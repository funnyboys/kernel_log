commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index a9ad4379523b..b75f78f2c4b8 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -1,22 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Advanced Linux Sound Architecture
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/init.h>

commit f4fa968950aef7efb98a0899bb0132405e2edaf1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 16 18:18:47 2019 +0200

    ALSA: core: Don't refer to snd_cards array directly
    
    The snd_cards[] array holds the card pointers that have been currently
    registered, and it's exported for the external modules that may need
    to refer a card object.  But accessing to this array can be racy
    against the driver probe or removal, as the card registration or free
    may happen concurrently.
    
    This patch gets rid of the direct access to snd_cards[] array and
    provides a helper function to give the card object from the index
    number with a refcount management.  Then the caller can access to the
    given card object safely, and releases it via snd_card_unref().
    
    While we're at it, add a proper comment to snd_card_unref() and make
    it an inlined function for type-safety, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index b30f027eb0fe..a9ad4379523b 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -134,8 +134,11 @@ static struct snd_minor *autoload_device(unsigned int minor)
 	if (dev == SNDRV_MINOR_CONTROL) {
 		/* /dev/aloadC? */
 		int card = SNDRV_MINOR_CARD(minor);
-		if (snd_cards[card] == NULL)
+		struct snd_card *ref = snd_card_ref(card);
+		if (!ref)
 			snd_request_card(card);
+		else
+			snd_card_unref(ref);
 	} else if (dev == SNDRV_MINOR_GLOBAL) {
 		/* /dev/aloadSEQ */
 		snd_request_other(minor);

commit 35f8001415d301ba47124f463f98eee0e7d0792c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 16 16:16:33 2017 +0200

    ALSA: core: Follow standard EXPORT_SYMBOL() declarations
    
    Just a tidy up to follow the standard EXPORT_SYMBOL*() declarations
    in order to improve grep-ability.
    
    - Move EXPORT_SYMBOL*() to the position right after its definition
    - Remove superfluous blank line before EXPORT_SYMBOL*() lines
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 175f9e4e01c8..b30f027eb0fe 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -74,7 +74,6 @@ void snd_request_card(int card)
 		return;
 	request_module("snd-card-%i", card);
 }
-
 EXPORT_SYMBOL(snd_request_card);
 
 static void snd_request_other(int minor)
@@ -124,7 +123,6 @@ void *snd_lookup_minor_data(unsigned int minor, int type)
 	mutex_unlock(&sound_mutex);
 	return private_data;
 }
-
 EXPORT_SYMBOL(snd_lookup_minor_data);
 
 #ifdef CONFIG_MODULES

commit cd6a65036f0eac4ad83dc371bb458e9e6ba6e306
Author: Jie Yang <yang.jie@intel.com>
Date:   Wed May 27 19:45:45 2015 +0800

    ALSA: replace CONFIG_PROC_FS with CONFIG_SND_PROC_FS
    
    We may disable proc fs only for sound part, to reduce ALSA
    memory footprint. So add CONFIG_SND_PROC_FS and replace the
    old CONFIG_PROC_FSs in alsa code.
    
    With sound proc fs disabled, we can save about 9KB memory
    size on X86_64 platform.
    
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index e5d37bd7c226..175f9e4e01c8 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -330,7 +330,7 @@ int snd_unregister_device(struct device *dev)
 }
 EXPORT_SYMBOL(snd_unregister_device);
 
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_SND_PROC_FS
 /*
  *  INFO PART
  */
@@ -391,7 +391,7 @@ int __init snd_minor_info_init(void)
 	entry->c.text.read = snd_minor_info_read;
 	return snd_info_register(entry); /* freed in error path */
 }
-#endif /* CONFIG_PROC_FS */
+#endif /* CONFIG_SND_PROC_FS */
 
 /*
  *  INIT PART

commit a0dca822e923e605dbdc2f6ed4fcd96b74df9258
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 23 10:56:21 2015 +0200

    ALSA: core: Clean up OSS proc file management
    
    A few minor cleanups:
    - Move the call of snd_info_minor_register() into snd_info_init() so
      that we can call all proc-related stuff in a shot
    - Add missing __init prefix to snd_info_minor_register()
    - Return an error properly from snd_oss_info_register()
    - Drop snd_info_minor_unregister() that is superfluous now
    
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 8fc402e4ff35..e5d37bd7c226 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -409,7 +409,6 @@ static int __init alsa_sound_init(void)
 		unregister_chrdev(major, "alsa");
 		return -ENOMEM;
 	}
-	snd_info_minor_register();
 #ifndef MODULE
 	pr_info("Advanced Linux Sound Architecture Driver Initialized.\n");
 #endif
@@ -418,7 +417,6 @@ static int __init alsa_sound_init(void)
 
 static void __exit alsa_sound_exit(void)
 {
-	snd_info_minor_unregister();
 	snd_info_done();
 	unregister_chrdev(major, "alsa");
 }

commit b591b6e9e99017137888e2e397f0ddd8adb77c5d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 22 22:29:10 2015 +0200

    ALSA: core: Don't ignore errors at creating proc files
    
    So far we've ignored the errors at creating proc files in many places.
    But they should be rather treated seriously.
    
    Also, by assuring the error handling, we can get rid of superfluous
    snd_info_free_entry() calls as they will be removed by the parent in
    the caller side.
    
    This patch fixes the missing error checks and reduces the superfluous
    free calls.
    
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index d584944c8fe5..8fc402e4ff35 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -386,14 +386,10 @@ int __init snd_minor_info_init(void)
 	struct snd_info_entry *entry;
 
 	entry = snd_info_create_module_entry(THIS_MODULE, "devices", NULL);
-	if (entry) {
-		entry->c.text.read = snd_minor_info_read;
-		if (snd_info_register(entry) < 0) {
-			snd_info_free_entry(entry);
-			entry = NULL;
-		}
-	}
-	return 0;
+	if (!entry)
+		return -ENOMEM;
+	entry->c.text.read = snd_minor_info_read;
+	return snd_info_register(entry); /* freed in error path */
 }
 #endif /* CONFIG_PROC_FS */
 

commit b046d244e2290e3d114af2e91503ee3d08fc605a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 22 21:33:41 2015 +0200

    ALSA: core: Remove superfluous exit calls for proc entries
    
    Since each proc entry is freed automatically by the parent, we don't
    have to take care of its life cycle any longer.  This allows us to
    reduce a few more lines of codes.
    
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 5fc93d00572a..d584944c8fe5 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -334,9 +334,6 @@ EXPORT_SYMBOL(snd_unregister_device);
 /*
  *  INFO PART
  */
-
-static struct snd_info_entry *snd_minor_info_entry;
-
 static const char *snd_device_type_name(int type)
 {
 	switch (type) {
@@ -396,13 +393,6 @@ int __init snd_minor_info_init(void)
 			entry = NULL;
 		}
 	}
-	snd_minor_info_entry = entry;
-	return 0;
-}
-
-int __exit snd_minor_info_done(void)
-{
-	snd_info_free_entry(snd_minor_info_entry);
 	return 0;
 }
 #endif /* CONFIG_PROC_FS */

commit 38ebb7034970efe5c7419267e499295e5893b565
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 6 14:45:33 2015 +0100

    ALSA: Consolidate snd_find_free_minor()
    
    A really small cleanup to consolidate snd_find_free_minor() and
    snd_kernel_minor() so that we can get rid of one more ifdef.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 185cec01ee25..5fc93d00572a 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -186,7 +186,7 @@ static const struct file_operations snd_fops =
 };
 
 #ifdef CONFIG_SND_DYNAMIC_MINORS
-static int snd_find_free_minor(int type)
+static int snd_find_free_minor(int type, struct snd_card *card, int dev)
 {
 	int minor;
 
@@ -209,7 +209,7 @@ static int snd_find_free_minor(int type)
 	return -EBUSY;
 }
 #else
-static int snd_kernel_minor(int type, struct snd_card *card, int dev)
+static int snd_find_free_minor(int type, struct snd_card *card, int dev)
 {
 	int minor;
 
@@ -237,6 +237,8 @@ static int snd_kernel_minor(int type, struct snd_card *card, int dev)
 	}
 	if (snd_BUG_ON(minor < 0 || minor >= SNDRV_OS_MINORS))
 		return -EINVAL;
+	if (snd_minors[minor])
+		return -EBUSY;
 	return minor;
 }
 #endif
@@ -276,13 +278,7 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	preg->private_data = private_data;
 	preg->card_ptr = card;
 	mutex_lock(&sound_mutex);
-#ifdef CONFIG_SND_DYNAMIC_MINORS
-	minor = snd_find_free_minor(type);
-#else
-	minor = snd_kernel_minor(type, card, dev);
-	if (minor >= 0 && snd_minors[minor])
-		minor = -EBUSY;
-#endif
+	minor = snd_find_free_minor(type, card, dev);
 	if (minor < 0) {
 		err = minor;
 		goto error;

commit 830953c0724b42be30a74febcde6c89c706ed286
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 30 08:39:40 2015 +0100

    ALSA: Drop snd_get_device() helper
    
    Since the device is no longer hidden but embedded into each component,
    we no longer need snd_get_device().  Let's drop it and relevant codes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 2e8aeb18d76b..185cec01ee25 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -303,24 +303,6 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 }
 EXPORT_SYMBOL(snd_register_device);
 
-/* find the matching minor record
- * return the index of snd_minor, or -1 if not found
- */
-static int find_snd_minor(int type, struct snd_card *card, int dev)
-{
-	int cardnum, minor;
-	struct snd_minor *mptr;
-
-	cardnum = card ? card->number : -1;
-	for (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor)
-		if ((mptr = snd_minors[minor]) != NULL &&
-		    mptr->type == type &&
-		    mptr->card == cardnum &&
-		    mptr->device == dev)
-			return minor;
-	return -1;
-}
-
 /**
  * snd_unregister_device - unregister the device on the given card
  * @dev: the device instance
@@ -352,31 +334,6 @@ int snd_unregister_device(struct device *dev)
 }
 EXPORT_SYMBOL(snd_unregister_device);
 
-/**
- * snd_get_device - get the assigned device to the given type and device number
- * @type: the device type, SNDRV_DEVICE_TYPE_XXX
- * @card:the card instance
- * @dev: the device index
- *
- * The caller needs to release it via put_device() after using it.
- */
-struct device *snd_get_device(int type, struct snd_card *card, int dev)
-{
-	int minor;
-	struct device *d = NULL;
-
-	mutex_lock(&sound_mutex);
-	minor = find_snd_minor(type, card, dev);
-	if (minor >= 0) {
-		d = snd_minors[minor]->dev;
-		if (d)
-			get_device(d);
-	}
-	mutex_unlock(&sound_mutex);
-	return d;
-}
-EXPORT_SYMBOL(snd_get_device);
-
 #ifdef CONFIG_PROC_FS
 /*
  *  INFO PART

commit 40a4b263854346fe7c7d1c3964c106296f690816
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 30 08:34:58 2015 +0100

    ALSA: Simplify snd_device_register() variants
    
    Now that all callers have been replaced with
    snd_device_register_for_dev(), let's drop the obsolete device
    registration code and concentrate only on the code handling struct
    device directly.  That said,
    
    - remove the old snd_device_register(),
    - rename snd_device_register_for_dev() with snd_device_register(),
    - drop superfluous arguments from snd_device_register(),
    - change snd_unregister_device() to pass the device pointer directly
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index ea1af1acdbe9..2e8aeb18d76b 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -242,30 +242,30 @@ static int snd_kernel_minor(int type, struct snd_card *card, int dev)
 #endif
 
 /**
- * snd_register_device_for_dev - Register the ALSA device file for the card
+ * snd_register_device - Register the ALSA device file for the card
  * @type: the device type, SNDRV_DEVICE_TYPE_XXX
  * @card: the card instance
  * @dev: the device index
  * @f_ops: the file operations
  * @private_data: user pointer for f_ops->open()
- * @device: the device to register, NULL to create a new one
- * @parent: the &struct device to link this new device to (only for device=NULL)
- * @name: the device file name (only for device=NULL)
+ * @device: the device to register
  *
  * Registers an ALSA device file for the given card.
  * The operators have to be set in reg parameter.
  *
  * Return: Zero if successful, or a negative error code on failure.
  */
-int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
-				const struct file_operations *f_ops,
-				void *private_data, struct device *device,
-				struct device *parent, const char *name)
+int snd_register_device(int type, struct snd_card *card, int dev,
+			const struct file_operations *f_ops,
+			void *private_data, struct device *device)
 {
 	int minor;
 	int err = 0;
 	struct snd_minor *preg;
 
+	if (snd_BUG_ON(!device))
+		return -EINVAL;
+
 	preg = kmalloc(sizeof *preg, GFP_KERNEL);
 	if (preg == NULL)
 		return -ENOMEM;
@@ -288,19 +288,9 @@ int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
 		goto error;
 	}
 
-	if (device) {
-		preg->created = false;
-		preg->dev = device;
-		device->devt = MKDEV(major, minor);
-		err = device_add(device);
-	} else {
-		preg->created = true;
-		preg->dev = device_create(sound_class, parent,
-					  MKDEV(major, minor), private_data,
-					  "%s", name);
-		if (IS_ERR(preg->dev))
-			err = PTR_ERR(preg->dev);
-	}
+	preg->dev = device;
+	device->devt = MKDEV(major, minor);
+	err = device_add(device);
 	if (err < 0)
 		goto error;
 
@@ -311,8 +301,7 @@ int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
 		kfree(preg);
 	return err;
 }
-
-EXPORT_SYMBOL(snd_register_device_for_dev);
+EXPORT_SYMBOL(snd_register_device);
 
 /* find the matching minor record
  * return the index of snd_minor, or -1 if not found
@@ -334,39 +323,33 @@ static int find_snd_minor(int type, struct snd_card *card, int dev)
 
 /**
  * snd_unregister_device - unregister the device on the given card
- * @type: the device type, SNDRV_DEVICE_TYPE_XXX
- * @card: the card instance
- * @dev: the device index
+ * @dev: the device instance
  *
  * Unregisters the device file already registered via
  * snd_register_device().
  *
  * Return: Zero if successful, or a negative error code on failure.
  */
-int snd_unregister_device(int type, struct snd_card *card, int dev)
+int snd_unregister_device(struct device *dev)
 {
 	int minor;
 	struct snd_minor *preg;
 
 	mutex_lock(&sound_mutex);
-	minor = find_snd_minor(type, card, dev);
-	if (minor < 0) {
-		mutex_unlock(&sound_mutex);
-		return -EINVAL;
+	for (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor) {
+		preg = snd_minors[minor];
+		if (preg && preg->dev == dev) {
+			snd_minors[minor] = NULL;
+			device_del(dev);
+			kfree(preg);
+			break;
+		}
 	}
-
-	preg = snd_minors[minor];
-	if (preg && !preg->created)
-		device_del(preg->dev);
-	else
-		device_destroy(sound_class, MKDEV(major, minor));
-
-	kfree(snd_minors[minor]);
-	snd_minors[minor] = NULL;
 	mutex_unlock(&sound_mutex);
+	if (minor >= ARRAY_SIZE(snd_minors))
+		return -ENOENT;
 	return 0;
 }
-
 EXPORT_SYMBOL(snd_unregister_device);
 
 /**

commit 92b7952da8279189aad352efbf9f2e7001de9524
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 29 15:53:51 2015 +0100

    ALSA: Allow to pass the device object to snd_register_device*()
    
    This is a preliminary patch for the further work on embedding struct
    device into each sound device instance.  It changes
    snd_register_device*() helpers to receive the device object directly
    for skipping creating a device there.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index f1333060bf1c..ea1af1acdbe9 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -248,8 +248,9 @@ static int snd_kernel_minor(int type, struct snd_card *card, int dev)
  * @dev: the device index
  * @f_ops: the file operations
  * @private_data: user pointer for f_ops->open()
- * @name: the device file name
- * @device: the &struct device to link this new device to
+ * @device: the device to register, NULL to create a new one
+ * @parent: the &struct device to link this new device to (only for device=NULL)
+ * @name: the device file name (only for device=NULL)
  *
  * Registers an ALSA device file for the given card.
  * The operators have to be set in reg parameter.
@@ -258,14 +259,13 @@ static int snd_kernel_minor(int type, struct snd_card *card, int dev)
  */
 int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
 				const struct file_operations *f_ops,
-				void *private_data,
-				const char *name, struct device *device)
+				void *private_data, struct device *device,
+				struct device *parent, const char *name)
 {
 	int minor;
+	int err = 0;
 	struct snd_minor *preg;
 
-	if (snd_BUG_ON(!name))
-		return -EINVAL;
 	preg = kmalloc(sizeof *preg, GFP_KERNEL);
 	if (preg == NULL)
 		return -ENOMEM;
@@ -284,23 +284,32 @@ int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
 		minor = -EBUSY;
 #endif
 	if (minor < 0) {
-		mutex_unlock(&sound_mutex);
-		kfree(preg);
-		return minor;
+		err = minor;
+		goto error;
 	}
-	snd_minors[minor] = preg;
-	preg->dev = device_create(sound_class, device, MKDEV(major, minor),
-				  private_data, "%s", name);
-	if (IS_ERR(preg->dev)) {
-		snd_minors[minor] = NULL;
-		mutex_unlock(&sound_mutex);
-		minor = PTR_ERR(preg->dev);
-		kfree(preg);
-		return minor;
+
+	if (device) {
+		preg->created = false;
+		preg->dev = device;
+		device->devt = MKDEV(major, minor);
+		err = device_add(device);
+	} else {
+		preg->created = true;
+		preg->dev = device_create(sound_class, parent,
+					  MKDEV(major, minor), private_data,
+					  "%s", name);
+		if (IS_ERR(preg->dev))
+			err = PTR_ERR(preg->dev);
 	}
+	if (err < 0)
+		goto error;
 
+	snd_minors[minor] = preg;
+ error:
 	mutex_unlock(&sound_mutex);
-	return 0;
+	if (err < 0)
+		kfree(preg);
+	return err;
 }
 
 EXPORT_SYMBOL(snd_register_device_for_dev);
@@ -337,6 +346,7 @@ static int find_snd_minor(int type, struct snd_card *card, int dev)
 int snd_unregister_device(int type, struct snd_card *card, int dev)
 {
 	int minor;
+	struct snd_minor *preg;
 
 	mutex_lock(&sound_mutex);
 	minor = find_snd_minor(type, card, dev);
@@ -345,7 +355,11 @@ int snd_unregister_device(int type, struct snd_card *card, int dev)
 		return -EINVAL;
 	}
 
-	device_destroy(sound_class, MKDEV(major, minor));
+	preg = snd_minors[minor];
+	if (preg && !preg->created)
+		device_del(preg->dev);
+	else
+		device_destroy(sound_class, MKDEV(major, minor));
 
 	kfree(snd_minors[minor]);
 	snd_minors[minor] = NULL;

commit eb9c38d54c9cad72101dfe7fefe4a784dd67da86
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 30 15:19:43 2014 +0100

    ALSA: doc: More kerneldoc comments on core components
    
    Some functions missed the proper kerneldoc comments.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 38ad1a0dd3f7..f1333060bf1c 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -355,8 +355,13 @@ int snd_unregister_device(int type, struct snd_card *card, int dev)
 
 EXPORT_SYMBOL(snd_unregister_device);
 
-/* get the assigned device to the given type and device number;
- * the caller needs to release it via put_device() after using it
+/**
+ * snd_get_device - get the assigned device to the given type and device number
+ * @type: the device type, SNDRV_DEVICE_TYPE_XXX
+ * @card:the card instance
+ * @dev: the device index
+ *
+ * The caller needs to release it via put_device() after using it.
  */
 struct device *snd_get_device(int type, struct snd_card *card, int dev)
 {

commit caa751bad444268d756b48ca03d7cceda3430cc8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 08:30:50 2014 +0100

    ALSA: Create sysfs attribute files via groups
    
    Instead of calling each time device_create_file(), create the groups
    of sysfs attribute files at once in a normal way.  Add a new helper
    function, snd_get_device(), to return the associated device object,
    so that we can handle the sysfs addition locally.
    
    Since the sysfs file addition is done differently now,
    snd_add_device_sysfs_file() helper function is removed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 60ab9b1f44b9..38ad1a0dd3f7 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -355,22 +355,25 @@ int snd_unregister_device(int type, struct snd_card *card, int dev)
 
 EXPORT_SYMBOL(snd_unregister_device);
 
-int snd_add_device_sysfs_file(int type, struct snd_card *card, int dev,
-			      struct device_attribute *attr)
+/* get the assigned device to the given type and device number;
+ * the caller needs to release it via put_device() after using it
+ */
+struct device *snd_get_device(int type, struct snd_card *card, int dev)
 {
-	int minor, ret = -EINVAL;
-	struct device *d;
+	int minor;
+	struct device *d = NULL;
 
 	mutex_lock(&sound_mutex);
 	minor = find_snd_minor(type, card, dev);
-	if (minor >= 0 && (d = snd_minors[minor]->dev) != NULL)
-		ret = device_create_file(d, attr);
+	if (minor >= 0) {
+		d = snd_minors[minor]->dev;
+		if (d)
+			get_device(d);
+	}
 	mutex_unlock(&sound_mutex);
-	return ret;
-
+	return d;
 }
-
-EXPORT_SYMBOL(snd_add_device_sysfs_file);
+EXPORT_SYMBOL(snd_get_device);
 
 #ifdef CONFIG_PROC_FS
 /*

commit f2f9307a4f26a9fbe47fff486a9cee5885af748f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:21:03 2014 +0100

    ALSA: core: Use standard printk helpers
    
    Use dev_err() & co as much as possible.  If not available (no device
    assigned at the calling point), use pr_xxx() helpers instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 4aaa53161644..60ab9b1f44b9 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -458,7 +458,7 @@ static int __init alsa_sound_init(void)
 	snd_major = major;
 	snd_ecards_limit = cards_limit;
 	if (register_chrdev(major, "alsa", &snd_fops)) {
-		snd_printk(KERN_ERR "unable to register native major device number %d\n", major);
+		pr_err("ALSA core: unable to register native major device number %d\n", major);
 		return -EIO;
 	}
 	if (snd_info_init() < 0) {
@@ -467,7 +467,7 @@ static int __init alsa_sound_init(void)
 	}
 	snd_info_minor_register();
 #ifndef MODULE
-	printk(KERN_INFO "Advanced Linux Sound Architecture Driver Initialized.\n");
+	pr_info("Advanced Linux Sound Architecture Driver Initialized.\n");
 #endif
 	return 0;
 }

commit f24640648186b59bd39f8cd640d631bdb61a3197
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 12:13:43 2014 +0100

    ALSA: Use standard device refcount for card accounting
    
    Drop the own refcount but use the standard device refcounting via
    get_device() and put_device().  Introduce a new completion to snd_card
    instead of the wait queue for syncing the last release, which is used
    in snd_card_free().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 437c25ea6403..4aaa53161644 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -118,7 +118,7 @@ void *snd_lookup_minor_data(unsigned int minor, int type)
 	if (mreg && mreg->type == type) {
 		private_data = mreg->private_data;
 		if (private_data && mreg->card_ptr)
-			atomic_inc(&mreg->card_ptr->refcount);
+			get_device(&mreg->card_ptr->card_dev);
 	} else
 		private_data = NULL;
 	mutex_unlock(&sound_mutex);

commit e84f9e57b90ca89664d733a7cef19aa7ccd832f3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Sep 22 14:17:15 2013 -0400

    consolidate the reassignments of ->f_op in ->open() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index f002bd911dae..437c25ea6403 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -153,7 +153,7 @@ static int snd_open(struct inode *inode, struct file *file)
 {
 	unsigned int minor = iminor(inode);
 	struct snd_minor *mptr = NULL;
-	const struct file_operations *old_fops;
+	const struct file_operations *new_fops;
 	int err = 0;
 
 	if (minor >= ARRAY_SIZE(snd_minors))
@@ -167,24 +167,14 @@ static int snd_open(struct inode *inode, struct file *file)
 			return -ENODEV;
 		}
 	}
-	old_fops = file->f_op;
-	file->f_op = fops_get(mptr->f_ops);
-	if (file->f_op == NULL) {
-		file->f_op = old_fops;
-		err = -ENODEV;
-	}
+	new_fops = fops_get(mptr->f_ops);
 	mutex_unlock(&sound_mutex);
-	if (err < 0)
-		return err;
+	if (!new_fops)
+		return -ENODEV;
+	replace_fops(file, new_fops);
 
-	if (file->f_op->open) {
+	if (file->f_op->open)
 		err = file->f_op->open(inode, file);
-		if (err) {
-			fops_put(file->f_op);
-			file->f_op = fops_get(old_fops);
-		}
-	}
-	fops_put(old_fops);
 	return err;
 }
 

commit eb7c06e8e9c93b495e355421cffd3c43c266d7d2
Author: Yacine Belkadi <yacine.belkadi.1@gmail.com>
Date:   Mon Mar 11 22:05:14 2013 +0100

    ALSA: add/change some comments describing function return values
    
    script/kernel-doc reports the following type of warnings (when run in verbose
    mode):
    
    Warning(sound/core/init.c:152): No description found for return value of
    'snd_card_create'
    
    To fix that:
    - add missing descriptions of function return values
    - use "Return:" sections to describe those return values
    
    Along the way:
    - complete some descriptions
    - fix some typos
    
    Signed-off-by: Yacine Belkadi <yacine.belkadi.1@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 70ccdab74153..f002bd911dae 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -102,6 +102,9 @@ static void snd_request_other(int minor)
  * This function increments the reference counter of the card instance
  * if an associated instance with the given minor number and type is found.
  * The caller must call snd_card_unref() appropriately later.
+ *
+ * Return: The user data pointer if the specified device is found. %NULL
+ * otherwise.
  */
 void *snd_lookup_minor_data(unsigned int minor, int type)
 {
@@ -261,7 +264,7 @@ static int snd_kernel_minor(int type, struct snd_card *card, int dev)
  * Registers an ALSA device file for the given card.
  * The operators have to be set in reg parameter.
  *
- * Returns zero if successful, or a negative error code on failure.
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
 				const struct file_operations *f_ops,
@@ -339,7 +342,7 @@ static int find_snd_minor(int type, struct snd_card *card, int dev)
  * Unregisters the device file already registered via
  * snd_register_device().
  *
- * Returns zero if sucecessful, or a negative error code on failure
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_unregister_device(int type, struct snd_card *card, int dev)
 {

commit 8bb4d9ce08b0a92ca174e41d92c180328f86173f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 8 14:36:18 2012 +0100

    ALSA: Fix card refcount unbalance
    
    There are uncovered cases whether the card refcount introduced by the
    commit a0830dbd isn't properly increased or decreased:
    - OSS PCM and mixer success paths
    - When lookup function gets NULL
    
    This patch fixes these places.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=50251
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 89780c323f19..70ccdab74153 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -114,7 +114,7 @@ void *snd_lookup_minor_data(unsigned int minor, int type)
 	mreg = snd_minors[minor];
 	if (mreg && mreg->type == type) {
 		private_data = mreg->private_data;
-		if (mreg->card_ptr)
+		if (private_data && mreg->card_ptr)
 			atomic_inc(&mreg->card_ptr->refcount);
 	} else
 		private_data = NULL;

commit a0830dbd4e42b38aefdf3fb61ba5019a1a99ea85
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 16 13:05:59 2012 +0200

    ALSA: Add a reference counter to card instance
    
    For more strict protection for wild disconnections, a refcount is
    introduced to the card instance, and let it up/down when an object is
    referred via snd_lookup_*() in the open ops.
    
    The free-after-last-close check is also changed to check this refcount
    instead of the empty list, too.
    
    Reported-by: Matthieu CASTET <matthieu.castet@parrot.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 643976000ce8..89780c323f19 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -98,6 +98,10 @@ static void snd_request_other(int minor)
  *
  * Checks that a minor device with the specified type is registered, and returns
  * its user data pointer.
+ *
+ * This function increments the reference counter of the card instance
+ * if an associated instance with the given minor number and type is found.
+ * The caller must call snd_card_unref() appropriately later.
  */
 void *snd_lookup_minor_data(unsigned int minor, int type)
 {
@@ -108,9 +112,11 @@ void *snd_lookup_minor_data(unsigned int minor, int type)
 		return NULL;
 	mutex_lock(&sound_mutex);
 	mreg = snd_minors[minor];
-	if (mreg && mreg->type == type)
+	if (mreg && mreg->type == type) {
 		private_data = mreg->private_data;
-	else
+		if (mreg->card_ptr)
+			atomic_inc(&mreg->card_ptr->refcount);
+	} else
 		private_data = NULL;
 	mutex_unlock(&sound_mutex);
 	return private_data;
@@ -275,6 +281,7 @@ int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
 	preg->device = dev;
 	preg->f_ops = f_ops;
 	preg->private_data = private_data;
+	preg->card_ptr = card;
 	mutex_lock(&sound_mutex);
 #ifdef CONFIG_SND_DYNAMIC_MINORS
 	minor = snd_find_free_minor(type);

commit 4266274836e81575ee82498d84f4bd08ab7a7378
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Tue Sep 4 11:21:45 2012 +0200

    ALSA: remove the main version information
    
    Remove the main ALSA version number from the kernel ALSA driver.
    The ALSA driver package release diverges from the upstream. This may
    confuse users to see the same ALSA version for many kernel releases
    and this version lost it's original purpose and connection.
    
    The "ioctl" APIs have own version numbers, so the user space may check
    for specific API changes only.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 28f35593a750..643976000ce8 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -27,7 +27,6 @@
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/info.h>
-#include <sound/version.h>
 #include <sound/control.h>
 #include <sound/initval.h>
 #include <linux/kmod.h>
@@ -468,7 +467,7 @@ static int __init alsa_sound_init(void)
 	}
 	snd_info_minor_register();
 #ifndef MODULE
-	printk(KERN_INFO "Advanced Linux Sound Architecture Driver Version " CONFIG_SND_VERSION CONFIG_SND_DATE ".\n");
+	printk(KERN_INFO "Advanced Linux Sound Architecture Driver Initialized.\n");
 #endif
 	return 0;
 }

commit 3eafc959b32f71d3fe6b27c9eae7495a23acfc3a
Author: Omair Mohammed Abdullah <omair.m.abdullah@intel.com>
Date:   Fri Dec 23 10:36:36 2011 +0530

    ALSA: core: add support for compressed devices
    
    Use the minor numbers 2 and 3 for audio compressed offload devices.
    Also add support for these devices in core
    
    Signed-off-by: Omair Mohammed Abdullah <omair.m.abdullah@intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 828af353ea9f..28f35593a750 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -229,6 +229,7 @@ static int snd_kernel_minor(int type, struct snd_card *card, int dev)
 	case SNDRV_DEVICE_TYPE_RAWMIDI:
 	case SNDRV_DEVICE_TYPE_PCM_PLAYBACK:
 	case SNDRV_DEVICE_TYPE_PCM_CAPTURE:
+	case SNDRV_DEVICE_TYPE_COMPRESS:
 		if (snd_BUG_ON(!card))
 			return -EINVAL;
 		minor = SNDRV_MINOR(card->number, type + dev);

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 1c7a3efe1778..828af353ea9f 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -23,7 +23,7 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/device.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/info.h>

commit 354d14b3f53cc749c5d26d4ba7280d1e931d6bc4
Merge: 5144c534d165 5b84ba26a967
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 13 09:29:52 2010 +0100

    Merge branch 'topic/workq-update' into topic/misc

commit 03cfe6f57dc5c13ccdd235c23c80e3fa170f03d1
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Nov 23 17:43:19 2010 +0100

    ALSA: support module on-demand loading for seq and timer
    
    If CONFIG_SND_DYNAMIC_MINORS is used, assign /dev/snd/seq and
    /dev/snd/timer the usual static minors, and export specific
    module aliases to generate udev module on-demand loading
    instructions:
    
      $ cat /lib/modules/2.6.33.4-smp/modules.devname
      # Device nodes to trigger on-demand module loading.
      microcode cpu/microcode c10:184
      fuse fuse c10:229
      ppp_generic ppp c108:0
      tun net/tun c10:200
      uinput uinput c10:223
      dm_mod mapper/control c10:236
      snd_timer snd/timer c116:33
      snd_seq snd/seq c116:1
    
    The last two lines instruct udev to create device nodes, even
    when the modules are not loaded at that time.
    
    As soon as userspace accesses any of these nodes, the in-kernel
    module-loader will load the module, and the device can be used.
    
    The header file minor calculation needed to be simplified to
    make __stringify() (supports only two indirections) in
    the MODULE_ALIAS macro work.
    
    This is part of systemd's effort to get rid of unconditional
    module load instructions and needless init scripts.
    
    Cc: Lennart Poettering <lennart@poettering.net>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 62a093efb453..345caea2d749 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -189,14 +189,22 @@ static const struct file_operations snd_fops =
 };
 
 #ifdef CONFIG_SND_DYNAMIC_MINORS
-static int snd_find_free_minor(void)
+static int snd_find_free_minor(int type)
 {
 	int minor;
 
+	/* static minors for module auto loading */
+	if (type == SNDRV_DEVICE_TYPE_SEQUENCER)
+		return SNDRV_MINOR_SEQUENCER;
+	if (type == SNDRV_DEVICE_TYPE_TIMER)
+		return SNDRV_MINOR_TIMER;
+
 	for (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor) {
-		/* skip minors still used statically for autoloading devices */
-		if (SNDRV_MINOR_DEVICE(minor) == SNDRV_MINOR_CONTROL ||
-		    minor == SNDRV_MINOR_SEQUENCER)
+		/* skip static minors still used for module auto loading */
+		if (SNDRV_MINOR_DEVICE(minor) == SNDRV_MINOR_CONTROL)
+			continue;
+		if (minor == SNDRV_MINOR_SEQUENCER ||
+		    minor == SNDRV_MINOR_TIMER)
 			continue;
 		if (!snd_minors[minor])
 			return minor;
@@ -270,7 +278,7 @@ int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
 	preg->private_data = private_data;
 	mutex_lock(&sound_mutex);
 #ifdef CONFIG_SND_DYNAMIC_MINORS
-	minor = snd_find_free_minor();
+	minor = snd_find_free_minor(type);
 #else
 	minor = snd_kernel_minor(type, card, dev);
 	if (minor >= 0 && snd_minors[minor])

commit 451a3c24b0135bce54542009b5fde43846c7cf67
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 17 16:26:55 2010 +0100

    BKL: remove extraneous #include <smp_lock.h>
    
    The big kernel lock has been removed from all these files at some point,
    leaving only the #include.
    
    Remove this too as a cleanup.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 62a093efb453..66691fe437e6 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -21,7 +21,6 @@
 
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/time.h>
 #include <linux/device.h>
 #include <linux/moduleparam.h>

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index ac42af42b787..62a093efb453 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -184,7 +184,8 @@ static int snd_open(struct inode *inode, struct file *file)
 static const struct file_operations snd_fops =
 {
 	.owner =	THIS_MODULE,
-	.open =		snd_open
+	.open =		snd_open,
+	.llseek =	noop_llseek,
 };
 
 #ifdef CONFIG_SND_DYNAMIC_MINORS

commit 4cf19b848f92641eeb2585949a09eedec57fb53a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 7 18:52:08 2010 +0200

    ALSA: Remove BKL from open multiplexer
    
    Use a local mutex instead of BKL.  This should suffice since each device
    type has also its open_mutex.
    Also, a bit of clean-up of the legacy device auto-loading code.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 563d1967a0ad..ac42af42b787 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -120,7 +120,29 @@ void *snd_lookup_minor_data(unsigned int minor, int type)
 
 EXPORT_SYMBOL(snd_lookup_minor_data);
 
-static int __snd_open(struct inode *inode, struct file *file)
+#ifdef CONFIG_MODULES
+static struct snd_minor *autoload_device(unsigned int minor)
+{
+	int dev;
+	mutex_unlock(&sound_mutex); /* release lock temporarily */
+	dev = SNDRV_MINOR_DEVICE(minor);
+	if (dev == SNDRV_MINOR_CONTROL) {
+		/* /dev/aloadC? */
+		int card = SNDRV_MINOR_CARD(minor);
+		if (snd_cards[card] == NULL)
+			snd_request_card(card);
+	} else if (dev == SNDRV_MINOR_GLOBAL) {
+		/* /dev/aloadSEQ */
+		snd_request_other(minor);
+	}
+	mutex_lock(&sound_mutex); /* reacuire lock */
+	return snd_minors[minor];
+}
+#else /* !CONFIG_MODULES */
+#define autoload_device(minor)	NULL
+#endif /* CONFIG_MODULES */
+
+static int snd_open(struct inode *inode, struct file *file)
 {
 	unsigned int minor = iminor(inode);
 	struct snd_minor *mptr = NULL;
@@ -129,55 +151,36 @@ static int __snd_open(struct inode *inode, struct file *file)
 
 	if (minor >= ARRAY_SIZE(snd_minors))
 		return -ENODEV;
+	mutex_lock(&sound_mutex);
 	mptr = snd_minors[minor];
 	if (mptr == NULL) {
-#ifdef CONFIG_MODULES
-		int dev = SNDRV_MINOR_DEVICE(minor);
-		if (dev == SNDRV_MINOR_CONTROL) {
-			/* /dev/aloadC? */
-			int card = SNDRV_MINOR_CARD(minor);
-			if (snd_cards[card] == NULL)
-				snd_request_card(card);
-		} else if (dev == SNDRV_MINOR_GLOBAL) {
-			/* /dev/aloadSEQ */
-			snd_request_other(minor);
-		}
-#ifndef CONFIG_SND_DYNAMIC_MINORS
-		/* /dev/snd/{controlC?,seq} */
-		mptr = snd_minors[minor];
-		if (mptr == NULL)
-#endif
-#endif
+		mptr = autoload_device(minor);
+		if (!mptr) {
+			mutex_unlock(&sound_mutex);
 			return -ENODEV;
+		}
 	}
 	old_fops = file->f_op;
 	file->f_op = fops_get(mptr->f_ops);
 	if (file->f_op == NULL) {
 		file->f_op = old_fops;
-		return -ENODEV;
+		err = -ENODEV;
 	}
-	if (file->f_op->open)
+	mutex_unlock(&sound_mutex);
+	if (err < 0)
+		return err;
+
+	if (file->f_op->open) {
 		err = file->f_op->open(inode, file);
-	if (err) {
-		fops_put(file->f_op);
-		file->f_op = fops_get(old_fops);
+		if (err) {
+			fops_put(file->f_op);
+			file->f_op = fops_get(old_fops);
+		}
 	}
 	fops_put(old_fops);
 	return err;
 }
 
-
-/* BKL pushdown: nasty #ifdef avoidance wrapper */
-static int snd_open(struct inode *inode, struct file *file)
-{
-	int ret;
-
-	lock_kernel();
-	ret = __snd_open(inode, file);
-	unlock_kernel();
-	return ret;
-}
-
 static const struct file_operations snd_fops =
 {
 	.owner =	THIS_MODULE,

commit c181a13a41ef32c9037393f4b42b780e1a36eb91
Author: Thadeu Lima de Souza Cascardo <cascardo@holoscopio.com>
Date:   Tue Jan 12 20:20:39 2010 -0200

    ALSA: use subsys_initcall for sound core instead of module_init
    
    This is needed for built-in drivers which are built before the sound directory,
    like thinkpad_acpi.
    
    Otherwise, registering a card fails.
    
    Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@holoscopio.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 7872a02f6ca9..563d1967a0ad 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -468,5 +468,5 @@ static void __exit alsa_sound_exit(void)
 	unregister_chrdev(major, "alsa");
 }
 
-module_init(alsa_sound_init)
-module_exit(alsa_sound_exit)
+subsys_initcall(alsa_sound_init);
+module_exit(alsa_sound_exit);

commit f41ced8f108cc80f16509b907cd7ac93944459bc
Author: Laurent Pinchart <laurent.pinchart@skynet.be>
Date:   Tue Jan 6 14:40:40 2009 -0800

    Check fops_get() return value
    
    Several subsystem open handlers dereference the fops_get() return value
    without checking it for nullness.  This opens a race condition between the
    open handler and module unloading.
    
    A module can be marked as being unloaded (MODULE_STATE_GOING) before its
    exit function is called and gets the chance to unregister the driver.
    During that window open handlers can still be called, and fops_get() will
    fail in try_module_get() and return a NULL pointer.
    
    This change checks the fops_get() return value and returns -ENODEV if NULL.
    
    Reported-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Signed-off-by: Laurent Pinchart <laurent.pinchart@skynet.be>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Dave Airlie <airlied@linux.ie>
    Acked-by: Mauro Carvalho Chehab <mchehab@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 44a69bb8d4f0..7872a02f6ca9 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -152,6 +152,10 @@ static int __snd_open(struct inode *inode, struct file *file)
 	}
 	old_fops = file->f_op;
 	file->f_op = fops_get(mptr->f_ops);
+	if (file->f_op == NULL) {
+		file->f_op = old_fops;
+		return -ENODEV;
+	}
 	if (file->f_op->open)
 		err = file->f_op->open(inode, file);
 	if (err) {

commit abe9ab8f62203ced11119fb96acc3b8dd107ebc4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jul 21 20:03:34 2008 -0700

    device create: sound: convert device_create_drvdata to device_create
    
    Now that device_create() has been audited, rename things back to the
    original call to be sane.
    
    Cc: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index c0685e2f0afa..44a69bb8d4f0 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -274,9 +274,8 @@ int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
 		return minor;
 	}
 	snd_minors[minor] = preg;
-	preg->dev = device_create_drvdata(sound_class, device,
-					  MKDEV(major, minor),
-					  private_data, "%s", name);
+	preg->dev = device_create(sound_class, device, MKDEV(major, minor),
+				  private_data, "%s", name);
 	if (IS_ERR(preg->dev)) {
 		snd_minors[minor] = NULL;
 		mutex_unlock(&sound_mutex);

commit 7eaa943c8ed8e91e05d0f5d0dc7a18e3319b45cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:09:09 2008 +0200

    ALSA: Kill snd_assert() in sound/core/*
    
    Kill snd_assert() in sound/core/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 838dd9ee957c..c0685e2f0afa 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -206,20 +206,23 @@ static int snd_kernel_minor(int type, struct snd_card *card, int dev)
 		minor = type;
 		break;
 	case SNDRV_DEVICE_TYPE_CONTROL:
-		snd_assert(card != NULL, return -EINVAL);
+		if (snd_BUG_ON(!card))
+			return -EINVAL;
 		minor = SNDRV_MINOR(card->number, type);
 		break;
 	case SNDRV_DEVICE_TYPE_HWDEP:
 	case SNDRV_DEVICE_TYPE_RAWMIDI:
 	case SNDRV_DEVICE_TYPE_PCM_PLAYBACK:
 	case SNDRV_DEVICE_TYPE_PCM_CAPTURE:
-		snd_assert(card != NULL, return -EINVAL);
+		if (snd_BUG_ON(!card))
+			return -EINVAL;
 		minor = SNDRV_MINOR(card->number, type + dev);
 		break;
 	default:
 		return -EINVAL;
 	}
-	snd_assert(minor >= 0 && minor < SNDRV_OS_MINORS, return -EINVAL);
+	if (snd_BUG_ON(minor < 0 || minor >= SNDRV_OS_MINORS))
+		return -EINVAL;
 	return minor;
 }
 #endif
@@ -247,7 +250,8 @@ int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
 	int minor;
 	struct snd_minor *preg;
 
-	snd_assert(name, return -EINVAL);
+	if (snd_BUG_ON(!name))
+		return -EINVAL;
 	preg = kmalloc(sizeof *preg, GFP_KERNEL);
 	if (preg == NULL)
 		return -ENOMEM;

commit f90c06a2b613eea24a77d56f24b084745c43713d
Author: Pawel MOLL <pawel.moll@st.com>
Date:   Wed Jul 30 12:46:40 2008 +0100

    ALSA: Fix limit of 8 PCM devices in SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE
    
    When compiled with CONFIG_SND_DYNAMIC_MINORS the ALSA core is fine
    to have more than 8 PCM devices per card, except one place - the
    SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE ioctl, which will not enumerate
    devices > 7. This patch fixes the issue, changing the devices list
    organisation.
    
    Instead of adding new device to the tail, the list is now kept always
    ordered (by card number, then device number). Thus, during enumeration,
    it is easy to discover the fact that there is no more given card's
    devices.
    
    Additionally the device field of struct snd_pcm had to be changed to int,
    as its "unsignednity" caused a lot of problems when comparing it to
    potentially negative signed values. (-1 is 0xffffffff or even more then ;-)
    
    Signed-off-by: Pawel Moll <pawel.moll@st.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 1003ae375d47..838dd9ee957c 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -34,8 +34,6 @@
 #include <linux/kmod.h>
 #include <linux/mutex.h>
 
-#define SNDRV_OS_MINORS 256
-
 static int major = CONFIG_SND_MAJOR;
 int snd_major;
 EXPORT_SYMBOL(snd_major);

commit 896e6cc20e67038af12e1a7711eef32647e62f23
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Aug 1 13:36:04 2008 +0200

    sound: Revert "ALSA: Fix limit of 8 PCM devices in SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE"
    
    This reverts commit fb3d6f2b77bdec75d45aa9d4464287ed87927866.
    
    New, updated patch with same subject replaces this commit.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 838dd9ee957c..1003ae375d47 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -34,6 +34,8 @@
 #include <linux/kmod.h>
 #include <linux/mutex.h>
 
+#define SNDRV_OS_MINORS 256
+
 static int major = CONFIG_SND_MAJOR;
 int snd_major;
 EXPORT_SYMBOL(snd_major);

commit 9423969005586e6e27ca380e01b4a8c50698e2af
Author: Pawel MOLL <pawel.moll@st.com>
Date:   Tue Jul 29 17:34:26 2008 +0100

    ALSA: Fix limit of 8 PCM devices in SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE
    
    When compiled with CONFIG_SND_DYNAMIC_MINORS the ALSA core is fine
    to have more than 8 PCM devices per card, except one place - the
    SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE ioctl, which will not enumerate
    devices > 7. This patch fixes the issue, changing the devices list
    organisation.
    
    Instead of adding new device to the tail, the list is now kept always
    ordered (by card number, then device number). Thus, during enumeration,
    it is easy to discover the fact that there is no more given card's
    devices. The same limit was present in OSS emulation code. It has
    been fixed as well.
    
    Additionally the device field of struct snd_pcm is now int, instead of
    unsigned int, as there is no obvious reason for keeping it unsigned.
    This caused a lot of problems with comparing this value with other
    (almost always signed) variables. There is just one more place where
    device number is unsigned - in struct snd_pcm_info, which should be
    also sorted out in future.
    
    Signed-off-by: Pawel MOLL <pawel.moll@st.com>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 1003ae375d47..838dd9ee957c 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -34,8 +34,6 @@
 #include <linux/kmod.h>
 #include <linux/mutex.h>
 
-#define SNDRV_OS_MINORS 256
-
 static int major = CONFIG_SND_MAJOR;
 int snd_major;
 EXPORT_SYMBOL(snd_major);

commit d1794f2c5b5817eb79ccc5e00701ca748d1b073a
Merge: a41eebab7537 2fceef397f98
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 14 14:48:31 2008 -0700

    Merge branch 'bkl-removal' of git://git.lwn.net/linux-2.6
    
    * 'bkl-removal' of git://git.lwn.net/linux-2.6: (146 commits)
      IB/umad: BKL is not needed for ib_umad_open()
      IB/uverbs: BKL is not needed for ib_uverbs_open()
      bf561-coreb: BKL unneeded for open()
      Call fasync() functions without the BKL
      snd/PCM: fasync BKL pushdown
      ipmi: fasync BKL pushdown
      ecryptfs: fasync BKL pushdown
      Bluetooth VHCI: fasync BKL pushdown
      tty_io: fasync BKL pushdown
      tun: fasync BKL pushdown
      i2o: fasync BKL pushdown
      mpt: fasync BKL pushdown
      Remove BKL from remote_llseek v2
      Make FAT users happier by not deadlocking
      x86-mce: BKL pushdown
      vmwatchdog: BKL pushdown
      vmcp: BKL pushdown
      via-pmu: BKL pushdown
      uml-random: BKL pushdown
      uml-mmapper: BKL pushdown
      ...

commit 2fceef397f9880b212a74c418290ce69e7ac00eb
Merge: feae1ef116ed bce7f793daec
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Mon Jul 14 15:29:34 2008 -0600

    Merge commit 'v2.6.26' into bkl-removal

commit ee2da99782d717b264d5c309a2084ca85e9a64ff
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Jul 9 10:28:41 2008 +0200

    ALSA: remove CONFIG_KMOD from sound
    
    A bunch of things in alsa depend on CONFIG_KMOD,
    use CONFIG_MODULES instead where the dependency
    is needed at all.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 6c8ab48c689a..09a94953745a 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -60,14 +60,14 @@ EXPORT_SYMBOL(snd_ecards_limit);
 static struct snd_minor *snd_minors[SNDRV_OS_MINORS];
 static DEFINE_MUTEX(sound_mutex);
 
-#ifdef CONFIG_KMOD
+#ifdef CONFIG_MODULES
 
 /**
  * snd_request_card - try to load the card module
  * @card: the card number
  *
  * Tries to load the module "snd-card-X" for the given card number
- * via KMOD.  Returns immediately if already loaded.
+ * via request_module.  Returns immediately if already loaded.
  */
 void snd_request_card(int card)
 {
@@ -92,7 +92,7 @@ static void snd_request_other(int minor)
 	request_module(str);
 }
 
-#endif				/* request_module support */
+#endif	/* modular kernel */
 
 /**
  * snd_lookup_minor_data - get user data of a registered device
@@ -132,7 +132,7 @@ static int snd_open(struct inode *inode, struct file *file)
 		return -ENODEV;
 	mptr = snd_minors[minor];
 	if (mptr == NULL) {
-#ifdef CONFIG_KMOD
+#ifdef CONFIG_MODULES
 		int dev = SNDRV_MINOR_DEVICE(minor);
 		if (dev == SNDRV_MINOR_CONTROL) {
 			/* /dev/aloadC? */

commit 78a3c3d7c6b89085610edfe86f7790144afc737e
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Thu May 15 16:39:03 2008 -0600

    sound: cdev lock_kernel() pushdown
    
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 812f91b3de5b..65b66fa6f97e 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -21,6 +21,7 @@
 
 #include <linux/init.h>
 #include <linux/slab.h>
+#include <linux/smp_lock.h>
 #include <linux/time.h>
 #include <linux/device.h>
 #include <linux/moduleparam.h>
@@ -121,7 +122,7 @@ void *snd_lookup_minor_data(unsigned int minor, int type)
 
 EXPORT_SYMBOL(snd_lookup_minor_data);
 
-static int snd_open(struct inode *inode, struct file *file)
+static int __snd_open(struct inode *inode, struct file *file)
 {
 	unsigned int minor = iminor(inode);
 	struct snd_minor *mptr = NULL;
@@ -163,6 +164,18 @@ static int snd_open(struct inode *inode, struct file *file)
 	return err;
 }
 
+
+/* BKL pushdown: nasty #ifdef avoidance wrapper */
+static int snd_open(struct inode *inode, struct file *file)
+{
+	int ret;
+
+	lock_kernel();
+	ret = __snd_open(inode, file);
+	unlock_kernel();
+	return ret;
+}
+
 static const struct file_operations snd_fops =
 {
 	.owner =	THIS_MODULE,

commit 5d99a8b814abd76e89ef2cf90e29bbb879d6d66c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri May 16 17:55:12 2008 -0700

    SOUND: fix race in device_create
    
    There is a race from when a device is created with device_create() and
    then the drvdata is set with a call to dev_set_drvdata() in which a
    sysfs file could be open, yet the drvdata will be NULL, causing all
    sorts of bad things to happen.
    
    This patch fixes the problem by using the new function,
    device_create_drvdata().
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 812f91b3de5b..6c8ab48c689a 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -259,8 +259,9 @@ int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
 		return minor;
 	}
 	snd_minors[minor] = preg;
-	preg->dev = device_create(sound_class, device, MKDEV(major, minor),
-				  "%s", name);
+	preg->dev = device_create_drvdata(sound_class, device,
+					  MKDEV(major, minor),
+					  private_data, "%s", name);
 	if (IS_ERR(preg->dev)) {
 		snd_minors[minor] = NULL;
 		mutex_unlock(&sound_mutex);
@@ -269,9 +270,6 @@ int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
 		return minor;
 	}
 
-	if (preg->dev)
-		dev_set_drvdata(preg->dev, private_data);
-
 	mutex_unlock(&sound_mutex);
 	return 0;
 }

commit 0d63e4f9ea61df1d727bd52a174aba732e6e1853
Author: Jan Blunck <jblunck@suse.de>
Date:   Thu Feb 14 19:34:28 2008 -0800

    Dont touch fs_struct in drivers
    
    The sound drivers and the pnpbios core test for current->root != NULL.  This
    test seems to be unnecessary since we always have rootfs mounted before
    initializing the drivers.
    
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 00cca4d6e562..812f91b3de5b 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -71,8 +71,6 @@ static DEFINE_MUTEX(sound_mutex);
  */
 void snd_request_card(int card)
 {
-	if (! current->fs->root)
-		return;
 	if (snd_card_locked(card))
 		return;
 	if (card < 0 || card >= cards_limit)
@@ -86,8 +84,6 @@ static void snd_request_other(int minor)
 {
 	char *str;
 
-	if (! current->fs->root)
-		return;
 	switch (minor) {
 	case SNDRV_MINOR_SEQUENCER:	str = "snd-seq";	break;
 	case SNDRV_MINOR_TIMER:		str = "snd-timer";	break;

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 7b486c4d70db..00cca4d6e562 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -19,7 +19,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/time.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index f6ebce08b537..7b486c4d70db 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -1,6 +1,6 @@
 /*
  *  Advanced Linux Sound Architecture
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *
  *
  *   This program is free software; you can redistribute it and/or modify
@@ -42,7 +42,7 @@ EXPORT_SYMBOL(snd_major);
 
 static int cards_limit = 1;
 
-MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");
 MODULE_DESCRIPTION("Advanced Linux Sound Architecture driver for soundcards.");
 MODULE_LICENSE("GPL");
 module_param(major, int, 0444);

commit 2469049e728ee0542d6617f81311a18a14e73826
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Tue Oct 9 10:34:06 2007 +0200

    [ALSA] sound: snd_register_device_for_dev fix
    
    snd_register_device_for_dev() can oops when device_create() returns
    ERR_PTR(err).
    Scenario:
    preg->dev = device_create(...); /* fails */
    if (preg->dev) /* contains ERR_PTR(err) */
            dev_set_drvdata(preg->dev, private_data);
    and dev_set_drvdata() looks like this:
    static inline void
    dev_set_drvdata (struct device *dev, void *data)
    {
            dev->driver_data = data; <--- boom
    }
    This patch should prevent that.
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 8dc7a3b32b98..f6ebce08b537 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -266,6 +266,14 @@ int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
 	snd_minors[minor] = preg;
 	preg->dev = device_create(sound_class, device, MKDEV(major, minor),
 				  "%s", name);
+	if (IS_ERR(preg->dev)) {
+		snd_minors[minor] = NULL;
+		mutex_unlock(&sound_mutex);
+		minor = PTR_ERR(preg->dev);
+		kfree(preg);
+		return minor;
+	}
+
 	if (preg->dev)
 		dev_set_drvdata(preg->dev, private_data);
 

commit 68fc4fabca897a09f75f53bac14cdc7a98f52210
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Jul 19 01:47:50 2007 -0700

    unregister_chrdev(): ignore the return value
    
    unregister_chrdev() always returns 0.  There is no need to check the return
    value.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 70600df94d62..8dc7a3b32b98 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -446,8 +446,7 @@ static void __exit alsa_sound_exit(void)
 {
 	snd_info_minor_unregister();
 	snd_info_done();
-	if (unregister_chrdev(major, "alsa") != 0)
-		snd_printk(KERN_ERR "unable to unregister major device number %d\n", major);
+	unregister_chrdev(major, "alsa");
 }
 
 module_init(alsa_sound_init)

commit 9c2e08c592cd357a8330c34def1e8ecfdcf53275
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:37 2007 -0800

    [PATCH] mark struct file_operations const 9
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 4084de064127..70600df94d62 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -168,7 +168,7 @@ static int snd_open(struct inode *inode, struct file *file)
 	return err;
 }
 
-static struct file_operations snd_fops =
+static const struct file_operations snd_fops =
 {
 	.owner =	THIS_MODULE,
 	.open =		snd_open

commit 12b131c4cf3eb1dc8a60082a434b7b100774c2e7
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Oct 5 15:05:34 2006 +0200

    [ALSA] allow registering an alsa device with struct device pointer
    
    This patch adds snd_register_device_for_dev taking a struct device
    pointer to link the new device to and makes snd_register_device a simple
    static inline wrapper around it.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 82a61c67cf3a..4084de064127 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -219,26 +219,27 @@ static int snd_kernel_minor(int type, struct snd_card *card, int dev)
 #endif
 
 /**
- * snd_register_device - Register the ALSA device file for the card
+ * snd_register_device_for_dev - Register the ALSA device file for the card
  * @type: the device type, SNDRV_DEVICE_TYPE_XXX
  * @card: the card instance
  * @dev: the device index
  * @f_ops: the file operations
  * @private_data: user pointer for f_ops->open()
  * @name: the device file name
+ * @device: the &struct device to link this new device to
  *
  * Registers an ALSA device file for the given card.
  * The operators have to be set in reg parameter.
  *
- * Retrurns zero if successful, or a negative error code on failure.
+ * Returns zero if successful, or a negative error code on failure.
  */
-int snd_register_device(int type, struct snd_card *card, int dev,
-			const struct file_operations *f_ops, void *private_data,
-			const char *name)
+int snd_register_device_for_dev(int type, struct snd_card *card, int dev,
+				const struct file_operations *f_ops,
+				void *private_data,
+				const char *name, struct device *device)
 {
 	int minor;
 	struct snd_minor *preg;
-	struct device *device = snd_card_get_device_link(card);
 
 	snd_assert(name, return -EINVAL);
 	preg = kmalloc(sizeof *preg, GFP_KERNEL);
@@ -272,7 +273,7 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	return 0;
 }
 
-EXPORT_SYMBOL(snd_register_device);
+EXPORT_SYMBOL(snd_register_device_for_dev);
 
 /* find the matching minor record
  * return the index of snd_minor, or -1 if not found

commit 7d2aae1e88660cf09be913e9754e45189dc33412
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 26 12:40:31 2007 +0100

    [PATCH] ALSA: Fix sysfs breakage
    
    The recent change for a new sysfs tree with card* object breaks the
    /sys/class/sound tree if CONFIG_SYSFS_DEPRECATED is enabled.
    The device in each entry doesn't point the correct device object:
    
      /sys/class/sound
      ...
      |-- pcmC0D0c
      |   |-- dev
      |   |-- device -> ../../../class/sound/card0
      |   |-- pcm_class
      |   |-- power
      |   |   `-- wakeup
      |   |-- subsystem -> ../../../class/sound
      |   `-- uevent
    
    Also, this change breaks some drivers (like sound/arm/*) referring
    card->dev directly to obtain the device object for memory handling.
    
    This patch reverts the semantics of card->dev to the former version,
    which points to a real device object.  The card* object is stored in a
    new card->card_dev field, instead.  The device parent is chosen either
    card->dev or card->card_dev according to CONFIG_SYSFS_DEPRECATED to
    keep the tree compatibility.
    Also, card* isn't created if CONFIG_SYSFS_DEPRECATED is enabled.  The
    reason of card* object is a root of all beloing devices, and it makes
    little sense if each sound device points to the real device object
    directly.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Monty Montgomery <xiphmont@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 282742022de6..82a61c67cf3a 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -238,7 +238,7 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 {
 	int minor;
 	struct snd_minor *preg;
-	struct device *device = NULL;
+	struct device *device = snd_card_get_device_link(card);
 
 	snd_assert(name, return -EINVAL);
 	preg = kmalloc(sizeof *preg, GFP_KERNEL);
@@ -263,8 +263,6 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 		return minor;
 	}
 	snd_minors[minor] = preg;
-	if (card)
-		device = card->dev;
 	preg->dev = device_create(sound_class, device, MKDEV(major, minor),
 				  "%s", name);
 	if (preg->dev)

commit d80f19fab89cba8a6d16193154c8ff3edab00942
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 7 22:19:37 2006 -0700

    Driver core: convert sound core to use struct device
    
    Converts from using struct "class_device" to "struct device" making
    everything show up properly in /sys/devices/ with symlinks from the
    /sys/class directory.
    
    It also makes the struct sound_card to show up as a "real" device
    where all the different sound class devices are placed as childs
    and different card attribute files can hang off of. /sys/class/sound is
    still a flat directory, but the symlink targets of all devices belonging
    to the same card, point the the /sys/devices tree below the new card
    device object.
    
    Thanks to Kay for the updates to this patch.
    
    Signed-off-by: Kay Sievers <kay.sievers@novell.com>
    Acked-by: Jaroslav Kysela <perex@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index efa476c5210a..282742022de6 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -61,9 +61,6 @@ EXPORT_SYMBOL(snd_ecards_limit);
 static struct snd_minor *snd_minors[SNDRV_OS_MINORS];
 static DEFINE_MUTEX(sound_mutex);
 
-extern struct class *sound_class;
-
-
 #ifdef CONFIG_KMOD
 
 /**
@@ -268,11 +265,10 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	snd_minors[minor] = preg;
 	if (card)
 		device = card->dev;
-	preg->class_dev = class_device_create(sound_class, NULL,
-					      MKDEV(major, minor),
-					      device, "%s", name);
-	if (preg->class_dev)
-		class_set_devdata(preg->class_dev, private_data);
+	preg->dev = device_create(sound_class, device, MKDEV(major, minor),
+				  "%s", name);
+	if (preg->dev)
+		dev_set_drvdata(preg->dev, private_data);
 
 	mutex_unlock(&sound_mutex);
 	return 0;
@@ -320,7 +316,7 @@ int snd_unregister_device(int type, struct snd_card *card, int dev)
 		return -EINVAL;
 	}
 
-	class_device_destroy(sound_class, MKDEV(major, minor));
+	device_destroy(sound_class, MKDEV(major, minor));
 
 	kfree(snd_minors[minor]);
 	snd_minors[minor] = NULL;
@@ -331,15 +327,15 @@ int snd_unregister_device(int type, struct snd_card *card, int dev)
 EXPORT_SYMBOL(snd_unregister_device);
 
 int snd_add_device_sysfs_file(int type, struct snd_card *card, int dev,
-			      const struct class_device_attribute *attr)
+			      struct device_attribute *attr)
 {
 	int minor, ret = -EINVAL;
-	struct class_device *cdev;
+	struct device *d;
 
 	mutex_lock(&sound_mutex);
 	minor = find_snd_minor(type, card, dev);
-	if (minor >= 0 && (cdev = snd_minors[minor]->class_dev) != NULL)
-		ret = class_device_create_file(cdev, attr);
+	if (minor >= 0 && (d = snd_minors[minor]->dev) != NULL)
+		ret = device_create_file(d, attr);
 	mutex_unlock(&sound_mutex);
 	return ret;
 

commit 9d19f48cfe2570562c2c6226780a7ca627b0f1f1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 6 14:27:46 2006 +0200

    [ALSA] Add pcm_class attribute to PCM sysfs entry
    
    This patch adds a new attribute, pcm_class, to each PCM sysfs entry.
    It's useful to detect what kind of PCM stream is, for example, HAL
    can check whether it's a modem or not.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index b4430db3fa4c..efa476c5210a 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -268,7 +268,11 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	snd_minors[minor] = preg;
 	if (card)
 		device = card->dev;
-	class_device_create(sound_class, NULL, MKDEV(major, minor), device, "%s", name);
+	preg->class_dev = class_device_create(sound_class, NULL,
+					      MKDEV(major, minor),
+					      device, "%s", name);
+	if (preg->class_dev)
+		class_set_devdata(preg->class_dev, private_data);
 
 	mutex_unlock(&sound_mutex);
 	return 0;
@@ -276,6 +280,24 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 
 EXPORT_SYMBOL(snd_register_device);
 
+/* find the matching minor record
+ * return the index of snd_minor, or -1 if not found
+ */
+static int find_snd_minor(int type, struct snd_card *card, int dev)
+{
+	int cardnum, minor;
+	struct snd_minor *mptr;
+
+	cardnum = card ? card->number : -1;
+	for (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor)
+		if ((mptr = snd_minors[minor]) != NULL &&
+		    mptr->type == type &&
+		    mptr->card == cardnum &&
+		    mptr->device == dev)
+			return minor;
+	return -1;
+}
+
 /**
  * snd_unregister_device - unregister the device on the given card
  * @type: the device type, SNDRV_DEVICE_TYPE_XXX
@@ -289,32 +311,42 @@ EXPORT_SYMBOL(snd_register_device);
  */
 int snd_unregister_device(int type, struct snd_card *card, int dev)
 {
-	int cardnum, minor;
-	struct snd_minor *mptr;
+	int minor;
 
-	cardnum = card ? card->number : -1;
 	mutex_lock(&sound_mutex);
-	for (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor)
-		if ((mptr = snd_minors[minor]) != NULL &&
-		    mptr->type == type &&
-		    mptr->card == cardnum &&
-		    mptr->device == dev)
-			break;
-	if (minor == ARRAY_SIZE(snd_minors)) {
+	minor = find_snd_minor(type, card, dev);
+	if (minor < 0) {
 		mutex_unlock(&sound_mutex);
 		return -EINVAL;
 	}
 
 	class_device_destroy(sound_class, MKDEV(major, minor));
 
+	kfree(snd_minors[minor]);
 	snd_minors[minor] = NULL;
 	mutex_unlock(&sound_mutex);
-	kfree(mptr);
 	return 0;
 }
 
 EXPORT_SYMBOL(snd_unregister_device);
 
+int snd_add_device_sysfs_file(int type, struct snd_card *card, int dev,
+			      const struct class_device_attribute *attr)
+{
+	int minor, ret = -EINVAL;
+	struct class_device *cdev;
+
+	mutex_lock(&sound_mutex);
+	minor = find_snd_minor(type, card, dev);
+	if (minor >= 0 && (cdev = snd_minors[minor]->class_dev) != NULL)
+		ret = class_device_create_file(cdev, attr);
+	mutex_unlock(&sound_mutex);
+	return ret;
+
+}
+
+EXPORT_SYMBOL(snd_add_device_sysfs_file);
+
 #ifdef CONFIG_PROC_FS
 /*
  *  INFO PART

commit 746d4a02e68499fc6c1f8d0c43d2271853ade181
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 23 14:37:59 2006 +0200

    [ALSA] Fix disconnection of proc interface
    
    - Add the linked list to each proc entry to enable a single-shot
      disconnection (unregister)
    - Deprecate snd_info_unregister(), use snd_info_free_entry()
    - Removed NULL checks of snd_info_free_entry()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 7edd1fc58b17..b4430db3fa4c 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -387,8 +387,7 @@ int __init snd_minor_info_init(void)
 
 int __exit snd_minor_info_done(void)
 {
-	if (snd_minor_info_entry)
-		snd_info_unregister(snd_minor_info_entry);
+	snd_info_free_entry(snd_minor_info_entry);
 	return 0;
 }
 #endif /* CONFIG_PROC_FS */

commit 562b590d4e838ecaca2cfd246fd4df55dc6db18a
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Jul 5 11:24:22 2006 +0200

    [ALSA] remove unused snd_minor.name field
    
    Drop the snd_minor structure's name field that was just a helper for
    devfs device deregistration.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 264f2efd1af8..7edd1fc58b17 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -244,7 +244,7 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	struct device *device = NULL;
 
 	snd_assert(name, return -EINVAL);
-	preg = kmalloc(sizeof(struct snd_minor) + strlen(name) + 1, GFP_KERNEL);
+	preg = kmalloc(sizeof *preg, GFP_KERNEL);
 	if (preg == NULL)
 		return -ENOMEM;
 	preg->type = type;
@@ -252,7 +252,6 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	preg->device = dev;
 	preg->f_ops = f_ops;
 	preg->private_data = private_data;
-	strcpy(preg->name, name);
 	mutex_lock(&sound_mutex);
 #ifdef CONFIG_SND_DYNAMIC_MINORS
 	minor = snd_find_free_minor();

commit 0936f26f55918af595b108208e64c37a0a481722
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] devfs: Remove devfs support from the sound subsystem
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index cd862728346c..264f2efd1af8 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -32,7 +32,6 @@
 #include <sound/control.h>
 #include <sound/initval.h>
 #include <linux/kmod.h>
-#include <linux/devfs_fs_kernel.h>
 #include <linux/mutex.h>
 
 #define SNDRV_OS_MINORS 256
@@ -42,7 +41,6 @@ int snd_major;
 EXPORT_SYMBOL(snd_major);
 
 static int cards_limit = 1;
-static int device_mode = S_IFCHR | S_IRUGO | S_IWUGO;
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
 MODULE_DESCRIPTION("Advanced Linux Sound Architecture driver for soundcards.");
@@ -51,10 +49,6 @@ module_param(major, int, 0444);
 MODULE_PARM_DESC(major, "Major # for sound driver.");
 module_param(cards_limit, int, 0444);
 MODULE_PARM_DESC(cards_limit, "Count of auto-loadable soundcards.");
-#ifdef CONFIG_DEVFS_FS
-module_param(device_mode, int, 0444);
-MODULE_PARM_DESC(device_mode, "Device file permission mask for devfs.");
-#endif
 MODULE_ALIAS_CHARDEV_MAJOR(CONFIG_SND_MAJOR);
 
 /* this one holds the actual max. card number currently available.
@@ -273,8 +267,6 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 		return minor;
 	}
 	snd_minors[minor] = preg;
-	if (type != SNDRV_DEVICE_TYPE_CONTROL || preg->card >= cards_limit)
-		devfs_mk_cdev(MKDEV(major, minor), S_IFCHR | device_mode, "snd/%s", name);
 	if (card)
 		device = card->dev;
 	class_device_create(sound_class, NULL, MKDEV(major, minor), device, "%s", name);
@@ -314,9 +306,6 @@ int snd_unregister_device(int type, struct snd_card *card, int dev)
 		return -EINVAL;
 	}
 
-	if (mptr->type != SNDRV_DEVICE_TYPE_CONTROL ||
-	    mptr->card >= cards_limit)			/* created in sound.c */
-		devfs_remove("snd/%s", mptr->name);
 	class_device_destroy(sound_class, MKDEV(major, minor));
 
 	snd_minors[minor] = NULL;
@@ -411,24 +400,17 @@ int __exit snd_minor_info_done(void)
 
 static int __init alsa_sound_init(void)
 {
-	short controlnum;
-
 	snd_major = major;
 	snd_ecards_limit = cards_limit;
-	devfs_mk_dir("snd");
 	if (register_chrdev(major, "alsa", &snd_fops)) {
 		snd_printk(KERN_ERR "unable to register native major device number %d\n", major);
-		devfs_remove("snd");
 		return -EIO;
 	}
 	if (snd_info_init() < 0) {
 		unregister_chrdev(major, "alsa");
-		devfs_remove("snd");
 		return -ENOMEM;
 	}
 	snd_info_minor_register();
-	for (controlnum = 0; controlnum < cards_limit; controlnum++)
-		devfs_mk_cdev(MKDEV(major, controlnum<<5), S_IFCHR | device_mode, "snd/controlC%d", controlnum);
 #ifndef MODULE
 	printk(KERN_INFO "Advanced Linux Sound Architecture Driver Version " CONFIG_SND_VERSION CONFIG_SND_DATE ".\n");
 #endif
@@ -437,16 +419,10 @@ static int __init alsa_sound_init(void)
 
 static void __exit alsa_sound_exit(void)
 {
-	short controlnum;
-
-	for (controlnum = 0; controlnum < cards_limit; controlnum++)
-		devfs_remove("snd/controlC%d", controlnum);
-
 	snd_info_minor_unregister();
 	snd_info_done();
 	if (unregister_chrdev(major, "alsa") != 0)
 		snd_printk(KERN_ERR "unable to unregister major device number %d\n", major);
-	devfs_remove("snd");
 }
 
 module_init(alsa_sound_init)

commit 6581f4e74d8541dd7d579f64e94822622cbb1654
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 17 17:14:51 2006 +0200

    [ALSA] Remove zero-initialization of static variables
    
    Removed zero-initializations of static variables.
    A tiny optimization.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 02c8cc4ebffe..cd862728346c 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -332,7 +332,7 @@ EXPORT_SYMBOL(snd_unregister_device);
  *  INFO PART
  */
 
-static struct snd_info_entry *snd_minor_info_entry = NULL;
+static struct snd_info_entry *snd_minor_info_entry;
 
 static const char *snd_device_type_name(int type)
 {

commit 746df94898554b3d8e91d855e934852e626c701c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon May 15 19:49:05 2006 +0200

    [ALSA] Fix rwlock around snd_iprintf() in sound core
    
    Fixed rwlock around snd_iprintf() in sound core part.
    Replaced with mutex.
    Also, make mutex and flags static variables with addition of
    snd_card_locked() function (just for sound.c).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 8313f97907d8..02c8cc4ebffe 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -81,14 +81,9 @@ extern struct class *sound_class;
  */
 void snd_request_card(int card)
 {
-	int locked;
-
 	if (! current->fs->root)
 		return;
-	read_lock(&snd_card_rwlock);
-	locked = snd_cards_lock & (1 << card);
-	read_unlock(&snd_card_rwlock);
-	if (locked)
+	if (snd_card_locked(card))
 		return;
 	if (card < 0 || card >= cards_limit)
 		return;

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 67cfa06062b8..8313f97907d8 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -392,7 +392,6 @@ int __init snd_minor_info_init(void)
 
 	entry = snd_info_create_module_entry(THIS_MODULE, "devices", NULL);
 	if (entry) {
-		entry->c.text.read_size = PAGE_SIZE;
 		entry->c.text.read = snd_minor_info_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);

commit c0d3fb39e9511c6fad17d059a3a50d1be33add24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:39 2006 +0200

    [ALSA] Clean up EXPORT_SYMBOL()s in snd module
    
    Move EXPORT_SYMBOL()s to places adjacent to functions/variables.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 108e430b5036..67cfa06062b8 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -39,6 +39,8 @@
 
 static int major = CONFIG_SND_MAJOR;
 int snd_major;
+EXPORT_SYMBOL(snd_major);
+
 static int cards_limit = 1;
 static int device_mode = S_IFCHR | S_IRUGO | S_IWUGO;
 
@@ -60,6 +62,7 @@ MODULE_ALIAS_CHARDEV_MAJOR(CONFIG_SND_MAJOR);
  * modules are loaded manually, this limit number increases, too.
  */
 int snd_ecards_limit;
+EXPORT_SYMBOL(snd_ecards_limit);
 
 static struct snd_minor *snd_minors[SNDRV_OS_MINORS];
 static DEFINE_MUTEX(sound_mutex);
@@ -92,6 +95,8 @@ void snd_request_card(int card)
 	request_module("snd-card-%i", card);
 }
 
+EXPORT_SYMBOL(snd_request_card);
+
 static void snd_request_other(int minor)
 {
 	char *str;
@@ -133,6 +138,8 @@ void *snd_lookup_minor_data(unsigned int minor, int type)
 	return private_data;
 }
 
+EXPORT_SYMBOL(snd_lookup_minor_data);
+
 static int snd_open(struct inode *inode, struct file *file)
 {
 	unsigned int minor = iminor(inode);
@@ -281,6 +288,8 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_register_device);
+
 /**
  * snd_unregister_device - unregister the device on the given card
  * @type: the device type, SNDRV_DEVICE_TYPE_XXX
@@ -321,6 +330,8 @@ int snd_unregister_device(int type, struct snd_card *card, int dev)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_unregister_device);
+
 #ifdef CONFIG_PROC_FS
 /*
  *  INFO PART
@@ -446,91 +457,3 @@ static void __exit alsa_sound_exit(void)
 
 module_init(alsa_sound_init)
 module_exit(alsa_sound_exit)
-
-  /* sound.c */
-EXPORT_SYMBOL(snd_major);
-EXPORT_SYMBOL(snd_ecards_limit);
-#if defined(CONFIG_KMOD)
-EXPORT_SYMBOL(snd_request_card);
-#endif
-EXPORT_SYMBOL(snd_register_device);
-EXPORT_SYMBOL(snd_unregister_device);
-EXPORT_SYMBOL(snd_lookup_minor_data);
-#if defined(CONFIG_SND_OSSEMUL)
-EXPORT_SYMBOL(snd_register_oss_device);
-EXPORT_SYMBOL(snd_unregister_oss_device);
-EXPORT_SYMBOL(snd_lookup_oss_minor_data);
-#endif
-  /* memory.c */
-EXPORT_SYMBOL(copy_to_user_fromio);
-EXPORT_SYMBOL(copy_from_user_toio);
-  /* init.c */
-EXPORT_SYMBOL(snd_cards);
-#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
-EXPORT_SYMBOL(snd_mixer_oss_notify_callback);
-#endif
-EXPORT_SYMBOL(snd_card_new);
-EXPORT_SYMBOL(snd_card_disconnect);
-EXPORT_SYMBOL(snd_card_free);
-EXPORT_SYMBOL(snd_card_free_in_thread);
-EXPORT_SYMBOL(snd_card_register);
-EXPORT_SYMBOL(snd_component_add);
-EXPORT_SYMBOL(snd_card_file_add);
-EXPORT_SYMBOL(snd_card_file_remove);
-#ifdef CONFIG_PM
-EXPORT_SYMBOL(snd_power_wait);
-#endif
-  /* device.c */
-EXPORT_SYMBOL(snd_device_new);
-EXPORT_SYMBOL(snd_device_register);
-EXPORT_SYMBOL(snd_device_free);
-  /* isadma.c */
-#ifdef CONFIG_ISA_DMA_API
-EXPORT_SYMBOL(snd_dma_program);
-EXPORT_SYMBOL(snd_dma_disable);
-EXPORT_SYMBOL(snd_dma_pointer);
-#endif
-  /* info.c */
-#ifdef CONFIG_PROC_FS
-EXPORT_SYMBOL(snd_seq_root);
-EXPORT_SYMBOL(snd_iprintf);
-EXPORT_SYMBOL(snd_info_get_line);
-EXPORT_SYMBOL(snd_info_get_str);
-EXPORT_SYMBOL(snd_info_create_module_entry);
-EXPORT_SYMBOL(snd_info_create_card_entry);
-EXPORT_SYMBOL(snd_info_free_entry);
-EXPORT_SYMBOL(snd_info_register);
-EXPORT_SYMBOL(snd_info_unregister);
-EXPORT_SYMBOL(snd_card_proc_new);
-#endif
-  /* info_oss.c */
-#if defined(CONFIG_SND_OSSEMUL) && defined(CONFIG_PROC_FS)
-EXPORT_SYMBOL(snd_oss_info_register);
-#endif
-  /* control.c */
-EXPORT_SYMBOL(snd_ctl_new);
-EXPORT_SYMBOL(snd_ctl_new1);
-EXPORT_SYMBOL(snd_ctl_free_one);
-EXPORT_SYMBOL(snd_ctl_add);
-EXPORT_SYMBOL(snd_ctl_remove);
-EXPORT_SYMBOL(snd_ctl_remove_id);
-EXPORT_SYMBOL(snd_ctl_rename_id);
-EXPORT_SYMBOL(snd_ctl_find_numid);
-EXPORT_SYMBOL(snd_ctl_find_id);
-EXPORT_SYMBOL(snd_ctl_notify);
-EXPORT_SYMBOL(snd_ctl_register_ioctl);
-EXPORT_SYMBOL(snd_ctl_unregister_ioctl);
-#ifdef CONFIG_COMPAT
-EXPORT_SYMBOL(snd_ctl_register_ioctl_compat);
-EXPORT_SYMBOL(snd_ctl_unregister_ioctl_compat);
-#endif
-EXPORT_SYMBOL(snd_ctl_elem_read);
-EXPORT_SYMBOL(snd_ctl_elem_write);
-  /* misc.c */
-EXPORT_SYMBOL(release_and_free_resource);
-#ifdef CONFIG_SND_VERBOSE_PRINTK
-EXPORT_SYMBOL(snd_verbose_printk);
-#endif
-#if defined(CONFIG_SND_DEBUG) && defined(CONFIG_SND_VERBOSE_PRINTK)
-EXPORT_SYMBOL(snd_verbose_printd);
-#endif

commit 99ac48f54a91d02140c497edc31dc57d4bc5c85d
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Mar 28 01:56:41 2006 -0800

    [PATCH] mark f_ops const in the inode
    
    Mark the f_ops members of inodes as const, as well as fix the
    ripple-through this causes by places that copy this f_ops and then "do
    stuff" with it.
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 4d28e5212611..108e430b5036 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -137,7 +137,7 @@ static int snd_open(struct inode *inode, struct file *file)
 {
 	unsigned int minor = iminor(inode);
 	struct snd_minor *mptr = NULL;
-	struct file_operations *old_fops;
+	const struct file_operations *old_fops;
 	int err = 0;
 
 	if (minor >= ARRAY_SIZE(snd_minors))
@@ -240,7 +240,7 @@ static int snd_kernel_minor(int type, struct snd_card *card, int dev)
  * Retrurns zero if successful, or a negative error code on failure.
  */
 int snd_register_device(int type, struct snd_card *card, int dev,
-			struct file_operations *f_ops, void *private_data,
+			const struct file_operations *f_ops, void *private_data,
 			const char *name)
 {
 	int minor;

commit 3a63e44420932852efd6a7d6d46cdad4d427f880
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Mar 13 14:14:10 2006 +0100

    [ALSA] sound/core/: fix 3 off-by-one errors
    
    Modules: ALSA Core
    
    This patch fixes three off-by-one errors found by the Coverity checker.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index df4ab94d006e..4d28e5212611 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -121,7 +121,7 @@ void *snd_lookup_minor_data(unsigned int minor, int type)
 	struct snd_minor *mreg;
 	void *private_data;
 
-	if (minor > ARRAY_SIZE(snd_minors))
+	if (minor >= ARRAY_SIZE(snd_minors))
 		return NULL;
 	mutex_lock(&sound_mutex);
 	mreg = snd_minors[minor];
@@ -140,7 +140,7 @@ static int snd_open(struct inode *inode, struct file *file)
 	struct file_operations *old_fops;
 	int err = 0;
 
-	if (minor > ARRAY_SIZE(snd_minors))
+	if (minor >= ARRAY_SIZE(snd_minors))
 		return -ENODEV;
 	mptr = snd_minors[minor];
 	if (mptr == NULL) {

commit 1a60d4c5a0c4028559585a74e48593b16e1ca9b2
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:29:08 2006 +0100

    [ALSA] semaphore -> mutex (core part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index a8eda02bcf1c..df4ab94d006e 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -33,6 +33,7 @@
 #include <sound/initval.h>
 #include <linux/kmod.h>
 #include <linux/devfs_fs_kernel.h>
+#include <linux/mutex.h>
 
 #define SNDRV_OS_MINORS 256
 
@@ -61,7 +62,7 @@ MODULE_ALIAS_CHARDEV_MAJOR(CONFIG_SND_MAJOR);
 int snd_ecards_limit;
 
 static struct snd_minor *snd_minors[SNDRV_OS_MINORS];
-static DECLARE_MUTEX(sound_mutex);
+static DEFINE_MUTEX(sound_mutex);
 
 extern struct class *sound_class;
 
@@ -122,13 +123,13 @@ void *snd_lookup_minor_data(unsigned int minor, int type)
 
 	if (minor > ARRAY_SIZE(snd_minors))
 		return NULL;
-	down(&sound_mutex);
+	mutex_lock(&sound_mutex);
 	mreg = snd_minors[minor];
 	if (mreg && mreg->type == type)
 		private_data = mreg->private_data;
 	else
 		private_data = NULL;
-	up(&sound_mutex);
+	mutex_unlock(&sound_mutex);
 	return private_data;
 }
 
@@ -256,7 +257,7 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	preg->f_ops = f_ops;
 	preg->private_data = private_data;
 	strcpy(preg->name, name);
-	down(&sound_mutex);
+	mutex_lock(&sound_mutex);
 #ifdef CONFIG_SND_DYNAMIC_MINORS
 	minor = snd_find_free_minor();
 #else
@@ -265,7 +266,7 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 		minor = -EBUSY;
 #endif
 	if (minor < 0) {
-		up(&sound_mutex);
+		mutex_unlock(&sound_mutex);
 		kfree(preg);
 		return minor;
 	}
@@ -276,7 +277,7 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 		device = card->dev;
 	class_device_create(sound_class, NULL, MKDEV(major, minor), device, "%s", name);
 
-	up(&sound_mutex);
+	mutex_unlock(&sound_mutex);
 	return 0;
 }
 
@@ -297,7 +298,7 @@ int snd_unregister_device(int type, struct snd_card *card, int dev)
 	struct snd_minor *mptr;
 
 	cardnum = card ? card->number : -1;
-	down(&sound_mutex);
+	mutex_lock(&sound_mutex);
 	for (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor)
 		if ((mptr = snd_minors[minor]) != NULL &&
 		    mptr->type == type &&
@@ -305,7 +306,7 @@ int snd_unregister_device(int type, struct snd_card *card, int dev)
 		    mptr->device == dev)
 			break;
 	if (minor == ARRAY_SIZE(snd_minors)) {
-		up(&sound_mutex);
+		mutex_unlock(&sound_mutex);
 		return -EINVAL;
 	}
 
@@ -315,7 +316,7 @@ int snd_unregister_device(int type, struct snd_card *card, int dev)
 	class_device_destroy(sound_class, MKDEV(major, minor));
 
 	snd_minors[minor] = NULL;
-	up(&sound_mutex);
+	mutex_unlock(&sound_mutex);
 	kfree(mptr);
 	return 0;
 }
@@ -354,7 +355,7 @@ static void snd_minor_info_read(struct snd_info_entry *entry, struct snd_info_bu
 	int minor;
 	struct snd_minor *mptr;
 
-	down(&sound_mutex);
+	mutex_lock(&sound_mutex);
 	for (minor = 0; minor < SNDRV_OS_MINORS; ++minor) {
 		if (!(mptr = snd_minors[minor]))
 			continue;
@@ -371,7 +372,7 @@ static void snd_minor_info_read(struct snd_info_entry *entry, struct snd_info_bu
 			snd_iprintf(buffer, "%3i:        : %s\n", minor,
 				    snd_device_type_name(mptr->type));
 	}
-	up(&sound_mutex);
+	mutex_unlock(&sound_mutex);
 }
 
 int __init snd_minor_info_init(void)

commit 3e23c658833f135508127c955d40d7c9387f71dd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 3 19:54:44 2006 +0100

    [ALSA] Revert the nested-device patch
    
    Modules: ALSA Core
    
    Revert the nested-device patch to keep the compatibility with the
    current HAL configuration.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 2f6108deb211..a8eda02bcf1c 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -245,7 +245,6 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	int minor;
 	struct snd_minor *preg;
 	struct device *device = NULL;
-	struct class_device *class_device = NULL;
 
 	snd_assert(name, return -EINVAL);
 	preg = kmalloc(sizeof(struct snd_minor) + strlen(name) + 1, GFP_KERNEL);
@@ -273,15 +272,9 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	snd_minors[minor] = preg;
 	if (type != SNDRV_DEVICE_TYPE_CONTROL || preg->card >= cards_limit)
 		devfs_mk_cdev(MKDEV(major, minor), S_IFCHR | device_mode, "snd/%s", name);
-	if (card) {
+	if (card)
 		device = card->dev;
-		class_device = card->parent_device;
-	}
-	class_device = class_device_create(sound_class, class_device,
-					   MKDEV(major, minor), device,
-					   "%s", name);
-	if (type == SNDRV_DEVICE_TYPE_CONTROL)
-		card->parent_device = class_device;
+	class_device_create(sound_class, NULL, MKDEV(major, minor), device, "%s", name);
 
 	up(&sound_mutex);
 	return 0;

commit 416c1079d30f1a52399b96f6772e993274b774ae
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Dec 7 09:11:05 2005 +0100

    [ALSA] Nest sound devices
    
    Modules: ALSA Core
    
    Make the control device parent of all other ALSA devices of a card.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index a8eda02bcf1c..2f6108deb211 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -245,6 +245,7 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	int minor;
 	struct snd_minor *preg;
 	struct device *device = NULL;
+	struct class_device *class_device = NULL;
 
 	snd_assert(name, return -EINVAL);
 	preg = kmalloc(sizeof(struct snd_minor) + strlen(name) + 1, GFP_KERNEL);
@@ -272,9 +273,15 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	snd_minors[minor] = preg;
 	if (type != SNDRV_DEVICE_TYPE_CONTROL || preg->card >= cards_limit)
 		devfs_mk_cdev(MKDEV(major, minor), S_IFCHR | device_mode, "snd/%s", name);
-	if (card)
+	if (card) {
 		device = card->dev;
-	class_device_create(sound_class, NULL, MKDEV(major, minor), device, "%s", name);
+		class_device = card->parent_device;
+	}
+	class_device = class_device_create(sound_class, class_device,
+					   MKDEV(major, minor), device,
+					   "%s", name);
+	if (type == SNDRV_DEVICE_TYPE_CONTROL)
+		card->parent_device = class_device;
 
 	up(&sound_mutex);
 	return 0;

commit e28563cceb9f258ebe3c50fc27d8f4ff0ac4bfa4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 1 10:42:42 2005 +0100

    [ALSA] Optimize for config without PROC_FS
    
    Modules: HWDEP Midlevel,ALSA Core,PCM Midlevel,Timer Midlevel
    
    Optimize the code when compiled without CONFIG_PROC_FS.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 3b91f180f687..a8eda02bcf1c 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -320,6 +320,7 @@ int snd_unregister_device(int type, struct snd_card *card, int dev)
 	return 0;
 }
 
+#ifdef CONFIG_PROC_FS
 /*
  *  INFO PART
  */
@@ -396,6 +397,7 @@ int __exit snd_minor_info_done(void)
 		snd_info_unregister(snd_minor_info_entry);
 	return 0;
 }
+#endif /* CONFIG_PROC_FS */
 
 /*
  *  INIT PART

commit 9a1a2a1d4eeda00df45ccf7a3a375d1887f1efb3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 22 15:46:41 2005 +0100

    [ALSA] Fix a missing include
    
    Modules: ALSA Core
    
    Fix missing include <linux/device.h>
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 5febd0545d7d..3b91f180f687 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/time.h>
+#include <linux/device.h>
 #include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/minors.h>

commit d001544ded23ddb1116f945ccc2d89a7f98ab7e8
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:09:05 2005 +0100

    [ALSA] dynamic minors (6/6): increase maximum number of sound cards
    
    Modules: ALSA Core,Memalloc module,ALSA sequencer
    
    With dynamic minor numbers, we can increase the number of sound cards.
    
    This requires that the sequencer client numbers of some kernel drivers
    are allocated dynamically, too.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 5e22283078fc..5febd0545d7d 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -358,15 +358,15 @@ static void snd_minor_info_read(struct snd_info_entry *entry, struct snd_info_bu
 			continue;
 		if (mptr->card >= 0) {
 			if (mptr->device >= 0)
-				snd_iprintf(buffer, "%3i: [%i-%2i]: %s\n",
+				snd_iprintf(buffer, "%3i: [%2i-%2i]: %s\n",
 					    minor, mptr->card, mptr->device,
 					    snd_device_type_name(mptr->type));
 			else
-				snd_iprintf(buffer, "%3i: [%i]   : %s\n",
+				snd_iprintf(buffer, "%3i: [%2i]   : %s\n",
 					    minor, mptr->card,
 					    snd_device_type_name(mptr->type));
 		} else
-			snd_iprintf(buffer, "%3i:       : %s\n", minor,
+			snd_iprintf(buffer, "%3i:        : %s\n", minor,
 				    snd_device_type_name(mptr->type));
 	}
 	up(&sound_mutex);

commit 332682b1cd540dd7abbbbfc1905af8139e76e1b7
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:07:47 2005 +0100

    [ALSA] dynamic minors (4/6): dynamic minor number allocation
    
    Modules: ALSA Core,ALSA Minor Numbers
    
    Add an option to allocate device file minor numbers dynamically.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 1e5eca546925..5e22283078fc 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -133,29 +133,34 @@ void *snd_lookup_minor_data(unsigned int minor, int type)
 
 static int snd_open(struct inode *inode, struct file *file)
 {
-	int minor = iminor(inode);
-	int card = SNDRV_MINOR_CARD(minor);
-	int dev = SNDRV_MINOR_DEVICE(minor);
+	unsigned int minor = iminor(inode);
 	struct snd_minor *mptr = NULL;
 	struct file_operations *old_fops;
 	int err = 0;
 
-	if (dev != SNDRV_MINOR_GLOBAL) {
-		if (snd_cards[card] == NULL) {
+	if (minor > ARRAY_SIZE(snd_minors))
+		return -ENODEV;
+	mptr = snd_minors[minor];
+	if (mptr == NULL) {
 #ifdef CONFIG_KMOD
-			snd_request_card(card);
+		int dev = SNDRV_MINOR_DEVICE(minor);
+		if (dev == SNDRV_MINOR_CONTROL) {
+			/* /dev/aloadC? */
+			int card = SNDRV_MINOR_CARD(minor);
 			if (snd_cards[card] == NULL)
-#endif
-				return -ENODEV;
-		}
-	} else {
-#ifdef CONFIG_KMOD
-		if ((mptr = snd_minors[minor]) == NULL)
+				snd_request_card(card);
+		} else if (dev == SNDRV_MINOR_GLOBAL) {
+			/* /dev/aloadSEQ */
 			snd_request_other(minor);
+		}
+#ifndef CONFIG_SND_DYNAMIC_MINORS
+		/* /dev/snd/{controlC?,seq} */
+		mptr = snd_minors[minor];
+		if (mptr == NULL)
+#endif
 #endif
+			return -ENODEV;
 	}
-	if (mptr == NULL && (mptr = snd_minors[minor]) == NULL)
-		return -ENODEV;
 	old_fops = file->f_op;
 	file->f_op = fops_get(mptr->f_ops);
 	if (file->f_op->open)
@@ -174,6 +179,22 @@ static struct file_operations snd_fops =
 	.open =		snd_open
 };
 
+#ifdef CONFIG_SND_DYNAMIC_MINORS
+static int snd_find_free_minor(void)
+{
+	int minor;
+
+	for (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor) {
+		/* skip minors still used statically for autoloading devices */
+		if (SNDRV_MINOR_DEVICE(minor) == SNDRV_MINOR_CONTROL ||
+		    minor == SNDRV_MINOR_SEQUENCER)
+			continue;
+		if (!snd_minors[minor])
+			return minor;
+	}
+	return -EBUSY;
+}
+#else
 static int snd_kernel_minor(int type, struct snd_card *card, int dev)
 {
 	int minor;
@@ -200,6 +221,7 @@ static int snd_kernel_minor(int type, struct snd_card *card, int dev)
 	snd_assert(minor >= 0 && minor < SNDRV_OS_MINORS, return -EINVAL);
 	return minor;
 }
+#endif
 
 /**
  * snd_register_device - Register the ALSA device file for the card
@@ -219,12 +241,10 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 			struct file_operations *f_ops, void *private_data,
 			const char *name)
 {
-	int minor = snd_kernel_minor(type, card, dev);
+	int minor;
 	struct snd_minor *preg;
 	struct device *device = NULL;
 
-	if (minor < 0)
-		return minor;
 	snd_assert(name, return -EINVAL);
 	preg = kmalloc(sizeof(struct snd_minor) + strlen(name) + 1, GFP_KERNEL);
 	if (preg == NULL)
@@ -236,10 +256,17 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	preg->private_data = private_data;
 	strcpy(preg->name, name);
 	down(&sound_mutex);
-	if (snd_minors[minor]) {
+#ifdef CONFIG_SND_DYNAMIC_MINORS
+	minor = snd_find_free_minor();
+#else
+	minor = snd_kernel_minor(type, card, dev);
+	if (minor >= 0 && snd_minors[minor])
+		minor = -EBUSY;
+#endif
+	if (minor < 0) {
 		up(&sound_mutex);
 		kfree(preg);
-		return -EBUSY;
+		return minor;
 	}
 	snd_minors[minor] = preg;
 	if (type != SNDRV_DEVICE_TYPE_CONTROL || preg->card >= cards_limit)

commit f87135f56cb266e031f5ec081dfbde7e43f55e80
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:06:59 2005 +0100

    [ALSA] dynamic minors (3/6): store device-specific object pointers dynamically
    
    Instead of storing the pointers to the device-specific structures in an
    array, put them into the struct snd_minor, and look them up dynamically.
    
    This makes the device type modules independent of the minor number
    encoding.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index a509f49fa0b4..1e5eca546925 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -60,7 +60,6 @@ MODULE_ALIAS_CHARDEV_MAJOR(CONFIG_SND_MAJOR);
 int snd_ecards_limit;
 
 static struct snd_minor *snd_minors[SNDRV_OS_MINORS];
-
 static DECLARE_MUTEX(sound_mutex);
 
 extern struct class *sound_class;
@@ -107,6 +106,31 @@ static void snd_request_other(int minor)
 
 #endif				/* request_module support */
 
+/**
+ * snd_lookup_minor_data - get user data of a registered device
+ * @minor: the minor number
+ * @type: device type (SNDRV_DEVICE_TYPE_XXX)
+ *
+ * Checks that a minor device with the specified type is registered, and returns
+ * its user data pointer.
+ */
+void *snd_lookup_minor_data(unsigned int minor, int type)
+{
+	struct snd_minor *mreg;
+	void *private_data;
+
+	if (minor > ARRAY_SIZE(snd_minors))
+		return NULL;
+	down(&sound_mutex);
+	mreg = snd_minors[minor];
+	if (mreg && mreg->type == type)
+		private_data = mreg->private_data;
+	else
+		private_data = NULL;
+	up(&sound_mutex);
+	return private_data;
+}
+
 static int snd_open(struct inode *inode, struct file *file)
 {
 	int minor = iminor(inode);
@@ -183,6 +207,7 @@ static int snd_kernel_minor(int type, struct snd_card *card, int dev)
  * @card: the card instance
  * @dev: the device index
  * @f_ops: the file operations
+ * @private_data: user pointer for f_ops->open()
  * @name: the device file name
  *
  * Registers an ALSA device file for the given card.
@@ -191,7 +216,8 @@ static int snd_kernel_minor(int type, struct snd_card *card, int dev)
  * Retrurns zero if successful, or a negative error code on failure.
  */
 int snd_register_device(int type, struct snd_card *card, int dev,
-			struct file_operations *f_ops, const char *name)
+			struct file_operations *f_ops, void *private_data,
+			const char *name)
 {
 	int minor = snd_kernel_minor(type, card, dev);
 	struct snd_minor *preg;
@@ -207,6 +233,7 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	preg->card = card ? card->number : -1;
 	preg->device = dev;
 	preg->f_ops = f_ops;
+	preg->private_data = private_data;
 	strcpy(preg->name, name);
 	down(&sound_mutex);
 	if (snd_minors[minor]) {
@@ -238,13 +265,18 @@ int snd_register_device(int type, struct snd_card *card, int dev,
  */
 int snd_unregister_device(int type, struct snd_card *card, int dev)
 {
-	int minor = snd_kernel_minor(type, card, dev);
+	int cardnum, minor;
 	struct snd_minor *mptr;
 
-	if (minor < 0)
-		return minor;
+	cardnum = card ? card->number : -1;
 	down(&sound_mutex);
-	if ((mptr = snd_minors[minor]) == NULL) {
+	for (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor)
+		if ((mptr = snd_minors[minor]) != NULL &&
+		    mptr->type == type &&
+		    mptr->card == cardnum &&
+		    mptr->device == dev)
+			break;
+	if (minor == ARRAY_SIZE(snd_minors)) {
 		up(&sound_mutex);
 		return -EINVAL;
 	}
@@ -392,9 +424,11 @@ EXPORT_SYMBOL(snd_request_card);
 #endif
 EXPORT_SYMBOL(snd_register_device);
 EXPORT_SYMBOL(snd_unregister_device);
+EXPORT_SYMBOL(snd_lookup_minor_data);
 #if defined(CONFIG_SND_OSSEMUL)
 EXPORT_SYMBOL(snd_register_oss_device);
 EXPORT_SYMBOL(snd_unregister_oss_device);
+EXPORT_SYMBOL(snd_lookup_oss_minor_data);
 #endif
   /* memory.c */
 EXPORT_SYMBOL(copy_to_user_fromio);

commit 6983b7240cd229787c3ee00e663ea94ea649d96a
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:05:49 2005 +0100

    [ALSA] dynamic minors (2/6): simplify storage of snd_minor structures
    
    Modules: ALSA Core
    
    Store the snd_minor structure pointers in one array instead of using a
    separate list for each card.  This simplifies the mapping from device
    files to minor struct by removing the need to know about the encoding
    of the card number in the minor number.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 798c24c2de20..a509f49fa0b4 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -59,7 +59,7 @@ MODULE_ALIAS_CHARDEV_MAJOR(CONFIG_SND_MAJOR);
  */
 int snd_ecards_limit;
 
-static struct list_head snd_minors_hash[SNDRV_CARDS];
+static struct snd_minor *snd_minors[SNDRV_OS_MINORS];
 
 static DECLARE_MUTEX(sound_mutex);
 
@@ -107,19 +107,6 @@ static void snd_request_other(int minor)
 
 #endif				/* request_module support */
 
-static struct snd_minor *snd_minor_search(int minor)
-{
-	struct list_head *list;
-	struct snd_minor *mptr;
-
-	list_for_each(list, &snd_minors_hash[SNDRV_MINOR_CARD(minor)]) {
-		mptr = list_entry(list, struct snd_minor, list);
-		if (mptr->number == minor)
-			return mptr;
-	}
-	return NULL;
-}
-
 static int snd_open(struct inode *inode, struct file *file)
 {
 	int minor = iminor(inode);
@@ -139,11 +126,11 @@ static int snd_open(struct inode *inode, struct file *file)
 		}
 	} else {
 #ifdef CONFIG_KMOD
-		if ((mptr = snd_minor_search(minor)) == NULL)
+		if ((mptr = snd_minors[minor]) == NULL)
 			snd_request_other(minor);
 #endif
 	}
-	if (mptr == NULL && (mptr = snd_minor_search(minor)) == NULL)
+	if (mptr == NULL && (mptr = snd_minors[minor]) == NULL)
 		return -ENODEV;
 	old_fops = file->f_op;
 	file->f_op = fops_get(mptr->f_ops);
@@ -213,22 +200,22 @@ int snd_register_device(int type, struct snd_card *card, int dev,
 	if (minor < 0)
 		return minor;
 	snd_assert(name, return -EINVAL);
-	preg = kzalloc(sizeof(struct snd_minor) + strlen(name) + 1, GFP_KERNEL);
+	preg = kmalloc(sizeof(struct snd_minor) + strlen(name) + 1, GFP_KERNEL);
 	if (preg == NULL)
 		return -ENOMEM;
-	preg->number = minor;
 	preg->type = type;
+	preg->card = card ? card->number : -1;
 	preg->device = dev;
 	preg->f_ops = f_ops;
 	strcpy(preg->name, name);
 	down(&sound_mutex);
-	if (snd_minor_search(minor)) {
+	if (snd_minors[minor]) {
 		up(&sound_mutex);
 		kfree(preg);
 		return -EBUSY;
 	}
-	list_add_tail(&preg->list, &snd_minors_hash[SNDRV_MINOR_CARD(minor)]);
-	if (strncmp(name, "controlC", 8) || card->number >= cards_limit)
+	snd_minors[minor] = preg;
+	if (type != SNDRV_DEVICE_TYPE_CONTROL || preg->card >= cards_limit)
 		devfs_mk_cdev(MKDEV(major, minor), S_IFCHR | device_mode, "snd/%s", name);
 	if (card)
 		device = card->dev;
@@ -257,16 +244,17 @@ int snd_unregister_device(int type, struct snd_card *card, int dev)
 	if (minor < 0)
 		return minor;
 	down(&sound_mutex);
-	if ((mptr = snd_minor_search(minor)) == NULL) {
+	if ((mptr = snd_minors[minor]) == NULL) {
 		up(&sound_mutex);
 		return -EINVAL;
 	}
 
-	if (strncmp(mptr->name, "controlC", 8) || card->number >= cards_limit) /* created in sound.c */
+	if (mptr->type != SNDRV_DEVICE_TYPE_CONTROL ||
+	    mptr->card >= cards_limit)			/* created in sound.c */
 		devfs_remove("snd/%s", mptr->name);
 	class_device_destroy(sound_class, MKDEV(major, minor));
 
-	list_del(&mptr->list);
+	snd_minors[minor] = NULL;
 	up(&sound_mutex);
 	kfree(mptr);
 	return 0;
@@ -302,23 +290,25 @@ static const char *snd_device_type_name(int type)
 
 static void snd_minor_info_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
-	int card, device;
-	struct list_head *list;
+	int minor;
 	struct snd_minor *mptr;
 
 	down(&sound_mutex);
-	for (card = 0; card < SNDRV_CARDS; card++) {
-		list_for_each(list, &snd_minors_hash[card]) {
-			mptr = list_entry(list, struct snd_minor, list);
-			if (SNDRV_MINOR_DEVICE(mptr->number) != SNDRV_MINOR_GLOBAL) {
-				if ((device = mptr->device) >= 0)
-					snd_iprintf(buffer, "%3i: [%i-%2i]: %s\n", mptr->number, card, device, snd_device_type_name(mptr->type));
-				else
-					snd_iprintf(buffer, "%3i: [%i]   : %s\n", mptr->number, card, snd_device_type_name(mptr->type));
-			} else {
-				snd_iprintf(buffer, "%3i:       : %s\n", mptr->number, snd_device_type_name(mptr->type));
-			}
-		}
+	for (minor = 0; minor < SNDRV_OS_MINORS; ++minor) {
+		if (!(mptr = snd_minors[minor]))
+			continue;
+		if (mptr->card >= 0) {
+			if (mptr->device >= 0)
+				snd_iprintf(buffer, "%3i: [%i-%2i]: %s\n",
+					    minor, mptr->card, mptr->device,
+					    snd_device_type_name(mptr->type));
+			else
+				snd_iprintf(buffer, "%3i: [%i]   : %s\n",
+					    minor, mptr->card,
+					    snd_device_type_name(mptr->type));
+		} else
+			snd_iprintf(buffer, "%3i:       : %s\n", minor,
+				    snd_device_type_name(mptr->type));
 	}
 	up(&sound_mutex);
 }
@@ -354,15 +344,9 @@ int __exit snd_minor_info_done(void)
 static int __init alsa_sound_init(void)
 {
 	short controlnum;
-	int err;
-	int card;
 
 	snd_major = major;
 	snd_ecards_limit = cards_limit;
-	for (card = 0; card < SNDRV_CARDS; card++)
-		INIT_LIST_HEAD(&snd_minors_hash[card]);
-	if ((err = snd_oss_init_module()) < 0)
-		return err;
 	devfs_mk_dir("snd");
 	if (register_chrdev(major, "alsa", &snd_fops)) {
 		snd_printk(KERN_ERR "unable to register native major device number %d\n", major);

commit 2af677fc884fc6dc79e65c99050ea607ac8bab9b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:03:48 2005 +0100

    [ALSA] dynamic minors (1/6): store device type in struct snd_minor
    
    Instead of a comment string, store the device type in the snd_minor
    structure.  This makes snd_minor more flexible, and has the nice side
    effect that we don't need anymore to create a separate snd_minor
    template for registering a device but can pass the file_operations
    directly to snd_register_device().
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index fb236a6b9c34..798c24c2de20 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -195,7 +195,7 @@ static int snd_kernel_minor(int type, struct snd_card *card, int dev)
  * @type: the device type, SNDRV_DEVICE_TYPE_XXX
  * @card: the card instance
  * @dev: the device index
- * @reg: the struct snd_minor record
+ * @f_ops: the file operations
  * @name: the device file name
  *
  * Registers an ALSA device file for the given card.
@@ -203,7 +203,8 @@ static int snd_kernel_minor(int type, struct snd_card *card, int dev)
  *
  * Retrurns zero if successful, or a negative error code on failure.
  */
-int snd_register_device(int type, struct snd_card *card, int dev, struct snd_minor * reg, const char *name)
+int snd_register_device(int type, struct snd_card *card, int dev,
+			struct file_operations *f_ops, const char *name)
 {
 	int minor = snd_kernel_minor(type, card, dev);
 	struct snd_minor *preg;
@@ -212,12 +213,13 @@ int snd_register_device(int type, struct snd_card *card, int dev, struct snd_min
 	if (minor < 0)
 		return minor;
 	snd_assert(name, return -EINVAL);
-	preg = kmalloc(sizeof(struct snd_minor) + strlen(name) + 1, GFP_KERNEL);
+	preg = kzalloc(sizeof(struct snd_minor) + strlen(name) + 1, GFP_KERNEL);
 	if (preg == NULL)
 		return -ENOMEM;
-	*preg = *reg;
 	preg->number = minor;
+	preg->type = type;
 	preg->device = dev;
+	preg->f_ops = f_ops;
 	strcpy(preg->name, name);
 	down(&sound_mutex);
 	if (snd_minor_search(minor)) {
@@ -276,6 +278,28 @@ int snd_unregister_device(int type, struct snd_card *card, int dev)
 
 static struct snd_info_entry *snd_minor_info_entry = NULL;
 
+static const char *snd_device_type_name(int type)
+{
+	switch (type) {
+	case SNDRV_DEVICE_TYPE_CONTROL:
+		return "control";
+	case SNDRV_DEVICE_TYPE_HWDEP:
+		return "hardware dependent";
+	case SNDRV_DEVICE_TYPE_RAWMIDI:
+		return "raw midi";
+	case SNDRV_DEVICE_TYPE_PCM_PLAYBACK:
+		return "digital audio playback";
+	case SNDRV_DEVICE_TYPE_PCM_CAPTURE:
+		return "digital audio capture";
+	case SNDRV_DEVICE_TYPE_SEQUENCER:
+		return "sequencer";
+	case SNDRV_DEVICE_TYPE_TIMER:
+		return "timer";
+	default:
+		return "?";
+	}
+}
+
 static void snd_minor_info_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
 	int card, device;
@@ -288,11 +312,11 @@ static void snd_minor_info_read(struct snd_info_entry *entry, struct snd_info_bu
 			mptr = list_entry(list, struct snd_minor, list);
 			if (SNDRV_MINOR_DEVICE(mptr->number) != SNDRV_MINOR_GLOBAL) {
 				if ((device = mptr->device) >= 0)
-					snd_iprintf(buffer, "%3i: [%i-%2i]: %s\n", mptr->number, card, device, mptr->comment);
+					snd_iprintf(buffer, "%3i: [%i-%2i]: %s\n", mptr->number, card, device, snd_device_type_name(mptr->type));
 				else
-					snd_iprintf(buffer, "%3i: [%i]   : %s\n", mptr->number, card, mptr->comment);
+					snd_iprintf(buffer, "%3i: [%i]   : %s\n", mptr->number, card, snd_device_type_name(mptr->type));
 			} else {
-				snd_iprintf(buffer, "%3i:       : %s\n", mptr->number, mptr->comment);
+				snd_iprintf(buffer, "%3i:       : %s\n", mptr->number, snd_device_type_name(mptr->type));
 			}
 		}
 	}

commit a381a7a66486f11606eccb8866e29848f995278f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:55:49 2005 +0100

    [ALSA] Decentralize PM control
    
    Modules: ALSA Core,Control Midlevel,/oss/Makefile
    
    Remove the centralized PM control in the sound core.
    Each driver is responsible to get callbacks from bus/driver now.
    
    SND_GENERIC_DRIVER is removed together with this action.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 04de0084e42a..fb236a6b9c34 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -32,7 +32,6 @@
 #include <sound/initval.h>
 #include <linux/kmod.h>
 #include <linux/devfs_fs_kernel.h>
-#include <linux/platform_device.h>
 
 #define SNDRV_OS_MINORS 256
 
@@ -328,10 +327,6 @@ int __exit snd_minor_info_done(void)
  *  INIT PART
  */
 
-#ifdef CONFIG_SND_GENERIC_DRIVER
-extern struct platform_driver snd_generic_driver;
-#endif
-
 static int __init alsa_sound_init(void)
 {
 	short controlnum;
@@ -356,9 +351,6 @@ static int __init alsa_sound_init(void)
 		return -ENOMEM;
 	}
 	snd_info_minor_register();
-#ifdef CONFIG_SND_GENERIC_DRIVER
-	platform_driver_register(&snd_generic_driver);
-#endif
 	for (controlnum = 0; controlnum < cards_limit; controlnum++)
 		devfs_mk_cdev(MKDEV(major, controlnum<<5), S_IFCHR | device_mode, "snd/controlC%d", controlnum);
 #ifndef MODULE
@@ -374,9 +366,6 @@ static void __exit alsa_sound_exit(void)
 	for (controlnum = 0; controlnum < cards_limit; controlnum++)
 		devfs_remove("snd/controlC%d", controlnum);
 
-#ifdef CONFIG_SND_GENERIC_DRIVER
-	platform_driver_unregister(&snd_generic_driver);
-#endif
 	snd_info_minor_unregister();
 	snd_info_done();
 	if (unregister_chrdev(major, "alsa") != 0)
@@ -415,19 +404,8 @@ EXPORT_SYMBOL(snd_card_register);
 EXPORT_SYMBOL(snd_component_add);
 EXPORT_SYMBOL(snd_card_file_add);
 EXPORT_SYMBOL(snd_card_file_remove);
-#ifdef CONFIG_SND_GENERIC_DRIVER
-EXPORT_SYMBOL(snd_card_set_generic_dev);
-#endif
 #ifdef CONFIG_PM
 EXPORT_SYMBOL(snd_power_wait);
-EXPORT_SYMBOL(snd_card_set_pm_callback);
-#ifdef CONFIG_SND_GENERIC_DRIVER
-EXPORT_SYMBOL(snd_card_set_generic_pm_callback);
-#endif
-#ifdef CONFIG_PCI
-EXPORT_SYMBOL(snd_card_pci_suspend);
-EXPORT_SYMBOL(snd_card_pci_resume);
-#endif
 #endif
   /* device.c */
 EXPORT_SYMBOL(snd_device_new);

commit 512bbd6a85230f16389f0dd51925472e72fc8a91
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 13:51:18 2005 +0100

    [ALSA] Remove xxx_t typedefs: Core component
    
    Modules: ALSA Core
    
    Remove xxx_t typedefs from the core component.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 6e7cad1e947e..04de0084e42a 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -108,13 +108,13 @@ static void snd_request_other(int minor)
 
 #endif				/* request_module support */
 
-static snd_minor_t *snd_minor_search(int minor)
+static struct snd_minor *snd_minor_search(int minor)
 {
 	struct list_head *list;
-	snd_minor_t *mptr;
+	struct snd_minor *mptr;
 
 	list_for_each(list, &snd_minors_hash[SNDRV_MINOR_CARD(minor)]) {
-		mptr = list_entry(list, snd_minor_t, list);
+		mptr = list_entry(list, struct snd_minor, list);
 		if (mptr->number == minor)
 			return mptr;
 	}
@@ -126,7 +126,7 @@ static int snd_open(struct inode *inode, struct file *file)
 	int minor = iminor(inode);
 	int card = SNDRV_MINOR_CARD(minor);
 	int dev = SNDRV_MINOR_DEVICE(minor);
-	snd_minor_t *mptr = NULL;
+	struct snd_minor *mptr = NULL;
 	struct file_operations *old_fops;
 	int err = 0;
 
@@ -164,7 +164,7 @@ static struct file_operations snd_fops =
 	.open =		snd_open
 };
 
-static int snd_kernel_minor(int type, snd_card_t * card, int dev)
+static int snd_kernel_minor(int type, struct snd_card *card, int dev)
 {
 	int minor;
 
@@ -196,7 +196,7 @@ static int snd_kernel_minor(int type, snd_card_t * card, int dev)
  * @type: the device type, SNDRV_DEVICE_TYPE_XXX
  * @card: the card instance
  * @dev: the device index
- * @reg: the snd_minor_t record
+ * @reg: the struct snd_minor record
  * @name: the device file name
  *
  * Registers an ALSA device file for the given card.
@@ -204,16 +204,16 @@ static int snd_kernel_minor(int type, snd_card_t * card, int dev)
  *
  * Retrurns zero if successful, or a negative error code on failure.
  */
-int snd_register_device(int type, snd_card_t * card, int dev, snd_minor_t * reg, const char *name)
+int snd_register_device(int type, struct snd_card *card, int dev, struct snd_minor * reg, const char *name)
 {
 	int minor = snd_kernel_minor(type, card, dev);
-	snd_minor_t *preg;
+	struct snd_minor *preg;
 	struct device *device = NULL;
 
 	if (minor < 0)
 		return minor;
 	snd_assert(name, return -EINVAL);
-	preg = (snd_minor_t *)kmalloc(sizeof(snd_minor_t) + strlen(name) + 1, GFP_KERNEL);
+	preg = kmalloc(sizeof(struct snd_minor) + strlen(name) + 1, GFP_KERNEL);
 	if (preg == NULL)
 		return -ENOMEM;
 	*preg = *reg;
@@ -248,10 +248,10 @@ int snd_register_device(int type, snd_card_t * card, int dev, snd_minor_t * reg,
  *
  * Returns zero if sucecessful, or a negative error code on failure
  */
-int snd_unregister_device(int type, snd_card_t * card, int dev)
+int snd_unregister_device(int type, struct snd_card *card, int dev)
 {
 	int minor = snd_kernel_minor(type, card, dev);
-	snd_minor_t *mptr;
+	struct snd_minor *mptr;
 
 	if (minor < 0)
 		return minor;
@@ -275,18 +275,18 @@ int snd_unregister_device(int type, snd_card_t * card, int dev)
  *  INFO PART
  */
 
-static snd_info_entry_t *snd_minor_info_entry = NULL;
+static struct snd_info_entry *snd_minor_info_entry = NULL;
 
-static void snd_minor_info_read(snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+static void snd_minor_info_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
 	int card, device;
 	struct list_head *list;
-	snd_minor_t *mptr;
+	struct snd_minor *mptr;
 
 	down(&sound_mutex);
 	for (card = 0; card < SNDRV_CARDS; card++) {
 		list_for_each(list, &snd_minors_hash[card]) {
-			mptr = list_entry(list, snd_minor_t, list);
+			mptr = list_entry(list, struct snd_minor, list);
 			if (SNDRV_MINOR_DEVICE(mptr->number) != SNDRV_MINOR_GLOBAL) {
 				if ((device = mptr->device) >= 0)
 					snd_iprintf(buffer, "%3i: [%i-%2i]: %s\n", mptr->number, card, device, mptr->comment);
@@ -302,7 +302,7 @@ static void snd_minor_info_read(snd_info_entry_t *entry, snd_info_buffer_t * buf
 
 int __init snd_minor_info_init(void)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	entry = snd_info_create_module_entry(THIS_MODULE, "devices", NULL);
 	if (entry) {

commit 3ae5eaec1d2d9c0cf53745352e7d4b152810ba24
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Nov 9 22:32:44 2005 +0000

    [DRIVER MODEL] Convert platform drivers to use struct platform_driver
    
    This allows us to eliminate the casts in the drivers, and eventually
    remove the use of the device_driver function pointer methods for
    platform device drivers.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 1139dd8ca8eb..6e7cad1e947e 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -32,7 +32,7 @@
 #include <sound/initval.h>
 #include <linux/kmod.h>
 #include <linux/devfs_fs_kernel.h>
-#include <linux/device.h>
+#include <linux/platform_device.h>
 
 #define SNDRV_OS_MINORS 256
 
@@ -329,7 +329,7 @@ int __exit snd_minor_info_done(void)
  */
 
 #ifdef CONFIG_SND_GENERIC_DRIVER
-extern struct device_driver snd_generic_driver;
+extern struct platform_driver snd_generic_driver;
 #endif
 
 static int __init alsa_sound_init(void)
@@ -357,7 +357,7 @@ static int __init alsa_sound_init(void)
 	}
 	snd_info_minor_register();
 #ifdef CONFIG_SND_GENERIC_DRIVER
-	driver_register(&snd_generic_driver);
+	platform_driver_register(&snd_generic_driver);
 #endif
 	for (controlnum = 0; controlnum < cards_limit; controlnum++)
 		devfs_mk_cdev(MKDEV(major, controlnum<<5), S_IFCHR | device_mode, "snd/controlC%d", controlnum);
@@ -375,7 +375,7 @@ static void __exit alsa_sound_exit(void)
 		devfs_remove("snd/controlC%d", controlnum);
 
 #ifdef CONFIG_SND_GENERIC_DRIVER
-	driver_unregister(&snd_generic_driver);
+	platform_driver_unregister(&snd_generic_driver);
 #endif
 	snd_info_minor_unregister();
 	snd_info_done();

commit 3939e7142da722324ab07d244a9736b0fa59c362
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Oct 24 17:02:03 2005 +0200

    [ALSA] clean up device types symbols
    
    Modules: ALSA Core,ALSA Minor Numbers
    
    Remove the unused and undefined symbols SNDRV_DEVICE_TYPE_{MIXER,
    PCM_PLOOP,PCM_CLOOP}, and introduce a new symbol SNDRV_MINOR_GLOBAL
    for non-card-specific devices like the sequencer or the timer.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index dee602245fe8..1139dd8ca8eb 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -130,7 +130,7 @@ static int snd_open(struct inode *inode, struct file *file)
 	struct file_operations *old_fops;
 	int err = 0;
 
-	if (dev != SNDRV_MINOR_SEQUENCER && dev != SNDRV_MINOR_TIMER) {
+	if (dev != SNDRV_MINOR_GLOBAL) {
 		if (snd_cards[card] == NULL) {
 #ifdef CONFIG_KMOD
 			snd_request_card(card);
@@ -287,7 +287,7 @@ static void snd_minor_info_read(snd_info_entry_t *entry, snd_info_buffer_t * buf
 	for (card = 0; card < SNDRV_CARDS; card++) {
 		list_for_each(list, &snd_minors_hash[card]) {
 			mptr = list_entry(list, snd_minor_t, list);
-			if (SNDRV_MINOR_DEVICE(mptr->number) != SNDRV_MINOR_SEQUENCER) {
+			if (SNDRV_MINOR_DEVICE(mptr->number) != SNDRV_MINOR_GLOBAL) {
 				if ((device = mptr->device) >= 0)
 					snd_iprintf(buffer, "%3i: [%i-%2i]: %s\n", mptr->number, card, device, mptr->comment);
 				else

commit e38e0cfa48ac38f4fe24453d2523852467c95b21
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:59:52 2005 +0200

    [ALSA] Remove kmalloc wrappers
    
    Modules: ALSA Core
    
    Remove kmalloc wrappers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index e94eebd8ad6f..dee602245fe8 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -350,9 +350,7 @@ static int __init alsa_sound_init(void)
 		devfs_remove("snd");
 		return -EIO;
 	}
-	snd_memory_init();
 	if (snd_info_init() < 0) {
-		snd_memory_done();
 		unregister_chrdev(major, "alsa");
 		devfs_remove("snd");
 		return -ENOMEM;
@@ -381,7 +379,6 @@ static void __exit alsa_sound_exit(void)
 #endif
 	snd_info_minor_unregister();
 	snd_info_done();
-	snd_memory_done();
 	if (unregister_chrdev(major, "alsa") != 0)
 		snd_printk(KERN_ERR "unable to unregister major device number %d\n", major);
 	devfs_remove("snd");
@@ -403,12 +400,6 @@ EXPORT_SYMBOL(snd_register_oss_device);
 EXPORT_SYMBOL(snd_unregister_oss_device);
 #endif
   /* memory.c */
-#ifdef CONFIG_SND_DEBUG_MEMORY
-EXPORT_SYMBOL(snd_hidden_kmalloc);
-EXPORT_SYMBOL(snd_hidden_kcalloc);
-EXPORT_SYMBOL(snd_hidden_kfree);
-EXPORT_SYMBOL(snd_hidden_kstrdup);
-#endif
 EXPORT_SYMBOL(copy_to_user_fromio);
 EXPORT_SYMBOL(copy_from_user_toio);
   /* init.c */
@@ -491,9 +482,4 @@ EXPORT_SYMBOL(snd_verbose_printk);
 #endif
 #if defined(CONFIG_SND_DEBUG) && defined(CONFIG_SND_VERBOSE_PRINTK)
 EXPORT_SYMBOL(snd_verbose_printd);
-#endif
-  /* wrappers */
-#ifdef CONFIG_SND_DEBUG_MEMORY
-EXPORT_SYMBOL(snd_wrapper_kmalloc);
-EXPORT_SYMBOL(snd_wrapper_kfree);
 #endif

commit b1d5776d865951c213a1caaab5d8bf5de7615dbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:56:31 2005 +0200

    [ALSA] Remove vmalloc wrapper, kfree_nocheck()
    
    - Remove vmalloc wrapper
    - Add release_and_free_resource() to remove kfree_nocheck() from each driver
      and simplify the code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index bc8ad0017984..e94eebd8ad6f 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -407,8 +407,6 @@ EXPORT_SYMBOL(snd_unregister_oss_device);
 EXPORT_SYMBOL(snd_hidden_kmalloc);
 EXPORT_SYMBOL(snd_hidden_kcalloc);
 EXPORT_SYMBOL(snd_hidden_kfree);
-EXPORT_SYMBOL(snd_hidden_vmalloc);
-EXPORT_SYMBOL(snd_hidden_vfree);
 EXPORT_SYMBOL(snd_hidden_kstrdup);
 #endif
 EXPORT_SYMBOL(copy_to_user_fromio);
@@ -487,6 +485,7 @@ EXPORT_SYMBOL(snd_ctl_unregister_ioctl_compat);
 EXPORT_SYMBOL(snd_ctl_elem_read);
 EXPORT_SYMBOL(snd_ctl_elem_write);
   /* misc.c */
+EXPORT_SYMBOL(release_and_free_resource);
 #ifdef CONFIG_SND_VERBOSE_PRINTK
 EXPORT_SYMBOL(snd_verbose_printk);
 #endif
@@ -497,6 +496,4 @@ EXPORT_SYMBOL(snd_verbose_printd);
 #ifdef CONFIG_SND_DEBUG_MEMORY
 EXPORT_SYMBOL(snd_wrapper_kmalloc);
 EXPORT_SYMBOL(snd_wrapper_kfree);
-EXPORT_SYMBOL(snd_wrapper_vmalloc);
-EXPORT_SYMBOL(snd_wrapper_vfree);
 #endif

commit 93f2e37840a9a7c3693ca6961fe6ad46b250f3b9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:51:55 2005 +0200

    [ALSA] Make snd_task_name() module local
    
    Modules: ALSA Core,ALSA<-OSS emulation
    
    Remove a global function snd_task_name(), and move it local
    to snd-pcm-oss module.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index b57519a3e3d9..bc8ad0017984 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -487,7 +487,6 @@ EXPORT_SYMBOL(snd_ctl_unregister_ioctl_compat);
 EXPORT_SYMBOL(snd_ctl_elem_read);
 EXPORT_SYMBOL(snd_ctl_elem_write);
   /* misc.c */
-EXPORT_SYMBOL(snd_task_name);
 #ifdef CONFIG_SND_VERBOSE_PRINTK
 EXPORT_SYMBOL(snd_verbose_printk);
 #endif

commit 53f4654272df7c51064825024340554b39c9efba
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 27 22:25:43 2005 -0700

    [PATCH] Driver Core: fix up all callers of class_device_create()
    
    The previous patch adding the ability to nest struct class_device
    changed the paramaters to the call class_device_create().  This patch
    fixes up all in-kernel users of the function.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 9e76bddb2c0b..b57519a3e3d9 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -231,7 +231,7 @@ int snd_register_device(int type, snd_card_t * card, int dev, snd_minor_t * reg,
 		devfs_mk_cdev(MKDEV(major, minor), S_IFCHR | device_mode, "snd/%s", name);
 	if (card)
 		device = card->dev;
-	class_device_create(sound_class, MKDEV(major, minor), device, "%s", name);
+	class_device_create(sound_class, NULL, MKDEV(major, minor), device, "%s", name);
 
 	up(&sound_mutex);
 	return 0;

commit ecbcfe36fa882e9f8f2be63ac0c42978336bf997
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 5 17:15:37 2005 +0200

    [ALSA] Introduce snd_card_set_generic_dev()
    
    ALSA Core
    A new function snd_card_set_generic_dev() is introduced to add the
    'generic device' support for devices without proper bus on sysfs.
    It's a last resort, and should be removed in future when they have
    a proper bus, instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 3271e9245490..9e76bddb2c0b 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -328,6 +328,10 @@ int __exit snd_minor_info_done(void)
  *  INIT PART
  */
 
+#ifdef CONFIG_SND_GENERIC_DRIVER
+extern struct device_driver snd_generic_driver;
+#endif
+
 static int __init alsa_sound_init(void)
 {
 	short controlnum;
@@ -354,6 +358,9 @@ static int __init alsa_sound_init(void)
 		return -ENOMEM;
 	}
 	snd_info_minor_register();
+#ifdef CONFIG_SND_GENERIC_DRIVER
+	driver_register(&snd_generic_driver);
+#endif
 	for (controlnum = 0; controlnum < cards_limit; controlnum++)
 		devfs_mk_cdev(MKDEV(major, controlnum<<5), S_IFCHR | device_mode, "snd/controlC%d", controlnum);
 #ifndef MODULE
@@ -369,6 +376,9 @@ static void __exit alsa_sound_exit(void)
 	for (controlnum = 0; controlnum < cards_limit; controlnum++)
 		devfs_remove("snd/controlC%d", controlnum);
 
+#ifdef CONFIG_SND_GENERIC_DRIVER
+	driver_unregister(&snd_generic_driver);
+#endif
 	snd_info_minor_unregister();
 	snd_info_done();
 	snd_memory_done();
@@ -416,10 +426,13 @@ EXPORT_SYMBOL(snd_card_register);
 EXPORT_SYMBOL(snd_component_add);
 EXPORT_SYMBOL(snd_card_file_add);
 EXPORT_SYMBOL(snd_card_file_remove);
+#ifdef CONFIG_SND_GENERIC_DRIVER
+EXPORT_SYMBOL(snd_card_set_generic_dev);
+#endif
 #ifdef CONFIG_PM
 EXPORT_SYMBOL(snd_power_wait);
 EXPORT_SYMBOL(snd_card_set_pm_callback);
-#if defined(CONFIG_PM) && defined(CONFIG_SND_GENERIC_PM)
+#ifdef CONFIG_SND_GENERIC_DRIVER
 EXPORT_SYMBOL(snd_card_set_generic_pm_callback);
 #endif
 #ifdef CONFIG_PCI

commit 276bd31ce5af01350465861af7aa6a25864eb108
Author: Al Viro <viro@www.linux.org.uk>
Date:   Tue Aug 23 22:45:06 2005 +0100

    [PATCH] Kconfig fix (ISA_DMA_API and sound/*)
    
    fixed kconfig dependencies on ISA_DMA_API for parts of sound/* that rely
    on it.
    
    Signed-off-by: Al Viro <viro@parcelfarce.linux.theplanet.co.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 7612884f530b..3271e9245490 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -432,7 +432,7 @@ EXPORT_SYMBOL(snd_device_new);
 EXPORT_SYMBOL(snd_device_register);
 EXPORT_SYMBOL(snd_device_free);
   /* isadma.c */
-#ifdef CONFIG_ISA
+#ifdef CONFIG_ISA_DMA_API
 EXPORT_SYMBOL(snd_dma_program);
 EXPORT_SYMBOL(snd_dma_disable);
 EXPORT_SYMBOL(snd_dma_pointer);

commit 543537bd922692bc978e2e356fcd8bfc9c2ee7d5
Author: Paulo Marques <pmarques@grupopie.com>
Date:   Thu Jun 23 00:09:02 2005 -0700

    [PATCH] create a kstrdup library function
    
    This patch creates a new kstrdup library function and changes the "local"
    implementations in several places to use this function.
    
    Most of the changes come from the sound and net subsystems.  The sound part
    had already been acknowledged by Takashi Iwai and the net part by David S.
    Miller.
    
    I left UML alone for now because I would need more time to read the code
    carefully before making changes there.
    
    Signed-off-by: Paulo Marques <pmarques@grupopie.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 0815fadeb3ec..7612884f530b 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -399,8 +399,8 @@ EXPORT_SYMBOL(snd_hidden_kcalloc);
 EXPORT_SYMBOL(snd_hidden_kfree);
 EXPORT_SYMBOL(snd_hidden_vmalloc);
 EXPORT_SYMBOL(snd_hidden_vfree);
+EXPORT_SYMBOL(snd_hidden_kstrdup);
 #endif
-EXPORT_SYMBOL(snd_kmalloc_strdup);
 EXPORT_SYMBOL(copy_to_user_fromio);
 EXPORT_SYMBOL(copy_from_user_toio);
   /* init.c */

commit fae6ec69c84d71b1d5bda9ede1a262c1681684aa
Merge: bbc0274e9bb2 1d345dac1f30
Author: Jaroslav Kysela <perex@hera.kernel.org>
Date:   Tue Jun 21 07:39:41 2005 -0700

    Merge with /pub/scm/linux/kernel/git/torvalds/linux-2.6.git

commit 619e666b7e9d2b0545ab60a9c824ae5f77c20c3b
Author: gregkh@suse.de <gregkh@suse.de>
Date:   Wed Mar 23 09:51:41 2005 -0800

    [PATCH] class: convert sound/* to use the new class api instead of class_simple
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 88e052079f85..33eaa5e5d284 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -64,7 +64,7 @@ static struct list_head snd_minors_hash[SNDRV_CARDS];
 
 static DECLARE_MUTEX(sound_mutex);
 
-extern struct class_simple *sound_class;
+extern struct class *sound_class;
 
 
 #ifdef CONFIG_KMOD
@@ -231,7 +231,7 @@ int snd_register_device(int type, snd_card_t * card, int dev, snd_minor_t * reg,
 		devfs_mk_cdev(MKDEV(major, minor), S_IFCHR | device_mode, "snd/%s", name);
 	if (card)
 		device = card->dev;
-	class_simple_device_add(sound_class, MKDEV(major, minor), device, name);
+	class_device_create(sound_class, MKDEV(major, minor), device, "%s", name);
 
 	up(&sound_mutex);
 	return 0;
@@ -263,7 +263,7 @@ int snd_unregister_device(int type, snd_card_t * card, int dev)
 
 	if (strncmp(mptr->name, "controlC", 8) || card->number >= cards_limit) /* created in sound.c */
 		devfs_remove("snd/%s", mptr->name);
-	class_simple_device_remove(MKDEV(major, minor));
+	class_device_destroy(sound_class, MKDEV(major, minor));
 
 	list_del(&mptr->list);
 	up(&sound_mutex);

commit 123992f728785e05f385d23893bd5ec69871aeb4
Author: Adrian Bunk <bunk@stusta.de>
Date:   Wed May 18 18:02:04 2005 +0200

    [ALSA] sound/core/: possible cleanups
    
    PCM Midlevel,ALSA Core,Timer Midlevel,ALSA sequencer,Virtual Midi
    This patch contains the following possible cleanups:
    - make needlessly global code static
    - #if 0 the following unused global functions
    - remove the following unneeded EXPORT_SYMBOL's
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/sound.c b/sound/core/sound.c
index 88e052079f85..fa92e660ec2c 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -431,7 +431,6 @@ EXPORT_SYMBOL(snd_card_pci_resume);
 EXPORT_SYMBOL(snd_device_new);
 EXPORT_SYMBOL(snd_device_register);
 EXPORT_SYMBOL(snd_device_free);
-EXPORT_SYMBOL(snd_device_free_all);
   /* isadma.c */
 #ifdef CONFIG_ISA
 EXPORT_SYMBOL(snd_dma_program);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/sound.c b/sound/core/sound.c
new file mode 100644
index 000000000000..88e052079f85
--- /dev/null
+++ b/sound/core/sound.c
@@ -0,0 +1,491 @@
+/*
+ *  Advanced Linux Sound Architecture
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/minors.h>
+#include <sound/info.h>
+#include <sound/version.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include <linux/kmod.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/device.h>
+
+#define SNDRV_OS_MINORS 256
+
+static int major = CONFIG_SND_MAJOR;
+int snd_major;
+static int cards_limit = 1;
+static int device_mode = S_IFCHR | S_IRUGO | S_IWUGO;
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_DESCRIPTION("Advanced Linux Sound Architecture driver for soundcards.");
+MODULE_LICENSE("GPL");
+module_param(major, int, 0444);
+MODULE_PARM_DESC(major, "Major # for sound driver.");
+module_param(cards_limit, int, 0444);
+MODULE_PARM_DESC(cards_limit, "Count of auto-loadable soundcards.");
+#ifdef CONFIG_DEVFS_FS
+module_param(device_mode, int, 0444);
+MODULE_PARM_DESC(device_mode, "Device file permission mask for devfs.");
+#endif
+MODULE_ALIAS_CHARDEV_MAJOR(CONFIG_SND_MAJOR);
+
+/* this one holds the actual max. card number currently available.
+ * as default, it's identical with cards_limit option.  when more
+ * modules are loaded manually, this limit number increases, too.
+ */
+int snd_ecards_limit;
+
+static struct list_head snd_minors_hash[SNDRV_CARDS];
+
+static DECLARE_MUTEX(sound_mutex);
+
+extern struct class_simple *sound_class;
+
+
+#ifdef CONFIG_KMOD
+
+/**
+ * snd_request_card - try to load the card module
+ * @card: the card number
+ *
+ * Tries to load the module "snd-card-X" for the given card number
+ * via KMOD.  Returns immediately if already loaded.
+ */
+void snd_request_card(int card)
+{
+	int locked;
+
+	if (! current->fs->root)
+		return;
+	read_lock(&snd_card_rwlock);
+	locked = snd_cards_lock & (1 << card);
+	read_unlock(&snd_card_rwlock);
+	if (locked)
+		return;
+	if (card < 0 || card >= cards_limit)
+		return;
+	request_module("snd-card-%i", card);
+}
+
+static void snd_request_other(int minor)
+{
+	char *str;
+
+	if (! current->fs->root)
+		return;
+	switch (minor) {
+	case SNDRV_MINOR_SEQUENCER:	str = "snd-seq";	break;
+	case SNDRV_MINOR_TIMER:		str = "snd-timer";	break;
+	default:			return;
+	}
+	request_module(str);
+}
+
+#endif				/* request_module support */
+
+static snd_minor_t *snd_minor_search(int minor)
+{
+	struct list_head *list;
+	snd_minor_t *mptr;
+
+	list_for_each(list, &snd_minors_hash[SNDRV_MINOR_CARD(minor)]) {
+		mptr = list_entry(list, snd_minor_t, list);
+		if (mptr->number == minor)
+			return mptr;
+	}
+	return NULL;
+}
+
+static int snd_open(struct inode *inode, struct file *file)
+{
+	int minor = iminor(inode);
+	int card = SNDRV_MINOR_CARD(minor);
+	int dev = SNDRV_MINOR_DEVICE(minor);
+	snd_minor_t *mptr = NULL;
+	struct file_operations *old_fops;
+	int err = 0;
+
+	if (dev != SNDRV_MINOR_SEQUENCER && dev != SNDRV_MINOR_TIMER) {
+		if (snd_cards[card] == NULL) {
+#ifdef CONFIG_KMOD
+			snd_request_card(card);
+			if (snd_cards[card] == NULL)
+#endif
+				return -ENODEV;
+		}
+	} else {
+#ifdef CONFIG_KMOD
+		if ((mptr = snd_minor_search(minor)) == NULL)
+			snd_request_other(minor);
+#endif
+	}
+	if (mptr == NULL && (mptr = snd_minor_search(minor)) == NULL)
+		return -ENODEV;
+	old_fops = file->f_op;
+	file->f_op = fops_get(mptr->f_ops);
+	if (file->f_op->open)
+		err = file->f_op->open(inode, file);
+	if (err) {
+		fops_put(file->f_op);
+		file->f_op = fops_get(old_fops);
+	}
+	fops_put(old_fops);
+	return err;
+}
+
+static struct file_operations snd_fops =
+{
+	.owner =	THIS_MODULE,
+	.open =		snd_open
+};
+
+static int snd_kernel_minor(int type, snd_card_t * card, int dev)
+{
+	int minor;
+
+	switch (type) {
+	case SNDRV_DEVICE_TYPE_SEQUENCER:
+	case SNDRV_DEVICE_TYPE_TIMER:
+		minor = type;
+		break;
+	case SNDRV_DEVICE_TYPE_CONTROL:
+		snd_assert(card != NULL, return -EINVAL);
+		minor = SNDRV_MINOR(card->number, type);
+		break;
+	case SNDRV_DEVICE_TYPE_HWDEP:
+	case SNDRV_DEVICE_TYPE_RAWMIDI:
+	case SNDRV_DEVICE_TYPE_PCM_PLAYBACK:
+	case SNDRV_DEVICE_TYPE_PCM_CAPTURE:
+		snd_assert(card != NULL, return -EINVAL);
+		minor = SNDRV_MINOR(card->number, type + dev);
+		break;
+	default:
+		return -EINVAL;
+	}
+	snd_assert(minor >= 0 && minor < SNDRV_OS_MINORS, return -EINVAL);
+	return minor;
+}
+
+/**
+ * snd_register_device - Register the ALSA device file for the card
+ * @type: the device type, SNDRV_DEVICE_TYPE_XXX
+ * @card: the card instance
+ * @dev: the device index
+ * @reg: the snd_minor_t record
+ * @name: the device file name
+ *
+ * Registers an ALSA device file for the given card.
+ * The operators have to be set in reg parameter.
+ *
+ * Retrurns zero if successful, or a negative error code on failure.
+ */
+int snd_register_device(int type, snd_card_t * card, int dev, snd_minor_t * reg, const char *name)
+{
+	int minor = snd_kernel_minor(type, card, dev);
+	snd_minor_t *preg;
+	struct device *device = NULL;
+
+	if (minor < 0)
+		return minor;
+	snd_assert(name, return -EINVAL);
+	preg = (snd_minor_t *)kmalloc(sizeof(snd_minor_t) + strlen(name) + 1, GFP_KERNEL);
+	if (preg == NULL)
+		return -ENOMEM;
+	*preg = *reg;
+	preg->number = minor;
+	preg->device = dev;
+	strcpy(preg->name, name);
+	down(&sound_mutex);
+	if (snd_minor_search(minor)) {
+		up(&sound_mutex);
+		kfree(preg);
+		return -EBUSY;
+	}
+	list_add_tail(&preg->list, &snd_minors_hash[SNDRV_MINOR_CARD(minor)]);
+	if (strncmp(name, "controlC", 8) || card->number >= cards_limit)
+		devfs_mk_cdev(MKDEV(major, minor), S_IFCHR | device_mode, "snd/%s", name);
+	if (card)
+		device = card->dev;
+	class_simple_device_add(sound_class, MKDEV(major, minor), device, name);
+
+	up(&sound_mutex);
+	return 0;
+}
+
+/**
+ * snd_unregister_device - unregister the device on the given card
+ * @type: the device type, SNDRV_DEVICE_TYPE_XXX
+ * @card: the card instance
+ * @dev: the device index
+ *
+ * Unregisters the device file already registered via
+ * snd_register_device().
+ *
+ * Returns zero if sucecessful, or a negative error code on failure
+ */
+int snd_unregister_device(int type, snd_card_t * card, int dev)
+{
+	int minor = snd_kernel_minor(type, card, dev);
+	snd_minor_t *mptr;
+
+	if (minor < 0)
+		return minor;
+	down(&sound_mutex);
+	if ((mptr = snd_minor_search(minor)) == NULL) {
+		up(&sound_mutex);
+		return -EINVAL;
+	}
+
+	if (strncmp(mptr->name, "controlC", 8) || card->number >= cards_limit) /* created in sound.c */
+		devfs_remove("snd/%s", mptr->name);
+	class_simple_device_remove(MKDEV(major, minor));
+
+	list_del(&mptr->list);
+	up(&sound_mutex);
+	kfree(mptr);
+	return 0;
+}
+
+/*
+ *  INFO PART
+ */
+
+static snd_info_entry_t *snd_minor_info_entry = NULL;
+
+static void snd_minor_info_read(snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+{
+	int card, device;
+	struct list_head *list;
+	snd_minor_t *mptr;
+
+	down(&sound_mutex);
+	for (card = 0; card < SNDRV_CARDS; card++) {
+		list_for_each(list, &snd_minors_hash[card]) {
+			mptr = list_entry(list, snd_minor_t, list);
+			if (SNDRV_MINOR_DEVICE(mptr->number) != SNDRV_MINOR_SEQUENCER) {
+				if ((device = mptr->device) >= 0)
+					snd_iprintf(buffer, "%3i: [%i-%2i]: %s\n", mptr->number, card, device, mptr->comment);
+				else
+					snd_iprintf(buffer, "%3i: [%i]   : %s\n", mptr->number, card, mptr->comment);
+			} else {
+				snd_iprintf(buffer, "%3i:       : %s\n", mptr->number, mptr->comment);
+			}
+		}
+	}
+	up(&sound_mutex);
+}
+
+int __init snd_minor_info_init(void)
+{
+	snd_info_entry_t *entry;
+
+	entry = snd_info_create_module_entry(THIS_MODULE, "devices", NULL);
+	if (entry) {
+		entry->c.text.read_size = PAGE_SIZE;
+		entry->c.text.read = snd_minor_info_read;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	snd_minor_info_entry = entry;
+	return 0;
+}
+
+int __exit snd_minor_info_done(void)
+{
+	if (snd_minor_info_entry)
+		snd_info_unregister(snd_minor_info_entry);
+	return 0;
+}
+
+/*
+ *  INIT PART
+ */
+
+static int __init alsa_sound_init(void)
+{
+	short controlnum;
+	int err;
+	int card;
+
+	snd_major = major;
+	snd_ecards_limit = cards_limit;
+	for (card = 0; card < SNDRV_CARDS; card++)
+		INIT_LIST_HEAD(&snd_minors_hash[card]);
+	if ((err = snd_oss_init_module()) < 0)
+		return err;
+	devfs_mk_dir("snd");
+	if (register_chrdev(major, "alsa", &snd_fops)) {
+		snd_printk(KERN_ERR "unable to register native major device number %d\n", major);
+		devfs_remove("snd");
+		return -EIO;
+	}
+	snd_memory_init();
+	if (snd_info_init() < 0) {
+		snd_memory_done();
+		unregister_chrdev(major, "alsa");
+		devfs_remove("snd");
+		return -ENOMEM;
+	}
+	snd_info_minor_register();
+	for (controlnum = 0; controlnum < cards_limit; controlnum++)
+		devfs_mk_cdev(MKDEV(major, controlnum<<5), S_IFCHR | device_mode, "snd/controlC%d", controlnum);
+#ifndef MODULE
+	printk(KERN_INFO "Advanced Linux Sound Architecture Driver Version " CONFIG_SND_VERSION CONFIG_SND_DATE ".\n");
+#endif
+	return 0;
+}
+
+static void __exit alsa_sound_exit(void)
+{
+	short controlnum;
+
+	for (controlnum = 0; controlnum < cards_limit; controlnum++)
+		devfs_remove("snd/controlC%d", controlnum);
+
+	snd_info_minor_unregister();
+	snd_info_done();
+	snd_memory_done();
+	if (unregister_chrdev(major, "alsa") != 0)
+		snd_printk(KERN_ERR "unable to unregister major device number %d\n", major);
+	devfs_remove("snd");
+}
+
+module_init(alsa_sound_init)
+module_exit(alsa_sound_exit)
+
+  /* sound.c */
+EXPORT_SYMBOL(snd_major);
+EXPORT_SYMBOL(snd_ecards_limit);
+#if defined(CONFIG_KMOD)
+EXPORT_SYMBOL(snd_request_card);
+#endif
+EXPORT_SYMBOL(snd_register_device);
+EXPORT_SYMBOL(snd_unregister_device);
+#if defined(CONFIG_SND_OSSEMUL)
+EXPORT_SYMBOL(snd_register_oss_device);
+EXPORT_SYMBOL(snd_unregister_oss_device);
+#endif
+  /* memory.c */
+#ifdef CONFIG_SND_DEBUG_MEMORY
+EXPORT_SYMBOL(snd_hidden_kmalloc);
+EXPORT_SYMBOL(snd_hidden_kcalloc);
+EXPORT_SYMBOL(snd_hidden_kfree);
+EXPORT_SYMBOL(snd_hidden_vmalloc);
+EXPORT_SYMBOL(snd_hidden_vfree);
+#endif
+EXPORT_SYMBOL(snd_kmalloc_strdup);
+EXPORT_SYMBOL(copy_to_user_fromio);
+EXPORT_SYMBOL(copy_from_user_toio);
+  /* init.c */
+EXPORT_SYMBOL(snd_cards);
+#if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
+EXPORT_SYMBOL(snd_mixer_oss_notify_callback);
+#endif
+EXPORT_SYMBOL(snd_card_new);
+EXPORT_SYMBOL(snd_card_disconnect);
+EXPORT_SYMBOL(snd_card_free);
+EXPORT_SYMBOL(snd_card_free_in_thread);
+EXPORT_SYMBOL(snd_card_register);
+EXPORT_SYMBOL(snd_component_add);
+EXPORT_SYMBOL(snd_card_file_add);
+EXPORT_SYMBOL(snd_card_file_remove);
+#ifdef CONFIG_PM
+EXPORT_SYMBOL(snd_power_wait);
+EXPORT_SYMBOL(snd_card_set_pm_callback);
+#if defined(CONFIG_PM) && defined(CONFIG_SND_GENERIC_PM)
+EXPORT_SYMBOL(snd_card_set_generic_pm_callback);
+#endif
+#ifdef CONFIG_PCI
+EXPORT_SYMBOL(snd_card_pci_suspend);
+EXPORT_SYMBOL(snd_card_pci_resume);
+#endif
+#endif
+  /* device.c */
+EXPORT_SYMBOL(snd_device_new);
+EXPORT_SYMBOL(snd_device_register);
+EXPORT_SYMBOL(snd_device_free);
+EXPORT_SYMBOL(snd_device_free_all);
+  /* isadma.c */
+#ifdef CONFIG_ISA
+EXPORT_SYMBOL(snd_dma_program);
+EXPORT_SYMBOL(snd_dma_disable);
+EXPORT_SYMBOL(snd_dma_pointer);
+#endif
+  /* info.c */
+#ifdef CONFIG_PROC_FS
+EXPORT_SYMBOL(snd_seq_root);
+EXPORT_SYMBOL(snd_iprintf);
+EXPORT_SYMBOL(snd_info_get_line);
+EXPORT_SYMBOL(snd_info_get_str);
+EXPORT_SYMBOL(snd_info_create_module_entry);
+EXPORT_SYMBOL(snd_info_create_card_entry);
+EXPORT_SYMBOL(snd_info_free_entry);
+EXPORT_SYMBOL(snd_info_register);
+EXPORT_SYMBOL(snd_info_unregister);
+EXPORT_SYMBOL(snd_card_proc_new);
+#endif
+  /* info_oss.c */
+#if defined(CONFIG_SND_OSSEMUL) && defined(CONFIG_PROC_FS)
+EXPORT_SYMBOL(snd_oss_info_register);
+#endif
+  /* control.c */
+EXPORT_SYMBOL(snd_ctl_new);
+EXPORT_SYMBOL(snd_ctl_new1);
+EXPORT_SYMBOL(snd_ctl_free_one);
+EXPORT_SYMBOL(snd_ctl_add);
+EXPORT_SYMBOL(snd_ctl_remove);
+EXPORT_SYMBOL(snd_ctl_remove_id);
+EXPORT_SYMBOL(snd_ctl_rename_id);
+EXPORT_SYMBOL(snd_ctl_find_numid);
+EXPORT_SYMBOL(snd_ctl_find_id);
+EXPORT_SYMBOL(snd_ctl_notify);
+EXPORT_SYMBOL(snd_ctl_register_ioctl);
+EXPORT_SYMBOL(snd_ctl_unregister_ioctl);
+#ifdef CONFIG_COMPAT
+EXPORT_SYMBOL(snd_ctl_register_ioctl_compat);
+EXPORT_SYMBOL(snd_ctl_unregister_ioctl_compat);
+#endif
+EXPORT_SYMBOL(snd_ctl_elem_read);
+EXPORT_SYMBOL(snd_ctl_elem_write);
+  /* misc.c */
+EXPORT_SYMBOL(snd_task_name);
+#ifdef CONFIG_SND_VERBOSE_PRINTK
+EXPORT_SYMBOL(snd_verbose_printk);
+#endif
+#if defined(CONFIG_SND_DEBUG) && defined(CONFIG_SND_VERBOSE_PRINTK)
+EXPORT_SYMBOL(snd_verbose_printd);
+#endif
+  /* wrappers */
+#ifdef CONFIG_SND_DEBUG_MEMORY
+EXPORT_SYMBOL(snd_wrapper_kmalloc);
+EXPORT_SYMBOL(snd_wrapper_kfree);
+EXPORT_SYMBOL(snd_wrapper_vmalloc);
+EXPORT_SYMBOL(snd_wrapper_vfree);
+#endif
