commit f9993480214f1345497875ed363a52b7ef7e33db
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Sat Jan 11 14:33:25 2020 -0600

    ALSA: timer: fix nsec/sec initialization confusion
    
    GCC reports a warning with W=1:
    
    sound/core/timer.c: In function ‘snd_timer_user_read’:
    sound/core/timer.c:2219:19: warning: initialized field overwritten
    [-Woverride-init]
     2219 |     .tstamp_sec = tread->tstamp_nsec,
          |                   ^~~~~
    sound/core/timer.c:2219:19: note: (near initialization for
    ‘(anonymous).tstamp_sec’)
    
    Assigning nsec values to sec fields is problematic in general, even
    more so when the initial goal was to survive the 2030 timer
    armageddon.
    
    Fix by using the proper field in the initialization
    
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Fixes: 07094ae6f9527 ("ALSA: Avoid using timespec for struct snd_timer_tread")
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lore.kernel.org/r/20200111203325.20498-1-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 8835ff91a893..d9f85f2d66a3 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -2216,7 +2216,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 			tread32 = (struct snd_timer_tread32) {
 				.event = tread->event,
 				.tstamp_sec = tread->tstamp_sec,
-				.tstamp_sec = tread->tstamp_nsec,
+				.tstamp_nsec = tread->tstamp_nsec,
 				.val = tread->val,
 			};
 

commit df76996a2c5369769b23a017b6303f7ecacb277b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:36 2020 +0100

    ALSA: timer: Constify snd_timer_hardware definitions
    
    Most of snd_timer_hardware definitions do simply copying to another
    struct as-is.  Mark them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-21-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index d53bc1f3a48a..8835ff91a893 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1199,7 +1199,7 @@ static int snd_timer_s_close(struct snd_timer *timer)
 	return 0;
 }
 
-static struct snd_timer_hardware snd_timer_system =
+static const struct snd_timer_hardware snd_timer_system =
 {
 	.flags =	SNDRV_TIMER_HW_FIRST | SNDRV_TIMER_HW_TASKLET,
 	.resolution =	1000000000L / HZ,

commit f15ee210cdb87f82147df237d2fcfc4527523d62
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:20 2020 +0100

    ALSA: core: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-5-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 4cfd8e691903..d53bc1f3a48a 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -936,7 +936,7 @@ int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,
 {
 	struct snd_timer *timer;
 	int err;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free = snd_timer_dev_free,
 		.dev_register = snd_timer_dev_register,
 		.dev_disconnect = snd_timer_dev_disconnect,

commit 07094ae6f9527279de6fd0c59e88f6d0423585b1
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Tue Apr 24 20:06:13 2018 +0800

    ALSA: Avoid using timespec for struct snd_timer_tread
    
    The struct snd_timer_tread will use 'timespec' type variables to record
    timestamp, which is not year 2038 safe on 32bits system.
    
    Since the struct snd_timer_tread is passed through read() rather than
    ioctl(), and the read syscall has no command number that lets us pick
    between the 32-bit or 64-bit version of this structure.
    
    Thus we introduced one new command SNDRV_TIMER_IOCTL_TREAD64 and new
    struct snd_timer_tread64 replacing timespec with s64 type to handle
    64bit time_t. That means we will set tu->tread = TREAD_FORMAT_64BIT
    when user space has a 64bit time_t, then we will copy to user with
    struct snd_timer_tread64. Otherwise we will use 32bit time_t variables
    when copying to user.
    
    Moreover this patch replaces timespec type with timespec64 type and
    related y2038 safe APIs.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index d2f69039f941..4cfd8e691903 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -44,6 +44,28 @@ MODULE_PARM_DESC(timer_tstamp_monotonic, "Use posix monotonic clock source for t
 MODULE_ALIAS_CHARDEV(CONFIG_SND_MAJOR, SNDRV_MINOR_TIMER);
 MODULE_ALIAS("devname:snd/timer");
 
+enum timer_tread_format {
+	TREAD_FORMAT_NONE = 0,
+	TREAD_FORMAT_TIME64,
+	TREAD_FORMAT_TIME32,
+};
+
+struct snd_timer_tread32 {
+	int event;
+	s32 tstamp_sec;
+	s32 tstamp_nsec;
+	unsigned int val;
+};
+
+struct snd_timer_tread64 {
+	int event;
+	u8 pad1[4];
+	s64 tstamp_sec;
+	s64 tstamp_nsec;
+	unsigned int val;
+	u8 pad2[4];
+};
+
 struct snd_timer_user {
 	struct snd_timer_instance *timeri;
 	int tread;		/* enhanced read with timestamps and events */
@@ -55,7 +77,7 @@ struct snd_timer_user {
 	int queue_size;
 	bool disconnected;
 	struct snd_timer_read *queue;
-	struct snd_timer_tread *tqueue;
+	struct snd_timer_tread64 *tqueue;
 	spinlock_t qlock;
 	unsigned long last_resolution;
 	unsigned int filter;
@@ -1329,7 +1351,7 @@ static void snd_timer_user_interrupt(struct snd_timer_instance *timeri,
 }
 
 static void snd_timer_user_append_to_tqueue(struct snd_timer_user *tu,
-					    struct snd_timer_tread *tread)
+					    struct snd_timer_tread64 *tread)
 {
 	if (tu->qused >= tu->queue_size) {
 		tu->overrun++;
@@ -1346,7 +1368,7 @@ static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,
 				     unsigned long resolution)
 {
 	struct snd_timer_user *tu = timeri->callback_data;
-	struct snd_timer_tread r1;
+	struct snd_timer_tread64 r1;
 	unsigned long flags;
 
 	if (event >= SNDRV_TIMER_EVENT_START &&
@@ -1356,7 +1378,8 @@ static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,
 		return;
 	memset(&r1, 0, sizeof(r1));
 	r1.event = event;
-	r1.tstamp = timespec64_to_timespec(*tstamp);
+	r1.tstamp_sec = tstamp->tv_sec;
+	r1.tstamp_nsec = tstamp->tv_nsec;
 	r1.val = resolution;
 	spin_lock_irqsave(&tu->qlock, flags);
 	snd_timer_user_append_to_tqueue(tu, &r1);
@@ -1378,7 +1401,7 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 				      unsigned long ticks)
 {
 	struct snd_timer_user *tu = timeri->callback_data;
-	struct snd_timer_tread *r, r1;
+	struct snd_timer_tread64 *r, r1;
 	struct timespec64 tstamp;
 	int prev, append = 0;
 
@@ -1399,7 +1422,8 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&
 	    tu->last_resolution != resolution) {
 		r1.event = SNDRV_TIMER_EVENT_RESOLUTION;
-		r1.tstamp = timespec64_to_timespec(tstamp);
+		r1.tstamp_sec = tstamp.tv_sec;
+		r1.tstamp_nsec = tstamp.tv_nsec;
 		r1.val = resolution;
 		snd_timer_user_append_to_tqueue(tu, &r1);
 		tu->last_resolution = resolution;
@@ -1413,14 +1437,16 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 		prev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;
 		r = &tu->tqueue[prev];
 		if (r->event == SNDRV_TIMER_EVENT_TICK) {
-			r->tstamp = timespec64_to_timespec(tstamp);
+			r->tstamp_sec = tstamp.tv_sec;
+			r->tstamp_nsec = tstamp.tv_nsec;
 			r->val += ticks;
 			append++;
 			goto __wake;
 		}
 	}
 	r1.event = SNDRV_TIMER_EVENT_TICK;
-	r1.tstamp = timespec64_to_timespec(tstamp);
+	r1.tstamp_sec = tstamp.tv_sec;
+	r1.tstamp_nsec = tstamp.tv_nsec;
 	r1.val = ticks;
 	snd_timer_user_append_to_tqueue(tu, &r1);
 	append++;
@@ -1435,7 +1461,7 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 static int realloc_user_queue(struct snd_timer_user *tu, int size)
 {
 	struct snd_timer_read *queue = NULL;
-	struct snd_timer_tread *tqueue = NULL;
+	struct snd_timer_tread64 *tqueue = NULL;
 
 	if (tu->tread) {
 		tqueue = kcalloc(size, sizeof(*tqueue), GFP_KERNEL);
@@ -1874,11 +1900,11 @@ static int snd_timer_user_params(struct file *file,
 	tu->qhead = tu->qtail = tu->qused = 0;
 	if (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {
 		if (tu->tread) {
-			struct snd_timer_tread tread;
+			struct snd_timer_tread64 tread;
 			memset(&tread, 0, sizeof(tread));
 			tread.event = SNDRV_TIMER_EVENT_EARLY;
-			tread.tstamp.tv_sec = 0;
-			tread.tstamp.tv_nsec = 0;
+			tread.tstamp_sec = 0;
+			tread.tstamp_nsec = 0;
 			tread.val = 0;
 			snd_timer_user_append_to_tqueue(tu, &tread);
 		} else {
@@ -2008,6 +2034,36 @@ static int snd_timer_user_pause(struct file *file)
 	return 0;
 }
 
+static int snd_timer_user_tread(void __user *argp, struct snd_timer_user *tu,
+				unsigned int cmd, bool compat)
+{
+	int __user *p = argp;
+	int xarg, old_tread;
+
+	if (tu->timeri)	/* too late */
+		return -EBUSY;
+	if (get_user(xarg, p))
+		return -EFAULT;
+
+	old_tread = tu->tread;
+
+	if (!xarg)
+		tu->tread = TREAD_FORMAT_NONE;
+	else if (cmd == SNDRV_TIMER_IOCTL_TREAD64 ||
+		 (IS_ENABLED(CONFIG_64BIT) && !compat))
+		tu->tread = TREAD_FORMAT_TIME64;
+	else
+		tu->tread = TREAD_FORMAT_TIME32;
+
+	if (tu->tread != old_tread &&
+	    realloc_user_queue(tu, tu->queue_size) < 0) {
+		tu->tread = old_tread;
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
 enum {
 	SNDRV_TIMER_IOCTL_START_OLD = _IO('T', 0x20),
 	SNDRV_TIMER_IOCTL_STOP_OLD = _IO('T', 0x21),
@@ -2016,7 +2072,7 @@ enum {
 };
 
 static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,
-				 unsigned long arg)
+				 unsigned long arg, bool compat)
 {
 	struct snd_timer_user *tu;
 	void __user *argp = (void __user *)arg;
@@ -2028,23 +2084,9 @@ static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 		return put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;
 	case SNDRV_TIMER_IOCTL_NEXT_DEVICE:
 		return snd_timer_user_next_device(argp);
-	case SNDRV_TIMER_IOCTL_TREAD:
-	{
-		int xarg, old_tread;
-
-		if (tu->timeri)	/* too late */
-			return -EBUSY;
-		if (get_user(xarg, p))
-			return -EFAULT;
-		old_tread = tu->tread;
-		tu->tread = xarg ? 1 : 0;
-		if (tu->tread != old_tread &&
-		    realloc_user_queue(tu, tu->queue_size) < 0) {
-			tu->tread = old_tread;
-			return -ENOMEM;
-		}
-		return 0;
-	}
+	case SNDRV_TIMER_IOCTL_TREAD_OLD:
+	case SNDRV_TIMER_IOCTL_TREAD64:
+		return snd_timer_user_tread(argp, tu, cmd, compat);
 	case SNDRV_TIMER_IOCTL_GINFO:
 		return snd_timer_user_ginfo(file, argp);
 	case SNDRV_TIMER_IOCTL_GPARAMS:
@@ -2084,7 +2126,7 @@ static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 	long ret;
 
 	mutex_lock(&tu->ioctl_lock);
-	ret = __snd_timer_user_ioctl(file, cmd, arg);
+	ret = __snd_timer_user_ioctl(file, cmd, arg, false);
 	mutex_unlock(&tu->ioctl_lock);
 	return ret;
 }
@@ -2100,13 +2142,29 @@ static int snd_timer_user_fasync(int fd, struct file * file, int on)
 static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 				   size_t count, loff_t *offset)
 {
+	struct snd_timer_tread64 *tread;
+	struct snd_timer_tread32 tread32;
 	struct snd_timer_user *tu;
 	long result = 0, unit;
 	int qhead;
 	int err = 0;
 
 	tu = file->private_data;
-	unit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);
+	switch (tu->tread) {
+	case TREAD_FORMAT_TIME64:
+		unit = sizeof(struct snd_timer_tread64);
+		break;
+	case TREAD_FORMAT_TIME32:
+		unit = sizeof(struct snd_timer_tread32);
+		break;
+	case TREAD_FORMAT_NONE:
+		unit = sizeof(struct snd_timer_read);
+		break;
+	default:
+		WARN_ONCE(1, "Corrupt snd_timer_user\n");
+		return -ENOTSUPP;
+	}
+
 	mutex_lock(&tu->ioctl_lock);
 	spin_lock_irq(&tu->qlock);
 	while ((long)count - result >= unit) {
@@ -2145,14 +2203,34 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 		tu->qused--;
 		spin_unlock_irq(&tu->qlock);
 
-		if (tu->tread) {
-			if (copy_to_user(buffer, &tu->tqueue[qhead],
-					 sizeof(struct snd_timer_tread)))
+		tread = &tu->tqueue[qhead];
+
+		switch (tu->tread) {
+		case TREAD_FORMAT_TIME64:
+			if (copy_to_user(buffer, tread,
+					 sizeof(struct snd_timer_tread64)))
 				err = -EFAULT;
-		} else {
+			break;
+		case TREAD_FORMAT_TIME32:
+			memset(&tread32, 0, sizeof(tread32));
+			tread32 = (struct snd_timer_tread32) {
+				.event = tread->event,
+				.tstamp_sec = tread->tstamp_sec,
+				.tstamp_sec = tread->tstamp_nsec,
+				.val = tread->val,
+			};
+
+			if (copy_to_user(buffer, &tread32, sizeof(tread32)))
+				err = -EFAULT;
+			break;
+		case TREAD_FORMAT_NONE:
 			if (copy_to_user(buffer, &tu->queue[qhead],
 					 sizeof(struct snd_timer_read)))
 				err = -EFAULT;
+			break;
+		default:
+			err = -ENOTSUPP;
+			break;
 		}
 
 		spin_lock_irq(&tu->qlock);

commit a07804cc7472d8aa5db03ea5d75f3d8d80abb687
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Tue Apr 24 20:06:09 2018 +0800

    ALSA: Avoid using timespec for struct snd_timer_status
    
    struct snd_timer_status uses 'timespec' type variables to record
    timestamp, which will be changed to an incompatible layout with
    updated user space using 64-bit time_t.
    
    To handle both the old and the new layout on 32-bit architectures,
    this patch introduces 'struct snd_timer_status32' and 'struct snd_timer_status64'
    to handle 32bit time_t and 64bit time_t in native mode and compat mode,
    which replaces timespec with s64 type.
    
    When glibc changes time_t to 64-bit, any recompiled program will issue
    ioctl commands that the kernel does not understand without this patch.
    
    In the public uapi header, snd_timer_status is now guarded by
    an #ifndef __KERNEL__ to avoid referencing 'struct timespec'.
    The timespec definition will be removed from the kernel to prevent
    new y2038 bugs and to avoid the conflict with an incompatible libc
    type of the same name.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index d808d5554c7a..d2f69039f941 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -65,6 +65,30 @@ struct snd_timer_user {
 	struct mutex ioctl_lock;
 };
 
+struct snd_timer_status32 {
+	s32 tstamp_sec;			/* Timestamp - last update */
+	s32 tstamp_nsec;
+	unsigned int resolution;	/* current period resolution in ns */
+	unsigned int lost;		/* counter of master tick lost */
+	unsigned int overrun;		/* count of read queue overruns */
+	unsigned int queue;		/* used queue size */
+	unsigned char reserved[64];	/* reserved */
+};
+
+#define SNDRV_TIMER_IOCTL_STATUS32	_IOR('T', 0x14, struct snd_timer_status32)
+
+struct snd_timer_status64 {
+	s64 tstamp_sec;			/* Timestamp - last update */
+	s64 tstamp_nsec;
+	unsigned int resolution;	/* current period resolution in ns */
+	unsigned int lost;		/* counter of master tick lost */
+	unsigned int overrun;		/* count of read queue overruns */
+	unsigned int queue;		/* used queue size */
+	unsigned char reserved[64];	/* reserved */
+};
+
+#define SNDRV_TIMER_IOCTL_STATUS64	_IOR('T', 0x14, struct snd_timer_status64)
+
 /* list of timers */
 static LIST_HEAD(snd_timer_list);
 
@@ -1875,17 +1899,41 @@ static int snd_timer_user_params(struct file *file,
 	return err;
 }
 
-static int snd_timer_user_status(struct file *file,
-				 struct snd_timer_status __user *_status)
+static int snd_timer_user_status32(struct file *file,
+				   struct snd_timer_status32 __user *_status)
+ {
+	struct snd_timer_user *tu;
+	struct snd_timer_status32 status;
+
+	tu = file->private_data;
+	if (!tu->timeri)
+		return -EBADFD;
+	memset(&status, 0, sizeof(status));
+	status.tstamp_sec = tu->tstamp.tv_sec;
+	status.tstamp_nsec = tu->tstamp.tv_nsec;
+	status.resolution = snd_timer_resolution(tu->timeri);
+	status.lost = tu->timeri->lost;
+	status.overrun = tu->overrun;
+	spin_lock_irq(&tu->qlock);
+	status.queue = tu->qused;
+	spin_unlock_irq(&tu->qlock);
+	if (copy_to_user(_status, &status, sizeof(status)))
+		return -EFAULT;
+	return 0;
+}
+
+static int snd_timer_user_status64(struct file *file,
+				   struct snd_timer_status64 __user *_status)
 {
 	struct snd_timer_user *tu;
-	struct snd_timer_status status;
+	struct snd_timer_status64 status;
 
 	tu = file->private_data;
 	if (!tu->timeri)
 		return -EBADFD;
 	memset(&status, 0, sizeof(status));
-	status.tstamp = timespec64_to_timespec(tu->tstamp);
+	status.tstamp_sec = tu->tstamp.tv_sec;
+	status.tstamp_nsec = tu->tstamp.tv_nsec;
 	status.resolution = snd_timer_resolution(tu->timeri);
 	status.lost = tu->timeri->lost;
 	status.overrun = tu->overrun;
@@ -2009,8 +2057,10 @@ static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 		return snd_timer_user_info(file, argp);
 	case SNDRV_TIMER_IOCTL_PARAMS:
 		return snd_timer_user_params(file, argp);
-	case SNDRV_TIMER_IOCTL_STATUS:
-		return snd_timer_user_status(file, argp);
+	case SNDRV_TIMER_IOCTL_STATUS32:
+		return snd_timer_user_status32(file, argp);
+	case SNDRV_TIMER_IOCTL_STATUS64:
+		return snd_timer_user_status64(file, argp);
 	case SNDRV_TIMER_IOCTL_START:
 	case SNDRV_TIMER_IOCTL_START_OLD:
 		return snd_timer_user_start(file);

commit fcae40c99fb3d09f4407f549a7f17761abe5e1bc
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Tue Apr 24 20:06:08 2018 +0800

    ALSA: Replace timespec with timespec64
    
    Since timespec is not year 2038 safe on 32bit system, and we need to
    convert all timespec variables to timespec64 type for sound subsystem.
    
    This patch is used to do preparation for following patches, that will
    convert all structures defined in uapi/sound/asound.h to use 64-bit
    time_t.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 24fed5c78273..d808d5554c7a 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -59,7 +59,7 @@ struct snd_timer_user {
 	spinlock_t qlock;
 	unsigned long last_resolution;
 	unsigned int filter;
-	struct timespec tstamp;		/* trigger tstamp */
+	struct timespec64 tstamp;		/* trigger tstamp */
 	wait_queue_head_t qchange_sleep;
 	struct fasync_struct *fasync;
 	struct mutex ioctl_lock;
@@ -453,12 +453,12 @@ static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 	struct snd_timer *timer = ti->timer;
 	unsigned long resolution = 0;
 	struct snd_timer_instance *ts;
-	struct timespec tstamp;
+	struct timespec64 tstamp;
 
 	if (timer_tstamp_monotonic)
-		ktime_get_ts(&tstamp);
+		ktime_get_ts64(&tstamp);
 	else
-		getnstimeofday(&tstamp);
+		ktime_get_real_ts64(&tstamp);
 	if (snd_BUG_ON(event < SNDRV_TIMER_EVENT_START ||
 		       event > SNDRV_TIMER_EVENT_PAUSE))
 		return;
@@ -1025,7 +1025,7 @@ static int snd_timer_dev_disconnect(struct snd_device *device)
 	return 0;
 }
 
-void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstamp)
+void snd_timer_notify(struct snd_timer *timer, int event, struct timespec64 *tstamp)
 {
 	unsigned long flags;
 	unsigned long resolution = 0;
@@ -1318,7 +1318,7 @@ static void snd_timer_user_append_to_tqueue(struct snd_timer_user *tu,
 
 static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,
 				     int event,
-				     struct timespec *tstamp,
+				     struct timespec64 *tstamp,
 				     unsigned long resolution)
 {
 	struct snd_timer_user *tu = timeri->callback_data;
@@ -1332,7 +1332,7 @@ static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,
 		return;
 	memset(&r1, 0, sizeof(r1));
 	r1.event = event;
-	r1.tstamp = *tstamp;
+	r1.tstamp = timespec64_to_timespec(*tstamp);
 	r1.val = resolution;
 	spin_lock_irqsave(&tu->qlock, flags);
 	snd_timer_user_append_to_tqueue(tu, &r1);
@@ -1355,7 +1355,7 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 {
 	struct snd_timer_user *tu = timeri->callback_data;
 	struct snd_timer_tread *r, r1;
-	struct timespec tstamp;
+	struct timespec64 tstamp;
 	int prev, append = 0;
 
 	memset(&r1, 0, sizeof(r1));
@@ -1368,14 +1368,14 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 	}
 	if (tu->last_resolution != resolution || ticks > 0) {
 		if (timer_tstamp_monotonic)
-			ktime_get_ts(&tstamp);
+			ktime_get_ts64(&tstamp);
 		else
-			getnstimeofday(&tstamp);
+			ktime_get_real_ts64(&tstamp);
 	}
 	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&
 	    tu->last_resolution != resolution) {
 		r1.event = SNDRV_TIMER_EVENT_RESOLUTION;
-		r1.tstamp = tstamp;
+		r1.tstamp = timespec64_to_timespec(tstamp);
 		r1.val = resolution;
 		snd_timer_user_append_to_tqueue(tu, &r1);
 		tu->last_resolution = resolution;
@@ -1389,14 +1389,14 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 		prev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;
 		r = &tu->tqueue[prev];
 		if (r->event == SNDRV_TIMER_EVENT_TICK) {
-			r->tstamp = tstamp;
+			r->tstamp = timespec64_to_timespec(tstamp);
 			r->val += ticks;
 			append++;
 			goto __wake;
 		}
 	}
 	r1.event = SNDRV_TIMER_EVENT_TICK;
-	r1.tstamp = tstamp;
+	r1.tstamp = timespec64_to_timespec(tstamp);
 	r1.val = ticks;
 	snd_timer_user_append_to_tqueue(tu, &r1);
 	append++;
@@ -1885,7 +1885,7 @@ static int snd_timer_user_status(struct file *file,
 	if (!tu->timeri)
 		return -EBADFD;
 	memset(&status, 0, sizeof(status));
-	status.tstamp = tu->tstamp;
+	status.tstamp = timespec64_to_timespec(tu->tstamp);
 	status.resolution = snd_timer_resolution(tu->timeri);
 	status.lost = tu->timeri->lost;
 	status.overrun = tu->overrun;

commit 0c4f09ceec3d7afbef6ad4077d96e36e0fad4028
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 11 18:36:42 2019 +0100

    ALSA: timer: Fix the breakage of slave link open
    
    A silly mistake was made while applying the fix for potential races in
    commit 6a34367e52ca ("ALSA: timer: Fix possible race at assigning a
    timer instance"): when a slave PCM is opened and succeeds, it doesn't
    return but proceeds to the master timer open code instead.  Plug the
    hole and beautify a bit.
    
    Fixes: 6a34367e52ca ("ALSA: timer: Fix possible race at assigning a timer instance")
    Reported-by: syzbot+4476917c053f60112c99@syzkaller.appspotmail.com
    Link: https://lore.kernel.org/r/20191111173642.6093-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 9091030f4a89..24fed5c78273 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -268,8 +268,7 @@ int snd_timer_open(struct snd_timer_instance *timeri,
 		list_add_tail(&timeri->open_list, &snd_timer_slave_list);
 		num_slaves++;
 		err = snd_timer_check_slave(timeri);
-		if (err < 0)
-			goto close;
+		goto list_added;
 	}
 
 	/* open a master instance */
@@ -324,7 +323,7 @@ int snd_timer_open(struct snd_timer_instance *timeri,
 	list_add_tail(&timeri->open_list, &timer->open_list_head);
 	timer->num_instances++;
 	err = snd_timer_check_master(timeri);
- close:
+list_added:
 	if (err < 0)
 		snd_timer_close_locked(timeri, &card_dev_to_put);
 

commit 6a34367e52caea1413eb0a0dcbb524f0c9b67e82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 7 20:20:08 2019 +0100

    ALSA: timer: Fix possible race at assigning a timer instance
    
    When a new timer instance is created and assigned to the active link
    in snd_timer_open(), the caller still doesn't (can't) set its callback
    and callback data.  In both the user-timer and the sequencer-timer
    code, they do manually set up the callbacks after calling
    snd_timer_open().  This has a potential risk of race when the timer
    instance is added to the already running timer target, as the callback
    might get triggered during setting up the callback itself.
    
    This patch tries to address it by changing the API usage slightly:
    
    - An empty timer instance is created at first via the new function
      snd_timer_instance_new().  This object isn't linked to the timer
      list yet.
    - The caller sets up the callbacks and others stuff for the new timer
      instance.
    - The caller invokes snd_timer_open() with this instance, so that it's
      linked to the target timer.
    
    For closing, do similarly:
    
    - Call snd_timer_close().  This unlinks the timer instance from the
      timer list.
    - Free the timer instance via snd_timer_instance_free() after that.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Link: https://lore.kernel.org/r/20191107192008.32331-4-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index c0a73913ec62..9091030f4a89 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -88,12 +88,11 @@ static void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_l
 
 /*
  * create a timer instance with the given owner string.
- * when timer is not NULL, increments the module counter
  */
-static struct snd_timer_instance *snd_timer_instance_new(char *owner,
-							 struct snd_timer *timer)
+struct snd_timer_instance *snd_timer_instance_new(const char *owner)
 {
 	struct snd_timer_instance *timeri;
+
 	timeri = kzalloc(sizeof(*timeri), GFP_KERNEL);
 	if (timeri == NULL)
 		return NULL;
@@ -108,15 +107,20 @@ static struct snd_timer_instance *snd_timer_instance_new(char *owner,
 	INIT_LIST_HEAD(&timeri->slave_list_head);
 	INIT_LIST_HEAD(&timeri->slave_active_head);
 
-	timeri->timer = timer;
-	if (timer && !try_module_get(timer->module)) {
+	return timeri;
+}
+EXPORT_SYMBOL(snd_timer_instance_new);
+
+void snd_timer_instance_free(struct snd_timer_instance *timeri)
+{
+	if (timeri) {
+		if (timeri->private_free)
+			timeri->private_free(timeri);
 		kfree(timeri->owner);
 		kfree(timeri);
-		return NULL;
 	}
-
-	return timeri;
 }
+EXPORT_SYMBOL(snd_timer_instance_free);
 
 /*
  * find a timer instance from the given timer id
@@ -236,12 +240,11 @@ static void snd_timer_close_locked(struct snd_timer_instance *timeri,
  * open a timer instance
  * when opening a master, the slave id must be here given.
  */
-int snd_timer_open(struct snd_timer_instance **ti,
-		   char *owner, struct snd_timer_id *tid,
+int snd_timer_open(struct snd_timer_instance *timeri,
+		   struct snd_timer_id *tid,
 		   unsigned int slave_id)
 {
 	struct snd_timer *timer;
-	struct snd_timer_instance *timeri = NULL;
 	struct device *card_dev_to_put = NULL;
 	int err;
 
@@ -259,22 +262,14 @@ int snd_timer_open(struct snd_timer_instance **ti,
 			err = -EBUSY;
 			goto unlock;
 		}
-		timeri = snd_timer_instance_new(owner, NULL);
-		if (!timeri) {
-			err = -ENOMEM;
-			goto unlock;
-		}
 		timeri->slave_class = tid->dev_sclass;
 		timeri->slave_id = tid->device;
 		timeri->flags |= SNDRV_TIMER_IFLG_SLAVE;
 		list_add_tail(&timeri->open_list, &snd_timer_slave_list);
 		num_slaves++;
 		err = snd_timer_check_slave(timeri);
-		if (err < 0) {
-			snd_timer_close_locked(timeri, &card_dev_to_put);
-			timeri = NULL;
-		}
-		goto unlock;
+		if (err < 0)
+			goto close;
 	}
 
 	/* open a master instance */
@@ -304,45 +299,40 @@ int snd_timer_open(struct snd_timer_instance **ti,
 		err = -EBUSY;
 		goto unlock;
 	}
-	timeri = snd_timer_instance_new(owner, timer);
-	if (!timeri) {
-		err = -ENOMEM;
+	if (!try_module_get(timer->module)) {
+		err = -EBUSY;
 		goto unlock;
 	}
 	/* take a card refcount for safe disconnection */
-	if (timer->card)
+	if (timer->card) {
 		get_device(&timer->card->card_dev);
-	timeri->slave_class = tid->dev_sclass;
-	timeri->slave_id = slave_id;
+		card_dev_to_put = &timer->card->card_dev;
+	}
 
 	if (list_empty(&timer->open_list_head) && timer->hw.open) {
 		err = timer->hw.open(timer);
 		if (err) {
-			kfree(timeri->owner);
-			kfree(timeri);
-			timeri = NULL;
-
-			if (timer->card)
-				card_dev_to_put = &timer->card->card_dev;
 			module_put(timer->module);
 			goto unlock;
 		}
 	}
 
+	timeri->timer = timer;
+	timeri->slave_class = tid->dev_sclass;
+	timeri->slave_id = slave_id;
+
 	list_add_tail(&timeri->open_list, &timer->open_list_head);
 	timer->num_instances++;
 	err = snd_timer_check_master(timeri);
-	if (err < 0) {
+ close:
+	if (err < 0)
 		snd_timer_close_locked(timeri, &card_dev_to_put);
-		timeri = NULL;
-	}
 
  unlock:
 	mutex_unlock(&register_mutex);
 	/* put_device() is called after unlock for avoiding deadlock */
-	if (card_dev_to_put)
+	if (err < 0 && card_dev_to_put)
 		put_device(card_dev_to_put);
-	*ti = timeri;
 	return err;
 }
 EXPORT_SYMBOL(snd_timer_open);
@@ -363,9 +353,11 @@ static void snd_timer_close_locked(struct snd_timer_instance *timeri,
 		spin_unlock_irq(&timer->lock);
 	}
 
-	list_del(&timeri->open_list);
-	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)
-		num_slaves--;
+	if (!list_empty(&timeri->open_list)) {
+		list_del_init(&timeri->open_list);
+		if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)
+			num_slaves--;
+	}
 
 	/* force to stop the timer */
 	snd_timer_stop(timeri);
@@ -384,6 +376,7 @@ static void snd_timer_close_locked(struct snd_timer_instance *timeri,
 		/* remove slave links */
 		spin_lock_irq(&slave_active_lock);
 		spin_lock(&timer->lock);
+		timeri->timer = NULL;
 		list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,
 					 open_list) {
 			list_move_tail(&slave->open_list, &snd_timer_slave_list);
@@ -401,11 +394,6 @@ static void snd_timer_close_locked(struct snd_timer_instance *timeri,
 			timer = NULL;
 	}
 
-	if (timeri->private_free)
-		timeri->private_free(timeri);
-	kfree(timeri->owner);
-	kfree(timeri);
-
 	if (timer) {
 		if (list_empty(&timer->open_list_head) && timer->hw.close)
 			timer->hw.close(timer);
@@ -1480,8 +1468,10 @@ static int snd_timer_user_release(struct inode *inode, struct file *file)
 		tu = file->private_data;
 		file->private_data = NULL;
 		mutex_lock(&tu->ioctl_lock);
-		if (tu->timeri)
+		if (tu->timeri) {
 			snd_timer_close(tu->timeri);
+			snd_timer_instance_free(tu->timeri);
+		}
 		mutex_unlock(&tu->ioctl_lock);
 		kfree(tu->queue);
 		kfree(tu->tqueue);
@@ -1722,6 +1712,7 @@ static int snd_timer_user_tselect(struct file *file,
 	tu = file->private_data;
 	if (tu->timeri) {
 		snd_timer_close(tu->timeri);
+		snd_timer_instance_free(tu->timeri);
 		tu->timeri = NULL;
 	}
 	if (copy_from_user(&tselect, _tselect, sizeof(tselect))) {
@@ -1731,9 +1722,11 @@ static int snd_timer_user_tselect(struct file *file,
 	sprintf(str, "application %i", current->pid);
 	if (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)
 		tselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;
-	err = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);
-	if (err < 0)
+	tu->timeri = snd_timer_instance_new(str);
+	if (!tu->timeri) {
+		err = -ENOMEM;
 		goto __err;
+	}
 
 	tu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;
 	tu->timeri->callback = tu->tread
@@ -1742,6 +1735,12 @@ static int snd_timer_user_tselect(struct file *file,
 	tu->timeri->callback_data = (void *)tu;
 	tu->timeri->disconnect = snd_timer_user_disconnect;
 
+	err = snd_timer_open(tu->timeri, &tselect.id, current->pid);
+	if (err < 0) {
+		snd_timer_instance_free(tu->timeri);
+		tu->timeri = NULL;
+	}
+
       __err:
 	return err;
 }

commit 33bbb8a0ecd142fb5e78f26f3a0b927ae77c30e7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 7 20:20:07 2019 +0100

    ALSA: timer: Make snd_timer_close() returning void
    
    The function doesn't return any useful value, so let's make it void to
    be clearer.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Link: https://lore.kernel.org/r/20191107192008.32331-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 21c2d25e4074..c0a73913ec62 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -229,8 +229,8 @@ static int snd_timer_check_master(struct snd_timer_instance *master)
 	return err < 0 ? err : 0;
 }
 
-static int snd_timer_close_locked(struct snd_timer_instance *timeri,
-				  struct device **card_devp_to_put);
+static void snd_timer_close_locked(struct snd_timer_instance *timeri,
+				   struct device **card_devp_to_put);
 
 /*
  * open a timer instance
@@ -351,8 +351,8 @@ EXPORT_SYMBOL(snd_timer_open);
  * close a timer instance
  * call this with register_mutex down.
  */
-static int snd_timer_close_locked(struct snd_timer_instance *timeri,
-				  struct device **card_devp_to_put)
+static void snd_timer_close_locked(struct snd_timer_instance *timeri,
+				   struct device **card_devp_to_put)
 {
 	struct snd_timer *timer = timeri->timer;
 	struct snd_timer_instance *slave, *tmp;
@@ -414,28 +414,24 @@ static int snd_timer_close_locked(struct snd_timer_instance *timeri,
 			*card_devp_to_put = &timer->card->card_dev;
 		module_put(timer->module);
 	}
-
-	return 0;
 }
 
 /*
  * close a timer instance
  */
-int snd_timer_close(struct snd_timer_instance *timeri)
+void snd_timer_close(struct snd_timer_instance *timeri)
 {
 	struct device *card_dev_to_put = NULL;
-	int err;
 
 	if (snd_BUG_ON(!timeri))
-		return -ENXIO;
+		return;
 
 	mutex_lock(&register_mutex);
-	err = snd_timer_close_locked(timeri, &card_dev_to_put);
+	snd_timer_close_locked(timeri, &card_dev_to_put);
 	mutex_unlock(&register_mutex);
 	/* put_device() is called after unlock for avoiding deadlock */
 	if (card_dev_to_put)
 		put_device(card_dev_to_put);
-	return err;
 }
 EXPORT_SYMBOL(snd_timer_close);
 

commit ebfc6de29ae8e48f91e280fd37539188b5252b38
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 7 20:20:06 2019 +0100

    ALSA: timer: Unify master/slave linking code
    
    The code in both snd_timer_check_master() and snd_timer_check_slave()
    are almost identical, both check whether the master/slave link and
    does linkage.  Factor out the common code and call it from both
    functions for readability.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Link: https://lore.kernel.org/r/20191107192008.32331-2-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 013f0e69ff0f..21c2d25e4074 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -163,6 +163,28 @@ static void snd_timer_request(struct snd_timer_id *tid)
 
 #endif
 
+/* move the slave if it belongs to the master; return 1 if match */
+static int check_matching_master_slave(struct snd_timer_instance *master,
+				       struct snd_timer_instance *slave)
+{
+	if (slave->slave_class != master->slave_class ||
+	    slave->slave_id != master->slave_id)
+		return 0;
+	if (master->timer->num_instances >= master->timer->max_instances)
+		return -EBUSY;
+	list_move_tail(&slave->open_list, &master->slave_list_head);
+	master->timer->num_instances++;
+	spin_lock_irq(&slave_active_lock);
+	spin_lock(&master->timer->lock);
+	slave->master = master;
+	slave->timer = master->timer;
+	if (slave->flags & SNDRV_TIMER_IFLG_RUNNING)
+		list_add_tail(&slave->active_list, &master->slave_active_head);
+	spin_unlock(&master->timer->lock);
+	spin_unlock_irq(&slave_active_lock);
+	return 1;
+}
+
 /*
  * look for a master instance matching with the slave id of the given slave.
  * when found, relink the open_link of the slave.
@@ -173,27 +195,18 @@ static int snd_timer_check_slave(struct snd_timer_instance *slave)
 {
 	struct snd_timer *timer;
 	struct snd_timer_instance *master;
+	int err = 0;
 
 	/* FIXME: it's really dumb to look up all entries.. */
 	list_for_each_entry(timer, &snd_timer_list, device_list) {
 		list_for_each_entry(master, &timer->open_list_head, open_list) {
-			if (slave->slave_class == master->slave_class &&
-			    slave->slave_id == master->slave_id) {
-				if (master->timer->num_instances >=
-				    master->timer->max_instances)
-					return -EBUSY;
-				list_move_tail(&slave->open_list,
-					       &master->slave_list_head);
-				master->timer->num_instances++;
-				spin_lock_irq(&slave_active_lock);
-				slave->master = master;
-				slave->timer = master->timer;
-				spin_unlock_irq(&slave_active_lock);
-				return 0;
-			}
+			err = check_matching_master_slave(master, slave);
+			if (err != 0) /* match found or error */
+				goto out;
 		}
 	}
-	return 0;
+ out:
+	return err < 0 ? err : 0;
 }
 
 /*
@@ -205,28 +218,15 @@ static int snd_timer_check_slave(struct snd_timer_instance *slave)
 static int snd_timer_check_master(struct snd_timer_instance *master)
 {
 	struct snd_timer_instance *slave, *tmp;
+	int err = 0;
 
 	/* check all pending slaves */
 	list_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {
-		if (slave->slave_class == master->slave_class &&
-		    slave->slave_id == master->slave_id) {
-			if (master->timer->num_instances >=
-			    master->timer->max_instances)
-				return -EBUSY;
-			list_move_tail(&slave->open_list, &master->slave_list_head);
-			master->timer->num_instances++;
-			spin_lock_irq(&slave_active_lock);
-			spin_lock(&master->timer->lock);
-			slave->master = master;
-			slave->timer = master->timer;
-			if (slave->flags & SNDRV_TIMER_IFLG_RUNNING)
-				list_add_tail(&slave->active_list,
-					      &master->slave_active_head);
-			spin_unlock(&master->timer->lock);
-			spin_unlock_irq(&slave_active_lock);
-		}
+		err = check_matching_master_slave(master, slave);
+		if (err < 0)
+			break;
 	}
-	return 0;
+	return err < 0 ? err : 0;
 }
 
 static int snd_timer_close_locked(struct snd_timer_instance *timeri,

commit 66a8966aac12f2a79de514dbbe99c9b3e90c9280
Merge: 9ff7759731db df37d941c4b5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 7 16:27:49 2019 +0100

    Merge branch 'for-linus' into for-next
    
    Merge 5.4-devel branch for applying the further ALSA timer fixes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit e7af6307a8a54f0b873960b32b6a644f2d0fbd97
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 6 17:55:47 2019 +0100

    ALSA: timer: Fix incorrectly assigned timer instance
    
    The clean up commit 41672c0c24a6 ("ALSA: timer: Simplify error path in
    snd_timer_open()") unified the error handling code paths with the
    standard goto, but it introduced a subtle bug: the timer instance is
    stored in snd_timer_open() incorrectly even if it returns an error.
    This may eventually lead to UAF, as spotted by fuzzer.
    
    The culprit is the snd_timer_open() code checks the
    SNDRV_TIMER_IFLG_EXCLUSIVE flag with the common variable timeri.
    This variable is supposed to be the newly created instance, but we
    (ab-)used it for a temporary check before the actual creation of a
    timer instance.  After that point, there is another check for the max
    number of instances, and it bails out if over the threshold.  Before
    the refactoring above, it worked fine because the code returned
    directly from that point.  After the refactoring, however, it jumps to
    the unified error path that stores the timeri variable in return --
    even if it returns an error.  Unfortunately this stored value is kept
    in the caller side (snd_timer_user_tselect()) in tu->timeri.  This
    causes inconsistency later, as if the timer was successfully
    assigned.
    
    In this patch, we fix it by not re-using timeri variable but a
    temporary variable for testing the exclusive connection, so timeri
    remains NULL at that point.
    
    Fixes: 41672c0c24a6 ("ALSA: timer: Simplify error path in snd_timer_open()")
    Reported-and-tested-by: Tristan Madani <tristmd@gmail.com>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20191106165547.23518-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 6b724d2ee2de..59ae21b0bb93 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -284,11 +284,11 @@ int snd_timer_open(struct snd_timer_instance **ti,
 		goto unlock;
 	}
 	if (!list_empty(&timer->open_list_head)) {
-		timeri = list_entry(timer->open_list_head.next,
+		struct snd_timer_instance *t =
+			list_entry(timer->open_list_head.next,
 				    struct snd_timer_instance, open_list);
-		if (timeri->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {
+		if (t->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {
 			err = -EBUSY;
-			timeri = NULL;
 			goto unlock;
 		}
 	}

commit fdea53fe5de532969a332d6e5e727f2ad8bf084d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 6 16:42:57 2019 +0100

    ALSA: timer: Limit max amount of slave instances
    
    The fuzzer tries to open the timer instances as much as possible, and
    this may cause a system hiccup easily.  We've already introduced the
    cap for the max number of available instances for the h/w timers, and
    we should put such a limit also to the slave timers, too.
    
    This patch introduces the limit to the multiple opened slave timers.
    The upper limit is hard-coded to 1000 for now, which should suffice
    for any practical usages up to now.
    
    Link: https://lore.kernel.org/r/20191106154257.5853-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 5c9fbf3f4340..219249627cc3 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -74,6 +74,9 @@ static LIST_HEAD(snd_timer_slave_list);
 /* lock for slave active lists */
 static DEFINE_SPINLOCK(slave_active_lock);
 
+#define MAX_SLAVE_INSTANCES	1000
+static int num_slaves;
+
 static DEFINE_MUTEX(register_mutex);
 
 static int snd_timer_free(struct snd_timer *timer);
@@ -250,6 +253,10 @@ int snd_timer_open(struct snd_timer_instance **ti,
 			err = -EINVAL;
 			goto unlock;
 		}
+		if (num_slaves >= MAX_SLAVE_INSTANCES) {
+			err = -EBUSY;
+			goto unlock;
+		}
 		timeri = snd_timer_instance_new(owner, NULL);
 		if (!timeri) {
 			err = -ENOMEM;
@@ -259,6 +266,7 @@ int snd_timer_open(struct snd_timer_instance **ti,
 		timeri->slave_id = tid->device;
 		timeri->flags |= SNDRV_TIMER_IFLG_SLAVE;
 		list_add_tail(&timeri->open_list, &snd_timer_slave_list);
+		num_slaves++;
 		err = snd_timer_check_slave(timeri);
 		if (err < 0) {
 			snd_timer_close_locked(timeri);
@@ -350,6 +358,8 @@ static int snd_timer_close_locked(struct snd_timer_instance *timeri)
 	}
 
 	list_del(&timeri->open_list);
+	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)
+		num_slaves--;
 
 	/* force to stop the timer */
 	snd_timer_stop(timeri);

commit a39331867335d4a94b6165e306265c9e24aca073
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 30 22:42:57 2019 +0100

    ALSA: timer: Fix mutex deadlock at releasing card
    
    When a card is disconnected while in use, the system waits until all
    opened files are closed then releases the card.  This is done via
    put_device() of the card device in each device release code.
    
    The recently reported mutex deadlock bug happens in this code path;
    snd_timer_close() for the timer device deals with the global
    register_mutex and it calls put_device() there.  When this timer
    device is the last one, the card gets freed and it eventually calls
    snd_timer_free(), which has again the protection with the global
    register_mutex -- boom.
    
    Basically put_device() call itself is race-free, so a relative simple
    workaround is to move this put_device() call out of the mutex.  For
    achieving that, in this patch, snd_timer_close_locked() got a new
    argument to store the card device pointer in return, and each caller
    invokes put_device() with the returned object after the mutex unlock.
    
    Reported-and-tested-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 5c9fbf3f4340..6b724d2ee2de 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -226,7 +226,8 @@ static int snd_timer_check_master(struct snd_timer_instance *master)
 	return 0;
 }
 
-static int snd_timer_close_locked(struct snd_timer_instance *timeri);
+static int snd_timer_close_locked(struct snd_timer_instance *timeri,
+				  struct device **card_devp_to_put);
 
 /*
  * open a timer instance
@@ -238,6 +239,7 @@ int snd_timer_open(struct snd_timer_instance **ti,
 {
 	struct snd_timer *timer;
 	struct snd_timer_instance *timeri = NULL;
+	struct device *card_dev_to_put = NULL;
 	int err;
 
 	mutex_lock(&register_mutex);
@@ -261,7 +263,7 @@ int snd_timer_open(struct snd_timer_instance **ti,
 		list_add_tail(&timeri->open_list, &snd_timer_slave_list);
 		err = snd_timer_check_slave(timeri);
 		if (err < 0) {
-			snd_timer_close_locked(timeri);
+			snd_timer_close_locked(timeri, &card_dev_to_put);
 			timeri = NULL;
 		}
 		goto unlock;
@@ -313,7 +315,7 @@ int snd_timer_open(struct snd_timer_instance **ti,
 			timeri = NULL;
 
 			if (timer->card)
-				put_device(&timer->card->card_dev);
+				card_dev_to_put = &timer->card->card_dev;
 			module_put(timer->module);
 			goto unlock;
 		}
@@ -323,12 +325,15 @@ int snd_timer_open(struct snd_timer_instance **ti,
 	timer->num_instances++;
 	err = snd_timer_check_master(timeri);
 	if (err < 0) {
-		snd_timer_close_locked(timeri);
+		snd_timer_close_locked(timeri, &card_dev_to_put);
 		timeri = NULL;
 	}
 
  unlock:
 	mutex_unlock(&register_mutex);
+	/* put_device() is called after unlock for avoiding deadlock */
+	if (card_dev_to_put)
+		put_device(card_dev_to_put);
 	*ti = timeri;
 	return err;
 }
@@ -338,7 +343,8 @@ EXPORT_SYMBOL(snd_timer_open);
  * close a timer instance
  * call this with register_mutex down.
  */
-static int snd_timer_close_locked(struct snd_timer_instance *timeri)
+static int snd_timer_close_locked(struct snd_timer_instance *timeri,
+				  struct device **card_devp_to_put)
 {
 	struct snd_timer *timer = timeri->timer;
 	struct snd_timer_instance *slave, *tmp;
@@ -395,7 +401,7 @@ static int snd_timer_close_locked(struct snd_timer_instance *timeri)
 			timer->hw.close(timer);
 		/* release a card refcount for safe disconnection */
 		if (timer->card)
-			put_device(&timer->card->card_dev);
+			*card_devp_to_put = &timer->card->card_dev;
 		module_put(timer->module);
 	}
 
@@ -407,14 +413,18 @@ static int snd_timer_close_locked(struct snd_timer_instance *timeri)
  */
 int snd_timer_close(struct snd_timer_instance *timeri)
 {
+	struct device *card_dev_to_put = NULL;
 	int err;
 
 	if (snd_BUG_ON(!timeri))
 		return -ENXIO;
 
 	mutex_lock(&register_mutex);
-	err = snd_timer_close_locked(timeri);
+	err = snd_timer_close_locked(timeri, &card_dev_to_put);
 	mutex_unlock(&register_mutex);
+	/* put_device() is called after unlock for avoiding deadlock */
+	if (card_dev_to_put)
+		put_device(card_dev_to_put);
 	return err;
 }
 EXPORT_SYMBOL(snd_timer_close);

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index e3973957b392..5c9fbf3f4340 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1,22 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Timers abstract layer
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/delay.h>

commit e57ccca1ba33e1d92cc3bbf8b6304a46948844b0
Merge: a2d635decbfa ed97c988bdc6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 9 08:26:55 2019 -0700

    Merge tag 'sound-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "The most significant changes at this cycle are the Sound Open Firmware
      support from Intel for the common DSP framework along with its support
      for Intel platforms. It's a door opened to a real "free" firmware (in
      the sense of FOSS), and other parties show interests in it.
    
      In addition to SOF, we've got a bunch of updates and fixes as usual.
      Some highlights are below.
    
      ALSA core:
       - Cleanups and fixes in ALSA timer code to cover some races spotted
         by syzkaller
       - Cleanups and fixes in ALSA sequencer code to cover some races,
         again unsurprisingly, spotted by syzkaller
       - Optimize the common page allocation helper with alloc_pages_exact()
    
      ASoC:
       - Add SOF core support, as well as Intel SOF platform support
       - Generic card driver improvements: support for MCLK/sample rate
         ratio and pin switches
       - A big set of improvements to TLV320AIC32x4 drivers
       - New drivers for Freescale audio mixers, several Intel machines,
         several Mediatek machines, Meson G12A, Spreadtrum compressed audio
         and DMA devices
    
      HD-audio:
       - A few Realtek codec fixes for reducing pop noises
       - Quirks for Chromebooks
       - Workaround for faulty connection report on AMD/Nvidia HDMI
    
      Others:
       - A quirk for Focusrite Scarlett Solo USB-audio
       - Add support for MOTU 8pre FireWire
       - 24bit sample format support in aloop
       - GUS patch format support (finally, over a decade) in native emux
         synth code"
    
    * tag 'sound-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (375 commits)
      ASoC: SOF: Fix unused variable warnings
      ALSA: line6: toneport: Fix broken usage of timer for delayed execution
      ALSA: aica: Fix a long-time build breakage
      ALSA: hda/realtek - Support low power consumption for ALC256
      ASoC: stm32: i2s: update pcm hardware constraints
      ASoC: codec: hdac_hdmi: no checking monitor in hw_params
      ASoC: mediatek: mt6358: save PGA for mixer control
      ASoC: mediatek: mt6358: save output volume for mixer controls
      ASoC: mediatek: mt6358: initialize setting when ramping volume
      ASoC: SOF: core: fix undefined nocodec reference
      ASoC: SOF: xtensa: fix undefined references
      ASoC: SOF: Propagate sof_get_ctrl_copy_params() error properly
      ALSA: hdea/realtek - Headset fixup for System76 Gazelle (gaze14)
      ALSA: hda/intel: add CometLake PCI IDs
      ALSA: hda/realtek - Support low power consumption for ALC295
      ASoC: rockchip: Fix an uninitialized variable compile warning
      ASoC: SOF: Fix a compile warning with CONFIG_PCI=n
      ASoC: da7219: Fix a compile warning at CONFIG_COMMON_CLK=n
      ASoC: sound/soc/sof/: fix kconfig dependency warning
      ASoC: stm32: spdifrx: change trace level on iec control
      ...

commit c5bf68fe0c86a5835bd2e6aead1c49976360753f
Author: Kirill Smelkov <kirr@nexedi.com>
Date:   Tue Mar 26 23:51:19 2019 +0300

    *: convert stream-like files from nonseekable_open -> stream_open
    
    Using scripts/coccinelle/api/stream_open.cocci added in 10dce8af3422
    ("fs: stream_open - opener for stream-like files so that read and write
    can run simultaneously without deadlock"), search and convert to
    stream_open all in-kernel nonseekable_open users for which read and
    write actually do not depend on ppos and where there is no other methods
    in file_operations which assume @offset access.
    
    I've verified each generated change manually - that it is correct to convert -
    and each other nonseekable_open instance left - that it is either not correct
    to convert there, or that it is not converted due to current stream_open.cocci
    limitations. The script also does not convert files that should be valid to
    convert, but that currently have .llseek = noop_llseek or generic_file_llseek
    for unknown reason despite file being opened with nonseekable_open (e.g.
    drivers/input/mousedev.c)
    
    Among cases converted 14 were potentially vulnerable to read vs write deadlock
    (see details in 10dce8af3422):
    
            drivers/char/pcmcia/cm4000_cs.c:1685:7-23: ERROR: cm4000_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/gnss/core.c:45:1-17: ERROR: gnss_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/hid/uhid.c:635:1-17: ERROR: uhid_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/infiniband/core/user_mad.c:988:1-17: ERROR: umad_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/input/evdev.c:527:1-17: ERROR: evdev_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/input/misc/uinput.c:401:1-17: ERROR: uinput_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/isdn/capi/capi.c:963:8-24: ERROR: capi_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/leds/uleds.c:77:1-17: ERROR: uleds_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/media/rc/lirc_dev.c:198:1-17: ERROR: lirc_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/s390/char/fs3270.c:488:1-17: ERROR: fs3270_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/usb/misc/ldusb.c:310:1-17: ERROR: ld_usb_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            drivers/xen/evtchn.c:667:8-24: ERROR: evtchn_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            net/batman-adv/icmp_socket.c:80:1-17: ERROR: batadv_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
            net/rfkill/core.c:1146:8-24: ERROR: rfkill_fops: .read() can deadlock .write(); change nonseekable_open -> stream_open to fix.
    
    and the rest were just safe to convert to stream_open because their read and
    write do not use ppos at all and corresponding file_operations do not
    have methods that assume @offset file access(*):
    
            arch/powerpc/platforms/52xx/mpc52xx_gpt.c:631:8-24: WARNING: mpc52xx_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/powerpc/platforms/cell/spufs/file.c:591:8-24: WARNING: spufs_ibox_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/powerpc/platforms/cell/spufs/file.c:591:8-24: WARNING: spufs_ibox_stat_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/powerpc/platforms/cell/spufs/file.c:591:8-24: WARNING: spufs_mbox_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/powerpc/platforms/cell/spufs/file.c:591:8-24: WARNING: spufs_mbox_stat_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/powerpc/platforms/cell/spufs/file.c:591:8-24: WARNING: spufs_wbox_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/powerpc/platforms/cell/spufs/file.c:591:8-24: WARNING: spufs_wbox_stat_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/um/drivers/harddog_kern.c:88:8-24: WARNING: harddog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            arch/x86/kernel/cpu/microcode/core.c:430:33-49: WARNING: microcode_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/char/ds1620.c:215:8-24: WARNING: ds1620_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/char/dtlk.c:301:1-17: WARNING: dtlk_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/char/ipmi/ipmi_watchdog.c:840:9-25: WARNING: ipmi_wdog_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/char/pcmcia/scr24x_cs.c:95:8-24: WARNING: scr24x_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/char/tb0219.c:246:9-25: WARNING: tb0219_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/firewire/nosy.c:306:8-24: WARNING: nosy_ops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/hwmon/fschmd.c:840:8-24: WARNING: watchdog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/hwmon/w83793.c:1344:8-24: WARNING: watchdog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/infiniband/core/ucma.c:1747:8-24: WARNING: ucma_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/infiniband/core/ucm.c:1178:8-24: WARNING: ucm_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/infiniband/core/uverbs_main.c:1086:8-24: WARNING: uverbs_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/input/joydev.c:282:1-17: WARNING: joydev_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/pci/switch/switchtec.c:393:1-17: WARNING: switchtec_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/platform/chrome/cros_ec_debugfs.c:135:8-24: WARNING: cros_ec_console_log_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/rtc/rtc-ds1374.c:470:9-25: WARNING: ds1374_wdt_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/rtc/rtc-m41t80.c:805:9-25: WARNING: wdt_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/s390/char/tape_char.c:293:2-18: WARNING: tape_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/s390/char/zcore.c:194:8-24: WARNING: zcore_reipl_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/s390/crypto/zcrypt_api.c:528:8-24: WARNING: zcrypt_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/spi/spidev.c:594:1-17: WARNING: spidev_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/staging/pi433/pi433_if.c:974:1-17: WARNING: pi433_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/acquirewdt.c:203:8-24: WARNING: acq_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/advantechwdt.c:202:8-24: WARNING: advwdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/alim1535_wdt.c:252:8-24: WARNING: ali_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/alim7101_wdt.c:217:8-24: WARNING: wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/ar7_wdt.c:166:8-24: WARNING: ar7_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/at91rm9200_wdt.c:113:8-24: WARNING: at91wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/ath79_wdt.c:135:8-24: WARNING: ath79_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/bcm63xx_wdt.c:119:8-24: WARNING: bcm63xx_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/cpu5wdt.c:143:8-24: WARNING: cpu5wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/cpwd.c:397:8-24: WARNING: cpwd_fops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/eurotechwdt.c:319:8-24: WARNING: eurwdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/f71808e_wdt.c:528:8-24: WARNING: watchdog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/gef_wdt.c:232:8-24: WARNING: gef_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/geodewdt.c:95:8-24: WARNING: geodewdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/ib700wdt.c:241:8-24: WARNING: ibwdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/ibmasr.c:326:8-24: WARNING: asr_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/indydog.c:80:8-24: WARNING: indydog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/intel_scu_watchdog.c:307:8-24: WARNING: intel_scu_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/iop_wdt.c:104:8-24: WARNING: iop_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/it8712f_wdt.c:330:8-24: WARNING: it8712f_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/ixp4xx_wdt.c:68:8-24: WARNING: ixp4xx_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/ks8695_wdt.c:145:8-24: WARNING: ks8695wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/m54xx_wdt.c:88:8-24: WARNING: m54xx_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/machzwd.c:336:8-24: WARNING: zf_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/mixcomwd.c:153:8-24: WARNING: mixcomwd_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/mtx-1_wdt.c:121:8-24: WARNING: mtx1_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/mv64x60_wdt.c:136:8-24: WARNING: mv64x60_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/nuc900_wdt.c:134:8-24: WARNING: nuc900wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/nv_tco.c:164:8-24: WARNING: nv_tco_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pc87413_wdt.c:289:8-24: WARNING: pc87413_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pcwd.c:698:8-24: WARNING: pcwd_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pcwd.c:737:8-24: WARNING: pcwd_temp_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pcwd_pci.c:581:8-24: WARNING: pcipcwd_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pcwd_pci.c:623:8-24: WARNING: pcipcwd_temp_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pcwd_usb.c:488:8-24: WARNING: usb_pcwd_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pcwd_usb.c:527:8-24: WARNING: usb_pcwd_temperature_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pika_wdt.c:121:8-24: WARNING: pikawdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/pnx833x_wdt.c:119:8-24: WARNING: pnx833x_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/rc32434_wdt.c:153:8-24: WARNING: rc32434_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/rdc321x_wdt.c:145:8-24: WARNING: rdc321x_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/riowd.c:79:1-17: WARNING: riowd_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sa1100_wdt.c:62:8-24: WARNING: sa1100dog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sbc60xxwdt.c:211:8-24: WARNING: wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sbc7240_wdt.c:139:8-24: WARNING: wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sbc8360.c:274:8-24: WARNING: sbc8360_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sbc_epx_c3.c:81:8-24: WARNING: epx_c3_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sbc_fitpc2_wdt.c:78:8-24: WARNING: fitpc2_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sb_wdog.c:108:1-17: WARNING: sbwdog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sc1200wdt.c:181:8-24: WARNING: sc1200wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sc520_wdt.c:261:8-24: WARNING: wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/sch311x_wdt.c:319:8-24: WARNING: sch311x_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/scx200_wdt.c:105:8-24: WARNING: scx200_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/smsc37b787_wdt.c:369:8-24: WARNING: wb_smsc_wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/w83877f_wdt.c:227:8-24: WARNING: wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/w83977f_wdt.c:301:8-24: WARNING: wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wafer5823wdt.c:200:8-24: WARNING: wafwdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/watchdog_dev.c:828:8-24: WARNING: watchdog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdrtas.c:379:8-24: WARNING: wdrtas_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdrtas.c:445:8-24: WARNING: wdrtas_temp_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdt285.c:104:1-17: WARNING: watchdog_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdt977.c:276:8-24: WARNING: wdt977_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdt.c:424:8-24: WARNING: wdt_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdt.c:484:8-24: WARNING: wdt_temp_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdt_pci.c:464:8-24: WARNING: wdtpci_fops: .write() has stream semantic; safe to change nonseekable_open -> stream_open.
            drivers/watchdog/wdt_pci.c:527:8-24: WARNING: wdtpci_temp_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            net/batman-adv/log.c:105:1-17: WARNING: batadv_log_fops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            sound/core/control.c:57:7-23: WARNING: snd_ctl_f_ops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
            sound/core/rawmidi.c:385:7-23: WARNING: snd_rawmidi_f_ops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            sound/core/seq/seq_clientmgr.c:310:7-23: WARNING: snd_seq_f_ops: .read() and .write() have stream semantic; safe to change nonseekable_open -> stream_open.
            sound/core/timer.c:1428:7-23: WARNING: snd_timer_f_ops: .read() has stream semantic; safe to change nonseekable_open -> stream_open.
    
    One can also recheck/review the patch via generating it with explanation comments included via
    
            $ make coccicheck MODE=patch COCCI=scripts/coccinelle/api/stream_open.cocci SPFLAGS="-D explain"
    
    (*) This second group also contains cases with read/write deadlocks that
    stream_open.cocci don't yet detect, but which are still valid to convert to
    stream_open since ppos is not used. For example drivers/pci/switch/switchtec.c
    calls wait_for_completion_interruptible() in its .read, but stream_open.cocci
    currently detects only "wait_event*" as blocking.
    
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Yongzhi Pan <panyongzhi@gmail.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Kirill Tkhai <ktkhai@virtuozzo.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Nikolaus Rath <Nikolaus@rath.org>
    Cc: Han-Wen Nienhuys <hanwen@google.com>
    Cc: Anatolij Gustschin <agust@denx.de>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James R. Van Zandt" <jrv@vanzandt.mv.com>
    Cc: Corey Minyard <minyard@acm.org>
    Cc: Harald Welte <laforge@gnumonks.org>
    Acked-by: Lubomir Rintel <lkundrak@v3.sk> [scr24x_cs]
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: David Herrmann <dh.herrmann@googlemail.com>
    Cc: Jiri Kosina <jikos@kernel.org>
    Cc: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Cc: Jean Delvare <jdelvare@suse.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>    [watchdog/* hwmon/*]
    Cc: Rudolf Marek <r.marek@assembler.cz>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Karsten Keil <isdn@linux-pingi.de>
    Cc: Jacek Anaszewski <jacek.anaszewski@gmail.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: Kurt Schwemmer <kurt.schwemmer@microsemi.com>
    Acked-by: Logan Gunthorpe <logang@deltatee.com> [drivers/pci/switch/switchtec]
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> [drivers/pci/switch/switchtec]
    Cc: Benson Leung <bleung@chromium.org>
    Acked-by: Enric Balletbo i Serra <enric.balletbo@collabora.com> [platform/chrome]
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com> [rtc/*]
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Wim Van Sebroeck <wim@linux-watchdog.org>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Cc: Zwane Mwaikambo <zwanem@gmail.com>
    Cc: Marek Lindner <mareklindner@neomailbox.ch>
    Cc: Simon Wunderlich <sw@simonwunderlich.de>
    Cc: Antonio Quartulli <a@unstable.cc>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Signed-off-by: Kirill Smelkov <kirr@nexedi.com>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 61a0cec6e1f6..b842b61f66c2 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1425,7 +1425,7 @@ static int snd_timer_user_open(struct inode *inode, struct file *file)
 	struct snd_timer_user *tu;
 	int err;
 
-	err = nonseekable_open(inode, file);
+	err = stream_open(inode, file);
 	if (err < 0)
 		return err;
 

commit 5d704b0d3b4855734f029337e516b829c473801c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 28 17:44:53 2019 +0100

    ALSA: timer: Coding style fixes
    
    Avoid old school C style but do plain and clear way.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 0eed4fe0da21..d23efec35660 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1909,7 +1909,10 @@ static int snd_timer_user_start(struct file *file)
 	snd_timer_stop(tu->timeri);
 	tu->timeri->lost = 0;
 	tu->last_resolution = 0;
-	return (err = snd_timer_start(tu->timeri, tu->ticks)) < 0 ? err : 0;
+	err = snd_timer_start(tu->timeri, tu->ticks);
+	if (err < 0)
+		return err;
+	return 0;
 }
 
 static int snd_timer_user_stop(struct file *file)
@@ -1920,7 +1923,10 @@ static int snd_timer_user_stop(struct file *file)
 	tu = file->private_data;
 	if (!tu->timeri)
 		return -EBADFD;
-	return (err = snd_timer_stop(tu->timeri)) < 0 ? err : 0;
+	err = snd_timer_stop(tu->timeri);
+	if (err < 0)
+		return err;
+	return 0;
 }
 
 static int snd_timer_user_continue(struct file *file)
@@ -1935,7 +1941,10 @@ static int snd_timer_user_continue(struct file *file)
 	if (!(tu->timeri->flags & SNDRV_TIMER_IFLG_PAUSED))
 		return snd_timer_user_start(file);
 	tu->timeri->lost = 0;
-	return (err = snd_timer_continue(tu->timeri)) < 0 ? err : 0;
+	err = snd_timer_continue(tu->timeri);
+	if (err < 0)
+		return err;
+	return 0;
 }
 
 static int snd_timer_user_pause(struct file *file)
@@ -1946,7 +1955,10 @@ static int snd_timer_user_pause(struct file *file)
 	tu = file->private_data;
 	if (!tu->timeri)
 		return -EBADFD;
-	return (err = snd_timer_pause(tu->timeri)) < 0 ? err : 0;
+	err = snd_timer_pause(tu->timeri);
+	if (err < 0)
+		return err;
+	return 0;
 }
 
 enum {

commit 41672c0c24a62699d20aab53b98d843b16483053
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 28 17:11:10 2019 +0100

    ALSA: timer: Simplify error path in snd_timer_open()
    
    Just a minor refactoring to use the standard goto for error paths in
    snd_timer_open() instead of open code.  The first mutex_lock() is
    moved to the beginning of the function to make the code clearer.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index df52d2960179..0eed4fe0da21 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -255,19 +255,20 @@ int snd_timer_open(struct snd_timer_instance **ti,
 	struct snd_timer_instance *timeri = NULL;
 	int err;
 
+	mutex_lock(&register_mutex);
 	if (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {
 		/* open a slave instance */
 		if (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||
 		    tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {
 			pr_debug("ALSA: timer: invalid slave class %i\n",
 				 tid->dev_sclass);
-			return -EINVAL;
+			err = -EINVAL;
+			goto unlock;
 		}
-		mutex_lock(&register_mutex);
 		timeri = snd_timer_instance_new(owner, NULL);
 		if (!timeri) {
-			mutex_unlock(&register_mutex);
-			return -ENOMEM;
+			err = -ENOMEM;
+			goto unlock;
 		}
 		timeri->slave_class = tid->dev_sclass;
 		timeri->slave_id = tid->device;
@@ -278,13 +279,10 @@ int snd_timer_open(struct snd_timer_instance **ti,
 			snd_timer_close_locked(timeri);
 			timeri = NULL;
 		}
-		mutex_unlock(&register_mutex);
-		*ti = timeri;
-		return err;
+		goto unlock;
 	}
 
 	/* open a master instance */
-	mutex_lock(&register_mutex);
 	timer = snd_timer_find(tid);
 #ifdef CONFIG_MODULES
 	if (!timer) {
@@ -295,25 +293,26 @@ int snd_timer_open(struct snd_timer_instance **ti,
 	}
 #endif
 	if (!timer) {
-		mutex_unlock(&register_mutex);
-		return -ENODEV;
+		err = -ENODEV;
+		goto unlock;
 	}
 	if (!list_empty(&timer->open_list_head)) {
 		timeri = list_entry(timer->open_list_head.next,
 				    struct snd_timer_instance, open_list);
 		if (timeri->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {
-			mutex_unlock(&register_mutex);
-			return -EBUSY;
+			err = -EBUSY;
+			timeri = NULL;
+			goto unlock;
 		}
 	}
 	if (timer->num_instances >= timer->max_instances) {
-		mutex_unlock(&register_mutex);
-		return -EBUSY;
+		err = -EBUSY;
+		goto unlock;
 	}
 	timeri = snd_timer_instance_new(owner, timer);
 	if (!timeri) {
-		mutex_unlock(&register_mutex);
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto unlock;
 	}
 	/* take a card refcount for safe disconnection */
 	if (timer->card)
@@ -322,16 +321,16 @@ int snd_timer_open(struct snd_timer_instance **ti,
 	timeri->slave_id = slave_id;
 
 	if (list_empty(&timer->open_list_head) && timer->hw.open) {
-		int err = timer->hw.open(timer);
+		err = timer->hw.open(timer);
 		if (err) {
 			kfree(timeri->owner);
 			kfree(timeri);
+			timeri = NULL;
 
 			if (timer->card)
 				put_device(&timer->card->card_dev);
 			module_put(timer->module);
-			mutex_unlock(&register_mutex);
-			return err;
+			goto unlock;
 		}
 	}
 
@@ -342,6 +341,8 @@ int snd_timer_open(struct snd_timer_instance **ti,
 		snd_timer_close_locked(timeri);
 		timeri = NULL;
 	}
+
+ unlock:
 	mutex_unlock(&register_mutex);
 	*ti = timeri;
 	return err;

commit df55531b8b0eea9d2473f5697ae4f38d0df6bec7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 9 12:25:32 2019 +0200

    ALSA: timer: Revert active callback sync check at close
    
    This is essentially a revert of the commit a7588c896b05 ("ALSA: timer:
    Check ack_list emptiness instead of bit flag").  The intended change
    by the commit turns out to be insufficient, as snd_timer_close*()
    always calls snd_timer_stop() that deletes the ack_list beforehand.
    
    In theory, we can change the behavior of snd_timer_stop() to sync the
    pending ack_list, but this will become a deadlock for the callback
    like sequencer that calls again snd_timer_stop() from itself.  So,
    reverting the change is a more straightforward solution.
    
    Fixes: a7588c896b05 ("ALSA: timer: Check ack_list emptiness instead of bit flag")
    Reported-by: syzbot+58813d77154713f4de15@syzkaller.appspotmail.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index bb7e90ab90f8..df52d2960179 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -372,7 +372,7 @@ static int snd_timer_close_locked(struct snd_timer_instance *timeri)
 		timer->num_instances--;
 		/* wait, until the active callback is finished */
 		spin_lock_irq(&timer->lock);
-		while (!list_empty(&timeri->ack_list)) {
+		while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
 			spin_unlock_irq(&timer->lock);
 			udelay(10);
 			spin_lock_irq(&timer->lock);
@@ -748,19 +748,20 @@ static void snd_timer_process_callbacks(struct snd_timer *timer,
 		ti = list_first_entry(head, struct snd_timer_instance,
 				      ack_list);
 
+		/* remove from ack_list and make empty */
+		list_del_init(&ti->ack_list);
+
 		if (!(ti->flags & SNDRV_TIMER_IFLG_DEAD)) {
 			ticks = ti->pticks;
 			ti->pticks = 0;
 			resolution = ti->resolution;
-
+			ti->flags |= SNDRV_TIMER_IFLG_CALLBACK;
 			spin_unlock(&timer->lock);
 			if (ti->callback)
 				ti->callback(ti, resolution, ticks);
 			spin_lock(&timer->lock);
+			ti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;
 		}
-
-		/* remove from ack_list and make empty */
-		list_del_init(&ti->ack_list);
 	}
 }
 

commit fe1b26c93d430400ac37d820425e2468218ae8b2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 27 17:02:40 2019 +0100

    ALSA: timer: Make snd_timer_close() really kill pending actions
    
    snd_timer_close() is supposed to close the timer instance and sync
    with the deactivation of pending actions.  However, there are still
    some overlooked cases:
    
    - It calls snd_timer_stop() at the beginning, but some other might
      re-trigger the timer right after that.
    
    - snd_timer_stop() calls del_timer_sync() only when all belonging
      instances are closed.  If multiple instances were assigned to a
      timer object and one is closed, the timer is still running.  Then
      the pending action assigned to this timer might be left.
    
    Actually either of the above is the likely cause of the reported
    syzkaller UAF.
    
    This patch plug these holes by introducing SNDRV_TIMER_IFLG_DEAD
    flag.  This is set at the beginning of snd_timer_close(), and the flag
    is checked at snd_timer_start*() and else, so that no longer new
    action is left after snd_timer_close().
    
    Reported-by: syzbot+d5136d4d3240cbe45a2a@syzkaller.appspotmail.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index e343de0e4f9e..bb7e90ab90f8 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -38,6 +38,7 @@
 
 /* internal flags */
 #define SNDRV_TIMER_IFLG_PAUSED		0x00010000
+#define SNDRV_TIMER_IFLG_DEAD		0x00020000
 
 #if IS_ENABLED(CONFIG_SND_HRTIMER)
 #define DEFAULT_TIMER_LIMIT 4
@@ -353,15 +354,20 @@ EXPORT_SYMBOL(snd_timer_open);
  */
 static int snd_timer_close_locked(struct snd_timer_instance *timeri)
 {
-	struct snd_timer *timer = NULL;
+	struct snd_timer *timer = timeri->timer;
 	struct snd_timer_instance *slave, *tmp;
 
+	if (timer) {
+		spin_lock_irq(&timer->lock);
+		timeri->flags |= SNDRV_TIMER_IFLG_DEAD;
+		spin_unlock_irq(&timer->lock);
+	}
+
 	list_del(&timeri->open_list);
 
 	/* force to stop the timer */
 	snd_timer_stop(timeri);
 
-	timer = timeri->timer;
 	if (timer) {
 		timer->num_instances--;
 		/* wait, until the active callback is finished */
@@ -497,6 +503,10 @@ static int snd_timer_start1(struct snd_timer_instance *timeri,
 		return -EINVAL;
 
 	spin_lock_irqsave(&timer->lock, flags);
+	if (timeri->flags & SNDRV_TIMER_IFLG_DEAD) {
+		result = -EINVAL;
+		goto unlock;
+	}
 	if (timer->card && timer->card->shutdown) {
 		result = -ENODEV;
 		goto unlock;
@@ -541,11 +551,16 @@ static int snd_timer_start_slave(struct snd_timer_instance *timeri,
 				 bool start)
 {
 	unsigned long flags;
+	int err;
 
 	spin_lock_irqsave(&slave_active_lock, flags);
+	if (timeri->flags & SNDRV_TIMER_IFLG_DEAD) {
+		err = -EINVAL;
+		goto unlock;
+	}
 	if (timeri->flags & SNDRV_TIMER_IFLG_RUNNING) {
-		spin_unlock_irqrestore(&slave_active_lock, flags);
-		return -EBUSY;
+		err = -EBUSY;
+		goto unlock;
 	}
 	timeri->flags |= SNDRV_TIMER_IFLG_RUNNING;
 	if (timeri->master && timeri->timer) {
@@ -556,8 +571,10 @@ static int snd_timer_start_slave(struct snd_timer_instance *timeri,
 				  SNDRV_TIMER_EVENT_CONTINUE);
 		spin_unlock(&timeri->timer->lock);
 	}
+	err = 1; /* delayed start */
+ unlock:
 	spin_unlock_irqrestore(&slave_active_lock, flags);
-	return 1; /* delayed start */
+	return err;
 }
 
 /* stop/pause a master timer */
@@ -731,14 +748,16 @@ static void snd_timer_process_callbacks(struct snd_timer *timer,
 		ti = list_first_entry(head, struct snd_timer_instance,
 				      ack_list);
 
-		ticks = ti->pticks;
-		ti->pticks = 0;
-		resolution = ti->resolution;
+		if (!(ti->flags & SNDRV_TIMER_IFLG_DEAD)) {
+			ticks = ti->pticks;
+			ti->pticks = 0;
+			resolution = ti->resolution;
 
-		spin_unlock(&timer->lock);
-		if (ti->callback)
-			ti->callback(ti, resolution, ticks);
-		spin_lock(&timer->lock);
+			spin_unlock(&timer->lock);
+			if (ti->callback)
+				ti->callback(ti, resolution, ticks);
+			spin_lock(&timer->lock);
+		}
 
 		/* remove from ack_list and make empty */
 		list_del_init(&ti->ack_list);
@@ -810,6 +829,8 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 	 */
 	list_for_each_entry_safe(ti, tmp, &timer->active_list_head,
 				 active_list) {
+		if (ti->flags & SNDRV_TIMER_IFLG_DEAD)
+			continue;
 		if (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING))
 			continue;
 		ti->pticks += ticks_left;

commit a7588c896b05444929ecb3d0115481988720abf6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 27 16:56:08 2019 +0100

    ALSA: timer: Check ack_list emptiness instead of bit flag
    
    For checking the pending timer instance that is still left on the
    timer object that is being closed, we set/clear a bit flag
    SNDRV_TIMER_IFLG_CALLBACK around the call of callbacks.  This can be
    simplified by replace with the list_empty() call for ti->ack_list.
    This covers the existence more comprehensively and safely.
    
    A gratis bonus is that we can get rid of SNDRV_TIMER_IFLG_CALLBACK bit
    flag definition as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 107d8ebeeb2e..e343de0e4f9e 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -366,7 +366,7 @@ static int snd_timer_close_locked(struct snd_timer_instance *timeri)
 		timer->num_instances--;
 		/* wait, until the active callback is finished */
 		spin_lock_irq(&timer->lock);
-		while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
+		while (!list_empty(&timeri->ack_list)) {
 			spin_unlock_irq(&timer->lock);
 			udelay(10);
 			spin_lock_irq(&timer->lock);
@@ -731,19 +731,17 @@ static void snd_timer_process_callbacks(struct snd_timer *timer,
 		ti = list_first_entry(head, struct snd_timer_instance,
 				      ack_list);
 
-		/* remove from ack_list and make empty */
-		list_del_init(&ti->ack_list);
-
 		ticks = ti->pticks;
 		ti->pticks = 0;
 		resolution = ti->resolution;
 
-		ti->flags |= SNDRV_TIMER_IFLG_CALLBACK;
 		spin_unlock(&timer->lock);
 		if (ti->callback)
 			ti->callback(ti, resolution, ticks);
 		spin_lock(&timer->lock);
-		ti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;
+
+		/* remove from ack_list and make empty */
+		list_del_init(&ti->ack_list);
 	}
 }
 

commit 7bb4a8a2cc9382da720b46988bc976ebccaa49fd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 27 16:51:58 2019 +0100

    ALSA: timer: Make sure to clear pending ack list
    
    When a card is under disconnection, we bail out immediately at each
    timer interrupt or tasklet.  This might leave some items left in ack
    list.  For a better integration of the upcoming change to check
    ack_list emptiness, clear out the whole list upon the emergency exit
    route.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index fdcddfb756b4..107d8ebeeb2e 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -747,6 +747,18 @@ static void snd_timer_process_callbacks(struct snd_timer *timer,
 	}
 }
 
+/* clear pending instances from ack list */
+static void snd_timer_clear_callbacks(struct snd_timer *timer,
+				      struct list_head *head)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&timer->lock, flags);
+	while (!list_empty(head))
+		list_del_init(head->next);
+	spin_unlock_irqrestore(&timer->lock, flags);
+}
+
 /*
  * timer tasklet
  *
@@ -756,8 +768,10 @@ static void snd_timer_tasklet(unsigned long arg)
 	struct snd_timer *timer = (struct snd_timer *) arg;
 	unsigned long flags;
 
-	if (timer->card && timer->card->shutdown)
+	if (timer->card && timer->card->shutdown) {
+		snd_timer_clear_callbacks(timer, &timer->sack_list_head);
 		return;
+	}
 
 	spin_lock_irqsave(&timer->lock, flags);
 	snd_timer_process_callbacks(timer, &timer->sack_list_head);
@@ -781,8 +795,10 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 	if (timer == NULL)
 		return;
 
-	if (timer->card && timer->card->shutdown)
+	if (timer->card && timer->card->shutdown) {
+		snd_timer_clear_callbacks(timer, &timer->ack_list_head);
 		return;
+	}
 
 	spin_lock_irqsave(&timer->lock, flags);
 

commit 8748b850beccdbc87aa8776d63abd6b5628720c8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 27 16:42:51 2019 +0100

    ALSA: timer: Unify timer callback process code
    
    The timer core has two almost identical code for processing callbacks:
    once in snd_timer_interrupt() for fast callbacks and another in
    snd_timer_tasklet() for delayed callbacks.  Let's unify them.
    
    In the new version, the resolution is read from ti->resolution at each
    call, and this must be fine; ti->resolution is set in the preparation
    step in snd_timer_interrupt().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 61a0cec6e1f6..fdcddfb756b4 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -720,29 +720,19 @@ static void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_l
 	timer->sticks = ticks;
 }
 
-/*
- * timer tasklet
- *
- */
-static void snd_timer_tasklet(unsigned long arg)
+/* call callbacks in timer ack list */
+static void snd_timer_process_callbacks(struct snd_timer *timer,
+					struct list_head *head)
 {
-	struct snd_timer *timer = (struct snd_timer *) arg;
 	struct snd_timer_instance *ti;
-	struct list_head *p;
 	unsigned long resolution, ticks;
-	unsigned long flags;
 
-	if (timer->card && timer->card->shutdown)
-		return;
-
-	spin_lock_irqsave(&timer->lock, flags);
-	/* now process all callbacks */
-	while (!list_empty(&timer->sack_list_head)) {
-		p = timer->sack_list_head.next;		/* get first item */
-		ti = list_entry(p, struct snd_timer_instance, ack_list);
+	while (!list_empty(head)) {
+		ti = list_first_entry(head, struct snd_timer_instance,
+				      ack_list);
 
 		/* remove from ack_list and make empty */
-		list_del_init(p);
+		list_del_init(&ti->ack_list);
 
 		ticks = ti->pticks;
 		ti->pticks = 0;
@@ -755,6 +745,22 @@ static void snd_timer_tasklet(unsigned long arg)
 		spin_lock(&timer->lock);
 		ti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;
 	}
+}
+
+/*
+ * timer tasklet
+ *
+ */
+static void snd_timer_tasklet(unsigned long arg)
+{
+	struct snd_timer *timer = (struct snd_timer *) arg;
+	unsigned long flags;
+
+	if (timer->card && timer->card->shutdown)
+		return;
+
+	spin_lock_irqsave(&timer->lock, flags);
+	snd_timer_process_callbacks(timer, &timer->sack_list_head);
 	spin_unlock_irqrestore(&timer->lock, flags);
 }
 
@@ -767,8 +773,8 @@ static void snd_timer_tasklet(unsigned long arg)
 void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 {
 	struct snd_timer_instance *ti, *ts, *tmp;
-	unsigned long resolution, ticks;
-	struct list_head *p, *ack_list_head;
+	unsigned long resolution;
+	struct list_head *ack_list_head;
 	unsigned long flags;
 	int use_tasklet = 0;
 
@@ -839,23 +845,7 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 	}
 
 	/* now process all fast callbacks */
-	while (!list_empty(&timer->ack_list_head)) {
-		p = timer->ack_list_head.next;		/* get first item */
-		ti = list_entry(p, struct snd_timer_instance, ack_list);
-
-		/* remove from ack_list and make empty */
-		list_del_init(p);
-
-		ticks = ti->pticks;
-		ti->pticks = 0;
-
-		ti->flags |= SNDRV_TIMER_IFLG_CALLBACK;
-		spin_unlock(&timer->lock);
-		if (ti->callback)
-			ti->callback(ti, resolution, ticks);
-		spin_lock(&timer->lock);
-		ti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;
-	}
+	snd_timer_process_callbacks(timer, &timer->ack_list_head);
 
 	/* do we have any slow callbacks? */
 	use_tasklet = !list_empty(&timer->sack_list_head);

commit d10ee9c542365bdc0a7497306e21ff6c7f2172b0
Author: Srikanth K H <srikanth.h@samsung.com>
Date:   Fri Jul 20 11:13:51 2018 +0530

    ALSA: timer: catch invalid timer object creation
    
    A timer object for the classes SNDRV_TIMER_CLASS_CARD and
    SNDRV_TIMER_CLASS_PCM has to be associated with a card object, but we
    have no check at creation time.  Such a timer object with NULL card
    causes various unexpected problems, e.g. NULL dereference at reading
    the sound timer proc file.
    
    So as preventive measure while the creating the sound timer object is
    created the card information availability is checked for the mentioned
    entries and returned error if its NULL.
    
    Signed-off-by: Srikanth K H <srikanth.h@samsung.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index b6f076bbc72d..61a0cec6e1f6 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -883,6 +883,11 @@ int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,
 
 	if (snd_BUG_ON(!tid))
 		return -EINVAL;
+	if (tid->dev_class == SNDRV_TIMER_CLASS_CARD ||
+	    tid->dev_class == SNDRV_TIMER_CLASS_PCM) {
+		if (WARN_ON(!card))
+			return -EINVAL;
+	}
 	if (rtimer)
 		*rtimer = NULL;
 	timer = kzalloc(sizeof(*timer), GFP_KERNEL);

commit b41f794f284966fd6ec634111e3b40d241389f96
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jun 25 11:09:11 2018 +0200

    ALSA: timer: Fix UBSAN warning at SNDRV_TIMER_IOCTL_NEXT_DEVICE ioctl
    
    The kernel may spew a WARNING about UBSAN undefined behavior at
    handling ALSA timer ioctl SNDRV_TIMER_IOCTL_NEXT_DEVICE:
    
    UBSAN: Undefined behaviour in sound/core/timer.c:1524:19
    signed integer overflow:
    2147483647 + 1 cannot be represented in type 'int'
    Call Trace:
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x122/0x1c8 lib/dump_stack.c:113
     ubsan_epilogue+0x12/0x86 lib/ubsan.c:159
     handle_overflow+0x1c2/0x21f lib/ubsan.c:190
     __ubsan_handle_add_overflow+0x2a/0x31 lib/ubsan.c:198
     snd_timer_user_next_device sound/core/timer.c:1524 [inline]
     __snd_timer_user_ioctl+0x204d/0x2520 sound/core/timer.c:1939
     snd_timer_user_ioctl+0x67/0x95 sound/core/timer.c:1994
     ....
    
    It happens only when a value with INT_MAX is passed, as we're
    incrementing it unconditionally.  So the fix is trivial, check the
    value with INT_MAX.  Although the bug itself is fairly harmless, it's
    better to fix it so that fuzzers won't hit this again later.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=200213
    Reported-and-tested-by: Team OWL337 <icytxw@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 665089c45560..b6f076bbc72d 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1520,7 +1520,7 @@ static int snd_timer_user_next_device(struct snd_timer_id __user *_tid)
 				} else {
 					if (id.subdevice < 0)
 						id.subdevice = 0;
-					else
+					else if (id.subdevice < INT_MAX)
 						id.subdevice++;
 				}
 			}

commit 9d4d207d1346329c5295420254f1dbef1a6ab6ba
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 16 23:52:42 2018 +0200

    ALSA: timer: Assure timer resolution access always locked
    
    There are still many places calling the timer's hw.c_resolution
    callback without lock, and this may lead to some races, as we faced in
    the commit a820ccbe21e8 ("ALSA: pcm: Fix UAF at PCM release via PCM
    timer access").
    
    This patch changes snd_timer_resolution() to take the timer->lock for
    avoiding the races.  A place calling this function already inside the
    lock (from the notifier) is replaced with the
    snd_timer_hw_resolution() accordingly, as well as wrapping with the
    lock around another place calling snd_timer_hw_resolution(), too.
    
    Reported-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 22c72857f379..665089c45560 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -438,19 +438,24 @@ static unsigned long snd_timer_hw_resolution(struct snd_timer *timer)
 unsigned long snd_timer_resolution(struct snd_timer_instance *timeri)
 {
 	struct snd_timer * timer;
+	unsigned long ret = 0;
+	unsigned long flags;
 
 	if (timeri == NULL)
 		return 0;
 	timer = timeri->timer;
-	if (timer)
-		return snd_timer_hw_resolution(timer);
-	return 0;
+	if (timer) {
+		spin_lock_irqsave(&timer->lock, flags);
+		ret = snd_timer_hw_resolution(timer);
+		spin_unlock_irqrestore(&timer->lock, flags);
+	}
+	return ret;
 }
 EXPORT_SYMBOL(snd_timer_resolution);
 
 static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 {
-	struct snd_timer *timer;
+	struct snd_timer *timer = ti->timer;
 	unsigned long resolution = 0;
 	struct snd_timer_instance *ts;
 	struct timespec tstamp;
@@ -462,14 +467,14 @@ static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 	if (snd_BUG_ON(event < SNDRV_TIMER_EVENT_START ||
 		       event > SNDRV_TIMER_EVENT_PAUSE))
 		return;
-	if (event == SNDRV_TIMER_EVENT_START ||
-	    event == SNDRV_TIMER_EVENT_CONTINUE)
-		resolution = snd_timer_resolution(ti);
+	if (timer &&
+	    (event == SNDRV_TIMER_EVENT_START ||
+	     event == SNDRV_TIMER_EVENT_CONTINUE))
+		resolution = snd_timer_hw_resolution(timer);
 	if (ti->ccallback)
 		ti->ccallback(ti, event, &tstamp, resolution);
 	if (ti->flags & SNDRV_TIMER_IFLG_SLAVE)
 		return;
-	timer = ti->timer;
 	if (timer == NULL)
 		return;
 	if (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)
@@ -1654,6 +1659,7 @@ static int snd_timer_user_gstatus(struct file *file,
 	mutex_lock(&register_mutex);
 	t = snd_timer_find(&tid);
 	if (t != NULL) {
+		spin_lock_irq(&t->lock);
 		gstatus.resolution = snd_timer_hw_resolution(t);
 		if (t->hw.precise_resolution) {
 			t->hw.precise_resolution(t, &gstatus.resolution_num,
@@ -1662,6 +1668,7 @@ static int snd_timer_user_gstatus(struct file *file,
 			gstatus.resolution_num = gstatus.resolution;
 			gstatus.resolution_den = 1000000000uL;
 		}
+		spin_unlock_irq(&t->lock);
 	} else {
 		err = -ENODEV;
 	}

commit fdcb5761c1580b03fb1ab8625eaa7db03fb8b7d0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 16 23:45:33 2018 +0200

    ALSA: timer: Simplify timer hw resolution calls
    
    There multiple open-codes to get the hardware timer resolution.
    Make a local helper function snd_timer_hw_resolution() and call it
    from all relevant places.
    
    There is no functional change by this, just a preliminary work for the
    following timer resolution hardening patch.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 0ddcae495838..22c72857f379 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -427,6 +427,14 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 }
 EXPORT_SYMBOL(snd_timer_close);
 
+static unsigned long snd_timer_hw_resolution(struct snd_timer *timer)
+{
+	if (timer->hw.c_resolution)
+		return timer->hw.c_resolution(timer);
+	else
+		return timer->hw.resolution;
+}
+
 unsigned long snd_timer_resolution(struct snd_timer_instance *timeri)
 {
 	struct snd_timer * timer;
@@ -434,11 +442,8 @@ unsigned long snd_timer_resolution(struct snd_timer_instance *timeri)
 	if (timeri == NULL)
 		return 0;
 	timer = timeri->timer;
-	if (timer) {
-		if (timer->hw.c_resolution)
-			return timer->hw.c_resolution(timer);
-		return timer->hw.resolution;
-	}
+	if (timer)
+		return snd_timer_hw_resolution(timer);
 	return 0;
 }
 EXPORT_SYMBOL(snd_timer_resolution);
@@ -771,10 +776,7 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 	spin_lock_irqsave(&timer->lock, flags);
 
 	/* remember the current resolution */
-	if (timer->hw.c_resolution)
-		resolution = timer->hw.c_resolution(timer);
-	else
-		resolution = timer->hw.resolution;
+	resolution = snd_timer_hw_resolution(timer);
 
 	/* loop for all active instances
 	 * Here we cannot use list_for_each_entry because the active_list of a
@@ -1014,12 +1016,8 @@ void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstam
 	spin_lock_irqsave(&timer->lock, flags);
 	if (event == SNDRV_TIMER_EVENT_MSTART ||
 	    event == SNDRV_TIMER_EVENT_MCONTINUE ||
-	    event == SNDRV_TIMER_EVENT_MRESUME) {
-		if (timer->hw.c_resolution)
-			resolution = timer->hw.c_resolution(timer);
-		else
-			resolution = timer->hw.resolution;
-	}
+	    event == SNDRV_TIMER_EVENT_MRESUME)
+		resolution = snd_timer_hw_resolution(timer);
 	list_for_each_entry(ti, &timer->active_list_head, active_list) {
 		if (ti->ccallback)
 			ti->ccallback(ti, event, tstamp, resolution);
@@ -1656,10 +1654,7 @@ static int snd_timer_user_gstatus(struct file *file,
 	mutex_lock(&register_mutex);
 	t = snd_timer_find(&tid);
 	if (t != NULL) {
-		if (t->hw.c_resolution)
-			gstatus.resolution = t->hw.c_resolution(t);
-		else
-			gstatus.resolution = t->hw.resolution;
+		gstatus.resolution = snd_timer_hw_resolution(t);
 		if (t->hw.precise_resolution) {
 			t->hw.precise_resolution(t, &gstatus.resolution_num,
 						 &gstatus.resolution_den);

commit 3ae180972564846e6d794e3615e1ab0a1e6c4ef9
Author: Ben Hutchings <ben.hutchings@codethink.co.uk>
Date:   Thu May 17 22:34:39 2018 +0100

    ALSA: timer: Fix pause event notification
    
    Commit f65e0d299807 ("ALSA: timer: Call notifier in the same spinlock")
    combined the start/continue and stop/pause functions, and in doing so
    changed the event code for the pause case to SNDRV_TIMER_EVENT_CONTINUE.
    Change it back to SNDRV_TIMER_EVENT_PAUSE.
    
    Fixes: f65e0d299807 ("ALSA: timer: Call notifier in the same spinlock")
    Signed-off-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Cc: stable@vger.kernel.org
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index dc87728c5b74..0ddcae495838 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -592,7 +592,7 @@ static int snd_timer_stop1(struct snd_timer_instance *timeri, bool stop)
 	else
 		timeri->flags |= SNDRV_TIMER_IFLG_PAUSED;
 	snd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :
-			  SNDRV_TIMER_EVENT_CONTINUE);
+			  SNDRV_TIMER_EVENT_PAUSE);
  unlock:
 	spin_unlock_irqrestore(&timer->lock, flags);
 	return result;
@@ -614,7 +614,7 @@ static int snd_timer_stop_slave(struct snd_timer_instance *timeri, bool stop)
 		list_del_init(&timeri->ack_list);
 		list_del_init(&timeri->active_list);
 		snd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :
-				  SNDRV_TIMER_EVENT_CONTINUE);
+				  SNDRV_TIMER_EVENT_PAUSE);
 		spin_unlock(&timeri->timer->lock);
 	}
 	spin_unlock_irqrestore(&slave_active_lock, flags);

commit a9a08845e9acbd224e4ee466f5c1275ed50054e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 11 14:34:03 2018 -0800

    vfs: do bulk POLL* -> EPOLL* replacement
    
    This is the mindless scripted replacement of kernel use of POLL*
    variables as described by Al, done by this script:
    
        for V in IN OUT PRI ERR RDNORM RDBAND WRNORM WRBAND HUP RDHUP NVAL MSG; do
            L=`git grep -l -w POLL$V | grep -v '^t' | grep -v /um/ | grep -v '^sa' | grep -v '/poll.h$'|grep -v '^D'`
            for f in $L; do sed -i "-es/^\([^\"]*\)\(\<POLL$V\>\)/\\1E\\2/" $f; done
        done
    
    with de-mangling cleanups yet to come.
    
    NOTE! On almost all architectures, the EPOLL* constants have the same
    values as the POLL* constants do.  But they keyword here is "almost".
    For various bad reasons they aren't the same, and epoll() doesn't
    actually work quite correctly in some cases due to this on Sparc et al.
    
    The next patch from Al will sort out the final differences, and we
    should be all done.
    
    Scripted-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index da05e314917f..dc87728c5b74 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -2084,9 +2084,9 @@ static __poll_t snd_timer_user_poll(struct file *file, poll_table * wait)
 	mask = 0;
 	spin_lock_irq(&tu->qlock);
 	if (tu->qused)
-		mask |= POLLIN | POLLRDNORM;
+		mask |= EPOLLIN | EPOLLRDNORM;
 	if (tu->disconnected)
-		mask |= POLLERR;
+		mask |= EPOLLERR;
 	spin_unlock_irq(&tu->qlock);
 
 	return mask;

commit 680ef72abd84cbe0b722453d6be4e412305c9060
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 2 23:27:36 2017 -0400

    sound: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index ee09dace8bb1..da05e314917f 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -2072,9 +2072,9 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 	return result > 0 ? result : err;
 }
 
-static unsigned int snd_timer_user_poll(struct file *file, poll_table * wait)
+static __poll_t snd_timer_user_poll(struct file *file, poll_table * wait)
 {
-        unsigned int mask;
+        __poll_t mask;
         struct snd_timer_user *tu;
 
         tu = file->private_data;

commit c429bda21ffafb28f02fb2eb4055b4ab6879ed58
Merge: 75ee94b20b46 9718a29d40b7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 13 15:43:04 2017 +0100

    Merge branch 'for-next' into for-linus
    
    Pull 4.15 updates to take over the previous urgent fixes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 9b7d869ee5a77ed4a462372bb89af622e705bfb8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Nov 5 10:07:43 2017 +0100

    ALSA: timer: Limit max instances per timer
    
    Currently we allow unlimited number of timer instances, and it may
    bring the system hogging way too much CPU when too many timer
    instances are opened and processed concurrently.  This may end up with
    a soft-lockup report as triggered by syzkaller, especially when
    hrtimer backend is deployed.
    
    Since such insane number of instances aren't demanded by the normal
    use case of ALSA sequencer and it merely  opens a risk only for abuse,
    this patch introduces the upper limit for the number of instances per
    timer backend.  As default, it's set to 1000, but for the fine-grained
    timer like hrtimer, it's set to 100.
    
    Reported-by: syzbot
    Tested-by: Jérôme Glisse <jglisse@redhat.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 6cdd04a45962..15e82a656d96 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -180,7 +180,7 @@ static void snd_timer_request(struct snd_timer_id *tid)
  *
  * call this with register_mutex down.
  */
-static void snd_timer_check_slave(struct snd_timer_instance *slave)
+static int snd_timer_check_slave(struct snd_timer_instance *slave)
 {
 	struct snd_timer *timer;
 	struct snd_timer_instance *master;
@@ -190,16 +190,21 @@ static void snd_timer_check_slave(struct snd_timer_instance *slave)
 		list_for_each_entry(master, &timer->open_list_head, open_list) {
 			if (slave->slave_class == master->slave_class &&
 			    slave->slave_id == master->slave_id) {
+				if (master->timer->num_instances >=
+				    master->timer->max_instances)
+					return -EBUSY;
 				list_move_tail(&slave->open_list,
 					       &master->slave_list_head);
+				master->timer->num_instances++;
 				spin_lock_irq(&slave_active_lock);
 				slave->master = master;
 				slave->timer = master->timer;
 				spin_unlock_irq(&slave_active_lock);
-				return;
+				return 0;
 			}
 		}
 	}
+	return 0;
 }
 
 /*
@@ -208,7 +213,7 @@ static void snd_timer_check_slave(struct snd_timer_instance *slave)
  *
  * call this with register_mutex down.
  */
-static void snd_timer_check_master(struct snd_timer_instance *master)
+static int snd_timer_check_master(struct snd_timer_instance *master)
 {
 	struct snd_timer_instance *slave, *tmp;
 
@@ -216,7 +221,11 @@ static void snd_timer_check_master(struct snd_timer_instance *master)
 	list_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {
 		if (slave->slave_class == master->slave_class &&
 		    slave->slave_id == master->slave_id) {
+			if (master->timer->num_instances >=
+			    master->timer->max_instances)
+				return -EBUSY;
 			list_move_tail(&slave->open_list, &master->slave_list_head);
+			master->timer->num_instances++;
 			spin_lock_irq(&slave_active_lock);
 			spin_lock(&master->timer->lock);
 			slave->master = master;
@@ -228,8 +237,11 @@ static void snd_timer_check_master(struct snd_timer_instance *master)
 			spin_unlock_irq(&slave_active_lock);
 		}
 	}
+	return 0;
 }
 
+static int snd_timer_close_locked(struct snd_timer_instance *timeri);
+
 /*
  * open a timer instance
  * when opening a master, the slave id must be here given.
@@ -240,6 +252,7 @@ int snd_timer_open(struct snd_timer_instance **ti,
 {
 	struct snd_timer *timer;
 	struct snd_timer_instance *timeri = NULL;
+	int err;
 
 	if (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {
 		/* open a slave instance */
@@ -259,10 +272,14 @@ int snd_timer_open(struct snd_timer_instance **ti,
 		timeri->slave_id = tid->device;
 		timeri->flags |= SNDRV_TIMER_IFLG_SLAVE;
 		list_add_tail(&timeri->open_list, &snd_timer_slave_list);
-		snd_timer_check_slave(timeri);
+		err = snd_timer_check_slave(timeri);
+		if (err < 0) {
+			snd_timer_close_locked(timeri);
+			timeri = NULL;
+		}
 		mutex_unlock(&register_mutex);
 		*ti = timeri;
-		return 0;
+		return err;
 	}
 
 	/* open a master instance */
@@ -288,6 +305,10 @@ int snd_timer_open(struct snd_timer_instance **ti,
 			return -EBUSY;
 		}
 	}
+	if (timer->num_instances >= timer->max_instances) {
+		mutex_unlock(&register_mutex);
+		return -EBUSY;
+	}
 	timeri = snd_timer_instance_new(owner, timer);
 	if (!timeri) {
 		mutex_unlock(&register_mutex);
@@ -314,25 +335,27 @@ int snd_timer_open(struct snd_timer_instance **ti,
 	}
 
 	list_add_tail(&timeri->open_list, &timer->open_list_head);
-	snd_timer_check_master(timeri);
+	timer->num_instances++;
+	err = snd_timer_check_master(timeri);
+	if (err < 0) {
+		snd_timer_close_locked(timeri);
+		timeri = NULL;
+	}
 	mutex_unlock(&register_mutex);
 	*ti = timeri;
-	return 0;
+	return err;
 }
 EXPORT_SYMBOL(snd_timer_open);
 
 /*
  * close a timer instance
+ * call this with register_mutex down.
  */
-int snd_timer_close(struct snd_timer_instance *timeri)
+static int snd_timer_close_locked(struct snd_timer_instance *timeri)
 {
 	struct snd_timer *timer = NULL;
 	struct snd_timer_instance *slave, *tmp;
 
-	if (snd_BUG_ON(!timeri))
-		return -ENXIO;
-
-	mutex_lock(&register_mutex);
 	list_del(&timeri->open_list);
 
 	/* force to stop the timer */
@@ -340,6 +363,7 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 
 	timer = timeri->timer;
 	if (timer) {
+		timer->num_instances--;
 		/* wait, until the active callback is finished */
 		spin_lock_irq(&timer->lock);
 		while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
@@ -355,6 +379,7 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 		list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,
 					 open_list) {
 			list_move_tail(&slave->open_list, &snd_timer_slave_list);
+			timer->num_instances--;
 			slave->master = NULL;
 			slave->timer = NULL;
 			list_del_init(&slave->ack_list);
@@ -382,9 +407,24 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 		module_put(timer->module);
 	}
 
-	mutex_unlock(&register_mutex);
 	return 0;
 }
+
+/*
+ * close a timer instance
+ */
+int snd_timer_close(struct snd_timer_instance *timeri)
+{
+	int err;
+
+	if (snd_BUG_ON(!timeri))
+		return -ENXIO;
+
+	mutex_lock(&register_mutex);
+	err = snd_timer_close_locked(timeri);
+	mutex_unlock(&register_mutex);
+	return err;
+}
 EXPORT_SYMBOL(snd_timer_close);
 
 unsigned long snd_timer_resolution(struct snd_timer_instance *timeri)
@@ -856,6 +896,7 @@ int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,
 	spin_lock_init(&timer->lock);
 	tasklet_init(&timer->task_queue, snd_timer_tasklet,
 		     (unsigned long)timer);
+	timer->max_instances = 1000; /* default limit per timer */
 	if (card != NULL) {
 		timer->module = card->module;
 		err = snd_device_new(card, SNDRV_DEV_TIMER, timer, &ops);

commit 38e9a80f66beb108d30f47dc856dd17b983c3dd6
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 4 17:53:33 2017 -0700

    ALSA: timer: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly. This adds a pointer back to struct
    snd_timer.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 6cdd04a45962..09acaf2b2e57 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1028,15 +1028,17 @@ EXPORT_SYMBOL(snd_timer_global_register);
 
 struct snd_timer_system_private {
 	struct timer_list tlist;
+	struct snd_timer *snd_timer;
 	unsigned long last_expires;
 	unsigned long last_jiffies;
 	unsigned long correction;
 };
 
-static void snd_timer_s_function(unsigned long data)
+static void snd_timer_s_function(struct timer_list *t)
 {
-	struct snd_timer *timer = (struct snd_timer *)data;
-	struct snd_timer_system_private *priv = timer->private_data;
+	struct snd_timer_system_private *priv = from_timer(priv, t,
+								tlist);
+	struct snd_timer *timer = priv->snd_timer;
 	unsigned long jiff = jiffies;
 	if (time_after(jiff, priv->last_expires))
 		priv->correction += (long)jiff - (long)priv->last_expires;
@@ -1118,7 +1120,8 @@ static int snd_timer_register_system(void)
 		snd_timer_free(timer);
 		return -ENOMEM;
 	}
-	setup_timer(&priv->tlist, snd_timer_s_function, (unsigned long) timer);
+	priv->snd_timer = timer;
+	timer_setup(&priv->tlist, snd_timer_s_function, 0);
 	timer->private_data = priv;
 	timer->private_free = snd_timer_free_system;
 	return snd_timer_global_register(timer);

commit 1ae0e4ce554fb57dc4d5e1eb8e6d302e3f18b0b4
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Wed Aug 23 09:30:41 2017 +0200

    ALSA: timer: Use common error handling code in alsa_timer_init()
    
    Add a jump target so that a bit of exception handling can be better reused
    at the end of this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 6051aed3197f..6cdd04a45962 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -2097,8 +2097,7 @@ static int __init alsa_timer_init(void)
 	err = snd_timer_register_system();
 	if (err < 0) {
 		pr_err("ALSA: unable to register system timer (%i)\n", err);
-		put_device(&timer_dev);
-		return err;
+		goto put_timer;
 	}
 
 	err = snd_register_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,
@@ -2106,12 +2105,15 @@ static int __init alsa_timer_init(void)
 	if (err < 0) {
 		pr_err("ALSA: unable to register timer device (%i)\n", err);
 		snd_timer_free_all();
-		put_device(&timer_dev);
-		return err;
+		goto put_timer;
 	}
 
 	snd_timer_proc_init();
 	return 0;
+
+put_timer:
+	put_device(&timer_dev);
+	return err;
 }
 
 static void __exit alsa_timer_exit(void)

commit dd1f7ab8a88ddc8fbb304aaca25f549e26fa8529
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Wed Aug 23 09:45:06 2017 +0200

    ALSA: timer: Adjust a condition check in snd_timer_resolution()
    
    The script "checkpatch.pl" pointed information out like the following.
    
    ERROR: do not use assignment in if condition
    
    Thus fix the affected source code place.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index a9b9a277e00c..6051aed3197f 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -393,7 +393,8 @@ unsigned long snd_timer_resolution(struct snd_timer_instance *timeri)
 
 	if (timeri == NULL)
 		return 0;
-	if ((timer = timeri->timer) != NULL) {
+	timer = timeri->timer;
+	if (timer) {
 		if (timer->hw.c_resolution)
 			return timer->hw.c_resolution(timer);
 		return timer->hw.resolution;

commit 920f2ecdf6c3b3526f60fbd38c68597953cad3ee
Merge: 9ced560b8260 fc18282cdcba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 6 10:56:51 2017 -0700

    Merge tag 'sound-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "This development cycle resulted in a fair amount of changes in both
      core and driver sides. The most significant change in ALSA core is
      about PCM. Also the support of of-graph card and the new DAPM widget
      for DSP are noteworthy changes in ASoC core. And there're lots of
      small changes splat over the tree, as you can see in diffstat.
    
      Below are a few highlights:
    
      ALSA core:
       - Removal of set_fs() hackery from PCM core stuff, and the code
         reorganization / optimization thereafter
       - Improved support of PCM ack ops, and a new ABI for improved
         control/status mmap handling
       - Lots of constifications in various codes
    
      ASoC core:
       - The support of of-graph card, which may work as a better generic
         device for a replacement of simple-card
       - New widget types intended mainly for use with DSPs
    
      ASoC drivers:
       - New drivers for Allwinner V3s SoCs
       - Ensonic ES8316 codec support
       - More Intel SKL and KBL works
       - More device support for Intel SST Atom (mostly for cheap tablets
         and 2-in-1 devices)
       - Support for Rockchip PDM controllers
       - Support for STM32 I2S and S/PDIF controllers
       - Support for ZTE AUD96P22 codecs
    
      HD-audio:
       - Support of new Realtek codecs (ALC215/ALC285/ALC289), more quirks
         for HP and Dell machines
       - A few more fixes for i915 component binding"
    
    * tag 'sound-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (418 commits)
      ALSA: hda - Fix unbalance of i915 module refcount
      ASoC: Intel: Skylake: Remove driver debugfs exit
      ASoC: Intel: Skylake: explicitly add the headers sst-dsp.h
      ALSA: hda/realtek - Remove GPIO_MASK
      ALSA: hda/realtek - Fix typo of pincfg for Dell quirk
      ALSA: pcm: add a documentation for tracepoints
      ALSA: atmel: ac97c: fix error return code in atmel_ac97c_probe()
      ALSA: x86: fix error return code in hdmi_lpe_audio_probe()
      ASoC: Intel: Skylake: Add support to read firmware registers
      ASoC: Intel: Skylake: Add sram address to sst_addr structure
      ASoC: Intel: Skylake: Debugfs facility to dump module config
      ASoC: Intel: Skylake: Add debugfs support
      ASoC: fix semicolon.cocci warnings
      ASoC: rt5645: Add quirk override by module option
      ASoC: rsnd: make arrays path and cmd_case static const
      ASoC: audio-graph-card: add widgets and routing for external amplifier support
      ASoC: audio-graph-card: update bindings for amplifier support
      ASoC: rt5665: calibration should be done before jack detection
      ASoC: rsnd: constify dev_pm_ops structures.
      ASoC: nau8825: change crosstalk-bypass property to bool type
      ...

commit ac6424b981bce1c4bc55675c6ce11bfe1bbfa64f
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Jun 20 12:06:13 2017 +0200

    sched/wait: Rename wait_queue_t => wait_queue_entry_t
    
    Rename:
    
            wait_queue_t            =>      wait_queue_entry_t
    
    'wait_queue_t' was always a slight misnomer: its name implies that it's a "queue",
    but in reality it's a queue *entry*. The 'real' queue is the wait queue head,
    which had to carry the name.
    
    Start sorting this out by renaming it to 'wait_queue_entry_t'.
    
    This also allows the real structure name 'struct __wait_queue' to
    lose its double underscore and become 'struct wait_queue_entry',
    which is the more canonical nomenclature for such data types.
    
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index cd67d1c12cf1..884c3066b028 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1964,7 +1964,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 	spin_lock_irq(&tu->qlock);
 	while ((long)count - result >= unit) {
 		while (!tu->qused) {
-			wait_queue_t wait;
+			wait_queue_entry_t wait;
 
 			if ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {
 				err = -EAGAIN;

commit 988563929d5b65c021439880ac6bd1b207722f26
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 16 16:16:05 2017 +0200

    ALSA: timer: Follow standard EXPORT_SYMBOL() declarations
    
    Just a tidy up to follow the standard EXPORT_SYMBOL*() declarations
    in order to improve grep-ability.
    
    - Move EXPORT_SYMBOL*() to the position right after its definition
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 148290ace756..4888203b2dbc 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -319,6 +319,7 @@ int snd_timer_open(struct snd_timer_instance **ti,
 	*ti = timeri;
 	return 0;
 }
+EXPORT_SYMBOL(snd_timer_open);
 
 /*
  * close a timer instance
@@ -384,6 +385,7 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 	mutex_unlock(&register_mutex);
 	return 0;
 }
+EXPORT_SYMBOL(snd_timer_close);
 
 unsigned long snd_timer_resolution(struct snd_timer_instance *timeri)
 {
@@ -398,6 +400,7 @@ unsigned long snd_timer_resolution(struct snd_timer_instance *timeri)
 	}
 	return 0;
 }
+EXPORT_SYMBOL(snd_timer_resolution);
 
 static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 {
@@ -589,6 +592,7 @@ int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)
 	else
 		return snd_timer_start1(timeri, true, ticks);
 }
+EXPORT_SYMBOL(snd_timer_start);
 
 /*
  * stop the timer instance.
@@ -602,6 +606,7 @@ int snd_timer_stop(struct snd_timer_instance *timeri)
 	else
 		return snd_timer_stop1(timeri, true);
 }
+EXPORT_SYMBOL(snd_timer_stop);
 
 /*
  * start again..  the tick is kept.
@@ -617,6 +622,7 @@ int snd_timer_continue(struct snd_timer_instance *timeri)
 	else
 		return snd_timer_start1(timeri, false, 0);
 }
+EXPORT_SYMBOL(snd_timer_continue);
 
 /*
  * pause.. remember the ticks left
@@ -628,6 +634,7 @@ int snd_timer_pause(struct snd_timer_instance * timeri)
 	else
 		return snd_timer_stop1(timeri, false);
 }
+EXPORT_SYMBOL(snd_timer_pause);
 
 /*
  * reschedule the timer
@@ -809,6 +816,7 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 	if (use_tasklet)
 		tasklet_schedule(&timer->task_queue);
 }
+EXPORT_SYMBOL(snd_timer_interrupt);
 
 /*
 
@@ -859,6 +867,7 @@ int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,
 		*rtimer = timer;
 	return 0;
 }
+EXPORT_SYMBOL(snd_timer_new);
 
 static int snd_timer_free(struct snd_timer *timer)
 {
@@ -978,6 +987,7 @@ void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstam
 	}
 	spin_unlock_irqrestore(&timer->lock, flags);
 }
+EXPORT_SYMBOL(snd_timer_notify);
 
 /*
  * exported functions for global timers
@@ -993,11 +1003,13 @@ int snd_timer_global_new(char *id, int device, struct snd_timer **rtimer)
 	tid.subdevice = 0;
 	return snd_timer_new(NULL, id, &tid, rtimer);
 }
+EXPORT_SYMBOL(snd_timer_global_new);
 
 int snd_timer_global_free(struct snd_timer *timer)
 {
 	return snd_timer_free(timer);
 }
+EXPORT_SYMBOL(snd_timer_global_free);
 
 int snd_timer_global_register(struct snd_timer *timer)
 {
@@ -1007,6 +1019,7 @@ int snd_timer_global_register(struct snd_timer *timer)
 	dev.device_data = timer;
 	return snd_timer_dev_register(&dev);
 }
+EXPORT_SYMBOL(snd_timer_global_register);
 
 /*
  *  System timer
@@ -2113,17 +2126,3 @@ static void __exit alsa_timer_exit(void)
 
 module_init(alsa_timer_init)
 module_exit(alsa_timer_exit)
-
-EXPORT_SYMBOL(snd_timer_open);
-EXPORT_SYMBOL(snd_timer_close);
-EXPORT_SYMBOL(snd_timer_resolution);
-EXPORT_SYMBOL(snd_timer_start);
-EXPORT_SYMBOL(snd_timer_stop);
-EXPORT_SYMBOL(snd_timer_continue);
-EXPORT_SYMBOL(snd_timer_pause);
-EXPORT_SYMBOL(snd_timer_new);
-EXPORT_SYMBOL(snd_timer_notify);
-EXPORT_SYMBOL(snd_timer_global_new);
-EXPORT_SYMBOL(snd_timer_global_free);
-EXPORT_SYMBOL(snd_timer_global_register);
-EXPORT_SYMBOL(snd_timer_interrupt);

commit d7f910bfedd863d13ea320030fe98e42d0938ed5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 2 17:35:30 2017 +0200

    ALSA: timer: Wrap with spinlock for queue access
    
    For accessing the snd_timer_user queue indices, we take tu->qlock.
    But it's forgotten in a couple of places.
    
    The one in snd_timer_user_params() should be safe without the
    spinlock as the timer is already stopped.  But it's better for
    consistency.
    
    The one in poll is just a read-out, so it's not inevitably needed, but
    it'd be good to make the result consistent, too.
    
    Tested-by: Alexander Potapenko <glider@google.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 96cffb1be57f..148290ace756 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1755,6 +1755,7 @@ static int snd_timer_user_params(struct file *file,
 		if (err < 0)
 			goto _end;
 	}
+	spin_lock_irq(&tu->qlock);
 	tu->qhead = tu->qtail = tu->qused = 0;
 	if (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {
 		if (tu->tread) {
@@ -1775,6 +1776,7 @@ static int snd_timer_user_params(struct file *file,
 	}
 	tu->filter = params.filter;
 	tu->ticks = params.ticks;
+	spin_unlock_irq(&tu->qlock);
 	err = 0;
  _end:
 	if (copy_to_user(_params, &params, sizeof(params)))
@@ -2022,10 +2024,12 @@ static unsigned int snd_timer_user_poll(struct file *file, poll_table * wait)
         poll_wait(file, &tu->qchange_sleep, wait);
 
 	mask = 0;
+	spin_lock_irq(&tu->qlock);
 	if (tu->qused)
 		mask |= POLLIN | POLLRDNORM;
 	if (tu->disconnected)
 		mask |= POLLERR;
+	spin_unlock_irq(&tu->qlock);
 
 	return mask;
 }

commit 890e2cb5d184629702a2c1a1e9631f9f64523c65
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 2 17:16:59 2017 +0200

    ALSA: timer: Improve user queue reallocation
    
    ALSA timer may reallocate the user queue upon request, and it happens
    at three places for now: at opening, at SNDRV_TIMER_IOCTL_PARAMS, and
    at SNDRV_TIMER_IOCTL_SELECT.  However, the last one,
    snd_timer_user_tselect(), doesn't need to reallocate the buffer since
    it doesn't change the queue size.  It does just because tu->tread
    might have been changed before starting the timer.
    
    Instead of *_SELECT ioctl, we should reallocate the queue at
    SNDRV_TIMER_IOCTL_TREAD; then the timer is guaranteed to be stopped,
    thus we can reassign the buffer more safely.
    
    This patch implements that with a slight code refactoring.
    Essentially, the patch achieves:
    - Introduce realloc_user_queue() for (re-)allocating the ring buffer,
      and call it from all places.  Also, realloc_user_queue() uses
      kcalloc() for avoiding possible leaks.
    - Add the buffer reallocation at SNDRV_TIMER_IOCTL_TREAD.  When it
      fails, tu->tread is restored to the old value, too.
    - Drop the buffer reallocation at snd_timer_user_tselect().
    
    Tested-by: Alexander Potapenko <glider@google.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index cd67d1c12cf1..96cffb1be57f 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1327,6 +1327,33 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 	wake_up(&tu->qchange_sleep);
 }
 
+static int realloc_user_queue(struct snd_timer_user *tu, int size)
+{
+	struct snd_timer_read *queue = NULL;
+	struct snd_timer_tread *tqueue = NULL;
+
+	if (tu->tread) {
+		tqueue = kcalloc(size, sizeof(*tqueue), GFP_KERNEL);
+		if (!tqueue)
+			return -ENOMEM;
+	} else {
+		queue = kcalloc(size, sizeof(*queue), GFP_KERNEL);
+		if (!queue)
+			return -ENOMEM;
+	}
+
+	spin_lock_irq(&tu->qlock);
+	kfree(tu->queue);
+	kfree(tu->tqueue);
+	tu->queue_size = size;
+	tu->queue = queue;
+	tu->tqueue = tqueue;
+	tu->qhead = tu->qtail = tu->qused = 0;
+	spin_unlock_irq(&tu->qlock);
+
+	return 0;
+}
+
 static int snd_timer_user_open(struct inode *inode, struct file *file)
 {
 	struct snd_timer_user *tu;
@@ -1343,10 +1370,7 @@ static int snd_timer_user_open(struct inode *inode, struct file *file)
 	init_waitqueue_head(&tu->qchange_sleep);
 	mutex_init(&tu->ioctl_lock);
 	tu->ticks = 1;
-	tu->queue_size = 128;
-	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
-			    GFP_KERNEL);
-	if (tu->queue == NULL) {
+	if (realloc_user_queue(tu, 128) < 0) {
 		kfree(tu);
 		return -ENOMEM;
 	}
@@ -1618,34 +1642,12 @@ static int snd_timer_user_tselect(struct file *file,
 	if (err < 0)
 		goto __err;
 
-	tu->qhead = tu->qtail = tu->qused = 0;
-	kfree(tu->queue);
-	tu->queue = NULL;
-	kfree(tu->tqueue);
-	tu->tqueue = NULL;
-	if (tu->tread) {
-		tu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),
-				     GFP_KERNEL);
-		if (tu->tqueue == NULL)
-			err = -ENOMEM;
-	} else {
-		tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
-				    GFP_KERNEL);
-		if (tu->queue == NULL)
-			err = -ENOMEM;
-	}
-
-      	if (err < 0) {
-		snd_timer_close(tu->timeri);
-      		tu->timeri = NULL;
-      	} else {
-		tu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;
-		tu->timeri->callback = tu->tread
+	tu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;
+	tu->timeri->callback = tu->tread
 			? snd_timer_user_tinterrupt : snd_timer_user_interrupt;
-		tu->timeri->ccallback = snd_timer_user_ccallback;
-		tu->timeri->callback_data = (void *)tu;
-		tu->timeri->disconnect = snd_timer_user_disconnect;
-	}
+	tu->timeri->ccallback = snd_timer_user_ccallback;
+	tu->timeri->callback_data = (void *)tu;
+	tu->timeri->disconnect = snd_timer_user_disconnect;
 
       __err:
 	return err;
@@ -1687,8 +1689,6 @@ static int snd_timer_user_params(struct file *file,
 	struct snd_timer_user *tu;
 	struct snd_timer_params params;
 	struct snd_timer *t;
-	struct snd_timer_read *tr;
-	struct snd_timer_tread *ttr;
 	int err;
 
 	tu = file->private_data;
@@ -1751,23 +1751,9 @@ static int snd_timer_user_params(struct file *file,
 	spin_unlock_irq(&t->lock);
 	if (params.queue_size > 0 &&
 	    (unsigned int)tu->queue_size != params.queue_size) {
-		if (tu->tread) {
-			ttr = kmalloc(params.queue_size * sizeof(*ttr),
-				      GFP_KERNEL);
-			if (ttr) {
-				kfree(tu->tqueue);
-				tu->queue_size = params.queue_size;
-				tu->tqueue = ttr;
-			}
-		} else {
-			tr = kmalloc(params.queue_size * sizeof(*tr),
-				     GFP_KERNEL);
-			if (tr) {
-				kfree(tu->queue);
-				tu->queue_size = params.queue_size;
-				tu->queue = tr;
-			}
-		}
+		err = realloc_user_queue(tu, params.queue_size);
+		if (err < 0)
+			goto _end;
 	}
 	tu->qhead = tu->qtail = tu->qused = 0;
 	if (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {
@@ -1891,13 +1877,19 @@ static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 		return snd_timer_user_next_device(argp);
 	case SNDRV_TIMER_IOCTL_TREAD:
 	{
-		int xarg;
+		int xarg, old_tread;
 
 		if (tu->timeri)	/* too late */
 			return -EBUSY;
 		if (get_user(xarg, p))
 			return -EFAULT;
+		old_tread = tu->tread;
 		tu->tread = xarg ? 1 : 0;
+		if (tu->tread != old_tread &&
+		    realloc_user_queue(tu, tu->queue_size) < 0) {
+			tu->tread = old_tread;
+			return -ENOMEM;
+		}
 		return 0;
 	}
 	case SNDRV_TIMER_IOCTL_GINFO:

commit ba3021b2c79b2fa9114f92790a99deb27a65b728
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 2 17:26:56 2017 +0200

    ALSA: timer: Fix missing queue indices reset at SNDRV_TIMER_IOCTL_SELECT
    
    snd_timer_user_tselect() reallocates the queue buffer dynamically, but
    it forgot to reset its indices.  Since the read may happen
    concurrently with ioctl and snd_timer_user_tselect() allocates the
    buffer via kmalloc(), this may lead to the leak of uninitialized
    kernel-space data, as spotted via KMSAN:
    
      BUG: KMSAN: use of unitialized memory in snd_timer_user_read+0x6c4/0xa10
      CPU: 0 PID: 1037 Comm: probe Not tainted 4.11.0-rc5+ #2739
      Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
      Call Trace:
       __dump_stack lib/dump_stack.c:16
       dump_stack+0x143/0x1b0 lib/dump_stack.c:52
       kmsan_report+0x12a/0x180 mm/kmsan/kmsan.c:1007
       kmsan_check_memory+0xc2/0x140 mm/kmsan/kmsan.c:1086
       copy_to_user ./arch/x86/include/asm/uaccess.h:725
       snd_timer_user_read+0x6c4/0xa10 sound/core/timer.c:2004
       do_loop_readv_writev fs/read_write.c:716
       __do_readv_writev+0x94c/0x1380 fs/read_write.c:864
       do_readv_writev fs/read_write.c:894
       vfs_readv fs/read_write.c:908
       do_readv+0x52a/0x5d0 fs/read_write.c:934
       SYSC_readv+0xb6/0xd0 fs/read_write.c:1021
       SyS_readv+0x87/0xb0 fs/read_write.c:1018
    
    This patch adds the missing reset of queue indices.  Together with the
    previous fix for the ioctl/read race, we cover the whole problem.
    
    Reported-by: Alexander Potapenko <glider@google.com>
    Tested-by: Alexander Potapenko <glider@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 1118bd8e2d3c..cd67d1c12cf1 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1618,6 +1618,7 @@ static int snd_timer_user_tselect(struct file *file,
 	if (err < 0)
 		goto __err;
 
+	tu->qhead = tu->qtail = tu->qused = 0;
 	kfree(tu->queue);
 	tu->queue = NULL;
 	kfree(tu->tqueue);

commit d11662f4f798b50d8c8743f433842c3e40fe3378
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 2 15:03:38 2017 +0200

    ALSA: timer: Fix race between read and ioctl
    
    The read from ALSA timer device, the function snd_timer_user_tread(),
    may access to an uninitialized struct snd_timer_user fields when the
    read is concurrently performed while the ioctl like
    snd_timer_user_tselect() is invoked.  We have already fixed the races
    among ioctls via a mutex, but we seem to have forgotten the race
    between read vs ioctl.
    
    This patch simply applies (more exactly extends the already applied
    range of) tu->ioctl_lock in snd_timer_user_tread() for closing the
    race window.
    
    Reported-by: Alexander Potapenko <glider@google.com>
    Tested-by: Alexander Potapenko <glider@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 2f836ca09860..1118bd8e2d3c 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1959,6 +1959,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 
 	tu = file->private_data;
 	unit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);
+	mutex_lock(&tu->ioctl_lock);
 	spin_lock_irq(&tu->qlock);
 	while ((long)count - result >= unit) {
 		while (!tu->qused) {
@@ -1974,7 +1975,9 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 			add_wait_queue(&tu->qchange_sleep, &wait);
 
 			spin_unlock_irq(&tu->qlock);
+			mutex_unlock(&tu->ioctl_lock);
 			schedule();
+			mutex_lock(&tu->ioctl_lock);
 			spin_lock_irq(&tu->qlock);
 
 			remove_wait_queue(&tu->qchange_sleep, &wait);
@@ -1994,7 +1997,6 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 		tu->qused--;
 		spin_unlock_irq(&tu->qlock);
 
-		mutex_lock(&tu->ioctl_lock);
 		if (tu->tread) {
 			if (copy_to_user(buffer, &tu->tqueue[qhead],
 					 sizeof(struct snd_timer_tread)))
@@ -2004,7 +2006,6 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 					 sizeof(struct snd_timer_read)))
 				err = -EFAULT;
 		}
-		mutex_unlock(&tu->ioctl_lock);
 
 		spin_lock_irq(&tu->qlock);
 		if (err < 0)
@@ -2014,6 +2015,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 	}
  _error:
 	spin_unlock_irq(&tu->qlock);
+	mutex_unlock(&tu->ioctl_lock);
 	return result > 0 ? result : err;
 }
 

commit a8c006aafead3c45ae5d5601e3717055bccf41bc
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Mar 31 18:22:23 2017 +0300

    ALSA: timer: Info leak in snd_timer_user_tinterrupt()
    
    The "r1" struct has memory holes.  We clear it with memset on one path
    where it is used but not the other.  Let's just memset it at the start
    of the function so it's always safe.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 8b9e7943a83b..2f836ca09860 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1277,6 +1277,7 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 	struct timespec tstamp;
 	int prev, append = 0;
 
+	memset(&r1, 0, sizeof(r1));
 	memset(&tstamp, 0, sizeof(tstamp));
 	spin_lock(&tu->qlock);
 	if ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |
@@ -1292,7 +1293,6 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 	}
 	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&
 	    tu->last_resolution != resolution) {
-		memset(&r1, 0, sizeof(r1));
 		r1.event = SNDRV_TIMER_EVENT_RESOLUTION;
 		r1.tstamp = tstamp;
 		r1.val = resolution;

commit e8ed68205f39a7a934901eab80a5cbf3a062b7b4
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Mar 31 18:21:41 2017 +0300

    ALSA: timer: remove some dead code
    
    We just checked "id.card < 0" on the lines before so we know it's not
    true here.  We can delete that check.
    
    Also checkpatch.pl complains about some extra curly braces so we may as
    well fix that while we're at it.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 6d4fbc439246..8b9e7943a83b 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1430,18 +1430,13 @@ static int snd_timer_user_next_device(struct snd_timer_id __user *_tid)
 			if (id.card < 0) {
 				id.card = 0;
 			} else {
-				if (id.card < 0) {
-					id.card = 0;
+				if (id.device < 0) {
+					id.device = 0;
 				} else {
-					if (id.device < 0) {
-						id.device = 0;
-					} else {
-						if (id.subdevice < 0) {
-							id.subdevice = 0;
-						} else {
-							id.subdevice++;
-						}
-					}
+					if (id.subdevice < 0)
+						id.subdevice = 0;
+					else
+						id.subdevice++;
 				}
 			}
 			list_for_each(p, &snd_timer_list) {

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index ad153149b231..6d4fbc439246 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -27,6 +27,7 @@
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/string.h>
+#include <linux/sched/signal.h>
 #include <sound/core.h>
 #include <sound/timer.h>
 #include <sound/control.h>

commit 71321eb3f2d0df4e6c327e0b936eec4458a12054
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 28 14:49:07 2017 +0100

    ALSA: timer: Reject user params with too small ticks
    
    When a user sets a too small ticks with a fine-grained timer like
    hrtimer, the kernel tries to fire up the timer irq too frequently.
    This may lead to the condensed locks, eventually the kernel spinlock
    lockup with warnings.
    
    For avoiding such a situation, we define a lower limit of the
    resolution, namely 1ms.  When the user passes a too small tick value
    that results in less than that, the kernel returns -EINVAL now.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index fc144f43faa6..ad153149b231 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1702,9 +1702,21 @@ static int snd_timer_user_params(struct file *file,
 		return -EBADFD;
 	if (copy_from_user(&params, _params, sizeof(params)))
 		return -EFAULT;
-	if (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE) && params.ticks < 1) {
-		err = -EINVAL;
-		goto _end;
+	if (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE)) {
+		u64 resolution;
+
+		if (params.ticks < 1) {
+			err = -EINVAL;
+			goto _end;
+		}
+
+		/* Don't allow resolution less than 1ms */
+		resolution = snd_timer_resolution(tu->timeri);
+		resolution *= params.ticks;
+		if (resolution < 1000000) {
+			err = -EINVAL;
+			goto _end;
+		}
 	}
 	if (params.queue_size > 0 &&
 	    (params.queue_size < 32 || params.queue_size > 1024)) {

commit 9f8a7658bcafb2a7853f7a2eae8a94e87e6e695b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 7 15:45:31 2016 +0200

    ALSA: timer: Fix zero-division by continue of uninitialized instance
    
    When a user timer instance is continued without the explicit start
    beforehand, the system gets eventually zero-division error like:
    
      divide error: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN
      CPU: 1 PID: 27320 Comm: syz-executor Not tainted 4.8.0-rc3-next-20160825+ #8
      Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
       task: ffff88003c9b2280 task.stack: ffff880027280000
       RIP: 0010:[<ffffffff858e1a6c>]  [<     inline     >] ktime_divns include/linux/ktime.h:195
       RIP: 0010:[<ffffffff858e1a6c>]  [<ffffffff858e1a6c>] snd_hrtimer_callback+0x1bc/0x3c0 sound/core/hrtimer.c:62
      Call Trace:
       <IRQ>
       [<     inline     >] __run_hrtimer kernel/time/hrtimer.c:1238
       [<ffffffff81504335>] __hrtimer_run_queues+0x325/0xe70 kernel/time/hrtimer.c:1302
       [<ffffffff81506ceb>] hrtimer_interrupt+0x18b/0x420 kernel/time/hrtimer.c:1336
       [<ffffffff8126d8df>] local_apic_timer_interrupt+0x6f/0xe0 arch/x86/kernel/apic/apic.c:933
       [<ffffffff86e13056>] smp_apic_timer_interrupt+0x76/0xa0 arch/x86/kernel/apic/apic.c:957
       [<ffffffff86e1210c>] apic_timer_interrupt+0x8c/0xa0 arch/x86/entry/entry_64.S:487
       <EOI>
       .....
    
    Although a similar issue was spotted and a fix patch was merged in
    commit [6b760bb2c63a: ALSA: timer: fix division by zero after
    SNDRV_TIMER_IOCTL_CONTINUE], it seems covering only a part of
    iceberg.
    
    In this patch, we fix the issue a bit more drastically.  Basically the
    continue of an uninitialized timer is supposed to be a fresh start, so
    we do it for user timers.  For the direct snd_timer_continue() call,
    there is no way to pass the initial tick value, so we kick out for the
    uninitialized case.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 2706061fc1ea..fc144f43faa6 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -35,6 +35,9 @@
 #include <sound/initval.h>
 #include <linux/kmod.h>
 
+/* internal flags */
+#define SNDRV_TIMER_IFLG_PAUSED		0x00010000
+
 #if IS_ENABLED(CONFIG_SND_HRTIMER)
 #define DEFAULT_TIMER_LIMIT 4
 #else
@@ -539,6 +542,10 @@ static int snd_timer_stop1(struct snd_timer_instance *timeri, bool stop)
 		}
 	}
 	timeri->flags &= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);
+	if (stop)
+		timeri->flags &= ~SNDRV_TIMER_IFLG_PAUSED;
+	else
+		timeri->flags |= SNDRV_TIMER_IFLG_PAUSED;
 	snd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :
 			  SNDRV_TIMER_EVENT_CONTINUE);
  unlock:
@@ -600,6 +607,10 @@ int snd_timer_stop(struct snd_timer_instance *timeri)
  */
 int snd_timer_continue(struct snd_timer_instance *timeri)
 {
+	/* timer can continue only after pause */
+	if (!(timeri->flags & SNDRV_TIMER_IFLG_PAUSED))
+		return -EINVAL;
+
 	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)
 		return snd_timer_start_slave(timeri, false);
 	else
@@ -1831,6 +1842,9 @@ static int snd_timer_user_continue(struct file *file)
 	tu = file->private_data;
 	if (!tu->timeri)
 		return -EBADFD;
+	/* start timer instead of continue if it's not used before */
+	if (!(tu->timeri->flags & SNDRV_TIMER_IFLG_PAUSED))
+		return snd_timer_user_start(file);
 	tu->timeri->lost = 0;
 	return (err = snd_timer_continue(tu->timeri)) < 0 ? err : 0;
 }

commit 11749e086b2766cccf6217a527ef5c5604ba069c
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Sun Aug 28 10:13:07 2016 +0200

    ALSA: timer: fix NULL pointer dereference in read()/ioctl() race
    
    I got this with syzkaller:
    
        ==================================================================
        BUG: KASAN: null-ptr-deref on address 0000000000000020
        Read of size 32 by task syz-executor/22519
        CPU: 1 PID: 22519 Comm: syz-executor Not tainted 4.8.0-rc2+ #169
        Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.9.3-0-ge2fc41e-prebuilt.qemu-project.org 04/01/2
        014
         0000000000000001 ffff880111a17a00 ffffffff81f9f141 ffff880111a17a90
         ffff880111a17c50 ffff880114584a58 ffff880114584a10 ffff880111a17a80
         ffffffff8161fe3f ffff880100000000 ffff880118d74a48 ffff880118d74a68
        Call Trace:
         [<ffffffff81f9f141>] dump_stack+0x83/0xb2
         [<ffffffff8161fe3f>] kasan_report_error+0x41f/0x4c0
         [<ffffffff8161ff74>] kasan_report+0x34/0x40
         [<ffffffff82c84b54>] ? snd_timer_user_read+0x554/0x790
         [<ffffffff8161e79e>] check_memory_region+0x13e/0x1a0
         [<ffffffff8161e9c1>] kasan_check_read+0x11/0x20
         [<ffffffff82c84b54>] snd_timer_user_read+0x554/0x790
         [<ffffffff82c84600>] ? snd_timer_user_info_compat.isra.5+0x2b0/0x2b0
         [<ffffffff817d0831>] ? proc_fault_inject_write+0x1c1/0x250
         [<ffffffff817d0670>] ? next_tgid+0x2a0/0x2a0
         [<ffffffff8127c278>] ? do_group_exit+0x108/0x330
         [<ffffffff8174653a>] ? fsnotify+0x72a/0xca0
         [<ffffffff81674dfe>] __vfs_read+0x10e/0x550
         [<ffffffff82c84600>] ? snd_timer_user_info_compat.isra.5+0x2b0/0x2b0
         [<ffffffff81674cf0>] ? do_sendfile+0xc50/0xc50
         [<ffffffff81745e10>] ? __fsnotify_update_child_dentry_flags+0x60/0x60
         [<ffffffff8143fec6>] ? kcov_ioctl+0x56/0x190
         [<ffffffff81e5ada2>] ? common_file_perm+0x2e2/0x380
         [<ffffffff81746b0e>] ? __fsnotify_parent+0x5e/0x2b0
         [<ffffffff81d93536>] ? security_file_permission+0x86/0x1e0
         [<ffffffff816728f5>] ? rw_verify_area+0xe5/0x2b0
         [<ffffffff81675355>] vfs_read+0x115/0x330
         [<ffffffff81676371>] SyS_read+0xd1/0x1a0
         [<ffffffff816762a0>] ? vfs_write+0x4b0/0x4b0
         [<ffffffff82001c2c>] ? __this_cpu_preempt_check+0x1c/0x20
         [<ffffffff8150455a>] ? __context_tracking_exit.part.4+0x3a/0x1e0
         [<ffffffff816762a0>] ? vfs_write+0x4b0/0x4b0
         [<ffffffff81005524>] do_syscall_64+0x1c4/0x4e0
         [<ffffffff810052fc>] ? syscall_return_slowpath+0x16c/0x1d0
         [<ffffffff83c3276a>] entry_SYSCALL64_slow_path+0x25/0x25
        ==================================================================
    
    There are a couple of problems that I can see:
    
     - ioctl(SNDRV_TIMER_IOCTL_SELECT), which potentially sets
       tu->queue/tu->tqueue to NULL on memory allocation failure, so read()
       would get a NULL pointer dereference like the above splat
    
     - the same ioctl() can free tu->queue/to->tqueue which means read()
       could potentially see (and dereference) the freed pointer
    
    We can fix both by taking the ioctl_lock mutex when dereferencing
    ->queue/->tqueue, since that's always held over all the ioctl() code.
    
    Just looking at the code I find it likely that there are more problems
    here such as tu->qhead pointing outside the buffer if the size is
    changed concurrently using SNDRV_TIMER_IOCTL_PARAMS.
    
    Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 2d6e3e76ddf5..2706061fc1ea 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1972,6 +1972,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 		tu->qused--;
 		spin_unlock_irq(&tu->qlock);
 
+		mutex_lock(&tu->ioctl_lock);
 		if (tu->tread) {
 			if (copy_to_user(buffer, &tu->tqueue[qhead],
 					 sizeof(struct snd_timer_tread)))
@@ -1981,6 +1982,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 					 sizeof(struct snd_timer_read)))
 				err = -EFAULT;
 		}
+		mutex_unlock(&tu->ioctl_lock);
 
 		spin_lock_irq(&tu->qlock);
 		if (err < 0)

commit 8ddc05638ee42b18ba4fe99b5fb647fa3ad20456
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Mon Aug 29 00:33:51 2016 +0200

    ALSA: timer: fix NULL pointer dereference on memory allocation failure
    
    I hit this with syzkaller:
    
        kasan: CONFIG_KASAN_INLINE enabled
        kasan: GPF could be caused by NULL-ptr deref or user memory access
        general protection fault: 0000 [#1] PREEMPT SMP KASAN
        CPU: 0 PID: 1327 Comm: a.out Not tainted 4.8.0-rc2+ #190
        Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.9.3-0-ge2fc41e-prebuilt.qemu-project.org 04/01/2014
        task: ffff88011278d600 task.stack: ffff8801120c0000
        RIP: 0010:[<ffffffff82c8ba07>]  [<ffffffff82c8ba07>] snd_hrtimer_start+0x77/0x100
        RSP: 0018:ffff8801120c7a60  EFLAGS: 00010006
        RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000007
        RDX: 0000000000000009 RSI: 1ffff10023483091 RDI: 0000000000000048
        RBP: ffff8801120c7a78 R08: ffff88011a5cf768 R09: ffff88011a5ba790
        R10: 0000000000000002 R11: ffffed00234b9ef1 R12: ffff880114843980
        R13: ffffffff84213c00 R14: ffff880114843ab0 R15: 0000000000000286
        FS:  00007f72958f3700(0000) GS:ffff88011aa00000(0000) knlGS:0000000000000000
        CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
        CR2: 0000000000603001 CR3: 00000001126ab000 CR4: 00000000000006f0
        Stack:
         ffff880114843980 ffff880111eb2dc0 ffff880114843a34 ffff8801120c7ad0
         ffffffff82c81ab1 0000000000000000 ffffffff842138e0 0000000100000000
         ffff880111eb2dd0 ffff880111eb2dc0 0000000000000001 ffff880111eb2dc0
        Call Trace:
         [<ffffffff82c81ab1>] snd_timer_start1+0x331/0x670
         [<ffffffff82c85bfd>] snd_timer_start+0x5d/0xa0
         [<ffffffff82c8795e>] snd_timer_user_ioctl+0x88e/0x2830
         [<ffffffff8159f3a0>] ? __follow_pte.isra.49+0x430/0x430
         [<ffffffff82c870d0>] ? snd_timer_pause+0x80/0x80
         [<ffffffff815a26fa>] ? do_wp_page+0x3aa/0x1c90
         [<ffffffff8132762f>] ? put_prev_entity+0x108f/0x21a0
         [<ffffffff82c870d0>] ? snd_timer_pause+0x80/0x80
         [<ffffffff816b0733>] do_vfs_ioctl+0x193/0x1050
         [<ffffffff813510af>] ? cpuacct_account_field+0x12f/0x1a0
         [<ffffffff816b05a0>] ? ioctl_preallocate+0x200/0x200
         [<ffffffff81002f2f>] ? syscall_trace_enter+0x3cf/0xdb0
         [<ffffffff815045ba>] ? __context_tracking_exit.part.4+0x9a/0x1e0
         [<ffffffff81002b60>] ? exit_to_usermode_loop+0x190/0x190
         [<ffffffff82001a97>] ? check_preemption_disabled+0x37/0x1e0
         [<ffffffff81d93889>] ? security_file_ioctl+0x89/0xb0
         [<ffffffff816b167f>] SyS_ioctl+0x8f/0xc0
         [<ffffffff816b15f0>] ? do_vfs_ioctl+0x1050/0x1050
         [<ffffffff81005524>] do_syscall_64+0x1c4/0x4e0
         [<ffffffff83c32b2a>] entry_SYSCALL64_slow_path+0x25/0x25
        Code: c7 c7 c4 b9 c8 82 48 89 d9 4c 89 ee e8 63 88 7f fe e8 7e 46 7b fe 48 8d 7b 48 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <0f> b6 04 02 84 c0 74 04 84 c0 7e 65 80 7b 48 00 74 0e e8 52 46
        RIP  [<ffffffff82c8ba07>] snd_hrtimer_start+0x77/0x100
         RSP <ffff8801120c7a60>
        ---[ end trace 5955b08db7f2b029 ]---
    
    This can happen if snd_hrtimer_open() fails to allocate memory and
    returns an error, which is currently not checked by snd_timer_open():
    
        ioctl(SNDRV_TIMER_IOCTL_SELECT)
         - snd_timer_user_tselect()
            - snd_timer_close()
               - snd_hrtimer_close()
                  - (struct snd_timer *) t->private_data = NULL
            - snd_timer_open()
               - snd_hrtimer_open()
                  - kzalloc() fails; t->private_data is still NULL
    
        ioctl(SNDRV_TIMER_IOCTL_START)
         - snd_timer_user_start()
            - snd_timer_start()
               - snd_timer_start1()
                  - snd_hrtimer_start()
                    - t->private_data == NULL // boom
    
    Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 00618703c58f..2d6e3e76ddf5 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -294,8 +294,21 @@ int snd_timer_open(struct snd_timer_instance **ti,
 		get_device(&timer->card->card_dev);
 	timeri->slave_class = tid->dev_sclass;
 	timeri->slave_id = slave_id;
-	if (list_empty(&timer->open_list_head) && timer->hw.open)
-		timer->hw.open(timer);
+
+	if (list_empty(&timer->open_list_head) && timer->hw.open) {
+		int err = timer->hw.open(timer);
+		if (err) {
+			kfree(timeri->owner);
+			kfree(timeri);
+
+			if (timer->card)
+				put_device(&timer->card->card_dev);
+			module_put(timer->module);
+			mutex_unlock(&register_mutex);
+			return err;
+		}
+	}
+
 	list_add_tail(&timeri->open_list, &timer->open_list_head);
 	snd_timer_check_master(timeri);
 	mutex_unlock(&register_mutex);

commit 6b760bb2c63a9e322c0e4a0b5daf335ad93d5a33
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Mon Aug 29 00:33:50 2016 +0200

    ALSA: timer: fix division by zero after SNDRV_TIMER_IOCTL_CONTINUE
    
    I got this:
    
        divide error: 0000 [#1] PREEMPT SMP KASAN
        CPU: 1 PID: 1327 Comm: a.out Not tainted 4.8.0-rc2+ #189
        Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.9.3-0-ge2fc41e-prebuilt.qemu-project.org 04/01/2014
        task: ffff8801120a9580 task.stack: ffff8801120b0000
        RIP: 0010:[<ffffffff82c8bd9a>]  [<ffffffff82c8bd9a>] snd_hrtimer_callback+0x1da/0x3f0
        RSP: 0018:ffff88011aa87da8  EFLAGS: 00010006
        RAX: 0000000000004f76 RBX: ffff880112655e88 RCX: 0000000000000000
        RDX: 0000000000000000 RSI: ffff880112655ea0 RDI: 0000000000000001
        RBP: ffff88011aa87e00 R08: ffff88013fff905c R09: ffff88013fff9048
        R10: ffff88013fff9050 R11: 00000001050a7b8c R12: ffff880114778a00
        R13: ffff880114778ab4 R14: ffff880114778b30 R15: 0000000000000000
        FS:  00007f071647c700(0000) GS:ffff88011aa80000(0000) knlGS:0000000000000000
        CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
        CR2: 0000000000603001 CR3: 0000000112021000 CR4: 00000000000006e0
        Stack:
         0000000000000000 ffff880114778ab8 ffff880112655ea0 0000000000004f76
         ffff880112655ec8 ffff880112655e80 ffff880112655e88 ffff88011aa98fc0
         00000000b97ccf2b dffffc0000000000 ffff88011aa98fc0 ffff88011aa87ef0
        Call Trace:
         <IRQ>
         [<ffffffff813abce7>] __hrtimer_run_queues+0x347/0xa00
         [<ffffffff82c8bbc0>] ? snd_hrtimer_close+0x130/0x130
         [<ffffffff813ab9a0>] ? retrigger_next_event+0x1b0/0x1b0
         [<ffffffff813ae1a6>] ? hrtimer_interrupt+0x136/0x4b0
         [<ffffffff813ae220>] hrtimer_interrupt+0x1b0/0x4b0
         [<ffffffff8120f91e>] local_apic_timer_interrupt+0x6e/0xf0
         [<ffffffff81227ad3>] ? kvm_guest_apic_eoi_write+0x13/0xc0
         [<ffffffff83c35086>] smp_apic_timer_interrupt+0x76/0xa0
         [<ffffffff83c3416c>] apic_timer_interrupt+0x8c/0xa0
         <EOI>
         [<ffffffff83c3239c>] ? _raw_spin_unlock_irqrestore+0x2c/0x60
         [<ffffffff82c8185d>] snd_timer_start1+0xdd/0x670
         [<ffffffff82c87015>] snd_timer_continue+0x45/0x80
         [<ffffffff82c88100>] snd_timer_user_ioctl+0x1030/0x2830
         [<ffffffff8159f3a0>] ? __follow_pte.isra.49+0x430/0x430
         [<ffffffff82c870d0>] ? snd_timer_pause+0x80/0x80
         [<ffffffff815a26fa>] ? do_wp_page+0x3aa/0x1c90
         [<ffffffff815aa4f8>] ? handle_mm_fault+0xbc8/0x27f0
         [<ffffffff815a9930>] ? __pmd_alloc+0x370/0x370
         [<ffffffff82c870d0>] ? snd_timer_pause+0x80/0x80
         [<ffffffff816b0733>] do_vfs_ioctl+0x193/0x1050
         [<ffffffff816b05a0>] ? ioctl_preallocate+0x200/0x200
         [<ffffffff81002f2f>] ? syscall_trace_enter+0x3cf/0xdb0
         [<ffffffff815045ba>] ? __context_tracking_exit.part.4+0x9a/0x1e0
         [<ffffffff81002b60>] ? exit_to_usermode_loop+0x190/0x190
         [<ffffffff82001a97>] ? check_preemption_disabled+0x37/0x1e0
         [<ffffffff81d93889>] ? security_file_ioctl+0x89/0xb0
         [<ffffffff816b167f>] SyS_ioctl+0x8f/0xc0
         [<ffffffff816b15f0>] ? do_vfs_ioctl+0x1050/0x1050
         [<ffffffff81005524>] do_syscall_64+0x1c4/0x4e0
         [<ffffffff83c32b2a>] entry_SYSCALL64_slow_path+0x25/0x25
        Code: e8 fc 42 7b fe 8b 0d 06 8a 50 03 49 0f af cf 48 85 c9 0f 88 7c 01 00 00 48 89 4d a8 e8 e0 42 7b fe 48 8b 45 c0 48 8b 4d a8 48 99 <48> f7 f9 49 01 c7 e8 cb 42 7b fe 48 8b 55 d0 48 b8 00 00 00 00
        RIP  [<ffffffff82c8bd9a>] snd_hrtimer_callback+0x1da/0x3f0
         RSP <ffff88011aa87da8>
        ---[ end trace 6aa380f756a21074 ]---
    
    The problem happens when you call ioctl(SNDRV_TIMER_IOCTL_CONTINUE) on a
    completely new/unused timer -- it will have ->sticks == 0, which causes a
    divide by 0 in snd_hrtimer_callback().
    
    Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 9a6157ea6881..00618703c58f 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -813,6 +813,7 @@ int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,
 	timer->tmr_subdevice = tid->subdevice;
 	if (id)
 		strlcpy(timer->id, id, sizeof(timer->id));
+	timer->sticks = 1;
 	INIT_LIST_HEAD(&timer->device_list);
 	INIT_LIST_HEAD(&timer->open_list_head);
 	INIT_LIST_HEAD(&timer->active_list_head);

commit 3fa6993fef634e05d200d141a85df0b044572364
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 4 14:02:15 2016 +0200

    ALSA: timer: Fix negative queue usage by racy accesses
    
    The user timer tu->qused counter may go to a negative value when
    multiple concurrent reads are performed since both the check and the
    decrement of tu->qused are done in two individual locked contexts.
    This results in bogus read outs, and the endless loop in the
    user-space side.
    
    The fix is to move the decrement of the tu->qused counter into the
    same spinlock context as the zero-check of the counter.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index e722022d325d..9a6157ea6881 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1955,6 +1955,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 
 		qhead = tu->qhead++;
 		tu->qhead %= tu->queue_size;
+		tu->qused--;
 		spin_unlock_irq(&tu->qlock);
 
 		if (tu->tread) {
@@ -1968,7 +1969,6 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 		}
 
 		spin_lock_irq(&tu->qlock);
-		tu->qused--;
 		if (err < 0)
 			goto _error;
 		result += unit;

commit e4ec8cc8039a7063e24204299b462bd1383184a5
Author: Kangjie Lu <kangjielu@gmail.com>
Date:   Tue May 3 16:44:32 2016 -0400

    ALSA: timer: Fix leak in events via snd_timer_user_tinterrupt
    
    The stack object “r1” has a total size of 32 bytes. Its field
    “event” and “val” both contain 4 bytes padding. These 8 bytes
    padding bytes are sent to user without being initialized.
    
    Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index cc3c08d17ab1..e722022d325d 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1266,6 +1266,7 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 	}
 	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&
 	    tu->last_resolution != resolution) {
+		memset(&r1, 0, sizeof(r1));
 		r1.event = SNDRV_TIMER_EVENT_RESOLUTION;
 		r1.tstamp = tstamp;
 		r1.val = resolution;

commit 9a47e9cff994f37f7f0dbd9ae23740d0f64f9fe6
Author: Kangjie Lu <kangjielu@gmail.com>
Date:   Tue May 3 16:44:20 2016 -0400

    ALSA: timer: Fix leak in events via snd_timer_user_ccallback
    
    The stack object “r1” has a total size of 32 bytes. Its field
    “event” and “val” both contain 4 bytes padding. These 8 bytes
    padding bytes are sent to user without being initialized.
    
    Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 306a93dea20a..cc3c08d17ab1 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1223,6 +1223,7 @@ static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,
 		tu->tstamp = *tstamp;
 	if ((tu->filter & (1 << event)) == 0 || !tu->tread)
 		return;
+	memset(&r1, 0, sizeof(r1));
 	r1.event = event;
 	r1.tstamp = *tstamp;
 	r1.val = resolution;

commit cec8f96e49d9be372fdb0c3836dcf31ec71e457e
Author: Kangjie Lu <kangjielu@gmail.com>
Date:   Tue May 3 16:44:07 2016 -0400

    ALSA: timer: Fix leak in SNDRV_TIMER_IOCTL_PARAMS
    
    The stack object “tread” has a total size of 32 bytes. Its field
    “event” and “val” both contain 4 bytes padding. These 8 bytes
    padding bytes are sent to user without being initialized.
    
    Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 0cfc028c1193..306a93dea20a 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1737,6 +1737,7 @@ static int snd_timer_user_params(struct file *file,
 	if (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {
 		if (tu->tread) {
 			struct snd_timer_tread tread;
+			memset(&tread, 0, sizeof(tread));
 			tread.event = SNDRV_TIMER_EVENT_EARLY;
 			tread.tstamp.tv_sec = 0;
 			tread.tstamp.tv_nsec = 0;

commit 34ce71a96dcba24c71b07f1b087bd179b885784d
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Sat Apr 23 02:58:05 2016 +0200

    ALSA: timer: remove legacy rtctimer
    
    There are no users of rtctimer left. Remove its code as this is the
    in-kernel user of the legacy PC RTC driver that will hopefully be removed
    at some point.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 6469bedda2f3..0cfc028c1193 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -37,8 +37,6 @@
 
 #if IS_ENABLED(CONFIG_SND_HRTIMER)
 #define DEFAULT_TIMER_LIMIT 4
-#elif IS_ENABLED(CONFIG_SND_RTCTIMER)
-#define DEFAULT_TIMER_LIMIT 2
 #else
 #define DEFAULT_TIMER_LIMIT 1
 #endif

commit 4a07083ed613644c96c34a7dd2853dc5d7c70902
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 1 12:28:16 2016 +0200

    ALSA: timer: Use mod_timer() for rearming the system timer
    
    ALSA system timer backend stops the timer via del_timer() without sync
    and leaves del_timer_sync() at the close instead.  This is because of
    the restriction by the design of ALSA timer: namely, the stop callback
    may be called from the timer handler, and calling the sync shall lead
    to a hangup.  However, this also triggers a kernel BUG() when the
    timer is rearmed immediately after stopping without sync:
     kernel BUG at kernel/time/timer.c:966!
     Call Trace:
      <IRQ>
      [<ffffffff8239c94e>] snd_timer_s_start+0x13e/0x1a0
      [<ffffffff8239e1f4>] snd_timer_interrupt+0x504/0xec0
      [<ffffffff8122fca0>] ? debug_check_no_locks_freed+0x290/0x290
      [<ffffffff8239ec64>] snd_timer_s_function+0xb4/0x120
      [<ffffffff81296b72>] call_timer_fn+0x162/0x520
      [<ffffffff81296add>] ? call_timer_fn+0xcd/0x520
      [<ffffffff8239ebb0>] ? snd_timer_interrupt+0xec0/0xec0
      ....
    
    It's the place where add_timer() checks the pending timer.  It's clear
    that this may happen after the immediate restart without sync in our
    cases.
    
    So, the workaround here is just to use mod_timer() instead of
    add_timer().  This looks like a band-aid fix, but it's a right move,
    as snd_timer_interrupt() takes care of the continuous rearm of timer.
    
    Reported-by: Jiri Slaby <jslaby@suse.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index ea4d999113ef..6469bedda2f3 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1019,8 +1019,8 @@ static int snd_timer_s_start(struct snd_timer * timer)
 		njiff += timer->sticks - priv->correction;
 		priv->correction = 0;
 	}
-	priv->last_expires = priv->tlist.expires = njiff;
-	add_timer(&priv->tlist);
+	priv->last_expires = njiff;
+	mod_timer(&priv->tlist, njiff);
 	return 0;
 }
 

commit 91d2178e26fdc806f33063f9df5904a48e3b6aeb
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed Mar 23 08:03:59 2016 +0900

    ALSA: timer: fix gparams ioctl compatibility for different architectures
    
    'struct snd_timer_gparams' includes some members with 'unsigned long',
    therefore its size differs depending on data models of architecture. As
    a result, x86/x32 applications fail to execute ioctl(2) with
    SNDRV_TIMER_GPARAMS command on x86_64 machine.
    
    This commit fixes this bug by adding a pair of structure and ioctl
    command for the compatibility.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index aa1b15c155d1..ea4d999113ef 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1502,17 +1502,13 @@ static int snd_timer_user_ginfo(struct file *file,
 	return err;
 }
 
-static int snd_timer_user_gparams(struct file *file,
-				  struct snd_timer_gparams __user *_gparams)
+static int timer_set_gparams(struct snd_timer_gparams *gparams)
 {
-	struct snd_timer_gparams gparams;
 	struct snd_timer *t;
 	int err;
 
-	if (copy_from_user(&gparams, _gparams, sizeof(gparams)))
-		return -EFAULT;
 	mutex_lock(&register_mutex);
-	t = snd_timer_find(&gparams.tid);
+	t = snd_timer_find(&gparams->tid);
 	if (!t) {
 		err = -ENODEV;
 		goto _error;
@@ -1525,12 +1521,22 @@ static int snd_timer_user_gparams(struct file *file,
 		err = -ENOSYS;
 		goto _error;
 	}
-	err = t->hw.set_period(t, gparams.period_num, gparams.period_den);
+	err = t->hw.set_period(t, gparams->period_num, gparams->period_den);
 _error:
 	mutex_unlock(&register_mutex);
 	return err;
 }
 
+static int snd_timer_user_gparams(struct file *file,
+				  struct snd_timer_gparams __user *_gparams)
+{
+	struct snd_timer_gparams gparams;
+
+	if (copy_from_user(&gparams, _gparams, sizeof(gparams)))
+		return -EFAULT;
+	return timer_set_gparams(&gparams);
+}
+
 static int snd_timer_user_gstatus(struct file *file,
 				  struct snd_timer_gstatus __user *_gstatus)
 {

commit f65e0d299807d8a11812845c972493c3f9a18e10
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 10 12:47:03 2016 +0100

    ALSA: timer: Call notifier in the same spinlock
    
    snd_timer_notify1() is called outside the spinlock and it retakes the
    lock after the unlock.  This is rather racy, and it's safer to move
    snd_timer_notify() call inside the main spinlock.
    
    The patch also contains a slight refactoring / cleanup of the code.
    Now all start/stop/continue/pause look more symmetric and a bit better
    readable.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index b572a9bc31ad..aa1b15c155d1 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -305,8 +305,6 @@ int snd_timer_open(struct snd_timer_instance **ti,
 	return 0;
 }
 
-static int _snd_timer_stop(struct snd_timer_instance *timeri, int event);
-
 /*
  * close a timer instance
  */
@@ -389,7 +387,6 @@ unsigned long snd_timer_resolution(struct snd_timer_instance *timeri)
 static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 {
 	struct snd_timer *timer;
-	unsigned long flags;
 	unsigned long resolution = 0;
 	struct snd_timer_instance *ts;
 	struct timespec tstamp;
@@ -413,34 +410,66 @@ static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 		return;
 	if (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)
 		return;
-	spin_lock_irqsave(&timer->lock, flags);
 	list_for_each_entry(ts, &ti->slave_active_head, active_list)
 		if (ts->ccallback)
 			ts->ccallback(ts, event + 100, &tstamp, resolution);
-	spin_unlock_irqrestore(&timer->lock, flags);
 }
 
-static int snd_timer_start1(struct snd_timer *timer, struct snd_timer_instance *timeri,
-			    unsigned long sticks)
+/* start/continue a master timer */
+static int snd_timer_start1(struct snd_timer_instance *timeri,
+			    bool start, unsigned long ticks)
 {
+	struct snd_timer *timer;
+	int result;
+	unsigned long flags;
+
+	timer = timeri->timer;
+	if (!timer)
+		return -EINVAL;
+
+	spin_lock_irqsave(&timer->lock, flags);
+	if (timer->card && timer->card->shutdown) {
+		result = -ENODEV;
+		goto unlock;
+	}
+	if (timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |
+			     SNDRV_TIMER_IFLG_START)) {
+		result = -EBUSY;
+		goto unlock;
+	}
+
+	if (start)
+		timeri->ticks = timeri->cticks = ticks;
+	else if (!timeri->cticks)
+		timeri->cticks = 1;
+	timeri->pticks = 0;
+
 	list_move_tail(&timeri->active_list, &timer->active_list_head);
 	if (timer->running) {
 		if (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)
 			goto __start_now;
 		timer->flags |= SNDRV_TIMER_FLG_RESCHED;
 		timeri->flags |= SNDRV_TIMER_IFLG_START;
-		return 1;	/* delayed start */
+		result = 1; /* delayed start */
 	} else {
-		timer->sticks = sticks;
+		if (start)
+			timer->sticks = ticks;
 		timer->hw.start(timer);
 	      __start_now:
 		timer->running++;
 		timeri->flags |= SNDRV_TIMER_IFLG_RUNNING;
-		return 0;
+		result = 0;
 	}
+	snd_timer_notify1(timeri, start ? SNDRV_TIMER_EVENT_START :
+			  SNDRV_TIMER_EVENT_CONTINUE);
+ unlock:
+	spin_unlock_irqrestore(&timer->lock, flags);
+	return result;
 }
 
-static int snd_timer_start_slave(struct snd_timer_instance *timeri)
+/* start/continue a slave timer */
+static int snd_timer_start_slave(struct snd_timer_instance *timeri,
+				 bool start)
 {
 	unsigned long flags;
 
@@ -454,88 +483,37 @@ static int snd_timer_start_slave(struct snd_timer_instance *timeri)
 		spin_lock(&timeri->timer->lock);
 		list_add_tail(&timeri->active_list,
 			      &timeri->master->slave_active_head);
+		snd_timer_notify1(timeri, start ? SNDRV_TIMER_EVENT_START :
+				  SNDRV_TIMER_EVENT_CONTINUE);
 		spin_unlock(&timeri->timer->lock);
 	}
 	spin_unlock_irqrestore(&slave_active_lock, flags);
 	return 1; /* delayed start */
 }
 
-/*
- *  start the timer instance
- */
-int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)
-{
-	struct snd_timer *timer;
-	int result = -EINVAL;
-	unsigned long flags;
-
-	if (timeri == NULL || ticks < 1)
-		return -EINVAL;
-	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
-		result = snd_timer_start_slave(timeri);
-		if (result >= 0)
-			snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);
-		return result;
-	}
-	timer = timeri->timer;
-	if (timer == NULL)
-		return -EINVAL;
-	if (timer->card && timer->card->shutdown)
-		return -ENODEV;
-	spin_lock_irqsave(&timer->lock, flags);
-	if (timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |
-			     SNDRV_TIMER_IFLG_START)) {
-		result = -EBUSY;
-		goto unlock;
-	}
-	timeri->ticks = timeri->cticks = ticks;
-	timeri->pticks = 0;
-	result = snd_timer_start1(timer, timeri, ticks);
- unlock:
-	spin_unlock_irqrestore(&timer->lock, flags);
-	if (result >= 0)
-		snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);
-	return result;
-}
-
-static int _snd_timer_stop(struct snd_timer_instance *timeri, int event)
+/* stop/pause a master timer */
+static int snd_timer_stop1(struct snd_timer_instance *timeri, bool stop)
 {
 	struct snd_timer *timer;
+	int result = 0;
 	unsigned long flags;
 
-	if (snd_BUG_ON(!timeri))
-		return -ENXIO;
-
-	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
-		spin_lock_irqsave(&slave_active_lock, flags);
-		if (!(timeri->flags & SNDRV_TIMER_IFLG_RUNNING)) {
-			spin_unlock_irqrestore(&slave_active_lock, flags);
-			return -EBUSY;
-		}
-		if (timeri->timer)
-			spin_lock(&timeri->timer->lock);
-		timeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
-		list_del_init(&timeri->ack_list);
-		list_del_init(&timeri->active_list);
-		if (timeri->timer)
-			spin_unlock(&timeri->timer->lock);
-		spin_unlock_irqrestore(&slave_active_lock, flags);
-		goto __end;
-	}
 	timer = timeri->timer;
 	if (!timer)
 		return -EINVAL;
 	spin_lock_irqsave(&timer->lock, flags);
 	if (!(timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |
 			       SNDRV_TIMER_IFLG_START))) {
-		spin_unlock_irqrestore(&timer->lock, flags);
-		return -EBUSY;
+		result = -EBUSY;
+		goto unlock;
 	}
 	list_del_init(&timeri->ack_list);
 	list_del_init(&timeri->active_list);
-	if (timer->card && timer->card->shutdown) {
-		spin_unlock_irqrestore(&timer->lock, flags);
-		return 0;
+	if (timer->card && timer->card->shutdown)
+		goto unlock;
+	if (stop) {
+		timeri->cticks = timeri->ticks;
+		timeri->pticks = 0;
 	}
 	if ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&
 	    !(--timer->running)) {
@@ -550,13 +528,49 @@ static int _snd_timer_stop(struct snd_timer_instance *timeri, int event)
 		}
 	}
 	timeri->flags &= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);
+	snd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :
+			  SNDRV_TIMER_EVENT_CONTINUE);
+ unlock:
 	spin_unlock_irqrestore(&timer->lock, flags);
-      __end:
-	if (event != SNDRV_TIMER_EVENT_RESOLUTION)
-		snd_timer_notify1(timeri, event);
+	return result;
+}
+
+/* stop/pause a slave timer */
+static int snd_timer_stop_slave(struct snd_timer_instance *timeri, bool stop)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&slave_active_lock, flags);
+	if (!(timeri->flags & SNDRV_TIMER_IFLG_RUNNING)) {
+		spin_unlock_irqrestore(&slave_active_lock, flags);
+		return -EBUSY;
+	}
+	timeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
+	if (timeri->timer) {
+		spin_lock(&timeri->timer->lock);
+		list_del_init(&timeri->ack_list);
+		list_del_init(&timeri->active_list);
+		snd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :
+				  SNDRV_TIMER_EVENT_CONTINUE);
+		spin_unlock(&timeri->timer->lock);
+	}
+	spin_unlock_irqrestore(&slave_active_lock, flags);
 	return 0;
 }
 
+/*
+ *  start the timer instance
+ */
+int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)
+{
+	if (timeri == NULL || ticks < 1)
+		return -EINVAL;
+	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)
+		return snd_timer_start_slave(timeri, true);
+	else
+		return snd_timer_start1(timeri, true, ticks);
+}
+
 /*
  * stop the timer instance.
  *
@@ -564,21 +578,10 @@ static int _snd_timer_stop(struct snd_timer_instance *timeri, int event)
  */
 int snd_timer_stop(struct snd_timer_instance *timeri)
 {
-	struct snd_timer *timer;
-	unsigned long flags;
-	int err;
-
-	err = _snd_timer_stop(timeri, SNDRV_TIMER_EVENT_STOP);
-	if (err < 0)
-		return err;
-	timer = timeri->timer;
-	if (!timer)
-		return -EINVAL;
-	spin_lock_irqsave(&timer->lock, flags);
-	timeri->cticks = timeri->ticks;
-	timeri->pticks = 0;
-	spin_unlock_irqrestore(&timer->lock, flags);
-	return 0;
+	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)
+		return snd_timer_stop_slave(timeri, true);
+	else
+		return snd_timer_stop1(timeri, true);
 }
 
 /*
@@ -586,32 +589,10 @@ int snd_timer_stop(struct snd_timer_instance *timeri)
  */
 int snd_timer_continue(struct snd_timer_instance *timeri)
 {
-	struct snd_timer *timer;
-	int result = -EINVAL;
-	unsigned long flags;
-
-	if (timeri == NULL)
-		return result;
 	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)
-		return snd_timer_start_slave(timeri);
-	timer = timeri->timer;
-	if (! timer)
-		return -EINVAL;
-	if (timer->card && timer->card->shutdown)
-		return -ENODEV;
-	spin_lock_irqsave(&timer->lock, flags);
-	if (timeri->flags & SNDRV_TIMER_IFLG_RUNNING) {
-		result = -EBUSY;
-		goto unlock;
-	}
-	if (!timeri->cticks)
-		timeri->cticks = 1;
-	timeri->pticks = 0;
-	result = snd_timer_start1(timer, timeri, timer->sticks);
- unlock:
-	spin_unlock_irqrestore(&timer->lock, flags);
-	snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_CONTINUE);
-	return result;
+		return snd_timer_start_slave(timeri, false);
+	else
+		return snd_timer_start1(timeri, false, 0);
 }
 
 /*
@@ -619,7 +600,10 @@ int snd_timer_continue(struct snd_timer_instance *timeri)
  */
 int snd_timer_pause(struct snd_timer_instance * timeri)
 {
-	return _snd_timer_stop(timeri, SNDRV_TIMER_EVENT_PAUSE);
+	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)
+		return snd_timer_stop_slave(timeri, false);
+	else
+		return snd_timer_stop1(timeri, false);
 }
 
 /*

commit 9984d1b5835ca29fc7025186a891ee7398d21cc7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 10 11:53:30 2016 +0100

    ALSA: timer: Protect the whole snd_timer_close() with open race
    
    In order to make the open/close more robust, widen the register_mutex
    protection over the whole snd_timer_close() function.  Also, the close
    procedure is slightly shuffled to be in the safer order, as well as a
    few code refactoring.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index dca817fc7894..b572a9bc31ad 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -318,25 +318,14 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 	if (snd_BUG_ON(!timeri))
 		return -ENXIO;
 
+	mutex_lock(&register_mutex);
+	list_del(&timeri->open_list);
+
 	/* force to stop the timer */
 	snd_timer_stop(timeri);
 
-	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
-		/* wait, until the active callback is finished */
-		spin_lock_irq(&slave_active_lock);
-		while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
-			spin_unlock_irq(&slave_active_lock);
-			udelay(10);
-			spin_lock_irq(&slave_active_lock);
-		}
-		spin_unlock_irq(&slave_active_lock);
-		mutex_lock(&register_mutex);
-		list_del(&timeri->open_list);
-		mutex_unlock(&register_mutex);
-	} else {
-		timer = timeri->timer;
-		if (snd_BUG_ON(!timer))
-			goto out;
+	timer = timeri->timer;
+	if (timer) {
 		/* wait, until the active callback is finished */
 		spin_lock_irq(&timer->lock);
 		while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
@@ -345,11 +334,7 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 			spin_lock_irq(&timer->lock);
 		}
 		spin_unlock_irq(&timer->lock);
-		mutex_lock(&register_mutex);
-		list_del(&timeri->open_list);
-		if (list_empty(&timer->open_list_head) &&
-		    timer->hw.close)
-			timer->hw.close(timer);
+
 		/* remove slave links */
 		spin_lock_irq(&slave_active_lock);
 		spin_lock(&timer->lock);
@@ -363,18 +348,27 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 		}
 		spin_unlock(&timer->lock);
 		spin_unlock_irq(&slave_active_lock);
-		/* release a card refcount for safe disconnection */
-		if (timer->card)
-			put_device(&timer->card->card_dev);
-		mutex_unlock(&register_mutex);
+
+		/* slave doesn't need to release timer resources below */
+		if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)
+			timer = NULL;
 	}
- out:
+
 	if (timeri->private_free)
 		timeri->private_free(timeri);
 	kfree(timeri->owner);
 	kfree(timeri);
-	if (timer)
+
+	if (timer) {
+		if (list_empty(&timer->open_list_head) && timer->hw.close)
+			timer->hw.close(timer);
+		/* release a card refcount for safe disconnection */
+		if (timer->card)
+			put_device(&timer->card->card_dev);
 		module_put(timer->module);
+	}
+
+	mutex_unlock(&register_mutex);
 	return 0;
 }
 

commit 4dff5c7b7093b19c19d3a100f8a3ad87cb7cd9e7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 8 17:26:58 2016 +0100

    ALSA: timer: Fix race at concurrent reads
    
    snd_timer_user_read() has a potential race among parallel reads, as
    qhead and qused are updated outside the critical section due to
    copy_to_user() calls.  Move them into the critical section, and also
    sanitize the relevant code a bit.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index a0405b0078c6..dca817fc7894 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1933,6 +1933,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 {
 	struct snd_timer_user *tu;
 	long result = 0, unit;
+	int qhead;
 	int err = 0;
 
 	tu = file->private_data;
@@ -1944,7 +1945,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 
 			if ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {
 				err = -EAGAIN;
-				break;
+				goto _error;
 			}
 
 			set_current_state(TASK_INTERRUPTIBLE);
@@ -1959,42 +1960,37 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 
 			if (tu->disconnected) {
 				err = -ENODEV;
-				break;
+				goto _error;
 			}
 			if (signal_pending(current)) {
 				err = -ERESTARTSYS;
-				break;
+				goto _error;
 			}
 		}
 
+		qhead = tu->qhead++;
+		tu->qhead %= tu->queue_size;
 		spin_unlock_irq(&tu->qlock);
-		if (err < 0)
-			goto _error;
 
 		if (tu->tread) {
-			if (copy_to_user(buffer, &tu->tqueue[tu->qhead++],
-					 sizeof(struct snd_timer_tread))) {
+			if (copy_to_user(buffer, &tu->tqueue[qhead],
+					 sizeof(struct snd_timer_tread)))
 				err = -EFAULT;
-				goto _error;
-			}
 		} else {
-			if (copy_to_user(buffer, &tu->queue[tu->qhead++],
-					 sizeof(struct snd_timer_read))) {
+			if (copy_to_user(buffer, &tu->queue[qhead],
+					 sizeof(struct snd_timer_read)))
 				err = -EFAULT;
-				goto _error;
-			}
 		}
 
-		tu->qhead %= tu->queue_size;
-
-		result += unit;
-		buffer += unit;
-
 		spin_lock_irq(&tu->qlock);
 		tu->qused--;
+		if (err < 0)
+			goto _error;
+		result += unit;
+		buffer += unit;
 	}
-	spin_unlock_irq(&tu->qlock);
  _error:
+	spin_unlock_irq(&tu->qlock);
 	return result > 0 ? result : err;
 }
 

commit ed8b1d6d2c741ab26d60d499d7fbb7ac801f0f51
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 9 12:02:32 2016 +0100

    ALSA: timer: Fix race between stop and interrupt
    
    A slave timer element also unlinks at snd_timer_stop() but it takes
    only slave_active_lock.  When a slave is assigned to a master,
    however, this may become a race against the master's interrupt
    handling, eventually resulting in a list corruption.  The actual bug
    could be seen with a syzkaller fuzzer test case in BugLink below.
    
    As a fix, we need to take timeri->timer->lock when timer isn't NULL,
    i.e. assigned to a master, while the assignment to a master itself is
    protected by slave_active_lock.
    
    BugLink: http://lkml.kernel.org/r/CACT4Y+Y_Bm+7epAb=8Wi=AaWd+DYS7qawX52qxdCfOfY49vozQ@mail.gmail.com
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index dea932ac6165..a0405b0078c6 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -518,9 +518,13 @@ static int _snd_timer_stop(struct snd_timer_instance *timeri, int event)
 			spin_unlock_irqrestore(&slave_active_lock, flags);
 			return -EBUSY;
 		}
+		if (timeri->timer)
+			spin_lock(&timeri->timer->lock);
 		timeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
 		list_del_init(&timeri->ack_list);
 		list_del_init(&timeri->active_list);
+		if (timeri->timer)
+			spin_unlock(&timeri->timer->lock);
 		spin_unlock_irqrestore(&slave_active_lock, flags);
 		goto __end;
 	}

commit 117159f0b9d392fb433a7871426fad50317f06f7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 8 17:36:25 2016 +0100

    ALSA: timer: Fix wrong instance passed to slave callbacks
    
    In snd_timer_notify1(), the wrong timer instance was passed for slave
    ccallback function.  This leads to the access to the wrong data when
    an incompatible master is handled (e.g. the master is the sequencer
    timer and the slave is a user timer), as spotted by syzkaller fuzzer.
    
    This patch fixes that wrong assignment.
    
    BugLink: http://lkml.kernel.org/r/CACT4Y+Y_Bm+7epAb=8Wi=AaWd+DYS7qawX52qxdCfOfY49vozQ@mail.gmail.com
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 9b513a05765a..dea932ac6165 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -422,7 +422,7 @@ static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 	spin_lock_irqsave(&timer->lock, flags);
 	list_for_each_entry(ts, &ti->slave_active_head, active_list)
 		if (ts->ccallback)
-			ts->ccallback(ti, event + 100, &tstamp, resolution);
+			ts->ccallback(ts, event + 100, &tstamp, resolution);
 	spin_unlock_irqrestore(&timer->lock, flags);
 }
 

commit 094fd3be87b0f102589e2d5c3fa5d06b7e20496d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 4 17:06:13 2016 +0100

    ALSA: timer: Fix leftover link at closing
    
    In ALSA timer core, the active timer instance is managed in
    active_list linked list.  Each element is added / removed dynamically
    at timer start, stop and in timer interrupt.  The problem is that
    snd_timer_interrupt() has a thinko and leaves the element in
    active_list when it's the last opened element.  This eventually leads
    to list corruption or use-after-free error.
    
    This hasn't been revealed because we used to delete the list forcibly
    in snd_timer_stop() in the past.  However, the recent fix avoids the
    double-stop behavior (in commit [f784beb75ce8: ALSA: timer: Fix link
    corruption due to double start or stop]), and this leak hits reality.
    
    This patch fixes the link management in snd_timer_interrupt().  Now it
    simply unlinks no matter which stream is.
    
    BugLink: http://lkml.kernel.org/r/CACT4Y+Yy2aukHP-EDp8-ziNqNNmb-NTf=jDWXMP7jB8HDa2vng@mail.gmail.com
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index b419e612f987..9b513a05765a 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -744,8 +744,8 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 			ti->cticks = ti->ticks;
 		} else {
 			ti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
-			if (--timer->running)
-				list_del_init(&ti->active_list);
+			--timer->running;
+			list_del_init(&ti->active_list);
 		}
 		if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||
 		    (ti->flags & SNDRV_TIMER_IFLG_FAST))

commit f146357f069e71aff8e474c625bcebcd3094b3ab
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 2 14:14:10 2016 +0100

    ALSA: timer: Sync timer deletion at closing the system timer
    
    ALSA timer core framework has no sync point at stopping because it's
    called inside the spinlock.  Thus we need a sync point at close for
    avoiding the stray timer task.  This is simply done by implementing
    the close callback just calling del_timer_sync().  (It's harmless to
    call it unconditionally, as the core timer itself cares of the already
    deleted timer instance.)
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 12db60dd147b..b419e612f987 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1058,11 +1058,21 @@ static int snd_timer_s_stop(struct snd_timer * timer)
 	return 0;
 }
 
+static int snd_timer_s_close(struct snd_timer *timer)
+{
+	struct snd_timer_system_private *priv;
+
+	priv = (struct snd_timer_system_private *)timer->private_data;
+	del_timer_sync(&priv->tlist);
+	return 0;
+}
+
 static struct snd_timer_hardware snd_timer_system =
 {
 	.flags =	SNDRV_TIMER_HW_FIRST | SNDRV_TIMER_HW_TASKLET,
 	.resolution =	1000000000L / HZ,
 	.ticks =	10000000L,
+	.close =	snd_timer_s_close,
 	.start =	snd_timer_s_start,
 	.stop =		snd_timer_s_stop
 };

commit f784beb75ce82f4136f8a0960d3ee872f7109e09
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat Jan 30 23:09:08 2016 +0100

    ALSA: timer: Fix link corruption due to double start or stop
    
    Although ALSA timer code got hardening for races, it still causes
    use-after-free error.  This is however rather a corrupted linked list,
    not actually the concurrent accesses.  Namely, when timer start is
    triggered twice, list_add_tail() is called twice, too.  This ends
    up with the link corruption and triggers KASAN error.
    
    The simplest fix would be replacing list_add_tail() with
    list_move_tail(), but fundamentally it's the problem that we don't
    check the double start/stop correctly.  So, the right fix here is to
    add the proper checks to snd_timer_start() and snd_timer_stop() (and
    their variants).
    
    BugLink: http://lkml.kernel.org/r/CACT4Y+ZyPRoMQjmawbvmCEDrkBD2BQuH7R09=eOkf5ESK8kJAw@mail.gmail.com
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index af1f68f7e315..12db60dd147b 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -451,6 +451,10 @@ static int snd_timer_start_slave(struct snd_timer_instance *timeri)
 	unsigned long flags;
 
 	spin_lock_irqsave(&slave_active_lock, flags);
+	if (timeri->flags & SNDRV_TIMER_IFLG_RUNNING) {
+		spin_unlock_irqrestore(&slave_active_lock, flags);
+		return -EBUSY;
+	}
 	timeri->flags |= SNDRV_TIMER_IFLG_RUNNING;
 	if (timeri->master && timeri->timer) {
 		spin_lock(&timeri->timer->lock);
@@ -475,7 +479,8 @@ int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)
 		return -EINVAL;
 	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
 		result = snd_timer_start_slave(timeri);
-		snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);
+		if (result >= 0)
+			snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);
 		return result;
 	}
 	timer = timeri->timer;
@@ -484,11 +489,18 @@ int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)
 	if (timer->card && timer->card->shutdown)
 		return -ENODEV;
 	spin_lock_irqsave(&timer->lock, flags);
+	if (timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |
+			     SNDRV_TIMER_IFLG_START)) {
+		result = -EBUSY;
+		goto unlock;
+	}
 	timeri->ticks = timeri->cticks = ticks;
 	timeri->pticks = 0;
 	result = snd_timer_start1(timer, timeri, ticks);
+ unlock:
 	spin_unlock_irqrestore(&timer->lock, flags);
-	snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);
+	if (result >= 0)
+		snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);
 	return result;
 }
 
@@ -502,6 +514,10 @@ static int _snd_timer_stop(struct snd_timer_instance *timeri, int event)
 
 	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
 		spin_lock_irqsave(&slave_active_lock, flags);
+		if (!(timeri->flags & SNDRV_TIMER_IFLG_RUNNING)) {
+			spin_unlock_irqrestore(&slave_active_lock, flags);
+			return -EBUSY;
+		}
 		timeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
 		list_del_init(&timeri->ack_list);
 		list_del_init(&timeri->active_list);
@@ -512,6 +528,11 @@ static int _snd_timer_stop(struct snd_timer_instance *timeri, int event)
 	if (!timer)
 		return -EINVAL;
 	spin_lock_irqsave(&timer->lock, flags);
+	if (!(timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |
+			       SNDRV_TIMER_IFLG_START))) {
+		spin_unlock_irqrestore(&timer->lock, flags);
+		return -EBUSY;
+	}
 	list_del_init(&timeri->ack_list);
 	list_del_init(&timeri->active_list);
 	if (timer->card && timer->card->shutdown) {
@@ -581,10 +602,15 @@ int snd_timer_continue(struct snd_timer_instance *timeri)
 	if (timer->card && timer->card->shutdown)
 		return -ENODEV;
 	spin_lock_irqsave(&timer->lock, flags);
+	if (timeri->flags & SNDRV_TIMER_IFLG_RUNNING) {
+		result = -EBUSY;
+		goto unlock;
+	}
 	if (!timeri->cticks)
 		timeri->cticks = 1;
 	timeri->pticks = 0;
 	result = snd_timer_start1(timer, timeri, timer->sticks);
+ unlock:
 	spin_unlock_irqrestore(&timer->lock, flags);
 	snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_CONTINUE);
 	return result;

commit 40ed9444cd2421cceedb35bb8d8ff913a5ae1ac3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 21 17:43:08 2016 +0100

    ALSA: timer: Introduce disconnect op to snd_timer_instance
    
    Instead of the previous ugly hack, introduce a new op, disconnect, to
    snd_timer_instance object for handling the wake up of pending tasks
    more cleanly.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=109431
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 681fb051b9eb..af1f68f7e315 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -899,11 +899,6 @@ static int snd_timer_dev_register(struct snd_device *dev)
 	return 0;
 }
 
-/* just for reference in snd_timer_dev_disconnect() below */
-static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,
-				     int event, struct timespec *tstamp,
-				     unsigned long resolution);
-
 static int snd_timer_dev_disconnect(struct snd_device *device)
 {
 	struct snd_timer *timer = device->device_data;
@@ -913,13 +908,8 @@ static int snd_timer_dev_disconnect(struct snd_device *device)
 	list_del_init(&timer->device_list);
 	/* wake up pending sleepers */
 	list_for_each_entry(ti, &timer->open_list_head, open_list) {
-		/* FIXME: better to have a ti.disconnect() op */
-		if (ti->ccallback == snd_timer_user_ccallback) {
-			struct snd_timer_user *tu = ti->callback_data;
-
-			tu->disconnected = true;
-			wake_up(&tu->qchange_sleep);
-		}
+		if (ti->disconnect)
+			ti->disconnect(ti);
 	}
 	mutex_unlock(&register_mutex);
 	return 0;
@@ -1227,6 +1217,14 @@ static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,
 	wake_up(&tu->qchange_sleep);
 }
 
+static void snd_timer_user_disconnect(struct snd_timer_instance *timeri)
+{
+	struct snd_timer_user *tu = timeri->callback_data;
+
+	tu->disconnected = true;
+	wake_up(&tu->qchange_sleep);
+}
+
 static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 				      unsigned long resolution,
 				      unsigned long ticks)
@@ -1600,6 +1598,7 @@ static int snd_timer_user_tselect(struct file *file,
 			? snd_timer_user_tinterrupt : snd_timer_user_interrupt;
 		tu->timeri->ccallback = snd_timer_user_ccallback;
 		tu->timeri->callback_data = (void *)tu;
+		tu->timeri->disconnect = snd_timer_user_disconnect;
 	}
 
       __err:

commit 230323dac060123c340cf75997971145a42661ee
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 21 17:19:31 2016 +0100

    ALSA: timer: Handle disconnection more safely
    
    Currently ALSA timer device doesn't take the disconnection into
    account very well; it merely unlinks the timer device at disconnection
    callback but does nothing else.  Because of this, when an application
    accessing the timer device is disconnected, it may release the
    resource before actually closed.  In most cases, it results in a
    warning message indicating a leftover timer instance like:
       ALSA: timer xxxx is busy?
    But basically this is an open race.
    
    This patch tries to address it.  The strategy is like other ALSA
    devices: namely,
    - Manage card's refcount at each open/close
    - Wake up the pending tasks at disconnection
    - Check the shutdown flag appropriately at each possible call
    
    Note that this patch has one ugly hack to handle the wakeup of pending
    tasks.  It'd be cleaner to introduce a new disconnect op to
    snd_timer_instance ops.  But since it would lead to internal ABI
    breakage and it eventually increase my own work when backporting to
    stable kernels, I took a different path to implement locally in
    timer.c.  A cleanup patch will follow at next for 4.5 kernel.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=109431
    Cc: <stable@vger.kernel.org> # v3.15+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index cb25aded5349..681fb051b9eb 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -65,6 +65,7 @@ struct snd_timer_user {
 	int qtail;
 	int qused;
 	int queue_size;
+	bool disconnected;
 	struct snd_timer_read *queue;
 	struct snd_timer_tread *tqueue;
 	spinlock_t qlock;
@@ -290,6 +291,9 @@ int snd_timer_open(struct snd_timer_instance **ti,
 		mutex_unlock(&register_mutex);
 		return -ENOMEM;
 	}
+	/* take a card refcount for safe disconnection */
+	if (timer->card)
+		get_device(&timer->card->card_dev);
 	timeri->slave_class = tid->dev_sclass;
 	timeri->slave_id = slave_id;
 	if (list_empty(&timer->open_list_head) && timer->hw.open)
@@ -359,6 +363,9 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 		}
 		spin_unlock(&timer->lock);
 		spin_unlock_irq(&slave_active_lock);
+		/* release a card refcount for safe disconnection */
+		if (timer->card)
+			put_device(&timer->card->card_dev);
 		mutex_unlock(&register_mutex);
 	}
  out:
@@ -474,6 +481,8 @@ int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)
 	timer = timeri->timer;
 	if (timer == NULL)
 		return -EINVAL;
+	if (timer->card && timer->card->shutdown)
+		return -ENODEV;
 	spin_lock_irqsave(&timer->lock, flags);
 	timeri->ticks = timeri->cticks = ticks;
 	timeri->pticks = 0;
@@ -505,6 +514,10 @@ static int _snd_timer_stop(struct snd_timer_instance *timeri, int event)
 	spin_lock_irqsave(&timer->lock, flags);
 	list_del_init(&timeri->ack_list);
 	list_del_init(&timeri->active_list);
+	if (timer->card && timer->card->shutdown) {
+		spin_unlock_irqrestore(&timer->lock, flags);
+		return 0;
+	}
 	if ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&
 	    !(--timer->running)) {
 		timer->hw.stop(timer);
@@ -565,6 +578,8 @@ int snd_timer_continue(struct snd_timer_instance *timeri)
 	timer = timeri->timer;
 	if (! timer)
 		return -EINVAL;
+	if (timer->card && timer->card->shutdown)
+		return -ENODEV;
 	spin_lock_irqsave(&timer->lock, flags);
 	if (!timeri->cticks)
 		timeri->cticks = 1;
@@ -628,6 +643,9 @@ static void snd_timer_tasklet(unsigned long arg)
 	unsigned long resolution, ticks;
 	unsigned long flags;
 
+	if (timer->card && timer->card->shutdown)
+		return;
+
 	spin_lock_irqsave(&timer->lock, flags);
 	/* now process all callbacks */
 	while (!list_empty(&timer->sack_list_head)) {
@@ -668,6 +686,9 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 	if (timer == NULL)
 		return;
 
+	if (timer->card && timer->card->shutdown)
+		return;
+
 	spin_lock_irqsave(&timer->lock, flags);
 
 	/* remember the current resolution */
@@ -878,11 +899,28 @@ static int snd_timer_dev_register(struct snd_device *dev)
 	return 0;
 }
 
+/* just for reference in snd_timer_dev_disconnect() below */
+static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,
+				     int event, struct timespec *tstamp,
+				     unsigned long resolution);
+
 static int snd_timer_dev_disconnect(struct snd_device *device)
 {
 	struct snd_timer *timer = device->device_data;
+	struct snd_timer_instance *ti;
+
 	mutex_lock(&register_mutex);
 	list_del_init(&timer->device_list);
+	/* wake up pending sleepers */
+	list_for_each_entry(ti, &timer->open_list_head, open_list) {
+		/* FIXME: better to have a ti.disconnect() op */
+		if (ti->ccallback == snd_timer_user_ccallback) {
+			struct snd_timer_user *tu = ti->callback_data;
+
+			tu->disconnected = true;
+			wake_up(&tu->qchange_sleep);
+		}
+	}
 	mutex_unlock(&register_mutex);
 	return 0;
 }
@@ -893,6 +931,8 @@ void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstam
 	unsigned long resolution = 0;
 	struct snd_timer_instance *ti, *ts;
 
+	if (timer->card && timer->card->shutdown)
+		return;
 	if (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))
 		return;
 	if (snd_BUG_ON(event < SNDRV_TIMER_EVENT_MSTART ||
@@ -1051,6 +1091,8 @@ static void snd_timer_proc_read(struct snd_info_entry *entry,
 
 	mutex_lock(&register_mutex);
 	list_for_each_entry(timer, &snd_timer_list, device_list) {
+		if (timer->card && timer->card->shutdown)
+			continue;
 		switch (timer->tmr_class) {
 		case SNDRV_TIMER_CLASS_GLOBAL:
 			snd_iprintf(buffer, "G%i: ", timer->tmr_device);
@@ -1876,6 +1918,10 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 
 			remove_wait_queue(&tu->qchange_sleep, &wait);
 
+			if (tu->disconnected) {
+				err = -ENODEV;
+				break;
+			}
 			if (signal_pending(current)) {
 				err = -ERESTARTSYS;
 				break;
@@ -1925,6 +1971,8 @@ static unsigned int snd_timer_user_poll(struct file *file, poll_table * wait)
 	mask = 0;
 	if (tu->qused)
 		mask |= POLLIN | POLLRDNORM;
+	if (tu->disconnected)
+		mask |= POLLERR;
 
 	return mask;
 }

commit c3b1681375dc6e71d89a3ae00cc3ce9e775a8917
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 14 17:01:46 2016 +0100

    ALSA: timer: Code cleanup
    
    This is a minor code cleanup without any functional changes:
    - Kill keep_flag argument from _snd_timer_stop(), as all callers pass
      only it false.
    - Remove redundant NULL check in _snd_timer_stop().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 4e8d7bfffff6..cb25aded5349 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -301,8 +301,7 @@ int snd_timer_open(struct snd_timer_instance **ti,
 	return 0;
 }
 
-static int _snd_timer_stop(struct snd_timer_instance *timeri,
-			   int keep_flag, int event);
+static int _snd_timer_stop(struct snd_timer_instance *timeri, int event);
 
 /*
  * close a timer instance
@@ -344,7 +343,7 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 		spin_unlock_irq(&timer->lock);
 		mutex_lock(&register_mutex);
 		list_del(&timeri->open_list);
-		if (timer && list_empty(&timer->open_list_head) &&
+		if (list_empty(&timer->open_list_head) &&
 		    timer->hw.close)
 			timer->hw.close(timer);
 		/* remove slave links */
@@ -484,8 +483,7 @@ int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)
 	return result;
 }
 
-static int _snd_timer_stop(struct snd_timer_instance * timeri,
-			   int keep_flag, int event)
+static int _snd_timer_stop(struct snd_timer_instance *timeri, int event)
 {
 	struct snd_timer *timer;
 	unsigned long flags;
@@ -494,13 +492,11 @@ static int _snd_timer_stop(struct snd_timer_instance * timeri,
 		return -ENXIO;
 
 	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
-		if (!keep_flag) {
-			spin_lock_irqsave(&slave_active_lock, flags);
-			timeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
-			list_del_init(&timeri->ack_list);
-			list_del_init(&timeri->active_list);
-			spin_unlock_irqrestore(&slave_active_lock, flags);
-		}
+		spin_lock_irqsave(&slave_active_lock, flags);
+		timeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
+		list_del_init(&timeri->ack_list);
+		list_del_init(&timeri->active_list);
+		spin_unlock_irqrestore(&slave_active_lock, flags);
 		goto __end;
 	}
 	timer = timeri->timer;
@@ -521,9 +517,7 @@ static int _snd_timer_stop(struct snd_timer_instance * timeri,
 			}
 		}
 	}
-	if (!keep_flag)
-		timeri->flags &=
-			~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);
+	timeri->flags &= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);
 	spin_unlock_irqrestore(&timer->lock, flags);
       __end:
 	if (event != SNDRV_TIMER_EVENT_RESOLUTION)
@@ -542,7 +536,7 @@ int snd_timer_stop(struct snd_timer_instance *timeri)
 	unsigned long flags;
 	int err;
 
-	err = _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_STOP);
+	err = _snd_timer_stop(timeri, SNDRV_TIMER_EVENT_STOP);
 	if (err < 0)
 		return err;
 	timer = timeri->timer;
@@ -586,7 +580,7 @@ int snd_timer_continue(struct snd_timer_instance *timeri)
  */
 int snd_timer_pause(struct snd_timer_instance * timeri)
 {
-	return _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_PAUSE);
+	return _snd_timer_stop(timeri, SNDRV_TIMER_EVENT_PAUSE);
 }
 
 /*

commit b5a663aa426f4884c71cd8580adae73f33570f0d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 14 16:30:58 2016 +0100

    ALSA: timer: Harden slave timer list handling
    
    A slave timer instance might be still accessible in a racy way while
    operating the master instance as it lacks of locking.  Since the
    master operation is mostly protected with timer->lock, we should cope
    with it while changing the slave instance, too.  Also, some linked
    lists (active_list and ack_list) of slave instances aren't unlinked
    immediately at stopping or closing, and this may lead to unexpected
    accesses.
    
    This patch tries to address these issues.  It adds spin lock of
    timer->lock (either from master or slave, which is equivalent) in a
    few places.  For avoiding a deadlock, we ensure that the global
    slave_active_lock is always locked at first before each timer lock.
    
    Also, ack and active_list of slave instances are properly unlinked at
    snd_timer_stop() and snd_timer_close().
    
    Last but not least, remove the superfluous call of _snd_timer_stop()
    at removing slave links.  This is a noop, and calling it may confuse
    readers wrt locking.  Further cleanup will follow in a later patch.
    
    Actually we've got reports of use-after-free by syzkaller fuzzer, and
    this hopefully fixes these issues.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 3810ee8f1205..4e8d7bfffff6 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -215,11 +215,13 @@ static void snd_timer_check_master(struct snd_timer_instance *master)
 		    slave->slave_id == master->slave_id) {
 			list_move_tail(&slave->open_list, &master->slave_list_head);
 			spin_lock_irq(&slave_active_lock);
+			spin_lock(&master->timer->lock);
 			slave->master = master;
 			slave->timer = master->timer;
 			if (slave->flags & SNDRV_TIMER_IFLG_RUNNING)
 				list_add_tail(&slave->active_list,
 					      &master->slave_active_head);
+			spin_unlock(&master->timer->lock);
 			spin_unlock_irq(&slave_active_lock);
 		}
 	}
@@ -346,15 +348,18 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 		    timer->hw.close)
 			timer->hw.close(timer);
 		/* remove slave links */
+		spin_lock_irq(&slave_active_lock);
+		spin_lock(&timer->lock);
 		list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,
 					 open_list) {
-			spin_lock_irq(&slave_active_lock);
-			_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);
 			list_move_tail(&slave->open_list, &snd_timer_slave_list);
 			slave->master = NULL;
 			slave->timer = NULL;
-			spin_unlock_irq(&slave_active_lock);
+			list_del_init(&slave->ack_list);
+			list_del_init(&slave->active_list);
 		}
+		spin_unlock(&timer->lock);
+		spin_unlock_irq(&slave_active_lock);
 		mutex_unlock(&register_mutex);
 	}
  out:
@@ -441,9 +446,12 @@ static int snd_timer_start_slave(struct snd_timer_instance *timeri)
 
 	spin_lock_irqsave(&slave_active_lock, flags);
 	timeri->flags |= SNDRV_TIMER_IFLG_RUNNING;
-	if (timeri->master)
+	if (timeri->master && timeri->timer) {
+		spin_lock(&timeri->timer->lock);
 		list_add_tail(&timeri->active_list,
 			      &timeri->master->slave_active_head);
+		spin_unlock(&timeri->timer->lock);
+	}
 	spin_unlock_irqrestore(&slave_active_lock, flags);
 	return 1; /* delayed start */
 }
@@ -489,6 +497,8 @@ static int _snd_timer_stop(struct snd_timer_instance * timeri,
 		if (!keep_flag) {
 			spin_lock_irqsave(&slave_active_lock, flags);
 			timeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
+			list_del_init(&timeri->ack_list);
+			list_del_init(&timeri->active_list);
 			spin_unlock_irqrestore(&slave_active_lock, flags);
 		}
 		goto __end;

commit af368027a49a751d6ff4ee9e3f9961f35bb4fede
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 13 17:48:01 2016 +0100

    ALSA: timer: Fix race among timer ioctls
    
    ALSA timer ioctls have an open race and this may lead to a
    use-after-free of timer instance object.  A simplistic fix is to make
    each ioctl exclusive.  We have already tread_sem for controlling the
    tread, and extend this as a global mutex to be applied to each ioctl.
    
    The downside is, of course, the worse concurrency.  But these ioctls
    aren't to be parallel accessible, in anyway, so it should be fine to
    serialize there.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 9241784dfe7d..3810ee8f1205 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -73,7 +73,7 @@ struct snd_timer_user {
 	struct timespec tstamp;		/* trigger tstamp */
 	wait_queue_head_t qchange_sleep;
 	struct fasync_struct *fasync;
-	struct mutex tread_sem;
+	struct mutex ioctl_lock;
 };
 
 /* list of timers */
@@ -1253,7 +1253,7 @@ static int snd_timer_user_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 	spin_lock_init(&tu->qlock);
 	init_waitqueue_head(&tu->qchange_sleep);
-	mutex_init(&tu->tread_sem);
+	mutex_init(&tu->ioctl_lock);
 	tu->ticks = 1;
 	tu->queue_size = 128;
 	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
@@ -1273,8 +1273,10 @@ static int snd_timer_user_release(struct inode *inode, struct file *file)
 	if (file->private_data) {
 		tu = file->private_data;
 		file->private_data = NULL;
+		mutex_lock(&tu->ioctl_lock);
 		if (tu->timeri)
 			snd_timer_close(tu->timeri);
+		mutex_unlock(&tu->ioctl_lock);
 		kfree(tu->queue);
 		kfree(tu->tqueue);
 		kfree(tu);
@@ -1512,7 +1514,6 @@ static int snd_timer_user_tselect(struct file *file,
 	int err = 0;
 
 	tu = file->private_data;
-	mutex_lock(&tu->tread_sem);
 	if (tu->timeri) {
 		snd_timer_close(tu->timeri);
 		tu->timeri = NULL;
@@ -1556,7 +1557,6 @@ static int snd_timer_user_tselect(struct file *file,
 	}
 
       __err:
-      	mutex_unlock(&tu->tread_sem);
 	return err;
 }
 
@@ -1769,7 +1769,7 @@ enum {
 	SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),
 };
 
-static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
+static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 				 unsigned long arg)
 {
 	struct snd_timer_user *tu;
@@ -1786,17 +1786,11 @@ static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 	{
 		int xarg;
 
-		mutex_lock(&tu->tread_sem);
-		if (tu->timeri)	{	/* too late */
-			mutex_unlock(&tu->tread_sem);
+		if (tu->timeri)	/* too late */
 			return -EBUSY;
-		}
-		if (get_user(xarg, p)) {
-			mutex_unlock(&tu->tread_sem);
+		if (get_user(xarg, p))
 			return -EFAULT;
-		}
 		tu->tread = xarg ? 1 : 0;
-		mutex_unlock(&tu->tread_sem);
 		return 0;
 	}
 	case SNDRV_TIMER_IOCTL_GINFO:
@@ -1829,6 +1823,18 @@ static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 	return -ENOTTY;
 }
 
+static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
+				 unsigned long arg)
+{
+	struct snd_timer_user *tu = file->private_data;
+	long ret;
+
+	mutex_lock(&tu->ioctl_lock);
+	ret = __snd_timer_user_ioctl(file, cmd, arg);
+	mutex_unlock(&tu->ioctl_lock);
+	return ret;
+}
+
 static int snd_timer_user_fasync(int fd, struct file * file, int on)
 {
 	struct snd_timer_user *tu;

commit ee8413b01045c74340aa13ad5bdf905de32be736
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 13 21:35:06 2016 +0100

    ALSA: timer: Fix double unlink of active_list
    
    ALSA timer instance object has a couple of linked lists and they are
    unlinked unconditionally at snd_timer_stop().  Meanwhile
    snd_timer_interrupt() unlinks it, but it calls list_del() which leaves
    the element list itself unchanged.  This ends up with unlinking twice,
    and it was caught by syzkaller fuzzer.
    
    The fix is to use list_del_init() variant properly there, too.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 31f40f03e5b7..9241784dfe7d 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -694,7 +694,7 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 		} else {
 			ti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
 			if (--timer->running)
-				list_del(&ti->active_list);
+				list_del_init(&ti->active_list);
 		}
 		if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||
 		    (ti->flags & SNDRV_TIMER_IFLG_FAST))

commit cd6a65036f0eac4ad83dc371bb458e9e6ba6e306
Author: Jie Yang <yang.jie@intel.com>
Date:   Wed May 27 19:45:45 2015 +0800

    ALSA: replace CONFIG_PROC_FS with CONFIG_SND_PROC_FS
    
    We may disable proc fs only for sound part, to reduce ALSA
    memory footprint. So add CONFIG_SND_PROC_FS and replace the
    old CONFIG_PROC_FSs in alsa code.
    
    With sound proc fs disabled, we can save about 9KB memory
    size on X86_64 platform.
    
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index a9a1a047c521..31f40f03e5b7 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1034,7 +1034,7 @@ static int snd_timer_register_system(void)
 	return snd_timer_global_register(timer);
 }
 
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_SND_PROC_FS
 /*
  *  Info interface
  */
@@ -1104,7 +1104,7 @@ static void __exit snd_timer_proc_done(void)
 {
 	snd_info_free_entry(snd_timer_proc_entry);
 }
-#else /* !CONFIG_PROC_FS */
+#else /* !CONFIG_SND_PROC_FS */
 #define snd_timer_proc_init()
 #define snd_timer_proc_done()
 #endif

commit ec0e9937aaa8b0a4b0633711c4d70d622acd9a7f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 10 15:42:14 2015 +0100

    ALSA: core: Drop superfluous error/debug messages after malloc failures
    
    The kernel memory allocators already report the errors when the
    requested allocation fails, thus we don't need to warn it again in
    each caller side.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 490b489d713d..a9a1a047c521 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -774,10 +774,8 @@ int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,
 	if (rtimer)
 		*rtimer = NULL;
 	timer = kzalloc(sizeof(*timer), GFP_KERNEL);
-	if (timer == NULL) {
-		pr_err("ALSA: timer: cannot allocate\n");
+	if (!timer)
 		return -ENOMEM;
-	}
 	timer->tmr_class = tid->dev_class;
 	timer->card = card;
 	timer->tmr_device = tid->device;

commit 3fe9cf390f6dc84f76b112b0a660967a84f9a81b
Merge: 6ccd93bdb989 830953c0724b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 3 17:57:16 2015 +0100

    Merge branch 'topic/snd-device' into for-next

commit 40a4b263854346fe7c7d1c3964c106296f690816
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 30 08:34:58 2015 +0100

    ALSA: Simplify snd_device_register() variants
    
    Now that all callers have been replaced with
    snd_device_register_for_dev(), let's drop the obsolete device
    registration code and concentrate only on the code handling struct
    device directly.  That said,
    
    - remove the old snd_device_register(),
    - rename snd_device_register_for_dev() with snd_device_register(),
    - drop superfluous arguments from snd_device_register(),
    - change snd_unregister_device() to pass the device pointer directly
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index dae40ac11e04..9f0c703ef081 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1976,9 +1976,8 @@ static int __init alsa_timer_init(void)
 		return err;
 	}
 
-	err = snd_register_device_for_dev(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,
-					  &snd_timer_f_ops, NULL,
-					  &timer_dev, NULL, NULL);
+	err = snd_register_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,
+				  &snd_timer_f_ops, NULL, &timer_dev);
 	if (err < 0) {
 		pr_err("ALSA: unable to register timer device (%i)\n", err);
 		snd_timer_free_all();
@@ -1992,7 +1991,7 @@ static int __init alsa_timer_init(void)
 
 static void __exit alsa_timer_exit(void)
 {
-	snd_unregister_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0);
+	snd_unregister_device(&timer_dev);
 	snd_timer_free_all();
 	put_device(&timer_dev);
 	snd_timer_proc_done();

commit 89da061f0a556f1324d8ac84f1012107bf08d2e1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 29 18:12:26 2015 +0100

    ALSA: timer: Handle the device directly
    
    This is a relatively straightforward change, using the struct device
    directly for managing the ALSA timer device.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 28b673d4f812..dae40ac11e04 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1951,6 +1951,8 @@ static void snd_timer_free_all(void)
 		snd_timer_free(timer);
 }
 
+static struct device timer_dev;
+
 /*
  *  ENTRY functions
  */
@@ -1959,6 +1961,9 @@ static int __init alsa_timer_init(void)
 {
 	int err;
 
+	snd_device_initialize(&timer_dev, NULL);
+	dev_set_name(&timer_dev, "timer");
+
 #ifdef SNDRV_OSS_INFO_DEV_TIMERS
 	snd_oss_info_register(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1,
 			      "system timer");
@@ -1967,14 +1972,17 @@ static int __init alsa_timer_init(void)
 	err = snd_timer_register_system();
 	if (err < 0) {
 		pr_err("ALSA: unable to register system timer (%i)\n", err);
+		put_device(&timer_dev);
 		return err;
 	}
 
-	err = snd_register_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,
-				  &snd_timer_f_ops, NULL, "timer");
+	err = snd_register_device_for_dev(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,
+					  &snd_timer_f_ops, NULL,
+					  &timer_dev, NULL, NULL);
 	if (err < 0) {
 		pr_err("ALSA: unable to register timer device (%i)\n", err);
 		snd_timer_free_all();
+		put_device(&timer_dev);
 		return err;
 	}
 
@@ -1986,6 +1994,7 @@ static void __exit alsa_timer_exit(void)
 {
 	snd_unregister_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0);
 	snd_timer_free_all();
+	put_device(&timer_dev);
 	snd_timer_proc_done();
 #ifdef SNDRV_OSS_INFO_DEV_TIMERS
 	snd_oss_info_unregister(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1);

commit 7c35860d1ae555a040f561c7cfdde066053787f0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 29 18:09:05 2015 +0100

    ALSA: timer: Propagate the error at initialization
    
    ... instead of just printing errors.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 777a45e08e53..28b673d4f812 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1942,6 +1942,15 @@ static const struct file_operations snd_timer_f_ops =
 	.fasync = 	snd_timer_user_fasync,
 };
 
+/* unregister the system timer */
+static void snd_timer_free_all(void)
+{
+	struct snd_timer *timer, *n;
+
+	list_for_each_entry_safe(timer, n, &snd_timer_list, device_list)
+		snd_timer_free(timer);
+}
+
 /*
  *  ENTRY functions
  */
@@ -1955,25 +1964,28 @@ static int __init alsa_timer_init(void)
 			      "system timer");
 #endif
 
-	if ((err = snd_timer_register_system()) < 0)
+	err = snd_timer_register_system();
+	if (err < 0) {
 		pr_err("ALSA: unable to register system timer (%i)\n", err);
-	if ((err = snd_register_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,
-				       &snd_timer_f_ops, NULL, "timer")) < 0)
+		return err;
+	}
+
+	err = snd_register_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,
+				  &snd_timer_f_ops, NULL, "timer");
+	if (err < 0) {
 		pr_err("ALSA: unable to register timer device (%i)\n", err);
+		snd_timer_free_all();
+		return err;
+	}
+
 	snd_timer_proc_init();
 	return 0;
 }
 
 static void __exit alsa_timer_exit(void)
 {
-	struct list_head *p, *n;
-
 	snd_unregister_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0);
-	/* unregister the system timer */
-	list_for_each_safe(p, n, &snd_timer_list) {
-		struct snd_timer *timer = list_entry(p, struct snd_timer, device_list);
-		snd_timer_free(timer);
-	}
+	snd_timer_free_all();
 	snd_timer_proc_done();
 #ifdef SNDRV_OSS_INFO_DEV_TIMERS
 	snd_oss_info_unregister(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1);

commit f169c10597bd55125fc5c9d0c63b8ebf6dd6b5b2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 11:26:25 2015 +0100

    ALSA: timer: Use setup_timer() and mod_timer()
    
    No functional change, refactoring with the standard helpers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 777a45e08e53..a44235555896 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1030,9 +1030,7 @@ static int snd_timer_register_system(void)
 		snd_timer_free(timer);
 		return -ENOMEM;
 	}
-	init_timer(&priv->tlist);
-	priv->tlist.function = snd_timer_s_function;
-	priv->tlist.data = (unsigned long) timer;
+	setup_timer(&priv->tlist, snd_timer_s_function, (unsigned long) timer);
 	timer->private_data = priv;
 	timer->private_free = snd_timer_free_system;
 	return snd_timer_global_register(timer);

commit 26204e048d2ee0c65e0539f7cc2b66f845a19a41
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jun 11 23:59:14 2014 +0000

    ALSA: core: Use ktime_get_ts()
    
    do_posix_clock_monotonic_gettime() is a leftover from the initial
    posix timer implementation which maps to ktime_get_ts().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index cfd455a8ac1a..777a45e08e53 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -390,7 +390,7 @@ static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 	struct timespec tstamp;
 
 	if (timer_tstamp_monotonic)
-		do_posix_clock_monotonic_gettime(&tstamp);
+		ktime_get_ts(&tstamp);
 	else
 		getnstimeofday(&tstamp);
 	if (snd_BUG_ON(event < SNDRV_TIMER_EVENT_START ||
@@ -1203,7 +1203,7 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 	}
 	if (tu->last_resolution != resolution || ticks > 0) {
 		if (timer_tstamp_monotonic)
-			do_posix_clock_monotonic_gettime(&tstamp);
+			ktime_get_ts(&tstamp);
 		else
 			getnstimeofday(&tstamp);
 	}

commit cf74dcf3512271bca4bb5fe79274ad23c22f5dd3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:22:39 2014 +0100

    ALSA: timer: Use standard printk helpers
    
    Use the standard pr_xxx() helpers instead of home-baked snd_print*().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index cbec51464c5b..cfd455a8ac1a 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -240,7 +240,8 @@ int snd_timer_open(struct snd_timer_instance **ti,
 		/* open a slave instance */
 		if (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||
 		    tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {
-			snd_printd("invalid slave class %i\n", tid->dev_sclass);
+			pr_debug("ALSA: timer: invalid slave class %i\n",
+				 tid->dev_sclass);
 			return -EINVAL;
 		}
 		mutex_lock(&register_mutex);
@@ -774,7 +775,7 @@ int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,
 		*rtimer = NULL;
 	timer = kzalloc(sizeof(*timer), GFP_KERNEL);
 	if (timer == NULL) {
-		snd_printk(KERN_ERR "timer: cannot allocate\n");
+		pr_err("ALSA: timer: cannot allocate\n");
 		return -ENOMEM;
 	}
 	timer->tmr_class = tid->dev_class;
@@ -813,7 +814,7 @@ static int snd_timer_free(struct snd_timer *timer)
 	if (! list_empty(&timer->open_list_head)) {
 		struct list_head *p, *n;
 		struct snd_timer_instance *ti;
-		snd_printk(KERN_WARNING "timer %p is busy?\n", timer);
+		pr_warn("ALSA: timer %p is busy?\n", timer);
 		list_for_each_safe(p, n, &timer->open_list_head) {
 			list_del_init(p);
 			ti = list_entry(p, struct snd_timer_instance, open_list);
@@ -1955,12 +1956,10 @@ static int __init alsa_timer_init(void)
 #endif
 
 	if ((err = snd_timer_register_system()) < 0)
-		snd_printk(KERN_ERR "unable to register system timer (%i)\n",
-			   err);
+		pr_err("ALSA: unable to register system timer (%i)\n", err);
 	if ((err = snd_register_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,
 				       &snd_timer_f_ops, NULL, "timer")) < 0)
-		snd_printk(KERN_ERR "unable to register timer device (%i)\n",
-			   err);
+		pr_err("ALSA: unable to register timer device (%i)\n", err);
 	snd_timer_proc_init();
 	return 0;
 }

commit 8eeaa2f9e06dcfb45593a0fcd91e81abc7f5d209
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 10 09:48:47 2014 +0100

    ALSA: Replace with IS_ENABLED()
    
    Replace the lengthy #if defined(XXX) || defined(XXX_MODULE) with the
    new IS_ENABLED() macro.
    
    The patch still doesn't cover all ifdefs.  For example, the dependency
    on CONFIG_GAMEPORT is still open-coded because this also has an extra
    dependency on MODULE.  Similarly, an open-coded ifdef in pcm_oss.c and
    some sequencer-related stuff are left untouched.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 6ddcf06f52f9..cbec51464c5b 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -35,9 +35,9 @@
 #include <sound/initval.h>
 #include <linux/kmod.h>
 
-#if defined(CONFIG_SND_HRTIMER) || defined(CONFIG_SND_HRTIMER_MODULE)
+#if IS_ENABLED(CONFIG_SND_HRTIMER)
 #define DEFAULT_TIMER_LIMIT 4
-#elif defined(CONFIG_SND_RTCTIMER) || defined(CONFIG_SND_RTCTIMER_MODULE)
+#elif IS_ENABLED(CONFIG_SND_RTCTIMER)
 #define DEFAULT_TIMER_LIMIT 2
 #else
 #define DEFAULT_TIMER_LIMIT 1

commit 51990e825431089747f8896244b5c17d3a6423f1
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jan 22 11:23:42 2012 -0500

    device.h: cleanup users outside of linux/include (C files)
    
    For files that are actively using linux/device.h, make sure
    that they call it out.  This will allow us to clean up some
    of the implicit uses of linux/device.h within include/*
    without introducing build regressions.
    
    Yes, this was created by "cheating" -- i.e. the headers were
    cleaned up, and then the fallout was found and fixed, and then
    the two commits were reordered.  This ensures we don't introduce
    build regressions into the git history.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 8e7561dfc5fc..6ddcf06f52f9 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -24,6 +24,7 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/mutex.h>
+#include <linux/device.h>
 #include <linux/module.h>
 #include <linux/string.h>
 #include <sound/core.h>

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 67ebf1c21c04..8e7561dfc5fc 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -24,7 +24,7 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/mutex.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <linux/string.h>
 #include <sound/core.h>
 #include <sound/timer.h>

commit 94094c8aaeded11f8b99734b9ebdaada20b5f24a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Aug 8 12:28:22 2011 +0200

    ALSA: timer - Add NULL-check for invalid slave timer
    
    Just to be sure.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 950eed0c098e..67ebf1c21c04 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -328,6 +328,8 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 		mutex_unlock(&register_mutex);
 	} else {
 		timer = timeri->timer;
+		if (snd_BUG_ON(!timer))
+			goto out;
 		/* wait, until the active callback is finished */
 		spin_lock_irq(&timer->lock);
 		while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
@@ -353,6 +355,7 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 		}
 		mutex_unlock(&register_mutex);
 	}
+ out:
 	if (timeri->private_free)
 		timeri->private_free(timeri);
 	kfree(timeri->owner);

commit 0584ffa548b6e59aceb027112f23a55f0133400e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Aug 8 12:24:46 2011 +0200

    ALSA: timer - Fix Oops at closing slave timer
    
    A slave-timer instance has no timer reference, and this results in
    NULL-dereference at stopping the timer, typically called at closing
    the device.
    
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=40682
    
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 7c1cbf0a0dc4..950eed0c098e 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -531,6 +531,8 @@ int snd_timer_stop(struct snd_timer_instance *timeri)
 	if (err < 0)
 		return err;
 	timer = timeri->timer;
+	if (!timer)
+		return -EINVAL;
 	spin_lock_irqsave(&timer->lock, flags);
 	timeri->cticks = timeri->ticks;
 	timeri->pticks = 0;

commit 5b7c757d1a8878d49f46c826d6081816935664aa
Author: Nicolas Kaiser <nikai@nikai.net>
Date:   Wed Mar 16 17:10:11 2011 +0100

    ALSA: sound/core: merge list_del()/list_add_tail() to list_move_tail()
    
    Merge list_del() + list_add_tail() to list_move_tail().
    
    Signed-off-by: Nicolas Kaiser <nikai@nikai.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index ed016329e911..7c1cbf0a0dc4 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -186,9 +186,8 @@ static void snd_timer_check_slave(struct snd_timer_instance *slave)
 		list_for_each_entry(master, &timer->open_list_head, open_list) {
 			if (slave->slave_class == master->slave_class &&
 			    slave->slave_id == master->slave_id) {
-				list_del(&slave->open_list);
-				list_add_tail(&slave->open_list,
-					      &master->slave_list_head);
+				list_move_tail(&slave->open_list,
+					       &master->slave_list_head);
 				spin_lock_irq(&slave_active_lock);
 				slave->master = master;
 				slave->timer = master->timer;
@@ -414,8 +413,7 @@ static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 static int snd_timer_start1(struct snd_timer *timer, struct snd_timer_instance *timeri,
 			    unsigned long sticks)
 {
-	list_del(&timeri->active_list);
-	list_add_tail(&timeri->active_list, &timer->active_list_head);
+	list_move_tail(&timeri->active_list, &timer->active_list_head);
 	if (timer->running) {
 		if (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)
 			goto __start_now;

commit 03cfe6f57dc5c13ccdd235c23c80e3fa170f03d1
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Nov 23 17:43:19 2010 +0100

    ALSA: support module on-demand loading for seq and timer
    
    If CONFIG_SND_DYNAMIC_MINORS is used, assign /dev/snd/seq and
    /dev/snd/timer the usual static minors, and export specific
    module aliases to generate udev module on-demand loading
    instructions:
    
      $ cat /lib/modules/2.6.33.4-smp/modules.devname
      # Device nodes to trigger on-demand module loading.
      microcode cpu/microcode c10:184
      fuse fuse c10:229
      ppp_generic ppp c108:0
      tun net/tun c10:200
      uinput uinput c10:223
      dm_mod mapper/control c10:236
      snd_timer snd/timer c116:33
      snd_seq snd/seq c116:1
    
    The last two lines instruct udev to create device nodes, even
    when the modules are not loaded at that time.
    
    As soon as userspace accesses any of these nodes, the in-kernel
    module-loader will load the module, and the device can be used.
    
    The header file minor calculation needed to be simplified to
    make __stringify() (supports only two indirections) in
    the MODULE_ALIAS macro work.
    
    This is part of systemd's effort to get rid of unconditional
    module load instructions and needless init scripts.
    
    Cc: Lennart Poettering <lennart@poettering.net>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index b3aaa600dcc2..ed016329e911 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -52,6 +52,9 @@ MODULE_PARM_DESC(timer_limit, "Maximum global timers in system.");
 module_param(timer_tstamp_monotonic, int, 0444);
 MODULE_PARM_DESC(timer_tstamp_monotonic, "Use posix monotonic clock source for timestamps (default).");
 
+MODULE_ALIAS_CHARDEV(CONFIG_SND_MAJOR, SNDRV_MINOR_TIMER);
+MODULE_ALIAS("devname:snd/timer");
+
 struct snd_timer_user {
 	struct snd_timer_instance *timeri;
 	int tread;		/* enhanced read with timestamps and events */

commit 109fef9edcc100952eec980acbc2e1295627fbab
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Nov 18 09:53:54 2010 +0100

    ALSA: timer: automatically load the high-resolution timer
    
    Increase the default timer limit so that snd-hrtimer.ko can be
    automatically loaded when needed, e.g., when used as the default
    sequencer timer.  This replaces the check for the obsolete
    CONFIG_SND_HPET.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 13afb60999b9..b3aaa600dcc2 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -34,8 +34,8 @@
 #include <sound/initval.h>
 #include <linux/kmod.h>
 
-#if defined(CONFIG_SND_HPET) || defined(CONFIG_SND_HPET_MODULE)
-#define DEFAULT_TIMER_LIMIT 3
+#if defined(CONFIG_SND_HRTIMER) || defined(CONFIG_SND_HRTIMER_MODULE)
+#define DEFAULT_TIMER_LIMIT 4
 #elif defined(CONFIG_SND_RTCTIMER) || defined(CONFIG_SND_RTCTIMER_MODULE)
 #define DEFAULT_TIMER_LIMIT 2
 #else

commit 3374cd1abd478f767aaedf2c21d109596ff0fe72
Merge: e40152ee1e1c 670ff6abd6ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu May 20 11:58:57 2010 +0200

    Merge branch 'topic/core-cleanup' into for-linus

commit bfe70783ca8e61f1fc3588cd59c4f1b755e9d3cf
Author: Dan Carpenter <error27@gmail.com>
Date:   Wed Apr 28 10:29:14 2010 +0200

    ALSA: take tu->qlock with irqs disabled
    
    We should disable irqs when we take the tu->qlock because it is used in
    the irq handler.  The only place that doesn't is
    snd_timer_user_ccallback().  Most of the time snd_timer_user_ccallback()
    is called with interrupts disabled but the the first ti->ccallback()
    call in snd_timer_notify1() has interrupts enabled.
    
    This was caught by lockdep which generates the following message:
    
    > =================================
    > [ INFO: inconsistent lock state ]
    > 2.6.34-rc5 #5
    > ---------------------------------
    > inconsistent {HARDIRQ-ON-W} -> {IN-HARDIRQ-W} usage.
    > dolphin/4003 [HC1[1]:SC0[0]:HE0:SE1] takes:
    > (&(&tu->qlock)->rlock){?.+...}, at: [<f84ec472>] snd_timer_user_tinterrupt+0x28/0x132 [snd_timer]
    > {HARDIRQ-ON-W} state was registered at:
    >   [<c1048de9>] __lock_acquire+0x654/0x1482
    >   [<c1049c73>] lock_acquire+0x5c/0x73
    >   [<c125ac3e>] _raw_spin_lock+0x25/0x34
    >   [<f84ec370>] snd_timer_user_ccallback+0x55/0x95 [snd_timer]
    >   [<f84ecc4b>] snd_timer_notify1+0x53/0xca [snd_timer]
    
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 73943651caed..5040c7b862fe 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1160,6 +1160,7 @@ static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,
 {
 	struct snd_timer_user *tu = timeri->callback_data;
 	struct snd_timer_tread r1;
+	unsigned long flags;
 
 	if (event >= SNDRV_TIMER_EVENT_START &&
 	    event <= SNDRV_TIMER_EVENT_PAUSE)
@@ -1169,9 +1170,9 @@ static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,
 	r1.event = event;
 	r1.tstamp = *tstamp;
 	r1.val = resolution;
-	spin_lock(&tu->qlock);
+	spin_lock_irqsave(&tu->qlock, flags);
 	snd_timer_user_append_to_tqueue(tu, &r1);
-	spin_unlock(&tu->qlock);
+	spin_unlock_irqrestore(&tu->qlock, flags);
 	kill_fasync(&tu->fasync, SIGIO, POLL_IN);
 	wake_up(&tu->qchange_sleep);
 }

commit 02f4865fa415a87de28cc8c2e4d798ff46be1cf8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 13 11:49:04 2010 +0200

    ALSA: core - Define llseek fops
    
    Set no_llseek to llseek file ops of each sound component (but for hwdep).
    This avoids the implicit BKL invocation via generic_file_llseek() used
    as default when fops.llseek is NULL.
    
    Also call nonseekable_open() at each open ops to ensure the file flags
    have no seek bit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 73943651caed..8c9a661df05b 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1237,6 +1237,11 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 static int snd_timer_user_open(struct inode *inode, struct file *file)
 {
 	struct snd_timer_user *tu;
+	int err;
+
+	err = nonseekable_open(inode, file);
+	if (err < 0)
+		return err;
 
 	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
 	if (tu == NULL)
@@ -1921,6 +1926,7 @@ static const struct file_operations snd_timer_f_ops =
 	.read =		snd_timer_user_read,
 	.open =		snd_timer_user_open,
 	.release =	snd_timer_user_release,
+	.llseek =	no_llseek,
 	.poll =		snd_timer_user_poll,
 	.unlocked_ioctl =	snd_timer_user_ioctl,
 	.compat_ioctl =	snd_timer_user_ioctl_compat,

commit b30477d5e2961bfd90ad4146c517871ca8a6bebc
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Wed Mar 3 11:05:55 2010 +0100

    ALSA: timer - pass real event in snd_timer_notify1() to instance callback
    
    Do not use hardcoded SNDRV_TIMER_EVENT_START value.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 8f8b17ac074d..73943651caed 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -393,7 +393,7 @@ static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 	    event == SNDRV_TIMER_EVENT_CONTINUE)
 		resolution = snd_timer_resolution(ti);
 	if (ti->ccallback)
-		ti->ccallback(ti, SNDRV_TIMER_EVENT_START, &tstamp, resolution);
+		ti->ccallback(ti, event, &tstamp, resolution);
 	if (ti->flags & SNDRV_TIMER_IFLG_SLAVE)
 		return;
 	timer = ti->timer;

commit ef44a1ec6eeef189998f84e7230e1d3535b01074
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Fri Apr 10 09:43:08 2009 +0800

    ALSA: sound/core: use memdup_user()
    
    Remove open-coded memdup_user().
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 3f0050d0b71e..8f8b17ac074d 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1395,13 +1395,10 @@ static int snd_timer_user_ginfo(struct file *file,
 	struct list_head *p;
 	int err = 0;
 
-	ginfo = kmalloc(sizeof(*ginfo), GFP_KERNEL);
-	if (! ginfo)
-		return -ENOMEM;
-	if (copy_from_user(ginfo, _ginfo, sizeof(*ginfo))) {
-		kfree(ginfo);
-		return -EFAULT;
-	}
+	ginfo = memdup_user(_ginfo, sizeof(*ginfo));
+	if (IS_ERR(ginfo))
+		return PTR_ERR(ginfo);
+
 	tid = ginfo->tid;
 	memset(ginfo, 0, sizeof(*ginfo));
 	ginfo->tid = tid;

commit 60aa49243d09afc873f082567d2e3c16634ced84
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Sun Feb 1 14:52:56 2009 -0700

    Rationalize fasync return values
    
    Most fasync implementations do something like:
    
         return fasync_helper(...);
    
    But fasync_helper() will return a positive value at times - a feature used
    in at least one place.  Thus, a number of other drivers do:
    
         err = fasync_helper(...);
         if (err < 0)
                 return err;
         return 0;
    
    In the interests of consistency and more concise code, it makes sense to
    map positive return values onto zero where ->fasync() is called.
    
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 796532081e81..3f0050d0b71e 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1825,13 +1825,9 @@ static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 static int snd_timer_user_fasync(int fd, struct file * file, int on)
 {
 	struct snd_timer_user *tu;
-	int err;
 
 	tu = file->private_data;
-	err = fasync_helper(fd, file, on, &tu->fasync);
-        if (err < 0)
-		return err;
-	return 0;
+	return fasync_helper(fd, file, on, &tu->fasync);
 }
 
 static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,

commit 1f04128a3db7c0f0e8b5d25323eba70ac342f47f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 18 12:17:55 2008 +0100

    ALSA: hda - Convert from takslet_hi_schedule() to tasklet_schedule()
    
    Replace all tasklet_hi_schedule() callers with the normal
    tasklet_schedule().  The former often causes troubles with
    RT-kernels, and has actually no merit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index c584408c9f17..796532081e81 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -743,7 +743,7 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 	spin_unlock_irqrestore(&timer->lock, flags);
 
 	if (use_tasklet)
-		tasklet_hi_schedule(&timer->task_queue);
+		tasklet_schedule(&timer->task_queue);
 }
 
 /*

commit 233e70f4228e78eb2f80dc6650f65d3ae3dbf17c
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Fri Oct 31 23:28:30 2008 +0000

    saner FASYNC handling on file close
    
    As it is, all instances of ->release() for files that have ->fasync()
    need to remember to evict file from fasync lists; forgetting that
    creates a hole and we actually have a bunch that *does* forget.
    
    So let's keep our lives simple - let __fput() check FASYNC in
    file->f_flags and call ->fasync() there if it's been set.  And lose that
    crap in ->release() instances - leaving it there is still valid, but we
    don't have to bother anymore.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index e582face89d2..c584408c9f17 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1263,7 +1263,6 @@ static int snd_timer_user_release(struct inode *inode, struct file *file)
 	if (file->private_data) {
 		tu = file->private_data;
 		file->private_data = NULL;
-		fasync_helper(-1, file, 0, &tu->fasync);
 		if (tu->timeri)
 			snd_timer_close(tu->timeri);
 		kfree(tu->queue);

commit 0072889a556373b12b687107ac6b24d2ea961ddf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 14 07:51:57 2008 +0200

    ALSA: fix a typo during snd_assert() removal
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index b8ee49c1f855..e582face89d2 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -306,7 +306,7 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 	struct snd_timer *timer = NULL;
 	struct snd_timer_instance *slave, *tmp;
 
-	if (snd_BUG_ON(!timer))
+	if (snd_BUG_ON(!timeri))
 		return -ENXIO;
 
 	/* force to stop the timer */

commit 7eaa943c8ed8e91e05d0f5d0dc7a18e3319b45cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:09:09 2008 +0200

    ALSA: Kill snd_assert() in sound/core/*
    
    Kill snd_assert() in sound/core/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 0af337efc64e..b8ee49c1f855 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -306,7 +306,8 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 	struct snd_timer *timer = NULL;
 	struct snd_timer_instance *slave, *tmp;
 
-	snd_assert(timeri != NULL, return -ENXIO);
+	if (snd_BUG_ON(!timer))
+		return -ENXIO;
 
 	/* force to stop the timer */
 	snd_timer_stop(timeri);
@@ -385,8 +386,9 @@ static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 		do_posix_clock_monotonic_gettime(&tstamp);
 	else
 		getnstimeofday(&tstamp);
-	snd_assert(event >= SNDRV_TIMER_EVENT_START &&
-		   event <= SNDRV_TIMER_EVENT_PAUSE, return);
+	if (snd_BUG_ON(event < SNDRV_TIMER_EVENT_START ||
+		       event > SNDRV_TIMER_EVENT_PAUSE))
+		return;
 	if (event == SNDRV_TIMER_EVENT_START ||
 	    event == SNDRV_TIMER_EVENT_CONTINUE)
 		resolution = snd_timer_resolution(ti);
@@ -474,7 +476,8 @@ static int _snd_timer_stop(struct snd_timer_instance * timeri,
 	struct snd_timer *timer;
 	unsigned long flags;
 
-	snd_assert(timeri != NULL, return -ENXIO);
+	if (snd_BUG_ON(!timeri))
+		return -ENXIO;
 
 	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
 		if (!keep_flag) {
@@ -758,9 +761,10 @@ int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,
 		.dev_disconnect = snd_timer_dev_disconnect,
 	};
 
-	snd_assert(tid != NULL, return -EINVAL);
-	snd_assert(rtimer != NULL, return -EINVAL);
-	*rtimer = NULL;
+	if (snd_BUG_ON(!tid))
+		return -EINVAL;
+	if (rtimer)
+		*rtimer = NULL;
 	timer = kzalloc(sizeof(*timer), GFP_KERNEL);
 	if (timer == NULL) {
 		snd_printk(KERN_ERR "timer: cannot allocate\n");
@@ -788,13 +792,15 @@ int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,
 			return err;
 		}
 	}
-	*rtimer = timer;
+	if (rtimer)
+		*rtimer = timer;
 	return 0;
 }
 
 static int snd_timer_free(struct snd_timer *timer)
 {
-	snd_assert(timer != NULL, return -ENXIO);
+	if (!timer)
+		return 0;
 
 	mutex_lock(&register_mutex);
 	if (! list_empty(&timer->open_list_head)) {
@@ -827,8 +833,8 @@ static int snd_timer_dev_register(struct snd_device *dev)
 	struct snd_timer *timer = dev->device_data;
 	struct snd_timer *timer1;
 
-	snd_assert(timer != NULL && timer->hw.start != NULL &&
-		   timer->hw.stop != NULL, return -ENXIO);
+	if (snd_BUG_ON(!timer || !timer->hw.start || !timer->hw.stop))
+		return -ENXIO;
 	if (!(timer->hw.flags & SNDRV_TIMER_HW_SLAVE) &&
 	    !timer->hw.resolution && timer->hw.c_resolution == NULL)
 	    	return -EINVAL;
@@ -879,8 +885,9 @@ void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstam
 
 	if (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))
 		return;
-	snd_assert(event >= SNDRV_TIMER_EVENT_MSTART &&
-		   event <= SNDRV_TIMER_EVENT_MRESUME, return);
+	if (snd_BUG_ON(event < SNDRV_TIMER_EVENT_MSTART ||
+		       event > SNDRV_TIMER_EVENT_MRESUME))
+		return;
 	spin_lock_irqsave(&timer->lock, flags);
 	if (event == SNDRV_TIMER_EVENT_MSTART ||
 	    event == SNDRV_TIMER_EVENT_MCONTINUE ||

commit ee2da99782d717b264d5c309a2084ca85e9a64ff
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Jul 9 10:28:41 2008 +0200

    ALSA: remove CONFIG_KMOD from sound
    
    A bunch of things in alsa depend on CONFIG_KMOD,
    use CONFIG_MODULES instead where the dependency
    is needed at all.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 9d8184a2c2d0..0af337efc64e 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -146,7 +146,7 @@ static struct snd_timer *snd_timer_find(struct snd_timer_id *tid)
 	return NULL;
 }
 
-#ifdef CONFIG_KMOD
+#ifdef CONFIG_MODULES
 
 static void snd_timer_request(struct snd_timer_id *tid)
 {
@@ -259,8 +259,8 @@ int snd_timer_open(struct snd_timer_instance **ti,
 	/* open a master instance */
 	mutex_lock(&register_mutex);
 	timer = snd_timer_find(tid);
-#ifdef CONFIG_KMOD
-	if (timer == NULL) {
+#ifdef CONFIG_MODULES
+	if (!timer) {
 		mutex_unlock(&register_mutex);
 		snd_timer_request(tid);
 		mutex_lock(&register_mutex);

commit 0d63e4f9ea61df1d727bd52a174aba732e6e1853
Author: Jan Blunck <jblunck@suse.de>
Date:   Thu Feb 14 19:34:28 2008 -0800

    Dont touch fs_struct in drivers
    
    The sound drivers and the pnpbios core test for current->root != NULL.  This
    test seems to be unnecessary since we always have rootfs mounted before
    initializing the drivers.
    
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index aece465934b8..9d8184a2c2d0 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -150,8 +150,6 @@ static struct snd_timer *snd_timer_find(struct snd_timer_id *tid)
 
 static void snd_timer_request(struct snd_timer_id *tid)
 {
-	if (! current->fs->root)
-		return;
 	switch (tid->dev_class) {
 	case SNDRV_TIMER_CLASS_GLOBAL:
 		if (tid->device < timer_limit)

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 7e5fe2d91662..aece465934b8 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -19,7 +19,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/slab.h>

commit b751eef1fdffca5532344285f2fad0c60d2f0158
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Thu Dec 13 10:19:42 2007 +0100

    [ALSA] Use posix clock monotonic for PCM and timer timestamps
    
    We need an accurate and continuous (monotonic) time sources to do
    accurate synchronization among more timing sources. This patch allows
    to enable monotonic timestamps for ALSA PCM devices and enables monotonic
    timestamps for ALSA timer devices.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index e7dc56ca4b97..7e5fe2d91662 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -44,11 +44,14 @@
 #endif
 
 static int timer_limit = DEFAULT_TIMER_LIMIT;
+static int timer_tstamp_monotonic = 1;
 MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>, Takashi Iwai <tiwai@suse.de>");
 MODULE_DESCRIPTION("ALSA timer interface");
 MODULE_LICENSE("GPL");
 module_param(timer_limit, int, 0444);
 MODULE_PARM_DESC(timer_limit, "Maximum global timers in system.");
+module_param(timer_tstamp_monotonic, int, 0444);
+MODULE_PARM_DESC(timer_tstamp_monotonic, "Use posix monotonic clock source for timestamps (default).");
 
 struct snd_timer_user {
 	struct snd_timer_instance *timeri;
@@ -381,7 +384,10 @@ static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 	struct snd_timer_instance *ts;
 	struct timespec tstamp;
 
-	getnstimeofday(&tstamp);
+	if (timer_tstamp_monotonic)
+		do_posix_clock_monotonic_gettime(&tstamp);
+	else
+		getnstimeofday(&tstamp);
 	snd_assert(event >= SNDRV_TIMER_EVENT_START &&
 		   event <= SNDRV_TIMER_EVENT_PAUSE, return);
 	if (event == SNDRV_TIMER_EVENT_START ||
@@ -1182,8 +1188,12 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 		spin_unlock(&tu->qlock);
 		return;
 	}
-	if (tu->last_resolution != resolution || ticks > 0)
-		getnstimeofday(&tstamp);
+	if (tu->last_resolution != resolution || ticks > 0) {
+		if (timer_tstamp_monotonic)
+			do_posix_clock_monotonic_gettime(&tstamp);
+		else
+			getnstimeofday(&tstamp);
+	}
 	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&
 	    tu->last_resolution != resolution) {
 		r1.event = SNDRV_TIMER_EVENT_RESOLUTION;

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index f2bbacedd567..e7dc56ca4b97 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1,6 +1,6 @@
 /*
  *  Timers abstract layer
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *
  *
  *   This program is free software; you can redistribute it and/or modify
@@ -44,7 +44,7 @@
 #endif
 
 static int timer_limit = DEFAULT_TIMER_LIMIT;
-MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, Takashi Iwai <tiwai@suse.de>");
+MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>, Takashi Iwai <tiwai@suse.de>");
 MODULE_DESCRIPTION("ALSA timer interface");
 MODULE_LICENSE("GPL");
 module_param(timer_limit, int, 0444);

commit 7c64ec343a7d7b2d73b19e6bb8d9fd15f0462890
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jul 16 11:01:30 2007 +0200

    [ALSA] timer: check for incorrect device state in non-debug compiles, too
    
    Convert the snd_assert()s to simple if()s to prevent crashes when one of
    the timer instance ioctls is called before the file is bound to a timer
    device.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 67520b3c0042..f2bbacedd567 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1549,9 +1549,11 @@ static int snd_timer_user_info(struct file *file,
 	int err = 0;
 
 	tu = file->private_data;
-	snd_assert(tu->timeri != NULL, return -ENXIO);
+	if (!tu->timeri)
+		return -EBADFD;
 	t = tu->timeri->timer;
-	snd_assert(t != NULL, return -ENXIO);
+	if (!t)
+		return -EBADFD;
 
 	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (! info)
@@ -1579,9 +1581,11 @@ static int snd_timer_user_params(struct file *file,
 	int err;
 
 	tu = file->private_data;
-	snd_assert(tu->timeri != NULL, return -ENXIO);
+	if (!tu->timeri)
+		return -EBADFD;
 	t = tu->timeri->timer;
-	snd_assert(t != NULL, return -ENXIO);
+	if (!t)
+		return -EBADFD;
 	if (copy_from_user(&params, _params, sizeof(params)))
 		return -EFAULT;
 	if (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE) && params.ticks < 1) {
@@ -1675,7 +1679,8 @@ static int snd_timer_user_status(struct file *file,
 	struct snd_timer_status status;
 
 	tu = file->private_data;
-	snd_assert(tu->timeri != NULL, return -ENXIO);
+	if (!tu->timeri)
+		return -EBADFD;
 	memset(&status, 0, sizeof(status));
 	status.tstamp = tu->tstamp;
 	status.resolution = snd_timer_resolution(tu->timeri);
@@ -1695,7 +1700,8 @@ static int snd_timer_user_start(struct file *file)
 	struct snd_timer_user *tu;
 
 	tu = file->private_data;
-	snd_assert(tu->timeri != NULL, return -ENXIO);
+	if (!tu->timeri)
+		return -EBADFD;
 	snd_timer_stop(tu->timeri);
 	tu->timeri->lost = 0;
 	tu->last_resolution = 0;
@@ -1708,7 +1714,8 @@ static int snd_timer_user_stop(struct file *file)
 	struct snd_timer_user *tu;
 
 	tu = file->private_data;
-	snd_assert(tu->timeri != NULL, return -ENXIO);
+	if (!tu->timeri)
+		return -EBADFD;
 	return (err = snd_timer_stop(tu->timeri)) < 0 ? err : 0;
 }
 
@@ -1718,7 +1725,8 @@ static int snd_timer_user_continue(struct file *file)
 	struct snd_timer_user *tu;
 
 	tu = file->private_data;
-	snd_assert(tu->timeri != NULL, return -ENXIO);
+	if (!tu->timeri)
+		return -EBADFD;
 	tu->timeri->lost = 0;
 	return (err = snd_timer_continue(tu->timeri)) < 0 ? err : 0;
 }
@@ -1729,7 +1737,8 @@ static int snd_timer_user_pause(struct file *file)
 	struct snd_timer_user *tu;
 
 	tu = file->private_data;
-	snd_assert(tu->timeri != NULL, return -ENXIO);
+	if (!tu->timeri)
+		return -EBADFD;
 	return (err = snd_timer_pause(tu->timeri)) < 0 ? err : 0;
 }
 

commit e63340ae6b6205fef26b40a75673d1c9c0c8bb90
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue May 8 00:28:08 2007 -0700

    header cleaning: don't include smp_lock.h when not used
    
    Remove includes of <linux/smp_lock.h> where it is not used/needed.
    Suggested by Al Viro.
    
    Builds cleanly on x86_64, i386, alpha, ia64, powerpc, sparc,
    sparc64, and arm (all 59 defconfigs).
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 160e40ede723..67520b3c0042 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -22,7 +22,6 @@
 #include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/init.h>
-#include <linux/smp_lock.h>
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/mutex.h>

commit 9c2e08c592cd357a8330c34def1e8ecfdcf53275
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:37 2007 -0800

    [PATCH] mark struct file_operations const 9
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 3e0638351069..160e40ede723 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1901,7 +1901,7 @@ static unsigned int snd_timer_user_poll(struct file *file, poll_table * wait)
 #define snd_timer_user_ioctl_compat	NULL
 #endif
 
-static struct file_operations snd_timer_f_ops =
+static const struct file_operations snd_timer_f_ops =
 {
 	.owner =	THIS_MODULE,
 	.read =		snd_timer_user_read,

commit bcb4d788f573805c74ac4f39a622b30955b2f916
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Mon Jan 29 14:46:18 2007 +0100

    [ALSA] Remove useless reference to obsolete KERNELD
    
    Remove the final useless reference to the obsolete KERNELD feature.
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 4e79f9ce1a85..3e0638351069 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -35,9 +35,6 @@
 #include <sound/minors.h>
 #include <sound/initval.h>
 #include <linux/kmod.h>
-#ifdef CONFIG_KERNELD
-#include <linux/kerneld.h>
-#endif
 
 #if defined(CONFIG_SND_HPET) || defined(CONFIG_SND_HPET_MODULE)
 #define DEFAULT_TIMER_LIMIT 3

commit 9244b2c3079faac79b3b961116bd548c45087e2c
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Oct 5 16:02:22 2006 +0200

    [ALSA] alsa core: convert to list_for_each_entry*
    
    This patch converts most uses of list_for_each to list_for_each_entry all
    across alsa. In some place apparently an item can be on a list with
    different pointers so of course that isn't compatible with list_for_each, I
    therefore didn't touch those places.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 10a79aed33f8..4e79f9ce1a85 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -130,11 +130,8 @@ static struct snd_timer_instance *snd_timer_instance_new(char *owner,
 static struct snd_timer *snd_timer_find(struct snd_timer_id *tid)
 {
 	struct snd_timer *timer = NULL;
-	struct list_head *p;
-
-	list_for_each(p, &snd_timer_list) {
-		timer = list_entry(p, struct snd_timer, device_list);
 
+	list_for_each_entry(timer, &snd_timer_list, device_list) {
 		if (timer->tmr_class != tid->dev_class)
 			continue;
 		if ((timer->tmr_class == SNDRV_TIMER_CLASS_CARD ||
@@ -184,13 +181,10 @@ static void snd_timer_check_slave(struct snd_timer_instance *slave)
 {
 	struct snd_timer *timer;
 	struct snd_timer_instance *master;
-	struct list_head *p, *q;
 
 	/* FIXME: it's really dumb to look up all entries.. */
-	list_for_each(p, &snd_timer_list) {
-		timer = list_entry(p, struct snd_timer, device_list);
-		list_for_each(q, &timer->open_list_head) {
-			master = list_entry(q, struct snd_timer_instance, open_list);
+	list_for_each_entry(timer, &snd_timer_list, device_list) {
+		list_for_each_entry(master, &timer->open_list_head, open_list) {
 			if (slave->slave_class == master->slave_class &&
 			    slave->slave_id == master->slave_id) {
 				list_del(&slave->open_list);
@@ -214,16 +208,13 @@ static void snd_timer_check_slave(struct snd_timer_instance *slave)
  */
 static void snd_timer_check_master(struct snd_timer_instance *master)
 {
-	struct snd_timer_instance *slave;
-	struct list_head *p, *n;
+	struct snd_timer_instance *slave, *tmp;
 
 	/* check all pending slaves */
-	list_for_each_safe(p, n, &snd_timer_slave_list) {
-		slave = list_entry(p, struct snd_timer_instance, open_list);
+	list_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {
 		if (slave->slave_class == master->slave_class &&
 		    slave->slave_id == master->slave_id) {
-			list_del(p);
-			list_add_tail(p, &master->slave_list_head);
+			list_move_tail(&slave->open_list, &master->slave_list_head);
 			spin_lock_irq(&slave_active_lock);
 			slave->master = master;
 			slave->timer = master->timer;
@@ -317,8 +308,7 @@ static int _snd_timer_stop(struct snd_timer_instance *timeri,
 int snd_timer_close(struct snd_timer_instance *timeri)
 {
 	struct snd_timer *timer = NULL;
-	struct list_head *p, *n;
-	struct snd_timer_instance *slave;
+	struct snd_timer_instance *slave, *tmp;
 
 	snd_assert(timeri != NULL, return -ENXIO);
 
@@ -353,12 +343,11 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 		    timer->hw.close)
 			timer->hw.close(timer);
 		/* remove slave links */
-		list_for_each_safe(p, n, &timeri->slave_list_head) {
-			slave = list_entry(p, struct snd_timer_instance, open_list);
+		list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,
+					 open_list) {
 			spin_lock_irq(&slave_active_lock);
 			_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);
-			list_del(p);
-			list_add_tail(p, &snd_timer_slave_list);
+			list_move_tail(&slave->open_list, &snd_timer_slave_list);
 			slave->master = NULL;
 			slave->timer = NULL;
 			spin_unlock_irq(&slave_active_lock);
@@ -394,7 +383,6 @@ static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 	unsigned long flags;
 	unsigned long resolution = 0;
 	struct snd_timer_instance *ts;
-	struct list_head *n;
 	struct timespec tstamp;
 
 	getnstimeofday(&tstamp);
@@ -413,11 +401,9 @@ static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 	if (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)
 		return;
 	spin_lock_irqsave(&timer->lock, flags);
-	list_for_each(n, &ti->slave_active_head) {
-		ts = list_entry(n, struct snd_timer_instance, active_list);
+	list_for_each_entry(ts, &ti->slave_active_head, active_list)
 		if (ts->ccallback)
 			ts->ccallback(ti, event + 100, &tstamp, resolution);
-	}
 	spin_unlock_irqrestore(&timer->lock, flags);
 }
 
@@ -593,10 +579,8 @@ static void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_l
 {
 	struct snd_timer_instance *ti;
 	unsigned long ticks = ~0UL;
-	struct list_head *p;
 
-	list_for_each(p, &timer->active_list_head) {
-		ti = list_entry(p, struct snd_timer_instance, active_list);
+	list_for_each_entry(ti, &timer->active_list_head, active_list) {
 		if (ti->flags & SNDRV_TIMER_IFLG_START) {
 			ti->flags &= ~SNDRV_TIMER_IFLG_START;
 			ti->flags |= SNDRV_TIMER_IFLG_RUNNING;
@@ -661,9 +645,9 @@ static void snd_timer_tasklet(unsigned long arg)
  */
 void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 {
-	struct snd_timer_instance *ti, *ts;
+	struct snd_timer_instance *ti, *ts, *tmp;
 	unsigned long resolution, ticks;
-	struct list_head *p, *q, *n, *ack_list_head;
+	struct list_head *p, *ack_list_head;
 	unsigned long flags;
 	int use_tasklet = 0;
 
@@ -679,12 +663,12 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 		resolution = timer->hw.resolution;
 
 	/* loop for all active instances
-	 * Here we cannot use list_for_each because the active_list of a
+	 * Here we cannot use list_for_each_entry because the active_list of a
 	 * processed instance is relinked to done_list_head before the callback
 	 * is called.
 	 */
-	list_for_each_safe(p, n, &timer->active_list_head) {
-		ti = list_entry(p, struct snd_timer_instance, active_list);
+	list_for_each_entry_safe(ti, tmp, &timer->active_list_head,
+				 active_list) {
 		if (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING))
 			continue;
 		ti->pticks += ticks_left;
@@ -700,7 +684,7 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 		} else {
 			ti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
 			if (--timer->running)
-				list_del(p);
+				list_del(&ti->active_list);
 		}
 		if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||
 		    (ti->flags & SNDRV_TIMER_IFLG_FAST))
@@ -709,8 +693,7 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 			ack_list_head = &timer->sack_list_head;
 		if (list_empty(&ti->ack_list))
 			list_add_tail(&ti->ack_list, ack_list_head);
-		list_for_each(q, &ti->slave_active_head) {
-			ts = list_entry(q, struct snd_timer_instance, active_list);
+		list_for_each_entry(ts, &ti->slave_active_head, active_list) {
 			ts->pticks = ti->pticks;
 			ts->resolution = resolution;
 			if (list_empty(&ts->ack_list))
@@ -844,7 +827,6 @@ static int snd_timer_dev_register(struct snd_device *dev)
 {
 	struct snd_timer *timer = dev->device_data;
 	struct snd_timer *timer1;
-	struct list_head *p;
 
 	snd_assert(timer != NULL && timer->hw.start != NULL &&
 		   timer->hw.stop != NULL, return -ENXIO);
@@ -853,8 +835,7 @@ static int snd_timer_dev_register(struct snd_device *dev)
 	    	return -EINVAL;
 
 	mutex_lock(&register_mutex);
-	list_for_each(p, &snd_timer_list) {
-		timer1 = list_entry(p, struct snd_timer, device_list);
+	list_for_each_entry(timer1, &snd_timer_list, device_list) {
 		if (timer1->tmr_class > timer->tmr_class)
 			break;
 		if (timer1->tmr_class < timer->tmr_class)
@@ -877,7 +858,7 @@ static int snd_timer_dev_register(struct snd_device *dev)
 		mutex_unlock(&register_mutex);
 		return -EBUSY;
 	}
-	list_add_tail(&timer->device_list, p);
+	list_add_tail(&timer->device_list, &timer1->device_list);
 	mutex_unlock(&register_mutex);
 	return 0;
 }
@@ -896,7 +877,6 @@ void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstam
 	unsigned long flags;
 	unsigned long resolution = 0;
 	struct snd_timer_instance *ti, *ts;
-	struct list_head *p, *n;
 
 	if (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))
 		return;
@@ -911,15 +891,12 @@ void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstam
 		else
 			resolution = timer->hw.resolution;
 	}
-	list_for_each(p, &timer->active_list_head) {
-		ti = list_entry(p, struct snd_timer_instance, active_list);
+	list_for_each_entry(ti, &timer->active_list_head, active_list) {
 		if (ti->ccallback)
 			ti->ccallback(ti, event, tstamp, resolution);
-		list_for_each(n, &ti->slave_active_head) {
-			ts = list_entry(n, struct snd_timer_instance, active_list);
+		list_for_each_entry(ts, &ti->slave_active_head, active_list)
 			if (ts->ccallback)
 				ts->ccallback(ts, event, tstamp, resolution);
-		}
 	}
 	spin_unlock_irqrestore(&timer->lock, flags);
 }
@@ -1057,11 +1034,9 @@ static void snd_timer_proc_read(struct snd_info_entry *entry,
 {
 	struct snd_timer *timer;
 	struct snd_timer_instance *ti;
-	struct list_head *p, *q;
 
 	mutex_lock(&register_mutex);
-	list_for_each(p, &snd_timer_list) {
-		timer = list_entry(p, struct snd_timer, device_list);
+	list_for_each_entry(timer, &snd_timer_list, device_list) {
 		switch (timer->tmr_class) {
 		case SNDRV_TIMER_CLASS_GLOBAL:
 			snd_iprintf(buffer, "G%i: ", timer->tmr_device);
@@ -1088,14 +1063,12 @@ static void snd_timer_proc_read(struct snd_info_entry *entry,
 		if (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)
 			snd_iprintf(buffer, " SLAVE");
 		snd_iprintf(buffer, "\n");
-		list_for_each(q, &timer->open_list_head) {
-			ti = list_entry(q, struct snd_timer_instance, open_list);
+		list_for_each_entry(ti, &timer->open_list_head, open_list)
 			snd_iprintf(buffer, "  Client %s : %s\n",
 				    ti->owner ? ti->owner : "unknown",
 				    ti->flags & (SNDRV_TIMER_IFLG_START |
 						 SNDRV_TIMER_IFLG_RUNNING)
 				    ? "running" : "stopped");
-		}
 	}
 	mutex_unlock(&register_mutex);
 }

commit 6e9059b05fa733045d7845ac70c5ba0a05e3c2d1
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Jul 21 10:45:19 2006 +0200

    [ALSA] system timer: remove unused snd_timer_system_private.timer field
    
    Remove the snd_timer_system_private structure's timer field that was never used.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 3a2f8e2ca401..10a79aed33f8 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -959,7 +959,6 @@ int snd_timer_global_register(struct snd_timer *timer)
 
 struct snd_timer_system_private {
 	struct timer_list tlist;
-	struct timer * timer;
 	unsigned long last_expires;
 	unsigned long last_jiffies;
 	unsigned long correction;

commit cd93fe4770ca607c7f39260c02941deccbd77b8b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jul 17 16:53:57 2006 +0200

    [ALSA] timer: fix timer rescheduling
    
    When checking whether a hardware timer needs to be rescheduled, we have
    to compare against the previously scheduled interval and not against the
    actual interval between the last two interrupts.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 4fcc8549e4a6..3a2f8e2ca401 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -718,7 +718,7 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 		}
 	}
 	if (timer->flags & SNDRV_TIMER_FLG_RESCHED)
-		snd_timer_reschedule(timer, ticks_left);
+		snd_timer_reschedule(timer, timer->sticks);
 	if (timer->running) {
 		if (timer->hw.flags & SNDRV_TIMER_HW_STOP) {
 			timer->hw.stop(timer);

commit de2696d8bc9c81874b3743e0c27708760cb7fb52
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jul 17 16:52:09 2006 +0200

    [ALSA] system timer: clear correction value when timer stops
    
    Do not retain the old correction value when the timer was stopped.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 0f6e6727ff7c..4fcc8549e4a6 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1006,6 +1006,7 @@ static int snd_timer_s_stop(struct snd_timer * timer)
 		timer->sticks = priv->last_expires - jiff;
 	else
 		timer->sticks = 1;
+	priv->correction = 0;
 	return 0;
 }
 

commit 6ed5eff025b72cb84a884d4be05f854f13b1542f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jul 17 16:51:37 2006 +0200

    [ALSA] system timer: accumulate correction for multiple lost ticks
    
    When multiple timer interrupts arrive too late, correct for all delays
    instead of ignoring the earlier ones.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 86357007259d..0f6e6727ff7c 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -971,7 +971,7 @@ static void snd_timer_s_function(unsigned long data)
 	struct snd_timer_system_private *priv = timer->private_data;
 	unsigned long jiff = jiffies;
 	if (time_after(jiff, priv->last_expires))
-		priv->correction = (long)jiff - (long)priv->last_expires;
+		priv->correction += (long)jiff - (long)priv->last_expires;
 	snd_timer_interrupt(timer, (long)jiff - (long)priv->last_jiffies);
 }
 

commit 17f48ec3f15ddb8080b151304ee887c68f7e4650
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jul 17 16:50:56 2006 +0200

    [ALSA] system timer: fix lost ticks correction adjustment
    
    Fix the adjustment of the lost ticks correction variable in the case
    when the correction has been fully taken into account in the next timer
    expiration value.  Subtracting the scheduled ticks value would result in
    an underflow.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 7e5e562fe356..86357007259d 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -987,7 +987,7 @@ static int snd_timer_s_start(struct snd_timer * timer)
 		njiff++;
 	} else {
 		njiff += timer->sticks - priv->correction;
-		priv->correction -= timer->sticks;
+		priv->correction = 0;
 	}
 	priv->last_expires = priv->tlist.expires = njiff;
 	add_timer(&priv->tlist);

commit c461482c8072bb073e6146db320d3da85cdc89ad
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 23 14:38:23 2006 +0200

    [ALSA] Unregister device files at disconnection
    
    Orignally proposed by Sam Revitch <sam.revitch@gmail.com>.
    Unregister device files at disconnection to avoid the futher accesses.
    Also, the dev_unregister callback is removed and replaced with the
    combination of disconnect + free.
    A new function snd_card_free_when_closed() is introduced, which is
    used in USB disconnect callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 52ecbe1e9abb..7e5e562fe356 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -88,7 +88,7 @@ static DEFINE_MUTEX(register_mutex);
 static int snd_timer_free(struct snd_timer *timer);
 static int snd_timer_dev_free(struct snd_device *device);
 static int snd_timer_dev_register(struct snd_device *device);
-static int snd_timer_dev_unregister(struct snd_device *device);
+static int snd_timer_dev_disconnect(struct snd_device *device);
 
 static void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_left);
 
@@ -773,7 +773,7 @@ int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,
 	static struct snd_device_ops ops = {
 		.dev_free = snd_timer_dev_free,
 		.dev_register = snd_timer_dev_register,
-		.dev_unregister = snd_timer_dev_unregister
+		.dev_disconnect = snd_timer_dev_disconnect,
 	};
 
 	snd_assert(tid != NULL, return -EINVAL);
@@ -813,6 +813,21 @@ int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,
 static int snd_timer_free(struct snd_timer *timer)
 {
 	snd_assert(timer != NULL, return -ENXIO);
+
+	mutex_lock(&register_mutex);
+	if (! list_empty(&timer->open_list_head)) {
+		struct list_head *p, *n;
+		struct snd_timer_instance *ti;
+		snd_printk(KERN_WARNING "timer %p is busy?\n", timer);
+		list_for_each_safe(p, n, &timer->open_list_head) {
+			list_del_init(p);
+			ti = list_entry(p, struct snd_timer_instance, open_list);
+			ti->timer = NULL;
+		}
+	}
+	list_del(&timer->device_list);
+	mutex_unlock(&register_mutex);
+
 	if (timer->private_free)
 		timer->private_free(timer);
 	kfree(timer);
@@ -867,30 +882,13 @@ static int snd_timer_dev_register(struct snd_device *dev)
 	return 0;
 }
 
-static int snd_timer_unregister(struct snd_timer *timer)
+static int snd_timer_dev_disconnect(struct snd_device *device)
 {
-	struct list_head *p, *n;
-	struct snd_timer_instance *ti;
-
-	snd_assert(timer != NULL, return -ENXIO);
+	struct snd_timer *timer = device->device_data;
 	mutex_lock(&register_mutex);
-	if (! list_empty(&timer->open_list_head)) {
-		snd_printk(KERN_WARNING "timer 0x%lx is busy?\n", (long)timer);
-		list_for_each_safe(p, n, &timer->open_list_head) {
-			list_del_init(p);
-			ti = list_entry(p, struct snd_timer_instance, open_list);
-			ti->timer = NULL;
-		}
-	}
-	list_del(&timer->device_list);
+	list_del_init(&timer->device_list);
 	mutex_unlock(&register_mutex);
-	return snd_timer_free(timer);
-}
-
-static int snd_timer_dev_unregister(struct snd_device *device)
-{
-	struct snd_timer *timer = device->device_data;
-	return snd_timer_unregister(timer);
+	return 0;
 }
 
 void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstamp)
@@ -955,11 +953,6 @@ int snd_timer_global_register(struct snd_timer *timer)
 	return snd_timer_dev_register(&dev);
 }
 
-int snd_timer_global_unregister(struct snd_timer *timer)
-{
-	return snd_timer_unregister(timer);
-}
-
 /*
  *  System timer
  */
@@ -1982,7 +1975,7 @@ static void __exit alsa_timer_exit(void)
 	/* unregister the system timer */
 	list_for_each_safe(p, n, &snd_timer_list) {
 		struct snd_timer *timer = list_entry(p, struct snd_timer, device_list);
-		snd_timer_unregister(timer);
+		snd_timer_free(timer);
 	}
 	snd_timer_proc_done();
 #ifdef SNDRV_OSS_INFO_DEV_TIMERS
@@ -2005,5 +1998,4 @@ EXPORT_SYMBOL(snd_timer_notify);
 EXPORT_SYMBOL(snd_timer_global_new);
 EXPORT_SYMBOL(snd_timer_global_free);
 EXPORT_SYMBOL(snd_timer_global_register);
-EXPORT_SYMBOL(snd_timer_global_unregister);
 EXPORT_SYMBOL(snd_timer_interrupt);

commit 746d4a02e68499fc6c1f8d0c43d2271853ade181
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 23 14:37:59 2006 +0200

    [ALSA] Fix disconnection of proc interface
    
    - Add the linked list to each proc entry to enable a single-shot
      disconnection (unregister)
    - Deprecate snd_info_unregister(), use snd_info_free_entry()
    - Removed NULL checks of snd_info_free_entry()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 0a984e881c10..52ecbe1e9abb 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1126,7 +1126,7 @@ static void __init snd_timer_proc_init(void)
 
 static void __exit snd_timer_proc_done(void)
 {
-	snd_info_unregister(snd_timer_proc_entry);
+	snd_info_free_entry(snd_timer_proc_entry);
 }
 #else /* !CONFIG_PROC_FS */
 #define snd_timer_proc_init()

commit 2999ff5ba12a3dce5a86acd7078fd8787623ec63
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 17:16:58 2006 +0200

    [ALSA] Fix a deadlock in snd-rtctimer
    
    Fix a occasional deadlock occuring with snd-rtctimer driver,
    added irqsave to the lock in tasklet (ALSA bug#952).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 78199f58b93a..0a984e881c10 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -628,8 +628,9 @@ static void snd_timer_tasklet(unsigned long arg)
 	struct snd_timer_instance *ti;
 	struct list_head *p;
 	unsigned long resolution, ticks;
+	unsigned long flags;
 
-	spin_lock(&timer->lock);
+	spin_lock_irqsave(&timer->lock, flags);
 	/* now process all callbacks */
 	while (!list_empty(&timer->sack_list_head)) {
 		p = timer->sack_list_head.next;		/* get first item */
@@ -649,7 +650,7 @@ static void snd_timer_tasklet(unsigned long arg)
 		spin_lock(&timer->lock);
 		ti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;
 	}
-	spin_unlock(&timer->lock);
+	spin_unlock_irqrestore(&timer->lock, flags);
 }
 
 /*

commit 6581f4e74d8541dd7d579f64e94822622cbb1654
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 17 17:14:51 2006 +0200

    [ALSA] Remove zero-initialization of static variables
    
    Removed zero-initializations of static variables.
    A tiny optimization.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index d92f73c2c6b5..78199f58b93a 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1106,7 +1106,7 @@ static void snd_timer_proc_read(struct snd_info_entry *entry,
 	mutex_unlock(&register_mutex);
 }
 
-static struct snd_info_entry *snd_timer_proc_entry = NULL;
+static struct snd_info_entry *snd_timer_proc_entry;
 
 static void __init snd_timer_proc_init(void)
 {

commit 170a34605c14a90df5f4a78e0b4ca643be6ef8ba
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:29:15 2006 +0200

    [ALSA] Fix compile warning in timer.c
    
    Fix a compile warning in timer.c due to unused variables.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index e37eab74572d..d92f73c2c6b5 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1061,7 +1061,6 @@ static int snd_timer_register_system(void)
 static void snd_timer_proc_read(struct snd_info_entry *entry,
 				struct snd_info_buffer *buffer)
 {
-	unsigned long flags;
 	struct snd_timer *timer;
 	struct snd_timer_instance *ti;
 	struct list_head *p, *q;

commit d689e34b524b69c111db0b7c844d71c8e1a53b15
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove spinlocks around proc prints
    
    Don't lock during showing proc read.  snd_iprintf() might sleep.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 9a1e51c7c230..e37eab74572d 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1095,7 +1095,6 @@ static void snd_timer_proc_read(struct snd_info_entry *entry,
 		if (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)
 			snd_iprintf(buffer, " SLAVE");
 		snd_iprintf(buffer, "\n");
-		spin_lock_irqsave(&timer->lock, flags);
 		list_for_each(q, &timer->open_list_head) {
 			ti = list_entry(q, struct snd_timer_instance, open_list);
 			snd_iprintf(buffer, "  Client %s : %s\n",
@@ -1104,7 +1103,6 @@ static void snd_timer_proc_read(struct snd_info_entry *entry,
 						 SNDRV_TIMER_IFLG_RUNNING)
 				    ? "running" : "stopped");
 		}
-		spin_unlock_irqrestore(&timer->lock, flags);
 	}
 	mutex_unlock(&register_mutex);
 }

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index cdeeb639b675..9a1e51c7c230 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1117,7 +1117,6 @@ static void __init snd_timer_proc_init(void)
 
 	entry = snd_info_create_module_entry(THIS_MODULE, "timers", NULL);
 	if (entry != NULL) {
-		entry->c.text.read_size = SNDRV_TIMER_DEVICES * 128;
 		entry->c.text.read = snd_timer_proc_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);

commit 1a60d4c5a0c4028559585a74e48593b16e1ca9b2
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:29:08 2006 +0100

    [ALSA] semaphore -> mutex (core part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 2425b971b240..cdeeb639b675 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -25,6 +25,7 @@
 #include <linux/smp_lock.h>
 #include <linux/slab.h>
 #include <linux/time.h>
+#include <linux/mutex.h>
 #include <linux/moduleparam.h>
 #include <linux/string.h>
 #include <sound/core.h>
@@ -70,7 +71,7 @@ struct snd_timer_user {
 	struct timespec tstamp;		/* trigger tstamp */
 	wait_queue_head_t qchange_sleep;
 	struct fasync_struct *fasync;
-	struct semaphore tread_sem;
+	struct mutex tread_sem;
 };
 
 /* list of timers */
@@ -82,7 +83,7 @@ static LIST_HEAD(snd_timer_slave_list);
 /* lock for slave active lists */
 static DEFINE_SPINLOCK(slave_active_lock);
 
-static DECLARE_MUTEX(register_mutex);
+static DEFINE_MUTEX(register_mutex);
 
 static int snd_timer_free(struct snd_timer *timer);
 static int snd_timer_dev_free(struct snd_device *device);
@@ -252,10 +253,10 @@ int snd_timer_open(struct snd_timer_instance **ti,
 			snd_printd("invalid slave class %i\n", tid->dev_sclass);
 			return -EINVAL;
 		}
-		down(&register_mutex);
+		mutex_lock(&register_mutex);
 		timeri = snd_timer_instance_new(owner, NULL);
 		if (!timeri) {
-			up(&register_mutex);
+			mutex_unlock(&register_mutex);
 			return -ENOMEM;
 		}
 		timeri->slave_class = tid->dev_sclass;
@@ -263,37 +264,37 @@ int snd_timer_open(struct snd_timer_instance **ti,
 		timeri->flags |= SNDRV_TIMER_IFLG_SLAVE;
 		list_add_tail(&timeri->open_list, &snd_timer_slave_list);
 		snd_timer_check_slave(timeri);
-		up(&register_mutex);
+		mutex_unlock(&register_mutex);
 		*ti = timeri;
 		return 0;
 	}
 
 	/* open a master instance */
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	timer = snd_timer_find(tid);
 #ifdef CONFIG_KMOD
 	if (timer == NULL) {
-		up(&register_mutex);
+		mutex_unlock(&register_mutex);
 		snd_timer_request(tid);
-		down(&register_mutex);
+		mutex_lock(&register_mutex);
 		timer = snd_timer_find(tid);
 	}
 #endif
 	if (!timer) {
-		up(&register_mutex);
+		mutex_unlock(&register_mutex);
 		return -ENODEV;
 	}
 	if (!list_empty(&timer->open_list_head)) {
 		timeri = list_entry(timer->open_list_head.next,
 				    struct snd_timer_instance, open_list);
 		if (timeri->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {
-			up(&register_mutex);
+			mutex_unlock(&register_mutex);
 			return -EBUSY;
 		}
 	}
 	timeri = snd_timer_instance_new(owner, timer);
 	if (!timeri) {
-		up(&register_mutex);
+		mutex_unlock(&register_mutex);
 		return -ENOMEM;
 	}
 	timeri->slave_class = tid->dev_sclass;
@@ -302,7 +303,7 @@ int snd_timer_open(struct snd_timer_instance **ti,
 		timer->hw.open(timer);
 	list_add_tail(&timeri->open_list, &timer->open_list_head);
 	snd_timer_check_master(timeri);
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 	*ti = timeri;
 	return 0;
 }
@@ -333,9 +334,9 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 			spin_lock_irq(&slave_active_lock);
 		}
 		spin_unlock_irq(&slave_active_lock);
-		down(&register_mutex);
+		mutex_lock(&register_mutex);
 		list_del(&timeri->open_list);
-		up(&register_mutex);
+		mutex_unlock(&register_mutex);
 	} else {
 		timer = timeri->timer;
 		/* wait, until the active callback is finished */
@@ -346,7 +347,7 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 			spin_lock_irq(&timer->lock);
 		}
 		spin_unlock_irq(&timer->lock);
-		down(&register_mutex);
+		mutex_lock(&register_mutex);
 		list_del(&timeri->open_list);
 		if (timer && list_empty(&timer->open_list_head) &&
 		    timer->hw.close)
@@ -362,7 +363,7 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 			slave->timer = NULL;
 			spin_unlock_irq(&slave_active_lock);
 		}
-		up(&register_mutex);
+		mutex_unlock(&register_mutex);
 	}
 	if (timeri->private_free)
 		timeri->private_free(timeri);
@@ -835,7 +836,7 @@ static int snd_timer_dev_register(struct snd_device *dev)
 	    !timer->hw.resolution && timer->hw.c_resolution == NULL)
 	    	return -EINVAL;
 
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	list_for_each(p, &snd_timer_list) {
 		timer1 = list_entry(p, struct snd_timer, device_list);
 		if (timer1->tmr_class > timer->tmr_class)
@@ -857,11 +858,11 @@ static int snd_timer_dev_register(struct snd_device *dev)
 		if (timer1->tmr_subdevice < timer->tmr_subdevice)
 			continue;
 		/* conflicts.. */
-		up(&register_mutex);
+		mutex_unlock(&register_mutex);
 		return -EBUSY;
 	}
 	list_add_tail(&timer->device_list, p);
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 	return 0;
 }
 
@@ -871,7 +872,7 @@ static int snd_timer_unregister(struct snd_timer *timer)
 	struct snd_timer_instance *ti;
 
 	snd_assert(timer != NULL, return -ENXIO);
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	if (! list_empty(&timer->open_list_head)) {
 		snd_printk(KERN_WARNING "timer 0x%lx is busy?\n", (long)timer);
 		list_for_each_safe(p, n, &timer->open_list_head) {
@@ -881,7 +882,7 @@ static int snd_timer_unregister(struct snd_timer *timer)
 		}
 	}
 	list_del(&timer->device_list);
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 	return snd_timer_free(timer);
 }
 
@@ -1065,7 +1066,7 @@ static void snd_timer_proc_read(struct snd_info_entry *entry,
 	struct snd_timer_instance *ti;
 	struct list_head *p, *q;
 
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	list_for_each(p, &snd_timer_list) {
 		timer = list_entry(p, struct snd_timer, device_list);
 		switch (timer->tmr_class) {
@@ -1105,7 +1106,7 @@ static void snd_timer_proc_read(struct snd_info_entry *entry,
 		}
 		spin_unlock_irqrestore(&timer->lock, flags);
 	}
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 }
 
 static struct snd_info_entry *snd_timer_proc_entry = NULL;
@@ -1269,7 +1270,7 @@ static int snd_timer_user_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 	spin_lock_init(&tu->qlock);
 	init_waitqueue_head(&tu->qchange_sleep);
-	init_MUTEX(&tu->tread_sem);
+	mutex_init(&tu->tread_sem);
 	tu->ticks = 1;
 	tu->queue_size = 128;
 	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
@@ -1325,7 +1326,7 @@ static int snd_timer_user_next_device(struct snd_timer_id __user *_tid)
 
 	if (copy_from_user(&id, _tid, sizeof(id)))
 		return -EFAULT;
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	if (id.dev_class < 0) {		/* first item */
 		if (list_empty(&snd_timer_list))
 			snd_timer_user_zero_id(&id);
@@ -1407,7 +1408,7 @@ static int snd_timer_user_next_device(struct snd_timer_id __user *_tid)
 			snd_timer_user_zero_id(&id);
 		}
 	}
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 	if (copy_to_user(_tid, &id, sizeof(*_tid)))
 		return -EFAULT;
 	return 0;
@@ -1432,7 +1433,7 @@ static int snd_timer_user_ginfo(struct file *file,
 	tid = ginfo->tid;
 	memset(ginfo, 0, sizeof(*ginfo));
 	ginfo->tid = tid;
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	t = snd_timer_find(&tid);
 	if (t != NULL) {
 		ginfo->card = t->card ? t->card->number : -1;
@@ -1451,7 +1452,7 @@ static int snd_timer_user_ginfo(struct file *file,
 	} else {
 		err = -ENODEV;
 	}
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 	if (err >= 0 && copy_to_user(_ginfo, ginfo, sizeof(*ginfo)))
 		err = -EFAULT;
 	kfree(ginfo);
@@ -1467,7 +1468,7 @@ static int snd_timer_user_gparams(struct file *file,
 
 	if (copy_from_user(&gparams, _gparams, sizeof(gparams)))
 		return -EFAULT;
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	t = snd_timer_find(&gparams.tid);
 	if (!t) {
 		err = -ENODEV;
@@ -1483,7 +1484,7 @@ static int snd_timer_user_gparams(struct file *file,
 	}
 	err = t->hw.set_period(t, gparams.period_num, gparams.period_den);
 _error:
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 	return err;
 }
 
@@ -1500,7 +1501,7 @@ static int snd_timer_user_gstatus(struct file *file,
 	tid = gstatus.tid;
 	memset(&gstatus, 0, sizeof(gstatus));
 	gstatus.tid = tid;
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	t = snd_timer_find(&tid);
 	if (t != NULL) {
 		if (t->hw.c_resolution)
@@ -1517,7 +1518,7 @@ static int snd_timer_user_gstatus(struct file *file,
 	} else {
 		err = -ENODEV;
 	}
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 	if (err >= 0 && copy_to_user(_gstatus, &gstatus, sizeof(gstatus)))
 		err = -EFAULT;
 	return err;
@@ -1532,7 +1533,7 @@ static int snd_timer_user_tselect(struct file *file,
 	int err = 0;
 
 	tu = file->private_data;
-	down(&tu->tread_sem);
+	mutex_lock(&tu->tread_sem);
 	if (tu->timeri) {
 		snd_timer_close(tu->timeri);
 		tu->timeri = NULL;
@@ -1576,7 +1577,7 @@ static int snd_timer_user_tselect(struct file *file,
 	}
 
       __err:
-      	up(&tu->tread_sem);
+      	mutex_unlock(&tu->tread_sem);
 	return err;
 }
 
@@ -1797,17 +1798,17 @@ static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 	{
 		int xarg;
 
-		down(&tu->tread_sem);
+		mutex_lock(&tu->tread_sem);
 		if (tu->timeri)	{	/* too late */
-			up(&tu->tread_sem);
+			mutex_unlock(&tu->tread_sem);
 			return -EBUSY;
 		}
 		if (get_user(xarg, p)) {
-			up(&tu->tread_sem);
+			mutex_unlock(&tu->tread_sem);
 			return -EFAULT;
 		}
 		tu->tread = xarg ? 1 : 0;
-		up(&tu->tread_sem);
+		mutex_unlock(&tu->tread_sem);
 		return 0;
 	}
 	case SNDRV_TIMER_IOCTL_GINFO:

commit e28563cceb9f258ebe3c50fc27d8f4ff0ac4bfa4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 1 10:42:42 2005 +0100

    [ALSA] Optimize for config without PROC_FS
    
    Modules: HWDEP Midlevel,ALSA Core,PCM Midlevel,Timer Midlevel
    
    Optimize the code when compiled without CONFIG_PROC_FS.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index c62dbacdca13..2425b971b240 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1052,6 +1052,7 @@ static int snd_timer_register_system(void)
 	return snd_timer_global_register(timer);
 }
 
+#ifdef CONFIG_PROC_FS
 /*
  *  Info interface
  */
@@ -1107,6 +1108,33 @@ static void snd_timer_proc_read(struct snd_info_entry *entry,
 	up(&register_mutex);
 }
 
+static struct snd_info_entry *snd_timer_proc_entry = NULL;
+
+static void __init snd_timer_proc_init(void)
+{
+	struct snd_info_entry *entry;
+
+	entry = snd_info_create_module_entry(THIS_MODULE, "timers", NULL);
+	if (entry != NULL) {
+		entry->c.text.read_size = SNDRV_TIMER_DEVICES * 128;
+		entry->c.text.read = snd_timer_proc_read;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	snd_timer_proc_entry = entry;
+}
+
+static void __exit snd_timer_proc_done(void)
+{
+	snd_info_unregister(snd_timer_proc_entry);
+}
+#else /* !CONFIG_PROC_FS */
+#define snd_timer_proc_init()
+#define snd_timer_proc_done()
+#endif
+
 /*
  *  USER SPACE interface
  */
@@ -1928,27 +1956,15 @@ static struct file_operations snd_timer_f_ops =
  *  ENTRY functions
  */
 
-static struct snd_info_entry *snd_timer_proc_entry = NULL;
-
 static int __init alsa_timer_init(void)
 {
 	int err;
-	struct snd_info_entry *entry;
 
 #ifdef SNDRV_OSS_INFO_DEV_TIMERS
 	snd_oss_info_register(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1,
 			      "system timer");
 #endif
-	entry = snd_info_create_module_entry(THIS_MODULE, "timers", NULL);
-	if (entry != NULL) {
-		entry->c.text.read_size = SNDRV_TIMER_DEVICES * 128;
-		entry->c.text.read = snd_timer_proc_read;
-		if (snd_info_register(entry) < 0) {
-			snd_info_free_entry(entry);
-			entry = NULL;
-		}
-	}
-	snd_timer_proc_entry = entry;
+
 	if ((err = snd_timer_register_system()) < 0)
 		snd_printk(KERN_ERR "unable to register system timer (%i)\n",
 			   err);
@@ -1956,6 +1972,7 @@ static int __init alsa_timer_init(void)
 				       &snd_timer_f_ops, NULL, "timer")) < 0)
 		snd_printk(KERN_ERR "unable to register timer device (%i)\n",
 			   err);
+	snd_timer_proc_init();
 	return 0;
 }
 
@@ -1969,10 +1986,7 @@ static void __exit alsa_timer_exit(void)
 		struct snd_timer *timer = list_entry(p, struct snd_timer, device_list);
 		snd_timer_unregister(timer);
 	}
-	if (snd_timer_proc_entry) {
-		snd_info_unregister(snd_timer_proc_entry);
-		snd_timer_proc_entry = NULL;
-	}
+	snd_timer_proc_done();
 #ifdef SNDRV_OSS_INFO_DEV_TIMERS
 	snd_oss_info_unregister(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1);
 #endif

commit f87135f56cb266e031f5ec081dfbde7e43f55e80
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:06:59 2005 +0100

    [ALSA] dynamic minors (3/6): store device-specific object pointers dynamically
    
    Instead of storing the pointers to the device-specific structures in an
    array, put them into the struct snd_minor, and look them up dynamically.
    
    This makes the device type modules independent of the minor number
    encoding.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index a7bcb04263cb..c62dbacdca13 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1952,8 +1952,8 @@ static int __init alsa_timer_init(void)
 	if ((err = snd_timer_register_system()) < 0)
 		snd_printk(KERN_ERR "unable to register system timer (%i)\n",
 			   err);
-	if ((err = snd_register_device(SNDRV_DEVICE_TYPE_TIMER,
-				       NULL, 0, &snd_timer_f_ops, "timer")) < 0)
+	if ((err = snd_register_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,
+				       &snd_timer_f_ops, NULL, "timer")) < 0)
 		snd_printk(KERN_ERR "unable to register timer device (%i)\n",
 			   err);
 	return 0;

commit 2af677fc884fc6dc79e65c99050ea607ac8bab9b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:03:48 2005 +0100

    [ALSA] dynamic minors (1/6): store device type in struct snd_minor
    
    Instead of a comment string, store the device type in the snd_minor
    structure.  This makes snd_minor more flexible, and has the nice side
    effect that we don't need anymore to create a separate snd_minor
    template for registering a device but can pass the file_operations
    directly to snd_register_device().
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 6aad411dd7b8..a7bcb04263cb 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1924,12 +1924,6 @@ static struct file_operations snd_timer_f_ops =
 	.fasync = 	snd_timer_user_fasync,
 };
 
-static struct snd_minor snd_timer_reg =
-{
-	.comment =	"timer",
-	.f_ops =	&snd_timer_f_ops,
-};
-
 /*
  *  ENTRY functions
  */
@@ -1959,7 +1953,7 @@ static int __init alsa_timer_init(void)
 		snd_printk(KERN_ERR "unable to register system timer (%i)\n",
 			   err);
 	if ((err = snd_register_device(SNDRV_DEVICE_TYPE_TIMER,
-					NULL, 0, &snd_timer_reg, "timer"))<0)
+				       NULL, 0, &snd_timer_f_ops, "timer")) < 0)
 		snd_printk(KERN_ERR "unable to register timer device (%i)\n",
 			   err);
 	return 0;

commit b32425ac93370e1ba5556110e662f896b2e143b3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 18 18:52:14 2005 +0100

    [ALSA] Fix possible races in timer callbacks
    
    Fix possible races in timer callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 74637cef6d2c..6aad411dd7b8 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -662,12 +662,13 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 	struct snd_timer_instance *ti, *ts;
 	unsigned long resolution, ticks;
 	struct list_head *p, *q, *n, *ack_list_head;
+	unsigned long flags;
 	int use_tasklet = 0;
 
 	if (timer == NULL)
 		return;
 
-	spin_lock(&timer->lock);
+	spin_lock_irqsave(&timer->lock, flags);
 
 	/* remember the current resolution */
 	if (timer->hw.c_resolution)
@@ -752,7 +753,7 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 
 	/* do we have any slow callbacks? */
 	use_tasklet = !list_empty(&timer->sack_list_head);
-	spin_unlock(&timer->lock);
+	spin_unlock_irqrestore(&timer->lock, flags);
 
 	if (use_tasklet)
 		tasklet_hi_schedule(&timer->task_queue);

commit 73e77ba0235532bd7523ba90883d325f6e095acf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 17:44:01 2005 +0100

    [ALSA] Add error messages
    
    Add error messages in the critial error path to be more verbose.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 18d43a037850..74637cef6d2c 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -777,8 +777,10 @@ int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,
 	snd_assert(rtimer != NULL, return -EINVAL);
 	*rtimer = NULL;
 	timer = kzalloc(sizeof(*timer), GFP_KERNEL);
-	if (timer == NULL)
+	if (timer == NULL) {
+		snd_printk(KERN_ERR "timer: cannot allocate\n");
 		return -ENOMEM;
+	}
 	timer->tmr_class = tid->dev_class;
 	timer->card = card;
 	timer->tmr_device = tid->device;

commit 53d2f744afc1fcb4fb68975a443fb66eb6c44da4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 13:56:05 2005 +0100

    [ALSA] Remove xxx_t typedefs: Timer
    
    Modules: RTC timer driver,Timer Midlevel
    
    Remove xxx_t typedefs from the core timer.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 1b90a38d10ff..18d43a037850 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -53,8 +53,8 @@ MODULE_LICENSE("GPL");
 module_param(timer_limit, int, 0444);
 MODULE_PARM_DESC(timer_limit, "Maximum global timers in system.");
 
-typedef struct {
-	snd_timer_instance_t *timeri;
+struct snd_timer_user {
+	struct snd_timer_instance *timeri;
 	int tread;		/* enhanced read with timestamps and events */
 	unsigned long ticks;
 	unsigned long overrun;
@@ -62,8 +62,8 @@ typedef struct {
 	int qtail;
 	int qused;
 	int queue_size;
-	snd_timer_read_t *queue;
-	snd_timer_tread_t *tqueue;
+	struct snd_timer_read *queue;
+	struct snd_timer_tread *tqueue;
 	spinlock_t qlock;
 	unsigned long last_resolution;
 	unsigned int filter;
@@ -71,7 +71,7 @@ typedef struct {
 	wait_queue_head_t qchange_sleep;
 	struct fasync_struct *fasync;
 	struct semaphore tread_sem;
-} snd_timer_user_t;
+};
 
 /* list of timers */
 static LIST_HEAD(snd_timer_list);
@@ -84,21 +84,21 @@ static DEFINE_SPINLOCK(slave_active_lock);
 
 static DECLARE_MUTEX(register_mutex);
 
-static int snd_timer_free(snd_timer_t *timer);
-static int snd_timer_dev_free(snd_device_t *device);
-static int snd_timer_dev_register(snd_device_t *device);
-static int snd_timer_dev_unregister(snd_device_t *device);
+static int snd_timer_free(struct snd_timer *timer);
+static int snd_timer_dev_free(struct snd_device *device);
+static int snd_timer_dev_register(struct snd_device *device);
+static int snd_timer_dev_unregister(struct snd_device *device);
 
-static void snd_timer_reschedule(snd_timer_t * timer, unsigned long ticks_left);
+static void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_left);
 
 /*
  * create a timer instance with the given owner string.
  * when timer is not NULL, increments the module counter
  */
-static snd_timer_instance_t *snd_timer_instance_new(char *owner,
-						    snd_timer_t *timer)
+static struct snd_timer_instance *snd_timer_instance_new(char *owner,
+							 struct snd_timer *timer)
 {
-	snd_timer_instance_t *timeri;
+	struct snd_timer_instance *timeri;
 	timeri = kzalloc(sizeof(*timeri), GFP_KERNEL);
 	if (timeri == NULL)
 		return NULL;
@@ -126,13 +126,13 @@ static snd_timer_instance_t *snd_timer_instance_new(char *owner,
 /*
  * find a timer instance from the given timer id
  */
-static snd_timer_t *snd_timer_find(snd_timer_id_t *tid)
+static struct snd_timer *snd_timer_find(struct snd_timer_id *tid)
 {
-	snd_timer_t *timer = NULL;
+	struct snd_timer *timer = NULL;
 	struct list_head *p;
 
 	list_for_each(p, &snd_timer_list) {
-		timer = list_entry(p, snd_timer_t, device_list);
+		timer = list_entry(p, struct snd_timer, device_list);
 
 		if (timer->tmr_class != tid->dev_class)
 			continue;
@@ -152,7 +152,7 @@ static snd_timer_t *snd_timer_find(snd_timer_id_t *tid)
 
 #ifdef CONFIG_KMOD
 
-static void snd_timer_request(snd_timer_id_t *tid)
+static void snd_timer_request(struct snd_timer_id *tid)
 {
 	if (! current->fs->root)
 		return;
@@ -179,17 +179,17 @@ static void snd_timer_request(snd_timer_id_t *tid)
  *
  * call this with register_mutex down.
  */
-static void snd_timer_check_slave(snd_timer_instance_t *slave)
+static void snd_timer_check_slave(struct snd_timer_instance *slave)
 {
-	snd_timer_t *timer;
-	snd_timer_instance_t *master;
+	struct snd_timer *timer;
+	struct snd_timer_instance *master;
 	struct list_head *p, *q;
 
 	/* FIXME: it's really dumb to look up all entries.. */
 	list_for_each(p, &snd_timer_list) {
-		timer = list_entry(p, snd_timer_t, device_list);
+		timer = list_entry(p, struct snd_timer, device_list);
 		list_for_each(q, &timer->open_list_head) {
-			master = list_entry(q, snd_timer_instance_t, open_list);
+			master = list_entry(q, struct snd_timer_instance, open_list);
 			if (slave->slave_class == master->slave_class &&
 			    slave->slave_id == master->slave_id) {
 				list_del(&slave->open_list);
@@ -211,14 +211,14 @@ static void snd_timer_check_slave(snd_timer_instance_t *slave)
  *
  * call this with register_mutex down.
  */
-static void snd_timer_check_master(snd_timer_instance_t *master)
+static void snd_timer_check_master(struct snd_timer_instance *master)
 {
-	snd_timer_instance_t *slave;
+	struct snd_timer_instance *slave;
 	struct list_head *p, *n;
 
 	/* check all pending slaves */
 	list_for_each_safe(p, n, &snd_timer_slave_list) {
-		slave = list_entry(p, snd_timer_instance_t, open_list);
+		slave = list_entry(p, struct snd_timer_instance, open_list);
 		if (slave->slave_class == master->slave_class &&
 		    slave->slave_id == master->slave_id) {
 			list_del(p);
@@ -238,12 +238,12 @@ static void snd_timer_check_master(snd_timer_instance_t *master)
  * open a timer instance
  * when opening a master, the slave id must be here given.
  */
-int snd_timer_open(snd_timer_instance_t **ti,
-		   char *owner, snd_timer_id_t *tid,
+int snd_timer_open(struct snd_timer_instance **ti,
+		   char *owner, struct snd_timer_id *tid,
 		   unsigned int slave_id)
 {
-	snd_timer_t *timer;
-	snd_timer_instance_t *timeri = NULL;
+	struct snd_timer *timer;
+	struct snd_timer_instance *timeri = NULL;
 
 	if (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {
 		/* open a slave instance */
@@ -285,7 +285,7 @@ int snd_timer_open(snd_timer_instance_t **ti,
 	}
 	if (!list_empty(&timer->open_list_head)) {
 		timeri = list_entry(timer->open_list_head.next,
-				    snd_timer_instance_t, open_list);
+				    struct snd_timer_instance, open_list);
 		if (timeri->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {
 			up(&register_mutex);
 			return -EBUSY;
@@ -307,17 +307,17 @@ int snd_timer_open(snd_timer_instance_t **ti,
 	return 0;
 }
 
-static int _snd_timer_stop(snd_timer_instance_t * timeri,
-			   int keep_flag, enum sndrv_timer_event event);
+static int _snd_timer_stop(struct snd_timer_instance *timeri,
+			   int keep_flag, int event);
 
 /*
  * close a timer instance
  */
-int snd_timer_close(snd_timer_instance_t * timeri)
+int snd_timer_close(struct snd_timer_instance *timeri)
 {
-	snd_timer_t *timer = NULL;
+	struct snd_timer *timer = NULL;
 	struct list_head *p, *n;
-	snd_timer_instance_t *slave;
+	struct snd_timer_instance *slave;
 
 	snd_assert(timeri != NULL, return -ENXIO);
 
@@ -353,7 +353,7 @@ int snd_timer_close(snd_timer_instance_t * timeri)
 			timer->hw.close(timer);
 		/* remove slave links */
 		list_for_each_safe(p, n, &timeri->slave_list_head) {
-			slave = list_entry(p, snd_timer_instance_t, open_list);
+			slave = list_entry(p, struct snd_timer_instance, open_list);
 			spin_lock_irq(&slave_active_lock);
 			_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);
 			list_del(p);
@@ -373,9 +373,9 @@ int snd_timer_close(snd_timer_instance_t * timeri)
 	return 0;
 }
 
-unsigned long snd_timer_resolution(snd_timer_instance_t * timeri)
+unsigned long snd_timer_resolution(struct snd_timer_instance *timeri)
 {
-	snd_timer_t * timer;
+	struct snd_timer * timer;
 
 	if (timeri == NULL)
 		return 0;
@@ -387,13 +387,12 @@ unsigned long snd_timer_resolution(snd_timer_instance_t * timeri)
 	return 0;
 }
 
-static void snd_timer_notify1(snd_timer_instance_t *ti,
-			      enum sndrv_timer_event event)
+static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 {
-	snd_timer_t *timer;
+	struct snd_timer *timer;
 	unsigned long flags;
 	unsigned long resolution = 0;
-	snd_timer_instance_t *ts;
+	struct snd_timer_instance *ts;
 	struct list_head *n;
 	struct timespec tstamp;
 
@@ -414,14 +413,14 @@ static void snd_timer_notify1(snd_timer_instance_t *ti,
 		return;
 	spin_lock_irqsave(&timer->lock, flags);
 	list_for_each(n, &ti->slave_active_head) {
-		ts = list_entry(n, snd_timer_instance_t, active_list);
+		ts = list_entry(n, struct snd_timer_instance, active_list);
 		if (ts->ccallback)
 			ts->ccallback(ti, event + 100, &tstamp, resolution);
 	}
 	spin_unlock_irqrestore(&timer->lock, flags);
 }
 
-static int snd_timer_start1(snd_timer_t *timer, snd_timer_instance_t *timeri,
+static int snd_timer_start1(struct snd_timer *timer, struct snd_timer_instance *timeri,
 			    unsigned long sticks)
 {
 	list_del(&timeri->active_list);
@@ -442,7 +441,7 @@ static int snd_timer_start1(snd_timer_t *timer, snd_timer_instance_t *timeri,
 	}
 }
 
-static int snd_timer_start_slave(snd_timer_instance_t *timeri)
+static int snd_timer_start_slave(struct snd_timer_instance *timeri)
 {
 	unsigned long flags;
 
@@ -458,9 +457,9 @@ static int snd_timer_start_slave(snd_timer_instance_t *timeri)
 /*
  *  start the timer instance
  */
-int snd_timer_start(snd_timer_instance_t * timeri, unsigned int ticks)
+int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)
 {
-	snd_timer_t *timer;
+	struct snd_timer *timer;
 	int result = -EINVAL;
 	unsigned long flags;
 
@@ -483,10 +482,10 @@ int snd_timer_start(snd_timer_instance_t * timeri, unsigned int ticks)
 	return result;
 }
 
-static int _snd_timer_stop(snd_timer_instance_t * timeri,
-			   int keep_flag, enum sndrv_timer_event event)
+static int _snd_timer_stop(struct snd_timer_instance * timeri,
+			   int keep_flag, int event)
 {
-	snd_timer_t *timer;
+	struct snd_timer *timer;
 	unsigned long flags;
 
 	snd_assert(timeri != NULL, return -ENXIO);
@@ -532,9 +531,9 @@ static int _snd_timer_stop(snd_timer_instance_t * timeri,
  *
  * do not call this from the timer callback!
  */
-int snd_timer_stop(snd_timer_instance_t * timeri)
+int snd_timer_stop(struct snd_timer_instance *timeri)
 {
-	snd_timer_t *timer;
+	struct snd_timer *timer;
 	unsigned long flags;
 	int err;
 
@@ -552,9 +551,9 @@ int snd_timer_stop(snd_timer_instance_t * timeri)
 /*
  * start again..  the tick is kept.
  */
-int snd_timer_continue(snd_timer_instance_t * timeri)
+int snd_timer_continue(struct snd_timer_instance *timeri)
 {
-	snd_timer_t *timer;
+	struct snd_timer *timer;
 	int result = -EINVAL;
 	unsigned long flags;
 
@@ -578,7 +577,7 @@ int snd_timer_continue(snd_timer_instance_t * timeri)
 /*
  * pause.. remember the ticks left
  */
-int snd_timer_pause(snd_timer_instance_t * timeri)
+int snd_timer_pause(struct snd_timer_instance * timeri)
 {
 	return _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_PAUSE);
 }
@@ -589,14 +588,14 @@ int snd_timer_pause(snd_timer_instance_t * timeri)
  * start pending instances and check the scheduling ticks.
  * when the scheduling ticks is changed set CHANGE flag to reprogram the timer.
  */
-static void snd_timer_reschedule(snd_timer_t * timer, unsigned long ticks_left)
+static void snd_timer_reschedule(struct snd_timer * timer, unsigned long ticks_left)
 {
-	snd_timer_instance_t *ti;
+	struct snd_timer_instance *ti;
 	unsigned long ticks = ~0UL;
 	struct list_head *p;
 
 	list_for_each(p, &timer->active_list_head) {
-		ti = list_entry(p, snd_timer_instance_t, active_list);
+		ti = list_entry(p, struct snd_timer_instance, active_list);
 		if (ti->flags & SNDRV_TIMER_IFLG_START) {
 			ti->flags &= ~SNDRV_TIMER_IFLG_START;
 			ti->flags |= SNDRV_TIMER_IFLG_RUNNING;
@@ -624,8 +623,8 @@ static void snd_timer_reschedule(snd_timer_t * timer, unsigned long ticks_left)
  */
 static void snd_timer_tasklet(unsigned long arg)
 {
-	snd_timer_t *timer = (snd_timer_t *) arg;
-	snd_timer_instance_t *ti;
+	struct snd_timer *timer = (struct snd_timer *) arg;
+	struct snd_timer_instance *ti;
 	struct list_head *p;
 	unsigned long resolution, ticks;
 
@@ -633,7 +632,7 @@ static void snd_timer_tasklet(unsigned long arg)
 	/* now process all callbacks */
 	while (!list_empty(&timer->sack_list_head)) {
 		p = timer->sack_list_head.next;		/* get first item */
-		ti = list_entry(p, snd_timer_instance_t, ack_list);
+		ti = list_entry(p, struct snd_timer_instance, ack_list);
 
 		/* remove from ack_list and make empty */
 		list_del_init(p);
@@ -658,9 +657,9 @@ static void snd_timer_tasklet(unsigned long arg)
  * ticks_left is usually equal to timer->sticks.
  *
  */
-void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left)
+void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 {
-	snd_timer_instance_t *ti, *ts;
+	struct snd_timer_instance *ti, *ts;
 	unsigned long resolution, ticks;
 	struct list_head *p, *q, *n, *ack_list_head;
 	int use_tasklet = 0;
@@ -682,7 +681,7 @@ void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left)
 	 * is called.
 	 */
 	list_for_each_safe(p, n, &timer->active_list_head) {
-		ti = list_entry(p, snd_timer_instance_t, active_list);
+		ti = list_entry(p, struct snd_timer_instance, active_list);
 		if (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING))
 			continue;
 		ti->pticks += ticks_left;
@@ -708,7 +707,7 @@ void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left)
 		if (list_empty(&ti->ack_list))
 			list_add_tail(&ti->ack_list, ack_list_head);
 		list_for_each(q, &ti->slave_active_head) {
-			ts = list_entry(q, snd_timer_instance_t, active_list);
+			ts = list_entry(q, struct snd_timer_instance, active_list);
 			ts->pticks = ti->pticks;
 			ts->resolution = resolution;
 			if (list_empty(&ts->ack_list))
@@ -735,7 +734,7 @@ void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left)
 	/* now process all fast callbacks */
 	while (!list_empty(&timer->ack_list_head)) {
 		p = timer->ack_list_head.next;		/* get first item */
-		ti = list_entry(p, snd_timer_instance_t, ack_list);
+		ti = list_entry(p, struct snd_timer_instance, ack_list);
 
 		/* remove from ack_list and make empty */
 		list_del_init(p);
@@ -763,12 +762,12 @@ void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left)
 
  */
 
-int snd_timer_new(snd_card_t *card, char *id, snd_timer_id_t *tid,
-		  snd_timer_t **rtimer)
+int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,
+		  struct snd_timer **rtimer)
 {
-	snd_timer_t *timer;
+	struct snd_timer *timer;
 	int err;
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free = snd_timer_dev_free,
 		.dev_register = snd_timer_dev_register,
 		.dev_unregister = snd_timer_dev_unregister
@@ -806,7 +805,7 @@ int snd_timer_new(snd_card_t *card, char *id, snd_timer_id_t *tid,
 	return 0;
 }
 
-static int snd_timer_free(snd_timer_t *timer)
+static int snd_timer_free(struct snd_timer *timer)
 {
 	snd_assert(timer != NULL, return -ENXIO);
 	if (timer->private_free)
@@ -815,16 +814,16 @@ static int snd_timer_free(snd_timer_t *timer)
 	return 0;
 }
 
-static int snd_timer_dev_free(snd_device_t *device)
+static int snd_timer_dev_free(struct snd_device *device)
 {
-	snd_timer_t *timer = device->device_data;
+	struct snd_timer *timer = device->device_data;
 	return snd_timer_free(timer);
 }
 
-static int snd_timer_dev_register(snd_device_t *dev)
+static int snd_timer_dev_register(struct snd_device *dev)
 {
-	snd_timer_t *timer = dev->device_data;
-	snd_timer_t *timer1;
+	struct snd_timer *timer = dev->device_data;
+	struct snd_timer *timer1;
 	struct list_head *p;
 
 	snd_assert(timer != NULL && timer->hw.start != NULL &&
@@ -835,7 +834,7 @@ static int snd_timer_dev_register(snd_device_t *dev)
 
 	down(&register_mutex);
 	list_for_each(p, &snd_timer_list) {
-		timer1 = list_entry(p, snd_timer_t, device_list);
+		timer1 = list_entry(p, struct snd_timer, device_list);
 		if (timer1->tmr_class > timer->tmr_class)
 			break;
 		if (timer1->tmr_class < timer->tmr_class)
@@ -863,10 +862,10 @@ static int snd_timer_dev_register(snd_device_t *dev)
 	return 0;
 }
 
-static int snd_timer_unregister(snd_timer_t *timer)
+static int snd_timer_unregister(struct snd_timer *timer)
 {
 	struct list_head *p, *n;
-	snd_timer_instance_t *ti;
+	struct snd_timer_instance *ti;
 
 	snd_assert(timer != NULL, return -ENXIO);
 	down(&register_mutex);
@@ -874,7 +873,7 @@ static int snd_timer_unregister(snd_timer_t *timer)
 		snd_printk(KERN_WARNING "timer 0x%lx is busy?\n", (long)timer);
 		list_for_each_safe(p, n, &timer->open_list_head) {
 			list_del_init(p);
-			ti = list_entry(p, snd_timer_instance_t, open_list);
+			ti = list_entry(p, struct snd_timer_instance, open_list);
 			ti->timer = NULL;
 		}
 	}
@@ -883,18 +882,17 @@ static int snd_timer_unregister(snd_timer_t *timer)
 	return snd_timer_free(timer);
 }
 
-static int snd_timer_dev_unregister(snd_device_t *device)
+static int snd_timer_dev_unregister(struct snd_device *device)
 {
-	snd_timer_t *timer = device->device_data;
+	struct snd_timer *timer = device->device_data;
 	return snd_timer_unregister(timer);
 }
 
-void snd_timer_notify(snd_timer_t *timer, enum sndrv_timer_event event,
-		      struct timespec *tstamp)
+void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstamp)
 {
 	unsigned long flags;
 	unsigned long resolution = 0;
-	snd_timer_instance_t *ti, *ts;
+	struct snd_timer_instance *ti, *ts;
 	struct list_head *p, *n;
 
 	if (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))
@@ -911,11 +909,11 @@ void snd_timer_notify(snd_timer_t *timer, enum sndrv_timer_event event,
 			resolution = timer->hw.resolution;
 	}
 	list_for_each(p, &timer->active_list_head) {
-		ti = list_entry(p, snd_timer_instance_t, active_list);
+		ti = list_entry(p, struct snd_timer_instance, active_list);
 		if (ti->ccallback)
 			ti->ccallback(ti, event, tstamp, resolution);
 		list_for_each(n, &ti->slave_active_head) {
-			ts = list_entry(n, snd_timer_instance_t, active_list);
+			ts = list_entry(n, struct snd_timer_instance, active_list);
 			if (ts->ccallback)
 				ts->ccallback(ts, event, tstamp, resolution);
 		}
@@ -926,9 +924,9 @@ void snd_timer_notify(snd_timer_t *timer, enum sndrv_timer_event event,
 /*
  * exported functions for global timers
  */
-int snd_timer_global_new(char *id, int device, snd_timer_t **rtimer)
+int snd_timer_global_new(char *id, int device, struct snd_timer **rtimer)
 {
-	snd_timer_id_t tid;
+	struct snd_timer_id tid;
 
 	tid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;
 	tid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;
@@ -938,21 +936,21 @@ int snd_timer_global_new(char *id, int device, snd_timer_t **rtimer)
 	return snd_timer_new(NULL, id, &tid, rtimer);
 }
 
-int snd_timer_global_free(snd_timer_t *timer)
+int snd_timer_global_free(struct snd_timer *timer)
 {
 	return snd_timer_free(timer);
 }
 
-int snd_timer_global_register(snd_timer_t *timer)
+int snd_timer_global_register(struct snd_timer *timer)
 {
-	snd_device_t dev;
+	struct snd_device dev;
 
 	memset(&dev, 0, sizeof(dev));
 	dev.device_data = timer;
 	return snd_timer_dev_register(&dev);
 }
 
-int snd_timer_global_unregister(snd_timer_t *timer)
+int snd_timer_global_unregister(struct snd_timer *timer)
 {
 	return snd_timer_unregister(timer);
 }
@@ -971,7 +969,7 @@ struct snd_timer_system_private {
 
 static void snd_timer_s_function(unsigned long data)
 {
-	snd_timer_t *timer = (snd_timer_t *)data;
+	struct snd_timer *timer = (struct snd_timer *)data;
 	struct snd_timer_system_private *priv = timer->private_data;
 	unsigned long jiff = jiffies;
 	if (time_after(jiff, priv->last_expires))
@@ -979,7 +977,7 @@ static void snd_timer_s_function(unsigned long data)
 	snd_timer_interrupt(timer, (long)jiff - (long)priv->last_jiffies);
 }
 
-static int snd_timer_s_start(snd_timer_t * timer)
+static int snd_timer_s_start(struct snd_timer * timer)
 {
 	struct snd_timer_system_private *priv;
 	unsigned long njiff;
@@ -998,7 +996,7 @@ static int snd_timer_s_start(snd_timer_t * timer)
 	return 0;
 }
 
-static int snd_timer_s_stop(snd_timer_t * timer)
+static int snd_timer_s_stop(struct snd_timer * timer)
 {
 	struct snd_timer_system_private *priv;
 	unsigned long jiff;
@@ -1013,7 +1011,7 @@ static int snd_timer_s_stop(snd_timer_t * timer)
 	return 0;
 }
 
-static struct _snd_timer_hardware snd_timer_system =
+static struct snd_timer_hardware snd_timer_system =
 {
 	.flags =	SNDRV_TIMER_HW_FIRST | SNDRV_TIMER_HW_TASKLET,
 	.resolution =	1000000000L / HZ,
@@ -1022,14 +1020,14 @@ static struct _snd_timer_hardware snd_timer_system =
 	.stop =		snd_timer_s_stop
 };
 
-static void snd_timer_free_system(snd_timer_t *timer)
+static void snd_timer_free_system(struct snd_timer *timer)
 {
 	kfree(timer->private_data);
 }
 
 static int snd_timer_register_system(void)
 {
-	snd_timer_t *timer;
+	struct snd_timer *timer;
 	struct snd_timer_system_private *priv;
 	int err;
 
@@ -1055,17 +1053,17 @@ static int snd_timer_register_system(void)
  *  Info interface
  */
 
-static void snd_timer_proc_read(snd_info_entry_t *entry,
-				snd_info_buffer_t * buffer)
+static void snd_timer_proc_read(struct snd_info_entry *entry,
+				struct snd_info_buffer *buffer)
 {
 	unsigned long flags;
-	snd_timer_t *timer;
-	snd_timer_instance_t *ti;
+	struct snd_timer *timer;
+	struct snd_timer_instance *ti;
 	struct list_head *p, *q;
 
 	down(&register_mutex);
 	list_for_each(p, &snd_timer_list) {
-		timer = list_entry(p, snd_timer_t, device_list);
+		timer = list_entry(p, struct snd_timer, device_list);
 		switch (timer->tmr_class) {
 		case SNDRV_TIMER_CLASS_GLOBAL:
 			snd_iprintf(buffer, "G%i: ", timer->tmr_device);
@@ -1094,7 +1092,7 @@ static void snd_timer_proc_read(snd_info_entry_t *entry,
 		snd_iprintf(buffer, "\n");
 		spin_lock_irqsave(&timer->lock, flags);
 		list_for_each(q, &timer->open_list_head) {
-			ti = list_entry(q, snd_timer_instance_t, open_list);
+			ti = list_entry(q, struct snd_timer_instance, open_list);
 			snd_iprintf(buffer, "  Client %s : %s\n",
 				    ti->owner ? ti->owner : "unknown",
 				    ti->flags & (SNDRV_TIMER_IFLG_START |
@@ -1110,12 +1108,12 @@ static void snd_timer_proc_read(snd_info_entry_t *entry,
  *  USER SPACE interface
  */
 
-static void snd_timer_user_interrupt(snd_timer_instance_t *timeri,
+static void snd_timer_user_interrupt(struct snd_timer_instance *timeri,
 				     unsigned long resolution,
 				     unsigned long ticks)
 {
-	snd_timer_user_t *tu = timeri->callback_data;
-	snd_timer_read_t *r;
+	struct snd_timer_user *tu = timeri->callback_data;
+	struct snd_timer_read *r;
 	int prev;
 
 	spin_lock(&tu->qlock);
@@ -1142,8 +1140,8 @@ static void snd_timer_user_interrupt(snd_timer_instance_t *timeri,
 	wake_up(&tu->qchange_sleep);
 }
 
-static void snd_timer_user_append_to_tqueue(snd_timer_user_t *tu,
-					    snd_timer_tread_t *tread)
+static void snd_timer_user_append_to_tqueue(struct snd_timer_user *tu,
+					    struct snd_timer_tread *tread)
 {
 	if (tu->qused >= tu->queue_size) {
 		tu->overrun++;
@@ -1154,13 +1152,13 @@ static void snd_timer_user_append_to_tqueue(snd_timer_user_t *tu,
 	}
 }
 
-static void snd_timer_user_ccallback(snd_timer_instance_t *timeri,
-				     enum sndrv_timer_event event,
+static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,
+				     int event,
 				     struct timespec *tstamp,
 				     unsigned long resolution)
 {
-	snd_timer_user_t *tu = timeri->callback_data;
-	snd_timer_tread_t r1;
+	struct snd_timer_user *tu = timeri->callback_data;
+	struct snd_timer_tread r1;
 
 	if (event >= SNDRV_TIMER_EVENT_START &&
 	    event <= SNDRV_TIMER_EVENT_PAUSE)
@@ -1177,12 +1175,12 @@ static void snd_timer_user_ccallback(snd_timer_instance_t *timeri,
 	wake_up(&tu->qchange_sleep);
 }
 
-static void snd_timer_user_tinterrupt(snd_timer_instance_t *timeri,
+static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 				      unsigned long resolution,
 				      unsigned long ticks)
 {
-	snd_timer_user_t *tu = timeri->callback_data;
-	snd_timer_tread_t *r, r1;
+	struct snd_timer_user *tu = timeri->callback_data;
+	struct snd_timer_tread *r, r1;
 	struct timespec tstamp;
 	int prev, append = 0;
 
@@ -1233,7 +1231,7 @@ static void snd_timer_user_tinterrupt(snd_timer_instance_t *timeri,
 
 static int snd_timer_user_open(struct inode *inode, struct file *file)
 {
-	snd_timer_user_t *tu;
+	struct snd_timer_user *tu;
 
 	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
 	if (tu == NULL)
@@ -1243,7 +1241,7 @@ static int snd_timer_user_open(struct inode *inode, struct file *file)
 	init_MUTEX(&tu->tread_sem);
 	tu->ticks = 1;
 	tu->queue_size = 128;
-	tu->queue = kmalloc(tu->queue_size * sizeof(snd_timer_read_t),
+	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
 			    GFP_KERNEL);
 	if (tu->queue == NULL) {
 		kfree(tu);
@@ -1255,7 +1253,7 @@ static int snd_timer_user_open(struct inode *inode, struct file *file)
 
 static int snd_timer_user_release(struct inode *inode, struct file *file)
 {
-	snd_timer_user_t *tu;
+	struct snd_timer_user *tu;
 
 	if (file->private_data) {
 		tu = file->private_data;
@@ -1270,7 +1268,7 @@ static int snd_timer_user_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static void snd_timer_user_zero_id(snd_timer_id_t *id)
+static void snd_timer_user_zero_id(struct snd_timer_id *id)
 {
 	id->dev_class = SNDRV_TIMER_CLASS_NONE;
 	id->dev_sclass = SNDRV_TIMER_SCLASS_NONE;
@@ -1279,7 +1277,7 @@ static void snd_timer_user_zero_id(snd_timer_id_t *id)
 	id->subdevice = -1;
 }
 
-static void snd_timer_user_copy_id(snd_timer_id_t *id, snd_timer_t *timer)
+static void snd_timer_user_copy_id(struct snd_timer_id *id, struct snd_timer *timer)
 {
 	id->dev_class = timer->tmr_class;
 	id->dev_sclass = SNDRV_TIMER_SCLASS_NONE;
@@ -1288,10 +1286,10 @@ static void snd_timer_user_copy_id(snd_timer_id_t *id, snd_timer_t *timer)
 	id->subdevice = timer->tmr_subdevice;
 }
 
-static int snd_timer_user_next_device(snd_timer_id_t __user *_tid)
+static int snd_timer_user_next_device(struct snd_timer_id __user *_tid)
 {
-	snd_timer_id_t id;
-	snd_timer_t *timer;
+	struct snd_timer_id id;
+	struct snd_timer *timer;
 	struct list_head *p;
 
 	if (copy_from_user(&id, _tid, sizeof(id)))
@@ -1302,7 +1300,7 @@ static int snd_timer_user_next_device(snd_timer_id_t __user *_tid)
 			snd_timer_user_zero_id(&id);
 		else {
 			timer = list_entry(snd_timer_list.next,
-					   snd_timer_t, device_list);
+					   struct snd_timer, device_list);
 			snd_timer_user_copy_id(&id, timer);
 		}
 	} else {
@@ -1310,7 +1308,7 @@ static int snd_timer_user_next_device(snd_timer_id_t __user *_tid)
 		case SNDRV_TIMER_CLASS_GLOBAL:
 			id.device = id.device < 0 ? 0 : id.device + 1;
 			list_for_each(p, &snd_timer_list) {
-				timer = list_entry(p, snd_timer_t, device_list);
+				timer = list_entry(p, struct snd_timer, device_list);
 				if (timer->tmr_class > SNDRV_TIMER_CLASS_GLOBAL) {
 					snd_timer_user_copy_id(&id, timer);
 					break;
@@ -1343,7 +1341,7 @@ static int snd_timer_user_next_device(snd_timer_id_t __user *_tid)
 				}
 			}
 			list_for_each(p, &snd_timer_list) {
-				timer = list_entry(p, snd_timer_t, device_list);
+				timer = list_entry(p, struct snd_timer, device_list);
 				if (timer->tmr_class > id.dev_class) {
 					snd_timer_user_copy_id(&id, timer);
 					break;
@@ -1385,11 +1383,11 @@ static int snd_timer_user_next_device(snd_timer_id_t __user *_tid)
 }
 
 static int snd_timer_user_ginfo(struct file *file,
-				snd_timer_ginfo_t __user *_ginfo)
+				struct snd_timer_ginfo __user *_ginfo)
 {
-	snd_timer_ginfo_t *ginfo;
-	snd_timer_id_t tid;
-	snd_timer_t *t;
+	struct snd_timer_ginfo *ginfo;
+	struct snd_timer_id tid;
+	struct snd_timer *t;
 	struct list_head *p;
 	int err = 0;
 
@@ -1430,10 +1428,10 @@ static int snd_timer_user_ginfo(struct file *file,
 }
 
 static int snd_timer_user_gparams(struct file *file,
-				  snd_timer_gparams_t __user *_gparams)
+				  struct snd_timer_gparams __user *_gparams)
 {
-	snd_timer_gparams_t gparams;
-	snd_timer_t *t;
+	struct snd_timer_gparams gparams;
+	struct snd_timer *t;
 	int err;
 
 	if (copy_from_user(&gparams, _gparams, sizeof(gparams)))
@@ -1459,11 +1457,11 @@ static int snd_timer_user_gparams(struct file *file,
 }
 
 static int snd_timer_user_gstatus(struct file *file,
-				  snd_timer_gstatus_t __user *_gstatus)
+				  struct snd_timer_gstatus __user *_gstatus)
 {
-	snd_timer_gstatus_t gstatus;
-	snd_timer_id_t tid;
-	snd_timer_t *t;
+	struct snd_timer_gstatus gstatus;
+	struct snd_timer_id tid;
+	struct snd_timer *t;
 	int err = 0;
 
 	if (copy_from_user(&gstatus, _gstatus, sizeof(gstatus)))
@@ -1495,10 +1493,10 @@ static int snd_timer_user_gstatus(struct file *file,
 }
 
 static int snd_timer_user_tselect(struct file *file,
-				  snd_timer_select_t __user *_tselect)
+				  struct snd_timer_select __user *_tselect)
 {
-	snd_timer_user_t *tu;
-	snd_timer_select_t tselect;
+	struct snd_timer_user *tu;
+	struct snd_timer_select tselect;
 	char str[32];
 	int err = 0;
 
@@ -1524,12 +1522,12 @@ static int snd_timer_user_tselect(struct file *file,
 	kfree(tu->tqueue);
 	tu->tqueue = NULL;
 	if (tu->tread) {
-		tu->tqueue = kmalloc(tu->queue_size * sizeof(snd_timer_tread_t),
+		tu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),
 				     GFP_KERNEL);
 		if (tu->tqueue == NULL)
 			err = -ENOMEM;
 	} else {
-		tu->queue = kmalloc(tu->queue_size * sizeof(snd_timer_read_t),
+		tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
 				    GFP_KERNEL);
 		if (tu->queue == NULL)
 			err = -ENOMEM;
@@ -1552,11 +1550,11 @@ static int snd_timer_user_tselect(struct file *file,
 }
 
 static int snd_timer_user_info(struct file *file,
-			       snd_timer_info_t __user *_info)
+			       struct snd_timer_info __user *_info)
 {
-	snd_timer_user_t *tu;
-	snd_timer_info_t *info;
-	snd_timer_t *t;
+	struct snd_timer_user *tu;
+	struct snd_timer_info *info;
+	struct snd_timer *t;
 	int err = 0;
 
 	tu = file->private_data;
@@ -1580,13 +1578,13 @@ static int snd_timer_user_info(struct file *file,
 }
 
 static int snd_timer_user_params(struct file *file,
-				 snd_timer_params_t __user *_params)
+				 struct snd_timer_params __user *_params)
 {
-	snd_timer_user_t *tu;
-	snd_timer_params_t params;
-	snd_timer_t *t;
-	snd_timer_read_t *tr;
-	snd_timer_tread_t *ttr;
+	struct snd_timer_user *tu;
+	struct snd_timer_params params;
+	struct snd_timer *t;
+	struct snd_timer_read *tr;
+	struct snd_timer_tread *ttr;
 	int err;
 
 	tu = file->private_data;
@@ -1656,14 +1654,14 @@ static int snd_timer_user_params(struct file *file,
 	tu->qhead = tu->qtail = tu->qused = 0;
 	if (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {
 		if (tu->tread) {
-			snd_timer_tread_t tread;
+			struct snd_timer_tread tread;
 			tread.event = SNDRV_TIMER_EVENT_EARLY;
 			tread.tstamp.tv_sec = 0;
 			tread.tstamp.tv_nsec = 0;
 			tread.val = 0;
 			snd_timer_user_append_to_tqueue(tu, &tread);
 		} else {
-			snd_timer_read_t *r = &tu->queue[0];
+			struct snd_timer_read *r = &tu->queue[0];
 			r->resolution = 0;
 			r->ticks = 0;
 			tu->qused++;
@@ -1680,10 +1678,10 @@ static int snd_timer_user_params(struct file *file,
 }
 
 static int snd_timer_user_status(struct file *file,
-				 snd_timer_status_t __user *_status)
+				 struct snd_timer_status __user *_status)
 {
-	snd_timer_user_t *tu;
-	snd_timer_status_t status;
+	struct snd_timer_user *tu;
+	struct snd_timer_status status;
 
 	tu = file->private_data;
 	snd_assert(tu->timeri != NULL, return -ENXIO);
@@ -1703,7 +1701,7 @@ static int snd_timer_user_status(struct file *file,
 static int snd_timer_user_start(struct file *file)
 {
 	int err;
-	snd_timer_user_t *tu;
+	struct snd_timer_user *tu;
 
 	tu = file->private_data;
 	snd_assert(tu->timeri != NULL, return -ENXIO);
@@ -1716,7 +1714,7 @@ static int snd_timer_user_start(struct file *file)
 static int snd_timer_user_stop(struct file *file)
 {
 	int err;
-	snd_timer_user_t *tu;
+	struct snd_timer_user *tu;
 
 	tu = file->private_data;
 	snd_assert(tu->timeri != NULL, return -ENXIO);
@@ -1726,7 +1724,7 @@ static int snd_timer_user_stop(struct file *file)
 static int snd_timer_user_continue(struct file *file)
 {
 	int err;
-	snd_timer_user_t *tu;
+	struct snd_timer_user *tu;
 
 	tu = file->private_data;
 	snd_assert(tu->timeri != NULL, return -ENXIO);
@@ -1737,7 +1735,7 @@ static int snd_timer_user_continue(struct file *file)
 static int snd_timer_user_pause(struct file *file)
 {
 	int err;
-	snd_timer_user_t *tu;
+	struct snd_timer_user *tu;
 
 	tu = file->private_data;
 	snd_assert(tu->timeri != NULL, return -ENXIO);
@@ -1754,7 +1752,7 @@ enum {
 static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 				 unsigned long arg)
 {
-	snd_timer_user_t *tu;
+	struct snd_timer_user *tu;
 	void __user *argp = (void __user *)arg;
 	int __user *p = argp;
 
@@ -1813,7 +1811,7 @@ static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 
 static int snd_timer_user_fasync(int fd, struct file * file, int on)
 {
-	snd_timer_user_t *tu;
+	struct snd_timer_user *tu;
 	int err;
 
 	tu = file->private_data;
@@ -1826,12 +1824,12 @@ static int snd_timer_user_fasync(int fd, struct file * file, int on)
 static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 				   size_t count, loff_t *offset)
 {
-	snd_timer_user_t *tu;
+	struct snd_timer_user *tu;
 	long result = 0, unit;
 	int err = 0;
 
 	tu = file->private_data;
-	unit = tu->tread ? sizeof(snd_timer_tread_t) : sizeof(snd_timer_read_t);
+	unit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);
 	spin_lock_irq(&tu->qlock);
 	while ((long)count - result >= unit) {
 		while (!tu->qused) {
@@ -1864,13 +1862,13 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 
 		if (tu->tread) {
 			if (copy_to_user(buffer, &tu->tqueue[tu->qhead++],
-					 sizeof(snd_timer_tread_t))) {
+					 sizeof(struct snd_timer_tread))) {
 				err = -EFAULT;
 				goto _error;
 			}
 		} else {
 			if (copy_to_user(buffer, &tu->queue[tu->qhead++],
-					 sizeof(snd_timer_read_t))) {
+					 sizeof(struct snd_timer_read))) {
 				err = -EFAULT;
 				goto _error;
 			}
@@ -1892,7 +1890,7 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 static unsigned int snd_timer_user_poll(struct file *file, poll_table * wait)
 {
         unsigned int mask;
-        snd_timer_user_t *tu;
+        struct snd_timer_user *tu;
 
         tu = file->private_data;
 
@@ -1923,7 +1921,7 @@ static struct file_operations snd_timer_f_ops =
 	.fasync = 	snd_timer_user_fasync,
 };
 
-static snd_minor_t snd_timer_reg =
+static struct snd_minor snd_timer_reg =
 {
 	.comment =	"timer",
 	.f_ops =	&snd_timer_f_ops,
@@ -1933,12 +1931,12 @@ static snd_minor_t snd_timer_reg =
  *  ENTRY functions
  */
 
-static snd_info_entry_t *snd_timer_proc_entry = NULL;
+static struct snd_info_entry *snd_timer_proc_entry = NULL;
 
 static int __init alsa_timer_init(void)
 {
 	int err;
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 #ifdef SNDRV_OSS_INFO_DEV_TIMERS
 	snd_oss_info_register(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1,
@@ -1971,7 +1969,7 @@ static void __exit alsa_timer_exit(void)
 	snd_unregister_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0);
 	/* unregister the system timer */
 	list_for_each_safe(p, n, &snd_timer_list) {
-		snd_timer_t *timer = list_entry(p, snd_timer_t, device_list);
+		struct snd_timer *timer = list_entry(p, struct snd_timer, device_list);
 		snd_timer_unregister(timer);
 	}
 	if (snd_timer_proc_entry) {

commit 6b172a853814fe52fb4d5942e660943cb9e6df37
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Oct 12 17:20:21 2005 +0200

    [ALSA] timer: formatting changes
    
    Modules: Timer Midlevel
    
    Split or rewrite lines that are longer than 80 characters, and remove
    whitespaces at the end of lines.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 488c28ac56c0..1b90a38d10ff 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -55,7 +55,7 @@ MODULE_PARM_DESC(timer_limit, "Maximum global timers in system.");
 
 typedef struct {
 	snd_timer_instance_t *timeri;
-	int tread;			/* enhanced read with timestamps and events */
+	int tread;		/* enhanced read with timestamps and events */
 	unsigned long ticks;
 	unsigned long overrun;
 	int qhead;
@@ -95,7 +95,8 @@ static void snd_timer_reschedule(snd_timer_t * timer, unsigned long ticks_left);
  * create a timer instance with the given owner string.
  * when timer is not NULL, increments the module counter
  */
-static snd_timer_instance_t *snd_timer_instance_new(char *owner, snd_timer_t *timer)
+static snd_timer_instance_t *snd_timer_instance_new(char *owner,
+						    snd_timer_t *timer)
 {
 	snd_timer_instance_t *timeri;
 	timeri = kzalloc(sizeof(*timeri), GFP_KERNEL);
@@ -192,7 +193,8 @@ static void snd_timer_check_slave(snd_timer_instance_t *slave)
 			if (slave->slave_class == master->slave_class &&
 			    slave->slave_id == master->slave_id) {
 				list_del(&slave->open_list);
-				list_add_tail(&slave->open_list, &master->slave_list_head);
+				list_add_tail(&slave->open_list,
+					      &master->slave_list_head);
 				spin_lock_irq(&slave_active_lock);
 				slave->master = master;
 				slave->timer = master->timer;
@@ -225,7 +227,8 @@ static void snd_timer_check_master(snd_timer_instance_t *master)
 			slave->master = master;
 			slave->timer = master->timer;
 			if (slave->flags & SNDRV_TIMER_IFLG_RUNNING)
-				list_add_tail(&slave->active_list, &master->slave_active_head);
+				list_add_tail(&slave->active_list,
+					      &master->slave_active_head);
 			spin_unlock_irq(&slave_active_lock);
 		}
 	}
@@ -241,7 +244,7 @@ int snd_timer_open(snd_timer_instance_t **ti,
 {
 	snd_timer_t *timer;
 	snd_timer_instance_t *timeri = NULL;
-	
+
 	if (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {
 		/* open a slave instance */
 		if (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||
@@ -304,7 +307,8 @@ int snd_timer_open(snd_timer_instance_t **ti,
 	return 0;
 }
 
-static int _snd_timer_stop(snd_timer_instance_t * timeri, int keep_flag, enum sndrv_timer_event event);
+static int _snd_timer_stop(snd_timer_instance_t * timeri,
+			   int keep_flag, enum sndrv_timer_event event);
 
 /*
  * close a timer instance
@@ -344,7 +348,8 @@ int snd_timer_close(snd_timer_instance_t * timeri)
 		spin_unlock_irq(&timer->lock);
 		down(&register_mutex);
 		list_del(&timeri->open_list);
-		if (timer && list_empty(&timer->open_list_head) && timer->hw.close)
+		if (timer && list_empty(&timer->open_list_head) &&
+		    timer->hw.close)
 			timer->hw.close(timer);
 		/* remove slave links */
 		list_for_each_safe(p, n, &timeri->slave_list_head) {
@@ -382,7 +387,8 @@ unsigned long snd_timer_resolution(snd_timer_instance_t * timeri)
 	return 0;
 }
 
-static void snd_timer_notify1(snd_timer_instance_t *ti, enum sndrv_timer_event event)
+static void snd_timer_notify1(snd_timer_instance_t *ti,
+			      enum sndrv_timer_event event)
 {
 	snd_timer_t *timer;
 	unsigned long flags;
@@ -392,8 +398,10 @@ static void snd_timer_notify1(snd_timer_instance_t *ti, enum sndrv_timer_event e
 	struct timespec tstamp;
 
 	getnstimeofday(&tstamp);
-	snd_assert(event >= SNDRV_TIMER_EVENT_START && event <= SNDRV_TIMER_EVENT_PAUSE, return);
-	if (event == SNDRV_TIMER_EVENT_START || event == SNDRV_TIMER_EVENT_CONTINUE)
+	snd_assert(event >= SNDRV_TIMER_EVENT_START &&
+		   event <= SNDRV_TIMER_EVENT_PAUSE, return);
+	if (event == SNDRV_TIMER_EVENT_START ||
+	    event == SNDRV_TIMER_EVENT_CONTINUE)
 		resolution = snd_timer_resolution(ti);
 	if (ti->ccallback)
 		ti->ccallback(ti, SNDRV_TIMER_EVENT_START, &tstamp, resolution);
@@ -413,7 +421,8 @@ static void snd_timer_notify1(snd_timer_instance_t *ti, enum sndrv_timer_event e
 	spin_unlock_irqrestore(&timer->lock, flags);
 }
 
-static int snd_timer_start1(snd_timer_t *timer, snd_timer_instance_t *timeri, unsigned long sticks)
+static int snd_timer_start1(snd_timer_t *timer, snd_timer_instance_t *timeri,
+			    unsigned long sticks)
 {
 	list_del(&timeri->active_list);
 	list_add_tail(&timeri->active_list, &timer->active_list_head);
@@ -440,14 +449,15 @@ static int snd_timer_start_slave(snd_timer_instance_t *timeri)
 	spin_lock_irqsave(&slave_active_lock, flags);
 	timeri->flags |= SNDRV_TIMER_IFLG_RUNNING;
 	if (timeri->master)
-		list_add_tail(&timeri->active_list, &timeri->master->slave_active_head);
+		list_add_tail(&timeri->active_list,
+			      &timeri->master->slave_active_head);
 	spin_unlock_irqrestore(&slave_active_lock, flags);
 	return 1; /* delayed start */
 }
 
 /*
  *  start the timer instance
- */ 
+ */
 int snd_timer_start(snd_timer_instance_t * timeri, unsigned int ticks)
 {
 	snd_timer_t *timer;
@@ -473,7 +483,8 @@ int snd_timer_start(snd_timer_instance_t * timeri, unsigned int ticks)
 	return result;
 }
 
-static int _snd_timer_stop(snd_timer_instance_t * timeri, int keep_flag, enum sndrv_timer_event event)
+static int _snd_timer_stop(snd_timer_instance_t * timeri,
+			   int keep_flag, enum sndrv_timer_event event)
 {
 	snd_timer_t *timer;
 	unsigned long flags;
@@ -507,7 +518,8 @@ static int _snd_timer_stop(snd_timer_instance_t * timeri, int keep_flag, enum sn
 		}
 	}
 	if (!keep_flag)
-		timeri->flags &= ~(SNDRV_TIMER_IFLG_RUNNING|SNDRV_TIMER_IFLG_START);
+		timeri->flags &=
+			~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);
 	spin_unlock_irqrestore(&timer->lock, flags);
       __end:
 	if (event != SNDRV_TIMER_EVENT_RESOLUTION)
@@ -625,7 +637,7 @@ static void snd_timer_tasklet(unsigned long arg)
 
 		/* remove from ack_list and make empty */
 		list_del_init(p);
-		
+
 		ticks = ti->pticks;
 		ti->pticks = 0;
 		resolution = ti->resolution;
@@ -650,7 +662,7 @@ void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left)
 {
 	snd_timer_instance_t *ti, *ts;
 	unsigned long resolution, ticks;
-	struct list_head *p, *q, *n;
+	struct list_head *p, *q, *n, *ack_list_head;
 	int use_tasklet = 0;
 
 	if (timer == NULL)
@@ -665,8 +677,9 @@ void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left)
 		resolution = timer->hw.resolution;
 
 	/* loop for all active instances
-	 * here we cannot use list_for_each because the active_list of a processed
-	 * instance is relinked to done_list_head before callback is called.
+	 * Here we cannot use list_for_each because the active_list of a
+	 * processed instance is relinked to done_list_head before the callback
+	 * is called.
 	 */
 	list_for_each_safe(p, n, &timer->active_list_head) {
 		ti = list_entry(p, snd_timer_instance_t, active_list);
@@ -687,26 +700,19 @@ void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left)
 			if (--timer->running)
 				list_del(p);
 		}
-		if (list_empty(&ti->ack_list)) {
-			if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||
-			    (ti->flags & SNDRV_TIMER_IFLG_FAST)) {
-				list_add_tail(&ti->ack_list, &timer->ack_list_head);
-			} else {
-				list_add_tail(&ti->ack_list, &timer->sack_list_head);
-			}
-		}
+		if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||
+		    (ti->flags & SNDRV_TIMER_IFLG_FAST))
+			ack_list_head = &timer->ack_list_head;
+		else
+			ack_list_head = &timer->sack_list_head;
+		if (list_empty(&ti->ack_list))
+			list_add_tail(&ti->ack_list, ack_list_head);
 		list_for_each(q, &ti->slave_active_head) {
 			ts = list_entry(q, snd_timer_instance_t, active_list);
 			ts->pticks = ti->pticks;
 			ts->resolution = resolution;
-			if (list_empty(&ts->ack_list)) {
-				if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||
-				    (ti->flags & SNDRV_TIMER_IFLG_FAST)) {
-					list_add_tail(&ts->ack_list, &timer->ack_list_head);
-				} else {
-					list_add_tail(&ts->ack_list, &timer->sack_list_head);
-				}
-			}
+			if (list_empty(&ts->ack_list))
+				list_add_tail(&ts->ack_list, ack_list_head);
 		}
 	}
 	if (timer->flags & SNDRV_TIMER_FLG_RESCHED)
@@ -730,10 +736,10 @@ void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left)
 	while (!list_empty(&timer->ack_list_head)) {
 		p = timer->ack_list_head.next;		/* get first item */
 		ti = list_entry(p, snd_timer_instance_t, ack_list);
-		
+
 		/* remove from ack_list and make empty */
 		list_del_init(p);
-		
+
 		ticks = ti->pticks;
 		ti->pticks = 0;
 
@@ -757,7 +763,8 @@ void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left)
 
  */
 
-int snd_timer_new(snd_card_t *card, char *id, snd_timer_id_t *tid, snd_timer_t ** rtimer)
+int snd_timer_new(snd_card_t *card, char *id, snd_timer_id_t *tid,
+		  snd_timer_t **rtimer)
 {
 	snd_timer_t *timer;
 	int err;
@@ -785,10 +792,12 @@ int snd_timer_new(snd_card_t *card, char *id, snd_timer_id_t *tid, snd_timer_t *
 	INIT_LIST_HEAD(&timer->ack_list_head);
 	INIT_LIST_HEAD(&timer->sack_list_head);
 	spin_lock_init(&timer->lock);
-	tasklet_init(&timer->task_queue, snd_timer_tasklet, (unsigned long)timer);
+	tasklet_init(&timer->task_queue, snd_timer_tasklet,
+		     (unsigned long)timer);
 	if (card != NULL) {
 		timer->module = card->module;
-		if ((err = snd_device_new(card, SNDRV_DEV_TIMER, timer, &ops)) < 0) {
+		err = snd_device_new(card, SNDRV_DEV_TIMER, timer, &ops);
+		if (err < 0) {
 			snd_timer_free(timer);
 			return err;
 		}
@@ -818,7 +827,8 @@ static int snd_timer_dev_register(snd_device_t *dev)
 	snd_timer_t *timer1;
 	struct list_head *p;
 
-	snd_assert(timer != NULL && timer->hw.start != NULL && timer->hw.stop != NULL, return -ENXIO);
+	snd_assert(timer != NULL && timer->hw.start != NULL &&
+		   timer->hw.stop != NULL, return -ENXIO);
 	if (!(timer->hw.flags & SNDRV_TIMER_HW_SLAVE) &&
 	    !timer->hw.resolution && timer->hw.c_resolution == NULL)
 	    	return -EINVAL;
@@ -879,7 +889,8 @@ static int snd_timer_dev_unregister(snd_device_t *device)
 	return snd_timer_unregister(timer);
 }
 
-void snd_timer_notify(snd_timer_t *timer, enum sndrv_timer_event event, struct timespec *tstamp)
+void snd_timer_notify(snd_timer_t *timer, enum sndrv_timer_event event,
+		      struct timespec *tstamp)
 {
 	unsigned long flags;
 	unsigned long resolution = 0;
@@ -888,7 +899,8 @@ void snd_timer_notify(snd_timer_t *timer, enum sndrv_timer_event event, struct t
 
 	if (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))
 		return;
-	snd_assert(event >= SNDRV_TIMER_EVENT_MSTART && event <= SNDRV_TIMER_EVENT_MRESUME, return);
+	snd_assert(event >= SNDRV_TIMER_EVENT_MSTART &&
+		   event <= SNDRV_TIMER_EVENT_MRESUME, return);
 	spin_lock_irqsave(&timer->lock, flags);
 	if (event == SNDRV_TIMER_EVENT_MSTART ||
 	    event == SNDRV_TIMER_EVENT_MCONTINUE ||
@@ -917,7 +929,7 @@ void snd_timer_notify(snd_timer_t *timer, enum sndrv_timer_event event, struct t
 int snd_timer_global_new(char *id, int device, snd_timer_t **rtimer)
 {
 	snd_timer_id_t tid;
-	
+
 	tid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;
 	tid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;
 	tid.card = -1;
@@ -945,7 +957,7 @@ int snd_timer_global_unregister(snd_timer_t *timer)
 	return snd_timer_unregister(timer);
 }
 
-/* 
+/*
  *  System timer
  */
 
@@ -1021,7 +1033,8 @@ static int snd_timer_register_system(void)
 	struct snd_timer_system_private *priv;
 	int err;
 
-	if ((err = snd_timer_global_new("system", SNDRV_TIMER_GLOBAL_SYSTEM, &timer)) < 0)
+	err = snd_timer_global_new("system", SNDRV_TIMER_GLOBAL_SYSTEM, &timer);
+	if (err < 0)
 		return err;
 	strcpy(timer->name, "system timer");
 	timer->hw = snd_timer_system;
@@ -1058,27 +1071,35 @@ static void snd_timer_proc_read(snd_info_entry_t *entry,
 			snd_iprintf(buffer, "G%i: ", timer->tmr_device);
 			break;
 		case SNDRV_TIMER_CLASS_CARD:
-			snd_iprintf(buffer, "C%i-%i: ", timer->card->number, timer->tmr_device);
+			snd_iprintf(buffer, "C%i-%i: ",
+				    timer->card->number, timer->tmr_device);
 			break;
 		case SNDRV_TIMER_CLASS_PCM:
-			snd_iprintf(buffer, "P%i-%i-%i: ", timer->card->number, timer->tmr_device, timer->tmr_subdevice);
+			snd_iprintf(buffer, "P%i-%i-%i: ", timer->card->number,
+				    timer->tmr_device, timer->tmr_subdevice);
 			break;
 		default:
-			snd_iprintf(buffer, "?%i-%i-%i-%i: ", timer->tmr_class, timer->card ? timer->card->number : -1, timer->tmr_device, timer->tmr_subdevice);
+			snd_iprintf(buffer, "?%i-%i-%i-%i: ", timer->tmr_class,
+				    timer->card ? timer->card->number : -1,
+				    timer->tmr_device, timer->tmr_subdevice);
 		}
 		snd_iprintf(buffer, "%s :", timer->name);
 		if (timer->hw.resolution)
-			snd_iprintf(buffer, " %lu.%03luus (%lu ticks)", timer->hw.resolution / 1000, timer->hw.resolution % 1000, timer->hw.ticks);
+			snd_iprintf(buffer, " %lu.%03luus (%lu ticks)",
+				    timer->hw.resolution / 1000,
+				    timer->hw.resolution % 1000,
+				    timer->hw.ticks);
 		if (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)
 			snd_iprintf(buffer, " SLAVE");
 		snd_iprintf(buffer, "\n");
 		spin_lock_irqsave(&timer->lock, flags);
 		list_for_each(q, &timer->open_list_head) {
 			ti = list_entry(q, snd_timer_instance_t, open_list);
-			snd_iprintf(buffer, "  Client %s : %s : lost interrupts %li\n",
-					ti->owner ? ti->owner : "unknown",
-					ti->flags & (SNDRV_TIMER_IFLG_START|SNDRV_TIMER_IFLG_RUNNING) ? "running" : "stopped",
-					ti->lost);
+			snd_iprintf(buffer, "  Client %s : %s\n",
+				    ti->owner ? ti->owner : "unknown",
+				    ti->flags & (SNDRV_TIMER_IFLG_START |
+						 SNDRV_TIMER_IFLG_RUNNING)
+				    ? "running" : "stopped");
 		}
 		spin_unlock_irqrestore(&timer->lock, flags);
 	}
@@ -1096,7 +1117,7 @@ static void snd_timer_user_interrupt(snd_timer_instance_t *timeri,
 	snd_timer_user_t *tu = timeri->callback_data;
 	snd_timer_read_t *r;
 	int prev;
-	
+
 	spin_lock(&tu->qlock);
 	if (tu->qused > 0) {
 		prev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;
@@ -1121,7 +1142,8 @@ static void snd_timer_user_interrupt(snd_timer_instance_t *timeri,
 	wake_up(&tu->qchange_sleep);
 }
 
-static void snd_timer_user_append_to_tqueue(snd_timer_user_t *tu, snd_timer_tread_t *tread)
+static void snd_timer_user_append_to_tqueue(snd_timer_user_t *tu,
+					    snd_timer_tread_t *tread)
 {
 	if (tu->qused >= tu->queue_size) {
 		tu->overrun++;
@@ -1140,7 +1162,8 @@ static void snd_timer_user_ccallback(snd_timer_instance_t *timeri,
 	snd_timer_user_t *tu = timeri->callback_data;
 	snd_timer_tread_t r1;
 
-	if (event >= SNDRV_TIMER_EVENT_START && event <= SNDRV_TIMER_EVENT_PAUSE)
+	if (event >= SNDRV_TIMER_EVENT_START &&
+	    event <= SNDRV_TIMER_EVENT_PAUSE)
 		tu->tstamp = *tstamp;
 	if ((tu->filter & (1 << event)) == 0 || !tu->tread)
 		return;
@@ -1165,13 +1188,15 @@ static void snd_timer_user_tinterrupt(snd_timer_instance_t *timeri,
 
 	memset(&tstamp, 0, sizeof(tstamp));
 	spin_lock(&tu->qlock);
-	if ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION)|(1 << SNDRV_TIMER_EVENT_TICK))) == 0) {
+	if ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |
+			   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {
 		spin_unlock(&tu->qlock);
 		return;
 	}
 	if (tu->last_resolution != resolution || ticks > 0)
 		getnstimeofday(&tstamp);
-	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) && tu->last_resolution != resolution) {
+	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&
+	    tu->last_resolution != resolution) {
 		r1.event = SNDRV_TIMER_EVENT_RESOLUTION;
 		r1.tstamp = tstamp;
 		r1.val = resolution;
@@ -1209,7 +1234,7 @@ static void snd_timer_user_tinterrupt(snd_timer_instance_t *timeri,
 static int snd_timer_user_open(struct inode *inode, struct file *file)
 {
 	snd_timer_user_t *tu;
-	
+
 	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
 	if (tu == NULL)
 		return -ENOMEM;
@@ -1218,7 +1243,8 @@ static int snd_timer_user_open(struct inode *inode, struct file *file)
 	init_MUTEX(&tu->tread_sem);
 	tu->ticks = 1;
 	tu->queue_size = 128;
-	tu->queue = (snd_timer_read_t *)kmalloc(tu->queue_size * sizeof(snd_timer_read_t), GFP_KERNEL);
+	tu->queue = kmalloc(tu->queue_size * sizeof(snd_timer_read_t),
+			    GFP_KERNEL);
 	if (tu->queue == NULL) {
 		kfree(tu);
 		return -ENOMEM;
@@ -1267,7 +1293,7 @@ static int snd_timer_user_next_device(snd_timer_id_t __user *_tid)
 	snd_timer_id_t id;
 	snd_timer_t *timer;
 	struct list_head *p;
-	
+
 	if (copy_from_user(&id, _tid, sizeof(id)))
 		return -EFAULT;
 	down(&register_mutex);
@@ -1308,7 +1334,11 @@ static int snd_timer_user_next_device(snd_timer_id_t __user *_tid)
 					if (id.device < 0) {
 						id.device = 0;
 					} else {
-						id.subdevice = id.subdevice < 0 ? 0 : id.subdevice + 1;
+						if (id.subdevice < 0) {
+							id.subdevice = 0;
+						} else {
+							id.subdevice++;
+						}
 					}
 				}
 			}
@@ -1352,9 +1382,10 @@ static int snd_timer_user_next_device(snd_timer_id_t __user *_tid)
 	if (copy_to_user(_tid, &id, sizeof(*_tid)))
 		return -EFAULT;
 	return 0;
-} 
+}
 
-static int snd_timer_user_ginfo(struct file *file, snd_timer_ginfo_t __user *_ginfo)
+static int snd_timer_user_ginfo(struct file *file,
+				snd_timer_ginfo_t __user *_ginfo)
 {
 	snd_timer_ginfo_t *ginfo;
 	snd_timer_id_t tid;
@@ -1398,7 +1429,8 @@ static int snd_timer_user_ginfo(struct file *file, snd_timer_ginfo_t __user *_gi
 	return err;
 }
 
-static int snd_timer_user_gparams(struct file *file, snd_timer_gparams_t __user *_gparams)
+static int snd_timer_user_gparams(struct file *file,
+				  snd_timer_gparams_t __user *_gparams)
 {
 	snd_timer_gparams_t gparams;
 	snd_timer_t *t;
@@ -1408,23 +1440,26 @@ static int snd_timer_user_gparams(struct file *file, snd_timer_gparams_t __user
 		return -EFAULT;
 	down(&register_mutex);
 	t = snd_timer_find(&gparams.tid);
-	if (t != NULL) {
-		if (list_empty(&t->open_list_head)) {
-			if (t->hw.set_period)
-				err = t->hw.set_period(t, gparams.period_num, gparams.period_den);
-			else
-				err = -ENOSYS;
-		} else {
-			err = -EBUSY;
-		}
-	} else {
+	if (!t) {
 		err = -ENODEV;
+		goto _error;
+	}
+	if (!list_empty(&t->open_list_head)) {
+		err = -EBUSY;
+		goto _error;
+	}
+	if (!t->hw.set_period) {
+		err = -ENOSYS;
+		goto _error;
 	}
+	err = t->hw.set_period(t, gparams.period_num, gparams.period_den);
+_error:
 	up(&register_mutex);
 	return err;
 }
 
-static int snd_timer_user_gstatus(struct file *file, snd_timer_gstatus_t __user *_gstatus)
+static int snd_timer_user_gstatus(struct file *file,
+				  snd_timer_gstatus_t __user *_gstatus)
 {
 	snd_timer_gstatus_t gstatus;
 	snd_timer_id_t tid;
@@ -1444,7 +1479,8 @@ static int snd_timer_user_gstatus(struct file *file, snd_timer_gstatus_t __user
 		else
 			gstatus.resolution = t->hw.resolution;
 		if (t->hw.precise_resolution) {
-			t->hw.precise_resolution(t, &gstatus.resolution_num, &gstatus.resolution_den);
+			t->hw.precise_resolution(t, &gstatus.resolution_num,
+						 &gstatus.resolution_den);
 		} else {
 			gstatus.resolution_num = gstatus.resolution;
 			gstatus.resolution_den = 1000000000uL;
@@ -1458,13 +1494,14 @@ static int snd_timer_user_gstatus(struct file *file, snd_timer_gstatus_t __user
 	return err;
 }
 
-static int snd_timer_user_tselect(struct file *file, snd_timer_select_t __user *_tselect)
+static int snd_timer_user_tselect(struct file *file,
+				  snd_timer_select_t __user *_tselect)
 {
 	snd_timer_user_t *tu;
 	snd_timer_select_t tselect;
 	char str[32];
 	int err = 0;
-	
+
 	tu = file->private_data;
 	down(&tu->tread_sem);
 	if (tu->timeri) {
@@ -1478,7 +1515,8 @@ static int snd_timer_user_tselect(struct file *file, snd_timer_select_t __user *
 	sprintf(str, "application %i", current->pid);
 	if (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)
 		tselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;
-	if ((err = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid)) < 0)
+	err = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);
+	if (err < 0)
 		goto __err;
 
 	kfree(tu->queue);
@@ -1486,21 +1524,24 @@ static int snd_timer_user_tselect(struct file *file, snd_timer_select_t __user *
 	kfree(tu->tqueue);
 	tu->tqueue = NULL;
 	if (tu->tread) {
-		tu->tqueue = (snd_timer_tread_t *)kmalloc(tu->queue_size * sizeof(snd_timer_tread_t), GFP_KERNEL);
+		tu->tqueue = kmalloc(tu->queue_size * sizeof(snd_timer_tread_t),
+				     GFP_KERNEL);
 		if (tu->tqueue == NULL)
 			err = -ENOMEM;
 	} else {
-		tu->queue = (snd_timer_read_t *)kmalloc(tu->queue_size * sizeof(snd_timer_read_t), GFP_KERNEL);
+		tu->queue = kmalloc(tu->queue_size * sizeof(snd_timer_read_t),
+				    GFP_KERNEL);
 		if (tu->queue == NULL)
 			err = -ENOMEM;
 	}
-	
+
       	if (err < 0) {
 		snd_timer_close(tu->timeri);
       		tu->timeri = NULL;
       	} else {
 		tu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;
-		tu->timeri->callback = tu->tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt;
+		tu->timeri->callback = tu->tread
+			? snd_timer_user_tinterrupt : snd_timer_user_interrupt;
 		tu->timeri->ccallback = snd_timer_user_ccallback;
 		tu->timeri->callback_data = (void *)tu;
 	}
@@ -1510,7 +1551,8 @@ static int snd_timer_user_tselect(struct file *file, snd_timer_select_t __user *
 	return err;
 }
 
-static int snd_timer_user_info(struct file *file, snd_timer_info_t __user *_info)
+static int snd_timer_user_info(struct file *file,
+			       snd_timer_info_t __user *_info)
 {
 	snd_timer_user_t *tu;
 	snd_timer_info_t *info;
@@ -1537,7 +1579,8 @@ static int snd_timer_user_info(struct file *file, snd_timer_info_t __user *_info
 	return err;
 }
 
-static int snd_timer_user_params(struct file *file, snd_timer_params_t __user *_params)
+static int snd_timer_user_params(struct file *file,
+				 snd_timer_params_t __user *_params)
 {
 	snd_timer_user_t *tu;
 	snd_timer_params_t params;
@@ -1545,7 +1588,7 @@ static int snd_timer_user_params(struct file *file, snd_timer_params_t __user *_
 	snd_timer_read_t *tr;
 	snd_timer_tread_t *ttr;
 	int err;
-	
+
 	tu = file->private_data;
 	snd_assert(tu->timeri != NULL, return -ENXIO);
 	t = tu->timeri->timer;
@@ -1556,7 +1599,8 @@ static int snd_timer_user_params(struct file *file, snd_timer_params_t __user *_
 		err = -EINVAL;
 		goto _end;
 	}
-	if (params.queue_size > 0 && (params.queue_size < 32 || params.queue_size > 1024)) {
+	if (params.queue_size > 0 &&
+	    (params.queue_size < 32 || params.queue_size > 1024)) {
 		err = -EINVAL;
 		goto _end;
 	}
@@ -1589,16 +1633,19 @@ static int snd_timer_user_params(struct file *file, snd_timer_params_t __user *_
 	if (params.flags & SNDRV_TIMER_PSFLG_EARLY_EVENT)
 		tu->timeri->flags |= SNDRV_TIMER_IFLG_EARLY_EVENT;
 	spin_unlock_irq(&t->lock);
-	if (params.queue_size > 0 && (unsigned int)tu->queue_size != params.queue_size) {
+	if (params.queue_size > 0 &&
+	    (unsigned int)tu->queue_size != params.queue_size) {
 		if (tu->tread) {
-			ttr = (snd_timer_tread_t *)kmalloc(params.queue_size * sizeof(snd_timer_tread_t), GFP_KERNEL);
+			ttr = kmalloc(params.queue_size * sizeof(*ttr),
+				      GFP_KERNEL);
 			if (ttr) {
 				kfree(tu->tqueue);
 				tu->queue_size = params.queue_size;
 				tu->tqueue = ttr;
 			}
 		} else {
-			tr = (snd_timer_read_t *)kmalloc(params.queue_size * sizeof(snd_timer_read_t), GFP_KERNEL);
+			tr = kmalloc(params.queue_size * sizeof(*tr),
+				     GFP_KERNEL);
 			if (tr) {
 				kfree(tu->queue);
 				tu->queue_size = params.queue_size;
@@ -1622,7 +1669,6 @@ static int snd_timer_user_params(struct file *file, snd_timer_params_t __user *_
 			tu->qused++;
 			tu->qtail++;
 		}
-		
 	}
 	tu->filter = params.filter;
 	tu->ticks = params.ticks;
@@ -1633,11 +1679,12 @@ static int snd_timer_user_params(struct file *file, snd_timer_params_t __user *_
 	return err;
 }
 
-static int snd_timer_user_status(struct file *file, snd_timer_status_t __user *_status)
+static int snd_timer_user_status(struct file *file,
+				 snd_timer_status_t __user *_status)
 {
 	snd_timer_user_t *tu;
 	snd_timer_status_t status;
-	
+
 	tu = file->private_data;
 	snd_assert(tu->timeri != NULL, return -ENXIO);
 	memset(&status, 0, sizeof(status));
@@ -1657,7 +1704,7 @@ static int snd_timer_user_start(struct file *file)
 {
 	int err;
 	snd_timer_user_t *tu;
-		
+
 	tu = file->private_data;
 	snd_assert(tu->timeri != NULL, return -ENXIO);
 	snd_timer_stop(tu->timeri);
@@ -1670,7 +1717,7 @@ static int snd_timer_user_stop(struct file *file)
 {
 	int err;
 	snd_timer_user_t *tu;
-		
+
 	tu = file->private_data;
 	snd_assert(tu->timeri != NULL, return -ENXIO);
 	return (err = snd_timer_stop(tu->timeri)) < 0 ? err : 0;
@@ -1680,7 +1727,7 @@ static int snd_timer_user_continue(struct file *file)
 {
 	int err;
 	snd_timer_user_t *tu;
-		
+
 	tu = file->private_data;
 	snd_assert(tu->timeri != NULL, return -ENXIO);
 	tu->timeri->lost = 0;
@@ -1691,7 +1738,7 @@ static int snd_timer_user_pause(struct file *file)
 {
 	int err;
 	snd_timer_user_t *tu;
-		
+
 	tu = file->private_data;
 	snd_assert(tu->timeri != NULL, return -ENXIO);
 	return (err = snd_timer_pause(tu->timeri)) < 0 ? err : 0;
@@ -1704,12 +1751,13 @@ enum {
 	SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),
 };
 
-static long snd_timer_user_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
+				 unsigned long arg)
 {
 	snd_timer_user_t *tu;
 	void __user *argp = (void __user *)arg;
 	int __user *p = argp;
-	
+
 	tu = file->private_data;
 	switch (cmd) {
 	case SNDRV_TIMER_IOCTL_PVERSION:
@@ -1719,7 +1767,7 @@ static long snd_timer_user_ioctl(struct file *file, unsigned int cmd, unsigned l
 	case SNDRV_TIMER_IOCTL_TREAD:
 	{
 		int xarg;
-		
+
 		down(&tu->tread_sem);
 		if (tu->timeri)	{	/* too late */
 			up(&tu->tread_sem);
@@ -1767,7 +1815,7 @@ static int snd_timer_user_fasync(int fd, struct file * file, int on)
 {
 	snd_timer_user_t *tu;
 	int err;
-	
+
 	tu = file->private_data;
 	err = fasync_helper(fd, file, on, &tu->fasync);
         if (err < 0)
@@ -1775,12 +1823,13 @@ static int snd_timer_user_fasync(int fd, struct file * file, int on)
 	return 0;
 }
 
-static ssize_t snd_timer_user_read(struct file *file, char __user *buffer, size_t count, loff_t *offset)
+static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
+				   size_t count, loff_t *offset)
 {
 	snd_timer_user_t *tu;
 	long result = 0, unit;
 	int err = 0;
-	
+
 	tu = file->private_data;
 	unit = tu->tread ? sizeof(snd_timer_tread_t) : sizeof(snd_timer_read_t);
 	spin_lock_irq(&tu->qlock);
@@ -1814,12 +1863,14 @@ static ssize_t snd_timer_user_read(struct file *file, char __user *buffer, size_
 			goto _error;
 
 		if (tu->tread) {
-			if (copy_to_user(buffer, &tu->tqueue[tu->qhead++], sizeof(snd_timer_tread_t))) {
+			if (copy_to_user(buffer, &tu->tqueue[tu->qhead++],
+					 sizeof(snd_timer_tread_t))) {
 				err = -EFAULT;
 				goto _error;
 			}
 		} else {
-			if (copy_to_user(buffer, &tu->queue[tu->qhead++], sizeof(snd_timer_read_t))) {
+			if (copy_to_user(buffer, &tu->queue[tu->qhead++],
+					 sizeof(snd_timer_read_t))) {
 				err = -EFAULT;
 				goto _error;
 			}
@@ -1846,7 +1897,7 @@ static unsigned int snd_timer_user_poll(struct file *file, poll_table * wait)
         tu = file->private_data;
 
         poll_wait(file, &tu->qchange_sleep, wait);
-	
+
 	mask = 0;
 	if (tu->qused)
 		mask |= POLLIN | POLLRDNORM;
@@ -1890,9 +1941,11 @@ static int __init alsa_timer_init(void)
 	snd_info_entry_t *entry;
 
 #ifdef SNDRV_OSS_INFO_DEV_TIMERS
-	snd_oss_info_register(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1, "system timer");
+	snd_oss_info_register(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1,
+			      "system timer");
 #endif
-	if ((entry = snd_info_create_module_entry(THIS_MODULE, "timers", NULL)) != NULL) {
+	entry = snd_info_create_module_entry(THIS_MODULE, "timers", NULL);
+	if (entry != NULL) {
 		entry->c.text.read_size = SNDRV_TIMER_DEVICES * 128;
 		entry->c.text.read = snd_timer_proc_read;
 		if (snd_info_register(entry) < 0) {
@@ -1902,10 +1955,12 @@ static int __init alsa_timer_init(void)
 	}
 	snd_timer_proc_entry = entry;
 	if ((err = snd_timer_register_system()) < 0)
-		snd_printk(KERN_ERR "unable to register system timer (%i)\n", err);
+		snd_printk(KERN_ERR "unable to register system timer (%i)\n",
+			   err);
 	if ((err = snd_register_device(SNDRV_DEVICE_TYPE_TIMER,
 					NULL, 0, &snd_timer_reg, "timer"))<0)
-		snd_printk(KERN_ERR "unable to register timer device (%i)\n", err);
+		snd_printk(KERN_ERR "unable to register timer device (%i)\n",
+			   err);
 	return 0;
 }
 

commit 9dfba38012196ecaf48cbb7ecad92e0729b4491f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Oct 12 17:14:55 2005 +0200

    [ALSA] timer: remove list_entry() type casts
    
    Modules: Timer Midlevel
    
    The return value of list_entry() already has the type from the second
    argument, so we don't need to typecase it again.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index c8496c7b8df8..488c28ac56c0 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -131,7 +131,7 @@ static snd_timer_t *snd_timer_find(snd_timer_id_t *tid)
 	struct list_head *p;
 
 	list_for_each(p, &snd_timer_list) {
-		timer = (snd_timer_t *)list_entry(p, snd_timer_t, device_list);
+		timer = list_entry(p, snd_timer_t, device_list);
 
 		if (timer->tmr_class != tid->dev_class)
 			continue;
@@ -186,9 +186,9 @@ static void snd_timer_check_slave(snd_timer_instance_t *slave)
 
 	/* FIXME: it's really dumb to look up all entries.. */
 	list_for_each(p, &snd_timer_list) {
-		timer = (snd_timer_t *)list_entry(p, snd_timer_t, device_list);
+		timer = list_entry(p, snd_timer_t, device_list);
 		list_for_each(q, &timer->open_list_head) {
-			master = (snd_timer_instance_t *)list_entry(q, snd_timer_instance_t, open_list);
+			master = list_entry(q, snd_timer_instance_t, open_list);
 			if (slave->slave_class == master->slave_class &&
 			    slave->slave_id == master->slave_id) {
 				list_del(&slave->open_list);
@@ -216,7 +216,7 @@ static void snd_timer_check_master(snd_timer_instance_t *master)
 
 	/* check all pending slaves */
 	list_for_each_safe(p, n, &snd_timer_slave_list) {
-		slave = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, open_list);
+		slave = list_entry(p, snd_timer_instance_t, open_list);
 		if (slave->slave_class == master->slave_class &&
 		    slave->slave_id == master->slave_id) {
 			list_del(p);
@@ -348,7 +348,7 @@ int snd_timer_close(snd_timer_instance_t * timeri)
 			timer->hw.close(timer);
 		/* remove slave links */
 		list_for_each_safe(p, n, &timeri->slave_list_head) {
-			slave = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, open_list);
+			slave = list_entry(p, snd_timer_instance_t, open_list);
 			spin_lock_irq(&slave_active_lock);
 			_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);
 			list_del(p);
@@ -406,7 +406,7 @@ static void snd_timer_notify1(snd_timer_instance_t *ti, enum sndrv_timer_event e
 		return;
 	spin_lock_irqsave(&timer->lock, flags);
 	list_for_each(n, &ti->slave_active_head) {
-		ts = (snd_timer_instance_t *)list_entry(n, snd_timer_instance_t, active_list);
+		ts = list_entry(n, snd_timer_instance_t, active_list);
 		if (ts->ccallback)
 			ts->ccallback(ti, event + 100, &tstamp, resolution);
 	}
@@ -584,7 +584,7 @@ static void snd_timer_reschedule(snd_timer_t * timer, unsigned long ticks_left)
 	struct list_head *p;
 
 	list_for_each(p, &timer->active_list_head) {
-		ti = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, active_list);
+		ti = list_entry(p, snd_timer_instance_t, active_list);
 		if (ti->flags & SNDRV_TIMER_IFLG_START) {
 			ti->flags &= ~SNDRV_TIMER_IFLG_START;
 			ti->flags |= SNDRV_TIMER_IFLG_RUNNING;
@@ -621,7 +621,7 @@ static void snd_timer_tasklet(unsigned long arg)
 	/* now process all callbacks */
 	while (!list_empty(&timer->sack_list_head)) {
 		p = timer->sack_list_head.next;		/* get first item */
-		ti = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, ack_list);
+		ti = list_entry(p, snd_timer_instance_t, ack_list);
 
 		/* remove from ack_list and make empty */
 		list_del_init(p);
@@ -669,7 +669,7 @@ void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left)
 	 * instance is relinked to done_list_head before callback is called.
 	 */
 	list_for_each_safe(p, n, &timer->active_list_head) {
-		ti = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, active_list);
+		ti = list_entry(p, snd_timer_instance_t, active_list);
 		if (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING))
 			continue;
 		ti->pticks += ticks_left;
@@ -696,7 +696,7 @@ void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left)
 			}
 		}
 		list_for_each(q, &ti->slave_active_head) {
-			ts = (snd_timer_instance_t *)list_entry(q, snd_timer_instance_t, active_list);
+			ts = list_entry(q, snd_timer_instance_t, active_list);
 			ts->pticks = ti->pticks;
 			ts->resolution = resolution;
 			if (list_empty(&ts->ack_list)) {
@@ -729,7 +729,7 @@ void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left)
 	/* now process all fast callbacks */
 	while (!list_empty(&timer->ack_list_head)) {
 		p = timer->ack_list_head.next;		/* get first item */
-		ti = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, ack_list);
+		ti = list_entry(p, snd_timer_instance_t, ack_list);
 		
 		/* remove from ack_list and make empty */
 		list_del_init(p);
@@ -825,7 +825,7 @@ static int snd_timer_dev_register(snd_device_t *dev)
 
 	down(&register_mutex);
 	list_for_each(p, &snd_timer_list) {
-		timer1 = (snd_timer_t *)list_entry(p, snd_timer_t, device_list);
+		timer1 = list_entry(p, snd_timer_t, device_list);
 		if (timer1->tmr_class > timer->tmr_class)
 			break;
 		if (timer1->tmr_class < timer->tmr_class)
@@ -864,7 +864,7 @@ static int snd_timer_unregister(snd_timer_t *timer)
 		snd_printk(KERN_WARNING "timer 0x%lx is busy?\n", (long)timer);
 		list_for_each_safe(p, n, &timer->open_list_head) {
 			list_del_init(p);
-			ti = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, open_list);
+			ti = list_entry(p, snd_timer_instance_t, open_list);
 			ti->timer = NULL;
 		}
 	}
@@ -899,11 +899,11 @@ void snd_timer_notify(snd_timer_t *timer, enum sndrv_timer_event event, struct t
 			resolution = timer->hw.resolution;
 	}
 	list_for_each(p, &timer->active_list_head) {
-		ti = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, active_list);
+		ti = list_entry(p, snd_timer_instance_t, active_list);
 		if (ti->ccallback)
 			ti->ccallback(ti, event, tstamp, resolution);
 		list_for_each(n, &ti->slave_active_head) {
-			ts = (snd_timer_instance_t *)list_entry(n, snd_timer_instance_t, active_list);
+			ts = list_entry(n, snd_timer_instance_t, active_list);
 			if (ts->ccallback)
 				ts->ccallback(ts, event, tstamp, resolution);
 		}
@@ -1052,7 +1052,7 @@ static void snd_timer_proc_read(snd_info_entry_t *entry,
 
 	down(&register_mutex);
 	list_for_each(p, &snd_timer_list) {
-		timer = (snd_timer_t *)list_entry(p, snd_timer_t, device_list);
+		timer = list_entry(p, snd_timer_t, device_list);
 		switch (timer->tmr_class) {
 		case SNDRV_TIMER_CLASS_GLOBAL:
 			snd_iprintf(buffer, "G%i: ", timer->tmr_device);
@@ -1074,7 +1074,7 @@ static void snd_timer_proc_read(snd_info_entry_t *entry,
 		snd_iprintf(buffer, "\n");
 		spin_lock_irqsave(&timer->lock, flags);
 		list_for_each(q, &timer->open_list_head) {
-			ti = (snd_timer_instance_t *)list_entry(q, snd_timer_instance_t, open_list);
+			ti = list_entry(q, snd_timer_instance_t, open_list);
 			snd_iprintf(buffer, "  Client %s : %s : lost interrupts %li\n",
 					ti->owner ? ti->owner : "unknown",
 					ti->flags & (SNDRV_TIMER_IFLG_START|SNDRV_TIMER_IFLG_RUNNING) ? "running" : "stopped",
@@ -1275,7 +1275,8 @@ static int snd_timer_user_next_device(snd_timer_id_t __user *_tid)
 		if (list_empty(&snd_timer_list))
 			snd_timer_user_zero_id(&id);
 		else {
-			timer = (snd_timer_t *)list_entry(snd_timer_list.next, snd_timer_t, device_list);
+			timer = list_entry(snd_timer_list.next,
+					   snd_timer_t, device_list);
 			snd_timer_user_copy_id(&id, timer);
 		}
 	} else {
@@ -1283,7 +1284,7 @@ static int snd_timer_user_next_device(snd_timer_id_t __user *_tid)
 		case SNDRV_TIMER_CLASS_GLOBAL:
 			id.device = id.device < 0 ? 0 : id.device + 1;
 			list_for_each(p, &snd_timer_list) {
-				timer = (snd_timer_t *)list_entry(p, snd_timer_t, device_list);
+				timer = list_entry(p, snd_timer_t, device_list);
 				if (timer->tmr_class > SNDRV_TIMER_CLASS_GLOBAL) {
 					snd_timer_user_copy_id(&id, timer);
 					break;
@@ -1312,7 +1313,7 @@ static int snd_timer_user_next_device(snd_timer_id_t __user *_tid)
 				}
 			}
 			list_for_each(p, &snd_timer_list) {
-				timer = (snd_timer_t *)list_entry(p, snd_timer_t, device_list);
+				timer = list_entry(p, snd_timer_t, device_list);
 				if (timer->tmr_class > id.dev_class) {
 					snd_timer_user_copy_id(&id, timer);
 					break;
@@ -1915,7 +1916,7 @@ static void __exit alsa_timer_exit(void)
 	snd_unregister_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0);
 	/* unregister the system timer */
 	list_for_each_safe(p, n, &snd_timer_list) {
-		snd_timer_t *timer = (snd_timer_t *)list_entry(p, snd_timer_t, device_list);
+		snd_timer_t *timer = list_entry(p, snd_timer_t, device_list);
 		snd_timer_unregister(timer);
 	}
 	if (snd_timer_proc_entry) {

commit de24214d0c8e78134875752619f99b9e5824c196
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Oct 12 17:12:31 2005 +0200

    [ALSA] timers: add module refcounting for global timers
    
    Modules: RTC timer driver,Timer Midlevel
    
    Add a module pointer to the timer structure and use it for refcounting
    instead of the card's module pointer to prevent the global timer
    modules (rtctimer and hpetimer) from being removed while in use.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index b02681eaea75..c8496c7b8df8 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -113,7 +113,7 @@ static snd_timer_instance_t *snd_timer_instance_new(char *owner, snd_timer_t *ti
 	INIT_LIST_HEAD(&timeri->slave_active_head);
 
 	timeri->timer = timer;
-	if (timer && timer->card && !try_module_get(timer->card->module)) {
+	if (timer && !try_module_get(timer->module)) {
 		kfree(timeri->owner);
 		kfree(timeri);
 		return NULL;
@@ -363,8 +363,8 @@ int snd_timer_close(snd_timer_instance_t * timeri)
 		timeri->private_free(timeri);
 	kfree(timeri->owner);
 	kfree(timeri);
-	if (timer && timer->card)
-		module_put(timer->card->module);
+	if (timer)
+		module_put(timer->module);
 	return 0;
 }
 
@@ -787,6 +787,7 @@ int snd_timer_new(snd_card_t *card, char *id, snd_timer_id_t *tid, snd_timer_t *
 	spin_lock_init(&timer->lock);
 	tasklet_init(&timer->task_queue, snd_timer_tasklet, (unsigned long)timer);
 	if (card != NULL) {
+		timer->module = card->module;
 		if ((err = snd_device_new(card, SNDRV_DEV_TIMER, timer, &ops)) < 0) {
 			snd_timer_free(timer);
 			return err;

commit 2fd43d1159d22395aae01836c4b13ee5265a9b6b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Oct 12 17:10:35 2005 +0200

    [ALSA] timer: fix timer instance memory allocation checks
    
    Modules: Timer Midlevel
    
    Add checks to return -ENOMEM in case snd_timer_instance_new() fails.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 8ecec9134acd..b02681eaea75 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -251,6 +251,10 @@ int snd_timer_open(snd_timer_instance_t **ti,
 		}
 		down(&register_mutex);
 		timeri = snd_timer_instance_new(owner, NULL);
+		if (!timeri) {
+			up(&register_mutex);
+			return -ENOMEM;
+		}
 		timeri->slave_class = tid->dev_sclass;
 		timeri->slave_id = tid->device;
 		timeri->flags |= SNDRV_TIMER_IFLG_SLAVE;
@@ -272,27 +276,29 @@ int snd_timer_open(snd_timer_instance_t **ti,
 		timer = snd_timer_find(tid);
 	}
 #endif
-	if (timer) {
-		if (!list_empty(&timer->open_list_head)) {
-			timeri = (snd_timer_instance_t *)list_entry(timer->open_list_head.next, snd_timer_instance_t, open_list);
-			if (timeri->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {
-				up(&register_mutex);
-				return -EBUSY;
-			}
-		}
-		timeri = snd_timer_instance_new(owner, timer);
-		if (timeri) {
-			timeri->slave_class = tid->dev_sclass;
-			timeri->slave_id = slave_id;
-			if (list_empty(&timer->open_list_head) && timer->hw.open)
-				timer->hw.open(timer);
-			list_add_tail(&timeri->open_list, &timer->open_list_head);
-			snd_timer_check_master(timeri);
-		}
-	} else {
+	if (!timer) {
 		up(&register_mutex);
 		return -ENODEV;
 	}
+	if (!list_empty(&timer->open_list_head)) {
+		timeri = list_entry(timer->open_list_head.next,
+				    snd_timer_instance_t, open_list);
+		if (timeri->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {
+			up(&register_mutex);
+			return -EBUSY;
+		}
+	}
+	timeri = snd_timer_instance_new(owner, timer);
+	if (!timeri) {
+		up(&register_mutex);
+		return -ENOMEM;
+	}
+	timeri->slave_class = tid->dev_sclass;
+	timeri->slave_id = slave_id;
+	if (list_empty(&timer->open_list_head) && timer->hw.open)
+		timer->hw.open(timer);
+	list_add_tail(&timeri->open_list, &timer->open_list_head);
+	snd_timer_check_master(timeri);
 	up(&register_mutex);
 	*ti = timeri;
 	return 0;

commit 07799e756c76ecd52cb01a812ba48b7d8ac67633
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:49:49 2005 +0200

    [ALSA] Use getnstimeofday()
    
    Modules: Documentation,PCM Midlevel,Timer Midlevel,ALSA Core
    
    Use the standard getnstimeofday() function instead of ALSA's own one.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 128916c66085..8ecec9134acd 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -385,7 +385,7 @@ static void snd_timer_notify1(snd_timer_instance_t *ti, enum sndrv_timer_event e
 	struct list_head *n;
 	struct timespec tstamp;
 
-	snd_timestamp_now(&tstamp, 1);
+	getnstimeofday(&tstamp);
 	snd_assert(event >= SNDRV_TIMER_EVENT_START && event <= SNDRV_TIMER_EVENT_PAUSE, return);
 	if (event == SNDRV_TIMER_EVENT_START || event == SNDRV_TIMER_EVENT_CONTINUE)
 		resolution = snd_timer_resolution(ti);
@@ -1156,14 +1156,14 @@ static void snd_timer_user_tinterrupt(snd_timer_instance_t *timeri,
 	struct timespec tstamp;
 	int prev, append = 0;
 
-	snd_timestamp_zero(&tstamp);
+	memset(&tstamp, 0, sizeof(tstamp));
 	spin_lock(&tu->qlock);
 	if ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION)|(1 << SNDRV_TIMER_EVENT_TICK))) == 0) {
 		spin_unlock(&tu->qlock);
 		return;
 	}
 	if (tu->last_resolution != resolution || ticks > 0)
-		snd_timestamp_now(&tstamp, 1);
+		getnstimeofday(&tstamp);
 	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) && tu->last_resolution != resolution) {
 		r1.event = SNDRV_TIMER_EVENT_RESOLUTION;
 		r1.tstamp = tstamp;

commit 7c22f1aaa23370bf9ba2dd3abbccbed70dced216
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:46:31 2005 +0200

    [ALSA] Remove snd_runtime_check() macro
    
    Remove snd_runtime_check() macro.
    This macro worsens the readability of codes.  They should be either
    normal if() or removable asserts.
    
    Also, the assert displays stack-dump, instead of only the last caller
    pointer.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 22b104624084..128916c66085 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -879,7 +879,8 @@ void snd_timer_notify(snd_timer_t *timer, enum sndrv_timer_event event, struct t
 	snd_timer_instance_t *ti, *ts;
 	struct list_head *p, *n;
 
-	snd_runtime_check(timer->hw.flags & SNDRV_TIMER_HW_SLAVE, return);	
+	if (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))
+		return;
 	snd_assert(event >= SNDRV_TIMER_EVENT_MSTART && event <= SNDRV_TIMER_EVENT_MRESUME, return);
 	spin_lock_irqsave(&timer->lock, flags);
 	if (event == SNDRV_TIMER_EVENT_MSTART ||

commit ca2c0966562cfbf9273167a5b60e8fddc24078d6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:20:23 2005 +0200

    [ALSA] Replace with kzalloc() - core stuff
    
    Control Midlevel,ALSA Core,HWDEP Midlevel,PCM Midlevel,RawMidi Midlevel
    Timer Midlevel,ALSA<-OSS emulation
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 4104f6e292e9..22b104624084 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -98,7 +98,7 @@ static void snd_timer_reschedule(snd_timer_t * timer, unsigned long ticks_left);
 static snd_timer_instance_t *snd_timer_instance_new(char *owner, snd_timer_t *timer)
 {
 	snd_timer_instance_t *timeri;
-	timeri = kcalloc(1, sizeof(*timeri), GFP_KERNEL);
+	timeri = kzalloc(sizeof(*timeri), GFP_KERNEL);
 	if (timeri == NULL)
 		return NULL;
 	timeri->owner = kstrdup(owner, GFP_KERNEL);
@@ -764,7 +764,7 @@ int snd_timer_new(snd_card_t *card, char *id, snd_timer_id_t *tid, snd_timer_t *
 	snd_assert(tid != NULL, return -EINVAL);
 	snd_assert(rtimer != NULL, return -EINVAL);
 	*rtimer = NULL;
-	timer = kcalloc(1, sizeof(*timer), GFP_KERNEL);
+	timer = kzalloc(sizeof(*timer), GFP_KERNEL);
 	if (timer == NULL)
 		return -ENOMEM;
 	timer->tmr_class = tid->dev_class;
@@ -1017,7 +1017,7 @@ static int snd_timer_register_system(void)
 		return err;
 	strcpy(timer->name, "system timer");
 	timer->hw = snd_timer_system;
-	priv = kcalloc(1, sizeof(*priv), GFP_KERNEL);
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (priv == NULL) {
 		snd_timer_free(timer);
 		return -ENOMEM;
@@ -1202,7 +1202,7 @@ static int snd_timer_user_open(struct inode *inode, struct file *file)
 {
 	snd_timer_user_t *tu;
 	
-	tu = kcalloc(1, sizeof(*tu), GFP_KERNEL);
+	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
 	if (tu == NULL)
 		return -ENOMEM;
 	spin_lock_init(&tu->qlock);
@@ -1513,7 +1513,7 @@ static int snd_timer_user_info(struct file *file, snd_timer_info_t __user *_info
 	t = tu->timeri->timer;
 	snd_assert(t != NULL, return -ENXIO);
 
-	info = kcalloc(1, sizeof(*info), GFP_KERNEL);
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (! info)
 		return -ENOMEM;
 	info->card = t->card ? t->card->number : -1;

commit 65d11d95515db3efb629202104cfc672476618b5
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Tue Aug 16 13:05:43 2005 +0200

    [ALSA] ALSA timer - fixed compilation
    
    Timer Midlevel
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 56bd383a06c2..4104f6e292e9 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1562,8 +1562,8 @@ static int snd_timer_user_params(struct file *file, snd_timer_params_t __user *_
 			      (1<<SNDRV_TIMER_EVENT_MSTART)|
 			      (1<<SNDRV_TIMER_EVENT_MSTOP)|
 			      (1<<SNDRV_TIMER_EVENT_MCONTINUE)|
-			      (1<<SNDRV_TIMER_EVENT_MPAUSE|
-			      (1<<SNDRV_TIMER_EVENT_MSUSPEND|
+			      (1<<SNDRV_TIMER_EVENT_MPAUSE)|
+			      (1<<SNDRV_TIMER_EVENT_MSUSPEND)|
 			      (1<<SNDRV_TIMER_EVENT_MRESUME))) {
 		err = -EINVAL;
 		goto _end;

commit a501dfa3a763451dedd583eb90a6c9e90d0e3a3c
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Tue Aug 16 11:09:05 2005 +0200

    [ALSA] Timer API - added SUSPEND/RESUME events
    
    PCM Midlevel,Timer Midlevel,ALSA Core
    - added SNDRV_TIMER_EVENT_SUSPEND / RESUME events
    - changed timer events from PAUSE / CONTINUE in PCM midlevel to SUSPEND / RESUME
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index c3997e047214..56bd383a06c2 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -880,9 +880,11 @@ void snd_timer_notify(snd_timer_t *timer, enum sndrv_timer_event event, struct t
 	struct list_head *p, *n;
 
 	snd_runtime_check(timer->hw.flags & SNDRV_TIMER_HW_SLAVE, return);	
-	snd_assert(event >= SNDRV_TIMER_EVENT_MSTART && event <= SNDRV_TIMER_EVENT_MPAUSE, return);
+	snd_assert(event >= SNDRV_TIMER_EVENT_MSTART && event <= SNDRV_TIMER_EVENT_MRESUME, return);
 	spin_lock_irqsave(&timer->lock, flags);
-	if (event == SNDRV_TIMER_EVENT_MSTART || event == SNDRV_TIMER_EVENT_MCONTINUE) {
+	if (event == SNDRV_TIMER_EVENT_MSTART ||
+	    event == SNDRV_TIMER_EVENT_MCONTINUE ||
+	    event == SNDRV_TIMER_EVENT_MRESUME) {
 		if (timer->hw.c_resolution)
 			resolution = timer->hw.c_resolution(timer);
 		else
@@ -1555,10 +1557,14 @@ static int snd_timer_user_params(struct file *file, snd_timer_params_t __user *_
 			      (1<<SNDRV_TIMER_EVENT_STOP)|
 			      (1<<SNDRV_TIMER_EVENT_CONTINUE)|
 			      (1<<SNDRV_TIMER_EVENT_PAUSE)|
+			      (1<<SNDRV_TIMER_EVENT_SUSPEND)|
+			      (1<<SNDRV_TIMER_EVENT_RESUME)|
 			      (1<<SNDRV_TIMER_EVENT_MSTART)|
 			      (1<<SNDRV_TIMER_EVENT_MSTOP)|
 			      (1<<SNDRV_TIMER_EVENT_MCONTINUE)|
-			      (1<<SNDRV_TIMER_EVENT_MPAUSE))) {
+			      (1<<SNDRV_TIMER_EVENT_MPAUSE|
+			      (1<<SNDRV_TIMER_EVENT_MSUSPEND|
+			      (1<<SNDRV_TIMER_EVENT_MRESUME))) {
 		err = -EINVAL;
 		goto _end;
 	}

commit a53fc188ec6fc406276799da465fe789c40d96b2
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Aug 11 15:59:17 2005 +0200

    [ALSA] make local objects static
    
    Memalloc module,PCM Midlevel,Timer Midlevel,GUS Library,AC97 Codec
    ALI5451 driver,RME9652 driver
    Make some functions/variables that are used in only one file static.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index cfaccd415b3b..c3997e047214 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -799,13 +799,13 @@ static int snd_timer_free(snd_timer_t *timer)
 	return 0;
 }
 
-int snd_timer_dev_free(snd_device_t *device)
+static int snd_timer_dev_free(snd_device_t *device)
 {
 	snd_timer_t *timer = device->device_data;
 	return snd_timer_free(timer);
 }
 
-int snd_timer_dev_register(snd_device_t *dev)
+static int snd_timer_dev_register(snd_device_t *dev)
 {
 	snd_timer_t *timer = dev->device_data;
 	snd_timer_t *timer1;

commit 543537bd922692bc978e2e356fcd8bfc9c2ee7d5
Author: Paulo Marques <pmarques@grupopie.com>
Date:   Thu Jun 23 00:09:02 2005 -0700

    [PATCH] create a kstrdup library function
    
    This patch creates a new kstrdup library function and changes the "local"
    implementations in several places to use this function.
    
    Most of the changes come from the sound and net subsystems.  The sound part
    had already been acknowledged by Takashi Iwai and the net part by David S.
    Miller.
    
    I left UML alone for now because I would need more time to read the code
    carefully before making changes there.
    
    Signed-off-by: Paulo Marques <pmarques@grupopie.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index b498e5482d77..cfaccd415b3b 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -26,6 +26,7 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/moduleparam.h>
+#include <linux/string.h>
 #include <sound/core.h>
 #include <sound/timer.h>
 #include <sound/control.h>
@@ -100,7 +101,7 @@ static snd_timer_instance_t *snd_timer_instance_new(char *owner, snd_timer_t *ti
 	timeri = kcalloc(1, sizeof(*timeri), GFP_KERNEL);
 	if (timeri == NULL)
 		return NULL;
-	timeri->owner = snd_kmalloc_strdup(owner, GFP_KERNEL);
+	timeri->owner = kstrdup(owner, GFP_KERNEL);
 	if (! timeri->owner) {
 		kfree(timeri);
 		return NULL;

commit 4d572776d4dfa2d5385a2ec3acec3cc059149e13
Author: Jesper Juhl <juhl-lkml@dif.dk>
Date:   Mon May 30 17:30:32 2005 +0200

    [ALSA] Remove redundant NULL checks before kfree
    
    Timer Midlevel,ALSA sequencer,ALSA<-OSS sequencer,Digigram VX core
    I2C tea6330t,GUS Library,VIA82xx driver,VIA82xx-modem driver
    CA0106 driver,CS46xx driver,EMU10K1/EMU10K2 driver,YMFPCI driver
    Digigram VX Pocket driver,Common EMU synth,USB generic driver,USB USX2Y
    Checking a pointer for NULL before calling kfree() on it is redundant,
    kfree() deals with NULL pointers just fine.
    This patch removes such checks from sound/
    
    This patch also makes another, but closely related, change.
    It avoids casting pointers about to be kfree()'ed.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index d67a5e91a108..b498e5482d77 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1469,14 +1469,10 @@ static int snd_timer_user_tselect(struct file *file, snd_timer_select_t __user *
 	if ((err = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid)) < 0)
 		goto __err;
 
-	if (tu->queue) {
-		kfree(tu->queue);
-		tu->queue = NULL;
-	}
-	if (tu->tqueue) {
-		kfree(tu->tqueue);
-		tu->tqueue = NULL;
-	}
+	kfree(tu->queue);
+	tu->queue = NULL;
+	kfree(tu->tqueue);
+	tu->tqueue = NULL;
 	if (tu->tread) {
 		tu->tqueue = (snd_timer_tread_t *)kmalloc(tu->queue_size * sizeof(snd_timer_tread_t), GFP_KERNEL);
 		if (tu->tqueue == NULL)

commit 123992f728785e05f385d23893bd5ec69871aeb4
Author: Adrian Bunk <bunk@stusta.de>
Date:   Wed May 18 18:02:04 2005 +0200

    [ALSA] sound/core/: possible cleanups
    
    PCM Midlevel,ALSA Core,Timer Midlevel,ALSA sequencer,Virtual Midi
    This patch contains the following possible cleanups:
    - make needlessly global code static
    - #if 0 the following unused global functions
    - remove the following unneeded EXPORT_SYMBOL's
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index cb011a1d4c3e..d67a5e91a108 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -845,7 +845,7 @@ int snd_timer_dev_register(snd_device_t *dev)
 	return 0;
 }
 
-int snd_timer_unregister(snd_timer_t *timer)
+static int snd_timer_unregister(snd_timer_t *timer)
 {
 	struct list_head *p, *n;
 	snd_timer_instance_t *ti;
@@ -946,11 +946,6 @@ struct snd_timer_system_private {
 	unsigned long correction;
 };
 
-unsigned int snd_timer_system_resolution(void)
-{
-	return 1000000000L / HZ;
-}
-
 static void snd_timer_s_function(unsigned long data)
 {
 	snd_timer_t *timer = (snd_timer_t *)data;
@@ -1938,4 +1933,3 @@ EXPORT_SYMBOL(snd_timer_global_free);
 EXPORT_SYMBOL(snd_timer_global_register);
 EXPORT_SYMBOL(snd_timer_global_unregister);
 EXPORT_SYMBOL(snd_timer_interrupt);
-EXPORT_SYMBOL(snd_timer_system_resolution);

commit d138b44589cc180418f5a20cb0ecfe338123d86c
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Mon May 16 13:51:39 2005 +0200

    [ALSA] fixed PAUSE ioctl for user space interface
    
    Timer Midlevel
    - fixed traditional cut-n-paste error
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 305e39d74092..cb011a1d4c3e 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1687,7 +1687,7 @@ static int snd_timer_user_pause(struct file *file)
 		
 	tu = file->private_data;
 	snd_assert(tu->timeri != NULL, return -ENXIO);
-	return (err = snd_timer_continue(tu->timeri)) < 0 ? err : 0;
+	return (err = snd_timer_pause(tu->timeri)) < 0 ? err : 0;
 }
 
 enum {

commit 8c50b37c04a026ab6641ecb7eaf0fd479798e8b8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun May 15 15:43:54 2005 +0200

    [ALSA] Change some timer ioctls due to confliction
    
    Timer Midlevel,ALSA Core
    Change values of some timer ioctls to avoid confliction with FIO* ioctls.
    The protocol version is increased to indicate this change.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index 48aebdf6550b..305e39d74092 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1690,6 +1690,13 @@ static int snd_timer_user_pause(struct file *file)
 	return (err = snd_timer_continue(tu->timeri)) < 0 ? err : 0;
 }
 
+enum {
+	SNDRV_TIMER_IOCTL_START_OLD = _IO('T', 0x20),
+	SNDRV_TIMER_IOCTL_STOP_OLD = _IO('T', 0x21),
+	SNDRV_TIMER_IOCTL_CONTINUE_OLD = _IO('T', 0x22),
+	SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),
+};
+
 static long snd_timer_user_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	snd_timer_user_t *tu;
@@ -1734,12 +1741,16 @@ static long snd_timer_user_ioctl(struct file *file, unsigned int cmd, unsigned l
 	case SNDRV_TIMER_IOCTL_STATUS:
 		return snd_timer_user_status(file, argp);
 	case SNDRV_TIMER_IOCTL_START:
+	case SNDRV_TIMER_IOCTL_START_OLD:
 		return snd_timer_user_start(file);
 	case SNDRV_TIMER_IOCTL_STOP:
+	case SNDRV_TIMER_IOCTL_STOP_OLD:
 		return snd_timer_user_stop(file);
 	case SNDRV_TIMER_IOCTL_CONTINUE:
+	case SNDRV_TIMER_IOCTL_CONTINUE_OLD:
 		return snd_timer_user_continue(file);
 	case SNDRV_TIMER_IOCTL_PAUSE:
+	case SNDRV_TIMER_IOCTL_PAUSE_OLD:
 		return snd_timer_user_pause(file);
 	}
 	return -ENOTTY;

commit 15790a6be14852850ee7cbd791225fa51750d8af
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun May 15 15:04:14 2005 +0200

    [ALSA] Add missing PAUSE ioctl
    
    Timer Midlevel
    Added the missing implemenation of TIMER PAUSE ioctl.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index be6d37af76d8..48aebdf6550b 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -1680,6 +1680,16 @@ static int snd_timer_user_continue(struct file *file)
 	return (err = snd_timer_continue(tu->timeri)) < 0 ? err : 0;
 }
 
+static int snd_timer_user_pause(struct file *file)
+{
+	int err;
+	snd_timer_user_t *tu;
+		
+	tu = file->private_data;
+	snd_assert(tu->timeri != NULL, return -ENXIO);
+	return (err = snd_timer_continue(tu->timeri)) < 0 ? err : 0;
+}
+
 static long snd_timer_user_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	snd_timer_user_t *tu;
@@ -1729,6 +1739,8 @@ static long snd_timer_user_ioctl(struct file *file, unsigned int cmd, unsigned l
 		return snd_timer_user_stop(file);
 	case SNDRV_TIMER_IOCTL_CONTINUE:
 		return snd_timer_user_continue(file);
+	case SNDRV_TIMER_IOCTL_PAUSE:
+		return snd_timer_user_pause(file);
 	}
 	return -ENOTTY;
 }

commit c1935b4d6edf1c4d78bf660992d00b2d8fcb9b59
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Mon Apr 4 16:44:58 2005 +0200

    [ALSA] timer - added tread semaphore
    
    Timer Midlevel
    
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/timer.c b/sound/core/timer.c
index fa762ca439be..be6d37af76d8 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -69,6 +69,7 @@ typedef struct {
 	struct timespec tstamp;		/* trigger tstamp */
 	wait_queue_head_t qchange_sleep;
 	struct fasync_struct *fasync;
+	struct semaphore tread_sem;
 } snd_timer_user_t;
 
 /* list of timers */
@@ -1208,6 +1209,7 @@ static int snd_timer_user_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 	spin_lock_init(&tu->qlock);
 	init_waitqueue_head(&tu->qchange_sleep);
+	init_MUTEX(&tu->tread_sem);
 	tu->ticks = 1;
 	tu->queue_size = 128;
 	tu->queue = (snd_timer_read_t *)kmalloc(tu->queue_size * sizeof(snd_timer_read_t), GFP_KERNEL);
@@ -1454,18 +1456,23 @@ static int snd_timer_user_tselect(struct file *file, snd_timer_select_t __user *
 	snd_timer_user_t *tu;
 	snd_timer_select_t tselect;
 	char str[32];
-	int err;
+	int err = 0;
 	
 	tu = file->private_data;
-	if (tu->timeri)
+	down(&tu->tread_sem);
+	if (tu->timeri) {
 		snd_timer_close(tu->timeri);
-	if (copy_from_user(&tselect, _tselect, sizeof(tselect)))
-		return -EFAULT;
+		tu->timeri = NULL;
+	}
+	if (copy_from_user(&tselect, _tselect, sizeof(tselect))) {
+		err = -EFAULT;
+		goto __err;
+	}
 	sprintf(str, "application %i", current->pid);
 	if (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)
 		tselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;
 	if ((err = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid)) < 0)
-		return err;
+		goto __err;
 
 	if (tu->queue) {
 		kfree(tu->queue);
@@ -1477,23 +1484,27 @@ static int snd_timer_user_tselect(struct file *file, snd_timer_select_t __user *
 	}
 	if (tu->tread) {
 		tu->tqueue = (snd_timer_tread_t *)kmalloc(tu->queue_size * sizeof(snd_timer_tread_t), GFP_KERNEL);
-		if (tu->tqueue == NULL) {
-			snd_timer_close(tu->timeri);
-			return -ENOMEM;
-		}
+		if (tu->tqueue == NULL)
+			err = -ENOMEM;
 	} else {
 		tu->queue = (snd_timer_read_t *)kmalloc(tu->queue_size * sizeof(snd_timer_read_t), GFP_KERNEL);
-		if (tu->queue == NULL) {
-			snd_timer_close(tu->timeri);
-			return -ENOMEM;
-		}
+		if (tu->queue == NULL)
+			err = -ENOMEM;
 	}
 	
-	tu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;
-	tu->timeri->callback = tu->tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt;
-	tu->timeri->ccallback = snd_timer_user_ccallback;
-	tu->timeri->callback_data = (void *)tu;
-	return 0;
+      	if (err < 0) {
+		snd_timer_close(tu->timeri);
+      		tu->timeri = NULL;
+      	} else {
+		tu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;
+		tu->timeri->callback = tu->tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt;
+		tu->timeri->ccallback = snd_timer_user_ccallback;
+		tu->timeri->callback_data = (void *)tu;
+	}
+
+      __err:
+      	up(&tu->tread_sem);
+	return err;
 }
 
 static int snd_timer_user_info(struct file *file, snd_timer_info_t __user *_info)
@@ -1685,11 +1696,17 @@ static long snd_timer_user_ioctl(struct file *file, unsigned int cmd, unsigned l
 	{
 		int xarg;
 		
-		if (tu->timeri)		/* too late */
+		down(&tu->tread_sem);
+		if (tu->timeri)	{	/* too late */
+			up(&tu->tread_sem);
 			return -EBUSY;
-		if (get_user(xarg, p))
+		}
+		if (get_user(xarg, p)) {
+			up(&tu->tread_sem);
 			return -EFAULT;
+		}
 		tu->tread = xarg ? 1 : 0;
+		up(&tu->tread_sem);
 		return 0;
 	}
 	case SNDRV_TIMER_IOCTL_GINFO:

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/timer.c b/sound/core/timer.c
new file mode 100644
index 000000000000..fa762ca439be
--- /dev/null
+++ b/sound/core/timer.c
@@ -0,0 +1,1901 @@
+/*
+ *  Timers abstract layer
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/timer.h>
+#include <sound/control.h>
+#include <sound/info.h>
+#include <sound/minors.h>
+#include <sound/initval.h>
+#include <linux/kmod.h>
+#ifdef CONFIG_KERNELD
+#include <linux/kerneld.h>
+#endif
+
+#if defined(CONFIG_SND_HPET) || defined(CONFIG_SND_HPET_MODULE)
+#define DEFAULT_TIMER_LIMIT 3
+#elif defined(CONFIG_SND_RTCTIMER) || defined(CONFIG_SND_RTCTIMER_MODULE)
+#define DEFAULT_TIMER_LIMIT 2
+#else
+#define DEFAULT_TIMER_LIMIT 1
+#endif
+
+static int timer_limit = DEFAULT_TIMER_LIMIT;
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, Takashi Iwai <tiwai@suse.de>");
+MODULE_DESCRIPTION("ALSA timer interface");
+MODULE_LICENSE("GPL");
+module_param(timer_limit, int, 0444);
+MODULE_PARM_DESC(timer_limit, "Maximum global timers in system.");
+
+typedef struct {
+	snd_timer_instance_t *timeri;
+	int tread;			/* enhanced read with timestamps and events */
+	unsigned long ticks;
+	unsigned long overrun;
+	int qhead;
+	int qtail;
+	int qused;
+	int queue_size;
+	snd_timer_read_t *queue;
+	snd_timer_tread_t *tqueue;
+	spinlock_t qlock;
+	unsigned long last_resolution;
+	unsigned int filter;
+	struct timespec tstamp;		/* trigger tstamp */
+	wait_queue_head_t qchange_sleep;
+	struct fasync_struct *fasync;
+} snd_timer_user_t;
+
+/* list of timers */
+static LIST_HEAD(snd_timer_list);
+
+/* list of slave instances */
+static LIST_HEAD(snd_timer_slave_list);
+
+/* lock for slave active lists */
+static DEFINE_SPINLOCK(slave_active_lock);
+
+static DECLARE_MUTEX(register_mutex);
+
+static int snd_timer_free(snd_timer_t *timer);
+static int snd_timer_dev_free(snd_device_t *device);
+static int snd_timer_dev_register(snd_device_t *device);
+static int snd_timer_dev_unregister(snd_device_t *device);
+
+static void snd_timer_reschedule(snd_timer_t * timer, unsigned long ticks_left);
+
+/*
+ * create a timer instance with the given owner string.
+ * when timer is not NULL, increments the module counter
+ */
+static snd_timer_instance_t *snd_timer_instance_new(char *owner, snd_timer_t *timer)
+{
+	snd_timer_instance_t *timeri;
+	timeri = kcalloc(1, sizeof(*timeri), GFP_KERNEL);
+	if (timeri == NULL)
+		return NULL;
+	timeri->owner = snd_kmalloc_strdup(owner, GFP_KERNEL);
+	if (! timeri->owner) {
+		kfree(timeri);
+		return NULL;
+	}
+	INIT_LIST_HEAD(&timeri->open_list);
+	INIT_LIST_HEAD(&timeri->active_list);
+	INIT_LIST_HEAD(&timeri->ack_list);
+	INIT_LIST_HEAD(&timeri->slave_list_head);
+	INIT_LIST_HEAD(&timeri->slave_active_head);
+
+	timeri->timer = timer;
+	if (timer && timer->card && !try_module_get(timer->card->module)) {
+		kfree(timeri->owner);
+		kfree(timeri);
+		return NULL;
+	}
+
+	return timeri;
+}
+
+/*
+ * find a timer instance from the given timer id
+ */
+static snd_timer_t *snd_timer_find(snd_timer_id_t *tid)
+{
+	snd_timer_t *timer = NULL;
+	struct list_head *p;
+
+	list_for_each(p, &snd_timer_list) {
+		timer = (snd_timer_t *)list_entry(p, snd_timer_t, device_list);
+
+		if (timer->tmr_class != tid->dev_class)
+			continue;
+		if ((timer->tmr_class == SNDRV_TIMER_CLASS_CARD ||
+		     timer->tmr_class == SNDRV_TIMER_CLASS_PCM) &&
+		    (timer->card == NULL ||
+		     timer->card->number != tid->card))
+			continue;
+		if (timer->tmr_device != tid->device)
+			continue;
+		if (timer->tmr_subdevice != tid->subdevice)
+			continue;
+		return timer;
+	}
+	return NULL;
+}
+
+#ifdef CONFIG_KMOD
+
+static void snd_timer_request(snd_timer_id_t *tid)
+{
+	if (! current->fs->root)
+		return;
+	switch (tid->dev_class) {
+	case SNDRV_TIMER_CLASS_GLOBAL:
+		if (tid->device < timer_limit)
+			request_module("snd-timer-%i", tid->device);
+		break;
+	case SNDRV_TIMER_CLASS_CARD:
+	case SNDRV_TIMER_CLASS_PCM:
+		if (tid->card < snd_ecards_limit)
+			request_module("snd-card-%i", tid->card);
+		break;
+	default:
+		break;
+	}
+}
+
+#endif
+
+/*
+ * look for a master instance matching with the slave id of the given slave.
+ * when found, relink the open_link of the slave.
+ *
+ * call this with register_mutex down.
+ */
+static void snd_timer_check_slave(snd_timer_instance_t *slave)
+{
+	snd_timer_t *timer;
+	snd_timer_instance_t *master;
+	struct list_head *p, *q;
+
+	/* FIXME: it's really dumb to look up all entries.. */
+	list_for_each(p, &snd_timer_list) {
+		timer = (snd_timer_t *)list_entry(p, snd_timer_t, device_list);
+		list_for_each(q, &timer->open_list_head) {
+			master = (snd_timer_instance_t *)list_entry(q, snd_timer_instance_t, open_list);
+			if (slave->slave_class == master->slave_class &&
+			    slave->slave_id == master->slave_id) {
+				list_del(&slave->open_list);
+				list_add_tail(&slave->open_list, &master->slave_list_head);
+				spin_lock_irq(&slave_active_lock);
+				slave->master = master;
+				slave->timer = master->timer;
+				spin_unlock_irq(&slave_active_lock);
+				return;
+			}
+		}
+	}
+}
+
+/*
+ * look for slave instances matching with the slave id of the given master.
+ * when found, relink the open_link of slaves.
+ *
+ * call this with register_mutex down.
+ */
+static void snd_timer_check_master(snd_timer_instance_t *master)
+{
+	snd_timer_instance_t *slave;
+	struct list_head *p, *n;
+
+	/* check all pending slaves */
+	list_for_each_safe(p, n, &snd_timer_slave_list) {
+		slave = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, open_list);
+		if (slave->slave_class == master->slave_class &&
+		    slave->slave_id == master->slave_id) {
+			list_del(p);
+			list_add_tail(p, &master->slave_list_head);
+			spin_lock_irq(&slave_active_lock);
+			slave->master = master;
+			slave->timer = master->timer;
+			if (slave->flags & SNDRV_TIMER_IFLG_RUNNING)
+				list_add_tail(&slave->active_list, &master->slave_active_head);
+			spin_unlock_irq(&slave_active_lock);
+		}
+	}
+}
+
+/*
+ * open a timer instance
+ * when opening a master, the slave id must be here given.
+ */
+int snd_timer_open(snd_timer_instance_t **ti,
+		   char *owner, snd_timer_id_t *tid,
+		   unsigned int slave_id)
+{
+	snd_timer_t *timer;
+	snd_timer_instance_t *timeri = NULL;
+	
+	if (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {
+		/* open a slave instance */
+		if (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||
+		    tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {
+			snd_printd("invalid slave class %i\n", tid->dev_sclass);
+			return -EINVAL;
+		}
+		down(&register_mutex);
+		timeri = snd_timer_instance_new(owner, NULL);
+		timeri->slave_class = tid->dev_sclass;
+		timeri->slave_id = tid->device;
+		timeri->flags |= SNDRV_TIMER_IFLG_SLAVE;
+		list_add_tail(&timeri->open_list, &snd_timer_slave_list);
+		snd_timer_check_slave(timeri);
+		up(&register_mutex);
+		*ti = timeri;
+		return 0;
+	}
+
+	/* open a master instance */
+	down(&register_mutex);
+	timer = snd_timer_find(tid);
+#ifdef CONFIG_KMOD
+	if (timer == NULL) {
+		up(&register_mutex);
+		snd_timer_request(tid);
+		down(&register_mutex);
+		timer = snd_timer_find(tid);
+	}
+#endif
+	if (timer) {
+		if (!list_empty(&timer->open_list_head)) {
+			timeri = (snd_timer_instance_t *)list_entry(timer->open_list_head.next, snd_timer_instance_t, open_list);
+			if (timeri->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {
+				up(&register_mutex);
+				return -EBUSY;
+			}
+		}
+		timeri = snd_timer_instance_new(owner, timer);
+		if (timeri) {
+			timeri->slave_class = tid->dev_sclass;
+			timeri->slave_id = slave_id;
+			if (list_empty(&timer->open_list_head) && timer->hw.open)
+				timer->hw.open(timer);
+			list_add_tail(&timeri->open_list, &timer->open_list_head);
+			snd_timer_check_master(timeri);
+		}
+	} else {
+		up(&register_mutex);
+		return -ENODEV;
+	}
+	up(&register_mutex);
+	*ti = timeri;
+	return 0;
+}
+
+static int _snd_timer_stop(snd_timer_instance_t * timeri, int keep_flag, enum sndrv_timer_event event);
+
+/*
+ * close a timer instance
+ */
+int snd_timer_close(snd_timer_instance_t * timeri)
+{
+	snd_timer_t *timer = NULL;
+	struct list_head *p, *n;
+	snd_timer_instance_t *slave;
+
+	snd_assert(timeri != NULL, return -ENXIO);
+
+	/* force to stop the timer */
+	snd_timer_stop(timeri);
+
+	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
+		/* wait, until the active callback is finished */
+		spin_lock_irq(&slave_active_lock);
+		while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
+			spin_unlock_irq(&slave_active_lock);
+			udelay(10);
+			spin_lock_irq(&slave_active_lock);
+		}
+		spin_unlock_irq(&slave_active_lock);
+		down(&register_mutex);
+		list_del(&timeri->open_list);
+		up(&register_mutex);
+	} else {
+		timer = timeri->timer;
+		/* wait, until the active callback is finished */
+		spin_lock_irq(&timer->lock);
+		while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
+			spin_unlock_irq(&timer->lock);
+			udelay(10);
+			spin_lock_irq(&timer->lock);
+		}
+		spin_unlock_irq(&timer->lock);
+		down(&register_mutex);
+		list_del(&timeri->open_list);
+		if (timer && list_empty(&timer->open_list_head) && timer->hw.close)
+			timer->hw.close(timer);
+		/* remove slave links */
+		list_for_each_safe(p, n, &timeri->slave_list_head) {
+			slave = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, open_list);
+			spin_lock_irq(&slave_active_lock);
+			_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);
+			list_del(p);
+			list_add_tail(p, &snd_timer_slave_list);
+			slave->master = NULL;
+			slave->timer = NULL;
+			spin_unlock_irq(&slave_active_lock);
+		}
+		up(&register_mutex);
+	}
+	if (timeri->private_free)
+		timeri->private_free(timeri);
+	kfree(timeri->owner);
+	kfree(timeri);
+	if (timer && timer->card)
+		module_put(timer->card->module);
+	return 0;
+}
+
+unsigned long snd_timer_resolution(snd_timer_instance_t * timeri)
+{
+	snd_timer_t * timer;
+
+	if (timeri == NULL)
+		return 0;
+	if ((timer = timeri->timer) != NULL) {
+		if (timer->hw.c_resolution)
+			return timer->hw.c_resolution(timer);
+		return timer->hw.resolution;
+	}
+	return 0;
+}
+
+static void snd_timer_notify1(snd_timer_instance_t *ti, enum sndrv_timer_event event)
+{
+	snd_timer_t *timer;
+	unsigned long flags;
+	unsigned long resolution = 0;
+	snd_timer_instance_t *ts;
+	struct list_head *n;
+	struct timespec tstamp;
+
+	snd_timestamp_now(&tstamp, 1);
+	snd_assert(event >= SNDRV_TIMER_EVENT_START && event <= SNDRV_TIMER_EVENT_PAUSE, return);
+	if (event == SNDRV_TIMER_EVENT_START || event == SNDRV_TIMER_EVENT_CONTINUE)
+		resolution = snd_timer_resolution(ti);
+	if (ti->ccallback)
+		ti->ccallback(ti, SNDRV_TIMER_EVENT_START, &tstamp, resolution);
+	if (ti->flags & SNDRV_TIMER_IFLG_SLAVE)
+		return;
+	timer = ti->timer;
+	if (timer == NULL)
+		return;
+	if (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)
+		return;
+	spin_lock_irqsave(&timer->lock, flags);
+	list_for_each(n, &ti->slave_active_head) {
+		ts = (snd_timer_instance_t *)list_entry(n, snd_timer_instance_t, active_list);
+		if (ts->ccallback)
+			ts->ccallback(ti, event + 100, &tstamp, resolution);
+	}
+	spin_unlock_irqrestore(&timer->lock, flags);
+}
+
+static int snd_timer_start1(snd_timer_t *timer, snd_timer_instance_t *timeri, unsigned long sticks)
+{
+	list_del(&timeri->active_list);
+	list_add_tail(&timeri->active_list, &timer->active_list_head);
+	if (timer->running) {
+		if (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)
+			goto __start_now;
+		timer->flags |= SNDRV_TIMER_FLG_RESCHED;
+		timeri->flags |= SNDRV_TIMER_IFLG_START;
+		return 1;	/* delayed start */
+	} else {
+		timer->sticks = sticks;
+		timer->hw.start(timer);
+	      __start_now:
+		timer->running++;
+		timeri->flags |= SNDRV_TIMER_IFLG_RUNNING;
+		return 0;
+	}
+}
+
+static int snd_timer_start_slave(snd_timer_instance_t *timeri)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&slave_active_lock, flags);
+	timeri->flags |= SNDRV_TIMER_IFLG_RUNNING;
+	if (timeri->master)
+		list_add_tail(&timeri->active_list, &timeri->master->slave_active_head);
+	spin_unlock_irqrestore(&slave_active_lock, flags);
+	return 1; /* delayed start */
+}
+
+/*
+ *  start the timer instance
+ */ 
+int snd_timer_start(snd_timer_instance_t * timeri, unsigned int ticks)
+{
+	snd_timer_t *timer;
+	int result = -EINVAL;
+	unsigned long flags;
+
+	if (timeri == NULL || ticks < 1)
+		return -EINVAL;
+	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
+		result = snd_timer_start_slave(timeri);
+		snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);
+		return result;
+	}
+	timer = timeri->timer;
+	if (timer == NULL)
+		return -EINVAL;
+	spin_lock_irqsave(&timer->lock, flags);
+	timeri->ticks = timeri->cticks = ticks;
+	timeri->pticks = 0;
+	result = snd_timer_start1(timer, timeri, ticks);
+	spin_unlock_irqrestore(&timer->lock, flags);
+	snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);
+	return result;
+}
+
+static int _snd_timer_stop(snd_timer_instance_t * timeri, int keep_flag, enum sndrv_timer_event event)
+{
+	snd_timer_t *timer;
+	unsigned long flags;
+
+	snd_assert(timeri != NULL, return -ENXIO);
+
+	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
+		if (!keep_flag) {
+			spin_lock_irqsave(&slave_active_lock, flags);
+			timeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
+			spin_unlock_irqrestore(&slave_active_lock, flags);
+		}
+		goto __end;
+	}
+	timer = timeri->timer;
+	if (!timer)
+		return -EINVAL;
+	spin_lock_irqsave(&timer->lock, flags);
+	list_del_init(&timeri->ack_list);
+	list_del_init(&timeri->active_list);
+	if ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&
+	    !(--timer->running)) {
+		timer->hw.stop(timer);
+		if (timer->flags & SNDRV_TIMER_FLG_RESCHED) {
+			timer->flags &= ~SNDRV_TIMER_FLG_RESCHED;
+			snd_timer_reschedule(timer, 0);
+			if (timer->flags & SNDRV_TIMER_FLG_CHANGE) {
+				timer->flags &= ~SNDRV_TIMER_FLG_CHANGE;
+				timer->hw.start(timer);
+			}
+		}
+	}
+	if (!keep_flag)
+		timeri->flags &= ~(SNDRV_TIMER_IFLG_RUNNING|SNDRV_TIMER_IFLG_START);
+	spin_unlock_irqrestore(&timer->lock, flags);
+      __end:
+	if (event != SNDRV_TIMER_EVENT_RESOLUTION)
+		snd_timer_notify1(timeri, event);
+	return 0;
+}
+
+/*
+ * stop the timer instance.
+ *
+ * do not call this from the timer callback!
+ */
+int snd_timer_stop(snd_timer_instance_t * timeri)
+{
+	snd_timer_t *timer;
+	unsigned long flags;
+	int err;
+
+	err = _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_STOP);
+	if (err < 0)
+		return err;
+	timer = timeri->timer;
+	spin_lock_irqsave(&timer->lock, flags);
+	timeri->cticks = timeri->ticks;
+	timeri->pticks = 0;
+	spin_unlock_irqrestore(&timer->lock, flags);
+	return 0;
+}
+
+/*
+ * start again..  the tick is kept.
+ */
+int snd_timer_continue(snd_timer_instance_t * timeri)
+{
+	snd_timer_t *timer;
+	int result = -EINVAL;
+	unsigned long flags;
+
+	if (timeri == NULL)
+		return result;
+	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)
+		return snd_timer_start_slave(timeri);
+	timer = timeri->timer;
+	if (! timer)
+		return -EINVAL;
+	spin_lock_irqsave(&timer->lock, flags);
+	if (!timeri->cticks)
+		timeri->cticks = 1;
+	timeri->pticks = 0;
+	result = snd_timer_start1(timer, timeri, timer->sticks);
+	spin_unlock_irqrestore(&timer->lock, flags);
+	snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_CONTINUE);
+	return result;
+}
+
+/*
+ * pause.. remember the ticks left
+ */
+int snd_timer_pause(snd_timer_instance_t * timeri)
+{
+	return _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_PAUSE);
+}
+
+/*
+ * reschedule the timer
+ *
+ * start pending instances and check the scheduling ticks.
+ * when the scheduling ticks is changed set CHANGE flag to reprogram the timer.
+ */
+static void snd_timer_reschedule(snd_timer_t * timer, unsigned long ticks_left)
+{
+	snd_timer_instance_t *ti;
+	unsigned long ticks = ~0UL;
+	struct list_head *p;
+
+	list_for_each(p, &timer->active_list_head) {
+		ti = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, active_list);
+		if (ti->flags & SNDRV_TIMER_IFLG_START) {
+			ti->flags &= ~SNDRV_TIMER_IFLG_START;
+			ti->flags |= SNDRV_TIMER_IFLG_RUNNING;
+			timer->running++;
+		}
+		if (ti->flags & SNDRV_TIMER_IFLG_RUNNING) {
+			if (ticks > ti->cticks)
+				ticks = ti->cticks;
+		}
+	}
+	if (ticks == ~0UL) {
+		timer->flags &= ~SNDRV_TIMER_FLG_RESCHED;
+		return;
+	}
+	if (ticks > timer->hw.ticks)
+		ticks = timer->hw.ticks;
+	if (ticks_left != ticks)
+		timer->flags |= SNDRV_TIMER_FLG_CHANGE;
+	timer->sticks = ticks;
+}
+
+/*
+ * timer tasklet
+ *
+ */
+static void snd_timer_tasklet(unsigned long arg)
+{
+	snd_timer_t *timer = (snd_timer_t *) arg;
+	snd_timer_instance_t *ti;
+	struct list_head *p;
+	unsigned long resolution, ticks;
+
+	spin_lock(&timer->lock);
+	/* now process all callbacks */
+	while (!list_empty(&timer->sack_list_head)) {
+		p = timer->sack_list_head.next;		/* get first item */
+		ti = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, ack_list);
+
+		/* remove from ack_list and make empty */
+		list_del_init(p);
+		
+		ticks = ti->pticks;
+		ti->pticks = 0;
+		resolution = ti->resolution;
+
+		ti->flags |= SNDRV_TIMER_IFLG_CALLBACK;
+		spin_unlock(&timer->lock);
+		if (ti->callback)
+			ti->callback(ti, resolution, ticks);
+		spin_lock(&timer->lock);
+		ti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;
+	}
+	spin_unlock(&timer->lock);
+}
+
+/*
+ * timer interrupt
+ *
+ * ticks_left is usually equal to timer->sticks.
+ *
+ */
+void snd_timer_interrupt(snd_timer_t * timer, unsigned long ticks_left)
+{
+	snd_timer_instance_t *ti, *ts;
+	unsigned long resolution, ticks;
+	struct list_head *p, *q, *n;
+	int use_tasklet = 0;
+
+	if (timer == NULL)
+		return;
+
+	spin_lock(&timer->lock);
+
+	/* remember the current resolution */
+	if (timer->hw.c_resolution)
+		resolution = timer->hw.c_resolution(timer);
+	else
+		resolution = timer->hw.resolution;
+
+	/* loop for all active instances
+	 * here we cannot use list_for_each because the active_list of a processed
+	 * instance is relinked to done_list_head before callback is called.
+	 */
+	list_for_each_safe(p, n, &timer->active_list_head) {
+		ti = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, active_list);
+		if (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING))
+			continue;
+		ti->pticks += ticks_left;
+		ti->resolution = resolution;
+		if (ti->cticks < ticks_left)
+			ti->cticks = 0;
+		else
+			ti->cticks -= ticks_left;
+		if (ti->cticks) /* not expired */
+			continue;
+		if (ti->flags & SNDRV_TIMER_IFLG_AUTO) {
+			ti->cticks = ti->ticks;
+		} else {
+			ti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
+			if (--timer->running)
+				list_del(p);
+		}
+		if (list_empty(&ti->ack_list)) {
+			if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||
+			    (ti->flags & SNDRV_TIMER_IFLG_FAST)) {
+				list_add_tail(&ti->ack_list, &timer->ack_list_head);
+			} else {
+				list_add_tail(&ti->ack_list, &timer->sack_list_head);
+			}
+		}
+		list_for_each(q, &ti->slave_active_head) {
+			ts = (snd_timer_instance_t *)list_entry(q, snd_timer_instance_t, active_list);
+			ts->pticks = ti->pticks;
+			ts->resolution = resolution;
+			if (list_empty(&ts->ack_list)) {
+				if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||
+				    (ti->flags & SNDRV_TIMER_IFLG_FAST)) {
+					list_add_tail(&ts->ack_list, &timer->ack_list_head);
+				} else {
+					list_add_tail(&ts->ack_list, &timer->sack_list_head);
+				}
+			}
+		}
+	}
+	if (timer->flags & SNDRV_TIMER_FLG_RESCHED)
+		snd_timer_reschedule(timer, ticks_left);
+	if (timer->running) {
+		if (timer->hw.flags & SNDRV_TIMER_HW_STOP) {
+			timer->hw.stop(timer);
+			timer->flags |= SNDRV_TIMER_FLG_CHANGE;
+		}
+		if (!(timer->hw.flags & SNDRV_TIMER_HW_AUTO) ||
+		    (timer->flags & SNDRV_TIMER_FLG_CHANGE)) {
+			/* restart timer */
+			timer->flags &= ~SNDRV_TIMER_FLG_CHANGE;
+			timer->hw.start(timer);
+		}
+	} else {
+		timer->hw.stop(timer);
+	}
+
+	/* now process all fast callbacks */
+	while (!list_empty(&timer->ack_list_head)) {
+		p = timer->ack_list_head.next;		/* get first item */
+		ti = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, ack_list);
+		
+		/* remove from ack_list and make empty */
+		list_del_init(p);
+		
+		ticks = ti->pticks;
+		ti->pticks = 0;
+
+		ti->flags |= SNDRV_TIMER_IFLG_CALLBACK;
+		spin_unlock(&timer->lock);
+		if (ti->callback)
+			ti->callback(ti, resolution, ticks);
+		spin_lock(&timer->lock);
+		ti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;
+	}
+
+	/* do we have any slow callbacks? */
+	use_tasklet = !list_empty(&timer->sack_list_head);
+	spin_unlock(&timer->lock);
+
+	if (use_tasklet)
+		tasklet_hi_schedule(&timer->task_queue);
+}
+
+/*
+
+ */
+
+int snd_timer_new(snd_card_t *card, char *id, snd_timer_id_t *tid, snd_timer_t ** rtimer)
+{
+	snd_timer_t *timer;
+	int err;
+	static snd_device_ops_t ops = {
+		.dev_free = snd_timer_dev_free,
+		.dev_register = snd_timer_dev_register,
+		.dev_unregister = snd_timer_dev_unregister
+	};
+
+	snd_assert(tid != NULL, return -EINVAL);
+	snd_assert(rtimer != NULL, return -EINVAL);
+	*rtimer = NULL;
+	timer = kcalloc(1, sizeof(*timer), GFP_KERNEL);
+	if (timer == NULL)
+		return -ENOMEM;
+	timer->tmr_class = tid->dev_class;
+	timer->card = card;
+	timer->tmr_device = tid->device;
+	timer->tmr_subdevice = tid->subdevice;
+	if (id)
+		strlcpy(timer->id, id, sizeof(timer->id));
+	INIT_LIST_HEAD(&timer->device_list);
+	INIT_LIST_HEAD(&timer->open_list_head);
+	INIT_LIST_HEAD(&timer->active_list_head);
+	INIT_LIST_HEAD(&timer->ack_list_head);
+	INIT_LIST_HEAD(&timer->sack_list_head);
+	spin_lock_init(&timer->lock);
+	tasklet_init(&timer->task_queue, snd_timer_tasklet, (unsigned long)timer);
+	if (card != NULL) {
+		if ((err = snd_device_new(card, SNDRV_DEV_TIMER, timer, &ops)) < 0) {
+			snd_timer_free(timer);
+			return err;
+		}
+	}
+	*rtimer = timer;
+	return 0;
+}
+
+static int snd_timer_free(snd_timer_t *timer)
+{
+	snd_assert(timer != NULL, return -ENXIO);
+	if (timer->private_free)
+		timer->private_free(timer);
+	kfree(timer);
+	return 0;
+}
+
+int snd_timer_dev_free(snd_device_t *device)
+{
+	snd_timer_t *timer = device->device_data;
+	return snd_timer_free(timer);
+}
+
+int snd_timer_dev_register(snd_device_t *dev)
+{
+	snd_timer_t *timer = dev->device_data;
+	snd_timer_t *timer1;
+	struct list_head *p;
+
+	snd_assert(timer != NULL && timer->hw.start != NULL && timer->hw.stop != NULL, return -ENXIO);
+	if (!(timer->hw.flags & SNDRV_TIMER_HW_SLAVE) &&
+	    !timer->hw.resolution && timer->hw.c_resolution == NULL)
+	    	return -EINVAL;
+
+	down(&register_mutex);
+	list_for_each(p, &snd_timer_list) {
+		timer1 = (snd_timer_t *)list_entry(p, snd_timer_t, device_list);
+		if (timer1->tmr_class > timer->tmr_class)
+			break;
+		if (timer1->tmr_class < timer->tmr_class)
+			continue;
+		if (timer1->card && timer->card) {
+			if (timer1->card->number > timer->card->number)
+				break;
+			if (timer1->card->number < timer->card->number)
+				continue;
+		}
+		if (timer1->tmr_device > timer->tmr_device)
+			break;
+		if (timer1->tmr_device < timer->tmr_device)
+			continue;
+		if (timer1->tmr_subdevice > timer->tmr_subdevice)
+			break;
+		if (timer1->tmr_subdevice < timer->tmr_subdevice)
+			continue;
+		/* conflicts.. */
+		up(&register_mutex);
+		return -EBUSY;
+	}
+	list_add_tail(&timer->device_list, p);
+	up(&register_mutex);
+	return 0;
+}
+
+int snd_timer_unregister(snd_timer_t *timer)
+{
+	struct list_head *p, *n;
+	snd_timer_instance_t *ti;
+
+	snd_assert(timer != NULL, return -ENXIO);
+	down(&register_mutex);
+	if (! list_empty(&timer->open_list_head)) {
+		snd_printk(KERN_WARNING "timer 0x%lx is busy?\n", (long)timer);
+		list_for_each_safe(p, n, &timer->open_list_head) {
+			list_del_init(p);
+			ti = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, open_list);
+			ti->timer = NULL;
+		}
+	}
+	list_del(&timer->device_list);
+	up(&register_mutex);
+	return snd_timer_free(timer);
+}
+
+static int snd_timer_dev_unregister(snd_device_t *device)
+{
+	snd_timer_t *timer = device->device_data;
+	return snd_timer_unregister(timer);
+}
+
+void snd_timer_notify(snd_timer_t *timer, enum sndrv_timer_event event, struct timespec *tstamp)
+{
+	unsigned long flags;
+	unsigned long resolution = 0;
+	snd_timer_instance_t *ti, *ts;
+	struct list_head *p, *n;
+
+	snd_runtime_check(timer->hw.flags & SNDRV_TIMER_HW_SLAVE, return);	
+	snd_assert(event >= SNDRV_TIMER_EVENT_MSTART && event <= SNDRV_TIMER_EVENT_MPAUSE, return);
+	spin_lock_irqsave(&timer->lock, flags);
+	if (event == SNDRV_TIMER_EVENT_MSTART || event == SNDRV_TIMER_EVENT_MCONTINUE) {
+		if (timer->hw.c_resolution)
+			resolution = timer->hw.c_resolution(timer);
+		else
+			resolution = timer->hw.resolution;
+	}
+	list_for_each(p, &timer->active_list_head) {
+		ti = (snd_timer_instance_t *)list_entry(p, snd_timer_instance_t, active_list);
+		if (ti->ccallback)
+			ti->ccallback(ti, event, tstamp, resolution);
+		list_for_each(n, &ti->slave_active_head) {
+			ts = (snd_timer_instance_t *)list_entry(n, snd_timer_instance_t, active_list);
+			if (ts->ccallback)
+				ts->ccallback(ts, event, tstamp, resolution);
+		}
+	}
+	spin_unlock_irqrestore(&timer->lock, flags);
+}
+
+/*
+ * exported functions for global timers
+ */
+int snd_timer_global_new(char *id, int device, snd_timer_t **rtimer)
+{
+	snd_timer_id_t tid;
+	
+	tid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;
+	tid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;
+	tid.card = -1;
+	tid.device = device;
+	tid.subdevice = 0;
+	return snd_timer_new(NULL, id, &tid, rtimer);
+}
+
+int snd_timer_global_free(snd_timer_t *timer)
+{
+	return snd_timer_free(timer);
+}
+
+int snd_timer_global_register(snd_timer_t *timer)
+{
+	snd_device_t dev;
+
+	memset(&dev, 0, sizeof(dev));
+	dev.device_data = timer;
+	return snd_timer_dev_register(&dev);
+}
+
+int snd_timer_global_unregister(snd_timer_t *timer)
+{
+	return snd_timer_unregister(timer);
+}
+
+/* 
+ *  System timer
+ */
+
+struct snd_timer_system_private {
+	struct timer_list tlist;
+	struct timer * timer;
+	unsigned long last_expires;
+	unsigned long last_jiffies;
+	unsigned long correction;
+};
+
+unsigned int snd_timer_system_resolution(void)
+{
+	return 1000000000L / HZ;
+}
+
+static void snd_timer_s_function(unsigned long data)
+{
+	snd_timer_t *timer = (snd_timer_t *)data;
+	struct snd_timer_system_private *priv = timer->private_data;
+	unsigned long jiff = jiffies;
+	if (time_after(jiff, priv->last_expires))
+		priv->correction = (long)jiff - (long)priv->last_expires;
+	snd_timer_interrupt(timer, (long)jiff - (long)priv->last_jiffies);
+}
+
+static int snd_timer_s_start(snd_timer_t * timer)
+{
+	struct snd_timer_system_private *priv;
+	unsigned long njiff;
+
+	priv = (struct snd_timer_system_private *) timer->private_data;
+	njiff = (priv->last_jiffies = jiffies);
+	if (priv->correction > timer->sticks - 1) {
+		priv->correction -= timer->sticks - 1;
+		njiff++;
+	} else {
+		njiff += timer->sticks - priv->correction;
+		priv->correction -= timer->sticks;
+	}
+	priv->last_expires = priv->tlist.expires = njiff;
+	add_timer(&priv->tlist);
+	return 0;
+}
+
+static int snd_timer_s_stop(snd_timer_t * timer)
+{
+	struct snd_timer_system_private *priv;
+	unsigned long jiff;
+
+	priv = (struct snd_timer_system_private *) timer->private_data;
+	del_timer(&priv->tlist);
+	jiff = jiffies;
+	if (time_before(jiff, priv->last_expires))
+		timer->sticks = priv->last_expires - jiff;
+	else
+		timer->sticks = 1;
+	return 0;
+}
+
+static struct _snd_timer_hardware snd_timer_system =
+{
+	.flags =	SNDRV_TIMER_HW_FIRST | SNDRV_TIMER_HW_TASKLET,
+	.resolution =	1000000000L / HZ,
+	.ticks =	10000000L,
+	.start =	snd_timer_s_start,
+	.stop =		snd_timer_s_stop
+};
+
+static void snd_timer_free_system(snd_timer_t *timer)
+{
+	kfree(timer->private_data);
+}
+
+static int snd_timer_register_system(void)
+{
+	snd_timer_t *timer;
+	struct snd_timer_system_private *priv;
+	int err;
+
+	if ((err = snd_timer_global_new("system", SNDRV_TIMER_GLOBAL_SYSTEM, &timer)) < 0)
+		return err;
+	strcpy(timer->name, "system timer");
+	timer->hw = snd_timer_system;
+	priv = kcalloc(1, sizeof(*priv), GFP_KERNEL);
+	if (priv == NULL) {
+		snd_timer_free(timer);
+		return -ENOMEM;
+	}
+	init_timer(&priv->tlist);
+	priv->tlist.function = snd_timer_s_function;
+	priv->tlist.data = (unsigned long) timer;
+	timer->private_data = priv;
+	timer->private_free = snd_timer_free_system;
+	return snd_timer_global_register(timer);
+}
+
+/*
+ *  Info interface
+ */
+
+static void snd_timer_proc_read(snd_info_entry_t *entry,
+				snd_info_buffer_t * buffer)
+{
+	unsigned long flags;
+	snd_timer_t *timer;
+	snd_timer_instance_t *ti;
+	struct list_head *p, *q;
+
+	down(&register_mutex);
+	list_for_each(p, &snd_timer_list) {
+		timer = (snd_timer_t *)list_entry(p, snd_timer_t, device_list);
+		switch (timer->tmr_class) {
+		case SNDRV_TIMER_CLASS_GLOBAL:
+			snd_iprintf(buffer, "G%i: ", timer->tmr_device);
+			break;
+		case SNDRV_TIMER_CLASS_CARD:
+			snd_iprintf(buffer, "C%i-%i: ", timer->card->number, timer->tmr_device);
+			break;
+		case SNDRV_TIMER_CLASS_PCM:
+			snd_iprintf(buffer, "P%i-%i-%i: ", timer->card->number, timer->tmr_device, timer->tmr_subdevice);
+			break;
+		default:
+			snd_iprintf(buffer, "?%i-%i-%i-%i: ", timer->tmr_class, timer->card ? timer->card->number : -1, timer->tmr_device, timer->tmr_subdevice);
+		}
+		snd_iprintf(buffer, "%s :", timer->name);
+		if (timer->hw.resolution)
+			snd_iprintf(buffer, " %lu.%03luus (%lu ticks)", timer->hw.resolution / 1000, timer->hw.resolution % 1000, timer->hw.ticks);
+		if (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)
+			snd_iprintf(buffer, " SLAVE");
+		snd_iprintf(buffer, "\n");
+		spin_lock_irqsave(&timer->lock, flags);
+		list_for_each(q, &timer->open_list_head) {
+			ti = (snd_timer_instance_t *)list_entry(q, snd_timer_instance_t, open_list);
+			snd_iprintf(buffer, "  Client %s : %s : lost interrupts %li\n",
+					ti->owner ? ti->owner : "unknown",
+					ti->flags & (SNDRV_TIMER_IFLG_START|SNDRV_TIMER_IFLG_RUNNING) ? "running" : "stopped",
+					ti->lost);
+		}
+		spin_unlock_irqrestore(&timer->lock, flags);
+	}
+	up(&register_mutex);
+}
+
+/*
+ *  USER SPACE interface
+ */
+
+static void snd_timer_user_interrupt(snd_timer_instance_t *timeri,
+				     unsigned long resolution,
+				     unsigned long ticks)
+{
+	snd_timer_user_t *tu = timeri->callback_data;
+	snd_timer_read_t *r;
+	int prev;
+	
+	spin_lock(&tu->qlock);
+	if (tu->qused > 0) {
+		prev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;
+		r = &tu->queue[prev];
+		if (r->resolution == resolution) {
+			r->ticks += ticks;
+			goto __wake;
+		}
+	}
+	if (tu->qused >= tu->queue_size) {
+		tu->overrun++;
+	} else {
+		r = &tu->queue[tu->qtail++];
+		tu->qtail %= tu->queue_size;
+		r->resolution = resolution;
+		r->ticks = ticks;
+		tu->qused++;
+	}
+      __wake:
+	spin_unlock(&tu->qlock);
+	kill_fasync(&tu->fasync, SIGIO, POLL_IN);
+	wake_up(&tu->qchange_sleep);
+}
+
+static void snd_timer_user_append_to_tqueue(snd_timer_user_t *tu, snd_timer_tread_t *tread)
+{
+	if (tu->qused >= tu->queue_size) {
+		tu->overrun++;
+	} else {
+		memcpy(&tu->tqueue[tu->qtail++], tread, sizeof(*tread));
+		tu->qtail %= tu->queue_size;
+		tu->qused++;
+	}
+}
+
+static void snd_timer_user_ccallback(snd_timer_instance_t *timeri,
+				     enum sndrv_timer_event event,
+				     struct timespec *tstamp,
+				     unsigned long resolution)
+{
+	snd_timer_user_t *tu = timeri->callback_data;
+	snd_timer_tread_t r1;
+
+	if (event >= SNDRV_TIMER_EVENT_START && event <= SNDRV_TIMER_EVENT_PAUSE)
+		tu->tstamp = *tstamp;
+	if ((tu->filter & (1 << event)) == 0 || !tu->tread)
+		return;
+	r1.event = event;
+	r1.tstamp = *tstamp;
+	r1.val = resolution;
+	spin_lock(&tu->qlock);
+	snd_timer_user_append_to_tqueue(tu, &r1);
+	spin_unlock(&tu->qlock);
+	kill_fasync(&tu->fasync, SIGIO, POLL_IN);
+	wake_up(&tu->qchange_sleep);
+}
+
+static void snd_timer_user_tinterrupt(snd_timer_instance_t *timeri,
+				      unsigned long resolution,
+				      unsigned long ticks)
+{
+	snd_timer_user_t *tu = timeri->callback_data;
+	snd_timer_tread_t *r, r1;
+	struct timespec tstamp;
+	int prev, append = 0;
+
+	snd_timestamp_zero(&tstamp);
+	spin_lock(&tu->qlock);
+	if ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION)|(1 << SNDRV_TIMER_EVENT_TICK))) == 0) {
+		spin_unlock(&tu->qlock);
+		return;
+	}
+	if (tu->last_resolution != resolution || ticks > 0)
+		snd_timestamp_now(&tstamp, 1);
+	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) && tu->last_resolution != resolution) {
+		r1.event = SNDRV_TIMER_EVENT_RESOLUTION;
+		r1.tstamp = tstamp;
+		r1.val = resolution;
+		snd_timer_user_append_to_tqueue(tu, &r1);
+		tu->last_resolution = resolution;
+		append++;
+	}
+	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)
+		goto __wake;
+	if (ticks == 0)
+		goto __wake;
+	if (tu->qused > 0) {
+		prev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;
+		r = &tu->tqueue[prev];
+		if (r->event == SNDRV_TIMER_EVENT_TICK) {
+			r->tstamp = tstamp;
+			r->val += ticks;
+			append++;
+			goto __wake;
+		}
+	}
+	r1.event = SNDRV_TIMER_EVENT_TICK;
+	r1.tstamp = tstamp;
+	r1.val = ticks;
+	snd_timer_user_append_to_tqueue(tu, &r1);
+	append++;
+      __wake:
+	spin_unlock(&tu->qlock);
+	if (append == 0)
+		return;
+	kill_fasync(&tu->fasync, SIGIO, POLL_IN);
+	wake_up(&tu->qchange_sleep);
+}
+
+static int snd_timer_user_open(struct inode *inode, struct file *file)
+{
+	snd_timer_user_t *tu;
+	
+	tu = kcalloc(1, sizeof(*tu), GFP_KERNEL);
+	if (tu == NULL)
+		return -ENOMEM;
+	spin_lock_init(&tu->qlock);
+	init_waitqueue_head(&tu->qchange_sleep);
+	tu->ticks = 1;
+	tu->queue_size = 128;
+	tu->queue = (snd_timer_read_t *)kmalloc(tu->queue_size * sizeof(snd_timer_read_t), GFP_KERNEL);
+	if (tu->queue == NULL) {
+		kfree(tu);
+		return -ENOMEM;
+	}
+	file->private_data = tu;
+	return 0;
+}
+
+static int snd_timer_user_release(struct inode *inode, struct file *file)
+{
+	snd_timer_user_t *tu;
+
+	if (file->private_data) {
+		tu = file->private_data;
+		file->private_data = NULL;
+		fasync_helper(-1, file, 0, &tu->fasync);
+		if (tu->timeri)
+			snd_timer_close(tu->timeri);
+		kfree(tu->queue);
+		kfree(tu->tqueue);
+		kfree(tu);
+	}
+	return 0;
+}
+
+static void snd_timer_user_zero_id(snd_timer_id_t *id)
+{
+	id->dev_class = SNDRV_TIMER_CLASS_NONE;
+	id->dev_sclass = SNDRV_TIMER_SCLASS_NONE;
+	id->card = -1;
+	id->device = -1;
+	id->subdevice = -1;
+}
+
+static void snd_timer_user_copy_id(snd_timer_id_t *id, snd_timer_t *timer)
+{
+	id->dev_class = timer->tmr_class;
+	id->dev_sclass = SNDRV_TIMER_SCLASS_NONE;
+	id->card = timer->card ? timer->card->number : -1;
+	id->device = timer->tmr_device;
+	id->subdevice = timer->tmr_subdevice;
+}
+
+static int snd_timer_user_next_device(snd_timer_id_t __user *_tid)
+{
+	snd_timer_id_t id;
+	snd_timer_t *timer;
+	struct list_head *p;
+	
+	if (copy_from_user(&id, _tid, sizeof(id)))
+		return -EFAULT;
+	down(&register_mutex);
+	if (id.dev_class < 0) {		/* first item */
+		if (list_empty(&snd_timer_list))
+			snd_timer_user_zero_id(&id);
+		else {
+			timer = (snd_timer_t *)list_entry(snd_timer_list.next, snd_timer_t, device_list);
+			snd_timer_user_copy_id(&id, timer);
+		}
+	} else {
+		switch (id.dev_class) {
+		case SNDRV_TIMER_CLASS_GLOBAL:
+			id.device = id.device < 0 ? 0 : id.device + 1;
+			list_for_each(p, &snd_timer_list) {
+				timer = (snd_timer_t *)list_entry(p, snd_timer_t, device_list);
+				if (timer->tmr_class > SNDRV_TIMER_CLASS_GLOBAL) {
+					snd_timer_user_copy_id(&id, timer);
+					break;
+				}
+				if (timer->tmr_device >= id.device) {
+					snd_timer_user_copy_id(&id, timer);
+					break;
+				}
+			}
+			if (p == &snd_timer_list)
+				snd_timer_user_zero_id(&id);
+			break;
+		case SNDRV_TIMER_CLASS_CARD:
+		case SNDRV_TIMER_CLASS_PCM:
+			if (id.card < 0) {
+				id.card = 0;
+			} else {
+				if (id.card < 0) {
+					id.card = 0;
+				} else {
+					if (id.device < 0) {
+						id.device = 0;
+					} else {
+						id.subdevice = id.subdevice < 0 ? 0 : id.subdevice + 1;
+					}
+				}
+			}
+			list_for_each(p, &snd_timer_list) {
+				timer = (snd_timer_t *)list_entry(p, snd_timer_t, device_list);
+				if (timer->tmr_class > id.dev_class) {
+					snd_timer_user_copy_id(&id, timer);
+					break;
+				}
+				if (timer->tmr_class < id.dev_class)
+					continue;
+				if (timer->card->number > id.card) {
+					snd_timer_user_copy_id(&id, timer);
+					break;
+				}
+				if (timer->card->number < id.card)
+					continue;
+				if (timer->tmr_device > id.device) {
+					snd_timer_user_copy_id(&id, timer);
+					break;
+				}
+				if (timer->tmr_device < id.device)
+					continue;
+				if (timer->tmr_subdevice > id.subdevice) {
+					snd_timer_user_copy_id(&id, timer);
+					break;
+				}
+				if (timer->tmr_subdevice < id.subdevice)
+					continue;
+				snd_timer_user_copy_id(&id, timer);
+				break;
+			}
+			if (p == &snd_timer_list)
+				snd_timer_user_zero_id(&id);
+			break;
+		default:
+			snd_timer_user_zero_id(&id);
+		}
+	}
+	up(&register_mutex);
+	if (copy_to_user(_tid, &id, sizeof(*_tid)))
+		return -EFAULT;
+	return 0;
+} 
+
+static int snd_timer_user_ginfo(struct file *file, snd_timer_ginfo_t __user *_ginfo)
+{
+	snd_timer_ginfo_t *ginfo;
+	snd_timer_id_t tid;
+	snd_timer_t *t;
+	struct list_head *p;
+	int err = 0;
+
+	ginfo = kmalloc(sizeof(*ginfo), GFP_KERNEL);
+	if (! ginfo)
+		return -ENOMEM;
+	if (copy_from_user(ginfo, _ginfo, sizeof(*ginfo))) {
+		kfree(ginfo);
+		return -EFAULT;
+	}
+	tid = ginfo->tid;
+	memset(ginfo, 0, sizeof(*ginfo));
+	ginfo->tid = tid;
+	down(&register_mutex);
+	t = snd_timer_find(&tid);
+	if (t != NULL) {
+		ginfo->card = t->card ? t->card->number : -1;
+		if (t->hw.flags & SNDRV_TIMER_HW_SLAVE)
+			ginfo->flags |= SNDRV_TIMER_FLG_SLAVE;
+		strlcpy(ginfo->id, t->id, sizeof(ginfo->id));
+		strlcpy(ginfo->name, t->name, sizeof(ginfo->name));
+		ginfo->resolution = t->hw.resolution;
+		if (t->hw.resolution_min > 0) {
+			ginfo->resolution_min = t->hw.resolution_min;
+			ginfo->resolution_max = t->hw.resolution_max;
+		}
+		list_for_each(p, &t->open_list_head) {
+			ginfo->clients++;
+		}
+	} else {
+		err = -ENODEV;
+	}
+	up(&register_mutex);
+	if (err >= 0 && copy_to_user(_ginfo, ginfo, sizeof(*ginfo)))
+		err = -EFAULT;
+	kfree(ginfo);
+	return err;
+}
+
+static int snd_timer_user_gparams(struct file *file, snd_timer_gparams_t __user *_gparams)
+{
+	snd_timer_gparams_t gparams;
+	snd_timer_t *t;
+	int err;
+
+	if (copy_from_user(&gparams, _gparams, sizeof(gparams)))
+		return -EFAULT;
+	down(&register_mutex);
+	t = snd_timer_find(&gparams.tid);
+	if (t != NULL) {
+		if (list_empty(&t->open_list_head)) {
+			if (t->hw.set_period)
+				err = t->hw.set_period(t, gparams.period_num, gparams.period_den);
+			else
+				err = -ENOSYS;
+		} else {
+			err = -EBUSY;
+		}
+	} else {
+		err = -ENODEV;
+	}
+	up(&register_mutex);
+	return err;
+}
+
+static int snd_timer_user_gstatus(struct file *file, snd_timer_gstatus_t __user *_gstatus)
+{
+	snd_timer_gstatus_t gstatus;
+	snd_timer_id_t tid;
+	snd_timer_t *t;
+	int err = 0;
+
+	if (copy_from_user(&gstatus, _gstatus, sizeof(gstatus)))
+		return -EFAULT;
+	tid = gstatus.tid;
+	memset(&gstatus, 0, sizeof(gstatus));
+	gstatus.tid = tid;
+	down(&register_mutex);
+	t = snd_timer_find(&tid);
+	if (t != NULL) {
+		if (t->hw.c_resolution)
+			gstatus.resolution = t->hw.c_resolution(t);
+		else
+			gstatus.resolution = t->hw.resolution;
+		if (t->hw.precise_resolution) {
+			t->hw.precise_resolution(t, &gstatus.resolution_num, &gstatus.resolution_den);
+		} else {
+			gstatus.resolution_num = gstatus.resolution;
+			gstatus.resolution_den = 1000000000uL;
+		}
+	} else {
+		err = -ENODEV;
+	}
+	up(&register_mutex);
+	if (err >= 0 && copy_to_user(_gstatus, &gstatus, sizeof(gstatus)))
+		err = -EFAULT;
+	return err;
+}
+
+static int snd_timer_user_tselect(struct file *file, snd_timer_select_t __user *_tselect)
+{
+	snd_timer_user_t *tu;
+	snd_timer_select_t tselect;
+	char str[32];
+	int err;
+	
+	tu = file->private_data;
+	if (tu->timeri)
+		snd_timer_close(tu->timeri);
+	if (copy_from_user(&tselect, _tselect, sizeof(tselect)))
+		return -EFAULT;
+	sprintf(str, "application %i", current->pid);
+	if (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)
+		tselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;
+	if ((err = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid)) < 0)
+		return err;
+
+	if (tu->queue) {
+		kfree(tu->queue);
+		tu->queue = NULL;
+	}
+	if (tu->tqueue) {
+		kfree(tu->tqueue);
+		tu->tqueue = NULL;
+	}
+	if (tu->tread) {
+		tu->tqueue = (snd_timer_tread_t *)kmalloc(tu->queue_size * sizeof(snd_timer_tread_t), GFP_KERNEL);
+		if (tu->tqueue == NULL) {
+			snd_timer_close(tu->timeri);
+			return -ENOMEM;
+		}
+	} else {
+		tu->queue = (snd_timer_read_t *)kmalloc(tu->queue_size * sizeof(snd_timer_read_t), GFP_KERNEL);
+		if (tu->queue == NULL) {
+			snd_timer_close(tu->timeri);
+			return -ENOMEM;
+		}
+	}
+	
+	tu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;
+	tu->timeri->callback = tu->tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt;
+	tu->timeri->ccallback = snd_timer_user_ccallback;
+	tu->timeri->callback_data = (void *)tu;
+	return 0;
+}
+
+static int snd_timer_user_info(struct file *file, snd_timer_info_t __user *_info)
+{
+	snd_timer_user_t *tu;
+	snd_timer_info_t *info;
+	snd_timer_t *t;
+	int err = 0;
+
+	tu = file->private_data;
+	snd_assert(tu->timeri != NULL, return -ENXIO);
+	t = tu->timeri->timer;
+	snd_assert(t != NULL, return -ENXIO);
+
+	info = kcalloc(1, sizeof(*info), GFP_KERNEL);
+	if (! info)
+		return -ENOMEM;
+	info->card = t->card ? t->card->number : -1;
+	if (t->hw.flags & SNDRV_TIMER_HW_SLAVE)
+		info->flags |= SNDRV_TIMER_FLG_SLAVE;
+	strlcpy(info->id, t->id, sizeof(info->id));
+	strlcpy(info->name, t->name, sizeof(info->name));
+	info->resolution = t->hw.resolution;
+	if (copy_to_user(_info, info, sizeof(*_info)))
+		err = -EFAULT;
+	kfree(info);
+	return err;
+}
+
+static int snd_timer_user_params(struct file *file, snd_timer_params_t __user *_params)
+{
+	snd_timer_user_t *tu;
+	snd_timer_params_t params;
+	snd_timer_t *t;
+	snd_timer_read_t *tr;
+	snd_timer_tread_t *ttr;
+	int err;
+	
+	tu = file->private_data;
+	snd_assert(tu->timeri != NULL, return -ENXIO);
+	t = tu->timeri->timer;
+	snd_assert(t != NULL, return -ENXIO);
+	if (copy_from_user(&params, _params, sizeof(params)))
+		return -EFAULT;
+	if (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE) && params.ticks < 1) {
+		err = -EINVAL;
+		goto _end;
+	}
+	if (params.queue_size > 0 && (params.queue_size < 32 || params.queue_size > 1024)) {
+		err = -EINVAL;
+		goto _end;
+	}
+	if (params.filter & ~((1<<SNDRV_TIMER_EVENT_RESOLUTION)|
+			      (1<<SNDRV_TIMER_EVENT_TICK)|
+			      (1<<SNDRV_TIMER_EVENT_START)|
+			      (1<<SNDRV_TIMER_EVENT_STOP)|
+			      (1<<SNDRV_TIMER_EVENT_CONTINUE)|
+			      (1<<SNDRV_TIMER_EVENT_PAUSE)|
+			      (1<<SNDRV_TIMER_EVENT_MSTART)|
+			      (1<<SNDRV_TIMER_EVENT_MSTOP)|
+			      (1<<SNDRV_TIMER_EVENT_MCONTINUE)|
+			      (1<<SNDRV_TIMER_EVENT_MPAUSE))) {
+		err = -EINVAL;
+		goto _end;
+	}
+	snd_timer_stop(tu->timeri);
+	spin_lock_irq(&t->lock);
+	tu->timeri->flags &= ~(SNDRV_TIMER_IFLG_AUTO|
+			       SNDRV_TIMER_IFLG_EXCLUSIVE|
+			       SNDRV_TIMER_IFLG_EARLY_EVENT);
+	if (params.flags & SNDRV_TIMER_PSFLG_AUTO)
+		tu->timeri->flags |= SNDRV_TIMER_IFLG_AUTO;
+	if (params.flags & SNDRV_TIMER_PSFLG_EXCLUSIVE)
+		tu->timeri->flags |= SNDRV_TIMER_IFLG_EXCLUSIVE;
+	if (params.flags & SNDRV_TIMER_PSFLG_EARLY_EVENT)
+		tu->timeri->flags |= SNDRV_TIMER_IFLG_EARLY_EVENT;
+	spin_unlock_irq(&t->lock);
+	if (params.queue_size > 0 && (unsigned int)tu->queue_size != params.queue_size) {
+		if (tu->tread) {
+			ttr = (snd_timer_tread_t *)kmalloc(params.queue_size * sizeof(snd_timer_tread_t), GFP_KERNEL);
+			if (ttr) {
+				kfree(tu->tqueue);
+				tu->queue_size = params.queue_size;
+				tu->tqueue = ttr;
+			}
+		} else {
+			tr = (snd_timer_read_t *)kmalloc(params.queue_size * sizeof(snd_timer_read_t), GFP_KERNEL);
+			if (tr) {
+				kfree(tu->queue);
+				tu->queue_size = params.queue_size;
+				tu->queue = tr;
+			}
+		}
+	}
+	tu->qhead = tu->qtail = tu->qused = 0;
+	if (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {
+		if (tu->tread) {
+			snd_timer_tread_t tread;
+			tread.event = SNDRV_TIMER_EVENT_EARLY;
+			tread.tstamp.tv_sec = 0;
+			tread.tstamp.tv_nsec = 0;
+			tread.val = 0;
+			snd_timer_user_append_to_tqueue(tu, &tread);
+		} else {
+			snd_timer_read_t *r = &tu->queue[0];
+			r->resolution = 0;
+			r->ticks = 0;
+			tu->qused++;
+			tu->qtail++;
+		}
+		
+	}
+	tu->filter = params.filter;
+	tu->ticks = params.ticks;
+	err = 0;
+ _end:
+	if (copy_to_user(_params, &params, sizeof(params)))
+		return -EFAULT;
+	return err;
+}
+
+static int snd_timer_user_status(struct file *file, snd_timer_status_t __user *_status)
+{
+	snd_timer_user_t *tu;
+	snd_timer_status_t status;
+	
+	tu = file->private_data;
+	snd_assert(tu->timeri != NULL, return -ENXIO);
+	memset(&status, 0, sizeof(status));
+	status.tstamp = tu->tstamp;
+	status.resolution = snd_timer_resolution(tu->timeri);
+	status.lost = tu->timeri->lost;
+	status.overrun = tu->overrun;
+	spin_lock_irq(&tu->qlock);
+	status.queue = tu->qused;
+	spin_unlock_irq(&tu->qlock);
+	if (copy_to_user(_status, &status, sizeof(status)))
+		return -EFAULT;
+	return 0;
+}
+
+static int snd_timer_user_start(struct file *file)
+{
+	int err;
+	snd_timer_user_t *tu;
+		
+	tu = file->private_data;
+	snd_assert(tu->timeri != NULL, return -ENXIO);
+	snd_timer_stop(tu->timeri);
+	tu->timeri->lost = 0;
+	tu->last_resolution = 0;
+	return (err = snd_timer_start(tu->timeri, tu->ticks)) < 0 ? err : 0;
+}
+
+static int snd_timer_user_stop(struct file *file)
+{
+	int err;
+	snd_timer_user_t *tu;
+		
+	tu = file->private_data;
+	snd_assert(tu->timeri != NULL, return -ENXIO);
+	return (err = snd_timer_stop(tu->timeri)) < 0 ? err : 0;
+}
+
+static int snd_timer_user_continue(struct file *file)
+{
+	int err;
+	snd_timer_user_t *tu;
+		
+	tu = file->private_data;
+	snd_assert(tu->timeri != NULL, return -ENXIO);
+	tu->timeri->lost = 0;
+	return (err = snd_timer_continue(tu->timeri)) < 0 ? err : 0;
+}
+
+static long snd_timer_user_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	snd_timer_user_t *tu;
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+	
+	tu = file->private_data;
+	switch (cmd) {
+	case SNDRV_TIMER_IOCTL_PVERSION:
+		return put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;
+	case SNDRV_TIMER_IOCTL_NEXT_DEVICE:
+		return snd_timer_user_next_device(argp);
+	case SNDRV_TIMER_IOCTL_TREAD:
+	{
+		int xarg;
+		
+		if (tu->timeri)		/* too late */
+			return -EBUSY;
+		if (get_user(xarg, p))
+			return -EFAULT;
+		tu->tread = xarg ? 1 : 0;
+		return 0;
+	}
+	case SNDRV_TIMER_IOCTL_GINFO:
+		return snd_timer_user_ginfo(file, argp);
+	case SNDRV_TIMER_IOCTL_GPARAMS:
+		return snd_timer_user_gparams(file, argp);
+	case SNDRV_TIMER_IOCTL_GSTATUS:
+		return snd_timer_user_gstatus(file, argp);
+	case SNDRV_TIMER_IOCTL_SELECT:
+		return snd_timer_user_tselect(file, argp);
+	case SNDRV_TIMER_IOCTL_INFO:
+		return snd_timer_user_info(file, argp);
+	case SNDRV_TIMER_IOCTL_PARAMS:
+		return snd_timer_user_params(file, argp);
+	case SNDRV_TIMER_IOCTL_STATUS:
+		return snd_timer_user_status(file, argp);
+	case SNDRV_TIMER_IOCTL_START:
+		return snd_timer_user_start(file);
+	case SNDRV_TIMER_IOCTL_STOP:
+		return snd_timer_user_stop(file);
+	case SNDRV_TIMER_IOCTL_CONTINUE:
+		return snd_timer_user_continue(file);
+	}
+	return -ENOTTY;
+}
+
+static int snd_timer_user_fasync(int fd, struct file * file, int on)
+{
+	snd_timer_user_t *tu;
+	int err;
+	
+	tu = file->private_data;
+	err = fasync_helper(fd, file, on, &tu->fasync);
+        if (err < 0)
+		return err;
+	return 0;
+}
+
+static ssize_t snd_timer_user_read(struct file *file, char __user *buffer, size_t count, loff_t *offset)
+{
+	snd_timer_user_t *tu;
+	long result = 0, unit;
+	int err = 0;
+	
+	tu = file->private_data;
+	unit = tu->tread ? sizeof(snd_timer_tread_t) : sizeof(snd_timer_read_t);
+	spin_lock_irq(&tu->qlock);
+	while ((long)count - result >= unit) {
+		while (!tu->qused) {
+			wait_queue_t wait;
+
+			if ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {
+				err = -EAGAIN;
+				break;
+			}
+
+			set_current_state(TASK_INTERRUPTIBLE);
+			init_waitqueue_entry(&wait, current);
+			add_wait_queue(&tu->qchange_sleep, &wait);
+
+			spin_unlock_irq(&tu->qlock);
+			schedule();
+			spin_lock_irq(&tu->qlock);
+
+			remove_wait_queue(&tu->qchange_sleep, &wait);
+
+			if (signal_pending(current)) {
+				err = -ERESTARTSYS;
+				break;
+			}
+		}
+
+		spin_unlock_irq(&tu->qlock);
+		if (err < 0)
+			goto _error;
+
+		if (tu->tread) {
+			if (copy_to_user(buffer, &tu->tqueue[tu->qhead++], sizeof(snd_timer_tread_t))) {
+				err = -EFAULT;
+				goto _error;
+			}
+		} else {
+			if (copy_to_user(buffer, &tu->queue[tu->qhead++], sizeof(snd_timer_read_t))) {
+				err = -EFAULT;
+				goto _error;
+			}
+		}
+
+		tu->qhead %= tu->queue_size;
+
+		result += unit;
+		buffer += unit;
+
+		spin_lock_irq(&tu->qlock);
+		tu->qused--;
+	}
+	spin_unlock_irq(&tu->qlock);
+ _error:
+	return result > 0 ? result : err;
+}
+
+static unsigned int snd_timer_user_poll(struct file *file, poll_table * wait)
+{
+        unsigned int mask;
+        snd_timer_user_t *tu;
+
+        tu = file->private_data;
+
+        poll_wait(file, &tu->qchange_sleep, wait);
+	
+	mask = 0;
+	if (tu->qused)
+		mask |= POLLIN | POLLRDNORM;
+
+	return mask;
+}
+
+#ifdef CONFIG_COMPAT
+#include "timer_compat.c"
+#else
+#define snd_timer_user_ioctl_compat	NULL
+#endif
+
+static struct file_operations snd_timer_f_ops =
+{
+	.owner =	THIS_MODULE,
+	.read =		snd_timer_user_read,
+	.open =		snd_timer_user_open,
+	.release =	snd_timer_user_release,
+	.poll =		snd_timer_user_poll,
+	.unlocked_ioctl =	snd_timer_user_ioctl,
+	.compat_ioctl =	snd_timer_user_ioctl_compat,
+	.fasync = 	snd_timer_user_fasync,
+};
+
+static snd_minor_t snd_timer_reg =
+{
+	.comment =	"timer",
+	.f_ops =	&snd_timer_f_ops,
+};
+
+/*
+ *  ENTRY functions
+ */
+
+static snd_info_entry_t *snd_timer_proc_entry = NULL;
+
+static int __init alsa_timer_init(void)
+{
+	int err;
+	snd_info_entry_t *entry;
+
+#ifdef SNDRV_OSS_INFO_DEV_TIMERS
+	snd_oss_info_register(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1, "system timer");
+#endif
+	if ((entry = snd_info_create_module_entry(THIS_MODULE, "timers", NULL)) != NULL) {
+		entry->c.text.read_size = SNDRV_TIMER_DEVICES * 128;
+		entry->c.text.read = snd_timer_proc_read;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	snd_timer_proc_entry = entry;
+	if ((err = snd_timer_register_system()) < 0)
+		snd_printk(KERN_ERR "unable to register system timer (%i)\n", err);
+	if ((err = snd_register_device(SNDRV_DEVICE_TYPE_TIMER,
+					NULL, 0, &snd_timer_reg, "timer"))<0)
+		snd_printk(KERN_ERR "unable to register timer device (%i)\n", err);
+	return 0;
+}
+
+static void __exit alsa_timer_exit(void)
+{
+	struct list_head *p, *n;
+
+	snd_unregister_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0);
+	/* unregister the system timer */
+	list_for_each_safe(p, n, &snd_timer_list) {
+		snd_timer_t *timer = (snd_timer_t *)list_entry(p, snd_timer_t, device_list);
+		snd_timer_unregister(timer);
+	}
+	if (snd_timer_proc_entry) {
+		snd_info_unregister(snd_timer_proc_entry);
+		snd_timer_proc_entry = NULL;
+	}
+#ifdef SNDRV_OSS_INFO_DEV_TIMERS
+	snd_oss_info_unregister(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1);
+#endif
+}
+
+module_init(alsa_timer_init)
+module_exit(alsa_timer_exit)
+
+EXPORT_SYMBOL(snd_timer_open);
+EXPORT_SYMBOL(snd_timer_close);
+EXPORT_SYMBOL(snd_timer_resolution);
+EXPORT_SYMBOL(snd_timer_start);
+EXPORT_SYMBOL(snd_timer_stop);
+EXPORT_SYMBOL(snd_timer_continue);
+EXPORT_SYMBOL(snd_timer_pause);
+EXPORT_SYMBOL(snd_timer_new);
+EXPORT_SYMBOL(snd_timer_notify);
+EXPORT_SYMBOL(snd_timer_global_new);
+EXPORT_SYMBOL(snd_timer_global_free);
+EXPORT_SYMBOL(snd_timer_global_register);
+EXPORT_SYMBOL(snd_timer_global_unregister);
+EXPORT_SYMBOL(snd_timer_interrupt);
+EXPORT_SYMBOL(snd_timer_system_resolution);
