commit b40fe4bbc76bf6be655f9ba975dc91c6a72fe79e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:55 2020 +0100

    ALSA: oss: More constifications
    
    Apply const prefix to the static tables for strings and formats.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-41-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 26502294f7d8..f702c96a7478 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1109,7 +1109,7 @@ static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer,
 /*
  */
 #define MIXER_VOL(name) [SOUND_MIXER_##name] = #name
-static char *oss_mixer_names[SNDRV_OSS_MAX_MIXERS] = {
+static const char * const oss_mixer_names[SNDRV_OSS_MAX_MIXERS] = {
 	MIXER_VOL(VOLUME),
 	MIXER_VOL(BASS),
 	MIXER_VOL(TREBLE),

commit 454f5ec1d2b774b89f3ea759a9a791f320e6f389
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:47 2020 +0100

    ALSA: mixer: oss: Constify snd_mixer_oss_assign_table definition
    
    The snd_mixer_oss_assign_table is read-only, and can it be declared as
    const.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-32-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 7eb54df5556d..26502294f7d8 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -486,7 +486,7 @@ struct slot {
 	unsigned int channels;
 	unsigned int numid[SNDRV_MIXER_OSS_ITEM_COUNT];
 	unsigned int capture_item;
-	struct snd_mixer_oss_assign_table *assigned;
+	const struct snd_mixer_oss_assign_table *assigned;
 	unsigned int allocated: 1;
 };
 
@@ -934,8 +934,8 @@ static void snd_mixer_oss_slot_free(struct snd_mixer_oss_slot *chn)
 	struct slot *p = chn->private_data;
 	if (p) {
 		if (p->allocated && p->assigned) {
-			kfree(p->assigned->name);
-			kfree(p->assigned);
+			kfree_const(p->assigned->name);
+			kfree_const(p->assigned);
 		}
 		kfree(p);
 	}
@@ -953,7 +953,7 @@ static void mixer_slot_clear(struct snd_mixer_oss_slot *rslot)
 /* In a separate function to keep gcc 3.2 happy - do NOT merge this in
    snd_mixer_oss_build_input! */
 static int snd_mixer_oss_build_test_all(struct snd_mixer_oss *mixer,
-					struct snd_mixer_oss_assign_table *ptr,
+					const struct snd_mixer_oss_assign_table *ptr,
 					struct slot *slot)
 {
 	char str[64];
@@ -1017,7 +1017,9 @@ static int snd_mixer_oss_build_test_all(struct snd_mixer_oss *mixer,
  * ptr_allocated means the entry is dynamically allocated (change via proc file).
  * when replace_old = 1, the old entry is replaced with the new one.
  */
-static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer, struct snd_mixer_oss_assign_table *ptr, int ptr_allocated, int replace_old)
+static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer,
+				     const struct snd_mixer_oss_assign_table *ptr,
+				     int ptr_allocated, int replace_old)
 {
 	struct slot slot;
 	struct slot *pslot;
@@ -1255,7 +1257,7 @@ static void snd_mixer_oss_proc_done(struct snd_mixer_oss *mixer)
 
 static void snd_mixer_oss_build(struct snd_mixer_oss *mixer)
 {
-	static struct snd_mixer_oss_assign_table table[] = {
+	static const struct snd_mixer_oss_assign_table table[] = {
 		{ SOUND_MIXER_VOLUME, 	"Master",		0 },
 		{ SOUND_MIXER_VOLUME, 	"Front",		0 }, /* fallback */
 		{ SOUND_MIXER_BASS,	"Tone Control - Bass",	0 },

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index c8618678649c..7eb54df5556d 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1,22 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  OSS emulation layer for the mixer interface
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/init.h>

commit f4fa968950aef7efb98a0899bb0132405e2edaf1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 16 18:18:47 2019 +0200

    ALSA: core: Don't refer to snd_cards array directly
    
    The snd_cards[] array holds the card pointers that have been currently
    registered, and it's exported for the external modules that may need
    to refer a card object.  But accessing to this array can be racy
    against the driver probe or removal, as the card registration or free
    may happen concurrently.
    
    This patch gets rid of the direct access to snd_cards[] array and
    provides a helper function to give the card object from the index
    number with a refcount management.  Then the caller can access to the
    given card object safely, and releases it via snd_card_unref().
    
    While we're at it, add a proper comment to snd_card_unref() and make
    it an inlined function for type-safety, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 64d904bee8bb..c8618678649c 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1403,24 +1403,32 @@ static int snd_mixer_oss_notify_handler(struct snd_card *card, int cmd)
 
 static int __init alsa_mixer_oss_init(void)
 {
+	struct snd_card *card;
 	int idx;
 	
 	snd_mixer_oss_notify_callback = snd_mixer_oss_notify_handler;
 	for (idx = 0; idx < SNDRV_CARDS; idx++) {
-		if (snd_cards[idx])
-			snd_mixer_oss_notify_handler(snd_cards[idx], SND_MIXER_OSS_NOTIFY_REGISTER);
+		card = snd_card_ref(idx);
+		if (card) {
+			snd_mixer_oss_notify_handler(card, SND_MIXER_OSS_NOTIFY_REGISTER);
+			snd_card_unref(card);
+		}
 	}
 	return 0;
 }
 
 static void __exit alsa_mixer_oss_exit(void)
 {
+	struct snd_card *card;
 	int idx;
 
 	snd_mixer_oss_notify_callback = NULL;
 	for (idx = 0; idx < SNDRV_CARDS; idx++) {
-		if (snd_cards[idx])
-			snd_mixer_oss_notify_handler(snd_cards[idx], SND_MIXER_OSS_NOTIFY_FREE);
+		card = snd_card_ref(idx);
+		if (card) {
+			snd_mixer_oss_notify_handler(card, SND_MIXER_OSS_NOTIFY_FREE);
+			snd_card_unref(card);
+		}
 	}
 }
 

commit 6a73cf46ce9d1b382ea14d74ce4bc9aa0c52337a
Author: Joe Perches <joe@perches.com>
Date:   Wed May 23 12:20:59 2018 -0700

    sound: Use octal not symbolic permissions
    
    Convert the S_<FOO> symbolic permissions to their octal equivalents as
    using octal and not symbolic permissions is preferred by many as more
    readable.
    
    see: https://lkml.org/lkml/2016/8/2/1945
    
    Done with automated conversion via:
    $ ./scripts/checkpatch.pl -f --types=SYMBOLIC_PERMS --fix-inplace <files...>
    
    Miscellanea:
    
    o Wrapped one multi-line call to a single line
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 379bf486ccc7..64d904bee8bb 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1247,7 +1247,7 @@ static void snd_mixer_oss_proc_init(struct snd_mixer_oss *mixer)
 	if (! entry)
 		return;
 	entry->content = SNDRV_INFO_CONTENT_TEXT;
-	entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+	entry->mode = S_IFREG | 0644;
 	entry->c.text.read = snd_mixer_oss_proc_read;
 	entry->c.text.write = snd_mixer_oss_proc_write;
 	entry->private_data = mixer;

commit 35f8001415d301ba47124f463f98eee0e7d0792c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 16 16:16:33 2017 +0200

    ALSA: core: Follow standard EXPORT_SYMBOL() declarations
    
    Just a tidy up to follow the standard EXPORT_SYMBOL*() declarations
    in order to improve grep-ability.
    
    - Move EXPORT_SYMBOL*() to the position right after its definition
    - Remove superfluous blank line before EXPORT_SYMBOL*() lines
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 2ff9c12d664a..379bf486ccc7 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -395,6 +395,7 @@ int snd_mixer_oss_ioctl_card(struct snd_card *card, unsigned int cmd, unsigned l
 	fmixer.mixer = card->mixer_oss;
 	return snd_mixer_oss_ioctl1(&fmixer, cmd, arg);
 }
+EXPORT_SYMBOL(snd_mixer_oss_ioctl_card);
 
 #ifdef CONFIG_COMPAT
 /* all compatible */
@@ -1425,5 +1426,3 @@ static void __exit alsa_mixer_oss_exit(void)
 
 module_init(alsa_mixer_oss_init)
 module_exit(alsa_mixer_oss_exit)
-
-EXPORT_SYMBOL(snd_mixer_oss_ioctl_card);

commit 83266b6b60b6727af986e84a133dae24d394c3e8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 3 17:19:31 2015 +0100

    ALSA: Fix compat_ioctl handling for OSS emulations
    
    The ALSA PCM, mixer and sequencer OSS emulations provide the 32bit
    compatible ioctl, but they just call the 64bit native ioctl as is.
    Although this works in most cases, passing the argument value as-is
    isn't guaranteed to work on all architectures.  We need to convert it
    via compat_ptr() instead.
    
    This patch addresses the missing conversions.  Since all relevant
    ioctls in these functions take the argument as a pointer, we do the
    pointer conversion in each compat_ioctl and pass it as a 64bit value
    to the native ioctl.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 7a8c79dd9734..2ff9c12d664a 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -24,6 +24,7 @@
 #include <linux/time.h>
 #include <linux/string.h>
 #include <linux/module.h>
+#include <linux/compat.h>
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/control.h>
@@ -397,7 +398,12 @@ int snd_mixer_oss_ioctl_card(struct snd_card *card, unsigned int cmd, unsigned l
 
 #ifdef CONFIG_COMPAT
 /* all compatible */
-#define snd_mixer_oss_ioctl_compat	snd_mixer_oss_ioctl
+static long snd_mixer_oss_ioctl_compat(struct file *file, unsigned int cmd,
+				       unsigned long arg)
+{
+	return snd_mixer_oss_ioctl1(file->private_data, cmd,
+				    (unsigned long)compat_ptr(arg));
+}
 #else
 #define snd_mixer_oss_ioctl_compat	NULL
 #endif

commit 5a1f8c42259a424cfd262185da872764dcc673ad
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Oct 15 10:01:42 2015 +0300

    ALSA: oss: underflow in snd_mixer_oss_proc_write()
    
    We cap the upper bound of "idx" but not the negative side.  Let's make
    it unsigned to fix this.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index a99f7200ff3f..7a8c79dd9734 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1177,7 +1177,8 @@ static void snd_mixer_oss_proc_write(struct snd_info_entry *entry,
 	struct snd_mixer_oss *mixer = entry->private_data;
 	char line[128], str[32], idxstr[16];
 	const char *cptr;
-	int ch, idx;
+	unsigned int idx;
+	int ch;
 	struct snd_mixer_oss_assign_table *tbl;
 	struct slot *slot;
 

commit cd6a65036f0eac4ad83dc371bb458e9e6ba6e306
Author: Jie Yang <yang.jie@intel.com>
Date:   Wed May 27 19:45:45 2015 +0800

    ALSA: replace CONFIG_PROC_FS with CONFIG_SND_PROC_FS
    
    We may disable proc fs only for sound part, to reduce ALSA
    memory footprint. So add CONFIG_SND_PROC_FS and replace the
    old CONFIG_PROC_FSs in alsa code.
    
    With sound proc fs disabled, we can save about 9KB memory
    size on X86_64 platform.
    
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 056f8e274851..a99f7200ff3f 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1111,7 +1111,7 @@ static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer, struct snd_mix
 	return 0;
 }
 
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_SND_PROC_FS
 /*
  */
 #define MIXER_VOL(name) [SOUND_MIXER_##name] = #name
@@ -1255,10 +1255,10 @@ static void snd_mixer_oss_proc_done(struct snd_mixer_oss *mixer)
 	snd_info_free_entry(mixer->proc_entry);
 	mixer->proc_entry = NULL;
 }
-#else /* !CONFIG_PROC_FS */
+#else /* !CONFIG_SND_PROC_FS */
 #define snd_mixer_oss_proc_init(mix)
 #define snd_mixer_oss_proc_done(mix)
-#endif /* CONFIG_PROC_FS */
+#endif /* CONFIG_SND_PROC_FS */
 
 static void snd_mixer_oss_build(struct snd_mixer_oss *mixer)
 {

commit ec0e9937aaa8b0a4b0633711c4d70d622acd9a7f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 10 15:42:14 2015 +0100

    ALSA: core: Drop superfluous error/debug messages after malloc failures
    
    The kernel memory allocators already report the errors when the
    requested allocation fails, thus we don't need to warn it again in
    each caller side.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 5e6349f00ecd..056f8e274851 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1212,10 +1212,8 @@ static void snd_mixer_oss_proc_write(struct snd_info_entry *entry,
 			/* not changed */
 			goto __unlock;
 		tbl = kmalloc(sizeof(*tbl), GFP_KERNEL);
-		if (! tbl) {
-			pr_err("ALSA: mixer_oss: no memory\n");
+		if (!tbl)
 			goto __unlock;
-		}
 		tbl->oss_id = ch;
 		tbl->name = kstrdup(str, GFP_KERNEL);
 		if (! tbl->name) {

commit 61efcee8608c38c1f3147aee9c60248b6e2b141f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:22:11 2014 +0100

    ALSA: oss: Use standard printk helpers
    
    Use dev_err() & co as much as possible.  If not available (no device
    assigned at the calling point), use pr_xxx() helpers instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index fcb810142a49..5e6349f00ecd 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1187,7 +1187,8 @@ static void snd_mixer_oss_proc_write(struct snd_info_entry *entry,
 			if (oss_mixer_names[ch] && strcmp(oss_mixer_names[ch], str) == 0)
 				break;
 		if (ch >= SNDRV_OSS_MAX_MIXERS) {
-			snd_printk(KERN_ERR "mixer_oss: invalid OSS volume '%s'\n", str);
+			pr_err("ALSA: mixer_oss: invalid OSS volume '%s'\n",
+			       str);
 			continue;
 		}
 		cptr = snd_info_get_str(str, cptr, sizeof(str));
@@ -1201,7 +1202,7 @@ static void snd_mixer_oss_proc_write(struct snd_info_entry *entry,
 		snd_info_get_str(idxstr, cptr, sizeof(idxstr));
 		idx = simple_strtoul(idxstr, NULL, 10);
 		if (idx >= 0x4000) { /* too big */
-			snd_printk(KERN_ERR "mixer_oss: invalid index %d\n", idx);
+			pr_err("ALSA: mixer_oss: invalid index %d\n", idx);
 			continue;
 		}
 		mutex_lock(&mixer->reg_mutex);
@@ -1212,7 +1213,7 @@ static void snd_mixer_oss_proc_write(struct snd_info_entry *entry,
 			goto __unlock;
 		tbl = kmalloc(sizeof(*tbl), GFP_KERNEL);
 		if (! tbl) {
-			snd_printk(KERN_ERR "mixer_oss: no memory\n");
+			pr_err("ALSA: mixer_oss: no memory\n");
 			goto __unlock;
 		}
 		tbl->oss_id = ch;
@@ -1352,8 +1353,9 @@ static int snd_mixer_oss_notify_handler(struct snd_card *card, int cmd)
 		if ((err = snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER,
 						   card, 0,
 						   &snd_mixer_oss_f_ops, card)) < 0) {
-			snd_printk(KERN_ERR "unable to register OSS mixer device %i:%i\n",
-				   card->number, 0);
+			dev_err(card->dev,
+				"unable to register OSS mixer device %i:%i\n",
+				card->number, 0);
 			kfree(mixer);
 			return err;
 		}

commit 80d7d771ae839d6fc2286f443ad8445b6721a7f3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 13:51:45 2014 +0100

    ALSA: Drop unused name argument in snd_register_oss_device()
    
    The last argument, name, of snd_oss_register_device() is nowhere
    referred in the function in the current code.  Let's drop it.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index e8a1d18774b2..fcb810142a49 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1343,18 +1343,15 @@ static int snd_mixer_oss_notify_handler(struct snd_card *card, int cmd)
 	struct snd_mixer_oss *mixer;
 
 	if (cmd == SND_MIXER_OSS_NOTIFY_REGISTER) {
-		char name[128];
 		int idx, err;
 
 		mixer = kcalloc(2, sizeof(*mixer), GFP_KERNEL);
 		if (mixer == NULL)
 			return -ENOMEM;
 		mutex_init(&mixer->reg_mutex);
-		sprintf(name, "mixer%i%i", card->number, 0);
 		if ((err = snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER,
 						   card, 0,
-						   &snd_mixer_oss_f_ops, card,
-						   name)) < 0) {
+						   &snd_mixer_oss_f_ops, card)) < 0) {
 			snd_printk(KERN_ERR "unable to register OSS mixer device %i:%i\n",
 				   card->number, 0);
 			kfree(mixer);
@@ -1365,7 +1362,8 @@ static int snd_mixer_oss_notify_handler(struct snd_card *card, int cmd)
 		if (*card->mixername)
 			strlcpy(mixer->name, card->mixername, sizeof(mixer->name));
 		else
-			strlcpy(mixer->name, name, sizeof(mixer->name));
+			snprintf(mixer->name, sizeof(mixer->name),
+				 "mixer%i", card->number);
 #ifdef SNDRV_OSS_INFO_DEV_MIXERS
 		snd_oss_info_register(SNDRV_OSS_INFO_DEV_MIXERS,
 				      card->number,

commit 8bb4d9ce08b0a92ca174e41d92c180328f86173f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 8 14:36:18 2012 +0100

    ALSA: Fix card refcount unbalance
    
    There are uncovered cases whether the card refcount introduced by the
    commit a0830dbd isn't properly increased or decreased:
    - OSS PCM and mixer success paths
    - When lookup function gets NULL
    
    This patch fixes these places.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=50251
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index a9a2e63c0222..e8a1d18774b2 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -76,6 +76,7 @@ static int snd_mixer_oss_open(struct inode *inode, struct file *file)
 		snd_card_unref(card);
 		return -EFAULT;
 	}
+	snd_card_unref(card);
 	return 0;
 }
 

commit a0830dbd4e42b38aefdf3fb61ba5019a1a99ea85
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 16 13:05:59 2012 +0200

    ALSA: Add a reference counter to card instance
    
    For more strict protection for wild disconnections, a refcount is
    introduced to the card instance, and let it up/down when an object is
    referred via snd_lookup_*() in the open ops.
    
    The free-after-last-close check is also changed to check this refcount
    instead of the empty list, too.
    
    Reported-by: Matthieu CASTET <matthieu.castet@parrot.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 29f6ded02555..a9a2e63c0222 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -52,14 +52,19 @@ static int snd_mixer_oss_open(struct inode *inode, struct file *file)
 					 SNDRV_OSS_DEVICE_TYPE_MIXER);
 	if (card == NULL)
 		return -ENODEV;
-	if (card->mixer_oss == NULL)
+	if (card->mixer_oss == NULL) {
+		snd_card_unref(card);
 		return -ENODEV;
+	}
 	err = snd_card_file_add(card, file);
-	if (err < 0)
+	if (err < 0) {
+		snd_card_unref(card);
 		return err;
+	}
 	fmixer = kzalloc(sizeof(*fmixer), GFP_KERNEL);
 	if (fmixer == NULL) {
 		snd_card_file_remove(card, file);
+		snd_card_unref(card);
 		return -ENOMEM;
 	}
 	fmixer->card = card;
@@ -68,6 +73,7 @@ static int snd_mixer_oss_open(struct inode *inode, struct file *file)
 	if (!try_module_get(card->module)) {
 		kfree(fmixer);
 		snd_card_file_remove(card, file);
+		snd_card_unref(card);
 		return -EFAULT;
 	}
 	return 0;

commit 1f3b14072bacc80d62597ed7798e3daf7615dcc6
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Sun Sep 2 22:10:27 2012 +0800

    ALSA: fix possible memory leak in snd_mixer_oss_build_input()
    
    uinfo has been allocated in this function and should be
    freed before leaving from the error handling cases.
    
    spatch with a semantic match is used to found this problem.
    (http://coccinelle.lip6.fr/)
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 18297f7f2c55..29f6ded02555 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1046,6 +1046,7 @@ static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer, struct snd_mix
 			
 		if (kctl->info(kctl, uinfo)) {
 			up_read(&mixer->card->controls_rwsem);
+			kfree(uinfo);
 			return 0;
 		}
 		strcpy(str, ptr->name);
@@ -1061,6 +1062,7 @@ static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer, struct snd_mix
 				uinfo->value.enumerated.item = slot.capture_item;
 				if (kctl->info(kctl, uinfo)) {
 					up_read(&mixer->card->controls_rwsem);
+					kfree(uinfo);
 					return 0;
 				}
 				if (!strcmp(uinfo->value.enumerated.name, str)) {

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 1b5e0c49a0ad..18297f7f2c55 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -23,6 +23,7 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/string.h>
+#include <linux/module.h>
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/control.h>

commit f92766bc8948f978a838a5607bea95804c8dfdfe
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Oct 4 09:29:39 2011 +0300

    ALSA: oss-mixer - use strlcpy() instead strcpy()
    
    This is mostly a static checker fix more than anything else.  We're
    copying from a 64 char buffer into a 44 char buffer.
    
    The 64 character buffer is str[] in snd_mixer_oss_build_test_all().
    The call tree is:
            snd_mixer_oss_build_test_all()
            -> snd_mixer_oss_build_test()
               -> snd_mixer_oss_build_test().
    
    We never actually do fill str[] buffer all the way to 64 characters.
    The longest string is:
            sprintf(str, "%s Playback Switch", ptr->name);
    ptr->name is a 32 character buffer so 32 plus 16 characters for
    " Playback Switch" still puts us over the 44 limit from "id.name".
    
    Most likely ptr->name never gets filled to the limit, but we can't
    really change the size of that buffer so lets just use strlcpy() here
    and be safe.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index d8359cfeca15..1b5e0c49a0ad 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -499,7 +499,7 @@ static struct snd_kcontrol *snd_mixer_oss_test_id(struct snd_mixer_oss *mixer, c
 	
 	memset(&id, 0, sizeof(id));
 	id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
-	strcpy(id.name, name);
+	strlcpy(id.name, name, sizeof(id.name));
 	id.index = index;
 	return snd_ctl_find_id(card, &id);
 }

commit fea952e5cc23ea94b4677ca20774cdc3cea014e2
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Feb 14 11:00:47 2011 +0100

    ALSA: core: sparse cleanups
    
    Change the core code where sparse complains.  In most cases, this means
    just adding annotations to confirm that we indeed want to do the dirty
    things we're doing.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 822dd56993ca..d8359cfeca15 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -190,9 +190,10 @@ static int snd_mixer_oss_get_recsrc(struct snd_mixer_oss_file *fmixer)
 		return -EIO;
 	if (mixer->put_recsrc && mixer->get_recsrc) {	/* exclusive */
 		int err;
-		if ((err = mixer->get_recsrc(fmixer, &result)) < 0)
+		unsigned int index;
+		if ((err = mixer->get_recsrc(fmixer, &index)) < 0)
 			return err;
-		result = 1 << result;
+		result = 1 << index;
 	} else {
 		struct snd_mixer_oss_slot *pslot;
 		int chn;
@@ -214,6 +215,7 @@ static int snd_mixer_oss_set_recsrc(struct snd_mixer_oss_file *fmixer, int recsr
 	struct snd_mixer_oss *mixer = fmixer->mixer;
 	struct snd_mixer_oss_slot *pslot;
 	int chn, active;
+	unsigned int index;
 	int result = 0;
 
 	if (mixer == NULL)
@@ -222,8 +224,8 @@ static int snd_mixer_oss_set_recsrc(struct snd_mixer_oss_file *fmixer, int recsr
 		if (recsrc & ~mixer->oss_recsrc)
 			recsrc &= ~mixer->oss_recsrc;
 		mixer->put_recsrc(fmixer, ffz(~recsrc));
-		mixer->get_recsrc(fmixer, &result);
-		result = 1 << result;
+		mixer->get_recsrc(fmixer, &index);
+		result = 1 << index;
 	}
 	for (chn = 0; chn < 31; chn++) {
 		pslot = &mixer->slots[chn];

commit e799d0bce6b191de6e96e556528243c1d73303ca
Merge: 1d2019fb6be2 838c364ff05c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 11 13:56:12 2010 +0200

    Merge remote branch 'alsa/devel' into topic/misc

commit 838c364ff05c143fd1810e8ad1469935d6c23a7a
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Oct 8 10:48:50 2010 +0200

    ALSA: OSS mixer emulation - fix locking
    
    Fix mutex release and cleanup some locking code.
    
    Cc: <stable@kernel.org>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index f50ebf20df96..8442a088677d 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -618,8 +618,10 @@ static void snd_mixer_oss_put_volume1_vol(struct snd_mixer_oss_file *fmixer,
 	if (numid == ID_UNKNOWN)
 		return;
 	down_read(&card->controls_rwsem);
-	if ((kctl = snd_ctl_find_numid(card, numid)) == NULL)
+	if ((kctl = snd_ctl_find_numid(card, numid)) == NULL) {
+		up_read(&card->controls_rwsem);
 		return;
+	}
 	uinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);
 	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (uinfo == NULL || uctl == NULL)
@@ -658,7 +660,7 @@ static void snd_mixer_oss_put_volume1_sw(struct snd_mixer_oss_file *fmixer,
 		return;
 	down_read(&card->controls_rwsem);
 	if ((kctl = snd_ctl_find_numid(card, numid)) == NULL) {
-		up_read(&fmixer->card->controls_rwsem);
+		up_read(&card->controls_rwsem);
 		return;
 	}
 	uinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);
@@ -797,7 +799,7 @@ static int snd_mixer_oss_get_recsrc2(struct snd_mixer_oss_file *fmixer, unsigned
 	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (uinfo == NULL || uctl == NULL) {
 		err = -ENOMEM;
-		goto __unlock;
+		goto __free_only;
 	}
 	down_read(&card->controls_rwsem);
 	kctl = snd_mixer_oss_test_id(mixer, "Capture Source", 0);
@@ -826,6 +828,7 @@ static int snd_mixer_oss_get_recsrc2(struct snd_mixer_oss_file *fmixer, unsigned
 	err = 0;
       __unlock:
      	up_read(&card->controls_rwsem);
+      __free_only:
       	kfree(uctl);
       	kfree(uinfo);
       	return err;
@@ -847,7 +850,7 @@ static int snd_mixer_oss_put_recsrc2(struct snd_mixer_oss_file *fmixer, unsigned
 	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (uinfo == NULL || uctl == NULL) {
 		err = -ENOMEM;
-		goto __unlock;
+		goto __free_only;
 	}
 	down_read(&card->controls_rwsem);
 	kctl = snd_mixer_oss_test_id(mixer, "Capture Source", 0);
@@ -880,6 +883,7 @@ static int snd_mixer_oss_put_recsrc2(struct snd_mixer_oss_file *fmixer, unsigned
 	err = 0;
       __unlock:
 	up_read(&card->controls_rwsem);
+      __free_only:
 	kfree(uctl);
 	kfree(uinfo);
 	return err;

commit 9fe856e47e1751204faf3d604c6d20ab24bd3b93
Author: Joe Perches <joe@perches.com>
Date:   Sat Sep 4 18:52:54 2010 -0700

    sound: Remove unnecessary casts of private_data
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index f50ebf20df96..86afb13cd240 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -77,7 +77,7 @@ static int snd_mixer_oss_release(struct inode *inode, struct file *file)
 	struct snd_mixer_oss_file *fmixer;
 
 	if (file->private_data) {
-		fmixer = (struct snd_mixer_oss_file *) file->private_data;
+		fmixer = file->private_data;
 		module_put(fmixer->card->module);
 		snd_card_file_remove(fmixer->card, file);
 		kfree(fmixer);
@@ -368,7 +368,7 @@ static int snd_mixer_oss_ioctl1(struct snd_mixer_oss_file *fmixer, unsigned int
 
 static long snd_mixer_oss_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	return snd_mixer_oss_ioctl1((struct snd_mixer_oss_file *) file->private_data, cmd, arg);
+	return snd_mixer_oss_ioctl1(file->private_data, cmd, arg);
 }
 
 int snd_mixer_oss_ioctl_card(struct snd_card *card, unsigned int cmd, unsigned long arg)
@@ -582,7 +582,7 @@ static int snd_mixer_oss_get_volume1(struct snd_mixer_oss_file *fmixer,
 				     struct snd_mixer_oss_slot *pslot,
 				     int *left, int *right)
 {
-	struct slot *slot = (struct slot *)pslot->private_data;
+	struct slot *slot = pslot->private_data;
 	
 	*left = *right = 100;
 	if (slot->present & SNDRV_MIXER_OSS_PRESENT_PVOLUME) {
@@ -691,7 +691,7 @@ static int snd_mixer_oss_put_volume1(struct snd_mixer_oss_file *fmixer,
 				     struct snd_mixer_oss_slot *pslot,
 				     int left, int right)
 {
-	struct slot *slot = (struct slot *)pslot->private_data;
+	struct slot *slot = pslot->private_data;
 	
 	if (slot->present & SNDRV_MIXER_OSS_PRESENT_PVOLUME) {
 		snd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PVOLUME], left, right);
@@ -740,7 +740,7 @@ static int snd_mixer_oss_get_recsrc1_sw(struct snd_mixer_oss_file *fmixer,
 					struct snd_mixer_oss_slot *pslot,
 					int *active)
 {
-	struct slot *slot = (struct slot *)pslot->private_data;
+	struct slot *slot = pslot->private_data;
 	int left, right;
 	
 	left = right = 1;
@@ -753,7 +753,7 @@ static int snd_mixer_oss_get_recsrc1_route(struct snd_mixer_oss_file *fmixer,
 					   struct snd_mixer_oss_slot *pslot,
 					   int *active)
 {
-	struct slot *slot = (struct slot *)pslot->private_data;
+	struct slot *slot = pslot->private_data;
 	int left, right;
 	
 	left = right = 1;
@@ -766,7 +766,7 @@ static int snd_mixer_oss_put_recsrc1_sw(struct snd_mixer_oss_file *fmixer,
 					struct snd_mixer_oss_slot *pslot,
 					int active)
 {
-	struct slot *slot = (struct slot *)pslot->private_data;
+	struct slot *slot = pslot->private_data;
 	
 	snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CSWITCH], active, active, 0);
 	return 0;
@@ -776,7 +776,7 @@ static int snd_mixer_oss_put_recsrc1_route(struct snd_mixer_oss_file *fmixer,
 					   struct snd_mixer_oss_slot *pslot,
 					   int active)
 {
-	struct slot *slot = (struct slot *)pslot->private_data;
+	struct slot *slot = pslot->private_data;
 	
 	snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CROUTE], active, active, 1);
 	return 0;
@@ -813,7 +813,7 @@ static int snd_mixer_oss_get_recsrc2(struct snd_mixer_oss_file *fmixer, unsigned
 		if (!(mixer->mask_recsrc & (1 << idx)))
 			continue;
 		pslot = &mixer->slots[idx];
-		slot = (struct slot *)pslot->private_data;
+		slot = pslot->private_data;
 		if (slot->signature != SNDRV_MIXER_OSS_SIGNATURE)
 			continue;
 		if (!(slot->present & SNDRV_MIXER_OSS_PRESENT_CAPTURE))
@@ -861,7 +861,7 @@ static int snd_mixer_oss_put_recsrc2(struct snd_mixer_oss_file *fmixer, unsigned
 		if (!(mixer->mask_recsrc & (1 << idx)))
 			continue;
 		pslot = &mixer->slots[idx];
-		slot = (struct slot *)pslot->private_data;
+		slot = pslot->private_data;
 		if (slot->signature != SNDRV_MIXER_OSS_SIGNATURE)
 			continue;
 		if (!(slot->present & SNDRV_MIXER_OSS_PRESENT_CAPTURE))
@@ -925,7 +925,7 @@ static int snd_mixer_oss_build_test(struct snd_mixer_oss *mixer, struct slot *sl
 
 static void snd_mixer_oss_slot_free(struct snd_mixer_oss_slot *chn)
 {
-	struct slot *p = (struct slot *)chn->private_data;
+	struct slot *p = chn->private_data;
 	if (p) {
 		if (p->allocated && p->assigned) {
 			kfree(p->assigned->name);

commit 02f4865fa415a87de28cc8c2e4d798ff46be1cf8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 13 11:49:04 2010 +0200

    ALSA: core - Define llseek fops
    
    Set no_llseek to llseek file ops of each sound component (but for hwdep).
    This avoids the implicit BKL invocation via generic_file_llseek() used
    as default when fops.llseek is NULL.
    
    Also call nonseekable_open() at each open ops to ensure the file flags
    have no seek bit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 54e2eb56e4c2..f50ebf20df96 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -43,6 +43,10 @@ static int snd_mixer_oss_open(struct inode *inode, struct file *file)
 	struct snd_mixer_oss_file *fmixer;
 	int err;
 
+	err = nonseekable_open(inode, file);
+	if (err < 0)
+		return err;
+
 	card = snd_lookup_oss_minor_data(iminor(inode),
 					 SNDRV_OSS_DEVICE_TYPE_MIXER);
 	if (card == NULL)
@@ -397,6 +401,7 @@ static const struct file_operations snd_mixer_oss_f_ops =
 	.owner =	THIS_MODULE,
 	.open =		snd_mixer_oss_open,
 	.release =	snd_mixer_oss_release,
+	.llseek =	no_llseek,
 	.unlocked_ioctl =	snd_mixer_oss_ioctl,
 	.compat_ioctl =	snd_mixer_oss_ioctl_compat,
 };

commit ad1cd745060ae2f24026b3b3d09da3426df6ab36
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Wed Nov 4 14:30:36 2009 +0100

    ALSA: rename "PC Speaker" controls to "Speaker"
    
    To unify control names, rename "PC Speaker" to "Speaker" for PPC ALSA drivers.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index b935ac9dce8d..54e2eb56e4c2 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1253,6 +1253,7 @@ static void snd_mixer_oss_build(struct snd_mixer_oss *mixer)
 		{ SOUND_MIXER_PCM,	"PCM",			0 },
 		{ SOUND_MIXER_SPEAKER,	"Beep", 		0 },
 		{ SOUND_MIXER_SPEAKER,	"PC Speaker", 		0 }, /* fallback */
+		{ SOUND_MIXER_SPEAKER,	"Speaker", 		0 }, /* fallback */
 		{ SOUND_MIXER_LINE,	"Line", 		0 },
 		{ SOUND_MIXER_MIC,	"Mic", 			0 },
 		{ SOUND_MIXER_CD,	"CD", 			0 },

commit d355c82a0191d5a3e971bd5af96cc81fe3ed25b9
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Tue Nov 3 15:47:25 2009 +0100

    ALSA: rename "PC Speaker" and "PC Beep" controls to "Beep"
    
    To avoid confusion in control names for the standard analog PC Beep generator
    using a small Internal PC Speaker, rename all related "PC Speaker" and "PC
    Beep" controls to "Beep" only. This name is more universal and can be also
    used on more platforms without confusion.
    
    Introduce also "Internal Speaker" in ControlNames.txt for systems with
    full-featured build-in internal speaker.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 772423889eb3..b935ac9dce8d 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1251,7 +1251,8 @@ static void snd_mixer_oss_build(struct snd_mixer_oss *mixer)
 		{ SOUND_MIXER_SYNTH,	"FM",			0 }, /* fallback */
 		{ SOUND_MIXER_SYNTH,	"Music",		0 }, /* fallback */
 		{ SOUND_MIXER_PCM,	"PCM",			0 },
-		{ SOUND_MIXER_SPEAKER,	"PC Speaker", 		0 },
+		{ SOUND_MIXER_SPEAKER,	"Beep", 		0 },
+		{ SOUND_MIXER_SPEAKER,	"PC Speaker", 		0 }, /* fallback */
 		{ SOUND_MIXER_LINE,	"Line", 		0 },
 		{ SOUND_MIXER_MIC,	"Mic", 			0 },
 		{ SOUND_MIXER_CD,	"CD", 			0 },

commit 4f7454a9970fa0f3e9f1a68201520e3df1bb5224
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 8 14:29:58 2009 +0200

    ALSA: Add const prefix to proc helper functions
    
    Add appropriate const prefix to char * arguments in proc helper functions.
    Also fixed the caller side to be proper const pointers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 5dcd8a526970..772423889eb3 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1154,7 +1154,8 @@ static void snd_mixer_oss_proc_write(struct snd_info_entry *entry,
 				     struct snd_info_buffer *buffer)
 {
 	struct snd_mixer_oss *mixer = entry->private_data;
-	char line[128], str[32], idxstr[16], *cptr;
+	char line[128], str[32], idxstr[16];
+	const char *cptr;
 	int ch, idx;
 	struct snd_mixer_oss_assign_table *tbl;
 	struct slot *slot;

commit d2e8e52976b9d0a34db529b06952d5187b78af8c
Author: Deepika Makhija <deepika.makhija@einfochips.com>
Date:   Sat Apr 4 18:08:28 2009 +0530

    ALSA: oss - volume control for CSWITCH and CROUTE
    
    Added an else part to check
    SNDRV_MIXER_OSS_PRESENT_CVOLUME for MIC (slot 7)
    in commit 36c7b833e5d2501142a371e4e75281d3a29fbd6b
    
    Similarly, checks and volume control is required for
    SNDRV_MIXER_OSS_PRESENT_CSWITCH and SNDRV_MIXER_OSS_PRESENT_CROUTE
    as well.
    
    Signed-off-by: Deepika Makhija <deepika.makhija@einfochips.com>
    Signed-off-by: Viral Mehta <viral.mehta@einfochips.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index e570649184e2..5dcd8a526970 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -703,19 +703,27 @@ static int snd_mixer_oss_put_volume1(struct snd_mixer_oss_file *fmixer,
 	if (left || right) {
 		if (slot->present & SNDRV_MIXER_OSS_PRESENT_PSWITCH)
 			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PSWITCH], left, right, 0);
+		if (slot->present & SNDRV_MIXER_OSS_PRESENT_CSWITCH)
+			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CSWITCH], left, right, 0);
 		if (slot->present & SNDRV_MIXER_OSS_PRESENT_GSWITCH)
 			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GSWITCH], left, right, 0);
 		if (slot->present & SNDRV_MIXER_OSS_PRESENT_PROUTE)
 			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PROUTE], left, right, 1);
+		if (slot->present & SNDRV_MIXER_OSS_PRESENT_CROUTE)
+			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CROUTE], left, right, 1);
 		if (slot->present & SNDRV_MIXER_OSS_PRESENT_GROUTE)
 			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GROUTE], left, right, 1);
 	} else {
 		if (slot->present & SNDRV_MIXER_OSS_PRESENT_PSWITCH) {
 			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PSWITCH], left, right, 0);
+		} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_CSWITCH) {
+			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CSWITCH], left, right, 0);
 		} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GSWITCH) {
 			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GSWITCH], left, right, 0);
 		} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_PROUTE) {
 			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PROUTE], left, right, 1);
+		} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_CROUTE) {
+			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CROUTE], left, right, 1);
 		} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GROUTE) {
 			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GROUTE], left, right, 1);
 		}

commit 36c7b833e5d2501142a371e4e75281d3a29fbd6b
Author: Viral Mehta <viral.mehta@einfochips.com>
Date:   Tue Mar 10 15:43:18 2009 +0100

    ALSA: oss-mixer - Fixes recording gain control
    
    At the time of initialization, SNDRV_MIXER_OSS_PRESENT_PVOLUME bit is not
    set for MIC (slot 7).
    So, the same should not be checked when an application tries to do gain
    control for audio recording devices.
    
    Just check slot->present for SNDRV_MIXER_OSS_PRESENT_CVOLUME independently.
    Verified with a simple application which opens /dev/dsp for recording and
    /dev/mixer for volume control.
    
    Have tested two usb audio mic devices.
    
    Signed-off-by: Viral Mehta <viral.mehta@einfochips.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 4690b8b5681f..e570649184e2 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -692,6 +692,9 @@ static int snd_mixer_oss_put_volume1(struct snd_mixer_oss_file *fmixer,
 		snd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PVOLUME], left, right);
 		if (slot->present & SNDRV_MIXER_OSS_PRESENT_CVOLUME)
 			snd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CVOLUME], left, right);
+	} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_CVOLUME) {
+		snd_mixer_oss_put_volume1_vol(fmixer, pslot,
+			slot->numid[SNDRV_MIXER_OSS_ITEM_CVOLUME], left, right);
 	} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GVOLUME) {
 		snd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GVOLUME], left, right);
 	} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GLOBAL) {

commit 7eaa943c8ed8e91e05d0f5d0dc7a18e3319b45cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:09:09 2008 +0200

    ALSA: Kill snd_assert() in sound/core/*
    
    Kill snd_assert() in sound/core/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 581aa2c60e65..4690b8b5681f 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -257,8 +257,10 @@ static int snd_mixer_oss_get_volume(struct snd_mixer_oss_file *fmixer, int slot)
 		result = pslot->get_volume(fmixer, pslot, &left, &right);
 	if (!pslot->stereo)
 		right = left;
-	snd_assert(left >= 0 && left <= 100, return -EIO);
-	snd_assert(right >= 0 && right <= 100, return -EIO);
+	if (snd_BUG_ON(left < 0 || left > 100))
+		return -EIO;
+	if (snd_BUG_ON(right < 0 || right > 100))
+		return -EIO;
 	if (result >= 0) {
 		pslot->volume[0] = left;
 		pslot->volume[1] = right;
@@ -298,7 +300,8 @@ static int snd_mixer_oss_ioctl1(struct snd_mixer_oss_file *fmixer, unsigned int
 	int __user *p = argp;
 	int tmp;
 
-	snd_assert(fmixer != NULL, return -ENXIO);
+	if (snd_BUG_ON(!fmixer))
+		return -ENXIO;
 	if (((cmd >> 8) & 0xff) == 'M') {
 		switch (cmd) {
 		case SOUND_MIXER_INFO:
@@ -368,7 +371,8 @@ int snd_mixer_oss_ioctl_card(struct snd_card *card, unsigned int cmd, unsigned l
 {
 	struct snd_mixer_oss_file fmixer;
 	
-	snd_assert(card != NULL, return -ENXIO);
+	if (snd_BUG_ON(!card))
+		return -ENXIO;
 	if (card->mixer_oss == NULL)
 		return -ENXIO;
 	memset(&fmixer, 0, sizeof(fmixer));
@@ -1284,9 +1288,11 @@ static int snd_mixer_oss_free1(void *private)
 	struct snd_card *card;
 	int idx;
  
-	snd_assert(mixer != NULL, return -ENXIO);
+	if (!mixer)
+		return 0;
 	card = mixer->card;
-	snd_assert(mixer == card->mixer_oss, return -ENXIO);
+	if (snd_BUG_ON(mixer != card->mixer_oss))
+		return -ENXIO;
 	card->mixer_oss = NULL;
 	for (idx = 0; idx < SNDRV_OSS_MAX_MIXERS; idx++) {
 		struct snd_mixer_oss_slot *chn = &mixer->slots[idx];

commit 6c4cc3a8ed15aacc06a5fd369639fef633cee2bc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 12:44:11 2008 +0100

    [ALSA] Add more fallbacks to OSS PHONEOUT mixer map
    
    Added more fallbacks to OSS PHONEOUT mixer mapping.  This corresponds
    to the speaker output in general, so now "Mono" and "Speaker" are
    assigned.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 75daed298a15..581aa2c60e65 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1257,6 +1257,8 @@ static void snd_mixer_oss_build(struct snd_mixer_oss *mixer)
 		{ SOUND_MIXER_DIGITAL3,	"Digital",		2 },
 		{ SOUND_MIXER_PHONEIN,	"Phone",		0 },
 		{ SOUND_MIXER_PHONEOUT,	"Master Mono",		0 },
+		{ SOUND_MIXER_PHONEOUT,	"Speaker",		0 }, /*fallback*/
+		{ SOUND_MIXER_PHONEOUT,	"Mono",			0 }, /*fallback*/
 		{ SOUND_MIXER_PHONEOUT,	"Phone",		0 }, /* fallback */
 		{ SOUND_MIXER_VIDEO,	"Video",		0 },
 		{ SOUND_MIXER_RADIO,	"Radio",		0 },

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index c5a5ab9cae8c..75daed298a15 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -19,7 +19,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/time.h>

commit 22a860a9e22fa077300e1e72170afb82bf695617
Author: Jean Delvare <khali@linux-fr.org>
Date:   Tue Jan 8 15:33:10 2008 -0800

    snd_mixer_oss_build_input(): fix for __you_cannot_kmalloc_that_much failure with gcc-3.2
    
    Rework this functions so that gcc-3.2 can successfully perform
    constant-folding.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 3ace4a5680ba..c5a5ab9cae8c 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -925,6 +925,68 @@ static void mixer_slot_clear(struct snd_mixer_oss_slot *rslot)
 	rslot->number = idx;
 }
 
+/* In a separate function to keep gcc 3.2 happy - do NOT merge this in
+   snd_mixer_oss_build_input! */
+static int snd_mixer_oss_build_test_all(struct snd_mixer_oss *mixer,
+					struct snd_mixer_oss_assign_table *ptr,
+					struct slot *slot)
+{
+	char str[64];
+	int err;
+
+	err = snd_mixer_oss_build_test(mixer, slot, ptr->name, ptr->index,
+				       SNDRV_MIXER_OSS_ITEM_GLOBAL);
+	if (err)
+		return err;
+	sprintf(str, "%s Switch", ptr->name);
+	err = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,
+				       SNDRV_MIXER_OSS_ITEM_GSWITCH);
+	if (err)
+		return err;
+	sprintf(str, "%s Route", ptr->name);
+	err = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,
+				       SNDRV_MIXER_OSS_ITEM_GROUTE);
+	if (err)
+		return err;
+	sprintf(str, "%s Volume", ptr->name);
+	err = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,
+				       SNDRV_MIXER_OSS_ITEM_GVOLUME);
+	if (err)
+		return err;
+	sprintf(str, "%s Playback Switch", ptr->name);
+	err = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,
+				       SNDRV_MIXER_OSS_ITEM_PSWITCH);
+	if (err)
+		return err;
+	sprintf(str, "%s Playback Route", ptr->name);
+	err = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,
+				       SNDRV_MIXER_OSS_ITEM_PROUTE);
+	if (err)
+		return err;
+	sprintf(str, "%s Playback Volume", ptr->name);
+	err = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,
+				       SNDRV_MIXER_OSS_ITEM_PVOLUME);
+	if (err)
+		return err;
+	sprintf(str, "%s Capture Switch", ptr->name);
+	err = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,
+				       SNDRV_MIXER_OSS_ITEM_CSWITCH);
+	if (err)
+		return err;
+	sprintf(str, "%s Capture Route", ptr->name);
+	err = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,
+				       SNDRV_MIXER_OSS_ITEM_CROUTE);
+	if (err)
+		return err;
+	sprintf(str, "%s Capture Volume", ptr->name);
+	err = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,
+				       SNDRV_MIXER_OSS_ITEM_CVOLUME);
+	if (err)
+		return err;
+
+	return 0;
+}
+
 /*
  * build an OSS mixer element.
  * ptr_allocated means the entry is dynamically allocated (change via proc file).
@@ -944,44 +1006,7 @@ static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer, struct snd_mix
 
 	memset(&slot, 0, sizeof(slot));
 	memset(slot.numid, 0xff, sizeof(slot.numid)); /* ID_UNKNOWN */
-	if (snd_mixer_oss_build_test(mixer, &slot, ptr->name, ptr->index,
-				     SNDRV_MIXER_OSS_ITEM_GLOBAL))
-		return 0;
-	sprintf(str, "%s Switch", ptr->name);
-	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
-				     SNDRV_MIXER_OSS_ITEM_GSWITCH))
-		return 0;
-	sprintf(str, "%s Route", ptr->name);
-	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
-				     SNDRV_MIXER_OSS_ITEM_GROUTE))
-		return 0;
-	sprintf(str, "%s Volume", ptr->name);
-	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
-				     SNDRV_MIXER_OSS_ITEM_GVOLUME))
-		return 0;
-	sprintf(str, "%s Playback Switch", ptr->name);
-	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
-				     SNDRV_MIXER_OSS_ITEM_PSWITCH))
-		return 0;
-	sprintf(str, "%s Playback Route", ptr->name);
-	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
-				     SNDRV_MIXER_OSS_ITEM_PROUTE))
-		return 0;
-	sprintf(str, "%s Playback Volume", ptr->name);
-	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
-				     SNDRV_MIXER_OSS_ITEM_PVOLUME))
-		return 0;
-	sprintf(str, "%s Capture Switch", ptr->name);
-	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
-				     SNDRV_MIXER_OSS_ITEM_CSWITCH))
-		return 0;
-	sprintf(str, "%s Capture Route", ptr->name);
-	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
-				     SNDRV_MIXER_OSS_ITEM_CROUTE))
-		return 0;
-	sprintf(str, "%s Capture Volume", ptr->name);
-	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
-				     SNDRV_MIXER_OSS_ITEM_CVOLUME))
+	if (snd_mixer_oss_build_test_all(mixer, ptr, &slot))
 		return 0;
 	down_read(&mixer->card->controls_rwsem);
 	if (ptr->index == 0 && (kctl = snd_mixer_oss_test_id(mixer, "Capture Source", 0)) != NULL) {

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index fccad8f0a6bb..3ace4a5680ba 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1,6 +1,6 @@
 /*
  *  OSS emulation layer for the mixer interface
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *
  *
  *   This program is free software; you can redistribute it and/or modify
@@ -33,7 +33,7 @@
 
 #define OSS_ALSAEMULVER         _SIOR ('M', 249, int)
 
-MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");
 MODULE_DESCRIPTION("Mixer OSS emulation for ALSA.");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS_SNDRV_MINOR(SNDRV_MINOR_OSS_MIXER);

commit e63340ae6b6205fef26b40a75673d1c9c0c8bb90
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue May 8 00:28:08 2007 -0700

    header cleaning: don't include smp_lock.h when not used
    
    Remove includes of <linux/smp_lock.h> where it is not used/needed.
    Suggested by Al Viro.
    
    Builds cleanly on x86_64, i386, alpha, ia64, powerpc, sparc,
    sparc64, and arm (all 59 defconfigs).
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 74a2923eb401..fccad8f0a6bb 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -21,7 +21,6 @@
 
 #include <sound/driver.h>
 #include <linux/init.h>
-#include <linux/smp_lock.h>
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/string.h>

commit 9c2e08c592cd357a8330c34def1e8ecfdcf53275
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:37 2007 -0800

    [PATCH] mark struct file_operations const 9
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 3391f2a9b4d1..74a2923eb401 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -390,7 +390,7 @@ int snd_mixer_oss_ioctl_card(struct snd_card *card, unsigned int cmd, unsigned l
  *  REGISTRATION PART
  */
 
-static struct file_operations snd_mixer_oss_f_ops =
+static const struct file_operations snd_mixer_oss_f_ops =
 {
 	.owner =	THIS_MODULE,
 	.open =		snd_mixer_oss_open,

commit 5cbded585d129d0226cb48ac4202b253c781be26
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Wed Dec 13 00:35:56 2006 -0800

    [PATCH] getting rid of all casts of k[cmz]alloc() calls
    
    Run this:
    
            #!/bin/sh
            for f in $(grep -Erl "\([^\)]*\) *k[cmz]alloc" *) ; do
              echo "De-casting $f..."
              perl -pi -e "s/ ?= ?\([^\)]*\) *(k[cmz]alloc) *\(/ = \1\(/" $f
            done
    
    And then go through and reinstate those cases where code is casting pointers
    to non-pointers.
    
    And then drop a few hunks which conflicted with outstanding work.
    
    Cc: Russell King <rmk@arm.linux.org.uk>, Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Ian Kent <raven@themaw.net>
    Cc: Steven French <sfrench@us.ibm.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index f4c67042e3ac..3391f2a9b4d1 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1023,7 +1023,7 @@ static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer, struct snd_mix
 	}
 	up_read(&mixer->card->controls_rwsem);
 	if (slot.present != 0) {
-		pslot = (struct slot *)kmalloc(sizeof(slot), GFP_KERNEL);
+		pslot = kmalloc(sizeof(slot), GFP_KERNEL);
 		if (! pslot)
 			return -ENOMEM;
 		*pslot = slot;

commit c461482c8072bb073e6146db320d3da85cdc89ad
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 23 14:38:23 2006 +0200

    [ALSA] Unregister device files at disconnection
    
    Orignally proposed by Sam Revitch <sam.revitch@gmail.com>.
    Unregister device files at disconnection to avoid the futher accesses.
    Also, the dev_unregister callback is removed and replaced with the
    combination of disconnect + free.
    A new function snd_card_free_when_closed() is introduced, which is
    used in USB disconnect callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 00c95def95aa..f4c67042e3ac 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1310,21 +1310,19 @@ static int snd_mixer_oss_notify_handler(struct snd_card *card, int cmd)
 		card->mixer_oss = mixer;
 		snd_mixer_oss_build(mixer);
 		snd_mixer_oss_proc_init(mixer);
-	} else if (cmd == SND_MIXER_OSS_NOTIFY_DISCONNECT) {
-		mixer = card->mixer_oss;
-		if (mixer == NULL || !mixer->oss_dev_alloc)
-			return 0;
-		snd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER, mixer->card, 0);
-		mixer->oss_dev_alloc = 0;
-	} else {		/* free */
+	} else {
 		mixer = card->mixer_oss;
 		if (mixer == NULL)
 			return 0;
+		if (mixer->oss_dev_alloc) {
 #ifdef SNDRV_OSS_INFO_DEV_MIXERS
-		snd_oss_info_unregister(SNDRV_OSS_INFO_DEV_MIXERS, mixer->card->number);
+			snd_oss_info_unregister(SNDRV_OSS_INFO_DEV_MIXERS, mixer->card->number);
 #endif
-		if (mixer->oss_dev_alloc)
 			snd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER, mixer->card, 0);
+			mixer->oss_dev_alloc = 0;
+		}
+		if (cmd == SND_MIXER_OSS_NOTIFY_DISCONNECT)
+			return 0;
 		snd_mixer_oss_proc_done(mixer);
 		return snd_mixer_oss_free1(mixer);
 	}

commit 746d4a02e68499fc6c1f8d0c43d2271853ade181
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 23 14:37:59 2006 +0200

    [ALSA] Fix disconnection of proc interface
    
    - Add the linked list to each proc entry to enable a single-shot
      disconnection (unregister)
    - Deprecate snd_info_unregister(), use snd_info_free_entry()
    - Removed NULL checks of snd_info_free_entry()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 75a9505c7445..00c95def95aa 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1193,10 +1193,8 @@ static void snd_mixer_oss_proc_init(struct snd_mixer_oss *mixer)
 
 static void snd_mixer_oss_proc_done(struct snd_mixer_oss *mixer)
 {
-	if (mixer->proc_entry) {
-		snd_info_unregister(mixer->proc_entry);
-		mixer->proc_entry = NULL;
-	}
+	snd_info_free_entry(mixer->proc_entry);
+	mixer->proc_entry = NULL;
 }
 #else /* !CONFIG_PROC_FS */
 #define snd_mixer_oss_proc_init(mix)

commit 59feddb25f9d925e86ee22596802405788bc050f
Author: Panagiotis Issaris <takis@issaris.org>
Date:   Tue Jul 25 15:28:03 2006 +0200

    [ALSA] Conversions from kmalloc+memset to k(z|c)alloc
    
    sound: Conversions from kmalloc+memset to k(c|z)alloc.
    
    Signed-off-by: Panagiotis Issaris <takis@issaris.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 71b5080fa66d..75a9505c7445 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -988,13 +988,12 @@ static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer, struct snd_mix
 	if (ptr->index == 0 && (kctl = snd_mixer_oss_test_id(mixer, "Capture Source", 0)) != NULL) {
 		struct snd_ctl_elem_info *uinfo;
 
-		uinfo = kmalloc(sizeof(*uinfo), GFP_KERNEL);
+		uinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);
 		if (! uinfo) {
 			up_read(&mixer->card->controls_rwsem);
 			return -ENOMEM;
 		}
 			
-		memset(uinfo, 0, sizeof(*uinfo));
 		if (kctl->info(kctl, uinfo)) {
 			up_read(&mixer->card->controls_rwsem);
 			return 0;

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 9c68bc3f97aa..71b5080fa66d 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1182,9 +1182,7 @@ static void snd_mixer_oss_proc_init(struct snd_mixer_oss *mixer)
 		return;
 	entry->content = SNDRV_INFO_CONTENT_TEXT;
 	entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
-	entry->c.text.read_size = 8192;
 	entry->c.text.read = snd_mixer_oss_proc_read;
-	entry->c.text.write_size = 8192;
 	entry->c.text.write = snd_mixer_oss_proc_write;
 	entry->private_data = mixer;
 	if (snd_info_register(entry) < 0) {

commit 1a60d4c5a0c4028559585a74e48593b16e1ca9b2
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:29:08 2006 +0100

    [ALSA] semaphore -> mutex (core part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index f08e65a2bffe..9c68bc3f97aa 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1095,7 +1095,7 @@ static void snd_mixer_oss_proc_read(struct snd_info_entry *entry,
 	struct snd_mixer_oss *mixer = entry->private_data;
 	int i;
 
-	down(&mixer->reg_mutex);
+	mutex_lock(&mixer->reg_mutex);
 	for (i = 0; i < SNDRV_OSS_MAX_MIXERS; i++) {
 		struct slot *p;
 
@@ -1110,7 +1110,7 @@ static void snd_mixer_oss_proc_read(struct snd_info_entry *entry,
 		else
 			snd_iprintf(buffer, "\"\" 0\n");
 	}
-	up(&mixer->reg_mutex);
+	mutex_unlock(&mixer->reg_mutex);
 }
 
 static void snd_mixer_oss_proc_write(struct snd_info_entry *entry,
@@ -1134,9 +1134,9 @@ static void snd_mixer_oss_proc_write(struct snd_info_entry *entry,
 		cptr = snd_info_get_str(str, cptr, sizeof(str));
 		if (! *str) {
 			/* remove the entry */
-			down(&mixer->reg_mutex);
+			mutex_lock(&mixer->reg_mutex);
 			mixer_slot_clear(&mixer->slots[ch]);
-			up(&mixer->reg_mutex);
+			mutex_unlock(&mixer->reg_mutex);
 			continue;
 		}
 		snd_info_get_str(idxstr, cptr, sizeof(idxstr));
@@ -1145,7 +1145,7 @@ static void snd_mixer_oss_proc_write(struct snd_info_entry *entry,
 			snd_printk(KERN_ERR "mixer_oss: invalid index %d\n", idx);
 			continue;
 		}
-		down(&mixer->reg_mutex);
+		mutex_lock(&mixer->reg_mutex);
 		slot = (struct slot *)mixer->slots[ch].private_data;
 		if (slot && slot->assigned &&
 		    slot->assigned->index == idx && ! strcmp(slot->assigned->name, str))
@@ -1168,7 +1168,7 @@ static void snd_mixer_oss_proc_write(struct snd_info_entry *entry,
 			kfree(tbl);
 		}
 	__unlock:
-		up(&mixer->reg_mutex);
+		mutex_unlock(&mixer->reg_mutex);
 	}
 }
 
@@ -1288,7 +1288,7 @@ static int snd_mixer_oss_notify_handler(struct snd_card *card, int cmd)
 		mixer = kcalloc(2, sizeof(*mixer), GFP_KERNEL);
 		if (mixer == NULL)
 			return -ENOMEM;
-		init_MUTEX(&mixer->reg_mutex);
+		mutex_init(&mixer->reg_mutex);
 		sprintf(name, "mixer%i%i", card->number, 0);
 		if ((err = snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER,
 						   card, 0,

commit 04f141a8800d022981f0405a8d307c98aba55105
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 1 10:43:51 2005 +0100

    [ALSA] Optimize for config without PROC_FS (seq and oss parts)
    
    Modules: ALSA<-OSS emulation,ALSA sequencer,ALSA<-OSS sequencer
    
    Optimize the code when compiled without CONFIG_PROC_FS (in seq and oss
    emulation parts).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 2d7a42014f51..f08e65a2bffe 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1053,6 +1053,7 @@ static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer, struct snd_mix
 	return 0;
 }
 
+#ifdef CONFIG_PROC_FS
 /*
  */
 #define MIXER_VOL(name) [SOUND_MIXER_##name] = #name
@@ -1200,6 +1201,10 @@ static void snd_mixer_oss_proc_done(struct snd_mixer_oss *mixer)
 		mixer->proc_entry = NULL;
 	}
 }
+#else /* !CONFIG_PROC_FS */
+#define snd_mixer_oss_proc_init(mix)
+#define snd_mixer_oss_proc_done(mix)
+#endif /* CONFIG_PROC_FS */
 
 static void snd_mixer_oss_build(struct snd_mixer_oss *mixer)
 {

commit f87135f56cb266e031f5ec081dfbde7e43f55e80
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:06:59 2005 +0100

    [ALSA] dynamic minors (3/6): store device-specific object pointers dynamically
    
    Instead of storing the pointers to the device-specific structures in an
    array, put them into the struct snd_minor, and look them up dynamically.
    
    This makes the device type modules independent of the minor number
    encoding.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 2dd6bf9b49ed..2d7a42014f51 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -41,12 +41,13 @@ MODULE_ALIAS_SNDRV_MINOR(SNDRV_MINOR_OSS_MIXER);
 
 static int snd_mixer_oss_open(struct inode *inode, struct file *file)
 {
-	int cardnum = SNDRV_MINOR_OSS_CARD(iminor(inode));
 	struct snd_card *card;
 	struct snd_mixer_oss_file *fmixer;
 	int err;
 
-	if ((card = snd_cards[cardnum]) == NULL)
+	card = snd_lookup_oss_minor_data(iminor(inode),
+					 SNDRV_OSS_DEVICE_TYPE_MIXER);
+	if (card == NULL)
 		return -ENODEV;
 	if (card->mixer_oss == NULL)
 		return -ENODEV;
@@ -1286,7 +1287,7 @@ static int snd_mixer_oss_notify_handler(struct snd_card *card, int cmd)
 		sprintf(name, "mixer%i%i", card->number, 0);
 		if ((err = snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER,
 						   card, 0,
-						   &snd_mixer_oss_f_ops,
+						   &snd_mixer_oss_f_ops, card,
 						   name)) < 0) {
 			snd_printk(KERN_ERR "unable to register OSS mixer device %i:%i\n",
 				   card->number, 0);

commit 2af677fc884fc6dc79e65c99050ea607ac8bab9b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:03:48 2005 +0100

    [ALSA] dynamic minors (1/6): store device type in struct snd_minor
    
    Instead of a comment string, store the device type in the snd_minor
    structure.  This makes snd_minor more flexible, and has the nice side
    effect that we don't need anymore to create a separate snd_minor
    template for registering a device but can pass the file_operations
    directly to snd_register_device().
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index e448002ca7b9..2dd6bf9b49ed 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -398,12 +398,6 @@ static struct file_operations snd_mixer_oss_f_ops =
 	.compat_ioctl =	snd_mixer_oss_ioctl_compat,
 };
 
-static struct snd_minor snd_mixer_oss_reg =
-{
-	.comment =	"mixer",
-	.f_ops =	&snd_mixer_oss_f_ops,
-};
-
 /*
  *  utilities
  */
@@ -1292,7 +1286,7 @@ static int snd_mixer_oss_notify_handler(struct snd_card *card, int cmd)
 		sprintf(name, "mixer%i%i", card->number, 0);
 		if ((err = snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER,
 						   card, 0,
-						   &snd_mixer_oss_reg,
+						   &snd_mixer_oss_f_ops,
 						   name)) < 0) {
 			snd_printk(KERN_ERR "unable to register OSS mixer device %i:%i\n",
 				   card->number, 0);

commit f956b4a3ae790e1bdde865ac42dd1b99b64a6256
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:01:22 2005 +0100

    [ALSA] Remove xxx_t typedefs: Mixer OSS-emulation
    
    Modules: ALSA<-OSS emulation
    
    Remove xxx_t typedefs from the core mixer OSS-emulation codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 214933cf5d49..e448002ca7b9 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -42,8 +42,8 @@ MODULE_ALIAS_SNDRV_MINOR(SNDRV_MINOR_OSS_MIXER);
 static int snd_mixer_oss_open(struct inode *inode, struct file *file)
 {
 	int cardnum = SNDRV_MINOR_OSS_CARD(iminor(inode));
-	snd_card_t *card;
-	snd_mixer_oss_file_t *fmixer;
+	struct snd_card *card;
+	struct snd_mixer_oss_file *fmixer;
 	int err;
 
 	if ((card = snd_cards[cardnum]) == NULL)
@@ -71,10 +71,10 @@ static int snd_mixer_oss_open(struct inode *inode, struct file *file)
 
 static int snd_mixer_oss_release(struct inode *inode, struct file *file)
 {
-	snd_mixer_oss_file_t *fmixer;
+	struct snd_mixer_oss_file *fmixer;
 
 	if (file->private_data) {
-		fmixer = (snd_mixer_oss_file_t *) file->private_data;
+		fmixer = (struct snd_mixer_oss_file *) file->private_data;
 		module_put(fmixer->card->module);
 		snd_card_file_remove(fmixer->card, file);
 		kfree(fmixer);
@@ -82,11 +82,11 @@ static int snd_mixer_oss_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static int snd_mixer_oss_info(snd_mixer_oss_file_t *fmixer,
+static int snd_mixer_oss_info(struct snd_mixer_oss_file *fmixer,
 			      mixer_info __user *_info)
 {
-	snd_card_t *card = fmixer->card;
-	snd_mixer_oss_t *mixer = fmixer->mixer;
+	struct snd_card *card = fmixer->card;
+	struct snd_mixer_oss *mixer = fmixer->mixer;
 	struct mixer_info info;
 	
 	memset(&info, 0, sizeof(info));
@@ -98,11 +98,11 @@ static int snd_mixer_oss_info(snd_mixer_oss_file_t *fmixer,
 	return 0;
 }
 
-static int snd_mixer_oss_info_obsolete(snd_mixer_oss_file_t *fmixer,
+static int snd_mixer_oss_info_obsolete(struct snd_mixer_oss_file *fmixer,
 				       _old_mixer_info __user *_info)
 {
-	snd_card_t *card = fmixer->card;
-	snd_mixer_oss_t *mixer = fmixer->mixer;
+	struct snd_card *card = fmixer->card;
+	struct snd_mixer_oss *mixer = fmixer->mixer;
 	_old_mixer_info info;
 	
 	memset(&info, 0, sizeof(info));
@@ -113,9 +113,9 @@ static int snd_mixer_oss_info_obsolete(snd_mixer_oss_file_t *fmixer,
 	return 0;
 }
 
-static int snd_mixer_oss_caps(snd_mixer_oss_file_t *fmixer)
+static int snd_mixer_oss_caps(struct snd_mixer_oss_file *fmixer)
 {
-	snd_mixer_oss_t *mixer = fmixer->mixer;
+	struct snd_mixer_oss *mixer = fmixer->mixer;
 	int result = 0;
 
 	if (mixer == NULL)
@@ -125,10 +125,10 @@ static int snd_mixer_oss_caps(snd_mixer_oss_file_t *fmixer)
 	return result;
 }
 
-static int snd_mixer_oss_devmask(snd_mixer_oss_file_t *fmixer)
+static int snd_mixer_oss_devmask(struct snd_mixer_oss_file *fmixer)
 {
-	snd_mixer_oss_t *mixer = fmixer->mixer;
-	snd_mixer_oss_slot_t *pslot;
+	struct snd_mixer_oss *mixer = fmixer->mixer;
+	struct snd_mixer_oss_slot *pslot;
 	int result = 0, chn;
 
 	if (mixer == NULL)
@@ -141,10 +141,10 @@ static int snd_mixer_oss_devmask(snd_mixer_oss_file_t *fmixer)
 	return result;
 }
 
-static int snd_mixer_oss_stereodevs(snd_mixer_oss_file_t *fmixer)
+static int snd_mixer_oss_stereodevs(struct snd_mixer_oss_file *fmixer)
 {
-	snd_mixer_oss_t *mixer = fmixer->mixer;
-	snd_mixer_oss_slot_t *pslot;
+	struct snd_mixer_oss *mixer = fmixer->mixer;
+	struct snd_mixer_oss_slot *pslot;
 	int result = 0, chn;
 
 	if (mixer == NULL)
@@ -157,9 +157,9 @@ static int snd_mixer_oss_stereodevs(snd_mixer_oss_file_t *fmixer)
 	return result;
 }
 
-static int snd_mixer_oss_recmask(snd_mixer_oss_file_t *fmixer)
+static int snd_mixer_oss_recmask(struct snd_mixer_oss_file *fmixer)
 {
-	snd_mixer_oss_t *mixer = fmixer->mixer;
+	struct snd_mixer_oss *mixer = fmixer->mixer;
 	int result = 0;
 
 	if (mixer == NULL)
@@ -167,7 +167,7 @@ static int snd_mixer_oss_recmask(snd_mixer_oss_file_t *fmixer)
 	if (mixer->put_recsrc && mixer->get_recsrc) {	/* exclusive */
 		result = mixer->mask_recsrc;
 	} else {
-		snd_mixer_oss_slot_t *pslot;
+		struct snd_mixer_oss_slot *pslot;
 		int chn;
 		for (chn = 0; chn < 31; chn++) {
 			pslot = &mixer->slots[chn];
@@ -178,9 +178,9 @@ static int snd_mixer_oss_recmask(snd_mixer_oss_file_t *fmixer)
 	return result;
 }
 
-static int snd_mixer_oss_get_recsrc(snd_mixer_oss_file_t *fmixer)
+static int snd_mixer_oss_get_recsrc(struct snd_mixer_oss_file *fmixer)
 {
-	snd_mixer_oss_t *mixer = fmixer->mixer;
+	struct snd_mixer_oss *mixer = fmixer->mixer;
 	int result = 0;
 
 	if (mixer == NULL)
@@ -191,7 +191,7 @@ static int snd_mixer_oss_get_recsrc(snd_mixer_oss_file_t *fmixer)
 			return err;
 		result = 1 << result;
 	} else {
-		snd_mixer_oss_slot_t *pslot;
+		struct snd_mixer_oss_slot *pslot;
 		int chn;
 		for (chn = 0; chn < 31; chn++) {
 			pslot = &mixer->slots[chn];
@@ -206,10 +206,10 @@ static int snd_mixer_oss_get_recsrc(snd_mixer_oss_file_t *fmixer)
 	return mixer->oss_recsrc = result;
 }
 
-static int snd_mixer_oss_set_recsrc(snd_mixer_oss_file_t *fmixer, int recsrc)
+static int snd_mixer_oss_set_recsrc(struct snd_mixer_oss_file *fmixer, int recsrc)
 {
-	snd_mixer_oss_t *mixer = fmixer->mixer;
-	snd_mixer_oss_slot_t *pslot;
+	struct snd_mixer_oss *mixer = fmixer->mixer;
+	struct snd_mixer_oss_slot *pslot;
 	int chn, active;
 	int result = 0;
 
@@ -243,10 +243,10 @@ static int snd_mixer_oss_set_recsrc(snd_mixer_oss_file_t *fmixer, int recsrc)
 	return result;
 }
 
-static int snd_mixer_oss_get_volume(snd_mixer_oss_file_t *fmixer, int slot)
+static int snd_mixer_oss_get_volume(struct snd_mixer_oss_file *fmixer, int slot)
 {
-	snd_mixer_oss_t *mixer = fmixer->mixer;
-	snd_mixer_oss_slot_t *pslot;
+	struct snd_mixer_oss *mixer = fmixer->mixer;
+	struct snd_mixer_oss_slot *pslot;
 	int result = 0, left, right;
 
 	if (mixer == NULL || slot > 30)
@@ -268,11 +268,11 @@ static int snd_mixer_oss_get_volume(snd_mixer_oss_file_t *fmixer, int slot)
 	return result;
 }
 
-static int snd_mixer_oss_set_volume(snd_mixer_oss_file_t *fmixer,
+static int snd_mixer_oss_set_volume(struct snd_mixer_oss_file *fmixer,
 				    int slot, int volume)
 {
-	snd_mixer_oss_t *mixer = fmixer->mixer;
-	snd_mixer_oss_slot_t *pslot;
+	struct snd_mixer_oss *mixer = fmixer->mixer;
+	struct snd_mixer_oss_slot *pslot;
 	int result = 0, left = volume & 0xff, right = (volume >> 8) & 0xff;
 
 	if (mixer == NULL || slot > 30)
@@ -293,7 +293,7 @@ static int snd_mixer_oss_set_volume(snd_mixer_oss_file_t *fmixer,
  	return (left & 0xff) | ((right & 0xff) << 8);
 }
 
-static int snd_mixer_oss_ioctl1(snd_mixer_oss_file_t *fmixer, unsigned int cmd, unsigned long arg)
+static int snd_mixer_oss_ioctl1(struct snd_mixer_oss_file *fmixer, unsigned int cmd, unsigned long arg)
 {
 	void __user *argp = (void __user *)arg;
 	int __user *p = argp;
@@ -362,12 +362,12 @@ static int snd_mixer_oss_ioctl1(snd_mixer_oss_file_t *fmixer, unsigned int cmd,
 
 static long snd_mixer_oss_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	return snd_mixer_oss_ioctl1((snd_mixer_oss_file_t *) file->private_data, cmd, arg);
+	return snd_mixer_oss_ioctl1((struct snd_mixer_oss_file *) file->private_data, cmd, arg);
 }
 
-int snd_mixer_oss_ioctl_card(snd_card_t *card, unsigned int cmd, unsigned long arg)
+int snd_mixer_oss_ioctl_card(struct snd_card *card, unsigned int cmd, unsigned long arg)
 {
-	snd_mixer_oss_file_t fmixer;
+	struct snd_mixer_oss_file fmixer;
 	
 	snd_assert(card != NULL, return -ENXIO);
 	if (card->mixer_oss == NULL)
@@ -398,7 +398,7 @@ static struct file_operations snd_mixer_oss_f_ops =
 	.compat_ioctl =	snd_mixer_oss_ioctl_compat,
 };
 
-static snd_minor_t snd_mixer_oss_reg =
+static struct snd_minor snd_mixer_oss_reg =
 {
 	.comment =	"mixer",
 	.f_ops =	&snd_mixer_oss_f_ops,
@@ -432,16 +432,16 @@ static long snd_mixer_oss_conv2(long val, long min, long max)
 }
 
 #if 0
-static void snd_mixer_oss_recsrce_set(snd_card_t *card, int slot)
+static void snd_mixer_oss_recsrce_set(struct snd_card *card, int slot)
 {
-	snd_mixer_oss_t *mixer = card->mixer_oss;
+	struct snd_mixer_oss *mixer = card->mixer_oss;
 	if (mixer)
 		mixer->mask_recsrc |= 1 << slot;
 }
 
-static int snd_mixer_oss_recsrce_get(snd_card_t *card, int slot)
+static int snd_mixer_oss_recsrce_get(struct snd_card *card, int slot)
 {
-	snd_mixer_oss_t *mixer = card->mixer_oss;
+	struct snd_mixer_oss *mixer = card->mixer_oss;
 	if (mixer && (mixer->mask_recsrc & (1 << slot)))
 		return 1;
 	return 0;
@@ -488,10 +488,10 @@ struct slot {
 
 #define ID_UNKNOWN	((unsigned int)-1)
 
-static snd_kcontrol_t *snd_mixer_oss_test_id(snd_mixer_oss_t *mixer, const char *name, int index)
+static struct snd_kcontrol *snd_mixer_oss_test_id(struct snd_mixer_oss *mixer, const char *name, int index)
 {
-	snd_card_t * card = mixer->card;
-	snd_ctl_elem_id_t id;
+	struct snd_card *card = mixer->card;
+	struct snd_ctl_elem_id id;
 	
 	memset(&id, 0, sizeof(id));
 	id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
@@ -500,15 +500,15 @@ static snd_kcontrol_t *snd_mixer_oss_test_id(snd_mixer_oss_t *mixer, const char
 	return snd_ctl_find_id(card, &id);
 }
 
-static void snd_mixer_oss_get_volume1_vol(snd_mixer_oss_file_t *fmixer,
-					  snd_mixer_oss_slot_t *pslot,
+static void snd_mixer_oss_get_volume1_vol(struct snd_mixer_oss_file *fmixer,
+					  struct snd_mixer_oss_slot *pslot,
 					  unsigned int numid,
 					  int *left, int *right)
 {
-	snd_ctl_elem_info_t *uinfo;
-	snd_ctl_elem_value_t *uctl;
-	snd_kcontrol_t *kctl;
-	snd_card_t *card = fmixer->card;
+	struct snd_ctl_elem_info *uinfo;
+	struct snd_ctl_elem_value *uctl;
+	struct snd_kcontrol *kctl;
+	struct snd_card *card = fmixer->card;
 
 	if (numid == ID_UNKNOWN)
 		return;
@@ -537,16 +537,16 @@ static void snd_mixer_oss_get_volume1_vol(snd_mixer_oss_file_t *fmixer,
       	kfree(uinfo);
 }
 
-static void snd_mixer_oss_get_volume1_sw(snd_mixer_oss_file_t *fmixer,
-					 snd_mixer_oss_slot_t *pslot,
+static void snd_mixer_oss_get_volume1_sw(struct snd_mixer_oss_file *fmixer,
+					 struct snd_mixer_oss_slot *pslot,
 					 unsigned int numid,
 					 int *left, int *right,
 					 int route)
 {
-	snd_ctl_elem_info_t *uinfo;
-	snd_ctl_elem_value_t *uctl;
-	snd_kcontrol_t *kctl;
-	snd_card_t *card = fmixer->card;
+	struct snd_ctl_elem_info *uinfo;
+	struct snd_ctl_elem_value *uctl;
+	struct snd_kcontrol *kctl;
+	struct snd_card *card = fmixer->card;
 
 	if (numid == ID_UNKNOWN)
 		return;
@@ -576,8 +576,8 @@ static void snd_mixer_oss_get_volume1_sw(snd_mixer_oss_file_t *fmixer,
 	kfree(uinfo);
 }
 
-static int snd_mixer_oss_get_volume1(snd_mixer_oss_file_t *fmixer,
-				     snd_mixer_oss_slot_t *pslot,
+static int snd_mixer_oss_get_volume1(struct snd_mixer_oss_file *fmixer,
+				     struct snd_mixer_oss_slot *pslot,
 				     int *left, int *right)
 {
 	struct slot *slot = (struct slot *)pslot->private_data;
@@ -602,15 +602,15 @@ static int snd_mixer_oss_get_volume1(snd_mixer_oss_file_t *fmixer,
 	return 0;
 }
 
-static void snd_mixer_oss_put_volume1_vol(snd_mixer_oss_file_t *fmixer,
-					  snd_mixer_oss_slot_t *pslot,
+static void snd_mixer_oss_put_volume1_vol(struct snd_mixer_oss_file *fmixer,
+					  struct snd_mixer_oss_slot *pslot,
 					  unsigned int numid,
 					  int left, int right)
 {
-	snd_ctl_elem_info_t *uinfo;
-	snd_ctl_elem_value_t *uctl;
-	snd_kcontrol_t *kctl;
-	snd_card_t *card = fmixer->card;
+	struct snd_ctl_elem_info *uinfo;
+	struct snd_ctl_elem_value *uctl;
+	struct snd_kcontrol *kctl;
+	struct snd_card *card = fmixer->card;
 	int res;
 
 	if (numid == ID_UNKNOWN)
@@ -640,16 +640,16 @@ static void snd_mixer_oss_put_volume1_vol(snd_mixer_oss_file_t *fmixer,
 	kfree(uinfo);
 }
 
-static void snd_mixer_oss_put_volume1_sw(snd_mixer_oss_file_t *fmixer,
-					 snd_mixer_oss_slot_t *pslot,
+static void snd_mixer_oss_put_volume1_sw(struct snd_mixer_oss_file *fmixer,
+					 struct snd_mixer_oss_slot *pslot,
 					 unsigned int numid,
 					 int left, int right,
 					 int route)
 {
-	snd_ctl_elem_info_t *uinfo;
-	snd_ctl_elem_value_t *uctl;
-	snd_kcontrol_t *kctl;
-	snd_card_t *card = fmixer->card;
+	struct snd_ctl_elem_info *uinfo;
+	struct snd_ctl_elem_value *uctl;
+	struct snd_kcontrol *kctl;
+	struct snd_card *card = fmixer->card;
 	int res;
 
 	if (numid == ID_UNKNOWN)
@@ -685,8 +685,8 @@ static void snd_mixer_oss_put_volume1_sw(snd_mixer_oss_file_t *fmixer,
 	kfree(uinfo);
 }
 
-static int snd_mixer_oss_put_volume1(snd_mixer_oss_file_t *fmixer,
-				     snd_mixer_oss_slot_t *pslot,
+static int snd_mixer_oss_put_volume1(struct snd_mixer_oss_file *fmixer,
+				     struct snd_mixer_oss_slot *pslot,
 				     int left, int right)
 {
 	struct slot *slot = (struct slot *)pslot->private_data;
@@ -723,8 +723,8 @@ static int snd_mixer_oss_put_volume1(snd_mixer_oss_file_t *fmixer,
 	return 0;
 }
 
-static int snd_mixer_oss_get_recsrc1_sw(snd_mixer_oss_file_t *fmixer,
-					snd_mixer_oss_slot_t *pslot,
+static int snd_mixer_oss_get_recsrc1_sw(struct snd_mixer_oss_file *fmixer,
+					struct snd_mixer_oss_slot *pslot,
 					int *active)
 {
 	struct slot *slot = (struct slot *)pslot->private_data;
@@ -736,8 +736,8 @@ static int snd_mixer_oss_get_recsrc1_sw(snd_mixer_oss_file_t *fmixer,
 	return 0;
 }
 
-static int snd_mixer_oss_get_recsrc1_route(snd_mixer_oss_file_t *fmixer,
-					   snd_mixer_oss_slot_t *pslot,
+static int snd_mixer_oss_get_recsrc1_route(struct snd_mixer_oss_file *fmixer,
+					   struct snd_mixer_oss_slot *pslot,
 					   int *active)
 {
 	struct slot *slot = (struct slot *)pslot->private_data;
@@ -749,8 +749,8 @@ static int snd_mixer_oss_get_recsrc1_route(snd_mixer_oss_file_t *fmixer,
 	return 0;
 }
 
-static int snd_mixer_oss_put_recsrc1_sw(snd_mixer_oss_file_t *fmixer,
-					snd_mixer_oss_slot_t *pslot,
+static int snd_mixer_oss_put_recsrc1_sw(struct snd_mixer_oss_file *fmixer,
+					struct snd_mixer_oss_slot *pslot,
 					int active)
 {
 	struct slot *slot = (struct slot *)pslot->private_data;
@@ -759,8 +759,8 @@ static int snd_mixer_oss_put_recsrc1_sw(snd_mixer_oss_file_t *fmixer,
 	return 0;
 }
 
-static int snd_mixer_oss_put_recsrc1_route(snd_mixer_oss_file_t *fmixer,
-					   snd_mixer_oss_slot_t *pslot,
+static int snd_mixer_oss_put_recsrc1_route(struct snd_mixer_oss_file *fmixer,
+					   struct snd_mixer_oss_slot *pslot,
 					   int active)
 {
 	struct slot *slot = (struct slot *)pslot->private_data;
@@ -769,15 +769,15 @@ static int snd_mixer_oss_put_recsrc1_route(snd_mixer_oss_file_t *fmixer,
 	return 0;
 }
 
-static int snd_mixer_oss_get_recsrc2(snd_mixer_oss_file_t *fmixer, unsigned int *active_index)
+static int snd_mixer_oss_get_recsrc2(struct snd_mixer_oss_file *fmixer, unsigned int *active_index)
 {
-	snd_card_t *card = fmixer->card;
-	snd_mixer_oss_t *mixer = fmixer->mixer;
-	snd_kcontrol_t *kctl;
-	snd_mixer_oss_slot_t *pslot;
+	struct snd_card *card = fmixer->card;
+	struct snd_mixer_oss *mixer = fmixer->mixer;
+	struct snd_kcontrol *kctl;
+	struct snd_mixer_oss_slot *pslot;
 	struct slot *slot;
-	snd_ctl_elem_info_t *uinfo;
-	snd_ctl_elem_value_t *uctl;
+	struct snd_ctl_elem_info *uinfo;
+	struct snd_ctl_elem_value *uctl;
 	int err, idx;
 	
 	uinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);
@@ -818,15 +818,15 @@ static int snd_mixer_oss_get_recsrc2(snd_mixer_oss_file_t *fmixer, unsigned int
       	return err;
 }
 
-static int snd_mixer_oss_put_recsrc2(snd_mixer_oss_file_t *fmixer, unsigned int active_index)
+static int snd_mixer_oss_put_recsrc2(struct snd_mixer_oss_file *fmixer, unsigned int active_index)
 {
-	snd_card_t *card = fmixer->card;
-	snd_mixer_oss_t *mixer = fmixer->mixer;
-	snd_kcontrol_t *kctl;
-	snd_mixer_oss_slot_t *pslot;
+	struct snd_card *card = fmixer->card;
+	struct snd_mixer_oss *mixer = fmixer->mixer;
+	struct snd_kcontrol *kctl;
+	struct snd_mixer_oss_slot *pslot;
 	struct slot *slot = NULL;
-	snd_ctl_elem_info_t *uinfo;
-	snd_ctl_elem_value_t *uctl;
+	struct snd_ctl_elem_info *uinfo;
+	struct snd_ctl_elem_value *uctl;
 	int err;
 	unsigned int idx;
 
@@ -878,11 +878,11 @@ struct snd_mixer_oss_assign_table {
 	int index;
 };
 
-static int snd_mixer_oss_build_test(snd_mixer_oss_t *mixer, struct slot *slot, const char *name, int index, int item)
+static int snd_mixer_oss_build_test(struct snd_mixer_oss *mixer, struct slot *slot, const char *name, int index, int item)
 {
-	snd_ctl_elem_info_t *info;
-	snd_kcontrol_t *kcontrol;
-	snd_card_t *card = mixer->card;
+	struct snd_ctl_elem_info *info;
+	struct snd_kcontrol *kcontrol;
+	struct snd_card *card = mixer->card;
 	int err;
 
 	down_read(&card->controls_rwsem);
@@ -910,7 +910,7 @@ static int snd_mixer_oss_build_test(snd_mixer_oss_t *mixer, struct slot *slot, c
 	return 0;
 }
 
-static void snd_mixer_oss_slot_free(snd_mixer_oss_slot_t *chn)
+static void snd_mixer_oss_slot_free(struct snd_mixer_oss_slot *chn)
 {
 	struct slot *p = (struct slot *)chn->private_data;
 	if (p) {
@@ -922,7 +922,7 @@ static void snd_mixer_oss_slot_free(snd_mixer_oss_slot_t *chn)
 	}
 }
 
-static void mixer_slot_clear(snd_mixer_oss_slot_t *rslot)
+static void mixer_slot_clear(struct snd_mixer_oss_slot *rslot)
 {
 	int idx = rslot->number; /* remember this */
 	if (rslot->private_free)
@@ -936,12 +936,12 @@ static void mixer_slot_clear(snd_mixer_oss_slot_t *rslot)
  * ptr_allocated means the entry is dynamically allocated (change via proc file).
  * when replace_old = 1, the old entry is replaced with the new one.
  */
-static int snd_mixer_oss_build_input(snd_mixer_oss_t *mixer, struct snd_mixer_oss_assign_table *ptr, int ptr_allocated, int replace_old)
+static int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer, struct snd_mixer_oss_assign_table *ptr, int ptr_allocated, int replace_old)
 {
 	struct slot slot;
 	struct slot *pslot;
-	snd_kcontrol_t *kctl;
-	snd_mixer_oss_slot_t *rslot;
+	struct snd_kcontrol *kctl;
+	struct snd_mixer_oss_slot *rslot;
 	char str[64];	
 	
 	/* check if already assigned */
@@ -991,7 +991,7 @@ static int snd_mixer_oss_build_input(snd_mixer_oss_t *mixer, struct snd_mixer_os
 		return 0;
 	down_read(&mixer->card->controls_rwsem);
 	if (ptr->index == 0 && (kctl = snd_mixer_oss_test_id(mixer, "Capture Source", 0)) != NULL) {
-		snd_ctl_elem_info_t *uinfo;
+		struct snd_ctl_elem_info *uinfo;
 
 		uinfo = kmalloc(sizeof(*uinfo), GFP_KERNEL);
 		if (! uinfo) {
@@ -1093,10 +1093,10 @@ static char *oss_mixer_names[SNDRV_OSS_MAX_MIXERS] = {
  *  /proc interface
  */
 
-static void snd_mixer_oss_proc_read(snd_info_entry_t *entry,
-				    snd_info_buffer_t * buffer)
+static void snd_mixer_oss_proc_read(struct snd_info_entry *entry,
+				    struct snd_info_buffer *buffer)
 {
-	snd_mixer_oss_t *mixer = entry->private_data;
+	struct snd_mixer_oss *mixer = entry->private_data;
 	int i;
 
 	down(&mixer->reg_mutex);
@@ -1117,10 +1117,10 @@ static void snd_mixer_oss_proc_read(snd_info_entry_t *entry,
 	up(&mixer->reg_mutex);
 }
 
-static void snd_mixer_oss_proc_write(snd_info_entry_t *entry,
-				     snd_info_buffer_t * buffer)
+static void snd_mixer_oss_proc_write(struct snd_info_entry *entry,
+				     struct snd_info_buffer *buffer)
 {
-	snd_mixer_oss_t *mixer = entry->private_data;
+	struct snd_mixer_oss *mixer = entry->private_data;
 	char line[128], str[32], idxstr[16], *cptr;
 	int ch, idx;
 	struct snd_mixer_oss_assign_table *tbl;
@@ -1176,9 +1176,9 @@ static void snd_mixer_oss_proc_write(snd_info_entry_t *entry,
 	}
 }
 
-static void snd_mixer_oss_proc_init(snd_mixer_oss_t *mixer)
+static void snd_mixer_oss_proc_init(struct snd_mixer_oss *mixer)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	entry = snd_info_create_card_entry(mixer->card, "oss_mixer",
 					   mixer->card->proc_root);
@@ -1198,7 +1198,7 @@ static void snd_mixer_oss_proc_init(snd_mixer_oss_t *mixer)
 	mixer->proc_entry = entry;
 }
 
-static void snd_mixer_oss_proc_done(snd_mixer_oss_t *mixer)
+static void snd_mixer_oss_proc_done(struct snd_mixer_oss *mixer)
 {
 	if (mixer->proc_entry) {
 		snd_info_unregister(mixer->proc_entry);
@@ -1206,7 +1206,7 @@ static void snd_mixer_oss_proc_done(snd_mixer_oss_t *mixer)
 	}
 }
 
-static void snd_mixer_oss_build(snd_mixer_oss_t *mixer)
+static void snd_mixer_oss_build(struct snd_mixer_oss *mixer)
 {
 	static struct snd_mixer_oss_assign_table table[] = {
 		{ SOUND_MIXER_VOLUME, 	"Master",		0 },
@@ -1260,8 +1260,8 @@ static void snd_mixer_oss_build(snd_mixer_oss_t *mixer)
 
 static int snd_mixer_oss_free1(void *private)
 {
-	snd_mixer_oss_t *mixer = private;
-	snd_card_t * card;
+	struct snd_mixer_oss *mixer = private;
+	struct snd_card *card;
 	int idx;
  
 	snd_assert(mixer != NULL, return -ENXIO);
@@ -1269,7 +1269,7 @@ static int snd_mixer_oss_free1(void *private)
 	snd_assert(mixer == card->mixer_oss, return -ENXIO);
 	card->mixer_oss = NULL;
 	for (idx = 0; idx < SNDRV_OSS_MAX_MIXERS; idx++) {
-		snd_mixer_oss_slot_t *chn = &mixer->slots[idx];
+		struct snd_mixer_oss_slot *chn = &mixer->slots[idx];
 		if (chn->private_free)
 			chn->private_free(chn);
 	}
@@ -1277,9 +1277,9 @@ static int snd_mixer_oss_free1(void *private)
 	return 0;
 }
 
-static int snd_mixer_oss_notify_handler(snd_card_t * card, int cmd)
+static int snd_mixer_oss_notify_handler(struct snd_card *card, int cmd)
 {
-	snd_mixer_oss_t *mixer;
+	struct snd_mixer_oss *mixer;
 
 	if (cmd == SND_MIXER_OSS_NOTIFY_REGISTER) {
 		char name[128];

commit d3d579f84ebf701dedd22ba696d1738ed6759ef7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Oct 21 16:20:11 2005 +0200

    [ALSA] Add missing KERN_* prefix
    
    Modules: ALSA<-OSS emulation,USB generic driver,USB USX2Y
    
    Added missing KERN_* prefix to printk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index b2497cec2079..214933cf5d49 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -1294,7 +1294,8 @@ static int snd_mixer_oss_notify_handler(snd_card_t * card, int cmd)
 						   card, 0,
 						   &snd_mixer_oss_reg,
 						   name)) < 0) {
-			snd_printk("unable to register OSS mixer device %i:%i\n", card->number, 0);
+			snd_printk(KERN_ERR "unable to register OSS mixer device %i:%i\n",
+				   card->number, 0);
 			kfree(mixer);
 			return err;
 		}

commit 7c22f1aaa23370bf9ba2dd3abbccbed70dced216
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:46:31 2005 +0200

    [ALSA] Remove snd_runtime_check() macro
    
    Remove snd_runtime_check() macro.
    This macro worsens the readability of codes.  They should be either
    normal if() or removable asserts.
    
    Also, the assert displays stack-dump, instead of only the last caller
    pointer.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 69e1059112d1..b2497cec2079 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -521,9 +521,13 @@ static void snd_mixer_oss_get_volume1_vol(snd_mixer_oss_file_t *fmixer,
 	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (uinfo == NULL || uctl == NULL)
 		goto __unalloc;
-	snd_runtime_check(!kctl->info(kctl, uinfo), goto __unalloc);
-	snd_runtime_check(!kctl->get(kctl, uctl), goto __unalloc);
-	snd_runtime_check(uinfo->type != SNDRV_CTL_ELEM_TYPE_BOOLEAN || uinfo->value.integer.min != 0 || uinfo->value.integer.max != 1, goto __unalloc);
+	if (kctl->info(kctl, uinfo))
+		goto __unalloc;
+	if (kctl->get(kctl, uctl))
+		goto __unalloc;
+	if (uinfo->type == SNDRV_CTL_ELEM_TYPE_BOOLEAN &&
+	    uinfo->value.integer.min == 0 && uinfo->value.integer.max == 1)
+		goto __unalloc;
 	*left = snd_mixer_oss_conv1(uctl->value.integer.value[0], uinfo->value.integer.min, uinfo->value.integer.max, &pslot->volume[0]);
 	if (uinfo->count > 1)
 		*right = snd_mixer_oss_conv1(uctl->value.integer.value[1], uinfo->value.integer.min, uinfo->value.integer.max, &pslot->volume[1]);
@@ -555,8 +559,10 @@ static void snd_mixer_oss_get_volume1_sw(snd_mixer_oss_file_t *fmixer,
 	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (uinfo == NULL || uctl == NULL)
 		goto __unalloc;
-	snd_runtime_check(!kctl->info(kctl, uinfo), goto __unalloc);
-	snd_runtime_check(!kctl->get(kctl, uctl), goto __unalloc);
+	if (kctl->info(kctl, uinfo))
+		goto __unalloc;
+	if (kctl->get(kctl, uctl))
+		goto __unalloc;
 	if (!uctl->value.integer.value[0]) {
 		*left = 0;
 		if (uinfo->count == 1)
@@ -616,12 +622,16 @@ static void snd_mixer_oss_put_volume1_vol(snd_mixer_oss_file_t *fmixer,
 	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (uinfo == NULL || uctl == NULL)
 		goto __unalloc;
-	snd_runtime_check(!kctl->info(kctl, uinfo), goto __unalloc);
-	snd_runtime_check(uinfo->type != SNDRV_CTL_ELEM_TYPE_BOOLEAN || uinfo->value.integer.min != 0 || uinfo->value.integer.max != 1, goto __unalloc);
+	if (kctl->info(kctl, uinfo))
+		goto __unalloc;
+	if (uinfo->type == SNDRV_CTL_ELEM_TYPE_BOOLEAN &&
+	    uinfo->value.integer.min == 0 && uinfo->value.integer.max == 1)
+		goto __unalloc;
 	uctl->value.integer.value[0] = snd_mixer_oss_conv2(left, uinfo->value.integer.min, uinfo->value.integer.max);
 	if (uinfo->count > 1)
 		uctl->value.integer.value[1] = snd_mixer_oss_conv2(right, uinfo->value.integer.min, uinfo->value.integer.max);
-	snd_runtime_check((res = kctl->put(kctl, uctl)) >= 0, goto __unalloc);
+	if ((res = kctl->put(kctl, uctl)) < 0)
+		goto __unalloc;
 	if (res > 0)
 		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);
       __unalloc:
@@ -653,7 +663,8 @@ static void snd_mixer_oss_put_volume1_sw(snd_mixer_oss_file_t *fmixer,
 	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (uinfo == NULL || uctl == NULL)
 		goto __unalloc;
-	snd_runtime_check(!kctl->info(kctl, uinfo), goto __unalloc);
+	if (kctl->info(kctl, uinfo))
+		goto __unalloc;
 	if (uinfo->count > 1) {
 		uctl->value.integer.value[0] = left > 0 ? 1 : 0;
 		uctl->value.integer.value[route ? 3 : 1] = right > 0 ? 1 : 0;
@@ -664,7 +675,8 @@ static void snd_mixer_oss_put_volume1_sw(snd_mixer_oss_file_t *fmixer,
 	} else {
 		uctl->value.integer.value[0] = (left > 0 || right > 0) ? 1 : 0;
 	}
-	snd_runtime_check((res = kctl->put(kctl, uctl)) >= 0, goto __unalloc);
+	if ((res = kctl->put(kctl, uctl)) < 0)
+		goto __unalloc;
 	if (res > 0)
 		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);
       __unalloc:
@@ -776,9 +788,14 @@ static int snd_mixer_oss_get_recsrc2(snd_mixer_oss_file_t *fmixer, unsigned int
 	}
 	down_read(&card->controls_rwsem);
 	kctl = snd_mixer_oss_test_id(mixer, "Capture Source", 0);
-	snd_runtime_check(kctl != NULL, err = -ENOENT; goto __unlock);
-	snd_runtime_check(!(err = kctl->info(kctl, uinfo)), goto __unlock);
-	snd_runtime_check(!(err = kctl->get(kctl, uctl)), goto __unlock);
+	if (! kctl) {
+		err = -ENOENT;
+		goto __unlock;
+	}
+	if ((err = kctl->info(kctl, uinfo)) < 0)
+		goto __unlock;
+	if ((err = kctl->get(kctl, uctl)) < 0)
+		goto __unlock;
 	for (idx = 0; idx < 32; idx++) {
 		if (!(mixer->mask_recsrc & (1 << idx)))
 			continue;
@@ -821,8 +838,12 @@ static int snd_mixer_oss_put_recsrc2(snd_mixer_oss_file_t *fmixer, unsigned int
 	}
 	down_read(&card->controls_rwsem);
 	kctl = snd_mixer_oss_test_id(mixer, "Capture Source", 0);
-	snd_runtime_check(kctl != NULL, err = -ENOENT; goto __unlock);
-	snd_runtime_check(!(err = kctl->info(kctl, uinfo)), goto __unlock);
+	if (! kctl) {
+		err = -ENOENT;
+		goto __unlock;
+	}
+	if ((err = kctl->info(kctl, uinfo)) < 0)
+		goto __unlock;
 	for (idx = 0; idx < 32; idx++) {
 		if (!(mixer->mask_recsrc & (1 << idx)))
 			continue;
@@ -836,10 +857,11 @@ static int snd_mixer_oss_put_recsrc2(snd_mixer_oss_file_t *fmixer, unsigned int
 			break;
 		slot = NULL;
 	}
-	snd_runtime_check(slot != NULL, goto __unlock);
+	if (! slot)
+		goto __unlock;
 	for (idx = 0; idx < uinfo->count; idx++)
 		uctl->value.enumerated.item[idx] = slot->capture_item;
-	snd_runtime_check((err = kctl->put(kctl, uctl)) >= 0, );
+	err = kctl->put(kctl, uctl);
 	if (err > 0)
 		snd_ctl_notify(fmixer->card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);
 	err = 0;
@@ -1008,7 +1030,8 @@ static int snd_mixer_oss_build_input(snd_mixer_oss_t *mixer, struct snd_mixer_os
 	up_read(&mixer->card->controls_rwsem);
 	if (slot.present != 0) {
 		pslot = (struct slot *)kmalloc(sizeof(slot), GFP_KERNEL);
-		snd_runtime_check(pslot != NULL, return -ENOMEM);
+		if (! pslot)
+			return -ENOMEM;
 		*pslot = slot;
 		pslot->signature = SNDRV_MIXER_OSS_SIGNATURE;
 		pslot->assigned = ptr;

commit ca2c0966562cfbf9273167a5b60e8fddc24078d6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:20:23 2005 +0200

    [ALSA] Replace with kzalloc() - core stuff
    
    Control Midlevel,ALSA Core,HWDEP Midlevel,PCM Midlevel,RawMidi Midlevel
    Timer Midlevel,ALSA<-OSS emulation
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 98fc0766f885..69e1059112d1 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -53,7 +53,7 @@ static int snd_mixer_oss_open(struct inode *inode, struct file *file)
 	err = snd_card_file_add(card, file);
 	if (err < 0)
 		return err;
-	fmixer = kcalloc(1, sizeof(*fmixer), GFP_KERNEL);
+	fmixer = kzalloc(sizeof(*fmixer), GFP_KERNEL);
 	if (fmixer == NULL) {
 		snd_card_file_remove(card, file);
 		return -ENOMEM;
@@ -517,8 +517,8 @@ static void snd_mixer_oss_get_volume1_vol(snd_mixer_oss_file_t *fmixer,
 		up_read(&card->controls_rwsem);
 		return;
 	}
-	uinfo = kcalloc(1, sizeof(*uinfo), GFP_KERNEL);
-	uctl = kcalloc(1, sizeof(*uctl), GFP_KERNEL);
+	uinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);
+	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (uinfo == NULL || uctl == NULL)
 		goto __unalloc;
 	snd_runtime_check(!kctl->info(kctl, uinfo), goto __unalloc);
@@ -551,8 +551,8 @@ static void snd_mixer_oss_get_volume1_sw(snd_mixer_oss_file_t *fmixer,
 		up_read(&card->controls_rwsem);
 		return;
 	}
-	uinfo = kcalloc(1, sizeof(*uinfo), GFP_KERNEL);
-	uctl = kcalloc(1, sizeof(*uctl), GFP_KERNEL);
+	uinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);
+	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (uinfo == NULL || uctl == NULL)
 		goto __unalloc;
 	snd_runtime_check(!kctl->info(kctl, uinfo), goto __unalloc);
@@ -612,8 +612,8 @@ static void snd_mixer_oss_put_volume1_vol(snd_mixer_oss_file_t *fmixer,
 	down_read(&card->controls_rwsem);
 	if ((kctl = snd_ctl_find_numid(card, numid)) == NULL)
 		return;
-	uinfo = kcalloc(1, sizeof(*uinfo), GFP_KERNEL);
-	uctl = kcalloc(1, sizeof(*uctl), GFP_KERNEL);
+	uinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);
+	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (uinfo == NULL || uctl == NULL)
 		goto __unalloc;
 	snd_runtime_check(!kctl->info(kctl, uinfo), goto __unalloc);
@@ -649,8 +649,8 @@ static void snd_mixer_oss_put_volume1_sw(snd_mixer_oss_file_t *fmixer,
 		up_read(&fmixer->card->controls_rwsem);
 		return;
 	}
-	uinfo = kcalloc(1, sizeof(*uinfo), GFP_KERNEL);
-	uctl = kcalloc(1, sizeof(*uctl), GFP_KERNEL);
+	uinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);
+	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (uinfo == NULL || uctl == NULL)
 		goto __unalloc;
 	snd_runtime_check(!kctl->info(kctl, uinfo), goto __unalloc);
@@ -768,8 +768,8 @@ static int snd_mixer_oss_get_recsrc2(snd_mixer_oss_file_t *fmixer, unsigned int
 	snd_ctl_elem_value_t *uctl;
 	int err, idx;
 	
-	uinfo = kcalloc(1, sizeof(*uinfo), GFP_KERNEL);
-	uctl = kcalloc(1, sizeof(*uctl), GFP_KERNEL);
+	uinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);
+	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (uinfo == NULL || uctl == NULL) {
 		err = -ENOMEM;
 		goto __unlock;
@@ -813,8 +813,8 @@ static int snd_mixer_oss_put_recsrc2(snd_mixer_oss_file_t *fmixer, unsigned int
 	int err;
 	unsigned int idx;
 
-	uinfo = kcalloc(1, sizeof(*uinfo), GFP_KERNEL);
-	uctl = kcalloc(1, sizeof(*uctl), GFP_KERNEL);
+	uinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);
+	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (uinfo == NULL || uctl == NULL) {
 		err = -ENOMEM;
 		goto __unlock;

commit 543537bd922692bc978e2e356fcd8bfc9c2ee7d5
Author: Paulo Marques <pmarques@grupopie.com>
Date:   Thu Jun 23 00:09:02 2005 -0700

    [PATCH] create a kstrdup library function
    
    This patch creates a new kstrdup library function and changes the "local"
    implementations in several places to use this function.
    
    Most of the changes come from the sound and net subsystems.  The sound part
    had already been acknowledged by Takashi Iwai and the net part by David S.
    Miller.
    
    I left UML alone for now because I would need more time to read the code
    carefully before making changes there.
    
    Signed-off-by: Paulo Marques <pmarques@grupopie.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
index 98ed9a9f0da6..98fc0766f885 100644
--- a/sound/core/oss/mixer_oss.c
+++ b/sound/core/oss/mixer_oss.c
@@ -24,6 +24,7 @@
 #include <linux/smp_lock.h>
 #include <linux/slab.h>
 #include <linux/time.h>
+#include <linux/string.h>
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/control.h>
@@ -1137,7 +1138,7 @@ static void snd_mixer_oss_proc_write(snd_info_entry_t *entry,
 			goto __unlock;
 		}
 		tbl->oss_id = ch;
-		tbl->name = snd_kmalloc_strdup(str, GFP_KERNEL);
+		tbl->name = kstrdup(str, GFP_KERNEL);
 		if (! tbl->name) {
 			kfree(tbl);
 			goto __unlock;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/oss/mixer_oss.c b/sound/core/oss/mixer_oss.c
new file mode 100644
index 000000000000..98ed9a9f0da6
--- /dev/null
+++ b/sound/core/oss/mixer_oss.c
@@ -0,0 +1,1340 @@
+/*
+ *  OSS emulation layer for the mixer interface
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/smp_lock.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <sound/core.h>
+#include <sound/minors.h>
+#include <sound/control.h>
+#include <sound/info.h>
+#include <sound/mixer_oss.h>
+#include <linux/soundcard.h>
+
+#define OSS_ALSAEMULVER         _SIOR ('M', 249, int)
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_DESCRIPTION("Mixer OSS emulation for ALSA.");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_SNDRV_MINOR(SNDRV_MINOR_OSS_MIXER);
+
+static int snd_mixer_oss_open(struct inode *inode, struct file *file)
+{
+	int cardnum = SNDRV_MINOR_OSS_CARD(iminor(inode));
+	snd_card_t *card;
+	snd_mixer_oss_file_t *fmixer;
+	int err;
+
+	if ((card = snd_cards[cardnum]) == NULL)
+		return -ENODEV;
+	if (card->mixer_oss == NULL)
+		return -ENODEV;
+	err = snd_card_file_add(card, file);
+	if (err < 0)
+		return err;
+	fmixer = kcalloc(1, sizeof(*fmixer), GFP_KERNEL);
+	if (fmixer == NULL) {
+		snd_card_file_remove(card, file);
+		return -ENOMEM;
+	}
+	fmixer->card = card;
+	fmixer->mixer = card->mixer_oss;
+	file->private_data = fmixer;
+	if (!try_module_get(card->module)) {
+		kfree(fmixer);
+		snd_card_file_remove(card, file);
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static int snd_mixer_oss_release(struct inode *inode, struct file *file)
+{
+	snd_mixer_oss_file_t *fmixer;
+
+	if (file->private_data) {
+		fmixer = (snd_mixer_oss_file_t *) file->private_data;
+		module_put(fmixer->card->module);
+		snd_card_file_remove(fmixer->card, file);
+		kfree(fmixer);
+	}
+	return 0;
+}
+
+static int snd_mixer_oss_info(snd_mixer_oss_file_t *fmixer,
+			      mixer_info __user *_info)
+{
+	snd_card_t *card = fmixer->card;
+	snd_mixer_oss_t *mixer = fmixer->mixer;
+	struct mixer_info info;
+	
+	memset(&info, 0, sizeof(info));
+	strlcpy(info.id, mixer && mixer->id[0] ? mixer->id : card->driver, sizeof(info.id));
+	strlcpy(info.name, mixer && mixer->name[0] ? mixer->name : card->mixername, sizeof(info.name));
+	info.modify_counter = card->mixer_oss_change_count;
+	if (copy_to_user(_info, &info, sizeof(info)))
+		return -EFAULT;
+	return 0;
+}
+
+static int snd_mixer_oss_info_obsolete(snd_mixer_oss_file_t *fmixer,
+				       _old_mixer_info __user *_info)
+{
+	snd_card_t *card = fmixer->card;
+	snd_mixer_oss_t *mixer = fmixer->mixer;
+	_old_mixer_info info;
+	
+	memset(&info, 0, sizeof(info));
+	strlcpy(info.id, mixer && mixer->id[0] ? mixer->id : card->driver, sizeof(info.id));
+	strlcpy(info.name, mixer && mixer->name[0] ? mixer->name : card->mixername, sizeof(info.name));
+	if (copy_to_user(_info, &info, sizeof(info)))
+		return -EFAULT;
+	return 0;
+}
+
+static int snd_mixer_oss_caps(snd_mixer_oss_file_t *fmixer)
+{
+	snd_mixer_oss_t *mixer = fmixer->mixer;
+	int result = 0;
+
+	if (mixer == NULL)
+		return -EIO;
+	if (mixer->get_recsrc && mixer->put_recsrc)
+		result |= SOUND_CAP_EXCL_INPUT;
+	return result;
+}
+
+static int snd_mixer_oss_devmask(snd_mixer_oss_file_t *fmixer)
+{
+	snd_mixer_oss_t *mixer = fmixer->mixer;
+	snd_mixer_oss_slot_t *pslot;
+	int result = 0, chn;
+
+	if (mixer == NULL)
+		return -EIO;
+	for (chn = 0; chn < 31; chn++) {
+		pslot = &mixer->slots[chn];
+		if (pslot->put_volume || pslot->put_recsrc)
+			result |= 1 << chn;
+	}
+	return result;
+}
+
+static int snd_mixer_oss_stereodevs(snd_mixer_oss_file_t *fmixer)
+{
+	snd_mixer_oss_t *mixer = fmixer->mixer;
+	snd_mixer_oss_slot_t *pslot;
+	int result = 0, chn;
+
+	if (mixer == NULL)
+		return -EIO;
+	for (chn = 0; chn < 31; chn++) {
+		pslot = &mixer->slots[chn];
+		if (pslot->put_volume && pslot->stereo)
+			result |= 1 << chn;
+	}
+	return result;
+}
+
+static int snd_mixer_oss_recmask(snd_mixer_oss_file_t *fmixer)
+{
+	snd_mixer_oss_t *mixer = fmixer->mixer;
+	int result = 0;
+
+	if (mixer == NULL)
+		return -EIO;
+	if (mixer->put_recsrc && mixer->get_recsrc) {	/* exclusive */
+		result = mixer->mask_recsrc;
+	} else {
+		snd_mixer_oss_slot_t *pslot;
+		int chn;
+		for (chn = 0; chn < 31; chn++) {
+			pslot = &mixer->slots[chn];
+			if (pslot->put_recsrc)
+				result |= 1 << chn;
+		}
+	}
+	return result;
+}
+
+static int snd_mixer_oss_get_recsrc(snd_mixer_oss_file_t *fmixer)
+{
+	snd_mixer_oss_t *mixer = fmixer->mixer;
+	int result = 0;
+
+	if (mixer == NULL)
+		return -EIO;
+	if (mixer->put_recsrc && mixer->get_recsrc) {	/* exclusive */
+		int err;
+		if ((err = mixer->get_recsrc(fmixer, &result)) < 0)
+			return err;
+		result = 1 << result;
+	} else {
+		snd_mixer_oss_slot_t *pslot;
+		int chn;
+		for (chn = 0; chn < 31; chn++) {
+			pslot = &mixer->slots[chn];
+			if (pslot->get_recsrc) {
+				int active = 0;
+				pslot->get_recsrc(fmixer, pslot, &active);
+				if (active)
+					result |= 1 << chn;
+			}
+		}
+	}
+	return mixer->oss_recsrc = result;
+}
+
+static int snd_mixer_oss_set_recsrc(snd_mixer_oss_file_t *fmixer, int recsrc)
+{
+	snd_mixer_oss_t *mixer = fmixer->mixer;
+	snd_mixer_oss_slot_t *pslot;
+	int chn, active;
+	int result = 0;
+
+	if (mixer == NULL)
+		return -EIO;
+	if (mixer->get_recsrc && mixer->put_recsrc) {	/* exclusive input */
+		if (recsrc & ~mixer->oss_recsrc)
+			recsrc &= ~mixer->oss_recsrc;
+		mixer->put_recsrc(fmixer, ffz(~recsrc));
+		mixer->get_recsrc(fmixer, &result);
+		result = 1 << result;
+	}
+	for (chn = 0; chn < 31; chn++) {
+		pslot = &mixer->slots[chn];
+		if (pslot->put_recsrc) {
+			active = (recsrc & (1 << chn)) ? 1 : 0;
+			pslot->put_recsrc(fmixer, pslot, active);
+		}
+	}
+	if (! result) {
+		for (chn = 0; chn < 31; chn++) {
+			pslot = &mixer->slots[chn];
+			if (pslot->get_recsrc) {
+				active = 0;
+				pslot->get_recsrc(fmixer, pslot, &active);
+				if (active)
+					result |= 1 << chn;
+			}
+		}
+	}
+	return result;
+}
+
+static int snd_mixer_oss_get_volume(snd_mixer_oss_file_t *fmixer, int slot)
+{
+	snd_mixer_oss_t *mixer = fmixer->mixer;
+	snd_mixer_oss_slot_t *pslot;
+	int result = 0, left, right;
+
+	if (mixer == NULL || slot > 30)
+		return -EIO;
+	pslot = &mixer->slots[slot];
+	left = pslot->volume[0];
+	right = pslot->volume[1];
+	if (pslot->get_volume)
+		result = pslot->get_volume(fmixer, pslot, &left, &right);
+	if (!pslot->stereo)
+		right = left;
+	snd_assert(left >= 0 && left <= 100, return -EIO);
+	snd_assert(right >= 0 && right <= 100, return -EIO);
+	if (result >= 0) {
+		pslot->volume[0] = left;
+		pslot->volume[1] = right;
+	 	result = (left & 0xff) | ((right & 0xff) << 8);
+	}
+	return result;
+}
+
+static int snd_mixer_oss_set_volume(snd_mixer_oss_file_t *fmixer,
+				    int slot, int volume)
+{
+	snd_mixer_oss_t *mixer = fmixer->mixer;
+	snd_mixer_oss_slot_t *pslot;
+	int result = 0, left = volume & 0xff, right = (volume >> 8) & 0xff;
+
+	if (mixer == NULL || slot > 30)
+		return -EIO;
+	pslot = &mixer->slots[slot];
+	if (left > 100)
+		left = 100;
+	if (right > 100)
+		right = 100;
+	if (!pslot->stereo)
+		right = left;
+	if (pslot->put_volume)
+		result = pslot->put_volume(fmixer, pslot, left, right);
+	if (result < 0)
+		return result;
+	pslot->volume[0] = left;
+	pslot->volume[1] = right;
+ 	return (left & 0xff) | ((right & 0xff) << 8);
+}
+
+static int snd_mixer_oss_ioctl1(snd_mixer_oss_file_t *fmixer, unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+	int tmp;
+
+	snd_assert(fmixer != NULL, return -ENXIO);
+	if (((cmd >> 8) & 0xff) == 'M') {
+		switch (cmd) {
+		case SOUND_MIXER_INFO:
+			return snd_mixer_oss_info(fmixer, argp);
+		case SOUND_OLD_MIXER_INFO:
+ 			return snd_mixer_oss_info_obsolete(fmixer, argp);
+		case SOUND_MIXER_WRITE_RECSRC:
+			if (get_user(tmp, p))
+				return -EFAULT;
+			tmp = snd_mixer_oss_set_recsrc(fmixer, tmp);
+			if (tmp < 0)
+				return tmp;
+			return put_user(tmp, p);
+		case OSS_GETVERSION:
+			return put_user(SNDRV_OSS_VERSION, p);
+		case OSS_ALSAEMULVER:
+			return put_user(1, p);
+		case SOUND_MIXER_READ_DEVMASK:
+			tmp = snd_mixer_oss_devmask(fmixer);
+			if (tmp < 0)
+				return tmp;
+			return put_user(tmp, p);
+		case SOUND_MIXER_READ_STEREODEVS:
+			tmp = snd_mixer_oss_stereodevs(fmixer);
+			if (tmp < 0)
+				return tmp;
+			return put_user(tmp, p);
+		case SOUND_MIXER_READ_RECMASK:
+			tmp = snd_mixer_oss_recmask(fmixer);
+			if (tmp < 0)
+				return tmp;
+			return put_user(tmp, p);
+		case SOUND_MIXER_READ_CAPS:
+			tmp = snd_mixer_oss_caps(fmixer);
+			if (tmp < 0)
+				return tmp;
+			return put_user(tmp, p);
+		case SOUND_MIXER_READ_RECSRC:
+			tmp = snd_mixer_oss_get_recsrc(fmixer);
+			if (tmp < 0)
+				return tmp;
+			return put_user(tmp, p);
+		}
+	}
+	if (cmd & SIOC_IN) {
+		if (get_user(tmp, p))
+			return -EFAULT;
+		tmp = snd_mixer_oss_set_volume(fmixer, cmd & 0xff, tmp);
+		if (tmp < 0)
+			return tmp;
+		return put_user(tmp, p);
+	} else if (cmd & SIOC_OUT) {
+		tmp = snd_mixer_oss_get_volume(fmixer, cmd & 0xff);
+		if (tmp < 0)
+			return tmp;
+		return put_user(tmp, p);
+	}
+	return -ENXIO;
+}
+
+static long snd_mixer_oss_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	return snd_mixer_oss_ioctl1((snd_mixer_oss_file_t *) file->private_data, cmd, arg);
+}
+
+int snd_mixer_oss_ioctl_card(snd_card_t *card, unsigned int cmd, unsigned long arg)
+{
+	snd_mixer_oss_file_t fmixer;
+	
+	snd_assert(card != NULL, return -ENXIO);
+	if (card->mixer_oss == NULL)
+		return -ENXIO;
+	memset(&fmixer, 0, sizeof(fmixer));
+	fmixer.card = card;
+	fmixer.mixer = card->mixer_oss;
+	return snd_mixer_oss_ioctl1(&fmixer, cmd, arg);
+}
+
+#ifdef CONFIG_COMPAT
+/* all compatible */
+#define snd_mixer_oss_ioctl_compat	snd_mixer_oss_ioctl
+#else
+#define snd_mixer_oss_ioctl_compat	NULL
+#endif
+
+/*
+ *  REGISTRATION PART
+ */
+
+static struct file_operations snd_mixer_oss_f_ops =
+{
+	.owner =	THIS_MODULE,
+	.open =		snd_mixer_oss_open,
+	.release =	snd_mixer_oss_release,
+	.unlocked_ioctl =	snd_mixer_oss_ioctl,
+	.compat_ioctl =	snd_mixer_oss_ioctl_compat,
+};
+
+static snd_minor_t snd_mixer_oss_reg =
+{
+	.comment =	"mixer",
+	.f_ops =	&snd_mixer_oss_f_ops,
+};
+
+/*
+ *  utilities
+ */
+
+static long snd_mixer_oss_conv(long val, long omin, long omax, long nmin, long nmax)
+{
+	long orange = omax - omin, nrange = nmax - nmin;
+	
+	if (orange == 0)
+		return 0;
+	return ((nrange * (val - omin)) + (orange / 2)) / orange + nmin;
+}
+
+/* convert from alsa native to oss values (0-100) */
+static long snd_mixer_oss_conv1(long val, long min, long max, int *old)
+{
+	if (val == snd_mixer_oss_conv(*old, 0, 100, min, max))
+		return *old;
+	return snd_mixer_oss_conv(val, min, max, 0, 100);
+}
+
+/* convert from oss to alsa native values */
+static long snd_mixer_oss_conv2(long val, long min, long max)
+{
+	return snd_mixer_oss_conv(val, 0, 100, min, max);
+}
+
+#if 0
+static void snd_mixer_oss_recsrce_set(snd_card_t *card, int slot)
+{
+	snd_mixer_oss_t *mixer = card->mixer_oss;
+	if (mixer)
+		mixer->mask_recsrc |= 1 << slot;
+}
+
+static int snd_mixer_oss_recsrce_get(snd_card_t *card, int slot)
+{
+	snd_mixer_oss_t *mixer = card->mixer_oss;
+	if (mixer && (mixer->mask_recsrc & (1 << slot)))
+		return 1;
+	return 0;
+}
+#endif
+
+#define SNDRV_MIXER_OSS_SIGNATURE		0x65999250
+
+#define SNDRV_MIXER_OSS_ITEM_GLOBAL	0
+#define SNDRV_MIXER_OSS_ITEM_GSWITCH	1
+#define SNDRV_MIXER_OSS_ITEM_GROUTE	2
+#define SNDRV_MIXER_OSS_ITEM_GVOLUME	3
+#define SNDRV_MIXER_OSS_ITEM_PSWITCH	4
+#define SNDRV_MIXER_OSS_ITEM_PROUTE	5
+#define SNDRV_MIXER_OSS_ITEM_PVOLUME	6
+#define SNDRV_MIXER_OSS_ITEM_CSWITCH	7
+#define SNDRV_MIXER_OSS_ITEM_CROUTE	8
+#define SNDRV_MIXER_OSS_ITEM_CVOLUME	9
+#define SNDRV_MIXER_OSS_ITEM_CAPTURE	10
+
+#define SNDRV_MIXER_OSS_ITEM_COUNT	11
+
+#define SNDRV_MIXER_OSS_PRESENT_GLOBAL	(1<<0)
+#define SNDRV_MIXER_OSS_PRESENT_GSWITCH	(1<<1)
+#define SNDRV_MIXER_OSS_PRESENT_GROUTE	(1<<2)
+#define SNDRV_MIXER_OSS_PRESENT_GVOLUME	(1<<3)
+#define SNDRV_MIXER_OSS_PRESENT_PSWITCH	(1<<4)
+#define SNDRV_MIXER_OSS_PRESENT_PROUTE	(1<<5)
+#define SNDRV_MIXER_OSS_PRESENT_PVOLUME	(1<<6)
+#define SNDRV_MIXER_OSS_PRESENT_CSWITCH	(1<<7)
+#define SNDRV_MIXER_OSS_PRESENT_CROUTE	(1<<8)
+#define SNDRV_MIXER_OSS_PRESENT_CVOLUME	(1<<9)
+#define SNDRV_MIXER_OSS_PRESENT_CAPTURE	(1<<10)
+
+struct slot {
+	unsigned int signature;
+	unsigned int present;
+	unsigned int channels;
+	unsigned int numid[SNDRV_MIXER_OSS_ITEM_COUNT];
+	unsigned int capture_item;
+	struct snd_mixer_oss_assign_table *assigned;
+	unsigned int allocated: 1;
+};
+
+#define ID_UNKNOWN	((unsigned int)-1)
+
+static snd_kcontrol_t *snd_mixer_oss_test_id(snd_mixer_oss_t *mixer, const char *name, int index)
+{
+	snd_card_t * card = mixer->card;
+	snd_ctl_elem_id_t id;
+	
+	memset(&id, 0, sizeof(id));
+	id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	strcpy(id.name, name);
+	id.index = index;
+	return snd_ctl_find_id(card, &id);
+}
+
+static void snd_mixer_oss_get_volume1_vol(snd_mixer_oss_file_t *fmixer,
+					  snd_mixer_oss_slot_t *pslot,
+					  unsigned int numid,
+					  int *left, int *right)
+{
+	snd_ctl_elem_info_t *uinfo;
+	snd_ctl_elem_value_t *uctl;
+	snd_kcontrol_t *kctl;
+	snd_card_t *card = fmixer->card;
+
+	if (numid == ID_UNKNOWN)
+		return;
+	down_read(&card->controls_rwsem);
+	if ((kctl = snd_ctl_find_numid(card, numid)) == NULL) {
+		up_read(&card->controls_rwsem);
+		return;
+	}
+	uinfo = kcalloc(1, sizeof(*uinfo), GFP_KERNEL);
+	uctl = kcalloc(1, sizeof(*uctl), GFP_KERNEL);
+	if (uinfo == NULL || uctl == NULL)
+		goto __unalloc;
+	snd_runtime_check(!kctl->info(kctl, uinfo), goto __unalloc);
+	snd_runtime_check(!kctl->get(kctl, uctl), goto __unalloc);
+	snd_runtime_check(uinfo->type != SNDRV_CTL_ELEM_TYPE_BOOLEAN || uinfo->value.integer.min != 0 || uinfo->value.integer.max != 1, goto __unalloc);
+	*left = snd_mixer_oss_conv1(uctl->value.integer.value[0], uinfo->value.integer.min, uinfo->value.integer.max, &pslot->volume[0]);
+	if (uinfo->count > 1)
+		*right = snd_mixer_oss_conv1(uctl->value.integer.value[1], uinfo->value.integer.min, uinfo->value.integer.max, &pslot->volume[1]);
+      __unalloc:
+	up_read(&card->controls_rwsem);
+      	kfree(uctl);
+      	kfree(uinfo);
+}
+
+static void snd_mixer_oss_get_volume1_sw(snd_mixer_oss_file_t *fmixer,
+					 snd_mixer_oss_slot_t *pslot,
+					 unsigned int numid,
+					 int *left, int *right,
+					 int route)
+{
+	snd_ctl_elem_info_t *uinfo;
+	snd_ctl_elem_value_t *uctl;
+	snd_kcontrol_t *kctl;
+	snd_card_t *card = fmixer->card;
+
+	if (numid == ID_UNKNOWN)
+		return;
+	down_read(&card->controls_rwsem);
+	if ((kctl = snd_ctl_find_numid(card, numid)) == NULL) {
+		up_read(&card->controls_rwsem);
+		return;
+	}
+	uinfo = kcalloc(1, sizeof(*uinfo), GFP_KERNEL);
+	uctl = kcalloc(1, sizeof(*uctl), GFP_KERNEL);
+	if (uinfo == NULL || uctl == NULL)
+		goto __unalloc;
+	snd_runtime_check(!kctl->info(kctl, uinfo), goto __unalloc);
+	snd_runtime_check(!kctl->get(kctl, uctl), goto __unalloc);
+	if (!uctl->value.integer.value[0]) {
+		*left = 0;
+		if (uinfo->count == 1)
+			*right = 0;
+	}
+	if (uinfo->count > 1 && !uctl->value.integer.value[route ? 3 : 1])
+		*right = 0;
+      __unalloc:
+	up_read(&card->controls_rwsem);
+      	kfree(uctl);
+	kfree(uinfo);
+}
+
+static int snd_mixer_oss_get_volume1(snd_mixer_oss_file_t *fmixer,
+				     snd_mixer_oss_slot_t *pslot,
+				     int *left, int *right)
+{
+	struct slot *slot = (struct slot *)pslot->private_data;
+	
+	*left = *right = 100;
+	if (slot->present & SNDRV_MIXER_OSS_PRESENT_PVOLUME) {
+		snd_mixer_oss_get_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PVOLUME], left, right);
+	} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GVOLUME) {
+		snd_mixer_oss_get_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GVOLUME], left, right);
+	} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GLOBAL) {
+		snd_mixer_oss_get_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GLOBAL], left, right);
+	}
+	if (slot->present & SNDRV_MIXER_OSS_PRESENT_PSWITCH) {
+		snd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PSWITCH], left, right, 0);
+	} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GSWITCH) {
+		snd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GSWITCH], left, right, 0);
+	} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_PROUTE) {
+		snd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PROUTE], left, right, 1);
+	} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GROUTE) {
+		snd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GROUTE], left, right, 1);
+	}
+	return 0;
+}
+
+static void snd_mixer_oss_put_volume1_vol(snd_mixer_oss_file_t *fmixer,
+					  snd_mixer_oss_slot_t *pslot,
+					  unsigned int numid,
+					  int left, int right)
+{
+	snd_ctl_elem_info_t *uinfo;
+	snd_ctl_elem_value_t *uctl;
+	snd_kcontrol_t *kctl;
+	snd_card_t *card = fmixer->card;
+	int res;
+
+	if (numid == ID_UNKNOWN)
+		return;
+	down_read(&card->controls_rwsem);
+	if ((kctl = snd_ctl_find_numid(card, numid)) == NULL)
+		return;
+	uinfo = kcalloc(1, sizeof(*uinfo), GFP_KERNEL);
+	uctl = kcalloc(1, sizeof(*uctl), GFP_KERNEL);
+	if (uinfo == NULL || uctl == NULL)
+		goto __unalloc;
+	snd_runtime_check(!kctl->info(kctl, uinfo), goto __unalloc);
+	snd_runtime_check(uinfo->type != SNDRV_CTL_ELEM_TYPE_BOOLEAN || uinfo->value.integer.min != 0 || uinfo->value.integer.max != 1, goto __unalloc);
+	uctl->value.integer.value[0] = snd_mixer_oss_conv2(left, uinfo->value.integer.min, uinfo->value.integer.max);
+	if (uinfo->count > 1)
+		uctl->value.integer.value[1] = snd_mixer_oss_conv2(right, uinfo->value.integer.min, uinfo->value.integer.max);
+	snd_runtime_check((res = kctl->put(kctl, uctl)) >= 0, goto __unalloc);
+	if (res > 0)
+		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);
+      __unalloc:
+	up_read(&card->controls_rwsem);
+      	kfree(uctl);
+	kfree(uinfo);
+}
+
+static void snd_mixer_oss_put_volume1_sw(snd_mixer_oss_file_t *fmixer,
+					 snd_mixer_oss_slot_t *pslot,
+					 unsigned int numid,
+					 int left, int right,
+					 int route)
+{
+	snd_ctl_elem_info_t *uinfo;
+	snd_ctl_elem_value_t *uctl;
+	snd_kcontrol_t *kctl;
+	snd_card_t *card = fmixer->card;
+	int res;
+
+	if (numid == ID_UNKNOWN)
+		return;
+	down_read(&card->controls_rwsem);
+	if ((kctl = snd_ctl_find_numid(card, numid)) == NULL) {
+		up_read(&fmixer->card->controls_rwsem);
+		return;
+	}
+	uinfo = kcalloc(1, sizeof(*uinfo), GFP_KERNEL);
+	uctl = kcalloc(1, sizeof(*uctl), GFP_KERNEL);
+	if (uinfo == NULL || uctl == NULL)
+		goto __unalloc;
+	snd_runtime_check(!kctl->info(kctl, uinfo), goto __unalloc);
+	if (uinfo->count > 1) {
+		uctl->value.integer.value[0] = left > 0 ? 1 : 0;
+		uctl->value.integer.value[route ? 3 : 1] = right > 0 ? 1 : 0;
+		if (route) {
+			uctl->value.integer.value[1] =
+			uctl->value.integer.value[2] = 0;
+		}
+	} else {
+		uctl->value.integer.value[0] = (left > 0 || right > 0) ? 1 : 0;
+	}
+	snd_runtime_check((res = kctl->put(kctl, uctl)) >= 0, goto __unalloc);
+	if (res > 0)
+		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);
+      __unalloc:
+	up_read(&card->controls_rwsem);
+      	kfree(uctl);
+	kfree(uinfo);
+}
+
+static int snd_mixer_oss_put_volume1(snd_mixer_oss_file_t *fmixer,
+				     snd_mixer_oss_slot_t *pslot,
+				     int left, int right)
+{
+	struct slot *slot = (struct slot *)pslot->private_data;
+	
+	if (slot->present & SNDRV_MIXER_OSS_PRESENT_PVOLUME) {
+		snd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PVOLUME], left, right);
+		if (slot->present & SNDRV_MIXER_OSS_PRESENT_CVOLUME)
+			snd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CVOLUME], left, right);
+	} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GVOLUME) {
+		snd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GVOLUME], left, right);
+	} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GLOBAL) {
+		snd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GLOBAL], left, right);
+	}
+	if (left || right) {
+		if (slot->present & SNDRV_MIXER_OSS_PRESENT_PSWITCH)
+			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PSWITCH], left, right, 0);
+		if (slot->present & SNDRV_MIXER_OSS_PRESENT_GSWITCH)
+			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GSWITCH], left, right, 0);
+		if (slot->present & SNDRV_MIXER_OSS_PRESENT_PROUTE)
+			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PROUTE], left, right, 1);
+		if (slot->present & SNDRV_MIXER_OSS_PRESENT_GROUTE)
+			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GROUTE], left, right, 1);
+	} else {
+		if (slot->present & SNDRV_MIXER_OSS_PRESENT_PSWITCH) {
+			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PSWITCH], left, right, 0);
+		} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GSWITCH) {
+			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GSWITCH], left, right, 0);
+		} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_PROUTE) {
+			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PROUTE], left, right, 1);
+		} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GROUTE) {
+			snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GROUTE], left, right, 1);
+		}
+	}
+	return 0;
+}
+
+static int snd_mixer_oss_get_recsrc1_sw(snd_mixer_oss_file_t *fmixer,
+					snd_mixer_oss_slot_t *pslot,
+					int *active)
+{
+	struct slot *slot = (struct slot *)pslot->private_data;
+	int left, right;
+	
+	left = right = 1;
+	snd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CSWITCH], &left, &right, 0);
+	*active = (left || right) ? 1 : 0;
+	return 0;
+}
+
+static int snd_mixer_oss_get_recsrc1_route(snd_mixer_oss_file_t *fmixer,
+					   snd_mixer_oss_slot_t *pslot,
+					   int *active)
+{
+	struct slot *slot = (struct slot *)pslot->private_data;
+	int left, right;
+	
+	left = right = 1;
+	snd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CROUTE], &left, &right, 1);
+	*active = (left || right) ? 1 : 0;
+	return 0;
+}
+
+static int snd_mixer_oss_put_recsrc1_sw(snd_mixer_oss_file_t *fmixer,
+					snd_mixer_oss_slot_t *pslot,
+					int active)
+{
+	struct slot *slot = (struct slot *)pslot->private_data;
+	
+	snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CSWITCH], active, active, 0);
+	return 0;
+}
+
+static int snd_mixer_oss_put_recsrc1_route(snd_mixer_oss_file_t *fmixer,
+					   snd_mixer_oss_slot_t *pslot,
+					   int active)
+{
+	struct slot *slot = (struct slot *)pslot->private_data;
+	
+	snd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CROUTE], active, active, 1);
+	return 0;
+}
+
+static int snd_mixer_oss_get_recsrc2(snd_mixer_oss_file_t *fmixer, unsigned int *active_index)
+{
+	snd_card_t *card = fmixer->card;
+	snd_mixer_oss_t *mixer = fmixer->mixer;
+	snd_kcontrol_t *kctl;
+	snd_mixer_oss_slot_t *pslot;
+	struct slot *slot;
+	snd_ctl_elem_info_t *uinfo;
+	snd_ctl_elem_value_t *uctl;
+	int err, idx;
+	
+	uinfo = kcalloc(1, sizeof(*uinfo), GFP_KERNEL);
+	uctl = kcalloc(1, sizeof(*uctl), GFP_KERNEL);
+	if (uinfo == NULL || uctl == NULL) {
+		err = -ENOMEM;
+		goto __unlock;
+	}
+	down_read(&card->controls_rwsem);
+	kctl = snd_mixer_oss_test_id(mixer, "Capture Source", 0);
+	snd_runtime_check(kctl != NULL, err = -ENOENT; goto __unlock);
+	snd_runtime_check(!(err = kctl->info(kctl, uinfo)), goto __unlock);
+	snd_runtime_check(!(err = kctl->get(kctl, uctl)), goto __unlock);
+	for (idx = 0; idx < 32; idx++) {
+		if (!(mixer->mask_recsrc & (1 << idx)))
+			continue;
+		pslot = &mixer->slots[idx];
+		slot = (struct slot *)pslot->private_data;
+		if (slot->signature != SNDRV_MIXER_OSS_SIGNATURE)
+			continue;
+		if (!(slot->present & SNDRV_MIXER_OSS_PRESENT_CAPTURE))
+			continue;
+		if (slot->capture_item == uctl->value.enumerated.item[0]) {
+			*active_index = idx;
+			break;
+		}
+	}
+	err = 0;
+      __unlock:
+     	up_read(&card->controls_rwsem);
+      	kfree(uctl);
+      	kfree(uinfo);
+      	return err;
+}
+
+static int snd_mixer_oss_put_recsrc2(snd_mixer_oss_file_t *fmixer, unsigned int active_index)
+{
+	snd_card_t *card = fmixer->card;
+	snd_mixer_oss_t *mixer = fmixer->mixer;
+	snd_kcontrol_t *kctl;
+	snd_mixer_oss_slot_t *pslot;
+	struct slot *slot = NULL;
+	snd_ctl_elem_info_t *uinfo;
+	snd_ctl_elem_value_t *uctl;
+	int err;
+	unsigned int idx;
+
+	uinfo = kcalloc(1, sizeof(*uinfo), GFP_KERNEL);
+	uctl = kcalloc(1, sizeof(*uctl), GFP_KERNEL);
+	if (uinfo == NULL || uctl == NULL) {
+		err = -ENOMEM;
+		goto __unlock;
+	}
+	down_read(&card->controls_rwsem);
+	kctl = snd_mixer_oss_test_id(mixer, "Capture Source", 0);
+	snd_runtime_check(kctl != NULL, err = -ENOENT; goto __unlock);
+	snd_runtime_check(!(err = kctl->info(kctl, uinfo)), goto __unlock);
+	for (idx = 0; idx < 32; idx++) {
+		if (!(mixer->mask_recsrc & (1 << idx)))
+			continue;
+		pslot = &mixer->slots[idx];
+		slot = (struct slot *)pslot->private_data;
+		if (slot->signature != SNDRV_MIXER_OSS_SIGNATURE)
+			continue;
+		if (!(slot->present & SNDRV_MIXER_OSS_PRESENT_CAPTURE))
+			continue;
+		if (idx == active_index)
+			break;
+		slot = NULL;
+	}
+	snd_runtime_check(slot != NULL, goto __unlock);
+	for (idx = 0; idx < uinfo->count; idx++)
+		uctl->value.enumerated.item[idx] = slot->capture_item;
+	snd_runtime_check((err = kctl->put(kctl, uctl)) >= 0, );
+	if (err > 0)
+		snd_ctl_notify(fmixer->card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);
+	err = 0;
+      __unlock:
+	up_read(&card->controls_rwsem);
+	kfree(uctl);
+	kfree(uinfo);
+	return err;
+}
+
+struct snd_mixer_oss_assign_table {
+	int oss_id;
+	const char *name;
+	int index;
+};
+
+static int snd_mixer_oss_build_test(snd_mixer_oss_t *mixer, struct slot *slot, const char *name, int index, int item)
+{
+	snd_ctl_elem_info_t *info;
+	snd_kcontrol_t *kcontrol;
+	snd_card_t *card = mixer->card;
+	int err;
+
+	down_read(&card->controls_rwsem);
+	kcontrol = snd_mixer_oss_test_id(mixer, name, index);
+	if (kcontrol == NULL) {
+		up_read(&card->controls_rwsem);
+		return 0;
+	}
+	info = kmalloc(sizeof(*info), GFP_KERNEL);
+	if (! info) {
+		up_read(&card->controls_rwsem);
+		return -ENOMEM;
+	}
+	if ((err = kcontrol->info(kcontrol, info)) < 0) {
+		up_read(&card->controls_rwsem);
+		kfree(info);
+		return err;
+	}
+	slot->numid[item] = kcontrol->id.numid;
+	up_read(&card->controls_rwsem);
+	if (info->count > slot->channels)
+		slot->channels = info->count;
+	slot->present |= 1 << item;
+	kfree(info);
+	return 0;
+}
+
+static void snd_mixer_oss_slot_free(snd_mixer_oss_slot_t *chn)
+{
+	struct slot *p = (struct slot *)chn->private_data;
+	if (p) {
+		if (p->allocated && p->assigned) {
+			kfree(p->assigned->name);
+			kfree(p->assigned);
+		}
+		kfree(p);
+	}
+}
+
+static void mixer_slot_clear(snd_mixer_oss_slot_t *rslot)
+{
+	int idx = rslot->number; /* remember this */
+	if (rslot->private_free)
+		rslot->private_free(rslot);
+	memset(rslot, 0, sizeof(*rslot));
+	rslot->number = idx;
+}
+
+/*
+ * build an OSS mixer element.
+ * ptr_allocated means the entry is dynamically allocated (change via proc file).
+ * when replace_old = 1, the old entry is replaced with the new one.
+ */
+static int snd_mixer_oss_build_input(snd_mixer_oss_t *mixer, struct snd_mixer_oss_assign_table *ptr, int ptr_allocated, int replace_old)
+{
+	struct slot slot;
+	struct slot *pslot;
+	snd_kcontrol_t *kctl;
+	snd_mixer_oss_slot_t *rslot;
+	char str[64];	
+	
+	/* check if already assigned */
+	if (mixer->slots[ptr->oss_id].get_volume && ! replace_old)
+		return 0;
+
+	memset(&slot, 0, sizeof(slot));
+	memset(slot.numid, 0xff, sizeof(slot.numid)); /* ID_UNKNOWN */
+	if (snd_mixer_oss_build_test(mixer, &slot, ptr->name, ptr->index,
+				     SNDRV_MIXER_OSS_ITEM_GLOBAL))
+		return 0;
+	sprintf(str, "%s Switch", ptr->name);
+	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
+				     SNDRV_MIXER_OSS_ITEM_GSWITCH))
+		return 0;
+	sprintf(str, "%s Route", ptr->name);
+	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
+				     SNDRV_MIXER_OSS_ITEM_GROUTE))
+		return 0;
+	sprintf(str, "%s Volume", ptr->name);
+	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
+				     SNDRV_MIXER_OSS_ITEM_GVOLUME))
+		return 0;
+	sprintf(str, "%s Playback Switch", ptr->name);
+	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
+				     SNDRV_MIXER_OSS_ITEM_PSWITCH))
+		return 0;
+	sprintf(str, "%s Playback Route", ptr->name);
+	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
+				     SNDRV_MIXER_OSS_ITEM_PROUTE))
+		return 0;
+	sprintf(str, "%s Playback Volume", ptr->name);
+	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
+				     SNDRV_MIXER_OSS_ITEM_PVOLUME))
+		return 0;
+	sprintf(str, "%s Capture Switch", ptr->name);
+	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
+				     SNDRV_MIXER_OSS_ITEM_CSWITCH))
+		return 0;
+	sprintf(str, "%s Capture Route", ptr->name);
+	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
+				     SNDRV_MIXER_OSS_ITEM_CROUTE))
+		return 0;
+	sprintf(str, "%s Capture Volume", ptr->name);
+	if (snd_mixer_oss_build_test(mixer, &slot, str, ptr->index,
+				     SNDRV_MIXER_OSS_ITEM_CVOLUME))
+		return 0;
+	down_read(&mixer->card->controls_rwsem);
+	if (ptr->index == 0 && (kctl = snd_mixer_oss_test_id(mixer, "Capture Source", 0)) != NULL) {
+		snd_ctl_elem_info_t *uinfo;
+
+		uinfo = kmalloc(sizeof(*uinfo), GFP_KERNEL);
+		if (! uinfo) {
+			up_read(&mixer->card->controls_rwsem);
+			return -ENOMEM;
+		}
+			
+		memset(uinfo, 0, sizeof(*uinfo));
+		if (kctl->info(kctl, uinfo)) {
+			up_read(&mixer->card->controls_rwsem);
+			return 0;
+		}
+		strcpy(str, ptr->name);
+		if (!strcmp(str, "Master"))
+			strcpy(str, "Mix");
+		if (!strcmp(str, "Master Mono"))
+			strcpy(str, "Mix Mono");
+		slot.capture_item = 0;
+		if (!strcmp(uinfo->value.enumerated.name, str)) {
+			slot.present |= SNDRV_MIXER_OSS_PRESENT_CAPTURE;
+		} else {
+			for (slot.capture_item = 1; slot.capture_item < uinfo->value.enumerated.items; slot.capture_item++) {
+				uinfo->value.enumerated.item = slot.capture_item;
+				if (kctl->info(kctl, uinfo)) {
+					up_read(&mixer->card->controls_rwsem);
+					return 0;
+				}
+				if (!strcmp(uinfo->value.enumerated.name, str)) {
+					slot.present |= SNDRV_MIXER_OSS_PRESENT_CAPTURE;
+					break;
+				}
+			}
+		}
+		kfree(uinfo);
+	}
+	up_read(&mixer->card->controls_rwsem);
+	if (slot.present != 0) {
+		pslot = (struct slot *)kmalloc(sizeof(slot), GFP_KERNEL);
+		snd_runtime_check(pslot != NULL, return -ENOMEM);
+		*pslot = slot;
+		pslot->signature = SNDRV_MIXER_OSS_SIGNATURE;
+		pslot->assigned = ptr;
+		pslot->allocated = ptr_allocated;
+		rslot = &mixer->slots[ptr->oss_id];
+		mixer_slot_clear(rslot);
+		rslot->stereo = slot.channels > 1 ? 1 : 0;
+		rslot->get_volume = snd_mixer_oss_get_volume1;
+		rslot->put_volume = snd_mixer_oss_put_volume1;
+		/* note: ES18xx have both Capture Source and XX Capture Volume !!! */
+		if (slot.present & SNDRV_MIXER_OSS_PRESENT_CSWITCH) {
+			rslot->get_recsrc = snd_mixer_oss_get_recsrc1_sw;
+			rslot->put_recsrc = snd_mixer_oss_put_recsrc1_sw;
+		} else if (slot.present & SNDRV_MIXER_OSS_PRESENT_CROUTE) {
+			rslot->get_recsrc = snd_mixer_oss_get_recsrc1_route;
+			rslot->put_recsrc = snd_mixer_oss_put_recsrc1_route;
+		} else if (slot.present & SNDRV_MIXER_OSS_PRESENT_CAPTURE) {
+			mixer->mask_recsrc |= 1 << ptr->oss_id;
+		}
+		rslot->private_data = pslot;
+		rslot->private_free = snd_mixer_oss_slot_free;
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ */
+#define MIXER_VOL(name) [SOUND_MIXER_##name] = #name
+static char *oss_mixer_names[SNDRV_OSS_MAX_MIXERS] = {
+	MIXER_VOL(VOLUME),
+	MIXER_VOL(BASS),
+	MIXER_VOL(TREBLE),
+	MIXER_VOL(SYNTH),
+	MIXER_VOL(PCM),
+	MIXER_VOL(SPEAKER),
+	MIXER_VOL(LINE),
+	MIXER_VOL(MIC),
+	MIXER_VOL(CD),
+	MIXER_VOL(IMIX),
+	MIXER_VOL(ALTPCM),
+	MIXER_VOL(RECLEV),
+	MIXER_VOL(IGAIN),
+	MIXER_VOL(OGAIN),
+	MIXER_VOL(LINE1),
+	MIXER_VOL(LINE2),
+	MIXER_VOL(LINE3),
+	MIXER_VOL(DIGITAL1),
+	MIXER_VOL(DIGITAL2),
+	MIXER_VOL(DIGITAL3),
+	MIXER_VOL(PHONEIN),
+	MIXER_VOL(PHONEOUT),
+	MIXER_VOL(VIDEO),
+	MIXER_VOL(RADIO),
+	MIXER_VOL(MONITOR),
+};
+	
+/*
+ *  /proc interface
+ */
+
+static void snd_mixer_oss_proc_read(snd_info_entry_t *entry,
+				    snd_info_buffer_t * buffer)
+{
+	snd_mixer_oss_t *mixer = entry->private_data;
+	int i;
+
+	down(&mixer->reg_mutex);
+	for (i = 0; i < SNDRV_OSS_MAX_MIXERS; i++) {
+		struct slot *p;
+
+		if (! oss_mixer_names[i])
+			continue;
+		p = (struct slot *)mixer->slots[i].private_data;
+		snd_iprintf(buffer, "%s ", oss_mixer_names[i]);
+		if (p && p->assigned)
+			snd_iprintf(buffer, "\"%s\" %d\n",
+				    p->assigned->name,
+				    p->assigned->index);
+		else
+			snd_iprintf(buffer, "\"\" 0\n");
+	}
+	up(&mixer->reg_mutex);
+}
+
+static void snd_mixer_oss_proc_write(snd_info_entry_t *entry,
+				     snd_info_buffer_t * buffer)
+{
+	snd_mixer_oss_t *mixer = entry->private_data;
+	char line[128], str[32], idxstr[16], *cptr;
+	int ch, idx;
+	struct snd_mixer_oss_assign_table *tbl;
+	struct slot *slot;
+
+	while (!snd_info_get_line(buffer, line, sizeof(line))) {
+		cptr = snd_info_get_str(str, line, sizeof(str));
+		for (ch = 0; ch < SNDRV_OSS_MAX_MIXERS; ch++)
+			if (oss_mixer_names[ch] && strcmp(oss_mixer_names[ch], str) == 0)
+				break;
+		if (ch >= SNDRV_OSS_MAX_MIXERS) {
+			snd_printk(KERN_ERR "mixer_oss: invalid OSS volume '%s'\n", str);
+			continue;
+		}
+		cptr = snd_info_get_str(str, cptr, sizeof(str));
+		if (! *str) {
+			/* remove the entry */
+			down(&mixer->reg_mutex);
+			mixer_slot_clear(&mixer->slots[ch]);
+			up(&mixer->reg_mutex);
+			continue;
+		}
+		snd_info_get_str(idxstr, cptr, sizeof(idxstr));
+		idx = simple_strtoul(idxstr, NULL, 10);
+		if (idx >= 0x4000) { /* too big */
+			snd_printk(KERN_ERR "mixer_oss: invalid index %d\n", idx);
+			continue;
+		}
+		down(&mixer->reg_mutex);
+		slot = (struct slot *)mixer->slots[ch].private_data;
+		if (slot && slot->assigned &&
+		    slot->assigned->index == idx && ! strcmp(slot->assigned->name, str))
+			/* not changed */
+			goto __unlock;
+		tbl = kmalloc(sizeof(*tbl), GFP_KERNEL);
+		if (! tbl) {
+			snd_printk(KERN_ERR "mixer_oss: no memory\n");
+			goto __unlock;
+		}
+		tbl->oss_id = ch;
+		tbl->name = snd_kmalloc_strdup(str, GFP_KERNEL);
+		if (! tbl->name) {
+			kfree(tbl);
+			goto __unlock;
+		}
+		tbl->index = idx;
+		if (snd_mixer_oss_build_input(mixer, tbl, 1, 1) <= 0) {
+			kfree(tbl->name);
+			kfree(tbl);
+		}
+	__unlock:
+		up(&mixer->reg_mutex);
+	}
+}
+
+static void snd_mixer_oss_proc_init(snd_mixer_oss_t *mixer)
+{
+	snd_info_entry_t *entry;
+
+	entry = snd_info_create_card_entry(mixer->card, "oss_mixer",
+					   mixer->card->proc_root);
+	if (! entry)
+		return;
+	entry->content = SNDRV_INFO_CONTENT_TEXT;
+	entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+	entry->c.text.read_size = 8192;
+	entry->c.text.read = snd_mixer_oss_proc_read;
+	entry->c.text.write_size = 8192;
+	entry->c.text.write = snd_mixer_oss_proc_write;
+	entry->private_data = mixer;
+	if (snd_info_register(entry) < 0) {
+		snd_info_free_entry(entry);
+		entry = NULL;
+	}
+	mixer->proc_entry = entry;
+}
+
+static void snd_mixer_oss_proc_done(snd_mixer_oss_t *mixer)
+{
+	if (mixer->proc_entry) {
+		snd_info_unregister(mixer->proc_entry);
+		mixer->proc_entry = NULL;
+	}
+}
+
+static void snd_mixer_oss_build(snd_mixer_oss_t *mixer)
+{
+	static struct snd_mixer_oss_assign_table table[] = {
+		{ SOUND_MIXER_VOLUME, 	"Master",		0 },
+		{ SOUND_MIXER_VOLUME, 	"Front",		0 }, /* fallback */
+		{ SOUND_MIXER_BASS,	"Tone Control - Bass",	0 },
+		{ SOUND_MIXER_TREBLE,	"Tone Control - Treble", 0 },
+		{ SOUND_MIXER_SYNTH,	"Synth",		0 },
+		{ SOUND_MIXER_SYNTH,	"FM",			0 }, /* fallback */
+		{ SOUND_MIXER_SYNTH,	"Music",		0 }, /* fallback */
+		{ SOUND_MIXER_PCM,	"PCM",			0 },
+		{ SOUND_MIXER_SPEAKER,	"PC Speaker", 		0 },
+		{ SOUND_MIXER_LINE,	"Line", 		0 },
+		{ SOUND_MIXER_MIC,	"Mic", 			0 },
+		{ SOUND_MIXER_CD,	"CD", 			0 },
+		{ SOUND_MIXER_IMIX,	"Monitor Mix", 		0 },
+		{ SOUND_MIXER_ALTPCM,	"PCM",			1 },
+		{ SOUND_MIXER_ALTPCM,	"Headphone",		0 }, /* fallback */
+		{ SOUND_MIXER_ALTPCM,	"Wave",			0 }, /* fallback */
+		{ SOUND_MIXER_RECLEV,	"-- nothing --",	0 },
+		{ SOUND_MIXER_IGAIN,	"Capture",		0 },
+		{ SOUND_MIXER_OGAIN,	"Playback",		0 },
+		{ SOUND_MIXER_LINE1,	"Aux",			0 },
+		{ SOUND_MIXER_LINE2,	"Aux",			1 },
+		{ SOUND_MIXER_LINE3,	"Aux",			2 },
+		{ SOUND_MIXER_DIGITAL1,	"Digital",		0 },
+		{ SOUND_MIXER_DIGITAL1,	"IEC958",		0 }, /* fallback */
+		{ SOUND_MIXER_DIGITAL1,	"IEC958 Optical",	0 }, /* fallback */
+		{ SOUND_MIXER_DIGITAL1,	"IEC958 Coaxial",	0 }, /* fallback */
+		{ SOUND_MIXER_DIGITAL2,	"Digital",		1 },
+		{ SOUND_MIXER_DIGITAL3,	"Digital",		2 },
+		{ SOUND_MIXER_PHONEIN,	"Phone",		0 },
+		{ SOUND_MIXER_PHONEOUT,	"Master Mono",		0 },
+		{ SOUND_MIXER_PHONEOUT,	"Phone",		0 }, /* fallback */
+		{ SOUND_MIXER_VIDEO,	"Video",		0 },
+		{ SOUND_MIXER_RADIO,	"Radio",		0 },
+		{ SOUND_MIXER_MONITOR,	"Monitor",		0 }
+	};
+	unsigned int idx;
+	
+	for (idx = 0; idx < ARRAY_SIZE(table); idx++)
+		snd_mixer_oss_build_input(mixer, &table[idx], 0, 0);
+	if (mixer->mask_recsrc) {
+		mixer->get_recsrc = snd_mixer_oss_get_recsrc2;
+		mixer->put_recsrc = snd_mixer_oss_put_recsrc2;
+	}
+}
+
+/*
+ *
+ */
+
+static int snd_mixer_oss_free1(void *private)
+{
+	snd_mixer_oss_t *mixer = private;
+	snd_card_t * card;
+	int idx;
+ 
+	snd_assert(mixer != NULL, return -ENXIO);
+	card = mixer->card;
+	snd_assert(mixer == card->mixer_oss, return -ENXIO);
+	card->mixer_oss = NULL;
+	for (idx = 0; idx < SNDRV_OSS_MAX_MIXERS; idx++) {
+		snd_mixer_oss_slot_t *chn = &mixer->slots[idx];
+		if (chn->private_free)
+			chn->private_free(chn);
+	}
+	kfree(mixer);
+	return 0;
+}
+
+static int snd_mixer_oss_notify_handler(snd_card_t * card, int cmd)
+{
+	snd_mixer_oss_t *mixer;
+
+	if (cmd == SND_MIXER_OSS_NOTIFY_REGISTER) {
+		char name[128];
+		int idx, err;
+
+		mixer = kcalloc(2, sizeof(*mixer), GFP_KERNEL);
+		if (mixer == NULL)
+			return -ENOMEM;
+		init_MUTEX(&mixer->reg_mutex);
+		sprintf(name, "mixer%i%i", card->number, 0);
+		if ((err = snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER,
+						   card, 0,
+						   &snd_mixer_oss_reg,
+						   name)) < 0) {
+			snd_printk("unable to register OSS mixer device %i:%i\n", card->number, 0);
+			kfree(mixer);
+			return err;
+		}
+		mixer->oss_dev_alloc = 1;
+		mixer->card = card;
+		if (*card->mixername)
+			strlcpy(mixer->name, card->mixername, sizeof(mixer->name));
+		else
+			strlcpy(mixer->name, name, sizeof(mixer->name));
+#ifdef SNDRV_OSS_INFO_DEV_MIXERS
+		snd_oss_info_register(SNDRV_OSS_INFO_DEV_MIXERS,
+				      card->number,
+				      mixer->name);
+#endif
+		for (idx = 0; idx < SNDRV_OSS_MAX_MIXERS; idx++)
+			mixer->slots[idx].number = idx;
+		card->mixer_oss = mixer;
+		snd_mixer_oss_build(mixer);
+		snd_mixer_oss_proc_init(mixer);
+	} else if (cmd == SND_MIXER_OSS_NOTIFY_DISCONNECT) {
+		mixer = card->mixer_oss;
+		if (mixer == NULL || !mixer->oss_dev_alloc)
+			return 0;
+		snd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER, mixer->card, 0);
+		mixer->oss_dev_alloc = 0;
+	} else {		/* free */
+		mixer = card->mixer_oss;
+		if (mixer == NULL)
+			return 0;
+#ifdef SNDRV_OSS_INFO_DEV_MIXERS
+		snd_oss_info_unregister(SNDRV_OSS_INFO_DEV_MIXERS, mixer->card->number);
+#endif
+		if (mixer->oss_dev_alloc)
+			snd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER, mixer->card, 0);
+		snd_mixer_oss_proc_done(mixer);
+		return snd_mixer_oss_free1(mixer);
+	}
+	return 0;
+}
+
+static int __init alsa_mixer_oss_init(void)
+{
+	int idx;
+	
+	snd_mixer_oss_notify_callback = snd_mixer_oss_notify_handler;
+	for (idx = 0; idx < SNDRV_CARDS; idx++) {
+		if (snd_cards[idx])
+			snd_mixer_oss_notify_handler(snd_cards[idx], SND_MIXER_OSS_NOTIFY_REGISTER);
+	}
+	return 0;
+}
+
+static void __exit alsa_mixer_oss_exit(void)
+{
+	int idx;
+
+	snd_mixer_oss_notify_callback = NULL;
+	for (idx = 0; idx < SNDRV_CARDS; idx++) {
+		if (snd_cards[idx])
+			snd_mixer_oss_notify_handler(snd_cards[idx], SND_MIXER_OSS_NOTIFY_FREE);
+	}
+}
+
+module_init(alsa_mixer_oss_init)
+module_exit(alsa_mixer_oss_exit)
+
+EXPORT_SYMBOL(snd_mixer_oss_ioctl_card);
