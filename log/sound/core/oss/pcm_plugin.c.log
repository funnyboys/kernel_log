commit ac957e8c54115c1ed32e41e0072af3a63576cda6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 24 21:38:43 2020 +0200

    ALSA: pcm: oss: Place the plugin buffer overflow checks correctly (for 5.7)
    
    [ This is again a forward-port of the fix applied for 5.6-base code
      (commit 4285de0725b1) to 5.7-base, hence neither Fixes nor
      Cc-to-stable tags are included here -- tiwai ]
    
    The checks of the plugin buffer overflow in the previous fix by commit
      f2ecf903ef06 ("ALSA: pcm: oss: Avoid plugin buffer overflow")
    are put in the wrong places mistakenly, which leads to the expected
    (repeated) sound when the rate plugin is involved.  Fix in the right
    places.
    
    Also, at those right places, the zero check is needed for the
    termination node, so added there as well, and let's get it done,
    finally.
    
    Link: https://lore.kernel.org/r/20200424193843.20397-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 59d62f05658f..1545f8fdb4db 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -205,13 +205,14 @@ static snd_pcm_sframes_t calc_dst_frames(struct snd_pcm_substream *plug,
 	plugin = snd_pcm_plug_first(plug);
 	while (plugin && frames > 0) {
 		plugin_next = plugin->next;
+		if (check_size && plugin->buf_frames &&
+		    frames > plugin->buf_frames)
+			frames = plugin->buf_frames;
 		if (plugin->dst_frames) {
 			frames = plugin->dst_frames(plugin, frames);
 			if (frames < 0)
 				return frames;
 		}
-		if (check_size && frames > plugin->buf_frames)
-			frames = plugin->buf_frames;
 		plugin = plugin_next;
 	}
 	return frames;
@@ -225,14 +226,15 @@ static snd_pcm_sframes_t calc_src_frames(struct snd_pcm_substream *plug,
 
 	plugin = snd_pcm_plug_last(plug);
 	while (plugin && frames > 0) {
-		if (check_size && frames > plugin->buf_frames)
-			frames = plugin->buf_frames;
 		plugin_prev = plugin->prev;
 		if (plugin->src_frames) {
 			frames = plugin->src_frames(plugin, frames);
 			if (frames < 0)
 				return frames;
 		}
+		if (check_size && plugin->buf_frames &&
+		    frames > plugin->buf_frames)
+			frames = plugin->buf_frames;
 		plugin = plugin_prev;
 	}
 	return frames;

commit ff7e06a55676931ab32db54f69189482a948c5ec
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 3 09:38:18 2020 +0200

    ALSA: pcm: oss: Fix regression by buffer overflow fix (again)
    
    [ This is essentially the same fix as commit ae769d355664, but it's
      adapted to the latest code for 5.7; hence it contains no Fixes or
      other tags for avoid backport confusion -- tiwai ]
    
    The recent fix for the OOB access in PCM OSS plugins (commit
    f2ecf903ef06: "ALSA: pcm: oss: Avoid plugin buffer overflow") caused a
    regression on OSS applications.  The patch introduced the size check
    in client and slave size calculations to limit to each plugin's buffer
    size, but I overlooked that some code paths call those without
    allocating the buffer but just for estimation.
    
    This patch fixes the bug by skipping the size check for those code
    paths while keeping checking in the actual transfer calls.
    
    Link: https://lore.kernel.org/r/20200403073818.27943-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index fbda4ebf38b3..59d62f05658f 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -197,7 +197,8 @@ int snd_pcm_plugin_free(struct snd_pcm_plugin *plugin)
 }
 
 static snd_pcm_sframes_t calc_dst_frames(struct snd_pcm_substream *plug,
-					 snd_pcm_sframes_t frames)
+					 snd_pcm_sframes_t frames,
+					 bool check_size)
 {
 	struct snd_pcm_plugin *plugin, *plugin_next;
 
@@ -209,7 +210,7 @@ static snd_pcm_sframes_t calc_dst_frames(struct snd_pcm_substream *plug,
 			if (frames < 0)
 				return frames;
 		}
-		if (frames > plugin->buf_frames)
+		if (check_size && frames > plugin->buf_frames)
 			frames = plugin->buf_frames;
 		plugin = plugin_next;
 	}
@@ -217,13 +218,14 @@ static snd_pcm_sframes_t calc_dst_frames(struct snd_pcm_substream *plug,
 }
 
 static snd_pcm_sframes_t calc_src_frames(struct snd_pcm_substream *plug,
-					 snd_pcm_sframes_t frames)
+					 snd_pcm_sframes_t frames,
+					 bool check_size)
 {
 	struct snd_pcm_plugin *plugin, *plugin_prev;
 
 	plugin = snd_pcm_plug_last(plug);
 	while (plugin && frames > 0) {
-		if (frames > plugin->buf_frames)
+		if (check_size && frames > plugin->buf_frames)
 			frames = plugin->buf_frames;
 		plugin_prev = plugin->prev;
 		if (plugin->src_frames) {
@@ -242,9 +244,9 @@ snd_pcm_sframes_t snd_pcm_plug_client_size(struct snd_pcm_substream *plug, snd_p
 		return -ENXIO;
 	switch (snd_pcm_plug_stream(plug)) {
 	case SNDRV_PCM_STREAM_PLAYBACK:
-		return calc_src_frames(plug, drv_frames);
+		return calc_src_frames(plug, drv_frames, false);
 	case SNDRV_PCM_STREAM_CAPTURE:
-		return calc_dst_frames(plug, drv_frames);
+		return calc_dst_frames(plug, drv_frames, false);
 	default:
 		snd_BUG();
 		return -EINVAL;
@@ -257,9 +259,9 @@ snd_pcm_sframes_t snd_pcm_plug_slave_size(struct snd_pcm_substream *plug, snd_pc
 		return -ENXIO;
 	switch (snd_pcm_plug_stream(plug)) {
 	case SNDRV_PCM_STREAM_PLAYBACK:
-		return calc_dst_frames(plug, clt_frames);
+		return calc_dst_frames(plug, clt_frames, false);
 	case SNDRV_PCM_STREAM_CAPTURE:
-		return calc_src_frames(plug, clt_frames);
+		return calc_src_frames(plug, clt_frames, false);
 	default:
 		snd_BUG();
 		return -EINVAL;
@@ -622,7 +624,7 @@ snd_pcm_sframes_t snd_pcm_plug_write_transfer(struct snd_pcm_substream *plug, st
 		src_channels = dst_channels;
 		plugin = next;
 	}
-	return snd_pcm_plug_client_size(plug, frames);
+	return calc_src_frames(plug, frames, true);
 }
 
 snd_pcm_sframes_t snd_pcm_plug_read_transfer(struct snd_pcm_substream *plug, struct snd_pcm_plugin_channel *dst_channels_final, snd_pcm_uframes_t size)
@@ -632,7 +634,7 @@ snd_pcm_sframes_t snd_pcm_plug_read_transfer(struct snd_pcm_substream *plug, str
 	snd_pcm_sframes_t frames = size;
 	int err;
 
-	frames = snd_pcm_plug_slave_size(plug, frames);
+	frames = calc_src_frames(plug, frames, true);
 	if (frames < 0)
 		return frames;
 

commit aa21c3d4b941739651e77747d2f7a20a6c1d87bc
Merge: 476c02e0b4fd 652bb5d8df4b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 30 09:46:51 2020 +0200

    Merge branch 'for-next' into for-linus

commit 5461e0530c222129dfc941058be114b5cbc00837
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 12 16:57:30 2020 +0100

    ALSA: pcm: oss: Remove WARNING from snd_pcm_plug_alloc() checks
    
    The return value checks in snd_pcm_plug_alloc() are covered with
    snd_BUG_ON() macro that may trigger a kernel WARNING depending on the
    kconfig.  But since the error condition can be triggered by a weird
    user space parameter passed to OSS layer, we shouldn't give the kernel
    stack trace just for that.  As it's a normal error condition, let's
    remove snd_BUG_ON() macro usage there.
    
    Reported-by: syzbot+2a59ee7a9831b264f45e@syzkaller.appspotmail.com
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200312155730.7520-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index c9401832967c..752d078908e9 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -111,7 +111,7 @@ int snd_pcm_plug_alloc(struct snd_pcm_substream *plug, snd_pcm_uframes_t frames)
 		while (plugin->next) {
 			if (plugin->dst_frames)
 				frames = plugin->dst_frames(plugin, frames);
-			if (snd_BUG_ON((snd_pcm_sframes_t)frames <= 0))
+			if ((snd_pcm_sframes_t)frames <= 0)
 				return -ENXIO;
 			plugin = plugin->next;
 			err = snd_pcm_plugin_alloc(plugin, frames);
@@ -123,7 +123,7 @@ int snd_pcm_plug_alloc(struct snd_pcm_substream *plug, snd_pcm_uframes_t frames)
 		while (plugin->prev) {
 			if (plugin->src_frames)
 				frames = plugin->src_frames(plugin, frames);
-			if (snd_BUG_ON((snd_pcm_sframes_t)frames <= 0))
+			if ((snd_pcm_sframes_t)frames <= 0)
 				return -ENXIO;
 			plugin = plugin->prev;
 			err = snd_pcm_plugin_alloc(plugin, frames);

commit 3bbf9e2f8624432d1f436bf13ddce1cf9db5238d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 9 19:58:55 2020 +0100

    ALSA: pcm: oss: Simplify plugin frame size calculations
    
    Both snd_pcm_plug_client_size() and snd_pcm_plug_slave_size() do the
    almost same calculations of calling src_frames() and dst_frames() in
    the chain, but just to the different directions with each other.
    
    This patch simplifies those functions.  Now they return -EINVAL for
    the invalid direction, but practically seen, there is no functional
    changes at all.
    
    Link: https://lore.kernel.org/r/20200309185855.15693-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index c9401832967c..58642fecd15c 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -196,82 +196,74 @@ int snd_pcm_plugin_free(struct snd_pcm_plugin *plugin)
 	return 0;
 }
 
-snd_pcm_sframes_t snd_pcm_plug_client_size(struct snd_pcm_substream *plug, snd_pcm_uframes_t drv_frames)
+static snd_pcm_sframes_t calc_dst_frames(struct snd_pcm_substream *plug,
+					 snd_pcm_sframes_t frames)
 {
-	struct snd_pcm_plugin *plugin, *plugin_prev, *plugin_next;
-	int stream;
+	struct snd_pcm_plugin *plugin, *plugin_next;
 
-	if (snd_BUG_ON(!plug))
-		return -ENXIO;
-	if (drv_frames == 0)
-		return 0;
-	stream = snd_pcm_plug_stream(plug);
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		plugin = snd_pcm_plug_last(plug);
-		while (plugin && drv_frames > 0) {
-			if (drv_frames > plugin->buf_frames)
-				drv_frames = plugin->buf_frames;
-			plugin_prev = plugin->prev;
-			if (plugin->src_frames)
-				drv_frames = plugin->src_frames(plugin, drv_frames);
-			plugin = plugin_prev;
+	plugin = snd_pcm_plug_first(plug);
+	while (plugin && frames > 0) {
+		plugin_next = plugin->next;
+		if (plugin->dst_frames) {
+			frames = plugin->dst_frames(plugin, frames);
+			if (frames < 0)
+				return frames;
 		}
-	} else if (stream == SNDRV_PCM_STREAM_CAPTURE) {
-		plugin = snd_pcm_plug_first(plug);
-		while (plugin && drv_frames > 0) {
-			plugin_next = plugin->next;
-			if (plugin->dst_frames)
-				drv_frames = plugin->dst_frames(plugin, drv_frames);
-			if (drv_frames > plugin->buf_frames)
-				drv_frames = plugin->buf_frames;
-			plugin = plugin_next;
+		if (frames > plugin->buf_frames)
+			frames = plugin->buf_frames;
+		plugin = plugin_next;
+	}
+	return frames;
+}
+
+static snd_pcm_sframes_t calc_src_frames(struct snd_pcm_substream *plug,
+					 snd_pcm_sframes_t frames)
+{
+	struct snd_pcm_plugin *plugin, *plugin_prev;
+
+	plugin = snd_pcm_plug_last(plug);
+	while (plugin && frames > 0) {
+		if (frames > plugin->buf_frames)
+			frames = plugin->buf_frames;
+		plugin_prev = plugin->prev;
+		if (plugin->src_frames) {
+			frames = plugin->src_frames(plugin, frames);
+			if (frames < 0)
+				return frames;
 		}
-	} else
+		plugin = plugin_prev;
+	}
+	return frames;
+}
+
+snd_pcm_sframes_t snd_pcm_plug_client_size(struct snd_pcm_substream *plug, snd_pcm_uframes_t drv_frames)
+{
+	if (snd_BUG_ON(!plug))
+		return -ENXIO;
+	switch (snd_pcm_plug_stream(plug)) {
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		return calc_src_frames(plug, drv_frames);
+	case SNDRV_PCM_STREAM_CAPTURE:
+		return calc_dst_frames(plug, drv_frames);
+	default:
 		snd_BUG();
-	return drv_frames;
+		return -EINVAL;
+	}
 }
 
 snd_pcm_sframes_t snd_pcm_plug_slave_size(struct snd_pcm_substream *plug, snd_pcm_uframes_t clt_frames)
 {
-	struct snd_pcm_plugin *plugin, *plugin_prev, *plugin_next;
-	snd_pcm_sframes_t frames;
-	int stream;
-	
 	if (snd_BUG_ON(!plug))
 		return -ENXIO;
-	if (clt_frames == 0)
-		return 0;
-	frames = clt_frames;
-	stream = snd_pcm_plug_stream(plug);
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		plugin = snd_pcm_plug_first(plug);
-		while (plugin && frames > 0) {
-			plugin_next = plugin->next;
-			if (plugin->dst_frames) {
-				frames = plugin->dst_frames(plugin, frames);
-				if (frames < 0)
-					return frames;
-			}
-			if (frames > plugin->buf_frames)
-				frames = plugin->buf_frames;
-			plugin = plugin_next;
-		}
-	} else if (stream == SNDRV_PCM_STREAM_CAPTURE) {
-		plugin = snd_pcm_plug_last(plug);
-		while (plugin) {
-			if (frames > plugin->buf_frames)
-				frames = plugin->buf_frames;
-			plugin_prev = plugin->prev;
-			if (plugin->src_frames) {
-				frames = plugin->src_frames(plugin, frames);
-				if (frames < 0)
-					return frames;
-			}
-			plugin = plugin_prev;
-		}
-	} else
+	switch (snd_pcm_plug_stream(plug)) {
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		return calc_dst_frames(plug, clt_frames);
+	case SNDRV_PCM_STREAM_CAPTURE:
+		return calc_src_frames(plug, clt_frames);
+	default:
 		snd_BUG();
-	return frames;
+		return -EINVAL;
+	}
 }
 
 static int snd_pcm_plug_formats(const struct snd_mask *mask,

commit f2ecf903ef06eb1bbbfa969db9889643d487e73a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 9 09:21:48 2020 +0100

    ALSA: pcm: oss: Avoid plugin buffer overflow
    
    Each OSS PCM plugins allocate its internal buffer per pre-calculation
    of the max buffer size through the chain of plugins (calling
    src_frames and dst_frames callbacks).  This works for most plugins,
    but the rate plugin might behave incorrectly.  The calculation in the
    rate plugin involves with the fractional position, i.e. it may vary
    depending on the input position.  Since the buffer size
    pre-calculation is always done with the offset zero, it may return a
    shorter size than it might be; this may result in the out-of-bound
    access as spotted by fuzzer.
    
    This patch addresses those possible buffer overflow accesses by simply
    setting the upper limit per the given buffer size for each plugin
    before src_frames() and after dst_frames() calls.
    
    Reported-by: syzbot+e1fe9f44fb8ecf4fb5dd@syzkaller.appspotmail.com
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/000000000000b25ea005a02bcf21@google.com
    Link: https://lore.kernel.org/r/20200309082148.19855-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 240e4702c098..c9401832967c 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -209,6 +209,8 @@ snd_pcm_sframes_t snd_pcm_plug_client_size(struct snd_pcm_substream *plug, snd_p
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		plugin = snd_pcm_plug_last(plug);
 		while (plugin && drv_frames > 0) {
+			if (drv_frames > plugin->buf_frames)
+				drv_frames = plugin->buf_frames;
 			plugin_prev = plugin->prev;
 			if (plugin->src_frames)
 				drv_frames = plugin->src_frames(plugin, drv_frames);
@@ -220,6 +222,8 @@ snd_pcm_sframes_t snd_pcm_plug_client_size(struct snd_pcm_substream *plug, snd_p
 			plugin_next = plugin->next;
 			if (plugin->dst_frames)
 				drv_frames = plugin->dst_frames(plugin, drv_frames);
+			if (drv_frames > plugin->buf_frames)
+				drv_frames = plugin->buf_frames;
 			plugin = plugin_next;
 		}
 	} else
@@ -248,11 +252,15 @@ snd_pcm_sframes_t snd_pcm_plug_slave_size(struct snd_pcm_substream *plug, snd_pc
 				if (frames < 0)
 					return frames;
 			}
+			if (frames > plugin->buf_frames)
+				frames = plugin->buf_frames;
 			plugin = plugin_next;
 		}
 	} else if (stream == SNDRV_PCM_STREAM_CAPTURE) {
 		plugin = snd_pcm_plug_last(plug);
 		while (plugin) {
+			if (frames > plugin->buf_frames)
+				frames = plugin->buf_frames;
 			plugin_prev = plugin->prev;
 			if (plugin->src_frames) {
 				frames = plugin->src_frames(plugin, frames);

commit b40fe4bbc76bf6be655f9ba975dc91c6a72fe79e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:55 2020 +0100

    ALSA: oss: More constifications
    
    Apply const prefix to the static tables for strings and formats.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-41-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 31cb2acf8afc..240e4702c098 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -288,7 +288,7 @@ static int snd_pcm_plug_formats(const struct snd_mask *mask,
 	return snd_mask_test(&formats, (__force int)format);
 }
 
-static snd_pcm_format_t preferred_formats[] = {
+static const snd_pcm_format_t preferred_formats[] = {
 	SNDRV_PCM_FORMAT_S16_LE,
 	SNDRV_PCM_FORMAT_S16_BE,
 	SNDRV_PCM_FORMAT_U16_LE,

commit 65766ee0bf7fe8b3be80e2e1c3ef54ad59b29476
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 9 11:59:45 2018 +0100

    ALSA: oss: Use kvzalloc() for local buffer allocations
    
    PCM OSS layer may allocate a few temporary buffers, one for the core
    read/write and another for the conversions via plugins.  Currently
    both are allocated via vmalloc().  But as the allocation size is
    equivalent with the PCM period size, the required size might be quite
    small, depending on the application.
    
    This patch replaces these vmalloc() calls with kvzalloc() for covering
    small period sizes better.  Also, we use "z"-alloc variant here for
    addressing the possible uninitialized access reported by syzkaller.
    
    Reported-by: syzbot+1cb36954e127c98dd037@syzkaller.appspotmail.com
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 141c5f3a9575..31cb2acf8afc 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -66,8 +66,8 @@ static int snd_pcm_plugin_alloc(struct snd_pcm_plugin *plugin, snd_pcm_uframes_t
 		return -ENXIO;
 	size /= 8;
 	if (plugin->buf_frames < frames) {
-		vfree(plugin->buf);
-		plugin->buf = vmalloc(size);
+		kvfree(plugin->buf);
+		plugin->buf = kvzalloc(size, GFP_KERNEL);
 		plugin->buf_frames = frames;
 	}
 	if (!plugin->buf) {
@@ -191,7 +191,7 @@ int snd_pcm_plugin_free(struct snd_pcm_plugin *plugin)
 	if (plugin->private_free)
 		plugin->private_free(plugin);
 	kfree(plugin->buf_channels);
-	vfree(plugin->buf);
+	kvfree(plugin->buf);
 	kfree(plugin);
 	return 0;
 }

commit 6f128fa41f310e1f39ebcea9621d2905549ecf52
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Aug 27 12:21:45 2018 +0300

    ALSA: pcm: signedness bug in snd_pcm_plug_alloc()
    
    The "frames" variable is unsigned so the error handling doesn't work
    properly.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 0391cb1a4f19..141c5f3a9575 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -111,7 +111,7 @@ int snd_pcm_plug_alloc(struct snd_pcm_substream *plug, snd_pcm_uframes_t frames)
 		while (plugin->next) {
 			if (plugin->dst_frames)
 				frames = plugin->dst_frames(plugin, frames);
-			if (snd_BUG_ON(frames <= 0))
+			if (snd_BUG_ON((snd_pcm_sframes_t)frames <= 0))
 				return -ENXIO;
 			plugin = plugin->next;
 			err = snd_pcm_plugin_alloc(plugin, frames);
@@ -123,7 +123,7 @@ int snd_pcm_plug_alloc(struct snd_pcm_substream *plug, snd_pcm_uframes_t frames)
 		while (plugin->prev) {
 			if (plugin->src_frames)
 				frames = plugin->src_frames(plugin, frames);
-			if (snd_BUG_ON(frames <= 0))
+			if (snd_BUG_ON((snd_pcm_sframes_t)frames <= 0))
 				return -ENXIO;
 			plugin = plugin->prev;
 			err = snd_pcm_plugin_alloc(plugin, frames);

commit 5a6cd13d4faef48bdcb7ae9c1e98175332ced7cd
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Wed Aug 1 10:58:25 2018 -0500

    ALSA: pcm: Mark expected switch fall-through
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Addresses-Coverity-ID: 1357375 ("Missing break in switch")
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 85bab922ce69..0391cb1a4f19 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -353,6 +353,7 @@ snd_pcm_format_t snd_pcm_plug_slave_format(snd_pcm_format_t format,
 				if (snd_mask_test(format_mask, (__force int)format1))
 					return format1;
 			}
+			/* fall through */
 		default:
 			return (__force snd_pcm_format_t)-EINVAL;
 		}

commit 191bb51e72c3b2b1ed1b2bd7ac30dd9f7ccea306
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 23:00:55 2018 +0200

    ALSA: pcm: Use standard lower_32_bits() and upper_32_bits()
    
    Instead of open codes, use the standard macros for obtaining the lower
    and upper 32bit values.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 85a56af104bd..85bab922ce69 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -281,10 +281,10 @@ static int snd_pcm_plug_formats(const struct snd_mask *mask,
 		       SNDRV_PCM_FMTBIT_U32_BE | SNDRV_PCM_FMTBIT_S32_BE);
 	snd_mask_set(&formats, (__force int)SNDRV_PCM_FORMAT_MU_LAW);
 	
-	if (formats.bits[0] & (u32)linfmts)
-		formats.bits[0] |= (u32)linfmts;
-	if (formats.bits[1] & (u32)(linfmts >> 32))
-		formats.bits[1] |= (u32)(linfmts >> 32);
+	if (formats.bits[0] & lower_32_bits(linfmts))
+		formats.bits[0] |= lower_32_bits(linfmts);
+	if (formats.bits[1] & upper_32_bits(linfmts))
+		formats.bits[1] |= upper_32_bits(linfmts);
 	return snd_mask_test(&formats, (__force int)format);
 }
 

commit 6708913750344a900f2e73bfe4a4d6dbbce4fe8d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 4 16:39:27 2018 +0100

    ALSA: pcm: Add missing error checks in OSS emulation plugin builder
    
    In the OSS emulation plugin builder where the frame size is parsed in
    the plugin chain, some places miss the possible errors returned from
    the plugin src_ or dst_frames callback.
    
    This patch papers over such places.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index cadc93792868..85a56af104bd 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -592,18 +592,26 @@ snd_pcm_sframes_t snd_pcm_plug_write_transfer(struct snd_pcm_substream *plug, st
 	snd_pcm_sframes_t frames = size;
 
 	plugin = snd_pcm_plug_first(plug);
-	while (plugin && frames > 0) {
+	while (plugin) {
+		if (frames <= 0)
+			return frames;
 		if ((next = plugin->next) != NULL) {
 			snd_pcm_sframes_t frames1 = frames;
-			if (plugin->dst_frames)
+			if (plugin->dst_frames) {
 				frames1 = plugin->dst_frames(plugin, frames);
+				if (frames1 <= 0)
+					return frames1;
+			}
 			if ((err = next->client_channels(next, frames1, &dst_channels)) < 0) {
 				return err;
 			}
 			if (err != frames1) {
 				frames = err;
-				if (plugin->src_frames)
+				if (plugin->src_frames) {
 					frames = plugin->src_frames(plugin, frames1);
+					if (frames <= 0)
+						return frames;
+				}
 			}
 		} else
 			dst_channels = NULL;

commit e76bf3c4b4e456fa8f2c729fa1e8c644857529a8
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Wed May 17 08:48:19 2017 +0900

    ALSA: pcm/oss: refer to parameters instead of copying to reduce usage of kernel stack
    
    Some functions in compatibility layer for Open Sound System interface has
    local variable to copy some parameters in runtime of PCM substream, while
    this can be replaced with reference of pointers to parameter itself. This
    brings an advantage to reduce usage of kernel stack.
    
    This commit applies this idea.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 727ac44d39f4..cadc93792868 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -266,7 +266,8 @@ snd_pcm_sframes_t snd_pcm_plug_slave_size(struct snd_pcm_substream *plug, snd_pc
 	return frames;
 }
 
-static int snd_pcm_plug_formats(struct snd_mask *mask, snd_pcm_format_t format)
+static int snd_pcm_plug_formats(const struct snd_mask *mask,
+				snd_pcm_format_t format)
 {
 	struct snd_mask formats = *mask;
 	u64 linfmts = (SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 |
@@ -309,7 +310,7 @@ static snd_pcm_format_t preferred_formats[] = {
 };
 
 snd_pcm_format_t snd_pcm_plug_slave_format(snd_pcm_format_t format,
-					   struct snd_mask *format_mask)
+					   const struct snd_mask *format_mask)
 {
 	int i;
 

commit 701ef3205eb33bce4ba97b96f6f04a5ae29cd7b8
Author: Xi Wang <xi.wang@gmail.com>
Date:   Tue Nov 13 17:12:12 2012 -0500

    ALSA: core: fix NULL checking in snd_pcm_plug_slave_size()
    
    The dereference snd_pcm_plug_stream(plug) should come after the NULL
    check snd_BUG_ON(!plug).
    
    Signed-off-by: Xi Wang <xi.wang@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index f0d7b1566a10..727ac44d39f4 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -231,13 +231,14 @@ snd_pcm_sframes_t snd_pcm_plug_slave_size(struct snd_pcm_substream *plug, snd_pc
 {
 	struct snd_pcm_plugin *plugin, *plugin_prev, *plugin_next;
 	snd_pcm_sframes_t frames;
-	int stream = snd_pcm_plug_stream(plug);
+	int stream;
 	
 	if (snd_BUG_ON(!plug))
 		return -ENXIO;
 	if (clt_frames == 0)
 		return 0;
 	frames = clt_frames;
+	stream = snd_pcm_plug_stream(plug);
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		plugin = snd_pcm_plug_first(plug);
 		while (plugin && frames > 0) {

commit 9af4e7fedab490fec6e831912859d6be92e9140d
Author: Xi Wang <xi.wang@gmail.com>
Date:   Tue Nov 13 17:12:11 2012 -0500

    ALSA: core: fix NULL checking in snd_pcm_plug_client_size()
    
    The dereference snd_pcm_plug_stream(plug) should come after the NULL
    check snd_BUG_ON(!plug).
    
    Signed-off-by: Xi Wang <xi.wang@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 71cc3ddf5c15..f0d7b1566a10 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -199,12 +199,13 @@ int snd_pcm_plugin_free(struct snd_pcm_plugin *plugin)
 snd_pcm_sframes_t snd_pcm_plug_client_size(struct snd_pcm_substream *plug, snd_pcm_uframes_t drv_frames)
 {
 	struct snd_pcm_plugin *plugin, *plugin_prev, *plugin_next;
-	int stream = snd_pcm_plug_stream(plug);
+	int stream;
 
 	if (snd_BUG_ON(!plug))
 		return -ENXIO;
 	if (drv_frames == 0)
 		return 0;
+	stream = snd_pcm_plug_stream(plug);
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		plugin = snd_pcm_plug_last(plug);
 		while (plugin && drv_frames > 0) {

commit fea952e5cc23ea94b4677ca20774cdc3cea014e2
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Feb 14 11:00:47 2011 +0100

    ALSA: core: sparse cleanups
    
    Change the core code where sparse complains.  In most cases, this means
    just adding annotations to confirm that we indeed want to do the dirty
    things we're doing.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 6751daa3bb50..71cc3ddf5c15 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -264,7 +264,7 @@ snd_pcm_sframes_t snd_pcm_plug_slave_size(struct snd_pcm_substream *plug, snd_pc
 	return frames;
 }
 
-static int snd_pcm_plug_formats(struct snd_mask *mask, int format)
+static int snd_pcm_plug_formats(struct snd_mask *mask, snd_pcm_format_t format)
 {
 	struct snd_mask formats = *mask;
 	u64 linfmts = (SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 |
@@ -276,16 +276,16 @@ static int snd_pcm_plug_formats(struct snd_mask *mask, int format)
 		       SNDRV_PCM_FMTBIT_U24_3BE | SNDRV_PCM_FMTBIT_S24_3BE |
 		       SNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_S32_LE |
 		       SNDRV_PCM_FMTBIT_U32_BE | SNDRV_PCM_FMTBIT_S32_BE);
-	snd_mask_set(&formats, SNDRV_PCM_FORMAT_MU_LAW);
+	snd_mask_set(&formats, (__force int)SNDRV_PCM_FORMAT_MU_LAW);
 	
 	if (formats.bits[0] & (u32)linfmts)
 		formats.bits[0] |= (u32)linfmts;
 	if (formats.bits[1] & (u32)(linfmts >> 32))
 		formats.bits[1] |= (u32)(linfmts >> 32);
-	return snd_mask_test(&formats, format);
+	return snd_mask_test(&formats, (__force int)format);
 }
 
-static int preferred_formats[] = {
+static snd_pcm_format_t preferred_formats[] = {
 	SNDRV_PCM_FORMAT_S16_LE,
 	SNDRV_PCM_FORMAT_S16_BE,
 	SNDRV_PCM_FORMAT_U16_LE,
@@ -306,24 +306,25 @@ static int preferred_formats[] = {
 	SNDRV_PCM_FORMAT_U8
 };
 
-int snd_pcm_plug_slave_format(int format, struct snd_mask *format_mask)
+snd_pcm_format_t snd_pcm_plug_slave_format(snd_pcm_format_t format,
+					   struct snd_mask *format_mask)
 {
 	int i;
 
-	if (snd_mask_test(format_mask, format))
+	if (snd_mask_test(format_mask, (__force int)format))
 		return format;
-	if (! snd_pcm_plug_formats(format_mask, format))
-		return -EINVAL;
+	if (!snd_pcm_plug_formats(format_mask, format))
+		return (__force snd_pcm_format_t)-EINVAL;
 	if (snd_pcm_format_linear(format)) {
 		unsigned int width = snd_pcm_format_width(format);
 		int unsignd = snd_pcm_format_unsigned(format) > 0;
 		int big = snd_pcm_format_big_endian(format) > 0;
 		unsigned int badness, best = -1;
-		int best_format = -1;
+		snd_pcm_format_t best_format = (__force snd_pcm_format_t)-1;
 		for (i = 0; i < ARRAY_SIZE(preferred_formats); i++) {
-			int f = preferred_formats[i];
+			snd_pcm_format_t f = preferred_formats[i];
 			unsigned int w;
-			if (!snd_mask_test(format_mask, f))
+			if (!snd_mask_test(format_mask, (__force int)f))
 				continue;
 			w = snd_pcm_format_width(f);
 			if (w >= width)
@@ -337,17 +338,20 @@ int snd_pcm_plug_slave_format(int format, struct snd_mask *format_mask)
 				best = badness;
 			}
 		}
-		return best_format >= 0 ? best_format : -EINVAL;
+		if ((__force int)best_format >= 0)
+			return best_format;
+		else
+			return (__force snd_pcm_format_t)-EINVAL;
 	} else {
 		switch (format) {
 		case SNDRV_PCM_FORMAT_MU_LAW:
 			for (i = 0; i < ARRAY_SIZE(preferred_formats); ++i) {
-				int format1 = preferred_formats[i];
-				if (snd_mask_test(format_mask, format1))
+				snd_pcm_format_t format1 = preferred_formats[i];
+				if (snd_mask_test(format_mask, (__force int)format1))
 					return format1;
 			}
 		default:
-			return -EINVAL;
+			return (__force snd_pcm_format_t)-EINVAL;
 		}
 	}
 }
@@ -359,7 +363,7 @@ int snd_pcm_plug_format_plugins(struct snd_pcm_substream *plug,
 	struct snd_pcm_plugin_format tmpformat;
 	struct snd_pcm_plugin_format dstformat;
 	struct snd_pcm_plugin_format srcformat;
-	int src_access, dst_access;
+	snd_pcm_access_t src_access, dst_access;
 	struct snd_pcm_plugin *plugin = NULL;
 	int err;
 	int stream = snd_pcm_plug_stream(plug);
@@ -641,7 +645,7 @@ snd_pcm_sframes_t snd_pcm_plug_read_transfer(struct snd_pcm_substream *plug, str
 }
 
 int snd_pcm_area_silence(const struct snd_pcm_channel_area *dst_area, size_t dst_offset,
-			 size_t samples, int format)
+			 size_t samples, snd_pcm_format_t format)
 {
 	/* FIXME: sub byte resolution and odd dst_offset */
 	unsigned char *dst;
@@ -688,7 +692,7 @@ int snd_pcm_area_silence(const struct snd_pcm_channel_area *dst_area, size_t dst
 
 int snd_pcm_area_copy(const struct snd_pcm_channel_area *src_area, size_t src_offset,
 		      const struct snd_pcm_channel_area *dst_area, size_t dst_offset,
-		      size_t samples, int format)
+		      size_t samples, snd_pcm_format_t format)
 {
 	/* FIXME: sub byte resolution and odd dst_offset */
 	char *src, *dst;

commit 7eaa943c8ed8e91e05d0f5d0dc7a18e3319b45cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:09:09 2008 +0200

    ALSA: Kill snd_assert() in sound/core/*
    
    Kill snd_assert() in sound/core/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index bec94138205e..6751daa3bb50 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -62,7 +62,8 @@ static int snd_pcm_plugin_alloc(struct snd_pcm_plugin *plugin, snd_pcm_uframes_t
 	if ((width = snd_pcm_format_physical_width(format->format)) < 0)
 		return width;
 	size = frames * format->channels * width;
-	snd_assert((size % 8) == 0, return -ENXIO);
+	if (snd_BUG_ON(size % 8))
+		return -ENXIO;
 	size /= 8;
 	if (plugin->buf_frames < frames) {
 		vfree(plugin->buf);
@@ -84,7 +85,8 @@ static int snd_pcm_plugin_alloc(struct snd_pcm_plugin *plugin, snd_pcm_uframes_t
 			c->area.step = format->channels * width;
 		}
 	} else if (plugin->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED) {
-		snd_assert((size % format->channels) == 0,);
+		if (snd_BUG_ON(size % format->channels))
+			return -EINVAL;
 		size /= format->channels;
 		for (channel = 0; channel < format->channels; channel++, c++) {
 			c->frames = frames;
@@ -102,13 +104,15 @@ static int snd_pcm_plugin_alloc(struct snd_pcm_plugin *plugin, snd_pcm_uframes_t
 int snd_pcm_plug_alloc(struct snd_pcm_substream *plug, snd_pcm_uframes_t frames)
 {
 	int err;
-	snd_assert(snd_pcm_plug_first(plug) != NULL, return -ENXIO);
+	if (snd_BUG_ON(!snd_pcm_plug_first(plug)))
+		return -ENXIO;
 	if (snd_pcm_plug_stream(plug) == SNDRV_PCM_STREAM_PLAYBACK) {
 		struct snd_pcm_plugin *plugin = snd_pcm_plug_first(plug);
 		while (plugin->next) {
 			if (plugin->dst_frames)
 				frames = plugin->dst_frames(plugin, frames);
-			snd_assert(frames > 0, return -ENXIO);
+			if (snd_BUG_ON(frames <= 0))
+				return -ENXIO;
 			plugin = plugin->next;
 			err = snd_pcm_plugin_alloc(plugin, frames);
 			if (err < 0)
@@ -119,7 +123,8 @@ int snd_pcm_plug_alloc(struct snd_pcm_substream *plug, snd_pcm_uframes_t frames)
 		while (plugin->prev) {
 			if (plugin->src_frames)
 				frames = plugin->src_frames(plugin, frames);
-			snd_assert(frames > 0, return -ENXIO);
+			if (snd_BUG_ON(frames <= 0))
+				return -ENXIO;
 			plugin = plugin->prev;
 			err = snd_pcm_plugin_alloc(plugin, frames);
 			if (err < 0)
@@ -148,8 +153,10 @@ int snd_pcm_plugin_build(struct snd_pcm_substream *plug,
 	struct snd_pcm_plugin *plugin;
 	unsigned int channels;
 	
-	snd_assert(plug != NULL, return -ENXIO);
-	snd_assert(src_format != NULL && dst_format != NULL, return -ENXIO);
+	if (snd_BUG_ON(!plug))
+		return -ENXIO;
+	if (snd_BUG_ON(!src_format || !dst_format))
+		return -ENXIO;
 	plugin = kzalloc(sizeof(*plugin) + extra, GFP_KERNEL);
 	if (plugin == NULL)
 		return -ENOMEM;
@@ -159,10 +166,10 @@ int snd_pcm_plugin_build(struct snd_pcm_substream *plug,
 	plugin->access = SNDRV_PCM_ACCESS_RW_INTERLEAVED;
 	plugin->src_format = *src_format;
 	plugin->src_width = snd_pcm_format_physical_width(src_format->format);
-	snd_assert(plugin->src_width > 0, );
+	snd_BUG_ON(plugin->src_width <= 0);
 	plugin->dst_format = *dst_format;
 	plugin->dst_width = snd_pcm_format_physical_width(dst_format->format);
-	snd_assert(plugin->dst_width > 0, );
+	snd_BUG_ON(plugin->dst_width <= 0);
 	if (plugin->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		channels = src_format->channels;
 	else
@@ -194,7 +201,8 @@ snd_pcm_sframes_t snd_pcm_plug_client_size(struct snd_pcm_substream *plug, snd_p
 	struct snd_pcm_plugin *plugin, *plugin_prev, *plugin_next;
 	int stream = snd_pcm_plug_stream(plug);
 
-	snd_assert(plug != NULL, return -ENXIO);
+	if (snd_BUG_ON(!plug))
+		return -ENXIO;
 	if (drv_frames == 0)
 		return 0;
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
@@ -224,7 +232,8 @@ snd_pcm_sframes_t snd_pcm_plug_slave_size(struct snd_pcm_substream *plug, snd_pc
 	snd_pcm_sframes_t frames;
 	int stream = snd_pcm_plug_stream(plug);
 	
-	snd_assert(plug != NULL, return -ENXIO);
+	if (snd_BUG_ON(!plug))
+		return -ENXIO;
 	if (clt_frames == 0)
 		return 0;
 	frames = clt_frames;
@@ -540,7 +549,8 @@ snd_pcm_sframes_t snd_pcm_plug_client_channels_buf(struct snd_pcm_substream *plu
 	int width, nchannels, channel;
 	int stream = snd_pcm_plug_stream(plug);
 
-	snd_assert(buf != NULL, return -ENXIO);
+	if (snd_BUG_ON(!buf))
+		return -ENXIO;
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		plugin = snd_pcm_plug_first(plug);
 		format = &plugin->src_format;
@@ -553,7 +563,9 @@ snd_pcm_sframes_t snd_pcm_plug_client_channels_buf(struct snd_pcm_substream *plu
 	if ((width = snd_pcm_format_physical_width(format->format)) < 0)
 		return width;
 	nchannels = format->channels;
-	snd_assert(plugin->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED || format->channels <= 1, return -ENXIO);
+	if (snd_BUG_ON(plugin->access != SNDRV_PCM_ACCESS_RW_INTERLEAVED &&
+		       format->channels > 1))
+		return -ENXIO;
 	for (channel = 0; channel < nchannels; channel++, v++) {
 		v->frames = count;
 		v->enabled = 1;

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 14095a927a1b..bec94138205e 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -24,7 +24,6 @@
 #define PLUGIN_DEBUG
 #endif
 
-#include <sound/driver.h>
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/vmalloc.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 25dcf96a5dc6..14095a927a1b 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -1,6 +1,6 @@
 /*
  *  PCM Plug-In shared (kernel/library) code
- *  Copyright (c) 1999 by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) 1999 by Jaroslav Kysela <perex@perex.cz>
  *  Copyright (c) 2000 by Abramo Bagnara <abramo@alsa-project.org>
  *
  *

commit 64d27f96cb719cf8b5dae634c4c548049d4ae6bf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 8 16:49:08 2007 +0200

    [ALSA] Support 3-bytes 24bit format in PCM OSS emulation
    
    Add the support of 3-bytes 24bit formats in PCM OSS emulation.
    Also removed snd_pcm_build_linear_format() function.  It's exported
    just for OSS emulation, and now the code was changed without calling
    this function.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index c0afb92869d3..25dcf96a5dc6 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -264,6 +264,8 @@ static int snd_pcm_plug_formats(struct snd_mask *mask, int format)
 		       SNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |
 		       SNDRV_PCM_FMTBIT_U24_LE | SNDRV_PCM_FMTBIT_S24_LE |
 		       SNDRV_PCM_FMTBIT_U24_BE | SNDRV_PCM_FMTBIT_S24_BE |
+		       SNDRV_PCM_FMTBIT_U24_3LE | SNDRV_PCM_FMTBIT_S24_3LE |
+		       SNDRV_PCM_FMTBIT_U24_3BE | SNDRV_PCM_FMTBIT_S24_3BE |
 		       SNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_S32_LE |
 		       SNDRV_PCM_FMTBIT_U32_BE | SNDRV_PCM_FMTBIT_S32_BE);
 	snd_mask_set(&formats, SNDRV_PCM_FORMAT_MU_LAW);
@@ -280,6 +282,10 @@ static int preferred_formats[] = {
 	SNDRV_PCM_FORMAT_S16_BE,
 	SNDRV_PCM_FORMAT_U16_LE,
 	SNDRV_PCM_FORMAT_U16_BE,
+	SNDRV_PCM_FORMAT_S24_3LE,
+	SNDRV_PCM_FORMAT_S24_3BE,
+	SNDRV_PCM_FORMAT_U24_3LE,
+	SNDRV_PCM_FORMAT_U24_3BE,
 	SNDRV_PCM_FORMAT_S24_LE,
 	SNDRV_PCM_FORMAT_S24_BE,
 	SNDRV_PCM_FORMAT_U24_LE,
@@ -294,41 +300,37 @@ static int preferred_formats[] = {
 
 int snd_pcm_plug_slave_format(int format, struct snd_mask *format_mask)
 {
+	int i;
+
 	if (snd_mask_test(format_mask, format))
 		return format;
 	if (! snd_pcm_plug_formats(format_mask, format))
 		return -EINVAL;
 	if (snd_pcm_format_linear(format)) {
-		int width = snd_pcm_format_width(format);
-		int unsignd = snd_pcm_format_unsigned(format);
-		int big = snd_pcm_format_big_endian(format);
-		int format1;
-		int wid, width1=width;
-		int dwidth1 = 8;
-		for (wid = 0; wid < 4; ++wid) {
-			int end, big1 = big;
-			for (end = 0; end < 2; ++end) {
-				int sgn, unsignd1 = unsignd;
-				for (sgn = 0; sgn < 2; ++sgn) {
-					format1 = snd_pcm_build_linear_format(width1, unsignd1, big1);
-					if (format1 >= 0 &&
-					    snd_mask_test(format_mask, format1))
-						goto _found;
-					unsignd1 = !unsignd1;
-				}
-				big1 = !big1;
-			}
-			if (width1 == 32) {
-				dwidth1 = -dwidth1;
-				width1 = width;
+		unsigned int width = snd_pcm_format_width(format);
+		int unsignd = snd_pcm_format_unsigned(format) > 0;
+		int big = snd_pcm_format_big_endian(format) > 0;
+		unsigned int badness, best = -1;
+		int best_format = -1;
+		for (i = 0; i < ARRAY_SIZE(preferred_formats); i++) {
+			int f = preferred_formats[i];
+			unsigned int w;
+			if (!snd_mask_test(format_mask, f))
+				continue;
+			w = snd_pcm_format_width(f);
+			if (w >= width)
+				badness = w - width;
+			else
+				badness = width - w + 32;
+			badness += snd_pcm_format_unsigned(f) != unsignd;
+			badness += snd_pcm_format_big_endian(f) != big;
+			if (badness < best) {
+				best_format = f;
+				best = badness;
 			}
-			width1 += dwidth1;
 		}
-		return -EINVAL;
-	_found:
-		return format1;
+		return best_format >= 0 ? best_format : -EINVAL;
 	} else {
-		unsigned int i;
 		switch (format) {
 		case SNDRV_PCM_FORMAT_MU_LAW:
 			for (i = 0; i < ARRAY_SIZE(preferred_formats); ++i) {

commit 887f9f0253ba4a52f38810f3056cdf040a6157b3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 8 15:20:48 2007 +0200

    [ALSA] Remove ifdefs from OSS PCM emulation codes
    
    Fix Makefile to compile files conditionally to CONFIG_SND_PCM_OSS_PLUGINS,
    and remove unneeded ifdefs in these files.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 0e67dd280a5d..c0afb92869d3 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -25,9 +25,6 @@
 #endif
 
 #include <sound/driver.h>
-
-#ifdef CONFIG_SND_PCM_OSS_PLUGINS
-
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/vmalloc.h>
@@ -740,5 +737,3 @@ int snd_pcm_area_copy(const struct snd_pcm_channel_area *src_area, size_t src_of
 	}
 	return 0;
 }
-
-#endif

commit c82590d2b2877ec846c5313ea897420209b91ea7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 20 17:13:45 2006 +0100

    [ALSA] Fix mulaw -> linear conversion in OSS PCM emulation
    
    Modules: ALSA<-OSS emulation
    
    Fixed the missing mulaw -> linear conversion in OSS PCM emulation code.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index cec2774425ec..0e67dd280a5d 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -470,7 +470,8 @@ int snd_pcm_plug_format_plugins(struct snd_pcm_substream *plug,
 	/* format change */
 	if (srcformat.format != dstformat.format) {
 		tmpformat.format = dstformat.format;
-		if (tmpformat.format == SNDRV_PCM_FORMAT_MU_LAW) {
+		if (srcformat.format == SNDRV_PCM_FORMAT_MU_LAW ||
+		    tmpformat.format == SNDRV_PCM_FORMAT_MU_LAW) {
 			err = snd_pcm_plugin_build_mulaw(plug,
 							 &srcformat, &tmpformat,
 							 &plugin);

commit 0534ab4279bd25e2d0a888af07466446dac05d74
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 13 12:09:12 2006 +0100

    [ALSA] Clean up pcm-oss plugins
    
    Modules: ALSA<-OSS emulation
    
    Clean up pcm-oss plugin codes.
    Removed dead codes, and simplified route/rate plugins.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 89bc8f965043..cec2774425ec 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -39,26 +39,6 @@
 #define snd_pcm_plug_first(plug) ((plug)->runtime->oss.plugin_first)
 #define snd_pcm_plug_last(plug) ((plug)->runtime->oss.plugin_last)
 
-static int snd_pcm_plugin_src_channels_mask(struct snd_pcm_plugin *plugin,
-					    unsigned long *dst_vmask,
-					    unsigned long **src_vmask)
-{
-	unsigned long *vmask = plugin->src_vmask;
-	bitmap_copy(vmask, dst_vmask, plugin->src_format.channels);
-	*src_vmask = vmask;
-	return 0;
-}
-
-static int snd_pcm_plugin_dst_channels_mask(struct snd_pcm_plugin *plugin,
-					    unsigned long *src_vmask,
-					    unsigned long **dst_vmask)
-{
-	unsigned long *vmask = plugin->dst_vmask;
-	bitmap_copy(vmask, src_vmask, plugin->dst_format.channels);
-	*dst_vmask = vmask;
-	return 0;
-}
-
 /*
  *  because some cards might have rates "very close", we ignore
  *  all "resampling" requests within +-5%
@@ -196,19 +176,7 @@ int snd_pcm_plugin_build(struct snd_pcm_substream *plug,
 		snd_pcm_plugin_free(plugin);
 		return -ENOMEM;
 	}
-	plugin->src_vmask = bitmap_alloc(src_format->channels);
-	if (plugin->src_vmask == NULL) {
-		snd_pcm_plugin_free(plugin);
-		return -ENOMEM;
-	}
-	plugin->dst_vmask = bitmap_alloc(dst_format->channels);
-	if (plugin->dst_vmask == NULL) {
-		snd_pcm_plugin_free(plugin);
-		return -ENOMEM;
-	}
 	plugin->client_channels = snd_pcm_plugin_client_channels;
-	plugin->src_channels_mask = snd_pcm_plugin_src_channels_mask;
-	plugin->dst_channels_mask = snd_pcm_plugin_dst_channels_mask;
 	*ret = plugin;
 	return 0;
 }
@@ -221,8 +189,6 @@ int snd_pcm_plugin_free(struct snd_pcm_plugin *plugin)
 		plugin->private_free(plugin);
 	kfree(plugin->buf_channels);
 	vfree(plugin->buf);
-	kfree(plugin->src_vmask);
-	kfree(plugin->dst_vmask);
 	kfree(plugin);
 	return 0;
 }
@@ -432,24 +398,14 @@ int snd_pcm_plug_format_plugins(struct snd_pcm_substream *plug,
 		 dstformat.channels);
 
 	/* Format change (linearization) */
-	if ((srcformat.format != dstformat.format ||
-	     !rate_match(srcformat.rate, dstformat.rate) ||
-	     srcformat.channels != dstformat.channels) &&
-	    !snd_pcm_format_linear(srcformat.format)) {
-		if (snd_pcm_format_linear(dstformat.format))
-			tmpformat.format = dstformat.format;
-		else
-			tmpformat.format = SNDRV_PCM_FORMAT_S16;
-		switch (srcformat.format) {
-		case SNDRV_PCM_FORMAT_MU_LAW:
-			err = snd_pcm_plugin_build_mulaw(plug,
-							 &srcformat, &tmpformat,
-							 &plugin);
-			break;
-		default:
+	if (! rate_match(srcformat.rate, dstformat.rate) &&
+	    ! snd_pcm_format_linear(srcformat.format)) {
+		if (srcformat.format != SNDRV_PCM_FORMAT_MU_LAW)
 			return -EINVAL;
-		}
-		pdprintf("format change: src=%i, dst=%i returns %i\n", srcformat.format, tmpformat.format, err);
+		tmpformat.format = SNDRV_PCM_FORMAT_S16;
+		err = snd_pcm_plugin_build_mulaw(plug,
+						 &srcformat, &tmpformat,
+						 &plugin);
 		if (err < 0)
 			return err;
 		err = snd_pcm_plugin_append(plugin);
@@ -463,35 +419,11 @@ int snd_pcm_plug_format_plugins(struct snd_pcm_substream *plug,
 
 	/* channels reduction */
 	if (srcformat.channels > dstformat.channels) {
-		int sv = srcformat.channels;
-		int dv = dstformat.channels;
-		int *ttable = kcalloc(dv * sv, sizeof(*ttable), GFP_KERNEL);
-		if (ttable == NULL)
-			return -ENOMEM;
-#if 1
-		if (sv == 2 && dv == 1) {
-			ttable[0] = HALF;
-			ttable[1] = HALF;
-		} else
-#endif
-		{
-			int v;
-			for (v = 0; v < dv; ++v)
-				ttable[v * sv + v] = FULL;
-		}
 		tmpformat.channels = dstformat.channels;
-		if (rate_match(srcformat.rate, dstformat.rate) &&
-		    snd_pcm_format_linear(dstformat.format))
-			tmpformat.format = dstformat.format;
-		err = snd_pcm_plugin_build_route(plug,
-						 &srcformat, &tmpformat,
-						 ttable, &plugin);
-		kfree(ttable);
+		err = snd_pcm_plugin_build_route(plug, &srcformat, &tmpformat, &plugin);
 		pdprintf("channels reduction: src=%i, dst=%i returns %i\n", srcformat.channels, tmpformat.channels, err);
-		if (err < 0) {
-			snd_pcm_plugin_free(plugin);
+		if (err < 0)
 			return err;
-		}
 		err = snd_pcm_plugin_append(plugin);
 		if (err < 0) {
 			snd_pcm_plugin_free(plugin);
@@ -503,18 +435,29 @@ int snd_pcm_plug_format_plugins(struct snd_pcm_substream *plug,
 
 	/* rate resampling */
 	if (!rate_match(srcformat.rate, dstformat.rate)) {
+		if (srcformat.format != SNDRV_PCM_FORMAT_S16) {
+			/* convert to S16 for resampling */
+			tmpformat.format = SNDRV_PCM_FORMAT_S16;
+			err = snd_pcm_plugin_build_linear(plug,
+							  &srcformat, &tmpformat,
+							  &plugin);
+			if (err < 0)
+				return err;
+			err = snd_pcm_plugin_append(plugin);
+			if (err < 0) {
+				snd_pcm_plugin_free(plugin);
+				return err;
+			}
+			srcformat = tmpformat;
+			src_access = dst_access;
+		}
 		tmpformat.rate = dstformat.rate;
-		if (srcformat.channels == dstformat.channels &&
-		    snd_pcm_format_linear(dstformat.format))
-			tmpformat.format = dstformat.format;
         	err = snd_pcm_plugin_build_rate(plug,
         					&srcformat, &tmpformat,
 						&plugin);
 		pdprintf("rate down resampling: src=%i, dst=%i returns %i\n", srcformat.rate, tmpformat.rate, err);
-		if (err < 0) {
-			snd_pcm_plugin_free(plugin);
+		if (err < 0)
 			return err;
-		}      					    
 		err = snd_pcm_plugin_append(plugin);
 		if (err < 0) {
 			snd_pcm_plugin_free(plugin);
@@ -524,52 +467,6 @@ int snd_pcm_plug_format_plugins(struct snd_pcm_substream *plug,
 		src_access = dst_access;
         }
 
-	/* channels extension  */
-	if (srcformat.channels < dstformat.channels) {
-		int sv = srcformat.channels;
-		int dv = dstformat.channels;
-		int *ttable = kcalloc(dv * sv, sizeof(*ttable), GFP_KERNEL);
-		if (ttable == NULL)
-			return -ENOMEM;
-#if 0
-		{
-			int v;
-			for (v = 0; v < sv; ++v)
-				ttable[v * sv + v] = FULL;
-		}
-#else
-		{
-			/* Playback is spreaded on all channels */
-			int vd, vs;
-			for (vd = 0, vs = 0; vd < dv; ++vd) {
-				ttable[vd * sv + vs] = FULL;
-				vs++;
-				if (vs == sv)
-					vs = 0;
-			}
-		}
-#endif
-		tmpformat.channels = dstformat.channels;
-		if (snd_pcm_format_linear(dstformat.format))
-			tmpformat.format = dstformat.format;
-		err = snd_pcm_plugin_build_route(plug,
-						 &srcformat, &tmpformat,
-						 ttable, &plugin);
-		kfree(ttable);
-		pdprintf("channels extension: src=%i, dst=%i returns %i\n", srcformat.channels, tmpformat.channels, err);
-		if (err < 0) {
-			snd_pcm_plugin_free(plugin);
-			return err;
-		}      					    
-		err = snd_pcm_plugin_append(plugin);
-		if (err < 0) {
-			snd_pcm_plugin_free(plugin);
-			return err;
-		}
-		srcformat = tmpformat;
-		src_access = dst_access;
-	}
-
 	/* format change */
 	if (srcformat.format != dstformat.format) {
 		tmpformat.format = dstformat.format;
@@ -598,6 +495,22 @@ int snd_pcm_plug_format_plugins(struct snd_pcm_substream *plug,
 		src_access = dst_access;
 	}
 
+	/* channels extension */
+	if (srcformat.channels < dstformat.channels) {
+		tmpformat.channels = dstformat.channels;
+		err = snd_pcm_plugin_build_route(plug, &srcformat, &tmpformat, &plugin);
+		pdprintf("channels extension: src=%i, dst=%i returns %i\n", srcformat.channels, tmpformat.channels, err);
+		if (err < 0)
+			return err;
+		err = snd_pcm_plugin_append(plugin);
+		if (err < 0) {
+			snd_pcm_plugin_free(plugin);
+			return err;
+		}
+		srcformat = tmpformat;
+		src_access = dst_access;
+	}
+
 	/* de-interleave */
 	if (src_access != dst_access) {
 		err = snd_pcm_plugin_build_copy(plug,
@@ -653,92 +566,6 @@ snd_pcm_sframes_t snd_pcm_plug_client_channels_buf(struct snd_pcm_substream *plu
 	return count;
 }
 
-static int snd_pcm_plug_playback_channels_mask(struct snd_pcm_substream *plug,
-					       unsigned long *client_vmask)
-{
-	struct snd_pcm_plugin *plugin = snd_pcm_plug_last(plug);
-	if (plugin == NULL) {
-		return 0;
-	} else {
-		int schannels = plugin->dst_format.channels;
-		DECLARE_BITMAP(bs, schannels);
-		unsigned long *srcmask;
-		unsigned long *dstmask = bs;
-		int err;
-		bitmap_fill(dstmask, schannels);
-
-		while (1) {
-			err = plugin->src_channels_mask(plugin, dstmask, &srcmask);
-			if (err < 0)
-				return err;
-			dstmask = srcmask;
-			if (plugin->prev == NULL)
-				break;
-			plugin = plugin->prev;
-		}
-		bitmap_and(client_vmask, client_vmask, dstmask, plugin->src_format.channels);
-		return 0;
-	}
-}
-
-static int snd_pcm_plug_playback_disable_useless_channels(struct snd_pcm_substream *plug,
-							  struct snd_pcm_plugin_channel *src_channels)
-{
-	struct snd_pcm_plugin *plugin = snd_pcm_plug_first(plug);
-	unsigned int nchannels = plugin->src_format.channels;
-	DECLARE_BITMAP(bs, nchannels);
-	unsigned long *srcmask = bs;
-	int err;
-	unsigned int channel;
-	for (channel = 0; channel < nchannels; channel++) {
-		if (src_channels[channel].enabled)
-			set_bit(channel, srcmask);
-		else
-			clear_bit(channel, srcmask);
-	}
-	err = snd_pcm_plug_playback_channels_mask(plug, srcmask);
-	if (err < 0)
-		return err;
-	for (channel = 0; channel < nchannels; channel++) {
-		if (!test_bit(channel, srcmask))
-			src_channels[channel].enabled = 0;
-	}
-	return 0;
-}
-
-static int snd_pcm_plug_capture_disable_useless_channels(struct snd_pcm_substream *plug,
-							 struct snd_pcm_plugin_channel *src_channels,
-							 struct snd_pcm_plugin_channel *client_channels)
-{
-	struct snd_pcm_plugin *plugin = snd_pcm_plug_last(plug);
-	unsigned int nchannels = plugin->dst_format.channels;
-	DECLARE_BITMAP(bs, nchannels);
-	unsigned long *dstmask = bs;
-	unsigned long *srcmask;
-	int err;
-	unsigned int channel;
-	for (channel = 0; channel < nchannels; channel++) {
-		if (client_channels[channel].enabled)
-			set_bit(channel, dstmask);
-		else
-			clear_bit(channel, dstmask);
-	}
-	while (plugin) {
-		err = plugin->src_channels_mask(plugin, dstmask, &srcmask);
-		if (err < 0)
-			return err;
-		dstmask = srcmask;
-		plugin = plugin->prev;
-	}
-	plugin = snd_pcm_plug_first(plug);
-	nchannels = plugin->src_format.channels;
-	for (channel = 0; channel < nchannels; channel++) {
-		if (!test_bit(channel, dstmask))
-			src_channels[channel].enabled = 0;
-	}
-	return 0;
-}
-
 snd_pcm_sframes_t snd_pcm_plug_write_transfer(struct snd_pcm_substream *plug, struct snd_pcm_plugin_channel *src_channels, snd_pcm_uframes_t size)
 {
 	struct snd_pcm_plugin *plugin, *next;
@@ -746,9 +573,6 @@ snd_pcm_sframes_t snd_pcm_plug_write_transfer(struct snd_pcm_substream *plug, st
 	int err;
 	snd_pcm_sframes_t frames = size;
 
-	if ((err = snd_pcm_plug_playback_disable_useless_channels(plug, src_channels)) < 0)
-		return err;
-	
 	plugin = snd_pcm_plug_first(plug);
 	while (plugin && frames > 0) {
 		if ((next = plugin->next) != NULL) {
@@ -793,10 +617,6 @@ snd_pcm_sframes_t snd_pcm_plug_read_transfer(struct snd_pcm_substream *plug, str
 				return err;
 			}
 			frames = err;
-			if (!plugin->prev) {
-				if ((err = snd_pcm_plug_capture_disable_useless_channels(plug, dst_channels, dst_channels_final)) < 0)
-					return err;
-			}
 		} else {
 			dst_channels = dst_channels_final;
 		}

commit 21a3479a0b606d36fe24093f70a1c27328cec286
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Fri Jan 13 09:12:11 2006 +0100

    [ALSA] PCM midlevel & PCM OSS - make procfs & OSS plugin code optional
    
    Modules: ALSA Core,PCM Midlevel,ALSA<-OSS emulation,USB generic driver
    
    1) The verbose procfs code for the PCM midlevel and usb audio
       can be removed now (more patches will follow).
       CONFIG_SND_VERBOSE_PROCFS
    2) The PCM OSS plugin system can be also compiled optionaly.
       CONFIG_SND_PCM_OSS_PLUGINS
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 7e8676880dde..89bc8f965043 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -25,6 +25,9 @@
 #endif
 
 #include <sound/driver.h>
+
+#ifdef CONFIG_SND_PCM_OSS_PLUGINS
+
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/vmalloc.h>
@@ -916,3 +919,5 @@ int snd_pcm_area_copy(const struct snd_pcm_channel_area *src_area, size_t src_of
 	}
 	return 0;
 }
+
+#endif

commit 6ac77bc180fbd985988015020c2e2347e802959d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:01:49 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCM OSS-emulation
    
    Modules: ALSA<-OSS emulation
    
    Remove xxx_t typedefs from the core PCM OSS-emulation codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 312ae1f2bfc3..7e8676880dde 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -36,7 +36,7 @@
 #define snd_pcm_plug_first(plug) ((plug)->runtime->oss.plugin_first)
 #define snd_pcm_plug_last(plug) ((plug)->runtime->oss.plugin_last)
 
-static int snd_pcm_plugin_src_channels_mask(snd_pcm_plugin_t *plugin,
+static int snd_pcm_plugin_src_channels_mask(struct snd_pcm_plugin *plugin,
 					    unsigned long *dst_vmask,
 					    unsigned long **src_vmask)
 {
@@ -46,7 +46,7 @@ static int snd_pcm_plugin_src_channels_mask(snd_pcm_plugin_t *plugin,
 	return 0;
 }
 
-static int snd_pcm_plugin_dst_channels_mask(snd_pcm_plugin_t *plugin,
+static int snd_pcm_plugin_dst_channels_mask(struct snd_pcm_plugin *plugin,
 					    unsigned long *src_vmask,
 					    unsigned long **dst_vmask)
 {
@@ -67,13 +67,13 @@ static int rate_match(unsigned int src_rate, unsigned int dst_rate)
 	return dst_rate >= low && dst_rate <= high;
 }
 
-static int snd_pcm_plugin_alloc(snd_pcm_plugin_t *plugin, snd_pcm_uframes_t frames)
+static int snd_pcm_plugin_alloc(struct snd_pcm_plugin *plugin, snd_pcm_uframes_t frames)
 {
-	snd_pcm_plugin_format_t *format;
+	struct snd_pcm_plugin_format *format;
 	ssize_t width;
 	size_t size;
 	unsigned int channel;
-	snd_pcm_plugin_channel_t *c;
+	struct snd_pcm_plugin_channel *c;
 
 	if (plugin->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		format = &plugin->src_format;
@@ -120,12 +120,12 @@ static int snd_pcm_plugin_alloc(snd_pcm_plugin_t *plugin, snd_pcm_uframes_t fram
 	return 0;
 }
 
-int snd_pcm_plug_alloc(snd_pcm_plug_t *plug, snd_pcm_uframes_t frames)
+int snd_pcm_plug_alloc(struct snd_pcm_substream *plug, snd_pcm_uframes_t frames)
 {
 	int err;
 	snd_assert(snd_pcm_plug_first(plug) != NULL, return -ENXIO);
 	if (snd_pcm_plug_stream(plug) == SNDRV_PCM_STREAM_PLAYBACK) {
-		snd_pcm_plugin_t *plugin = snd_pcm_plug_first(plug);
+		struct snd_pcm_plugin *plugin = snd_pcm_plug_first(plug);
 		while (plugin->next) {
 			if (plugin->dst_frames)
 				frames = plugin->dst_frames(plugin, frames);
@@ -136,7 +136,7 @@ int snd_pcm_plug_alloc(snd_pcm_plug_t *plug, snd_pcm_uframes_t frames)
 				return err;
 		}
 	} else {
-		snd_pcm_plugin_t *plugin = snd_pcm_plug_last(plug);
+		struct snd_pcm_plugin *plugin = snd_pcm_plug_last(plug);
 		while (plugin->prev) {
 			if (plugin->src_frames)
 				frames = plugin->src_frames(plugin, frames);
@@ -151,22 +151,22 @@ int snd_pcm_plug_alloc(snd_pcm_plug_t *plug, snd_pcm_uframes_t frames)
 }
 
 
-snd_pcm_sframes_t snd_pcm_plugin_client_channels(snd_pcm_plugin_t *plugin,
+snd_pcm_sframes_t snd_pcm_plugin_client_channels(struct snd_pcm_plugin *plugin,
 				       snd_pcm_uframes_t frames,
-				       snd_pcm_plugin_channel_t **channels)
+				       struct snd_pcm_plugin_channel **channels)
 {
 	*channels = plugin->buf_channels;
 	return frames;
 }
 
-int snd_pcm_plugin_build(snd_pcm_plug_t *plug,
+int snd_pcm_plugin_build(struct snd_pcm_substream *plug,
 			 const char *name,
-			 snd_pcm_plugin_format_t *src_format,
-			 snd_pcm_plugin_format_t *dst_format,
+			 struct snd_pcm_plugin_format *src_format,
+			 struct snd_pcm_plugin_format *dst_format,
 			 size_t extra,
-			 snd_pcm_plugin_t **ret)
+			 struct snd_pcm_plugin **ret)
 {
-	snd_pcm_plugin_t *plugin;
+	struct snd_pcm_plugin *plugin;
 	unsigned int channels;
 	
 	snd_assert(plug != NULL, return -ENXIO);
@@ -210,7 +210,7 @@ int snd_pcm_plugin_build(snd_pcm_plug_t *plug,
 	return 0;
 }
 
-int snd_pcm_plugin_free(snd_pcm_plugin_t *plugin)
+int snd_pcm_plugin_free(struct snd_pcm_plugin *plugin)
 {
 	if (! plugin)
 		return 0;
@@ -224,9 +224,9 @@ int snd_pcm_plugin_free(snd_pcm_plugin_t *plugin)
 	return 0;
 }
 
-snd_pcm_sframes_t snd_pcm_plug_client_size(snd_pcm_plug_t *plug, snd_pcm_uframes_t drv_frames)
+snd_pcm_sframes_t snd_pcm_plug_client_size(struct snd_pcm_substream *plug, snd_pcm_uframes_t drv_frames)
 {
-	snd_pcm_plugin_t *plugin, *plugin_prev, *plugin_next;
+	struct snd_pcm_plugin *plugin, *plugin_prev, *plugin_next;
 	int stream = snd_pcm_plug_stream(plug);
 
 	snd_assert(plug != NULL, return -ENXIO);
@@ -253,9 +253,9 @@ snd_pcm_sframes_t snd_pcm_plug_client_size(snd_pcm_plug_t *plug, snd_pcm_uframes
 	return drv_frames;
 }
 
-snd_pcm_sframes_t snd_pcm_plug_slave_size(snd_pcm_plug_t *plug, snd_pcm_uframes_t clt_frames)
+snd_pcm_sframes_t snd_pcm_plug_slave_size(struct snd_pcm_substream *plug, snd_pcm_uframes_t clt_frames)
 {
-	snd_pcm_plugin_t *plugin, *plugin_prev, *plugin_next;
+	struct snd_pcm_plugin *plugin, *plugin_prev, *plugin_next;
 	snd_pcm_sframes_t frames;
 	int stream = snd_pcm_plug_stream(plug);
 	
@@ -290,9 +290,9 @@ snd_pcm_sframes_t snd_pcm_plug_slave_size(snd_pcm_plug_t *plug, snd_pcm_uframes_
 	return frames;
 }
 
-static int snd_pcm_plug_formats(snd_mask_t *mask, int format)
+static int snd_pcm_plug_formats(struct snd_mask *mask, int format)
 {
-	snd_mask_t formats = *mask;
+	struct snd_mask formats = *mask;
 	u64 linfmts = (SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 |
 		       SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_S16_LE |
 		       SNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |
@@ -326,7 +326,7 @@ static int preferred_formats[] = {
 	SNDRV_PCM_FORMAT_U8
 };
 
-int snd_pcm_plug_slave_format(int format, snd_mask_t *format_mask)
+int snd_pcm_plug_slave_format(int format, struct snd_mask *format_mask)
 {
 	if (snd_mask_test(format_mask, format))
 		return format;
@@ -376,15 +376,15 @@ int snd_pcm_plug_slave_format(int format, snd_mask_t *format_mask)
 	}
 }
 
-int snd_pcm_plug_format_plugins(snd_pcm_plug_t *plug,
-				snd_pcm_hw_params_t *params,
-				snd_pcm_hw_params_t *slave_params)
+int snd_pcm_plug_format_plugins(struct snd_pcm_substream *plug,
+				struct snd_pcm_hw_params *params,
+				struct snd_pcm_hw_params *slave_params)
 {
-	snd_pcm_plugin_format_t tmpformat;
-	snd_pcm_plugin_format_t dstformat;
-	snd_pcm_plugin_format_t srcformat;
+	struct snd_pcm_plugin_format tmpformat;
+	struct snd_pcm_plugin_format dstformat;
+	struct snd_pcm_plugin_format srcformat;
 	int src_access, dst_access;
-	snd_pcm_plugin_t *plugin = NULL;
+	struct snd_pcm_plugin *plugin = NULL;
 	int err;
 	int stream = snd_pcm_plug_stream(plug);
 	int slave_interleaved = (params_channels(slave_params) == 1 ||
@@ -462,7 +462,7 @@ int snd_pcm_plug_format_plugins(snd_pcm_plug_t *plug,
 	if (srcformat.channels > dstformat.channels) {
 		int sv = srcformat.channels;
 		int dv = dstformat.channels;
-		route_ttable_entry_t *ttable = kcalloc(dv * sv, sizeof(*ttable), GFP_KERNEL);
+		int *ttable = kcalloc(dv * sv, sizeof(*ttable), GFP_KERNEL);
 		if (ttable == NULL)
 			return -ENOMEM;
 #if 1
@@ -525,7 +525,7 @@ int snd_pcm_plug_format_plugins(snd_pcm_plug_t *plug,
 	if (srcformat.channels < dstformat.channels) {
 		int sv = srcformat.channels;
 		int dv = dstformat.channels;
-		route_ttable_entry_t *ttable = kcalloc(dv * sv, sizeof(*ttable), GFP_KERNEL);
+		int *ttable = kcalloc(dv * sv, sizeof(*ttable), GFP_KERNEL);
 		if (ttable == NULL)
 			return -ENOMEM;
 #if 0
@@ -614,14 +614,14 @@ int snd_pcm_plug_format_plugins(snd_pcm_plug_t *plug,
 	return 0;
 }
 
-snd_pcm_sframes_t snd_pcm_plug_client_channels_buf(snd_pcm_plug_t *plug,
+snd_pcm_sframes_t snd_pcm_plug_client_channels_buf(struct snd_pcm_substream *plug,
 					 char *buf,
 					 snd_pcm_uframes_t count,
-					 snd_pcm_plugin_channel_t **channels)
+					 struct snd_pcm_plugin_channel **channels)
 {
-	snd_pcm_plugin_t *plugin;
-	snd_pcm_plugin_channel_t *v;
-	snd_pcm_plugin_format_t *format;
+	struct snd_pcm_plugin *plugin;
+	struct snd_pcm_plugin_channel *v;
+	struct snd_pcm_plugin_format *format;
 	int width, nchannels, channel;
 	int stream = snd_pcm_plug_stream(plug);
 
@@ -650,10 +650,10 @@ snd_pcm_sframes_t snd_pcm_plug_client_channels_buf(snd_pcm_plug_t *plug,
 	return count;
 }
 
-static int snd_pcm_plug_playback_channels_mask(snd_pcm_plug_t *plug,
+static int snd_pcm_plug_playback_channels_mask(struct snd_pcm_substream *plug,
 					       unsigned long *client_vmask)
 {
-	snd_pcm_plugin_t *plugin = snd_pcm_plug_last(plug);
+	struct snd_pcm_plugin *plugin = snd_pcm_plug_last(plug);
 	if (plugin == NULL) {
 		return 0;
 	} else {
@@ -678,10 +678,10 @@ static int snd_pcm_plug_playback_channels_mask(snd_pcm_plug_t *plug,
 	}
 }
 
-static int snd_pcm_plug_playback_disable_useless_channels(snd_pcm_plug_t *plug,
-							  snd_pcm_plugin_channel_t *src_channels)
+static int snd_pcm_plug_playback_disable_useless_channels(struct snd_pcm_substream *plug,
+							  struct snd_pcm_plugin_channel *src_channels)
 {
-	snd_pcm_plugin_t *plugin = snd_pcm_plug_first(plug);
+	struct snd_pcm_plugin *plugin = snd_pcm_plug_first(plug);
 	unsigned int nchannels = plugin->src_format.channels;
 	DECLARE_BITMAP(bs, nchannels);
 	unsigned long *srcmask = bs;
@@ -703,11 +703,11 @@ static int snd_pcm_plug_playback_disable_useless_channels(snd_pcm_plug_t *plug,
 	return 0;
 }
 
-static int snd_pcm_plug_capture_disable_useless_channels(snd_pcm_plug_t *plug,
-							 snd_pcm_plugin_channel_t *src_channels,
-							 snd_pcm_plugin_channel_t *client_channels)
+static int snd_pcm_plug_capture_disable_useless_channels(struct snd_pcm_substream *plug,
+							 struct snd_pcm_plugin_channel *src_channels,
+							 struct snd_pcm_plugin_channel *client_channels)
 {
-	snd_pcm_plugin_t *plugin = snd_pcm_plug_last(plug);
+	struct snd_pcm_plugin *plugin = snd_pcm_plug_last(plug);
 	unsigned int nchannels = plugin->dst_format.channels;
 	DECLARE_BITMAP(bs, nchannels);
 	unsigned long *dstmask = bs;
@@ -736,10 +736,10 @@ static int snd_pcm_plug_capture_disable_useless_channels(snd_pcm_plug_t *plug,
 	return 0;
 }
 
-snd_pcm_sframes_t snd_pcm_plug_write_transfer(snd_pcm_plug_t *plug, snd_pcm_plugin_channel_t *src_channels, snd_pcm_uframes_t size)
+snd_pcm_sframes_t snd_pcm_plug_write_transfer(struct snd_pcm_substream *plug, struct snd_pcm_plugin_channel *src_channels, snd_pcm_uframes_t size)
 {
-	snd_pcm_plugin_t *plugin, *next;
-	snd_pcm_plugin_channel_t *dst_channels;
+	struct snd_pcm_plugin *plugin, *next;
+	struct snd_pcm_plugin_channel *dst_channels;
 	int err;
 	snd_pcm_sframes_t frames = size;
 
@@ -771,10 +771,10 @@ snd_pcm_sframes_t snd_pcm_plug_write_transfer(snd_pcm_plug_t *plug, snd_pcm_plug
 	return snd_pcm_plug_client_size(plug, frames);
 }
 
-snd_pcm_sframes_t snd_pcm_plug_read_transfer(snd_pcm_plug_t *plug, snd_pcm_plugin_channel_t *dst_channels_final, snd_pcm_uframes_t size)
+snd_pcm_sframes_t snd_pcm_plug_read_transfer(struct snd_pcm_substream *plug, struct snd_pcm_plugin_channel *dst_channels_final, snd_pcm_uframes_t size)
 {
-	snd_pcm_plugin_t *plugin, *next;
-	snd_pcm_plugin_channel_t *src_channels, *dst_channels;
+	struct snd_pcm_plugin *plugin, *next;
+	struct snd_pcm_plugin_channel *src_channels, *dst_channels;
 	snd_pcm_sframes_t frames = size;
 	int err;
 
@@ -806,7 +806,7 @@ snd_pcm_sframes_t snd_pcm_plug_read_transfer(snd_pcm_plug_t *plug, snd_pcm_plugi
 	return frames;
 }
 
-int snd_pcm_area_silence(const snd_pcm_channel_area_t *dst_area, size_t dst_offset,
+int snd_pcm_area_silence(const struct snd_pcm_channel_area *dst_area, size_t dst_offset,
 			 size_t samples, int format)
 {
 	/* FIXME: sub byte resolution and odd dst_offset */
@@ -852,8 +852,8 @@ int snd_pcm_area_silence(const snd_pcm_channel_area_t *dst_area, size_t dst_offs
 	return 0;
 }
 
-int snd_pcm_area_copy(const snd_pcm_channel_area_t *src_area, size_t src_offset,
-		      const snd_pcm_channel_area_t *dst_area, size_t dst_offset,
+int snd_pcm_area_copy(const struct snd_pcm_channel_area *src_area, size_t src_offset,
+		      const struct snd_pcm_channel_area *dst_area, size_t dst_offset,
 		      size_t samples, int format)
 {
 	/* FIXME: sub byte resolution and odd dst_offset */

commit 47eaebfd31610d2a55fbaccd1e7c37690d42ce30
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 10:18:00 2005 +0100

    [ALSA] Use standard bitmap functions
    
    Modules: ALSA<-OSS emulation
    
    Use standard bitmap functions instead of in-house ones.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index fc23373c000d..312ae1f2bfc3 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -37,21 +37,21 @@
 #define snd_pcm_plug_last(plug) ((plug)->runtime->oss.plugin_last)
 
 static int snd_pcm_plugin_src_channels_mask(snd_pcm_plugin_t *plugin,
-					    bitset_t *dst_vmask,
-					    bitset_t **src_vmask)
+					    unsigned long *dst_vmask,
+					    unsigned long **src_vmask)
 {
-	bitset_t *vmask = plugin->src_vmask;
-	bitset_copy(vmask, dst_vmask, plugin->src_format.channels);
+	unsigned long *vmask = plugin->src_vmask;
+	bitmap_copy(vmask, dst_vmask, plugin->src_format.channels);
 	*src_vmask = vmask;
 	return 0;
 }
 
 static int snd_pcm_plugin_dst_channels_mask(snd_pcm_plugin_t *plugin,
-					    bitset_t *src_vmask,
-					    bitset_t **dst_vmask)
+					    unsigned long *src_vmask,
+					    unsigned long **dst_vmask)
 {
-	bitset_t *vmask = plugin->dst_vmask;
-	bitset_copy(vmask, src_vmask, plugin->dst_format.channels);
+	unsigned long *vmask = plugin->dst_vmask;
+	bitmap_copy(vmask, src_vmask, plugin->dst_format.channels);
 	*dst_vmask = vmask;
 	return 0;
 }
@@ -193,12 +193,12 @@ int snd_pcm_plugin_build(snd_pcm_plug_t *plug,
 		snd_pcm_plugin_free(plugin);
 		return -ENOMEM;
 	}
-	plugin->src_vmask = bitset_alloc(src_format->channels);
+	plugin->src_vmask = bitmap_alloc(src_format->channels);
 	if (plugin->src_vmask == NULL) {
 		snd_pcm_plugin_free(plugin);
 		return -ENOMEM;
 	}
-	plugin->dst_vmask = bitset_alloc(dst_format->channels);
+	plugin->dst_vmask = bitmap_alloc(dst_format->channels);
 	if (plugin->dst_vmask == NULL) {
 		snd_pcm_plugin_free(plugin);
 		return -ENOMEM;
@@ -651,18 +651,18 @@ snd_pcm_sframes_t snd_pcm_plug_client_channels_buf(snd_pcm_plug_t *plug,
 }
 
 static int snd_pcm_plug_playback_channels_mask(snd_pcm_plug_t *plug,
-					       bitset_t *client_vmask)
+					       unsigned long *client_vmask)
 {
 	snd_pcm_plugin_t *plugin = snd_pcm_plug_last(plug);
 	if (plugin == NULL) {
 		return 0;
 	} else {
 		int schannels = plugin->dst_format.channels;
-		bitset_t bs[bitset_size(schannels)];
-		bitset_t *srcmask;
-		bitset_t *dstmask = bs;
+		DECLARE_BITMAP(bs, schannels);
+		unsigned long *srcmask;
+		unsigned long *dstmask = bs;
 		int err;
-		bitset_one(dstmask, schannels);
+		bitmap_fill(dstmask, schannels);
 
 		while (1) {
 			err = plugin->src_channels_mask(plugin, dstmask, &srcmask);
@@ -673,7 +673,7 @@ static int snd_pcm_plug_playback_channels_mask(snd_pcm_plug_t *plug,
 				break;
 			plugin = plugin->prev;
 		}
-		bitset_and(client_vmask, dstmask, plugin->src_format.channels);
+		bitmap_and(client_vmask, client_vmask, dstmask, plugin->src_format.channels);
 		return 0;
 	}
 }
@@ -683,21 +683,21 @@ static int snd_pcm_plug_playback_disable_useless_channels(snd_pcm_plug_t *plug,
 {
 	snd_pcm_plugin_t *plugin = snd_pcm_plug_first(plug);
 	unsigned int nchannels = plugin->src_format.channels;
-	bitset_t bs[bitset_size(nchannels)];
-	bitset_t *srcmask = bs;
+	DECLARE_BITMAP(bs, nchannels);
+	unsigned long *srcmask = bs;
 	int err;
 	unsigned int channel;
 	for (channel = 0; channel < nchannels; channel++) {
 		if (src_channels[channel].enabled)
-			bitset_set(srcmask, channel);
+			set_bit(channel, srcmask);
 		else
-			bitset_reset(srcmask, channel);
+			clear_bit(channel, srcmask);
 	}
 	err = snd_pcm_plug_playback_channels_mask(plug, srcmask);
 	if (err < 0)
 		return err;
 	for (channel = 0; channel < nchannels; channel++) {
-		if (!bitset_get(srcmask, channel))
+		if (!test_bit(channel, srcmask))
 			src_channels[channel].enabled = 0;
 	}
 	return 0;
@@ -709,16 +709,16 @@ static int snd_pcm_plug_capture_disable_useless_channels(snd_pcm_plug_t *plug,
 {
 	snd_pcm_plugin_t *plugin = snd_pcm_plug_last(plug);
 	unsigned int nchannels = plugin->dst_format.channels;
-	bitset_t bs[bitset_size(nchannels)];
-	bitset_t *dstmask = bs;
-	bitset_t *srcmask;
+	DECLARE_BITMAP(bs, nchannels);
+	unsigned long *dstmask = bs;
+	unsigned long *srcmask;
 	int err;
 	unsigned int channel;
 	for (channel = 0; channel < nchannels; channel++) {
 		if (client_channels[channel].enabled)
-			bitset_set(dstmask, channel);
+			set_bit(channel, dstmask);
 		else
-			bitset_reset(dstmask, channel);
+			clear_bit(channel, dstmask);
 	}
 	while (plugin) {
 		err = plugin->src_channels_mask(plugin, dstmask, &srcmask);
@@ -730,7 +730,7 @@ static int snd_pcm_plug_capture_disable_useless_channels(snd_pcm_plug_t *plug,
 	plugin = snd_pcm_plug_first(plug);
 	nchannels = plugin->src_format.channels;
 	for (channel = 0; channel < nchannels; channel++) {
-		if (!bitset_get(dstmask, channel))
+		if (!test_bit(channel, dstmask))
 			src_channels[channel].enabled = 0;
 	}
 	return 0;

commit ca2c0966562cfbf9273167a5b60e8fddc24078d6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:20:23 2005 +0200

    [ALSA] Replace with kzalloc() - core stuff
    
    Control Midlevel,ALSA Core,HWDEP Midlevel,PCM Midlevel,RawMidi Midlevel
    Timer Midlevel,ALSA<-OSS emulation
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 6430410c6c04..fc23373c000d 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -171,7 +171,7 @@ int snd_pcm_plugin_build(snd_pcm_plug_t *plug,
 	
 	snd_assert(plug != NULL, return -ENXIO);
 	snd_assert(src_format != NULL && dst_format != NULL, return -ENXIO);
-	plugin = kcalloc(1, sizeof(*plugin) + extra, GFP_KERNEL);
+	plugin = kzalloc(sizeof(*plugin) + extra, GFP_KERNEL);
 	if (plugin == NULL)
 		return -ENOMEM;
 	plugin->name = name;

commit 94f19c9a6da1fd3a5958f1a0b44aa340f2596a5b
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Mar 24 12:01:15 2005 +0100

    [ALSA] kill dead code
    
    ALSA<-OSS emulation
    The Coverity checker found this obviously dead code.
    
    I'm not sure which of the if (plugin == NULL) is correct - this patch
    removes the one that couldn't be true.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
index 6bb31009f0b4..6430410c6c04 100644
--- a/sound/core/oss/pcm_plugin.c
+++ b/sound/core/oss/pcm_plugin.c
@@ -663,10 +663,7 @@ static int snd_pcm_plug_playback_channels_mask(snd_pcm_plug_t *plug,
 		bitset_t *dstmask = bs;
 		int err;
 		bitset_one(dstmask, schannels);
-		if (plugin == NULL) {
-			bitset_and(client_vmask, dstmask, schannels);
-			return 0;
-		}
+
 		while (1) {
 			err = plugin->src_channels_mask(plugin, dstmask, &srcmask);
 			if (err < 0)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/oss/pcm_plugin.c b/sound/core/oss/pcm_plugin.c
new file mode 100644
index 000000000000..6bb31009f0b4
--- /dev/null
+++ b/sound/core/oss/pcm_plugin.c
@@ -0,0 +1,921 @@
+/*
+ *  PCM Plug-In shared (kernel/library) code
+ *  Copyright (c) 1999 by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) 2000 by Abramo Bagnara <abramo@alsa-project.org>
+ *
+ *
+ *   This library is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU Library General Public License as
+ *   published by the Free Software Foundation; either version 2 of
+ *   the License, or (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU Library General Public License for more details.
+ *
+ *   You should have received a copy of the GNU Library General Public
+ *   License along with this library; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+  
+#if 0
+#define PLUGIN_DEBUG
+#endif
+
+#include <sound/driver.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/vmalloc.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include "pcm_plugin.h"
+
+#define snd_pcm_plug_first(plug) ((plug)->runtime->oss.plugin_first)
+#define snd_pcm_plug_last(plug) ((plug)->runtime->oss.plugin_last)
+
+static int snd_pcm_plugin_src_channels_mask(snd_pcm_plugin_t *plugin,
+					    bitset_t *dst_vmask,
+					    bitset_t **src_vmask)
+{
+	bitset_t *vmask = plugin->src_vmask;
+	bitset_copy(vmask, dst_vmask, plugin->src_format.channels);
+	*src_vmask = vmask;
+	return 0;
+}
+
+static int snd_pcm_plugin_dst_channels_mask(snd_pcm_plugin_t *plugin,
+					    bitset_t *src_vmask,
+					    bitset_t **dst_vmask)
+{
+	bitset_t *vmask = plugin->dst_vmask;
+	bitset_copy(vmask, src_vmask, plugin->dst_format.channels);
+	*dst_vmask = vmask;
+	return 0;
+}
+
+/*
+ *  because some cards might have rates "very close", we ignore
+ *  all "resampling" requests within +-5%
+ */
+static int rate_match(unsigned int src_rate, unsigned int dst_rate)
+{
+	unsigned int low = (src_rate * 95) / 100;
+	unsigned int high = (src_rate * 105) / 100;
+	return dst_rate >= low && dst_rate <= high;
+}
+
+static int snd_pcm_plugin_alloc(snd_pcm_plugin_t *plugin, snd_pcm_uframes_t frames)
+{
+	snd_pcm_plugin_format_t *format;
+	ssize_t width;
+	size_t size;
+	unsigned int channel;
+	snd_pcm_plugin_channel_t *c;
+
+	if (plugin->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		format = &plugin->src_format;
+	} else {
+		format = &plugin->dst_format;
+	}
+	if ((width = snd_pcm_format_physical_width(format->format)) < 0)
+		return width;
+	size = frames * format->channels * width;
+	snd_assert((size % 8) == 0, return -ENXIO);
+	size /= 8;
+	if (plugin->buf_frames < frames) {
+		vfree(plugin->buf);
+		plugin->buf = vmalloc(size);
+		plugin->buf_frames = frames;
+	}
+	if (!plugin->buf) {
+		plugin->buf_frames = 0;
+		return -ENOMEM;
+	}
+	c = plugin->buf_channels;
+	if (plugin->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) {
+		for (channel = 0; channel < format->channels; channel++, c++) {
+			c->frames = frames;
+			c->enabled = 1;
+			c->wanted = 0;
+			c->area.addr = plugin->buf;
+			c->area.first = channel * width;
+			c->area.step = format->channels * width;
+		}
+	} else if (plugin->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED) {
+		snd_assert((size % format->channels) == 0,);
+		size /= format->channels;
+		for (channel = 0; channel < format->channels; channel++, c++) {
+			c->frames = frames;
+			c->enabled = 1;
+			c->wanted = 0;
+			c->area.addr = plugin->buf + (channel * size);
+			c->area.first = 0;
+			c->area.step = width;
+		}
+	} else
+		return -EINVAL;
+	return 0;
+}
+
+int snd_pcm_plug_alloc(snd_pcm_plug_t *plug, snd_pcm_uframes_t frames)
+{
+	int err;
+	snd_assert(snd_pcm_plug_first(plug) != NULL, return -ENXIO);
+	if (snd_pcm_plug_stream(plug) == SNDRV_PCM_STREAM_PLAYBACK) {
+		snd_pcm_plugin_t *plugin = snd_pcm_plug_first(plug);
+		while (plugin->next) {
+			if (plugin->dst_frames)
+				frames = plugin->dst_frames(plugin, frames);
+			snd_assert(frames > 0, return -ENXIO);
+			plugin = plugin->next;
+			err = snd_pcm_plugin_alloc(plugin, frames);
+			if (err < 0)
+				return err;
+		}
+	} else {
+		snd_pcm_plugin_t *plugin = snd_pcm_plug_last(plug);
+		while (plugin->prev) {
+			if (plugin->src_frames)
+				frames = plugin->src_frames(plugin, frames);
+			snd_assert(frames > 0, return -ENXIO);
+			plugin = plugin->prev;
+			err = snd_pcm_plugin_alloc(plugin, frames);
+			if (err < 0)
+				return err;
+		}
+	}
+	return 0;
+}
+
+
+snd_pcm_sframes_t snd_pcm_plugin_client_channels(snd_pcm_plugin_t *plugin,
+				       snd_pcm_uframes_t frames,
+				       snd_pcm_plugin_channel_t **channels)
+{
+	*channels = plugin->buf_channels;
+	return frames;
+}
+
+int snd_pcm_plugin_build(snd_pcm_plug_t *plug,
+			 const char *name,
+			 snd_pcm_plugin_format_t *src_format,
+			 snd_pcm_plugin_format_t *dst_format,
+			 size_t extra,
+			 snd_pcm_plugin_t **ret)
+{
+	snd_pcm_plugin_t *plugin;
+	unsigned int channels;
+	
+	snd_assert(plug != NULL, return -ENXIO);
+	snd_assert(src_format != NULL && dst_format != NULL, return -ENXIO);
+	plugin = kcalloc(1, sizeof(*plugin) + extra, GFP_KERNEL);
+	if (plugin == NULL)
+		return -ENOMEM;
+	plugin->name = name;
+	plugin->plug = plug;
+	plugin->stream = snd_pcm_plug_stream(plug);
+	plugin->access = SNDRV_PCM_ACCESS_RW_INTERLEAVED;
+	plugin->src_format = *src_format;
+	plugin->src_width = snd_pcm_format_physical_width(src_format->format);
+	snd_assert(plugin->src_width > 0, );
+	plugin->dst_format = *dst_format;
+	plugin->dst_width = snd_pcm_format_physical_width(dst_format->format);
+	snd_assert(plugin->dst_width > 0, );
+	if (plugin->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		channels = src_format->channels;
+	else
+		channels = dst_format->channels;
+	plugin->buf_channels = kcalloc(channels, sizeof(*plugin->buf_channels), GFP_KERNEL);
+	if (plugin->buf_channels == NULL) {
+		snd_pcm_plugin_free(plugin);
+		return -ENOMEM;
+	}
+	plugin->src_vmask = bitset_alloc(src_format->channels);
+	if (plugin->src_vmask == NULL) {
+		snd_pcm_plugin_free(plugin);
+		return -ENOMEM;
+	}
+	plugin->dst_vmask = bitset_alloc(dst_format->channels);
+	if (plugin->dst_vmask == NULL) {
+		snd_pcm_plugin_free(plugin);
+		return -ENOMEM;
+	}
+	plugin->client_channels = snd_pcm_plugin_client_channels;
+	plugin->src_channels_mask = snd_pcm_plugin_src_channels_mask;
+	plugin->dst_channels_mask = snd_pcm_plugin_dst_channels_mask;
+	*ret = plugin;
+	return 0;
+}
+
+int snd_pcm_plugin_free(snd_pcm_plugin_t *plugin)
+{
+	if (! plugin)
+		return 0;
+	if (plugin->private_free)
+		plugin->private_free(plugin);
+	kfree(plugin->buf_channels);
+	vfree(plugin->buf);
+	kfree(plugin->src_vmask);
+	kfree(plugin->dst_vmask);
+	kfree(plugin);
+	return 0;
+}
+
+snd_pcm_sframes_t snd_pcm_plug_client_size(snd_pcm_plug_t *plug, snd_pcm_uframes_t drv_frames)
+{
+	snd_pcm_plugin_t *plugin, *plugin_prev, *plugin_next;
+	int stream = snd_pcm_plug_stream(plug);
+
+	snd_assert(plug != NULL, return -ENXIO);
+	if (drv_frames == 0)
+		return 0;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		plugin = snd_pcm_plug_last(plug);
+		while (plugin && drv_frames > 0) {
+			plugin_prev = plugin->prev;
+			if (plugin->src_frames)
+				drv_frames = plugin->src_frames(plugin, drv_frames);
+			plugin = plugin_prev;
+		}
+	} else if (stream == SNDRV_PCM_STREAM_CAPTURE) {
+		plugin = snd_pcm_plug_first(plug);
+		while (plugin && drv_frames > 0) {
+			plugin_next = plugin->next;
+			if (plugin->dst_frames)
+				drv_frames = plugin->dst_frames(plugin, drv_frames);
+			plugin = plugin_next;
+		}
+	} else
+		snd_BUG();
+	return drv_frames;
+}
+
+snd_pcm_sframes_t snd_pcm_plug_slave_size(snd_pcm_plug_t *plug, snd_pcm_uframes_t clt_frames)
+{
+	snd_pcm_plugin_t *plugin, *plugin_prev, *plugin_next;
+	snd_pcm_sframes_t frames;
+	int stream = snd_pcm_plug_stream(plug);
+	
+	snd_assert(plug != NULL, return -ENXIO);
+	if (clt_frames == 0)
+		return 0;
+	frames = clt_frames;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		plugin = snd_pcm_plug_first(plug);
+		while (plugin && frames > 0) {
+			plugin_next = plugin->next;
+			if (plugin->dst_frames) {
+				frames = plugin->dst_frames(plugin, frames);
+				if (frames < 0)
+					return frames;
+			}
+			plugin = plugin_next;
+		}
+	} else if (stream == SNDRV_PCM_STREAM_CAPTURE) {
+		plugin = snd_pcm_plug_last(plug);
+		while (plugin) {
+			plugin_prev = plugin->prev;
+			if (plugin->src_frames) {
+				frames = plugin->src_frames(plugin, frames);
+				if (frames < 0)
+					return frames;
+			}
+			plugin = plugin_prev;
+		}
+	} else
+		snd_BUG();
+	return frames;
+}
+
+static int snd_pcm_plug_formats(snd_mask_t *mask, int format)
+{
+	snd_mask_t formats = *mask;
+	u64 linfmts = (SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 |
+		       SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_S16_LE |
+		       SNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |
+		       SNDRV_PCM_FMTBIT_U24_LE | SNDRV_PCM_FMTBIT_S24_LE |
+		       SNDRV_PCM_FMTBIT_U24_BE | SNDRV_PCM_FMTBIT_S24_BE |
+		       SNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_S32_LE |
+		       SNDRV_PCM_FMTBIT_U32_BE | SNDRV_PCM_FMTBIT_S32_BE);
+	snd_mask_set(&formats, SNDRV_PCM_FORMAT_MU_LAW);
+	
+	if (formats.bits[0] & (u32)linfmts)
+		formats.bits[0] |= (u32)linfmts;
+	if (formats.bits[1] & (u32)(linfmts >> 32))
+		formats.bits[1] |= (u32)(linfmts >> 32);
+	return snd_mask_test(&formats, format);
+}
+
+static int preferred_formats[] = {
+	SNDRV_PCM_FORMAT_S16_LE,
+	SNDRV_PCM_FORMAT_S16_BE,
+	SNDRV_PCM_FORMAT_U16_LE,
+	SNDRV_PCM_FORMAT_U16_BE,
+	SNDRV_PCM_FORMAT_S24_LE,
+	SNDRV_PCM_FORMAT_S24_BE,
+	SNDRV_PCM_FORMAT_U24_LE,
+	SNDRV_PCM_FORMAT_U24_BE,
+	SNDRV_PCM_FORMAT_S32_LE,
+	SNDRV_PCM_FORMAT_S32_BE,
+	SNDRV_PCM_FORMAT_U32_LE,
+	SNDRV_PCM_FORMAT_U32_BE,
+	SNDRV_PCM_FORMAT_S8,
+	SNDRV_PCM_FORMAT_U8
+};
+
+int snd_pcm_plug_slave_format(int format, snd_mask_t *format_mask)
+{
+	if (snd_mask_test(format_mask, format))
+		return format;
+	if (! snd_pcm_plug_formats(format_mask, format))
+		return -EINVAL;
+	if (snd_pcm_format_linear(format)) {
+		int width = snd_pcm_format_width(format);
+		int unsignd = snd_pcm_format_unsigned(format);
+		int big = snd_pcm_format_big_endian(format);
+		int format1;
+		int wid, width1=width;
+		int dwidth1 = 8;
+		for (wid = 0; wid < 4; ++wid) {
+			int end, big1 = big;
+			for (end = 0; end < 2; ++end) {
+				int sgn, unsignd1 = unsignd;
+				for (sgn = 0; sgn < 2; ++sgn) {
+					format1 = snd_pcm_build_linear_format(width1, unsignd1, big1);
+					if (format1 >= 0 &&
+					    snd_mask_test(format_mask, format1))
+						goto _found;
+					unsignd1 = !unsignd1;
+				}
+				big1 = !big1;
+			}
+			if (width1 == 32) {
+				dwidth1 = -dwidth1;
+				width1 = width;
+			}
+			width1 += dwidth1;
+		}
+		return -EINVAL;
+	_found:
+		return format1;
+	} else {
+		unsigned int i;
+		switch (format) {
+		case SNDRV_PCM_FORMAT_MU_LAW:
+			for (i = 0; i < ARRAY_SIZE(preferred_formats); ++i) {
+				int format1 = preferred_formats[i];
+				if (snd_mask_test(format_mask, format1))
+					return format1;
+			}
+		default:
+			return -EINVAL;
+		}
+	}
+}
+
+int snd_pcm_plug_format_plugins(snd_pcm_plug_t *plug,
+				snd_pcm_hw_params_t *params,
+				snd_pcm_hw_params_t *slave_params)
+{
+	snd_pcm_plugin_format_t tmpformat;
+	snd_pcm_plugin_format_t dstformat;
+	snd_pcm_plugin_format_t srcformat;
+	int src_access, dst_access;
+	snd_pcm_plugin_t *plugin = NULL;
+	int err;
+	int stream = snd_pcm_plug_stream(plug);
+	int slave_interleaved = (params_channels(slave_params) == 1 ||
+				 params_access(slave_params) == SNDRV_PCM_ACCESS_RW_INTERLEAVED);
+
+	switch (stream) {
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		dstformat.format = params_format(slave_params);
+		dstformat.rate = params_rate(slave_params);
+		dstformat.channels = params_channels(slave_params);
+		srcformat.format = params_format(params);
+		srcformat.rate = params_rate(params);
+		srcformat.channels = params_channels(params);
+		src_access = SNDRV_PCM_ACCESS_RW_INTERLEAVED;
+		dst_access = (slave_interleaved ? SNDRV_PCM_ACCESS_RW_INTERLEAVED :
+						  SNDRV_PCM_ACCESS_RW_NONINTERLEAVED);
+		break;
+	case SNDRV_PCM_STREAM_CAPTURE:
+		dstformat.format = params_format(params);
+		dstformat.rate = params_rate(params);
+		dstformat.channels = params_channels(params);
+		srcformat.format = params_format(slave_params);
+		srcformat.rate = params_rate(slave_params);
+		srcformat.channels = params_channels(slave_params);
+		src_access = (slave_interleaved ? SNDRV_PCM_ACCESS_RW_INTERLEAVED :
+						  SNDRV_PCM_ACCESS_RW_NONINTERLEAVED);
+		dst_access = SNDRV_PCM_ACCESS_RW_INTERLEAVED;
+		break;
+	default:
+		snd_BUG();
+		return -EINVAL;
+	}
+	tmpformat = srcformat;
+		
+	pdprintf("srcformat: format=%i, rate=%i, channels=%i\n", 
+		 srcformat.format,
+		 srcformat.rate,
+		 srcformat.channels);
+	pdprintf("dstformat: format=%i, rate=%i, channels=%i\n", 
+		 dstformat.format,
+		 dstformat.rate,
+		 dstformat.channels);
+
+	/* Format change (linearization) */
+	if ((srcformat.format != dstformat.format ||
+	     !rate_match(srcformat.rate, dstformat.rate) ||
+	     srcformat.channels != dstformat.channels) &&
+	    !snd_pcm_format_linear(srcformat.format)) {
+		if (snd_pcm_format_linear(dstformat.format))
+			tmpformat.format = dstformat.format;
+		else
+			tmpformat.format = SNDRV_PCM_FORMAT_S16;
+		switch (srcformat.format) {
+		case SNDRV_PCM_FORMAT_MU_LAW:
+			err = snd_pcm_plugin_build_mulaw(plug,
+							 &srcformat, &tmpformat,
+							 &plugin);
+			break;
+		default:
+			return -EINVAL;
+		}
+		pdprintf("format change: src=%i, dst=%i returns %i\n", srcformat.format, tmpformat.format, err);
+		if (err < 0)
+			return err;
+		err = snd_pcm_plugin_append(plugin);
+		if (err < 0) {
+			snd_pcm_plugin_free(plugin);
+			return err;
+		}
+		srcformat = tmpformat;
+		src_access = dst_access;
+	}
+
+	/* channels reduction */
+	if (srcformat.channels > dstformat.channels) {
+		int sv = srcformat.channels;
+		int dv = dstformat.channels;
+		route_ttable_entry_t *ttable = kcalloc(dv * sv, sizeof(*ttable), GFP_KERNEL);
+		if (ttable == NULL)
+			return -ENOMEM;
+#if 1
+		if (sv == 2 && dv == 1) {
+			ttable[0] = HALF;
+			ttable[1] = HALF;
+		} else
+#endif
+		{
+			int v;
+			for (v = 0; v < dv; ++v)
+				ttable[v * sv + v] = FULL;
+		}
+		tmpformat.channels = dstformat.channels;
+		if (rate_match(srcformat.rate, dstformat.rate) &&
+		    snd_pcm_format_linear(dstformat.format))
+			tmpformat.format = dstformat.format;
+		err = snd_pcm_plugin_build_route(plug,
+						 &srcformat, &tmpformat,
+						 ttable, &plugin);
+		kfree(ttable);
+		pdprintf("channels reduction: src=%i, dst=%i returns %i\n", srcformat.channels, tmpformat.channels, err);
+		if (err < 0) {
+			snd_pcm_plugin_free(plugin);
+			return err;
+		}
+		err = snd_pcm_plugin_append(plugin);
+		if (err < 0) {
+			snd_pcm_plugin_free(plugin);
+			return err;
+		}
+		srcformat = tmpformat;
+		src_access = dst_access;
+	}
+
+	/* rate resampling */
+	if (!rate_match(srcformat.rate, dstformat.rate)) {
+		tmpformat.rate = dstformat.rate;
+		if (srcformat.channels == dstformat.channels &&
+		    snd_pcm_format_linear(dstformat.format))
+			tmpformat.format = dstformat.format;
+        	err = snd_pcm_plugin_build_rate(plug,
+        					&srcformat, &tmpformat,
+						&plugin);
+		pdprintf("rate down resampling: src=%i, dst=%i returns %i\n", srcformat.rate, tmpformat.rate, err);
+		if (err < 0) {
+			snd_pcm_plugin_free(plugin);
+			return err;
+		}      					    
+		err = snd_pcm_plugin_append(plugin);
+		if (err < 0) {
+			snd_pcm_plugin_free(plugin);
+			return err;
+		}
+		srcformat = tmpformat;
+		src_access = dst_access;
+        }
+
+	/* channels extension  */
+	if (srcformat.channels < dstformat.channels) {
+		int sv = srcformat.channels;
+		int dv = dstformat.channels;
+		route_ttable_entry_t *ttable = kcalloc(dv * sv, sizeof(*ttable), GFP_KERNEL);
+		if (ttable == NULL)
+			return -ENOMEM;
+#if 0
+		{
+			int v;
+			for (v = 0; v < sv; ++v)
+				ttable[v * sv + v] = FULL;
+		}
+#else
+		{
+			/* Playback is spreaded on all channels */
+			int vd, vs;
+			for (vd = 0, vs = 0; vd < dv; ++vd) {
+				ttable[vd * sv + vs] = FULL;
+				vs++;
+				if (vs == sv)
+					vs = 0;
+			}
+		}
+#endif
+		tmpformat.channels = dstformat.channels;
+		if (snd_pcm_format_linear(dstformat.format))
+			tmpformat.format = dstformat.format;
+		err = snd_pcm_plugin_build_route(plug,
+						 &srcformat, &tmpformat,
+						 ttable, &plugin);
+		kfree(ttable);
+		pdprintf("channels extension: src=%i, dst=%i returns %i\n", srcformat.channels, tmpformat.channels, err);
+		if (err < 0) {
+			snd_pcm_plugin_free(plugin);
+			return err;
+		}      					    
+		err = snd_pcm_plugin_append(plugin);
+		if (err < 0) {
+			snd_pcm_plugin_free(plugin);
+			return err;
+		}
+		srcformat = tmpformat;
+		src_access = dst_access;
+	}
+
+	/* format change */
+	if (srcformat.format != dstformat.format) {
+		tmpformat.format = dstformat.format;
+		if (tmpformat.format == SNDRV_PCM_FORMAT_MU_LAW) {
+			err = snd_pcm_plugin_build_mulaw(plug,
+							 &srcformat, &tmpformat,
+							 &plugin);
+		}
+		else if (snd_pcm_format_linear(srcformat.format) &&
+			 snd_pcm_format_linear(tmpformat.format)) {
+			err = snd_pcm_plugin_build_linear(plug,
+							  &srcformat, &tmpformat,
+							  &plugin);
+		}
+		else
+			return -EINVAL;
+		pdprintf("format change: src=%i, dst=%i returns %i\n", srcformat.format, tmpformat.format, err);
+		if (err < 0)
+			return err;
+		err = snd_pcm_plugin_append(plugin);
+		if (err < 0) {
+			snd_pcm_plugin_free(plugin);
+			return err;
+		}
+		srcformat = tmpformat;
+		src_access = dst_access;
+	}
+
+	/* de-interleave */
+	if (src_access != dst_access) {
+		err = snd_pcm_plugin_build_copy(plug,
+						&srcformat,
+						&tmpformat,
+						&plugin);
+		pdprintf("interleave change (copy: returns %i)\n", err);
+		if (err < 0)
+			return err;
+		err = snd_pcm_plugin_append(plugin);
+		if (err < 0) {
+			snd_pcm_plugin_free(plugin);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+snd_pcm_sframes_t snd_pcm_plug_client_channels_buf(snd_pcm_plug_t *plug,
+					 char *buf,
+					 snd_pcm_uframes_t count,
+					 snd_pcm_plugin_channel_t **channels)
+{
+	snd_pcm_plugin_t *plugin;
+	snd_pcm_plugin_channel_t *v;
+	snd_pcm_plugin_format_t *format;
+	int width, nchannels, channel;
+	int stream = snd_pcm_plug_stream(plug);
+
+	snd_assert(buf != NULL, return -ENXIO);
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		plugin = snd_pcm_plug_first(plug);
+		format = &plugin->src_format;
+	} else {
+		plugin = snd_pcm_plug_last(plug);
+		format = &plugin->dst_format;
+	}
+	v = plugin->buf_channels;
+	*channels = v;
+	if ((width = snd_pcm_format_physical_width(format->format)) < 0)
+		return width;
+	nchannels = format->channels;
+	snd_assert(plugin->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED || format->channels <= 1, return -ENXIO);
+	for (channel = 0; channel < nchannels; channel++, v++) {
+		v->frames = count;
+		v->enabled = 1;
+		v->wanted = (stream == SNDRV_PCM_STREAM_CAPTURE);
+		v->area.addr = buf;
+		v->area.first = channel * width;
+		v->area.step = nchannels * width;
+	}
+	return count;
+}
+
+static int snd_pcm_plug_playback_channels_mask(snd_pcm_plug_t *plug,
+					       bitset_t *client_vmask)
+{
+	snd_pcm_plugin_t *plugin = snd_pcm_plug_last(plug);
+	if (plugin == NULL) {
+		return 0;
+	} else {
+		int schannels = plugin->dst_format.channels;
+		bitset_t bs[bitset_size(schannels)];
+		bitset_t *srcmask;
+		bitset_t *dstmask = bs;
+		int err;
+		bitset_one(dstmask, schannels);
+		if (plugin == NULL) {
+			bitset_and(client_vmask, dstmask, schannels);
+			return 0;
+		}
+		while (1) {
+			err = plugin->src_channels_mask(plugin, dstmask, &srcmask);
+			if (err < 0)
+				return err;
+			dstmask = srcmask;
+			if (plugin->prev == NULL)
+				break;
+			plugin = plugin->prev;
+		}
+		bitset_and(client_vmask, dstmask, plugin->src_format.channels);
+		return 0;
+	}
+}
+
+static int snd_pcm_plug_playback_disable_useless_channels(snd_pcm_plug_t *plug,
+							  snd_pcm_plugin_channel_t *src_channels)
+{
+	snd_pcm_plugin_t *plugin = snd_pcm_plug_first(plug);
+	unsigned int nchannels = plugin->src_format.channels;
+	bitset_t bs[bitset_size(nchannels)];
+	bitset_t *srcmask = bs;
+	int err;
+	unsigned int channel;
+	for (channel = 0; channel < nchannels; channel++) {
+		if (src_channels[channel].enabled)
+			bitset_set(srcmask, channel);
+		else
+			bitset_reset(srcmask, channel);
+	}
+	err = snd_pcm_plug_playback_channels_mask(plug, srcmask);
+	if (err < 0)
+		return err;
+	for (channel = 0; channel < nchannels; channel++) {
+		if (!bitset_get(srcmask, channel))
+			src_channels[channel].enabled = 0;
+	}
+	return 0;
+}
+
+static int snd_pcm_plug_capture_disable_useless_channels(snd_pcm_plug_t *plug,
+							 snd_pcm_plugin_channel_t *src_channels,
+							 snd_pcm_plugin_channel_t *client_channels)
+{
+	snd_pcm_plugin_t *plugin = snd_pcm_plug_last(plug);
+	unsigned int nchannels = plugin->dst_format.channels;
+	bitset_t bs[bitset_size(nchannels)];
+	bitset_t *dstmask = bs;
+	bitset_t *srcmask;
+	int err;
+	unsigned int channel;
+	for (channel = 0; channel < nchannels; channel++) {
+		if (client_channels[channel].enabled)
+			bitset_set(dstmask, channel);
+		else
+			bitset_reset(dstmask, channel);
+	}
+	while (plugin) {
+		err = plugin->src_channels_mask(plugin, dstmask, &srcmask);
+		if (err < 0)
+			return err;
+		dstmask = srcmask;
+		plugin = plugin->prev;
+	}
+	plugin = snd_pcm_plug_first(plug);
+	nchannels = plugin->src_format.channels;
+	for (channel = 0; channel < nchannels; channel++) {
+		if (!bitset_get(dstmask, channel))
+			src_channels[channel].enabled = 0;
+	}
+	return 0;
+}
+
+snd_pcm_sframes_t snd_pcm_plug_write_transfer(snd_pcm_plug_t *plug, snd_pcm_plugin_channel_t *src_channels, snd_pcm_uframes_t size)
+{
+	snd_pcm_plugin_t *plugin, *next;
+	snd_pcm_plugin_channel_t *dst_channels;
+	int err;
+	snd_pcm_sframes_t frames = size;
+
+	if ((err = snd_pcm_plug_playback_disable_useless_channels(plug, src_channels)) < 0)
+		return err;
+	
+	plugin = snd_pcm_plug_first(plug);
+	while (plugin && frames > 0) {
+		if ((next = plugin->next) != NULL) {
+			snd_pcm_sframes_t frames1 = frames;
+			if (plugin->dst_frames)
+				frames1 = plugin->dst_frames(plugin, frames);
+			if ((err = next->client_channels(next, frames1, &dst_channels)) < 0) {
+				return err;
+			}
+			if (err != frames1) {
+				frames = err;
+				if (plugin->src_frames)
+					frames = plugin->src_frames(plugin, frames1);
+			}
+		} else
+			dst_channels = NULL;
+		pdprintf("write plugin: %s, %li\n", plugin->name, frames);
+		if ((frames = plugin->transfer(plugin, src_channels, dst_channels, frames)) < 0)
+			return frames;
+		src_channels = dst_channels;
+		plugin = next;
+	}
+	return snd_pcm_plug_client_size(plug, frames);
+}
+
+snd_pcm_sframes_t snd_pcm_plug_read_transfer(snd_pcm_plug_t *plug, snd_pcm_plugin_channel_t *dst_channels_final, snd_pcm_uframes_t size)
+{
+	snd_pcm_plugin_t *plugin, *next;
+	snd_pcm_plugin_channel_t *src_channels, *dst_channels;
+	snd_pcm_sframes_t frames = size;
+	int err;
+
+	frames = snd_pcm_plug_slave_size(plug, frames);
+	if (frames < 0)
+		return frames;
+
+	src_channels = NULL;
+	plugin = snd_pcm_plug_first(plug);
+	while (plugin && frames > 0) {
+		if ((next = plugin->next) != NULL) {
+			if ((err = plugin->client_channels(plugin, frames, &dst_channels)) < 0) {
+				return err;
+			}
+			frames = err;
+			if (!plugin->prev) {
+				if ((err = snd_pcm_plug_capture_disable_useless_channels(plug, dst_channels, dst_channels_final)) < 0)
+					return err;
+			}
+		} else {
+			dst_channels = dst_channels_final;
+		}
+		pdprintf("read plugin: %s, %li\n", plugin->name, frames);
+		if ((frames = plugin->transfer(plugin, src_channels, dst_channels, frames)) < 0)
+			return frames;
+		plugin = next;
+		src_channels = dst_channels;
+	}
+	return frames;
+}
+
+int snd_pcm_area_silence(const snd_pcm_channel_area_t *dst_area, size_t dst_offset,
+			 size_t samples, int format)
+{
+	/* FIXME: sub byte resolution and odd dst_offset */
+	unsigned char *dst;
+	unsigned int dst_step;
+	int width;
+	const unsigned char *silence;
+	if (!dst_area->addr)
+		return 0;
+	dst = dst_area->addr + (dst_area->first + dst_area->step * dst_offset) / 8;
+	width = snd_pcm_format_physical_width(format);
+	if (width <= 0)
+		return -EINVAL;
+	if (dst_area->step == (unsigned int) width && width >= 8)
+		return snd_pcm_format_set_silence(format, dst, samples);
+	silence = snd_pcm_format_silence_64(format);
+	if (! silence)
+		return -EINVAL;
+	dst_step = dst_area->step / 8;
+	if (width == 4) {
+		/* Ima ADPCM */
+		int dstbit = dst_area->first % 8;
+		int dstbit_step = dst_area->step % 8;
+		while (samples-- > 0) {
+			if (dstbit)
+				*dst &= 0xf0;
+			else
+				*dst &= 0x0f;
+			dst += dst_step;
+			dstbit += dstbit_step;
+			if (dstbit == 8) {
+				dst++;
+				dstbit = 0;
+			}
+		}
+	} else {
+		width /= 8;
+		while (samples-- > 0) {
+			memcpy(dst, silence, width);
+			dst += dst_step;
+		}
+	}
+	return 0;
+}
+
+int snd_pcm_area_copy(const snd_pcm_channel_area_t *src_area, size_t src_offset,
+		      const snd_pcm_channel_area_t *dst_area, size_t dst_offset,
+		      size_t samples, int format)
+{
+	/* FIXME: sub byte resolution and odd dst_offset */
+	char *src, *dst;
+	int width;
+	int src_step, dst_step;
+	src = src_area->addr + (src_area->first + src_area->step * src_offset) / 8;
+	if (!src_area->addr)
+		return snd_pcm_area_silence(dst_area, dst_offset, samples, format);
+	dst = dst_area->addr + (dst_area->first + dst_area->step * dst_offset) / 8;
+	if (!dst_area->addr)
+		return 0;
+	width = snd_pcm_format_physical_width(format);
+	if (width <= 0)
+		return -EINVAL;
+	if (src_area->step == (unsigned int) width &&
+	    dst_area->step == (unsigned int) width && width >= 8) {
+		size_t bytes = samples * width / 8;
+		memcpy(dst, src, bytes);
+		return 0;
+	}
+	src_step = src_area->step / 8;
+	dst_step = dst_area->step / 8;
+	if (width == 4) {
+		/* Ima ADPCM */
+		int srcbit = src_area->first % 8;
+		int srcbit_step = src_area->step % 8;
+		int dstbit = dst_area->first % 8;
+		int dstbit_step = dst_area->step % 8;
+		while (samples-- > 0) {
+			unsigned char srcval;
+			if (srcbit)
+				srcval = *src & 0x0f;
+			else
+				srcval = (*src & 0xf0) >> 4;
+			if (dstbit)
+				*dst = (*dst & 0xf0) | srcval;
+			else
+				*dst = (*dst & 0x0f) | (srcval << 4);
+			src += src_step;
+			srcbit += srcbit_step;
+			if (srcbit == 8) {
+				src++;
+				srcbit = 0;
+			}
+			dst += dst_step;
+			dstbit += dstbit_step;
+			if (dstbit == 8) {
+				dst++;
+				dstbit = 0;
+			}
+		}
+	} else {
+		width /= 8;
+		while (samples-- > 0) {
+			memcpy(dst, src, width);
+			src += src_step;
+			dst += dst_step;
+		}
+	}
+	return 0;
+}
