commit 9478bd43a2eb5c72b599368513d10880b296d65f
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Feb 11 13:39:10 2020 -0600

    ALSA: core: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertenly introduced[3] to the codebase from now on.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Link: https://lore.kernel.org/r/20200211193910.GA4596@embeddedor
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/rate.c b/sound/core/oss/rate.c
index 7cd09cef6961..d381f4c967c9 100644
--- a/sound/core/oss/rate.c
+++ b/sound/core/oss/rate.c
@@ -47,7 +47,7 @@ struct rate_priv {
 	unsigned int pos;
 	rate_f func;
 	snd_pcm_sframes_t old_src_frames, old_dst_frames;
-	struct rate_channel channels[0];
+	struct rate_channel channels[];
 };
 
 static void rate_init(struct snd_pcm_plugin *plugin)

commit 92bfa664ae133d13a3496f71f5c7c7f4d4827a88
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu May 23 15:29:17 2019 -0500

    ALSA: pcm: oss: Use struct_size() helper
    
    Make use of the struct_size() helper instead of an open-coded version
    in order to avoid any potential type mistakes, in particular in the
    context in which this code is being used.
    
    So, replace the following form:
    
    sizeof(struct rate_priv) + src_format->channels * sizeof(struct rate_channel)
    
    with:
    
    struct_size(data, channels, src_format->channels)
    
    This code was detected with the help of Coccinelle.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/rate.c b/sound/core/oss/rate.c
index 2fa9299a440d..7cd09cef6961 100644
--- a/sound/core/oss/rate.c
+++ b/sound/core/oss/rate.c
@@ -323,8 +323,8 @@ int snd_pcm_plugin_build_rate(struct snd_pcm_substream *plug,
 
 	err = snd_pcm_plugin_build(plug, "rate conversion",
 				   src_format, dst_format,
-				   sizeof(struct rate_priv) +
-				   src_format->channels * sizeof(struct rate_channel),
+				   struct_size(data, channels,
+					       src_format->channels),
 				   &plugin);
 	if (err < 0)
 		return err;

commit 5370d96f85962769ea3df3a81cc885f257c51589
Author: Steve Chen <schen@mvista.com>
Date:   Sat Feb 21 08:05:04 2009 -0600

    ALSA: fix excessive background noise introduced by OSS emulation rate shrink
    
    Incorrect variable was used to get the next sample which caused S2
    to be stuck with the same value resulting in loud background noise.
    
    Signed-off-by: Steve Chen <schen at mvista.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/rate.c b/sound/core/oss/rate.c
index a466443c4a26..2fa9299a440d 100644
--- a/sound/core/oss/rate.c
+++ b/sound/core/oss/rate.c
@@ -157,7 +157,7 @@ static void resample_shrink(struct snd_pcm_plugin *plugin,
 		while (dst_frames1 > 0) {
 			S1 = S2;
 			if (src_frames1-- > 0) {
-				S1 = *src;
+				S2 = *src;
 				src += src_step;
 			}
 			if (pos & ~R_MASK) {

commit 7eaa943c8ed8e91e05d0f5d0dc7a18e3319b45cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:09:09 2008 +0200

    ALSA: Kill snd_assert() in sound/core/*
    
    Kill snd_assert() in sound/core/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/oss/rate.c b/sound/core/oss/rate.c
index 14dfb3175d84..a466443c4a26 100644
--- a/sound/core/oss/rate.c
+++ b/sound/core/oss/rate.c
@@ -185,7 +185,8 @@ static snd_pcm_sframes_t rate_src_frames(struct snd_pcm_plugin *plugin, snd_pcm_
 	struct rate_priv *data;
 	snd_pcm_sframes_t res;
 
-	snd_assert(plugin != NULL, return -ENXIO);
+	if (snd_BUG_ON(!plugin))
+		return -ENXIO;
 	if (frames == 0)
 		return 0;
 	data = (struct rate_priv *)plugin->extra_data;
@@ -217,7 +218,8 @@ static snd_pcm_sframes_t rate_dst_frames(struct snd_pcm_plugin *plugin, snd_pcm_
 	struct rate_priv *data;
 	snd_pcm_sframes_t res;
 
-	snd_assert(plugin != NULL, return -ENXIO);
+	if (snd_BUG_ON(!plugin))
+		return -ENXIO;
 	if (frames == 0)
 		return 0;
 	data = (struct rate_priv *)plugin->extra_data;
@@ -252,19 +254,20 @@ static snd_pcm_sframes_t rate_transfer(struct snd_pcm_plugin *plugin,
 	snd_pcm_uframes_t dst_frames;
 	struct rate_priv *data;
 
-	snd_assert(plugin != NULL && src_channels != NULL && dst_channels != NULL, return -ENXIO);
+	if (snd_BUG_ON(!plugin || !src_channels || !dst_channels))
+		return -ENXIO;
 	if (frames == 0)
 		return 0;
 #ifdef CONFIG_SND_DEBUG
 	{
 		unsigned int channel;
 		for (channel = 0; channel < plugin->src_format.channels; channel++) {
-			snd_assert(src_channels[channel].area.first % 8 == 0 &&
-				   src_channels[channel].area.step % 8 == 0,
-				   return -ENXIO);
-			snd_assert(dst_channels[channel].area.first % 8 == 0 &&
-				   dst_channels[channel].area.step % 8 == 0,
-				   return -ENXIO);
+			if (snd_BUG_ON(src_channels[channel].area.first % 8 ||
+				       src_channels[channel].area.step % 8))
+				return -ENXIO;
+			if (snd_BUG_ON(dst_channels[channel].area.first % 8 ||
+				       dst_channels[channel].area.step % 8))
+				return -ENXIO;
 		}
 	}
 #endif
@@ -281,7 +284,8 @@ static int rate_action(struct snd_pcm_plugin *plugin,
 		       enum snd_pcm_plugin_action action,
 		       unsigned long udata)
 {
-	snd_assert(plugin != NULL, return -ENXIO);
+	if (snd_BUG_ON(!plugin))
+		return -ENXIO;
 	switch (action) {
 	case INIT:
 	case PREPARE:
@@ -302,14 +306,20 @@ int snd_pcm_plugin_build_rate(struct snd_pcm_substream *plug,
 	struct rate_priv *data;
 	struct snd_pcm_plugin *plugin;
 
-	snd_assert(r_plugin != NULL, return -ENXIO);
+	if (snd_BUG_ON(!r_plugin))
+		return -ENXIO;
 	*r_plugin = NULL;
 
-	snd_assert(src_format->channels == dst_format->channels, return -ENXIO);
-	snd_assert(src_format->channels > 0, return -ENXIO);
-	snd_assert(src_format->format == SNDRV_PCM_FORMAT_S16, return -ENXIO);
-	snd_assert(dst_format->format == SNDRV_PCM_FORMAT_S16, return -ENXIO);
-	snd_assert(src_format->rate != dst_format->rate, return -ENXIO);
+	if (snd_BUG_ON(src_format->channels != dst_format->channels))
+		return -ENXIO;
+	if (snd_BUG_ON(src_format->channels <= 0))
+		return -ENXIO;
+	if (snd_BUG_ON(src_format->format != SNDRV_PCM_FORMAT_S16))
+		return -ENXIO;
+	if (snd_BUG_ON(dst_format->format != SNDRV_PCM_FORMAT_S16))
+		return -ENXIO;
+	if (snd_BUG_ON(src_format->rate == dst_format->rate))
+		return -ENXIO;
 
 	err = snd_pcm_plugin_build(plug, "rate conversion",
 				   src_format, dst_format,

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/oss/rate.c b/sound/core/oss/rate.c
index 9eb267913c38..14dfb3175d84 100644
--- a/sound/core/oss/rate.c
+++ b/sound/core/oss/rate.c
@@ -19,7 +19,6 @@
  *
  */
   
-#include <sound/driver.h>
 #include <linux/time.h>
 #include <sound/core.h>
 #include <sound/pcm.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/oss/rate.c b/sound/core/oss/rate.c
index 66f1dbe492cf..9eb267913c38 100644
--- a/sound/core/oss/rate.c
+++ b/sound/core/oss/rate.c
@@ -1,6 +1,6 @@
 /*
  *  Rate conversion Plug-In
- *  Copyright (c) 1999 by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) 1999 by Jaroslav Kysela <perex@perex.cz>
  *
  *
  *   This library is free software; you can redistribute it and/or modify

commit 887f9f0253ba4a52f38810f3056cdf040a6157b3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 8 15:20:48 2007 +0200

    [ALSA] Remove ifdefs from OSS PCM emulation codes
    
    Fix Makefile to compile files conditionally to CONFIG_SND_PCM_OSS_PLUGINS,
    and remove unneeded ifdefs in these files.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/oss/rate.c b/sound/core/oss/rate.c
index 18d8a0f4e816..66f1dbe492cf 100644
--- a/sound/core/oss/rate.c
+++ b/sound/core/oss/rate.c
@@ -20,9 +20,6 @@
  */
   
 #include <sound/driver.h>
-
-#ifdef CONFIG_SND_PCM_OSS_PLUGINS
-
 #include <linux/time.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -340,5 +337,3 @@ int snd_pcm_plugin_build_rate(struct snd_pcm_substream *plug,
 	*r_plugin = plugin;
 	return 0;
 }
-
-#endif

commit 0534ab4279bd25e2d0a888af07466446dac05d74
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 13 12:09:12 2006 +0100

    [ALSA] Clean up pcm-oss plugins
    
    Modules: ALSA<-OSS emulation
    
    Clean up pcm-oss plugin codes.
    Removed dead codes, and simplified route/rate plugins.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/rate.c b/sound/core/oss/rate.c
index c4b75bff0ee5..18d8a0f4e816 100644
--- a/sound/core/oss/rate.c
+++ b/sound/core/oss/rate.c
@@ -50,7 +50,6 @@ struct rate_priv {
 	unsigned int pitch;
 	unsigned int pos;
 	rate_f func;
-	int get, put;
 	snd_pcm_sframes_t old_src_frames, old_dst_frames;
 	struct rate_channel channels[0];
 };
@@ -74,21 +73,12 @@ static void resample_expand(struct snd_pcm_plugin *plugin,
 	unsigned int pos = 0;
 	signed int val;
 	signed short S1, S2;
-	char *src, *dst;
+	signed short *src, *dst;
 	unsigned int channel;
 	int src_step, dst_step;
 	int src_frames1, dst_frames1;
 	struct rate_priv *data = (struct rate_priv *)plugin->extra_data;
 	struct rate_channel *rchannels = data->channels;
-
-#define GET_S16_LABELS
-#define PUT_S16_LABELS
-#include "plugin_ops.h"
-#undef GET_S16_LABELS
-#undef PUT_S16_LABELS
-	void *get = get_s16_labels[data->get];
-	void *put = put_s16_labels[data->put];
-	signed short sample = 0;
 	
 	for (channel = 0; channel < plugin->src_format.channels; channel++) {
 		pos = data->pos;
@@ -101,10 +91,12 @@ static void resample_expand(struct snd_pcm_plugin *plugin,
 			continue;
 		}
 		dst_channels[channel].enabled = 1;
-		src = (char *)src_channels[channel].area.addr + src_channels[channel].area.first / 8;
-		dst = (char *)dst_channels[channel].area.addr + dst_channels[channel].area.first / 8;
-		src_step = src_channels[channel].area.step / 8;
-		dst_step = dst_channels[channel].area.step / 8;
+		src = (signed short *)src_channels[channel].area.addr +
+			src_channels[channel].area.first / 8 / 2;
+		dst = (signed short *)dst_channels[channel].area.addr +
+			dst_channels[channel].area.first / 8 / 2;
+		src_step = src_channels[channel].area.step / 8 / 2;
+		dst_step = dst_channels[channel].area.step / 8 / 2;
 		src_frames1 = src_frames;
 		dst_frames1 = dst_frames;
 		while (dst_frames1-- > 0) {
@@ -112,12 +104,7 @@ static void resample_expand(struct snd_pcm_plugin *plugin,
 				pos &= R_MASK;
 				S1 = S2;
 				if (src_frames1-- > 0) {
-					goto *get;
-#define GET_S16_END after_get
-#include "plugin_ops.h"
-#undef GET_S16_END
-				after_get:
-					S2 = sample;
+					S2 = *src;
 					src += src_step;
 				}
 			}
@@ -126,12 +113,7 @@ static void resample_expand(struct snd_pcm_plugin *plugin,
 				val = -32768;
 			else if (val > 32767)
 				val = 32767;
-			sample = val;
-			goto *put;
-#define PUT_S16_END after_put
-#include "plugin_ops.h"
-#undef PUT_S16_END
-		after_put:
+			*dst = val;
 			dst += dst_step;
 			pos += data->pitch;
 		}
@@ -150,21 +132,12 @@ static void resample_shrink(struct snd_pcm_plugin *plugin,
 	unsigned int pos = 0;
 	signed int val;
 	signed short S1, S2;
-	char *src, *dst;
+	signed short *src, *dst;
 	unsigned int channel;
 	int src_step, dst_step;
 	int src_frames1, dst_frames1;
 	struct rate_priv *data = (struct rate_priv *)plugin->extra_data;
 	struct rate_channel *rchannels = data->channels;
-	
-#define GET_S16_LABELS
-#define PUT_S16_LABELS
-#include "plugin_ops.h"
-#undef GET_S16_LABELS
-#undef PUT_S16_LABELS
-	void *get = get_s16_labels[data->get];
-	void *put = put_s16_labels[data->put];
-	signed short sample = 0;
 
 	for (channel = 0; channel < plugin->src_format.channels; ++channel) {
 		pos = data->pos;
@@ -177,21 +150,18 @@ static void resample_shrink(struct snd_pcm_plugin *plugin,
 			continue;
 		}
 		dst_channels[channel].enabled = 1;
-		src = (char *)src_channels[channel].area.addr + src_channels[channel].area.first / 8;
-		dst = (char *)dst_channels[channel].area.addr + dst_channels[channel].area.first / 8;
-		src_step = src_channels[channel].area.step / 8;
-		dst_step = dst_channels[channel].area.step / 8;
+		src = (signed short *)src_channels[channel].area.addr +
+			src_channels[channel].area.first / 8 / 2;
+		dst = (signed short *)dst_channels[channel].area.addr +
+			dst_channels[channel].area.first / 8 / 2;
+		src_step = src_channels[channel].area.step / 8 / 2;
+		dst_step = dst_channels[channel].area.step / 8 / 2;
 		src_frames1 = src_frames;
 		dst_frames1 = dst_frames;
 		while (dst_frames1 > 0) {
 			S1 = S2;
 			if (src_frames1-- > 0) {
-				goto *get;
-#define GET_S16_END after_get
-#include "plugin_ops.h"
-#undef GET_S16_END
-			after_get:
-				S2 = sample;
+				S1 = *src;
 				src += src_step;
 			}
 			if (pos & ~R_MASK) {
@@ -201,12 +171,7 @@ static void resample_shrink(struct snd_pcm_plugin *plugin,
 					val = -32768;
 				else if (val > 32767)
 					val = 32767;
-				sample = val;
-				goto *put;
-#define PUT_S16_END after_put
-#include "plugin_ops.h"
-#undef PUT_S16_END
-			after_put:
+				*dst = val;
 				dst += dst_step;
 				dst_frames1--;
 			}
@@ -346,8 +311,8 @@ int snd_pcm_plugin_build_rate(struct snd_pcm_substream *plug,
 
 	snd_assert(src_format->channels == dst_format->channels, return -ENXIO);
 	snd_assert(src_format->channels > 0, return -ENXIO);
-	snd_assert(snd_pcm_format_linear(src_format->format) != 0, return -ENXIO);
-	snd_assert(snd_pcm_format_linear(dst_format->format) != 0, return -ENXIO);
+	snd_assert(src_format->format == SNDRV_PCM_FORMAT_S16, return -ENXIO);
+	snd_assert(dst_format->format == SNDRV_PCM_FORMAT_S16, return -ENXIO);
 	snd_assert(src_format->rate != dst_format->rate, return -ENXIO);
 
 	err = snd_pcm_plugin_build(plug, "rate conversion",
@@ -358,11 +323,6 @@ int snd_pcm_plugin_build_rate(struct snd_pcm_substream *plug,
 	if (err < 0)
 		return err;
 	data = (struct rate_priv *)plugin->extra_data;
-	data->get = getput_index(src_format->format);
-	snd_assert(data->get >= 0 && data->get < 4*2*2, return -EINVAL);
-	data->put = getput_index(dst_format->format);
-	snd_assert(data->put >= 0 && data->put < 4*2*2, return -EINVAL);
-
 	if (src_format->rate < dst_format->rate) {
 		data->pitch = ((src_format->rate << SHIFT) + (dst_format->rate >> 1)) / dst_format->rate;
 		data->func = resample_expand;

commit 21a3479a0b606d36fe24093f70a1c27328cec286
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Fri Jan 13 09:12:11 2006 +0100

    [ALSA] PCM midlevel & PCM OSS - make procfs & OSS plugin code optional
    
    Modules: ALSA Core,PCM Midlevel,ALSA<-OSS emulation,USB generic driver
    
    1) The verbose procfs code for the PCM midlevel and usb audio
       can be removed now (more patches will follow).
       CONFIG_SND_VERBOSE_PROCFS
    2) The PCM OSS plugin system can be also compiled optionaly.
       CONFIG_SND_PCM_OSS_PLUGINS
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/oss/rate.c b/sound/core/oss/rate.c
index 4854cef6fb4f..c4b75bff0ee5 100644
--- a/sound/core/oss/rate.c
+++ b/sound/core/oss/rate.c
@@ -20,6 +20,9 @@
  */
   
 #include <sound/driver.h>
+
+#ifdef CONFIG_SND_PCM_OSS_PLUGINS
+
 #include <linux/time.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -377,3 +380,5 @@ int snd_pcm_plugin_build_rate(struct snd_pcm_substream *plug,
 	*r_plugin = plugin;
 	return 0;
 }
+
+#endif

commit 6ac77bc180fbd985988015020c2e2347e802959d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:01:49 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCM OSS-emulation
    
    Modules: ALSA<-OSS emulation
    
    Remove xxx_t typedefs from the core PCM OSS-emulation codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/rate.c b/sound/core/oss/rate.c
index 7e325ca58706..4854cef6fb4f 100644
--- a/sound/core/oss/rate.c
+++ b/sound/core/oss/rate.c
@@ -33,29 +33,29 @@
  *  Basic rate conversion plugin
  */
 
-typedef struct {
+struct rate_channel {
 	signed short last_S1;
 	signed short last_S2;
-} rate_channel_t;
+};
  
-typedef void (*rate_f)(snd_pcm_plugin_t *plugin,
-		       const snd_pcm_plugin_channel_t *src_channels,
-		       snd_pcm_plugin_channel_t *dst_channels,
+typedef void (*rate_f)(struct snd_pcm_plugin *plugin,
+		       const struct snd_pcm_plugin_channel *src_channels,
+		       struct snd_pcm_plugin_channel *dst_channels,
 		       int src_frames, int dst_frames);
 
-typedef struct rate_private_data {
+struct rate_priv {
 	unsigned int pitch;
 	unsigned int pos;
 	rate_f func;
 	int get, put;
 	snd_pcm_sframes_t old_src_frames, old_dst_frames;
-	rate_channel_t channels[0];
-} rate_t;
+	struct rate_channel channels[0];
+};
 
-static void rate_init(snd_pcm_plugin_t *plugin)
+static void rate_init(struct snd_pcm_plugin *plugin)
 {
 	unsigned int channel;
-	rate_t *data = (rate_t *)plugin->extra_data;
+	struct rate_priv *data = (struct rate_priv *)plugin->extra_data;
 	data->pos = 0;
 	for (channel = 0; channel < plugin->src_format.channels; channel++) {
 		data->channels[channel].last_S1 = 0;
@@ -63,9 +63,9 @@ static void rate_init(snd_pcm_plugin_t *plugin)
 	}
 }
 
-static void resample_expand(snd_pcm_plugin_t *plugin,
-			    const snd_pcm_plugin_channel_t *src_channels,
-			    snd_pcm_plugin_channel_t *dst_channels,
+static void resample_expand(struct snd_pcm_plugin *plugin,
+			    const struct snd_pcm_plugin_channel *src_channels,
+			    struct snd_pcm_plugin_channel *dst_channels,
 			    int src_frames, int dst_frames)
 {
 	unsigned int pos = 0;
@@ -75,8 +75,8 @@ static void resample_expand(snd_pcm_plugin_t *plugin,
 	unsigned int channel;
 	int src_step, dst_step;
 	int src_frames1, dst_frames1;
-	rate_t *data = (rate_t *)plugin->extra_data;
-	rate_channel_t *rchannels = data->channels;
+	struct rate_priv *data = (struct rate_priv *)plugin->extra_data;
+	struct rate_channel *rchannels = data->channels;
 
 #define GET_S16_LABELS
 #define PUT_S16_LABELS
@@ -139,9 +139,9 @@ static void resample_expand(snd_pcm_plugin_t *plugin,
 	data->pos = pos;
 }
 
-static void resample_shrink(snd_pcm_plugin_t *plugin,
-			    const snd_pcm_plugin_channel_t *src_channels,
-			    snd_pcm_plugin_channel_t *dst_channels,
+static void resample_shrink(struct snd_pcm_plugin *plugin,
+			    const struct snd_pcm_plugin_channel *src_channels,
+			    struct snd_pcm_plugin_channel *dst_channels,
 			    int src_frames, int dst_frames)
 {
 	unsigned int pos = 0;
@@ -151,8 +151,8 @@ static void resample_shrink(snd_pcm_plugin_t *plugin,
 	unsigned int channel;
 	int src_step, dst_step;
 	int src_frames1, dst_frames1;
-	rate_t *data = (rate_t *)plugin->extra_data;
-	rate_channel_t *rchannels = data->channels;
+	struct rate_priv *data = (struct rate_priv *)plugin->extra_data;
+	struct rate_channel *rchannels = data->channels;
 	
 #define GET_S16_LABELS
 #define PUT_S16_LABELS
@@ -216,15 +216,15 @@ static void resample_shrink(snd_pcm_plugin_t *plugin,
 	data->pos = pos;
 }
 
-static snd_pcm_sframes_t rate_src_frames(snd_pcm_plugin_t *plugin, snd_pcm_uframes_t frames)
+static snd_pcm_sframes_t rate_src_frames(struct snd_pcm_plugin *plugin, snd_pcm_uframes_t frames)
 {
-	rate_t *data;
+	struct rate_priv *data;
 	snd_pcm_sframes_t res;
 
 	snd_assert(plugin != NULL, return -ENXIO);
 	if (frames == 0)
 		return 0;
-	data = (rate_t *)plugin->extra_data;
+	data = (struct rate_priv *)plugin->extra_data;
 	if (plugin->src_format.rate < plugin->dst_format.rate) {
 		res = (((frames * data->pitch) + (BITS/2)) >> SHIFT);
 	} else {
@@ -248,15 +248,15 @@ static snd_pcm_sframes_t rate_src_frames(snd_pcm_plugin_t *plugin, snd_pcm_ufram
 	return res;
 }
 
-static snd_pcm_sframes_t rate_dst_frames(snd_pcm_plugin_t *plugin, snd_pcm_uframes_t frames)
+static snd_pcm_sframes_t rate_dst_frames(struct snd_pcm_plugin *plugin, snd_pcm_uframes_t frames)
 {
-	rate_t *data;
+	struct rate_priv *data;
 	snd_pcm_sframes_t res;
 
 	snd_assert(plugin != NULL, return -ENXIO);
 	if (frames == 0)
 		return 0;
-	data = (rate_t *)plugin->extra_data;
+	data = (struct rate_priv *)plugin->extra_data;
 	if (plugin->src_format.rate < plugin->dst_format.rate) {
 		res = (((frames << SHIFT) + (data->pitch / 2)) / data->pitch);
 	} else {
@@ -280,13 +280,13 @@ static snd_pcm_sframes_t rate_dst_frames(snd_pcm_plugin_t *plugin, snd_pcm_ufram
 	return res;
 }
 
-static snd_pcm_sframes_t rate_transfer(snd_pcm_plugin_t *plugin,
-			     const snd_pcm_plugin_channel_t *src_channels,
-			     snd_pcm_plugin_channel_t *dst_channels,
+static snd_pcm_sframes_t rate_transfer(struct snd_pcm_plugin *plugin,
+			     const struct snd_pcm_plugin_channel *src_channels,
+			     struct snd_pcm_plugin_channel *dst_channels,
 			     snd_pcm_uframes_t frames)
 {
 	snd_pcm_uframes_t dst_frames;
-	rate_t *data;
+	struct rate_priv *data;
 
 	snd_assert(plugin != NULL && src_channels != NULL && dst_channels != NULL, return -ENXIO);
 	if (frames == 0)
@@ -308,13 +308,13 @@ static snd_pcm_sframes_t rate_transfer(snd_pcm_plugin_t *plugin,
 	dst_frames = rate_dst_frames(plugin, frames);
 	if (dst_frames > dst_channels[0].frames)
 		dst_frames = dst_channels[0].frames;
-	data = (rate_t *)plugin->extra_data;
+	data = (struct rate_priv *)plugin->extra_data;
 	data->func(plugin, src_channels, dst_channels, frames, dst_frames);
 	return dst_frames;
 }
 
-static int rate_action(snd_pcm_plugin_t *plugin,
-		       snd_pcm_plugin_action_t action,
+static int rate_action(struct snd_pcm_plugin *plugin,
+		       enum snd_pcm_plugin_action action,
 		       unsigned long udata)
 {
 	snd_assert(plugin != NULL, return -ENXIO);
@@ -329,14 +329,14 @@ static int rate_action(snd_pcm_plugin_t *plugin,
 	return 0;	/* silenty ignore other actions */
 }
 
-int snd_pcm_plugin_build_rate(snd_pcm_plug_t *plug,
-			      snd_pcm_plugin_format_t *src_format,
-			      snd_pcm_plugin_format_t *dst_format,
-			      snd_pcm_plugin_t **r_plugin)
+int snd_pcm_plugin_build_rate(struct snd_pcm_substream *plug,
+			      struct snd_pcm_plugin_format *src_format,
+			      struct snd_pcm_plugin_format *dst_format,
+			      struct snd_pcm_plugin **r_plugin)
 {
 	int err;
-	rate_t *data;
-	snd_pcm_plugin_t *plugin;
+	struct rate_priv *data;
+	struct snd_pcm_plugin *plugin;
 
 	snd_assert(r_plugin != NULL, return -ENXIO);
 	*r_plugin = NULL;
@@ -349,11 +349,12 @@ int snd_pcm_plugin_build_rate(snd_pcm_plug_t *plug,
 
 	err = snd_pcm_plugin_build(plug, "rate conversion",
 				   src_format, dst_format,
-				   sizeof(rate_t) + src_format->channels * sizeof(rate_channel_t),
+				   sizeof(struct rate_priv) +
+				   src_format->channels * sizeof(struct rate_channel),
 				   &plugin);
 	if (err < 0)
 		return err;
-	data = (rate_t *)plugin->extra_data;
+	data = (struct rate_priv *)plugin->extra_data;
 	data->get = getput_index(src_format->format);
 	snd_assert(data->get >= 0 && data->get < 4*2*2, return -EINVAL);
 	data->put = getput_index(dst_format->format);

commit 47eaebfd31610d2a55fbaccd1e7c37690d42ce30
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 10:18:00 2005 +0100

    [ALSA] Use standard bitmap functions
    
    Modules: ALSA<-OSS emulation
    
    Use standard bitmap functions instead of in-house ones.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/oss/rate.c b/sound/core/oss/rate.c
index 1096ec186714..7e325ca58706 100644
--- a/sound/core/oss/rate.c
+++ b/sound/core/oss/rate.c
@@ -315,7 +315,7 @@ static snd_pcm_sframes_t rate_transfer(snd_pcm_plugin_t *plugin,
 
 static int rate_action(snd_pcm_plugin_t *plugin,
 		       snd_pcm_plugin_action_t action,
-		       unsigned long udata ATTRIBUTE_UNUSED)
+		       unsigned long udata)
 {
 	snd_assert(plugin != NULL, return -ENXIO);
 	switch (action) {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/oss/rate.c b/sound/core/oss/rate.c
new file mode 100644
index 000000000000..1096ec186714
--- /dev/null
+++ b/sound/core/oss/rate.c
@@ -0,0 +1,378 @@
+/*
+ *  Rate conversion Plug-In
+ *  Copyright (c) 1999 by Jaroslav Kysela <perex@suse.cz>
+ *
+ *
+ *   This library is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU Library General Public License as
+ *   published by the Free Software Foundation; either version 2 of
+ *   the License, or (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU Library General Public License for more details.
+ *
+ *   You should have received a copy of the GNU Library General Public
+ *   License along with this library; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+  
+#include <sound/driver.h>
+#include <linux/time.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include "pcm_plugin.h"
+
+#define SHIFT	11
+#define BITS	(1<<SHIFT)
+#define R_MASK	(BITS-1)
+
+/*
+ *  Basic rate conversion plugin
+ */
+
+typedef struct {
+	signed short last_S1;
+	signed short last_S2;
+} rate_channel_t;
+ 
+typedef void (*rate_f)(snd_pcm_plugin_t *plugin,
+		       const snd_pcm_plugin_channel_t *src_channels,
+		       snd_pcm_plugin_channel_t *dst_channels,
+		       int src_frames, int dst_frames);
+
+typedef struct rate_private_data {
+	unsigned int pitch;
+	unsigned int pos;
+	rate_f func;
+	int get, put;
+	snd_pcm_sframes_t old_src_frames, old_dst_frames;
+	rate_channel_t channels[0];
+} rate_t;
+
+static void rate_init(snd_pcm_plugin_t *plugin)
+{
+	unsigned int channel;
+	rate_t *data = (rate_t *)plugin->extra_data;
+	data->pos = 0;
+	for (channel = 0; channel < plugin->src_format.channels; channel++) {
+		data->channels[channel].last_S1 = 0;
+		data->channels[channel].last_S2 = 0;
+	}
+}
+
+static void resample_expand(snd_pcm_plugin_t *plugin,
+			    const snd_pcm_plugin_channel_t *src_channels,
+			    snd_pcm_plugin_channel_t *dst_channels,
+			    int src_frames, int dst_frames)
+{
+	unsigned int pos = 0;
+	signed int val;
+	signed short S1, S2;
+	char *src, *dst;
+	unsigned int channel;
+	int src_step, dst_step;
+	int src_frames1, dst_frames1;
+	rate_t *data = (rate_t *)plugin->extra_data;
+	rate_channel_t *rchannels = data->channels;
+
+#define GET_S16_LABELS
+#define PUT_S16_LABELS
+#include "plugin_ops.h"
+#undef GET_S16_LABELS
+#undef PUT_S16_LABELS
+	void *get = get_s16_labels[data->get];
+	void *put = put_s16_labels[data->put];
+	signed short sample = 0;
+	
+	for (channel = 0; channel < plugin->src_format.channels; channel++) {
+		pos = data->pos;
+		S1 = rchannels->last_S1;
+		S2 = rchannels->last_S2;
+		if (!src_channels[channel].enabled) {
+			if (dst_channels[channel].wanted)
+				snd_pcm_area_silence(&dst_channels[channel].area, 0, dst_frames, plugin->dst_format.format);
+			dst_channels[channel].enabled = 0;
+			continue;
+		}
+		dst_channels[channel].enabled = 1;
+		src = (char *)src_channels[channel].area.addr + src_channels[channel].area.first / 8;
+		dst = (char *)dst_channels[channel].area.addr + dst_channels[channel].area.first / 8;
+		src_step = src_channels[channel].area.step / 8;
+		dst_step = dst_channels[channel].area.step / 8;
+		src_frames1 = src_frames;
+		dst_frames1 = dst_frames;
+		while (dst_frames1-- > 0) {
+			if (pos & ~R_MASK) {
+				pos &= R_MASK;
+				S1 = S2;
+				if (src_frames1-- > 0) {
+					goto *get;
+#define GET_S16_END after_get
+#include "plugin_ops.h"
+#undef GET_S16_END
+				after_get:
+					S2 = sample;
+					src += src_step;
+				}
+			}
+			val = S1 + ((S2 - S1) * (signed int)pos) / BITS;
+			if (val < -32768)
+				val = -32768;
+			else if (val > 32767)
+				val = 32767;
+			sample = val;
+			goto *put;
+#define PUT_S16_END after_put
+#include "plugin_ops.h"
+#undef PUT_S16_END
+		after_put:
+			dst += dst_step;
+			pos += data->pitch;
+		}
+		rchannels->last_S1 = S1;
+		rchannels->last_S2 = S2;
+		rchannels++;
+	}
+	data->pos = pos;
+}
+
+static void resample_shrink(snd_pcm_plugin_t *plugin,
+			    const snd_pcm_plugin_channel_t *src_channels,
+			    snd_pcm_plugin_channel_t *dst_channels,
+			    int src_frames, int dst_frames)
+{
+	unsigned int pos = 0;
+	signed int val;
+	signed short S1, S2;
+	char *src, *dst;
+	unsigned int channel;
+	int src_step, dst_step;
+	int src_frames1, dst_frames1;
+	rate_t *data = (rate_t *)plugin->extra_data;
+	rate_channel_t *rchannels = data->channels;
+	
+#define GET_S16_LABELS
+#define PUT_S16_LABELS
+#include "plugin_ops.h"
+#undef GET_S16_LABELS
+#undef PUT_S16_LABELS
+	void *get = get_s16_labels[data->get];
+	void *put = put_s16_labels[data->put];
+	signed short sample = 0;
+
+	for (channel = 0; channel < plugin->src_format.channels; ++channel) {
+		pos = data->pos;
+		S1 = rchannels->last_S1;
+		S2 = rchannels->last_S2;
+		if (!src_channels[channel].enabled) {
+			if (dst_channels[channel].wanted)
+				snd_pcm_area_silence(&dst_channels[channel].area, 0, dst_frames, plugin->dst_format.format);
+			dst_channels[channel].enabled = 0;
+			continue;
+		}
+		dst_channels[channel].enabled = 1;
+		src = (char *)src_channels[channel].area.addr + src_channels[channel].area.first / 8;
+		dst = (char *)dst_channels[channel].area.addr + dst_channels[channel].area.first / 8;
+		src_step = src_channels[channel].area.step / 8;
+		dst_step = dst_channels[channel].area.step / 8;
+		src_frames1 = src_frames;
+		dst_frames1 = dst_frames;
+		while (dst_frames1 > 0) {
+			S1 = S2;
+			if (src_frames1-- > 0) {
+				goto *get;
+#define GET_S16_END after_get
+#include "plugin_ops.h"
+#undef GET_S16_END
+			after_get:
+				S2 = sample;
+				src += src_step;
+			}
+			if (pos & ~R_MASK) {
+				pos &= R_MASK;
+				val = S1 + ((S2 - S1) * (signed int)pos) / BITS;
+				if (val < -32768)
+					val = -32768;
+				else if (val > 32767)
+					val = 32767;
+				sample = val;
+				goto *put;
+#define PUT_S16_END after_put
+#include "plugin_ops.h"
+#undef PUT_S16_END
+			after_put:
+				dst += dst_step;
+				dst_frames1--;
+			}
+			pos += data->pitch;
+		}
+		rchannels->last_S1 = S1;
+		rchannels->last_S2 = S2;
+		rchannels++;
+	}
+	data->pos = pos;
+}
+
+static snd_pcm_sframes_t rate_src_frames(snd_pcm_plugin_t *plugin, snd_pcm_uframes_t frames)
+{
+	rate_t *data;
+	snd_pcm_sframes_t res;
+
+	snd_assert(plugin != NULL, return -ENXIO);
+	if (frames == 0)
+		return 0;
+	data = (rate_t *)plugin->extra_data;
+	if (plugin->src_format.rate < plugin->dst_format.rate) {
+		res = (((frames * data->pitch) + (BITS/2)) >> SHIFT);
+	} else {
+		res = (((frames << SHIFT) + (data->pitch / 2)) / data->pitch);		
+	}
+	if (data->old_src_frames > 0) {
+		snd_pcm_sframes_t frames1 = frames, res1 = data->old_dst_frames;
+		while (data->old_src_frames < frames1) {
+			frames1 >>= 1;
+			res1 <<= 1;
+		}
+		while (data->old_src_frames > frames1) {
+			frames1 <<= 1;
+			res1 >>= 1;
+		}
+		if (data->old_src_frames == frames1)
+			return res1;
+	}
+	data->old_src_frames = frames;
+	data->old_dst_frames = res;
+	return res;
+}
+
+static snd_pcm_sframes_t rate_dst_frames(snd_pcm_plugin_t *plugin, snd_pcm_uframes_t frames)
+{
+	rate_t *data;
+	snd_pcm_sframes_t res;
+
+	snd_assert(plugin != NULL, return -ENXIO);
+	if (frames == 0)
+		return 0;
+	data = (rate_t *)plugin->extra_data;
+	if (plugin->src_format.rate < plugin->dst_format.rate) {
+		res = (((frames << SHIFT) + (data->pitch / 2)) / data->pitch);
+	} else {
+		res = (((frames * data->pitch) + (BITS/2)) >> SHIFT);
+	}
+	if (data->old_dst_frames > 0) {
+		snd_pcm_sframes_t frames1 = frames, res1 = data->old_src_frames;
+		while (data->old_dst_frames < frames1) {
+			frames1 >>= 1;
+			res1 <<= 1;
+		}
+		while (data->old_dst_frames > frames1) {
+			frames1 <<= 1;
+			res1 >>= 1;
+		}
+		if (data->old_dst_frames == frames1)
+			return res1;
+	}
+	data->old_dst_frames = frames;
+	data->old_src_frames = res;
+	return res;
+}
+
+static snd_pcm_sframes_t rate_transfer(snd_pcm_plugin_t *plugin,
+			     const snd_pcm_plugin_channel_t *src_channels,
+			     snd_pcm_plugin_channel_t *dst_channels,
+			     snd_pcm_uframes_t frames)
+{
+	snd_pcm_uframes_t dst_frames;
+	rate_t *data;
+
+	snd_assert(plugin != NULL && src_channels != NULL && dst_channels != NULL, return -ENXIO);
+	if (frames == 0)
+		return 0;
+#ifdef CONFIG_SND_DEBUG
+	{
+		unsigned int channel;
+		for (channel = 0; channel < plugin->src_format.channels; channel++) {
+			snd_assert(src_channels[channel].area.first % 8 == 0 &&
+				   src_channels[channel].area.step % 8 == 0,
+				   return -ENXIO);
+			snd_assert(dst_channels[channel].area.first % 8 == 0 &&
+				   dst_channels[channel].area.step % 8 == 0,
+				   return -ENXIO);
+		}
+	}
+#endif
+
+	dst_frames = rate_dst_frames(plugin, frames);
+	if (dst_frames > dst_channels[0].frames)
+		dst_frames = dst_channels[0].frames;
+	data = (rate_t *)plugin->extra_data;
+	data->func(plugin, src_channels, dst_channels, frames, dst_frames);
+	return dst_frames;
+}
+
+static int rate_action(snd_pcm_plugin_t *plugin,
+		       snd_pcm_plugin_action_t action,
+		       unsigned long udata ATTRIBUTE_UNUSED)
+{
+	snd_assert(plugin != NULL, return -ENXIO);
+	switch (action) {
+	case INIT:
+	case PREPARE:
+		rate_init(plugin);
+		break;
+	default:
+		break;
+	}
+	return 0;	/* silenty ignore other actions */
+}
+
+int snd_pcm_plugin_build_rate(snd_pcm_plug_t *plug,
+			      snd_pcm_plugin_format_t *src_format,
+			      snd_pcm_plugin_format_t *dst_format,
+			      snd_pcm_plugin_t **r_plugin)
+{
+	int err;
+	rate_t *data;
+	snd_pcm_plugin_t *plugin;
+
+	snd_assert(r_plugin != NULL, return -ENXIO);
+	*r_plugin = NULL;
+
+	snd_assert(src_format->channels == dst_format->channels, return -ENXIO);
+	snd_assert(src_format->channels > 0, return -ENXIO);
+	snd_assert(snd_pcm_format_linear(src_format->format) != 0, return -ENXIO);
+	snd_assert(snd_pcm_format_linear(dst_format->format) != 0, return -ENXIO);
+	snd_assert(src_format->rate != dst_format->rate, return -ENXIO);
+
+	err = snd_pcm_plugin_build(plug, "rate conversion",
+				   src_format, dst_format,
+				   sizeof(rate_t) + src_format->channels * sizeof(rate_channel_t),
+				   &plugin);
+	if (err < 0)
+		return err;
+	data = (rate_t *)plugin->extra_data;
+	data->get = getput_index(src_format->format);
+	snd_assert(data->get >= 0 && data->get < 4*2*2, return -EINVAL);
+	data->put = getput_index(dst_format->format);
+	snd_assert(data->put >= 0 && data->put < 4*2*2, return -EINVAL);
+
+	if (src_format->rate < dst_format->rate) {
+		data->pitch = ((src_format->rate << SHIFT) + (dst_format->rate >> 1)) / dst_format->rate;
+		data->func = resample_expand;
+	} else {
+		data->pitch = ((dst_format->rate << SHIFT) + (src_format->rate >> 1)) / src_format->rate;
+		data->func = resample_shrink;
+	}
+	data->pos = 0;
+	rate_init(plugin);
+	data->old_src_frames = data->old_dst_frames = 0;
+	plugin->transfer = rate_transfer;
+	plugin->src_frames = rate_src_frames;
+	plugin->dst_frames = rate_dst_frames;
+	plugin->action = rate_action;
+	*r_plugin = plugin;
+	return 0;
+}
