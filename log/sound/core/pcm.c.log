commit 296a37fd029dd8a911396e3c28e0bbd5a2720a5d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 13 14:02:23 2020 +0100

    ALSA: pcm: Fix superfluous snprintf() usage
    
    show_pcm_class() returns obviously a short string that can't overflow
    PAGE_SIZE.  And even if it were to overflow, using snprintf() there is
    just wrong, as it doesn't return the correct size.
    So simplify with sprintf() instead.
    
    Link: https://lore.kernel.org/r/20200313130223.8908-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index a141a301369f..b6d2331a82f7 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1019,7 +1019,7 @@ static ssize_t show_pcm_class(struct device *dev,
 		str = "none";
 	else
 		str = strs[pcm->dev_class];
-        return snprintf(buf, PAGE_SIZE, "%s\n", str);
+	return sprintf(buf, "%s\n", str);
 }
 
 static DEVICE_ATTR(pcm_class, 0444, show_pcm_class, NULL);

commit d03af9b8ea7e8655869834f2eed1f1d583cc5672
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:20 2020 +0100

    ALSA: pcm: More constifications
    
    Apply const prefix to more possible places: the string tables for PCM
    format and co, the table for the PCM type helpers, etc.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-6-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index a0f704b72a78..a141a301369f 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -163,7 +163,7 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 
 #define FORMAT(v) [SNDRV_PCM_FORMAT_##v] = #v
 
-static char *snd_pcm_format_names[] = {
+static const char * const snd_pcm_format_names[] = {
 	FORMAT(S8),
 	FORMAT(U8),
 	FORMAT(S16_LE),
@@ -237,12 +237,12 @@ EXPORT_SYMBOL_GPL(snd_pcm_format_name);
 #define START(v) [SNDRV_PCM_START_##v] = #v
 #define SUBFORMAT(v) [SNDRV_PCM_SUBFORMAT_##v] = #v 
 
-static char *snd_pcm_stream_names[] = {
+static const char * const snd_pcm_stream_names[] = {
 	STREAM(PLAYBACK),
 	STREAM(CAPTURE),
 };
 
-static char *snd_pcm_state_names[] = {
+static const char * const snd_pcm_state_names[] = {
 	STATE(OPEN),
 	STATE(SETUP),
 	STATE(PREPARED),
@@ -253,7 +253,7 @@ static char *snd_pcm_state_names[] = {
 	STATE(SUSPENDED),
 };
 
-static char *snd_pcm_access_names[] = {
+static const char * const snd_pcm_access_names[] = {
 	ACCESS(MMAP_INTERLEAVED), 
 	ACCESS(MMAP_NONINTERLEAVED),
 	ACCESS(MMAP_COMPLEX),
@@ -261,11 +261,11 @@ static char *snd_pcm_access_names[] = {
 	ACCESS(RW_NONINTERLEAVED),
 };
 
-static char *snd_pcm_subformat_names[] = {
+static const char * const snd_pcm_subformat_names[] = {
 	SUBFORMAT(STD), 
 };
 
-static char *snd_pcm_tstamp_mode_names[] = {
+static const char * const snd_pcm_tstamp_mode_names[] = {
 	TSTAMP(NONE),
 	TSTAMP(ENABLE),
 };

commit f15ee210cdb87f82147df237d2fcfc4527523d62
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:20 2020 +0100

    ALSA: core: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-5-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 85db55ea49fd..a0f704b72a78 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -706,12 +706,12 @@ static int _snd_pcm_new(struct snd_card *card, const char *id, int device,
 {
 	struct snd_pcm *pcm;
 	int err;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free = snd_pcm_dev_free,
 		.dev_register =	snd_pcm_dev_register,
 		.dev_disconnect = snd_pcm_dev_disconnect,
 	};
-	static struct snd_device_ops internal_ops = {
+	static const struct snd_device_ops internal_ops = {
 		.dev_free = snd_pcm_dev_free,
 	};
 

commit 3ddee7f88aaf2dee38f7016ac8fd48dd9fdb43e3
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Tue Apr 24 20:06:11 2018 +0800

    ALSA: Avoid using timespec for struct snd_pcm_status
    
    The struct snd_pcm_status will use 'timespec' type variables to record
    timestamp, which is not year 2038 safe on 32bits system.
    
    Userspace will use SNDRV_PCM_IOCTL_STATUS and SNDRV_PCM_IOCTL_STATUS_EXT
    as commands to issue ioctl() to fill the 'snd_pcm_status' structure in
    userspace. The command number is always defined through _IOR/_IOW/IORW,
    so when userspace changes the definition of 'struct timespec' to use
    64-bit types, the command number also changes.
    
    Thus in the kernel, we now need to define two versions of each such ioctl
    and corresponding ioctl commands to handle 32bit time_t and 64bit time_t
    in native mode:
    struct snd_pcm_status32 {
            ......
    
            s32 trigger_tstamp_sec;
            s32 trigger_tstamp_nsec;
    
            ......
    
            s32 audio_tstamp_sec;
            s32 audio_tstamp_nsec;
    
            ......
    };
    
    struct snd_pcm_status64 {
            ......
    
            s32 trigger_tstamp_sec;
            s32 trigger_tstamp_nsec;
    
            ......
    
            s32 audio_tstamp_sec;
            s32 audio_tstamp_nsec;
    
            ......
    };
    
    Moreover in compat file, we renamed or introduced new structures to handle
    32bit/64bit time_t in compatible mode. The 'struct snd_pcm_status32' and
    snd_pcm_status_user32() are used to handle 32bit time_t in compat mode.
    'struct compat_snd_pcm_status64' and snd_pcm_status_user_compat64() are used
    to handle 64bit time_t.
    
    The implicit padding before timespec is made explicit to avoid incompatible
    structure layout between 32-bit and 64-bit x86 due to the different
    alignment requirements, and the snd_pcm_status structure is now hidden
    from the kernel to avoid relying on the timespec definitio definitionn
    
    Finally we can replace SNDRV_PCM_IOCTL_STATUS and SNDRV_PCM_IOCTL_STATUS_EXT
    with new commands and introduce new functions to fill new 'struct snd_pcm_status64'
    instead of using unsafe 'struct snd_pcm_status'. Then in future, the new
    commands can be matched when userspace changes 'timespec' to 64bit type
    to make a size change of 'struct snd_pcm_status'. When glibc changes time_t
    to 64-bit, any recompiled program will issue ioctl commands that the kernel
    does not understand without this patch.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 9a72d641743d..85db55ea49fd 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -443,7 +443,7 @@ static void snd_pcm_substream_proc_status_read(struct snd_info_entry *entry,
 {
 	struct snd_pcm_substream *substream = entry->private_data;
 	struct snd_pcm_runtime *runtime;
-	struct snd_pcm_status status;
+	struct snd_pcm_status64 status;
 	int err;
 
 	mutex_lock(&substream->pcm->open_mutex);
@@ -453,17 +453,17 @@ static void snd_pcm_substream_proc_status_read(struct snd_info_entry *entry,
 		goto unlock;
 	}
 	memset(&status, 0, sizeof(status));
-	err = snd_pcm_status(substream, &status);
+	err = snd_pcm_status64(substream, &status);
 	if (err < 0) {
 		snd_iprintf(buffer, "error %d\n", err);
 		goto unlock;
 	}
 	snd_iprintf(buffer, "state: %s\n", snd_pcm_state_name(status.state));
 	snd_iprintf(buffer, "owner_pid   : %d\n", pid_vnr(substream->pid));
-	snd_iprintf(buffer, "trigger_time: %ld.%09ld\n",
-		status.trigger_tstamp.tv_sec, status.trigger_tstamp.tv_nsec);
-	snd_iprintf(buffer, "tstamp      : %ld.%09ld\n",
-		status.tstamp.tv_sec, status.tstamp.tv_nsec);
+	snd_iprintf(buffer, "trigger_time: %lld.%09lld\n",
+		status.trigger_tstamp_sec, status.trigger_tstamp_nsec);
+	snd_iprintf(buffer, "tstamp      : %lld.%09lld\n",
+		status.tstamp_sec, status.tstamp_nsec);
 	snd_iprintf(buffer, "delay       : %ld\n", status.delay);
 	snd_iprintf(buffer, "avail       : %ld\n", status.avail);
 	snd_iprintf(buffer, "avail_max   : %ld\n", status.avail_max);

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 998e477522fd..9a72d641743d 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1,22 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Digital Audio (PCM) abstract layer
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/init.h>

commit 734b5a0bbdf43518e6739c8156a985e385e557fe
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 23 19:38:13 2018 +0100

    ALSA: Replace snd_malloc_pages() and snd_free_pages() with standard helpers, take#2
    
    snd_malloc_pages() and snd_free_pages() are merely thin wrappers of
    the standard page allocator / free functions.  Even the arguments are
    compatible with some standard helpers, so there is little merit of
    keeping these wrappers.
    
    This patch replaces the all existing callers of snd_malloc_pages() and
    snd_free_pages() with the direct calls of the standard helper
    functions.  In this version, we use a recently introduced one,
    alloc_pages_exact(), which suits better than the old
    snd_malloc_pages() implementation for our purposes.  Then we can avoid
    the waste of pages by alignment to power-of-two.
    
    Since alloc_pages_exact() does split pages, we need no longer
    __GFP_COMP flag; or better to say, we must not pass __GFP_COMP to
    alloc_pages_exact().  So the former unconditional addition of
    __GFP_COMP flag in snd_malloc_pages() is dropped, as well as in most
    other places.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 7b63aee124af..998e477522fd 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -959,22 +959,22 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 		return -ENOMEM;
 
 	size = PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status));
-	runtime->status = snd_malloc_pages(size, GFP_KERNEL);
+	runtime->status = alloc_pages_exact(size, GFP_KERNEL);
 	if (runtime->status == NULL) {
 		kfree(runtime);
 		return -ENOMEM;
 	}
-	memset((void*)runtime->status, 0, size);
+	memset(runtime->status, 0, size);
 
 	size = PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control));
-	runtime->control = snd_malloc_pages(size, GFP_KERNEL);
+	runtime->control = alloc_pages_exact(size, GFP_KERNEL);
 	if (runtime->control == NULL) {
-		snd_free_pages((void*)runtime->status,
+		free_pages_exact(runtime->status,
 			       PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status)));
 		kfree(runtime);
 		return -ENOMEM;
 	}
-	memset((void*)runtime->control, 0, size);
+	memset(runtime->control, 0, size);
 
 	init_waitqueue_head(&runtime->sleep);
 	init_waitqueue_head(&runtime->tsleep);
@@ -1000,9 +1000,9 @@ void snd_pcm_detach_substream(struct snd_pcm_substream *substream)
 	runtime = substream->runtime;
 	if (runtime->private_free != NULL)
 		runtime->private_free(runtime);
-	snd_free_pages((void*)runtime->status,
+	free_pages_exact(runtime->status,
 		       PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status)));
-	snd_free_pages((void*)runtime->control,
+	free_pages_exact(runtime->control,
 		       PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control)));
 	kfree(runtime->hw_constraints.rules);
 	/* Avoid concurrent access to runtime via PCM timer interface */

commit a8d149813b4456b689effb1f10accdc937566703
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 15:02:11 2019 +0100

    ALSA: pcm: Remove superfluous snd_info_register() calls
    
    The calls of snd_info_register() are superfluous and should be avoided
    at the procfs creation time.  They are called at the end of the whole
    initialization via snd_card_register().  This patch drops such
    superfluous calls, as well as cleaning up the calls of substream proc
    entries with a common helper.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 4f45b3000347..7b63aee124af 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -528,28 +528,17 @@ static int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)
 	if (!entry)
 		return -ENOMEM;
 	entry->mode = S_IFDIR | 0555;
-	if (snd_info_register(entry) < 0) {
-		snd_info_free_entry(entry);
-		return -ENOMEM;
-	}
 	pstr->proc_root = entry;
 	entry = snd_info_create_card_entry(pcm->card, "info", pstr->proc_root);
-	if (entry) {
+	if (entry)
 		snd_info_set_text_ops(entry, pstr, snd_pcm_stream_proc_info_read);
-		if (snd_info_register(entry) < 0)
-			snd_info_free_entry(entry);
-	}
-
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
 	entry = snd_info_create_card_entry(pcm->card, "xrun_debug",
 					   pstr->proc_root);
 	if (entry) {
-		entry->c.text.read = snd_pcm_xrun_debug_read;
+		snd_info_set_text_ops(entry, pstr, snd_pcm_xrun_debug_read);
 		entry->c.text.write = snd_pcm_xrun_debug_write;
 		entry->mode |= 0200;
-		entry->private_data = pstr;
-		if (snd_info_register(entry) < 0)
-			snd_info_free_entry(entry);
 	}
 #endif
 	return 0;
@@ -562,6 +551,21 @@ static int snd_pcm_stream_proc_done(struct snd_pcm_str *pstr)
 	return 0;
 }
 
+static struct snd_info_entry *
+create_substream_info_entry(struct snd_pcm_substream *substream,
+			    const char *name,
+			    void (*read)(struct snd_info_entry *,
+					 struct snd_info_buffer *))
+{
+	struct snd_info_entry *entry;
+
+	entry = snd_info_create_card_entry(substream->pcm->card, name,
+					   substream->proc_root);
+	if (entry)
+		snd_info_set_text_ops(entry, substream, read);
+	return entry;
+}
+
 static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 {
 	struct snd_info_entry *entry;
@@ -576,53 +580,22 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 	if (!entry)
 		return -ENOMEM;
 	entry->mode = S_IFDIR | 0555;
-	if (snd_info_register(entry) < 0) {
-		snd_info_free_entry(entry);
-		return -ENOMEM;
-	}
 	substream->proc_root = entry;
-	entry = snd_info_create_card_entry(card, "info", substream->proc_root);
-	if (entry) {
-		snd_info_set_text_ops(entry, substream,
-				      snd_pcm_substream_proc_info_read);
-		if (snd_info_register(entry) < 0)
-			snd_info_free_entry(entry);
-	}
-	entry = snd_info_create_card_entry(card, "hw_params",
-					   substream->proc_root);
-	if (entry) {
-		snd_info_set_text_ops(entry, substream,
-				      snd_pcm_substream_proc_hw_params_read);
-		if (snd_info_register(entry) < 0)
-			snd_info_free_entry(entry);
-	}
-	entry = snd_info_create_card_entry(card, "sw_params",
-					   substream->proc_root);
-	if (entry) {
-		snd_info_set_text_ops(entry, substream,
-				      snd_pcm_substream_proc_sw_params_read);
-		if (snd_info_register(entry) < 0)
-			snd_info_free_entry(entry);
-	}
-	entry = snd_info_create_card_entry(card, "status",
-					   substream->proc_root);
-	if (entry) {
-		snd_info_set_text_ops(entry, substream,
-				      snd_pcm_substream_proc_status_read);
-		if (snd_info_register(entry) < 0)
-			snd_info_free_entry(entry);
-	}
+
+	create_substream_info_entry(substream, "info",
+				    snd_pcm_substream_proc_info_read);
+	create_substream_info_entry(substream, "hw_params",
+				    snd_pcm_substream_proc_hw_params_read);
+	create_substream_info_entry(substream, "sw_params",
+				    snd_pcm_substream_proc_sw_params_read);
+	create_substream_info_entry(substream, "status",
+				    snd_pcm_substream_proc_status_read);
 
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
-	entry = snd_info_create_card_entry(card, "xrun_injection",
-					   substream->proc_root);
+	entry = create_substream_info_entry(substream, "xrun_injection", NULL);
 	if (entry) {
-		entry->private_data = substream;
-		entry->c.text.read = NULL;
 		entry->c.text.write = snd_pcm_xrun_injection_write;
 		entry->mode = S_IFREG | 0200;
-		if (snd_info_register(entry) < 0)
-			snd_info_free_entry(entry);
 	}
 #endif /* CONFIG_SND_PCM_XRUN_DEBUG */
 

commit 205d6bcf9bb896903248cd8d600f23cf4d3886d2
Merge: 3a55437141a1 ef2056b8f394
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 24 14:46:17 2019 +0100

    Merge branch 'topic/pcm-lock-refactor' into for-next
    
    Pull PCM lock refactoring.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 480e32ebd524ffdf3d50cc5cac179fb9e44a552d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 23 16:44:38 2019 +0100

    ALSA: pcm: Simplify proc file destruction
    
    The proc files are recursively freed by calling with the root
    snd_info_entry object, so we don't have to keep each object for
    releasing one by one.  Move the release of the PCM stream proc root at
    the beginning, so that we can remove the redundant code and resource.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index ca1ea3cf9350..bca0bdf3e33c 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -536,12 +536,9 @@ static int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)
 	entry = snd_info_create_card_entry(pcm->card, "info", pstr->proc_root);
 	if (entry) {
 		snd_info_set_text_ops(entry, pstr, snd_pcm_stream_proc_info_read);
-		if (snd_info_register(entry) < 0) {
+		if (snd_info_register(entry) < 0)
 			snd_info_free_entry(entry);
-			entry = NULL;
-		}
 	}
-	pstr->proc_info_entry = entry;
 
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
 	entry = snd_info_create_card_entry(pcm->card, "xrun_debug",
@@ -551,24 +548,15 @@ static int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)
 		entry->c.text.write = snd_pcm_xrun_debug_write;
 		entry->mode |= 0200;
 		entry->private_data = pstr;
-		if (snd_info_register(entry) < 0) {
+		if (snd_info_register(entry) < 0)
 			snd_info_free_entry(entry);
-			entry = NULL;
-		}
 	}
-	pstr->proc_xrun_debug_entry = entry;
 #endif
 	return 0;
 }
 
 static int snd_pcm_stream_proc_done(struct snd_pcm_str *pstr)
 {
-#ifdef CONFIG_SND_PCM_XRUN_DEBUG
-	snd_info_free_entry(pstr->proc_xrun_debug_entry);
-	pstr->proc_xrun_debug_entry = NULL;
-#endif
-	snd_info_free_entry(pstr->proc_info_entry);
-	pstr->proc_info_entry = NULL;
 	snd_info_free_entry(pstr->proc_root);
 	pstr->proc_root = NULL;
 	return 0;
@@ -597,45 +585,33 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 	if (entry) {
 		snd_info_set_text_ops(entry, substream,
 				      snd_pcm_substream_proc_info_read);
-		if (snd_info_register(entry) < 0) {
+		if (snd_info_register(entry) < 0)
 			snd_info_free_entry(entry);
-			entry = NULL;
-		}
 	}
-	substream->proc_info_entry = entry;
 	entry = snd_info_create_card_entry(card, "hw_params",
 					   substream->proc_root);
 	if (entry) {
 		snd_info_set_text_ops(entry, substream,
 				      snd_pcm_substream_proc_hw_params_read);
-		if (snd_info_register(entry) < 0) {
+		if (snd_info_register(entry) < 0)
 			snd_info_free_entry(entry);
-			entry = NULL;
-		}
 	}
-	substream->proc_hw_params_entry = entry;
 	entry = snd_info_create_card_entry(card, "sw_params",
 					   substream->proc_root);
 	if (entry) {
 		snd_info_set_text_ops(entry, substream,
 				      snd_pcm_substream_proc_sw_params_read);
-		if (snd_info_register(entry) < 0) {
+		if (snd_info_register(entry) < 0)
 			snd_info_free_entry(entry);
-			entry = NULL;
-		}
 	}
-	substream->proc_sw_params_entry = entry;
 	entry = snd_info_create_card_entry(card, "status",
 					   substream->proc_root);
 	if (entry) {
 		snd_info_set_text_ops(entry, substream,
 				      snd_pcm_substream_proc_status_read);
-		if (snd_info_register(entry) < 0) {
+		if (snd_info_register(entry) < 0)
 			snd_info_free_entry(entry);
-			entry = NULL;
-		}
 	}
-	substream->proc_status_entry = entry;
 
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
 	entry = snd_info_create_card_entry(card, "xrun_injection",
@@ -645,40 +621,18 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 		entry->c.text.read = NULL;
 		entry->c.text.write = snd_pcm_xrun_injection_write;
 		entry->mode = S_IFREG | 0200;
-		if (snd_info_register(entry) < 0) {
+		if (snd_info_register(entry) < 0)
 			snd_info_free_entry(entry);
-			entry = NULL;
-		}
 	}
-	substream->proc_xrun_injection_entry = entry;
 #endif /* CONFIG_SND_PCM_XRUN_DEBUG */
 
 	return 0;
 }
 
-static int snd_pcm_substream_proc_done(struct snd_pcm_substream *substream)
-{
-	snd_info_free_entry(substream->proc_info_entry);
-	substream->proc_info_entry = NULL;
-	snd_info_free_entry(substream->proc_hw_params_entry);
-	substream->proc_hw_params_entry = NULL;
-	snd_info_free_entry(substream->proc_sw_params_entry);
-	substream->proc_sw_params_entry = NULL;
-	snd_info_free_entry(substream->proc_status_entry);
-	substream->proc_status_entry = NULL;
-#ifdef CONFIG_SND_PCM_XRUN_DEBUG
-	snd_info_free_entry(substream->proc_xrun_injection_entry);
-	substream->proc_xrun_injection_entry = NULL;
-#endif
-	snd_info_free_entry(substream->proc_root);
-	substream->proc_root = NULL;
-	return 0;
-}
 #else /* !CONFIG_SND_VERBOSE_PROCFS */
 static inline int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr) { return 0; }
 static inline int snd_pcm_stream_proc_done(struct snd_pcm_str *pstr) { return 0; }
 static inline int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream) { return 0; }
-static inline int snd_pcm_substream_proc_done(struct snd_pcm_substream *substream) { return 0; }
 #endif /* CONFIG_SND_VERBOSE_PROCFS */
 
 static const struct attribute_group *pcm_dev_attr_groups[];
@@ -911,15 +865,17 @@ static void snd_pcm_free_stream(struct snd_pcm_str * pstr)
 #if IS_ENABLED(CONFIG_SND_PCM_OSS)
 	struct snd_pcm_oss_setup *setup, *setupn;
 #endif
+
+	/* free all proc files under the stream */
+	snd_pcm_stream_proc_done(pstr);
+
 	substream = pstr->substream;
 	while (substream) {
 		substream_next = substream->next;
 		snd_pcm_timer_done(substream);
-		snd_pcm_substream_proc_done(substream);
 		kfree(substream);
 		substream = substream_next;
 	}
-	snd_pcm_stream_proc_done(pstr);
 #if IS_ENABLED(CONFIG_SND_PCM_OSS)
 	for (setup = pstr->oss.setup_list; setup; setup = setupn) {
 		setupn = setup->next;

commit 73365cb10b280e539bad14e129e0d8434418bb79
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 13 09:35:17 2019 +0100

    ALSA: pcm: Unify snd_pcm_group initialization
    
    There are multiple open codes that initialize the same object.
    Create a common helper function instead.
    
    Also, use kzalloc() to be safer at creating a group object, and move
    the initialization out of the critical section.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 01b9d62eef14..88a2998f4f9b 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -753,9 +753,7 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 			}
 		}
 		substream->group = &substream->self_group;
-		spin_lock_init(&substream->self_group.lock);
-		mutex_init(&substream->self_group.mutex);
-		INIT_LIST_HEAD(&substream->self_group.substreams);
+		snd_pcm_group_init(&substream->self_group);
 		list_add_tail(&substream->link_list, &substream->self_group.substreams);
 		atomic_set(&substream->mmap_count, 0);
 		prev = substream;

commit 3d21ef0b49f84d3341984caafc5c658739674927
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 15:58:39 2019 +0100

    ALSA: pcm: Suspend streams globally via device type PM ops
    
    Until now we rely on each driver calling snd_pcm_suspend*() explicitly
    at its own PM handling.  However, this can be done far more easily by
    setting the PM ops to each actual snd_pcm device object.
    
    This patch adds the device_type object for PCM stream and assigns to
    each PCM stream object.  The type contains only the PM ops for system
    suspend; we don't need to deal with the resume in general.
    
    The suspend hook simply calls snd_pcm_suspend_all() for the given PCM
    streams.  This implies that the PM order is correctly put, i.e. PCM is
    suspended before the main (or codec) driver, which should be true in
    general.  If a special ordering is needed, you'd need to adjust the
    device PM order manually later.
    
    This patch introduces a new flag, snd_pcm.no_device_suspend, too.
    With this flag set, the PCM device object won't invoke
    snd_pcm_suspend_all() by itself.  This is needed for ASoC who wants to
    manage the PM call orders in its serialized way, and the flag is set
    in soc_new_pcm() as default.
    
    For the non-ASoC world, we can get rid of the manual snd_pcm_suspend
    calls.  This will be done in the later patches.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 01b9d62eef14..ca1ea3cf9350 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -683,6 +683,31 @@ static inline int snd_pcm_substream_proc_done(struct snd_pcm_substream *substrea
 
 static const struct attribute_group *pcm_dev_attr_groups[];
 
+/*
+ * PM callbacks: we need to deal only with suspend here, as the resume is
+ * triggered either from user-space or the driver's resume callback
+ */
+#ifdef CONFIG_PM_SLEEP
+static int do_pcm_suspend(struct device *dev)
+{
+	struct snd_pcm_str *pstr = container_of(dev, struct snd_pcm_str, dev);
+
+	if (!pstr->pcm->no_device_suspend)
+		snd_pcm_suspend_all(pstr->pcm);
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops pcm_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(do_pcm_suspend, NULL)
+};
+
+/* device type for PCM -- basically only for passing PM callbacks */
+static const struct device_type pcm_dev_type = {
+	.name = "pcm",
+	.pm = &pcm_dev_pm_ops,
+};
+
 /**
  * snd_pcm_new_stream - create a new PCM stream
  * @pcm: the pcm instance
@@ -713,6 +738,7 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 
 	snd_device_initialize(&pstr->dev, pcm->card);
 	pstr->dev.groups = pcm_dev_attr_groups;
+	pstr->dev.type = &pcm_dev_type;
 	dev_set_name(&pstr->dev, "pcmC%iD%i%c", pcm->card->number, pcm->device,
 		     stream == SNDRV_PCM_STREAM_PLAYBACK ? 'p' : 'c');
 

commit 94ffb030b6d31ec840bb811be455dd2e26a4f43e
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Wed Dec 12 15:36:28 2018 -0600

    ALSA: pcm: Fix potential Spectre v1 vulnerability
    
    stream is indirectly controlled by user-space, hence leading to
    a potential exploitation of the Spectre variant 1 vulnerability.
    
    This issue was detected with the help of Smatch:
    
    sound/core/pcm.c:140 snd_pcm_control_ioctl() warn: potential spectre issue 'pcm->streams' [r] (local cap)
    
    Fix this by sanitizing stream before using it to index pcm->streams
    
    Notice that given that speculation windows are large, the policy is
    to kill the speculation on the first load and not worry if it can be
    completed with a dependent load/store [1].
    
    [1] https://marc.info/?l=linux-kernel&m=152449131114778&w=2
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index fdb9b92fc8d6..01b9d62eef14 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -25,6 +25,7 @@
 #include <linux/time.h>
 #include <linux/mutex.h>
 #include <linux/device.h>
+#include <linux/nospec.h>
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/pcm.h>
@@ -129,6 +130,7 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 				return -EFAULT;
 			if (stream < 0 || stream > 1)
 				return -EINVAL;
+			stream = array_index_nospec(stream, 2);
 			if (get_user(subdevice, &info->subdevice))
 				return -EFAULT;
 			mutex_lock(&register_mutex);

commit e647f5a5c5d165c87750e8c0dcbe341b5a378ffd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 4 15:08:05 2018 +0200

    ALSA: pcm: Use snd_pcm_stop_xrun() for xrun injection
    
    Basically the xrun injection routine can simply call the standard
    helper snd_pcm_stop_xrun(), but with one exception: it may be called
    even when the stream is closed.
    
    Make snd_pcm_stop_xrun() more robust and check the NULL runtime state,
    and simplify xrun injection code by calling it.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 6f037a4b8b52..fdb9b92fc8d6 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -492,13 +492,8 @@ static void snd_pcm_xrun_injection_write(struct snd_info_entry *entry,
 					 struct snd_info_buffer *buffer)
 {
 	struct snd_pcm_substream *substream = entry->private_data;
-	struct snd_pcm_runtime *runtime;
 
-	snd_pcm_stream_lock_irq(substream);
-	runtime = substream->runtime;
-	if (runtime && runtime->status->state == SNDRV_PCM_STATE_RUNNING)
-		__snd_pcm_xrun(substream);
-	snd_pcm_stream_unlock_irq(substream);
+	snd_pcm_stop_xrun(substream);
 }
 
 static void snd_pcm_xrun_debug_read(struct snd_info_entry *entry,

commit 9cd641ed31f576d08f7b784850ba93eef050f32f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 4 14:46:27 2018 +0200

    ALSA: pcm: trace XRUN event at injection, too
    
    The PCM xrun injection triggers directly snd_pcm_stop() without the
    standard xrun handler, hence it's not recorded on the event buffer.
    Ditto for snd_pcm_stop_xrun() call and SNDRV_PCM_IOCTL_XRUN ioctl.
    They are inconvenient from the debugging POV.
    
    Let's make them to trigger XRUN via the standard helper more
    consistently.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index c352bfb973cc..6f037a4b8b52 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -497,7 +497,7 @@ static void snd_pcm_xrun_injection_write(struct snd_info_entry *entry,
 	snd_pcm_stream_lock_irq(substream);
 	runtime = substream->runtime;
 	if (runtime && runtime->status->state == SNDRV_PCM_STATE_RUNNING)
-		snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
+		__snd_pcm_xrun(substream);
 	snd_pcm_stream_unlock_irq(substream);
 }
 

commit 6a73cf46ce9d1b382ea14d74ce4bc9aa0c52337a
Author: Joe Perches <joe@perches.com>
Date:   Wed May 23 12:20:59 2018 -0700

    sound: Use octal not symbolic permissions
    
    Convert the S_<FOO> symbolic permissions to their octal equivalents as
    using octal and not symbolic permissions is preferred by many as more
    readable.
    
    see: https://lkml.org/lkml/2016/8/2/1945
    
    Done with automated conversion via:
    $ ./scripts/checkpatch.pl -f --types=SYMBOLIC_PERMS --fix-inplace <files...>
    
    Miscellanea:
    
    o Wrapped one multi-line call to a single line
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 66ac89aad681..c352bfb973cc 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -530,7 +530,7 @@ static int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)
 					   pcm->card->proc_root);
 	if (!entry)
 		return -ENOMEM;
-	entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+	entry->mode = S_IFDIR | 0555;
 	if (snd_info_register(entry) < 0) {
 		snd_info_free_entry(entry);
 		return -ENOMEM;
@@ -552,7 +552,7 @@ static int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)
 	if (entry) {
 		entry->c.text.read = snd_pcm_xrun_debug_read;
 		entry->c.text.write = snd_pcm_xrun_debug_write;
-		entry->mode |= S_IWUSR;
+		entry->mode |= 0200;
 		entry->private_data = pstr;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
@@ -590,7 +590,7 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 					   substream->pstr->proc_root);
 	if (!entry)
 		return -ENOMEM;
-	entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+	entry->mode = S_IFDIR | 0555;
 	if (snd_info_register(entry) < 0) {
 		snd_info_free_entry(entry);
 		return -ENOMEM;
@@ -647,7 +647,7 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 		entry->private_data = substream;
 		entry->c.text.read = NULL;
 		entry->c.text.write = snd_pcm_xrun_injection_write;
-		entry->mode = S_IFREG | S_IWUSR;
+		entry->mode = S_IFREG | 0200;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
 			entry = NULL;
@@ -1087,7 +1087,7 @@ static ssize_t show_pcm_class(struct device *dev,
         return snprintf(buf, PAGE_SIZE, "%s\n", str);
 }
 
-static DEVICE_ATTR(pcm_class, S_IRUGO, show_pcm_class, NULL);
+static DEVICE_ATTR(pcm_class, 0444, show_pcm_class, NULL);
 static struct attribute *pcm_dev_attrs[] = {
 	&dev_attr_pcm_class.attr,
 	NULL

commit a820ccbe21e8ce8e86c39cd1d3bc8c7d1cbb949b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 2 22:41:43 2018 +0200

    ALSA: pcm: Fix UAF at PCM release via PCM timer access
    
    The PCM runtime object is created and freed dynamically at PCM stream
    open / close time.  This is tracked via substream->runtime, and it's
    cleared at snd_pcm_detach_substream().
    
    The runtime object assignment is protected by PCM open_mutex, so for
    all PCM operations, it's safely handled.  However, each PCM substream
    provides also an ALSA timer interface, and user-space can access to
    this while closing a PCM substream.  This may eventually lead to a
    UAF, as snd_pcm_timer_resolution() tries to access the runtime while
    clearing it in other side.
    
    Fortunately, it's the only concurrent access from the PCM timer, and
    it merely reads runtime->timer_resolution field.  So, we can avoid the
    race by reordering kfree() and wrapping the substream->runtime
    clearance with the corresponding timer lock.
    
    Reported-by: syzbot+8e62ff4e07aa2ce87826@syzkaller.appspotmail.com
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 09ee8c6b9f75..66ac89aad681 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -28,6 +28,7 @@
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/pcm.h>
+#include <sound/timer.h>
 #include <sound/control.h>
 #include <sound/info.h>
 
@@ -1054,8 +1055,13 @@ void snd_pcm_detach_substream(struct snd_pcm_substream *substream)
 	snd_free_pages((void*)runtime->control,
 		       PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control)));
 	kfree(runtime->hw_constraints.rules);
-	kfree(runtime);
+	/* Avoid concurrent access to runtime via PCM timer interface */
+	if (substream->timer)
+		spin_lock_irq(&substream->timer->lock);
 	substream->runtime = NULL;
+	if (substream->timer)
+		spin_unlock_irq(&substream->timer->lock);
+	kfree(runtime);
 	put_pid(substream->pid);
 	substream->pid = NULL;
 	substream->pstr->substream_opened--;

commit 362bca57f5d78220f8b5907b875961af9436e229
Author: Robb Glasser <rglasser@google.com>
Date:   Tue Dec 5 09:16:55 2017 -0800

    ALSA: pcm: prevent UAF in snd_pcm_info
    
    When the device descriptor is closed, the `substream->runtime` pointer
    is freed. But another thread may be in the ioctl handler, case
    SNDRV_CTL_IOCTL_PCM_INFO. This case calls snd_pcm_info_user() which
    calls snd_pcm_info() which accesses the now freed `substream->runtime`.
    
    Note: this fixes CVE-2017-0861
    
    Signed-off-by: Robb Glasser <rglasser@google.com>
    Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 9070f277f8db..09ee8c6b9f75 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -153,7 +153,9 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 				err = -ENXIO;
 				goto _error;
 			}
+			mutex_lock(&pcm->open_mutex);
 			err = snd_pcm_info_user(substream, info);
+			mutex_unlock(&pcm->open_mutex);
 		_error:
 			mutex_unlock(&register_mutex);
 			return err;

commit 6ca73de7ebc5dac358551633e0c69ab6b5007baa
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 11 11:42:00 2017 +0200

    ALSA: pcm: Forcibly stop at disconnect callback
    
    So far we assumed that each driver implements the hotplug PCM handling
    properly, e.g. dealing with the pending PCM stream at disconnect
    callback.  But most codes don't care, and it eventually leaves the PCM
    stream inconsistent state when an abrupt disconnection like sysfs
    unbind happens.
    
    This patch is simple but a big-hammer solution: invoke snd_pcm_stop()
    at the common PCM disconnect callback always when the stream is
    running.
    
    Tested-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 1b073ed0b1f9..9070f277f8db 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1154,6 +1154,10 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next) {
 			snd_pcm_stream_lock_irq(substream);
 			if (substream->runtime) {
+				if (snd_pcm_running(substream))
+					snd_pcm_stop(substream,
+						     SNDRV_PCM_STATE_DISCONNECTED);
+				/* to be sure, set the state unconditionally */
 				substream->runtime->status->state = SNDRV_PCM_STATE_DISCONNECTED;
 				wake_up(&substream->runtime->sleep);
 				wake_up(&substream->runtime->tsleep);

commit 8b645e4a40dd490b9426670fffe9bb9e2878c3fd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 17 11:40:55 2017 +0200

    ALSA: pcm: Don't call register and disconnect callbacks for internal PCM
    
    The internal PCM (aka DPCM backend PCM) doesn't need any registration
    procedure, thus currently we bail out immediately at dev_register
    callback.  Similarly, its counterpart, dev_disconnect callback, is
    superfluous for the internal PCM.  For simplifying and avoiding the
    conflicting disconnect call for internal PCM objects, this patch drops
    dev_register and dev_disconnect callbacks for the internal ops.
    
    The only uncertain thing by this action is whether skipping the PCM
    state change to SNDRV_PCM_STATE_DISCONNECT for the internal PCM is
    mandatory.  Looking through the current implementations, this doesn't
    look so, hence dropping the whole dev_disconnect would make more
    sense.
    
    Tested-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 7eadb7fd8074..1b073ed0b1f9 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -775,6 +775,9 @@ static int _snd_pcm_new(struct snd_card *card, const char *id, int device,
 		.dev_register =	snd_pcm_dev_register,
 		.dev_disconnect = snd_pcm_dev_disconnect,
 	};
+	static struct snd_device_ops internal_ops = {
+		.dev_free = snd_pcm_dev_free,
+	};
 
 	if (snd_BUG_ON(!card))
 		return -ENXIO;
@@ -801,7 +804,8 @@ static int _snd_pcm_new(struct snd_card *card, const char *id, int device,
 	if (err < 0)
 		goto free_pcm;
 
-	err = snd_device_new(card, SNDRV_DEV_PCM, pcm, &ops);
+	err = snd_device_new(card, SNDRV_DEV_PCM, pcm,
+			     internal ? &internal_ops : &ops);
 	if (err < 0)
 		goto free_pcm;
 
@@ -1099,8 +1103,6 @@ static int snd_pcm_dev_register(struct snd_device *device)
 	if (snd_BUG_ON(!device || !device->device_data))
 		return -ENXIO;
 	pcm = device->device_data;
-	if (pcm->internal)
-		return 0;
 
 	mutex_lock(&register_mutex);
 	err = snd_pcm_add(pcm);
@@ -1159,12 +1161,10 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 			snd_pcm_stream_unlock_irq(substream);
 		}
 	}
-	if (!pcm->internal) {
-		pcm_call_notify(pcm, n_disconnect);
-	}
+
+	pcm_call_notify(pcm, n_disconnect);
 	for (cidx = 0; cidx < 2; cidx++) {
-		if (!pcm->internal)
-			snd_unregister_device(&pcm->streams[cidx].dev);
+		snd_unregister_device(&pcm->streams[cidx].dev);
 		free_chmap(&pcm->streams[cidx]);
 	}
 	mutex_unlock(&pcm->open_mutex);

commit e6b4c525d94e6fb28d5c4b9eb4016caa12f68841
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 24 22:11:07 2017 +0200

    ALSA: pcm: Correct broken procfs set up
    
    The commit c8da9be4a75f ("ALSA: pcm: Adjust nine function calls
    together with a variable assignment") contained a badly incorrect
    conversion, a "status" PCM procfs creation was replaced with the next
    one.  Luckily, this could be spotted easily by the kernel runtime
    warning.
    
    Fixes: c8da9be4a75f ("ALSA: pcm: Adjust nine function calls together...")
    Reported-by: Fabio Estevam <fabio.estevam@nxp.com>
    Tested-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index c790f79e45ae..7eadb7fd8074 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -625,7 +625,8 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 		}
 	}
 	substream->proc_sw_params_entry = entry;
-	entry = snd_info_create_module_entry(THIS_MODULE, "pcm", NULL);
+	entry = snd_info_create_card_entry(card, "status",
+					   substream->proc_root);
 	if (entry) {
 		snd_info_set_text_ops(entry, substream,
 				      snd_pcm_substream_proc_status_read);

commit c8da9be4a75f1f63024a16b976c5be47405c13dc
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Wed Aug 23 09:20:29 2017 +0200

    ALSA: pcm: Adjust nine function calls together with a variable assignment
    
    The script "checkpatch.pl" pointed information out like the following.
    
    ERROR: do not use assignment in if condition
    
    Thus fix the affected source code places.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 048df9658f50..c790f79e45ae 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -523,7 +523,9 @@ static int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)
 
 	sprintf(name, "pcm%i%c", pcm->device, 
 		pstr->stream == SNDRV_PCM_STREAM_PLAYBACK ? 'p' : 'c');
-	if ((entry = snd_info_create_card_entry(pcm->card, name, pcm->card->proc_root)) == NULL)
+	entry = snd_info_create_card_entry(pcm->card, name,
+					   pcm->card->proc_root);
+	if (!entry)
 		return -ENOMEM;
 	entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
 	if (snd_info_register(entry) < 0) {
@@ -531,8 +533,8 @@ static int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)
 		return -ENOMEM;
 	}
 	pstr->proc_root = entry;
-
-	if ((entry = snd_info_create_card_entry(pcm->card, "info", pstr->proc_root)) != NULL) {
+	entry = snd_info_create_card_entry(pcm->card, "info", pstr->proc_root);
+	if (entry) {
 		snd_info_set_text_ops(entry, pstr, snd_pcm_stream_proc_info_read);
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
@@ -542,8 +544,9 @@ static int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)
 	pstr->proc_info_entry = entry;
 
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
-	if ((entry = snd_info_create_card_entry(pcm->card, "xrun_debug",
-						pstr->proc_root)) != NULL) {
+	entry = snd_info_create_card_entry(pcm->card, "xrun_debug",
+					   pstr->proc_root);
+	if (entry) {
 		entry->c.text.read = snd_pcm_xrun_debug_read;
 		entry->c.text.write = snd_pcm_xrun_debug_write;
 		entry->mode |= S_IWUSR;
@@ -580,7 +583,9 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 	card = substream->pcm->card;
 
 	sprintf(name, "sub%i", substream->number);
-	if ((entry = snd_info_create_card_entry(card, name, substream->pstr->proc_root)) == NULL)
+	entry = snd_info_create_card_entry(card, name,
+					   substream->pstr->proc_root);
+	if (!entry)
 		return -ENOMEM;
 	entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
 	if (snd_info_register(entry) < 0) {
@@ -588,8 +593,8 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 		return -ENOMEM;
 	}
 	substream->proc_root = entry;
-
-	if ((entry = snd_info_create_card_entry(card, "info", substream->proc_root)) != NULL) {
+	entry = snd_info_create_card_entry(card, "info", substream->proc_root);
+	if (entry) {
 		snd_info_set_text_ops(entry, substream,
 				      snd_pcm_substream_proc_info_read);
 		if (snd_info_register(entry) < 0) {
@@ -598,8 +603,9 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 		}
 	}
 	substream->proc_info_entry = entry;
-
-	if ((entry = snd_info_create_card_entry(card, "hw_params", substream->proc_root)) != NULL) {
+	entry = snd_info_create_card_entry(card, "hw_params",
+					   substream->proc_root);
+	if (entry) {
 		snd_info_set_text_ops(entry, substream,
 				      snd_pcm_substream_proc_hw_params_read);
 		if (snd_info_register(entry) < 0) {
@@ -608,8 +614,9 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 		}
 	}
 	substream->proc_hw_params_entry = entry;
-
-	if ((entry = snd_info_create_card_entry(card, "sw_params", substream->proc_root)) != NULL) {
+	entry = snd_info_create_card_entry(card, "sw_params",
+					   substream->proc_root);
+	if (entry) {
 		snd_info_set_text_ops(entry, substream,
 				      snd_pcm_substream_proc_sw_params_read);
 		if (snd_info_register(entry) < 0) {
@@ -618,8 +625,8 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 		}
 	}
 	substream->proc_sw_params_entry = entry;
-
-	if ((entry = snd_info_create_card_entry(card, "status", substream->proc_root)) != NULL) {
+	entry = snd_info_create_module_entry(THIS_MODULE, "pcm", NULL);
+	if (entry) {
 		snd_info_set_text_ops(entry, substream,
 				      snd_pcm_substream_proc_status_read);
 		if (snd_info_register(entry) < 0) {
@@ -1230,7 +1237,8 @@ static void snd_pcm_proc_init(void)
 {
 	struct snd_info_entry *entry;
 
-	if ((entry = snd_info_create_module_entry(THIS_MODULE, "pcm", NULL)) != NULL) {
+	entry = snd_info_create_module_entry(THIS_MODULE, "pcm", NULL);
+	if (entry) {
 		snd_info_set_text_ops(entry, NULL, snd_pcm_proc_read);
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);

commit 97d15a141f84a02d40d2ee442df5c6bd2f62b3d8
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Wed Aug 23 08:40:37 2017 +0200

    ALSA: pcm: Use common error handling code in _snd_pcm_new()
    
    Add a jump target so that a bit of exception handling can be better reused
    at the end of this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 89c7485519cb..048df9658f50 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -783,21 +783,27 @@ static int _snd_pcm_new(struct snd_card *card, const char *id, int device,
 	INIT_LIST_HEAD(&pcm->list);
 	if (id)
 		strlcpy(pcm->id, id, sizeof(pcm->id));
-	if ((err = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_PLAYBACK, playback_count)) < 0) {
-		snd_pcm_free(pcm);
-		return err;
-	}
-	if ((err = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_CAPTURE, capture_count)) < 0) {
-		snd_pcm_free(pcm);
-		return err;
-	}
-	if ((err = snd_device_new(card, SNDRV_DEV_PCM, pcm, &ops)) < 0) {
-		snd_pcm_free(pcm);
-		return err;
-	}
+
+	err = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				 playback_count);
+	if (err < 0)
+		goto free_pcm;
+
+	err = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_CAPTURE, capture_count);
+	if (err < 0)
+		goto free_pcm;
+
+	err = snd_device_new(card, SNDRV_DEV_PCM, pcm, &ops);
+	if (err < 0)
+		goto free_pcm;
+
 	if (rpcm)
 		*rpcm = pcm;
 	return 0;
+
+free_pcm:
+	snd_pcm_free(pcm);
+	return err;
 }
 
 /**

commit 343fe850668cc38ba0524aa5880b041b2567ae5c
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Thu Jun 29 16:02:56 2017 +0530

    ALSA: pcm: constify attribute_group structures.
    
    attribute_groups are not supposed to change at runtime. All functions
    working with attribute_groups provided by <linux/device.h> work with const
    attribute_group. So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
       9781     240       8   10029    272d sound/core/pcm.o
    
    File size After adding 'const':
       text    data     bss     dec     hex filename
       9813     176       8    9997    270d sound/core/pcm.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 4b3290447398..89c7485519cb 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1067,7 +1067,7 @@ static struct attribute *pcm_dev_attrs[] = {
 	NULL
 };
 
-static struct attribute_group pcm_dev_attr_group = {
+static const struct attribute_group pcm_dev_attr_group = {
 	.attrs	= pcm_dev_attrs,
 };
 

commit 2c4842d3b6b3cf6db0f21e487da7e9bd3aa23090
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri May 26 09:30:46 2017 +0900

    ALSA: pcm: add local header file for snd-pcm module
    
    Several files are used to construct PCM core module, a.k.a snd-pcm.
    Although available APIs are described in 'include/sound/pcm.h', some of
    them are not exported as symbols in kernel space. Such APIs are just for
    module local usage.
    
    This commit adds module local header file and move some function prototypes
    into it so that scopes of them are controlled properly and developers
    get no confusion from unavailable symbols.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index d30dba0ee688..4b3290447398 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -31,6 +31,8 @@
 #include <sound/control.h>
 #include <sound/info.h>
 
+#include "pcm_local.h"
+
 MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>, Abramo Bagnara <abramo@alsa-project.org>");
 MODULE_DESCRIPTION("Midlevel PCM code for ALSA.");
 MODULE_LICENSE("GPL");

commit 9aee03f39c13fc674f5973baa69d13e32b45b535
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu May 18 15:35:54 2017 +0200

    ALSA: pcm: use "do {} while (0)" for empty macro
    
    Recent compilers produce a harmless warning for the new pcm_call_notify()
    macro when CONFIG_SND_PCM_OSS is disabled:
    
    sound/core/pcm.c: In function 'snd_pcm_free':
    sound/core/pcm.c:905:37: error: suggest braces around empty body in an 'if' statement [-Werror=empty-body]
    
    This turns the empty macro into a 'do {} while (0)' statement to avoid
    the warning.
    
    Fixes: 58f30d650c7f ("ALSA: pcm: Build pcm notifier code conditionally")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 24acbfb5c531..d30dba0ee688 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -894,7 +894,7 @@ static void snd_pcm_free_stream(struct snd_pcm_str * pstr)
 			_notify->call(pcm);				\
 	} while (0)
 #else
-#define pcm_call_notify(pcm, call) /* NOP */
+#define pcm_call_notify(pcm, call) do {} while (0)
 #endif
 
 static int snd_pcm_free(struct snd_pcm *pcm)

commit 58f30d650c7f5275d4d57e62862970e1078af462
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 12 11:35:17 2017 +0200

    ALSA: pcm: Build pcm notifier code conditionally
    
    The PCM notifier code is used only by OSS emulation layer, so we can
    build it conditionally for reducing the size.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 8e980aa678d0..24acbfb5c531 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -36,8 +36,10 @@ MODULE_DESCRIPTION("Midlevel PCM code for ALSA.");
 MODULE_LICENSE("GPL");
 
 static LIST_HEAD(snd_pcm_devices);
-static LIST_HEAD(snd_pcm_notify_list);
 static DEFINE_MUTEX(register_mutex);
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
+static LIST_HEAD(snd_pcm_notify_list);
+#endif
 
 static int snd_pcm_free(struct snd_pcm *pcm);
 static int snd_pcm_dev_free(struct snd_device *device);
@@ -884,16 +886,23 @@ static void snd_pcm_free_stream(struct snd_pcm_str * pstr)
 		put_device(&pstr->dev);
 }
 
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
+#define pcm_call_notify(pcm, call)					\
+	do {								\
+		struct snd_pcm_notify *_notify;				\
+		list_for_each_entry(_notify, &snd_pcm_notify_list, list) \
+			_notify->call(pcm);				\
+	} while (0)
+#else
+#define pcm_call_notify(pcm, call) /* NOP */
+#endif
+
 static int snd_pcm_free(struct snd_pcm *pcm)
 {
-	struct snd_pcm_notify *notify;
-
 	if (!pcm)
 		return 0;
-	if (!pcm->internal) {
-		list_for_each_entry(notify, &snd_pcm_notify_list, list)
-			notify->n_unregister(pcm);
-	}
+	if (!pcm->internal)
+		pcm_call_notify(pcm, n_unregister);
 	if (pcm->private_free)
 		pcm->private_free(pcm);
 	snd_pcm_lib_preallocate_free_for_all(pcm);
@@ -1069,7 +1078,6 @@ static int snd_pcm_dev_register(struct snd_device *device)
 {
 	int cidx, err;
 	struct snd_pcm_substream *substream;
-	struct snd_pcm_notify *notify;
 	struct snd_pcm *pcm;
 
 	if (snd_BUG_ON(!device || !device->device_data))
@@ -1107,8 +1115,7 @@ static int snd_pcm_dev_register(struct snd_device *device)
 			snd_pcm_timer_init(substream);
 	}
 
-	list_for_each_entry(notify, &snd_pcm_notify_list, list)
-		notify->n_register(pcm);
+	pcm_call_notify(pcm, n_register);
 
  unlock:
 	mutex_unlock(&register_mutex);
@@ -1118,7 +1125,6 @@ static int snd_pcm_dev_register(struct snd_device *device)
 static int snd_pcm_dev_disconnect(struct snd_device *device)
 {
 	struct snd_pcm *pcm = device->device_data;
-	struct snd_pcm_notify *notify;
 	struct snd_pcm_substream *substream;
 	int cidx;
 
@@ -1138,8 +1144,7 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 		}
 	}
 	if (!pcm->internal) {
-		list_for_each_entry(notify, &snd_pcm_notify_list, list)
-			notify->n_disconnect(pcm);
+		pcm_call_notify(pcm, n_disconnect);
 	}
 	for (cidx = 0; cidx < 2; cidx++) {
 		if (!pcm->internal)
@@ -1151,6 +1156,7 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 	return 0;
 }
 
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
 /**
  * snd_pcm_notify - Add/remove the notify list
  * @notify: PCM notify list
@@ -1183,6 +1189,7 @@ int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 	return 0;
 }
 EXPORT_SYMBOL(snd_pcm_notify);
+#endif /* CONFIG_SND_PCM_OSS */
 
 #ifdef CONFIG_SND_PROC_FS
 /*

commit a8ff48cb70835f48de5703052760312019afea55
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jul 8 08:23:43 2016 +0200

    ALSA: pcm: Free chmap at PCM free callback, too
    
    The chmap ctls assigned to PCM streams are freed in the PCM disconnect
    callback.  However, since the disconnect callback isn't called when
    the card gets freed before registering, the chmap ctls may still be
    left assigned.  They are eventually freed together with other ctls,
    but it may cause an Oops at pcm_chmap_ctl_private_free(), as the
    function refers to the assigned PCM stream, while the PCM objects have
    been already freed beforehand.
    
    The fix is to free the chmap ctls also at PCM free callback, not only
    at PCM disconnect.
    
    Reported-by: Laxminath Kasam <b_lkasam@codeaurora.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 308c9ecf73db..8e980aa678d0 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -849,6 +849,14 @@ int snd_pcm_new_internal(struct snd_card *card, const char *id, int device,
 }
 EXPORT_SYMBOL(snd_pcm_new_internal);
 
+static void free_chmap(struct snd_pcm_str *pstr)
+{
+	if (pstr->chmap_kctl) {
+		snd_ctl_remove(pstr->pcm->card, pstr->chmap_kctl);
+		pstr->chmap_kctl = NULL;
+	}
+}
+
 static void snd_pcm_free_stream(struct snd_pcm_str * pstr)
 {
 	struct snd_pcm_substream *substream, *substream_next;
@@ -871,6 +879,7 @@ static void snd_pcm_free_stream(struct snd_pcm_str * pstr)
 		kfree(setup);
 	}
 #endif
+	free_chmap(pstr);
 	if (pstr->substream_count)
 		put_device(&pstr->dev);
 }
@@ -1135,10 +1144,7 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 	for (cidx = 0; cidx < 2; cidx++) {
 		if (!pcm->internal)
 			snd_unregister_device(&pcm->streams[cidx].dev);
-		if (pcm->streams[cidx].chmap_kctl) {
-			snd_ctl_remove(pcm->card, pcm->streams[cidx].chmap_kctl);
-			pcm->streams[cidx].chmap_kctl = NULL;
-		}
+		free_chmap(&pcm->streams[cidx]);
 	}
 	mutex_unlock(&pcm->open_mutex);
 	mutex_unlock(&register_mutex);

commit 0052b7dcf9d9ec6be4fc3fe815a2ceda623bb9d1
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Sun Sep 13 19:00:05 2015 +0900

    ALSA: pcm: remove structure member of 'struct snd_pcm_hwptr_log *' type because this structure had been removed
    
    This structure was added by 4d96eb255c53 ('ALSA: pcm_lib - add possibility
    to log last 10 DMA ring buffer positions') to store PCM pointers
    information of latest 10 pointer movements (=XRUN_LOG_CNT). When
    CONFIG_SND_PCM_XRUN_DEBUG is configured, 'struct snd_pcm_runtime' has
    'hwptr_log' member with a pointer to the structure. When calling
    xrun_log() in pcm_lib.c, the structure was allocated to the pointer.
    When calling snd_pcm_detach_substream() in pcm.c, the allocated pointer
    is released.
    
    In f5914908a5b7 ('ALSA: pcm: Replace PCM hwptr tracking with tracepoints'),
    the pointer logging is replaced with using Linux Kernel Tracepoints. The
    structure was also removed, while it's just declared. The member and kfree
    still remains.
    
    This commit removes the member and related codes. I think this was
    overlooked because it brings no errors/warnings to C compilers.
    
    Fixes: f5914908a5b7 ('ALSA: pcm: Replace PCM hwptr tracking with tracepoints')
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 02bd96954dc4..308c9ecf73db 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1014,9 +1014,6 @@ void snd_pcm_detach_substream(struct snd_pcm_substream *substream)
 	snd_free_pages((void*)runtime->control,
 		       PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control)));
 	kfree(runtime->hw_constraints.rules);
-#ifdef CONFIG_SND_PCM_XRUN_DEBUG
-	kfree(runtime->hwptr_log);
-#endif
 	kfree(runtime);
 	substream->runtime = NULL;
 	put_pid(substream->pid);

commit 60b93030b44a8c2cd015cebe5624fd7552ec67ec
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 23 11:56:22 2015 +0200

    ALSA: pcm: Fix pcm_class sysfs output
    
    The pcm_class sysfs of each PCM substream gives only "none" since the
    recent code change to embed the struct device.  Fix the code to point
    directly to the embedded device object properly.
    
    Fixes: ef46c7af93f9 ('ALSA: pcm: Embed struct device')
    Cc: <stable@vger.kernel.org> # v4.0+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index e53794319ef3..02bd96954dc4 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1027,7 +1027,8 @@ void snd_pcm_detach_substream(struct snd_pcm_substream *substream)
 static ssize_t show_pcm_class(struct device *dev,
 			      struct device_attribute *attr, char *buf)
 {
-	struct snd_pcm *pcm;
+	struct snd_pcm_str *pstr = container_of(dev, struct snd_pcm_str, dev);
+	struct snd_pcm *pcm = pstr->pcm;
 	const char *str;
 	static const char *strs[SNDRV_PCM_CLASS_LAST + 1] = {
 		[SNDRV_PCM_CLASS_GENERIC] = "generic",
@@ -1036,8 +1037,7 @@ static ssize_t show_pcm_class(struct device *dev,
 		[SNDRV_PCM_CLASS_DIGITIZER] = "digitizer",
 	};
 
-	if (! (pcm = dev_get_drvdata(dev)) ||
-	    pcm->dev_class > SNDRV_PCM_CLASS_LAST)
+	if (pcm->dev_class > SNDRV_PCM_CLASS_LAST)
 		str = "none";
 	else
 		str = strs[pcm->dev_class];

commit cd6a65036f0eac4ad83dc371bb458e9e6ba6e306
Author: Jie Yang <yang.jie@intel.com>
Date:   Wed May 27 19:45:45 2015 +0800

    ALSA: replace CONFIG_PROC_FS with CONFIG_SND_PROC_FS
    
    We may disable proc fs only for sound part, to reduce ALSA
    memory footprint. So add CONFIG_SND_PROC_FS and replace the
    old CONFIG_PROC_FSs in alsa code.
    
    With sound proc fs disabled, we can save about 9KB memory
    size on X86_64 platform.
    
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index b25bcf5b8644..e53794319ef3 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1181,7 +1181,7 @@ int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 }
 EXPORT_SYMBOL(snd_pcm_notify);
 
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_SND_PROC_FS
 /*
  *  Info interface
  */
@@ -1227,10 +1227,10 @@ static void snd_pcm_proc_done(void)
 	snd_info_free_entry(snd_pcm_proc_entry);
 }
 
-#else /* !CONFIG_PROC_FS */
+#else /* !CONFIG_SND_PROC_FS */
 #define snd_pcm_proc_init()
 #define snd_pcm_proc_done()
-#endif /* CONFIG_PROC_FS */
+#endif /* CONFIG_SND_PROC_FS */
 
 
 /*

commit ec0e9937aaa8b0a4b0633711c4d70d622acd9a7f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 10 15:42:14 2015 +0100

    ALSA: core: Drop superfluous error/debug messages after malloc failures
    
    The kernel memory allocators already report the errors when the
    requested allocation fails, thus we don't need to warn it again in
    each caller side.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index e9b87465c73d..b25bcf5b8644 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -343,11 +343,8 @@ static void snd_pcm_proc_info_read(struct snd_pcm_substream *substream,
 		return;
 
 	info = kmalloc(sizeof(*info), GFP_KERNEL);
-	if (! info) {
-		pcm_dbg(substream->pcm,
-			"snd_pcm_proc_info_read: cannot malloc\n");
+	if (!info)
 		return;
-	}
 
 	err = snd_pcm_info(substream, info);
 	if (err < 0) {
@@ -717,10 +714,8 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 	prev = NULL;
 	for (idx = 0, prev = NULL; idx < substream_count; idx++) {
 		substream = kzalloc(sizeof(*substream), GFP_KERNEL);
-		if (substream == NULL) {
-			pcm_err(pcm, "Cannot allocate PCM substream\n");
+		if (!substream)
 			return -ENOMEM;
-		}
 		substream->pcm = pcm;
 		substream->pstr = pstr;
 		substream->number = idx;
@@ -774,10 +769,8 @@ static int _snd_pcm_new(struct snd_card *card, const char *id, int device,
 	if (rpcm)
 		*rpcm = NULL;
 	pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
-	if (pcm == NULL) {
-		dev_err(card->dev, "Cannot allocate PCM\n");
+	if (!pcm)
 		return -ENOMEM;
-	}
 	pcm->card = card;
 	pcm->device = device;
 	pcm->internal = internal;

commit b20221385c40155f13068be75b865170a1ad5d1e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 20 17:05:27 2015 +0100

    ALSA: pcm: Don't ignore internal PCMs in snd_pcm_dev_disconnect()
    
    Some codes in snd_pcm_dev_disconnect() are still valid even for
    internal PCMs, but they are skipped because of the check of
    list_empty(&pcm->list) at the beginning.  Remove this check and put
    pcm->internal checks appropriately for internal PCM object to process
    through this function.
    
    Acked-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 542dbc6f54e8..e9b87465c73d 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1124,9 +1124,6 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 	int cidx;
 
 	mutex_lock(&register_mutex);
-	if (list_empty(&pcm->list))
-		goto unlock;
-
 	mutex_lock(&pcm->open_mutex);
 	wake_up(&pcm->open_wait);
 	list_del_init(&pcm->list);
@@ -1146,14 +1143,14 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 			notify->n_disconnect(pcm);
 	}
 	for (cidx = 0; cidx < 2; cidx++) {
-		snd_unregister_device(&pcm->streams[cidx].dev);
+		if (!pcm->internal)
+			snd_unregister_device(&pcm->streams[cidx].dev);
 		if (pcm->streams[cidx].chmap_kctl) {
 			snd_ctl_remove(pcm->card, pcm->streams[cidx].chmap_kctl);
 			pcm->streams[cidx].chmap_kctl = NULL;
 		}
 	}
 	mutex_unlock(&pcm->open_mutex);
- unlock:
 	mutex_unlock(&register_mutex);
 	return 0;
 }

commit 646e1dd8f9f47c57560ce81c02fdd57ff0929bc6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 20 17:04:08 2015 +0100

    ALSA: pcm: Don't notify internal PCMs
    
    Notifier shouldn't listen to the changes of internal PCMs.
    
    Acked-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index d440629e08e2..542dbc6f54e8 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -888,8 +888,9 @@ static int snd_pcm_free(struct snd_pcm *pcm)
 
 	if (!pcm)
 		return 0;
-	list_for_each_entry(notify, &snd_pcm_notify_list, list) {
-		notify->n_unregister(pcm);
+	if (!pcm->internal) {
+		list_for_each_entry(notify, &snd_pcm_notify_list, list)
+			notify->n_unregister(pcm);
 	}
 	if (pcm->private_free)
 		pcm->private_free(pcm);
@@ -1129,7 +1130,7 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 	mutex_lock(&pcm->open_mutex);
 	wake_up(&pcm->open_wait);
 	list_del_init(&pcm->list);
-	for (cidx = 0; cidx < 2; cidx++)
+	for (cidx = 0; cidx < 2; cidx++) {
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next) {
 			snd_pcm_stream_lock_irq(substream);
 			if (substream->runtime) {
@@ -1139,8 +1140,10 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 			}
 			snd_pcm_stream_unlock_irq(substream);
 		}
-	list_for_each_entry(notify, &snd_pcm_notify_list, list) {
-		notify->n_disconnect(pcm);
+	}
+	if (!pcm->internal) {
+		list_for_each_entry(notify, &snd_pcm_notify_list, list)
+			notify->n_disconnect(pcm);
 	}
 	for (cidx = 0; cidx < 2; cidx++) {
 		snd_unregister_device(&pcm->streams[cidx].dev);

commit b95bd3a454cf9e9e111b6b87c02550368fe6e802
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 20 16:49:04 2015 +0100

    ALSA: pcm: Don't add internal PCMs to PCM device list
    
    An internal PCM object shouldn't be added to the PCM device list, as
    it's never accessed directly from the user-space, and it has no proc
    or any similar accesses.  Currently, it's excluded in snd_pcm_get()
    and snd_pcm_next(), but it's easier not to add such an object to the
    list.
    
    Actually, the whole snd_pcm_dev_register() can be skipped for an
    internal PCM.  So this patch changes the code there, but also
    addresses the uninitialized list_head access.
    
    Acked-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index d63d262c571e..d440629e08e2 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -49,8 +49,6 @@ static struct snd_pcm *snd_pcm_get(struct snd_card *card, int device)
 	struct snd_pcm *pcm;
 
 	list_for_each_entry(pcm, &snd_pcm_devices, list) {
-		if (pcm->internal)
-			continue;
 		if (pcm->card == card && pcm->device == device)
 			return pcm;
 	}
@@ -62,8 +60,6 @@ static int snd_pcm_next(struct snd_card *card, int device)
 	struct snd_pcm *pcm;
 
 	list_for_each_entry(pcm, &snd_pcm_devices, list) {
-		if (pcm->internal)
-			continue;
 		if (pcm->card == card && pcm->device > device)
 			return pcm->device;
 		else if (pcm->card->number > card->number)
@@ -76,6 +72,9 @@ static int snd_pcm_add(struct snd_pcm *newpcm)
 {
 	struct snd_pcm *pcm;
 
+	if (newpcm->internal)
+		return 0;
+
 	list_for_each_entry(pcm, &snd_pcm_devices, list) {
 		if (pcm->card == newpcm->card && pcm->device == newpcm->device)
 			return -EBUSY;
@@ -782,6 +781,9 @@ static int _snd_pcm_new(struct snd_card *card, const char *id, int device,
 	pcm->card = card;
 	pcm->device = device;
 	pcm->internal = internal;
+	mutex_init(&pcm->open_mutex);
+	init_waitqueue_head(&pcm->open_wait);
+	INIT_LIST_HEAD(&pcm->list);
 	if (id)
 		strlcpy(pcm->id, id, sizeof(pcm->id));
 	if ((err = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_PLAYBACK, playback_count)) < 0) {
@@ -792,8 +794,6 @@ static int _snd_pcm_new(struct snd_card *card, const char *id, int device,
 		snd_pcm_free(pcm);
 		return err;
 	}
-	mutex_init(&pcm->open_mutex);
-	init_waitqueue_head(&pcm->open_wait);
 	if ((err = snd_device_new(card, SNDRV_DEV_PCM, pcm, &ops)) < 0) {
 		snd_pcm_free(pcm);
 		return err;
@@ -1075,15 +1075,16 @@ static int snd_pcm_dev_register(struct snd_device *device)
 	if (snd_BUG_ON(!device || !device->device_data))
 		return -ENXIO;
 	pcm = device->device_data;
+	if (pcm->internal)
+		return 0;
+
 	mutex_lock(&register_mutex);
 	err = snd_pcm_add(pcm);
-	if (err) {
-		mutex_unlock(&register_mutex);
-		return err;
-	}
+	if (err)
+		goto unlock;
 	for (cidx = 0; cidx < 2; cidx++) {
 		int devtype = -1;
-		if (pcm->streams[cidx].substream == NULL || pcm->internal)
+		if (pcm->streams[cidx].substream == NULL)
 			continue;
 		switch (cidx) {
 		case SNDRV_PCM_STREAM_PLAYBACK:
@@ -1098,9 +1099,8 @@ static int snd_pcm_dev_register(struct snd_device *device)
 					  &snd_pcm_f_ops[cidx], pcm,
 					  &pcm->streams[cidx].dev);
 		if (err < 0) {
-			list_del(&pcm->list);
-			mutex_unlock(&register_mutex);
-			return err;
+			list_del_init(&pcm->list);
+			goto unlock;
 		}
 
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
@@ -1110,8 +1110,9 @@ static int snd_pcm_dev_register(struct snd_device *device)
 	list_for_each_entry(notify, &snd_pcm_notify_list, list)
 		notify->n_register(pcm);
 
+ unlock:
 	mutex_unlock(&register_mutex);
-	return 0;
+	return err;
 }
 
 static int snd_pcm_dev_disconnect(struct snd_device *device)

commit ad876c862278be59147d4004f1a7c4d492e4ec96
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 20 16:26:00 2015 +0100

    ALSA: pcm: Minor refactoring in snd_pcm_attach_substream()
    
    No functional changes at all.
    
    Acked-by: Liam Girdwood <liam.r.girdwood@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 0345e53a340c..d63d262c571e 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -919,6 +919,9 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 
 	if (snd_BUG_ON(!pcm || !rsubstream))
 		return -ENXIO;
+	if (snd_BUG_ON(stream != SNDRV_PCM_STREAM_PLAYBACK &&
+		       stream != SNDRV_PCM_STREAM_CAPTURE))
+		return -EINVAL;
 	*rsubstream = NULL;
 	pstr = &pcm->streams[stream];
 	if (pstr->substream == NULL || pstr->substream_count == 0)
@@ -927,25 +930,14 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 	card = pcm->card;
 	prefer_subdevice = snd_ctl_get_preferred_subdevice(card, SND_CTL_SUBDEV_PCM);
 
-	switch (stream) {
-	case SNDRV_PCM_STREAM_PLAYBACK:
-		if (pcm->info_flags & SNDRV_PCM_INFO_HALF_DUPLEX) {
-			for (substream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream; substream; substream = substream->next) {
-				if (SUBSTREAM_BUSY(substream))
-					return -EAGAIN;
-			}
-		}
-		break;
-	case SNDRV_PCM_STREAM_CAPTURE:
-		if (pcm->info_flags & SNDRV_PCM_INFO_HALF_DUPLEX) {
-			for (substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; substream; substream = substream->next) {
-				if (SUBSTREAM_BUSY(substream))
-					return -EAGAIN;
-			}
+	if (pcm->info_flags & SNDRV_PCM_INFO_HALF_DUPLEX) {
+		int opposite = !stream;
+
+		for (substream = pcm->streams[opposite].substream; substream;
+		     substream = substream->next) {
+			if (SUBSTREAM_BUSY(substream))
+				return -EAGAIN;
 		}
-		break;
-	default:
-		return -EINVAL;
 	}
 
 	if (file->f_flags & O_APPEND) {
@@ -968,15 +960,12 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 		return 0;
 	}
 
-	if (prefer_subdevice >= 0) {
-		for (substream = pstr->substream; substream; substream = substream->next)
-			if (!SUBSTREAM_BUSY(substream) && substream->number == prefer_subdevice)
-				goto __ok;
-	}
-	for (substream = pstr->substream; substream; substream = substream->next)
-		if (!SUBSTREAM_BUSY(substream))
+	for (substream = pstr->substream; substream; substream = substream->next) {
+		if (!SUBSTREAM_BUSY(substream) &&
+		    (prefer_subdevice == -1 ||
+		     substream->number == prefer_subdevice))
 			break;
-      __ok:
+	}
 	if (substream == NULL)
 		return -EAGAIN;
 

commit 40a4b263854346fe7c7d1c3964c106296f690816
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 30 08:34:58 2015 +0100

    ALSA: Simplify snd_device_register() variants
    
    Now that all callers have been replaced with
    snd_device_register_for_dev(), let's drop the obsolete device
    registration code and concentrate only on the code handling struct
    device directly.  That said,
    
    - remove the old snd_device_register(),
    - rename snd_device_register_for_dev() with snd_device_register(),
    - drop superfluous arguments from snd_device_register(),
    - change snd_unregister_device() to pass the device pointer directly
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 4d5120f7a8ab..0345e53a340c 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1105,11 +1105,9 @@ static int snd_pcm_dev_register(struct snd_device *device)
 			break;
 		}
 		/* register pcm */
-		err = snd_register_device_for_dev(devtype, pcm->card,
-						  pcm->device,
-						  &snd_pcm_f_ops[cidx],
-						  pcm, &pcm->streams[cidx].dev,
-						  NULL, NULL);
+		err = snd_register_device(devtype, pcm->card, pcm->device,
+					  &snd_pcm_f_ops[cidx], pcm,
+					  &pcm->streams[cidx].dev);
 		if (err < 0) {
 			list_del(&pcm->list);
 			mutex_unlock(&register_mutex);
@@ -1132,7 +1130,7 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 	struct snd_pcm *pcm = device->device_data;
 	struct snd_pcm_notify *notify;
 	struct snd_pcm_substream *substream;
-	int cidx, devtype;
+	int cidx;
 
 	mutex_lock(&register_mutex);
 	if (list_empty(&pcm->list))
@@ -1155,16 +1153,7 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 		notify->n_disconnect(pcm);
 	}
 	for (cidx = 0; cidx < 2; cidx++) {
-		devtype = -1;
-		switch (cidx) {
-		case SNDRV_PCM_STREAM_PLAYBACK:
-			devtype = SNDRV_DEVICE_TYPE_PCM_PLAYBACK;
-			break;
-		case SNDRV_PCM_STREAM_CAPTURE:
-			devtype = SNDRV_DEVICE_TYPE_PCM_CAPTURE;
-			break;
-		}
-		snd_unregister_device(devtype, pcm->card, pcm->device);
+		snd_unregister_device(&pcm->streams[cidx].dev);
 		if (pcm->streams[cidx].chmap_kctl) {
 			snd_ctl_remove(pcm->card, pcm->streams[cidx].chmap_kctl);
 			pcm->streams[cidx].chmap_kctl = NULL;

commit ef46c7af93f98d07cd0ed891f93a26d135785526
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 29 17:32:26 2015 +0100

    ALSA: pcm: Embed struct device
    
    Like previous patches, at this time we embed the struct device into
    PCM object.  However, this needs a bit more caution: struct snd_pcm
    doesn't own one device but two, for both playback and capture!  Thus
    not struct snd_pcm but struct snd_pcm_str object contains the device.
    
    Along with this change, pcm->dev field is dropped for avoiding
    confusion.  It was meant to point to a non-standard parent.  But,
    since now we can touch each struct device directly, we can manipulate
    the parent field easily there, too.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 1b7c473720fa..4d5120f7a8ab 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -673,6 +673,8 @@ static inline int snd_pcm_substream_proc_init(struct snd_pcm_substream *substrea
 static inline int snd_pcm_substream_proc_done(struct snd_pcm_substream *substream) { return 0; }
 #endif /* CONFIG_SND_VERBOSE_PROCFS */
 
+static const struct attribute_group *pcm_dev_attr_groups[];
+
 /**
  * snd_pcm_new_stream - create a new PCM stream
  * @pcm: the pcm instance
@@ -698,7 +700,15 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 	pstr->stream = stream;
 	pstr->pcm = pcm;
 	pstr->substream_count = substream_count;
-	if (substream_count > 0 && !pcm->internal) {
+	if (!substream_count)
+		return 0;
+
+	snd_device_initialize(&pstr->dev, pcm->card);
+	pstr->dev.groups = pcm_dev_attr_groups;
+	dev_set_name(&pstr->dev, "pcmC%iD%i%c", pcm->card->number, pcm->device,
+		     stream == SNDRV_PCM_STREAM_PLAYBACK ? 'p' : 'c');
+
+	if (!pcm->internal) {
 		err = snd_pcm_stream_proc_init(pstr);
 		if (err < 0) {
 			pcm_err(pcm, "Error in snd_pcm_stream_proc_init\n");
@@ -868,6 +878,8 @@ static void snd_pcm_free_stream(struct snd_pcm_str * pstr)
 		kfree(setup);
 	}
 #endif
+	if (pstr->substream_count)
+		put_device(&pstr->dev);
 }
 
 static int snd_pcm_free(struct snd_pcm *pcm)
@@ -1069,9 +1081,7 @@ static int snd_pcm_dev_register(struct snd_device *device)
 	int cidx, err;
 	struct snd_pcm_substream *substream;
 	struct snd_pcm_notify *notify;
-	char str[16];
 	struct snd_pcm *pcm;
-	struct device *dev;
 
 	if (snd_BUG_ON(!device || !device->device_data))
 		return -ENXIO;
@@ -1088,42 +1098,24 @@ static int snd_pcm_dev_register(struct snd_device *device)
 			continue;
 		switch (cidx) {
 		case SNDRV_PCM_STREAM_PLAYBACK:
-			sprintf(str, "pcmC%iD%ip", pcm->card->number, pcm->device);
 			devtype = SNDRV_DEVICE_TYPE_PCM_PLAYBACK;
 			break;
 		case SNDRV_PCM_STREAM_CAPTURE:
-			sprintf(str, "pcmC%iD%ic", pcm->card->number, pcm->device);
 			devtype = SNDRV_DEVICE_TYPE_PCM_CAPTURE;
 			break;
 		}
-		/* device pointer to use, pcm->dev takes precedence if
-		 * it is assigned, otherwise fall back to card's device
-		 * if possible */
-		dev = pcm->dev;
-		if (!dev)
-			dev = snd_card_get_device_link(pcm->card);
 		/* register pcm */
 		err = snd_register_device_for_dev(devtype, pcm->card,
 						  pcm->device,
 						  &snd_pcm_f_ops[cidx],
-						  pcm, NULL, dev, str);
+						  pcm, &pcm->streams[cidx].dev,
+						  NULL, NULL);
 		if (err < 0) {
 			list_del(&pcm->list);
 			mutex_unlock(&register_mutex);
 			return err;
 		}
 
-		dev = snd_get_device(devtype, pcm->card, pcm->device);
-		if (dev) {
-			err = sysfs_create_groups(&dev->kobj,
-						  pcm_dev_attr_groups);
-			if (err < 0)
-				dev_warn(dev,
-					 "pcm %d:%d: cannot create sysfs groups\n",
-					 pcm->card->number, pcm->device);
-			put_device(dev);
-		}
-
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
 			snd_pcm_timer_init(substream);
 	}

commit 23c18d4bfd73ee24070849faf98b3ab01263a3c4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 19 14:30:29 2014 +0100

    ALSA: control: Provide a helper to look for the preferred subdevice
    
    Instead of open-coding the search over the control file loop, provide
    a helper function for the preferred subdevice assigned to the current
    process.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index dba5180e5b80..1b7c473720fa 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -161,7 +161,7 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 			
 			if (get_user(val, (int __user *)arg))
 				return -EFAULT;
-			control->prefer_pcm_subdevice = val;
+			control->preferred_subdevice[SND_CTL_SUBDEV_PCM] = val;
 			return 0;
 		}
 	}
@@ -901,9 +901,8 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 	struct snd_pcm_str * pstr;
 	struct snd_pcm_substream *substream;
 	struct snd_pcm_runtime *runtime;
-	struct snd_ctl_file *kctl;
 	struct snd_card *card;
-	int prefer_subdevice = -1;
+	int prefer_subdevice;
 	size_t size;
 
 	if (snd_BUG_ON(!pcm || !rsubstream))
@@ -914,15 +913,7 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 		return -ENODEV;
 
 	card = pcm->card;
-	read_lock(&card->ctl_files_rwlock);
-	list_for_each_entry(kctl, &card->ctl_files, list) {
-		if (kctl->pid == task_pid(current)) {
-			prefer_subdevice = kctl->prefer_pcm_subdevice;
-			if (prefer_subdevice != -1)
-				break;
-		}
-	}
-	read_unlock(&card->ctl_files_rwlock);
+	prefer_subdevice = snd_ctl_get_preferred_subdevice(card, SND_CTL_SUBDEV_PCM);
 
 	switch (stream) {
 	case SNDRV_PCM_STREAM_PLAYBACK:

commit 92b7952da8279189aad352efbf9f2e7001de9524
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 29 15:53:51 2015 +0100

    ALSA: Allow to pass the device object to snd_register_device*()
    
    This is a preliminary patch for the further work on embedding struct
    device into each sound device instance.  It changes
    snd_register_device*() helpers to receive the device object directly
    for skipping creating a device there.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index cfc56c806964..dba5180e5b80 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1115,7 +1115,7 @@ static int snd_pcm_dev_register(struct snd_device *device)
 		err = snd_register_device_for_dev(devtype, pcm->card,
 						  pcm->device,
 						  &snd_pcm_f_ops[cidx],
-						  pcm, str, dev);
+						  pcm, NULL, dev, str);
 		if (err < 0) {
 			list_del(&pcm->list);
 			mutex_unlock(&register_mutex);

commit 50314663877b3c5f08b2573c0bb161b6a2c63c3e
Merge: 6874daad4b0f d42472ecffd7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 28 18:30:19 2014 +0100

    Merge branch 'for-linus' into for-next
    
    The commit [7a2e9ddc: ALSA: usb-audio: Add native DSD support for
    Denon/Marantz DACs] requires the new format definition that has
    landed only in for-next branch.

commit d42472ecffd7c42086c6e5b1335c99a3adf58a09
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Fri Nov 21 16:04:46 2014 +0200

    ALSA: pcm: Add big-endian DSD sample formats and fix XMOS DSD sample format
    
    This patch fixes XMOS DSD sample format to DSD_U32_BE and also adds
    DSD_U16_BE and DSD_U32_BE sample formats.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Acked-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 42ded997b223..c6ff94ab1ad6 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -216,6 +216,8 @@ static char *snd_pcm_format_names[] = {
 	FORMAT(DSD_U8),
 	FORMAT(DSD_U16_LE),
 	FORMAT(DSD_U32_LE),
+	FORMAT(DSD_U16_BE),
+	FORMAT(DSD_U32_BE),
 };
 
 const char *snd_pcm_format_name(snd_pcm_format_t format)

commit 2b30d411dbc6eddfb5b4f9afd5a2c57b6f4dd96c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 4 14:02:40 2014 +0100

    ALSA: pcm: Add xrun_injection proc entry
    
    This patch adds a new proc entry for PCM substreams to inject an
    XRUN.  When a PCM substream is running and any value is written to its
    xrun_injection proc file, the driver triggers XRUN.  This is a useful
    feature for debugging XRUN and error handling code paths.
    
    Note that this entry is enabled only when CONFIG_SND_PCM_XRUN_DEBUG is
    set.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 31acc3df62cd..8f624b7af0ca 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -483,6 +483,19 @@ static void snd_pcm_substream_proc_status_read(struct snd_info_entry *entry,
 }
 
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
+static void snd_pcm_xrun_injection_write(struct snd_info_entry *entry,
+					 struct snd_info_buffer *buffer)
+{
+	struct snd_pcm_substream *substream = entry->private_data;
+	struct snd_pcm_runtime *runtime;
+
+	snd_pcm_stream_lock_irq(substream);
+	runtime = substream->runtime;
+	if (runtime && runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+		snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
+	snd_pcm_stream_unlock_irq(substream);
+}
+
 static void snd_pcm_xrun_debug_read(struct snd_info_entry *entry,
 				    struct snd_info_buffer *buffer)
 {
@@ -614,6 +627,22 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 	}
 	substream->proc_status_entry = entry;
 
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
+	entry = snd_info_create_card_entry(card, "xrun_injection",
+					   substream->proc_root);
+	if (entry) {
+		entry->private_data = substream;
+		entry->c.text.read = NULL;
+		entry->c.text.write = snd_pcm_xrun_injection_write;
+		entry->mode = S_IFREG | S_IWUSR;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	substream->proc_xrun_injection_entry = entry;
+#endif /* CONFIG_SND_PCM_XRUN_DEBUG */
+
 	return 0;
 }
 
@@ -627,6 +656,10 @@ static int snd_pcm_substream_proc_done(struct snd_pcm_substream *substream)
 	substream->proc_sw_params_entry = NULL;
 	snd_info_free_entry(substream->proc_status_entry);
 	substream->proc_status_entry = NULL;
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
+	snd_info_free_entry(substream->proc_xrun_injection_entry);
+	substream->proc_xrun_injection_entry = NULL;
+#endif
 	snd_info_free_entry(substream->proc_root);
 	substream->proc_root = NULL;
 	return 0;

commit 30b771cf8c3120c5c946811ecc5a9b87a34003a2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 30 15:02:50 2014 +0100

    ALSA: pcm: More kerneldoc updates
    
    Add proper kerneldoc comments to the exported functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 42ded997b223..31acc3df62cd 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -218,6 +218,10 @@ static char *snd_pcm_format_names[] = {
 	FORMAT(DSD_U32_LE),
 };
 
+/**
+ * snd_pcm_format_name - Return a name string for the given PCM format
+ * @format: PCM format
+ */
 const char *snd_pcm_format_name(snd_pcm_format_t format)
 {
 	if ((__force unsigned int)format >= ARRAY_SIZE(snd_pcm_format_names))
@@ -707,7 +711,6 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 	}
 	return 0;
 }				
-
 EXPORT_SYMBOL(snd_pcm_new_stream);
 
 static int _snd_pcm_new(struct snd_card *card, const char *id, int device,
@@ -1155,6 +1158,15 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 	return 0;
 }
 
+/**
+ * snd_pcm_notify - Add/remove the notify list
+ * @notify: PCM notify list
+ * @nfree: 0 = register, 1 = unregister
+ *
+ * This adds the given notifier to the global list so that the callback is
+ * called for each registered PCM devices.  This exists only for PCM OSS
+ * emulation, so far.
+ */
 int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 {
 	struct snd_pcm *pcm;
@@ -1177,7 +1189,6 @@ int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 	mutex_unlock(&register_mutex);
 	return 0;
 }
-
 EXPORT_SYMBOL(snd_pcm_notify);
 
 #ifdef CONFIG_PROC_FS

commit d4288d3fac18bbc31cb6d369679b1fa1d9321ae9
Author: Jurgen Kramer <gtmkramer@xs4all.nl>
Date:   Fri Sep 5 10:47:56 2014 +0200

    ALSA: pcm: add new DSD sampleformat for native DSD playback on XMOS based devices
    
    XMOS based USB DACs with native DSD support expose this feature via a USB
    alternate setting. The audio format is either 32-bit raw or a 32-bit PCM format.
    To utilize this feature on linux this patch introduces a new 32-bit DSD
    sampleformat DSD_U32_LE.
    A follow up patch will add a quirk for XMOS based devices to utilize the new format.
    Further patches will add support to alsa-lib.
    
    Signed-off-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index afccdc553ef9..42ded997b223 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -215,6 +215,7 @@ static char *snd_pcm_format_names[] = {
 	FORMAT(G723_40_1B),
 	FORMAT(DSD_U8),
 	FORMAT(DSD_U16_LE),
+	FORMAT(DSD_U32_LE),
 };
 
 const char *snd_pcm_format_name(snd_pcm_format_t format)

commit 257f8cce5d40b811d229ed71602882baa0012808
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 29 15:32:29 2014 +0200

    ALSA: pcm: Allow nonatomic trigger operations
    
    Currently, many PCM operations are performed in a critical section
    protected by spinlock, typically the trigger and pointer callbacks are
    assumed to be atomic.  This is basically because some trigger action
    (e.g. PCM stop after drain or xrun) is done in the interrupt handler.
    If a driver runs in a threaded irq, however, this doesn't have to be
    atomic.  And many devices want to handle trigger in a non-atomic
    context due to lengthy communications.
    
    This patch tries all PCM calls operational in non-atomic context.
    What it does is very simple: replaces the substream spinlock with the
    corresponding substream mutex when pcm->nonatomic flag is set.  The
    driver that wants to use the non-atomic PCM ops just needs to set the
    flag and keep the rest as is.  (Of course, it must not handle any PCM
    ops in irq context.)
    
    Note that the code doesn't check whether it's atomic-safe or not, but
    trust in 100% that the driver sets pcm->nonatomic correctly.
    
    One possible problem is the case where linked PCM substreams have
    inconsistent nonatomic states.  For avoiding this, snd_pcm_link()
    returns an error if one tries to link an inconsistent PCM substream.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 43932e8dce66..afccdc553ef9 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -698,6 +698,7 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 		}
 		substream->group = &substream->self_group;
 		spin_lock_init(&substream->self_group.lock);
+		mutex_init(&substream->self_group.mutex);
 		INIT_LIST_HEAD(&substream->self_group.substreams);
 		list_add_tail(&substream->link_list, &substream->self_group.substreams);
 		atomic_set(&substream->mmap_count, 0);

commit caa751bad444268d756b48ca03d7cceda3430cc8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 08:30:50 2014 +0100

    ALSA: Create sysfs attribute files via groups
    
    Instead of calling each time device_create_file(), create the groups
    of sysfs attribute files at once in a normal way.  Add a new helper
    function, snd_get_device(), to return the associated device object,
    so that we can handle the sysfs addition locally.
    
    Since the sysfs file addition is done differently now,
    snd_add_device_sysfs_file() helper function is removed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 9defdaef520b..43932e8dce66 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1018,8 +1018,20 @@ static ssize_t show_pcm_class(struct device *dev,
         return snprintf(buf, PAGE_SIZE, "%s\n", str);
 }
 
-static struct device_attribute pcm_attrs =
-	__ATTR(pcm_class, S_IRUGO, show_pcm_class, NULL);
+static DEVICE_ATTR(pcm_class, S_IRUGO, show_pcm_class, NULL);
+static struct attribute *pcm_dev_attrs[] = {
+	&dev_attr_pcm_class.attr,
+	NULL
+};
+
+static struct attribute_group pcm_dev_attr_group = {
+	.attrs	= pcm_dev_attrs,
+};
+
+static const struct attribute_group *pcm_dev_attr_groups[] = {
+	&pcm_dev_attr_group,
+	NULL
+};
 
 static int snd_pcm_dev_register(struct snd_device *device)
 {
@@ -1069,8 +1081,18 @@ static int snd_pcm_dev_register(struct snd_device *device)
 			mutex_unlock(&register_mutex);
 			return err;
 		}
-		snd_add_device_sysfs_file(devtype, pcm->card, pcm->device,
-					  &pcm_attrs);
+
+		dev = snd_get_device(devtype, pcm->card, pcm->device);
+		if (dev) {
+			err = sysfs_create_groups(&dev->kobj,
+						  pcm_dev_attr_groups);
+			if (err < 0)
+				dev_warn(dev,
+					 "pcm %d:%d: cannot create sysfs groups\n",
+					 pcm->card->number, pcm->device);
+			put_device(dev);
+		}
+
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
 			snd_pcm_timer_init(substream);
 	}

commit 09e56df8b37f5e751614a0d140b8bf8250812912
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 18:19:48 2014 +0100

    ALSA: pcm: Use standard printk helpers
    
    Use dev_err() & co as much as possible.  If not available (no device
    assigned at the calling point), use pr_xxx() helpers instead.
    
    For simplicity, introduce new helpers for pcm stream, pcm_err(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 091a05c1d5b3..9defdaef520b 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -338,7 +338,8 @@ static void snd_pcm_proc_info_read(struct snd_pcm_substream *substream,
 
 	info = kmalloc(sizeof(*info), GFP_KERNEL);
 	if (! info) {
-		printk(KERN_DEBUG "snd_pcm_proc_info_read: cannot malloc\n");
+		pcm_dbg(substream->pcm,
+			"snd_pcm_proc_info_read: cannot malloc\n");
 		return;
 	}
 
@@ -660,7 +661,7 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 	if (substream_count > 0 && !pcm->internal) {
 		err = snd_pcm_stream_proc_init(pstr);
 		if (err < 0) {
-			snd_printk(KERN_ERR "Error in snd_pcm_stream_proc_init\n");
+			pcm_err(pcm, "Error in snd_pcm_stream_proc_init\n");
 			return err;
 		}
 	}
@@ -668,7 +669,7 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 	for (idx = 0, prev = NULL; idx < substream_count; idx++) {
 		substream = kzalloc(sizeof(*substream), GFP_KERNEL);
 		if (substream == NULL) {
-			snd_printk(KERN_ERR "Cannot allocate PCM substream\n");
+			pcm_err(pcm, "Cannot allocate PCM substream\n");
 			return -ENOMEM;
 		}
 		substream->pcm = pcm;
@@ -685,7 +686,8 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 		if (!pcm->internal) {
 			err = snd_pcm_substream_proc_init(substream);
 			if (err < 0) {
-				snd_printk(KERN_ERR "Error in snd_pcm_stream_proc_init\n");
+				pcm_err(pcm,
+					"Error in snd_pcm_stream_proc_init\n");
 				if (prev == NULL)
 					pstr->substream = NULL;
 				else
@@ -724,7 +726,7 @@ static int _snd_pcm_new(struct snd_card *card, const char *id, int device,
 		*rpcm = NULL;
 	pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
 	if (pcm == NULL) {
-		snd_printk(KERN_ERR "Cannot allocate PCM\n");
+		dev_err(card->dev, "Cannot allocate PCM\n");
 		return -ENOMEM;
 	}
 	pcm->card = card;

commit 8eeaa2f9e06dcfb45593a0fcd91e81abc7f5d209
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 10 09:48:47 2014 +0100

    ALSA: Replace with IS_ENABLED()
    
    Replace the lengthy #if defined(XXX) || defined(XXX_MODULE) with the
    new IS_ENABLED() macro.
    
    The patch still doesn't cover all ifdefs.  For example, the dependency
    on CONFIG_GAMEPORT is still open-coded because this also has an extra
    dependency on MODULE.  Similarly, an open-coded ifdef in pcm_oss.c and
    some sequencer-related stuff are left untouched.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index e1e9e0c999fe..091a05c1d5b3 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -295,7 +295,7 @@ static const char *snd_pcm_state_name(snd_pcm_state_t state)
 	return snd_pcm_state_names[(__force int)state];
 }
 
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
 #include <linux/soundcard.h>
 
 static const char *snd_pcm_oss_format_name(int format)
@@ -398,7 +398,7 @@ static void snd_pcm_substream_proc_hw_params_read(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "rate: %u (%u/%u)\n", runtime->rate, runtime->rate_num, runtime->rate_den);	
 	snd_iprintf(buffer, "period_size: %lu\n", runtime->period_size);	
 	snd_iprintf(buffer, "buffer_size: %lu\n", runtime->buffer_size);	
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
 	if (substream->oss.oss) {
 		snd_iprintf(buffer, "OSS format: %s\n", snd_pcm_oss_format_name(runtime->oss.format));
 		snd_iprintf(buffer, "OSS channels: %u\n", runtime->oss.channels);	
@@ -651,7 +651,7 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 	struct snd_pcm_str *pstr = &pcm->streams[stream];
 	struct snd_pcm_substream *substream, *prev;
 
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
 	mutex_init(&pstr->oss.setup_mutex);
 #endif
 	pstr->stream = stream;
@@ -807,7 +807,7 @@ EXPORT_SYMBOL(snd_pcm_new_internal);
 static void snd_pcm_free_stream(struct snd_pcm_str * pstr)
 {
 	struct snd_pcm_substream *substream, *substream_next;
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
 	struct snd_pcm_oss_setup *setup, *setupn;
 #endif
 	substream = pstr->substream;
@@ -819,7 +819,7 @@ static void snd_pcm_free_stream(struct snd_pcm_str * pstr)
 		substream = substream_next;
 	}
 	snd_pcm_stream_proc_done(pstr);
-#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+#if IS_ENABLED(CONFIG_SND_PCM_OSS)
 	for (setup = pstr->oss.setup_list; setup; setup = setupn) {
 		setupn = setup->next;
 		kfree(setup->task_name);

commit a4461f41b94cb52e0141af717dcf4ef6558c8e2e
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Oct 31 15:01:37 2013 +0000

    ALSA: fix oops in snd_pcm_info() caused by ASoC DPCM
    
    Unable to handle kernel NULL pointer dereference at virtual address 00000008
    pgd = d5300000
    [00000008] *pgd=0d265831, *pte=00000000, *ppte=00000000
    Internal error: Oops: 17 [#1] PREEMPT ARM
    CPU: 0 PID: 2295 Comm: vlc Not tainted 3.11.0+ #755
    task: dee74800 ti: e213c000 task.ti: e213c000
    PC is at snd_pcm_info+0xc8/0xd8
    LR is at 0x30232065
    pc : [<c031b52c>]    lr : [<30232065>]    psr: a0070013
    sp : e213dea8  ip : d81cb0d0  fp : c05f7678
    r10: c05f7770  r9 : fffffdfd  r8 : 00000000
    r7 : d8a968a8  r6 : d8a96800  r5 : d8a96200  r4 : d81cb000
    r3 : 00000000  r2 : d81cb000  r1 : 00000001  r0 : d8a96200
    Flags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
    Control: 10c5387d  Table: 15300019  DAC: 00000015
    Process vlc (pid: 2295, stack limit = 0xe213c248)
    [<c031b52c>] (snd_pcm_info) from [<c031b570>] (snd_pcm_info_user+0x34/0x9c)
    [<c031b570>] (snd_pcm_info_user) from [<c03164a4>] (snd_pcm_control_ioctl+0x274/0x280)
    [<c03164a4>] (snd_pcm_control_ioctl) from [<c0311458>] (snd_ctl_ioctl+0xc0/0x55c)
    [<c0311458>] (snd_ctl_ioctl) from [<c00eca84>] (do_vfs_ioctl+0x80/0x31c)
    [<c00eca84>] (do_vfs_ioctl) from [<c00ecd5c>] (SyS_ioctl+0x3c/0x60)
    [<c00ecd5c>] (SyS_ioctl) from [<c000e500>] (ret_fast_syscall+0x0/0x48)
    Code: e1a00005 e59530dc e3a01001 e1a02004 (e5933008)
    ---[ end trace cb3d9bdb8dfefb3c ]---
    
    This is provoked when the ASoC front end is open along with its backend,
    (which causes the backend to have a runtime assigned to it) and then the
    SNDRV_CTL_IOCTL_PCM_INFO is requested for the (visible) backend device.
    
    Resolve this by ensuring that ASoC internal backend devices are not
    visible to userspace, just as the commentry for snd_pcm_new_internal()
    says it should be.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Mark Brown <broonie@linaro.org>
    Cc: <stable@vger.kernel.org> [v3.4+]
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 17f45e8aa89c..e1e9e0c999fe 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -49,6 +49,8 @@ static struct snd_pcm *snd_pcm_get(struct snd_card *card, int device)
 	struct snd_pcm *pcm;
 
 	list_for_each_entry(pcm, &snd_pcm_devices, list) {
+		if (pcm->internal)
+			continue;
 		if (pcm->card == card && pcm->device == device)
 			return pcm;
 	}
@@ -60,6 +62,8 @@ static int snd_pcm_next(struct snd_card *card, int device)
 	struct snd_pcm *pcm;
 
 	list_for_each_entry(pcm, &snd_pcm_devices, list) {
+		if (pcm->internal)
+			continue;
 		if (pcm->card == card && pcm->device > device)
 			return pcm->device;
 		else if (pcm->card->number > card->number)

commit ef7a4f979bd8201324b2bcd30277c14aba889f50
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Apr 17 00:01:36 2013 +0800

    ALSA: add DSD formats
    
    This patch adds two formats for Direct Stream Digital (DSD), a
    pulse-density encoding format which is described here:
    https://en.wikipedia.org/wiki/Direct_Stream_Digital
    
    DSD operates on 2.8, 5.6 or 11.2MHz sample rates and as a 1-bit
    stream.
    
    The two new types added by this patch describe streams that are capable
    of handling DSD samples in DOP format as 8-bit or in 16-bit (or at a x8
    or x16 data rate, respectively).
    
    DSD itself specifies samples in *bit*, while DOP and ALSA handle them
    as *bytes*. Hence, a factor of 8 or 16 has to be applied for the sample
    rare configuration, according to the following table:
    
                                                      configured hardware
            176.4KHz   352.8kHz   705.6KHz     <----       sample rate
    
    8-bit                2.8MHz     5.6MHz
    16-bit    2.8Mhz     5.6MHz    11.2MHz
    
             `-----------------------------'
                 actual DSD sample rates
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 578327e2bc26..17f45e8aa89c 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -209,6 +209,8 @@ static char *snd_pcm_format_names[] = {
 	FORMAT(G723_24_1B),
 	FORMAT(G723_40),
 	FORMAT(G723_40_1B),
+	FORMAT(DSD_U8),
+	FORMAT(DSD_U16_LE),
 };
 
 const char *snd_pcm_format_name(snd_pcm_format_t format)

commit eb7c06e8e9c93b495e355421cffd3c43c266d7d2
Author: Yacine Belkadi <yacine.belkadi.1@gmail.com>
Date:   Mon Mar 11 22:05:14 2013 +0100

    ALSA: add/change some comments describing function return values
    
    script/kernel-doc reports the following type of warnings (when run in verbose
    mode):
    
    Warning(sound/core/init.c:152): No description found for return value of
    'snd_card_create'
    
    To fix that:
    - add missing descriptions of function return values
    - use "Return:" sections to describe those return values
    
    Along the way:
    - complete some descriptions
    - fix some typos
    
    Signed-off-by: Yacine Belkadi <yacine.belkadi.1@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 61798f85d030..578327e2bc26 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -637,7 +637,7 @@ static inline int snd_pcm_substream_proc_done(struct snd_pcm_substream *substrea
  * calling this, i.e. zero must be given to the argument of
  * snd_pcm_new().
  *
- * Returns zero if successful, or a negative error code on failure.
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 {
@@ -759,7 +759,7 @@ static int _snd_pcm_new(struct snd_card *card, const char *id, int device,
  * The pcm operators have to be set afterwards to the new instance
  * via snd_pcm_set_ops().
  *
- * Returns zero if successful, or a negative error code on failure.
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_new(struct snd_card *card, const char *id, int device,
 		int playback_count, int capture_count, struct snd_pcm **rpcm)
@@ -787,7 +787,7 @@ EXPORT_SYMBOL(snd_pcm_new);
  * The pcm operators have to be set afterwards to the new instance
  * via snd_pcm_set_ops().
  *
- * Returns zero if successful, or a negative error code on failure.
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_pcm_new_internal(struct snd_card *card, const char *id, int device,
 	int playback_count, int capture_count,

commit 51d503de0210a2b800efdedee23580011f5422c3
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Wed Nov 21 14:36:54 2012 +0530

    ALSA: PCM: Remove redundant null check before kfree
    
    kfree on a null pointer is a no-op.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 030102caeee9..61798f85d030 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -981,8 +981,7 @@ void snd_pcm_detach_substream(struct snd_pcm_substream *substream)
 		       PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control)));
 	kfree(runtime->hw_constraints.rules);
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
-	if (runtime->hwptr_log)
-		kfree(runtime->hwptr_log);
+	kfree(runtime->hwptr_log);
 #endif
 	kfree(runtime);
 	substream->runtime = NULL;

commit 0914f7961babbf28aaa2f19b453951fb4841c03f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 16 16:43:39 2012 +0200

    ALSA: Avoid endless sleep after disconnect
    
    When disconnect callback is called, each component should wake up
    sleepers and check card->shutdown flag for avoiding the endless sleep
    blocking the proper resource release.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 993b2405fdfe..030102caeee9 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1087,12 +1087,16 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 		goto unlock;
 
 	mutex_lock(&pcm->open_mutex);
+	wake_up(&pcm->open_wait);
 	list_del_init(&pcm->list);
 	for (cidx = 0; cidx < 2; cidx++)
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next) {
 			snd_pcm_stream_lock_irq(substream);
-			if (substream->runtime)
+			if (substream->runtime) {
 				substream->runtime->status->state = SNDRV_PCM_STATE_DISCONNECTED;
+				wake_up(&substream->runtime->sleep);
+				wake_up(&substream->runtime->tsleep);
+			}
 			snd_pcm_stream_unlock_irq(substream);
 		}
 	list_for_each_entry(notify, &snd_pcm_notify_list, list) {

commit 9b0573c07f278e9888c352aa9724035c75784ea0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Oct 12 15:07:34 2012 +0200

    ALSA: PCM: Fix some races at disconnection
    
    Fix races at PCM disconnection:
    - while a PCM device is being opened or closed
    - while the PCM state is being changed without lock in prepare,
      hw_params, hw_free ops
    
    Reported-by: Matthieu CASTET <matthieu.castet@parrot.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index f2991940b271..993b2405fdfe 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1086,11 +1086,15 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 	if (list_empty(&pcm->list))
 		goto unlock;
 
+	mutex_lock(&pcm->open_mutex);
 	list_del_init(&pcm->list);
 	for (cidx = 0; cidx < 2; cidx++)
-		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
+		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next) {
+			snd_pcm_stream_lock_irq(substream);
 			if (substream->runtime)
 				substream->runtime->status->state = SNDRV_PCM_STATE_DISCONNECTED;
+			snd_pcm_stream_unlock_irq(substream);
+		}
 	list_for_each_entry(notify, &snd_pcm_notify_list, list) {
 		notify->n_disconnect(pcm);
 	}
@@ -1110,6 +1114,7 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 			pcm->streams[cidx].chmap_kctl = NULL;
 		}
 	}
+	mutex_unlock(&pcm->open_mutex);
  unlock:
 	mutex_unlock(&register_mutex);
 	return 0;

commit 2d3391ec0ecca37efb6bc995906292f47522b471
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jul 27 18:27:00 2012 +0200

    ALSA: PCM: channel mapping API implementation
    
    This patch implements the basic data types for the standard channel
    mapping API handling.
    
    - The definitions of the channel positions and the new TLV types are
      added in sound/asound.h and sound/tlv.h, so that they can be
      referred from user-space.
    
    - Introduced a new helper function snd_pcm_add_chmap_ctls() to create
      control elements representing the channel maps for each PCM
      (sub)stream.
    
    - Some standard pre-defined channel maps are provided for
      convenience.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 1a3070b4e5b5..f2991940b271 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1105,6 +1105,10 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 			break;
 		}
 		snd_unregister_device(devtype, pcm->card, pcm->device);
+		if (pcm->streams[cidx].chmap_kctl) {
+			snd_ctl_remove(pcm->card, pcm->streams[cidx].chmap_kctl);
+			pcm->streams[cidx].chmap_kctl = NULL;
+		}
 	}
  unlock:
 	mutex_unlock(&register_mutex);

commit 250f6715a4112d6686670c5a62ceb9305da94616
Merge: 11bcb32848dd 313162d0b838
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 24 10:41:37 2012 -0700

    Merge tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    Pull <linux/device.h> avoidance patches from Paul Gortmaker:
     "Nearly every subsystem has some kind of header with a proto like:
    
            void foo(struct device *dev);
    
      and yet there is no reason for most of these guys to care about the
      sub fields within the device struct.  This allows us to significantly
      reduce the scope of headers including headers.  For this instance, a
      reduction of about 40% is achieved by replacing the include with the
      simple fact that the device is some kind of a struct.
    
      Unlike the much larger module.h cleanup, this one is simply two
      commits.  One to fix the implicit <linux/device.h> users, and then one
      to delete the device.h includes from the linux/include/ dir wherever
      possible."
    
    * tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux:
      device.h: audit and cleanup users in main include dir
      device.h: cleanup users outside of linux/include (C files)

commit 51990e825431089747f8896244b5c17d3a6423f1
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jan 22 11:23:42 2012 -0500

    device.h: cleanup users outside of linux/include (C files)
    
    For files that are actively using linux/device.h, make sure
    that they call it out.  This will allow us to clean up some
    of the implicit uses of linux/device.h within include/*
    without introducing build regressions.
    
    Yes, this was created by "cheating" -- i.e. the headers were
    cleaned up, and then the fallout was found and fixed, and then
    the two commits were reordered.  This ensures we don't introduce
    build regressions into the git history.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 8928ca871c22..1888a90bd5b6 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -24,6 +24,7 @@
 #include <linux/module.h>
 #include <linux/time.h>
 #include <linux/mutex.h>
+#include <linux/device.h>
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/pcm.h>

commit 945e5038455fef18e73914c149717878d78cb4c0
Author: Liam Girdwood <lrg@ti.com>
Date:   Wed Feb 8 20:33:31 2012 +0000

    ALSA: PCM - Add PCM creation API for internal PCMs.
    
    The new ASoC dynamic PCM core needs to create PCMs and substreams that are
    for use by internal ASoC drivers only and not visible to userspace for
    direct IO. These new PCMs are similar to regular PCMs expect they have no
    device nodes or procfs entries. The ASoC component drivers use them in exactly
    the same way as regular PCMs for PCM and DAI operations.
    
    The intention is that a dynamic PCM based driver will register both regular
    PCMs and internal PCMs. The regular PCMs will be used for all IO with userspace
    however the internal PCMs will be used by the driver to route digital audio
    through numerous back end DAI links (with potentially a DSP providing different
    hw_params, DAI formats based on the regular front end PCM params) to devices
    like CODECs, MODEMs, Bluetooth, FM, DMICs, etc
    
    This patch adds a new snd_pcm_new_internal() API call to create the internal PCM
    without device nodes or procfs. It also adds adds a new internal flag to snd_pcm.
    
    [fixed minor coding-style issues by tiwai]
    
    Signed-off-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 8928ca871c22..6e4bfcc14254 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -650,7 +650,7 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 	pstr->stream = stream;
 	pstr->pcm = pcm;
 	pstr->substream_count = substream_count;
-	if (substream_count > 0) {
+	if (substream_count > 0 && !pcm->internal) {
 		err = snd_pcm_stream_proc_init(pstr);
 		if (err < 0) {
 			snd_printk(KERN_ERR "Error in snd_pcm_stream_proc_init\n");
@@ -674,15 +674,18 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 			pstr->substream = substream;
 		else
 			prev->next = substream;
-		err = snd_pcm_substream_proc_init(substream);
-		if (err < 0) {
-			snd_printk(KERN_ERR "Error in snd_pcm_stream_proc_init\n");
-			if (prev == NULL)
-				pstr->substream = NULL;
-			else
-				prev->next = NULL;
-			kfree(substream);
-			return err;
+
+		if (!pcm->internal) {
+			err = snd_pcm_substream_proc_init(substream);
+			if (err < 0) {
+				snd_printk(KERN_ERR "Error in snd_pcm_stream_proc_init\n");
+				if (prev == NULL)
+					pstr->substream = NULL;
+				else
+					prev->next = NULL;
+				kfree(substream);
+				return err;
+			}
 		}
 		substream->group = &substream->self_group;
 		spin_lock_init(&substream->self_group.lock);
@@ -696,25 +699,9 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 
 EXPORT_SYMBOL(snd_pcm_new_stream);
 
-/**
- * snd_pcm_new - create a new PCM instance
- * @card: the card instance
- * @id: the id string
- * @device: the device index (zero based)
- * @playback_count: the number of substreams for playback
- * @capture_count: the number of substreams for capture
- * @rpcm: the pointer to store the new pcm instance
- *
- * Creates a new PCM instance.
- *
- * The pcm operators have to be set afterwards to the new instance
- * via snd_pcm_set_ops().
- *
- * Returns zero if successful, or a negative error code on failure.
- */
-int snd_pcm_new(struct snd_card *card, const char *id, int device,
-		int playback_count, int capture_count,
-	        struct snd_pcm ** rpcm)
+static int _snd_pcm_new(struct snd_card *card, const char *id, int device,
+		int playback_count, int capture_count, bool internal,
+		struct snd_pcm **rpcm)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -735,6 +722,7 @@ int snd_pcm_new(struct snd_card *card, const char *id, int device,
 	}
 	pcm->card = card;
 	pcm->device = device;
+	pcm->internal = internal;
 	if (id)
 		strlcpy(pcm->id, id, sizeof(pcm->id));
 	if ((err = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_PLAYBACK, playback_count)) < 0) {
@@ -756,8 +744,59 @@ int snd_pcm_new(struct snd_card *card, const char *id, int device,
 	return 0;
 }
 
+/**
+ * snd_pcm_new - create a new PCM instance
+ * @card: the card instance
+ * @id: the id string
+ * @device: the device index (zero based)
+ * @playback_count: the number of substreams for playback
+ * @capture_count: the number of substreams for capture
+ * @rpcm: the pointer to store the new pcm instance
+ *
+ * Creates a new PCM instance.
+ *
+ * The pcm operators have to be set afterwards to the new instance
+ * via snd_pcm_set_ops().
+ *
+ * Returns zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_new(struct snd_card *card, const char *id, int device,
+		int playback_count, int capture_count, struct snd_pcm **rpcm)
+{
+	return _snd_pcm_new(card, id, device, playback_count, capture_count,
+			false, rpcm);
+}
 EXPORT_SYMBOL(snd_pcm_new);
 
+/**
+ * snd_pcm_new_internal - create a new internal PCM instance
+ * @card: the card instance
+ * @id: the id string
+ * @device: the device index (zero based - shared with normal PCMs)
+ * @playback_count: the number of substreams for playback
+ * @capture_count: the number of substreams for capture
+ * @rpcm: the pointer to store the new pcm instance
+ *
+ * Creates a new internal PCM instance with no userspace device or procfs
+ * entries. This is used by ASoC Back End PCMs in order to create a PCM that
+ * will only be used internally by kernel drivers. i.e. it cannot be opened
+ * by userspace. It provides existing ASoC components drivers with a substream
+ * and access to any private data.
+ *
+ * The pcm operators have to be set afterwards to the new instance
+ * via snd_pcm_set_ops().
+ *
+ * Returns zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_new_internal(struct snd_card *card, const char *id, int device,
+	int playback_count, int capture_count,
+	struct snd_pcm **rpcm)
+{
+	return _snd_pcm_new(card, id, device, playback_count, capture_count,
+			true, rpcm);
+}
+EXPORT_SYMBOL(snd_pcm_new_internal);
+
 static void snd_pcm_free_stream(struct snd_pcm_str * pstr)
 {
 	struct snd_pcm_substream *substream, *substream_next;
@@ -994,7 +1033,7 @@ static int snd_pcm_dev_register(struct snd_device *device)
 	}
 	for (cidx = 0; cidx < 2; cidx++) {
 		int devtype = -1;
-		if (pcm->streams[cidx].substream == NULL)
+		if (pcm->streams[cidx].substream == NULL || pcm->internal)
 			continue;
 		switch (cidx) {
 		case SNDRV_PCM_STREAM_PLAYBACK:

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index ee9abb2d9001..8928ca871c22 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -21,6 +21,7 @@
 
 #include <linux/init.h>
 #include <linux/slab.h>
+#include <linux/module.h>
 #include <linux/time.h>
 #include <linux/mutex.h>
 #include <sound/core.h>

commit fea952e5cc23ea94b4677ca20774cdc3cea014e2
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Feb 14 11:00:47 2011 +0100

    ALSA: core: sparse cleanups
    
    Change the core code where sparse complains.  In most cases, this means
    just adding annotations to confirm that we indeed want to do the dirty
    things we're doing.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 6b4b1287b314..ee9abb2d9001 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -211,9 +211,9 @@ static char *snd_pcm_format_names[] = {
 
 const char *snd_pcm_format_name(snd_pcm_format_t format)
 {
-	if (format >= ARRAY_SIZE(snd_pcm_format_names))
+	if ((__force unsigned int)format >= ARRAY_SIZE(snd_pcm_format_names))
 		return "Unknown";
-	return snd_pcm_format_names[format];
+	return snd_pcm_format_names[(__force unsigned int)format];
 }
 EXPORT_SYMBOL_GPL(snd_pcm_format_name);
 
@@ -269,12 +269,12 @@ static const char *snd_pcm_stream_name(int stream)
 
 static const char *snd_pcm_access_name(snd_pcm_access_t access)
 {
-	return snd_pcm_access_names[access];
+	return snd_pcm_access_names[(__force int)access];
 }
 
 static const char *snd_pcm_subformat_name(snd_pcm_subformat_t subformat)
 {
-	return snd_pcm_subformat_names[subformat];
+	return snd_pcm_subformat_names[(__force int)subformat];
 }
 
 static const char *snd_pcm_tstamp_mode_name(int mode)
@@ -284,7 +284,7 @@ static const char *snd_pcm_tstamp_mode_name(int mode)
 
 static const char *snd_pcm_state_name(snd_pcm_state_t state)
 {
-	return snd_pcm_state_names[state];
+	return snd_pcm_state_names[(__force int)state];
 }
 
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)

commit 4e83998f5af010a928495988c586ea2926624db9
Merge: dd1d3a49db4a d4cfa4d12f46
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 11 13:45:22 2010 +0200

    Merge branch 'fix/misc' into topic/misc

commit 901d46d5a8eb821b03ca9e8cf005beb0c92f31ea
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 16 23:06:50 2010 +0200

    ALSA: pcm - Fix race with proc files
    
    The PCM proc files may open a race against substream close, which can
    end up with an Oops.  Use the open_mutex to protect for it.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 204af48c5cc1..ac242a377aea 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -372,14 +372,17 @@ static void snd_pcm_substream_proc_hw_params_read(struct snd_info_entry *entry,
 						  struct snd_info_buffer *buffer)
 {
 	struct snd_pcm_substream *substream = entry->private_data;
-	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime;
+
+	mutex_lock(&substream->pcm->open_mutex);
+	runtime = substream->runtime;
 	if (!runtime) {
 		snd_iprintf(buffer, "closed\n");
-		return;
+		goto unlock;
 	}
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN) {
 		snd_iprintf(buffer, "no setup\n");
-		return;
+		goto unlock;
 	}
 	snd_iprintf(buffer, "access: %s\n", snd_pcm_access_name(runtime->access));
 	snd_iprintf(buffer, "format: %s\n", snd_pcm_format_name(runtime->format));
@@ -398,20 +401,25 @@ static void snd_pcm_substream_proc_hw_params_read(struct snd_info_entry *entry,
 		snd_iprintf(buffer, "OSS period frames: %lu\n", (unsigned long)runtime->oss.period_frames);
 	}
 #endif
+ unlock:
+	mutex_unlock(&substream->pcm->open_mutex);
 }
 
 static void snd_pcm_substream_proc_sw_params_read(struct snd_info_entry *entry,
 						  struct snd_info_buffer *buffer)
 {
 	struct snd_pcm_substream *substream = entry->private_data;
-	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime;
+
+	mutex_lock(&substream->pcm->open_mutex);
+	runtime = substream->runtime;
 	if (!runtime) {
 		snd_iprintf(buffer, "closed\n");
-		return;
+		goto unlock;
 	}
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN) {
 		snd_iprintf(buffer, "no setup\n");
-		return;
+		goto unlock;
 	}
 	snd_iprintf(buffer, "tstamp_mode: %s\n", snd_pcm_tstamp_mode_name(runtime->tstamp_mode));
 	snd_iprintf(buffer, "period_step: %u\n", runtime->period_step);
@@ -421,24 +429,29 @@ static void snd_pcm_substream_proc_sw_params_read(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "silence_threshold: %lu\n", runtime->silence_threshold);
 	snd_iprintf(buffer, "silence_size: %lu\n", runtime->silence_size);
 	snd_iprintf(buffer, "boundary: %lu\n", runtime->boundary);
+ unlock:
+	mutex_unlock(&substream->pcm->open_mutex);
 }
 
 static void snd_pcm_substream_proc_status_read(struct snd_info_entry *entry,
 					       struct snd_info_buffer *buffer)
 {
 	struct snd_pcm_substream *substream = entry->private_data;
-	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime;
 	struct snd_pcm_status status;
 	int err;
+
+	mutex_lock(&substream->pcm->open_mutex);
+	runtime = substream->runtime;
 	if (!runtime) {
 		snd_iprintf(buffer, "closed\n");
-		return;
+		goto unlock;
 	}
 	memset(&status, 0, sizeof(status));
 	err = snd_pcm_status(substream, &status);
 	if (err < 0) {
 		snd_iprintf(buffer, "error %d\n", err);
-		return;
+		goto unlock;
 	}
 	snd_iprintf(buffer, "state: %s\n", snd_pcm_state_name(status.state));
 	snd_iprintf(buffer, "owner_pid   : %d\n", pid_vnr(substream->pid));
@@ -452,6 +465,8 @@ static void snd_pcm_substream_proc_status_read(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "-----\n");
 	snd_iprintf(buffer, "hw_ptr      : %ld\n", runtime->status->hw_ptr);
 	snd_iprintf(buffer, "appl_ptr    : %ld\n", runtime->control->appl_ptr);
+ unlock:
+	mutex_unlock(&substream->pcm->open_mutex);
 }
 
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG

commit 9fe856e47e1751204faf3d604c6d20ab24bd3b93
Author: Joe Perches <joe@perches.com>
Date:   Sat Sep 4 18:52:54 2010 -0700

    sound: Remove unnecessary casts of private_data
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 204af48c5cc1..88525a958291 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -364,8 +364,7 @@ static void snd_pcm_stream_proc_info_read(struct snd_info_entry *entry,
 static void snd_pcm_substream_proc_info_read(struct snd_info_entry *entry,
 					     struct snd_info_buffer *buffer)
 {
-	snd_pcm_proc_info_read((struct snd_pcm_substream *)entry->private_data,
-			       buffer);
+	snd_pcm_proc_info_read(entry->private_data, buffer);
 }
 
 static void snd_pcm_substream_proc_hw_params_read(struct snd_info_entry *entry,

commit 7a28826ac73d31a379d93785d8fbd24ab492b0bd
Author: Dan Carpenter <error27@gmail.com>
Date:   Fri Aug 27 22:02:15 2010 +0200

    ALSA: pcm: add more format names
    
    There were some new formats added in commit 15c0cee6c809 "ALSA: pcm:
    Define G723 3-bit and 5-bit formats".  That commit increased
    SNDRV_PCM_FORMAT_LAST as well.  My concern is that there are a couple
    places which do:
    
            for (i = 0; i < SNDRV_PCM_FORMAT_LAST; i++) {
                    if (dummy->pcm_hw.formats & (1ULL << i))
                            snd_iprintf(buffer, " %s", snd_pcm_format_name(i));
            }
    
    I haven't tested these but it looks like if "i" were equal to
    SNDRV_PCM_FORMAT_G723_24 or higher then we might read past the end of
    the array.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index cbe815dfbdc8..204af48c5cc1 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -203,10 +203,16 @@ static char *snd_pcm_format_names[] = {
 	FORMAT(S18_3BE),
 	FORMAT(U18_3LE),
 	FORMAT(U18_3BE),
+	FORMAT(G723_24),
+	FORMAT(G723_24_1B),
+	FORMAT(G723_40),
+	FORMAT(G723_40_1B),
 };
 
 const char *snd_pcm_format_name(snd_pcm_format_t format)
 {
+	if (format >= ARRAY_SIZE(snd_pcm_format_names))
+		return "Unknown";
 	return snd_pcm_format_names[format];
 }
 EXPORT_SYMBOL_GPL(snd_pcm_format_name);

commit ed77134bfccf5e75b6cbadab268e559dbe6a4ebb
Author: Mark Gross <mgross@linux.intel.com>
Date:   Thu May 6 01:59:26 2010 +0200

    PM QOS update
    
    This patch changes the string based list management to a handle base
    implementation to help with the hot path use of pm-qos, it also renames
    much of the API to use "request" as opposed to "requirement" that was
    used in the initial implementation.  I did this because request more
    accurately represents what it actually does.
    
    Also, I added a string based ABI for users wanting to use a string
    interface.  So if the user writes 0xDDDDDDDD formatted hex it will be
    accepted by the interface.  (someone asked me for it and I don't think
    it hurts anything.)
    
    This patch updates some documentation input I got from Randy.
    
    Signed-off-by: markgross <mgross@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 0d428d0896db..cbe815dfbdc8 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -648,9 +648,6 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 		substream->number = idx;
 		substream->stream = stream;
 		sprintf(substream->name, "subdevice #%i", idx);
-		snprintf(substream->latency_id, sizeof(substream->latency_id),
-			 "ALSA-PCM%d-%d%c%d", pcm->card->number, pcm->device,
-			 (stream ? 'c' : 'p'), idx);
 		substream->buffer_bytes_max = UINT_MAX;
 		if (prev == NULL)
 			pstr->substream = substream;

commit c91a988dc6551c66418690e36b2a23cdb0255da8
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Thu Jan 21 10:32:15 2010 +0100

    ALSA: pcm_core: Fix wake_up() optimization
    
    This change fixes the "ALSA: pcm_lib - optimize wake_up() calls for PCM I/O"
    commit. New sleeping queue is introduced to separate user space and kernel
    space wake_ups. runtime->nowake is renamed to twake (transfer wake).
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index df57a0e30bf2..0d428d0896db 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -894,6 +894,7 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 	memset((void*)runtime->control, 0, size);
 
 	init_waitqueue_head(&runtime->sleep);
+	init_waitqueue_head(&runtime->tsleep);
 
 	runtime->status->state = SNDRV_PCM_STATE_OPEN;
 

commit 4d96eb255c53ab5e39b37fd4d484ea3dc39ab456
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Sun Dec 20 11:47:57 2009 +0100

    ALSA: pcm_lib - add possibility to log last 10 DMA ring buffer positions
    
    In some debug cases, it might be usefull to see previous ring buffer
    positions to determine position problems from the lowlevel drivers.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 6884ae031f6f..df57a0e30bf2 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -921,6 +921,10 @@ void snd_pcm_detach_substream(struct snd_pcm_substream *substream)
 	snd_free_pages((void*)runtime->control,
 		       PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control)));
 	kfree(runtime->hw_constraints.rules);
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
+	if (runtime->hwptr_log)
+		kfree(runtime->hwptr_log);
+#endif
 	kfree(runtime);
 	substream->runtime = NULL;
 	put_pid(substream->pid);

commit e7373b702f6eab35f315e016a4159860a7a4d686
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Nov 10 10:13:30 2009 +0100

    sound: pcm: record a substream's owner process
    
    Record the pid of the task that opened a PCM substream. For sound
    cards with hardware mixing, this allows determining which process
    is associated with a specific substream's volume control.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 8e2c7833614c..6884ae031f6f 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -435,6 +435,7 @@ static void snd_pcm_substream_proc_status_read(struct snd_info_entry *entry,
 		return;
 	}
 	snd_iprintf(buffer, "state: %s\n", snd_pcm_state_name(status.state));
+	snd_iprintf(buffer, "owner_pid   : %d\n", pid_vnr(substream->pid));
 	snd_iprintf(buffer, "trigger_time: %ld.%09ld\n",
 		status.trigger_tstamp.tv_sec, status.trigger_tstamp.tv_nsec);
 	snd_iprintf(buffer, "tstamp      : %ld.%09ld\n",
@@ -900,6 +901,7 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 	substream->private_data = pcm->private_data;
 	substream->ref_count = 1;
 	substream->f_flags = file->f_flags;
+	substream->pid = get_pid(task_pid(current));
 	pstr->substream_opened++;
 	*rsubstream = substream;
 	return 0;
@@ -921,6 +923,8 @@ void snd_pcm_detach_substream(struct snd_pcm_substream *substream)
 	kfree(runtime->hw_constraints.rules);
 	kfree(runtime);
 	substream->runtime = NULL;
+	put_pid(substream->pid);
+	substream->pid = NULL;
 	substream->pstr->substream_opened--;
 }
 

commit 25d27eded1f4fc728e64f443adc339b5229be5d7
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Nov 2 09:35:44 2009 +0100

    control: use reference-counted pid
    
    Instead of storing the PID number, take a reference to the task's pid
    structure.  This protects against duplicates due to PID overflows, and
    using pid_vnr() ensures that the PID returned by snd_ctl_elem_info() is
    correct as seen from the current namespace.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index c69c60b2a48a..8e2c7833614c 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -809,7 +809,7 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 	card = pcm->card;
 	read_lock(&card->ctl_files_rwlock);
 	list_for_each_entry(kctl, &card->ctl_files, list) {
-		if (kctl->pid == current->pid) {
+		if (kctl->pid == task_pid(current)) {
 			prefer_subdevice = kctl->prefer_pcm_subdevice;
 			if (prefer_subdevice != -1)
 				break;

commit 4b3be6afa4ab8b3fdce39df68bad71f8b85164de
Author: Julia Lawall <julia@diku.dk>
Date:   Sat Oct 17 08:33:22 2009 +0200

    ALSA: sound: Move dereference after NULL test and drop unnecessary NULL tests
    
    In pcm.c, if the NULL test on pcm is needed, then the dereference should be
    after the NULL test.
    
    In dummy.c and ali5451.c, the context of the calls to
    snd_card_dummy_new_mixer and snd_ali_free_voice show that dummy and pvoice,
    respectively cannot be NULL.
    
    A simplified version of the semantic match that detects this problem is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    @match exists@
    expression x, E;
    identifier fld;
    @@
    
    * x->fld
      ... when != \(x = E\|&x\)
    * x == NULL
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 0c1440121c22..c69c60b2a48a 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -953,11 +953,12 @@ static int snd_pcm_dev_register(struct snd_device *device)
 	struct snd_pcm_substream *substream;
 	struct snd_pcm_notify *notify;
 	char str[16];
-	struct snd_pcm *pcm = device->device_data;
+	struct snd_pcm *pcm;
 	struct device *dev;
 
-	if (snd_BUG_ON(!pcm || !device))
+	if (snd_BUG_ON(!device || !device->device_data))
 		return -ENXIO;
+	pcm = device->device_data;
 	mutex_lock(&register_mutex);
 	err = snd_pcm_add(pcm);
 	if (err) {

commit 6e5265ec34d3b9578973841ddec8b925e986136a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 8 14:26:51 2009 +0200

    ALSA: Re-export snd_pcm_format_name() function
    
    Re-export snd_pcm_format_name() function to be used outside the PCM core.
    As a first example, usbaudio is changed to use it now again.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 145931a9ff30..0c1440121c22 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -162,18 +162,7 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 	return -ENOIOCTLCMD;
 }
 
-#ifdef CONFIG_SND_VERBOSE_PROCFS
-
-#define STATE(v) [SNDRV_PCM_STATE_##v] = #v
-#define STREAM(v) [SNDRV_PCM_STREAM_##v] = #v
-#define READY(v) [SNDRV_PCM_READY_##v] = #v
-#define XRUN(v) [SNDRV_PCM_XRUN_##v] = #v
-#define SILENCE(v) [SNDRV_PCM_SILENCE_##v] = #v
-#define TSTAMP(v) [SNDRV_PCM_TSTAMP_##v] = #v
-#define ACCESS(v) [SNDRV_PCM_ACCESS_##v] = #v
-#define START(v) [SNDRV_PCM_START_##v] = #v
 #define FORMAT(v) [SNDRV_PCM_FORMAT_##v] = #v
-#define SUBFORMAT(v) [SNDRV_PCM_SUBFORMAT_##v] = #v 
 
 static char *snd_pcm_format_names[] = {
 	FORMAT(S8),
@@ -216,10 +205,23 @@ static char *snd_pcm_format_names[] = {
 	FORMAT(U18_3BE),
 };
 
-static const char *snd_pcm_format_name(snd_pcm_format_t format)
+const char *snd_pcm_format_name(snd_pcm_format_t format)
 {
 	return snd_pcm_format_names[format];
 }
+EXPORT_SYMBOL_GPL(snd_pcm_format_name);
+
+#ifdef CONFIG_SND_VERBOSE_PROCFS
+
+#define STATE(v) [SNDRV_PCM_STATE_##v] = #v
+#define STREAM(v) [SNDRV_PCM_STREAM_##v] = #v
+#define READY(v) [SNDRV_PCM_READY_##v] = #v
+#define XRUN(v) [SNDRV_PCM_XRUN_##v] = #v
+#define SILENCE(v) [SNDRV_PCM_SILENCE_##v] = #v
+#define TSTAMP(v) [SNDRV_PCM_TSTAMP_##v] = #v
+#define ACCESS(v) [SNDRV_PCM_ACCESS_##v] = #v
+#define START(v) [SNDRV_PCM_START_##v] = #v
+#define SUBFORMAT(v) [SNDRV_PCM_SUBFORMAT_##v] = #v 
 
 static char *snd_pcm_stream_names[] = {
 	STREAM(PLAYBACK),

commit e0d2054fd3cf167395390dc1758644486c782707
Merge: d807500a2472 c468ac29e63b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:35:50 2009 +0100

    Merge branch 'topic/misc' into for-linus

commit 85122ea40c4fc82af5b66b8683f525c2c4a36d1a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 6 16:30:07 2009 +0100

    ALSA: Remove unneeded snd_pcm_substream.timer_lock
    
    The timer callbacks are called in the protected status by the lock
    of the timer instance, so there is no need for an extra lock in the
    PCM substream.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 192a433a2403..37f567a68ef2 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -667,7 +667,6 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 		spin_lock_init(&substream->self_group.lock);
 		INIT_LIST_HEAD(&substream->self_group.substreams);
 		list_add_tail(&substream->link_list, &substream->self_group.substreams);
-		spin_lock_init(&substream->timer_lock);
 		atomic_set(&substream->mmap_count, 0);
 		prev = substream;
 	}

commit e6161653094f14b1add10efe3493a2e526fe9538
Author: Tim Blechmann <tim@klingt.org>
Date:   Thu Feb 5 13:01:54 2009 +0100

    ALSA: snd_pcm_new api cleanup
    
    Impact: cleanup
    
    snd_pcm_new takes a char *id argument, although it is not modifying
    the string. it can therefore be declared as const char *id.
    
    Signed-off-by: Tim Blechmann <tim@klingt.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 192a433a2403..583453e2355c 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -692,7 +692,7 @@ EXPORT_SYMBOL(snd_pcm_new_stream);
  *
  * Returns zero if successful, or a negative error code on failure.
  */
-int snd_pcm_new(struct snd_card *card, char *id, int device,
+int snd_pcm_new(struct snd_card *card, const char *id, int device,
 		int playback_count, int capture_count,
 	        struct snd_pcm ** rpcm)
 {

commit 7eaa943c8ed8e91e05d0f5d0dc7a18e3319b45cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:09:09 2008 +0200

    ALSA: Kill snd_assert() in sound/core/*
    
    Kill snd_assert() in sound/core/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 517388b2eba9..192a433a2403 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -256,7 +256,6 @@ static char *snd_pcm_tstamp_mode_names[] = {
 
 static const char *snd_pcm_stream_name(int stream)
 {
-	snd_assert(stream <= SNDRV_PCM_STREAM_LAST, return NULL);
 	return snd_pcm_stream_names[stream];
 }
 
@@ -272,7 +271,6 @@ static const char *snd_pcm_subformat_name(snd_pcm_subformat_t subformat)
 
 static const char *snd_pcm_tstamp_mode_name(int mode)
 {
-	snd_assert(mode <= SNDRV_PCM_TSTAMP_LAST, return NULL);
 	return snd_pcm_tstamp_mode_names[mode];
 }
 
@@ -706,9 +704,10 @@ int snd_pcm_new(struct snd_card *card, char *id, int device,
 		.dev_disconnect = snd_pcm_dev_disconnect,
 	};
 
-	snd_assert(rpcm != NULL, return -EINVAL);
-	*rpcm = NULL;
-	snd_assert(card != NULL, return -ENXIO);
+	if (snd_BUG_ON(!card))
+		return -ENXIO;
+	if (rpcm)
+		*rpcm = NULL;
 	pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
 	if (pcm == NULL) {
 		snd_printk(KERN_ERR "Cannot allocate PCM\n");
@@ -732,7 +731,8 @@ int snd_pcm_new(struct snd_card *card, char *id, int device,
 		snd_pcm_free(pcm);
 		return err;
 	}
-	*rpcm = pcm;
+	if (rpcm)
+		*rpcm = pcm;
 	return 0;
 }
 
@@ -766,7 +766,8 @@ static int snd_pcm_free(struct snd_pcm *pcm)
 {
 	struct snd_pcm_notify *notify;
 
-	snd_assert(pcm != NULL, return -ENXIO);
+	if (!pcm)
+		return 0;
 	list_for_each_entry(notify, &snd_pcm_notify_list, list) {
 		notify->n_unregister(pcm);
 	}
@@ -797,9 +798,9 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 	int prefer_subdevice = -1;
 	size_t size;
 
-	snd_assert(rsubstream != NULL, return -EINVAL);
+	if (snd_BUG_ON(!pcm || !rsubstream))
+		return -ENXIO;
 	*rsubstream = NULL;
-	snd_assert(pcm != NULL, return -ENXIO);
 	pstr = &pcm->streams[stream];
 	if (pstr->substream == NULL || pstr->substream_count == 0)
 		return -ENODEV;
@@ -907,8 +908,9 @@ void snd_pcm_detach_substream(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime;
 
+	if (PCM_RUNTIME_CHECK(substream))
+		return;
 	runtime = substream->runtime;
-	snd_assert(runtime != NULL, return);
 	if (runtime->private_free != NULL)
 		runtime->private_free(runtime);
 	snd_free_pages((void*)runtime->status,
@@ -953,7 +955,8 @@ static int snd_pcm_dev_register(struct snd_device *device)
 	struct snd_pcm *pcm = device->device_data;
 	struct device *dev;
 
-	snd_assert(pcm != NULL && device != NULL, return -ENXIO);
+	if (snd_BUG_ON(!pcm || !device))
+		return -ENXIO;
 	mutex_lock(&register_mutex);
 	err = snd_pcm_add(pcm);
 	if (err) {
@@ -1043,10 +1046,11 @@ int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 {
 	struct snd_pcm *pcm;
 
-	snd_assert(notify != NULL &&
-		   notify->n_register != NULL &&
-		   notify->n_unregister != NULL &&
-		   notify->n_disconnect, return -EINVAL);
+	if (snd_BUG_ON(!notify ||
+		       !notify->n_register ||
+		       !notify->n_unregister ||
+		       !notify->n_disconnect))
+		return -EINVAL;
 	mutex_lock(&register_mutex);
 	if (nfree) {
 		list_del(&notify->list);

commit f90c06a2b613eea24a77d56f24b084745c43713d
Author: Pawel MOLL <pawel.moll@st.com>
Date:   Wed Jul 30 12:46:40 2008 +0100

    ALSA: Fix limit of 8 PCM devices in SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE
    
    When compiled with CONFIG_SND_DYNAMIC_MINORS the ALSA core is fine
    to have more than 8 PCM devices per card, except one place - the
    SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE ioctl, which will not enumerate
    devices > 7. This patch fixes the issue, changing the devices list
    organisation.
    
    Instead of adding new device to the tail, the list is now kept always
    ordered (by card number, then device number). Thus, during enumeration,
    it is easy to discover the fact that there is no more given card's
    devices.
    
    Additionally the device field of struct snd_pcm had to be changed to int,
    as its "unsignednity" caused a lot of problems when comparing it to
    potentially negative signed values. (-1 is 0xffffffff or even more then ;-)
    
    Signed-off-by: Pawel Moll <pawel.moll@st.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index ece25c718e95..517388b2eba9 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -42,7 +42,7 @@ static int snd_pcm_dev_free(struct snd_device *device);
 static int snd_pcm_dev_register(struct snd_device *device);
 static int snd_pcm_dev_disconnect(struct snd_device *device);
 
-static struct snd_pcm *snd_pcm_search(struct snd_card *card, int device)
+static struct snd_pcm *snd_pcm_get(struct snd_card *card, int device)
 {
 	struct snd_pcm *pcm;
 
@@ -53,6 +53,37 @@ static struct snd_pcm *snd_pcm_search(struct snd_card *card, int device)
 	return NULL;
 }
 
+static int snd_pcm_next(struct snd_card *card, int device)
+{
+	struct snd_pcm *pcm;
+
+	list_for_each_entry(pcm, &snd_pcm_devices, list) {
+		if (pcm->card == card && pcm->device > device)
+			return pcm->device;
+		else if (pcm->card->number > card->number)
+			return -1;
+	}
+	return -1;
+}
+
+static int snd_pcm_add(struct snd_pcm *newpcm)
+{
+	struct snd_pcm *pcm;
+
+	list_for_each_entry(pcm, &snd_pcm_devices, list) {
+		if (pcm->card == newpcm->card && pcm->device == newpcm->device)
+			return -EBUSY;
+		if (pcm->card->number > newpcm->card->number ||
+				(pcm->card == newpcm->card &&
+				pcm->device > newpcm->device)) {
+			list_add(&newpcm->list, pcm->list.prev);
+			return 0;
+		}
+	}
+	list_add_tail(&newpcm->list, &snd_pcm_devices);
+	return 0;
+}
+
 static int snd_pcm_control_ioctl(struct snd_card *card,
 				 struct snd_ctl_file *control,
 				 unsigned int cmd, unsigned long arg)
@@ -65,14 +96,7 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 			if (get_user(device, (int __user *)arg))
 				return -EFAULT;
 			mutex_lock(&register_mutex);
-			device = device < 0 ? 0 : device + 1;
-			while (device < SNDRV_PCM_DEVICES) {
-				if (snd_pcm_search(card, device))
-					break;
-				device++;
-			}
-			if (device == SNDRV_PCM_DEVICES)
-				device = -1;
+			device = snd_pcm_next(card, device);
 			mutex_unlock(&register_mutex);
 			if (put_user(device, (int __user *)arg))
 				return -EFAULT;
@@ -98,7 +122,7 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 			if (get_user(subdevice, &info->subdevice))
 				return -EFAULT;
 			mutex_lock(&register_mutex);
-			pcm = snd_pcm_search(card, device);
+			pcm = snd_pcm_get(card, device);
 			if (pcm == NULL) {
 				err = -ENXIO;
 				goto _error;
@@ -931,11 +955,11 @@ static int snd_pcm_dev_register(struct snd_device *device)
 
 	snd_assert(pcm != NULL && device != NULL, return -ENXIO);
 	mutex_lock(&register_mutex);
-	if (snd_pcm_search(pcm->card, pcm->device)) {
+	err = snd_pcm_add(pcm);
+	if (err) {
 		mutex_unlock(&register_mutex);
-		return -EBUSY;
+		return err;
 	}
-	list_add_tail(&pcm->list, &snd_pcm_devices);
 	for (cidx = 0; cidx < 2; cidx++) {
 		int devtype = -1;
 		if (pcm->streams[cidx].substream == NULL)

commit 896e6cc20e67038af12e1a7711eef32647e62f23
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Aug 1 13:36:04 2008 +0200

    sound: Revert "ALSA: Fix limit of 8 PCM devices in SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE"
    
    This reverts commit fb3d6f2b77bdec75d45aa9d4464287ed87927866.
    
    New, updated patch with same subject replaces this commit.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 24271a3bd901..ece25c718e95 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -42,7 +42,7 @@ static int snd_pcm_dev_free(struct snd_device *device);
 static int snd_pcm_dev_register(struct snd_device *device);
 static int snd_pcm_dev_disconnect(struct snd_device *device);
 
-static inline struct snd_pcm *snd_pcm_get(struct snd_card *card, int device)
+static struct snd_pcm *snd_pcm_search(struct snd_card *card, int device)
 {
 	struct snd_pcm *pcm;
 
@@ -53,37 +53,6 @@ static inline struct snd_pcm *snd_pcm_get(struct snd_card *card, int device)
 	return NULL;
 }
 
-static inline int snd_pcm_next(struct snd_card *card, int device)
-{
-	struct snd_pcm *pcm;
-
-	list_for_each_entry(pcm, &snd_pcm_devices, list) {
-		if (pcm->card == card && pcm->device > device)
-			return pcm->device;
-		else if (pcm->card->number > card->number)
-			return -1;
-	}
-	return -1;
-}
-
-static inline int snd_pcm_add(struct snd_pcm *newpcm)
-{
-	struct snd_pcm *pcm;
-
-	list_for_each_entry(pcm, &snd_pcm_devices, list) {
-		if (pcm->card == newpcm->card && pcm->device == newpcm->device)
-			return -EBUSY;
-		if (pcm->card->number > newpcm->card->number ||
-				(pcm->card == newpcm->card &&
-				pcm->device > newpcm->device)) {
-			list_add(&newpcm->list, pcm->list.prev);
-			return 0;
-		}
-	}
-	list_add_tail(&newpcm->list, &snd_pcm_devices);
-	return 0;
-}
-
 static int snd_pcm_control_ioctl(struct snd_card *card,
 				 struct snd_ctl_file *control,
 				 unsigned int cmd, unsigned long arg)
@@ -96,7 +65,14 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 			if (get_user(device, (int __user *)arg))
 				return -EFAULT;
 			mutex_lock(&register_mutex);
-			device = snd_pcm_next(card, device);
+			device = device < 0 ? 0 : device + 1;
+			while (device < SNDRV_PCM_DEVICES) {
+				if (snd_pcm_search(card, device))
+					break;
+				device++;
+			}
+			if (device == SNDRV_PCM_DEVICES)
+				device = -1;
 			mutex_unlock(&register_mutex);
 			if (put_user(device, (int __user *)arg))
 				return -EFAULT;
@@ -122,7 +98,7 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 			if (get_user(subdevice, &info->subdevice))
 				return -EFAULT;
 			mutex_lock(&register_mutex);
-			pcm = snd_pcm_get(card, device);
+			pcm = snd_pcm_search(card, device);
 			if (pcm == NULL) {
 				err = -ENXIO;
 				goto _error;
@@ -955,11 +931,11 @@ static int snd_pcm_dev_register(struct snd_device *device)
 
 	snd_assert(pcm != NULL && device != NULL, return -ENXIO);
 	mutex_lock(&register_mutex);
-	err = snd_pcm_add(pcm);
-	if (err) {
+	if (snd_pcm_search(pcm->card, pcm->device)) {
 		mutex_unlock(&register_mutex);
-		return err;
+		return -EBUSY;
 	}
+	list_add_tail(&pcm->list, &snd_pcm_devices);
 	for (cidx = 0; cidx < 2; cidx++) {
 		int devtype = -1;
 		if (pcm->streams[cidx].substream == NULL)

commit 9423969005586e6e27ca380e01b4a8c50698e2af
Author: Pawel MOLL <pawel.moll@st.com>
Date:   Tue Jul 29 17:34:26 2008 +0100

    ALSA: Fix limit of 8 PCM devices in SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE
    
    When compiled with CONFIG_SND_DYNAMIC_MINORS the ALSA core is fine
    to have more than 8 PCM devices per card, except one place - the
    SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE ioctl, which will not enumerate
    devices > 7. This patch fixes the issue, changing the devices list
    organisation.
    
    Instead of adding new device to the tail, the list is now kept always
    ordered (by card number, then device number). Thus, during enumeration,
    it is easy to discover the fact that there is no more given card's
    devices. The same limit was present in OSS emulation code. It has
    been fixed as well.
    
    Additionally the device field of struct snd_pcm is now int, instead of
    unsigned int, as there is no obvious reason for keeping it unsigned.
    This caused a lot of problems with comparing this value with other
    (almost always signed) variables. There is just one more place where
    device number is unsigned - in struct snd_pcm_info, which should be
    also sorted out in future.
    
    Signed-off-by: Pawel MOLL <pawel.moll@st.com>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index ece25c718e95..24271a3bd901 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -42,7 +42,7 @@ static int snd_pcm_dev_free(struct snd_device *device);
 static int snd_pcm_dev_register(struct snd_device *device);
 static int snd_pcm_dev_disconnect(struct snd_device *device);
 
-static struct snd_pcm *snd_pcm_search(struct snd_card *card, int device)
+static inline struct snd_pcm *snd_pcm_get(struct snd_card *card, int device)
 {
 	struct snd_pcm *pcm;
 
@@ -53,6 +53,37 @@ static struct snd_pcm *snd_pcm_search(struct snd_card *card, int device)
 	return NULL;
 }
 
+static inline int snd_pcm_next(struct snd_card *card, int device)
+{
+	struct snd_pcm *pcm;
+
+	list_for_each_entry(pcm, &snd_pcm_devices, list) {
+		if (pcm->card == card && pcm->device > device)
+			return pcm->device;
+		else if (pcm->card->number > card->number)
+			return -1;
+	}
+	return -1;
+}
+
+static inline int snd_pcm_add(struct snd_pcm *newpcm)
+{
+	struct snd_pcm *pcm;
+
+	list_for_each_entry(pcm, &snd_pcm_devices, list) {
+		if (pcm->card == newpcm->card && pcm->device == newpcm->device)
+			return -EBUSY;
+		if (pcm->card->number > newpcm->card->number ||
+				(pcm->card == newpcm->card &&
+				pcm->device > newpcm->device)) {
+			list_add(&newpcm->list, pcm->list.prev);
+			return 0;
+		}
+	}
+	list_add_tail(&newpcm->list, &snd_pcm_devices);
+	return 0;
+}
+
 static int snd_pcm_control_ioctl(struct snd_card *card,
 				 struct snd_ctl_file *control,
 				 unsigned int cmd, unsigned long arg)
@@ -65,14 +96,7 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 			if (get_user(device, (int __user *)arg))
 				return -EFAULT;
 			mutex_lock(&register_mutex);
-			device = device < 0 ? 0 : device + 1;
-			while (device < SNDRV_PCM_DEVICES) {
-				if (snd_pcm_search(card, device))
-					break;
-				device++;
-			}
-			if (device == SNDRV_PCM_DEVICES)
-				device = -1;
+			device = snd_pcm_next(card, device);
 			mutex_unlock(&register_mutex);
 			if (put_user(device, (int __user *)arg))
 				return -EFAULT;
@@ -98,7 +122,7 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 			if (get_user(subdevice, &info->subdevice))
 				return -EFAULT;
 			mutex_lock(&register_mutex);
-			pcm = snd_pcm_search(card, device);
+			pcm = snd_pcm_get(card, device);
 			if (pcm == NULL) {
 				err = -ENXIO;
 				goto _error;
@@ -931,11 +955,11 @@ static int snd_pcm_dev_register(struct snd_device *device)
 
 	snd_assert(pcm != NULL && device != NULL, return -ENXIO);
 	mutex_lock(&register_mutex);
-	if (snd_pcm_search(pcm->card, pcm->device)) {
+	err = snd_pcm_add(pcm);
+	if (err) {
 		mutex_unlock(&register_mutex);
-		return -EBUSY;
+		return err;
 	}
-	list_add_tail(&pcm->list, &snd_pcm_devices);
 	for (cidx = 0; cidx < 2; cidx++) {
 		int devtype = -1;
 		if (pcm->streams[cidx].substream == NULL)

commit 399ccdc1cd4e92e541d4dacbbf18c52bd693418b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 25 14:51:03 2008 +0200

    ALSA: fix locking in snd_pcm_open*() and snd_rawmidi_open*()
    
    The PCM and rawmidi open callbacks have a lock against card->controls_list
    but it takes a wrong one, card->controls_rwsem, instead of a right one
    card->ctl_files_rwlock.  This patch fixes them.
    
    This change also fixes automatically the potential deadlocks due to
    mm->mmap_sem in munmap and copy_from/to_user, reported by Sitsofe
    Wheeler:
    
      A: snd_ctl_elem_user_tlv(): card->controls_rwsem => mm->mmap_sem
      B: snd_pcm_open(): card->open_mutex => card->controls_rwsem
      C: munmap: mm->mmap_sem => snd_pcm_release(): card->open_mutex
    
    The patch breaks the chain.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 9dd9bc73fe1d..ece25c718e95 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -781,7 +781,7 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 		return -ENODEV;
 
 	card = pcm->card;
-	down_read(&card->controls_rwsem);
+	read_lock(&card->ctl_files_rwlock);
 	list_for_each_entry(kctl, &card->ctl_files, list) {
 		if (kctl->pid == current->pid) {
 			prefer_subdevice = kctl->prefer_pcm_subdevice;
@@ -789,7 +789,7 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 				break;
 		}
 	}
-	up_read(&card->controls_rwsem);
+	read_unlock(&card->ctl_files_rwlock);
 
 	switch (stream) {
 	case SNDRV_PCM_STREAM_PLAYBACK:

commit 8c12158687fc78091730d5456336b7efbf6f2250
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Jan 11 08:45:08 2008 +0100

    [ALSA] PCM interface - rename SNDRV_PCM_TSTAMP_MMAP to SNDRV_PCM_TSTAMP_ENABLE
    
    Change semantics for SNDRV_PCM_TSTAMP_MMAP. Doing timestamping only in
    the interrupt handler might cause that hw_ptr is not related to actual
    timestamp. With this change, grab timestamp at every hw_ptr update to
    have always valid timestamp + ring buffer position pair.
    With this change, SNDRV_PCM_TSTAMP_MMAP was renamed to
    SNDRV_PCM_TSTAMP_ENABLE. It's no regression (I think).
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 1502acd81a18..9dd9bc73fe1d 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -227,7 +227,7 @@ static char *snd_pcm_subformat_names[] = {
 
 static char *snd_pcm_tstamp_mode_names[] = {
 	TSTAMP(NONE),
-	TSTAMP(MMAP),
+	TSTAMP(ENABLE),
 };
 
 static const char *snd_pcm_stream_name(int stream)

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index cf3af39c3514..1502acd81a18 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -19,7 +19,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/time.h>

commit 31e8960b35975ed235d283d6fb95d0e28dffded0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:09:57 2008 +0100

    [ALSA] Remove PCM sleep_min and tick
    
    The 'tick' in PCM is set (again) via sw_params.  And, nobody uses
    this feature at all except for a command line option of aplay.
    (This is literally 'nobody', as I checked alsa-lib API calls in all
     programs in major distros.)
    Above all, if we need finer wake-ups for the position update, it's
    basically an issue that the driver should solve, not tuned by each
    application.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 97cb681502a3..cf3af39c3514 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -359,7 +359,6 @@ static void snd_pcm_substream_proc_hw_params_read(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "rate: %u (%u/%u)\n", runtime->rate, runtime->rate_num, runtime->rate_den);	
 	snd_iprintf(buffer, "period_size: %lu\n", runtime->period_size);	
 	snd_iprintf(buffer, "buffer_size: %lu\n", runtime->buffer_size);	
-	snd_iprintf(buffer, "tick_time: %u\n", runtime->tick_time);
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	if (substream->oss.oss) {
 		snd_iprintf(buffer, "OSS format: %s\n", snd_pcm_oss_format_name(runtime->oss.format));
@@ -387,7 +386,6 @@ static void snd_pcm_substream_proc_sw_params_read(struct snd_info_entry *entry,
 	}
 	snd_iprintf(buffer, "tstamp_mode: %s\n", snd_pcm_tstamp_mode_name(runtime->tstamp_mode));
 	snd_iprintf(buffer, "period_step: %u\n", runtime->period_step);
-	snd_iprintf(buffer, "sleep_min: %u\n", runtime->sleep_min);
 	snd_iprintf(buffer, "avail_min: %lu\n", runtime->control->avail_min);
 	snd_iprintf(buffer, "start_threshold: %lu\n", runtime->start_threshold);
 	snd_iprintf(buffer, "stop_threshold: %lu\n", runtime->stop_threshold);
@@ -764,12 +762,6 @@ static int snd_pcm_dev_free(struct snd_device *device)
 	return snd_pcm_free(pcm);
 }
 
-static void snd_pcm_tick_timer_func(unsigned long data)
-{
-	struct snd_pcm_substream *substream = (struct snd_pcm_substream *) data;
-	snd_pcm_tick_elapsed(substream);
-}
-
 int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 			     struct file *file,
 			     struct snd_pcm_substream **rsubstream)
@@ -876,9 +868,6 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 	memset((void*)runtime->control, 0, size);
 
 	init_waitqueue_head(&runtime->sleep);
-	init_timer(&runtime->tick_timer);
-	runtime->tick_timer.function = snd_pcm_tick_timer_func;
-	runtime->tick_timer.data = (unsigned long) substream;
 
 	runtime->status->state = SNDRV_PCM_STATE_OPEN;
 

commit d948035a928400ae127c873fbf771389bee18949
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:05:26 2008 +0100

    [ALSA] Remove PCM xfer_align sw params
    
    The xfer_align sw_params parameter has never been used in a sane manner,
    and no one understands what this does exactly.  The current
    implementation looks also buggy because it allows write of shorter size
    than xfer_align.  So, if you do partial writes, the write isn't actually
    aligned at all.
    Removing this parameter will make some pcm_lib_* code more readable
    (and less buggy).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index cf9b9493d41d..97cb681502a3 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -389,7 +389,6 @@ static void snd_pcm_substream_proc_sw_params_read(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "period_step: %u\n", runtime->period_step);
 	snd_iprintf(buffer, "sleep_min: %u\n", runtime->sleep_min);
 	snd_iprintf(buffer, "avail_min: %lu\n", runtime->control->avail_min);
-	snd_iprintf(buffer, "xfer_align: %lu\n", runtime->xfer_align);
 	snd_iprintf(buffer, "start_threshold: %lu\n", runtime->start_threshold);
 	snd_iprintf(buffer, "stop_threshold: %lu\n", runtime->stop_threshold);
 	snd_iprintf(buffer, "silence_threshold: %lu\n", runtime->silence_threshold);

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 2743414fc8fa..cf9b9493d41d 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1,6 +1,6 @@
 /*
  *  Digital Audio (PCM) abstract layer
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *
  *
  *   This program is free software; you can redistribute it and/or modify
@@ -30,7 +30,7 @@
 #include <sound/control.h>
 #include <sound/info.h>
 
-MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, Abramo Bagnara <abramo@alsa-project.org>");
+MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>, Abramo Bagnara <abramo@alsa-project.org>");
 MODULE_DESCRIPTION("Midlevel PCM code for ALSA.");
 MODULE_LICENSE("GPL");
 

commit c2902c8ae06762d941fab64198467f78cab6f8cd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 9 16:25:48 2007 +0100

    [PATCH] Fix breakage with CONFIG_SYSFS_DEPRECATED
    
    The fix for sysfs breakage with CONFIG_SYSFS_DEPRECATED was flown
    away by the conflicted merge of the ALSA git tree.  The patch below
    fixes it again.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 76fcc5234d83..2743414fc8fa 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -968,7 +968,7 @@ static int snd_pcm_dev_register(struct snd_device *device)
 		 * if possible */
 		dev = pcm->dev;
 		if (!dev)
-			dev = pcm->card ? pcm->card->dev : NULL;
+			dev = snd_card_get_device_link(pcm->card);
 		/* register pcm */
 		err = snd_register_device_for_dev(devtype, pcm->card,
 						  pcm->device,

commit 9244b2c3079faac79b3b961116bd548c45087e2c
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Oct 5 16:02:22 2006 +0200

    [ALSA] alsa core: convert to list_for_each_entry*
    
    This patch converts most uses of list_for_each to list_for_each_entry all
    across alsa. In some place apparently an item can be on a list with
    different pointers so of course that isn't compatible with list_for_each, I
    therefore didn't touch those places.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 4701f07ee0ae..76fcc5234d83 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -45,11 +45,9 @@ static int snd_pcm_dev_disconnect(struct snd_device *device);
 
 static struct snd_pcm *snd_pcm_search(struct snd_card *card, int device)
 {
-	struct list_head *p;
 	struct snd_pcm *pcm;
 
-	list_for_each(p, &snd_pcm_devices) {
-		pcm = list_entry(p, struct snd_pcm, list);
+	list_for_each_entry(pcm, &snd_pcm_devices, list) {
 		if (pcm->card == card && pcm->device == device)
 			return pcm;
 	}
@@ -782,7 +780,6 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 	struct snd_pcm_runtime *runtime;
 	struct snd_ctl_file *kctl;
 	struct snd_card *card;
-	struct list_head *list;
 	int prefer_subdevice = -1;
 	size_t size;
 
@@ -795,8 +792,7 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 
 	card = pcm->card;
 	down_read(&card->controls_rwsem);
-	list_for_each(list, &card->ctl_files) {
-		kctl = snd_ctl_file(list);
+	list_for_each_entry(kctl, &card->ctl_files, list) {
 		if (kctl->pid == current->pid) {
 			prefer_subdevice = kctl->prefer_pcm_subdevice;
 			if (prefer_subdevice != -1)
@@ -941,7 +937,7 @@ static int snd_pcm_dev_register(struct snd_device *device)
 {
 	int cidx, err;
 	struct snd_pcm_substream *substream;
-	struct list_head *list;
+	struct snd_pcm_notify *notify;
 	char str[16];
 	struct snd_pcm *pcm = device->device_data;
 	struct device *dev;
@@ -988,11 +984,10 @@ static int snd_pcm_dev_register(struct snd_device *device)
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
 			snd_pcm_timer_init(substream);
 	}
-	list_for_each(list, &snd_pcm_notify_list) {
-		struct snd_pcm_notify *notify;
-		notify = list_entry(list, struct snd_pcm_notify, list);
+
+	list_for_each_entry(notify, &snd_pcm_notify_list, list)
 		notify->n_register(pcm);
-	}
+
 	mutex_unlock(&register_mutex);
 	return 0;
 }
@@ -1035,7 +1030,7 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 
 int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 {
-	struct list_head *p;
+	struct snd_pcm *pcm;
 
 	snd_assert(notify != NULL &&
 		   notify->n_register != NULL &&
@@ -1044,13 +1039,12 @@ int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 	mutex_lock(&register_mutex);
 	if (nfree) {
 		list_del(&notify->list);
-		list_for_each(p, &snd_pcm_devices)
-			notify->n_unregister(list_entry(p,
-							struct snd_pcm, list));
+		list_for_each_entry(pcm, &snd_pcm_devices, list)
+			notify->n_unregister(pcm);
 	} else {
 		list_add_tail(&notify->list, &snd_pcm_notify_list);
-		list_for_each(p, &snd_pcm_devices)
-			notify->n_register(list_entry(p, struct snd_pcm, list));
+		list_for_each_entry(pcm, &snd_pcm_devices, list)
+			notify->n_register(pcm);
 	}
 	mutex_unlock(&register_mutex);
 	return 0;
@@ -1066,12 +1060,10 @@ EXPORT_SYMBOL(snd_pcm_notify);
 static void snd_pcm_proc_read(struct snd_info_entry *entry,
 			      struct snd_info_buffer *buffer)
 {
-	struct list_head *p;
 	struct snd_pcm *pcm;
 
 	mutex_lock(&register_mutex);
-	list_for_each(p, &snd_pcm_devices) {
-		pcm = list_entry(p, struct snd_pcm, list);
+	list_for_each_entry(pcm, &snd_pcm_devices, list) {
 		snd_iprintf(buffer, "%02i-%02i: %s : %s",
 			    pcm->card->number, pcm->device, pcm->id, pcm->name);
 		if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream)

commit c78085fcd2ce7cd036e1488472eb41a64d70949a
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Oct 5 15:06:34 2006 +0200

    [ALSA] alsa core: add struct device pointer to struct snd_pcm
    
    This patch adds a struct device pointer to struct snd_pcm in order to be
    able to give it a different device than the card. It defaults to the card's
    device, however, so it should behave identically for drivers not touching
    the field.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 8e0189885516..4701f07ee0ae 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -944,6 +944,7 @@ static int snd_pcm_dev_register(struct snd_device *device)
 	struct list_head *list;
 	char str[16];
 	struct snd_pcm *pcm = device->device_data;
+	struct device *dev;
 
 	snd_assert(pcm != NULL && device != NULL, return -ENXIO);
 	mutex_lock(&register_mutex);
@@ -966,11 +967,18 @@ static int snd_pcm_dev_register(struct snd_device *device)
 			devtype = SNDRV_DEVICE_TYPE_PCM_CAPTURE;
 			break;
 		}
-		if ((err = snd_register_device(devtype, pcm->card,
-					       pcm->device,
-					       &snd_pcm_f_ops[cidx],
-					       pcm, str)) < 0)
-		{
+		/* device pointer to use, pcm->dev takes precedence if
+		 * it is assigned, otherwise fall back to card's device
+		 * if possible */
+		dev = pcm->dev;
+		if (!dev)
+			dev = pcm->card ? pcm->card->dev : NULL;
+		/* register pcm */
+		err = snd_register_device_for_dev(devtype, pcm->card,
+						  pcm->device,
+						  &snd_pcm_f_ops[cidx],
+						  pcm, str, dev);
+		if (err < 0) {
 			list_del(&pcm->list);
 			mutex_unlock(&register_mutex);
 			return err;

commit 4d361285925613516560f81f8c7fc96b89c8b1a8
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Nov 23 12:03:24 2006 +0100

    [ALSA] sound: fix PCM substream list
    
    If snd_pcm_new_stream() fails to initalize a substream (if
    snd_pcm_substream_proc_init() returns error), snd_pcm_new_stream()
    immediately return without unlinking that kfree()d substram.
    It causes oops when snd_pcm_free() iterates the list of substream to
    free them by invalid reference.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 5ac6e19ccb41..8e0189885516 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -640,6 +640,10 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 		err = snd_pcm_substream_proc_init(substream);
 		if (err < 0) {
 			snd_printk(KERN_ERR "Error in snd_pcm_stream_proc_init\n");
+			if (prev == NULL)
+				pstr->substream = NULL;
+			else
+				prev->next = NULL;
 			kfree(substream);
 			return err;
 		}

commit d80f19fab89cba8a6d16193154c8ff3edab00942
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 7 22:19:37 2006 -0700

    Driver core: convert sound core to use struct device
    
    Converts from using struct "class_device" to "struct device" making
    everything show up properly in /sys/devices/ with symlinks from the
    /sys/class directory.
    
    It also makes the struct sound_card to show up as a "real" device
    where all the different sound class devices are placed as childs
    and different card attribute files can hang off of. /sys/class/sound is
    still a flat directory, but the symlink targets of all devices belonging
    to the same card, point the the /sys/devices tree below the new card
    device object.
    
    Thanks to Kay for the updates to this patch.
    
    Signed-off-by: Kay Sievers <kay.sievers@novell.com>
    Acked-by: Jaroslav Kysela <perex@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index fbbbcd20c4cc..5ac6e19ccb41 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -910,7 +910,8 @@ void snd_pcm_detach_substream(struct snd_pcm_substream *substream)
 	substream->pstr->substream_opened--;
 }
 
-static ssize_t show_pcm_class(struct class_device *class_device, char *buf)
+static ssize_t show_pcm_class(struct device *dev,
+			      struct device_attribute *attr, char *buf)
 {
 	struct snd_pcm *pcm;
 	const char *str;
@@ -921,7 +922,7 @@ static ssize_t show_pcm_class(struct class_device *class_device, char *buf)
 		[SNDRV_PCM_CLASS_DIGITIZER] = "digitizer",
 	};
 
-	if (! (pcm = class_get_devdata(class_device)) ||
+	if (! (pcm = dev_get_drvdata(dev)) ||
 	    pcm->dev_class > SNDRV_PCM_CLASS_LAST)
 		str = "none";
 	else
@@ -929,7 +930,7 @@ static ssize_t show_pcm_class(struct class_device *class_device, char *buf)
         return snprintf(buf, PAGE_SIZE, "%s\n", str);
 }
 
-static struct class_device_attribute pcm_attrs =
+static struct device_attribute pcm_attrs =
 	__ATTR(pcm_class, S_IRUGO, show_pcm_class, NULL);
 
 static int snd_pcm_dev_register(struct snd_device *device)

commit 9442e691e4aec85eba43ac60a3e77c77fd2e73a4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat Sep 30 23:27:19 2006 -0700

    [PATCH] maximum latency tracking: ALSA support
    
    Add maximum latency tracking to the ALSA subsystem for PCM playback.  In
    ALSA, the playback application controls the buffer size and thus indirectly
    the period of latency that it can deal with.  This patch uses 75% of the
    total available latency as threshold to announce to the latency subsystem;
    While 75% is a crude heuristic it's a quite reasonable one; the remaining
    25% can be used for all driver processing for the next samples which is
    also proportional to the size of the buffer.
    
    With ogg123 a latency setting of about 4msec was seen (at 44Khz), while
    with the "play" command a much longer maximum tolerable latency was seen.
    Other, more multimedia oriented players as well as games, will have a lot
    smaller buffers to allow better synchronization and those will actually get
    into the latency domains where there is impact on the power management
    rules.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index bf8f412988b8..fbbbcd20c4cc 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -629,6 +629,9 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 		substream->number = idx;
 		substream->stream = stream;
 		sprintf(substream->name, "subdevice #%i", idx);
+		snprintf(substream->latency_id, sizeof(substream->latency_id),
+			 "ALSA-PCM%d-%d%c%d", pcm->card->number, pcm->device,
+			 (stream ? 'c' : 'p'), idx);
 		substream->buffer_bytes_max = UINT_MAX;
 		if (prev == NULL)
 			pstr->substream = substream;

commit 9d19f48cfe2570562c2c6226780a7ca627b0f1f1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 6 14:27:46 2006 +0200

    [ALSA] Add pcm_class attribute to PCM sysfs entry
    
    This patch adds a new attribute, pcm_class, to each PCM sysfs entry.
    It's useful to detect what kind of PCM stream is, for example, HAL
    can check whether it's a modem or not.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index ed3b09469560..bf8f412988b8 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -907,6 +907,28 @@ void snd_pcm_detach_substream(struct snd_pcm_substream *substream)
 	substream->pstr->substream_opened--;
 }
 
+static ssize_t show_pcm_class(struct class_device *class_device, char *buf)
+{
+	struct snd_pcm *pcm;
+	const char *str;
+	static const char *strs[SNDRV_PCM_CLASS_LAST + 1] = {
+		[SNDRV_PCM_CLASS_GENERIC] = "generic",
+		[SNDRV_PCM_CLASS_MULTI] = "multi",
+		[SNDRV_PCM_CLASS_MODEM] = "modem",
+		[SNDRV_PCM_CLASS_DIGITIZER] = "digitizer",
+	};
+
+	if (! (pcm = class_get_devdata(class_device)) ||
+	    pcm->dev_class > SNDRV_PCM_CLASS_LAST)
+		str = "none";
+	else
+		str = strs[pcm->dev_class];
+        return snprintf(buf, PAGE_SIZE, "%s\n", str);
+}
+
+static struct class_device_attribute pcm_attrs =
+	__ATTR(pcm_class, S_IRUGO, show_pcm_class, NULL);
+
 static int snd_pcm_dev_register(struct snd_device *device)
 {
 	int cidx, err;
@@ -945,6 +967,8 @@ static int snd_pcm_dev_register(struct snd_device *device)
 			mutex_unlock(&register_mutex);
 			return err;
 		}
+		snd_add_device_sysfs_file(devtype, pcm->card, pcm->device,
+					  &pcm_attrs);
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
 			snd_pcm_timer_init(substream);
 	}

commit 2529bba7606b23c1b7161d3c2ad486162e8650f9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 4 12:57:19 2006 +0200

    [ALSA] Fix substream selection in PCM and rawmidi
    
    The PCM and rawmidi substreams can be selected explicitly by opening
    control handle and set via *_PREFER_SUBDEVICE ioctl.  But, when
    multiple controls are opened, the driver gets confused.
    The patch fixes the initialization of prefer_*_subdevice and the
    check of multiple controls.  The first set subdevice is picked up
    as the valid one.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index f52178abf120..ed3b09469560 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -792,7 +792,8 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 		kctl = snd_ctl_file(list);
 		if (kctl->pid == current->pid) {
 			prefer_subdevice = kctl->prefer_pcm_subdevice;
-			break;
+			if (prefer_subdevice != -1)
+				break;
 		}
 	}
 	up_read(&card->controls_rwsem);

commit c461482c8072bb073e6146db320d3da85cdc89ad
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 23 14:38:23 2006 +0200

    [ALSA] Unregister device files at disconnection
    
    Orignally proposed by Sam Revitch <sam.revitch@gmail.com>.
    Unregister device files at disconnection to avoid the futher accesses.
    Also, the dev_unregister callback is removed and replaced with the
    combination of disconnect + free.
    A new function snd_card_free_when_closed() is introduced, which is
    used in USB disconnect callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index b8602471f7e5..f52178abf120 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -42,7 +42,6 @@ static int snd_pcm_free(struct snd_pcm *pcm);
 static int snd_pcm_dev_free(struct snd_device *device);
 static int snd_pcm_dev_register(struct snd_device *device);
 static int snd_pcm_dev_disconnect(struct snd_device *device);
-static int snd_pcm_dev_unregister(struct snd_device *device);
 
 static struct snd_pcm *snd_pcm_search(struct snd_card *card, int device)
 {
@@ -680,7 +679,6 @@ int snd_pcm_new(struct snd_card *card, char *id, int device,
 		.dev_free = snd_pcm_dev_free,
 		.dev_register =	snd_pcm_dev_register,
 		.dev_disconnect = snd_pcm_dev_disconnect,
-		.dev_unregister = snd_pcm_dev_unregister
 	};
 
 	snd_assert(rpcm != NULL, return -EINVAL);
@@ -724,6 +722,7 @@ static void snd_pcm_free_stream(struct snd_pcm_str * pstr)
 	substream = pstr->substream;
 	while (substream) {
 		substream_next = substream->next;
+		snd_pcm_timer_done(substream);
 		snd_pcm_substream_proc_done(substream);
 		kfree(substream);
 		substream = substream_next;
@@ -740,7 +739,12 @@ static void snd_pcm_free_stream(struct snd_pcm_str * pstr)
 
 static int snd_pcm_free(struct snd_pcm *pcm)
 {
+	struct snd_pcm_notify *notify;
+
 	snd_assert(pcm != NULL, return -ENXIO);
+	list_for_each_entry(notify, &snd_pcm_notify_list, list) {
+		notify->n_unregister(pcm);
+	}
 	if (pcm->private_free)
 		pcm->private_free(pcm);
 	snd_pcm_lib_preallocate_free_for_all(pcm);
@@ -955,35 +959,22 @@ static int snd_pcm_dev_register(struct snd_device *device)
 static int snd_pcm_dev_disconnect(struct snd_device *device)
 {
 	struct snd_pcm *pcm = device->device_data;
-	struct list_head *list;
+	struct snd_pcm_notify *notify;
 	struct snd_pcm_substream *substream;
-	int cidx;
+	int cidx, devtype;
 
 	mutex_lock(&register_mutex);
+	if (list_empty(&pcm->list))
+		goto unlock;
+
 	list_del_init(&pcm->list);
 	for (cidx = 0; cidx < 2; cidx++)
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
 			if (substream->runtime)
 				substream->runtime->status->state = SNDRV_PCM_STATE_DISCONNECTED;
-	list_for_each(list, &snd_pcm_notify_list) {
-		struct snd_pcm_notify *notify;
-		notify = list_entry(list, struct snd_pcm_notify, list);
+	list_for_each_entry(notify, &snd_pcm_notify_list, list) {
 		notify->n_disconnect(pcm);
 	}
-	mutex_unlock(&register_mutex);
-	return 0;
-}
-
-static int snd_pcm_dev_unregister(struct snd_device *device)
-{
-	int cidx, devtype;
-	struct snd_pcm_substream *substream;
-	struct list_head *list;
-	struct snd_pcm *pcm = device->device_data;
-
-	snd_assert(pcm != NULL, return -ENXIO);
-	mutex_lock(&register_mutex);
-	list_del(&pcm->list);
 	for (cidx = 0; cidx < 2; cidx++) {
 		devtype = -1;
 		switch (cidx) {
@@ -995,23 +986,20 @@ static int snd_pcm_dev_unregister(struct snd_device *device)
 			break;
 		}
 		snd_unregister_device(devtype, pcm->card, pcm->device);
-		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
-			snd_pcm_timer_done(substream);
-	}
-	list_for_each(list, &snd_pcm_notify_list) {
-		struct snd_pcm_notify *notify;
-		notify = list_entry(list, struct snd_pcm_notify, list);
-		notify->n_unregister(pcm);
 	}
+ unlock:
 	mutex_unlock(&register_mutex);
-	return snd_pcm_free(pcm);
+	return 0;
 }
 
 int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 {
 	struct list_head *p;
 
-	snd_assert(notify != NULL && notify->n_register != NULL && notify->n_unregister != NULL, return -EINVAL);
+	snd_assert(notify != NULL &&
+		   notify->n_register != NULL &&
+		   notify->n_unregister != NULL &&
+		   notify->n_disconnect, return -EINVAL);
 	mutex_lock(&register_mutex);
 	if (nfree) {
 		list_del(&notify->list);

commit 746d4a02e68499fc6c1f8d0c43d2271853ade181
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 23 14:37:59 2006 +0200

    [ALSA] Fix disconnection of proc interface
    
    - Add the linked list to each proc entry to enable a single-shot
      disconnection (unregister)
    - Deprecate snd_info_unregister(), use snd_info_free_entry()
    - Removed NULL checks of snd_info_free_entry()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 7581edd7b9ff..b8602471f7e5 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -494,19 +494,13 @@ static int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)
 static int snd_pcm_stream_proc_done(struct snd_pcm_str *pstr)
 {
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
-	if (pstr->proc_xrun_debug_entry) {
-		snd_info_unregister(pstr->proc_xrun_debug_entry);
-		pstr->proc_xrun_debug_entry = NULL;
-	}
+	snd_info_free_entry(pstr->proc_xrun_debug_entry);
+	pstr->proc_xrun_debug_entry = NULL;
 #endif
-	if (pstr->proc_info_entry) {
-		snd_info_unregister(pstr->proc_info_entry);
-		pstr->proc_info_entry = NULL;
-	}
-	if (pstr->proc_root) {
-		snd_info_unregister(pstr->proc_root);
-		pstr->proc_root = NULL;
-	}
+	snd_info_free_entry(pstr->proc_info_entry);
+	pstr->proc_info_entry = NULL;
+	snd_info_free_entry(pstr->proc_root);
+	pstr->proc_root = NULL;
 	return 0;
 }
 
@@ -570,29 +564,19 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 
 	return 0;
 }
-		
+
 static int snd_pcm_substream_proc_done(struct snd_pcm_substream *substream)
 {
-	if (substream->proc_info_entry) {
-		snd_info_unregister(substream->proc_info_entry);
-		substream->proc_info_entry = NULL;
-	}
-	if (substream->proc_hw_params_entry) {
-		snd_info_unregister(substream->proc_hw_params_entry);
-		substream->proc_hw_params_entry = NULL;
-	}
-	if (substream->proc_sw_params_entry) {
-		snd_info_unregister(substream->proc_sw_params_entry);
-		substream->proc_sw_params_entry = NULL;
-	}
-	if (substream->proc_status_entry) {
-		snd_info_unregister(substream->proc_status_entry);
-		substream->proc_status_entry = NULL;
-	}
-	if (substream->proc_root) {
-		snd_info_unregister(substream->proc_root);
-		substream->proc_root = NULL;
-	}
+	snd_info_free_entry(substream->proc_info_entry);
+	substream->proc_info_entry = NULL;
+	snd_info_free_entry(substream->proc_hw_params_entry);
+	substream->proc_hw_params_entry = NULL;
+	snd_info_free_entry(substream->proc_sw_params_entry);
+	substream->proc_sw_params_entry = NULL;
+	snd_info_free_entry(substream->proc_status_entry);
+	substream->proc_status_entry = NULL;
+	snd_info_free_entry(substream->proc_root);
+	substream->proc_root = NULL;
 	return 0;
 }
 #else /* !CONFIG_SND_VERBOSE_PROCFS */
@@ -1090,8 +1074,7 @@ static void snd_pcm_proc_init(void)
 
 static void snd_pcm_proc_done(void)
 {
-	if (snd_pcm_proc_entry)
-		snd_info_unregister(snd_pcm_proc_entry);
+	snd_info_free_entry(snd_pcm_proc_entry);
 }
 
 #else /* !CONFIG_PROC_FS */

commit 6581f4e74d8541dd7d579f64e94822622cbb1654
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 17 17:14:51 2006 +0200

    [ALSA] Remove zero-initialization of static variables
    
    Removed zero-initializations of static variables.
    A tiny optimization.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index bc00f9b00cbd..7581edd7b9ff 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1072,7 +1072,7 @@ static void snd_pcm_proc_read(struct snd_info_entry *entry,
 	mutex_unlock(&register_mutex);
 }
 
-static struct snd_info_entry *snd_pcm_proc_entry = NULL;
+static struct snd_info_entry *snd_pcm_proc_entry;
 
 static void snd_pcm_proc_init(void)
 {

commit 9c323fcbc51493f79f9700cb20830d0857c72d99
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Fix mmap_count with O_APPEND opened streams
    
    Move mmap_count to snd_pcm_substream instead of runtime struct
    so that multiplly opened substreams via O_APPEND can be handled
    correctly.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 8136be2e6066..bc00f9b00cbd 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -662,6 +662,7 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 		INIT_LIST_HEAD(&substream->self_group.substreams);
 		list_add_tail(&substream->link_list, &substream->self_group.substreams);
 		spin_lock_init(&substream->timer_lock);
+		atomic_set(&substream->mmap_count, 0);
 		prev = substream;
 	}
 	return 0;
@@ -884,7 +885,6 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 	memset((void*)runtime->control, 0, size);
 
 	init_waitqueue_head(&runtime->sleep);
-	atomic_set(&runtime->mmap_count, 0);
 	init_timer(&runtime->tick_timer);
 	runtime->tick_timer.function = snd_pcm_tick_timer_func;
 	runtime->tick_timer.data = (unsigned long) substream;

commit 0df63e44c3e315ec0fe427ae62558231864108bd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Add O_APPEND flag support to PCM
    
    Added O_APPEND flag support to PCM to enable shared substreams
    among multiple processes.  This mechanism is used by dmix and
    dsnoop plugins.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 4f5204175d37..8136be2e6066 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -829,6 +829,26 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 		return -EINVAL;
 	}
 
+	if (file->f_flags & O_APPEND) {
+		if (prefer_subdevice < 0) {
+			if (pstr->substream_count > 1)
+				return -EINVAL; /* must be unique */
+			substream = pstr->substream;
+		} else {
+			for (substream = pstr->substream; substream;
+			     substream = substream->next)
+				if (substream->number == prefer_subdevice)
+					break;
+		}
+		if (! substream)
+			return -ENODEV;
+		if (! SUBSTREAM_BUSY(substream))
+			return -EBADFD;
+		substream->ref_count++;
+		*rsubstream = substream;
+		return 0;
+	}
+
 	if (prefer_subdevice >= 0) {
 		for (substream = pstr->substream; substream; substream = substream->next)
 			if (!SUBSTREAM_BUSY(substream) && substream->number == prefer_subdevice)
@@ -873,7 +893,8 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 
 	substream->runtime = runtime;
 	substream->private_data = pcm->private_data;
-	substream->ffile = file;
+	substream->ref_count = 1;
+	substream->f_flags = file->f_flags;
 	pstr->substream_opened++;
 	*rsubstream = substream;
 	return 0;
@@ -882,7 +903,7 @@ int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
 void snd_pcm_detach_substream(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime;
-	substream->file = NULL;
+
 	runtime = substream->runtime;
 	snd_assert(runtime != NULL, return);
 	if (runtime->private_free != NULL)

commit d689e34b524b69c111db0b7c844d71c8e1a53b15
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove spinlocks around proc prints
    
    Don't lock during showing proc read.  snd_iprintf() might sleep.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 08223783cfa3..4f5204175d37 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -351,10 +351,8 @@ static void snd_pcm_substream_proc_hw_params_read(struct snd_info_entry *entry,
 		snd_iprintf(buffer, "closed\n");
 		return;
 	}
-	snd_pcm_stream_lock_irq(substream);
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN) {
 		snd_iprintf(buffer, "no setup\n");
-		snd_pcm_stream_unlock_irq(substream);
 		return;
 	}
 	snd_iprintf(buffer, "access: %s\n", snd_pcm_access_name(runtime->access));
@@ -375,7 +373,6 @@ static void snd_pcm_substream_proc_hw_params_read(struct snd_info_entry *entry,
 		snd_iprintf(buffer, "OSS period frames: %lu\n", (unsigned long)runtime->oss.period_frames);
 	}
 #endif
-	snd_pcm_stream_unlock_irq(substream);
 }
 
 static void snd_pcm_substream_proc_sw_params_read(struct snd_info_entry *entry,
@@ -387,10 +384,8 @@ static void snd_pcm_substream_proc_sw_params_read(struct snd_info_entry *entry,
 		snd_iprintf(buffer, "closed\n");
 		return;
 	}
-	snd_pcm_stream_lock_irq(substream);
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN) {
 		snd_iprintf(buffer, "no setup\n");
-		snd_pcm_stream_unlock_irq(substream);
 		return;
 	}
 	snd_iprintf(buffer, "tstamp_mode: %s\n", snd_pcm_tstamp_mode_name(runtime->tstamp_mode));
@@ -403,7 +398,6 @@ static void snd_pcm_substream_proc_sw_params_read(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "silence_threshold: %lu\n", runtime->silence_threshold);
 	snd_iprintf(buffer, "silence_size: %lu\n", runtime->silence_size);
 	snd_iprintf(buffer, "boundary: %lu\n", runtime->boundary);
-	snd_pcm_stream_unlock_irq(substream);
 }
 
 static void snd_pcm_substream_proc_status_read(struct snd_info_entry *entry,

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 8c15c01907f4..08223783cfa3 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -472,7 +472,7 @@ static int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)
 	pstr->proc_root = entry;
 
 	if ((entry = snd_info_create_card_entry(pcm->card, "info", pstr->proc_root)) != NULL) {
-		snd_info_set_text_ops(entry, pstr, 256, snd_pcm_stream_proc_info_read);
+		snd_info_set_text_ops(entry, pstr, snd_pcm_stream_proc_info_read);
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
 			entry = NULL;
@@ -483,9 +483,7 @@ static int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)
 #ifdef CONFIG_SND_PCM_XRUN_DEBUG
 	if ((entry = snd_info_create_card_entry(pcm->card, "xrun_debug",
 						pstr->proc_root)) != NULL) {
-		entry->c.text.read_size = 64;
 		entry->c.text.read = snd_pcm_xrun_debug_read;
-		entry->c.text.write_size = 64;
 		entry->c.text.write = snd_pcm_xrun_debug_write;
 		entry->mode |= S_IWUSR;
 		entry->private_data = pstr;
@@ -537,7 +535,8 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 	substream->proc_root = entry;
 
 	if ((entry = snd_info_create_card_entry(card, "info", substream->proc_root)) != NULL) {
-		snd_info_set_text_ops(entry, substream, 256, snd_pcm_substream_proc_info_read);
+		snd_info_set_text_ops(entry, substream,
+				      snd_pcm_substream_proc_info_read);
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
 			entry = NULL;
@@ -546,7 +545,8 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 	substream->proc_info_entry = entry;
 
 	if ((entry = snd_info_create_card_entry(card, "hw_params", substream->proc_root)) != NULL) {
-		snd_info_set_text_ops(entry, substream, 256, snd_pcm_substream_proc_hw_params_read);
+		snd_info_set_text_ops(entry, substream,
+				      snd_pcm_substream_proc_hw_params_read);
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
 			entry = NULL;
@@ -555,7 +555,8 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 	substream->proc_hw_params_entry = entry;
 
 	if ((entry = snd_info_create_card_entry(card, "sw_params", substream->proc_root)) != NULL) {
-		snd_info_set_text_ops(entry, substream, 256, snd_pcm_substream_proc_sw_params_read);
+		snd_info_set_text_ops(entry, substream,
+				      snd_pcm_substream_proc_sw_params_read);
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
 			entry = NULL;
@@ -564,7 +565,8 @@ static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 	substream->proc_sw_params_entry = entry;
 
 	if ((entry = snd_info_create_card_entry(card, "status", substream->proc_root)) != NULL) {
-		snd_info_set_text_ops(entry, substream, 256, snd_pcm_substream_proc_status_read);
+		snd_info_set_text_ops(entry, substream,
+				      snd_pcm_substream_proc_status_read);
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
 			entry = NULL;
@@ -1062,8 +1064,7 @@ static void snd_pcm_proc_init(void)
 	struct snd_info_entry *entry;
 
 	if ((entry = snd_info_create_module_entry(THIS_MODULE, "pcm", NULL)) != NULL) {
-		snd_info_set_text_ops(entry, NULL, SNDRV_CARDS * SNDRV_PCM_DEVICES * 128,
-				      snd_pcm_proc_read);
+		snd_info_set_text_ops(entry, NULL, snd_pcm_proc_read);
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
 			entry = NULL;

commit e88e8ae639a4908b903d9406c54e99a729b01a28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:40 2006 +0200

    [ALSA] Move OSS-specific hw_params helper to snd-pcm-oss module
    
    Move EXPORT_SYMBOL()s to places adjacent to functions/variables.
    Also move OSS-specific hw_params helper functions to pcm_oss.c.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 84b00038236d..8c15c01907f4 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -671,6 +671,8 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 	return 0;
 }				
 
+EXPORT_SYMBOL(snd_pcm_new_stream);
+
 /**
  * snd_pcm_new - create a new PCM instance
  * @card: the card instance
@@ -730,6 +732,8 @@ int snd_pcm_new(struct snd_card *card, char *id, int device,
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_pcm_new);
+
 static void snd_pcm_free_stream(struct snd_pcm_str * pstr)
 {
 	struct snd_pcm_substream *substream, *substream_next;
@@ -1022,6 +1026,8 @@ int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_pcm_notify);
+
 #ifdef CONFIG_PROC_FS
 /*
  *  Info interface
@@ -1099,33 +1105,3 @@ static void __exit alsa_pcm_exit(void)
 
 module_init(alsa_pcm_init)
 module_exit(alsa_pcm_exit)
-
-EXPORT_SYMBOL(snd_pcm_new);
-EXPORT_SYMBOL(snd_pcm_new_stream);
-EXPORT_SYMBOL(snd_pcm_notify);
-EXPORT_SYMBOL(snd_pcm_open_substream);
-EXPORT_SYMBOL(snd_pcm_release_substream);
-  /* pcm_native.c */
-EXPORT_SYMBOL(snd_pcm_link_rwlock);
-#ifdef CONFIG_PM
-EXPORT_SYMBOL(snd_pcm_suspend);
-EXPORT_SYMBOL(snd_pcm_suspend_all);
-#endif
-EXPORT_SYMBOL(snd_pcm_kernel_ioctl);
-EXPORT_SYMBOL(snd_pcm_mmap_data);
-#if SNDRV_PCM_INFO_MMAP_IOMEM
-EXPORT_SYMBOL(snd_pcm_lib_mmap_iomem);
-#endif
- /* pcm_misc.c */
-EXPORT_SYMBOL(snd_pcm_format_signed);
-EXPORT_SYMBOL(snd_pcm_format_unsigned);
-EXPORT_SYMBOL(snd_pcm_format_linear);
-EXPORT_SYMBOL(snd_pcm_format_little_endian);
-EXPORT_SYMBOL(snd_pcm_format_big_endian);
-EXPORT_SYMBOL(snd_pcm_format_width);
-EXPORT_SYMBOL(snd_pcm_format_physical_width);
-EXPORT_SYMBOL(snd_pcm_format_size);
-EXPORT_SYMBOL(snd_pcm_format_silence_64);
-EXPORT_SYMBOL(snd_pcm_format_set_silence);
-EXPORT_SYMBOL(snd_pcm_build_linear_format);
-EXPORT_SYMBOL(snd_pcm_limit_hw_rates);

commit b7d90a356a43f4609bd6290fc2e1ca4ef79d4458
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 25 12:56:04 2006 +0200

    [ALSA] Fix Oops at rmmod with CONFIG_SND_VERBOSE_PROCFS=n
    
    Fixed Oops at rmmod with CONFIG_SND_VERBOSE_PROCFS=n.
    Add ifdef to struct fields for optimization and better compile
    checks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 48007a54c8b7..84b00038236d 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -142,7 +142,7 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 	return -ENOIOCTLCMD;
 }
 
-#if defined(CONFIG_PROC_FS) && defined(CONFIG_SND_VERBOSE_PROCFS)
+#ifdef CONFIG_SND_VERBOSE_PROCFS
 
 #define STATE(v) [SNDRV_PCM_STATE_##v] = #v
 #define STREAM(v) [SNDRV_PCM_STREAM_##v] = #v
@@ -599,12 +599,12 @@ static int snd_pcm_substream_proc_done(struct snd_pcm_substream *substream)
 	}
 	return 0;
 }
-#else /* !CONFIG_PROC_FS */
+#else /* !CONFIG_SND_VERBOSE_PROCFS */
 static inline int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr) { return 0; }
 static inline int snd_pcm_stream_proc_done(struct snd_pcm_str *pstr) { return 0; }
 static inline int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream) { return 0; }
 static inline int snd_pcm_substream_proc_done(struct snd_pcm_substream *substream) { return 0; }
-#endif /* CONFIG_PROC_FS */
+#endif /* CONFIG_SND_VERBOSE_PROCFS */
 
 /**
  * snd_pcm_new_stream - create a new PCM stream

commit 61fb63c096a2e88b87742eaecfe88912b89f57cf
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Mon Apr 24 21:57:16 2006 +0200

    [ALSA] PCM core - introduce CONFIG_SND_PCM_XRUN_DEBUG
    
    This patch makes the XRUN (overrun/underrun) notification code optional.
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 122e10a61ab9..48007a54c8b7 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -436,7 +436,7 @@ static void snd_pcm_substream_proc_status_read(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "appl_ptr    : %ld\n", runtime->control->appl_ptr);
 }
 
-#ifdef CONFIG_SND_DEBUG
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
 static void snd_pcm_xrun_debug_read(struct snd_info_entry *entry,
 				    struct snd_info_buffer *buffer)
 {
@@ -480,7 +480,7 @@ static int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)
 	}
 	pstr->proc_info_entry = entry;
 
-#ifdef CONFIG_SND_DEBUG
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
 	if ((entry = snd_info_create_card_entry(pcm->card, "xrun_debug",
 						pstr->proc_root)) != NULL) {
 		entry->c.text.read_size = 64;
@@ -501,7 +501,7 @@ static int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)
 
 static int snd_pcm_stream_proc_done(struct snd_pcm_str *pstr)
 {
-#ifdef CONFIG_SND_DEBUG
+#ifdef CONFIG_SND_PCM_XRUN_DEBUG
 	if (pstr->proc_xrun_debug_entry) {
 		snd_info_unregister(pstr->proc_xrun_debug_entry);
 		pstr->proc_xrun_debug_entry = NULL;

commit 12831c15f35dcc9f55fa63d50fd4892c7c6a0a1c
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Apr 11 11:12:46 2006 +0200

    [ALSA] sound/core/pcm.c: make snd_pcm_format_name() static
    
    Modules: PCM Midlevel
    
    This patch makes the needlessly global snd_pcm_format_name() static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 5d7eb123b999..122e10a61ab9 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -196,7 +196,7 @@ static char *snd_pcm_format_names[] = {
 	FORMAT(U18_3BE),
 };
 
-const char *snd_pcm_format_name(snd_pcm_format_t format)
+static const char *snd_pcm_format_name(snd_pcm_format_t format)
 {
 	return snd_pcm_format_names[format];
 }

commit 3bf75f9b90c981f18f27a0d35a44f488ab68c8ea
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 27 16:40:49 2006 +0200

    [ALSA] Clean up PCM codes (take 2)
    
    - Clean up initialization and destruction of substream instance
      Now snd_pcm_open_substream() alone does most initialization jobs.
      Add pcm_release callback for cleaning up at snd_pcm_release_substream()
    - Tidy up PCM oss code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 1e9878fed37f..5d7eb123b999 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -777,8 +777,9 @@ static void snd_pcm_tick_timer_func(unsigned long data)
 	snd_pcm_tick_elapsed(substream);
 }
 
-int snd_pcm_open_substream(struct snd_pcm *pcm, int stream,
-			   struct snd_pcm_substream **rsubstream)
+int snd_pcm_attach_substream(struct snd_pcm *pcm, int stream,
+			     struct file *file,
+			     struct snd_pcm_substream **rsubstream)
 {
 	struct snd_pcm_str * pstr;
 	struct snd_pcm_substream *substream;
@@ -793,7 +794,7 @@ int snd_pcm_open_substream(struct snd_pcm *pcm, int stream,
 	*rsubstream = NULL;
 	snd_assert(pcm != NULL, return -ENXIO);
 	pstr = &pcm->streams[stream];
-	if (pstr->substream == NULL)
+	if (pstr->substream == NULL || pstr->substream_count == 0)
 		return -ENODEV;
 
 	card = pcm->card;
@@ -807,8 +808,6 @@ int snd_pcm_open_substream(struct snd_pcm *pcm, int stream,
 	}
 	up_read(&card->controls_rwsem);
 
-	if (pstr->substream_count == 0)
-		return -ENODEV;
 	switch (stream) {
 	case SNDRV_PCM_STREAM_PLAYBACK:
 		if (pcm->info_flags & SNDRV_PCM_INFO_HALF_DUPLEX) {
@@ -874,12 +873,13 @@ int snd_pcm_open_substream(struct snd_pcm *pcm, int stream,
 
 	substream->runtime = runtime;
 	substream->private_data = pcm->private_data;
+	substream->ffile = file;
 	pstr->substream_opened++;
 	*rsubstream = substream;
 	return 0;
 }
 
-void snd_pcm_release_substream(struct snd_pcm_substream *substream)
+void snd_pcm_detach_substream(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime;
 	substream->file = NULL;

commit bf1bbb5a49eec51c30d341606885507b501b37e8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 27 16:22:45 2006 +0200

    [ALSA] Tiny clean up of PCM codes
    
    - Make snd_pcm_prepare() static
    - Clean up snd_pcm_kernel_*_ioctl() functions, reduce exports
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 3da6a38c2d0f..1e9878fed37f 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1111,8 +1111,6 @@ EXPORT_SYMBOL(snd_pcm_link_rwlock);
 EXPORT_SYMBOL(snd_pcm_suspend);
 EXPORT_SYMBOL(snd_pcm_suspend_all);
 #endif
-EXPORT_SYMBOL(snd_pcm_kernel_playback_ioctl);
-EXPORT_SYMBOL(snd_pcm_kernel_capture_ioctl);
 EXPORT_SYMBOL(snd_pcm_kernel_ioctl);
 EXPORT_SYMBOL(snd_pcm_mmap_data);
 #if SNDRV_PCM_INFO_MMAP_IOMEM

commit 3f72a30ccfd5054c01fc3bb0d37241df5380a54c
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Wed Jan 18 11:50:40 2006 +0100

    [ALSA] snd_pcm_format_name() is no longer exported
    
    Modules: PCM Midlevel,USB generic driver
    
    Because snd_pcm_format_name() function is used only for informational
    purposes, it is no longer exported from the PCM midlevel to reduce
    space and dependency. usbaudio module shows only numeric value for format.
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index f903d1bd74d5..3da6a38c2d0f 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1105,7 +1105,6 @@ EXPORT_SYMBOL(snd_pcm_new_stream);
 EXPORT_SYMBOL(snd_pcm_notify);
 EXPORT_SYMBOL(snd_pcm_open_substream);
 EXPORT_SYMBOL(snd_pcm_release_substream);
-EXPORT_SYMBOL(snd_pcm_format_name);
   /* pcm_native.c */
 EXPORT_SYMBOL(snd_pcm_link_rwlock);
 #ifdef CONFIG_PM

commit 1a60d4c5a0c4028559585a74e48593b16e1ca9b2
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:29:08 2006 +0100

    [ALSA] semaphore -> mutex (core part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index d92c3ce4a4c9..f903d1bd74d5 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/time.h>
+#include <linux/mutex.h>
 #include <sound/core.h>
 #include <sound/minors.h>
 #include <sound/pcm.h>
@@ -35,7 +36,7 @@ MODULE_LICENSE("GPL");
 
 static LIST_HEAD(snd_pcm_devices);
 static LIST_HEAD(snd_pcm_notify_list);
-static DECLARE_MUTEX(register_mutex);
+static DEFINE_MUTEX(register_mutex);
 
 static int snd_pcm_free(struct snd_pcm *pcm);
 static int snd_pcm_dev_free(struct snd_device *device);
@@ -67,7 +68,7 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 
 			if (get_user(device, (int __user *)arg))
 				return -EFAULT;
-			down(&register_mutex);
+			mutex_lock(&register_mutex);
 			device = device < 0 ? 0 : device + 1;
 			while (device < SNDRV_PCM_DEVICES) {
 				if (snd_pcm_search(card, device))
@@ -76,7 +77,7 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 			}
 			if (device == SNDRV_PCM_DEVICES)
 				device = -1;
-			up(&register_mutex);
+			mutex_unlock(&register_mutex);
 			if (put_user(device, (int __user *)arg))
 				return -EFAULT;
 			return 0;
@@ -100,7 +101,7 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 				return -EINVAL;
 			if (get_user(subdevice, &info->subdevice))
 				return -EFAULT;
-			down(&register_mutex);
+			mutex_lock(&register_mutex);
 			pcm = snd_pcm_search(card, device);
 			if (pcm == NULL) {
 				err = -ENXIO;
@@ -125,7 +126,7 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 			}
 			err = snd_pcm_info_user(substream, info);
 		_error:
-			up(&register_mutex);
+			mutex_unlock(&register_mutex);
 			return err;
 		}
 	case SNDRV_CTL_IOCTL_PCM_PREFER_SUBDEVICE:
@@ -262,6 +263,7 @@ static const char *snd_pcm_state_name(snd_pcm_state_t state)
 
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 #include <linux/soundcard.h>
+
 static const char *snd_pcm_oss_format_name(int format)
 {
 	switch (format) {
@@ -624,7 +626,7 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 	struct snd_pcm_substream *substream, *prev;
 
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
-	init_MUTEX(&pstr->oss.setup_mutex);
+	mutex_init(&pstr->oss.setup_mutex);
 #endif
 	pstr->stream = stream;
 	pstr->pcm = pcm;
@@ -718,7 +720,7 @@ int snd_pcm_new(struct snd_card *card, char *id, int device,
 		snd_pcm_free(pcm);
 		return err;
 	}
-	init_MUTEX(&pcm->open_mutex);
+	mutex_init(&pcm->open_mutex);
 	init_waitqueue_head(&pcm->open_wait);
 	if ((err = snd_device_new(card, SNDRV_DEV_PCM, pcm, &ops)) < 0) {
 		snd_pcm_free(pcm);
@@ -904,9 +906,9 @@ static int snd_pcm_dev_register(struct snd_device *device)
 	struct snd_pcm *pcm = device->device_data;
 
 	snd_assert(pcm != NULL && device != NULL, return -ENXIO);
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	if (snd_pcm_search(pcm->card, pcm->device)) {
-		up(&register_mutex);
+		mutex_unlock(&register_mutex);
 		return -EBUSY;
 	}
 	list_add_tail(&pcm->list, &snd_pcm_devices);
@@ -930,7 +932,7 @@ static int snd_pcm_dev_register(struct snd_device *device)
 					       pcm, str)) < 0)
 		{
 			list_del(&pcm->list);
-			up(&register_mutex);
+			mutex_unlock(&register_mutex);
 			return err;
 		}
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
@@ -941,7 +943,7 @@ static int snd_pcm_dev_register(struct snd_device *device)
 		notify = list_entry(list, struct snd_pcm_notify, list);
 		notify->n_register(pcm);
 	}
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 	return 0;
 }
 
@@ -952,7 +954,7 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 	struct snd_pcm_substream *substream;
 	int cidx;
 
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	list_del_init(&pcm->list);
 	for (cidx = 0; cidx < 2; cidx++)
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
@@ -963,7 +965,7 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 		notify = list_entry(list, struct snd_pcm_notify, list);
 		notify->n_disconnect(pcm);
 	}
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 	return 0;
 }
 
@@ -975,7 +977,7 @@ static int snd_pcm_dev_unregister(struct snd_device *device)
 	struct snd_pcm *pcm = device->device_data;
 
 	snd_assert(pcm != NULL, return -ENXIO);
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	list_del(&pcm->list);
 	for (cidx = 0; cidx < 2; cidx++) {
 		devtype = -1;
@@ -996,7 +998,7 @@ static int snd_pcm_dev_unregister(struct snd_device *device)
 		notify = list_entry(list, struct snd_pcm_notify, list);
 		notify->n_unregister(pcm);
 	}
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 	return snd_pcm_free(pcm);
 }
 
@@ -1005,7 +1007,7 @@ int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 	struct list_head *p;
 
 	snd_assert(notify != NULL && notify->n_register != NULL && notify->n_unregister != NULL, return -EINVAL);
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	if (nfree) {
 		list_del(&notify->list);
 		list_for_each(p, &snd_pcm_devices)
@@ -1016,7 +1018,7 @@ int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 		list_for_each(p, &snd_pcm_devices)
 			notify->n_register(list_entry(p, struct snd_pcm, list));
 	}
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 	return 0;
 }
 
@@ -1031,7 +1033,7 @@ static void snd_pcm_proc_read(struct snd_info_entry *entry,
 	struct list_head *p;
 	struct snd_pcm *pcm;
 
-	down(&register_mutex);
+	mutex_lock(&register_mutex);
 	list_for_each(p, &snd_pcm_devices) {
 		pcm = list_entry(p, struct snd_pcm, list);
 		snd_iprintf(buffer, "%02i-%02i: %s : %s",
@@ -1044,7 +1046,7 @@ static void snd_pcm_proc_read(struct snd_info_entry *entry,
 				    pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream_count);
 		snd_iprintf(buffer, "\n");
 	}
-	up(&register_mutex);
+	mutex_unlock(&register_mutex);
 }
 
 static struct snd_info_entry *snd_pcm_proc_entry = NULL;

commit 21a3479a0b606d36fe24093f70a1c27328cec286
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Fri Jan 13 09:12:11 2006 +0100

    [ALSA] PCM midlevel & PCM OSS - make procfs & OSS plugin code optional
    
    Modules: ALSA Core,PCM Midlevel,ALSA<-OSS emulation,USB generic driver
    
    1) The verbose procfs code for the PCM midlevel and usb audio
       can be removed now (more patches will follow).
       CONFIG_SND_VERBOSE_PROCFS
    2) The PCM OSS plugin system can be also compiled optionaly.
       CONFIG_SND_PCM_OSS_PLUGINS
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 28ca61eb0b0d..d92c3ce4a4c9 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -140,6 +140,9 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 	}
 	return -ENOIOCTLCMD;
 }
+
+#if defined(CONFIG_PROC_FS) && defined(CONFIG_SND_VERBOSE_PROCFS)
+
 #define STATE(v) [SNDRV_PCM_STATE_##v] = #v
 #define STREAM(v) [SNDRV_PCM_STREAM_##v] = #v
 #define READY(v) [SNDRV_PCM_READY_##v] = #v
@@ -197,7 +200,6 @@ const char *snd_pcm_format_name(snd_pcm_format_t format)
 	return snd_pcm_format_names[format];
 }
 
-#ifdef CONFIG_PROC_FS
 static char *snd_pcm_stream_names[] = {
 	STREAM(PLAYBACK),
 	STREAM(CAPTURE),

commit e28563cceb9f258ebe3c50fc27d8f4ff0ac4bfa4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 1 10:42:42 2005 +0100

    [ALSA] Optimize for config without PROC_FS
    
    Modules: HWDEP Midlevel,ALSA Core,PCM Midlevel,Timer Midlevel
    
    Optimize the code when compiled without CONFIG_PROC_FS.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 95036c83de43..28ca61eb0b0d 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -151,30 +151,6 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 #define FORMAT(v) [SNDRV_PCM_FORMAT_##v] = #v
 #define SUBFORMAT(v) [SNDRV_PCM_SUBFORMAT_##v] = #v 
 
-static char *snd_pcm_stream_names[] = {
-	STREAM(PLAYBACK),
-	STREAM(CAPTURE),
-};
-
-static char *snd_pcm_state_names[] = {
-	STATE(OPEN),
-	STATE(SETUP),
-	STATE(PREPARED),
-	STATE(RUNNING),
-	STATE(XRUN),
-	STATE(DRAINING),
-	STATE(PAUSED),
-	STATE(SUSPENDED),
-};
-
-static char *snd_pcm_access_names[] = {
-	ACCESS(MMAP_INTERLEAVED), 
-	ACCESS(MMAP_NONINTERLEAVED),
-	ACCESS(MMAP_COMPLEX),
-	ACCESS(RW_INTERLEAVED),
-	ACCESS(RW_NONINTERLEAVED),
-};
-
 static char *snd_pcm_format_names[] = {
 	FORMAT(S8),
 	FORMAT(U8),
@@ -216,6 +192,36 @@ static char *snd_pcm_format_names[] = {
 	FORMAT(U18_3BE),
 };
 
+const char *snd_pcm_format_name(snd_pcm_format_t format)
+{
+	return snd_pcm_format_names[format];
+}
+
+#ifdef CONFIG_PROC_FS
+static char *snd_pcm_stream_names[] = {
+	STREAM(PLAYBACK),
+	STREAM(CAPTURE),
+};
+
+static char *snd_pcm_state_names[] = {
+	STATE(OPEN),
+	STATE(SETUP),
+	STATE(PREPARED),
+	STATE(RUNNING),
+	STATE(XRUN),
+	STATE(DRAINING),
+	STATE(PAUSED),
+	STATE(SUSPENDED),
+};
+
+static char *snd_pcm_access_names[] = {
+	ACCESS(MMAP_INTERLEAVED), 
+	ACCESS(MMAP_NONINTERLEAVED),
+	ACCESS(MMAP_COMPLEX),
+	ACCESS(RW_INTERLEAVED),
+	ACCESS(RW_NONINTERLEAVED),
+};
+
 static char *snd_pcm_subformat_names[] = {
 	SUBFORMAT(STD), 
 };
@@ -236,11 +242,6 @@ static const char *snd_pcm_access_name(snd_pcm_access_t access)
 	return snd_pcm_access_names[access];
 }
 
-const char *snd_pcm_format_name(snd_pcm_format_t format)
-{
-	return snd_pcm_format_names[format];
-}
-
 static const char *snd_pcm_subformat_name(snd_pcm_subformat_t subformat)
 {
 	return snd_pcm_subformat_names[subformat];
@@ -288,7 +289,6 @@ static const char *snd_pcm_oss_format_name(int format)
 }
 #endif
 
-#ifdef CONFIG_PROC_FS
 static void snd_pcm_proc_info_read(struct snd_pcm_substream *substream,
 				   struct snd_info_buffer *buffer)
 {
@@ -431,7 +431,6 @@ static void snd_pcm_substream_proc_status_read(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "hw_ptr      : %ld\n", runtime->status->hw_ptr);
 	snd_iprintf(buffer, "appl_ptr    : %ld\n", runtime->control->appl_ptr);
 }
-#endif
 
 #ifdef CONFIG_SND_DEBUG
 static void snd_pcm_xrun_debug_read(struct snd_info_entry *entry,
@@ -596,6 +595,12 @@ static int snd_pcm_substream_proc_done(struct snd_pcm_substream *substream)
 	}
 	return 0;
 }
+#else /* !CONFIG_PROC_FS */
+static inline int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr) { return 0; }
+static inline int snd_pcm_stream_proc_done(struct snd_pcm_str *pstr) { return 0; }
+static inline int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream) { return 0; }
+static inline int snd_pcm_substream_proc_done(struct snd_pcm_substream *substream) { return 0; }
+#endif /* CONFIG_PROC_FS */
 
 /**
  * snd_pcm_new_stream - create a new PCM stream
@@ -1013,6 +1018,7 @@ int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 	return 0;
 }
 
+#ifdef CONFIG_PROC_FS
 /*
  *  Info interface
  */
@@ -1039,18 +1045,12 @@ static void snd_pcm_proc_read(struct snd_info_entry *entry,
 	up(&register_mutex);
 }
 
-/*
- *  ENTRY functions
- */
-
 static struct snd_info_entry *snd_pcm_proc_entry = NULL;
 
-static int __init alsa_pcm_init(void)
+static void snd_pcm_proc_init(void)
 {
 	struct snd_info_entry *entry;
 
-	snd_ctl_register_ioctl(snd_pcm_control_ioctl);
-	snd_ctl_register_ioctl_compat(snd_pcm_control_ioctl);
 	if ((entry = snd_info_create_module_entry(THIS_MODULE, "pcm", NULL)) != NULL) {
 		snd_info_set_text_ops(entry, NULL, SNDRV_CARDS * SNDRV_PCM_DEVICES * 128,
 				      snd_pcm_proc_read);
@@ -1060,6 +1060,29 @@ static int __init alsa_pcm_init(void)
 		}
 	}
 	snd_pcm_proc_entry = entry;
+}
+
+static void snd_pcm_proc_done(void)
+{
+	if (snd_pcm_proc_entry)
+		snd_info_unregister(snd_pcm_proc_entry);
+}
+
+#else /* !CONFIG_PROC_FS */
+#define snd_pcm_proc_init()
+#define snd_pcm_proc_done()
+#endif /* CONFIG_PROC_FS */
+
+
+/*
+ *  ENTRY functions
+ */
+
+static int __init alsa_pcm_init(void)
+{
+	snd_ctl_register_ioctl(snd_pcm_control_ioctl);
+	snd_ctl_register_ioctl_compat(snd_pcm_control_ioctl);
+	snd_pcm_proc_init();
 	return 0;
 }
 
@@ -1067,10 +1090,7 @@ static void __exit alsa_pcm_exit(void)
 {
 	snd_ctl_unregister_ioctl(snd_pcm_control_ioctl);
 	snd_ctl_unregister_ioctl_compat(snd_pcm_control_ioctl);
-	if (snd_pcm_proc_entry) {
-		snd_info_unregister(snd_pcm_proc_entry);
-		snd_pcm_proc_entry = NULL;
-	}
+	snd_pcm_proc_done();
 }
 
 module_init(alsa_pcm_init)

commit f87135f56cb266e031f5ec081dfbde7e43f55e80
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:06:59 2005 +0100

    [ALSA] dynamic minors (3/6): store device-specific object pointers dynamically
    
    Instead of storing the pointers to the device-specific structures in an
    array, put them into the struct snd_minor, and look them up dynamically.
    
    This makes the device type modules independent of the minor number
    encoding.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 2bc5f69ec2a8..95036c83de43 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -33,7 +33,7 @@ MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, Abramo Bagnara <abramo@alsa-proj
 MODULE_DESCRIPTION("Midlevel PCM code for ALSA.");
 MODULE_LICENSE("GPL");
 
-struct snd_pcm *snd_pcm_devices[SNDRV_CARDS * SNDRV_PCM_DEVICES];
+static LIST_HEAD(snd_pcm_devices);
 static LIST_HEAD(snd_pcm_notify_list);
 static DECLARE_MUTEX(register_mutex);
 
@@ -43,13 +43,23 @@ static int snd_pcm_dev_register(struct snd_device *device);
 static int snd_pcm_dev_disconnect(struct snd_device *device);
 static int snd_pcm_dev_unregister(struct snd_device *device);
 
+static struct snd_pcm *snd_pcm_search(struct snd_card *card, int device)
+{
+	struct list_head *p;
+	struct snd_pcm *pcm;
+
+	list_for_each(p, &snd_pcm_devices) {
+		pcm = list_entry(p, struct snd_pcm, list);
+		if (pcm->card == card && pcm->device == device)
+			return pcm;
+	}
+	return NULL;
+}
+
 static int snd_pcm_control_ioctl(struct snd_card *card,
 				 struct snd_ctl_file *control,
 				 unsigned int cmd, unsigned long arg)
 {
-	unsigned int tmp;
-
-	tmp = card->number * SNDRV_PCM_DEVICES;
 	switch (cmd) {
 	case SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE:
 		{
@@ -57,14 +67,16 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 
 			if (get_user(device, (int __user *)arg))
 				return -EFAULT;
+			down(&register_mutex);
 			device = device < 0 ? 0 : device + 1;
 			while (device < SNDRV_PCM_DEVICES) {
-				if (snd_pcm_devices[tmp + device])
+				if (snd_pcm_search(card, device))
 					break;
 				device++;
 			}
 			if (device == SNDRV_PCM_DEVICES)
 				device = -1;
+			up(&register_mutex);
 			if (put_user(device, (int __user *)arg))
 				return -EFAULT;
 			return 0;
@@ -77,31 +89,44 @@ static int snd_pcm_control_ioctl(struct snd_card *card,
 			struct snd_pcm *pcm;
 			struct snd_pcm_str *pstr;
 			struct snd_pcm_substream *substream;
+			int err;
+
 			info = (struct snd_pcm_info __user *)arg;
 			if (get_user(device, &info->device))
 				return -EFAULT;
-			if (device >= SNDRV_PCM_DEVICES)
-				return -ENXIO;
-			pcm = snd_pcm_devices[tmp + device];
-			if (pcm == NULL)
-				return -ENXIO;
 			if (get_user(stream, &info->stream))
 				return -EFAULT;
 			if (stream < 0 || stream > 1)
 				return -EINVAL;
-			pstr = &pcm->streams[stream];
-			if (pstr->substream_count == 0)
-				return -ENOENT;
 			if (get_user(subdevice, &info->subdevice))
 				return -EFAULT;
-			if (subdevice >= pstr->substream_count)
-				return -ENXIO;
-			for (substream = pstr->substream; substream; substream = substream->next)
+			down(&register_mutex);
+			pcm = snd_pcm_search(card, device);
+			if (pcm == NULL) {
+				err = -ENXIO;
+				goto _error;
+			}
+			pstr = &pcm->streams[stream];
+			if (pstr->substream_count == 0) {
+				err = -ENOENT;
+				goto _error;
+			}
+			if (subdevice >= pstr->substream_count) {
+				err = -ENXIO;
+				goto _error;
+			}
+			for (substream = pstr->substream; substream;
+			     substream = substream->next)
 				if (substream->number == (int)subdevice)
 					break;
-			if (substream == NULL)
-				return -ENXIO;
-			return snd_pcm_info_user(substream, info);
+			if (substream == NULL) {
+				err = -ENXIO;
+				goto _error;
+			}
+			err = snd_pcm_info_user(substream, info);
+		_error:
+			up(&register_mutex);
+			return err;
 		}
 	case SNDRV_CTL_IOCTL_PCM_PREFER_SUBDEVICE:
 		{
@@ -865,8 +890,7 @@ void snd_pcm_release_substream(struct snd_pcm_substream *substream)
 
 static int snd_pcm_dev_register(struct snd_device *device)
 {
-	int idx, cidx, err;
-	unsigned short minor;
+	int cidx, err;
 	struct snd_pcm_substream *substream;
 	struct list_head *list;
 	char str[16];
@@ -874,12 +898,11 @@ static int snd_pcm_dev_register(struct snd_device *device)
 
 	snd_assert(pcm != NULL && device != NULL, return -ENXIO);
 	down(&register_mutex);
-	idx = (pcm->card->number * SNDRV_PCM_DEVICES) + pcm->device;
-	if (snd_pcm_devices[idx]) {
+	if (snd_pcm_search(pcm->card, pcm->device)) {
 		up(&register_mutex);
 		return -EBUSY;
 	}
-	snd_pcm_devices[idx] = pcm;
+	list_add_tail(&pcm->list, &snd_pcm_devices);
 	for (cidx = 0; cidx < 2; cidx++) {
 		int devtype = -1;
 		if (pcm->streams[cidx].substream == NULL)
@@ -887,20 +910,19 @@ static int snd_pcm_dev_register(struct snd_device *device)
 		switch (cidx) {
 		case SNDRV_PCM_STREAM_PLAYBACK:
 			sprintf(str, "pcmC%iD%ip", pcm->card->number, pcm->device);
-			minor = SNDRV_MINOR_PCM_PLAYBACK + idx;
 			devtype = SNDRV_DEVICE_TYPE_PCM_PLAYBACK;
 			break;
 		case SNDRV_PCM_STREAM_CAPTURE:
 			sprintf(str, "pcmC%iD%ic", pcm->card->number, pcm->device);
-			minor = SNDRV_MINOR_PCM_CAPTURE + idx;
 			devtype = SNDRV_DEVICE_TYPE_PCM_CAPTURE;
 			break;
 		}
 		if ((err = snd_register_device(devtype, pcm->card,
 					       pcm->device,
-					       &snd_pcm_f_ops[cidx], str)) < 0)
+					       &snd_pcm_f_ops[cidx],
+					       pcm, str)) < 0)
 		{
-			snd_pcm_devices[idx] = NULL;
+			list_del(&pcm->list);
 			up(&register_mutex);
 			return err;
 		}
@@ -921,11 +943,10 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 	struct snd_pcm *pcm = device->device_data;
 	struct list_head *list;
 	struct snd_pcm_substream *substream;
-	int idx, cidx;
+	int cidx;
 
 	down(&register_mutex);
-	idx = (pcm->card->number * SNDRV_PCM_DEVICES) + pcm->device;
-	snd_pcm_devices[idx] = NULL;
+	list_del_init(&pcm->list);
 	for (cidx = 0; cidx < 2; cidx++)
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
 			if (substream->runtime)
@@ -941,15 +962,14 @@ static int snd_pcm_dev_disconnect(struct snd_device *device)
 
 static int snd_pcm_dev_unregister(struct snd_device *device)
 {
-	int idx, cidx, devtype;
+	int cidx, devtype;
 	struct snd_pcm_substream *substream;
 	struct list_head *list;
 	struct snd_pcm *pcm = device->device_data;
 
 	snd_assert(pcm != NULL, return -ENXIO);
 	down(&register_mutex);
-	idx = (pcm->card->number * SNDRV_PCM_DEVICES) + pcm->device;
-	snd_pcm_devices[idx] = NULL;
+	list_del(&pcm->list);
 	for (cidx = 0; cidx < 2; cidx++) {
 		devtype = -1;
 		switch (cidx) {
@@ -975,24 +995,19 @@ static int snd_pcm_dev_unregister(struct snd_device *device)
 
 int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 {
-	int idx;
+	struct list_head *p;
 
 	snd_assert(notify != NULL && notify->n_register != NULL && notify->n_unregister != NULL, return -EINVAL);
 	down(&register_mutex);
 	if (nfree) {
 		list_del(&notify->list);
-		for (idx = 0; idx < SNDRV_CARDS * SNDRV_PCM_DEVICES; idx++) {
-			if (snd_pcm_devices[idx] == NULL)
-				continue;
-			notify->n_unregister(snd_pcm_devices[idx]);
-		}
+		list_for_each(p, &snd_pcm_devices)
+			notify->n_unregister(list_entry(p,
+							struct snd_pcm, list));
 	} else {
 		list_add_tail(&notify->list, &snd_pcm_notify_list);
-		for (idx = 0; idx < SNDRV_CARDS * SNDRV_PCM_DEVICES; idx++) {
-			if (snd_pcm_devices[idx] == NULL)
-				continue;
-			notify->n_register(snd_pcm_devices[idx]);
-		}
+		list_for_each(p, &snd_pcm_devices)
+			notify->n_register(list_entry(p, struct snd_pcm, list));
 	}
 	up(&register_mutex);
 	return 0;
@@ -1005,16 +1020,14 @@ int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 static void snd_pcm_proc_read(struct snd_info_entry *entry,
 			      struct snd_info_buffer *buffer)
 {
-	int idx;
+	struct list_head *p;
 	struct snd_pcm *pcm;
 
 	down(&register_mutex);
-	for (idx = 0; idx < SNDRV_CARDS * SNDRV_PCM_DEVICES; idx++) {
-		pcm = snd_pcm_devices[idx];
-		if (pcm == NULL)
-			continue;
-		snd_iprintf(buffer, "%02i-%02i: %s : %s", idx / SNDRV_PCM_DEVICES,
-			    idx % SNDRV_PCM_DEVICES, pcm->id, pcm->name);
+	list_for_each(p, &snd_pcm_devices) {
+		pcm = list_entry(p, struct snd_pcm, list);
+		snd_iprintf(buffer, "%02i-%02i: %s : %s",
+			    pcm->card->number, pcm->device, pcm->id, pcm->name);
 		if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream)
 			snd_iprintf(buffer, " : playback %i",
 				    pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream_count);
@@ -1063,7 +1076,6 @@ static void __exit alsa_pcm_exit(void)
 module_init(alsa_pcm_init)
 module_exit(alsa_pcm_exit)
 
-EXPORT_SYMBOL(snd_pcm_devices);
 EXPORT_SYMBOL(snd_pcm_new);
 EXPORT_SYMBOL(snd_pcm_new_stream);
 EXPORT_SYMBOL(snd_pcm_notify);

commit 2af677fc884fc6dc79e65c99050ea607ac8bab9b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 20 14:03:48 2005 +0100

    [ALSA] dynamic minors (1/6): store device type in struct snd_minor
    
    Instead of a comment string, store the device type in the snd_minor
    structure.  This makes snd_minor more flexible, and has the nice side
    effect that we don't need anymore to create a separate snd_minor
    template for registering a device but can pass the file_operations
    directly to snd_register_device().
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 9305ac357a3e..2bc5f69ec2a8 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -597,7 +597,6 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 	pstr->stream = stream;
 	pstr->pcm = pcm;
 	pstr->substream_count = substream_count;
-	pstr->reg = &snd_pcm_reg[stream];
 	if (substream_count > 0) {
 		err = snd_pcm_stream_proc_init(pstr);
 		if (err < 0) {
@@ -897,7 +896,10 @@ static int snd_pcm_dev_register(struct snd_device *device)
 			devtype = SNDRV_DEVICE_TYPE_PCM_CAPTURE;
 			break;
 		}
-		if ((err = snd_register_device(devtype, pcm->card, pcm->device, pcm->streams[cidx].reg, str)) < 0) {
+		if ((err = snd_register_device(devtype, pcm->card,
+					       pcm->device,
+					       &snd_pcm_f_ops[cidx], str)) < 0)
+		{
 			snd_pcm_devices[idx] = NULL;
 			up(&register_mutex);
 			return err;

commit 73e77ba0235532bd7523ba90883d325f6e095acf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 17:44:01 2005 +0100

    [ALSA] Add error messages
    
    Add error messages in the critial error path to be more verbose.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 59c995bbf15b..9305ac357a3e 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -600,14 +600,18 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 	pstr->reg = &snd_pcm_reg[stream];
 	if (substream_count > 0) {
 		err = snd_pcm_stream_proc_init(pstr);
-		if (err < 0)
+		if (err < 0) {
+			snd_printk(KERN_ERR "Error in snd_pcm_stream_proc_init\n");
 			return err;
+		}
 	}
 	prev = NULL;
 	for (idx = 0, prev = NULL; idx < substream_count; idx++) {
 		substream = kzalloc(sizeof(*substream), GFP_KERNEL);
-		if (substream == NULL)
+		if (substream == NULL) {
+			snd_printk(KERN_ERR "Cannot allocate PCM substream\n");
 			return -ENOMEM;
+		}
 		substream->pcm = pcm;
 		substream->pstr = pstr;
 		substream->number = idx;
@@ -620,6 +624,7 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 			prev->next = substream;
 		err = snd_pcm_substream_proc_init(substream);
 		if (err < 0) {
+			snd_printk(KERN_ERR "Error in snd_pcm_stream_proc_init\n");
 			kfree(substream);
 			return err;
 		}
@@ -666,13 +671,14 @@ int snd_pcm_new(struct snd_card *card, char *id, int device,
 	*rpcm = NULL;
 	snd_assert(card != NULL, return -ENXIO);
 	pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
-	if (pcm == NULL)
+	if (pcm == NULL) {
+		snd_printk(KERN_ERR "Cannot allocate PCM\n");
 		return -ENOMEM;
+	}
 	pcm->card = card;
 	pcm->device = device;
-	if (id) {
+	if (id)
 		strlcpy(pcm->id, id, sizeof(pcm->id));
-	}
 	if ((err = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_PLAYBACK, playback_count)) < 0) {
 		snd_pcm_free(pcm);
 		return err;

commit 877211f5e1b1196179ba1290e8e1a3dc00427c55
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 13:59:38 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCM
    
    Modules: PCM Midlevel
    
    Remove xxx_t typedefs from the core PCM codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 184e74b75ba9..59c995bbf15b 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -33,18 +33,18 @@ MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, Abramo Bagnara <abramo@alsa-proj
 MODULE_DESCRIPTION("Midlevel PCM code for ALSA.");
 MODULE_LICENSE("GPL");
 
-snd_pcm_t *snd_pcm_devices[SNDRV_CARDS * SNDRV_PCM_DEVICES];
+struct snd_pcm *snd_pcm_devices[SNDRV_CARDS * SNDRV_PCM_DEVICES];
 static LIST_HEAD(snd_pcm_notify_list);
 static DECLARE_MUTEX(register_mutex);
 
-static int snd_pcm_free(snd_pcm_t *pcm);
-static int snd_pcm_dev_free(snd_device_t *device);
-static int snd_pcm_dev_register(snd_device_t *device);
-static int snd_pcm_dev_disconnect(snd_device_t *device);
-static int snd_pcm_dev_unregister(snd_device_t *device);
+static int snd_pcm_free(struct snd_pcm *pcm);
+static int snd_pcm_dev_free(struct snd_device *device);
+static int snd_pcm_dev_register(struct snd_device *device);
+static int snd_pcm_dev_disconnect(struct snd_device *device);
+static int snd_pcm_dev_unregister(struct snd_device *device);
 
-static int snd_pcm_control_ioctl(snd_card_t * card,
-				 snd_ctl_file_t * control,
+static int snd_pcm_control_ioctl(struct snd_card *card,
+				 struct snd_ctl_file *control,
 				 unsigned int cmd, unsigned long arg)
 {
 	unsigned int tmp;
@@ -71,13 +71,13 @@ static int snd_pcm_control_ioctl(snd_card_t * card,
 		}
 	case SNDRV_CTL_IOCTL_PCM_INFO:
 		{
-			snd_pcm_info_t __user *info;
+			struct snd_pcm_info __user *info;
 			unsigned int device, subdevice;
-			snd_pcm_stream_t stream;
-			snd_pcm_t *pcm;
-			snd_pcm_str_t *pstr;
-			snd_pcm_substream_t *substream;
-			info = (snd_pcm_info_t __user *)arg;
+			int stream;
+			struct snd_pcm *pcm;
+			struct snd_pcm_str *pstr;
+			struct snd_pcm_substream *substream;
+			info = (struct snd_pcm_info __user *)arg;
 			if (get_user(device, &info->device))
 				return -EFAULT;
 			if (device >= SNDRV_PCM_DEVICES)
@@ -200,7 +200,7 @@ static char *snd_pcm_tstamp_mode_names[] = {
 	TSTAMP(MMAP),
 };
 
-static const char *snd_pcm_stream_name(snd_pcm_stream_t stream)
+static const char *snd_pcm_stream_name(int stream)
 {
 	snd_assert(stream <= SNDRV_PCM_STREAM_LAST, return NULL);
 	return snd_pcm_stream_names[stream];
@@ -208,23 +208,20 @@ static const char *snd_pcm_stream_name(snd_pcm_stream_t stream)
 
 static const char *snd_pcm_access_name(snd_pcm_access_t access)
 {
-	snd_assert(access <= SNDRV_PCM_ACCESS_LAST, return NULL);
 	return snd_pcm_access_names[access];
 }
 
 const char *snd_pcm_format_name(snd_pcm_format_t format)
 {
-	snd_assert(format <= SNDRV_PCM_FORMAT_LAST, return NULL);
 	return snd_pcm_format_names[format];
 }
 
 static const char *snd_pcm_subformat_name(snd_pcm_subformat_t subformat)
 {
-	snd_assert(subformat <= SNDRV_PCM_SUBFORMAT_LAST, return NULL);
 	return snd_pcm_subformat_names[subformat];
 }
 
-static const char *snd_pcm_tstamp_mode_name(snd_pcm_tstamp_t mode)
+static const char *snd_pcm_tstamp_mode_name(int mode)
 {
 	snd_assert(mode <= SNDRV_PCM_TSTAMP_LAST, return NULL);
 	return snd_pcm_tstamp_mode_names[mode];
@@ -232,7 +229,6 @@ static const char *snd_pcm_tstamp_mode_name(snd_pcm_tstamp_t mode)
 
 static const char *snd_pcm_state_name(snd_pcm_state_t state)
 {
-	snd_assert(state <= SNDRV_PCM_STATE_LAST, return NULL);
 	return snd_pcm_state_names[state];
 }
 
@@ -268,9 +264,10 @@ static const char *snd_pcm_oss_format_name(int format)
 #endif
 
 #ifdef CONFIG_PROC_FS
-static void snd_pcm_proc_info_read(snd_pcm_substream_t *substream, snd_info_buffer_t *buffer)
+static void snd_pcm_proc_info_read(struct snd_pcm_substream *substream,
+				   struct snd_info_buffer *buffer)
 {
-	snd_pcm_info_t *info;
+	struct snd_pcm_info *info;
 	int err;
 
 	if (! substream)
@@ -302,20 +299,25 @@ static void snd_pcm_proc_info_read(snd_pcm_substream_t *substream, snd_info_buff
 	kfree(info);
 }
 
-static void snd_pcm_stream_proc_info_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+static void snd_pcm_stream_proc_info_read(struct snd_info_entry *entry,
+					  struct snd_info_buffer *buffer)
 {
-	snd_pcm_proc_info_read(((snd_pcm_str_t *)entry->private_data)->substream, buffer);
+	snd_pcm_proc_info_read(((struct snd_pcm_str *)entry->private_data)->substream,
+			       buffer);
 }
 
-static void snd_pcm_substream_proc_info_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+static void snd_pcm_substream_proc_info_read(struct snd_info_entry *entry,
+					     struct snd_info_buffer *buffer)
 {
-	snd_pcm_proc_info_read((snd_pcm_substream_t *)entry->private_data, buffer);
+	snd_pcm_proc_info_read((struct snd_pcm_substream *)entry->private_data,
+			       buffer);
 }
 
-static void snd_pcm_substream_proc_hw_params_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+static void snd_pcm_substream_proc_hw_params_read(struct snd_info_entry *entry,
+						  struct snd_info_buffer *buffer)
 {
-	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)entry->private_data;
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_substream *substream = entry->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	if (!runtime) {
 		snd_iprintf(buffer, "closed\n");
 		return;
@@ -347,10 +349,11 @@ static void snd_pcm_substream_proc_hw_params_read(snd_info_entry_t *entry, snd_i
 	snd_pcm_stream_unlock_irq(substream);
 }
 
-static void snd_pcm_substream_proc_sw_params_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+static void snd_pcm_substream_proc_sw_params_read(struct snd_info_entry *entry,
+						  struct snd_info_buffer *buffer)
 {
-	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)entry->private_data;
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_substream *substream = entry->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	if (!runtime) {
 		snd_iprintf(buffer, "closed\n");
 		return;
@@ -374,11 +377,12 @@ static void snd_pcm_substream_proc_sw_params_read(snd_info_entry_t *entry, snd_i
 	snd_pcm_stream_unlock_irq(substream);
 }
 
-static void snd_pcm_substream_proc_status_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+static void snd_pcm_substream_proc_status_read(struct snd_info_entry *entry,
+					       struct snd_info_buffer *buffer)
 {
-	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)entry->private_data;
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_pcm_status_t status;
+	struct snd_pcm_substream *substream = entry->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_pcm_status status;
 	int err;
 	if (!runtime) {
 		snd_iprintf(buffer, "closed\n");
@@ -405,25 +409,27 @@ static void snd_pcm_substream_proc_status_read(snd_info_entry_t *entry, snd_info
 #endif
 
 #ifdef CONFIG_SND_DEBUG
-static void snd_pcm_xrun_debug_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+static void snd_pcm_xrun_debug_read(struct snd_info_entry *entry,
+				    struct snd_info_buffer *buffer)
 {
-	snd_pcm_str_t *pstr = (snd_pcm_str_t *)entry->private_data;
+	struct snd_pcm_str *pstr = entry->private_data;
 	snd_iprintf(buffer, "%d\n", pstr->xrun_debug);
 }
 
-static void snd_pcm_xrun_debug_write(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+static void snd_pcm_xrun_debug_write(struct snd_info_entry *entry,
+				     struct snd_info_buffer *buffer)
 {
-	snd_pcm_str_t *pstr = (snd_pcm_str_t *)entry->private_data;
+	struct snd_pcm_str *pstr = entry->private_data;
 	char line[64];
 	if (!snd_info_get_line(buffer, line, sizeof(line)))
 		pstr->xrun_debug = simple_strtoul(line, NULL, 10);
 }
 #endif
 
-static int snd_pcm_stream_proc_init(snd_pcm_str_t *pstr)
+static int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr)
 {
-	snd_pcm_t *pcm = pstr->pcm;
-	snd_info_entry_t *entry;
+	struct snd_pcm *pcm = pstr->pcm;
+	struct snd_info_entry *entry;
 	char name[16];
 
 	sprintf(name, "pcm%i%c", pcm->device, 
@@ -447,7 +453,8 @@ static int snd_pcm_stream_proc_init(snd_pcm_str_t *pstr)
 	pstr->proc_info_entry = entry;
 
 #ifdef CONFIG_SND_DEBUG
-	if ((entry = snd_info_create_card_entry(pcm->card, "xrun_debug", pstr->proc_root)) != NULL) {
+	if ((entry = snd_info_create_card_entry(pcm->card, "xrun_debug",
+						pstr->proc_root)) != NULL) {
 		entry->c.text.read_size = 64;
 		entry->c.text.read = snd_pcm_xrun_debug_read;
 		entry->c.text.write_size = 64;
@@ -464,7 +471,7 @@ static int snd_pcm_stream_proc_init(snd_pcm_str_t *pstr)
 	return 0;
 }
 
-static int snd_pcm_stream_proc_done(snd_pcm_str_t *pstr)
+static int snd_pcm_stream_proc_done(struct snd_pcm_str *pstr)
 {
 #ifdef CONFIG_SND_DEBUG
 	if (pstr->proc_xrun_debug_entry) {
@@ -483,10 +490,10 @@ static int snd_pcm_stream_proc_done(snd_pcm_str_t *pstr)
 	return 0;
 }
 
-static int snd_pcm_substream_proc_init(snd_pcm_substream_t *substream)
+static int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream)
 {
-	snd_info_entry_t *entry;
-	snd_card_t *card;
+	struct snd_info_entry *entry;
+	struct snd_card *card;
 	char name[16];
 
 	card = substream->pcm->card;
@@ -540,7 +547,7 @@ static int snd_pcm_substream_proc_init(snd_pcm_substream_t *substream)
 	return 0;
 }
 		
-static int snd_pcm_substream_proc_done(snd_pcm_substream_t *substream)
+static int snd_pcm_substream_proc_done(struct snd_pcm_substream *substream)
 {
 	if (substream->proc_info_entry) {
 		snd_info_unregister(substream->proc_info_entry);
@@ -578,11 +585,11 @@ static int snd_pcm_substream_proc_done(snd_pcm_substream_t *substream)
  *
  * Returns zero if successful, or a negative error code on failure.
  */
-int snd_pcm_new_stream(snd_pcm_t *pcm, int stream, int substream_count)
+int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 {
 	int idx, err;
-	snd_pcm_str_t *pstr = &pcm->streams[stream];
-	snd_pcm_substream_t *substream, *prev;
+	struct snd_pcm_str *pstr = &pcm->streams[stream];
+	struct snd_pcm_substream *substream, *prev;
 
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
 	init_MUTEX(&pstr->oss.setup_mutex);
@@ -642,13 +649,13 @@ int snd_pcm_new_stream(snd_pcm_t *pcm, int stream, int substream_count)
  *
  * Returns zero if successful, or a negative error code on failure.
  */
-int snd_pcm_new(snd_card_t * card, char *id, int device,
+int snd_pcm_new(struct snd_card *card, char *id, int device,
 		int playback_count, int capture_count,
-	        snd_pcm_t ** rpcm)
+	        struct snd_pcm ** rpcm)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free = snd_pcm_dev_free,
 		.dev_register =	snd_pcm_dev_register,
 		.dev_disconnect = snd_pcm_dev_disconnect,
@@ -684,11 +691,11 @@ int snd_pcm_new(snd_card_t * card, char *id, int device,
 	return 0;
 }
 
-static void snd_pcm_free_stream(snd_pcm_str_t * pstr)
+static void snd_pcm_free_stream(struct snd_pcm_str * pstr)
 {
-	snd_pcm_substream_t *substream, *substream_next;
+	struct snd_pcm_substream *substream, *substream_next;
 #if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
-	snd_pcm_oss_setup_t *setup, *setupn;
+	struct snd_pcm_oss_setup *setup, *setupn;
 #endif
 	substream = pstr->substream;
 	while (substream) {
@@ -707,7 +714,7 @@ static void snd_pcm_free_stream(snd_pcm_str_t * pstr)
 #endif
 }
 
-static int snd_pcm_free(snd_pcm_t *pcm)
+static int snd_pcm_free(struct snd_pcm *pcm)
 {
 	snd_assert(pcm != NULL, return -ENXIO);
 	if (pcm->private_free)
@@ -719,26 +726,26 @@ static int snd_pcm_free(snd_pcm_t *pcm)
 	return 0;
 }
 
-static int snd_pcm_dev_free(snd_device_t *device)
+static int snd_pcm_dev_free(struct snd_device *device)
 {
-	snd_pcm_t *pcm = device->device_data;
+	struct snd_pcm *pcm = device->device_data;
 	return snd_pcm_free(pcm);
 }
 
 static void snd_pcm_tick_timer_func(unsigned long data)
 {
-	snd_pcm_substream_t *substream = (snd_pcm_substream_t*) data;
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *) data;
 	snd_pcm_tick_elapsed(substream);
 }
 
-int snd_pcm_open_substream(snd_pcm_t *pcm, int stream,
-			   snd_pcm_substream_t **rsubstream)
+int snd_pcm_open_substream(struct snd_pcm *pcm, int stream,
+			   struct snd_pcm_substream **rsubstream)
 {
-	snd_pcm_str_t * pstr;
-	snd_pcm_substream_t * substream;
-	snd_pcm_runtime_t * runtime;
-	snd_ctl_file_t *kctl;
-	snd_card_t *card;
+	struct snd_pcm_str * pstr;
+	struct snd_pcm_substream *substream;
+	struct snd_pcm_runtime *runtime;
+	struct snd_ctl_file *kctl;
+	struct snd_card *card;
 	struct list_head *list;
 	int prefer_subdevice = -1;
 	size_t size;
@@ -800,7 +807,7 @@ int snd_pcm_open_substream(snd_pcm_t *pcm, int stream,
 	if (runtime == NULL)
 		return -ENOMEM;
 
-	size = PAGE_ALIGN(sizeof(snd_pcm_mmap_status_t));
+	size = PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status));
 	runtime->status = snd_malloc_pages(size, GFP_KERNEL);
 	if (runtime->status == NULL) {
 		kfree(runtime);
@@ -808,10 +815,11 @@ int snd_pcm_open_substream(snd_pcm_t *pcm, int stream,
 	}
 	memset((void*)runtime->status, 0, size);
 
-	size = PAGE_ALIGN(sizeof(snd_pcm_mmap_control_t));
+	size = PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control));
 	runtime->control = snd_malloc_pages(size, GFP_KERNEL);
 	if (runtime->control == NULL) {
-		snd_free_pages((void*)runtime->status, PAGE_ALIGN(sizeof(snd_pcm_mmap_status_t)));
+		snd_free_pages((void*)runtime->status,
+			       PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status)));
 		kfree(runtime);
 		return -ENOMEM;
 	}
@@ -832,30 +840,32 @@ int snd_pcm_open_substream(snd_pcm_t *pcm, int stream,
 	return 0;
 }
 
-void snd_pcm_release_substream(snd_pcm_substream_t *substream)
+void snd_pcm_release_substream(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t * runtime;
+	struct snd_pcm_runtime *runtime;
 	substream->file = NULL;
 	runtime = substream->runtime;
 	snd_assert(runtime != NULL, return);
 	if (runtime->private_free != NULL)
 		runtime->private_free(runtime);
-	snd_free_pages((void*)runtime->status, PAGE_ALIGN(sizeof(snd_pcm_mmap_status_t)));
-	snd_free_pages((void*)runtime->control, PAGE_ALIGN(sizeof(snd_pcm_mmap_control_t)));
+	snd_free_pages((void*)runtime->status,
+		       PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status)));
+	snd_free_pages((void*)runtime->control,
+		       PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control)));
 	kfree(runtime->hw_constraints.rules);
 	kfree(runtime);
 	substream->runtime = NULL;
 	substream->pstr->substream_opened--;
 }
 
-static int snd_pcm_dev_register(snd_device_t *device)
+static int snd_pcm_dev_register(struct snd_device *device)
 {
 	int idx, cidx, err;
 	unsigned short minor;
-	snd_pcm_substream_t *substream;
+	struct snd_pcm_substream *substream;
 	struct list_head *list;
 	char str[16];
-	snd_pcm_t *pcm = device->device_data;
+	struct snd_pcm *pcm = device->device_data;
 
 	snd_assert(pcm != NULL && device != NULL, return -ENXIO);
 	down(&register_mutex);
@@ -890,19 +900,19 @@ static int snd_pcm_dev_register(snd_device_t *device)
 			snd_pcm_timer_init(substream);
 	}
 	list_for_each(list, &snd_pcm_notify_list) {
-		snd_pcm_notify_t *notify;
-		notify = list_entry(list, snd_pcm_notify_t, list);
+		struct snd_pcm_notify *notify;
+		notify = list_entry(list, struct snd_pcm_notify, list);
 		notify->n_register(pcm);
 	}
 	up(&register_mutex);
 	return 0;
 }
 
-static int snd_pcm_dev_disconnect(snd_device_t *device)
+static int snd_pcm_dev_disconnect(struct snd_device *device)
 {
-	snd_pcm_t *pcm = device->device_data;
+	struct snd_pcm *pcm = device->device_data;
 	struct list_head *list;
-	snd_pcm_substream_t *substream;
+	struct snd_pcm_substream *substream;
 	int idx, cidx;
 
 	down(&register_mutex);
@@ -913,20 +923,20 @@ static int snd_pcm_dev_disconnect(snd_device_t *device)
 			if (substream->runtime)
 				substream->runtime->status->state = SNDRV_PCM_STATE_DISCONNECTED;
 	list_for_each(list, &snd_pcm_notify_list) {
-		snd_pcm_notify_t *notify;
-		notify = list_entry(list, snd_pcm_notify_t, list);
+		struct snd_pcm_notify *notify;
+		notify = list_entry(list, struct snd_pcm_notify, list);
 		notify->n_disconnect(pcm);
 	}
 	up(&register_mutex);
 	return 0;
 }
 
-static int snd_pcm_dev_unregister(snd_device_t *device)
+static int snd_pcm_dev_unregister(struct snd_device *device)
 {
 	int idx, cidx, devtype;
-	snd_pcm_substream_t *substream;
+	struct snd_pcm_substream *substream;
 	struct list_head *list;
-	snd_pcm_t *pcm = device->device_data;
+	struct snd_pcm *pcm = device->device_data;
 
 	snd_assert(pcm != NULL, return -ENXIO);
 	down(&register_mutex);
@@ -947,15 +957,15 @@ static int snd_pcm_dev_unregister(snd_device_t *device)
 			snd_pcm_timer_done(substream);
 	}
 	list_for_each(list, &snd_pcm_notify_list) {
-		snd_pcm_notify_t *notify;
-		notify = list_entry(list, snd_pcm_notify_t, list);
+		struct snd_pcm_notify *notify;
+		notify = list_entry(list, struct snd_pcm_notify, list);
 		notify->n_unregister(pcm);
 	}
 	up(&register_mutex);
 	return snd_pcm_free(pcm);
 }
 
-int snd_pcm_notify(snd_pcm_notify_t *notify, int nfree)
+int snd_pcm_notify(struct snd_pcm_notify *notify, int nfree)
 {
 	int idx;
 
@@ -984,10 +994,11 @@ int snd_pcm_notify(snd_pcm_notify_t *notify, int nfree)
  *  Info interface
  */
 
-static void snd_pcm_proc_read(snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+static void snd_pcm_proc_read(struct snd_info_entry *entry,
+			      struct snd_info_buffer *buffer)
 {
 	int idx;
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 
 	down(&register_mutex);
 	for (idx = 0; idx < SNDRV_CARDS * SNDRV_PCM_DEVICES; idx++) {
@@ -997,9 +1008,11 @@ static void snd_pcm_proc_read(snd_info_entry_t *entry, snd_info_buffer_t * buffe
 		snd_iprintf(buffer, "%02i-%02i: %s : %s", idx / SNDRV_PCM_DEVICES,
 			    idx % SNDRV_PCM_DEVICES, pcm->id, pcm->name);
 		if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream)
-			snd_iprintf(buffer, " : playback %i", pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream_count);
+			snd_iprintf(buffer, " : playback %i",
+				    pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream_count);
 		if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream)
-			snd_iprintf(buffer, " : capture %i", pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream_count);
+			snd_iprintf(buffer, " : capture %i",
+				    pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream_count);
 		snd_iprintf(buffer, "\n");
 	}
 	up(&register_mutex);
@@ -1009,16 +1022,17 @@ static void snd_pcm_proc_read(snd_info_entry_t *entry, snd_info_buffer_t * buffe
  *  ENTRY functions
  */
 
-static snd_info_entry_t *snd_pcm_proc_entry = NULL;
+static struct snd_info_entry *snd_pcm_proc_entry = NULL;
 
 static int __init alsa_pcm_init(void)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	snd_ctl_register_ioctl(snd_pcm_control_ioctl);
 	snd_ctl_register_ioctl_compat(snd_pcm_control_ioctl);
 	if ((entry = snd_info_create_module_entry(THIS_MODULE, "pcm", NULL)) != NULL) {
-		snd_info_set_text_ops(entry, NULL, SNDRV_CARDS * SNDRV_PCM_DEVICES * 128, snd_pcm_proc_read);
+		snd_info_set_text_ops(entry, NULL, SNDRV_CARDS * SNDRV_PCM_DEVICES * 128,
+				      snd_pcm_proc_read);
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
 			entry = NULL;

commit 7c22f1aaa23370bf9ba2dd3abbccbed70dced216
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:46:31 2005 +0200

    [ALSA] Remove snd_runtime_check() macro
    
    Remove snd_runtime_check() macro.
    This macro worsens the readability of codes.  They should be either
    normal if() or removable asserts.
    
    Also, the assert displays stack-dump, instead of only the last caller
    pointer.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 1be470e942ef..184e74b75ba9 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -273,7 +273,8 @@ static void snd_pcm_proc_info_read(snd_pcm_substream_t *substream, snd_info_buff
 	snd_pcm_info_t *info;
 	int err;
 
-	snd_runtime_check(substream, return);
+	if (! substream)
+		return;
 
 	info = kmalloc(sizeof(*info), GFP_KERNEL);
 	if (! info) {

commit ca2c0966562cfbf9273167a5b60e8fddc24078d6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:20:23 2005 +0200

    [ALSA] Replace with kzalloc() - core stuff
    
    Control Midlevel,ALSA Core,HWDEP Midlevel,PCM Midlevel,RawMidi Midlevel
    Timer Midlevel,ALSA<-OSS emulation
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 9f4c9209b271..1be470e942ef 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -597,7 +597,7 @@ int snd_pcm_new_stream(snd_pcm_t *pcm, int stream, int substream_count)
 	}
 	prev = NULL;
 	for (idx = 0, prev = NULL; idx < substream_count; idx++) {
-		substream = kcalloc(1, sizeof(*substream), GFP_KERNEL);
+		substream = kzalloc(sizeof(*substream), GFP_KERNEL);
 		if (substream == NULL)
 			return -ENOMEM;
 		substream->pcm = pcm;
@@ -657,7 +657,7 @@ int snd_pcm_new(snd_card_t * card, char *id, int device,
 	snd_assert(rpcm != NULL, return -EINVAL);
 	*rpcm = NULL;
 	snd_assert(card != NULL, return -ENXIO);
-	pcm = kcalloc(1, sizeof(*pcm), GFP_KERNEL);
+	pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
 	if (pcm == NULL)
 		return -ENOMEM;
 	pcm->card = card;
@@ -795,7 +795,7 @@ int snd_pcm_open_substream(snd_pcm_t *pcm, int stream,
 	if (substream == NULL)
 		return -EAGAIN;
 
-	runtime = kcalloc(1, sizeof(*runtime), GFP_KERNEL);
+	runtime = kzalloc(sizeof(*runtime), GFP_KERNEL);
 	if (runtime == NULL)
 		return -ENOMEM;
 

commit 123992f728785e05f385d23893bd5ec69871aeb4
Author: Adrian Bunk <bunk@stusta.de>
Date:   Wed May 18 18:02:04 2005 +0200

    [ALSA] sound/core/: possible cleanups
    
    PCM Midlevel,ALSA Core,Timer Midlevel,ALSA sequencer,Virtual Midi
    This patch contains the following possible cleanups:
    - make needlessly global code static
    - #if 0 the following unused global functions
    - remove the following unneeded EXPORT_SYMBOL's
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index d57f4ec3b08b..9f4c9209b271 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1049,7 +1049,6 @@ EXPORT_SYMBOL(snd_pcm_release_substream);
 EXPORT_SYMBOL(snd_pcm_format_name);
   /* pcm_native.c */
 EXPORT_SYMBOL(snd_pcm_link_rwlock);
-EXPORT_SYMBOL(snd_pcm_start);
 #ifdef CONFIG_PM
 EXPORT_SYMBOL(snd_pcm_suspend);
 EXPORT_SYMBOL(snd_pcm_suspend_all);

commit 9502dcad6c1138a3ce2bae23ccd4be44c718d2a9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 18 16:25:46 2005 +0200

    [ALSA] Export missing snd_pcm_format_*()
    
    PCM Midlevel
    Export snd_pcm_format_size().  This function is used by some out-of-kernel
    drivers.
    
    Make snd_pcm_format_cpu_endian() macro for optimization.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index a2757fcec1f0..d57f4ec3b08b 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -1069,6 +1069,7 @@ EXPORT_SYMBOL(snd_pcm_format_little_endian);
 EXPORT_SYMBOL(snd_pcm_format_big_endian);
 EXPORT_SYMBOL(snd_pcm_format_width);
 EXPORT_SYMBOL(snd_pcm_format_physical_width);
+EXPORT_SYMBOL(snd_pcm_format_size);
 EXPORT_SYMBOL(snd_pcm_format_silence_64);
 EXPORT_SYMBOL(snd_pcm_format_set_silence);
 EXPORT_SYMBOL(snd_pcm_build_linear_format);

commit bd7bf042e89941d4e693a0ec68c5093a2bb2adb3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 12 16:27:28 2005 +0200

    [ALSA] Fix permissions in some /proc files
    
    PCM Midlevel,CA0106 driver,EMU10K1/EMU10K2 driver
    Fix by Guillaume Chazarain <guichaz@yahoo.fr>:
    
    Some tunables in /proc have a write() function, but as their
    permission does not reflect it, it can be confusing to the user.
    
    So here is a patch that corrects the mode of those files. Note that I
    have only tested the 'xrun_debug' entry.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 8d94325529a8..a2757fcec1f0 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -451,6 +451,7 @@ static int snd_pcm_stream_proc_init(snd_pcm_str_t *pstr)
 		entry->c.text.read = snd_pcm_xrun_debug_read;
 		entry->c.text.write_size = 64;
 		entry->c.text.write = snd_pcm_xrun_debug_write;
+		entry->mode |= S_IWUSR;
 		entry->private_data = pstr;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/core/pcm.c b/sound/core/pcm.c
new file mode 100644
index 000000000000..8d94325529a8
--- /dev/null
+++ b/sound/core/pcm.c
@@ -0,0 +1,1074 @@
+/*
+ *  Digital Audio (PCM) abstract layer
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <sound/core.h>
+#include <sound/minors.h>
+#include <sound/pcm.h>
+#include <sound/control.h>
+#include <sound/info.h>
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, Abramo Bagnara <abramo@alsa-project.org>");
+MODULE_DESCRIPTION("Midlevel PCM code for ALSA.");
+MODULE_LICENSE("GPL");
+
+snd_pcm_t *snd_pcm_devices[SNDRV_CARDS * SNDRV_PCM_DEVICES];
+static LIST_HEAD(snd_pcm_notify_list);
+static DECLARE_MUTEX(register_mutex);
+
+static int snd_pcm_free(snd_pcm_t *pcm);
+static int snd_pcm_dev_free(snd_device_t *device);
+static int snd_pcm_dev_register(snd_device_t *device);
+static int snd_pcm_dev_disconnect(snd_device_t *device);
+static int snd_pcm_dev_unregister(snd_device_t *device);
+
+static int snd_pcm_control_ioctl(snd_card_t * card,
+				 snd_ctl_file_t * control,
+				 unsigned int cmd, unsigned long arg)
+{
+	unsigned int tmp;
+
+	tmp = card->number * SNDRV_PCM_DEVICES;
+	switch (cmd) {
+	case SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE:
+		{
+			int device;
+
+			if (get_user(device, (int __user *)arg))
+				return -EFAULT;
+			device = device < 0 ? 0 : device + 1;
+			while (device < SNDRV_PCM_DEVICES) {
+				if (snd_pcm_devices[tmp + device])
+					break;
+				device++;
+			}
+			if (device == SNDRV_PCM_DEVICES)
+				device = -1;
+			if (put_user(device, (int __user *)arg))
+				return -EFAULT;
+			return 0;
+		}
+	case SNDRV_CTL_IOCTL_PCM_INFO:
+		{
+			snd_pcm_info_t __user *info;
+			unsigned int device, subdevice;
+			snd_pcm_stream_t stream;
+			snd_pcm_t *pcm;
+			snd_pcm_str_t *pstr;
+			snd_pcm_substream_t *substream;
+			info = (snd_pcm_info_t __user *)arg;
+			if (get_user(device, &info->device))
+				return -EFAULT;
+			if (device >= SNDRV_PCM_DEVICES)
+				return -ENXIO;
+			pcm = snd_pcm_devices[tmp + device];
+			if (pcm == NULL)
+				return -ENXIO;
+			if (get_user(stream, &info->stream))
+				return -EFAULT;
+			if (stream < 0 || stream > 1)
+				return -EINVAL;
+			pstr = &pcm->streams[stream];
+			if (pstr->substream_count == 0)
+				return -ENOENT;
+			if (get_user(subdevice, &info->subdevice))
+				return -EFAULT;
+			if (subdevice >= pstr->substream_count)
+				return -ENXIO;
+			for (substream = pstr->substream; substream; substream = substream->next)
+				if (substream->number == (int)subdevice)
+					break;
+			if (substream == NULL)
+				return -ENXIO;
+			return snd_pcm_info_user(substream, info);
+		}
+	case SNDRV_CTL_IOCTL_PCM_PREFER_SUBDEVICE:
+		{
+			int val;
+			
+			if (get_user(val, (int __user *)arg))
+				return -EFAULT;
+			control->prefer_pcm_subdevice = val;
+			return 0;
+		}
+	}
+	return -ENOIOCTLCMD;
+}
+#define STATE(v) [SNDRV_PCM_STATE_##v] = #v
+#define STREAM(v) [SNDRV_PCM_STREAM_##v] = #v
+#define READY(v) [SNDRV_PCM_READY_##v] = #v
+#define XRUN(v) [SNDRV_PCM_XRUN_##v] = #v
+#define SILENCE(v) [SNDRV_PCM_SILENCE_##v] = #v
+#define TSTAMP(v) [SNDRV_PCM_TSTAMP_##v] = #v
+#define ACCESS(v) [SNDRV_PCM_ACCESS_##v] = #v
+#define START(v) [SNDRV_PCM_START_##v] = #v
+#define FORMAT(v) [SNDRV_PCM_FORMAT_##v] = #v
+#define SUBFORMAT(v) [SNDRV_PCM_SUBFORMAT_##v] = #v 
+
+static char *snd_pcm_stream_names[] = {
+	STREAM(PLAYBACK),
+	STREAM(CAPTURE),
+};
+
+static char *snd_pcm_state_names[] = {
+	STATE(OPEN),
+	STATE(SETUP),
+	STATE(PREPARED),
+	STATE(RUNNING),
+	STATE(XRUN),
+	STATE(DRAINING),
+	STATE(PAUSED),
+	STATE(SUSPENDED),
+};
+
+static char *snd_pcm_access_names[] = {
+	ACCESS(MMAP_INTERLEAVED), 
+	ACCESS(MMAP_NONINTERLEAVED),
+	ACCESS(MMAP_COMPLEX),
+	ACCESS(RW_INTERLEAVED),
+	ACCESS(RW_NONINTERLEAVED),
+};
+
+static char *snd_pcm_format_names[] = {
+	FORMAT(S8),
+	FORMAT(U8),
+	FORMAT(S16_LE),
+	FORMAT(S16_BE),
+	FORMAT(U16_LE),
+	FORMAT(U16_BE),
+	FORMAT(S24_LE),
+	FORMAT(S24_BE),
+	FORMAT(U24_LE),
+	FORMAT(U24_BE),
+	FORMAT(S32_LE),
+	FORMAT(S32_BE),
+	FORMAT(U32_LE),
+	FORMAT(U32_BE),
+	FORMAT(FLOAT_LE),
+	FORMAT(FLOAT_BE),
+	FORMAT(FLOAT64_LE),
+	FORMAT(FLOAT64_BE),
+	FORMAT(IEC958_SUBFRAME_LE),
+	FORMAT(IEC958_SUBFRAME_BE),
+	FORMAT(MU_LAW),
+	FORMAT(A_LAW),
+	FORMAT(IMA_ADPCM),
+	FORMAT(MPEG),
+	FORMAT(GSM),
+	FORMAT(SPECIAL),
+	FORMAT(S24_3LE),
+	FORMAT(S24_3BE),
+	FORMAT(U24_3LE),
+	FORMAT(U24_3BE),
+	FORMAT(S20_3LE),
+	FORMAT(S20_3BE),
+	FORMAT(U20_3LE),
+	FORMAT(U20_3BE),
+	FORMAT(S18_3LE),
+	FORMAT(S18_3BE),
+	FORMAT(U18_3LE),
+	FORMAT(U18_3BE),
+};
+
+static char *snd_pcm_subformat_names[] = {
+	SUBFORMAT(STD), 
+};
+
+static char *snd_pcm_tstamp_mode_names[] = {
+	TSTAMP(NONE),
+	TSTAMP(MMAP),
+};
+
+static const char *snd_pcm_stream_name(snd_pcm_stream_t stream)
+{
+	snd_assert(stream <= SNDRV_PCM_STREAM_LAST, return NULL);
+	return snd_pcm_stream_names[stream];
+}
+
+static const char *snd_pcm_access_name(snd_pcm_access_t access)
+{
+	snd_assert(access <= SNDRV_PCM_ACCESS_LAST, return NULL);
+	return snd_pcm_access_names[access];
+}
+
+const char *snd_pcm_format_name(snd_pcm_format_t format)
+{
+	snd_assert(format <= SNDRV_PCM_FORMAT_LAST, return NULL);
+	return snd_pcm_format_names[format];
+}
+
+static const char *snd_pcm_subformat_name(snd_pcm_subformat_t subformat)
+{
+	snd_assert(subformat <= SNDRV_PCM_SUBFORMAT_LAST, return NULL);
+	return snd_pcm_subformat_names[subformat];
+}
+
+static const char *snd_pcm_tstamp_mode_name(snd_pcm_tstamp_t mode)
+{
+	snd_assert(mode <= SNDRV_PCM_TSTAMP_LAST, return NULL);
+	return snd_pcm_tstamp_mode_names[mode];
+}
+
+static const char *snd_pcm_state_name(snd_pcm_state_t state)
+{
+	snd_assert(state <= SNDRV_PCM_STATE_LAST, return NULL);
+	return snd_pcm_state_names[state];
+}
+
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+#include <linux/soundcard.h>
+static const char *snd_pcm_oss_format_name(int format)
+{
+	switch (format) {
+	case AFMT_MU_LAW:
+		return "MU_LAW";
+	case AFMT_A_LAW:
+		return "A_LAW";
+	case AFMT_IMA_ADPCM:
+		return "IMA_ADPCM";
+	case AFMT_U8:
+		return "U8";
+	case AFMT_S16_LE:
+		return "S16_LE";
+	case AFMT_S16_BE:
+		return "S16_BE";
+	case AFMT_S8:
+		return "S8";
+	case AFMT_U16_LE:
+		return "U16_LE";
+	case AFMT_U16_BE:
+		return "U16_BE";
+	case AFMT_MPEG:
+		return "MPEG";
+	default:
+		return "unknown";
+	}
+}
+#endif
+
+#ifdef CONFIG_PROC_FS
+static void snd_pcm_proc_info_read(snd_pcm_substream_t *substream, snd_info_buffer_t *buffer)
+{
+	snd_pcm_info_t *info;
+	int err;
+
+	snd_runtime_check(substream, return);
+
+	info = kmalloc(sizeof(*info), GFP_KERNEL);
+	if (! info) {
+		printk(KERN_DEBUG "snd_pcm_proc_info_read: cannot malloc\n");
+		return;
+	}
+
+	err = snd_pcm_info(substream, info);
+	if (err < 0) {
+		snd_iprintf(buffer, "error %d\n", err);
+		kfree(info);
+		return;
+	}
+	snd_iprintf(buffer, "card: %d\n", info->card);
+	snd_iprintf(buffer, "device: %d\n", info->device);
+	snd_iprintf(buffer, "subdevice: %d\n", info->subdevice);
+	snd_iprintf(buffer, "stream: %s\n", snd_pcm_stream_name(info->stream));
+	snd_iprintf(buffer, "id: %s\n", info->id);
+	snd_iprintf(buffer, "name: %s\n", info->name);
+	snd_iprintf(buffer, "subname: %s\n", info->subname);
+	snd_iprintf(buffer, "class: %d\n", info->dev_class);
+	snd_iprintf(buffer, "subclass: %d\n", info->dev_subclass);
+	snd_iprintf(buffer, "subdevices_count: %d\n", info->subdevices_count);
+	snd_iprintf(buffer, "subdevices_avail: %d\n", info->subdevices_avail);
+	kfree(info);
+}
+
+static void snd_pcm_stream_proc_info_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+{
+	snd_pcm_proc_info_read(((snd_pcm_str_t *)entry->private_data)->substream, buffer);
+}
+
+static void snd_pcm_substream_proc_info_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+{
+	snd_pcm_proc_info_read((snd_pcm_substream_t *)entry->private_data, buffer);
+}
+
+static void snd_pcm_substream_proc_hw_params_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+{
+	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)entry->private_data;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	if (!runtime) {
+		snd_iprintf(buffer, "closed\n");
+		return;
+	}
+	snd_pcm_stream_lock_irq(substream);
+	if (runtime->status->state == SNDRV_PCM_STATE_OPEN) {
+		snd_iprintf(buffer, "no setup\n");
+		snd_pcm_stream_unlock_irq(substream);
+		return;
+	}
+	snd_iprintf(buffer, "access: %s\n", snd_pcm_access_name(runtime->access));
+	snd_iprintf(buffer, "format: %s\n", snd_pcm_format_name(runtime->format));
+	snd_iprintf(buffer, "subformat: %s\n", snd_pcm_subformat_name(runtime->subformat));
+	snd_iprintf(buffer, "channels: %u\n", runtime->channels);	
+	snd_iprintf(buffer, "rate: %u (%u/%u)\n", runtime->rate, runtime->rate_num, runtime->rate_den);	
+	snd_iprintf(buffer, "period_size: %lu\n", runtime->period_size);	
+	snd_iprintf(buffer, "buffer_size: %lu\n", runtime->buffer_size);	
+	snd_iprintf(buffer, "tick_time: %u\n", runtime->tick_time);
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	if (substream->oss.oss) {
+		snd_iprintf(buffer, "OSS format: %s\n", snd_pcm_oss_format_name(runtime->oss.format));
+		snd_iprintf(buffer, "OSS channels: %u\n", runtime->oss.channels);	
+		snd_iprintf(buffer, "OSS rate: %u\n", runtime->oss.rate);
+		snd_iprintf(buffer, "OSS period bytes: %lu\n", (unsigned long)runtime->oss.period_bytes);
+		snd_iprintf(buffer, "OSS periods: %u\n", runtime->oss.periods);
+		snd_iprintf(buffer, "OSS period frames: %lu\n", (unsigned long)runtime->oss.period_frames);
+	}
+#endif
+	snd_pcm_stream_unlock_irq(substream);
+}
+
+static void snd_pcm_substream_proc_sw_params_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+{
+	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)entry->private_data;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	if (!runtime) {
+		snd_iprintf(buffer, "closed\n");
+		return;
+	}
+	snd_pcm_stream_lock_irq(substream);
+	if (runtime->status->state == SNDRV_PCM_STATE_OPEN) {
+		snd_iprintf(buffer, "no setup\n");
+		snd_pcm_stream_unlock_irq(substream);
+		return;
+	}
+	snd_iprintf(buffer, "tstamp_mode: %s\n", snd_pcm_tstamp_mode_name(runtime->tstamp_mode));
+	snd_iprintf(buffer, "period_step: %u\n", runtime->period_step);
+	snd_iprintf(buffer, "sleep_min: %u\n", runtime->sleep_min);
+	snd_iprintf(buffer, "avail_min: %lu\n", runtime->control->avail_min);
+	snd_iprintf(buffer, "xfer_align: %lu\n", runtime->xfer_align);
+	snd_iprintf(buffer, "start_threshold: %lu\n", runtime->start_threshold);
+	snd_iprintf(buffer, "stop_threshold: %lu\n", runtime->stop_threshold);
+	snd_iprintf(buffer, "silence_threshold: %lu\n", runtime->silence_threshold);
+	snd_iprintf(buffer, "silence_size: %lu\n", runtime->silence_size);
+	snd_iprintf(buffer, "boundary: %lu\n", runtime->boundary);
+	snd_pcm_stream_unlock_irq(substream);
+}
+
+static void snd_pcm_substream_proc_status_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+{
+	snd_pcm_substream_t *substream = (snd_pcm_substream_t *)entry->private_data;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_pcm_status_t status;
+	int err;
+	if (!runtime) {
+		snd_iprintf(buffer, "closed\n");
+		return;
+	}
+	memset(&status, 0, sizeof(status));
+	err = snd_pcm_status(substream, &status);
+	if (err < 0) {
+		snd_iprintf(buffer, "error %d\n", err);
+		return;
+	}
+	snd_iprintf(buffer, "state: %s\n", snd_pcm_state_name(status.state));
+	snd_iprintf(buffer, "trigger_time: %ld.%09ld\n",
+		status.trigger_tstamp.tv_sec, status.trigger_tstamp.tv_nsec);
+	snd_iprintf(buffer, "tstamp      : %ld.%09ld\n",
+		status.tstamp.tv_sec, status.tstamp.tv_nsec);
+	snd_iprintf(buffer, "delay       : %ld\n", status.delay);
+	snd_iprintf(buffer, "avail       : %ld\n", status.avail);
+	snd_iprintf(buffer, "avail_max   : %ld\n", status.avail_max);
+	snd_iprintf(buffer, "-----\n");
+	snd_iprintf(buffer, "hw_ptr      : %ld\n", runtime->status->hw_ptr);
+	snd_iprintf(buffer, "appl_ptr    : %ld\n", runtime->control->appl_ptr);
+}
+#endif
+
+#ifdef CONFIG_SND_DEBUG
+static void snd_pcm_xrun_debug_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+{
+	snd_pcm_str_t *pstr = (snd_pcm_str_t *)entry->private_data;
+	snd_iprintf(buffer, "%d\n", pstr->xrun_debug);
+}
+
+static void snd_pcm_xrun_debug_write(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+{
+	snd_pcm_str_t *pstr = (snd_pcm_str_t *)entry->private_data;
+	char line[64];
+	if (!snd_info_get_line(buffer, line, sizeof(line)))
+		pstr->xrun_debug = simple_strtoul(line, NULL, 10);
+}
+#endif
+
+static int snd_pcm_stream_proc_init(snd_pcm_str_t *pstr)
+{
+	snd_pcm_t *pcm = pstr->pcm;
+	snd_info_entry_t *entry;
+	char name[16];
+
+	sprintf(name, "pcm%i%c", pcm->device, 
+		pstr->stream == SNDRV_PCM_STREAM_PLAYBACK ? 'p' : 'c');
+	if ((entry = snd_info_create_card_entry(pcm->card, name, pcm->card->proc_root)) == NULL)
+		return -ENOMEM;
+	entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+	if (snd_info_register(entry) < 0) {
+		snd_info_free_entry(entry);
+		return -ENOMEM;
+	}
+	pstr->proc_root = entry;
+
+	if ((entry = snd_info_create_card_entry(pcm->card, "info", pstr->proc_root)) != NULL) {
+		snd_info_set_text_ops(entry, pstr, 256, snd_pcm_stream_proc_info_read);
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	pstr->proc_info_entry = entry;
+
+#ifdef CONFIG_SND_DEBUG
+	if ((entry = snd_info_create_card_entry(pcm->card, "xrun_debug", pstr->proc_root)) != NULL) {
+		entry->c.text.read_size = 64;
+		entry->c.text.read = snd_pcm_xrun_debug_read;
+		entry->c.text.write_size = 64;
+		entry->c.text.write = snd_pcm_xrun_debug_write;
+		entry->private_data = pstr;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	pstr->proc_xrun_debug_entry = entry;
+#endif
+	return 0;
+}
+
+static int snd_pcm_stream_proc_done(snd_pcm_str_t *pstr)
+{
+#ifdef CONFIG_SND_DEBUG
+	if (pstr->proc_xrun_debug_entry) {
+		snd_info_unregister(pstr->proc_xrun_debug_entry);
+		pstr->proc_xrun_debug_entry = NULL;
+	}
+#endif
+	if (pstr->proc_info_entry) {
+		snd_info_unregister(pstr->proc_info_entry);
+		pstr->proc_info_entry = NULL;
+	}
+	if (pstr->proc_root) {
+		snd_info_unregister(pstr->proc_root);
+		pstr->proc_root = NULL;
+	}
+	return 0;
+}
+
+static int snd_pcm_substream_proc_init(snd_pcm_substream_t *substream)
+{
+	snd_info_entry_t *entry;
+	snd_card_t *card;
+	char name[16];
+
+	card = substream->pcm->card;
+
+	sprintf(name, "sub%i", substream->number);
+	if ((entry = snd_info_create_card_entry(card, name, substream->pstr->proc_root)) == NULL)
+		return -ENOMEM;
+	entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+	if (snd_info_register(entry) < 0) {
+		snd_info_free_entry(entry);
+		return -ENOMEM;
+	}
+	substream->proc_root = entry;
+
+	if ((entry = snd_info_create_card_entry(card, "info", substream->proc_root)) != NULL) {
+		snd_info_set_text_ops(entry, substream, 256, snd_pcm_substream_proc_info_read);
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	substream->proc_info_entry = entry;
+
+	if ((entry = snd_info_create_card_entry(card, "hw_params", substream->proc_root)) != NULL) {
+		snd_info_set_text_ops(entry, substream, 256, snd_pcm_substream_proc_hw_params_read);
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	substream->proc_hw_params_entry = entry;
+
+	if ((entry = snd_info_create_card_entry(card, "sw_params", substream->proc_root)) != NULL) {
+		snd_info_set_text_ops(entry, substream, 256, snd_pcm_substream_proc_sw_params_read);
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	substream->proc_sw_params_entry = entry;
+
+	if ((entry = snd_info_create_card_entry(card, "status", substream->proc_root)) != NULL) {
+		snd_info_set_text_ops(entry, substream, 256, snd_pcm_substream_proc_status_read);
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	substream->proc_status_entry = entry;
+
+	return 0;
+}
+		
+static int snd_pcm_substream_proc_done(snd_pcm_substream_t *substream)
+{
+	if (substream->proc_info_entry) {
+		snd_info_unregister(substream->proc_info_entry);
+		substream->proc_info_entry = NULL;
+	}
+	if (substream->proc_hw_params_entry) {
+		snd_info_unregister(substream->proc_hw_params_entry);
+		substream->proc_hw_params_entry = NULL;
+	}
+	if (substream->proc_sw_params_entry) {
+		snd_info_unregister(substream->proc_sw_params_entry);
+		substream->proc_sw_params_entry = NULL;
+	}
+	if (substream->proc_status_entry) {
+		snd_info_unregister(substream->proc_status_entry);
+		substream->proc_status_entry = NULL;
+	}
+	if (substream->proc_root) {
+		snd_info_unregister(substream->proc_root);
+		substream->proc_root = NULL;
+	}
+	return 0;
+}
+
+/**
+ * snd_pcm_new_stream - create a new PCM stream
+ * @pcm: the pcm instance
+ * @stream: the stream direction, SNDRV_PCM_STREAM_XXX
+ * @substream_count: the number of substreams
+ *
+ * Creates a new stream for the pcm.
+ * The corresponding stream on the pcm must have been empty before
+ * calling this, i.e. zero must be given to the argument of
+ * snd_pcm_new().
+ *
+ * Returns zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_new_stream(snd_pcm_t *pcm, int stream, int substream_count)
+{
+	int idx, err;
+	snd_pcm_str_t *pstr = &pcm->streams[stream];
+	snd_pcm_substream_t *substream, *prev;
+
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	init_MUTEX(&pstr->oss.setup_mutex);
+#endif
+	pstr->stream = stream;
+	pstr->pcm = pcm;
+	pstr->substream_count = substream_count;
+	pstr->reg = &snd_pcm_reg[stream];
+	if (substream_count > 0) {
+		err = snd_pcm_stream_proc_init(pstr);
+		if (err < 0)
+			return err;
+	}
+	prev = NULL;
+	for (idx = 0, prev = NULL; idx < substream_count; idx++) {
+		substream = kcalloc(1, sizeof(*substream), GFP_KERNEL);
+		if (substream == NULL)
+			return -ENOMEM;
+		substream->pcm = pcm;
+		substream->pstr = pstr;
+		substream->number = idx;
+		substream->stream = stream;
+		sprintf(substream->name, "subdevice #%i", idx);
+		substream->buffer_bytes_max = UINT_MAX;
+		if (prev == NULL)
+			pstr->substream = substream;
+		else
+			prev->next = substream;
+		err = snd_pcm_substream_proc_init(substream);
+		if (err < 0) {
+			kfree(substream);
+			return err;
+		}
+		substream->group = &substream->self_group;
+		spin_lock_init(&substream->self_group.lock);
+		INIT_LIST_HEAD(&substream->self_group.substreams);
+		list_add_tail(&substream->link_list, &substream->self_group.substreams);
+		spin_lock_init(&substream->timer_lock);
+		prev = substream;
+	}
+	return 0;
+}				
+
+/**
+ * snd_pcm_new - create a new PCM instance
+ * @card: the card instance
+ * @id: the id string
+ * @device: the device index (zero based)
+ * @playback_count: the number of substreams for playback
+ * @capture_count: the number of substreams for capture
+ * @rpcm: the pointer to store the new pcm instance
+ *
+ * Creates a new PCM instance.
+ *
+ * The pcm operators have to be set afterwards to the new instance
+ * via snd_pcm_set_ops().
+ *
+ * Returns zero if successful, or a negative error code on failure.
+ */
+int snd_pcm_new(snd_card_t * card, char *id, int device,
+		int playback_count, int capture_count,
+	        snd_pcm_t ** rpcm)
+{
+	snd_pcm_t *pcm;
+	int err;
+	static snd_device_ops_t ops = {
+		.dev_free = snd_pcm_dev_free,
+		.dev_register =	snd_pcm_dev_register,
+		.dev_disconnect = snd_pcm_dev_disconnect,
+		.dev_unregister = snd_pcm_dev_unregister
+	};
+
+	snd_assert(rpcm != NULL, return -EINVAL);
+	*rpcm = NULL;
+	snd_assert(card != NULL, return -ENXIO);
+	pcm = kcalloc(1, sizeof(*pcm), GFP_KERNEL);
+	if (pcm == NULL)
+		return -ENOMEM;
+	pcm->card = card;
+	pcm->device = device;
+	if (id) {
+		strlcpy(pcm->id, id, sizeof(pcm->id));
+	}
+	if ((err = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_PLAYBACK, playback_count)) < 0) {
+		snd_pcm_free(pcm);
+		return err;
+	}
+	if ((err = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_CAPTURE, capture_count)) < 0) {
+		snd_pcm_free(pcm);
+		return err;
+	}
+	init_MUTEX(&pcm->open_mutex);
+	init_waitqueue_head(&pcm->open_wait);
+	if ((err = snd_device_new(card, SNDRV_DEV_PCM, pcm, &ops)) < 0) {
+		snd_pcm_free(pcm);
+		return err;
+	}
+	*rpcm = pcm;
+	return 0;
+}
+
+static void snd_pcm_free_stream(snd_pcm_str_t * pstr)
+{
+	snd_pcm_substream_t *substream, *substream_next;
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	snd_pcm_oss_setup_t *setup, *setupn;
+#endif
+	substream = pstr->substream;
+	while (substream) {
+		substream_next = substream->next;
+		snd_pcm_substream_proc_done(substream);
+		kfree(substream);
+		substream = substream_next;
+	}
+	snd_pcm_stream_proc_done(pstr);
+#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
+	for (setup = pstr->oss.setup_list; setup; setup = setupn) {
+		setupn = setup->next;
+		kfree(setup->task_name);
+		kfree(setup);
+	}
+#endif
+}
+
+static int snd_pcm_free(snd_pcm_t *pcm)
+{
+	snd_assert(pcm != NULL, return -ENXIO);
+	if (pcm->private_free)
+		pcm->private_free(pcm);
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+	snd_pcm_free_stream(&pcm->streams[SNDRV_PCM_STREAM_PLAYBACK]);
+	snd_pcm_free_stream(&pcm->streams[SNDRV_PCM_STREAM_CAPTURE]);
+	kfree(pcm);
+	return 0;
+}
+
+static int snd_pcm_dev_free(snd_device_t *device)
+{
+	snd_pcm_t *pcm = device->device_data;
+	return snd_pcm_free(pcm);
+}
+
+static void snd_pcm_tick_timer_func(unsigned long data)
+{
+	snd_pcm_substream_t *substream = (snd_pcm_substream_t*) data;
+	snd_pcm_tick_elapsed(substream);
+}
+
+int snd_pcm_open_substream(snd_pcm_t *pcm, int stream,
+			   snd_pcm_substream_t **rsubstream)
+{
+	snd_pcm_str_t * pstr;
+	snd_pcm_substream_t * substream;
+	snd_pcm_runtime_t * runtime;
+	snd_ctl_file_t *kctl;
+	snd_card_t *card;
+	struct list_head *list;
+	int prefer_subdevice = -1;
+	size_t size;
+
+	snd_assert(rsubstream != NULL, return -EINVAL);
+	*rsubstream = NULL;
+	snd_assert(pcm != NULL, return -ENXIO);
+	pstr = &pcm->streams[stream];
+	if (pstr->substream == NULL)
+		return -ENODEV;
+
+	card = pcm->card;
+	down_read(&card->controls_rwsem);
+	list_for_each(list, &card->ctl_files) {
+		kctl = snd_ctl_file(list);
+		if (kctl->pid == current->pid) {
+			prefer_subdevice = kctl->prefer_pcm_subdevice;
+			break;
+		}
+	}
+	up_read(&card->controls_rwsem);
+
+	if (pstr->substream_count == 0)
+		return -ENODEV;
+	switch (stream) {
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		if (pcm->info_flags & SNDRV_PCM_INFO_HALF_DUPLEX) {
+			for (substream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream; substream; substream = substream->next) {
+				if (SUBSTREAM_BUSY(substream))
+					return -EAGAIN;
+			}
+		}
+		break;
+	case SNDRV_PCM_STREAM_CAPTURE:
+		if (pcm->info_flags & SNDRV_PCM_INFO_HALF_DUPLEX) {
+			for (substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; substream; substream = substream->next) {
+				if (SUBSTREAM_BUSY(substream))
+					return -EAGAIN;
+			}
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (prefer_subdevice >= 0) {
+		for (substream = pstr->substream; substream; substream = substream->next)
+			if (!SUBSTREAM_BUSY(substream) && substream->number == prefer_subdevice)
+				goto __ok;
+	}
+	for (substream = pstr->substream; substream; substream = substream->next)
+		if (!SUBSTREAM_BUSY(substream))
+			break;
+      __ok:
+	if (substream == NULL)
+		return -EAGAIN;
+
+	runtime = kcalloc(1, sizeof(*runtime), GFP_KERNEL);
+	if (runtime == NULL)
+		return -ENOMEM;
+
+	size = PAGE_ALIGN(sizeof(snd_pcm_mmap_status_t));
+	runtime->status = snd_malloc_pages(size, GFP_KERNEL);
+	if (runtime->status == NULL) {
+		kfree(runtime);
+		return -ENOMEM;
+	}
+	memset((void*)runtime->status, 0, size);
+
+	size = PAGE_ALIGN(sizeof(snd_pcm_mmap_control_t));
+	runtime->control = snd_malloc_pages(size, GFP_KERNEL);
+	if (runtime->control == NULL) {
+		snd_free_pages((void*)runtime->status, PAGE_ALIGN(sizeof(snd_pcm_mmap_status_t)));
+		kfree(runtime);
+		return -ENOMEM;
+	}
+	memset((void*)runtime->control, 0, size);
+
+	init_waitqueue_head(&runtime->sleep);
+	atomic_set(&runtime->mmap_count, 0);
+	init_timer(&runtime->tick_timer);
+	runtime->tick_timer.function = snd_pcm_tick_timer_func;
+	runtime->tick_timer.data = (unsigned long) substream;
+
+	runtime->status->state = SNDRV_PCM_STATE_OPEN;
+
+	substream->runtime = runtime;
+	substream->private_data = pcm->private_data;
+	pstr->substream_opened++;
+	*rsubstream = substream;
+	return 0;
+}
+
+void snd_pcm_release_substream(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t * runtime;
+	substream->file = NULL;
+	runtime = substream->runtime;
+	snd_assert(runtime != NULL, return);
+	if (runtime->private_free != NULL)
+		runtime->private_free(runtime);
+	snd_free_pages((void*)runtime->status, PAGE_ALIGN(sizeof(snd_pcm_mmap_status_t)));
+	snd_free_pages((void*)runtime->control, PAGE_ALIGN(sizeof(snd_pcm_mmap_control_t)));
+	kfree(runtime->hw_constraints.rules);
+	kfree(runtime);
+	substream->runtime = NULL;
+	substream->pstr->substream_opened--;
+}
+
+static int snd_pcm_dev_register(snd_device_t *device)
+{
+	int idx, cidx, err;
+	unsigned short minor;
+	snd_pcm_substream_t *substream;
+	struct list_head *list;
+	char str[16];
+	snd_pcm_t *pcm = device->device_data;
+
+	snd_assert(pcm != NULL && device != NULL, return -ENXIO);
+	down(&register_mutex);
+	idx = (pcm->card->number * SNDRV_PCM_DEVICES) + pcm->device;
+	if (snd_pcm_devices[idx]) {
+		up(&register_mutex);
+		return -EBUSY;
+	}
+	snd_pcm_devices[idx] = pcm;
+	for (cidx = 0; cidx < 2; cidx++) {
+		int devtype = -1;
+		if (pcm->streams[cidx].substream == NULL)
+			continue;
+		switch (cidx) {
+		case SNDRV_PCM_STREAM_PLAYBACK:
+			sprintf(str, "pcmC%iD%ip", pcm->card->number, pcm->device);
+			minor = SNDRV_MINOR_PCM_PLAYBACK + idx;
+			devtype = SNDRV_DEVICE_TYPE_PCM_PLAYBACK;
+			break;
+		case SNDRV_PCM_STREAM_CAPTURE:
+			sprintf(str, "pcmC%iD%ic", pcm->card->number, pcm->device);
+			minor = SNDRV_MINOR_PCM_CAPTURE + idx;
+			devtype = SNDRV_DEVICE_TYPE_PCM_CAPTURE;
+			break;
+		}
+		if ((err = snd_register_device(devtype, pcm->card, pcm->device, pcm->streams[cidx].reg, str)) < 0) {
+			snd_pcm_devices[idx] = NULL;
+			up(&register_mutex);
+			return err;
+		}
+		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
+			snd_pcm_timer_init(substream);
+	}
+	list_for_each(list, &snd_pcm_notify_list) {
+		snd_pcm_notify_t *notify;
+		notify = list_entry(list, snd_pcm_notify_t, list);
+		notify->n_register(pcm);
+	}
+	up(&register_mutex);
+	return 0;
+}
+
+static int snd_pcm_dev_disconnect(snd_device_t *device)
+{
+	snd_pcm_t *pcm = device->device_data;
+	struct list_head *list;
+	snd_pcm_substream_t *substream;
+	int idx, cidx;
+
+	down(&register_mutex);
+	idx = (pcm->card->number * SNDRV_PCM_DEVICES) + pcm->device;
+	snd_pcm_devices[idx] = NULL;
+	for (cidx = 0; cidx < 2; cidx++)
+		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
+			if (substream->runtime)
+				substream->runtime->status->state = SNDRV_PCM_STATE_DISCONNECTED;
+	list_for_each(list, &snd_pcm_notify_list) {
+		snd_pcm_notify_t *notify;
+		notify = list_entry(list, snd_pcm_notify_t, list);
+		notify->n_disconnect(pcm);
+	}
+	up(&register_mutex);
+	return 0;
+}
+
+static int snd_pcm_dev_unregister(snd_device_t *device)
+{
+	int idx, cidx, devtype;
+	snd_pcm_substream_t *substream;
+	struct list_head *list;
+	snd_pcm_t *pcm = device->device_data;
+
+	snd_assert(pcm != NULL, return -ENXIO);
+	down(&register_mutex);
+	idx = (pcm->card->number * SNDRV_PCM_DEVICES) + pcm->device;
+	snd_pcm_devices[idx] = NULL;
+	for (cidx = 0; cidx < 2; cidx++) {
+		devtype = -1;
+		switch (cidx) {
+		case SNDRV_PCM_STREAM_PLAYBACK:
+			devtype = SNDRV_DEVICE_TYPE_PCM_PLAYBACK;
+			break;
+		case SNDRV_PCM_STREAM_CAPTURE:
+			devtype = SNDRV_DEVICE_TYPE_PCM_CAPTURE;
+			break;
+		}
+		snd_unregister_device(devtype, pcm->card, pcm->device);
+		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
+			snd_pcm_timer_done(substream);
+	}
+	list_for_each(list, &snd_pcm_notify_list) {
+		snd_pcm_notify_t *notify;
+		notify = list_entry(list, snd_pcm_notify_t, list);
+		notify->n_unregister(pcm);
+	}
+	up(&register_mutex);
+	return snd_pcm_free(pcm);
+}
+
+int snd_pcm_notify(snd_pcm_notify_t *notify, int nfree)
+{
+	int idx;
+
+	snd_assert(notify != NULL && notify->n_register != NULL && notify->n_unregister != NULL, return -EINVAL);
+	down(&register_mutex);
+	if (nfree) {
+		list_del(&notify->list);
+		for (idx = 0; idx < SNDRV_CARDS * SNDRV_PCM_DEVICES; idx++) {
+			if (snd_pcm_devices[idx] == NULL)
+				continue;
+			notify->n_unregister(snd_pcm_devices[idx]);
+		}
+	} else {
+		list_add_tail(&notify->list, &snd_pcm_notify_list);
+		for (idx = 0; idx < SNDRV_CARDS * SNDRV_PCM_DEVICES; idx++) {
+			if (snd_pcm_devices[idx] == NULL)
+				continue;
+			notify->n_register(snd_pcm_devices[idx]);
+		}
+	}
+	up(&register_mutex);
+	return 0;
+}
+
+/*
+ *  Info interface
+ */
+
+static void snd_pcm_proc_read(snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+{
+	int idx;
+	snd_pcm_t *pcm;
+
+	down(&register_mutex);
+	for (idx = 0; idx < SNDRV_CARDS * SNDRV_PCM_DEVICES; idx++) {
+		pcm = snd_pcm_devices[idx];
+		if (pcm == NULL)
+			continue;
+		snd_iprintf(buffer, "%02i-%02i: %s : %s", idx / SNDRV_PCM_DEVICES,
+			    idx % SNDRV_PCM_DEVICES, pcm->id, pcm->name);
+		if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream)
+			snd_iprintf(buffer, " : playback %i", pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream_count);
+		if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream)
+			snd_iprintf(buffer, " : capture %i", pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream_count);
+		snd_iprintf(buffer, "\n");
+	}
+	up(&register_mutex);
+}
+
+/*
+ *  ENTRY functions
+ */
+
+static snd_info_entry_t *snd_pcm_proc_entry = NULL;
+
+static int __init alsa_pcm_init(void)
+{
+	snd_info_entry_t *entry;
+
+	snd_ctl_register_ioctl(snd_pcm_control_ioctl);
+	snd_ctl_register_ioctl_compat(snd_pcm_control_ioctl);
+	if ((entry = snd_info_create_module_entry(THIS_MODULE, "pcm", NULL)) != NULL) {
+		snd_info_set_text_ops(entry, NULL, SNDRV_CARDS * SNDRV_PCM_DEVICES * 128, snd_pcm_proc_read);
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	snd_pcm_proc_entry = entry;
+	return 0;
+}
+
+static void __exit alsa_pcm_exit(void)
+{
+	snd_ctl_unregister_ioctl(snd_pcm_control_ioctl);
+	snd_ctl_unregister_ioctl_compat(snd_pcm_control_ioctl);
+	if (snd_pcm_proc_entry) {
+		snd_info_unregister(snd_pcm_proc_entry);
+		snd_pcm_proc_entry = NULL;
+	}
+}
+
+module_init(alsa_pcm_init)
+module_exit(alsa_pcm_exit)
+
+EXPORT_SYMBOL(snd_pcm_devices);
+EXPORT_SYMBOL(snd_pcm_new);
+EXPORT_SYMBOL(snd_pcm_new_stream);
+EXPORT_SYMBOL(snd_pcm_notify);
+EXPORT_SYMBOL(snd_pcm_open_substream);
+EXPORT_SYMBOL(snd_pcm_release_substream);
+EXPORT_SYMBOL(snd_pcm_format_name);
+  /* pcm_native.c */
+EXPORT_SYMBOL(snd_pcm_link_rwlock);
+EXPORT_SYMBOL(snd_pcm_start);
+#ifdef CONFIG_PM
+EXPORT_SYMBOL(snd_pcm_suspend);
+EXPORT_SYMBOL(snd_pcm_suspend_all);
+#endif
+EXPORT_SYMBOL(snd_pcm_kernel_playback_ioctl);
+EXPORT_SYMBOL(snd_pcm_kernel_capture_ioctl);
+EXPORT_SYMBOL(snd_pcm_kernel_ioctl);
+EXPORT_SYMBOL(snd_pcm_mmap_data);
+#if SNDRV_PCM_INFO_MMAP_IOMEM
+EXPORT_SYMBOL(snd_pcm_lib_mmap_iomem);
+#endif
+ /* pcm_misc.c */
+EXPORT_SYMBOL(snd_pcm_format_signed);
+EXPORT_SYMBOL(snd_pcm_format_unsigned);
+EXPORT_SYMBOL(snd_pcm_format_linear);
+EXPORT_SYMBOL(snd_pcm_format_little_endian);
+EXPORT_SYMBOL(snd_pcm_format_big_endian);
+EXPORT_SYMBOL(snd_pcm_format_width);
+EXPORT_SYMBOL(snd_pcm_format_physical_width);
+EXPORT_SYMBOL(snd_pcm_format_silence_64);
+EXPORT_SYMBOL(snd_pcm_format_set_silence);
+EXPORT_SYMBOL(snd_pcm_build_linear_format);
+EXPORT_SYMBOL(snd_pcm_limit_hw_rates);
