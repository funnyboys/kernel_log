commit c5f72ef15cb89284b0d7b0c167d9a713bb3781e8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 6 17:39:41 2020 +0100

    ALSA: dummy: Use standard macros for fixing PCM format cast
    
    Simplify the code with the new macros for PCM format type iterations.
    This fixes the sparse warnings nicely:
      sound/drivers/dummy.c:906:25: warning: restricted snd_pcm_format_t degrades to integer
      sound/drivers/dummy.c:908:25: warning: incorrect type in argument 1 (different base types)
      sound/drivers/dummy.c:908:25:    expected restricted snd_pcm_format_t [usertype] format
      sound/drivers/dummy.c:908:25:    got int [assigned] i
    
    No functional changes, just sparse warning fixes.
    
    Link: https://lore.kernel.org/r/20200206163945.6797-5-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 02ac3f4e0c02..b5486de08b97 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -901,10 +901,10 @@ static int snd_card_dummy_new_mixer(struct snd_dummy *dummy)
 static void print_formats(struct snd_dummy *dummy,
 			  struct snd_info_buffer *buffer)
 {
-	int i;
+	snd_pcm_format_t i;
 
-	for (i = 0; i <= SNDRV_PCM_FORMAT_LAST; i++) {
-		if (dummy->pcm_hw.formats & (1ULL << i))
+	pcm_for_each_format(i) {
+		if (dummy->pcm_hw.formats & pcm_format_to_bits(i))
 			snd_iprintf(buffer, " %s", snd_pcm_format_name(i));
 	}
 }

commit 2acf25f13ebe8beb40e97a1bbe76f36277c64f1e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat Feb 1 09:05:30 2020 +0100

    ALSA: dummy: Fix PCM format loop in proc output
    
    The loop termination for iterating over all formats should contain
    SNDRV_PCM_FORMAT_LAST, not less than it.
    
    Fixes: 9b151fec139d ("ALSA: dummy - Add debug proc file")
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200201080530.22390-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index da0bd8960b3c..02ac3f4e0c02 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -903,7 +903,7 @@ static void print_formats(struct snd_dummy *dummy,
 {
 	int i;
 
-	for (i = 0; i < SNDRV_PCM_FORMAT_LAST; i++) {
+	for (i = 0; i <= SNDRV_PCM_FORMAT_LAST; i++) {
 		if (dummy->pcm_hw.formats & (1ULL << i))
 			snd_iprintf(buffer, " %s", snd_pcm_format_name(i));
 	}

commit d64e7f7c9e70c587ce9fcc2eacd0cd7c29bcf91c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:19 2020 +0100

    ALSA: dummy: More constifications
    
    Apply const prefix to every possible place: mostly for declaring the
    dummy hardware models.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-5-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 46fa60e7f722..da0bd8960b3c 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -117,7 +117,7 @@ struct dummy_model {
 
 struct snd_dummy {
 	struct snd_card *card;
-	struct dummy_model *model;
+	const struct dummy_model *model;
 	struct snd_pcm *pcm;
 	struct snd_pcm_hardware pcm_hw;
 	spinlock_t mixer_lock;
@@ -144,13 +144,13 @@ static int emu10k1_playback_constraints(struct snd_pcm_runtime *runtime)
 	return 0;
 }
 
-static struct dummy_model model_emu10k1 = {
+static const struct dummy_model model_emu10k1 = {
 	.name = "emu10k1",
 	.playback_constraints = emu10k1_playback_constraints,
 	.buffer_bytes_max = 128 * 1024,
 };
 
-static struct dummy_model model_rme9652 = {
+static const struct dummy_model model_rme9652 = {
 	.name = "rme9652",
 	.buffer_bytes_max = 26 * 64 * 1024,
 	.formats = SNDRV_PCM_FMTBIT_S32_LE,
@@ -160,7 +160,7 @@ static struct dummy_model model_rme9652 = {
 	.periods_max = 2,
 };
 
-static struct dummy_model model_ice1712 = {
+static const struct dummy_model model_ice1712 = {
 	.name = "ice1712",
 	.buffer_bytes_max = 256 * 1024,
 	.formats = SNDRV_PCM_FMTBIT_S32_LE,
@@ -170,7 +170,7 @@ static struct dummy_model model_ice1712 = {
 	.periods_max = 1024,
 };
 
-static struct dummy_model model_uda1341 = {
+static const struct dummy_model model_uda1341 = {
 	.name = "uda1341",
 	.buffer_bytes_max = 16380,
 	.formats = SNDRV_PCM_FMTBIT_S16_LE,
@@ -180,7 +180,7 @@ static struct dummy_model model_uda1341 = {
 	.periods_max = 255,
 };
 
-static struct dummy_model model_ac97 = {
+static const struct dummy_model model_ac97 = {
 	.name = "ac97",
 	.formats = SNDRV_PCM_FMTBIT_S16_LE,
 	.channels_min = 2,
@@ -190,7 +190,7 @@ static struct dummy_model model_ac97 = {
 	.rate_max = 48000,
 };
 
-static struct dummy_model model_ca0106 = {
+static const struct dummy_model model_ca0106 = {
 	.name = "ca0106",
 	.formats = SNDRV_PCM_FMTBIT_S16_LE,
 	.buffer_bytes_max = ((65536-64)*8),
@@ -204,7 +204,7 @@ static struct dummy_model model_ca0106 = {
 	.rate_max = 192000,
 };
 
-static struct dummy_model *dummy_models[] = {
+static const struct dummy_model *dummy_models[] = {
 	&model_emu10k1,
 	&model_rme9652,
 	&model_ice1712,
@@ -535,7 +535,7 @@ static int dummy_pcm_hw_params(struct snd_pcm_substream *substream,
 static int dummy_pcm_open(struct snd_pcm_substream *substream)
 {
 	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
-	struct dummy_model *model = dummy->model;
+	const struct dummy_model *model = dummy->model;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	const struct dummy_timer_ops *ops;
 	int err;
@@ -912,7 +912,7 @@ static void print_formats(struct snd_dummy *dummy,
 static void print_rates(struct snd_dummy *dummy,
 			struct snd_info_buffer *buffer)
 {
-	static int rates[] = {
+	static const int rates[] = {
 		5512, 8000, 11025, 16000, 22050, 32000, 44100, 48000,
 		64000, 88200, 96000, 176400, 192000,
 	};
@@ -944,7 +944,7 @@ struct dummy_hw_field {
 	.offset = offsetof(struct snd_pcm_hardware, item), \
 	.size = sizeof(dummy_pcm_hardware.item) }
 
-static struct dummy_hw_field fields[] = {
+static const struct dummy_hw_field fields[] = {
 	FIELD_ENTRY(formats, "%#llx"),
 	FIELD_ENTRY(rates, "%#x"),
 	FIELD_ENTRY(rate_min, "%d"),
@@ -1022,7 +1022,7 @@ static int snd_dummy_probe(struct platform_device *devptr)
 {
 	struct snd_card *card;
 	struct snd_dummy *dummy;
-	struct dummy_model *m = NULL, **mdl;
+	const struct dummy_model *m = NULL, **mdl;
 	int idx, err;
 	int dev = devptr->id;
 

commit 1da7f0c570d7356f232aee6528ccf8b2dcd96dcf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:59 2020 +0100

    ALSA: dummy: Constify snd_pcm_ops definitions
    
    The snd_pcm_ops items defined in snd-dummy driver can be gracefully
    declared as const.  Let's mark them for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-44-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index cec682a7b88d..46fa60e7f722 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -644,7 +644,7 @@ static struct page *dummy_pcm_page(struct snd_pcm_substream *substream,
 	return virt_to_page(dummy_page[substream->stream]); /* the same page */
 }
 
-static struct snd_pcm_ops dummy_pcm_ops = {
+static const struct snd_pcm_ops dummy_pcm_ops = {
 	.open =		dummy_pcm_open,
 	.close =	dummy_pcm_close,
 	.hw_params =	dummy_pcm_hw_params,
@@ -653,7 +653,7 @@ static struct snd_pcm_ops dummy_pcm_ops = {
 	.pointer =	dummy_pcm_pointer,
 };
 
-static struct snd_pcm_ops dummy_pcm_ops_no_buf = {
+static const struct snd_pcm_ops dummy_pcm_ops_no_buf = {
 	.open =		dummy_pcm_open,
 	.close =	dummy_pcm_close,
 	.hw_params =	dummy_pcm_hw_params,
@@ -670,7 +670,7 @@ static int snd_card_dummy_pcm(struct snd_dummy *dummy, int device,
 			      int substreams)
 {
 	struct snd_pcm *pcm;
-	struct snd_pcm_ops *ops;
+	const struct snd_pcm_ops *ops;
 	int err;
 
 	err = snd_pcm_new(dummy->card, "Dummy PCM", device,

commit 2eccd408037449ac6c1ceba1d74bd10c67dc13d7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:49 2020 +0100

    ALSA: drivers: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    Constify snd_kcontrol_new items
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-34-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index cef5b391cc44..cec682a7b88d 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -849,7 +849,7 @@ static int snd_dummy_iobox_put(struct snd_kcontrol *kcontrol,
 	return changed;
 }
 
-static struct snd_kcontrol_new snd_dummy_controls[] = {
+static const struct snd_kcontrol_new snd_dummy_controls[] = {
 DUMMY_VOLUME("Master Volume", 0, MIXER_ADDR_MASTER),
 DUMMY_CAPSRC("Master Capture Switch", 0, MIXER_ADDR_MASTER),
 DUMMY_VOLUME("Synth Volume", 0, MIXER_ADDR_SYNTH),

commit ae531486d77061fcc227455c8bcdcc278350b0c4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:26 2019 +0100

    ALSA: drivers: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-5-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index ab6062dcd1b3..cef5b391cc44 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -647,7 +647,6 @@ static struct page *dummy_pcm_page(struct snd_pcm_substream *substream,
 static struct snd_pcm_ops dummy_pcm_ops = {
 	.open =		dummy_pcm_open,
 	.close =	dummy_pcm_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	dummy_pcm_hw_params,
 	.prepare =	dummy_pcm_prepare,
 	.trigger =	dummy_pcm_trigger,
@@ -657,7 +656,6 @@ static struct snd_pcm_ops dummy_pcm_ops = {
 static struct snd_pcm_ops dummy_pcm_ops_no_buf = {
 	.open =		dummy_pcm_open,
 	.close =	dummy_pcm_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	dummy_pcm_hw_params,
 	.prepare =	dummy_pcm_prepare,
 	.trigger =	dummy_pcm_trigger,

commit ef1545b8f35e230e7e7aae7d01647d151fd8e87a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:48:37 2019 +0100

    ALSA: dummy: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The hw_free callback became superfluous and got dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-6-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 022a0db692e0..ab6062dcd1b3 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -529,15 +529,7 @@ static int dummy_pcm_hw_params(struct snd_pcm_substream *substream,
 		substream->runtime->dma_bytes = params_buffer_bytes(hw_params);
 		return 0;
 	}
-	return snd_pcm_lib_malloc_pages(substream,
-					params_buffer_bytes(hw_params));
-}
-
-static int dummy_pcm_hw_free(struct snd_pcm_substream *substream)
-{
-	if (fake_buffer)
-		return 0;
-	return snd_pcm_lib_free_pages(substream);
+	return 0;
 }
 
 static int dummy_pcm_open(struct snd_pcm_substream *substream)
@@ -657,7 +649,6 @@ static struct snd_pcm_ops dummy_pcm_ops = {
 	.close =	dummy_pcm_close,
 	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	dummy_pcm_hw_params,
-	.hw_free =	dummy_pcm_hw_free,
 	.prepare =	dummy_pcm_prepare,
 	.trigger =	dummy_pcm_trigger,
 	.pointer =	dummy_pcm_pointer,
@@ -668,7 +659,6 @@ static struct snd_pcm_ops dummy_pcm_ops_no_buf = {
 	.close =	dummy_pcm_close,
 	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	dummy_pcm_hw_params,
-	.hw_free =	dummy_pcm_hw_free,
 	.prepare =	dummy_pcm_prepare,
 	.trigger =	dummy_pcm_trigger,
 	.pointer =	dummy_pcm_pointer,
@@ -700,7 +690,7 @@ static int snd_card_dummy_pcm(struct snd_dummy *dummy, int device,
 	pcm->info_flags = 0;
 	strcpy(pcm->name, "Dummy PCM");
 	if (!fake_buffer) {
-		snd_pcm_lib_preallocate_pages_for_all(pcm,
+		snd_pcm_set_managed_buffer_all(pcm,
 			SNDRV_DMA_TYPE_CONTINUOUS,
 			NULL,
 			0, 64*1024);

commit 8fd9da750e76c321cd0a781c89a0d70cc399b22d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:33 2019 +0100

    ALSA: drivers: Remove superfluous snd_dma_continuous_data()
    
    The recent change (commit 08422d2c559d: "ALSA: memalloc: Allow NULL
    device for SNDRV_DMA_TYPE_CONTINUOUS type") made the PCM preallocation
    helper accepting NULL as the device pointer for the default usage.
    Drop the snd_dma_continuous_data() usage that became superfluous from
    the callers.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-2-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index aee7c04d49e5..022a0db692e0 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -702,7 +702,7 @@ static int snd_card_dummy_pcm(struct snd_dummy *dummy, int device,
 	if (!fake_buffer) {
 		snd_pcm_lib_preallocate_pages_for_all(pcm,
 			SNDRV_DMA_TYPE_CONTINUOUS,
-			snd_dma_continuous_data(GFP_KERNEL),
+			NULL,
 			0, 64*1024);
 	}
 	return 0;

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 2672c2e13334..aee7c04d49e5 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -1,21 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Dummy soundcard
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/init.h>

commit 815d808c7bfc91edbf25813cea54709f4a805c71
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 15:58:33 2019 +0100

    ALSA: drivers: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index c8d31550e9a1..2672c2e13334 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -1037,14 +1037,8 @@ static void dummy_proc_write(struct snd_info_entry *entry,
 
 static void dummy_proc_init(struct snd_dummy *chip)
 {
-	struct snd_info_entry *entry;
-
-	if (!snd_card_proc_new(chip->card, "dummy_pcm", &entry)) {
-		snd_info_set_text_ops(entry, chip, dummy_proc_read);
-		entry->c.text.write = dummy_proc_write;
-		entry->mode |= 0200;
-		entry->private_data = chip;
-	}
+	snd_card_rw_proc_new(chip->card, "dummy_pcm", chip,
+			     dummy_proc_read, dummy_proc_write);
 }
 #else
 #define dummy_proc_init(x)

commit 3c40dfeb044943d2323d39c7348c910746a81add
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:02:20 2019 +0100

    ALSA: drivers: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 9af154db530a..c8d31550e9a1 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -1138,10 +1138,8 @@ static int snd_dummy_remove(struct platform_device *devptr)
 static int snd_dummy_suspend(struct device *pdev)
 {
 	struct snd_card *card = dev_get_drvdata(pdev);
-	struct snd_dummy *dummy = card->private_data;
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
-	snd_pcm_suspend_all(dummy->pcm);
 	return 0;
 }
 	

commit 6a73cf46ce9d1b382ea14d74ce4bc9aa0c52337a
Author: Joe Perches <joe@perches.com>
Date:   Wed May 23 12:20:59 2018 -0700

    sound: Use octal not symbolic permissions
    
    Convert the S_<FOO> symbolic permissions to their octal equivalents as
    using octal and not symbolic permissions is preferred by many as more
    readable.
    
    see: https://lkml.org/lkml/2016/8/2/1945
    
    Done with automated conversion via:
    $ ./scripts/checkpatch.pl -f --types=SYMBOLIC_PERMS --fix-inplace <files...>
    
    Miscellanea:
    
    o Wrapped one multi-line call to a single line
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 8fb9a54fe8ba..9af154db530a 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -1042,7 +1042,7 @@ static void dummy_proc_init(struct snd_dummy *chip)
 	if (!snd_card_proc_new(chip->card, "dummy_pcm", &entry)) {
 		snd_info_set_text_ops(entry, chip, dummy_proc_read);
 		entry->c.text.write = dummy_proc_write;
-		entry->mode |= S_IWUSR;
+		entry->mode |= 0200;
 		entry->private_data = chip;
 	}
 }

commit a46d3f9b1c9888a244ed1ce8da0eca98c3f378e2
Merge: 7bcd34259466 303c146df1c4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 29 16:50:58 2018 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The timer departement presents:
    
       - A rather large rework of the hrtimer infrastructure which
         introduces softirq based hrtimers to replace the spread of
         hrtimer/tasklet combos which force the actual callback execution
         into softirq context. The approach is completely different from the
         initial implementation which you cursed at 10 years ago rightfully.
    
         The softirq based timers have their own queues and there is no
         nasty indirection and list reshuffling in the hard interrupt
         anymore. This comes with conversion of some of the hrtimer/tasklet
         users, the rest and the final removal of that horrible interface
         will come towards the end of the merge window or go through the
         relevant maintainer trees.
    
         Note: The top commit merged the last minute bugfix for the 10 years
         old CPU hotplug bug as I wanted to make sure that I fatfinger the
         merge conflict resolution myself.
    
       - The overhaul of the STM32 clocksource/clockevents driver
    
       - A new driver for the Spreadtrum SC9860 timer
    
       - A new driver dor the Actions Semi S700 timer
    
       - The usual set of fixes and updates all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (53 commits)
      usb/gadget/NCM: Replace tasklet with softirq hrtimer
      ALSA/dummy: Replace tasklet with softirq hrtimer
      hrtimer: Implement SOFT/HARD clock base selection
      hrtimer: Implement support for softirq based hrtimers
      hrtimer: Prepare handling of hard and softirq based hrtimers
      hrtimer: Add clock bases and hrtimer mode for softirq context
      hrtimer: Use irqsave/irqrestore around __run_hrtimer()
      hrtimer: Factor out __hrtimer_next_event_base()
      hrtimer: Factor out __hrtimer_start_range_ns()
      hrtimer: Remove the 'base' parameter from hrtimer_reprogram()
      hrtimer: Make remote enqueue decision less restrictive
      hrtimer: Unify remote enqueue handling
      hrtimer: Unify hrtimer removal handling
      hrtimer: Make hrtimer_force_reprogramm() unconditionally available
      hrtimer: Make hrtimer_reprogramm() unconditional
      hrtimer: Make hrtimer_cpu_base.next_timer handling unconditional
      hrtimer: Make the remote enqueue check unconditional
      hrtimer: Use accesor functions instead of direct access
      hrtimer: Make the hrtimer_cpu_base::hres_active field unconditional, to simplify the code
      hrtimer: Make room in 'struct hrtimer_cpu_base'
      ...

commit b03bbbe08ff04d80136b6aac152954ef308a4909
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 21 11:42:03 2017 +0100

    ALSA/dummy: Replace tasklet with softirq hrtimer
    
    The tasklet is used to defer the execution of snd_pcm_period_elapsed() to
    the softirq context. Using the HRTIMER_MODE_SOFT mode invokes the timer
    callback in softirq context as well which renders the tasklet useless.
    
    [o-takashi: avoid stall due to a call of hrtimer_cancel() on a callback of hrtimer]
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Takashi Iwai <tiwai@suse.com>
    Cc: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Cc: alsa-devel@alsa-project.org
    Cc: keescook@chromium.org
    Link: http://lkml.kernel.org/r/20171221104205.7269-35-anna-maria@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 7b2b1f766b00..6ad2ff57833d 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -375,17 +375,9 @@ struct dummy_hrtimer_pcm {
 	ktime_t period_time;
 	atomic_t running;
 	struct hrtimer timer;
-	struct tasklet_struct tasklet;
 	struct snd_pcm_substream *substream;
 };
 
-static void dummy_hrtimer_pcm_elapsed(unsigned long priv)
-{
-	struct dummy_hrtimer_pcm *dpcm = (struct dummy_hrtimer_pcm *)priv;
-	if (atomic_read(&dpcm->running))
-		snd_pcm_period_elapsed(dpcm->substream);
-}
-
 static enum hrtimer_restart dummy_hrtimer_callback(struct hrtimer *timer)
 {
 	struct dummy_hrtimer_pcm *dpcm;
@@ -393,7 +385,14 @@ static enum hrtimer_restart dummy_hrtimer_callback(struct hrtimer *timer)
 	dpcm = container_of(timer, struct dummy_hrtimer_pcm, timer);
 	if (!atomic_read(&dpcm->running))
 		return HRTIMER_NORESTART;
-	tasklet_schedule(&dpcm->tasklet);
+	/*
+	 * In cases of XRUN and draining, this calls .trigger to stop PCM
+	 * substream.
+	 */
+	snd_pcm_period_elapsed(dpcm->substream);
+	if (!atomic_read(&dpcm->running))
+		return HRTIMER_NORESTART;
+
 	hrtimer_forward_now(timer, dpcm->period_time);
 	return HRTIMER_RESTART;
 }
@@ -403,7 +402,7 @@ static int dummy_hrtimer_start(struct snd_pcm_substream *substream)
 	struct dummy_hrtimer_pcm *dpcm = substream->runtime->private_data;
 
 	dpcm->base_time = hrtimer_cb_get_time(&dpcm->timer);
-	hrtimer_start(&dpcm->timer, dpcm->period_time, HRTIMER_MODE_REL);
+	hrtimer_start(&dpcm->timer, dpcm->period_time, HRTIMER_MODE_REL_SOFT);
 	atomic_set(&dpcm->running, 1);
 	return 0;
 }
@@ -413,14 +412,14 @@ static int dummy_hrtimer_stop(struct snd_pcm_substream *substream)
 	struct dummy_hrtimer_pcm *dpcm = substream->runtime->private_data;
 
 	atomic_set(&dpcm->running, 0);
-	hrtimer_cancel(&dpcm->timer);
+	if (!hrtimer_callback_running(&dpcm->timer))
+		hrtimer_cancel(&dpcm->timer);
 	return 0;
 }
 
 static inline void dummy_hrtimer_sync(struct dummy_hrtimer_pcm *dpcm)
 {
 	hrtimer_cancel(&dpcm->timer);
-	tasklet_kill(&dpcm->tasklet);
 }
 
 static snd_pcm_uframes_t
@@ -465,12 +464,10 @@ static int dummy_hrtimer_create(struct snd_pcm_substream *substream)
 	if (!dpcm)
 		return -ENOMEM;
 	substream->runtime->private_data = dpcm;
-	hrtimer_init(&dpcm->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	hrtimer_init(&dpcm->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_SOFT);
 	dpcm->timer.function = dummy_hrtimer_callback;
 	dpcm->substream = substream;
 	atomic_set(&dpcm->running, 0);
-	tasklet_init(&dpcm->tasklet, dummy_hrtimer_pcm_elapsed,
-		     (unsigned long)dpcm);
 	return 0;
 }
 

commit a4a1b737032daf42e1e2ccd70bfceca56464ccac
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Nov 27 12:58:51 2017 +0000

    ALSA: drivers: make array 'names' const, reduces object code size
    
    Don't populate array 'names' on the stack but instead make them static.
    Makes the object code smaller by 50 bytes:
    
    Before:
       text    data     bss     dec     hex filename
      21237    9192    1120   31549    7b3d linux/sound/drivers/dummy.o
    
    After:
       text    data     bss     dec     hex filename
      21095    9280    1120   31495    7b07 linux/sound/drivers/dummy.o
    
    (gcc version 7.2.0 x86_64)
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 7b2b1f766b00..69db45bc0197 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -830,7 +830,7 @@ static int snd_dummy_capsrc_put(struct snd_kcontrol *kcontrol, struct snd_ctl_el
 static int snd_dummy_iobox_info(struct snd_kcontrol *kcontrol,
 				struct snd_ctl_elem_info *info)
 {
-	const char *const names[] = { "None", "CD Player" };
+	static const char *const names[] = { "None", "CD Player" };
 
 	return snd_ctl_enum_info(info, 1, 2, names);
 }

commit bc47ba90b01afe468cdd586b0dbe59b64862e2b7
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 24 08:34:29 2017 -0700

    ALSA: drivers: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index c0939a0164a6..7b2b1f766b00 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -306,9 +306,9 @@ static int dummy_systimer_prepare(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static void dummy_systimer_callback(unsigned long data)
+static void dummy_systimer_callback(struct timer_list *t)
 {
-	struct dummy_systimer_pcm *dpcm = (struct dummy_systimer_pcm *)data;
+	struct dummy_systimer_pcm *dpcm = from_timer(dpcm, t, timer);
 	unsigned long flags;
 	int elapsed = 0;
 	
@@ -343,8 +343,7 @@ static int dummy_systimer_create(struct snd_pcm_substream *substream)
 	if (!dpcm)
 		return -ENOMEM;
 	substream->runtime->private_data = dpcm;
-	setup_timer(&dpcm->timer, dummy_systimer_callback,
-			(unsigned long) dpcm);
+	timer_setup(&dpcm->timer, dummy_systimer_callback, 0);
 	spin_lock_init(&dpcm->lock);
 	dpcm->substream = substream;
 	return 0;

commit b6c0b7156167b8a0f82576adaaa9d7287296bbfc
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Thu Aug 17 14:45:51 2017 +0530

    ALSA: drivers: make snd_pcm_hardware const
    
    Make these const as they are only used in a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index dd5ed037adf2..c0939a0164a6 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -520,7 +520,7 @@ static snd_pcm_uframes_t dummy_pcm_pointer(struct snd_pcm_substream *substream)
 	return get_dummy_ops(substream)->pointer(substream);
 }
 
-static struct snd_pcm_hardware dummy_pcm_hardware = {
+static const struct snd_pcm_hardware dummy_pcm_hardware = {
 	.info =			(SNDRV_PCM_INFO_MMAP |
 				 SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_RESUME |

commit d53611d21ef6000619e87f6cfc1f6d870c10cd93
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 10 20:15:40 2017 +0200

    ALSA: dummy: Convert to new PCM copy ops
    
    It's a dummy ops, so just replacing it.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 172dacd925f5..dd5ed037adf2 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -644,15 +644,22 @@ static int alloc_fake_buffer(void)
 }
 
 static int dummy_pcm_copy(struct snd_pcm_substream *substream,
-			  int channel, snd_pcm_uframes_t pos,
-			  void __user *dst, snd_pcm_uframes_t count)
+			  int channel, unsigned long pos,
+			  void __user *dst, unsigned long bytes)
+{
+	return 0; /* do nothing */
+}
+
+static int dummy_pcm_copy_kernel(struct snd_pcm_substream *substream,
+				 int channel, unsigned long pos,
+				 void *dst, unsigned long bytes)
 {
 	return 0; /* do nothing */
 }
 
 static int dummy_pcm_silence(struct snd_pcm_substream *substream,
-			     int channel, snd_pcm_uframes_t pos,
-			     snd_pcm_uframes_t count)
+			     int channel, unsigned long pos,
+			     unsigned long bytes)
 {
 	return 0; /* do nothing */
 }
@@ -683,8 +690,9 @@ static struct snd_pcm_ops dummy_pcm_ops_no_buf = {
 	.prepare =	dummy_pcm_prepare,
 	.trigger =	dummy_pcm_trigger,
 	.pointer =	dummy_pcm_pointer,
-	.copy =		dummy_pcm_copy,
-	.silence =	dummy_pcm_silence,
+	.copy_user =	dummy_pcm_copy,
+	.copy_kernel =	dummy_pcm_copy_kernel,
+	.fill_silence =	dummy_pcm_silence,
 	.page =		dummy_pcm_page,
 };
 

commit d5dbbe6569481bf12dcbe3e12cff72c5f78d272c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 24 15:15:26 2016 +0200

    ALSA: dummy: Fix a use-after-free at closing
    
    syzkaller fuzzer spotted a potential use-after-free case in snd-dummy
    driver when hrtimer is used as backend:
    > ==================================================================
    > BUG: KASAN: use-after-free in rb_erase+0x1b17/0x2010 at addr ffff88005e5b6f68
    >  Read of size 8 by task syz-executor/8984
    > =============================================================================
    > BUG kmalloc-192 (Not tainted): kasan: bad access detected
    > -----------------------------------------------------------------------------
    >
    > Disabling lock debugging due to kernel taint
    > INFO: Allocated in 0xbbbbbbbbbbbbbbbb age=18446705582212484632
    > ....
    > [<      none      >] dummy_hrtimer_create+0x49/0x1a0 sound/drivers/dummy.c:464
    > ....
    > INFO: Freed in 0xfffd8e09 age=18446705496313138713 cpu=2164287125 pid=-1
    > [<      none      >] dummy_hrtimer_free+0x68/0x80 sound/drivers/dummy.c:481
    > ....
    > Call Trace:
    >  [<ffffffff8179e59e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:333
    >  [<     inline     >] rb_set_parent include/linux/rbtree_augmented.h:111
    >  [<     inline     >] __rb_erase_augmented include/linux/rbtree_augmented.h:218
    >  [<ffffffff82ca5787>] rb_erase+0x1b17/0x2010 lib/rbtree.c:427
    >  [<ffffffff82cb02e8>] timerqueue_del+0x78/0x170 lib/timerqueue.c:86
    >  [<ffffffff814d0c80>] __remove_hrtimer+0x90/0x220 kernel/time/hrtimer.c:903
    >  [<     inline     >] remove_hrtimer kernel/time/hrtimer.c:945
    >  [<ffffffff814d23da>] hrtimer_try_to_cancel+0x22a/0x570 kernel/time/hrtimer.c:1046
    >  [<ffffffff814d2742>] hrtimer_cancel+0x22/0x40 kernel/time/hrtimer.c:1066
    >  [<ffffffff85420531>] dummy_hrtimer_stop+0x91/0xb0 sound/drivers/dummy.c:417
    >  [<ffffffff854228bf>] dummy_pcm_trigger+0x17f/0x1e0 sound/drivers/dummy.c:507
    >  [<ffffffff85392170>] snd_pcm_do_stop+0x160/0x1b0 sound/core/pcm_native.c:1106
    >  [<ffffffff85391b26>] snd_pcm_action_single+0x76/0x120 sound/core/pcm_native.c:956
    >  [<ffffffff85391e01>] snd_pcm_action+0x231/0x290 sound/core/pcm_native.c:974
    >  [<     inline     >] snd_pcm_stop sound/core/pcm_native.c:1139
    >  [<ffffffff8539754d>] snd_pcm_drop+0x12d/0x1d0 sound/core/pcm_native.c:1784
    >  [<ffffffff8539d3be>] snd_pcm_common_ioctl1+0xfae/0x2150 sound/core/pcm_native.c:2805
    >  [<ffffffff8539ee91>] snd_pcm_capture_ioctl1+0x2a1/0x5e0 sound/core/pcm_native.c:2976
    >  [<ffffffff8539f2ec>] snd_pcm_kernel_ioctl+0x11c/0x160 sound/core/pcm_native.c:3020
    >  [<ffffffff853d9a44>] snd_pcm_oss_sync+0x3a4/0xa30 sound/core/oss/pcm_oss.c:1693
    >  [<ffffffff853da27d>] snd_pcm_oss_release+0x1ad/0x280 sound/core/oss/pcm_oss.c:2483
    >  .....
    
    A workaround is to call hrtimer_cancel() in dummy_hrtimer_sync() which
    is called certainly before other blocking ops.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index c0f8f613f1f1..172dacd925f5 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -420,6 +420,7 @@ static int dummy_hrtimer_stop(struct snd_pcm_substream *substream)
 
 static inline void dummy_hrtimer_sync(struct dummy_hrtimer_pcm *dpcm)
 {
+	hrtimer_cancel(&dpcm->timer);
 	tasklet_kill(&dpcm->tasklet);
 }
 

commit ddce57a6f0a2d8d1bfacfa77f06043bc760403c2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 2 15:27:36 2016 +0100

    ALSA: dummy: Implement timer backend switching more safely
    
    Currently the selected timer backend is referred at any moment from
    the running PCM callbacks.  When the backend is switched, it's
    possible to lead to inconsistency from the running backend.  This was
    pointed by syzkaller fuzzer, and the commit [7ee96216c31a: ALSA:
    dummy: Disable switching timer backend via sysfs] disabled the dynamic
    switching for avoiding the crash.
    
    This patch improves the handling of timer backend switching.  It keeps
    the reference to the selected backend during the whole operation of an
    opened stream so that it won't be changed by other streams.
    
    Together with this change, the hrtimer parameter is reenabled as
    writable now.
    
    NOTE: this patch also turned out to fix the still remaining race.
    Namely, ops was still replaced dynamically at dummy_pcm_open:
    
      static int dummy_pcm_open(struct snd_pcm_substream *substream)
      {
      ....
              dummy->timer_ops = &dummy_systimer_ops;
              if (hrtimer)
                      dummy->timer_ops = &dummy_hrtimer_ops;
    
    Since dummy->timer_ops is common among all streams, and when the
    replacement happens during accesses of other streams, it may lead to a
    crash.  This was actually triggered by syzkaller fuzzer and KASAN.
    
    This patch rewrites the code not to use the ops shared by all streams
    any longer, too.
    
    BugLink: http://lkml.kernel.org/r/CACT4Y+aZ+xisrpuM6cOXbL21DuM0yVxPYXf4cD4Md9uw0C3dBQ@mail.gmail.com
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index bde33308f0d6..c0f8f613f1f1 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -87,7 +87,7 @@ MODULE_PARM_DESC(pcm_substreams, "PCM substreams # (1-128) for dummy driver.");
 module_param(fake_buffer, bool, 0444);
 MODULE_PARM_DESC(fake_buffer, "Fake buffer allocations.");
 #ifdef CONFIG_HIGH_RES_TIMERS
-module_param(hrtimer, bool, 0444);
+module_param(hrtimer, bool, 0644);
 MODULE_PARM_DESC(hrtimer, "Use hrtimer as the timer source.");
 #endif
 
@@ -109,6 +109,9 @@ struct dummy_timer_ops {
 	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *);
 };
 
+#define get_dummy_ops(substream) \
+	(*(const struct dummy_timer_ops **)(substream)->runtime->private_data)
+
 struct dummy_model {
 	const char *name;
 	int (*playback_constraints)(struct snd_pcm_runtime *runtime);
@@ -137,7 +140,6 @@ struct snd_dummy {
 	int iobox;
 	struct snd_kcontrol *cd_volume_ctl;
 	struct snd_kcontrol *cd_switch_ctl;
-	const struct dummy_timer_ops *timer_ops;
 };
 
 /*
@@ -231,6 +233,8 @@ static struct dummy_model *dummy_models[] = {
  */
 
 struct dummy_systimer_pcm {
+	/* ops must be the first item */
+	const struct dummy_timer_ops *timer_ops;
 	spinlock_t lock;
 	struct timer_list timer;
 	unsigned long base_time;
@@ -366,6 +370,8 @@ static const struct dummy_timer_ops dummy_systimer_ops = {
  */
 
 struct dummy_hrtimer_pcm {
+	/* ops must be the first item */
+	const struct dummy_timer_ops *timer_ops;
 	ktime_t base_time;
 	ktime_t period_time;
 	atomic_t running;
@@ -492,31 +498,25 @@ static const struct dummy_timer_ops dummy_hrtimer_ops = {
 
 static int dummy_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
-
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
-		return dummy->timer_ops->start(substream);
+		return get_dummy_ops(substream)->start(substream);
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
-		return dummy->timer_ops->stop(substream);
+		return get_dummy_ops(substream)->stop(substream);
 	}
 	return -EINVAL;
 }
 
 static int dummy_pcm_prepare(struct snd_pcm_substream *substream)
 {
-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
-
-	return dummy->timer_ops->prepare(substream);
+	return get_dummy_ops(substream)->prepare(substream);
 }
 
 static snd_pcm_uframes_t dummy_pcm_pointer(struct snd_pcm_substream *substream)
 {
-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
-
-	return dummy->timer_ops->pointer(substream);
+	return get_dummy_ops(substream)->pointer(substream);
 }
 
 static struct snd_pcm_hardware dummy_pcm_hardware = {
@@ -562,17 +562,19 @@ static int dummy_pcm_open(struct snd_pcm_substream *substream)
 	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
 	struct dummy_model *model = dummy->model;
 	struct snd_pcm_runtime *runtime = substream->runtime;
+	const struct dummy_timer_ops *ops;
 	int err;
 
-	dummy->timer_ops = &dummy_systimer_ops;
+	ops = &dummy_systimer_ops;
 #ifdef CONFIG_HIGH_RES_TIMERS
 	if (hrtimer)
-		dummy->timer_ops = &dummy_hrtimer_ops;
+		ops = &dummy_hrtimer_ops;
 #endif
 
-	err = dummy->timer_ops->create(substream);
+	err = ops->create(substream);
 	if (err < 0)
 		return err;
+	get_dummy_ops(substream) = ops;
 
 	runtime->hw = dummy->pcm_hw;
 	if (substream->pcm->device & 1) {
@@ -594,7 +596,7 @@ static int dummy_pcm_open(struct snd_pcm_substream *substream)
 			err = model->capture_constraints(substream->runtime);
 	}
 	if (err < 0) {
-		dummy->timer_ops->free(substream);
+		get_dummy_ops(substream)->free(substream);
 		return err;
 	}
 	return 0;
@@ -602,8 +604,7 @@ static int dummy_pcm_open(struct snd_pcm_substream *substream)
 
 static int dummy_pcm_close(struct snd_pcm_substream *substream)
 {
-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
-	dummy->timer_ops->free(substream);
+	get_dummy_ops(substream)->free(substream);
 	return 0;
 }
 

commit 7ee96216c31aabe1eb42fb91ff50dae9fcd014b2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 28 07:54:16 2016 +0100

    ALSA: dummy: Disable switching timer backend via sysfs
    
    ALSA dummy driver can switch the timer backend between system timer
    and hrtimer via its hrtimer module option.  This can be also switched
    dynamically via sysfs, but it may lead to a memory corruption when
    switching is done while a PCM stream is running; the stream instance
    for the newly switched timer method tries to access the memory that
    was allocated by another timer method although the sizes differ.
    
    As the simplest fix, this patch just disables the switch via sysfs by
    dropping the writable bit.
    
    BugLink: http://lkml.kernel.org/r/CACT4Y+ZGEeEBntHW5WHn2GoeE0G_kRrCmUh6=dWyy-wfzvuJLg@mail.gmail.com
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 75b74850c005..bde33308f0d6 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -87,7 +87,7 @@ MODULE_PARM_DESC(pcm_substreams, "PCM substreams # (1-128) for dummy driver.");
 module_param(fake_buffer, bool, 0444);
 MODULE_PARM_DESC(fake_buffer, "Fake buffer allocations.");
 #ifdef CONFIG_HIGH_RES_TIMERS
-module_param(hrtimer, bool, 0644);
+module_param(hrtimer, bool, 0444);
 MODULE_PARM_DESC(hrtimer, "Use hrtimer as the timer source.");
 #endif
 

commit d8c5ed752e5b9aabad9ea8b53272b6abb4fa5235
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Wed Dec 30 12:28:49 2015 +0100

    ALSA: dummy: constify dummy_timer_ops structures
    
    The dummy_timer_ops structures are never modified, so declare them as
    const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 016e451ed506..75b74850c005 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -351,7 +351,7 @@ static void dummy_systimer_free(struct snd_pcm_substream *substream)
 	kfree(substream->runtime->private_data);
 }
 
-static struct dummy_timer_ops dummy_systimer_ops = {
+static const struct dummy_timer_ops dummy_systimer_ops = {
 	.create =	dummy_systimer_create,
 	.free =		dummy_systimer_free,
 	.prepare =	dummy_systimer_prepare,
@@ -475,7 +475,7 @@ static void dummy_hrtimer_free(struct snd_pcm_substream *substream)
 	kfree(dpcm);
 }
 
-static struct dummy_timer_ops dummy_hrtimer_ops = {
+static const struct dummy_timer_ops dummy_hrtimer_ops = {
 	.create =	dummy_hrtimer_create,
 	.free =		dummy_hrtimer_free,
 	.prepare =	dummy_hrtimer_prepare,

commit 129a4c9f829d3e2113ce4f2c67cd431b48b2abb7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 29 07:47:50 2015 +0200

    ALSA: dummy: Replace CONFIG_PROC_FS with CONFIG_SND_PROC_FS
    
    Although there shouldn't be a problem in practice (the compiler should
    handle well), it's better to follow to the new Kconfig.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 5912f440d30f..016e451ed506 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -914,7 +914,7 @@ static int snd_card_dummy_new_mixer(struct snd_dummy *dummy)
 	return 0;
 }
 
-#if defined(CONFIG_SND_DEBUG) && defined(CONFIG_PROC_FS)
+#if defined(CONFIG_SND_DEBUG) && defined(CONFIG_SND_PROC_FS)
 /*
  * proc interface
  */
@@ -1042,7 +1042,7 @@ static void dummy_proc_init(struct snd_dummy *chip)
 }
 #else
 #define dummy_proc_init(x)
-#endif /* CONFIG_SND_DEBUG && CONFIG_PROC_FS */
+#endif /* CONFIG_SND_DEBUG && CONFIG_SND_PROC_FS */
 
 static int snd_dummy_probe(struct platform_device *devptr)
 {

commit e4c286880e8f8f94f55b9abe26329ab106108230
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 26 12:51:35 2015 +0200

    ALSA: dummy: make local data static
    
    Add missing prefix to make some local data static.
    
    Spotted by sparse:
      sound/drivers/dummy.c:159:20: warning: symbol 'model_emu10k1' was not declared. Should it be static?
      sound/drivers/dummy.c:165:20: warning: symbol 'model_rme9652' was not declared. Should it be static?
      ....
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index d11baaf0f0b4..5912f440d30f 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -156,13 +156,13 @@ static int emu10k1_playback_constraints(struct snd_pcm_runtime *runtime)
 	return 0;
 }
 
-struct dummy_model model_emu10k1 = {
+static struct dummy_model model_emu10k1 = {
 	.name = "emu10k1",
 	.playback_constraints = emu10k1_playback_constraints,
 	.buffer_bytes_max = 128 * 1024,
 };
 
-struct dummy_model model_rme9652 = {
+static struct dummy_model model_rme9652 = {
 	.name = "rme9652",
 	.buffer_bytes_max = 26 * 64 * 1024,
 	.formats = SNDRV_PCM_FMTBIT_S32_LE,
@@ -172,7 +172,7 @@ struct dummy_model model_rme9652 = {
 	.periods_max = 2,
 };
 
-struct dummy_model model_ice1712 = {
+static struct dummy_model model_ice1712 = {
 	.name = "ice1712",
 	.buffer_bytes_max = 256 * 1024,
 	.formats = SNDRV_PCM_FMTBIT_S32_LE,
@@ -182,7 +182,7 @@ struct dummy_model model_ice1712 = {
 	.periods_max = 1024,
 };
 
-struct dummy_model model_uda1341 = {
+static struct dummy_model model_uda1341 = {
 	.name = "uda1341",
 	.buffer_bytes_max = 16380,
 	.formats = SNDRV_PCM_FMTBIT_S16_LE,
@@ -192,7 +192,7 @@ struct dummy_model model_uda1341 = {
 	.periods_max = 255,
 };
 
-struct dummy_model model_ac97 = {
+static struct dummy_model model_ac97 = {
 	.name = "ac97",
 	.formats = SNDRV_PCM_FMTBIT_S16_LE,
 	.channels_min = 2,
@@ -202,7 +202,7 @@ struct dummy_model model_ac97 = {
 	.rate_max = 48000,
 };
 
-struct dummy_model model_ca0106 = {
+static struct dummy_model model_ca0106 = {
 	.name = "ca0106",
 	.formats = SNDRV_PCM_FMTBIT_S16_LE,
 	.buffer_bytes_max = ((65536-64)*8),
@@ -216,7 +216,7 @@ struct dummy_model model_ca0106 = {
 	.rate_max = 192000,
 };
 
-struct dummy_model *dummy_models[] = {
+static struct dummy_model *dummy_models[] = {
 	&model_emu10k1,
 	&model_rme9652,
 	&model_ice1712,

commit 2a52b6eef7386cc19dfc0a2e82a7e23d807e51e5
Author: Roman Kollar <rkollar@mail.muni.cz>
Date:   Mon Jan 19 10:42:54 2015 +0100

    ALSA: dummy: use setup_timer and mod_timer
    
    Use setup_timer and mod_timer instead of structure assignments as it
    is the preferred way to setup and set the timer.
    
    Signed-off-by: Roman Kollar <rkollar@mail.muni.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 5d0dfb787cec..d11baaf0f0b4 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -245,9 +245,8 @@ struct dummy_systimer_pcm {
 
 static void dummy_systimer_rearm(struct dummy_systimer_pcm *dpcm)
 {
-	dpcm->timer.expires = jiffies +
-		(dpcm->frac_period_rest + dpcm->rate - 1) / dpcm->rate;
-	add_timer(&dpcm->timer);
+	mod_timer(&dpcm->timer, jiffies +
+		(dpcm->frac_period_rest + dpcm->rate - 1) / dpcm->rate);
 }
 
 static void dummy_systimer_update(struct dummy_systimer_pcm *dpcm)
@@ -340,9 +339,8 @@ static int dummy_systimer_create(struct snd_pcm_substream *substream)
 	if (!dpcm)
 		return -ENOMEM;
 	substream->runtime->private_data = dpcm;
-	init_timer(&dpcm->timer);
-	dpcm->timer.data = (unsigned long) dpcm;
-	dpcm->timer.function = dummy_systimer_callback;
+	setup_timer(&dpcm->timer, dummy_systimer_callback,
+			(unsigned long) dpcm);
 	spin_lock_init(&dpcm->lock);
 	dpcm->substream = substream;
 	return 0;

commit 5d5638afa0cb252442e1746a36550b46a9ebe6ee
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:59 2014 +0200

    ALSA: drivers: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index fab90bd2bd51..5d0dfb787cec 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -1162,7 +1162,6 @@ static struct platform_driver snd_dummy_driver = {
 	.remove		= snd_dummy_remove,
 	.driver		= {
 		.name	= SND_DUMMY_DRIVER,
-		.owner	= THIS_MODULE,
 		.pm	= SND_DUMMY_PM_OPS,
 	},
 };

commit 5872f3f621f9f65342583a85ec93b00c0a697eda
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 12:59:08 2014 +0100

    ALSA: drivers: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 915b4d7fbb23..fab90bd2bd51 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -1054,8 +1054,8 @@ static int snd_dummy_probe(struct platform_device *devptr)
 	int idx, err;
 	int dev = devptr->id;
 
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE,
-			      sizeof(struct snd_dummy), &card);
+	err = snd_card_new(&devptr->dev, index[dev], id[dev], THIS_MODULE,
+			   sizeof(struct snd_dummy), &card);
 	if (err < 0)
 		return err;
 	dummy = card->private_data;
@@ -1114,8 +1114,6 @@ static int snd_dummy_probe(struct platform_device *devptr)
 
 	dummy_proc_init(dummy);
 
-	snd_card_set_dev(card, &devptr->dev);
-
 	err = snd_card_register(card);
 	if (err == 0) {
 		platform_set_drvdata(devptr, card);

commit b785a492c6eef578520594d5c4d6e9f2cb47cbeb
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Fri Jul 19 16:24:59 2013 +0900

    ALSA: replace strict_strto*() with kstrto*()
    
    The usage of strict_strto*() is not preferred, because
    strict_strto*() is obsolete. Thus, kstrto*() should be
    used.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 11048cc744d0..915b4d7fbb23 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -1022,7 +1022,7 @@ static void dummy_proc_write(struct snd_info_entry *entry,
 		if (i >= ARRAY_SIZE(fields))
 			continue;
 		snd_info_get_str(item, ptr, sizeof(item));
-		if (strict_strtoull(item, 0, &val))
+		if (kstrtoull(item, 0, &val))
 			continue;
 		if (fields[i].size == sizeof(int))
 			*get_dummy_int_ptr(dummy, fields[i].offset) = val;

commit f35e839a3ce730063174caaab8bf63432be553cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:50:59 2013 +0200

    ALSA: Remove the rest of *_set_drvdata(NULL) calls
    
    A few calls are still left in parport drivers after this commit, which
    I'm not quite sure yet.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index fd798f753609..11048cc744d0 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -1129,7 +1129,6 @@ static int snd_dummy_probe(struct platform_device *devptr)
 static int snd_dummy_remove(struct platform_device *devptr)
 {
 	snd_card_free(platform_get_drvdata(devptr));
-	platform_set_drvdata(devptr, NULL);
 	return 0;
 }
 

commit fbbb01a12d5d553ea3851a020d98c0ac9b383673
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:27 2012 -0500

    ALSA: drivers: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 4f522cf48455..fd798f753609 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -688,8 +688,8 @@ static struct snd_pcm_ops dummy_pcm_ops_no_buf = {
 	.page =		dummy_pcm_page,
 };
 
-static int __devinit snd_card_dummy_pcm(struct snd_dummy *dummy, int device,
-					int substreams)
+static int snd_card_dummy_pcm(struct snd_dummy *dummy, int device,
+			      int substreams)
 {
 	struct snd_pcm *pcm;
 	struct snd_pcm_ops *ops;
@@ -891,7 +891,7 @@ DUMMY_CAPSRC("CD Capture Switch", 0, MIXER_ADDR_CD),
 },
 };
 
-static int __devinit snd_card_dummy_new_mixer(struct snd_dummy *dummy)
+static int snd_card_dummy_new_mixer(struct snd_dummy *dummy)
 {
 	struct snd_card *card = dummy->card;
 	struct snd_kcontrol *kcontrol;
@@ -1031,7 +1031,7 @@ static void dummy_proc_write(struct snd_info_entry *entry,
 	}
 }
 
-static void __devinit dummy_proc_init(struct snd_dummy *chip)
+static void dummy_proc_init(struct snd_dummy *chip)
 {
 	struct snd_info_entry *entry;
 
@@ -1046,7 +1046,7 @@ static void __devinit dummy_proc_init(struct snd_dummy *chip)
 #define dummy_proc_init(x)
 #endif /* CONFIG_SND_DEBUG && CONFIG_PROC_FS */
 
-static int __devinit snd_dummy_probe(struct platform_device *devptr)
+static int snd_dummy_probe(struct platform_device *devptr)
 {
 	struct snd_card *card;
 	struct snd_dummy *dummy;
@@ -1126,7 +1126,7 @@ static int __devinit snd_dummy_probe(struct platform_device *devptr)
 	return err;
 }
 
-static int __devexit snd_dummy_remove(struct platform_device *devptr)
+static int snd_dummy_remove(struct platform_device *devptr)
 {
 	snd_card_free(platform_get_drvdata(devptr));
 	platform_set_drvdata(devptr, NULL);
@@ -1162,7 +1162,7 @@ static SIMPLE_DEV_PM_OPS(snd_dummy_pm, snd_dummy_suspend, snd_dummy_resume);
 
 static struct platform_driver snd_dummy_driver = {
 	.probe		= snd_dummy_probe,
-	.remove		= __devexit_p(snd_dummy_remove),
+	.remove		= snd_dummy_remove,
 	.driver		= {
 		.name	= SND_DUMMY_DRIVER,
 		.owner	= THIS_MODULE,

commit 16e434670e95398e22cd54b87e4eebe44ae6c179
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sat Oct 20 12:21:36 2012 +0200

    ALSA: dummy: allow disabling mixer controls
    
    To make the testing of deactivated mixer controls easier (and for people
    with common hardware, possible), add a control that deactivates some
    other controls.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 54bb6644a598..4f522cf48455 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -134,6 +134,9 @@ struct snd_dummy {
 	spinlock_t mixer_lock;
 	int mixer_volume[MIXER_ADDR_LAST+1][2];
 	int capture_source[MIXER_ADDR_LAST+1][2];
+	int iobox;
+	struct snd_kcontrol *cd_volume_ctl;
+	struct snd_kcontrol *cd_switch_ctl;
 	const struct dummy_timer_ops *timer_ops;
 };
 
@@ -817,6 +820,57 @@ static int snd_dummy_capsrc_put(struct snd_kcontrol *kcontrol, struct snd_ctl_el
 	return change;
 }
 
+static int snd_dummy_iobox_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *info)
+{
+	const char *const names[] = { "None", "CD Player" };
+
+	return snd_ctl_enum_info(info, 1, 2, names);
+}
+
+static int snd_dummy_iobox_get(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *value)
+{
+	struct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);
+
+	value->value.enumerated.item[0] = dummy->iobox;
+	return 0;
+}
+
+static int snd_dummy_iobox_put(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *value)
+{
+	struct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);
+	int changed;
+
+	if (value->value.enumerated.item[0] > 1)
+		return -EINVAL;
+
+	changed = value->value.enumerated.item[0] != dummy->iobox;
+	if (changed) {
+		dummy->iobox = value->value.enumerated.item[0];
+
+		if (dummy->iobox) {
+			dummy->cd_volume_ctl->vd[0].access &=
+				~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+			dummy->cd_switch_ctl->vd[0].access &=
+				~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+		} else {
+			dummy->cd_volume_ctl->vd[0].access |=
+				SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+			dummy->cd_switch_ctl->vd[0].access |=
+				SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+		}
+
+		snd_ctl_notify(dummy->card, SNDRV_CTL_EVENT_MASK_INFO,
+			       &dummy->cd_volume_ctl->id);
+		snd_ctl_notify(dummy->card, SNDRV_CTL_EVENT_MASK_INFO,
+			       &dummy->cd_switch_ctl->id);
+	}
+
+	return changed;
+}
+
 static struct snd_kcontrol_new snd_dummy_controls[] = {
 DUMMY_VOLUME("Master Volume", 0, MIXER_ADDR_MASTER),
 DUMMY_CAPSRC("Master Capture Switch", 0, MIXER_ADDR_MASTER),
@@ -827,22 +881,37 @@ DUMMY_CAPSRC("Line Capture Switch", 0, MIXER_ADDR_LINE),
 DUMMY_VOLUME("Mic Volume", 0, MIXER_ADDR_MIC),
 DUMMY_CAPSRC("Mic Capture Switch", 0, MIXER_ADDR_MIC),
 DUMMY_VOLUME("CD Volume", 0, MIXER_ADDR_CD),
-DUMMY_CAPSRC("CD Capture Switch", 0, MIXER_ADDR_CD)
+DUMMY_CAPSRC("CD Capture Switch", 0, MIXER_ADDR_CD),
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name  = "External I/O Box",
+	.info  = snd_dummy_iobox_info,
+	.get   = snd_dummy_iobox_get,
+	.put   = snd_dummy_iobox_put,
+},
 };
 
 static int __devinit snd_card_dummy_new_mixer(struct snd_dummy *dummy)
 {
 	struct snd_card *card = dummy->card;
+	struct snd_kcontrol *kcontrol;
 	unsigned int idx;
 	int err;
 
 	spin_lock_init(&dummy->mixer_lock);
 	strcpy(card->mixername, "Dummy Mixer");
+	dummy->iobox = 1;
 
 	for (idx = 0; idx < ARRAY_SIZE(snd_dummy_controls); idx++) {
-		err = snd_ctl_add(card, snd_ctl_new1(&snd_dummy_controls[idx], dummy));
+		kcontrol = snd_ctl_new1(&snd_dummy_controls[idx], dummy);
+		err = snd_ctl_add(card, kcontrol);
 		if (err < 0)
 			return err;
+		if (!strcmp(kcontrol->id.name, "CD Volume"))
+			dummy->cd_volume_ctl = kcontrol;
+		else if (!strcmp(kcontrol->id.name, "CD Capture Switch"))
+			dummy->cd_switch_ctl = kcontrol;
+
 	}
 	return 0;
 }

commit d34e4e00adbbc91ff9fc96ed9a4e4b65161868da
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 9 15:47:15 2012 +0200

    ALSA: platform: Check CONFIG_PM_SLEEP instead of CONFIG_PM
    
    When CONFIG_PM is set but CONFIG_PM_SLEEP is unset,
    SIMPLE_DEV_PM_OPS() ignores the given functions, and this leads to
    compile warnings.
    
    For avoiding this, simply check CONFIG_PM_SLEEP instead of CONFIG_PM.
    
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index f7d3bfc6bca8..54bb6644a598 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -1064,7 +1064,7 @@ static int __devexit snd_dummy_remove(struct platform_device *devptr)
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int snd_dummy_suspend(struct device *pdev)
 {
 	struct snd_card *card = dev_get_drvdata(pdev);

commit 284e7ca75f96a18f182cce38ba76ee724fb97e16
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 11:22:40 2012 +0200

    ALSA: convert PM ops of platform_driver to new pm ops
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index bc79c441a8f2..f7d3bfc6bca8 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -1065,9 +1065,9 @@ static int __devexit snd_dummy_remove(struct platform_device *devptr)
 }
 
 #ifdef CONFIG_PM
-static int snd_dummy_suspend(struct platform_device *pdev, pm_message_t state)
+static int snd_dummy_suspend(struct device *pdev)
 {
-	struct snd_card *card = platform_get_drvdata(pdev);
+	struct snd_card *card = dev_get_drvdata(pdev);
 	struct snd_dummy *dummy = card->private_data;
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
@@ -1075,13 +1075,18 @@ static int snd_dummy_suspend(struct platform_device *pdev, pm_message_t state)
 	return 0;
 }
 	
-static int snd_dummy_resume(struct platform_device *pdev)
+static int snd_dummy_resume(struct device *pdev)
 {
-	struct snd_card *card = platform_get_drvdata(pdev);
+	struct snd_card *card = dev_get_drvdata(pdev);
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
+
+static SIMPLE_DEV_PM_OPS(snd_dummy_pm, snd_dummy_suspend, snd_dummy_resume);
+#define SND_DUMMY_PM_OPS	&snd_dummy_pm
+#else
+#define SND_DUMMY_PM_OPS	NULL
 #endif
 
 #define SND_DUMMY_DRIVER	"snd_dummy"
@@ -1089,13 +1094,10 @@ static int snd_dummy_resume(struct platform_device *pdev)
 static struct platform_driver snd_dummy_driver = {
 	.probe		= snd_dummy_probe,
 	.remove		= __devexit_p(snd_dummy_remove),
-#ifdef CONFIG_PM
-	.suspend	= snd_dummy_suspend,
-	.resume		= snd_dummy_resume,
-#endif
 	.driver		= {
 		.name	= SND_DUMMY_DRIVER,
 		.owner	= THIS_MODULE,
+		.pm	= SND_DUMMY_PM_OPS,
 	},
 };
 

commit 8bf01d8abc55eaf8e19a2d48911c8e49ee6f5bab
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 10:50:24 2012 +0200

    ALSA: Add missing .owner=THIS_MODULE to platform_driver definitions
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index ad9434fd6370..bc79c441a8f2 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -1094,7 +1094,8 @@ static struct platform_driver snd_dummy_driver = {
 	.resume		= snd_dummy_resume,
 #endif
 	.driver		= {
-		.name	= SND_DUMMY_DRIVER
+		.name	= SND_DUMMY_DRIVER,
+		.owner	= THIS_MODULE,
 	},
 };
 

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 97f1f93ed275..ad9434fd6370 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -60,15 +60,15 @@ MODULE_SUPPORTED_DEVICE("{{ALSA,Dummy soundcard}}");
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = {1, [1 ... (SNDRV_CARDS - 1)] = 0};
+static bool enable[SNDRV_CARDS] = {1, [1 ... (SNDRV_CARDS - 1)] = 0};
 static char *model[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = NULL};
 static int pcm_devs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};
 static int pcm_substreams[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 8};
 //static int midi_devs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
 #ifdef CONFIG_HIGH_RES_TIMERS
-static int hrtimer = 1;
+static bool hrtimer = 1;
 #endif
-static int fake_buffer = 1;
+static bool fake_buffer = 1;
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for dummy soundcard.");

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 7f41990ed68b..97f1f93ed275 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -27,7 +27,7 @@
 #include <linux/wait.h>
 #include <linux/hrtimer.h>
 #include <linux/math64.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/tlv.h>

commit d5e1ca05f758fec2845a97fd7aa1eeca91c51a21
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Tue Feb 2 17:48:51 2010 +0100

    ALSA: dummy driver - add model parameter
    
    This is a cleanup for the dummy driver. The model kernel module parameter
    is introduced to select the soundcard emulation.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 252e04ce602f..7f41990ed68b 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -45,109 +45,23 @@ MODULE_SUPPORTED_DEVICE("{{ALSA,Dummy soundcard}}");
 #define MAX_PCM_SUBSTREAMS	128
 #define MAX_MIDI_DEVICES	2
 
-#if 0 /* emu10k1 emulation */
-#define MAX_BUFFER_SIZE		(128 * 1024)
-static int emu10k1_playback_constraints(struct snd_pcm_runtime *runtime)
-{
-	int err;
-	err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
-	if (err < 0)
-		return err;
-	err = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 256, UINT_MAX);
-	if (err < 0)
-		return err;
-	return 0;
-}
-#define add_playback_constraints emu10k1_playback_constraints
-#endif
-
-#if 0 /* RME9652 emulation */
-#define MAX_BUFFER_SIZE		(26 * 64 * 1024)
-#define USE_FORMATS		SNDRV_PCM_FMTBIT_S32_LE
-#define USE_CHANNELS_MIN	26
-#define USE_CHANNELS_MAX	26
-#define USE_PERIODS_MIN		2
-#define USE_PERIODS_MAX		2
-#endif
-
-#if 0 /* ICE1712 emulation */
-#define MAX_BUFFER_SIZE		(256 * 1024)
-#define USE_FORMATS		SNDRV_PCM_FMTBIT_S32_LE
-#define USE_CHANNELS_MIN	10
-#define USE_CHANNELS_MAX	10
-#define USE_PERIODS_MIN		1
-#define USE_PERIODS_MAX		1024
-#endif
-
-#if 0 /* UDA1341 emulation */
-#define MAX_BUFFER_SIZE		(16380)
-#define USE_FORMATS		SNDRV_PCM_FMTBIT_S16_LE
-#define USE_CHANNELS_MIN	2
-#define USE_CHANNELS_MAX	2
-#define USE_PERIODS_MIN		2
-#define USE_PERIODS_MAX		255
-#endif
-
-#if 0 /* simple AC97 bridge (intel8x0) with 48kHz AC97 only codec */
-#define USE_FORMATS		SNDRV_PCM_FMTBIT_S16_LE
-#define USE_CHANNELS_MIN	2
-#define USE_CHANNELS_MAX	2
-#define USE_RATE		SNDRV_PCM_RATE_48000
-#define USE_RATE_MIN		48000
-#define USE_RATE_MAX		48000
-#endif
-
-#if 0 /* CA0106 */
-#define USE_FORMATS		SNDRV_PCM_FMTBIT_S16_LE
-#define USE_CHANNELS_MIN	2
-#define USE_CHANNELS_MAX	2
-#define USE_RATE		(SNDRV_PCM_RATE_48000|SNDRV_PCM_RATE_96000|SNDRV_PCM_RATE_192000) 
-#define USE_RATE_MIN		48000 
-#define USE_RATE_MAX		192000
-#define MAX_BUFFER_SIZE		((65536-64)*8)
-#define MAX_PERIOD_SIZE		(65536-64)
-#define USE_PERIODS_MIN		2
-#define USE_PERIODS_MAX		8
-#endif
-
-
 /* defaults */
-#ifndef MAX_BUFFER_SIZE
 #define MAX_BUFFER_SIZE		(64*1024)
-#endif
-#ifndef MAX_PERIOD_SIZE
+#define MIN_PERIOD_SIZE		64
 #define MAX_PERIOD_SIZE		MAX_BUFFER_SIZE
-#endif
-#ifndef USE_FORMATS
 #define USE_FORMATS 		(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE)
-#endif
-#ifndef USE_RATE
 #define USE_RATE		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000
 #define USE_RATE_MIN		5500
 #define USE_RATE_MAX		48000
-#endif
-#ifndef USE_CHANNELS_MIN
 #define USE_CHANNELS_MIN 	1
-#endif
-#ifndef USE_CHANNELS_MAX
 #define USE_CHANNELS_MAX 	2
-#endif
-#ifndef USE_PERIODS_MIN
 #define USE_PERIODS_MIN 	1
-#endif
-#ifndef USE_PERIODS_MAX
 #define USE_PERIODS_MAX 	1024
-#endif
-#ifndef add_playback_constraints
-#define add_playback_constraints(x) 0
-#endif
-#ifndef add_capture_constraints
-#define add_capture_constraints(x) 0
-#endif
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = {1, [1 ... (SNDRV_CARDS - 1)] = 0};
+static char *model[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = NULL};
 static int pcm_devs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};
 static int pcm_substreams[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 8};
 //static int midi_devs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
@@ -162,6 +76,8 @@ module_param_array(id, charp, NULL, 0444);
 MODULE_PARM_DESC(id, "ID string for dummy soundcard.");
 module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable this dummy soundcard.");
+module_param_array(model, charp, NULL, 0444);
+MODULE_PARM_DESC(model, "Soundcard model.");
 module_param_array(pcm_devs, int, NULL, 0444);
 MODULE_PARM_DESC(pcm_devs, "PCM devices # (0-4) for dummy driver.");
 module_param_array(pcm_substreams, int, NULL, 0444);
@@ -193,15 +109,120 @@ struct dummy_timer_ops {
 	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *);
 };
 
+struct dummy_model {
+	const char *name;
+	int (*playback_constraints)(struct snd_pcm_runtime *runtime);
+	int (*capture_constraints)(struct snd_pcm_runtime *runtime);
+	u64 formats;
+	size_t buffer_bytes_max;
+	size_t period_bytes_min;
+	size_t period_bytes_max;
+	unsigned int periods_min;
+	unsigned int periods_max;
+	unsigned int rates;
+	unsigned int rate_min;
+	unsigned int rate_max;
+	unsigned int channels_min;
+	unsigned int channels_max;
+};
+
 struct snd_dummy {
 	struct snd_card *card;
+	struct dummy_model *model;
 	struct snd_pcm *pcm;
+	struct snd_pcm_hardware pcm_hw;
 	spinlock_t mixer_lock;
 	int mixer_volume[MIXER_ADDR_LAST+1][2];
 	int capture_source[MIXER_ADDR_LAST+1][2];
 	const struct dummy_timer_ops *timer_ops;
 };
 
+/*
+ * card models
+ */
+
+static int emu10k1_playback_constraints(struct snd_pcm_runtime *runtime)
+{
+	int err;
+	err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	if (err < 0)
+		return err;
+	err = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 256, UINT_MAX);
+	if (err < 0)
+		return err;
+	return 0;
+}
+
+struct dummy_model model_emu10k1 = {
+	.name = "emu10k1",
+	.playback_constraints = emu10k1_playback_constraints,
+	.buffer_bytes_max = 128 * 1024,
+};
+
+struct dummy_model model_rme9652 = {
+	.name = "rme9652",
+	.buffer_bytes_max = 26 * 64 * 1024,
+	.formats = SNDRV_PCM_FMTBIT_S32_LE,
+	.channels_min = 26,
+	.channels_max = 26,
+	.periods_min = 2,
+	.periods_max = 2,
+};
+
+struct dummy_model model_ice1712 = {
+	.name = "ice1712",
+	.buffer_bytes_max = 256 * 1024,
+	.formats = SNDRV_PCM_FMTBIT_S32_LE,
+	.channels_min = 10,
+	.channels_max = 10,
+	.periods_min = 1,
+	.periods_max = 1024,
+};
+
+struct dummy_model model_uda1341 = {
+	.name = "uda1341",
+	.buffer_bytes_max = 16380,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	.channels_min = 2,
+	.channels_max = 2,
+	.periods_min = 2,
+	.periods_max = 255,
+};
+
+struct dummy_model model_ac97 = {
+	.name = "ac97",
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	.channels_min = 2,
+	.channels_max = 2,
+	.rates = SNDRV_PCM_RATE_48000,
+	.rate_min = 48000,
+	.rate_max = 48000,
+};
+
+struct dummy_model model_ca0106 = {
+	.name = "ca0106",
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	.buffer_bytes_max = ((65536-64)*8),
+	.period_bytes_max = (65536-64),
+	.periods_min = 2,
+	.periods_max = 8,
+	.channels_min = 2,
+	.channels_max = 2,
+	.rates = SNDRV_PCM_RATE_48000|SNDRV_PCM_RATE_96000|SNDRV_PCM_RATE_192000,
+	.rate_min = 48000,
+	.rate_max = 192000,
+};
+
+struct dummy_model *dummy_models[] = {
+	&model_emu10k1,
+	&model_rme9652,
+	&model_ice1712,
+	&model_uda1341,
+	&model_ac97,
+	&model_ca0106,
+	NULL
+};
+
 /*
  * system timer interface
  */
@@ -509,7 +530,7 @@ static struct snd_pcm_hardware dummy_pcm_hardware = {
 	.channels_min =		USE_CHANNELS_MIN,
 	.channels_max =		USE_CHANNELS_MAX,
 	.buffer_bytes_max =	MAX_BUFFER_SIZE,
-	.period_bytes_min =	64,
+	.period_bytes_min =	MIN_PERIOD_SIZE,
 	.period_bytes_max =	MAX_PERIOD_SIZE,
 	.periods_min =		USE_PERIODS_MIN,
 	.periods_max =		USE_PERIODS_MAX,
@@ -538,6 +559,7 @@ static int dummy_pcm_hw_free(struct snd_pcm_substream *substream)
 static int dummy_pcm_open(struct snd_pcm_substream *substream)
 {
 	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
+	struct dummy_model *model = dummy->model;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err;
 
@@ -551,7 +573,7 @@ static int dummy_pcm_open(struct snd_pcm_substream *substream)
 	if (err < 0)
 		return err;
 
-	runtime->hw = dummy_pcm_hardware;
+	runtime->hw = dummy->pcm_hw;
 	if (substream->pcm->device & 1) {
 		runtime->hw.info &= ~SNDRV_PCM_INFO_INTERLEAVED;
 		runtime->hw.info |= SNDRV_PCM_INFO_NONINTERLEAVED;
@@ -560,10 +582,16 @@ static int dummy_pcm_open(struct snd_pcm_substream *substream)
 		runtime->hw.info &= ~(SNDRV_PCM_INFO_MMAP |
 				      SNDRV_PCM_INFO_MMAP_VALID);
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		err = add_playback_constraints(substream->runtime);
-	else
-		err = add_capture_constraints(substream->runtime);
+	if (model == NULL)
+		return 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (model->playback_constraints)
+			err = model->playback_constraints(substream->runtime);
+	} else {
+		if (model->capture_constraints)
+			err = model->capture_constraints(substream->runtime);
+	}
 	if (err < 0) {
 		dummy->timer_ops->free(substream);
 		return err;
@@ -823,17 +851,19 @@ static int __devinit snd_card_dummy_new_mixer(struct snd_dummy *dummy)
 /*
  * proc interface
  */
-static void print_formats(struct snd_info_buffer *buffer)
+static void print_formats(struct snd_dummy *dummy,
+			  struct snd_info_buffer *buffer)
 {
 	int i;
 
 	for (i = 0; i < SNDRV_PCM_FORMAT_LAST; i++) {
-		if (dummy_pcm_hardware.formats & (1ULL << i))
+		if (dummy->pcm_hw.formats & (1ULL << i))
 			snd_iprintf(buffer, " %s", snd_pcm_format_name(i));
 	}
 }
 
-static void print_rates(struct snd_info_buffer *buffer)
+static void print_rates(struct snd_dummy *dummy,
+			struct snd_info_buffer *buffer)
 {
 	static int rates[] = {
 		5512, 8000, 11025, 16000, 22050, 32000, 44100, 48000,
@@ -841,19 +871,19 @@ static void print_rates(struct snd_info_buffer *buffer)
 	};
 	int i;
 
-	if (dummy_pcm_hardware.rates & SNDRV_PCM_RATE_CONTINUOUS)
+	if (dummy->pcm_hw.rates & SNDRV_PCM_RATE_CONTINUOUS)
 		snd_iprintf(buffer, " continuous");
-	if (dummy_pcm_hardware.rates & SNDRV_PCM_RATE_KNOT)
+	if (dummy->pcm_hw.rates & SNDRV_PCM_RATE_KNOT)
 		snd_iprintf(buffer, " knot");
 	for (i = 0; i < ARRAY_SIZE(rates); i++)
-		if (dummy_pcm_hardware.rates & (1 << i))
+		if (dummy->pcm_hw.rates & (1 << i))
 			snd_iprintf(buffer, " %d", rates[i]);
 }
 
-#define get_dummy_int_ptr(ofs) \
-	(unsigned int *)((char *)&dummy_pcm_hardware + (ofs))
-#define get_dummy_ll_ptr(ofs) \
-	(unsigned long long *)((char *)&dummy_pcm_hardware + (ofs))
+#define get_dummy_int_ptr(dummy, ofs) \
+	(unsigned int *)((char *)&((dummy)->pcm_hw) + (ofs))
+#define get_dummy_ll_ptr(dummy, ofs) \
+	(unsigned long long *)((char *)&((dummy)->pcm_hw) + (ofs))
 
 struct dummy_hw_field {
 	const char *name;
@@ -884,20 +914,21 @@ static struct dummy_hw_field fields[] = {
 static void dummy_proc_read(struct snd_info_entry *entry,
 			    struct snd_info_buffer *buffer)
 {
+	struct snd_dummy *dummy = entry->private_data;
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(fields); i++) {
 		snd_iprintf(buffer, "%s ", fields[i].name);
 		if (fields[i].size == sizeof(int))
 			snd_iprintf(buffer, fields[i].format,
-				    *get_dummy_int_ptr(fields[i].offset));
+				*get_dummy_int_ptr(dummy, fields[i].offset));
 		else
 			snd_iprintf(buffer, fields[i].format,
-				    *get_dummy_ll_ptr(fields[i].offset));
+				*get_dummy_ll_ptr(dummy, fields[i].offset));
 		if (!strcmp(fields[i].name, "formats"))
-			print_formats(buffer);
+			print_formats(dummy, buffer);
 		else if (!strcmp(fields[i].name, "rates"))
-			print_rates(buffer);
+			print_rates(dummy, buffer);
 		snd_iprintf(buffer, "\n");
 	}
 }
@@ -905,6 +936,7 @@ static void dummy_proc_read(struct snd_info_entry *entry,
 static void dummy_proc_write(struct snd_info_entry *entry,
 			     struct snd_info_buffer *buffer)
 {
+	struct snd_dummy *dummy = entry->private_data;
 	char line[64];
 
 	while (!snd_info_get_line(buffer, line, sizeof(line))) {
@@ -924,9 +956,9 @@ static void dummy_proc_write(struct snd_info_entry *entry,
 		if (strict_strtoull(item, 0, &val))
 			continue;
 		if (fields[i].size == sizeof(int))
-			*get_dummy_int_ptr(fields[i].offset) = val;
+			*get_dummy_int_ptr(dummy, fields[i].offset) = val;
 		else
-			*get_dummy_ll_ptr(fields[i].offset) = val;
+			*get_dummy_ll_ptr(dummy, fields[i].offset) = val;
 	}
 }
 
@@ -938,6 +970,7 @@ static void __devinit dummy_proc_init(struct snd_dummy *chip)
 		snd_info_set_text_ops(entry, chip, dummy_proc_read);
 		entry->c.text.write = dummy_proc_write;
 		entry->mode |= S_IWUSR;
+		entry->private_data = chip;
 	}
 }
 #else
@@ -948,6 +981,7 @@ static int __devinit snd_dummy_probe(struct platform_device *devptr)
 {
 	struct snd_card *card;
 	struct snd_dummy *dummy;
+	struct dummy_model *m = NULL, **mdl;
 	int idx, err;
 	int dev = devptr->id;
 
@@ -957,6 +991,15 @@ static int __devinit snd_dummy_probe(struct platform_device *devptr)
 		return err;
 	dummy = card->private_data;
 	dummy->card = card;
+	for (mdl = dummy_models; *mdl && model[dev]; mdl++) {
+		if (strcmp(model[dev], (*mdl)->name) == 0) {
+			printk(KERN_INFO
+				"snd-dummy: Using model '%s' for card %i\n",
+				(*mdl)->name, card->number);
+			m = dummy->model = *mdl;
+			break;
+		}
+	}
 	for (idx = 0; idx < MAX_PCM_DEVICES && idx < pcm_devs[dev]; idx++) {
 		if (pcm_substreams[dev] < 1)
 			pcm_substreams[dev] = 1;
@@ -966,6 +1009,33 @@ static int __devinit snd_dummy_probe(struct platform_device *devptr)
 		if (err < 0)
 			goto __nodev;
 	}
+
+	dummy->pcm_hw = dummy_pcm_hardware;
+	if (m) {
+		if (m->formats)
+			dummy->pcm_hw.formats = m->formats;
+		if (m->buffer_bytes_max)
+			dummy->pcm_hw.buffer_bytes_max = m->buffer_bytes_max;
+		if (m->period_bytes_min)
+			dummy->pcm_hw.period_bytes_min = m->period_bytes_min;
+		if (m->period_bytes_max)
+			dummy->pcm_hw.period_bytes_max = m->period_bytes_max;
+		if (m->periods_min)
+			dummy->pcm_hw.periods_min = m->periods_min;
+		if (m->periods_max)
+			dummy->pcm_hw.periods_max = m->periods_max;
+		if (m->rates)
+			dummy->pcm_hw.rates = m->rates;
+		if (m->rate_min)
+			dummy->pcm_hw.rate_min = m->rate_min;
+		if (m->rate_max)
+			dummy->pcm_hw.rate_max = m->rate_max;
+		if (m->channels_min)
+			dummy->pcm_hw.channels_min = m->channels_min;
+		if (m->channels_max)
+			dummy->pcm_hw.channels_max = m->channels_max;
+	}
+
 	err = snd_card_dummy_new_mixer(dummy);
 	if (err < 0)
 		goto __nodev;

commit 23aebca486429b74c35b41ac5cac7ce97609fd6a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 2 14:10:59 2009 +0100

    ALSA: dummy - Fix descriptions of pcm_substreams parameter
    
    Now up to 128 substreams are supported.
    
    Reported-by: Adrian Bridgett <adrian@smop.co.uk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 146ef00f94a3..252e04ce602f 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -165,7 +165,7 @@ MODULE_PARM_DESC(enable, "Enable this dummy soundcard.");
 module_param_array(pcm_devs, int, NULL, 0444);
 MODULE_PARM_DESC(pcm_devs, "PCM devices # (0-4) for dummy driver.");
 module_param_array(pcm_substreams, int, NULL, 0444);
-MODULE_PARM_DESC(pcm_substreams, "PCM substreams # (1-16) for dummy driver.");
+MODULE_PARM_DESC(pcm_substreams, "PCM substreams # (1-128) for dummy driver.");
 //module_param_array(midi_devs, int, NULL, 0444);
 //MODULE_PARM_DESC(midi_devs, "MIDI devices # (0-2) for dummy driver.");
 module_param(fake_buffer, bool, 0444);

commit 4b3be6afa4ab8b3fdce39df68bad71f8b85164de
Author: Julia Lawall <julia@diku.dk>
Date:   Sat Oct 17 08:33:22 2009 +0200

    ALSA: sound: Move dereference after NULL test and drop unnecessary NULL tests
    
    In pcm.c, if the NULL test on pcm is needed, then the dereference should be
    after the NULL test.
    
    In dummy.c and ali5451.c, the context of the calls to
    snd_card_dummy_new_mixer and snd_ali_free_voice show that dummy and pvoice,
    respectively cannot be NULL.
    
    A simplified version of the semantic match that detects this problem is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    @match exists@
    expression x, E;
    identifier fld;
    @@
    
    * x->fld
      ... when != \(x = E\|&x\)
    * x == NULL
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 6ba066c41d2e..146ef00f94a3 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -808,8 +808,6 @@ static int __devinit snd_card_dummy_new_mixer(struct snd_dummy *dummy)
 	unsigned int idx;
 	int err;
 
-	if (snd_BUG_ON(!dummy))
-		return -EINVAL;
 	spin_lock_init(&dummy->mixer_lock);
 	strcpy(card->mixername, "Dummy Mixer");
 

commit b888d1ce82ebd2bafecf64c765754968e78b4228
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 8 18:15:17 2009 +0200

    ALSA: dummy - Increase MAX_PCM_SUBSTREAMS to 128
    
    Increase the limit of PCM substreams to 128.  The default value is
    unchanged; only the max accept value is increased.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index ccfbdfa75511..6ba066c41d2e 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -42,7 +42,7 @@ MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{ALSA,Dummy soundcard}}");
 
 #define MAX_PCM_DEVICES		4
-#define MAX_PCM_SUBSTREAMS	16
+#define MAX_PCM_SUBSTREAMS	128
 #define MAX_MIDI_DEVICES	2
 
 #if 0 /* emu10k1 emulation */

commit 9b151fec139d32ab3acce5da5761d868e205fadd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 8 14:30:49 2009 +0200

    ALSA: dummy - Add debug proc file
    
    Added the debug proc file to see or change the snd_pcm_hardware fields
    to emulate.  The parameters can be changed by writing to a proc file like:
    
        # echo periods_min 4 > /proc/asound/card1/dummy_pcm
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 2ee6c8ebe25a..ccfbdfa75511 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -33,6 +33,7 @@
 #include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/rawmidi.h>
+#include <sound/info.h>
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");
@@ -686,6 +687,10 @@ static int __devinit snd_card_dummy_pcm(struct snd_dummy *dummy, int device,
 	return 0;
 }
 
+/*
+ * mixer interface
+ */
+
 #define DUMMY_VOLUME(xname, xindex, addr) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \
@@ -816,6 +821,131 @@ static int __devinit snd_card_dummy_new_mixer(struct snd_dummy *dummy)
 	return 0;
 }
 
+#if defined(CONFIG_SND_DEBUG) && defined(CONFIG_PROC_FS)
+/*
+ * proc interface
+ */
+static void print_formats(struct snd_info_buffer *buffer)
+{
+	int i;
+
+	for (i = 0; i < SNDRV_PCM_FORMAT_LAST; i++) {
+		if (dummy_pcm_hardware.formats & (1ULL << i))
+			snd_iprintf(buffer, " %s", snd_pcm_format_name(i));
+	}
+}
+
+static void print_rates(struct snd_info_buffer *buffer)
+{
+	static int rates[] = {
+		5512, 8000, 11025, 16000, 22050, 32000, 44100, 48000,
+		64000, 88200, 96000, 176400, 192000,
+	};
+	int i;
+
+	if (dummy_pcm_hardware.rates & SNDRV_PCM_RATE_CONTINUOUS)
+		snd_iprintf(buffer, " continuous");
+	if (dummy_pcm_hardware.rates & SNDRV_PCM_RATE_KNOT)
+		snd_iprintf(buffer, " knot");
+	for (i = 0; i < ARRAY_SIZE(rates); i++)
+		if (dummy_pcm_hardware.rates & (1 << i))
+			snd_iprintf(buffer, " %d", rates[i]);
+}
+
+#define get_dummy_int_ptr(ofs) \
+	(unsigned int *)((char *)&dummy_pcm_hardware + (ofs))
+#define get_dummy_ll_ptr(ofs) \
+	(unsigned long long *)((char *)&dummy_pcm_hardware + (ofs))
+
+struct dummy_hw_field {
+	const char *name;
+	const char *format;
+	unsigned int offset;
+	unsigned int size;
+};
+#define FIELD_ENTRY(item, fmt) {		   \
+	.name = #item,				   \
+	.format = fmt,				   \
+	.offset = offsetof(struct snd_pcm_hardware, item), \
+	.size = sizeof(dummy_pcm_hardware.item) }
+
+static struct dummy_hw_field fields[] = {
+	FIELD_ENTRY(formats, "%#llx"),
+	FIELD_ENTRY(rates, "%#x"),
+	FIELD_ENTRY(rate_min, "%d"),
+	FIELD_ENTRY(rate_max, "%d"),
+	FIELD_ENTRY(channels_min, "%d"),
+	FIELD_ENTRY(channels_max, "%d"),
+	FIELD_ENTRY(buffer_bytes_max, "%ld"),
+	FIELD_ENTRY(period_bytes_min, "%ld"),
+	FIELD_ENTRY(period_bytes_max, "%ld"),
+	FIELD_ENTRY(periods_min, "%d"),
+	FIELD_ENTRY(periods_max, "%d"),
+};
+
+static void dummy_proc_read(struct snd_info_entry *entry,
+			    struct snd_info_buffer *buffer)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(fields); i++) {
+		snd_iprintf(buffer, "%s ", fields[i].name);
+		if (fields[i].size == sizeof(int))
+			snd_iprintf(buffer, fields[i].format,
+				    *get_dummy_int_ptr(fields[i].offset));
+		else
+			snd_iprintf(buffer, fields[i].format,
+				    *get_dummy_ll_ptr(fields[i].offset));
+		if (!strcmp(fields[i].name, "formats"))
+			print_formats(buffer);
+		else if (!strcmp(fields[i].name, "rates"))
+			print_rates(buffer);
+		snd_iprintf(buffer, "\n");
+	}
+}
+
+static void dummy_proc_write(struct snd_info_entry *entry,
+			     struct snd_info_buffer *buffer)
+{
+	char line[64];
+
+	while (!snd_info_get_line(buffer, line, sizeof(line))) {
+		char item[20];
+		const char *ptr;
+		unsigned long long val;
+		int i;
+
+		ptr = snd_info_get_str(item, line, sizeof(item));
+		for (i = 0; i < ARRAY_SIZE(fields); i++) {
+			if (!strcmp(item, fields[i].name))
+				break;
+		}
+		if (i >= ARRAY_SIZE(fields))
+			continue;
+		snd_info_get_str(item, ptr, sizeof(item));
+		if (strict_strtoull(item, 0, &val))
+			continue;
+		if (fields[i].size == sizeof(int))
+			*get_dummy_int_ptr(fields[i].offset) = val;
+		else
+			*get_dummy_ll_ptr(fields[i].offset) = val;
+	}
+}
+
+static void __devinit dummy_proc_init(struct snd_dummy *chip)
+{
+	struct snd_info_entry *entry;
+
+	if (!snd_card_proc_new(chip->card, "dummy_pcm", &entry)) {
+		snd_info_set_text_ops(entry, chip, dummy_proc_read);
+		entry->c.text.write = dummy_proc_write;
+		entry->mode |= S_IWUSR;
+	}
+}
+#else
+#define dummy_proc_init(x)
+#endif /* CONFIG_SND_DEBUG && CONFIG_PROC_FS */
+
 static int __devinit snd_dummy_probe(struct platform_device *devptr)
 {
 	struct snd_card *card;
@@ -845,6 +975,8 @@ static int __devinit snd_dummy_probe(struct platform_device *devptr)
 	strcpy(card->shortname, "Dummy");
 	sprintf(card->longname, "Dummy %i", dev + 1);
 
+	dummy_proc_init(dummy);
+
 	snd_card_set_dev(card, &devptr->dev);
 
 	err = snd_card_register(card);

commit a68c4d11336610dc348620766119db09675707c2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 4 12:19:36 2009 +0200

    ALSA: dummy - Fake buffer allocations
    
    Instead of allocating the real buffers, use a fake buffer and ignore
    read/write in the dummy driver so that we can save the resources.
    For mmap, a single page (unique to the direction, though) is reused
    to all buffers.
    
    When the app requires to read/write the real buffers, pass fake_buffer=0
    module option at loading time.  This will get back to the old behavior.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index e8e29bfb85ec..2ee6c8ebe25a 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -153,6 +153,7 @@ static int pcm_substreams[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 8};
 #ifdef CONFIG_HIGH_RES_TIMERS
 static int hrtimer = 1;
 #endif
+static int fake_buffer = 1;
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for dummy soundcard.");
@@ -166,6 +167,8 @@ module_param_array(pcm_substreams, int, NULL, 0444);
 MODULE_PARM_DESC(pcm_substreams, "PCM substreams # (1-16) for dummy driver.");
 //module_param_array(midi_devs, int, NULL, 0444);
 //MODULE_PARM_DESC(midi_devs, "MIDI devices # (0-2) for dummy driver.");
+module_param(fake_buffer, bool, 0444);
+MODULE_PARM_DESC(fake_buffer, "Fake buffer allocations.");
 #ifdef CONFIG_HIGH_RES_TIMERS
 module_param(hrtimer, bool, 0644);
 MODULE_PARM_DESC(hrtimer, "Use hrtimer as the timer source.");
@@ -481,11 +484,8 @@ static int dummy_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 
 static int dummy_pcm_prepare(struct snd_pcm_substream *substream)
 {
-	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
 
-	snd_pcm_format_set_silence(runtime->format, runtime->dma_area,
-			bytes_to_samples(runtime, runtime->dma_bytes));
 	return dummy->timer_ops->prepare(substream);
 }
 
@@ -518,12 +518,19 @@ static struct snd_pcm_hardware dummy_pcm_hardware = {
 static int dummy_pcm_hw_params(struct snd_pcm_substream *substream,
 			       struct snd_pcm_hw_params *hw_params)
 {
+	if (fake_buffer) {
+		/* runtime->dma_bytes has to be set manually to allow mmap */
+		substream->runtime->dma_bytes = params_buffer_bytes(hw_params);
+		return 0;
+	}
 	return snd_pcm_lib_malloc_pages(substream,
 					params_buffer_bytes(hw_params));
 }
 
 static int dummy_pcm_hw_free(struct snd_pcm_substream *substream)
 {
+	if (fake_buffer)
+		return 0;
 	return snd_pcm_lib_free_pages(substream);
 }
 
@@ -570,6 +577,60 @@ static int dummy_pcm_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
+/*
+ * dummy buffer handling
+ */
+
+static void *dummy_page[2];
+
+static void free_fake_buffer(void)
+{
+	if (fake_buffer) {
+		int i;
+		for (i = 0; i < 2; i++)
+			if (dummy_page[i]) {
+				free_page((unsigned long)dummy_page[i]);
+				dummy_page[i] = NULL;
+			}
+	}
+}
+
+static int alloc_fake_buffer(void)
+{
+	int i;
+
+	if (!fake_buffer)
+		return 0;
+	for (i = 0; i < 2; i++) {
+		dummy_page[i] = (void *)get_zeroed_page(GFP_KERNEL);
+		if (!dummy_page[i]) {
+			free_fake_buffer();
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+static int dummy_pcm_copy(struct snd_pcm_substream *substream,
+			  int channel, snd_pcm_uframes_t pos,
+			  void __user *dst, snd_pcm_uframes_t count)
+{
+	return 0; /* do nothing */
+}
+
+static int dummy_pcm_silence(struct snd_pcm_substream *substream,
+			     int channel, snd_pcm_uframes_t pos,
+			     snd_pcm_uframes_t count)
+{
+	return 0; /* do nothing */
+}
+
+static struct page *dummy_pcm_page(struct snd_pcm_substream *substream,
+				   unsigned long offset)
+{
+	return virt_to_page(dummy_page[substream->stream]); /* the same page */
+}
+
 static struct snd_pcm_ops dummy_pcm_ops = {
 	.open =		dummy_pcm_open,
 	.close =	dummy_pcm_close,
@@ -581,10 +642,25 @@ static struct snd_pcm_ops dummy_pcm_ops = {
 	.pointer =	dummy_pcm_pointer,
 };
 
+static struct snd_pcm_ops dummy_pcm_ops_no_buf = {
+	.open =		dummy_pcm_open,
+	.close =	dummy_pcm_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	dummy_pcm_hw_params,
+	.hw_free =	dummy_pcm_hw_free,
+	.prepare =	dummy_pcm_prepare,
+	.trigger =	dummy_pcm_trigger,
+	.pointer =	dummy_pcm_pointer,
+	.copy =		dummy_pcm_copy,
+	.silence =	dummy_pcm_silence,
+	.page =		dummy_pcm_page,
+};
+
 static int __devinit snd_card_dummy_pcm(struct snd_dummy *dummy, int device,
 					int substreams)
 {
 	struct snd_pcm *pcm;
+	struct snd_pcm_ops *ops;
 	int err;
 
 	err = snd_pcm_new(dummy->card, "Dummy PCM", device,
@@ -592,14 +668,21 @@ static int __devinit snd_card_dummy_pcm(struct snd_dummy *dummy, int device,
 	if (err < 0)
 		return err;
 	dummy->pcm = pcm;
-	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &dummy_pcm_ops);
-	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &dummy_pcm_ops);
+	if (fake_buffer)
+		ops = &dummy_pcm_ops_no_buf;
+	else
+		ops = &dummy_pcm_ops;
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, ops);
 	pcm->private_data = dummy;
 	pcm->info_flags = 0;
 	strcpy(pcm->name, "Dummy PCM");
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
-					      snd_dma_continuous_data(GFP_KERNEL),
-					      0, 64*1024);
+	if (!fake_buffer) {
+		snd_pcm_lib_preallocate_pages_for_all(pcm,
+			SNDRV_DMA_TYPE_CONTINUOUS,
+			snd_dma_continuous_data(GFP_KERNEL),
+			0, 64*1024);
+	}
 	return 0;
 }
 
@@ -822,6 +905,7 @@ static void snd_dummy_unregister_all(void)
 	for (i = 0; i < ARRAY_SIZE(devices); ++i)
 		platform_device_unregister(devices[i]);
 	platform_driver_unregister(&snd_dummy_driver);
+	free_fake_buffer();
 }
 
 static int __init alsa_card_dummy_init(void)
@@ -832,6 +916,12 @@ static int __init alsa_card_dummy_init(void)
 	if (err < 0)
 		return err;
 
+	err = alloc_fake_buffer();
+	if (err < 0) {
+		platform_driver_unregister(&snd_dummy_driver);
+		return err;
+	}
+
 	cards = 0;
 	for (i = 0; i < SNDRV_CARDS; i++) {
 		struct platform_device *device;

commit b5d10781731ece07bb2049e7743907194a5cc3f1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 4 08:45:11 2009 +0200

    ALSA: dummy - Fix the timer calculation in systimer mode
    
    Fix the expire-time calculation in the systimer mode when the buffer
    size isn't aligned to the period size.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 0a798bde0d03..e8e29bfb85ec 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -207,19 +207,18 @@ struct dummy_systimer_pcm {
 	struct timer_list timer;
 	unsigned long base_time;
 	unsigned int frac_pos;	/* fractional sample position (based HZ) */
+	unsigned int frac_period_rest;
 	unsigned int frac_buffer_size;	/* buffer_size * HZ */
 	unsigned int frac_period_size;	/* period_size * HZ */
 	unsigned int rate;
+	int elapsed;
 	struct snd_pcm_substream *substream;
 };
 
 static void dummy_systimer_rearm(struct dummy_systimer_pcm *dpcm)
 {
-	unsigned long frac;
-
-	frac = dpcm->frac_pos % dpcm->frac_period_size;
 	dpcm->timer.expires = jiffies +
-		(dpcm->frac_period_size + dpcm->rate - 1) / dpcm->rate;
+		(dpcm->frac_period_rest + dpcm->rate - 1) / dpcm->rate;
 	add_timer(&dpcm->timer);
 }
 
@@ -230,10 +229,16 @@ static void dummy_systimer_update(struct dummy_systimer_pcm *dpcm)
 	delta = jiffies - dpcm->base_time;
 	if (!delta)
 		return;
-	dpcm->base_time = jiffies;
-	dpcm->frac_pos += delta * dpcm->rate;
+	dpcm->base_time += delta;
+	delta *= dpcm->rate;
+	dpcm->frac_pos += delta;
 	while (dpcm->frac_pos >= dpcm->frac_buffer_size)
 		dpcm->frac_pos -= dpcm->frac_buffer_size;
+	while (dpcm->frac_period_rest <= delta) {
+		dpcm->elapsed++;
+		dpcm->frac_period_rest += dpcm->frac_period_size;
+	}
+	dpcm->frac_period_rest -= delta;
 }
 
 static int dummy_systimer_start(struct snd_pcm_substream *substream)
@@ -264,6 +269,8 @@ static int dummy_systimer_prepare(struct snd_pcm_substream *substream)
 	dpcm->rate = runtime->rate;
 	dpcm->frac_buffer_size = runtime->buffer_size * HZ;
 	dpcm->frac_period_size = runtime->period_size * HZ;
+	dpcm->frac_period_rest = dpcm->frac_period_size;
+	dpcm->elapsed = 0;
 
 	return 0;
 }
@@ -272,23 +279,29 @@ static void dummy_systimer_callback(unsigned long data)
 {
 	struct dummy_systimer_pcm *dpcm = (struct dummy_systimer_pcm *)data;
 	unsigned long flags;
+	int elapsed = 0;
 	
 	spin_lock_irqsave(&dpcm->lock, flags);
 	dummy_systimer_update(dpcm);
 	dummy_systimer_rearm(dpcm);
+	elapsed = dpcm->elapsed;
+	dpcm->elapsed = 0;
 	spin_unlock_irqrestore(&dpcm->lock, flags);
-	snd_pcm_period_elapsed(dpcm->substream);
+	if (elapsed)
+		snd_pcm_period_elapsed(dpcm->substream);
 }
 
 static snd_pcm_uframes_t
 dummy_systimer_pointer(struct snd_pcm_substream *substream)
 {
 	struct dummy_systimer_pcm *dpcm = substream->runtime->private_data;
+	snd_pcm_uframes_t pos;
 
 	spin_lock(&dpcm->lock);
 	dummy_systimer_update(dpcm);
+	pos = dpcm->frac_pos / HZ;
 	spin_unlock(&dpcm->lock);
-	return dpcm->frac_pos / HZ;
+	return pos;
 }
 
 static int dummy_systimer_create(struct snd_pcm_substream *substream)

commit b142037b4c1edf5ad0b2871c518d4f14ac1cd470
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 3 16:01:06 2009 +0200

    ALSA: dummy - Better jiffies handling
    
    In the system-timer mode, snd-dummy driver issues each tick to update
    the position.  This is highly inefficient and even inaccurate if the
    timer can't be triggered at each tick.
    
    Now rewritten to wake up only at the period boundary.  The position
    is calculated from the current jiffies.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index f387d53e5039..0a798bde0d03 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -205,21 +205,43 @@ struct snd_dummy {
 struct dummy_systimer_pcm {
 	spinlock_t lock;
 	struct timer_list timer;
-	unsigned int pcm_buffer_size;
-	unsigned int pcm_period_size;
-	unsigned int pcm_bps;		/* bytes per second */
-	unsigned int pcm_hz;		/* HZ */
-	unsigned int pcm_irq_pos;	/* IRQ position */
-	unsigned int pcm_buf_pos;	/* position in buffer */
+	unsigned long base_time;
+	unsigned int frac_pos;	/* fractional sample position (based HZ) */
+	unsigned int frac_buffer_size;	/* buffer_size * HZ */
+	unsigned int frac_period_size;	/* period_size * HZ */
+	unsigned int rate;
 	struct snd_pcm_substream *substream;
 };
 
+static void dummy_systimer_rearm(struct dummy_systimer_pcm *dpcm)
+{
+	unsigned long frac;
+
+	frac = dpcm->frac_pos % dpcm->frac_period_size;
+	dpcm->timer.expires = jiffies +
+		(dpcm->frac_period_size + dpcm->rate - 1) / dpcm->rate;
+	add_timer(&dpcm->timer);
+}
+
+static void dummy_systimer_update(struct dummy_systimer_pcm *dpcm)
+{
+	unsigned long delta;
+
+	delta = jiffies - dpcm->base_time;
+	if (!delta)
+		return;
+	dpcm->base_time = jiffies;
+	dpcm->frac_pos += delta * dpcm->rate;
+	while (dpcm->frac_pos >= dpcm->frac_buffer_size)
+		dpcm->frac_pos -= dpcm->frac_buffer_size;
+}
+
 static int dummy_systimer_start(struct snd_pcm_substream *substream)
 {
 	struct dummy_systimer_pcm *dpcm = substream->runtime->private_data;
 	spin_lock(&dpcm->lock);
-	dpcm->timer.expires = 1 + jiffies;
-	add_timer(&dpcm->timer);
+	dpcm->base_time = jiffies;
+	dummy_systimer_rearm(dpcm);
 	spin_unlock(&dpcm->lock);
 	return 0;
 }
@@ -237,20 +259,11 @@ static int dummy_systimer_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct dummy_systimer_pcm *dpcm = runtime->private_data;
-	int bps;
 
-	bps = snd_pcm_format_width(runtime->format) * runtime->rate *
-		runtime->channels / 8;
-
-	if (bps <= 0)
-		return -EINVAL;
-
-	dpcm->pcm_bps = bps;
-	dpcm->pcm_hz = HZ;
-	dpcm->pcm_buffer_size = snd_pcm_lib_buffer_bytes(substream);
-	dpcm->pcm_period_size = snd_pcm_lib_period_bytes(substream);
-	dpcm->pcm_irq_pos = 0;
-	dpcm->pcm_buf_pos = 0;
+	dpcm->frac_pos = 0;
+	dpcm->rate = runtime->rate;
+	dpcm->frac_buffer_size = runtime->buffer_size * HZ;
+	dpcm->frac_period_size = runtime->period_size * HZ;
 
 	return 0;
 }
@@ -261,26 +274,21 @@ static void dummy_systimer_callback(unsigned long data)
 	unsigned long flags;
 	
 	spin_lock_irqsave(&dpcm->lock, flags);
-	dpcm->timer.expires = 1 + jiffies;
-	add_timer(&dpcm->timer);
-	dpcm->pcm_irq_pos += dpcm->pcm_bps;
-	dpcm->pcm_buf_pos += dpcm->pcm_bps;
-	dpcm->pcm_buf_pos %= dpcm->pcm_buffer_size * dpcm->pcm_hz;
-	if (dpcm->pcm_irq_pos >= dpcm->pcm_period_size * dpcm->pcm_hz) {
-		dpcm->pcm_irq_pos %= dpcm->pcm_period_size * dpcm->pcm_hz;
-		spin_unlock_irqrestore(&dpcm->lock, flags);
-		snd_pcm_period_elapsed(dpcm->substream);
-	} else
-		spin_unlock_irqrestore(&dpcm->lock, flags);
+	dummy_systimer_update(dpcm);
+	dummy_systimer_rearm(dpcm);
+	spin_unlock_irqrestore(&dpcm->lock, flags);
+	snd_pcm_period_elapsed(dpcm->substream);
 }
 
 static snd_pcm_uframes_t
 dummy_systimer_pointer(struct snd_pcm_substream *substream)
 {
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct dummy_systimer_pcm *dpcm = runtime->private_data;
+	struct dummy_systimer_pcm *dpcm = substream->runtime->private_data;
 
-	return bytes_to_frames(runtime, dpcm->pcm_buf_pos / dpcm->pcm_hz);
+	spin_lock(&dpcm->lock);
+	dummy_systimer_update(dpcm);
+	spin_unlock(&dpcm->lock);
+	return dpcm->frac_pos / HZ;
 }
 
 static int dummy_systimer_create(struct snd_pcm_substream *substream)

commit c631d03c6873b9e17906556e84fcafc42f26a7c2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 3 15:59:26 2009 +0200

    ALSA: dummy - Support high-res timer mode
    
    Allow snd-dummy driver to use high-res timer as its timing source
    instead of the system timer.  The new module option "hrtimer" is added
    to turn on/off the high-res timer support.  It can be switched even
    dynamically via sysfs.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 54239d2e0997..f387d53e5039 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -25,6 +25,8 @@
 #include <linux/slab.h>
 #include <linux/time.h>
 #include <linux/wait.h>
+#include <linux/hrtimer.h>
+#include <linux/math64.h>
 #include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/control.h>
@@ -148,6 +150,9 @@ static int enable[SNDRV_CARDS] = {1, [1 ... (SNDRV_CARDS - 1)] = 0};
 static int pcm_devs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};
 static int pcm_substreams[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 8};
 //static int midi_devs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
+#ifdef CONFIG_HIGH_RES_TIMERS
+static int hrtimer = 1;
+#endif
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for dummy soundcard.");
@@ -161,6 +166,10 @@ module_param_array(pcm_substreams, int, NULL, 0444);
 MODULE_PARM_DESC(pcm_substreams, "PCM substreams # (1-16) for dummy driver.");
 //module_param_array(midi_devs, int, NULL, 0444);
 //MODULE_PARM_DESC(midi_devs, "MIDI devices # (0-2) for dummy driver.");
+#ifdef CONFIG_HIGH_RES_TIMERS
+module_param(hrtimer, bool, 0644);
+MODULE_PARM_DESC(hrtimer, "Use hrtimer as the timer source.");
+#endif
 
 static struct platform_device *devices[SNDRV_CARDS];
 
@@ -171,16 +180,29 @@ static struct platform_device *devices[SNDRV_CARDS];
 #define MIXER_ADDR_CD		4
 #define MIXER_ADDR_LAST		4
 
+struct dummy_timer_ops {
+	int (*create)(struct snd_pcm_substream *);
+	void (*free)(struct snd_pcm_substream *);
+	int (*prepare)(struct snd_pcm_substream *);
+	int (*start)(struct snd_pcm_substream *);
+	int (*stop)(struct snd_pcm_substream *);
+	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *);
+};
+
 struct snd_dummy {
 	struct snd_card *card;
 	struct snd_pcm *pcm;
 	spinlock_t mixer_lock;
 	int mixer_volume[MIXER_ADDR_LAST+1][2];
 	int capture_source[MIXER_ADDR_LAST+1][2];
+	const struct dummy_timer_ops *timer_ops;
 };
 
-struct snd_dummy_pcm {
-	struct snd_dummy *dummy;
+/*
+ * system timer interface
+ */
+
+struct dummy_systimer_pcm {
 	spinlock_t lock;
 	struct timer_list timer;
 	unsigned int pcm_buffer_size;
@@ -192,46 +214,29 @@ struct snd_dummy_pcm {
 	struct snd_pcm_substream *substream;
 };
 
-
-static inline void snd_card_dummy_pcm_timer_start(struct snd_dummy_pcm *dpcm)
+static int dummy_systimer_start(struct snd_pcm_substream *substream)
 {
+	struct dummy_systimer_pcm *dpcm = substream->runtime->private_data;
+	spin_lock(&dpcm->lock);
 	dpcm->timer.expires = 1 + jiffies;
 	add_timer(&dpcm->timer);
+	spin_unlock(&dpcm->lock);
+	return 0;
 }
 
-static inline void snd_card_dummy_pcm_timer_stop(struct snd_dummy_pcm *dpcm)
-{
-	del_timer(&dpcm->timer);
-}
-
-static int snd_card_dummy_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+static int dummy_systimer_stop(struct snd_pcm_substream *substream)
 {
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_dummy_pcm *dpcm = runtime->private_data;
-	int err = 0;
-
+	struct dummy_systimer_pcm *dpcm = substream->runtime->private_data;
 	spin_lock(&dpcm->lock);
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-		snd_card_dummy_pcm_timer_start(dpcm);
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-		snd_card_dummy_pcm_timer_stop(dpcm);
-		break;
-	default:
-		err = -EINVAL;
-		break;
-	}
+	del_timer(&dpcm->timer);
 	spin_unlock(&dpcm->lock);
 	return 0;
 }
 
-static int snd_card_dummy_pcm_prepare(struct snd_pcm_substream *substream)
+static int dummy_systimer_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_dummy_pcm *dpcm = runtime->private_data;
+	struct dummy_systimer_pcm *dpcm = runtime->private_data;
 	int bps;
 
 	bps = snd_pcm_format_width(runtime->format) * runtime->rate *
@@ -247,15 +252,12 @@ static int snd_card_dummy_pcm_prepare(struct snd_pcm_substream *substream)
 	dpcm->pcm_irq_pos = 0;
 	dpcm->pcm_buf_pos = 0;
 
-	snd_pcm_format_set_silence(runtime->format, runtime->dma_area,
-			bytes_to_samples(runtime, runtime->dma_bytes));
-
 	return 0;
 }
 
-static void snd_card_dummy_pcm_timer_function(unsigned long data)
+static void dummy_systimer_callback(unsigned long data)
 {
-	struct snd_dummy_pcm *dpcm = (struct snd_dummy_pcm *)data;
+	struct dummy_systimer_pcm *dpcm = (struct dummy_systimer_pcm *)data;
 	unsigned long flags;
 	
 	spin_lock_irqsave(&dpcm->lock, flags);
@@ -272,36 +274,212 @@ static void snd_card_dummy_pcm_timer_function(unsigned long data)
 		spin_unlock_irqrestore(&dpcm->lock, flags);
 }
 
-static snd_pcm_uframes_t snd_card_dummy_pcm_pointer(struct snd_pcm_substream *substream)
+static snd_pcm_uframes_t
+dummy_systimer_pointer(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_dummy_pcm *dpcm = runtime->private_data;
+	struct dummy_systimer_pcm *dpcm = runtime->private_data;
 
 	return bytes_to_frames(runtime, dpcm->pcm_buf_pos / dpcm->pcm_hz);
 }
 
-static struct snd_pcm_hardware snd_card_dummy_playback =
+static int dummy_systimer_create(struct snd_pcm_substream *substream)
 {
-	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
-				 SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),
-	.formats =		USE_FORMATS,
-	.rates =		USE_RATE,
-	.rate_min =		USE_RATE_MIN,
-	.rate_max =		USE_RATE_MAX,
-	.channels_min =		USE_CHANNELS_MIN,
-	.channels_max =		USE_CHANNELS_MAX,
-	.buffer_bytes_max =	MAX_BUFFER_SIZE,
-	.period_bytes_min =	64,
-	.period_bytes_max =	MAX_PERIOD_SIZE,
-	.periods_min =		USE_PERIODS_MIN,
-	.periods_max =		USE_PERIODS_MAX,
-	.fifo_size =		0,
+	struct dummy_systimer_pcm *dpcm;
+
+	dpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);
+	if (!dpcm)
+		return -ENOMEM;
+	substream->runtime->private_data = dpcm;
+	init_timer(&dpcm->timer);
+	dpcm->timer.data = (unsigned long) dpcm;
+	dpcm->timer.function = dummy_systimer_callback;
+	spin_lock_init(&dpcm->lock);
+	dpcm->substream = substream;
+	return 0;
+}
+
+static void dummy_systimer_free(struct snd_pcm_substream *substream)
+{
+	kfree(substream->runtime->private_data);
+}
+
+static struct dummy_timer_ops dummy_systimer_ops = {
+	.create =	dummy_systimer_create,
+	.free =		dummy_systimer_free,
+	.prepare =	dummy_systimer_prepare,
+	.start =	dummy_systimer_start,
+	.stop =		dummy_systimer_stop,
+	.pointer =	dummy_systimer_pointer,
+};
+
+#ifdef CONFIG_HIGH_RES_TIMERS
+/*
+ * hrtimer interface
+ */
+
+struct dummy_hrtimer_pcm {
+	ktime_t base_time;
+	ktime_t period_time;
+	atomic_t running;
+	struct hrtimer timer;
+	struct tasklet_struct tasklet;
+	struct snd_pcm_substream *substream;
+};
+
+static void dummy_hrtimer_pcm_elapsed(unsigned long priv)
+{
+	struct dummy_hrtimer_pcm *dpcm = (struct dummy_hrtimer_pcm *)priv;
+	if (atomic_read(&dpcm->running))
+		snd_pcm_period_elapsed(dpcm->substream);
+}
+
+static enum hrtimer_restart dummy_hrtimer_callback(struct hrtimer *timer)
+{
+	struct dummy_hrtimer_pcm *dpcm;
+
+	dpcm = container_of(timer, struct dummy_hrtimer_pcm, timer);
+	if (!atomic_read(&dpcm->running))
+		return HRTIMER_NORESTART;
+	tasklet_schedule(&dpcm->tasklet);
+	hrtimer_forward_now(timer, dpcm->period_time);
+	return HRTIMER_RESTART;
+}
+
+static int dummy_hrtimer_start(struct snd_pcm_substream *substream)
+{
+	struct dummy_hrtimer_pcm *dpcm = substream->runtime->private_data;
+
+	dpcm->base_time = hrtimer_cb_get_time(&dpcm->timer);
+	hrtimer_start(&dpcm->timer, dpcm->period_time, HRTIMER_MODE_REL);
+	atomic_set(&dpcm->running, 1);
+	return 0;
+}
+
+static int dummy_hrtimer_stop(struct snd_pcm_substream *substream)
+{
+	struct dummy_hrtimer_pcm *dpcm = substream->runtime->private_data;
+
+	atomic_set(&dpcm->running, 0);
+	hrtimer_cancel(&dpcm->timer);
+	return 0;
+}
+
+static inline void dummy_hrtimer_sync(struct dummy_hrtimer_pcm *dpcm)
+{
+	tasklet_kill(&dpcm->tasklet);
+}
+
+static snd_pcm_uframes_t
+dummy_hrtimer_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct dummy_hrtimer_pcm *dpcm = runtime->private_data;
+	u64 delta;
+	u32 pos;
+
+	delta = ktime_us_delta(hrtimer_cb_get_time(&dpcm->timer),
+			       dpcm->base_time);
+	delta = div_u64(delta * runtime->rate + 999999, 1000000);
+	div_u64_rem(delta, runtime->buffer_size, &pos);
+	return pos;
+}
+
+static int dummy_hrtimer_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct dummy_hrtimer_pcm *dpcm = runtime->private_data;
+	unsigned int period, rate;
+	long sec;
+	unsigned long nsecs;
+
+	dummy_hrtimer_sync(dpcm);
+	period = runtime->period_size;
+	rate = runtime->rate;
+	sec = period / rate;
+	period %= rate;
+	nsecs = div_u64((u64)period * 1000000000UL + rate - 1, rate);
+	dpcm->period_time = ktime_set(sec, nsecs);
+
+	return 0;
+}
+
+static int dummy_hrtimer_create(struct snd_pcm_substream *substream)
+{
+	struct dummy_hrtimer_pcm *dpcm;
+
+	dpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);
+	if (!dpcm)
+		return -ENOMEM;
+	substream->runtime->private_data = dpcm;
+	hrtimer_init(&dpcm->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	dpcm->timer.function = dummy_hrtimer_callback;
+	dpcm->substream = substream;
+	atomic_set(&dpcm->running, 0);
+	tasklet_init(&dpcm->tasklet, dummy_hrtimer_pcm_elapsed,
+		     (unsigned long)dpcm);
+	return 0;
+}
+
+static void dummy_hrtimer_free(struct snd_pcm_substream *substream)
+{
+	struct dummy_hrtimer_pcm *dpcm = substream->runtime->private_data;
+	dummy_hrtimer_sync(dpcm);
+	kfree(dpcm);
+}
+
+static struct dummy_timer_ops dummy_hrtimer_ops = {
+	.create =	dummy_hrtimer_create,
+	.free =		dummy_hrtimer_free,
+	.prepare =	dummy_hrtimer_prepare,
+	.start =	dummy_hrtimer_start,
+	.stop =		dummy_hrtimer_stop,
+	.pointer =	dummy_hrtimer_pointer,
 };
 
-static struct snd_pcm_hardware snd_card_dummy_capture =
+#endif /* CONFIG_HIGH_RES_TIMERS */
+
+/*
+ * PCM interface
+ */
+
+static int dummy_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		return dummy->timer_ops->start(substream);
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		return dummy->timer_ops->stop(substream);
+	}
+	return -EINVAL;
+}
+
+static int dummy_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
+
+	snd_pcm_format_set_silence(runtime->format, runtime->dma_area,
+			bytes_to_samples(runtime, runtime->dma_bytes));
+	return dummy->timer_ops->prepare(substream);
+}
+
+static snd_pcm_uframes_t dummy_pcm_pointer(struct snd_pcm_substream *substream)
 {
-	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
-				 SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),
+	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
+
+	return dummy->timer_ops->pointer(substream);
+}
+
+static struct snd_pcm_hardware dummy_pcm_hardware = {
+	.info =			(SNDRV_PCM_INFO_MMAP |
+				 SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_RESUME |
+				 SNDRV_PCM_INFO_MMAP_VALID),
 	.formats =		USE_FORMATS,
 	.rates =		USE_RATE,
 	.rate_min =		USE_RATE_MIN,
@@ -316,117 +494,70 @@ static struct snd_pcm_hardware snd_card_dummy_capture =
 	.fifo_size =		0,
 };
 
-static void snd_card_dummy_runtime_free(struct snd_pcm_runtime *runtime)
-{
-	kfree(runtime->private_data);
-}
-
-static int snd_card_dummy_hw_params(struct snd_pcm_substream *substream,
-				    struct snd_pcm_hw_params *hw_params)
+static int dummy_pcm_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *hw_params)
 {
-	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+	return snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
 }
 
-static int snd_card_dummy_hw_free(struct snd_pcm_substream *substream)
+static int dummy_pcm_hw_free(struct snd_pcm_substream *substream)
 {
 	return snd_pcm_lib_free_pages(substream);
 }
 
-static struct snd_dummy_pcm *new_pcm_stream(struct snd_pcm_substream *substream)
-{
-	struct snd_dummy_pcm *dpcm;
-
-	dpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);
-	if (! dpcm)
-		return dpcm;
-	init_timer(&dpcm->timer);
-	dpcm->timer.data = (unsigned long) dpcm;
-	dpcm->timer.function = snd_card_dummy_pcm_timer_function;
-	spin_lock_init(&dpcm->lock);
-	dpcm->substream = substream;
-	return dpcm;
-}
-
-static int snd_card_dummy_playback_open(struct snd_pcm_substream *substream)
+static int dummy_pcm_open(struct snd_pcm_substream *substream)
 {
+	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_dummy_pcm *dpcm;
 	int err;
 
-	if ((dpcm = new_pcm_stream(substream)) == NULL)
-		return -ENOMEM;
-	runtime->private_data = dpcm;
-	/* makes the infrastructure responsible for freeing dpcm */
-	runtime->private_free = snd_card_dummy_runtime_free;
-	runtime->hw = snd_card_dummy_playback;
-	if (substream->pcm->device & 1) {
-		runtime->hw.info &= ~SNDRV_PCM_INFO_INTERLEAVED;
-		runtime->hw.info |= SNDRV_PCM_INFO_NONINTERLEAVED;
-	}
-	if (substream->pcm->device & 2)
-		runtime->hw.info &= ~(SNDRV_PCM_INFO_MMAP|SNDRV_PCM_INFO_MMAP_VALID);
-	err = add_playback_constraints(runtime);
+	dummy->timer_ops = &dummy_systimer_ops;
+#ifdef CONFIG_HIGH_RES_TIMERS
+	if (hrtimer)
+		dummy->timer_ops = &dummy_hrtimer_ops;
+#endif
+
+	err = dummy->timer_ops->create(substream);
 	if (err < 0)
 		return err;
 
-	return 0;
-}
-
-static int snd_card_dummy_capture_open(struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_dummy_pcm *dpcm;
-	int err;
-
-	if ((dpcm = new_pcm_stream(substream)) == NULL)
-		return -ENOMEM;
-	runtime->private_data = dpcm;
-	/* makes the infrastructure responsible for freeing dpcm */
-	runtime->private_free = snd_card_dummy_runtime_free;
-	runtime->hw = snd_card_dummy_capture;
-	if (substream->pcm->device == 1) {
+	runtime->hw = dummy_pcm_hardware;
+	if (substream->pcm->device & 1) {
 		runtime->hw.info &= ~SNDRV_PCM_INFO_INTERLEAVED;
 		runtime->hw.info |= SNDRV_PCM_INFO_NONINTERLEAVED;
 	}
 	if (substream->pcm->device & 2)
-		runtime->hw.info &= ~(SNDRV_PCM_INFO_MMAP|SNDRV_PCM_INFO_MMAP_VALID);
-	err = add_capture_constraints(runtime);
-	if (err < 0)
+		runtime->hw.info &= ~(SNDRV_PCM_INFO_MMAP |
+				      SNDRV_PCM_INFO_MMAP_VALID);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		err = add_playback_constraints(substream->runtime);
+	else
+		err = add_capture_constraints(substream->runtime);
+	if (err < 0) {
+		dummy->timer_ops->free(substream);
 		return err;
-
-	return 0;
-}
-
-static int snd_card_dummy_playback_close(struct snd_pcm_substream *substream)
-{
+	}
 	return 0;
 }
 
-static int snd_card_dummy_capture_close(struct snd_pcm_substream *substream)
+static int dummy_pcm_close(struct snd_pcm_substream *substream)
 {
+	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
+	dummy->timer_ops->free(substream);
 	return 0;
 }
 
-static struct snd_pcm_ops snd_card_dummy_playback_ops = {
-	.open =			snd_card_dummy_playback_open,
-	.close =		snd_card_dummy_playback_close,
-	.ioctl =		snd_pcm_lib_ioctl,
-	.hw_params =		snd_card_dummy_hw_params,
-	.hw_free =		snd_card_dummy_hw_free,
-	.prepare =		snd_card_dummy_pcm_prepare,
-	.trigger =		snd_card_dummy_pcm_trigger,
-	.pointer =		snd_card_dummy_pcm_pointer,
-};
-
-static struct snd_pcm_ops snd_card_dummy_capture_ops = {
-	.open =			snd_card_dummy_capture_open,
-	.close =		snd_card_dummy_capture_close,
-	.ioctl =		snd_pcm_lib_ioctl,
-	.hw_params =		snd_card_dummy_hw_params,
-	.hw_free =		snd_card_dummy_hw_free,
-	.prepare =		snd_card_dummy_pcm_prepare,
-	.trigger =		snd_card_dummy_pcm_trigger,
-	.pointer =		snd_card_dummy_pcm_pointer,
+static struct snd_pcm_ops dummy_pcm_ops = {
+	.open =		dummy_pcm_open,
+	.close =	dummy_pcm_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	dummy_pcm_hw_params,
+	.hw_free =	dummy_pcm_hw_free,
+	.prepare =	dummy_pcm_prepare,
+	.trigger =	dummy_pcm_trigger,
+	.pointer =	dummy_pcm_pointer,
 };
 
 static int __devinit snd_card_dummy_pcm(struct snd_dummy *dummy, int device,
@@ -440,8 +571,8 @@ static int __devinit snd_card_dummy_pcm(struct snd_dummy *dummy, int device,
 	if (err < 0)
 		return err;
 	dummy->pcm = pcm;
-	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_card_dummy_playback_ops);
-	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_card_dummy_capture_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &dummy_pcm_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &dummy_pcm_ops);
 	pcm->private_data = dummy;
 	pcm->info_flags = 0;
 	strcpy(pcm->name, "Dummy PCM");

commit bd7dd77c2a05c530684eea2e3af16449ae9c5d52
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:45:02 2008 +0100

    ALSA: Convert to snd_card_create() in other sound/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in other sound subdirectories.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 73be7e14a603..54239d2e0997 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -588,10 +588,10 @@ static int __devinit snd_dummy_probe(struct platform_device *devptr)
 	int idx, err;
 	int dev = devptr->id;
 
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE,
-			    sizeof(struct snd_dummy));
-	if (card == NULL)
-		return -ENOMEM;
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE,
+			      sizeof(struct snd_dummy), &card);
+	if (err < 0)
+		return err;
 	dummy = card->private_data;
 	dummy->card = card;
 	for (idx = 0; idx < MAX_PCM_DEVICES && idx < pcm_devs[dev]; idx++) {

commit e78521f3212d5d3931442819cbf0910fe1b28beb
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Sun Oct 19 10:34:22 2008 +0200

    ALSA: misc typo fixes
    
    Fixed typos in disabled codes via #if 0.
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index e5e749f3e0ef..73be7e14a603 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -51,7 +51,7 @@ static int emu10k1_playback_constraints(struct snd_pcm_runtime *runtime)
 	if (err < 0)
 		return err;
 	err = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 256, UINT_MAX);
-	if (err) < 0)
+	if (err < 0)
 		return err;
 	return 0;
 }

commit 1a11cb6427e65b7cfc9c3ec6eaecd2dba1f2d69a
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Aug 15 12:59:02 2008 +0200

    ALSA: dummy driver - do not use assignment in if condition
    
    checkpatch.pl does not like assignment in if condition
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 4f900d8b92ce..e5e749f3e0ef 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -47,9 +47,11 @@ MODULE_SUPPORTED_DEVICE("{{ALSA,Dummy soundcard}}");
 static int emu10k1_playback_constraints(struct snd_pcm_runtime *runtime)
 {
 	int err;
-	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+	err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	if (err < 0)
 		return err;
-	if ((err = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 256, UINT_MAX)) < 0)
+	err = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 256, UINT_MAX);
+	if (err) < 0)
 		return err;
 	return 0;
 }
@@ -363,7 +365,8 @@ static int snd_card_dummy_playback_open(struct snd_pcm_substream *substream)
 	}
 	if (substream->pcm->device & 2)
 		runtime->hw.info &= ~(SNDRV_PCM_INFO_MMAP|SNDRV_PCM_INFO_MMAP_VALID);
-	if ((err = add_playback_constraints(runtime)) < 0)
+	err = add_playback_constraints(runtime);
+	if (err < 0)
 		return err;
 
 	return 0;
@@ -387,7 +390,8 @@ static int snd_card_dummy_capture_open(struct snd_pcm_substream *substream)
 	}
 	if (substream->pcm->device & 2)
 		runtime->hw.info &= ~(SNDRV_PCM_INFO_MMAP|SNDRV_PCM_INFO_MMAP_VALID);
-	if ((err = add_capture_constraints(runtime)) < 0)
+	err = add_capture_constraints(runtime);
+	if (err < 0)
 		return err;
 
 	return 0;
@@ -431,8 +435,9 @@ static int __devinit snd_card_dummy_pcm(struct snd_dummy *dummy, int device,
 	struct snd_pcm *pcm;
 	int err;
 
-	if ((err = snd_pcm_new(dummy->card, "Dummy PCM", device,
-			       substreams, substreams, &pcm)) < 0)
+	err = snd_pcm_new(dummy->card, "Dummy PCM", device,
+			       substreams, substreams, &pcm);
+	if (err < 0)
 		return err;
 	dummy->pcm = pcm;
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_card_dummy_playback_ops);
@@ -569,7 +574,8 @@ static int __devinit snd_card_dummy_new_mixer(struct snd_dummy *dummy)
 	strcpy(card->mixername, "Dummy Mixer");
 
 	for (idx = 0; idx < ARRAY_SIZE(snd_dummy_controls); idx++) {
-		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_dummy_controls[idx], dummy))) < 0)
+		err = snd_ctl_add(card, snd_ctl_new1(&snd_dummy_controls[idx], dummy));
+		if (err < 0)
 			return err;
 	}
 	return 0;
@@ -593,10 +599,12 @@ static int __devinit snd_dummy_probe(struct platform_device *devptr)
 			pcm_substreams[dev] = 1;
 		if (pcm_substreams[dev] > MAX_PCM_SUBSTREAMS)
 			pcm_substreams[dev] = MAX_PCM_SUBSTREAMS;
-		if ((err = snd_card_dummy_pcm(dummy, idx, pcm_substreams[dev])) < 0)
+		err = snd_card_dummy_pcm(dummy, idx, pcm_substreams[dev]);
+		if (err < 0)
 			goto __nodev;
 	}
-	if ((err = snd_card_dummy_new_mixer(dummy)) < 0)
+	err = snd_card_dummy_new_mixer(dummy);
+	if (err < 0)
 		goto __nodev;
 	strcpy(card->driver, "Dummy");
 	strcpy(card->shortname, "Dummy");
@@ -604,7 +612,8 @@ static int __devinit snd_dummy_probe(struct platform_device *devptr)
 
 	snd_card_set_dev(card, &devptr->dev);
 
-	if ((err = snd_card_register(card)) == 0) {
+	err = snd_card_register(card);
+	if (err == 0) {
 		platform_set_drvdata(devptr, card);
 		return 0;
 	}
@@ -667,7 +676,8 @@ static int __init alsa_card_dummy_init(void)
 {
 	int i, cards, err;
 
-	if ((err = platform_driver_register(&snd_dummy_driver)) < 0)
+	err = platform_driver_register(&snd_dummy_driver);
+	if (err < 0)
 		return err;
 
 	cards = 0;

commit 54e8e21ed21ca8788aa75294067494abebf9d550
Author: Daniel THOMPSON <daniel.thompson@st.com>
Date:   Fri Aug 15 10:53:38 2008 +0100

    sound: Fix esoteric double free in the dummy sound driver.
    
    The dummy driver uses runtime->private_free but still frees
    its pcm structures on error paths.
    
    This is esoteric because the error paths in question are
    unreachable. Thus the bug is only a problem when someone
    copies this code into other drivers.
    
    Signed-off-by: Daniel R Thompson <daniel.thompson@st.com>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index c873243e6713..4f900d8b92ce 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -354,6 +354,7 @@ static int snd_card_dummy_playback_open(struct snd_pcm_substream *substream)
 	if ((dpcm = new_pcm_stream(substream)) == NULL)
 		return -ENOMEM;
 	runtime->private_data = dpcm;
+	/* makes the infrastructure responsible for freeing dpcm */
 	runtime->private_free = snd_card_dummy_runtime_free;
 	runtime->hw = snd_card_dummy_playback;
 	if (substream->pcm->device & 1) {
@@ -362,10 +363,8 @@ static int snd_card_dummy_playback_open(struct snd_pcm_substream *substream)
 	}
 	if (substream->pcm->device & 2)
 		runtime->hw.info &= ~(SNDRV_PCM_INFO_MMAP|SNDRV_PCM_INFO_MMAP_VALID);
-	if ((err = add_playback_constraints(runtime)) < 0) {
-		kfree(dpcm);
+	if ((err = add_playback_constraints(runtime)) < 0)
 		return err;
-	}
 
 	return 0;
 }
@@ -379,6 +378,7 @@ static int snd_card_dummy_capture_open(struct snd_pcm_substream *substream)
 	if ((dpcm = new_pcm_stream(substream)) == NULL)
 		return -ENOMEM;
 	runtime->private_data = dpcm;
+	/* makes the infrastructure responsible for freeing dpcm */
 	runtime->private_free = snd_card_dummy_runtime_free;
 	runtime->hw = snd_card_dummy_capture;
 	if (substream->pcm->device == 1) {
@@ -387,10 +387,8 @@ static int snd_card_dummy_capture_open(struct snd_pcm_substream *substream)
 	}
 	if (substream->pcm->device & 2)
 		runtime->hw.info &= ~(SNDRV_PCM_INFO_MMAP|SNDRV_PCM_INFO_MMAP_VALID);
-	if ((err = add_capture_constraints(runtime)) < 0) {
-		kfree(dpcm);
+	if ((err = add_capture_constraints(runtime)) < 0)
 		return err;
-	}
 
 	return 0;
 }

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 4e4c69e6cb4c..c873243e6713 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -565,7 +565,8 @@ static int __devinit snd_card_dummy_new_mixer(struct snd_dummy *dummy)
 	unsigned int idx;
 	int err;
 
-	snd_assert(dummy != NULL, return -EINVAL);
+	if (snd_BUG_ON(!dummy))
+		return -EINVAL;
 	spin_lock_init(&dummy->mixer_lock);
 	strcpy(card->mixername, "Dummy Mixer");
 

commit 369b240d6391aef41d376c9e8769fd939c7c6c4d
Author: Roel Kluin <12o3l@tiscali.nl>
Date:   Wed Apr 16 19:30:30 2008 +0200

    [ALSA] sound/drivers/dummy.c: fix negative snd_pcm_format_width() check
    
    bps is unsigned, a negative snd_pcm_format_width() return value is not noticed
    
    Signed-off-by: Roel Kluin <12o3l@tiscali.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 83ac4980c5fb..4e4c69e6cb4c 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -230,13 +230,14 @@ static int snd_card_dummy_pcm_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_dummy_pcm *dpcm = runtime->private_data;
-	unsigned int bps;
+	int bps;
+
+	bps = snd_pcm_format_width(runtime->format) * runtime->rate *
+		runtime->channels / 8;
 
-	bps = runtime->rate * runtime->channels;
-	bps *= snd_pcm_format_width(runtime->format);
-	bps /= 8;
 	if (bps <= 0)
 		return -EINVAL;
+
 	dpcm->pcm_bps = bps;
 	dpcm->pcm_hz = HZ;
 	dpcm->pcm_buffer_size = snd_pcm_lib_buffer_bytes(substream);

commit 470f23b873679b045908551302fec6b1edf05a5a
Author: Ahmet nan <ainan at>
Date:   Thu Feb 28 12:46:32 2008 +0100

    [ALSA] snd-dummy - better realtime app support
    
    when the time interval for a period is smaller than kernel HZ, then
    snd-aloop and snd-dummy cannot call snd_pcm_period_elapsed as fast enough
    annymore. this happens for example with games. but the app still needs to
    see, that the buffer actually did go further, which is provided by these
    patches.
    
    Signed-off-by: Ahmet nan <ainan <at> mathematik.uni-freiburg.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index f67f65829f3e..83ac4980c5fb 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -259,10 +259,10 @@ static void snd_card_dummy_pcm_timer_function(unsigned long data)
 	dpcm->timer.expires = 1 + jiffies;
 	add_timer(&dpcm->timer);
 	dpcm->pcm_irq_pos += dpcm->pcm_bps;
+	dpcm->pcm_buf_pos += dpcm->pcm_bps;
+	dpcm->pcm_buf_pos %= dpcm->pcm_buffer_size * dpcm->pcm_hz;
 	if (dpcm->pcm_irq_pos >= dpcm->pcm_period_size * dpcm->pcm_hz) {
 		dpcm->pcm_irq_pos %= dpcm->pcm_period_size * dpcm->pcm_hz;
-		dpcm->pcm_buf_pos += dpcm->pcm_period_size;
-		dpcm->pcm_buf_pos %= dpcm->pcm_buffer_size;
 		spin_unlock_irqrestore(&dpcm->lock, flags);
 		snd_pcm_period_elapsed(dpcm->substream);
 	} else
@@ -274,7 +274,7 @@ static snd_pcm_uframes_t snd_card_dummy_pcm_pointer(struct snd_pcm_substream *su
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_dummy_pcm *dpcm = runtime->private_data;
 
-	return bytes_to_frames(runtime, dpcm->pcm_buf_pos);
+	return bytes_to_frames(runtime, dpcm->pcm_buf_pos / dpcm->pcm_hz);
 }
 
 static struct snd_pcm_hardware snd_card_dummy_playback =

commit 53463a8302d0c3148c4c64c034312215e76429c2
Author: Ahmet nan <ainan at>
Date:   Thu Feb 21 07:55:30 2008 +0100

    [ALSA] snd-dummy - improved timing, silence on prepare
    
    Signed-off-by: Ahmet nan <ainan <at> mathematik.uni-freiburg.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index a240eaeb5c62..f67f65829f3e 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -181,10 +181,10 @@ struct snd_dummy_pcm {
 	struct snd_dummy *dummy;
 	spinlock_t lock;
 	struct timer_list timer;
-	unsigned int pcm_size;
-	unsigned int pcm_count;
+	unsigned int pcm_buffer_size;
+	unsigned int pcm_period_size;
 	unsigned int pcm_bps;		/* bytes per second */
-	unsigned int pcm_jiffie;	/* bytes per one jiffie */
+	unsigned int pcm_hz;		/* HZ */
 	unsigned int pcm_irq_pos;	/* IRQ position */
 	unsigned int pcm_buf_pos;	/* position in buffer */
 	struct snd_pcm_substream *substream;
@@ -238,11 +238,15 @@ static int snd_card_dummy_pcm_prepare(struct snd_pcm_substream *substream)
 	if (bps <= 0)
 		return -EINVAL;
 	dpcm->pcm_bps = bps;
-	dpcm->pcm_jiffie = bps / HZ;
-	dpcm->pcm_size = snd_pcm_lib_buffer_bytes(substream);
-	dpcm->pcm_count = snd_pcm_lib_period_bytes(substream);
+	dpcm->pcm_hz = HZ;
+	dpcm->pcm_buffer_size = snd_pcm_lib_buffer_bytes(substream);
+	dpcm->pcm_period_size = snd_pcm_lib_period_bytes(substream);
 	dpcm->pcm_irq_pos = 0;
 	dpcm->pcm_buf_pos = 0;
+
+	snd_pcm_format_set_silence(runtime->format, runtime->dma_area,
+			bytes_to_samples(runtime, runtime->dma_bytes));
+
 	return 0;
 }
 
@@ -254,11 +258,11 @@ static void snd_card_dummy_pcm_timer_function(unsigned long data)
 	spin_lock_irqsave(&dpcm->lock, flags);
 	dpcm->timer.expires = 1 + jiffies;
 	add_timer(&dpcm->timer);
-	dpcm->pcm_irq_pos += dpcm->pcm_jiffie;
-	dpcm->pcm_buf_pos += dpcm->pcm_jiffie;
-	dpcm->pcm_buf_pos %= dpcm->pcm_size;
-	if (dpcm->pcm_irq_pos >= dpcm->pcm_count) {
-		dpcm->pcm_irq_pos %= dpcm->pcm_count;
+	dpcm->pcm_irq_pos += dpcm->pcm_bps;
+	if (dpcm->pcm_irq_pos >= dpcm->pcm_period_size * dpcm->pcm_hz) {
+		dpcm->pcm_irq_pos %= dpcm->pcm_period_size * dpcm->pcm_hz;
+		dpcm->pcm_buf_pos += dpcm->pcm_period_size;
+		dpcm->pcm_buf_pos %= dpcm->pcm_buffer_size;
 		spin_unlock_irqrestore(&dpcm->lock, flags);
 		snd_pcm_period_elapsed(dpcm->substream);
 	} else

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index e008f3c58eac..a240eaeb5c62 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -18,7 +18,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/err.h>
 #include <linux/platform_device.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 77bca5fdda50..e008f3c58eac 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -1,6 +1,6 @@
 /*
  *  Dummy soundcard
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -34,7 +34,7 @@
 #include <sound/rawmidi.h>
 #include <sound/initval.h>
 
-MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");
 MODULE_DESCRIPTION("Dummy soundcard (/dev/null)");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{ALSA,Dummy soundcard}}");

commit a5ce88909d3007caa7b65996a8f6784350beb2a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 23 15:42:26 2007 +0200

    [ALSA] Clean up with common snd_ctl_boolean_*_info callbacks
    
    Clean up codes using the new common snd_ctl_boolean_*_info() callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 4360ae9de19c..77bca5fdda50 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -510,15 +510,7 @@ static const DECLARE_TLV_DB_SCALE(db_scale_dummy, -4500, 30, 0);
   .get = snd_dummy_capsrc_get, .put = snd_dummy_capsrc_put, \
   .private_value = addr }
 
-static int snd_dummy_capsrc_info(struct snd_kcontrol *kcontrol,
-				 struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 2;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_dummy_capsrc_info	snd_ctl_boolean_stereo_info
  
 static int snd_dummy_capsrc_get(struct snd_kcontrol *kcontrol,
 				struct snd_ctl_elem_value *ucontrol)

commit c12aad6efbee1d937438f1deabbef695add0628b
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Jun 25 12:08:01 2007 +0200

    [ALSA] more section mismatches
    
    Something about __init_or_module isn't working as expected (?).
    CONFIG_HOTPLUG=y
    CONFIG_MODULES=n
    Fix shared init/exit code helper:
    WARNING: sound/built-in.o(.exit.text+0x243): Section mismatch: reference to .init.text: (between 'alsa_card_mpu401_exit' and 'ac97_bus_exit')
    WARNING: sound/built-in.o(.exit.text+0x21b): Section mismatch: reference to .init.text: (between 'alsa_card_dummy_exit' and 'alsa_card_serial_exit')
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index a0f28f51fc7e..4360ae9de19c 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -659,7 +659,7 @@ static struct platform_driver snd_dummy_driver = {
 	},
 };
 
-static void __init_or_module snd_dummy_unregister_all(void)
+static void snd_dummy_unregister_all(void)
 {
 	int i;
 

commit 788c6043335590e0a483fdc18f85b1405a157bf9
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Tue Feb 13 13:11:11 2007 +0100

    [ALSA] Fix __devinit and __devexit issues with sound drivers
    
    Fix __devinit and __devexit issues with sound drivers.
    Resolves MODPOST warnings similar to:
    WARNING: sound/drivers/snd-dummy.o - Section mismatch: reference to .init.text:snd_dummy_probe from .data.rel.local between 'snd_dummy_driver' (at offset 0x0) and 'snd_dummy_controls'
    WARNING: sound/drivers/snd-mtpav.o - Section mismatch: reference to .init.text:snd_mtpav_probe from .data.rel.local between 'snd_mtpav_driver' (at offset 0x0) and 'snd_mtpav_input'
    WARNING: sound/drivers/snd-virmidi.o - Section mismatch: reference to .init.text:snd_virmidi_probe from .data.rel.local after 'snd_virmidi_driver' (at offset 0x0)
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 8339bad969ba..a0f28f51fc7e 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -423,7 +423,8 @@ static struct snd_pcm_ops snd_card_dummy_capture_ops = {
 	.pointer =		snd_card_dummy_pcm_pointer,
 };
 
-static int __init snd_card_dummy_pcm(struct snd_dummy *dummy, int device, int substreams)
+static int __devinit snd_card_dummy_pcm(struct snd_dummy *dummy, int device,
+					int substreams)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -562,7 +563,7 @@ DUMMY_VOLUME("CD Volume", 0, MIXER_ADDR_CD),
 DUMMY_CAPSRC("CD Capture Switch", 0, MIXER_ADDR_CD)
 };
 
-static int __init snd_card_dummy_new_mixer(struct snd_dummy *dummy)
+static int __devinit snd_card_dummy_new_mixer(struct snd_dummy *dummy)
 {
 	struct snd_card *card = dummy->card;
 	unsigned int idx;
@@ -579,7 +580,7 @@ static int __init snd_card_dummy_new_mixer(struct snd_dummy *dummy)
 	return 0;
 }
 
-static int __init snd_dummy_probe(struct platform_device *devptr)
+static int __devinit snd_dummy_probe(struct platform_device *devptr)
 {
 	struct snd_card *card;
 	struct snd_dummy *dummy;
@@ -617,7 +618,7 @@ static int __init snd_dummy_probe(struct platform_device *devptr)
 	return err;
 }
 
-static int snd_dummy_remove(struct platform_device *devptr)
+static int __devexit snd_dummy_remove(struct platform_device *devptr)
 {
 	snd_card_free(platform_get_drvdata(devptr));
 	platform_set_drvdata(devptr, NULL);
@@ -648,7 +649,7 @@ static int snd_dummy_resume(struct platform_device *pdev)
 
 static struct platform_driver snd_dummy_driver = {
 	.probe		= snd_dummy_probe,
-	.remove		= snd_dummy_remove,
+	.remove		= __devexit_p(snd_dummy_remove),
 #ifdef CONFIG_PM
 	.suspend	= snd_dummy_suspend,
 	.resume		= snd_dummy_resume,

commit 0cb29ea0d449d7c0ecc9649a08ab63476389701d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 29 15:33:49 2007 +0100

    [ALSA] Add even more 'const' to everything related to TLV
    
    Mark TLV data as 'const'
    Signed-of-by: Philipp Matthias Hahn <pmhahn@pmhahn.de>
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 42001efa9f3e..8339bad969ba 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -501,7 +501,7 @@ static int snd_dummy_volume_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static DECLARE_TLV_DB_SCALE(db_scale_dummy, -4500, 30, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_dummy, -4500, 30, 0);
 
 #define DUMMY_CAPSRC(xname, xindex, addr) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \

commit fb567a8e4f077b7b084c0558706339c35a4fb186
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 23 13:07:19 2006 +0200

    [ALSA] Add dB scale information to dummy driver
    
    Added the dB scale information to dummy driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 73b16134a434..42001efa9f3e 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -29,6 +29,7 @@
 #include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/pcm.h>
 #include <sound/rawmidi.h>
 #include <sound/initval.h>
@@ -443,10 +444,13 @@ static int __init snd_card_dummy_pcm(struct snd_dummy *dummy, int device, int su
 }
 
 #define DUMMY_VOLUME(xname, xindex, addr) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_TLV_READ, \
+  .name = xname, .index = xindex, \
   .info = snd_dummy_volume_info, \
   .get = snd_dummy_volume_get, .put = snd_dummy_volume_put, \
-  .private_value = addr }
+  .private_value = addr, \
+  .tlv = { .p = db_scale_dummy } }
 
 static int snd_dummy_volume_info(struct snd_kcontrol *kcontrol,
 				 struct snd_ctl_elem_info *uinfo)
@@ -497,6 +501,8 @@ static int snd_dummy_volume_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
+static DECLARE_TLV_DB_SCALE(db_scale_dummy, -4500, 30, 0);
+
 #define DUMMY_CAPSRC(xname, xindex, addr) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
   .info = snd_dummy_capsrc_info, \

commit e05d696424f21b59eccff35d04938f0d6588cd94
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 17 17:12:19 2006 +0200

    [ALSA] Fix some typos in snd-dummy driver
    
    Fixed some typos in snd-dummy driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index ffeafaf2ecca..73b16134a434 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -285,7 +285,7 @@ static struct snd_pcm_hardware snd_card_dummy_playback =
 	.channels_max =		USE_CHANNELS_MAX,
 	.buffer_bytes_max =	MAX_BUFFER_SIZE,
 	.period_bytes_min =	64,
-	.period_bytes_max =	MAX_BUFFER_SIZE,
+	.period_bytes_max =	MAX_PERIOD_SIZE,
 	.periods_min =		USE_PERIODS_MIN,
 	.periods_max =		USE_PERIODS_MAX,
 	.fifo_size =		0,
@@ -547,13 +547,13 @@ static struct snd_kcontrol_new snd_dummy_controls[] = {
 DUMMY_VOLUME("Master Volume", 0, MIXER_ADDR_MASTER),
 DUMMY_CAPSRC("Master Capture Switch", 0, MIXER_ADDR_MASTER),
 DUMMY_VOLUME("Synth Volume", 0, MIXER_ADDR_SYNTH),
-DUMMY_CAPSRC("Synth Capture Switch", 0, MIXER_ADDR_MASTER),
+DUMMY_CAPSRC("Synth Capture Switch", 0, MIXER_ADDR_SYNTH),
 DUMMY_VOLUME("Line Volume", 0, MIXER_ADDR_LINE),
-DUMMY_CAPSRC("Line Capture Switch", 0, MIXER_ADDR_MASTER),
+DUMMY_CAPSRC("Line Capture Switch", 0, MIXER_ADDR_LINE),
 DUMMY_VOLUME("Mic Volume", 0, MIXER_ADDR_MIC),
-DUMMY_CAPSRC("Mic Capture Switch", 0, MIXER_ADDR_MASTER),
+DUMMY_CAPSRC("Mic Capture Switch", 0, MIXER_ADDR_MIC),
 DUMMY_VOLUME("CD Volume", 0, MIXER_ADDR_CD),
-DUMMY_CAPSRC("CD Capture Switch", 0, MIXER_ADDR_MASTER)
+DUMMY_CAPSRC("CD Capture Switch", 0, MIXER_ADDR_CD)
 };
 
 static int __init snd_card_dummy_new_mixer(struct snd_dummy *dummy)

commit 7152447df98b3981d621224be947a2c8d77aed06
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Thu Apr 13 12:58:06 2006 +0200

    [ALSA] unregister platform device again if probe was unsuccessful
    
    This second one unregisters the platform device again when the probe is
    unsuccesful for sound/drivers, sound/arm/sa11xx-uda1341.c and
    sound/ppc/powermac.c. This gets them all.
    
    Signed-off-by: Rene Herman <rene.herman@keyaccess.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index ae0df549fac7..ffeafaf2ecca 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -677,6 +677,10 @@ static int __init alsa_card_dummy_init(void)
 							 i, NULL, 0);
 		if (IS_ERR(device))
 			continue;
+		if (!platform_get_drvdata(device)) {
+			platform_device_unregister(device);
+			continue;
+		}
 		devices[i] = device;
 		cards++;
 	}

commit a182ee9876c7826d0b8f7789cb5c38c5bfbec441
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Thu Apr 13 12:57:11 2006 +0200

    [ALSA] continue on IS_ERR from platform device registration
    
    I previously only concerned myself with sound/isa. When I now checked
    for more platform_device_register_simple() usages in ALSA I found a
    couple more drivers that needed the same patches as already submitted
    for all the ISA drivers.
    This first one is the continue-on-iserr patch for sound/drivers. This
    gets them all.
    
    Signed-off-by: Rene Herman <rene.herman@keyaccess.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index e35fd5779a9d..ae0df549fac7 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -675,10 +675,8 @@ static int __init alsa_card_dummy_init(void)
 			continue;
 		device = platform_device_register_simple(SND_DUMMY_DRIVER,
 							 i, NULL, 0);
-		if (IS_ERR(device)) {
-			err = PTR_ERR(device);
-			goto errout;
-		}
+		if (IS_ERR(device))
+			continue;
 		devices[i] = device;
 		cards++;
 	}
@@ -686,14 +684,10 @@ static int __init alsa_card_dummy_init(void)
 #ifdef MODULE
 		printk(KERN_ERR "Dummy soundcard not found or device busy\n");
 #endif
-		err = -ENODEV;
-		goto errout;
+		snd_dummy_unregister_all();
+		return -ENODEV;
 	}
 	return 0;
-
- errout:
-	snd_dummy_unregister_all();
-	return err;
 }
 
 static void __exit alsa_card_dummy_exit(void)

commit 8278ca8feb2748cf02d756ac6c5b9ab2e047c84a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 20 11:57:34 2006 +0100

    [ALSA] Fix check of enable module option
    
    Fix the check of enable module option in probe of platform_device drivers.
    It shouldn't break the loop but just ignore if enable[i] is false.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 14e1a671b5cf..e35fd5779a9d 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -669,8 +669,10 @@ static int __init alsa_card_dummy_init(void)
 		return err;
 
 	cards = 0;
-	for (i = 0; i < SNDRV_CARDS && enable[i]; i++) {
+	for (i = 0; i < SNDRV_CARDS; i++) {
 		struct platform_device *device;
+		if (! enable[i])
+			continue;
 		device = platform_device_register_simple(SND_DUMMY_DRIVER,
 							 i, NULL, 0);
 		if (IS_ERR(device)) {

commit 2ad5dd8dc31137a050f205525a5cd1a4be76c3f1
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Tue Jan 3 14:27:21 2006 +0100

    [ALSA] dummy driver - added CA0106 emulation defines
    
    Modules: Generic drivers
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 96d207051628..14e1a671b5cf 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -92,11 +92,27 @@ static int emu10k1_playback_constraints(struct snd_pcm_runtime *runtime)
 #define USE_RATE_MAX		48000
 #endif
 
+#if 0 /* CA0106 */
+#define USE_FORMATS		SNDRV_PCM_FMTBIT_S16_LE
+#define USE_CHANNELS_MIN	2
+#define USE_CHANNELS_MAX	2
+#define USE_RATE		(SNDRV_PCM_RATE_48000|SNDRV_PCM_RATE_96000|SNDRV_PCM_RATE_192000) 
+#define USE_RATE_MIN		48000 
+#define USE_RATE_MAX		192000
+#define MAX_BUFFER_SIZE		((65536-64)*8)
+#define MAX_PERIOD_SIZE		(65536-64)
+#define USE_PERIODS_MIN		2
+#define USE_PERIODS_MAX		8
+#endif
+
 
 /* defaults */
 #ifndef MAX_BUFFER_SIZE
 #define MAX_BUFFER_SIZE		(64*1024)
 #endif
+#ifndef MAX_PERIOD_SIZE
+#define MAX_PERIOD_SIZE		MAX_BUFFER_SIZE
+#endif
 #ifndef USE_FORMATS
 #define USE_FORMATS 		(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE)
 #endif
@@ -287,7 +303,7 @@ static struct snd_pcm_hardware snd_card_dummy_capture =
 	.channels_max =		USE_CHANNELS_MAX,
 	.buffer_bytes_max =	MAX_BUFFER_SIZE,
 	.period_bytes_min =	64,
-	.period_bytes_max =	MAX_BUFFER_SIZE,
+	.period_bytes_max =	MAX_PERIOD_SIZE,
 	.periods_min =		USE_PERIODS_MIN,
 	.periods_max =		USE_PERIODS_MAX,
 	.fifo_size =		0,

commit f7a9275d949cb0bf1f259a1546e52a0bf518151c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Dec 7 09:13:42 2005 +0100

    [ALSA] unregister platform devices
    
    Call platform_device_unregister() for all platform devices that we've
    registered.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 186117571745..96d207051628 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -144,6 +144,8 @@ MODULE_PARM_DESC(pcm_substreams, "PCM substreams # (1-16) for dummy driver.");
 //module_param_array(midi_devs, int, NULL, 0444);
 //MODULE_PARM_DESC(midi_devs, "MIDI devices # (0-2) for dummy driver.");
 
+static struct platform_device *devices[SNDRV_CARDS];
+
 #define MIXER_ADDR_MASTER	0
 #define MIXER_ADDR_LINE		1
 #define MIXER_ADDR_MIC		2
@@ -634,6 +636,15 @@ static struct platform_driver snd_dummy_driver = {
 	},
 };
 
+static void __init_or_module snd_dummy_unregister_all(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(devices); ++i)
+		platform_device_unregister(devices[i]);
+	platform_driver_unregister(&snd_dummy_driver);
+}
+
 static int __init alsa_card_dummy_init(void)
 {
 	int i, cards, err;
@@ -650,6 +661,7 @@ static int __init alsa_card_dummy_init(void)
 			err = PTR_ERR(device);
 			goto errout;
 		}
+		devices[i] = device;
 		cards++;
 	}
 	if (!cards) {
@@ -662,13 +674,13 @@ static int __init alsa_card_dummy_init(void)
 	return 0;
 
  errout:
-	platform_driver_unregister(&snd_dummy_driver);
+	snd_dummy_unregister_all();
 	return err;
 }
 
 static void __exit alsa_card_dummy_exit(void)
 {
-	platform_driver_unregister(&snd_dummy_driver);
+	snd_dummy_unregister_all();
 }
 
 module_init(alsa_card_dummy_init)

commit b32425ac93370e1ba5556110e662f896b2e143b3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 18 18:52:14 2005 +0100

    [ALSA] Fix possible races in timer callbacks
    
    Fix possible races in timer callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index a276f7c80360..186117571745 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -231,8 +231,9 @@ static int snd_card_dummy_pcm_prepare(struct snd_pcm_substream *substream)
 static void snd_card_dummy_pcm_timer_function(unsigned long data)
 {
 	struct snd_dummy_pcm *dpcm = (struct snd_dummy_pcm *)data;
+	unsigned long flags;
 	
-	spin_lock(&dpcm->lock);
+	spin_lock_irqsave(&dpcm->lock, flags);
 	dpcm->timer.expires = 1 + jiffies;
 	add_timer(&dpcm->timer);
 	dpcm->pcm_irq_pos += dpcm->pcm_jiffie;
@@ -240,11 +241,10 @@ static void snd_card_dummy_pcm_timer_function(unsigned long data)
 	dpcm->pcm_buf_pos %= dpcm->pcm_size;
 	if (dpcm->pcm_irq_pos >= dpcm->pcm_count) {
 		dpcm->pcm_irq_pos %= dpcm->pcm_count;
-		spin_unlock(&dpcm->lock);
+		spin_unlock_irqrestore(&dpcm->lock, flags);
 		snd_pcm_period_elapsed(dpcm->substream);
-		spin_lock(&dpcm->lock);
-	}
-	spin_unlock(&dpcm->lock);
+	} else
+		spin_unlock_irqrestore(&dpcm->lock, flags);
 }
 
 static snd_pcm_uframes_t snd_card_dummy_pcm_pointer(struct snd_pcm_substream *substream)

commit 6e65c1cc4458b2784224759b6137a50d4f65e610
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 16:01:56 2005 +0100

    [ALSA] dummy - Use platform_device
    
    Modules: Generic drivers
    
    Rewrite the probe/remove code using platform_device.
    Added the suspend/resume support, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 9c827b154458..a276f7c80360 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -20,6 +20,8 @@
 
 #include <sound/driver.h>
 #include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
 #include <linux/jiffies.h>
 #include <linux/slab.h>
 #include <linux/time.h>
@@ -151,6 +153,7 @@ MODULE_PARM_DESC(pcm_substreams, "PCM substreams # (1-16) for dummy driver.");
 
 struct snd_dummy {
 	struct snd_card *card;
+	struct snd_pcm *pcm;
 	spinlock_t mixer_lock;
 	int mixer_volume[MIXER_ADDR_LAST+1][2];
 	int capture_source[MIXER_ADDR_LAST+1][2];
@@ -169,8 +172,6 @@ struct snd_dummy_pcm {
 	struct snd_pcm_substream *substream;
 };
 
-static struct snd_card *snd_dummy_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
-
 
 static inline void snd_card_dummy_pcm_timer_start(struct snd_dummy_pcm *dpcm)
 {
@@ -190,15 +191,21 @@ static int snd_card_dummy_pcm_trigger(struct snd_pcm_substream *substream, int c
 	int err = 0;
 
 	spin_lock(&dpcm->lock);
-	if (cmd == SNDRV_PCM_TRIGGER_START) {
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
 		snd_card_dummy_pcm_timer_start(dpcm);
-	} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
 		snd_card_dummy_pcm_timer_stop(dpcm);
-	} else {
+		break;
+	default:
 		err = -EINVAL;
+		break;
 	}
 	spin_unlock(&dpcm->lock);
-	return err;
+	return 0;
 }
 
 static int snd_card_dummy_pcm_prepare(struct snd_pcm_substream *substream)
@@ -251,7 +258,7 @@ static snd_pcm_uframes_t snd_card_dummy_pcm_pointer(struct snd_pcm_substream *su
 static struct snd_pcm_hardware snd_card_dummy_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
-				 SNDRV_PCM_INFO_MMAP_VALID),
+				 SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),
 	.formats =		USE_FORMATS,
 	.rates =		USE_RATE,
 	.rate_min =		USE_RATE_MIN,
@@ -269,7 +276,7 @@ static struct snd_pcm_hardware snd_card_dummy_playback =
 static struct snd_pcm_hardware snd_card_dummy_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
-				 SNDRV_PCM_INFO_MMAP_VALID),
+				 SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),
 	.formats =		USE_FORMATS,
 	.rates =		USE_RATE,
 	.rate_min =		USE_RATE_MIN,
@@ -405,6 +412,7 @@ static int __init snd_card_dummy_pcm(struct snd_dummy *dummy, int device, int su
 	if ((err = snd_pcm_new(dummy->card, "Dummy PCM", device,
 			       substreams, substreams, &pcm)) < 0)
 		return err;
+	dummy->pcm = pcm;
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_card_dummy_playback_ops);
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_card_dummy_capture_ops);
 	pcm->private_data = dummy;
@@ -547,14 +555,13 @@ static int __init snd_card_dummy_new_mixer(struct snd_dummy *dummy)
 	return 0;
 }
 
-static int __init snd_card_dummy_probe(int dev)
+static int __init snd_dummy_probe(struct platform_device *devptr)
 {
 	struct snd_card *card;
 	struct snd_dummy *dummy;
 	int idx, err;
+	int dev = devptr->id;
 
-	if (!enable[dev])
-		return -ENODEV;
 	card = snd_card_new(index[dev], id[dev], THIS_MODULE,
 			    sizeof(struct snd_dummy));
 	if (card == NULL)
@@ -575,11 +582,10 @@ static int __init snd_card_dummy_probe(int dev)
 	strcpy(card->shortname, "Dummy");
 	sprintf(card->longname, "Dummy %i", dev + 1);
 
-	if ((err = snd_card_set_generic_dev(card)) < 0)
-		goto __nodev;
+	snd_card_set_dev(card, &devptr->dev);
 
 	if ((err = snd_card_register(card)) == 0) {
-		snd_dummy_cards[dev] = card;
+		platform_set_drvdata(devptr, card);
 		return 0;
 	}
       __nodev:
@@ -587,16 +593,62 @@ static int __init snd_card_dummy_probe(int dev)
 	return err;
 }
 
-static int __init alsa_card_dummy_init(void)
+static int snd_dummy_remove(struct platform_device *devptr)
+{
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int snd_dummy_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	int dev, cards;
+	struct snd_card *card = platform_get_drvdata(pdev);
+	struct snd_dummy *dummy = card->private_data;
 
-	for (dev = cards = 0; dev < SNDRV_CARDS && enable[dev]; dev++) {
-		if (snd_card_dummy_probe(dev) < 0) {
-#ifdef MODULE
-			printk(KERN_ERR "Dummy soundcard #%i not found or device busy\n", dev + 1);
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	snd_pcm_suspend_all(dummy->pcm);
+	return 0;
+}
+	
+static int snd_dummy_resume(struct platform_device *pdev)
+{
+	struct snd_card *card = platform_get_drvdata(pdev);
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	return 0;
+}
+#endif
+
+#define SND_DUMMY_DRIVER	"snd_dummy"
+
+static struct platform_driver snd_dummy_driver = {
+	.probe		= snd_dummy_probe,
+	.remove		= snd_dummy_remove,
+#ifdef CONFIG_PM
+	.suspend	= snd_dummy_suspend,
+	.resume		= snd_dummy_resume,
 #endif
-			break;
+	.driver		= {
+		.name	= SND_DUMMY_DRIVER
+	},
+};
+
+static int __init alsa_card_dummy_init(void)
+{
+	int i, cards, err;
+
+	if ((err = platform_driver_register(&snd_dummy_driver)) < 0)
+		return err;
+
+	cards = 0;
+	for (i = 0; i < SNDRV_CARDS && enable[i]; i++) {
+		struct platform_device *device;
+		device = platform_device_register_simple(SND_DUMMY_DRIVER,
+							 i, NULL, 0);
+		if (IS_ERR(device)) {
+			err = PTR_ERR(device);
+			goto errout;
 		}
 		cards++;
 	}
@@ -604,17 +656,19 @@ static int __init alsa_card_dummy_init(void)
 #ifdef MODULE
 		printk(KERN_ERR "Dummy soundcard not found or device busy\n");
 #endif
-		return -ENODEV;
+		err = -ENODEV;
+		goto errout;
 	}
 	return 0;
+
+ errout:
+	platform_driver_unregister(&snd_dummy_driver);
+	return err;
 }
 
 static void __exit alsa_card_dummy_exit(void)
 {
-	int idx;
-
-	for (idx = 0; idx < SNDRV_CARDS; idx++)
-		snd_card_free(snd_dummy_cards[idx]);
+	platform_driver_unregister(&snd_dummy_driver);
 }
 
 module_init(alsa_card_dummy_init)

commit 4a4d2cfd8cbca3076742547157ea135d0be77928
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:27:28 2005 +0100

    [ALSA] Remove xxx_t typedefs: Generic drivers
    
    Modules: Generic drivers
    
    Remove xxx_t typedefs from the generic drivers
    (dummy, mtpav, serial-u16550 and virmidi).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 8dfe5d49eafc..9c827b154458 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -42,7 +42,7 @@ MODULE_SUPPORTED_DEVICE("{{ALSA,Dummy soundcard}}");
 
 #if 0 /* emu10k1 emulation */
 #define MAX_BUFFER_SIZE		(128 * 1024)
-static int emu10k1_playback_constraints(snd_pcm_runtime_t *runtime)
+static int emu10k1_playback_constraints(struct snd_pcm_runtime *runtime)
 {
 	int err;
 	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
@@ -149,15 +149,15 @@ MODULE_PARM_DESC(pcm_substreams, "PCM substreams # (1-16) for dummy driver.");
 #define MIXER_ADDR_CD		4
 #define MIXER_ADDR_LAST		4
 
-typedef struct snd_card_dummy {
-	snd_card_t *card;
+struct snd_dummy {
+	struct snd_card *card;
 	spinlock_t mixer_lock;
 	int mixer_volume[MIXER_ADDR_LAST+1][2];
 	int capture_source[MIXER_ADDR_LAST+1][2];
-} snd_card_dummy_t;
+};
 
-typedef struct snd_card_dummy_pcm {
-	snd_card_dummy_t *dummy;
+struct snd_dummy_pcm {
+	struct snd_dummy *dummy;
 	spinlock_t lock;
 	struct timer_list timer;
 	unsigned int pcm_size;
@@ -166,27 +166,27 @@ typedef struct snd_card_dummy_pcm {
 	unsigned int pcm_jiffie;	/* bytes per one jiffie */
 	unsigned int pcm_irq_pos;	/* IRQ position */
 	unsigned int pcm_buf_pos;	/* position in buffer */
-	snd_pcm_substream_t *substream;
-} snd_card_dummy_pcm_t;
+	struct snd_pcm_substream *substream;
+};
 
-static snd_card_t *snd_dummy_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
+static struct snd_card *snd_dummy_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
 
 
-static inline void snd_card_dummy_pcm_timer_start(snd_card_dummy_pcm_t *dpcm)
+static inline void snd_card_dummy_pcm_timer_start(struct snd_dummy_pcm *dpcm)
 {
 	dpcm->timer.expires = 1 + jiffies;
 	add_timer(&dpcm->timer);
 }
 
-static inline void snd_card_dummy_pcm_timer_stop(snd_card_dummy_pcm_t *dpcm)
+static inline void snd_card_dummy_pcm_timer_stop(struct snd_dummy_pcm *dpcm)
 {
 	del_timer(&dpcm->timer);
 }
 
-static int snd_card_dummy_pcm_trigger(snd_pcm_substream_t *substream, int cmd)
+static int snd_card_dummy_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_dummy_card_pcm_t *dpcm = runtime->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_dummy_pcm *dpcm = runtime->private_data;
 	int err = 0;
 
 	spin_lock(&dpcm->lock);
@@ -201,10 +201,10 @@ static int snd_card_dummy_pcm_trigger(snd_pcm_substream_t *substream, int cmd)
 	return err;
 }
 
-static int snd_card_dummy_pcm_prepare(snd_pcm_substream_t * substream)
+static int snd_card_dummy_pcm_prepare(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_card_dummy_pcm_t *dpcm = runtime->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_dummy_pcm *dpcm = runtime->private_data;
 	unsigned int bps;
 
 	bps = runtime->rate * runtime->channels;
@@ -223,7 +223,7 @@ static int snd_card_dummy_pcm_prepare(snd_pcm_substream_t * substream)
 
 static void snd_card_dummy_pcm_timer_function(unsigned long data)
 {
-	snd_card_dummy_pcm_t *dpcm = (snd_card_dummy_pcm_t *)data;
+	struct snd_dummy_pcm *dpcm = (struct snd_dummy_pcm *)data;
 	
 	spin_lock(&dpcm->lock);
 	dpcm->timer.expires = 1 + jiffies;
@@ -240,15 +240,15 @@ static void snd_card_dummy_pcm_timer_function(unsigned long data)
 	spin_unlock(&dpcm->lock);
 }
 
-static snd_pcm_uframes_t snd_card_dummy_pcm_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_card_dummy_pcm_pointer(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_card_dummy_pcm_t *dpcm = runtime->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_dummy_pcm *dpcm = runtime->private_data;
 
 	return bytes_to_frames(runtime, dpcm->pcm_buf_pos);
 }
 
-static snd_pcm_hardware_t snd_card_dummy_playback =
+static struct snd_pcm_hardware snd_card_dummy_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_MMAP_VALID),
@@ -266,7 +266,7 @@ static snd_pcm_hardware_t snd_card_dummy_playback =
 	.fifo_size =		0,
 };
 
-static snd_pcm_hardware_t snd_card_dummy_capture =
+static struct snd_pcm_hardware snd_card_dummy_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_MMAP_VALID),
@@ -284,25 +284,25 @@ static snd_pcm_hardware_t snd_card_dummy_capture =
 	.fifo_size =		0,
 };
 
-static void snd_card_dummy_runtime_free(snd_pcm_runtime_t *runtime)
+static void snd_card_dummy_runtime_free(struct snd_pcm_runtime *runtime)
 {
 	kfree(runtime->private_data);
 }
 
-static int snd_card_dummy_hw_params(snd_pcm_substream_t * substream,
-				    snd_pcm_hw_params_t * hw_params)
+static int snd_card_dummy_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *hw_params)
 {
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 }
 
-static int snd_card_dummy_hw_free(snd_pcm_substream_t * substream)
+static int snd_card_dummy_hw_free(struct snd_pcm_substream *substream)
 {
 	return snd_pcm_lib_free_pages(substream);
 }
 
-static snd_card_dummy_pcm_t *new_pcm_stream(snd_pcm_substream_t *substream)
+static struct snd_dummy_pcm *new_pcm_stream(struct snd_pcm_substream *substream)
 {
-	snd_card_dummy_pcm_t *dpcm;
+	struct snd_dummy_pcm *dpcm;
 
 	dpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);
 	if (! dpcm)
@@ -315,10 +315,10 @@ static snd_card_dummy_pcm_t *new_pcm_stream(snd_pcm_substream_t *substream)
 	return dpcm;
 }
 
-static int snd_card_dummy_playback_open(snd_pcm_substream_t * substream)
+static int snd_card_dummy_playback_open(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_card_dummy_pcm_t *dpcm;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_dummy_pcm *dpcm;
 	int err;
 
 	if ((dpcm = new_pcm_stream(substream)) == NULL)
@@ -340,10 +340,10 @@ static int snd_card_dummy_playback_open(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_card_dummy_capture_open(snd_pcm_substream_t * substream)
+static int snd_card_dummy_capture_open(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_card_dummy_pcm_t *dpcm;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_dummy_pcm *dpcm;
 	int err;
 
 	if ((dpcm = new_pcm_stream(substream)) == NULL)
@@ -365,17 +365,17 @@ static int snd_card_dummy_capture_open(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_card_dummy_playback_close(snd_pcm_substream_t * substream)
+static int snd_card_dummy_playback_close(struct snd_pcm_substream *substream)
 {
 	return 0;
 }
 
-static int snd_card_dummy_capture_close(snd_pcm_substream_t * substream)
+static int snd_card_dummy_capture_close(struct snd_pcm_substream *substream)
 {
 	return 0;
 }
 
-static snd_pcm_ops_t snd_card_dummy_playback_ops = {
+static struct snd_pcm_ops snd_card_dummy_playback_ops = {
 	.open =			snd_card_dummy_playback_open,
 	.close =		snd_card_dummy_playback_close,
 	.ioctl =		snd_pcm_lib_ioctl,
@@ -386,7 +386,7 @@ static snd_pcm_ops_t snd_card_dummy_playback_ops = {
 	.pointer =		snd_card_dummy_pcm_pointer,
 };
 
-static snd_pcm_ops_t snd_card_dummy_capture_ops = {
+static struct snd_pcm_ops snd_card_dummy_capture_ops = {
 	.open =			snd_card_dummy_capture_open,
 	.close =		snd_card_dummy_capture_close,
 	.ioctl =		snd_pcm_lib_ioctl,
@@ -397,12 +397,13 @@ static snd_pcm_ops_t snd_card_dummy_capture_ops = {
 	.pointer =		snd_card_dummy_pcm_pointer,
 };
 
-static int __init snd_card_dummy_pcm(snd_card_dummy_t *dummy, int device, int substreams)
+static int __init snd_card_dummy_pcm(struct snd_dummy *dummy, int device, int substreams)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
-	if ((err = snd_pcm_new(dummy->card, "Dummy PCM", device, substreams, substreams, &pcm)) < 0)
+	if ((err = snd_pcm_new(dummy->card, "Dummy PCM", device,
+			       substreams, substreams, &pcm)) < 0)
 		return err;
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_card_dummy_playback_ops);
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_card_dummy_capture_ops);
@@ -421,7 +422,8 @@ static int __init snd_card_dummy_pcm(snd_card_dummy_t *dummy, int device, int su
   .get = snd_dummy_volume_get, .put = snd_dummy_volume_put, \
   .private_value = addr }
 
-static int snd_dummy_volume_info(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_dummy_volume_info(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
@@ -430,9 +432,10 @@ static int snd_dummy_volume_info(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t
 	return 0;
 }
  
-static int snd_dummy_volume_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_dummy_volume_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	snd_card_dummy_t *dummy = snd_kcontrol_chip(kcontrol);
+	struct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);
 	int addr = kcontrol->private_value;
 
 	spin_lock_irq(&dummy->mixer_lock);
@@ -442,9 +445,10 @@ static int snd_dummy_volume_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	return 0;
 }
 
-static int snd_dummy_volume_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_dummy_volume_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	snd_card_dummy_t *dummy = snd_kcontrol_chip(kcontrol);
+	struct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);
 	int change, addr = kcontrol->private_value;
 	int left, right;
 
@@ -473,7 +477,8 @@ static int snd_dummy_volume_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
   .get = snd_dummy_capsrc_get, .put = snd_dummy_capsrc_put, \
   .private_value = addr }
 
-static int snd_dummy_capsrc_info(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_dummy_capsrc_info(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 2;
@@ -482,9 +487,10 @@ static int snd_dummy_capsrc_info(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t
 	return 0;
 }
  
-static int snd_dummy_capsrc_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_dummy_capsrc_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	snd_card_dummy_t *dummy = snd_kcontrol_chip(kcontrol);
+	struct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);
 	int addr = kcontrol->private_value;
 
 	spin_lock_irq(&dummy->mixer_lock);
@@ -494,9 +500,9 @@ static int snd_dummy_capsrc_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	return 0;
 }
 
-static int snd_dummy_capsrc_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_dummy_capsrc_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	snd_card_dummy_t *dummy = snd_kcontrol_chip(kcontrol);
+	struct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);
 	int change, addr = kcontrol->private_value;
 	int left, right;
 
@@ -511,7 +517,7 @@ static int snd_dummy_capsrc_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	return change;
 }
 
-static snd_kcontrol_new_t snd_dummy_controls[] = {
+static struct snd_kcontrol_new snd_dummy_controls[] = {
 DUMMY_VOLUME("Master Volume", 0, MIXER_ADDR_MASTER),
 DUMMY_CAPSRC("Master Capture Switch", 0, MIXER_ADDR_MASTER),
 DUMMY_VOLUME("Synth Volume", 0, MIXER_ADDR_SYNTH),
@@ -524,9 +530,9 @@ DUMMY_VOLUME("CD Volume", 0, MIXER_ADDR_CD),
 DUMMY_CAPSRC("CD Capture Switch", 0, MIXER_ADDR_MASTER)
 };
 
-static int __init snd_card_dummy_new_mixer(snd_card_dummy_t * dummy)
+static int __init snd_card_dummy_new_mixer(struct snd_dummy *dummy)
 {
-	snd_card_t *card = dummy->card;
+	struct snd_card *card = dummy->card;
 	unsigned int idx;
 	int err;
 
@@ -543,17 +549,17 @@ static int __init snd_card_dummy_new_mixer(snd_card_dummy_t * dummy)
 
 static int __init snd_card_dummy_probe(int dev)
 {
-	snd_card_t *card;
-	struct snd_card_dummy *dummy;
+	struct snd_card *card;
+	struct snd_dummy *dummy;
 	int idx, err;
 
 	if (!enable[dev])
 		return -ENODEV;
 	card = snd_card_new(index[dev], id[dev], THIS_MODULE,
-			    sizeof(struct snd_card_dummy));
+			    sizeof(struct snd_dummy));
 	if (card == NULL)
 		return -ENOMEM;
-	dummy = (struct snd_card_dummy *)card->private_data;
+	dummy = card->private_data;
 	dummy->card = card;
 	for (idx = 0; idx < MAX_PCM_DEVICES && idx < pcm_devs[dev]; idx++) {
 		if (pcm_substreams[dev] < 1)

commit c8eb6ba16a5803fab9cc0d1d0dd04a75bf91b6d5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 10:20:23 2005 +0100

    [ALSA] snd-dummy - Code clean-up
    
    Modules: Generic drivers
    
    Clean up snd-dummy driver code.
    - Make common PCM callbacks
    - Simplify open callback
    - Remove unnecessary irqsave in control callbacks
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 64ef7f62851d..8dfe5d49eafc 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -172,47 +172,33 @@ typedef struct snd_card_dummy_pcm {
 static snd_card_t *snd_dummy_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
 
 
-static void snd_card_dummy_pcm_timer_start(snd_pcm_substream_t * substream)
+static inline void snd_card_dummy_pcm_timer_start(snd_card_dummy_pcm_t *dpcm)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_card_dummy_pcm_t *dpcm = runtime->private_data;
-
 	dpcm->timer.expires = 1 + jiffies;
 	add_timer(&dpcm->timer);
 }
 
-static void snd_card_dummy_pcm_timer_stop(snd_pcm_substream_t * substream)
+static inline void snd_card_dummy_pcm_timer_stop(snd_card_dummy_pcm_t *dpcm)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_card_dummy_pcm_t *dpcm = runtime->private_data;
-
 	del_timer(&dpcm->timer);
 }
 
-static int snd_card_dummy_playback_trigger(snd_pcm_substream_t * substream,
-					   int cmd)
+static int snd_card_dummy_pcm_trigger(snd_pcm_substream_t *substream, int cmd)
 {
-	if (cmd == SNDRV_PCM_TRIGGER_START) {
-		snd_card_dummy_pcm_timer_start(substream);
-	} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {
-		snd_card_dummy_pcm_timer_stop(substream);
-	} else {
-		return -EINVAL;
-	}
-	return 0;
-}
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_dummy_card_pcm_t *dpcm = runtime->private_data;
+	int err = 0;
 
-static int snd_card_dummy_capture_trigger(snd_pcm_substream_t * substream,
-					  int cmd)
-{
+	spin_lock(&dpcm->lock);
 	if (cmd == SNDRV_PCM_TRIGGER_START) {
-		snd_card_dummy_pcm_timer_start(substream);
+		snd_card_dummy_pcm_timer_start(dpcm);
 	} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {
-		snd_card_dummy_pcm_timer_stop(substream);
+		snd_card_dummy_pcm_timer_stop(dpcm);
 	} else {
-		return -EINVAL;
+		err = -EINVAL;
 	}
-	return 0;
+	spin_unlock(&dpcm->lock);
+	return err;
 }
 
 static int snd_card_dummy_pcm_prepare(snd_pcm_substream_t * substream)
@@ -235,42 +221,26 @@ static int snd_card_dummy_pcm_prepare(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_card_dummy_playback_prepare(snd_pcm_substream_t * substream)
-{
-	return snd_card_dummy_pcm_prepare(substream);
-}
-
-static int snd_card_dummy_capture_prepare(snd_pcm_substream_t * substream)
-{
-	return snd_card_dummy_pcm_prepare(substream);
-}
-
 static void snd_card_dummy_pcm_timer_function(unsigned long data)
 {
 	snd_card_dummy_pcm_t *dpcm = (snd_card_dummy_pcm_t *)data;
 	
+	spin_lock(&dpcm->lock);
 	dpcm->timer.expires = 1 + jiffies;
 	add_timer(&dpcm->timer);
-	spin_lock_irq(&dpcm->lock);
 	dpcm->pcm_irq_pos += dpcm->pcm_jiffie;
 	dpcm->pcm_buf_pos += dpcm->pcm_jiffie;
 	dpcm->pcm_buf_pos %= dpcm->pcm_size;
 	if (dpcm->pcm_irq_pos >= dpcm->pcm_count) {
 		dpcm->pcm_irq_pos %= dpcm->pcm_count;
+		spin_unlock(&dpcm->lock);
 		snd_pcm_period_elapsed(dpcm->substream);
+		spin_lock(&dpcm->lock);
 	}
-	spin_unlock_irq(&dpcm->lock);	
+	spin_unlock(&dpcm->lock);
 }
 
-static snd_pcm_uframes_t snd_card_dummy_playback_pointer(snd_pcm_substream_t * substream)
-{
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_card_dummy_pcm_t *dpcm = runtime->private_data;
-
-	return bytes_to_frames(runtime, dpcm->pcm_buf_pos);
-}
-
-static snd_pcm_uframes_t snd_card_dummy_capture_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_card_dummy_pcm_pointer(snd_pcm_substream_t * substream)
 {
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	snd_card_dummy_pcm_t *dpcm = runtime->private_data;
@@ -316,8 +286,7 @@ static snd_pcm_hardware_t snd_card_dummy_capture =
 
 static void snd_card_dummy_runtime_free(snd_pcm_runtime_t *runtime)
 {
-	snd_card_dummy_pcm_t *dpcm = runtime->private_data;
-	kfree(dpcm);
+	kfree(runtime->private_data);
 }
 
 static int snd_card_dummy_hw_params(snd_pcm_substream_t * substream,
@@ -331,20 +300,29 @@ static int snd_card_dummy_hw_free(snd_pcm_substream_t * substream)
 	return snd_pcm_lib_free_pages(substream);
 }
 
-static int snd_card_dummy_playback_open(snd_pcm_substream_t * substream)
+static snd_card_dummy_pcm_t *new_pcm_stream(snd_pcm_substream_t *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
 	snd_card_dummy_pcm_t *dpcm;
-	int err;
 
 	dpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);
-	if (dpcm == NULL)
-		return -ENOMEM;
+	if (! dpcm)
+		return dpcm;
 	init_timer(&dpcm->timer);
 	dpcm->timer.data = (unsigned long) dpcm;
 	dpcm->timer.function = snd_card_dummy_pcm_timer_function;
 	spin_lock_init(&dpcm->lock);
 	dpcm->substream = substream;
+	return dpcm;
+}
+
+static int snd_card_dummy_playback_open(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_card_dummy_pcm_t *dpcm;
+	int err;
+
+	if ((dpcm = new_pcm_stream(substream)) == NULL)
+		return -ENOMEM;
 	runtime->private_data = dpcm;
 	runtime->private_free = snd_card_dummy_runtime_free;
 	runtime->hw = snd_card_dummy_playback;
@@ -368,14 +346,8 @@ static int snd_card_dummy_capture_open(snd_pcm_substream_t * substream)
 	snd_card_dummy_pcm_t *dpcm;
 	int err;
 
-	dpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);
-	if (dpcm == NULL)
+	if ((dpcm = new_pcm_stream(substream)) == NULL)
 		return -ENOMEM;
-	init_timer(&dpcm->timer);
-	dpcm->timer.data = (unsigned long) dpcm;
-	dpcm->timer.function = snd_card_dummy_pcm_timer_function;
-	spin_lock_init(&dpcm->lock);
-	dpcm->substream = substream;
 	runtime->private_data = dpcm;
 	runtime->private_free = snd_card_dummy_runtime_free;
 	runtime->hw = snd_card_dummy_capture;
@@ -409,9 +381,9 @@ static snd_pcm_ops_t snd_card_dummy_playback_ops = {
 	.ioctl =		snd_pcm_lib_ioctl,
 	.hw_params =		snd_card_dummy_hw_params,
 	.hw_free =		snd_card_dummy_hw_free,
-	.prepare =		snd_card_dummy_playback_prepare,
-	.trigger =		snd_card_dummy_playback_trigger,
-	.pointer =		snd_card_dummy_playback_pointer,
+	.prepare =		snd_card_dummy_pcm_prepare,
+	.trigger =		snd_card_dummy_pcm_trigger,
+	.pointer =		snd_card_dummy_pcm_pointer,
 };
 
 static snd_pcm_ops_t snd_card_dummy_capture_ops = {
@@ -420,9 +392,9 @@ static snd_pcm_ops_t snd_card_dummy_capture_ops = {
 	.ioctl =		snd_pcm_lib_ioctl,
 	.hw_params =		snd_card_dummy_hw_params,
 	.hw_free =		snd_card_dummy_hw_free,
-	.prepare =		snd_card_dummy_capture_prepare,
-	.trigger =		snd_card_dummy_capture_trigger,
-	.pointer =		snd_card_dummy_capture_pointer,
+	.prepare =		snd_card_dummy_pcm_prepare,
+	.trigger =		snd_card_dummy_pcm_trigger,
+	.pointer =		snd_card_dummy_pcm_pointer,
 };
 
 static int __init snd_card_dummy_pcm(snd_card_dummy_t *dummy, int device, int substreams)
@@ -461,20 +433,18 @@ static int snd_dummy_volume_info(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t
 static int snd_dummy_volume_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	snd_card_dummy_t *dummy = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
 	int addr = kcontrol->private_value;
 
-	spin_lock_irqsave(&dummy->mixer_lock, flags);
+	spin_lock_irq(&dummy->mixer_lock);
 	ucontrol->value.integer.value[0] = dummy->mixer_volume[addr][0];
 	ucontrol->value.integer.value[1] = dummy->mixer_volume[addr][1];
-	spin_unlock_irqrestore(&dummy->mixer_lock, flags);
+	spin_unlock_irq(&dummy->mixer_lock);
 	return 0;
 }
 
 static int snd_dummy_volume_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	snd_card_dummy_t *dummy = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
 	int change, addr = kcontrol->private_value;
 	int left, right;
 
@@ -488,12 +458,12 @@ static int snd_dummy_volume_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 		right = -50;
 	if (right > 100)
 		right = 100;
-	spin_lock_irqsave(&dummy->mixer_lock, flags);
+	spin_lock_irq(&dummy->mixer_lock);
 	change = dummy->mixer_volume[addr][0] != left ||
 	         dummy->mixer_volume[addr][1] != right;
 	dummy->mixer_volume[addr][0] = left;
 	dummy->mixer_volume[addr][1] = right;
-	spin_unlock_irqrestore(&dummy->mixer_lock, flags);
+	spin_unlock_irq(&dummy->mixer_lock);
 	return change;
 }
 
@@ -515,31 +485,29 @@ static int snd_dummy_capsrc_info(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t
 static int snd_dummy_capsrc_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	snd_card_dummy_t *dummy = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
 	int addr = kcontrol->private_value;
 
-	spin_lock_irqsave(&dummy->mixer_lock, flags);
+	spin_lock_irq(&dummy->mixer_lock);
 	ucontrol->value.integer.value[0] = dummy->capture_source[addr][0];
 	ucontrol->value.integer.value[1] = dummy->capture_source[addr][1];
-	spin_unlock_irqrestore(&dummy->mixer_lock, flags);
+	spin_unlock_irq(&dummy->mixer_lock);
 	return 0;
 }
 
 static int snd_dummy_capsrc_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
 {
 	snd_card_dummy_t *dummy = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
 	int change, addr = kcontrol->private_value;
 	int left, right;
 
 	left = ucontrol->value.integer.value[0] & 1;
 	right = ucontrol->value.integer.value[1] & 1;
-	spin_lock_irqsave(&dummy->mixer_lock, flags);
+	spin_lock_irq(&dummy->mixer_lock);
 	change = dummy->capture_source[addr][0] != left &&
 	         dummy->capture_source[addr][1] != right;
 	dummy->capture_source[addr][0] = left;
 	dummy->capture_source[addr][1] = right;
-	spin_unlock_irqrestore(&dummy->mixer_lock, flags);
+	spin_unlock_irq(&dummy->mixer_lock);
 	return change;
 }
 

commit 561b220a4dece18d67177413e6fa21b49aa4acce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:22:34 2005 +0200

    [ALSA] Replace with kzalloc() - others
    
    Documentation,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,OPL3
    OPL4,Digigram VX core,I2C cs8427,I2C lib core,I2C tea6330t,L3 drivers
    AK4114 receiver,AK4117 receiver,PDAudioCF driver,PPC PMAC driver
    SPARC AMD7930 driver,SPARC cs4231 driver,Synth,Common EMU synth
    USB generic driver,USB USX2Y
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index 977d98d26a81..64ef7f62851d 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -337,7 +337,7 @@ static int snd_card_dummy_playback_open(snd_pcm_substream_t * substream)
 	snd_card_dummy_pcm_t *dpcm;
 	int err;
 
-	dpcm = kcalloc(1, sizeof(*dpcm), GFP_KERNEL);
+	dpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);
 	if (dpcm == NULL)
 		return -ENOMEM;
 	init_timer(&dpcm->timer);
@@ -368,7 +368,7 @@ static int snd_card_dummy_capture_open(snd_pcm_substream_t * substream)
 	snd_card_dummy_pcm_t *dpcm;
 	int err;
 
-	dpcm = kcalloc(1, sizeof(*dpcm), GFP_KERNEL);
+	dpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);
 	if (dpcm == NULL)
 		return -ENOMEM;
 	init_timer(&dpcm->timer);

commit 16dab54b8cbac39bd3f639db5d7d0fd8300a6cb0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 5 17:17:58 2005 +0200

    [ALSA] Add snd_card_set_generic_dev() call
    
    ARM,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,MIPS
    MIPS AU1x00 driver,PPC,PPC PowerMac driver,SPARC,SPARC AMD7930 driver
    SPARC cs4231 driver,SPARC DBRI driver
    - Added snd_card_set_generic_dev() call.
    - Added SND_GENERIC_DRIVER to Kconfig.
    - Clean up the error path in probe if necessary.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index a61640cf7ae7..977d98d26a81 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -600,6 +600,10 @@ static int __init snd_card_dummy_probe(int dev)
 	strcpy(card->driver, "Dummy");
 	strcpy(card->shortname, "Dummy");
 	sprintf(card->longname, "Dummy %i", dev + 1);
+
+	if ((err = snd_card_set_generic_dev(card)) < 0)
+		goto __nodev;
+
 	if ((err = snd_card_register(card)) == 0) {
 		snd_dummy_cards[dev] = card;
 		return 0;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
new file mode 100644
index 000000000000..a61640cf7ae7
--- /dev/null
+++ b/sound/drivers/dummy.c
@@ -0,0 +1,643 @@
+/*
+ *  Dummy soundcard
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/wait.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/rawmidi.h>
+#include <sound/initval.h>
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_DESCRIPTION("Dummy soundcard (/dev/null)");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{ALSA,Dummy soundcard}}");
+
+#define MAX_PCM_DEVICES		4
+#define MAX_PCM_SUBSTREAMS	16
+#define MAX_MIDI_DEVICES	2
+
+#if 0 /* emu10k1 emulation */
+#define MAX_BUFFER_SIZE		(128 * 1024)
+static int emu10k1_playback_constraints(snd_pcm_runtime_t *runtime)
+{
+	int err;
+	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+	if ((err = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 256, UINT_MAX)) < 0)
+		return err;
+	return 0;
+}
+#define add_playback_constraints emu10k1_playback_constraints
+#endif
+
+#if 0 /* RME9652 emulation */
+#define MAX_BUFFER_SIZE		(26 * 64 * 1024)
+#define USE_FORMATS		SNDRV_PCM_FMTBIT_S32_LE
+#define USE_CHANNELS_MIN	26
+#define USE_CHANNELS_MAX	26
+#define USE_PERIODS_MIN		2
+#define USE_PERIODS_MAX		2
+#endif
+
+#if 0 /* ICE1712 emulation */
+#define MAX_BUFFER_SIZE		(256 * 1024)
+#define USE_FORMATS		SNDRV_PCM_FMTBIT_S32_LE
+#define USE_CHANNELS_MIN	10
+#define USE_CHANNELS_MAX	10
+#define USE_PERIODS_MIN		1
+#define USE_PERIODS_MAX		1024
+#endif
+
+#if 0 /* UDA1341 emulation */
+#define MAX_BUFFER_SIZE		(16380)
+#define USE_FORMATS		SNDRV_PCM_FMTBIT_S16_LE
+#define USE_CHANNELS_MIN	2
+#define USE_CHANNELS_MAX	2
+#define USE_PERIODS_MIN		2
+#define USE_PERIODS_MAX		255
+#endif
+
+#if 0 /* simple AC97 bridge (intel8x0) with 48kHz AC97 only codec */
+#define USE_FORMATS		SNDRV_PCM_FMTBIT_S16_LE
+#define USE_CHANNELS_MIN	2
+#define USE_CHANNELS_MAX	2
+#define USE_RATE		SNDRV_PCM_RATE_48000
+#define USE_RATE_MIN		48000
+#define USE_RATE_MAX		48000
+#endif
+
+
+/* defaults */
+#ifndef MAX_BUFFER_SIZE
+#define MAX_BUFFER_SIZE		(64*1024)
+#endif
+#ifndef USE_FORMATS
+#define USE_FORMATS 		(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE)
+#endif
+#ifndef USE_RATE
+#define USE_RATE		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000
+#define USE_RATE_MIN		5500
+#define USE_RATE_MAX		48000
+#endif
+#ifndef USE_CHANNELS_MIN
+#define USE_CHANNELS_MIN 	1
+#endif
+#ifndef USE_CHANNELS_MAX
+#define USE_CHANNELS_MAX 	2
+#endif
+#ifndef USE_PERIODS_MIN
+#define USE_PERIODS_MIN 	1
+#endif
+#ifndef USE_PERIODS_MAX
+#define USE_PERIODS_MAX 	1024
+#endif
+#ifndef add_playback_constraints
+#define add_playback_constraints(x) 0
+#endif
+#ifndef add_capture_constraints
+#define add_capture_constraints(x) 0
+#endif
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = {1, [1 ... (SNDRV_CARDS - 1)] = 0};
+static int pcm_devs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};
+static int pcm_substreams[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 8};
+//static int midi_devs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for dummy soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for dummy soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable this dummy soundcard.");
+module_param_array(pcm_devs, int, NULL, 0444);
+MODULE_PARM_DESC(pcm_devs, "PCM devices # (0-4) for dummy driver.");
+module_param_array(pcm_substreams, int, NULL, 0444);
+MODULE_PARM_DESC(pcm_substreams, "PCM substreams # (1-16) for dummy driver.");
+//module_param_array(midi_devs, int, NULL, 0444);
+//MODULE_PARM_DESC(midi_devs, "MIDI devices # (0-2) for dummy driver.");
+
+#define MIXER_ADDR_MASTER	0
+#define MIXER_ADDR_LINE		1
+#define MIXER_ADDR_MIC		2
+#define MIXER_ADDR_SYNTH	3
+#define MIXER_ADDR_CD		4
+#define MIXER_ADDR_LAST		4
+
+typedef struct snd_card_dummy {
+	snd_card_t *card;
+	spinlock_t mixer_lock;
+	int mixer_volume[MIXER_ADDR_LAST+1][2];
+	int capture_source[MIXER_ADDR_LAST+1][2];
+} snd_card_dummy_t;
+
+typedef struct snd_card_dummy_pcm {
+	snd_card_dummy_t *dummy;
+	spinlock_t lock;
+	struct timer_list timer;
+	unsigned int pcm_size;
+	unsigned int pcm_count;
+	unsigned int pcm_bps;		/* bytes per second */
+	unsigned int pcm_jiffie;	/* bytes per one jiffie */
+	unsigned int pcm_irq_pos;	/* IRQ position */
+	unsigned int pcm_buf_pos;	/* position in buffer */
+	snd_pcm_substream_t *substream;
+} snd_card_dummy_pcm_t;
+
+static snd_card_t *snd_dummy_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
+
+
+static void snd_card_dummy_pcm_timer_start(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_card_dummy_pcm_t *dpcm = runtime->private_data;
+
+	dpcm->timer.expires = 1 + jiffies;
+	add_timer(&dpcm->timer);
+}
+
+static void snd_card_dummy_pcm_timer_stop(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_card_dummy_pcm_t *dpcm = runtime->private_data;
+
+	del_timer(&dpcm->timer);
+}
+
+static int snd_card_dummy_playback_trigger(snd_pcm_substream_t * substream,
+					   int cmd)
+{
+	if (cmd == SNDRV_PCM_TRIGGER_START) {
+		snd_card_dummy_pcm_timer_start(substream);
+	} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {
+		snd_card_dummy_pcm_timer_stop(substream);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int snd_card_dummy_capture_trigger(snd_pcm_substream_t * substream,
+					  int cmd)
+{
+	if (cmd == SNDRV_PCM_TRIGGER_START) {
+		snd_card_dummy_pcm_timer_start(substream);
+	} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {
+		snd_card_dummy_pcm_timer_stop(substream);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int snd_card_dummy_pcm_prepare(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_card_dummy_pcm_t *dpcm = runtime->private_data;
+	unsigned int bps;
+
+	bps = runtime->rate * runtime->channels;
+	bps *= snd_pcm_format_width(runtime->format);
+	bps /= 8;
+	if (bps <= 0)
+		return -EINVAL;
+	dpcm->pcm_bps = bps;
+	dpcm->pcm_jiffie = bps / HZ;
+	dpcm->pcm_size = snd_pcm_lib_buffer_bytes(substream);
+	dpcm->pcm_count = snd_pcm_lib_period_bytes(substream);
+	dpcm->pcm_irq_pos = 0;
+	dpcm->pcm_buf_pos = 0;
+	return 0;
+}
+
+static int snd_card_dummy_playback_prepare(snd_pcm_substream_t * substream)
+{
+	return snd_card_dummy_pcm_prepare(substream);
+}
+
+static int snd_card_dummy_capture_prepare(snd_pcm_substream_t * substream)
+{
+	return snd_card_dummy_pcm_prepare(substream);
+}
+
+static void snd_card_dummy_pcm_timer_function(unsigned long data)
+{
+	snd_card_dummy_pcm_t *dpcm = (snd_card_dummy_pcm_t *)data;
+	
+	dpcm->timer.expires = 1 + jiffies;
+	add_timer(&dpcm->timer);
+	spin_lock_irq(&dpcm->lock);
+	dpcm->pcm_irq_pos += dpcm->pcm_jiffie;
+	dpcm->pcm_buf_pos += dpcm->pcm_jiffie;
+	dpcm->pcm_buf_pos %= dpcm->pcm_size;
+	if (dpcm->pcm_irq_pos >= dpcm->pcm_count) {
+		dpcm->pcm_irq_pos %= dpcm->pcm_count;
+		snd_pcm_period_elapsed(dpcm->substream);
+	}
+	spin_unlock_irq(&dpcm->lock);	
+}
+
+static snd_pcm_uframes_t snd_card_dummy_playback_pointer(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_card_dummy_pcm_t *dpcm = runtime->private_data;
+
+	return bytes_to_frames(runtime, dpcm->pcm_buf_pos);
+}
+
+static snd_pcm_uframes_t snd_card_dummy_capture_pointer(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_card_dummy_pcm_t *dpcm = runtime->private_data;
+
+	return bytes_to_frames(runtime, dpcm->pcm_buf_pos);
+}
+
+static snd_pcm_hardware_t snd_card_dummy_playback =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		USE_FORMATS,
+	.rates =		USE_RATE,
+	.rate_min =		USE_RATE_MIN,
+	.rate_max =		USE_RATE_MAX,
+	.channels_min =		USE_CHANNELS_MIN,
+	.channels_max =		USE_CHANNELS_MAX,
+	.buffer_bytes_max =	MAX_BUFFER_SIZE,
+	.period_bytes_min =	64,
+	.period_bytes_max =	MAX_BUFFER_SIZE,
+	.periods_min =		USE_PERIODS_MIN,
+	.periods_max =		USE_PERIODS_MAX,
+	.fifo_size =		0,
+};
+
+static snd_pcm_hardware_t snd_card_dummy_capture =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		USE_FORMATS,
+	.rates =		USE_RATE,
+	.rate_min =		USE_RATE_MIN,
+	.rate_max =		USE_RATE_MAX,
+	.channels_min =		USE_CHANNELS_MIN,
+	.channels_max =		USE_CHANNELS_MAX,
+	.buffer_bytes_max =	MAX_BUFFER_SIZE,
+	.period_bytes_min =	64,
+	.period_bytes_max =	MAX_BUFFER_SIZE,
+	.periods_min =		USE_PERIODS_MIN,
+	.periods_max =		USE_PERIODS_MAX,
+	.fifo_size =		0,
+};
+
+static void snd_card_dummy_runtime_free(snd_pcm_runtime_t *runtime)
+{
+	snd_card_dummy_pcm_t *dpcm = runtime->private_data;
+	kfree(dpcm);
+}
+
+static int snd_card_dummy_hw_params(snd_pcm_substream_t * substream,
+				    snd_pcm_hw_params_t * hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+}
+
+static int snd_card_dummy_hw_free(snd_pcm_substream_t * substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int snd_card_dummy_playback_open(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_card_dummy_pcm_t *dpcm;
+	int err;
+
+	dpcm = kcalloc(1, sizeof(*dpcm), GFP_KERNEL);
+	if (dpcm == NULL)
+		return -ENOMEM;
+	init_timer(&dpcm->timer);
+	dpcm->timer.data = (unsigned long) dpcm;
+	dpcm->timer.function = snd_card_dummy_pcm_timer_function;
+	spin_lock_init(&dpcm->lock);
+	dpcm->substream = substream;
+	runtime->private_data = dpcm;
+	runtime->private_free = snd_card_dummy_runtime_free;
+	runtime->hw = snd_card_dummy_playback;
+	if (substream->pcm->device & 1) {
+		runtime->hw.info &= ~SNDRV_PCM_INFO_INTERLEAVED;
+		runtime->hw.info |= SNDRV_PCM_INFO_NONINTERLEAVED;
+	}
+	if (substream->pcm->device & 2)
+		runtime->hw.info &= ~(SNDRV_PCM_INFO_MMAP|SNDRV_PCM_INFO_MMAP_VALID);
+	if ((err = add_playback_constraints(runtime)) < 0) {
+		kfree(dpcm);
+		return err;
+	}
+
+	return 0;
+}
+
+static int snd_card_dummy_capture_open(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_card_dummy_pcm_t *dpcm;
+	int err;
+
+	dpcm = kcalloc(1, sizeof(*dpcm), GFP_KERNEL);
+	if (dpcm == NULL)
+		return -ENOMEM;
+	init_timer(&dpcm->timer);
+	dpcm->timer.data = (unsigned long) dpcm;
+	dpcm->timer.function = snd_card_dummy_pcm_timer_function;
+	spin_lock_init(&dpcm->lock);
+	dpcm->substream = substream;
+	runtime->private_data = dpcm;
+	runtime->private_free = snd_card_dummy_runtime_free;
+	runtime->hw = snd_card_dummy_capture;
+	if (substream->pcm->device == 1) {
+		runtime->hw.info &= ~SNDRV_PCM_INFO_INTERLEAVED;
+		runtime->hw.info |= SNDRV_PCM_INFO_NONINTERLEAVED;
+	}
+	if (substream->pcm->device & 2)
+		runtime->hw.info &= ~(SNDRV_PCM_INFO_MMAP|SNDRV_PCM_INFO_MMAP_VALID);
+	if ((err = add_capture_constraints(runtime)) < 0) {
+		kfree(dpcm);
+		return err;
+	}
+
+	return 0;
+}
+
+static int snd_card_dummy_playback_close(snd_pcm_substream_t * substream)
+{
+	return 0;
+}
+
+static int snd_card_dummy_capture_close(snd_pcm_substream_t * substream)
+{
+	return 0;
+}
+
+static snd_pcm_ops_t snd_card_dummy_playback_ops = {
+	.open =			snd_card_dummy_playback_open,
+	.close =		snd_card_dummy_playback_close,
+	.ioctl =		snd_pcm_lib_ioctl,
+	.hw_params =		snd_card_dummy_hw_params,
+	.hw_free =		snd_card_dummy_hw_free,
+	.prepare =		snd_card_dummy_playback_prepare,
+	.trigger =		snd_card_dummy_playback_trigger,
+	.pointer =		snd_card_dummy_playback_pointer,
+};
+
+static snd_pcm_ops_t snd_card_dummy_capture_ops = {
+	.open =			snd_card_dummy_capture_open,
+	.close =		snd_card_dummy_capture_close,
+	.ioctl =		snd_pcm_lib_ioctl,
+	.hw_params =		snd_card_dummy_hw_params,
+	.hw_free =		snd_card_dummy_hw_free,
+	.prepare =		snd_card_dummy_capture_prepare,
+	.trigger =		snd_card_dummy_capture_trigger,
+	.pointer =		snd_card_dummy_capture_pointer,
+};
+
+static int __init snd_card_dummy_pcm(snd_card_dummy_t *dummy, int device, int substreams)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	if ((err = snd_pcm_new(dummy->card, "Dummy PCM", device, substreams, substreams, &pcm)) < 0)
+		return err;
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_card_dummy_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_card_dummy_capture_ops);
+	pcm->private_data = dummy;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "Dummy PCM");
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
+					      snd_dma_continuous_data(GFP_KERNEL),
+					      0, 64*1024);
+	return 0;
+}
+
+#define DUMMY_VOLUME(xname, xindex, addr) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+  .info = snd_dummy_volume_info, \
+  .get = snd_dummy_volume_get, .put = snd_dummy_volume_put, \
+  .private_value = addr }
+
+static int snd_dummy_volume_info(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = -50;
+	uinfo->value.integer.max = 100;
+	return 0;
+}
+ 
+static int snd_dummy_volume_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	snd_card_dummy_t *dummy = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int addr = kcontrol->private_value;
+
+	spin_lock_irqsave(&dummy->mixer_lock, flags);
+	ucontrol->value.integer.value[0] = dummy->mixer_volume[addr][0];
+	ucontrol->value.integer.value[1] = dummy->mixer_volume[addr][1];
+	spin_unlock_irqrestore(&dummy->mixer_lock, flags);
+	return 0;
+}
+
+static int snd_dummy_volume_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	snd_card_dummy_t *dummy = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int change, addr = kcontrol->private_value;
+	int left, right;
+
+	left = ucontrol->value.integer.value[0];
+	if (left < -50)
+		left = -50;
+	if (left > 100)
+		left = 100;
+	right = ucontrol->value.integer.value[1];
+	if (right < -50)
+		right = -50;
+	if (right > 100)
+		right = 100;
+	spin_lock_irqsave(&dummy->mixer_lock, flags);
+	change = dummy->mixer_volume[addr][0] != left ||
+	         dummy->mixer_volume[addr][1] != right;
+	dummy->mixer_volume[addr][0] = left;
+	dummy->mixer_volume[addr][1] = right;
+	spin_unlock_irqrestore(&dummy->mixer_lock, flags);
+	return change;
+}
+
+#define DUMMY_CAPSRC(xname, xindex, addr) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+  .info = snd_dummy_capsrc_info, \
+  .get = snd_dummy_capsrc_get, .put = snd_dummy_capsrc_put, \
+  .private_value = addr }
+
+static int snd_dummy_capsrc_info(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+ 
+static int snd_dummy_capsrc_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	snd_card_dummy_t *dummy = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int addr = kcontrol->private_value;
+
+	spin_lock_irqsave(&dummy->mixer_lock, flags);
+	ucontrol->value.integer.value[0] = dummy->capture_source[addr][0];
+	ucontrol->value.integer.value[1] = dummy->capture_source[addr][1];
+	spin_unlock_irqrestore(&dummy->mixer_lock, flags);
+	return 0;
+}
+
+static int snd_dummy_capsrc_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	snd_card_dummy_t *dummy = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int change, addr = kcontrol->private_value;
+	int left, right;
+
+	left = ucontrol->value.integer.value[0] & 1;
+	right = ucontrol->value.integer.value[1] & 1;
+	spin_lock_irqsave(&dummy->mixer_lock, flags);
+	change = dummy->capture_source[addr][0] != left &&
+	         dummy->capture_source[addr][1] != right;
+	dummy->capture_source[addr][0] = left;
+	dummy->capture_source[addr][1] = right;
+	spin_unlock_irqrestore(&dummy->mixer_lock, flags);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_dummy_controls[] = {
+DUMMY_VOLUME("Master Volume", 0, MIXER_ADDR_MASTER),
+DUMMY_CAPSRC("Master Capture Switch", 0, MIXER_ADDR_MASTER),
+DUMMY_VOLUME("Synth Volume", 0, MIXER_ADDR_SYNTH),
+DUMMY_CAPSRC("Synth Capture Switch", 0, MIXER_ADDR_MASTER),
+DUMMY_VOLUME("Line Volume", 0, MIXER_ADDR_LINE),
+DUMMY_CAPSRC("Line Capture Switch", 0, MIXER_ADDR_MASTER),
+DUMMY_VOLUME("Mic Volume", 0, MIXER_ADDR_MIC),
+DUMMY_CAPSRC("Mic Capture Switch", 0, MIXER_ADDR_MASTER),
+DUMMY_VOLUME("CD Volume", 0, MIXER_ADDR_CD),
+DUMMY_CAPSRC("CD Capture Switch", 0, MIXER_ADDR_MASTER)
+};
+
+static int __init snd_card_dummy_new_mixer(snd_card_dummy_t * dummy)
+{
+	snd_card_t *card = dummy->card;
+	unsigned int idx;
+	int err;
+
+	snd_assert(dummy != NULL, return -EINVAL);
+	spin_lock_init(&dummy->mixer_lock);
+	strcpy(card->mixername, "Dummy Mixer");
+
+	for (idx = 0; idx < ARRAY_SIZE(snd_dummy_controls); idx++) {
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_dummy_controls[idx], dummy))) < 0)
+			return err;
+	}
+	return 0;
+}
+
+static int __init snd_card_dummy_probe(int dev)
+{
+	snd_card_t *card;
+	struct snd_card_dummy *dummy;
+	int idx, err;
+
+	if (!enable[dev])
+		return -ENODEV;
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE,
+			    sizeof(struct snd_card_dummy));
+	if (card == NULL)
+		return -ENOMEM;
+	dummy = (struct snd_card_dummy *)card->private_data;
+	dummy->card = card;
+	for (idx = 0; idx < MAX_PCM_DEVICES && idx < pcm_devs[dev]; idx++) {
+		if (pcm_substreams[dev] < 1)
+			pcm_substreams[dev] = 1;
+		if (pcm_substreams[dev] > MAX_PCM_SUBSTREAMS)
+			pcm_substreams[dev] = MAX_PCM_SUBSTREAMS;
+		if ((err = snd_card_dummy_pcm(dummy, idx, pcm_substreams[dev])) < 0)
+			goto __nodev;
+	}
+	if ((err = snd_card_dummy_new_mixer(dummy)) < 0)
+		goto __nodev;
+	strcpy(card->driver, "Dummy");
+	strcpy(card->shortname, "Dummy");
+	sprintf(card->longname, "Dummy %i", dev + 1);
+	if ((err = snd_card_register(card)) == 0) {
+		snd_dummy_cards[dev] = card;
+		return 0;
+	}
+      __nodev:
+	snd_card_free(card);
+	return err;
+}
+
+static int __init alsa_card_dummy_init(void)
+{
+	int dev, cards;
+
+	for (dev = cards = 0; dev < SNDRV_CARDS && enable[dev]; dev++) {
+		if (snd_card_dummy_probe(dev) < 0) {
+#ifdef MODULE
+			printk(KERN_ERR "Dummy soundcard #%i not found or device busy\n", dev + 1);
+#endif
+			break;
+		}
+		cards++;
+	}
+	if (!cards) {
+#ifdef MODULE
+		printk(KERN_ERR "Dummy soundcard not found or device busy\n");
+#endif
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void __exit alsa_card_dummy_exit(void)
+{
+	int idx;
+
+	for (idx = 0; idx < SNDRV_CARDS; idx++)
+		snd_card_free(snd_dummy_cards[idx]);
+}
+
+module_init(alsa_card_dummy_init)
+module_exit(alsa_card_dummy_exit)
