commit c09482455ca586539802282380f59f54a1febf16
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:22 2020 +0100

    ALSA: vx: More constifications
    
    Apply const prefix to every possible place: the static tables for DSP
    commands, the string tables, and register/offset tables.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-8-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index dd35de3f2434..ffab0400d7fb 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -39,7 +39,7 @@ MODULE_LICENSE("GPL");
 int snd_vx_check_reg_bit(struct vx_core *chip, int reg, int mask, int bit, int time)
 {
 	unsigned long end_time = jiffies + (time * HZ + 999) / 1000;
-	static char *reg_names[VX_REG_MAX] = {
+	static const char * const reg_names[VX_REG_MAX] = {
 		"ICR", "CVR", "ISR", "IVR", "RXH", "RXM", "RXL",
 		"DMA", "CDSP", "RFREQ", "RUER/V2", "DATA", "MEMIRQ",
 		"ACQ", "BIT0", "BIT1", "MIC0", "MIC1", "MIC2",
@@ -588,11 +588,11 @@ static void vx_reset_board(struct vx_core *chip, int cold_reset)
 static void vx_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
 	struct vx_core *chip = entry->private_data;
-	static char *audio_src_vxp[] = { "Line", "Mic", "Digital" };
-	static char *audio_src_vx2[] = { "Analog", "Analog", "Digital" };
-	static char *clock_mode[] = { "Auto", "Internal", "External" };
-	static char *clock_src[] = { "Internal", "External" };
-	static char *uer_type[] = { "Consumer", "Professional", "Not Present" };
+	static const char * const audio_src_vxp[] = { "Line", "Mic", "Digital" };
+	static const char * const audio_src_vx2[] = { "Analog", "Analog", "Digital" };
+	static const char * const clock_mode[] = { "Auto", "Internal", "External" };
+	static const char * const clock_src[] = { "Internal", "External" };
+	static const char * const uer_type[] = { "Consumer", "Professional", "Not Present" };
 	
 	snd_iprintf(buffer, "%s\n", chip->card->longname);
 	snd_iprintf(buffer, "Xilinx Firmware: %s\n",

commit f8ae2d2919481817d2e942617c203fc792687c66
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:46 2020 +0100

    ALSA: vx: Constify snd_vx_hardware and snd_vx_ops definitions
    
    Both snd_vx_hardware and snd_vx_ops are only referred without
    modification, hence they can be constified gracefully for further
    optimizations.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-31-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 6bbc2a4f85c1..dd35de3f2434 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -765,8 +765,9 @@ EXPORT_SYMBOL(snd_vx_resume);
  *
  * return the instance pointer if successful, NULL in error.
  */
-struct vx_core *snd_vx_create(struct snd_card *card, struct snd_vx_hardware *hw,
-			      struct snd_vx_ops *ops,
+struct vx_core *snd_vx_create(struct snd_card *card,
+			      const struct snd_vx_hardware *hw,
+			      const struct snd_vx_ops *ops,
 			      int extra_size)
 {
 	struct vx_core *chip;

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 543945643a76..6bbc2a4f85c1 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Driver for Digigram VX soundcards
  *
  * Hardware core part
  *
  * Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include <linux/delay.h>

commit 815d808c7bfc91edbf25813cea54709f4a805c71
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 15:58:33 2019 +0100

    ALSA: drivers: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 19496fa486aa..543945643a76 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -643,10 +643,7 @@ static void vx_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *b
 
 static void vx_proc_init(struct vx_core *chip)
 {
-	struct snd_info_entry *entry;
-
-	if (! snd_card_proc_new(chip->card, "vx-status", &entry))
-		snd_info_set_text_ops(entry, chip, vx_proc_read);
+	snd_card_ro_proc_new(chip->card, "vx-status", chip, vx_proc_read);
 }
 
 

commit 3c40dfeb044943d2323d39c7348c910746a81add
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:02:20 2019 +0100

    ALSA: drivers: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 04368dd59a4c..19496fa486aa 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -732,12 +732,8 @@ EXPORT_SYMBOL(snd_vx_dsp_load);
  */
 int snd_vx_suspend(struct vx_core *chip)
 {
-	unsigned int i;
-
 	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
 	chip->chip_status |= VX_STAT_IN_SUSPEND;
-	for (i = 0; i < chip->hw->num_codecs; i++)
-		snd_pcm_suspend_all(chip->pcm[i]);
 
 	return 0;
 }

commit 969686ee0e0ff62ece428e8e02b07f81ac88a84d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 3 15:42:46 2018 +0200

    ALSA: drivers: Remove empty init and exit
    
    For a sake of code simplification, remove the init and the exit
    entries that do nothing.
    
    Notes for readers: actually it's OK to remove *both* init and exit,
    but not OK to remove the exit entry.  By removing only the exit while
    keeping init, the module becomes permanently loaded; i.e. you cannot
    unload it any longer!
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 121357397a6d..04368dd59a4c 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -815,18 +815,3 @@ struct vx_core *snd_vx_create(struct snd_card *card, struct snd_vx_hardware *hw,
 }
 
 EXPORT_SYMBOL(snd_vx_create);
-
-/*
- * module entries
- */
-static int __init alsa_vx_core_init(void)
-{
-	return 0;
-}
-
-static void __exit alsa_vx_core_exit(void)
-{
-}
-
-module_init(alsa_vx_core_init)
-module_exit(alsa_vx_core_exit)

commit 07f070dda48c3c5b0a81d6b48b4d7c7de7341b12
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 31 10:56:12 2017 +0200

    ALSA: vx: Put missing KERN_CONT prefix
    
    The vx driver has a debug printk code without proper KERN_ prefix.
    On recent kernels, KERN_CONT prefix is mandatory for continued output
    lines.  Put it properly.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index f684fffd1397..121357397a6d 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -256,8 +256,8 @@ int vx_send_msg_nolock(struct vx_core *chip, struct vx_rmh *rmh)
 	if (rmh->LgCmd > 1) {
 		printk(KERN_DEBUG "  ");
 		for (i = 1; i < rmh->LgCmd; i++)
-			printk("0x%06x ", rmh->Cmd[i]);
-		printk("\n");
+			printk(KERN_CONT "0x%06x ", rmh->Cmd[i]);
+		printk(KERN_CONT "\n");
 	}
 #endif
 	/* Check bit M is set according to length of the command */

commit a65895e0ee3a9e4f7f38e0d0fa4054b30b811035
Author: Mihai Burduselu <michelcatalin@gmail.com>
Date:   Sun Feb 26 01:30:38 2017 +0200

    ALSA: vx: remove 'out of memory' message
    
    Reported by checkpatch.pl
    
    Signed-off-by: Mihai Burduselu <michelcatalin@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 289f041706cd..f684fffd1397 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -795,10 +795,8 @@ struct vx_core *snd_vx_create(struct snd_card *card, struct snd_vx_hardware *hw,
 		return NULL;
 
 	chip = kzalloc(sizeof(*chip) + extra_size, GFP_KERNEL);
-	if (! chip) {
-		snd_printk(KERN_ERR "vx_core: no memory\n");
+	if (! chip)
 		return NULL;
-	}
 	mutex_init(&chip->lock);
 	chip->irq = -1;
 	chip->hw = hw;

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index fc05a37fd017..289f041706cd 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -27,11 +27,11 @@
 #include <linux/device.h>
 #include <linux/firmware.h>
 #include <linux/module.h>
+#include <linux/io.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/asoundef.h>
 #include <sound/info.h>
-#include <asm/io.h>
 #include <sound/vx_core.h>
 #include "vx_cmd.h"
 

commit 2a9e8df00951092e825144a9968285398f8aa162
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 10 16:46:35 2014 +0100

    ALSA: vx: Fix missing kerneldoc parameter descriptions
    
    The file isn't processed, but it's not bad to fix beforehand.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index e8cc16993903..fc05a37fd017 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -416,6 +416,7 @@ int vx_send_rih(struct vx_core *chip, int cmd)
 
 /**
  * snd_vx_boot_xilinx - boot up the xilinx interface
+ * @chip: VX core instance
  * @boot: the boot record to load
  */
 int snd_vx_load_boot_image(struct vx_core *chip, const struct firmware *boot)
@@ -538,6 +539,8 @@ EXPORT_SYMBOL(snd_vx_threaded_irq_handler);
 
 /**
  * snd_vx_irq_handler - interrupt handler
+ * @irq: irq number
+ * @dev: VX core instance
  */
 irqreturn_t snd_vx_irq_handler(int irq, void *dev)
 {
@@ -649,6 +652,8 @@ static void vx_proc_init(struct vx_core *chip)
 
 /**
  * snd_vx_dsp_boot - load the DSP boot
+ * @chip: VX core instance
+ * @boot: firmware data
  */
 int snd_vx_dsp_boot(struct vx_core *chip, const struct firmware *boot)
 {
@@ -669,6 +674,8 @@ EXPORT_SYMBOL(snd_vx_dsp_boot);
 
 /**
  * snd_vx_dsp_load - load the DSP image
+ * @chip: VX core instance
+ * @dsp: firmware data
  */
 int snd_vx_dsp_load(struct vx_core *chip, const struct firmware *dsp)
 {
@@ -768,7 +775,10 @@ EXPORT_SYMBOL(snd_vx_resume);
 
 /**
  * snd_vx_create - constructor for struct vx_core
+ * @card: card instance
  * @hw: hardware specific record
+ * @ops: VX ops pointer
+ * @extra_size: extra byte size to allocate appending to chip
  *
  * this function allocates the instance and prepare for the hardware
  * initialization.

commit db0a5214b8d6cc7a90ce3336d24a85b90cbb4e67
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 9 17:17:20 2014 +0200

    ALSA: vx: Use nonatomic PCM ops
    
    Rewrite VXpocket and VX222 drivers to use the new PCM nonatomic ops.
    The former irq tasklet is replaced with a threaded irq handler, and
    the tasklet for the PCM delayed start is simply merged into the normal
    PCM trigger, as well as the replacement of spinlock with mutex.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 83596891cde4..e8cc16993903 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -117,7 +117,7 @@ static int vx_reset_chk(struct vx_core *chip)
  *
  * returns 0 if successful, or a negative error code.
  * the error code can be VX-specific, retrieved via vx_get_error().
- * NB: call with spinlock held!
+ * NB: call with mutex held!
  */
 static int vx_transfer_end(struct vx_core *chip, int cmd)
 {
@@ -155,7 +155,7 @@ static int vx_transfer_end(struct vx_core *chip, int cmd)
  *
  * returns 0 if successful, or a negative error code.
  * the error code can be VX-specific, retrieved via vx_get_error().
- * NB: call with spinlock held!
+ * NB: call with mutex held!
  */
 static int vx_read_status(struct vx_core *chip, struct vx_rmh *rmh)
 {
@@ -236,7 +236,7 @@ static int vx_read_status(struct vx_core *chip, struct vx_rmh *rmh)
  * returns 0 if successful, or a negative error code.
  * the error code can be VX-specific, retrieved via vx_get_error().
  * 
- * this function doesn't call spinlock at all.
+ * this function doesn't call mutex lock at all.
  */
 int vx_send_msg_nolock(struct vx_core *chip, struct vx_rmh *rmh)
 {
@@ -337,7 +337,7 @@ int vx_send_msg_nolock(struct vx_core *chip, struct vx_rmh *rmh)
 
 
 /*
- * vx_send_msg - send a DSP message with spinlock
+ * vx_send_msg - send a DSP message with mutex
  * @rmh: the rmh record to send and receive
  *
  * returns 0 if successful, or a negative error code.
@@ -345,12 +345,11 @@ int vx_send_msg_nolock(struct vx_core *chip, struct vx_rmh *rmh)
  */
 int vx_send_msg(struct vx_core *chip, struct vx_rmh *rmh)
 {
-	unsigned long flags;
 	int err;
 
-	spin_lock_irqsave(&chip->lock, flags);
+	mutex_lock(&chip->lock);
 	err = vx_send_msg_nolock(chip, rmh);
-	spin_unlock_irqrestore(&chip->lock, flags);
+	mutex_unlock(&chip->lock);
 	return err;
 }
 
@@ -362,7 +361,7 @@ int vx_send_msg(struct vx_core *chip, struct vx_rmh *rmh)
  * returns 0 if successful, or a negative error code.
  * the error code can be VX-specific, retrieved via vx_get_error().
  *
- * this function doesn't call spinlock at all.
+ * this function doesn't call mutex at all.
  *
  * unlike RMH, no command is sent to DSP.
  */
@@ -398,19 +397,18 @@ int vx_send_rih_nolock(struct vx_core *chip, int cmd)
 
 
 /*
- * vx_send_rih - send an RIH with spinlock
+ * vx_send_rih - send an RIH with mutex
  * @cmd: the command to send
  *
  * see vx_send_rih_nolock().
  */
 int vx_send_rih(struct vx_core *chip, int cmd)
 {
-	unsigned long flags;
 	int err;
 
-	spin_lock_irqsave(&chip->lock, flags);
+	mutex_lock(&chip->lock);
 	err = vx_send_rih_nolock(chip, cmd);
-	spin_unlock_irqrestore(&chip->lock, flags);
+	mutex_unlock(&chip->lock);
 	return err;
 }
 
@@ -482,30 +480,30 @@ static int vx_test_irq_src(struct vx_core *chip, unsigned int *ret)
 	int err;
 
 	vx_init_rmh(&chip->irq_rmh, CMD_TEST_IT);
-	spin_lock(&chip->lock);
+	mutex_lock(&chip->lock);
 	err = vx_send_msg_nolock(chip, &chip->irq_rmh);
 	if (err < 0)
 		*ret = 0;
 	else
 		*ret = chip->irq_rmh.Stat[0];
-	spin_unlock(&chip->lock);
+	mutex_unlock(&chip->lock);
 	return err;
 }
 
 
 /*
- * vx_interrupt - soft irq handler
+ * snd_vx_threaded_irq_handler - threaded irq handler
  */
-static void vx_interrupt(unsigned long private_data)
+irqreturn_t snd_vx_threaded_irq_handler(int irq, void *dev)
 {
-	struct vx_core *chip = (struct vx_core *) private_data;
+	struct vx_core *chip = dev;
 	unsigned int events;
 		
 	if (chip->chip_status & VX_STAT_IS_STALE)
-		return;
+		return IRQ_HANDLED;
 
 	if (vx_test_irq_src(chip, &events) < 0)
-		return;
+		return IRQ_HANDLED;
     
 #if 0
 	if (events & 0x000800)
@@ -519,7 +517,7 @@ static void vx_interrupt(unsigned long private_data)
 	 */
 	if (events & FATAL_DSP_ERROR) {
 		snd_printk(KERN_ERR "vx_core: fatal DSP error!!\n");
-		return;
+		return IRQ_HANDLED;
 	}
 
 	/* The start on time code conditions are filled (ie the time code
@@ -534,8 +532,9 @@ static void vx_interrupt(unsigned long private_data)
 
 	/* update the pcm streams */
 	vx_pcm_update_intr(chip, events);
+	return IRQ_HANDLED;
 }
-
+EXPORT_SYMBOL(snd_vx_threaded_irq_handler);
 
 /**
  * snd_vx_irq_handler - interrupt handler
@@ -548,8 +547,8 @@ irqreturn_t snd_vx_irq_handler(int irq, void *dev)
 	    (chip->chip_status & VX_STAT_IS_STALE))
 		return IRQ_NONE;
 	if (! vx_test_and_ack(chip))
-		tasklet_schedule(&chip->tq);
-	return IRQ_HANDLED;
+		return IRQ_WAKE_THREAD;
+	return IRQ_NONE;
 }
 
 EXPORT_SYMBOL(snd_vx_irq_handler);
@@ -790,13 +789,11 @@ struct vx_core *snd_vx_create(struct snd_card *card, struct snd_vx_hardware *hw,
 		snd_printk(KERN_ERR "vx_core: no memory\n");
 		return NULL;
 	}
-	spin_lock_init(&chip->lock);
-	spin_lock_init(&chip->irq_lock);
+	mutex_init(&chip->lock);
 	chip->irq = -1;
 	chip->hw = hw;
 	chip->type = hw->type;
 	chip->ops = ops;
-	tasklet_init(&chip->tq, vx_interrupt, (unsigned long)chip);
 	mutex_init(&chip->mixer_mutex);
 
 	chip->card = card;

commit fefe228c5f13809f77e6b2873ffe8bfb006cadd4
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Jun 21 15:25:33 2013 +0300

    ALSA: vx_core: off by one in vx_read_status()
    
    This code is older than git, and I haven't tested it, but if size ==
    SIZE_MAX_STATUS then we would write one space past the end of the
    rmh->Stat[] array.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index c39961c11401..83596891cde4 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -205,7 +205,7 @@ static int vx_read_status(struct vx_core *chip, struct vx_rmh *rmh)
 
 	if (size < 1)
 		return 0;
-	if (snd_BUG_ON(size > SIZE_MAX_STATUS))
+	if (snd_BUG_ON(size >= SIZE_MAX_STATUS))
 		return -EINVAL;
 
 	for (i = 1; i <= size; i++) {

commit 86b2723725a2e186f5699d97cb20014fa893931f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 25 10:54:07 2013 +0100

    ALSA: Make snd_printd() and snd_printdd() inline
    
    Because currently snd_printd() and snd_printdd() macros are expanded
    to empty when CONFIG_SND_DEBUG=n, a compile warning like below
    appears sometimes, and we had to covert it by ugly ifdefs:
      sound/pci/hda/patch_sigmatel.c: In function ‘stac92hd71bxx_fixup_hp’:
      sound/pci/hda/patch_sigmatel.c:2434:24: warning: unused variable ‘spec’ [-Wunused-variable]
    
    For "fixing" these issues better, this patch replaces snd_printd() and
    snd_printdd() definitions with empty inline functions instead of
    macros.  This should have the same effect but shut up warnings like
    above.
    
    But since we had already put ifdefs, changing to inline functions
    would trigger compile errors.  So, such ifdefs is removed in this
    patch.
    
    In addition, snd_pci_quirk name field is defined only when
    CONFIG_SND_DEBUG_VERBOSE is set, and the reference to it in
    snd_printdd() argument triggers the build errors, too.  For avoiding
    these errors, introduce a new macro snd_pci_quirk_name() that is
    defined no matter how the debug option is set.
    
    Reported-by: Stratos Karafotis <stratosk@semaphore.gr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index de5055a3b0d0..c39961c11401 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -52,7 +52,6 @@ MODULE_LICENSE("GPL");
 int snd_vx_check_reg_bit(struct vx_core *chip, int reg, int mask, int bit, int time)
 {
 	unsigned long end_time = jiffies + (time * HZ + 999) / 1000;
-#ifdef CONFIG_SND_DEBUG
 	static char *reg_names[VX_REG_MAX] = {
 		"ICR", "CVR", "ISR", "IVR", "RXH", "RXM", "RXL",
 		"DMA", "CDSP", "RFREQ", "RUER/V2", "DATA", "MEMIRQ",
@@ -60,7 +59,7 @@ int snd_vx_check_reg_bit(struct vx_core *chip, int reg, int mask, int bit, int t
 		"MIC3", "INTCSR", "CNTRL", "GPIOC",
 		"LOFREQ", "HIFREQ", "CSUER", "RUER"
 	};
-#endif
+
 	do {
 		if ((snd_vx_inb(chip, reg) & mask) == bit)
 			return 0;

commit 68cb2b559278858ef9f3a7722f95df88797c7840
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 15:20:37 2012 +0200

    ALSA: Convert to new pm_ops for PCI drivers
    
    Straightforward conversion to the new pm_ops from the legacy
    suspend/resume ops.
    
    Since we change vx222, vx_core and vxpocket have to be converted,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index b8e515999bc2..de5055a3b0d0 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -725,7 +725,7 @@ EXPORT_SYMBOL(snd_vx_dsp_load);
 /*
  * suspend
  */
-int snd_vx_suspend(struct vx_core *chip, pm_message_t state)
+int snd_vx_suspend(struct vx_core *chip)
 {
 	unsigned int i;
 

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 19c6e376c7c7..b8e515999bc2 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -26,6 +26,7 @@
 #include <linux/init.h>
 #include <linux/device.h>
 #include <linux/firmware.h>
+#include <linux/module.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/asoundef.h>

commit 45203832df2fa9e94ca0a249ddb20d2b077e58cc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 15:51:50 2009 +0100

    ALSA: Add missing KERN_* prefix to printk in sound/drivers
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 14e3354be43a..19c6e376c7c7 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -688,7 +688,8 @@ int snd_vx_dsp_load(struct vx_core *chip, const struct firmware *dsp)
 		image = dsp->data + i;
 		/* Wait DSP ready for a new read */
 		if ((err = vx_wait_isr_bit(chip, ISR_TX_EMPTY)) < 0) {
-			printk("dsp loading error at position %d\n", i);
+			printk(KERN_ERR
+			       "dsp loading error at position %d\n", i);
 			return err;
 		}
 		cptr = image;

commit 1f04128a3db7c0f0e8b5d25323eba70ac342f47f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 18 12:17:55 2008 +0100

    ALSA: hda - Convert from takslet_hi_schedule() to tasklet_schedule()
    
    Replace all tasklet_hi_schedule() callers with the normal
    tasklet_schedule().  The former often causes troubles with
    RT-kernels, and has actually no merit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 473b07f6ae85..14e3354be43a 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -548,7 +548,7 @@ irqreturn_t snd_vx_irq_handler(int irq, void *dev)
 	    (chip->chip_status & VX_STAT_IS_STALE))
 		return IRQ_NONE;
 	if (! vx_test_and_ack(chip))
-		tasklet_hi_schedule(&chip->tq);
+		tasklet_schedule(&chip->tq);
 	return IRQ_HANDLED;
 }
 

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 585af2eb1438..473b07f6ae85 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -205,7 +205,8 @@ static int vx_read_status(struct vx_core *chip, struct vx_rmh *rmh)
 
 	if (size < 1)
 		return 0;
-	snd_assert(size <= SIZE_MAX_STATUS, return -EINVAL);
+	if (snd_BUG_ON(size > SIZE_MAX_STATUS))
+		return -EINVAL;
 
 	for (i = 1; i <= size; i++) {
 		/* trigger an irq MESS_WRITE_NEXT */
@@ -425,13 +426,16 @@ int snd_vx_load_boot_image(struct vx_core *chip, const struct firmware *boot)
 	int no_fillup = vx_has_new_dsp(chip);
 
 	/* check the length of boot image */
-	snd_assert(boot->size > 0, return -EINVAL);
-	snd_assert(boot->size % 3 == 0, return -EINVAL);
+	if (boot->size <= 0)
+		return -EINVAL;
+	if (boot->size % 3)
+		return -EINVAL;
 #if 0
 	{
 		/* more strict check */
 		unsigned int c = ((u32)boot->data[0] << 16) | ((u32)boot->data[1] << 8) | boot->data[2];
-		snd_assert(boot->size == (c + 2) * 3, return -EINVAL);
+		if (boot->size != (c + 2) * 3)
+			return -EINVAL;
 	}
 #endif
 
@@ -554,7 +558,8 @@ EXPORT_SYMBOL(snd_vx_irq_handler);
  */
 static void vx_reset_board(struct vx_core *chip, int cold_reset)
 {
-	snd_assert(chip->ops->reset_board, return);
+	if (snd_BUG_ON(!chip->ops->reset_board))
+		return;
 
 	/* current source, later sync'ed with target */
 	chip->audio_source = VX_AUDIO_SRC_LINE;
@@ -673,7 +678,8 @@ int snd_vx_dsp_load(struct vx_core *chip, const struct firmware *dsp)
 	unsigned int csum = 0;
 	const unsigned char *image, *cptr;
 
-	snd_assert(dsp->size % 3 == 0, return -EINVAL);
+	if (dsp->size % 3)
+		return -EINVAL;
 
 	vx_toggle_dac_mute(chip, 1);
 
@@ -775,7 +781,8 @@ struct vx_core *snd_vx_create(struct snd_card *card, struct snd_vx_hardware *hw,
 {
 	struct vx_core *chip;
 
-	snd_assert(card && hw && ops, return NULL);
+	if (snd_BUG_ON(!card || !hw || !ops))
+		return NULL;
 
 	chip = kzalloc(sizeof(*chip) + extra_size, GFP_KERNEL);
 	if (! chip) {

commit 2f0600b639777cbc1c0ae3f7bbbc982b0838e706
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sat May 24 00:02:49 2008 +0100

    vx: treat firmware data as const
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 99538862e342..585af2eb1438 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -453,7 +453,7 @@ int snd_vx_load_boot_image(struct vx_core *chip, const struct firmware *boot)
 			vx_outb(chip, TXM, 0);
 			vx_outb(chip, TXL, 0);
 		} else {
-			unsigned char *image = boot->data + i;
+			const unsigned char *image = boot->data + i;
 			if (vx_wait_isr_bit(chip, ISR_TX_EMPTY) < 0) {
 				snd_printk(KERN_ERR "dsp boot failed at %d\n", i);
 				return -EIO;
@@ -671,7 +671,7 @@ int snd_vx_dsp_load(struct vx_core *chip, const struct firmware *dsp)
 	unsigned int i;
 	int err;
 	unsigned int csum = 0;
-	unsigned char *image, *cptr;
+	const unsigned char *image, *cptr;
 
 	snd_assert(dsp->size % 3 == 0, return -EINVAL);
 

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index ed19bc17400b..99538862e342 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -20,7 +20,6 @@
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
-#include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index a60168268ddd..ed19bc17400b 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -537,7 +537,7 @@ static void vx_interrupt(unsigned long private_data)
 /**
  * snd_vx_irq_handler - interrupt handler
  */
-irqreturn_t snd_vx_irq_handler(int irq, void *dev, struct pt_regs *regs)
+irqreturn_t snd_vx_irq_handler(int irq, void *dev)
 {
 	struct vx_core *chip = dev;
 

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index e1c3dda15774..a60168268ddd 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -640,7 +640,7 @@ static void vx_proc_init(struct vx_core *chip)
 	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(chip->card, "vx-status", &entry))
-		snd_info_set_text_ops(entry, chip, 1024, vx_proc_read);
+		snd_info_set_text_ops(entry, chip, vx_proc_read);
 }
 
 

commit fa325eb3afc3cdaf7fba6ee3eaf05b243f5614a3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:40 2006 +0200

    [ALSA] vx - Move EXPORT_SYMBOL() to adjacent to each function
    
    Move EXPORT_SYMBOL() to adjacent to each exported function/variable.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index fa4a2b5c2d8d..e1c3dda15774 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -70,6 +70,8 @@ int snd_vx_check_reg_bit(struct vx_core *chip, int reg, int mask, int bit, int t
 	return -EIO;
 }
 
+EXPORT_SYMBOL(snd_vx_check_reg_bit);
+
 /*
  * vx_send_irq_dsp - set command irq bit
  * @num: the requested IRQ type, IRQ_XXX
@@ -465,6 +467,8 @@ int snd_vx_load_boot_image(struct vx_core *chip, const struct firmware *boot)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_vx_load_boot_image);
+
 /*
  * vx_test_irq_src - query the source of interrupts
  *
@@ -545,6 +549,7 @@ irqreturn_t snd_vx_irq_handler(int irq, void *dev, struct pt_regs *regs)
 	return IRQ_HANDLED;
 }
 
+EXPORT_SYMBOL(snd_vx_irq_handler);
 
 /*
  */
@@ -657,6 +662,8 @@ int snd_vx_dsp_boot(struct vx_core *chip, const struct firmware *boot)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_vx_dsp_boot);
+
 /**
  * snd_vx_dsp_load - load the DSP image
  */
@@ -705,6 +712,8 @@ int snd_vx_dsp_load(struct vx_core *chip, const struct firmware *dsp)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_vx_dsp_load);
+
 #ifdef CONFIG_PM
 /*
  * suspend
@@ -721,6 +730,8 @@ int snd_vx_suspend(struct vx_core *chip, pm_message_t state)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_vx_suspend);
+
 /*
  * resume
  */
@@ -747,6 +758,7 @@ int snd_vx_resume(struct vx_core *chip)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_vx_resume);
 #endif
 
 /**
@@ -790,6 +802,8 @@ struct vx_core *snd_vx_create(struct snd_card *card, struct snd_vx_hardware *hw,
 	return chip;
 }
 
+EXPORT_SYMBOL(snd_vx_create);
+
 /*
  * module entries
  */
@@ -804,19 +818,3 @@ static void __exit alsa_vx_core_exit(void)
 
 module_init(alsa_vx_core_init)
 module_exit(alsa_vx_core_exit)
-
-/*
- * exports
- */
-EXPORT_SYMBOL(snd_vx_check_reg_bit);
-EXPORT_SYMBOL(snd_vx_create);
-EXPORT_SYMBOL(snd_vx_setup_firmware);
-EXPORT_SYMBOL(snd_vx_free_firmware);
-EXPORT_SYMBOL(snd_vx_irq_handler);
-EXPORT_SYMBOL(snd_vx_dsp_boot);
-EXPORT_SYMBOL(snd_vx_dsp_load);
-EXPORT_SYMBOL(snd_vx_load_boot_image);
-#ifdef CONFIG_PM
-EXPORT_SYMBOL(snd_vx_suspend);
-EXPORT_SYMBOL(snd_vx_resume);
-#endif

commit ef9f0a42db987e7e2df72289fb4522d24027786b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:31:42 2006 +0100

    [ALSA] semaphore -> mutex (driver part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 43f615d7a545..fa4a2b5c2d8d 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -778,7 +778,7 @@ struct vx_core *snd_vx_create(struct snd_card *card, struct snd_vx_hardware *hw,
 	chip->type = hw->type;
 	chip->ops = ops;
 	tasklet_init(&chip->tq, vx_interrupt, (unsigned long)chip);
-	init_MUTEX(&chip->mixer_mutex);
+	mutex_init(&chip->mixer_mutex);
 
 	chip->card = card;
 	card->private_data = chip;

commit 0ed1cad172176a4595f82e8cd9055938ad54bd4b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 16:06:05 2005 +0100

    [ALSA] vx-driver - Fix PM support
    
    Fix PM support on VX drivers (vxpocket and vx222).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 5abf42351772..43f615d7a545 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -709,13 +709,11 @@ int snd_vx_dsp_load(struct vx_core *chip, const struct firmware *dsp)
 /*
  * suspend
  */
-static int snd_vx_suspend(struct snd_card *card, pm_message_t state)
+int snd_vx_suspend(struct vx_core *chip, pm_message_t state)
 {
-	struct vx_core *chip = card->pm_private_data;
 	unsigned int i;
 
-	snd_assert(chip, return -EINVAL);
-
+	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
 	chip->chip_status |= VX_STAT_IN_SUSPEND;
 	for (i = 0; i < chip->hw->num_codecs; i++)
 		snd_pcm_suspend_all(chip->pcm[i]);
@@ -726,13 +724,10 @@ static int snd_vx_suspend(struct snd_card *card, pm_message_t state)
 /*
  * resume
  */
-static int snd_vx_resume(struct snd_card *card)
+int snd_vx_resume(struct vx_core *chip)
 {
-	struct vx_core *chip = card->pm_private_data;
 	int i, err;
 
-	snd_assert(chip, return -EINVAL);
-
 	chip->chip_status &= ~VX_STAT_CHIP_INIT;
 
 	for (i = 0; i < 4; i++) {
@@ -748,6 +743,7 @@ static int snd_vx_resume(struct snd_card *card)
 	chip->chip_status |= VX_STAT_CHIP_INIT;
 	chip->chip_status &= ~VX_STAT_IN_SUSPEND;
 
+	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 
@@ -789,8 +785,6 @@ struct vx_core *snd_vx_create(struct snd_card *card, struct snd_vx_hardware *hw,
 	strcpy(card->driver, hw->name);
 	sprintf(card->shortname, "Digigram %s", hw->name);
 
-	snd_card_set_pm_callback(card, snd_vx_suspend, snd_vx_resume, chip);
-
 	vx_proc_init(chip);
 
 	return chip;
@@ -822,3 +816,7 @@ EXPORT_SYMBOL(snd_vx_irq_handler);
 EXPORT_SYMBOL(snd_vx_dsp_boot);
 EXPORT_SYMBOL(snd_vx_dsp_load);
 EXPORT_SYMBOL(snd_vx_load_boot_image);
+#ifdef CONFIG_PM
+EXPORT_SYMBOL(snd_vx_suspend);
+EXPORT_SYMBOL(snd_vx_resume);
+#endif

commit af26367f69a474ed809e4a59abb5855b47daaff4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:46:59 2005 +0100

    [ALSA] Remove xxx_t typedefs: VXdriver
    
    Remove xxx_t typedefs from the VXdriver codes
    (vx_core support, vx222 and vxpocket).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index e6e4cf997419..5abf42351772 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -49,7 +49,7 @@ MODULE_LICENSE("GPL");
  *
  * returns zero if a bit matches, or a negative error code.
  */
-int snd_vx_check_reg_bit(vx_core_t *chip, int reg, int mask, int bit, int time)
+int snd_vx_check_reg_bit(struct vx_core *chip, int reg, int mask, int bit, int time)
 {
 	unsigned long end_time = jiffies + (time * HZ + 999) / 1000;
 #ifdef CONFIG_SND_DEBUG
@@ -78,7 +78,7 @@ int snd_vx_check_reg_bit(vx_core_t *chip, int reg, int mask, int bit, int time)
  * returns 0 if successful, or a negative error code.
  * 
  */
-static int vx_send_irq_dsp(vx_core_t *chip, int num)
+static int vx_send_irq_dsp(struct vx_core *chip, int num)
 {
 	int nirq;
 
@@ -99,7 +99,7 @@ static int vx_send_irq_dsp(vx_core_t *chip, int num)
  *
  * returns 0 if successful, or a negative error code.
  */
-static int vx_reset_chk(vx_core_t *chip)
+static int vx_reset_chk(struct vx_core *chip)
 {
 	/* Reset irq CHK */
 	if (vx_send_irq_dsp(chip, IRQ_RESET_CHK) < 0)
@@ -118,7 +118,7 @@ static int vx_reset_chk(vx_core_t *chip)
  * the error code can be VX-specific, retrieved via vx_get_error().
  * NB: call with spinlock held!
  */
-static int vx_transfer_end(vx_core_t *chip, int cmd)
+static int vx_transfer_end(struct vx_core *chip, int cmd)
 {
 	int err;
 
@@ -156,7 +156,7 @@ static int vx_transfer_end(vx_core_t *chip, int cmd)
  * the error code can be VX-specific, retrieved via vx_get_error().
  * NB: call with spinlock held!
  */
-static int vx_read_status(vx_core_t *chip, struct vx_rmh *rmh)
+static int vx_read_status(struct vx_core *chip, struct vx_rmh *rmh)
 {
 	int i, err, val, size;
 
@@ -236,7 +236,7 @@ static int vx_read_status(vx_core_t *chip, struct vx_rmh *rmh)
  * 
  * this function doesn't call spinlock at all.
  */
-int vx_send_msg_nolock(vx_core_t *chip, struct vx_rmh *rmh)
+int vx_send_msg_nolock(struct vx_core *chip, struct vx_rmh *rmh)
 {
 	int i, err;
 	
@@ -341,7 +341,7 @@ int vx_send_msg_nolock(vx_core_t *chip, struct vx_rmh *rmh)
  * returns 0 if successful, or a negative error code.
  * see vx_send_msg_nolock().
  */
-int vx_send_msg(vx_core_t *chip, struct vx_rmh *rmh)
+int vx_send_msg(struct vx_core *chip, struct vx_rmh *rmh)
 {
 	unsigned long flags;
 	int err;
@@ -364,7 +364,7 @@ int vx_send_msg(vx_core_t *chip, struct vx_rmh *rmh)
  *
  * unlike RMH, no command is sent to DSP.
  */
-int vx_send_rih_nolock(vx_core_t *chip, int cmd)
+int vx_send_rih_nolock(struct vx_core *chip, int cmd)
 {
 	int err;
 
@@ -401,7 +401,7 @@ int vx_send_rih_nolock(vx_core_t *chip, int cmd)
  *
  * see vx_send_rih_nolock().
  */
-int vx_send_rih(vx_core_t *chip, int cmd)
+int vx_send_rih(struct vx_core *chip, int cmd)
 {
 	unsigned long flags;
 	int err;
@@ -418,7 +418,7 @@ int vx_send_rih(vx_core_t *chip, int cmd)
  * snd_vx_boot_xilinx - boot up the xilinx interface
  * @boot: the boot record to load
  */
-int snd_vx_load_boot_image(vx_core_t *chip, const struct firmware *boot)
+int snd_vx_load_boot_image(struct vx_core *chip, const struct firmware *boot)
 {
 	unsigned int i;
 	int no_fillup = vx_has_new_dsp(chip);
@@ -470,7 +470,7 @@ int snd_vx_load_boot_image(vx_core_t *chip, const struct firmware *boot)
  *
  * called from irq handler only
  */
-static int vx_test_irq_src(vx_core_t *chip, unsigned int *ret)
+static int vx_test_irq_src(struct vx_core *chip, unsigned int *ret)
 {
 	int err;
 
@@ -491,7 +491,7 @@ static int vx_test_irq_src(vx_core_t *chip, unsigned int *ret)
  */
 static void vx_interrupt(unsigned long private_data)
 {
-	vx_core_t *chip = (vx_core_t *) private_data;
+	struct vx_core *chip = (struct vx_core *) private_data;
 	unsigned int events;
 		
 	if (chip->chip_status & VX_STAT_IS_STALE)
@@ -535,7 +535,7 @@ static void vx_interrupt(unsigned long private_data)
  */
 irqreturn_t snd_vx_irq_handler(int irq, void *dev, struct pt_regs *regs)
 {
-	vx_core_t *chip = dev;
+	struct vx_core *chip = dev;
 
 	if (! (chip->chip_status & VX_STAT_CHIP_INIT) ||
 	    (chip->chip_status & VX_STAT_IS_STALE))
@@ -548,7 +548,7 @@ irqreturn_t snd_vx_irq_handler(int irq, void *dev, struct pt_regs *regs)
 
 /*
  */
-static void vx_reset_board(vx_core_t *chip, int cold_reset)
+static void vx_reset_board(struct vx_core *chip, int cold_reset)
 {
 	snd_assert(chip->ops->reset_board, return);
 
@@ -587,9 +587,9 @@ static void vx_reset_board(vx_core_t *chip, int cold_reset)
  * proc interface
  */
 
-static void vx_proc_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+static void vx_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
-	vx_core_t *chip = entry->private_data;
+	struct vx_core *chip = entry->private_data;
 	static char *audio_src_vxp[] = { "Line", "Mic", "Digital" };
 	static char *audio_src_vx2[] = { "Analog", "Analog", "Digital" };
 	static char *clock_mode[] = { "Auto", "Internal", "External" };
@@ -630,9 +630,9 @@ static void vx_proc_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
 		    chip->ibl.granularity);
 }
 
-static void vx_proc_init(vx_core_t *chip)
+static void vx_proc_init(struct vx_core *chip)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(chip->card, "vx-status", &entry))
 		snd_info_set_text_ops(entry, chip, 1024, vx_proc_read);
@@ -642,7 +642,7 @@ static void vx_proc_init(vx_core_t *chip)
 /**
  * snd_vx_dsp_boot - load the DSP boot
  */
-int snd_vx_dsp_boot(vx_core_t *chip, const struct firmware *boot)
+int snd_vx_dsp_boot(struct vx_core *chip, const struct firmware *boot)
 {
 	int err;
 	int cold_reset = !(chip->chip_status & VX_STAT_DEVICE_INIT);
@@ -660,7 +660,7 @@ int snd_vx_dsp_boot(vx_core_t *chip, const struct firmware *boot)
 /**
  * snd_vx_dsp_load - load the DSP image
  */
-int snd_vx_dsp_load(vx_core_t *chip, const struct firmware *dsp)
+int snd_vx_dsp_load(struct vx_core *chip, const struct firmware *dsp)
 {
 	unsigned int i;
 	int err;
@@ -709,9 +709,9 @@ int snd_vx_dsp_load(vx_core_t *chip, const struct firmware *dsp)
 /*
  * suspend
  */
-static int snd_vx_suspend(snd_card_t *card, pm_message_t state)
+static int snd_vx_suspend(struct snd_card *card, pm_message_t state)
 {
-	vx_core_t *chip = card->pm_private_data;
+	struct vx_core *chip = card->pm_private_data;
 	unsigned int i;
 
 	snd_assert(chip, return -EINVAL);
@@ -726,9 +726,9 @@ static int snd_vx_suspend(snd_card_t *card, pm_message_t state)
 /*
  * resume
  */
-static int snd_vx_resume(snd_card_t *card)
+static int snd_vx_resume(struct snd_card *card)
 {
-	vx_core_t *chip = card->pm_private_data;
+	struct vx_core *chip = card->pm_private_data;
 	int i, err;
 
 	snd_assert(chip, return -EINVAL);
@@ -754,7 +754,7 @@ static int snd_vx_resume(snd_card_t *card)
 #endif
 
 /**
- * snd_vx_create - constructor for vx_core_t
+ * snd_vx_create - constructor for struct vx_core
  * @hw: hardware specific record
  *
  * this function allocates the instance and prepare for the hardware
@@ -762,11 +762,11 @@ static int snd_vx_resume(snd_card_t *card)
  *
  * return the instance pointer if successful, NULL in error.
  */
-vx_core_t *snd_vx_create(snd_card_t *card, struct snd_vx_hardware *hw,
-			 struct snd_vx_ops *ops,
-			 int extra_size)
+struct vx_core *snd_vx_create(struct snd_card *card, struct snd_vx_hardware *hw,
+			      struct snd_vx_ops *ops,
+			      int extra_size)
 {
-	vx_core_t *chip;
+	struct vx_core *chip;
 
 	snd_assert(card && hw && ops, return NULL);
 

commit bdbae7e62837c22c5399df0789a24e9d8a1d675f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 10:21:19 2005 +0100

    [ALSA] Remove snd_vx_delay() function
    
    Replace snd_vx_delay() with appropriate delay/sleep functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index 4697b1d75cbb..e6e4cf997419 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -40,18 +40,6 @@ MODULE_DESCRIPTION("Common routines for Digigram VX drivers");
 MODULE_LICENSE("GPL");
 
 
-/*
- * snd_vx_delay - delay for the specified time
- * @xmsec: the time to delay in msec
- */
-void snd_vx_delay(vx_core_t *chip, int xmsec)
-{
-	if (! in_interrupt() && xmsec >= 1000 / HZ)
-		msleep(xmsec);
-	else
-		mdelay(xmsec);
-}
-
 /*
  * vx_check_reg_bit - wait for the specified bit is set/reset on a register
  * @reg: register to check
@@ -76,7 +64,7 @@ int snd_vx_check_reg_bit(vx_core_t *chip, int reg, int mask, int bit, int time)
 	do {
 		if ((snd_vx_inb(chip, reg) & mask) == bit)
 			return 0;
-		//snd_vx_delay(chip, 10);
+		//msleep(10);
 	} while (time_after_eq(end_time, jiffies));
 	snd_printd(KERN_DEBUG "vx_check_reg_bit: timeout, reg=%s, mask=0x%x, val=0x%x\n", reg_names[reg], mask, snd_vx_inb(chip, reg));
 	return -EIO;
@@ -664,7 +652,7 @@ int snd_vx_dsp_boot(vx_core_t *chip, const struct firmware *boot)
 
 	if ((err = snd_vx_load_boot_image(chip, boot)) < 0)
 		return err;
-	snd_vx_delay(chip, 10);
+	msleep(10);
 
 	return 0;
 }
@@ -704,7 +692,7 @@ int snd_vx_dsp_load(vx_core_t *chip, const struct firmware *dsp)
 	}
 	snd_printdd(KERN_DEBUG "checksum = 0x%08x\n", csum);
 
-	snd_vx_delay(chip, 200);
+	msleep(200);
 
 	if ((err = vx_wait_isr_bit(chip, ISR_CHK)) < 0)
 		return err;
@@ -831,7 +819,6 @@ EXPORT_SYMBOL(snd_vx_create);
 EXPORT_SYMBOL(snd_vx_setup_firmware);
 EXPORT_SYMBOL(snd_vx_free_firmware);
 EXPORT_SYMBOL(snd_vx_irq_handler);
-EXPORT_SYMBOL(snd_vx_delay);
 EXPORT_SYMBOL(snd_vx_dsp_boot);
 EXPORT_SYMBOL(snd_vx_dsp_load);
 EXPORT_SYMBOL(snd_vx_load_boot_image);

commit 561b220a4dece18d67177413e6fa21b49aa4acce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:22:34 2005 +0200

    [ALSA] Replace with kzalloc() - others
    
    Documentation,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,OPL3
    OPL4,Digigram VX core,I2C cs8427,I2C lib core,I2C tea6330t,L3 drivers
    AK4114 receiver,AK4117 receiver,PDAudioCF driver,PPC PMAC driver
    SPARC AMD7930 driver,SPARC cs4231 driver,Synth,Common EMU synth
    USB generic driver,USB USX2Y
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
index c6fa5afa3e9a..4697b1d75cbb 100644
--- a/sound/drivers/vx/vx_core.c
+++ b/sound/drivers/vx/vx_core.c
@@ -782,7 +782,7 @@ vx_core_t *snd_vx_create(snd_card_t *card, struct snd_vx_hardware *hw,
 
 	snd_assert(card && hw && ops, return NULL);
 
-	chip = kcalloc(1, sizeof(*chip) + extra_size, GFP_KERNEL);
+	chip = kzalloc(sizeof(*chip) + extra_size, GFP_KERNEL);
 	if (! chip) {
 		snd_printk(KERN_ERR "vx_core: no memory\n");
 		return NULL;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/drivers/vx/vx_core.c b/sound/drivers/vx/vx_core.c
new file mode 100644
index 000000000000..c6fa5afa3e9a
--- /dev/null
+++ b/sound/drivers/vx/vx_core.c
@@ -0,0 +1,837 @@
+/*
+ * Driver for Digigram VX soundcards
+ *
+ * Hardware core part
+ *
+ * Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/asoundef.h>
+#include <sound/info.h>
+#include <asm/io.h>
+#include <sound/vx_core.h>
+#include "vx_cmd.h"
+
+MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
+MODULE_DESCRIPTION("Common routines for Digigram VX drivers");
+MODULE_LICENSE("GPL");
+
+
+/*
+ * snd_vx_delay - delay for the specified time
+ * @xmsec: the time to delay in msec
+ */
+void snd_vx_delay(vx_core_t *chip, int xmsec)
+{
+	if (! in_interrupt() && xmsec >= 1000 / HZ)
+		msleep(xmsec);
+	else
+		mdelay(xmsec);
+}
+
+/*
+ * vx_check_reg_bit - wait for the specified bit is set/reset on a register
+ * @reg: register to check
+ * @mask: bit mask
+ * @bit: resultant bit to be checked
+ * @time: time-out of loop in msec
+ *
+ * returns zero if a bit matches, or a negative error code.
+ */
+int snd_vx_check_reg_bit(vx_core_t *chip, int reg, int mask, int bit, int time)
+{
+	unsigned long end_time = jiffies + (time * HZ + 999) / 1000;
+#ifdef CONFIG_SND_DEBUG
+	static char *reg_names[VX_REG_MAX] = {
+		"ICR", "CVR", "ISR", "IVR", "RXH", "RXM", "RXL",
+		"DMA", "CDSP", "RFREQ", "RUER/V2", "DATA", "MEMIRQ",
+		"ACQ", "BIT0", "BIT1", "MIC0", "MIC1", "MIC2",
+		"MIC3", "INTCSR", "CNTRL", "GPIOC",
+		"LOFREQ", "HIFREQ", "CSUER", "RUER"
+	};
+#endif
+	do {
+		if ((snd_vx_inb(chip, reg) & mask) == bit)
+			return 0;
+		//snd_vx_delay(chip, 10);
+	} while (time_after_eq(end_time, jiffies));
+	snd_printd(KERN_DEBUG "vx_check_reg_bit: timeout, reg=%s, mask=0x%x, val=0x%x\n", reg_names[reg], mask, snd_vx_inb(chip, reg));
+	return -EIO;
+}
+
+/*
+ * vx_send_irq_dsp - set command irq bit
+ * @num: the requested IRQ type, IRQ_XXX
+ *
+ * this triggers the specified IRQ request
+ * returns 0 if successful, or a negative error code.
+ * 
+ */
+static int vx_send_irq_dsp(vx_core_t *chip, int num)
+{
+	int nirq;
+
+	/* wait for Hc = 0 */
+	if (snd_vx_check_reg_bit(chip, VX_CVR, CVR_HC, 0, 200) < 0)
+		return -EIO;
+
+	nirq = num;
+	if (vx_has_new_dsp(chip))
+		nirq += VXP_IRQ_OFFSET;
+	vx_outb(chip, CVR, (nirq >> 1) | CVR_HC);
+	return 0;
+}
+
+
+/*
+ * vx_reset_chk - reset CHK bit on ISR
+ *
+ * returns 0 if successful, or a negative error code.
+ */
+static int vx_reset_chk(vx_core_t *chip)
+{
+	/* Reset irq CHK */
+	if (vx_send_irq_dsp(chip, IRQ_RESET_CHK) < 0)
+		return -EIO;
+	/* Wait until CHK = 0 */
+	if (vx_check_isr(chip, ISR_CHK, 0, 200) < 0)
+		return -EIO;
+	return 0;
+}
+
+/*
+ * vx_transfer_end - terminate message transfer
+ * @cmd: IRQ message to send (IRQ_MESS_XXX_END)
+ *
+ * returns 0 if successful, or a negative error code.
+ * the error code can be VX-specific, retrieved via vx_get_error().
+ * NB: call with spinlock held!
+ */
+static int vx_transfer_end(vx_core_t *chip, int cmd)
+{
+	int err;
+
+	if ((err = vx_reset_chk(chip)) < 0)
+		return err;
+
+	/* irq MESS_READ/WRITE_END */
+	if ((err = vx_send_irq_dsp(chip, cmd)) < 0)
+		return err;
+
+	/* Wait CHK = 1 */
+	if ((err = vx_wait_isr_bit(chip, ISR_CHK)) < 0)
+		return err;
+
+	/* If error, Read RX */
+	if ((err = vx_inb(chip, ISR)) & ISR_ERR) {
+		if ((err = vx_wait_for_rx_full(chip)) < 0) {
+			snd_printd(KERN_DEBUG "transfer_end: error in rx_full\n");
+			return err;
+		}
+		err = vx_inb(chip, RXH) << 16;
+		err |= vx_inb(chip, RXM) << 8;
+		err |= vx_inb(chip, RXL);
+		snd_printd(KERN_DEBUG "transfer_end: error = 0x%x\n", err);
+		return -(VX_ERR_MASK | err);
+	}
+	return 0;
+}
+
+/*
+ * vx_read_status - return the status rmh
+ * @rmh: rmh record to store the status
+ *
+ * returns 0 if successful, or a negative error code.
+ * the error code can be VX-specific, retrieved via vx_get_error().
+ * NB: call with spinlock held!
+ */
+static int vx_read_status(vx_core_t *chip, struct vx_rmh *rmh)
+{
+	int i, err, val, size;
+
+	/* no read necessary? */
+	if (rmh->DspStat == RMH_SSIZE_FIXED && rmh->LgStat == 0)
+		return 0;
+
+	/* Wait for RX full (with timeout protection)
+	 * The first word of status is in RX
+	 */
+	err = vx_wait_for_rx_full(chip);
+	if (err < 0)
+		return err;
+
+	/* Read RX */
+	val = vx_inb(chip, RXH) << 16;
+	val |= vx_inb(chip, RXM) << 8;
+	val |= vx_inb(chip, RXL);
+
+	/* If status given by DSP, let's decode its size */
+	switch (rmh->DspStat) {
+	case RMH_SSIZE_ARG:
+		size = val & 0xff;
+		rmh->Stat[0] = val & 0xffff00;
+		rmh->LgStat = size + 1;
+		break;
+	case RMH_SSIZE_MASK:
+		/* Let's count the arg numbers from a mask */
+		rmh->Stat[0] = val;
+		size = 0;
+		while (val) {
+			if (val & 0x01)
+				size++;
+			val >>= 1;
+		}
+		rmh->LgStat = size + 1;
+		break;
+	default:
+		/* else retrieve the status length given by the driver */
+		size = rmh->LgStat;
+		rmh->Stat[0] = val;  /* Val is the status 1st word */
+		size--;              /* hence adjust remaining length */
+		break;
+        }
+
+	if (size < 1)
+		return 0;
+	snd_assert(size <= SIZE_MAX_STATUS, return -EINVAL);
+
+	for (i = 1; i <= size; i++) {
+		/* trigger an irq MESS_WRITE_NEXT */
+		err = vx_send_irq_dsp(chip, IRQ_MESS_WRITE_NEXT);
+		if (err < 0)
+			return err;
+		/* Wait for RX full (with timeout protection) */
+		err = vx_wait_for_rx_full(chip);
+		if (err < 0)
+			return err;
+		rmh->Stat[i] = vx_inb(chip, RXH) << 16;
+		rmh->Stat[i] |= vx_inb(chip, RXM) <<  8;
+		rmh->Stat[i] |= vx_inb(chip, RXL);
+	}
+
+	return vx_transfer_end(chip, IRQ_MESS_WRITE_END);
+}
+
+
+#define MASK_MORE_THAN_1_WORD_COMMAND   0x00008000
+#define MASK_1_WORD_COMMAND             0x00ff7fff
+
+/*
+ * vx_send_msg_nolock - send a DSP message and read back the status
+ * @rmh: the rmh record to send and receive
+ *
+ * returns 0 if successful, or a negative error code.
+ * the error code can be VX-specific, retrieved via vx_get_error().
+ * 
+ * this function doesn't call spinlock at all.
+ */
+int vx_send_msg_nolock(vx_core_t *chip, struct vx_rmh *rmh)
+{
+	int i, err;
+	
+	if (chip->chip_status & VX_STAT_IS_STALE)
+		return -EBUSY;
+
+	if ((err = vx_reset_chk(chip)) < 0) {
+		snd_printd(KERN_DEBUG "vx_send_msg: vx_reset_chk error\n");
+		return err;
+	}
+
+#if 0
+	printk(KERN_DEBUG "rmh: cmd = 0x%06x, length = %d, stype = %d\n",
+	       rmh->Cmd[0], rmh->LgCmd, rmh->DspStat);
+	if (rmh->LgCmd > 1) {
+		printk(KERN_DEBUG "  ");
+		for (i = 1; i < rmh->LgCmd; i++)
+			printk("0x%06x ", rmh->Cmd[i]);
+		printk("\n");
+	}
+#endif
+	/* Check bit M is set according to length of the command */
+	if (rmh->LgCmd > 1)
+		rmh->Cmd[0] |= MASK_MORE_THAN_1_WORD_COMMAND;
+	else
+		rmh->Cmd[0] &= MASK_1_WORD_COMMAND;
+
+	/* Wait for TX empty */
+	if ((err = vx_wait_isr_bit(chip, ISR_TX_EMPTY)) < 0) {
+		snd_printd(KERN_DEBUG "vx_send_msg: wait tx empty error\n");
+		return err;
+	}
+
+	/* Write Cmd[0] */
+	vx_outb(chip, TXH, (rmh->Cmd[0] >> 16) & 0xff);
+	vx_outb(chip, TXM, (rmh->Cmd[0] >> 8) & 0xff);
+	vx_outb(chip, TXL, rmh->Cmd[0] & 0xff);
+
+	/* Trigger irq MESSAGE */
+	if ((err = vx_send_irq_dsp(chip, IRQ_MESSAGE)) < 0) {
+		snd_printd(KERN_DEBUG "vx_send_msg: send IRQ_MESSAGE error\n");
+		return err;
+	}
+
+	/* Wait for CHK = 1 */
+	if ((err = vx_wait_isr_bit(chip, ISR_CHK)) < 0)
+		return err;
+
+	/* If error, get error value from RX */
+	if (vx_inb(chip, ISR) & ISR_ERR) {
+		if ((err = vx_wait_for_rx_full(chip)) < 0) {
+			snd_printd(KERN_DEBUG "vx_send_msg: rx_full read error\n");
+			return err;
+		}
+		err = vx_inb(chip, RXH) << 16;
+		err |= vx_inb(chip, RXM) << 8;
+		err |= vx_inb(chip, RXL);
+		snd_printd(KERN_DEBUG "msg got error = 0x%x at cmd[0]\n", err);
+		err = -(VX_ERR_MASK | err);
+		return err;
+	}
+
+	/* Send the other words */
+	if (rmh->LgCmd > 1) {
+		for (i = 1; i < rmh->LgCmd; i++) {
+			/* Wait for TX ready */
+			if ((err = vx_wait_isr_bit(chip, ISR_TX_READY)) < 0) {
+				snd_printd(KERN_DEBUG "vx_send_msg: tx_ready error\n");
+				return err;
+			}
+
+			/* Write Cmd[i] */
+			vx_outb(chip, TXH, (rmh->Cmd[i] >> 16) & 0xff);
+			vx_outb(chip, TXM, (rmh->Cmd[i] >> 8) & 0xff);
+			vx_outb(chip, TXL, rmh->Cmd[i] & 0xff);
+
+			/* Trigger irq MESS_READ_NEXT */
+			if ((err = vx_send_irq_dsp(chip, IRQ_MESS_READ_NEXT)) < 0) {
+				snd_printd(KERN_DEBUG "vx_send_msg: IRQ_READ_NEXT error\n");
+				return err;
+			}
+		}
+		/* Wait for TX empty */
+		if ((err = vx_wait_isr_bit(chip, ISR_TX_READY)) < 0) {
+			snd_printd(KERN_DEBUG "vx_send_msg: TX_READY error\n");
+			return err;
+		}
+		/* End of transfer */
+		err = vx_transfer_end(chip, IRQ_MESS_READ_END);
+		if (err < 0)
+			return err;
+	}
+
+	return vx_read_status(chip, rmh);
+}
+
+
+/*
+ * vx_send_msg - send a DSP message with spinlock
+ * @rmh: the rmh record to send and receive
+ *
+ * returns 0 if successful, or a negative error code.
+ * see vx_send_msg_nolock().
+ */
+int vx_send_msg(vx_core_t *chip, struct vx_rmh *rmh)
+{
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	err = vx_send_msg_nolock(chip, rmh);
+	spin_unlock_irqrestore(&chip->lock, flags);
+	return err;
+}
+
+
+/*
+ * vx_send_rih_nolock - send an RIH to xilinx
+ * @cmd: the command to send
+ *
+ * returns 0 if successful, or a negative error code.
+ * the error code can be VX-specific, retrieved via vx_get_error().
+ *
+ * this function doesn't call spinlock at all.
+ *
+ * unlike RMH, no command is sent to DSP.
+ */
+int vx_send_rih_nolock(vx_core_t *chip, int cmd)
+{
+	int err;
+
+	if (chip->chip_status & VX_STAT_IS_STALE)
+		return -EBUSY;
+
+#if 0
+	printk(KERN_DEBUG "send_rih: cmd = 0x%x\n", cmd);
+#endif
+	if ((err = vx_reset_chk(chip)) < 0)
+		return err;
+	/* send the IRQ */
+	if ((err = vx_send_irq_dsp(chip, cmd)) < 0)
+		return err;
+	/* Wait CHK = 1 */
+	if ((err = vx_wait_isr_bit(chip, ISR_CHK)) < 0)
+		return err;
+	/* If error, read RX */
+	if (vx_inb(chip, ISR) & ISR_ERR) {
+		if ((err = vx_wait_for_rx_full(chip)) < 0)
+			return err;
+		err = vx_inb(chip, RXH) << 16;
+		err |= vx_inb(chip, RXM) << 8;
+		err |= vx_inb(chip, RXL);
+		return -(VX_ERR_MASK | err);
+	}
+	return 0;
+}
+
+
+/*
+ * vx_send_rih - send an RIH with spinlock
+ * @cmd: the command to send
+ *
+ * see vx_send_rih_nolock().
+ */
+int vx_send_rih(vx_core_t *chip, int cmd)
+{
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	err = vx_send_rih_nolock(chip, cmd);
+	spin_unlock_irqrestore(&chip->lock, flags);
+	return err;
+}
+
+#define END_OF_RESET_WAIT_TIME		500	/* us */
+
+/**
+ * snd_vx_boot_xilinx - boot up the xilinx interface
+ * @boot: the boot record to load
+ */
+int snd_vx_load_boot_image(vx_core_t *chip, const struct firmware *boot)
+{
+	unsigned int i;
+	int no_fillup = vx_has_new_dsp(chip);
+
+	/* check the length of boot image */
+	snd_assert(boot->size > 0, return -EINVAL);
+	snd_assert(boot->size % 3 == 0, return -EINVAL);
+#if 0
+	{
+		/* more strict check */
+		unsigned int c = ((u32)boot->data[0] << 16) | ((u32)boot->data[1] << 8) | boot->data[2];
+		snd_assert(boot->size == (c + 2) * 3, return -EINVAL);
+	}
+#endif
+
+	/* reset dsp */
+	vx_reset_dsp(chip);
+	
+	udelay(END_OF_RESET_WAIT_TIME); /* another wait? */
+
+	/* download boot strap */
+	for (i = 0; i < 0x600; i += 3) {
+		if (i >= boot->size) {
+			if (no_fillup)
+				break;
+			if (vx_wait_isr_bit(chip, ISR_TX_EMPTY) < 0) {
+				snd_printk(KERN_ERR "dsp boot failed at %d\n", i);
+				return -EIO;
+			}
+			vx_outb(chip, TXH, 0);
+			vx_outb(chip, TXM, 0);
+			vx_outb(chip, TXL, 0);
+		} else {
+			unsigned char *image = boot->data + i;
+			if (vx_wait_isr_bit(chip, ISR_TX_EMPTY) < 0) {
+				snd_printk(KERN_ERR "dsp boot failed at %d\n", i);
+				return -EIO;
+			}
+			vx_outb(chip, TXH, image[0]);
+			vx_outb(chip, TXM, image[1]);
+			vx_outb(chip, TXL, image[2]);
+		}
+	}
+	return 0;
+}
+
+/*
+ * vx_test_irq_src - query the source of interrupts
+ *
+ * called from irq handler only
+ */
+static int vx_test_irq_src(vx_core_t *chip, unsigned int *ret)
+{
+	int err;
+
+	vx_init_rmh(&chip->irq_rmh, CMD_TEST_IT);
+	spin_lock(&chip->lock);
+	err = vx_send_msg_nolock(chip, &chip->irq_rmh);
+	if (err < 0)
+		*ret = 0;
+	else
+		*ret = chip->irq_rmh.Stat[0];
+	spin_unlock(&chip->lock);
+	return err;
+}
+
+
+/*
+ * vx_interrupt - soft irq handler
+ */
+static void vx_interrupt(unsigned long private_data)
+{
+	vx_core_t *chip = (vx_core_t *) private_data;
+	unsigned int events;
+		
+	if (chip->chip_status & VX_STAT_IS_STALE)
+		return;
+
+	if (vx_test_irq_src(chip, &events) < 0)
+		return;
+    
+#if 0
+	if (events & 0x000800)
+		printk(KERN_ERR "DSP Stream underrun ! IRQ events = 0x%x\n", events);
+#endif
+	// printk(KERN_DEBUG "IRQ events = 0x%x\n", events);
+
+	/* We must prevent any application using this DSP
+	 * and block any further request until the application
+	 * either unregisters or reloads the DSP
+	 */
+	if (events & FATAL_DSP_ERROR) {
+		snd_printk(KERN_ERR "vx_core: fatal DSP error!!\n");
+		return;
+	}
+
+	/* The start on time code conditions are filled (ie the time code
+	 * received by the board is equal to one of those given to it).
+	 */
+	if (events & TIME_CODE_EVENT_PENDING)
+		; /* so far, nothing to do yet */
+
+	/* The frequency has changed on the board (UER mode). */
+	if (events & FREQUENCY_CHANGE_EVENT_PENDING)
+		vx_change_frequency(chip);
+
+	/* update the pcm streams */
+	vx_pcm_update_intr(chip, events);
+}
+
+
+/**
+ * snd_vx_irq_handler - interrupt handler
+ */
+irqreturn_t snd_vx_irq_handler(int irq, void *dev, struct pt_regs *regs)
+{
+	vx_core_t *chip = dev;
+
+	if (! (chip->chip_status & VX_STAT_CHIP_INIT) ||
+	    (chip->chip_status & VX_STAT_IS_STALE))
+		return IRQ_NONE;
+	if (! vx_test_and_ack(chip))
+		tasklet_hi_schedule(&chip->tq);
+	return IRQ_HANDLED;
+}
+
+
+/*
+ */
+static void vx_reset_board(vx_core_t *chip, int cold_reset)
+{
+	snd_assert(chip->ops->reset_board, return);
+
+	/* current source, later sync'ed with target */
+	chip->audio_source = VX_AUDIO_SRC_LINE;
+	if (cold_reset) {
+		chip->audio_source_target = chip->audio_source;
+		chip->clock_source = INTERNAL_QUARTZ;
+		chip->clock_mode = VX_CLOCK_MODE_AUTO;
+		chip->freq = 48000;
+		chip->uer_detected = VX_UER_MODE_NOT_PRESENT;
+		chip->uer_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
+	}
+
+	chip->ops->reset_board(chip, cold_reset);
+
+	vx_reset_codec(chip, cold_reset);
+
+	vx_set_internal_clock(chip, chip->freq);
+
+	/* Reset the DSP */
+	vx_reset_dsp(chip);
+
+	if (vx_is_pcmcia(chip)) {
+		/* Acknowledge any pending IRQ and reset the MEMIRQ flag. */
+		vx_test_and_ack(chip);
+		vx_validate_irq(chip, 1);
+	}
+
+	/* init CBits */
+	vx_set_iec958_status(chip, chip->uer_bits);
+}
+
+
+/*
+ * proc interface
+ */
+
+static void vx_proc_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+{
+	vx_core_t *chip = entry->private_data;
+	static char *audio_src_vxp[] = { "Line", "Mic", "Digital" };
+	static char *audio_src_vx2[] = { "Analog", "Analog", "Digital" };
+	static char *clock_mode[] = { "Auto", "Internal", "External" };
+	static char *clock_src[] = { "Internal", "External" };
+	static char *uer_type[] = { "Consumer", "Professional", "Not Present" };
+	
+	snd_iprintf(buffer, "%s\n", chip->card->longname);
+	snd_iprintf(buffer, "Xilinx Firmware: %s\n",
+		    chip->chip_status & VX_STAT_XILINX_LOADED ? "Loaded" : "No");
+	snd_iprintf(buffer, "Device Initialized: %s\n",
+		    chip->chip_status & VX_STAT_DEVICE_INIT ? "Yes" : "No");
+	snd_iprintf(buffer, "DSP audio info:");
+	if (chip->audio_info & VX_AUDIO_INFO_REAL_TIME)
+		snd_iprintf(buffer, " realtime");
+	if (chip->audio_info & VX_AUDIO_INFO_OFFLINE)
+		snd_iprintf(buffer, " offline");
+	if (chip->audio_info & VX_AUDIO_INFO_MPEG1)
+		snd_iprintf(buffer, " mpeg1");
+	if (chip->audio_info & VX_AUDIO_INFO_MPEG2)
+		snd_iprintf(buffer, " mpeg2");
+	if (chip->audio_info & VX_AUDIO_INFO_LINEAR_8)
+		snd_iprintf(buffer, " linear8");
+	if (chip->audio_info & VX_AUDIO_INFO_LINEAR_16)
+		snd_iprintf(buffer, " linear16");
+	if (chip->audio_info & VX_AUDIO_INFO_LINEAR_24)
+		snd_iprintf(buffer, " linear24");
+	snd_iprintf(buffer, "\n");
+	snd_iprintf(buffer, "Input Source: %s\n", vx_is_pcmcia(chip) ?
+		    audio_src_vxp[chip->audio_source] :
+		    audio_src_vx2[chip->audio_source]);
+	snd_iprintf(buffer, "Clock Mode: %s\n", clock_mode[chip->clock_mode]);
+	snd_iprintf(buffer, "Clock Source: %s\n", clock_src[chip->clock_source]);
+	snd_iprintf(buffer, "Frequency: %d\n", chip->freq);
+	snd_iprintf(buffer, "Detected Frequency: %d\n", chip->freq_detected);
+	snd_iprintf(buffer, "Detected UER type: %s\n", uer_type[chip->uer_detected]);
+	snd_iprintf(buffer, "Min/Max/Cur IBL: %d/%d/%d (granularity=%d)\n",
+		    chip->ibl.min_size, chip->ibl.max_size, chip->ibl.size,
+		    chip->ibl.granularity);
+}
+
+static void vx_proc_init(vx_core_t *chip)
+{
+	snd_info_entry_t *entry;
+
+	if (! snd_card_proc_new(chip->card, "vx-status", &entry))
+		snd_info_set_text_ops(entry, chip, 1024, vx_proc_read);
+}
+
+
+/**
+ * snd_vx_dsp_boot - load the DSP boot
+ */
+int snd_vx_dsp_boot(vx_core_t *chip, const struct firmware *boot)
+{
+	int err;
+	int cold_reset = !(chip->chip_status & VX_STAT_DEVICE_INIT);
+
+	vx_reset_board(chip, cold_reset);
+	vx_validate_irq(chip, 0);
+
+	if ((err = snd_vx_load_boot_image(chip, boot)) < 0)
+		return err;
+	snd_vx_delay(chip, 10);
+
+	return 0;
+}
+
+/**
+ * snd_vx_dsp_load - load the DSP image
+ */
+int snd_vx_dsp_load(vx_core_t *chip, const struct firmware *dsp)
+{
+	unsigned int i;
+	int err;
+	unsigned int csum = 0;
+	unsigned char *image, *cptr;
+
+	snd_assert(dsp->size % 3 == 0, return -EINVAL);
+
+	vx_toggle_dac_mute(chip, 1);
+
+	/* Transfert data buffer from PC to DSP */
+	for (i = 0; i < dsp->size; i += 3) {
+		image = dsp->data + i;
+		/* Wait DSP ready for a new read */
+		if ((err = vx_wait_isr_bit(chip, ISR_TX_EMPTY)) < 0) {
+			printk("dsp loading error at position %d\n", i);
+			return err;
+		}
+		cptr = image;
+		csum ^= *cptr;
+		csum = (csum >> 24) | (csum << 8);
+		vx_outb(chip, TXH, *cptr++);
+		csum ^= *cptr;
+		csum = (csum >> 24) | (csum << 8);
+		vx_outb(chip, TXM, *cptr++);
+		csum ^= *cptr;
+		csum = (csum >> 24) | (csum << 8);
+		vx_outb(chip, TXL, *cptr++);
+	}
+	snd_printdd(KERN_DEBUG "checksum = 0x%08x\n", csum);
+
+	snd_vx_delay(chip, 200);
+
+	if ((err = vx_wait_isr_bit(chip, ISR_CHK)) < 0)
+		return err;
+
+	vx_toggle_dac_mute(chip, 0);
+
+	vx_test_and_ack(chip);
+	vx_validate_irq(chip, 1);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/*
+ * suspend
+ */
+static int snd_vx_suspend(snd_card_t *card, pm_message_t state)
+{
+	vx_core_t *chip = card->pm_private_data;
+	unsigned int i;
+
+	snd_assert(chip, return -EINVAL);
+
+	chip->chip_status |= VX_STAT_IN_SUSPEND;
+	for (i = 0; i < chip->hw->num_codecs; i++)
+		snd_pcm_suspend_all(chip->pcm[i]);
+
+	return 0;
+}
+
+/*
+ * resume
+ */
+static int snd_vx_resume(snd_card_t *card)
+{
+	vx_core_t *chip = card->pm_private_data;
+	int i, err;
+
+	snd_assert(chip, return -EINVAL);
+
+	chip->chip_status &= ~VX_STAT_CHIP_INIT;
+
+	for (i = 0; i < 4; i++) {
+		if (! chip->firmware[i])
+			continue;
+		err = chip->ops->load_dsp(chip, i, chip->firmware[i]);
+		if (err < 0) {
+			snd_printk(KERN_ERR "vx: firmware resume error at DSP %d\n", i);
+			return -EIO;
+		}
+	}
+
+	chip->chip_status |= VX_STAT_CHIP_INIT;
+	chip->chip_status &= ~VX_STAT_IN_SUSPEND;
+
+	return 0;
+}
+
+#endif
+
+/**
+ * snd_vx_create - constructor for vx_core_t
+ * @hw: hardware specific record
+ *
+ * this function allocates the instance and prepare for the hardware
+ * initialization.
+ *
+ * return the instance pointer if successful, NULL in error.
+ */
+vx_core_t *snd_vx_create(snd_card_t *card, struct snd_vx_hardware *hw,
+			 struct snd_vx_ops *ops,
+			 int extra_size)
+{
+	vx_core_t *chip;
+
+	snd_assert(card && hw && ops, return NULL);
+
+	chip = kcalloc(1, sizeof(*chip) + extra_size, GFP_KERNEL);
+	if (! chip) {
+		snd_printk(KERN_ERR "vx_core: no memory\n");
+		return NULL;
+	}
+	spin_lock_init(&chip->lock);
+	spin_lock_init(&chip->irq_lock);
+	chip->irq = -1;
+	chip->hw = hw;
+	chip->type = hw->type;
+	chip->ops = ops;
+	tasklet_init(&chip->tq, vx_interrupt, (unsigned long)chip);
+	init_MUTEX(&chip->mixer_mutex);
+
+	chip->card = card;
+	card->private_data = chip;
+	strcpy(card->driver, hw->name);
+	sprintf(card->shortname, "Digigram %s", hw->name);
+
+	snd_card_set_pm_callback(card, snd_vx_suspend, snd_vx_resume, chip);
+
+	vx_proc_init(chip);
+
+	return chip;
+}
+
+/*
+ * module entries
+ */
+static int __init alsa_vx_core_init(void)
+{
+	return 0;
+}
+
+static void __exit alsa_vx_core_exit(void)
+{
+}
+
+module_init(alsa_vx_core_init)
+module_exit(alsa_vx_core_exit)
+
+/*
+ * exports
+ */
+EXPORT_SYMBOL(snd_vx_check_reg_bit);
+EXPORT_SYMBOL(snd_vx_create);
+EXPORT_SYMBOL(snd_vx_setup_firmware);
+EXPORT_SYMBOL(snd_vx_free_firmware);
+EXPORT_SYMBOL(snd_vx_irq_handler);
+EXPORT_SYMBOL(snd_vx_delay);
+EXPORT_SYMBOL(snd_vx_dsp_boot);
+EXPORT_SYMBOL(snd_vx_dsp_load);
+EXPORT_SYMBOL(snd_vx_load_boot_image);
