commit ae531486d77061fcc227455c8bcdcc278350b0c4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:26 2019 +0100

    ALSA: drivers: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-5-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 615e8b2b85f6..664b9efa9a50 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -843,7 +843,6 @@ static int vx_pcm_prepare(struct snd_pcm_substream *subs)
 static const struct snd_pcm_ops vx_pcm_playback_ops = {
 	.open =		vx_pcm_playback_open,
 	.close =	vx_pcm_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	vx_pcm_prepare,
 	.trigger =	vx_pcm_trigger,
 	.pointer =	vx_pcm_playback_pointer,
@@ -1061,7 +1060,6 @@ static snd_pcm_uframes_t vx_pcm_capture_pointer(struct snd_pcm_substream *subs)
 static const struct snd_pcm_ops vx_pcm_capture_ops = {
 	.open =		vx_pcm_capture_open,
 	.close =	vx_pcm_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	vx_pcm_prepare,
 	.trigger =	vx_pcm_trigger,
 	.pointer =	vx_pcm_capture_pointer,

commit 8f326303b0d89a6f7efaa56e4c02d6584c6d61df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:48:40 2019 +0100

    ALSA: vx: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The hw_params and hw_free callbacks became superfluous and got
    dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-9-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index f17e0a76c73c..615e8b2b85f6 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -772,23 +772,6 @@ static snd_pcm_uframes_t vx_pcm_playback_pointer(struct snd_pcm_substream *subs)
 	return pipe->position;
 }
 
-/*
- * vx_pcm_hw_params - hw_params callback for playback and capture
- */
-static int vx_pcm_hw_params(struct snd_pcm_substream *subs,
-				     struct snd_pcm_hw_params *hw_params)
-{
-	return snd_pcm_lib_malloc_pages(subs, params_buffer_bytes(hw_params));
-}
-
-/*
- * vx_pcm_hw_free - hw_free callback for playback and capture
- */
-static int vx_pcm_hw_free(struct snd_pcm_substream *subs)
-{
-	return snd_pcm_lib_free_pages(subs);
-}
-
 /*
  * vx_pcm_prepare - prepare callback for playback and capture
  */
@@ -861,8 +844,6 @@ static const struct snd_pcm_ops vx_pcm_playback_ops = {
 	.open =		vx_pcm_playback_open,
 	.close =	vx_pcm_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	vx_pcm_hw_params,
-	.hw_free =	vx_pcm_hw_free,
 	.prepare =	vx_pcm_prepare,
 	.trigger =	vx_pcm_trigger,
 	.pointer =	vx_pcm_playback_pointer,
@@ -1081,8 +1062,6 @@ static const struct snd_pcm_ops vx_pcm_capture_ops = {
 	.open =		vx_pcm_capture_open,
 	.close =	vx_pcm_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	vx_pcm_hw_params,
-	.hw_free =	vx_pcm_hw_free,
 	.prepare =	vx_pcm_prepare,
 	.trigger =	vx_pcm_trigger,
 	.pointer =	vx_pcm_capture_pointer,
@@ -1230,9 +1209,9 @@ int snd_vx_pcm_new(struct vx_core *chip)
 			snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &vx_pcm_playback_ops);
 		if (ins)
 			snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &vx_pcm_capture_ops);
-		snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_VMALLOC,
-						      snd_dma_continuous_data(GFP_KERNEL | GFP_DMA32),
-						      0, 0);
+		snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC,
+					       snd_dma_continuous_data(GFP_KERNEL | GFP_DMA32),
+					       0, 0);
 
 		pcm->private_data = chip;
 		pcm->private_free = snd_vx_pcm_free;

commit 748a76b215a36e9bb88a5bd8b56c5088371b2f19
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:47 2019 +0100

    ALSA: vx: Convert to the common vmalloc memalloc
    
    The recent change (*) in the ALSA memalloc core allows us to drop the
    special vmalloc-specific allocation and page handling.  This patch
    coverts to the common code.
    (*) 1fe7f397cfe2: ALSA: memalloc: Add vmalloc buffer allocation
                      support
        7e8edae39fd1: ALSA: pcm: Handle special page mapping in the
                      default mmap handler
    
    Since the driver requires the DMA32 allocation, it passes the
    specially encoded device to snd_pcm_lib_preallocate_pages().
    
    Link: https://lore.kernel.org/r/20191105151856.10785-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 4705c50fbf4f..f17e0a76c73c 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -778,8 +778,7 @@ static snd_pcm_uframes_t vx_pcm_playback_pointer(struct snd_pcm_substream *subs)
 static int vx_pcm_hw_params(struct snd_pcm_substream *subs,
 				     struct snd_pcm_hw_params *hw_params)
 {
-	return snd_pcm_lib_alloc_vmalloc_32_buffer
-					(subs, params_buffer_bytes(hw_params));
+	return snd_pcm_lib_malloc_pages(subs, params_buffer_bytes(hw_params));
 }
 
 /*
@@ -787,7 +786,7 @@ static int vx_pcm_hw_params(struct snd_pcm_substream *subs,
  */
 static int vx_pcm_hw_free(struct snd_pcm_substream *subs)
 {
-	return snd_pcm_lib_free_vmalloc_buffer(subs);
+	return snd_pcm_lib_free_pages(subs);
 }
 
 /*
@@ -867,7 +866,6 @@ static const struct snd_pcm_ops vx_pcm_playback_ops = {
 	.prepare =	vx_pcm_prepare,
 	.trigger =	vx_pcm_trigger,
 	.pointer =	vx_pcm_playback_pointer,
-	.page =		snd_pcm_lib_get_vmalloc_page,
 };
 
 
@@ -1088,7 +1086,6 @@ static const struct snd_pcm_ops vx_pcm_capture_ops = {
 	.prepare =	vx_pcm_prepare,
 	.trigger =	vx_pcm_trigger,
 	.pointer =	vx_pcm_capture_pointer,
-	.page =		snd_pcm_lib_get_vmalloc_page,
 };
 
 
@@ -1233,6 +1230,9 @@ int snd_vx_pcm_new(struct vx_core *chip)
 			snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &vx_pcm_playback_ops);
 		if (ins)
 			snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &vx_pcm_capture_ops);
+		snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_VMALLOC,
+						      snd_dma_continuous_data(GFP_KERNEL | GFP_DMA32),
+						      0, 0);
 
 		pcm->private_data = chip;
 		pcm->private_free = snd_vx_pcm_free;

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index ba80f459bdc5..4705c50fbf4f 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Driver for Digigram VX soundcards
  *
@@ -5,21 +6,6 @@
  *
  * Copyright (c) 2002,2003 by Takashi Iwai <tiwai@suse.de>
  *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- *
  * STRATEGY
  *  for playback, we send series of "chunks", which size is equal with the
  *  IBL size, typically 126 samples.  at each end of chunk, the end-of-buffer
@@ -39,7 +25,6 @@
  *  the current point of read buffer is kept in pipe->hw_ptr.  note that
  *  this is in bytes.
  *
- *
  * TODO
  *  - linked trigger for full-duplex mode.
  *  - scheduled action on the stream.

commit fa84cf094ef9667e2b91c104b0a788fd1896f482
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 18 07:40:53 2018 +0200

    ALSA: pcm: Nuke snd_pcm_lib_mmap_vmalloc()
    
    snd_pcm_lib_mmap_vmalloc() was supposed to be implemented with
    somewhat special for vmalloc handling, but in the end, this turned to
    just the default handler, i.e. NULL.  As the situation has never
    changed over decades, let's rip it off.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 380a028469c4..ba80f459bdc5 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -883,7 +883,6 @@ static const struct snd_pcm_ops vx_pcm_playback_ops = {
 	.trigger =	vx_pcm_trigger,
 	.pointer =	vx_pcm_playback_pointer,
 	.page =		snd_pcm_lib_get_vmalloc_page,
-	.mmap =		snd_pcm_lib_mmap_vmalloc,
 };
 
 
@@ -1105,7 +1104,6 @@ static const struct snd_pcm_ops vx_pcm_capture_ops = {
 	.trigger =	vx_pcm_trigger,
 	.pointer =	vx_pcm_capture_pointer,
 	.page =		snd_pcm_lib_get_vmalloc_page,
-	.mmap =		snd_pcm_lib_mmap_vmalloc,
 };
 
 

commit b6c0b7156167b8a0f82576adaaa9d7287296bbfc
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Thu Aug 17 14:45:51 2017 +0530

    ALSA: drivers: make snd_pcm_hardware const
    
    Make these const as they are only used in a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index d318a33b6cfb..380a028469c4 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -500,7 +500,7 @@ static int vx_stop_stream(struct vx_core *chip, struct vx_pipe *pipe)
  * playback hw information
  */
 
-static struct snd_pcm_hardware vx_pcm_playback_hw = {
+static const struct snd_pcm_hardware vx_pcm_playback_hw = {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID /*|*/
 				 /*SNDRV_PCM_INFO_RESUME*/),
@@ -891,7 +891,7 @@ static const struct snd_pcm_ops vx_pcm_playback_ops = {
  * playback hw information
  */
 
-static struct snd_pcm_hardware vx_pcm_capture_hw = {
+static const struct snd_pcm_hardware vx_pcm_capture_hw = {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID /*|*/
 				 /*SNDRV_PCM_INFO_RESUME*/),

commit bf8334845598a172b42ee487b05eb4394c86bce8
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Jun 9 12:35:43 2017 +0530

    ALSA: vx: vx_pcm: constify vx_pcm_playback_ops and vx_pcm_capture_ops.
    
    File size before:
       text    data     bss     dec     hex filename
       7126     240       0    7366    1cc6 sound/drivers/vx/vx_pcm.o
    
    File size After adding 'const':
       text    data     bss     dec     hex filename
       7382       0       0    7382    1cd6 sound/drivers/vx/vx_pcm.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index ea7b377f0378..d318a33b6cfb 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -873,7 +873,7 @@ static int vx_pcm_prepare(struct snd_pcm_substream *subs)
 /*
  * operators for PCM playback
  */
-static struct snd_pcm_ops vx_pcm_playback_ops = {
+static const struct snd_pcm_ops vx_pcm_playback_ops = {
 	.open =		vx_pcm_playback_open,
 	.close =	vx_pcm_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1095,7 +1095,7 @@ static snd_pcm_uframes_t vx_pcm_capture_pointer(struct snd_pcm_substream *subs)
 /*
  * operators for PCM capture
  */
-static struct snd_pcm_ops vx_pcm_capture_ops = {
+static const struct snd_pcm_ops vx_pcm_capture_ops = {
 	.open =		vx_pcm_capture_open,
 	.close =	vx_pcm_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,

commit ed3c177d960bb5881b945ca6f784868126bb90db
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 4 12:34:14 2017 +0100

    ALSA: vx: Don't try to update capture stream before running
    
    The update of stream costs significantly, and we should avoid it
    unless the stream really has started.  Check pipe->running flag
    instead of pipe->prepared.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 41a617886cc7..ea7b377f0378 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -1015,7 +1015,7 @@ static void vx_pcm_capture_update(struct vx_core *chip, struct snd_pcm_substream
 	int size, space, count;
 	struct snd_pcm_runtime *runtime = subs->runtime;
 
-	if (! pipe->prepared || (chip->chip_status & VX_STAT_IS_STALE))
+	if (!pipe->running || (chip->chip_status & VX_STAT_IS_STALE))
 		return;
 
 	size = runtime->buffer_size - snd_pcm_capture_avail(runtime);

commit 874e1f6fad9a5184b67f4cee37c1335cd2cc5677
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 4 12:19:15 2017 +0100

    ALSA: vx: Fix possible transfer overflow
    
    The pseudo DMA transfer codes in VX222 and VX-pocket driver have a
    slight bug where they check the buffer boundary wrongly, and may
    overflow.  Also, the zero sample count might be handled badly for the
    playback (although it shouldn't happen in theory).  This patch
    addresses these issues.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=141541
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 11467272089e..41a617886cc7 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -1048,8 +1048,10 @@ static void vx_pcm_capture_update(struct vx_core *chip, struct snd_pcm_substream
 		/* ok, let's accelerate! */
 		int align = pipe->align * 3;
 		space = (count / align) * align;
-		vx_pseudo_dma_read(chip, runtime, pipe, space);
-		count -= space;
+		if (space > 0) {
+			vx_pseudo_dma_read(chip, runtime, pipe, space);
+			count -= space;
+		}
 	}
 	/* read the rest of bytes */
 	while (count > 0) {

commit db0a5214b8d6cc7a90ce3336d24a85b90cbb4e67
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 9 17:17:20 2014 +0200

    ALSA: vx: Use nonatomic PCM ops
    
    Rewrite VXpocket and VX222 drivers to use the new PCM nonatomic ops.
    The former irq tasklet is replaced with a threaded irq handler, and
    the tasklet for the PCM delayed start is simply merged into the normal
    PCM trigger, as well as the replacement of spinlock with mutex.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index deed5efff33c..11467272089e 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -229,7 +229,7 @@ static int vx_get_pipe_state(struct vx_core *chip, struct vx_pipe *pipe, int *st
 
 	vx_init_rmh(&rmh, CMD_PIPE_STATE);
 	vx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);
-	err = vx_send_msg_nolock(chip, &rmh); /* no lock needed for trigger */ 
+	err = vx_send_msg(chip, &rmh);
 	if (! err)
 		*state = (rmh.Stat[0] & (1 << pipe->number)) ? 1 : 0;
 	return err;
@@ -280,7 +280,7 @@ static int vx_pipe_can_start(struct vx_core *chip, struct vx_pipe *pipe)
 	vx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);
 	rmh.Cmd[0] |= 1;
 
-	err = vx_send_msg_nolock(chip, &rmh); /* no lock needed for trigger */ 
+	err = vx_send_msg(chip, &rmh);
 	if (! err) {
 		if (rmh.Stat[0])
 			err = 1;
@@ -300,7 +300,7 @@ static int vx_conf_pipe(struct vx_core *chip, struct vx_pipe *pipe)
 	if (pipe->is_capture)
 		rmh.Cmd[0] |= COMMAND_RECORD_MASK;
 	rmh.Cmd[1] = 1 << pipe->number;
-	return vx_send_msg_nolock(chip, &rmh); /* no lock needed for trigger */
+	return vx_send_msg(chip, &rmh);
 }
 
 /*
@@ -311,7 +311,7 @@ static int vx_send_irqa(struct vx_core *chip)
 	struct vx_rmh rmh;
 
 	vx_init_rmh(&rmh, CMD_SEND_IRQA);
-	return vx_send_msg_nolock(chip, &rmh); /* no lock needed for trigger */ 
+	return vx_send_msg(chip, &rmh);
 }
 
 
@@ -389,7 +389,7 @@ static int vx_stop_pipe(struct vx_core *chip, struct vx_pipe *pipe)
 	struct vx_rmh rmh;
 	vx_init_rmh(&rmh, CMD_STOP_PIPE);
 	vx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);
-	return vx_send_msg_nolock(chip, &rmh); /* no lock needed for trigger */ 
+	return vx_send_msg(chip, &rmh);
 }
 
 
@@ -477,7 +477,7 @@ static int vx_start_stream(struct vx_core *chip, struct vx_pipe *pipe)
 	vx_init_rmh(&rmh, CMD_START_ONE_STREAM);
 	vx_set_stream_cmd_params(&rmh, pipe->is_capture, pipe->number);
 	vx_set_differed_time(chip, &rmh, pipe);
-	return vx_send_msg_nolock(chip, &rmh); /* no lock needed for trigger */ 
+	return vx_send_msg(chip, &rmh);
 }
 
 
@@ -492,7 +492,7 @@ static int vx_stop_stream(struct vx_core *chip, struct vx_pipe *pipe)
 
 	vx_init_rmh(&rmh, CMD_STOP_STREAM);
 	vx_set_stream_cmd_params(&rmh, pipe->is_capture, pipe->number);
-	return vx_send_msg_nolock(chip, &rmh); /* no lock needed for trigger */ 
+	return vx_send_msg(chip, &rmh);
 }
 
 
@@ -520,8 +520,6 @@ static struct snd_pcm_hardware vx_pcm_playback_hw = {
 };
 
 
-static void vx_pcm_delayed_start(unsigned long arg);
-
 /*
  * vx_pcm_playback_open - open callback for playback
  */
@@ -553,7 +551,6 @@ static int vx_pcm_playback_open(struct snd_pcm_substream *subs)
 	pipe->references++;
 
 	pipe->substream = subs;
-	tasklet_init(&pipe->start_tq, vx_pcm_delayed_start, (unsigned long)subs);
 	chip->playback_pipes[audio] = pipe;
 
 	runtime->hw = vx_pcm_playback_hw;
@@ -646,12 +643,12 @@ static int vx_pcm_playback_transfer_chunk(struct vx_core *chip,
 	/* we don't need irqsave here, because this function
 	 * is called from either trigger callback or irq handler
 	 */
-	spin_lock(&chip->lock); 
+	mutex_lock(&chip->lock);
 	vx_pseudo_dma_write(chip, runtime, pipe, size);
 	err = vx_notify_end_of_buffer(chip, pipe);
 	/* disconnect the host, SIZE_HBUF command always switches to the stream mode */
 	vx_send_rih_nolock(chip, IRQ_CONNECT_STREAM_NEXT);
-	spin_unlock(&chip->lock);
+	mutex_unlock(&chip->lock);
 	return err;
 }
 
@@ -727,31 +724,6 @@ static void vx_pcm_playback_update(struct vx_core *chip,
 	}
 }
 
-/*
- * start the stream and pipe.
- * this function is called from tasklet, which is invoked by the trigger
- * START callback.
- */
-static void vx_pcm_delayed_start(unsigned long arg)
-{
-	struct snd_pcm_substream *subs = (struct snd_pcm_substream *)arg;
-	struct vx_core *chip = subs->pcm->private_data;
-	struct vx_pipe *pipe = subs->runtime->private_data;
-	int err;
-
-	/*  printk( KERN_DEBUG "DDDD tasklet delayed start jiffies = %ld\n", jiffies);*/
-
-	if ((err = vx_start_stream(chip, pipe)) < 0) {
-		snd_printk(KERN_ERR "vx: cannot start stream\n");
-		return;
-	}
-	if ((err = vx_toggle_pipe(chip, pipe, 1)) < 0) {
-		snd_printk(KERN_ERR "vx: cannot start pipe\n");
-		return;
-	}
-	/*   printk( KERN_DEBUG "dddd tasklet delayed start jiffies = %ld \n", jiffies);*/
-}
-
 /*
  * vx_pcm_playback_trigger - trigger callback for playback
  */
@@ -769,11 +741,17 @@ static int vx_pcm_trigger(struct snd_pcm_substream *subs, int cmd)
 	case SNDRV_PCM_TRIGGER_RESUME:
 		if (! pipe->is_capture)
 			vx_pcm_playback_transfer(chip, subs, pipe, 2);
-		/* FIXME:
-		 * we trigger the pipe using tasklet, so that the interrupts are
-		 * issued surely after the trigger is completed.
-		 */ 
-		tasklet_schedule(&pipe->start_tq);
+		err = vx_start_stream(chip, pipe);
+		if (err < 0) {
+			pr_debug("vx: cannot start stream\n");
+			return err;
+		}
+		err = vx_toggle_pipe(chip, pipe, 1);
+		if (err < 0) {
+			pr_debug("vx: cannot start pipe\n");
+			vx_stop_stream(chip, pipe);
+			return err;
+		}
 		chip->pcm_running++;
 		pipe->running = 1;
 		break;
@@ -955,7 +933,6 @@ static int vx_pcm_capture_open(struct snd_pcm_substream *subs)
 	if (err < 0)
 		return err;
 	pipe->substream = subs;
-	tasklet_init(&pipe->start_tq, vx_pcm_delayed_start, (unsigned long)subs);
 	chip->capture_pipes[audio] = pipe;
 
 	/* check if monitoring is needed */
@@ -1082,7 +1059,7 @@ static void vx_pcm_capture_update(struct vx_core *chip, struct snd_pcm_substream
 		count -= 3;
 	}
 	/* disconnect the host, SIZE_HBUF command always switches to the stream mode */
-	vx_send_rih_nolock(chip, IRQ_CONNECT_STREAM_NEXT);
+	vx_send_rih(chip, IRQ_CONNECT_STREAM_NEXT);
 	/* read the last pending 6 bytes */
 	count = DMA_READ_ALIGN;
 	while (count > 0) {
@@ -1099,7 +1076,7 @@ static void vx_pcm_capture_update(struct vx_core *chip, struct snd_pcm_substream
 
  _error:
 	/* disconnect the host, SIZE_HBUF command always switches to the stream mode */
-	vx_send_rih_nolock(chip, IRQ_CONNECT_STREAM_NEXT);
+	vx_send_rih(chip, IRQ_CONNECT_STREAM_NEXT);
 	return;
 }
 
@@ -1275,6 +1252,7 @@ int snd_vx_pcm_new(struct vx_core *chip)
 		pcm->private_data = chip;
 		pcm->private_free = snd_vx_pcm_free;
 		pcm->info_flags = 0;
+		pcm->nonatomic = true;
 		strcpy(pcm->name, chip->card->shortname);
 		chip->pcm[i] = pcm;
 	}

commit 395d9dd5dd13c6aa3c8c61a31126af98cd1e747d
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Fri Sep 28 11:24:57 2012 +0200

    sound: Remove unnecessary semicolon
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r1@
    statement S;
    position p,p1;
    @@
    S@p1;@p
    
    @script:python r2@
    p << r1.p;
    p1 << r1.p1;
    @@
    if p[0].line != p1[0].line_end:
            cocci.include_match(False)
    @@
    position r1.p;
    @@
    -;@p
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 5e897b236cec..deed5efff33c 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -184,7 +184,7 @@ static int vx_set_format(struct vx_core *chip, struct vx_pipe *pipe,
 	default : 
 		snd_BUG();
 		return -EINVAL;
-        };
+	}
 
 	return vx_set_stream_format(chip, pipe, header);
 }

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 35a2f71a6af5..5e897b236cec 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -1189,7 +1189,7 @@ void vx_pcm_update_intr(struct vx_core *chip, unsigned int events)
 
 
 /*
- * vx_init_audio_io - check the availabe audio i/o and allocate pipe arrays
+ * vx_init_audio_io - check the available audio i/o and allocate pipe arrays
  */
 static int vx_init_audio_io(struct vx_core *chip)
 {

commit c32d977b8157bf67cdf47729ce7dd054a26eb534
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 18 14:58:57 2010 +0100

    ALSA: pcm - Call pgprot_noncached() for vmalloc'ed buffers
    
    pgprot_noncached() can be set for vmalloc'ed buffers safely, and we'd
    need non-cached behavior more or less, even for the intermediate ring-
    buffers.
    
    Now snd_pcm_lib_mmap_vmalloc() is added as the common PCM mmap callback
    that is coupled with snd_pcm_lib_alloc_vmalloc_buffer() & co.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index c8385d26a16f..35a2f71a6af5 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -905,6 +905,7 @@ static struct snd_pcm_ops vx_pcm_playback_ops = {
 	.trigger =	vx_pcm_trigger,
 	.pointer =	vx_pcm_playback_pointer,
 	.page =		snd_pcm_lib_get_vmalloc_page,
+	.mmap =		snd_pcm_lib_mmap_vmalloc,
 };
 
 
@@ -1125,6 +1126,7 @@ static struct snd_pcm_ops vx_pcm_capture_ops = {
 	.trigger =	vx_pcm_trigger,
 	.pointer =	vx_pcm_capture_pointer,
 	.page =		snd_pcm_lib_get_vmalloc_page,
+	.mmap =		snd_pcm_lib_mmap_vmalloc,
 };
 
 

commit 149feef54bf543448dd4ec5820ef8ae178021c3a
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Dec 18 09:30:55 2009 +0100

    sound: vx: use vmalloc buffer helper functions
    
    Remove this duplicate of snd_pcm_alloc_vmalloc_buffer and use the
    equivalent core functions instead.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 6644d0034fba..c8385d26a16f 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -46,7 +46,6 @@
  */
 
 #include <linux/slab.h>
-#include <linux/vmalloc.h>
 #include <linux/delay.h>
 #include <sound/core.h>
 #include <sound/asoundef.h>
@@ -55,55 +54,6 @@
 #include "vx_cmd.h"
 
 
-/*
- * we use a vmalloc'ed (sg-)buffer
- */
-
-/* get the physical page pointer on the given offset */
-static struct page *snd_pcm_get_vmalloc_page(struct snd_pcm_substream *subs,
-					     unsigned long offset)
-{
-	void *pageptr = subs->runtime->dma_area + offset;
-	return vmalloc_to_page(pageptr);
-}
-
-/*
- * allocate a buffer via vmalloc_32().
- * called from hw_params
- * NOTE: this may be called not only once per pcm open!
- */
-static int snd_pcm_alloc_vmalloc_buffer(struct snd_pcm_substream *subs, size_t size)
-{
-	struct snd_pcm_runtime *runtime = subs->runtime;
-	if (runtime->dma_area) {
-		/* already allocated */
-		if (runtime->dma_bytes >= size)
-			return 0; /* already enough large */
-		vfree(runtime->dma_area);
-	}
-	runtime->dma_area = vmalloc_32(size);
-	if (! runtime->dma_area)
-		return -ENOMEM;
-	memset(runtime->dma_area, 0, size);
-	runtime->dma_bytes = size;
-	return 1; /* changed */
-}
-
-/*
- * free the buffer.
- * called from hw_free callback
- * NOTE: this may be called not only once per pcm open!
- */
-static int snd_pcm_free_vmalloc_buffer(struct snd_pcm_substream *subs)
-{
-	struct snd_pcm_runtime *runtime = subs->runtime;
-
-	vfree(runtime->dma_area);
-	runtime->dma_area = NULL;
-	return 0;
-}
-
-
 /*
  * read three pending pcm bytes via inb()
  */
@@ -865,7 +815,8 @@ static snd_pcm_uframes_t vx_pcm_playback_pointer(struct snd_pcm_substream *subs)
 static int vx_pcm_hw_params(struct snd_pcm_substream *subs,
 				     struct snd_pcm_hw_params *hw_params)
 {
-	return snd_pcm_alloc_vmalloc_buffer(subs, params_buffer_bytes(hw_params));
+	return snd_pcm_lib_alloc_vmalloc_32_buffer
+					(subs, params_buffer_bytes(hw_params));
 }
 
 /*
@@ -873,7 +824,7 @@ static int vx_pcm_hw_params(struct snd_pcm_substream *subs,
  */
 static int vx_pcm_hw_free(struct snd_pcm_substream *subs)
 {
-	return snd_pcm_free_vmalloc_buffer(subs);
+	return snd_pcm_lib_free_vmalloc_buffer(subs);
 }
 
 /*
@@ -953,7 +904,7 @@ static struct snd_pcm_ops vx_pcm_playback_ops = {
 	.prepare =	vx_pcm_prepare,
 	.trigger =	vx_pcm_trigger,
 	.pointer =	vx_pcm_playback_pointer,
-	.page =		snd_pcm_get_vmalloc_page,
+	.page =		snd_pcm_lib_get_vmalloc_page,
 };
 
 
@@ -1173,7 +1124,7 @@ static struct snd_pcm_ops vx_pcm_capture_ops = {
 	.prepare =	vx_pcm_prepare,
 	.trigger =	vx_pcm_trigger,
 	.pointer =	vx_pcm_capture_pointer,
-	.page =		snd_pcm_get_vmalloc_page,
+	.page =		snd_pcm_lib_get_vmalloc_page,
 };
 
 

commit 1f04128a3db7c0f0e8b5d25323eba70ac342f47f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 18 12:17:55 2008 +0100

    ALSA: hda - Convert from takslet_hi_schedule() to tasklet_schedule()
    
    Replace all tasklet_hi_schedule() callers with the normal
    tasklet_schedule().  The former often causes troubles with
    RT-kernels, and has actually no merit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 27de574c08f7..6644d0034fba 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -823,7 +823,7 @@ static int vx_pcm_trigger(struct snd_pcm_substream *subs, int cmd)
 		 * we trigger the pipe using tasklet, so that the interrupts are
 		 * issued surely after the trigger is completed.
 		 */ 
-		tasklet_hi_schedule(&pipe->start_tq);
+		tasklet_schedule(&pipe->start_tq);
 		chip->pcm_running++;
 		pipe->running = 1;
 		break;

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index fdbf86571b1f..27de574c08f7 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -587,7 +587,8 @@ static int vx_pcm_playback_open(struct snd_pcm_substream *subs)
 		return -EBUSY;
 
 	audio = subs->pcm->device * 2;
-	snd_assert(audio < chip->audio_outs, return -EINVAL);
+	if (snd_BUG_ON(audio >= chip->audio_outs))
+		return -EINVAL;
 	
 	/* playback pipe may have been already allocated for monitoring */
 	pipe = chip->playback_pipes[audio];
@@ -996,7 +997,8 @@ static int vx_pcm_capture_open(struct snd_pcm_substream *subs)
 		return -EBUSY;
 
 	audio = subs->pcm->device * 2;
-	snd_assert(audio < chip->audio_ins, return -EINVAL);
+	if (snd_BUG_ON(audio >= chip->audio_ins))
+		return -EINVAL;
 	err = vx_alloc_pipe(chip, 1, audio, 2, &pipe);
 	if (err < 0)
 		return err;
@@ -1214,7 +1216,8 @@ void vx_pcm_update_intr(struct vx_core *chip, unsigned int events)
 			}
 			if (capture)
 				continue;
-			snd_assert(p >= 0 && (unsigned int)p < chip->audio_outs,);
+			if (snd_BUG_ON(p < 0 || p >= chip->audio_outs))
+				continue;
 			pipe = chip->playback_pipes[p];
 			if (pipe && pipe->substream) {
 				vx_pcm_playback_update(chip, pipe->substream, pipe);

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 7e65a103fbb2..fdbf86571b1f 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -45,7 +45,6 @@
  *  - scheduled action on the stream.
  */
 
-#include <sound/driver.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/delay.h>

commit 59feddb25f9d925e86ee22596802405788bc050f
Author: Panagiotis Issaris <takis@issaris.org>
Date:   Tue Jul 25 15:28:03 2006 +0200

    [ALSA] Conversions from kmalloc+memset to k(z|c)alloc
    
    sound: Conversions from kmalloc+memset to k(c|z)alloc.
    
    Signed-off-by: Panagiotis Issaris <takis@issaris.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index c4af84995d05..7e65a103fbb2 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -1252,18 +1252,15 @@ static int vx_init_audio_io(struct vx_core *chip)
 	chip->audio_info = rmh.Stat[1];
 
 	/* allocate pipes */
-	chip->playback_pipes = kmalloc(sizeof(struct vx_pipe *) * chip->audio_outs, GFP_KERNEL);
+	chip->playback_pipes = kcalloc(chip->audio_outs, sizeof(struct vx_pipe *), GFP_KERNEL);
 	if (!chip->playback_pipes)
 		return -ENOMEM;
-	chip->capture_pipes = kmalloc(sizeof(struct vx_pipe *) * chip->audio_ins, GFP_KERNEL);
+	chip->capture_pipes = kcalloc(chip->audio_ins, sizeof(struct vx_pipe *), GFP_KERNEL);
 	if (!chip->capture_pipes) {
 		kfree(chip->playback_pipes);
 		return -ENOMEM;
 	}
 
-	memset(chip->playback_pipes, 0, sizeof(struct vx_pipe *) * chip->audio_outs);
-	memset(chip->capture_pipes, 0, sizeof(struct vx_pipe *) * chip->audio_ins);
-
 	preferred = chip->ibl.size;
 	chip->ibl.size = 0;
 	vx_set_ibl(chip, &chip->ibl); /* query the info */

commit ac57b84984859f3e1d567c031556d3de872c1a91
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Mar 6 13:21:30 2006 +0100

    [ALSA] vx - Fix memory leak on error path
    
    Modules: Digigram VX core
    
    Noticed by Eric Sesterhenn on kernel-janitors@
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 2195e25087b4..c4af84995d05 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -1253,9 +1253,13 @@ static int vx_init_audio_io(struct vx_core *chip)
 
 	/* allocate pipes */
 	chip->playback_pipes = kmalloc(sizeof(struct vx_pipe *) * chip->audio_outs, GFP_KERNEL);
+	if (!chip->playback_pipes)
+		return -ENOMEM;
 	chip->capture_pipes = kmalloc(sizeof(struct vx_pipe *) * chip->audio_ins, GFP_KERNEL);
-	if (! chip->playback_pipes || ! chip->capture_pipes)
+	if (!chip->capture_pipes) {
+		kfree(chip->playback_pipes);
 		return -ENOMEM;
+	}
 
 	memset(chip->playback_pipes, 0, sizeof(struct vx_pipe *) * chip->audio_outs);
 	memset(chip->capture_pipes, 0, sizeof(struct vx_pipe *) * chip->audio_ins);

commit 9c4be3d334808d1dedea7db0ae84759bfac8e18e
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Thu Feb 9 20:04:16 2006 +0100

    [ALSA] no need to check pointers passed to vfree() for NULL
    
    Modules: Digigram VX core,USB generic driver
    
    There's no need to check pointers passed to vfree() for NULL.
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 464109e421d4..2195e25087b4 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -98,10 +98,9 @@ static int snd_pcm_alloc_vmalloc_buffer(struct snd_pcm_substream *subs, size_t s
 static int snd_pcm_free_vmalloc_buffer(struct snd_pcm_substream *subs)
 {
 	struct snd_pcm_runtime *runtime = subs->runtime;
-	if (runtime->dma_area) {
-		vfree(runtime->dma_area);
-		runtime->dma_area = NULL;
-	}
+
+	vfree(runtime->dma_area);
+	runtime->dma_area = NULL;
 	return 0;
 }
 

commit af26367f69a474ed809e4a59abb5855b47daaff4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:46:59 2005 +0100

    [ALSA] Remove xxx_t typedefs: VXdriver
    
    Remove xxx_t typedefs from the VXdriver codes
    (vx_core support, vx222 and vxpocket).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 2b46758fe86f..464109e421d4 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -61,7 +61,8 @@
  */
 
 /* get the physical page pointer on the given offset */
-static struct page *snd_pcm_get_vmalloc_page(snd_pcm_substream_t *subs, unsigned long offset)
+static struct page *snd_pcm_get_vmalloc_page(struct snd_pcm_substream *subs,
+					     unsigned long offset)
 {
 	void *pageptr = subs->runtime->dma_area + offset;
 	return vmalloc_to_page(pageptr);
@@ -72,9 +73,9 @@ static struct page *snd_pcm_get_vmalloc_page(snd_pcm_substream_t *subs, unsigned
  * called from hw_params
  * NOTE: this may be called not only once per pcm open!
  */
-static int snd_pcm_alloc_vmalloc_buffer(snd_pcm_substream_t *subs, size_t size)
+static int snd_pcm_alloc_vmalloc_buffer(struct snd_pcm_substream *subs, size_t size)
 {
-	snd_pcm_runtime_t *runtime = subs->runtime;
+	struct snd_pcm_runtime *runtime = subs->runtime;
 	if (runtime->dma_area) {
 		/* already allocated */
 		if (runtime->dma_bytes >= size)
@@ -94,9 +95,9 @@ static int snd_pcm_alloc_vmalloc_buffer(snd_pcm_substream_t *subs, size_t size)
  * called from hw_free callback
  * NOTE: this may be called not only once per pcm open!
  */
-static int snd_pcm_free_vmalloc_buffer(snd_pcm_substream_t *subs)
+static int snd_pcm_free_vmalloc_buffer(struct snd_pcm_substream *subs)
 {
-	snd_pcm_runtime_t *runtime = subs->runtime;
+	struct snd_pcm_runtime *runtime = subs->runtime;
 	if (runtime->dma_area) {
 		vfree(runtime->dma_area);
 		runtime->dma_area = NULL;
@@ -108,7 +109,8 @@ static int snd_pcm_free_vmalloc_buffer(snd_pcm_substream_t *subs)
 /*
  * read three pending pcm bytes via inb()
  */
-static void vx_pcm_read_per_bytes(vx_core_t *chip, snd_pcm_runtime_t *runtime, vx_pipe_t *pipe)
+static void vx_pcm_read_per_bytes(struct vx_core *chip, struct snd_pcm_runtime *runtime,
+				  struct vx_pipe *pipe)
 {
 	int offset = pipe->hw_ptr;
 	unsigned char *buf = (unsigned char *)(runtime->dma_area + offset);
@@ -135,7 +137,8 @@ static void vx_pcm_read_per_bytes(vx_core_t *chip, snd_pcm_runtime_t *runtime, v
  * @pc_time: the pointer for the PC-time to set
  * @dsp_time: the pointer for RMH status time array
  */
-static void vx_set_pcx_time(vx_core_t *chip, pcx_time_t *pc_time, unsigned int *dsp_time)
+static void vx_set_pcx_time(struct vx_core *chip, pcx_time_t *pc_time,
+			    unsigned int *dsp_time)
 {
 	dsp_time[0] = (unsigned int)((*pc_time) >> 24) & PCX_TIME_HI_MASK;
 	dsp_time[1] = (unsigned int)(*pc_time) &  MASK_DSP_WORD;
@@ -151,7 +154,8 @@ static void vx_set_pcx_time(vx_core_t *chip, pcx_time_t *pc_time, unsigned int *
  *
  * returns the increase of the command length.
  */
-static int vx_set_differed_time(vx_core_t *chip, struct vx_rmh *rmh, vx_pipe_t *pipe)
+static int vx_set_differed_time(struct vx_core *chip, struct vx_rmh *rmh,
+				struct vx_pipe *pipe)
 {
 	/* Update The length added to the RMH command by the timestamp */
 	if (! (pipe->differed_type & DC_DIFFERED_DELAY))
@@ -184,7 +188,8 @@ static int vx_set_differed_time(vx_core_t *chip, struct vx_rmh *rmh, vx_pipe_t *
  * @pipe: the affected pipe
  * @data: format bitmask
  */
-static int vx_set_stream_format(vx_core_t *chip, vx_pipe_t *pipe, unsigned int data)
+static int vx_set_stream_format(struct vx_core *chip, struct vx_pipe *pipe,
+				unsigned int data)
 {
 	struct vx_rmh rmh;
 
@@ -210,8 +215,8 @@ static int vx_set_stream_format(vx_core_t *chip, vx_pipe_t *pipe, unsigned int d
  *
  * returns 0 if successful, or a negative error code.
  */
-static int vx_set_format(vx_core_t *chip, vx_pipe_t *pipe,
-			 snd_pcm_runtime_t *runtime)
+static int vx_set_format(struct vx_core *chip, struct vx_pipe *pipe,
+			 struct snd_pcm_runtime *runtime)
 {
 	unsigned int header = HEADER_FMT_BASE;
 
@@ -239,7 +244,7 @@ static int vx_set_format(vx_core_t *chip, vx_pipe_t *pipe,
 /*
  * set / query the IBL size
  */
-static int vx_set_ibl(vx_core_t *chip, struct vx_ibl_info *info)
+static int vx_set_ibl(struct vx_core *chip, struct vx_ibl_info *info)
 {
 	int err;
 	struct vx_rmh rmh;
@@ -269,7 +274,7 @@ static int vx_set_ibl(vx_core_t *chip, struct vx_ibl_info *info)
  *
  * called from trigger callback only
  */
-static int vx_get_pipe_state(vx_core_t *chip, vx_pipe_t *pipe, int *state)
+static int vx_get_pipe_state(struct vx_core *chip, struct vx_pipe *pipe, int *state)
 {
 	int err;
 	struct vx_rmh rmh;
@@ -294,7 +299,7 @@ static int vx_get_pipe_state(vx_core_t *chip, vx_pipe_t *pipe, int *state)
  *       you'll need to disconnect the host to get back to the
  *       normal mode.
  */
-static int vx_query_hbuffer_size(vx_core_t *chip, vx_pipe_t *pipe)
+static int vx_query_hbuffer_size(struct vx_core *chip, struct vx_pipe *pipe)
 {
 	int result;
 	struct vx_rmh rmh;
@@ -318,7 +323,7 @@ static int vx_query_hbuffer_size(vx_core_t *chip, vx_pipe_t *pipe)
  *
  * called from trigger callback only
  */
-static int vx_pipe_can_start(vx_core_t *chip, vx_pipe_t *pipe)
+static int vx_pipe_can_start(struct vx_core *chip, struct vx_pipe *pipe)
 {
 	int err;
 	struct vx_rmh rmh;
@@ -339,7 +344,7 @@ static int vx_pipe_can_start(vx_core_t *chip, vx_pipe_t *pipe)
  * vx_conf_pipe - tell the pipe to stand by and wait for IRQA.
  * @pipe: the pipe to be configured
  */
-static int vx_conf_pipe(vx_core_t *chip, vx_pipe_t *pipe)
+static int vx_conf_pipe(struct vx_core *chip, struct vx_pipe *pipe)
 {
 	struct vx_rmh rmh;
 
@@ -353,7 +358,7 @@ static int vx_conf_pipe(vx_core_t *chip, vx_pipe_t *pipe)
 /*
  * vx_send_irqa - trigger IRQA
  */
-static int vx_send_irqa(vx_core_t *chip)
+static int vx_send_irqa(struct vx_core *chip)
 {
 	struct vx_rmh rmh;
 
@@ -378,7 +383,7 @@ static int vx_send_irqa(vx_core_t *chip)
  * called from trigger callback only
  *
  */
-static int vx_toggle_pipe(vx_core_t *chip, vx_pipe_t *pipe, int state)
+static int vx_toggle_pipe(struct vx_core *chip, struct vx_pipe *pipe, int state)
 {
 	int err, i, cur_state;
 
@@ -431,7 +436,7 @@ static int vx_toggle_pipe(vx_core_t *chip, vx_pipe_t *pipe, int state)
  *
  * called from trigger callback only
  */
-static int vx_stop_pipe(vx_core_t *chip, vx_pipe_t *pipe)
+static int vx_stop_pipe(struct vx_core *chip, struct vx_pipe *pipe)
 {
 	struct vx_rmh rmh;
 	vx_init_rmh(&rmh, CMD_STOP_PIPE);
@@ -449,12 +454,12 @@ static int vx_stop_pipe(vx_core_t *chip, vx_pipe_t *pipe)
  *
  * return 0 on success, or a negative error code.
  */
-static int vx_alloc_pipe(vx_core_t *chip, int capture,
+static int vx_alloc_pipe(struct vx_core *chip, int capture,
 			 int audioid, int num_audio,
-			 vx_pipe_t **pipep)
+			 struct vx_pipe **pipep)
 {
 	int err;
-	vx_pipe_t *pipe;
+	struct vx_pipe *pipe;
 	struct vx_rmh rmh;
 	int data_mode;
 
@@ -499,7 +504,7 @@ static int vx_alloc_pipe(vx_core_t *chip, int capture,
  * vx_free_pipe - release a pipe
  * @pipe: pipe to be released
  */
-static int vx_free_pipe(vx_core_t *chip, vx_pipe_t *pipe)
+static int vx_free_pipe(struct vx_core *chip, struct vx_pipe *pipe)
 {
 	struct vx_rmh rmh;
 
@@ -517,7 +522,7 @@ static int vx_free_pipe(vx_core_t *chip, vx_pipe_t *pipe)
  *
  * called from trigger callback only
  */
-static int vx_start_stream(vx_core_t *chip, vx_pipe_t *pipe)
+static int vx_start_stream(struct vx_core *chip, struct vx_pipe *pipe)
 {
 	struct vx_rmh rmh;
 
@@ -533,7 +538,7 @@ static int vx_start_stream(vx_core_t *chip, vx_pipe_t *pipe)
  *
  * called from trigger callback only
  */
-static int vx_stop_stream(vx_core_t *chip, vx_pipe_t *pipe)
+static int vx_stop_stream(struct vx_core *chip, struct vx_pipe *pipe)
 {
 	struct vx_rmh rmh;
 
@@ -547,11 +552,12 @@ static int vx_stop_stream(vx_core_t *chip, vx_pipe_t *pipe)
  * playback hw information
  */
 
-static snd_pcm_hardware_t vx_pcm_playback_hw = {
+static struct snd_pcm_hardware vx_pcm_playback_hw = {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID /*|*/
 				 /*SNDRV_PCM_INFO_RESUME*/),
-	.formats =		/*SNDRV_PCM_FMTBIT_U8 |*/ SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE,
+	.formats =		(/*SNDRV_PCM_FMTBIT_U8 |*/
+				 SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE),
 	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
 	.rate_min =		5000,
 	.rate_max =		48000,
@@ -571,11 +577,11 @@ static void vx_pcm_delayed_start(unsigned long arg);
 /*
  * vx_pcm_playback_open - open callback for playback
  */
-static int vx_pcm_playback_open(snd_pcm_substream_t *subs)
+static int vx_pcm_playback_open(struct snd_pcm_substream *subs)
 {
-	snd_pcm_runtime_t *runtime = subs->runtime;
-	vx_core_t *chip = snd_pcm_substream_chip(subs);
-	vx_pipe_t *pipe = NULL;
+	struct snd_pcm_runtime *runtime = subs->runtime;
+	struct vx_core *chip = snd_pcm_substream_chip(subs);
+	struct vx_pipe *pipe = NULL;
 	unsigned int audio;
 	int err;
 
@@ -615,10 +621,10 @@ static int vx_pcm_playback_open(snd_pcm_substream_t *subs)
 /*
  * vx_pcm_playback_close - close callback for playback
  */
-static int vx_pcm_playback_close(snd_pcm_substream_t *subs)
+static int vx_pcm_playback_close(struct snd_pcm_substream *subs)
 {
-	vx_core_t *chip = snd_pcm_substream_chip(subs);
-	vx_pipe_t *pipe;
+	struct vx_core *chip = snd_pcm_substream_chip(subs);
+	struct vx_pipe *pipe;
 
 	if (! subs->runtime->private_data)
 		return -EINVAL;
@@ -641,7 +647,7 @@ static int vx_pcm_playback_close(snd_pcm_substream_t *subs)
  *
  * NB: call with a certain lock.
  */
-static int vx_notify_end_of_buffer(vx_core_t *chip, vx_pipe_t *pipe)
+static int vx_notify_end_of_buffer(struct vx_core *chip, struct vx_pipe *pipe)
 {
 	int err;
 	struct vx_rmh rmh;  /* use a temporary rmh here */
@@ -669,7 +675,9 @@ static int vx_notify_end_of_buffer(vx_core_t *chip, vx_pipe_t *pipe)
  *
  * return 0 if ok.
  */
-static int vx_pcm_playback_transfer_chunk(vx_core_t *chip, snd_pcm_runtime_t *runtime, vx_pipe_t *pipe, int size)
+static int vx_pcm_playback_transfer_chunk(struct vx_core *chip,
+					  struct snd_pcm_runtime *runtime,
+					  struct vx_pipe *pipe, int size)
 {
 	int space, err = 0;
 
@@ -705,7 +713,9 @@ static int vx_pcm_playback_transfer_chunk(vx_core_t *chip, snd_pcm_runtime_t *ru
  * so that the caller can check the total transferred size later
  * (to call snd_pcm_period_elapsed).
  */
-static int vx_update_pipe_position(vx_core_t *chip, snd_pcm_runtime_t *runtime, vx_pipe_t *pipe)
+static int vx_update_pipe_position(struct vx_core *chip,
+				   struct snd_pcm_runtime *runtime,
+				   struct vx_pipe *pipe)
 {
 	struct vx_rmh rmh;
 	int err, update;
@@ -731,10 +741,12 @@ static int vx_update_pipe_position(vx_core_t *chip, snd_pcm_runtime_t *runtime,
  * transfer the pending playback buffer data to DSP
  * called from interrupt handler
  */
-static void vx_pcm_playback_transfer(vx_core_t *chip, snd_pcm_substream_t *subs, vx_pipe_t *pipe, int nchunks)
+static void vx_pcm_playback_transfer(struct vx_core *chip,
+				     struct snd_pcm_substream *subs,
+				     struct vx_pipe *pipe, int nchunks)
 {
 	int i, err;
-	snd_pcm_runtime_t *runtime = subs->runtime;
+	struct snd_pcm_runtime *runtime = subs->runtime;
 
 	if (! pipe->prepared || (chip->chip_status & VX_STAT_IS_STALE))
 		return;
@@ -749,10 +761,12 @@ static void vx_pcm_playback_transfer(vx_core_t *chip, snd_pcm_substream_t *subs,
  * update the playback position and call snd_pcm_period_elapsed() if necessary
  * called from interrupt handler
  */
-static void vx_pcm_playback_update(vx_core_t *chip, snd_pcm_substream_t *subs, vx_pipe_t *pipe)
+static void vx_pcm_playback_update(struct vx_core *chip,
+				   struct snd_pcm_substream *subs,
+				   struct vx_pipe *pipe)
 {
 	int err;
-	snd_pcm_runtime_t *runtime = subs->runtime;
+	struct snd_pcm_runtime *runtime = subs->runtime;
 
 	if (pipe->running && ! (chip->chip_status & VX_STAT_IS_STALE)) {
 		if ((err = vx_update_pipe_position(chip, runtime, pipe)) < 0)
@@ -771,9 +785,9 @@ static void vx_pcm_playback_update(vx_core_t *chip, snd_pcm_substream_t *subs, v
  */
 static void vx_pcm_delayed_start(unsigned long arg)
 {
-	snd_pcm_substream_t *subs = (snd_pcm_substream_t *)arg;
-	vx_core_t *chip = subs->pcm->private_data;
-	vx_pipe_t *pipe = subs->runtime->private_data;
+	struct snd_pcm_substream *subs = (struct snd_pcm_substream *)arg;
+	struct vx_core *chip = subs->pcm->private_data;
+	struct vx_pipe *pipe = subs->runtime->private_data;
 	int err;
 
 	/*  printk( KERN_DEBUG "DDDD tasklet delayed start jiffies = %ld\n", jiffies);*/
@@ -792,10 +806,10 @@ static void vx_pcm_delayed_start(unsigned long arg)
 /*
  * vx_pcm_playback_trigger - trigger callback for playback
  */
-static int vx_pcm_trigger(snd_pcm_substream_t *subs, int cmd)
+static int vx_pcm_trigger(struct snd_pcm_substream *subs, int cmd)
 {
-	vx_core_t *chip = snd_pcm_substream_chip(subs);
-	vx_pipe_t *pipe = subs->runtime->private_data;
+	struct vx_core *chip = snd_pcm_substream_chip(subs);
+	struct vx_pipe *pipe = subs->runtime->private_data;
 	int err;
 
 	if (chip->chip_status & VX_STAT_IS_STALE)
@@ -839,18 +853,18 @@ static int vx_pcm_trigger(snd_pcm_substream_t *subs, int cmd)
 /*
  * vx_pcm_playback_pointer - pointer callback for playback
  */
-static snd_pcm_uframes_t vx_pcm_playback_pointer(snd_pcm_substream_t *subs)
+static snd_pcm_uframes_t vx_pcm_playback_pointer(struct snd_pcm_substream *subs)
 {
-	snd_pcm_runtime_t *runtime = subs->runtime;
-	vx_pipe_t *pipe = runtime->private_data;
+	struct snd_pcm_runtime *runtime = subs->runtime;
+	struct vx_pipe *pipe = runtime->private_data;
 	return pipe->position;
 }
 
 /*
  * vx_pcm_hw_params - hw_params callback for playback and capture
  */
-static int vx_pcm_hw_params(snd_pcm_substream_t *subs,
-				     snd_pcm_hw_params_t *hw_params)
+static int vx_pcm_hw_params(struct snd_pcm_substream *subs,
+				     struct snd_pcm_hw_params *hw_params)
 {
 	return snd_pcm_alloc_vmalloc_buffer(subs, params_buffer_bytes(hw_params));
 }
@@ -858,7 +872,7 @@ static int vx_pcm_hw_params(snd_pcm_substream_t *subs,
 /*
  * vx_pcm_hw_free - hw_free callback for playback and capture
  */
-static int vx_pcm_hw_free(snd_pcm_substream_t *subs)
+static int vx_pcm_hw_free(struct snd_pcm_substream *subs)
 {
 	return snd_pcm_free_vmalloc_buffer(subs);
 }
@@ -866,11 +880,11 @@ static int vx_pcm_hw_free(snd_pcm_substream_t *subs)
 /*
  * vx_pcm_prepare - prepare callback for playback and capture
  */
-static int vx_pcm_prepare(snd_pcm_substream_t *subs)
+static int vx_pcm_prepare(struct snd_pcm_substream *subs)
 {
-	vx_core_t *chip = snd_pcm_substream_chip(subs);
-	snd_pcm_runtime_t *runtime = subs->runtime;
-	vx_pipe_t *pipe = runtime->private_data;
+	struct vx_core *chip = snd_pcm_substream_chip(subs);
+	struct snd_pcm_runtime *runtime = subs->runtime;
+	struct vx_pipe *pipe = runtime->private_data;
 	int err, data_mode;
 	// int max_size, nchunks;
 
@@ -897,7 +911,8 @@ static int vx_pcm_prepare(snd_pcm_substream_t *subs)
 	}
 
 	if (chip->pcm_running && chip->freq != runtime->rate) {
-		snd_printk(KERN_ERR "vx: cannot set different clock %d from the current %d\n", runtime->rate, chip->freq);
+		snd_printk(KERN_ERR "vx: cannot set different clock %d "
+			   "from the current %d\n", runtime->rate, chip->freq);
 		return -EINVAL;
 	}
 	vx_set_clock(chip, runtime->rate);
@@ -930,7 +945,7 @@ static int vx_pcm_prepare(snd_pcm_substream_t *subs)
 /*
  * operators for PCM playback
  */
-static snd_pcm_ops_t vx_pcm_playback_ops = {
+static struct snd_pcm_ops vx_pcm_playback_ops = {
 	.open =		vx_pcm_playback_open,
 	.close =	vx_pcm_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -947,11 +962,12 @@ static snd_pcm_ops_t vx_pcm_playback_ops = {
  * playback hw information
  */
 
-static snd_pcm_hardware_t vx_pcm_capture_hw = {
+static struct snd_pcm_hardware vx_pcm_capture_hw = {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID /*|*/
 				 /*SNDRV_PCM_INFO_RESUME*/),
-	.formats =		/*SNDRV_PCM_FMTBIT_U8 |*/ SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE,
+	.formats =		(/*SNDRV_PCM_FMTBIT_U8 |*/
+				 SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE),
 	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
 	.rate_min =		5000,
 	.rate_max =		48000,
@@ -969,12 +985,12 @@ static snd_pcm_hardware_t vx_pcm_capture_hw = {
 /*
  * vx_pcm_capture_open - open callback for capture
  */
-static int vx_pcm_capture_open(snd_pcm_substream_t *subs)
+static int vx_pcm_capture_open(struct snd_pcm_substream *subs)
 {
-	snd_pcm_runtime_t *runtime = subs->runtime;
-	vx_core_t *chip = snd_pcm_substream_chip(subs);
-	vx_pipe_t *pipe;
-	vx_pipe_t *pipe_out_monitoring = NULL;
+	struct snd_pcm_runtime *runtime = subs->runtime;
+	struct vx_core *chip = snd_pcm_substream_chip(subs);
+	struct vx_pipe *pipe;
+	struct vx_pipe *pipe_out_monitoring = NULL;
 	unsigned int audio;
 	int err;
 
@@ -1005,9 +1021,11 @@ static int vx_pcm_capture_open(snd_pcm_substream_t *subs)
 		   if an output pipe is available, it's audios still may need to be 
 		   unmuted. hence we'll have to call a mixer entry point.
 		*/
-		vx_set_monitor_level(chip, audio, chip->audio_monitor[audio], chip->audio_monitor_active[audio]);
+		vx_set_monitor_level(chip, audio, chip->audio_monitor[audio],
+				     chip->audio_monitor_active[audio]);
 		/* assuming stereo */
-		vx_set_monitor_level(chip, audio+1, chip->audio_monitor[audio+1], chip->audio_monitor_active[audio+1]); 
+		vx_set_monitor_level(chip, audio+1, chip->audio_monitor[audio+1],
+				     chip->audio_monitor_active[audio+1]); 
 	}
 
 	pipe->monitoring_pipe = pipe_out_monitoring; /* default value NULL */
@@ -1026,11 +1044,11 @@ static int vx_pcm_capture_open(snd_pcm_substream_t *subs)
 /*
  * vx_pcm_capture_close - close callback for capture
  */
-static int vx_pcm_capture_close(snd_pcm_substream_t *subs)
+static int vx_pcm_capture_close(struct snd_pcm_substream *subs)
 {
-	vx_core_t *chip = snd_pcm_substream_chip(subs);
-	vx_pipe_t *pipe;
-	vx_pipe_t *pipe_out_monitoring;
+	struct vx_core *chip = snd_pcm_substream_chip(subs);
+	struct vx_pipe *pipe;
+	struct vx_pipe *pipe_out_monitoring;
 	
 	if (! subs->runtime->private_data)
 		return -EINVAL;
@@ -1062,10 +1080,11 @@ static int vx_pcm_capture_close(snd_pcm_substream_t *subs)
 /*
  * vx_pcm_capture_update - update the capture buffer
  */
-static void vx_pcm_capture_update(vx_core_t *chip, snd_pcm_substream_t *subs, vx_pipe_t *pipe)
+static void vx_pcm_capture_update(struct vx_core *chip, struct snd_pcm_substream *subs,
+				  struct vx_pipe *pipe)
 {
 	int size, space, count;
-	snd_pcm_runtime_t *runtime = subs->runtime;
+	struct snd_pcm_runtime *runtime = subs->runtime;
 
 	if (! pipe->prepared || (chip->chip_status & VX_STAT_IS_STALE))
 		return;
@@ -1135,17 +1154,17 @@ static void vx_pcm_capture_update(vx_core_t *chip, snd_pcm_substream_t *subs, vx
 /*
  * vx_pcm_capture_pointer - pointer callback for capture
  */
-static snd_pcm_uframes_t vx_pcm_capture_pointer(snd_pcm_substream_t *subs)
+static snd_pcm_uframes_t vx_pcm_capture_pointer(struct snd_pcm_substream *subs)
 {
-	snd_pcm_runtime_t *runtime = subs->runtime;
-	vx_pipe_t *pipe = runtime->private_data;
+	struct snd_pcm_runtime *runtime = subs->runtime;
+	struct vx_pipe *pipe = runtime->private_data;
 	return bytes_to_frames(runtime, pipe->hw_ptr);
 }
 
 /*
  * operators for PCM capture
  */
-static snd_pcm_ops_t vx_pcm_capture_ops = {
+static struct snd_pcm_ops vx_pcm_capture_ops = {
 	.open =		vx_pcm_capture_open,
 	.close =	vx_pcm_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1161,10 +1180,10 @@ static snd_pcm_ops_t vx_pcm_capture_ops = {
 /*
  * interrupt handler for pcm streams
  */
-void vx_pcm_update_intr(vx_core_t *chip, unsigned int events)
+void vx_pcm_update_intr(struct vx_core *chip, unsigned int events)
 {
 	unsigned int i;
-	vx_pipe_t *pipe;
+	struct vx_pipe *pipe;
 
 #define EVENT_MASK	(END_OF_BUFFER_EVENTS_PENDING|ASYNC_EVENTS_PENDING)
 
@@ -1218,7 +1237,7 @@ void vx_pcm_update_intr(vx_core_t *chip, unsigned int events)
 /*
  * vx_init_audio_io - check the availabe audio i/o and allocate pipe arrays
  */
-static int vx_init_audio_io(vx_core_t *chip)
+static int vx_init_audio_io(struct vx_core *chip)
 {
 	struct vx_rmh rmh;
 	int preferred;
@@ -1234,19 +1253,20 @@ static int vx_init_audio_io(vx_core_t *chip)
 	chip->audio_info = rmh.Stat[1];
 
 	/* allocate pipes */
-	chip->playback_pipes = kmalloc(sizeof(vx_pipe_t *) * chip->audio_outs, GFP_KERNEL);
-	chip->capture_pipes = kmalloc(sizeof(vx_pipe_t *) * chip->audio_ins, GFP_KERNEL);
+	chip->playback_pipes = kmalloc(sizeof(struct vx_pipe *) * chip->audio_outs, GFP_KERNEL);
+	chip->capture_pipes = kmalloc(sizeof(struct vx_pipe *) * chip->audio_ins, GFP_KERNEL);
 	if (! chip->playback_pipes || ! chip->capture_pipes)
 		return -ENOMEM;
 
-	memset(chip->playback_pipes, 0, sizeof(vx_pipe_t *) * chip->audio_outs);
-	memset(chip->capture_pipes, 0, sizeof(vx_pipe_t *) * chip->audio_ins);
+	memset(chip->playback_pipes, 0, sizeof(struct vx_pipe *) * chip->audio_outs);
+	memset(chip->capture_pipes, 0, sizeof(struct vx_pipe *) * chip->audio_ins);
 
 	preferred = chip->ibl.size;
 	chip->ibl.size = 0;
 	vx_set_ibl(chip, &chip->ibl); /* query the info */
 	if (preferred > 0) {
-		chip->ibl.size = ((preferred + chip->ibl.granularity - 1) / chip->ibl.granularity) * chip->ibl.granularity;
+		chip->ibl.size = ((preferred + chip->ibl.granularity - 1) /
+				  chip->ibl.granularity) * chip->ibl.granularity;
 		if (chip->ibl.size > chip->ibl.max_size)
 			chip->ibl.size = chip->ibl.max_size;
 	} else
@@ -1260,9 +1280,9 @@ static int vx_init_audio_io(vx_core_t *chip)
 /*
  * free callback for pcm
  */
-static void snd_vx_pcm_free(snd_pcm_t *pcm)
+static void snd_vx_pcm_free(struct snd_pcm *pcm)
 {
-	vx_core_t *chip = pcm->private_data;
+	struct vx_core *chip = pcm->private_data;
 	chip->pcm[pcm->device] = NULL;
 	kfree(chip->playback_pipes);
 	chip->playback_pipes = NULL;
@@ -1273,9 +1293,9 @@ static void snd_vx_pcm_free(snd_pcm_t *pcm)
 /*
  * snd_vx_pcm_new - create and initialize a pcm
  */
-int snd_vx_pcm_new(vx_core_t *chip)
+int snd_vx_pcm_new(struct vx_core *chip)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	unsigned int i;
 	int err;
 

commit b1d5776d865951c213a1caaab5d8bf5de7615dbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:56:31 2005 +0200

    [ALSA] Remove vmalloc wrapper, kfree_nocheck()
    
    - Remove vmalloc wrapper
    - Add release_and_free_resource() to remove kfree_nocheck() from each driver
      and simplify the code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index c2312d912fc7..2b46758fe86f 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -79,7 +79,7 @@ static int snd_pcm_alloc_vmalloc_buffer(snd_pcm_substream_t *subs, size_t size)
 		/* already allocated */
 		if (runtime->dma_bytes >= size)
 			return 0; /* already enough large */
-		vfree_nocheck(runtime->dma_area); /* bypass the memory wrapper */
+		vfree(runtime->dma_area);
 	}
 	runtime->dma_area = vmalloc_32(size);
 	if (! runtime->dma_area)
@@ -98,7 +98,7 @@ static int snd_pcm_free_vmalloc_buffer(snd_pcm_substream_t *subs)
 {
 	snd_pcm_runtime_t *runtime = subs->runtime;
 	if (runtime->dma_area) {
-		vfree_nocheck(runtime->dma_area); /* bypass the memory wrapper */
+		vfree(runtime->dma_area);
 		runtime->dma_area = NULL;
 	}
 	return 0;

commit 561b220a4dece18d67177413e6fa21b49aa4acce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:22:34 2005 +0200

    [ALSA] Replace with kzalloc() - others
    
    Documentation,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,OPL3
    OPL4,Digigram VX core,I2C cs8427,I2C lib core,I2C tea6330t,L3 drivers
    AK4114 receiver,AK4117 receiver,PDAudioCF driver,PPC PMAC driver
    SPARC AMD7930 driver,SPARC cs4231 driver,Synth,Common EMU synth
    USB generic driver,USB USX2Y
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index d4becf44e247..c2312d912fc7 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -473,7 +473,7 @@ static int vx_alloc_pipe(vx_core_t *chip, int capture,
 		return err;
 
 	/* initialize the pipe record */
-	pipe = kcalloc(1, sizeof(*pipe), GFP_KERNEL);
+	pipe = kzalloc(sizeof(*pipe), GFP_KERNEL);
 	if (! pipe) {
 		/* release the pipe */
 		vx_init_rmh(&rmh, CMD_FREE_PIPE);

commit 41e4845c426024ec41724326397a36b3aa2cb6a3
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Thu Aug 18 13:43:12 2005 +0200

    [ALSA] PCM resume cleanups
    
    Digigram VX core,CS4231 driver,ATIIXP driver,VIA82xx driver
    VIA82xx-modem driver,au88x0 driver,CS46xx driver,Trident driver
    This patch disables SNDRV_PCM_INFO_RESUME flag for drivers which does not
    support the full resume.
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index af381b15fe5c..d4becf44e247 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -549,8 +549,8 @@ static int vx_stop_stream(vx_core_t *chip, vx_pipe_t *pipe)
 
 static snd_pcm_hardware_t vx_pcm_playback_hw = {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
-				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID |
-				 SNDRV_PCM_INFO_RESUME),
+				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID /*|*/
+				 /*SNDRV_PCM_INFO_RESUME*/),
 	.formats =		/*SNDRV_PCM_FMTBIT_U8 |*/ SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE,
 	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
 	.rate_min =		5000,
@@ -949,8 +949,8 @@ static snd_pcm_ops_t vx_pcm_playback_ops = {
 
 static snd_pcm_hardware_t vx_pcm_capture_hw = {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
-				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID |
-				 SNDRV_PCM_INFO_RESUME),
+				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID /*|*/
+				 /*SNDRV_PCM_INFO_RESUME*/),
 	.formats =		/*SNDRV_PCM_FMTBIT_U8 |*/ SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE,
 	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
 	.rate_min =		5000,

commit 4d572776d4dfa2d5385a2ec3acec3cc059149e13
Author: Jesper Juhl <juhl-lkml@dif.dk>
Date:   Mon May 30 17:30:32 2005 +0200

    [ALSA] Remove redundant NULL checks before kfree
    
    Timer Midlevel,ALSA sequencer,ALSA<-OSS sequencer,Digigram VX core
    I2C tea6330t,GUS Library,VIA82xx driver,VIA82xx-modem driver
    CA0106 driver,CS46xx driver,EMU10K1/EMU10K2 driver,YMFPCI driver
    Digigram VX Pocket driver,Common EMU synth,USB generic driver,USB USX2Y
    Checking a pointer for NULL before calling kfree() on it is redundant,
    kfree() deals with NULL pointers just fine.
    This patch removes such checks from sound/
    
    This patch also makes another, but closely related, change.
    It avoids casting pointers about to be kfree()'ed.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
index 98587176b327..af381b15fe5c 100644
--- a/sound/drivers/vx/vx_pcm.c
+++ b/sound/drivers/vx/vx_pcm.c
@@ -1264,14 +1264,10 @@ static void snd_vx_pcm_free(snd_pcm_t *pcm)
 {
 	vx_core_t *chip = pcm->private_data;
 	chip->pcm[pcm->device] = NULL;
-	if (chip->playback_pipes) {
-		kfree(chip->playback_pipes);
-		chip->playback_pipes = NULL;
-	}
-	if (chip->capture_pipes) {
-		kfree(chip->capture_pipes);
-		chip->capture_pipes = NULL;
-	}
+	kfree(chip->playback_pipes);
+	chip->playback_pipes = NULL;
+	kfree(chip->capture_pipes);
+	chip->capture_pipes = NULL;
 }
 
 /*

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/drivers/vx/vx_pcm.c b/sound/drivers/vx/vx_pcm.c
new file mode 100644
index 000000000000..98587176b327
--- /dev/null
+++ b/sound/drivers/vx/vx_pcm.c
@@ -0,0 +1,1312 @@
+/*
+ * Driver for Digigram VX soundcards
+ *
+ * PCM part
+ *
+ * Copyright (c) 2002,2003 by Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *
+ * STRATEGY
+ *  for playback, we send series of "chunks", which size is equal with the
+ *  IBL size, typically 126 samples.  at each end of chunk, the end-of-buffer
+ *  interrupt is notified, and the interrupt handler will feed the next chunk.
+ *
+ *  the current position is calculated from the sample count RMH.
+ *  pipe->transferred is the counter of data which has been already transferred.
+ *  if this counter reaches to the period size, snd_pcm_period_elapsed() will
+ *  be issued.
+ *
+ *  for capture, the situation is much easier.
+ *  to get a low latency response, we'll check the capture streams at each
+ *  interrupt (capture stream has no EOB notification).  if the pending
+ *  data is accumulated to the period size, snd_pcm_period_elapsed() is
+ *  called and the pointer is updated.
+ *
+ *  the current point of read buffer is kept in pipe->hw_ptr.  note that
+ *  this is in bytes.
+ *
+ *
+ * TODO
+ *  - linked trigger for full-duplex mode.
+ *  - scheduled action on the stream.
+ */
+
+#include <sound/driver.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/asoundef.h>
+#include <sound/pcm.h>
+#include <sound/vx_core.h>
+#include "vx_cmd.h"
+
+
+/*
+ * we use a vmalloc'ed (sg-)buffer
+ */
+
+/* get the physical page pointer on the given offset */
+static struct page *snd_pcm_get_vmalloc_page(snd_pcm_substream_t *subs, unsigned long offset)
+{
+	void *pageptr = subs->runtime->dma_area + offset;
+	return vmalloc_to_page(pageptr);
+}
+
+/*
+ * allocate a buffer via vmalloc_32().
+ * called from hw_params
+ * NOTE: this may be called not only once per pcm open!
+ */
+static int snd_pcm_alloc_vmalloc_buffer(snd_pcm_substream_t *subs, size_t size)
+{
+	snd_pcm_runtime_t *runtime = subs->runtime;
+	if (runtime->dma_area) {
+		/* already allocated */
+		if (runtime->dma_bytes >= size)
+			return 0; /* already enough large */
+		vfree_nocheck(runtime->dma_area); /* bypass the memory wrapper */
+	}
+	runtime->dma_area = vmalloc_32(size);
+	if (! runtime->dma_area)
+		return -ENOMEM;
+	memset(runtime->dma_area, 0, size);
+	runtime->dma_bytes = size;
+	return 1; /* changed */
+}
+
+/*
+ * free the buffer.
+ * called from hw_free callback
+ * NOTE: this may be called not only once per pcm open!
+ */
+static int snd_pcm_free_vmalloc_buffer(snd_pcm_substream_t *subs)
+{
+	snd_pcm_runtime_t *runtime = subs->runtime;
+	if (runtime->dma_area) {
+		vfree_nocheck(runtime->dma_area); /* bypass the memory wrapper */
+		runtime->dma_area = NULL;
+	}
+	return 0;
+}
+
+
+/*
+ * read three pending pcm bytes via inb()
+ */
+static void vx_pcm_read_per_bytes(vx_core_t *chip, snd_pcm_runtime_t *runtime, vx_pipe_t *pipe)
+{
+	int offset = pipe->hw_ptr;
+	unsigned char *buf = (unsigned char *)(runtime->dma_area + offset);
+	*buf++ = vx_inb(chip, RXH);
+	if (++offset >= pipe->buffer_bytes) {
+		offset = 0;
+		buf = (unsigned char *)runtime->dma_area;
+	}
+	*buf++ = vx_inb(chip, RXM);
+	if (++offset >= pipe->buffer_bytes) {
+		offset = 0;
+		buf = (unsigned char *)runtime->dma_area;
+	}
+	*buf++ = vx_inb(chip, RXL);
+	if (++offset >= pipe->buffer_bytes) {
+		offset = 0;
+		buf = (unsigned char *)runtime->dma_area;
+	}
+	pipe->hw_ptr = offset;
+}
+
+/*
+ * vx_set_pcx_time - convert from the PC time to the RMH status time.
+ * @pc_time: the pointer for the PC-time to set
+ * @dsp_time: the pointer for RMH status time array
+ */
+static void vx_set_pcx_time(vx_core_t *chip, pcx_time_t *pc_time, unsigned int *dsp_time)
+{
+	dsp_time[0] = (unsigned int)((*pc_time) >> 24) & PCX_TIME_HI_MASK;
+	dsp_time[1] = (unsigned int)(*pc_time) &  MASK_DSP_WORD;
+}
+
+/*
+ * vx_set_differed_time - set the differed time if specified
+ * @rmh: the rmh record to modify
+ * @pipe: the pipe to be checked
+ *
+ * if the pipe is programmed with the differed time, set the DSP time
+ * on the rmh and changes its command length.
+ *
+ * returns the increase of the command length.
+ */
+static int vx_set_differed_time(vx_core_t *chip, struct vx_rmh *rmh, vx_pipe_t *pipe)
+{
+	/* Update The length added to the RMH command by the timestamp */
+	if (! (pipe->differed_type & DC_DIFFERED_DELAY))
+		return 0;
+		
+	/* Set the T bit */
+	rmh->Cmd[0] |= DSP_DIFFERED_COMMAND_MASK;
+
+	/* Time stamp is the 1st following parameter */
+	vx_set_pcx_time(chip, &pipe->pcx_time, &rmh->Cmd[1]);
+
+	/* Add the flags to a notified differed command */
+	if (pipe->differed_type & DC_NOTIFY_DELAY)
+		rmh->Cmd[1] |= NOTIFY_MASK_TIME_HIGH ;
+
+	/* Add the flags to a multiple differed command */
+	if (pipe->differed_type & DC_MULTIPLE_DELAY)
+		rmh->Cmd[1] |= MULTIPLE_MASK_TIME_HIGH;
+
+	/* Add the flags to a stream-time differed command */
+	if (pipe->differed_type & DC_STREAM_TIME_DELAY)
+		rmh->Cmd[1] |= STREAM_MASK_TIME_HIGH;
+		
+	rmh->LgCmd += 2;
+	return 2;
+}
+
+/*
+ * vx_set_stream_format - send the stream format command
+ * @pipe: the affected pipe
+ * @data: format bitmask
+ */
+static int vx_set_stream_format(vx_core_t *chip, vx_pipe_t *pipe, unsigned int data)
+{
+	struct vx_rmh rmh;
+
+	vx_init_rmh(&rmh, pipe->is_capture ?
+		    CMD_FORMAT_STREAM_IN : CMD_FORMAT_STREAM_OUT);
+	rmh.Cmd[0] |= pipe->number << FIELD_SIZE;
+
+        /* Command might be longer since we may have to add a timestamp */
+	vx_set_differed_time(chip, &rmh, pipe);
+
+	rmh.Cmd[rmh.LgCmd] = (data & 0xFFFFFF00) >> 8;
+	rmh.Cmd[rmh.LgCmd + 1] = (data & 0xFF) << 16 /*| (datal & 0xFFFF00) >> 8*/;
+	rmh.LgCmd += 2;
+    
+	return vx_send_msg(chip, &rmh);
+}
+
+
+/*
+ * vx_set_format - set the format of a pipe
+ * @pipe: the affected pipe
+ * @runtime: pcm runtime instance to be referred
+ *
+ * returns 0 if successful, or a negative error code.
+ */
+static int vx_set_format(vx_core_t *chip, vx_pipe_t *pipe,
+			 snd_pcm_runtime_t *runtime)
+{
+	unsigned int header = HEADER_FMT_BASE;
+
+	if (runtime->channels == 1)
+		header |= HEADER_FMT_MONO;
+	if (snd_pcm_format_little_endian(runtime->format))
+		header |= HEADER_FMT_INTEL;
+	if (runtime->rate < 32000 && runtime->rate > 11025)
+		header |= HEADER_FMT_UPTO32;
+	else if (runtime->rate <= 11025)
+		header |= HEADER_FMT_UPTO11;
+
+	switch (snd_pcm_format_physical_width(runtime->format)) {
+	// case 8: break;
+	case 16: header |= HEADER_FMT_16BITS; break;
+	case 24: header |= HEADER_FMT_24BITS; break;
+	default : 
+		snd_BUG();
+		return -EINVAL;
+        };
+
+	return vx_set_stream_format(chip, pipe, header);
+}
+
+/*
+ * set / query the IBL size
+ */
+static int vx_set_ibl(vx_core_t *chip, struct vx_ibl_info *info)
+{
+	int err;
+	struct vx_rmh rmh;
+
+	vx_init_rmh(&rmh, CMD_IBL);
+	rmh.Cmd[0] |= info->size & 0x03ffff;
+	err = vx_send_msg(chip, &rmh);
+	if (err < 0)
+		return err;
+	info->size = rmh.Stat[0];
+	info->max_size = rmh.Stat[1];
+	info->min_size = rmh.Stat[2];
+	info->granularity = rmh.Stat[3];
+	snd_printdd(KERN_DEBUG "vx_set_ibl: size = %d, max = %d, min = %d, gran = %d\n",
+		   info->size, info->max_size, info->min_size, info->granularity);
+	return 0;
+}
+
+
+/*
+ * vx_get_pipe_state - get the state of a pipe
+ * @pipe: the pipe to be checked
+ * @state: the pointer for the returned state
+ *
+ * checks the state of a given pipe, and stores the state (1 = running,
+ * 0 = paused) on the given pointer.
+ *
+ * called from trigger callback only
+ */
+static int vx_get_pipe_state(vx_core_t *chip, vx_pipe_t *pipe, int *state)
+{
+	int err;
+	struct vx_rmh rmh;
+
+	vx_init_rmh(&rmh, CMD_PIPE_STATE);
+	vx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);
+	err = vx_send_msg_nolock(chip, &rmh); /* no lock needed for trigger */ 
+	if (! err)
+		*state = (rmh.Stat[0] & (1 << pipe->number)) ? 1 : 0;
+	return err;
+}
+
+
+/*
+ * vx_query_hbuffer_size - query available h-buffer size in bytes
+ * @pipe: the pipe to be checked
+ *
+ * return the available size on h-buffer in bytes,
+ * or a negative error code.
+ *
+ * NOTE: calling this function always switches to the stream mode.
+ *       you'll need to disconnect the host to get back to the
+ *       normal mode.
+ */
+static int vx_query_hbuffer_size(vx_core_t *chip, vx_pipe_t *pipe)
+{
+	int result;
+	struct vx_rmh rmh;
+
+	vx_init_rmh(&rmh, CMD_SIZE_HBUFFER);
+	vx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);
+	if (pipe->is_capture)
+		rmh.Cmd[0] |= 0x00000001;
+	result = vx_send_msg(chip, &rmh);
+	if (! result)
+		result = rmh.Stat[0] & 0xffff;
+	return result;
+}
+
+
+/*
+ * vx_pipe_can_start - query whether a pipe is ready for start
+ * @pipe: the pipe to be checked
+ *
+ * return 1 if ready, 0 if not ready, and negative value on error.
+ *
+ * called from trigger callback only
+ */
+static int vx_pipe_can_start(vx_core_t *chip, vx_pipe_t *pipe)
+{
+	int err;
+	struct vx_rmh rmh;
+        
+	vx_init_rmh(&rmh, CMD_CAN_START_PIPE);
+	vx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);
+	rmh.Cmd[0] |= 1;
+
+	err = vx_send_msg_nolock(chip, &rmh); /* no lock needed for trigger */ 
+	if (! err) {
+		if (rmh.Stat[0])
+			err = 1;
+	}
+	return err;
+}
+
+/*
+ * vx_conf_pipe - tell the pipe to stand by and wait for IRQA.
+ * @pipe: the pipe to be configured
+ */
+static int vx_conf_pipe(vx_core_t *chip, vx_pipe_t *pipe)
+{
+	struct vx_rmh rmh;
+
+	vx_init_rmh(&rmh, CMD_CONF_PIPE);
+	if (pipe->is_capture)
+		rmh.Cmd[0] |= COMMAND_RECORD_MASK;
+	rmh.Cmd[1] = 1 << pipe->number;
+	return vx_send_msg_nolock(chip, &rmh); /* no lock needed for trigger */
+}
+
+/*
+ * vx_send_irqa - trigger IRQA
+ */
+static int vx_send_irqa(vx_core_t *chip)
+{
+	struct vx_rmh rmh;
+
+	vx_init_rmh(&rmh, CMD_SEND_IRQA);
+	return vx_send_msg_nolock(chip, &rmh); /* no lock needed for trigger */ 
+}
+
+
+#define MAX_WAIT_FOR_DSP        250
+/*
+ * vx boards do not support inter-card sync, besides
+ * only 126 samples require to be prepared before a pipe can start
+ */
+#define CAN_START_DELAY         2	/* wait 2ms only before asking if the pipe is ready*/
+#define WAIT_STATE_DELAY        2	/* wait 2ms after irqA was requested and check if the pipe state toggled*/
+
+/*
+ * vx_toggle_pipe - start / pause a pipe
+ * @pipe: the pipe to be triggered
+ * @state: start = 1, pause = 0
+ *
+ * called from trigger callback only
+ *
+ */
+static int vx_toggle_pipe(vx_core_t *chip, vx_pipe_t *pipe, int state)
+{
+	int err, i, cur_state;
+
+	/* Check the pipe is not already in the requested state */
+	if (vx_get_pipe_state(chip, pipe, &cur_state) < 0)
+		return -EBADFD;
+	if (state == cur_state)
+		return 0;
+
+	/* If a start is requested, ask the DSP to get prepared
+	 * and wait for a positive acknowledge (when there are
+	 * enough sound buffer for this pipe)
+	 */
+	if (state) {
+		for (i = 0 ; i < MAX_WAIT_FOR_DSP; i++) {
+			err = vx_pipe_can_start(chip, pipe);
+			if (err > 0)
+				break;
+			/* Wait for a few, before asking again
+			 * to avoid flooding the DSP with our requests
+			 */
+			mdelay(1);
+		}
+	}
+    
+	if ((err = vx_conf_pipe(chip, pipe)) < 0)
+		return err;
+
+	if ((err = vx_send_irqa(chip)) < 0)
+		return err;
+    
+	/* If it completes successfully, wait for the pipes
+	 * reaching the expected state before returning
+	 * Check one pipe only (since they are synchronous)
+	 */
+	for (i = 0; i < MAX_WAIT_FOR_DSP; i++) {
+		err = vx_get_pipe_state(chip, pipe, &cur_state);
+		if (err < 0 || cur_state == state)
+			break;
+		err = -EIO;
+		mdelay(1);
+	}
+	return err < 0 ? -EIO : 0;
+}
+
+    
+/*
+ * vx_stop_pipe - stop a pipe
+ * @pipe: the pipe to be stopped
+ *
+ * called from trigger callback only
+ */
+static int vx_stop_pipe(vx_core_t *chip, vx_pipe_t *pipe)
+{
+	struct vx_rmh rmh;
+	vx_init_rmh(&rmh, CMD_STOP_PIPE);
+	vx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);
+	return vx_send_msg_nolock(chip, &rmh); /* no lock needed for trigger */ 
+}
+
+
+/*
+ * vx_alloc_pipe - allocate a pipe and initialize the pipe instance
+ * @capture: 0 = playback, 1 = capture operation
+ * @audioid: the audio id to be assigned
+ * @num_audio: number of audio channels
+ * @pipep: the returned pipe instance
+ *
+ * return 0 on success, or a negative error code.
+ */
+static int vx_alloc_pipe(vx_core_t *chip, int capture,
+			 int audioid, int num_audio,
+			 vx_pipe_t **pipep)
+{
+	int err;
+	vx_pipe_t *pipe;
+	struct vx_rmh rmh;
+	int data_mode;
+
+	*pipep = NULL;
+	vx_init_rmh(&rmh, CMD_RES_PIPE);
+	vx_set_pipe_cmd_params(&rmh, capture, audioid, num_audio);
+#if 0	// NYI
+	if (underrun_skip_sound)
+		rmh.Cmd[0] |= BIT_SKIP_SOUND;
+#endif	// NYI
+	data_mode = (chip->uer_bits & IEC958_AES0_NONAUDIO) != 0;
+	if (! capture && data_mode)
+		rmh.Cmd[0] |= BIT_DATA_MODE;
+	err = vx_send_msg(chip, &rmh);
+	if (err < 0)
+		return err;
+
+	/* initialize the pipe record */
+	pipe = kcalloc(1, sizeof(*pipe), GFP_KERNEL);
+	if (! pipe) {
+		/* release the pipe */
+		vx_init_rmh(&rmh, CMD_FREE_PIPE);
+		vx_set_pipe_cmd_params(&rmh, capture, audioid, 0);
+		vx_send_msg(chip, &rmh);
+		return -ENOMEM;
+	}
+
+	/* the pipe index should be identical with the audio index */
+	pipe->number = audioid;
+	pipe->is_capture = capture;
+	pipe->channels = num_audio;
+	pipe->differed_type = 0;
+	pipe->pcx_time = 0;
+	pipe->data_mode = data_mode;
+	*pipep = pipe;
+
+	return 0;
+}
+
+
+/*
+ * vx_free_pipe - release a pipe
+ * @pipe: pipe to be released
+ */
+static int vx_free_pipe(vx_core_t *chip, vx_pipe_t *pipe)
+{
+	struct vx_rmh rmh;
+
+	vx_init_rmh(&rmh, CMD_FREE_PIPE);
+	vx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);
+	vx_send_msg(chip, &rmh);
+
+	kfree(pipe);
+	return 0;
+}
+
+
+/*
+ * vx_start_stream - start the stream
+ *
+ * called from trigger callback only
+ */
+static int vx_start_stream(vx_core_t *chip, vx_pipe_t *pipe)
+{
+	struct vx_rmh rmh;
+
+	vx_init_rmh(&rmh, CMD_START_ONE_STREAM);
+	vx_set_stream_cmd_params(&rmh, pipe->is_capture, pipe->number);
+	vx_set_differed_time(chip, &rmh, pipe);
+	return vx_send_msg_nolock(chip, &rmh); /* no lock needed for trigger */ 
+}
+
+
+/*
+ * vx_stop_stream - stop the stream
+ *
+ * called from trigger callback only
+ */
+static int vx_stop_stream(vx_core_t *chip, vx_pipe_t *pipe)
+{
+	struct vx_rmh rmh;
+
+	vx_init_rmh(&rmh, CMD_STOP_STREAM);
+	vx_set_stream_cmd_params(&rmh, pipe->is_capture, pipe->number);
+	return vx_send_msg_nolock(chip, &rmh); /* no lock needed for trigger */ 
+}
+
+
+/*
+ * playback hw information
+ */
+
+static snd_pcm_hardware_t vx_pcm_playback_hw = {
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_RESUME),
+	.formats =		/*SNDRV_PCM_FMTBIT_U8 |*/ SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE,
+	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		5000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	126,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		2,
+	.periods_max =		VX_MAX_PERIODS,
+	.fifo_size =		126,
+};
+
+
+static void vx_pcm_delayed_start(unsigned long arg);
+
+/*
+ * vx_pcm_playback_open - open callback for playback
+ */
+static int vx_pcm_playback_open(snd_pcm_substream_t *subs)
+{
+	snd_pcm_runtime_t *runtime = subs->runtime;
+	vx_core_t *chip = snd_pcm_substream_chip(subs);
+	vx_pipe_t *pipe = NULL;
+	unsigned int audio;
+	int err;
+
+	if (chip->chip_status & VX_STAT_IS_STALE)
+		return -EBUSY;
+
+	audio = subs->pcm->device * 2;
+	snd_assert(audio < chip->audio_outs, return -EINVAL);
+	
+	/* playback pipe may have been already allocated for monitoring */
+	pipe = chip->playback_pipes[audio];
+	if (! pipe) {
+		/* not allocated yet */
+		err = vx_alloc_pipe(chip, 0, audio, 2, &pipe); /* stereo playback */
+		if (err < 0)
+			return err;
+		chip->playback_pipes[audio] = pipe;
+	}
+	/* open for playback */
+	pipe->references++;
+
+	pipe->substream = subs;
+	tasklet_init(&pipe->start_tq, vx_pcm_delayed_start, (unsigned long)subs);
+	chip->playback_pipes[audio] = pipe;
+
+	runtime->hw = vx_pcm_playback_hw;
+	runtime->hw.period_bytes_min = chip->ibl.size;
+	runtime->private_data = pipe;
+
+	/* align to 4 bytes (otherwise will be problematic when 24bit is used) */ 
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 4);
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 4);
+
+	return 0;
+}
+
+/*
+ * vx_pcm_playback_close - close callback for playback
+ */
+static int vx_pcm_playback_close(snd_pcm_substream_t *subs)
+{
+	vx_core_t *chip = snd_pcm_substream_chip(subs);
+	vx_pipe_t *pipe;
+
+	if (! subs->runtime->private_data)
+		return -EINVAL;
+
+	pipe = subs->runtime->private_data;
+
+	if (--pipe->references == 0) {
+		chip->playback_pipes[pipe->number] = NULL;
+		vx_free_pipe(chip, pipe);
+	}
+
+	return 0;
+
+}
+
+
+/*
+ * vx_notify_end_of_buffer - send "end-of-buffer" notifier at the given pipe
+ * @pipe: the pipe to notify
+ *
+ * NB: call with a certain lock.
+ */
+static int vx_notify_end_of_buffer(vx_core_t *chip, vx_pipe_t *pipe)
+{
+	int err;
+	struct vx_rmh rmh;  /* use a temporary rmh here */
+
+	/* Toggle Dsp Host Interface into Message mode */
+	vx_send_rih_nolock(chip, IRQ_PAUSE_START_CONNECT);
+	vx_init_rmh(&rmh, CMD_NOTIFY_END_OF_BUFFER);
+	vx_set_stream_cmd_params(&rmh, 0, pipe->number);
+	err = vx_send_msg_nolock(chip, &rmh);
+	if (err < 0)
+		return err;
+	/* Toggle Dsp Host Interface back to sound transfer mode */
+	vx_send_rih_nolock(chip, IRQ_PAUSE_START_CONNECT);
+	return 0;
+}
+
+/*
+ * vx_pcm_playback_transfer_chunk - transfer a single chunk
+ * @subs: substream
+ * @pipe: the pipe to transfer
+ * @size: chunk size in bytes
+ *
+ * transfer a single buffer chunk.  EOB notificaton is added after that.
+ * called from the interrupt handler, too.
+ *
+ * return 0 if ok.
+ */
+static int vx_pcm_playback_transfer_chunk(vx_core_t *chip, snd_pcm_runtime_t *runtime, vx_pipe_t *pipe, int size)
+{
+	int space, err = 0;
+
+	space = vx_query_hbuffer_size(chip, pipe);
+	if (space < 0) {
+		/* disconnect the host, SIZE_HBUF command always switches to the stream mode */
+		vx_send_rih(chip, IRQ_CONNECT_STREAM_NEXT);
+		snd_printd("error hbuffer\n");
+		return space;
+	}
+	if (space < size) {
+		vx_send_rih(chip, IRQ_CONNECT_STREAM_NEXT);
+		snd_printd("no enough hbuffer space %d\n", space);
+		return -EIO; /* XRUN */
+	}
+		
+	/* we don't need irqsave here, because this function
+	 * is called from either trigger callback or irq handler
+	 */
+	spin_lock(&chip->lock); 
+	vx_pseudo_dma_write(chip, runtime, pipe, size);
+	err = vx_notify_end_of_buffer(chip, pipe);
+	/* disconnect the host, SIZE_HBUF command always switches to the stream mode */
+	vx_send_rih_nolock(chip, IRQ_CONNECT_STREAM_NEXT);
+	spin_unlock(&chip->lock);
+	return err;
+}
+
+/*
+ * update the position of the given pipe.
+ * pipe->position is updated and wrapped within the buffer size.
+ * pipe->transferred is updated, too, but the size is not wrapped,
+ * so that the caller can check the total transferred size later
+ * (to call snd_pcm_period_elapsed).
+ */
+static int vx_update_pipe_position(vx_core_t *chip, snd_pcm_runtime_t *runtime, vx_pipe_t *pipe)
+{
+	struct vx_rmh rmh;
+	int err, update;
+	u64 count;
+
+	vx_init_rmh(&rmh, CMD_STREAM_SAMPLE_COUNT);
+	vx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);
+	err = vx_send_msg(chip, &rmh);
+	if (err < 0)
+		return err;
+
+	count = ((u64)(rmh.Stat[0] & 0xfffff) << 24) | (u64)rmh.Stat[1];
+	update = (int)(count - pipe->cur_count);
+	pipe->cur_count = count;
+	pipe->position += update;
+	if (pipe->position >= (int)runtime->buffer_size)
+		pipe->position %= runtime->buffer_size;
+	pipe->transferred += update;
+	return 0;
+}
+
+/*
+ * transfer the pending playback buffer data to DSP
+ * called from interrupt handler
+ */
+static void vx_pcm_playback_transfer(vx_core_t *chip, snd_pcm_substream_t *subs, vx_pipe_t *pipe, int nchunks)
+{
+	int i, err;
+	snd_pcm_runtime_t *runtime = subs->runtime;
+
+	if (! pipe->prepared || (chip->chip_status & VX_STAT_IS_STALE))
+		return;
+	for (i = 0; i < nchunks; i++) {
+		if ((err = vx_pcm_playback_transfer_chunk(chip, runtime, pipe,
+							  chip->ibl.size)) < 0)
+			return;
+	}
+}
+
+/*
+ * update the playback position and call snd_pcm_period_elapsed() if necessary
+ * called from interrupt handler
+ */
+static void vx_pcm_playback_update(vx_core_t *chip, snd_pcm_substream_t *subs, vx_pipe_t *pipe)
+{
+	int err;
+	snd_pcm_runtime_t *runtime = subs->runtime;
+
+	if (pipe->running && ! (chip->chip_status & VX_STAT_IS_STALE)) {
+		if ((err = vx_update_pipe_position(chip, runtime, pipe)) < 0)
+			return;
+		if (pipe->transferred >= (int)runtime->period_size) {
+			pipe->transferred %= runtime->period_size;
+			snd_pcm_period_elapsed(subs);
+		}
+	}
+}
+
+/*
+ * start the stream and pipe.
+ * this function is called from tasklet, which is invoked by the trigger
+ * START callback.
+ */
+static void vx_pcm_delayed_start(unsigned long arg)
+{
+	snd_pcm_substream_t *subs = (snd_pcm_substream_t *)arg;
+	vx_core_t *chip = subs->pcm->private_data;
+	vx_pipe_t *pipe = subs->runtime->private_data;
+	int err;
+
+	/*  printk( KERN_DEBUG "DDDD tasklet delayed start jiffies = %ld\n", jiffies);*/
+
+	if ((err = vx_start_stream(chip, pipe)) < 0) {
+		snd_printk(KERN_ERR "vx: cannot start stream\n");
+		return;
+	}
+	if ((err = vx_toggle_pipe(chip, pipe, 1)) < 0) {
+		snd_printk(KERN_ERR "vx: cannot start pipe\n");
+		return;
+	}
+	/*   printk( KERN_DEBUG "dddd tasklet delayed start jiffies = %ld \n", jiffies);*/
+}
+
+/*
+ * vx_pcm_playback_trigger - trigger callback for playback
+ */
+static int vx_pcm_trigger(snd_pcm_substream_t *subs, int cmd)
+{
+	vx_core_t *chip = snd_pcm_substream_chip(subs);
+	vx_pipe_t *pipe = subs->runtime->private_data;
+	int err;
+
+	if (chip->chip_status & VX_STAT_IS_STALE)
+		return -EBUSY;
+		
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		if (! pipe->is_capture)
+			vx_pcm_playback_transfer(chip, subs, pipe, 2);
+		/* FIXME:
+		 * we trigger the pipe using tasklet, so that the interrupts are
+		 * issued surely after the trigger is completed.
+		 */ 
+		tasklet_hi_schedule(&pipe->start_tq);
+		chip->pcm_running++;
+		pipe->running = 1;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		vx_toggle_pipe(chip, pipe, 0);
+		vx_stop_pipe(chip, pipe);
+		vx_stop_stream(chip, pipe);
+		chip->pcm_running--;
+		pipe->running = 0;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if ((err = vx_toggle_pipe(chip, pipe, 0)) < 0)
+			return err;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if ((err = vx_toggle_pipe(chip, pipe, 1)) < 0)
+			return err;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*
+ * vx_pcm_playback_pointer - pointer callback for playback
+ */
+static snd_pcm_uframes_t vx_pcm_playback_pointer(snd_pcm_substream_t *subs)
+{
+	snd_pcm_runtime_t *runtime = subs->runtime;
+	vx_pipe_t *pipe = runtime->private_data;
+	return pipe->position;
+}
+
+/*
+ * vx_pcm_hw_params - hw_params callback for playback and capture
+ */
+static int vx_pcm_hw_params(snd_pcm_substream_t *subs,
+				     snd_pcm_hw_params_t *hw_params)
+{
+	return snd_pcm_alloc_vmalloc_buffer(subs, params_buffer_bytes(hw_params));
+}
+
+/*
+ * vx_pcm_hw_free - hw_free callback for playback and capture
+ */
+static int vx_pcm_hw_free(snd_pcm_substream_t *subs)
+{
+	return snd_pcm_free_vmalloc_buffer(subs);
+}
+
+/*
+ * vx_pcm_prepare - prepare callback for playback and capture
+ */
+static int vx_pcm_prepare(snd_pcm_substream_t *subs)
+{
+	vx_core_t *chip = snd_pcm_substream_chip(subs);
+	snd_pcm_runtime_t *runtime = subs->runtime;
+	vx_pipe_t *pipe = runtime->private_data;
+	int err, data_mode;
+	// int max_size, nchunks;
+
+	if (chip->chip_status & VX_STAT_IS_STALE)
+		return -EBUSY;
+
+	data_mode = (chip->uer_bits & IEC958_AES0_NONAUDIO) != 0;
+	if (data_mode != pipe->data_mode && ! pipe->is_capture) {
+		/* IEC958 status (raw-mode) was changed */
+		/* we reopen the pipe */
+		struct vx_rmh rmh;
+		snd_printdd(KERN_DEBUG "reopen the pipe with data_mode = %d\n", data_mode);
+		vx_init_rmh(&rmh, CMD_FREE_PIPE);
+		vx_set_pipe_cmd_params(&rmh, 0, pipe->number, 0);
+		if ((err = vx_send_msg(chip, &rmh)) < 0)
+			return err;
+		vx_init_rmh(&rmh, CMD_RES_PIPE);
+		vx_set_pipe_cmd_params(&rmh, 0, pipe->number, pipe->channels);
+		if (data_mode)
+			rmh.Cmd[0] |= BIT_DATA_MODE;
+		if ((err = vx_send_msg(chip, &rmh)) < 0)
+			return err;
+		pipe->data_mode = data_mode;
+	}
+
+	if (chip->pcm_running && chip->freq != runtime->rate) {
+		snd_printk(KERN_ERR "vx: cannot set different clock %d from the current %d\n", runtime->rate, chip->freq);
+		return -EINVAL;
+	}
+	vx_set_clock(chip, runtime->rate);
+
+	if ((err = vx_set_format(chip, pipe, runtime)) < 0)
+		return err;
+
+	if (vx_is_pcmcia(chip)) {
+		pipe->align = 2; /* 16bit word */
+	} else {
+		pipe->align = 4; /* 32bit word */
+	}
+
+	pipe->buffer_bytes = frames_to_bytes(runtime, runtime->buffer_size);
+	pipe->period_bytes = frames_to_bytes(runtime, runtime->period_size);
+	pipe->hw_ptr = 0;
+
+	/* set the timestamp */
+	vx_update_pipe_position(chip, runtime, pipe);
+	/* clear again */
+	pipe->transferred = 0;
+	pipe->position = 0;
+
+	pipe->prepared = 1;
+
+	return 0;
+}
+
+
+/*
+ * operators for PCM playback
+ */
+static snd_pcm_ops_t vx_pcm_playback_ops = {
+	.open =		vx_pcm_playback_open,
+	.close =	vx_pcm_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	vx_pcm_hw_params,
+	.hw_free =	vx_pcm_hw_free,
+	.prepare =	vx_pcm_prepare,
+	.trigger =	vx_pcm_trigger,
+	.pointer =	vx_pcm_playback_pointer,
+	.page =		snd_pcm_get_vmalloc_page,
+};
+
+
+/*
+ * playback hw information
+ */
+
+static snd_pcm_hardware_t vx_pcm_capture_hw = {
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_RESUME),
+	.formats =		/*SNDRV_PCM_FMTBIT_U8 |*/ SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE,
+	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		5000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	126,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		2,
+	.periods_max =		VX_MAX_PERIODS,
+	.fifo_size =		126,
+};
+
+
+/*
+ * vx_pcm_capture_open - open callback for capture
+ */
+static int vx_pcm_capture_open(snd_pcm_substream_t *subs)
+{
+	snd_pcm_runtime_t *runtime = subs->runtime;
+	vx_core_t *chip = snd_pcm_substream_chip(subs);
+	vx_pipe_t *pipe;
+	vx_pipe_t *pipe_out_monitoring = NULL;
+	unsigned int audio;
+	int err;
+
+	if (chip->chip_status & VX_STAT_IS_STALE)
+		return -EBUSY;
+
+	audio = subs->pcm->device * 2;
+	snd_assert(audio < chip->audio_ins, return -EINVAL);
+	err = vx_alloc_pipe(chip, 1, audio, 2, &pipe);
+	if (err < 0)
+		return err;
+	pipe->substream = subs;
+	tasklet_init(&pipe->start_tq, vx_pcm_delayed_start, (unsigned long)subs);
+	chip->capture_pipes[audio] = pipe;
+
+	/* check if monitoring is needed */
+	if (chip->audio_monitor_active[audio]) {
+		pipe_out_monitoring = chip->playback_pipes[audio];
+		if (! pipe_out_monitoring) {
+			/* allocate a pipe */
+			err = vx_alloc_pipe(chip, 0, audio, 2, &pipe_out_monitoring);
+			if (err < 0)
+				return err;
+			chip->playback_pipes[audio] = pipe_out_monitoring;
+		}
+		pipe_out_monitoring->references++;
+		/* 
+		   if an output pipe is available, it's audios still may need to be 
+		   unmuted. hence we'll have to call a mixer entry point.
+		*/
+		vx_set_monitor_level(chip, audio, chip->audio_monitor[audio], chip->audio_monitor_active[audio]);
+		/* assuming stereo */
+		vx_set_monitor_level(chip, audio+1, chip->audio_monitor[audio+1], chip->audio_monitor_active[audio+1]); 
+	}
+
+	pipe->monitoring_pipe = pipe_out_monitoring; /* default value NULL */
+
+	runtime->hw = vx_pcm_capture_hw;
+	runtime->hw.period_bytes_min = chip->ibl.size;
+	runtime->private_data = pipe;
+
+	/* align to 4 bytes (otherwise will be problematic when 24bit is used) */ 
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 4);
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 4);
+
+	return 0;
+}
+
+/*
+ * vx_pcm_capture_close - close callback for capture
+ */
+static int vx_pcm_capture_close(snd_pcm_substream_t *subs)
+{
+	vx_core_t *chip = snd_pcm_substream_chip(subs);
+	vx_pipe_t *pipe;
+	vx_pipe_t *pipe_out_monitoring;
+	
+	if (! subs->runtime->private_data)
+		return -EINVAL;
+	pipe = subs->runtime->private_data;
+	chip->capture_pipes[pipe->number] = NULL;
+
+	pipe_out_monitoring = pipe->monitoring_pipe;
+
+	/*
+	  if an output pipe is attached to this input, 
+	  check if it needs to be released.
+	*/
+	if (pipe_out_monitoring) {
+		if (--pipe_out_monitoring->references == 0) {
+			vx_free_pipe(chip, pipe_out_monitoring);
+			chip->playback_pipes[pipe->number] = NULL;
+			pipe->monitoring_pipe = NULL;
+		}
+	}
+	
+	vx_free_pipe(chip, pipe);
+	return 0;
+}
+
+
+
+#define DMA_READ_ALIGN	6	/* hardware alignment for read */
+
+/*
+ * vx_pcm_capture_update - update the capture buffer
+ */
+static void vx_pcm_capture_update(vx_core_t *chip, snd_pcm_substream_t *subs, vx_pipe_t *pipe)
+{
+	int size, space, count;
+	snd_pcm_runtime_t *runtime = subs->runtime;
+
+	if (! pipe->prepared || (chip->chip_status & VX_STAT_IS_STALE))
+		return;
+
+	size = runtime->buffer_size - snd_pcm_capture_avail(runtime);
+	if (! size)
+		return;
+	size = frames_to_bytes(runtime, size);
+	space = vx_query_hbuffer_size(chip, pipe);
+	if (space < 0)
+		goto _error;
+	if (size > space)
+		size = space;
+	size = (size / 3) * 3; /* align to 3 bytes */
+	if (size < DMA_READ_ALIGN)
+		goto _error;
+
+	/* keep the last 6 bytes, they will be read after disconnection */
+	count = size - DMA_READ_ALIGN;
+	/* read bytes until the current pointer reaches to the aligned position
+	 * for word-transfer
+	 */
+	while (count > 0) {
+		if ((pipe->hw_ptr % pipe->align) == 0)
+			break;
+		if (vx_wait_for_rx_full(chip) < 0)
+			goto _error;
+		vx_pcm_read_per_bytes(chip, runtime, pipe);
+		count -= 3;
+	}
+	if (count > 0) {
+		/* ok, let's accelerate! */
+		int align = pipe->align * 3;
+		space = (count / align) * align;
+		vx_pseudo_dma_read(chip, runtime, pipe, space);
+		count -= space;
+	}
+	/* read the rest of bytes */
+	while (count > 0) {
+		if (vx_wait_for_rx_full(chip) < 0)
+			goto _error;
+		vx_pcm_read_per_bytes(chip, runtime, pipe);
+		count -= 3;
+	}
+	/* disconnect the host, SIZE_HBUF command always switches to the stream mode */
+	vx_send_rih_nolock(chip, IRQ_CONNECT_STREAM_NEXT);
+	/* read the last pending 6 bytes */
+	count = DMA_READ_ALIGN;
+	while (count > 0) {
+		vx_pcm_read_per_bytes(chip, runtime, pipe);
+		count -= 3;
+	}
+	/* update the position */
+	pipe->transferred += size;
+	if (pipe->transferred >= pipe->period_bytes) {
+		pipe->transferred %= pipe->period_bytes;
+		snd_pcm_period_elapsed(subs);
+	}
+	return;
+
+ _error:
+	/* disconnect the host, SIZE_HBUF command always switches to the stream mode */
+	vx_send_rih_nolock(chip, IRQ_CONNECT_STREAM_NEXT);
+	return;
+}
+
+/*
+ * vx_pcm_capture_pointer - pointer callback for capture
+ */
+static snd_pcm_uframes_t vx_pcm_capture_pointer(snd_pcm_substream_t *subs)
+{
+	snd_pcm_runtime_t *runtime = subs->runtime;
+	vx_pipe_t *pipe = runtime->private_data;
+	return bytes_to_frames(runtime, pipe->hw_ptr);
+}
+
+/*
+ * operators for PCM capture
+ */
+static snd_pcm_ops_t vx_pcm_capture_ops = {
+	.open =		vx_pcm_capture_open,
+	.close =	vx_pcm_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	vx_pcm_hw_params,
+	.hw_free =	vx_pcm_hw_free,
+	.prepare =	vx_pcm_prepare,
+	.trigger =	vx_pcm_trigger,
+	.pointer =	vx_pcm_capture_pointer,
+	.page =		snd_pcm_get_vmalloc_page,
+};
+
+
+/*
+ * interrupt handler for pcm streams
+ */
+void vx_pcm_update_intr(vx_core_t *chip, unsigned int events)
+{
+	unsigned int i;
+	vx_pipe_t *pipe;
+
+#define EVENT_MASK	(END_OF_BUFFER_EVENTS_PENDING|ASYNC_EVENTS_PENDING)
+
+	if (events & EVENT_MASK) {
+		vx_init_rmh(&chip->irq_rmh, CMD_ASYNC);
+		if (events & ASYNC_EVENTS_PENDING)
+			chip->irq_rmh.Cmd[0] |= 0x00000001;	/* SEL_ASYNC_EVENTS */
+		if (events & END_OF_BUFFER_EVENTS_PENDING)
+			chip->irq_rmh.Cmd[0] |= 0x00000002;	/* SEL_END_OF_BUF_EVENTS */
+
+		if (vx_send_msg(chip, &chip->irq_rmh) < 0) {
+			snd_printdd(KERN_ERR "msg send error!!\n");
+			return;
+		}
+
+		i = 1;
+		while (i < chip->irq_rmh.LgStat) {
+			int p, buf, capture, eob;
+			p = chip->irq_rmh.Stat[i] & MASK_FIRST_FIELD;
+			capture = (chip->irq_rmh.Stat[i] & 0x400000) ? 1 : 0;
+			eob = (chip->irq_rmh.Stat[i] & 0x800000) ? 1 : 0;
+			i++;
+			if (events & ASYNC_EVENTS_PENDING)
+				i++;
+			buf = 1; /* force to transfer */
+			if (events & END_OF_BUFFER_EVENTS_PENDING) {
+				if (eob)
+					buf = chip->irq_rmh.Stat[i];
+				i++;
+			}
+			if (capture)
+				continue;
+			snd_assert(p >= 0 && (unsigned int)p < chip->audio_outs,);
+			pipe = chip->playback_pipes[p];
+			if (pipe && pipe->substream) {
+				vx_pcm_playback_update(chip, pipe->substream, pipe);
+				vx_pcm_playback_transfer(chip, pipe->substream, pipe, buf);
+			}
+		}
+	}
+
+	/* update the capture pcm pointers as frequently as possible */
+	for (i = 0; i < chip->audio_ins; i++) {
+		pipe = chip->capture_pipes[i];
+		if (pipe && pipe->substream)
+			vx_pcm_capture_update(chip, pipe->substream, pipe);
+	}
+}
+
+
+/*
+ * vx_init_audio_io - check the availabe audio i/o and allocate pipe arrays
+ */
+static int vx_init_audio_io(vx_core_t *chip)
+{
+	struct vx_rmh rmh;
+	int preferred;
+
+	vx_init_rmh(&rmh, CMD_SUPPORTED);
+	if (vx_send_msg(chip, &rmh) < 0) {
+		snd_printk(KERN_ERR "vx: cannot get the supported audio data\n");
+		return -ENXIO;
+	}
+
+	chip->audio_outs = rmh.Stat[0] & MASK_FIRST_FIELD;
+	chip->audio_ins = (rmh.Stat[0] >> (FIELD_SIZE*2)) & MASK_FIRST_FIELD;
+	chip->audio_info = rmh.Stat[1];
+
+	/* allocate pipes */
+	chip->playback_pipes = kmalloc(sizeof(vx_pipe_t *) * chip->audio_outs, GFP_KERNEL);
+	chip->capture_pipes = kmalloc(sizeof(vx_pipe_t *) * chip->audio_ins, GFP_KERNEL);
+	if (! chip->playback_pipes || ! chip->capture_pipes)
+		return -ENOMEM;
+
+	memset(chip->playback_pipes, 0, sizeof(vx_pipe_t *) * chip->audio_outs);
+	memset(chip->capture_pipes, 0, sizeof(vx_pipe_t *) * chip->audio_ins);
+
+	preferred = chip->ibl.size;
+	chip->ibl.size = 0;
+	vx_set_ibl(chip, &chip->ibl); /* query the info */
+	if (preferred > 0) {
+		chip->ibl.size = ((preferred + chip->ibl.granularity - 1) / chip->ibl.granularity) * chip->ibl.granularity;
+		if (chip->ibl.size > chip->ibl.max_size)
+			chip->ibl.size = chip->ibl.max_size;
+	} else
+		chip->ibl.size = chip->ibl.min_size; /* set to the minimum */
+	vx_set_ibl(chip, &chip->ibl);
+
+	return 0;
+}
+
+
+/*
+ * free callback for pcm
+ */
+static void snd_vx_pcm_free(snd_pcm_t *pcm)
+{
+	vx_core_t *chip = pcm->private_data;
+	chip->pcm[pcm->device] = NULL;
+	if (chip->playback_pipes) {
+		kfree(chip->playback_pipes);
+		chip->playback_pipes = NULL;
+	}
+	if (chip->capture_pipes) {
+		kfree(chip->capture_pipes);
+		chip->capture_pipes = NULL;
+	}
+}
+
+/*
+ * snd_vx_pcm_new - create and initialize a pcm
+ */
+int snd_vx_pcm_new(vx_core_t *chip)
+{
+	snd_pcm_t *pcm;
+	unsigned int i;
+	int err;
+
+	if ((err = vx_init_audio_io(chip)) < 0)
+		return err;
+
+	for (i = 0; i < chip->hw->num_codecs; i++) {
+		unsigned int outs, ins;
+		outs = chip->audio_outs > i * 2 ? 1 : 0;
+		ins = chip->audio_ins > i * 2 ? 1 : 0;
+		if (! outs && ! ins)
+			break;
+		err = snd_pcm_new(chip->card, "VX PCM", i,
+				  outs, ins, &pcm);
+		if (err < 0)
+			return err;
+		if (outs)
+			snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &vx_pcm_playback_ops);
+		if (ins)
+			snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &vx_pcm_capture_ops);
+
+		pcm->private_data = chip;
+		pcm->private_free = snd_vx_pcm_free;
+		pcm->info_flags = 0;
+		strcpy(pcm->name, chip->card->shortname);
+		chip->pcm[i] = pcm;
+	}
+
+	return 0;
+}
