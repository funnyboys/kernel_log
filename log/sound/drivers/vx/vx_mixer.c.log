commit c09482455ca586539802282380f59f54a1febf16
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:22 2020 +0100

    ALSA: vx: More constifications
    
    Apply const prefix to every possible place: the static tables for DSP
    commands, the string tables, and register/offset tables.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-8-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
index b17c67b14d59..13099f8c84d6 100644
--- a/sound/drivers/vx/vx_mixer.c
+++ b/sound/drivers/vx/vx_mixer.c
@@ -961,7 +961,7 @@ int snd_vx_mixer_new(struct vx_core *chip)
 		return err;
 	/* VU, peak, saturation meters */
 	for (c = 0; c < 2; c++) {
-		static char *dir[2] = { "Output", "Input" };
+		static const char * const dir[2] = { "Output", "Input" };
 		for (i = 0; i < chip->hw->num_ins; i++) {
 			int val = (i * 2) | (c << 8);
 			if (c == 1) {

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
index 98a41ac40b60..b17c67b14d59 100644
--- a/sound/drivers/vx/vx_mixer.c
+++ b/sound/drivers/vx/vx_mixer.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Driver for Digigram VX soundcards
  *
  * Common mixer part
  *
  * Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include <sound/core.h>

commit 905e46acd3272d04566fec49afbd7ad9e2ed9ae3
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat May 27 20:16:15 2017 +0530

    ALSA: declare snd_kcontrol_new structures as const
    
    Declare snd_kcontrol_new structures as const as they are only passed an
    argument to the function snd_ctl_new1. This argument is of type const,
    so snd_kcontrol_new structures having this property can be made const.
    Done using Coccinelle:
    
    @r disable optional_qualifier@
    identifier x;
    position p;
    @@
    static struct snd_kcontrol_new x@p={...};
    
    @ok@
    identifier r.x;
    position p;
    @@
    snd_ctl_new1(&x@p,...)
    
    @bad@
    position p != {r.p,ok.p};
    identifier r.x;
    @@
    x@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.x;
    @@
    +const
    struct snd_kcontrol_new x;
    
    Cross compiled these files:
    sound/aoa/codecs/tas.c - powerpc
    sound/mips/{hal2.c/sgio2audio.c} - mips
    sound/ppc/{awacs.c/beep.c/tumbler.c} - powerpc
    sound/soc/sh/siu_dai.c - sh
    Could not find an architecture to compile sound/sh/aica.c.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
index be9477e30739..98a41ac40b60 100644
--- a/sound/drivers/vx/vx_mixer.c
+++ b/sound/drivers/vx/vx_mixer.c
@@ -455,7 +455,7 @@ static int vx_output_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_ele
 	return 0;
 }
 
-static struct snd_kcontrol_new vx_control_output_level = {
+static const struct snd_kcontrol_new vx_control_output_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
 			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
@@ -514,7 +514,7 @@ static int vx_audio_src_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_v
 	return 0;
 }
 
-static struct snd_kcontrol_new vx_control_audio_src = {
+static const struct snd_kcontrol_new vx_control_audio_src = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"Capture Source",
 	.info =		vx_audio_src_info,
@@ -558,7 +558,7 @@ static int vx_clock_mode_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 	return 0;
 }
 
-static struct snd_kcontrol_new vx_control_clock_mode = {
+static const struct snd_kcontrol_new vx_control_clock_mode = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"Clock Mode",
 	.info =		vx_clock_mode_info,
@@ -717,7 +717,7 @@ static int vx_monitor_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 
 static const DECLARE_TLV_DB_SCALE(db_scale_audio_gain, -10975, 25, 0);
 
-static struct snd_kcontrol_new vx_control_audio_gain = {
+static const struct snd_kcontrol_new vx_control_audio_gain = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
 			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
@@ -727,14 +727,14 @@ static struct snd_kcontrol_new vx_control_audio_gain = {
 	.put =          vx_audio_gain_put,
 	.tlv = { .p = db_scale_audio_gain },
 };
-static struct snd_kcontrol_new vx_control_output_switch = {
+static const struct snd_kcontrol_new vx_control_output_switch = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "PCM Playback Switch",
 	.info =         vx_audio_sw_info,
 	.get =          vx_audio_sw_get,
 	.put =          vx_audio_sw_put
 };
-static struct snd_kcontrol_new vx_control_monitor_gain = {
+static const struct snd_kcontrol_new vx_control_monitor_gain = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Monitoring Volume",
 	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
@@ -744,7 +744,7 @@ static struct snd_kcontrol_new vx_control_monitor_gain = {
 	.put =          vx_audio_monitor_put,
 	.tlv = { .p = db_scale_audio_gain },
 };
-static struct snd_kcontrol_new vx_control_monitor_switch = {
+static const struct snd_kcontrol_new vx_control_monitor_switch = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Monitoring Switch",
 	.info =         vx_audio_sw_info,	/* shared */
@@ -805,7 +805,7 @@ static int vx_iec958_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_valu
 	return 0;
 }
 
-static struct snd_kcontrol_new vx_control_iec958_mask = {
+static const struct snd_kcontrol_new vx_control_iec958_mask = {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
@@ -813,7 +813,7 @@ static struct snd_kcontrol_new vx_control_iec958_mask = {
 	.get =		vx_iec958_mask_get,
 };
 
-static struct snd_kcontrol_new vx_control_iec958 = {
+static const struct snd_kcontrol_new vx_control_iec958 = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
 	.info =         vx_iec958_info,
@@ -878,7 +878,7 @@ static int vx_saturation_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 	return 0;
 }
 
-static struct snd_kcontrol_new vx_control_vu_meter = {
+static const struct snd_kcontrol_new vx_control_vu_meter = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
 	/* name will be filled later */
@@ -886,7 +886,7 @@ static struct snd_kcontrol_new vx_control_vu_meter = {
 	.get =		vx_vu_meter_get,
 };
 
-static struct snd_kcontrol_new vx_control_peak_meter = {
+static const struct snd_kcontrol_new vx_control_peak_meter = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
 	/* name will be filled later */
@@ -894,7 +894,7 @@ static struct snd_kcontrol_new vx_control_peak_meter = {
 	.get =		vx_peak_meter_get,
 };
 
-static struct snd_kcontrol_new vx_control_saturation = {
+static const struct snd_kcontrol_new vx_control_saturation = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"Input Saturation",
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,

commit 7f471fd40742a5d87d887375430bf40331cbbcf6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 20 18:11:58 2014 +0200

    ALSA: vx: Use snd_ctl_elem_info()
    
    ... and reduce the open codes.  Also add missing const to text arrays.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
index 3b6823fc0606..be9477e30739 100644
--- a/sound/drivers/vx/vx_mixer.c
+++ b/sound/drivers/vx/vx_mixer.c
@@ -471,30 +471,18 @@ static struct snd_kcontrol_new vx_control_output_level = {
  */
 static int vx_audio_src_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts_mic[3] = {
+	static const char * const texts_mic[3] = {
 		"Digital", "Line", "Mic"
 	};
-	static char *texts_vx2[2] = {
+	static const char * const texts_vx2[2] = {
 		"Digital", "Analog"
 	};
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	if (chip->type >= VX_TYPE_VXPOCKET) {
-		uinfo->value.enumerated.items = 3;
-		if (uinfo->value.enumerated.item > 2)
-			uinfo->value.enumerated.item = 2;
-		strcpy(uinfo->value.enumerated.name,
-		       texts_mic[uinfo->value.enumerated.item]);
-	} else {
-		uinfo->value.enumerated.items = 2;
-		if (uinfo->value.enumerated.item > 1)
-			uinfo->value.enumerated.item = 1;
-		strcpy(uinfo->value.enumerated.name,
-		       texts_vx2[uinfo->value.enumerated.item]);
-	}
-	return 0;
+	if (chip->type >= VX_TYPE_VXPOCKET)
+		return snd_ctl_enum_info(uinfo, 1, 3, texts_mic);
+	else
+		return snd_ctl_enum_info(uinfo, 1, 2, texts_vx2);
 }
 
 static int vx_audio_src_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
@@ -539,18 +527,11 @@ static struct snd_kcontrol_new vx_control_audio_src = {
  */
 static int vx_clock_mode_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[3] = {
+	static const char * const texts[3] = {
 		"Auto", "Internal", "External"
 	};
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 3;
-	if (uinfo->value.enumerated.item > 2)
-		uinfo->value.enumerated.item = 2;
-	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1, 3, texts);
 }
 
 static int vx_clock_mode_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)

commit db0a5214b8d6cc7a90ce3336d24a85b90cbb4e67
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 9 17:17:20 2014 +0200

    ALSA: vx: Use nonatomic PCM ops
    
    Rewrite VXpocket and VX222 drivers to use the new PCM nonatomic ops.
    The former irq tasklet is replaced with a threaded irq handler, and
    the tasklet for the PCM delayed start is simply merged into the normal
    PCM trigger, as well as the replacement of spinlock with mutex.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
index c71b8d148d7f..3b6823fc0606 100644
--- a/sound/drivers/vx/vx_mixer.c
+++ b/sound/drivers/vx/vx_mixer.c
@@ -32,17 +32,15 @@
  */
 static void vx_write_codec_reg(struct vx_core *chip, int codec, unsigned int data)
 {
-	unsigned long flags;
-
 	if (snd_BUG_ON(!chip->ops->write_codec))
 		return;
 
 	if (chip->chip_status & VX_STAT_IS_STALE)
 		return;
 
-	spin_lock_irqsave(&chip->lock, flags);
+	mutex_lock(&chip->lock);
 	chip->ops->write_codec(chip, codec, data);
-	spin_unlock_irqrestore(&chip->lock, flags);
+	mutex_unlock(&chip->lock);
 }
 
 /*
@@ -178,14 +176,12 @@ void vx_reset_codec(struct vx_core *chip, int cold_reset)
  */
 static void vx_change_audio_source(struct vx_core *chip, int src)
 {
-	unsigned long flags;
-
 	if (chip->chip_status & VX_STAT_IS_STALE)
 		return;
 
-	spin_lock_irqsave(&chip->lock, flags);
+	mutex_lock(&chip->lock);
 	chip->ops->change_audio_source(chip, src);
-	spin_unlock_irqrestore(&chip->lock, flags);
+	mutex_unlock(&chip->lock);
 }
 
 

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
index 5a347321f8c0..c71b8d148d7f 100644
--- a/sound/drivers/vx/vx_mixer.c
+++ b/sound/drivers/vx/vx_mixer.c
@@ -34,7 +34,8 @@ static void vx_write_codec_reg(struct vx_core *chip, int codec, unsigned int dat
 {
 	unsigned long flags;
 
-	snd_assert(chip->ops->write_codec, return);
+	if (snd_BUG_ON(!chip->ops->write_codec))
+		return;
 
 	if (chip->chip_status & VX_STAT_IS_STALE)
 		return;

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
index a37f0a8f17af..5a347321f8c0 100644
--- a/sound/drivers/vx/vx_mixer.c
+++ b/sound/drivers/vx/vx_mixer.c
@@ -20,7 +20,6 @@
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
-#include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/tlv.h>

commit d05ab185b770de96399766be6bcb5769ab99bc09
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 15 16:13:32 2007 +0100

    [ALSA] vxpocket - Check value range in ctl callbacks
    
    Check the value ranges in ctl put callbacks in vxpocket driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
index b8fcd79a7e11..a37f0a8f17af 100644
--- a/sound/drivers/vx/vx_mixer.c
+++ b/sound/drivers/vx/vx_mixer.c
@@ -439,14 +439,19 @@ static int vx_output_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_ele
 {
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int codec = kcontrol->id.index;
+	unsigned int val[2], vmax;
+
+	vmax = chip->hw->output_level_max;
+	val[0] = ucontrol->value.integer.value[0];
+	val[1] = ucontrol->value.integer.value[1];
+	if (val[0] > vmax || val[1] > vmax)
+		return -EINVAL;
 	mutex_lock(&chip->mixer_mutex);
-	if (ucontrol->value.integer.value[0] != chip->output_level[codec][0] ||
-	    ucontrol->value.integer.value[1] != chip->output_level[codec][1]) {
-		vx_set_analog_output_level(chip, codec,
-					   ucontrol->value.integer.value[0],
-					   ucontrol->value.integer.value[1]);
-		chip->output_level[codec][0] = ucontrol->value.integer.value[0];
-		chip->output_level[codec][1] = ucontrol->value.integer.value[1];
+	if (val[0] != chip->output_level[codec][0] ||
+	    val[1] != chip->output_level[codec][1]) {
+		vx_set_analog_output_level(chip, codec, val[0], val[1]);
+		chip->output_level[codec][0] = val[0];
+		chip->output_level[codec][1] = val[1];
 		mutex_unlock(&chip->mixer_mutex);
 		return 1;
 	}
@@ -506,6 +511,14 @@ static int vx_audio_src_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_v
 static int vx_audio_src_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
+
+	if (chip->type >= VX_TYPE_VXPOCKET) {
+		if (ucontrol->value.enumerated.item[0] > 2)
+			return -EINVAL;
+	} else {
+		if (ucontrol->value.enumerated.item[0] > 1)
+			return -EINVAL;
+	}
 	mutex_lock(&chip->mixer_mutex);
 	if (chip->audio_source_target != ucontrol->value.enumerated.item[0]) {
 		chip->audio_source_target = ucontrol->value.enumerated.item[0];
@@ -554,6 +567,9 @@ static int vx_clock_mode_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 static int vx_clock_mode_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
+
+	if (ucontrol->value.enumerated.item[0] > 2)
+		return -EINVAL;
 	mutex_lock(&chip->mixer_mutex);
 	if (chip->clock_mode != ucontrol->value.enumerated.item[0]) {
 		chip->clock_mode = ucontrol->value.enumerated.item[0];
@@ -603,12 +619,17 @@ static int vx_audio_gain_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 	int capture = (kcontrol->private_value >> 8) & 1;
+	unsigned int val[2];
 
+	val[0] = ucontrol->value.integer.value[0];
+	val[1] = ucontrol->value.integer.value[1];
+	if (val[0] > CVAL_MAX || val[1] > CVAL_MAX)
+		return -EINVAL;
 	mutex_lock(&chip->mixer_mutex);
-	if (ucontrol->value.integer.value[0] != chip->audio_gain[capture][audio] ||
-	    ucontrol->value.integer.value[1] != chip->audio_gain[capture][audio+1]) {
-		vx_set_audio_gain(chip, audio, capture, ucontrol->value.integer.value[0]);
-		vx_set_audio_gain(chip, audio+1, capture, ucontrol->value.integer.value[1]);
+	if (val[0] != chip->audio_gain[capture][audio] ||
+	    val[1] != chip->audio_gain[capture][audio+1]) {
+		vx_set_audio_gain(chip, audio, capture, val[0]);
+		vx_set_audio_gain(chip, audio+1, capture, val[1]);
 		mutex_unlock(&chip->mixer_mutex);
 		return 1;
 	}
@@ -632,13 +653,19 @@ static int vx_audio_monitor_put(struct snd_kcontrol *kcontrol, struct snd_ctl_el
 {
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
+	unsigned int val[2];
+
+	val[0] = ucontrol->value.integer.value[0];
+	val[1] = ucontrol->value.integer.value[1];
+	if (val[0] > CVAL_MAX || val[1] > CVAL_MAX)
+		return -EINVAL;
 
 	mutex_lock(&chip->mixer_mutex);
-	if (ucontrol->value.integer.value[0] != chip->audio_monitor[audio] ||
-	    ucontrol->value.integer.value[1] != chip->audio_monitor[audio+1]) {
-		vx_set_monitor_level(chip, audio, ucontrol->value.integer.value[0],
+	if (val[0] != chip->audio_monitor[audio] ||
+	    val[1] != chip->audio_monitor[audio+1]) {
+		vx_set_monitor_level(chip, audio, val[0],
 				     chip->audio_monitor_active[audio]);
-		vx_set_monitor_level(chip, audio+1, ucontrol->value.integer.value[1],
+		vx_set_monitor_level(chip, audio+1, val[1],
 				     chip->audio_monitor_active[audio+1]);
 		mutex_unlock(&chip->mixer_mutex);
 		return 1;
@@ -669,8 +696,10 @@ static int vx_audio_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_va
 	mutex_lock(&chip->mixer_mutex);
 	if (ucontrol->value.integer.value[0] != chip->audio_active[audio] ||
 	    ucontrol->value.integer.value[1] != chip->audio_active[audio+1]) {
-		vx_set_audio_switch(chip, audio, ucontrol->value.integer.value[0]);
-		vx_set_audio_switch(chip, audio+1, ucontrol->value.integer.value[1]);
+		vx_set_audio_switch(chip, audio,
+				    !!ucontrol->value.integer.value[0]);
+		vx_set_audio_switch(chip, audio+1,
+				    !!ucontrol->value.integer.value[1]);
 		mutex_unlock(&chip->mixer_mutex);
 		return 1;
 	}
@@ -699,9 +728,9 @@ static int vx_monitor_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 	if (ucontrol->value.integer.value[0] != chip->audio_monitor_active[audio] ||
 	    ucontrol->value.integer.value[1] != chip->audio_monitor_active[audio+1]) {
 		vx_set_monitor_level(chip, audio, chip->audio_monitor[audio],
-				     ucontrol->value.integer.value[0]);
+				     !!ucontrol->value.integer.value[0]);
 		vx_set_monitor_level(chip, audio+1, chip->audio_monitor[audio+1],
-				     ucontrol->value.integer.value[1]);
+				     !!ucontrol->value.integer.value[1]);
 		mutex_unlock(&chip->mixer_mutex);
 		return 1;
 	}

commit a5ce88909d3007caa7b65996a8f6784350beb2a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 23 15:42:26 2007 +0200

    [ALSA] Clean up with common snd_ctl_boolean_*_info callbacks
    
    Clean up codes using the new common snd_ctl_boolean_*_info() callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
index f63152a6a223..b8fcd79a7e11 100644
--- a/sound/drivers/vx/vx_mixer.c
+++ b/sound/drivers/vx/vx_mixer.c
@@ -647,14 +647,7 @@ static int vx_audio_monitor_put(struct snd_kcontrol *kcontrol, struct snd_ctl_el
 	return 0;
 }
 
-static int vx_audio_sw_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 2;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define vx_audio_sw_info	snd_ctl_boolean_stereo_info
 
 static int vx_audio_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
@@ -865,14 +858,7 @@ static int vx_peak_meter_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 	return 0;
 }
 
-static int vx_saturation_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 2;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define vx_saturation_info	snd_ctl_boolean_stereo_info
 
 static int vx_saturation_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {

commit 0cb29ea0d449d7c0ecc9649a08ab63476389701d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 29 15:33:49 2007 +0100

    [ALSA] Add even more 'const' to everything related to TLV
    
    Mark TLV data as 'const'
    Signed-of-by: Philipp Matthias Hahn <pmhahn@pmhahn.de>
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
index 1613ed844ac6..f63152a6a223 100644
--- a/sound/drivers/vx/vx_mixer.c
+++ b/sound/drivers/vx/vx_mixer.c
@@ -716,7 +716,7 @@ static int vx_monitor_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 	return 0;
 }
 
-static DECLARE_TLV_DB_SCALE(db_scale_audio_gain, -10975, 25, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_audio_gain, -10975, 25, 0);
 
 static struct snd_kcontrol_new vx_control_audio_gain = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,

commit 1186ed8c7dc9c0185e783beddf241509cc224f1a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 23 19:53:28 2006 +0200

    [ALSA] Add dB scale information to vxpocket and vx222 drivers
    
    Added the dB scale information to vxpocket and vx222 drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
index c1d7fcdd1973..1613ed844ac6 100644
--- a/sound/drivers/vx/vx_mixer.c
+++ b/sound/drivers/vx/vx_mixer.c
@@ -23,6 +23,7 @@
 #include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/vx_core.h>
 #include "vx_cmd.h"
 
@@ -455,10 +456,13 @@ static int vx_output_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_ele
 
 static struct snd_kcontrol_new vx_control_output_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.name =		"Master Playback Volume",
 	.info =		vx_output_level_info,
 	.get =		vx_output_level_get,
 	.put =		vx_output_level_put,
+	/* tlv will be filled later */
 };
 
 /*
@@ -712,12 +716,17 @@ static int vx_monitor_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 	return 0;
 }
 
+static DECLARE_TLV_DB_SCALE(db_scale_audio_gain, -10975, 25, 0);
+
 static struct snd_kcontrol_new vx_control_audio_gain = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	/* name will be filled later */
 	.info =         vx_audio_gain_info,
 	.get =          vx_audio_gain_get,
-	.put =          vx_audio_gain_put
+	.put =          vx_audio_gain_put,
+	.tlv = { .p = db_scale_audio_gain },
 };
 static struct snd_kcontrol_new vx_control_output_switch = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -729,9 +738,12 @@ static struct snd_kcontrol_new vx_control_output_switch = {
 static struct snd_kcontrol_new vx_control_monitor_gain = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Monitoring Volume",
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_TLV_READ),
 	.info =         vx_audio_gain_info,	/* shared */
 	.get =          vx_audio_monitor_get,
-	.put =          vx_audio_monitor_put
+	.put =          vx_audio_monitor_put,
+	.tlv = { .p = db_scale_audio_gain },
 };
 static struct snd_kcontrol_new vx_control_monitor_switch = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -918,6 +930,7 @@ int snd_vx_mixer_new(struct vx_core *chip)
 	for (i = 0; i < chip->hw->num_outs; i++) {
 		temp = vx_control_output_level;
 		temp.index = i;
+		temp.tlv.p = chip->hw->output_level_db_scale;
 		if ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)
 			return err;
 	}

commit ef9f0a42db987e7e2df72289fb4522d24027786b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:31:42 2006 +0100

    [ALSA] semaphore -> mutex (driver part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
index 8ec2c605d2f0..c1d7fcdd1973 100644
--- a/sound/drivers/vx/vx_mixer.c
+++ b/sound/drivers/vx/vx_mixer.c
@@ -427,10 +427,10 @@ static int vx_output_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_ele
 {
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int codec = kcontrol->id.index;
-	down(&chip->mixer_mutex);
+	mutex_lock(&chip->mixer_mutex);
 	ucontrol->value.integer.value[0] = chip->output_level[codec][0];
 	ucontrol->value.integer.value[1] = chip->output_level[codec][1];
-	up(&chip->mixer_mutex);
+	mutex_unlock(&chip->mixer_mutex);
 	return 0;
 }
 
@@ -438,7 +438,7 @@ static int vx_output_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_ele
 {
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int codec = kcontrol->id.index;
-	down(&chip->mixer_mutex);
+	mutex_lock(&chip->mixer_mutex);
 	if (ucontrol->value.integer.value[0] != chip->output_level[codec][0] ||
 	    ucontrol->value.integer.value[1] != chip->output_level[codec][1]) {
 		vx_set_analog_output_level(chip, codec,
@@ -446,10 +446,10 @@ static int vx_output_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_ele
 					   ucontrol->value.integer.value[1]);
 		chip->output_level[codec][0] = ucontrol->value.integer.value[0];
 		chip->output_level[codec][1] = ucontrol->value.integer.value[1];
-		up(&chip->mixer_mutex);
+		mutex_unlock(&chip->mixer_mutex);
 		return 1;
 	}
-	up(&chip->mixer_mutex);
+	mutex_unlock(&chip->mixer_mutex);
 	return 0;
 }
 
@@ -502,14 +502,14 @@ static int vx_audio_src_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_v
 static int vx_audio_src_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
-	down(&chip->mixer_mutex);
+	mutex_lock(&chip->mixer_mutex);
 	if (chip->audio_source_target != ucontrol->value.enumerated.item[0]) {
 		chip->audio_source_target = ucontrol->value.enumerated.item[0];
 		vx_sync_audio_source(chip);
-		up(&chip->mixer_mutex);
+		mutex_unlock(&chip->mixer_mutex);
 		return 1;
 	}
-	up(&chip->mixer_mutex);
+	mutex_unlock(&chip->mixer_mutex);
 	return 0;
 }
 
@@ -550,14 +550,14 @@ static int vx_clock_mode_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 static int vx_clock_mode_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
-	down(&chip->mixer_mutex);
+	mutex_lock(&chip->mixer_mutex);
 	if (chip->clock_mode != ucontrol->value.enumerated.item[0]) {
 		chip->clock_mode = ucontrol->value.enumerated.item[0];
 		vx_set_clock(chip, chip->freq);
-		up(&chip->mixer_mutex);
+		mutex_unlock(&chip->mixer_mutex);
 		return 1;
 	}
-	up(&chip->mixer_mutex);
+	mutex_unlock(&chip->mixer_mutex);
 	return 0;
 }
 
@@ -587,10 +587,10 @@ static int vx_audio_gain_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 	int audio = kcontrol->private_value & 0xff;
 	int capture = (kcontrol->private_value >> 8) & 1;
 
-	down(&chip->mixer_mutex);
+	mutex_lock(&chip->mixer_mutex);
 	ucontrol->value.integer.value[0] = chip->audio_gain[capture][audio];
 	ucontrol->value.integer.value[1] = chip->audio_gain[capture][audio+1];
-	up(&chip->mixer_mutex);
+	mutex_unlock(&chip->mixer_mutex);
 	return 0;
 }
 
@@ -600,15 +600,15 @@ static int vx_audio_gain_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 	int audio = kcontrol->private_value & 0xff;
 	int capture = (kcontrol->private_value >> 8) & 1;
 
-	down(&chip->mixer_mutex);
+	mutex_lock(&chip->mixer_mutex);
 	if (ucontrol->value.integer.value[0] != chip->audio_gain[capture][audio] ||
 	    ucontrol->value.integer.value[1] != chip->audio_gain[capture][audio+1]) {
 		vx_set_audio_gain(chip, audio, capture, ucontrol->value.integer.value[0]);
 		vx_set_audio_gain(chip, audio+1, capture, ucontrol->value.integer.value[1]);
-		up(&chip->mixer_mutex);
+		mutex_unlock(&chip->mixer_mutex);
 		return 1;
 	}
-	up(&chip->mixer_mutex);
+	mutex_unlock(&chip->mixer_mutex);
 	return 0;
 }
 
@@ -617,10 +617,10 @@ static int vx_audio_monitor_get(struct snd_kcontrol *kcontrol, struct snd_ctl_el
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 
-	down(&chip->mixer_mutex);
+	mutex_lock(&chip->mixer_mutex);
 	ucontrol->value.integer.value[0] = chip->audio_monitor[audio];
 	ucontrol->value.integer.value[1] = chip->audio_monitor[audio+1];
-	up(&chip->mixer_mutex);
+	mutex_unlock(&chip->mixer_mutex);
 	return 0;
 }
 
@@ -629,17 +629,17 @@ static int vx_audio_monitor_put(struct snd_kcontrol *kcontrol, struct snd_ctl_el
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 
-	down(&chip->mixer_mutex);
+	mutex_lock(&chip->mixer_mutex);
 	if (ucontrol->value.integer.value[0] != chip->audio_monitor[audio] ||
 	    ucontrol->value.integer.value[1] != chip->audio_monitor[audio+1]) {
 		vx_set_monitor_level(chip, audio, ucontrol->value.integer.value[0],
 				     chip->audio_monitor_active[audio]);
 		vx_set_monitor_level(chip, audio+1, ucontrol->value.integer.value[1],
 				     chip->audio_monitor_active[audio+1]);
-		up(&chip->mixer_mutex);
+		mutex_unlock(&chip->mixer_mutex);
 		return 1;
 	}
-	up(&chip->mixer_mutex);
+	mutex_unlock(&chip->mixer_mutex);
 	return 0;
 }
 
@@ -657,10 +657,10 @@ static int vx_audio_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_va
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 
-	down(&chip->mixer_mutex);
+	mutex_lock(&chip->mixer_mutex);
 	ucontrol->value.integer.value[0] = chip->audio_active[audio];
 	ucontrol->value.integer.value[1] = chip->audio_active[audio+1];
-	up(&chip->mixer_mutex);
+	mutex_unlock(&chip->mixer_mutex);
 	return 0;
 }
 
@@ -669,15 +669,15 @@ static int vx_audio_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_va
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 
-	down(&chip->mixer_mutex);
+	mutex_lock(&chip->mixer_mutex);
 	if (ucontrol->value.integer.value[0] != chip->audio_active[audio] ||
 	    ucontrol->value.integer.value[1] != chip->audio_active[audio+1]) {
 		vx_set_audio_switch(chip, audio, ucontrol->value.integer.value[0]);
 		vx_set_audio_switch(chip, audio+1, ucontrol->value.integer.value[1]);
-		up(&chip->mixer_mutex);
+		mutex_unlock(&chip->mixer_mutex);
 		return 1;
 	}
-	up(&chip->mixer_mutex);
+	mutex_unlock(&chip->mixer_mutex);
 	return 0;
 }
 
@@ -686,10 +686,10 @@ static int vx_monitor_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 
-	down(&chip->mixer_mutex);
+	mutex_lock(&chip->mixer_mutex);
 	ucontrol->value.integer.value[0] = chip->audio_monitor_active[audio];
 	ucontrol->value.integer.value[1] = chip->audio_monitor_active[audio+1];
-	up(&chip->mixer_mutex);
+	mutex_unlock(&chip->mixer_mutex);
 	return 0;
 }
 
@@ -698,17 +698,17 @@ static int vx_monitor_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 
-	down(&chip->mixer_mutex);
+	mutex_lock(&chip->mixer_mutex);
 	if (ucontrol->value.integer.value[0] != chip->audio_monitor_active[audio] ||
 	    ucontrol->value.integer.value[1] != chip->audio_monitor_active[audio+1]) {
 		vx_set_monitor_level(chip, audio, chip->audio_monitor[audio],
 				     ucontrol->value.integer.value[0]);
 		vx_set_monitor_level(chip, audio+1, chip->audio_monitor[audio+1],
 				     ucontrol->value.integer.value[1]);
-		up(&chip->mixer_mutex);
+		mutex_unlock(&chip->mixer_mutex);
 		return 1;
 	}
-	up(&chip->mixer_mutex);
+	mutex_unlock(&chip->mixer_mutex);
 	return 0;
 }
 
@@ -756,12 +756,12 @@ static int vx_iec958_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_valu
 {
 	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 
-	down(&chip->mixer_mutex);
+	mutex_lock(&chip->mixer_mutex);
 	ucontrol->value.iec958.status[0] = (chip->uer_bits >> 0) & 0xff;
 	ucontrol->value.iec958.status[1] = (chip->uer_bits >> 8) & 0xff;
 	ucontrol->value.iec958.status[2] = (chip->uer_bits >> 16) & 0xff;
 	ucontrol->value.iec958.status[3] = (chip->uer_bits >> 24) & 0xff;
-	up(&chip->mixer_mutex);
+	mutex_unlock(&chip->mixer_mutex);
         return 0;
 }
 
@@ -783,14 +783,14 @@ static int vx_iec958_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_valu
 	      (ucontrol->value.iec958.status[1] << 8) |
 	      (ucontrol->value.iec958.status[2] << 16) |
 	      (ucontrol->value.iec958.status[3] << 24);
-	down(&chip->mixer_mutex);
+	mutex_lock(&chip->mixer_mutex);
 	if (chip->uer_bits != val) {
 		chip->uer_bits = val;
 		vx_set_iec958_status(chip, val);
-		up(&chip->mixer_mutex);
+		mutex_unlock(&chip->mixer_mutex);
 		return 1;
 	}
-	up(&chip->mixer_mutex);
+	mutex_unlock(&chip->mixer_mutex);
 	return 0;
 }
 

commit af26367f69a474ed809e4a59abb5855b47daaff4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:46:59 2005 +0100

    [ALSA] Remove xxx_t typedefs: VXdriver
    
    Remove xxx_t typedefs from the VXdriver codes
    (vx_core support, vx222 and vxpocket).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
index 19fc68c23378..8ec2c605d2f0 100644
--- a/sound/drivers/vx/vx_mixer.c
+++ b/sound/drivers/vx/vx_mixer.c
@@ -30,7 +30,7 @@
 /*
  * write a codec data (24bit)
  */
-static void vx_write_codec_reg(vx_core_t *chip, int codec, unsigned int data)
+static void vx_write_codec_reg(struct vx_core *chip, int codec, unsigned int data)
 {
 	unsigned long flags;
 
@@ -47,7 +47,7 @@ static void vx_write_codec_reg(vx_core_t *chip, int codec, unsigned int data)
 /*
  * Data type used to access the Codec
  */
-typedef union {
+union vx_codec_data {
 	u32 l;
 #ifdef SNDRV_BIG_ENDIAN
 	struct w {
@@ -72,7 +72,7 @@ typedef union {
 		u8 hh;
 	} b;
 #endif
-} vx_codec_data_t;
+};
 
 #define SET_CDC_DATA_SEL(di,s)          ((di).b.mh = (u8) (s))
 #define SET_CDC_DATA_REG(di,r)          ((di).b.ml = (u8) (r))
@@ -85,9 +85,9 @@ typedef union {
  * @reg: register index
  * @val: data value
  */
-static void vx_set_codec_reg(vx_core_t *chip, int codec, int reg, int val)
+static void vx_set_codec_reg(struct vx_core *chip, int codec, int reg, int val)
 {
-	vx_codec_data_t data;
+	union vx_codec_data data;
 	/* DAC control register */
 	SET_CDC_DATA_INIT(data);
 	SET_CDC_DATA_REG(data, reg);
@@ -102,7 +102,7 @@ static void vx_set_codec_reg(vx_core_t *chip, int codec, int reg, int val)
  * @left: left output level, 0 = mute
  * @right: right output level
  */
-static void vx_set_analog_output_level(vx_core_t *chip, int codec, int left, int right)
+static void vx_set_analog_output_level(struct vx_core *chip, int codec, int left, int right)
 {
 	left  = chip->hw->output_level_max - left;
 	right = chip->hw->output_level_max - right;
@@ -126,7 +126,7 @@ static void vx_set_analog_output_level(vx_core_t *chip, int codec, int left, int
 #define DAC_ATTEN_MIN	0x08
 #define DAC_ATTEN_MAX	0x38
 
-void vx_toggle_dac_mute(vx_core_t *chip, int mute)
+void vx_toggle_dac_mute(struct vx_core *chip, int mute)
 {
 	unsigned int i;
 	for (i = 0; i < chip->hw->num_codecs; i++) {
@@ -141,7 +141,7 @@ void vx_toggle_dac_mute(vx_core_t *chip, int mute)
 /*
  * vx_reset_codec - reset and initialize the codecs
  */
-void vx_reset_codec(vx_core_t *chip, int cold_reset)
+void vx_reset_codec(struct vx_core *chip, int cold_reset)
 {
 	unsigned int i;
 	int port = chip->type >= VX_TYPE_VXPOCKET ? 0x75 : 0x65;
@@ -175,7 +175,7 @@ void vx_reset_codec(vx_core_t *chip, int cold_reset)
  * change the audio input source
  * @src: the target source (VX_AUDIO_SRC_XXX)
  */
-static void vx_change_audio_source(vx_core_t *chip, int src)
+static void vx_change_audio_source(struct vx_core *chip, int src)
 {
 	unsigned long flags;
 
@@ -192,7 +192,7 @@ static void vx_change_audio_source(vx_core_t *chip, int src)
  * change the audio source if necessary and possible
  * returns 1 if the source is actually changed.
  */
-int vx_sync_audio_source(vx_core_t *chip)
+int vx_sync_audio_source(struct vx_core *chip)
 {
 	if (chip->audio_source_target == chip->audio_source ||
 	    chip->pcm_running)
@@ -217,7 +217,7 @@ struct vx_audio_level {
 	short monitor_level;
 };
 
-static int vx_adjust_audio_level(vx_core_t *chip, int audio, int capture,
+static int vx_adjust_audio_level(struct vx_core *chip, int audio, int capture,
 				 struct vx_audio_level *info)
 {
 	struct vx_rmh rmh;
@@ -256,7 +256,7 @@ static int vx_adjust_audio_level(vx_core_t *chip, int audio, int capture,
 
     
 #if 0 // not used
-static int vx_read_audio_level(vx_core_t *chip, int audio, int capture,
+static int vx_read_audio_level(struct vx_core *chip, int audio, int capture,
 			       struct vx_audio_level *info)
 {
 	int err;
@@ -283,7 +283,7 @@ static int vx_read_audio_level(vx_core_t *chip, int audio, int capture,
  * set the monitoring level and mute state of the given audio
  * no more static, because must be called from vx_pcm to demute monitoring
  */
-int vx_set_monitor_level(vx_core_t *chip, int audio, int level, int active)
+int vx_set_monitor_level(struct vx_core *chip, int audio, int level, int active)
 {
 	struct vx_audio_level info;
 
@@ -301,7 +301,7 @@ int vx_set_monitor_level(vx_core_t *chip, int audio, int level, int active)
 /*
  * set the mute status of the given audio
  */
-static int vx_set_audio_switch(vx_core_t *chip, int audio, int active)
+static int vx_set_audio_switch(struct vx_core *chip, int audio, int active)
 {
 	struct vx_audio_level info;
 
@@ -315,7 +315,7 @@ static int vx_set_audio_switch(vx_core_t *chip, int audio, int active)
 /*
  * set the mute status of the given audio
  */
-static int vx_set_audio_gain(vx_core_t *chip, int audio, int capture, int level)
+static int vx_set_audio_gain(struct vx_core *chip, int audio, int capture, int level)
 {
 	struct vx_audio_level info;
 
@@ -329,7 +329,7 @@ static int vx_set_audio_gain(vx_core_t *chip, int audio, int capture, int level)
 /*
  * reset all audio levels
  */
-static void vx_reset_audio_levels(vx_core_t *chip)
+static void vx_reset_audio_levels(struct vx_core *chip)
 {
 	unsigned int i, c;
 	struct vx_audio_level info;
@@ -375,7 +375,7 @@ struct vx_vu_meter {
  * @capture: 0 = playback, 1 = capture operation
  * @info: the array of vx_vu_meter records (size = 2).
  */
-static int vx_get_audio_vu_meter(vx_core_t *chip, int audio, int capture, struct vx_vu_meter *info)
+static int vx_get_audio_vu_meter(struct vx_core *chip, int audio, int capture, struct vx_vu_meter *info)
 {
 	struct vx_rmh rmh;
 	int i, err;
@@ -413,9 +413,9 @@ static int vx_get_audio_vu_meter(vx_core_t *chip, int audio, int capture, struct
 /*
  * output level control
  */
-static int vx_output_level_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int vx_output_level_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
 	uinfo->value.integer.min = 0;
@@ -423,9 +423,9 @@ static int vx_output_level_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *u
 	return 0;
 }
 
-static int vx_output_level_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_output_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int codec = kcontrol->id.index;
 	down(&chip->mixer_mutex);
 	ucontrol->value.integer.value[0] = chip->output_level[codec][0];
@@ -434,9 +434,9 @@ static int vx_output_level_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *u
 	return 0;
 }
 
-static int vx_output_level_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_output_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int codec = kcontrol->id.index;
 	down(&chip->mixer_mutex);
 	if (ucontrol->value.integer.value[0] != chip->output_level[codec][0] ||
@@ -453,7 +453,7 @@ static int vx_output_level_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *u
 	return 0;
 }
 
-static snd_kcontrol_new_t vx_control_output_level = {
+static struct snd_kcontrol_new vx_control_output_level = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"Master Playback Volume",
 	.info =		vx_output_level_info,
@@ -464,7 +464,7 @@ static snd_kcontrol_new_t vx_control_output_level = {
 /*
  * audio source select
  */
-static int vx_audio_src_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int vx_audio_src_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts_mic[3] = {
 		"Digital", "Line", "Mic"
@@ -472,7 +472,7 @@ static int vx_audio_src_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinf
 	static char *texts_vx2[2] = {
 		"Digital", "Analog"
 	};
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
@@ -492,16 +492,16 @@ static int vx_audio_src_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinf
 	return 0;
 }
 
-static int vx_audio_src_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_audio_src_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	ucontrol->value.enumerated.item[0] = chip->audio_source_target;
 	return 0;
 }
 
-static int vx_audio_src_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_audio_src_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	down(&chip->mixer_mutex);
 	if (chip->audio_source_target != ucontrol->value.enumerated.item[0]) {
 		chip->audio_source_target = ucontrol->value.enumerated.item[0];
@@ -513,7 +513,7 @@ static int vx_audio_src_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucon
 	return 0;
 }
 
-static snd_kcontrol_new_t vx_control_audio_src = {
+static struct snd_kcontrol_new vx_control_audio_src = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"Capture Source",
 	.info =		vx_audio_src_info,
@@ -524,7 +524,7 @@ static snd_kcontrol_new_t vx_control_audio_src = {
 /*
  * clock mode selection
  */
-static int vx_clock_mode_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int vx_clock_mode_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[3] = {
 		"Auto", "Internal", "External"
@@ -540,16 +540,16 @@ static int vx_clock_mode_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uin
 	return 0;
 }
 
-static int vx_clock_mode_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_clock_mode_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	ucontrol->value.enumerated.item[0] = chip->clock_mode;
 	return 0;
 }
 
-static int vx_clock_mode_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_clock_mode_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	down(&chip->mixer_mutex);
 	if (chip->clock_mode != ucontrol->value.enumerated.item[0]) {
 		chip->clock_mode = ucontrol->value.enumerated.item[0];
@@ -561,7 +561,7 @@ static int vx_clock_mode_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *uco
 	return 0;
 }
 
-static snd_kcontrol_new_t vx_control_clock_mode = {
+static struct snd_kcontrol_new vx_control_clock_mode = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"Clock Mode",
 	.info =		vx_clock_mode_info,
@@ -572,7 +572,7 @@ static snd_kcontrol_new_t vx_control_clock_mode = {
 /*
  * Audio Gain
  */
-static int vx_audio_gain_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int vx_audio_gain_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
@@ -581,9 +581,9 @@ static int vx_audio_gain_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uin
 	return 0;
 }
 
-static int vx_audio_gain_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_audio_gain_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 	int capture = (kcontrol->private_value >> 8) & 1;
 
@@ -594,9 +594,9 @@ static int vx_audio_gain_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *uco
 	return 0;
 }
 
-static int vx_audio_gain_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_audio_gain_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 	int capture = (kcontrol->private_value >> 8) & 1;
 
@@ -612,9 +612,9 @@ static int vx_audio_gain_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *uco
 	return 0;
 }
 
-static int vx_audio_monitor_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_audio_monitor_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 
 	down(&chip->mixer_mutex);
@@ -624,9 +624,9 @@ static int vx_audio_monitor_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *
 	return 0;
 }
 
-static int vx_audio_monitor_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_audio_monitor_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 
 	down(&chip->mixer_mutex);
@@ -643,7 +643,7 @@ static int vx_audio_monitor_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *
 	return 0;
 }
 
-static int vx_audio_sw_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int vx_audio_sw_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 2;
@@ -652,9 +652,9 @@ static int vx_audio_sw_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo
 	return 0;
 }
 
-static int vx_audio_sw_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_audio_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 
 	down(&chip->mixer_mutex);
@@ -664,9 +664,9 @@ static int vx_audio_sw_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucont
 	return 0;
 }
 
-static int vx_audio_sw_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_audio_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 
 	down(&chip->mixer_mutex);
@@ -681,9 +681,9 @@ static int vx_audio_sw_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucont
 	return 0;
 }
 
-static int vx_monitor_sw_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_monitor_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 
 	down(&chip->mixer_mutex);
@@ -693,9 +693,9 @@ static int vx_monitor_sw_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *uco
 	return 0;
 }
 
-static int vx_monitor_sw_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_monitor_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	int audio = kcontrol->private_value & 0xff;
 
 	down(&chip->mixer_mutex);
@@ -712,28 +712,28 @@ static int vx_monitor_sw_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *uco
 	return 0;
 }
 
-static snd_kcontrol_new_t vx_control_audio_gain = {
+static struct snd_kcontrol_new vx_control_audio_gain = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	/* name will be filled later */
 	.info =         vx_audio_gain_info,
 	.get =          vx_audio_gain_get,
 	.put =          vx_audio_gain_put
 };
-static snd_kcontrol_new_t vx_control_output_switch = {
+static struct snd_kcontrol_new vx_control_output_switch = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "PCM Playback Switch",
 	.info =         vx_audio_sw_info,
 	.get =          vx_audio_sw_get,
 	.put =          vx_audio_sw_put
 };
-static snd_kcontrol_new_t vx_control_monitor_gain = {
+static struct snd_kcontrol_new vx_control_monitor_gain = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Monitoring Volume",
 	.info =         vx_audio_gain_info,	/* shared */
 	.get =          vx_audio_monitor_get,
 	.put =          vx_audio_monitor_put
 };
-static snd_kcontrol_new_t vx_control_monitor_switch = {
+static struct snd_kcontrol_new vx_control_monitor_switch = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Monitoring Switch",
 	.info =         vx_audio_sw_info,	/* shared */
@@ -745,16 +745,16 @@ static snd_kcontrol_new_t vx_control_monitor_switch = {
 /*
  * IEC958 status bits
  */
-static int vx_iec958_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int vx_iec958_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int vx_iec958_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_iec958_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 
 	down(&chip->mixer_mutex);
 	ucontrol->value.iec958.status[0] = (chip->uer_bits >> 0) & 0xff;
@@ -765,7 +765,7 @@ static int vx_iec958_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontro
         return 0;
 }
 
-static int vx_iec958_mask_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_iec958_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
 	ucontrol->value.iec958.status[0] = 0xff;
 	ucontrol->value.iec958.status[1] = 0xff;
@@ -774,9 +774,9 @@ static int vx_iec958_mask_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t *u
         return 0;
 }
 
-static int vx_iec958_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_iec958_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 
 	val = (ucontrol->value.iec958.status[0] << 0) |
@@ -794,7 +794,7 @@ static int vx_iec958_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontro
 	return 0;
 }
 
-static snd_kcontrol_new_t vx_control_iec958_mask = {
+static struct snd_kcontrol_new vx_control_iec958_mask = {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
@@ -802,7 +802,7 @@ static snd_kcontrol_new_t vx_control_iec958_mask = {
 	.get =		vx_iec958_mask_get,
 };
 
-static snd_kcontrol_new_t vx_control_iec958 = {
+static struct snd_kcontrol_new vx_control_iec958 = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
 	.info =         vx_iec958_info,
@@ -818,7 +818,7 @@ static snd_kcontrol_new_t vx_control_iec958 = {
 #define METER_MAX	0xff
 #define METER_SHIFT	16
 
-static int vx_vu_meter_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int vx_vu_meter_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
@@ -827,9 +827,9 @@ static int vx_vu_meter_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo
 	return 0;
 }
 
-static int vx_vu_meter_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_vu_meter_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	struct vx_vu_meter meter[2];
 	int audio = kcontrol->private_value & 0xff;
 	int capture = (kcontrol->private_value >> 8) & 1;
@@ -840,9 +840,9 @@ static int vx_vu_meter_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucont
 	return 0;
 }
 
-static int vx_peak_meter_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_peak_meter_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	struct vx_vu_meter meter[2];
 	int audio = kcontrol->private_value & 0xff;
 	int capture = (kcontrol->private_value >> 8) & 1;
@@ -853,7 +853,7 @@ static int vx_peak_meter_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *uco
 	return 0;
 }
 
-static int vx_saturation_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int vx_saturation_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 2;
@@ -862,9 +862,9 @@ static int vx_saturation_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uin
 	return 0;
 }
 
-static int vx_saturation_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int vx_saturation_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_core *chip = snd_kcontrol_chip(kcontrol);
 	struct vx_vu_meter meter[2];
 	int audio = kcontrol->private_value & 0xff;
 
@@ -874,7 +874,7 @@ static int vx_saturation_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *uco
 	return 0;
 }
 
-static snd_kcontrol_new_t vx_control_vu_meter = {
+static struct snd_kcontrol_new vx_control_vu_meter = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
 	/* name will be filled later */
@@ -882,7 +882,7 @@ static snd_kcontrol_new_t vx_control_vu_meter = {
 	.get =		vx_vu_meter_get,
 };
 
-static snd_kcontrol_new_t vx_control_peak_meter = {
+static struct snd_kcontrol_new vx_control_peak_meter = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
 	/* name will be filled later */
@@ -890,7 +890,7 @@ static snd_kcontrol_new_t vx_control_peak_meter = {
 	.get =		vx_peak_meter_get,
 };
 
-static snd_kcontrol_new_t vx_control_saturation = {
+static struct snd_kcontrol_new vx_control_saturation = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"Input Saturation",
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
@@ -904,12 +904,12 @@ static snd_kcontrol_new_t vx_control_saturation = {
  *
  */
 
-int snd_vx_mixer_new(vx_core_t *chip)
+int snd_vx_mixer_new(struct vx_core *chip)
 {
 	unsigned int i, c;
 	int err;
-	snd_kcontrol_new_t temp;
-	snd_card_t *card = chip->card;
+	struct snd_kcontrol_new temp;
+	struct snd_card *card = chip->card;
 	char name[32];
 
 	strcpy(card->mixername, card->driver);

commit 5549d54992391d81a8cbfbaac45a958876fbc9cb
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Aug 3 13:50:30 2005 +0200

    [ALSA] use PCM interface for IEC958 controls
    
    Digigram VX core,ENS1370/1+ driver,CA0106 driver,EMU10K1/EMU10K2 driver
    RME HDSP driver,RME9652 driver
    For consistency, use the PCM interface instead of MIXER for IEC958
    default/mask/stream mixer controls.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
index f00c88886460..19fc68c23378 100644
--- a/sound/drivers/vx/vx_mixer.c
+++ b/sound/drivers/vx/vx_mixer.c
@@ -796,14 +796,14 @@ static int vx_iec958_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontro
 
 static snd_kcontrol_new_t vx_control_iec958_mask = {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
-	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
 	.info =		vx_iec958_info,	/* shared */
 	.get =		vx_iec958_mask_get,
 };
 
 static snd_kcontrol_new_t vx_control_iec958 = {
-	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
 	.info =         vx_iec958_info,
 	.get =          vx_iec958_get,

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/drivers/vx/vx_mixer.c b/sound/drivers/vx/vx_mixer.c
new file mode 100644
index 000000000000..f00c88886460
--- /dev/null
+++ b/sound/drivers/vx/vx_mixer.c
@@ -0,0 +1,1000 @@
+/*
+ * Driver for Digigram VX soundcards
+ *
+ * Common mixer part
+ *
+ * Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/vx_core.h>
+#include "vx_cmd.h"
+
+
+/*
+ * write a codec data (24bit)
+ */
+static void vx_write_codec_reg(vx_core_t *chip, int codec, unsigned int data)
+{
+	unsigned long flags;
+
+	snd_assert(chip->ops->write_codec, return);
+
+	if (chip->chip_status & VX_STAT_IS_STALE)
+		return;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	chip->ops->write_codec(chip, codec, data);
+	spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+/*
+ * Data type used to access the Codec
+ */
+typedef union {
+	u32 l;
+#ifdef SNDRV_BIG_ENDIAN
+	struct w {
+		u16 h;
+		u16 l;
+	} w;
+	struct b {
+		u8 hh;
+		u8 mh;
+		u8 ml;
+		u8 ll;
+	} b;
+#else /* LITTLE_ENDIAN */
+	struct w {
+		u16 l;
+		u16 h;
+	} w;
+	struct b {
+		u8 ll;
+		u8 ml;
+		u8 mh;
+		u8 hh;
+	} b;
+#endif
+} vx_codec_data_t;
+
+#define SET_CDC_DATA_SEL(di,s)          ((di).b.mh = (u8) (s))
+#define SET_CDC_DATA_REG(di,r)          ((di).b.ml = (u8) (r))
+#define SET_CDC_DATA_VAL(di,d)          ((di).b.ll = (u8) (d))
+#define SET_CDC_DATA_INIT(di)           ((di).l = 0L, SET_CDC_DATA_SEL(di,XX_CODEC_SELECTOR))
+
+/*
+ * set up codec register and write the value
+ * @codec: the codec id, 0 or 1
+ * @reg: register index
+ * @val: data value
+ */
+static void vx_set_codec_reg(vx_core_t *chip, int codec, int reg, int val)
+{
+	vx_codec_data_t data;
+	/* DAC control register */
+	SET_CDC_DATA_INIT(data);
+	SET_CDC_DATA_REG(data, reg);
+	SET_CDC_DATA_VAL(data, val);
+	vx_write_codec_reg(chip, codec, data.l);
+}
+
+
+/*
+ * vx_set_analog_output_level - set the output attenuation level
+ * @codec: the output codec, 0 or 1.  (1 for VXP440 only)
+ * @left: left output level, 0 = mute
+ * @right: right output level
+ */
+static void vx_set_analog_output_level(vx_core_t *chip, int codec, int left, int right)
+{
+	left  = chip->hw->output_level_max - left;
+	right = chip->hw->output_level_max - right;
+
+	if (chip->ops->akm_write) {
+		chip->ops->akm_write(chip, XX_CODEC_LEVEL_LEFT_REGISTER, left);
+		chip->ops->akm_write(chip, XX_CODEC_LEVEL_RIGHT_REGISTER, right);
+	} else {
+		/* convert to attenuation level: 0 = 0dB (max), 0xe3 = -113.5 dB (min) */
+		vx_set_codec_reg(chip, codec, XX_CODEC_LEVEL_LEFT_REGISTER, left);
+		vx_set_codec_reg(chip, codec, XX_CODEC_LEVEL_RIGHT_REGISTER, right);
+	}
+}
+
+
+/*
+ * vx_toggle_dac_mute -  mute/unmute DAC
+ * @mute: 0 = unmute, 1 = mute
+ */
+
+#define DAC_ATTEN_MIN	0x08
+#define DAC_ATTEN_MAX	0x38
+
+void vx_toggle_dac_mute(vx_core_t *chip, int mute)
+{
+	unsigned int i;
+	for (i = 0; i < chip->hw->num_codecs; i++) {
+		if (chip->ops->akm_write)
+			chip->ops->akm_write(chip, XX_CODEC_DAC_CONTROL_REGISTER, mute); /* XXX */
+		else
+			vx_set_codec_reg(chip, i, XX_CODEC_DAC_CONTROL_REGISTER,
+					 mute ? DAC_ATTEN_MAX : DAC_ATTEN_MIN);
+	}
+}
+
+/*
+ * vx_reset_codec - reset and initialize the codecs
+ */
+void vx_reset_codec(vx_core_t *chip, int cold_reset)
+{
+	unsigned int i;
+	int port = chip->type >= VX_TYPE_VXPOCKET ? 0x75 : 0x65;
+
+	chip->ops->reset_codec(chip);
+
+	/* AKM codecs should be initialized in reset_codec callback */
+	if (! chip->ops->akm_write) {
+		/* initialize old codecs */
+		for (i = 0; i < chip->hw->num_codecs; i++) {
+			/* DAC control register (change level when zero crossing + mute) */
+			vx_set_codec_reg(chip, i, XX_CODEC_DAC_CONTROL_REGISTER, DAC_ATTEN_MAX);
+			/* ADC control register */
+			vx_set_codec_reg(chip, i, XX_CODEC_ADC_CONTROL_REGISTER, 0x00);
+			/* Port mode register */
+			vx_set_codec_reg(chip, i, XX_CODEC_PORT_MODE_REGISTER, port);
+			/* Clock control register */
+			vx_set_codec_reg(chip, i, XX_CODEC_CLOCK_CONTROL_REGISTER, 0x00);
+		}
+	}
+
+	/* mute analog output */
+	for (i = 0; i < chip->hw->num_codecs; i++) {
+		chip->output_level[i][0] = 0;
+		chip->output_level[i][1] = 0;
+		vx_set_analog_output_level(chip, i, 0, 0);
+	}
+}
+
+/*
+ * change the audio input source
+ * @src: the target source (VX_AUDIO_SRC_XXX)
+ */
+static void vx_change_audio_source(vx_core_t *chip, int src)
+{
+	unsigned long flags;
+
+	if (chip->chip_status & VX_STAT_IS_STALE)
+		return;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	chip->ops->change_audio_source(chip, src);
+	spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+
+/*
+ * change the audio source if necessary and possible
+ * returns 1 if the source is actually changed.
+ */
+int vx_sync_audio_source(vx_core_t *chip)
+{
+	if (chip->audio_source_target == chip->audio_source ||
+	    chip->pcm_running)
+		return 0;
+	vx_change_audio_source(chip, chip->audio_source_target);
+	chip->audio_source = chip->audio_source_target;
+	return 1;
+}
+
+
+/*
+ * audio level, mute, monitoring
+ */
+struct vx_audio_level {
+	unsigned int has_level: 1;
+	unsigned int has_monitor_level: 1;
+	unsigned int has_mute: 1;
+	unsigned int has_monitor_mute: 1;
+	unsigned int mute;
+	unsigned int monitor_mute;
+	short level;
+	short monitor_level;
+};
+
+static int vx_adjust_audio_level(vx_core_t *chip, int audio, int capture,
+				 struct vx_audio_level *info)
+{
+	struct vx_rmh rmh;
+
+	if (chip->chip_status & VX_STAT_IS_STALE)
+		return -EBUSY;
+
+        vx_init_rmh(&rmh, CMD_AUDIO_LEVEL_ADJUST);
+	if (capture)
+		rmh.Cmd[0] |= COMMAND_RECORD_MASK;
+	/* Add Audio IO mask */
+	rmh.Cmd[1] = 1 << audio;
+	rmh.Cmd[2] = 0;
+	if (info->has_level) {
+		rmh.Cmd[0] |=  VALID_AUDIO_IO_DIGITAL_LEVEL;
+		rmh.Cmd[2] |= info->level;
+        }
+	if (info->has_monitor_level) {
+		rmh.Cmd[0] |=  VALID_AUDIO_IO_MONITORING_LEVEL;
+		rmh.Cmd[2] |= ((unsigned int)info->monitor_level << 10);
+        }
+	if (info->has_mute) { 
+		rmh.Cmd[0] |= VALID_AUDIO_IO_MUTE_LEVEL;
+		if (info->mute)
+			rmh.Cmd[2] |= AUDIO_IO_HAS_MUTE_LEVEL;
+	}
+	if (info->has_monitor_mute) {
+		/* validate flag for M2 at least to unmute it */ 
+		rmh.Cmd[0] |=  VALID_AUDIO_IO_MUTE_MONITORING_1 | VALID_AUDIO_IO_MUTE_MONITORING_2;
+		if (info->monitor_mute)
+			rmh.Cmd[2] |= AUDIO_IO_HAS_MUTE_MONITORING_1;
+	}
+
+	return vx_send_msg(chip, &rmh);
+}
+
+    
+#if 0 // not used
+static int vx_read_audio_level(vx_core_t *chip, int audio, int capture,
+			       struct vx_audio_level *info)
+{
+	int err;
+	struct vx_rmh rmh;
+
+	memset(info, 0, sizeof(*info));
+        vx_init_rmh(&rmh, CMD_GET_AUDIO_LEVELS);
+	if (capture)
+		rmh.Cmd[0] |= COMMAND_RECORD_MASK;
+	/* Add Audio IO mask */
+	rmh.Cmd[1] = 1 << audio;
+	err = vx_send_msg(chip, &rmh);
+	if (err < 0)
+		return err;
+	info.level = rmh.Stat[0] & MASK_DSP_WORD_LEVEL;
+	info.monitor_level = (rmh.Stat[0] >> 10) & MASK_DSP_WORD_LEVEL;
+	info.mute = (rmh.Stat[i] & AUDIO_IO_HAS_MUTE_LEVEL) ? 1 : 0;
+	info.monitor_mute = (rmh.Stat[i] & AUDIO_IO_HAS_MUTE_MONITORING_1) ? 1 : 0;
+	return 0;
+}
+#endif // not used
+
+/*
+ * set the monitoring level and mute state of the given audio
+ * no more static, because must be called from vx_pcm to demute monitoring
+ */
+int vx_set_monitor_level(vx_core_t *chip, int audio, int level, int active)
+{
+	struct vx_audio_level info;
+
+	memset(&info, 0, sizeof(info));
+	info.has_monitor_level = 1;
+	info.monitor_level = level;
+	info.has_monitor_mute = 1;
+	info.monitor_mute = !active;
+	chip->audio_monitor[audio] = level;
+	chip->audio_monitor_active[audio] = active;
+	return vx_adjust_audio_level(chip, audio, 0, &info); /* playback only */
+}
+
+
+/*
+ * set the mute status of the given audio
+ */
+static int vx_set_audio_switch(vx_core_t *chip, int audio, int active)
+{
+	struct vx_audio_level info;
+
+	memset(&info, 0, sizeof(info));
+	info.has_mute = 1;
+	info.mute = !active;
+	chip->audio_active[audio] = active;
+	return vx_adjust_audio_level(chip, audio, 0, &info); /* playback only */
+}
+
+/*
+ * set the mute status of the given audio
+ */
+static int vx_set_audio_gain(vx_core_t *chip, int audio, int capture, int level)
+{
+	struct vx_audio_level info;
+
+	memset(&info, 0, sizeof(info));
+	info.has_level = 1;
+	info.level = level;
+	chip->audio_gain[capture][audio] = level;
+	return vx_adjust_audio_level(chip, audio, capture, &info);
+}
+
+/*
+ * reset all audio levels
+ */
+static void vx_reset_audio_levels(vx_core_t *chip)
+{
+	unsigned int i, c;
+	struct vx_audio_level info;
+
+	memset(chip->audio_gain, 0, sizeof(chip->audio_gain));
+	memset(chip->audio_active, 0, sizeof(chip->audio_active));
+	memset(chip->audio_monitor, 0, sizeof(chip->audio_monitor));
+	memset(chip->audio_monitor_active, 0, sizeof(chip->audio_monitor_active));
+
+	for (c = 0; c < 2; c++) {
+		for (i = 0; i < chip->hw->num_ins * 2; i++) {
+			memset(&info, 0, sizeof(info));
+			if (c == 0) {
+				info.has_monitor_level = 1;
+				info.has_mute = 1;
+				info.has_monitor_mute = 1;
+			}
+			info.has_level = 1;
+			info.level = CVAL_0DB; /* default: 0dB */
+			vx_adjust_audio_level(chip, i, c, &info);
+			chip->audio_gain[c][i] = CVAL_0DB;
+			chip->audio_monitor[i] = CVAL_0DB;
+		}
+	}
+}
+
+
+/*
+ * VU, peak meter record
+ */
+
+#define VU_METER_CHANNELS	2
+
+struct vx_vu_meter {
+	int saturated;
+	int vu_level;
+	int peak_level;
+};
+
+/*
+ * get the VU and peak meter values
+ * @audio: the audio index
+ * @capture: 0 = playback, 1 = capture operation
+ * @info: the array of vx_vu_meter records (size = 2).
+ */
+static int vx_get_audio_vu_meter(vx_core_t *chip, int audio, int capture, struct vx_vu_meter *info)
+{
+	struct vx_rmh rmh;
+	int i, err;
+
+	if (chip->chip_status & VX_STAT_IS_STALE)
+		return -EBUSY;
+
+	vx_init_rmh(&rmh, CMD_AUDIO_VU_PIC_METER);
+	rmh.LgStat += 2 * VU_METER_CHANNELS;
+	if (capture)
+		rmh.Cmd[0] |= COMMAND_RECORD_MASK;
+    
+        /* Add Audio IO mask */
+	rmh.Cmd[1] = 0;
+	for (i = 0; i < VU_METER_CHANNELS; i++)
+		rmh.Cmd[1] |= 1 << (audio + i);
+	err = vx_send_msg(chip, &rmh);
+	if (err < 0)
+		return err;
+	/* Read response */
+	for (i = 0; i < 2 * VU_METER_CHANNELS; i +=2) {
+		info->saturated = (rmh.Stat[0] & (1 << (audio + i))) ? 1 : 0;
+		info->vu_level = rmh.Stat[i + 1];
+		info->peak_level = rmh.Stat[i + 2];
+		info++;
+	}
+	return 0;
+}
+   
+
+/*
+ * control API entries
+ */
+
+/*
+ * output level control
+ */
+static int vx_output_level_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = chip->hw->output_level_max;
+	return 0;
+}
+
+static int vx_output_level_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	int codec = kcontrol->id.index;
+	down(&chip->mixer_mutex);
+	ucontrol->value.integer.value[0] = chip->output_level[codec][0];
+	ucontrol->value.integer.value[1] = chip->output_level[codec][1];
+	up(&chip->mixer_mutex);
+	return 0;
+}
+
+static int vx_output_level_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	int codec = kcontrol->id.index;
+	down(&chip->mixer_mutex);
+	if (ucontrol->value.integer.value[0] != chip->output_level[codec][0] ||
+	    ucontrol->value.integer.value[1] != chip->output_level[codec][1]) {
+		vx_set_analog_output_level(chip, codec,
+					   ucontrol->value.integer.value[0],
+					   ucontrol->value.integer.value[1]);
+		chip->output_level[codec][0] = ucontrol->value.integer.value[0];
+		chip->output_level[codec][1] = ucontrol->value.integer.value[1];
+		up(&chip->mixer_mutex);
+		return 1;
+	}
+	up(&chip->mixer_mutex);
+	return 0;
+}
+
+static snd_kcontrol_new_t vx_control_output_level = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		"Master Playback Volume",
+	.info =		vx_output_level_info,
+	.get =		vx_output_level_get,
+	.put =		vx_output_level_put,
+};
+
+/*
+ * audio source select
+ */
+static int vx_audio_src_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	static char *texts_mic[3] = {
+		"Digital", "Line", "Mic"
+	};
+	static char *texts_vx2[2] = {
+		"Digital", "Analog"
+	};
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	if (chip->type >= VX_TYPE_VXPOCKET) {
+		uinfo->value.enumerated.items = 3;
+		if (uinfo->value.enumerated.item > 2)
+			uinfo->value.enumerated.item = 2;
+		strcpy(uinfo->value.enumerated.name,
+		       texts_mic[uinfo->value.enumerated.item]);
+	} else {
+		uinfo->value.enumerated.items = 2;
+		if (uinfo->value.enumerated.item > 1)
+			uinfo->value.enumerated.item = 1;
+		strcpy(uinfo->value.enumerated.name,
+		       texts_vx2[uinfo->value.enumerated.item]);
+	}
+	return 0;
+}
+
+static int vx_audio_src_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	ucontrol->value.enumerated.item[0] = chip->audio_source_target;
+	return 0;
+}
+
+static int vx_audio_src_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	down(&chip->mixer_mutex);
+	if (chip->audio_source_target != ucontrol->value.enumerated.item[0]) {
+		chip->audio_source_target = ucontrol->value.enumerated.item[0];
+		vx_sync_audio_source(chip);
+		up(&chip->mixer_mutex);
+		return 1;
+	}
+	up(&chip->mixer_mutex);
+	return 0;
+}
+
+static snd_kcontrol_new_t vx_control_audio_src = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		"Capture Source",
+	.info =		vx_audio_src_info,
+	.get =		vx_audio_src_get,
+	.put =		vx_audio_src_put,
+};
+
+/*
+ * clock mode selection
+ */
+static int vx_clock_mode_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	static char *texts[3] = {
+		"Auto", "Internal", "External"
+	};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 3;
+	if (uinfo->value.enumerated.item > 2)
+		uinfo->value.enumerated.item = 2;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int vx_clock_mode_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	ucontrol->value.enumerated.item[0] = chip->clock_mode;
+	return 0;
+}
+
+static int vx_clock_mode_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	down(&chip->mixer_mutex);
+	if (chip->clock_mode != ucontrol->value.enumerated.item[0]) {
+		chip->clock_mode = ucontrol->value.enumerated.item[0];
+		vx_set_clock(chip, chip->freq);
+		up(&chip->mixer_mutex);
+		return 1;
+	}
+	up(&chip->mixer_mutex);
+	return 0;
+}
+
+static snd_kcontrol_new_t vx_control_clock_mode = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		"Clock Mode",
+	.info =		vx_clock_mode_info,
+	.get =		vx_clock_mode_get,
+	.put =		vx_clock_mode_put,
+};
+
+/*
+ * Audio Gain
+ */
+static int vx_audio_gain_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = CVAL_MAX;
+	return 0;
+}
+
+static int vx_audio_gain_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	int audio = kcontrol->private_value & 0xff;
+	int capture = (kcontrol->private_value >> 8) & 1;
+
+	down(&chip->mixer_mutex);
+	ucontrol->value.integer.value[0] = chip->audio_gain[capture][audio];
+	ucontrol->value.integer.value[1] = chip->audio_gain[capture][audio+1];
+	up(&chip->mixer_mutex);
+	return 0;
+}
+
+static int vx_audio_gain_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	int audio = kcontrol->private_value & 0xff;
+	int capture = (kcontrol->private_value >> 8) & 1;
+
+	down(&chip->mixer_mutex);
+	if (ucontrol->value.integer.value[0] != chip->audio_gain[capture][audio] ||
+	    ucontrol->value.integer.value[1] != chip->audio_gain[capture][audio+1]) {
+		vx_set_audio_gain(chip, audio, capture, ucontrol->value.integer.value[0]);
+		vx_set_audio_gain(chip, audio+1, capture, ucontrol->value.integer.value[1]);
+		up(&chip->mixer_mutex);
+		return 1;
+	}
+	up(&chip->mixer_mutex);
+	return 0;
+}
+
+static int vx_audio_monitor_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	int audio = kcontrol->private_value & 0xff;
+
+	down(&chip->mixer_mutex);
+	ucontrol->value.integer.value[0] = chip->audio_monitor[audio];
+	ucontrol->value.integer.value[1] = chip->audio_monitor[audio+1];
+	up(&chip->mixer_mutex);
+	return 0;
+}
+
+static int vx_audio_monitor_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	int audio = kcontrol->private_value & 0xff;
+
+	down(&chip->mixer_mutex);
+	if (ucontrol->value.integer.value[0] != chip->audio_monitor[audio] ||
+	    ucontrol->value.integer.value[1] != chip->audio_monitor[audio+1]) {
+		vx_set_monitor_level(chip, audio, ucontrol->value.integer.value[0],
+				     chip->audio_monitor_active[audio]);
+		vx_set_monitor_level(chip, audio+1, ucontrol->value.integer.value[1],
+				     chip->audio_monitor_active[audio+1]);
+		up(&chip->mixer_mutex);
+		return 1;
+	}
+	up(&chip->mixer_mutex);
+	return 0;
+}
+
+static int vx_audio_sw_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int vx_audio_sw_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	int audio = kcontrol->private_value & 0xff;
+
+	down(&chip->mixer_mutex);
+	ucontrol->value.integer.value[0] = chip->audio_active[audio];
+	ucontrol->value.integer.value[1] = chip->audio_active[audio+1];
+	up(&chip->mixer_mutex);
+	return 0;
+}
+
+static int vx_audio_sw_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	int audio = kcontrol->private_value & 0xff;
+
+	down(&chip->mixer_mutex);
+	if (ucontrol->value.integer.value[0] != chip->audio_active[audio] ||
+	    ucontrol->value.integer.value[1] != chip->audio_active[audio+1]) {
+		vx_set_audio_switch(chip, audio, ucontrol->value.integer.value[0]);
+		vx_set_audio_switch(chip, audio+1, ucontrol->value.integer.value[1]);
+		up(&chip->mixer_mutex);
+		return 1;
+	}
+	up(&chip->mixer_mutex);
+	return 0;
+}
+
+static int vx_monitor_sw_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	int audio = kcontrol->private_value & 0xff;
+
+	down(&chip->mixer_mutex);
+	ucontrol->value.integer.value[0] = chip->audio_monitor_active[audio];
+	ucontrol->value.integer.value[1] = chip->audio_monitor_active[audio+1];
+	up(&chip->mixer_mutex);
+	return 0;
+}
+
+static int vx_monitor_sw_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	int audio = kcontrol->private_value & 0xff;
+
+	down(&chip->mixer_mutex);
+	if (ucontrol->value.integer.value[0] != chip->audio_monitor_active[audio] ||
+	    ucontrol->value.integer.value[1] != chip->audio_monitor_active[audio+1]) {
+		vx_set_monitor_level(chip, audio, chip->audio_monitor[audio],
+				     ucontrol->value.integer.value[0]);
+		vx_set_monitor_level(chip, audio+1, chip->audio_monitor[audio+1],
+				     ucontrol->value.integer.value[1]);
+		up(&chip->mixer_mutex);
+		return 1;
+	}
+	up(&chip->mixer_mutex);
+	return 0;
+}
+
+static snd_kcontrol_new_t vx_control_audio_gain = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	/* name will be filled later */
+	.info =         vx_audio_gain_info,
+	.get =          vx_audio_gain_get,
+	.put =          vx_audio_gain_put
+};
+static snd_kcontrol_new_t vx_control_output_switch = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "PCM Playback Switch",
+	.info =         vx_audio_sw_info,
+	.get =          vx_audio_sw_get,
+	.put =          vx_audio_sw_put
+};
+static snd_kcontrol_new_t vx_control_monitor_gain = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "Monitoring Volume",
+	.info =         vx_audio_gain_info,	/* shared */
+	.get =          vx_audio_monitor_get,
+	.put =          vx_audio_monitor_put
+};
+static snd_kcontrol_new_t vx_control_monitor_switch = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "Monitoring Switch",
+	.info =         vx_audio_sw_info,	/* shared */
+	.get =          vx_monitor_sw_get,
+	.put =          vx_monitor_sw_put
+};
+
+
+/*
+ * IEC958 status bits
+ */
+static int vx_iec958_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int vx_iec958_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+
+	down(&chip->mixer_mutex);
+	ucontrol->value.iec958.status[0] = (chip->uer_bits >> 0) & 0xff;
+	ucontrol->value.iec958.status[1] = (chip->uer_bits >> 8) & 0xff;
+	ucontrol->value.iec958.status[2] = (chip->uer_bits >> 16) & 0xff;
+	ucontrol->value.iec958.status[3] = (chip->uer_bits >> 24) & 0xff;
+	up(&chip->mixer_mutex);
+        return 0;
+}
+
+static int vx_iec958_mask_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	ucontrol->value.iec958.status[0] = 0xff;
+	ucontrol->value.iec958.status[1] = 0xff;
+	ucontrol->value.iec958.status[2] = 0xff;
+	ucontrol->value.iec958.status[3] = 0xff;
+        return 0;
+}
+
+static int vx_iec958_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+
+	val = (ucontrol->value.iec958.status[0] << 0) |
+	      (ucontrol->value.iec958.status[1] << 8) |
+	      (ucontrol->value.iec958.status[2] << 16) |
+	      (ucontrol->value.iec958.status[3] << 24);
+	down(&chip->mixer_mutex);
+	if (chip->uer_bits != val) {
+		chip->uer_bits = val;
+		vx_set_iec958_status(chip, val);
+		up(&chip->mixer_mutex);
+		return 1;
+	}
+	up(&chip->mixer_mutex);
+	return 0;
+}
+
+static snd_kcontrol_new_t vx_control_iec958_mask = {
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
+	.info =		vx_iec958_info,	/* shared */
+	.get =		vx_iec958_mask_get,
+};
+
+static snd_kcontrol_new_t vx_control_iec958 = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
+	.info =         vx_iec958_info,
+	.get =          vx_iec958_get,
+	.put =          vx_iec958_put
+};
+
+
+/*
+ * VU meter
+ */
+
+#define METER_MAX	0xff
+#define METER_SHIFT	16
+
+static int vx_vu_meter_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = METER_MAX;
+	return 0;
+}
+
+static int vx_vu_meter_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_vu_meter meter[2];
+	int audio = kcontrol->private_value & 0xff;
+	int capture = (kcontrol->private_value >> 8) & 1;
+
+	vx_get_audio_vu_meter(chip, audio, capture, meter);
+	ucontrol->value.integer.value[0] = meter[0].vu_level >> METER_SHIFT;
+	ucontrol->value.integer.value[1] = meter[1].vu_level >> METER_SHIFT;
+	return 0;
+}
+
+static int vx_peak_meter_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_vu_meter meter[2];
+	int audio = kcontrol->private_value & 0xff;
+	int capture = (kcontrol->private_value >> 8) & 1;
+
+	vx_get_audio_vu_meter(chip, audio, capture, meter);
+	ucontrol->value.integer.value[0] = meter[0].peak_level >> METER_SHIFT;
+	ucontrol->value.integer.value[1] = meter[1].peak_level >> METER_SHIFT;
+	return 0;
+}
+
+static int vx_saturation_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int vx_saturation_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	vx_core_t *chip = snd_kcontrol_chip(kcontrol);
+	struct vx_vu_meter meter[2];
+	int audio = kcontrol->private_value & 0xff;
+
+	vx_get_audio_vu_meter(chip, audio, 1, meter); /* capture only */
+	ucontrol->value.integer.value[0] = meter[0].saturated;
+	ucontrol->value.integer.value[1] = meter[1].saturated;
+	return 0;
+}
+
+static snd_kcontrol_new_t vx_control_vu_meter = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	/* name will be filled later */
+	.info =		vx_vu_meter_info,
+	.get =		vx_vu_meter_get,
+};
+
+static snd_kcontrol_new_t vx_control_peak_meter = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	/* name will be filled later */
+	.info =		vx_vu_meter_info,	/* shared */
+	.get =		vx_peak_meter_get,
+};
+
+static snd_kcontrol_new_t vx_control_saturation = {
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		"Input Saturation",
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.info =		vx_saturation_info,
+	.get =		vx_saturation_get,
+};
+
+
+
+/*
+ *
+ */
+
+int snd_vx_mixer_new(vx_core_t *chip)
+{
+	unsigned int i, c;
+	int err;
+	snd_kcontrol_new_t temp;
+	snd_card_t *card = chip->card;
+	char name[32];
+
+	strcpy(card->mixername, card->driver);
+
+	/* output level controls */
+	for (i = 0; i < chip->hw->num_outs; i++) {
+		temp = vx_control_output_level;
+		temp.index = i;
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)
+			return err;
+	}
+
+	/* PCM volumes, switches, monitoring */
+	for (i = 0; i < chip->hw->num_outs; i++) {
+		int val = i * 2;
+		temp = vx_control_audio_gain;
+		temp.index = i;
+		temp.name = "PCM Playback Volume";
+		temp.private_value = val;
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)
+			return err;
+		temp = vx_control_output_switch;
+		temp.index = i;
+		temp.private_value = val;
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)
+			return err;
+		temp = vx_control_monitor_gain;
+		temp.index = i;
+		temp.private_value = val;
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)
+			return err;
+		temp = vx_control_monitor_switch;
+		temp.index = i;
+		temp.private_value = val;
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)
+			return err;
+	}
+	for (i = 0; i < chip->hw->num_outs; i++) {
+		temp = vx_control_audio_gain;
+		temp.index = i;
+		temp.name = "PCM Capture Volume";
+		temp.private_value = (i * 2) | (1 << 8);
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)
+			return err;
+	}
+
+	/* Audio source */
+	if ((err = snd_ctl_add(card, snd_ctl_new1(&vx_control_audio_src, chip))) < 0)
+		return err;
+	/* clock mode */
+	if ((err = snd_ctl_add(card, snd_ctl_new1(&vx_control_clock_mode, chip))) < 0)
+		return err;
+	/* IEC958 controls */
+	if ((err = snd_ctl_add(card, snd_ctl_new1(&vx_control_iec958_mask, chip))) < 0)
+		return err;
+	if ((err = snd_ctl_add(card, snd_ctl_new1(&vx_control_iec958, chip))) < 0)
+		return err;
+	/* VU, peak, saturation meters */
+	for (c = 0; c < 2; c++) {
+		static char *dir[2] = { "Output", "Input" };
+		for (i = 0; i < chip->hw->num_ins; i++) {
+			int val = (i * 2) | (c << 8);
+			if (c == 1) {
+				temp = vx_control_saturation;
+				temp.index = i;
+				temp.private_value = val;
+				if ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)
+					return err;
+			}
+			sprintf(name, "%s VU Meter", dir[c]);
+			temp = vx_control_vu_meter;
+			temp.index = i;
+			temp.name = name;
+			temp.private_value = val;
+			if ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)
+				return err;
+			sprintf(name, "%s Peak Meter", dir[c]);
+			temp = vx_control_peak_meter;
+			temp.index = i;
+			temp.name = name;
+			temp.private_value = val;
+			if ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)
+				return err;
+		}
+	}
+	vx_reset_audio_levels(chip);
+	return 0;
+}
