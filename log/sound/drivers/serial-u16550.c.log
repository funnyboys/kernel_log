commit 6c8454888fe68bf2e3690c489d8764bac47c24c5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:48:13 2020 +0100

    ALSA: serial-u16550: More constification
    
    Apply const prefix to the string array.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-59-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 893c2b57331f..3947f084dd6b 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -42,7 +42,7 @@ MODULE_SUPPORTED_DEVICE("{{ALSA, MIDI serial u16550}}");
 #define SNDRV_SERIAL_MS124W_MB 3   /* Midiator MS-124W in M/B mode */
 #define SNDRV_SERIAL_GENERIC 4     /* Generic Interface */
 #define SNDRV_SERIAL_MAX_ADAPTOR SNDRV_SERIAL_GENERIC
-static char *adaptor_names[] = {
+static const char * const adaptor_names[] = {
 	"Soundcanvas",
         "MS-124T",
 	"MS-124W S/A",

commit 34273b234c0712c963f02845919125686f503d3e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:21 2020 +0100

    ALSA: drivers: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-6-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 4775f1b7b444..893c2b57331f 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -777,7 +777,7 @@ static int snd_uart16550_create(struct snd_card *card,
 				int droponfull,
 				struct snd_uart16550 **ruart)
 {
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free =	snd_uart16550_dev_free,
 	};
 	struct snd_uart16550 *uart;

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 0a67b8b9f176..4775f1b7b444 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *   serial.c
  *   Copyright (c) by Jaroslav Kysela <perex@perex.cz>,
@@ -7,20 +8,6 @@
  *
  *   This code is based on the code from ALSA 0.5.9, but heavily rewritten.
  *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  * Sat Mar 31 17:27:57 PST 2001 tim.mann@compaq.com 
  *      Added support for the Midiator MS-124T and for the MS-124W in
  *      Single Addressed (S/A) or Multiple Burst (M/B) mode, with

commit bc47ba90b01afe468cdd586b0dbe59b64862e2b7
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 24 08:34:29 2017 -0700

    ALSA: drivers: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 88e66ea0306d..0a67b8b9f176 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -309,12 +309,12 @@ static irqreturn_t snd_uart16550_interrupt(int irq, void *dev_id)
 }
 
 /* When the polling mode, this function calls snd_uart16550_io_loop. */
-static void snd_uart16550_buffer_timer(unsigned long data)
+static void snd_uart16550_buffer_timer(struct timer_list *t)
 {
 	unsigned long flags;
 	struct snd_uart16550 *uart;
 
-	uart = (struct snd_uart16550 *)data;
+	uart = from_timer(uart, t, buffer_timer);
 	spin_lock_irqsave(&uart->open_lock, flags);
 	snd_uart16550_del_timer(uart);
 	snd_uart16550_io_loop(uart);
@@ -828,8 +828,7 @@ static int snd_uart16550_create(struct snd_card *card,
 	uart->prev_in = 0;
 	uart->rstatus = 0;
 	memset(uart->prev_status, 0x80, sizeof(unsigned char) * SNDRV_SERIAL_MAX_OUTS);
-	setup_timer(&uart->buffer_timer, snd_uart16550_buffer_timer,
-		    (unsigned long)uart);
+	timer_setup(&uart->buffer_timer, snd_uart16550_buffer_timer, 0);
 	uart->timer_running = 0;
 
 	/* Register device */

commit b11ce420c5dfc966061bc20f576c85504bb69712
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:30 2017 +0100

    Annotate hardware config module parameters in sound/drivers/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in sound/drivers/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    cc: Jaroslav Kysela <perex@perex.cz>
    cc: alsa-devel@alsa-project.org

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 60d51ac4ccfe..88e66ea0306d 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -84,9 +84,9 @@ module_param_array(id, charp, NULL, 0444);
 MODULE_PARM_DESC(id, "ID string for Serial MIDI.");
 module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable UART16550A chip.");
-module_param_array(port, long, NULL, 0444);
+module_param_hw_array(port, long, ioport, NULL, 0444);
 MODULE_PARM_DESC(port, "Port # for UART16550A chip.");
-module_param_array(irq, int, NULL, 0444);
+module_param_hw_array(irq, int, irq, NULL, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for UART16550A chip.");
 module_param_array(speed, int, NULL, 0444);
 MODULE_PARM_DESC(speed, "Speed in bauds.");

commit c36f486d7bc71d41ec6b9521574136a280c17803
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 5 17:28:39 2017 +0100

    ALSA: drivers: Constify snd_rawmidi_ops
    
    Now snd_rawmidi_ops is maintained as a const pointer in snd_rawmidi,
    we can constify the definitions.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 1927b89e1d1f..60d51ac4ccfe 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -752,14 +752,14 @@ static void snd_uart16550_output_trigger(struct snd_rawmidi_substream *substream
 		snd_uart16550_output_write(substream);
 }
 
-static struct snd_rawmidi_ops snd_uart16550_output =
+static const struct snd_rawmidi_ops snd_uart16550_output =
 {
 	.open =		snd_uart16550_output_open,
 	.close =	snd_uart16550_output_close,
 	.trigger =	snd_uart16550_output_trigger,
 };
 
-static struct snd_rawmidi_ops snd_uart16550_input =
+static const struct snd_rawmidi_ops snd_uart16550_input =
 {
 	.open =		snd_uart16550_input_open,
 	.close =	snd_uart16550_input_close,

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 8c1dc73e14e4..1927b89e1d1f 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -37,6 +37,7 @@
 #include <linux/slab.h>
 #include <linux/ioport.h>
 #include <linux/module.h>
+#include <linux/io.h>
 #include <sound/core.h>
 #include <sound/rawmidi.h>
 #include <sound/initval.h>
@@ -44,8 +45,6 @@
 #include <linux/serial_reg.h>
 #include <linux/jiffies.h>
 
-#include <asm/io.h>
-
 MODULE_DESCRIPTION("MIDI serial u16550");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{ALSA, MIDI serial u16550}}");

commit d80d05fcca1771ff68e0b385459fabb3eb938e98
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 11:29:09 2015 +0100

    ALSA: serial-u16550: Use setup_timer() and mod_timer()
    
    No functional change, refactoring with the standard helpers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 13a34e3c6382..8c1dc73e14e4 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -174,9 +174,8 @@ static inline void snd_uart16550_add_timer(struct snd_uart16550 *uart)
 {
 	if (!uart->timer_running) {
 		/* timer 38600bps * 10bit * 16byte */
-		uart->buffer_timer.expires = jiffies + (HZ+255)/256;
+		mod_timer(&uart->buffer_timer, jiffies + (HZ + 255) / 256);
 		uart->timer_running = 1;
-		add_timer(&uart->buffer_timer);
 	}
 }
 
@@ -830,9 +829,8 @@ static int snd_uart16550_create(struct snd_card *card,
 	uart->prev_in = 0;
 	uart->rstatus = 0;
 	memset(uart->prev_status, 0x80, sizeof(unsigned char) * SNDRV_SERIAL_MAX_OUTS);
-	init_timer(&uart->buffer_timer);
-	uart->buffer_timer.function = snd_uart16550_buffer_timer;
-	uart->buffer_timer.data = (unsigned long)uart;
+	setup_timer(&uart->buffer_timer, snd_uart16550_buffer_timer,
+		    (unsigned long)uart);
 	uart->timer_running = 0;
 
 	/* Register device */

commit 5d5638afa0cb252442e1746a36550b46a9ebe6ee
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:59 2014 +0200

    ALSA: drivers: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 9ad4414fa25c..13a34e3c6382 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -994,7 +994,6 @@ static struct platform_driver snd_serial_driver = {
 	.remove		=  snd_serial_remove,
 	.driver		= {
 		.name	= SND_SERIAL_DRIVER,
-		.owner	= THIS_MODULE,
 	},
 };
 

commit 5872f3f621f9f65342583a85ec93b00c0a697eda
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 12:59:08 2014 +0100

    ALSA: drivers: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index e0bf5e77b43a..9ad4414fa25c 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -942,7 +942,8 @@ static int snd_serial_probe(struct platform_device *devptr)
 		return -ENODEV;
 	}
 
-	err  = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	err  = snd_card_new(&devptr->dev, index[dev], id[dev], THIS_MODULE,
+			    0, &card);
 	if (err < 0)
 		return err;
 
@@ -969,8 +970,6 @@ static int snd_serial_probe(struct platform_device *devptr)
 		uart->base,
 		uart->irq);
 
-	snd_card_set_dev(card, &devptr->dev);
-
 	if ((err = snd_card_register(card)) < 0)
 		goto _err;
 

commit 45837cb214a7fd076ae66a87a9425588156d3a78
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon May 20 14:08:40 2013 +0530

    ALSA: serial-u16550: Remove redundant platform_set_drvdata()
    
    Commit 0998d06310 (device-core: Ensure drvdata = NULL when no
    driver is bound) removes the need to set driver data field to
    NULL.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 7425dd8c1f09..e0bf5e77b43a 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -985,7 +985,6 @@ static int snd_serial_probe(struct platform_device *devptr)
 static int snd_serial_remove(struct platform_device *devptr)
 {
 	snd_card_free(platform_get_drvdata(devptr));
-	platform_set_drvdata(devptr, NULL);
 	return 0;
 }
 

commit fbbb01a12d5d553ea3851a020d98c0ac9b383673
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:27 2012 -0500

    ALSA: drivers: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 86700671d1ac..7425dd8c1f09 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -328,7 +328,7 @@ static void snd_uart16550_buffer_timer(unsigned long data)
  *  return 0 if found
  *  return negative error if not found
  */
-static int __devinit snd_uart16550_detect(struct snd_uart16550 *uart)
+static int snd_uart16550_detect(struct snd_uart16550 *uart)
 {
 	unsigned long io_base = uart->base;
 	int ok;
@@ -783,14 +783,14 @@ static int snd_uart16550_dev_free(struct snd_device *device)
 	return snd_uart16550_free(uart);
 }
 
-static int __devinit snd_uart16550_create(struct snd_card *card,
-				       unsigned long iobase,
-				       int irq,
-				       unsigned int speed,
-				       unsigned int base,
-				       int adaptor,
-				       int droponfull,
-				       struct snd_uart16550 **ruart)
+static int snd_uart16550_create(struct snd_card *card,
+				unsigned long iobase,
+				int irq,
+				unsigned int speed,
+				unsigned int base,
+				int adaptor,
+				int droponfull,
+				struct snd_uart16550 **ruart)
 {
 	static struct snd_device_ops ops = {
 		.dev_free =	snd_uart16550_dev_free,
@@ -863,7 +863,7 @@ static int __devinit snd_uart16550_create(struct snd_card *card,
 	return 0;
 }
 
-static void __devinit snd_uart16550_substreams(struct snd_rawmidi_str *stream)
+static void snd_uart16550_substreams(struct snd_rawmidi_str *stream)
 {
 	struct snd_rawmidi_substream *substream;
 
@@ -872,9 +872,9 @@ static void __devinit snd_uart16550_substreams(struct snd_rawmidi_str *stream)
 	}
 }
 
-static int __devinit snd_uart16550_rmidi(struct snd_uart16550 *uart, int device,
-				      int outs, int ins,
-				      struct snd_rawmidi **rmidi)
+static int snd_uart16550_rmidi(struct snd_uart16550 *uart, int device,
+			       int outs, int ins,
+			       struct snd_rawmidi **rmidi)
 {
 	struct snd_rawmidi *rrawmidi;
 	int err;
@@ -899,7 +899,7 @@ static int __devinit snd_uart16550_rmidi(struct snd_uart16550 *uart, int device,
 	return 0;
 }
 
-static int __devinit snd_serial_probe(struct platform_device *devptr)
+static int snd_serial_probe(struct platform_device *devptr)
 {
 	struct snd_card *card;
 	struct snd_uart16550 *uart;
@@ -982,7 +982,7 @@ static int __devinit snd_serial_probe(struct platform_device *devptr)
 	return err;
 }
 
-static int __devexit snd_serial_remove(struct platform_device *devptr)
+static int snd_serial_remove(struct platform_device *devptr)
 {
 	snd_card_free(platform_get_drvdata(devptr));
 	platform_set_drvdata(devptr, NULL);
@@ -993,7 +993,7 @@ static int __devexit snd_serial_remove(struct platform_device *devptr)
 
 static struct platform_driver snd_serial_driver = {
 	.probe		= snd_serial_probe,
-	.remove		= __devexit_p( snd_serial_remove),
+	.remove		=  snd_serial_remove,
 	.driver		= {
 		.name	= SND_SERIAL_DRIVER,
 		.owner	= THIS_MODULE,

commit 8bf01d8abc55eaf8e19a2d48911c8e49ee6f5bab
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 10:50:24 2012 +0200

    ALSA: Add missing .owner=THIS_MODULE to platform_driver definitions
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index b2d0e8e49bed..86700671d1ac 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -995,7 +995,8 @@ static struct platform_driver snd_serial_driver = {
 	.probe		= snd_serial_probe,
 	.remove		= __devexit_p( snd_serial_remove),
 	.driver		= {
-		.name	= SND_SERIAL_DRIVER
+		.name	= SND_SERIAL_DRIVER,
+		.owner	= THIS_MODULE,
 	},
 };
 

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 85aad43f0b1e..b2d0e8e49bed 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -69,7 +69,7 @@ static char *adaptor_names[] = {
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE; /* Enable this card */
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE; /* Enable this card */
 static long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT; /* 0x3f8,0x2f8,0x3e8,0x2e8 */
 static int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ; 	/* 3,4,5,7,9,10,11,14,15 */
 static int speed[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 38400}; /* 9600,19200,38400,57600,115200 */
@@ -77,7 +77,7 @@ static int base[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 115200}; /* baud bas
 static int outs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};	 /* 1 to 16 */
 static int ins[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};	/* 1 to 16 */
 static int adaptor[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = SNDRV_SERIAL_SOUNDCANVAS};
-static int droponfull[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS -1)] = SNDRV_SERIAL_NORMALBUFF };
+static bool droponfull[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS -1)] = SNDRV_SERIAL_NORMALBUFF };
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for Serial MIDI.");

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index fc1d822802c3..85aad43f0b1e 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -36,7 +36,7 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/ioport.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <sound/core.h>
 #include <sound/rawmidi.h>
 #include <sound/initval.h>

commit 88e24c3a4b30a6bd361f2b5ce602667a8161b2e8
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Thu Sep 22 16:59:20 2011 +0800

    sound: irq: Remove IRQF_DISABLED
    
    Since commit [e58aa3d2: genirq: Run irq handlers with interrupts disabled],
    We run all interrupt handlers with interrupts disabled
    and we even check and yell when an interrupt handler
    returns with interrupts enabled (see commit [b738a50a:
    genirq: Warn when handler enables interrupts]).
    
    So now this flag is a NOOP and can be removed.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index a25fb7b1f441..fc1d822802c3 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -816,7 +816,7 @@ static int __devinit snd_uart16550_create(struct snd_card *card,
 
 	if (irq >= 0 && irq != SNDRV_AUTO_IRQ) {
 		if (request_irq(irq, snd_uart16550_interrupt,
-				IRQF_DISABLED, "Serial MIDI", uart)) {
+				0, "Serial MIDI", uart)) {
 			snd_printk(KERN_WARNING
 				   "irq %d busy. Using Polling.\n", irq);
 		} else {

commit bd0185ceaca7ef17d5c9c094882a5aabe8eff677
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue May 5 15:39:39 2009 +0200

    sound: serial-u16550: fix buffer overflow
    
    Remove most of the serial port parameters from the card longname string
    because it was way too long and overflowed into the mixername string.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index b2b6d50c9425..a25fb7b1f441 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -963,16 +963,11 @@ static int __devinit snd_serial_probe(struct platform_device *devptr)
 	if (err < 0)
 		goto _err;
 
-	sprintf(card->longname, "%s at 0x%lx, irq %d speed %d div %d outs %d ins %d adaptor %s droponfull %d",
+	sprintf(card->longname, "%s [%s] at %#lx, irq %d",
 		card->shortname,
-		uart->base,
-		uart->irq,
-		uart->speed,
-		(int)uart->divisor,
-		outs[dev],
-		ins[dev],
 		adaptor_names[uart->adaptor],
-		uart->drop_on_full);
+		uart->base,
+		uart->irq);
 
 	snd_card_set_dev(card, &devptr->dev);
 

commit e0d2054fd3cf167395390dc1758644486c782707
Merge: d807500a2472 c468ac29e63b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:35:50 2009 +0100

    Merge branch 'topic/misc' into for-linus

commit 45203832df2fa9e94ca0a249ddb20d2b077e58cc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 15:51:50 2009 +0100

    ALSA: Add missing KERN_* prefix to printk in sound/drivers
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index d8aab9da97c2..ff0a41510945 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -241,7 +241,8 @@ static void snd_uart16550_io_loop(struct snd_uart16550 * uart)
 			snd_rawmidi_receive(uart->midi_input[substream], &c, 1);
 
 		if (status & UART_LSR_OE)
-			snd_printk("%s: Overrun on device at 0x%lx\n",
+			snd_printk(KERN_WARNING
+				   "%s: Overrun on device at 0x%lx\n",
 			       uart->rmidi->name, uart->base);
 	}
 
@@ -636,7 +637,8 @@ static int snd_uart16550_output_byte(struct snd_uart16550 *uart,
 		}
 	} else {
 		if (!snd_uart16550_write_buffer(uart, midi_byte)) {
-			snd_printk("%s: Buffer overrun on device at 0x%lx\n",
+			snd_printk(KERN_WARNING
+				   "%s: Buffer overrun on device at 0x%lx\n",
 				   uart->rmidi->name, uart->base);
 			return 0;
 		}
@@ -815,7 +817,8 @@ static int __devinit snd_uart16550_create(struct snd_card *card,
 	if (irq >= 0 && irq != SNDRV_AUTO_IRQ) {
 		if (request_irq(irq, snd_uart16550_interrupt,
 				IRQF_DISABLED, "Serial MIDI", uart)) {
-			snd_printk("irq %d busy. Using Polling.\n", irq);
+			snd_printk(KERN_WARNING
+				   "irq %d busy. Using Polling.\n", irq);
 		} else {
 			uart->irq = irq;
 		}
@@ -919,19 +922,22 @@ static int __devinit snd_serial_probe(struct platform_device *devptr)
 	case SNDRV_SERIAL_GENERIC:
 		break;
 	default:
-		snd_printk("Adaptor type is out of range 0-%d (%d)\n",
+		snd_printk(KERN_ERR
+			   "Adaptor type is out of range 0-%d (%d)\n",
 			   SNDRV_SERIAL_MAX_ADAPTOR, adaptor[dev]);
 		return -ENODEV;
 	}
 
 	if (outs[dev] < 1 || outs[dev] > SNDRV_SERIAL_MAX_OUTS) {
-		snd_printk("Count of outputs is out of range 1-%d (%d)\n",
+		snd_printk(KERN_ERR
+			   "Count of outputs is out of range 1-%d (%d)\n",
 			   SNDRV_SERIAL_MAX_OUTS, outs[dev]);
 		return -ENODEV;
 	}
 
 	if (ins[dev] < 1 || ins[dev] > SNDRV_SERIAL_MAX_INS) {
-		snd_printk("Count of inputs is out of range 1-%d (%d)\n",
+		snd_printk(KERN_ERR
+			   "Count of inputs is out of range 1-%d (%d)\n",
 			   SNDRV_SERIAL_MAX_INS, ins[dev]);
 		return -ENODEV;
 	}

commit bd7dd77c2a05c530684eea2e3af16449ae9c5d52
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:45:02 2008 +0100

    ALSA: Convert to snd_card_create() in other sound/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in other sound subdirectories.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index d8aab9da97c2..891d081e4825 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -936,9 +936,9 @@ static int __devinit snd_serial_probe(struct platform_device *devptr)
 		return -ENODEV;
 	}
 
-	card  = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
-	if (card == NULL)
-		return -ENOMEM;
+	err  = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	if (err < 0)
+		return err;
 
 	strcpy(card->driver, "Serial");
 	strcpy(card->shortname, "Serial MIDI (UART16550A)");

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index f4156011945f..d8aab9da97c2 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -30,7 +30,6 @@
  *      More documentation can be found in serial-u16550.txt.
  */
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/err.h>

commit f11b799282201fbd8c88b51815176a902b1f15b8
Author: Julia Lawall <julia@diku.dk>
Date:   Mon Jan 7 13:33:45 2008 +0100

    [ALSA] sound: Use time_before, time_before_eq, etc.
    
    The functions time_before, time_before_eq, time_after, and time_after_eq
    are more robust for comparing jiffies against other values.
    A simplified version of the semantic patch making this change is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    // <smpl>
    @ change_compare_np @
    expression E;
    @@
    (
    - jiffies <= E
    + time_before_eq(jiffies,E)
    |
    - jiffies >= E
    + time_after_eq(jiffies,E)
    |
    - jiffies < E
    + time_before(jiffies,E)
    |
    - jiffies > E
    + time_after(jiffies,E)
    )
    @ include depends on change_compare_np @
    @@
    #include <linux/jiffies.h>
    @ no_include depends on !include && change_compare_np @
    @@
      #include <linux/...>
    + #include <linux/jiffies.h>
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 3958dbd626b2..f4156011945f 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -43,6 +43,7 @@
 #include <sound/initval.h>
 
 #include <linux/serial_reg.h>
+#include <linux/jiffies.h>
 
 #include <asm/io.h>
 
@@ -694,7 +695,7 @@ static void snd_uart16550_output_write(struct snd_rawmidi_substream *substream)
 			    (uart->adaptor == SNDRV_SERIAL_SOUNDCANVAS ||
 			     uart->adaptor == SNDRV_SERIAL_GENERIC) &&
 			    (uart->prev_out != substream->number ||
-			     jiffies-lasttime > 3*HZ)) {
+			     time_after(jiffies, lasttime + 3*HZ))) {
 
 				if (snd_uart16550_buffer_can_write(uart, 3)) {
 					/* Roland Soundcanvas part selection */

commit 561de31a23a8a5d23baeb8b2ce7c6102cb649616
Author: Joe Perches <joe@perches.com>
Date:   Tue Dec 18 13:13:47 2007 +0100

    [ALSA] sound/: Spelling fixes
    
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 65de3a755ddb..3958dbd626b2 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -455,7 +455,7 @@ static void snd_uart16550_do_open(struct snd_uart16550 * uart)
 		    | UART_IER_THRI	/* Enable Transmitter holding register empty interrupt */
 		    ;
 	}
-	outb(byte, uart->base + UART_IER);	/* Interupt enable Register */
+	outb(byte, uart->base + UART_IER);	/* Interrupt enable Register */
 
 	inb(uart->base + UART_LSR);	/* Clear any pre-existing overrun indication */
 	inb(uart->base + UART_IIR);	/* Clear any pre-existing transmit interrupt */
@@ -473,7 +473,7 @@ static void snd_uart16550_do_close(struct snd_uart16550 * uart)
 
 	outb((0 & UART_IER_RDI)		/* Disable Receiver data interrupt */
 	     |(0 & UART_IER_THRI)	/* Disable Transmitter holding register empty interrupt */
-	     ,uart->base + UART_IER);	/* Interupt enable Register */
+	     ,uart->base + UART_IER);	/* Interrupt enable Register */
 
 	switch (uart->adaptor) {
 	default:
@@ -653,7 +653,7 @@ static void snd_uart16550_output_write(struct snd_rawmidi_substream *substream)
 	char first;
 	static unsigned long lasttime = 0;
 	
-	/* Interupts are disabled during the updating of the tx_buff,
+	/* Interrupts are disabled during the updating of the tx_buff,
 	 * since it is 'bad' to have two processes updating the same
 	 * variables (ie buff_in & buff_out)
 	 */

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index d3e6a20edd38..65de3a755ddb 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -1,6 +1,6 @@
 /*
  *   serial.c
- *   Copyright (c) by Jaroslav Kysela <perex@suse.cz>,
+ *   Copyright (c) by Jaroslav Kysela <perex@perex.cz>,
  *                    Isaku Yamahata <yamahata@private.email.ne.jp>,
  *		      George Hansper <ghansper@apana.org.au>,
  *		      Hannu Savolainen

commit bdec0c728256e1a3739820e244a5138bcfae5a91
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Jun 25 12:07:38 2007 +0200

    [ALSA] fix section mismatch
    
    Fix shared init/exit function attributes:
    WARNING: sound/built-in.o(.exit.text+0x4a1): Section mismatch: reference to .init.text: (between 'alsa_card_virmidi_exit' and 'alsa_card_serial_exit')
    WARNING: sound/built-in.o(.exit.text+0x4c1): Section mismatch: reference to .init.text: (between 'alsa_card_serial_exit' and 'ac97_bus_exit')
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 838a4277929d..d3e6a20edd38 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -998,7 +998,7 @@ static struct platform_driver snd_serial_driver = {
 	},
 };
 
-static void __init_or_module snd_serial_unregister_all(void)
+static void snd_serial_unregister_all(void)
 {
 	int i;
 

commit 788c6043335590e0a483fdc18f85b1405a157bf9
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Tue Feb 13 13:11:11 2007 +0100

    [ALSA] Fix __devinit and __devexit issues with sound drivers
    
    Fix __devinit and __devexit issues with sound drivers.
    Resolves MODPOST warnings similar to:
    WARNING: sound/drivers/snd-dummy.o - Section mismatch: reference to .init.text:snd_dummy_probe from .data.rel.local between 'snd_dummy_driver' (at offset 0x0) and 'snd_dummy_controls'
    WARNING: sound/drivers/snd-mtpav.o - Section mismatch: reference to .init.text:snd_mtpav_probe from .data.rel.local between 'snd_mtpav_driver' (at offset 0x0) and 'snd_mtpav_input'
    WARNING: sound/drivers/snd-virmidi.o - Section mismatch: reference to .init.text:snd_virmidi_probe from .data.rel.local after 'snd_virmidi_driver' (at offset 0x0)
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 3a86a5820726..838a4277929d 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -327,7 +327,7 @@ static void snd_uart16550_buffer_timer(unsigned long data)
  *  return 0 if found
  *  return negative error if not found
  */
-static int __init snd_uart16550_detect(struct snd_uart16550 *uart)
+static int __devinit snd_uart16550_detect(struct snd_uart16550 *uart)
 {
 	unsigned long io_base = uart->base;
 	int ok;
@@ -781,7 +781,7 @@ static int snd_uart16550_dev_free(struct snd_device *device)
 	return snd_uart16550_free(uart);
 }
 
-static int __init snd_uart16550_create(struct snd_card *card,
+static int __devinit snd_uart16550_create(struct snd_card *card,
 				       unsigned long iobase,
 				       int irq,
 				       unsigned int speed,
@@ -860,7 +860,7 @@ static int __init snd_uart16550_create(struct snd_card *card,
 	return 0;
 }
 
-static void __init snd_uart16550_substreams(struct snd_rawmidi_str *stream)
+static void __devinit snd_uart16550_substreams(struct snd_rawmidi_str *stream)
 {
 	struct snd_rawmidi_substream *substream;
 
@@ -869,7 +869,7 @@ static void __init snd_uart16550_substreams(struct snd_rawmidi_str *stream)
 	}
 }
 
-static int __init snd_uart16550_rmidi(struct snd_uart16550 *uart, int device,
+static int __devinit snd_uart16550_rmidi(struct snd_uart16550 *uart, int device,
 				      int outs, int ins,
 				      struct snd_rawmidi **rmidi)
 {
@@ -896,7 +896,7 @@ static int __init snd_uart16550_rmidi(struct snd_uart16550 *uart, int device,
 	return 0;
 }
 
-static int __init snd_serial_probe(struct platform_device *devptr)
+static int __devinit snd_serial_probe(struct platform_device *devptr)
 {
 	struct snd_card *card;
 	struct snd_uart16550 *uart;
@@ -981,7 +981,7 @@ static int __init snd_serial_probe(struct platform_device *devptr)
 	return err;
 }
 
-static int snd_serial_remove(struct platform_device *devptr)
+static int __devexit snd_serial_remove(struct platform_device *devptr)
 {
 	snd_card_free(platform_get_drvdata(devptr));
 	platform_set_drvdata(devptr, NULL);
@@ -992,7 +992,7 @@ static int snd_serial_remove(struct platform_device *devptr)
 
 static struct platform_driver snd_serial_driver = {
 	.probe		= snd_serial_probe,
-	.remove		= snd_serial_remove,
+	.remove		= __devexit_p( snd_serial_remove),
 	.driver		= {
 		.name	= SND_SERIAL_DRIVER
 	},

commit 0b830bac35dd6e3996bee675c3893857da8a4d0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 24 16:13:57 2006 +0100

    [ALSA] Clean up serial-u16500.c
    
    Remove uesless typedefs and clean up the code a bit to follow
    the standard coding style.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 74028b2219c2..3a86a5820726 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -117,13 +117,13 @@ MODULE_PARM_DESC(adaptor, "Type of adaptor.");
 #define SERIAL_MODE_INPUT_TRIGGERED	(1 << 2)
 #define SERIAL_MODE_OUTPUT_TRIGGERED	(1 << 3)
 
-typedef struct _snd_uart16550 {
+struct snd_uart16550 {
 	struct snd_card *card;
 	struct snd_rawmidi *rmidi;
 	struct snd_rawmidi_substream *midi_output[SNDRV_SERIAL_MAX_OUTS];
 	struct snd_rawmidi_substream *midi_input[SNDRV_SERIAL_MAX_INS];
 
-	int filemode;		//open status of file
+	int filemode;		/* open status of file */
 
 	spinlock_t open_lock;
 
@@ -140,39 +140,39 @@ typedef struct _snd_uart16550 {
 	unsigned char old_divisor_msb;
 	unsigned char old_line_ctrl_reg;
 
-	// parameter for using of write loop
-	short int fifo_limit;	//used in uart16550
-        short int fifo_count;	//used in uart16550
+	/* parameter for using of write loop */
+	short int fifo_limit;	/* used in uart16550 */
+        short int fifo_count;	/* used in uart16550 */
 
-	// type of adaptor
+	/* type of adaptor */
 	int adaptor;
 
-	// inputs
+	/* inputs */
 	int prev_in;
 	unsigned char rstatus;
 
-	// outputs
+	/* outputs */
 	int prev_out;
 	unsigned char prev_status[SNDRV_SERIAL_MAX_OUTS];
 
-	// write buffer and its writing/reading position
+	/* write buffer and its writing/reading position */
 	unsigned char tx_buff[TX_BUFF_SIZE];
 	int buff_in_count;
         int buff_in;
         int buff_out;
         int drop_on_full;
 
-	// wait timer
+	/* wait timer */
 	unsigned int timer_running:1;
 	struct timer_list buffer_timer;
 
-} snd_uart16550_t;
+};
 
 static struct platform_device *devices[SNDRV_CARDS];
 
-static inline void snd_uart16550_add_timer(snd_uart16550_t *uart)
+static inline void snd_uart16550_add_timer(struct snd_uart16550 *uart)
 {
-	if (! uart->timer_running) {
+	if (!uart->timer_running) {
 		/* timer 38600bps * 10bit * 16byte */
 		uart->buffer_timer.expires = jiffies + (HZ+255)/256;
 		uart->timer_running = 1;
@@ -180,7 +180,7 @@ static inline void snd_uart16550_add_timer(snd_uart16550_t *uart)
 	}
 }
 
-static inline void snd_uart16550_del_timer(snd_uart16550_t *uart)
+static inline void snd_uart16550_del_timer(struct snd_uart16550 *uart)
 {
 	if (uart->timer_running) {
 		del_timer(&uart->buffer_timer);
@@ -189,10 +189,10 @@ static inline void snd_uart16550_del_timer(snd_uart16550_t *uart)
 }
 
 /* This macro is only used in snd_uart16550_io_loop */
-static inline void snd_uart16550_buffer_output(snd_uart16550_t *uart)
+static inline void snd_uart16550_buffer_output(struct snd_uart16550 *uart)
 {
 	unsigned short buff_out = uart->buff_out;
-	if( uart->buff_in_count > 0 ) {
+	if (uart->buff_in_count > 0) {
 		outb(uart->tx_buff[buff_out], uart->base + UART_TX);
 		uart->fifo_count++;
 		buff_out++;
@@ -206,7 +206,7 @@ static inline void snd_uart16550_buffer_output(snd_uart16550_t *uart)
  * We don't want to interrupt this, 
  * as we're already handling an interrupt 
  */
-static void snd_uart16550_io_loop(snd_uart16550_t * uart)
+static void snd_uart16550_io_loop(struct snd_uart16550 * uart)
 {
 	unsigned char c, status;
 	int substream;
@@ -220,9 +220,8 @@ static void snd_uart16550_io_loop(snd_uart16550_t * uart)
 		c = inb(uart->base + UART_RX);
 
 		/* keep track of last status byte */
-		if (c & 0x80) {
+		if (c & 0x80)
 			uart->rstatus = c;
-		}
 
 		/* handle stream switch */
 		if (uart->adaptor == SNDRV_SERIAL_GENERIC) {
@@ -230,14 +229,16 @@ static void snd_uart16550_io_loop(snd_uart16550_t * uart)
 				if (c <= SNDRV_SERIAL_MAX_INS && c > 0)
 					substream = c - 1;
 				if (c != 0xf5)
-					uart->rstatus = 0; /* prevent future bytes from being interpreted as streams */
-			}
-			else if ((uart->filemode & SERIAL_MODE_INPUT_OPEN) && (uart->midi_input[substream] != NULL)) {
-				snd_rawmidi_receive(uart->midi_input[substream], &c, 1);
-			}
-		} else if ((uart->filemode & SERIAL_MODE_INPUT_OPEN) && (uart->midi_input[substream] != NULL)) {
+					/* prevent future bytes from being
+					   interpreted as streams */
+					uart->rstatus = 0;
+			} else if ((uart->filemode & SERIAL_MODE_INPUT_OPEN)
+				   && uart->midi_input[substream])
+				snd_rawmidi_receive(uart->midi_input[substream],
+						    &c, 1);
+		} else if ((uart->filemode & SERIAL_MODE_INPUT_OPEN) &&
+			   uart->midi_input[substream])
 			snd_rawmidi_receive(uart->midi_input[substream], &c, 1);
-		}
 
 		if (status & UART_LSR_OE)
 			snd_printk("%s: Overrun on device at 0x%lx\n",
@@ -250,21 +251,20 @@ static void snd_uart16550_io_loop(snd_uart16550_t * uart)
 	/* no need of check SERIAL_MODE_OUTPUT_OPEN because if not,
 	   buffer is never filled. */
 	/* Check write status */
-	if (status & UART_LSR_THRE) {
+	if (status & UART_LSR_THRE)
 		uart->fifo_count = 0;
-	}
 	if (uart->adaptor == SNDRV_SERIAL_MS124W_SA
 	   || uart->adaptor == SNDRV_SERIAL_GENERIC) {
 		/* Can't use FIFO, must send only when CTS is true */
 		status = inb(uart->base + UART_MSR);
-		while( (uart->fifo_count == 0) && (status & UART_MSR_CTS) &&
-		      (uart->buff_in_count > 0) ) {
+		while (uart->fifo_count == 0 && (status & UART_MSR_CTS) &&
+		       uart->buff_in_count > 0) {
 		       snd_uart16550_buffer_output(uart);
-		       status = inb( uart->base + UART_MSR );
+		       status = inb(uart->base + UART_MSR);
 		}
 	} else {
 		/* Write loop */
-		while (uart->fifo_count < uart->fifo_limit	/* Can we write ? */
+		while (uart->fifo_count < uart->fifo_limit /* Can we write ? */
 		       && uart->buff_in_count > 0)	/* Do we want to? */
 			snd_uart16550_buffer_output(uart);
 	}
@@ -294,15 +294,16 @@ static void snd_uart16550_io_loop(snd_uart16550_t * uart)
  */
 static irqreturn_t snd_uart16550_interrupt(int irq, void *dev_id)
 {
-	snd_uart16550_t *uart;
+	struct snd_uart16550 *uart;
 
-	uart = (snd_uart16550_t *) dev_id;
+	uart = dev_id;
 	spin_lock(&uart->open_lock);
 	if (uart->filemode == SERIAL_MODE_NOT_OPENED) {
 		spin_unlock(&uart->open_lock);
 		return IRQ_NONE;
 	}
-	inb(uart->base + UART_IIR);		/* indicate to the UART that the interrupt has been serviced */
+	/* indicate to the UART that the interrupt has been serviced */
+	inb(uart->base + UART_IIR);
 	snd_uart16550_io_loop(uart);
 	spin_unlock(&uart->open_lock);
 	return IRQ_HANDLED;
@@ -312,9 +313,9 @@ static irqreturn_t snd_uart16550_interrupt(int irq, void *dev_id)
 static void snd_uart16550_buffer_timer(unsigned long data)
 {
 	unsigned long flags;
-	snd_uart16550_t *uart;
+	struct snd_uart16550 *uart;
 
-	uart = (snd_uart16550_t *)data;
+	uart = (struct snd_uart16550 *)data;
 	spin_lock_irqsave(&uart->open_lock, flags);
 	snd_uart16550_del_timer(uart);
 	snd_uart16550_io_loop(uart);
@@ -326,7 +327,7 @@ static void snd_uart16550_buffer_timer(unsigned long data)
  *  return 0 if found
  *  return negative error if not found
  */
-static int __init snd_uart16550_detect(snd_uart16550_t *uart)
+static int __init snd_uart16550_detect(struct snd_uart16550 *uart)
 {
 	unsigned long io_base = uart->base;
 	int ok;
@@ -343,7 +344,8 @@ static int __init snd_uart16550_detect(snd_uart16550_t *uart)
 		return -EBUSY;
 	}
 
-	ok = 1;			/* uart detected unless one of the following tests should fail */
+	/* uart detected unless one of the following tests should fail */
+	ok = 1;
 	/* 8 data-bits, 1 stop-bit, parity off, DLAB = 0 */
 	outb(UART_LCR_WLEN8, io_base + UART_LCR); /* Line Control Register */
 	c = inb(io_base + UART_IER);
@@ -368,7 +370,7 @@ static int __init snd_uart16550_detect(snd_uart16550_t *uart)
 	return ok;
 }
 
-static void snd_uart16550_do_open(snd_uart16550_t * uart)
+static void snd_uart16550_do_open(struct snd_uart16550 * uart)
 {
 	char byte;
 
@@ -460,7 +462,7 @@ static void snd_uart16550_do_open(snd_uart16550_t * uart)
 	inb(uart->base + UART_RX);	/* Clear any pre-existing receive interrupt */
 }
 
-static void snd_uart16550_do_close(snd_uart16550_t * uart)
+static void snd_uart16550_do_close(struct snd_uart16550 * uart)
 {
 	if (uart->irq < 0)
 		snd_uart16550_del_timer(uart);
@@ -514,7 +516,7 @@ static void snd_uart16550_do_close(snd_uart16550_t * uart)
 static int snd_uart16550_input_open(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
-	snd_uart16550_t *uart = substream->rmidi->private_data;
+	struct snd_uart16550 *uart = substream->rmidi->private_data;
 
 	spin_lock_irqsave(&uart->open_lock, flags);
 	if (uart->filemode == SERIAL_MODE_NOT_OPENED)
@@ -528,7 +530,7 @@ static int snd_uart16550_input_open(struct snd_rawmidi_substream *substream)
 static int snd_uart16550_input_close(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
-	snd_uart16550_t *uart = substream->rmidi->private_data;
+	struct snd_uart16550 *uart = substream->rmidi->private_data;
 
 	spin_lock_irqsave(&uart->open_lock, flags);
 	uart->filemode &= ~SERIAL_MODE_INPUT_OPEN;
@@ -539,24 +541,24 @@ static int snd_uart16550_input_close(struct snd_rawmidi_substream *substream)
 	return 0;
 }
 
-static void snd_uart16550_input_trigger(struct snd_rawmidi_substream *substream, int up)
+static void snd_uart16550_input_trigger(struct snd_rawmidi_substream *substream,
+					int up)
 {
 	unsigned long flags;
-	snd_uart16550_t *uart = substream->rmidi->private_data;
+	struct snd_uart16550 *uart = substream->rmidi->private_data;
 
 	spin_lock_irqsave(&uart->open_lock, flags);
-	if (up) {
+	if (up)
 		uart->filemode |= SERIAL_MODE_INPUT_TRIGGERED;
-	} else {
+	else
 		uart->filemode &= ~SERIAL_MODE_INPUT_TRIGGERED;
-	}
 	spin_unlock_irqrestore(&uart->open_lock, flags);
 }
 
 static int snd_uart16550_output_open(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
-	snd_uart16550_t *uart = substream->rmidi->private_data;
+	struct snd_uart16550 *uart = substream->rmidi->private_data;
 
 	spin_lock_irqsave(&uart->open_lock, flags);
 	if (uart->filemode == SERIAL_MODE_NOT_OPENED)
@@ -570,7 +572,7 @@ static int snd_uart16550_output_open(struct snd_rawmidi_substream *substream)
 static int snd_uart16550_output_close(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
-	snd_uart16550_t *uart = substream->rmidi->private_data;
+	struct snd_uart16550 *uart = substream->rmidi->private_data;
 
 	spin_lock_irqsave(&uart->open_lock, flags);
 	uart->filemode &= ~SERIAL_MODE_OUTPUT_OPEN;
@@ -581,18 +583,20 @@ static int snd_uart16550_output_close(struct snd_rawmidi_substream *substream)
 	return 0;
 };
 
-static inline int snd_uart16550_buffer_can_write( snd_uart16550_t *uart, int Num )
+static inline int snd_uart16550_buffer_can_write(struct snd_uart16550 *uart,
+						 int Num)
 {
-	if( uart->buff_in_count + Num < TX_BUFF_SIZE )
+	if (uart->buff_in_count + Num < TX_BUFF_SIZE)
 		return 1;
 	else
 		return 0;
 }
 
-static inline int snd_uart16550_write_buffer(snd_uart16550_t *uart, unsigned char byte)
+static inline int snd_uart16550_write_buffer(struct snd_uart16550 *uart,
+					     unsigned char byte)
 {
 	unsigned short buff_in = uart->buff_in;
-	if( uart->buff_in_count < TX_BUFF_SIZE ) {
+	if (uart->buff_in_count < TX_BUFF_SIZE) {
 		uart->tx_buff[buff_in] = byte;
 		buff_in++;
 		buff_in &= TX_BUFF_MASK;
@@ -605,12 +609,14 @@ static inline int snd_uart16550_write_buffer(snd_uart16550_t *uart, unsigned cha
 		return 0;
 }
 
-static int snd_uart16550_output_byte(snd_uart16550_t *uart, struct snd_rawmidi_substream *substream, unsigned char midi_byte)
+static int snd_uart16550_output_byte(struct snd_uart16550 *uart,
+				     struct snd_rawmidi_substream *substream,
+				     unsigned char midi_byte)
 {
-	if (uart->buff_in_count == 0                            /* Buffer empty? */
+	if (uart->buff_in_count == 0                    /* Buffer empty? */
 	    && ((uart->adaptor != SNDRV_SERIAL_MS124W_SA &&
 	    uart->adaptor != SNDRV_SERIAL_GENERIC) ||
-		(uart->fifo_count == 0                               /* FIFO empty? */
+		(uart->fifo_count == 0                  /* FIFO empty? */
 		 && (inb(uart->base + UART_MSR) & UART_MSR_CTS)))) { /* CTS? */
 
 	        /* Tx Buffer Empty - try to write immediately */
@@ -623,12 +629,13 @@ static int snd_uart16550_output_byte(snd_uart16550_t *uart, struct snd_rawmidi_s
 			        uart->fifo_count++;
 				outb(midi_byte, uart->base + UART_TX);
 			} else {
-			        /* Cannot write (buffer empty) - put char in buffer */
+			        /* Cannot write (buffer empty) -
+				 * put char in buffer */
 				snd_uart16550_write_buffer(uart, midi_byte);
 			}
 		}
 	} else {
-		if( !snd_uart16550_write_buffer(uart, midi_byte) ) {
+		if (!snd_uart16550_write_buffer(uart, midi_byte)) {
 			snd_printk("%s: Buffer overrun on device at 0x%lx\n",
 				   uart->rmidi->name, uart->base);
 			return 0;
@@ -642,9 +649,9 @@ static void snd_uart16550_output_write(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
 	unsigned char midi_byte, addr_byte;
-	snd_uart16550_t *uart = substream->rmidi->private_data;
+	struct snd_uart16550 *uart = substream->rmidi->private_data;
 	char first;
-	static unsigned long lasttime=0;
+	static unsigned long lasttime = 0;
 	
 	/* Interupts are disabled during the updating of the tx_buff,
 	 * since it is 'bad' to have two processes updating the same
@@ -653,7 +660,7 @@ static void snd_uart16550_output_write(struct snd_rawmidi_substream *substream)
 
 	spin_lock_irqsave(&uart->open_lock, flags);
 
-	if (uart->irq < 0)	//polling
+	if (uart->irq < 0)	/* polling */
 		snd_uart16550_io_loop(uart);
 
 	if (uart->adaptor == SNDRV_SERIAL_MS124W_MB) {
@@ -671,7 +678,8 @@ static void snd_uart16550_output_write(struct snd_rawmidi_substream *substream)
 			/* select any combination of the four ports */
 			addr_byte = (substream->number << 4) | 0x08;
 			/* ...except none */
-			if (addr_byte == 0x08) addr_byte = 0xf8;
+			if (addr_byte == 0x08)
+				addr_byte = 0xf8;
 #endif
 			snd_uart16550_output_byte(uart, substream, addr_byte);
 			/* send midi byte */
@@ -679,31 +687,42 @@ static void snd_uart16550_output_write(struct snd_rawmidi_substream *substream)
 		}
 	} else {
 		first = 0;
-		while( 1 == snd_rawmidi_transmit_peek(substream, &midi_byte, 1) ) {
-			/* Also send F5 after 3 seconds with no data to handle device disconnect */
-			if (first == 0 && (uart->adaptor == SNDRV_SERIAL_SOUNDCANVAS ||
-				uart->adaptor == SNDRV_SERIAL_GENERIC) &&
-			   (uart->prev_out != substream->number || jiffies-lasttime > 3*HZ)) {
-
-				if( snd_uart16550_buffer_can_write( uart, 3 ) ) {
+		while (snd_rawmidi_transmit_peek(substream, &midi_byte, 1) == 1) {
+			/* Also send F5 after 3 seconds with no data
+			 * to handle device disconnect */
+			if (first == 0 &&
+			    (uart->adaptor == SNDRV_SERIAL_SOUNDCANVAS ||
+			     uart->adaptor == SNDRV_SERIAL_GENERIC) &&
+			    (uart->prev_out != substream->number ||
+			     jiffies-lasttime > 3*HZ)) {
+
+				if (snd_uart16550_buffer_can_write(uart, 3)) {
 					/* Roland Soundcanvas part selection */
-					/* If this substream of the data is different previous
-					   substream in this uart, send the change part event */
+					/* If this substream of the data is
+					 * different previous substream
+					 * in this uart, send the change part
+					 * event
+					 */
 					uart->prev_out = substream->number;
 					/* change part */
-					snd_uart16550_output_byte(uart, substream, 0xf5);
+					snd_uart16550_output_byte(uart, substream,
+								  0xf5);
 					/* data */
-					snd_uart16550_output_byte(uart, substream, uart->prev_out + 1);
-					/* If midi_byte is a data byte, send the previous status byte */
-					if ((midi_byte < 0x80) && (uart->adaptor == SNDRV_SERIAL_SOUNDCANVAS))
+					snd_uart16550_output_byte(uart, substream,
+								  uart->prev_out + 1);
+					/* If midi_byte is a data byte,
+					 * send the previous status byte */
+					if (midi_byte < 0x80 &&
+					    uart->adaptor == SNDRV_SERIAL_SOUNDCANVAS)
 						snd_uart16550_output_byte(uart, substream, uart->prev_status[uart->prev_out]);
-				} else if( !uart->drop_on_full )
+				} else if (!uart->drop_on_full)
 					break;
 
 			}
 
 			/* send midi byte */
-			if( !snd_uart16550_output_byte(uart, substream, midi_byte) && !uart->drop_on_full )
+			if (!snd_uart16550_output_byte(uart, substream, midi_byte) &&
+			    !uart->drop_on_full )
 				break;
 
 			if (midi_byte >= 0x80 && midi_byte < 0xf0)
@@ -717,17 +736,17 @@ static void snd_uart16550_output_write(struct snd_rawmidi_substream *substream)
 	spin_unlock_irqrestore(&uart->open_lock, flags);
 }
 
-static void snd_uart16550_output_trigger(struct snd_rawmidi_substream *substream, int up)
+static void snd_uart16550_output_trigger(struct snd_rawmidi_substream *substream,
+					 int up)
 {
 	unsigned long flags;
-	snd_uart16550_t *uart = substream->rmidi->private_data;
+	struct snd_uart16550 *uart = substream->rmidi->private_data;
 
 	spin_lock_irqsave(&uart->open_lock, flags);
-	if (up) {
+	if (up)
 		uart->filemode |= SERIAL_MODE_OUTPUT_TRIGGERED;
-	} else {
+	else
 		uart->filemode &= ~SERIAL_MODE_OUTPUT_TRIGGERED;
-	}
 	spin_unlock_irqrestore(&uart->open_lock, flags);
 	if (up)
 		snd_uart16550_output_write(substream);
@@ -747,10 +766,10 @@ static struct snd_rawmidi_ops snd_uart16550_input =
 	.trigger =	snd_uart16550_input_trigger,
 };
 
-static int snd_uart16550_free(snd_uart16550_t *uart)
+static int snd_uart16550_free(struct snd_uart16550 *uart)
 {
 	if (uart->irq >= 0)
-		free_irq(uart->irq, (void *)uart);
+		free_irq(uart->irq, uart);
 	release_and_free_resource(uart->res_base);
 	kfree(uart);
 	return 0;
@@ -758,7 +777,7 @@ static int snd_uart16550_free(snd_uart16550_t *uart)
 
 static int snd_uart16550_dev_free(struct snd_device *device)
 {
-	snd_uart16550_t *uart = device->device_data;
+	struct snd_uart16550 *uart = device->device_data;
 	return snd_uart16550_free(uart);
 }
 
@@ -769,12 +788,12 @@ static int __init snd_uart16550_create(struct snd_card *card,
 				       unsigned int base,
 				       int adaptor,
 				       int droponfull,
-				       snd_uart16550_t **ruart)
+				       struct snd_uart16550 **ruart)
 {
 	static struct snd_device_ops ops = {
 		.dev_free =	snd_uart16550_dev_free,
 	};
-	snd_uart16550_t *uart;
+	struct snd_uart16550 *uart;
 	int err;
 
 
@@ -795,7 +814,7 @@ static int __init snd_uart16550_create(struct snd_card *card,
 
 	if (irq >= 0 && irq != SNDRV_AUTO_IRQ) {
 		if (request_irq(irq, snd_uart16550_interrupt,
-				IRQF_DISABLED, "Serial MIDI", (void *) uart)) {
+				IRQF_DISABLED, "Serial MIDI", uart)) {
 			snd_printk("irq %d busy. Using Polling.\n", irq);
 		} else {
 			uart->irq = irq;
@@ -843,23 +862,28 @@ static int __init snd_uart16550_create(struct snd_card *card,
 
 static void __init snd_uart16550_substreams(struct snd_rawmidi_str *stream)
 {
-	struct list_head *list;
+	struct snd_rawmidi_substream *substream;
 
-	list_for_each(list, &stream->substreams) {
-		struct snd_rawmidi_substream *substream = list_entry(list, struct snd_rawmidi_substream, list);
+	list_for_each_entry(substream, &stream->substreams, list) {
 		sprintf(substream->name, "Serial MIDI %d", substream->number + 1);
 	}
 }
 
-static int __init snd_uart16550_rmidi(snd_uart16550_t *uart, int device, int outs, int ins, struct snd_rawmidi **rmidi)
+static int __init snd_uart16550_rmidi(struct snd_uart16550 *uart, int device,
+				      int outs, int ins,
+				      struct snd_rawmidi **rmidi)
 {
 	struct snd_rawmidi *rrawmidi;
 	int err;
 
-	if ((err = snd_rawmidi_new(uart->card, "UART Serial MIDI", device, outs, ins, &rrawmidi)) < 0)
+	err = snd_rawmidi_new(uart->card, "UART Serial MIDI", device,
+			      outs, ins, &rrawmidi);
+	if (err < 0)
 		return err;
-	snd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_uart16550_input);
-	snd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_uart16550_output);
+	snd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_INPUT,
+			    &snd_uart16550_input);
+	snd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,
+			    &snd_uart16550_output);
 	strcpy(rrawmidi->name, "Serial MIDI");
 	snd_uart16550_substreams(&rrawmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT]);
 	snd_uart16550_substreams(&rrawmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT]);
@@ -875,7 +899,7 @@ static int __init snd_uart16550_rmidi(snd_uart16550_t *uart, int device, int out
 static int __init snd_serial_probe(struct platform_device *devptr)
 {
 	struct snd_card *card;
-	snd_uart16550_t *uart;
+	struct snd_uart16550 *uart;
 	int err;
 	int dev = devptr->id;
 
@@ -929,7 +953,8 @@ static int __init snd_serial_probe(struct platform_device *devptr)
 					&uart)) < 0)
 		goto _err;
 
-	if ((err = snd_uart16550_rmidi(uart, 0, outs[dev], ins[dev], &uart->rmidi)) < 0)
+	err = snd_uart16550_rmidi(uart, 0, outs[dev], ins[dev], &uart->rmidi);
+	if (err < 0)
 		goto _err;
 
 	sprintf(card->longname, "%s at 0x%lx, irq %d speed %d div %d outs %d ins %d adaptor %s droponfull %d",

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 52afb4bd2079..74028b2219c2 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -292,7 +292,7 @@ static void snd_uart16550_io_loop(snd_uart16550_t * uart)
  * Note that some devices need OUT2 to be set before they will generate
  * interrupts at all. (Possibly tied to an internal pull-up on CTS?)
  */
-static irqreturn_t snd_uart16550_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_uart16550_interrupt(int irq, void *dev_id)
 {
 	snd_uart16550_t *uart;
 

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 2330fec505da..52afb4bd2079 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -795,7 +795,7 @@ static int __init snd_uart16550_create(struct snd_card *card,
 
 	if (irq >= 0 && irq != SNDRV_AUTO_IRQ) {
 		if (request_irq(irq, snd_uart16550_interrupt,
-				SA_INTERRUPT, "Serial MIDI", (void *) uart)) {
+				IRQF_DISABLED, "Serial MIDI", (void *) uart)) {
 			snd_printk("irq %d busy. Using Polling.\n", irq);
 		} else {
 			uart->irq = irq;

commit 7152447df98b3981d621224be947a2c8d77aed06
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Thu Apr 13 12:58:06 2006 +0200

    [ALSA] unregister platform device again if probe was unsuccessful
    
    This second one unregisters the platform device again when the probe is
    unsuccesful for sound/drivers, sound/arm/sa11xx-uda1341.c and
    sound/ppc/powermac.c. This gets them all.
    
    Signed-off-by: Rene Herman <rene.herman@keyaccess.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index c01b4c5118b9..2330fec505da 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -998,6 +998,10 @@ static int __init alsa_card_serial_init(void)
 							 i, NULL, 0);
 		if (IS_ERR(device))
 			continue;
+		if (!platform_get_drvdata(device)) {
+			platform_device_unregister(device);
+			continue;
+		}
 		devices[i] = device;
 		cards++;
 	}

commit a182ee9876c7826d0b8f7789cb5c38c5bfbec441
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Thu Apr 13 12:57:11 2006 +0200

    [ALSA] continue on IS_ERR from platform device registration
    
    I previously only concerned myself with sound/isa. When I now checked
    for more platform_device_register_simple() usages in ALSA I found a
    couple more drivers that needed the same patches as already submitted
    for all the ISA drivers.
    This first one is the continue-on-iserr patch for sound/drivers. This
    gets them all.
    
    Signed-off-by: Rene Herman <rene.herman@keyaccess.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 1a7fbefe4740..c01b4c5118b9 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -996,10 +996,8 @@ static int __init alsa_card_serial_init(void)
 			continue;
 		device = platform_device_register_simple(SND_SERIAL_DRIVER,
 							 i, NULL, 0);
-		if (IS_ERR(device)) {
-			err = PTR_ERR(device);
-			goto errout;
-		}
+		if (IS_ERR(device))
+			continue;
 		devices[i] = device;
 		cards++;
 	}
@@ -1007,14 +1005,10 @@ static int __init alsa_card_serial_init(void)
 #ifdef MODULE
 		printk(KERN_ERR "serial midi soundcard not found or device busy\n");
 #endif
-		err = -ENODEV;
-		goto errout;
+		snd_serial_unregister_all();
+		return -ENODEV;
 	}
 	return 0;
-
- errout:
-	snd_serial_unregister_all();
-	return err;
 }
 
 static void __exit alsa_card_serial_exit(void)

commit 202728d783a0fc180e7141d18186eeae167218a1
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Mar 14 09:44:19 2006 +0100

    [ALSA] fix some memory leaks
    
    Modules: Generic drivers,ES18xx driver,CS46xx driver
    
    This patch fixes two memory leaks spotted by the Coverity checker.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 13b46d12564a..1a7fbefe4740 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -789,6 +789,7 @@ static int __init snd_uart16550_create(struct snd_card *card,
 
 	if ((err = snd_uart16550_detect(uart)) <= 0) {
 		printk(KERN_ERR "no UART detected at 0x%lx\n", iobase);
+		snd_uart16550_free(uart);
 		return -ENODEV;
 	}
 

commit 8278ca8feb2748cf02d756ac6c5b9ab2e047c84a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 20 11:57:34 2006 +0100

    [ALSA] Fix check of enable module option
    
    Fix the check of enable module option in probe of platform_device drivers.
    It shouldn't break the loop but just ignore if enable[i] is false.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 112ddf705402..13b46d12564a 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -989,8 +989,10 @@ static int __init alsa_card_serial_init(void)
 		return err;
 
 	cards = 0;
-	for (i = 0; i < SNDRV_CARDS && enable[i]; i++) {
+	for (i = 0; i < SNDRV_CARDS; i++) {
 		struct platform_device *device;
+		if (! enable[i])
+			continue;
 		device = platform_device_register_simple(SND_SERIAL_DRIVER,
 							 i, NULL, 0);
 		if (IS_ERR(device)) {

commit 68b8bc05213567cfc58d8bdb8917b36c314ba7fd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 23 15:21:28 2006 +0100

    [ALSA] serial-uart16550 - Fix a compile warning
    
    Modules: Generic drivers
    
    Fix a gcc-4.1 compile warning regarding uninitialized variables.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 29676d800cae..112ddf705402 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -789,7 +789,7 @@ static int __init snd_uart16550_create(struct snd_card *card,
 
 	if ((err = snd_uart16550_detect(uart)) <= 0) {
 		printk(KERN_ERR "no UART detected at 0x%lx\n", iobase);
-		return err;
+		return -ENODEV;
 	}
 
 	if (irq >= 0 && irq != SNDRV_AUTO_IRQ) {

commit f7a9275d949cb0bf1f259a1546e52a0bf518151c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Dec 7 09:13:42 2005 +0100

    [ALSA] unregister platform devices
    
    Call platform_device_unregister() for all platform devices that we've
    registered.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 3381a43c592e..29676d800cae 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -168,6 +168,8 @@ typedef struct _snd_uart16550 {
 
 } snd_uart16550_t;
 
+static struct platform_device *devices[SNDRV_CARDS];
+
 static inline void snd_uart16550_add_timer(snd_uart16550_t *uart)
 {
 	if (! uart->timer_running) {
@@ -970,6 +972,15 @@ static struct platform_driver snd_serial_driver = {
 	},
 };
 
+static void __init_or_module snd_serial_unregister_all(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(devices); ++i)
+		platform_device_unregister(devices[i]);
+	platform_driver_unregister(&snd_serial_driver);
+}
+
 static int __init alsa_card_serial_init(void)
 {
 	int i, cards, err;
@@ -986,6 +997,7 @@ static int __init alsa_card_serial_init(void)
 			err = PTR_ERR(device);
 			goto errout;
 		}
+		devices[i] = device;
 		cards++;
 	}
 	if (! cards) {
@@ -998,13 +1010,13 @@ static int __init alsa_card_serial_init(void)
 	return 0;
 
  errout:
-	platform_driver_unregister(&snd_serial_driver);
+	snd_serial_unregister_all();
 	return err;
 }
 
 static void __exit alsa_card_serial_exit(void)
 {
-	platform_driver_unregister(&snd_serial_driver);
+	snd_serial_unregister_all();
 }
 
 module_init(alsa_card_serial_init)

commit 9caf6b5908e1e3b10478e9201ca1be809145253f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 16:02:30 2005 +0100

    [ALSA] serial-u16550 - Use platform_device
    
    Modules: Generic drivers
    
    Rewrite the probe/remove code using platform_device.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index ec28587247f4..3381a43c592e 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -33,6 +33,8 @@
 #include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/ioport.h>
 #include <linux/moduleparam.h>
@@ -166,8 +168,6 @@ typedef struct _snd_uart16550 {
 
 } snd_uart16550_t;
 
-static struct snd_card *snd_serial_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
-
 static inline void snd_uart16550_add_timer(snd_uart16550_t *uart)
 {
 	if (! uart->timer_running) {
@@ -869,14 +869,12 @@ static int __init snd_uart16550_rmidi(snd_uart16550_t *uart, int device, int out
 	return 0;
 }
 
-static int __init snd_serial_probe(int dev)
+static int __init snd_serial_probe(struct platform_device *devptr)
 {
 	struct snd_card *card;
 	snd_uart16550_t *uart;
 	int err;
-
-	if (!enable[dev])
-		return -ENOENT;
+	int dev = devptr->id;
 
 	switch (adaptor[dev]) {
 	case SNDRV_SERIAL_SOUNDCANVAS:
@@ -942,13 +940,12 @@ static int __init snd_serial_probe(int dev)
 		adaptor_names[uart->adaptor],
 		uart->drop_on_full);
 
-	if ((err = snd_card_set_generic_dev(card)) < 0)
-		goto _err;
+	snd_card_set_dev(card, &devptr->dev);
 
 	if ((err = snd_card_register(card)) < 0)
 		goto _err;
 
-	snd_serial_cards[dev] = card;
+	platform_set_drvdata(devptr, card);
 	return 0;
 
  _err:
@@ -956,33 +953,58 @@ static int __init snd_serial_probe(int dev)
 	return err;
 }
 
+static int snd_serial_remove(struct platform_device *devptr)
+{
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+	return 0;
+}
+
+#define SND_SERIAL_DRIVER	"snd_serial_u16550"
+
+static struct platform_driver snd_serial_driver = {
+	.probe		= snd_serial_probe,
+	.remove		= snd_serial_remove,
+	.driver		= {
+		.name	= SND_SERIAL_DRIVER
+	},
+};
+
 static int __init alsa_card_serial_init(void)
 {
-	int dev = 0;
-	int cards = 0;
+	int i, cards, err;
 
-	for (dev = 0; dev < SNDRV_CARDS; dev++) {
-		if (snd_serial_probe(dev) == 0)
-			cards++;
-	}
+	if ((err = platform_driver_register(&snd_serial_driver)) < 0)
+		return err;
 
-	if (cards == 0) {
+	cards = 0;
+	for (i = 0; i < SNDRV_CARDS && enable[i]; i++) {
+		struct platform_device *device;
+		device = platform_device_register_simple(SND_SERIAL_DRIVER,
+							 i, NULL, 0);
+		if (IS_ERR(device)) {
+			err = PTR_ERR(device);
+			goto errout;
+		}
+		cards++;
+	}
+	if (! cards) {
 #ifdef MODULE
 		printk(KERN_ERR "serial midi soundcard not found or device busy\n");
 #endif
-		return -ENODEV;
+		err = -ENODEV;
+		goto errout;
 	}
 	return 0;
+
+ errout:
+	platform_driver_unregister(&snd_serial_driver);
+	return err;
 }
 
 static void __exit alsa_card_serial_exit(void)
 {
-	int dev;
-
-	for (dev = 0; dev < SNDRV_CARDS; dev++) {
-		if (snd_serial_cards[dev] != NULL)
-			snd_card_free(snd_serial_cards[dev]);
-	}
+	platform_driver_unregister(&snd_serial_driver);
 }
 
 module_init(alsa_card_serial_init)

commit 4a4d2cfd8cbca3076742547157ea135d0be77928
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:27:28 2005 +0100

    [ALSA] Remove xxx_t typedefs: Generic drivers
    
    Modules: Generic drivers
    
    Remove xxx_t typedefs from the generic drivers
    (dummy, mtpav, serial-u16550 and virmidi).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 1ed58df42671..ec28587247f4 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -116,10 +116,10 @@ MODULE_PARM_DESC(adaptor, "Type of adaptor.");
 #define SERIAL_MODE_OUTPUT_TRIGGERED	(1 << 3)
 
 typedef struct _snd_uart16550 {
-	snd_card_t *card;
-	snd_rawmidi_t *rmidi;
-	snd_rawmidi_substream_t *midi_output[SNDRV_SERIAL_MAX_OUTS];
-	snd_rawmidi_substream_t *midi_input[SNDRV_SERIAL_MAX_INS];
+	struct snd_card *card;
+	struct snd_rawmidi *rmidi;
+	struct snd_rawmidi_substream *midi_output[SNDRV_SERIAL_MAX_OUTS];
+	struct snd_rawmidi_substream *midi_input[SNDRV_SERIAL_MAX_INS];
 
 	int filemode;		//open status of file
 
@@ -166,7 +166,7 @@ typedef struct _snd_uart16550 {
 
 } snd_uart16550_t;
 
-static snd_card_t *snd_serial_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
+static struct snd_card *snd_serial_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
 
 static inline void snd_uart16550_add_timer(snd_uart16550_t *uart)
 {
@@ -509,7 +509,7 @@ static void snd_uart16550_do_close(snd_uart16550_t * uart)
 	}
 }
 
-static int snd_uart16550_input_open(snd_rawmidi_substream_t * substream)
+static int snd_uart16550_input_open(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
 	snd_uart16550_t *uart = substream->rmidi->private_data;
@@ -523,7 +523,7 @@ static int snd_uart16550_input_open(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static int snd_uart16550_input_close(snd_rawmidi_substream_t * substream)
+static int snd_uart16550_input_close(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
 	snd_uart16550_t *uart = substream->rmidi->private_data;
@@ -537,7 +537,7 @@ static int snd_uart16550_input_close(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static void snd_uart16550_input_trigger(snd_rawmidi_substream_t * substream, int up)
+static void snd_uart16550_input_trigger(struct snd_rawmidi_substream *substream, int up)
 {
 	unsigned long flags;
 	snd_uart16550_t *uart = substream->rmidi->private_data;
@@ -551,7 +551,7 @@ static void snd_uart16550_input_trigger(snd_rawmidi_substream_t * substream, int
 	spin_unlock_irqrestore(&uart->open_lock, flags);
 }
 
-static int snd_uart16550_output_open(snd_rawmidi_substream_t * substream)
+static int snd_uart16550_output_open(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
 	snd_uart16550_t *uart = substream->rmidi->private_data;
@@ -565,7 +565,7 @@ static int snd_uart16550_output_open(snd_rawmidi_substream_t * substream)
 	return 0;
 };
 
-static int snd_uart16550_output_close(snd_rawmidi_substream_t * substream)
+static int snd_uart16550_output_close(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
 	snd_uart16550_t *uart = substream->rmidi->private_data;
@@ -603,7 +603,7 @@ static inline int snd_uart16550_write_buffer(snd_uart16550_t *uart, unsigned cha
 		return 0;
 }
 
-static int snd_uart16550_output_byte(snd_uart16550_t *uart, snd_rawmidi_substream_t * substream, unsigned char midi_byte)
+static int snd_uart16550_output_byte(snd_uart16550_t *uart, struct snd_rawmidi_substream *substream, unsigned char midi_byte)
 {
 	if (uart->buff_in_count == 0                            /* Buffer empty? */
 	    && ((uart->adaptor != SNDRV_SERIAL_MS124W_SA &&
@@ -636,7 +636,7 @@ static int snd_uart16550_output_byte(snd_uart16550_t *uart, snd_rawmidi_substrea
 	return 1;
 }
 
-static void snd_uart16550_output_write(snd_rawmidi_substream_t * substream)
+static void snd_uart16550_output_write(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
 	unsigned char midi_byte, addr_byte;
@@ -715,7 +715,7 @@ static void snd_uart16550_output_write(snd_rawmidi_substream_t * substream)
 	spin_unlock_irqrestore(&uart->open_lock, flags);
 }
 
-static void snd_uart16550_output_trigger(snd_rawmidi_substream_t * substream, int up)
+static void snd_uart16550_output_trigger(struct snd_rawmidi_substream *substream, int up)
 {
 	unsigned long flags;
 	snd_uart16550_t *uart = substream->rmidi->private_data;
@@ -731,14 +731,14 @@ static void snd_uart16550_output_trigger(snd_rawmidi_substream_t * substream, in
 		snd_uart16550_output_write(substream);
 }
 
-static snd_rawmidi_ops_t snd_uart16550_output =
+static struct snd_rawmidi_ops snd_uart16550_output =
 {
 	.open =		snd_uart16550_output_open,
 	.close =	snd_uart16550_output_close,
 	.trigger =	snd_uart16550_output_trigger,
 };
 
-static snd_rawmidi_ops_t snd_uart16550_input =
+static struct snd_rawmidi_ops snd_uart16550_input =
 {
 	.open =		snd_uart16550_input_open,
 	.close =	snd_uart16550_input_close,
@@ -754,13 +754,13 @@ static int snd_uart16550_free(snd_uart16550_t *uart)
 	return 0;
 };
 
-static int snd_uart16550_dev_free(snd_device_t *device)
+static int snd_uart16550_dev_free(struct snd_device *device)
 {
 	snd_uart16550_t *uart = device->device_data;
 	return snd_uart16550_free(uart);
 }
 
-static int __init snd_uart16550_create(snd_card_t * card,
+static int __init snd_uart16550_create(struct snd_card *card,
 				       unsigned long iobase,
 				       int irq,
 				       unsigned int speed,
@@ -769,7 +769,7 @@ static int __init snd_uart16550_create(snd_card_t * card,
 				       int droponfull,
 				       snd_uart16550_t **ruart)
 {
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free =	snd_uart16550_dev_free,
 	};
 	snd_uart16550_t *uart;
@@ -838,19 +838,19 @@ static int __init snd_uart16550_create(snd_card_t * card,
 	return 0;
 }
 
-static void __init snd_uart16550_substreams(snd_rawmidi_str_t *stream)
+static void __init snd_uart16550_substreams(struct snd_rawmidi_str *stream)
 {
 	struct list_head *list;
 
 	list_for_each(list, &stream->substreams) {
-		snd_rawmidi_substream_t *substream = list_entry(list, snd_rawmidi_substream_t, list);
+		struct snd_rawmidi_substream *substream = list_entry(list, struct snd_rawmidi_substream, list);
 		sprintf(substream->name, "Serial MIDI %d", substream->number + 1);
 	}
 }
 
-static int __init snd_uart16550_rmidi(snd_uart16550_t *uart, int device, int outs, int ins, snd_rawmidi_t **rmidi)
+static int __init snd_uart16550_rmidi(snd_uart16550_t *uart, int device, int outs, int ins, struct snd_rawmidi **rmidi)
 {
-	snd_rawmidi_t *rrawmidi;
+	struct snd_rawmidi *rrawmidi;
 	int err;
 
 	if ((err = snd_rawmidi_new(uart->card, "UART Serial MIDI", device, outs, ins, &rrawmidi)) < 0)
@@ -871,7 +871,7 @@ static int __init snd_uart16550_rmidi(snd_uart16550_t *uart, int device, int out
 
 static int __init snd_serial_probe(int dev)
 {
-	snd_card_t *card;
+	struct snd_card *card;
 	snd_uart16550_t *uart;
 	int err;
 

commit b1d5776d865951c213a1caaab5d8bf5de7615dbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:56:31 2005 +0200

    [ALSA] Remove vmalloc wrapper, kfree_nocheck()
    
    - Remove vmalloc wrapper
    - Add release_and_free_resource() to remove kfree_nocheck() from each driver
      and simplify the code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 416172ea1f47..1ed58df42671 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -749,10 +749,7 @@ static int snd_uart16550_free(snd_uart16550_t *uart)
 {
 	if (uart->irq >= 0)
 		free_irq(uart->irq, (void *)uart);
-	if (uart->res_base) {
-		release_resource(uart->res_base);
-		kfree_nocheck(uart->res_base);
-	}
+	release_and_free_resource(uart->res_base);
 	kfree(uart);
 	return 0;
 };

commit 561b220a4dece18d67177413e6fa21b49aa4acce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:22:34 2005 +0200

    [ALSA] Replace with kzalloc() - others
    
    Documentation,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,OPL3
    OPL4,Digigram VX core,I2C cs8427,I2C lib core,I2C tea6330t,L3 drivers
    AK4114 receiver,AK4117 receiver,PDAudioCF driver,PPC PMAC driver
    SPARC AMD7930 driver,SPARC cs4231 driver,Synth,Common EMU synth
    USB generic driver,USB USX2Y
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index fd3bb9dd1d24..416172ea1f47 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -779,7 +779,7 @@ static int __init snd_uart16550_create(snd_card_t * card,
 	int err;
 
 
-	if ((uart = kcalloc(1, sizeof(*uart), GFP_KERNEL)) == NULL)
+	if ((uart = kzalloc(sizeof(*uart), GFP_KERNEL)) == NULL)
 		return -ENOMEM;
 	uart->adaptor = adaptor;
 	uart->card = card;

commit 16dab54b8cbac39bd3f639db5d7d0fd8300a6cb0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 5 17:17:58 2005 +0200

    [ALSA] Add snd_card_set_generic_dev() call
    
    ARM,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,MIPS
    MIPS AU1x00 driver,PPC,PPC PowerMac driver,SPARC,SPARC AMD7930 driver
    SPARC cs4231 driver,SPARC DBRI driver
    - Added snd_card_set_generic_dev() call.
    - Added SND_GENERIC_DRIVER to Kconfig.
    - Clean up the error path in probe if necessary.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 986df35fb829..fd3bb9dd1d24 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -928,15 +928,11 @@ static int __init snd_serial_probe(int dev)
 					base[dev],
 					adaptor[dev],
 					droponfull[dev],
-					&uart)) < 0) {
-		snd_card_free(card);
-		return err;
-	}
+					&uart)) < 0)
+		goto _err;
 
-	if ((err = snd_uart16550_rmidi(uart, 0, outs[dev], ins[dev], &uart->rmidi)) < 0) {
-		snd_card_free(card);
-		return err;
-	}
+	if ((err = snd_uart16550_rmidi(uart, 0, outs[dev], ins[dev], &uart->rmidi)) < 0)
+		goto _err;
 
 	sprintf(card->longname, "%s at 0x%lx, irq %d speed %d div %d outs %d ins %d adaptor %s droponfull %d",
 		card->shortname,
@@ -949,12 +945,18 @@ static int __init snd_serial_probe(int dev)
 		adaptor_names[uart->adaptor],
 		uart->drop_on_full);
 
-	if ((err = snd_card_register(card)) < 0) {
-		snd_card_free(card);
-		return err;
-	}
+	if ((err = snd_card_set_generic_dev(card)) < 0)
+		goto _err;
+
+	if ((err = snd_card_register(card)) < 0)
+		goto _err;
+
 	snd_serial_cards[dev] = card;
 	return 0;
+
+ _err:
+	snd_card_free(card);
+	return err;
 }
 
 static int __init alsa_card_serial_init(void)

commit 77933d7276ee8fa0e2947641941a6f7a100a327b
Author: Jesper Juhl <juhl@dif.dk>
Date:   Wed Jul 27 11:46:09 2005 -0700

    [PATCH] clean up inline static vs static inline
    
    `gcc -W' likes to complain if the static keyword is not at the beginning of
    the declaration.  This patch fixes all remaining occurrences of "inline
    static" up with "static inline" in the entire kernel tree (140 occurrences in
    47 files).
    
    While making this change I came across a few lines with trailing whitespace
    that I also fixed up, I have also added or removed a blank line or two here
    and there, but there are no functional changes in the patch.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
index 964b97e70c84..986df35fb829 100644
--- a/sound/drivers/serial-u16550.c
+++ b/sound/drivers/serial-u16550.c
@@ -168,7 +168,7 @@ typedef struct _snd_uart16550 {
 
 static snd_card_t *snd_serial_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
 
-inline static void snd_uart16550_add_timer(snd_uart16550_t *uart)
+static inline void snd_uart16550_add_timer(snd_uart16550_t *uart)
 {
 	if (! uart->timer_running) {
 		/* timer 38600bps * 10bit * 16byte */
@@ -178,7 +178,7 @@ inline static void snd_uart16550_add_timer(snd_uart16550_t *uart)
 	}
 }
 
-inline static void snd_uart16550_del_timer(snd_uart16550_t *uart)
+static inline void snd_uart16550_del_timer(snd_uart16550_t *uart)
 {
 	if (uart->timer_running) {
 		del_timer(&uart->buffer_timer);
@@ -187,7 +187,7 @@ inline static void snd_uart16550_del_timer(snd_uart16550_t *uart)
 }
 
 /* This macro is only used in snd_uart16550_io_loop */
-inline static void snd_uart16550_buffer_output(snd_uart16550_t *uart)
+static inline void snd_uart16550_buffer_output(snd_uart16550_t *uart)
 {
 	unsigned short buff_out = uart->buff_out;
 	if( uart->buff_in_count > 0 ) {
@@ -579,7 +579,7 @@ static int snd_uart16550_output_close(snd_rawmidi_substream_t * substream)
 	return 0;
 };
 
-inline static int snd_uart16550_buffer_can_write( snd_uart16550_t *uart, int Num )
+static inline int snd_uart16550_buffer_can_write( snd_uart16550_t *uart, int Num )
 {
 	if( uart->buff_in_count + Num < TX_BUFF_SIZE )
 		return 1;
@@ -587,7 +587,7 @@ inline static int snd_uart16550_buffer_can_write( snd_uart16550_t *uart, int Num
 		return 0;
 }
 
-inline static int snd_uart16550_write_buffer(snd_uart16550_t *uart, unsigned char byte)
+static inline int snd_uart16550_write_buffer(snd_uart16550_t *uart, unsigned char byte)
 {
 	unsigned short buff_in = uart->buff_in;
 	if( uart->buff_in_count < TX_BUFF_SIZE ) {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/drivers/serial-u16550.c b/sound/drivers/serial-u16550.c
new file mode 100644
index 000000000000..964b97e70c84
--- /dev/null
+++ b/sound/drivers/serial-u16550.c
@@ -0,0 +1,990 @@
+/*
+ *   serial.c
+ *   Copyright (c) by Jaroslav Kysela <perex@suse.cz>,
+ *                    Isaku Yamahata <yamahata@private.email.ne.jp>,
+ *		      George Hansper <ghansper@apana.org.au>,
+ *		      Hannu Savolainen
+ *
+ *   This code is based on the code from ALSA 0.5.9, but heavily rewritten.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * Sat Mar 31 17:27:57 PST 2001 tim.mann@compaq.com 
+ *      Added support for the Midiator MS-124T and for the MS-124W in
+ *      Single Addressed (S/A) or Multiple Burst (M/B) mode, with
+ *      power derived either parasitically from the serial port or
+ *      from a separate power supply.
+ *
+ *      More documentation can be found in serial-u16550.txt.
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/rawmidi.h>
+#include <sound/initval.h>
+
+#include <linux/serial_reg.h>
+
+#include <asm/io.h>
+
+MODULE_DESCRIPTION("MIDI serial u16550");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{ALSA, MIDI serial u16550}}");
+
+#define SNDRV_SERIAL_SOUNDCANVAS 0 /* Roland Soundcanvas; F5 NN selects part */
+#define SNDRV_SERIAL_MS124T 1      /* Midiator MS-124T */
+#define SNDRV_SERIAL_MS124W_SA 2   /* Midiator MS-124W in S/A mode */
+#define SNDRV_SERIAL_MS124W_MB 3   /* Midiator MS-124W in M/B mode */
+#define SNDRV_SERIAL_GENERIC 4     /* Generic Interface */
+#define SNDRV_SERIAL_MAX_ADAPTOR SNDRV_SERIAL_GENERIC
+static char *adaptor_names[] = {
+	"Soundcanvas",
+        "MS-124T",
+	"MS-124W S/A",
+	"MS-124W M/B",
+	"Generic"
+};
+
+#define SNDRV_SERIAL_NORMALBUFF 0 /* Normal blocking buffer operation */
+#define SNDRV_SERIAL_DROPBUFF   1 /* Non-blocking discard operation */
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE; /* Enable this card */
+static long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT; /* 0x3f8,0x2f8,0x3e8,0x2e8 */
+static int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ; 	/* 3,4,5,7,9,10,11,14,15 */
+static int speed[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 38400}; /* 9600,19200,38400,57600,115200 */
+static int base[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 115200}; /* baud base */
+static int outs[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};	 /* 1 to 16 */
+static int ins[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1};	/* 1 to 16 */
+static int adaptor[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = SNDRV_SERIAL_SOUNDCANVAS};
+static int droponfull[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS -1)] = SNDRV_SERIAL_NORMALBUFF };
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for Serial MIDI.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for Serial MIDI.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable UART16550A chip.");
+module_param_array(port, long, NULL, 0444);
+MODULE_PARM_DESC(port, "Port # for UART16550A chip.");
+module_param_array(irq, int, NULL, 0444);
+MODULE_PARM_DESC(irq, "IRQ # for UART16550A chip.");
+module_param_array(speed, int, NULL, 0444);
+MODULE_PARM_DESC(speed, "Speed in bauds.");
+module_param_array(base, int, NULL, 0444);
+MODULE_PARM_DESC(base, "Base for divisor in bauds.");
+module_param_array(outs, int, NULL, 0444);
+MODULE_PARM_DESC(outs, "Number of MIDI outputs.");
+module_param_array(ins, int, NULL, 0444);
+MODULE_PARM_DESC(ins, "Number of MIDI inputs.");
+module_param_array(droponfull, bool, NULL, 0444);
+MODULE_PARM_DESC(droponfull, "Flag to enable drop-on-full buffer mode");
+
+module_param_array(adaptor, int, NULL, 0444);
+MODULE_PARM_DESC(adaptor, "Type of adaptor.");
+
+/*#define SNDRV_SERIAL_MS124W_MB_NOCOMBO 1*/  /* Address outs as 0-3 instead of bitmap */
+
+#define SNDRV_SERIAL_MAX_OUTS	16		/* max 64, min 16 */
+#define SNDRV_SERIAL_MAX_INS	16		/* max 64, min 16 */
+
+#define TX_BUFF_SIZE		(1<<15)		/* Must be 2^n */
+#define TX_BUFF_MASK		(TX_BUFF_SIZE - 1)
+
+#define SERIAL_MODE_NOT_OPENED 		(0)
+#define SERIAL_MODE_INPUT_OPEN		(1 << 0)
+#define SERIAL_MODE_OUTPUT_OPEN		(1 << 1)
+#define SERIAL_MODE_INPUT_TRIGGERED	(1 << 2)
+#define SERIAL_MODE_OUTPUT_TRIGGERED	(1 << 3)
+
+typedef struct _snd_uart16550 {
+	snd_card_t *card;
+	snd_rawmidi_t *rmidi;
+	snd_rawmidi_substream_t *midi_output[SNDRV_SERIAL_MAX_OUTS];
+	snd_rawmidi_substream_t *midi_input[SNDRV_SERIAL_MAX_INS];
+
+	int filemode;		//open status of file
+
+	spinlock_t open_lock;
+
+	int irq;
+
+	unsigned long base;
+	struct resource *res_base;
+
+	unsigned int speed;
+	unsigned int speed_base;
+	unsigned char divisor;
+
+	unsigned char old_divisor_lsb;
+	unsigned char old_divisor_msb;
+	unsigned char old_line_ctrl_reg;
+
+	// parameter for using of write loop
+	short int fifo_limit;	//used in uart16550
+        short int fifo_count;	//used in uart16550
+
+	// type of adaptor
+	int adaptor;
+
+	// inputs
+	int prev_in;
+	unsigned char rstatus;
+
+	// outputs
+	int prev_out;
+	unsigned char prev_status[SNDRV_SERIAL_MAX_OUTS];
+
+	// write buffer and its writing/reading position
+	unsigned char tx_buff[TX_BUFF_SIZE];
+	int buff_in_count;
+        int buff_in;
+        int buff_out;
+        int drop_on_full;
+
+	// wait timer
+	unsigned int timer_running:1;
+	struct timer_list buffer_timer;
+
+} snd_uart16550_t;
+
+static snd_card_t *snd_serial_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
+
+inline static void snd_uart16550_add_timer(snd_uart16550_t *uart)
+{
+	if (! uart->timer_running) {
+		/* timer 38600bps * 10bit * 16byte */
+		uart->buffer_timer.expires = jiffies + (HZ+255)/256;
+		uart->timer_running = 1;
+		add_timer(&uart->buffer_timer);
+	}
+}
+
+inline static void snd_uart16550_del_timer(snd_uart16550_t *uart)
+{
+	if (uart->timer_running) {
+		del_timer(&uart->buffer_timer);
+		uart->timer_running = 0;
+	}
+}
+
+/* This macro is only used in snd_uart16550_io_loop */
+inline static void snd_uart16550_buffer_output(snd_uart16550_t *uart)
+{
+	unsigned short buff_out = uart->buff_out;
+	if( uart->buff_in_count > 0 ) {
+		outb(uart->tx_buff[buff_out], uart->base + UART_TX);
+		uart->fifo_count++;
+		buff_out++;
+		buff_out &= TX_BUFF_MASK;
+		uart->buff_out = buff_out;
+		uart->buff_in_count--;
+	}
+}
+
+/* This loop should be called with interrupts disabled
+ * We don't want to interrupt this, 
+ * as we're already handling an interrupt 
+ */
+static void snd_uart16550_io_loop(snd_uart16550_t * uart)
+{
+	unsigned char c, status;
+	int substream;
+
+	/* recall previous stream */
+	substream = uart->prev_in;
+
+	/* Read Loop */
+	while ((status = inb(uart->base + UART_LSR)) & UART_LSR_DR) {
+		/* while receive data ready */
+		c = inb(uart->base + UART_RX);
+
+		/* keep track of last status byte */
+		if (c & 0x80) {
+			uart->rstatus = c;
+		}
+
+		/* handle stream switch */
+		if (uart->adaptor == SNDRV_SERIAL_GENERIC) {
+			if (uart->rstatus == 0xf5) {
+				if (c <= SNDRV_SERIAL_MAX_INS && c > 0)
+					substream = c - 1;
+				if (c != 0xf5)
+					uart->rstatus = 0; /* prevent future bytes from being interpreted as streams */
+			}
+			else if ((uart->filemode & SERIAL_MODE_INPUT_OPEN) && (uart->midi_input[substream] != NULL)) {
+				snd_rawmidi_receive(uart->midi_input[substream], &c, 1);
+			}
+		} else if ((uart->filemode & SERIAL_MODE_INPUT_OPEN) && (uart->midi_input[substream] != NULL)) {
+			snd_rawmidi_receive(uart->midi_input[substream], &c, 1);
+		}
+
+		if (status & UART_LSR_OE)
+			snd_printk("%s: Overrun on device at 0x%lx\n",
+			       uart->rmidi->name, uart->base);
+	}
+
+	/* remember the last stream */
+	uart->prev_in = substream;
+
+	/* no need of check SERIAL_MODE_OUTPUT_OPEN because if not,
+	   buffer is never filled. */
+	/* Check write status */
+	if (status & UART_LSR_THRE) {
+		uart->fifo_count = 0;
+	}
+	if (uart->adaptor == SNDRV_SERIAL_MS124W_SA
+	   || uart->adaptor == SNDRV_SERIAL_GENERIC) {
+		/* Can't use FIFO, must send only when CTS is true */
+		status = inb(uart->base + UART_MSR);
+		while( (uart->fifo_count == 0) && (status & UART_MSR_CTS) &&
+		      (uart->buff_in_count > 0) ) {
+		       snd_uart16550_buffer_output(uart);
+		       status = inb( uart->base + UART_MSR );
+		}
+	} else {
+		/* Write loop */
+		while (uart->fifo_count < uart->fifo_limit	/* Can we write ? */
+		       && uart->buff_in_count > 0)	/* Do we want to? */
+			snd_uart16550_buffer_output(uart);
+	}
+	if (uart->irq < 0 && uart->buff_in_count > 0)
+		snd_uart16550_add_timer(uart);
+}
+
+/* NOTES ON SERVICING INTERUPTS
+ * ---------------------------
+ * After receiving a interrupt, it is important to indicate to the UART that
+ * this has been done. 
+ * For a Rx interrupt, this is done by reading the received byte.
+ * For a Tx interrupt this is done by either:
+ * a) Writing a byte
+ * b) Reading the IIR
+ * It is particularly important to read the IIR if a Tx interrupt is received
+ * when there is no data in tx_buff[], as in this case there no other
+ * indication that the interrupt has been serviced, and it remains outstanding
+ * indefinitely. This has the curious side effect that and no further interrupts
+ * will be generated from this device AT ALL!!.
+ * It is also desirable to clear outstanding interrupts when the device is
+ * opened/closed.
+ *
+ *
+ * Note that some devices need OUT2 to be set before they will generate
+ * interrupts at all. (Possibly tied to an internal pull-up on CTS?)
+ */
+static irqreturn_t snd_uart16550_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	snd_uart16550_t *uart;
+
+	uart = (snd_uart16550_t *) dev_id;
+	spin_lock(&uart->open_lock);
+	if (uart->filemode == SERIAL_MODE_NOT_OPENED) {
+		spin_unlock(&uart->open_lock);
+		return IRQ_NONE;
+	}
+	inb(uart->base + UART_IIR);		/* indicate to the UART that the interrupt has been serviced */
+	snd_uart16550_io_loop(uart);
+	spin_unlock(&uart->open_lock);
+	return IRQ_HANDLED;
+}
+
+/* When the polling mode, this function calls snd_uart16550_io_loop. */
+static void snd_uart16550_buffer_timer(unsigned long data)
+{
+	unsigned long flags;
+	snd_uart16550_t *uart;
+
+	uart = (snd_uart16550_t *)data;
+	spin_lock_irqsave(&uart->open_lock, flags);
+	snd_uart16550_del_timer(uart);
+	snd_uart16550_io_loop(uart);
+	spin_unlock_irqrestore(&uart->open_lock, flags);
+}
+
+/*
+ *  this method probes, if an uart sits on given port
+ *  return 0 if found
+ *  return negative error if not found
+ */
+static int __init snd_uart16550_detect(snd_uart16550_t *uart)
+{
+	unsigned long io_base = uart->base;
+	int ok;
+	unsigned char c;
+
+	/* Do some vague tests for the presence of the uart */
+	if (io_base == 0 || io_base == SNDRV_AUTO_PORT) {
+		return -ENODEV;	/* Not configured */
+	}
+
+	uart->res_base = request_region(io_base, 8, "Serial MIDI");
+	if (uart->res_base == NULL) {
+		snd_printk(KERN_ERR "u16550: can't grab port 0x%lx\n", io_base);
+		return -EBUSY;
+	}
+
+	ok = 1;			/* uart detected unless one of the following tests should fail */
+	/* 8 data-bits, 1 stop-bit, parity off, DLAB = 0 */
+	outb(UART_LCR_WLEN8, io_base + UART_LCR); /* Line Control Register */
+	c = inb(io_base + UART_IER);
+	/* The top four bits of the IER should always == 0 */
+	if ((c & 0xf0) != 0)
+		ok = 0;		/* failed */
+
+	outb(0xaa, io_base + UART_SCR);
+	/* Write arbitrary data into the scratch reg */
+	c = inb(io_base + UART_SCR);
+	/* If it comes back, it's OK */
+	if (c != 0xaa)
+		ok = 0;		/* failed */
+
+	outb(0x55, io_base + UART_SCR);
+	/* Write arbitrary data into the scratch reg */
+	c = inb(io_base + UART_SCR);
+	/* If it comes back, it's OK */
+	if (c != 0x55)
+		ok = 0;		/* failed */
+
+	return ok;
+}
+
+static void snd_uart16550_do_open(snd_uart16550_t * uart)
+{
+	char byte;
+
+	/* Initialize basic variables */
+	uart->buff_in_count = 0;
+	uart->buff_in = 0;
+	uart->buff_out = 0;
+	uart->fifo_limit = 1;
+	uart->fifo_count = 0;
+	uart->timer_running = 0;
+
+	outb(UART_FCR_ENABLE_FIFO	/* Enable FIFO's (if available) */
+	     | UART_FCR_CLEAR_RCVR	/* Clear receiver FIFO */
+	     | UART_FCR_CLEAR_XMIT	/* Clear transmitter FIFO */
+	     | UART_FCR_TRIGGER_4	/* Set FIFO trigger at 4-bytes */
+	/* NOTE: interrupt generated after T=(time)4-bytes
+	 * if less than UART_FCR_TRIGGER bytes received
+	 */
+	     ,uart->base + UART_FCR);	/* FIFO Control Register */
+
+	if ((inb(uart->base + UART_IIR) & 0xf0) == 0xc0)
+		uart->fifo_limit = 16;
+	if (uart->divisor != 0) {
+		uart->old_line_ctrl_reg = inb(uart->base + UART_LCR);
+		outb(UART_LCR_DLAB	/* Divisor latch access bit */
+		     ,uart->base + UART_LCR);	/* Line Control Register */
+		uart->old_divisor_lsb = inb(uart->base + UART_DLL);
+		uart->old_divisor_msb = inb(uart->base + UART_DLM);
+
+		outb(uart->divisor
+		     ,uart->base + UART_DLL);	/* Divisor Latch Low */
+		outb(0
+		     ,uart->base + UART_DLM);	/* Divisor Latch High */
+		/* DLAB is reset to 0 in next outb() */
+	}
+	/* Set serial parameters (parity off, etc) */
+	outb(UART_LCR_WLEN8	/* 8 data-bits */
+	     | 0		/* 1 stop-bit */
+	     | 0		/* parity off */
+	     | 0		/* DLAB = 0 */
+	     ,uart->base + UART_LCR);	/* Line Control Register */
+
+	switch (uart->adaptor) {
+	default:
+		outb(UART_MCR_RTS	/* Set Request-To-Send line active */
+		     | UART_MCR_DTR	/* Set Data-Terminal-Ready line active */
+		     | UART_MCR_OUT2	/* Set OUT2 - not always required, but when
+					 * it is, it is ESSENTIAL for enabling interrupts
+				 */
+		     ,uart->base + UART_MCR);	/* Modem Control Register */
+		break;
+	case SNDRV_SERIAL_MS124W_SA:
+	case SNDRV_SERIAL_MS124W_MB:
+		/* MS-124W can draw power from RTS and DTR if they
+		   are in opposite states. */ 
+		outb(UART_MCR_RTS | (0&UART_MCR_DTR) | UART_MCR_OUT2,
+		     uart->base + UART_MCR);
+		break;
+	case SNDRV_SERIAL_MS124T:
+		/* MS-124T can draw power from RTS and/or DTR (preferably
+		   both) if they are both asserted. */
+		outb(UART_MCR_RTS | UART_MCR_DTR | UART_MCR_OUT2,
+		     uart->base + UART_MCR);
+		break;
+	}
+
+	if (uart->irq < 0) {
+		byte = (0 & UART_IER_RDI)	/* Disable Receiver data interrupt */
+		    |(0 & UART_IER_THRI)	/* Disable Transmitter holding register empty interrupt */
+		    ;
+	} else if (uart->adaptor == SNDRV_SERIAL_MS124W_SA) {
+		byte = UART_IER_RDI	/* Enable Receiver data interrupt */
+		    | UART_IER_MSI	/* Enable Modem status interrupt */
+		    ;
+	} else if (uart->adaptor == SNDRV_SERIAL_GENERIC) {
+		byte = UART_IER_RDI	/* Enable Receiver data interrupt */
+		    | UART_IER_MSI	/* Enable Modem status interrupt */
+		    | UART_IER_THRI	/* Enable Transmitter holding register empty interrupt */
+		    ;
+	} else {
+		byte = UART_IER_RDI	/* Enable Receiver data interrupt */
+		    | UART_IER_THRI	/* Enable Transmitter holding register empty interrupt */
+		    ;
+	}
+	outb(byte, uart->base + UART_IER);	/* Interupt enable Register */
+
+	inb(uart->base + UART_LSR);	/* Clear any pre-existing overrun indication */
+	inb(uart->base + UART_IIR);	/* Clear any pre-existing transmit interrupt */
+	inb(uart->base + UART_RX);	/* Clear any pre-existing receive interrupt */
+}
+
+static void snd_uart16550_do_close(snd_uart16550_t * uart)
+{
+	if (uart->irq < 0)
+		snd_uart16550_del_timer(uart);
+
+	/* NOTE: may need to disable interrupts before de-registering out handler.
+	 * For now, the consequences are harmless.
+	 */
+
+	outb((0 & UART_IER_RDI)		/* Disable Receiver data interrupt */
+	     |(0 & UART_IER_THRI)	/* Disable Transmitter holding register empty interrupt */
+	     ,uart->base + UART_IER);	/* Interupt enable Register */
+
+	switch (uart->adaptor) {
+	default:
+		outb((0 & UART_MCR_RTS)		/* Deactivate Request-To-Send line  */
+		     |(0 & UART_MCR_DTR)	/* Deactivate Data-Terminal-Ready line */
+		     |(0 & UART_MCR_OUT2)	/* Deactivate OUT2 */
+		     ,uart->base + UART_MCR);	/* Modem Control Register */
+	  break;
+	case SNDRV_SERIAL_MS124W_SA:
+	case SNDRV_SERIAL_MS124W_MB:
+		/* MS-124W can draw power from RTS and DTR if they
+		   are in opposite states; leave it powered. */ 
+		outb(UART_MCR_RTS | (0&UART_MCR_DTR) | (0&UART_MCR_OUT2),
+		     uart->base + UART_MCR);
+		break;
+	case SNDRV_SERIAL_MS124T:
+		/* MS-124T can draw power from RTS and/or DTR (preferably
+		   both) if they are both asserted; leave it powered. */
+		outb(UART_MCR_RTS | UART_MCR_DTR | (0&UART_MCR_OUT2),
+		     uart->base + UART_MCR);
+		break;
+	}
+
+	inb(uart->base + UART_IIR);	/* Clear any outstanding interrupts */
+
+	/* Restore old divisor */
+	if (uart->divisor != 0) {
+		outb(UART_LCR_DLAB		/* Divisor latch access bit */
+		     ,uart->base + UART_LCR);	/* Line Control Register */
+		outb(uart->old_divisor_lsb
+		     ,uart->base + UART_DLL);	/* Divisor Latch Low */
+		outb(uart->old_divisor_msb
+		     ,uart->base + UART_DLM);	/* Divisor Latch High */
+		/* Restore old LCR (data bits, stop bits, parity, DLAB) */
+		outb(uart->old_line_ctrl_reg
+		     ,uart->base + UART_LCR);	/* Line Control Register */
+	}
+}
+
+static int snd_uart16550_input_open(snd_rawmidi_substream_t * substream)
+{
+	unsigned long flags;
+	snd_uart16550_t *uart = substream->rmidi->private_data;
+
+	spin_lock_irqsave(&uart->open_lock, flags);
+	if (uart->filemode == SERIAL_MODE_NOT_OPENED)
+		snd_uart16550_do_open(uart);
+	uart->filemode |= SERIAL_MODE_INPUT_OPEN;
+	uart->midi_input[substream->number] = substream;
+	spin_unlock_irqrestore(&uart->open_lock, flags);
+	return 0;
+}
+
+static int snd_uart16550_input_close(snd_rawmidi_substream_t * substream)
+{
+	unsigned long flags;
+	snd_uart16550_t *uart = substream->rmidi->private_data;
+
+	spin_lock_irqsave(&uart->open_lock, flags);
+	uart->filemode &= ~SERIAL_MODE_INPUT_OPEN;
+	uart->midi_input[substream->number] = NULL;
+	if (uart->filemode == SERIAL_MODE_NOT_OPENED)
+		snd_uart16550_do_close(uart);
+	spin_unlock_irqrestore(&uart->open_lock, flags);
+	return 0;
+}
+
+static void snd_uart16550_input_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	unsigned long flags;
+	snd_uart16550_t *uart = substream->rmidi->private_data;
+
+	spin_lock_irqsave(&uart->open_lock, flags);
+	if (up) {
+		uart->filemode |= SERIAL_MODE_INPUT_TRIGGERED;
+	} else {
+		uart->filemode &= ~SERIAL_MODE_INPUT_TRIGGERED;
+	}
+	spin_unlock_irqrestore(&uart->open_lock, flags);
+}
+
+static int snd_uart16550_output_open(snd_rawmidi_substream_t * substream)
+{
+	unsigned long flags;
+	snd_uart16550_t *uart = substream->rmidi->private_data;
+
+	spin_lock_irqsave(&uart->open_lock, flags);
+	if (uart->filemode == SERIAL_MODE_NOT_OPENED)
+		snd_uart16550_do_open(uart);
+	uart->filemode |= SERIAL_MODE_OUTPUT_OPEN;
+	uart->midi_output[substream->number] = substream;
+	spin_unlock_irqrestore(&uart->open_lock, flags);
+	return 0;
+};
+
+static int snd_uart16550_output_close(snd_rawmidi_substream_t * substream)
+{
+	unsigned long flags;
+	snd_uart16550_t *uart = substream->rmidi->private_data;
+
+	spin_lock_irqsave(&uart->open_lock, flags);
+	uart->filemode &= ~SERIAL_MODE_OUTPUT_OPEN;
+	uart->midi_output[substream->number] = NULL;
+	if (uart->filemode == SERIAL_MODE_NOT_OPENED)
+		snd_uart16550_do_close(uart);
+	spin_unlock_irqrestore(&uart->open_lock, flags);
+	return 0;
+};
+
+inline static int snd_uart16550_buffer_can_write( snd_uart16550_t *uart, int Num )
+{
+	if( uart->buff_in_count + Num < TX_BUFF_SIZE )
+		return 1;
+	else
+		return 0;
+}
+
+inline static int snd_uart16550_write_buffer(snd_uart16550_t *uart, unsigned char byte)
+{
+	unsigned short buff_in = uart->buff_in;
+	if( uart->buff_in_count < TX_BUFF_SIZE ) {
+		uart->tx_buff[buff_in] = byte;
+		buff_in++;
+		buff_in &= TX_BUFF_MASK;
+		uart->buff_in = buff_in;
+		uart->buff_in_count++;
+		if (uart->irq < 0) /* polling mode */
+			snd_uart16550_add_timer(uart);
+		return 1;
+	} else
+		return 0;
+}
+
+static int snd_uart16550_output_byte(snd_uart16550_t *uart, snd_rawmidi_substream_t * substream, unsigned char midi_byte)
+{
+	if (uart->buff_in_count == 0                            /* Buffer empty? */
+	    && ((uart->adaptor != SNDRV_SERIAL_MS124W_SA &&
+	    uart->adaptor != SNDRV_SERIAL_GENERIC) ||
+		(uart->fifo_count == 0                               /* FIFO empty? */
+		 && (inb(uart->base + UART_MSR) & UART_MSR_CTS)))) { /* CTS? */
+
+	        /* Tx Buffer Empty - try to write immediately */
+		if ((inb(uart->base + UART_LSR) & UART_LSR_THRE) != 0) {
+		        /* Transmitter holding register (and Tx FIFO) empty */
+		        uart->fifo_count = 1;
+			outb(midi_byte, uart->base + UART_TX);
+		} else {
+		        if (uart->fifo_count < uart->fifo_limit) {
+			        uart->fifo_count++;
+				outb(midi_byte, uart->base + UART_TX);
+			} else {
+			        /* Cannot write (buffer empty) - put char in buffer */
+				snd_uart16550_write_buffer(uart, midi_byte);
+			}
+		}
+	} else {
+		if( !snd_uart16550_write_buffer(uart, midi_byte) ) {
+			snd_printk("%s: Buffer overrun on device at 0x%lx\n",
+				   uart->rmidi->name, uart->base);
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static void snd_uart16550_output_write(snd_rawmidi_substream_t * substream)
+{
+	unsigned long flags;
+	unsigned char midi_byte, addr_byte;
+	snd_uart16550_t *uart = substream->rmidi->private_data;
+	char first;
+	static unsigned long lasttime=0;
+	
+	/* Interupts are disabled during the updating of the tx_buff,
+	 * since it is 'bad' to have two processes updating the same
+	 * variables (ie buff_in & buff_out)
+	 */
+
+	spin_lock_irqsave(&uart->open_lock, flags);
+
+	if (uart->irq < 0)	//polling
+		snd_uart16550_io_loop(uart);
+
+	if (uart->adaptor == SNDRV_SERIAL_MS124W_MB) {
+		while (1) {
+			/* buffer full? */
+			/* in this mode we need two bytes of space */
+			if (uart->buff_in_count > TX_BUFF_SIZE - 2)
+				break;
+			if (snd_rawmidi_transmit(substream, &midi_byte, 1) != 1)
+				break;
+#ifdef SNDRV_SERIAL_MS124W_MB_NOCOMBO
+			/* select exactly one of the four ports */
+			addr_byte = (1 << (substream->number + 4)) | 0x08;
+#else
+			/* select any combination of the four ports */
+			addr_byte = (substream->number << 4) | 0x08;
+			/* ...except none */
+			if (addr_byte == 0x08) addr_byte = 0xf8;
+#endif
+			snd_uart16550_output_byte(uart, substream, addr_byte);
+			/* send midi byte */
+			snd_uart16550_output_byte(uart, substream, midi_byte);
+		}
+	} else {
+		first = 0;
+		while( 1 == snd_rawmidi_transmit_peek(substream, &midi_byte, 1) ) {
+			/* Also send F5 after 3 seconds with no data to handle device disconnect */
+			if (first == 0 && (uart->adaptor == SNDRV_SERIAL_SOUNDCANVAS ||
+				uart->adaptor == SNDRV_SERIAL_GENERIC) &&
+			   (uart->prev_out != substream->number || jiffies-lasttime > 3*HZ)) {
+
+				if( snd_uart16550_buffer_can_write( uart, 3 ) ) {
+					/* Roland Soundcanvas part selection */
+					/* If this substream of the data is different previous
+					   substream in this uart, send the change part event */
+					uart->prev_out = substream->number;
+					/* change part */
+					snd_uart16550_output_byte(uart, substream, 0xf5);
+					/* data */
+					snd_uart16550_output_byte(uart, substream, uart->prev_out + 1);
+					/* If midi_byte is a data byte, send the previous status byte */
+					if ((midi_byte < 0x80) && (uart->adaptor == SNDRV_SERIAL_SOUNDCANVAS))
+						snd_uart16550_output_byte(uart, substream, uart->prev_status[uart->prev_out]);
+				} else if( !uart->drop_on_full )
+					break;
+
+			}
+
+			/* send midi byte */
+			if( !snd_uart16550_output_byte(uart, substream, midi_byte) && !uart->drop_on_full )
+				break;
+
+			if (midi_byte >= 0x80 && midi_byte < 0xf0)
+				uart->prev_status[uart->prev_out] = midi_byte;
+			first = 1;
+
+			snd_rawmidi_transmit_ack( substream, 1 );
+		}
+		lasttime = jiffies;
+	}
+	spin_unlock_irqrestore(&uart->open_lock, flags);
+}
+
+static void snd_uart16550_output_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	unsigned long flags;
+	snd_uart16550_t *uart = substream->rmidi->private_data;
+
+	spin_lock_irqsave(&uart->open_lock, flags);
+	if (up) {
+		uart->filemode |= SERIAL_MODE_OUTPUT_TRIGGERED;
+	} else {
+		uart->filemode &= ~SERIAL_MODE_OUTPUT_TRIGGERED;
+	}
+	spin_unlock_irqrestore(&uart->open_lock, flags);
+	if (up)
+		snd_uart16550_output_write(substream);
+}
+
+static snd_rawmidi_ops_t snd_uart16550_output =
+{
+	.open =		snd_uart16550_output_open,
+	.close =	snd_uart16550_output_close,
+	.trigger =	snd_uart16550_output_trigger,
+};
+
+static snd_rawmidi_ops_t snd_uart16550_input =
+{
+	.open =		snd_uart16550_input_open,
+	.close =	snd_uart16550_input_close,
+	.trigger =	snd_uart16550_input_trigger,
+};
+
+static int snd_uart16550_free(snd_uart16550_t *uart)
+{
+	if (uart->irq >= 0)
+		free_irq(uart->irq, (void *)uart);
+	if (uart->res_base) {
+		release_resource(uart->res_base);
+		kfree_nocheck(uart->res_base);
+	}
+	kfree(uart);
+	return 0;
+};
+
+static int snd_uart16550_dev_free(snd_device_t *device)
+{
+	snd_uart16550_t *uart = device->device_data;
+	return snd_uart16550_free(uart);
+}
+
+static int __init snd_uart16550_create(snd_card_t * card,
+				       unsigned long iobase,
+				       int irq,
+				       unsigned int speed,
+				       unsigned int base,
+				       int adaptor,
+				       int droponfull,
+				       snd_uart16550_t **ruart)
+{
+	static snd_device_ops_t ops = {
+		.dev_free =	snd_uart16550_dev_free,
+	};
+	snd_uart16550_t *uart;
+	int err;
+
+
+	if ((uart = kcalloc(1, sizeof(*uart), GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+	uart->adaptor = adaptor;
+	uart->card = card;
+	spin_lock_init(&uart->open_lock);
+	uart->irq = -1;
+	uart->base = iobase;
+	uart->drop_on_full = droponfull;
+
+	if ((err = snd_uart16550_detect(uart)) <= 0) {
+		printk(KERN_ERR "no UART detected at 0x%lx\n", iobase);
+		return err;
+	}
+
+	if (irq >= 0 && irq != SNDRV_AUTO_IRQ) {
+		if (request_irq(irq, snd_uart16550_interrupt,
+				SA_INTERRUPT, "Serial MIDI", (void *) uart)) {
+			snd_printk("irq %d busy. Using Polling.\n", irq);
+		} else {
+			uart->irq = irq;
+		}
+	}
+	uart->divisor = base / speed;
+	uart->speed = base / (unsigned int)uart->divisor;
+	uart->speed_base = base;
+	uart->prev_out = -1;
+	uart->prev_in = 0;
+	uart->rstatus = 0;
+	memset(uart->prev_status, 0x80, sizeof(unsigned char) * SNDRV_SERIAL_MAX_OUTS);
+	init_timer(&uart->buffer_timer);
+	uart->buffer_timer.function = snd_uart16550_buffer_timer;
+	uart->buffer_timer.data = (unsigned long)uart;
+	uart->timer_running = 0;
+
+	/* Register device */
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, uart, &ops)) < 0) {
+		snd_uart16550_free(uart);
+		return err;
+	}
+
+	switch (uart->adaptor) {
+	case SNDRV_SERIAL_MS124W_SA:
+	case SNDRV_SERIAL_MS124W_MB:
+		/* MS-124W can draw power from RTS and DTR if they
+		   are in opposite states. */ 
+		outb(UART_MCR_RTS | (0&UART_MCR_DTR), uart->base + UART_MCR);
+		break;
+	case SNDRV_SERIAL_MS124T:
+		/* MS-124T can draw power from RTS and/or DTR (preferably
+		   both) if they are asserted. */
+		outb(UART_MCR_RTS | UART_MCR_DTR, uart->base + UART_MCR);
+		break;
+	default:
+		break;
+	}
+
+	if (ruart)
+		*ruart = uart;
+
+	return 0;
+}
+
+static void __init snd_uart16550_substreams(snd_rawmidi_str_t *stream)
+{
+	struct list_head *list;
+
+	list_for_each(list, &stream->substreams) {
+		snd_rawmidi_substream_t *substream = list_entry(list, snd_rawmidi_substream_t, list);
+		sprintf(substream->name, "Serial MIDI %d", substream->number + 1);
+	}
+}
+
+static int __init snd_uart16550_rmidi(snd_uart16550_t *uart, int device, int outs, int ins, snd_rawmidi_t **rmidi)
+{
+	snd_rawmidi_t *rrawmidi;
+	int err;
+
+	if ((err = snd_rawmidi_new(uart->card, "UART Serial MIDI", device, outs, ins, &rrawmidi)) < 0)
+		return err;
+	snd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_uart16550_input);
+	snd_rawmidi_set_ops(rrawmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_uart16550_output);
+	strcpy(rrawmidi->name, "Serial MIDI");
+	snd_uart16550_substreams(&rrawmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT]);
+	snd_uart16550_substreams(&rrawmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT]);
+	rrawmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
+			       SNDRV_RAWMIDI_INFO_INPUT |
+			       SNDRV_RAWMIDI_INFO_DUPLEX;
+	rrawmidi->private_data = uart;
+	if (rmidi)
+		*rmidi = rrawmidi;
+	return 0;
+}
+
+static int __init snd_serial_probe(int dev)
+{
+	snd_card_t *card;
+	snd_uart16550_t *uart;
+	int err;
+
+	if (!enable[dev])
+		return -ENOENT;
+
+	switch (adaptor[dev]) {
+	case SNDRV_SERIAL_SOUNDCANVAS:
+		ins[dev] = 1;
+		break;
+	case SNDRV_SERIAL_MS124T:
+	case SNDRV_SERIAL_MS124W_SA:
+		outs[dev] = 1;
+		ins[dev] = 1;
+		break;
+	case SNDRV_SERIAL_MS124W_MB:
+		outs[dev] = 16;
+		ins[dev] = 1;
+		break;
+	case SNDRV_SERIAL_GENERIC:
+		break;
+	default:
+		snd_printk("Adaptor type is out of range 0-%d (%d)\n",
+			   SNDRV_SERIAL_MAX_ADAPTOR, adaptor[dev]);
+		return -ENODEV;
+	}
+
+	if (outs[dev] < 1 || outs[dev] > SNDRV_SERIAL_MAX_OUTS) {
+		snd_printk("Count of outputs is out of range 1-%d (%d)\n",
+			   SNDRV_SERIAL_MAX_OUTS, outs[dev]);
+		return -ENODEV;
+	}
+
+	if (ins[dev] < 1 || ins[dev] > SNDRV_SERIAL_MAX_INS) {
+		snd_printk("Count of inputs is out of range 1-%d (%d)\n",
+			   SNDRV_SERIAL_MAX_INS, ins[dev]);
+		return -ENODEV;
+	}
+
+	card  = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+
+	strcpy(card->driver, "Serial");
+	strcpy(card->shortname, "Serial MIDI (UART16550A)");
+
+	if ((err = snd_uart16550_create(card,
+					port[dev],
+					irq[dev],
+					speed[dev],
+					base[dev],
+					adaptor[dev],
+					droponfull[dev],
+					&uart)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	if ((err = snd_uart16550_rmidi(uart, 0, outs[dev], ins[dev], &uart->rmidi)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	sprintf(card->longname, "%s at 0x%lx, irq %d speed %d div %d outs %d ins %d adaptor %s droponfull %d",
+		card->shortname,
+		uart->base,
+		uart->irq,
+		uart->speed,
+		(int)uart->divisor,
+		outs[dev],
+		ins[dev],
+		adaptor_names[uart->adaptor],
+		uart->drop_on_full);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	snd_serial_cards[dev] = card;
+	return 0;
+}
+
+static int __init alsa_card_serial_init(void)
+{
+	int dev = 0;
+	int cards = 0;
+
+	for (dev = 0; dev < SNDRV_CARDS; dev++) {
+		if (snd_serial_probe(dev) == 0)
+			cards++;
+	}
+
+	if (cards == 0) {
+#ifdef MODULE
+		printk(KERN_ERR "serial midi soundcard not found or device busy\n");
+#endif
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void __exit alsa_card_serial_exit(void)
+{
+	int dev;
+
+	for (dev = 0; dev < SNDRV_CARDS; dev++) {
+		if (snd_serial_cards[dev] != NULL)
+			snd_card_free(snd_serial_cards[dev]);
+	}
+}
+
+module_init(alsa_card_serial_init)
+module_exit(alsa_card_serial_exit)
