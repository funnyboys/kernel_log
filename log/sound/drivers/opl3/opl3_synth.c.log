commit ad155712bb1ea2151944cf06a0e08c315c70c1e3
Author: xidongwang <wangxidong_97@163.com>
Date:   Sun Jul 5 20:27:38 2020 -0700

    ALSA: opl3: fix infoleak in opl3
    
    The stack object “info” in snd_opl3_ioctl() has a leaking problem.
    It has 2 padding bytes which are not initialized and leaked via
    “copy_to_user”.
    
    Signed-off-by: xidongwang <wangxidong_97@163.com>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/1594006058-30362-1-git-send-email-wangxidong_97@163.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index e69a4ef0d6bd..08c10ac9d6c8 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -91,6 +91,8 @@ int snd_opl3_ioctl(struct snd_hwdep * hw, struct file *file,
 		{
 			struct snd_dm_fm_info info;
 
+			memset(&info, 0, sizeof(info));
+
 			info.fm_mode = opl3->fm_mode;
 			info.rhythm = opl3->rhythm;
 			if (copy_to_user(argp, &info, sizeof(struct snd_dm_fm_info)))

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index d522925fc5c0..e69a4ef0d6bd 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -1,22 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Copyright (c) by Uros Bizjak <uros@kss-loka.si>
  *                   
  *  Routines for OPL2/OPL3/OPL4 control
- *
- *   This program is free software; you can redistribute it and/or modify 
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/slab.h>

commit 7e9c20f40304a16d5f69dbdc44a551cc48252266
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 23:00:52 2018 +0200

    ALSA: opl3: Declare common variables properly
    
    Move the declarations of common variables into opl3_voice.h instead of
    declaring at each file multiple times, which was error-prone.
    
    This fixes sparse warnings like:
      sound/drivers/opl3/opl3_synth.c:51:6: warning: symbol 'snd_opl3_regmap' was not declared. Should it be static?
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index 42920a243328..d522925fc5c0 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -24,6 +24,7 @@
 #include <linux/nospec.h>
 #include <sound/opl3.h>
 #include <sound/asound_fm.h>
+#include "opl3_voice.h"
 
 #if IS_ENABLED(CONFIG_SND_SEQUENCER)
 #define OPL3_SUPPORT_SYNTH

commit 7f054a5bee0987f1e2d4e59daea462421c76f2cb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 07:56:07 2018 +0200

    ALSA: opl3: Hardening for potential Spectre v1
    
    As recently Smatch suggested, one place in OPL3 driver may expand the
    array directly from the user-space value with speculation:
      sound/drivers/opl3/opl3_synth.c:476 snd_opl3_set_voice() warn: potential spectre issue 'snd_opl3_regmap'
    
    This patch puts array_index_nospec() for hardening against it.
    
    BugLink: https://marc.info/?l=linux-kernel&m=152411496503418&w=2
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index ddcc1a325a61..42920a243328 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -21,6 +21,7 @@
 
 #include <linux/slab.h>
 #include <linux/export.h>
+#include <linux/nospec.h>
 #include <sound/opl3.h>
 #include <sound/asound_fm.h>
 
@@ -448,7 +449,7 @@ static int snd_opl3_set_voice(struct snd_opl3 * opl3, struct snd_dm_fm_voice * v
 {
 	unsigned short reg_side;
 	unsigned char op_offset;
-	unsigned char voice_offset;
+	unsigned char voice_offset, voice_op;
 
 	unsigned short opl3_reg;
 	unsigned char reg_val;
@@ -473,7 +474,9 @@ static int snd_opl3_set_voice(struct snd_opl3 * opl3, struct snd_dm_fm_voice * v
 		voice_offset = voice->voice - MAX_OPL2_VOICES;
 	}
 	/* Get register offset of operator */
-	op_offset = snd_opl3_regmap[voice_offset][voice->op];
+	voice_offset = array_index_nospec(voice_offset, MAX_OPL2_VOICES);
+	voice_op = array_index_nospec(voice->op, 4);
+	op_offset = snd_opl3_regmap[voice_offset][voice_op];
 
 	reg_val = 0x00;
 	/* Set amplitude modulation (tremolo) effect */

commit 8eeaa2f9e06dcfb45593a0fcd91e81abc7f5d209
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 10 09:48:47 2014 +0100

    ALSA: Replace with IS_ENABLED()
    
    Replace the lengthy #if defined(XXX) || defined(XXX_MODULE) with the
    new IS_ENABLED() macro.
    
    The patch still doesn't cover all ifdefs.  For example, the dependency
    on CONFIG_GAMEPORT is still open-coded because this also has an extra
    dependency on MODULE.  Similarly, an open-coded ifdef in pcm_oss.c and
    some sequencer-related stuff are left untouched.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index 742a4b642fd9..ddcc1a325a61 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -24,7 +24,7 @@
 #include <sound/opl3.h>
 #include <sound/asound_fm.h>
 
-#if defined(CONFIG_SND_SEQUENCER) || defined(CONFIG_SND_SEQUENCER_MODULE)
+#if IS_ENABLED(CONFIG_SND_SEQUENCER)
 #define OPL3_SUPPORT_SYNTH
 #endif
 

commit d81a6d71760c4d8323f1f9a506c64084caa09063
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Sep 22 09:34:58 2011 -0400

    sound: Add export.h for THIS_MODULE/EXPORT_SYMBOL where needed
    
    These aren't modules, but they do make use of these macros, so
    they will need export.h to get that definition.  Previously,
    they got it via the implicit module.h inclusion.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index 301acb6b9cf9..742a4b642fd9 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -20,6 +20,7 @@
  */
 
 #include <linux/slab.h>
+#include <linux/export.h>
 #include <sound/opl3.h>
 #include <sound/asound_fm.h>
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index 6d57b6441dec..301acb6b9cf9 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -19,6 +19,7 @@
  *
  */
 
+#include <linux/slab.h>
 #include <sound/opl3.h>
 #include <sound/asound_fm.h>
 

commit 45203832df2fa9e94ca0a249ddb20d2b077e58cc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 15:51:50 2009 +0100

    ALSA: Add missing KERN_* prefix to printk in sound/drivers
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index 962bb9c8b9c8..6d57b6441dec 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -168,7 +168,7 @@ int snd_opl3_ioctl(struct snd_hwdep * hw, struct file *file,
 
 #ifdef CONFIG_SND_DEBUG
 	default:
-		snd_printk("unknown IOCTL: 0x%x\n", cmd);
+		snd_printk(KERN_WARNING "unknown IOCTL: 0x%x\n", cmd);
 #endif
 	}
 	return -ENOTTY;

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index fb64c890109b..962bb9c8b9c8 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -92,7 +92,8 @@ int snd_opl3_ioctl(struct snd_hwdep * hw, struct file *file,
 	struct snd_opl3 *opl3 = hw->private_data;
 	void __user *argp = (void __user *)arg;
 
-	snd_assert(opl3 != NULL, return -EINVAL);
+	if (snd_BUG_ON(!opl3))
+		return -EINVAL;
 
 	switch (cmd) {
 		/* get information */

commit 0ee46c9dadcbbd0daa12da30f226391896d90abb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 22 18:34:06 2008 +0100

    [ALSA] opl3 - Fix compilation without sequencer support
    
    Add proper ifdef's to the patch loading code moved from the old instr
    layer so that opl3 driver can be compiled without the sequencer support.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index a7bf7a4b1f85..fb64c890109b 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -22,6 +22,10 @@
 #include <sound/opl3.h>
 #include <sound/asound_fm.h>
 
+#if defined(CONFIG_SND_SEQUENCER) || defined(CONFIG_SND_SEQUENCER_MODULE)
+#define OPL3_SUPPORT_SYNTH
+#endif
+
 /*
  *    There is 18 possible 2 OP voices
  *      (9 in the left and 9 in the right).
@@ -155,9 +159,11 @@ int snd_opl3_ioctl(struct snd_hwdep * hw, struct file *file,
 #endif
 		return snd_opl3_set_connection(opl3, (int) arg);
 
+#ifdef OPL3_SUPPORT_SYNTH
 	case SNDRV_DM_FM_IOCTL_CLEAR_PATCHES:
 		snd_opl3_clear_patches(opl3);
 		return 0;
+#endif
 
 #ifdef CONFIG_SND_DEBUG
 	default:
@@ -178,6 +184,7 @@ int snd_opl3_release(struct snd_hwdep * hw, struct file *file)
 	return 0;
 }
 
+#ifdef OPL3_SUPPORT_SYNTH
 /*
  * write the device - load patches
  */
@@ -341,6 +348,7 @@ void snd_opl3_clear_patches(struct snd_opl3 *opl3)
 	}
 	memset(opl3->patch_table, 0, sizeof(opl3->patch_table));
 }
+#endif /* OPL3_SUPPORT_SYNTH */
 
 /* ------------------------------ */
 

commit 05c1afe75fcebf456017ec186811cf1599f4360e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 30 11:59:15 2007 +0100

    [ALSA] opl3 - simplify exclusive access lock
    
    Use the exclusive access lock in hwdep instead of the own one.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index d55eefce44c1..a7bf7a4b1f85 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -76,16 +76,6 @@ static int snd_opl3_set_connection(struct snd_opl3 * opl3, int connection);
  */
 int snd_opl3_open(struct snd_hwdep * hw, struct file *file)
 {
-	struct snd_opl3 *opl3 = hw->private_data;
-
-	mutex_lock(&opl3->access_mutex);
-	if (opl3->used) {
-		mutex_unlock(&opl3->access_mutex);
-		return -EAGAIN;
-	}
-	opl3->used++;
-	mutex_unlock(&opl3->access_mutex);
-
 	return 0;
 }
 
@@ -185,10 +175,6 @@ int snd_opl3_release(struct snd_hwdep * hw, struct file *file)
 	struct snd_opl3 *opl3 = hw->private_data;
 
 	snd_opl3_reset(opl3);
-	mutex_lock(&opl3->access_mutex);
-	opl3->used--;
-	mutex_unlock(&opl3->access_mutex);
-
 	return 0;
 }
 

commit 224a033252bba46c5c8b5df625f5e781ca138f48
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 30 11:49:22 2007 +0100

    [ALSA] opl3 - Use hwdep for patch loading
    
    Use the hwdep device for loading OPL2/3 patch data instead of the
    messy sequencer instrument layer.
    Due to this change, the sbiload program should be updated, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index a4b3543a7118..d55eefce44c1 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -165,6 +165,10 @@ int snd_opl3_ioctl(struct snd_hwdep * hw, struct file *file,
 #endif
 		return snd_opl3_set_connection(opl3, (int) arg);
 
+	case SNDRV_DM_FM_IOCTL_CLEAR_PATCHES:
+		snd_opl3_clear_patches(opl3);
+		return 0;
+
 #ifdef CONFIG_SND_DEBUG
 	default:
 		snd_printk("unknown IOCTL: 0x%x\n", cmd);
@@ -188,6 +192,170 @@ int snd_opl3_release(struct snd_hwdep * hw, struct file *file)
 	return 0;
 }
 
+/*
+ * write the device - load patches
+ */
+long snd_opl3_write(struct snd_hwdep *hw, const char __user *buf, long count,
+		    loff_t *offset)
+{
+	struct snd_opl3 *opl3 = hw->private_data;
+	long result = 0;
+	int err = 0;
+	struct sbi_patch inst;
+
+	while (count >= sizeof(inst)) {
+		unsigned char type;
+		if (copy_from_user(&inst, buf, sizeof(inst)))
+			return -EFAULT;
+		if (!memcmp(inst.key, FM_KEY_SBI, 4) ||
+		    !memcmp(inst.key, FM_KEY_2OP, 4))
+			type = FM_PATCH_OPL2;
+		else if (!memcmp(inst.key, FM_KEY_4OP, 4))
+			type = FM_PATCH_OPL3;
+		else /* invalid type */
+			break;
+		err = snd_opl3_load_patch(opl3, inst.prog, inst.bank, type,
+					  inst.name, inst.extension,
+					  inst.data);
+		if (err < 0)
+			break;
+		result += sizeof(inst);
+		count -= sizeof(inst);
+	}
+	return result > 0 ? result : err;
+}
+
+
+/*
+ * Patch management
+ */
+
+/* offsets for SBI params */
+#define AM_VIB		0
+#define KSL_LEVEL	2
+#define ATTACK_DECAY	4
+#define SUSTAIN_RELEASE	6
+#define WAVE_SELECT	8
+
+/* offset for SBI instrument */
+#define CONNECTION	10
+#define OFFSET_4OP	11
+
+/*
+ * load a patch, obviously.
+ *
+ * loaded on the given program and bank numbers with the given type
+ * (FM_PATCH_OPLx).
+ * data is the pointer of SBI record _without_ header (key and name).
+ * name is the name string of the patch.
+ * ext is the extension data of 7 bytes long (stored in name of SBI
+ * data up to offset 25), or NULL to skip.
+ * return 0 if successful or a negative error code.
+ */
+int snd_opl3_load_patch(struct snd_opl3 *opl3,
+			int prog, int bank, int type,
+			const char *name,
+			const unsigned char *ext,
+			const unsigned char *data)
+{
+	struct fm_patch *patch;
+	int i;
+
+	patch = snd_opl3_find_patch(opl3, prog, bank, 1);
+	if (!patch)
+		return -ENOMEM;
+
+	patch->type = type;
+
+	for (i = 0; i < 2; i++) {
+		patch->inst.op[i].am_vib = data[AM_VIB + i];
+		patch->inst.op[i].ksl_level = data[KSL_LEVEL + i];
+		patch->inst.op[i].attack_decay = data[ATTACK_DECAY + i];
+		patch->inst.op[i].sustain_release = data[SUSTAIN_RELEASE + i];
+		patch->inst.op[i].wave_select = data[WAVE_SELECT + i];
+	}
+	patch->inst.feedback_connection[0] = data[CONNECTION];
+
+	if (type == FM_PATCH_OPL3) {
+		for (i = 0; i < 2; i++) {
+			patch->inst.op[i+2].am_vib =
+				data[OFFSET_4OP + AM_VIB + i];
+			patch->inst.op[i+2].ksl_level =
+				data[OFFSET_4OP + KSL_LEVEL + i];
+			patch->inst.op[i+2].attack_decay =
+				data[OFFSET_4OP + ATTACK_DECAY + i];
+			patch->inst.op[i+2].sustain_release =
+				data[OFFSET_4OP + SUSTAIN_RELEASE + i];
+			patch->inst.op[i+2].wave_select =
+				data[OFFSET_4OP + WAVE_SELECT + i];
+		}
+		patch->inst.feedback_connection[1] =
+			data[OFFSET_4OP + CONNECTION];
+	}
+
+	if (ext) {
+		patch->inst.echo_delay = ext[0];
+		patch->inst.echo_atten = ext[1];
+		patch->inst.chorus_spread = ext[2];
+		patch->inst.trnsps = ext[3];
+		patch->inst.fix_dur = ext[4];
+		patch->inst.modes = ext[5];
+		patch->inst.fix_key = ext[6];
+	}
+
+	if (name)
+		strlcpy(patch->name, name, sizeof(patch->name));
+
+	return 0;
+}
+EXPORT_SYMBOL(snd_opl3_load_patch);
+
+/*
+ * find a patch with the given program and bank numbers, returns its pointer
+ * if no matching patch is found and create_patch is set, it creates a
+ * new patch object.
+ */
+struct fm_patch *snd_opl3_find_patch(struct snd_opl3 *opl3, int prog, int bank,
+				     int create_patch)
+{
+	/* pretty dumb hash key */
+	unsigned int key = (prog + bank) % OPL3_PATCH_HASH_SIZE;
+	struct fm_patch *patch;
+
+	for (patch = opl3->patch_table[key]; patch; patch = patch->next) {
+		if (patch->prog == prog && patch->bank == bank)
+			return patch;
+	}
+	if (!create_patch)
+		return NULL;
+
+	patch = kzalloc(sizeof(*patch), GFP_KERNEL);
+	if (!patch)
+		return NULL;
+	patch->prog = prog;
+	patch->bank = bank;
+	patch->next = opl3->patch_table[key];
+	opl3->patch_table[key] = patch;
+	return patch;
+}
+EXPORT_SYMBOL(snd_opl3_find_patch);
+
+/*
+ * Clear all patches of the given OPL3 instance
+ */
+void snd_opl3_clear_patches(struct snd_opl3 *opl3)
+{
+	int i;
+	for (i = 0; i <  OPL3_PATCH_HASH_SIZE; i++) {
+		struct fm_patch *patch, *next;
+		for (patch = opl3->patch_table[i]; patch; patch = next) {
+			next = patch->next;
+			kfree(patch);
+		}
+	}
+	memset(opl3->patch_table, 0, sizeof(opl3->patch_table));
+}
+
 /* ------------------------------ */
 
 void snd_opl3_reset(struct snd_opl3 * opl3)

commit ac19e19b3664feda8040fb9fb7885183a9eb7a80
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:39 2006 +0200

    [ALSA] opl3 - Move EXPORT_SYMBOL() to adjacent to each function
    
    Move EXPORT_SYMBOL() to adjacent to each exported function/variable.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index 6db503f025b3..a4b3543a7118 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -58,6 +58,8 @@ char snd_opl3_regmap[MAX_OPL2_VOICES][4] =
 	{ 0x12, 0x15, 0x00, 0x00 }	/* is selected (only left reg block) */
 };
 
+EXPORT_SYMBOL(snd_opl3_regmap);
+
 /*
  * prototypes
  */
@@ -228,6 +230,7 @@ void snd_opl3_reset(struct snd_opl3 * opl3)
 	opl3->rhythm = 0;
 }
 
+EXPORT_SYMBOL(snd_opl3_reset);
 
 static int snd_opl3_play_note(struct snd_opl3 * opl3, struct snd_dm_fm_note * note)
 {
@@ -445,3 +448,4 @@ static int snd_opl3_set_connection(struct snd_opl3 * opl3, int connection)
 
 	return 0;
 }
+

commit ef9f0a42db987e7e2df72289fb4522d24027786b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:31:42 2006 +0100

    [ALSA] semaphore -> mutex (driver part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index 3534a0e3342a..6db503f025b3 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -76,13 +76,13 @@ int snd_opl3_open(struct snd_hwdep * hw, struct file *file)
 {
 	struct snd_opl3 *opl3 = hw->private_data;
 
-	down(&opl3->access_mutex);
+	mutex_lock(&opl3->access_mutex);
 	if (opl3->used) {
-		up(&opl3->access_mutex);
+		mutex_unlock(&opl3->access_mutex);
 		return -EAGAIN;
 	}
 	opl3->used++;
-	up(&opl3->access_mutex);
+	mutex_unlock(&opl3->access_mutex);
 
 	return 0;
 }
@@ -179,9 +179,9 @@ int snd_opl3_release(struct snd_hwdep * hw, struct file *file)
 	struct snd_opl3 *opl3 = hw->private_data;
 
 	snd_opl3_reset(opl3);
-	down(&opl3->access_mutex);
+	mutex_lock(&opl3->access_mutex);
 	opl3->used--;
-	up(&opl3->access_mutex);
+	mutex_unlock(&opl3->access_mutex);
 
 	return 0;
 }

commit 5b1646a8eceff0a4ff06f309abb6e7f43f99a498
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:13:14 2005 +0100

    [ALSA] Remove xxx_t typedefs: OPL3
    
    Modules: OPL3,Raw OPL FM
    
    Remove xxx_t typedefs from the OPL3 driver
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
index 04f9f955e5b7..3534a0e3342a 100644
--- a/sound/drivers/opl3/opl3_synth.c
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -61,20 +61,20 @@ char snd_opl3_regmap[MAX_OPL2_VOICES][4] =
 /*
  * prototypes
  */
-static int snd_opl3_play_note(opl3_t * opl3, snd_dm_fm_note_t * note);
-static int snd_opl3_set_voice(opl3_t * opl3, snd_dm_fm_voice_t * voice);
-static int snd_opl3_set_params(opl3_t * opl3, snd_dm_fm_params_t * params);
-static int snd_opl3_set_mode(opl3_t * opl3, int mode);
-static int snd_opl3_set_connection(opl3_t * opl3, int connection);
+static int snd_opl3_play_note(struct snd_opl3 * opl3, struct snd_dm_fm_note * note);
+static int snd_opl3_set_voice(struct snd_opl3 * opl3, struct snd_dm_fm_voice * voice);
+static int snd_opl3_set_params(struct snd_opl3 * opl3, struct snd_dm_fm_params * params);
+static int snd_opl3_set_mode(struct snd_opl3 * opl3, int mode);
+static int snd_opl3_set_connection(struct snd_opl3 * opl3, int connection);
 
 /* ------------------------------ */
 
 /*
  * open the device exclusively
  */
-int snd_opl3_open(snd_hwdep_t * hw, struct file *file)
+int snd_opl3_open(struct snd_hwdep * hw, struct file *file)
 {
-	opl3_t *opl3 = hw->private_data;
+	struct snd_opl3 *opl3 = hw->private_data;
 
 	down(&opl3->access_mutex);
 	if (opl3->used) {
@@ -90,10 +90,10 @@ int snd_opl3_open(snd_hwdep_t * hw, struct file *file)
 /*
  * ioctl for hwdep device:
  */
-int snd_opl3_ioctl(snd_hwdep_t * hw, struct file *file,
+int snd_opl3_ioctl(struct snd_hwdep * hw, struct file *file,
 		   unsigned int cmd, unsigned long arg)
 {
-	opl3_t *opl3 = hw->private_data;
+	struct snd_opl3 *opl3 = hw->private_data;
 	void __user *argp = (void __user *)arg;
 
 	snd_assert(opl3 != NULL, return -EINVAL);
@@ -102,11 +102,11 @@ int snd_opl3_ioctl(snd_hwdep_t * hw, struct file *file,
 		/* get information */
 	case SNDRV_DM_FM_IOCTL_INFO:
 		{
-			snd_dm_fm_info_t info;
+			struct snd_dm_fm_info info;
 
 			info.fm_mode = opl3->fm_mode;
 			info.rhythm = opl3->rhythm;
-			if (copy_to_user(argp, &info, sizeof(snd_dm_fm_info_t)))
+			if (copy_to_user(argp, &info, sizeof(struct snd_dm_fm_info)))
 				return -EFAULT;
 			return 0;
 		}
@@ -123,8 +123,8 @@ int snd_opl3_ioctl(snd_hwdep_t * hw, struct file *file,
 	case SNDRV_DM_FM_OSS_IOCTL_PLAY_NOTE:
 #endif
 		{
-			snd_dm_fm_note_t note;
-			if (copy_from_user(&note, argp, sizeof(snd_dm_fm_note_t)))
+			struct snd_dm_fm_note note;
+			if (copy_from_user(&note, argp, sizeof(struct snd_dm_fm_note)))
 				return -EFAULT;
 			return snd_opl3_play_note(opl3, &note);
 		}
@@ -134,8 +134,8 @@ int snd_opl3_ioctl(snd_hwdep_t * hw, struct file *file,
 	case SNDRV_DM_FM_OSS_IOCTL_SET_VOICE:
 #endif
 		{
-			snd_dm_fm_voice_t voice;
-			if (copy_from_user(&voice, argp, sizeof(snd_dm_fm_voice_t)))
+			struct snd_dm_fm_voice voice;
+			if (copy_from_user(&voice, argp, sizeof(struct snd_dm_fm_voice)))
 				return -EFAULT;
 			return snd_opl3_set_voice(opl3, &voice);
 		}
@@ -145,8 +145,8 @@ int snd_opl3_ioctl(snd_hwdep_t * hw, struct file *file,
 	case SNDRV_DM_FM_OSS_IOCTL_SET_PARAMS:
 #endif
 		{
-			snd_dm_fm_params_t params;
-			if (copy_from_user(&params, argp, sizeof(snd_dm_fm_params_t)))
+			struct snd_dm_fm_params params;
+			if (copy_from_user(&params, argp, sizeof(struct snd_dm_fm_params)))
 				return -EFAULT;
 			return snd_opl3_set_params(opl3, &params);
 		}
@@ -174,9 +174,9 @@ int snd_opl3_ioctl(snd_hwdep_t * hw, struct file *file,
 /*
  * close the device
  */
-int snd_opl3_release(snd_hwdep_t * hw, struct file *file)
+int snd_opl3_release(struct snd_hwdep * hw, struct file *file)
 {
-	opl3_t *opl3 = hw->private_data;
+	struct snd_opl3 *opl3 = hw->private_data;
 
 	snd_opl3_reset(opl3);
 	down(&opl3->access_mutex);
@@ -188,7 +188,7 @@ int snd_opl3_release(snd_hwdep_t * hw, struct file *file)
 
 /* ------------------------------ */
 
-void snd_opl3_reset(opl3_t * opl3)
+void snd_opl3_reset(struct snd_opl3 * opl3)
 {
 	unsigned short opl3_reg;
 
@@ -229,7 +229,7 @@ void snd_opl3_reset(opl3_t * opl3)
 }
 
 
-static int snd_opl3_play_note(opl3_t * opl3, snd_dm_fm_note_t * note)
+static int snd_opl3_play_note(struct snd_opl3 * opl3, struct snd_dm_fm_note * note)
 {
 	unsigned short reg_side;
 	unsigned char voice_offset;
@@ -276,7 +276,7 @@ static int snd_opl3_play_note(opl3_t * opl3, snd_dm_fm_note_t * note)
 }
 
 
-static int snd_opl3_set_voice(opl3_t * opl3, snd_dm_fm_voice_t * voice)
+static int snd_opl3_set_voice(struct snd_opl3 * opl3, struct snd_dm_fm_voice * voice)
 {
 	unsigned short reg_side;
 	unsigned char op_offset;
@@ -378,7 +378,7 @@ static int snd_opl3_set_voice(opl3_t * opl3, snd_dm_fm_voice_t * voice)
 	return 0;
 }
 
-static int snd_opl3_set_params(opl3_t * opl3, snd_dm_fm_params_t * params)
+static int snd_opl3_set_params(struct snd_opl3 * opl3, struct snd_dm_fm_params * params)
 {
 	unsigned char reg_val;
 
@@ -418,7 +418,7 @@ static int snd_opl3_set_params(opl3_t * opl3, snd_dm_fm_params_t * params)
 	return 0;
 }
 
-static int snd_opl3_set_mode(opl3_t * opl3, int mode)
+static int snd_opl3_set_mode(struct snd_opl3 * opl3, int mode)
 {
 	if ((mode == SNDRV_DM_FM_MODE_OPL3) && (opl3->hardware < OPL3_HW_OPL3))
 		return -EINVAL;
@@ -430,7 +430,7 @@ static int snd_opl3_set_mode(opl3_t * opl3, int mode)
 	return 0;
 }
 
-static int snd_opl3_set_connection(opl3_t * opl3, int connection)
+static int snd_opl3_set_connection(struct snd_opl3 * opl3, int connection)
 {
 	unsigned char reg_val;
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/drivers/opl3/opl3_synth.c b/sound/drivers/opl3/opl3_synth.c
new file mode 100644
index 000000000000..04f9f955e5b7
--- /dev/null
+++ b/sound/drivers/opl3/opl3_synth.c
@@ -0,0 +1,447 @@
+/*
+ *  Copyright (c) by Uros Bizjak <uros@kss-loka.si>
+ *                   
+ *  Routines for OPL2/OPL3/OPL4 control
+ *
+ *   This program is free software; you can redistribute it and/or modify 
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/opl3.h>
+#include <sound/asound_fm.h>
+
+/*
+ *    There is 18 possible 2 OP voices
+ *      (9 in the left and 9 in the right).
+ *      The first OP is the modulator and 2nd is the carrier.
+ *
+ *      The first three voices in the both sides may be connected
+ *      with another voice to a 4 OP voice. For example voice 0
+ *      can be connected with voice 3. The operators of voice 3 are
+ *      used as operators 3 and 4 of the new 4 OP voice.
+ *      In this case the 2 OP voice number 0 is the 'first half' and
+ *      voice 3 is the second.
+ */
+
+
+/*
+ *    Register offset table for OPL2/3 voices,
+ *    OPL2 / one OPL3 register array side only
+ */
+
+char snd_opl3_regmap[MAX_OPL2_VOICES][4] =
+{
+/*	  OP1   OP2   OP3   OP4		*/
+/*	 ------------------------	*/
+	{ 0x00, 0x03, 0x08, 0x0b },
+	{ 0x01, 0x04, 0x09, 0x0c },
+	{ 0x02, 0x05, 0x0a, 0x0d },
+
+	{ 0x08, 0x0b, 0x00, 0x00 },
+	{ 0x09, 0x0c, 0x00, 0x00 },
+	{ 0x0a, 0x0d, 0x00, 0x00 },
+
+	{ 0x10, 0x13, 0x00, 0x00 },	/* used by percussive voices */
+	{ 0x11, 0x14, 0x00, 0x00 },	/* if the percussive mode */
+	{ 0x12, 0x15, 0x00, 0x00 }	/* is selected (only left reg block) */
+};
+
+/*
+ * prototypes
+ */
+static int snd_opl3_play_note(opl3_t * opl3, snd_dm_fm_note_t * note);
+static int snd_opl3_set_voice(opl3_t * opl3, snd_dm_fm_voice_t * voice);
+static int snd_opl3_set_params(opl3_t * opl3, snd_dm_fm_params_t * params);
+static int snd_opl3_set_mode(opl3_t * opl3, int mode);
+static int snd_opl3_set_connection(opl3_t * opl3, int connection);
+
+/* ------------------------------ */
+
+/*
+ * open the device exclusively
+ */
+int snd_opl3_open(snd_hwdep_t * hw, struct file *file)
+{
+	opl3_t *opl3 = hw->private_data;
+
+	down(&opl3->access_mutex);
+	if (opl3->used) {
+		up(&opl3->access_mutex);
+		return -EAGAIN;
+	}
+	opl3->used++;
+	up(&opl3->access_mutex);
+
+	return 0;
+}
+
+/*
+ * ioctl for hwdep device:
+ */
+int snd_opl3_ioctl(snd_hwdep_t * hw, struct file *file,
+		   unsigned int cmd, unsigned long arg)
+{
+	opl3_t *opl3 = hw->private_data;
+	void __user *argp = (void __user *)arg;
+
+	snd_assert(opl3 != NULL, return -EINVAL);
+
+	switch (cmd) {
+		/* get information */
+	case SNDRV_DM_FM_IOCTL_INFO:
+		{
+			snd_dm_fm_info_t info;
+
+			info.fm_mode = opl3->fm_mode;
+			info.rhythm = opl3->rhythm;
+			if (copy_to_user(argp, &info, sizeof(snd_dm_fm_info_t)))
+				return -EFAULT;
+			return 0;
+		}
+
+	case SNDRV_DM_FM_IOCTL_RESET:
+#ifdef CONFIG_SND_OSSEMUL
+	case SNDRV_DM_FM_OSS_IOCTL_RESET:
+#endif
+		snd_opl3_reset(opl3);
+		return 0;
+
+	case SNDRV_DM_FM_IOCTL_PLAY_NOTE:
+#ifdef CONFIG_SND_OSSEMUL
+	case SNDRV_DM_FM_OSS_IOCTL_PLAY_NOTE:
+#endif
+		{
+			snd_dm_fm_note_t note;
+			if (copy_from_user(&note, argp, sizeof(snd_dm_fm_note_t)))
+				return -EFAULT;
+			return snd_opl3_play_note(opl3, &note);
+		}
+
+	case SNDRV_DM_FM_IOCTL_SET_VOICE:
+#ifdef CONFIG_SND_OSSEMUL
+	case SNDRV_DM_FM_OSS_IOCTL_SET_VOICE:
+#endif
+		{
+			snd_dm_fm_voice_t voice;
+			if (copy_from_user(&voice, argp, sizeof(snd_dm_fm_voice_t)))
+				return -EFAULT;
+			return snd_opl3_set_voice(opl3, &voice);
+		}
+
+	case SNDRV_DM_FM_IOCTL_SET_PARAMS:
+#ifdef CONFIG_SND_OSSEMUL
+	case SNDRV_DM_FM_OSS_IOCTL_SET_PARAMS:
+#endif
+		{
+			snd_dm_fm_params_t params;
+			if (copy_from_user(&params, argp, sizeof(snd_dm_fm_params_t)))
+				return -EFAULT;
+			return snd_opl3_set_params(opl3, &params);
+		}
+
+	case SNDRV_DM_FM_IOCTL_SET_MODE:
+#ifdef CONFIG_SND_OSSEMUL
+	case SNDRV_DM_FM_OSS_IOCTL_SET_MODE:
+#endif
+		return snd_opl3_set_mode(opl3, (int) arg);
+
+	case SNDRV_DM_FM_IOCTL_SET_CONNECTION:
+#ifdef CONFIG_SND_OSSEMUL
+	case SNDRV_DM_FM_OSS_IOCTL_SET_OPL:
+#endif
+		return snd_opl3_set_connection(opl3, (int) arg);
+
+#ifdef CONFIG_SND_DEBUG
+	default:
+		snd_printk("unknown IOCTL: 0x%x\n", cmd);
+#endif
+	}
+	return -ENOTTY;
+}
+
+/*
+ * close the device
+ */
+int snd_opl3_release(snd_hwdep_t * hw, struct file *file)
+{
+	opl3_t *opl3 = hw->private_data;
+
+	snd_opl3_reset(opl3);
+	down(&opl3->access_mutex);
+	opl3->used--;
+	up(&opl3->access_mutex);
+
+	return 0;
+}
+
+/* ------------------------------ */
+
+void snd_opl3_reset(opl3_t * opl3)
+{
+	unsigned short opl3_reg;
+
+	unsigned short reg_side;
+	unsigned char voice_offset;
+
+	int max_voices, i;
+
+	max_voices = (opl3->hardware < OPL3_HW_OPL3) ?
+		MAX_OPL2_VOICES : MAX_OPL3_VOICES;
+
+	for (i = 0; i < max_voices; i++) {
+		/* Get register array side and offset of voice */
+		if (i < MAX_OPL2_VOICES) {
+			/* Left register block for voices 0 .. 8 */
+			reg_side = OPL3_LEFT;
+			voice_offset = i;
+		} else {
+			/* Right register block for voices 9 .. 17 */
+			reg_side = OPL3_RIGHT;
+			voice_offset = i - MAX_OPL2_VOICES;
+		}
+		opl3_reg = reg_side | (OPL3_REG_KSL_LEVEL + snd_opl3_regmap[voice_offset][0]);
+		opl3->command(opl3, opl3_reg, OPL3_TOTAL_LEVEL_MASK); /* Operator 1 volume */
+		opl3_reg = reg_side | (OPL3_REG_KSL_LEVEL + snd_opl3_regmap[voice_offset][1]);
+		opl3->command(opl3, opl3_reg, OPL3_TOTAL_LEVEL_MASK); /* Operator 2 volume */
+
+		opl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);
+		opl3->command(opl3, opl3_reg, 0x00);	/* Note off */
+	}
+
+	opl3->max_voices = MAX_OPL2_VOICES;
+	opl3->fm_mode = SNDRV_DM_FM_MODE_OPL2;
+
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TEST, OPL3_ENABLE_WAVE_SELECT);
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION, 0x00);	/* Melodic mode */
+	opl3->rhythm = 0;
+}
+
+
+static int snd_opl3_play_note(opl3_t * opl3, snd_dm_fm_note_t * note)
+{
+	unsigned short reg_side;
+	unsigned char voice_offset;
+
+	unsigned short opl3_reg;
+	unsigned char reg_val;
+
+	/* Voices 0 -  8 in OPL2 mode */
+	/* Voices 0 - 17 in OPL3 mode */
+	if (note->voice >= ((opl3->fm_mode == SNDRV_DM_FM_MODE_OPL3) ?
+			    MAX_OPL3_VOICES : MAX_OPL2_VOICES))
+		return -EINVAL;
+
+	/* Get register array side and offset of voice */
+	if (note->voice < MAX_OPL2_VOICES) {
+		/* Left register block for voices 0 .. 8 */
+		reg_side = OPL3_LEFT;
+		voice_offset = note->voice;
+	} else {
+		/* Right register block for voices 9 .. 17 */
+		reg_side = OPL3_RIGHT;
+		voice_offset = note->voice - MAX_OPL2_VOICES;
+	}
+
+	/* Set lower 8 bits of note frequency */
+	reg_val = (unsigned char) note->fnum;
+	opl3_reg = reg_side | (OPL3_REG_FNUM_LOW + voice_offset);
+	opl3->command(opl3, opl3_reg, reg_val);
+	
+	reg_val = 0x00;
+	/* Set output sound flag */
+	if (note->key_on)
+		reg_val |= OPL3_KEYON_BIT;
+	/* Set octave */
+	reg_val |= (note->octave << 2) & OPL3_BLOCKNUM_MASK;
+	/* Set higher 2 bits of note frequency */
+	reg_val |= (unsigned char) (note->fnum >> 8) & OPL3_FNUM_HIGH_MASK;
+
+	/* Set OPL3 KEYON_BLOCK register of requested voice */ 
+	opl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);
+	opl3->command(opl3, opl3_reg, reg_val);
+
+	return 0;
+}
+
+
+static int snd_opl3_set_voice(opl3_t * opl3, snd_dm_fm_voice_t * voice)
+{
+	unsigned short reg_side;
+	unsigned char op_offset;
+	unsigned char voice_offset;
+
+	unsigned short opl3_reg;
+	unsigned char reg_val;
+
+	/* Only operators 1 and 2 */
+	if (voice->op > 1)
+		return -EINVAL;
+	/* Voices 0 -  8 in OPL2 mode */
+	/* Voices 0 - 17 in OPL3 mode */
+	if (voice->voice >= ((opl3->fm_mode == SNDRV_DM_FM_MODE_OPL3) ?
+			     MAX_OPL3_VOICES : MAX_OPL2_VOICES))
+		return -EINVAL;
+
+	/* Get register array side and offset of voice */
+	if (voice->voice < MAX_OPL2_VOICES) {
+		/* Left register block for voices 0 .. 8 */
+		reg_side = OPL3_LEFT;
+		voice_offset = voice->voice;
+	} else {
+		/* Right register block for voices 9 .. 17 */
+		reg_side = OPL3_RIGHT;
+		voice_offset = voice->voice - MAX_OPL2_VOICES;
+	}
+	/* Get register offset of operator */
+	op_offset = snd_opl3_regmap[voice_offset][voice->op];
+
+	reg_val = 0x00;
+	/* Set amplitude modulation (tremolo) effect */
+	if (voice->am)
+		reg_val |= OPL3_TREMOLO_ON;
+	/* Set vibrato effect */
+	if (voice->vibrato)
+		reg_val |= OPL3_VIBRATO_ON;
+	/* Set sustaining sound phase */
+	if (voice->do_sustain)
+		reg_val |= OPL3_SUSTAIN_ON;
+	/* Set keyboard scaling bit */ 
+	if (voice->kbd_scale)
+		reg_val |= OPL3_KSR;
+	/* Set harmonic or frequency multiplier */
+	reg_val |= voice->harmonic & OPL3_MULTIPLE_MASK;
+
+	/* Set OPL3 AM_VIB register of requested voice/operator */ 
+	opl3_reg = reg_side | (OPL3_REG_AM_VIB + op_offset);
+	opl3->command(opl3, opl3_reg, reg_val);
+
+	/* Set decreasing volume of higher notes */
+	reg_val = (voice->scale_level << 6) & OPL3_KSL_MASK;
+	/* Set output volume */
+	reg_val |= ~voice->volume & OPL3_TOTAL_LEVEL_MASK;
+
+	/* Set OPL3 KSL_LEVEL register of requested voice/operator */ 
+	opl3_reg = reg_side | (OPL3_REG_KSL_LEVEL + op_offset);
+	opl3->command(opl3, opl3_reg, reg_val);
+
+	/* Set attack phase level */
+	reg_val = (voice->attack << 4) & OPL3_ATTACK_MASK;
+	/* Set decay phase level */
+	reg_val |= voice->decay & OPL3_DECAY_MASK;
+
+	/* Set OPL3 ATTACK_DECAY register of requested voice/operator */ 
+	opl3_reg = reg_side | (OPL3_REG_ATTACK_DECAY + op_offset);
+	opl3->command(opl3, opl3_reg, reg_val);
+
+	/* Set sustain phase level */
+	reg_val = (voice->sustain << 4) & OPL3_SUSTAIN_MASK;
+	/* Set release phase level */
+	reg_val |= voice->release & OPL3_RELEASE_MASK;
+
+	/* Set OPL3 SUSTAIN_RELEASE register of requested voice/operator */ 
+	opl3_reg = reg_side | (OPL3_REG_SUSTAIN_RELEASE + op_offset);
+	opl3->command(opl3, opl3_reg, reg_val);
+
+	/* Set inter-operator feedback */
+	reg_val = (voice->feedback << 1) & OPL3_FEEDBACK_MASK;
+	/* Set inter-operator connection */
+	if (voice->connection)
+		reg_val |= OPL3_CONNECTION_BIT;
+	/* OPL-3 only */
+	if (opl3->fm_mode == SNDRV_DM_FM_MODE_OPL3) {
+		if (voice->left)
+			reg_val |= OPL3_VOICE_TO_LEFT;
+		if (voice->right)
+			reg_val |= OPL3_VOICE_TO_RIGHT;
+	}
+	/* Feedback/connection bits are applicable to voice */
+	opl3_reg = reg_side | (OPL3_REG_FEEDBACK_CONNECTION + voice_offset);
+	opl3->command(opl3, opl3_reg, reg_val);
+
+	/* Select waveform */
+	reg_val = voice->waveform & OPL3_WAVE_SELECT_MASK;
+	opl3_reg = reg_side | (OPL3_REG_WAVE_SELECT + op_offset);
+	opl3->command(opl3, opl3_reg, reg_val);
+
+	return 0;
+}
+
+static int snd_opl3_set_params(opl3_t * opl3, snd_dm_fm_params_t * params)
+{
+	unsigned char reg_val;
+
+	reg_val = 0x00;
+	/* Set keyboard split method */
+	if (params->kbd_split)
+		reg_val |= OPL3_KEYBOARD_SPLIT;
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_KBD_SPLIT, reg_val);
+
+	reg_val = 0x00;
+	/* Set amplitude modulation (tremolo) depth */
+	if (params->am_depth)
+		reg_val |= OPL3_TREMOLO_DEPTH;
+	/* Set vibrato depth */
+	if (params->vib_depth)
+		reg_val |= OPL3_VIBRATO_DEPTH;
+	/* Set percussion mode */
+	if (params->rhythm) {
+		reg_val |= OPL3_PERCUSSION_ENABLE;
+		opl3->rhythm = 1;
+	} else {
+		opl3->rhythm = 0;
+	}
+	/* Play percussion instruments */
+	if (params->bass)
+		reg_val |= OPL3_BASSDRUM_ON;
+	if (params->snare)
+		reg_val |= OPL3_SNAREDRUM_ON;
+	if (params->tomtom)
+		reg_val |= OPL3_TOMTOM_ON;
+	if (params->cymbal)
+		reg_val |= OPL3_CYMBAL_ON;
+	if (params->hihat)
+		reg_val |= OPL3_HIHAT_ON;
+
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION, reg_val);
+	return 0;
+}
+
+static int snd_opl3_set_mode(opl3_t * opl3, int mode)
+{
+	if ((mode == SNDRV_DM_FM_MODE_OPL3) && (opl3->hardware < OPL3_HW_OPL3))
+		return -EINVAL;
+
+	opl3->fm_mode = mode;
+	if (opl3->hardware >= OPL3_HW_OPL3)
+		opl3->command(opl3, OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT, 0x00);	/* Clear 4-op connections */
+
+	return 0;
+}
+
+static int snd_opl3_set_connection(opl3_t * opl3, int connection)
+{
+	unsigned char reg_val;
+
+	/* OPL-3 only */
+	if (opl3->fm_mode != SNDRV_DM_FM_MODE_OPL3)
+		return -EINVAL;
+
+	reg_val = connection & (OPL3_RIGHT_4OP_0 | OPL3_RIGHT_4OP_1 | OPL3_RIGHT_4OP_2 |
+				OPL3_LEFT_4OP_0 | OPL3_LEFT_4OP_1 | OPL3_LEFT_4OP_2);
+	/* Set 4-op connections */
+	opl3->command(opl3, OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT, reg_val);
+
+	return 0;
+}
