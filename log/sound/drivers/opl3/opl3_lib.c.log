commit 5ff16a3d48ef58be8fd93035ae9272d4cc990c49
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:37 2020 +0100

    ALSA: Constify snd_timer_hardware definitions
    
    Most of snd_timer_hardware definitions do simply copying to another
    struct as-is.  Mark them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-22-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index 6134e5ffea0b..9259522483c8 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -214,7 +214,7 @@ static int snd_opl3_timer2_stop(struct snd_timer * timer)
 
  */
 
-static struct snd_timer_hardware snd_opl3_timer1 =
+static const struct snd_timer_hardware snd_opl3_timer1 =
 {
 	.flags =	SNDRV_TIMER_HW_STOP,
 	.resolution =	80000,
@@ -223,7 +223,7 @@ static struct snd_timer_hardware snd_opl3_timer1 =
 	.stop =		snd_opl3_timer1_stop,
 };
 
-static struct snd_timer_hardware snd_opl3_timer2 =
+static const struct snd_timer_hardware snd_opl3_timer2 =
 {
 	.flags =	SNDRV_TIMER_HW_STOP,
 	.resolution =	320000,

commit 34273b234c0712c963f02845919125686f503d3e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:21 2020 +0100

    ALSA: drivers: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-6-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index cbdec28e89af..6134e5ffea0b 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -332,7 +332,7 @@ int snd_opl3_new(struct snd_card *card,
 		 unsigned short hardware,
 		 struct snd_opl3 **ropl3)
 {
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free = snd_opl3_dev_free,
 	};
 	struct snd_opl3 *opl3;

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index cf86c36c7c3b..cbdec28e89af 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>,
  *                   Hannu Savolainen 1993-1996,
@@ -6,21 +7,6 @@
  *  Routines for control of AdLib FM cards (OPL2/OPL3/OPL4 chips)
  *
  *  Most if code is ported from OSS/Lite.
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <sound/opl3.h>

commit 969686ee0e0ff62ece428e8e02b07f81ac88a84d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 3 15:42:46 2018 +0200

    ALSA: drivers: Remove empty init and exit
    
    For a sake of code simplification, remove the init and the exit
    entries that do nothing.
    
    Notes for readers: actually it's OK to remove *both* init and exit,
    but not OK to remove the exit entry.  By removing only the exit while
    keeping init, the module becomes permanently loaded; i.e. you cannot
    unload it any longer!
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index 1a5355b747ec..cf86c36c7c3b 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -538,19 +538,3 @@ int snd_opl3_hwdep_new(struct snd_opl3 * opl3,
 }
 
 EXPORT_SYMBOL(snd_opl3_hwdep_new);
-
-/*
- *  INIT part
- */
-
-static int __init alsa_opl3_init(void)
-{
-	return 0;
-}
-
-static void __exit alsa_opl3_exit(void)
-{
-}
-
-module_init(alsa_opl3_init)
-module_exit(alsa_opl3_exit)

commit 7e9c20f40304a16d5f69dbdc44a551cc48252266
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 23:00:52 2018 +0200

    ALSA: opl3: Declare common variables properly
    
    Move the declarations of common variables into opl3_voice.h instead of
    declaring at each file multiple times, which was error-prone.
    
    This fixes sparse warnings like:
      sound/drivers/opl3/opl3_synth.c:51:6: warning: symbol 'snd_opl3_regmap' was not declared. Should it be static?
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index 588963d6be28..1a5355b747ec 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -31,13 +31,12 @@
 #include <linux/slab.h>
 #include <linux/ioport.h>
 #include <sound/minors.h>
+#include "opl3_voice.h"
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>, Hannu Savolainen 1993-1996, Rob Hooft");
 MODULE_DESCRIPTION("Routines for control of AdLib FM cards (OPL2/OPL3/OPL4 chips)");
 MODULE_LICENSE("GPL");
 
-extern char snd_opl3_regmap[MAX_OPL2_VOICES][4];
-
 static void snd_opl2_command(struct snd_opl3 * opl3, unsigned short cmd, unsigned char val)
 {
 	unsigned long flags;

commit 2b223a91197ffd45d556625edf2939f07f2b7730
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Aug 12 19:54:20 2017 +0200

    ALSA: opl3: Delete an error message for a failed memory allocation in snd_opl3_new()
    
    Omit an extra message for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index d5e5b4657b4b..588963d6be28 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -355,10 +355,8 @@ int snd_opl3_new(struct snd_card *card,
 
 	*ropl3 = NULL;
 	opl3 = kzalloc(sizeof(*opl3), GFP_KERNEL);
-	if (opl3 == NULL) {
-		snd_printk(KERN_ERR "opl3: cannot allocate\n");
+	if (!opl3)
 		return -ENOMEM;
-	}
 
 	opl3->card = card;
 	opl3->hardware = hardware;

commit 111b0cdb97d44cfe5dec1338a78ba8aff65c32e2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 9 15:11:58 2017 +0200

    ALSA: seq: Allow the modular sequencer registration
    
    Many drivers bind the sequencer stuff in off-load by another driver
    module, so that it's loaded only on demand.  In the current code, this
    mechanism doesn't work when the driver is built-in while the sequencer
    is module.  We check with IS_REACHABLE() and enable only when the
    sequencer is in the same level of build.
    
    However, this is basically a overshoot.  The binder code
    (snd-seq-device) is an individual module from the sequencer core
    (snd-seq), and we just have to make the former a built-in while
    keeping the latter a module for allowing the scenario like the above.
    
    This patch achieves that by rewriting Kconfig slightly.  Now, a driver
    that provides the manual sequencer device binding should select
    CONFIG_SND_SEQ_DEVICE in a way as
            select SND_SEQ_DEVICE if SND_SEQUENCER != n
    
    Note that the "!=n" is needed here to avoid the influence of the
    sequencer core is module while the driver is built-in.
    
    Also, since rawmidi.o may be linked with snd_seq_device.o when
    built-in, we have to shuffle the code to make the linker happy.
    (the kernel linker isn't smart enough yet to handle such a case.)
    That is, snd_seq_device.c is moved to sound/core from sound/core/seq,
    as well as Makefile.
    
    Last but not least, the patch replaces the code using IS_REACHABLE()
    with IS_ENABLED(), since now the condition meets always when enabled.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index cd9e9f31720f..d5e5b4657b4b 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -528,7 +528,7 @@ int snd_opl3_hwdep_new(struct snd_opl3 * opl3,
 
 	opl3->hwdep = hw;
 	opl3->seq_dev_num = seq_device;
-#if IS_REACHABLE(CONFIG_SND_SEQUENCER)
+#if IS_ENABLED(CONFIG_SND_SEQUENCER)
 	if (snd_seq_device_new(card, seq_device, SNDRV_SEQ_DEV_ID_OPL3,
 			       sizeof(struct snd_opl3 *), &opl3->seq_dev) >= 0) {
 		strcpy(opl3->seq_dev->name, hw->name);

commit db0717da2a74faf7694cdfe1e591425e84ae7504
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sat Nov 12 09:28:33 2016 +0100

    ALSA: opl3: don't opencode IS_REACHABLE()
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index 369cef212ea9..cd9e9f31720f 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -528,7 +528,7 @@ int snd_opl3_hwdep_new(struct snd_opl3 * opl3,
 
 	opl3->hwdep = hw;
 	opl3->seq_dev_num = seq_device;
-#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
+#if IS_REACHABLE(CONFIG_SND_SEQUENCER)
 	if (snd_seq_device_new(card, seq_device, SNDRV_SEQ_DEV_ID_OPL3,
 			       sizeof(struct snd_opl3 *), &opl3->seq_dev) >= 0) {
 		strcpy(opl3->seq_dev->name, hw->name);

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index f66af5884c40..369cef212ea9 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -24,7 +24,7 @@
  */
 
 #include <sound/opl3.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/init.h>

commit 80d7d771ae839d6fc2286f443ad8445b6721a7f3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 4 13:51:45 2014 +0100

    ALSA: Drop unused name argument in snd_register_oss_device()
    
    The last argument, name, of snd_oss_register_device() is nowhere
    referred in the function in the current code.  Let's drop it.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index 33d9a857a262..f66af5884c40 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -501,10 +501,8 @@ int snd_opl3_hwdep_new(struct snd_opl3 * opl3,
 	hw->private_data = opl3;
 	hw->exclusive = 1;
 #ifdef CONFIG_SND_OSSEMUL
-	if (device == 0) {
+	if (device == 0)
 		hw->oss_type = SNDRV_OSS_DEVICE_TYPE_DMFM;
-		sprintf(hw->oss_dev, "dmfm%i", card->number);
-	}
 #endif
 	strcpy(hw->name, hw->id);
 	switch (opl3->hardware & OPL3_HW_MASK) {

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index 6e31e46ca393..33d9a857a262 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -26,6 +26,7 @@
 #include <sound/opl3.h>
 #include <asm/io.h>
 #include <linux/delay.h>
+#include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/ioport.h>

commit 45203832df2fa9e94ca0a249ddb20d2b077e58cc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 15:51:50 2009 +0100

    ALSA: Add missing KERN_* prefix to printk in sound/drivers
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index 780582340fef..6e31e46ca393 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -302,7 +302,7 @@ void snd_opl3_interrupt(struct snd_hwdep * hw)
 	opl3 = hw->private_data;
 	status = inb(opl3->l_port);
 #if 0
-	snd_printk("AdLib IRQ status = 0x%x\n", status);
+	snd_printk(KERN_DEBUG "AdLib IRQ status = 0x%x\n", status);
 #endif
 	if (!(status & 0x80))
 		return;

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index ebe4359047cb..780582340fef 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -139,7 +139,8 @@ static int snd_opl3_detect(struct snd_opl3 * opl3)
 		 * If we had an OPL4 chip, opl3->hardware would have been set
 		 * by the OPL4 driver; so we can assume OPL3 here.
 		 */
-		snd_assert(opl3->r_port != 0, return -ENODEV);
+		if (snd_BUG_ON(!opl3->r_port))
+			return -ENODEV;
 		opl3->hardware = OPL3_HW_OPL3;
 	}
 	return 0;
@@ -324,7 +325,8 @@ EXPORT_SYMBOL(snd_opl3_interrupt);
 
 static int snd_opl3_free(struct snd_opl3 *opl3)
 {
-	snd_assert(opl3 != NULL, return -ENXIO);
+	if (snd_BUG_ON(!opl3))
+		return -ENXIO;
 	if (opl3->private_free)
 		opl3->private_free(opl3);
 	snd_opl3_clear_patches(opl3);

commit 045765253c610cb5acebb22ae94d759f586d9521
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 30 12:43:40 2007 +0100

    [ALSA] opl3 - Fix build errors
    
    I applied a wrong patch for 'opl3 - simplify exclusive access lock'.
    Fixed now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index a1270841290b..ebe4359047cb 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -525,6 +525,7 @@ int snd_opl3_hwdep_new(struct snd_opl3 * opl3,
 	hw->ops.write = snd_opl3_write;
 	hw->ops.release = snd_opl3_release;
 
+	opl3->hwdep = hw;
 	opl3->seq_dev_num = seq_device;
 #if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
 	if (snd_seq_device_new(card, seq_device, SNDRV_SEQ_DEV_ID_OPL3,

commit 05c1afe75fcebf456017ec186811cf1599f4360e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 30 11:59:15 2007 +0100

    [ALSA] opl3 - simplify exclusive access lock
    
    Use the exclusive access lock in hwdep instead of the own one.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index a657da922b4d..a1270841290b 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -361,7 +361,6 @@ int snd_opl3_new(struct snd_card *card,
 	opl3->hardware = hardware;
 	spin_lock_init(&opl3->reg_lock);
 	spin_lock_init(&opl3->timer_lock);
-	mutex_init(&opl3->access_mutex);
 
 	if ((err = snd_device_new(card, SNDRV_DEV_CODEC, opl3, &ops)) < 0) {
 		snd_opl3_free(opl3);
@@ -497,6 +496,7 @@ int snd_opl3_hwdep_new(struct snd_opl3 * opl3,
 		return err;
 	}
 	hw->private_data = opl3;
+	hw->exclusive = 1;
 #ifdef CONFIG_SND_OSSEMUL
 	if (device == 0) {
 		hw->oss_type = SNDRV_OSS_DEVICE_TYPE_DMFM;

commit 224a033252bba46c5c8b5df625f5e781ca138f48
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 30 11:49:22 2007 +0100

    [ALSA] opl3 - Use hwdep for patch loading
    
    Use the hwdep device for loading OPL2/3 patch data instead of the
    messy sequencer instrument layer.
    Due to this change, the sbiload program should be updated, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index a2b9ce060295..a657da922b4d 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -327,6 +327,7 @@ static int snd_opl3_free(struct snd_opl3 *opl3)
 	snd_assert(opl3 != NULL, return -ENXIO);
 	if (opl3->private_free)
 		opl3->private_free(opl3);
+	snd_opl3_clear_patches(opl3);
 	release_and_free_resource(opl3->res_l_port);
 	release_and_free_resource(opl3->res_r_port);
 	kfree(opl3);
@@ -521,6 +522,7 @@ int snd_opl3_hwdep_new(struct snd_opl3 * opl3,
 	/* operators - only ioctl */
 	hw->ops.open = snd_opl3_open;
 	hw->ops.ioctl = snd_opl3_ioctl;
+	hw->ops.write = snd_opl3_write;
 	hw->ops.release = snd_opl3_release;
 
 	opl3->seq_dev_num = seq_device;

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index 87fe376f38f0..a2b9ce060295 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>,
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>,
  *                   Hannu Savolainen 1993-1996,
  *                   Rob Hooft
  *                   
@@ -31,7 +31,7 @@
 #include <linux/ioport.h>
 #include <sound/minors.h>
 
-MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, Hannu Savolainen 1993-1996, Rob Hooft");
+MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>, Hannu Savolainen 1993-1996, Rob Hooft");
 MODULE_DESCRIPTION("Routines for control of AdLib FM cards (OPL2/OPL3/OPL4 chips)");
 MODULE_LICENSE("GPL");
 

commit ac19e19b3664feda8040fb9fb7885183a9eb7a80
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:39 2006 +0200

    [ALSA] opl3 - Move EXPORT_SYMBOL() to adjacent to each function
    
    Move EXPORT_SYMBOL() to adjacent to each exported function/variable.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index 4f8556976774..87fe376f38f0 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -316,6 +316,8 @@ void snd_opl3_interrupt(struct snd_hwdep * hw)
 	}
 }
 
+EXPORT_SYMBOL(snd_opl3_interrupt);
+
 /*
 
  */
@@ -369,6 +371,8 @@ int snd_opl3_new(struct snd_card *card,
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_opl3_new);
+
 int snd_opl3_init(struct snd_opl3 *opl3)
 {
 	if (! opl3->command) {
@@ -393,6 +397,8 @@ int snd_opl3_init(struct snd_opl3 *opl3)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_opl3_init);
+
 int snd_opl3_create(struct snd_card *card,
 		    unsigned long l_port,
 		    unsigned long r_port,
@@ -451,6 +457,8 @@ int snd_opl3_create(struct snd_card *card,
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_opl3_create);
+
 int snd_opl3_timer_new(struct snd_opl3 * opl3, int timer1_dev, int timer2_dev)
 {
 	int err;
@@ -468,6 +476,8 @@ int snd_opl3_timer_new(struct snd_opl3 * opl3, int timer1_dev, int timer2_dev)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_opl3_timer_new);
+
 int snd_opl3_hwdep_new(struct snd_opl3 * opl3,
 		       int device, int seq_device,
 		       struct snd_hwdep ** rhwdep)
@@ -526,17 +536,8 @@ int snd_opl3_hwdep_new(struct snd_opl3 * opl3,
 	return 0;
 }
 
-EXPORT_SYMBOL(snd_opl3_interrupt);
-EXPORT_SYMBOL(snd_opl3_new);
-EXPORT_SYMBOL(snd_opl3_init);
-EXPORT_SYMBOL(snd_opl3_create);
-EXPORT_SYMBOL(snd_opl3_timer_new);
 EXPORT_SYMBOL(snd_opl3_hwdep_new);
 
-/* opl3_synth.c */
-EXPORT_SYMBOL(snd_opl3_regmap);
-EXPORT_SYMBOL(snd_opl3_reset);
-
 /*
  *  INIT part
  */

commit ef9f0a42db987e7e2df72289fb4522d24027786b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:31:42 2006 +0100

    [ALSA] semaphore -> mutex (driver part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index 1e0c76b9acfc..4f8556976774 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -358,7 +358,7 @@ int snd_opl3_new(struct snd_card *card,
 	opl3->hardware = hardware;
 	spin_lock_init(&opl3->reg_lock);
 	spin_lock_init(&opl3->timer_lock);
-	init_MUTEX(&opl3->access_mutex);
+	mutex_init(&opl3->access_mutex);
 
 	if ((err = snd_device_new(card, SNDRV_DEV_CODEC, opl3, &ops)) < 0) {
 		snd_opl3_free(opl3);

commit 676338a1623ee9b60a6efb19ef8f743ab3b2eecb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 3 19:56:55 2006 +0100

    [ALSA] opl3 - Fix the unreleased resources
    
    Modules: OPL3
    
    Fix the unreleased resources in the error path of snd_opl3_create().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index 650f3b8e60e0..1e0c76b9acfc 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -409,13 +409,13 @@ int snd_opl3_create(struct snd_card *card,
 	if (! integrated) {
 		if ((opl3->res_l_port = request_region(l_port, 2, "OPL2/3 (left)")) == NULL) {
 			snd_printk(KERN_ERR "opl3: can't grab left port 0x%lx\n", l_port);
-			snd_opl3_free(opl3);
+			snd_device_free(card, opl3);
 			return -EBUSY;
 		}
 		if (r_port != 0 &&
 		    (opl3->res_r_port = request_region(r_port, 2, "OPL2/3 (right)")) == NULL) {
 			snd_printk(KERN_ERR "opl3: can't grab right port 0x%lx\n", r_port);
-			snd_opl3_free(opl3);
+			snd_device_free(card, opl3);
 			return -EBUSY;
 		}
 	}
@@ -434,7 +434,7 @@ int snd_opl3_create(struct snd_card *card,
 		if ((err = snd_opl3_detect(opl3)) < 0) {
 			snd_printd("OPL2/3 chip not detected at 0x%lx/0x%lx\n",
 				   opl3->l_port, opl3->r_port);
-			snd_opl3_free(opl3);
+			snd_device_free(card, opl3);
 			return err;
 		}
 		/* detect routine returns correct hardware type */

commit 73e77ba0235532bd7523ba90883d325f6e095acf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 17:44:01 2005 +0100

    [ALSA] Add error messages
    
    Add error messages in the critial error path to be more verbose.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index cbd37e919601..650f3b8e60e0 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -349,8 +349,10 @@ int snd_opl3_new(struct snd_card *card,
 
 	*ropl3 = NULL;
 	opl3 = kzalloc(sizeof(*opl3), GFP_KERNEL);
-	if (opl3 == NULL)
+	if (opl3 == NULL) {
+		snd_printk(KERN_ERR "opl3: cannot allocate\n");
 		return -ENOMEM;
+	}
 
 	opl3->card = card;
 	opl3->hardware = hardware;

commit 5b1646a8eceff0a4ff06f309abb6e7f43f99a498
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:13:14 2005 +0100

    [ALSA] Remove xxx_t typedefs: OPL3
    
    Modules: OPL3,Raw OPL FM
    
    Remove xxx_t typedefs from the OPL3 driver
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index 06246503083c..cbd37e919601 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -37,7 +37,7 @@ MODULE_LICENSE("GPL");
 
 extern char snd_opl3_regmap[MAX_OPL2_VOICES][4];
 
-static void snd_opl2_command(opl3_t * opl3, unsigned short cmd, unsigned char val)
+static void snd_opl2_command(struct snd_opl3 * opl3, unsigned short cmd, unsigned char val)
 {
 	unsigned long flags;
 	unsigned long port;
@@ -60,7 +60,7 @@ static void snd_opl2_command(opl3_t * opl3, unsigned short cmd, unsigned char va
 	spin_unlock_irqrestore(&opl3->reg_lock, flags);
 }
 
-static void snd_opl3_command(opl3_t * opl3, unsigned short cmd, unsigned char val)
+static void snd_opl3_command(struct snd_opl3 * opl3, unsigned short cmd, unsigned char val)
 {
 	unsigned long flags;
 	unsigned long port;
@@ -85,7 +85,7 @@ static void snd_opl3_command(opl3_t * opl3, unsigned short cmd, unsigned char va
 	spin_unlock_irqrestore(&opl3->reg_lock, flags);
 }
 
-static int snd_opl3_detect(opl3_t * opl3)
+static int snd_opl3_detect(struct snd_opl3 * opl3)
 {
 	/*
 	 * This function returns 1 if the FM chip is present at the given I/O port
@@ -153,12 +153,12 @@ static int snd_opl3_detect(opl3_t * opl3)
  *  Timer 1 - 80us
  */
 
-static int snd_opl3_timer1_start(snd_timer_t * timer)
+static int snd_opl3_timer1_start(struct snd_timer * timer)
 {
 	unsigned long flags;
 	unsigned char tmp;
 	unsigned int ticks;
-	opl3_t *opl3;
+	struct snd_opl3 *opl3;
 
 	opl3 = snd_timer_chip(timer);
 	spin_lock_irqsave(&opl3->timer_lock, flags);
@@ -171,11 +171,11 @@ static int snd_opl3_timer1_start(snd_timer_t * timer)
 	return 0;
 }
 
-static int snd_opl3_timer1_stop(snd_timer_t * timer)
+static int snd_opl3_timer1_stop(struct snd_timer * timer)
 {
 	unsigned long flags;
 	unsigned char tmp;
-	opl3_t *opl3;
+	struct snd_opl3 *opl3;
 
 	opl3 = snd_timer_chip(timer);
 	spin_lock_irqsave(&opl3->timer_lock, flags);
@@ -190,12 +190,12 @@ static int snd_opl3_timer1_stop(snd_timer_t * timer)
  *  Timer 2 - 320us
  */
 
-static int snd_opl3_timer2_start(snd_timer_t * timer)
+static int snd_opl3_timer2_start(struct snd_timer * timer)
 {
 	unsigned long flags;
 	unsigned char tmp;
 	unsigned int ticks;
-	opl3_t *opl3;
+	struct snd_opl3 *opl3;
 
 	opl3 = snd_timer_chip(timer);
 	spin_lock_irqsave(&opl3->timer_lock, flags);
@@ -208,11 +208,11 @@ static int snd_opl3_timer2_start(snd_timer_t * timer)
 	return 0;
 }
 
-static int snd_opl3_timer2_stop(snd_timer_t * timer)
+static int snd_opl3_timer2_stop(struct snd_timer * timer)
 {
 	unsigned long flags;
 	unsigned char tmp;
-	opl3_t *opl3;
+	struct snd_opl3 *opl3;
 
 	opl3 = snd_timer_chip(timer);
 	spin_lock_irqsave(&opl3->timer_lock, flags);
@@ -227,7 +227,7 @@ static int snd_opl3_timer2_stop(snd_timer_t * timer)
 
  */
 
-static struct _snd_timer_hardware snd_opl3_timer1 =
+static struct snd_timer_hardware snd_opl3_timer1 =
 {
 	.flags =	SNDRV_TIMER_HW_STOP,
 	.resolution =	80000,
@@ -236,7 +236,7 @@ static struct _snd_timer_hardware snd_opl3_timer1 =
 	.stop =		snd_opl3_timer1_stop,
 };
 
-static struct _snd_timer_hardware snd_opl3_timer2 =
+static struct snd_timer_hardware snd_opl3_timer2 =
 {
 	.flags =	SNDRV_TIMER_HW_STOP,
 	.resolution =	320000,
@@ -245,10 +245,10 @@ static struct _snd_timer_hardware snd_opl3_timer2 =
 	.stop =		snd_opl3_timer2_stop,
 };
 
-static int snd_opl3_timer1_init(opl3_t * opl3, int timer_no)
+static int snd_opl3_timer1_init(struct snd_opl3 * opl3, int timer_no)
 {
-	snd_timer_t *timer = NULL;
-	snd_timer_id_t tid;
+	struct snd_timer *timer = NULL;
+	struct snd_timer_id tid;
 	int err;
 
 	tid.dev_class = SNDRV_TIMER_CLASS_CARD;
@@ -265,10 +265,10 @@ static int snd_opl3_timer1_init(opl3_t * opl3, int timer_no)
 	return err;
 }
 
-static int snd_opl3_timer2_init(opl3_t * opl3, int timer_no)
+static int snd_opl3_timer2_init(struct snd_opl3 * opl3, int timer_no)
 {
-	snd_timer_t *timer = NULL;
-	snd_timer_id_t tid;
+	struct snd_timer *timer = NULL;
+	struct snd_timer_id tid;
 	int err;
 
 	tid.dev_class = SNDRV_TIMER_CLASS_CARD;
@@ -289,11 +289,11 @@ static int snd_opl3_timer2_init(opl3_t * opl3, int timer_no)
 
  */
 
-void snd_opl3_interrupt(snd_hwdep_t * hw)
+void snd_opl3_interrupt(struct snd_hwdep * hw)
 {
 	unsigned char status;
-	opl3_t *opl3;
-	snd_timer_t *timer;
+	struct snd_opl3 *opl3;
+	struct snd_timer *timer;
 
 	if (hw == NULL)
 		return;
@@ -320,7 +320,7 @@ void snd_opl3_interrupt(snd_hwdep_t * hw)
 
  */
 
-static int snd_opl3_free(opl3_t *opl3)
+static int snd_opl3_free(struct snd_opl3 *opl3)
 {
 	snd_assert(opl3 != NULL, return -ENXIO);
 	if (opl3->private_free)
@@ -331,20 +331,20 @@ static int snd_opl3_free(opl3_t *opl3)
 	return 0;
 }
 
-static int snd_opl3_dev_free(snd_device_t *device)
+static int snd_opl3_dev_free(struct snd_device *device)
 {
-	opl3_t *opl3 = device->device_data;
+	struct snd_opl3 *opl3 = device->device_data;
 	return snd_opl3_free(opl3);
 }
 
-int snd_opl3_new(snd_card_t *card,
+int snd_opl3_new(struct snd_card *card,
 		 unsigned short hardware,
-		 opl3_t **ropl3)
+		 struct snd_opl3 **ropl3)
 {
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free = snd_opl3_dev_free,
 	};
-	opl3_t *opl3;
+	struct snd_opl3 *opl3;
 	int err;
 
 	*ropl3 = NULL;
@@ -367,7 +367,7 @@ int snd_opl3_new(snd_card_t *card,
 	return 0;
 }
 
-int snd_opl3_init(opl3_t *opl3)
+int snd_opl3_init(struct snd_opl3 *opl3)
 {
 	if (! opl3->command) {
 		printk(KERN_ERR "snd_opl3_init: command not defined!\n");
@@ -391,14 +391,14 @@ int snd_opl3_init(opl3_t *opl3)
 	return 0;
 }
 
-int snd_opl3_create(snd_card_t * card,
+int snd_opl3_create(struct snd_card *card,
 		    unsigned long l_port,
 		    unsigned long r_port,
 		    unsigned short hardware,
 		    int integrated,
-		    opl3_t ** ropl3)
+		    struct snd_opl3 ** ropl3)
 {
-	opl3_t *opl3;
+	struct snd_opl3 *opl3;
 	int err;
 
 	*ropl3 = NULL;
@@ -449,7 +449,7 @@ int snd_opl3_create(snd_card_t * card,
 	return 0;
 }
 
-int snd_opl3_timer_new(opl3_t * opl3, int timer1_dev, int timer2_dev)
+int snd_opl3_timer_new(struct snd_opl3 * opl3, int timer1_dev, int timer2_dev)
 {
 	int err;
 
@@ -466,12 +466,12 @@ int snd_opl3_timer_new(opl3_t * opl3, int timer1_dev, int timer2_dev)
 	return 0;
 }
 
-int snd_opl3_hwdep_new(opl3_t * opl3,
+int snd_opl3_hwdep_new(struct snd_opl3 * opl3,
 		       int device, int seq_device,
-		       snd_hwdep_t ** rhwdep)
+		       struct snd_hwdep ** rhwdep)
 {
-	snd_hwdep_t *hw;
-	snd_card_t *card = opl3->card;
+	struct snd_hwdep *hw;
+	struct snd_card *card = opl3->card;
 	int err;
 
 	if (rhwdep)
@@ -514,9 +514,9 @@ int snd_opl3_hwdep_new(opl3_t * opl3,
 	opl3->seq_dev_num = seq_device;
 #if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
 	if (snd_seq_device_new(card, seq_device, SNDRV_SEQ_DEV_ID_OPL3,
-			       sizeof(opl3_t*), &opl3->seq_dev) >= 0) {
+			       sizeof(struct snd_opl3 *), &opl3->seq_dev) >= 0) {
 		strcpy(opl3->seq_dev->name, hw->name);
-		*(opl3_t**)SNDRV_SEQ_DEVICE_ARGPTR(opl3->seq_dev) = opl3;
+		*(struct snd_opl3 **)SNDRV_SEQ_DEVICE_ARGPTR(opl3->seq_dev) = opl3;
 	}
 #endif
 	if (rhwdep)

commit b1d5776d865951c213a1caaab5d8bf5de7615dbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:56:31 2005 +0200

    [ALSA] Remove vmalloc wrapper, kfree_nocheck()
    
    - Remove vmalloc wrapper
    - Add release_and_free_resource() to remove kfree_nocheck() from each driver
      and simplify the code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index 1f84d78260de..06246503083c 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -325,14 +325,8 @@ static int snd_opl3_free(opl3_t *opl3)
 	snd_assert(opl3 != NULL, return -ENXIO);
 	if (opl3->private_free)
 		opl3->private_free(opl3);
-	if (opl3->res_l_port) {
-		release_resource(opl3->res_l_port);
-		kfree_nocheck(opl3->res_l_port);
-	}
-	if (opl3->res_r_port) {
-		release_resource(opl3->res_r_port);
-		kfree_nocheck(opl3->res_r_port);
-	}
+	release_and_free_resource(opl3->res_l_port);
+	release_and_free_resource(opl3->res_r_port);
 	kfree(opl3);
 	return 0;
 }

commit 561b220a4dece18d67177413e6fa21b49aa4acce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:22:34 2005 +0200

    [ALSA] Replace with kzalloc() - others
    
    Documentation,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,OPL3
    OPL4,Digigram VX core,I2C cs8427,I2C lib core,I2C tea6330t,L3 drivers
    AK4114 receiver,AK4117 receiver,PDAudioCF driver,PPC PMAC driver
    SPARC AMD7930 driver,SPARC cs4231 driver,Synth,Common EMU synth
    USB generic driver,USB USX2Y
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
index c313e5205cb8..1f84d78260de 100644
--- a/sound/drivers/opl3/opl3_lib.c
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -354,7 +354,7 @@ int snd_opl3_new(snd_card_t *card,
 	int err;
 
 	*ropl3 = NULL;
-	opl3 = kcalloc(1, sizeof(*opl3), GFP_KERNEL);
+	opl3 = kzalloc(sizeof(*opl3), GFP_KERNEL);
 	if (opl3 == NULL)
 		return -ENOMEM;
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/drivers/opl3/opl3_lib.c b/sound/drivers/opl3/opl3_lib.c
new file mode 100644
index 000000000000..c313e5205cb8
--- /dev/null
+++ b/sound/drivers/opl3/opl3_lib.c
@@ -0,0 +1,558 @@
+/*
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>,
+ *                   Hannu Savolainen 1993-1996,
+ *                   Rob Hooft
+ *                   
+ *  Routines for control of AdLib FM cards (OPL2/OPL3/OPL4 chips)
+ *
+ *  Most if code is ported from OSS/Lite.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/opl3.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <sound/minors.h>
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, Hannu Savolainen 1993-1996, Rob Hooft");
+MODULE_DESCRIPTION("Routines for control of AdLib FM cards (OPL2/OPL3/OPL4 chips)");
+MODULE_LICENSE("GPL");
+
+extern char snd_opl3_regmap[MAX_OPL2_VOICES][4];
+
+static void snd_opl2_command(opl3_t * opl3, unsigned short cmd, unsigned char val)
+{
+	unsigned long flags;
+	unsigned long port;
+
+	/*
+	 * The original 2-OP synth requires a quite long delay
+	 * after writing to a register.
+	 */
+
+	port = (cmd & OPL3_RIGHT) ? opl3->r_port : opl3->l_port;
+
+	spin_lock_irqsave(&opl3->reg_lock, flags);
+
+	outb((unsigned char) cmd, port);
+	udelay(10);
+
+	outb((unsigned char) val, port + 1);
+	udelay(30);
+
+	spin_unlock_irqrestore(&opl3->reg_lock, flags);
+}
+
+static void snd_opl3_command(opl3_t * opl3, unsigned short cmd, unsigned char val)
+{
+	unsigned long flags;
+	unsigned long port;
+
+	/*
+	 * The OPL-3 survives with just two INBs
+	 * after writing to a register.
+	 */
+
+	port = (cmd & OPL3_RIGHT) ? opl3->r_port : opl3->l_port;
+
+	spin_lock_irqsave(&opl3->reg_lock, flags);
+
+	outb((unsigned char) cmd, port);
+	inb(opl3->l_port);
+	inb(opl3->l_port);
+
+	outb((unsigned char) val, port + 1);
+	inb(opl3->l_port);
+	inb(opl3->l_port);
+
+	spin_unlock_irqrestore(&opl3->reg_lock, flags);
+}
+
+static int snd_opl3_detect(opl3_t * opl3)
+{
+	/*
+	 * This function returns 1 if the FM chip is present at the given I/O port
+	 * The detection algorithm plays with the timer built in the FM chip and
+	 * looks for a change in the status register.
+	 *
+	 * Note! The timers of the FM chip are not connected to AdLib (and compatible)
+	 * boards.
+	 *
+	 * Note2! The chip is initialized if detected.
+	 */
+
+	unsigned char stat1, stat2, signature;
+
+	/* Reset timers 1 and 2 */
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_TIMER1_MASK | OPL3_TIMER2_MASK);
+	/* Reset the IRQ of the FM chip */
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_IRQ_RESET);
+	signature = stat1 = inb(opl3->l_port);	/* Status register */
+	if ((stat1 & 0xe0) != 0x00) {	/* Should be 0x00 */
+		snd_printd("OPL3: stat1 = 0x%x\n", stat1);
+		return -ENODEV;
+	}
+	/* Set timer1 to 0xff */
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER1, 0xff);
+	/* Unmask and start timer 1 */
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_TIMER2_MASK | OPL3_TIMER1_START);
+	/* Now we have to delay at least 80us */
+	udelay(200);
+	/* Read status after timers have expired */
+	stat2 = inb(opl3->l_port);
+	/* Stop the timers */
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_TIMER1_MASK | OPL3_TIMER2_MASK);
+	/* Reset the IRQ of the FM chip */
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, OPL3_IRQ_RESET);
+	if ((stat2 & 0xe0) != 0xc0) {	/* There is no YM3812 */
+		snd_printd("OPL3: stat2 = 0x%x\n", stat2);
+		return -ENODEV;
+	}
+
+	/* If the toplevel code knows exactly the type of chip, don't try
+	   to detect it. */
+	if (opl3->hardware != OPL3_HW_AUTO)
+		return 0;
+
+	/* There is a FM chip on this address. Detect the type (OPL2 to OPL4) */
+	if (signature == 0x06) {	/* OPL2 */
+		opl3->hardware = OPL3_HW_OPL2;
+	} else {
+		/*
+		 * If we had an OPL4 chip, opl3->hardware would have been set
+		 * by the OPL4 driver; so we can assume OPL3 here.
+		 */
+		snd_assert(opl3->r_port != 0, return -ENODEV);
+		opl3->hardware = OPL3_HW_OPL3;
+	}
+	return 0;
+}
+
+/*
+ *  AdLib timers
+ */
+
+/*
+ *  Timer 1 - 80us
+ */
+
+static int snd_opl3_timer1_start(snd_timer_t * timer)
+{
+	unsigned long flags;
+	unsigned char tmp;
+	unsigned int ticks;
+	opl3_t *opl3;
+
+	opl3 = snd_timer_chip(timer);
+	spin_lock_irqsave(&opl3->timer_lock, flags);
+	ticks = timer->sticks;
+	tmp = (opl3->timer_enable | OPL3_TIMER1_START) & ~OPL3_TIMER1_MASK;
+	opl3->timer_enable = tmp;
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER1, 256 - ticks);	/* timer 1 count */
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, tmp);	/* enable timer 1 IRQ */
+	spin_unlock_irqrestore(&opl3->timer_lock, flags);
+	return 0;
+}
+
+static int snd_opl3_timer1_stop(snd_timer_t * timer)
+{
+	unsigned long flags;
+	unsigned char tmp;
+	opl3_t *opl3;
+
+	opl3 = snd_timer_chip(timer);
+	spin_lock_irqsave(&opl3->timer_lock, flags);
+	tmp = (opl3->timer_enable | OPL3_TIMER1_MASK) & ~OPL3_TIMER1_START;
+	opl3->timer_enable = tmp;
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, tmp);	/* disable timer #1 */
+	spin_unlock_irqrestore(&opl3->timer_lock, flags);
+	return 0;
+}
+
+/*
+ *  Timer 2 - 320us
+ */
+
+static int snd_opl3_timer2_start(snd_timer_t * timer)
+{
+	unsigned long flags;
+	unsigned char tmp;
+	unsigned int ticks;
+	opl3_t *opl3;
+
+	opl3 = snd_timer_chip(timer);
+	spin_lock_irqsave(&opl3->timer_lock, flags);
+	ticks = timer->sticks;
+	tmp = (opl3->timer_enable | OPL3_TIMER2_START) & ~OPL3_TIMER2_MASK;
+	opl3->timer_enable = tmp;
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER2, 256 - ticks);	/* timer 1 count */
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, tmp);	/* enable timer 1 IRQ */
+	spin_unlock_irqrestore(&opl3->timer_lock, flags);
+	return 0;
+}
+
+static int snd_opl3_timer2_stop(snd_timer_t * timer)
+{
+	unsigned long flags;
+	unsigned char tmp;
+	opl3_t *opl3;
+
+	opl3 = snd_timer_chip(timer);
+	spin_lock_irqsave(&opl3->timer_lock, flags);
+	tmp = (opl3->timer_enable | OPL3_TIMER2_MASK) & ~OPL3_TIMER2_START;
+	opl3->timer_enable = tmp;
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TIMER_CONTROL, tmp);	/* disable timer #1 */
+	spin_unlock_irqrestore(&opl3->timer_lock, flags);
+	return 0;
+}
+
+/*
+
+ */
+
+static struct _snd_timer_hardware snd_opl3_timer1 =
+{
+	.flags =	SNDRV_TIMER_HW_STOP,
+	.resolution =	80000,
+	.ticks =	256,
+	.start =	snd_opl3_timer1_start,
+	.stop =		snd_opl3_timer1_stop,
+};
+
+static struct _snd_timer_hardware snd_opl3_timer2 =
+{
+	.flags =	SNDRV_TIMER_HW_STOP,
+	.resolution =	320000,
+	.ticks =	256,
+	.start =	snd_opl3_timer2_start,
+	.stop =		snd_opl3_timer2_stop,
+};
+
+static int snd_opl3_timer1_init(opl3_t * opl3, int timer_no)
+{
+	snd_timer_t *timer = NULL;
+	snd_timer_id_t tid;
+	int err;
+
+	tid.dev_class = SNDRV_TIMER_CLASS_CARD;
+	tid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;
+	tid.card = opl3->card->number;
+	tid.device = timer_no;
+	tid.subdevice = 0;
+	if ((err = snd_timer_new(opl3->card, "AdLib timer #1", &tid, &timer)) >= 0) {
+		strcpy(timer->name, "AdLib timer #1");
+		timer->private_data = opl3;
+		timer->hw = snd_opl3_timer1;
+	}
+	opl3->timer1 = timer;
+	return err;
+}
+
+static int snd_opl3_timer2_init(opl3_t * opl3, int timer_no)
+{
+	snd_timer_t *timer = NULL;
+	snd_timer_id_t tid;
+	int err;
+
+	tid.dev_class = SNDRV_TIMER_CLASS_CARD;
+	tid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;
+	tid.card = opl3->card->number;
+	tid.device = timer_no;
+	tid.subdevice = 0;
+	if ((err = snd_timer_new(opl3->card, "AdLib timer #2", &tid, &timer)) >= 0) {
+		strcpy(timer->name, "AdLib timer #2");
+		timer->private_data = opl3;
+		timer->hw = snd_opl3_timer2;
+	}
+	opl3->timer2 = timer;
+	return err;
+}
+
+/*
+
+ */
+
+void snd_opl3_interrupt(snd_hwdep_t * hw)
+{
+	unsigned char status;
+	opl3_t *opl3;
+	snd_timer_t *timer;
+
+	if (hw == NULL)
+		return;
+
+	opl3 = hw->private_data;
+	status = inb(opl3->l_port);
+#if 0
+	snd_printk("AdLib IRQ status = 0x%x\n", status);
+#endif
+	if (!(status & 0x80))
+		return;
+
+	if (status & 0x40) {
+		timer = opl3->timer1;
+		snd_timer_interrupt(timer, timer->sticks);
+	}
+	if (status & 0x20) {
+		timer = opl3->timer2;
+		snd_timer_interrupt(timer, timer->sticks);
+	}
+}
+
+/*
+
+ */
+
+static int snd_opl3_free(opl3_t *opl3)
+{
+	snd_assert(opl3 != NULL, return -ENXIO);
+	if (opl3->private_free)
+		opl3->private_free(opl3);
+	if (opl3->res_l_port) {
+		release_resource(opl3->res_l_port);
+		kfree_nocheck(opl3->res_l_port);
+	}
+	if (opl3->res_r_port) {
+		release_resource(opl3->res_r_port);
+		kfree_nocheck(opl3->res_r_port);
+	}
+	kfree(opl3);
+	return 0;
+}
+
+static int snd_opl3_dev_free(snd_device_t *device)
+{
+	opl3_t *opl3 = device->device_data;
+	return snd_opl3_free(opl3);
+}
+
+int snd_opl3_new(snd_card_t *card,
+		 unsigned short hardware,
+		 opl3_t **ropl3)
+{
+	static snd_device_ops_t ops = {
+		.dev_free = snd_opl3_dev_free,
+	};
+	opl3_t *opl3;
+	int err;
+
+	*ropl3 = NULL;
+	opl3 = kcalloc(1, sizeof(*opl3), GFP_KERNEL);
+	if (opl3 == NULL)
+		return -ENOMEM;
+
+	opl3->card = card;
+	opl3->hardware = hardware;
+	spin_lock_init(&opl3->reg_lock);
+	spin_lock_init(&opl3->timer_lock);
+	init_MUTEX(&opl3->access_mutex);
+
+	if ((err = snd_device_new(card, SNDRV_DEV_CODEC, opl3, &ops)) < 0) {
+		snd_opl3_free(opl3);
+		return err;
+	}
+
+	*ropl3 = opl3;
+	return 0;
+}
+
+int snd_opl3_init(opl3_t *opl3)
+{
+	if (! opl3->command) {
+		printk(KERN_ERR "snd_opl3_init: command not defined!\n");
+		return -EINVAL;
+	}
+
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_TEST, OPL3_ENABLE_WAVE_SELECT);
+	/* Melodic mode */
+	opl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION, 0x00);
+
+	switch (opl3->hardware & OPL3_HW_MASK) {
+	case OPL3_HW_OPL2:
+		opl3->max_voices = MAX_OPL2_VOICES;
+		break;
+	case OPL3_HW_OPL3:
+	case OPL3_HW_OPL4:
+		opl3->max_voices = MAX_OPL3_VOICES;
+		/* Enter OPL3 mode */
+		opl3->command(opl3, OPL3_RIGHT | OPL3_REG_MODE, OPL3_OPL3_ENABLE);
+	}
+	return 0;
+}
+
+int snd_opl3_create(snd_card_t * card,
+		    unsigned long l_port,
+		    unsigned long r_port,
+		    unsigned short hardware,
+		    int integrated,
+		    opl3_t ** ropl3)
+{
+	opl3_t *opl3;
+	int err;
+
+	*ropl3 = NULL;
+	if ((err = snd_opl3_new(card, hardware, &opl3)) < 0)
+		return err;
+	if (! integrated) {
+		if ((opl3->res_l_port = request_region(l_port, 2, "OPL2/3 (left)")) == NULL) {
+			snd_printk(KERN_ERR "opl3: can't grab left port 0x%lx\n", l_port);
+			snd_opl3_free(opl3);
+			return -EBUSY;
+		}
+		if (r_port != 0 &&
+		    (opl3->res_r_port = request_region(r_port, 2, "OPL2/3 (right)")) == NULL) {
+			snd_printk(KERN_ERR "opl3: can't grab right port 0x%lx\n", r_port);
+			snd_opl3_free(opl3);
+			return -EBUSY;
+		}
+	}
+	opl3->l_port = l_port;
+	opl3->r_port = r_port;
+
+	switch (opl3->hardware) {
+	/* some hardware doesn't support timers */
+	case OPL3_HW_OPL3_SV:
+	case OPL3_HW_OPL3_CS:
+	case OPL3_HW_OPL3_FM801:
+		opl3->command = &snd_opl3_command;
+		break;
+	default:
+		opl3->command = &snd_opl2_command;
+		if ((err = snd_opl3_detect(opl3)) < 0) {
+			snd_printd("OPL2/3 chip not detected at 0x%lx/0x%lx\n",
+				   opl3->l_port, opl3->r_port);
+			snd_opl3_free(opl3);
+			return err;
+		}
+		/* detect routine returns correct hardware type */
+		switch (opl3->hardware & OPL3_HW_MASK) {
+		case OPL3_HW_OPL3:
+		case OPL3_HW_OPL4:
+			opl3->command = &snd_opl3_command;
+		}
+	}
+
+	snd_opl3_init(opl3);
+
+	*ropl3 = opl3;
+	return 0;
+}
+
+int snd_opl3_timer_new(opl3_t * opl3, int timer1_dev, int timer2_dev)
+{
+	int err;
+
+	if (timer1_dev >= 0)
+		if ((err = snd_opl3_timer1_init(opl3, timer1_dev)) < 0)
+			return err;
+	if (timer2_dev >= 0) {
+		if ((err = snd_opl3_timer2_init(opl3, timer2_dev)) < 0) {
+			snd_device_free(opl3->card, opl3->timer1);
+			opl3->timer1 = NULL;
+			return err;
+		}
+	}
+	return 0;
+}
+
+int snd_opl3_hwdep_new(opl3_t * opl3,
+		       int device, int seq_device,
+		       snd_hwdep_t ** rhwdep)
+{
+	snd_hwdep_t *hw;
+	snd_card_t *card = opl3->card;
+	int err;
+
+	if (rhwdep)
+		*rhwdep = NULL;
+
+	/* create hardware dependent device (direct FM) */
+
+	if ((err = snd_hwdep_new(card, "OPL2/OPL3", device, &hw)) < 0) {
+		snd_device_free(card, opl3);
+		return err;
+	}
+	hw->private_data = opl3;
+#ifdef CONFIG_SND_OSSEMUL
+	if (device == 0) {
+		hw->oss_type = SNDRV_OSS_DEVICE_TYPE_DMFM;
+		sprintf(hw->oss_dev, "dmfm%i", card->number);
+	}
+#endif
+	strcpy(hw->name, hw->id);
+	switch (opl3->hardware & OPL3_HW_MASK) {
+	case OPL3_HW_OPL2:
+		strcpy(hw->name, "OPL2 FM");
+		hw->iface = SNDRV_HWDEP_IFACE_OPL2;
+		break;
+	case OPL3_HW_OPL3:
+		strcpy(hw->name, "OPL3 FM");
+		hw->iface = SNDRV_HWDEP_IFACE_OPL3;
+		break;
+	case OPL3_HW_OPL4:
+		strcpy(hw->name, "OPL4 FM");
+		hw->iface = SNDRV_HWDEP_IFACE_OPL4;
+		break;
+	}
+
+	/* operators - only ioctl */
+	hw->ops.open = snd_opl3_open;
+	hw->ops.ioctl = snd_opl3_ioctl;
+	hw->ops.release = snd_opl3_release;
+
+	opl3->seq_dev_num = seq_device;
+#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
+	if (snd_seq_device_new(card, seq_device, SNDRV_SEQ_DEV_ID_OPL3,
+			       sizeof(opl3_t*), &opl3->seq_dev) >= 0) {
+		strcpy(opl3->seq_dev->name, hw->name);
+		*(opl3_t**)SNDRV_SEQ_DEVICE_ARGPTR(opl3->seq_dev) = opl3;
+	}
+#endif
+	if (rhwdep)
+		*rhwdep = hw;
+	return 0;
+}
+
+EXPORT_SYMBOL(snd_opl3_interrupt);
+EXPORT_SYMBOL(snd_opl3_new);
+EXPORT_SYMBOL(snd_opl3_init);
+EXPORT_SYMBOL(snd_opl3_create);
+EXPORT_SYMBOL(snd_opl3_timer_new);
+EXPORT_SYMBOL(snd_opl3_hwdep_new);
+
+/* opl3_synth.c */
+EXPORT_SYMBOL(snd_opl3_regmap);
+EXPORT_SYMBOL(snd_opl3_reset);
+
+/*
+ *  INIT part
+ */
+
+static int __init alsa_opl3_init(void)
+{
+	return 0;
+}
+
+static void __exit alsa_opl3_exit(void)
+{
+}
+
+module_init(alsa_opl3_init)
+module_exit(alsa_opl3_exit)
