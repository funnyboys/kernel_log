commit e3de2a406ef525302e8a0805a753af13db26c844
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:57 2020 +0100

    ALSA: opl3: More constifications
    
    Apply const prefix to the static tables for drum, volume and notes.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-43-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 280cc79870cf..2f6e8023e05c 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -23,7 +23,7 @@ static void snd_opl3_note_off_unsafe(void *p, int note, int vel,
  * it saves a lot of log() calculations. (Rob Hooft <hooft@chem.ruu.nl>)
  */
 
-static char opl3_volume_table[128] =
+static const char opl3_volume_table[128] =
 {
 	-63, -48, -40, -35, -32, -29, -27, -26,
 	-24, -23, -21, -20, -19, -18, -18, -17,
@@ -69,7 +69,7 @@ void snd_opl3_calc_volume(unsigned char *volbyte, int vel,
 /*
  * Converts the note frequency to block and fnum values for the FM chip
  */
-static short opl3_note_table[16] =
+static const short opl3_note_table[16] =
 {
 	305, 323,	/* for pitch bending, -2 semitones */
 	343, 363, 385, 408, 432, 458, 485, 514, 544, 577, 611, 647,
@@ -266,7 +266,7 @@ static void snd_opl3_start_timer(struct snd_opl3 *opl3)
 /* ------------------------------ */
 
 
-static int snd_opl3_oss_map[MAX_OPL3_VOICES] = {
+static const int snd_opl3_oss_map[MAX_OPL3_VOICES] = {
 	0, 1, 2, 9, 10, 11, 6, 7, 8, 15, 16, 17, 3, 4 ,5, 12, 13, 14
 };
 

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index a33cb744e96c..280cc79870cf 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -1,22 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Copyright (c) by Uros Bizjak <uros@kss-loka.si>
  *
  *  Midi synth routines for OPL2/OPL3/OPL4 FM
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #undef DEBUG_ALLOC

commit 0c93c5ce107659069d16fa34ddce465acdf9d996
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Wed Aug 8 14:25:16 2018 -0500

    ALSA: opl3: Mark expected switch fall-through
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Addresses-Coverity-ID: 114878 ("Missing break in switch")
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 471916ca0b6b..a33cb744e96c 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -368,6 +368,7 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 			instr_4op = 1;
 			break;
 		}
+		/* fall through */
 	default:
 		spin_unlock_irqrestore(&opl3->voice_lock, flags);
 		return;

commit 7e9c20f40304a16d5f69dbdc44a551cc48252266
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 23:00:52 2018 +0200

    ALSA: opl3: Declare common variables properly
    
    Move the declarations of common variables into opl3_voice.h instead of
    declaring at each file multiple times, which was error-prone.
    
    This fixes sparse warnings like:
      sound/drivers/opl3/opl3_synth.c:51:6: warning: symbol 'snd_opl3_regmap' was not declared. Should it be static?
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 71cd5a2fbe82..471916ca0b6b 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -25,10 +25,6 @@
 #include "opl3_voice.h"
 #include <sound/asoundef.h>
 
-extern char snd_opl3_regmap[MAX_OPL2_VOICES][4];
-
-extern bool use_internal_drums;
-
 static void snd_opl3_note_off_unsafe(void *p, int note, int vel,
 				     struct snd_midi_channel *chan);
 /*

commit eeef847de593e2de4ddbf7ae3439c9fc9ebc8e84
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Jul 16 09:34:51 2018 +0100

    ALSA: opl3: remove redundant pointer opl3
    
    Variable opl3 is being assigned but is never used hence it is
    redundant and can be removed.
    
    Cleans up several clang warnings:
    warning: variable 'opl3' set but not used [-Wunused-but-set-variable]
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index bb3f3a5a6951..71cd5a2fbe82 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -721,9 +721,6 @@ void snd_opl3_note_off(void *p, int note, int vel,
  */
 void snd_opl3_key_press(void *p, int note, int vel, struct snd_midi_channel *chan)
 {
-  	struct snd_opl3 *opl3;
-
-	opl3 = p;
 #ifdef DEBUG_MIDI
 	snd_printk(KERN_DEBUG "Key pressure, ch#: %i, inst#: %i\n",
 		   chan->number, chan->midi_program);
@@ -735,9 +732,6 @@ void snd_opl3_key_press(void *p, int note, int vel, struct snd_midi_channel *cha
  */
 void snd_opl3_terminate_note(void *p, int note, struct snd_midi_channel *chan)
 {
-  	struct snd_opl3 *opl3;
-
-	opl3 = p;
 #ifdef DEBUG_MIDI
 	snd_printk(KERN_DEBUG "Terminate note, ch#: %i, inst#: %i\n",
 		   chan->number, chan->midi_program);
@@ -861,9 +855,6 @@ void snd_opl3_control(void *p, int type, struct snd_midi_channel *chan)
 void snd_opl3_nrpn(void *p, struct snd_midi_channel *chan,
 		   struct snd_midi_channel_set *chset)
 {
-  	struct snd_opl3 *opl3;
-
-	opl3 = p;
 #ifdef DEBUG_MIDI
 	snd_printk(KERN_DEBUG "NRPN, ch#: %i, inst#: %i\n",
 		   chan->number, chan->midi_program);
@@ -876,9 +867,6 @@ void snd_opl3_nrpn(void *p, struct snd_midi_channel *chan,
 void snd_opl3_sysex(void *p, unsigned char *buf, int len,
 		    int parsed, struct snd_midi_channel_set *chset)
 {
-  	struct snd_opl3 *opl3;
-
-	opl3 = p;
 #ifdef DEBUG_MIDI
 	snd_printk(KERN_DEBUG "SYSEX\n");
 #endif

commit bc47ba90b01afe468cdd586b0dbe59b64862e2b7
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 24 08:34:29 2017 -0700

    ALSA: drivers: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 13c0a7e1bc2b..bb3f3a5a6951 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -238,10 +238,10 @@ static int opl3_get_voice(struct snd_opl3 *opl3, int instr_4op,
 /*
  * System timer interrupt function
  */
-void snd_opl3_timer_func(unsigned long data)
+void snd_opl3_timer_func(struct timer_list *t)
 {
 
-	struct snd_opl3 *opl3 = (struct snd_opl3 *)data;
+	struct snd_opl3 *opl3 = from_timer(opl3, t, tlist);
 	unsigned long flags;
 	int again = 0;
 	int i;

commit 53cfa99e37010c9d270dc9f16054928d4e0716e6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 31 10:53:35 2017 +0200

    ALSA: opl3: Put missing KERN_CONT prefix
    
    The opl3 driver has a debug printk code without proper KERN_ prefix.
    On recent kernels, KERN_CONT prefix is mandatory for continued output
    lines.  Put it properly.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 7821b07415a7..13c0a7e1bc2b 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -131,8 +131,8 @@ static void debug_alloc(struct snd_opl3 *opl3, char *s, int voice) {
 
 	printk(KERN_DEBUG "time %.5i: %s [%.2i]: ", opl3->use_time, s, voice);
 	for (i = 0; i < opl3->max_voices; i++)
-		printk("%c", *(str + opl3->voices[i].state + 1));
-	printk("\n");
+		printk(KERN_CONT "%c", *(str + opl3->voices[i].state + 1));
+	printk(KERN_CONT "\n");
 }
 #endif
 

commit d124380674b58f62d0ef974630d74d67bb8afeb0
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Mar 5 20:49:06 2015 +0300

    ALSA: opl3: small array underflow
    
    There is a missing lower bound check on "pitchbend" so it means we can
    read up to 6 elements before the start of the opl3_note_table[] array.
    
    Thanks to Clemens Ladisch for his help with this patch.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index f62780ed64ad..7821b07415a7 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -105,6 +105,8 @@ static void snd_opl3_calc_pitch(unsigned char *fnum, unsigned char *blocknum,
 		int pitchbend = chan->midi_pitchbend;
 		int segment;
 
+		if (pitchbend < -0x2000)
+			pitchbend = -0x2000;
 		if (pitchbend > 0x1FFF)
 			pitchbend = 0x1FFF;
 

commit f5d5f75fe167c8b80747290968aeaa91457cb10a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 11:28:54 2015 +0100

    ALSA: opl3: Use setup_timer() and mod_timer()
    
    No functional change, refactoring with the standard helpers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 6c6d09a51f42..f62780ed64ad 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -258,12 +258,10 @@ void snd_opl3_timer_func(unsigned long data)
 	spin_unlock_irqrestore(&opl3->voice_lock, flags);
 
 	spin_lock_irqsave(&opl3->sys_timer_lock, flags);
-	if (again) {
-		opl3->tlist.expires = jiffies + 1;	/* invoke again */
-		add_timer(&opl3->tlist);
-	} else {
+	if (again)
+		mod_timer(&opl3->tlist, jiffies + 1);	/* invoke again */
+	else
 		opl3->sys_timer_status = 0;
-	}
 	spin_unlock_irqrestore(&opl3->sys_timer_lock, flags);
 }
 
@@ -275,8 +273,7 @@ static void snd_opl3_start_timer(struct snd_opl3 *opl3)
 	unsigned long flags;
 	spin_lock_irqsave(&opl3->sys_timer_lock, flags);
 	if (! opl3->sys_timer_status) {
-		opl3->tlist.expires = jiffies + 1;
-		add_timer(&opl3->tlist);
+		mod_timer(&opl3->tlist, jiffies + 1);
 		opl3->sys_timer_status = 1;
 	}
 	spin_unlock_irqrestore(&opl3->sys_timer_lock, flags);

commit a8d09e3a6dfc44fd2246f3c57d2cd00e1a56e2bd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 29 15:07:19 2013 +0100

    ALSA: opl3: Fix possible negative array index access
    
    Spotted by coverity CID 115196.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 0c796bcbc0a3..6c6d09a51f42 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -390,6 +390,11 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 		voice = snd_opl3_oss_map[chan->number];		
 	}
 
+	if (voice < 0) {
+		spin_unlock_irqrestore(&opl3->voice_lock, flags);
+		return;
+	}
+
 	if (voice < MAX_OPL2_VOICES) {
 		/* Left register block for voices 0 .. 8 */
 		reg_side = OPL3_LEFT;

commit 395d9dd5dd13c6aa3c8c61a31126af98cd1e747d
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Fri Sep 28 11:24:57 2012 +0200

    sound: Remove unnecessary semicolon
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r1@
    statement S;
    position p,p1;
    @@
    S@p1;@p
    
    @script:python r2@
    p << r1.p;
    p1 << r1.p1;
    @@
    if p[0].line != p1[0].line_end:
            cocci.include_match(False)
    @@
    position r1.p;
    @@
    -;@p
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 2bfe4bcb7a7d..0c796bcbc0a3 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -163,7 +163,7 @@ static int opl3_get_voice(struct snd_opl3 *opl3, int instr_4op,
 	struct best *bp;
 
 	for (i = 0; i < END; i++) {
-		best[i].time = (unsigned int)(-1); /* XXX MAX_?INT really */;
+		best[i].time = (unsigned int)(-1); /* XXX MAX_?INT really */
 		best[i].voice = -1;
 	}
 

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 7d722a025d0d..2bfe4bcb7a7d 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -27,7 +27,7 @@
 
 extern char snd_opl3_regmap[MAX_OPL2_VOICES][4];
 
-extern int use_internal_drums;
+extern bool use_internal_drums;
 
 static void snd_opl3_note_off_unsafe(void *p, int note, int vel,
 				     struct snd_midi_channel *chan);

commit 8dce39b8955be6164172cb6204ef8fc21de27431
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Wed Oct 7 22:51:34 2009 +0200

    ALSA: opl3: circular locking in the snd_opl3_note_on() and snd_opl3_note_off()
    
    Fix following circular locking in the opl3 driver.
    
    =======================================================
    [ INFO: possible circular locking dependency detected ]
    2.6.32-rc3 #87
    -------------------------------------------------------
    swapper/0 is trying to acquire lock:
     (&opl3->voice_lock){..-...}, at: [<cca748fe>] snd_opl3_note_off+0x1e/0xe0 [snd_opl3_synth]
    
    but task is already holding lock:
     (&opl3->sys_timer_lock){..-...}, at: [<cca75169>] snd_opl3_timer_func+0x19/0xc0 [snd_opl3_synth]
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #1 (&opl3->sys_timer_lock){..-...}:
           [<c02461d5>] validate_chain+0xa25/0x1040
           [<c0246aca>] __lock_acquire+0x2da/0xab0
           [<c024731a>] lock_acquire+0x7a/0xa0
           [<c044c300>] _spin_lock_irqsave+0x40/0x60
           [<cca75046>] snd_opl3_note_on+0x686/0x790 [snd_opl3_synth]
           [<cca68912>] snd_midi_process_event+0x322/0x590 [snd_seq_midi_emul]
           [<cca74245>] snd_opl3_synth_event_input+0x15/0x20 [snd_opl3_synth]
           [<cca4dcc0>] snd_seq_deliver_single_event+0x100/0x200 [snd_seq]
           [<cca4de07>] snd_seq_deliver_event+0x47/0x1f0 [snd_seq]
           [<cca4e50b>] snd_seq_dispatch_event+0x3b/0x140 [snd_seq]
           [<cca5008c>] snd_seq_check_queue+0x10c/0x120 [snd_seq]
           [<cca5037b>] snd_seq_enqueue_event+0x6b/0xe0 [snd_seq]
           [<cca4e0fd>] snd_seq_client_enqueue_event+0xdd/0x100 [snd_seq]
           [<cca4eb7a>] snd_seq_write+0xea/0x190 [snd_seq]
           [<c02827b6>] vfs_write+0x96/0x160
           [<c0282c9d>] sys_write+0x3d/0x70
           [<c0202c45>] syscall_call+0x7/0xb
    
    -> #0 (&opl3->voice_lock){..-...}:
           [<c02467e6>] validate_chain+0x1036/0x1040
           [<c0246aca>] __lock_acquire+0x2da/0xab0
           [<c024731a>] lock_acquire+0x7a/0xa0
           [<c044c300>] _spin_lock_irqsave+0x40/0x60
           [<cca748fe>] snd_opl3_note_off+0x1e/0xe0 [snd_opl3_synth]
           [<cca751f0>] snd_opl3_timer_func+0xa0/0xc0 [snd_opl3_synth]
           [<c022ac46>] run_timer_softirq+0x166/0x1e0
           [<c02269e8>] __do_softirq+0x78/0x110
           [<c0226ac6>] do_softirq+0x46/0x50
           [<c0226e26>] irq_exit+0x36/0x40
           [<c0204bd2>] do_IRQ+0x42/0xb0
           [<c020328e>] common_interrupt+0x2e/0x40
           [<c021092f>] apm_cpu_idle+0x10f/0x290
           [<c0201b11>] cpu_idle+0x21/0x40
           [<c04443cd>] rest_init+0x4d/0x60
           [<c055c835>] start_kernel+0x235/0x280
           [<c055c066>] i386_start_kernel+0x66/0x70
    
    other info that might help us debug this:
    
    2 locks held by swapper/0:
     #0:  (&opl3->tlist){+.-...}, at: [<c022abd0>] run_timer_softirq+0xf0/0x1e0
     #1:  (&opl3->sys_timer_lock){..-...}, at: [<cca75169>] snd_opl3_timer_func+0x19/0xc0 [snd_opl3_synth]
    
    stack backtrace:
    Pid: 0, comm: swapper Not tainted 2.6.32-rc3 #87
    Call Trace:
     [<c0245188>] print_circular_bug+0xc8/0xd0
     [<c02467e6>] validate_chain+0x1036/0x1040
     [<c0247f14>] ? check_usage_forwards+0x54/0xd0
     [<c0246aca>] __lock_acquire+0x2da/0xab0
     [<c024731a>] lock_acquire+0x7a/0xa0
     [<cca748fe>] ? snd_opl3_note_off+0x1e/0xe0 [snd_opl3_synth]
     [<c044c300>] _spin_lock_irqsave+0x40/0x60
     [<cca748fe>] ? snd_opl3_note_off+0x1e/0xe0 [snd_opl3_synth]
     [<cca748fe>] snd_opl3_note_off+0x1e/0xe0 [snd_opl3_synth]
     [<c044c307>] ? _spin_lock_irqsave+0x47/0x60
     [<cca751f0>] snd_opl3_timer_func+0xa0/0xc0 [snd_opl3_synth]
     [<c022ac46>] run_timer_softirq+0x166/0x1e0
     [<c022abd0>] ? run_timer_softirq+0xf0/0x1e0
     [<cca75150>] ? snd_opl3_timer_func+0x0/0xc0 [snd_opl3_synth]
     [<c02269e8>] __do_softirq+0x78/0x110
     [<c044c0fd>] ? _spin_unlock+0x1d/0x20
     [<c025915f>] ? handle_level_irq+0xaf/0xe0
     [<c0226ac6>] do_softirq+0x46/0x50
     [<c0226e26>] irq_exit+0x36/0x40
     [<c0204bd2>] do_IRQ+0x42/0xb0
     [<c024463c>] ? trace_hardirqs_on_caller+0x12c/0x180
     [<c020328e>] common_interrupt+0x2e/0x40
     [<c0208d88>] ? default_idle+0x38/0x50
     [<c021092f>] apm_cpu_idle+0x10f/0x290
     [<c0201b11>] cpu_idle+0x21/0x40
     [<c04443cd>] rest_init+0x4d/0x60
     [<c055c835>] start_kernel+0x235/0x280
     [<c055c210>] ? unknown_bootoption+0x0/0x210
     [<c055c066>] i386_start_kernel+0x66/0x70
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 6e7d09ae0e82..7d722a025d0d 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -29,6 +29,8 @@ extern char snd_opl3_regmap[MAX_OPL2_VOICES][4];
 
 extern int use_internal_drums;
 
+static void snd_opl3_note_off_unsafe(void *p, int note, int vel,
+				     struct snd_midi_channel *chan);
 /*
  * The next table looks magical, but it certainly is not. Its values have
  * been calculated as table[i]=8*log(i/64)/log(2) with an obvious exception
@@ -242,16 +244,20 @@ void snd_opl3_timer_func(unsigned long data)
 	int again = 0;
 	int i;
 
-	spin_lock_irqsave(&opl3->sys_timer_lock, flags);
+	spin_lock_irqsave(&opl3->voice_lock, flags);
 	for (i = 0; i < opl3->max_voices; i++) {
 		struct snd_opl3_voice *vp = &opl3->voices[i];
 		if (vp->state > 0 && vp->note_off_check) {
 			if (vp->note_off == jiffies)
-				snd_opl3_note_off(opl3, vp->note, 0, vp->chan);
+				snd_opl3_note_off_unsafe(opl3, vp->note, 0,
+							 vp->chan);
 			else
 				again++;
 		}
 	}
+	spin_unlock_irqrestore(&opl3->voice_lock, flags);
+
+	spin_lock_irqsave(&opl3->sys_timer_lock, flags);
 	if (again) {
 		opl3->tlist.expires = jiffies + 1;	/* invoke again */
 		add_timer(&opl3->tlist);
@@ -658,15 +664,14 @@ static void snd_opl3_kill_voice(struct snd_opl3 *opl3, int voice)
 /*
  * Release a note in response to a midi note off.
  */
-void snd_opl3_note_off(void *p, int note, int vel, struct snd_midi_channel *chan)
+static void snd_opl3_note_off_unsafe(void *p, int note, int vel,
+				     struct snd_midi_channel *chan)
 {
   	struct snd_opl3 *opl3;
 
 	int voice;
 	struct snd_opl3_voice *vp;
 
-	unsigned long flags;
-
 	opl3 = p;
 
 #ifdef DEBUG_MIDI
@@ -674,12 +679,9 @@ void snd_opl3_note_off(void *p, int note, int vel, struct snd_midi_channel *chan
 		   chan->number, chan->midi_program, note);
 #endif
 
-	spin_lock_irqsave(&opl3->voice_lock, flags);
-
 	if (opl3->synth_mode == SNDRV_OPL3_MODE_SEQ) {
 		if (chan->drum_channel && use_internal_drums) {
 			snd_opl3_drum_switch(opl3, note, vel, 0, chan);
-			spin_unlock_irqrestore(&opl3->voice_lock, flags);
 			return;
 		}
 		/* this loop will hopefully kill all extra voices, because
@@ -697,6 +699,16 @@ void snd_opl3_note_off(void *p, int note, int vel, struct snd_midi_channel *chan
 			snd_opl3_kill_voice(opl3, voice);
 		}
 	}
+}
+
+void snd_opl3_note_off(void *p, int note, int vel,
+		       struct snd_midi_channel *chan)
+{
+	struct snd_opl3 *opl3 = p;
+	unsigned long flags;
+
+	spin_lock_irqsave(&opl3->voice_lock, flags);
+	snd_opl3_note_off_unsafe(p, note, vel, chan);
 	spin_unlock_irqrestore(&opl3->voice_lock, flags);
 }
 

commit 45203832df2fa9e94ca0a249ddb20d2b077e58cc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 15:51:50 2009 +0100

    ALSA: Add missing KERN_* prefix to printk in sound/drivers
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 16feafa2c51e..6e7d09ae0e82 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -125,7 +125,7 @@ static void debug_alloc(struct snd_opl3 *opl3, char *s, int voice) {
 	int i;
 	char *str = "x.24";
 
-	printk("time %.5i: %s [%.2i]: ", opl3->use_time, s, voice);
+	printk(KERN_DEBUG "time %.5i: %s [%.2i]: ", opl3->use_time, s, voice);
 	for (i = 0; i < opl3->max_voices; i++)
 		printk("%c", *(str + opl3->voices[i].state + 1));
 	printk("\n");
@@ -218,7 +218,7 @@ static int opl3_get_voice(struct snd_opl3 *opl3, int instr_4op,
 	for (i = 0; i < END; i++) {
 		if (best[i].voice >= 0) {
 #ifdef DEBUG_ALLOC
-			printk("%s %iop allocation on voice %i\n",
+			printk(KERN_DEBUG "%s %iop allocation on voice %i\n",
 			       alloc_type[i], instr_4op ? 4 : 2,
 			       best[i].voice);
 #endif
@@ -317,7 +317,7 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 	opl3 = p;
 
 #ifdef DEBUG_MIDI
-	snd_printk("Note on, ch %i, inst %i, note %i, vel %i\n",
+	snd_printk(KERN_DEBUG "Note on, ch %i, inst %i, note %i, vel %i\n",
 		   chan->number, chan->midi_program, note, vel);
 #endif
 
@@ -372,7 +372,7 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 		return;
 	}
 #ifdef DEBUG_MIDI
-	snd_printk("  --> OPL%i instrument: %s\n",
+	snd_printk(KERN_DEBUG "  --> OPL%i instrument: %s\n",
 		   instr_4op ? 3 : 2, patch->name);
 #endif
 	/* in SYNTH mode, application takes care of voices */
@@ -431,7 +431,7 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 	}
 
 #ifdef DEBUG_MIDI
-	snd_printk("  --> setting OPL3 connection: 0x%x\n",
+	snd_printk(KERN_DEBUG "  --> setting OPL3 connection: 0x%x\n",
 		   opl3->connection_reg);
 #endif
 	/*
@@ -466,7 +466,7 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 	/* Program the FM voice characteristics */
 	for (i = 0; i < (instr_4op ? 4 : 2); i++) {
 #ifdef DEBUG_MIDI
-		snd_printk("  --> programming operator %i\n", i);
+		snd_printk(KERN_DEBUG "  --> programming operator %i\n", i);
 #endif
 		op_offset = snd_opl3_regmap[voice_offset][i];
 
@@ -546,7 +546,7 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 	blocknum |= OPL3_KEYON_BIT;
 
 #ifdef DEBUG_MIDI
-	snd_printk("  --> trigger voice %i\n", voice);
+	snd_printk(KERN_DEBUG "  --> trigger voice %i\n", voice);
 #endif
 	/* Set OPL3 KEYON_BLOCK register of requested voice */ 
 	opl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);
@@ -602,7 +602,7 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 			prg = extra_prg - 1;
 		}
 #ifdef DEBUG_MIDI
-		snd_printk(" *** allocating extra program\n");
+		snd_printk(KERN_DEBUG " *** allocating extra program\n");
 #endif
 		goto __extra_prg;
 	}
@@ -633,7 +633,7 @@ static void snd_opl3_kill_voice(struct snd_opl3 *opl3, int voice)
 
 	/* kill voice */
 #ifdef DEBUG_MIDI
-	snd_printk("  --> kill voice %i\n", voice);
+	snd_printk(KERN_DEBUG "  --> kill voice %i\n", voice);
 #endif
 	opl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);
 	/* clear Key ON bit */
@@ -670,7 +670,7 @@ void snd_opl3_note_off(void *p, int note, int vel, struct snd_midi_channel *chan
 	opl3 = p;
 
 #ifdef DEBUG_MIDI
-	snd_printk("Note off, ch %i, inst %i, note %i\n",
+	snd_printk(KERN_DEBUG "Note off, ch %i, inst %i, note %i\n",
 		   chan->number, chan->midi_program, note);
 #endif
 
@@ -709,7 +709,7 @@ void snd_opl3_key_press(void *p, int note, int vel, struct snd_midi_channel *cha
 
 	opl3 = p;
 #ifdef DEBUG_MIDI
-	snd_printk("Key pressure, ch#: %i, inst#: %i\n",
+	snd_printk(KERN_DEBUG "Key pressure, ch#: %i, inst#: %i\n",
 		   chan->number, chan->midi_program);
 #endif
 }
@@ -723,7 +723,7 @@ void snd_opl3_terminate_note(void *p, int note, struct snd_midi_channel *chan)
 
 	opl3 = p;
 #ifdef DEBUG_MIDI
-	snd_printk("Terminate note, ch#: %i, inst#: %i\n",
+	snd_printk(KERN_DEBUG "Terminate note, ch#: %i, inst#: %i\n",
 		   chan->number, chan->midi_program);
 #endif
 }
@@ -812,7 +812,7 @@ void snd_opl3_control(void *p, int type, struct snd_midi_channel *chan)
 
 	opl3 = p;
 #ifdef DEBUG_MIDI
-	snd_printk("Controller, TYPE = %i, ch#: %i, inst#: %i\n",
+	snd_printk(KERN_DEBUG "Controller, TYPE = %i, ch#: %i, inst#: %i\n",
 		   type, chan->number, chan->midi_program);
 #endif
 
@@ -849,7 +849,7 @@ void snd_opl3_nrpn(void *p, struct snd_midi_channel *chan,
 
 	opl3 = p;
 #ifdef DEBUG_MIDI
-	snd_printk("NRPN, ch#: %i, inst#: %i\n",
+	snd_printk(KERN_DEBUG "NRPN, ch#: %i, inst#: %i\n",
 		   chan->number, chan->midi_program);
 #endif
 }
@@ -864,6 +864,6 @@ void snd_opl3_sysex(void *p, unsigned char *buf, int len,
 
 	opl3 = p;
 #ifdef DEBUG_MIDI
-	snd_printk("SYSEX\n");
+	snd_printk(KERN_DEBUG "SYSEX\n");
 #endif
 }

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index cebcb8b78acb..16feafa2c51e 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -617,7 +617,8 @@ static void snd_opl3_kill_voice(struct snd_opl3 *opl3, int voice)
 
 	struct snd_opl3_voice *vp, *vp2;
 
-	snd_assert(voice < MAX_OPL3_VOICES, return);
+	if (snd_BUG_ON(voice >= MAX_OPL3_VOICES))
+		return;
 
 	vp = &opl3->voices[voice];
 	if (voice < MAX_OPL2_VOICES) {
@@ -737,7 +738,8 @@ static void snd_opl3_update_pitch(struct snd_opl3 *opl3, int voice)
 
 	struct snd_opl3_voice *vp;
 
-	snd_assert(voice < MAX_OPL3_VOICES, return);
+	if (snd_BUG_ON(voice >= MAX_OPL3_VOICES))
+		return;
 
 	vp = &opl3->voices[voice];
 	if (vp->chan == NULL)

commit 224a033252bba46c5c8b5df625f5e781ca138f48
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 30 11:49:22 2007 +0100

    [ALSA] opl3 - Use hwdep for patch loading
    
    Use the hwdep device for loading OPL2/3 patch data instead of the
    messy sequencer instrument layer.
    Due to this change, the sbiload program should be updated, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 3557b6e20eb5..cebcb8b78acb 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -289,8 +289,6 @@ static int snd_opl3_oss_map[MAX_OPL3_VOICES] = {
 void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 {
 	struct snd_opl3 *opl3;
-	struct snd_seq_instr wanted;
-	struct snd_seq_kinstr *kinstr;
 	int instr_4op;
 
 	int voice;
@@ -306,11 +304,13 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 	unsigned char voice_offset;
 	unsigned short opl3_reg;
 	unsigned char reg_val;
+	unsigned char prg, bank;
 
 	int key = note;
 	unsigned char fnum, blocknum;
 	int i;
 
+	struct fm_patch *patch;
 	struct fm_instrument *fm;
 	unsigned long flags;
 
@@ -320,19 +320,17 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 	snd_printk("Note on, ch %i, inst %i, note %i, vel %i\n",
 		   chan->number, chan->midi_program, note, vel);
 #endif
-	wanted.cluster = 0;
-	wanted.std = SNDRV_SEQ_INSTR_TYPE2_OPL2_3;
 
 	/* in SYNTH mode, application takes care of voices */
 	/* in SEQ mode, drum voice numbers are notes on drum channel */
 	if (opl3->synth_mode == SNDRV_OPL3_MODE_SEQ) {
 		if (chan->drum_channel) {
 			/* percussion instruments are located in bank 128 */
-			wanted.bank = 128;
-			wanted.prg = note;
+			bank = 128;
+			prg = note;
 		} else {
-			wanted.bank = chan->gm_bank_select;
-			wanted.prg = chan->midi_program;
+			bank = chan->gm_bank_select;
+			prg = chan->midi_program;
 		}
 	} else {
 		/* Prepare for OSS mode */
@@ -340,8 +338,8 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 			return;
 
 		/* OSS instruments are located in bank 127 */
-		wanted.bank = 127;
-		wanted.prg = chan->midi_program;
+		bank = 127;
+		prg = chan->midi_program;
 	}
 
 	spin_lock_irqsave(&opl3->voice_lock, flags);
@@ -353,15 +351,14 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 	}
 
  __extra_prg:
-	kinstr = snd_seq_instr_find(opl3->ilist, &wanted, 1, 0);
-	if (kinstr == NULL) {
+	patch = snd_opl3_find_patch(opl3, prg, bank, 0);
+	if (!patch) {
 		spin_unlock_irqrestore(&opl3->voice_lock, flags);
 		return;
 	}
 
-	fm = KINSTR_DATA(kinstr);
-
-	switch (fm->type) {
+	fm = &patch->inst;
+	switch (patch->type) {
 	case FM_PATCH_OPL2:
 		instr_4op = 0;
 		break;
@@ -371,14 +368,12 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 			break;
 		}
 	default:
-		snd_seq_instr_free_use(opl3->ilist, kinstr);
 		spin_unlock_irqrestore(&opl3->voice_lock, flags);
 		return;
 	}
-
 #ifdef DEBUG_MIDI
 	snd_printk("  --> OPL%i instrument: %s\n",
-		   instr_4op ? 3 : 2, kinstr->name);
+		   instr_4op ? 3 : 2, patch->name);
 #endif
 	/* in SYNTH mode, application takes care of voices */
 	/* in SEQ mode, allocate voice on free OPL3 channel */
@@ -569,8 +564,6 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 	/* get extra pgm, but avoid possible loops */
 	extra_prg = (extra_prg) ? 0 : fm->modes;
 
-	snd_seq_instr_free_use(opl3->ilist, kinstr);
-
 	/* do the bookkeeping */
 	vp->time = opl3->use_time++;
 	vp->note = key;
@@ -601,12 +594,12 @@ void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 	/* allocate extra program if specified in patch library */
 	if (extra_prg) {
 		if (extra_prg > 128) {
-			wanted.bank = 128;
+			bank = 128;
 			/* percussions start at 35 */
-			wanted.prg = extra_prg - 128 + 35 - 1;
+			prg = extra_prg - 128 + 35 - 1;
 		} else {
-			wanted.bank = 0;
-			wanted.prg = extra_prg - 1;
+			bank = 0;
+			prg = extra_prg - 1;
 		}
 #ifdef DEBUG_MIDI
 		snd_printk(" *** allocating extra program\n");

commit 3a4fa0a25da81600ea0bcd75692ae8ca6050d165
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Fri Oct 19 23:10:43 2007 +0200

    Fix misspellings of "system", "controller", "interrupt" and "necessary".
    
    Fix the various misspellings of "system", controller", "interrupt" and
    "[un]necessary".
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 1b6f227af370..3557b6e20eb5 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -808,7 +808,7 @@ static void snd_opl3_pitch_ctrl(struct snd_opl3 *opl3, struct snd_midi_channel *
 }
 
 /*
- * Deal with a controler type event.  This includes all types of
+ * Deal with a controller type event.  This includes all types of
  * control events, not just the midi controllers
  */
 void snd_opl3_control(void *p, int type, struct snd_midi_channel *chan)

commit b32425ac93370e1ba5556110e662f896b2e143b3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 18 18:52:14 2005 +0100

    [ALSA] Fix possible races in timer callbacks
    
    Fix possible races in timer callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 48c480e050ce..1b6f227af370 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -238,10 +238,11 @@ void snd_opl3_timer_func(unsigned long data)
 {
 
 	struct snd_opl3 *opl3 = (struct snd_opl3 *)data;
+	unsigned long flags;
 	int again = 0;
 	int i;
 
-	spin_lock(&opl3->sys_timer_lock);
+	spin_lock_irqsave(&opl3->sys_timer_lock, flags);
 	for (i = 0; i < opl3->max_voices; i++) {
 		struct snd_opl3_voice *vp = &opl3->voices[i];
 		if (vp->state > 0 && vp->note_off_check) {
@@ -257,7 +258,7 @@ void snd_opl3_timer_func(unsigned long data)
 	} else {
 		opl3->sys_timer_status = 0;
 	}
-	spin_unlock(&opl3->sys_timer_lock);
+	spin_unlock_irqrestore(&opl3->sys_timer_lock, flags);
 }
 
 /*

commit 5b1646a8eceff0a4ff06f309abb6e7f43f99a498
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:13:14 2005 +0100

    [ALSA] Remove xxx_t typedefs: OPL3
    
    Modules: OPL3,Raw OPL FM
    
    Remove xxx_t typedefs from the OPL3 driver
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
index 93d674070b71..48c480e050ce 100644
--- a/sound/drivers/opl3/opl3_midi.c
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -60,7 +60,7 @@ static char opl3_volume_table[128] =
 };
 
 void snd_opl3_calc_volume(unsigned char *volbyte, int vel,
-			  snd_midi_channel_t *chan)
+			  struct snd_midi_channel *chan)
 {
 	int oldvol, newvol, n;
 	int volume;
@@ -93,7 +93,7 @@ static short opl3_note_table[16] =
 };
 
 static void snd_opl3_calc_pitch(unsigned char *fnum, unsigned char *blocknum,
-				int note, snd_midi_channel_t *chan)
+				int note, struct snd_midi_channel *chan)
 {
 	int block = ((note / 12) & 0x07) - 1;
 	int idx = (note % 12) + 2;
@@ -121,7 +121,7 @@ static void snd_opl3_calc_pitch(unsigned char *fnum, unsigned char *blocknum,
 
 
 #ifdef DEBUG_ALLOC
-static void debug_alloc(opl3_t *opl3, char *s, int voice) {
+static void debug_alloc(struct snd_opl3 *opl3, char *s, int voice) {
 	int i;
 	char *str = "x.24";
 
@@ -135,12 +135,12 @@ static void debug_alloc(opl3_t *opl3, char *s, int voice) {
 /*
  * Get a FM voice (channel) to play a note on.
  */
-static int opl3_get_voice(opl3_t *opl3, int instr_4op,
-			  snd_midi_channel_t *chan) {
+static int opl3_get_voice(struct snd_opl3 *opl3, int instr_4op,
+			  struct snd_midi_channel *chan) {
 	int chan_4op_1;		/* first voice for 4op instrument */
 	int chan_4op_2;		/* second voice for 4op instrument */
 
-	snd_opl3_voice_t *vp, *vp2;
+	struct snd_opl3_voice *vp, *vp2;
 	unsigned int voice_time;
 	int i;
 
@@ -237,13 +237,13 @@ static int opl3_get_voice(opl3_t *opl3, int instr_4op,
 void snd_opl3_timer_func(unsigned long data)
 {
 
-	opl3_t *opl3 = (opl3_t *)data;
+	struct snd_opl3 *opl3 = (struct snd_opl3 *)data;
 	int again = 0;
 	int i;
 
 	spin_lock(&opl3->sys_timer_lock);
 	for (i = 0; i < opl3->max_voices; i++) {
-		snd_opl3_voice_t *vp = &opl3->voices[i];
+		struct snd_opl3_voice *vp = &opl3->voices[i];
 		if (vp->state > 0 && vp->note_off_check) {
 			if (vp->note_off == jiffies)
 				snd_opl3_note_off(opl3, vp->note, 0, vp->chan);
@@ -263,7 +263,7 @@ void snd_opl3_timer_func(unsigned long data)
 /*
  * Start system timer
  */
-static void snd_opl3_start_timer(opl3_t *opl3)
+static void snd_opl3_start_timer(struct snd_opl3 *opl3)
 {
 	unsigned long flags;
 	spin_lock_irqsave(&opl3->sys_timer_lock, flags);
@@ -285,15 +285,15 @@ static int snd_opl3_oss_map[MAX_OPL3_VOICES] = {
 /*
  * Start a note.
  */
-void snd_opl3_note_on(void *p, int note, int vel, snd_midi_channel_t *chan)
+void snd_opl3_note_on(void *p, int note, int vel, struct snd_midi_channel *chan)
 {
-	opl3_t *opl3;
-	snd_seq_instr_t wanted;
-	snd_seq_kinstr_t *kinstr;
+	struct snd_opl3 *opl3;
+	struct snd_seq_instr wanted;
+	struct snd_seq_kinstr *kinstr;
 	int instr_4op;
 
 	int voice;
-	snd_opl3_voice_t *vp, *vp2;
+	struct snd_opl3_voice *vp, *vp2;
 	unsigned short connect_mask;
 	unsigned char connection;
 	unsigned char vol_op[4];
@@ -310,7 +310,7 @@ void snd_opl3_note_on(void *p, int note, int vel, snd_midi_channel_t *chan)
 	unsigned char fnum, blocknum;
 	int i;
 
-	fm_instrument_t *fm;
+	struct fm_instrument *fm;
 	unsigned long flags;
 
 	opl3 = p;
@@ -615,13 +615,13 @@ void snd_opl3_note_on(void *p, int note, int vel, snd_midi_channel_t *chan)
 	spin_unlock_irqrestore(&opl3->voice_lock, flags);
 }
 
-static void snd_opl3_kill_voice(opl3_t *opl3, int voice)
+static void snd_opl3_kill_voice(struct snd_opl3 *opl3, int voice)
 {
 	unsigned short reg_side;
 	unsigned char voice_offset;
 	unsigned short opl3_reg;
 
-	snd_opl3_voice_t *vp, *vp2;
+	struct snd_opl3_voice *vp, *vp2;
 
 	snd_assert(voice < MAX_OPL3_VOICES, return);
 
@@ -663,12 +663,12 @@ static void snd_opl3_kill_voice(opl3_t *opl3, int voice)
 /*
  * Release a note in response to a midi note off.
  */
-void snd_opl3_note_off(void *p, int note, int vel, snd_midi_channel_t *chan)
+void snd_opl3_note_off(void *p, int note, int vel, struct snd_midi_channel *chan)
 {
-  	opl3_t *opl3;
+  	struct snd_opl3 *opl3;
 
 	int voice;
-	snd_opl3_voice_t *vp;
+	struct snd_opl3_voice *vp;
 
 	unsigned long flags;
 
@@ -708,9 +708,9 @@ void snd_opl3_note_off(void *p, int note, int vel, snd_midi_channel_t *chan)
 /*
  * key pressure change
  */
-void snd_opl3_key_press(void *p, int note, int vel, snd_midi_channel_t *chan)
+void snd_opl3_key_press(void *p, int note, int vel, struct snd_midi_channel *chan)
 {
-  	opl3_t *opl3;
+  	struct snd_opl3 *opl3;
 
 	opl3 = p;
 #ifdef DEBUG_MIDI
@@ -722,9 +722,9 @@ void snd_opl3_key_press(void *p, int note, int vel, snd_midi_channel_t *chan)
 /*
  * terminate note
  */
-void snd_opl3_terminate_note(void *p, int note, snd_midi_channel_t *chan)
+void snd_opl3_terminate_note(void *p, int note, struct snd_midi_channel *chan)
 {
-  	opl3_t *opl3;
+  	struct snd_opl3 *opl3;
 
 	opl3 = p;
 #ifdef DEBUG_MIDI
@@ -733,7 +733,7 @@ void snd_opl3_terminate_note(void *p, int note, snd_midi_channel_t *chan)
 #endif
 }
 
-static void snd_opl3_update_pitch(opl3_t *opl3, int voice)
+static void snd_opl3_update_pitch(struct snd_opl3 *opl3, int voice)
 {
 	unsigned short reg_side;
 	unsigned char voice_offset;
@@ -741,7 +741,7 @@ static void snd_opl3_update_pitch(opl3_t *opl3, int voice)
 
 	unsigned char fnum, blocknum;
 
-	snd_opl3_voice_t *vp;
+	struct snd_opl3_voice *vp;
 
 	snd_assert(voice < MAX_OPL3_VOICES, return);
 
@@ -780,10 +780,10 @@ static void snd_opl3_update_pitch(opl3_t *opl3, int voice)
 /*
  * Update voice pitch controller
  */
-static void snd_opl3_pitch_ctrl(opl3_t *opl3, snd_midi_channel_t *chan)
+static void snd_opl3_pitch_ctrl(struct snd_opl3 *opl3, struct snd_midi_channel *chan)
 {
 	int voice;
-	snd_opl3_voice_t *vp;
+	struct snd_opl3_voice *vp;
 
 	unsigned long flags;
 
@@ -810,9 +810,9 @@ static void snd_opl3_pitch_ctrl(opl3_t *opl3, snd_midi_channel_t *chan)
  * Deal with a controler type event.  This includes all types of
  * control events, not just the midi controllers
  */
-void snd_opl3_control(void *p, int type, snd_midi_channel_t *chan)
+void snd_opl3_control(void *p, int type, struct snd_midi_channel *chan)
 {
-  	opl3_t *opl3;
+  	struct snd_opl3 *opl3;
 
 	opl3 = p;
 #ifdef DEBUG_MIDI
@@ -846,10 +846,10 @@ void snd_opl3_control(void *p, int type, snd_midi_channel_t *chan)
 /*
  * NRPN events
  */
-void snd_opl3_nrpn(void *p, snd_midi_channel_t *chan,
-		   snd_midi_channel_set_t *chset)
+void snd_opl3_nrpn(void *p, struct snd_midi_channel *chan,
+		   struct snd_midi_channel_set *chset)
 {
-  	opl3_t *opl3;
+  	struct snd_opl3 *opl3;
 
 	opl3 = p;
 #ifdef DEBUG_MIDI
@@ -862,9 +862,9 @@ void snd_opl3_nrpn(void *p, snd_midi_channel_t *chan,
  * receive sysex
  */
 void snd_opl3_sysex(void *p, unsigned char *buf, int len,
-		    int parsed, snd_midi_channel_set_t *chset)
+		    int parsed, struct snd_midi_channel_set *chset)
 {
-  	opl3_t *opl3;
+  	struct snd_opl3 *opl3;
 
 	opl3 = p;
 #ifdef DEBUG_MIDI

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/drivers/opl3/opl3_midi.c b/sound/drivers/opl3/opl3_midi.c
new file mode 100644
index 000000000000..93d674070b71
--- /dev/null
+++ b/sound/drivers/opl3/opl3_midi.c
@@ -0,0 +1,873 @@
+/*
+ *  Copyright (c) by Uros Bizjak <uros@kss-loka.si>
+ *
+ *  Midi synth routines for OPL2/OPL3/OPL4 FM
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#undef DEBUG_ALLOC
+#undef DEBUG_MIDI
+
+#include "opl3_voice.h"
+#include <sound/asoundef.h>
+
+extern char snd_opl3_regmap[MAX_OPL2_VOICES][4];
+
+extern int use_internal_drums;
+
+/*
+ * The next table looks magical, but it certainly is not. Its values have
+ * been calculated as table[i]=8*log(i/64)/log(2) with an obvious exception
+ * for i=0. This log-table converts a linear volume-scaling (0..127) to a
+ * logarithmic scaling as present in the FM-synthesizer chips. so :    Volume
+ * 64 =  0 db = relative volume  0 and:    Volume 32 = -6 db = relative
+ * volume -8 it was implemented as a table because it is only 128 bytes and
+ * it saves a lot of log() calculations. (Rob Hooft <hooft@chem.ruu.nl>)
+ */
+
+static char opl3_volume_table[128] =
+{
+	-63, -48, -40, -35, -32, -29, -27, -26,
+	-24, -23, -21, -20, -19, -18, -18, -17,
+	-16, -15, -15, -14, -13, -13, -12, -12,
+	-11, -11, -10, -10, -10, -9, -9, -8,
+	-8, -8, -7, -7, -7, -6, -6, -6,
+	-5, -5, -5, -5, -4, -4, -4, -4,
+	-3, -3, -3, -3, -2, -2, -2, -2,
+	-2, -1, -1, -1, -1, 0, 0, 0,
+	0, 0, 0, 1, 1, 1, 1, 1,
+	1, 2, 2, 2, 2, 2, 2, 2,
+	3, 3, 3, 3, 3, 3, 3, 4,
+	4, 4, 4, 4, 4, 4, 4, 5,
+	5, 5, 5, 5, 5, 5, 5, 5,
+	6, 6, 6, 6, 6, 6, 6, 6,
+	6, 7, 7, 7, 7, 7, 7, 7,
+	7, 7, 7, 8, 8, 8, 8, 8
+};
+
+void snd_opl3_calc_volume(unsigned char *volbyte, int vel,
+			  snd_midi_channel_t *chan)
+{
+	int oldvol, newvol, n;
+	int volume;
+
+	volume = (vel * chan->gm_volume * chan->gm_expression) / (127*127);
+	if (volume > 127)
+		volume = 127;
+
+	oldvol = OPL3_TOTAL_LEVEL_MASK - (*volbyte & OPL3_TOTAL_LEVEL_MASK);
+
+	newvol = opl3_volume_table[volume] + oldvol;
+	if (newvol > OPL3_TOTAL_LEVEL_MASK)
+		newvol = OPL3_TOTAL_LEVEL_MASK;
+	else if (newvol < 0)
+		newvol = 0;
+
+	n = OPL3_TOTAL_LEVEL_MASK - (newvol & OPL3_TOTAL_LEVEL_MASK);
+
+	*volbyte = (*volbyte & OPL3_KSL_MASK) | (n & OPL3_TOTAL_LEVEL_MASK);
+}
+
+/*
+ * Converts the note frequency to block and fnum values for the FM chip
+ */
+static short opl3_note_table[16] =
+{
+	305, 323,	/* for pitch bending, -2 semitones */
+	343, 363, 385, 408, 432, 458, 485, 514, 544, 577, 611, 647,
+	686, 726	/* for pitch bending, +2 semitones */
+};
+
+static void snd_opl3_calc_pitch(unsigned char *fnum, unsigned char *blocknum,
+				int note, snd_midi_channel_t *chan)
+{
+	int block = ((note / 12) & 0x07) - 1;
+	int idx = (note % 12) + 2;
+	int freq;
+
+	if (chan->midi_pitchbend) {
+		int pitchbend = chan->midi_pitchbend;
+		int segment;
+
+		if (pitchbend > 0x1FFF)
+			pitchbend = 0x1FFF;
+
+		segment = pitchbend / 0x1000;
+		freq = opl3_note_table[idx+segment];
+		freq += ((opl3_note_table[idx+segment+1] - freq) *
+			 (pitchbend % 0x1000)) / 0x1000;
+	} else {
+		freq = opl3_note_table[idx];
+	}
+
+	*fnum = (unsigned char) freq;
+	*blocknum = ((freq >> 8) & OPL3_FNUM_HIGH_MASK) |
+		((block << 2) & OPL3_BLOCKNUM_MASK);
+}
+
+
+#ifdef DEBUG_ALLOC
+static void debug_alloc(opl3_t *opl3, char *s, int voice) {
+	int i;
+	char *str = "x.24";
+
+	printk("time %.5i: %s [%.2i]: ", opl3->use_time, s, voice);
+	for (i = 0; i < opl3->max_voices; i++)
+		printk("%c", *(str + opl3->voices[i].state + 1));
+	printk("\n");
+}
+#endif
+
+/*
+ * Get a FM voice (channel) to play a note on.
+ */
+static int opl3_get_voice(opl3_t *opl3, int instr_4op,
+			  snd_midi_channel_t *chan) {
+	int chan_4op_1;		/* first voice for 4op instrument */
+	int chan_4op_2;		/* second voice for 4op instrument */
+
+	snd_opl3_voice_t *vp, *vp2;
+	unsigned int voice_time;
+	int i;
+
+#ifdef DEBUG_ALLOC
+	char *alloc_type[3] = { "FREE     ", "CHEAP    ", "EXPENSIVE" };
+#endif
+
+	/* This is our "allocation cost" table */
+	enum {
+		FREE = 0, CHEAP, EXPENSIVE, END
+	};
+
+	/* Keeps track of what we are finding */
+	struct best {
+		unsigned int time;
+		int voice;
+	} best[END];
+	struct best *bp;
+
+	for (i = 0; i < END; i++) {
+		best[i].time = (unsigned int)(-1); /* XXX MAX_?INT really */;
+		best[i].voice = -1;
+	}
+
+	/* Look through all the channels for the most suitable. */
+	for (i = 0; i < opl3->max_voices; i++) {
+		vp = &opl3->voices[i];
+
+		if (vp->state == SNDRV_OPL3_ST_NOT_AVAIL)
+		  /* skip unavailable channels, allocated by
+		     drum voices or by bounded 4op voices) */
+			continue;
+
+		voice_time = vp->time;
+		bp = best;
+
+		chan_4op_1 = ((i < 3) || (i > 8 && i < 12));
+		chan_4op_2 = ((i > 2 && i < 6) || (i > 11 && i < 15));
+		if (instr_4op) {
+			/* allocate 4op voice */
+			/* skip channels unavailable to 4op instrument */
+			if (!chan_4op_1)
+				continue;
+
+			if (vp->state)
+				/* kill one voice, CHEAP */
+				bp++;
+			/* get state of bounded 2op channel
+			   to be allocated for 4op instrument */
+			vp2 = &opl3->voices[i + 3];
+			if (vp2->state == SNDRV_OPL3_ST_ON_2OP) {
+				/* kill two voices, EXPENSIVE */
+				bp++;
+				voice_time = (voice_time > vp->time) ?
+					voice_time : vp->time;
+			}
+		} else {
+			/* allocate 2op voice */
+			if ((chan_4op_1) || (chan_4op_2))
+				/* use bounded channels for 2op, CHEAP */
+				bp++;
+			else if (vp->state)
+				/* kill one voice on 2op channel, CHEAP */
+				bp++;
+			/* raise kill cost to EXPENSIVE for all channels */
+			if (vp->state)
+				bp++;
+		}
+		if (voice_time < bp->time) {
+			bp->time = voice_time;
+			bp->voice = i;
+		}
+	}
+
+	for (i = 0; i < END; i++) {
+		if (best[i].voice >= 0) {
+#ifdef DEBUG_ALLOC
+			printk("%s %iop allocation on voice %i\n",
+			       alloc_type[i], instr_4op ? 4 : 2,
+			       best[i].voice);
+#endif
+			return best[i].voice;
+		}
+	}
+	/* not found */
+	return -1;
+}
+
+/* ------------------------------ */
+
+/*
+ * System timer interrupt function
+ */
+void snd_opl3_timer_func(unsigned long data)
+{
+
+	opl3_t *opl3 = (opl3_t *)data;
+	int again = 0;
+	int i;
+
+	spin_lock(&opl3->sys_timer_lock);
+	for (i = 0; i < opl3->max_voices; i++) {
+		snd_opl3_voice_t *vp = &opl3->voices[i];
+		if (vp->state > 0 && vp->note_off_check) {
+			if (vp->note_off == jiffies)
+				snd_opl3_note_off(opl3, vp->note, 0, vp->chan);
+			else
+				again++;
+		}
+	}
+	if (again) {
+		opl3->tlist.expires = jiffies + 1;	/* invoke again */
+		add_timer(&opl3->tlist);
+	} else {
+		opl3->sys_timer_status = 0;
+	}
+	spin_unlock(&opl3->sys_timer_lock);
+}
+
+/*
+ * Start system timer
+ */
+static void snd_opl3_start_timer(opl3_t *opl3)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&opl3->sys_timer_lock, flags);
+	if (! opl3->sys_timer_status) {
+		opl3->tlist.expires = jiffies + 1;
+		add_timer(&opl3->tlist);
+		opl3->sys_timer_status = 1;
+	}
+	spin_unlock_irqrestore(&opl3->sys_timer_lock, flags);
+}
+
+/* ------------------------------ */
+
+
+static int snd_opl3_oss_map[MAX_OPL3_VOICES] = {
+	0, 1, 2, 9, 10, 11, 6, 7, 8, 15, 16, 17, 3, 4 ,5, 12, 13, 14
+};
+
+/*
+ * Start a note.
+ */
+void snd_opl3_note_on(void *p, int note, int vel, snd_midi_channel_t *chan)
+{
+	opl3_t *opl3;
+	snd_seq_instr_t wanted;
+	snd_seq_kinstr_t *kinstr;
+	int instr_4op;
+
+	int voice;
+	snd_opl3_voice_t *vp, *vp2;
+	unsigned short connect_mask;
+	unsigned char connection;
+	unsigned char vol_op[4];
+
+	int extra_prg = 0;
+
+	unsigned short reg_side;
+	unsigned char op_offset;
+	unsigned char voice_offset;
+	unsigned short opl3_reg;
+	unsigned char reg_val;
+
+	int key = note;
+	unsigned char fnum, blocknum;
+	int i;
+
+	fm_instrument_t *fm;
+	unsigned long flags;
+
+	opl3 = p;
+
+#ifdef DEBUG_MIDI
+	snd_printk("Note on, ch %i, inst %i, note %i, vel %i\n",
+		   chan->number, chan->midi_program, note, vel);
+#endif
+	wanted.cluster = 0;
+	wanted.std = SNDRV_SEQ_INSTR_TYPE2_OPL2_3;
+
+	/* in SYNTH mode, application takes care of voices */
+	/* in SEQ mode, drum voice numbers are notes on drum channel */
+	if (opl3->synth_mode == SNDRV_OPL3_MODE_SEQ) {
+		if (chan->drum_channel) {
+			/* percussion instruments are located in bank 128 */
+			wanted.bank = 128;
+			wanted.prg = note;
+		} else {
+			wanted.bank = chan->gm_bank_select;
+			wanted.prg = chan->midi_program;
+		}
+	} else {
+		/* Prepare for OSS mode */
+		if (chan->number >= MAX_OPL3_VOICES)
+			return;
+
+		/* OSS instruments are located in bank 127 */
+		wanted.bank = 127;
+		wanted.prg = chan->midi_program;
+	}
+
+	spin_lock_irqsave(&opl3->voice_lock, flags);
+
+	if (use_internal_drums) {
+		snd_opl3_drum_switch(opl3, note, vel, 1, chan);
+		spin_unlock_irqrestore(&opl3->voice_lock, flags);
+		return;
+	}
+
+ __extra_prg:
+	kinstr = snd_seq_instr_find(opl3->ilist, &wanted, 1, 0);
+	if (kinstr == NULL) {
+		spin_unlock_irqrestore(&opl3->voice_lock, flags);
+		return;
+	}
+
+	fm = KINSTR_DATA(kinstr);
+
+	switch (fm->type) {
+	case FM_PATCH_OPL2:
+		instr_4op = 0;
+		break;
+	case FM_PATCH_OPL3:
+		if (opl3->hardware >= OPL3_HW_OPL3) {
+			instr_4op = 1;
+			break;
+		}
+	default:
+		snd_seq_instr_free_use(opl3->ilist, kinstr);
+		spin_unlock_irqrestore(&opl3->voice_lock, flags);
+		return;
+	}
+
+#ifdef DEBUG_MIDI
+	snd_printk("  --> OPL%i instrument: %s\n",
+		   instr_4op ? 3 : 2, kinstr->name);
+#endif
+	/* in SYNTH mode, application takes care of voices */
+	/* in SEQ mode, allocate voice on free OPL3 channel */
+	if (opl3->synth_mode == SNDRV_OPL3_MODE_SEQ) {
+		voice = opl3_get_voice(opl3, instr_4op, chan);
+	} else {
+		/* remap OSS voice */
+		voice = snd_opl3_oss_map[chan->number];		
+	}
+
+	if (voice < MAX_OPL2_VOICES) {
+		/* Left register block for voices 0 .. 8 */
+		reg_side = OPL3_LEFT;
+		voice_offset = voice;
+		connect_mask = (OPL3_LEFT_4OP_0 << voice_offset) & 0x07;
+	} else {
+		/* Right register block for voices 9 .. 17 */
+		reg_side = OPL3_RIGHT;
+		voice_offset = voice - MAX_OPL2_VOICES;
+		connect_mask = (OPL3_RIGHT_4OP_0 << voice_offset) & 0x38;
+	}
+
+	/* kill voice on channel */
+	vp = &opl3->voices[voice];
+	if (vp->state > 0) {
+		opl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);
+		reg_val = vp->keyon_reg & ~OPL3_KEYON_BIT;
+		opl3->command(opl3, opl3_reg, reg_val);
+	}
+	if (instr_4op) {
+		vp2 = &opl3->voices[voice + 3];
+		if (vp->state > 0) {
+			opl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK +
+					       voice_offset + 3);
+			reg_val = vp->keyon_reg & ~OPL3_KEYON_BIT;
+			opl3->command(opl3, opl3_reg, reg_val);
+		}
+	}
+
+	/* set connection register */
+	if (instr_4op) {
+		if ((opl3->connection_reg ^ connect_mask) & connect_mask) {
+			opl3->connection_reg |= connect_mask;
+			/* set connection bit */
+			opl3_reg = OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT;
+			opl3->command(opl3, opl3_reg, opl3->connection_reg);
+		}
+	} else {
+		if ((opl3->connection_reg ^ ~connect_mask) & connect_mask) {
+			opl3->connection_reg &= ~connect_mask;
+			/* clear connection bit */
+			opl3_reg = OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT;
+			opl3->command(opl3, opl3_reg, opl3->connection_reg);
+		}
+	}
+
+#ifdef DEBUG_MIDI
+	snd_printk("  --> setting OPL3 connection: 0x%x\n",
+		   opl3->connection_reg);
+#endif
+	/*
+	 * calculate volume depending on connection
+	 * between FM operators (see include/opl3.h)
+	 */
+	for (i = 0; i < (instr_4op ? 4 : 2); i++)
+		vol_op[i] = fm->op[i].ksl_level;
+
+	connection = fm->feedback_connection[0] & 0x01;
+	if (instr_4op) {
+		connection <<= 1;
+		connection |= fm->feedback_connection[1] & 0x01;
+
+		snd_opl3_calc_volume(&vol_op[3], vel, chan);
+		switch (connection) {
+		case 0x03:
+			snd_opl3_calc_volume(&vol_op[2], vel, chan);
+			/* fallthru */
+		case 0x02:
+			snd_opl3_calc_volume(&vol_op[0], vel, chan);
+			break;
+		case 0x01:
+			snd_opl3_calc_volume(&vol_op[1], vel, chan);
+		}
+	} else {
+		snd_opl3_calc_volume(&vol_op[1], vel, chan);
+		if (connection)
+			snd_opl3_calc_volume(&vol_op[0], vel, chan);
+	}
+
+	/* Program the FM voice characteristics */
+	for (i = 0; i < (instr_4op ? 4 : 2); i++) {
+#ifdef DEBUG_MIDI
+		snd_printk("  --> programming operator %i\n", i);
+#endif
+		op_offset = snd_opl3_regmap[voice_offset][i];
+
+		/* Set OPL3 AM_VIB register of requested voice/operator */ 
+		reg_val = fm->op[i].am_vib;
+		opl3_reg = reg_side | (OPL3_REG_AM_VIB + op_offset);
+		opl3->command(opl3, opl3_reg, reg_val);
+
+		/* Set OPL3 KSL_LEVEL register of requested voice/operator */ 
+		reg_val = vol_op[i];
+		opl3_reg = reg_side | (OPL3_REG_KSL_LEVEL + op_offset);
+		opl3->command(opl3, opl3_reg, reg_val);
+
+		/* Set OPL3 ATTACK_DECAY register of requested voice/operator */ 
+		reg_val = fm->op[i].attack_decay;
+		opl3_reg = reg_side | (OPL3_REG_ATTACK_DECAY + op_offset);
+		opl3->command(opl3, opl3_reg, reg_val);
+
+		/* Set OPL3 SUSTAIN_RELEASE register of requested voice/operator */ 
+		reg_val = fm->op[i].sustain_release;
+		opl3_reg = reg_side | (OPL3_REG_SUSTAIN_RELEASE + op_offset);
+		opl3->command(opl3, opl3_reg, reg_val);
+
+		/* Select waveform */
+		reg_val = fm->op[i].wave_select;
+		opl3_reg = reg_side | (OPL3_REG_WAVE_SELECT + op_offset);
+		opl3->command(opl3, opl3_reg, reg_val);
+	}
+
+	/* Set operator feedback and 2op inter-operator connection */
+	reg_val = fm->feedback_connection[0];
+	/* Set output voice connection */
+	reg_val |= OPL3_STEREO_BITS;
+	if (chan->gm_pan < 43)
+		reg_val &= ~OPL3_VOICE_TO_RIGHT;
+	if (chan->gm_pan > 85)
+		reg_val &= ~OPL3_VOICE_TO_LEFT;
+	opl3_reg = reg_side | (OPL3_REG_FEEDBACK_CONNECTION + voice_offset);
+	opl3->command(opl3, opl3_reg, reg_val);
+
+	if (instr_4op) {
+		/* Set 4op inter-operator connection */
+		reg_val = fm->feedback_connection[1] & OPL3_CONNECTION_BIT;
+		/* Set output voice connection */
+		reg_val |= OPL3_STEREO_BITS;
+		if (chan->gm_pan < 43)
+			reg_val &= ~OPL3_VOICE_TO_RIGHT;
+		if (chan->gm_pan > 85)
+			reg_val &= ~OPL3_VOICE_TO_LEFT;
+		opl3_reg = reg_side | (OPL3_REG_FEEDBACK_CONNECTION +
+				       voice_offset + 3);
+		opl3->command(opl3, opl3_reg, reg_val);
+	}
+
+	/*
+	 * Special treatment of percussion notes for fm:
+	 * Requested pitch is really program, and pitch for
+	 * device is whatever was specified in the patch library.
+	 */
+	if (fm->fix_key)
+		note = fm->fix_key;
+	/*
+	 * use transpose if defined in patch library
+	 */
+	if (fm->trnsps)
+		note += (fm->trnsps - 64);
+
+	snd_opl3_calc_pitch(&fnum, &blocknum, note, chan);
+
+	/* Set OPL3 FNUM_LOW register of requested voice */
+	opl3_reg = reg_side | (OPL3_REG_FNUM_LOW + voice_offset);
+	opl3->command(opl3, opl3_reg, fnum);
+
+	opl3->voices[voice].keyon_reg = blocknum;
+
+	/* Set output sound flag */
+	blocknum |= OPL3_KEYON_BIT;
+
+#ifdef DEBUG_MIDI
+	snd_printk("  --> trigger voice %i\n", voice);
+#endif
+	/* Set OPL3 KEYON_BLOCK register of requested voice */ 
+	opl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);
+	opl3->command(opl3, opl3_reg, blocknum);
+
+	/* kill note after fixed duration (in centiseconds) */
+	if (fm->fix_dur) {
+		opl3->voices[voice].note_off = jiffies +
+			(fm->fix_dur * HZ) / 100;
+		snd_opl3_start_timer(opl3);
+		opl3->voices[voice].note_off_check = 1;
+	} else
+		opl3->voices[voice].note_off_check = 0;
+
+	/* get extra pgm, but avoid possible loops */
+	extra_prg = (extra_prg) ? 0 : fm->modes;
+
+	snd_seq_instr_free_use(opl3->ilist, kinstr);
+
+	/* do the bookkeeping */
+	vp->time = opl3->use_time++;
+	vp->note = key;
+	vp->chan = chan;
+
+	if (instr_4op) {
+		vp->state = SNDRV_OPL3_ST_ON_4OP;
+
+		vp2 = &opl3->voices[voice + 3];
+		vp2->time = opl3->use_time++;
+		vp2->note = key;
+		vp2->chan = chan;
+		vp2->state = SNDRV_OPL3_ST_NOT_AVAIL;
+	} else {
+		if (vp->state == SNDRV_OPL3_ST_ON_4OP) {
+			/* 4op killed by 2op, release bounded voice */
+			vp2 = &opl3->voices[voice + 3];
+			vp2->time = opl3->use_time++;
+			vp2->state = SNDRV_OPL3_ST_OFF;
+		}
+		vp->state = SNDRV_OPL3_ST_ON_2OP;
+	}
+
+#ifdef DEBUG_ALLOC
+	debug_alloc(opl3, "note on ", voice);
+#endif
+
+	/* allocate extra program if specified in patch library */
+	if (extra_prg) {
+		if (extra_prg > 128) {
+			wanted.bank = 128;
+			/* percussions start at 35 */
+			wanted.prg = extra_prg - 128 + 35 - 1;
+		} else {
+			wanted.bank = 0;
+			wanted.prg = extra_prg - 1;
+		}
+#ifdef DEBUG_MIDI
+		snd_printk(" *** allocating extra program\n");
+#endif
+		goto __extra_prg;
+	}
+	spin_unlock_irqrestore(&opl3->voice_lock, flags);
+}
+
+static void snd_opl3_kill_voice(opl3_t *opl3, int voice)
+{
+	unsigned short reg_side;
+	unsigned char voice_offset;
+	unsigned short opl3_reg;
+
+	snd_opl3_voice_t *vp, *vp2;
+
+	snd_assert(voice < MAX_OPL3_VOICES, return);
+
+	vp = &opl3->voices[voice];
+	if (voice < MAX_OPL2_VOICES) {
+		/* Left register block for voices 0 .. 8 */
+		reg_side = OPL3_LEFT;
+		voice_offset = voice;
+	} else {
+		/* Right register block for voices 9 .. 17 */
+		reg_side = OPL3_RIGHT;
+		voice_offset = voice - MAX_OPL2_VOICES;
+	}
+
+	/* kill voice */
+#ifdef DEBUG_MIDI
+	snd_printk("  --> kill voice %i\n", voice);
+#endif
+	opl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);
+	/* clear Key ON bit */
+	opl3->command(opl3, opl3_reg, vp->keyon_reg);
+
+	/* do the bookkeeping */
+	vp->time = opl3->use_time++;
+
+	if (vp->state == SNDRV_OPL3_ST_ON_4OP) {
+		vp2 = &opl3->voices[voice + 3];
+
+		vp2->time = opl3->use_time++;
+		vp2->state = SNDRV_OPL3_ST_OFF;
+	}
+	vp->state = SNDRV_OPL3_ST_OFF;
+#ifdef DEBUG_ALLOC
+	debug_alloc(opl3, "note off", voice);
+#endif
+
+}
+
+/*
+ * Release a note in response to a midi note off.
+ */
+void snd_opl3_note_off(void *p, int note, int vel, snd_midi_channel_t *chan)
+{
+  	opl3_t *opl3;
+
+	int voice;
+	snd_opl3_voice_t *vp;
+
+	unsigned long flags;
+
+	opl3 = p;
+
+#ifdef DEBUG_MIDI
+	snd_printk("Note off, ch %i, inst %i, note %i\n",
+		   chan->number, chan->midi_program, note);
+#endif
+
+	spin_lock_irqsave(&opl3->voice_lock, flags);
+
+	if (opl3->synth_mode == SNDRV_OPL3_MODE_SEQ) {
+		if (chan->drum_channel && use_internal_drums) {
+			snd_opl3_drum_switch(opl3, note, vel, 0, chan);
+			spin_unlock_irqrestore(&opl3->voice_lock, flags);
+			return;
+		}
+		/* this loop will hopefully kill all extra voices, because
+		   they are grouped by the same channel and note values */
+		for (voice = 0; voice < opl3->max_voices; voice++) {
+			vp = &opl3->voices[voice];
+			if (vp->state > 0 && vp->chan == chan && vp->note == note) {
+				snd_opl3_kill_voice(opl3, voice);
+			}
+		}
+	} else {
+		/* remap OSS voices */
+		if (chan->number < MAX_OPL3_VOICES) {
+			voice = snd_opl3_oss_map[chan->number];		
+			snd_opl3_kill_voice(opl3, voice);
+		}
+	}
+	spin_unlock_irqrestore(&opl3->voice_lock, flags);
+}
+
+/*
+ * key pressure change
+ */
+void snd_opl3_key_press(void *p, int note, int vel, snd_midi_channel_t *chan)
+{
+  	opl3_t *opl3;
+
+	opl3 = p;
+#ifdef DEBUG_MIDI
+	snd_printk("Key pressure, ch#: %i, inst#: %i\n",
+		   chan->number, chan->midi_program);
+#endif
+}
+
+/*
+ * terminate note
+ */
+void snd_opl3_terminate_note(void *p, int note, snd_midi_channel_t *chan)
+{
+  	opl3_t *opl3;
+
+	opl3 = p;
+#ifdef DEBUG_MIDI
+	snd_printk("Terminate note, ch#: %i, inst#: %i\n",
+		   chan->number, chan->midi_program);
+#endif
+}
+
+static void snd_opl3_update_pitch(opl3_t *opl3, int voice)
+{
+	unsigned short reg_side;
+	unsigned char voice_offset;
+	unsigned short opl3_reg;
+
+	unsigned char fnum, blocknum;
+
+	snd_opl3_voice_t *vp;
+
+	snd_assert(voice < MAX_OPL3_VOICES, return);
+
+	vp = &opl3->voices[voice];
+	if (vp->chan == NULL)
+		return; /* not allocated? */
+
+	if (voice < MAX_OPL2_VOICES) {
+		/* Left register block for voices 0 .. 8 */
+		reg_side = OPL3_LEFT;
+		voice_offset = voice;
+	} else {
+		/* Right register block for voices 9 .. 17 */
+		reg_side = OPL3_RIGHT;
+		voice_offset = voice - MAX_OPL2_VOICES;
+	}
+
+	snd_opl3_calc_pitch(&fnum, &blocknum, vp->note, vp->chan);
+
+	/* Set OPL3 FNUM_LOW register of requested voice */
+	opl3_reg = reg_side | (OPL3_REG_FNUM_LOW + voice_offset);
+	opl3->command(opl3, opl3_reg, fnum);
+
+	vp->keyon_reg = blocknum;
+
+	/* Set output sound flag */
+	blocknum |= OPL3_KEYON_BIT;
+
+	/* Set OPL3 KEYON_BLOCK register of requested voice */ 
+	opl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);
+	opl3->command(opl3, opl3_reg, blocknum);
+
+	vp->time = opl3->use_time++;
+}
+
+/*
+ * Update voice pitch controller
+ */
+static void snd_opl3_pitch_ctrl(opl3_t *opl3, snd_midi_channel_t *chan)
+{
+	int voice;
+	snd_opl3_voice_t *vp;
+
+	unsigned long flags;
+
+	spin_lock_irqsave(&opl3->voice_lock, flags);
+
+	if (opl3->synth_mode == SNDRV_OPL3_MODE_SEQ) {
+		for (voice = 0; voice < opl3->max_voices; voice++) {
+			vp = &opl3->voices[voice];
+			if (vp->state > 0 && vp->chan == chan) {
+				snd_opl3_update_pitch(opl3, voice);
+			}
+		}
+	} else {
+		/* remap OSS voices */
+		if (chan->number < MAX_OPL3_VOICES) {
+			voice = snd_opl3_oss_map[chan->number];		
+			snd_opl3_update_pitch(opl3, voice);
+		}
+	}
+	spin_unlock_irqrestore(&opl3->voice_lock, flags);
+}
+
+/*
+ * Deal with a controler type event.  This includes all types of
+ * control events, not just the midi controllers
+ */
+void snd_opl3_control(void *p, int type, snd_midi_channel_t *chan)
+{
+  	opl3_t *opl3;
+
+	opl3 = p;
+#ifdef DEBUG_MIDI
+	snd_printk("Controller, TYPE = %i, ch#: %i, inst#: %i\n",
+		   type, chan->number, chan->midi_program);
+#endif
+
+	switch (type) {
+	case MIDI_CTL_MSB_MODWHEEL:
+		if (chan->control[MIDI_CTL_MSB_MODWHEEL] > 63)
+			opl3->drum_reg |= OPL3_VIBRATO_DEPTH;
+		else 
+			opl3->drum_reg &= ~OPL3_VIBRATO_DEPTH;
+		opl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION,
+				 opl3->drum_reg);
+		break;
+	case MIDI_CTL_E2_TREMOLO_DEPTH:
+		if (chan->control[MIDI_CTL_E2_TREMOLO_DEPTH] > 63)
+			opl3->drum_reg |= OPL3_TREMOLO_DEPTH;
+		else 
+			opl3->drum_reg &= ~OPL3_TREMOLO_DEPTH;
+		opl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION,
+				 opl3->drum_reg);
+		break;
+	case MIDI_CTL_PITCHBEND:
+		snd_opl3_pitch_ctrl(opl3, chan);
+		break;
+	}
+}
+
+/*
+ * NRPN events
+ */
+void snd_opl3_nrpn(void *p, snd_midi_channel_t *chan,
+		   snd_midi_channel_set_t *chset)
+{
+  	opl3_t *opl3;
+
+	opl3 = p;
+#ifdef DEBUG_MIDI
+	snd_printk("NRPN, ch#: %i, inst#: %i\n",
+		   chan->number, chan->midi_program);
+#endif
+}
+
+/*
+ * receive sysex
+ */
+void snd_opl3_sysex(void *p, unsigned char *buf, int len,
+		    int parsed, snd_midi_channel_set_t *chset)
+{
+  	opl3_t *opl3;
+
+	opl3 = p;
+#ifdef DEBUG_MIDI
+	snd_printk("SYSEX\n");
+#endif
+}
