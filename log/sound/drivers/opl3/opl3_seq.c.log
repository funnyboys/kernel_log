commit aad7ebb544072bcb9335fa4eb0fbd1b85a6c495b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:45 2020 +0100

    ALSA: seq: Constify struct snd_midi_op
    
    Change the argument of snd_midi_process_event() to receive a const
    snd_midi_op pointer and its callers respectively.  This allows further
    optimizations.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-30-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index 20f2f5125394..cd2a01b5e2e1 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -128,7 +128,7 @@ static int snd_opl3_synth_unuse(void *private_data, struct snd_seq_port_subscrib
 /*
  * MIDI emulation operators
  */
-struct snd_midi_op opl3_ops = {
+const struct snd_midi_op opl3_ops = {
 	.note_on =		snd_opl3_note_on,
 	.note_off =		snd_opl3_note_off,
 	.key_press =		snd_opl3_key_press,

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index 5f881c4cdf1f..20f2f5125394 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Copyright (c) by Uros Bizjak <uros@kss-loka.si>
  *
@@ -5,21 +6,6 @@
  *
  *  OPL2/3 FM instrument loader:
  *   alsa-tools/seq/sbiload/
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include "opl3_voice.h"

commit bc47ba90b01afe468cdd586b0dbe59b64862e2b7
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 24 08:34:29 2017 -0700

    ALSA: drivers: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index d3e91be8b23a..5f881c4cdf1f 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -248,7 +248,7 @@ static int snd_opl3_seq_probe(struct device *_dev)
 	}
 
 	/* setup system timer */
-	setup_timer(&opl3->tlist, snd_opl3_timer_func, (unsigned long) opl3);
+	timer_setup(&opl3->tlist, snd_opl3_timer_func, 0);
 	spin_lock_init(&opl3->sys_timer_lock);
 	opl3->sys_timer_status = 0;
 

commit 3d774d5ef066971aee1839150bf47d100d8e43d3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 9 14:06:46 2017 +0200

    ALSA: seq: Allow the tristate build of OSS emulation
    
    Currently OSS sequencer emulation is tied with ALSA sequencer core,
    both are built in the same level; i.e. when CONFIG_SND_SEQUENCER=y,
    the OSS sequencer emulation is also always built-in, even though the
    functionality can be built as an individual module.
    
    This patch changes the rule and allows users to build snd-seq-oss
    module while others are built-in.  Essentially, it's just a few simple
    changes in Kconfig and Makefile.  Some driver codes like opl3 need to
    convert from the simple ifdef to IS_ENABLED().  But that's all.
    
    You might wonder how about the dependency: right, it can be messy, but
    it still works.  Since we rewrote the sequencer binding with the
    standard bus, the driver can be bound at any time on demand.  So, the
    synthesizer driver module can be loaded individually from the OSS
    emulation core before/after it.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index fdae5d7f421f..d3e91be8b23a 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -252,7 +252,7 @@ static int snd_opl3_seq_probe(struct device *_dev)
 	spin_lock_init(&opl3->sys_timer_lock);
 	opl3->sys_timer_status = 0;
 
-#ifdef CONFIG_SND_SEQUENCER_OSS
+#if IS_ENABLED(CONFIG_SND_SEQUENCER_OSS)
 	snd_opl3_init_seq_oss(opl3, name);
 #endif
 	return 0;
@@ -267,7 +267,7 @@ static int snd_opl3_seq_remove(struct device *_dev)
 	if (opl3 == NULL)
 		return -EINVAL;
 
-#ifdef CONFIG_SND_SEQUENCER_OSS
+#if IS_ENABLED(CONFIG_SND_SEQUENCER_OSS)
 	snd_opl3_free_seq_oss(opl3);
 #endif
 	if (opl3->seq_client >= 0) {

commit 056622053b8ae02978678ac1321b5bd956e7c812
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 12 13:43:22 2015 +0100

    ALSA: seq: Define driver object in each driver
    
    This patch moves the driver object initialization and allocation to
    each driver's module init/exit code like other normal drivers.  The
    snd_seq_driver struct is now published in seq_device.h, and each
    driver is responsible to define it with proper driver attributes
    (name, probe and remove) with snd_seq_driver specific attributes as id
    and argsize fields.  The helper functions snd_seq_driver_register(),
    snd_seq_driver_unregister() and module_snd_seq_driver() are used for
    simplifying codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index a9f618e06a22..fdae5d7f421f 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -216,8 +216,9 @@ static int snd_opl3_synth_create_port(struct snd_opl3 * opl3)
 
 /* ------------------------------ */
 
-static int snd_opl3_seq_new_device(struct snd_seq_device *dev)
+static int snd_opl3_seq_probe(struct device *_dev)
 {
+	struct snd_seq_device *dev = to_seq_dev(_dev);
 	struct snd_opl3 *opl3;
 	int client, err;
 	char name[32];
@@ -257,8 +258,9 @@ static int snd_opl3_seq_new_device(struct snd_seq_device *dev)
 	return 0;
 }
 
-static int snd_opl3_seq_delete_device(struct snd_seq_device *dev)
+static int snd_opl3_seq_remove(struct device *_dev)
 {
+	struct snd_seq_device *dev = to_seq_dev(_dev);
 	struct snd_opl3 *opl3;
 
 	opl3 = *(struct snd_opl3 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
@@ -275,22 +277,14 @@ static int snd_opl3_seq_delete_device(struct snd_seq_device *dev)
 	return 0;
 }
 
-static int __init alsa_opl3_seq_init(void)
-{
-	static struct snd_seq_dev_ops ops =
-	{
-		snd_opl3_seq_new_device,
-		snd_opl3_seq_delete_device
-	};
-
-	return snd_seq_device_register_driver(SNDRV_SEQ_DEV_ID_OPL3, &ops,
-					      sizeof(struct snd_opl3 *));
-}
-
-static void __exit alsa_opl3_seq_exit(void)
-{
-	snd_seq_device_unregister_driver(SNDRV_SEQ_DEV_ID_OPL3);
-}
+static struct snd_seq_driver opl3_seq_driver = {
+	.driver = {
+		.name = KBUILD_MODNAME,
+		.probe = snd_opl3_seq_probe,
+		.remove = snd_opl3_seq_remove,
+	},
+	.id = SNDRV_SEQ_DEV_ID_OPL3,
+	.argsize = sizeof(struct snd_opl3 *),
+};
 
-module_init(alsa_opl3_seq_init)
-module_exit(alsa_opl3_seq_exit)
+module_snd_seq_driver(opl3_seq_driver);

commit f5d5f75fe167c8b80747290968aeaa91457cb10a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 11:28:54 2015 +0100

    ALSA: opl3: Use setup_timer() and mod_timer()
    
    No functional change, refactoring with the standard helpers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index 68399538e435..a9f618e06a22 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -247,9 +247,7 @@ static int snd_opl3_seq_new_device(struct snd_seq_device *dev)
 	}
 
 	/* setup system timer */
-	init_timer(&opl3->tlist);
-	opl3->tlist.function = snd_opl3_timer_func;
-	opl3->tlist.data = (unsigned long) opl3;
+	setup_timer(&opl3->tlist, snd_opl3_timer_func, (unsigned long) opl3);
 	spin_lock_init(&opl3->sys_timer_lock);
 	opl3->sys_timer_status = 0;
 

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index 723562e34fcc..68399538e435 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -32,7 +32,7 @@ MODULE_AUTHOR("Uros Bizjak <uros@kss-loka.si>");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("ALSA driver for OPL3 FM synth");
 
-int use_internal_drums = 0;
+bool use_internal_drums = 0;
 module_param(use_internal_drums, bool, 0444);
 MODULE_PARM_DESC(use_internal_drums, "Enable internal OPL2/3 drums.");
 

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index 2d33f53d36b8..723562e34fcc 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -25,6 +25,7 @@
 #include "opl3_voice.h"
 #include <linux/init.h>
 #include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Uros Bizjak <uros@kss-loka.si>");

commit 045765253c610cb5acebb22ae94d759f586d9521
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 30 12:43:40 2007 +0100

    [ALSA] opl3 - Fix build errors
    
    I applied a wrong patch for 'opl3 - simplify exclusive access lock'.
    Fixed now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index 6fd60b7e5805..2d33f53d36b8 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -82,6 +82,7 @@ int snd_opl3_synth_setup(struct snd_opl3 * opl3)
 void snd_opl3_synth_cleanup(struct snd_opl3 * opl3)
 {
 	unsigned long flags;
+	struct snd_hwdep *hwdep;
 
 	/* Stop system timer */
 	spin_lock_irqsave(&opl3->sys_timer_lock, flags);

commit 05c1afe75fcebf456017ec186811cf1599f4360e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 30 11:59:15 2007 +0100

    [ALSA] opl3 - simplify exclusive access lock
    
    Use the exclusive access lock in hwdep instead of the own one.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index ff6da16b9178..6fd60b7e5805 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -51,14 +51,15 @@ void snd_opl3_synth_use_dec(struct snd_opl3 * opl3)
 int snd_opl3_synth_setup(struct snd_opl3 * opl3)
 {
 	int idx;
+	struct snd_hwdep *hwdep = opl3->hwdep;
 
-	mutex_lock(&opl3->access_mutex);
-	if (opl3->used) {
-		mutex_unlock(&opl3->access_mutex);
+	mutex_lock(&hwdep->open_mutex);
+	if (hwdep->used) {
+		mutex_unlock(&hwdep->open_mutex);
 		return -EBUSY;
 	}
-	opl3->used++;
-	mutex_unlock(&opl3->access_mutex);
+	hwdep->used++;
+	mutex_unlock(&hwdep->open_mutex);
 
 	snd_opl3_reset(opl3);
 
@@ -91,9 +92,11 @@ void snd_opl3_synth_cleanup(struct snd_opl3 * opl3)
 	spin_unlock_irqrestore(&opl3->sys_timer_lock, flags);
 
 	snd_opl3_reset(opl3);
-	mutex_lock(&opl3->access_mutex);
-	opl3->used--;
-	mutex_unlock(&opl3->access_mutex);
+	hwdep = opl3->hwdep;
+	mutex_lock(&hwdep->open_mutex);
+	hwdep->used--;
+	mutex_unlock(&hwdep->open_mutex);
+	wake_up(&hwdep->open_wait);
 }
 
 static int snd_opl3_synth_use(void *private_data, struct snd_seq_port_subscribe * info)

commit 224a033252bba46c5c8b5df625f5e781ca138f48
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 30 11:49:22 2007 +0100

    [ALSA] opl3 - Use hwdep for patch loading
    
    Use the hwdep device for loading OPL2/3 patch data instead of the
    messy sequencer instrument layer.
    Due to this change, the sbiload program should be updated, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index 96762c9d4855..ff6da16b9178 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -152,15 +152,7 @@ static int snd_opl3_synth_event_input(struct snd_seq_event * ev, int direct,
 {
 	struct snd_opl3 *opl3 = private_data;
 
-	if (ev->type >= SNDRV_SEQ_EVENT_INSTR_BEGIN &&
-	    ev->type <= SNDRV_SEQ_EVENT_INSTR_CHANGE) {
-		if (direct) {
-			snd_seq_instr_event(&opl3->fm_ops, opl3->ilist, ev,
-					    opl3->seq_client, atomic, hop);
-		}
-	} else {
-		snd_midi_process_event(&opl3_ops, ev, opl3->chset);
-	}
+	snd_midi_process_event(&opl3_ops, ev, opl3->chset);
 	return 0;
 }
 
@@ -249,16 +241,6 @@ static int snd_opl3_seq_new_device(struct snd_seq_device *dev)
 		return err;
 	}
 
-	/* initialize instrument list */
-	opl3->ilist = snd_seq_instr_list_new();
-	if (opl3->ilist == NULL) {
-		snd_seq_delete_kernel_client(client);
-		opl3->seq_client = -1;
-		return -ENOMEM;
-	}
-	opl3->ilist->flags = SNDRV_SEQ_INSTR_FLG_DIRECT;
-	snd_seq_fm_init(&opl3->fm_ops, NULL);
-
 	/* setup system timer */
 	init_timer(&opl3->tlist);
 	opl3->tlist.function = snd_opl3_timer_func;
@@ -287,8 +269,6 @@ static int snd_opl3_seq_delete_device(struct snd_seq_device *dev)
 		snd_seq_delete_kernel_client(opl3->seq_client);
 		opl3->seq_client = -1;
 	}
-	if (opl3->ilist)
-		snd_seq_instr_list_free(&opl3->ilist);
 	return 0;
 }
 

commit 450047a78f3c35a905576e121abfbee2ccd45993
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue May 2 16:08:41 2006 +0200

    [ALSA] add more sequencer port type information bits
    
    Add four new information flags SNDRV_SEQ_PORT_TYPE_HARDWARE, _SOFTWARE,
    _SYNTHESIZER, _PORT for sequencer ports.  This makes it easier for apps
    like Rosegarden to make policy decisions based on the port type.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index 2aece1b18660..96762c9d4855 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -203,7 +203,9 @@ static int snd_opl3_synth_create_port(struct snd_opl3 * opl3)
 						      SNDRV_SEQ_PORT_CAP_SUBS_WRITE,
 						      SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |
 						      SNDRV_SEQ_PORT_TYPE_MIDI_GM |
-						      SNDRV_SEQ_PORT_TYPE_DIRECT_SAMPLE,
+						      SNDRV_SEQ_PORT_TYPE_DIRECT_SAMPLE |
+						      SNDRV_SEQ_PORT_TYPE_HARDWARE |
+						      SNDRV_SEQ_PORT_TYPE_SYNTHESIZER,
 						      16, voices,
 						      name);
 	if (opl3->chset->port < 0) {

commit c97f3dd85490e51ba48782dd0c063cdade352c0d
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue May 2 15:50:05 2006 +0200

    [ALSA] fix port type bits
    
    Fix the port information about non-MIDI messages that had wrong values
    for some OPL3 and EmuX ports.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index 57becf34f43e..2aece1b18660 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -203,7 +203,7 @@ static int snd_opl3_synth_create_port(struct snd_opl3 * opl3)
 						      SNDRV_SEQ_PORT_CAP_SUBS_WRITE,
 						      SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |
 						      SNDRV_SEQ_PORT_TYPE_MIDI_GM |
-						      SNDRV_SEQ_PORT_TYPE_SYNTH,
+						      SNDRV_SEQ_PORT_TYPE_DIRECT_SAMPLE,
 						      16, voices,
 						      name);
 	if (opl3->chset->port < 0) {

commit 5e315e9248329c53a8932b71532c28240125e3c4
Author: Dave Jones <davej@redhat.com>
Date:   Mon Mar 6 14:03:37 2006 +0100

    [ALSA] Fix use after free in opl3_seq and opl3_oss
    
    Modules: OPL3
    
    Don't read from free'd memory.  Also make use of the return
    value, and don't register the device if something went wrong
    creating the port.
    
    Coverity #954, #955
    
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index e26556d500e5..57becf34f43e 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -207,8 +207,10 @@ static int snd_opl3_synth_create_port(struct snd_opl3 * opl3)
 						      16, voices,
 						      name);
 	if (opl3->chset->port < 0) {
+		int port;
+		port = opl3->chset->port;
 		snd_midi_channel_free_set(opl3->chset);
-		return opl3->chset->port;
+		return port;
 	}
 	return 0;
 }
@@ -218,7 +220,7 @@ static int snd_opl3_synth_create_port(struct snd_opl3 * opl3)
 static int snd_opl3_seq_new_device(struct snd_seq_device *dev)
 {
 	struct snd_opl3 *opl3;
-	int client;
+	int client, err;
 	char name[32];
 	int opl_ver;
 
@@ -239,7 +241,11 @@ static int snd_opl3_seq_new_device(struct snd_seq_device *dev)
 	if (client < 0)
 		return client;
 
-	snd_opl3_synth_create_port(opl3);
+	if ((err = snd_opl3_synth_create_port(opl3)) < 0) {
+		snd_seq_delete_kernel_client(client);
+		opl3->seq_client = -1;
+		return err;
+	}
 
 	/* initialize instrument list */
 	opl3->ilist = snd_seq_instr_list_new();

commit ef9f0a42db987e7e2df72289fb4522d24027786b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:31:42 2006 +0100

    [ALSA] semaphore -> mutex (driver part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index c4ead790008a..e26556d500e5 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -52,13 +52,13 @@ int snd_opl3_synth_setup(struct snd_opl3 * opl3)
 {
 	int idx;
 
-	down(&opl3->access_mutex);
+	mutex_lock(&opl3->access_mutex);
 	if (opl3->used) {
-		up(&opl3->access_mutex);
+		mutex_unlock(&opl3->access_mutex);
 		return -EBUSY;
 	}
 	opl3->used++;
-	up(&opl3->access_mutex);
+	mutex_unlock(&opl3->access_mutex);
 
 	snd_opl3_reset(opl3);
 
@@ -91,9 +91,9 @@ void snd_opl3_synth_cleanup(struct snd_opl3 * opl3)
 	spin_unlock_irqrestore(&opl3->sys_timer_lock, flags);
 
 	snd_opl3_reset(opl3);
-	down(&opl3->access_mutex);
+	mutex_lock(&opl3->access_mutex);
 	opl3->used--;
-	up(&opl3->access_mutex);
+	mutex_unlock(&opl3->access_mutex);
 }
 
 static int snd_opl3_synth_use(void *private_data, struct snd_seq_port_subscribe * info)

commit 7b6d92451ad5e1136dc347347e888b94638b8ba9
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Dec 12 09:33:37 2005 +0100

    [ALSA] seq: set client name in snd_seq_create_kernel_client()
    
    All users of snd_seq_create_kernel_client() have to set the client name
    anyway, so we can just pass the name as parameter.  This relieves us
    from having to muck around with a struct snd_seq_client_info in these
    cases.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index 582ff63e784b..c4ead790008a 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -219,7 +219,7 @@ static int snd_opl3_seq_new_device(struct snd_seq_device *dev)
 {
 	struct snd_opl3 *opl3;
 	int client;
-	struct snd_seq_client_info cinfo;
+	char name[32];
 	int opl_ver;
 
 	opl3 = *(struct snd_opl3 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
@@ -231,19 +231,14 @@ static int snd_opl3_seq_new_device(struct snd_seq_device *dev)
 	opl3->seq_client = -1;
 
 	/* allocate new client */
+	opl_ver = (opl3->hardware & OPL3_HW_MASK) >> 8;
+	sprintf(name, "OPL%i FM synth", opl_ver);
 	client = opl3->seq_client =
-		snd_seq_create_kernel_client(opl3->card, opl3->seq_dev_num);
+		snd_seq_create_kernel_client(opl3->card, opl3->seq_dev_num,
+					     name);
 	if (client < 0)
 		return client;
 
-	/* change name of client */
-	memset(&cinfo, 0, sizeof(cinfo));
-	cinfo.client = client;
-	cinfo.type = KERNEL_CLIENT;
-	opl_ver = (opl3->hardware & OPL3_HW_MASK) >> 8;
-	sprintf(cinfo.name, "OPL%i FM synth", opl_ver);
-	snd_seq_kernel_client_ctl(client, SNDRV_SEQ_IOCTL_SET_CLIENT_INFO, &cinfo);
-
 	snd_opl3_synth_create_port(opl3);
 
 	/* initialize instrument list */
@@ -264,7 +259,7 @@ static int snd_opl3_seq_new_device(struct snd_seq_device *dev)
 	opl3->sys_timer_status = 0;
 
 #ifdef CONFIG_SND_SEQUENCER_OSS
-	snd_opl3_init_seq_oss(opl3, cinfo.name);
+	snd_opl3_init_seq_oss(opl3, name);
 #endif
 	return 0;
 }

commit 83e8ad6984dccd6d848ac91ba0df379ff968180b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Dec 12 09:30:43 2005 +0100

    [ALSA] seq: remove struct snd_seq_client_callback
    
    The fields of struct snd_seq_client_callback either aren't used or are
    always set to the same value, so we can get rid of it altogether.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index 1886b2958e77..582ff63e784b 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -219,7 +219,6 @@ static int snd_opl3_seq_new_device(struct snd_seq_device *dev)
 {
 	struct snd_opl3 *opl3;
 	int client;
-	struct snd_seq_client_callback callbacks;
 	struct snd_seq_client_info cinfo;
 	int opl_ver;
 
@@ -232,11 +231,8 @@ static int snd_opl3_seq_new_device(struct snd_seq_device *dev)
 	opl3->seq_client = -1;
 
 	/* allocate new client */
-	memset(&callbacks, 0, sizeof(callbacks));
-	callbacks.private_data = opl3;
-	callbacks.allow_output = callbacks.allow_input = 1;
 	client = opl3->seq_client =
-	    snd_seq_create_kernel_client(opl3->card, opl3->seq_dev_num, &callbacks);
+		snd_seq_create_kernel_client(opl3->card, opl3->seq_dev_num);
 	if (client < 0)
 		return client;
 

commit 5b1646a8eceff0a4ff06f309abb6e7f43f99a498
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:13:14 2005 +0100

    [ALSA] Remove xxx_t typedefs: OPL3
    
    Modules: OPL3,Raw OPL FM
    
    Remove xxx_t typedefs from the OPL3 driver
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
index 136964b844de..1886b2958e77 100644
--- a/sound/drivers/opl3/opl3_seq.c
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -35,7 +35,7 @@ int use_internal_drums = 0;
 module_param(use_internal_drums, bool, 0444);
 MODULE_PARM_DESC(use_internal_drums, "Enable internal OPL2/3 drums.");
 
-int snd_opl3_synth_use_inc(opl3_t * opl3)
+int snd_opl3_synth_use_inc(struct snd_opl3 * opl3)
 {
 	if (!try_module_get(opl3->card->module))
 		return -EFAULT;
@@ -43,12 +43,12 @@ int snd_opl3_synth_use_inc(opl3_t * opl3)
 
 }
 
-void snd_opl3_synth_use_dec(opl3_t * opl3)
+void snd_opl3_synth_use_dec(struct snd_opl3 * opl3)
 {
 	module_put(opl3->card->module);
 }
 
-int snd_opl3_synth_setup(opl3_t * opl3)
+int snd_opl3_synth_setup(struct snd_opl3 * opl3)
 {
 	int idx;
 
@@ -78,7 +78,7 @@ int snd_opl3_synth_setup(opl3_t * opl3)
 	return 0;
 }
 
-void snd_opl3_synth_cleanup(opl3_t * opl3)
+void snd_opl3_synth_cleanup(struct snd_opl3 * opl3)
 {
 	unsigned long flags;
 
@@ -96,9 +96,9 @@ void snd_opl3_synth_cleanup(opl3_t * opl3)
 	up(&opl3->access_mutex);
 }
 
-static int snd_opl3_synth_use(void *private_data, snd_seq_port_subscribe_t * info)
+static int snd_opl3_synth_use(void *private_data, struct snd_seq_port_subscribe * info)
 {
-	opl3_t *opl3 = private_data;
+	struct snd_opl3 *opl3 = private_data;
 	int err;
 
 	if ((err = snd_opl3_synth_setup(opl3)) < 0)
@@ -123,9 +123,9 @@ static int snd_opl3_synth_use(void *private_data, snd_seq_port_subscribe_t * inf
 	return 0;
 }
 
-static int snd_opl3_synth_unuse(void *private_data, snd_seq_port_subscribe_t * info)
+static int snd_opl3_synth_unuse(void *private_data, struct snd_seq_port_subscribe * info)
 {
-	opl3_t *opl3 = private_data;
+	struct snd_opl3 *opl3 = private_data;
 
 	snd_opl3_synth_cleanup(opl3);
 
@@ -137,7 +137,7 @@ static int snd_opl3_synth_unuse(void *private_data, snd_seq_port_subscribe_t * i
 /*
  * MIDI emulation operators
  */
-snd_midi_op_t opl3_ops = {
+struct snd_midi_op opl3_ops = {
 	.note_on =		snd_opl3_note_on,
 	.note_off =		snd_opl3_note_off,
 	.key_press =		snd_opl3_key_press,
@@ -147,10 +147,10 @@ snd_midi_op_t opl3_ops = {
 	.sysex =		snd_opl3_sysex,
 };
 
-static int snd_opl3_synth_event_input(snd_seq_event_t * ev, int direct,
+static int snd_opl3_synth_event_input(struct snd_seq_event * ev, int direct,
 				      void *private_data, int atomic, int hop)
 {
-	opl3_t *opl3 = private_data;
+	struct snd_opl3 *opl3 = private_data;
 
 	if (ev->type >= SNDRV_SEQ_EVENT_INSTR_BEGIN &&
 	    ev->type <= SNDRV_SEQ_EVENT_INSTR_CHANGE) {
@@ -168,14 +168,14 @@ static int snd_opl3_synth_event_input(snd_seq_event_t * ev, int direct,
 
 static void snd_opl3_synth_free_port(void *private_data)
 {
-	opl3_t *opl3 = private_data;
+	struct snd_opl3 *opl3 = private_data;
 
 	snd_midi_channel_free_set(opl3->chset);
 }
 
-static int snd_opl3_synth_create_port(opl3_t * opl3)
+static int snd_opl3_synth_create_port(struct snd_opl3 * opl3)
 {
-	snd_seq_port_callback_t callbacks;
+	struct snd_seq_port_callback callbacks;
 	char name[32];
 	int voices, opl_ver;
 
@@ -215,15 +215,15 @@ static int snd_opl3_synth_create_port(opl3_t * opl3)
 
 /* ------------------------------ */
 
-static int snd_opl3_seq_new_device(snd_seq_device_t *dev)
+static int snd_opl3_seq_new_device(struct snd_seq_device *dev)
 {
-	opl3_t *opl3;
+	struct snd_opl3 *opl3;
 	int client;
-	snd_seq_client_callback_t callbacks;
-	snd_seq_client_info_t cinfo;
+	struct snd_seq_client_callback callbacks;
+	struct snd_seq_client_info cinfo;
 	int opl_ver;
 
-	opl3 = *(opl3_t **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
+	opl3 = *(struct snd_opl3 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
 	if (opl3 == NULL)
 		return -EINVAL;
 
@@ -273,11 +273,11 @@ static int snd_opl3_seq_new_device(snd_seq_device_t *dev)
 	return 0;
 }
 
-static int snd_opl3_seq_delete_device(snd_seq_device_t *dev)
+static int snd_opl3_seq_delete_device(struct snd_seq_device *dev)
 {
-	opl3_t *opl3;
+	struct snd_opl3 *opl3;
 
-	opl3 = *(opl3_t **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
+	opl3 = *(struct snd_opl3 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
 	if (opl3 == NULL)
 		return -EINVAL;
 
@@ -295,14 +295,14 @@ static int snd_opl3_seq_delete_device(snd_seq_device_t *dev)
 
 static int __init alsa_opl3_seq_init(void)
 {
-	static snd_seq_dev_ops_t ops =
+	static struct snd_seq_dev_ops ops =
 	{
 		snd_opl3_seq_new_device,
 		snd_opl3_seq_delete_device
 	};
 
 	return snd_seq_device_register_driver(SNDRV_SEQ_DEV_ID_OPL3, &ops,
-					      sizeof(opl3_t*));
+					      sizeof(struct snd_opl3 *));
 }
 
 static void __exit alsa_opl3_seq_exit(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/drivers/opl3/opl3_seq.c b/sound/drivers/opl3/opl3_seq.c
new file mode 100644
index 000000000000..136964b844de
--- /dev/null
+++ b/sound/drivers/opl3/opl3_seq.c
@@ -0,0 +1,314 @@
+/*
+ *  Copyright (c) by Uros Bizjak <uros@kss-loka.si>
+ *
+ *  Midi Sequencer interface routines for OPL2/OPL3/OPL4 FM
+ *
+ *  OPL2/3 FM instrument loader:
+ *   alsa-tools/seq/sbiload/
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include "opl3_voice.h"
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <sound/initval.h>
+
+MODULE_AUTHOR("Uros Bizjak <uros@kss-loka.si>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("ALSA driver for OPL3 FM synth");
+
+int use_internal_drums = 0;
+module_param(use_internal_drums, bool, 0444);
+MODULE_PARM_DESC(use_internal_drums, "Enable internal OPL2/3 drums.");
+
+int snd_opl3_synth_use_inc(opl3_t * opl3)
+{
+	if (!try_module_get(opl3->card->module))
+		return -EFAULT;
+	return 0;
+
+}
+
+void snd_opl3_synth_use_dec(opl3_t * opl3)
+{
+	module_put(opl3->card->module);
+}
+
+int snd_opl3_synth_setup(opl3_t * opl3)
+{
+	int idx;
+
+	down(&opl3->access_mutex);
+	if (opl3->used) {
+		up(&opl3->access_mutex);
+		return -EBUSY;
+	}
+	opl3->used++;
+	up(&opl3->access_mutex);
+
+	snd_opl3_reset(opl3);
+
+	for (idx = 0; idx < MAX_OPL3_VOICES; idx++) {
+		opl3->voices[idx].state = SNDRV_OPL3_ST_OFF;
+		opl3->voices[idx].time = 0;
+		opl3->voices[idx].keyon_reg = 0x00;
+	}
+	opl3->use_time = 0;
+	opl3->connection_reg = 0x00;
+	if (opl3->hardware >= OPL3_HW_OPL3) {
+		/* Clear 4-op connections */
+		opl3->command(opl3, OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT,
+				 opl3->connection_reg);
+		opl3->max_voices = MAX_OPL3_VOICES;
+	}
+	return 0;
+}
+
+void snd_opl3_synth_cleanup(opl3_t * opl3)
+{
+	unsigned long flags;
+
+	/* Stop system timer */
+	spin_lock_irqsave(&opl3->sys_timer_lock, flags);
+	if (opl3->sys_timer_status) {
+		del_timer(&opl3->tlist);
+		opl3->sys_timer_status = 0;
+	}
+	spin_unlock_irqrestore(&opl3->sys_timer_lock, flags);
+
+	snd_opl3_reset(opl3);
+	down(&opl3->access_mutex);
+	opl3->used--;
+	up(&opl3->access_mutex);
+}
+
+static int snd_opl3_synth_use(void *private_data, snd_seq_port_subscribe_t * info)
+{
+	opl3_t *opl3 = private_data;
+	int err;
+
+	if ((err = snd_opl3_synth_setup(opl3)) < 0)
+		return err;
+
+	if (use_internal_drums) {
+		/* Percussion mode */
+		opl3->voices[6].state = opl3->voices[7].state = 
+			opl3->voices[8].state = SNDRV_OPL3_ST_NOT_AVAIL;
+		snd_opl3_load_drums(opl3);
+		opl3->drum_reg = OPL3_PERCUSSION_ENABLE;
+		opl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION, opl3->drum_reg);
+	} else {
+		opl3->drum_reg = 0x00;
+	}
+
+	if (info->sender.client != SNDRV_SEQ_CLIENT_SYSTEM) {
+		if ((err = snd_opl3_synth_use_inc(opl3)) < 0)
+			return err;
+	}
+	opl3->synth_mode = SNDRV_OPL3_MODE_SEQ;
+	return 0;
+}
+
+static int snd_opl3_synth_unuse(void *private_data, snd_seq_port_subscribe_t * info)
+{
+	opl3_t *opl3 = private_data;
+
+	snd_opl3_synth_cleanup(opl3);
+
+	if (info->sender.client != SNDRV_SEQ_CLIENT_SYSTEM)
+		snd_opl3_synth_use_dec(opl3);
+	return 0;
+}
+
+/*
+ * MIDI emulation operators
+ */
+snd_midi_op_t opl3_ops = {
+	.note_on =		snd_opl3_note_on,
+	.note_off =		snd_opl3_note_off,
+	.key_press =		snd_opl3_key_press,
+	.note_terminate =	snd_opl3_terminate_note,
+	.control =		snd_opl3_control,
+	.nrpn =			snd_opl3_nrpn,
+	.sysex =		snd_opl3_sysex,
+};
+
+static int snd_opl3_synth_event_input(snd_seq_event_t * ev, int direct,
+				      void *private_data, int atomic, int hop)
+{
+	opl3_t *opl3 = private_data;
+
+	if (ev->type >= SNDRV_SEQ_EVENT_INSTR_BEGIN &&
+	    ev->type <= SNDRV_SEQ_EVENT_INSTR_CHANGE) {
+		if (direct) {
+			snd_seq_instr_event(&opl3->fm_ops, opl3->ilist, ev,
+					    opl3->seq_client, atomic, hop);
+		}
+	} else {
+		snd_midi_process_event(&opl3_ops, ev, opl3->chset);
+	}
+	return 0;
+}
+
+/* ------------------------------ */
+
+static void snd_opl3_synth_free_port(void *private_data)
+{
+	opl3_t *opl3 = private_data;
+
+	snd_midi_channel_free_set(opl3->chset);
+}
+
+static int snd_opl3_synth_create_port(opl3_t * opl3)
+{
+	snd_seq_port_callback_t callbacks;
+	char name[32];
+	int voices, opl_ver;
+
+	voices = (opl3->hardware < OPL3_HW_OPL3) ?
+		MAX_OPL2_VOICES : MAX_OPL3_VOICES;
+	opl3->chset = snd_midi_channel_alloc_set(16);
+	if (opl3->chset == NULL)
+		return -ENOMEM;
+	opl3->chset->private_data = opl3;
+
+	memset(&callbacks, 0, sizeof(callbacks));
+	callbacks.owner = THIS_MODULE;
+	callbacks.use = snd_opl3_synth_use;
+	callbacks.unuse = snd_opl3_synth_unuse;
+	callbacks.event_input = snd_opl3_synth_event_input;
+	callbacks.private_free = snd_opl3_synth_free_port;
+	callbacks.private_data = opl3;
+
+	opl_ver = (opl3->hardware & OPL3_HW_MASK) >> 8;
+	sprintf(name, "OPL%i FM Port", opl_ver);
+
+	opl3->chset->client = opl3->seq_client;
+	opl3->chset->port = snd_seq_event_port_attach(opl3->seq_client, &callbacks,
+						      SNDRV_SEQ_PORT_CAP_WRITE |
+						      SNDRV_SEQ_PORT_CAP_SUBS_WRITE,
+						      SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |
+						      SNDRV_SEQ_PORT_TYPE_MIDI_GM |
+						      SNDRV_SEQ_PORT_TYPE_SYNTH,
+						      16, voices,
+						      name);
+	if (opl3->chset->port < 0) {
+		snd_midi_channel_free_set(opl3->chset);
+		return opl3->chset->port;
+	}
+	return 0;
+}
+
+/* ------------------------------ */
+
+static int snd_opl3_seq_new_device(snd_seq_device_t *dev)
+{
+	opl3_t *opl3;
+	int client;
+	snd_seq_client_callback_t callbacks;
+	snd_seq_client_info_t cinfo;
+	int opl_ver;
+
+	opl3 = *(opl3_t **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
+	if (opl3 == NULL)
+		return -EINVAL;
+
+	spin_lock_init(&opl3->voice_lock);
+
+	opl3->seq_client = -1;
+
+	/* allocate new client */
+	memset(&callbacks, 0, sizeof(callbacks));
+	callbacks.private_data = opl3;
+	callbacks.allow_output = callbacks.allow_input = 1;
+	client = opl3->seq_client =
+	    snd_seq_create_kernel_client(opl3->card, opl3->seq_dev_num, &callbacks);
+	if (client < 0)
+		return client;
+
+	/* change name of client */
+	memset(&cinfo, 0, sizeof(cinfo));
+	cinfo.client = client;
+	cinfo.type = KERNEL_CLIENT;
+	opl_ver = (opl3->hardware & OPL3_HW_MASK) >> 8;
+	sprintf(cinfo.name, "OPL%i FM synth", opl_ver);
+	snd_seq_kernel_client_ctl(client, SNDRV_SEQ_IOCTL_SET_CLIENT_INFO, &cinfo);
+
+	snd_opl3_synth_create_port(opl3);
+
+	/* initialize instrument list */
+	opl3->ilist = snd_seq_instr_list_new();
+	if (opl3->ilist == NULL) {
+		snd_seq_delete_kernel_client(client);
+		opl3->seq_client = -1;
+		return -ENOMEM;
+	}
+	opl3->ilist->flags = SNDRV_SEQ_INSTR_FLG_DIRECT;
+	snd_seq_fm_init(&opl3->fm_ops, NULL);
+
+	/* setup system timer */
+	init_timer(&opl3->tlist);
+	opl3->tlist.function = snd_opl3_timer_func;
+	opl3->tlist.data = (unsigned long) opl3;
+	spin_lock_init(&opl3->sys_timer_lock);
+	opl3->sys_timer_status = 0;
+
+#ifdef CONFIG_SND_SEQUENCER_OSS
+	snd_opl3_init_seq_oss(opl3, cinfo.name);
+#endif
+	return 0;
+}
+
+static int snd_opl3_seq_delete_device(snd_seq_device_t *dev)
+{
+	opl3_t *opl3;
+
+	opl3 = *(opl3_t **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
+	if (opl3 == NULL)
+		return -EINVAL;
+
+#ifdef CONFIG_SND_SEQUENCER_OSS
+	snd_opl3_free_seq_oss(opl3);
+#endif
+	if (opl3->seq_client >= 0) {
+		snd_seq_delete_kernel_client(opl3->seq_client);
+		opl3->seq_client = -1;
+	}
+	if (opl3->ilist)
+		snd_seq_instr_list_free(&opl3->ilist);
+	return 0;
+}
+
+static int __init alsa_opl3_seq_init(void)
+{
+	static snd_seq_dev_ops_t ops =
+	{
+		snd_opl3_seq_new_device,
+		snd_opl3_seq_delete_device
+	};
+
+	return snd_seq_device_register_driver(SNDRV_SEQ_DEV_ID_OPL3, &ops,
+					      sizeof(opl3_t*));
+}
+
+static void __exit alsa_opl3_seq_exit(void)
+{
+	snd_seq_device_unregister_driver(SNDRV_SEQ_DEV_ID_OPL3);
+}
+
+module_init(alsa_opl3_seq_init)
+module_exit(alsa_opl3_seq_exit)
