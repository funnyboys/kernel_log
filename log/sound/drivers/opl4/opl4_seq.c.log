commit aad7ebb544072bcb9335fa4eb0fbd1b85a6c495b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:45 2020 +0100

    ALSA: seq: Constify struct snd_midi_op
    
    Change the argument of snd_midi_process_event() to receive a const
    snd_midi_op pointer and its callers respectively.  This allows further
    optimizations.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-30-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_seq.c b/sound/drivers/opl4/opl4_seq.c
index 03d6202f4829..f59ca660c616 100644
--- a/sound/drivers/opl4/opl4_seq.c
+++ b/sound/drivers/opl4/opl4_seq.c
@@ -100,7 +100,7 @@ static int snd_opl4_seq_unuse(void *private_data, struct snd_seq_port_subscribe
 	return 0;
 }
 
-static struct snd_midi_op opl4_ops = {
+static const struct snd_midi_op opl4_ops = {
 	.note_on =		snd_opl4_note_on,
 	.note_off =		snd_opl4_note_off,
 	.note_terminate =	snd_opl4_terminate_note,

commit 056622053b8ae02978678ac1321b5bd956e7c812
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 12 13:43:22 2015 +0100

    ALSA: seq: Define driver object in each driver
    
    This patch moves the driver object initialization and allocation to
    each driver's module init/exit code like other normal drivers.  The
    snd_seq_driver struct is now published in seq_device.h, and each
    driver is responsible to define it with proper driver attributes
    (name, probe and remove) with snd_seq_driver specific attributes as id
    and argsize fields.  The helper functions snd_seq_driver_register(),
    snd_seq_driver_unregister() and module_snd_seq_driver() are used for
    simplifying codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_seq.c b/sound/drivers/opl4/opl4_seq.c
index 99197699c55a..03d6202f4829 100644
--- a/sound/drivers/opl4/opl4_seq.c
+++ b/sound/drivers/opl4/opl4_seq.c
@@ -124,8 +124,9 @@ static void snd_opl4_seq_free_port(void *private_data)
 	snd_midi_channel_free_set(opl4->chset);
 }
 
-static int snd_opl4_seq_new_device(struct snd_seq_device *dev)
+static int snd_opl4_seq_probe(struct device *_dev)
 {
+	struct snd_seq_device *dev = to_seq_dev(_dev);
 	struct snd_opl4 *opl4;
 	int client;
 	struct snd_seq_port_callback pcallbacks;
@@ -180,8 +181,9 @@ static int snd_opl4_seq_new_device(struct snd_seq_device *dev)
 	return 0;
 }
 
-static int snd_opl4_seq_delete_device(struct snd_seq_device *dev)
+static int snd_opl4_seq_remove(struct device *_dev)
 {
+	struct snd_seq_device *dev = to_seq_dev(_dev);
 	struct snd_opl4 *opl4;
 
 	opl4 = *(struct snd_opl4 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
@@ -195,21 +197,14 @@ static int snd_opl4_seq_delete_device(struct snd_seq_device *dev)
 	return 0;
 }
 
-static int __init alsa_opl4_synth_init(void)
-{
-	static struct snd_seq_dev_ops ops = {
-		snd_opl4_seq_new_device,
-		snd_opl4_seq_delete_device
-	};
-
-	return snd_seq_device_register_driver(SNDRV_SEQ_DEV_ID_OPL4, &ops,
-					      sizeof(struct snd_opl4 *));
-}
-
-static void __exit alsa_opl4_synth_exit(void)
-{
-	snd_seq_device_unregister_driver(SNDRV_SEQ_DEV_ID_OPL4);
-}
+static struct snd_seq_driver opl4_seq_driver = {
+	.driver = {
+		.name = KBUILD_MODNAME,
+		.probe = snd_opl4_seq_probe,
+		.remove = snd_opl4_seq_remove,
+	},
+	.id = SNDRV_SEQ_DEV_ID_OPL4,
+	.argsize = sizeof(struct snd_opl4 *),
+};
 
-module_init(alsa_opl4_synth_init)
-module_exit(alsa_opl4_synth_exit)
+module_snd_seq_driver(opl4_seq_driver);

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/drivers/opl4/opl4_seq.c b/sound/drivers/opl4/opl4_seq.c
index 43d8a2bdd280..99197699c55a 100644
--- a/sound/drivers/opl4/opl4_seq.c
+++ b/sound/drivers/opl4/opl4_seq.c
@@ -34,6 +34,7 @@
 #include "opl4_local.h"
 #include <linux/init.h>
 #include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <sound/initval.h>
 
 MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");

commit 450047a78f3c35a905576e121abfbee2ccd45993
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue May 2 16:08:41 2006 +0200

    [ALSA] add more sequencer port type information bits
    
    Add four new information flags SNDRV_SEQ_PORT_TYPE_HARDWARE, _SOFTWARE,
    _SYNTHESIZER, _PORT for sequencer ports.  This makes it easier for apps
    like Rosegarden to make policy decisions based on the port type.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/drivers/opl4/opl4_seq.c b/sound/drivers/opl4/opl4_seq.c
index dc0dcdc6c313..43d8a2bdd280 100644
--- a/sound/drivers/opl4/opl4_seq.c
+++ b/sound/drivers/opl4/opl4_seq.c
@@ -164,7 +164,9 @@ static int snd_opl4_seq_new_device(struct snd_seq_device *dev)
 						      SNDRV_SEQ_PORT_CAP_WRITE |
 						      SNDRV_SEQ_PORT_CAP_SUBS_WRITE,
 						      SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |
-						      SNDRV_SEQ_PORT_TYPE_MIDI_GM,
+						      SNDRV_SEQ_PORT_TYPE_MIDI_GM |
+						      SNDRV_SEQ_PORT_TYPE_HARDWARE |
+						      SNDRV_SEQ_PORT_TYPE_SYNTHESIZER,
 						      16, 24,
 						      "OPL4 Wavetable Port");
 	if (opl4->chset->port < 0) {

commit ef9f0a42db987e7e2df72289fb4522d24027786b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:31:42 2006 +0100

    [ALSA] semaphore -> mutex (driver part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_seq.c b/sound/drivers/opl4/opl4_seq.c
index e3480326e735..dc0dcdc6c313 100644
--- a/sound/drivers/opl4/opl4_seq.c
+++ b/sound/drivers/opl4/opl4_seq.c
@@ -62,10 +62,10 @@ static int snd_opl4_seq_use(void *private_data, struct snd_seq_port_subscribe *i
 	struct snd_opl4 *opl4 = private_data;
 	int err;
 
-	down(&opl4->access_mutex);
+	mutex_lock(&opl4->access_mutex);
 
 	if (opl4->used) {
-		up(&opl4->access_mutex);
+		mutex_unlock(&opl4->access_mutex);
 		return -EBUSY;
 	}
 	opl4->used++;
@@ -73,12 +73,12 @@ static int snd_opl4_seq_use(void *private_data, struct snd_seq_port_subscribe *i
 	if (info->sender.client != SNDRV_SEQ_CLIENT_SYSTEM) {
 		err = snd_opl4_seq_use_inc(opl4);
 		if (err < 0) {
-			up(&opl4->access_mutex);
+			mutex_unlock(&opl4->access_mutex);
 			return err;
 		}
 	}
 
-	up(&opl4->access_mutex);
+	mutex_unlock(&opl4->access_mutex);
 
 	snd_opl4_synth_reset(opl4);
 	return 0;
@@ -90,9 +90,9 @@ static int snd_opl4_seq_unuse(void *private_data, struct snd_seq_port_subscribe
 
 	snd_opl4_synth_shutdown(opl4);
 
-	down(&opl4->access_mutex);
+	mutex_lock(&opl4->access_mutex);
 	opl4->used--;
-	up(&opl4->access_mutex);
+	mutex_unlock(&opl4->access_mutex);
 
 	if (info->sender.client != SNDRV_SEQ_CLIENT_SYSTEM)
 		snd_opl4_seq_use_dec(opl4);

commit 7b6d92451ad5e1136dc347347e888b94638b8ba9
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Dec 12 09:33:37 2005 +0100

    [ALSA] seq: set client name in snd_seq_create_kernel_client()
    
    All users of snd_seq_create_kernel_client() have to set the client name
    anyway, so we can just pass the name as parameter.  This relieves us
    from having to muck around with a struct snd_seq_client_info in these
    cases.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/drivers/opl4/opl4_seq.c b/sound/drivers/opl4/opl4_seq.c
index a69117dd0071..e3480326e735 100644
--- a/sound/drivers/opl4/opl4_seq.c
+++ b/sound/drivers/opl4/opl4_seq.c
@@ -127,7 +127,6 @@ static int snd_opl4_seq_new_device(struct snd_seq_device *dev)
 {
 	struct snd_opl4 *opl4;
 	int client;
-	struct snd_seq_client_info cinfo;
 	struct snd_seq_port_callback pcallbacks;
 
 	opl4 = *(struct snd_opl4 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
@@ -143,7 +142,8 @@ static int snd_opl4_seq_new_device(struct snd_seq_device *dev)
 	opl4->chset->private_data = opl4;
 
 	/* allocate new client */
-	client = snd_seq_create_kernel_client(opl4->card, opl4->seq_dev_num);
+	client = snd_seq_create_kernel_client(opl4->card, opl4->seq_dev_num,
+					      "OPL4 Wavetable");
 	if (client < 0) {
 		snd_midi_channel_free_set(opl4->chset);
 		return client;
@@ -151,13 +151,6 @@ static int snd_opl4_seq_new_device(struct snd_seq_device *dev)
 	opl4->seq_client = client;
 	opl4->chset->client = client;
 
-	/* change name of client */
-	memset(&cinfo, 0, sizeof(cinfo));
-	cinfo.client = client;
-	cinfo.type = KERNEL_CLIENT;
-	strcpy(cinfo.name, "OPL4 Wavetable");
-	snd_seq_kernel_client_ctl(client, SNDRV_SEQ_IOCTL_SET_CLIENT_INFO, &cinfo);
-
 	/* create new port */
 	memset(&pcallbacks, 0, sizeof(pcallbacks));
 	pcallbacks.owner = THIS_MODULE;

commit 83e8ad6984dccd6d848ac91ba0df379ff968180b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Dec 12 09:30:43 2005 +0100

    [ALSA] seq: remove struct snd_seq_client_callback
    
    The fields of struct snd_seq_client_callback either aren't used or are
    always set to the same value, so we can get rid of it altogether.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/drivers/opl4/opl4_seq.c b/sound/drivers/opl4/opl4_seq.c
index bfd68e49c914..a69117dd0071 100644
--- a/sound/drivers/opl4/opl4_seq.c
+++ b/sound/drivers/opl4/opl4_seq.c
@@ -127,7 +127,6 @@ static int snd_opl4_seq_new_device(struct snd_seq_device *dev)
 {
 	struct snd_opl4 *opl4;
 	int client;
-	struct snd_seq_client_callback callbacks;
 	struct snd_seq_client_info cinfo;
 	struct snd_seq_port_callback pcallbacks;
 
@@ -144,10 +143,7 @@ static int snd_opl4_seq_new_device(struct snd_seq_device *dev)
 	opl4->chset->private_data = opl4;
 
 	/* allocate new client */
-	memset(&callbacks, 0, sizeof(callbacks));
-	callbacks.private_data = opl4;
-	callbacks.allow_output = callbacks.allow_input = 1;
-	client = snd_seq_create_kernel_client(opl4->card, opl4->seq_dev_num, &callbacks);
+	client = snd_seq_create_kernel_client(opl4->card, opl4->seq_dev_num);
 	if (client < 0) {
 		snd_midi_channel_free_set(opl4->chset);
 		return client;

commit a42dd420bea7a5cd130162183d95f640c299a337
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:13:47 2005 +0100

    [ALSA] Remove xxx_t typedefs: OPL4
    
    Modules: OPL4
    
    Remove xxx_t typedefs from the OPL4 driver
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_seq.c b/sound/drivers/opl4/opl4_seq.c
index 958dfe88479a..bfd68e49c914 100644
--- a/sound/drivers/opl4/opl4_seq.c
+++ b/sound/drivers/opl4/opl4_seq.c
@@ -45,21 +45,21 @@ int volume_boost = 8;
 module_param(volume_boost, int, 0644);
 MODULE_PARM_DESC(volume_boost, "Additional volume for OPL4 wavetable sounds.");
 
-static int snd_opl4_seq_use_inc(opl4_t *opl4)
+static int snd_opl4_seq_use_inc(struct snd_opl4 *opl4)
 {
 	if (!try_module_get(opl4->card->module))
 		return -EFAULT;
 	return 0;
 }
 
-static void snd_opl4_seq_use_dec(opl4_t *opl4)
+static void snd_opl4_seq_use_dec(struct snd_opl4 *opl4)
 {
 	module_put(opl4->card->module);
 }
 
-static int snd_opl4_seq_use(void *private_data, snd_seq_port_subscribe_t *info)
+static int snd_opl4_seq_use(void *private_data, struct snd_seq_port_subscribe *info)
 {
-	opl4_t *opl4 = private_data;
+	struct snd_opl4 *opl4 = private_data;
 	int err;
 
 	down(&opl4->access_mutex);
@@ -84,9 +84,9 @@ static int snd_opl4_seq_use(void *private_data, snd_seq_port_subscribe_t *info)
 	return 0;
 }
 
-static int snd_opl4_seq_unuse(void *private_data, snd_seq_port_subscribe_t *info)
+static int snd_opl4_seq_unuse(void *private_data, struct snd_seq_port_subscribe *info)
 {
-	opl4_t *opl4 = private_data;
+	struct snd_opl4 *opl4 = private_data;
 
 	snd_opl4_synth_shutdown(opl4);
 
@@ -99,7 +99,7 @@ static int snd_opl4_seq_unuse(void *private_data, snd_seq_port_subscribe_t *info
 	return 0;
 }
 
-static snd_midi_op_t opl4_ops = {
+static struct snd_midi_op opl4_ops = {
 	.note_on =		snd_opl4_note_on,
 	.note_off =		snd_opl4_note_off,
 	.note_terminate =	snd_opl4_terminate_note,
@@ -107,10 +107,10 @@ static snd_midi_op_t opl4_ops = {
 	.sysex =		snd_opl4_sysex,
 };
 
-static int snd_opl4_seq_event_input(snd_seq_event_t *ev, int direct,
+static int snd_opl4_seq_event_input(struct snd_seq_event *ev, int direct,
 				    void *private_data, int atomic, int hop)
 {
-	opl4_t *opl4 = private_data;
+	struct snd_opl4 *opl4 = private_data;
 
 	snd_midi_process_event(&opl4_ops, ev, opl4->chset);
 	return 0;
@@ -118,20 +118,20 @@ static int snd_opl4_seq_event_input(snd_seq_event_t *ev, int direct,
 
 static void snd_opl4_seq_free_port(void *private_data)
 {
-	opl4_t *opl4 = private_data;
+	struct snd_opl4 *opl4 = private_data;
 
 	snd_midi_channel_free_set(opl4->chset);
 }
 
-static int snd_opl4_seq_new_device(snd_seq_device_t *dev)
+static int snd_opl4_seq_new_device(struct snd_seq_device *dev)
 {
-	opl4_t *opl4;
+	struct snd_opl4 *opl4;
 	int client;
-	snd_seq_client_callback_t callbacks;
-	snd_seq_client_info_t cinfo;
-	snd_seq_port_callback_t pcallbacks;
+	struct snd_seq_client_callback callbacks;
+	struct snd_seq_client_info cinfo;
+	struct snd_seq_port_callback pcallbacks;
 
-	opl4 = *(opl4_t **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
+	opl4 = *(struct snd_opl4 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
 	if (!opl4)
 		return -EINVAL;
 
@@ -188,11 +188,11 @@ static int snd_opl4_seq_new_device(snd_seq_device_t *dev)
 	return 0;
 }
 
-static int snd_opl4_seq_delete_device(snd_seq_device_t *dev)
+static int snd_opl4_seq_delete_device(struct snd_seq_device *dev)
 {
-	opl4_t *opl4;
+	struct snd_opl4 *opl4;
 
-	opl4 = *(opl4_t **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
+	opl4 = *(struct snd_opl4 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
 	if (!opl4)
 		return -EINVAL;
 
@@ -205,13 +205,13 @@ static int snd_opl4_seq_delete_device(snd_seq_device_t *dev)
 
 static int __init alsa_opl4_synth_init(void)
 {
-	static snd_seq_dev_ops_t ops = {
+	static struct snd_seq_dev_ops ops = {
 		snd_opl4_seq_new_device,
 		snd_opl4_seq_delete_device
 	};
 
 	return snd_seq_device_register_driver(SNDRV_SEQ_DEV_ID_OPL4, &ops,
-					      sizeof(opl4_t*));
+					      sizeof(struct snd_opl4 *));
 }
 
 static void __exit alsa_opl4_synth_exit(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/drivers/opl4/opl4_seq.c b/sound/drivers/opl4/opl4_seq.c
new file mode 100644
index 000000000000..958dfe88479a
--- /dev/null
+++ b/sound/drivers/opl4/opl4_seq.c
@@ -0,0 +1,223 @@
+/*
+ * OPL4 sequencer functions
+ *
+ * Copyright (c) 2003 by Clemens Ladisch <clemens@ladisch.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed and/or modified under the
+ * terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include "opl4_local.h"
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <sound/initval.h>
+
+MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
+MODULE_DESCRIPTION("OPL4 wavetable synth driver");
+MODULE_LICENSE("Dual BSD/GPL");
+
+int volume_boost = 8;
+
+module_param(volume_boost, int, 0644);
+MODULE_PARM_DESC(volume_boost, "Additional volume for OPL4 wavetable sounds.");
+
+static int snd_opl4_seq_use_inc(opl4_t *opl4)
+{
+	if (!try_module_get(opl4->card->module))
+		return -EFAULT;
+	return 0;
+}
+
+static void snd_opl4_seq_use_dec(opl4_t *opl4)
+{
+	module_put(opl4->card->module);
+}
+
+static int snd_opl4_seq_use(void *private_data, snd_seq_port_subscribe_t *info)
+{
+	opl4_t *opl4 = private_data;
+	int err;
+
+	down(&opl4->access_mutex);
+
+	if (opl4->used) {
+		up(&opl4->access_mutex);
+		return -EBUSY;
+	}
+	opl4->used++;
+
+	if (info->sender.client != SNDRV_SEQ_CLIENT_SYSTEM) {
+		err = snd_opl4_seq_use_inc(opl4);
+		if (err < 0) {
+			up(&opl4->access_mutex);
+			return err;
+		}
+	}
+
+	up(&opl4->access_mutex);
+
+	snd_opl4_synth_reset(opl4);
+	return 0;
+}
+
+static int snd_opl4_seq_unuse(void *private_data, snd_seq_port_subscribe_t *info)
+{
+	opl4_t *opl4 = private_data;
+
+	snd_opl4_synth_shutdown(opl4);
+
+	down(&opl4->access_mutex);
+	opl4->used--;
+	up(&opl4->access_mutex);
+
+	if (info->sender.client != SNDRV_SEQ_CLIENT_SYSTEM)
+		snd_opl4_seq_use_dec(opl4);
+	return 0;
+}
+
+static snd_midi_op_t opl4_ops = {
+	.note_on =		snd_opl4_note_on,
+	.note_off =		snd_opl4_note_off,
+	.note_terminate =	snd_opl4_terminate_note,
+	.control =		snd_opl4_control,
+	.sysex =		snd_opl4_sysex,
+};
+
+static int snd_opl4_seq_event_input(snd_seq_event_t *ev, int direct,
+				    void *private_data, int atomic, int hop)
+{
+	opl4_t *opl4 = private_data;
+
+	snd_midi_process_event(&opl4_ops, ev, opl4->chset);
+	return 0;
+}
+
+static void snd_opl4_seq_free_port(void *private_data)
+{
+	opl4_t *opl4 = private_data;
+
+	snd_midi_channel_free_set(opl4->chset);
+}
+
+static int snd_opl4_seq_new_device(snd_seq_device_t *dev)
+{
+	opl4_t *opl4;
+	int client;
+	snd_seq_client_callback_t callbacks;
+	snd_seq_client_info_t cinfo;
+	snd_seq_port_callback_t pcallbacks;
+
+	opl4 = *(opl4_t **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
+	if (!opl4)
+		return -EINVAL;
+
+	if (snd_yrw801_detect(opl4) < 0)
+		return -ENODEV;
+
+	opl4->chset = snd_midi_channel_alloc_set(16);
+	if (!opl4->chset)
+		return -ENOMEM;
+	opl4->chset->private_data = opl4;
+
+	/* allocate new client */
+	memset(&callbacks, 0, sizeof(callbacks));
+	callbacks.private_data = opl4;
+	callbacks.allow_output = callbacks.allow_input = 1;
+	client = snd_seq_create_kernel_client(opl4->card, opl4->seq_dev_num, &callbacks);
+	if (client < 0) {
+		snd_midi_channel_free_set(opl4->chset);
+		return client;
+	}
+	opl4->seq_client = client;
+	opl4->chset->client = client;
+
+	/* change name of client */
+	memset(&cinfo, 0, sizeof(cinfo));
+	cinfo.client = client;
+	cinfo.type = KERNEL_CLIENT;
+	strcpy(cinfo.name, "OPL4 Wavetable");
+	snd_seq_kernel_client_ctl(client, SNDRV_SEQ_IOCTL_SET_CLIENT_INFO, &cinfo);
+
+	/* create new port */
+	memset(&pcallbacks, 0, sizeof(pcallbacks));
+	pcallbacks.owner = THIS_MODULE;
+	pcallbacks.use = snd_opl4_seq_use;
+	pcallbacks.unuse = snd_opl4_seq_unuse;
+	pcallbacks.event_input = snd_opl4_seq_event_input;
+	pcallbacks.private_free = snd_opl4_seq_free_port;
+	pcallbacks.private_data = opl4;
+
+	opl4->chset->port = snd_seq_event_port_attach(client, &pcallbacks,
+						      SNDRV_SEQ_PORT_CAP_WRITE |
+						      SNDRV_SEQ_PORT_CAP_SUBS_WRITE,
+						      SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |
+						      SNDRV_SEQ_PORT_TYPE_MIDI_GM,
+						      16, 24,
+						      "OPL4 Wavetable Port");
+	if (opl4->chset->port < 0) {
+		int err = opl4->chset->port;
+		snd_midi_channel_free_set(opl4->chset);
+		snd_seq_delete_kernel_client(client);
+		opl4->seq_client = -1;
+		return err;
+	}
+	return 0;
+}
+
+static int snd_opl4_seq_delete_device(snd_seq_device_t *dev)
+{
+	opl4_t *opl4;
+
+	opl4 = *(opl4_t **)SNDRV_SEQ_DEVICE_ARGPTR(dev);
+	if (!opl4)
+		return -EINVAL;
+
+	if (opl4->seq_client >= 0) {
+		snd_seq_delete_kernel_client(opl4->seq_client);
+		opl4->seq_client = -1;
+	}
+	return 0;
+}
+
+static int __init alsa_opl4_synth_init(void)
+{
+	static snd_seq_dev_ops_t ops = {
+		snd_opl4_seq_new_device,
+		snd_opl4_seq_delete_device
+	};
+
+	return snd_seq_device_register_driver(SNDRV_SEQ_DEV_ID_OPL4, &ops,
+					      sizeof(opl4_t*));
+}
+
+static void __exit alsa_opl4_synth_exit(void)
+{
+	snd_seq_device_unregister_driver(SNDRV_SEQ_DEV_ID_OPL4);
+}
+
+module_init(alsa_opl4_synth_init)
+module_exit(alsa_opl4_synth_exit)
