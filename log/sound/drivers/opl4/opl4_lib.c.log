commit 34273b234c0712c963f02845919125686f503d3e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:21 2020 +0100

    ALSA: drivers: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-6-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index 901d339703a9..035645eb5e8d 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -184,7 +184,7 @@ int snd_opl4_create(struct snd_card *card,
 	struct snd_opl4 *opl4;
 	struct snd_opl3 *opl3;
 	int err;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free = snd_opl4_dev_free
 	};
 

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index 819d2dce2a19..901d339703a9 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -1,20 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Functions for accessing OPL4 devices
  * Copyright (c) 2003 by Clemens Ladisch <clemens@ladisch.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include "opl4_local.h"

commit 969686ee0e0ff62ece428e8e02b07f81ac88a84d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 3 15:42:46 2018 +0200

    ALSA: drivers: Remove empty init and exit
    
    For a sake of code simplification, remove the init and the exit
    entries that do nothing.
    
    Notes for readers: actually it's OK to remove *both* init and exit,
    but not OK to remove the exit entry.  By removing only the exit while
    keeping init, the module becomes permanently loaded; i.e. you cannot
    unload it any longer!
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index db76a5bf2bd2..819d2dce2a19 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -263,15 +263,3 @@ int snd_opl4_create(struct snd_card *card,
 }
 
 EXPORT_SYMBOL(snd_opl4_create);
-
-static int __init alsa_opl4_init(void)
-{
-	return 0;
-}
-
-static void __exit alsa_opl4_exit(void)
-{
-}
-
-module_init(alsa_opl4_init)
-module_exit(alsa_opl4_exit)

commit 6ede2b7df92f4f8da1abfa831a038688fcf409ea
Author: Joe Perches <joe@perches.com>
Date:   Wed Jul 5 13:02:27 2017 -0700

    ALSA: opl4: Move inline before return type
    
    Make the code like the rest of the kernel.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index bc345d564f8d..db76a5bf2bd2 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -29,7 +29,7 @@ MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
 MODULE_DESCRIPTION("OPL4 driver");
 MODULE_LICENSE("GPL");
 
-static void inline snd_opl4_wait(struct snd_opl4 *opl4)
+static inline void snd_opl4_wait(struct snd_opl4 *opl4)
 {
 	int timeout = 10;
 	while ((inb(opl4->fm_port) & OPL4_STATUS_BUSY) && --timeout > 0)

commit 111b0cdb97d44cfe5dec1338a78ba8aff65c32e2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 9 15:11:58 2017 +0200

    ALSA: seq: Allow the modular sequencer registration
    
    Many drivers bind the sequencer stuff in off-load by another driver
    module, so that it's loaded only on demand.  In the current code, this
    mechanism doesn't work when the driver is built-in while the sequencer
    is module.  We check with IS_REACHABLE() and enable only when the
    sequencer is in the same level of build.
    
    However, this is basically a overshoot.  The binder code
    (snd-seq-device) is an individual module from the sequencer core
    (snd-seq), and we just have to make the former a built-in while
    keeping the latter a module for allowing the scenario like the above.
    
    This patch achieves that by rewriting Kconfig slightly.  Now, a driver
    that provides the manual sequencer device binding should select
    CONFIG_SND_SEQ_DEVICE in a way as
            select SND_SEQ_DEVICE if SND_SEQUENCER != n
    
    Note that the "!=n" is needed here to avoid the influence of the
    sequencer core is module while the driver is built-in.
    
    Also, since rawmidi.o may be linked with snd_seq_device.o when
    built-in, we have to shuffle the code to make the linker happy.
    (the kernel linker isn't smart enough yet to handle such a case.)
    That is, snd_seq_device.c is moved to sound/core from sound/core/seq,
    as well as Makefile.
    
    Last but not least, the patch replaces the code using IS_REACHABLE()
    with IS_ENABLED(), since now the condition meets always when enabled.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index 240656e54400..bc345d564f8d 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -153,7 +153,7 @@ static int snd_opl4_detect(struct snd_opl4 *opl4)
 	return 0;
 }
 
-#if IS_REACHABLE(CONFIG_SND_SEQUENCER)
+#if IS_ENABLED(CONFIG_SND_SEQUENCER)
 static void snd_opl4_seq_dev_free(struct snd_seq_device *seq_dev)
 {
 	struct snd_opl4 *opl4 = seq_dev->private_data;
@@ -249,7 +249,7 @@ int snd_opl4_create(struct snd_card *card,
 	snd_opl4_create_mixer(opl4);
 	snd_opl4_create_proc(opl4);
 
-#if IS_REACHABLE(CONFIG_SND_SEQUENCER)
+#if IS_ENABLED(CONFIG_SND_SEQUENCER)
 	opl4->seq_client = -1;
 	if (opl4->hardware < OPL3_HW_OPL4_ML)
 		snd_opl4_create_seq_dev(opl4, seq_device);

commit 2e2d4cb450e951b90629b3f988c48ed01c69c1ac
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 12 11:52:06 2017 +0200

    ALSA: opl4: Use IS_REACHABLE()
    
    Rewrite the complex ifdef condition with IS_REACHABLE().
    The ifdef in opl4_local.h was without defined(MODLE) check, but this
    is likely the oversight.  Use IS_REACHABLE() here as well.
    
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index 89c7aa04b3bc..240656e54400 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -153,7 +153,7 @@ static int snd_opl4_detect(struct snd_opl4 *opl4)
 	return 0;
 }
 
-#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
+#if IS_REACHABLE(CONFIG_SND_SEQUENCER)
 static void snd_opl4_seq_dev_free(struct snd_seq_device *seq_dev)
 {
 	struct snd_opl4 *opl4 = seq_dev->private_data;
@@ -249,7 +249,7 @@ int snd_opl4_create(struct snd_card *card,
 	snd_opl4_create_mixer(opl4);
 	snd_opl4_create_proc(opl4);
 
-#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
+#if IS_REACHABLE(CONFIG_SND_SEQUENCER)
 	opl4->seq_client = -1;
 	if (opl4->hardware < OPL3_HW_OPL4_ML)
 		snd_opl4_create_seq_dev(opl4, seq_device);

commit c43a55d5b1c51436730e2f769f1b90add800a6f1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 29 07:49:55 2015 +0200

    ALSA: opl4: Fix / cleanup ifdef CONFIG_PROC_FS
    
    Some are replaced with the new ifdef CONFIG_SND_PROC_FS.  Some are
    removed by building opl4_proc.o conditionally.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index 3b0ee42a5343..89c7aa04b3bc 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -176,9 +176,7 @@ static int snd_opl4_create_seq_dev(struct snd_opl4 *opl4, int seq_device)
 
 static void snd_opl4_free(struct snd_opl4 *opl4)
 {
-#ifdef CONFIG_PROC_FS
 	snd_opl4_free_proc(opl4);
-#endif
 	release_and_free_resource(opl4->res_fm_port);
 	release_and_free_resource(opl4->res_pcm_port);
 	kfree(opl4);
@@ -249,9 +247,7 @@ int snd_opl4_create(struct snd_card *card,
 	snd_opl4_enable_opl4(opl4);
 
 	snd_opl4_create_mixer(opl4);
-#ifdef CONFIG_PROC_FS
 	snd_opl4_create_proc(opl4);
-#endif
 
 #if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
 	opl4->seq_client = -1;

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index b953fb4aa298..3b0ee42a5343 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -23,7 +23,7 @@
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/module.h>
-#include <asm/io.h>
+#include <linux/io.h>
 
 MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
 MODULE_DESCRIPTION("OPL4 driver");

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index f07e38da59b8..b953fb4aa298 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -22,6 +22,7 @@
 #include <linux/ioport.h>
 #include <linux/slab.h>
 #include <linux/init.h>
+#include <linux/module.h>
 #include <asm/io.h>
 
 MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index 01997f24c895..f07e38da59b8 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -20,6 +20,7 @@
 #include "opl4_local.h"
 #include <sound/initval.h>
 #include <linux/ioport.h>
+#include <linux/slab.h>
 #include <linux/init.h>
 #include <asm/io.h>
 

commit 4181e5fe4b27b0a049402a359a4a5d8b80308528
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:39 2006 +0200

    [ALSA] opl4 - Move EXPORT_SYMBOL() to adjacent to each function
    
    Move EXPORT_SYMBOL() to adjacent to each exported function/variable.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index 4bc860ae02de..01997f24c895 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -43,6 +43,8 @@ void snd_opl4_write(struct snd_opl4 *opl4, u8 reg, u8 value)
 	outb(value, opl4->pcm_port + 1);
 }
 
+EXPORT_SYMBOL(snd_opl4_write);
+
 u8 snd_opl4_read(struct snd_opl4 *opl4, u8 reg)
 {
 	snd_opl4_wait(opl4);
@@ -52,6 +54,8 @@ u8 snd_opl4_read(struct snd_opl4 *opl4, u8 reg)
 	return inb(opl4->pcm_port + 1);
 }
 
+EXPORT_SYMBOL(snd_opl4_read);
+
 void snd_opl4_read_memory(struct snd_opl4 *opl4, char *buf, int offset, int size)
 {
 	unsigned long flags;
@@ -76,6 +80,8 @@ void snd_opl4_read_memory(struct snd_opl4 *opl4, char *buf, int offset, int size
 	spin_unlock_irqrestore(&opl4->reg_lock, flags);
 }
 
+EXPORT_SYMBOL(snd_opl4_read_memory);
+
 void snd_opl4_write_memory(struct snd_opl4 *opl4, const char *buf, int offset, int size)
 {
 	unsigned long flags;
@@ -100,6 +106,8 @@ void snd_opl4_write_memory(struct snd_opl4 *opl4, const char *buf, int offset, i
 	spin_unlock_irqrestore(&opl4->reg_lock, flags);
 }
 
+EXPORT_SYMBOL(snd_opl4_write_memory);
+
 static void snd_opl4_enable_opl4(struct snd_opl4 *opl4)
 {
 	outb(OPL3_REG_MODE, opl4->fm_port + 2);
@@ -256,10 +264,6 @@ int snd_opl4_create(struct snd_card *card,
 	return 0;
 }
 
-EXPORT_SYMBOL(snd_opl4_write);
-EXPORT_SYMBOL(snd_opl4_read);
-EXPORT_SYMBOL(snd_opl4_write_memory);
-EXPORT_SYMBOL(snd_opl4_read_memory);
 EXPORT_SYMBOL(snd_opl4_create);
 
 static int __init alsa_opl4_init(void)

commit ef9f0a42db987e7e2df72289fb4522d24027786b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:31:42 2006 +0100

    [ALSA] semaphore -> mutex (driver part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index ddfc10d04be2..4bc860ae02de 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -214,7 +214,7 @@ int snd_opl4_create(struct snd_card *card,
 	opl4->fm_port = fm_port;
 	opl4->pcm_port = pcm_port;
 	spin_lock_init(&opl4->reg_lock);
-	init_MUTEX(&opl4->access_mutex);
+	mutex_init(&opl4->access_mutex);
 
 	err = snd_opl4_detect(opl4);
 	if (err < 0) {

commit a42dd420bea7a5cd130162183d95f640c299a337
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:13:47 2005 +0100

    [ALSA] Remove xxx_t typedefs: OPL4
    
    Modules: OPL4
    
    Remove xxx_t typedefs from the OPL4 driver
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index 4ae5dd8f011e..ddfc10d04be2 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -27,14 +27,14 @@ MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
 MODULE_DESCRIPTION("OPL4 driver");
 MODULE_LICENSE("GPL");
 
-static void inline snd_opl4_wait(opl4_t *opl4)
+static void inline snd_opl4_wait(struct snd_opl4 *opl4)
 {
 	int timeout = 10;
 	while ((inb(opl4->fm_port) & OPL4_STATUS_BUSY) && --timeout > 0)
 		;
 }
 
-void snd_opl4_write(opl4_t *opl4, u8 reg, u8 value)
+void snd_opl4_write(struct snd_opl4 *opl4, u8 reg, u8 value)
 {
 	snd_opl4_wait(opl4);
 	outb(reg, opl4->pcm_port);
@@ -43,7 +43,7 @@ void snd_opl4_write(opl4_t *opl4, u8 reg, u8 value)
 	outb(value, opl4->pcm_port + 1);
 }
 
-u8 snd_opl4_read(opl4_t *opl4, u8 reg)
+u8 snd_opl4_read(struct snd_opl4 *opl4, u8 reg)
 {
 	snd_opl4_wait(opl4);
 	outb(reg, opl4->pcm_port);
@@ -52,7 +52,7 @@ u8 snd_opl4_read(opl4_t *opl4, u8 reg)
 	return inb(opl4->pcm_port + 1);
 }
 
-void snd_opl4_read_memory(opl4_t *opl4, char *buf, int offset, int size)
+void snd_opl4_read_memory(struct snd_opl4 *opl4, char *buf, int offset, int size)
 {
 	unsigned long flags;
 	u8 memcfg;
@@ -76,7 +76,7 @@ void snd_opl4_read_memory(opl4_t *opl4, char *buf, int offset, int size)
 	spin_unlock_irqrestore(&opl4->reg_lock, flags);
 }
 
-void snd_opl4_write_memory(opl4_t *opl4, const char *buf, int offset, int size)
+void snd_opl4_write_memory(struct snd_opl4 *opl4, const char *buf, int offset, int size)
 {
 	unsigned long flags;
 	u8 memcfg;
@@ -100,7 +100,7 @@ void snd_opl4_write_memory(opl4_t *opl4, const char *buf, int offset, int size)
 	spin_unlock_irqrestore(&opl4->reg_lock, flags);
 }
 
-static void snd_opl4_enable_opl4(opl4_t *opl4)
+static void snd_opl4_enable_opl4(struct snd_opl4 *opl4)
 {
 	outb(OPL3_REG_MODE, opl4->fm_port + 2);
 	inb(opl4->fm_port);
@@ -110,7 +110,7 @@ static void snd_opl4_enable_opl4(opl4_t *opl4)
 	inb(opl4->fm_port);
 }
 
-static int snd_opl4_detect(opl4_t *opl4)
+static int snd_opl4_detect(struct snd_opl4 *opl4)
 {
 	u8 id1, id2;
 
@@ -144,19 +144,19 @@ static int snd_opl4_detect(opl4_t *opl4)
 }
 
 #if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
-static void snd_opl4_seq_dev_free(snd_seq_device_t *seq_dev)
+static void snd_opl4_seq_dev_free(struct snd_seq_device *seq_dev)
 {
-	opl4_t *opl4 = seq_dev->private_data;
+	struct snd_opl4 *opl4 = seq_dev->private_data;
 	opl4->seq_dev = NULL;
 }
 
-static int snd_opl4_create_seq_dev(opl4_t *opl4, int seq_device)
+static int snd_opl4_create_seq_dev(struct snd_opl4 *opl4, int seq_device)
 {
 	opl4->seq_dev_num = seq_device;
 	if (snd_seq_device_new(opl4->card, seq_device, SNDRV_SEQ_DEV_ID_OPL4,
-			       sizeof(opl4_t *), &opl4->seq_dev) >= 0) {
+			       sizeof(struct snd_opl4 *), &opl4->seq_dev) >= 0) {
 		strcpy(opl4->seq_dev->name, "OPL4 Wavetable");
-		*(opl4_t **)SNDRV_SEQ_DEVICE_ARGPTR(opl4->seq_dev) = opl4;
+		*(struct snd_opl4 **)SNDRV_SEQ_DEVICE_ARGPTR(opl4->seq_dev) = opl4;
 		opl4->seq_dev->private_data = opl4;
 		opl4->seq_dev->private_free = snd_opl4_seq_dev_free;
 	}
@@ -164,7 +164,7 @@ static int snd_opl4_create_seq_dev(opl4_t *opl4, int seq_device)
 }
 #endif
 
-static void snd_opl4_free(opl4_t *opl4)
+static void snd_opl4_free(struct snd_opl4 *opl4)
 {
 #ifdef CONFIG_PROC_FS
 	snd_opl4_free_proc(opl4);
@@ -174,22 +174,22 @@ static void snd_opl4_free(opl4_t *opl4)
 	kfree(opl4);
 }
 
-static int snd_opl4_dev_free(snd_device_t *device)
+static int snd_opl4_dev_free(struct snd_device *device)
 {
-	opl4_t *opl4 = device->device_data;
+	struct snd_opl4 *opl4 = device->device_data;
 	snd_opl4_free(opl4);
 	return 0;
 }
 
-int snd_opl4_create(snd_card_t *card,
+int snd_opl4_create(struct snd_card *card,
 		    unsigned long fm_port, unsigned long pcm_port,
 		    int seq_device,
-		    opl3_t **ropl3, opl4_t **ropl4)
+		    struct snd_opl3 **ropl3, struct snd_opl4 **ropl4)
 {
-	opl4_t *opl4;
-	opl3_t *opl3;
+	struct snd_opl4 *opl4;
+	struct snd_opl3 *opl3;
 	int err;
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free = snd_opl4_dev_free
 	};
 

commit b1d5776d865951c213a1caaab5d8bf5de7615dbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:56:31 2005 +0200

    [ALSA] Remove vmalloc wrapper, kfree_nocheck()
    
    - Remove vmalloc wrapper
    - Add release_and_free_resource() to remove kfree_nocheck() from each driver
      and simplify the code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index 380c2c704c54..4ae5dd8f011e 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -169,14 +169,8 @@ static void snd_opl4_free(opl4_t *opl4)
 #ifdef CONFIG_PROC_FS
 	snd_opl4_free_proc(opl4);
 #endif
-	if (opl4->res_fm_port) {
-		release_resource(opl4->res_fm_port);
-		kfree_nocheck(opl4->res_fm_port);
-	}
-	if (opl4->res_pcm_port) {
-		release_resource(opl4->res_pcm_port);
-		kfree_nocheck(opl4->res_pcm_port);
-	}
+	release_and_free_resource(opl4->res_fm_port);
+	release_and_free_resource(opl4->res_pcm_port);
 	kfree(opl4);
 }
 

commit 561b220a4dece18d67177413e6fa21b49aa4acce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:22:34 2005 +0200

    [ALSA] Replace with kzalloc() - others
    
    Documentation,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,OPL3
    OPL4,Digigram VX core,I2C cs8427,I2C lib core,I2C tea6330t,L3 drivers
    AK4114 receiver,AK4117 receiver,PDAudioCF driver,PPC PMAC driver
    SPARC AMD7930 driver,SPARC cs4231 driver,Synth,Common EMU synth
    USB generic driver,USB USX2Y
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
index 8261464dade8..380c2c704c54 100644
--- a/sound/drivers/opl4/opl4_lib.c
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -204,7 +204,7 @@ int snd_opl4_create(snd_card_t *card,
 	if (ropl4)
 		*ropl4 = NULL;
 
-	opl4 = kcalloc(1, sizeof(*opl4), GFP_KERNEL);
+	opl4 = kzalloc(sizeof(*opl4), GFP_KERNEL);
 	if (!opl4)
 		return -ENOMEM;
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/drivers/opl4/opl4_lib.c b/sound/drivers/opl4/opl4_lib.c
new file mode 100644
index 000000000000..8261464dade8
--- /dev/null
+++ b/sound/drivers/opl4/opl4_lib.c
@@ -0,0 +1,281 @@
+/*
+ * Functions for accessing OPL4 devices
+ * Copyright (c) 2003 by Clemens Ladisch <clemens@ladisch.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include "opl4_local.h"
+#include <sound/initval.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <asm/io.h>
+
+MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
+MODULE_DESCRIPTION("OPL4 driver");
+MODULE_LICENSE("GPL");
+
+static void inline snd_opl4_wait(opl4_t *opl4)
+{
+	int timeout = 10;
+	while ((inb(opl4->fm_port) & OPL4_STATUS_BUSY) && --timeout > 0)
+		;
+}
+
+void snd_opl4_write(opl4_t *opl4, u8 reg, u8 value)
+{
+	snd_opl4_wait(opl4);
+	outb(reg, opl4->pcm_port);
+
+	snd_opl4_wait(opl4);
+	outb(value, opl4->pcm_port + 1);
+}
+
+u8 snd_opl4_read(opl4_t *opl4, u8 reg)
+{
+	snd_opl4_wait(opl4);
+	outb(reg, opl4->pcm_port);
+
+	snd_opl4_wait(opl4);
+	return inb(opl4->pcm_port + 1);
+}
+
+void snd_opl4_read_memory(opl4_t *opl4, char *buf, int offset, int size)
+{
+	unsigned long flags;
+	u8 memcfg;
+
+	spin_lock_irqsave(&opl4->reg_lock, flags);
+
+	memcfg = snd_opl4_read(opl4, OPL4_REG_MEMORY_CONFIGURATION);
+	snd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, memcfg | OPL4_MODE_BIT);
+
+	snd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_HIGH, offset >> 16);
+	snd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_MID, offset >> 8);
+	snd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_LOW, offset);
+
+	snd_opl4_wait(opl4);
+	outb(OPL4_REG_MEMORY_DATA, opl4->pcm_port);
+	snd_opl4_wait(opl4);
+	insb(opl4->pcm_port + 1, buf, size);
+
+	snd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, memcfg);
+
+	spin_unlock_irqrestore(&opl4->reg_lock, flags);
+}
+
+void snd_opl4_write_memory(opl4_t *opl4, const char *buf, int offset, int size)
+{
+	unsigned long flags;
+	u8 memcfg;
+
+	spin_lock_irqsave(&opl4->reg_lock, flags);
+
+	memcfg = snd_opl4_read(opl4, OPL4_REG_MEMORY_CONFIGURATION);
+	snd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, memcfg | OPL4_MODE_BIT);
+
+	snd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_HIGH, offset >> 16);
+	snd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_MID, offset >> 8);
+	snd_opl4_write(opl4, OPL4_REG_MEMORY_ADDRESS_LOW, offset);
+
+	snd_opl4_wait(opl4);
+	outb(OPL4_REG_MEMORY_DATA, opl4->pcm_port);
+	snd_opl4_wait(opl4);
+	outsb(opl4->pcm_port + 1, buf, size);
+
+	snd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, memcfg);
+
+	spin_unlock_irqrestore(&opl4->reg_lock, flags);
+}
+
+static void snd_opl4_enable_opl4(opl4_t *opl4)
+{
+	outb(OPL3_REG_MODE, opl4->fm_port + 2);
+	inb(opl4->fm_port);
+	inb(opl4->fm_port);
+	outb(OPL3_OPL3_ENABLE | OPL3_OPL4_ENABLE, opl4->fm_port + 3);
+	inb(opl4->fm_port);
+	inb(opl4->fm_port);
+}
+
+static int snd_opl4_detect(opl4_t *opl4)
+{
+	u8 id1, id2;
+
+	snd_opl4_enable_opl4(opl4);
+
+	id1 = snd_opl4_read(opl4, OPL4_REG_MEMORY_CONFIGURATION);
+	snd_printdd("OPL4[02]=%02x\n", id1);
+	switch (id1 & OPL4_DEVICE_ID_MASK) {
+	case 0x20:
+		opl4->hardware = OPL3_HW_OPL4;
+		break;
+	case 0x40:
+		opl4->hardware = OPL3_HW_OPL4_ML;
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	snd_opl4_write(opl4, OPL4_REG_MIX_CONTROL_FM, 0x00);
+	snd_opl4_write(opl4, OPL4_REG_MIX_CONTROL_PCM, 0xff);
+	id1 = snd_opl4_read(opl4, OPL4_REG_MIX_CONTROL_FM);
+	id2 = snd_opl4_read(opl4, OPL4_REG_MIX_CONTROL_PCM);
+	snd_printdd("OPL4 id1=%02x id2=%02x\n", id1, id2);
+       	if (id1 != 0x00 || id2 != 0xff)
+		return -ENODEV;
+
+	snd_opl4_write(opl4, OPL4_REG_MIX_CONTROL_FM, 0x3f);
+	snd_opl4_write(opl4, OPL4_REG_MIX_CONTROL_PCM, 0x3f);
+	snd_opl4_write(opl4, OPL4_REG_MEMORY_CONFIGURATION, 0x00);
+	return 0;
+}
+
+#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
+static void snd_opl4_seq_dev_free(snd_seq_device_t *seq_dev)
+{
+	opl4_t *opl4 = seq_dev->private_data;
+	opl4->seq_dev = NULL;
+}
+
+static int snd_opl4_create_seq_dev(opl4_t *opl4, int seq_device)
+{
+	opl4->seq_dev_num = seq_device;
+	if (snd_seq_device_new(opl4->card, seq_device, SNDRV_SEQ_DEV_ID_OPL4,
+			       sizeof(opl4_t *), &opl4->seq_dev) >= 0) {
+		strcpy(opl4->seq_dev->name, "OPL4 Wavetable");
+		*(opl4_t **)SNDRV_SEQ_DEVICE_ARGPTR(opl4->seq_dev) = opl4;
+		opl4->seq_dev->private_data = opl4;
+		opl4->seq_dev->private_free = snd_opl4_seq_dev_free;
+	}
+	return 0;
+}
+#endif
+
+static void snd_opl4_free(opl4_t *opl4)
+{
+#ifdef CONFIG_PROC_FS
+	snd_opl4_free_proc(opl4);
+#endif
+	if (opl4->res_fm_port) {
+		release_resource(opl4->res_fm_port);
+		kfree_nocheck(opl4->res_fm_port);
+	}
+	if (opl4->res_pcm_port) {
+		release_resource(opl4->res_pcm_port);
+		kfree_nocheck(opl4->res_pcm_port);
+	}
+	kfree(opl4);
+}
+
+static int snd_opl4_dev_free(snd_device_t *device)
+{
+	opl4_t *opl4 = device->device_data;
+	snd_opl4_free(opl4);
+	return 0;
+}
+
+int snd_opl4_create(snd_card_t *card,
+		    unsigned long fm_port, unsigned long pcm_port,
+		    int seq_device,
+		    opl3_t **ropl3, opl4_t **ropl4)
+{
+	opl4_t *opl4;
+	opl3_t *opl3;
+	int err;
+	static snd_device_ops_t ops = {
+		.dev_free = snd_opl4_dev_free
+	};
+
+	if (ropl3)
+		*ropl3 = NULL;
+	if (ropl4)
+		*ropl4 = NULL;
+
+	opl4 = kcalloc(1, sizeof(*opl4), GFP_KERNEL);
+	if (!opl4)
+		return -ENOMEM;
+
+	opl4->res_fm_port = request_region(fm_port, 8, "OPL4 FM");
+	opl4->res_pcm_port = request_region(pcm_port, 8, "OPL4 PCM/MIX");
+	if (!opl4->res_fm_port || !opl4->res_pcm_port) {
+		snd_printk(KERN_ERR "opl4: can't grab ports 0x%lx, 0x%lx\n", fm_port, pcm_port);
+		snd_opl4_free(opl4);
+		return -EBUSY;
+	}
+
+	opl4->card = card;
+	opl4->fm_port = fm_port;
+	opl4->pcm_port = pcm_port;
+	spin_lock_init(&opl4->reg_lock);
+	init_MUTEX(&opl4->access_mutex);
+
+	err = snd_opl4_detect(opl4);
+	if (err < 0) {
+		snd_opl4_free(opl4);
+		snd_printd("OPL4 chip not detected at %#lx/%#lx\n", fm_port, pcm_port);
+		return err;
+	}
+
+	err = snd_device_new(card, SNDRV_DEV_CODEC, opl4, &ops);
+	if (err < 0) {
+		snd_opl4_free(opl4);
+		return err;
+	}
+
+	err = snd_opl3_create(card, fm_port, fm_port + 2, opl4->hardware, 1, &opl3);
+	if (err < 0) {
+		snd_device_free(card, opl4);
+		return err;
+	}
+
+	/* opl3 initialization disabled opl4, so reenable */
+	snd_opl4_enable_opl4(opl4);
+
+	snd_opl4_create_mixer(opl4);
+#ifdef CONFIG_PROC_FS
+	snd_opl4_create_proc(opl4);
+#endif
+
+#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
+	opl4->seq_client = -1;
+	if (opl4->hardware < OPL3_HW_OPL4_ML)
+		snd_opl4_create_seq_dev(opl4, seq_device);
+#endif
+
+	if (ropl3)
+		*ropl3 = opl3;
+	if (ropl4)
+		*ropl4 = opl4;
+	return 0;
+}
+
+EXPORT_SYMBOL(snd_opl4_write);
+EXPORT_SYMBOL(snd_opl4_read);
+EXPORT_SYMBOL(snd_opl4_write_memory);
+EXPORT_SYMBOL(snd_opl4_read_memory);
+EXPORT_SYMBOL(snd_opl4_create);
+
+static int __init alsa_opl4_init(void)
+{
+	return 0;
+}
+
+static void __exit alsa_opl4_exit(void)
+{
+}
+
+module_init(alsa_opl4_init)
+module_exit(alsa_opl4_exit)
