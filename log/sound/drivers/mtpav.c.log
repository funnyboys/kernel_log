commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 547662e02fcc..ce5fd17bd720 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -1,24 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *      MOTU Midi Timepiece ALSA Main routines
  *      Copyright by Michael T. Mayers (c) Jan 09, 2000
  *      mail: michael@tweakoz.com
  *      Thanks to John Galbraith
  *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- *
  *      This driver is for the 'Mark Of The Unicorn' (MOTU)
  *      MidiTimePiece AV multiport MIDI interface 
  *
@@ -39,7 +25,6 @@
  *      MIDI Synchronization to Video, ADAT, SMPTE and other Clock sources
  *      128 'scene' memories, recallable from MIDI program change
  *
- *
  * ChangeLog
  * Jun 11 2001	Takashi Iwai <tiwai@suse.de>
  *      - Recoded & debugged
@@ -47,7 +32,6 @@
  *      - hwports is between 1 and 8, which specifies the number of hardware ports.
  *        The three global ports, computer, adat and broadcast ports, are created
  *        always after h/w and remote ports.
- *
  */
 
 #include <linux/init.h>

commit bc47ba90b01afe468cdd586b0dbe59b64862e2b7
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 24 08:34:29 2017 -0700

    ALSA: drivers: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 0f6392001e30..547662e02fcc 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -406,10 +406,10 @@ static void snd_mtpav_input_trigger(struct snd_rawmidi_substream *substream, int
  * timer interrupt for outputs
  */
 
-static void snd_mtpav_output_timer(unsigned long data)
+static void snd_mtpav_output_timer(struct timer_list *t)
 {
 	unsigned long flags;
-	struct mtpav *chip = (struct mtpav *)data;
+	struct mtpav *chip = from_timer(chip, t, timer);
 	int p;
 
 	spin_lock_irqsave(&chip->spinlock, flags);
@@ -707,8 +707,7 @@ static int snd_mtpav_probe(struct platform_device *dev)
 	mtp_card->share_irq = 0;
 	mtp_card->inmidistate = 0;
 	mtp_card->outmidihwport = 0xffffffff;
-	setup_timer(&mtp_card->timer, snd_mtpav_output_timer,
-		    (unsigned long) mtp_card);
+	timer_setup(&mtp_card->timer, snd_mtpav_output_timer, 0);
 
 	card->private_free = snd_mtpav_free;
 

commit b11ce420c5dfc966061bc20f576c85504bb69712
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:30 2017 +0100

    Annotate hardware config module parameters in sound/drivers/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in sound/drivers/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    cc: Jaroslav Kysela <perex@perex.cz>
    cc: alsa-devel@alsa-project.org

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 00b31f92c504..0f6392001e30 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -86,9 +86,9 @@ module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for MotuMTPAV MIDI.");
 module_param(id, charp, 0444);
 MODULE_PARM_DESC(id, "ID string for MotuMTPAV MIDI.");
-module_param(port, long, 0444);
+module_param_hw(port, long, ioport, 0444);
 MODULE_PARM_DESC(port, "Parallel port # for MotuMTPAV MIDI.");
-module_param(irq, int, 0444);
+module_param_hw(irq, int, irq, 0444);
 MODULE_PARM_DESC(irq, "Parallel IRQ # for MotuMTPAV MIDI.");
 module_param(hwports, int, 0444);
 MODULE_PARM_DESC(hwports, "Hardware ports # for MotuMTPAV MIDI.");

commit c36f486d7bc71d41ec6b9521574136a280c17803
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 5 17:28:39 2017 +0100

    ALSA: drivers: Constify snd_rawmidi_ops
    
    Now snd_rawmidi_ops is maintained as a const pointer in snd_rawmidi,
    we can constify the definitions.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 30e8a1d5bc87..00b31f92c504 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -600,13 +600,13 @@ static int snd_mtpav_get_ISA(struct mtpav *mcard)
 /*
  */
 
-static struct snd_rawmidi_ops snd_mtpav_output = {
+static const struct snd_rawmidi_ops snd_mtpav_output = {
 	.open =		snd_mtpav_output_open,
 	.close =	snd_mtpav_output_close,
 	.trigger =	snd_mtpav_output_trigger,
 };
 
-static struct snd_rawmidi_ops snd_mtpav_input = {
+static const struct snd_rawmidi_ops snd_mtpav_input = {
 	.open =		snd_mtpav_input_open,
 	.close =	snd_mtpav_input_close,
 	.trigger =	snd_mtpav_input_trigger,

commit 2b1b78114319e0ed2b7ca8c75d9cde6d2bf8f9fc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 11:28:36 2015 +0100

    ALSA: mtpav: Use setup_timer() and mod_timer()
    
    No functional change, refactoring with the standard helpers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 15769447688f..30e8a1d5bc87 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -414,8 +414,7 @@ static void snd_mtpav_output_timer(unsigned long data)
 
 	spin_lock_irqsave(&chip->spinlock, flags);
 	/* reprogram timer */
-	chip->timer.expires = 1 + jiffies;
-	add_timer(&chip->timer);
+	mod_timer(&chip->timer, 1 + jiffies);
 	/* process each port */
 	for (p = 0; p <= chip->num_ports * 2 + MTPAV_PIDX_BROADCAST; p++) {
 		struct mtpav_port *portp = &chip->ports[p];
@@ -428,8 +427,7 @@ static void snd_mtpav_output_timer(unsigned long data)
 /* spinlock held! */
 static void snd_mtpav_add_output_timer(struct mtpav *chip)
 {
-	chip->timer.expires = 1 + jiffies;
-	add_timer(&chip->timer);
+	mod_timer(&chip->timer, 1 + jiffies);
 }
 
 /* spinlock held! */
@@ -704,15 +702,13 @@ static int snd_mtpav_probe(struct platform_device *dev)
 
 	mtp_card = card->private_data;
 	spin_lock_init(&mtp_card->spinlock);
-	init_timer(&mtp_card->timer);
 	mtp_card->card = card;
 	mtp_card->irq = -1;
 	mtp_card->share_irq = 0;
 	mtp_card->inmidistate = 0;
 	mtp_card->outmidihwport = 0xffffffff;
-	init_timer(&mtp_card->timer);
-	mtp_card->timer.function = snd_mtpav_output_timer;
-	mtp_card->timer.data = (unsigned long) mtp_card;
+	setup_timer(&mtp_card->timer, snd_mtpav_output_timer,
+		    (unsigned long) mtp_card);
 
 	card->private_free = snd_mtpav_free;
 

commit 5d5638afa0cb252442e1746a36550b46a9ebe6ee
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:59 2014 +0200

    ALSA: drivers: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 4b66c7f22af7..15769447688f 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -759,7 +759,6 @@ static struct platform_driver snd_mtpav_driver = {
 	.remove		= snd_mtpav_remove,
 	.driver		= {
 		.name	= SND_MTPAV_DRIVER,
-		.owner	= THIS_MODULE,
 	},
 };
 

commit 5872f3f621f9f65342583a85ec93b00c0a697eda
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 12:59:08 2014 +0100

    ALSA: drivers: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index e5ec7eb27dec..4b66c7f22af7 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -697,7 +697,8 @@ static int snd_mtpav_probe(struct platform_device *dev)
 	int err;
 	struct mtpav *mtp_card;
 
-	err = snd_card_create(index, id, THIS_MODULE, sizeof(*mtp_card), &card);
+	err = snd_card_new(&dev->dev, index, id, THIS_MODULE,
+			   sizeof(*mtp_card), &card);
 	if (err < 0)
 		return err;
 
@@ -732,7 +733,6 @@ static int snd_mtpav_probe(struct platform_device *dev)
 
 	snd_mtpav_portscan(mtp_card);
 
-	snd_card_set_dev(card, &dev->dev);
 	err = snd_card_register(mtp_card->card);
 	if (err < 0)
 		goto __error;

commit a204341dae68bee125f4e7f22c5640cb4e3aae16
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon May 20 14:08:38 2013 +0530

    ALSA: mtpav: Remove redundant platform_set_drvdata()
    
    Commit 0998d06310 (device-core: Ensure drvdata = NULL when no
    driver is bound) removes the need to set driver data field to
    NULL.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 9f1815b99a15..e5ec7eb27dec 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -749,7 +749,6 @@ static int snd_mtpav_probe(struct platform_device *dev)
 static int snd_mtpav_remove(struct platform_device *devptr)
 {
 	snd_card_free(platform_get_drvdata(devptr));
-	platform_set_drvdata(devptr, NULL);
 	return 0;
 }
 

commit fbbb01a12d5d553ea3851a020d98c0ac9b383673
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:27 2012 -0500

    ALSA: drivers: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index cad73af3860c..9f1815b99a15 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -583,7 +583,7 @@ static irqreturn_t snd_mtpav_irqh(int irq, void *dev_id)
 /*
  * get ISA resources
  */
-static int __devinit snd_mtpav_get_ISA(struct mtpav * mcard)
+static int snd_mtpav_get_ISA(struct mtpav *mcard)
 {
 	if ((mcard->res_port = request_region(port, 3, "MotuMTPAV MIDI")) == NULL) {
 		snd_printk(KERN_ERR "MTVAP port 0x%lx is busy\n", port);
@@ -619,8 +619,8 @@ static struct snd_rawmidi_ops snd_mtpav_input = {
  * get RAWMIDI resources
  */
 
-static void __devinit snd_mtpav_set_name(struct mtpav *chip,
-				      struct snd_rawmidi_substream *substream)
+static void snd_mtpav_set_name(struct mtpav *chip,
+			       struct snd_rawmidi_substream *substream)
 {
 	if (substream->number >= 0 && substream->number < chip->num_ports)
 		sprintf(substream->name, "MTP direct %d", (substream->number % chip->num_ports) + 1);
@@ -634,7 +634,7 @@ static void __devinit snd_mtpav_set_name(struct mtpav *chip,
 		strcpy(substream->name, "MTP broadcast");
 }
 
-static int __devinit snd_mtpav_get_RAWMIDI(struct mtpav *mcard)
+static int snd_mtpav_get_RAWMIDI(struct mtpav *mcard)
 {
 	int rval;
 	struct snd_rawmidi *rawmidi;
@@ -691,7 +691,7 @@ static void snd_mtpav_free(struct snd_card *card)
 
 /*
  */
-static int __devinit snd_mtpav_probe(struct platform_device *dev)
+static int snd_mtpav_probe(struct platform_device *dev)
 {
 	struct snd_card *card;
 	int err;
@@ -746,7 +746,7 @@ static int __devinit snd_mtpav_probe(struct platform_device *dev)
 	return err;
 }
 
-static int __devexit snd_mtpav_remove(struct platform_device *devptr)
+static int snd_mtpav_remove(struct platform_device *devptr)
 {
 	snd_card_free(platform_get_drvdata(devptr));
 	platform_set_drvdata(devptr, NULL);
@@ -757,7 +757,7 @@ static int __devexit snd_mtpav_remove(struct platform_device *devptr)
 
 static struct platform_driver snd_mtpav_driver = {
 	.probe		= snd_mtpav_probe,
-	.remove		= __devexit_p(snd_mtpav_remove),
+	.remove		= snd_mtpav_remove,
 	.driver		= {
 		.name	= SND_MTPAV_DRIVER,
 		.owner	= THIS_MODULE,

commit 8bf01d8abc55eaf8e19a2d48911c8e49ee6f5bab
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 10:50:24 2012 +0200

    ALSA: Add missing .owner=THIS_MODULE to platform_driver definitions
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 76930793fb69..cad73af3860c 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -759,7 +759,8 @@ static struct platform_driver snd_mtpav_driver = {
 	.probe		= snd_mtpav_probe,
 	.remove		= __devexit_p(snd_mtpav_remove),
 	.driver		= {
-		.name	= SND_MTPAV_DRIVER
+		.name	= SND_MTPAV_DRIVER,
+		.owner	= THIS_MODULE,
 	},
 };
 

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 1eef4ccebe4b..76930793fb69 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -52,6 +52,7 @@
 
 #include <linux/init.h>
 #include <linux/interrupt.h>
+#include <linux/module.h>
 #include <linux/err.h>
 #include <linux/platform_device.h>
 #include <linux/ioport.h>

commit 88e24c3a4b30a6bd361f2b5ce602667a8161b2e8
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Thu Sep 22 16:59:20 2011 +0800

    sound: irq: Remove IRQF_DISABLED
    
    Since commit [e58aa3d2: genirq: Run irq handlers with interrupts disabled],
    We run all interrupt handlers with interrupts disabled
    and we even check and yell when an interrupt handler
    returns with interrupts enabled (see commit [b738a50a:
    genirq: Warn when handler enables interrupts]).
    
    So now this flag is a NOOP and can be removed.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 5c426df87678..1eef4ccebe4b 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -589,7 +589,7 @@ static int __devinit snd_mtpav_get_ISA(struct mtpav * mcard)
 		return -EBUSY;
 	}
 	mcard->port = port;
-	if (request_irq(irq, snd_mtpav_irqh, IRQF_DISABLED, "MOTU MTPAV", mcard)) {
+	if (request_irq(irq, snd_mtpav_irqh, 0, "MOTU MTPAV", mcard)) {
 		snd_printk(KERN_ERR "MTVAP IRQ %d busy\n", irq);
 		return -EBUSY;
 	}

commit ddfb319926462fd9670b7c1678a1f6a14a68e421
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 2 17:49:53 2011 +0100

    ALSA: use linux/io.h to fix compile warnings
    
    For helping to reduce Greert's regression list...
      src/sound/drivers/mtpav.c: error: implicit declaration of function 'inb'
      src/sound/drivers/mtpav.c: error: implicit declaration of function 'outb'
      ...
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index da03597fc893..5c426df87678 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -55,14 +55,13 @@
 #include <linux/err.h>
 #include <linux/platform_device.h>
 #include <linux/ioport.h>
+#include <linux/io.h>
 #include <linux/moduleparam.h>
 #include <sound/core.h>
 #include <sound/initval.h>
 #include <sound/rawmidi.h>
 #include <linux/delay.h>
 
-#include <asm/io.h>
-
 /*
  *      globals
  */

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 2f8f295d6b0c..da03597fc893 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -54,7 +54,6 @@
 #include <linux/interrupt.h>
 #include <linux/err.h>
 #include <linux/platform_device.h>
-#include <linux/slab.h>
 #include <linux/ioport.h>
 #include <linux/moduleparam.h>
 #include <sound/core.h>

commit e0d2054fd3cf167395390dc1758644486c782707
Merge: d807500a2472 c468ac29e63b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:35:50 2009 +0100

    Merge branch 'topic/misc' into for-linus

commit dec14f8c0eff54549e5747f8a4d1dc6c0347e2dd
Merge: 8e0ee43bc2c3 b1a0aac05f04
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:35:35 2009 +0100

    Merge branch 'topic/snd_card_new-err' into for-linus

commit 32cf9a16f4af01573ddec1eb073111fc20a9d7d4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 12 00:06:42 2009 +0100

    ALSA: mtpav - Fix initial value for input hwport
    
    Fix the initial value for input hwport.  The old value (-1) may cause
    Oops when an realtime MIDI byte is received before the input port is
    explicitly given.
    Instead, now it's set to the broadcasting as default.
    
    Tested-by: Holger Dehnhardt <dehnhardt@ahdehnhardt.de>
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 5b89c0883d60..48b64e6b2670 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -706,7 +706,6 @@ static int __devinit snd_mtpav_probe(struct platform_device *dev)
 	mtp_card->card = card;
 	mtp_card->irq = -1;
 	mtp_card->share_irq = 0;
-	mtp_card->inmidiport = 0xffffffff;
 	mtp_card->inmidistate = 0;
 	mtp_card->outmidihwport = 0xffffffff;
 	init_timer(&mtp_card->timer);
@@ -719,6 +718,8 @@ static int __devinit snd_mtpav_probe(struct platform_device *dev)
 	if (err < 0)
 		goto __error;
 
+	mtp_card->inmidiport = mtp_card->num_ports + MTPAV_PIDX_BROADCAST;
+
 	err = snd_mtpav_get_ISA(mtp_card);
 	if (err < 0)
 		goto __error;

commit 45203832df2fa9e94ca0a249ddb20d2b077e58cc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 15:51:50 2009 +0100

    ALSA: Add missing KERN_* prefix to printk in sound/drivers
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 5b89c0883d60..6b26305ff0e6 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -303,8 +303,10 @@ static void snd_mtpav_output_port_write(struct mtpav *mtp_card,
 
 		snd_mtpav_send_byte(mtp_card, 0xf5);
 		snd_mtpav_send_byte(mtp_card, portp->hwport);
-		//snd_printk("new outport: 0x%x\n", (unsigned int) portp->hwport);
-
+		/*
+		snd_printk(KERN_DEBUG "new outport: 0x%x\n",
+			   (unsigned int) portp->hwport);
+		*/
 		if (!(outbyte & 0x80) && portp->running_status)
 			snd_mtpav_send_byte(mtp_card, portp->running_status);
 	}
@@ -540,7 +542,7 @@ static void snd_mtpav_read_bytes(struct mtpav *mcrd)
 
 	u8 sbyt = snd_mtpav_getreg(mcrd, SREG);
 
-	//printk("snd_mtpav_read_bytes() sbyt: 0x%x\n", sbyt);
+	/* printk(KERN_DEBUG "snd_mtpav_read_bytes() sbyt: 0x%x\n", sbyt); */
 
 	if (!(sbyt & SIGS_BYTE))
 		return;
@@ -585,12 +587,12 @@ static irqreturn_t snd_mtpav_irqh(int irq, void *dev_id)
 static int __devinit snd_mtpav_get_ISA(struct mtpav * mcard)
 {
 	if ((mcard->res_port = request_region(port, 3, "MotuMTPAV MIDI")) == NULL) {
-		snd_printk("MTVAP port 0x%lx is busy\n", port);
+		snd_printk(KERN_ERR "MTVAP port 0x%lx is busy\n", port);
 		return -EBUSY;
 	}
 	mcard->port = port;
 	if (request_irq(irq, snd_mtpav_irqh, IRQF_DISABLED, "MOTU MTPAV", mcard)) {
-		snd_printk("MTVAP IRQ %d busy\n", irq);
+		snd_printk(KERN_ERR "MTVAP IRQ %d busy\n", irq);
 		return -EBUSY;
 	}
 	mcard->irq = irq;

commit bd7dd77c2a05c530684eea2e3af16449ae9c5d52
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:45:02 2008 +0100

    ALSA: Convert to snd_card_create() in other sound/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in other sound subdirectories.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 5b89c0883d60..c3e9833dcfd9 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -696,9 +696,9 @@ static int __devinit snd_mtpav_probe(struct platform_device *dev)
 	int err;
 	struct mtpav *mtp_card;
 
-	card = snd_card_new(index, id, THIS_MODULE, sizeof(*mtp_card));
-	if (! card)
-		return -ENOMEM;
+	err = snd_card_create(index, id, THIS_MODULE, sizeof(*mtp_card), &card);
+	if (err < 0)
+		return err;
 
 	mtp_card = card->private_data;
 	spin_lock_init(&mtp_card->spinlock);

commit 32fe61426373d85e797bf4f4dcbe4510487c3e00
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 8 10:28:25 2008 +0200

    ALSA: mtpav - Fix race in probe
    
    Ingo reported Oops at probing mtpav driver.  It's a race between
    the irq handler and the rawmidi instance registration.
    
    This patch fixes the order of registration to avoid the race.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Tested-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index b5e1a71bb64b..5b89c0883d60 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -715,6 +715,10 @@ static int __devinit snd_mtpav_probe(struct platform_device *dev)
 
 	card->private_free = snd_mtpav_free;
 
+	err = snd_mtpav_get_RAWMIDI(mtp_card);
+	if (err < 0)
+		goto __error;
+
 	err = snd_mtpav_get_ISA(mtp_card);
 	if (err < 0)
 		goto __error;
@@ -724,10 +728,6 @@ static int __devinit snd_mtpav_probe(struct platform_device *dev)
 	snprintf(card->longname, sizeof(card->longname),
 		 "MTPAV on parallel port at 0x%lx", port);
 
-	err = snd_mtpav_get_RAWMIDI(mtp_card);
-	if (err < 0)
-		goto __error;
-
 	snd_mtpav_portscan(mtp_card);
 
 	snd_card_set_dev(card, &dev->dev);

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 40eb026c86ed..b5e1a71bb64b 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -50,7 +50,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/err.h>

commit 788c6043335590e0a483fdc18f85b1405a157bf9
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Tue Feb 13 13:11:11 2007 +0100

    [ALSA] Fix __devinit and __devexit issues with sound drivers
    
    Fix __devinit and __devexit issues with sound drivers.
    Resolves MODPOST warnings similar to:
    WARNING: sound/drivers/snd-dummy.o - Section mismatch: reference to .init.text:snd_dummy_probe from .data.rel.local between 'snd_dummy_driver' (at offset 0x0) and 'snd_dummy_controls'
    WARNING: sound/drivers/snd-mtpav.o - Section mismatch: reference to .init.text:snd_mtpav_probe from .data.rel.local between 'snd_mtpav_driver' (at offset 0x0) and 'snd_mtpav_input'
    WARNING: sound/drivers/snd-virmidi.o - Section mismatch: reference to .init.text:snd_virmidi_probe from .data.rel.local after 'snd_virmidi_driver' (at offset 0x0)
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index a9ff391258e7..40eb026c86ed 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -583,7 +583,7 @@ static irqreturn_t snd_mtpav_irqh(int irq, void *dev_id)
 /*
  * get ISA resources
  */
-static int __init snd_mtpav_get_ISA(struct mtpav * mcard)
+static int __devinit snd_mtpav_get_ISA(struct mtpav * mcard)
 {
 	if ((mcard->res_port = request_region(port, 3, "MotuMTPAV MIDI")) == NULL) {
 		snd_printk("MTVAP port 0x%lx is busy\n", port);
@@ -619,7 +619,7 @@ static struct snd_rawmidi_ops snd_mtpav_input = {
  * get RAWMIDI resources
  */
 
-static void __init snd_mtpav_set_name(struct mtpav *chip,
+static void __devinit snd_mtpav_set_name(struct mtpav *chip,
 				      struct snd_rawmidi_substream *substream)
 {
 	if (substream->number >= 0 && substream->number < chip->num_ports)
@@ -634,7 +634,7 @@ static void __init snd_mtpav_set_name(struct mtpav *chip,
 		strcpy(substream->name, "MTP broadcast");
 }
 
-static int __init snd_mtpav_get_RAWMIDI(struct mtpav *mcard)
+static int __devinit snd_mtpav_get_RAWMIDI(struct mtpav *mcard)
 {
 	int rval;
 	struct snd_rawmidi *rawmidi;
@@ -691,7 +691,7 @@ static void snd_mtpav_free(struct snd_card *card)
 
 /*
  */
-static int __init snd_mtpav_probe(struct platform_device *dev)
+static int __devinit snd_mtpav_probe(struct platform_device *dev)
 {
 	struct snd_card *card;
 	int err;
@@ -745,7 +745,7 @@ static int __init snd_mtpav_probe(struct platform_device *dev)
 	return err;
 }
 
-static int snd_mtpav_remove(struct platform_device *devptr)
+static int __devexit snd_mtpav_remove(struct platform_device *devptr)
 {
 	snd_card_free(platform_get_drvdata(devptr));
 	platform_set_drvdata(devptr, NULL);
@@ -756,7 +756,7 @@ static int snd_mtpav_remove(struct platform_device *devptr)
 
 static struct platform_driver snd_mtpav_driver = {
 	.probe		= snd_mtpav_probe,
-	.remove		= snd_mtpav_remove,
+	.remove		= __devexit_p(snd_mtpav_remove),
 	.driver		= {
 		.name	= SND_MTPAV_DRIVER
 	},

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index e064d6c5685b..a9ff391258e7 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -570,7 +570,7 @@ static void snd_mtpav_read_bytes(struct mtpav *mcrd)
 	} while (sbyt & SIGS_BYTE);
 }
 
-static irqreturn_t snd_mtpav_irqh(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_mtpav_irqh(int irq, void *dev_id)
 {
 	struct mtpav *mcard = dev_id;
 

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 474eed06e70f..e064d6c5685b 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -590,7 +590,7 @@ static int __init snd_mtpav_get_ISA(struct mtpav * mcard)
 		return -EBUSY;
 	}
 	mcard->port = port;
-	if (request_irq(irq, snd_mtpav_irqh, SA_INTERRUPT, "MOTU MTPAV", mcard)) {
+	if (request_irq(irq, snd_mtpav_irqh, IRQF_DISABLED, "MOTU MTPAV", mcard)) {
 		snd_printk("MTVAP IRQ %d busy\n", irq);
 		return -EBUSY;
 	}

commit 7152447df98b3981d621224be947a2c8d77aed06
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Thu Apr 13 12:58:06 2006 +0200

    [ALSA] unregister platform device again if probe was unsuccessful
    
    This second one unregisters the platform device again when the probe is
    unsuccesful for sound/drivers, sound/arm/sa11xx-uda1341.c and
    sound/ppc/powermac.c. This gets them all.
    
    Signed-off-by: Rene Herman <rene.herman@keyaccess.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index b7a0b42813e1..474eed06e70f 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -770,11 +770,15 @@ static int __init alsa_card_mtpav_init(void)
 		return err;
 
 	device = platform_device_register_simple(SND_MTPAV_DRIVER, -1, NULL, 0);
-	if (IS_ERR(device)) {
-		platform_driver_unregister(&snd_mtpav_driver);
-		return PTR_ERR(device);
-	}
-	return 0;
+	if (!IS_ERR(device)) {
+		if (platform_get_drvdata(device))
+			return 0;
+		platform_device_unregister(device);
+		err = -ENODEV;
+	} else
+		err = PTR_ERR(device);
+	platform_driver_unregister(&snd_mtpav_driver);
+	return err;
 }
 
 static void __exit alsa_card_mtpav_exit(void)

commit f7a9275d949cb0bf1f259a1546e52a0bf518151c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Dec 7 09:13:42 2005 +0100

    [ALSA] unregister platform devices
    
    Call platform_device_unregister() for all platform devices that we've
    registered.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index d9c4e224fa5f..b7a0b42813e1 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -95,6 +95,8 @@ MODULE_PARM_DESC(irq, "Parallel IRQ # for MotuMTPAV MIDI.");
 module_param(hwports, int, 0444);
 MODULE_PARM_DESC(hwports, "Hardware ports # for MotuMTPAV MIDI.");
 
+static struct platform_device *device;
+
 /*
  *      defines
  */
@@ -763,7 +765,6 @@ static struct platform_driver snd_mtpav_driver = {
 static int __init alsa_card_mtpav_init(void)
 {
 	int err;
-	struct platform_device *device;
 
 	if ((err = platform_driver_register(&snd_mtpav_driver)) < 0)
 		return err;
@@ -778,6 +779,7 @@ static int __init alsa_card_mtpav_init(void)
 
 static void __exit alsa_card_mtpav_exit(void)
 {
+	platform_device_unregister(device);
 	platform_driver_unregister(&snd_mtpav_driver);
 }
 

commit 077d0ac5b63185abb848ae81e2949a1e9aedc1bb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 16:02:15 2005 +0100

    [ALSA] mtpav - Use platform_device
    
    Modules: Generic drivers
    
    Rewrite the probe/remove code using platform_device.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index d32d5f6eee39..d9c4e224fa5f 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -53,6 +53,8 @@
 #include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/ioport.h>
 #include <linux/moduleparam.h>
@@ -125,16 +127,16 @@ MODULE_PARM_DESC(hwports, "Hardware ports # for MotuMTPAV MIDI.");
 /*
  */
 
-typedef struct mtpav_port {
+struct mtpav_port {
 	u8 number;
 	u8 hwport;
 	u8 mode;
 	u8 running_status;
 	struct snd_rawmidi_substream *input;
 	struct snd_rawmidi_substream *output;
-} mtpav_port_t;
+};
 
-typedef struct mtpav {
+struct mtpav {
 	struct snd_card *card;
 	unsigned long port;
 	struct resource *res_port;
@@ -145,21 +147,15 @@ typedef struct mtpav {
 	struct timer_list timer;	/* timer interrupts for outputs */
 	struct snd_rawmidi *rmidi;
 	int num_ports;		/* number of hw ports (1-8) */
-	mtpav_port_t ports[NUMPORTS];	/* all ports including computer, adat and bc */
+	struct mtpav_port ports[NUMPORTS];	/* all ports including computer, adat and bc */
 
 	u32 inmidiport;		/* selected input midi port */
 	u32 inmidistate;	/* during midi command 0xf5 */
 
 	u32 outmidihwport;	/* selected output midi hw port */
-} mtpav_t;
+};
 
 
-/*
- * global instance
- * hey, we handle at most only one card..
- */
-static mtpav_t *mtp_card;
-
 /*
  * possible hardware ports (selected by 0xf5 port message)
  *      0x00		all ports
@@ -183,7 +179,7 @@ static mtpav_t *mtp_card;
 #define MTPAV_PIDX_BROADCAST	2
 
 
-static int translate_subdevice_to_hwport(mtpav_t *chip, int subdev)
+static int translate_subdevice_to_hwport(struct mtpav *chip, int subdev)
 {
 	if (subdev < 0)
 		return 0x01; /* invalid - use port 0 as default */
@@ -198,7 +194,7 @@ static int translate_subdevice_to_hwport(mtpav_t *chip, int subdev)
 	return 0; /* all ports */
 }
 
-static int translate_hwport_to_subdevice(mtpav_t *chip, int hwport)
+static int translate_hwport_to_subdevice(struct mtpav *chip, int hwport)
 {
 	int p;
 	if (hwport <= 0x00) /* all ports */
@@ -223,7 +219,7 @@ static int translate_hwport_to_subdevice(mtpav_t *chip, int hwport)
 /*
  */
 
-static u8 snd_mtpav_getreg(mtpav_t *chip, u16 reg)
+static u8 snd_mtpav_getreg(struct mtpav *chip, u16 reg)
 {
 	u8 rval = 0;
 
@@ -241,19 +237,16 @@ static u8 snd_mtpav_getreg(mtpav_t *chip, u16 reg)
 /*
  */
 
-static void snd_mtpav_mputreg(mtpav_t *chip, u16 reg, u8 val)
+static inline void snd_mtpav_mputreg(struct mtpav *chip, u16 reg, u8 val)
 {
-	if (reg == DREG) {
-		outb(val, chip->port + DREG);
-	} else if (reg == CREG) {
-		outb(val, chip->port + CREG);
-	}
+	if (reg == DREG || reg == CREG)
+		outb(val, chip->port + reg);
 }
 
 /*
  */
 
-static void snd_mtpav_wait_rfdhi(mtpav_t *chip)
+static void snd_mtpav_wait_rfdhi(struct mtpav *chip)
 {
 	int counts = 10000;
 	u8 sbyte;
@@ -265,7 +258,7 @@ static void snd_mtpav_wait_rfdhi(mtpav_t *chip)
 	}
 }
 
-static void snd_mtpav_send_byte(mtpav_t *chip, u8 byte)
+static void snd_mtpav_send_byte(struct mtpav *chip, u8 byte)
 {
 	u8 tcbyt;
 	u8 clrwrite;
@@ -291,7 +284,8 @@ static void snd_mtpav_send_byte(mtpav_t *chip, u8 byte)
  */
 
 /* call this with spin lock held */
-static void snd_mtpav_output_port_write(mtpav_port_t *port,
+static void snd_mtpav_output_port_write(struct mtpav *mtp_card,
+					struct mtpav_port *portp,
 					struct snd_rawmidi_substream *substream)
 {
 	u8 outbyte;
@@ -303,22 +297,22 @@ static void snd_mtpav_output_port_write(mtpav_port_t *port,
 
 	// send port change command if necessary
 
-	if (port->hwport != mtp_card->outmidihwport) {
-		mtp_card->outmidihwport = port->hwport;
+	if (portp->hwport != mtp_card->outmidihwport) {
+		mtp_card->outmidihwport = portp->hwport;
 
 		snd_mtpav_send_byte(mtp_card, 0xf5);
-		snd_mtpav_send_byte(mtp_card, port->hwport);
-		//snd_printk("new outport: 0x%x\n", (unsigned int) port->hwport);
+		snd_mtpav_send_byte(mtp_card, portp->hwport);
+		//snd_printk("new outport: 0x%x\n", (unsigned int) portp->hwport);
 
-		if (!(outbyte & 0x80) && port->running_status)
-			snd_mtpav_send_byte(mtp_card, port->running_status);
+		if (!(outbyte & 0x80) && portp->running_status)
+			snd_mtpav_send_byte(mtp_card, portp->running_status);
 	}
 
 	// send data
 
 	do {
 		if (outbyte & 0x80)
-			port->running_status = outbyte;
+			portp->running_status = outbyte;
 		
 		snd_mtpav_send_byte(mtp_card, outbyte);
 	} while (snd_rawmidi_transmit(substream, &outbyte, 1) == 1);
@@ -326,11 +320,12 @@ static void snd_mtpav_output_port_write(mtpav_port_t *port,
 
 static void snd_mtpav_output_write(struct snd_rawmidi_substream *substream)
 {
-	mtpav_port_t *port = &mtp_card->ports[substream->number];
+	struct mtpav *mtp_card = substream->rmidi->private_data;
+	struct mtpav_port *portp = &mtp_card->ports[substream->number];
 	unsigned long flags;
 
 	spin_lock_irqsave(&mtp_card->spinlock, flags);
-	snd_mtpav_output_port_write(port, substream);
+	snd_mtpav_output_port_write(mtp_card, portp, substream);
 	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
 }
 
@@ -339,7 +334,7 @@ static void snd_mtpav_output_write(struct snd_rawmidi_substream *substream)
  *      mtpav control
  */
 
-static void snd_mtpav_portscan(mtpav_t *chip)	// put mtp into smart routing mode
+static void snd_mtpav_portscan(struct mtpav *chip)	// put mtp into smart routing mode
 {
 	u8 p;
 
@@ -355,10 +350,10 @@ static void snd_mtpav_portscan(mtpav_t *chip)	// put mtp into smart routing mode
 
 static int snd_mtpav_input_open(struct snd_rawmidi_substream *substream)
 {
+	struct mtpav *mtp_card = substream->rmidi->private_data;
+	struct mtpav_port *portp = &mtp_card->ports[substream->number];
 	unsigned long flags;
-	mtpav_port_t *portp = &mtp_card->ports[substream->number];
 
-	//printk("mtpav port: %d opened\n", (int) substream->number);
 	spin_lock_irqsave(&mtp_card->spinlock, flags);
 	portp->mode |= MTPAV_MODE_INPUT_OPENED;
 	portp->input = substream;
@@ -373,18 +368,15 @@ static int snd_mtpav_input_open(struct snd_rawmidi_substream *substream)
 
 static int snd_mtpav_input_close(struct snd_rawmidi_substream *substream)
 {
+	struct mtpav *mtp_card = substream->rmidi->private_data;
+	struct mtpav_port *portp = &mtp_card->ports[substream->number];
 	unsigned long flags;
-	mtpav_port_t *portp = &mtp_card->ports[substream->number];
-
-	//printk("mtpav port: %d closed\n", (int) portp);
 
 	spin_lock_irqsave(&mtp_card->spinlock, flags);
-
-	portp->mode &= (~MTPAV_MODE_INPUT_OPENED);
+	portp->mode &= ~MTPAV_MODE_INPUT_OPENED;
 	portp->input = NULL;
 	if (--mtp_card->share_irq == 0)
 		snd_mtpav_mputreg(mtp_card, CREG, 0);	// disable pport interrupts
-
 	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
 	return 0;
 }
@@ -394,8 +386,9 @@ static int snd_mtpav_input_close(struct snd_rawmidi_substream *substream)
 
 static void snd_mtpav_input_trigger(struct snd_rawmidi_substream *substream, int up)
 {
+	struct mtpav *mtp_card = substream->rmidi->private_data;
+	struct mtpav_port *portp = &mtp_card->ports[substream->number];
 	unsigned long flags;
-	mtpav_port_t *portp = &mtp_card->ports[substream->number];
 
 	spin_lock_irqsave(&mtp_card->spinlock, flags);
 	if (up)
@@ -414,7 +407,7 @@ static void snd_mtpav_input_trigger(struct snd_rawmidi_substream *substream, int
 static void snd_mtpav_output_timer(unsigned long data)
 {
 	unsigned long flags;
-	mtpav_t *chip = (mtpav_t *)data;
+	struct mtpav *chip = (struct mtpav *)data;
 	int p;
 
 	spin_lock_irqsave(&chip->spinlock, flags);
@@ -423,25 +416,22 @@ static void snd_mtpav_output_timer(unsigned long data)
 	add_timer(&chip->timer);
 	/* process each port */
 	for (p = 0; p <= chip->num_ports * 2 + MTPAV_PIDX_BROADCAST; p++) {
-		mtpav_port_t *portp = &mtp_card->ports[p];
+		struct mtpav_port *portp = &chip->ports[p];
 		if ((portp->mode & MTPAV_MODE_OUTPUT_TRIGGERED) && portp->output)
-			snd_mtpav_output_port_write(portp, portp->output);
+			snd_mtpav_output_port_write(chip, portp, portp->output);
 	}
 	spin_unlock_irqrestore(&chip->spinlock, flags);
 }
 
 /* spinlock held! */
-static void snd_mtpav_add_output_timer(mtpav_t *chip)
+static void snd_mtpav_add_output_timer(struct mtpav *chip)
 {
-	init_timer(&chip->timer);
-	chip->timer.function = snd_mtpav_output_timer;
-	chip->timer.data = (unsigned long) mtp_card;
 	chip->timer.expires = 1 + jiffies;
 	add_timer(&chip->timer);
 }
 
 /* spinlock held! */
-static void snd_mtpav_remove_output_timer(mtpav_t *chip)
+static void snd_mtpav_remove_output_timer(struct mtpav *chip)
 {
 	del_timer(&chip->timer);
 }
@@ -451,8 +441,9 @@ static void snd_mtpav_remove_output_timer(mtpav_t *chip)
 
 static int snd_mtpav_output_open(struct snd_rawmidi_substream *substream)
 {
+	struct mtpav *mtp_card = substream->rmidi->private_data;
+	struct mtpav_port *portp = &mtp_card->ports[substream->number];
 	unsigned long flags;
-	mtpav_port_t *portp = &mtp_card->ports[substream->number];
 
 	spin_lock_irqsave(&mtp_card->spinlock, flags);
 	portp->mode |= MTPAV_MODE_OUTPUT_OPENED;
@@ -466,11 +457,12 @@ static int snd_mtpav_output_open(struct snd_rawmidi_substream *substream)
 
 static int snd_mtpav_output_close(struct snd_rawmidi_substream *substream)
 {
+	struct mtpav *mtp_card = substream->rmidi->private_data;
+	struct mtpav_port *portp = &mtp_card->ports[substream->number];
 	unsigned long flags;
-	mtpav_port_t *portp = &mtp_card->ports[substream->number];
 
 	spin_lock_irqsave(&mtp_card->spinlock, flags);
-	portp->mode &= (~MTPAV_MODE_OUTPUT_OPENED);
+	portp->mode &= ~MTPAV_MODE_OUTPUT_OPENED;
 	portp->output = NULL;
 	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
 	return 0;
@@ -481,12 +473,13 @@ static int snd_mtpav_output_close(struct snd_rawmidi_substream *substream)
 
 static void snd_mtpav_output_trigger(struct snd_rawmidi_substream *substream, int up)
 {
+	struct mtpav *mtp_card = substream->rmidi->private_data;
+	struct mtpav_port *portp = &mtp_card->ports[substream->number];
 	unsigned long flags;
-	mtpav_port_t *portp = &mtp_card->ports[substream->number];
 
 	spin_lock_irqsave(&mtp_card->spinlock, flags);
 	if (up) {
-		if (! (portp->mode  & MTPAV_MODE_OUTPUT_TRIGGERED)) {
+		if (! (portp->mode & MTPAV_MODE_OUTPUT_TRIGGERED)) {
 			if (mtp_card->istimer++ == 0)
 				snd_mtpav_add_output_timer(mtp_card);
 			portp->mode |= MTPAV_MODE_OUTPUT_TRIGGERED;
@@ -506,23 +499,20 @@ static void snd_mtpav_output_trigger(struct snd_rawmidi_substream *substream, in
  * midi interrupt for inputs
  */
 
-static void snd_mtpav_inmidi_process(mtpav_t *mcrd, u8 inbyte)
+static void snd_mtpav_inmidi_process(struct mtpav *mcrd, u8 inbyte)
 {
-	mtpav_port_t *portp;
+	struct mtpav_port *portp;
 
 	if ((int)mcrd->inmidiport > mcrd->num_ports * 2 + MTPAV_PIDX_BROADCAST)
 		return;
 
 	portp = &mcrd->ports[mcrd->inmidiport];
-	if (portp->mode & MTPAV_MODE_INPUT_TRIGGERED) {
+	if (portp->mode & MTPAV_MODE_INPUT_TRIGGERED)
 		snd_rawmidi_receive(portp->input, &inbyte, 1);
-	}
 }
 
-static void snd_mtpav_inmidi_h(mtpav_t * mcrd, u8 inbyte)
+static void snd_mtpav_inmidi_h(struct mtpav *mcrd, u8 inbyte)
 {
-	snd_assert(mcrd, return);
-
 	if (inbyte >= 0xf8) {
 		/* real-time midi code */
 		snd_mtpav_inmidi_process(mcrd, inbyte);
@@ -540,7 +530,7 @@ static void snd_mtpav_inmidi_h(mtpav_t * mcrd, u8 inbyte)
 	}
 }
 
-static void snd_mtpav_read_bytes(mtpav_t * mcrd)
+static void snd_mtpav_read_bytes(struct mtpav *mcrd)
 {
 	u8 clrread, setread;
 	u8 mtp_read_byte;
@@ -580,9 +570,8 @@ static void snd_mtpav_read_bytes(mtpav_t * mcrd)
 
 static irqreturn_t snd_mtpav_irqh(int irq, void *dev_id, struct pt_regs *regs)
 {
-	mtpav_t *mcard = dev_id;
+	struct mtpav *mcard = dev_id;
 
-	//printk("irqh()\n");
 	spin_lock(&mcard->spinlock);
 	snd_mtpav_read_bytes(mcard);
 	spin_unlock(&mcard->spinlock);
@@ -592,14 +581,14 @@ static irqreturn_t snd_mtpav_irqh(int irq, void *dev_id, struct pt_regs *regs)
 /*
  * get ISA resources
  */
-static int snd_mtpav_get_ISA(mtpav_t * mcard)
+static int __init snd_mtpav_get_ISA(struct mtpav * mcard)
 {
 	if ((mcard->res_port = request_region(port, 3, "MotuMTPAV MIDI")) == NULL) {
 		snd_printk("MTVAP port 0x%lx is busy\n", port);
 		return -EBUSY;
 	}
 	mcard->port = port;
-	if (request_irq(irq, snd_mtpav_irqh, SA_INTERRUPT, "MOTU MTPAV", (void *)mcard)) {
+	if (request_irq(irq, snd_mtpav_irqh, SA_INTERRUPT, "MOTU MTPAV", mcard)) {
 		snd_printk("MTVAP IRQ %d busy\n", irq);
 		return -EBUSY;
 	}
@@ -628,7 +617,8 @@ static struct snd_rawmidi_ops snd_mtpav_input = {
  * get RAWMIDI resources
  */
 
-static void snd_mtpav_set_name(mtpav_t *chip, struct snd_rawmidi_substream *substream)
+static void __init snd_mtpav_set_name(struct mtpav *chip,
+				      struct snd_rawmidi_substream *substream)
 {
 	if (substream->number >= 0 && substream->number < chip->num_ports)
 		sprintf(substream->name, "MTP direct %d", (substream->number % chip->num_ports) + 1);
@@ -642,21 +632,18 @@ static void snd_mtpav_set_name(mtpav_t *chip, struct snd_rawmidi_substream *subs
 		strcpy(substream->name, "MTP broadcast");
 }
 
-static int snd_mtpav_get_RAWMIDI(mtpav_t * mcard)
+static int __init snd_mtpav_get_RAWMIDI(struct mtpav *mcard)
 {
-	int rval = 0;
+	int rval;
 	struct snd_rawmidi *rawmidi;
 	struct snd_rawmidi_substream *substream;
 	struct list_head *list;
 
-	//printk("entering snd_mtpav_get_RAWMIDI\n");
-
 	if (hwports < 1)
-		mcard->num_ports = 1;
+		hwports = 1;
 	else if (hwports > 8)
-		mcard->num_ports = 8;
-	else
-		mcard->num_ports = hwports;
+		hwports = 8;
+	mcard->num_ports = hwports;
 
 	if ((rval = snd_rawmidi_new(mcard->card, "MotuMIDI", 0,
 				    mcard->num_ports * 2 + MTPAV_PIDX_BROADCAST + 1,
@@ -664,6 +651,7 @@ static int snd_mtpav_get_RAWMIDI(mtpav_t * mcard)
 				    &mcard->rmidi)) < 0)
 		return rval;
 	rawmidi = mcard->rmidi;
+	rawmidi->private_data = mcard;
 
 	list_for_each(list, &rawmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams) {
 		substream = list_entry(list, struct snd_rawmidi_substream, list);
@@ -679,36 +667,15 @@ static int snd_mtpav_get_RAWMIDI(mtpav_t * mcard)
 	rawmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT |
 			       SNDRV_RAWMIDI_INFO_DUPLEX;
 	sprintf(rawmidi->name, "MTP AV MIDI");
-	//printk("exiting snd_mtpav_get_RAWMIDI() \n");
 	return 0;
 }
 
 /*
  */
 
-static mtpav_t *new_mtpav(void)
-{
-	mtpav_t *ncrd = kzalloc(sizeof(*ncrd), GFP_KERNEL);
-	if (ncrd != NULL) {
-		spin_lock_init(&ncrd->spinlock);
-
-		init_timer(&ncrd->timer);
-		ncrd->card = NULL;
-		ncrd->irq = -1;
-		ncrd->share_irq = 0;
-
-		ncrd->inmidiport = 0xffffffff;
-		ncrd->inmidistate = 0;
-		ncrd->outmidihwport = 0xffffffff;
-	}
-	return ncrd;
-}
-
-/*
- */
-
-static void free_mtpav(mtpav_t * crd)
+static void snd_mtpav_free(struct snd_card *card)
 {
+	struct mtpav *crd = card->private_data;
 	unsigned long flags;
 
 	spin_lock_irqsave(&crd->spinlock, flags);
@@ -718,78 +685,101 @@ static void free_mtpav(mtpav_t * crd)
 	if (crd->irq >= 0)
 		free_irq(crd->irq, (void *)crd);
 	release_and_free_resource(crd->res_port);
-	kfree(crd);
 }
 
 /*
  */
-
-static int __init alsa_card_mtpav_init(void)
+static int __init snd_mtpav_probe(struct platform_device *dev)
 {
-	int err = 0;
-	char longname_buffer[80];
+	struct snd_card *card;
+	int err;
+	struct mtpav *mtp_card;
 
-	mtp_card = new_mtpav();
-	if (mtp_card == NULL)
+	card = snd_card_new(index, id, THIS_MODULE, sizeof(*mtp_card));
+	if (! card)
 		return -ENOMEM;
 
-	mtp_card->card = snd_card_new(index, id, THIS_MODULE, 0);
-	if (mtp_card->card == NULL) {
-		free_mtpav(mtp_card);
-		return -ENOMEM;
-	}
+	mtp_card = card->private_data;
+	spin_lock_init(&mtp_card->spinlock);
+	init_timer(&mtp_card->timer);
+	mtp_card->card = card;
+	mtp_card->irq = -1;
+	mtp_card->share_irq = 0;
+	mtp_card->inmidiport = 0xffffffff;
+	mtp_card->inmidistate = 0;
+	mtp_card->outmidihwport = 0xffffffff;
+	init_timer(&mtp_card->timer);
+	mtp_card->timer.function = snd_mtpav_output_timer;
+	mtp_card->timer.data = (unsigned long) mtp_card;
+
+	card->private_free = snd_mtpav_free;
 
 	err = snd_mtpav_get_ISA(mtp_card);
-	//printk("snd_mtpav_get_ISA returned: %d\n", err);
 	if (err < 0)
 		goto __error;
 
-	strcpy(mtp_card->card->driver, "MTPAV");
-	strcpy(mtp_card->card->shortname, "MTPAV on parallel port");
-	memset(longname_buffer, 0, sizeof(longname_buffer));
-	sprintf(longname_buffer, "MTPAV on parallel port at");
+	strcpy(card->driver, "MTPAV");
+	strcpy(card->shortname, "MTPAV on parallel port");
+	snprintf(card->longname, sizeof(card->longname),
+		 "MTPAV on parallel port at 0x%lx", port);
 
 	err = snd_mtpav_get_RAWMIDI(mtp_card);
-	//snd_printk("snd_mtapv_get_RAWMIDI returned: %d\n", err);
 	if (err < 0)
 		goto __error;
 
-	if ((err = snd_card_set_generic_dev(mtp_card->card)) < 0)
-		goto __error;
-
-	err = snd_card_register(mtp_card->card);	// don't snd_card_register until AFTER all cards reources done!
+	snd_mtpav_portscan(mtp_card);
 
-	//printk("snd_card_register returned %d\n", err);
+	snd_card_set_dev(card, &dev->dev);
+	err = snd_card_register(mtp_card->card);
 	if (err < 0)
 		goto __error;
 
-
-	snd_mtpav_portscan(mtp_card);
-
+	platform_set_drvdata(dev, card);
 	printk(KERN_INFO "Motu MidiTimePiece on parallel port irq: %d ioport: 0x%lx\n", irq, port);
-
 	return 0;
 
-      __error:
-	snd_card_free(mtp_card->card);
-	free_mtpav(mtp_card);
+ __error:
+	snd_card_free(card);
 	return err;
 }
 
-/*
- */
+static int snd_mtpav_remove(struct platform_device *devptr)
+{
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+	return 0;
+}
 
-static void __exit alsa_card_mtpav_exit(void)
+#define SND_MTPAV_DRIVER	"snd_mtpav"
+
+static struct platform_driver snd_mtpav_driver = {
+	.probe		= snd_mtpav_probe,
+	.remove		= snd_mtpav_remove,
+	.driver		= {
+		.name	= SND_MTPAV_DRIVER
+	},
+};
+
+static int __init alsa_card_mtpav_init(void)
 {
-	if (mtp_card == NULL)
-		return;
-	if (mtp_card->card)
-		snd_card_free(mtp_card->card);
-	free_mtpav(mtp_card);
+	int err;
+	struct platform_device *device;
+
+	if ((err = platform_driver_register(&snd_mtpav_driver)) < 0)
+		return err;
+
+	device = platform_device_register_simple(SND_MTPAV_DRIVER, -1, NULL, 0);
+	if (IS_ERR(device)) {
+		platform_driver_unregister(&snd_mtpav_driver);
+		return PTR_ERR(device);
+	}
+	return 0;
 }
 
-/*
- */
+static void __exit alsa_card_mtpav_exit(void)
+{
+	platform_driver_unregister(&snd_mtpav_driver);
+}
 
 module_init(alsa_card_mtpav_init)
 module_exit(alsa_card_mtpav_exit)

commit 4a4d2cfd8cbca3076742547157ea135d0be77928
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:27:28 2005 +0100

    [ALSA] Remove xxx_t typedefs: Generic drivers
    
    Modules: Generic drivers
    
    Remove xxx_t typedefs from the generic drivers
    (dummy, mtpav, serial-u16550 and virmidi).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index e9d52c668edc..d32d5f6eee39 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -130,12 +130,12 @@ typedef struct mtpav_port {
 	u8 hwport;
 	u8 mode;
 	u8 running_status;
-	snd_rawmidi_substream_t *input;
-	snd_rawmidi_substream_t *output;
+	struct snd_rawmidi_substream *input;
+	struct snd_rawmidi_substream *output;
 } mtpav_port_t;
 
 typedef struct mtpav {
-	snd_card_t *card;
+	struct snd_card *card;
 	unsigned long port;
 	struct resource *res_port;
 	int irq;			/* interrupt (for inputs) */
@@ -143,7 +143,7 @@ typedef struct mtpav {
 	int share_irq;			/* number of accesses to input interrupts */
 	int istimer;			/* number of accesses to timer interrupts */
 	struct timer_list timer;	/* timer interrupts for outputs */
-	snd_rawmidi_t *rmidi;
+	struct snd_rawmidi *rmidi;
 	int num_ports;		/* number of hw ports (1-8) */
 	mtpav_port_t ports[NUMPORTS];	/* all ports including computer, adat and bc */
 
@@ -292,7 +292,7 @@ static void snd_mtpav_send_byte(mtpav_t *chip, u8 byte)
 
 /* call this with spin lock held */
 static void snd_mtpav_output_port_write(mtpav_port_t *port,
-					snd_rawmidi_substream_t *substream)
+					struct snd_rawmidi_substream *substream)
 {
 	u8 outbyte;
 
@@ -324,7 +324,7 @@ static void snd_mtpav_output_port_write(mtpav_port_t *port,
 	} while (snd_rawmidi_transmit(substream, &outbyte, 1) == 1);
 }
 
-static void snd_mtpav_output_write(snd_rawmidi_substream_t * substream)
+static void snd_mtpav_output_write(struct snd_rawmidi_substream *substream)
 {
 	mtpav_port_t *port = &mtp_card->ports[substream->number];
 	unsigned long flags;
@@ -353,7 +353,7 @@ static void snd_mtpav_portscan(mtpav_t *chip)	// put mtp into smart routing mode
 /*
  */
 
-static int snd_mtpav_input_open(snd_rawmidi_substream_t * substream)
+static int snd_mtpav_input_open(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
 	mtpav_port_t *portp = &mtp_card->ports[substream->number];
@@ -371,7 +371,7 @@ static int snd_mtpav_input_open(snd_rawmidi_substream_t * substream)
 /*
  */
 
-static int snd_mtpav_input_close(snd_rawmidi_substream_t *substream)
+static int snd_mtpav_input_close(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
 	mtpav_port_t *portp = &mtp_card->ports[substream->number];
@@ -392,7 +392,7 @@ static int snd_mtpav_input_close(snd_rawmidi_substream_t *substream)
 /*
  */
 
-static void snd_mtpav_input_trigger(snd_rawmidi_substream_t * substream, int up)
+static void snd_mtpav_input_trigger(struct snd_rawmidi_substream *substream, int up)
 {
 	unsigned long flags;
 	mtpav_port_t *portp = &mtp_card->ports[substream->number];
@@ -449,7 +449,7 @@ static void snd_mtpav_remove_output_timer(mtpav_t *chip)
 /*
  */
 
-static int snd_mtpav_output_open(snd_rawmidi_substream_t * substream)
+static int snd_mtpav_output_open(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
 	mtpav_port_t *portp = &mtp_card->ports[substream->number];
@@ -464,7 +464,7 @@ static int snd_mtpav_output_open(snd_rawmidi_substream_t * substream)
 /*
  */
 
-static int snd_mtpav_output_close(snd_rawmidi_substream_t * substream)
+static int snd_mtpav_output_close(struct snd_rawmidi_substream *substream)
 {
 	unsigned long flags;
 	mtpav_port_t *portp = &mtp_card->ports[substream->number];
@@ -479,7 +479,7 @@ static int snd_mtpav_output_close(snd_rawmidi_substream_t * substream)
 /*
  */
 
-static void snd_mtpav_output_trigger(snd_rawmidi_substream_t * substream, int up)
+static void snd_mtpav_output_trigger(struct snd_rawmidi_substream *substream, int up)
 {
 	unsigned long flags;
 	mtpav_port_t *portp = &mtp_card->ports[substream->number];
@@ -611,13 +611,13 @@ static int snd_mtpav_get_ISA(mtpav_t * mcard)
 /*
  */
 
-static snd_rawmidi_ops_t snd_mtpav_output = {
+static struct snd_rawmidi_ops snd_mtpav_output = {
 	.open =		snd_mtpav_output_open,
 	.close =	snd_mtpav_output_close,
 	.trigger =	snd_mtpav_output_trigger,
 };
 
-static snd_rawmidi_ops_t snd_mtpav_input = {
+static struct snd_rawmidi_ops snd_mtpav_input = {
 	.open =		snd_mtpav_input_open,
 	.close =	snd_mtpav_input_close,
 	.trigger =	snd_mtpav_input_trigger,
@@ -628,7 +628,7 @@ static snd_rawmidi_ops_t snd_mtpav_input = {
  * get RAWMIDI resources
  */
 
-static void snd_mtpav_set_name(mtpav_t *chip, snd_rawmidi_substream_t *substream)
+static void snd_mtpav_set_name(mtpav_t *chip, struct snd_rawmidi_substream *substream)
 {
 	if (substream->number >= 0 && substream->number < chip->num_ports)
 		sprintf(substream->name, "MTP direct %d", (substream->number % chip->num_ports) + 1);
@@ -645,8 +645,8 @@ static void snd_mtpav_set_name(mtpav_t *chip, snd_rawmidi_substream_t *substream
 static int snd_mtpav_get_RAWMIDI(mtpav_t * mcard)
 {
 	int rval = 0;
-	snd_rawmidi_t *rawmidi;
-	snd_rawmidi_substream_t *substream;
+	struct snd_rawmidi *rawmidi;
+	struct snd_rawmidi_substream *substream;
 	struct list_head *list;
 
 	//printk("entering snd_mtpav_get_RAWMIDI\n");
@@ -666,12 +666,12 @@ static int snd_mtpav_get_RAWMIDI(mtpav_t * mcard)
 	rawmidi = mcard->rmidi;
 
 	list_for_each(list, &rawmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams) {
-		substream = list_entry(list, snd_rawmidi_substream_t, list);
+		substream = list_entry(list, struct snd_rawmidi_substream, list);
 		snd_mtpav_set_name(mcard, substream);
 		substream->ops = &snd_mtpav_input;
 	}
 	list_for_each(list, &rawmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams) {
-		substream = list_entry(list, snd_rawmidi_substream_t, list);
+		substream = list_entry(list, struct snd_rawmidi_substream, list);
 		snd_mtpav_set_name(mcard, substream);
 		substream->ops = &snd_mtpav_output;
 		mcard->ports[substream->number].hwport = translate_subdevice_to_hwport(mcard, substream->number);

commit b1d5776d865951c213a1caaab5d8bf5de7615dbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:56:31 2005 +0200

    [ALSA] Remove vmalloc wrapper, kfree_nocheck()
    
    - Remove vmalloc wrapper
    - Add release_and_free_resource() to remove kfree_nocheck() from each driver
      and simplify the code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 3a25c89d2983..e9d52c668edc 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -717,10 +717,7 @@ static void free_mtpav(mtpav_t * crd)
 	spin_unlock_irqrestore(&crd->spinlock, flags);
 	if (crd->irq >= 0)
 		free_irq(crd->irq, (void *)crd);
-	if (crd->res_port) {
-		release_resource(crd->res_port);
-		kfree_nocheck(crd->res_port);
-	}
+	release_and_free_resource(crd->res_port);
 	kfree(crd);
 }
 

commit 561b220a4dece18d67177413e6fa21b49aa4acce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:22:34 2005 +0200

    [ALSA] Replace with kzalloc() - others
    
    Documentation,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,OPL3
    OPL4,Digigram VX core,I2C cs8427,I2C lib core,I2C tea6330t,L3 drivers
    AK4114 receiver,AK4117 receiver,PDAudioCF driver,PPC PMAC driver
    SPARC AMD7930 driver,SPARC cs4231 driver,Synth,Common EMU synth
    USB generic driver,USB USX2Y
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index b8199d20be82..3a25c89d2983 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -688,7 +688,7 @@ static int snd_mtpav_get_RAWMIDI(mtpav_t * mcard)
 
 static mtpav_t *new_mtpav(void)
 {
-	mtpav_t *ncrd = kcalloc(1, sizeof(*ncrd), GFP_KERNEL);
+	mtpav_t *ncrd = kzalloc(sizeof(*ncrd), GFP_KERNEL);
 	if (ncrd != NULL) {
 		spin_lock_init(&ncrd->spinlock);
 

commit 16dab54b8cbac39bd3f639db5d7d0fd8300a6cb0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 5 17:17:58 2005 +0200

    [ALSA] Add snd_card_set_generic_dev() call
    
    ARM,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,MIPS
    MIPS AU1x00 driver,PPC,PPC PowerMac driver,SPARC,SPARC AMD7930 driver
    SPARC cs4231 driver,SPARC DBRI driver
    - Added snd_card_set_generic_dev() call.
    - Added SND_GENERIC_DRIVER to Kconfig.
    - Clean up the error path in probe if necessary.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
index 1280a57c49eb..b8199d20be82 100644
--- a/sound/drivers/mtpav.c
+++ b/sound/drivers/mtpav.c
@@ -757,6 +757,9 @@ static int __init alsa_card_mtpav_init(void)
 	if (err < 0)
 		goto __error;
 
+	if ((err = snd_card_set_generic_dev(mtp_card->card)) < 0)
+		goto __error;
+
 	err = snd_card_register(mtp_card->card);	// don't snd_card_register until AFTER all cards reources done!
 
 	//printk("snd_card_register returned %d\n", err);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/drivers/mtpav.c b/sound/drivers/mtpav.c
new file mode 100644
index 000000000000..1280a57c49eb
--- /dev/null
+++ b/sound/drivers/mtpav.c
@@ -0,0 +1,795 @@
+/*
+ *      MOTU Midi Timepiece ALSA Main routines
+ *      Copyright by Michael T. Mayers (c) Jan 09, 2000
+ *      mail: michael@tweakoz.com
+ *      Thanks to John Galbraith
+ *
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this program; if not, write to the Free Software
+ *      Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *
+ *      This driver is for the 'Mark Of The Unicorn' (MOTU)
+ *      MidiTimePiece AV multiport MIDI interface 
+ *
+ *      IOPORTS
+ *      -------
+ *      8 MIDI Ins and 8 MIDI outs
+ *      Video Sync In (BNC), Word Sync Out (BNC), 
+ *      ADAT Sync Out (DB9)
+ *      SMPTE in/out (1/4")
+ *      2 programmable pedal/footswitch inputs and 4 programmable MIDI controller knobs.
+ *      Macintosh RS422 serial port
+ *      RS422 "network" port for ganging multiple MTP's
+ *      PC Parallel Port ( which this driver currently uses )
+ *
+ *      MISC FEATURES
+ *      -------------
+ *      Hardware MIDI routing, merging, and filtering   
+ *      MIDI Synchronization to Video, ADAT, SMPTE and other Clock sources
+ *      128 'scene' memories, recallable from MIDI program change
+ *
+ *
+ * ChangeLog
+ * Jun 11 2001	Takashi Iwai <tiwai@suse.de>
+ *      - Recoded & debugged
+ *      - Added timer interrupt for midi outputs
+ *      - hwports is between 1 and 8, which specifies the number of hardware ports.
+ *        The three global ports, computer, adat and broadcast ports, are created
+ *        always after h/w and remote ports.
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/rawmidi.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+
+/*
+ *      globals
+ */
+MODULE_AUTHOR("Michael T. Mayers");
+MODULE_DESCRIPTION("MOTU MidiTimePiece AV multiport MIDI");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{MOTU,MidiTimePiece AV multiport MIDI}}");
+
+// io resources
+#define MTPAV_IOBASE		0x378
+#define MTPAV_IRQ		7
+#define MTPAV_MAX_PORTS		8
+
+static int index = SNDRV_DEFAULT_IDX1;
+static char *id = SNDRV_DEFAULT_STR1;
+static long port = MTPAV_IOBASE;	/* 0x378, 0x278 */
+static int irq = MTPAV_IRQ;		/* 7, 5 */
+static int hwports = MTPAV_MAX_PORTS;	/* use hardware ports 1-8 */
+
+module_param(index, int, 0444);
+MODULE_PARM_DESC(index, "Index value for MotuMTPAV MIDI.");
+module_param(id, charp, 0444);
+MODULE_PARM_DESC(id, "ID string for MotuMTPAV MIDI.");
+module_param(port, long, 0444);
+MODULE_PARM_DESC(port, "Parallel port # for MotuMTPAV MIDI.");
+module_param(irq, int, 0444);
+MODULE_PARM_DESC(irq, "Parallel IRQ # for MotuMTPAV MIDI.");
+module_param(hwports, int, 0444);
+MODULE_PARM_DESC(hwports, "Hardware ports # for MotuMTPAV MIDI.");
+
+/*
+ *      defines
+ */
+//#define USE_FAKE_MTP //       don't actually read/write to MTP device (for debugging without an actual unit) (does not work yet)
+
+// parallel port usage masks
+#define SIGS_BYTE 0x08
+#define SIGS_RFD 0x80
+#define SIGS_IRQ 0x40
+#define SIGS_IN0 0x10
+#define SIGS_IN1 0x20
+
+#define SIGC_WRITE 0x04
+#define SIGC_READ 0x08
+#define SIGC_INTEN 0x10
+
+#define DREG 0
+#define SREG 1
+#define CREG 2
+
+//
+#define MTPAV_MODE_INPUT_OPENED		0x01
+#define MTPAV_MODE_OUTPUT_OPENED	0x02
+#define MTPAV_MODE_INPUT_TRIGGERED	0x04
+#define MTPAV_MODE_OUTPUT_TRIGGERED	0x08
+
+#define NUMPORTS (0x12+1)
+
+
+/*
+ */
+
+typedef struct mtpav_port {
+	u8 number;
+	u8 hwport;
+	u8 mode;
+	u8 running_status;
+	snd_rawmidi_substream_t *input;
+	snd_rawmidi_substream_t *output;
+} mtpav_port_t;
+
+typedef struct mtpav {
+	snd_card_t *card;
+	unsigned long port;
+	struct resource *res_port;
+	int irq;			/* interrupt (for inputs) */
+	spinlock_t spinlock;
+	int share_irq;			/* number of accesses to input interrupts */
+	int istimer;			/* number of accesses to timer interrupts */
+	struct timer_list timer;	/* timer interrupts for outputs */
+	snd_rawmidi_t *rmidi;
+	int num_ports;		/* number of hw ports (1-8) */
+	mtpav_port_t ports[NUMPORTS];	/* all ports including computer, adat and bc */
+
+	u32 inmidiport;		/* selected input midi port */
+	u32 inmidistate;	/* during midi command 0xf5 */
+
+	u32 outmidihwport;	/* selected output midi hw port */
+} mtpav_t;
+
+
+/*
+ * global instance
+ * hey, we handle at most only one card..
+ */
+static mtpav_t *mtp_card;
+
+/*
+ * possible hardware ports (selected by 0xf5 port message)
+ *      0x00		all ports
+ *      0x01 .. 0x08    this MTP's ports 1..8
+ *      0x09 .. 0x10    networked MTP's ports (9..16)
+ *      0x11            networked MTP's computer port
+ *      0x63            to ADAT
+ *
+ * mappig:
+ *  subdevice 0 - (X-1)    ports
+ *            X - (2*X-1)  networked ports
+ *            X            computer
+ *            X+1          ADAT
+ *            X+2          all ports
+ *
+ *  where X = chip->num_ports
+ */
+
+#define MTPAV_PIDX_COMPUTER	0
+#define MTPAV_PIDX_ADAT		1
+#define MTPAV_PIDX_BROADCAST	2
+
+
+static int translate_subdevice_to_hwport(mtpav_t *chip, int subdev)
+{
+	if (subdev < 0)
+		return 0x01; /* invalid - use port 0 as default */
+	else if (subdev < chip->num_ports)
+		return subdev + 1; /* single mtp port */
+	else if (subdev < chip->num_ports * 2)
+		return subdev - chip->num_ports + 0x09; /* remote port */
+	else if (subdev == chip->num_ports * 2 + MTPAV_PIDX_COMPUTER)
+		return 0x11; /* computer port */
+	else if (subdev == chip->num_ports + MTPAV_PIDX_ADAT)
+		return 0x63;		/* ADAT */
+	return 0; /* all ports */
+}
+
+static int translate_hwport_to_subdevice(mtpav_t *chip, int hwport)
+{
+	int p;
+	if (hwport <= 0x00) /* all ports */
+		return chip->num_ports + MTPAV_PIDX_BROADCAST;
+	else if (hwport <= 0x08) { /* single port */
+		p = hwport - 1;
+		if (p >= chip->num_ports)
+			p = 0;
+		return p;
+	} else if (hwport <= 0x10) { /* remote port */
+		p = hwport - 0x09 + chip->num_ports;
+		if (p >= chip->num_ports * 2)
+			p = chip->num_ports;
+		return p;
+	} else if (hwport == 0x11)  /* computer port */
+		return chip->num_ports + MTPAV_PIDX_COMPUTER;
+	else  /* ADAT */
+		return chip->num_ports + MTPAV_PIDX_ADAT;
+}
+
+
+/*
+ */
+
+static u8 snd_mtpav_getreg(mtpav_t *chip, u16 reg)
+{
+	u8 rval = 0;
+
+	if (reg == SREG) {
+		rval = inb(chip->port + SREG);
+		rval = (rval & 0xf8);
+	} else if (reg == CREG) {
+		rval = inb(chip->port + CREG);
+		rval = (rval & 0x1c);
+	}
+
+	return rval;
+}
+
+/*
+ */
+
+static void snd_mtpav_mputreg(mtpav_t *chip, u16 reg, u8 val)
+{
+	if (reg == DREG) {
+		outb(val, chip->port + DREG);
+	} else if (reg == CREG) {
+		outb(val, chip->port + CREG);
+	}
+}
+
+/*
+ */
+
+static void snd_mtpav_wait_rfdhi(mtpav_t *chip)
+{
+	int counts = 10000;
+	u8 sbyte;
+
+	sbyte = snd_mtpav_getreg(chip, SREG);
+	while (!(sbyte & SIGS_RFD) && counts--) {
+		sbyte = snd_mtpav_getreg(chip, SREG);
+		udelay(10);
+	}
+}
+
+static void snd_mtpav_send_byte(mtpav_t *chip, u8 byte)
+{
+	u8 tcbyt;
+	u8 clrwrite;
+	u8 setwrite;
+
+	snd_mtpav_wait_rfdhi(chip);
+
+	/////////////////
+
+	tcbyt = snd_mtpav_getreg(chip, CREG);
+	clrwrite = tcbyt & (SIGC_WRITE ^ 0xff);
+	setwrite = tcbyt | SIGC_WRITE;
+
+	snd_mtpav_mputreg(chip, DREG, byte);
+	snd_mtpav_mputreg(chip, CREG, clrwrite);	// clear write bit
+
+	snd_mtpav_mputreg(chip, CREG, setwrite);	// set write bit
+
+}
+
+
+/*
+ */
+
+/* call this with spin lock held */
+static void snd_mtpav_output_port_write(mtpav_port_t *port,
+					snd_rawmidi_substream_t *substream)
+{
+	u8 outbyte;
+
+	// Get the outbyte first, so we can emulate running status if
+	// necessary
+	if (snd_rawmidi_transmit(substream, &outbyte, 1) != 1)
+		return;
+
+	// send port change command if necessary
+
+	if (port->hwport != mtp_card->outmidihwport) {
+		mtp_card->outmidihwport = port->hwport;
+
+		snd_mtpav_send_byte(mtp_card, 0xf5);
+		snd_mtpav_send_byte(mtp_card, port->hwport);
+		//snd_printk("new outport: 0x%x\n", (unsigned int) port->hwport);
+
+		if (!(outbyte & 0x80) && port->running_status)
+			snd_mtpav_send_byte(mtp_card, port->running_status);
+	}
+
+	// send data
+
+	do {
+		if (outbyte & 0x80)
+			port->running_status = outbyte;
+		
+		snd_mtpav_send_byte(mtp_card, outbyte);
+	} while (snd_rawmidi_transmit(substream, &outbyte, 1) == 1);
+}
+
+static void snd_mtpav_output_write(snd_rawmidi_substream_t * substream)
+{
+	mtpav_port_t *port = &mtp_card->ports[substream->number];
+	unsigned long flags;
+
+	spin_lock_irqsave(&mtp_card->spinlock, flags);
+	snd_mtpav_output_port_write(port, substream);
+	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
+}
+
+
+/*
+ *      mtpav control
+ */
+
+static void snd_mtpav_portscan(mtpav_t *chip)	// put mtp into smart routing mode
+{
+	u8 p;
+
+	for (p = 0; p < 8; p++) {
+		snd_mtpav_send_byte(chip, 0xf5);
+		snd_mtpav_send_byte(chip, p);
+		snd_mtpav_send_byte(chip, 0xfe);
+	}
+}
+
+/*
+ */
+
+static int snd_mtpav_input_open(snd_rawmidi_substream_t * substream)
+{
+	unsigned long flags;
+	mtpav_port_t *portp = &mtp_card->ports[substream->number];
+
+	//printk("mtpav port: %d opened\n", (int) substream->number);
+	spin_lock_irqsave(&mtp_card->spinlock, flags);
+	portp->mode |= MTPAV_MODE_INPUT_OPENED;
+	portp->input = substream;
+	if (mtp_card->share_irq++ == 0)
+		snd_mtpav_mputreg(mtp_card, CREG, (SIGC_INTEN | SIGC_WRITE));	// enable pport interrupts
+	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
+	return 0;
+}
+
+/*
+ */
+
+static int snd_mtpav_input_close(snd_rawmidi_substream_t *substream)
+{
+	unsigned long flags;
+	mtpav_port_t *portp = &mtp_card->ports[substream->number];
+
+	//printk("mtpav port: %d closed\n", (int) portp);
+
+	spin_lock_irqsave(&mtp_card->spinlock, flags);
+
+	portp->mode &= (~MTPAV_MODE_INPUT_OPENED);
+	portp->input = NULL;
+	if (--mtp_card->share_irq == 0)
+		snd_mtpav_mputreg(mtp_card, CREG, 0);	// disable pport interrupts
+
+	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
+	return 0;
+}
+
+/*
+ */
+
+static void snd_mtpav_input_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	unsigned long flags;
+	mtpav_port_t *portp = &mtp_card->ports[substream->number];
+
+	spin_lock_irqsave(&mtp_card->spinlock, flags);
+	if (up)
+		portp->mode |= MTPAV_MODE_INPUT_TRIGGERED;
+	else
+		portp->mode &= ~MTPAV_MODE_INPUT_TRIGGERED;
+	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
+
+}
+
+
+/*
+ * timer interrupt for outputs
+ */
+
+static void snd_mtpav_output_timer(unsigned long data)
+{
+	unsigned long flags;
+	mtpav_t *chip = (mtpav_t *)data;
+	int p;
+
+	spin_lock_irqsave(&chip->spinlock, flags);
+	/* reprogram timer */
+	chip->timer.expires = 1 + jiffies;
+	add_timer(&chip->timer);
+	/* process each port */
+	for (p = 0; p <= chip->num_ports * 2 + MTPAV_PIDX_BROADCAST; p++) {
+		mtpav_port_t *portp = &mtp_card->ports[p];
+		if ((portp->mode & MTPAV_MODE_OUTPUT_TRIGGERED) && portp->output)
+			snd_mtpav_output_port_write(portp, portp->output);
+	}
+	spin_unlock_irqrestore(&chip->spinlock, flags);
+}
+
+/* spinlock held! */
+static void snd_mtpav_add_output_timer(mtpav_t *chip)
+{
+	init_timer(&chip->timer);
+	chip->timer.function = snd_mtpav_output_timer;
+	chip->timer.data = (unsigned long) mtp_card;
+	chip->timer.expires = 1 + jiffies;
+	add_timer(&chip->timer);
+}
+
+/* spinlock held! */
+static void snd_mtpav_remove_output_timer(mtpav_t *chip)
+{
+	del_timer(&chip->timer);
+}
+
+/*
+ */
+
+static int snd_mtpav_output_open(snd_rawmidi_substream_t * substream)
+{
+	unsigned long flags;
+	mtpav_port_t *portp = &mtp_card->ports[substream->number];
+
+	spin_lock_irqsave(&mtp_card->spinlock, flags);
+	portp->mode |= MTPAV_MODE_OUTPUT_OPENED;
+	portp->output = substream;
+	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
+	return 0;
+};
+
+/*
+ */
+
+static int snd_mtpav_output_close(snd_rawmidi_substream_t * substream)
+{
+	unsigned long flags;
+	mtpav_port_t *portp = &mtp_card->ports[substream->number];
+
+	spin_lock_irqsave(&mtp_card->spinlock, flags);
+	portp->mode &= (~MTPAV_MODE_OUTPUT_OPENED);
+	portp->output = NULL;
+	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
+	return 0;
+};
+
+/*
+ */
+
+static void snd_mtpav_output_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	unsigned long flags;
+	mtpav_port_t *portp = &mtp_card->ports[substream->number];
+
+	spin_lock_irqsave(&mtp_card->spinlock, flags);
+	if (up) {
+		if (! (portp->mode  & MTPAV_MODE_OUTPUT_TRIGGERED)) {
+			if (mtp_card->istimer++ == 0)
+				snd_mtpav_add_output_timer(mtp_card);
+			portp->mode |= MTPAV_MODE_OUTPUT_TRIGGERED;
+		}
+	} else {
+		portp->mode &= ~MTPAV_MODE_OUTPUT_TRIGGERED;
+		if (--mtp_card->istimer == 0)
+			snd_mtpav_remove_output_timer(mtp_card);
+	}
+	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
+
+	if (up)
+		snd_mtpav_output_write(substream);
+}
+
+/*
+ * midi interrupt for inputs
+ */
+
+static void snd_mtpav_inmidi_process(mtpav_t *mcrd, u8 inbyte)
+{
+	mtpav_port_t *portp;
+
+	if ((int)mcrd->inmidiport > mcrd->num_ports * 2 + MTPAV_PIDX_BROADCAST)
+		return;
+
+	portp = &mcrd->ports[mcrd->inmidiport];
+	if (portp->mode & MTPAV_MODE_INPUT_TRIGGERED) {
+		snd_rawmidi_receive(portp->input, &inbyte, 1);
+	}
+}
+
+static void snd_mtpav_inmidi_h(mtpav_t * mcrd, u8 inbyte)
+{
+	snd_assert(mcrd, return);
+
+	if (inbyte >= 0xf8) {
+		/* real-time midi code */
+		snd_mtpav_inmidi_process(mcrd, inbyte);
+		return;
+	}
+
+	if (mcrd->inmidistate == 0) {	// awaiting command
+		if (inbyte == 0xf5)	// MTP port #
+			mcrd->inmidistate = 1;
+		else
+			snd_mtpav_inmidi_process(mcrd, inbyte);
+	} else if (mcrd->inmidistate) {
+		mcrd->inmidiport = translate_hwport_to_subdevice(mcrd, inbyte);
+		mcrd->inmidistate = 0;
+	}
+}
+
+static void snd_mtpav_read_bytes(mtpav_t * mcrd)
+{
+	u8 clrread, setread;
+	u8 mtp_read_byte;
+	u8 sr, cbyt;
+	int i;
+
+	u8 sbyt = snd_mtpav_getreg(mcrd, SREG);
+
+	//printk("snd_mtpav_read_bytes() sbyt: 0x%x\n", sbyt);
+
+	if (!(sbyt & SIGS_BYTE))
+		return;
+
+	cbyt = snd_mtpav_getreg(mcrd, CREG);
+	clrread = cbyt & (SIGC_READ ^ 0xff);
+	setread = cbyt | SIGC_READ;
+
+	do {
+
+		mtp_read_byte = 0;
+		for (i = 0; i < 4; i++) {
+			snd_mtpav_mputreg(mcrd, CREG, setread);
+			sr = snd_mtpav_getreg(mcrd, SREG);
+			snd_mtpav_mputreg(mcrd, CREG, clrread);
+
+			sr &= SIGS_IN0 | SIGS_IN1;
+			sr >>= 4;
+			mtp_read_byte |= sr << (i * 2);
+		}
+
+		snd_mtpav_inmidi_h(mcrd, mtp_read_byte);
+
+		sbyt = snd_mtpav_getreg(mcrd, SREG);
+
+	} while (sbyt & SIGS_BYTE);
+}
+
+static irqreturn_t snd_mtpav_irqh(int irq, void *dev_id, struct pt_regs *regs)
+{
+	mtpav_t *mcard = dev_id;
+
+	//printk("irqh()\n");
+	spin_lock(&mcard->spinlock);
+	snd_mtpav_read_bytes(mcard);
+	spin_unlock(&mcard->spinlock);
+	return IRQ_HANDLED;
+}
+
+/*
+ * get ISA resources
+ */
+static int snd_mtpav_get_ISA(mtpav_t * mcard)
+{
+	if ((mcard->res_port = request_region(port, 3, "MotuMTPAV MIDI")) == NULL) {
+		snd_printk("MTVAP port 0x%lx is busy\n", port);
+		return -EBUSY;
+	}
+	mcard->port = port;
+	if (request_irq(irq, snd_mtpav_irqh, SA_INTERRUPT, "MOTU MTPAV", (void *)mcard)) {
+		snd_printk("MTVAP IRQ %d busy\n", irq);
+		return -EBUSY;
+	}
+	mcard->irq = irq;
+	return 0;
+}
+
+
+/*
+ */
+
+static snd_rawmidi_ops_t snd_mtpav_output = {
+	.open =		snd_mtpav_output_open,
+	.close =	snd_mtpav_output_close,
+	.trigger =	snd_mtpav_output_trigger,
+};
+
+static snd_rawmidi_ops_t snd_mtpav_input = {
+	.open =		snd_mtpav_input_open,
+	.close =	snd_mtpav_input_close,
+	.trigger =	snd_mtpav_input_trigger,
+};
+
+
+/*
+ * get RAWMIDI resources
+ */
+
+static void snd_mtpav_set_name(mtpav_t *chip, snd_rawmidi_substream_t *substream)
+{
+	if (substream->number >= 0 && substream->number < chip->num_ports)
+		sprintf(substream->name, "MTP direct %d", (substream->number % chip->num_ports) + 1);
+	else if (substream->number >= 8 && substream->number < chip->num_ports * 2)
+		sprintf(substream->name, "MTP remote %d", (substream->number % chip->num_ports) + 1);
+	else if (substream->number == chip->num_ports * 2)
+		strcpy(substream->name, "MTP computer");
+	else if (substream->number == chip->num_ports * 2 + 1)
+		strcpy(substream->name, "MTP ADAT");
+	else
+		strcpy(substream->name, "MTP broadcast");
+}
+
+static int snd_mtpav_get_RAWMIDI(mtpav_t * mcard)
+{
+	int rval = 0;
+	snd_rawmidi_t *rawmidi;
+	snd_rawmidi_substream_t *substream;
+	struct list_head *list;
+
+	//printk("entering snd_mtpav_get_RAWMIDI\n");
+
+	if (hwports < 1)
+		mcard->num_ports = 1;
+	else if (hwports > 8)
+		mcard->num_ports = 8;
+	else
+		mcard->num_ports = hwports;
+
+	if ((rval = snd_rawmidi_new(mcard->card, "MotuMIDI", 0,
+				    mcard->num_ports * 2 + MTPAV_PIDX_BROADCAST + 1,
+				    mcard->num_ports * 2 + MTPAV_PIDX_BROADCAST + 1,
+				    &mcard->rmidi)) < 0)
+		return rval;
+	rawmidi = mcard->rmidi;
+
+	list_for_each(list, &rawmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams) {
+		substream = list_entry(list, snd_rawmidi_substream_t, list);
+		snd_mtpav_set_name(mcard, substream);
+		substream->ops = &snd_mtpav_input;
+	}
+	list_for_each(list, &rawmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams) {
+		substream = list_entry(list, snd_rawmidi_substream_t, list);
+		snd_mtpav_set_name(mcard, substream);
+		substream->ops = &snd_mtpav_output;
+		mcard->ports[substream->number].hwport = translate_subdevice_to_hwport(mcard, substream->number);
+	}
+	rawmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT |
+			       SNDRV_RAWMIDI_INFO_DUPLEX;
+	sprintf(rawmidi->name, "MTP AV MIDI");
+	//printk("exiting snd_mtpav_get_RAWMIDI() \n");
+	return 0;
+}
+
+/*
+ */
+
+static mtpav_t *new_mtpav(void)
+{
+	mtpav_t *ncrd = kcalloc(1, sizeof(*ncrd), GFP_KERNEL);
+	if (ncrd != NULL) {
+		spin_lock_init(&ncrd->spinlock);
+
+		init_timer(&ncrd->timer);
+		ncrd->card = NULL;
+		ncrd->irq = -1;
+		ncrd->share_irq = 0;
+
+		ncrd->inmidiport = 0xffffffff;
+		ncrd->inmidistate = 0;
+		ncrd->outmidihwport = 0xffffffff;
+	}
+	return ncrd;
+}
+
+/*
+ */
+
+static void free_mtpav(mtpav_t * crd)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&crd->spinlock, flags);
+	if (crd->istimer > 0)
+		snd_mtpav_remove_output_timer(crd);
+	spin_unlock_irqrestore(&crd->spinlock, flags);
+	if (crd->irq >= 0)
+		free_irq(crd->irq, (void *)crd);
+	if (crd->res_port) {
+		release_resource(crd->res_port);
+		kfree_nocheck(crd->res_port);
+	}
+	kfree(crd);
+}
+
+/*
+ */
+
+static int __init alsa_card_mtpav_init(void)
+{
+	int err = 0;
+	char longname_buffer[80];
+
+	mtp_card = new_mtpav();
+	if (mtp_card == NULL)
+		return -ENOMEM;
+
+	mtp_card->card = snd_card_new(index, id, THIS_MODULE, 0);
+	if (mtp_card->card == NULL) {
+		free_mtpav(mtp_card);
+		return -ENOMEM;
+	}
+
+	err = snd_mtpav_get_ISA(mtp_card);
+	//printk("snd_mtpav_get_ISA returned: %d\n", err);
+	if (err < 0)
+		goto __error;
+
+	strcpy(mtp_card->card->driver, "MTPAV");
+	strcpy(mtp_card->card->shortname, "MTPAV on parallel port");
+	memset(longname_buffer, 0, sizeof(longname_buffer));
+	sprintf(longname_buffer, "MTPAV on parallel port at");
+
+	err = snd_mtpav_get_RAWMIDI(mtp_card);
+	//snd_printk("snd_mtapv_get_RAWMIDI returned: %d\n", err);
+	if (err < 0)
+		goto __error;
+
+	err = snd_card_register(mtp_card->card);	// don't snd_card_register until AFTER all cards reources done!
+
+	//printk("snd_card_register returned %d\n", err);
+	if (err < 0)
+		goto __error;
+
+
+	snd_mtpav_portscan(mtp_card);
+
+	printk(KERN_INFO "Motu MidiTimePiece on parallel port irq: %d ioport: 0x%lx\n", irq, port);
+
+	return 0;
+
+      __error:
+	snd_card_free(mtp_card->card);
+	free_mtpav(mtp_card);
+	return err;
+}
+
+/*
+ */
+
+static void __exit alsa_card_mtpav_exit(void)
+{
+	if (mtp_card == NULL)
+		return;
+	if (mtp_card->card)
+		snd_card_free(mtp_card->card);
+	free_mtpav(mtp_card);
+}
+
+/*
+ */
+
+module_init(alsa_card_mtpav_init)
+module_exit(alsa_card_mtpav_exit)
