commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index dae26e856b26..65982d6babfc 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *  Routines for control of MPU-401 in UART mode
@@ -6,26 +7,10 @@
  *  interrupts thus output is done via polling. Without interrupt,
  *  input is done also via polling. Do not expect good performance.
  *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  *   13-03-2003:
  *      Added support for different kind of hardware I/O. Build in choices
  *      are port and mmio. For other kind of I/O, set mpu->read and
  *      mpu->write to your own I/O functions.
- *
  */
 
 #include <linux/io.h>

commit 969686ee0e0ff62ece428e8e02b07f81ac88a84d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 3 15:42:46 2018 +0200

    ALSA: drivers: Remove empty init and exit
    
    For a sake of code simplification, remove the init and the exit
    entries that do nothing.
    
    Notes for readers: actually it's OK to remove *both* init and exit,
    but not OK to remove the exit entry.  By removing only the exit while
    keeping init, the module becomes permanently loaded; i.e. you cannot
    unload it any longer!
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 3e745f47dd2f..dae26e856b26 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -617,19 +617,3 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 }
 
 EXPORT_SYMBOL(snd_mpu401_uart_new);
-
-/*
- *  INIT part
- */
-
-static int __init alsa_mpu401_uart_init(void)
-{
-	return 0;
-}
-
-static void __exit alsa_mpu401_uart_exit(void)
-{
-}
-
-module_init(alsa_mpu401_uart_init)
-module_exit(alsa_mpu401_uart_exit)

commit bc47ba90b01afe468cdd586b0dbe59b64862e2b7
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 24 08:34:29 2017 -0700

    ALSA: drivers: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index b997222274bd..3e745f47dd2f 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -169,9 +169,9 @@ EXPORT_SYMBOL(snd_mpu401_uart_interrupt_tx);
  * timer callback
  * reprogram the timer and call the interrupt job
  */
-static void snd_mpu401_uart_timer(unsigned long data)
+static void snd_mpu401_uart_timer(struct timer_list *t)
 {
-	struct snd_mpu401 *mpu = (struct snd_mpu401 *)data;
+	struct snd_mpu401 *mpu = from_timer(mpu, t, timer);
 	unsigned long flags;
 
 	spin_lock_irqsave(&mpu->timer_lock, flags);
@@ -191,8 +191,7 @@ static void snd_mpu401_uart_add_timer (struct snd_mpu401 *mpu, int input)
 
 	spin_lock_irqsave (&mpu->timer_lock, flags);
 	if (mpu->timer_invoked == 0) {
-		setup_timer(&mpu->timer, snd_mpu401_uart_timer,
-			    (unsigned long)mpu);
+		timer_setup(&mpu->timer, snd_mpu401_uart_timer, 0);
 		mod_timer(&mpu->timer, 1 + jiffies);
 	} 
 	mpu->timer_invoked |= input ? MPU401_MODE_INPUT_TIMER :

commit f1a77dc17103e53e43f33beab67a287feafa6aa3
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Aug 12 20:50:16 2017 +0200

    ALSA: mpu401: Adjust four checks for null pointers
    
    The script “checkpatch.pl” pointed information out like the following.
    
    Comparison to NULL could be written !…
    
    Thus fix the affected source code places.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index e8bdea193eab..b997222274bd 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -136,7 +136,7 @@ irqreturn_t snd_mpu401_uart_interrupt(int irq, void *dev_id)
 {
 	struct snd_mpu401 *mpu = dev_id;
 	
-	if (mpu == NULL)
+	if (!mpu)
 		return IRQ_NONE;
 	_snd_mpu401_uart_interrupt(mpu);
 	return IRQ_HANDLED;
@@ -157,7 +157,7 @@ irqreturn_t snd_mpu401_uart_interrupt_tx(int irq, void *dev_id)
 {
 	struct snd_mpu401 *mpu = dev_id;
 	
-	if (mpu == NULL)
+	if (!mpu)
 		return IRQ_NONE;
 	uart_interrupt_tx(mpu);
 	return IRQ_HANDLED;
@@ -544,7 +544,7 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 				   out_enable, in_enable, &rmidi)) < 0)
 		return err;
 	mpu = kzalloc(sizeof(*mpu), GFP_KERNEL);
-	if (mpu == NULL) {
+	if (!mpu) {
 		err = -ENOMEM;
 		goto free_device;
 	}
@@ -558,7 +558,7 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 	if (! (info_flags & MPU401_INFO_INTEGRATED)) {
 		int res_size = hardware == MPU401_HW_PC98II ? 4 : 2;
 		mpu->res = request_region(port, res_size, "MPU401 UART");
-		if (mpu->res == NULL) {
+		if (!mpu->res) {
 			snd_printk(KERN_ERR "mpu401_uart: "
 				   "unable to grab port 0x%lx size %d\n",
 				   port, res_size);

commit ec1f43c83b9df3052209e0c7e7d936e15251c867
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Aug 12 20:40:17 2017 +0200

    ALSA: mpu401: Use common error handling code in snd_mpu401_uart_new()
    
    Add a jump target so that a bit of exception handling can be better reused
    at the end of this function.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index cc347386fc2b..e8bdea193eab 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -545,8 +545,8 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 		return err;
 	mpu = kzalloc(sizeof(*mpu), GFP_KERNEL);
 	if (mpu == NULL) {
-		snd_device_free(card, rmidi);
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto free_device;
 	}
 	rmidi->private_data = mpu;
 	rmidi->private_free = snd_mpu401_uart_free;
@@ -562,8 +562,8 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 			snd_printk(KERN_ERR "mpu401_uart: "
 				   "unable to grab port 0x%lx size %d\n",
 				   port, res_size);
-			snd_device_free(card, rmidi);
-			return -EBUSY;
+			err = -EBUSY;
+			goto free_device;
 		}
 	}
 	if (info_flags & MPU401_INFO_MMIO) {
@@ -583,8 +583,8 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 				"MPU401 UART", (void *) mpu)) {
 			snd_printk(KERN_ERR "mpu401_uart: "
 				   "unable to grab IRQ %d\n", irq);
-			snd_device_free(card, rmidi);
-			return -EBUSY;
+			err = -EBUSY;
+			goto free_device;
 		}
 	}
 	if (irq < 0 && !(info_flags & MPU401_INFO_IRQ_HOOK))
@@ -612,6 +612,9 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 	if (rrawmidi)
 		*rrawmidi = rmidi;
 	return 0;
+free_device:
+	snd_device_free(card, rmidi);
+	return err;
 }
 
 EXPORT_SYMBOL(snd_mpu401_uart_new);

commit 30b2aeb8a85c2f91f23c95e2b6723a464d0ee6d3
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Aug 12 20:20:11 2017 +0200

    ALSA: mpu401: Delete an error message for a failed memory allocation in snd_mpu401_uart_new()
    
    Omit an extra message for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 3a7c317ae012..cc347386fc2b 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -545,7 +545,6 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 		return err;
 	mpu = kzalloc(sizeof(*mpu), GFP_KERNEL);
 	if (mpu == NULL) {
-		snd_printk(KERN_ERR "mpu401_uart: cannot allocate\n");
 		snd_device_free(card, rmidi);
 		return -ENOMEM;
 	}

commit c36f486d7bc71d41ec6b9521574136a280c17803
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 5 17:28:39 2017 +0100

    ALSA: drivers: Constify snd_rawmidi_ops
    
    Now snd_rawmidi_ops is maintained as a const pointer in snd_rawmidi,
    we can constify the definitions.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 776596b5ee05..3a7c317ae012 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -481,14 +481,14 @@ snd_mpu401_uart_output_trigger(struct snd_rawmidi_substream *substream, int up)
 
  */
 
-static struct snd_rawmidi_ops snd_mpu401_uart_output =
+static const struct snd_rawmidi_ops snd_mpu401_uart_output =
 {
 	.open =		snd_mpu401_uart_output_open,
 	.close =	snd_mpu401_uart_output_close,
 	.trigger =	snd_mpu401_uart_output_trigger,
 };
 
-static struct snd_rawmidi_ops snd_mpu401_uart_input =
+static const struct snd_rawmidi_ops snd_mpu401_uart_input =
 {
 	.open =		snd_mpu401_uart_input_open,
 	.close =	snd_mpu401_uart_input_close,

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 1e19eb9e1596..776596b5ee05 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -28,7 +28,7 @@
  *
  */
 
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/slab.h>

commit b093ed23dad894d473bb2e9948facf7fc509ae77
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 11:28:13 2015 +0100

    ALSA: mpu401: Use setup_timer() and mod_timer()
    
    No functional change, refactoring with the standard helpers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index e3a90d043f03..1e19eb9e1596 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -176,8 +176,7 @@ static void snd_mpu401_uart_timer(unsigned long data)
 
 	spin_lock_irqsave(&mpu->timer_lock, flags);
 	/*mpu->mode |= MPU401_MODE_TIMER;*/
-	mpu->timer.expires = 1 + jiffies;
-	add_timer(&mpu->timer);
+	mod_timer(&mpu->timer,  1 + jiffies);
 	spin_unlock_irqrestore(&mpu->timer_lock, flags);
 	if (mpu->rmidi)
 		_snd_mpu401_uart_interrupt(mpu);
@@ -192,11 +191,9 @@ static void snd_mpu401_uart_add_timer (struct snd_mpu401 *mpu, int input)
 
 	spin_lock_irqsave (&mpu->timer_lock, flags);
 	if (mpu->timer_invoked == 0) {
-		init_timer(&mpu->timer);
-		mpu->timer.data = (unsigned long)mpu;
-		mpu->timer.function = snd_mpu401_uart_timer;
-		mpu->timer.expires = 1 + jiffies;
-		add_timer(&mpu->timer);
+		setup_timer(&mpu->timer, snd_mpu401_uart_timer,
+			    (unsigned long)mpu);
+		mod_timer(&mpu->timer, 1 + jiffies);
 	} 
 	mpu->timer_invoked |= input ? MPU401_MODE_INPUT_TIMER :
 		MPU401_MODE_OUTPUT_TIMER;

commit eb7c06e8e9c93b495e355421cffd3c43c266d7d2
Author: Yacine Belkadi <yacine.belkadi.1@gmail.com>
Date:   Mon Mar 11 22:05:14 2013 +0100

    ALSA: add/change some comments describing function return values
    
    script/kernel-doc reports the following type of warnings (when run in verbose
    mode):
    
    Warning(sound/core/init.c:152): No description found for return value of
    'snd_card_create'
    
    To fix that:
    - add missing descriptions of function return values
    - use "Return:" sections to describe those return values
    
    Along the way:
    - complete some descriptions
    - fix some typos
    
    Signed-off-by: Yacine Belkadi <yacine.belkadi.1@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 4608c2ca43f8..e3a90d043f03 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -129,6 +129,8 @@ static void _snd_mpu401_uart_interrupt(struct snd_mpu401 *mpu)
  * @dev_id: mpu401 instance
  *
  * Processes the interrupt for MPU401-UART i/o.
+ *
+ * Return: %IRQ_HANDLED if the interrupt was handled. %IRQ_NONE otherwise.
  */
 irqreturn_t snd_mpu401_uart_interrupt(int irq, void *dev_id)
 {
@@ -148,6 +150,8 @@ EXPORT_SYMBOL(snd_mpu401_uart_interrupt);
  * @dev_id: mpu401 instance
  *
  * Processes the interrupt for MPU401-UART output.
+ *
+ * Return: %IRQ_HANDLED if the interrupt was handled. %IRQ_NONE otherwise.
  */
 irqreturn_t snd_mpu401_uart_interrupt_tx(int irq, void *dev_id)
 {
@@ -519,7 +523,7 @@ static void snd_mpu401_uart_free(struct snd_rawmidi *rmidi)
  * not the mpu401 instance itself.  To access to the mpu401 instance,
  * cast from rawmidi->private_data (with struct snd_mpu401 magic-cast).
  *
- * Returns zero if successful, or a negative error code.
+ * Return: Zero if successful, or a negative error code.
  */
 int snd_mpu401_uart_new(struct snd_card *card, int device,
 			unsigned short hardware,

commit bc733d495267a23ef8660220d696c6e549ce30b3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 23 11:35:55 2012 +0200

    ALSA: mpu401: Fix missing initialization of irq field
    
    The irq field of struct snd_mpu401 is supposed to be initialized to -1.
    Since it's set to zero as of now, a probing error before the irq
    installation results in a kernel warning "Trying to free already-free
    IRQ 0".
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=44821
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 1cff331a228e..4608c2ca43f8 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -554,6 +554,7 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 	spin_lock_init(&mpu->output_lock);
 	spin_lock_init(&mpu->timer_lock);
 	mpu->hardware = hardware;
+	mpu->irq = -1;
 	if (! (info_flags & MPU401_INFO_INTEGRATED)) {
 		int res_size = hardware == MPU401_HW_PC98II ? 4 : 2;
 		mpu->res = request_region(port, res_size, "MPU401 UART");

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index e91698a634b2..1cff331a228e 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -33,6 +33,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/ioport.h>
+#include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/errno.h>
 #include <sound/core.h>

commit 88e24c3a4b30a6bd361f2b5ce602667a8161b2e8
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Thu Sep 22 16:59:20 2011 +0800

    sound: irq: Remove IRQF_DISABLED
    
    Since commit [e58aa3d2: genirq: Run irq handlers with interrupts disabled],
    We run all interrupt handlers with interrupts disabled
    and we even check and yell when an interrupt handler
    returns with interrupts enabled (see commit [b738a50a:
    genirq: Warn when handler enables interrupts]).
    
    So now this flag is a NOOP and can be removed.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 9d01c181feca..e91698a634b2 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -577,7 +577,7 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 	else
 		mpu->cport = port + 1;
 	if (irq >= 0) {
-		if (request_irq(irq, snd_mpu401_uart_interrupt, IRQF_DISABLED,
+		if (request_irq(irq, snd_mpu401_uart_interrupt, 0,
 				"MPU401 UART", (void *) mpu)) {
 			snd_printk(KERN_ERR "mpu401_uart: "
 				   "unable to grab IRQ %d\n", irq);

commit dba8b46992c55946d3b092934f581a343403118f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Sep 13 11:24:41 2011 +0200

    ALSA: mpu401: clean up interrupt specification
    
    The semantics of snd_mpu401_uart_new()'s interrupt parameters are
    somewhat counterintuitive:  To prevent the function from allocating its
    own interrupt, either the irq number must be invalid, or the irq_flags
    parameter must be zero.  At the same time, the irq parameter being
    invalid specifies that the mpu401 code has to work without an interrupt
    allocated by the caller.  This implies that, if there is an interrupt
    and it is allocated by the caller, the irq parameter must be set to
    a valid-looking number which then isn't actually used.
    
    With the removal of IRQF_DISABLED, zero becomes a valid irq_flags value,
    which forces us to handle the parameters differently.
    
    This patch introduces a new flag MPU401_INFO_IRQ_HOOK for when the
    device interrupt is handled by the caller, and makes the allocation of
    the interrupt to depend only on the irq parameter.  As suggested by
    Takashi, the irq_flags parameter was dropped because, when used, it had
    the constant value IRQF_DISABLED.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 2af09996a3d0..9d01c181feca 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -3,7 +3,7 @@
  *  Routines for control of MPU-401 in UART mode
  *
  *  MPU-401 supports UART mode which is not capable generate transmit
- *  interrupts thus output is done via polling. Also, if irq < 0, then
+ *  interrupts thus output is done via polling. Without interrupt,
  *  input is done also via polling. Do not expect good performance.
  *
  *
@@ -374,7 +374,7 @@ snd_mpu401_uart_input_trigger(struct snd_rawmidi_substream *substream, int up)
 			/* first time - flush FIFO */
 			while (max-- > 0)
 				mpu->read(mpu, MPU401D(mpu));
-			if (mpu->irq < 0)
+			if (mpu->info_flags & MPU401_INFO_USE_TIMER)
 				snd_mpu401_uart_add_timer(mpu, 1);
 		}
 		
@@ -383,7 +383,7 @@ snd_mpu401_uart_input_trigger(struct snd_rawmidi_substream *substream, int up)
 		snd_mpu401_uart_input_read(mpu);
 		spin_unlock_irqrestore(&mpu->input_lock, flags);
 	} else {
-		if (mpu->irq < 0)
+		if (mpu->info_flags & MPU401_INFO_USE_TIMER)
 			snd_mpu401_uart_remove_timer(mpu, 1);
 		clear_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode);
 	}
@@ -496,7 +496,7 @@ static struct snd_rawmidi_ops snd_mpu401_uart_input =
 static void snd_mpu401_uart_free(struct snd_rawmidi *rmidi)
 {
 	struct snd_mpu401 *mpu = rmidi->private_data;
-	if (mpu->irq_flags && mpu->irq >= 0)
+	if (mpu->irq >= 0)
 		free_irq(mpu->irq, (void *) mpu);
 	release_and_free_resource(mpu->res);
 	kfree(mpu);
@@ -509,8 +509,7 @@ static void snd_mpu401_uart_free(struct snd_rawmidi *rmidi)
  * @hardware: the hardware type, MPU401_HW_XXXX
  * @port: the base address of MPU401 port
  * @info_flags: bitflags MPU401_INFO_XXX
- * @irq: the irq number, -1 if no interrupt for mpu
- * @irq_flags: the irq request flags (SA_XXX), 0 if irq was already reserved.
+ * @irq: the ISA irq number, -1 if not to be allocated
  * @rrawmidi: the pointer to store the new rawmidi instance
  *
  * Creates a new MPU-401 instance.
@@ -525,7 +524,7 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 			unsigned short hardware,
 			unsigned long port,
 			unsigned int info_flags,
-			int irq, int irq_flags,
+			int irq,
 			struct snd_rawmidi ** rrawmidi)
 {
 	struct snd_mpu401 *mpu;
@@ -577,8 +576,8 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 		mpu->cport = port + 2;
 	else
 		mpu->cport = port + 1;
-	if (irq >= 0 && irq_flags) {
-		if (request_irq(irq, snd_mpu401_uart_interrupt, irq_flags,
+	if (irq >= 0) {
+		if (request_irq(irq, snd_mpu401_uart_interrupt, IRQF_DISABLED,
 				"MPU401 UART", (void *) mpu)) {
 			snd_printk(KERN_ERR "mpu401_uart: "
 				   "unable to grab IRQ %d\n", irq);
@@ -586,9 +585,10 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 			return -EBUSY;
 		}
 	}
+	if (irq < 0 && !(info_flags & MPU401_INFO_IRQ_HOOK))
+		info_flags |= MPU401_INFO_USE_TIMER;
 	mpu->info_flags = info_flags;
 	mpu->irq = irq;
-	mpu->irq_flags = irq_flags;
 	if (card->shortname[0])
 		snprintf(rmidi->name, sizeof(rmidi->name), "%s MIDI",
 			 card->shortname);

commit df7e3fdf83699328d1fdf7000ce0dc852fbb0ad9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 25 09:13:45 2008 +0200

    [ALSA] Add MPU401_INFO_NO_ACK bitflag
    
    Added MPU401_INFO_NO_ACK bitflag to ignore the ACK check for UART
    commands.  VT172x doesn't handle ACK commands, for example.
    
    Tested-by: Pavel Hofman <pavel.hofman@insite.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 18cca2457d44..2af09996a3d0 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -243,7 +243,7 @@ static int snd_mpu401_uart_cmd(struct snd_mpu401 * mpu, unsigned char cmd,
 #endif
 	}
 	mpu->write(mpu, cmd, MPU401C(mpu));
-	if (ack) {
+	if (ack && !(mpu->info_flags & MPU401_INFO_NO_ACK)) {
 		ok = 0;
 		timeout = 10000;
 		while (!ok && timeout-- > 0) {

commit b415ed45f4db9f8365daac84cf2518642a174dc0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 23 17:47:28 2008 +0200

    [ALSA] Define MPU401 registers in sound/mpu401_uart.h
    
    Define some MPU401 registers in sound/mpu401_uart.h so that other
    drivers can refer to them.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index dd6ec4266732..18cca2457d44 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -49,12 +49,10 @@ static void snd_mpu401_uart_output_write(struct snd_mpu401 * mpu);
 
  */
 
-#define snd_mpu401_input_avail(mpu)	(!(mpu->read(mpu, MPU401C(mpu)) & 0x80))
-#define snd_mpu401_output_ready(mpu)	(!(mpu->read(mpu, MPU401C(mpu)) & 0x40))
-
-#define MPU401_RESET		0xff
-#define MPU401_ENTER_UART	0x3f
-#define MPU401_ACK		0xfe
+#define snd_mpu401_input_avail(mpu) \
+	(!(mpu->read(mpu, MPU401C(mpu)) & MPU401_RX_EMPTY))
+#define snd_mpu401_output_ready(mpu) \
+	(!(mpu->read(mpu, MPU401C(mpu)) & MPU401_TX_FULL))
 
 /* Build in lowlevel io */
 static void mpu401_write_port(struct snd_mpu401 *mpu, unsigned char data,

commit ea6b5828cdbbedaf26b12ae64befbec18084ea3c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Feb 25 10:59:52 2008 +0100

    [ALSA] mpu401: reduce tx loop timeout
    
    Reduce the number of times to check for a non-empty Tx FIFO from 100 to
    2 because there is no MPU-401 implementation that needs more than one or
    two reads to determine the actual FIFO status.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 5993864acbd3..dd6ec4266732 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -425,16 +425,17 @@ static void snd_mpu401_uart_input_read(struct snd_mpu401 * mpu)
 static void snd_mpu401_uart_output_write(struct snd_mpu401 * mpu)
 {
 	unsigned char byte;
-	int max = 256, timeout;
+	int max = 256;
 
 	do {
 		if (snd_rawmidi_transmit_peek(mpu->substream_output,
 					      &byte, 1) == 1) {
-			for (timeout = 100; timeout > 0; timeout--) {
-				if (snd_mpu401_output_ready(mpu))
-					break;
-			}
-			if (timeout == 0)
+			/*
+			 * Try twice because there is hardware that insists on
+			 * setting the output busy bit after each write.
+			 */
+			if (!snd_mpu401_output_ready(mpu) &&
+			    !snd_mpu401_output_ready(mpu))
 				break;	/* Tx FIFO full - try again later */
 			mpu->write(mpu, byte, MPU401D(mpu));
 			snd_rawmidi_transmit_ack(mpu->substream_output, 1);

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index b57f2d5a1c9d..5993864acbd3 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -28,7 +28,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <asm/io.h>
 #include <linux/delay.h>
 #include <linux/init.h>

commit 60fac85fffc74cdd2fbdae821f269594ca25b6b1
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Nov 12 08:47:57 2007 +0100

    [ALSA] mpu401: fix recursive locking in timer
    
    When the output and input ports are used at the same time, the timer can
    be interrupted by the hardware interrupt, so we have to disable
    interrupts when we take a lock in the timer.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 3306ecd49243..b57f2d5a1c9d 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -97,23 +97,27 @@ static void snd_mpu401_uart_clear_rx(struct snd_mpu401 *mpu)
 
 static void uart_interrupt_tx(struct snd_mpu401 *mpu)
 {
+	unsigned long flags;
+
 	if (test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode) &&
 	    test_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode)) {
-		spin_lock(&mpu->output_lock);
+		spin_lock_irqsave(&mpu->output_lock, flags);
 		snd_mpu401_uart_output_write(mpu);
-		spin_unlock(&mpu->output_lock);
+		spin_unlock_irqrestore(&mpu->output_lock, flags);
 	}
 }
 
 static void _snd_mpu401_uart_interrupt(struct snd_mpu401 *mpu)
 {
+	unsigned long flags;
+
 	if (mpu->info_flags & MPU401_INFO_INPUT) {
-		spin_lock(&mpu->input_lock);
+		spin_lock_irqsave(&mpu->input_lock, flags);
 		if (test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode))
 			snd_mpu401_uart_input_read(mpu);
 		else
 			snd_mpu401_uart_clear_rx(mpu);
-		spin_unlock(&mpu->input_lock);
+		spin_unlock_irqrestore(&mpu->input_lock, flags);
 	}
 	if (! (mpu->info_flags & MPU401_INFO_TX_IRQ))
 		/* ok. for better Tx performance try do some output

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 43c6f207c3c2..3306ecd49243 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *  Routines for control of MPU-401 in UART mode
  *
  *  MPU-401 supports UART mode which is not capable generate transmit
@@ -39,7 +39,7 @@
 #include <sound/core.h>
 #include <sound/mpu401.h>
 
-MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");
 MODULE_DESCRIPTION("Routines for control of MPU-401 in UART mode");
 MODULE_LICENSE("GPL");
 

commit c1099fcb74ddc005c85beaef33bbe68c9bf3b5bb
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Oct 11 14:42:23 2007 +0200

    [ALSA] mpu-401: remove MPU401_INFO_UART_ONLY flag
    
    Since the last patch made the ENTER_UART command optional, the
    enter_uart option and its corresponding flag have become superfluous.
    The uart_enter option remains for backward compatibility but just prints
    a warning when used.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index b5c5dd1e61bd..43c6f207c3c2 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -270,8 +270,7 @@ static int snd_mpu401_do_reset(struct snd_mpu401 *mpu)
 {
 	if (snd_mpu401_uart_cmd(mpu, MPU401_RESET, 1))
 		return -EIO;
-	if (!(mpu->info_flags & MPU401_INFO_UART_ONLY) &&
-	    snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 0))
+	if (snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 0))
 		return -EIO;
 	return 0;
 }

commit 69d8d3eb4df40194485b842c00047bb80e51c6a8
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Oct 11 14:15:06 2007 +0200

    [ALSA] mpu-401: do not require an ACK byte for the ENTER_UART command
    
    The original MPU-401 does not send an ACK byte after processing the
    ENTER_UART command, so we better do not try to wait for it.
    Many clones get this wrong and do send an ACK, but when interpreting it
    as MIDI, it is just a harmless Active Sensing message, and it is likely
    to be read and discarded by the interrupt handler before the MIDI input
    device is triggered.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 85aedc348e2d..b5c5dd1e61bd 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -271,7 +271,7 @@ static int snd_mpu401_do_reset(struct snd_mpu401 *mpu)
 	if (snd_mpu401_uart_cmd(mpu, MPU401_RESET, 1))
 		return -EIO;
 	if (!(mpu->info_flags & MPU401_INFO_UART_ONLY) &&
-	    snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 1))
+	    snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 0))
 		return -EIO;
 	return 0;
 }

commit 8f7ba051d2abb3d3bde9b95e47246c60b704d2b4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 22 16:07:21 2007 +0100

    [ALSA] mpu401 - Add MPU401_INFO_UART_ONLY bitflag
    
    Added MPU401_INFO_UART_ONLY bitflag to avoid issueing UART_ENTER command
    at opening streams.  Some devices support only UART mode and give errors
    to UART_ENTER.
    A new module option, uart_enter, is added to snd-mpu401 driver.
    For UART-only devices, set uart_enter=0.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 3daa9fa56c0b..85aedc348e2d 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -266,6 +266,16 @@ static int snd_mpu401_uart_cmd(struct snd_mpu401 * mpu, unsigned char cmd,
 	return 0;
 }
 
+static int snd_mpu401_do_reset(struct snd_mpu401 *mpu)
+{
+	if (snd_mpu401_uart_cmd(mpu, MPU401_RESET, 1))
+		return -EIO;
+	if (!(mpu->info_flags & MPU401_INFO_UART_ONLY) &&
+	    snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 1))
+		return -EIO;
+	return 0;
+}
+
 /*
  * input/output open/close - protected by open_mutex in rawmidi.c
  */
@@ -278,9 +288,7 @@ static int snd_mpu401_uart_input_open(struct snd_rawmidi_substream *substream)
 	if (mpu->open_input && (err = mpu->open_input(mpu)) < 0)
 		return err;
 	if (! test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode)) {
-		if (snd_mpu401_uart_cmd(mpu, MPU401_RESET, 1))
-			goto error_out;
-		if (snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 1))
+		if (snd_mpu401_do_reset(mpu) < 0)
 			goto error_out;
 	}
 	mpu->substream_input = substream;
@@ -302,9 +310,7 @@ static int snd_mpu401_uart_output_open(struct snd_rawmidi_substream *substream)
 	if (mpu->open_output && (err = mpu->open_output(mpu)) < 0)
 		return err;
 	if (! test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode)) {
-		if (snd_mpu401_uart_cmd(mpu, MPU401_RESET, 1))
-			goto error_out;
-		if (snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 1))
+		if (snd_mpu401_do_reset(mpu) < 0)
 			goto error_out;
 	}
 	mpu->substream_output = substream;

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 4bf07ca9b17d..3daa9fa56c0b 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -125,12 +125,10 @@ static void _snd_mpu401_uart_interrupt(struct snd_mpu401 *mpu)
  * snd_mpu401_uart_interrupt - generic MPU401-UART interrupt handler
  * @irq: the irq number
  * @dev_id: mpu401 instance
- * @regs: the reigster
  *
  * Processes the interrupt for MPU401-UART i/o.
  */
-irqreturn_t snd_mpu401_uart_interrupt(int irq, void *dev_id,
-				      struct pt_regs *regs)
+irqreturn_t snd_mpu401_uart_interrupt(int irq, void *dev_id)
 {
 	struct snd_mpu401 *mpu = dev_id;
 	
@@ -146,12 +144,10 @@ EXPORT_SYMBOL(snd_mpu401_uart_interrupt);
  * snd_mpu401_uart_interrupt_tx - generic MPU401-UART transmit irq handler
  * @irq: the irq number
  * @dev_id: mpu401 instance
- * @regs: the reigster
  *
  * Processes the interrupt for MPU401-UART output.
  */
-irqreturn_t snd_mpu401_uart_interrupt_tx(int irq, void *dev_id,
-					 struct pt_regs *regs)
+irqreturn_t snd_mpu401_uart_interrupt_tx(int irq, void *dev_id)
 {
 	struct snd_mpu401 *mpu = dev_id;
 	

commit 302e4c2f9e2b9f07c69649782330a61c60001ac4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 23 13:24:30 2006 +0200

    [ALSA] Change an arugment of snd_mpu401_uart_new() to bit flags
    
    Change the 5th argument of snd_mpu401_uart_new() to bit flags
    instead of a boolean.  The argument takes bits that consist of
    MPU401_INFO_XXX flags.
    The callers that used the value 1 there are replaced with
    MPU401_INFO_INTEGRATED.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index cd64d3eb9ec8..4bf07ca9b17d 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -95,17 +95,8 @@ static void snd_mpu401_uart_clear_rx(struct snd_mpu401 *mpu)
 #endif
 }
 
-static void _snd_mpu401_uart_interrupt(struct snd_mpu401 *mpu)
+static void uart_interrupt_tx(struct snd_mpu401 *mpu)
 {
-	spin_lock(&mpu->input_lock);
-	if (test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode))
-		snd_mpu401_uart_input_read(mpu);
-	else
-		snd_mpu401_uart_clear_rx(mpu);
-	spin_unlock(&mpu->input_lock);
- 	/* ok. for better Tx performance try do some output when
-	 * input is done
-	 */
 	if (test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode) &&
 	    test_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode)) {
 		spin_lock(&mpu->output_lock);
@@ -114,6 +105,22 @@ static void _snd_mpu401_uart_interrupt(struct snd_mpu401 *mpu)
 	}
 }
 
+static void _snd_mpu401_uart_interrupt(struct snd_mpu401 *mpu)
+{
+	if (mpu->info_flags & MPU401_INFO_INPUT) {
+		spin_lock(&mpu->input_lock);
+		if (test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode))
+			snd_mpu401_uart_input_read(mpu);
+		else
+			snd_mpu401_uart_clear_rx(mpu);
+		spin_unlock(&mpu->input_lock);
+	}
+	if (! (mpu->info_flags & MPU401_INFO_TX_IRQ))
+		/* ok. for better Tx performance try do some output
+		   when input is done */
+		uart_interrupt_tx(mpu);
+}
+
 /**
  * snd_mpu401_uart_interrupt - generic MPU401-UART interrupt handler
  * @irq: the irq number
@@ -135,6 +142,27 @@ irqreturn_t snd_mpu401_uart_interrupt(int irq, void *dev_id,
 
 EXPORT_SYMBOL(snd_mpu401_uart_interrupt);
 
+/**
+ * snd_mpu401_uart_interrupt_tx - generic MPU401-UART transmit irq handler
+ * @irq: the irq number
+ * @dev_id: mpu401 instance
+ * @regs: the reigster
+ *
+ * Processes the interrupt for MPU401-UART output.
+ */
+irqreturn_t snd_mpu401_uart_interrupt_tx(int irq, void *dev_id,
+					 struct pt_regs *regs)
+{
+	struct snd_mpu401 *mpu = dev_id;
+	
+	if (mpu == NULL)
+		return IRQ_NONE;
+	uart_interrupt_tx(mpu);
+	return IRQ_HANDLED;
+}
+
+EXPORT_SYMBOL(snd_mpu401_uart_interrupt_tx);
+
 /*
  * timer callback
  * reprogram the timer and call the interrupt job
@@ -430,14 +458,16 @@ snd_mpu401_uart_output_trigger(struct snd_rawmidi_substream *substream, int up)
 		 * since the output timer might have been removed in
 		 * snd_mpu401_uart_output_write().
 		 */
-		snd_mpu401_uart_add_timer(mpu, 0);
+		if (! (mpu->info_flags & MPU401_INFO_TX_IRQ))
+			snd_mpu401_uart_add_timer(mpu, 0);
 
 		/* output pending data */
 		spin_lock_irqsave(&mpu->output_lock, flags);
 		snd_mpu401_uart_output_write(mpu);
 		spin_unlock_irqrestore(&mpu->output_lock, flags);
 	} else {
-		snd_mpu401_uart_remove_timer(mpu, 0);
+		if (! (mpu->info_flags & MPU401_INFO_TX_IRQ))
+			snd_mpu401_uart_remove_timer(mpu, 0);
 		clear_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode);
 	}
 }
@@ -475,7 +505,7 @@ static void snd_mpu401_uart_free(struct snd_rawmidi *rmidi)
  * @device: the device index, zero-based
  * @hardware: the hardware type, MPU401_HW_XXXX
  * @port: the base address of MPU401 port
- * @integrated: non-zero if the port was already reserved by the chip
+ * @info_flags: bitflags MPU401_INFO_XXX
  * @irq: the irq number, -1 if no interrupt for mpu
  * @irq_flags: the irq request flags (SA_XXX), 0 if irq was already reserved.
  * @rrawmidi: the pointer to store the new rawmidi instance
@@ -490,17 +520,24 @@ static void snd_mpu401_uart_free(struct snd_rawmidi *rmidi)
  */
 int snd_mpu401_uart_new(struct snd_card *card, int device,
 			unsigned short hardware,
-			unsigned long port, int integrated,
+			unsigned long port,
+			unsigned int info_flags,
 			int irq, int irq_flags,
 			struct snd_rawmidi ** rrawmidi)
 {
 	struct snd_mpu401 *mpu;
 	struct snd_rawmidi *rmidi;
+	int in_enable, out_enable;
 	int err;
 
 	if (rrawmidi)
 		*rrawmidi = NULL;
-	if ((err = snd_rawmidi_new(card, "MPU-401U", device, 1, 1, &rmidi)) < 0)
+	if (! (info_flags & (MPU401_INFO_INPUT | MPU401_INFO_OUTPUT)))
+		info_flags |= MPU401_INFO_INPUT | MPU401_INFO_OUTPUT;
+	in_enable = (info_flags & MPU401_INFO_INPUT) ? 1 : 0;
+	out_enable = (info_flags & MPU401_INFO_OUTPUT) ? 1 : 0;
+	if ((err = snd_rawmidi_new(card, "MPU-401U", device,
+				   out_enable, in_enable, &rmidi)) < 0)
 		return err;
 	mpu = kzalloc(sizeof(*mpu), GFP_KERNEL);
 	if (mpu == NULL) {
@@ -514,7 +551,7 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 	spin_lock_init(&mpu->output_lock);
 	spin_lock_init(&mpu->timer_lock);
 	mpu->hardware = hardware;
-	if (!integrated) {
+	if (! (info_flags & MPU401_INFO_INTEGRATED)) {
 		int res_size = hardware == MPU401_HW_PC98II ? 4 : 2;
 		mpu->res = request_region(port, res_size, "MPU401 UART");
 		if (mpu->res == NULL) {
@@ -525,15 +562,12 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 			return -EBUSY;
 		}
 	}
-	switch (hardware) {
-	case MPU401_HW_AUREAL:
+	if (info_flags & MPU401_INFO_MMIO) {
 		mpu->write = mpu401_write_mmio;
 		mpu->read = mpu401_read_mmio;
-		break;
-	default:
+	} else {
 		mpu->write = mpu401_write_port;
 		mpu->read = mpu401_read_port;
-		break;
 	}
 	mpu->port = port;
 	if (hardware == MPU401_HW_PC98II)
@@ -549,6 +583,7 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 			return -EBUSY;
 		}
 	}
+	mpu->info_flags = info_flags;
 	mpu->irq = irq;
 	mpu->irq_flags = irq_flags;
 	if (card->shortname[0])
@@ -556,13 +591,18 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 			 card->shortname);
 	else
 		sprintf(rmidi->name, "MPU-401 MIDI %d-%d",card->number, device);
-	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,
-			    &snd_mpu401_uart_output);
-	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,
-			    &snd_mpu401_uart_input);
-	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |
-	                     SNDRV_RAWMIDI_INFO_INPUT |
-	                     SNDRV_RAWMIDI_INFO_DUPLEX;
+	if (out_enable) {
+		snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,
+				    &snd_mpu401_uart_output);
+		rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT;
+	}
+	if (in_enable) {
+		snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,
+				    &snd_mpu401_uart_input);
+		rmidi->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;
+		if (out_enable)
+			rmidi->info_flags |= SNDRV_RAWMIDI_INFO_DUPLEX;
+	}
 	mpu->rmidi = rmidi;
 	if (rrawmidi)
 		*rrawmidi = rmidi;

commit 2851d963e0038c53d2175970daac4217abed7af2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu May 18 14:48:26 2006 +0200

    [ALSA] mpu401_uart - Fix coding style and code clean up
    
    - fold lines and fix spaces to follow the standard style
    - added some comments
    - moved EXPORT_SYMBOL() near the definition
    - some code clean up
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index b49a45cbf67a..cd64d3eb9ec8 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -58,22 +58,26 @@ static void snd_mpu401_uart_output_write(struct snd_mpu401 * mpu);
 #define MPU401_ACK		0xfe
 
 /* Build in lowlevel io */
-static void mpu401_write_port(struct snd_mpu401 *mpu, unsigned char data, unsigned long addr)
+static void mpu401_write_port(struct snd_mpu401 *mpu, unsigned char data,
+			      unsigned long addr)
 {
 	outb(data, addr);
 }
 
-static unsigned char mpu401_read_port(struct snd_mpu401 *mpu, unsigned long addr)
+static unsigned char mpu401_read_port(struct snd_mpu401 *mpu,
+				      unsigned long addr)
 {
 	return inb(addr);
 }
 
-static void mpu401_write_mmio(struct snd_mpu401 *mpu, unsigned char data, unsigned long addr)
+static void mpu401_write_mmio(struct snd_mpu401 *mpu, unsigned char data,
+			      unsigned long addr)
 {
 	writeb(data, (void __iomem *)addr);
 }
 
-static unsigned char mpu401_read_mmio(struct snd_mpu401 *mpu, unsigned long addr)
+static unsigned char mpu401_read_mmio(struct snd_mpu401 *mpu,
+				      unsigned long addr)
 {
 	return readb((void __iomem *)addr);
 }
@@ -86,20 +90,22 @@ static void snd_mpu401_uart_clear_rx(struct snd_mpu401 *mpu)
 		mpu->read(mpu, MPU401D(mpu));
 #ifdef CONFIG_SND_DEBUG
 	if (timeout <= 0)
-		snd_printk("cmd: clear rx timeout (status = 0x%x)\n", mpu->read(mpu, MPU401C(mpu)));
+		snd_printk(KERN_ERR "cmd: clear rx timeout (status = 0x%x)\n",
+			   mpu->read(mpu, MPU401C(mpu)));
 #endif
 }
 
 static void _snd_mpu401_uart_interrupt(struct snd_mpu401 *mpu)
 {
 	spin_lock(&mpu->input_lock);
-	if (test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode)) {
+	if (test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode))
 		snd_mpu401_uart_input_read(mpu);
-	} else {
+	else
 		snd_mpu401_uart_clear_rx(mpu);
-	}
 	spin_unlock(&mpu->input_lock);
- 	/* ok. for better Tx performance try do some output when input is done */
+ 	/* ok. for better Tx performance try do some output when
+	 * input is done
+	 */
 	if (test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode) &&
 	    test_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode)) {
 		spin_lock(&mpu->output_lock);
@@ -116,7 +122,8 @@ static void _snd_mpu401_uart_interrupt(struct snd_mpu401 *mpu)
  *
  * Processes the interrupt for MPU401-UART i/o.
  */
-irqreturn_t snd_mpu401_uart_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t snd_mpu401_uart_interrupt(int irq, void *dev_id,
+				      struct pt_regs *regs)
 {
 	struct snd_mpu401 *mpu = dev_id;
 	
@@ -126,6 +133,8 @@ irqreturn_t snd_mpu401_uart_interrupt(int irq, void *dev_id, struct pt_regs *reg
 	return IRQ_HANDLED;
 }
 
+EXPORT_SYMBOL(snd_mpu401_uart_interrupt);
+
 /*
  * timer callback
  * reprogram the timer and call the interrupt job
@@ -159,7 +168,8 @@ static void snd_mpu401_uart_add_timer (struct snd_mpu401 *mpu, int input)
 		mpu->timer.expires = 1 + jiffies;
 		add_timer(&mpu->timer);
 	} 
-	mpu->timer_invoked |= input ? MPU401_MODE_INPUT_TIMER : MPU401_MODE_OUTPUT_TIMER;
+	mpu->timer_invoked |= input ? MPU401_MODE_INPUT_TIMER :
+		MPU401_MODE_OUTPUT_TIMER;
 	spin_unlock_irqrestore (&mpu->timer_lock, flags);
 }
 
@@ -172,7 +182,8 @@ static void snd_mpu401_uart_remove_timer (struct snd_mpu401 *mpu, int input)
 
 	spin_lock_irqsave (&mpu->timer_lock, flags);
 	if (mpu->timer_invoked) {
-		mpu->timer_invoked &= input ? ~MPU401_MODE_INPUT_TIMER : ~MPU401_MODE_OUTPUT_TIMER;
+		mpu->timer_invoked &= input ? ~MPU401_MODE_INPUT_TIMER :
+			~MPU401_MODE_OUTPUT_TIMER;
 		if (! mpu->timer_invoked)
 			del_timer(&mpu->timer);
 	}
@@ -180,11 +191,12 @@ static void snd_mpu401_uart_remove_timer (struct snd_mpu401 *mpu, int input)
 }
 
 /*
-
+ * send a UART command
+ * return zero if successful, non-zero for some errors
  */
 
 static int snd_mpu401_uart_cmd(struct snd_mpu401 * mpu, unsigned char cmd,
-		int ack)
+			       int ack)
 {
 	unsigned long flags;
 	int timeout, ok;
@@ -196,11 +208,13 @@ static int snd_mpu401_uart_cmd(struct snd_mpu401 * mpu, unsigned char cmd,
 	}
 	/* ok. standard MPU-401 initialization */
 	if (mpu->hardware != MPU401_HW_SB) {
-		for (timeout = 1000; timeout > 0 && !snd_mpu401_output_ready(mpu); timeout--)
+		for (timeout = 1000; timeout > 0 &&
+			     !snd_mpu401_output_ready(mpu); timeout--)
 			udelay(10);
 #ifdef CONFIG_SND_DEBUG
 		if (!timeout)
-			snd_printk("cmd: tx timeout (status = 0x%x)\n", mpu->read(mpu, MPU401C(mpu)));
+			snd_printk(KERN_ERR "cmd: tx timeout (status = 0x%x)\n",
+				   mpu->read(mpu, MPU401C(mpu)));
 #endif
 	}
 	mpu->write(mpu, cmd, MPU401C(mpu));
@@ -215,12 +229,14 @@ static int snd_mpu401_uart_cmd(struct snd_mpu401 * mpu, unsigned char cmd,
 		}
 		if (!ok && mpu->read(mpu, MPU401D(mpu)) == MPU401_ACK)
 			ok = 1;
-	} else {
+	} else
 		ok = 1;
-	}
 	spin_unlock_irqrestore(&mpu->input_lock, flags);
 	if (!ok) {
-		snd_printk("cmd: 0x%x failed at 0x%lx (status = 0x%x, data = 0x%x)\n", cmd, mpu->port, mpu->read(mpu, MPU401C(mpu)), mpu->read(mpu, MPU401D(mpu)));
+		snd_printk(KERN_ERR "cmd: 0x%x failed at 0x%lx "
+			   "(status = 0x%x, data = 0x%x)\n", cmd, mpu->port,
+			   mpu->read(mpu, MPU401C(mpu)),
+			   mpu->read(mpu, MPU401D(mpu)));
 		return 1;
 	}
 	return 0;
@@ -314,7 +330,8 @@ static int snd_mpu401_uart_output_close(struct snd_rawmidi_substream *substream)
 /*
  * trigger input callback
  */
-static void snd_mpu401_uart_input_trigger(struct snd_rawmidi_substream *substream, int up)
+static void
+snd_mpu401_uart_input_trigger(struct snd_rawmidi_substream *substream, int up)
 {
 	unsigned long flags;
 	struct snd_mpu401 *mpu;
@@ -322,7 +339,8 @@ static void snd_mpu401_uart_input_trigger(struct snd_rawmidi_substream *substrea
 
 	mpu = substream->rmidi->private_data;
 	if (up) {
-		if (! test_and_set_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode)) {
+		if (! test_and_set_bit(MPU401_MODE_BIT_INPUT_TRIGGER,
+				       &mpu->mode)) {
 			/* first time - flush FIFO */
 			while (max-- > 0)
 				mpu->read(mpu, MPU401D(mpu));
@@ -352,13 +370,11 @@ static void snd_mpu401_uart_input_read(struct snd_mpu401 * mpu)
 	unsigned char byte;
 
 	while (max-- > 0) {
-		if (snd_mpu401_input_avail(mpu)) {
-			byte = mpu->read(mpu, MPU401D(mpu));
-			if (test_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode))
-				snd_rawmidi_receive(mpu->substream_input, &byte, 1);
-		} else {
+		if (! snd_mpu401_input_avail(mpu))
 			break; /* input not available */
-		}
+		byte = mpu->read(mpu, MPU401D(mpu));
+		if (test_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode))
+			snd_rawmidi_receive(mpu->substream_input, &byte, 1);
 	}
 }
 
@@ -380,16 +396,16 @@ static void snd_mpu401_uart_output_write(struct snd_mpu401 * mpu)
 	int max = 256, timeout;
 
 	do {
-		if (snd_rawmidi_transmit_peek(mpu->substream_output, &byte, 1) == 1) {
+		if (snd_rawmidi_transmit_peek(mpu->substream_output,
+					      &byte, 1) == 1) {
 			for (timeout = 100; timeout > 0; timeout--) {
-				if (snd_mpu401_output_ready(mpu)) {
-					mpu->write(mpu, byte, MPU401D(mpu));
-					snd_rawmidi_transmit_ack(mpu->substream_output, 1);
+				if (snd_mpu401_output_ready(mpu))
 					break;
-				}
 			}
 			if (timeout == 0)
 				break;	/* Tx FIFO full - try again later */
+			mpu->write(mpu, byte, MPU401D(mpu));
+			snd_rawmidi_transmit_ack(mpu->substream_output, 1);
 		} else {
 			snd_mpu401_uart_remove_timer (mpu, 0);
 			break;	/* no other data - leave the tx loop */
@@ -400,7 +416,8 @@ static void snd_mpu401_uart_output_write(struct snd_mpu401 * mpu)
 /*
  * output trigger callback
  */
-static void snd_mpu401_uart_output_trigger(struct snd_rawmidi_substream *substream, int up)
+static void
+snd_mpu401_uart_output_trigger(struct snd_rawmidi_substream *substream, int up)
 {
 	unsigned long flags;
 	struct snd_mpu401 *mpu;
@@ -499,8 +516,11 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 	mpu->hardware = hardware;
 	if (!integrated) {
 		int res_size = hardware == MPU401_HW_PC98II ? 4 : 2;
-		if ((mpu->res = request_region(port, res_size, "MPU401 UART")) == NULL) {
-			snd_printk(KERN_ERR "mpu401_uart: unable to grab port 0x%lx size %d\n", port, res_size);
+		mpu->res = request_region(port, res_size, "MPU401 UART");
+		if (mpu->res == NULL) {
+			snd_printk(KERN_ERR "mpu401_uart: "
+				   "unable to grab port 0x%lx size %d\n",
+				   port, res_size);
 			snd_device_free(card, rmidi);
 			return -EBUSY;
 		}
@@ -521,8 +541,10 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 	else
 		mpu->cport = port + 1;
 	if (irq >= 0 && irq_flags) {
-		if (request_irq(irq, snd_mpu401_uart_interrupt, irq_flags, "MPU401 UART", (void *) mpu)) {
-			snd_printk(KERN_ERR "mpu401_uart: unable to grab IRQ %d\n", irq);
+		if (request_irq(irq, snd_mpu401_uart_interrupt, irq_flags,
+				"MPU401 UART", (void *) mpu)) {
+			snd_printk(KERN_ERR "mpu401_uart: "
+				   "unable to grab IRQ %d\n", irq);
 			snd_device_free(card, rmidi);
 			return -EBUSY;
 		}
@@ -530,11 +552,14 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 	mpu->irq = irq;
 	mpu->irq_flags = irq_flags;
 	if (card->shortname[0])
-		snprintf(rmidi->name, sizeof(rmidi->name), "%s MIDI", card->shortname);
+		snprintf(rmidi->name, sizeof(rmidi->name), "%s MIDI",
+			 card->shortname);
 	else
-		sprintf(rmidi->name, "MPU-401 MIDI %d-%d", card->number, device);
-	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_mpu401_uart_output);
-	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_mpu401_uart_input);
+		sprintf(rmidi->name, "MPU-401 MIDI %d-%d",card->number, device);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,
+			    &snd_mpu401_uart_output);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,
+			    &snd_mpu401_uart_input);
 	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |
 	                     SNDRV_RAWMIDI_INFO_INPUT |
 	                     SNDRV_RAWMIDI_INFO_DUPLEX;
@@ -544,7 +569,6 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 	return 0;
 }
 
-EXPORT_SYMBOL(snd_mpu401_uart_interrupt);
 EXPORT_SYMBOL(snd_mpu401_uart_new);
 
 /*

commit 962f831f67301265dcd2cd96408d07d95d556aed
Author: Jon Masters <jcm@jonmasters.org>
Date:   Thu Apr 20 02:43:20 2006 -0700

    [PATCH] sound: fix hang in mpu401_uart.c
    
    This fixes a hang in mpu401_uart.c that can occur when the mpu401 interface
    is non-existent or otherwise doesn't respond to commands but we issue IO
    anyway.  snd_mpu401_uart_cmd now returns an error code that is passed up
    the stack so that an open() will fail immediately in such cases.
    
    Eventually discovered after wine/cxoffice would constantly cause hard
    lockups on my desktop immediately after loading (emulating Windows too
    well).  Turned out that I'd recently moved my sound cards around and using
    /dev/sequencer now talks to a sound card with a broken MPU.
    
    This second version changes -EFAULT to -EIO and frees open resources on
    error too.  Test booted and seems to work ok.
    
    Signed-off-by: Jon Masters <jcm@jonmasters.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 8687ae3c66b8..b49a45cbf67a 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -183,7 +183,8 @@ static void snd_mpu401_uart_remove_timer (struct snd_mpu401 *mpu, int input)
 
  */
 
-static void snd_mpu401_uart_cmd(struct snd_mpu401 * mpu, unsigned char cmd, int ack)
+static int snd_mpu401_uart_cmd(struct snd_mpu401 * mpu, unsigned char cmd,
+		int ack)
 {
 	unsigned long flags;
 	int timeout, ok;
@@ -218,9 +219,11 @@ static void snd_mpu401_uart_cmd(struct snd_mpu401 * mpu, unsigned char cmd, int
 		ok = 1;
 	}
 	spin_unlock_irqrestore(&mpu->input_lock, flags);
-	if (! ok)
+	if (!ok) {
 		snd_printk("cmd: 0x%x failed at 0x%lx (status = 0x%x, data = 0x%x)\n", cmd, mpu->port, mpu->read(mpu, MPU401C(mpu)), mpu->read(mpu, MPU401D(mpu)));
-	// snd_printk("cmd: 0x%x at 0x%lx (status = 0x%x, data = 0x%x)\n", cmd, mpu->port, mpu->read(mpu, MPU401C(mpu)), mpu->read(mpu, MPU401D(mpu)));
+		return 1;
+	}
+	return 0;
 }
 
 /*
@@ -235,12 +238,19 @@ static int snd_mpu401_uart_input_open(struct snd_rawmidi_substream *substream)
 	if (mpu->open_input && (err = mpu->open_input(mpu)) < 0)
 		return err;
 	if (! test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode)) {
-		snd_mpu401_uart_cmd(mpu, MPU401_RESET, 1);
-		snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 1);
+		if (snd_mpu401_uart_cmd(mpu, MPU401_RESET, 1))
+			goto error_out;
+		if (snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 1))
+			goto error_out;
 	}
 	mpu->substream_input = substream;
 	set_bit(MPU401_MODE_BIT_INPUT, &mpu->mode);
 	return 0;
+
+error_out:
+	if (mpu->open_input && mpu->close_input)
+		mpu->close_input(mpu);
+	return -EIO;
 }
 
 static int snd_mpu401_uart_output_open(struct snd_rawmidi_substream *substream)
@@ -252,39 +262,52 @@ static int snd_mpu401_uart_output_open(struct snd_rawmidi_substream *substream)
 	if (mpu->open_output && (err = mpu->open_output(mpu)) < 0)
 		return err;
 	if (! test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode)) {
-		snd_mpu401_uart_cmd(mpu, MPU401_RESET, 1);
-		snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 1);
+		if (snd_mpu401_uart_cmd(mpu, MPU401_RESET, 1))
+			goto error_out;
+		if (snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 1))
+			goto error_out;
 	}
 	mpu->substream_output = substream;
 	set_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode);
 	return 0;
+
+error_out:
+	if (mpu->open_output && mpu->close_output)
+		mpu->close_output(mpu);
+	return -EIO;
 }
 
 static int snd_mpu401_uart_input_close(struct snd_rawmidi_substream *substream)
 {
 	struct snd_mpu401 *mpu;
+	int err = 0;
 
 	mpu = substream->rmidi->private_data;
 	clear_bit(MPU401_MODE_BIT_INPUT, &mpu->mode);
 	mpu->substream_input = NULL;
 	if (! test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode))
-		snd_mpu401_uart_cmd(mpu, MPU401_RESET, 0);
+		err = snd_mpu401_uart_cmd(mpu, MPU401_RESET, 0);
 	if (mpu->close_input)
 		mpu->close_input(mpu);
+	if (err)
+		return -EIO;
 	return 0;
 }
 
 static int snd_mpu401_uart_output_close(struct snd_rawmidi_substream *substream)
 {
 	struct snd_mpu401 *mpu;
+	int err = 0;
 
 	mpu = substream->rmidi->private_data;
 	clear_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode);
 	mpu->substream_output = NULL;
 	if (! test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode))
-		snd_mpu401_uart_cmd(mpu, MPU401_RESET, 0);
+		err = snd_mpu401_uart_cmd(mpu, MPU401_RESET, 0);
 	if (mpu->close_output)
 		mpu->close_output(mpu);
+	if (err)
+		return -EIO;
 	return 0;
 }
 
@@ -316,6 +339,7 @@ static void snd_mpu401_uart_input_trigger(struct snd_rawmidi_substream *substrea
 			snd_mpu401_uart_remove_timer(mpu, 1);
 		clear_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode);
 	}
+
 }
 
 /*

commit b32425ac93370e1ba5556110e662f896b2e143b3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 18 18:52:14 2005 +0100

    [ALSA] Fix possible races in timer callbacks
    
    Fix possible races in timer callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index ee67b522d259..8687ae3c66b8 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -133,12 +133,13 @@ irqreturn_t snd_mpu401_uart_interrupt(int irq, void *dev_id, struct pt_regs *reg
 static void snd_mpu401_uart_timer(unsigned long data)
 {
 	struct snd_mpu401 *mpu = (struct snd_mpu401 *)data;
+	unsigned long flags;
 
-	spin_lock(&mpu->timer_lock);
+	spin_lock_irqsave(&mpu->timer_lock, flags);
 	/*mpu->mode |= MPU401_MODE_TIMER;*/
 	mpu->timer.expires = 1 + jiffies;
 	add_timer(&mpu->timer);
-	spin_unlock(&mpu->timer_lock);
+	spin_unlock_irqrestore(&mpu->timer_lock, flags);
 	if (mpu->rmidi)
 		_snd_mpu401_uart_interrupt(mpu);
 }

commit 73e77ba0235532bd7523ba90883d325f6e095acf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 17:44:01 2005 +0100

    [ALSA] Add error messages
    
    Add error messages in the critial error path to be more verbose.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 16e87f31788c..ee67b522d259 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -462,6 +462,7 @@ int snd_mpu401_uart_new(struct snd_card *card, int device,
 		return err;
 	mpu = kzalloc(sizeof(*mpu), GFP_KERNEL);
 	if (mpu == NULL) {
+		snd_printk(KERN_ERR "mpu401_uart: cannot allocate\n");
 		snd_device_free(card, rmidi);
 		return -ENOMEM;
 	}

commit e1fad17bb4084dc7c435360185417aed55656ec8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:12:45 2005 +0100

    [ALSA] Remove xxx_t typedefs: MPU401
    
    Modules: MPU401 UART
    
    Remove xxx_t typedefs from the MPU401-UART and MPU401 drivers
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index bdeb2c00dac5..16e87f31788c 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -43,8 +43,8 @@ MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
 MODULE_DESCRIPTION("Routines for control of MPU-401 in UART mode");
 MODULE_LICENSE("GPL");
 
-static void snd_mpu401_uart_input_read(mpu401_t * mpu);
-static void snd_mpu401_uart_output_write(mpu401_t * mpu);
+static void snd_mpu401_uart_input_read(struct snd_mpu401 * mpu);
+static void snd_mpu401_uart_output_write(struct snd_mpu401 * mpu);
 
 /*
 
@@ -58,28 +58,28 @@ static void snd_mpu401_uart_output_write(mpu401_t * mpu);
 #define MPU401_ACK		0xfe
 
 /* Build in lowlevel io */
-static void mpu401_write_port(mpu401_t *mpu, unsigned char data, unsigned long addr)
+static void mpu401_write_port(struct snd_mpu401 *mpu, unsigned char data, unsigned long addr)
 {
 	outb(data, addr);
 }
 
-static unsigned char mpu401_read_port(mpu401_t *mpu, unsigned long addr)
+static unsigned char mpu401_read_port(struct snd_mpu401 *mpu, unsigned long addr)
 {
 	return inb(addr);
 }
 
-static void mpu401_write_mmio(mpu401_t *mpu, unsigned char data, unsigned long addr)
+static void mpu401_write_mmio(struct snd_mpu401 *mpu, unsigned char data, unsigned long addr)
 {
 	writeb(data, (void __iomem *)addr);
 }
 
-static unsigned char mpu401_read_mmio(mpu401_t *mpu, unsigned long addr)
+static unsigned char mpu401_read_mmio(struct snd_mpu401 *mpu, unsigned long addr)
 {
 	return readb((void __iomem *)addr);
 }
 /*  */
 
-static void snd_mpu401_uart_clear_rx(mpu401_t *mpu)
+static void snd_mpu401_uart_clear_rx(struct snd_mpu401 *mpu)
 {
 	int timeout = 100000;
 	for (; timeout > 0 && snd_mpu401_input_avail(mpu); timeout--)
@@ -90,7 +90,7 @@ static void snd_mpu401_uart_clear_rx(mpu401_t *mpu)
 #endif
 }
 
-static void _snd_mpu401_uart_interrupt(mpu401_t *mpu)
+static void _snd_mpu401_uart_interrupt(struct snd_mpu401 *mpu)
 {
 	spin_lock(&mpu->input_lock);
 	if (test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode)) {
@@ -118,7 +118,7 @@ static void _snd_mpu401_uart_interrupt(mpu401_t *mpu)
  */
 irqreturn_t snd_mpu401_uart_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	mpu401_t *mpu = dev_id;
+	struct snd_mpu401 *mpu = dev_id;
 	
 	if (mpu == NULL)
 		return IRQ_NONE;
@@ -132,7 +132,7 @@ irqreturn_t snd_mpu401_uart_interrupt(int irq, void *dev_id, struct pt_regs *reg
  */
 static void snd_mpu401_uart_timer(unsigned long data)
 {
-	mpu401_t *mpu = (mpu401_t *)data;
+	struct snd_mpu401 *mpu = (struct snd_mpu401 *)data;
 
 	spin_lock(&mpu->timer_lock);
 	/*mpu->mode |= MPU401_MODE_TIMER;*/
@@ -146,7 +146,7 @@ static void snd_mpu401_uart_timer(unsigned long data)
 /*
  * initialize the timer callback if not programmed yet
  */
-static void snd_mpu401_uart_add_timer (mpu401_t *mpu, int input)
+static void snd_mpu401_uart_add_timer (struct snd_mpu401 *mpu, int input)
 {
 	unsigned long flags;
 
@@ -165,7 +165,7 @@ static void snd_mpu401_uart_add_timer (mpu401_t *mpu, int input)
 /*
  * remove the timer callback if still active
  */
-static void snd_mpu401_uart_remove_timer (mpu401_t *mpu, int input)
+static void snd_mpu401_uart_remove_timer (struct snd_mpu401 *mpu, int input)
 {
 	unsigned long flags;
 
@@ -182,7 +182,7 @@ static void snd_mpu401_uart_remove_timer (mpu401_t *mpu, int input)
 
  */
 
-static void snd_mpu401_uart_cmd(mpu401_t * mpu, unsigned char cmd, int ack)
+static void snd_mpu401_uart_cmd(struct snd_mpu401 * mpu, unsigned char cmd, int ack)
 {
 	unsigned long flags;
 	int timeout, ok;
@@ -225,9 +225,9 @@ static void snd_mpu401_uart_cmd(mpu401_t * mpu, unsigned char cmd, int ack)
 /*
  * input/output open/close - protected by open_mutex in rawmidi.c
  */
-static int snd_mpu401_uart_input_open(snd_rawmidi_substream_t * substream)
+static int snd_mpu401_uart_input_open(struct snd_rawmidi_substream *substream)
 {
-	mpu401_t *mpu;
+	struct snd_mpu401 *mpu;
 	int err;
 
 	mpu = substream->rmidi->private_data;
@@ -242,9 +242,9 @@ static int snd_mpu401_uart_input_open(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static int snd_mpu401_uart_output_open(snd_rawmidi_substream_t * substream)
+static int snd_mpu401_uart_output_open(struct snd_rawmidi_substream *substream)
 {
-	mpu401_t *mpu;
+	struct snd_mpu401 *mpu;
 	int err;
 
 	mpu = substream->rmidi->private_data;
@@ -259,9 +259,9 @@ static int snd_mpu401_uart_output_open(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static int snd_mpu401_uart_input_close(snd_rawmidi_substream_t * substream)
+static int snd_mpu401_uart_input_close(struct snd_rawmidi_substream *substream)
 {
-	mpu401_t *mpu;
+	struct snd_mpu401 *mpu;
 
 	mpu = substream->rmidi->private_data;
 	clear_bit(MPU401_MODE_BIT_INPUT, &mpu->mode);
@@ -273,9 +273,9 @@ static int snd_mpu401_uart_input_close(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static int snd_mpu401_uart_output_close(snd_rawmidi_substream_t * substream)
+static int snd_mpu401_uart_output_close(struct snd_rawmidi_substream *substream)
 {
-	mpu401_t *mpu;
+	struct snd_mpu401 *mpu;
 
 	mpu = substream->rmidi->private_data;
 	clear_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode);
@@ -290,10 +290,10 @@ static int snd_mpu401_uart_output_close(snd_rawmidi_substream_t * substream)
 /*
  * trigger input callback
  */
-static void snd_mpu401_uart_input_trigger(snd_rawmidi_substream_t * substream, int up)
+static void snd_mpu401_uart_input_trigger(struct snd_rawmidi_substream *substream, int up)
 {
 	unsigned long flags;
-	mpu401_t *mpu;
+	struct snd_mpu401 *mpu;
 	int max = 64;
 
 	mpu = substream->rmidi->private_data;
@@ -321,7 +321,7 @@ static void snd_mpu401_uart_input_trigger(snd_rawmidi_substream_t * substream, i
  * transfer input pending data
  * call with input_lock spinlock held
  */
-static void snd_mpu401_uart_input_read(mpu401_t * mpu)
+static void snd_mpu401_uart_input_read(struct snd_mpu401 * mpu)
 {
 	int max = 128;
 	unsigned char byte;
@@ -349,7 +349,7 @@ static void snd_mpu401_uart_input_read(mpu401_t * mpu)
  * write output pending bytes
  * call with output_lock spinlock held
  */
-static void snd_mpu401_uart_output_write(mpu401_t * mpu)
+static void snd_mpu401_uart_output_write(struct snd_mpu401 * mpu)
 {
 	unsigned char byte;
 	int max = 256, timeout;
@@ -375,10 +375,10 @@ static void snd_mpu401_uart_output_write(mpu401_t * mpu)
 /*
  * output trigger callback
  */
-static void snd_mpu401_uart_output_trigger(snd_rawmidi_substream_t * substream, int up)
+static void snd_mpu401_uart_output_trigger(struct snd_rawmidi_substream *substream, int up)
 {
 	unsigned long flags;
-	mpu401_t *mpu;
+	struct snd_mpu401 *mpu;
 
 	mpu = substream->rmidi->private_data;
 	if (up) {
@@ -404,23 +404,23 @@ static void snd_mpu401_uart_output_trigger(snd_rawmidi_substream_t * substream,
 
  */
 
-static snd_rawmidi_ops_t snd_mpu401_uart_output =
+static struct snd_rawmidi_ops snd_mpu401_uart_output =
 {
 	.open =		snd_mpu401_uart_output_open,
 	.close =	snd_mpu401_uart_output_close,
 	.trigger =	snd_mpu401_uart_output_trigger,
 };
 
-static snd_rawmidi_ops_t snd_mpu401_uart_input =
+static struct snd_rawmidi_ops snd_mpu401_uart_input =
 {
 	.open =		snd_mpu401_uart_input_open,
 	.close =	snd_mpu401_uart_input_close,
 	.trigger =	snd_mpu401_uart_input_trigger,
 };
 
-static void snd_mpu401_uart_free(snd_rawmidi_t *rmidi)
+static void snd_mpu401_uart_free(struct snd_rawmidi *rmidi)
 {
-	mpu401_t *mpu = rmidi->private_data;
+	struct snd_mpu401 *mpu = rmidi->private_data;
 	if (mpu->irq_flags && mpu->irq >= 0)
 		free_irq(mpu->irq, (void *) mpu);
 	release_and_free_resource(mpu->res);
@@ -442,18 +442,18 @@ static void snd_mpu401_uart_free(snd_rawmidi_t *rmidi)
  *
  * Note that the rawmidi instance is returned on the rrawmidi argument,
  * not the mpu401 instance itself.  To access to the mpu401 instance,
- * cast from rawmidi->private_data (with mpu401_t magic-cast).
+ * cast from rawmidi->private_data (with struct snd_mpu401 magic-cast).
  *
  * Returns zero if successful, or a negative error code.
  */
-int snd_mpu401_uart_new(snd_card_t * card, int device,
+int snd_mpu401_uart_new(struct snd_card *card, int device,
 			unsigned short hardware,
 			unsigned long port, int integrated,
 			int irq, int irq_flags,
-			snd_rawmidi_t ** rrawmidi)
+			struct snd_rawmidi ** rrawmidi)
 {
-	mpu401_t *mpu;
-	snd_rawmidi_t *rmidi;
+	struct snd_mpu401 *mpu;
+	struct snd_rawmidi *rmidi;
 	int err;
 
 	if (rrawmidi)

commit b1d5776d865951c213a1caaab5d8bf5de7615dbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:56:31 2005 +0200

    [ALSA] Remove vmalloc wrapper, kfree_nocheck()
    
    - Remove vmalloc wrapper
    - Add release_and_free_resource() to remove kfree_nocheck() from each driver
      and simplify the code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index fe3f921ffbe3..bdeb2c00dac5 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -423,10 +423,7 @@ static void snd_mpu401_uart_free(snd_rawmidi_t *rmidi)
 	mpu401_t *mpu = rmidi->private_data;
 	if (mpu->irq_flags && mpu->irq >= 0)
 		free_irq(mpu->irq, (void *) mpu);
-	if (mpu->res) {
-		release_resource(mpu->res);
-		kfree_nocheck(mpu->res);
-	}
+	release_and_free_resource(mpu->res);
 	kfree(mpu);
 }
 

commit 561b220a4dece18d67177413e6fa21b49aa4acce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:22:34 2005 +0200

    [ALSA] Replace with kzalloc() - others
    
    Documentation,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,OPL3
    OPL4,Digigram VX core,I2C cs8427,I2C lib core,I2C tea6330t,L3 drivers
    AK4114 receiver,AK4117 receiver,PDAudioCF driver,PPC PMAC driver
    SPARC AMD7930 driver,SPARC cs4231 driver,Synth,Common EMU synth
    USB generic driver,USB USX2Y
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
index 0f83c5241b6b..fe3f921ffbe3 100644
--- a/sound/drivers/mpu401/mpu401_uart.c
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -463,7 +463,7 @@ int snd_mpu401_uart_new(snd_card_t * card, int device,
 		*rrawmidi = NULL;
 	if ((err = snd_rawmidi_new(card, "MPU-401U", device, 1, 1, &rmidi)) < 0)
 		return err;
-	mpu = kcalloc(1, sizeof(*mpu), GFP_KERNEL);
+	mpu = kzalloc(sizeof(*mpu), GFP_KERNEL);
 	if (mpu == NULL) {
 		snd_device_free(card, rmidi);
 		return -ENOMEM;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/drivers/mpu401/mpu401_uart.c b/sound/drivers/mpu401/mpu401_uart.c
new file mode 100644
index 000000000000..0f83c5241b6b
--- /dev/null
+++ b/sound/drivers/mpu401/mpu401_uart.c
@@ -0,0 +1,541 @@
+/*
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Routines for control of MPU-401 in UART mode
+ *
+ *  MPU-401 supports UART mode which is not capable generate transmit
+ *  interrupts thus output is done via polling. Also, if irq < 0, then
+ *  input is done also via polling. Do not expect good performance.
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *   13-03-2003:
+ *      Added support for different kind of hardware I/O. Build in choices
+ *      are port and mmio. For other kind of I/O, set mpu->read and
+ *      mpu->write to your own I/O functions.
+ *
+ */
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <sound/core.h>
+#include <sound/mpu401.h>
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_DESCRIPTION("Routines for control of MPU-401 in UART mode");
+MODULE_LICENSE("GPL");
+
+static void snd_mpu401_uart_input_read(mpu401_t * mpu);
+static void snd_mpu401_uart_output_write(mpu401_t * mpu);
+
+/*
+
+ */
+
+#define snd_mpu401_input_avail(mpu)	(!(mpu->read(mpu, MPU401C(mpu)) & 0x80))
+#define snd_mpu401_output_ready(mpu)	(!(mpu->read(mpu, MPU401C(mpu)) & 0x40))
+
+#define MPU401_RESET		0xff
+#define MPU401_ENTER_UART	0x3f
+#define MPU401_ACK		0xfe
+
+/* Build in lowlevel io */
+static void mpu401_write_port(mpu401_t *mpu, unsigned char data, unsigned long addr)
+{
+	outb(data, addr);
+}
+
+static unsigned char mpu401_read_port(mpu401_t *mpu, unsigned long addr)
+{
+	return inb(addr);
+}
+
+static void mpu401_write_mmio(mpu401_t *mpu, unsigned char data, unsigned long addr)
+{
+	writeb(data, (void __iomem *)addr);
+}
+
+static unsigned char mpu401_read_mmio(mpu401_t *mpu, unsigned long addr)
+{
+	return readb((void __iomem *)addr);
+}
+/*  */
+
+static void snd_mpu401_uart_clear_rx(mpu401_t *mpu)
+{
+	int timeout = 100000;
+	for (; timeout > 0 && snd_mpu401_input_avail(mpu); timeout--)
+		mpu->read(mpu, MPU401D(mpu));
+#ifdef CONFIG_SND_DEBUG
+	if (timeout <= 0)
+		snd_printk("cmd: clear rx timeout (status = 0x%x)\n", mpu->read(mpu, MPU401C(mpu)));
+#endif
+}
+
+static void _snd_mpu401_uart_interrupt(mpu401_t *mpu)
+{
+	spin_lock(&mpu->input_lock);
+	if (test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode)) {
+		snd_mpu401_uart_input_read(mpu);
+	} else {
+		snd_mpu401_uart_clear_rx(mpu);
+	}
+	spin_unlock(&mpu->input_lock);
+ 	/* ok. for better Tx performance try do some output when input is done */
+	if (test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode) &&
+	    test_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode)) {
+		spin_lock(&mpu->output_lock);
+		snd_mpu401_uart_output_write(mpu);
+		spin_unlock(&mpu->output_lock);
+	}
+}
+
+/**
+ * snd_mpu401_uart_interrupt - generic MPU401-UART interrupt handler
+ * @irq: the irq number
+ * @dev_id: mpu401 instance
+ * @regs: the reigster
+ *
+ * Processes the interrupt for MPU401-UART i/o.
+ */
+irqreturn_t snd_mpu401_uart_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	mpu401_t *mpu = dev_id;
+	
+	if (mpu == NULL)
+		return IRQ_NONE;
+	_snd_mpu401_uart_interrupt(mpu);
+	return IRQ_HANDLED;
+}
+
+/*
+ * timer callback
+ * reprogram the timer and call the interrupt job
+ */
+static void snd_mpu401_uart_timer(unsigned long data)
+{
+	mpu401_t *mpu = (mpu401_t *)data;
+
+	spin_lock(&mpu->timer_lock);
+	/*mpu->mode |= MPU401_MODE_TIMER;*/
+	mpu->timer.expires = 1 + jiffies;
+	add_timer(&mpu->timer);
+	spin_unlock(&mpu->timer_lock);
+	if (mpu->rmidi)
+		_snd_mpu401_uart_interrupt(mpu);
+}
+
+/*
+ * initialize the timer callback if not programmed yet
+ */
+static void snd_mpu401_uart_add_timer (mpu401_t *mpu, int input)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave (&mpu->timer_lock, flags);
+	if (mpu->timer_invoked == 0) {
+		init_timer(&mpu->timer);
+		mpu->timer.data = (unsigned long)mpu;
+		mpu->timer.function = snd_mpu401_uart_timer;
+		mpu->timer.expires = 1 + jiffies;
+		add_timer(&mpu->timer);
+	} 
+	mpu->timer_invoked |= input ? MPU401_MODE_INPUT_TIMER : MPU401_MODE_OUTPUT_TIMER;
+	spin_unlock_irqrestore (&mpu->timer_lock, flags);
+}
+
+/*
+ * remove the timer callback if still active
+ */
+static void snd_mpu401_uart_remove_timer (mpu401_t *mpu, int input)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave (&mpu->timer_lock, flags);
+	if (mpu->timer_invoked) {
+		mpu->timer_invoked &= input ? ~MPU401_MODE_INPUT_TIMER : ~MPU401_MODE_OUTPUT_TIMER;
+		if (! mpu->timer_invoked)
+			del_timer(&mpu->timer);
+	}
+	spin_unlock_irqrestore (&mpu->timer_lock, flags);
+}
+
+/*
+
+ */
+
+static void snd_mpu401_uart_cmd(mpu401_t * mpu, unsigned char cmd, int ack)
+{
+	unsigned long flags;
+	int timeout, ok;
+
+	spin_lock_irqsave(&mpu->input_lock, flags);
+	if (mpu->hardware != MPU401_HW_TRID4DWAVE) {
+		mpu->write(mpu, 0x00, MPU401D(mpu));
+		/*snd_mpu401_uart_clear_rx(mpu);*/
+	}
+	/* ok. standard MPU-401 initialization */
+	if (mpu->hardware != MPU401_HW_SB) {
+		for (timeout = 1000; timeout > 0 && !snd_mpu401_output_ready(mpu); timeout--)
+			udelay(10);
+#ifdef CONFIG_SND_DEBUG
+		if (!timeout)
+			snd_printk("cmd: tx timeout (status = 0x%x)\n", mpu->read(mpu, MPU401C(mpu)));
+#endif
+	}
+	mpu->write(mpu, cmd, MPU401C(mpu));
+	if (ack) {
+		ok = 0;
+		timeout = 10000;
+		while (!ok && timeout-- > 0) {
+			if (snd_mpu401_input_avail(mpu)) {
+				if (mpu->read(mpu, MPU401D(mpu)) == MPU401_ACK)
+					ok = 1;
+			}
+		}
+		if (!ok && mpu->read(mpu, MPU401D(mpu)) == MPU401_ACK)
+			ok = 1;
+	} else {
+		ok = 1;
+	}
+	spin_unlock_irqrestore(&mpu->input_lock, flags);
+	if (! ok)
+		snd_printk("cmd: 0x%x failed at 0x%lx (status = 0x%x, data = 0x%x)\n", cmd, mpu->port, mpu->read(mpu, MPU401C(mpu)), mpu->read(mpu, MPU401D(mpu)));
+	// snd_printk("cmd: 0x%x at 0x%lx (status = 0x%x, data = 0x%x)\n", cmd, mpu->port, mpu->read(mpu, MPU401C(mpu)), mpu->read(mpu, MPU401D(mpu)));
+}
+
+/*
+ * input/output open/close - protected by open_mutex in rawmidi.c
+ */
+static int snd_mpu401_uart_input_open(snd_rawmidi_substream_t * substream)
+{
+	mpu401_t *mpu;
+	int err;
+
+	mpu = substream->rmidi->private_data;
+	if (mpu->open_input && (err = mpu->open_input(mpu)) < 0)
+		return err;
+	if (! test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode)) {
+		snd_mpu401_uart_cmd(mpu, MPU401_RESET, 1);
+		snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 1);
+	}
+	mpu->substream_input = substream;
+	set_bit(MPU401_MODE_BIT_INPUT, &mpu->mode);
+	return 0;
+}
+
+static int snd_mpu401_uart_output_open(snd_rawmidi_substream_t * substream)
+{
+	mpu401_t *mpu;
+	int err;
+
+	mpu = substream->rmidi->private_data;
+	if (mpu->open_output && (err = mpu->open_output(mpu)) < 0)
+		return err;
+	if (! test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode)) {
+		snd_mpu401_uart_cmd(mpu, MPU401_RESET, 1);
+		snd_mpu401_uart_cmd(mpu, MPU401_ENTER_UART, 1);
+	}
+	mpu->substream_output = substream;
+	set_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode);
+	return 0;
+}
+
+static int snd_mpu401_uart_input_close(snd_rawmidi_substream_t * substream)
+{
+	mpu401_t *mpu;
+
+	mpu = substream->rmidi->private_data;
+	clear_bit(MPU401_MODE_BIT_INPUT, &mpu->mode);
+	mpu->substream_input = NULL;
+	if (! test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode))
+		snd_mpu401_uart_cmd(mpu, MPU401_RESET, 0);
+	if (mpu->close_input)
+		mpu->close_input(mpu);
+	return 0;
+}
+
+static int snd_mpu401_uart_output_close(snd_rawmidi_substream_t * substream)
+{
+	mpu401_t *mpu;
+
+	mpu = substream->rmidi->private_data;
+	clear_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode);
+	mpu->substream_output = NULL;
+	if (! test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode))
+		snd_mpu401_uart_cmd(mpu, MPU401_RESET, 0);
+	if (mpu->close_output)
+		mpu->close_output(mpu);
+	return 0;
+}
+
+/*
+ * trigger input callback
+ */
+static void snd_mpu401_uart_input_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	unsigned long flags;
+	mpu401_t *mpu;
+	int max = 64;
+
+	mpu = substream->rmidi->private_data;
+	if (up) {
+		if (! test_and_set_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode)) {
+			/* first time - flush FIFO */
+			while (max-- > 0)
+				mpu->read(mpu, MPU401D(mpu));
+			if (mpu->irq < 0)
+				snd_mpu401_uart_add_timer(mpu, 1);
+		}
+		
+		/* read data in advance */
+		spin_lock_irqsave(&mpu->input_lock, flags);
+		snd_mpu401_uart_input_read(mpu);
+		spin_unlock_irqrestore(&mpu->input_lock, flags);
+	} else {
+		if (mpu->irq < 0)
+			snd_mpu401_uart_remove_timer(mpu, 1);
+		clear_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode);
+	}
+}
+
+/*
+ * transfer input pending data
+ * call with input_lock spinlock held
+ */
+static void snd_mpu401_uart_input_read(mpu401_t * mpu)
+{
+	int max = 128;
+	unsigned char byte;
+
+	while (max-- > 0) {
+		if (snd_mpu401_input_avail(mpu)) {
+			byte = mpu->read(mpu, MPU401D(mpu));
+			if (test_bit(MPU401_MODE_BIT_INPUT_TRIGGER, &mpu->mode))
+				snd_rawmidi_receive(mpu->substream_input, &byte, 1);
+		} else {
+			break; /* input not available */
+		}
+	}
+}
+
+/*
+ *  Tx FIFO sizes:
+ *    CS4237B			- 16 bytes
+ *    AudioDrive ES1688         - 12 bytes
+ *    S3 SonicVibes             -  8 bytes
+ *    SoundBlaster AWE 64       -  2 bytes (ugly hardware)
+ */
+
+/*
+ * write output pending bytes
+ * call with output_lock spinlock held
+ */
+static void snd_mpu401_uart_output_write(mpu401_t * mpu)
+{
+	unsigned char byte;
+	int max = 256, timeout;
+
+	do {
+		if (snd_rawmidi_transmit_peek(mpu->substream_output, &byte, 1) == 1) {
+			for (timeout = 100; timeout > 0; timeout--) {
+				if (snd_mpu401_output_ready(mpu)) {
+					mpu->write(mpu, byte, MPU401D(mpu));
+					snd_rawmidi_transmit_ack(mpu->substream_output, 1);
+					break;
+				}
+			}
+			if (timeout == 0)
+				break;	/* Tx FIFO full - try again later */
+		} else {
+			snd_mpu401_uart_remove_timer (mpu, 0);
+			break;	/* no other data - leave the tx loop */
+		}
+	} while (--max > 0);
+}
+
+/*
+ * output trigger callback
+ */
+static void snd_mpu401_uart_output_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	unsigned long flags;
+	mpu401_t *mpu;
+
+	mpu = substream->rmidi->private_data;
+	if (up) {
+		set_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode);
+
+		/* try to add the timer at each output trigger,
+		 * since the output timer might have been removed in
+		 * snd_mpu401_uart_output_write().
+		 */
+		snd_mpu401_uart_add_timer(mpu, 0);
+
+		/* output pending data */
+		spin_lock_irqsave(&mpu->output_lock, flags);
+		snd_mpu401_uart_output_write(mpu);
+		spin_unlock_irqrestore(&mpu->output_lock, flags);
+	} else {
+		snd_mpu401_uart_remove_timer(mpu, 0);
+		clear_bit(MPU401_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode);
+	}
+}
+
+/*
+
+ */
+
+static snd_rawmidi_ops_t snd_mpu401_uart_output =
+{
+	.open =		snd_mpu401_uart_output_open,
+	.close =	snd_mpu401_uart_output_close,
+	.trigger =	snd_mpu401_uart_output_trigger,
+};
+
+static snd_rawmidi_ops_t snd_mpu401_uart_input =
+{
+	.open =		snd_mpu401_uart_input_open,
+	.close =	snd_mpu401_uart_input_close,
+	.trigger =	snd_mpu401_uart_input_trigger,
+};
+
+static void snd_mpu401_uart_free(snd_rawmidi_t *rmidi)
+{
+	mpu401_t *mpu = rmidi->private_data;
+	if (mpu->irq_flags && mpu->irq >= 0)
+		free_irq(mpu->irq, (void *) mpu);
+	if (mpu->res) {
+		release_resource(mpu->res);
+		kfree_nocheck(mpu->res);
+	}
+	kfree(mpu);
+}
+
+/**
+ * snd_mpu401_uart_new - create an MPU401-UART instance
+ * @card: the card instance
+ * @device: the device index, zero-based
+ * @hardware: the hardware type, MPU401_HW_XXXX
+ * @port: the base address of MPU401 port
+ * @integrated: non-zero if the port was already reserved by the chip
+ * @irq: the irq number, -1 if no interrupt for mpu
+ * @irq_flags: the irq request flags (SA_XXX), 0 if irq was already reserved.
+ * @rrawmidi: the pointer to store the new rawmidi instance
+ *
+ * Creates a new MPU-401 instance.
+ *
+ * Note that the rawmidi instance is returned on the rrawmidi argument,
+ * not the mpu401 instance itself.  To access to the mpu401 instance,
+ * cast from rawmidi->private_data (with mpu401_t magic-cast).
+ *
+ * Returns zero if successful, or a negative error code.
+ */
+int snd_mpu401_uart_new(snd_card_t * card, int device,
+			unsigned short hardware,
+			unsigned long port, int integrated,
+			int irq, int irq_flags,
+			snd_rawmidi_t ** rrawmidi)
+{
+	mpu401_t *mpu;
+	snd_rawmidi_t *rmidi;
+	int err;
+
+	if (rrawmidi)
+		*rrawmidi = NULL;
+	if ((err = snd_rawmidi_new(card, "MPU-401U", device, 1, 1, &rmidi)) < 0)
+		return err;
+	mpu = kcalloc(1, sizeof(*mpu), GFP_KERNEL);
+	if (mpu == NULL) {
+		snd_device_free(card, rmidi);
+		return -ENOMEM;
+	}
+	rmidi->private_data = mpu;
+	rmidi->private_free = snd_mpu401_uart_free;
+	spin_lock_init(&mpu->input_lock);
+	spin_lock_init(&mpu->output_lock);
+	spin_lock_init(&mpu->timer_lock);
+	mpu->hardware = hardware;
+	if (!integrated) {
+		int res_size = hardware == MPU401_HW_PC98II ? 4 : 2;
+		if ((mpu->res = request_region(port, res_size, "MPU401 UART")) == NULL) {
+			snd_printk(KERN_ERR "mpu401_uart: unable to grab port 0x%lx size %d\n", port, res_size);
+			snd_device_free(card, rmidi);
+			return -EBUSY;
+		}
+	}
+	switch (hardware) {
+	case MPU401_HW_AUREAL:
+		mpu->write = mpu401_write_mmio;
+		mpu->read = mpu401_read_mmio;
+		break;
+	default:
+		mpu->write = mpu401_write_port;
+		mpu->read = mpu401_read_port;
+		break;
+	}
+	mpu->port = port;
+	if (hardware == MPU401_HW_PC98II)
+		mpu->cport = port + 2;
+	else
+		mpu->cport = port + 1;
+	if (irq >= 0 && irq_flags) {
+		if (request_irq(irq, snd_mpu401_uart_interrupt, irq_flags, "MPU401 UART", (void *) mpu)) {
+			snd_printk(KERN_ERR "mpu401_uart: unable to grab IRQ %d\n", irq);
+			snd_device_free(card, rmidi);
+			return -EBUSY;
+		}
+	}
+	mpu->irq = irq;
+	mpu->irq_flags = irq_flags;
+	if (card->shortname[0])
+		snprintf(rmidi->name, sizeof(rmidi->name), "%s MIDI", card->shortname);
+	else
+		sprintf(rmidi->name, "MPU-401 MIDI %d-%d", card->number, device);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_mpu401_uart_output);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_mpu401_uart_input);
+	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |
+	                     SNDRV_RAWMIDI_INFO_INPUT |
+	                     SNDRV_RAWMIDI_INFO_DUPLEX;
+	mpu->rmidi = rmidi;
+	if (rrawmidi)
+		*rrawmidi = rmidi;
+	return 0;
+}
+
+EXPORT_SYMBOL(snd_mpu401_uart_interrupt);
+EXPORT_SYMBOL(snd_mpu401_uart_new);
+
+/*
+ *  INIT part
+ */
+
+static int __init alsa_mpu401_uart_init(void)
+{
+	return 0;
+}
+
+static void __exit alsa_mpu401_uart_exit(void)
+{
+}
+
+module_init(alsa_mpu401_uart_init)
+module_exit(alsa_mpu401_uart_exit)
