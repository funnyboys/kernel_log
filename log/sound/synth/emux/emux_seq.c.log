commit aad7ebb544072bcb9335fa4eb0fbd1b85a6c495b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:45 2020 +0100

    ALSA: seq: Constify struct snd_midi_op
    
    Change the argument of snd_midi_process_event() to receive a const
    snd_midi_op pointer and its callers respectively.  This allows further
    optimizations.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-30-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index 9d8a69f1a644..b227c7e0bc2a 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -19,7 +19,7 @@ static int snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *inf
 /*
  * MIDI emulation operators
  */
-static struct snd_midi_op emux_ops = {
+static const struct snd_midi_op emux_ops = {
 	.note_on = snd_emux_note_on,
 	.note_off = snd_emux_note_off,
 	.key_press = snd_emux_key_press,

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index 396c406d0f77..9d8a69f1a644 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -1,22 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Midi Sequencer interface routines.
  *
  *  Copyright (C) 1999 Steve Ratcliffe
  *  Copyright (c) 1999-2000 Takashi Iwai <tiwai@suse.de>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include "emux_voice.h"

commit 64a591e67e30599bed0179f187e034cc0828010e
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Wed Aug 9 09:30:34 2017 +0200

    ALSA: emux: Delete two error messages for a failed memory allocation in snd_emux_create_port()
    
    Omit extra messages for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Link: http://events.linuxfoundation.org/sites/events/files/slides/LCJ16-Refactor_Strings-WSang_0.pdf
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index fd6cbd439511..396c406d0f77 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -145,14 +145,12 @@ snd_emux_create_port(struct snd_emux *emu, char *name,
 
 	/* Allocate structures for this channel */
 	p = kzalloc(sizeof(*p), GFP_KERNEL);
-	if (!p) {
-		snd_printk(KERN_ERR "no memory\n");
+	if (!p)
 		return NULL;
-	}
+
 	p->chset.channels = kcalloc(max_channels, sizeof(*p->chset.channels),
 				    GFP_KERNEL);
 	if (!p->chset.channels) {
-		snd_printk(KERN_ERR "no memory\n");
 		kfree(p);
 		return NULL;
 	}

commit fbc020b48c85fc7e4ca42ceb095c76f294b00043
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Wed Aug 9 09:22:42 2017 +0200

    ALSA: emux: Adjust four checks for null pointers
    
    MIME-Version: 1.0
    Content-Type: text/plain; charset=UTF-8
    Content-Transfer-Encoding: 8bit
    
    The script “checkpatch.pl” pointed information out like the following.
    
    Comparison to NULL could be written !…
    
    Thus fix affected source code places.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index 12acf18c5be4..fd6cbd439511 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -99,7 +99,7 @@ snd_emux_init_seq(struct snd_emux *emu, struct snd_card *card, int index)
 		sprintf(tmpname, "%s Port %d", emu->name, i);
 		p = snd_emux_create_port(emu, tmpname, MIDI_CHANNELS,
 					 0, &pinfo);
-		if (p == NULL) {
+		if (!p) {
 			snd_printk(KERN_ERR "can't create port\n");
 			return -ENOMEM;
 		}
@@ -151,7 +151,7 @@ snd_emux_create_port(struct snd_emux *emu, char *name,
 	}
 	p->chset.channels = kcalloc(max_channels, sizeof(*p->chset.channels),
 				    GFP_KERNEL);
-	if (p->chset.channels == NULL) {
+	if (!p->chset.channels) {
 		snd_printk(KERN_ERR "no memory\n");
 		kfree(p);
 		return NULL;
@@ -373,7 +373,7 @@ int snd_emux_init_virmidi(struct snd_emux *emu, struct snd_card *card)
 		return 0;
 
 	emu->vmidi = kcalloc(emu->midi_ports, sizeof(*emu->vmidi), GFP_KERNEL);
-	if (emu->vmidi == NULL)
+	if (!emu->vmidi)
 		return -ENOMEM;
 
 	for (i = 0; i < emu->midi_ports; i++) {
@@ -405,7 +405,7 @@ int snd_emux_delete_virmidi(struct snd_emux *emu)
 {
 	int i;
 
-	if (emu->vmidi == NULL)
+	if (!emu->vmidi)
 		return 0;
 
 	for (i = 0; i < emu->midi_ports; i++) {

commit 949a0c23de89c02907970de7214c16b47ccf0482
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Wed Aug 9 09:11:26 2017 +0200

    ALSA: emux: Improve a size determination in two functions
    
    Replace the specification of data types by pointer dereferences
    as the parameter for the operator "sizeof" to make the corresponding size
    determination a bit safer according to the Linux coding style convention.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index 53820f75ba3e..12acf18c5be4 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -149,7 +149,8 @@ snd_emux_create_port(struct snd_emux *emu, char *name,
 		snd_printk(KERN_ERR "no memory\n");
 		return NULL;
 	}
-	p->chset.channels = kcalloc(max_channels, sizeof(struct snd_midi_channel), GFP_KERNEL);
+	p->chset.channels = kcalloc(max_channels, sizeof(*p->chset.channels),
+				    GFP_KERNEL);
 	if (p->chset.channels == NULL) {
 		snd_printk(KERN_ERR "no memory\n");
 		kfree(p);
@@ -371,7 +372,7 @@ int snd_emux_init_virmidi(struct snd_emux *emu, struct snd_card *card)
 	if (emu->midi_ports <= 0)
 		return 0;
 
-	emu->vmidi = kcalloc(emu->midi_ports, sizeof(struct snd_rawmidi *), GFP_KERNEL);
+	emu->vmidi = kcalloc(emu->midi_ports, sizeof(*emu->vmidi), GFP_KERNEL);
 	if (emu->vmidi == NULL)
 		return -ENOMEM;
 

commit c997aabbd3503c61901059caf457115098f344a4
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Wed Aug 9 08:40:14 2017 +0200

    ALSA: emux: Adjust one function call together with a variable assignment
    
    The script "checkpatch.pl" pointed information out like the following.
    
    ERROR: do not use assignment in if condition
    
    Thus fix the affected source code place.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index 55579f6b8cb2..53820f75ba3e 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -144,7 +144,8 @@ snd_emux_create_port(struct snd_emux *emu, char *name,
 	int i, type, cap;
 
 	/* Allocate structures for this channel */
-	if ((p = kzalloc(sizeof(*p), GFP_KERNEL)) == NULL) {
+	p = kzalloc(sizeof(*p), GFP_KERNEL);
+	if (!p) {
 		snd_printk(KERN_ERR "no memory\n");
 		return NULL;
 	}

commit f93a1c9e5e6a8ce05391708157af5bfd71fe6c21
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Dec 16 16:59:44 2016 -0800

    ALSA: synth: use designated initializers
    
    Prepare to mark sensitive kernel structures for randomization by making
    sure they're using designated initializers. These were identified during
    allyesconfig builds of x86, arm, and arm64, with most initializer fixes
    extracted from grsecurity.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index a0209204ae48..55579f6b8cb2 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -33,13 +33,13 @@ static int snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *inf
  * MIDI emulation operators
  */
 static struct snd_midi_op emux_ops = {
-	snd_emux_note_on,
-	snd_emux_note_off,
-	snd_emux_key_press,
-	snd_emux_terminate_note,
-	snd_emux_control,
-	snd_emux_nrpn,
-	snd_emux_sysex,
+	.note_on = snd_emux_note_on,
+	.note_off = snd_emux_note_off,
+	.key_press = snd_emux_key_press,
+	.note_terminate = snd_emux_terminate_note,
+	.control = snd_emux_control,
+	.nrpn = snd_emux_nrpn,
+	.sysex = snd_emux_sysex,
 };
 
 

commit 1c94e65c668f44d2c69ae7e7fc268ab3268fba3e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 28 17:11:44 2015 +0200

    ALSA: emux: Fix mutex deadlock in OSS emulation
    
    The OSS emulation in synth-emux helper has a potential AB/BA deadlock
    at the simultaneous closing and opening:
    
      close ->
        snd_seq_release() ->
          sne_seq_free_client() ->
            snd_seq_delete_all_ports(): takes client->ports_mutex ->
              port_delete() ->
                snd_emux_unuse(): takes emux->register_mutex
    
      open ->
        snd_seq_oss_open() ->
          snd_emux_open_seq_oss(): takes emux->register_mutex ->
            snd_seq_event_port_attach() ->
              snd_seq_create_port(): takes client->ports_mutex
    
    This patch addresses the deadlock by reducing the rance taking
    emux->register_mutex in snd_emux_open_seq_oss().  The lock is needed
    for the refcount handling, so move it locally.  The calls in
    emux_seq.c are already with the mutex, thus they are replaced with the
    version without mutex lock/unlock.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index 188fda0effb0..a0209204ae48 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -267,8 +267,8 @@ snd_emux_event_input(struct snd_seq_event *ev, int direct, void *private_data,
 /*
  * increment usage count
  */
-int
-snd_emux_inc_count(struct snd_emux *emu)
+static int
+__snd_emux_inc_count(struct snd_emux *emu)
 {
 	emu->used++;
 	if (!try_module_get(emu->ops.owner))
@@ -282,12 +282,21 @@ snd_emux_inc_count(struct snd_emux *emu)
 	return 1;
 }
 
+int snd_emux_inc_count(struct snd_emux *emu)
+{
+	int ret;
+
+	mutex_lock(&emu->register_mutex);
+	ret = __snd_emux_inc_count(emu);
+	mutex_unlock(&emu->register_mutex);
+	return ret;
+}
 
 /*
  * decrease usage count
  */
-void
-snd_emux_dec_count(struct snd_emux *emu)
+static void
+__snd_emux_dec_count(struct snd_emux *emu)
 {
 	module_put(emu->card->module);
 	emu->used--;
@@ -296,6 +305,12 @@ snd_emux_dec_count(struct snd_emux *emu)
 	module_put(emu->ops.owner);
 }
 
+void snd_emux_dec_count(struct snd_emux *emu)
+{
+	mutex_lock(&emu->register_mutex);
+	__snd_emux_dec_count(emu);
+	mutex_unlock(&emu->register_mutex);
+}
 
 /*
  * Routine that is called upon a first use of a particular port
@@ -315,7 +330,7 @@ snd_emux_use(void *private_data, struct snd_seq_port_subscribe *info)
 
 	mutex_lock(&emu->register_mutex);
 	snd_emux_init_port(p);
-	snd_emux_inc_count(emu);
+	__snd_emux_inc_count(emu);
 	mutex_unlock(&emu->register_mutex);
 	return 0;
 }
@@ -338,7 +353,7 @@ snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info)
 
 	mutex_lock(&emu->register_mutex);
 	snd_emux_sounds_off_all(p);
-	snd_emux_dec_count(emu);
+	__snd_emux_dec_count(emu);
 	mutex_unlock(&emu->register_mutex);
 	return 0;
 }

commit 07b0e5d49d227e3950cb13a3e8caf248ef2a310e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 27 14:50:39 2015 +0200

    ALSA: emux: Fix mutex deadlock at unloading
    
    The emux-synth driver has a possible AB/BA mutex deadlock at unloading
    the emu10k1 driver:
    
      snd_emux_free() ->
        snd_emux_detach_seq(): mutex_lock(&emu->register_mutex) ->
          snd_seq_delete_kernel_client() ->
            snd_seq_free_client(): mutex_lock(&register_mutex)
    
      snd_seq_release() ->
        snd_seq_free_client(): mutex_lock(&register_mutex) ->
          snd_seq_delete_all_ports() ->
            snd_emux_unuse(): mutex_lock(&emu->register_mutex)
    
    Basically snd_emux_detach_seq() doesn't need a protection of
    emu->register_mutex as it's already being unregistered.  So, we can
    get rid of this for avoiding the deadlock.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index 7778b8e19782..188fda0effb0 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -124,12 +124,10 @@ snd_emux_detach_seq(struct snd_emux *emu)
 	if (emu->voices)
 		snd_emux_terminate_all(emu);
 		
-	mutex_lock(&emu->register_mutex);
 	if (emu->client >= 0) {
 		snd_seq_delete_kernel_client(emu->client);
 		emu->client = -1;
 	}
-	mutex_unlock(&emu->register_mutex);
 }
 
 

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index ca5f7effb4df..7778b8e19782 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -21,7 +21,7 @@
 
 #include "emux_voice.h"
 #include <linux/slab.h>
-
+#include <linux/module.h>
 
 /* Prototypes for static functions */
 static void free_port(void *private);

commit 42b0158bdb1344b05cc1e98c363fba9e97137565
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 16:01:46 2009 +0100

    ALSA: emux - Add missing KERN_* prefix to printk
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index 335aa2ce2574..ca5f7effb4df 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -74,15 +74,15 @@ snd_emux_init_seq(struct snd_emux *emu, struct snd_card *card, int index)
 	emu->client = snd_seq_create_kernel_client(card, index,
 						   "%s WaveTable", emu->name);
 	if (emu->client < 0) {
-		snd_printk("can't create client\n");
+		snd_printk(KERN_ERR "can't create client\n");
 		return -ENODEV;
 	}
 
 	if (emu->num_ports < 0) {
-		snd_printk("seqports must be greater than zero\n");
+		snd_printk(KERN_WARNING "seqports must be greater than zero\n");
 		emu->num_ports = 1;
 	} else if (emu->num_ports >= SNDRV_EMUX_MAX_PORTS) {
-		snd_printk("too many ports."
+		snd_printk(KERN_WARNING "too many ports."
 			   "limited max. ports %d\n", SNDRV_EMUX_MAX_PORTS);
 		emu->num_ports = SNDRV_EMUX_MAX_PORTS;
 	}
@@ -100,7 +100,7 @@ snd_emux_init_seq(struct snd_emux *emu, struct snd_card *card, int index)
 		p = snd_emux_create_port(emu, tmpname, MIDI_CHANNELS,
 					 0, &pinfo);
 		if (p == NULL) {
-			snd_printk("can't create port\n");
+			snd_printk(KERN_ERR "can't create port\n");
 			return -ENOMEM;
 		}
 
@@ -147,12 +147,12 @@ snd_emux_create_port(struct snd_emux *emu, char *name,
 
 	/* Allocate structures for this channel */
 	if ((p = kzalloc(sizeof(*p), GFP_KERNEL)) == NULL) {
-		snd_printk("no memory\n");
+		snd_printk(KERN_ERR "no memory\n");
 		return NULL;
 	}
 	p->chset.channels = kcalloc(max_channels, sizeof(struct snd_midi_channel), GFP_KERNEL);
 	if (p->chset.channels == NULL) {
-		snd_printk("no memory\n");
+		snd_printk(KERN_ERR "no memory\n");
 		kfree(p);
 		return NULL;
 	}
@@ -376,12 +376,12 @@ int snd_emux_init_virmidi(struct snd_emux *emu, struct snd_card *card)
 			goto __error;
 		}
 		emu->vmidi[i] = rmidi;
-		//snd_printk("virmidi %d ok\n", i);
+		/* snd_printk(KERN_DEBUG "virmidi %d ok\n", i); */
 	}
 	return 0;
 
 __error:
-	//snd_printk("error init..\n");
+	/* snd_printk(KERN_DEBUG "error init..\n"); */
 	snd_emux_delete_virmidi(emu);
 	return -ENOMEM;
 }

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index d176cc01742d..335aa2ce2574 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -257,7 +257,8 @@ snd_emux_event_input(struct snd_seq_event *ev, int direct, void *private_data,
 	struct snd_emux_port *port;
 
 	port = private_data;
-	snd_assert(port != NULL && ev != NULL, return -EINVAL);
+	if (snd_BUG_ON(!port || !ev))
+		return -EINVAL;
 
 	snd_midi_process_event(&emux_ops, ev, &port->chset);
 
@@ -308,9 +309,11 @@ snd_emux_use(void *private_data, struct snd_seq_port_subscribe *info)
 	struct snd_emux *emu;
 
 	p = private_data;
-	snd_assert(p != NULL, return -EINVAL);
+	if (snd_BUG_ON(!p))
+		return -EINVAL;
 	emu = p->emu;
-	snd_assert(emu != NULL, return -EINVAL);
+	if (snd_BUG_ON(!emu))
+		return -EINVAL;
 
 	mutex_lock(&emu->register_mutex);
 	snd_emux_init_port(p);
@@ -329,9 +332,11 @@ snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info)
 	struct snd_emux *emu;
 
 	p = private_data;
-	snd_assert(p != NULL, return -EINVAL);
+	if (snd_BUG_ON(!p))
+		return -EINVAL;
 	emu = p->emu;
-	snd_assert(emu != NULL, return -EINVAL);
+	if (snd_BUG_ON(!emu))
+		return -EINVAL;
 
 	mutex_lock(&emu->register_mutex);
 	snd_emux_sounds_off_all(p);

commit 450047a78f3c35a905576e121abfbee2ccd45993
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue May 2 16:08:41 2006 +0200

    [ALSA] add more sequencer port type information bits
    
    Add four new information flags SNDRV_SEQ_PORT_TYPE_HARDWARE, _SOFTWARE,
    _SYNTHESIZER, _PORT for sequencer ports.  This makes it easier for apps
    like Rosegarden to make policy decisions based on the port type.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index 58838f7c95f0..d176cc01742d 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -54,7 +54,9 @@ static struct snd_midi_op emux_ops = {
 #define DEFAULT_MIDI_TYPE	(SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\
 				 SNDRV_SEQ_PORT_TYPE_MIDI_GM |\
 				 SNDRV_SEQ_PORT_TYPE_MIDI_GS |\
-				 SNDRV_SEQ_PORT_TYPE_MIDI_XG)
+				 SNDRV_SEQ_PORT_TYPE_MIDI_XG |\
+				 SNDRV_SEQ_PORT_TYPE_HARDWARE |\
+				 SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)
 
 /*
  * Initialise the EMUX Synth by creating a client and registering

commit c97f3dd85490e51ba48782dd0c063cdade352c0d
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue May 2 15:50:05 2006 +0200

    [ALSA] fix port type bits
    
    Fix the port information about non-MIDI messages that had wrong values
    for some OPL3 and EmuX ports.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index 8f00f07701c4..58838f7c95f0 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -54,8 +54,7 @@ static struct snd_midi_op emux_ops = {
 #define DEFAULT_MIDI_TYPE	(SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\
 				 SNDRV_SEQ_PORT_TYPE_MIDI_GM |\
 				 SNDRV_SEQ_PORT_TYPE_MIDI_GS |\
-				 SNDRV_SEQ_PORT_TYPE_MIDI_XG |\
-				 SNDRV_SEQ_PORT_TYPE_DIRECT_SAMPLE)
+				 SNDRV_SEQ_PORT_TYPE_MIDI_XG)
 
 /*
  * Initialise the EMUX Synth by creating a client and registering

commit ef9f0a42db987e7e2df72289fb4522d24027786b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:31:42 2006 +0100

    [ALSA] semaphore -> mutex (driver part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index 1a973d7a90f8..8f00f07701c4 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -123,12 +123,12 @@ snd_emux_detach_seq(struct snd_emux *emu)
 	if (emu->voices)
 		snd_emux_terminate_all(emu);
 		
-	down(&emu->register_mutex);
+	mutex_lock(&emu->register_mutex);
 	if (emu->client >= 0) {
 		snd_seq_delete_kernel_client(emu->client);
 		emu->client = -1;
 	}
-	up(&emu->register_mutex);
+	mutex_unlock(&emu->register_mutex);
 }
 
 
@@ -311,10 +311,10 @@ snd_emux_use(void *private_data, struct snd_seq_port_subscribe *info)
 	emu = p->emu;
 	snd_assert(emu != NULL, return -EINVAL);
 
-	down(&emu->register_mutex);
+	mutex_lock(&emu->register_mutex);
 	snd_emux_init_port(p);
 	snd_emux_inc_count(emu);
-	up(&emu->register_mutex);
+	mutex_unlock(&emu->register_mutex);
 	return 0;
 }
 
@@ -332,10 +332,10 @@ snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info)
 	emu = p->emu;
 	snd_assert(emu != NULL, return -EINVAL);
 
-	down(&emu->register_mutex);
+	mutex_lock(&emu->register_mutex);
 	snd_emux_sounds_off_all(p);
 	snd_emux_dec_count(emu);
-	up(&emu->register_mutex);
+	mutex_unlock(&emu->register_mutex);
 	return 0;
 }
 

commit 7b6d92451ad5e1136dc347347e888b94638b8ba9
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Dec 12 09:33:37 2005 +0100

    [ALSA] seq: set client name in snd_seq_create_kernel_client()
    
    All users of snd_seq_create_kernel_client() have to set the client name
    anyway, so we can just pass the name as parameter.  This relieves us
    from having to muck around with a struct snd_seq_client_info in these
    cases.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index b7129c5aee06..1a973d7a90f8 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -28,7 +28,6 @@ static void free_port(void *private);
 static void snd_emux_init_port(struct snd_emux_port *p);
 static int snd_emux_use(void *private_data, struct snd_seq_port_subscribe *info);
 static int snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info);
-static int get_client(struct snd_card *card, int index, char *name);
 
 /*
  * MIDI emulation operators
@@ -71,8 +70,8 @@ snd_emux_init_seq(struct snd_emux *emu, struct snd_card *card, int index)
 	struct snd_seq_port_callback pinfo;
 	char tmpname[64];
 
-	sprintf(tmpname, "%s WaveTable", emu->name);
-	emu->client = get_client(card, index, tmpname);
+	emu->client = snd_seq_create_kernel_client(card, index,
+						   "%s WaveTable", emu->name);
 	if (emu->client < 0) {
 		snd_printk("can't create client\n");
 		return -ENODEV;
@@ -341,30 +340,6 @@ snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info)
 }
 
 
-/*
- * Create a sequencer client
- */
-static int
-get_client(struct snd_card *card, int index, char *name)
-{
-	struct snd_seq_client_info cinfo;
-	int client;
-
-	/* Find a free client, start from 1 as the MPU expects to use 0 */
-	client = snd_seq_create_kernel_client(card, index);
-	if (client < 0)
-		return client;
-
-	memset(&cinfo, 0, sizeof(cinfo));
-	cinfo.client = client;
-	cinfo.type = KERNEL_CLIENT;
-	strcpy(cinfo.name, name);
-	snd_seq_kernel_client_ctl(client, SNDRV_SEQ_IOCTL_SET_CLIENT_INFO, &cinfo);
-
-	return client;
-}
-
-
 /*
  * attach virtual rawmidi devices
  */

commit 83e8ad6984dccd6d848ac91ba0df379ff968180b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Dec 12 09:30:43 2005 +0100

    [ALSA] seq: remove struct snd_seq_client_callback
    
    The fields of struct snd_seq_client_callback either aren't used or are
    always set to the same value, so we can get rid of it altogether.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index f5a832ff362c..b7129c5aee06 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -347,17 +347,11 @@ snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info)
 static int
 get_client(struct snd_card *card, int index, char *name)
 {
-	struct snd_seq_client_callback callbacks;
 	struct snd_seq_client_info cinfo;
 	int client;
 
-	memset(&callbacks, 0, sizeof(callbacks));
-	callbacks.private_data = NULL;
-	callbacks.allow_input = 1;
-	callbacks.allow_output = 1;
-
 	/* Find a free client, start from 1 as the MPU expects to use 0 */
-	client = snd_seq_create_kernel_client(card, index, &callbacks);
+	client = snd_seq_create_kernel_client(card, index);
 	if (client < 0)
 		return client;
 

commit 03da312ac080b4f5c9359c233b8812cc93a035fe
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:24:47 2005 +0100

    [ALSA] Remove xxx_t typedefs: Emu-X synth
    
    Modules: Common EMU synth,SoundFont,Synth
    
    Remove xxx_t typedefs from the Emu-X synth support.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index 8ccd33f4aa57..f5a832ff362c 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -25,15 +25,15 @@
 
 /* Prototypes for static functions */
 static void free_port(void *private);
-static void snd_emux_init_port(snd_emux_port_t *p);
-static int snd_emux_use(void *private_data, snd_seq_port_subscribe_t *info);
-static int snd_emux_unuse(void *private_data, snd_seq_port_subscribe_t *info);
-static int get_client(snd_card_t *card, int index, char *name);
+static void snd_emux_init_port(struct snd_emux_port *p);
+static int snd_emux_use(void *private_data, struct snd_seq_port_subscribe *info);
+static int snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info);
+static int get_client(struct snd_card *card, int index, char *name);
 
 /*
  * MIDI emulation operators
  */
-static snd_midi_op_t emux_ops = {
+static struct snd_midi_op emux_ops = {
 	snd_emux_note_on,
 	snd_emux_note_off,
 	snd_emux_key_press,
@@ -65,10 +65,10 @@ static snd_midi_op_t emux_ops = {
  * can connect to these ports to play midi data.
  */
 int
-snd_emux_init_seq(snd_emux_t *emu, snd_card_t *card, int index)
+snd_emux_init_seq(struct snd_emux *emu, struct snd_card *card, int index)
 {
 	int  i;
-	snd_seq_port_callback_t pinfo;
+	struct snd_seq_port_callback pinfo;
 	char tmpname[64];
 
 	sprintf(tmpname, "%s WaveTable", emu->name);
@@ -94,7 +94,7 @@ snd_emux_init_seq(snd_emux_t *emu, snd_card_t *card, int index)
 	pinfo.event_input = snd_emux_event_input;
 
 	for (i = 0; i < emu->num_ports; i++) {
-		snd_emux_port_t *p;
+		struct snd_emux_port *p;
 
 		sprintf(tmpname, "%s Port %d", emu->name, i);
 		p = snd_emux_create_port(emu, tmpname, MIDI_CHANNELS,
@@ -119,7 +119,7 @@ snd_emux_init_seq(snd_emux_t *emu, snd_card_t *card, int index)
  * destroy the kernel client.
  */
 void
-snd_emux_detach_seq(snd_emux_t *emu)
+snd_emux_detach_seq(struct snd_emux *emu)
 {
 	if (emu->voices)
 		snd_emux_terminate_all(emu);
@@ -137,12 +137,12 @@ snd_emux_detach_seq(snd_emux_t *emu)
  * create a sequencer port and channel_set
  */
 
-snd_emux_port_t *
-snd_emux_create_port(snd_emux_t *emu, char *name,
-			int max_channels, int oss_port,
-			snd_seq_port_callback_t *callback)
+struct snd_emux_port *
+snd_emux_create_port(struct snd_emux *emu, char *name,
+		     int max_channels, int oss_port,
+		     struct snd_seq_port_callback *callback)
 {
-	snd_emux_port_t *p;
+	struct snd_emux_port *p;
 	int i, type, cap;
 
 	/* Allocate structures for this channel */
@@ -150,7 +150,7 @@ snd_emux_create_port(snd_emux_t *emu, char *name,
 		snd_printk("no memory\n");
 		return NULL;
 	}
-	p->chset.channels = kcalloc(max_channels, sizeof(snd_midi_channel_t), GFP_KERNEL);
+	p->chset.channels = kcalloc(max_channels, sizeof(struct snd_midi_channel), GFP_KERNEL);
 	if (p->chset.channels == NULL) {
 		snd_printk("no memory\n");
 		kfree(p);
@@ -190,7 +190,7 @@ snd_emux_create_port(snd_emux_t *emu, char *name,
 static void
 free_port(void *private_data)
 {
-	snd_emux_port_t *p;
+	struct snd_emux_port *p;
 
 	p = private_data;
 	if (p) {
@@ -209,7 +209,7 @@ free_port(void *private_data)
  * initialize the port specific parameters
  */
 static void
-snd_emux_init_port(snd_emux_port_t *p)
+snd_emux_init_port(struct snd_emux_port *p)
 {
 	p->drum_flags = DEFAULT_DRUM_FLAGS;
 	p->volume_atten = 0;
@@ -222,7 +222,7 @@ snd_emux_init_port(snd_emux_port_t *p)
  * reset port
  */
 void
-snd_emux_reset_port(snd_emux_port_t *port)
+snd_emux_reset_port(struct snd_emux_port *port)
 {
 	int i;
 
@@ -241,7 +241,7 @@ snd_emux_reset_port(snd_emux_port_t *port)
 	port->ctrls[EMUX_MD_REALTIME_PAN] = 1;
 
 	for (i = 0; i < port->chset.max_channels; i++) {
-		snd_midi_channel_t *chan = port->chset.channels + i;
+		struct snd_midi_channel *chan = port->chset.channels + i;
 		chan->drum_channel = ((port->drum_flags >> i) & 1) ? 1 : 0;
 	}
 }
@@ -251,10 +251,10 @@ snd_emux_reset_port(snd_emux_port_t *port)
  * input sequencer event
  */
 int
-snd_emux_event_input(snd_seq_event_t *ev, int direct, void *private_data,
+snd_emux_event_input(struct snd_seq_event *ev, int direct, void *private_data,
 		     int atomic, int hop)
 {
-	snd_emux_port_t *port;
+	struct snd_emux_port *port;
 
 	port = private_data;
 	snd_assert(port != NULL && ev != NULL, return -EINVAL);
@@ -269,7 +269,7 @@ snd_emux_event_input(snd_seq_event_t *ev, int direct, void *private_data,
  * increment usage count
  */
 int
-snd_emux_inc_count(snd_emux_t *emu)
+snd_emux_inc_count(struct snd_emux *emu)
 {
 	emu->used++;
 	if (!try_module_get(emu->ops.owner))
@@ -288,7 +288,7 @@ snd_emux_inc_count(snd_emux_t *emu)
  * decrease usage count
  */
 void
-snd_emux_dec_count(snd_emux_t *emu)
+snd_emux_dec_count(struct snd_emux *emu)
 {
 	module_put(emu->card->module);
 	emu->used--;
@@ -302,10 +302,10 @@ snd_emux_dec_count(snd_emux_t *emu)
  * Routine that is called upon a first use of a particular port
  */
 static int
-snd_emux_use(void *private_data, snd_seq_port_subscribe_t *info)
+snd_emux_use(void *private_data, struct snd_seq_port_subscribe *info)
 {
-	snd_emux_port_t *p;
-	snd_emux_t *emu;
+	struct snd_emux_port *p;
+	struct snd_emux *emu;
 
 	p = private_data;
 	snd_assert(p != NULL, return -EINVAL);
@@ -323,10 +323,10 @@ snd_emux_use(void *private_data, snd_seq_port_subscribe_t *info)
  * Routine that is called upon the last unuse() of a particular port.
  */
 static int
-snd_emux_unuse(void *private_data, snd_seq_port_subscribe_t *info)
+snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info)
 {
-	snd_emux_port_t *p;
-	snd_emux_t *emu;
+	struct snd_emux_port *p;
+	struct snd_emux *emu;
 
 	p = private_data;
 	snd_assert(p != NULL, return -EINVAL);
@@ -345,10 +345,10 @@ snd_emux_unuse(void *private_data, snd_seq_port_subscribe_t *info)
  * Create a sequencer client
  */
 static int
-get_client(snd_card_t *card, int index, char *name)
+get_client(struct snd_card *card, int index, char *name)
 {
-	snd_seq_client_callback_t callbacks;
-	snd_seq_client_info_t cinfo;
+	struct snd_seq_client_callback callbacks;
+	struct snd_seq_client_info cinfo;
 	int client;
 
 	memset(&callbacks, 0, sizeof(callbacks));
@@ -374,7 +374,7 @@ get_client(snd_card_t *card, int index, char *name)
 /*
  * attach virtual rawmidi devices
  */
-int snd_emux_init_virmidi(snd_emux_t *emu, snd_card_t *card)
+int snd_emux_init_virmidi(struct snd_emux *emu, struct snd_card *card)
 {
 	int i;
 
@@ -382,13 +382,13 @@ int snd_emux_init_virmidi(snd_emux_t *emu, snd_card_t *card)
 	if (emu->midi_ports <= 0)
 		return 0;
 
-	emu->vmidi = kcalloc(emu->midi_ports, sizeof(snd_rawmidi_t*), GFP_KERNEL);
+	emu->vmidi = kcalloc(emu->midi_ports, sizeof(struct snd_rawmidi *), GFP_KERNEL);
 	if (emu->vmidi == NULL)
 		return -ENOMEM;
 
 	for (i = 0; i < emu->midi_ports; i++) {
-		snd_rawmidi_t *rmidi;
-		snd_virmidi_dev_t *rdev;
+		struct snd_rawmidi *rmidi;
+		struct snd_virmidi_dev *rdev;
 		if (snd_virmidi_new(card, emu->midi_devidx + i, &rmidi) < 0)
 			goto __error;
 		rdev = rmidi->private_data;
@@ -411,7 +411,7 @@ int snd_emux_init_virmidi(snd_emux_t *emu, snd_card_t *card)
 	return -ENOMEM;
 }
 
-int snd_emux_delete_virmidi(snd_emux_t *emu)
+int snd_emux_delete_virmidi(struct snd_emux *emu)
 {
 	int i;
 

commit 561b220a4dece18d67177413e6fa21b49aa4acce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:22:34 2005 +0200

    [ALSA] Replace with kzalloc() - others
    
    Documentation,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,OPL3
    OPL4,Digigram VX core,I2C cs8427,I2C lib core,I2C tea6330t,L3 drivers
    AK4114 receiver,AK4117 receiver,PDAudioCF driver,PPC PMAC driver
    SPARC AMD7930 driver,SPARC cs4231 driver,Synth,Common EMU synth
    USB generic driver,USB USX2Y
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index e41b28d9bf52..8ccd33f4aa57 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -146,7 +146,7 @@ snd_emux_create_port(snd_emux_t *emu, char *name,
 	int i, type, cap;
 
 	/* Allocate structures for this channel */
-	if ((p = kcalloc(1, sizeof(*p), GFP_KERNEL)) == NULL) {
+	if ((p = kzalloc(sizeof(*p), GFP_KERNEL)) == NULL) {
 		snd_printk("no memory\n");
 		return NULL;
 	}

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
new file mode 100644
index 000000000000..e41b28d9bf52
--- /dev/null
+++ b/sound/synth/emux/emux_seq.c
@@ -0,0 +1,428 @@
+/*
+ *  Midi Sequencer interface routines.
+ *
+ *  Copyright (C) 1999 Steve Ratcliffe
+ *  Copyright (c) 1999-2000 Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include "emux_voice.h"
+#include <linux/slab.h>
+
+
+/* Prototypes for static functions */
+static void free_port(void *private);
+static void snd_emux_init_port(snd_emux_port_t *p);
+static int snd_emux_use(void *private_data, snd_seq_port_subscribe_t *info);
+static int snd_emux_unuse(void *private_data, snd_seq_port_subscribe_t *info);
+static int get_client(snd_card_t *card, int index, char *name);
+
+/*
+ * MIDI emulation operators
+ */
+static snd_midi_op_t emux_ops = {
+	snd_emux_note_on,
+	snd_emux_note_off,
+	snd_emux_key_press,
+	snd_emux_terminate_note,
+	snd_emux_control,
+	snd_emux_nrpn,
+	snd_emux_sysex,
+};
+
+
+/*
+ * number of MIDI channels
+ */
+#define MIDI_CHANNELS		16
+
+/*
+ * type flags for MIDI sequencer port
+ */
+#define DEFAULT_MIDI_TYPE	(SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\
+				 SNDRV_SEQ_PORT_TYPE_MIDI_GM |\
+				 SNDRV_SEQ_PORT_TYPE_MIDI_GS |\
+				 SNDRV_SEQ_PORT_TYPE_MIDI_XG |\
+				 SNDRV_SEQ_PORT_TYPE_DIRECT_SAMPLE)
+
+/*
+ * Initialise the EMUX Synth by creating a client and registering
+ * a series of ports.
+ * Each of the ports will contain the 16 midi channels.  Applications
+ * can connect to these ports to play midi data.
+ */
+int
+snd_emux_init_seq(snd_emux_t *emu, snd_card_t *card, int index)
+{
+	int  i;
+	snd_seq_port_callback_t pinfo;
+	char tmpname[64];
+
+	sprintf(tmpname, "%s WaveTable", emu->name);
+	emu->client = get_client(card, index, tmpname);
+	if (emu->client < 0) {
+		snd_printk("can't create client\n");
+		return -ENODEV;
+	}
+
+	if (emu->num_ports < 0) {
+		snd_printk("seqports must be greater than zero\n");
+		emu->num_ports = 1;
+	} else if (emu->num_ports >= SNDRV_EMUX_MAX_PORTS) {
+		snd_printk("too many ports."
+			   "limited max. ports %d\n", SNDRV_EMUX_MAX_PORTS);
+		emu->num_ports = SNDRV_EMUX_MAX_PORTS;
+	}
+
+	memset(&pinfo, 0, sizeof(pinfo));
+	pinfo.owner = THIS_MODULE;
+	pinfo.use = snd_emux_use;
+	pinfo.unuse = snd_emux_unuse;
+	pinfo.event_input = snd_emux_event_input;
+
+	for (i = 0; i < emu->num_ports; i++) {
+		snd_emux_port_t *p;
+
+		sprintf(tmpname, "%s Port %d", emu->name, i);
+		p = snd_emux_create_port(emu, tmpname, MIDI_CHANNELS,
+					 0, &pinfo);
+		if (p == NULL) {
+			snd_printk("can't create port\n");
+			return -ENOMEM;
+		}
+
+		p->port_mode =  SNDRV_EMUX_PORT_MODE_MIDI;
+		snd_emux_init_port(p);
+		emu->ports[i] = p->chset.port;
+		emu->portptrs[i] = p;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Detach from the ports that were set up for this synthesizer and
+ * destroy the kernel client.
+ */
+void
+snd_emux_detach_seq(snd_emux_t *emu)
+{
+	if (emu->voices)
+		snd_emux_terminate_all(emu);
+		
+	down(&emu->register_mutex);
+	if (emu->client >= 0) {
+		snd_seq_delete_kernel_client(emu->client);
+		emu->client = -1;
+	}
+	up(&emu->register_mutex);
+}
+
+
+/*
+ * create a sequencer port and channel_set
+ */
+
+snd_emux_port_t *
+snd_emux_create_port(snd_emux_t *emu, char *name,
+			int max_channels, int oss_port,
+			snd_seq_port_callback_t *callback)
+{
+	snd_emux_port_t *p;
+	int i, type, cap;
+
+	/* Allocate structures for this channel */
+	if ((p = kcalloc(1, sizeof(*p), GFP_KERNEL)) == NULL) {
+		snd_printk("no memory\n");
+		return NULL;
+	}
+	p->chset.channels = kcalloc(max_channels, sizeof(snd_midi_channel_t), GFP_KERNEL);
+	if (p->chset.channels == NULL) {
+		snd_printk("no memory\n");
+		kfree(p);
+		return NULL;
+	}
+	for (i = 0; i < max_channels; i++)
+		p->chset.channels[i].number = i;
+	p->chset.private_data = p;
+	p->chset.max_channels = max_channels;
+	p->emu = emu;
+	p->chset.client = emu->client;
+#ifdef SNDRV_EMUX_USE_RAW_EFFECT
+	snd_emux_create_effect(p);
+#endif
+	callback->private_free = free_port;
+	callback->private_data = p;
+
+	cap = SNDRV_SEQ_PORT_CAP_WRITE;
+	if (oss_port) {
+		type = SNDRV_SEQ_PORT_TYPE_SPECIFIC;
+	} else {
+		type = DEFAULT_MIDI_TYPE;
+		cap |= SNDRV_SEQ_PORT_CAP_SUBS_WRITE;
+	}
+
+	p->chset.port = snd_seq_event_port_attach(emu->client, callback,
+						  cap, type, max_channels,
+						  emu->max_voices, name);
+
+	return p;
+}
+
+
+/*
+ * release memory block for port
+ */
+static void
+free_port(void *private_data)
+{
+	snd_emux_port_t *p;
+
+	p = private_data;
+	if (p) {
+#ifdef SNDRV_EMUX_USE_RAW_EFFECT
+		snd_emux_delete_effect(p);
+#endif
+		kfree(p->chset.channels);
+		kfree(p);
+	}
+}
+
+
+#define DEFAULT_DRUM_FLAGS	(1<<9)
+
+/*
+ * initialize the port specific parameters
+ */
+static void
+snd_emux_init_port(snd_emux_port_t *p)
+{
+	p->drum_flags = DEFAULT_DRUM_FLAGS;
+	p->volume_atten = 0;
+
+	snd_emux_reset_port(p);
+}
+
+
+/*
+ * reset port
+ */
+void
+snd_emux_reset_port(snd_emux_port_t *port)
+{
+	int i;
+
+	/* stop all sounds */
+	snd_emux_sounds_off_all(port);
+
+	snd_midi_channel_set_clear(&port->chset);
+
+#ifdef SNDRV_EMUX_USE_RAW_EFFECT
+	snd_emux_clear_effect(port);
+#endif
+
+	/* set port specific control parameters */
+	port->ctrls[EMUX_MD_DEF_BANK] = 0;
+	port->ctrls[EMUX_MD_DEF_DRUM] = 0;
+	port->ctrls[EMUX_MD_REALTIME_PAN] = 1;
+
+	for (i = 0; i < port->chset.max_channels; i++) {
+		snd_midi_channel_t *chan = port->chset.channels + i;
+		chan->drum_channel = ((port->drum_flags >> i) & 1) ? 1 : 0;
+	}
+}
+
+
+/*
+ * input sequencer event
+ */
+int
+snd_emux_event_input(snd_seq_event_t *ev, int direct, void *private_data,
+		     int atomic, int hop)
+{
+	snd_emux_port_t *port;
+
+	port = private_data;
+	snd_assert(port != NULL && ev != NULL, return -EINVAL);
+
+	snd_midi_process_event(&emux_ops, ev, &port->chset);
+
+	return 0;
+}
+
+
+/*
+ * increment usage count
+ */
+int
+snd_emux_inc_count(snd_emux_t *emu)
+{
+	emu->used++;
+	if (!try_module_get(emu->ops.owner))
+		goto __error;
+	if (!try_module_get(emu->card->module)) {
+		module_put(emu->ops.owner);
+	      __error:
+		emu->used--;
+		return 0;
+	}
+	return 1;
+}
+
+
+/*
+ * decrease usage count
+ */
+void
+snd_emux_dec_count(snd_emux_t *emu)
+{
+	module_put(emu->card->module);
+	emu->used--;
+	if (emu->used <= 0)
+		snd_emux_terminate_all(emu);
+	module_put(emu->ops.owner);
+}
+
+
+/*
+ * Routine that is called upon a first use of a particular port
+ */
+static int
+snd_emux_use(void *private_data, snd_seq_port_subscribe_t *info)
+{
+	snd_emux_port_t *p;
+	snd_emux_t *emu;
+
+	p = private_data;
+	snd_assert(p != NULL, return -EINVAL);
+	emu = p->emu;
+	snd_assert(emu != NULL, return -EINVAL);
+
+	down(&emu->register_mutex);
+	snd_emux_init_port(p);
+	snd_emux_inc_count(emu);
+	up(&emu->register_mutex);
+	return 0;
+}
+
+/*
+ * Routine that is called upon the last unuse() of a particular port.
+ */
+static int
+snd_emux_unuse(void *private_data, snd_seq_port_subscribe_t *info)
+{
+	snd_emux_port_t *p;
+	snd_emux_t *emu;
+
+	p = private_data;
+	snd_assert(p != NULL, return -EINVAL);
+	emu = p->emu;
+	snd_assert(emu != NULL, return -EINVAL);
+
+	down(&emu->register_mutex);
+	snd_emux_sounds_off_all(p);
+	snd_emux_dec_count(emu);
+	up(&emu->register_mutex);
+	return 0;
+}
+
+
+/*
+ * Create a sequencer client
+ */
+static int
+get_client(snd_card_t *card, int index, char *name)
+{
+	snd_seq_client_callback_t callbacks;
+	snd_seq_client_info_t cinfo;
+	int client;
+
+	memset(&callbacks, 0, sizeof(callbacks));
+	callbacks.private_data = NULL;
+	callbacks.allow_input = 1;
+	callbacks.allow_output = 1;
+
+	/* Find a free client, start from 1 as the MPU expects to use 0 */
+	client = snd_seq_create_kernel_client(card, index, &callbacks);
+	if (client < 0)
+		return client;
+
+	memset(&cinfo, 0, sizeof(cinfo));
+	cinfo.client = client;
+	cinfo.type = KERNEL_CLIENT;
+	strcpy(cinfo.name, name);
+	snd_seq_kernel_client_ctl(client, SNDRV_SEQ_IOCTL_SET_CLIENT_INFO, &cinfo);
+
+	return client;
+}
+
+
+/*
+ * attach virtual rawmidi devices
+ */
+int snd_emux_init_virmidi(snd_emux_t *emu, snd_card_t *card)
+{
+	int i;
+
+	emu->vmidi = NULL;
+	if (emu->midi_ports <= 0)
+		return 0;
+
+	emu->vmidi = kcalloc(emu->midi_ports, sizeof(snd_rawmidi_t*), GFP_KERNEL);
+	if (emu->vmidi == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < emu->midi_ports; i++) {
+		snd_rawmidi_t *rmidi;
+		snd_virmidi_dev_t *rdev;
+		if (snd_virmidi_new(card, emu->midi_devidx + i, &rmidi) < 0)
+			goto __error;
+		rdev = rmidi->private_data;
+		sprintf(rmidi->name, "%s Synth MIDI", emu->name);
+		rdev->seq_mode = SNDRV_VIRMIDI_SEQ_ATTACH;
+		rdev->client = emu->client;
+		rdev->port = emu->ports[i];
+		if (snd_device_register(card, rmidi) < 0) {
+			snd_device_free(card, rmidi);
+			goto __error;
+		}
+		emu->vmidi[i] = rmidi;
+		//snd_printk("virmidi %d ok\n", i);
+	}
+	return 0;
+
+__error:
+	//snd_printk("error init..\n");
+	snd_emux_delete_virmidi(emu);
+	return -ENOMEM;
+}
+
+int snd_emux_delete_virmidi(snd_emux_t *emu)
+{
+	int i;
+
+	if (emu->vmidi == NULL)
+		return 0;
+
+	for (i = 0; i < emu->midi_ports; i++) {
+		if (emu->vmidi[i])
+			snd_device_free(emu->card, emu->vmidi[i]);
+	}
+	kfree(emu->vmidi);
+	emu->vmidi = NULL;
+	return 0;
+}
