commit 87065d3d946bf116a639f3bd88ebbd3f3938cffb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:17:08 2020 +0100

    ALSA: seq: oss: Constify snd_seq_oss_callback definitions
    
    The snd_seq_oss_callback items are just copied to another struct
    as-is, hence they can be declared as const.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-53-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index a14fc6562664..d8d32671f703 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -34,7 +34,7 @@ static void fake_event(struct snd_emux *emu, struct snd_emux_port *port,
 		       int ch, int param, int val, int atomic, int hop);
 
 /* operators */
-static struct snd_seq_oss_callback oss_callback = {
+static const struct snd_seq_oss_callback oss_callback = {
 	.owner = THIS_MODULE,
 	.open = snd_emux_open_seq_oss,
 	.close = snd_emux_close_seq_oss,

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index 764ff4bc2089..a14fc6562664 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -1,22 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Interface for OSS sequencer emulation
  *
  *  Copyright (C) 1999 Takashi Iwai <tiwai@suse.de>
  *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  * Changes
  * 19990227   Steve Ratcliffe   Made separate file and merged in latest
  * 				midi emulation.

commit 41e4b7dc6e1b6d717edb8679759c2bde138f78a9
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Oct 16 12:18:39 2017 +0100

    ALSA: emux: remove unused redundant variable p2
    
    The variable p2 is being assigned but never used, it is redundant
    and can be safely removed.  Cleans up clang warning: Value stored to
    'p2' is never read.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index de19e108974a..764ff4bc2089 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -430,7 +430,6 @@ gusspec_control(struct snd_emux *emu, struct snd_emux_port *port, int cmd,
 {
 	int voice;
 	unsigned short p1;
-	short p2;
 	int plong;
 	struct snd_midi_channel *chan;
 
@@ -445,7 +444,6 @@ gusspec_control(struct snd_emux *emu, struct snd_emux_port *port, int cmd,
 	chan = &port->chset.channels[voice];
 
 	p1 = *(unsigned short *) &event[4];
-	p2 = *(short *) &event[6];
 	plong = *(int*) &event[4];
 
 	switch (cmd) {

commit 3d774d5ef066971aee1839150bf47d100d8e43d3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 9 14:06:46 2017 +0200

    ALSA: seq: Allow the tristate build of OSS emulation
    
    Currently OSS sequencer emulation is tied with ALSA sequencer core,
    both are built in the same level; i.e. when CONFIG_SND_SEQUENCER=y,
    the OSS sequencer emulation is also always built-in, even though the
    functionality can be built as an individual module.
    
    This patch changes the rule and allows users to build snd-seq-oss
    module while others are built-in.  Essentially, it's just a few simple
    changes in Kconfig and Makefile.  Some driver codes like opl3 need to
    convert from the simple ifdef to IS_ENABLED().  But that's all.
    
    You might wonder how about the dependency: right, it can be messy, but
    it still works.  Since we rewrote the sequencer binding with the
    standard bus, the driver can be bound at any time on demand.  So, the
    synthesizer driver module can be loaded individually from the OSS
    emulation core before/after it.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index 850fab4a8f3b..de19e108974a 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -23,8 +23,6 @@
  */
 
 
-#ifdef CONFIG_SND_SEQUENCER_OSS
-
 #include <linux/export.h>
 #include <linux/uaccess.h>
 #include <sound/core.h>
@@ -505,5 +503,3 @@ fake_event(struct snd_emux *emu, struct snd_emux_port *port, int ch, int param,
 	ev.data.control.value = val;
 	snd_emux_event_input(&ev, 0, port, atomic, hop);
 }
-
-#endif /* CONFIG_SND_SEQUENCER_OSS */

commit 5885615e44faebaf379fa0cdd2b9c084960dae38
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Mar 31 16:53:40 2017 +0300

    ALSA: emux: stop if copy_from_user() fails
    
    If we can't fill the "patch" struct because "count" is too small (it can
    be as low as 4 bytes) or because copy_from_user() failed, then just
    return instead of using unintialized data.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index ac75816ada7c..850fab4a8f3b 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -225,9 +225,9 @@ snd_emux_load_patch_seq_oss(struct snd_seq_oss_arg *arg, int format,
 	else if (format == SNDRV_OSS_SOUNDFONT_PATCH) {
 		struct soundfont_patch_info patch;
 		if (count < (int)sizeof(patch))
-			rc = -EINVAL;
+			return -EINVAL;
 		if (copy_from_user(&patch, buf, sizeof(patch)))
-			rc = -EFAULT;
+			return -EFAULT;
 		if (patch.type >= SNDRV_SFNT_LOAD_INFO &&
 		    patch.type <= SNDRV_SFNT_PROBE_DATA)
 			rc = snd_soundfont_load(emu->sflist, buf, count, SF_CLIENT_NO(p->chset.port));

commit 225db5762dc1a35b26850477ffa06e5cd0097243
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 5 16:55:09 2015 +0200

    ALSA: synth: Fix conflicting OSS device registration on AWE32
    
    When OSS emulation is loaded on ISA SB AWE32 chip, we get now kernel
    warnings like:
      WARNING: CPU: 0 PID: 2791 at fs/sysfs/dir.c:31 sysfs_warn_dup+0x51/0x80()
      sysfs: cannot create duplicate filename '/devices/isa/sbawe.0/sound/card0/seq-oss-0-0'
    
    It's because both emux synth and opl3 drivers try to register their
    OSS device object with the same static index number 0.  This hasn't
    been a big problem until the recent rewrite of device management code
    (that exposes sysfs at the same time), but it's been an obvious bug.
    
    This patch works around it just by using a different index number of
    emux synth object.  There can be a more elegant way to fix, but it's
    enough for now, as this code won't be touched so often, in anyway.
    
    Reported-and-tested-by: Michael Shell <list1@michaelshell.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index 82e350e9501c..ac75816ada7c 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -69,7 +69,8 @@ snd_emux_init_seq_oss(struct snd_emux *emu)
 	struct snd_seq_oss_reg *arg;
 	struct snd_seq_device *dev;
 
-	if (snd_seq_device_new(emu->card, 0, SNDRV_SEQ_DEV_ID_OSS,
+	/* using device#1 here for avoiding conflicts with OPL3 */
+	if (snd_seq_device_new(emu->card, 1, SNDRV_SEQ_DEV_ID_OSS,
 			       sizeof(struct snd_seq_oss_reg), &dev) < 0)
 		return;
 

commit 1c94e65c668f44d2c69ae7e7fc268ab3268fba3e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 28 17:11:44 2015 +0200

    ALSA: emux: Fix mutex deadlock in OSS emulation
    
    The OSS emulation in synth-emux helper has a potential AB/BA deadlock
    at the simultaneous closing and opening:
    
      close ->
        snd_seq_release() ->
          sne_seq_free_client() ->
            snd_seq_delete_all_ports(): takes client->ports_mutex ->
              port_delete() ->
                snd_emux_unuse(): takes emux->register_mutex
    
      open ->
        snd_seq_oss_open() ->
          snd_emux_open_seq_oss(): takes emux->register_mutex ->
            snd_seq_event_port_attach() ->
              snd_seq_create_port(): takes client->ports_mutex
    
    This patch addresses the deadlock by reducing the rance taking
    emux->register_mutex in snd_emux_open_seq_oss().  The lock is needed
    for the refcount handling, so move it locally.  The calls in
    emux_seq.c are already with the mutex, thus they are replaced with the
    version without mutex lock/unlock.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index ab37add269ae..82e350e9501c 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -118,12 +118,8 @@ snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)
 	if (snd_BUG_ON(!arg || !emu))
 		return -ENXIO;
 
-	mutex_lock(&emu->register_mutex);
-
-	if (!snd_emux_inc_count(emu)) {
-		mutex_unlock(&emu->register_mutex);
+	if (!snd_emux_inc_count(emu))
 		return -EFAULT;
-	}
 
 	memset(&callback, 0, sizeof(callback));
 	callback.owner = THIS_MODULE;
@@ -135,7 +131,6 @@ snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)
 	if (p == NULL) {
 		snd_printk(KERN_ERR "can't create port\n");
 		snd_emux_dec_count(emu);
-		mutex_unlock(&emu->register_mutex);
 		return -ENOMEM;
 	}
 
@@ -148,8 +143,6 @@ snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)
 	reset_port_mode(p, arg->seq_mode);
 
 	snd_emux_reset_port(p);
-
-	mutex_unlock(&emu->register_mutex);
 	return 0;
 }
 
@@ -195,13 +188,11 @@ snd_emux_close_seq_oss(struct snd_seq_oss_arg *arg)
 	if (snd_BUG_ON(!emu))
 		return -ENXIO;
 
-	mutex_lock(&emu->register_mutex);
 	snd_emux_sounds_off_all(p);
 	snd_soundfont_close_check(emu->sflist, SF_CLIENT_NO(p->chset.port));
 	snd_seq_event_port_detach(p->chset.client, p->chset.port);
 	snd_emux_dec_count(emu);
 
-	mutex_unlock(&emu->register_mutex);
 	return 0;
 }
 

commit 976412fbc9855176ea7e02602a601b46c4479fcc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 17:24:43 2015 +0100

    ALSA: Include linux/uaccess.h and linux/bitopts.h instead of asm/*
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index 319754cf6208..ab37add269ae 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -26,7 +26,7 @@
 #ifdef CONFIG_SND_SEQUENCER_OSS
 
 #include <linux/export.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <sound/core.h>
 #include "emux_voice.h"
 #include <sound/asoundef.h>

commit d81a6d71760c4d8323f1f9a506c64084caa09063
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Sep 22 09:34:58 2011 -0400

    sound: Add export.h for THIS_MODULE/EXPORT_SYMBOL where needed
    
    These aren't modules, but they do make use of these macros, so
    they will need export.h to get that definition.  Previously,
    they got it via the implicit module.h inclusion.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index 87e42206c4ef..319754cf6208 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -25,6 +25,7 @@
 
 #ifdef CONFIG_SND_SEQUENCER_OSS
 
+#include <linux/export.h>
 #include <asm/uaccess.h>
 #include <sound/core.h>
 #include "emux_voice.h"

commit 42b0158bdb1344b05cc1e98c363fba9e97137565
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 16:01:46 2009 +0100

    ALSA: emux - Add missing KERN_* prefix to printk
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index 5c47b6c09264..87e42206c4ef 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -132,7 +132,7 @@ snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)
 	p = snd_emux_create_port(emu, tmpname, 32,
 				 1, &callback);
 	if (p == NULL) {
-		snd_printk("can't create port\n");
+		snd_printk(KERN_ERR "can't create port\n");
 		snd_emux_dec_count(emu);
 		mutex_unlock(&emu->register_mutex);
 		return -ENOMEM;

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index f60a98ef7dec..5c47b6c09264 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -114,7 +114,8 @@ snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)
 	char tmpname[64];
 
 	emu = closure;
-	snd_assert(arg != NULL && emu != NULL, return -ENXIO);
+	if (snd_BUG_ON(!arg || !emu))
+		return -ENXIO;
 
 	mutex_lock(&emu->register_mutex);
 
@@ -183,12 +184,15 @@ snd_emux_close_seq_oss(struct snd_seq_oss_arg *arg)
 	struct snd_emux *emu;
 	struct snd_emux_port *p;
 
-	snd_assert(arg != NULL, return -ENXIO);
+	if (snd_BUG_ON(!arg))
+		return -ENXIO;
 	p = arg->private_data;
-	snd_assert(p != NULL, return -ENXIO);
+	if (snd_BUG_ON(!p))
+		return -ENXIO;
 
 	emu = p->emu;
-	snd_assert(emu != NULL, return -ENXIO);
+	if (snd_BUG_ON(!emu))
+		return -ENXIO;
 
 	mutex_lock(&emu->register_mutex);
 	snd_emux_sounds_off_all(p);
@@ -212,12 +216,15 @@ snd_emux_load_patch_seq_oss(struct snd_seq_oss_arg *arg, int format,
 	struct snd_emux_port *p;
 	int rc;
 
-	snd_assert(arg != NULL, return -ENXIO);
+	if (snd_BUG_ON(!arg))
+		return -ENXIO;
 	p = arg->private_data;
-	snd_assert(p != NULL, return -ENXIO);
+	if (snd_BUG_ON(!p))
+		return -ENXIO;
 
 	emu = p->emu;
-	snd_assert(emu != NULL, return -ENXIO);
+	if (snd_BUG_ON(!emu))
+		return -ENXIO;
 
 	if (format == GUS_PATCH)
 		rc = snd_soundfont_load_guspatch(emu->sflist, buf, count,
@@ -252,12 +259,15 @@ snd_emux_ioctl_seq_oss(struct snd_seq_oss_arg *arg, unsigned int cmd, unsigned l
 	struct snd_emux_port *p;
 	struct snd_emux *emu;
 
-	snd_assert(arg != NULL, return -ENXIO);
+	if (snd_BUG_ON(!arg))
+		return -ENXIO;
 	p = arg->private_data;
-	snd_assert(p != NULL, return -ENXIO);
+	if (snd_BUG_ON(!p))
+		return -ENXIO;
 
 	emu = p->emu;
-	snd_assert(emu != NULL, return -ENXIO);
+	if (snd_BUG_ON(!emu))
+		return -ENXIO;
 
 	switch (cmd) {
 	case SNDCTL_SEQ_RESETSAMPLES:
@@ -282,9 +292,11 @@ snd_emux_reset_seq_oss(struct snd_seq_oss_arg *arg)
 {
 	struct snd_emux_port *p;
 
-	snd_assert(arg != NULL, return -ENXIO);
+	if (snd_BUG_ON(!arg))
+		return -ENXIO;
 	p = arg->private_data;
-	snd_assert(p != NULL, return -ENXIO);
+	if (snd_BUG_ON(!p))
+		return -ENXIO;
 	snd_emux_reset_port(p);
 	return 0;
 }
@@ -302,9 +314,11 @@ snd_emux_event_oss_input(struct snd_seq_event *ev, int direct, void *private_dat
 	unsigned char cmd, *data;
 
 	p = private_data;
-	snd_assert(p != NULL, return -EINVAL);
+	if (snd_BUG_ON(!p))
+		return -EINVAL;
 	emu = p->emu;
-	snd_assert(emu != NULL, return -EINVAL);
+	if (snd_BUG_ON(!emu))
+		return -EINVAL;
 	if (ev->type != SNDRV_SEQ_EVENT_OSS)
 		return snd_emux_event_input(ev, direct, private_data, atomic, hop);
 

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index 3436816727c8..f60a98ef7dec 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -22,7 +22,6 @@
  * 				midi emulation.
  */
 
-#include <sound/driver.h>
 
 #ifdef CONFIG_SND_SEQUENCER_OSS
 

commit ef9f0a42db987e7e2df72289fb4522d24027786b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:31:42 2006 +0100

    [ALSA] semaphore -> mutex (driver part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index dfbfcfbe5dd2..3436816727c8 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -117,10 +117,10 @@ snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)
 	emu = closure;
 	snd_assert(arg != NULL && emu != NULL, return -ENXIO);
 
-	down(&emu->register_mutex);
+	mutex_lock(&emu->register_mutex);
 
 	if (!snd_emux_inc_count(emu)) {
-		up(&emu->register_mutex);
+		mutex_unlock(&emu->register_mutex);
 		return -EFAULT;
 	}
 
@@ -134,7 +134,7 @@ snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)
 	if (p == NULL) {
 		snd_printk("can't create port\n");
 		snd_emux_dec_count(emu);
-		up(&emu->register_mutex);
+		mutex_unlock(&emu->register_mutex);
 		return -ENOMEM;
 	}
 
@@ -148,7 +148,7 @@ snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)
 
 	snd_emux_reset_port(p);
 
-	up(&emu->register_mutex);
+	mutex_unlock(&emu->register_mutex);
 	return 0;
 }
 
@@ -191,13 +191,13 @@ snd_emux_close_seq_oss(struct snd_seq_oss_arg *arg)
 	emu = p->emu;
 	snd_assert(emu != NULL, return -ENXIO);
 
-	down(&emu->register_mutex);
+	mutex_lock(&emu->register_mutex);
 	snd_emux_sounds_off_all(p);
 	snd_soundfont_close_check(emu->sflist, SF_CLIENT_NO(p->chset.port));
 	snd_seq_event_port_detach(p->chset.client, p->chset.port);
 	snd_emux_dec_count(emu);
 
-	up(&emu->register_mutex);
+	mutex_unlock(&emu->register_mutex);
 	return 0;
 }
 

commit 03da312ac080b4f5c9359c233b8812cc93a035fe
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:24:47 2005 +0100

    [ALSA] Remove xxx_t typedefs: Emu-X synth
    
    Modules: Common EMU synth,SoundFont,Synth
    
    Remove xxx_t typedefs from the Emu-X synth support.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index 5272f4ac8afd..dfbfcfbe5dd2 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -31,19 +31,25 @@
 #include "emux_voice.h"
 #include <sound/asoundef.h>
 
-static int snd_emux_open_seq_oss(snd_seq_oss_arg_t *arg, void *closure);
-static int snd_emux_close_seq_oss(snd_seq_oss_arg_t *arg);
-static int snd_emux_ioctl_seq_oss(snd_seq_oss_arg_t *arg, unsigned int cmd, unsigned long ioarg);
-static int snd_emux_load_patch_seq_oss(snd_seq_oss_arg_t *arg, int format, const char __user *buf, int offs, int count);
-static int snd_emux_reset_seq_oss(snd_seq_oss_arg_t *arg);
-static int snd_emux_event_oss_input(snd_seq_event_t *ev, int direct, void *private, int atomic, int hop);
-static void reset_port_mode(snd_emux_port_t *port, int midi_mode);
-static void emuspec_control(snd_emux_t *emu, snd_emux_port_t *port, int cmd, unsigned char *event, int atomic, int hop);
-static void gusspec_control(snd_emux_t *emu, snd_emux_port_t *port, int cmd, unsigned char *event, int atomic, int hop);
-static void fake_event(snd_emux_t *emu, snd_emux_port_t *port, int ch, int param, int val, int atomic, int hop);
+static int snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure);
+static int snd_emux_close_seq_oss(struct snd_seq_oss_arg *arg);
+static int snd_emux_ioctl_seq_oss(struct snd_seq_oss_arg *arg, unsigned int cmd,
+				  unsigned long ioarg);
+static int snd_emux_load_patch_seq_oss(struct snd_seq_oss_arg *arg, int format,
+				       const char __user *buf, int offs, int count);
+static int snd_emux_reset_seq_oss(struct snd_seq_oss_arg *arg);
+static int snd_emux_event_oss_input(struct snd_seq_event *ev, int direct,
+				    void *private, int atomic, int hop);
+static void reset_port_mode(struct snd_emux_port *port, int midi_mode);
+static void emuspec_control(struct snd_emux *emu, struct snd_emux_port *port,
+			    int cmd, unsigned char *event, int atomic, int hop);
+static void gusspec_control(struct snd_emux *emu, struct snd_emux_port *port,
+			    int cmd, unsigned char *event, int atomic, int hop);
+static void fake_event(struct snd_emux *emu, struct snd_emux_port *port,
+		       int ch, int param, int val, int atomic, int hop);
 
 /* operators */
-static snd_seq_oss_callback_t oss_callback = {
+static struct snd_seq_oss_callback oss_callback = {
 	.owner = THIS_MODULE,
 	.open = snd_emux_open_seq_oss,
 	.close = snd_emux_close_seq_oss,
@@ -58,13 +64,13 @@ static snd_seq_oss_callback_t oss_callback = {
  */
 
 void
-snd_emux_init_seq_oss(snd_emux_t *emu)
+snd_emux_init_seq_oss(struct snd_emux *emu)
 {
-	snd_seq_oss_reg_t *arg;
-	snd_seq_device_t *dev;
+	struct snd_seq_oss_reg *arg;
+	struct snd_seq_device *dev;
 
 	if (snd_seq_device_new(emu->card, 0, SNDRV_SEQ_DEV_ID_OSS,
-			       sizeof(snd_seq_oss_reg_t), &dev) < 0)
+			       sizeof(struct snd_seq_oss_reg), &dev) < 0)
 		return;
 
 	emu->oss_synth = dev;
@@ -85,7 +91,7 @@ snd_emux_init_seq_oss(snd_emux_t *emu)
  * unregister
  */
 void
-snd_emux_detach_seq_oss(snd_emux_t *emu)
+snd_emux_detach_seq_oss(struct snd_emux *emu)
 {
 	if (emu->oss_synth) {
 		snd_device_free(emu->card, emu->oss_synth);
@@ -101,11 +107,11 @@ snd_emux_detach_seq_oss(snd_emux_t *emu)
  * open port for OSS sequencer
  */
 static int
-snd_emux_open_seq_oss(snd_seq_oss_arg_t *arg, void *closure)
+snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)
 {
-	snd_emux_t *emu;
-	snd_emux_port_t *p;
-	snd_seq_port_callback_t callback;
+	struct snd_emux *emu;
+	struct snd_emux_port *p;
+	struct snd_seq_port_callback callback;
 	char tmpname[64];
 
 	emu = closure;
@@ -153,7 +159,7 @@ snd_emux_open_seq_oss(snd_seq_oss_arg_t *arg, void *closure)
  * reset port mode
  */
 static void
-reset_port_mode(snd_emux_port_t *port, int midi_mode)
+reset_port_mode(struct snd_emux_port *port, int midi_mode)
 {
 	if (midi_mode) {
 		port->port_mode = SNDRV_EMUX_PORT_MODE_OSS_MIDI;
@@ -173,10 +179,10 @@ reset_port_mode(snd_emux_port_t *port, int midi_mode)
  * close port
  */
 static int
-snd_emux_close_seq_oss(snd_seq_oss_arg_t *arg)
+snd_emux_close_seq_oss(struct snd_seq_oss_arg *arg)
 {
-	snd_emux_t *emu;
-	snd_emux_port_t *p;
+	struct snd_emux *emu;
+	struct snd_emux_port *p;
 
 	snd_assert(arg != NULL, return -ENXIO);
 	p = arg->private_data;
@@ -200,11 +206,11 @@ snd_emux_close_seq_oss(snd_seq_oss_arg_t *arg)
  * load patch
  */
 static int
-snd_emux_load_patch_seq_oss(snd_seq_oss_arg_t *arg, int format,
+snd_emux_load_patch_seq_oss(struct snd_seq_oss_arg *arg, int format,
 			    const char __user *buf, int offs, int count)
 {
-	snd_emux_t *emu;
-	snd_emux_port_t *p;
+	struct snd_emux *emu;
+	struct snd_emux_port *p;
 	int rc;
 
 	snd_assert(arg != NULL, return -ENXIO);
@@ -218,7 +224,7 @@ snd_emux_load_patch_seq_oss(snd_seq_oss_arg_t *arg, int format,
 		rc = snd_soundfont_load_guspatch(emu->sflist, buf, count,
 						 SF_CLIENT_NO(p->chset.port));
 	else if (format == SNDRV_OSS_SOUNDFONT_PATCH) {
-		soundfont_patch_info_t patch;
+		struct soundfont_patch_info patch;
 		if (count < (int)sizeof(patch))
 			rc = -EINVAL;
 		if (copy_from_user(&patch, buf, sizeof(patch)))
@@ -242,10 +248,10 @@ snd_emux_load_patch_seq_oss(snd_seq_oss_arg_t *arg, int format,
  * ioctl
  */
 static int
-snd_emux_ioctl_seq_oss(snd_seq_oss_arg_t *arg, unsigned int cmd, unsigned long ioarg)
+snd_emux_ioctl_seq_oss(struct snd_seq_oss_arg *arg, unsigned int cmd, unsigned long ioarg)
 {
-	snd_emux_port_t *p;
-	snd_emux_t *emu;
+	struct snd_emux_port *p;
+	struct snd_emux *emu;
 
 	snd_assert(arg != NULL, return -ENXIO);
 	p = arg->private_data;
@@ -273,9 +279,9 @@ snd_emux_ioctl_seq_oss(snd_seq_oss_arg_t *arg, unsigned int cmd, unsigned long i
  * reset device
  */
 static int
-snd_emux_reset_seq_oss(snd_seq_oss_arg_t *arg)
+snd_emux_reset_seq_oss(struct snd_seq_oss_arg *arg)
 {
-	snd_emux_port_t *p;
+	struct snd_emux_port *p;
 
 	snd_assert(arg != NULL, return -ENXIO);
 	p = arg->private_data;
@@ -289,11 +295,11 @@ snd_emux_reset_seq_oss(snd_seq_oss_arg_t *arg)
  * receive raw events: only SEQ_PRIVATE is accepted.
  */
 static int
-snd_emux_event_oss_input(snd_seq_event_t *ev, int direct, void *private_data,
+snd_emux_event_oss_input(struct snd_seq_event *ev, int direct, void *private_data,
 			 int atomic, int hop)
 {
-	snd_emux_t *emu;
-	snd_emux_port_t *p;
+	struct snd_emux *emu;
+	struct snd_emux_port *p;
 	unsigned char cmd, *data;
 
 	p = private_data;
@@ -320,14 +326,14 @@ snd_emux_event_oss_input(snd_seq_event_t *ev, int direct, void *private_data,
  * OSS/AWE driver specific h/w controls
  */
 static void
-emuspec_control(snd_emux_t *emu, snd_emux_port_t *port, int cmd,
+emuspec_control(struct snd_emux *emu, struct snd_emux_port *port, int cmd,
 		unsigned char *event, int atomic, int hop)
 {
 	int voice;
 	unsigned short p1;
 	short p2;
 	int i;
-	snd_midi_channel_t *chan;
+	struct snd_midi_channel *chan;
 
 	voice = event[3];
 	if (voice < 0 || voice >= port->chset.max_channels)
@@ -415,14 +421,14 @@ emuspec_control(snd_emux_t *emu, snd_emux_port_t *port, int cmd,
 #include <linux/ultrasound.h>
 
 static void
-gusspec_control(snd_emux_t *emu, snd_emux_port_t *port, int cmd,
+gusspec_control(struct snd_emux *emu, struct snd_emux_port *port, int cmd,
 		unsigned char *event, int atomic, int hop)
 {
 	int voice;
 	unsigned short p1;
 	short p2;
 	int plong;
-	snd_midi_channel_t *chan;
+	struct snd_midi_channel *chan;
 
 	if (port->port_mode != SNDRV_EMUX_PORT_MODE_OSS_SYNTH)
 		return;
@@ -483,9 +489,9 @@ gusspec_control(snd_emux_t *emu, snd_emux_port_t *port, int cmd,
  * send an event to midi emulation
  */
 static void
-fake_event(snd_emux_t *emu, snd_emux_port_t *port, int ch, int param, int val, int atomic, int hop)
+fake_event(struct snd_emux *emu, struct snd_emux_port *port, int ch, int param, int val, int atomic, int hop)
 {
-	snd_seq_event_t ev;
+	struct snd_seq_event ev;
 	memset(&ev, 0, sizeof(ev));
 	ev.type = SNDRV_SEQ_EVENT_CONTROLLER;
 	ev.data.control.channel = ch;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
new file mode 100644
index 000000000000..5272f4ac8afd
--- /dev/null
+++ b/sound/synth/emux/emux_oss.c
@@ -0,0 +1,497 @@
+/*
+ *  Interface for OSS sequencer emulation
+ *
+ *  Copyright (C) 1999 Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * Changes
+ * 19990227   Steve Ratcliffe   Made separate file and merged in latest
+ * 				midi emulation.
+ */
+
+#include <sound/driver.h>
+
+#ifdef CONFIG_SND_SEQUENCER_OSS
+
+#include <asm/uaccess.h>
+#include <sound/core.h>
+#include "emux_voice.h"
+#include <sound/asoundef.h>
+
+static int snd_emux_open_seq_oss(snd_seq_oss_arg_t *arg, void *closure);
+static int snd_emux_close_seq_oss(snd_seq_oss_arg_t *arg);
+static int snd_emux_ioctl_seq_oss(snd_seq_oss_arg_t *arg, unsigned int cmd, unsigned long ioarg);
+static int snd_emux_load_patch_seq_oss(snd_seq_oss_arg_t *arg, int format, const char __user *buf, int offs, int count);
+static int snd_emux_reset_seq_oss(snd_seq_oss_arg_t *arg);
+static int snd_emux_event_oss_input(snd_seq_event_t *ev, int direct, void *private, int atomic, int hop);
+static void reset_port_mode(snd_emux_port_t *port, int midi_mode);
+static void emuspec_control(snd_emux_t *emu, snd_emux_port_t *port, int cmd, unsigned char *event, int atomic, int hop);
+static void gusspec_control(snd_emux_t *emu, snd_emux_port_t *port, int cmd, unsigned char *event, int atomic, int hop);
+static void fake_event(snd_emux_t *emu, snd_emux_port_t *port, int ch, int param, int val, int atomic, int hop);
+
+/* operators */
+static snd_seq_oss_callback_t oss_callback = {
+	.owner = THIS_MODULE,
+	.open = snd_emux_open_seq_oss,
+	.close = snd_emux_close_seq_oss,
+	.ioctl = snd_emux_ioctl_seq_oss,
+	.load_patch = snd_emux_load_patch_seq_oss,
+	.reset = snd_emux_reset_seq_oss,
+};
+
+
+/*
+ * register OSS synth
+ */
+
+void
+snd_emux_init_seq_oss(snd_emux_t *emu)
+{
+	snd_seq_oss_reg_t *arg;
+	snd_seq_device_t *dev;
+
+	if (snd_seq_device_new(emu->card, 0, SNDRV_SEQ_DEV_ID_OSS,
+			       sizeof(snd_seq_oss_reg_t), &dev) < 0)
+		return;
+
+	emu->oss_synth = dev;
+	strcpy(dev->name, emu->name);
+	arg = SNDRV_SEQ_DEVICE_ARGPTR(dev);
+	arg->type = SYNTH_TYPE_SAMPLE;
+	arg->subtype = SAMPLE_TYPE_AWE32;
+	arg->nvoices = emu->max_voices;
+	arg->oper = oss_callback;
+	arg->private_data = emu;
+
+	/* register to OSS synth table */
+	snd_device_register(emu->card, dev);
+}
+
+
+/*
+ * unregister
+ */
+void
+snd_emux_detach_seq_oss(snd_emux_t *emu)
+{
+	if (emu->oss_synth) {
+		snd_device_free(emu->card, emu->oss_synth);
+		emu->oss_synth = NULL;
+	}
+}
+
+
+/* use port number as a unique soundfont client number */
+#define SF_CLIENT_NO(p)	((p) + 0x1000)
+
+/*
+ * open port for OSS sequencer
+ */
+static int
+snd_emux_open_seq_oss(snd_seq_oss_arg_t *arg, void *closure)
+{
+	snd_emux_t *emu;
+	snd_emux_port_t *p;
+	snd_seq_port_callback_t callback;
+	char tmpname[64];
+
+	emu = closure;
+	snd_assert(arg != NULL && emu != NULL, return -ENXIO);
+
+	down(&emu->register_mutex);
+
+	if (!snd_emux_inc_count(emu)) {
+		up(&emu->register_mutex);
+		return -EFAULT;
+	}
+
+	memset(&callback, 0, sizeof(callback));
+	callback.owner = THIS_MODULE;
+	callback.event_input = snd_emux_event_oss_input;
+
+	sprintf(tmpname, "%s OSS Port", emu->name);
+	p = snd_emux_create_port(emu, tmpname, 32,
+				 1, &callback);
+	if (p == NULL) {
+		snd_printk("can't create port\n");
+		snd_emux_dec_count(emu);
+		up(&emu->register_mutex);
+		return -ENOMEM;
+	}
+
+	/* fill the argument data */
+	arg->private_data = p;
+	arg->addr.client = p->chset.client;
+	arg->addr.port = p->chset.port;
+	p->oss_arg = arg;
+
+	reset_port_mode(p, arg->seq_mode);
+
+	snd_emux_reset_port(p);
+
+	up(&emu->register_mutex);
+	return 0;
+}
+
+
+#define DEFAULT_DRUM_FLAGS	((1<<9) | (1<<25))
+
+/*
+ * reset port mode
+ */
+static void
+reset_port_mode(snd_emux_port_t *port, int midi_mode)
+{
+	if (midi_mode) {
+		port->port_mode = SNDRV_EMUX_PORT_MODE_OSS_MIDI;
+		port->drum_flags = DEFAULT_DRUM_FLAGS;
+		port->volume_atten = 0;
+		port->oss_arg->event_passing = SNDRV_SEQ_OSS_PROCESS_KEYPRESS;
+	} else {
+		port->port_mode = SNDRV_EMUX_PORT_MODE_OSS_SYNTH;
+		port->drum_flags = 0;
+		port->volume_atten = 32;
+		port->oss_arg->event_passing = SNDRV_SEQ_OSS_PROCESS_EVENTS;
+	}
+}
+
+
+/*
+ * close port
+ */
+static int
+snd_emux_close_seq_oss(snd_seq_oss_arg_t *arg)
+{
+	snd_emux_t *emu;
+	snd_emux_port_t *p;
+
+	snd_assert(arg != NULL, return -ENXIO);
+	p = arg->private_data;
+	snd_assert(p != NULL, return -ENXIO);
+
+	emu = p->emu;
+	snd_assert(emu != NULL, return -ENXIO);
+
+	down(&emu->register_mutex);
+	snd_emux_sounds_off_all(p);
+	snd_soundfont_close_check(emu->sflist, SF_CLIENT_NO(p->chset.port));
+	snd_seq_event_port_detach(p->chset.client, p->chset.port);
+	snd_emux_dec_count(emu);
+
+	up(&emu->register_mutex);
+	return 0;
+}
+
+
+/*
+ * load patch
+ */
+static int
+snd_emux_load_patch_seq_oss(snd_seq_oss_arg_t *arg, int format,
+			    const char __user *buf, int offs, int count)
+{
+	snd_emux_t *emu;
+	snd_emux_port_t *p;
+	int rc;
+
+	snd_assert(arg != NULL, return -ENXIO);
+	p = arg->private_data;
+	snd_assert(p != NULL, return -ENXIO);
+
+	emu = p->emu;
+	snd_assert(emu != NULL, return -ENXIO);
+
+	if (format == GUS_PATCH)
+		rc = snd_soundfont_load_guspatch(emu->sflist, buf, count,
+						 SF_CLIENT_NO(p->chset.port));
+	else if (format == SNDRV_OSS_SOUNDFONT_PATCH) {
+		soundfont_patch_info_t patch;
+		if (count < (int)sizeof(patch))
+			rc = -EINVAL;
+		if (copy_from_user(&patch, buf, sizeof(patch)))
+			rc = -EFAULT;
+		if (patch.type >= SNDRV_SFNT_LOAD_INFO &&
+		    patch.type <= SNDRV_SFNT_PROBE_DATA)
+			rc = snd_soundfont_load(emu->sflist, buf, count, SF_CLIENT_NO(p->chset.port));
+		else {
+			if (emu->ops.load_fx)
+				rc = emu->ops.load_fx(emu, patch.type, patch.optarg, buf, count);
+			else
+				rc = -EINVAL;
+		}
+	} else
+		rc = 0;
+	return rc;
+}
+
+
+/*
+ * ioctl
+ */
+static int
+snd_emux_ioctl_seq_oss(snd_seq_oss_arg_t *arg, unsigned int cmd, unsigned long ioarg)
+{
+	snd_emux_port_t *p;
+	snd_emux_t *emu;
+
+	snd_assert(arg != NULL, return -ENXIO);
+	p = arg->private_data;
+	snd_assert(p != NULL, return -ENXIO);
+
+	emu = p->emu;
+	snd_assert(emu != NULL, return -ENXIO);
+
+	switch (cmd) {
+	case SNDCTL_SEQ_RESETSAMPLES:
+		snd_soundfont_remove_samples(emu->sflist);
+		return 0;
+			
+	case SNDCTL_SYNTH_MEMAVL:
+		if (emu->memhdr)
+			return snd_util_mem_avail(emu->memhdr);
+		return 0;
+	}
+
+	return 0;
+}
+
+
+/*
+ * reset device
+ */
+static int
+snd_emux_reset_seq_oss(snd_seq_oss_arg_t *arg)
+{
+	snd_emux_port_t *p;
+
+	snd_assert(arg != NULL, return -ENXIO);
+	p = arg->private_data;
+	snd_assert(p != NULL, return -ENXIO);
+	snd_emux_reset_port(p);
+	return 0;
+}
+
+
+/*
+ * receive raw events: only SEQ_PRIVATE is accepted.
+ */
+static int
+snd_emux_event_oss_input(snd_seq_event_t *ev, int direct, void *private_data,
+			 int atomic, int hop)
+{
+	snd_emux_t *emu;
+	snd_emux_port_t *p;
+	unsigned char cmd, *data;
+
+	p = private_data;
+	snd_assert(p != NULL, return -EINVAL);
+	emu = p->emu;
+	snd_assert(emu != NULL, return -EINVAL);
+	if (ev->type != SNDRV_SEQ_EVENT_OSS)
+		return snd_emux_event_input(ev, direct, private_data, atomic, hop);
+
+	data = ev->data.raw8.d;
+	/* only SEQ_PRIVATE is accepted */
+	if (data[0] != 0xfe)
+		return 0;
+	cmd = data[2] & _EMUX_OSS_MODE_VALUE_MASK;
+	if (data[2] & _EMUX_OSS_MODE_FLAG)
+		emuspec_control(emu, p, cmd, data, atomic, hop);
+	else
+		gusspec_control(emu, p, cmd, data, atomic, hop);
+	return 0;
+}
+
+
+/*
+ * OSS/AWE driver specific h/w controls
+ */
+static void
+emuspec_control(snd_emux_t *emu, snd_emux_port_t *port, int cmd,
+		unsigned char *event, int atomic, int hop)
+{
+	int voice;
+	unsigned short p1;
+	short p2;
+	int i;
+	snd_midi_channel_t *chan;
+
+	voice = event[3];
+	if (voice < 0 || voice >= port->chset.max_channels)
+		chan = NULL;
+	else
+		chan = &port->chset.channels[voice];
+
+	p1 = *(unsigned short *) &event[4];
+	p2 = *(short *) &event[6];
+
+	switch (cmd) {
+#if 0 /* don't do this atomically */
+	case _EMUX_OSS_REMOVE_LAST_SAMPLES:
+		snd_soundfont_remove_unlocked(emu->sflist);
+		break;
+#endif
+	case _EMUX_OSS_SEND_EFFECT:
+		if (chan)
+			snd_emux_send_effect_oss(port, chan, p1, p2);
+		break;
+		
+	case _EMUX_OSS_TERMINATE_ALL:
+		snd_emux_terminate_all(emu);
+		break;
+
+	case _EMUX_OSS_TERMINATE_CHANNEL:
+		/*snd_emux_mute_channel(emu, chan);*/
+		break;
+	case _EMUX_OSS_RESET_CHANNEL:
+		/*snd_emux_channel_init(chset, chan);*/
+		break;
+
+	case _EMUX_OSS_RELEASE_ALL:
+		fake_event(emu, port, voice, MIDI_CTL_ALL_NOTES_OFF, 0, atomic, hop);
+		break;
+	case _EMUX_OSS_NOTEOFF_ALL:
+		fake_event(emu, port, voice, MIDI_CTL_ALL_SOUNDS_OFF, 0, atomic, hop);
+		break;
+
+	case _EMUX_OSS_INITIAL_VOLUME:
+		if (p2) {
+			port->volume_atten = (short)p1;
+			snd_emux_update_port(port, SNDRV_EMUX_UPDATE_VOLUME);
+		}
+		break;
+
+	case _EMUX_OSS_CHN_PRESSURE:
+		if (chan) {
+			chan->midi_pressure = p1;
+			snd_emux_update_channel(port, chan, SNDRV_EMUX_UPDATE_FMMOD|SNDRV_EMUX_UPDATE_FM2FRQ2);
+		}
+		break;
+
+	case _EMUX_OSS_CHANNEL_MODE:
+		reset_port_mode(port, p1);
+		snd_emux_reset_port(port);
+		break;
+
+	case _EMUX_OSS_DRUM_CHANNELS:
+		port->drum_flags = *(unsigned int*)&event[4];
+		for (i = 0; i < port->chset.max_channels; i++) {
+			chan = &port->chset.channels[i];
+			chan->drum_channel = ((port->drum_flags >> i) & 1) ? 1 : 0;
+		}
+		break;
+
+	case _EMUX_OSS_MISC_MODE:
+		if (p1 < EMUX_MD_END)
+			port->ctrls[p1] = p2;
+		break;
+	case _EMUX_OSS_DEBUG_MODE:
+		break;
+
+	default:
+		if (emu->ops.oss_ioctl)
+			emu->ops.oss_ioctl(emu, cmd, p1, p2);
+		break;
+	}
+}
+
+/*
+ * GUS specific h/w controls
+ */
+
+#include <linux/ultrasound.h>
+
+static void
+gusspec_control(snd_emux_t *emu, snd_emux_port_t *port, int cmd,
+		unsigned char *event, int atomic, int hop)
+{
+	int voice;
+	unsigned short p1;
+	short p2;
+	int plong;
+	snd_midi_channel_t *chan;
+
+	if (port->port_mode != SNDRV_EMUX_PORT_MODE_OSS_SYNTH)
+		return;
+	if (cmd == _GUS_NUMVOICES)
+		return;
+	voice = event[3];
+	if (voice < 0 || voice >= port->chset.max_channels)
+		return;
+
+	chan = &port->chset.channels[voice];
+
+	p1 = *(unsigned short *) &event[4];
+	p2 = *(short *) &event[6];
+	plong = *(int*) &event[4];
+
+	switch (cmd) {
+	case _GUS_VOICESAMPLE:
+		chan->midi_program = p1;
+		return;
+
+	case _GUS_VOICEBALA:
+		/* 0 to 15 --> 0 to 127 */
+		chan->control[MIDI_CTL_MSB_PAN] = (int)p1 << 3;
+		snd_emux_update_channel(port, chan, SNDRV_EMUX_UPDATE_PAN);
+		return;
+
+	case _GUS_VOICEVOL:
+	case _GUS_VOICEVOL2:
+		/* not supported yet */
+		return;
+
+	case _GUS_RAMPRANGE:
+	case _GUS_RAMPRATE:
+	case _GUS_RAMPMODE:
+	case _GUS_RAMPON:
+	case _GUS_RAMPOFF:
+		/* volume ramping not supported */
+		return;
+
+	case _GUS_VOLUME_SCALE:
+		return;
+
+	case _GUS_VOICE_POS:
+#ifdef SNDRV_EMUX_USE_RAW_EFFECT
+		snd_emux_send_effect(port, chan, EMUX_FX_SAMPLE_START,
+				     (short)(plong & 0x7fff),
+				     EMUX_FX_FLAG_SET);
+		snd_emux_send_effect(port, chan, EMUX_FX_COARSE_SAMPLE_START,
+				     (plong >> 15) & 0xffff,
+				     EMUX_FX_FLAG_SET);
+#endif
+		return;
+	}
+}
+
+
+/*
+ * send an event to midi emulation
+ */
+static void
+fake_event(snd_emux_t *emu, snd_emux_port_t *port, int ch, int param, int val, int atomic, int hop)
+{
+	snd_seq_event_t ev;
+	memset(&ev, 0, sizeof(ev));
+	ev.type = SNDRV_SEQ_EVENT_CONTROLLER;
+	ev.data.control.channel = ch;
+	ev.data.control.param = param;
+	ev.data.control.value = val;
+	snd_emux_event_input(&ev, 0, port, atomic, hop);
+}
+
+#endif /* CONFIG_SND_SEQUENCER_OSS */
