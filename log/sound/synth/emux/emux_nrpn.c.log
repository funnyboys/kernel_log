commit 55a6921bf1ea0cfd01aa798c084b6932842fe10e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:36 2020 +0100

    ALSA: emux: More constifications
    
    Apply const prefix to each possible place: the MIDI data definitions,
    the static tables for volume parameters, etc.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-22-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_nrpn.c b/sound/synth/emux/emux_nrpn.c
index 1ac22676d464..7eed5791972c 100644
--- a/sound/synth/emux/emux_nrpn.c
+++ b/sound/synth/emux/emux_nrpn.c
@@ -63,7 +63,7 @@ static int send_converted_effect(const struct nrpn_conv_table *table,
 /* effect sensitivities for GS NRPN:
  *  adjusted for chaos 8MB soundfonts
  */
-static int gs_sense[] = 
+static const int gs_sense[] =
 {
 	DEF_FX_CUTOFF, DEF_FX_RESONANCE, DEF_FX_ATTACK, DEF_FX_RELEASE,
 	DEF_FX_VIBRATE, DEF_FX_VIBDEPTH, DEF_FX_VIBDELAY
@@ -72,7 +72,7 @@ static int gs_sense[] =
 /* effect sensitivies for XG controls:
  * adjusted for chaos 8MB soundfonts
  */
-static int xg_sense[] = 
+static const int xg_sense[] =
 {
 	DEF_FX_CUTOFF, DEF_FX_RESONANCE, DEF_FX_ATTACK, DEF_FX_RELEASE,
 	DEF_FX_VIBRATE, DEF_FX_VIBDEPTH, DEF_FX_VIBDELAY

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/synth/emux/emux_nrpn.c b/sound/synth/emux/emux_nrpn.c
index 9729a15b6ae6..1ac22676d464 100644
--- a/sound/synth/emux/emux_nrpn.c
+++ b/sound/synth/emux/emux_nrpn.c
@@ -1,22 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  NRPN / SYSEX callbacks for Emu8k/Emu10k1
  *
  *  Copyright (c) 1999-2000 Takashi Iwai <tiwai@suse.de>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include "emux_voice.h"

commit 3643b46c381eda180df1ec68cd2ec5c79afd61f3
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Mon Jan 4 17:50:47 2016 +0100

    ALSA: emux: constify nrpn_conv_table structures
    
    The nrpn_conv_table structures are never modified, so declare them as
    const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_nrpn.c b/sound/synth/emux/emux_nrpn.c
index 00fc005ecf6e..9729a15b6ae6 100644
--- a/sound/synth/emux/emux_nrpn.c
+++ b/sound/synth/emux/emux_nrpn.c
@@ -48,7 +48,8 @@ struct nrpn_conv_table {
  * convert NRPN/control values
  */
 
-static int send_converted_effect(struct nrpn_conv_table *table, int num_tables,
+static int send_converted_effect(const struct nrpn_conv_table *table,
+				 int num_tables,
 				 struct snd_emux_port *port,
 				 struct snd_midi_channel *chan,
 				 int type, int val, int mode)
@@ -179,7 +180,7 @@ static int fx_conv_Q(int val)
 }
 
 
-static struct nrpn_conv_table awe_effects[] =
+static const struct nrpn_conv_table awe_effects[] =
 {
 	{ 0, EMUX_FX_LFO1_DELAY,	fx_lfo1_delay},
 	{ 1, EMUX_FX_LFO1_FREQ,	fx_lfo1_freq},
@@ -266,7 +267,7 @@ static int gs_vib_delay(int val)
 	return -(val - 64) * gs_sense[FX_VIBDELAY] / 50;
 }
 
-static struct nrpn_conv_table gs_effects[] =
+static const struct nrpn_conv_table gs_effects[] =
 {
 	{32, EMUX_FX_CUTOFF,	gs_cutoff},
 	{33, EMUX_FX_FILTERQ,	gs_filterQ},
@@ -350,7 +351,7 @@ static int xg_release(int val)
 	return -(val - 64) * xg_sense[FX_RELEASE] / 64;
 }
 
-static struct nrpn_conv_table xg_effects[] =
+static const struct nrpn_conv_table xg_effects[] =
 {
 	{71, EMUX_FX_CUTOFF,	xg_cutoff},
 	{74, EMUX_FX_FILTERQ,	xg_filterQ},

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/synth/emux/emux_nrpn.c b/sound/synth/emux/emux_nrpn.c
index c6917ba2c934..00fc005ecf6e 100644
--- a/sound/synth/emux/emux_nrpn.c
+++ b/sound/synth/emux/emux_nrpn.c
@@ -289,8 +289,8 @@ snd_emux_nrpn(void *p, struct snd_midi_channel *chan,
 	struct snd_emux_port *port;
 
 	port = p;
-	snd_assert(port != NULL, return);
-	snd_assert(chan != NULL, return);
+	if (snd_BUG_ON(!port || !chan))
+		return;
 
 	if (chan->control[MIDI_CTL_NONREG_PARM_NUM_MSB] == 127 &&
 	    chan->control[MIDI_CTL_NONREG_PARM_NUM_LSB] <= 26) {
@@ -379,8 +379,8 @@ snd_emux_sysex(void *p, unsigned char *buf, int len, int parsed,
 	struct snd_emux *emu;
 
 	port = p;
-	snd_assert(port != NULL, return);
-	snd_assert(chset != NULL, return);
+	if (snd_BUG_ON(!port || !chset))
+		return;
 	emu = port->emu;
 
 	switch (parsed) {

commit 03da312ac080b4f5c9359c233b8812cc93a035fe
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:24:47 2005 +0100

    [ALSA] Remove xxx_t typedefs: Emu-X synth
    
    Modules: Common EMU synth,SoundFont,Synth
    
    Remove xxx_t typedefs from the Emu-X synth support.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/synth/emux/emux_nrpn.c b/sound/synth/emux/emux_nrpn.c
index 25edff9e1fc2..c6917ba2c934 100644
--- a/sound/synth/emux/emux_nrpn.c
+++ b/sound/synth/emux/emux_nrpn.c
@@ -27,11 +27,11 @@
  */
 
 /* NRPN / CC -> Emu8000 parameter converter */
-typedef struct {
+struct nrpn_conv_table {
 	int control;
 	int effect;
 	int (*convert)(int val);
-} nrpn_conv_table;
+};
 
 /* effect sensitivity */
 
@@ -48,8 +48,9 @@ typedef struct {
  * convert NRPN/control values
  */
 
-static int send_converted_effect(nrpn_conv_table *table, int num_tables,
-				 snd_emux_port_t *port, snd_midi_channel_t *chan,
+static int send_converted_effect(struct nrpn_conv_table *table, int num_tables,
+				 struct snd_emux_port *port,
+				 struct snd_midi_channel *chan,
 				 int type, int val, int mode)
 {
 	int i, cval;
@@ -178,7 +179,7 @@ static int fx_conv_Q(int val)
 }
 
 
-static nrpn_conv_table awe_effects[] =
+static struct nrpn_conv_table awe_effects[] =
 {
 	{ 0, EMUX_FX_LFO1_DELAY,	fx_lfo1_delay},
 	{ 1, EMUX_FX_LFO1_FREQ,	fx_lfo1_freq},
@@ -265,7 +266,7 @@ static int gs_vib_delay(int val)
 	return -(val - 64) * gs_sense[FX_VIBDELAY] / 50;
 }
 
-static nrpn_conv_table gs_effects[] =
+static struct nrpn_conv_table gs_effects[] =
 {
 	{32, EMUX_FX_CUTOFF,	gs_cutoff},
 	{33, EMUX_FX_FILTERQ,	gs_filterQ},
@@ -282,9 +283,10 @@ static nrpn_conv_table gs_effects[] =
  * NRPN events
  */
 void
-snd_emux_nrpn(void *p, snd_midi_channel_t *chan, snd_midi_channel_set_t *chset)
+snd_emux_nrpn(void *p, struct snd_midi_channel *chan,
+	      struct snd_midi_channel_set *chset)
 {
-	snd_emux_port_t *port;
+	struct snd_emux_port *port;
 
 	port = p;
 	snd_assert(port != NULL, return);
@@ -348,7 +350,7 @@ static int xg_release(int val)
 	return -(val - 64) * xg_sense[FX_RELEASE] / 64;
 }
 
-static nrpn_conv_table xg_effects[] =
+static struct nrpn_conv_table xg_effects[] =
 {
 	{71, EMUX_FX_CUTOFF,	xg_cutoff},
 	{74, EMUX_FX_FILTERQ,	xg_filterQ},
@@ -357,7 +359,8 @@ static nrpn_conv_table xg_effects[] =
 };
 
 int
-snd_emux_xg_control(snd_emux_port_t *port, snd_midi_channel_t *chan, int param)
+snd_emux_xg_control(struct snd_emux_port *port, struct snd_midi_channel *chan,
+		    int param)
 {
 	return send_converted_effect(xg_effects, ARRAY_SIZE(xg_effects),
 				     port, chan, param,
@@ -369,10 +372,11 @@ snd_emux_xg_control(snd_emux_port_t *port, snd_midi_channel_t *chan, int param)
  * receive sysex
  */
 void
-snd_emux_sysex(void *p, unsigned char *buf, int len, int parsed, snd_midi_channel_set_t *chset)
+snd_emux_sysex(void *p, unsigned char *buf, int len, int parsed,
+	       struct snd_midi_channel_set *chset)
 {
-	snd_emux_port_t *port;
-	snd_emux_t *emu;
+	struct snd_emux_port *port;
+	struct snd_emux *emu;
 
 	port = p;
 	snd_assert(port != NULL, return);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/synth/emux/emux_nrpn.c b/sound/synth/emux/emux_nrpn.c
new file mode 100644
index 000000000000..25edff9e1fc2
--- /dev/null
+++ b/sound/synth/emux/emux_nrpn.c
@@ -0,0 +1,392 @@
+/*
+ *  NRPN / SYSEX callbacks for Emu8k/Emu10k1
+ *
+ *  Copyright (c) 1999-2000 Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include "emux_voice.h"
+#include <sound/asoundef.h>
+
+/*
+ * conversion from NRPN/control parameters to Emu8000 raw parameters
+ */
+
+/* NRPN / CC -> Emu8000 parameter converter */
+typedef struct {
+	int control;
+	int effect;
+	int (*convert)(int val);
+} nrpn_conv_table;
+
+/* effect sensitivity */
+
+#define FX_CUTOFF	0
+#define FX_RESONANCE	1
+#define FX_ATTACK	2
+#define FX_RELEASE	3
+#define FX_VIBRATE	4
+#define FX_VIBDEPTH	5
+#define FX_VIBDELAY	6
+#define FX_NUMS		7
+
+/*
+ * convert NRPN/control values
+ */
+
+static int send_converted_effect(nrpn_conv_table *table, int num_tables,
+				 snd_emux_port_t *port, snd_midi_channel_t *chan,
+				 int type, int val, int mode)
+{
+	int i, cval;
+	for (i = 0; i < num_tables; i++) {
+		if (table[i].control == type) {
+			cval = table[i].convert(val);
+			snd_emux_send_effect(port, chan, table[i].effect,
+					     cval, mode);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+#define DEF_FX_CUTOFF		170
+#define DEF_FX_RESONANCE	6
+#define DEF_FX_ATTACK		50
+#define DEF_FX_RELEASE		50
+#define DEF_FX_VIBRATE		30
+#define DEF_FX_VIBDEPTH		4
+#define DEF_FX_VIBDELAY		1500
+
+/* effect sensitivities for GS NRPN:
+ *  adjusted for chaos 8MB soundfonts
+ */
+static int gs_sense[] = 
+{
+	DEF_FX_CUTOFF, DEF_FX_RESONANCE, DEF_FX_ATTACK, DEF_FX_RELEASE,
+	DEF_FX_VIBRATE, DEF_FX_VIBDEPTH, DEF_FX_VIBDELAY
+};
+
+/* effect sensitivies for XG controls:
+ * adjusted for chaos 8MB soundfonts
+ */
+static int xg_sense[] = 
+{
+	DEF_FX_CUTOFF, DEF_FX_RESONANCE, DEF_FX_ATTACK, DEF_FX_RELEASE,
+	DEF_FX_VIBRATE, DEF_FX_VIBDEPTH, DEF_FX_VIBDELAY
+};
+
+
+/*
+ * AWE32 NRPN effects
+ */
+
+static int fx_delay(int val);
+static int fx_attack(int val);
+static int fx_hold(int val);
+static int fx_decay(int val);
+static int fx_the_value(int val);
+static int fx_twice_value(int val);
+static int fx_conv_pitch(int val);
+static int fx_conv_Q(int val);
+
+/* function for each NRPN */		/* [range]  units */
+#define fx_env1_delay	fx_delay	/* [0,5900] 4msec */
+#define fx_env1_attack	fx_attack	/* [0,5940] 1msec */
+#define fx_env1_hold	fx_hold		/* [0,8191] 1msec */
+#define fx_env1_decay	fx_decay	/* [0,5940] 4msec */
+#define fx_env1_release	fx_decay	/* [0,5940] 4msec */
+#define fx_env1_sustain	fx_the_value	/* [0,127] 0.75dB */
+#define fx_env1_pitch	fx_the_value	/* [-127,127] 9.375cents */
+#define fx_env1_cutoff	fx_the_value	/* [-127,127] 56.25cents */
+
+#define fx_env2_delay	fx_delay	/* [0,5900] 4msec */
+#define fx_env2_attack	fx_attack	/* [0,5940] 1msec */
+#define fx_env2_hold	fx_hold		/* [0,8191] 1msec */
+#define fx_env2_decay	fx_decay	/* [0,5940] 4msec */
+#define fx_env2_release	fx_decay	/* [0,5940] 4msec */
+#define fx_env2_sustain	fx_the_value	/* [0,127] 0.75dB */
+
+#define fx_lfo1_delay	fx_delay	/* [0,5900] 4msec */
+#define fx_lfo1_freq	fx_twice_value	/* [0,127] 84mHz */
+#define fx_lfo1_volume	fx_twice_value	/* [0,127] 0.1875dB */
+#define fx_lfo1_pitch	fx_the_value	/* [-127,127] 9.375cents */
+#define fx_lfo1_cutoff	fx_twice_value	/* [-64,63] 56.25cents */
+
+#define fx_lfo2_delay	fx_delay	/* [0,5900] 4msec */
+#define fx_lfo2_freq	fx_twice_value	/* [0,127] 84mHz */
+#define fx_lfo2_pitch	fx_the_value	/* [-127,127] 9.375cents */
+
+#define fx_init_pitch	fx_conv_pitch	/* [-8192,8192] cents */
+#define fx_chorus	fx_the_value	/* [0,255] -- */
+#define fx_reverb	fx_the_value	/* [0,255] -- */
+#define fx_cutoff	fx_twice_value	/* [0,127] 62Hz */
+#define fx_filterQ	fx_conv_Q	/* [0,127] -- */
+
+static int fx_delay(int val)
+{
+	return (unsigned short)snd_sf_calc_parm_delay(val);
+}
+
+static int fx_attack(int val)
+{
+	return (unsigned short)snd_sf_calc_parm_attack(val);
+}
+
+static int fx_hold(int val)
+{
+	return (unsigned short)snd_sf_calc_parm_hold(val);
+}
+
+static int fx_decay(int val)
+{
+	return (unsigned short)snd_sf_calc_parm_decay(val);
+}
+
+static int fx_the_value(int val)
+{
+	return (unsigned short)(val & 0xff);
+}
+
+static int fx_twice_value(int val)
+{
+	return (unsigned short)((val * 2) & 0xff);
+}
+
+static int fx_conv_pitch(int val)
+{
+	return (short)(val * 4096 / 1200);
+}
+
+static int fx_conv_Q(int val)
+{
+	return (unsigned short)((val / 8) & 0xff);
+}
+
+
+static nrpn_conv_table awe_effects[] =
+{
+	{ 0, EMUX_FX_LFO1_DELAY,	fx_lfo1_delay},
+	{ 1, EMUX_FX_LFO1_FREQ,	fx_lfo1_freq},
+	{ 2, EMUX_FX_LFO2_DELAY,	fx_lfo2_delay},
+	{ 3, EMUX_FX_LFO2_FREQ,	fx_lfo2_freq},
+
+	{ 4, EMUX_FX_ENV1_DELAY,	fx_env1_delay},
+	{ 5, EMUX_FX_ENV1_ATTACK,fx_env1_attack},
+	{ 6, EMUX_FX_ENV1_HOLD,	fx_env1_hold},
+	{ 7, EMUX_FX_ENV1_DECAY,	fx_env1_decay},
+	{ 8, EMUX_FX_ENV1_SUSTAIN,	fx_env1_sustain},
+	{ 9, EMUX_FX_ENV1_RELEASE,	fx_env1_release},
+
+	{10, EMUX_FX_ENV2_DELAY,	fx_env2_delay},
+	{11, EMUX_FX_ENV2_ATTACK,	fx_env2_attack},
+	{12, EMUX_FX_ENV2_HOLD,	fx_env2_hold},
+	{13, EMUX_FX_ENV2_DECAY,	fx_env2_decay},
+	{14, EMUX_FX_ENV2_SUSTAIN,	fx_env2_sustain},
+	{15, EMUX_FX_ENV2_RELEASE,	fx_env2_release},
+
+	{16, EMUX_FX_INIT_PITCH,	fx_init_pitch},
+	{17, EMUX_FX_LFO1_PITCH,	fx_lfo1_pitch},
+	{18, EMUX_FX_LFO2_PITCH,	fx_lfo2_pitch},
+	{19, EMUX_FX_ENV1_PITCH,	fx_env1_pitch},
+	{20, EMUX_FX_LFO1_VOLUME,	fx_lfo1_volume},
+	{21, EMUX_FX_CUTOFF,		fx_cutoff},
+	{22, EMUX_FX_FILTERQ,	fx_filterQ},
+	{23, EMUX_FX_LFO1_CUTOFF,	fx_lfo1_cutoff},
+	{24, EMUX_FX_ENV1_CUTOFF,	fx_env1_cutoff},
+	{25, EMUX_FX_CHORUS,		fx_chorus},
+	{26, EMUX_FX_REVERB,		fx_reverb},
+};
+
+
+/*
+ * GS(SC88) NRPN effects; still experimental
+ */
+
+/* cutoff: quarter semitone step, max=255 */
+static int gs_cutoff(int val)
+{
+	return (val - 64) * gs_sense[FX_CUTOFF] / 50;
+}
+
+/* resonance: 0 to 15(max) */
+static int gs_filterQ(int val)
+{
+	return (val - 64) * gs_sense[FX_RESONANCE] / 50;
+}
+
+/* attack: */
+static int gs_attack(int val)
+{
+	return -(val - 64) * gs_sense[FX_ATTACK] / 50;
+}
+
+/* decay: */
+static int gs_decay(int val)
+{
+	return -(val - 64) * gs_sense[FX_RELEASE] / 50;
+}
+
+/* release: */
+static int gs_release(int val)
+{
+	return -(val - 64) * gs_sense[FX_RELEASE] / 50;
+}
+
+/* vibrato freq: 0.042Hz step, max=255 */
+static int gs_vib_rate(int val)
+{
+	return (val - 64) * gs_sense[FX_VIBRATE] / 50;
+}
+
+/* vibrato depth: max=127, 1 octave */
+static int gs_vib_depth(int val)
+{
+	return (val - 64) * gs_sense[FX_VIBDEPTH] / 50;
+}
+
+/* vibrato delay: -0.725msec step */
+static int gs_vib_delay(int val)
+{
+	return -(val - 64) * gs_sense[FX_VIBDELAY] / 50;
+}
+
+static nrpn_conv_table gs_effects[] =
+{
+	{32, EMUX_FX_CUTOFF,	gs_cutoff},
+	{33, EMUX_FX_FILTERQ,	gs_filterQ},
+	{99, EMUX_FX_ENV2_ATTACK, gs_attack},
+	{100, EMUX_FX_ENV2_DECAY, gs_decay},
+	{102, EMUX_FX_ENV2_RELEASE, gs_release},
+	{8, EMUX_FX_LFO1_FREQ, gs_vib_rate},
+	{9, EMUX_FX_LFO1_VOLUME, gs_vib_depth},
+	{10, EMUX_FX_LFO1_DELAY, gs_vib_delay},
+};
+
+
+/*
+ * NRPN events
+ */
+void
+snd_emux_nrpn(void *p, snd_midi_channel_t *chan, snd_midi_channel_set_t *chset)
+{
+	snd_emux_port_t *port;
+
+	port = p;
+	snd_assert(port != NULL, return);
+	snd_assert(chan != NULL, return);
+
+	if (chan->control[MIDI_CTL_NONREG_PARM_NUM_MSB] == 127 &&
+	    chan->control[MIDI_CTL_NONREG_PARM_NUM_LSB] <= 26) {
+		int val;
+		/* Win/DOS AWE32 specific NRPNs */
+		/* both MSB/LSB necessary */
+		val = (chan->control[MIDI_CTL_MSB_DATA_ENTRY] << 7) |
+			chan->control[MIDI_CTL_LSB_DATA_ENTRY]; 
+		val -= 8192;
+		send_converted_effect
+			(awe_effects, ARRAY_SIZE(awe_effects),
+			 port, chan, chan->control[MIDI_CTL_NONREG_PARM_NUM_LSB],
+			 val, EMUX_FX_FLAG_SET);
+		return;
+	}
+
+	if (port->chset.midi_mode == SNDRV_MIDI_MODE_GS &&
+	    chan->control[MIDI_CTL_NONREG_PARM_NUM_MSB] == 1) {
+		int val;
+		/* GS specific NRPNs */
+		/* only MSB is valid */
+		val = chan->control[MIDI_CTL_MSB_DATA_ENTRY];
+		send_converted_effect
+			(gs_effects, ARRAY_SIZE(gs_effects),
+			 port, chan, chan->control[MIDI_CTL_NONREG_PARM_NUM_LSB],
+			 val, EMUX_FX_FLAG_ADD);
+		return;
+	}
+}
+
+
+/*
+ * XG control effects; still experimental
+ */
+
+/* cutoff: quarter semitone step, max=255 */
+static int xg_cutoff(int val)
+{
+	return (val - 64) * xg_sense[FX_CUTOFF] / 64;
+}
+
+/* resonance: 0(open) to 15(most nasal) */
+static int xg_filterQ(int val)
+{
+	return (val - 64) * xg_sense[FX_RESONANCE] / 64;
+}
+
+/* attack: */
+static int xg_attack(int val)
+{
+	return -(val - 64) * xg_sense[FX_ATTACK] / 64;
+}
+
+/* release: */
+static int xg_release(int val)
+{
+	return -(val - 64) * xg_sense[FX_RELEASE] / 64;
+}
+
+static nrpn_conv_table xg_effects[] =
+{
+	{71, EMUX_FX_CUTOFF,	xg_cutoff},
+	{74, EMUX_FX_FILTERQ,	xg_filterQ},
+	{72, EMUX_FX_ENV2_RELEASE, xg_release},
+	{73, EMUX_FX_ENV2_ATTACK, xg_attack},
+};
+
+int
+snd_emux_xg_control(snd_emux_port_t *port, snd_midi_channel_t *chan, int param)
+{
+	return send_converted_effect(xg_effects, ARRAY_SIZE(xg_effects),
+				     port, chan, param,
+				     chan->control[param],
+				     EMUX_FX_FLAG_ADD);
+}
+
+/*
+ * receive sysex
+ */
+void
+snd_emux_sysex(void *p, unsigned char *buf, int len, int parsed, snd_midi_channel_set_t *chset)
+{
+	snd_emux_port_t *port;
+	snd_emux_t *emu;
+
+	port = p;
+	snd_assert(port != NULL, return);
+	snd_assert(chset != NULL, return);
+	emu = port->emu;
+
+	switch (parsed) {
+	case SNDRV_MIDI_SYSEX_GS_MASTER_VOLUME:
+		snd_emux_update_port(port, SNDRV_EMUX_UPDATE_VOLUME);
+		break;
+	default:
+		if (emu->ops.sysex)
+			emu->ops.sysex(emu, buf, len, parsed, chset);
+		break;
+	}
+}
+
