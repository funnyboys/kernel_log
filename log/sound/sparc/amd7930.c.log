commit f8a32d94f31fc9e28732b73602adc072e620e466
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:55 2020 +0100

    ALSA: sparc: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-40-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 916bed46be06..9d0da5fa1c70 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -837,7 +837,7 @@ static int snd_amd7930_put_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem
 	return change;
 }
 
-static struct snd_kcontrol_new amd7930_controls[] = {
+static const struct snd_kcontrol_new amd7930_controls[] = {
 	{
 		.iface		=	SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name		=	"Monitor Volume",

commit b75851d43d73c68f302d7c11dc3ae23598c57990
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:32 2020 +0100

    ALSA: sparc: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-17-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index df1b16c97d16..916bed46be06 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -912,7 +912,7 @@ static int snd_amd7930_dev_free(struct snd_device *device)
 	return snd_amd7930_free(amd);
 }
 
-static struct snd_device_ops snd_amd7930_dev_ops = {
+static const struct snd_device_ops snd_amd7930_dev_ops = {
 	.dev_free	=	snd_amd7930_dev_free,
 };
 

commit 5fcd1aeee587f6582e66572d12fb0b9c4c2583fb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:41 2019 +0100

    ALSA: sparc: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-20-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index d39973605cca..df1b16c97d16 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -726,7 +726,6 @@ static int snd_amd7930_capture_close(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_amd7930_playback_ops = {
 	.open		=	snd_amd7930_playback_open,
 	.close		=	snd_amd7930_playback_close,
-	.ioctl		=	snd_pcm_lib_ioctl,
 	.prepare	=	snd_amd7930_playback_prepare,
 	.trigger	=	snd_amd7930_playback_trigger,
 	.pointer	=	snd_amd7930_playback_pointer,
@@ -735,7 +734,6 @@ static const struct snd_pcm_ops snd_amd7930_playback_ops = {
 static const struct snd_pcm_ops snd_amd7930_capture_ops = {
 	.open		=	snd_amd7930_capture_open,
 	.close		=	snd_amd7930_capture_close,
-	.ioctl		=	snd_pcm_lib_ioctl,
 	.prepare	=	snd_amd7930_capture_prepare,
 	.trigger	=	snd_amd7930_capture_trigger,
 	.pointer	=	snd_amd7930_capture_pointer,

commit 786e90b0d0f4ffc16237c05ac5cfc7285bf4e1bc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:34 2019 +0100

    ALSA: sparc: Use managed buffer allocation
    
    Clean up the drivers with the new managed buffer allocation API.
    The hw_params and hw_free callbacks became superfluous and dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-63-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index d4b8ccc61dc2..d39973605cca 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -723,23 +723,10 @@ static int snd_amd7930_capture_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static int snd_amd7930_hw_params(struct snd_pcm_substream *substream,
-				    struct snd_pcm_hw_params *hw_params)
-{
-	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
-}
-
-static int snd_amd7930_hw_free(struct snd_pcm_substream *substream)
-{
-	return snd_pcm_lib_free_pages(substream);
-}
-
 static const struct snd_pcm_ops snd_amd7930_playback_ops = {
 	.open		=	snd_amd7930_playback_open,
 	.close		=	snd_amd7930_playback_close,
 	.ioctl		=	snd_pcm_lib_ioctl,
-	.hw_params	=	snd_amd7930_hw_params,
-	.hw_free	=	snd_amd7930_hw_free,
 	.prepare	=	snd_amd7930_playback_prepare,
 	.trigger	=	snd_amd7930_playback_trigger,
 	.pointer	=	snd_amd7930_playback_pointer,
@@ -749,8 +736,6 @@ static const struct snd_pcm_ops snd_amd7930_capture_ops = {
 	.open		=	snd_amd7930_capture_open,
 	.close		=	snd_amd7930_capture_close,
 	.ioctl		=	snd_pcm_lib_ioctl,
-	.hw_params	=	snd_amd7930_hw_params,
-	.hw_free	=	snd_amd7930_hw_free,
 	.prepare	=	snd_amd7930_capture_prepare,
 	.trigger	=	snd_amd7930_capture_trigger,
 	.pointer	=	snd_amd7930_capture_pointer,
@@ -776,9 +761,8 @@ static int snd_amd7930_pcm(struct snd_amd7930 *amd)
 	strcpy(pcm->name, amd->card->shortname);
 	amd->pcm = pcm;
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
-					      NULL,
-					      64*1024, 64*1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
+				       NULL, 64*1024, 64*1024);
 
 	return 0;
 }

commit 0382e4e18fafcaea75ffab85838ef2110fac1668
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:37 2019 +0100

    ALSA: sparc: Remove superfluous snd_dma_continuous_data()
    
    The recent change (commit 08422d2c559d: "ALSA: memalloc: Allow NULL
    device for SNDRV_DMA_TYPE_CONTINUOUS type") made the PCM preallocation
    helper accepting NULL as the device pointer for the default usage.
    Drop the snd_dma_continuous_data() usage that became superfluous from
    the callers.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-6-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 441222c8e223..d4b8ccc61dc2 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -777,7 +777,7 @@ static int snd_amd7930_pcm(struct snd_amd7930 *amd)
 	amd->pcm = pcm;
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
-					      snd_dma_continuous_data(GFP_KERNEL),
+					      NULL,
 					      64*1024, 64*1024);
 
 	return 0;

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 56f17410fcea..441222c8e223 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Driver for AMD7930 sound chips found on Sparcs.
  * Copyright (C) 2002, 2008 David S. Miller <davem@davemloft.net>

commit 544d6272c8c85684db10e96910adc9f55f2b6350
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Aug 18 13:15:19 2017 +0530

    ALSA: sparc: constify snd_pcm_ops structures
    
    snd_pcm_ops are not supposed to change at runtime. All functions
    working with snd_pcm_ops provided by <sound/pcm.h> work with
    const snd_pcm_ops. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index a6864fda725e..56f17410fcea 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -733,7 +733,7 @@ static int snd_amd7930_hw_free(struct snd_pcm_substream *substream)
 	return snd_pcm_lib_free_pages(substream);
 }
 
-static struct snd_pcm_ops snd_amd7930_playback_ops = {
+static const struct snd_pcm_ops snd_amd7930_playback_ops = {
 	.open		=	snd_amd7930_playback_open,
 	.close		=	snd_amd7930_playback_close,
 	.ioctl		=	snd_pcm_lib_ioctl,
@@ -744,7 +744,7 @@ static struct snd_pcm_ops snd_amd7930_playback_ops = {
 	.pointer	=	snd_amd7930_playback_pointer,
 };
 
-static struct snd_pcm_ops snd_amd7930_capture_ops = {
+static const struct snd_pcm_ops snd_amd7930_capture_ops = {
 	.open		=	snd_amd7930_capture_open,
 	.close		=	snd_amd7930_capture_close,
 	.ioctl		=	snd_pcm_lib_ioctl,

commit 688ed206e16e13973cfb9e4d10c6a75768ebfd48
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Thu Aug 17 14:45:58 2017 +0530

    ALSA: sparc: make snd_pcm_hardware const
    
    Make these const as they are only used in a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 35c1f6ae773f..a6864fda725e 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -666,7 +666,7 @@ static snd_pcm_uframes_t snd_amd7930_capture_pointer(struct snd_pcm_substream *s
 }
 
 /* Playback and capture have identical properties.  */
-static struct snd_pcm_hardware snd_amd7930_pcm_hw =
+static const struct snd_pcm_hardware snd_amd7930_pcm_hw =
 {
 	.info			= (SNDRV_PCM_INFO_MMAP |
 				   SNDRV_PCM_INFO_MMAP_VALID |

commit 86bfbc15660a61bb7b3df73db11939eec3393008
Author: Luis de Bethencourt <luis@debethencourt.com>
Date:   Thu Sep 3 13:03:04 2015 +0200

    ALSA: sparc: amd7930: Fix module autoload for OF platform driver
    
    This platform driver has a OF device ID table but the OF module
    alias information is not created so module autoloading won't work.
    
    Signed-off-by: Luis de Bethencourt <luis@debethencourt.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 784ceb85b2d9..35c1f6ae773f 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1064,6 +1064,7 @@ static const struct of_device_id amd7930_match[] = {
 	},
 	{},
 };
+MODULE_DEVICE_TABLE(of, amd7930_match);
 
 static struct platform_driver amd7930_sbus_driver = {
 	.driver = {

commit 25e5eaf19962bd48788371e4f516bdd89ce248bc
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Fri Jul 17 20:33:21 2015 +0200

    ALSA: sparc: Add missing kfree in error path
    
    If 'of_ioremap' fails, then 'amd' should be freed, otherwise, there is a
    memory leak.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 1b1a89e80d13..784ceb85b2d9 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -956,6 +956,7 @@ static int snd_amd7930_create(struct snd_card *card,
 	if (!amd->regs) {
 		snd_printk(KERN_ERR
 			   "amd7930-%d: Unable to map chip registers.\n", dev);
+		kfree(amd);
 		return -EIO;
 	}
 

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 86280d63b76d..1b1a89e80d13 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -37,6 +37,7 @@
 #include <linux/moduleparam.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <linux/io.h>
 
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -44,7 +45,6 @@
 #include <sound/control.h>
 #include <sound/initval.h>
 
-#include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/prom.h>
 

commit 79cd1762933153237731585f0901eec368e54bae
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:22:16 2014 +0200

    ALSA: sparc: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 4a85e1433472..86280d63b76d 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1067,7 +1067,6 @@ static const struct of_device_id amd7930_match[] = {
 static struct platform_driver amd7930_sbus_driver = {
 	.driver = {
 		.name = "audio",
-		.owner = THIS_MODULE,
 		.of_match_table = amd7930_match,
 	},
 	.probe		= amd7930_sbus_probe,

commit a2fefc35a99f684b4ba15d243995170fa23bdd7e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:41:09 2014 +0100

    ALSA: sparc: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 174d21fb56e2..4a85e1433472 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1019,8 +1019,8 @@ static int amd7930_sbus_probe(struct platform_device *op)
 		return -ENOENT;
 	}
 
-	err = snd_card_create(index[dev_num], id[dev_num], THIS_MODULE, 0,
-			      &card);
+	err = snd_card_new(&op->dev, index[dev_num], id[dev_num],
+			   THIS_MODULE, 0, &card);
 	if (err < 0)
 		return err;
 

commit 32e02a7b690f22b2f56efac929d7c300994ddc4c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:25 2012 -0500

    ALSA: sparc: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 5701787c0e6b..174d21fb56e2 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -755,7 +755,7 @@ static struct snd_pcm_ops snd_amd7930_capture_ops = {
 	.pointer	=	snd_amd7930_capture_pointer,
 };
 
-static int __devinit snd_amd7930_pcm(struct snd_amd7930 *amd)
+static int snd_amd7930_pcm(struct snd_amd7930 *amd)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -854,7 +854,7 @@ static int snd_amd7930_put_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem
 	return change;
 }
 
-static struct snd_kcontrol_new amd7930_controls[] __devinitdata = {
+static struct snd_kcontrol_new amd7930_controls[] = {
 	{
 		.iface		=	SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name		=	"Monitor Volume",
@@ -884,7 +884,7 @@ static struct snd_kcontrol_new amd7930_controls[] __devinitdata = {
 	},
 };
 
-static int __devinit snd_amd7930_mixer(struct snd_amd7930 *amd)
+static int snd_amd7930_mixer(struct snd_amd7930 *amd)
 {
 	struct snd_card *card;
 	int idx, err;
@@ -933,10 +933,10 @@ static struct snd_device_ops snd_amd7930_dev_ops = {
 	.dev_free	=	snd_amd7930_dev_free,
 };
 
-static int __devinit snd_amd7930_create(struct snd_card *card,
-					struct platform_device *op,
-					int irq, int dev,
-					struct snd_amd7930 **ramd)
+static int snd_amd7930_create(struct snd_card *card,
+			      struct platform_device *op,
+			      int irq, int dev,
+			      struct snd_amd7930 **ramd)
 {
 	struct snd_amd7930 *amd;
 	unsigned long flags;
@@ -1002,7 +1002,7 @@ static int __devinit snd_amd7930_create(struct snd_card *card,
 	return 0;
 }
 
-static int __devinit amd7930_sbus_probe(struct platform_device *op)
+static int amd7930_sbus_probe(struct platform_device *op)
 {
 	struct resource *rp = &op->resource[0];
 	static int dev_num;

commit 395d9dd5dd13c6aa3c8c61a31126af98cd1e747d
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Fri Sep 28 11:24:57 2012 +0200

    sound: Remove unnecessary semicolon
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r1@
    statement S;
    position p,p1;
    @@
    S@p1;@p
    
    @script:python r2@
    p << r1.p;
    p1 << r1.p1;
    @@
    if p[0].line != p1[0].line_end:
            cocci.include_match(False)
    @@
    position r1.p;
    @@
    -;@p
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index b63b3a86d3f4..5701787c0e6b 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -813,7 +813,7 @@ static int snd_amd7930_get_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem
 	default:
 		swval = &amd->pgain;
 		break;
-	};
+	}
 
 	ucontrol->value.integer.value[0] = *swval;
 
@@ -838,7 +838,7 @@ static int snd_amd7930_put_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem
 	default:
 		swval = &amd->pgain;
 		break;
-	};
+	}
 
 	spin_lock_irqsave(&amd->lock, flags);
 

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index f036776380b5..b63b3a86d3f4 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -50,7 +50,7 @@
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for Sun AMD7930 soundcard.");

commit 88e24c3a4b30a6bd361f2b5ce602667a8161b2e8
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Thu Sep 22 16:59:20 2011 +0800

    sound: irq: Remove IRQF_DISABLED
    
    Since commit [e58aa3d2: genirq: Run irq handlers with interrupts disabled],
    We run all interrupt handlers with interrupts disabled
    and we even check and yell when an interrupt handler
    returns with interrupts enabled (see commit [b738a50a:
    genirq: Warn when handler enables interrupts]).
    
    So now this flag is a NOOP and can be removed.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index ad7d4d7d9237..f036776380b5 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -962,7 +962,7 @@ static int __devinit snd_amd7930_create(struct snd_card *card,
 	amd7930_idle(amd);
 
 	if (request_irq(irq, snd_amd7930_interrupt,
-			IRQF_DISABLED | IRQF_SHARED, "amd7930", amd)) {
+			IRQF_SHARED, "amd7930", amd)) {
 		snd_printk(KERN_ERR "amd7930-%d: Unable to grab IRQ %d\n",
 			   dev, irq);
 		snd_amd7930_free(amd);

commit f07eb223a081b278be02a58394cb5fd66f1a1bbd
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 22 21:05:04 2011 -0700

    dt/sound: Eliminate users of of_platform_{,un}register_driver
    
    Get rid of users of of_platform_driver in drivers/sound.  The
    of_platform_{,un}register_driver functions are going away, so the
    users need to be converted to using the platform_bus_type directly.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index f8bcfc30f800..ad7d4d7d9237 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1002,7 +1002,7 @@ static int __devinit snd_amd7930_create(struct snd_card *card,
 	return 0;
 }
 
-static int __devinit amd7930_sbus_probe(struct platform_device *op, const struct of_device_id *match)
+static int __devinit amd7930_sbus_probe(struct platform_device *op)
 {
 	struct resource *rp = &op->resource[0];
 	static int dev_num;
@@ -1064,7 +1064,7 @@ static const struct of_device_id amd7930_match[] = {
 	{},
 };
 
-static struct of_platform_driver amd7930_sbus_driver = {
+static struct platform_driver amd7930_sbus_driver = {
 	.driver = {
 		.name = "audio",
 		.owner = THIS_MODULE,
@@ -1075,7 +1075,7 @@ static struct of_platform_driver amd7930_sbus_driver = {
 
 static int __init amd7930_init(void)
 {
-	return of_register_platform_driver(&amd7930_sbus_driver);
+	return platform_driver_register(&amd7930_sbus_driver);
 }
 
 static void __exit amd7930_exit(void)
@@ -1092,7 +1092,7 @@ static void __exit amd7930_exit(void)
 
 	amd7930_list = NULL;
 
-	of_unregister_platform_driver(&amd7930_sbus_driver);
+	platform_driver_unregister(&amd7930_sbus_driver);
 }
 
 module_init(amd7930_init);

commit 2dc11581376829303b98eadb2de253bee065a56a
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Aug 6 09:25:50 2010 -0600

    of/device: Replace struct of_device with struct platform_device
    
    of_device is just an alias for platform_device, so remove it entirely.  Also
    replace to_of_device() with to_platform_device() and update comment blocks.
    
    This patch was initially generated from the following semantic patch, and then
    edited by hand to pick up the bits that coccinelle didn't catch.
    
    @@
    @@
    -struct of_device
    +struct platform_device
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: David S. Miller <davem@davemloft.net>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 9eb1a4e0363b..f8bcfc30f800 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -336,7 +336,7 @@ struct snd_amd7930 {
 	int			pgain;
 	int			mgain;
 
-	struct of_device	*op;
+	struct platform_device	*op;
 	unsigned int		irq;
 	struct snd_amd7930	*next;
 };
@@ -906,7 +906,7 @@ static int __devinit snd_amd7930_mixer(struct snd_amd7930 *amd)
 
 static int snd_amd7930_free(struct snd_amd7930 *amd)
 {
-	struct of_device *op = amd->op;
+	struct platform_device *op = amd->op;
 
 	amd7930_idle(amd);
 
@@ -934,7 +934,7 @@ static struct snd_device_ops snd_amd7930_dev_ops = {
 };
 
 static int __devinit snd_amd7930_create(struct snd_card *card,
-					struct of_device *op,
+					struct platform_device *op,
 					int irq, int dev,
 					struct snd_amd7930 **ramd)
 {
@@ -1002,7 +1002,7 @@ static int __devinit snd_amd7930_create(struct snd_card *card,
 	return 0;
 }
 
-static int __devinit amd7930_sbus_probe(struct of_device *op, const struct of_device_id *match)
+static int __devinit amd7930_sbus_probe(struct platform_device *op, const struct of_device_id *match)
 {
 	struct resource *rp = &op->resource[0];
 	static int dev_num;

commit 1ab1d63a85cee2545272f63a7644e9f855cb65d0
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jun 24 15:14:37 2010 -0600

    of/platform: remove all of_bus_type and of_platform_bus_type references
    
    Both of_bus_type and of_platform_bus_type are just #define aliases
    for the platform bus.  This patch removes all references to them and
    switches to the of_register_platform_driver()/of_unregister_platform_driver()
    API for registering.
    
    Subsequent patches will convert each user of of_register_platform_driver()
    into plain platform_drivers without the of_platform_driver shim.  At which
    point the of_register_platform_driver()/of_unregister_platform_driver()
    functions can be removed.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 43c63d441087..9eb1a4e0363b 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1075,7 +1075,7 @@ static struct of_platform_driver amd7930_sbus_driver = {
 
 static int __init amd7930_init(void)
 {
-	return of_register_driver(&amd7930_sbus_driver, &of_bus_type);
+	return of_register_platform_driver(&amd7930_sbus_driver);
 }
 
 static void __exit amd7930_exit(void)
@@ -1092,7 +1092,7 @@ static void __exit amd7930_exit(void)
 
 	amd7930_list = NULL;
 
-	of_unregister_driver(&amd7930_sbus_driver);
+	of_unregister_platform_driver(&amd7930_sbus_driver);
 }
 
 module_init(amd7930_init);

commit 1636f8ac2b08410df4766449f7c86b912443cd99
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jun 18 11:09:58 2010 -0600

    sparc/of: Move of_device fields into struct pdev_archdata
    
    This patch moves SPARC architecture specific data members out of
    struct of_device and into the pdev_archdata structure.  The reason
    for this change is to unify the struct of_device definition amongst
    all the architectures.  It also remvoes the .sysdata, .slot, .portid
    and .clock_freq properties because they aren't actually used by
    anything.
    
    A subsequent patch will replace struct of_device entirely with struct
    platform_device and the of_platform support code will share common
    routines with the platform bus (but the bus instances themselves can
    remain separate).
    
    This patch also adds 'struct resources *resource' and num_resources
    to match the fields defined in struct platform_device.  After this
    change, 'struct platform_device' can be used as a drop-in replacement
    for 'struct of_platform'.
    
    This change is in preparation for merging the of_platform_bus_type
    with the platform_bus_type.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 71221fd20944..43c63d441087 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1010,7 +1010,7 @@ static int __devinit amd7930_sbus_probe(struct of_device *op, const struct of_de
 	struct snd_amd7930 *amd;
 	int err, irq;
 
-	irq = op->irqs[0];
+	irq = op->archdata.irqs[0];
 
 	if (dev_num >= SNDRV_CARDS)
 		return -ENODEV;

commit 4018294b53d1dae026880e45f174c1cc63b5d435
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:13:02 2010 -0700

    of: Remove duplicate fields from of_platform_driver
    
    .name, .match_table and .owner are duplicated in both of_platform_driver
    and device_driver.  This patch is a removes the extra copies from struct
    of_platform_driver and converts all users to the device_driver members.
    
    This patch is a pretty mechanical change.  The usage model doesn't change
    and if any drivers have been missed, or if anything has been fixed up
    incorrectly, then it will fail with a compile time error, and the fixup
    will be trivial.  This patch looks big and scary because it touches so
    many files, but it should be pretty safe.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Sean MacLennan <smaclennan@pikatech.com>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 574af56ba8a6..71221fd20944 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1065,8 +1065,11 @@ static const struct of_device_id amd7930_match[] = {
 };
 
 static struct of_platform_driver amd7930_sbus_driver = {
-	.name		= "audio",
-	.match_table	= amd7930_match,
+	.driver = {
+		.name = "audio",
+		.owner = THIS_MODULE,
+		.of_match_table = amd7930_match,
+	},
 	.probe		= amd7930_sbus_probe,
 };
 

commit e0d2054fd3cf167395390dc1758644486c782707
Merge: d807500a2472 c468ac29e63b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:35:50 2009 +0100

    Merge branch 'topic/misc' into for-linus

commit 2ebfb8eeb8f244f9d25937d31a947895cf819e26
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 16:11:58 2009 +0100

    ALSA: Add missing KERN_* prefix to printk in other sound/*
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index f87933e48812..7cbc725934e5 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -954,7 +954,8 @@ static int __devinit snd_amd7930_create(struct snd_card *card,
 	amd->regs = of_ioremap(&op->resource[0], 0,
 			       resource_size(&op->resource[0]), "amd7930");
 	if (!amd->regs) {
-		snd_printk("amd7930-%d: Unable to map chip registers.\n", dev);
+		snd_printk(KERN_ERR
+			   "amd7930-%d: Unable to map chip registers.\n", dev);
 		return -EIO;
 	}
 
@@ -962,7 +963,7 @@ static int __devinit snd_amd7930_create(struct snd_card *card,
 
 	if (request_irq(irq, snd_amd7930_interrupt,
 			IRQF_DISABLED | IRQF_SHARED, "amd7930", amd)) {
-		snd_printk("amd7930-%d: Unable to grab IRQ %d\n",
+		snd_printk(KERN_ERR "amd7930-%d: Unable to grab IRQ %d\n",
 			   dev, irq);
 		snd_amd7930_free(amd);
 		return -EBUSY;

commit bd7dd77c2a05c530684eea2e3af16449ae9c5d52
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:45:02 2008 +0100

    ALSA: Convert to snd_card_create() in other sound/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in other sound subdirectories.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index f87933e48812..ba38912614b4 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1018,9 +1018,10 @@ static int __devinit amd7930_sbus_probe(struct of_device *op, const struct of_de
 		return -ENOENT;
 	}
 
-	card = snd_card_new(index[dev_num], id[dev_num], THIS_MODULE, 0);
-	if (card == NULL)
-		return -ENOMEM;
+	err = snd_card_create(index[dev_num], id[dev_num], THIS_MODULE, 0,
+			      &card);
+	if (err < 0)
+		return err;
 
 	strcpy(card->driver, "AMD7930");
 	strcpy(card->shortname, "Sun AMD7930");

commit 56c5d900dbb8e042bfad035d18433476931d8f93
Merge: 4dd95b63ae25 ead9d23d803e
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Oct 11 12:39:35 2008 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            sound/core/memalloc.c

commit fd098316ef533e8441576f020ead4beab93154ce
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Aug 31 01:23:17 2008 -0700

    sparc: Annotate of_device_id arrays with const or __initdata.
    
    As suggested by Stephen Rothwell.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 0f82c3f6cfdb..5af5503edadb 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1070,7 +1070,7 @@ static int __devinit amd7930_sbus_probe(struct of_device *op, const struct of_de
 	return err;
 }
 
-static struct of_device_id amd7930_match[] = {
+static const struct of_device_id amd7930_match[] = {
 	{
 		.name = "audio",
 	},

commit dc8aa2e9d6c965c11ddd05fca721b2218585b9f0
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 27 00:29:27 2008 -0700

    amd7930: Convert to pure OF driver.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 0c63e0585b15..0f82c3f6cfdb 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1,6 +1,6 @@
 /*
  * Driver for AMD7930 sound chips found on Sparcs.
- * Copyright (C) 2002 David S. Miller <davem@redhat.com>
+ * Copyright (C) 2002, 2008 David S. Miller <davem@davemloft.net>
  *
  * Based entirely upon drivers/sbus/audio/amd7930.c which is:
  * Copyright (C) 1996,1997 Thomas K. Dyas (tdyas@eden.rutgers.edu)
@@ -35,6 +35,8 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/moduleparam.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -44,7 +46,6 @@
 
 #include <asm/io.h>
 #include <asm/irq.h>
-#include <asm/sbus.h>
 #include <asm/prom.h>
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
@@ -335,8 +336,8 @@ struct snd_amd7930 {
 	int			pgain;
 	int			mgain;
 
+	struct of_device	*op;
 	unsigned int		irq;
-	unsigned int		regs_size;
 	struct snd_amd7930	*next;
 };
 
@@ -920,13 +921,16 @@ static int __devinit snd_amd7930_mixer(struct snd_amd7930 *amd)
 
 static int snd_amd7930_free(struct snd_amd7930 *amd)
 {
+	struct of_device *op = amd->op;
+
 	amd7930_idle(amd);
 
 	if (amd->irq)
 		free_irq(amd->irq, amd);
 
 	if (amd->regs)
-		sbus_iounmap(amd->regs, amd->regs_size);
+		of_iounmap(&op->resource[0], amd->regs,
+			   resource_size(&op->resource[0]));
 
 	kfree(amd);
 
@@ -945,13 +949,12 @@ static struct snd_device_ops snd_amd7930_dev_ops = {
 };
 
 static int __devinit snd_amd7930_create(struct snd_card *card,
-					struct resource *rp,
-					unsigned int reg_size,
+					struct of_device *op,
 					int irq, int dev,
 					struct snd_amd7930 **ramd)
 {
-	unsigned long flags;
 	struct snd_amd7930 *amd;
+	unsigned long flags;
 	int err;
 
 	*ramd = NULL;
@@ -961,9 +964,10 @@ static int __devinit snd_amd7930_create(struct snd_card *card,
 
 	spin_lock_init(&amd->lock);
 	amd->card = card;
-	amd->regs_size = reg_size;
+	amd->op = op;
 
-	amd->regs = sbus_ioremap(rp, 0, amd->regs_size, "amd7930");
+	amd->regs = of_ioremap(&op->resource[0], 0,
+			       resource_size(&op->resource[0]), "amd7930");
 	if (!amd->regs) {
 		snd_printk("amd7930-%d: Unable to map chip registers.\n", dev);
 		return -EIO;
@@ -1012,12 +1016,15 @@ static int __devinit snd_amd7930_create(struct snd_card *card,
 	return 0;
 }
 
-static int __devinit amd7930_attach_common(struct resource *rp, int irq)
+static int __devinit amd7930_sbus_probe(struct of_device *op, const struct of_device_id *match)
 {
+	struct resource *rp = &op->resource[0];
 	static int dev_num;
 	struct snd_card *card;
 	struct snd_amd7930 *amd;
-	int err;
+	int err, irq;
+
+	irq = op->irqs[0];
 
 	if (dev_num >= SNDRV_CARDS)
 		return -ENODEV;
@@ -1038,8 +1045,7 @@ static int __devinit amd7930_attach_common(struct resource *rp, int irq)
 		(unsigned long long)rp->start,
 		irq);
 
-	if ((err = snd_amd7930_create(card, rp,
-				      (rp->end - rp->start) + 1,
+	if ((err = snd_amd7930_create(card, op,
 				      irq, dev_num, &amd)) < 0)
 		goto out_err;
 
@@ -1064,42 +1070,6 @@ static int __devinit amd7930_attach_common(struct resource *rp, int irq)
 	return err;
 }
 
-static int __devinit amd7930_obio_attach(struct device_node *dp)
-{
-	const struct linux_prom_registers *regs;
-	const struct linux_prom_irqs *irqp;
-	struct resource res, *rp;
-	int len;
-
-	irqp = of_get_property(dp, "intr", &len);
-	if (!irqp) {
-		snd_printk("%s: Firmware node lacks IRQ property.\n",
-			   dp->full_name);
-		return -ENODEV;
-	}
-
-	regs = of_get_property(dp, "reg", &len);
-	if (!regs) {
-		snd_printk("%s: Firmware node lacks register property.\n",
-			   dp->full_name);
-		return -ENODEV;
-	}
-
-	rp = &res;
-	rp->start = regs->phys_addr;
-	rp->end = rp->start + regs->reg_size - 1;
-	rp->flags = IORESOURCE_IO | (regs->which_io & 0xff);
-
-	return amd7930_attach_common(rp, irqp->pri);
-}
-
-static int __devinit amd7930_sbus_probe(struct of_device *dev, const struct of_device_id *match)
-{
-	struct sbus_dev *sdev = to_sbus_device(&dev->dev);
-
-	return amd7930_attach_common(&sdev->resource[0], sdev->irqs[0]);
-}
-
 static struct of_device_id amd7930_match[] = {
 	{
 		.name = "audio",
@@ -1115,20 +1085,7 @@ static struct of_platform_driver amd7930_sbus_driver = {
 
 static int __init amd7930_init(void)
 {
-	struct device_node *dp;
-
-	/* Try to find the sun4c "audio" node first. */
-	dp = of_find_node_by_path("/");
-	dp = dp->child;
-	while (dp) {
-		if (!strcmp(dp->name, "audio"))
-			amd7930_obio_attach(dp);
-
-		dp = dp->sibling;
-	}
-
-	/* Probe each SBUS for amd7930 chips. */
-	return of_register_driver(&amd7930_sbus_driver, &sbus_bus_type);
+	return of_register_driver(&amd7930_sbus_driver, &of_bus_type);
 }
 
 static void __exit amd7930_exit(void)

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 0c63e0585b15..49acee0c4840 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -765,7 +765,6 @@ static int __devinit snd_amd7930_pcm(struct snd_amd7930 *amd)
 			       /* playback count */ 1,
 			       /* capture count */  1, &pcm)) < 0)
 		return err;
-	snd_assert(pcm != NULL, return -EINVAL);
 
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_amd7930_playback_ops);
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_amd7930_capture_ops);
@@ -788,13 +787,6 @@ static int __devinit snd_amd7930_pcm(struct snd_amd7930 *amd)
 
 static int snd_amd7930_info_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem_info *uinfo)
 {
-	int type = kctl->private_value;
-
-	snd_assert(type == VOLUME_MONITOR ||
-		   type == VOLUME_CAPTURE ||
-		   type == VOLUME_PLAYBACK, return -EINVAL);
-	(void) type;
-
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
 	uinfo->value.integer.min = 0;
@@ -809,10 +801,6 @@ static int snd_amd7930_get_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem
 	int type = kctl->private_value;
 	int *swval;
 
-	snd_assert(type == VOLUME_MONITOR ||
-		   type == VOLUME_CAPTURE ||
-		   type == VOLUME_PLAYBACK, return -EINVAL);
-
 	switch (type) {
 	case VOLUME_MONITOR:
 		swval = &amd->mgain;
@@ -838,10 +826,6 @@ static int snd_amd7930_put_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem
 	int type = kctl->private_value;
 	int *swval, change;
 
-	snd_assert(type == VOLUME_MONITOR ||
-		   type == VOLUME_CAPTURE ||
-		   type == VOLUME_PLAYBACK, return -EINVAL);
-
 	switch (type) {
 	case VOLUME_MONITOR:
 		swval = &amd->mgain;
@@ -904,7 +888,8 @@ static int __devinit snd_amd7930_mixer(struct snd_amd7930 *amd)
 	struct snd_card *card;
 	int idx, err;
 
-	snd_assert(amd != NULL && amd->card != NULL, return -EINVAL);
+	if (snd_BUG_ON(!amd || !amd->card))
+		return -EINVAL;
 
 	card = amd->card;
 	strcpy(card->mixername, card->shortname);

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index b1d431587158..0c63e0585b15 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -36,7 +36,6 @@
 #include <linux/interrupt.h>
 #include <linux/moduleparam.h>
 
-#include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/info.h>

commit 3b892467786410f26dffc2c7bccd3ea445604037
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 15 16:17:24 2007 +0100

    [ALSA] Check value range in ctl callbacks
    
    Check the value ranges in ctl put callbacks properly (in the rest drivers).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 07962a35f241..b1d431587158 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -859,7 +859,7 @@ static int snd_amd7930_put_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem
 	spin_lock_irqsave(&amd->lock, flags);
 
 	if (*swval != ucontrol->value.integer.value[0]) {
-		*swval = ucontrol->value.integer.value[0];
+		*swval = ucontrol->value.integer.value[0] & 0xff;
 		__amd7930_update_map(amd);
 		change = 1;
 	} else

commit 3198514d2d10fb3ce5e49ba0c611764ad8a214d0
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Mar 29 00:50:57 2007 -0700

    [SPARC/64] constify of_get_property return: sound
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index c899786f30f5..07962a35f241 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1067,8 +1067,8 @@ static int __devinit amd7930_attach_common(struct resource *rp, int irq)
 
 static int __devinit amd7930_obio_attach(struct device_node *dp)
 {
-	struct linux_prom_registers *regs;
-	struct linux_prom_irqs *irqp;
+	const struct linux_prom_registers *regs;
+	const struct linux_prom_irqs *irqp;
 	struct resource res, *rp;
 	int len;
 

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index be0bd503f013..c899786f30f5 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -491,7 +491,7 @@ static void __amd7930_update_map(struct snd_amd7930 *amd)
 	__amd7930_write_map(amd);
 }
 
-static irqreturn_t snd_amd7930_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_amd7930_interrupt(int irq, void *dev_id)
 {
 	struct snd_amd7930 *amd = dev_id;
 	unsigned int elapsed;

commit be5b6d3d6cb7311893c9fbeebf094591d5f760a8
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Mon Sep 25 14:08:37 2006 -0700

    [SOUND] sparc/amd7930: Use __devinit and __devinitdata as needed.
    
    Fixes section-mismatch errors.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 2bd8e40b8541..be0bd503f013 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -755,7 +755,7 @@ static struct snd_pcm_ops snd_amd7930_capture_ops = {
 	.pointer	=	snd_amd7930_capture_pointer,
 };
 
-static int __init snd_amd7930_pcm(struct snd_amd7930 *amd)
+static int __devinit snd_amd7930_pcm(struct snd_amd7930 *amd)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -870,7 +870,7 @@ static int snd_amd7930_put_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem
 	return change;
 }
 
-static struct snd_kcontrol_new amd7930_controls[] __initdata = {
+static struct snd_kcontrol_new amd7930_controls[] __devinitdata = {
 	{
 		.iface		=	SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name		=	"Monitor Volume",
@@ -900,7 +900,7 @@ static struct snd_kcontrol_new amd7930_controls[] __initdata = {
 	},
 };
 
-static int __init snd_amd7930_mixer(struct snd_amd7930 *amd)
+static int __devinit snd_amd7930_mixer(struct snd_amd7930 *amd)
 {
 	struct snd_card *card;
 	int idx, err;
@@ -945,11 +945,11 @@ static struct snd_device_ops snd_amd7930_dev_ops = {
 	.dev_free	=	snd_amd7930_dev_free,
 };
 
-static int __init snd_amd7930_create(struct snd_card *card,
-				     struct resource *rp,
-				     unsigned int reg_size,
-				     int irq, int dev,
-				     struct snd_amd7930 **ramd)
+static int __devinit snd_amd7930_create(struct snd_card *card,
+					struct resource *rp,
+					unsigned int reg_size,
+					int irq, int dev,
+					struct snd_amd7930 **ramd)
 {
 	unsigned long flags;
 	struct snd_amd7930 *amd;
@@ -1013,7 +1013,7 @@ static int __init snd_amd7930_create(struct snd_card *card,
 	return 0;
 }
 
-static int __init amd7930_attach_common(struct resource *rp, int irq)
+static int __devinit amd7930_attach_common(struct resource *rp, int irq)
 {
 	static int dev_num;
 	struct snd_card *card;
@@ -1065,7 +1065,7 @@ static int __init amd7930_attach_common(struct resource *rp, int irq)
 	return err;
 }
 
-static int __init amd7930_obio_attach(struct device_node *dp)
+static int __devinit amd7930_obio_attach(struct device_node *dp)
 {
 	struct linux_prom_registers *regs;
 	struct linux_prom_irqs *irqp;

commit 5863aa651bd79a6bb15972894306923db088e71c
Author: Andrew Morton <akpm@osdl.org>
Date:   Mon Jul 3 00:24:22 2006 -0700

    [PATCH] sparc: resource warning fix
    
    sound/sparc/amd7930.c: In function 'amd7930_attach_common':
    sound/sparc/amd7930.c:1040: warning: format '%08lx' expects type 'long unsigned int', but argument 5 has type 'resource_size_t'
    
    sound/sparc/cs4231.c:2043: warning: format '%016lx' expects type 'long unsigned int', but argument 5 has type 'resource_size_t'
    
    sound/sparc/dbri.c: In function 'dbri_attach':
    sound/sparc/dbri.c:2650: warning: format '%016lx' expects type 'long unsigned int', but argument 5 has type 'resource_size_t'
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index db3e22efd02e..2bd8e40b8541 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1033,10 +1033,10 @@ static int __init amd7930_attach_common(struct resource *rp, int irq)
 
 	strcpy(card->driver, "AMD7930");
 	strcpy(card->shortname, "Sun AMD7930");
-	sprintf(card->longname, "%s at 0x%02lx:0x%08lx, irq %d",
+	sprintf(card->longname, "%s at 0x%02lx:0x%08Lx, irq %d",
 		card->shortname,
 		rp->flags & 0xffL,
-		rp->start,
+		(unsigned long long)rp->start,
 		irq);
 
 	if ((err = snd_amd7930_create(card, rp,

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index ba1b2a3443d3..db3e22efd02e 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -973,7 +973,7 @@ static int __init snd_amd7930_create(struct snd_card *card,
 	amd7930_idle(amd);
 
 	if (request_irq(irq, snd_amd7930_interrupt,
-			SA_INTERRUPT | SA_SHIRQ, "amd7930", amd)) {
+			IRQF_DISABLED | IRQF_SHARED, "amd7930", amd)) {
 		snd_printk("amd7930-%d: Unable to grab IRQ %d\n",
 			   dev, irq);
 		snd_amd7930_free(amd);

commit 69b5c4f18b2ceab3da9e854d02f8d9a2aa5b8431
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Fri Jun 23 16:23:12 2006 -0700

    [SOUND] sparc: Port amd7930 to new SBUS device layer.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index dfe9bac7fa32..ba1b2a3443d3 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -46,6 +46,7 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/sbus.h>
+#include <asm/prom.h>
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
@@ -335,7 +336,6 @@ struct snd_amd7930 {
 	int			pgain;
 	int			mgain;
 
-	struct sbus_dev		*sdev;
 	unsigned int		irq;
 	unsigned int		regs_size;
 	struct snd_amd7930	*next;
@@ -946,11 +946,9 @@ static struct snd_device_ops snd_amd7930_dev_ops = {
 };
 
 static int __init snd_amd7930_create(struct snd_card *card,
-				     struct sbus_dev *sdev,
 				     struct resource *rp,
 				     unsigned int reg_size,
-				     struct linux_prom_irqs *irq_prop,
-				     int dev,
+				     int irq, int dev,
 				     struct snd_amd7930 **ramd)
 {
 	unsigned long flags;
@@ -964,7 +962,6 @@ static int __init snd_amd7930_create(struct snd_card *card,
 
 	spin_lock_init(&amd->lock);
 	amd->card = card;
-	amd->sdev = sdev;
 	amd->regs_size = reg_size;
 
 	amd->regs = sbus_ioremap(rp, 0, amd->regs_size, "amd7930");
@@ -975,15 +972,14 @@ static int __init snd_amd7930_create(struct snd_card *card,
 
 	amd7930_idle(amd);
 
-	if (request_irq(irq_prop->pri, snd_amd7930_interrupt,
+	if (request_irq(irq, snd_amd7930_interrupt,
 			SA_INTERRUPT | SA_SHIRQ, "amd7930", amd)) {
 		snd_printk("amd7930-%d: Unable to grab IRQ %d\n",
-			   dev,
-			   irq_prop->pri);
+			   dev, irq);
 		snd_amd7930_free(amd);
 		return -EBUSY;
 	}
-	amd->irq = irq_prop->pri;
+	amd->irq = irq;
 
 	amd7930_enable_ints(amd);
 
@@ -1017,47 +1013,21 @@ static int __init snd_amd7930_create(struct snd_card *card,
 	return 0;
 }
 
-static int __init amd7930_attach(int prom_node, struct sbus_dev *sdev)
+static int __init amd7930_attach_common(struct resource *rp, int irq)
 {
-	static int dev;
-	struct linux_prom_registers reg_prop;
-	struct linux_prom_irqs irq_prop;
-	struct resource res, *rp;
+	static int dev_num;
 	struct snd_card *card;
 	struct snd_amd7930 *amd;
 	int err;
 
-	if (dev >= SNDRV_CARDS)
+	if (dev_num >= SNDRV_CARDS)
 		return -ENODEV;
-	if (!enable[dev]) {
-		dev++;
+	if (!enable[dev_num]) {
+		dev_num++;
 		return -ENOENT;
 	}
 
-	err = prom_getproperty(prom_node, "intr",
-			       (char *) &irq_prop, sizeof(irq_prop));
-	if (err < 0) {
-		snd_printk("amd7930-%d: Firmware node lacks IRQ property.\n", dev);
-		return -ENODEV;
-	}
-
-	err = prom_getproperty(prom_node, "reg",
-			       (char *) &reg_prop, sizeof(reg_prop));
-	if (err < 0) {
-		snd_printk("amd7930-%d: Firmware node lacks register property.\n", dev);
-		return -ENODEV;
-	}
-
-	if (sdev) {
-		rp = &sdev->resource[0];
-	} else {
-		rp = &res;
-		rp->start = reg_prop.phys_addr;
-		rp->end = rp->start + reg_prop.reg_size - 1;
-		rp->flags = IORESOURCE_IO | (reg_prop.which_io & 0xff);
-	}
-
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	card = snd_card_new(index[dev_num], id[dev_num], THIS_MODULE, 0);
 	if (card == NULL)
 		return -ENOMEM;
 
@@ -1067,10 +1037,11 @@ static int __init amd7930_attach(int prom_node, struct sbus_dev *sdev)
 		card->shortname,
 		rp->flags & 0xffL,
 		rp->start,
-		irq_prop.pri);
+		irq);
 
-	if ((err = snd_amd7930_create(card, sdev, rp, reg_prop.reg_size,
-					  &irq_prop, dev, &amd)) < 0)
+	if ((err = snd_amd7930_create(card, rp,
+				      (rp->end - rp->start) + 1,
+				      irq, dev_num, &amd)) < 0)
 		goto out_err;
 
 	if ((err = snd_amd7930_pcm(amd)) < 0)
@@ -1085,7 +1056,8 @@ static int __init amd7930_attach(int prom_node, struct sbus_dev *sdev)
 	amd->next = amd7930_list;
 	amd7930_list = amd;
 
-	dev++;
+	dev_num++;
+
 	return 0;
 
 out_err:
@@ -1093,29 +1065,71 @@ static int __init amd7930_attach(int prom_node, struct sbus_dev *sdev)
 	return err;
 }
 
-static int __init amd7930_init(void)
+static int __init amd7930_obio_attach(struct device_node *dp)
+{
+	struct linux_prom_registers *regs;
+	struct linux_prom_irqs *irqp;
+	struct resource res, *rp;
+	int len;
+
+	irqp = of_get_property(dp, "intr", &len);
+	if (!irqp) {
+		snd_printk("%s: Firmware node lacks IRQ property.\n",
+			   dp->full_name);
+		return -ENODEV;
+	}
+
+	regs = of_get_property(dp, "reg", &len);
+	if (!regs) {
+		snd_printk("%s: Firmware node lacks register property.\n",
+			   dp->full_name);
+		return -ENODEV;
+	}
+
+	rp = &res;
+	rp->start = regs->phys_addr;
+	rp->end = rp->start + regs->reg_size - 1;
+	rp->flags = IORESOURCE_IO | (regs->which_io & 0xff);
+
+	return amd7930_attach_common(rp, irqp->pri);
+}
+
+static int __devinit amd7930_sbus_probe(struct of_device *dev, const struct of_device_id *match)
 {
-	struct sbus_bus *sbus;
-	struct sbus_dev *sdev;
-	int node, found;
+	struct sbus_dev *sdev = to_sbus_device(&dev->dev);
 
-	found = 0;
+	return amd7930_attach_common(&sdev->resource[0], sdev->irqs[0]);
+}
+
+static struct of_device_id amd7930_match[] = {
+	{
+		.name = "audio",
+	},
+	{},
+};
+
+static struct of_platform_driver amd7930_sbus_driver = {
+	.name		= "audio",
+	.match_table	= amd7930_match,
+	.probe		= amd7930_sbus_probe,
+};
+
+static int __init amd7930_init(void)
+{
+	struct device_node *dp;
 
 	/* Try to find the sun4c "audio" node first. */
-	node = prom_getchild(prom_root_node);
-	node = prom_searchsiblings(node, "audio");
-	if (node && amd7930_attach(node, NULL) == 0)
-		found++;
+	dp = of_find_node_by_path("/");
+	dp = dp->child;
+	while (dp) {
+		if (!strcmp(dp->name, "audio"))
+			amd7930_obio_attach(dp);
 
-	/* Probe each SBUS for amd7930 chips. */
-	for_all_sbusdev(sdev, sbus) {
-		if (!strcmp(sdev->prom_name, "audio")) {
-			if (amd7930_attach(sdev->prom_node, sdev) == 0)
-				found++;
-		}
+		dp = dp->sibling;
 	}
 
-	return (found > 0) ? 0 : -EIO;
+	/* Probe each SBUS for amd7930 chips. */
+	return of_register_driver(&amd7930_sbus_driver, &sbus_bus_type);
 }
 
 static void __exit amd7930_exit(void)
@@ -1131,6 +1145,8 @@ static void __exit amd7930_exit(void)
 	}
 
 	amd7930_list = NULL;
+
+	of_unregister_driver(&amd7930_sbus_driver);
 }
 
 module_init(amd7930_init);

commit c6387a48cf5958e43c201fc27a158c328927531a
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jun 20 01:21:29 2006 -0700

    [SPARC]: Kill __irq_itoa().
    
    This ugly hack was long overdue to die.
    
    It was a way to print out Sparc interrupts in a more freindly format,
    since IRQ numbers were arbitrary opaque 32-bit integers which vectored
    into PIL levels.  These 32-bit integers were not necessarily in the
    0-->NR_IRQS range, but the PILs they vectored to were.
    
    The idea now is that we will increase NR_IRQS a little bit and use a
    virtual<-->real IRQ number mapping scheme similar to PowerPC.
    
    That makes this IRQ printing hack irrelevant, and furthermore only a
    handful of drivers actually used __irq_itoa() making it even less
    useful.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 55493340f467..dfe9bac7fa32 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -977,9 +977,9 @@ static int __init snd_amd7930_create(struct snd_card *card,
 
 	if (request_irq(irq_prop->pri, snd_amd7930_interrupt,
 			SA_INTERRUPT | SA_SHIRQ, "amd7930", amd)) {
-		snd_printk("amd7930-%d: Unable to grab IRQ %s\n",
+		snd_printk("amd7930-%d: Unable to grab IRQ %d\n",
 			   dev,
-			   __irq_itoa(irq_prop->pri));
+			   irq_prop->pri);
 		snd_amd7930_free(amd);
 		return -EBUSY;
 	}
@@ -1063,11 +1063,11 @@ static int __init amd7930_attach(int prom_node, struct sbus_dev *sdev)
 
 	strcpy(card->driver, "AMD7930");
 	strcpy(card->shortname, "Sun AMD7930");
-	sprintf(card->longname, "%s at 0x%02lx:0x%08lx, irq %s",
+	sprintf(card->longname, "%s at 0x%02lx:0x%08lx, irq %d",
 		card->shortname,
 		rp->flags & 0xffL,
 		rp->start,
-		__irq_itoa(irq_prop.pri));
+		irq_prop.pri);
 
 	if ((err = snd_amd7930_create(card, sdev, rp, reg_prop.reg_size,
 					  &irq_prop, dev, &amd)) < 0)

commit ebfbd2b83da14c7118da0efd1b59d8b641da08c2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 17:21:46 2005 +0100

    [ALSA] Remove snd_card_generic_dev()
    
    Remove the obsolete snd_card_generic_dev().
    CONFIG_SND_GENERIC_DRIVER is also removed from Kconfig.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index c2710499b83a..55493340f467 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1079,9 +1079,6 @@ static int __init amd7930_attach(int prom_node, struct sbus_dev *sdev)
 	if ((err = snd_amd7930_mixer(amd)) < 0)
 		goto out_err;
 
-	if ((err = snd_card_set_generic_dev(card)) < 0)
-		goto out_err;
-
 	if ((err = snd_card_register(card)) < 0)
 		goto out_err;
 

commit dcc94db78362759931ff538f1579d4a1cec8bd64
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:11:19 2005 +0100

    [ALSA] Remove xxx_t typedefs: SPARC AMD7930
    
    Modules: SPARC AMD7930 driver
    
    Remove xxx_t typedefs from the SPARC AMD7930 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 7d4b6855bac0..c2710499b83a 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -311,7 +311,7 @@ struct amd7930_map {
 #define	AMR_PP_PPCR2			0xC8
 #define	AMR_PP_PPCR3			0xC9
 
-typedef struct snd_amd7930 {
+struct snd_amd7930 {
 	spinlock_t		lock;
 	void __iomem		*regs;
 	u32			flags;
@@ -320,10 +320,10 @@ typedef struct snd_amd7930 {
 
 	struct amd7930_map	map;
 
-	snd_card_t		*card;
-	snd_pcm_t		*pcm;
-	snd_pcm_substream_t	*playback_substream;
-	snd_pcm_substream_t	*capture_substream;
+	struct snd_card		*card;
+	struct snd_pcm		*pcm;
+	struct snd_pcm_substream	*playback_substream;
+	struct snd_pcm_substream	*capture_substream;
 
 	/* Playback/Capture buffer state. */
 	unsigned char		*p_orig, *p_cur;
@@ -339,12 +339,12 @@ typedef struct snd_amd7930 {
 	unsigned int		irq;
 	unsigned int		regs_size;
 	struct snd_amd7930	*next;
-} amd7930_t;
+};
 
-static amd7930_t *amd7930_list;
+static struct snd_amd7930 *amd7930_list;
 
 /* Idle the AMD7930 chip.  The amd->lock is not held.  */
-static __inline__ void amd7930_idle(amd7930_t *amd)
+static __inline__ void amd7930_idle(struct snd_amd7930 *amd)
 {
 	unsigned long flags;
 
@@ -355,7 +355,7 @@ static __inline__ void amd7930_idle(amd7930_t *amd)
 }
 
 /* Enable chip interrupts.  The amd->lock is not held.  */
-static __inline__ void amd7930_enable_ints(amd7930_t *amd)
+static __inline__ void amd7930_enable_ints(struct snd_amd7930 *amd)
 {
 	unsigned long flags;
 
@@ -366,7 +366,7 @@ static __inline__ void amd7930_enable_ints(amd7930_t *amd)
 }
 
 /* Disable chip interrupts.  The amd->lock is not held.  */
-static __inline__ void amd7930_disable_ints(amd7930_t *amd)
+static __inline__ void amd7930_disable_ints(struct snd_amd7930 *amd)
 {
 	unsigned long flags;
 
@@ -379,7 +379,7 @@ static __inline__ void amd7930_disable_ints(amd7930_t *amd)
 /* Commit amd7930_map settings to the hardware.
  * The amd->lock is held and local interrupts are disabled.
  */
-static void __amd7930_write_map(amd7930_t *amd)
+static void __amd7930_write_map(struct snd_amd7930 *amd)
 {
 	struct amd7930_map *map = &amd->map;
 
@@ -473,7 +473,7 @@ static __const__ __u16 ger_coeff[] = {
 /* Update amd7930_map settings and program them into the hardware.
  * The amd->lock is held and local interrupts are disabled.
  */
-static void __amd7930_update_map(amd7930_t *amd)
+static void __amd7930_update_map(struct snd_amd7930 *amd)
 {
 	struct amd7930_map *map = &amd->map;
 	int level;
@@ -493,7 +493,7 @@ static void __amd7930_update_map(amd7930_t *amd)
 
 static irqreturn_t snd_amd7930_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	amd7930_t *amd = dev_id;
+	struct snd_amd7930 *amd = dev_id;
 	unsigned int elapsed;
 	u8 ir;
 
@@ -534,7 +534,7 @@ static irqreturn_t snd_amd7930_interrupt(int irq, void *dev_id, struct pt_regs *
 	return IRQ_HANDLED;
 }
 
-static int snd_amd7930_trigger(amd7930_t *amd, unsigned int flag, int cmd)
+static int snd_amd7930_trigger(struct snd_amd7930 *amd, unsigned int flag, int cmd)
 {
 	unsigned long flags;
 	int result = 0;
@@ -564,24 +564,24 @@ static int snd_amd7930_trigger(amd7930_t *amd, unsigned int flag, int cmd)
 	return result;
 }
 
-static int snd_amd7930_playback_trigger(snd_pcm_substream_t * substream,
+static int snd_amd7930_playback_trigger(struct snd_pcm_substream *substream,
 					int cmd)
 {
-	amd7930_t *amd = snd_pcm_substream_chip(substream);
+	struct snd_amd7930 *amd = snd_pcm_substream_chip(substream);
 	return snd_amd7930_trigger(amd, AMD7930_FLAG_PLAYBACK, cmd);
 }
 
-static int snd_amd7930_capture_trigger(snd_pcm_substream_t * substream,
+static int snd_amd7930_capture_trigger(struct snd_pcm_substream *substream,
 				       int cmd)
 {
-	amd7930_t *amd = snd_pcm_substream_chip(substream);
+	struct snd_amd7930 *amd = snd_pcm_substream_chip(substream);
 	return snd_amd7930_trigger(amd, AMD7930_FLAG_CAPTURE, cmd);
 }
 
-static int snd_amd7930_playback_prepare(snd_pcm_substream_t * substream)
+static int snd_amd7930_playback_prepare(struct snd_pcm_substream *substream)
 {
-	amd7930_t *amd = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_amd7930 *amd = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned int size = snd_pcm_lib_buffer_bytes(substream);
 	unsigned long flags;
 	u8 new_mmr1;
@@ -610,10 +610,10 @@ static int snd_amd7930_playback_prepare(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_amd7930_capture_prepare(snd_pcm_substream_t * substream)
+static int snd_amd7930_capture_prepare(struct snd_pcm_substream *substream)
 {
-	amd7930_t *amd = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_amd7930 *amd = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned int size = snd_pcm_lib_buffer_bytes(substream);
 	unsigned long flags;
 	u8 new_mmr1;
@@ -642,9 +642,9 @@ static int snd_amd7930_capture_prepare(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static snd_pcm_uframes_t snd_amd7930_playback_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_amd7930_playback_pointer(struct snd_pcm_substream *substream)
 {
-	amd7930_t *amd = snd_pcm_substream_chip(substream);
+	struct snd_amd7930 *amd = snd_pcm_substream_chip(substream);
 	size_t ptr;
 
 	if (!(amd->flags & AMD7930_FLAG_PLAYBACK))
@@ -653,9 +653,9 @@ static snd_pcm_uframes_t snd_amd7930_playback_pointer(snd_pcm_substream_t * subs
 	return bytes_to_frames(substream->runtime, ptr);
 }
 
-static snd_pcm_uframes_t snd_amd7930_capture_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_amd7930_capture_pointer(struct snd_pcm_substream *substream)
 {
-	amd7930_t *amd = snd_pcm_substream_chip(substream);
+	struct snd_amd7930 *amd = snd_pcm_substream_chip(substream);
 	size_t ptr;
 
 	if (!(amd->flags & AMD7930_FLAG_CAPTURE))
@@ -666,7 +666,7 @@ static snd_pcm_uframes_t snd_amd7930_capture_pointer(snd_pcm_substream_t * subst
 }
 
 /* Playback and capture have identical properties.  */
-static snd_pcm_hardware_t snd_amd7930_pcm_hw =
+static struct snd_pcm_hardware snd_amd7930_pcm_hw =
 {
 	.info			= (SNDRV_PCM_INFO_MMAP |
 				   SNDRV_PCM_INFO_MMAP_VALID |
@@ -686,54 +686,54 @@ static snd_pcm_hardware_t snd_amd7930_pcm_hw =
 	.periods_max		= 1024,
 };
 
-static int snd_amd7930_playback_open(snd_pcm_substream_t * substream)
+static int snd_amd7930_playback_open(struct snd_pcm_substream *substream)
 {
-	amd7930_t *amd = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_amd7930 *amd = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	amd->playback_substream = substream;
 	runtime->hw = snd_amd7930_pcm_hw;
 	return 0;
 }
 
-static int snd_amd7930_capture_open(snd_pcm_substream_t * substream)
+static int snd_amd7930_capture_open(struct snd_pcm_substream *substream)
 {
-	amd7930_t *amd = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_amd7930 *amd = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	amd->capture_substream = substream;
 	runtime->hw = snd_amd7930_pcm_hw;
 	return 0;
 }
 
-static int snd_amd7930_playback_close(snd_pcm_substream_t * substream)
+static int snd_amd7930_playback_close(struct snd_pcm_substream *substream)
 {
-	amd7930_t *amd = snd_pcm_substream_chip(substream);
+	struct snd_amd7930 *amd = snd_pcm_substream_chip(substream);
 
 	amd->playback_substream = NULL;
 	return 0;
 }
 
-static int snd_amd7930_capture_close(snd_pcm_substream_t * substream)
+static int snd_amd7930_capture_close(struct snd_pcm_substream *substream)
 {
-	amd7930_t *amd = snd_pcm_substream_chip(substream);
+	struct snd_amd7930 *amd = snd_pcm_substream_chip(substream);
 
 	amd->capture_substream = NULL;
 	return 0;
 }
 
-static int snd_amd7930_hw_params(snd_pcm_substream_t * substream,
-				    snd_pcm_hw_params_t * hw_params)
+static int snd_amd7930_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *hw_params)
 {
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 }
 
-static int snd_amd7930_hw_free(snd_pcm_substream_t * substream)
+static int snd_amd7930_hw_free(struct snd_pcm_substream *substream)
 {
 	return snd_pcm_lib_free_pages(substream);
 }
 
-static snd_pcm_ops_t snd_amd7930_playback_ops = {
+static struct snd_pcm_ops snd_amd7930_playback_ops = {
 	.open		=	snd_amd7930_playback_open,
 	.close		=	snd_amd7930_playback_close,
 	.ioctl		=	snd_pcm_lib_ioctl,
@@ -744,7 +744,7 @@ static snd_pcm_ops_t snd_amd7930_playback_ops = {
 	.pointer	=	snd_amd7930_playback_pointer,
 };
 
-static snd_pcm_ops_t snd_amd7930_capture_ops = {
+static struct snd_pcm_ops snd_amd7930_capture_ops = {
 	.open		=	snd_amd7930_capture_open,
 	.close		=	snd_amd7930_capture_close,
 	.ioctl		=	snd_pcm_lib_ioctl,
@@ -755,9 +755,9 @@ static snd_pcm_ops_t snd_amd7930_capture_ops = {
 	.pointer	=	snd_amd7930_capture_pointer,
 };
 
-static int __init snd_amd7930_pcm(amd7930_t *amd)
+static int __init snd_amd7930_pcm(struct snd_amd7930 *amd)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	if ((err = snd_pcm_new(amd->card,
@@ -787,7 +787,7 @@ static int __init snd_amd7930_pcm(amd7930_t *amd)
 #define VOLUME_CAPTURE	1
 #define VOLUME_PLAYBACK	2
 
-static int snd_amd7930_info_volume(snd_kcontrol_t *kctl, snd_ctl_elem_info_t *uinfo)
+static int snd_amd7930_info_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem_info *uinfo)
 {
 	int type = kctl->private_value;
 
@@ -804,9 +804,9 @@ static int snd_amd7930_info_volume(snd_kcontrol_t *kctl, snd_ctl_elem_info_t *ui
 	return 0;
 }
 
-static int snd_amd7930_get_volume(snd_kcontrol_t *kctl, snd_ctl_elem_value_t *ucontrol)
+static int snd_amd7930_get_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
 {
-	amd7930_t *amd = snd_kcontrol_chip(kctl);
+	struct snd_amd7930 *amd = snd_kcontrol_chip(kctl);
 	int type = kctl->private_value;
 	int *swval;
 
@@ -832,9 +832,9 @@ static int snd_amd7930_get_volume(snd_kcontrol_t *kctl, snd_ctl_elem_value_t *uc
 	return 0;
 }
 
-static int snd_amd7930_put_volume(snd_kcontrol_t *kctl, snd_ctl_elem_value_t *ucontrol)
+static int snd_amd7930_put_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)
 {
-	amd7930_t *amd = snd_kcontrol_chip(kctl);
+	struct snd_amd7930 *amd = snd_kcontrol_chip(kctl);
 	unsigned long flags;
 	int type = kctl->private_value;
 	int *swval, change;
@@ -870,7 +870,7 @@ static int snd_amd7930_put_volume(snd_kcontrol_t *kctl, snd_ctl_elem_value_t *uc
 	return change;
 }
 
-static snd_kcontrol_new_t amd7930_controls[] __initdata = {
+static struct snd_kcontrol_new amd7930_controls[] __initdata = {
 	{
 		.iface		=	SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name		=	"Monitor Volume",
@@ -900,9 +900,9 @@ static snd_kcontrol_new_t amd7930_controls[] __initdata = {
 	},
 };
 
-static int __init snd_amd7930_mixer(amd7930_t *amd)
+static int __init snd_amd7930_mixer(struct snd_amd7930 *amd)
 {
-	snd_card_t *card;
+	struct snd_card *card;
 	int idx, err;
 
 	snd_assert(amd != NULL && amd->card != NULL, return -EINVAL);
@@ -919,7 +919,7 @@ static int __init snd_amd7930_mixer(amd7930_t *amd)
 	return 0;
 }
 
-static int snd_amd7930_free(amd7930_t *amd)
+static int snd_amd7930_free(struct snd_amd7930 *amd)
 {
 	amd7930_idle(amd);
 
@@ -934,27 +934,27 @@ static int snd_amd7930_free(amd7930_t *amd)
 	return 0;
 }
 
-static int snd_amd7930_dev_free(snd_device_t *device)
+static int snd_amd7930_dev_free(struct snd_device *device)
 {
-	amd7930_t *amd = device->device_data;
+	struct snd_amd7930 *amd = device->device_data;
 
 	return snd_amd7930_free(amd);
 }
 
-static snd_device_ops_t snd_amd7930_dev_ops = {
+static struct snd_device_ops snd_amd7930_dev_ops = {
 	.dev_free	=	snd_amd7930_dev_free,
 };
 
-static int __init snd_amd7930_create(snd_card_t *card,
+static int __init snd_amd7930_create(struct snd_card *card,
 				     struct sbus_dev *sdev,
 				     struct resource *rp,
 				     unsigned int reg_size,
 				     struct linux_prom_irqs *irq_prop,
 				     int dev,
-				     amd7930_t **ramd)
+				     struct snd_amd7930 **ramd)
 {
 	unsigned long flags;
-	amd7930_t *amd;
+	struct snd_amd7930 *amd;
 	int err;
 
 	*ramd = NULL;
@@ -1023,8 +1023,8 @@ static int __init amd7930_attach(int prom_node, struct sbus_dev *sdev)
 	struct linux_prom_registers reg_prop;
 	struct linux_prom_irqs irq_prop;
 	struct resource res, *rp;
-	snd_card_t *card;
-	amd7930_t *amd;
+	struct snd_card *card;
+	struct snd_amd7930 *amd;
 	int err;
 
 	if (dev >= SNDRV_CARDS)
@@ -1123,10 +1123,10 @@ static int __init amd7930_init(void)
 
 static void __exit amd7930_exit(void)
 {
-	amd7930_t *p = amd7930_list;
+	struct snd_amd7930 *p = amd7930_list;
 
 	while (p != NULL) {
-		amd7930_t *next = p->next;
+		struct snd_amd7930 *next = p->next;
 
 		snd_card_free(p->card);
 

commit c3e6f7d8763fa0400d28c57633eb323515ba05fc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 16 18:43:35 2005 +0100

    [ALSA] Remove superfluous pcm_free callbacks
    
    Remove superflous pcm_free callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index 46d504ba7e03..7d4b6855bac0 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -755,14 +755,6 @@ static snd_pcm_ops_t snd_amd7930_capture_ops = {
 	.pointer	=	snd_amd7930_capture_pointer,
 };
 
-static void snd_amd7930_pcm_free(snd_pcm_t *pcm)
-{
-	amd7930_t *amd = pcm->private_data;
-
-	amd->pcm = NULL;
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
 static int __init snd_amd7930_pcm(amd7930_t *amd)
 {
 	snd_pcm_t *pcm;
@@ -780,7 +772,6 @@ static int __init snd_amd7930_pcm(amd7930_t *amd)
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_amd7930_capture_ops);
 
 	pcm->private_data = amd;
-	pcm->private_free = snd_amd7930_pcm_free;
 	pcm->info_flags = 0;
 	strcpy(pcm->name, amd->card->shortname);
 	amd->pcm = pcm;

commit 561b220a4dece18d67177413e6fa21b49aa4acce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:22:34 2005 +0200

    [ALSA] Replace with kzalloc() - others
    
    Documentation,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,OPL3
    OPL4,Digigram VX core,I2C cs8427,I2C lib core,I2C tea6330t,L3 drivers
    AK4114 receiver,AK4117 receiver,PDAudioCF driver,PPC PMAC driver
    SPARC AMD7930 driver,SPARC cs4231 driver,Synth,Common EMU synth
    USB generic driver,USB USX2Y
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index ed0d5f2f0888..46d504ba7e03 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -967,7 +967,7 @@ static int __init snd_amd7930_create(snd_card_t *card,
 	int err;
 
 	*ramd = NULL;
-	amd = kcalloc(1, sizeof(*amd), GFP_KERNEL);
+	amd = kzalloc(sizeof(*amd), GFP_KERNEL);
 	if (amd == NULL)
 		return -ENOMEM;
 

commit 16dab54b8cbac39bd3f639db5d7d0fd8300a6cb0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 5 17:17:58 2005 +0200

    [ALSA] Add snd_card_set_generic_dev() call
    
    ARM,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,MIPS
    MIPS AU1x00 driver,PPC,PPC PowerMac driver,SPARC,SPARC AMD7930 driver
    SPARC cs4231 driver,SPARC DBRI driver
    - Added snd_card_set_generic_dev() call.
    - Added SND_GENERIC_DRIVER to Kconfig.
    - Clean up the error path in probe if necessary.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
index bd8a850e93ea..ed0d5f2f0888 100644
--- a/sound/sparc/amd7930.c
+++ b/sound/sparc/amd7930.c
@@ -1088,6 +1088,9 @@ static int __init amd7930_attach(int prom_node, struct sbus_dev *sdev)
 	if ((err = snd_amd7930_mixer(amd)) < 0)
 		goto out_err;
 
+	if ((err = snd_card_set_generic_dev(card)) < 0)
+		goto out_err;
+
 	if ((err = snd_card_register(card)) < 0)
 		goto out_err;
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/sparc/amd7930.c b/sound/sparc/amd7930.c
new file mode 100644
index 000000000000..bd8a850e93ea
--- /dev/null
+++ b/sound/sparc/amd7930.c
@@ -0,0 +1,1146 @@
+/*
+ * Driver for AMD7930 sound chips found on Sparcs.
+ * Copyright (C) 2002 David S. Miller <davem@redhat.com>
+ *
+ * Based entirely upon drivers/sbus/audio/amd7930.c which is:
+ * Copyright (C) 1996,1997 Thomas K. Dyas (tdyas@eden.rutgers.edu)
+ *
+ * --- Notes from Thomas's original driver ---
+ * This is the lowlevel driver for the AMD7930 audio chip found on all
+ * sun4c machines and some sun4m machines.
+ *
+ * The amd7930 is actually an ISDN chip which has a very simple
+ * integrated audio encoder/decoder. When Sun decided on what chip to
+ * use for audio, they had the brilliant idea of using the amd7930 and
+ * only connecting the audio encoder/decoder pins.
+ *
+ * Thanks to the AMD engineer who was able to get us the AMD79C30
+ * databook which has all the programming information and gain tables.
+ *
+ * Advanced Micro Devices' Am79C30A is an ISDN/audio chip used in the
+ * SparcStation 1+.  The chip provides microphone and speaker interfaces
+ * which provide mono-channel audio at 8K samples per second via either
+ * 8-bit A-law or 8-bit mu-law encoding.  Also, the chip features an
+ * ISDN BRI Line Interface Unit (LIU), I.430 S/T physical interface,
+ * which performs basic D channel LAPD processing and provides raw
+ * B channel data.  The digital audio channel, the two ISDN B channels,
+ * and two 64 Kbps channels to the microprocessor are all interconnected
+ * via a multiplexer.
+ * --- End of notes from Thoamas's original driver ---
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/moduleparam.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/info.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/sbus.h>
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for Sun AMD7930 soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for Sun AMD7930 soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable Sun AMD7930 soundcard.");
+MODULE_AUTHOR("Thomas K. Dyas and David S. Miller");
+MODULE_DESCRIPTION("Sun AMD7930");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{Sun,AMD7930}}");
+
+/* Device register layout.  */
+
+/* Register interface presented to the CPU by the amd7930. */
+#define AMD7930_CR	0x00UL		/* Command Register (W) */
+#define AMD7930_IR	AMD7930_CR	/* Interrupt Register (R) */
+#define AMD7930_DR	0x01UL		/* Data Register (R/W) */
+#define AMD7930_DSR1	0x02UL		/* D-channel Status Register 1 (R) */
+#define AMD7930_DER	0x03UL		/* D-channel Error Register (R) */
+#define AMD7930_DCTB	0x04UL		/* D-channel Transmit Buffer (W) */
+#define AMD7930_DCRB	AMD7930_DCTB	/* D-channel Receive Buffer (R) */
+#define AMD7930_BBTB	0x05UL		/* Bb-channel Transmit Buffer (W) */
+#define AMD7930_BBRB	AMD7930_BBTB	/* Bb-channel Receive Buffer (R) */
+#define AMD7930_BCTB	0x06UL		/* Bc-channel Transmit Buffer (W) */
+#define AMD7930_BCRB	AMD7930_BCTB	/* Bc-channel Receive Buffer (R) */
+#define AMD7930_DSR2	0x07UL		/* D-channel Status Register 2 (R) */
+
+/* Indirect registers in the Main Audio Processor. */
+struct amd7930_map {
+	__u16	x[8];
+	__u16	r[8];
+	__u16	gx;
+	__u16	gr;
+	__u16	ger;
+	__u16	stgr;
+	__u16	ftgr;
+	__u16	atgr;
+	__u8	mmr1;
+	__u8	mmr2;
+};
+
+/* After an amd7930 interrupt, reading the Interrupt Register (ir)
+ * clears the interrupt and returns a bitmask indicating which
+ * interrupt source(s) require service.
+ */
+
+#define AMR_IR_DTTHRSH			0x01 /* D-channel xmit threshold */
+#define AMR_IR_DRTHRSH			0x02 /* D-channel recv threshold */
+#define AMR_IR_DSRI			0x04 /* D-channel packet status */
+#define AMR_IR_DERI			0x08 /* D-channel error */
+#define AMR_IR_BBUF			0x10 /* B-channel data xfer */
+#define AMR_IR_LSRI			0x20 /* LIU status */
+#define AMR_IR_DSR2I			0x40 /* D-channel buffer status */
+#define AMR_IR_MLTFRMI			0x80 /* multiframe or PP */
+
+/* The amd7930 has "indirect registers" which are accessed by writing
+ * the register number into the Command Register and then reading or
+ * writing values from the Data Register as appropriate. We define the
+ * AMR_* macros to be the indirect register numbers and AM_* macros to
+ * be bits in whatever register is referred to.
+ */
+
+/* Initialization */
+#define	AMR_INIT			0x21
+#define		AM_INIT_ACTIVE			0x01
+#define		AM_INIT_DATAONLY		0x02
+#define		AM_INIT_POWERDOWN		0x03
+#define		AM_INIT_DISABLE_INTS		0x04
+#define AMR_INIT2			0x20
+#define		AM_INIT2_ENABLE_POWERDOWN	0x20
+#define		AM_INIT2_ENABLE_MULTIFRAME	0x10
+
+/* Line Interface Unit */
+#define	AMR_LIU_LSR			0xA1
+#define		AM_LIU_LSR_STATE		0x07
+#define		AM_LIU_LSR_F3			0x08
+#define		AM_LIU_LSR_F7			0x10
+#define		AM_LIU_LSR_F8			0x20
+#define		AM_LIU_LSR_HSW			0x40
+#define		AM_LIU_LSR_HSW_CHG		0x80
+#define	AMR_LIU_LPR			0xA2
+#define	AMR_LIU_LMR1			0xA3
+#define		AM_LIU_LMR1_B1_ENABL		0x01
+#define		AM_LIU_LMR1_B2_ENABL		0x02
+#define		AM_LIU_LMR1_F_DISABL		0x04
+#define		AM_LIU_LMR1_FA_DISABL		0x08
+#define		AM_LIU_LMR1_REQ_ACTIV		0x10
+#define		AM_LIU_LMR1_F8_F3		0x20
+#define		AM_LIU_LMR1_LIU_ENABL		0x40
+#define	AMR_LIU_LMR2			0xA4
+#define		AM_LIU_LMR2_DECHO		0x01
+#define		AM_LIU_LMR2_DLOOP		0x02
+#define		AM_LIU_LMR2_DBACKOFF		0x04
+#define		AM_LIU_LMR2_EN_F3_INT		0x08
+#define		AM_LIU_LMR2_EN_F8_INT		0x10
+#define		AM_LIU_LMR2_EN_HSW_INT		0x20
+#define		AM_LIU_LMR2_EN_F7_INT		0x40
+#define	AMR_LIU_2_4			0xA5
+#define	AMR_LIU_MF			0xA6
+#define	AMR_LIU_MFSB			0xA7
+#define	AMR_LIU_MFQB			0xA8
+
+/* Multiplexor */
+#define	AMR_MUX_MCR1			0x41
+#define	AMR_MUX_MCR2			0x42
+#define	AMR_MUX_MCR3			0x43
+#define		AM_MUX_CHANNEL_B1		0x01
+#define		AM_MUX_CHANNEL_B2		0x02
+#define		AM_MUX_CHANNEL_Ba		0x03
+#define		AM_MUX_CHANNEL_Bb		0x04
+#define		AM_MUX_CHANNEL_Bc		0x05
+#define		AM_MUX_CHANNEL_Bd		0x06
+#define		AM_MUX_CHANNEL_Be		0x07
+#define		AM_MUX_CHANNEL_Bf		0x08
+#define	AMR_MUX_MCR4			0x44
+#define		AM_MUX_MCR4_ENABLE_INTS		0x08
+#define		AM_MUX_MCR4_REVERSE_Bb		0x10
+#define		AM_MUX_MCR4_REVERSE_Bc		0x20
+#define	AMR_MUX_1_4			0x45
+
+/* Main Audio Processor */
+#define	AMR_MAP_X			0x61
+#define	AMR_MAP_R			0x62
+#define	AMR_MAP_GX			0x63
+#define	AMR_MAP_GR			0x64
+#define	AMR_MAP_GER			0x65
+#define	AMR_MAP_STGR			0x66
+#define	AMR_MAP_FTGR_1_2		0x67
+#define	AMR_MAP_ATGR_1_2		0x68
+#define	AMR_MAP_MMR1			0x69
+#define		AM_MAP_MMR1_ALAW		0x01
+#define		AM_MAP_MMR1_GX			0x02
+#define		AM_MAP_MMR1_GR			0x04
+#define		AM_MAP_MMR1_GER			0x08
+#define		AM_MAP_MMR1_X			0x10
+#define		AM_MAP_MMR1_R			0x20
+#define		AM_MAP_MMR1_STG			0x40
+#define		AM_MAP_MMR1_LOOPBACK		0x80
+#define	AMR_MAP_MMR2			0x6A
+#define		AM_MAP_MMR2_AINB		0x01
+#define		AM_MAP_MMR2_LS			0x02
+#define		AM_MAP_MMR2_ENABLE_DTMF		0x04
+#define		AM_MAP_MMR2_ENABLE_TONEGEN	0x08
+#define		AM_MAP_MMR2_ENABLE_TONERING	0x10
+#define		AM_MAP_MMR2_DISABLE_HIGHPASS	0x20
+#define		AM_MAP_MMR2_DISABLE_AUTOZERO	0x40
+#define	AMR_MAP_1_10			0x6B
+#define	AMR_MAP_MMR3			0x6C
+#define	AMR_MAP_STRA			0x6D
+#define	AMR_MAP_STRF			0x6E
+#define	AMR_MAP_PEAKX			0x70
+#define	AMR_MAP_PEAKR			0x71
+#define	AMR_MAP_15_16			0x72
+
+/* Data Link Controller */
+#define	AMR_DLC_FRAR_1_2_3		0x81
+#define	AMR_DLC_SRAR_1_2_3		0x82
+#define	AMR_DLC_TAR			0x83
+#define	AMR_DLC_DRLR			0x84
+#define	AMR_DLC_DTCR			0x85
+#define	AMR_DLC_DMR1			0x86
+#define		AMR_DLC_DMR1_DTTHRSH_INT	0x01
+#define		AMR_DLC_DMR1_DRTHRSH_INT	0x02
+#define		AMR_DLC_DMR1_TAR_ENABL		0x04
+#define		AMR_DLC_DMR1_EORP_INT		0x08
+#define		AMR_DLC_DMR1_EN_ADDR1		0x10
+#define		AMR_DLC_DMR1_EN_ADDR2		0x20
+#define		AMR_DLC_DMR1_EN_ADDR3		0x40
+#define		AMR_DLC_DMR1_EN_ADDR4		0x80
+#define		AMR_DLC_DMR1_EN_ADDRS		0xf0
+#define	AMR_DLC_DMR2			0x87
+#define		AMR_DLC_DMR2_RABRT_INT		0x01
+#define		AMR_DLC_DMR2_RESID_INT		0x02
+#define		AMR_DLC_DMR2_COLL_INT		0x04
+#define		AMR_DLC_DMR2_FCS_INT		0x08
+#define		AMR_DLC_DMR2_OVFL_INT		0x10
+#define		AMR_DLC_DMR2_UNFL_INT		0x20
+#define		AMR_DLC_DMR2_OVRN_INT		0x40
+#define		AMR_DLC_DMR2_UNRN_INT		0x80
+#define	AMR_DLC_1_7			0x88
+#define	AMR_DLC_DRCR			0x89
+#define	AMR_DLC_RNGR1			0x8A
+#define	AMR_DLC_RNGR2			0x8B
+#define	AMR_DLC_FRAR4			0x8C
+#define	AMR_DLC_SRAR4			0x8D
+#define	AMR_DLC_DMR3			0x8E
+#define		AMR_DLC_DMR3_VA_INT		0x01
+#define		AMR_DLC_DMR3_EOTP_INT		0x02
+#define		AMR_DLC_DMR3_LBRP_INT		0x04
+#define		AMR_DLC_DMR3_RBA_INT		0x08
+#define		AMR_DLC_DMR3_LBT_INT		0x10
+#define		AMR_DLC_DMR3_TBE_INT		0x20
+#define		AMR_DLC_DMR3_RPLOST_INT		0x40
+#define		AMR_DLC_DMR3_KEEP_FCS		0x80
+#define	AMR_DLC_DMR4			0x8F
+#define		AMR_DLC_DMR4_RCV_1		0x00
+#define		AMR_DLC_DMR4_RCV_2		0x01
+#define		AMR_DLC_DMR4_RCV_4		0x02
+#define		AMR_DLC_DMR4_RCV_8		0x03
+#define		AMR_DLC_DMR4_RCV_16		0x01
+#define		AMR_DLC_DMR4_RCV_24		0x02
+#define		AMR_DLC_DMR4_RCV_30		0x03
+#define		AMR_DLC_DMR4_XMT_1		0x00
+#define		AMR_DLC_DMR4_XMT_2		0x04
+#define		AMR_DLC_DMR4_XMT_4		0x08
+#define		AMR_DLC_DMR4_XMT_8		0x0c
+#define		AMR_DLC_DMR4_XMT_10		0x08
+#define		AMR_DLC_DMR4_XMT_14		0x0c
+#define		AMR_DLC_DMR4_IDLE_MARK		0x00
+#define		AMR_DLC_DMR4_IDLE_FLAG		0x10
+#define		AMR_DLC_DMR4_ADDR_BOTH		0x00
+#define		AMR_DLC_DMR4_ADDR_1ST		0x20
+#define		AMR_DLC_DMR4_ADDR_2ND		0xa0
+#define		AMR_DLC_DMR4_CR_ENABLE		0x40
+#define	AMR_DLC_12_15			0x90
+#define	AMR_DLC_ASR			0x91
+#define	AMR_DLC_EFCR			0x92
+#define		AMR_DLC_EFCR_EXTEND_FIFO	0x01
+#define		AMR_DLC_EFCR_SEC_PKT_INT	0x02
+
+#define AMR_DSR1_VADDR			0x01
+#define AMR_DSR1_EORP			0x02
+#define AMR_DSR1_PKT_IP			0x04
+#define AMR_DSR1_DECHO_ON		0x08
+#define AMR_DSR1_DLOOP_ON		0x10
+#define AMR_DSR1_DBACK_OFF		0x20
+#define AMR_DSR1_EOTP			0x40
+#define AMR_DSR1_CXMT_ABRT		0x80
+
+#define AMR_DSR2_LBRP			0x01
+#define AMR_DSR2_RBA			0x02
+#define AMR_DSR2_RPLOST			0x04
+#define AMR_DSR2_LAST_BYTE		0x08
+#define AMR_DSR2_TBE			0x10
+#define AMR_DSR2_MARK_IDLE		0x20
+#define AMR_DSR2_FLAG_IDLE		0x40
+#define AMR_DSR2_SECOND_PKT		0x80
+
+#define AMR_DER_RABRT			0x01
+#define AMR_DER_RFRAME			0x02
+#define AMR_DER_COLLISION		0x04
+#define AMR_DER_FCS			0x08
+#define AMR_DER_OVFL			0x10
+#define AMR_DER_UNFL			0x20
+#define AMR_DER_OVRN			0x40
+#define AMR_DER_UNRN			0x80
+
+/* Peripheral Port */
+#define	AMR_PP_PPCR1			0xC0
+#define	AMR_PP_PPSR			0xC1
+#define	AMR_PP_PPIER			0xC2
+#define	AMR_PP_MTDR			0xC3
+#define	AMR_PP_MRDR			0xC3
+#define	AMR_PP_CITDR0			0xC4
+#define	AMR_PP_CIRDR0			0xC4
+#define	AMR_PP_CITDR1			0xC5
+#define	AMR_PP_CIRDR1			0xC5
+#define	AMR_PP_PPCR2			0xC8
+#define	AMR_PP_PPCR3			0xC9
+
+typedef struct snd_amd7930 {
+	spinlock_t		lock;
+	void __iomem		*regs;
+	u32			flags;
+#define AMD7930_FLAG_PLAYBACK	0x00000001
+#define AMD7930_FLAG_CAPTURE	0x00000002
+
+	struct amd7930_map	map;
+
+	snd_card_t		*card;
+	snd_pcm_t		*pcm;
+	snd_pcm_substream_t	*playback_substream;
+	snd_pcm_substream_t	*capture_substream;
+
+	/* Playback/Capture buffer state. */
+	unsigned char		*p_orig, *p_cur;
+	int			p_left;
+	unsigned char		*c_orig, *c_cur;
+	int			c_left;
+
+	int			rgain;
+	int			pgain;
+	int			mgain;
+
+	struct sbus_dev		*sdev;
+	unsigned int		irq;
+	unsigned int		regs_size;
+	struct snd_amd7930	*next;
+} amd7930_t;
+
+static amd7930_t *amd7930_list;
+
+/* Idle the AMD7930 chip.  The amd->lock is not held.  */
+static __inline__ void amd7930_idle(amd7930_t *amd)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&amd->lock, flags);
+	sbus_writeb(AMR_INIT, amd->regs + AMD7930_CR);
+	sbus_writeb(0, amd->regs + AMD7930_DR);
+	spin_unlock_irqrestore(&amd->lock, flags);
+}
+
+/* Enable chip interrupts.  The amd->lock is not held.  */
+static __inline__ void amd7930_enable_ints(amd7930_t *amd)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&amd->lock, flags);
+	sbus_writeb(AMR_INIT, amd->regs + AMD7930_CR);
+	sbus_writeb(AM_INIT_ACTIVE, amd->regs + AMD7930_DR);
+	spin_unlock_irqrestore(&amd->lock, flags);
+}
+
+/* Disable chip interrupts.  The amd->lock is not held.  */
+static __inline__ void amd7930_disable_ints(amd7930_t *amd)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&amd->lock, flags);
+	sbus_writeb(AMR_INIT, amd->regs + AMD7930_CR);
+	sbus_writeb(AM_INIT_ACTIVE | AM_INIT_DISABLE_INTS, amd->regs + AMD7930_DR);
+	spin_unlock_irqrestore(&amd->lock, flags);
+}
+
+/* Commit amd7930_map settings to the hardware.
+ * The amd->lock is held and local interrupts are disabled.
+ */
+static void __amd7930_write_map(amd7930_t *amd)
+{
+	struct amd7930_map *map = &amd->map;
+
+	sbus_writeb(AMR_MAP_GX, amd->regs + AMD7930_CR);
+	sbus_writeb(((map->gx >> 0) & 0xff), amd->regs + AMD7930_DR);
+	sbus_writeb(((map->gx >> 8) & 0xff), amd->regs + AMD7930_DR);
+
+	sbus_writeb(AMR_MAP_GR, amd->regs + AMD7930_CR);
+	sbus_writeb(((map->gr >> 0) & 0xff), amd->regs + AMD7930_DR);
+	sbus_writeb(((map->gr >> 8) & 0xff), amd->regs + AMD7930_DR);
+
+	sbus_writeb(AMR_MAP_STGR, amd->regs + AMD7930_CR);
+	sbus_writeb(((map->stgr >> 0) & 0xff), amd->regs + AMD7930_DR);
+	sbus_writeb(((map->stgr >> 8) & 0xff), amd->regs + AMD7930_DR);
+
+	sbus_writeb(AMR_MAP_GER, amd->regs + AMD7930_CR);
+	sbus_writeb(((map->ger >> 0) & 0xff), amd->regs + AMD7930_DR);
+	sbus_writeb(((map->ger >> 8) & 0xff), amd->regs + AMD7930_DR);
+
+	sbus_writeb(AMR_MAP_MMR1, amd->regs + AMD7930_CR);
+	sbus_writeb(map->mmr1, amd->regs + AMD7930_DR);
+
+	sbus_writeb(AMR_MAP_MMR2, amd->regs + AMD7930_CR);
+	sbus_writeb(map->mmr2, amd->regs + AMD7930_DR);
+}
+
+/* gx, gr & stg gains.  this table must contain 256 elements with
+ * the 0th being "infinity" (the magic value 9008).  The remaining
+ * elements match sun's gain curve (but with higher resolution):
+ * -18 to 0dB in .16dB steps then 0 to 12dB in .08dB steps.
+ */
+static __const__ __u16 gx_coeff[256] = {
+	0x9008, 0x8b7c, 0x8b51, 0x8b45, 0x8b42, 0x8b3b, 0x8b36, 0x8b33,
+	0x8b32, 0x8b2a, 0x8b2b, 0x8b2c, 0x8b25, 0x8b23, 0x8b22, 0x8b22,
+	0x9122, 0x8b1a, 0x8aa3, 0x8aa3, 0x8b1c, 0x8aa6, 0x912d, 0x912b,
+	0x8aab, 0x8b12, 0x8aaa, 0x8ab2, 0x9132, 0x8ab4, 0x913c, 0x8abb,
+	0x9142, 0x9144, 0x9151, 0x8ad5, 0x8aeb, 0x8a79, 0x8a5a, 0x8a4a,
+	0x8b03, 0x91c2, 0x91bb, 0x8a3f, 0x8a33, 0x91b2, 0x9212, 0x9213,
+	0x8a2c, 0x921d, 0x8a23, 0x921a, 0x9222, 0x9223, 0x922d, 0x9231,
+	0x9234, 0x9242, 0x925b, 0x92dd, 0x92c1, 0x92b3, 0x92ab, 0x92a4,
+	0x92a2, 0x932b, 0x9341, 0x93d3, 0x93b2, 0x93a2, 0x943c, 0x94b2,
+	0x953a, 0x9653, 0x9782, 0x9e21, 0x9d23, 0x9cd2, 0x9c23, 0x9baa,
+	0x9bde, 0x9b33, 0x9b22, 0x9b1d, 0x9ab2, 0xa142, 0xa1e5, 0x9a3b,
+	0xa213, 0xa1a2, 0xa231, 0xa2eb, 0xa313, 0xa334, 0xa421, 0xa54b,
+	0xada4, 0xac23, 0xab3b, 0xaaab, 0xaa5c, 0xb1a3, 0xb2ca, 0xb3bd,
+	0xbe24, 0xbb2b, 0xba33, 0xc32b, 0xcb5a, 0xd2a2, 0xe31d, 0x0808,
+	0x72ba, 0x62c2, 0x5c32, 0x52db, 0x513e, 0x4cce, 0x43b2, 0x4243,
+	0x41b4, 0x3b12, 0x3bc3, 0x3df2, 0x34bd, 0x3334, 0x32c2, 0x3224,
+	0x31aa, 0x2a7b, 0x2aaa, 0x2b23, 0x2bba, 0x2c42, 0x2e23, 0x25bb,
+	0x242b, 0x240f, 0x231a, 0x22bb, 0x2241, 0x2223, 0x221f, 0x1a33,
+	0x1a4a, 0x1acd, 0x2132, 0x1b1b, 0x1b2c, 0x1b62, 0x1c12, 0x1c32,
+	0x1d1b, 0x1e71, 0x16b1, 0x1522, 0x1434, 0x1412, 0x1352, 0x1323,
+	0x1315, 0x12bc, 0x127a, 0x1235, 0x1226, 0x11a2, 0x1216, 0x0a2a,
+	0x11bc, 0x11d1, 0x1163, 0x0ac2, 0x0ab2, 0x0aab, 0x0b1b, 0x0b23,
+	0x0b33, 0x0c0f, 0x0bb3, 0x0c1b, 0x0c3e, 0x0cb1, 0x0d4c, 0x0ec1,
+	0x079a, 0x0614, 0x0521, 0x047c, 0x0422, 0x03b1, 0x03e3, 0x0333,
+	0x0322, 0x031c, 0x02aa, 0x02ba, 0x02f2, 0x0242, 0x0232, 0x0227,
+	0x0222, 0x021b, 0x01ad, 0x0212, 0x01b2, 0x01bb, 0x01cb, 0x01f6,
+	0x0152, 0x013a, 0x0133, 0x0131, 0x012c, 0x0123, 0x0122, 0x00a2,
+	0x011b, 0x011e, 0x0114, 0x00b1, 0x00aa, 0x00b3, 0x00bd, 0x00ba,
+	0x00c5, 0x00d3, 0x00f3, 0x0062, 0x0051, 0x0042, 0x003b, 0x0033,
+	0x0032, 0x002a, 0x002c, 0x0025, 0x0023, 0x0022, 0x001a, 0x0021,
+	0x001b, 0x001b, 0x001d, 0x0015, 0x0013, 0x0013, 0x0012, 0x0012,
+	0x000a, 0x000a, 0x0011, 0x0011, 0x000b, 0x000b, 0x000c, 0x000e,
+};
+
+static __const__ __u16 ger_coeff[] = {
+	0x431f, /* 5. dB */
+	0x331f, /* 5.5 dB */
+	0x40dd, /* 6. dB */
+	0x11dd, /* 6.5 dB */
+	0x440f, /* 7. dB */
+	0x411f, /* 7.5 dB */
+	0x311f, /* 8. dB */
+	0x5520, /* 8.5 dB */
+	0x10dd, /* 9. dB */
+	0x4211, /* 9.5 dB */
+	0x410f, /* 10. dB */
+	0x111f, /* 10.5 dB */
+	0x600b, /* 11. dB */
+	0x00dd, /* 11.5 dB */
+	0x4210, /* 12. dB */
+	0x110f, /* 13. dB */
+	0x7200, /* 14. dB */
+	0x2110, /* 15. dB */
+	0x2200, /* 15.9 dB */
+	0x000b, /* 16.9 dB */
+	0x000f  /* 18. dB */
+};
+
+/* Update amd7930_map settings and program them into the hardware.
+ * The amd->lock is held and local interrupts are disabled.
+ */
+static void __amd7930_update_map(amd7930_t *amd)
+{
+	struct amd7930_map *map = &amd->map;
+	int level;
+
+	map->gx = gx_coeff[amd->rgain];
+	map->stgr = gx_coeff[amd->mgain];
+	level = (amd->pgain * (256 + ARRAY_SIZE(ger_coeff))) >> 8;
+	if (level >= 256) {
+		map->ger = ger_coeff[level - 256];
+		map->gr = gx_coeff[255];
+	} else {
+		map->ger = ger_coeff[0];
+		map->gr = gx_coeff[level];
+	}
+	__amd7930_write_map(amd);
+}
+
+static irqreturn_t snd_amd7930_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	amd7930_t *amd = dev_id;
+	unsigned int elapsed;
+	u8 ir;
+
+	spin_lock(&amd->lock);
+
+	elapsed = 0;
+
+	ir = sbus_readb(amd->regs + AMD7930_IR);
+	if (ir & AMR_IR_BBUF) {
+		u8 byte;
+
+		if (amd->flags & AMD7930_FLAG_PLAYBACK) {
+			if (amd->p_left > 0) {
+				byte = *(amd->p_cur++);
+				amd->p_left--;
+				sbus_writeb(byte, amd->regs + AMD7930_BBTB);
+				if (amd->p_left == 0)
+					elapsed |= AMD7930_FLAG_PLAYBACK;
+			} else
+				sbus_writeb(0, amd->regs + AMD7930_BBTB);
+		} else if (amd->flags & AMD7930_FLAG_CAPTURE) {
+			byte = sbus_readb(amd->regs + AMD7930_BBRB);
+			if (amd->c_left > 0) {
+				*(amd->c_cur++) = byte;
+				amd->c_left--;
+				if (amd->c_left == 0)
+					elapsed |= AMD7930_FLAG_CAPTURE;
+			}
+		}
+	}
+	spin_unlock(&amd->lock);
+
+	if (elapsed & AMD7930_FLAG_PLAYBACK)
+		snd_pcm_period_elapsed(amd->playback_substream);
+	else
+		snd_pcm_period_elapsed(amd->capture_substream);
+
+	return IRQ_HANDLED;
+}
+
+static int snd_amd7930_trigger(amd7930_t *amd, unsigned int flag, int cmd)
+{
+	unsigned long flags;
+	int result = 0;
+
+	spin_lock_irqsave(&amd->lock, flags);
+	if (cmd == SNDRV_PCM_TRIGGER_START) {
+		if (!(amd->flags & flag)) {
+			amd->flags |= flag;
+
+			/* Enable B channel interrupts.  */
+			sbus_writeb(AMR_MUX_MCR4, amd->regs + AMD7930_CR);
+			sbus_writeb(AM_MUX_MCR4_ENABLE_INTS, amd->regs + AMD7930_DR);
+		}
+	} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {
+		if (amd->flags & flag) {
+			amd->flags &= ~flag;
+
+			/* Disable B channel interrupts.  */
+			sbus_writeb(AMR_MUX_MCR4, amd->regs + AMD7930_CR);
+			sbus_writeb(0, amd->regs + AMD7930_DR);
+		}
+	} else {
+		result = -EINVAL;
+	}
+	spin_unlock_irqrestore(&amd->lock, flags);
+
+	return result;
+}
+
+static int snd_amd7930_playback_trigger(snd_pcm_substream_t * substream,
+					int cmd)
+{
+	amd7930_t *amd = snd_pcm_substream_chip(substream);
+	return snd_amd7930_trigger(amd, AMD7930_FLAG_PLAYBACK, cmd);
+}
+
+static int snd_amd7930_capture_trigger(snd_pcm_substream_t * substream,
+				       int cmd)
+{
+	amd7930_t *amd = snd_pcm_substream_chip(substream);
+	return snd_amd7930_trigger(amd, AMD7930_FLAG_CAPTURE, cmd);
+}
+
+static int snd_amd7930_playback_prepare(snd_pcm_substream_t * substream)
+{
+	amd7930_t *amd = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned int size = snd_pcm_lib_buffer_bytes(substream);
+	unsigned long flags;
+	u8 new_mmr1;
+
+	spin_lock_irqsave(&amd->lock, flags);
+
+	amd->flags |= AMD7930_FLAG_PLAYBACK;
+
+	/* Setup the pseudo-dma transfer pointers.  */
+	amd->p_orig = amd->p_cur = runtime->dma_area;
+	amd->p_left = size;
+
+	/* Put the chip into the correct encoding format.  */
+	new_mmr1 = amd->map.mmr1;
+	if (runtime->format == SNDRV_PCM_FORMAT_A_LAW)
+		new_mmr1 |= AM_MAP_MMR1_ALAW;
+	else
+		new_mmr1 &= ~AM_MAP_MMR1_ALAW;
+	if (new_mmr1 != amd->map.mmr1) {
+		amd->map.mmr1 = new_mmr1;
+		__amd7930_update_map(amd);
+	}
+
+	spin_unlock_irqrestore(&amd->lock, flags);
+
+	return 0;
+}
+
+static int snd_amd7930_capture_prepare(snd_pcm_substream_t * substream)
+{
+	amd7930_t *amd = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned int size = snd_pcm_lib_buffer_bytes(substream);
+	unsigned long flags;
+	u8 new_mmr1;
+
+	spin_lock_irqsave(&amd->lock, flags);
+
+	amd->flags |= AMD7930_FLAG_CAPTURE;
+
+	/* Setup the pseudo-dma transfer pointers.  */
+	amd->c_orig = amd->c_cur = runtime->dma_area;
+	amd->c_left = size;
+
+	/* Put the chip into the correct encoding format.  */
+	new_mmr1 = amd->map.mmr1;
+	if (runtime->format == SNDRV_PCM_FORMAT_A_LAW)
+		new_mmr1 |= AM_MAP_MMR1_ALAW;
+	else
+		new_mmr1 &= ~AM_MAP_MMR1_ALAW;
+	if (new_mmr1 != amd->map.mmr1) {
+		amd->map.mmr1 = new_mmr1;
+		__amd7930_update_map(amd);
+	}
+
+	spin_unlock_irqrestore(&amd->lock, flags);
+
+	return 0;
+}
+
+static snd_pcm_uframes_t snd_amd7930_playback_pointer(snd_pcm_substream_t * substream)
+{
+	amd7930_t *amd = snd_pcm_substream_chip(substream);
+	size_t ptr;
+
+	if (!(amd->flags & AMD7930_FLAG_PLAYBACK))
+		return 0;
+	ptr = amd->p_cur - amd->p_orig;
+	return bytes_to_frames(substream->runtime, ptr);
+}
+
+static snd_pcm_uframes_t snd_amd7930_capture_pointer(snd_pcm_substream_t * substream)
+{
+	amd7930_t *amd = snd_pcm_substream_chip(substream);
+	size_t ptr;
+
+	if (!(amd->flags & AMD7930_FLAG_CAPTURE))
+		return 0;
+
+	ptr = amd->c_cur - amd->c_orig;
+	return bytes_to_frames(substream->runtime, ptr);
+}
+
+/* Playback and capture have identical properties.  */
+static snd_pcm_hardware_t snd_amd7930_pcm_hw =
+{
+	.info			= (SNDRV_PCM_INFO_MMAP |
+				   SNDRV_PCM_INFO_MMAP_VALID |
+				   SNDRV_PCM_INFO_INTERLEAVED |
+				   SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				   SNDRV_PCM_INFO_HALF_DUPLEX),
+	.formats		= SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW,
+	.rates			= SNDRV_PCM_RATE_8000,
+	.rate_min		= 8000,
+	.rate_max		= 8000,
+	.channels_min		= 1,
+	.channels_max		= 1,
+	.buffer_bytes_max	= (64*1024),
+	.period_bytes_min	= 1,
+	.period_bytes_max	= (64*1024),
+	.periods_min		= 1,
+	.periods_max		= 1024,
+};
+
+static int snd_amd7930_playback_open(snd_pcm_substream_t * substream)
+{
+	amd7930_t *amd = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	amd->playback_substream = substream;
+	runtime->hw = snd_amd7930_pcm_hw;
+	return 0;
+}
+
+static int snd_amd7930_capture_open(snd_pcm_substream_t * substream)
+{
+	amd7930_t *amd = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	amd->capture_substream = substream;
+	runtime->hw = snd_amd7930_pcm_hw;
+	return 0;
+}
+
+static int snd_amd7930_playback_close(snd_pcm_substream_t * substream)
+{
+	amd7930_t *amd = snd_pcm_substream_chip(substream);
+
+	amd->playback_substream = NULL;
+	return 0;
+}
+
+static int snd_amd7930_capture_close(snd_pcm_substream_t * substream)
+{
+	amd7930_t *amd = snd_pcm_substream_chip(substream);
+
+	amd->capture_substream = NULL;
+	return 0;
+}
+
+static int snd_amd7930_hw_params(snd_pcm_substream_t * substream,
+				    snd_pcm_hw_params_t * hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+}
+
+static int snd_amd7930_hw_free(snd_pcm_substream_t * substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static snd_pcm_ops_t snd_amd7930_playback_ops = {
+	.open		=	snd_amd7930_playback_open,
+	.close		=	snd_amd7930_playback_close,
+	.ioctl		=	snd_pcm_lib_ioctl,
+	.hw_params	=	snd_amd7930_hw_params,
+	.hw_free	=	snd_amd7930_hw_free,
+	.prepare	=	snd_amd7930_playback_prepare,
+	.trigger	=	snd_amd7930_playback_trigger,
+	.pointer	=	snd_amd7930_playback_pointer,
+};
+
+static snd_pcm_ops_t snd_amd7930_capture_ops = {
+	.open		=	snd_amd7930_capture_open,
+	.close		=	snd_amd7930_capture_close,
+	.ioctl		=	snd_pcm_lib_ioctl,
+	.hw_params	=	snd_amd7930_hw_params,
+	.hw_free	=	snd_amd7930_hw_free,
+	.prepare	=	snd_amd7930_capture_prepare,
+	.trigger	=	snd_amd7930_capture_trigger,
+	.pointer	=	snd_amd7930_capture_pointer,
+};
+
+static void snd_amd7930_pcm_free(snd_pcm_t *pcm)
+{
+	amd7930_t *amd = pcm->private_data;
+
+	amd->pcm = NULL;
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static int __init snd_amd7930_pcm(amd7930_t *amd)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	if ((err = snd_pcm_new(amd->card,
+			       /* ID */             "sun_amd7930",
+			       /* device */         0,
+			       /* playback count */ 1,
+			       /* capture count */  1, &pcm)) < 0)
+		return err;
+	snd_assert(pcm != NULL, return -EINVAL);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_amd7930_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_amd7930_capture_ops);
+
+	pcm->private_data = amd;
+	pcm->private_free = snd_amd7930_pcm_free;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, amd->card->shortname);
+	amd->pcm = pcm;
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
+					      snd_dma_continuous_data(GFP_KERNEL),
+					      64*1024, 64*1024);
+
+	return 0;
+}
+
+#define VOLUME_MONITOR	0
+#define VOLUME_CAPTURE	1
+#define VOLUME_PLAYBACK	2
+
+static int snd_amd7930_info_volume(snd_kcontrol_t *kctl, snd_ctl_elem_info_t *uinfo)
+{
+	int type = kctl->private_value;
+
+	snd_assert(type == VOLUME_MONITOR ||
+		   type == VOLUME_CAPTURE ||
+		   type == VOLUME_PLAYBACK, return -EINVAL);
+	(void) type;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 255;
+
+	return 0;
+}
+
+static int snd_amd7930_get_volume(snd_kcontrol_t *kctl, snd_ctl_elem_value_t *ucontrol)
+{
+	amd7930_t *amd = snd_kcontrol_chip(kctl);
+	int type = kctl->private_value;
+	int *swval;
+
+	snd_assert(type == VOLUME_MONITOR ||
+		   type == VOLUME_CAPTURE ||
+		   type == VOLUME_PLAYBACK, return -EINVAL);
+
+	switch (type) {
+	case VOLUME_MONITOR:
+		swval = &amd->mgain;
+		break;
+	case VOLUME_CAPTURE:
+		swval = &amd->rgain;
+		break;
+	case VOLUME_PLAYBACK:
+	default:
+		swval = &amd->pgain;
+		break;
+	};
+
+	ucontrol->value.integer.value[0] = *swval;
+
+	return 0;
+}
+
+static int snd_amd7930_put_volume(snd_kcontrol_t *kctl, snd_ctl_elem_value_t *ucontrol)
+{
+	amd7930_t *amd = snd_kcontrol_chip(kctl);
+	unsigned long flags;
+	int type = kctl->private_value;
+	int *swval, change;
+
+	snd_assert(type == VOLUME_MONITOR ||
+		   type == VOLUME_CAPTURE ||
+		   type == VOLUME_PLAYBACK, return -EINVAL);
+
+	switch (type) {
+	case VOLUME_MONITOR:
+		swval = &amd->mgain;
+		break;
+	case VOLUME_CAPTURE:
+		swval = &amd->rgain;
+		break;
+	case VOLUME_PLAYBACK:
+	default:
+		swval = &amd->pgain;
+		break;
+	};
+
+	spin_lock_irqsave(&amd->lock, flags);
+
+	if (*swval != ucontrol->value.integer.value[0]) {
+		*swval = ucontrol->value.integer.value[0];
+		__amd7930_update_map(amd);
+		change = 1;
+	} else
+		change = 0;
+
+	spin_unlock_irqrestore(&amd->lock, flags);
+
+	return change;
+}
+
+static snd_kcontrol_new_t amd7930_controls[] __initdata = {
+	{
+		.iface		=	SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name		=	"Monitor Volume",
+		.index		=	0,
+		.info		=	snd_amd7930_info_volume,
+		.get		=	snd_amd7930_get_volume,
+		.put		=	snd_amd7930_put_volume,
+		.private_value	=	VOLUME_MONITOR,
+	},
+	{
+		.iface		=	SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name		=	"Capture Volume",
+		.index		=	0,
+		.info		=	snd_amd7930_info_volume,
+		.get		=	snd_amd7930_get_volume,
+		.put		=	snd_amd7930_put_volume,
+		.private_value	=	VOLUME_CAPTURE,
+	},
+	{
+		.iface		=	SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name		=	"Playback Volume",
+		.index		=	0,
+		.info		=	snd_amd7930_info_volume,
+		.get		=	snd_amd7930_get_volume,
+		.put		=	snd_amd7930_put_volume,
+		.private_value	=	VOLUME_PLAYBACK,
+	},
+};
+
+static int __init snd_amd7930_mixer(amd7930_t *amd)
+{
+	snd_card_t *card;
+	int idx, err;
+
+	snd_assert(amd != NULL && amd->card != NULL, return -EINVAL);
+
+	card = amd->card;
+	strcpy(card->mixername, card->shortname);
+
+	for (idx = 0; idx < ARRAY_SIZE(amd7930_controls); idx++) {
+		if ((err = snd_ctl_add(card,
+				       snd_ctl_new1(&amd7930_controls[idx], amd))) < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static int snd_amd7930_free(amd7930_t *amd)
+{
+	amd7930_idle(amd);
+
+	if (amd->irq)
+		free_irq(amd->irq, amd);
+
+	if (amd->regs)
+		sbus_iounmap(amd->regs, amd->regs_size);
+
+	kfree(amd);
+
+	return 0;
+}
+
+static int snd_amd7930_dev_free(snd_device_t *device)
+{
+	amd7930_t *amd = device->device_data;
+
+	return snd_amd7930_free(amd);
+}
+
+static snd_device_ops_t snd_amd7930_dev_ops = {
+	.dev_free	=	snd_amd7930_dev_free,
+};
+
+static int __init snd_amd7930_create(snd_card_t *card,
+				     struct sbus_dev *sdev,
+				     struct resource *rp,
+				     unsigned int reg_size,
+				     struct linux_prom_irqs *irq_prop,
+				     int dev,
+				     amd7930_t **ramd)
+{
+	unsigned long flags;
+	amd7930_t *amd;
+	int err;
+
+	*ramd = NULL;
+	amd = kcalloc(1, sizeof(*amd), GFP_KERNEL);
+	if (amd == NULL)
+		return -ENOMEM;
+
+	spin_lock_init(&amd->lock);
+	amd->card = card;
+	amd->sdev = sdev;
+	amd->regs_size = reg_size;
+
+	amd->regs = sbus_ioremap(rp, 0, amd->regs_size, "amd7930");
+	if (!amd->regs) {
+		snd_printk("amd7930-%d: Unable to map chip registers.\n", dev);
+		return -EIO;
+	}
+
+	amd7930_idle(amd);
+
+	if (request_irq(irq_prop->pri, snd_amd7930_interrupt,
+			SA_INTERRUPT | SA_SHIRQ, "amd7930", amd)) {
+		snd_printk("amd7930-%d: Unable to grab IRQ %s\n",
+			   dev,
+			   __irq_itoa(irq_prop->pri));
+		snd_amd7930_free(amd);
+		return -EBUSY;
+	}
+	amd->irq = irq_prop->pri;
+
+	amd7930_enable_ints(amd);
+
+	spin_lock_irqsave(&amd->lock, flags);
+
+	amd->rgain = 128;
+	amd->pgain = 200;
+	amd->mgain = 0;
+
+	memset(&amd->map, 0, sizeof(amd->map));
+	amd->map.mmr1 = (AM_MAP_MMR1_GX | AM_MAP_MMR1_GER |
+			 AM_MAP_MMR1_GR | AM_MAP_MMR1_STG);
+	amd->map.mmr2 = (AM_MAP_MMR2_LS | AM_MAP_MMR2_AINB);
+
+	__amd7930_update_map(amd);
+
+	/* Always MUX audio (Ba) to channel Bb. */
+	sbus_writeb(AMR_MUX_MCR1, amd->regs + AMD7930_CR);
+	sbus_writeb(AM_MUX_CHANNEL_Ba | (AM_MUX_CHANNEL_Bb << 4),
+		    amd->regs + AMD7930_DR);
+
+	spin_unlock_irqrestore(&amd->lock, flags);
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,
+				  amd, &snd_amd7930_dev_ops)) < 0) {
+		snd_amd7930_free(amd);
+		return err;
+	}
+
+	*ramd = amd;
+	return 0;
+}
+
+static int __init amd7930_attach(int prom_node, struct sbus_dev *sdev)
+{
+	static int dev;
+	struct linux_prom_registers reg_prop;
+	struct linux_prom_irqs irq_prop;
+	struct resource res, *rp;
+	snd_card_t *card;
+	amd7930_t *amd;
+	int err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	err = prom_getproperty(prom_node, "intr",
+			       (char *) &irq_prop, sizeof(irq_prop));
+	if (err < 0) {
+		snd_printk("amd7930-%d: Firmware node lacks IRQ property.\n", dev);
+		return -ENODEV;
+	}
+
+	err = prom_getproperty(prom_node, "reg",
+			       (char *) &reg_prop, sizeof(reg_prop));
+	if (err < 0) {
+		snd_printk("amd7930-%d: Firmware node lacks register property.\n", dev);
+		return -ENODEV;
+	}
+
+	if (sdev) {
+		rp = &sdev->resource[0];
+	} else {
+		rp = &res;
+		rp->start = reg_prop.phys_addr;
+		rp->end = rp->start + reg_prop.reg_size - 1;
+		rp->flags = IORESOURCE_IO | (reg_prop.which_io & 0xff);
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+
+	strcpy(card->driver, "AMD7930");
+	strcpy(card->shortname, "Sun AMD7930");
+	sprintf(card->longname, "%s at 0x%02lx:0x%08lx, irq %s",
+		card->shortname,
+		rp->flags & 0xffL,
+		rp->start,
+		__irq_itoa(irq_prop.pri));
+
+	if ((err = snd_amd7930_create(card, sdev, rp, reg_prop.reg_size,
+					  &irq_prop, dev, &amd)) < 0)
+		goto out_err;
+
+	if ((err = snd_amd7930_pcm(amd)) < 0)
+		goto out_err;
+
+	if ((err = snd_amd7930_mixer(amd)) < 0)
+		goto out_err;
+
+	if ((err = snd_card_register(card)) < 0)
+		goto out_err;
+
+	amd->next = amd7930_list;
+	amd7930_list = amd;
+
+	dev++;
+	return 0;
+
+out_err:
+	snd_card_free(card);
+	return err;
+}
+
+static int __init amd7930_init(void)
+{
+	struct sbus_bus *sbus;
+	struct sbus_dev *sdev;
+	int node, found;
+
+	found = 0;
+
+	/* Try to find the sun4c "audio" node first. */
+	node = prom_getchild(prom_root_node);
+	node = prom_searchsiblings(node, "audio");
+	if (node && amd7930_attach(node, NULL) == 0)
+		found++;
+
+	/* Probe each SBUS for amd7930 chips. */
+	for_all_sbusdev(sdev, sbus) {
+		if (!strcmp(sdev->prom_name, "audio")) {
+			if (amd7930_attach(sdev->prom_node, sdev) == 0)
+				found++;
+		}
+	}
+
+	return (found > 0) ? 0 : -EIO;
+}
+
+static void __exit amd7930_exit(void)
+{
+	amd7930_t *p = amd7930_list;
+
+	while (p != NULL) {
+		amd7930_t *next = p->next;
+
+		snd_card_free(p->card);
+
+		p = next;
+	}
+
+	amd7930_list = NULL;
+}
+
+module_init(amd7930_init);
+module_exit(amd7930_exit);
