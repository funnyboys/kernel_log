commit 0da2c47a951c27f1be34cb9221d77b0ed2db6cee
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:50 2020 +0100

    ALSA: i2c: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-35-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index bac4f0036cd6..8634d4f466b3 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -459,7 +459,7 @@ static int snd_cs8427_spdif_mask_get(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_cs8427_iec958_controls[] = {
+static const struct snd_kcontrol_new snd_cs8427_iec958_controls[] = {
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.info =		snd_cs8427_in_status_info,

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index 8afa2f888466..bac4f0036cd6 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -1,23 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Routines for control of the CS8427 via i2c bus
  *  IEC958 (S/PDIF) receiver & transmitter by Cirrus Logic
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/slab.h>

commit eb7ebfa3c1989aa8e59d5e68ab3cddd7df1bfb27
Author: Philipp Klocke <philipp97kl@gmail.com>
Date:   Thu Oct 18 12:33:02 2018 +0200

    ALSA: i2c/cs8427: Fix int to char conversion
    
    Compiling with clang yields the following warning:
    
    sound/i2c/cs8427.c:140:31: warning: implicit conversion from 'int'
    to 'char' changes value from 160 to -96 [-Wconstant-conversion]
        data[0] = CS8427_REG_AUTOINC | CS8427_REG_CORU_DATABUF;
                ~ ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
    
    Because CS8427_REG_AUTOINC is defined as 128, it is too big for a
    char field.
    So change data from char to unsigned char, that it can hold the value.
    
    This patch does not change the generated code.
    
    Signed-off-by: Philipp Klocke <philipp97kl@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index 2647309bc675..8afa2f888466 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -118,7 +118,7 @@ static int snd_cs8427_send_corudata(struct snd_i2c_device *device,
 	struct cs8427 *chip = device->private_data;
 	char *hw_data = udata ?
 		chip->playback.hw_udata : chip->playback.hw_status;
-	char data[32];
+	unsigned char data[32];
 	int err, idx;
 
 	if (!memcmp(hw_data, ndata, count))

commit 3b23dc52da90c340c51273414f4e2d13e07e594c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 3 15:48:26 2018 +0200

    ALSA: i2c: Remove empty init and exit
    
    For a sake of code simplification, remove the init and the exit
    entries that do nothing.
    
    Notes for readers: actually it's OK to remove *both* init and exit,
    but not OK to remove the exit entry.  By removing only the exit while
    keeping init, the module becomes permanently loaded; i.e. you cannot
    unload it any longer!
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index 7e21621e492a..2647309bc675 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -621,15 +621,3 @@ int snd_cs8427_iec958_pcm(struct snd_i2c_device *cs8427, unsigned int rate)
 }
 
 EXPORT_SYMBOL(snd_cs8427_iec958_pcm);
-
-static int __init alsa_cs8427_module_init(void)
-{
-	return 0;
-}
-
-static void __exit alsa_cs8427_module_exit(void)
-{
-}
-
-module_init(alsa_cs8427_module_init)
-module_exit(alsa_cs8427_module_exit)

commit 9229bc1500100226ef4d2dbe51446fd8472a3cea
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Thu Apr 3 14:49:46 2014 +0200

    ALSA: cs8427: separate HW initialization
    
    Separate HW initialization from device creation.
    This is needed for suspend/resume support.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index 6c2dc3863ac0..7e21621e492a 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -150,10 +150,8 @@ static void snd_cs8427_free(struct snd_i2c_device *device)
 	kfree(device->private_data);
 }
 
-int snd_cs8427_create(struct snd_i2c_bus *bus,
-		      unsigned char addr,
-		      unsigned int reset_timeout,
-		      struct snd_i2c_device **r_cs8427)
+int snd_cs8427_init(struct snd_i2c_bus *bus,
+		    struct snd_i2c_device *device)
 {
 	static unsigned char initvals1[] = {
 	  CS8427_REG_CONTROL1 | CS8427_REG_AUTOINC,
@@ -200,22 +198,10 @@ int snd_cs8427_create(struct snd_i2c_bus *bus,
 	     Inhibit E->F transfers. */
 	  CS8427_UD | CS8427_EFTUI | CS8427_DETUI,
 	};
+	struct cs8427 *chip = device->private_data;
 	int err;
-	struct cs8427 *chip;
-	struct snd_i2c_device *device;
 	unsigned char buf[24];
 
-	if ((err = snd_i2c_device_create(bus, "CS8427",
-					 CS8427_ADDR | (addr & 7),
-					 &device)) < 0)
-		return err;
-	chip = device->private_data = kzalloc(sizeof(*chip), GFP_KERNEL);
-	if (chip == NULL) {
-	      	snd_i2c_device_free(device);
-		return -ENOMEM;
-	}
-	device->private_free = snd_cs8427_free;
-	
 	snd_i2c_lock(bus);
 	err = snd_cs8427_reg_read(device, CS8427_REG_ID_AND_VER);
 	if (err != CS8427_VER8427A) {
@@ -264,10 +250,44 @@ int snd_cs8427_create(struct snd_i2c_bus *bus,
 	snd_i2c_unlock(bus);
 
 	/* turn on run bit and rock'n'roll */
+	snd_cs8427_reset(device);
+
+	return 0;
+
+__fail:
+	snd_i2c_unlock(bus);
+
+	return err;
+}
+EXPORT_SYMBOL(snd_cs8427_init);
+
+int snd_cs8427_create(struct snd_i2c_bus *bus,
+		      unsigned char addr,
+		      unsigned int reset_timeout,
+		      struct snd_i2c_device **r_cs8427)
+{
+	int err;
+	struct cs8427 *chip;
+	struct snd_i2c_device *device;
+
+	err = snd_i2c_device_create(bus, "CS8427", CS8427_ADDR | (addr & 7),
+				    &device);
+	if (err < 0)
+		return err;
+	chip = device->private_data = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL) {
+		snd_i2c_device_free(device);
+		return -ENOMEM;
+	}
+	device->private_free = snd_cs8427_free;
+
 	if (reset_timeout < 1)
 		reset_timeout = 1;
 	chip->reset_timeout = reset_timeout;
-	snd_cs8427_reset(device);
+
+	err = snd_cs8427_init(bus, device);
+	if (err)
+		goto __fail;
 
 #if 0	// it's nice for read tests
 	{
@@ -286,7 +306,6 @@ int snd_cs8427_create(struct snd_i2c_bus *bus,
 	return 0;
 
       __fail:
-      	snd_i2c_unlock(bus);
       	snd_i2c_device_free(device);
       	return err < 0 ? err : -EIO;
 }

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index 04ae8704cdcd..6c2dc3863ac0 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -24,6 +24,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/bitrev.h>
+#include <linux/module.h>
 #include <asm/unaligned.h>
 #include <sound/core.h>
 #include <sound/control.h>

commit 401de8184a4d94688962b9258fe10ab309ffda9c
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Fri Nov 13 16:02:56 2009 +0900

    ALSA: ice1712: Use bitrev8
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index 020a5d512472..04ae8704cdcd 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -23,6 +23,7 @@
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/init.h>
+#include <linux/bitrev.h>
 #include <asm/unaligned.h>
 #include <sound/core.h>
 #include <sound/control.h>
@@ -55,18 +56,6 @@ struct cs8427 {
 	struct cs8427_stream capture;
 };
 
-static unsigned char swapbits(unsigned char val)
-{
-	int bit;
-	unsigned char res = 0;
-	for (bit = 0; bit < 8; bit++) {
-		res <<= 1;
-		res |= val & 1;
-		val >>= 1;
-	}
-	return res;
-}
-
 int snd_cs8427_reg_write(struct snd_i2c_device *device, unsigned char reg,
 			 unsigned char val)
 {
@@ -149,7 +138,7 @@ static int snd_cs8427_send_corudata(struct snd_i2c_device *device,
 	}
 	data[0] = CS8427_REG_AUTOINC | CS8427_REG_CORU_DATABUF;
 	for (idx = 0; idx < count; idx++)
-		data[idx + 1] = swapbits(ndata[idx]);
+		data[idx + 1] = bitrev8(ndata[idx]);
 	if (snd_i2c_sendbytes(device, data, count + 1) != count + 1)
 		return -EIO;
 	return 1;

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index 9c3d361accfb..020a5d512472 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -314,7 +314,8 @@ static void snd_cs8427_reset(struct snd_i2c_device *cs8427)
 	unsigned long end_time;
 	int data, aes3input = 0;
 
-	snd_assert(cs8427, return);
+	if (snd_BUG_ON(!cs8427))
+		return;
 	chip = cs8427->private_data;
 	snd_i2c_lock(cs8427->bus);
 	if ((chip->regmap[CS8427_REG_CLOCKSOURCE] & CS8427_RXDAES3INPUT) ==
@@ -526,7 +527,8 @@ int snd_cs8427_iec958_build(struct snd_i2c_device *cs8427,
 	unsigned int idx;
 	int err;
 
-	snd_assert(play_substream && cap_substream, return -EINVAL);
+	if (snd_BUG_ON(!play_substream || !cap_substream))
+		return -EINVAL;
 	for (idx = 0; idx < ARRAY_SIZE(snd_cs8427_iec958_controls); idx++) {
 		kctl = snd_ctl_new1(&snd_cs8427_iec958_controls[idx], cs8427);
 		if (kctl == NULL)
@@ -543,7 +545,8 @@ int snd_cs8427_iec958_build(struct snd_i2c_device *cs8427,
 
 	chip->playback.substream = play_substream;
 	chip->capture.substream = cap_substream;
-	snd_assert(chip->playback.pcm_ctl, return -EIO);
+	if (snd_BUG_ON(!chip->playback.pcm_ctl))
+		return -EIO;
 	return 0;
 }
 
@@ -553,7 +556,8 @@ int snd_cs8427_iec958_active(struct snd_i2c_device *cs8427, int active)
 {
 	struct cs8427 *chip;
 
-	snd_assert(cs8427, return -ENXIO);
+	if (snd_BUG_ON(!cs8427))
+		return -ENXIO;
 	chip = cs8427->private_data;
 	if (active)
 		memcpy(chip->playback.pcm_status,
@@ -573,7 +577,8 @@ int snd_cs8427_iec958_pcm(struct snd_i2c_device *cs8427, unsigned int rate)
 	char *status;
 	int err, reset;
 
-	snd_assert(cs8427, return -ENXIO);
+	if (snd_BUG_ON(!cs8427))
+		return -ENXIO;
 	chip = cs8427->private_data;
 	status = chip->playback.pcm_status;
 	snd_i2c_lock(cs8427->bus);

commit 48008b598bb9cfffbd871512f49d84eb5b885a00
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu May 8 13:01:32 2008 +0200

    [ALSA] i2c: cs8427.c use put_unaligned helper
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index e57e9cbe6a0f..9c3d361accfb 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -23,6 +23,7 @@
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/init.h>
+#include <asm/unaligned.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
@@ -264,10 +265,7 @@ int snd_cs8427_create(struct snd_i2c_bus *bus,
 		goto __fail;
 	}
 	/* write default channel status bytes */
-	buf[0] = ((unsigned char)(SNDRV_PCM_DEFAULT_CON_SPDIF >> 0));
-	buf[1] = ((unsigned char)(SNDRV_PCM_DEFAULT_CON_SPDIF >> 8));
-	buf[2] = ((unsigned char)(SNDRV_PCM_DEFAULT_CON_SPDIF >> 16));
-	buf[3] = ((unsigned char)(SNDRV_PCM_DEFAULT_CON_SPDIF >> 24));
+	put_unaligned_le32(SNDRV_PCM_DEFAULT_CON_SPDIF, buf);
 	memset(buf + 4, 0, 24 - 4);
 	if (snd_cs8427_send_corudata(device, 0, buf, 24) < 0)
 		goto __fail;

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index 744366b72345..e57e9cbe6a0f 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -20,7 +20,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/init.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index e601caa6ea0b..744366b72345 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -1,7 +1,7 @@
 /*
  *  Routines for control of the CS8427 via i2c bus
  *  IEC958 (S/PDIF) receiver & transmitter by Cirrus Logic
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *
  *
  *   This program is free software; you can redistribute it and/or modify
@@ -32,7 +32,7 @@
 
 static void snd_cs8427_reset(struct snd_i2c_device *cs8427);
 
-MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");
 MODULE_DESCRIPTION("IEC958 (S/PDIF) receiver & transmitter by Cirrus Logic");
 MODULE_LICENSE("GPL");
 

commit 4eb4550ab37d351ab0973ccec921a5a2d8560ec7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 20 17:34:57 2007 +0200

    [ALSA] Workaround for invalid signature read of CS8427
    
    Reading the signature of CS8427 over SPI/I2C fails on some devices
    by mysterious reason.  In most cases, however, it succeeds at the
    sequential read.  So, let's give a second chance to check the signature
    again.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index 64388cb8d6e5..e601caa6ea0b 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -228,6 +228,12 @@ int snd_cs8427_create(struct snd_i2c_bus *bus,
 	
 	snd_i2c_lock(bus);
 	err = snd_cs8427_reg_read(device, CS8427_REG_ID_AND_VER);
+	if (err != CS8427_VER8427A) {
+		/* give second chance */
+		snd_printk(KERN_WARNING "invalid CS8427 signature 0x%x: "
+			   "let me try again...\n", err);
+		err = snd_cs8427_reg_read(device, CS8427_REG_ID_AND_VER);
+	}
 	if (err != CS8427_VER8427A) {
 		snd_i2c_unlock(bus);
 		snd_printk(KERN_ERR "unable to find CS8427 signature "

commit cc63935f56d1b2486fa17bea63ee3cfc7b9c1304
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 30 15:31:25 2006 +0200

    [ALSA] trivial: Code clean up of i2c/cs8427.c
    
    - Fix spaces, wrap lines in 80 columns.
    - Move EXPORT_SYMBOL() adjacent to each function.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index 700c35b741e3..64388cb8d6e5 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -76,23 +76,28 @@ int snd_cs8427_reg_write(struct snd_i2c_device *device, unsigned char reg,
 	buf[0] = reg & 0x7f;
 	buf[1] = val;
 	if ((err = snd_i2c_sendbytes(device, buf, 2)) != 2) {
-		snd_printk(KERN_ERR "unable to send bytes 0x%02x:0x%02x to CS8427 (%i)\n", buf[0], buf[1], err);
+		snd_printk(KERN_ERR "unable to send bytes 0x%02x:0x%02x "
+			   "to CS8427 (%i)\n", buf[0], buf[1], err);
 		return err < 0 ? err : -EIO;
 	}
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_cs8427_reg_write);
+
 static int snd_cs8427_reg_read(struct snd_i2c_device *device, unsigned char reg)
 {
 	int err;
 	unsigned char buf;
 
 	if ((err = snd_i2c_sendbytes(device, &reg, 1)) != 1) {
-		snd_printk(KERN_ERR "unable to send register 0x%x byte to CS8427\n", reg);
+		snd_printk(KERN_ERR "unable to send register 0x%x byte "
+			   "to CS8427\n", reg);
 		return err < 0 ? err : -EIO;
 	}
 	if ((err = snd_i2c_readbytes(device, &buf, 1)) != 1) {
-		snd_printk(KERN_ERR "unable to read register 0x%x byte from CS8427\n", reg);
+		snd_printk(KERN_ERR "unable to read register 0x%x byte "
+			   "from CS8427\n", reg);
 		return err < 0 ? err : -EIO;
 	}
 	return buf;
@@ -121,7 +126,8 @@ static int snd_cs8427_send_corudata(struct snd_i2c_device *device,
 				    int count)
 {
 	struct cs8427 *chip = device->private_data;
-	char *hw_data = udata ? chip->playback.hw_udata : chip->playback.hw_status;
+	char *hw_data = udata ?
+		chip->playback.hw_udata : chip->playback.hw_status;
 	char data[32];
 	int err, idx;
 
@@ -134,11 +140,11 @@ static int snd_cs8427_send_corudata(struct snd_i2c_device *device,
 		memset(data, 0, sizeof(data));
 		if (memcmp(hw_data, data, count) == 0) {
 			chip->regmap[CS8427_REG_UDATABUF] &= ~CS8427_UBMMASK;
-			chip->regmap[CS8427_REG_UDATABUF] |= CS8427_UBMZEROS | CS8427_EFTUI;
-			if ((err = snd_cs8427_reg_write(device, CS8427_REG_UDATABUF,
-							chip->regmap[CS8427_REG_UDATABUF])) < 0)
-				return err;
-			return 0;
+			chip->regmap[CS8427_REG_UDATABUF] |= CS8427_UBMZEROS |
+				CS8427_EFTUI;
+			err = snd_cs8427_reg_write(device, CS8427_REG_UDATABUF,
+						   chip->regmap[CS8427_REG_UDATABUF]);
+			return err < 0 ? err : 0;
 		}
 	}
 	data[0] = CS8427_REG_AUTOINC | CS8427_REG_CORU_DATABUF;
@@ -161,24 +167,32 @@ int snd_cs8427_create(struct snd_i2c_bus *bus,
 {
 	static unsigned char initvals1[] = {
 	  CS8427_REG_CONTROL1 | CS8427_REG_AUTOINC,
-	  /* CS8427_REG_CONTROL1: RMCK to OMCK, valid PCM audio, disable mutes, TCBL=output */
+	  /* CS8427_REG_CONTROL1: RMCK to OMCK, valid PCM audio, disable mutes,
+	     TCBL=output */
 	  CS8427_SWCLK | CS8427_TCBLDIR,
-	  /* CS8427_REG_CONTROL2: hold last valid audio sample, RMCK=256*Fs, normal stereo operation */
+	  /* CS8427_REG_CONTROL2: hold last valid audio sample, RMCK=256*Fs,
+	     normal stereo operation */
 	  0x00,
-	  /* CS8427_REG_DATAFLOW: output drivers normal operation, Tx<=serial, Rx=>serial */
+	  /* CS8427_REG_DATAFLOW: output drivers normal operation, Tx<=serial,
+	     Rx=>serial */
 	  CS8427_TXDSERIAL | CS8427_SPDAES3RECEIVER,
-	  /* CS8427_REG_CLOCKSOURCE: Run off, CMCK=256*Fs, output time base = OMCK, input time base =
-	     recovered input clock, recovered input clock source is ILRCK changed to AES3INPUT (workaround, see snd_cs8427_reset) */
+	  /* CS8427_REG_CLOCKSOURCE: Run off, CMCK=256*Fs,
+	     output time base = OMCK, input time base = recovered input clock,
+	     recovered input clock source is ILRCK changed to AES3INPUT
+	     (workaround, see snd_cs8427_reset) */
 	  CS8427_RXDILRCK,
-	  /* CS8427_REG_SERIALINPUT: Serial audio input port data format = I2S, 24-bit, 64*Fsi */
+	  /* CS8427_REG_SERIALINPUT: Serial audio input port data format = I2S,
+	     24-bit, 64*Fsi */
 	  CS8427_SIDEL | CS8427_SILRPOL,
-	  /* CS8427_REG_SERIALOUTPUT: Serial audio output port data format = I2S, 24-bit, 64*Fsi */
+	  /* CS8427_REG_SERIALOUTPUT: Serial audio output port data format
+	     = I2S, 24-bit, 64*Fsi */
 	  CS8427_SODEL | CS8427_SOLRPOL,
 	};
 	static unsigned char initvals2[] = {
 	  CS8427_REG_RECVERRMASK | CS8427_REG_AUTOINC,
-	  /* CS8427_REG_RECVERRMASK: unmask the input PLL clock, V, confidence, biphase, parity status bits */
-	  /* CS8427_UNLOCK | CS8427_V | CS8427_CONF | CS8427_BIP | CS8427_PAR, */
+	  /* CS8427_REG_RECVERRMASK: unmask the input PLL clock, V, confidence,
+	     biphase, parity status bits */
+	  /* CS8427_UNLOCK | CS8427_V | CS8427_CONF | CS8427_BIP | CS8427_PAR,*/
 	  0xff, /* set everything */
 	  /* CS8427_REG_CSDATABUF:
 	     Registers 32-55 window to CS buffer
@@ -201,7 +215,8 @@ int snd_cs8427_create(struct snd_i2c_bus *bus,
 	struct snd_i2c_device *device;
 	unsigned char buf[24];
 
-	if ((err = snd_i2c_device_create(bus, "CS8427", CS8427_ADDR | (addr & 7),
+	if ((err = snd_i2c_device_create(bus, "CS8427",
+					 CS8427_ADDR | (addr & 7),
 					 &device)) < 0)
 		return err;
 	chip = device->private_data = kzalloc(sizeof(*chip), GFP_KERNEL);
@@ -212,8 +227,8 @@ int snd_cs8427_create(struct snd_i2c_bus *bus,
 	device->private_free = snd_cs8427_free;
 	
 	snd_i2c_lock(bus);
-	if ((err = snd_cs8427_reg_read(device, CS8427_REG_ID_AND_VER)) !=
-	    CS8427_VER8427A) {
+	err = snd_cs8427_reg_read(device, CS8427_REG_ID_AND_VER);
+	if (err != CS8427_VER8427A) {
 		snd_i2c_unlock(bus);
 		snd_printk(KERN_ERR "unable to find CS8427 signature "
 			   "(expected 0x%x, read 0x%x),\n",
@@ -222,7 +237,8 @@ int snd_cs8427_create(struct snd_i2c_bus *bus,
 		return -EFAULT;
 	}
 	/* turn off run bit while making changes to configuration */
-	if ((err = snd_cs8427_reg_write(device, CS8427_REG_CLOCKSOURCE, 0x00)) < 0)
+	err = snd_cs8427_reg_write(device, CS8427_REG_CLOCKSOURCE, 0x00);
+	if (err < 0)
 		goto __fail;
 	/* send initial values */
 	memcpy(chip->regmap + (initvals1[0] & 0x7f), initvals1 + 1, 6);
@@ -282,6 +298,8 @@ int snd_cs8427_create(struct snd_i2c_bus *bus,
       	return err < 0 ? err : -EIO;
 }
 
+EXPORT_SYMBOL(snd_cs8427_create);
+
 /*
  * Reset the chip using run bit, also lock PLL using ILRCK and
  * put back AES3INPUT. This workaround is described in latest
@@ -296,7 +314,8 @@ static void snd_cs8427_reset(struct snd_i2c_device *cs8427)
 	snd_assert(cs8427, return);
 	chip = cs8427->private_data;
 	snd_i2c_lock(cs8427->bus);
-	if ((chip->regmap[CS8427_REG_CLOCKSOURCE] & CS8427_RXDAES3INPUT) == CS8427_RXDAES3INPUT)  /* AES3 bit is set */
+	if ((chip->regmap[CS8427_REG_CLOCKSOURCE] & CS8427_RXDAES3INPUT) ==
+	    CS8427_RXDAES3INPUT)  /* AES3 bit is set */
 		aes3input = 1;
 	chip->regmap[CS8427_REG_CLOCKSOURCE] &= ~(CS8427_RUN | CS8427_RXDMASK);
 	snd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE,
@@ -367,12 +386,15 @@ static int snd_cs8427_qsubcode_get(struct snd_kcontrol *kcontrol,
 
 	snd_i2c_lock(device->bus);
 	if ((err = snd_i2c_sendbytes(device, &reg, 1)) != 1) {
-		snd_printk(KERN_ERR "unable to send register 0x%x byte to CS8427\n", reg);
+		snd_printk(KERN_ERR "unable to send register 0x%x byte "
+			   "to CS8427\n", reg);
 		snd_i2c_unlock(device->bus);
 		return err < 0 ? err : -EIO;
 	}
-	if ((err = snd_i2c_readbytes(device, ucontrol->value.bytes.data, 10)) != 10) {
-		snd_printk(KERN_ERR "unable to read Q-subcode bytes from CS8427\n");
+	err = snd_i2c_readbytes(device, ucontrol->value.bytes.data, 10);
+	if (err != 10) {
+		snd_printk(KERN_ERR "unable to read Q-subcode bytes "
+			   "from CS8427\n");
 		snd_i2c_unlock(device->bus);
 		return err < 0 ? err : -EIO;
 	}
@@ -380,7 +402,8 @@ static int snd_cs8427_qsubcode_get(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static int snd_cs8427_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+static int snd_cs8427_spdif_info(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
@@ -413,7 +436,8 @@ static int snd_cs8427_spdif_put(struct snd_kcontrol *kcontrol,
 	snd_i2c_lock(device->bus);
 	change = memcmp(ucontrol->value.iec958.status, status, 24) != 0;
 	memcpy(status, ucontrol->value.iec958.status, 24);
-	if (change && (kcontrol->private_value ? runtime != NULL : runtime == NULL)) {
+	if (change && (kcontrol->private_value ?
+		       runtime != NULL : runtime == NULL)) {
 		err = snd_cs8427_send_corudata(device, 0, status, 24);
 		if (err < 0)
 			change = err;
@@ -442,7 +466,8 @@ static struct snd_kcontrol_new snd_cs8427_iec958_controls[] = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.info =		snd_cs8427_in_status_info,
 	.name =		"IEC958 CS8427 Input Status",
-	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READ |
+			 SNDRV_CTL_ELEM_ACCESS_VOLATILE),
 	.get =		snd_cs8427_in_status_get,
 	.private_value = 15,
 },
@@ -450,7 +475,8 @@ static struct snd_kcontrol_new snd_cs8427_iec958_controls[] = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.info =		snd_cs8427_in_status_info,
 	.name =		"IEC958 CS8427 Error Status",
-	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READ |
+			 SNDRV_CTL_ELEM_ACCESS_VOLATILE),
 	.get =		snd_cs8427_in_status_get,
 	.private_value = 16,
 },
@@ -470,7 +496,8 @@ static struct snd_kcontrol_new snd_cs8427_iec958_controls[] = {
 	.private_value = 0
 },
 {
-	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			 SNDRV_CTL_ELEM_ACCESS_INACTIVE),
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM),
 	.info =		snd_cs8427_spdif_info,
@@ -482,7 +509,8 @@ static struct snd_kcontrol_new snd_cs8427_iec958_controls[] = {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.info =		snd_cs8427_qsubcode_info,
 	.name =		"IEC958 Q-subcode Capture Default",
-	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.access =	(SNDRV_CTL_ELEM_ACCESS_READ |
+			 SNDRV_CTL_ELEM_ACCESS_VOLATILE),
 	.get =		snd_cs8427_qsubcode_get
 }};
 
@@ -505,7 +533,8 @@ int snd_cs8427_iec958_build(struct snd_i2c_device *cs8427,
 		err = snd_ctl_add(cs8427->bus->card, kctl);
 		if (err < 0)
 			return err;
-		if (!strcmp(kctl->id.name, SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM)))
+		if (! strcmp(kctl->id.name,
+			     SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM)))
 			chip->playback.pcm_ctl = kctl;
 	}
 
@@ -515,6 +544,8 @@ int snd_cs8427_iec958_build(struct snd_i2c_device *cs8427,
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_cs8427_iec958_build);
+
 int snd_cs8427_iec958_active(struct snd_i2c_device *cs8427, int active)
 {
 	struct cs8427 *chip;
@@ -522,13 +553,17 @@ int snd_cs8427_iec958_active(struct snd_i2c_device *cs8427, int active)
 	snd_assert(cs8427, return -ENXIO);
 	chip = cs8427->private_data;
 	if (active)
-		memcpy(chip->playback.pcm_status, chip->playback.def_status, 24);
+		memcpy(chip->playback.pcm_status,
+		       chip->playback.def_status, 24);
 	chip->playback.pcm_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
-	snd_ctl_notify(cs8427->bus->card, SNDRV_CTL_EVENT_MASK_VALUE |
-					  SNDRV_CTL_EVENT_MASK_INFO, &chip->playback.pcm_ctl->id);
+	snd_ctl_notify(cs8427->bus->card,
+		       SNDRV_CTL_EVENT_MASK_VALUE | SNDRV_CTL_EVENT_MASK_INFO,
+		       &chip->playback.pcm_ctl->id);
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_cs8427_iec958_active);
+
 int snd_cs8427_iec958_pcm(struct snd_i2c_device *cs8427, unsigned int rate)
 {
 	struct cs8427 *chip;
@@ -568,6 +603,8 @@ int snd_cs8427_iec958_pcm(struct snd_i2c_device *cs8427, unsigned int rate)
 	return err < 0 ? err : 0;
 }
 
+EXPORT_SYMBOL(snd_cs8427_iec958_pcm);
+
 static int __init alsa_cs8427_module_init(void)
 {
 	return 0;
@@ -579,9 +616,3 @@ static void __exit alsa_cs8427_module_exit(void)
 
 module_init(alsa_cs8427_module_init)
 module_exit(alsa_cs8427_module_exit)
-
-EXPORT_SYMBOL(snd_cs8427_create);
-EXPORT_SYMBOL(snd_cs8427_reg_write);
-EXPORT_SYMBOL(snd_cs8427_iec958_build);
-EXPORT_SYMBOL(snd_cs8427_iec958_active);
-EXPORT_SYMBOL(snd_cs8427_iec958_pcm);

commit 7fd37481b1e26edc36a011a3760f10c34fffda37
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Jun 30 13:52:24 2006 +0200

    [ALSA] sound/i2c/cs8427.c: don't export a static function
    
    Static functions shouldn't be exported.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index cb89f7eb9236..700c35b741e3 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -581,7 +581,6 @@ module_init(alsa_cs8427_module_init)
 module_exit(alsa_cs8427_module_exit)
 
 EXPORT_SYMBOL(snd_cs8427_create);
-EXPORT_SYMBOL(snd_cs8427_reset);
 EXPORT_SYMBOL(snd_cs8427_reg_write);
 EXPORT_SYMBOL(snd_cs8427_iec958_build);
 EXPORT_SYMBOL(snd_cs8427_iec958_active);

commit e957ebf164e880ddb0c057418195db47d013c4ac
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Thu Feb 2 07:56:54 2006 +0100

    [ALSA] ice1712 & cs8427 - fix problem for S/PDIF input setup
    
    Modules: I2C cs8427,ICE1712 driver
    
    See ALSA bug#1785 for more details.
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index 9deba80a587c..cb89f7eb9236 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -291,11 +291,13 @@ static void snd_cs8427_reset(struct snd_i2c_device *cs8427)
 {
 	struct cs8427 *chip;
 	unsigned long end_time;
-	int data;
+	int data, aes3input = 0;
 
 	snd_assert(cs8427, return);
 	chip = cs8427->private_data;
 	snd_i2c_lock(cs8427->bus);
+	if ((chip->regmap[CS8427_REG_CLOCKSOURCE] & CS8427_RXDAES3INPUT) == CS8427_RXDAES3INPUT)  /* AES3 bit is set */
+		aes3input = 1;
 	chip->regmap[CS8427_REG_CLOCKSOURCE] &= ~(CS8427_RUN | CS8427_RXDMASK);
 	snd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE,
 			     chip->regmap[CS8427_REG_CLOCKSOURCE]);
@@ -316,7 +318,8 @@ static void snd_cs8427_reset(struct snd_i2c_device *cs8427)
 	}
 	snd_i2c_lock(cs8427->bus);
 	chip->regmap[CS8427_REG_CLOCKSOURCE] &= ~CS8427_RXDMASK;
-	chip->regmap[CS8427_REG_CLOCKSOURCE] |= CS8427_RXDAES3INPUT;
+	if (aes3input)
+		chip->regmap[CS8427_REG_CLOCKSOURCE] |= CS8427_RXDAES3INPUT;
 	snd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE,
 			     chip->regmap[CS8427_REG_CLOCKSOURCE]);
 	snd_i2c_unlock(cs8427->bus);

commit 97f02e05f246a2346275c1c93a3079e8933e74b2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:17:19 2005 +0100

    [ALSA] Remove xxx_t typedefs: I2C drivers
    
    Remove xxx_t typedefs from the i2c drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index 1a05cfbdc7c6..9deba80a587c 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -30,7 +30,7 @@
 #include <sound/cs8427.h>
 #include <sound/asoundef.h>
 
-static void snd_cs8427_reset(snd_i2c_device_t *cs8427);
+static void snd_cs8427_reset(struct snd_i2c_device *cs8427);
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
 MODULE_DESCRIPTION("IEC958 (S/PDIF) receiver & transmitter by Cirrus Logic");
@@ -38,22 +38,22 @@ MODULE_LICENSE("GPL");
 
 #define CS8427_ADDR			(0x20>>1) /* fixed address */
 
-typedef struct {
-	snd_pcm_substream_t *substream;
+struct cs8427_stream {
+	struct snd_pcm_substream *substream;
 	char hw_status[24];		/* hardware status */
 	char def_status[24];		/* default status */
 	char pcm_status[24];		/* PCM private status */
 	char hw_udata[32];
-	snd_kcontrol_t *pcm_ctl;
-} cs8427_stream_t;
+	struct snd_kcontrol *pcm_ctl;
+};
 
-typedef struct {
+struct cs8427 {
 	unsigned char regmap[0x14];	/* map of first 1 + 13 registers */
 	unsigned int rate;
 	unsigned int reset_timeout;
-	cs8427_stream_t playback;
-	cs8427_stream_t capture;
-} cs8427_t;
+	struct cs8427_stream playback;
+	struct cs8427_stream capture;
+};
 
 static unsigned char swapbits(unsigned char val)
 {
@@ -67,7 +67,8 @@ static unsigned char swapbits(unsigned char val)
 	return res;
 }
 
-int snd_cs8427_reg_write(snd_i2c_device_t *device, unsigned char reg, unsigned char val)
+int snd_cs8427_reg_write(struct snd_i2c_device *device, unsigned char reg,
+			 unsigned char val)
 {
 	int err;
 	unsigned char buf[2];
@@ -81,7 +82,7 @@ int snd_cs8427_reg_write(snd_i2c_device_t *device, unsigned char reg, unsigned c
 	return 0;
 }
 
-static int snd_cs8427_reg_read(snd_i2c_device_t *device, unsigned char reg)
+static int snd_cs8427_reg_read(struct snd_i2c_device *device, unsigned char reg)
 {
 	int err;
 	unsigned char buf;
@@ -97,28 +98,29 @@ static int snd_cs8427_reg_read(snd_i2c_device_t *device, unsigned char reg)
 	return buf;
 }
 
-static int snd_cs8427_select_corudata(snd_i2c_device_t *device, int udata)
+static int snd_cs8427_select_corudata(struct snd_i2c_device *device, int udata)
 {
-	cs8427_t *chip = device->private_data;
+	struct cs8427 *chip = device->private_data;
 	int err;
 
 	udata = udata ? CS8427_BSEL : 0;
 	if (udata != (chip->regmap[CS8427_REG_CSDATABUF] & udata)) {
 		chip->regmap[CS8427_REG_CSDATABUF] &= ~CS8427_BSEL;
 		chip->regmap[CS8427_REG_CSDATABUF] |= udata;
-		err = snd_cs8427_reg_write(device, CS8427_REG_CSDATABUF, chip->regmap[CS8427_REG_CSDATABUF]);
+		err = snd_cs8427_reg_write(device, CS8427_REG_CSDATABUF,
+					   chip->regmap[CS8427_REG_CSDATABUF]);
 		if (err < 0)
 			return err;
 	}
 	return 0;
 }
 
-static int snd_cs8427_send_corudata(snd_i2c_device_t *device,
+static int snd_cs8427_send_corudata(struct snd_i2c_device *device,
 				    int udata,
 				    unsigned char *ndata,
 				    int count)
 {
-	cs8427_t *chip = device->private_data;
+	struct cs8427 *chip = device->private_data;
 	char *hw_data = udata ? chip->playback.hw_udata : chip->playback.hw_status;
 	char data[32];
 	int err, idx;
@@ -133,7 +135,8 @@ static int snd_cs8427_send_corudata(snd_i2c_device_t *device,
 		if (memcmp(hw_data, data, count) == 0) {
 			chip->regmap[CS8427_REG_UDATABUF] &= ~CS8427_UBMMASK;
 			chip->regmap[CS8427_REG_UDATABUF] |= CS8427_UBMZEROS | CS8427_EFTUI;
-			if ((err = snd_cs8427_reg_write(device, CS8427_REG_UDATABUF, chip->regmap[CS8427_REG_UDATABUF])) < 0)
+			if ((err = snd_cs8427_reg_write(device, CS8427_REG_UDATABUF,
+							chip->regmap[CS8427_REG_UDATABUF])) < 0)
 				return err;
 			return 0;
 		}
@@ -146,15 +149,15 @@ static int snd_cs8427_send_corudata(snd_i2c_device_t *device,
 	return 1;
 }
 
-static void snd_cs8427_free(snd_i2c_device_t *device)
+static void snd_cs8427_free(struct snd_i2c_device *device)
 {
 	kfree(device->private_data);
 }
 
-int snd_cs8427_create(snd_i2c_bus_t *bus,
+int snd_cs8427_create(struct snd_i2c_bus *bus,
 		      unsigned char addr,
 		      unsigned int reset_timeout,
-		      snd_i2c_device_t **r_cs8427)
+		      struct snd_i2c_device **r_cs8427)
 {
 	static unsigned char initvals1[] = {
 	  CS8427_REG_CONTROL1 | CS8427_REG_AUTOINC,
@@ -194,11 +197,12 @@ int snd_cs8427_create(snd_i2c_bus_t *bus,
 	  CS8427_UD | CS8427_EFTUI | CS8427_DETUI,
 	};
 	int err;
-	cs8427_t *chip;
-	snd_i2c_device_t *device;
+	struct cs8427 *chip;
+	struct snd_i2c_device *device;
 	unsigned char buf[24];
 
-	if ((err = snd_i2c_device_create(bus, "CS8427", CS8427_ADDR | (addr & 7), &device)) < 0)
+	if ((err = snd_i2c_device_create(bus, "CS8427", CS8427_ADDR | (addr & 7),
+					 &device)) < 0)
 		return err;
 	chip = device->private_data = kzalloc(sizeof(*chip), GFP_KERNEL);
 	if (chip == NULL) {
@@ -208,9 +212,13 @@ int snd_cs8427_create(snd_i2c_bus_t *bus,
 	device->private_free = snd_cs8427_free;
 	
 	snd_i2c_lock(bus);
-	if ((err = snd_cs8427_reg_read(device, CS8427_REG_ID_AND_VER)) != CS8427_VER8427A) {
+	if ((err = snd_cs8427_reg_read(device, CS8427_REG_ID_AND_VER)) !=
+	    CS8427_VER8427A) {
 		snd_i2c_unlock(bus);
-		snd_printk(KERN_ERR "unable to find CS8427 signature (expected 0x%x, read 0x%x), initialization is not completed\n", CS8427_VER8427A, err);
+		snd_printk(KERN_ERR "unable to find CS8427 signature "
+			   "(expected 0x%x, read 0x%x),\n",
+			   CS8427_VER8427A, err);
+		snd_printk(KERN_ERR "   initialization is not completed\n");
 		return -EFAULT;
 	}
 	/* turn off run bit while making changes to configuration */
@@ -279,9 +287,9 @@ int snd_cs8427_create(snd_i2c_bus_t *bus,
  * put back AES3INPUT. This workaround is described in latest
  * CS8427 datasheet, otherwise TXDSERIAL will not work.
  */
-static void snd_cs8427_reset(snd_i2c_device_t *cs8427)
+static void snd_cs8427_reset(struct snd_i2c_device *cs8427)
 {
-	cs8427_t *chip;
+	struct cs8427 *chip;
 	unsigned long end_time;
 	int data;
 
@@ -289,10 +297,12 @@ static void snd_cs8427_reset(snd_i2c_device_t *cs8427)
 	chip = cs8427->private_data;
 	snd_i2c_lock(cs8427->bus);
 	chip->regmap[CS8427_REG_CLOCKSOURCE] &= ~(CS8427_RUN | CS8427_RXDMASK);
-	snd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE, chip->regmap[CS8427_REG_CLOCKSOURCE]);
+	snd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE,
+			     chip->regmap[CS8427_REG_CLOCKSOURCE]);
 	udelay(200);
 	chip->regmap[CS8427_REG_CLOCKSOURCE] |= CS8427_RUN | CS8427_RXDILRCK;
-	snd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE, chip->regmap[CS8427_REG_CLOCKSOURCE]);
+	snd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE,
+			     chip->regmap[CS8427_REG_CLOCKSOURCE]);
 	udelay(200);
 	snd_i2c_unlock(cs8427->bus);
 	end_time = jiffies + chip->reset_timeout;
@@ -307,12 +317,13 @@ static void snd_cs8427_reset(snd_i2c_device_t *cs8427)
 	snd_i2c_lock(cs8427->bus);
 	chip->regmap[CS8427_REG_CLOCKSOURCE] &= ~CS8427_RXDMASK;
 	chip->regmap[CS8427_REG_CLOCKSOURCE] |= CS8427_RXDAES3INPUT;
-	snd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE, chip->regmap[CS8427_REG_CLOCKSOURCE]);
+	snd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE,
+			     chip->regmap[CS8427_REG_CLOCKSOURCE]);
 	snd_i2c_unlock(cs8427->bus);
 }
 
-static int snd_cs8427_in_status_info(snd_kcontrol_t *kcontrol,
-				     snd_ctl_elem_info_t *uinfo)
+static int snd_cs8427_in_status_info(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
@@ -321,10 +332,10 @@ static int snd_cs8427_in_status_info(snd_kcontrol_t *kcontrol,
 	return 0;
 }
 
-static int snd_cs8427_in_status_get(snd_kcontrol_t *kcontrol,
-				    snd_ctl_elem_value_t *ucontrol)
+static int snd_cs8427_in_status_get(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
 {
-	snd_i2c_device_t *device = snd_kcontrol_chip(kcontrol);
+	struct snd_i2c_device *device = snd_kcontrol_chip(kcontrol);
 	int data;
 
 	snd_i2c_lock(device->bus);
@@ -336,18 +347,18 @@ static int snd_cs8427_in_status_get(snd_kcontrol_t *kcontrol,
 	return 0;
 }
 
-static int snd_cs8427_qsubcode_info(snd_kcontrol_t *kcontrol,
-				    snd_ctl_elem_info_t *uinfo)
+static int snd_cs8427_qsubcode_info(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
 	uinfo->count = 10;
 	return 0;
 }
 
-static int snd_cs8427_qsubcode_get(snd_kcontrol_t *kcontrol,
-				   snd_ctl_elem_value_t *ucontrol)
+static int snd_cs8427_qsubcode_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
 {
-	snd_i2c_device_t *device = snd_kcontrol_chip(kcontrol);
+	struct snd_i2c_device *device = snd_kcontrol_chip(kcontrol);
 	unsigned char reg = CS8427_REG_QSUBCODE;
 	int err;
 
@@ -366,18 +377,18 @@ static int snd_cs8427_qsubcode_get(snd_kcontrol_t *kcontrol,
 	return 0;
 }
 
-static int snd_cs8427_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_cs8427_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_cs8427_spdif_get(snd_kcontrol_t * kcontrol,
-				snd_ctl_elem_value_t * ucontrol)
+static int snd_cs8427_spdif_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	snd_i2c_device_t *device = snd_kcontrol_chip(kcontrol);
-	cs8427_t *chip = device->private_data;
+	struct snd_i2c_device *device = snd_kcontrol_chip(kcontrol);
+	struct cs8427 *chip = device->private_data;
 	
 	snd_i2c_lock(device->bus);
 	memcpy(ucontrol->value.iec958.status, chip->playback.def_status, 24);
@@ -385,13 +396,15 @@ static int snd_cs8427_spdif_get(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_cs8427_spdif_put(snd_kcontrol_t * kcontrol,
-				snd_ctl_elem_value_t * ucontrol)
+static int snd_cs8427_spdif_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	snd_i2c_device_t *device = snd_kcontrol_chip(kcontrol);
-	cs8427_t *chip = device->private_data;
-	unsigned char *status = kcontrol->private_value ? chip->playback.pcm_status : chip->playback.def_status;
-	snd_pcm_runtime_t *runtime = chip->playback.substream ? chip->playback.substream->runtime : NULL;
+	struct snd_i2c_device *device = snd_kcontrol_chip(kcontrol);
+	struct cs8427 *chip = device->private_data;
+	unsigned char *status = kcontrol->private_value ?
+		chip->playback.pcm_status : chip->playback.def_status;
+	struct snd_pcm_runtime *runtime = chip->playback.substream ?
+		chip->playback.substream->runtime : NULL;
 	int err, change;
 
 	snd_i2c_lock(device->bus);
@@ -406,21 +419,22 @@ static int snd_cs8427_spdif_put(snd_kcontrol_t * kcontrol,
 	return change;
 }
 
-static int snd_cs8427_spdif_mask_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_cs8427_spdif_mask_info(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_cs8427_spdif_mask_get(snd_kcontrol_t * kcontrol,
-				      snd_ctl_elem_value_t * ucontrol)
+static int snd_cs8427_spdif_mask_get(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
 {
 	memset(ucontrol->value.iec958.status, 0xff, 24);
 	return 0;
 }
 
-static snd_kcontrol_new_t snd_cs8427_iec958_controls[] = {
+static struct snd_kcontrol_new snd_cs8427_iec958_controls[] = {
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.info =		snd_cs8427_in_status_info,
@@ -469,12 +483,12 @@ static snd_kcontrol_new_t snd_cs8427_iec958_controls[] = {
 	.get =		snd_cs8427_qsubcode_get
 }};
 
-int snd_cs8427_iec958_build(snd_i2c_device_t *cs8427,
-			    snd_pcm_substream_t *play_substream,
-			    snd_pcm_substream_t *cap_substream)
+int snd_cs8427_iec958_build(struct snd_i2c_device *cs8427,
+			    struct snd_pcm_substream *play_substream,
+			    struct snd_pcm_substream *cap_substream)
 {
-	cs8427_t *chip = cs8427->private_data;
-	snd_kcontrol_t *kctl;
+	struct cs8427 *chip = cs8427->private_data;
+	struct snd_kcontrol *kctl;
 	unsigned int idx;
 	int err;
 
@@ -498,9 +512,9 @@ int snd_cs8427_iec958_build(snd_i2c_device_t *cs8427,
 	return 0;
 }
 
-int snd_cs8427_iec958_active(snd_i2c_device_t *cs8427, int active)
+int snd_cs8427_iec958_active(struct snd_i2c_device *cs8427, int active)
 {
-	cs8427_t *chip;
+	struct cs8427 *chip;
 
 	snd_assert(cs8427, return -ENXIO);
 	chip = cs8427->private_data;
@@ -512,9 +526,9 @@ int snd_cs8427_iec958_active(snd_i2c_device_t *cs8427, int active)
 	return 0;
 }
 
-int snd_cs8427_iec958_pcm(snd_i2c_device_t *cs8427, unsigned int rate)
+int snd_cs8427_iec958_pcm(struct snd_i2c_device *cs8427, unsigned int rate)
 {
-	cs8427_t *chip;
+	struct cs8427 *chip;
 	char *status;
 	int err, reset;
 

commit 8433a509c0eb6bb1f33ce39c82c580b8901619ee
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Mon Oct 24 15:02:37 2005 +0200

    [ALSA] Fix schedule_timeout usage
    
    Use schedule_timeout_{,un}interruptible() instead of
    set_current_state()/schedule_timeout() to reduce kernel size.  Also use
    human-time conversion functions instead of hard-coded division to avoid
    rounding issues.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index 21133eb6e881..1a05cfbdc7c6 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -302,8 +302,7 @@ static void snd_cs8427_reset(snd_i2c_device_t *cs8427)
 		snd_i2c_unlock(cs8427->bus);
 		if (!(data & CS8427_UNLOCK))
 			break;
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_timeout_uninterruptible(1);
 	}
 	snd_i2c_lock(cs8427->bus);
 	chip->regmap[CS8427_REG_CLOCKSOURCE] &= ~CS8427_RXDMASK;

commit 99b359ba10a582148c6725f428a33ba5356dd993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 20 18:26:44 2005 +0200

    [ALSA] Add missing KERN_* suffix to printk
    
    Add missing KERN_* suffix to printk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index a21f7d541f86..21133eb6e881 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -75,7 +75,7 @@ int snd_cs8427_reg_write(snd_i2c_device_t *device, unsigned char reg, unsigned c
 	buf[0] = reg & 0x7f;
 	buf[1] = val;
 	if ((err = snd_i2c_sendbytes(device, buf, 2)) != 2) {
-		snd_printk("unable to send bytes 0x%02x:0x%02x to CS8427 (%i)\n", buf[0], buf[1], err);
+		snd_printk(KERN_ERR "unable to send bytes 0x%02x:0x%02x to CS8427 (%i)\n", buf[0], buf[1], err);
 		return err < 0 ? err : -EIO;
 	}
 	return 0;
@@ -87,11 +87,11 @@ static int snd_cs8427_reg_read(snd_i2c_device_t *device, unsigned char reg)
 	unsigned char buf;
 
 	if ((err = snd_i2c_sendbytes(device, &reg, 1)) != 1) {
-		snd_printk("unable to send register 0x%x byte to CS8427\n", reg);
+		snd_printk(KERN_ERR "unable to send register 0x%x byte to CS8427\n", reg);
 		return err < 0 ? err : -EIO;
 	}
 	if ((err = snd_i2c_readbytes(device, &buf, 1)) != 1) {
-		snd_printk("unable to read register 0x%x byte from CS8427\n", reg);
+		snd_printk(KERN_ERR "unable to read register 0x%x byte from CS8427\n", reg);
 		return err < 0 ? err : -EIO;
 	}
 	return buf;
@@ -210,7 +210,7 @@ int snd_cs8427_create(snd_i2c_bus_t *bus,
 	snd_i2c_lock(bus);
 	if ((err = snd_cs8427_reg_read(device, CS8427_REG_ID_AND_VER)) != CS8427_VER8427A) {
 		snd_i2c_unlock(bus);
-		snd_printk("unable to find CS8427 signature (expected 0x%x, read 0x%x), initialization is not completed\n", CS8427_VER8427A, err);
+		snd_printk(KERN_ERR "unable to find CS8427 signature (expected 0x%x, read 0x%x), initialization is not completed\n", CS8427_VER8427A, err);
 		return -EFAULT;
 	}
 	/* turn off run bit while making changes to configuration */
@@ -260,7 +260,7 @@ int snd_cs8427_create(snd_i2c_bus_t *bus,
 	snd_i2c_sendbytes(device, buf, 1);
 	snd_i2c_readbytes(device, buf, 127);
 	for (xx = 0; xx < 127; xx++)
-		printk("reg[0x%x] = 0x%x\n", xx+1, buf[xx]);
+		printk(KERN_DEBUG "reg[0x%x] = 0x%x\n", xx+1, buf[xx]);
 	}
 #endif
 	
@@ -354,12 +354,12 @@ static int snd_cs8427_qsubcode_get(snd_kcontrol_t *kcontrol,
 
 	snd_i2c_lock(device->bus);
 	if ((err = snd_i2c_sendbytes(device, &reg, 1)) != 1) {
-		snd_printk("unable to send register 0x%x byte to CS8427\n", reg);
+		snd_printk(KERN_ERR "unable to send register 0x%x byte to CS8427\n", reg);
 		snd_i2c_unlock(device->bus);
 		return err < 0 ? err : -EIO;
 	}
 	if ((err = snd_i2c_readbytes(device, ucontrol->value.bytes.data, 10)) != 10) {
-		snd_printk("unable to read Q-subcode bytes from CS8427\n");
+		snd_printk(KERN_ERR "unable to read Q-subcode bytes from CS8427\n");
 		snd_i2c_unlock(device->bus);
 		return err < 0 ? err : -EIO;
 	}

commit 561b220a4dece18d67177413e6fa21b49aa4acce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:22:34 2005 +0200

    [ALSA] Replace with kzalloc() - others
    
    Documentation,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,OPL3
    OPL4,Digigram VX core,I2C cs8427,I2C lib core,I2C tea6330t,L3 drivers
    AK4114 receiver,AK4117 receiver,PDAudioCF driver,PPC PMAC driver
    SPARC AMD7930 driver,SPARC cs4231 driver,Synth,Common EMU synth
    USB generic driver,USB USX2Y
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
index a3fda859dd15..a21f7d541f86 100644
--- a/sound/i2c/cs8427.c
+++ b/sound/i2c/cs8427.c
@@ -200,7 +200,7 @@ int snd_cs8427_create(snd_i2c_bus_t *bus,
 
 	if ((err = snd_i2c_device_create(bus, "CS8427", CS8427_ADDR | (addr & 7), &device)) < 0)
 		return err;
-	chip = device->private_data = kcalloc(1, sizeof(*chip), GFP_KERNEL);
+	chip = device->private_data = kzalloc(sizeof(*chip), GFP_KERNEL);
 	if (chip == NULL) {
 	      	snd_i2c_device_free(device);
 		return -ENOMEM;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/i2c/cs8427.c b/sound/i2c/cs8427.c
new file mode 100644
index 000000000000..a3fda859dd15
--- /dev/null
+++ b/sound/i2c/cs8427.c
@@ -0,0 +1,572 @@
+/*
+ *  Routines for control of the CS8427 via i2c bus
+ *  IEC958 (S/PDIF) receiver & transmitter by Cirrus Logic
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/cs8427.h>
+#include <sound/asoundef.h>
+
+static void snd_cs8427_reset(snd_i2c_device_t *cs8427);
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_DESCRIPTION("IEC958 (S/PDIF) receiver & transmitter by Cirrus Logic");
+MODULE_LICENSE("GPL");
+
+#define CS8427_ADDR			(0x20>>1) /* fixed address */
+
+typedef struct {
+	snd_pcm_substream_t *substream;
+	char hw_status[24];		/* hardware status */
+	char def_status[24];		/* default status */
+	char pcm_status[24];		/* PCM private status */
+	char hw_udata[32];
+	snd_kcontrol_t *pcm_ctl;
+} cs8427_stream_t;
+
+typedef struct {
+	unsigned char regmap[0x14];	/* map of first 1 + 13 registers */
+	unsigned int rate;
+	unsigned int reset_timeout;
+	cs8427_stream_t playback;
+	cs8427_stream_t capture;
+} cs8427_t;
+
+static unsigned char swapbits(unsigned char val)
+{
+	int bit;
+	unsigned char res = 0;
+	for (bit = 0; bit < 8; bit++) {
+		res <<= 1;
+		res |= val & 1;
+		val >>= 1;
+	}
+	return res;
+}
+
+int snd_cs8427_reg_write(snd_i2c_device_t *device, unsigned char reg, unsigned char val)
+{
+	int err;
+	unsigned char buf[2];
+
+	buf[0] = reg & 0x7f;
+	buf[1] = val;
+	if ((err = snd_i2c_sendbytes(device, buf, 2)) != 2) {
+		snd_printk("unable to send bytes 0x%02x:0x%02x to CS8427 (%i)\n", buf[0], buf[1], err);
+		return err < 0 ? err : -EIO;
+	}
+	return 0;
+}
+
+static int snd_cs8427_reg_read(snd_i2c_device_t *device, unsigned char reg)
+{
+	int err;
+	unsigned char buf;
+
+	if ((err = snd_i2c_sendbytes(device, &reg, 1)) != 1) {
+		snd_printk("unable to send register 0x%x byte to CS8427\n", reg);
+		return err < 0 ? err : -EIO;
+	}
+	if ((err = snd_i2c_readbytes(device, &buf, 1)) != 1) {
+		snd_printk("unable to read register 0x%x byte from CS8427\n", reg);
+		return err < 0 ? err : -EIO;
+	}
+	return buf;
+}
+
+static int snd_cs8427_select_corudata(snd_i2c_device_t *device, int udata)
+{
+	cs8427_t *chip = device->private_data;
+	int err;
+
+	udata = udata ? CS8427_BSEL : 0;
+	if (udata != (chip->regmap[CS8427_REG_CSDATABUF] & udata)) {
+		chip->regmap[CS8427_REG_CSDATABUF] &= ~CS8427_BSEL;
+		chip->regmap[CS8427_REG_CSDATABUF] |= udata;
+		err = snd_cs8427_reg_write(device, CS8427_REG_CSDATABUF, chip->regmap[CS8427_REG_CSDATABUF]);
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+static int snd_cs8427_send_corudata(snd_i2c_device_t *device,
+				    int udata,
+				    unsigned char *ndata,
+				    int count)
+{
+	cs8427_t *chip = device->private_data;
+	char *hw_data = udata ? chip->playback.hw_udata : chip->playback.hw_status;
+	char data[32];
+	int err, idx;
+
+	if (!memcmp(hw_data, ndata, count))
+		return 0;
+	if ((err = snd_cs8427_select_corudata(device, udata)) < 0)
+		return err;
+	memcpy(hw_data, ndata, count);
+	if (udata) {
+		memset(data, 0, sizeof(data));
+		if (memcmp(hw_data, data, count) == 0) {
+			chip->regmap[CS8427_REG_UDATABUF] &= ~CS8427_UBMMASK;
+			chip->regmap[CS8427_REG_UDATABUF] |= CS8427_UBMZEROS | CS8427_EFTUI;
+			if ((err = snd_cs8427_reg_write(device, CS8427_REG_UDATABUF, chip->regmap[CS8427_REG_UDATABUF])) < 0)
+				return err;
+			return 0;
+		}
+	}
+	data[0] = CS8427_REG_AUTOINC | CS8427_REG_CORU_DATABUF;
+	for (idx = 0; idx < count; idx++)
+		data[idx + 1] = swapbits(ndata[idx]);
+	if (snd_i2c_sendbytes(device, data, count + 1) != count + 1)
+		return -EIO;
+	return 1;
+}
+
+static void snd_cs8427_free(snd_i2c_device_t *device)
+{
+	kfree(device->private_data);
+}
+
+int snd_cs8427_create(snd_i2c_bus_t *bus,
+		      unsigned char addr,
+		      unsigned int reset_timeout,
+		      snd_i2c_device_t **r_cs8427)
+{
+	static unsigned char initvals1[] = {
+	  CS8427_REG_CONTROL1 | CS8427_REG_AUTOINC,
+	  /* CS8427_REG_CONTROL1: RMCK to OMCK, valid PCM audio, disable mutes, TCBL=output */
+	  CS8427_SWCLK | CS8427_TCBLDIR,
+	  /* CS8427_REG_CONTROL2: hold last valid audio sample, RMCK=256*Fs, normal stereo operation */
+	  0x00,
+	  /* CS8427_REG_DATAFLOW: output drivers normal operation, Tx<=serial, Rx=>serial */
+	  CS8427_TXDSERIAL | CS8427_SPDAES3RECEIVER,
+	  /* CS8427_REG_CLOCKSOURCE: Run off, CMCK=256*Fs, output time base = OMCK, input time base =
+	     recovered input clock, recovered input clock source is ILRCK changed to AES3INPUT (workaround, see snd_cs8427_reset) */
+	  CS8427_RXDILRCK,
+	  /* CS8427_REG_SERIALINPUT: Serial audio input port data format = I2S, 24-bit, 64*Fsi */
+	  CS8427_SIDEL | CS8427_SILRPOL,
+	  /* CS8427_REG_SERIALOUTPUT: Serial audio output port data format = I2S, 24-bit, 64*Fsi */
+	  CS8427_SODEL | CS8427_SOLRPOL,
+	};
+	static unsigned char initvals2[] = {
+	  CS8427_REG_RECVERRMASK | CS8427_REG_AUTOINC,
+	  /* CS8427_REG_RECVERRMASK: unmask the input PLL clock, V, confidence, biphase, parity status bits */
+	  /* CS8427_UNLOCK | CS8427_V | CS8427_CONF | CS8427_BIP | CS8427_PAR, */
+	  0xff, /* set everything */
+	  /* CS8427_REG_CSDATABUF:
+	     Registers 32-55 window to CS buffer
+	     Inhibit D->E transfers from overwriting first 5 bytes of CS data.
+	     Inhibit D->E transfers (all) of CS data.
+	     Allow E->F transfer of CS data.
+	     One byte mode; both A/B channels get same written CB data.
+	     A channel info is output to chip's EMPH* pin. */
+	  CS8427_CBMR | CS8427_DETCI,
+	  /* CS8427_REG_UDATABUF:
+	     Use internal buffer to transmit User (U) data.
+	     Chip's U pin is an output.
+	     Transmit all O's for user data.
+	     Inhibit D->E transfers.
+	     Inhibit E->F transfers. */
+	  CS8427_UD | CS8427_EFTUI | CS8427_DETUI,
+	};
+	int err;
+	cs8427_t *chip;
+	snd_i2c_device_t *device;
+	unsigned char buf[24];
+
+	if ((err = snd_i2c_device_create(bus, "CS8427", CS8427_ADDR | (addr & 7), &device)) < 0)
+		return err;
+	chip = device->private_data = kcalloc(1, sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL) {
+	      	snd_i2c_device_free(device);
+		return -ENOMEM;
+	}
+	device->private_free = snd_cs8427_free;
+	
+	snd_i2c_lock(bus);
+	if ((err = snd_cs8427_reg_read(device, CS8427_REG_ID_AND_VER)) != CS8427_VER8427A) {
+		snd_i2c_unlock(bus);
+		snd_printk("unable to find CS8427 signature (expected 0x%x, read 0x%x), initialization is not completed\n", CS8427_VER8427A, err);
+		return -EFAULT;
+	}
+	/* turn off run bit while making changes to configuration */
+	if ((err = snd_cs8427_reg_write(device, CS8427_REG_CLOCKSOURCE, 0x00)) < 0)
+		goto __fail;
+	/* send initial values */
+	memcpy(chip->regmap + (initvals1[0] & 0x7f), initvals1 + 1, 6);
+	if ((err = snd_i2c_sendbytes(device, initvals1, 7)) != 7) {
+		err = err < 0 ? err : -EIO;
+		goto __fail;
+	}
+	/* Turn off CS8427 interrupt stuff that is not used in hardware */
+	memset(buf, 0, 7);
+	/* from address 9 to 15 */
+	buf[0] = 9;	/* register */
+	if ((err = snd_i2c_sendbytes(device, buf, 7)) != 7)
+		goto __fail;
+	/* send transfer initialization sequence */
+	memcpy(chip->regmap + (initvals2[0] & 0x7f), initvals2 + 1, 3);
+	if ((err = snd_i2c_sendbytes(device, initvals2, 4)) != 4) {
+		err = err < 0 ? err : -EIO;
+		goto __fail;
+	}
+	/* write default channel status bytes */
+	buf[0] = ((unsigned char)(SNDRV_PCM_DEFAULT_CON_SPDIF >> 0));
+	buf[1] = ((unsigned char)(SNDRV_PCM_DEFAULT_CON_SPDIF >> 8));
+	buf[2] = ((unsigned char)(SNDRV_PCM_DEFAULT_CON_SPDIF >> 16));
+	buf[3] = ((unsigned char)(SNDRV_PCM_DEFAULT_CON_SPDIF >> 24));
+	memset(buf + 4, 0, 24 - 4);
+	if (snd_cs8427_send_corudata(device, 0, buf, 24) < 0)
+		goto __fail;
+	memcpy(chip->playback.def_status, buf, 24);
+	memcpy(chip->playback.pcm_status, buf, 24);
+	snd_i2c_unlock(bus);
+
+	/* turn on run bit and rock'n'roll */
+	if (reset_timeout < 1)
+		reset_timeout = 1;
+	chip->reset_timeout = reset_timeout;
+	snd_cs8427_reset(device);
+
+#if 0	// it's nice for read tests
+	{
+	char buf[128];
+	int xx;
+	buf[0] = 0x81;
+	snd_i2c_sendbytes(device, buf, 1);
+	snd_i2c_readbytes(device, buf, 127);
+	for (xx = 0; xx < 127; xx++)
+		printk("reg[0x%x] = 0x%x\n", xx+1, buf[xx]);
+	}
+#endif
+	
+	if (r_cs8427)
+		*r_cs8427 = device;
+	return 0;
+
+      __fail:
+      	snd_i2c_unlock(bus);
+      	snd_i2c_device_free(device);
+      	return err < 0 ? err : -EIO;
+}
+
+/*
+ * Reset the chip using run bit, also lock PLL using ILRCK and
+ * put back AES3INPUT. This workaround is described in latest
+ * CS8427 datasheet, otherwise TXDSERIAL will not work.
+ */
+static void snd_cs8427_reset(snd_i2c_device_t *cs8427)
+{
+	cs8427_t *chip;
+	unsigned long end_time;
+	int data;
+
+	snd_assert(cs8427, return);
+	chip = cs8427->private_data;
+	snd_i2c_lock(cs8427->bus);
+	chip->regmap[CS8427_REG_CLOCKSOURCE] &= ~(CS8427_RUN | CS8427_RXDMASK);
+	snd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE, chip->regmap[CS8427_REG_CLOCKSOURCE]);
+	udelay(200);
+	chip->regmap[CS8427_REG_CLOCKSOURCE] |= CS8427_RUN | CS8427_RXDILRCK;
+	snd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE, chip->regmap[CS8427_REG_CLOCKSOURCE]);
+	udelay(200);
+	snd_i2c_unlock(cs8427->bus);
+	end_time = jiffies + chip->reset_timeout;
+	while (time_after_eq(end_time, jiffies)) {
+		snd_i2c_lock(cs8427->bus);
+		data = snd_cs8427_reg_read(cs8427, CS8427_REG_RECVERRORS);
+		snd_i2c_unlock(cs8427->bus);
+		if (!(data & CS8427_UNLOCK))
+			break;
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	}
+	snd_i2c_lock(cs8427->bus);
+	chip->regmap[CS8427_REG_CLOCKSOURCE] &= ~CS8427_RXDMASK;
+	chip->regmap[CS8427_REG_CLOCKSOURCE] |= CS8427_RXDAES3INPUT;
+	snd_cs8427_reg_write(cs8427, CS8427_REG_CLOCKSOURCE, chip->regmap[CS8427_REG_CLOCKSOURCE]);
+	snd_i2c_unlock(cs8427->bus);
+}
+
+static int snd_cs8427_in_status_info(snd_kcontrol_t *kcontrol,
+				     snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 255;
+	return 0;
+}
+
+static int snd_cs8427_in_status_get(snd_kcontrol_t *kcontrol,
+				    snd_ctl_elem_value_t *ucontrol)
+{
+	snd_i2c_device_t *device = snd_kcontrol_chip(kcontrol);
+	int data;
+
+	snd_i2c_lock(device->bus);
+	data = snd_cs8427_reg_read(device, kcontrol->private_value);
+	snd_i2c_unlock(device->bus);
+	if (data < 0)
+		return data;
+	ucontrol->value.integer.value[0] = data;
+	return 0;
+}
+
+static int snd_cs8427_qsubcode_info(snd_kcontrol_t *kcontrol,
+				    snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	uinfo->count = 10;
+	return 0;
+}
+
+static int snd_cs8427_qsubcode_get(snd_kcontrol_t *kcontrol,
+				   snd_ctl_elem_value_t *ucontrol)
+{
+	snd_i2c_device_t *device = snd_kcontrol_chip(kcontrol);
+	unsigned char reg = CS8427_REG_QSUBCODE;
+	int err;
+
+	snd_i2c_lock(device->bus);
+	if ((err = snd_i2c_sendbytes(device, &reg, 1)) != 1) {
+		snd_printk("unable to send register 0x%x byte to CS8427\n", reg);
+		snd_i2c_unlock(device->bus);
+		return err < 0 ? err : -EIO;
+	}
+	if ((err = snd_i2c_readbytes(device, ucontrol->value.bytes.data, 10)) != 10) {
+		snd_printk("unable to read Q-subcode bytes from CS8427\n");
+		snd_i2c_unlock(device->bus);
+		return err < 0 ? err : -EIO;
+	}
+	snd_i2c_unlock(device->bus);
+	return 0;
+}
+
+static int snd_cs8427_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_cs8427_spdif_get(snd_kcontrol_t * kcontrol,
+				snd_ctl_elem_value_t * ucontrol)
+{
+	snd_i2c_device_t *device = snd_kcontrol_chip(kcontrol);
+	cs8427_t *chip = device->private_data;
+	
+	snd_i2c_lock(device->bus);
+	memcpy(ucontrol->value.iec958.status, chip->playback.def_status, 24);
+	snd_i2c_unlock(device->bus);
+	return 0;
+}
+
+static int snd_cs8427_spdif_put(snd_kcontrol_t * kcontrol,
+				snd_ctl_elem_value_t * ucontrol)
+{
+	snd_i2c_device_t *device = snd_kcontrol_chip(kcontrol);
+	cs8427_t *chip = device->private_data;
+	unsigned char *status = kcontrol->private_value ? chip->playback.pcm_status : chip->playback.def_status;
+	snd_pcm_runtime_t *runtime = chip->playback.substream ? chip->playback.substream->runtime : NULL;
+	int err, change;
+
+	snd_i2c_lock(device->bus);
+	change = memcmp(ucontrol->value.iec958.status, status, 24) != 0;
+	memcpy(status, ucontrol->value.iec958.status, 24);
+	if (change && (kcontrol->private_value ? runtime != NULL : runtime == NULL)) {
+		err = snd_cs8427_send_corudata(device, 0, status, 24);
+		if (err < 0)
+			change = err;
+	}
+	snd_i2c_unlock(device->bus);
+	return change;
+}
+
+static int snd_cs8427_spdif_mask_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_cs8427_spdif_mask_get(snd_kcontrol_t * kcontrol,
+				      snd_ctl_elem_value_t * ucontrol)
+{
+	memset(ucontrol->value.iec958.status, 0xff, 24);
+	return 0;
+}
+
+static snd_kcontrol_new_t snd_cs8427_iec958_controls[] = {
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.info =		snd_cs8427_in_status_info,
+	.name =		"IEC958 CS8427 Input Status",
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.get =		snd_cs8427_in_status_get,
+	.private_value = 15,
+},
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.info =		snd_cs8427_in_status_info,
+	.name =		"IEC958 CS8427 Error Status",
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.get =		snd_cs8427_in_status_get,
+	.private_value = 16,
+},
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
+	.info =		snd_cs8427_spdif_mask_info,
+	.get =		snd_cs8427_spdif_mask_get,
+},
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
+	.info =		snd_cs8427_spdif_info,
+	.get =		snd_cs8427_spdif_get,
+	.put =		snd_cs8427_spdif_put,
+	.private_value = 0
+},
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM),
+	.info =		snd_cs8427_spdif_info,
+	.get =		snd_cs8427_spdif_get,
+	.put =		snd_cs8427_spdif_put,
+	.private_value = 1
+},
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.info =		snd_cs8427_qsubcode_info,
+	.name =		"IEC958 Q-subcode Capture Default",
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.get =		snd_cs8427_qsubcode_get
+}};
+
+int snd_cs8427_iec958_build(snd_i2c_device_t *cs8427,
+			    snd_pcm_substream_t *play_substream,
+			    snd_pcm_substream_t *cap_substream)
+{
+	cs8427_t *chip = cs8427->private_data;
+	snd_kcontrol_t *kctl;
+	unsigned int idx;
+	int err;
+
+	snd_assert(play_substream && cap_substream, return -EINVAL);
+	for (idx = 0; idx < ARRAY_SIZE(snd_cs8427_iec958_controls); idx++) {
+		kctl = snd_ctl_new1(&snd_cs8427_iec958_controls[idx], cs8427);
+		if (kctl == NULL)
+			return -ENOMEM;
+		kctl->id.device = play_substream->pcm->device;
+		kctl->id.subdevice = play_substream->number;
+		err = snd_ctl_add(cs8427->bus->card, kctl);
+		if (err < 0)
+			return err;
+		if (!strcmp(kctl->id.name, SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM)))
+			chip->playback.pcm_ctl = kctl;
+	}
+
+	chip->playback.substream = play_substream;
+	chip->capture.substream = cap_substream;
+	snd_assert(chip->playback.pcm_ctl, return -EIO);
+	return 0;
+}
+
+int snd_cs8427_iec958_active(snd_i2c_device_t *cs8427, int active)
+{
+	cs8427_t *chip;
+
+	snd_assert(cs8427, return -ENXIO);
+	chip = cs8427->private_data;
+	if (active)
+		memcpy(chip->playback.pcm_status, chip->playback.def_status, 24);
+	chip->playback.pcm_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+	snd_ctl_notify(cs8427->bus->card, SNDRV_CTL_EVENT_MASK_VALUE |
+					  SNDRV_CTL_EVENT_MASK_INFO, &chip->playback.pcm_ctl->id);
+	return 0;
+}
+
+int snd_cs8427_iec958_pcm(snd_i2c_device_t *cs8427, unsigned int rate)
+{
+	cs8427_t *chip;
+	char *status;
+	int err, reset;
+
+	snd_assert(cs8427, return -ENXIO);
+	chip = cs8427->private_data;
+	status = chip->playback.pcm_status;
+	snd_i2c_lock(cs8427->bus);
+	if (status[0] & IEC958_AES0_PROFESSIONAL) {
+		status[0] &= ~IEC958_AES0_PRO_FS;
+		switch (rate) {
+		case 32000: status[0] |= IEC958_AES0_PRO_FS_32000; break;
+		case 44100: status[0] |= IEC958_AES0_PRO_FS_44100; break;
+		case 48000: status[0] |= IEC958_AES0_PRO_FS_48000; break;
+		default: status[0] |= IEC958_AES0_PRO_FS_NOTID; break;
+		}
+	} else {
+		status[3] &= ~IEC958_AES3_CON_FS;
+		switch (rate) {
+		case 32000: status[3] |= IEC958_AES3_CON_FS_32000; break;
+		case 44100: status[3] |= IEC958_AES3_CON_FS_44100; break;
+		case 48000: status[3] |= IEC958_AES3_CON_FS_48000; break;
+		}
+	}
+	err = snd_cs8427_send_corudata(cs8427, 0, status, 24);
+	if (err > 0)
+		snd_ctl_notify(cs8427->bus->card,
+			       SNDRV_CTL_EVENT_MASK_VALUE,
+			       &chip->playback.pcm_ctl->id);
+	reset = chip->rate != rate;
+	chip->rate = rate;
+	snd_i2c_unlock(cs8427->bus);
+	if (reset)
+		snd_cs8427_reset(cs8427);
+	return err < 0 ? err : 0;
+}
+
+static int __init alsa_cs8427_module_init(void)
+{
+	return 0;
+}
+
+static void __exit alsa_cs8427_module_exit(void)
+{
+}
+
+module_init(alsa_cs8427_module_init)
+module_exit(alsa_cs8427_module_exit)
+
+EXPORT_SYMBOL(snd_cs8427_create);
+EXPORT_SYMBOL(snd_cs8427_reset);
+EXPORT_SYMBOL(snd_cs8427_reg_write);
+EXPORT_SYMBOL(snd_cs8427_iec958_build);
+EXPORT_SYMBOL(snd_cs8427_iec958_active);
+EXPORT_SYMBOL(snd_cs8427_iec958_pcm);
