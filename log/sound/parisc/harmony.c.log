commit fb95aae6e67c4e319a24b3eea32032d4246a5335
Merge: bd2463ac7d7e 90fb04f890bc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 28 16:26:57 2020 -0800

    Merge tag 'sound-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "As the diffstat shows we've had again a lot of works done for this
      cycle: the majority of changes are the continued componentization and
      code refactoring in ASoC, the tree-wide PCM API updates and cleanups
      and SOF updates while a few ASoC driver updates are seen, too.
    
      Here we go, some highlights:
    
      Core:
       - Finally y2038 support landed to ALSA ABI; some ioctls have been
         extended and lots of tricks were applied
       - Applying the new managed PCM buffer API to all drivers; the API
         itself was already merged in 5.5
       - The already deprecated dimension support in ALSA control API is
         dropped completely now
       - Verification of ALSA control elements to catch API misuses
    
      ASoC:
       - Further code refactorings and moving things to the component level
       - Lots of updates and improvements on SOF / Intel drivers; now
         including common HDMI driver and SoundWire support
       - New driver support for Ingenic JZ4770, Mediatek MT6660, Qualcomm
         WCD934x and WSA881x, and Realtek RT700, RT711, RT715, RT1011,
         RT1015 and RT1308
    
      HD-audio:
       - Improved ring-buffer communications using waitqueue
       - Drop the superfluous buffer preallocation on x86
    
      Others:
       - Many code cleanups, mostly constifications over the whole tree
       - USB-audio: quirks for MOTU, Corsair Virtuoso, Line6 Helix
       - FireWire: code refactoring for oxfw and dice drivers"
    
    * tag 'sound-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (638 commits)
      ALSA: usb-audio: add quirks for Line6 Helix devices fw>=2.82
      ALSA: hda: Add Clevo W65_67SB the power_save blacklist
      ASoC: soc-core: remove null_snd_soc_ops
      ASoC: soc-pcm: add soc_rtd_trigger()
      ASoC: soc-pcm: add soc_rtd_hw_free()
      ASoC: soc-pcm: add soc_rtd_hw_params()
      ASoC: soc-pcm: add soc_rtd_prepare()
      ASoC: soc-pcm: add soc_rtd_shutdown()
      ASoC: soc-pcm: add soc_rtd_startup()
      ASoC: rt1015: add rt1015 amplifier driver
      ASoC: madera: Correct some kernel doc
      ASoC: topology: fix soc_tplg_fe_link_create() - link->dobj initialization order
      ASoC: Intel: skl_hda_dsp_common: Fix global-out-of-bounds bug
      ASoC: madera: Correct DMIC only input hook ups
      ALSA: cs46xx: fix spelling mistake "to" -> "too"
      ALSA: hda - Add docking station support for Lenovo Thinkpad T420s
      ASoC: Add MediaTek MT6660 Speaker Amp Driver
      ASoC: dt-bindings: rt5645: add suppliers
      ASoC: max98090: fix deadlock in max98090_dapm_put_enum_double()
      ASoC: dapm: add snd_soc_dapm_put_enum_double_locked
      ...

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 6acc59c25379..0d1eced95f33 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -907,7 +907,7 @@ snd_harmony_create(struct snd_card *card,
 	h->card = card;
 	h->dev = padev;
 	h->irq = -1;
-	h->iobase = ioremap_nocache(padev->hpa.start, HARMONY_SIZE);
+	h->iobase = ioremap(padev->hpa.start, HARMONY_SIZE);
 	if (h->iobase == NULL) {
 		printk(KERN_ERR PFX "unable to remap hpa 0x%lx\n",
 		       (unsigned long)padev->hpa.start);

commit 46708e626d0d768587cf676e55b21e0beb966be6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:58 2020 +0100

    ALSA: parisc: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-43-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index d330f22a3e8f..97241d984c6c 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -797,7 +797,7 @@ snd_harmony_captureroute_put(struct snd_kcontrol *kc,
   .private_value = ((left_shift) | ((right_shift) << 8) |            \
                    ((mask) << 16) | ((invert) << 24)) }
 
-static struct snd_kcontrol_new snd_harmony_controls[] = {
+static const struct snd_kcontrol_new snd_harmony_controls[] = {
 	HARMONY_VOLUME("Master Playback Volume", HARMONY_GAIN_LO_SHIFT, 
 		       HARMONY_GAIN_RO_SHIFT, HARMONY_GAIN_OUT, 1),
 	HARMONY_VOLUME("Capture Volume", HARMONY_GAIN_LI_SHIFT,

commit 65341589599a17465c25ae760e9b317b3596eb8c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:29 2020 +0100

    ALSA: parisc: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-14-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index ea3630217d39..d330f22a3e8f 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -881,7 +881,7 @@ snd_harmony_create(struct snd_card *card,
 {
 	int err;
 	struct snd_harmony *h;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free = snd_harmony_dev_free,
 	};
 

commit c02644684ca11b904c5105f06c988a62ef0c6dde
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:31 2019 +0100

    ALSA: parisc: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 1a4c40aafcbe..ea3630217d39 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -578,7 +578,6 @@ snd_harmony_hw_params(struct snd_pcm_substream *ss,
 static const struct snd_pcm_ops snd_harmony_playback_ops = {
 	.open =	snd_harmony_playback_open,
 	.close = snd_harmony_playback_close,
-	.ioctl = snd_pcm_lib_ioctl,
 	.hw_params = snd_harmony_hw_params,
 	.prepare = snd_harmony_playback_prepare,
 	.trigger = snd_harmony_playback_trigger,
@@ -588,7 +587,6 @@ static const struct snd_pcm_ops snd_harmony_playback_ops = {
 static const struct snd_pcm_ops snd_harmony_capture_ops = {
         .open = snd_harmony_capture_open,
         .close = snd_harmony_capture_close,
-        .ioctl = snd_pcm_lib_ioctl,
         .hw_params = snd_harmony_hw_params,
         .prepare = snd_harmony_capture_prepare,
         .trigger = snd_harmony_capture_trigger,

commit 005f3e67a855f6d1deaea84e0ab8e40c597ad10c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:48:50 2019 +0100

    ALSA: parisc: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The hw_free callbacks became superfluous and got dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-19-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 6acc59c25379..1a4c40aafcbe 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -567,20 +567,12 @@ static int
 snd_harmony_hw_params(struct snd_pcm_substream *ss,
 		      struct snd_pcm_hw_params *hw)
 {
-	int err;
 	struct snd_harmony *h = snd_pcm_substream_chip(ss);
 	
-	err = snd_pcm_lib_malloc_pages(ss, params_buffer_bytes(hw));
-	if (err > 0 && h->dma.type == SNDRV_DMA_TYPE_CONTINUOUS)
+	if (h->dma.type == SNDRV_DMA_TYPE_CONTINUOUS)
 		ss->runtime->dma_addr = __pa(ss->runtime->dma_area);
-	
-	return err;
-}
 
-static int 
-snd_harmony_hw_free(struct snd_pcm_substream *ss) 
-{
-	return snd_pcm_lib_free_pages(ss);
+	return 0;
 }
 
 static const struct snd_pcm_ops snd_harmony_playback_ops = {
@@ -588,7 +580,6 @@ static const struct snd_pcm_ops snd_harmony_playback_ops = {
 	.close = snd_harmony_playback_close,
 	.ioctl = snd_pcm_lib_ioctl,
 	.hw_params = snd_harmony_hw_params,
-	.hw_free = snd_harmony_hw_free,
 	.prepare = snd_harmony_playback_prepare,
 	.trigger = snd_harmony_playback_trigger,
  	.pointer = snd_harmony_playback_pointer,
@@ -599,7 +590,6 @@ static const struct snd_pcm_ops snd_harmony_capture_ops = {
         .close = snd_harmony_capture_close,
         .ioctl = snd_pcm_lib_ioctl,
         .hw_params = snd_harmony_hw_params,
-        .hw_free = snd_harmony_hw_free,
         .prepare = snd_harmony_capture_prepare,
         .trigger = snd_harmony_capture_trigger,
         .pointer = snd_harmony_capture_pointer,
@@ -656,8 +646,8 @@ snd_harmony_pcm_init(struct snd_harmony *h)
 	}
 
 	/* pre-allocate space for DMA */
-	snd_pcm_lib_preallocate_pages_for_all(pcm, h->dma.type, h->dma.dev,
-					      MAX_BUF_SIZE, MAX_BUF_SIZE);
+	snd_pcm_set_managed_buffer_all(pcm, h->dma.type, h->dma.dev,
+				       MAX_BUF_SIZE, MAX_BUF_SIZE);
 
 	h->st.format = snd_harmony_set_data_format(h,
 		SNDRV_PCM_FORMAT_S16_BE, 1);

commit 82c298100a2db7e4241e0fee73d94dc5ee573837
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:05 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 176
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 44 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170025.980374610@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index a4264b8943f0..6acc59c25379 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* Hewlett-Packard Harmony audio driver
  *
  *   This is a driver for the Harmony audio chipset found
@@ -13,26 +14,12 @@
  *       Copyright 2003 (c) Laurent Canet
  *       Copyright 2004 (c) Stuart Brady
  *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License, version 2, as
- *   published by the Free Software Foundation.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  * Notes:
  *   - graveyard and silence buffers last for lifetime of
  *     the driver. playback and capture buffers are allocated
  *     per _open()/_close().
  * 
  * TODO:
- *
  */
 
 #include <linux/init.h>

commit f32e5616005bb999fec6a2e914161805d7ad061f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:31:42 2019 +0100

    ALSA: parisc: Drop superfluous PCM preallocation error checks
    
    snd_pcm_lib_preallocate_pages() and co always succeed, so the error
    check is simply redundant.  Drop it.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index f36e7006e00c..a4264b8943f0 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -669,14 +669,8 @@ snd_harmony_pcm_init(struct snd_harmony *h)
 	}
 
 	/* pre-allocate space for DMA */
-	err = snd_pcm_lib_preallocate_pages_for_all(pcm, h->dma.type,
-						    h->dma.dev,
-						    MAX_BUF_SIZE, 
-						    MAX_BUF_SIZE);
-	if (err < 0) {
-		printk(KERN_ERR PFX "buffer allocation error: %d\n", err);
-		return err;
-	}
+	snd_pcm_lib_preallocate_pages_for_all(pcm, h->dma.type, h->dma.dev,
+					      MAX_BUF_SIZE, MAX_BUF_SIZE);
 
 	h->st.format = snd_harmony_set_data_format(h,
 		SNDRV_PCM_FORMAT_S16_BE, 1);

commit d969443064abf2f51510559a5b01325eaabfcb1d
Merge: 3645e6d0dc80 ee5f38a4459a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 7 12:44:53 2017 -0700

    Merge tag 'sound-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "We have touched quite a lot of files but with fewer changes at this
      cycle; as you can see, most of changes are trivial fixes, especially
      constification patches.
    
      Among the massive attacks by constification gangs, we had a few core
      changes (mostly for ASoC core), as well the fixes and the updates by
      major vendors.
    
      Some highlights:
    
      ALSA core:
    
       - Fix possible races in control API user-TLV codes
    
       - Small cleanup of PCM core
    
      ASoC:
    
       - Continued work for componentization; still half-baked, but we're
         certainly progressing
    
       - Use of devres for jack detection GPIOs, rather as a cleanup
    
       - Jack detection support for Qualcomm MSM8916
    
       - Support for Allwinner H3, Cirrus Logic CS43130, Intel Kabylake
         systems with RT5663, Realtek RT274, TI TLV320AIC32x6 and Wolfson
         WM8523"
    
    * tag 'sound-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (512 commits)
      ALSA: hda/ca0132 - Fix memory leak at error path
      ALSA: hda: Fix forget to free resource in error handling code path in hda_codec_driver_probe
      ASoC: cs43130: Fix unused compiler warnings for PM runtime
      ASoC: cs43130: Fix possible Oops with invalid dev_id
      ASoC: cs43130: fix spelling mistake: "irq_occurrance" -> "irq_occurrence"
      ALSA: atmel: Remove leftovers of AVR32 removal
      ALSA: atmel: convert AC97c driver to GPIO descriptor API
      ALSA: hda/realtek - Enable jack detection function for Intel ALC700
      ALSA: hda: Fix regression of hdmi eld control created based on invalid pcm
      ASoC: Intel: Skylake: Add IPC to configure the copier secondary pins
      ASoC: add missing compile rule for max98371
      ASoC: add missing compile rule for sirf-audio-codec
      ASoC: add missing compile rule for max98371
      ASoC: cs43130: Add devicetree bindings for CS43130
      ASoC: cs43130: Add support for CS43130 codec
      ASoC: make clock direction configurable in asoc-simple
      ALSA: ctxfi: Remove null check before kfree
      ASoC: max98927: Changed device property read function
      ASoC: max98927: Modified DAPM widget and map to enable/disable VI sense path
      ASoC: max98927: Added PM suspend and resume function
      ...

commit c8dbaa2261197a648673cc14a280fe7dac73ca5d
Author: Helge Deller <deller@gmx.de>
Date:   Mon Aug 21 21:52:05 2017 +0200

    parisc/harmony: Fix section mismatches
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 5911eb35c2a3..5e04c2b4fbc1 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -66,7 +66,7 @@ module_param(id, charp, 0444);
 MODULE_PARM_DESC(id, "ID string for Harmony driver.");
 
 
-static struct parisc_device_id snd_harmony_devtable[] = {
+static const struct parisc_device_id snd_harmony_devtable[] __initconst = {
 	/* bushmaster / flounder */
 	{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0007A }, 
 	/* 712 / 715 */
@@ -960,7 +960,7 @@ snd_harmony_create(struct snd_card *card,
 	return err;
 }
 
-static int
+static int __init
 snd_harmony_probe(struct parisc_device *padev)
 {
 	int err;
@@ -1000,18 +1000,18 @@ snd_harmony_probe(struct parisc_device *padev)
 	return err;
 }
 
-static int
+static int __exit
 snd_harmony_remove(struct parisc_device *padev)
 {
 	snd_card_free(parisc_get_drvdata(padev));
 	return 0;
 }
 
-static struct parisc_driver snd_harmony_driver = {
+static struct parisc_driver snd_harmony_driver __refdata = {
 	.name = "harmony",
 	.id_table = snd_harmony_devtable,
 	.probe = snd_harmony_probe,
-	.remove = snd_harmony_remove,
+	.remove = __exit_p(snd_harmony_remove),
 };
 
 static int __init 

commit c2992b19a7a00055443d25b9256c39ad7b3e3d69
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Aug 18 13:15:15 2017 +0530

    ALSA: parisc: constify snd_pcm_ops structures
    
    snd_pcm_ops are not supposed to change at runtime. All functions
    working with snd_pcm_ops provided by <sound/pcm.h> work with
    const snd_pcm_ops. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index cb2bc5460304..4eddd81d6832 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -596,7 +596,7 @@ snd_harmony_hw_free(struct snd_pcm_substream *ss)
 	return snd_pcm_lib_free_pages(ss);
 }
 
-static struct snd_pcm_ops snd_harmony_playback_ops = {
+static const struct snd_pcm_ops snd_harmony_playback_ops = {
 	.open =	snd_harmony_playback_open,
 	.close = snd_harmony_playback_close,
 	.ioctl = snd_pcm_lib_ioctl,
@@ -607,7 +607,7 @@ static struct snd_pcm_ops snd_harmony_playback_ops = {
  	.pointer = snd_harmony_playback_pointer,
 };
 
-static struct snd_pcm_ops snd_harmony_capture_ops = {
+static const struct snd_pcm_ops snd_harmony_capture_ops = {
         .open = snd_harmony_capture_open,
         .close = snd_harmony_capture_close,
         .ioctl = snd_pcm_lib_ioctl,

commit a977d0452fc8c4d6539dafeccac900761776a0aa
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Thu Aug 17 14:46:00 2017 +0530

    ALSA: parisc: make snd_pcm_hardware const
    
    Make these const as they are only used in a copy operation.
    Done using Coccinelle
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 5911eb35c2a3..cb2bc5460304 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -260,7 +260,7 @@ snd_harmony_rate_bits(int rate)
 	return HARMONY_SR_44KHZ;
 }
 
-static struct snd_pcm_hardware snd_harmony_playback =
+static const struct snd_pcm_hardware snd_harmony_playback =
 {
 	.info =	(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED | 
 		 SNDRV_PCM_INFO_JOINT_DUPLEX | SNDRV_PCM_INFO_MMAP_VALID |
@@ -281,7 +281,7 @@ static struct snd_pcm_hardware snd_harmony_playback =
 	.fifo_size = 0,
 };
 
-static struct snd_pcm_hardware snd_harmony_capture =
+static const struct snd_pcm_hardware snd_harmony_capture =
 {
         .info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
                  SNDRV_PCM_INFO_JOINT_DUPLEX | SNDRV_PCM_INFO_MMAP_VALID |

commit d236d36107dec03a7755ee9a6dfc2961f269aa43
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 7 14:17:04 2017 +0200

    ALSA: parisc: Constify hw_constraints
    
    snd_pcm_hw_constraint_list(), *_ratnums() and *_ratdens() receive the
    const pointers.  Constify the corresponding static objects for better
    hardening.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 99b64cb3cef8..5911eb35c2a3 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -83,14 +83,14 @@ MODULE_DEVICE_TABLE(parisc, snd_harmony_devtable);
 #define NAME "harmony"
 #define PFX  NAME ": "
 
-static unsigned int snd_harmony_rates[] = {
+static const unsigned int snd_harmony_rates[] = {
 	5512, 6615, 8000, 9600,
 	11025, 16000, 18900, 22050,
 	27428, 32000, 33075, 37800,
 	44100, 48000
 };
 
-static unsigned int rate_bits[14] = {
+static const unsigned int rate_bits[14] = {
 	HARMONY_SR_5KHZ, HARMONY_SR_6KHZ, HARMONY_SR_8KHZ,
 	HARMONY_SR_9KHZ, HARMONY_SR_11KHZ, HARMONY_SR_16KHZ,
 	HARMONY_SR_18KHZ, HARMONY_SR_22KHZ, HARMONY_SR_27KHZ,
@@ -98,7 +98,7 @@ static unsigned int rate_bits[14] = {
 	HARMONY_SR_44KHZ, HARMONY_SR_48KHZ
 };
 
-static struct snd_pcm_hw_constraint_list hw_constraint_rates = {
+static const struct snd_pcm_hw_constraint_list hw_constraint_rates = {
 	.count = ARRAY_SIZE(snd_harmony_rates),
 	.list = snd_harmony_rates,
 	.mask = 0,

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index f2350c1d6ee8..99b64cb3cef8 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -44,6 +44,7 @@
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
 #include <linux/dma-mapping.h>
+#include <linux/io.h>
 
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -52,7 +53,6 @@
 #include <sound/initval.h>
 #include <sound/info.h>
 
-#include <asm/io.h>
 #include <asm/hardware.h>
 #include <asm/parisc-device.h>
 

commit ff6defa6a8fae12205d64f55db395b1fcf35af8e
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jan 3 22:55:54 2015 +0100

    ALSA: Deletion of checks before the function call "iounmap"
    
    The iounmap() function performs also input parameter validation.
    Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 29604a239c44..f2350c1d6ee8 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -893,9 +893,7 @@ snd_harmony_free(struct snd_harmony *h)
 	if (h->irq >= 0)
 		free_irq(h->irq, h);
 
-	if (h->iobase)
-		iounmap(h->iobase);
-
+	iounmap(h->iobase);
 	kfree(h);
 	return 0;
 }

commit 3c6a73cc6b6ccd9188b3405c744365c0874b9274
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 20 18:15:26 2014 +0200

    ALSA: parisc: Use snd_ctl_enum_info()
    
    ... and reduce the open codes.  Also add missing const to the text array.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 4b20be79c1dd..29604a239c44 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -776,15 +776,9 @@ static int
 snd_harmony_captureroute_info(struct snd_kcontrol *kc, 
 			      struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[2] = { "Line", "Mic" };
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 2;
-	if (uinfo->value.enumerated.item > 1)
-		uinfo->value.enumerated.item = 1;
-	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
-	return 0;
+	static const char * const texts[2] = { "Line", "Mic" };
+
+	return snd_ctl_enum_info(uinfo, 1, 2, texts);
 }
 
 static int 

commit 5f32c314f9c2a4e2e88de3ef23aa35580a0a19e5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:35:40 2014 +0100

    ALSA: parisc: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 67f56a2cee6a..4b20be79c1dd 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -959,8 +959,6 @@ snd_harmony_create(struct snd_card *card,
                 goto free_and_ret;
         }
 
-	snd_card_set_dev(card, &padev->dev);
-
 	*rchip = h;
 
 	return 0;
@@ -977,7 +975,7 @@ snd_harmony_probe(struct parisc_device *padev)
 	struct snd_card *card;
 	struct snd_harmony *h;
 
-	err = snd_card_create(index, id, THIS_MODULE, 0, &card);
+	err = snd_card_new(&padev->dev, index, id, THIS_MODULE, 0, &card);
 	if (err < 0)
 		return err;
 

commit f35e839a3ce730063174caaab8bf63432be553cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:50:59 2013 +0200

    ALSA: Remove the rest of *_set_drvdata(NULL) calls
    
    A few calls are still left in parport drivers after this commit, which
    I'm not quite sure yet.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 0e66ba48d453..67f56a2cee6a 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -902,8 +902,6 @@ snd_harmony_free(struct snd_harmony *h)
 	if (h->iobase)
 		iounmap(h->iobase);
 
-	parisc_set_drvdata(h->dev, NULL);
-
 	kfree(h);
 	return 0;
 }
@@ -1016,7 +1014,6 @@ static int
 snd_harmony_remove(struct parisc_device *padev)
 {
 	snd_card_free(parisc_get_drvdata(padev));
-	parisc_set_drvdata(padev, NULL);
 	return 0;
 }
 

commit 05bcf50367668b6706a44e89c166c541f2644d04
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:16 2012 -0500

    ALSA: parisc/harmony: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: linux-parisc@vger.kernel.org
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index f47f9e226b08..0e66ba48d453 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -856,7 +856,7 @@ static struct snd_kcontrol_new snd_harmony_controls[] = {
 		       HARMONY_GAIN_HE_SHIFT, 1, 0),
 };
 
-static void __devinit
+static void
 snd_harmony_mixer_reset(struct snd_harmony *h)
 {
 	harmony_mute(h);
@@ -865,7 +865,7 @@ snd_harmony_mixer_reset(struct snd_harmony *h)
 	harmony_unmute(h);
 }
 
-static int __devinit
+static int
 snd_harmony_mixer_init(struct snd_harmony *h)
 {
 	struct snd_card *card;
@@ -915,7 +915,7 @@ snd_harmony_dev_free(struct snd_device *dev)
 	return snd_harmony_free(h);
 }
 
-static int __devinit
+static int
 snd_harmony_create(struct snd_card *card, 
 		   struct parisc_device *padev, 
 		   struct snd_harmony **rchip)
@@ -972,7 +972,7 @@ snd_harmony_create(struct snd_card *card,
 	return err;
 }
 
-static int __devinit
+static int
 snd_harmony_probe(struct parisc_device *padev)
 {
 	int err;
@@ -1012,7 +1012,7 @@ snd_harmony_probe(struct parisc_device *padev)
 	return err;
 }
 
-static int __devexit
+static int
 snd_harmony_remove(struct parisc_device *padev)
 {
 	snd_card_free(parisc_get_drvdata(padev));
@@ -1024,7 +1024,7 @@ static struct parisc_driver snd_harmony_driver = {
 	.name = "harmony",
 	.id_table = snd_harmony_devtable,
 	.probe = snd_harmony_probe,
-	.remove = __devexit_p(snd_harmony_remove),
+	.remove = snd_harmony_remove,
 };
 
 static int __init 

commit e8e0929d7290cab7c5b1a3e5f5f54f73daf38038
Author: Julia Lawall <julia@diku.dk>
Date:   Sat Oct 17 08:33:47 2009 +0200

    ALSA: sound/parisc: Move dereference after NULL test
    
    If the NULL test on h is needed in snd_harmony_mixer_init, then the
    dereference should be after the NULL test.
    
    Actually, there is a sequence of calls: snd_harmony_create, then
    snd_harmony_pcm_init, and then snd_harmony_mixer_init.  snd_harmony_create
    initializes h, but may indeed leave it as NULL.  There was no NULL test at
    the beginning of snd_harmony_pcm_init, so I have added one.  The NULL test
    in snd_harmony_mixer_init is then not necessary, but in case the ordering
    of the calls changes, I have left it, and moved the dereference after it.
    
    A simplified version of the semantic match that detects this problem is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    @match exists@
    expression x, E;
    identifier fld;
    @@
    
    * x->fld
      ... when != \(x = E\|&x\)
    * x == NULL
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index e924492df21d..f47f9e226b08 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -624,6 +624,9 @@ snd_harmony_pcm_init(struct snd_harmony *h)
 	struct snd_pcm *pcm;
 	int err;
 
+	if (snd_BUG_ON(!h))
+		return -EINVAL;
+
 	harmony_disable_interrupts(h);
 	
    	err = snd_pcm_new(h->card, "harmony", 0, 1, 1, &pcm);
@@ -865,11 +868,12 @@ snd_harmony_mixer_reset(struct snd_harmony *h)
 static int __devinit
 snd_harmony_mixer_init(struct snd_harmony *h)
 {
-	struct snd_card *card = h->card;
+	struct snd_card *card;
 	int idx, err;
 
 	if (snd_BUG_ON(!h))
 		return -EINVAL;
+	card = h->card;
 	strcpy(card->mixername, "Harmony Gain control interface");
 
 	for (idx = 0; idx < HARMONY_CONTROLS; idx++) {

commit 1282c824cc4ad5b43fc1813e7ea564c0d6f0d046
Merge: 45d60e3648ea 82ced6fd2865
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 10 07:26:46 2009 +0200

    Merge branch 'topic/section-fix' into for-linus
    
    * topic/section-fix:
      ALSA: Add missing __devexit_p() markers
      ALSA: powermac - Replace the rest of __init*
      ALSA: sound/ppc: update annotations of serveral functions

commit 82ced6fd28653ab456c3e5b25e9ef3c1c96cd6e9
Author: Jean Delvare <khali@linux-fr.org>
Date:   Thu Jun 4 10:46:43 2009 +0200

    ALSA: Add missing __devexit_p() markers
    
    3 ISA sound drivers lack their __devexit_p() markers, which would
    cause build failures when the kernel is built without hotplug support.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 6055fd6d3b38..610c43914cf2 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -1020,7 +1020,7 @@ static struct parisc_driver snd_harmony_driver = {
 	.name = "harmony",
 	.id_table = snd_harmony_devtable,
 	.probe = snd_harmony_probe,
-	.remove = snd_harmony_remove,
+	.remove = __devexit_p(snd_harmony_remove),
 };
 
 static int __init 

commit b04b4f7862de8d6e8b536853aaf66a6c1bb05cbd
Author: Alexander Beregalov <a.beregalov@gmail.com>
Date:   Fri May 15 18:00:38 2009 +0400

    ALSA: parisc/harmony: fix printk format warning
    
    Fix this warning:
    sound/parisc/harmony.c:938: warning: format '%lx' expects type 'long unsigned int',
    but argument 2 has type 'resource_size_t'
    
    Signed-off-by: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 6055fd6d3b38..63ae0f9aeaf5 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -935,7 +935,7 @@ snd_harmony_create(struct snd_card *card,
 	h->iobase = ioremap_nocache(padev->hpa.start, HARMONY_SIZE);
 	if (h->iobase == NULL) {
 		printk(KERN_ERR PFX "unable to remap hpa 0x%lx\n",
-		       padev->hpa.start);
+		       (unsigned long)padev->hpa.start);
 		err = -EBUSY;
 		goto free_and_ret;
 	}

commit bd7dd77c2a05c530684eea2e3af16449ae9c5d52
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:45:02 2008 +0100

    ALSA: Convert to snd_card_create() in other sound/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in other sound subdirectories.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 41f870f8a11d..6055fd6d3b38 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -975,9 +975,9 @@ snd_harmony_probe(struct parisc_device *padev)
 	struct snd_card *card;
 	struct snd_harmony *h;
 
-	card = snd_card_new(index, id, THIS_MODULE, 0);
-	if (card == NULL)
-		return -ENOMEM;
+	err = snd_card_create(index, id, THIS_MODULE, 0, &card);
+	if (err < 0)
+		return err;
 
 	err = snd_harmony_create(card, padev, &h);
 	if (err < 0)

commit c86a456b25695974ddba9833ab8e4f853bcdd995
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 1 19:45:58 2008 +0200

    ALSA: harmony - fix a typo
    
    Fix a typo in the patch to remove snd_assert().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 774372fe34ad..41f870f8a11d 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -869,7 +869,7 @@ snd_harmony_mixer_init(struct snd_harmony *h)
 	int idx, err;
 
 	if (snd_BUG_ON(!h))
-		reutrn -EINVAL;
+		return -EINVAL;
 	strcpy(card->mixername, "Harmony Gain control interface");
 
 	for (idx = 0; idx < HARMONY_CONTROLS; idx++) {

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 99f5483abf2e..774372fe34ad 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -868,7 +868,8 @@ snd_harmony_mixer_init(struct snd_harmony *h)
 	struct snd_card *card = h->card;
 	int idx, err;
 
-	snd_assert(h != NULL, return -EINVAL);
+	if (snd_BUG_ON(!h))
+		reutrn -EINVAL;
 	strcpy(card->mixername, "Harmony Gain control interface");
 
 	for (idx = 0; idx < HARMONY_CONTROLS; idx++) {

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index ff705c63a03a..99f5483abf2e 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -45,7 +45,6 @@
 #include <linux/spinlock.h>
 #include <linux/dma-mapping.h>
 
-#include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/control.h>

commit 992378a06413116c6a7cf2ad597e096589e531aa
Author: Helge Deller <deller@gmx.de>
Date:   Sun Jan 28 17:06:12 2007 +0100

    [PARISC] fix section mismatch warnings in harmony sound driver
    
    fix for two warnings:
    - Section mismatch: reference to .init.text:snd_harmony_mixer_init from .text.snd_harmony_probe after 'snd_harmony_probe'
    - Section mismatch: reference to .init.text:snd_harmony_mixer_reset from .text.snd_harmony_mixer_init after 'snd_harmony_mixer_init'
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index cf603337b321..ff705c63a03a 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -854,7 +854,7 @@ static struct snd_kcontrol_new snd_harmony_controls[] = {
 		       HARMONY_GAIN_HE_SHIFT, 1, 0),
 };
 
-static void __init 
+static void __devinit
 snd_harmony_mixer_reset(struct snd_harmony *h)
 {
 	harmony_mute(h);
@@ -863,7 +863,7 @@ snd_harmony_mixer_reset(struct snd_harmony *h)
 	harmony_unmute(h);
 }
 
-static int __init 
+static int __devinit
 snd_harmony_mixer_init(struct snd_harmony *h)
 {
 	struct snd_card *card = h->card;

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index ce73f3eae78c..cf603337b321 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -193,7 +193,7 @@ harmony_set_control(struct snd_harmony *h)
 }
 
 static irqreturn_t
-snd_harmony_interrupt(int irq, void *dev, struct pt_regs *regs)
+snd_harmony_interrupt(int irq, void *dev)
 {
 	u32 dstatus;
 	struct snd_harmony *h = dev;

commit 67b1020d88a77a73bd9ccbc21733c155a4d7d44c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:12:11 2005 +0100

    [ALSA] Remove xxx_t typedefs: PARISC Harmony
    
    Modules: PARISC Harmony driver
    
    Remove xxx_t typedefs from the PARIC Harmony driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 0513137d4ec4..ce73f3eae78c 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -99,32 +99,32 @@ static unsigned int rate_bits[14] = {
 	HARMONY_SR_44KHZ, HARMONY_SR_48KHZ
 };
 
-static snd_pcm_hw_constraint_list_t hw_constraint_rates = {
+static struct snd_pcm_hw_constraint_list hw_constraint_rates = {
 	.count = ARRAY_SIZE(snd_harmony_rates),
 	.list = snd_harmony_rates,
 	.mask = 0,
 };
 
-inline unsigned long
-harmony_read(harmony_t *h, unsigned r)
+static inline unsigned long
+harmony_read(struct snd_harmony *h, unsigned r)
 {
 	return __raw_readl(h->iobase + r);
 }
 
-inline void
-harmony_write(harmony_t *h, unsigned r, unsigned long v)
+static inline void
+harmony_write(struct snd_harmony *h, unsigned r, unsigned long v)
 {
 	__raw_writel(v, h->iobase + r);
 }
 
-static void
-harmony_wait_for_control(harmony_t *h)
+static inline void
+harmony_wait_for_control(struct snd_harmony *h)
 {
 	while (harmony_read(h, HARMONY_CNTL) & HARMONY_CNTL_C) ;
 }
 
-inline void
-harmony_reset(harmony_t *h)
+static inline void
+harmony_reset(struct snd_harmony *h)
 {
 	harmony_write(h, HARMONY_RESET, 1);
 	mdelay(50);
@@ -132,7 +132,7 @@ harmony_reset(harmony_t *h)
 }
 
 static void
-harmony_disable_interrupts(harmony_t *h)
+harmony_disable_interrupts(struct snd_harmony *h)
 {
 	u32 dstatus;
 	harmony_wait_for_control(h);
@@ -142,7 +142,7 @@ harmony_disable_interrupts(harmony_t *h)
 }
 
 static void
-harmony_enable_interrupts(harmony_t *h)
+harmony_enable_interrupts(struct snd_harmony *h)
 {
 	u32 dstatus;
 	harmony_wait_for_control(h);
@@ -152,7 +152,7 @@ harmony_enable_interrupts(harmony_t *h)
 }
 
 static void
-harmony_mute(harmony_t *h)
+harmony_mute(struct snd_harmony *h)
 {
 	unsigned long flags;
 
@@ -163,7 +163,7 @@ harmony_mute(harmony_t *h)
 }
 
 static void
-harmony_unmute(harmony_t *h)
+harmony_unmute(struct snd_harmony *h)
 {
 	unsigned long flags;
 
@@ -174,7 +174,7 @@ harmony_unmute(harmony_t *h)
 }
 
 static void
-harmony_set_control(harmony_t *h)
+harmony_set_control(struct snd_harmony *h)
 {
 	u32 ctrl;
 	unsigned long flags;
@@ -196,7 +196,7 @@ static irqreturn_t
 snd_harmony_interrupt(int irq, void *dev, struct pt_regs *regs)
 {
 	u32 dstatus;
-	harmony_t *h = dev;
+	struct snd_harmony *h = dev;
 
 	spin_lock(&h->lock);
 	harmony_disable_interrupts(h);
@@ -261,7 +261,7 @@ snd_harmony_rate_bits(int rate)
 	return HARMONY_SR_44KHZ;
 }
 
-static snd_pcm_hardware_t snd_harmony_playback =
+static struct snd_pcm_hardware snd_harmony_playback =
 {
 	.info =	(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED | 
 		 SNDRV_PCM_INFO_JOINT_DUPLEX | SNDRV_PCM_INFO_MMAP_VALID |
@@ -282,7 +282,7 @@ static snd_pcm_hardware_t snd_harmony_playback =
 	.fifo_size = 0,
 };
 
-static snd_pcm_hardware_t snd_harmony_capture =
+static struct snd_pcm_hardware snd_harmony_capture =
 {
         .info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
                  SNDRV_PCM_INFO_JOINT_DUPLEX | SNDRV_PCM_INFO_MMAP_VALID |
@@ -304,9 +304,9 @@ static snd_pcm_hardware_t snd_harmony_capture =
 };
 
 static int
-snd_harmony_playback_trigger(snd_pcm_substream_t *ss, int cmd)
+snd_harmony_playback_trigger(struct snd_pcm_substream *ss, int cmd)
 {
-	harmony_t *h = snd_pcm_substream_chip(ss);
+	struct snd_harmony *h = snd_pcm_substream_chip(ss);
 
 	if (h->st.capturing)
 		return -EBUSY;
@@ -340,9 +340,9 @@ snd_harmony_playback_trigger(snd_pcm_substream_t *ss, int cmd)
 }
 
 static int
-snd_harmony_capture_trigger(snd_pcm_substream_t *ss, int cmd)
+snd_harmony_capture_trigger(struct snd_pcm_substream *ss, int cmd)
 {
-        harmony_t *h = snd_pcm_substream_chip(ss);
+        struct snd_harmony *h = snd_pcm_substream_chip(ss);
 
 	if (h->st.playing)
 		return -EBUSY;
@@ -376,7 +376,7 @@ snd_harmony_capture_trigger(snd_pcm_substream_t *ss, int cmd)
 }
 
 static int
-snd_harmony_set_data_format(harmony_t *h, int fmt, int force)
+snd_harmony_set_data_format(struct snd_harmony *h, int fmt, int force)
 {
 	int o = h->st.format;
 	int n;
@@ -406,10 +406,10 @@ snd_harmony_set_data_format(harmony_t *h, int fmt, int force)
 }
 
 static int
-snd_harmony_playback_prepare(snd_pcm_substream_t *ss)
+snd_harmony_playback_prepare(struct snd_pcm_substream *ss)
 {
-	harmony_t *h = snd_pcm_substream_chip(ss);
-	snd_pcm_runtime_t *rt = ss->runtime;
+	struct snd_harmony *h = snd_pcm_substream_chip(ss);
+	struct snd_pcm_runtime *rt = ss->runtime;
 	
 	if (h->st.capturing)
 		return -EBUSY;
@@ -436,10 +436,10 @@ snd_harmony_playback_prepare(snd_pcm_substream_t *ss)
 }
 
 static int
-snd_harmony_capture_prepare(snd_pcm_substream_t *ss)
+snd_harmony_capture_prepare(struct snd_pcm_substream *ss)
 {
-        harmony_t *h = snd_pcm_substream_chip(ss);
-        snd_pcm_runtime_t *rt = ss->runtime;
+        struct snd_harmony *h = snd_pcm_substream_chip(ss);
+        struct snd_pcm_runtime *rt = ss->runtime;
 
 	if (h->st.playing)
 		return -EBUSY;
@@ -466,10 +466,10 @@ snd_harmony_capture_prepare(snd_pcm_substream_t *ss)
 }
 
 static snd_pcm_uframes_t 
-snd_harmony_playback_pointer(snd_pcm_substream_t *ss)
+snd_harmony_playback_pointer(struct snd_pcm_substream *ss)
 {
-	snd_pcm_runtime_t *rt = ss->runtime;
-	harmony_t *h = snd_pcm_substream_chip(ss);
+	struct snd_pcm_runtime *rt = ss->runtime;
+	struct snd_harmony *h = snd_pcm_substream_chip(ss);
 	unsigned long pcuradd;
 	unsigned long played;
 
@@ -495,10 +495,10 @@ snd_harmony_playback_pointer(snd_pcm_substream_t *ss)
 }
 
 static snd_pcm_uframes_t
-snd_harmony_capture_pointer(snd_pcm_substream_t *ss)
+snd_harmony_capture_pointer(struct snd_pcm_substream *ss)
 {
-        snd_pcm_runtime_t *rt = ss->runtime;
-        harmony_t *h = snd_pcm_substream_chip(ss);
+        struct snd_pcm_runtime *rt = ss->runtime;
+        struct snd_harmony *h = snd_pcm_substream_chip(ss);
         unsigned long rcuradd;
         unsigned long caught;
 
@@ -524,10 +524,10 @@ snd_harmony_capture_pointer(snd_pcm_substream_t *ss)
 }
 
 static int 
-snd_harmony_playback_open(snd_pcm_substream_t *ss)
+snd_harmony_playback_open(struct snd_pcm_substream *ss)
 {
-	harmony_t *h = snd_pcm_substream_chip(ss);
-	snd_pcm_runtime_t *rt = ss->runtime;
+	struct snd_harmony *h = snd_pcm_substream_chip(ss);
+	struct snd_pcm_runtime *rt = ss->runtime;
 	int err;
 	
 	h->psubs = ss;
@@ -543,10 +543,10 @@ snd_harmony_playback_open(snd_pcm_substream_t *ss)
 }
 
 static int
-snd_harmony_capture_open(snd_pcm_substream_t *ss)
+snd_harmony_capture_open(struct snd_pcm_substream *ss)
 {
-        harmony_t *h = snd_pcm_substream_chip(ss);
-        snd_pcm_runtime_t *rt = ss->runtime;
+        struct snd_harmony *h = snd_pcm_substream_chip(ss);
+        struct snd_pcm_runtime *rt = ss->runtime;
         int err;
 
         h->csubs = ss;
@@ -562,27 +562,27 @@ snd_harmony_capture_open(snd_pcm_substream_t *ss)
 }
 
 static int 
-snd_harmony_playback_close(snd_pcm_substream_t *ss)
+snd_harmony_playback_close(struct snd_pcm_substream *ss)
 {
-	harmony_t *h = snd_pcm_substream_chip(ss);
+	struct snd_harmony *h = snd_pcm_substream_chip(ss);
 	h->psubs = NULL;
 	return 0;
 }
 
 static int
-snd_harmony_capture_close(snd_pcm_substream_t *ss)
+snd_harmony_capture_close(struct snd_pcm_substream *ss)
 {
-        harmony_t *h = snd_pcm_substream_chip(ss);
+        struct snd_harmony *h = snd_pcm_substream_chip(ss);
         h->csubs = NULL;
         return 0;
 }
 
 static int 
-snd_harmony_hw_params(snd_pcm_substream_t *ss,
-		      snd_pcm_hw_params_t *hw)
+snd_harmony_hw_params(struct snd_pcm_substream *ss,
+		      struct snd_pcm_hw_params *hw)
 {
 	int err;
-	harmony_t *h = snd_pcm_substream_chip(ss);
+	struct snd_harmony *h = snd_pcm_substream_chip(ss);
 	
 	err = snd_pcm_lib_malloc_pages(ss, params_buffer_bytes(hw));
 	if (err > 0 && h->dma.type == SNDRV_DMA_TYPE_CONTINUOUS)
@@ -592,12 +592,12 @@ snd_harmony_hw_params(snd_pcm_substream_t *ss,
 }
 
 static int 
-snd_harmony_hw_free(snd_pcm_substream_t *ss) 
+snd_harmony_hw_free(struct snd_pcm_substream *ss) 
 {
 	return snd_pcm_lib_free_pages(ss);
 }
 
-static snd_pcm_ops_t snd_harmony_playback_ops = {
+static struct snd_pcm_ops snd_harmony_playback_ops = {
 	.open =	snd_harmony_playback_open,
 	.close = snd_harmony_playback_close,
 	.ioctl = snd_pcm_lib_ioctl,
@@ -608,7 +608,7 @@ static snd_pcm_ops_t snd_harmony_playback_ops = {
  	.pointer = snd_harmony_playback_pointer,
 };
 
-static snd_pcm_ops_t snd_harmony_capture_ops = {
+static struct snd_pcm_ops snd_harmony_capture_ops = {
         .open = snd_harmony_capture_open,
         .close = snd_harmony_capture_close,
         .ioctl = snd_pcm_lib_ioctl,
@@ -620,9 +620,9 @@ static snd_pcm_ops_t snd_harmony_capture_ops = {
 };
 
 static int 
-snd_harmony_pcm_init(harmony_t *h)
+snd_harmony_pcm_init(struct snd_harmony *h)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	harmony_disable_interrupts(h);
@@ -683,15 +683,15 @@ snd_harmony_pcm_init(harmony_t *h)
 }
 
 static void 
-snd_harmony_set_new_gain(harmony_t *h)
+snd_harmony_set_new_gain(struct snd_harmony *h)
 {
  	harmony_wait_for_control(h);
 	harmony_write(h, HARMONY_GAINCTL, h->st.gain);
 }
 
 static int 
-snd_harmony_mixercontrol_info(snd_kcontrol_t *kc, 
-			      snd_ctl_elem_info_t *uinfo)
+snd_harmony_mixercontrol_info(struct snd_kcontrol *kc, 
+			      struct snd_ctl_elem_info *uinfo)
 {
 	int mask = (kc->private_value >> 16) & 0xff;
 	int left_shift = (kc->private_value) & 0xff;
@@ -707,10 +707,10 @@ snd_harmony_mixercontrol_info(snd_kcontrol_t *kc,
 }
 
 static int 
-snd_harmony_volume_get(snd_kcontrol_t *kc, 
-		       snd_ctl_elem_value_t *ucontrol)
+snd_harmony_volume_get(struct snd_kcontrol *kc, 
+		       struct snd_ctl_elem_value *ucontrol)
 {
-	harmony_t *h = snd_kcontrol_chip(kc);
+	struct snd_harmony *h = snd_kcontrol_chip(kc);
 	int shift_left = (kc->private_value) & 0xff;
 	int shift_right = (kc->private_value >> 8) & 0xff;
 	int mask = (kc->private_value >> 16) & 0xff;
@@ -736,10 +736,10 @@ snd_harmony_volume_get(snd_kcontrol_t *kc,
 }  
 
 static int 
-snd_harmony_volume_put(snd_kcontrol_t *kc, 
-		       snd_ctl_elem_value_t *ucontrol)
+snd_harmony_volume_put(struct snd_kcontrol *kc, 
+		       struct snd_ctl_elem_value *ucontrol)
 {
-	harmony_t *h = snd_kcontrol_chip(kc);
+	struct snd_harmony *h = snd_kcontrol_chip(kc);
 	int shift_left = (kc->private_value) & 0xff;
 	int shift_right = (kc->private_value >> 8) & 0xff;
 	int mask = (kc->private_value >> 16) & 0xff;
@@ -771,8 +771,8 @@ snd_harmony_volume_put(snd_kcontrol_t *kc,
 }
 
 static int 
-snd_harmony_captureroute_info(snd_kcontrol_t *kc, 
-			      snd_ctl_elem_info_t *uinfo)
+snd_harmony_captureroute_info(struct snd_kcontrol *kc, 
+			      struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[2] = { "Line", "Mic" };
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
@@ -786,10 +786,10 @@ snd_harmony_captureroute_info(snd_kcontrol_t *kc,
 }
 
 static int 
-snd_harmony_captureroute_get(snd_kcontrol_t *kc, 
-			     snd_ctl_elem_value_t *ucontrol)
+snd_harmony_captureroute_get(struct snd_kcontrol *kc, 
+			     struct snd_ctl_elem_value *ucontrol)
 {
-	harmony_t *h = snd_kcontrol_chip(kc);
+	struct snd_harmony *h = snd_kcontrol_chip(kc);
 	int value;
 	
 	spin_lock_irq(&h->mixer_lock);
@@ -803,10 +803,10 @@ snd_harmony_captureroute_get(snd_kcontrol_t *kc,
 }  
 
 static int 
-snd_harmony_captureroute_put(snd_kcontrol_t *kc, 
-			     snd_ctl_elem_value_t *ucontrol)
+snd_harmony_captureroute_put(struct snd_kcontrol *kc, 
+			     struct snd_ctl_elem_value *ucontrol)
 {
-	harmony_t *h = snd_kcontrol_chip(kc);
+	struct snd_harmony *h = snd_kcontrol_chip(kc);
 	int value;
 	int old_gain = h->st.gain;
 	
@@ -823,8 +823,7 @@ snd_harmony_captureroute_put(snd_kcontrol_t *kc,
 	return h->st.gain != old_gain;
 }
 
-#define HARMONY_CONTROLS (sizeof(snd_harmony_controls)/ \
-                          sizeof(snd_kcontrol_new_t))
+#define HARMONY_CONTROLS	ARRAY_SIZE(snd_harmony_controls)
 
 #define HARMONY_VOLUME(xname, left_shift, right_shift, mask, invert) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,                \
@@ -833,7 +832,7 @@ snd_harmony_captureroute_put(snd_kcontrol_t *kc,
   .private_value = ((left_shift) | ((right_shift) << 8) |            \
                    ((mask) << 16) | ((invert) << 24)) }
 
-static snd_kcontrol_new_t snd_harmony_controls[] = {
+static struct snd_kcontrol_new snd_harmony_controls[] = {
 	HARMONY_VOLUME("Master Playback Volume", HARMONY_GAIN_LO_SHIFT, 
 		       HARMONY_GAIN_RO_SHIFT, HARMONY_GAIN_OUT, 1),
 	HARMONY_VOLUME("Capture Volume", HARMONY_GAIN_LI_SHIFT,
@@ -856,7 +855,7 @@ static snd_kcontrol_new_t snd_harmony_controls[] = {
 };
 
 static void __init 
-snd_harmony_mixer_reset(harmony_t *h)
+snd_harmony_mixer_reset(struct snd_harmony *h)
 {
 	harmony_mute(h);
 	harmony_reset(h);
@@ -865,9 +864,9 @@ snd_harmony_mixer_reset(harmony_t *h)
 }
 
 static int __init 
-snd_harmony_mixer_init(harmony_t *h)
+snd_harmony_mixer_init(struct snd_harmony *h)
 {
-	snd_card_t *card = h->card;
+	struct snd_card *card = h->card;
 	int idx, err;
 
 	snd_assert(h != NULL, return -EINVAL);
@@ -886,7 +885,7 @@ snd_harmony_mixer_init(harmony_t *h)
 }
 
 static int
-snd_harmony_free(harmony_t *h)
+snd_harmony_free(struct snd_harmony *h)
 {
         if (h->gdma.addr)
                 snd_dma_free_pages(&h->gdma);
@@ -906,20 +905,20 @@ snd_harmony_free(harmony_t *h)
 }
 
 static int
-snd_harmony_dev_free(snd_device_t *dev)
+snd_harmony_dev_free(struct snd_device *dev)
 {
-	harmony_t *h = dev->device_data;
+	struct snd_harmony *h = dev->device_data;
 	return snd_harmony_free(h);
 }
 
 static int __devinit
-snd_harmony_create(snd_card_t *card, 
+snd_harmony_create(struct snd_card *card, 
 		   struct parisc_device *padev, 
-		   harmony_t **rchip)
+		   struct snd_harmony **rchip)
 {
 	int err;
-	harmony_t *h;
-	static snd_device_ops_t ops = {
+	struct snd_harmony *h;
+	static struct snd_device_ops ops = {
 		.dev_free = snd_harmony_dev_free,
 	};
 
@@ -973,8 +972,8 @@ static int __devinit
 snd_harmony_probe(struct parisc_device *padev)
 {
 	int err;
-	snd_card_t *card;
-	harmony_t *h;
+	struct snd_card *card;
+	struct snd_harmony *h;
 
 	card = snd_card_new(index, id, THIS_MODULE, 0);
 	if (card == NULL)
@@ -1033,7 +1032,7 @@ alsa_harmony_init(void)
 static void __exit
 alsa_harmony_fini(void)
 {
-	return unregister_parisc_driver(&snd_harmony_driver);
+	unregister_parisc_driver(&snd_harmony_driver);
 }
 
 MODULE_LICENSE("GPL");

commit 03f9ae2505cf2f5d56c197b4045ed9dba5ce8912
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 10:34:40 2005 +0100

    [ALSA] harmony - Code clean up
    
    Modules: PARISC Harmony driver
    
    Clean up snd-harmony driver code:
    
    - Give standard module options
    - Fix spinlocks
    - Fix the error path of request_irq()
    - Clean up redundant codes
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index d833349ed518..0513137d4ec4 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -59,6 +59,14 @@
 
 #include "harmony.h"
 
+static int index = SNDRV_DEFAULT_IDX1;	/* Index 0-MAX */
+static char *id = SNDRV_DEFAULT_STR1;	/* ID for this card */
+module_param(index, int, 0444);
+MODULE_PARM_DESC(index, "Index value for Harmony driver.");
+module_param(id, charp, 0444);
+MODULE_PARM_DESC(id, "ID string for Harmony driver.");
+
+
 static struct parisc_device_id snd_harmony_devtable[] = {
 	/* bushmaster / flounder */
 	{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0007A }, 
@@ -299,12 +307,11 @@ static int
 snd_harmony_playback_trigger(snd_pcm_substream_t *ss, int cmd)
 {
 	harmony_t *h = snd_pcm_substream_chip(ss);
-	unsigned long flags;
 
 	if (h->st.capturing)
 		return -EBUSY;
 
-	spin_lock_irqsave(&h->lock, flags);
+	spin_lock(&h->lock);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 		h->st.playing = 1;
@@ -323,11 +330,11 @@ snd_harmony_playback_trigger(snd_pcm_substream_t *ss, int cmd)
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 	default:
-		spin_unlock_irqrestore(&h->lock, flags);
+		spin_unlock(&h->lock);
 		snd_BUG();
 		return -EINVAL;
 	}
-	spin_unlock_irqrestore(&h->lock, flags);
+	spin_unlock(&h->lock);
 	
 	return 0;
 }
@@ -336,12 +343,11 @@ static int
 snd_harmony_capture_trigger(snd_pcm_substream_t *ss, int cmd)
 {
         harmony_t *h = snd_pcm_substream_chip(ss);
-	unsigned long flags;
 
 	if (h->st.playing)
 		return -EBUSY;
 
-	spin_lock_irqsave(&h->lock, flags);
+	spin_lock(&h->lock);
         switch (cmd) {
         case SNDRV_PCM_TRIGGER_START:
 		h->st.capturing = 1;
@@ -360,11 +366,11 @@ snd_harmony_capture_trigger(snd_pcm_substream_t *ss, int cmd)
         case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
         case SNDRV_PCM_TRIGGER_SUSPEND:
 	default:
-		spin_unlock_irqrestore(&h->lock, flags);
+		spin_unlock(&h->lock);
 		snd_BUG();
                 return -EINVAL;
         }
-	spin_unlock_irqrestore(&h->lock, flags);
+	spin_unlock(&h->lock);
 		
         return 0;
 }
@@ -710,9 +716,8 @@ snd_harmony_volume_get(snd_kcontrol_t *kc,
 	int mask = (kc->private_value >> 16) & 0xff;
 	int invert = (kc->private_value >> 24) & 0xff;
 	int left, right;
-	unsigned long flags;
 	
-	spin_lock_irqsave(&h->mixer_lock, flags);
+	spin_lock_irq(&h->mixer_lock);
 
 	left = (h->st.gain >> shift_left) & mask;
 	right = (h->st.gain >> shift_right) & mask;
@@ -725,7 +730,7 @@ snd_harmony_volume_get(snd_kcontrol_t *kc,
 	if (shift_left != shift_right)
 		ucontrol->value.integer.value[1] = right;
 
-	spin_unlock_irqrestore(&h->mixer_lock, flags);
+	spin_unlock_irq(&h->mixer_lock);
 
 	return 0;
 }  
@@ -741,9 +746,8 @@ snd_harmony_volume_put(snd_kcontrol_t *kc,
 	int invert = (kc->private_value >> 24) & 0xff;
 	int left, right;
 	int old_gain = h->st.gain;
-	unsigned long flags;
 	
-	spin_lock_irqsave(&h->mixer_lock, flags);
+	spin_lock_irq(&h->mixer_lock);
 
 	left = ucontrol->value.integer.value[0] & mask;
 	if (invert)
@@ -761,7 +765,7 @@ snd_harmony_volume_put(snd_kcontrol_t *kc,
 
 	snd_harmony_set_new_gain(h);
 
-	spin_unlock_irqrestore(&h->mixer_lock, flags);
+	spin_unlock_irq(&h->mixer_lock);
 	
 	return h->st.gain != old_gain;
 }
@@ -787,14 +791,13 @@ snd_harmony_captureroute_get(snd_kcontrol_t *kc,
 {
 	harmony_t *h = snd_kcontrol_chip(kc);
 	int value;
-	unsigned long flags;
 	
-	spin_lock_irqsave(&h->mixer_lock, flags);
+	spin_lock_irq(&h->mixer_lock);
 
 	value = (h->st.gain >> HARMONY_GAIN_IS_SHIFT) & 1;
 	ucontrol->value.enumerated.item[0] = value;
 
-	spin_unlock_irqrestore(&h->mixer_lock, flags);
+	spin_unlock_irq(&h->mixer_lock);
 
 	return 0;
 }  
@@ -806,9 +809,8 @@ snd_harmony_captureroute_put(snd_kcontrol_t *kc,
 	harmony_t *h = snd_kcontrol_chip(kc);
 	int value;
 	int old_gain = h->st.gain;
-	unsigned long flags;
 	
-	spin_lock_irqsave(&h->mixer_lock, flags);
+	spin_lock_irq(&h->mixer_lock);
 
 	value = ucontrol->value.enumerated.item[0] & 1;
 	h->st.gain &= ~HARMONY_GAIN_IS_MASK;
@@ -816,7 +818,7 @@ snd_harmony_captureroute_put(snd_kcontrol_t *kc,
 
 	snd_harmony_set_new_gain(h);
 
-	spin_unlock_irqrestore(&h->mixer_lock, flags);
+	spin_unlock_irq(&h->mixer_lock);
 	
 	return h->st.gain != old_gain;
 }
@@ -923,19 +925,14 @@ snd_harmony_create(snd_card_t *card,
 
 	*rchip = NULL;
 
-	h = kmalloc(sizeof(*h), GFP_KERNEL);
+	h = kzalloc(sizeof(*h), GFP_KERNEL);
 	if (h == NULL)
 		return -ENOMEM;
 
-	memset(&h->st, 0, sizeof(h->st));
-	memset(&h->stats, 0, sizeof(h->stats));
-	memset(&h->pbuf, 0, sizeof(h->pbuf));
-	memset(&h->cbuf, 0, sizeof(h->cbuf));
-
 	h->hpa = padev->hpa.start;
 	h->card = card;
 	h->dev = padev;
-	h->irq = padev->irq;
+	h->irq = -1;
 	h->iobase = ioremap_nocache(padev->hpa.start, HARMONY_SIZE);
 	if (h->iobase == NULL) {
 		printk(KERN_ERR PFX "unable to remap hpa 0x%lx\n",
@@ -944,13 +941,14 @@ snd_harmony_create(snd_card_t *card,
 		goto free_and_ret;
 	}
 		
-	err = request_irq(h->irq, snd_harmony_interrupt, 0,
+	err = request_irq(padev->irq, snd_harmony_interrupt, 0,
 			  "harmony", h);
 	if (err) {
 		printk(KERN_ERR PFX "could not obtain interrupt %d",
-		       h->irq);
+		       padev->irq);
 		goto free_and_ret;
 	}
+	h->irq = padev->irq;
 
 	spin_lock_init(&h->mixer_lock);
 	spin_lock_init(&h->lock);
@@ -975,35 +973,24 @@ static int __devinit
 snd_harmony_probe(struct parisc_device *padev)
 {
 	int err;
-	static int dev;
 	snd_card_t *card;
 	harmony_t *h;
-	static int index = SNDRV_DEFAULT_IDX1;
-	static char *id = SNDRV_DEFAULT_STR1;
-
-	h = parisc_get_drvdata(padev);
-	if (h != NULL) {
-		return -ENODEV;
-	}
 
 	card = snd_card_new(index, id, THIS_MODULE, 0);
 	if (card == NULL)
 		return -ENOMEM;
 
 	err = snd_harmony_create(card, padev, &h);
-	if (err < 0) {
+	if (err < 0)
 		goto free_and_ret;
-	}
 
 	err = snd_harmony_pcm_init(h);
-	if (err < 0) {
+	if (err < 0)
 		goto free_and_ret;
-	}
 
 	err = snd_harmony_mixer_init(h);
-	if (err < 0) {
+	if (err < 0)
 		goto free_and_ret;
-	}
 
 	strcpy(card->driver, "harmony");
 	strcpy(card->shortname, "Harmony");
@@ -1011,13 +998,10 @@ snd_harmony_probe(struct parisc_device *padev)
 		card->shortname, h->hpa, h->irq);
 
 	err = snd_card_register(card);
-	if (err < 0) {
+	if (err < 0)
 		goto free_and_ret;
-	}
-
-	dev++;
-	parisc_set_drvdata(padev, h);
 
+	parisc_set_drvdata(padev, card);
 	return 0;
 
 free_and_ret:
@@ -1028,8 +1012,8 @@ snd_harmony_probe(struct parisc_device *padev)
 static int __devexit
 snd_harmony_remove(struct parisc_device *padev)
 {
-	harmony_t *h = parisc_get_drvdata(padev);
-	snd_card_free(h->card);
+	snd_card_free(parisc_get_drvdata(padev));
+	parisc_set_drvdata(padev, NULL);
 	return 0;
 }
 
@@ -1043,28 +1027,13 @@ static struct parisc_driver snd_harmony_driver = {
 static int __init 
 alsa_harmony_init(void)
 {
-	int err;
-
-	err = register_parisc_driver(&snd_harmony_driver);
-	if (err < 0) {
-		printk(KERN_ERR PFX "device not found\n");
-		return err;
-	}
-
-	return 0;
+	return register_parisc_driver(&snd_harmony_driver);
 }
 
 static void __exit
 alsa_harmony_fini(void)
 {
-	int err;
-
-	err = unregister_parisc_driver(&snd_harmony_driver);
-	if (err < 0) {
-		printk(KERN_ERR PFX "failed to unregister\n");
-	}
-	
-	return;
+	return unregister_parisc_driver(&snd_harmony_driver);
 }
 
 MODULE_LICENSE("GPL");

commit 3a165680168758733b7a9f7fb835954fbe6b91a8
Author: Stuart Brady <sdb@parisc-linux.org>
Date:   Fri Oct 21 22:42:38 2005 -0400

    [PARISC] Update harmony from parisc tree
    
    o Added a control for the input source (which can be either
      "line" or "mic")
    
    o Mute the speaker/line-out/headphone outputs by default.
    
    o Increased the buffer size from 10 pages to 16.
    
    Signed-off-by: Stuart Brady <sdb@parisc-linux.org>
    
    ALSA Harmony was resetting the capture position when
    preparing the capture substream, which it shouldn't do.
    This should fix the problem.
    
    Signed-off-by: Stuart Brady <sdb@parisc-linux.org>
    
    ALSA Harmony should no longer play junk (left in the buffers
    from a previous stream) at the start of a new stream.
    
    Implement the monitor mixer channel for ALSA Harmony.
    
    Also prevent snd_harmony_volume_get from returning negative values.
    
    Signed-off-by: Stuart Brady <sdb@parisc-linux.org>
    
    Use the graveyard/silence buffers in ALSA Harmony.
    
    Signed-off-by: Stuart Brady <sdb@parisc-linux.org>
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index 8b3ea26469ad..d833349ed518 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -197,7 +197,7 @@ snd_harmony_interrupt(int irq, void *dev, struct pt_regs *regs)
 	spin_unlock(&h->lock);
 
 	if (dstatus & HARMONY_DSTATUS_PN) {
-		if (h->psubs) {
+		if (h->psubs && h->st.playing) {
 			spin_lock(&h->lock);
 			h->pbuf.buf += h->pbuf.count; /* PAGE_SIZE */
 			h->pbuf.buf %= h->pbuf.size; /* MAX_BUFS*PAGE_SIZE */
@@ -216,7 +216,7 @@ snd_harmony_interrupt(int irq, void *dev, struct pt_regs *regs)
 	}
 
 	if (dstatus & HARMONY_DSTATUS_RN) {
-		if (h->csubs) {
+		if (h->csubs && h->st.capturing) {
 			spin_lock(&h->lock);
 			h->cbuf.buf += h->cbuf.count;
 			h->cbuf.buf %= h->cbuf.size;
@@ -316,6 +316,7 @@ snd_harmony_playback_trigger(snd_pcm_substream_t *ss, int cmd)
 	case SNDRV_PCM_TRIGGER_STOP:
 		h->st.playing = 0;
 		harmony_mute(h);
+		harmony_write(h, HARMONY_PNXTADD, h->sdma.addr);
 		harmony_disable_interrupts(h);
 		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
@@ -351,8 +352,9 @@ snd_harmony_capture_trigger(snd_pcm_substream_t *ss, int cmd)
 		break;
         case SNDRV_PCM_TRIGGER_STOP:
 		h->st.capturing = 0;
-                harmony_mute(h);
-                harmony_disable_interrupts(h);
+		harmony_mute(h);
+		harmony_write(h, HARMONY_RNXTADD, h->gdma.addr);
+		harmony_disable_interrupts(h);
 		break;
         case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
         case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
@@ -408,7 +410,8 @@ snd_harmony_playback_prepare(snd_pcm_substream_t *ss)
 	
 	h->pbuf.size = snd_pcm_lib_buffer_bytes(ss);
 	h->pbuf.count = snd_pcm_lib_period_bytes(ss);
-	h->pbuf.buf = 0;
+	if (h->pbuf.buf >= h->pbuf.size)
+		h->pbuf.buf = 0;
 	h->st.playing = 0;
 
 	h->st.rate = snd_harmony_rate_bits(rt->rate);
@@ -437,7 +440,8 @@ snd_harmony_capture_prepare(snd_pcm_substream_t *ss)
 
         h->cbuf.size = snd_pcm_lib_buffer_bytes(ss);
         h->cbuf.count = snd_pcm_lib_period_bytes(ss);
-        h->cbuf.buf = 0;
+	if (h->cbuf.buf >= h->cbuf.size)
+	        h->cbuf.buf = 0;
 	h->st.capturing = 0;
 
         h->st.rate = snd_harmony_rate_bits(rt->rate);
@@ -712,13 +716,14 @@ snd_harmony_volume_get(snd_kcontrol_t *kc,
 
 	left = (h->st.gain >> shift_left) & mask;
 	right = (h->st.gain >> shift_right) & mask;
-
 	if (invert) {
 		left = mask - left;
 		right = mask - right;
 	}
+	
 	ucontrol->value.integer.value[0] = left;
-	ucontrol->value.integer.value[1] = right;
+	if (shift_left != shift_right)
+		ucontrol->value.integer.value[1] = right;
 
 	spin_unlock_irqrestore(&h->mixer_lock, flags);
 
@@ -738,22 +743,82 @@ snd_harmony_volume_put(snd_kcontrol_t *kc,
 	int old_gain = h->st.gain;
 	unsigned long flags;
 	
+	spin_lock_irqsave(&h->mixer_lock, flags);
+
 	left = ucontrol->value.integer.value[0] & mask;
-	right = ucontrol->value.integer.value[1] & mask;
-	if (invert) {
+	if (invert)
 		left = mask - left;
-		right = mask - right;
+	h->st.gain &= ~( (mask << shift_left ) );
+ 	h->st.gain |= (left << shift_left);
+
+	if (shift_left != shift_right) {
+		right = ucontrol->value.integer.value[1] & mask;
+		if (invert)
+			right = mask - right;
+		h->st.gain &= ~( (mask << shift_right) );
+		h->st.gain |= (right << shift_right);
 	}
+
+	snd_harmony_set_new_gain(h);
+
+	spin_unlock_irqrestore(&h->mixer_lock, flags);
+	
+	return h->st.gain != old_gain;
+}
+
+static int 
+snd_harmony_captureroute_info(snd_kcontrol_t *kc, 
+			      snd_ctl_elem_info_t *uinfo)
+{
+	static char *texts[2] = { "Line", "Mic" };
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+	if (uinfo->value.enumerated.item > 1)
+		uinfo->value.enumerated.item = 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int 
+snd_harmony_captureroute_get(snd_kcontrol_t *kc, 
+			     snd_ctl_elem_value_t *ucontrol)
+{
+	harmony_t *h = snd_kcontrol_chip(kc);
+	int value;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&h->mixer_lock, flags);
+
+	value = (h->st.gain >> HARMONY_GAIN_IS_SHIFT) & 1;
+	ucontrol->value.enumerated.item[0] = value;
+
+	spin_unlock_irqrestore(&h->mixer_lock, flags);
+
+	return 0;
+}  
+
+static int 
+snd_harmony_captureroute_put(snd_kcontrol_t *kc, 
+			     snd_ctl_elem_value_t *ucontrol)
+{
+	harmony_t *h = snd_kcontrol_chip(kc);
+	int value;
+	int old_gain = h->st.gain;
+	unsigned long flags;
 	
 	spin_lock_irqsave(&h->mixer_lock, flags);
 
-	h->st.gain &= ~( (mask << shift_right) | (mask << shift_left) );
- 	h->st.gain |=  ( (left << shift_left) | (right << shift_right) );
+	value = ucontrol->value.enumerated.item[0] & 1;
+	h->st.gain &= ~HARMONY_GAIN_IS_MASK;
+ 	h->st.gain |= value << HARMONY_GAIN_IS_SHIFT;
+
 	snd_harmony_set_new_gain(h);
 
 	spin_unlock_irqrestore(&h->mixer_lock, flags);
 	
-	return (old_gain - h->st.gain);
+	return h->st.gain != old_gain;
 }
 
 #define HARMONY_CONTROLS (sizeof(snd_harmony_controls)/ \
@@ -767,10 +832,25 @@ snd_harmony_volume_put(snd_kcontrol_t *kc,
                    ((mask) << 16) | ((invert) << 24)) }
 
 static snd_kcontrol_new_t snd_harmony_controls[] = {
-	HARMONY_VOLUME("Playback Volume", HARMONY_GAIN_LO_SHIFT, 
+	HARMONY_VOLUME("Master Playback Volume", HARMONY_GAIN_LO_SHIFT, 
 		       HARMONY_GAIN_RO_SHIFT, HARMONY_GAIN_OUT, 1),
 	HARMONY_VOLUME("Capture Volume", HARMONY_GAIN_LI_SHIFT,
 		       HARMONY_GAIN_RI_SHIFT, HARMONY_GAIN_IN, 0),
+	HARMONY_VOLUME("Monitor Volume", HARMONY_GAIN_MA_SHIFT,
+		       HARMONY_GAIN_MA_SHIFT, HARMONY_GAIN_MA, 1),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Input Route",
+		.info = snd_harmony_captureroute_info,
+		.get = snd_harmony_captureroute_get,
+		.put = snd_harmony_captureroute_put
+	},
+	HARMONY_VOLUME("Internal Speaker Switch", HARMONY_GAIN_SE_SHIFT,
+		       HARMONY_GAIN_SE_SHIFT, 1, 0),
+	HARMONY_VOLUME("Line-Out Switch", HARMONY_GAIN_LE_SHIFT,
+		       HARMONY_GAIN_LE_SHIFT, 1, 0),
+	HARMONY_VOLUME("Headphones Switch", HARMONY_GAIN_HE_SHIFT,
+		       HARMONY_GAIN_HE_SHIFT, 1, 0),
 };
 
 static void __init 

commit 53f01bba49938f115237fe43a261c31ac13ae5c6
Author: Matthew Wilcox <willy@parisc-linux.org>
Date:   Fri Oct 21 22:36:40 2005 -0400

    [PARISC] Convert parisc_device to use struct resource for hpa
    
    Convert pa_dev->hpa from an unsigned long to a struct resource.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    Fix up users of ->hpa to use ->hpa.start instead.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index f560dd8cdb90..8b3ea26469ad 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -852,14 +852,14 @@ snd_harmony_create(snd_card_t *card,
 	memset(&h->pbuf, 0, sizeof(h->pbuf));
 	memset(&h->cbuf, 0, sizeof(h->cbuf));
 
-	h->hpa = padev->hpa;
+	h->hpa = padev->hpa.start;
 	h->card = card;
 	h->dev = padev;
 	h->irq = padev->irq;
-	h->iobase = ioremap_nocache(padev->hpa, HARMONY_SIZE);
+	h->iobase = ioremap_nocache(padev->hpa.start, HARMONY_SIZE);
 	if (h->iobase == NULL) {
 		printk(KERN_ERR PFX "unable to remap hpa 0x%lx\n",
-		       padev->hpa);
+		       padev->hpa.start);
 		err = -EBUSY;
 		goto free_and_ret;
 	}

commit a76af199dc025e8f5cf6b9542efadc3de5163a7a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 5 16:56:40 2005 +0200

    [ALSA] Add snd_card_set_dev()
    
    ARM AACI PL041 driver,PARISC Harmony driver
    Added snd_card_set_dev() calls to register the device pointer for the card.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
index d7a8f9f5896f..f560dd8cdb90 100644
--- a/sound/parisc/harmony.c
+++ b/sound/parisc/harmony.c
@@ -880,6 +880,8 @@ snd_harmony_create(snd_card_t *card,
                 goto free_and_ret;
         }
 
+	snd_card_set_dev(card, &padev->dev);
+
 	*rchip = h;
 
 	return 0;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/parisc/harmony.c b/sound/parisc/harmony.c
new file mode 100644
index 000000000000..d7a8f9f5896f
--- /dev/null
+++ b/sound/parisc/harmony.c
@@ -0,0 +1,993 @@
+/* Hewlett-Packard Harmony audio driver
+ *
+ *   This is a driver for the Harmony audio chipset found
+ *   on the LASI ASIC of various early HP PA-RISC workstations.
+ *
+ *   Copyright (C) 2004, Kyle McMartin <kyle@{debian.org,parisc-linux.org}>
+ *
+ *     Based on the previous Harmony incarnations by,
+ *       Copyright 2000 (c) Linuxcare Canada, Alex deVries
+ *       Copyright 2000-2003 (c) Helge Deller
+ *       Copyright 2001 (c) Matthieu Delahaye
+ *       Copyright 2001 (c) Jean-Christophe Vaugeois
+ *       Copyright 2003 (c) Laurent Canet
+ *       Copyright 2004 (c) Stuart Brady
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License, version 2, as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Notes:
+ *   - graveyard and silence buffers last for lifetime of
+ *     the driver. playback and capture buffers are allocated
+ *     per _open()/_close().
+ * 
+ * TODO:
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/control.h>
+#include <sound/rawmidi.h>
+#include <sound/initval.h>
+#include <sound/info.h>
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/parisc-device.h>
+
+#include "harmony.h"
+
+static struct parisc_device_id snd_harmony_devtable[] = {
+	/* bushmaster / flounder */
+	{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0007A }, 
+	/* 712 / 715 */
+	{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0007B }, 
+	/* pace */
+	{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0007E }, 
+	/* outfield / coral II */
+	{ HPHW_FIO, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x0007F },
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(parisc, snd_harmony_devtable);
+
+#define NAME "harmony"
+#define PFX  NAME ": "
+
+static unsigned int snd_harmony_rates[] = {
+	5512, 6615, 8000, 9600,
+	11025, 16000, 18900, 22050,
+	27428, 32000, 33075, 37800,
+	44100, 48000
+};
+
+static unsigned int rate_bits[14] = {
+	HARMONY_SR_5KHZ, HARMONY_SR_6KHZ, HARMONY_SR_8KHZ,
+	HARMONY_SR_9KHZ, HARMONY_SR_11KHZ, HARMONY_SR_16KHZ,
+	HARMONY_SR_18KHZ, HARMONY_SR_22KHZ, HARMONY_SR_27KHZ,
+	HARMONY_SR_32KHZ, HARMONY_SR_33KHZ, HARMONY_SR_37KHZ,
+	HARMONY_SR_44KHZ, HARMONY_SR_48KHZ
+};
+
+static snd_pcm_hw_constraint_list_t hw_constraint_rates = {
+	.count = ARRAY_SIZE(snd_harmony_rates),
+	.list = snd_harmony_rates,
+	.mask = 0,
+};
+
+inline unsigned long
+harmony_read(harmony_t *h, unsigned r)
+{
+	return __raw_readl(h->iobase + r);
+}
+
+inline void
+harmony_write(harmony_t *h, unsigned r, unsigned long v)
+{
+	__raw_writel(v, h->iobase + r);
+}
+
+static void
+harmony_wait_for_control(harmony_t *h)
+{
+	while (harmony_read(h, HARMONY_CNTL) & HARMONY_CNTL_C) ;
+}
+
+inline void
+harmony_reset(harmony_t *h)
+{
+	harmony_write(h, HARMONY_RESET, 1);
+	mdelay(50);
+	harmony_write(h, HARMONY_RESET, 0);
+}
+
+static void
+harmony_disable_interrupts(harmony_t *h)
+{
+	u32 dstatus;
+	harmony_wait_for_control(h);
+	dstatus = harmony_read(h, HARMONY_DSTATUS);
+	dstatus &= ~HARMONY_DSTATUS_IE;
+	harmony_write(h, HARMONY_DSTATUS, dstatus);
+}
+
+static void
+harmony_enable_interrupts(harmony_t *h)
+{
+	u32 dstatus;
+	harmony_wait_for_control(h);
+	dstatus = harmony_read(h, HARMONY_DSTATUS);
+	dstatus |= HARMONY_DSTATUS_IE;
+	harmony_write(h, HARMONY_DSTATUS, dstatus);
+}
+
+static void
+harmony_mute(harmony_t *h)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&h->mixer_lock, flags);
+	harmony_wait_for_control(h);
+	harmony_write(h, HARMONY_GAINCTL, HARMONY_GAIN_SILENCE);
+	spin_unlock_irqrestore(&h->mixer_lock, flags);
+}
+
+static void
+harmony_unmute(harmony_t *h)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&h->mixer_lock, flags);
+	harmony_wait_for_control(h);
+	harmony_write(h, HARMONY_GAINCTL, h->st.gain);
+	spin_unlock_irqrestore(&h->mixer_lock, flags);
+}
+
+static void
+harmony_set_control(harmony_t *h)
+{
+	u32 ctrl;
+	unsigned long flags;
+
+	spin_lock_irqsave(&h->lock, flags);
+
+	ctrl = (HARMONY_CNTL_C      |
+		(h->st.format << 6) |
+		(h->st.stereo << 5) |
+		(h->st.rate));
+
+	harmony_wait_for_control(h);
+	harmony_write(h, HARMONY_CNTL, ctrl);
+
+	spin_unlock_irqrestore(&h->lock, flags);
+}
+
+static irqreturn_t
+snd_harmony_interrupt(int irq, void *dev, struct pt_regs *regs)
+{
+	u32 dstatus;
+	harmony_t *h = dev;
+
+	spin_lock(&h->lock);
+	harmony_disable_interrupts(h);
+	harmony_wait_for_control(h);
+	dstatus = harmony_read(h, HARMONY_DSTATUS);
+	spin_unlock(&h->lock);
+
+	if (dstatus & HARMONY_DSTATUS_PN) {
+		if (h->psubs) {
+			spin_lock(&h->lock);
+			h->pbuf.buf += h->pbuf.count; /* PAGE_SIZE */
+			h->pbuf.buf %= h->pbuf.size; /* MAX_BUFS*PAGE_SIZE */
+
+			harmony_write(h, HARMONY_PNXTADD, 
+				      h->pbuf.addr + h->pbuf.buf);
+			h->stats.play_intr++;
+			spin_unlock(&h->lock);
+                        snd_pcm_period_elapsed(h->psubs);
+		} else {
+			spin_lock(&h->lock);
+			harmony_write(h, HARMONY_PNXTADD, h->sdma.addr);
+			h->stats.silence_intr++;
+			spin_unlock(&h->lock);
+		}
+	}
+
+	if (dstatus & HARMONY_DSTATUS_RN) {
+		if (h->csubs) {
+			spin_lock(&h->lock);
+			h->cbuf.buf += h->cbuf.count;
+			h->cbuf.buf %= h->cbuf.size;
+
+			harmony_write(h, HARMONY_RNXTADD,
+				      h->cbuf.addr + h->cbuf.buf);
+			h->stats.rec_intr++;
+			spin_unlock(&h->lock);
+                        snd_pcm_period_elapsed(h->csubs);
+		} else {
+			spin_lock(&h->lock);
+			harmony_write(h, HARMONY_RNXTADD, h->gdma.addr);
+			h->stats.graveyard_intr++;
+			spin_unlock(&h->lock);
+		}
+	}
+
+	spin_lock(&h->lock);
+	harmony_enable_interrupts(h);
+	spin_unlock(&h->lock);
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int 
+snd_harmony_rate_bits(int rate)
+{
+	unsigned int i;
+	
+	for (i = 0; i < ARRAY_SIZE(snd_harmony_rates); i++)
+		if (snd_harmony_rates[i] == rate)
+			return rate_bits[i];
+
+	return HARMONY_SR_44KHZ;
+}
+
+static snd_pcm_hardware_t snd_harmony_playback =
+{
+	.info =	(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED | 
+		 SNDRV_PCM_INFO_JOINT_DUPLEX | SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER),
+	.formats = (SNDRV_PCM_FMTBIT_S16_BE | SNDRV_PCM_FMTBIT_MU_LAW |
+		    SNDRV_PCM_FMTBIT_A_LAW),
+	.rates = (SNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000_48000 |
+		  SNDRV_PCM_RATE_KNOT),
+	.rate_min = 5512,
+	.rate_max = 48000,
+	.channels_min =	1,
+	.channels_max =	2,
+	.buffer_bytes_max = MAX_BUF_SIZE,
+	.period_bytes_min = BUF_SIZE,
+	.period_bytes_max = BUF_SIZE,
+	.periods_min = 1,
+	.periods_max = MAX_BUFS,
+	.fifo_size = 0,
+};
+
+static snd_pcm_hardware_t snd_harmony_capture =
+{
+        .info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+                 SNDRV_PCM_INFO_JOINT_DUPLEX | SNDRV_PCM_INFO_MMAP_VALID |
+                 SNDRV_PCM_INFO_BLOCK_TRANSFER),
+        .formats = (SNDRV_PCM_FMTBIT_S16_BE | SNDRV_PCM_FMTBIT_MU_LAW |
+                    SNDRV_PCM_FMTBIT_A_LAW),
+        .rates = (SNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000_48000 |
+		  SNDRV_PCM_RATE_KNOT),
+        .rate_min = 5512,
+        .rate_max = 48000,
+        .channels_min = 1,
+        .channels_max = 2,
+        .buffer_bytes_max = MAX_BUF_SIZE,
+        .period_bytes_min = BUF_SIZE,
+        .period_bytes_max = BUF_SIZE,
+        .periods_min = 1,
+        .periods_max = MAX_BUFS,
+        .fifo_size = 0,
+};
+
+static int
+snd_harmony_playback_trigger(snd_pcm_substream_t *ss, int cmd)
+{
+	harmony_t *h = snd_pcm_substream_chip(ss);
+	unsigned long flags;
+
+	if (h->st.capturing)
+		return -EBUSY;
+
+	spin_lock_irqsave(&h->lock, flags);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		h->st.playing = 1;
+		harmony_write(h, HARMONY_PNXTADD, h->pbuf.addr);
+		harmony_write(h, HARMONY_RNXTADD, h->gdma.addr);
+		harmony_unmute(h);
+		harmony_enable_interrupts(h);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		h->st.playing = 0;
+		harmony_mute(h);
+		harmony_disable_interrupts(h);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	default:
+		spin_unlock_irqrestore(&h->lock, flags);
+		snd_BUG();
+		return -EINVAL;
+	}
+	spin_unlock_irqrestore(&h->lock, flags);
+	
+	return 0;
+}
+
+static int
+snd_harmony_capture_trigger(snd_pcm_substream_t *ss, int cmd)
+{
+        harmony_t *h = snd_pcm_substream_chip(ss);
+	unsigned long flags;
+
+	if (h->st.playing)
+		return -EBUSY;
+
+	spin_lock_irqsave(&h->lock, flags);
+        switch (cmd) {
+        case SNDRV_PCM_TRIGGER_START:
+		h->st.capturing = 1;
+                harmony_write(h, HARMONY_PNXTADD, h->sdma.addr);
+                harmony_write(h, HARMONY_RNXTADD, h->cbuf.addr);
+		harmony_unmute(h);
+                harmony_enable_interrupts(h);
+		break;
+        case SNDRV_PCM_TRIGGER_STOP:
+		h->st.capturing = 0;
+                harmony_mute(h);
+                harmony_disable_interrupts(h);
+		break;
+        case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+        case SNDRV_PCM_TRIGGER_SUSPEND:
+	default:
+		spin_unlock_irqrestore(&h->lock, flags);
+		snd_BUG();
+                return -EINVAL;
+        }
+	spin_unlock_irqrestore(&h->lock, flags);
+		
+        return 0;
+}
+
+static int
+snd_harmony_set_data_format(harmony_t *h, int fmt, int force)
+{
+	int o = h->st.format;
+	int n;
+
+	switch(fmt) {
+	case SNDRV_PCM_FORMAT_S16_BE:
+		n = HARMONY_DF_16BIT_LINEAR;
+		break;
+	case SNDRV_PCM_FORMAT_A_LAW:
+		n = HARMONY_DF_8BIT_ALAW;
+		break;
+	case SNDRV_PCM_FORMAT_MU_LAW:
+		n = HARMONY_DF_8BIT_ULAW;
+		break;
+	default:
+		n = HARMONY_DF_16BIT_LINEAR;
+		break;
+	}
+
+	if (force || o != n) {
+		snd_pcm_format_set_silence(fmt, h->sdma.area, SILENCE_BUFSZ / 
+					   (snd_pcm_format_physical_width(fmt)
+					    / 8));
+	}
+
+	return n;
+}
+
+static int
+snd_harmony_playback_prepare(snd_pcm_substream_t *ss)
+{
+	harmony_t *h = snd_pcm_substream_chip(ss);
+	snd_pcm_runtime_t *rt = ss->runtime;
+	
+	if (h->st.capturing)
+		return -EBUSY;
+	
+	h->pbuf.size = snd_pcm_lib_buffer_bytes(ss);
+	h->pbuf.count = snd_pcm_lib_period_bytes(ss);
+	h->pbuf.buf = 0;
+	h->st.playing = 0;
+
+	h->st.rate = snd_harmony_rate_bits(rt->rate);
+	h->st.format = snd_harmony_set_data_format(h, rt->format, 0);
+	
+	if (rt->channels == 2)
+		h->st.stereo = HARMONY_SS_STEREO;
+	else
+		h->st.stereo = HARMONY_SS_MONO;
+
+	harmony_set_control(h);
+
+	h->pbuf.addr = rt->dma_addr;
+
+	return 0;
+}
+
+static int
+snd_harmony_capture_prepare(snd_pcm_substream_t *ss)
+{
+        harmony_t *h = snd_pcm_substream_chip(ss);
+        snd_pcm_runtime_t *rt = ss->runtime;
+
+	if (h->st.playing)
+		return -EBUSY;
+
+        h->cbuf.size = snd_pcm_lib_buffer_bytes(ss);
+        h->cbuf.count = snd_pcm_lib_period_bytes(ss);
+        h->cbuf.buf = 0;
+	h->st.capturing = 0;
+
+        h->st.rate = snd_harmony_rate_bits(rt->rate);
+        h->st.format = snd_harmony_set_data_format(h, rt->format, 0);
+
+        if (rt->channels == 2)
+                h->st.stereo = HARMONY_SS_STEREO;
+        else
+                h->st.stereo = HARMONY_SS_MONO;
+
+        harmony_set_control(h);
+
+        h->cbuf.addr = rt->dma_addr;
+
+        return 0;
+}
+
+static snd_pcm_uframes_t 
+snd_harmony_playback_pointer(snd_pcm_substream_t *ss)
+{
+	snd_pcm_runtime_t *rt = ss->runtime;
+	harmony_t *h = snd_pcm_substream_chip(ss);
+	unsigned long pcuradd;
+	unsigned long played;
+
+	if (!(h->st.playing) || (h->psubs == NULL)) 
+		return 0;
+
+	if ((h->pbuf.addr == 0) || (h->pbuf.size == 0))
+		return 0;
+	
+	pcuradd = harmony_read(h, HARMONY_PCURADD);
+	played = pcuradd - h->pbuf.addr;
+
+#ifdef HARMONY_DEBUG
+	printk(KERN_DEBUG PFX "playback_pointer is 0x%lx-0x%lx = %d bytes\n", 
+	       pcuradd, h->pbuf.addr, played);	
+#endif
+
+	if (pcuradd > h->pbuf.addr + h->pbuf.size) {
+		return 0;
+	}
+
+	return bytes_to_frames(rt, played);
+}
+
+static snd_pcm_uframes_t
+snd_harmony_capture_pointer(snd_pcm_substream_t *ss)
+{
+        snd_pcm_runtime_t *rt = ss->runtime;
+        harmony_t *h = snd_pcm_substream_chip(ss);
+        unsigned long rcuradd;
+        unsigned long caught;
+
+        if (!(h->st.capturing) || (h->csubs == NULL))
+                return 0;
+
+        if ((h->cbuf.addr == 0) || (h->cbuf.size == 0))
+                return 0;
+
+        rcuradd = harmony_read(h, HARMONY_RCURADD);
+        caught = rcuradd - h->cbuf.addr;
+
+#ifdef HARMONY_DEBUG
+        printk(KERN_DEBUG PFX "capture_pointer is 0x%lx-0x%lx = %d bytes\n",
+               rcuradd, h->cbuf.addr, caught);
+#endif
+
+        if (rcuradd > h->cbuf.addr + h->cbuf.size) {
+		return 0;
+	}
+
+        return bytes_to_frames(rt, caught);
+}
+
+static int 
+snd_harmony_playback_open(snd_pcm_substream_t *ss)
+{
+	harmony_t *h = snd_pcm_substream_chip(ss);
+	snd_pcm_runtime_t *rt = ss->runtime;
+	int err;
+	
+	h->psubs = ss;
+	rt->hw = snd_harmony_playback;
+	snd_pcm_hw_constraint_list(rt, 0, SNDRV_PCM_HW_PARAM_RATE, 
+				   &hw_constraint_rates);
+	
+	err = snd_pcm_hw_constraint_integer(rt, SNDRV_PCM_HW_PARAM_PERIODS);
+	if (err < 0)
+		return err;
+	
+	return 0;
+}
+
+static int
+snd_harmony_capture_open(snd_pcm_substream_t *ss)
+{
+        harmony_t *h = snd_pcm_substream_chip(ss);
+        snd_pcm_runtime_t *rt = ss->runtime;
+        int err;
+
+        h->csubs = ss;
+        rt->hw = snd_harmony_capture;
+        snd_pcm_hw_constraint_list(rt, 0, SNDRV_PCM_HW_PARAM_RATE,
+                                   &hw_constraint_rates);
+
+        err = snd_pcm_hw_constraint_integer(rt, SNDRV_PCM_HW_PARAM_PERIODS);
+        if (err < 0)
+                return err;
+
+        return 0;
+}
+
+static int 
+snd_harmony_playback_close(snd_pcm_substream_t *ss)
+{
+	harmony_t *h = snd_pcm_substream_chip(ss);
+	h->psubs = NULL;
+	return 0;
+}
+
+static int
+snd_harmony_capture_close(snd_pcm_substream_t *ss)
+{
+        harmony_t *h = snd_pcm_substream_chip(ss);
+        h->csubs = NULL;
+        return 0;
+}
+
+static int 
+snd_harmony_hw_params(snd_pcm_substream_t *ss,
+		      snd_pcm_hw_params_t *hw)
+{
+	int err;
+	harmony_t *h = snd_pcm_substream_chip(ss);
+	
+	err = snd_pcm_lib_malloc_pages(ss, params_buffer_bytes(hw));
+	if (err > 0 && h->dma.type == SNDRV_DMA_TYPE_CONTINUOUS)
+		ss->runtime->dma_addr = __pa(ss->runtime->dma_area);
+	
+	return err;
+}
+
+static int 
+snd_harmony_hw_free(snd_pcm_substream_t *ss) 
+{
+	return snd_pcm_lib_free_pages(ss);
+}
+
+static snd_pcm_ops_t snd_harmony_playback_ops = {
+	.open =	snd_harmony_playback_open,
+	.close = snd_harmony_playback_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = snd_harmony_hw_params,
+	.hw_free = snd_harmony_hw_free,
+	.prepare = snd_harmony_playback_prepare,
+	.trigger = snd_harmony_playback_trigger,
+ 	.pointer = snd_harmony_playback_pointer,
+};
+
+static snd_pcm_ops_t snd_harmony_capture_ops = {
+        .open = snd_harmony_capture_open,
+        .close = snd_harmony_capture_close,
+        .ioctl = snd_pcm_lib_ioctl,
+        .hw_params = snd_harmony_hw_params,
+        .hw_free = snd_harmony_hw_free,
+        .prepare = snd_harmony_capture_prepare,
+        .trigger = snd_harmony_capture_trigger,
+        .pointer = snd_harmony_capture_pointer,
+};
+
+static int 
+snd_harmony_pcm_init(harmony_t *h)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	harmony_disable_interrupts(h);
+	
+   	err = snd_pcm_new(h->card, "harmony", 0, 1, 1, &pcm);
+	if (err < 0)
+		return err;
+	
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, 
+			&snd_harmony_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+			&snd_harmony_capture_ops);
+
+	pcm->private_data = h;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "harmony");
+	h->pcm = pcm;
+
+	h->psubs = NULL;
+	h->csubs = NULL;
+	
+	/* initialize graveyard buffer */
+	h->dma.type = SNDRV_DMA_TYPE_DEV;
+	h->dma.dev = &h->dev->dev;
+	err = snd_dma_alloc_pages(h->dma.type,
+				  h->dma.dev,
+				  BUF_SIZE*GRAVEYARD_BUFS,
+				  &h->gdma);
+	if (err < 0) {
+		printk(KERN_ERR PFX "cannot allocate graveyard buffer!\n");
+		return err;
+	}
+	
+	/* initialize silence buffers */
+	err = snd_dma_alloc_pages(h->dma.type,
+				  h->dma.dev,
+				  BUF_SIZE*SILENCE_BUFS,
+				  &h->sdma);
+	if (err < 0) {
+		printk(KERN_ERR PFX "cannot allocate silence buffer!\n");
+		return err;
+	}
+
+	/* pre-allocate space for DMA */
+	err = snd_pcm_lib_preallocate_pages_for_all(pcm, h->dma.type,
+						    h->dma.dev,
+						    MAX_BUF_SIZE, 
+						    MAX_BUF_SIZE);
+	if (err < 0) {
+		printk(KERN_ERR PFX "buffer allocation error: %d\n", err);
+		return err;
+	}
+
+	h->st.format = snd_harmony_set_data_format(h,
+		SNDRV_PCM_FORMAT_S16_BE, 1);
+
+	return 0;
+}
+
+static void 
+snd_harmony_set_new_gain(harmony_t *h)
+{
+ 	harmony_wait_for_control(h);
+	harmony_write(h, HARMONY_GAINCTL, h->st.gain);
+}
+
+static int 
+snd_harmony_mixercontrol_info(snd_kcontrol_t *kc, 
+			      snd_ctl_elem_info_t *uinfo)
+{
+	int mask = (kc->private_value >> 16) & 0xff;
+	int left_shift = (kc->private_value) & 0xff;
+	int right_shift = (kc->private_value >> 8) & 0xff;
+	
+	uinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : 
+		       SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = left_shift == right_shift ? 1 : 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+
+	return 0;
+}
+
+static int 
+snd_harmony_volume_get(snd_kcontrol_t *kc, 
+		       snd_ctl_elem_value_t *ucontrol)
+{
+	harmony_t *h = snd_kcontrol_chip(kc);
+	int shift_left = (kc->private_value) & 0xff;
+	int shift_right = (kc->private_value >> 8) & 0xff;
+	int mask = (kc->private_value >> 16) & 0xff;
+	int invert = (kc->private_value >> 24) & 0xff;
+	int left, right;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&h->mixer_lock, flags);
+
+	left = (h->st.gain >> shift_left) & mask;
+	right = (h->st.gain >> shift_right) & mask;
+
+	if (invert) {
+		left = mask - left;
+		right = mask - right;
+	}
+	ucontrol->value.integer.value[0] = left;
+	ucontrol->value.integer.value[1] = right;
+
+	spin_unlock_irqrestore(&h->mixer_lock, flags);
+
+	return 0;
+}  
+
+static int 
+snd_harmony_volume_put(snd_kcontrol_t *kc, 
+		       snd_ctl_elem_value_t *ucontrol)
+{
+	harmony_t *h = snd_kcontrol_chip(kc);
+	int shift_left = (kc->private_value) & 0xff;
+	int shift_right = (kc->private_value >> 8) & 0xff;
+	int mask = (kc->private_value >> 16) & 0xff;
+	int invert = (kc->private_value >> 24) & 0xff;
+	int left, right;
+	int old_gain = h->st.gain;
+	unsigned long flags;
+	
+	left = ucontrol->value.integer.value[0] & mask;
+	right = ucontrol->value.integer.value[1] & mask;
+	if (invert) {
+		left = mask - left;
+		right = mask - right;
+	}
+	
+	spin_lock_irqsave(&h->mixer_lock, flags);
+
+	h->st.gain &= ~( (mask << shift_right) | (mask << shift_left) );
+ 	h->st.gain |=  ( (left << shift_left) | (right << shift_right) );
+	snd_harmony_set_new_gain(h);
+
+	spin_unlock_irqrestore(&h->mixer_lock, flags);
+	
+	return (old_gain - h->st.gain);
+}
+
+#define HARMONY_CONTROLS (sizeof(snd_harmony_controls)/ \
+                          sizeof(snd_kcontrol_new_t))
+
+#define HARMONY_VOLUME(xname, left_shift, right_shift, mask, invert) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,                \
+  .info = snd_harmony_mixercontrol_info,                             \
+  .get = snd_harmony_volume_get, .put = snd_harmony_volume_put,      \
+  .private_value = ((left_shift) | ((right_shift) << 8) |            \
+                   ((mask) << 16) | ((invert) << 24)) }
+
+static snd_kcontrol_new_t snd_harmony_controls[] = {
+	HARMONY_VOLUME("Playback Volume", HARMONY_GAIN_LO_SHIFT, 
+		       HARMONY_GAIN_RO_SHIFT, HARMONY_GAIN_OUT, 1),
+	HARMONY_VOLUME("Capture Volume", HARMONY_GAIN_LI_SHIFT,
+		       HARMONY_GAIN_RI_SHIFT, HARMONY_GAIN_IN, 0),
+};
+
+static void __init 
+snd_harmony_mixer_reset(harmony_t *h)
+{
+	harmony_mute(h);
+	harmony_reset(h);
+	h->st.gain = HARMONY_GAIN_DEFAULT;
+	harmony_unmute(h);
+}
+
+static int __init 
+snd_harmony_mixer_init(harmony_t *h)
+{
+	snd_card_t *card = h->card;
+	int idx, err;
+
+	snd_assert(h != NULL, return -EINVAL);
+	strcpy(card->mixername, "Harmony Gain control interface");
+
+	for (idx = 0; idx < HARMONY_CONTROLS; idx++) {
+		err = snd_ctl_add(card, 
+				  snd_ctl_new1(&snd_harmony_controls[idx], h));
+		if (err < 0)
+			return err;
+	}
+	
+	snd_harmony_mixer_reset(h);
+
+	return 0;
+}
+
+static int
+snd_harmony_free(harmony_t *h)
+{
+        if (h->gdma.addr)
+                snd_dma_free_pages(&h->gdma);
+        if (h->sdma.addr)
+                snd_dma_free_pages(&h->sdma);
+
+	if (h->irq >= 0)
+		free_irq(h->irq, h);
+
+	if (h->iobase)
+		iounmap(h->iobase);
+
+	parisc_set_drvdata(h->dev, NULL);
+
+	kfree(h);
+	return 0;
+}
+
+static int
+snd_harmony_dev_free(snd_device_t *dev)
+{
+	harmony_t *h = dev->device_data;
+	return snd_harmony_free(h);
+}
+
+static int __devinit
+snd_harmony_create(snd_card_t *card, 
+		   struct parisc_device *padev, 
+		   harmony_t **rchip)
+{
+	int err;
+	harmony_t *h;
+	static snd_device_ops_t ops = {
+		.dev_free = snd_harmony_dev_free,
+	};
+
+	*rchip = NULL;
+
+	h = kmalloc(sizeof(*h), GFP_KERNEL);
+	if (h == NULL)
+		return -ENOMEM;
+
+	memset(&h->st, 0, sizeof(h->st));
+	memset(&h->stats, 0, sizeof(h->stats));
+	memset(&h->pbuf, 0, sizeof(h->pbuf));
+	memset(&h->cbuf, 0, sizeof(h->cbuf));
+
+	h->hpa = padev->hpa;
+	h->card = card;
+	h->dev = padev;
+	h->irq = padev->irq;
+	h->iobase = ioremap_nocache(padev->hpa, HARMONY_SIZE);
+	if (h->iobase == NULL) {
+		printk(KERN_ERR PFX "unable to remap hpa 0x%lx\n",
+		       padev->hpa);
+		err = -EBUSY;
+		goto free_and_ret;
+	}
+		
+	err = request_irq(h->irq, snd_harmony_interrupt, 0,
+			  "harmony", h);
+	if (err) {
+		printk(KERN_ERR PFX "could not obtain interrupt %d",
+		       h->irq);
+		goto free_and_ret;
+	}
+
+	spin_lock_init(&h->mixer_lock);
+	spin_lock_init(&h->lock);
+
+        if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,
+                                  h, &ops)) < 0) {
+                goto free_and_ret;
+        }
+
+	*rchip = h;
+
+	return 0;
+
+free_and_ret:
+	snd_harmony_free(h);
+	return err;
+}
+
+static int __devinit
+snd_harmony_probe(struct parisc_device *padev)
+{
+	int err;
+	static int dev;
+	snd_card_t *card;
+	harmony_t *h;
+	static int index = SNDRV_DEFAULT_IDX1;
+	static char *id = SNDRV_DEFAULT_STR1;
+
+	h = parisc_get_drvdata(padev);
+	if (h != NULL) {
+		return -ENODEV;
+	}
+
+	card = snd_card_new(index, id, THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+
+	err = snd_harmony_create(card, padev, &h);
+	if (err < 0) {
+		goto free_and_ret;
+	}
+
+	err = snd_harmony_pcm_init(h);
+	if (err < 0) {
+		goto free_and_ret;
+	}
+
+	err = snd_harmony_mixer_init(h);
+	if (err < 0) {
+		goto free_and_ret;
+	}
+
+	strcpy(card->driver, "harmony");
+	strcpy(card->shortname, "Harmony");
+	sprintf(card->longname, "%s at 0x%lx, irq %i",
+		card->shortname, h->hpa, h->irq);
+
+	err = snd_card_register(card);
+	if (err < 0) {
+		goto free_and_ret;
+	}
+
+	dev++;
+	parisc_set_drvdata(padev, h);
+
+	return 0;
+
+free_and_ret:
+	snd_card_free(card);
+	return err;
+}
+
+static int __devexit
+snd_harmony_remove(struct parisc_device *padev)
+{
+	harmony_t *h = parisc_get_drvdata(padev);
+	snd_card_free(h->card);
+	return 0;
+}
+
+static struct parisc_driver snd_harmony_driver = {
+	.name = "harmony",
+	.id_table = snd_harmony_devtable,
+	.probe = snd_harmony_probe,
+	.remove = snd_harmony_remove,
+};
+
+static int __init 
+alsa_harmony_init(void)
+{
+	int err;
+
+	err = register_parisc_driver(&snd_harmony_driver);
+	if (err < 0) {
+		printk(KERN_ERR PFX "device not found\n");
+		return err;
+	}
+
+	return 0;
+}
+
+static void __exit
+alsa_harmony_fini(void)
+{
+	int err;
+
+	err = unregister_parisc_driver(&snd_harmony_driver);
+	if (err < 0) {
+		printk(KERN_ERR PFX "failed to unregister\n");
+	}
+	
+	return;
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kyle McMartin <kyle@parisc-linux.org>");
+MODULE_DESCRIPTION("Harmony sound driver");
+
+module_init(alsa_harmony_init);
+module_exit(alsa_harmony_fini);
