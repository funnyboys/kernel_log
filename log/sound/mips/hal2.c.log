commit 35a76585c6386115c065ebdda906f9a65a1b75ce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:28 2020 +0100

    ALSA: mips: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-13-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index db44d9d691db..ec84bc4c3a6e 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -732,7 +732,7 @@ static int hal2_dev_free(struct snd_device *device)
 	return 0;
 }
 
-static struct snd_device_ops hal2_ops = {
+static const struct snd_device_ops hal2_ops = {
 	.dev_free = hal2_dev_free,
 };
 

commit 9a4df8251ac0aed09d67405c7dfa59f14bde82ed
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:30 2019 +0100

    ALSA: mips: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-9-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index e80ebe521218..db44d9d691db 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -684,7 +684,6 @@ static int hal2_capture_ack(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops hal2_playback_ops = {
 	.open =        hal2_playback_open,
 	.close =       hal2_playback_close,
-	.ioctl =       snd_pcm_lib_ioctl,
 	.prepare =     hal2_playback_prepare,
 	.trigger =     hal2_playback_trigger,
 	.pointer =     hal2_playback_pointer,
@@ -694,7 +693,6 @@ static const struct snd_pcm_ops hal2_playback_ops = {
 static const struct snd_pcm_ops hal2_capture_ops = {
 	.open =        hal2_capture_open,
 	.close =       hal2_capture_close,
-	.ioctl =       snd_pcm_lib_ioctl,
 	.prepare =     hal2_capture_prepare,
 	.trigger =     hal2_capture_trigger,
 	.pointer =     hal2_capture_pointer,

commit ee88f4ebe57523889fc437bc42f95d9ab89bdd9f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:48:49 2019 +0100

    ALSA: mips: Use managed buffer allocation
    
    Clean up the drivers with the new managed buffer allocation API.
    The hw_params and hw_free callbacks became superfluous and got
    dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-18-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index c9e060939708..e80ebe521218 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -505,23 +505,6 @@ static const struct snd_pcm_hardware hal2_pcm_hw = {
 	.periods_max =      1024,
 };
 
-static int hal2_pcm_hw_params(struct snd_pcm_substream *substream,
-			      struct snd_pcm_hw_params *params)
-{
-	int err;
-
-	err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
-	if (err < 0)
-		return err;
-
-	return 0;
-}
-
-static int hal2_pcm_hw_free(struct snd_pcm_substream *substream)
-{
-	return snd_pcm_lib_free_pages(substream);
-}
-
 static int hal2_playback_open(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -702,8 +685,6 @@ static const struct snd_pcm_ops hal2_playback_ops = {
 	.open =        hal2_playback_open,
 	.close =       hal2_playback_close,
 	.ioctl =       snd_pcm_lib_ioctl,
-	.hw_params =   hal2_pcm_hw_params,
-	.hw_free =     hal2_pcm_hw_free,
 	.prepare =     hal2_playback_prepare,
 	.trigger =     hal2_playback_trigger,
 	.pointer =     hal2_playback_pointer,
@@ -714,8 +695,6 @@ static const struct snd_pcm_ops hal2_capture_ops = {
 	.open =        hal2_capture_open,
 	.close =       hal2_capture_close,
 	.ioctl =       snd_pcm_lib_ioctl,
-	.hw_params =   hal2_pcm_hw_params,
-	.hw_free =     hal2_pcm_hw_free,
 	.prepare =     hal2_capture_prepare,
 	.trigger =     hal2_capture_trigger,
 	.pointer =     hal2_capture_pointer,
@@ -740,8 +719,8 @@ static int hal2_pcm_create(struct snd_hal2 *hal2)
 			&hal2_playback_ops);
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
 			&hal2_capture_ops);
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
-					   NULL, 0, 1024 * 1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
+				       NULL, 0, 1024 * 1024);
 
 	return 0;
 }

commit 987334266d087a4974c73f4a071bc24596f545aa
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:34 2019 +0100

    ALSA: mips: Remove superfluous snd_dma_continuous_data()
    
    The recent change (commit 08422d2c559d: "ALSA: memalloc: Allow NULL
    device for SNDRV_DMA_TYPE_CONTINUOUS type") made the PCM preallocation
    helper accepting NULL as the device pointer for the default usage.
    Drop the snd_dma_continuous_data() usage that became superfluous from
    the callers.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 6676bcbd769f..c9e060939708 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -741,8 +741,7 @@ static int hal2_pcm_create(struct snd_hal2 *hal2)
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
 			&hal2_capture_ops);
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
-					   snd_dma_continuous_data(GFP_KERNEL),
-					   0, 1024 * 1024);
+					   NULL, 0, 1024 * 1024);
 
 	return 0;
 }

commit 82c298100a2db7e4241e0fee73d94dc5ee573837
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:05 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 176
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 44 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170025.980374610@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index d63e1565b62b..6676bcbd769f 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  Driver for A2 audio system used in SGI machines
  *  Copyright (c) 2008 Thomas Bogendoerfer <tsbogend@alpha.fanken.de>
  *
  *  Based on OSS code from Ladislav Michl <ladis@linux-mips.org>, which
  *  was based on code from Ulf Carlsson
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  */
 #include <linux/kernel.h>
 #include <linux/init.h>

commit 9f7d35d9f7a184ffb591b090b2cbf63d2d599c02
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Feb 1 09:48:00 2019 +0100

    ALSA: hal2: pass struct device to DMA API functions
    
    The DMA API generally relies on a struct device to work properly, and
    only barely works without one for legacy reasons.  Pass the easily
    available struct device from the platform_device to remedy this.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index a4ed54aeaf1d..d63e1565b62b 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -454,21 +454,22 @@ static inline void hal2_stop_adc(struct snd_hal2 *hal2)
 	hal2->adc.pbus.pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;
 }
 
-static int hal2_alloc_dmabuf(struct hal2_codec *codec)
+static int hal2_alloc_dmabuf(struct snd_hal2 *hal2, struct hal2_codec *codec)
 {
+	struct device *dev = hal2->card->dev;
 	struct hal2_desc *desc;
 	dma_addr_t desc_dma, buffer_dma;
 	int count = H2_BUF_SIZE / H2_BLOCK_SIZE;
 	int i;
 
-	codec->buffer = dma_alloc_attrs(NULL, H2_BUF_SIZE, &buffer_dma,
+	codec->buffer = dma_alloc_attrs(dev, H2_BUF_SIZE, &buffer_dma,
 					GFP_KERNEL, DMA_ATTR_NON_CONSISTENT);
 	if (!codec->buffer)
 		return -ENOMEM;
-	desc = dma_alloc_attrs(NULL, count * sizeof(struct hal2_desc),
+	desc = dma_alloc_attrs(dev, count * sizeof(struct hal2_desc),
 			       &desc_dma, GFP_KERNEL, DMA_ATTR_NON_CONSISTENT);
 	if (!desc) {
-		dma_free_attrs(NULL, H2_BUF_SIZE, codec->buffer, buffer_dma,
+		dma_free_attrs(dev, H2_BUF_SIZE, codec->buffer, buffer_dma,
 			       DMA_ATTR_NON_CONSISTENT);
 		return -ENOMEM;
 	}
@@ -482,17 +483,19 @@ static int hal2_alloc_dmabuf(struct hal2_codec *codec)
 		      desc_dma : desc_dma + (i + 1) * sizeof(struct hal2_desc);
 		desc++;
 	}
-	dma_cache_sync(NULL, codec->desc, count * sizeof(struct hal2_desc),
+	dma_cache_sync(dev, codec->desc, count * sizeof(struct hal2_desc),
 		       DMA_TO_DEVICE);
 	codec->desc_count = count;
 	return 0;
 }
 
-static void hal2_free_dmabuf(struct hal2_codec *codec)
+static void hal2_free_dmabuf(struct snd_hal2 *hal2, struct hal2_codec *codec)
 {
-	dma_free_attrs(NULL, codec->desc_count * sizeof(struct hal2_desc),
+	struct device *dev = hal2->card->dev;
+
+	dma_free_attrs(dev, codec->desc_count * sizeof(struct hal2_desc),
 		       codec->desc, codec->desc_dma, DMA_ATTR_NON_CONSISTENT);
-	dma_free_attrs(NULL, H2_BUF_SIZE, codec->buffer, codec->buffer_dma,
+	dma_free_attrs(dev, H2_BUF_SIZE, codec->buffer, codec->buffer_dma,
 		       DMA_ATTR_NON_CONSISTENT);
 }
 
@@ -540,7 +543,7 @@ static int hal2_playback_open(struct snd_pcm_substream *substream)
 
 	runtime->hw = hal2_pcm_hw;
 
-	err = hal2_alloc_dmabuf(&hal2->dac);
+	err = hal2_alloc_dmabuf(hal2, &hal2->dac);
 	if (err)
 		return err;
 	return 0;
@@ -550,7 +553,7 @@ static int hal2_playback_close(struct snd_pcm_substream *substream)
 {
 	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
 
-	hal2_free_dmabuf(&hal2->dac);
+	hal2_free_dmabuf(hal2, &hal2->dac);
 	return 0;
 }
 
@@ -606,7 +609,7 @@ static void hal2_playback_transfer(struct snd_pcm_substream *substream,
 	unsigned char *buf = hal2->dac.buffer + rec->hw_data;
 
 	memcpy(buf, substream->runtime->dma_area + rec->sw_data, bytes);
-	dma_cache_sync(NULL, buf, bytes, DMA_TO_DEVICE);
+	dma_cache_sync(hal2->card->dev, buf, bytes, DMA_TO_DEVICE);
 
 }
 
@@ -629,7 +632,7 @@ static int hal2_capture_open(struct snd_pcm_substream *substream)
 
 	runtime->hw = hal2_pcm_hw;
 
-	err = hal2_alloc_dmabuf(adc);
+	err = hal2_alloc_dmabuf(hal2, adc);
 	if (err)
 		return err;
 	return 0;
@@ -639,7 +642,7 @@ static int hal2_capture_close(struct snd_pcm_substream *substream)
 {
 	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
 
-	hal2_free_dmabuf(&hal2->adc);
+	hal2_free_dmabuf(hal2, &hal2->adc);
 	return 0;
 }
 
@@ -694,7 +697,7 @@ static void hal2_capture_transfer(struct snd_pcm_substream *substream,
 	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
 	unsigned char *buf = hal2->adc.buffer + rec->hw_data;
 
-	dma_cache_sync(NULL, buf, bytes, DMA_FROM_DEVICE);
+	dma_cache_sync(hal2->card->dev, buf, bytes, DMA_FROM_DEVICE);
 	memcpy(substream->runtime->dma_area + rec->sw_data, buf, bytes);
 }
 

commit d873d5ea89e39e3224ec873a00414b6861507cac
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Sep 2 10:26:08 2018 +0200

    ALSA: mips: Cleanup indirect PCM helper usages
    
    We shouldn't set up the indirect PCM parameters at trigger but they
    should be set at prepare.  Also, remove a useless debug message, too.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 2bd1cb7489ff..a4ed54aeaf1d 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -564,6 +564,8 @@ static int hal2_playback_prepare(struct snd_pcm_substream *substream)
 	dac->sample_rate = hal2_compute_rate(dac, runtime->rate);
 	memset(&dac->pcm_indirect, 0, sizeof(dac->pcm_indirect));
 	dac->pcm_indirect.hw_buffer_size = H2_BUF_SIZE;
+	dac->pcm_indirect.hw_queue_size = H2_BUF_SIZE / 2;
+	dac->pcm_indirect.hw_io = dac->buffer_dma;
 	dac->pcm_indirect.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);
 	dac->substream = substream;
 	hal2_setup_dac(hal2);
@@ -576,8 +578,6 @@ static int hal2_playback_trigger(struct snd_pcm_substream *substream, int cmd)
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
-		hal2->dac.pcm_indirect.hw_io = hal2->dac.buffer_dma;
-		hal2->dac.pcm_indirect.hw_data = 0;
 		hal2_start_dac(hal2);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
@@ -615,7 +615,6 @@ static int hal2_playback_ack(struct snd_pcm_substream *substream)
 	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
 	struct hal2_codec *dac = &hal2->dac;
 
-	dac->pcm_indirect.hw_queue_size = H2_BUF_SIZE / 2;
 	return snd_pcm_indirect_playback_transfer(substream,
 						  &dac->pcm_indirect,
 						  hal2_playback_transfer);
@@ -655,6 +654,7 @@ static int hal2_capture_prepare(struct snd_pcm_substream *substream)
 	memset(&adc->pcm_indirect, 0, sizeof(adc->pcm_indirect));
 	adc->pcm_indirect.hw_buffer_size = H2_BUF_SIZE;
 	adc->pcm_indirect.hw_queue_size = H2_BUF_SIZE / 2;
+	adc->pcm_indirect.hw_io = adc->buffer_dma;
 	adc->pcm_indirect.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);
 	adc->substream = substream;
 	hal2_setup_adc(hal2);
@@ -667,9 +667,6 @@ static int hal2_capture_trigger(struct snd_pcm_substream *substream, int cmd)
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
-		hal2->adc.pcm_indirect.hw_io = hal2->adc.buffer_dma;
-		hal2->adc.pcm_indirect.hw_data = 0;
-		printk(KERN_DEBUG "buffer_dma %x\n", hal2->adc.buffer_dma);
 		hal2_start_adc(hal2);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:

commit dc0d1c4519095a6c6bbd9ec4a808674aba502741
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Sep 2 10:22:37 2018 +0200

    ALSA: mips: Use SNDRV_PCM_INFO_SYNC_APPLPTR info flag
    
    The recently introduced PCM info flag assures the call of ack ops at
    each applptr change, and this is mandatory for the indirect PCM
    helpers.
    
    Also, with the proper ack callback, we need no longer prefill at
    trigger start.  The relevant code can be killed.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index c8904e732aaa..2bd1cb7489ff 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -500,7 +500,8 @@ static const struct snd_pcm_hardware hal2_pcm_hw = {
 	.info = (SNDRV_PCM_INFO_MMAP |
 		 SNDRV_PCM_INFO_MMAP_VALID |
 		 SNDRV_PCM_INFO_INTERLEAVED |
-		 SNDRV_PCM_INFO_BLOCK_TRANSFER),
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		 SNDRV_PCM_INFO_SYNC_APPLPTR),
 	.formats =          SNDRV_PCM_FMTBIT_S16_BE,
 	.rates =            SNDRV_PCM_RATE_8000_48000,
 	.rate_min =         8000,
@@ -577,7 +578,6 @@ static int hal2_playback_trigger(struct snd_pcm_substream *substream, int cmd)
 	case SNDRV_PCM_TRIGGER_START:
 		hal2->dac.pcm_indirect.hw_io = hal2->dac.buffer_dma;
 		hal2->dac.pcm_indirect.hw_data = 0;
-		substream->ops->ack(substream);
 		hal2_start_dac(hal2);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:

commit 044ace5e3fc95f8df1197b7eaeadee0b35dfcef5
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Nov 11 18:34:04 2017 +0100

    ALSA: hal2: Improve a size determination in hal2_create()
    
    Replace the specification of a data structure by a pointer dereference
    as the parameter for the operator "sizeof" to make the corresponding size
    determination a bit safer according to the Linux coding style convention.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 37d378a26a50..c8904e732aaa 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -814,7 +814,7 @@ static int hal2_create(struct snd_card *card, struct snd_hal2 **rchip)
 	struct hpc3_regs *hpc3 = hpc3c0;
 	int err;
 
-	hal2 = kzalloc(sizeof(struct snd_hal2), GFP_KERNEL);
+	hal2 = kzalloc(sizeof(*hal2), GFP_KERNEL);
 	if (!hal2)
 		return -ENOMEM;
 

commit 915a38d324d23f4fa53306a3a834f54a9f6da17c
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Aug 18 13:15:14 2017 +0530

    ALSA: mips: constify snd_pcm_ops structures
    
    snd_pcm_ops are not supposed to change at runtime. All functions
    working with snd_pcm_ops provided by <sound/pcm.h> work with
    const snd_pcm_ops. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 367d6c37b47e..37d378a26a50 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -711,7 +711,7 @@ static int hal2_capture_ack(struct snd_pcm_substream *substream)
 						 hal2_capture_transfer);
 }
 
-static struct snd_pcm_ops hal2_playback_ops = {
+static const struct snd_pcm_ops hal2_playback_ops = {
 	.open =        hal2_playback_open,
 	.close =       hal2_playback_close,
 	.ioctl =       snd_pcm_lib_ioctl,
@@ -723,7 +723,7 @@ static struct snd_pcm_ops hal2_playback_ops = {
 	.ack =         hal2_playback_ack,
 };
 
-static struct snd_pcm_ops hal2_capture_ops = {
+static const struct snd_pcm_ops hal2_capture_ops = {
 	.open =        hal2_capture_open,
 	.close =       hal2_capture_close,
 	.ioctl =       snd_pcm_lib_ioctl,

commit 3068116f532639cc0420b30ac574af470c051e85
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Thu Aug 17 14:45:53 2017 +0530

    ALSA: mips: make snd_pcm_hardware const
    
    Make these const as they are only used in a copy operation.
    Done using Coccinelle
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 3318c15e324a..367d6c37b47e 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -496,7 +496,7 @@ static void hal2_free_dmabuf(struct hal2_codec *codec)
 		       DMA_ATTR_NON_CONSISTENT);
 }
 
-static struct snd_pcm_hardware hal2_pcm_hw = {
+static const struct snd_pcm_hardware hal2_pcm_hw = {
 	.info = (SNDRV_PCM_INFO_MMAP |
 		 SNDRV_PCM_INFO_MMAP_VALID |
 		 SNDRV_PCM_INFO_INTERLEAVED |

commit 15b5ef42904bdaf20f0145c3693a7d2f3c10ab44
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jun 16 09:17:09 2017 +0200

    ALSA: hal2: switch to dma_alloc_attrs
    
    Use dma_alloc_attrs directly instead of the dma_alloc_noncoherent wrapper.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 6505deb8c06b..3318c15e324a 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -461,15 +461,15 @@ static int hal2_alloc_dmabuf(struct hal2_codec *codec)
 	int count = H2_BUF_SIZE / H2_BLOCK_SIZE;
 	int i;
 
-	codec->buffer = dma_alloc_noncoherent(NULL, H2_BUF_SIZE,
-					      &buffer_dma, GFP_KERNEL);
+	codec->buffer = dma_alloc_attrs(NULL, H2_BUF_SIZE, &buffer_dma,
+					GFP_KERNEL, DMA_ATTR_NON_CONSISTENT);
 	if (!codec->buffer)
 		return -ENOMEM;
-	desc = dma_alloc_noncoherent(NULL, count * sizeof(struct hal2_desc),
-				     &desc_dma, GFP_KERNEL);
+	desc = dma_alloc_attrs(NULL, count * sizeof(struct hal2_desc),
+			       &desc_dma, GFP_KERNEL, DMA_ATTR_NON_CONSISTENT);
 	if (!desc) {
-		dma_free_noncoherent(NULL, H2_BUF_SIZE,
-				     codec->buffer, buffer_dma);
+		dma_free_attrs(NULL, H2_BUF_SIZE, codec->buffer, buffer_dma,
+			       DMA_ATTR_NON_CONSISTENT);
 		return -ENOMEM;
 	}
 	codec->buffer_dma = buffer_dma;
@@ -490,10 +490,10 @@ static int hal2_alloc_dmabuf(struct hal2_codec *codec)
 
 static void hal2_free_dmabuf(struct hal2_codec *codec)
 {
-	dma_free_noncoherent(NULL, codec->desc_count * sizeof(struct hal2_desc),
-			     codec->desc, codec->desc_dma);
-	dma_free_noncoherent(NULL, H2_BUF_SIZE, codec->buffer,
-			     codec->buffer_dma);
+	dma_free_attrs(NULL, codec->desc_count * sizeof(struct hal2_desc),
+		       codec->desc, codec->desc_dma, DMA_ATTR_NON_CONSISTENT);
+	dma_free_attrs(NULL, H2_BUF_SIZE, codec->buffer, codec->buffer_dma,
+		       DMA_ATTR_NON_CONSISTENT);
 }
 
 static struct snd_pcm_hardware hal2_pcm_hw = {

commit 905e46acd3272d04566fec49afbd7ad9e2ed9ae3
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat May 27 20:16:15 2017 +0530

    ALSA: declare snd_kcontrol_new structures as const
    
    Declare snd_kcontrol_new structures as const as they are only passed an
    argument to the function snd_ctl_new1. This argument is of type const,
    so snd_kcontrol_new structures having this property can be made const.
    Done using Coccinelle:
    
    @r disable optional_qualifier@
    identifier x;
    position p;
    @@
    static struct snd_kcontrol_new x@p={...};
    
    @ok@
    identifier r.x;
    position p;
    @@
    snd_ctl_new1(&x@p,...)
    
    @bad@
    position p != {r.p,ok.p};
    identifier r.x;
    @@
    x@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.x;
    @@
    +const
    struct snd_kcontrol_new x;
    
    Cross compiled these files:
    sound/aoa/codecs/tas.c - powerpc
    sound/mips/{hal2.c/sgio2audio.c} - mips
    sound/ppc/{awacs.c/beep.c/tumbler.c} - powerpc
    sound/soc/sh/siu_dai.c - sh
    Could not find an architecture to compile sound/sh/aica.c.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 684dc4ddef41..6505deb8c06b 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -264,7 +264,7 @@ static int hal2_gain_put(struct snd_kcontrol *kcontrol,
 	return old != new;
 }
 
-static struct snd_kcontrol_new hal2_ctrl_headphone = {
+static const struct snd_kcontrol_new hal2_ctrl_headphone = {
 	.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name           = "Headphone Playback Volume",
 	.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,
@@ -274,7 +274,7 @@ static struct snd_kcontrol_new hal2_ctrl_headphone = {
 	.put            = hal2_gain_put,
 };
 
-static struct snd_kcontrol_new hal2_ctrl_mic = {
+static const struct snd_kcontrol_new hal2_ctrl_mic = {
 	.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name           = "Mic Capture Volume",
 	.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,

commit 0f21e57decaa2c49ace8436781cd4672d3637ddc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 19 18:41:45 2017 +0200

    ALSA: mips: Deliver indirect-PCM transfer error
    
    Now that the indirect-PCM transfer helper gives back an error, we
    should return the error from ack callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 00fc9241d266..684dc4ddef41 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -616,10 +616,9 @@ static int hal2_playback_ack(struct snd_pcm_substream *substream)
 	struct hal2_codec *dac = &hal2->dac;
 
 	dac->pcm_indirect.hw_queue_size = H2_BUF_SIZE / 2;
-	snd_pcm_indirect_playback_transfer(substream,
-					   &dac->pcm_indirect,
-					   hal2_playback_transfer);
-	return 0;
+	return snd_pcm_indirect_playback_transfer(substream,
+						  &dac->pcm_indirect,
+						  hal2_playback_transfer);
 }
 
 static int hal2_capture_open(struct snd_pcm_substream *substream)
@@ -707,10 +706,9 @@ static int hal2_capture_ack(struct snd_pcm_substream *substream)
 	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
 	struct hal2_codec *adc = &hal2->adc;
 
-	snd_pcm_indirect_capture_transfer(substream,
-					  &adc->pcm_indirect,
-					  hal2_capture_transfer);
-	return 0;
+	return snd_pcm_indirect_capture_transfer(substream,
+						 &adc->pcm_indirect,
+						 hal2_capture_transfer);
 }
 
 static struct snd_pcm_ops hal2_playback_ops = {

commit 8b169cb27c8267cd344fd71c2067ea864dd4c2e7
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jan 16 14:27:57 2017 +0100

    ALSA: mips: avoid potential uninitialized variable use
    
    MIPS allmodconfig results in this warning:
    
    sound/mips/hal2.c: In function 'hal2_gain_get':
    sound/mips/hal2.c:224:35: error: 'r' may be used uninitialized in this function [-Werror=maybe-uninitialized]
    sound/mips/hal2.c:223:35: error: 'l' may be used uninitialized in this function [-Werror=maybe-uninitialized]
    sound/mips/hal2.c: In function 'hal2_gain_put':
    sound/mips/hal2.c:260:13: error: 'new' may be used uninitialized in this function [-Werror=maybe-uninitialized]
    sound/mips/hal2.c:260:13: error: 'old' may be used uninitialized in this function [-Werror=maybe-uninitialized]
    
    Returning an error for all unexpected cases shuts up the warning
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index ede449f0b50d..00fc9241d266 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -219,6 +219,8 @@ static int hal2_gain_get(struct snd_kcontrol *kcontrol,
 		l = (tmp >> H2I_C2_L_GAIN_SHIFT) & 15;
 		r = (tmp >> H2I_C2_R_GAIN_SHIFT) & 15;
 		break;
+	default:
+		return -EINVAL;
 	}
 	ucontrol->value.integer.value[0] = l;
 	ucontrol->value.integer.value[1] = r;
@@ -256,6 +258,8 @@ static int hal2_gain_put(struct snd_kcontrol *kcontrol,
 		new |= (r << H2I_C2_R_GAIN_SHIFT);
 		hal2_i_write32(hal2, H2I_ADC_C2, new);
 		break;
+	default:
+		return -EINVAL;
 	}
 	return old != new;
 }

commit 0d3d8be84aa6d2da80257a847c0db4520654cfb3
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:22:01 2014 +0200

    ALSA: mips: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 23441b9e6148..ede449f0b50d 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -929,7 +929,6 @@ static struct platform_driver hal2_driver = {
 	.remove	= hal2_remove,
 	.driver = {
 		.name	= "sgihal2",
-		.owner	= THIS_MODULE,
 	}
 };
 

commit bee1bb19cf97413494a5254de63d43d52d93d4f8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:34:47 2014 +0100

    ALSA: mips: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 2b7f6e8bdd24..23441b9e6148 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -880,7 +880,7 @@ static int hal2_probe(struct platform_device *pdev)
 	struct snd_hal2 *chip;
 	int err;
 
-	err = snd_card_create(index, id, THIS_MODULE, 0, &card);
+	err = snd_card_new(&pdev->dev, index, id, THIS_MODULE, 0, &card);
 	if (err < 0)
 		return err;
 
@@ -889,7 +889,6 @@ static int hal2_probe(struct platform_device *pdev)
 		snd_card_free(card);
 		return err;
 	}
-	snd_card_set_dev(card, &pdev->dev);
 
 	err = hal2_pcm_create(chip);
 	if (err < 0) {

commit 318352061618504dbbe93c1817fe3be4b53ce08a
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon May 6 10:16:15 2013 +0530

    ALSA: mips/hal2: Remove redundant platform_set_drvdata()
    
    Commit 0998d06310 (device-core: Ensure drvdata = NULL when no
    driver is bound) removes the need to set driver data field to
    NULL.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.fanken.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 7420c59444ab..2b7f6e8bdd24 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -922,7 +922,6 @@ static int hal2_remove(struct platform_device *pdev)
 	struct snd_card *card = platform_get_drvdata(pdev);
 
 	snd_card_free(card);
-	platform_set_drvdata(pdev, NULL);
 	return 0;
 }
 

commit e0f8cb5fac7f6ab0353caccab54e960bbe517123
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:15 2012 -0500

    ALSA: mips: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 5f88d1f09ffe..7420c59444ab 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -260,7 +260,7 @@ static int hal2_gain_put(struct snd_kcontrol *kcontrol,
 	return old != new;
 }
 
-static struct snd_kcontrol_new hal2_ctrl_headphone __devinitdata = {
+static struct snd_kcontrol_new hal2_ctrl_headphone = {
 	.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name           = "Headphone Playback Volume",
 	.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,
@@ -270,7 +270,7 @@ static struct snd_kcontrol_new hal2_ctrl_headphone __devinitdata = {
 	.put            = hal2_gain_put,
 };
 
-static struct snd_kcontrol_new hal2_ctrl_mic __devinitdata = {
+static struct snd_kcontrol_new hal2_ctrl_mic = {
 	.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name           = "Mic Capture Volume",
 	.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,
@@ -280,7 +280,7 @@ static struct snd_kcontrol_new hal2_ctrl_mic __devinitdata = {
 	.put            = hal2_gain_put,
 };
 
-static int __devinit hal2_mixer_create(struct snd_hal2 *hal2)
+static int hal2_mixer_create(struct snd_hal2 *hal2)
 {
 	int err;
 
@@ -733,7 +733,7 @@ static struct snd_pcm_ops hal2_capture_ops = {
 	.ack =         hal2_capture_ack,
 };
 
-static int __devinit hal2_pcm_create(struct snd_hal2 *hal2)
+static int hal2_pcm_create(struct snd_hal2 *hal2)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -874,7 +874,7 @@ static int hal2_create(struct snd_card *card, struct snd_hal2 **rchip)
 	return 0;
 }
 
-static int __devinit hal2_probe(struct platform_device *pdev)
+static int hal2_probe(struct platform_device *pdev)
 {
 	struct snd_card *card;
 	struct snd_hal2 *chip;
@@ -917,7 +917,7 @@ static int __devinit hal2_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int __devexit hal2_remove(struct platform_device *pdev)
+static int hal2_remove(struct platform_device *pdev)
 {
 	struct snd_card *card = platform_get_drvdata(pdev);
 
@@ -928,7 +928,7 @@ static int __devexit hal2_remove(struct platform_device *pdev)
 
 static struct platform_driver hal2_driver = {
 	.probe	= hal2_probe,
-	.remove	= __devexit_p(hal2_remove),
+	.remove	= hal2_remove,
 	.driver = {
 		.name	= "sgihal2",
 		.owner	= THIS_MODULE,

commit 51451b8d607374297055c4e08034b39f4be22d33
Author: Axel Lin <axel.lin@gmail.com>
Date:   Thu Nov 24 18:47:25 2011 +0800

    ALSA: Convert mips directory to module_platform_driver
    
    Factor out some boilerplate code.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 2e6c85894e0b..5f88d1f09ffe 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -935,15 +935,4 @@ static struct platform_driver hal2_driver = {
 	}
 };
 
-static int __init alsa_card_hal2_init(void)
-{
-	return platform_driver_register(&hal2_driver);
-}
-
-static void __exit alsa_card_hal2_exit(void)
-{
-	platform_driver_unregister(&hal2_driver);
-}
-
-module_init(alsa_card_hal2_init);
-module_exit(alsa_card_hal2_exit);
+module_platform_driver(hal2_driver);

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 453d343550a8..2e6c85894e0b 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -26,6 +26,7 @@
 #include <linux/platform_device.h>
 #include <linux/io.h>
 #include <linux/slab.h>
+#include <linux/module.h>
 
 #include <asm/sgi/hpc3.h>
 #include <asm/sgi/ip22.h>

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index 9a88cdfd952a..453d343550a8 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -25,6 +25,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
+#include <linux/slab.h>
 
 #include <asm/sgi/hpc3.h>
 #include <asm/sgi/ip22.h>

commit 2f229a31aac86ea6911d70ec4c79196ca711d625
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Oct 2 11:04:54 2009 +0200

    ALSA: Fix invalid __exit in sound/mips/*.c
    
    The remove callback has to be marked as __devexit, as the dynamic unbind
    is possible.
    
    Reported-by: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index c52691c2fc46..9a88cdfd952a 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -915,7 +915,7 @@ static int __devinit hal2_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int __exit hal2_remove(struct platform_device *pdev)
+static int __devexit hal2_remove(struct platform_device *pdev)
 {
 	struct snd_card *card = platform_get_drvdata(pdev);
 

commit bd7dd77c2a05c530684eea2e3af16449ae9c5d52
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:45:02 2008 +0100

    ALSA: Convert to snd_card_create() in other sound/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in other sound subdirectories.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
index db495be01861..c52691c2fc46 100644
--- a/sound/mips/hal2.c
+++ b/sound/mips/hal2.c
@@ -878,9 +878,9 @@ static int __devinit hal2_probe(struct platform_device *pdev)
 	struct snd_hal2 *chip;
 	int err;
 
-	card = snd_card_new(index, id, THIS_MODULE, 0);
-	if (card == NULL)
-		return -ENOMEM;
+	err = snd_card_create(index, id, THIS_MODULE, 0, &card);
+	if (err < 0)
+		return err;
 
 	err = hal2_create(card, &chip);
 	if (err < 0) {

commit 787dba37a6ff5c80c67f37c081712a6e4af92e25
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Sat Jul 12 12:12:20 2008 +0200

    ALSA: ALSA driver for SGI HAL2 audio device
    
    This patch adds a new ALSA driver for the audio device found inside
    many older SGI workstation (Indy, Indigo2). The hardware uses a SGI
    custom chip, which feeds two codec chips, an IEC chip and a synth chip.
    Currently only one of the codecs is supported. This driver already has
    the same functionality as the HAL2 OSS driver and will replace it.
    
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/mips/hal2.c b/sound/mips/hal2.c
new file mode 100644
index 000000000000..db495be01861
--- /dev/null
+++ b/sound/mips/hal2.c
@@ -0,0 +1,947 @@
+/*
+ *  Driver for A2 audio system used in SGI machines
+ *  Copyright (c) 2008 Thomas Bogendoerfer <tsbogend@alpha.fanken.de>
+ *
+ *  Based on OSS code from Ladislav Michl <ladis@linux-mips.org>, which
+ *  was based on code from Ulf Carlsson
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+#include <asm/sgi/hpc3.h>
+#include <asm/sgi/ip22.h>
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/pcm-indirect.h>
+#include <sound/initval.h>
+
+#include "hal2.h"
+
+static int index = SNDRV_DEFAULT_IDX1;  /* Index 0-MAX */
+static char *id = SNDRV_DEFAULT_STR1;   /* ID for this card */
+
+module_param(index, int, 0444);
+MODULE_PARM_DESC(index, "Index value for SGI HAL2 soundcard.");
+module_param(id, charp, 0444);
+MODULE_PARM_DESC(id, "ID string for SGI HAL2 soundcard.");
+MODULE_DESCRIPTION("ALSA driver for SGI HAL2 audio");
+MODULE_AUTHOR("Thomas Bogendoerfer");
+MODULE_LICENSE("GPL");
+
+
+#define H2_BLOCK_SIZE	1024
+#define H2_BUF_SIZE	16384
+
+struct hal2_pbus {
+	struct hpc3_pbus_dmacregs *pbus;
+	int pbusnr;
+	unsigned int ctrl;		/* Current state of pbus->pbdma_ctrl */
+};
+
+struct hal2_desc {
+	struct hpc_dma_desc desc;
+	u32 pad;			/* padding */
+};
+
+struct hal2_codec {
+	struct snd_pcm_indirect pcm_indirect;
+	struct snd_pcm_substream *substream;
+
+	unsigned char *buffer;
+	dma_addr_t buffer_dma;
+	struct hal2_desc *desc;
+	dma_addr_t desc_dma;
+	int desc_count;
+	struct hal2_pbus pbus;
+	int voices;			/* mono/stereo */
+	unsigned int sample_rate;
+	unsigned int master;		/* Master frequency */
+	unsigned short mod;		/* MOD value */
+	unsigned short inc;		/* INC value */
+};
+
+#define H2_MIX_OUTPUT_ATT	0
+#define H2_MIX_INPUT_GAIN	1
+
+struct snd_hal2 {
+	struct snd_card *card;
+
+	struct hal2_ctl_regs *ctl_regs;	/* HAL2 ctl registers */
+	struct hal2_aes_regs *aes_regs;	/* HAL2 aes registers */
+	struct hal2_vol_regs *vol_regs;	/* HAL2 vol registers */
+	struct hal2_syn_regs *syn_regs;	/* HAL2 syn registers */
+
+	struct hal2_codec dac;
+	struct hal2_codec adc;
+};
+
+#define H2_INDIRECT_WAIT(regs)	while (hal2_read(&regs->isr) & H2_ISR_TSTATUS);
+
+#define H2_READ_ADDR(addr)	(addr | (1<<7))
+#define H2_WRITE_ADDR(addr)	(addr)
+
+static inline u32 hal2_read(u32 *reg)
+{
+	return __raw_readl(reg);
+}
+
+static inline void hal2_write(u32 val, u32 *reg)
+{
+	__raw_writel(val, reg);
+}
+
+
+static u32 hal2_i_read32(struct snd_hal2 *hal2, u16 addr)
+{
+	u32 ret;
+	struct hal2_ctl_regs *regs = hal2->ctl_regs;
+
+	hal2_write(H2_READ_ADDR(addr), &regs->iar);
+	H2_INDIRECT_WAIT(regs);
+	ret = hal2_read(&regs->idr0) & 0xffff;
+	hal2_write(H2_READ_ADDR(addr) | 0x1, &regs->iar);
+	H2_INDIRECT_WAIT(regs);
+	ret |= (hal2_read(&regs->idr0) & 0xffff) << 16;
+	return ret;
+}
+
+static void hal2_i_write16(struct snd_hal2 *hal2, u16 addr, u16 val)
+{
+	struct hal2_ctl_regs *regs = hal2->ctl_regs;
+
+	hal2_write(val, &regs->idr0);
+	hal2_write(0, &regs->idr1);
+	hal2_write(0, &regs->idr2);
+	hal2_write(0, &regs->idr3);
+	hal2_write(H2_WRITE_ADDR(addr), &regs->iar);
+	H2_INDIRECT_WAIT(regs);
+}
+
+static void hal2_i_write32(struct snd_hal2 *hal2, u16 addr, u32 val)
+{
+	struct hal2_ctl_regs *regs = hal2->ctl_regs;
+
+	hal2_write(val & 0xffff, &regs->idr0);
+	hal2_write(val >> 16, &regs->idr1);
+	hal2_write(0, &regs->idr2);
+	hal2_write(0, &regs->idr3);
+	hal2_write(H2_WRITE_ADDR(addr), &regs->iar);
+	H2_INDIRECT_WAIT(regs);
+}
+
+static void hal2_i_setbit16(struct snd_hal2 *hal2, u16 addr, u16 bit)
+{
+	struct hal2_ctl_regs *regs = hal2->ctl_regs;
+
+	hal2_write(H2_READ_ADDR(addr), &regs->iar);
+	H2_INDIRECT_WAIT(regs);
+	hal2_write((hal2_read(&regs->idr0) & 0xffff) | bit, &regs->idr0);
+	hal2_write(0, &regs->idr1);
+	hal2_write(0, &regs->idr2);
+	hal2_write(0, &regs->idr3);
+	hal2_write(H2_WRITE_ADDR(addr), &regs->iar);
+	H2_INDIRECT_WAIT(regs);
+}
+
+static void hal2_i_clearbit16(struct snd_hal2 *hal2, u16 addr, u16 bit)
+{
+	struct hal2_ctl_regs *regs = hal2->ctl_regs;
+
+	hal2_write(H2_READ_ADDR(addr), &regs->iar);
+	H2_INDIRECT_WAIT(regs);
+	hal2_write((hal2_read(&regs->idr0) & 0xffff) & ~bit, &regs->idr0);
+	hal2_write(0, &regs->idr1);
+	hal2_write(0, &regs->idr2);
+	hal2_write(0, &regs->idr3);
+	hal2_write(H2_WRITE_ADDR(addr), &regs->iar);
+	H2_INDIRECT_WAIT(regs);
+}
+
+static int hal2_gain_info(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	switch ((int)kcontrol->private_value) {
+	case H2_MIX_OUTPUT_ATT:
+		uinfo->value.integer.max = 31;
+		break;
+	case H2_MIX_INPUT_GAIN:
+		uinfo->value.integer.max = 15;
+		break;
+	}
+	return 0;
+}
+
+static int hal2_gain_get(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_hal2 *hal2 = snd_kcontrol_chip(kcontrol);
+	u32 tmp;
+	int l, r;
+
+	switch ((int)kcontrol->private_value) {
+	case H2_MIX_OUTPUT_ATT:
+		tmp = hal2_i_read32(hal2, H2I_DAC_C2);
+		if (tmp & H2I_C2_MUTE) {
+			l = 0;
+			r = 0;
+		} else {
+			l = 31 - ((tmp >> H2I_C2_L_ATT_SHIFT) & 31);
+			r = 31 - ((tmp >> H2I_C2_R_ATT_SHIFT) & 31);
+		}
+		break;
+	case H2_MIX_INPUT_GAIN:
+		tmp = hal2_i_read32(hal2, H2I_ADC_C2);
+		l = (tmp >> H2I_C2_L_GAIN_SHIFT) & 15;
+		r = (tmp >> H2I_C2_R_GAIN_SHIFT) & 15;
+		break;
+	}
+	ucontrol->value.integer.value[0] = l;
+	ucontrol->value.integer.value[1] = r;
+
+	return 0;
+}
+
+static int hal2_gain_put(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_hal2 *hal2 = snd_kcontrol_chip(kcontrol);
+	u32 old, new;
+	int l, r;
+
+	l = ucontrol->value.integer.value[0];
+	r = ucontrol->value.integer.value[1];
+
+	switch ((int)kcontrol->private_value) {
+	case H2_MIX_OUTPUT_ATT:
+		old = hal2_i_read32(hal2, H2I_DAC_C2);
+		new = old & ~(H2I_C2_L_ATT_M | H2I_C2_R_ATT_M | H2I_C2_MUTE);
+		if (l | r) {
+			l = 31 - l;
+			r = 31 - r;
+			new |= (l << H2I_C2_L_ATT_SHIFT);
+			new |= (r << H2I_C2_R_ATT_SHIFT);
+		} else
+			new |= H2I_C2_L_ATT_M | H2I_C2_R_ATT_M | H2I_C2_MUTE;
+		hal2_i_write32(hal2, H2I_DAC_C2, new);
+		break;
+	case H2_MIX_INPUT_GAIN:
+		old = hal2_i_read32(hal2, H2I_ADC_C2);
+		new = old & ~(H2I_C2_L_GAIN_M | H2I_C2_R_GAIN_M);
+		new |= (l << H2I_C2_L_GAIN_SHIFT);
+		new |= (r << H2I_C2_R_GAIN_SHIFT);
+		hal2_i_write32(hal2, H2I_ADC_C2, new);
+		break;
+	}
+	return old != new;
+}
+
+static struct snd_kcontrol_new hal2_ctrl_headphone __devinitdata = {
+	.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name           = "Headphone Playback Volume",
+	.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.private_value  = H2_MIX_OUTPUT_ATT,
+	.info           = hal2_gain_info,
+	.get            = hal2_gain_get,
+	.put            = hal2_gain_put,
+};
+
+static struct snd_kcontrol_new hal2_ctrl_mic __devinitdata = {
+	.iface          = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name           = "Mic Capture Volume",
+	.access         = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.private_value  = H2_MIX_INPUT_GAIN,
+	.info           = hal2_gain_info,
+	.get            = hal2_gain_get,
+	.put            = hal2_gain_put,
+};
+
+static int __devinit hal2_mixer_create(struct snd_hal2 *hal2)
+{
+	int err;
+
+	/* mute DAC */
+	hal2_i_write32(hal2, H2I_DAC_C2,
+		       H2I_C2_L_ATT_M | H2I_C2_R_ATT_M | H2I_C2_MUTE);
+	/* mute ADC */
+	hal2_i_write32(hal2, H2I_ADC_C2, 0);
+
+	err = snd_ctl_add(hal2->card,
+			  snd_ctl_new1(&hal2_ctrl_headphone, hal2));
+	if (err < 0)
+		return err;
+
+	err = snd_ctl_add(hal2->card,
+			  snd_ctl_new1(&hal2_ctrl_mic, hal2));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static irqreturn_t hal2_interrupt(int irq, void *dev_id)
+{
+	struct snd_hal2 *hal2 = dev_id;
+	irqreturn_t ret = IRQ_NONE;
+
+	/* decide what caused this interrupt */
+	if (hal2->dac.pbus.pbus->pbdma_ctrl & HPC3_PDMACTRL_INT) {
+		snd_pcm_period_elapsed(hal2->dac.substream);
+		ret = IRQ_HANDLED;
+	}
+	if (hal2->adc.pbus.pbus->pbdma_ctrl & HPC3_PDMACTRL_INT) {
+		snd_pcm_period_elapsed(hal2->adc.substream);
+		ret = IRQ_HANDLED;
+	}
+	return ret;
+}
+
+static int hal2_compute_rate(struct hal2_codec *codec, unsigned int rate)
+{
+	unsigned short mod;
+
+	if (44100 % rate < 48000 % rate) {
+		mod = 4 * 44100 / rate;
+		codec->master = 44100;
+	} else {
+		mod = 4 * 48000 / rate;
+		codec->master = 48000;
+	}
+
+	codec->inc = 4;
+	codec->mod = mod;
+	rate = 4 * codec->master / mod;
+
+	return rate;
+}
+
+static void hal2_set_dac_rate(struct snd_hal2 *hal2)
+{
+	unsigned int master = hal2->dac.master;
+	int inc = hal2->dac.inc;
+	int mod = hal2->dac.mod;
+
+	hal2_i_write16(hal2, H2I_BRES1_C1, (master == 44100) ? 1 : 0);
+	hal2_i_write32(hal2, H2I_BRES1_C2,
+		       ((0xffff & (inc - mod - 1)) << 16) | inc);
+}
+
+static void hal2_set_adc_rate(struct snd_hal2 *hal2)
+{
+	unsigned int master = hal2->adc.master;
+	int inc = hal2->adc.inc;
+	int mod = hal2->adc.mod;
+
+	hal2_i_write16(hal2, H2I_BRES2_C1, (master == 44100) ? 1 : 0);
+	hal2_i_write32(hal2, H2I_BRES2_C2,
+		       ((0xffff & (inc - mod - 1)) << 16) | inc);
+}
+
+static void hal2_setup_dac(struct snd_hal2 *hal2)
+{
+	unsigned int fifobeg, fifoend, highwater, sample_size;
+	struct hal2_pbus *pbus = &hal2->dac.pbus;
+
+	/* Now we set up some PBUS information. The PBUS needs information about
+	 * what portion of the fifo it will use. If it's receiving or
+	 * transmitting, and finally whether the stream is little endian or big
+	 * endian. The information is written later, on the start call.
+	 */
+	sample_size = 2 * hal2->dac.voices;
+	/* Fifo should be set to hold exactly four samples. Highwater mark
+	 * should be set to two samples. */
+	highwater = (sample_size * 2) >> 1;	/* halfwords */
+	fifobeg = 0;				/* playback is first */
+	fifoend = (sample_size * 4) >> 3;	/* doublewords */
+	pbus->ctrl = HPC3_PDMACTRL_RT | HPC3_PDMACTRL_LD |
+		     (highwater << 8) | (fifobeg << 16) | (fifoend << 24);
+	/* We disable everything before we do anything at all */
+	pbus->pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;
+	hal2_i_clearbit16(hal2, H2I_DMA_PORT_EN, H2I_DMA_PORT_EN_CODECTX);
+	/* Setup the HAL2 for playback */
+	hal2_set_dac_rate(hal2);
+	/* Set endianess */
+	hal2_i_clearbit16(hal2, H2I_DMA_END, H2I_DMA_END_CODECTX);
+	/* Set DMA bus */
+	hal2_i_setbit16(hal2, H2I_DMA_DRV, (1 << pbus->pbusnr));
+	/* We are using 1st Bresenham clock generator for playback */
+	hal2_i_write16(hal2, H2I_DAC_C1, (pbus->pbusnr << H2I_C1_DMA_SHIFT)
+			| (1 << H2I_C1_CLKID_SHIFT)
+			| (hal2->dac.voices << H2I_C1_DATAT_SHIFT));
+}
+
+static void hal2_setup_adc(struct snd_hal2 *hal2)
+{
+	unsigned int fifobeg, fifoend, highwater, sample_size;
+	struct hal2_pbus *pbus = &hal2->adc.pbus;
+
+	sample_size = 2 * hal2->adc.voices;
+	highwater = (sample_size * 2) >> 1;		/* halfwords */
+	fifobeg = (4 * 4) >> 3;				/* record is second */
+	fifoend = (4 * 4 + sample_size * 4) >> 3;	/* doublewords */
+	pbus->ctrl = HPC3_PDMACTRL_RT | HPC3_PDMACTRL_RCV | HPC3_PDMACTRL_LD |
+		     (highwater << 8) | (fifobeg << 16) | (fifoend << 24);
+	pbus->pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;
+	hal2_i_clearbit16(hal2, H2I_DMA_PORT_EN, H2I_DMA_PORT_EN_CODECR);
+	/* Setup the HAL2 for record */
+	hal2_set_adc_rate(hal2);
+	/* Set endianess */
+	hal2_i_clearbit16(hal2, H2I_DMA_END, H2I_DMA_END_CODECR);
+	/* Set DMA bus */
+	hal2_i_setbit16(hal2, H2I_DMA_DRV, (1 << pbus->pbusnr));
+	/* We are using 2nd Bresenham clock generator for record */
+	hal2_i_write16(hal2, H2I_ADC_C1, (pbus->pbusnr << H2I_C1_DMA_SHIFT)
+			| (2 << H2I_C1_CLKID_SHIFT)
+			| (hal2->adc.voices << H2I_C1_DATAT_SHIFT));
+}
+
+static void hal2_start_dac(struct snd_hal2 *hal2)
+{
+	struct hal2_pbus *pbus = &hal2->dac.pbus;
+
+	pbus->pbus->pbdma_dptr = hal2->dac.desc_dma;
+	pbus->pbus->pbdma_ctrl = pbus->ctrl | HPC3_PDMACTRL_ACT;
+	/* enable DAC */
+	hal2_i_setbit16(hal2, H2I_DMA_PORT_EN, H2I_DMA_PORT_EN_CODECTX);
+}
+
+static void hal2_start_adc(struct snd_hal2 *hal2)
+{
+	struct hal2_pbus *pbus = &hal2->adc.pbus;
+
+	pbus->pbus->pbdma_dptr = hal2->adc.desc_dma;
+	pbus->pbus->pbdma_ctrl = pbus->ctrl | HPC3_PDMACTRL_ACT;
+	/* enable ADC */
+	hal2_i_setbit16(hal2, H2I_DMA_PORT_EN, H2I_DMA_PORT_EN_CODECR);
+}
+
+static inline void hal2_stop_dac(struct snd_hal2 *hal2)
+{
+	hal2->dac.pbus.pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;
+	/* The HAL2 itself may remain enabled safely */
+}
+
+static inline void hal2_stop_adc(struct snd_hal2 *hal2)
+{
+	hal2->adc.pbus.pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;
+}
+
+static int hal2_alloc_dmabuf(struct hal2_codec *codec)
+{
+	struct hal2_desc *desc;
+	dma_addr_t desc_dma, buffer_dma;
+	int count = H2_BUF_SIZE / H2_BLOCK_SIZE;
+	int i;
+
+	codec->buffer = dma_alloc_noncoherent(NULL, H2_BUF_SIZE,
+					      &buffer_dma, GFP_KERNEL);
+	if (!codec->buffer)
+		return -ENOMEM;
+	desc = dma_alloc_noncoherent(NULL, count * sizeof(struct hal2_desc),
+				     &desc_dma, GFP_KERNEL);
+	if (!desc) {
+		dma_free_noncoherent(NULL, H2_BUF_SIZE,
+				     codec->buffer, buffer_dma);
+		return -ENOMEM;
+	}
+	codec->buffer_dma = buffer_dma;
+	codec->desc_dma = desc_dma;
+	codec->desc = desc;
+	for (i = 0; i < count; i++) {
+		desc->desc.pbuf = buffer_dma + i * H2_BLOCK_SIZE;
+		desc->desc.cntinfo = HPCDMA_XIE | H2_BLOCK_SIZE;
+		desc->desc.pnext = (i == count - 1) ?
+		      desc_dma : desc_dma + (i + 1) * sizeof(struct hal2_desc);
+		desc++;
+	}
+	dma_cache_sync(NULL, codec->desc, count * sizeof(struct hal2_desc),
+		       DMA_TO_DEVICE);
+	codec->desc_count = count;
+	return 0;
+}
+
+static void hal2_free_dmabuf(struct hal2_codec *codec)
+{
+	dma_free_noncoherent(NULL, codec->desc_count * sizeof(struct hal2_desc),
+			     codec->desc, codec->desc_dma);
+	dma_free_noncoherent(NULL, H2_BUF_SIZE, codec->buffer,
+			     codec->buffer_dma);
+}
+
+static struct snd_pcm_hardware hal2_pcm_hw = {
+	.info = (SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_INTERLEAVED |
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER),
+	.formats =          SNDRV_PCM_FMTBIT_S16_BE,
+	.rates =            SNDRV_PCM_RATE_8000_48000,
+	.rate_min =         8000,
+	.rate_max =         48000,
+	.channels_min =     2,
+	.channels_max =     2,
+	.buffer_bytes_max = 65536,
+	.period_bytes_min = 1024,
+	.period_bytes_max = 65536,
+	.periods_min =      2,
+	.periods_max =      1024,
+};
+
+static int hal2_pcm_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params)
+{
+	int err;
+
+	err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int hal2_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int hal2_playback_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
+	int err;
+
+	runtime->hw = hal2_pcm_hw;
+
+	err = hal2_alloc_dmabuf(&hal2->dac);
+	if (err)
+		return err;
+	return 0;
+}
+
+static int hal2_playback_close(struct snd_pcm_substream *substream)
+{
+	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
+
+	hal2_free_dmabuf(&hal2->dac);
+	return 0;
+}
+
+static int hal2_playback_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hal2_codec *dac = &hal2->dac;
+
+	dac->voices = runtime->channels;
+	dac->sample_rate = hal2_compute_rate(dac, runtime->rate);
+	memset(&dac->pcm_indirect, 0, sizeof(dac->pcm_indirect));
+	dac->pcm_indirect.hw_buffer_size = H2_BUF_SIZE;
+	dac->pcm_indirect.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);
+	dac->substream = substream;
+	hal2_setup_dac(hal2);
+	return 0;
+}
+
+static int hal2_playback_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		hal2->dac.pcm_indirect.hw_io = hal2->dac.buffer_dma;
+		hal2->dac.pcm_indirect.hw_data = 0;
+		substream->ops->ack(substream);
+		hal2_start_dac(hal2);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		hal2_stop_dac(hal2);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static snd_pcm_uframes_t
+hal2_playback_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
+	struct hal2_codec *dac = &hal2->dac;
+
+	return snd_pcm_indirect_playback_pointer(substream, &dac->pcm_indirect,
+						 dac->pbus.pbus->pbdma_bptr);
+}
+
+static void hal2_playback_transfer(struct snd_pcm_substream *substream,
+				   struct snd_pcm_indirect *rec, size_t bytes)
+{
+	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
+	unsigned char *buf = hal2->dac.buffer + rec->hw_data;
+
+	memcpy(buf, substream->runtime->dma_area + rec->sw_data, bytes);
+	dma_cache_sync(NULL, buf, bytes, DMA_TO_DEVICE);
+
+}
+
+static int hal2_playback_ack(struct snd_pcm_substream *substream)
+{
+	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
+	struct hal2_codec *dac = &hal2->dac;
+
+	dac->pcm_indirect.hw_queue_size = H2_BUF_SIZE / 2;
+	snd_pcm_indirect_playback_transfer(substream,
+					   &dac->pcm_indirect,
+					   hal2_playback_transfer);
+	return 0;
+}
+
+static int hal2_capture_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
+	struct hal2_codec *adc = &hal2->adc;
+	int err;
+
+	runtime->hw = hal2_pcm_hw;
+
+	err = hal2_alloc_dmabuf(adc);
+	if (err)
+		return err;
+	return 0;
+}
+
+static int hal2_capture_close(struct snd_pcm_substream *substream)
+{
+	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
+
+	hal2_free_dmabuf(&hal2->adc);
+	return 0;
+}
+
+static int hal2_capture_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hal2_codec *adc = &hal2->adc;
+
+	adc->voices = runtime->channels;
+	adc->sample_rate = hal2_compute_rate(adc, runtime->rate);
+	memset(&adc->pcm_indirect, 0, sizeof(adc->pcm_indirect));
+	adc->pcm_indirect.hw_buffer_size = H2_BUF_SIZE;
+	adc->pcm_indirect.hw_queue_size = H2_BUF_SIZE / 2;
+	adc->pcm_indirect.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);
+	adc->substream = substream;
+	hal2_setup_adc(hal2);
+	return 0;
+}
+
+static int hal2_capture_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		hal2->adc.pcm_indirect.hw_io = hal2->adc.buffer_dma;
+		hal2->adc.pcm_indirect.hw_data = 0;
+		printk(KERN_DEBUG "buffer_dma %x\n", hal2->adc.buffer_dma);
+		hal2_start_adc(hal2);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		hal2_stop_adc(hal2);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static snd_pcm_uframes_t
+hal2_capture_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
+	struct hal2_codec *adc = &hal2->adc;
+
+	return snd_pcm_indirect_capture_pointer(substream, &adc->pcm_indirect,
+						adc->pbus.pbus->pbdma_bptr);
+}
+
+static void hal2_capture_transfer(struct snd_pcm_substream *substream,
+				  struct snd_pcm_indirect *rec, size_t bytes)
+{
+	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
+	unsigned char *buf = hal2->adc.buffer + rec->hw_data;
+
+	dma_cache_sync(NULL, buf, bytes, DMA_FROM_DEVICE);
+	memcpy(substream->runtime->dma_area + rec->sw_data, buf, bytes);
+}
+
+static int hal2_capture_ack(struct snd_pcm_substream *substream)
+{
+	struct snd_hal2 *hal2 = snd_pcm_substream_chip(substream);
+	struct hal2_codec *adc = &hal2->adc;
+
+	snd_pcm_indirect_capture_transfer(substream,
+					  &adc->pcm_indirect,
+					  hal2_capture_transfer);
+	return 0;
+}
+
+static struct snd_pcm_ops hal2_playback_ops = {
+	.open =        hal2_playback_open,
+	.close =       hal2_playback_close,
+	.ioctl =       snd_pcm_lib_ioctl,
+	.hw_params =   hal2_pcm_hw_params,
+	.hw_free =     hal2_pcm_hw_free,
+	.prepare =     hal2_playback_prepare,
+	.trigger =     hal2_playback_trigger,
+	.pointer =     hal2_playback_pointer,
+	.ack =         hal2_playback_ack,
+};
+
+static struct snd_pcm_ops hal2_capture_ops = {
+	.open =        hal2_capture_open,
+	.close =       hal2_capture_close,
+	.ioctl =       snd_pcm_lib_ioctl,
+	.hw_params =   hal2_pcm_hw_params,
+	.hw_free =     hal2_pcm_hw_free,
+	.prepare =     hal2_capture_prepare,
+	.trigger =     hal2_capture_trigger,
+	.pointer =     hal2_capture_pointer,
+	.ack =         hal2_capture_ack,
+};
+
+static int __devinit hal2_pcm_create(struct snd_hal2 *hal2)
+{
+	struct snd_pcm *pcm;
+	int err;
+
+	/* create first pcm device with one outputs and one input */
+	err = snd_pcm_new(hal2->card, "SGI HAL2 Audio", 0, 1, 1, &pcm);
+	if (err < 0)
+		return err;
+
+	pcm->private_data = hal2;
+	strcpy(pcm->name, "SGI HAL2");
+
+	/* set operators */
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&hal2_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+			&hal2_capture_ops);
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
+					   snd_dma_continuous_data(GFP_KERNEL),
+					   0, 1024 * 1024);
+
+	return 0;
+}
+
+static int hal2_dev_free(struct snd_device *device)
+{
+	struct snd_hal2 *hal2 = device->device_data;
+
+	free_irq(SGI_HPCDMA_IRQ, hal2);
+	kfree(hal2);
+	return 0;
+}
+
+static struct snd_device_ops hal2_ops = {
+	.dev_free = hal2_dev_free,
+};
+
+static void hal2_init_codec(struct hal2_codec *codec, struct hpc3_regs *hpc3,
+			    int index)
+{
+	codec->pbus.pbusnr = index;
+	codec->pbus.pbus = &hpc3->pbdma[index];
+}
+
+static int hal2_detect(struct snd_hal2 *hal2)
+{
+	unsigned short board, major, minor;
+	unsigned short rev;
+
+	/* reset HAL2 */
+	hal2_write(0, &hal2->ctl_regs->isr);
+
+	/* release reset */
+	hal2_write(H2_ISR_GLOBAL_RESET_N | H2_ISR_CODEC_RESET_N,
+		   &hal2->ctl_regs->isr);
+
+
+	hal2_i_write16(hal2, H2I_RELAY_C, H2I_RELAY_C_STATE);
+	rev = hal2_read(&hal2->ctl_regs->rev);
+	if (rev & H2_REV_AUDIO_PRESENT)
+		return -ENODEV;
+
+	board = (rev & H2_REV_BOARD_M) >> 12;
+	major = (rev & H2_REV_MAJOR_CHIP_M) >> 4;
+	minor = (rev & H2_REV_MINOR_CHIP_M);
+
+	printk(KERN_INFO "SGI HAL2 revision %i.%i.%i\n",
+	       board, major, minor);
+
+	return 0;
+}
+
+static int hal2_create(struct snd_card *card, struct snd_hal2 **rchip)
+{
+	struct snd_hal2 *hal2;
+	struct hpc3_regs *hpc3 = hpc3c0;
+	int err;
+
+	hal2 = kzalloc(sizeof(struct snd_hal2), GFP_KERNEL);
+	if (!hal2)
+		return -ENOMEM;
+
+	hal2->card = card;
+
+	if (request_irq(SGI_HPCDMA_IRQ, hal2_interrupt, IRQF_SHARED,
+			"SGI HAL2", hal2)) {
+		printk(KERN_ERR "HAL2: Can't get irq %d\n", SGI_HPCDMA_IRQ);
+		kfree(hal2);
+		return -EAGAIN;
+	}
+
+	hal2->ctl_regs = (struct hal2_ctl_regs *)hpc3->pbus_extregs[0];
+	hal2->aes_regs = (struct hal2_aes_regs *)hpc3->pbus_extregs[1];
+	hal2->vol_regs = (struct hal2_vol_regs *)hpc3->pbus_extregs[2];
+	hal2->syn_regs = (struct hal2_syn_regs *)hpc3->pbus_extregs[3];
+
+	if (hal2_detect(hal2) < 0) {
+		kfree(hal2);
+		return -ENODEV;
+	}
+
+	hal2_init_codec(&hal2->dac, hpc3, 0);
+	hal2_init_codec(&hal2->adc, hpc3, 1);
+
+	/*
+	 * All DMA channel interfaces in HAL2 are designed to operate with
+	 * PBUS programmed for 2 cycles in D3, 2 cycles in D4 and 2 cycles
+	 * in D5. HAL2 is a 16-bit device which can accept both big and little
+	 * endian format. It assumes that even address bytes are on high
+	 * portion of PBUS (15:8) and assumes that HPC3 is programmed to
+	 * accept a live (unsynchronized) version of P_DREQ_N from HAL2.
+	 */
+#define HAL2_PBUS_DMACFG ((0 << HPC3_DMACFG_D3R_SHIFT) | \
+			  (2 << HPC3_DMACFG_D4R_SHIFT) | \
+			  (2 << HPC3_DMACFG_D5R_SHIFT) | \
+			  (0 << HPC3_DMACFG_D3W_SHIFT) | \
+			  (2 << HPC3_DMACFG_D4W_SHIFT) | \
+			  (2 << HPC3_DMACFG_D5W_SHIFT) | \
+				HPC3_DMACFG_DS16 | \
+				HPC3_DMACFG_EVENHI | \
+				HPC3_DMACFG_RTIME | \
+			  (8 << HPC3_DMACFG_BURST_SHIFT) | \
+				HPC3_DMACFG_DRQLIVE)
+	/*
+	 * Ignore what's mentioned in the specification and write value which
+	 * works in The Real World (TM)
+	 */
+	hpc3->pbus_dmacfg[hal2->dac.pbus.pbusnr][0] = 0x8208844;
+	hpc3->pbus_dmacfg[hal2->adc.pbus.pbusnr][0] = 0x8208844;
+
+	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, hal2, &hal2_ops);
+	if (err < 0) {
+		free_irq(SGI_HPCDMA_IRQ, hal2);
+		kfree(hal2);
+		return err;
+	}
+	*rchip = hal2;
+	return 0;
+}
+
+static int __devinit hal2_probe(struct platform_device *pdev)
+{
+	struct snd_card *card;
+	struct snd_hal2 *chip;
+	int err;
+
+	card = snd_card_new(index, id, THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+
+	err = hal2_create(card, &chip);
+	if (err < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	snd_card_set_dev(card, &pdev->dev);
+
+	err = hal2_pcm_create(chip);
+	if (err < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	err = hal2_mixer_create(chip);
+	if (err < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	strcpy(card->driver, "SGI HAL2 Audio");
+	strcpy(card->shortname, "SGI HAL2 Audio");
+	sprintf(card->longname, "%s irq %i",
+		card->shortname,
+		SGI_HPCDMA_IRQ);
+
+	err = snd_card_register(card);
+	if (err < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	platform_set_drvdata(pdev, card);
+	return 0;
+}
+
+static int __exit hal2_remove(struct platform_device *pdev)
+{
+	struct snd_card *card = platform_get_drvdata(pdev);
+
+	snd_card_free(card);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static struct platform_driver hal2_driver = {
+	.probe	= hal2_probe,
+	.remove	= __devexit_p(hal2_remove),
+	.driver = {
+		.name	= "sgihal2",
+		.owner	= THIS_MODULE,
+	}
+};
+
+static int __init alsa_card_hal2_init(void)
+{
+	return platform_driver_register(&hal2_driver);
+}
+
+static void __exit alsa_card_hal2_exit(void)
+{
+	platform_driver_unregister(&hal2_driver);
+}
+
+module_init(alsa_card_hal2_init);
+module_exit(alsa_card_hal2_exit);
