commit b9f2d35f05308813c4c887d5c530004f01e1829c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat May 16 08:28:54 2020 +0200

    ALSA: hda: Unexport some local helper functions
    
    snd_hdac_bus_queue_event() and snd_hdac_bus_exec_verb() are used only
    internally in HD-audio core.  Let's drop the exports and move the
    declarations into local.h.
    
    Link: https://lore.kernel.org/r/20200516062854.22141-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index ac15aa357fbd..011b17cc1efa 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -9,6 +9,7 @@
 #include <sound/core.h>
 #include <sound/hdaudio.h>
 #include <sound/hda_register.h>
+#include "local.h"
 
 /* clear CORB read pointer properly */
 static void azx_clear_corbrp(struct hdac_bus *bus)

commit 67ae482a59e951c346b5a55a756504bc58ce7cfa
Author: Sameer Pujar <spujar@nvidia.com>
Date:   Mon May 4 13:46:15 2020 +0530

    ALSA: hda: add member to store ratio for stripe control
    
    Stripe control programming is governed by following formula, which is
    referenced from the HD Audio specification(Revision 1.0a).
      { ((num_channels * bits_per_sample) / number of SDOs) >= 8 }
    
    Currently above is implemented in snd_hdac_get_stream_stripe_ctl().
    This patch introduces a structure member to store the default factor
    of '8'. If any HW wants to use a different value, this member can be
    easily updated.
    
    Signed-off-by: Sameer Pujar <spujar@nvidia.com>
    Link: https://lore.kernel.org/r/1588580176-2801-3-git-send-email-spujar@nvidia.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index bc4a8b606020..ac15aa357fbd 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -527,6 +527,18 @@ bool snd_hdac_bus_init_chip(struct hdac_bus *bus, bool full_reset)
 	}
 
 	bus->chip_init = true;
+
+	/*
+	 * Default value of '8' is as per the HD audio specification (Rev 1.0a).
+	 * Following relation is used to derive STRIPE control value.
+	 *  For sample rate <= 48K:
+	 *   { ((num_channels * bits_per_sample) / number of SDOs) >= 8 }
+	 *  For sample rate > 48K:
+	 *   { ((num_channels * bits_per_sample * rate/48000) /
+	 *	number of SDOs) >= 8 }
+	 */
+	bus->sdo_limit = 8;
+
 	return true;
 }
 EXPORT_SYMBOL_GPL(snd_hdac_bus_init_chip);

commit 6e57188f20ecf33185b671cff1af305d8f3bb2fe
Author: Keyon Jie <yang.jie@linux.intel.com>
Date:   Mon Jan 13 14:56:38 2020 -0600

    ALSA: hda: Update kernel-doc function parameter descriptions
    
    Make W=1 throws a lot of warnings, with multiple misalignments between
    function params and their descriptions.
    
    Signed-off-by: Keyon Jie <yang.jie@linux.intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20200113205638.27338-1-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index b856184af37f..bc4a8b606020 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -561,7 +561,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_bus_stop_chip);
  * snd_hdac_bus_handle_stream_irq - interrupt handler for streams
  * @bus: HD-audio core bus
  * @status: INTSTS register value
- * @ask: callback to be called for woken streams
+ * @ack: callback to be called for woken streams
  *
  * Returns the bits of handled streams, or zero if no stream is handled.
  */

commit 651bbb9d5161ae7170bc19fec893b8bf05fc590f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Dec 13 17:30:05 2019 +0100

    ALSA: hda: Comment about snd_hdac_bus_update_rirb() and spinlock
    
    The call of snd_hdac_bus_update_rirb() needs the bus->reg_lock
    spinlock protection for concurrency.  Comment about it more
    explicitly.
    
    Link: https://lore.kernel.org/r/20191213163005.19116-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 01787081552d..b856184af37f 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -181,6 +181,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_bus_send_cmd);
  * @bus: HD-audio core bus
  *
  * Usually called from interrupt handler.
+ * The caller needs bus->reg_lock spinlock before calling this.
  */
 void snd_hdac_bus_update_rirb(struct hdac_bus *bus)
 {

commit 5f2cb361d798fb39adb79fab4e5235e307c70e9a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 12 20:11:01 2019 +0100

    ALSA: hda: Unify get_response handling
    
    Now most of the get_response handling became quite similar between
    HDA-core and legacy drivers, and the only differences are:
    
    - the handling of extra-long polling delay for some codecs
    - the debug message for the stalled communication
    
    and both are worth to share in the common code.
    
    This patch unifies the code into snd_hdac_bus_get_response(), and use
    this from the legacy get_response callback.  It results in a good
    amount of code reduction in the end.
    
    Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
    Link: https://lore.kernel.org/r/20191212191101.19517-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 61950b83b8c9..01787081552d 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -242,6 +242,7 @@ int snd_hdac_bus_get_response(struct hdac_bus *bus, unsigned int addr,
 	unsigned long timeout;
 	unsigned long loopcounter;
 	wait_queue_entry_t wait;
+	bool warned = false;
 
 	init_wait_entry(&wait, 0);
 	timeout = jiffies + msecs_to_jiffies(1000);
@@ -264,9 +265,17 @@ int snd_hdac_bus_get_response(struct hdac_bus *bus, unsigned int addr,
 		spin_unlock_irq(&bus->reg_lock);
 		if (time_after(jiffies, timeout))
 			break;
+#define LOOP_COUNT_MAX	3000
 		if (!bus->polling_mode) {
 			schedule_timeout(msecs_to_jiffies(2));
-		} else if (loopcounter > 3000) {
+		} else if (bus->needs_damn_long_delay ||
+			   loopcounter > LOOP_COUNT_MAX) {
+			if (loopcounter > LOOP_COUNT_MAX && !warned) {
+				dev_dbg_ratelimited(bus->dev,
+						    "too slow response, last cmd=%#08x\n",
+						    bus->last_cmd[addr]);
+				warned = true;
+			}
 			msleep(2); /* temporary workaround */
 		} else {
 			udelay(10);

commit 89698ed5cc76d8de6c2b51d132c06bf4cd930314
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 12 20:11:00 2019 +0100

    ALSA: hda: Use waitqueue for RIRB in HDA-core helper, too
    
    This patch implements the same logic that was done for the legacy
    HD-audio controller driver by the commit 88452da92ba2 ("ALSA: hda: Use
    standard waitqueue for RIRB wakeup") to the HDA-core helper code,
    too.  This makes snd_hdac_bus_get_response() waiting for the response
    with bus->rirb_wq instead of polling when bus->polling is false.
    It'll save both CPU time and response latency.
    
    Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
    Link: https://lore.kernel.org/r/20191212191101.19517-2-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index cd1c3b282657..61950b83b8c9 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -241,30 +241,42 @@ int snd_hdac_bus_get_response(struct hdac_bus *bus, unsigned int addr,
 {
 	unsigned long timeout;
 	unsigned long loopcounter;
+	wait_queue_entry_t wait;
 
+	init_wait_entry(&wait, 0);
 	timeout = jiffies + msecs_to_jiffies(1000);
 
 	for (loopcounter = 0;; loopcounter++) {
 		spin_lock_irq(&bus->reg_lock);
+		if (!bus->polling_mode)
+			prepare_to_wait(&bus->rirb_wq, &wait,
+					TASK_UNINTERRUPTIBLE);
 		if (bus->polling_mode)
 			snd_hdac_bus_update_rirb(bus);
 		if (!bus->rirb.cmds[addr]) {
 			if (res)
 				*res = bus->rirb.res[addr]; /* the last value */
+			if (!bus->polling_mode)
+				finish_wait(&bus->rirb_wq, &wait);
 			spin_unlock_irq(&bus->reg_lock);
 			return 0;
 		}
 		spin_unlock_irq(&bus->reg_lock);
 		if (time_after(jiffies, timeout))
 			break;
-		if (loopcounter > 3000)
+		if (!bus->polling_mode) {
+			schedule_timeout(msecs_to_jiffies(2));
+		} else if (loopcounter > 3000) {
 			msleep(2); /* temporary workaround */
-		else {
+		} else {
 			udelay(10);
 			cond_resched();
 		}
 	}
 
+	if (!bus->polling_mode)
+		finish_wait(&bus->rirb_wq, &wait);
+
 	return -EIO;
 }
 EXPORT_SYMBOL_GPL(snd_hdac_bus_get_response);

commit 88452da92ba2b264a3922218c2cec13aac51c502
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 15:57:27 2019 +0100

    ALSA: hda: Use standard waitqueue for RIRB wakeup
    
    The HD-audio CORB/RIRB communication was programmed in a way that was
    documented in the reference in decades ago, which is essentially a
    polling in the waiter side.  It's working fine but costs CPU cycles on
    some platforms that support only slow communications.  Also, for some
    platforms that had unreliable communications, we put longer wait time
    (2 ms), which accumulate quite long time if you execute many verbs in
    a shot (e.g. at the initialization or resume phase).
    
    This patch attempts to improve the situation by introducing the
    standard waitqueue in the RIRB waiter side instead of polling.  The
    test results on my machine show significant improvements.  The time
    spent for "cat /proc/asound/card*/codec#*" were changed like:
    
    * Intel SKL + Realtek codec
      before the patch:
       0.00user 0.04system 0:00.10elapsed 40.0%CPU
      after the patch:
       0.00user 0.01system 0:00.10elapsed 10.0%CPU
    
    * Nvidia GP107GL + Nvidia HDMI codec
      before the patch:
       0.00user 0.00system 0:02.76elapsed 0.0%CPU
      after the patch:
       0.00user 0.00system 0:00.01elapsed 17.0%CPU
    
    So, for Intel chips, the total time is same, while the total time is
    greatly reduced (from 2.76 to 0.01s) for Nvidia chips.
    The only negative data here is the increase of CPU time for Nvidia,
    but this is the unavoidable cost for faster wakeups, supposedly.
    
    Link: https://lore.kernel.org/r/20191210145727.22054-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 7e7be8e4dcf9..cd1c3b282657 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -216,6 +216,9 @@ void snd_hdac_bus_update_rirb(struct hdac_bus *bus)
 		else if (bus->rirb.cmds[addr]) {
 			bus->rirb.res[addr] = res;
 			bus->rirb.cmds[addr]--;
+			if (!bus->rirb.cmds[addr] &&
+			    waitqueue_active(&bus->rirb_wq))
+				wake_up(&bus->rirb_wq);
 		} else {
 			dev_err_ratelimited(bus->dev,
 				"spurious response %#x:%#x, last cmd=%#08x\n",

commit 1a7f60b9df614bb36d14dc0c0bc898a31b2b506f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 28 09:10:56 2019 +0100

    Revert "ALSA: hda: Flush interrupts on disabling"
    
    This reverts commit caa8422d01e983782548648e125fd617cadcec3f.
    
    It turned out that this commit caused a regression at shutdown /
    reboot, as the synchronize_irq() calls seems blocking the whole
    shutdown.  Also another part of the change about shuffling the call
    order looks suspicious; the azx_stop_chip() call disables the CORB /
    RIRB while the others may still need the CORB/RIRB update.
    
    Since the original commit itself was a cargo-fix, let's revert the
    whole patch.
    
    Fixes: caa8422d01e9 ("ALSA: hda: Flush interrupts on disabling")
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=205333
    BugLinK: https://bugs.freedesktop.org/show_bug.cgi?id=111174
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://lore.kernel.org/r/20191028081056.22010-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index d3999e7b0705..7e7be8e4dcf9 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -447,8 +447,6 @@ static void azx_int_disable(struct hdac_bus *bus)
 	list_for_each_entry(azx_dev, &bus->stream_list, list)
 		snd_hdac_stream_updateb(azx_dev, SD_CTL, SD_INT_MASK, 0);
 
-	synchronize_irq(bus->irq);
-
 	/* disable SIE for all streams */
 	snd_hdac_chip_writeb(bus, INTCTL, 0);
 

commit 3a76a41ffbf94c49245f5050be97d389b7d28102
Merge: 118b2806a076 d4ff1b3917a5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 8 22:35:44 2019 +0200

    Merge branch 'topic/hda-bus-ops-cleanup' into for-next
    
    Pull HD-audio bus ops cleanups.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 619a1f195f93276dc8c6e33fe057e007adc9c288
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 7 20:02:31 2019 +0200

    ALSA: hda: Remove page allocation redirection
    
    The HD-audio core allocates and releases pages via driver's specific
    dma_alloc_pages and dma_free_pages ops defined in bus->io_ops.  This
    was because some platforms require the uncached pages and the handling
    of page flags had to be done locally in the driver code.
    
    Since the recent change in ALSA core memory allocator, we can simply
    pass SNDRV_DMA_TYPE_DEV_UC for the uncached pages, and the only
    difference became about this type to be passed to the core allocator.
    That is, it's good time for cleaning up the mess.
    
    This patch changes the allocation code in HD-audio core to call the
    core allocator directly so that we get rid of dma_alloc_pages and
    dma_free_pages io_ops.  If a driver needs the uncached pages, it has
    to set bus->dma_type right after the bus initialization.
    
    This is merely a code refactoring and shouldn't bring any behavior
    changes.
    
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 3b0110545070..7e7be8e4dcf9 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -575,12 +575,13 @@ int snd_hdac_bus_alloc_stream_pages(struct hdac_bus *bus)
 {
 	struct hdac_stream *s;
 	int num_streams = 0;
+	int dma_type = bus->dma_type ? bus->dma_type : SNDRV_DMA_TYPE_DEV;
 	int err;
 
 	list_for_each_entry(s, &bus->stream_list, list) {
 		/* allocate memory for the BDL for each stream */
-		err = bus->io_ops->dma_alloc_pages(bus, SNDRV_DMA_TYPE_DEV,
-						   BDL_SIZE, &s->bdl);
+		err = snd_dma_alloc_pages(dma_type, bus->dev,
+					  BDL_SIZE, &s->bdl);
 		num_streams++;
 		if (err < 0)
 			return -ENOMEM;
@@ -589,16 +590,15 @@ int snd_hdac_bus_alloc_stream_pages(struct hdac_bus *bus)
 	if (WARN_ON(!num_streams))
 		return -EINVAL;
 	/* allocate memory for the position buffer */
-	err = bus->io_ops->dma_alloc_pages(bus, SNDRV_DMA_TYPE_DEV,
-					   num_streams * 8, &bus->posbuf);
+	err = snd_dma_alloc_pages(dma_type, bus->dev,
+				  num_streams * 8, &bus->posbuf);
 	if (err < 0)
 		return -ENOMEM;
 	list_for_each_entry(s, &bus->stream_list, list)
 		s->posbuf = (__le32 *)(bus->posbuf.area + s->index * 8);
 
 	/* single page (at least 4096 bytes) must suffice for both ringbuffes */
-	return bus->io_ops->dma_alloc_pages(bus, SNDRV_DMA_TYPE_DEV,
-					    PAGE_SIZE, &bus->rb);
+	return snd_dma_alloc_pages(dma_type, bus->dev, PAGE_SIZE, &bus->rb);
 }
 EXPORT_SYMBOL_GPL(snd_hdac_bus_alloc_stream_pages);
 
@@ -612,12 +612,12 @@ void snd_hdac_bus_free_stream_pages(struct hdac_bus *bus)
 
 	list_for_each_entry(s, &bus->stream_list, list) {
 		if (s->bdl.area)
-			bus->io_ops->dma_free_pages(bus, &s->bdl);
+			snd_dma_free_pages(&s->bdl);
 	}
 
 	if (bus->rb.area)
-		bus->io_ops->dma_free_pages(bus, &bus->rb);
+		snd_dma_free_pages(&bus->rb);
 	if (bus->posbuf.area)
-		bus->io_ops->dma_free_pages(bus, &bus->posbuf);
+		snd_dma_free_pages(&bus->posbuf);
 }
 EXPORT_SYMBOL_GPL(snd_hdac_bus_free_stream_pages);

commit caa8422d01e983782548648e125fd617cadcec3f
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Jul 20 12:33:37 2019 +0100

    ALSA: hda: Flush interrupts on disabling
    
    I was looking at
    
    <4> [241.835158] general protection fault: 0000 [#1] PREEMPT SMP PTI
    <4> [241.835181] CPU: 1 PID: 214 Comm: kworker/1:3 Tainted: G     U            5.2.0-CI-CI_DRM_6509+ #1
    <4> [241.835199] Hardware name: Dell Inc.                 OptiPlex 745                 /0GW726, BIOS 2.3.1  05/21/2007
    <4> [241.835234] Workqueue: events snd_hdac_bus_process_unsol_events [snd_hda_core]
    <4> [241.835256] RIP: 0010:input_handle_event+0x16d/0x5e0
    <4> [241.835270] Code: 48 8b 93 58 01 00 00 8b 52 08 89 50 04 8b 83 f8 06 00 00 48 8b 93 00 07 00 00 8d 70 01 48 8d 04 c2 83 e1 08 89 b3 f8 06 00 00 <66> 89 28 66 44 89 60 02 44 89 68 04 8b 93 f8 06 00 00 0f 84 fd fe
    <4> [241.835304] RSP: 0018:ffffc9000019fda0 EFLAGS: 00010046
    <4> [241.835317] RAX: 6b6b6b6ec6c6c6c3 RBX: ffff8880290fefc8 RCX: 0000000000000000
    <4> [241.835332] RDX: 000000006b6b6b6b RSI: 000000006b6b6b6c RDI: 0000000000000046
    <4> [241.835347] RBP: 0000000000000005 R08: 0000000000000000 R09: 0000000000000001
    <4> [241.835362] R10: ffffc9000019faa0 R11: 0000000000000000 R12: 0000000000000004
    <4> [241.835377] R13: 0000000000000000 R14: ffff8880290ff1d0 R15: 0000000000000293
    <4> [241.835392] FS:  0000000000000000(0000) GS:ffff88803de80000(0000) knlGS:0000000000000000
    <4> [241.835409] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    <4> [241.835422] CR2: 00007ffe9a99e9b7 CR3: 000000002f588000 CR4: 00000000000006e0
    <4> [241.835436] Call Trace:
    <4> [241.835449]  input_event+0x45/0x70
    <4> [241.835464]  snd_jack_report+0xdc/0x100
    <4> [241.835490]  snd_hda_jack_report_sync+0x83/0xc0 [snd_hda_codec]
    <4> [241.835512]  snd_hdac_bus_process_unsol_events+0x5a/0x70 [snd_hda_core]
    <4> [241.835530]  process_one_work+0x245/0x610
    
    which has the hallmarks of a worker queued from interrupt after it was
    supposedly cancelled (note the POISON_FREE), and I could not see where
    the interrupt would be flushed on shutdown so added the likely suspects.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=111174
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 3b0110545070..196bbc85699e 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -447,6 +447,8 @@ static void azx_int_disable(struct hdac_bus *bus)
 	list_for_each_entry(azx_dev, &bus->stream_list, list)
 		snd_hdac_stream_updateb(azx_dev, SD_CTL, SD_INT_MASK, 0);
 
+	synchronize_irq(bus->irq);
+
 	/* disable SIE for all streams */
 	snd_hdac_chip_writeb(bus, INTCTL, 0);
 

commit 3c53c6255d598db7084c5c3d7553d7200e857818
Merge: b89b889a326a a98429acadef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 8 14:45:20 2019 +0200

    Merge tag 'asoc-v5.3' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.3
    
    This is a very big update, mainly thanks to Morimoto-san's refactoring
    work and some fairly large new drivers.
    
     - Lots more work on moving towards a component based framework from
       Morimoto-san.
     - Support for force disconnecting muxes from Jerome Brunet.
     - New drivers for Cirrus Logic CS47L35, CS47L85 and CS47L90, Conexant
       CX2072X, Realtek RT1011 and RT1308.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 7c2b3629d09ddec810dc4c1d3a6657c32def8f71
Author: Rander Wang <rander.wang@linux.intel.com>
Date:   Mon Jul 1 15:46:30 2019 +0800

    ALSA: hda: Fix a headphone detection issue when using SOF
    
    To save power, the hda hdmi driver in ASoC invokes snd_hdac_ext_bus_link_put
    to disable CORB/RIRB buffers DMA if there is no user of bus and invokes
    snd_hdac_ext_bus_link_get to set up CORB/RIRB buffers when it is used.
    Unsolicited responses is disabled in snd_hdac_bus_stop_cmd_io called by
    snd_hdac_ext_bus_link_put , but it is not enabled in snd_hdac_bus_init_cmd_io
    called by snd_hdac_ext_bus_link_get. So for put-get sequence, Unsolicited
    responses is disabled and headphone can't be detected by hda codecs.
    
    Now unsolicited responses is only enabled in snd_hdac_bus_reset_link
    which resets controller. The function is only called for setup of
    controller. This patch enables Unsolicited responses after RIRB is
    initialized in snd_hdac_bus_init_cmd_io which works together with
    snd_hdac_bus_reset_link to set up controller.
    
    Tested legacy hda driver and SOF driver on intel whiskeylake.
    
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Rander Wang <rander.wang@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index d6a91429c058..c24fc8d266a9 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -78,6 +78,8 @@ void snd_hdac_bus_init_cmd_io(struct hdac_bus *bus)
 	snd_hdac_chip_writew(bus, RINTCNT, 1);
 	/* enable rirb dma and response irq */
 	snd_hdac_chip_writeb(bus, RIRBCTL, AZX_RBCTL_DMA_EN | AZX_RBCTL_IRQ_EN);
+	/* Accept unsolicited responses */
+	snd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_UNSOL, AZX_GCTL_UNSOL);
 	spin_unlock_irq(&bus->reg_lock);
 }
 EXPORT_SYMBOL_GPL(snd_hdac_bus_init_cmd_io);
@@ -416,9 +418,6 @@ int snd_hdac_bus_reset_link(struct hdac_bus *bus, bool full_reset)
 		return -EBUSY;
 	}
 
-	/* Accept unsolicited responses */
-	snd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_UNSOL, AZX_GCTL_UNSOL);
-
 	/* detect codecs */
 	if (!bus->codec_mask) {
 		bus->codec_mask = snd_hdac_chip_readw(bus, STATESTS);

commit ee8829dc609c5c4a425b4a65fbb4cd56fb82f1f4
Author: Bard Liao <yung-chuan.liao@linux.intel.com>
Date:   Thu May 30 04:59:00 2019 +0800

    ALSA: hda: fix: lock reg_lock before calling snd_hdac_bus_update_rirb
    
    The patch is to fix commit 5e13cf6cd64c
    (ALSA: hda: add polling mode in snd_hdac_bus_get_response)
    spin_lock_irq should be called before snd_hdac_bus_update_rirb.
    
    Fixes: 5e13cf6cd64c ("ALSA: hda: add polling mode in snd_hdac_bus_get_response")
    Signed-off-by: Bard Liao <yung-chuan.liao@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index a16ac31bda83..d6a91429c058 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -239,9 +239,9 @@ int snd_hdac_bus_get_response(struct hdac_bus *bus, unsigned int addr,
 	timeout = jiffies + msecs_to_jiffies(1000);
 
 	for (loopcounter = 0;; loopcounter++) {
+		spin_lock_irq(&bus->reg_lock);
 		if (bus->polling_mode)
 			snd_hdac_bus_update_rirb(bus);
-		spin_lock_irq(&bus->reg_lock);
 		if (!bus->rirb.cmds[addr]) {
 			if (res)
 				*res = bus->rirb.res[addr]; /* the last value */

commit 5e13cf6cd64c6a4c15a4426e6f1683093a495d9a
Author: Bard Liao <yung-chuan.liao@linux.intel.com>
Date:   Mon May 27 00:58:35 2019 +0800

    ALSA: hda: add polling mode in snd_hdac_bus_get_response
    
    Polling mode is useful if a machine somehow missed an expected IRQ.
    
    Signed-off-by: Bard Liao <yung-chuan.liao@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index b2e9454f5816..a16ac31bda83 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -239,6 +239,8 @@ int snd_hdac_bus_get_response(struct hdac_bus *bus, unsigned int addr,
 	timeout = jiffies + msecs_to_jiffies(1000);
 
 	for (loopcounter = 0;; loopcounter++) {
+		if (bus->polling_mode)
+			snd_hdac_bus_update_rirb(bus);
 		spin_lock_irq(&bus->reg_lock);
 		if (!bus->rirb.cmds[addr]) {
 			if (res)

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index b2e9454f5816..b02f74528b66 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * HD-audio controller helpers
  */

commit 081e01f059ba03b25499cb4616ec58db0979406d
Author: Keyon Jie <yang.jie@linux.intel.com>
Date:   Wed Jan 9 16:20:50 2019 +0800

    ALSA: hda: Fix mismatches for register mask and value in hdac controller
    
    E.g. for azx_int_enable(), we should set both mask and value to be
    "AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN"(the mask was 0) to enable
    controller CIE and GIE.
    
    We have similar issues on setting AZX_GCTL_RESET and AZX_GCTL_UNSOL,
    here try to correct all of them.
    
    Signed-off-by: Keyon Jie <yang.jie@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 74244d8e2909..b2e9454f5816 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -376,7 +376,7 @@ void snd_hdac_bus_exit_link_reset(struct hdac_bus *bus)
 {
 	unsigned long timeout;
 
-	snd_hdac_chip_updateb(bus, GCTL, 0, AZX_GCTL_RESET);
+	snd_hdac_chip_updateb(bus, GCTL, AZX_GCTL_RESET, AZX_GCTL_RESET);
 
 	timeout = jiffies + msecs_to_jiffies(100);
 	while (!snd_hdac_chip_readb(bus, GCTL) && time_before(jiffies, timeout))
@@ -415,7 +415,7 @@ int snd_hdac_bus_reset_link(struct hdac_bus *bus, bool full_reset)
 	}
 
 	/* Accept unsolicited responses */
-	snd_hdac_chip_updatel(bus, GCTL, 0, AZX_GCTL_UNSOL);
+	snd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_UNSOL, AZX_GCTL_UNSOL);
 
 	/* detect codecs */
 	if (!bus->codec_mask) {
@@ -431,7 +431,9 @@ EXPORT_SYMBOL_GPL(snd_hdac_bus_reset_link);
 static void azx_int_enable(struct hdac_bus *bus)
 {
 	/* enable controller CIE and GIE */
-	snd_hdac_chip_updatel(bus, INTCTL, 0, AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN);
+	snd_hdac_chip_updatel(bus, INTCTL,
+			      AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN,
+			      AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN);
 }
 
 /* disable interrupts */

commit 75383f8d39d4c0fb96083dd460b7b139fbdac492
Author: Yu Zhao <yuzhao@google.com>
Date:   Tue Sep 11 15:15:16 2018 -0600

    sound: don't call skl_init_chip() to reset intel skl soc
    
    Internally, skl_init_chip() calls snd_hdac_bus_init_chip() which
    1) sets bus->chip_init to prevent multiple entrances before device
    is stopped; 2) enables interrupt.
    
    We shouldn't use it for the purpose of resetting device only because
    1) when we really want to initialize device, we won't be able to do
    so; 2) we are ready to handle interrupt yet, and kernel crashes when
    interrupt comes in.
    
    Rename azx_reset() to snd_hdac_bus_reset_link(), and use it to reset
    device properly.
    
    Fixes: 60767abcea3d ("ASoC: Intel: Skylake: Reset the controller in probe")
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Yu Zhao <yuzhao@google.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 11057d9f84ec..74244d8e2909 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -385,7 +385,7 @@ void snd_hdac_bus_exit_link_reset(struct hdac_bus *bus)
 EXPORT_SYMBOL_GPL(snd_hdac_bus_exit_link_reset);
 
 /* reset codec link */
-static int azx_reset(struct hdac_bus *bus, bool full_reset)
+int snd_hdac_bus_reset_link(struct hdac_bus *bus, bool full_reset)
 {
 	if (!full_reset)
 		goto skip_reset;
@@ -410,7 +410,7 @@ static int azx_reset(struct hdac_bus *bus, bool full_reset)
  skip_reset:
 	/* check to see if controller is ready */
 	if (!snd_hdac_chip_readb(bus, GCTL)) {
-		dev_dbg(bus->dev, "azx_reset: controller not ready!\n");
+		dev_dbg(bus->dev, "controller not ready!\n");
 		return -EBUSY;
 	}
 
@@ -425,6 +425,7 @@ static int azx_reset(struct hdac_bus *bus, bool full_reset)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(snd_hdac_bus_reset_link);
 
 /* enable interrupts */
 static void azx_int_enable(struct hdac_bus *bus)
@@ -479,7 +480,7 @@ bool snd_hdac_bus_init_chip(struct hdac_bus *bus, bool full_reset)
 		return false;
 
 	/* reset controller */
-	azx_reset(bus, full_reset);
+	snd_hdac_bus_reset_link(bus, full_reset);
 
 	/* clear interrupts */
 	azx_int_clear(bus);

commit b61749a89f826eb61fc59794d9e4697bd246eb61
Author: Yu Zhao <yuzhao@google.com>
Date:   Tue Sep 11 15:14:04 2018 -0600

    sound: enable interrupt after dma buffer initialization
    
    In snd_hdac_bus_init_chip(), we enable interrupt before
    snd_hdac_bus_init_cmd_io() initializing dma buffers. If irq has
    been acquired and irq handler uses the dma buffer, kernel may crash
    when interrupt comes in.
    
    Fix the problem by postponing enabling irq after dma buffer
    initialization. And warn once on null dma buffer pointer during the
    initialization.
    
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Yu Zhao <yuzhao@google.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 560ec0986e1a..11057d9f84ec 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -40,6 +40,8 @@ static void azx_clear_corbrp(struct hdac_bus *bus)
  */
 void snd_hdac_bus_init_cmd_io(struct hdac_bus *bus)
 {
+	WARN_ON_ONCE(!bus->rb.area);
+
 	spin_lock_irq(&bus->reg_lock);
 	/* CORB set up */
 	bus->corb.addr = bus->rb.addr;
@@ -479,13 +481,15 @@ bool snd_hdac_bus_init_chip(struct hdac_bus *bus, bool full_reset)
 	/* reset controller */
 	azx_reset(bus, full_reset);
 
-	/* initialize interrupts */
+	/* clear interrupts */
 	azx_int_clear(bus);
-	azx_int_enable(bus);
 
 	/* initialize the codec command I/O */
 	snd_hdac_bus_init_cmd_io(bus);
 
+	/* enable interrupts after CORB/RIRB buffers are initialized above */
+	azx_int_enable(bus);
+
 	/* program the position buffer */
 	if (bus->use_posbuf && bus->posbuf.addr) {
 		snd_hdac_chip_writel(bus, DPLBASE, (u32)bus->posbuf.addr);

commit c429bda21ffafb28f02fb2eb4055b4ab6879ed58
Merge: 75ee94b20b46 9718a29d40b7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 13 15:43:04 2017 +0100

    Merge branch 'for-next' into for-linus
    
    Pull 4.15 updates to take over the previous urgent fixes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit b676da70c495acb2515de76300596e9147806ead
Author: Rakesh Ughreja <rakesh.a.ughreja@intel.com>
Date:   Tue Oct 24 18:26:47 2017 +0530

    ALSA: hda: Abort capability probe on invalid capability
    
    On reading wrong capability pointer values driver may crash, so whenever
    driver discovers unknown HDA capability, log it as error and stop traversing
    the link list further.
    
    Signed-off-by: Rakesh Ughreja <rakesh.a.ughreja@intel.com>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 978dc1801b3a..8f7d0d9ed762 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -314,7 +314,8 @@ int snd_hdac_bus_parse_capabilities(struct hdac_bus *bus)
 			break;
 
 		default:
-			dev_dbg(bus->dev, "Unknown capability %d\n", cur_cap);
+			dev_err(bus->dev, "Unknown capability %d\n", cur_cap);
+			cur_cap = 0;
 			break;
 		}
 

commit 098a0a62c1554f5a3813ef1b8539563214ada8f6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 17 16:38:55 2017 +0200

    ALSA: hda: Abort capability probe at invalid register read
    
    The loop in snd_hdac_bus_parse_capabilities() may go to nirvana when
    it hits an invalid register value read:
    
     BUG: unable to handle kernel paging request at ffffad5dc41f3fff
     IP: pci_azx_readl+0x5/0x10 [snd_hda_intel]
     Call Trace:
      snd_hdac_bus_parse_capabilities+0x3c/0x1f0 [snd_hda_core]
      azx_probe_continue+0x7d5/0x940 [snd_hda_intel]
      .....
    
    This happened on a new Intel machine, and we need to check the value
    and abort the loop accordingly.
    
    [Note: the fixes tag below indicates only the commit where this patch
     can be applied; the original problem was introduced even before that
     commit]
    
    Fixes: 6720b38420a0 ("ALSA: hda - move bus_parse_capabilities to core")
    Cc: <stable@vger.kernel.org>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 978dc1801b3a..f6d2985b2520 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -284,6 +284,11 @@ int snd_hdac_bus_parse_capabilities(struct hdac_bus *bus)
 		dev_dbg(bus->dev, "HDA capability ID: 0x%x\n",
 			(cur_cap & AZX_CAP_HDR_ID_MASK) >> AZX_CAP_HDR_ID_OFF);
 
+		if (cur_cap == -1) {
+			dev_dbg(bus->dev, "Invalid capability reg read\n");
+			break;
+		}
+
 		switch ((cur_cap & AZX_CAP_HDR_ID_MASK) >> AZX_CAP_HDR_ID_OFF) {
 		case AZX_ML_CAP_ID:
 			dev_dbg(bus->dev, "Found ML capability\n");

commit 960013762df0a214b57f2fce655422fb52bdfd2c
Author: Jeeja KP <jeeja.kp@intel.com>
Date:   Wed May 10 11:51:58 2017 +0530

    ALSA: hda: Fix cpu lockup when stopping the cmd dmas
    
    Using jiffies in hdac_wait_for_cmd_dmas() to determine when to time out
    when interrupts are off (snd_hdac_bus_stop_cmd_io()/spin_lock_irq())
    causes hard lockup so unlock while waiting using jiffies.
    
    ---<-snip->---
    <0>[ 1211.603046] NMI watchdog: Watchdog detected hard LOCKUP on cpu 3
    <4>[ 1211.603047] Modules linked in: snd_hda_intel i915 vgem
    <4>[ 1211.603053] irq event stamp: 13366
    <4>[ 1211.603053] hardirqs last  enabled at (13365):
    ...
    <4>[ 1211.603059] Call Trace:
    <4>[ 1211.603059]  ? delay_tsc+0x3d/0xc0
    <4>[ 1211.603059]  __delay+0xa/0x10
    <4>[ 1211.603060]  __const_udelay+0x31/0x40
    <4>[ 1211.603060]  snd_hdac_bus_stop_cmd_io+0x96/0xe0 [snd_hda_core]
    <4>[ 1211.603060]  ? azx_dev_disconnect+0x20/0x20 [snd_hda_intel]
    <4>[ 1211.603061]  snd_hdac_bus_stop_chip+0xb1/0x100 [snd_hda_core]
    <4>[ 1211.603061]  azx_stop_chip+0x9/0x10 [snd_hda_codec]
    <4>[ 1211.603061]  azx_suspend+0x72/0x220 [snd_hda_intel]
    <4>[ 1211.603061]  pci_pm_suspend+0x71/0x140
    <4>[ 1211.603062]  dpm_run_callback+0x6f/0x330
    <4>[ 1211.603062]  ? pci_pm_freeze+0xe0/0xe0
    <4>[ 1211.603062]  __device_suspend+0xf9/0x370
    <4>[ 1211.603062]  ? dpm_watchdog_set+0x60/0x60
    <4>[ 1211.603063]  async_suspend+0x1a/0x90
    <4>[ 1211.603063]  async_run_entry_fn+0x34/0x160
    <4>[ 1211.603063]  process_one_work+0x1f4/0x6d0
    <4>[ 1211.603063]  ? process_one_work+0x16e/0x6d0
    <4>[ 1211.603064]  worker_thread+0x49/0x4a0
    <4>[ 1211.603064]  kthread+0x107/0x140
    <4>[ 1211.603064]  ? process_one_work+0x6d0/0x6d0
    <4>[ 1211.603065]  ? kthread_create_on_node+0x40/0x40
    <4>[ 1211.603065]  ret_from_fork+0x2e/0x40
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=100419
    Fixes: 38b19ed7f81ec ("ALSA: hda: fix to wait for RIRB & CORB DMA to set")
    Reported-by: Marta Lofstedt <marta.lofstedt@intel.com>
    Suggested-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    CC: stable <stable@vger.kernel.org> # 4.7
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index ee08c389b4d6..978dc1801b3a 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -106,7 +106,11 @@ void snd_hdac_bus_stop_cmd_io(struct hdac_bus *bus)
 	/* disable ringbuffer DMAs */
 	snd_hdac_chip_writeb(bus, RIRBCTL, 0);
 	snd_hdac_chip_writeb(bus, CORBCTL, 0);
+	spin_unlock_irq(&bus->reg_lock);
+
 	hdac_wait_for_cmd_dmas(bus);
+
+	spin_lock_irq(&bus->reg_lock);
 	/* disable unsolicited responses */
 	snd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_UNSOL, 0);
 	spin_unlock_irq(&bus->reg_lock);

commit a5c3b32a1146e44f6b38fdfdfffc27842953420c
Merge: d7dc450d5a71 20d5c84bef06
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 2 08:25:25 2017 +0200

    Merge tag 'asoc-v4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v4.12
    
    A quiet release for the core, but lots of new drivers this time around:
    
     - A new, generalized, API for hooking up jacks which makes it easier to
       write generic machine drivers for simple cases.
     - Continuing fixes for issues with the x86 CPU drivers.
     - New drivers for Cirrus CS35L35, DIO DIO2125, Everest ES7132,
       HiSilicon hi6210, Maxim MAX98927, MT2701 systems with WM8960, Nuvoton
       NAU8824, Odroid systems, ST STM32 SAI controllers and x86 systems with
       DA7213

commit 2c1f81381eadc6dd3c288ec4477b2fe572cf86dc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 29 08:27:15 2017 +0200

    ALSA: hda - Avoid tricky macros
    
    The macros _snd_hdac_chip_read() and *_write() expand to different
    types (b,w,l) per their argument.  They were thought to be used only
    internally for other snd_hdac_chip_*() macros, but in some situations
    we need to call these directly, and they are way too ugly.
    
    Instead of saving a few lines, we just write these macros explicitly
    with the types, so that they can be used in a saner way.
    
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 043065867656..d15b653de0bf 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -272,7 +272,7 @@ int snd_hdac_bus_parse_capabilities(struct hdac_bus *bus)
 
 	/* Lets walk the linked capabilities list */
 	do {
-		cur_cap = _snd_hdac_chip_read(l, bus, offset);
+		cur_cap = _snd_hdac_chip_readl(bus, offset);
 
 		dev_dbg(bus->dev, "Capability version: 0x%x\n",
 			(cur_cap & AZX_CAP_HDR_VER_MASK) >> AZX_CAP_HDR_VER_OFF);

commit ccfdf9f6a47179941cb8b5f1d3df9734e54b38c4
Author: B, Jayachandran <jayachandran.b@intel.com>
Date:   Fri Mar 24 23:10:24 2017 +0530

    ALSA: hda: Fix LLCH register read
    
    LLCH is a 16 bit register. Use readw instead of readl API.
    
    Signed-off-by: B, Jayachandran <jayachandran.b@intel.com>
    Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 043065867656..6f1e99c9fed9 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -268,7 +268,7 @@ int snd_hdac_bus_parse_capabilities(struct hdac_bus *bus)
 	unsigned int offset;
 	unsigned int counter = 0;
 
-	offset = snd_hdac_chip_readl(bus, LLCH);
+	offset = snd_hdac_chip_readw(bus, LLCH);
 
 	/* Lets walk the linked capabilities list */
 	do {

commit 6720b38420a01d40dbeb8ee575eb601d612de691
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Thu Aug 4 15:46:00 2016 +0530

    ALSA: hda - move bus_parse_capabilities to core
    
    HDA capability introduced recently are move to hdac core so that it can
    be used by legacy driver as well. Also move the capability pointers up
    to hdac_bus object.
    
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 9fee464e5d49..043065867656 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -255,6 +255,81 @@ int snd_hdac_bus_get_response(struct hdac_bus *bus, unsigned int addr,
 }
 EXPORT_SYMBOL_GPL(snd_hdac_bus_get_response);
 
+#define HDAC_MAX_CAPS 10
+/**
+ * snd_hdac_bus_parse_capabilities - parse capability structure
+ * @bus: the pointer to bus object
+ *
+ * Returns 0 if successful, or a negative error code.
+ */
+int snd_hdac_bus_parse_capabilities(struct hdac_bus *bus)
+{
+	unsigned int cur_cap;
+	unsigned int offset;
+	unsigned int counter = 0;
+
+	offset = snd_hdac_chip_readl(bus, LLCH);
+
+	/* Lets walk the linked capabilities list */
+	do {
+		cur_cap = _snd_hdac_chip_read(l, bus, offset);
+
+		dev_dbg(bus->dev, "Capability version: 0x%x\n",
+			(cur_cap & AZX_CAP_HDR_VER_MASK) >> AZX_CAP_HDR_VER_OFF);
+
+		dev_dbg(bus->dev, "HDA capability ID: 0x%x\n",
+			(cur_cap & AZX_CAP_HDR_ID_MASK) >> AZX_CAP_HDR_ID_OFF);
+
+		switch ((cur_cap & AZX_CAP_HDR_ID_MASK) >> AZX_CAP_HDR_ID_OFF) {
+		case AZX_ML_CAP_ID:
+			dev_dbg(bus->dev, "Found ML capability\n");
+			bus->mlcap = bus->remap_addr + offset;
+			break;
+
+		case AZX_GTS_CAP_ID:
+			dev_dbg(bus->dev, "Found GTS capability offset=%x\n", offset);
+			bus->gtscap = bus->remap_addr + offset;
+			break;
+
+		case AZX_PP_CAP_ID:
+			/* PP capability found, the Audio DSP is present */
+			dev_dbg(bus->dev, "Found PP capability offset=%x\n", offset);
+			bus->ppcap = bus->remap_addr + offset;
+			break;
+
+		case AZX_SPB_CAP_ID:
+			/* SPIB capability found, handler function */
+			dev_dbg(bus->dev, "Found SPB capability\n");
+			bus->spbcap = bus->remap_addr + offset;
+			break;
+
+		case AZX_DRSM_CAP_ID:
+			/* DMA resume  capability found, handler function */
+			dev_dbg(bus->dev, "Found DRSM capability\n");
+			bus->drsmcap = bus->remap_addr + offset;
+			break;
+
+		default:
+			dev_dbg(bus->dev, "Unknown capability %d\n", cur_cap);
+			break;
+		}
+
+		counter++;
+
+		if (counter > HDAC_MAX_CAPS) {
+			dev_err(bus->dev, "We exceeded HDAC capabilities!!!\n");
+			break;
+		}
+
+		/* read the offset of next capability */
+		offset = cur_cap & AZX_CAP_HDR_NXT_PTR_MASK;
+
+	} while (offset);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_parse_capabilities);
+
 /*
  * Lowlevel interface
  */

commit 38b19ed7f81ec930f3ad2066ae088f574970c814
Author: Jeeja KP <jeeja.kp@intel.com>
Date:   Thu May 5 11:24:43 2016 +0530

    ALSA: hda: fix to wait for RIRB & CORB DMA to set
    
    If the DMAs are not being quiesced properly, it may lead to
    stability issues, so the recommendation is to wait till DMAs are
    stopped.
    
    After setting the stop bit of RIRB/CORB DMA, we should wait for
    stop bit to be set.
    
    Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index 8c486235c905..9fee464e5d49 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -80,6 +80,22 @@ void snd_hdac_bus_init_cmd_io(struct hdac_bus *bus)
 }
 EXPORT_SYMBOL_GPL(snd_hdac_bus_init_cmd_io);
 
+/* wait for cmd dmas till they are stopped */
+static void hdac_wait_for_cmd_dmas(struct hdac_bus *bus)
+{
+	unsigned long timeout;
+
+	timeout = jiffies + msecs_to_jiffies(100);
+	while ((snd_hdac_chip_readb(bus, RIRBCTL) & AZX_RBCTL_DMA_EN)
+		&& time_before(jiffies, timeout))
+		udelay(10);
+
+	timeout = jiffies + msecs_to_jiffies(100);
+	while ((snd_hdac_chip_readb(bus, CORBCTL) & AZX_CORBCTL_RUN)
+		&& time_before(jiffies, timeout))
+		udelay(10);
+}
+
 /**
  * snd_hdac_bus_stop_cmd_io - clean up CORB/RIRB buffers
  * @bus: HD-audio core bus
@@ -90,6 +106,7 @@ void snd_hdac_bus_stop_cmd_io(struct hdac_bus *bus)
 	/* disable ringbuffer DMAs */
 	snd_hdac_chip_writeb(bus, RIRBCTL, 0);
 	snd_hdac_chip_writeb(bus, CORBCTL, 0);
+	hdac_wait_for_cmd_dmas(bus);
 	/* disable unsolicited responses */
 	snd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_UNSOL, 0);
 	spin_unlock_irq(&bus->reg_lock);

commit 473f414564528a819f0c2bb6b4bf26366b64c9ab
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 23 15:54:47 2016 +0100

    ALSA: hda - Loop interrupt handling until really cleared
    
    Currently the interrupt handler of HD-audio driver assumes that no irq
    update is needed while processing the irq.  But in reality, it has
    been confirmed that the HW irq is issued even during the irq
    handling.  Since we clear the irq status at the beginning, process the
    interrupt, then exits from the handler, the lately issued interrupt is
    left untouched without being properly processed.
    
    This patch changes the interrupt handler code to loop over the
    check-and-process.  The handler tries repeatedly as long as the IRQ
    status are turned on, and either stream or CORB/RIRB is handled.
    
    For checking the stream handling, snd_hdac_bus_handle_stream_irq()
    returns a value indicating the stream indices bits.  Other than that,
    the change is only in the irq handler itself.
    
    Reported-by: Libin Yang <libin.yang@linux.intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index b5a17cb510a0..8c486235c905 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -426,18 +426,22 @@ EXPORT_SYMBOL_GPL(snd_hdac_bus_stop_chip);
  * @bus: HD-audio core bus
  * @status: INTSTS register value
  * @ask: callback to be called for woken streams
+ *
+ * Returns the bits of handled streams, or zero if no stream is handled.
  */
-void snd_hdac_bus_handle_stream_irq(struct hdac_bus *bus, unsigned int status,
+int snd_hdac_bus_handle_stream_irq(struct hdac_bus *bus, unsigned int status,
 				    void (*ack)(struct hdac_bus *,
 						struct hdac_stream *))
 {
 	struct hdac_stream *azx_dev;
 	u8 sd_status;
+	int handled = 0;
 
 	list_for_each_entry(azx_dev, &bus->stream_list, list) {
 		if (status & azx_dev->sd_int_sta_mask) {
 			sd_status = snd_hdac_stream_readb(azx_dev, SD_STS);
 			snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);
+			handled |= 1 << azx_dev->index;
 			if (!azx_dev->substream || !azx_dev->running ||
 			    !(sd_status & SD_INT_COMPLETE))
 				continue;
@@ -445,6 +449,7 @@ void snd_hdac_bus_handle_stream_irq(struct hdac_bus *bus, unsigned int status,
 				ack(bus, azx_dev);
 		}
 	}
+	return handled;
 }
 EXPORT_SYMBOL_GPL(snd_hdac_bus_handle_stream_irq);
 

commit 304dad30388d017544bc2e90fe4fefcca94263d3
Author: Jeeja KP <jeeja.kp@intel.com>
Date:   Sun Apr 12 18:06:13 2015 +0530

    ALSA: hda - moved alloc/free stream pages function to controller library
    
    Moved azx_alloc_stream_pages and azx_free_stream_pages
    to controller library.
    
    Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
    Signed-off-by: Subhransu S. Prusty <subhransu.s.prusty@intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
index c0069d0b7875..b5a17cb510a0 100644
--- a/sound/hda/hdac_controller.c
+++ b/sound/hda/hdac_controller.c
@@ -447,3 +447,61 @@ void snd_hdac_bus_handle_stream_irq(struct hdac_bus *bus, unsigned int status,
 	}
 }
 EXPORT_SYMBOL_GPL(snd_hdac_bus_handle_stream_irq);
+
+/**
+ * snd_hdac_bus_alloc_stream_pages - allocate BDL and other buffers
+ * @bus: HD-audio core bus
+ *
+ * Call this after assigning the all streams.
+ * Returns zero for success, or a negative error code.
+ */
+int snd_hdac_bus_alloc_stream_pages(struct hdac_bus *bus)
+{
+	struct hdac_stream *s;
+	int num_streams = 0;
+	int err;
+
+	list_for_each_entry(s, &bus->stream_list, list) {
+		/* allocate memory for the BDL for each stream */
+		err = bus->io_ops->dma_alloc_pages(bus, SNDRV_DMA_TYPE_DEV,
+						   BDL_SIZE, &s->bdl);
+		num_streams++;
+		if (err < 0)
+			return -ENOMEM;
+	}
+
+	if (WARN_ON(!num_streams))
+		return -EINVAL;
+	/* allocate memory for the position buffer */
+	err = bus->io_ops->dma_alloc_pages(bus, SNDRV_DMA_TYPE_DEV,
+					   num_streams * 8, &bus->posbuf);
+	if (err < 0)
+		return -ENOMEM;
+	list_for_each_entry(s, &bus->stream_list, list)
+		s->posbuf = (__le32 *)(bus->posbuf.area + s->index * 8);
+
+	/* single page (at least 4096 bytes) must suffice for both ringbuffes */
+	return bus->io_ops->dma_alloc_pages(bus, SNDRV_DMA_TYPE_DEV,
+					    PAGE_SIZE, &bus->rb);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_alloc_stream_pages);
+
+/**
+ * snd_hdac_bus_free_stream_pages - release BDL and other buffers
+ * @bus: HD-audio core bus
+ */
+void snd_hdac_bus_free_stream_pages(struct hdac_bus *bus)
+{
+	struct hdac_stream *s;
+
+	list_for_each_entry(s, &bus->stream_list, list) {
+		if (s->bdl.area)
+			bus->io_ops->dma_free_pages(bus, &s->bdl);
+	}
+
+	if (bus->rb.area)
+		bus->io_ops->dma_free_pages(bus, &bus->rb);
+	if (bus->posbuf.area)
+		bus->io_ops->dma_free_pages(bus, &bus->posbuf);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_free_stream_pages);

commit 14752412721c61d9ac1e8d8fb51d7148cb15f85b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 14 12:15:47 2015 +0200

    ALSA: hda - Add the controller helper codes to hda-core module
    
    This patch adds the controller helper codes to hda-core library.
    The I/O access ops are added to the bus ops.  The CORB/RIRB, the basic
    attributes like irq# and iomap address, some locks and the list of
    streams are added to the bus object, together with the stream object
    and its helpers.
    
    Currently the codes are just copied from the legacy driver, so you can
    find duplicated codes in both directories.  Only constants are removed
    from the original hda_controller.h.  More integration work will follow
    in the later patches.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_controller.c b/sound/hda/hdac_controller.c
new file mode 100644
index 000000000000..c0069d0b7875
--- /dev/null
+++ b/sound/hda/hdac_controller.c
@@ -0,0 +1,449 @@
+/*
+ * HD-audio controller helpers
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/export.h>
+#include <sound/core.h>
+#include <sound/hdaudio.h>
+#include <sound/hda_register.h>
+
+/* clear CORB read pointer properly */
+static void azx_clear_corbrp(struct hdac_bus *bus)
+{
+	int timeout;
+
+	for (timeout = 1000; timeout > 0; timeout--) {
+		if (snd_hdac_chip_readw(bus, CORBRP) & AZX_CORBRP_RST)
+			break;
+		udelay(1);
+	}
+	if (timeout <= 0)
+		dev_err(bus->dev, "CORB reset timeout#1, CORBRP = %d\n",
+			snd_hdac_chip_readw(bus, CORBRP));
+
+	snd_hdac_chip_writew(bus, CORBRP, 0);
+	for (timeout = 1000; timeout > 0; timeout--) {
+		if (snd_hdac_chip_readw(bus, CORBRP) == 0)
+			break;
+		udelay(1);
+	}
+	if (timeout <= 0)
+		dev_err(bus->dev, "CORB reset timeout#2, CORBRP = %d\n",
+			snd_hdac_chip_readw(bus, CORBRP));
+}
+
+/**
+ * snd_hdac_bus_init_cmd_io - set up CORB/RIRB buffers
+ * @bus: HD-audio core bus
+ */
+void snd_hdac_bus_init_cmd_io(struct hdac_bus *bus)
+{
+	spin_lock_irq(&bus->reg_lock);
+	/* CORB set up */
+	bus->corb.addr = bus->rb.addr;
+	bus->corb.buf = (__le32 *)bus->rb.area;
+	snd_hdac_chip_writel(bus, CORBLBASE, (u32)bus->corb.addr);
+	snd_hdac_chip_writel(bus, CORBUBASE, upper_32_bits(bus->corb.addr));
+
+	/* set the corb size to 256 entries (ULI requires explicitly) */
+	snd_hdac_chip_writeb(bus, CORBSIZE, 0x02);
+	/* set the corb write pointer to 0 */
+	snd_hdac_chip_writew(bus, CORBWP, 0);
+
+	/* reset the corb hw read pointer */
+	snd_hdac_chip_writew(bus, CORBRP, AZX_CORBRP_RST);
+	if (!bus->corbrp_self_clear)
+		azx_clear_corbrp(bus);
+
+	/* enable corb dma */
+	snd_hdac_chip_writeb(bus, CORBCTL, AZX_CORBCTL_RUN);
+
+	/* RIRB set up */
+	bus->rirb.addr = bus->rb.addr + 2048;
+	bus->rirb.buf = (__le32 *)(bus->rb.area + 2048);
+	bus->rirb.wp = bus->rirb.rp = 0;
+	memset(bus->rirb.cmds, 0, sizeof(bus->rirb.cmds));
+	snd_hdac_chip_writel(bus, RIRBLBASE, (u32)bus->rirb.addr);
+	snd_hdac_chip_writel(bus, RIRBUBASE, upper_32_bits(bus->rirb.addr));
+
+	/* set the rirb size to 256 entries (ULI requires explicitly) */
+	snd_hdac_chip_writeb(bus, RIRBSIZE, 0x02);
+	/* reset the rirb hw write pointer */
+	snd_hdac_chip_writew(bus, RIRBWP, AZX_RIRBWP_RST);
+	/* set N=1, get RIRB response interrupt for new entry */
+	snd_hdac_chip_writew(bus, RINTCNT, 1);
+	/* enable rirb dma and response irq */
+	snd_hdac_chip_writeb(bus, RIRBCTL, AZX_RBCTL_DMA_EN | AZX_RBCTL_IRQ_EN);
+	spin_unlock_irq(&bus->reg_lock);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_init_cmd_io);
+
+/**
+ * snd_hdac_bus_stop_cmd_io - clean up CORB/RIRB buffers
+ * @bus: HD-audio core bus
+ */
+void snd_hdac_bus_stop_cmd_io(struct hdac_bus *bus)
+{
+	spin_lock_irq(&bus->reg_lock);
+	/* disable ringbuffer DMAs */
+	snd_hdac_chip_writeb(bus, RIRBCTL, 0);
+	snd_hdac_chip_writeb(bus, CORBCTL, 0);
+	/* disable unsolicited responses */
+	snd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_UNSOL, 0);
+	spin_unlock_irq(&bus->reg_lock);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_stop_cmd_io);
+
+static unsigned int azx_command_addr(u32 cmd)
+{
+	unsigned int addr = cmd >> 28;
+
+	if (snd_BUG_ON(addr >= HDA_MAX_CODECS))
+		addr = 0;
+	return addr;
+}
+
+/**
+ * snd_hdac_bus_send_cmd - send a command verb via CORB
+ * @bus: HD-audio core bus
+ * @val: encoded verb value to send
+ *
+ * Returns zero for success or a negative error code.
+ */
+int snd_hdac_bus_send_cmd(struct hdac_bus *bus, unsigned int val)
+{
+	unsigned int addr = azx_command_addr(val);
+	unsigned int wp, rp;
+
+	spin_lock_irq(&bus->reg_lock);
+
+	bus->last_cmd[azx_command_addr(val)] = val;
+
+	/* add command to corb */
+	wp = snd_hdac_chip_readw(bus, CORBWP);
+	if (wp == 0xffff) {
+		/* something wrong, controller likely turned to D3 */
+		spin_unlock_irq(&bus->reg_lock);
+		return -EIO;
+	}
+	wp++;
+	wp %= AZX_MAX_CORB_ENTRIES;
+
+	rp = snd_hdac_chip_readw(bus, CORBRP);
+	if (wp == rp) {
+		/* oops, it's full */
+		spin_unlock_irq(&bus->reg_lock);
+		return -EAGAIN;
+	}
+
+	bus->rirb.cmds[addr]++;
+	bus->corb.buf[wp] = cpu_to_le32(val);
+	snd_hdac_chip_writew(bus, CORBWP, wp);
+
+	spin_unlock_irq(&bus->reg_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_send_cmd);
+
+#define AZX_RIRB_EX_UNSOL_EV	(1<<4)
+
+/**
+ * snd_hdac_bus_update_rirb - retrieve RIRB entries
+ * @bus: HD-audio core bus
+ *
+ * Usually called from interrupt handler.
+ */
+void snd_hdac_bus_update_rirb(struct hdac_bus *bus)
+{
+	unsigned int rp, wp;
+	unsigned int addr;
+	u32 res, res_ex;
+
+	wp = snd_hdac_chip_readw(bus, RIRBWP);
+	if (wp == 0xffff) {
+		/* something wrong, controller likely turned to D3 */
+		return;
+	}
+
+	if (wp == bus->rirb.wp)
+		return;
+	bus->rirb.wp = wp;
+
+	while (bus->rirb.rp != wp) {
+		bus->rirb.rp++;
+		bus->rirb.rp %= AZX_MAX_RIRB_ENTRIES;
+
+		rp = bus->rirb.rp << 1; /* an RIRB entry is 8-bytes */
+		res_ex = le32_to_cpu(bus->rirb.buf[rp + 1]);
+		res = le32_to_cpu(bus->rirb.buf[rp]);
+		addr = res_ex & 0xf;
+		if (addr >= HDA_MAX_CODECS) {
+			dev_err(bus->dev,
+				"spurious response %#x:%#x, rp = %d, wp = %d",
+				res, res_ex, bus->rirb.rp, wp);
+			snd_BUG();
+		} else if (res_ex & AZX_RIRB_EX_UNSOL_EV)
+			snd_hdac_bus_queue_event(bus, res, res_ex);
+		else if (bus->rirb.cmds[addr]) {
+			bus->rirb.res[addr] = res;
+			bus->rirb.cmds[addr]--;
+		} else {
+			dev_err_ratelimited(bus->dev,
+				"spurious response %#x:%#x, last cmd=%#08x\n",
+				res, res_ex, bus->last_cmd[addr]);
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_update_rirb);
+
+/**
+ * snd_hdac_bus_get_response - receive a response via RIRB
+ * @bus: HD-audio core bus
+ * @addr: codec address
+ * @res: pointer to store the value, NULL when not needed
+ *
+ * Returns zero if a value is read, or a negative error code.
+ */
+int snd_hdac_bus_get_response(struct hdac_bus *bus, unsigned int addr,
+			      unsigned int *res)
+{
+	unsigned long timeout;
+	unsigned long loopcounter;
+
+	timeout = jiffies + msecs_to_jiffies(1000);
+
+	for (loopcounter = 0;; loopcounter++) {
+		spin_lock_irq(&bus->reg_lock);
+		if (!bus->rirb.cmds[addr]) {
+			if (res)
+				*res = bus->rirb.res[addr]; /* the last value */
+			spin_unlock_irq(&bus->reg_lock);
+			return 0;
+		}
+		spin_unlock_irq(&bus->reg_lock);
+		if (time_after(jiffies, timeout))
+			break;
+		if (loopcounter > 3000)
+			msleep(2); /* temporary workaround */
+		else {
+			udelay(10);
+			cond_resched();
+		}
+	}
+
+	return -EIO;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_get_response);
+
+/*
+ * Lowlevel interface
+ */
+
+/**
+ * snd_hdac_bus_enter_link_reset - enter link reset
+ * @bus: HD-audio core bus
+ *
+ * Enter to the link reset state.
+ */
+void snd_hdac_bus_enter_link_reset(struct hdac_bus *bus)
+{
+	unsigned long timeout;
+
+	/* reset controller */
+	snd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_RESET, 0);
+
+	timeout = jiffies + msecs_to_jiffies(100);
+	while ((snd_hdac_chip_readb(bus, GCTL) & AZX_GCTL_RESET) &&
+	       time_before(jiffies, timeout))
+		usleep_range(500, 1000);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_enter_link_reset);
+
+/**
+ * snd_hdac_bus_exit_link_reset - exit link reset
+ * @bus: HD-audio core bus
+ *
+ * Exit from the link reset state.
+ */
+void snd_hdac_bus_exit_link_reset(struct hdac_bus *bus)
+{
+	unsigned long timeout;
+
+	snd_hdac_chip_updateb(bus, GCTL, 0, AZX_GCTL_RESET);
+
+	timeout = jiffies + msecs_to_jiffies(100);
+	while (!snd_hdac_chip_readb(bus, GCTL) && time_before(jiffies, timeout))
+		usleep_range(500, 1000);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_exit_link_reset);
+
+/* reset codec link */
+static int azx_reset(struct hdac_bus *bus, bool full_reset)
+{
+	if (!full_reset)
+		goto skip_reset;
+
+	/* clear STATESTS */
+	snd_hdac_chip_writew(bus, STATESTS, STATESTS_INT_MASK);
+
+	/* reset controller */
+	snd_hdac_bus_enter_link_reset(bus);
+
+	/* delay for >= 100us for codec PLL to settle per spec
+	 * Rev 0.9 section 5.5.1
+	 */
+	usleep_range(500, 1000);
+
+	/* Bring controller out of reset */
+	snd_hdac_bus_exit_link_reset(bus);
+
+	/* Brent Chartrand said to wait >= 540us for codecs to initialize */
+	usleep_range(1000, 1200);
+
+ skip_reset:
+	/* check to see if controller is ready */
+	if (!snd_hdac_chip_readb(bus, GCTL)) {
+		dev_dbg(bus->dev, "azx_reset: controller not ready!\n");
+		return -EBUSY;
+	}
+
+	/* Accept unsolicited responses */
+	snd_hdac_chip_updatel(bus, GCTL, 0, AZX_GCTL_UNSOL);
+
+	/* detect codecs */
+	if (!bus->codec_mask) {
+		bus->codec_mask = snd_hdac_chip_readw(bus, STATESTS);
+		dev_dbg(bus->dev, "codec_mask = 0x%lx\n", bus->codec_mask);
+	}
+
+	return 0;
+}
+
+/* enable interrupts */
+static void azx_int_enable(struct hdac_bus *bus)
+{
+	/* enable controller CIE and GIE */
+	snd_hdac_chip_updatel(bus, INTCTL, 0, AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN);
+}
+
+/* disable interrupts */
+static void azx_int_disable(struct hdac_bus *bus)
+{
+	struct hdac_stream *azx_dev;
+
+	/* disable interrupts in stream descriptor */
+	list_for_each_entry(azx_dev, &bus->stream_list, list)
+		snd_hdac_stream_updateb(azx_dev, SD_CTL, SD_INT_MASK, 0);
+
+	/* disable SIE for all streams */
+	snd_hdac_chip_writeb(bus, INTCTL, 0);
+
+	/* disable controller CIE and GIE */
+	snd_hdac_chip_updatel(bus, INTCTL, AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN, 0);
+}
+
+/* clear interrupts */
+static void azx_int_clear(struct hdac_bus *bus)
+{
+	struct hdac_stream *azx_dev;
+
+	/* clear stream status */
+	list_for_each_entry(azx_dev, &bus->stream_list, list)
+		snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);
+
+	/* clear STATESTS */
+	snd_hdac_chip_writew(bus, STATESTS, STATESTS_INT_MASK);
+
+	/* clear rirb status */
+	snd_hdac_chip_writeb(bus, RIRBSTS, RIRB_INT_MASK);
+
+	/* clear int status */
+	snd_hdac_chip_writel(bus, INTSTS, AZX_INT_CTRL_EN | AZX_INT_ALL_STREAM);
+}
+
+/**
+ * snd_hdac_bus_init_chip - reset and start the controller registers
+ * @bus: HD-audio core bus
+ * @full_reset: Do full reset
+ */
+bool snd_hdac_bus_init_chip(struct hdac_bus *bus, bool full_reset)
+{
+	if (bus->chip_init)
+		return false;
+
+	/* reset controller */
+	azx_reset(bus, full_reset);
+
+	/* initialize interrupts */
+	azx_int_clear(bus);
+	azx_int_enable(bus);
+
+	/* initialize the codec command I/O */
+	snd_hdac_bus_init_cmd_io(bus);
+
+	/* program the position buffer */
+	if (bus->use_posbuf && bus->posbuf.addr) {
+		snd_hdac_chip_writel(bus, DPLBASE, (u32)bus->posbuf.addr);
+		snd_hdac_chip_writel(bus, DPUBASE, upper_32_bits(bus->posbuf.addr));
+	}
+
+	bus->chip_init = true;
+	return true;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_init_chip);
+
+/**
+ * snd_hdac_bus_stop_chip - disable the whole IRQ and I/Os
+ * @bus: HD-audio core bus
+ */
+void snd_hdac_bus_stop_chip(struct hdac_bus *bus)
+{
+	if (!bus->chip_init)
+		return;
+
+	/* disable interrupts */
+	azx_int_disable(bus);
+	azx_int_clear(bus);
+
+	/* disable CORB/RIRB */
+	snd_hdac_bus_stop_cmd_io(bus);
+
+	/* disable position buffer */
+	if (bus->posbuf.addr) {
+		snd_hdac_chip_writel(bus, DPLBASE, 0);
+		snd_hdac_chip_writel(bus, DPUBASE, 0);
+	}
+
+	bus->chip_init = false;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_stop_chip);
+
+/**
+ * snd_hdac_bus_handle_stream_irq - interrupt handler for streams
+ * @bus: HD-audio core bus
+ * @status: INTSTS register value
+ * @ask: callback to be called for woken streams
+ */
+void snd_hdac_bus_handle_stream_irq(struct hdac_bus *bus, unsigned int status,
+				    void (*ack)(struct hdac_bus *,
+						struct hdac_stream *))
+{
+	struct hdac_stream *azx_dev;
+	u8 sd_status;
+
+	list_for_each_entry(azx_dev, &bus->stream_list, list) {
+		if (status & azx_dev->sd_int_sta_mask) {
+			sd_status = snd_hdac_stream_readb(azx_dev, SD_STS);
+			snd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);
+			if (!azx_dev->substream || !azx_dev->running ||
+			    !(sd_status & SD_INT_COMPLETE))
+				continue;
+			if (ack)
+				ack(bus, azx_dev);
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_handle_stream_irq);
