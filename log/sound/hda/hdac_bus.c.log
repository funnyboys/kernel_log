commit b9f2d35f05308813c4c887d5c530004f01e1829c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat May 16 08:28:54 2020 +0200

    ALSA: hda: Unexport some local helper functions
    
    snd_hdac_bus_queue_event() and snd_hdac_bus_exec_verb() are used only
    internally in HD-audio core.  Let's drop the exports and move the
    declarations into local.h.
    
    Link: https://lore.kernel.org/r/20200516062854.22141-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index dee04792ca86..09ddab5f5cae 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -81,7 +81,6 @@ int snd_hdac_bus_exec_verb(struct hdac_bus *bus, unsigned int addr,
 	mutex_unlock(&bus->cmd_mutex);
 	return err;
 }
-EXPORT_SYMBOL_GPL(snd_hdac_bus_exec_verb);
 
 /**
  * snd_hdac_bus_exec_verb_unlocked - unlocked version
@@ -150,7 +149,6 @@ void snd_hdac_bus_queue_event(struct hdac_bus *bus, u32 res, u32 res_ex)
 
 	schedule_work(&bus->unsol_work);
 }
-EXPORT_SYMBOL_GPL(snd_hdac_bus_queue_event);
 
 /*
  * process queued unsolicited events

commit c637fa151259c0f74665fde7cba5b7eac1417ae5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat May 16 08:25:56 2020 +0200

    ALSA: hda: Fix potential race in unsol event handler
    
    The unsol event handling code has a loop retrieving the read/write
    indices and the arrays without locking while the append to the array
    may happen concurrently.  This may lead to some inconsistency.
    Although there hasn't been any proof of this bad results, it's still
    safer to protect the racy accesses.
    
    This patch adds the spinlock protection around the unsol handling loop
    for addressing it.  Here we take bus->reg_lock as the writer side
    snd_hdac_bus_queue_event() is also protected by that lock.
    
    Link: https://lore.kernel.org/r/20200516062556.30951-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index 3fe62be1cbcc..dee04792ca86 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -162,6 +162,7 @@ static void snd_hdac_bus_process_unsol_events(struct work_struct *work)
 	struct hdac_driver *drv;
 	unsigned int rp, caddr, res;
 
+	spin_lock_irq(&bus->reg_lock);
 	while (bus->unsol_rp != bus->unsol_wp) {
 		rp = (bus->unsol_rp + 1) % HDA_UNSOL_QUEUE_SIZE;
 		bus->unsol_rp = rp;
@@ -173,10 +174,13 @@ static void snd_hdac_bus_process_unsol_events(struct work_struct *work)
 		codec = bus->caddr_tbl[caddr & 0x0f];
 		if (!codec || !codec->dev.driver)
 			continue;
+		spin_unlock_irq(&bus->reg_lock);
 		drv = drv_to_hdac_driver(codec->dev.driver);
 		if (drv->unsol_event)
 			drv->unsol_event(codec, res);
+		spin_lock_irq(&bus->reg_lock);
 	}
+	spin_unlock_irq(&bus->reg_lock);
 }
 
 /**

commit 6e57188f20ecf33185b671cff1af305d8f3bb2fe
Author: Keyon Jie <yang.jie@linux.intel.com>
Date:   Mon Jan 13 14:56:38 2020 -0600

    ALSA: hda: Update kernel-doc function parameter descriptions
    
    Make W=1 throws a lot of warnings, with multiple misalignments between
    function params and their descriptions.
    
    Signed-off-by: Keyon Jie <yang.jie@linux.intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Link: https://lore.kernel.org/r/20200113205638.27338-1-pierre-louis.bossart@linux.intel.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index 48b227fff204..3fe62be1cbcc 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -22,6 +22,7 @@ static const struct hdac_bus_ops default_ops = {
 /**
  * snd_hdac_bus_init - initialize a HD-audio bas bus
  * @bus: the pointer to bus object
+ * @dev: device pointer
  * @ops: bus verb operators
  *
  * Returns 0 if successful, or a negative error code.
@@ -64,6 +65,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_bus_exit);
 /**
  * snd_hdac_bus_exec_verb - execute a HD-audio verb on the given bus
  * @bus: bus object
+ * @addr: the HDAC device address
  * @cmd: HD-audio encoded verb
  * @res: pointer to store the response, NULL if performing asynchronously
  *
@@ -84,6 +86,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_bus_exec_verb);
 /**
  * snd_hdac_bus_exec_verb_unlocked - unlocked version
  * @bus: bus object
+ * @addr: the HDAC device address
  * @cmd: HD-audio encoded verb
  * @res: pointer to store the response, NULL if performing asynchronously
  *

commit 88452da92ba2b264a3922218c2cec13aac51c502
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 15:57:27 2019 +0100

    ALSA: hda: Use standard waitqueue for RIRB wakeup
    
    The HD-audio CORB/RIRB communication was programmed in a way that was
    documented in the reference in decades ago, which is essentially a
    polling in the waiter side.  It's working fine but costs CPU cycles on
    some platforms that support only slow communications.  Also, for some
    platforms that had unreliable communications, we put longer wait time
    (2 ms), which accumulate quite long time if you execute many verbs in
    a shot (e.g. at the initialization or resume phase).
    
    This patch attempts to improve the situation by introducing the
    standard waitqueue in the RIRB waiter side instead of polling.  The
    test results on my machine show significant improvements.  The time
    spent for "cat /proc/asound/card*/codec#*" were changed like:
    
    * Intel SKL + Realtek codec
      before the patch:
       0.00user 0.04system 0:00.10elapsed 40.0%CPU
      after the patch:
       0.00user 0.01system 0:00.10elapsed 10.0%CPU
    
    * Nvidia GP107GL + Nvidia HDMI codec
      before the patch:
       0.00user 0.00system 0:02.76elapsed 0.0%CPU
      after the patch:
       0.00user 0.00system 0:00.01elapsed 17.0%CPU
    
    So, for Intel chips, the total time is same, while the total time is
    greatly reduced (from 2.76 to 0.01s) for Nvidia chips.
    The only negative data here is the increase of CPU time for Nvidia,
    but this is the unavoidable cost for faster wakeups, supposedly.
    
    Link: https://lore.kernel.org/r/20191210145727.22054-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index 8f19876244eb..48b227fff204 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -43,6 +43,7 @@ int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,
 	mutex_init(&bus->cmd_mutex);
 	mutex_init(&bus->lock);
 	INIT_LIST_HEAD(&bus->hlink_list);
+	init_waitqueue_head(&bus->rirb_wq);
 	bus->irq = -1;
 	return 0;
 }

commit ddf7cb83b0f45feb94ad89a987f600c766c463ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 14 19:59:44 2019 +0200

    ALSA: hda: Unexport a few more stuff
    
    Drop EXPORT_SYMBOL*() from a few more stuff in HD-audio core that
    aren't used outside.  Particular the unsol event handler can be
    staticized now because the recent change removed all external
    callers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index 18ed3185df82..8f19876244eb 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -12,6 +12,8 @@
 #include "local.h"
 #include "trace.h"
 
+static void snd_hdac_bus_process_unsol_events(struct work_struct *work);
+
 static const struct hdac_bus_ops default_ops = {
 	.command = snd_hdac_bus_send_cmd,
 	.get_response = snd_hdac_bus_get_response,
@@ -149,7 +151,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_bus_queue_event);
 /*
  * process queued unsolicited events
  */
-void snd_hdac_bus_process_unsol_events(struct work_struct *work)
+static void snd_hdac_bus_process_unsol_events(struct work_struct *work)
 {
 	struct hdac_bus *bus = container_of(work, struct hdac_bus, unsol_work);
 	struct hdac_device *codec;
@@ -172,7 +174,6 @@ void snd_hdac_bus_process_unsol_events(struct work_struct *work)
 			drv->unsol_event(codec, res);
 	}
 }
-EXPORT_SYMBOL_GPL(snd_hdac_bus_process_unsol_events);
 
 /**
  * snd_hdac_bus_add_device - Add a codec to bus

commit 53eff75e5f4dd4b9bc489955fdc60fde48d85e93
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 14 18:27:08 2019 +0200

    ALSA: hda: Drop export of snd_hdac_bus_add/remove_device()
    
    snd_hdac_bus_add_device() and snd_hdac_remove_device() are called only
    internally in hda-core.  Let's drop the exports of them and move the
    declarations into local.h.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index cd25e2b3f7f2..18ed3185df82 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/export.h>
 #include <sound/hdaudio.h>
+#include "local.h"
 #include "trace.h"
 
 static const struct hdac_bus_ops default_ops = {
@@ -196,7 +197,6 @@ int snd_hdac_bus_add_device(struct hdac_bus *bus, struct hdac_device *codec)
 	bus->num_codecs++;
 	return 0;
 }
-EXPORT_SYMBOL_GPL(snd_hdac_bus_add_device);
 
 /**
  * snd_hdac_bus_remove_device - Remove a codec from bus
@@ -215,7 +215,6 @@ void snd_hdac_bus_remove_device(struct hdac_bus *bus,
 	bus->num_codecs--;
 	flush_work(&bus->unsol_work);
 }
-EXPORT_SYMBOL_GPL(snd_hdac_bus_remove_device);
 
 #ifdef CONFIG_SND_HDA_ALIGNED_MMIO
 /* Helpers for aligned read/write of mmio space, for Tegra */

commit fe4010667741df8c8d6bef1780ec34ebf43cf007
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Fri Aug 9 12:54:58 2019 +1000

    ALSA: hda: readl/writel need linux/io.h
    
    Fixes: 19abfefd4c76 ("ALSA: hda: Direct MMIO accesses")
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index dc2523ef7d98..cd25e2b3f7f2 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -4,6 +4,7 @@
  */
 
 #include <linux/init.h>
+#include <linux/io.h>
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/export.h>

commit 19abfefd4c7604993d1c31e098a3f48bdafe334d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 7 20:32:08 2019 +0200

    ALSA: hda: Direct MMIO accesses
    
    HD-audio drivers access to the mmio registers indirectly via the
    corresponding bus->io_ops callbacks.  This is because some platform
    (notably Tegra SoC) requires the word-aligned access.  But it's rather
    a rare case, and other platforms suffer from the penalties by indirect
    calls unnecessarily.
    
    This patch is an attempt to optimize and cleanup for this situation.
    Now the special aligned access is used only when a new kconfig
    CONFIG_SND_HDA_ALIGNED_MMIO is set.  And the HD-audio core itself
    provides the aligned MMIO access helpers instead of the driver side.
    If Kconfig isn't set (as default), the standard helpers like readl()
    or writel() are used directly.
    
    A couple of places in ASoC Intel drivers have the access via io_ops
    reg_writel(), and they are replaced with the direct writel() calls.
    
    And now with this patch, the whole bus->io_ops becomes empty, so it's
    dropped completely.  The bus initialization functions are changed
    accordingly as well to drop the whole bus->io_ops.
    
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index 00ea12e67dc8..dc2523ef7d98 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -19,13 +19,11 @@ static const struct hdac_bus_ops default_ops = {
  * snd_hdac_bus_init - initialize a HD-audio bas bus
  * @bus: the pointer to bus object
  * @ops: bus verb operators
- * @io_ops: lowlevel I/O operators
  *
  * Returns 0 if successful, or a negative error code.
  */
 int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,
-		      const struct hdac_bus_ops *ops,
-		      const struct hdac_io_ops *io_ops)
+		      const struct hdac_bus_ops *ops)
 {
 	memset(bus, 0, sizeof(*bus));
 	bus->dev = dev;
@@ -33,7 +31,6 @@ int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,
 		bus->ops = ops;
 	else
 		bus->ops = &default_ops;
-	bus->io_ops = io_ops;
 	bus->dma_type = SNDRV_DMA_TYPE_DEV;
 	INIT_LIST_HEAD(&bus->stream_list);
 	INIT_LIST_HEAD(&bus->codec_list);
@@ -218,3 +215,33 @@ void snd_hdac_bus_remove_device(struct hdac_bus *bus,
 	flush_work(&bus->unsol_work);
 }
 EXPORT_SYMBOL_GPL(snd_hdac_bus_remove_device);
+
+#ifdef CONFIG_SND_HDA_ALIGNED_MMIO
+/* Helpers for aligned read/write of mmio space, for Tegra */
+unsigned int snd_hdac_aligned_read(void __iomem *addr, unsigned int mask)
+{
+	void __iomem *aligned_addr =
+		(void __iomem *)((unsigned long)(addr) & ~0x3);
+	unsigned int shift = ((unsigned long)(addr) & 0x3) << 3;
+	unsigned int v;
+
+	v = readl(aligned_addr);
+	return (v >> shift) & mask;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_aligned_read);
+
+void snd_hdac_aligned_write(unsigned int val, void __iomem *addr,
+			    unsigned int mask)
+{
+	void __iomem *aligned_addr =
+		(void __iomem *)((unsigned long)(addr) & ~0x3);
+	unsigned int shift = ((unsigned long)(addr) & 0x3) << 3;
+	unsigned int v;
+
+	v = readl(aligned_addr);
+	v &= ~(mask << shift);
+	v |= val << shift;
+	writel(v, aligned_addr);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_aligned_write);
+#endif /* CONFIG_SND_HDA_ALIGNED_MMIO */

commit 619a1f195f93276dc8c6e33fe057e007adc9c288
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 7 20:02:31 2019 +0200

    ALSA: hda: Remove page allocation redirection
    
    The HD-audio core allocates and releases pages via driver's specific
    dma_alloc_pages and dma_free_pages ops defined in bus->io_ops.  This
    was because some platforms require the uncached pages and the handling
    of page flags had to be done locally in the driver code.
    
    Since the recent change in ALSA core memory allocator, we can simply
    pass SNDRV_DMA_TYPE_DEV_UC for the uncached pages, and the only
    difference became about this type to be passed to the core allocator.
    That is, it's good time for cleaning up the mess.
    
    This patch changes the allocation code in HD-audio core to call the
    core allocator directly so that we get rid of dma_alloc_pages and
    dma_free_pages io_ops.  If a driver needs the uncached pages, it has
    to set bus->dma_type right after the bus initialization.
    
    This is merely a code refactoring and shouldn't bring any behavior
    changes.
    
    Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index 14e57ffd5bc1..00ea12e67dc8 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -34,6 +34,7 @@ int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,
 	else
 		bus->ops = &default_ops;
 	bus->io_ops = io_ops;
+	bus->dma_type = SNDRV_DMA_TYPE_DEV;
 	INIT_LIST_HEAD(&bus->stream_list);
 	INIT_LIST_HEAD(&bus->codec_list);
 	INIT_WORK(&bus->unsol_work, snd_hdac_bus_process_unsol_events);

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index 10e5d261fde1..14e57ffd5bc1 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * HD-audio core bus driver
  */

commit e61ab9f017493ef42f0374a578b2758c30f41f74
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 10 16:00:54 2019 +0200

    ALSA: hda: Initialize ext-bus-specific fields in snd_hdac_bus_init(), too
    
    Some fields in snd_hdac_bus are ext-bus specific, but they still
    should be initialized in snd_hdac_bus_init() for consistency, at
    least, for the ones that do need the explicit initialization like the
    list head.
    
    Also move the lock field to the more appropriate place and correct the
    comment to reflect the recent change where it serves for both the
    display power and the link management.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index ad8eee08013f..10e5d261fde1 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -39,6 +39,7 @@ int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,
 	spin_lock_init(&bus->reg_lock);
 	mutex_init(&bus->cmd_mutex);
 	mutex_init(&bus->lock);
+	INIT_LIST_HEAD(&bus->hlink_list);
 	bus->irq = -1;
 	return 0;
 }

commit d7a181da2dfa3190487c446042ba01e07d851c74
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 10 12:49:55 2019 +0200

    ALSA: hda: Fix racy display power access
    
    snd_hdac_display_power() doesn't handle the concurrent calls carefully
    enough, and it may lead to the doubly get_power or put_power calls,
    when a runtime PM and an async work get called in racy way.
    
    This patch addresses it by reusing the bus->lock mutex that has been
    used for protecting the link state change in ext bus code, so that it
    can protect against racy display state changes.  The initialization of
    bus->lock was moved from snd_hdac_ext_bus_init() to
    snd_hdac_bus_init() as well accordingly.
    
    Testcase: igt/i915_pm_rpm/module-reload #glk-dsi
    Reported-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index 012305177f68..ad8eee08013f 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -38,6 +38,7 @@ int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,
 	INIT_WORK(&bus->unsol_work, snd_hdac_bus_process_unsol_events);
 	spin_lock_init(&bus->reg_lock);
 	mutex_init(&bus->cmd_mutex);
+	mutex_init(&bus->lock);
 	bus->irq = -1;
 	return 0;
 }

commit 18d43c9b88eb335440c5e769eb6c2d5bc908dc61
Author: Keyon Jie <yang.jie@linux.intel.com>
Date:   Tue Dec 11 15:30:27 2018 -0600

    ALSA: HDA: export process_unsol_events()
    
    The SOF implementation does not rely on the hdac_bus library, however
    for HDMI and HDaudio codec support it does need to deal with
    unsolicited events. Instead of re-inventing the wheel, export this
    symbol to reuse this part of the library directly.
    
    Signed-off-by: Keyon Jie <yang.jie@linux.intel.com>
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index 714a51721a31..012305177f68 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -9,8 +9,6 @@
 #include <sound/hdaudio.h>
 #include "trace.h"
 
-static void process_unsol_events(struct work_struct *work);
-
 static const struct hdac_bus_ops default_ops = {
 	.command = snd_hdac_bus_send_cmd,
 	.get_response = snd_hdac_bus_get_response,
@@ -37,7 +35,7 @@ int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,
 	bus->io_ops = io_ops;
 	INIT_LIST_HEAD(&bus->stream_list);
 	INIT_LIST_HEAD(&bus->codec_list);
-	INIT_WORK(&bus->unsol_work, process_unsol_events);
+	INIT_WORK(&bus->unsol_work, snd_hdac_bus_process_unsol_events);
 	spin_lock_init(&bus->reg_lock);
 	mutex_init(&bus->cmd_mutex);
 	bus->irq = -1;
@@ -148,7 +146,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_bus_queue_event);
 /*
  * process queued unsolicited events
  */
-static void process_unsol_events(struct work_struct *work)
+void snd_hdac_bus_process_unsol_events(struct work_struct *work)
 {
 	struct hdac_bus *bus = container_of(work, struct hdac_bus, unsol_work);
 	struct hdac_device *codec;
@@ -171,6 +169,7 @@ static void process_unsol_events(struct work_struct *work)
 			drv->unsol_event(codec, res);
 	}
 }
+EXPORT_SYMBOL_GPL(snd_hdac_bus_process_unsol_events);
 
 /**
  * snd_hdac_bus_add_device - Add a codec to bus

commit eb8d0eaaf84b0398533a7c091a0b65663f2fd7ea
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jun 19 17:49:48 2017 +0200

    ALSA: hda: Fix potential race at unregistration and unsol events
    
    When the codec device is unregistered / freed, it may release the
    resource while being used in an unsolicited event like the jack
    detection work.  This leads to use-after-free.
    
    The fix here is to unregister the device at first, i.e. removing the
    codec from the list, then flushing the pending works to assure that
    all unsol events are gone.  After this point, we're free from
    accessing the codec via unsol events, thus can release the resources
    gracefully.
    
    The issue was spotted originally by Intel CI, but it couldn't be
    reproduced reliably by its nature.  So let's hope this fix really
    addresses the whole issues.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=196045
    Reported-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index 0e81ea89a596..714a51721a31 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -212,5 +212,6 @@ void snd_hdac_bus_remove_device(struct hdac_bus *bus,
 	bus->caddr_tbl[codec->addr] = NULL;
 	clear_bit(codec->addr, &bus->codec_powered);
 	bus->num_codecs--;
+	flush_work(&bus->unsol_work);
 }
 EXPORT_SYMBOL_GPL(snd_hdac_bus_remove_device);

commit 78dd5e21b075053e67194ea8f496439bebc52728
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 28 12:26:48 2015 +0100

    ALSA: hda - Add / fix kernel doc comments
    
    Give some readable comment in kernel doc style for each exported
    function, as I promised in the previous meetings.  While we're at it,
    fix the wrong comments, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index 27c447e4fe5c..0e81ea89a596 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -172,6 +172,15 @@ static void process_unsol_events(struct work_struct *work)
 	}
 }
 
+/**
+ * snd_hdac_bus_add_device - Add a codec to bus
+ * @bus: HDA core bus
+ * @codec: HDA core device to add
+ *
+ * Adds the given codec to the list in the bus.  The caddr_tbl array
+ * and codec_powered bits are updated, as well.
+ * Returns zero if success, or a negative error code.
+ */
 int snd_hdac_bus_add_device(struct hdac_bus *bus, struct hdac_device *codec)
 {
 	if (bus->caddr_tbl[codec->addr]) {
@@ -188,6 +197,11 @@ int snd_hdac_bus_add_device(struct hdac_bus *bus, struct hdac_device *codec)
 }
 EXPORT_SYMBOL_GPL(snd_hdac_bus_add_device);
 
+/**
+ * snd_hdac_bus_remove_device - Remove a codec from bus
+ * @bus: HDA core bus
+ * @codec: HDA core device to remove
+ */
 void snd_hdac_bus_remove_device(struct hdac_bus *bus,
 				struct hdac_device *codec)
 {

commit 14752412721c61d9ac1e8d8fb51d7148cb15f85b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 14 12:15:47 2015 +0200

    ALSA: hda - Add the controller helper codes to hda-core module
    
    This patch adds the controller helper codes to hda-core library.
    The I/O access ops are added to the bus ops.  The CORB/RIRB, the basic
    attributes like irq# and iomap address, some locks and the list of
    streams are added to the bus object, together with the stream object
    and its helpers.
    
    Currently the codes are just copied from the legacy driver, so you can
    find duplicated codes in both directories.  Only constants are removed
    from the original hda_controller.h.  More integration work will follow
    in the later patches.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index 8e262da74f6a..27c447e4fe5c 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -11,21 +11,36 @@
 
 static void process_unsol_events(struct work_struct *work);
 
+static const struct hdac_bus_ops default_ops = {
+	.command = snd_hdac_bus_send_cmd,
+	.get_response = snd_hdac_bus_get_response,
+};
+
 /**
  * snd_hdac_bus_init - initialize a HD-audio bas bus
  * @bus: the pointer to bus object
+ * @ops: bus verb operators
+ * @io_ops: lowlevel I/O operators
  *
  * Returns 0 if successful, or a negative error code.
  */
 int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,
-		      const struct hdac_bus_ops *ops)
+		      const struct hdac_bus_ops *ops,
+		      const struct hdac_io_ops *io_ops)
 {
 	memset(bus, 0, sizeof(*bus));
 	bus->dev = dev;
-	bus->ops = ops;
+	if (ops)
+		bus->ops = ops;
+	else
+		bus->ops = &default_ops;
+	bus->io_ops = io_ops;
+	INIT_LIST_HEAD(&bus->stream_list);
 	INIT_LIST_HEAD(&bus->codec_list);
 	INIT_WORK(&bus->unsol_work, process_unsol_events);
+	spin_lock_init(&bus->reg_lock);
 	mutex_init(&bus->cmd_mutex);
+	bus->irq = -1;
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_hdac_bus_init);
@@ -36,6 +51,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_bus_init);
  */
 void snd_hdac_bus_exit(struct hdac_bus *bus)
 {
+	WARN_ON(!list_empty(&bus->stream_list));
 	WARN_ON(!list_empty(&bus->codec_list));
 	cancel_work_sync(&bus->unsol_work);
 }

commit e311782acd196d17d25b323d115709c50c8f7d3f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 10 15:16:28 2015 +0100

    ALSA: hda - Re-add tracepoints to HD-audio core driver
    
    Now let's take the basic tracepoints back to the HD-audio driver.
    The three bus tracepoints, hda_send_cmd, hda_get_response and
    hda_unsol_event are revived but in a slightly different form.
    Since we don't assign the card number there, print the bus device name
    instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
index 364f64c0e4a3..8e262da74f6a 100644
--- a/sound/hda/hdac_bus.c
+++ b/sound/hda/hdac_bus.c
@@ -7,6 +7,7 @@
 #include <linux/module.h>
 #include <linux/export.h>
 #include <sound/hdaudio.h>
+#include "trace.h"
 
 static void process_unsol_events(struct work_struct *work);
 
@@ -82,6 +83,7 @@ int snd_hdac_bus_exec_verb_unlocked(struct hdac_bus *bus, unsigned int addr,
 	else if (bus->sync_write)
 		res = &tmp;
 	for (;;) {
+		trace_hda_send_cmd(bus, cmd);
 		err = bus->ops->command(bus, cmd);
 		if (err != -EAGAIN)
 			break;
@@ -90,8 +92,10 @@ int snd_hdac_bus_exec_verb_unlocked(struct hdac_bus *bus, unsigned int addr,
 		if (err)
 			break;
 	}
-	if (!err && res)
+	if (!err && res) {
 		err = bus->ops->get_response(bus, addr, res);
+		trace_hda_get_response(bus, addr, *res);
+	}
 	return err;
 }
 EXPORT_SYMBOL_GPL(snd_hdac_bus_exec_verb_unlocked);
@@ -113,6 +117,7 @@ void snd_hdac_bus_queue_event(struct hdac_bus *bus, u32 res, u32 res_ex)
 	if (!bus)
 		return;
 
+	trace_hda_unsol_event(bus, res, res_ex);
 	wp = (bus->unsol_wp + 1) % HDA_UNSOL_QUEUE_SIZE;
 	bus->unsol_wp = wp;
 

commit d068ebc25e6e1360510ad8023fe7bca3dacd204e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 2 23:22:59 2015 +0100

    ALSA: hda - Move some codes up to hdac_bus struct
    
    A few basic codes for communicating over HD-audio bus are moved to
    struct hdac_bus now.  It has only command and get_response ops in
    addition to the unsolicited event handling.
    
    Note that the codec-side tracing support is disabled temporarily
    during this transition due to the code shuffling.  It will be
    re-enabled later once when all pieces are settled down.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_bus.c b/sound/hda/hdac_bus.c
new file mode 100644
index 000000000000..364f64c0e4a3
--- /dev/null
+++ b/sound/hda/hdac_bus.c
@@ -0,0 +1,181 @@
+/*
+ * HD-audio core bus driver
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/export.h>
+#include <sound/hdaudio.h>
+
+static void process_unsol_events(struct work_struct *work);
+
+/**
+ * snd_hdac_bus_init - initialize a HD-audio bas bus
+ * @bus: the pointer to bus object
+ *
+ * Returns 0 if successful, or a negative error code.
+ */
+int snd_hdac_bus_init(struct hdac_bus *bus, struct device *dev,
+		      const struct hdac_bus_ops *ops)
+{
+	memset(bus, 0, sizeof(*bus));
+	bus->dev = dev;
+	bus->ops = ops;
+	INIT_LIST_HEAD(&bus->codec_list);
+	INIT_WORK(&bus->unsol_work, process_unsol_events);
+	mutex_init(&bus->cmd_mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_init);
+
+/**
+ * snd_hdac_bus_exit - clean up a HD-audio bas bus
+ * @bus: the pointer to bus object
+ */
+void snd_hdac_bus_exit(struct hdac_bus *bus)
+{
+	WARN_ON(!list_empty(&bus->codec_list));
+	cancel_work_sync(&bus->unsol_work);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_exit);
+
+/**
+ * snd_hdac_bus_exec_verb - execute a HD-audio verb on the given bus
+ * @bus: bus object
+ * @cmd: HD-audio encoded verb
+ * @res: pointer to store the response, NULL if performing asynchronously
+ *
+ * Returns 0 if successful, or a negative error code.
+ */
+int snd_hdac_bus_exec_verb(struct hdac_bus *bus, unsigned int addr,
+			   unsigned int cmd, unsigned int *res)
+{
+	int err;
+
+	mutex_lock(&bus->cmd_mutex);
+	err = snd_hdac_bus_exec_verb_unlocked(bus, addr, cmd, res);
+	mutex_unlock(&bus->cmd_mutex);
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_exec_verb);
+
+/**
+ * snd_hdac_bus_exec_verb_unlocked - unlocked version
+ * @bus: bus object
+ * @cmd: HD-audio encoded verb
+ * @res: pointer to store the response, NULL if performing asynchronously
+ *
+ * Returns 0 if successful, or a negative error code.
+ */
+int snd_hdac_bus_exec_verb_unlocked(struct hdac_bus *bus, unsigned int addr,
+				    unsigned int cmd, unsigned int *res)
+{
+	unsigned int tmp;
+	int err;
+
+	if (cmd == ~0)
+		return -EINVAL;
+
+	if (res)
+		*res = -1;
+	else if (bus->sync_write)
+		res = &tmp;
+	for (;;) {
+		err = bus->ops->command(bus, cmd);
+		if (err != -EAGAIN)
+			break;
+		/* process pending verbs */
+		err = bus->ops->get_response(bus, addr, &tmp);
+		if (err)
+			break;
+	}
+	if (!err && res)
+		err = bus->ops->get_response(bus, addr, res);
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_exec_verb_unlocked);
+
+/**
+ * snd_hdac_bus_queue_event - add an unsolicited event to queue
+ * @bus: the BUS
+ * @res: unsolicited event (lower 32bit of RIRB entry)
+ * @res_ex: codec addr and flags (upper 32bit or RIRB entry)
+ *
+ * Adds the given event to the queue.  The events are processed in
+ * the workqueue asynchronously.  Call this function in the interrupt
+ * hanlder when RIRB receives an unsolicited event.
+ */
+void snd_hdac_bus_queue_event(struct hdac_bus *bus, u32 res, u32 res_ex)
+{
+	unsigned int wp;
+
+	if (!bus)
+		return;
+
+	wp = (bus->unsol_wp + 1) % HDA_UNSOL_QUEUE_SIZE;
+	bus->unsol_wp = wp;
+
+	wp <<= 1;
+	bus->unsol_queue[wp] = res;
+	bus->unsol_queue[wp + 1] = res_ex;
+
+	schedule_work(&bus->unsol_work);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_queue_event);
+
+/*
+ * process queued unsolicited events
+ */
+static void process_unsol_events(struct work_struct *work)
+{
+	struct hdac_bus *bus = container_of(work, struct hdac_bus, unsol_work);
+	struct hdac_device *codec;
+	struct hdac_driver *drv;
+	unsigned int rp, caddr, res;
+
+	while (bus->unsol_rp != bus->unsol_wp) {
+		rp = (bus->unsol_rp + 1) % HDA_UNSOL_QUEUE_SIZE;
+		bus->unsol_rp = rp;
+		rp <<= 1;
+		res = bus->unsol_queue[rp];
+		caddr = bus->unsol_queue[rp + 1];
+		if (!(caddr & (1 << 4))) /* no unsolicited event? */
+			continue;
+		codec = bus->caddr_tbl[caddr & 0x0f];
+		if (!codec || !codec->dev.driver)
+			continue;
+		drv = drv_to_hdac_driver(codec->dev.driver);
+		if (drv->unsol_event)
+			drv->unsol_event(codec, res);
+	}
+}
+
+int snd_hdac_bus_add_device(struct hdac_bus *bus, struct hdac_device *codec)
+{
+	if (bus->caddr_tbl[codec->addr]) {
+		dev_err(bus->dev, "address 0x%x is already occupied\n",
+			codec->addr);
+		return -EBUSY;
+	}
+
+	list_add_tail(&codec->list, &bus->codec_list);
+	bus->caddr_tbl[codec->addr] = codec;
+	set_bit(codec->addr, &bus->codec_powered);
+	bus->num_codecs++;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_add_device);
+
+void snd_hdac_bus_remove_device(struct hdac_bus *bus,
+				struct hdac_device *codec)
+{
+	WARN_ON(bus != codec->bus);
+	if (list_empty(&codec->list))
+		return;
+	list_del_init(&codec->list);
+	bus->caddr_tbl[codec->addr] = NULL;
+	clear_bit(codec->addr, &bus->codec_powered);
+	bus->num_codecs--;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_bus_remove_device);
