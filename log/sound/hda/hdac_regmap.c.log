commit 1a462be52f4505a2719631fb5aa7bfdbd37bfd8d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 9 10:01:04 2020 +0100

    ALSA: hda: Manage concurrent reg access more properly
    
    In the commit 8e85def5723e ("ALSA: hda: enable regmap internal
    locking"), we re-enabled the regmap lock due to the reported
    regression that showed the possible concurrent accesses.  It was a
    temporary workaround, and there are still a few opened races even
    after the revert.  In this patch, we cover those still opened windows
    with a proper mutex lock and disable the regmap internal lock again.
    
    First off, the patch introduces a new snd_hdac_device.regmap_lock
    mutex that is applied for each snd_hdac_regmap_*() call, including
    read, write and update helpers.  The mutex is applied carefully so
    that it won't block the self-power-up procedure in the helper
    function.  Also, this assures the protection for the accesses without
    regmap, too.
    
    The snd_hdac_regmap_update_raw() is refactored to use the standard
    regmap_update_bits_check() function instead of the open-code.  The
    non-regmap case is still open-coded but it's an easy part.  The all
    read and write operations are in the single mutex protection, so it's
    now race-free.
    
    In addition, a couple of new helper functions are added:
    snd_hdac_regmap_update_raw_once() and snd_hdac_regmap_sync().  Both
    are called from HD-audio legacy driver.  The former is to initialize
    the given verb bits but only once when it's not initialized yet.  Due
    to this condition, the function invokes regcache_cache_only(), and
    it's now performed inside the regmap_lock (formerly it was racy) too.
    The latter function is for simply invoking regcache_sync() inside the
    regmap_lock, which is called from the codec resume call path.
    Along with that, the HD-audio codec driver code is slightly modified /
    simplified to adapt those new functions.
    
    And finally, snd_hdac_regmap_read_raw(), *_write_raw(), etc are
    rewritten with the helper macro.  It's just for simplification because
    the code logic is identical among all those functions.
    
    Tested-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
    Link: https://lore.kernel.org/r/20200109090104.26073-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 0c8188a48a00..d75f31eb9d78 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -363,6 +363,7 @@ static const struct regmap_config hda_regmap_cfg = {
 	.reg_write = hda_reg_write,
 	.use_single_read = true,
 	.use_single_write = true,
+	.disable_locking = true,
 };
 
 /**
@@ -425,12 +426,29 @@ EXPORT_SYMBOL_GPL(snd_hdac_regmap_add_vendor_verb);
 static int reg_raw_write(struct hdac_device *codec, unsigned int reg,
 			 unsigned int val)
 {
+	int err;
+
+	mutex_lock(&codec->regmap_lock);
 	if (!codec->regmap)
-		return hda_reg_write(codec, reg, val);
+		err = hda_reg_write(codec, reg, val);
 	else
-		return regmap_write(codec->regmap, reg, val);
+		err = regmap_write(codec->regmap, reg, val);
+	mutex_unlock(&codec->regmap_lock);
+	return err;
 }
 
+/* a helper macro to call @func_call; retry with power-up if failed */
+#define CALL_RAW_FUNC(codec, func_call)				\
+	({							\
+		int _err = func_call;				\
+		if (_err == -EAGAIN) {				\
+			_err = snd_hdac_power_up_pm(codec);	\
+			if (_err >= 0)				\
+				_err = func_call;		\
+			snd_hdac_power_down_pm(codec);		\
+		}						\
+		_err;})
+
 /**
  * snd_hdac_regmap_write_raw - write a pseudo register with power mgmt
  * @codec: the codec object
@@ -442,42 +460,29 @@ static int reg_raw_write(struct hdac_device *codec, unsigned int reg,
 int snd_hdac_regmap_write_raw(struct hdac_device *codec, unsigned int reg,
 			      unsigned int val)
 {
-	int err;
-
-	err = reg_raw_write(codec, reg, val);
-	if (err == -EAGAIN) {
-		err = snd_hdac_power_up_pm(codec);
-		if (err >= 0)
-			err = reg_raw_write(codec, reg, val);
-		snd_hdac_power_down_pm(codec);
-	}
-	return err;
+	return CALL_RAW_FUNC(codec, reg_raw_write(codec, reg, val));
 }
 EXPORT_SYMBOL_GPL(snd_hdac_regmap_write_raw);
 
 static int reg_raw_read(struct hdac_device *codec, unsigned int reg,
 			unsigned int *val, bool uncached)
 {
+	int err;
+
+	mutex_lock(&codec->regmap_lock);
 	if (uncached || !codec->regmap)
-		return hda_reg_read(codec, reg, val);
+		err = hda_reg_read(codec, reg, val);
 	else
-		return regmap_read(codec->regmap, reg, val);
+		err = regmap_read(codec->regmap, reg, val);
+	mutex_unlock(&codec->regmap_lock);
+	return err;
 }
 
 static int __snd_hdac_regmap_read_raw(struct hdac_device *codec,
 				      unsigned int reg, unsigned int *val,
 				      bool uncached)
 {
-	int err;
-
-	err = reg_raw_read(codec, reg, val, uncached);
-	if (err == -EAGAIN) {
-		err = snd_hdac_power_up_pm(codec);
-		if (err >= 0)
-			err = reg_raw_read(codec, reg, val, uncached);
-		snd_hdac_power_down_pm(codec);
-	}
-	return err;
+	return CALL_RAW_FUNC(codec, reg_raw_read(codec, reg, val, uncached));
 }
 
 /**
@@ -504,6 +509,35 @@ int snd_hdac_regmap_read_raw_uncached(struct hdac_device *codec,
 	return __snd_hdac_regmap_read_raw(codec, reg, val, true);
 }
 
+static int reg_raw_update(struct hdac_device *codec, unsigned int reg,
+			  unsigned int mask, unsigned int val)
+{
+	unsigned int orig;
+	bool change;
+	int err;
+
+	mutex_lock(&codec->regmap_lock);
+	if (codec->regmap) {
+		err = regmap_update_bits_check(codec->regmap, reg, mask, val,
+					       &change);
+		if (!err)
+			err = change ? 1 : 0;
+	} else {
+		err = hda_reg_read(codec, reg, &orig);
+		if (!err) {
+			val &= mask;
+			val |= orig & ~mask;
+			if (val != orig) {
+				err = hda_reg_write(codec, reg, val);
+				if (!err)
+					err = 1;
+			}
+		}
+	}
+	mutex_unlock(&codec->regmap_lock);
+	return err;
+}
+
 /**
  * snd_hdac_regmap_update_raw - update a pseudo register with power mgmt
  * @codec: the codec object
@@ -515,20 +549,58 @@ int snd_hdac_regmap_read_raw_uncached(struct hdac_device *codec,
  */
 int snd_hdac_regmap_update_raw(struct hdac_device *codec, unsigned int reg,
 			       unsigned int mask, unsigned int val)
+{
+	return CALL_RAW_FUNC(codec, reg_raw_update(codec, reg, mask, val));
+}
+EXPORT_SYMBOL_GPL(snd_hdac_regmap_update_raw);
+
+static int reg_raw_update_once(struct hdac_device *codec, unsigned int reg,
+			       unsigned int mask, unsigned int val)
 {
 	unsigned int orig;
 	int err;
 
-	val &= mask;
-	err = snd_hdac_regmap_read_raw(codec, reg, &orig);
-	if (err < 0)
-		return err;
-	val |= orig & ~mask;
-	if (val == orig)
-		return 0;
-	err = snd_hdac_regmap_write_raw(codec, reg, val);
+	if (!codec->regmap)
+		return reg_raw_update(codec, reg, mask, val);
+
+	mutex_lock(&codec->regmap_lock);
+	regcache_cache_only(codec->regmap, true);
+	err = regmap_read(codec->regmap, reg, &orig);
+	regcache_cache_only(codec->regmap, false);
 	if (err < 0)
-		return err;
-	return 1;
+		err = regmap_update_bits(codec->regmap, reg, mask, val);
+	mutex_unlock(&codec->regmap_lock);
+	return err;
 }
-EXPORT_SYMBOL_GPL(snd_hdac_regmap_update_raw);
+
+/**
+ * snd_hdac_regmap_update_raw_once - initialize the register value only once
+ * @codec: the codec object
+ * @reg: pseudo register
+ * @mask: bit mask to update
+ * @val: value to update
+ *
+ * Performs the update of the register bits only once when the register
+ * hasn't been initialized yet.  Used in HD-audio legacy driver.
+ * Returns zero if successful or a negative error code
+ */
+int snd_hdac_regmap_update_raw_once(struct hdac_device *codec, unsigned int reg,
+				    unsigned int mask, unsigned int val)
+{
+	return CALL_RAW_FUNC(codec, reg_raw_update_once(codec, reg, mask, val));
+}
+EXPORT_SYMBOL_GPL(snd_hdac_regmap_update_raw_once);
+
+/**
+ * snd_hdac_regmap_sync - sync out the cached values for PM resume
+ * @codec: the codec object
+ */
+void snd_hdac_regmap_sync(struct hdac_device *codec)
+{
+	if (codec->regmap) {
+		mutex_lock(&codec->regmap_lock);
+		regcache_sync(codec->regmap);
+		mutex_unlock(&codec->regmap_lock);
+	}
+}
+EXPORT_SYMBOL_GPL(snd_hdac_regmap_sync);

commit 3cdca6d62b8e948ca9c148deec7424b664d50cd9
Merge: 1a0986c1bc14 7fba6aea4472
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat Jan 11 09:03:32 2020 +0100

    Merge branch 'for-linus' into for-next
    
    Sync 5.5-devel branch once again for applying the HD-audio fixes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 8e85def5723eccea30ebf22645673692ab8cb3e2
Author: Kai Vehmanen <kai.vehmanen@linux.intel.com>
Date:   Wed Jan 8 20:08:56 2020 +0200

    ALSA: hda: enable regmap internal locking
    
    This reverts commit 42ec336f1f9d ("ALSA: hda: Disable regmap
    internal locking").
    
    Without regmap locking, there is a race between snd_hda_codec_amp_init()
    and PM callbacks issuing regcache_sync(). This was caught by
    following kernel warning trace:
    
    <4> [358.080081] WARNING: CPU: 2 PID: 4157 at drivers/base/regmap/regcache.c:498 regcache_cache_only+0xf5/0x130
    [...]
    <4> [358.080148] Call Trace:
    <4> [358.080158]  snd_hda_codec_amp_init+0x4e/0x100 [snd_hda_codec]
    <4> [358.080169]  snd_hda_codec_amp_init_stereo+0x40/0x80 [snd_hda_codec]
    
    Suggested-by: Takashi Iwai <tiwai@suse.de>
    BugLink: https://gitlab.freedesktop.org/drm/intel/issues/592
    Signed-off-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
    Link: https://lore.kernel.org/r/20200108180856.5194-1-kai.vehmanen@linux.intel.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 906b1e20bae0..286361ecd640 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -363,7 +363,6 @@ static const struct regmap_config hda_regmap_cfg = {
 	.reg_write = hda_reg_write,
 	.use_single_read = true,
 	.use_single_write = true,
-	.disable_locking = true,
 };
 
 /**

commit 1a0986c1bc14a6a05da9d9cdeb61833560bacb1e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 8 16:34:30 2020 +0100

    ALSA: hda: Fix a typo in comments
    
    Link: https://lore.kernel.org/r/20200108153430.31456-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 906b1e20bae0..d771d2cfdef7 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -509,7 +509,7 @@ int snd_hdac_regmap_read_raw_uncached(struct hdac_device *codec,
  * snd_hdac_regmap_update_raw - update a pseudo register with power mgmt
  * @codec: the codec object
  * @reg: pseudo register
- * @mask: bit mask to udpate
+ * @mask: bit mask to update
  * @val: value to update
  *
  * Returns zero if successful or a negative error code.

commit 42ec336f1f9d54049811b749f729e9e01c152ade
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 09:18:06 2019 +0100

    ALSA: hda: Disable regmap internal locking
    
    Since we apply the own mutex (bus->cmd_mutex) in HDA core side, the
    internal locking in regmap is superfluous.  This patch adds the flag
    to indicate that.
    
    Also, an infamous side-effect by this change is that it disables the
    regmap debugfs, too, and this is seen rather good; the regmap debugfs
    isn't quite useful for HD-audio as it provides the very sparse
    registers and its debugfs access tends to lead to the way too high
    resource usages or sometimes hang up.  So it'd be rather safe to
    disable it altogether.
    
    Link: https://lore.kernel.org/r/2029139028.10333037.1572874551626.JavaMail.zimbra@redhat.com
    Link: https://lore.kernel.org/r/20191105081806.4896-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 286361ecd640..906b1e20bae0 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -363,6 +363,7 @@ static const struct regmap_config hda_regmap_cfg = {
 	.reg_write = hda_reg_write,
 	.use_single_read = true,
 	.use_single_write = true,
+	.disable_locking = true,
 };
 
 /**

commit ddf7cb83b0f45feb94ad89a987f600c766c463ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 14 19:59:44 2019 +0200

    ALSA: hda: Unexport a few more stuff
    
    Drop EXPORT_SYMBOL*() from a few more stuff in HD-audio core that
    aren't used outside.  Particular the unsol event handler can be
    staticized now because the recent change removed all external
    callers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index f399a1552e73..286361ecd640 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -21,6 +21,7 @@
 #include <sound/core.h>
 #include <sound/hdaudio.h>
 #include <sound/hda_regmap.h>
+#include "local.h"
 
 static int codec_pm_lock(struct hdac_device *codec)
 {

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 996dbc850224..f399a1552e73 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Regmap support for HD-audio verbs
  *

commit 1c96a2f67cd9b617b013f0a7580d76aae7dcd0d7
Author: David Frey <dpfrey@gmail.com>
Date:   Sat Sep 1 09:50:41 2018 -0700

    regmap: split up regmap_config.use_single_rw
    
    Split regmap_config.use_single_rw into use_single_read and
    use_single_write. This change enables drivers of devices which only
    support bulk operations in one direction to use the regmap_bulk_*()
    functions for both directions and have their bulk operation split into
    single operations only when necessary.
    
    Update all struct regmap_config instances where use_single_rw==true to
    instead set both use_single_read and use_single_write. No attempt was
    made to evaluate whether it is possible to set only one of
    use_single_read or use_single_write.
    
    Signed-off-by: David Frey <dpfrey@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 419e285e0226..996dbc850224 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -359,7 +359,8 @@ static const struct regmap_config hda_regmap_cfg = {
 	.cache_type = REGCACHE_RBTREE,
 	.reg_read = hda_reg_read,
 	.reg_write = hda_reg_write,
-	.use_single_rw = true,
+	.use_single_read = true,
+	.use_single_write = true,
 };
 
 /**

commit a9c2dfc8527318a27db045cd7ea51e8ecab8c884
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 23 17:24:56 2018 +0200

    ALSA: hda - Use a macro for snd_array iteration loops
    
    Introduce a new helper macro, snd_array_for_each(), to iterate for
    each snd_array element.  It slightly improves the readability than
    lengthy open codes at each place.
    
    Along with it, add const prefix to some obvious places.
    
    There should be no functional changes by this.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 47a358fab132..419e285e0226 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -65,10 +65,10 @@ static bool hda_writeable_reg(struct device *dev, unsigned int reg)
 {
 	struct hdac_device *codec = dev_to_hdac_dev(dev);
 	unsigned int verb = get_verb(reg);
+	const unsigned int *v;
 	int i;
 
-	for (i = 0; i < codec->vendor_verbs.used; i++) {
-		unsigned int *v = snd_array_elem(&codec->vendor_verbs, i);
+	snd_array_for_each(&codec->vendor_verbs, i, v) {
 		if (verb == *v)
 			return true;
 	}

commit 8198868f0a283eb23e264951632ce61ec2f82228
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Fri Jun 17 13:35:56 2016 +0200

    ALSA: hdac_regmap - fix the register access for runtime PM
    
    Call path:
    
      1) snd_hdac_power_up_pm()
      2) snd_hdac_power_up()
      3) pm_runtime_get_sync()
      4) __pm_runtime_resume()
      5) rpm_resume()
    
    The rpm_resume() returns 1 when the device is already active.
    Because the return value is unmodified, the hdac regmap read/write
    functions should allow this value for the retry I/O operation, too.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 87041ddd29cb..47a358fab132 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -444,7 +444,7 @@ int snd_hdac_regmap_write_raw(struct hdac_device *codec, unsigned int reg,
 	err = reg_raw_write(codec, reg, val);
 	if (err == -EAGAIN) {
 		err = snd_hdac_power_up_pm(codec);
-		if (!err)
+		if (err >= 0)
 			err = reg_raw_write(codec, reg, val);
 		snd_hdac_power_down_pm(codec);
 	}
@@ -470,7 +470,7 @@ static int __snd_hdac_regmap_read_raw(struct hdac_device *codec,
 	err = reg_raw_read(codec, reg, val, uncached);
 	if (err == -EAGAIN) {
 		err = snd_hdac_power_up_pm(codec);
-		if (!err)
+		if (err >= 0)
 			err = reg_raw_read(codec, reg, val, uncached);
 		snd_hdac_power_down_pm(codec);
 	}

commit 3194ed497939c6448005542e3ca4fa2386968fa0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 21 17:49:11 2016 +0200

    ALSA: hda - Fix possible race on regmap bypass flip
    
    HD-audio driver uses regmap cache bypass feature for reading a raw
    value without the cache.  But this is racy since both the cached and
    the uncached reads may occur concurrently.  The former is done via the
    normal control API access while the latter comes from the proc file
    read.
    
    Even though the regmap itself has the protection against the
    concurrent accesses, the flag set/reset is done without the
    protection, so it may lead to inconsistent state of bypass flag that
    doesn't match with the current read and occasionally result in a
    kernel WARNING like:
      WARNING: CPU: 3 PID: 2731 at drivers/base/regmap/regcache.c:499 regcache_cache_only+0x78/0x93
    
    One way to work around such a problem is to wrap with a mutex.  But in
    this case, the solution is simpler: for the uncached read, we just
    skip the regmap and directly calls its accessor.  The verb execution
    there is protected by itself, so basically it's safe to call
    individually.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=116171
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index bdbcd6b75ff6..87041ddd29cb 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -453,14 +453,30 @@ int snd_hdac_regmap_write_raw(struct hdac_device *codec, unsigned int reg,
 EXPORT_SYMBOL_GPL(snd_hdac_regmap_write_raw);
 
 static int reg_raw_read(struct hdac_device *codec, unsigned int reg,
-			unsigned int *val)
+			unsigned int *val, bool uncached)
 {
-	if (!codec->regmap)
+	if (uncached || !codec->regmap)
 		return hda_reg_read(codec, reg, val);
 	else
 		return regmap_read(codec->regmap, reg, val);
 }
 
+static int __snd_hdac_regmap_read_raw(struct hdac_device *codec,
+				      unsigned int reg, unsigned int *val,
+				      bool uncached)
+{
+	int err;
+
+	err = reg_raw_read(codec, reg, val, uncached);
+	if (err == -EAGAIN) {
+		err = snd_hdac_power_up_pm(codec);
+		if (!err)
+			err = reg_raw_read(codec, reg, val, uncached);
+		snd_hdac_power_down_pm(codec);
+	}
+	return err;
+}
+
 /**
  * snd_hdac_regmap_read_raw - read a pseudo register with power mgmt
  * @codec: the codec object
@@ -472,19 +488,19 @@ static int reg_raw_read(struct hdac_device *codec, unsigned int reg,
 int snd_hdac_regmap_read_raw(struct hdac_device *codec, unsigned int reg,
 			     unsigned int *val)
 {
-	int err;
-
-	err = reg_raw_read(codec, reg, val);
-	if (err == -EAGAIN) {
-		err = snd_hdac_power_up_pm(codec);
-		if (!err)
-			err = reg_raw_read(codec, reg, val);
-		snd_hdac_power_down_pm(codec);
-	}
-	return err;
+	return __snd_hdac_regmap_read_raw(codec, reg, val, false);
 }
 EXPORT_SYMBOL_GPL(snd_hdac_regmap_read_raw);
 
+/* Works like snd_hdac_regmap_read_raw(), but this doesn't read from the
+ * cache but always via hda verbs.
+ */
+int snd_hdac_regmap_read_raw_uncached(struct hdac_device *codec,
+				      unsigned int reg, unsigned int *val)
+{
+	return __snd_hdac_regmap_read_raw(codec, reg, val, true);
+}
+
 /**
  * snd_hdac_regmap_update_raw - update a pseudo register with power mgmt
  * @codec: the codec object

commit fc4f000bf8c0cbf38f44de6bd5e225574e572ed4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 4 11:34:18 2016 +0100

    ALSA: hda - Fix unexpected resume through regmap code path
    
    HD-audio driver has a mechanism to trigger the runtime resume
    automatically at accessing the verbs.  This auto-resume, however,
    causes the mutex deadlock when invoked from the regmap handler since
    the regmap keeps the mutex while auto-resuming.  For avoiding that,
    there is some tricky check in the HDA regmap handler to return -EAGAIN
    error to back-off when the codec is powered down.  Then the caller of
    regmap r/w will retry after properly turning on the codec power.
    
    This works in most cases, but there seems a slight race between the
    codec power check and the actual on-demand auto-resume trigger.  This
    resulted in the lockdep splat, eventually leading to a real deadlock.
    
    This patch tries to address the race window by getting the runtime PM
    refcount at the check time using pm_runtime_get_if_in_use().  With
    this call, we can keep the power on only when the codec has been
    already turned on, and back off if not.
    
    For keeping the code consistency, the code touching the runtime PM is
    stored in hdac_device.c although it's used only locally in
    hdac_regmap.c.
    
    Reported-by: Jiri Slaby <jslaby@suse.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index eb8f7c30cb09..bdbcd6b75ff6 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -21,13 +21,16 @@
 #include <sound/hdaudio.h>
 #include <sound/hda_regmap.h>
 
-#ifdef CONFIG_PM
-#define codec_is_running(codec)				\
-	(atomic_read(&(codec)->in_pm) ||		\
-	 !pm_runtime_suspended(&(codec)->dev))
-#else
-#define codec_is_running(codec)		true
-#endif
+static int codec_pm_lock(struct hdac_device *codec)
+{
+	return snd_hdac_keep_power_up(codec);
+}
+
+static void codec_pm_unlock(struct hdac_device *codec, int lock)
+{
+	if (lock == 1)
+		snd_hdac_power_down_pm(codec);
+}
 
 #define get_verb(reg)	(((reg) >> 8) & 0xfff)
 
@@ -238,20 +241,28 @@ static int hda_reg_read(void *context, unsigned int reg, unsigned int *val)
 	struct hdac_device *codec = context;
 	int verb = get_verb(reg);
 	int err;
+	int pm_lock = 0;
 
-	if (!codec_is_running(codec) && verb != AC_VERB_GET_POWER_STATE)
-		return -EAGAIN;
+	if (verb != AC_VERB_GET_POWER_STATE) {
+		pm_lock = codec_pm_lock(codec);
+		if (pm_lock < 0)
+			return -EAGAIN;
+	}
 	reg |= (codec->addr << 28);
-	if (is_stereo_amp_verb(reg))
-		return hda_reg_read_stereo_amp(codec, reg, val);
-	if (verb == AC_VERB_GET_PROC_COEF)
-		return hda_reg_read_coef(codec, reg, val);
+	if (is_stereo_amp_verb(reg)) {
+		err = hda_reg_read_stereo_amp(codec, reg, val);
+		goto out;
+	}
+	if (verb == AC_VERB_GET_PROC_COEF) {
+		err = hda_reg_read_coef(codec, reg, val);
+		goto out;
+	}
 	if ((verb & 0x700) == AC_VERB_SET_AMP_GAIN_MUTE)
 		reg &= ~AC_AMP_FAKE_MUTE;
 
 	err = snd_hdac_exec_verb(codec, reg, 0, val);
 	if (err < 0)
-		return err;
+		goto out;
 	/* special handling for asymmetric reads */
 	if (verb == AC_VERB_GET_POWER_STATE) {
 		if (*val & AC_PWRST_ERROR)
@@ -259,7 +270,9 @@ static int hda_reg_read(void *context, unsigned int reg, unsigned int *val)
 		else /* take only the actual state */
 			*val = (*val >> 4) & 0x0f;
 	}
-	return 0;
+ out:
+	codec_pm_unlock(codec, pm_lock);
+	return err;
 }
 
 static int hda_reg_write(void *context, unsigned int reg, unsigned int val)
@@ -267,6 +280,7 @@ static int hda_reg_write(void *context, unsigned int reg, unsigned int val)
 	struct hdac_device *codec = context;
 	unsigned int verb;
 	int i, bytes, err;
+	int pm_lock = 0;
 
 	if (codec->caps_overwriting)
 		return 0;
@@ -275,14 +289,21 @@ static int hda_reg_write(void *context, unsigned int reg, unsigned int val)
 	reg |= (codec->addr << 28);
 	verb = get_verb(reg);
 
-	if (!codec_is_running(codec) && verb != AC_VERB_SET_POWER_STATE)
-		return codec->lazy_cache ? 0 : -EAGAIN;
+	if (verb != AC_VERB_SET_POWER_STATE) {
+		pm_lock = codec_pm_lock(codec);
+		if (pm_lock < 0)
+			return codec->lazy_cache ? 0 : -EAGAIN;
+	}
 
-	if (is_stereo_amp_verb(reg))
-		return hda_reg_write_stereo_amp(codec, reg, val);
+	if (is_stereo_amp_verb(reg)) {
+		err = hda_reg_write_stereo_amp(codec, reg, val);
+		goto out;
+	}
 
-	if (verb == AC_VERB_SET_PROC_COEF)
-		return hda_reg_write_coef(codec, reg, val);
+	if (verb == AC_VERB_SET_PROC_COEF) {
+		err = hda_reg_write_coef(codec, reg, val);
+		goto out;
+	}
 
 	switch (verb & 0xf00) {
 	case AC_VERB_SET_AMP_GAIN_MUTE:
@@ -319,10 +340,12 @@ static int hda_reg_write(void *context, unsigned int reg, unsigned int val)
 		reg |= (verb + i) << 8 | ((val >> (8 * i)) & 0xff);
 		err = snd_hdac_exec_verb(codec, reg, 0, NULL);
 		if (err < 0)
-			return err;
+			goto out;
 	}
 
-	return 0;
+ out:
+	codec_pm_unlock(codec, pm_lock);
+	return err;
 }
 
 static const struct regmap_config hda_regmap_cfg = {

commit 78dd5e21b075053e67194ea8f496439bebc52728
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 28 12:26:48 2015 +0100

    ALSA: hda - Add / fix kernel doc comments
    
    Give some readable comment in kernel doc style for each exported
    function, as I promised in the previous meetings.  While we're at it,
    fix the wrong comments, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index b0ed870ffb88..eb8f7c30cb09 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -339,6 +339,12 @@ static const struct regmap_config hda_regmap_cfg = {
 	.use_single_rw = true,
 };
 
+/**
+ * snd_hdac_regmap_init - Initialize regmap for HDA register accesses
+ * @codec: the codec object
+ *
+ * Returns zero for success or a negative error code.
+ */
 int snd_hdac_regmap_init(struct hdac_device *codec)
 {
 	struct regmap *regmap;
@@ -352,6 +358,10 @@ int snd_hdac_regmap_init(struct hdac_device *codec)
 }
 EXPORT_SYMBOL_GPL(snd_hdac_regmap_init);
 
+/**
+ * snd_hdac_regmap_init - Release the regmap from HDA codec
+ * @codec: the codec object
+ */
 void snd_hdac_regmap_exit(struct hdac_device *codec)
 {
 	if (codec->regmap) {

commit fbce23a0b95763dfc4961ce6240e055c39f497ed
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jul 17 16:27:33 2015 +0200

    ALSA: hda - Check the return value from pm_runtime_get/put*()
    
    This patch changes the return type of snd_hdac_power_up/down() and
    variants to pass the error code from the underlying
    pm_runtime_get/put() calls.  Currently they are ignored, but in most
    places, these should be handled properly.
    
    As an example, the regmap handler is updated to check the return value
    and accesses the register only when the wakeup succeeds.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 1eabcdf69457..b0ed870ffb88 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -410,8 +410,9 @@ int snd_hdac_regmap_write_raw(struct hdac_device *codec, unsigned int reg,
 
 	err = reg_raw_write(codec, reg, val);
 	if (err == -EAGAIN) {
-		snd_hdac_power_up_pm(codec);
-		err = reg_raw_write(codec, reg, val);
+		err = snd_hdac_power_up_pm(codec);
+		if (!err)
+			err = reg_raw_write(codec, reg, val);
 		snd_hdac_power_down_pm(codec);
 	}
 	return err;
@@ -442,8 +443,9 @@ int snd_hdac_regmap_read_raw(struct hdac_device *codec, unsigned int reg,
 
 	err = reg_raw_read(codec, reg, val);
 	if (err == -EAGAIN) {
-		snd_hdac_power_up_pm(codec);
-		err = reg_raw_read(codec, reg, val);
+		err = snd_hdac_power_up_pm(codec);
+		if (!err)
+			err = reg_raw_read(codec, reg, val);
 		snd_hdac_power_down_pm(codec);
 	}
 	return err;

commit a686ec4c5f28eb1b384e4b87b08543155c970072
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jun 11 10:51:28 2015 +0200

    ALSA: hda - Re-add the lost fake mute support
    
    Yet another regression by the transition to regmap cache; for better
    usability, we had the fake mute control using the zero amp value for
    Conexant codecs, and this was forgotten in the new hda core code.
    
    Since the bits 4-7 are unused for the amp registers (as we follow the
    syntax of AMP_GET verb), the bit 4 is now used to indicate the fake
    mute.  For setting this flag, snd_hda_codec_amp_update() becomes a
    function from a simple macro.  The bonus is that it gained a proper
    function description.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index c4f5e61d4404..1eabcdf69457 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -246,6 +246,9 @@ static int hda_reg_read(void *context, unsigned int reg, unsigned int *val)
 		return hda_reg_read_stereo_amp(codec, reg, val);
 	if (verb == AC_VERB_GET_PROC_COEF)
 		return hda_reg_read_coef(codec, reg, val);
+	if ((verb & 0x700) == AC_VERB_SET_AMP_GAIN_MUTE)
+		reg &= ~AC_AMP_FAKE_MUTE;
+
 	err = snd_hdac_exec_verb(codec, reg, 0, val);
 	if (err < 0)
 		return err;
@@ -283,6 +286,8 @@ static int hda_reg_write(void *context, unsigned int reg, unsigned int val)
 
 	switch (verb & 0xf00) {
 	case AC_VERB_SET_AMP_GAIN_MUTE:
+		if ((reg & AC_AMP_FAKE_MUTE) && (val & AC_AMP_MUTE))
+			val = 0;
 		verb = AC_VERB_SET_AMP_GAIN_MUTE;
 		if (reg & AC_AMP_GET_LEFT)
 			verb |= AC_AMP_SET_LEFT >> 8;

commit 98a226ed21949601b270f7ea20abc9f72f7b0be9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 10 10:27:00 2015 +0200

    ALSA: hda - Don't actually write registers for caps overwrites
    
    Along with the transition to regmap for managing the cached parameter
    reads, the caps overwrite was also moved to regmap cache.  The cache
    change itself works, but it still tries to write the non-existing verb
    (the HDA parameter is read-only) wrongly.  It's harmless in most
    cases, but some chips are picky and may result in the codec
    communication stall.
    
    This patch avoids it just by adding the missing flag check in
    reg_write ops.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 7371e0c3926f..c4f5e61d4404 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -265,6 +265,9 @@ static int hda_reg_write(void *context, unsigned int reg, unsigned int val)
 	unsigned int verb;
 	int i, bytes, err;
 
+	if (codec->caps_overwriting)
+		return 0;
+
 	reg &= ~0x00080000U; /* drop GET bit */
 	reg |= (codec->addr << 28);
 	verb = get_verb(reg);

commit d6eb9e3ec78c98324097bab8eea266c3bb0d0ac7
Author: Mengdong Lin <mengdong.lin@intel.com>
Date:   Tue Apr 14 11:25:36 2015 +0800

    ALSA: hda - set GET bit when adding a vendor verb to the codec regmap
    
    Some HD-A codecs may add their own vendor 'set' verb to the regmap, thru func
    snd_hdac_add_vendor_verb(). This patch sets the GET bit (bit 11)  when adding
    the verb so that its peer vendor 'get' verb is actually added. This can avoid
    I/O error when writing the 'set' verb thru remap, since HD-A regmap internally
    looks up a writable vendor verb with GET bit set at first.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 51f1b5c8a91c..7371e0c3926f 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -368,7 +368,7 @@ int snd_hdac_regmap_add_vendor_verb(struct hdac_device *codec,
 
 	if (!p)
 		return -ENOMEM;
-	*p = verb;
+	*p = verb | 0x800; /* set GET bit */
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_hdac_regmap_add_vendor_verb);

commit 9efe2731db3a8944d26233bb47532011411810fb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 9 07:58:46 2015 +0200

    ALSA: hda - Always allow access for POWER_STATE verbs via regmap
    
    The hdac regmap code checks whether the codec is powered on while
    accessing, but there must be an exception -- the verbs to control the
    power state.
    
    Currently HD-audio driver doesn't access them via regmap, so this
    patch doesn't fix any current behavior, but it's just for future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 64876fa357c9..51f1b5c8a91c 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -239,7 +239,7 @@ static int hda_reg_read(void *context, unsigned int reg, unsigned int *val)
 	int verb = get_verb(reg);
 	int err;
 
-	if (!codec_is_running(codec))
+	if (!codec_is_running(codec) && verb != AC_VERB_GET_POWER_STATE)
 		return -EAGAIN;
 	reg |= (codec->addr << 28);
 	if (is_stereo_amp_verb(reg))
@@ -265,16 +265,16 @@ static int hda_reg_write(void *context, unsigned int reg, unsigned int val)
 	unsigned int verb;
 	int i, bytes, err;
 
-	if (!codec_is_running(codec))
-		return codec->lazy_cache ? 0 : -EAGAIN;
-
 	reg &= ~0x00080000U; /* drop GET bit */
 	reg |= (codec->addr << 28);
+	verb = get_verb(reg);
+
+	if (!codec_is_running(codec) && verb != AC_VERB_SET_POWER_STATE)
+		return codec->lazy_cache ? 0 : -EAGAIN;
 
 	if (is_stereo_amp_verb(reg))
 		return hda_reg_write_stereo_amp(codec, reg, val);
 
-	verb = get_verb(reg);
 	if (verb == AC_VERB_SET_PROC_COEF)
 		return hda_reg_write_coef(codec, reg, val);
 

commit 664c715573c2c116c2d8f5de7d59ce85a98a1751
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 8 11:43:14 2015 +0200

    ALSA: hda - Work around races of power up/down with runtime PM
    
    Currently, snd_hdac_power_up()/down() helpers checks whether the codec
    is being in pm (suspend/resume), and skips the call of runtime get/put
    during it.  This is needed as there are lots of power up/down
    sequences called in the paths that are also used in the PM itself.  An
    example is found in hda_codec.c::codec_exec_verb(), where this can
    power up the codec while it may be called again in its power up
    sequence, too.
    
    The above works in most cases, but sometimes we really want to wait
    for the real power up.  For example, the control element get/put may
    want explicit power up so that the value change is assured to reach to
    the hardware.   Using the current snd_hdac_power_up(), however,
    results in a race, e.g. when it's called during the runtime suspend is
    being performed.  In the worst case, as found in patch_ca0132.c, it
    can even lead to the deadlock because the code assumes the power up
    while it was skipped due to the check above.
    
    For dealing with such cases, this patch makes snd_hdac_power_up() and
    _down() to two variants: with and without in_pm flag check.  The
    version with pm flag check is named as snd_hdac_power_up_pm() while
    the version without pm flag check is still kept as
    snd_hdac_power_up().  (Just because the usage of the former is fewer.)
    
    Then finally, the patch replaces each call potentially done in PM with
    the new _pm() variant.
    
    In theory, we can implement a unified version -- if we can distinguish
    the current context whether it's in the pm path.  But such an
    implementation is cumbersome, so leave the code like this a bit messy
    way for now...
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=96271
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 1eb43209fe2c..64876fa357c9 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -402,9 +402,9 @@ int snd_hdac_regmap_write_raw(struct hdac_device *codec, unsigned int reg,
 
 	err = reg_raw_write(codec, reg, val);
 	if (err == -EAGAIN) {
-		snd_hdac_power_up(codec);
+		snd_hdac_power_up_pm(codec);
 		err = reg_raw_write(codec, reg, val);
-		snd_hdac_power_down(codec);
+		snd_hdac_power_down_pm(codec);
 	}
 	return err;
 }
@@ -434,9 +434,9 @@ int snd_hdac_regmap_read_raw(struct hdac_device *codec, unsigned int reg,
 
 	err = reg_raw_read(codec, reg, val);
 	if (err == -EAGAIN) {
-		snd_hdac_power_up(codec);
+		snd_hdac_power_up_pm(codec);
 		err = reg_raw_read(codec, reg, val);
-		snd_hdac_power_down(codec);
+		snd_hdac_power_down_pm(codec);
 	}
 	return err;
 }

commit 9d82f9272ddd8492afdd721c9999171741be835b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 27 14:07:26 2015 +0100

    ALSA: hda - Set use_single_rw flag for regmap
    
    HD-audio doesn't support the bulk access.  Currently it works even
    without this flag as implicitly assumed, but it's safer to set
    explicitly.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index d401e5c69fe3..1eb43209fe2c 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -328,6 +328,7 @@ static const struct regmap_config hda_regmap_cfg = {
 	.cache_type = REGCACHE_RBTREE,
 	.reg_read = hda_reg_read,
 	.reg_write = hda_reg_write,
+	.use_single_rw = true,
 };
 
 int snd_hdac_regmap_init(struct hdac_device *codec)

commit 8bc174e9e3079b2475fb09e244f71fd57de7a802
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 26 14:18:34 2015 +0100

    ALSA: hda - Handle a few verbs as read-only
    
    Although they can be written, handle a few verbs as read-only in
    regmap interface: CONFIG_DEFAULT, CONV and CVT_CHAN_COUNT.  These are
    either updated in PCM or HDMI management code in a volatile manner, or
    just needed only as parameter, thus they don't need to be written at
    resume sync.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index e1dcf104d273..d401e5c69fe3 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -88,7 +88,6 @@ static bool hda_writeable_reg(struct device *dev, unsigned int reg)
 	switch (verb) {
 	case AC_VERB_GET_CONNECT_SEL:
 	case AC_VERB_GET_SDI_SELECT:
-	case AC_VERB_GET_CONV:
 	case AC_VERB_GET_PIN_WIDGET_CONTROL:
 	case AC_VERB_GET_UNSOLICITED_RESPONSE: /* only as SET_UNSOLICITED_ENABLE */
 	case AC_VERB_GET_BEEP_CONTROL:
@@ -96,14 +95,12 @@ static bool hda_writeable_reg(struct device *dev, unsigned int reg)
 	case AC_VERB_GET_DIGI_CONVERT_1:
 	case AC_VERB_GET_DIGI_CONVERT_2: /* only for beep control */
 	case AC_VERB_GET_VOLUME_KNOB_CONTROL:
-	case AC_VERB_GET_CONFIG_DEFAULT:
 	case AC_VERB_GET_GPIO_MASK:
 	case AC_VERB_GET_GPIO_DIRECTION:
 	case AC_VERB_GET_GPIO_DATA: /* not for volatile read */
 	case AC_VERB_GET_GPIO_WAKE_MASK:
 	case AC_VERB_GET_GPIO_UNSOLICITED_RSP_MASK:
 	case AC_VERB_GET_GPIO_STICKY_MASK:
-	case AC_VERB_GET_CVT_CHAN_COUNT:
 		return true;
 	}
 
@@ -123,6 +120,13 @@ static bool hda_readable_reg(struct device *dev, unsigned int reg)
 	case AC_VERB_GET_CONNECT_LIST:
 	case AC_VERB_GET_SUBSYSTEM_ID:
 		return true;
+	/* below are basically writable, but disabled for reducing unnecessary
+	 * writes at sync
+	 */
+	case AC_VERB_GET_CONFIG_DEFAULT: /* usually just read */
+	case AC_VERB_GET_CONV: /* managed in PCM code */
+	case AC_VERB_GET_CVT_CHAN_COUNT: /* managed in HDMI CA code */
+		return true;
 	}
 
 	return hda_writeable_reg(dev, reg);

commit 40ba66a702b83f46c53456eaaac692fc12f82cb0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 13 15:56:25 2015 +0100

    ALSA: hda - Add cache support for COEF read/write
    
    The 16bit COEF read/write is pretty standard for many codecs, and they
    can be cached in most cases -- more importantly, they need to be
    restored at resume.  For making this easier, add the cache support to
    regmap.  If the codec driver wants to cache the COEF access, set
    codec->cache_coef flag and issue AC_VERB_GET_PROC_COEF with the coef
    index in LSB 8 bits.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 2eea8d4e6a7f..e1dcf104d273 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -33,10 +33,12 @@
 
 static bool hda_volatile_reg(struct device *dev, unsigned int reg)
 {
+	struct hdac_device *codec = dev_to_hdac_dev(dev);
 	unsigned int verb = get_verb(reg);
 
 	switch (verb) {
 	case AC_VERB_GET_PROC_COEF:
+		return !codec->cache_coef;
 	case AC_VERB_GET_COEF_INDEX:
 	case AC_VERB_GET_PROC_STATE:
 	case AC_VERB_GET_POWER_STATE:
@@ -75,6 +77,8 @@ static bool hda_writeable_reg(struct device *dev, unsigned int reg)
 	case AC_VERB_GET_STREAM_FORMAT:
 	case AC_VERB_GET_AMP_GAIN_MUTE:
 		return true;
+	case AC_VERB_GET_PROC_COEF:
+		return codec->cache_coef;
 	case 0xf00:
 		break;
 	default:
@@ -188,9 +192,47 @@ static int hda_reg_write_stereo_amp(struct hdac_device *codec,
 	return 0;
 }
 
+/* read a pseudo coef register (16bit) */
+static int hda_reg_read_coef(struct hdac_device *codec, unsigned int reg,
+			     unsigned int *val)
+{
+	unsigned int verb;
+	int err;
+
+	if (!codec->cache_coef)
+		return -EINVAL;
+	/* LSB 8bit = coef index */
+	verb = (reg & ~0xfff00) | (AC_VERB_SET_COEF_INDEX << 8);
+	err = snd_hdac_exec_verb(codec, verb, 0, NULL);
+	if (err < 0)
+		return err;
+	verb = (reg & ~0xfffff) | (AC_VERB_GET_COEF_INDEX << 8);
+	return snd_hdac_exec_verb(codec, verb, 0, val);
+}
+
+/* write a pseudo coef register (16bit) */
+static int hda_reg_write_coef(struct hdac_device *codec, unsigned int reg,
+			      unsigned int val)
+{
+	unsigned int verb;
+	int err;
+
+	if (!codec->cache_coef)
+		return -EINVAL;
+	/* LSB 8bit = coef index */
+	verb = (reg & ~0xfff00) | (AC_VERB_SET_COEF_INDEX << 8);
+	err = snd_hdac_exec_verb(codec, verb, 0, NULL);
+	if (err < 0)
+		return err;
+	verb = (reg & ~0xfffff) | (AC_VERB_GET_COEF_INDEX << 8) |
+		(val & 0xffff);
+	return snd_hdac_exec_verb(codec, verb, 0, NULL);
+}
+
 static int hda_reg_read(void *context, unsigned int reg, unsigned int *val)
 {
 	struct hdac_device *codec = context;
+	int verb = get_verb(reg);
 	int err;
 
 	if (!codec_is_running(codec))
@@ -198,11 +240,13 @@ static int hda_reg_read(void *context, unsigned int reg, unsigned int *val)
 	reg |= (codec->addr << 28);
 	if (is_stereo_amp_verb(reg))
 		return hda_reg_read_stereo_amp(codec, reg, val);
+	if (verb == AC_VERB_GET_PROC_COEF)
+		return hda_reg_read_coef(codec, reg, val);
 	err = snd_hdac_exec_verb(codec, reg, 0, val);
 	if (err < 0)
 		return err;
 	/* special handling for asymmetric reads */
-	if (get_verb(reg) == AC_VERB_GET_POWER_STATE) {
+	if (verb == AC_VERB_GET_POWER_STATE) {
 		if (*val & AC_PWRST_ERROR)
 			*val = -1;
 		else /* take only the actual state */
@@ -227,6 +271,9 @@ static int hda_reg_write(void *context, unsigned int reg, unsigned int val)
 		return hda_reg_write_stereo_amp(codec, reg, val);
 
 	verb = get_verb(reg);
+	if (verb == AC_VERB_SET_PROC_COEF)
+		return hda_reg_write_coef(codec, reg, val);
+
 	switch (verb & 0xf00) {
 	case AC_VERB_SET_AMP_GAIN_MUTE:
 		verb = AC_VERB_SET_AMP_GAIN_MUTE;

commit 33f819400659da9ff9f636b78f33ff4f1f08cbd4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 9 22:19:47 2015 +0100

    ALSA: hda - Handle get/set power verb symmetrically via regmap
    
    HD-audio has quite a few asymmetrical ways of accessing verbs, and one
    of typical ones is GET/SET_POWER_STATE verbs.  While it takes only the
    power state for setting, it returns a combination of states for
    getting.  For making the state handling simpler, this patch adds a
    code to translate the value returned from GET_POWER_STATE to return
    only the actual state or -1 for error.  In that way, the driver can
    simplify the power state management.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index fb4a02e0319f..2eea8d4e6a7f 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -191,13 +191,24 @@ static int hda_reg_write_stereo_amp(struct hdac_device *codec,
 static int hda_reg_read(void *context, unsigned int reg, unsigned int *val)
 {
 	struct hdac_device *codec = context;
+	int err;
 
 	if (!codec_is_running(codec))
 		return -EAGAIN;
 	reg |= (codec->addr << 28);
 	if (is_stereo_amp_verb(reg))
 		return hda_reg_read_stereo_amp(codec, reg, val);
-	return snd_hdac_exec_verb(codec, reg, 0, val);
+	err = snd_hdac_exec_verb(codec, reg, 0, val);
+	if (err < 0)
+		return err;
+	/* special handling for asymmetric reads */
+	if (get_verb(reg) == AC_VERB_GET_POWER_STATE) {
+		if (*val & AC_PWRST_ERROR)
+			*val = -1;
+		else /* take only the actual state */
+			*val = (*val >> 4) & 0x0f;
+	}
+	return 0;
 }
 
 static int hda_reg_write(void *context, unsigned int reg, unsigned int val)

commit d313e0a88d1b29d17198ef659af042a633a2d3de
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 4 20:43:20 2015 +0100

    ALSA: hda - Add a fake stereo amp register support
    
    HD-audio spec is inconvenient regarding the handling of stereo volume
    controls.  It can set and get only single channel at once (although
    there is a special option to set the same value to both channels).
    This patch provides a fake pseudo-register via the regmap access so
    that the stereo channels can be read and written by a single call.
    It'd be useful, for example, for implementing DAPM widgets.
    
    A stereo amp pseudo register consists of the encoding like the normal
    amp verbs but it has both SET_LEFT (bit 13) and SET_RIGHT (bit 12)
    bits set.  The regmap reads and writes a 16bit value for this pseudo
    register where the upper 8bit is for the right chanel and the lower
    8bit for the left channel.
    
    Note that the driver doesn't recognize conflicts when both stereo and
    mono channel registers are mixed.  Mixing them would certainly confuse
    the operation.  So, use carefully.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 486ef720cbff..fb4a02e0319f 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -124,6 +124,70 @@ static bool hda_readable_reg(struct device *dev, unsigned int reg)
 	return hda_writeable_reg(dev, reg);
 }
 
+/*
+ * Stereo amp pseudo register:
+ * for making easier to handle the stereo volume control, we provide a
+ * fake register to deal both left and right channels by a single
+ * (pseudo) register access.  A verb consisting of SET_AMP_GAIN with
+ * *both* SET_LEFT and SET_RIGHT bits takes a 16bit value, the lower 8bit
+ * for the left and the upper 8bit for the right channel.
+ */
+static bool is_stereo_amp_verb(unsigned int reg)
+{
+	if (((reg >> 8) & 0x700) != AC_VERB_SET_AMP_GAIN_MUTE)
+		return false;
+	return (reg & (AC_AMP_SET_LEFT | AC_AMP_SET_RIGHT)) ==
+		(AC_AMP_SET_LEFT | AC_AMP_SET_RIGHT);
+}
+
+/* read a pseudo stereo amp register (16bit left+right) */
+static int hda_reg_read_stereo_amp(struct hdac_device *codec,
+				   unsigned int reg, unsigned int *val)
+{
+	unsigned int left, right;
+	int err;
+
+	reg &= ~(AC_AMP_SET_LEFT | AC_AMP_SET_RIGHT);
+	err = snd_hdac_exec_verb(codec, reg | AC_AMP_GET_LEFT, 0, &left);
+	if (err < 0)
+		return err;
+	err = snd_hdac_exec_verb(codec, reg | AC_AMP_GET_RIGHT, 0, &right);
+	if (err < 0)
+		return err;
+	*val = left | (right << 8);
+	return 0;
+}
+
+/* write a pseudo stereo amp register (16bit left+right) */
+static int hda_reg_write_stereo_amp(struct hdac_device *codec,
+				    unsigned int reg, unsigned int val)
+{
+	int err;
+	unsigned int verb, left, right;
+
+	verb = AC_VERB_SET_AMP_GAIN_MUTE << 8;
+	if (reg & AC_AMP_GET_OUTPUT)
+		verb |= AC_AMP_SET_OUTPUT;
+	else
+		verb |= AC_AMP_SET_INPUT | ((reg & 0xf) << 8);
+	reg = (reg & ~0xfffff) | verb;
+
+	left = val & 0xff;
+	right = (val >> 8) & 0xff;
+	if (left == right) {
+		reg |= AC_AMP_SET_LEFT | AC_AMP_SET_RIGHT;
+		return snd_hdac_exec_verb(codec, reg | left, 0, NULL);
+	}
+
+	err = snd_hdac_exec_verb(codec, reg | AC_AMP_SET_LEFT | left, 0, NULL);
+	if (err < 0)
+		return err;
+	err = snd_hdac_exec_verb(codec, reg | AC_AMP_SET_RIGHT | right, 0, NULL);
+	if (err < 0)
+		return err;
+	return 0;
+}
+
 static int hda_reg_read(void *context, unsigned int reg, unsigned int *val)
 {
 	struct hdac_device *codec = context;
@@ -131,6 +195,8 @@ static int hda_reg_read(void *context, unsigned int reg, unsigned int *val)
 	if (!codec_is_running(codec))
 		return -EAGAIN;
 	reg |= (codec->addr << 28);
+	if (is_stereo_amp_verb(reg))
+		return hda_reg_read_stereo_amp(codec, reg, val);
 	return snd_hdac_exec_verb(codec, reg, 0, val);
 }
 
@@ -145,8 +211,11 @@ static int hda_reg_write(void *context, unsigned int reg, unsigned int val)
 
 	reg &= ~0x00080000U; /* drop GET bit */
 	reg |= (codec->addr << 28);
-	verb = get_verb(reg);
 
+	if (is_stereo_amp_verb(reg))
+		return hda_reg_write_stereo_amp(codec, reg, val);
+
+	verb = get_verb(reg);
 	switch (verb & 0xf00) {
 	case AC_VERB_SET_AMP_GAIN_MUTE:
 		verb = AC_VERB_SET_AMP_GAIN_MUTE;

commit 5e56bcea5017b7b7808df60f21ef01738b6e1a25
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 26 12:29:03 2015 +0100

    ALSA: hda - Allow driver to add vendor-specific verbs for regmap
    
    Codecs may have own vendor-specific verbs, and we need to allow each
    driver to give such verbs for cached accesses.  Here a verb can be put
    into a single array and looked through it at readable and writeable
    callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index 933907b16457..486ef720cbff 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -60,6 +60,13 @@ static bool hda_writeable_reg(struct device *dev, unsigned int reg)
 {
 	struct hdac_device *codec = dev_to_hdac_dev(dev);
 	unsigned int verb = get_verb(reg);
+	int i;
+
+	for (i = 0; i < codec->vendor_verbs.used; i++) {
+		unsigned int *v = snd_array_elem(&codec->vendor_verbs, i);
+		if (verb == *v)
+			return true;
+	}
 
 	if (codec->caps_overwriting)
 		return true;
@@ -200,6 +207,7 @@ int snd_hdac_regmap_init(struct hdac_device *codec)
 	if (IS_ERR(regmap))
 		return PTR_ERR(regmap);
 	codec->regmap = regmap;
+	snd_array_init(&codec->vendor_verbs, sizeof(unsigned int), 8);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_hdac_regmap_init);
@@ -209,10 +217,30 @@ void snd_hdac_regmap_exit(struct hdac_device *codec)
 	if (codec->regmap) {
 		regmap_exit(codec->regmap);
 		codec->regmap = NULL;
+		snd_array_free(&codec->vendor_verbs);
 	}
 }
 EXPORT_SYMBOL_GPL(snd_hdac_regmap_exit);
 
+/**
+ * snd_hdac_regmap_add_vendor_verb - add a vendor-specific verb to regmap
+ * @codec: the codec object
+ * @verb: verb to allow accessing via regmap
+ *
+ * Returns zero for success or a negative error code.
+ */
+int snd_hdac_regmap_add_vendor_verb(struct hdac_device *codec,
+				    unsigned int verb)
+{
+	unsigned int *p = snd_array_new(&codec->vendor_verbs);
+
+	if (!p)
+		return -ENOMEM;
+	*p = verb;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_regmap_add_vendor_verb);
+
 /*
  * helper functions
  */

commit faa75f8a2edf005a5caf43be4875ffeeb9bcb498
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 26 08:54:56 2015 +0100

    ALSA: hda - Use regmap for parameter caches, too
    
    The amp hash table was used for recording the cached reads of some
    capability values like pin caps or amp caps.  Now all these are moved
    to regmap as well.
    
    One addition to the regmap helper is codec->caps_overwriting flag.
    This is set in snd_hdac_override_parm(), and the regmap helper accepts
    any register while this flag is set, so that it can overwrite even the
    read-only verb like AC_VERB_PARAMETERS.  The flag is cleared
    immediately in snd_hdac_override_parm(), as it's a once-off flag.
    
    Along with these changes, the no longer needed amp hash and relevant
    fields are removed from hda_codec struct now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
index db03d60d9c99..933907b16457 100644
--- a/sound/hda/hdac_regmap.c
+++ b/sound/hda/hdac_regmap.c
@@ -58,8 +58,12 @@ static bool hda_volatile_reg(struct device *dev, unsigned int reg)
 
 static bool hda_writeable_reg(struct device *dev, unsigned int reg)
 {
+	struct hdac_device *codec = dev_to_hdac_dev(dev);
 	unsigned int verb = get_verb(reg);
 
+	if (codec->caps_overwriting)
+		return true;
+
 	switch (verb & 0xf00) {
 	case AC_VERB_GET_STREAM_FORMAT:
 	case AC_VERB_GET_AMP_GAIN_MUTE:
@@ -97,8 +101,12 @@ static bool hda_writeable_reg(struct device *dev, unsigned int reg)
 
 static bool hda_readable_reg(struct device *dev, unsigned int reg)
 {
+	struct hdac_device *codec = dev_to_hdac_dev(dev);
 	unsigned int verb = get_verb(reg);
 
+	if (codec->caps_overwriting)
+		return true;
+
 	switch (verb) {
 	case AC_VERB_PARAMETERS:
 	case AC_VERB_GET_CONNECT_LIST:

commit 4d75faa0448a6bb2fd6d56051a3675a3937cbada
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 25 14:42:38 2015 +0100

    ALSA: hda - Add regmap support
    
    This patch adds an infrastructure to support regmap-based verb
    accesses.  Because o the asymmetric nature of HD-audio verbs,
    especially the amp verbs, we need to translate the verbs as a sort of
    pseudo registers to be mapped uniquely in regmap.
    
    In this patch, a pseudo register is built from the NID, the
    AC_VERB_GET_* and 8bit parameters, i.e. almost in the form to be sent
    to HD-audio bus but without codec address field.  OTOH, for writing,
    the same pseudo register is translated to AC_VERB_SET_* automatically.
    The AC_VERB_SET_AMP_* verb is re-encoded from the corresponding
    AC_VERB_GET_AMP_* verb and parameter at writing.
    
    Some verbs has a single command for read but multiple for writes.  A
    write for such a verb is split automatically to multiple verbs.
    
    The patch provides also a few handy helper functions.  They are
    designed to be accessible even without regmap.  When no regmap is set
    up (e.g. before the codec device instantiation), the direct hardware
    access is used.  Also, it tries to avoid the unnecessary power-up.
    The power up/down sequence is performed only on demand.
    
    The codec driver needs to call snd_hdac_regmap_exit() and
    snd_hdac_regmap_exit() at probe and remove if it wants the regmap
    access.
    
    There is one flag added to hdac_device.  When the flag lazy_cache is
    set, regmap helper ignores a write for a suspended device and returns
    as if it was actually written.  It reduces the hardware access pretty
    much, e.g. when adjusting the mixer volume while in idle.  This
    assumes that the driver will sync the cache later at resume properly,
    so use it carefully.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_regmap.c b/sound/hda/hdac_regmap.c
new file mode 100644
index 000000000000..db03d60d9c99
--- /dev/null
+++ b/sound/hda/hdac_regmap.c
@@ -0,0 +1,304 @@
+/*
+ * Regmap support for HD-audio verbs
+ *
+ * A virtual register is translated to one or more hda verbs for write,
+ * vice versa for read.
+ *
+ * A few limitations:
+ * - Provided for not all verbs but only subset standard non-volatile verbs.
+ * - For reading, only AC_VERB_GET_* variants can be used.
+ * - For writing, mapped to the *corresponding* AC_VERB_SET_* variants,
+ *   so can't handle asymmetric verbs for read and write
+ */
+
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/regmap.h>
+#include <linux/export.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <sound/core.h>
+#include <sound/hdaudio.h>
+#include <sound/hda_regmap.h>
+
+#ifdef CONFIG_PM
+#define codec_is_running(codec)				\
+	(atomic_read(&(codec)->in_pm) ||		\
+	 !pm_runtime_suspended(&(codec)->dev))
+#else
+#define codec_is_running(codec)		true
+#endif
+
+#define get_verb(reg)	(((reg) >> 8) & 0xfff)
+
+static bool hda_volatile_reg(struct device *dev, unsigned int reg)
+{
+	unsigned int verb = get_verb(reg);
+
+	switch (verb) {
+	case AC_VERB_GET_PROC_COEF:
+	case AC_VERB_GET_COEF_INDEX:
+	case AC_VERB_GET_PROC_STATE:
+	case AC_VERB_GET_POWER_STATE:
+	case AC_VERB_GET_PIN_SENSE:
+	case AC_VERB_GET_HDMI_DIP_SIZE:
+	case AC_VERB_GET_HDMI_ELDD:
+	case AC_VERB_GET_HDMI_DIP_INDEX:
+	case AC_VERB_GET_HDMI_DIP_DATA:
+	case AC_VERB_GET_HDMI_DIP_XMIT:
+	case AC_VERB_GET_HDMI_CP_CTRL:
+	case AC_VERB_GET_HDMI_CHAN_SLOT:
+	case AC_VERB_GET_DEVICE_SEL:
+	case AC_VERB_GET_DEVICE_LIST:	/* read-only volatile */
+		return true;
+	}
+
+	return false;
+}
+
+static bool hda_writeable_reg(struct device *dev, unsigned int reg)
+{
+	unsigned int verb = get_verb(reg);
+
+	switch (verb & 0xf00) {
+	case AC_VERB_GET_STREAM_FORMAT:
+	case AC_VERB_GET_AMP_GAIN_MUTE:
+		return true;
+	case 0xf00:
+		break;
+	default:
+		return false;
+	}
+
+	switch (verb) {
+	case AC_VERB_GET_CONNECT_SEL:
+	case AC_VERB_GET_SDI_SELECT:
+	case AC_VERB_GET_CONV:
+	case AC_VERB_GET_PIN_WIDGET_CONTROL:
+	case AC_VERB_GET_UNSOLICITED_RESPONSE: /* only as SET_UNSOLICITED_ENABLE */
+	case AC_VERB_GET_BEEP_CONTROL:
+	case AC_VERB_GET_EAPD_BTLENABLE:
+	case AC_VERB_GET_DIGI_CONVERT_1:
+	case AC_VERB_GET_DIGI_CONVERT_2: /* only for beep control */
+	case AC_VERB_GET_VOLUME_KNOB_CONTROL:
+	case AC_VERB_GET_CONFIG_DEFAULT:
+	case AC_VERB_GET_GPIO_MASK:
+	case AC_VERB_GET_GPIO_DIRECTION:
+	case AC_VERB_GET_GPIO_DATA: /* not for volatile read */
+	case AC_VERB_GET_GPIO_WAKE_MASK:
+	case AC_VERB_GET_GPIO_UNSOLICITED_RSP_MASK:
+	case AC_VERB_GET_GPIO_STICKY_MASK:
+	case AC_VERB_GET_CVT_CHAN_COUNT:
+		return true;
+	}
+
+	return false;
+}
+
+static bool hda_readable_reg(struct device *dev, unsigned int reg)
+{
+	unsigned int verb = get_verb(reg);
+
+	switch (verb) {
+	case AC_VERB_PARAMETERS:
+	case AC_VERB_GET_CONNECT_LIST:
+	case AC_VERB_GET_SUBSYSTEM_ID:
+		return true;
+	}
+
+	return hda_writeable_reg(dev, reg);
+}
+
+static int hda_reg_read(void *context, unsigned int reg, unsigned int *val)
+{
+	struct hdac_device *codec = context;
+
+	if (!codec_is_running(codec))
+		return -EAGAIN;
+	reg |= (codec->addr << 28);
+	return snd_hdac_exec_verb(codec, reg, 0, val);
+}
+
+static int hda_reg_write(void *context, unsigned int reg, unsigned int val)
+{
+	struct hdac_device *codec = context;
+	unsigned int verb;
+	int i, bytes, err;
+
+	if (!codec_is_running(codec))
+		return codec->lazy_cache ? 0 : -EAGAIN;
+
+	reg &= ~0x00080000U; /* drop GET bit */
+	reg |= (codec->addr << 28);
+	verb = get_verb(reg);
+
+	switch (verb & 0xf00) {
+	case AC_VERB_SET_AMP_GAIN_MUTE:
+		verb = AC_VERB_SET_AMP_GAIN_MUTE;
+		if (reg & AC_AMP_GET_LEFT)
+			verb |= AC_AMP_SET_LEFT >> 8;
+		else
+			verb |= AC_AMP_SET_RIGHT >> 8;
+		if (reg & AC_AMP_GET_OUTPUT) {
+			verb |= AC_AMP_SET_OUTPUT >> 8;
+		} else {
+			verb |= AC_AMP_SET_INPUT >> 8;
+			verb |= reg & 0xf;
+		}
+		break;
+	}
+
+	switch (verb) {
+	case AC_VERB_SET_DIGI_CONVERT_1:
+		bytes = 2;
+		break;
+	case AC_VERB_SET_CONFIG_DEFAULT_BYTES_0:
+		bytes = 4;
+		break;
+	default:
+		bytes = 1;
+		break;
+	}
+
+	for (i = 0; i < bytes; i++) {
+		reg &= ~0xfffff;
+		reg |= (verb + i) << 8 | ((val >> (8 * i)) & 0xff);
+		err = snd_hdac_exec_verb(codec, reg, 0, NULL);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static const struct regmap_config hda_regmap_cfg = {
+	.name = "hdaudio",
+	.reg_bits = 32,
+	.val_bits = 32,
+	.max_register = 0xfffffff,
+	.writeable_reg = hda_writeable_reg,
+	.readable_reg = hda_readable_reg,
+	.volatile_reg = hda_volatile_reg,
+	.cache_type = REGCACHE_RBTREE,
+	.reg_read = hda_reg_read,
+	.reg_write = hda_reg_write,
+};
+
+int snd_hdac_regmap_init(struct hdac_device *codec)
+{
+	struct regmap *regmap;
+
+	regmap = regmap_init(&codec->dev, NULL, codec, &hda_regmap_cfg);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+	codec->regmap = regmap;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_regmap_init);
+
+void snd_hdac_regmap_exit(struct hdac_device *codec)
+{
+	if (codec->regmap) {
+		regmap_exit(codec->regmap);
+		codec->regmap = NULL;
+	}
+}
+EXPORT_SYMBOL_GPL(snd_hdac_regmap_exit);
+
+/*
+ * helper functions
+ */
+
+/* write a pseudo-register value (w/o power sequence) */
+static int reg_raw_write(struct hdac_device *codec, unsigned int reg,
+			 unsigned int val)
+{
+	if (!codec->regmap)
+		return hda_reg_write(codec, reg, val);
+	else
+		return regmap_write(codec->regmap, reg, val);
+}
+
+/**
+ * snd_hdac_regmap_write_raw - write a pseudo register with power mgmt
+ * @codec: the codec object
+ * @reg: pseudo register
+ * @val: value to write
+ *
+ * Returns zero if successful or a negative error code.
+ */
+int snd_hdac_regmap_write_raw(struct hdac_device *codec, unsigned int reg,
+			      unsigned int val)
+{
+	int err;
+
+	err = reg_raw_write(codec, reg, val);
+	if (err == -EAGAIN) {
+		snd_hdac_power_up(codec);
+		err = reg_raw_write(codec, reg, val);
+		snd_hdac_power_down(codec);
+	}
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_regmap_write_raw);
+
+static int reg_raw_read(struct hdac_device *codec, unsigned int reg,
+			unsigned int *val)
+{
+	if (!codec->regmap)
+		return hda_reg_read(codec, reg, val);
+	else
+		return regmap_read(codec->regmap, reg, val);
+}
+
+/**
+ * snd_hdac_regmap_read_raw - read a pseudo register with power mgmt
+ * @codec: the codec object
+ * @reg: pseudo register
+ * @val: pointer to store the read value
+ *
+ * Returns zero if successful or a negative error code.
+ */
+int snd_hdac_regmap_read_raw(struct hdac_device *codec, unsigned int reg,
+			     unsigned int *val)
+{
+	int err;
+
+	err = reg_raw_read(codec, reg, val);
+	if (err == -EAGAIN) {
+		snd_hdac_power_up(codec);
+		err = reg_raw_read(codec, reg, val);
+		snd_hdac_power_down(codec);
+	}
+	return err;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_regmap_read_raw);
+
+/**
+ * snd_hdac_regmap_update_raw - update a pseudo register with power mgmt
+ * @codec: the codec object
+ * @reg: pseudo register
+ * @mask: bit mask to udpate
+ * @val: value to update
+ *
+ * Returns zero if successful or a negative error code.
+ */
+int snd_hdac_regmap_update_raw(struct hdac_device *codec, unsigned int reg,
+			       unsigned int mask, unsigned int val)
+{
+	unsigned int orig;
+	int err;
+
+	val &= mask;
+	err = snd_hdac_regmap_read_raw(codec, reg, &orig);
+	if (err < 0)
+		return err;
+	val |= orig & ~mask;
+	if (val == orig)
+		return 0;
+	err = snd_hdac_regmap_write_raw(codec, reg, val);
+	if (err < 0)
+		return err;
+	return 1;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_regmap_update_raw);
