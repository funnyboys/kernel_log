commit 74bf71ed792ab0f64631cc65ccdb54c356c36d45
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Fri Jul 26 23:47:02 2019 +0200

    ALSA: hda: Fix 1-minute detection delay when i915 module is not available
    
    Distribution installation images such as Debian include different sets
    of modules which can be downloaded dynamically.  Such images may notably
    include the hda sound modules but not the i915 DRM module, even if the
    latter was enabled at build time, as reported on
    https://bugs.debian.org/931507
    
    In such a case hdac_i915 would be linked in and try to load the i915
    module, fail since it is not there, but still wait for a whole minute
    before giving up binding with it.
    
    This fixes such as case by only waiting for the binding if the module
    was properly loaded (or module support is disabled, in which case i915
    is already compiled-in anyway).
    
    Fixes: f9b54e1961c7 ("ALSA: hda/i915: Allow delayed i915 audio component binding")
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 1192c7561d62..3c2db3816029 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -136,10 +136,12 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 	if (!acomp)
 		return -ENODEV;
 	if (!acomp->ops) {
-		request_module("i915");
-		/* 60s timeout */
-		wait_for_completion_timeout(&bind_complete,
-					    msecs_to_jiffies(60 * 1000));
+		if (!IS_ENABLED(CONFIG_MODULES) ||
+		    !request_module("i915")) {
+			/* 60s timeout */
+			wait_for_completion_timeout(&bind_complete,
+						   msecs_to_jiffies(60 * 1000));
+		}
 	}
 	if (!acomp->ops) {
 		dev_info(bus->dev, "couldn't bind with audio component\n");

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 575198bd3cd0..1192c7561d62 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -1,15 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  hdac_i915.c - routines for sync between HD-A core and i915 display driver
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the Free
- *  Software Foundation; either version 2 of the License, or (at your option)
- *  any later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  for more details.
  */
 
 #include <linux/init.h>

commit 45763bf4bc1ebdf8eb95697607e1fd042a3e1221
Merge: da2577fe63f8 142a0f83b216
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 6 14:18:59 2019 -0800

    Merge tag 'char-misc-5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc
    
    Pull char/misc driver updates from Greg KH:
     "Here is the big char/misc driver patch pull request for 5.1-rc1.
    
      The largest thing by far is the new habanalabs driver for their AI
      accelerator chip. For now it is in the drivers/misc directory but will
      probably move to a new directory soon along with other drivers of this
      type.
    
      Other than that, just the usual set of individual driver updates and
      fixes. There's an "odd" merge in here from the DRM tree that they
      asked me to do as the MEI driver is starting to interact with the i915
      driver, and it needed some coordination. All of those patches have
      been properly acked by the relevant subsystem maintainers.
    
      All of these have been in linux-next with no reported issues, most for
      quite some time"
    
    * tag 'char-misc-5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc: (219 commits)
      habanalabs: adjust Kconfig to fix build errors
      habanalabs: use %px instead of %p in error print
      habanalabs: use do_div for 64-bit divisions
      intel_th: gth: Fix an off-by-one in output unassigning
      habanalabs: fix little-endian<->cpu conversion warnings
      habanalabs: use NULL to initialize array of pointers
      habanalabs: fix little-endian<->cpu conversion warnings
      habanalabs: soft-reset device if context-switch fails
      habanalabs: print pointer using %p
      habanalabs: fix memory leak with CBs with unaligned size
      habanalabs: return correct error code on MMU mapping failure
      habanalabs: add comments in uapi/misc/habanalabs.h
      habanalabs: extend QMAN0 job timeout
      habanalabs: set DMA0 completion to SOB 1007
      habanalabs: fix validation of WREG32 to DMA completion
      habanalabs: fix mmu cache registers init
      habanalabs: disable CPU access on timeouts
      habanalabs: add MMU DRAM default page mapping
      habanalabs: Dissociate RAZWI info from event types
      misc/habanalabs: adjust Kconfig to fix build errors
      ...

commit cfc35f9c128cea8fce6a5513b1de50d36f3b209f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 25 16:49:27 2019 +0100

    ALSA: hda: Extend i915 component bind timeout
    
    I set 10 seconds for the timeout of the i915 audio component binding
    with a hope that recent machines are fast enough to handle all probe
    tasks in that period, but I was too optimistic.  The binding may take
    longer than that, and this caused a problem on the machine with both
    audio and graphics driver modules loaded in parallel, as Paul Menzel
    experienced.  This problem haven't hit so often just because the KMS
    driver is loaded in initrd on most machines.
    
    As a simple workaround, extend the timeout to 60 seconds.
    
    Fixes: f9b54e1961c7 ("ALSA: hda/i915: Allow delayed i915 audio component binding")
    Reported-by: Paul Menzel <pmenzel+alsa-devel@molgen.mpg.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 617ff1aa818f..27eb0270a711 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -144,9 +144,9 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 		return -ENODEV;
 	if (!acomp->ops) {
 		request_module("i915");
-		/* 10s timeout */
+		/* 60s timeout */
 		wait_for_completion_timeout(&bind_complete,
-					    msecs_to_jiffies(10 * 1000));
+					    msecs_to_jiffies(60 * 1000));
 	}
 	if (!acomp->ops) {
 		dev_info(bus->dev, "couldn't bind with audio component\n");

commit 8857c7d065e900a0b3829c97634c99501b606541
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Feb 8 00:27:59 2019 +0100

    i915/snd_hdac: I915 subcomponent for the snd_hdac
    
    Since we need multiple components for I915 for different purposes
    (Audio & Mei_hdcp), we adopt the subcomponents methodology introduced
    by the previous patch (mentioned below).
    
            Author: Daniel Vetter <daniel.vetter@ffwll.ch>
            Date:   Mon Jan 28 17:08:20 2019 +0530
    
                components: multiple components for a device
    
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by-by: Ramalingam C <ramalinagm.c@intel.com> (commit message)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch> (code)
    cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: Russell King <rmk+kernel@arm.linux.org.uk>
    cc: Rafael J. Wysocki <rafael@kernel.org>
    cc: Jaroslav Kysela <perex@perex.cz>
    cc: Takashi Iwai <tiwai@suse.com>
    cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    cc: Jani Nikula <jani.nikula@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190207232759.14553-4-daniel.vetter@ffwll.ch

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 617ff1aa818f..7aee090e3d27 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -82,9 +82,11 @@ void snd_hdac_i915_set_bclk(struct hdac_bus *bus)
 }
 EXPORT_SYMBOL_GPL(snd_hdac_i915_set_bclk);
 
-static int i915_component_master_match(struct device *dev, void *data)
+static int i915_component_master_match(struct device *dev, int subcomponent,
+				       void *data)
 {
-	return !strcmp(dev->driver->name, "i915");
+	return !strcmp(dev->driver->name, "i915") &&
+	       subcomponent == I915_COMPONENT_AUDIO;
 }
 
 /* check whether intel graphics is present */

commit b3a5402cbcebaf5a9db4d6a3268070e4a099355d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 18 18:21:11 2018 +0200

    ALSA: hda: Fix the audio-component completion timeout
    
    The timeout of audio component binding was incorrectly specified in
    msec, not in jiffies, which results in way too shorter timeout than
    expected.
    
    Along with fixing it, add the information print about the binding
    failure to show the unexpected situation more clearly.
    
    Fixes: a57942bfdd61 ("ALSA: hda: Make audio component support more generic")
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index b5282cbbe489..617ff1aa818f 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -145,9 +145,11 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 	if (!acomp->ops) {
 		request_module("i915");
 		/* 10s timeout */
-		wait_for_completion_timeout(&bind_complete, 10 * 1000);
+		wait_for_completion_timeout(&bind_complete,
+					    msecs_to_jiffies(10 * 1000));
 	}
 	if (!acomp->ops) {
+		dev_info(bus->dev, "couldn't bind with audio component\n");
 		snd_hdac_acomp_exit(bus);
 		return -ENODEV;
 	}

commit f9b54e1961c7052e7d7817d707826eb2b9a1ca09
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 11 15:05:06 2018 +0200

    ALSA: hda/i915: Allow delayed i915 audio component binding
    
    Currently HD-audio i915 audio binding doesn't support any delayed
    binding, and supposes that the i915 driver registers the component
    immediately.  This has been OK, so far, but the work-in-progress
    change in i915 may introduce the asynchronous binding, which
    effectively delays the component registration.
    
    For addressing it, implement a completion to be synced with the master
    binding.  The timeout is set to 10 seconds which should be long enough
    and hopefully be not too annoying if anyone boots up a debugging
    session with i915 KMS turned off.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 8f2aa8bc1185..b5282cbbe489 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -20,6 +20,8 @@
 #include <sound/hda_i915.h>
 #include <sound/hda_register.h>
 
+static struct completion bind_complete;
+
 #define CONTROLLER_IN_GPU(pci) (((pci)->device == 0x0a0c) || \
 				((pci)->device == 0x0c0c) || \
 				((pci)->device == 0x0d0c) || \
@@ -97,6 +99,19 @@ static bool i915_gfx_present(void)
 	return pci_dev_present(ids);
 }
 
+static int i915_master_bind(struct device *dev,
+			    struct drm_audio_component *acomp)
+{
+	complete_all(&bind_complete);
+	/* clear audio_ops here as it was needed only for completion call */
+	acomp->audio_ops = NULL;
+	return 0;
+}
+
+static const struct drm_audio_component_audio_ops i915_init_ops = {
+	.master_bind = i915_master_bind
+};
+
 /**
  * snd_hdac_i915_init - Initialize i915 audio component
  * @bus: HDA core bus
@@ -117,7 +132,9 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 	if (!i915_gfx_present())
 		return -ENODEV;
 
-	err = snd_hdac_acomp_init(bus, NULL,
+	init_completion(&bind_complete);
+
+	err = snd_hdac_acomp_init(bus, &i915_init_ops,
 				  i915_component_master_match,
 				  sizeof(struct i915_audio_component) - sizeof(*acomp));
 	if (err < 0)
@@ -125,8 +142,11 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 	acomp = bus->audio_component;
 	if (!acomp)
 		return -ENODEV;
-	if (!acomp->ops)
+	if (!acomp->ops) {
 		request_module("i915");
+		/* 10s timeout */
+		wait_for_completion_timeout(&bind_complete, 10 * 1000);
+	}
 	if (!acomp->ops) {
 		snd_hdac_acomp_exit(bus);
 		return -ENODEV;

commit a57942bfdd61b46df94021c9c33b8faaae5b65e1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 11 16:23:16 2018 +0200

    ALSA: hda: Make audio component support more generic
    
    This is the final step for more generic support of DRM audio
    component.  The generic audio component code is now moved to its own
    file, and the symbols are renamed from snd_hac_i915_* to
    snd_hdac_acomp_*, respectively.  The generic code is enabled via the
    new kconfig, CONFIG_SND_HDA_COMPONENT, while CONFIG_SND_HDA_I915 is
    kept as the super-class.
    
    Along with the split, three new callbacks are added to audio_ops:
    pin2port is for providing the conversion between the pin number and
    the widget id, and master_bind/master_unbin are called at binding /
    unbinding the master component, respectively.  All these are optional,
    but used in i915 implementation and also other later implementations.
    
    A note about the new snd_hdac_acomp_init() function: there is a slight
    difference between this and the old snd_hdac_i915_init().  The latter
    (still) synchronizes with the master component binding, i.e. it
    assures that the relevant DRM component gets bound when it returns, or
    gives a negative error.  Meanwhile the new function doesn't
    synchronize but just leaves as is.  It's the responsibility by the
    caller's side to synchronize, or the caller may accept the
    asynchronous binding on the fly.
    
    v1->v2: Fix missing NULL check in master_bind/unbind
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 861b77bbc7df..8f2aa8bc1185 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -15,96 +15,11 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/pci.h>
-#include <linux/component.h>
-#include <drm/drm_audio_component.h>
 #include <sound/core.h>
 #include <sound/hdaudio.h>
 #include <sound/hda_i915.h>
 #include <sound/hda_register.h>
 
-static void hdac_acomp_release(struct device *dev, void *res)
-{
-}
-
-static struct drm_audio_component *hdac_get_acomp(struct device *dev)
-{
-	return devres_find(dev, hdac_acomp_release, NULL, NULL);
-}
-
-/**
- * snd_hdac_set_codec_wakeup - Enable / disable HDMI/DP codec wakeup
- * @bus: HDA core bus
- * @enable: enable or disable the wakeup
- *
- * This function is supposed to be used only by a HD-audio controller
- * driver that needs the interaction with i915 graphics.
- *
- * This function should be called during the chip reset, also called at
- * resume for updating STATESTS register read.
- *
- * Returns zero for success or a negative error code.
- */
-int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable)
-{
-	struct drm_audio_component *acomp = bus->audio_component;
-
-	if (!acomp || !acomp->ops)
-		return -ENODEV;
-
-	if (!acomp->ops->codec_wake_override) {
-		dev_warn(bus->dev,
-			"Invalid codec wake callback\n");
-		return 0;
-	}
-
-	dev_dbg(bus->dev, "%s codec wakeup\n",
-		enable ? "enable" : "disable");
-
-	acomp->ops->codec_wake_override(acomp->dev, enable);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_hdac_set_codec_wakeup);
-
-/**
- * snd_hdac_display_power - Power up / down the power refcount
- * @bus: HDA core bus
- * @enable: power up or down
- *
- * This function is supposed to be used only by a HD-audio controller
- * driver that needs the interaction with i915 graphics.
- *
- * This function manages a refcount and calls the i915 get_power() and
- * put_power() ops accordingly, toggling the codec wakeup, too.
- *
- * Returns zero for success or a negative error code.
- */
-int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
-{
-	struct drm_audio_component *acomp = bus->audio_component;
-
-	if (!acomp || !acomp->ops)
-		return -ENODEV;
-
-	dev_dbg(bus->dev, "display power %s\n",
-		enable ? "enable" : "disable");
-
-	if (enable) {
-		if (!bus->drm_power_refcount++) {
-			acomp->ops->get_power(acomp->dev);
-			snd_hdac_set_codec_wakeup(bus, true);
-			snd_hdac_set_codec_wakeup(bus, false);
-		}
-	} else {
-		WARN_ON(!bus->drm_power_refcount);
-		if (!--bus->drm_power_refcount)
-			acomp->ops->put_power(acomp->dev);
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_hdac_display_power);
-
 #define CONTROLLER_IN_GPU(pci) (((pci)->device == 0x0a0c) || \
 				((pci)->device == 0x0c0c) || \
 				((pci)->device == 0x0d0c) || \
@@ -165,183 +80,11 @@ void snd_hdac_i915_set_bclk(struct hdac_bus *bus)
 }
 EXPORT_SYMBOL_GPL(snd_hdac_i915_set_bclk);
 
-/* There is a fixed mapping between audio pin node and display port.
- * on SNB, IVY, HSW, BSW, SKL, BXT, KBL:
- * Pin Widget 5 - PORT B (port = 1 in i915 driver)
- * Pin Widget 6 - PORT C (port = 2 in i915 driver)
- * Pin Widget 7 - PORT D (port = 3 in i915 driver)
- *
- * on VLV, ILK:
- * Pin Widget 4 - PORT B (port = 1 in i915 driver)
- * Pin Widget 5 - PORT C (port = 2 in i915 driver)
- * Pin Widget 6 - PORT D (port = 3 in i915 driver)
- */
-static int pin2port(struct hdac_device *codec, hda_nid_t pin_nid)
-{
-	int base_nid;
-
-	switch (codec->vendor_id) {
-	case 0x80860054: /* ILK */
-	case 0x80862804: /* ILK */
-	case 0x80862882: /* VLV */
-		base_nid = 3;
-		break;
-	default:
-		base_nid = 4;
-		break;
-	}
-
-	if (WARN_ON(pin_nid <= base_nid || pin_nid > base_nid + 3))
-		return -1;
-	return pin_nid - base_nid;
-}
-
-/**
- * snd_hdac_sync_audio_rate - Set N/CTS based on the sample rate
- * @codec: HDA codec
- * @nid: the pin widget NID
- * @dev_id: device identifier
- * @rate: the sample rate to set
- *
- * This function is supposed to be used only by a HD-audio controller
- * driver that needs the interaction with i915 graphics.
- *
- * This function sets N/CTS value based on the given sample rate.
- * Returns zero for success, or a negative error code.
- */
-int snd_hdac_sync_audio_rate(struct hdac_device *codec, hda_nid_t nid,
-			     int dev_id, int rate)
+static int i915_component_master_match(struct device *dev, void *data)
 {
-	struct hdac_bus *bus = codec->bus;
-	struct drm_audio_component *acomp = bus->audio_component;
-	int port, pipe;
-
-	if (!acomp || !acomp->ops || !acomp->ops->sync_audio_rate)
-		return -ENODEV;
-	port = pin2port(codec, nid);
-	if (port < 0)
-		return -EINVAL;
-	pipe = dev_id;
-	return acomp->ops->sync_audio_rate(acomp->dev, port, pipe, rate);
-}
-EXPORT_SYMBOL_GPL(snd_hdac_sync_audio_rate);
-
-/**
- * snd_hdac_acomp_get_eld - Get the audio state and ELD via component
- * @codec: HDA codec
- * @nid: the pin widget NID
- * @dev_id: device identifier
- * @audio_enabled: the pointer to store the current audio state
- * @buffer: the buffer pointer to store ELD bytes
- * @max_bytes: the max bytes to be stored on @buffer
- *
- * This function is supposed to be used only by a HD-audio controller
- * driver that needs the interaction with i915 graphics.
- *
- * This function queries the current state of the audio on the given
- * digital port and fetches the ELD bytes onto the given buffer.
- * It returns the number of bytes for the total ELD data, zero for
- * invalid ELD, or a negative error code.
- *
- * The return size is the total bytes required for the whole ELD bytes,
- * thus it may be over @max_bytes.  If it's over @max_bytes, it implies
- * that only a part of ELD bytes have been fetched.
- */
-int snd_hdac_acomp_get_eld(struct hdac_device *codec, hda_nid_t nid, int dev_id,
-			   bool *audio_enabled, char *buffer, int max_bytes)
-{
-	struct hdac_bus *bus = codec->bus;
-	struct drm_audio_component *acomp = bus->audio_component;
-	int port, pipe;
-
-	if (!acomp || !acomp->ops || !acomp->ops->get_eld)
-		return -ENODEV;
-
-	port = pin2port(codec, nid);
-	if (port < 0)
-		return -EINVAL;
-
-	pipe = dev_id;
-	return acomp->ops->get_eld(acomp->dev, port, pipe, audio_enabled,
-				   buffer, max_bytes);
-}
-EXPORT_SYMBOL_GPL(snd_hdac_acomp_get_eld);
-
-static int hdac_component_master_bind(struct device *dev)
-{
-	struct drm_audio_component *acomp = hdac_get_acomp(dev);
-	int ret;
-
-	ret = component_bind_all(dev, acomp);
-	if (ret < 0)
-		return ret;
-
-	if (WARN_ON(!(acomp->dev && acomp->ops && acomp->ops->get_power &&
-		      acomp->ops->put_power && acomp->ops->get_cdclk_freq))) {
-		ret = -EINVAL;
-		goto out_unbind;
-	}
-
-	/*
-	 * Atm, we don't support dynamic unbinding initiated by the child
-	 * component, so pin its containing module until we unbind.
-	 */
-	if (!try_module_get(acomp->ops->owner)) {
-		ret = -ENODEV;
-		goto out_unbind;
-	}
-
-	return 0;
-
-out_unbind:
-	component_unbind_all(dev, acomp);
-
-	return ret;
-}
-
-static void hdac_component_master_unbind(struct device *dev)
-{
-	struct drm_audio_component *acomp = hdac_get_acomp(dev);
-
-	module_put(acomp->ops->owner);
-	component_unbind_all(dev, acomp);
-	WARN_ON(acomp->ops || acomp->dev);
-}
-
-static const struct component_master_ops hdac_component_master_ops = {
-	.bind = hdac_component_master_bind,
-	.unbind = hdac_component_master_unbind,
-};
-
-static int hdac_component_master_match(struct device *dev, void *data)
-{
-	/* i915 is the only supported component */
 	return !strcmp(dev->driver->name, "i915");
 }
 
-/**
- * snd_hdac_i915_register_notifier - Register i915 audio component ops
- * @bus: HDA core bus
- * @aops: i915 audio component ops
- *
- * This function is supposed to be used only by a HD-audio controller
- * driver that needs the interaction with i915 graphics.
- *
- * This function sets the given ops to be called by the i915 graphics driver.
- *
- * Returns zero for success or a negative error code.
- */
-int snd_hdac_i915_register_notifier(struct hdac_bus *bus,
-				    const struct drm_audio_component_audio_ops *aops)
-{
-	if (!bus->audio_component)
-		return -ENODEV;
-
-	bus->audio_component->audio_ops = aops;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_hdac_i915_register_notifier);
-
 /* check whether intel graphics is present */
 static bool i915_gfx_present(void)
 {
@@ -368,84 +111,26 @@ static bool i915_gfx_present(void)
  */
 int snd_hdac_i915_init(struct hdac_bus *bus)
 {
-	struct component_match *match = NULL;
-	struct device *dev = bus->dev;
-	struct i915_audio_component *i915_acomp;
 	struct drm_audio_component *acomp;
-	int ret;
-
-	if (WARN_ON(hdac_get_acomp(dev)))
-		return -EBUSY;
+	int err;
 
 	if (!i915_gfx_present())
 		return -ENODEV;
 
-	i915_acomp = devres_alloc(hdac_acomp_release, sizeof(*i915_acomp),
-				  GFP_KERNEL);
-	if (!i915_acomp)
-		return -ENOMEM;
-	acomp = &i915_acomp->base;
-	bus->audio_component = acomp;
-	devres_add(dev, acomp);
-
-	component_match_add(dev, &match, hdac_component_master_match, bus);
-	ret = component_master_add_with_match(dev, &hdac_component_master_ops,
-					      match);
-	if (ret < 0)
-		goto out_err;
-
-	/*
-	 * Atm, we don't support deferring the component binding, so make sure
-	 * i915 is loaded and that the binding successfully completes.
-	 */
-	request_module("i915");
-
+	err = snd_hdac_acomp_init(bus, NULL,
+				  i915_component_master_match,
+				  sizeof(struct i915_audio_component) - sizeof(*acomp));
+	if (err < 0)
+		return err;
+	acomp = bus->audio_component;
+	if (!acomp)
+		return -ENODEV;
+	if (!acomp->ops)
+		request_module("i915");
 	if (!acomp->ops) {
-		ret = -ENODEV;
-		goto out_master_del;
+		snd_hdac_acomp_exit(bus);
+		return -ENODEV;
 	}
-	dev_dbg(dev, "bound to i915 component master\n");
-
 	return 0;
-out_master_del:
-	component_master_del(dev, &hdac_component_master_ops);
-out_err:
-	bus->audio_component = NULL;
-	devres_destroy(dev, hdac_acomp_release, NULL, NULL);
-	dev_info(dev, "failed to add i915 component master (%d)\n", ret);
-
-	return ret;
 }
 EXPORT_SYMBOL_GPL(snd_hdac_i915_init);
-
-/**
- * snd_hdac_i915_exit - Finalize i915 audio component
- * @bus: HDA core bus
- *
- * This function is supposed to be used only by a HD-audio controller
- * driver that needs the interaction with i915 graphics.
- *
- * This function releases the i915 audio component that has been used.
- *
- * Returns zero for success or a negative error code.
- */
-int snd_hdac_i915_exit(struct hdac_bus *bus)
-{
-	struct device *dev = bus->dev;
-	struct drm_audio_component *acomp = bus->audio_component;
-
-	if (!acomp)
-		return 0;
-
-	WARN_ON(bus->drm_power_refcount);
-	if (bus->drm_power_refcount > 0 && acomp->ops)
-		acomp->ops->put_power(acomp->dev);
-
-	component_master_del(dev, &hdac_component_master_ops);
-
-	bus->audio_component = NULL;
-	devres_destroy(dev, hdac_acomp_release, NULL, NULL);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_hdac_i915_exit);

commit 82887c0beb1ee6b33eed8318d8e8d41c5b3eddae
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 11 15:48:18 2018 +0200

    ALSA: hda/i915: Associate audio component with devres
    
    The HD-audio i915 binding code contains a single pointer, hdac_acomp,
    for allowing the access to audio component from the master bind/unbind
    callbacks.  This was needed because the callbacks pass only the device
    pointer and we can't guarantee the object type assigned to the drvdata
    (which is free for each controller driver implementation).
    And this implementation will be a problem if we support multiple
    components for different DRM drivers, not only i915.
    
    As a solution, allocate the audio component object via devres and
    associate it with the given device, so that the component callbacks
    can refer to it via devres_find().
    
    The removal of the object is still done half-manually via
    devres_destroy() to make the code consistent (although it may work
    without the explicit call).
    
    Also, the snd_hda_i915_register_notifier() had the reference to
    hdac_acomp as well.  In this patch, the corresponding code is removed
    by passing hdac_bus object to the function, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 1a88c1aaf9bb..861b77bbc7df 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -22,7 +22,14 @@
 #include <sound/hda_i915.h>
 #include <sound/hda_register.h>
 
-static struct drm_audio_component *hdac_acomp;
+static void hdac_acomp_release(struct device *dev, void *res)
+{
+}
+
+static struct drm_audio_component *hdac_get_acomp(struct device *dev)
+{
+	return devres_find(dev, hdac_acomp_release, NULL, NULL);
+}
 
 /**
  * snd_hdac_set_codec_wakeup - Enable / disable HDMI/DP codec wakeup
@@ -262,7 +269,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_acomp_get_eld);
 
 static int hdac_component_master_bind(struct device *dev)
 {
-	struct drm_audio_component *acomp = hdac_acomp;
+	struct drm_audio_component *acomp = hdac_get_acomp(dev);
 	int ret;
 
 	ret = component_bind_all(dev, acomp);
@@ -294,7 +301,7 @@ static int hdac_component_master_bind(struct device *dev)
 
 static void hdac_component_master_unbind(struct device *dev)
 {
-	struct drm_audio_component *acomp = hdac_acomp;
+	struct drm_audio_component *acomp = hdac_get_acomp(dev);
 
 	module_put(acomp->ops->owner);
 	component_unbind_all(dev, acomp);
@@ -314,6 +321,7 @@ static int hdac_component_master_match(struct device *dev, void *data)
 
 /**
  * snd_hdac_i915_register_notifier - Register i915 audio component ops
+ * @bus: HDA core bus
  * @aops: i915 audio component ops
  *
  * This function is supposed to be used only by a HD-audio controller
@@ -323,12 +331,13 @@ static int hdac_component_master_match(struct device *dev, void *data)
  *
  * Returns zero for success or a negative error code.
  */
-int snd_hdac_i915_register_notifier(const struct drm_audio_component_audio_ops *aops)
+int snd_hdac_i915_register_notifier(struct hdac_bus *bus,
+				    const struct drm_audio_component_audio_ops *aops)
 {
-	if (!hdac_acomp)
+	if (!bus->audio_component)
 		return -ENODEV;
 
-	hdac_acomp->audio_ops = aops;
+	bus->audio_component->audio_ops = aops;
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_hdac_i915_register_notifier);
@@ -365,18 +374,19 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 	struct drm_audio_component *acomp;
 	int ret;
 
-	if (WARN_ON(hdac_acomp))
+	if (WARN_ON(hdac_get_acomp(dev)))
 		return -EBUSY;
 
 	if (!i915_gfx_present())
 		return -ENODEV;
 
-	i915_acomp = kzalloc(sizeof(*i915_acomp), GFP_KERNEL);
+	i915_acomp = devres_alloc(hdac_acomp_release, sizeof(*i915_acomp),
+				  GFP_KERNEL);
 	if (!i915_acomp)
 		return -ENOMEM;
 	acomp = &i915_acomp->base;
 	bus->audio_component = acomp;
-	hdac_acomp = acomp;
+	devres_add(dev, acomp);
 
 	component_match_add(dev, &match, hdac_component_master_match, bus);
 	ret = component_master_add_with_match(dev, &hdac_component_master_ops,
@@ -400,9 +410,8 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 out_master_del:
 	component_master_del(dev, &hdac_component_master_ops);
 out_err:
-	kfree(acomp);
 	bus->audio_component = NULL;
-	hdac_acomp = NULL;
+	devres_destroy(dev, hdac_acomp_release, NULL, NULL);
 	dev_info(dev, "failed to add i915 component master (%d)\n", ret);
 
 	return ret;
@@ -434,9 +443,8 @@ int snd_hdac_i915_exit(struct hdac_bus *bus)
 
 	component_master_del(dev, &hdac_component_master_ops);
 
-	kfree(acomp);
 	bus->audio_component = NULL;
-	hdac_acomp = NULL;
+	devres_destroy(dev, hdac_acomp_release, NULL, NULL);
 
 	return 0;
 }

commit ae891abe7c2ccf75b69ca8330225e37ecc06924e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 11 15:17:22 2018 +0200

    drm/i915: Split audio component to a generic type
    
    For allowing other drivers to use the DRM audio component, rename the
    i915_audio_component_* with drm_audio_component_*, and split the
    generic part into drm_audio_component.h.  The i915 specific stuff
    remains in struct i915_audio_component, which contains
    drm_audio_component as the base.
    
    The license of drm_audio_component.h is kept to MIT as same as the the
    original i915_component.h.
    
    This is a preliminary change for further development, and no
    functional changes by this patch itself, merely code-split and
    renames.
    
    v1->v2: Use SPDX for drm_audio_component.h, fix remaining i915
            argument in drm_audio_component.h
    
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index cbe818eda336..1a88c1aaf9bb 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -16,13 +16,13 @@
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/component.h>
-#include <drm/i915_component.h>
+#include <drm/drm_audio_component.h>
 #include <sound/core.h>
 #include <sound/hdaudio.h>
 #include <sound/hda_i915.h>
 #include <sound/hda_register.h>
 
-static struct i915_audio_component *hdac_acomp;
+static struct drm_audio_component *hdac_acomp;
 
 /**
  * snd_hdac_set_codec_wakeup - Enable / disable HDMI/DP codec wakeup
@@ -39,7 +39,7 @@ static struct i915_audio_component *hdac_acomp;
  */
 int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable)
 {
-	struct i915_audio_component *acomp = bus->audio_component;
+	struct drm_audio_component *acomp = bus->audio_component;
 
 	if (!acomp || !acomp->ops)
 		return -ENODEV;
@@ -74,7 +74,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_set_codec_wakeup);
  */
 int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
 {
-	struct i915_audio_component *acomp = bus->audio_component;
+	struct drm_audio_component *acomp = bus->audio_component;
 
 	if (!acomp || !acomp->ops)
 		return -ENODEV;
@@ -83,14 +83,14 @@ int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
 		enable ? "enable" : "disable");
 
 	if (enable) {
-		if (!bus->i915_power_refcount++) {
+		if (!bus->drm_power_refcount++) {
 			acomp->ops->get_power(acomp->dev);
 			snd_hdac_set_codec_wakeup(bus, true);
 			snd_hdac_set_codec_wakeup(bus, false);
 		}
 	} else {
-		WARN_ON(!bus->i915_power_refcount);
-		if (!--bus->i915_power_refcount)
+		WARN_ON(!bus->drm_power_refcount);
+		if (!--bus->drm_power_refcount)
 			acomp->ops->put_power(acomp->dev);
 	}
 
@@ -119,7 +119,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_display_power);
  */
 void snd_hdac_i915_set_bclk(struct hdac_bus *bus)
 {
-	struct i915_audio_component *acomp = bus->audio_component;
+	struct drm_audio_component *acomp = bus->audio_component;
 	struct pci_dev *pci = to_pci_dev(bus->dev);
 	int cdclk_freq;
 	unsigned int bclk_m, bclk_n;
@@ -206,7 +206,7 @@ int snd_hdac_sync_audio_rate(struct hdac_device *codec, hda_nid_t nid,
 			     int dev_id, int rate)
 {
 	struct hdac_bus *bus = codec->bus;
-	struct i915_audio_component *acomp = bus->audio_component;
+	struct drm_audio_component *acomp = bus->audio_component;
 	int port, pipe;
 
 	if (!acomp || !acomp->ops || !acomp->ops->sync_audio_rate)
@@ -244,7 +244,7 @@ int snd_hdac_acomp_get_eld(struct hdac_device *codec, hda_nid_t nid, int dev_id,
 			   bool *audio_enabled, char *buffer, int max_bytes)
 {
 	struct hdac_bus *bus = codec->bus;
-	struct i915_audio_component *acomp = bus->audio_component;
+	struct drm_audio_component *acomp = bus->audio_component;
 	int port, pipe;
 
 	if (!acomp || !acomp->ops || !acomp->ops->get_eld)
@@ -262,7 +262,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_acomp_get_eld);
 
 static int hdac_component_master_bind(struct device *dev)
 {
-	struct i915_audio_component *acomp = hdac_acomp;
+	struct drm_audio_component *acomp = hdac_acomp;
 	int ret;
 
 	ret = component_bind_all(dev, acomp);
@@ -294,7 +294,7 @@ static int hdac_component_master_bind(struct device *dev)
 
 static void hdac_component_master_unbind(struct device *dev)
 {
-	struct i915_audio_component *acomp = hdac_acomp;
+	struct drm_audio_component *acomp = hdac_acomp;
 
 	module_put(acomp->ops->owner);
 	component_unbind_all(dev, acomp);
@@ -323,7 +323,7 @@ static int hdac_component_master_match(struct device *dev, void *data)
  *
  * Returns zero for success or a negative error code.
  */
-int snd_hdac_i915_register_notifier(const struct i915_audio_component_audio_ops *aops)
+int snd_hdac_i915_register_notifier(const struct drm_audio_component_audio_ops *aops)
 {
 	if (!hdac_acomp)
 		return -ENODEV;
@@ -361,7 +361,8 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 {
 	struct component_match *match = NULL;
 	struct device *dev = bus->dev;
-	struct i915_audio_component *acomp;
+	struct i915_audio_component *i915_acomp;
+	struct drm_audio_component *acomp;
 	int ret;
 
 	if (WARN_ON(hdac_acomp))
@@ -370,9 +371,10 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 	if (!i915_gfx_present())
 		return -ENODEV;
 
-	acomp = kzalloc(sizeof(*acomp), GFP_KERNEL);
-	if (!acomp)
+	i915_acomp = kzalloc(sizeof(*i915_acomp), GFP_KERNEL);
+	if (!i915_acomp)
 		return -ENOMEM;
+	acomp = &i915_acomp->base;
 	bus->audio_component = acomp;
 	hdac_acomp = acomp;
 
@@ -421,13 +423,13 @@ EXPORT_SYMBOL_GPL(snd_hdac_i915_init);
 int snd_hdac_i915_exit(struct hdac_bus *bus)
 {
 	struct device *dev = bus->dev;
-	struct i915_audio_component *acomp = bus->audio_component;
+	struct drm_audio_component *acomp = bus->audio_component;
 
 	if (!acomp)
 		return 0;
 
-	WARN_ON(bus->i915_power_refcount);
-	if (bus->i915_power_refcount > 0 && acomp->ops)
+	WARN_ON(bus->drm_power_refcount);
+	if (bus->drm_power_refcount > 0 && acomp->ops)
 		acomp->ops->put_power(acomp->dev);
 
 	component_master_del(dev, &hdac_component_master_ops);

commit a36c2638380c0a4676647a1f553b70b20d3ebce1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Dec 22 10:45:07 2017 +0100

    ALSA: hda: Drop useless WARN_ON()
    
    Since the commit 97cc2ed27e5a ("ALSA: hda - Fix yet another i915
    pointer leftover in error path") cleared hdac_acomp pointer, the
    WARN_ON() non-NULL check in snd_hdac_i915_register_notifier() may give
    a false-positive warning, as the function gets called no matter
    whether the component is registered or not.  For fixing it, let's get
    rid of the spurious WARN_ON().
    
    Fixes: 97cc2ed27e5a ("ALSA: hda - Fix yet another i915 pointer leftover in error path")
    Cc: <stable@vger.kernel.org>
    Reported-by: Kouta Okamoto <kouta.okamoto@toshiba.co.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 038a180d3f81..cbe818eda336 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -325,7 +325,7 @@ static int hdac_component_master_match(struct device *dev, void *data)
  */
 int snd_hdac_i915_register_notifier(const struct i915_audio_component_audio_ops *aops)
 {
-	if (WARN_ON(!hdac_acomp))
+	if (!hdac_acomp)
 		return -ENODEV;
 
 	hdac_acomp->audio_ops = aops;

commit 6c5a266029cc9b036643d08c2f9340d09ee03708
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue Jul 18 22:35:06 2017 +0530

    ALSA: hda: constify pci_device_id.
    
    pci_device_id are not supposed to change at runtime. All functions
    working with pci_device_id provided by <linux/pci.h> work with
    const pci_device_id. So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
       2610     304       8    2922     b6a sound/hda/hdac_i915.o
    
    File size After adding 'const':
       text    data     bss     dec     hex filename
       2674     240       8    2922     b6a sound/hda/hdac_i915.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 0659bf389489..038a180d3f81 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -336,7 +336,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_i915_register_notifier);
 /* check whether intel graphics is present */
 static bool i915_gfx_present(void)
 {
-	static struct pci_device_id ids[] = {
+	static const struct pci_device_id ids[] = {
 		{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_ANY_ID),
 		  .class = PCI_BASE_CLASS_DISPLAY << 16,
 		  .class_mask = 0xff << 16 },

commit f931894194b9395313d1c34f95ceb8d91f49790d
Author: Pandiyan, Dhinakaran <dhinakaran.pandiyan@intel.com>
Date:   Wed Sep 21 13:02:48 2016 -0700

    drm/i915/dp: DP audio API changes for MST
    
    DP MST provides the capability to send multiple video and audio streams
    through a single port. This requires the API's between i915 and audio
    drivers to distinguish between multiple audio capable displays that can be
    connected to a port. Currently only the port identity is shared in the
    APIs. This patch adds support for MST with an additional parameter
    'int pipe'. The existing parameter 'port' does not change it's meaning.
    
    pipe =
            MST     : display pipe that the stream originates from
            Non-MST : -1
    
    Affected APIs:
    struct i915_audio_component_ops
    -       int (*sync_audio_rate)(struct device *, int port, int rate);
    +       int (*sync_audio_rate)(struct device *, int port, int pipe,
    +            int rate);
    
    -       int (*get_eld)(struct device *, int port, bool *enabled,
    -                       unsigned char *buf, int max_bytes);
    +       int (*get_eld)(struct device *, int port, int pipe,
    +                      bool *enabled, unsigned char *buf, int max_bytes);
    
    struct i915_audio_component_audio_ops
    -       void (*pin_eld_notify)(void *audio_ptr, int port);
    +       void (*pin_eld_notify)(void *audio_ptr, int port, int pipe);
    
    This patch makes dummy changes in the audio drivers (thanks Libin) for
    build to succeed. The audio side drivers will send the right 'pipe' values
    for MST in patches that will follow.
    
    v2:
    Renamed the new API parameter from 'dev_id' to 'pipe'. (Jim, Ville)
    Included Asoc driver API compatibility changes from Jeeja.
    Added WARN_ON() for invalid pipe in get_saved_encoder(). (Takashi)
    Added comment for av_enc_map[] definition. (Takashi)
    
    v3:
    Fixed logic error introduced while renaming 'dev_id' as 'pipe' (Ville)
    Renamed get_saved_encoder() to get_saved_enc() to reduce line length
    
    v4:
    Rebased.
    Parameter check for pipe < -1 values in get_saved_enc() (Ville)
    Switched to for_each_pipe() in get_saved_enc() (Ville)
    Renamed 'pipe' to 'dev_id' in audio side code (Takashi)
    
    v5:
    Included a comment for the dev_id arg. (Libin)
    
    Signed-off-by: Dhinakaran Pandiyan <dhinakaran.pandiyan@intel.com>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1474488168-2343-1-git-send-email-dhinakaran.pandiyan@intel.com

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index c9af022676c2..0659bf389489 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -193,6 +193,7 @@ static int pin2port(struct hdac_device *codec, hda_nid_t pin_nid)
  * snd_hdac_sync_audio_rate - Set N/CTS based on the sample rate
  * @codec: HDA codec
  * @nid: the pin widget NID
+ * @dev_id: device identifier
  * @rate: the sample rate to set
  *
  * This function is supposed to be used only by a HD-audio controller
@@ -201,18 +202,20 @@ static int pin2port(struct hdac_device *codec, hda_nid_t pin_nid)
  * This function sets N/CTS value based on the given sample rate.
  * Returns zero for success, or a negative error code.
  */
-int snd_hdac_sync_audio_rate(struct hdac_device *codec, hda_nid_t nid, int rate)
+int snd_hdac_sync_audio_rate(struct hdac_device *codec, hda_nid_t nid,
+			     int dev_id, int rate)
 {
 	struct hdac_bus *bus = codec->bus;
 	struct i915_audio_component *acomp = bus->audio_component;
-	int port;
+	int port, pipe;
 
 	if (!acomp || !acomp->ops || !acomp->ops->sync_audio_rate)
 		return -ENODEV;
 	port = pin2port(codec, nid);
 	if (port < 0)
 		return -EINVAL;
-	return acomp->ops->sync_audio_rate(acomp->dev, port, rate);
+	pipe = dev_id;
+	return acomp->ops->sync_audio_rate(acomp->dev, port, pipe, rate);
 }
 EXPORT_SYMBOL_GPL(snd_hdac_sync_audio_rate);
 
@@ -220,6 +223,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_sync_audio_rate);
  * snd_hdac_acomp_get_eld - Get the audio state and ELD via component
  * @codec: HDA codec
  * @nid: the pin widget NID
+ * @dev_id: device identifier
  * @audio_enabled: the pointer to store the current audio state
  * @buffer: the buffer pointer to store ELD bytes
  * @max_bytes: the max bytes to be stored on @buffer
@@ -236,12 +240,12 @@ EXPORT_SYMBOL_GPL(snd_hdac_sync_audio_rate);
  * thus it may be over @max_bytes.  If it's over @max_bytes, it implies
  * that only a part of ELD bytes have been fetched.
  */
-int snd_hdac_acomp_get_eld(struct hdac_device *codec, hda_nid_t nid,
+int snd_hdac_acomp_get_eld(struct hdac_device *codec, hda_nid_t nid, int dev_id,
 			   bool *audio_enabled, char *buffer, int max_bytes)
 {
 	struct hdac_bus *bus = codec->bus;
 	struct i915_audio_component *acomp = bus->audio_component;
-	int port;
+	int port, pipe;
 
 	if (!acomp || !acomp->ops || !acomp->ops->get_eld)
 		return -ENODEV;
@@ -249,7 +253,9 @@ int snd_hdac_acomp_get_eld(struct hdac_device *codec, hda_nid_t nid,
 	port = pin2port(codec, nid);
 	if (port < 0)
 		return -EINVAL;
-	return acomp->ops->get_eld(acomp->dev, port, audio_enabled,
+
+	pipe = dev_id;
+	return acomp->ops->get_eld(acomp->dev, port, pipe, audio_enabled,
 				   buffer, max_bytes);
 }
 EXPORT_SYMBOL_GPL(snd_hdac_acomp_get_eld);

commit a33d59599653edc6469c582f0ffd99c5fc58af04
Merge: 58a8738cfcde bb03ed216370
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 26 10:04:19 2016 +0200

    Merge branch 'for-linus' into for-next
    
    For taking back the recent change of HDA HDMI fixes for i915 HSW/BDW.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit bb03ed216370cb021f377f923471e56d1de3ff5d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 21 16:39:17 2016 +0200

    ALSA: hda - Update BCLK also at hotplug for i915 HSW/BDW
    
    The recent bug report suggests that BCLK setup for i915 HSW/BDW needs
    to be updated at each HDMI hotplug, not only at initialization and
    resume.  That is, we need to update HSW_EM4 and HSW_EM5 registers at
    ELD notification, too.  Otherwise the HDMI audio may be out of sync
    and played in a wrong pitch.
    
    However, the HDA codec driver has no access to the controller
    registers, and currently the code managing these registers is in
    hda_intel.c, i.e. local to the controller driver.  For allowing the
    explicit BCLK update from the codec driver, as in this patch, the
    former haswell_set_bclk() in hda_intel.c is moved to hdac_i915.c and
    exposed as snd_hdac_i915_set_bclk().  This is called from both the HDA
    controller driver and intel_pin_eld_notify() in HDMI codec driver.
    
    Along with this change, snd_hdac_get_display_clk() gets dropped as
    it's no longer used.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=91410
    Cc: <stable@vger.kernel.org> # v4.5+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 54babe1c0b16..607bbeaebddf 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -20,6 +20,7 @@
 #include <sound/core.h>
 #include <sound/hdaudio.h>
 #include <sound/hda_i915.h>
+#include <sound/hda_register.h>
 
 static struct i915_audio_component *hdac_acomp;
 
@@ -97,26 +98,65 @@ int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
 }
 EXPORT_SYMBOL_GPL(snd_hdac_display_power);
 
+#define CONTROLLER_IN_GPU(pci) (((pci)->device == 0x0a0c) || \
+				((pci)->device == 0x0c0c) || \
+				((pci)->device == 0x0d0c) || \
+				((pci)->device == 0x160c))
+
 /**
- * snd_hdac_get_display_clk - Get CDCLK in kHz
+ * snd_hdac_i915_set_bclk - Reprogram BCLK for HSW/BDW
  * @bus: HDA core bus
  *
- * This function is supposed to be used only by a HD-audio controller
- * driver that needs the interaction with i915 graphics.
+ * Intel HSW/BDW display HDA controller is in GPU. Both its power and link BCLK
+ * depends on GPU. Two Extended Mode registers EM4 (M value) and EM5 (N Value)
+ * are used to convert CDClk (Core Display Clock) to 24MHz BCLK:
+ * BCLK = CDCLK * M / N
+ * The values will be lost when the display power well is disabled and need to
+ * be restored to avoid abnormal playback speed.
  *
- * This function queries CDCLK value in kHz from the graphics driver and
- * returns the value.  A negative code is returned in error.
+ * Call this function at initializing and changing power well, as well as
+ * at ELD notifier for the hotplug.
  */
-int snd_hdac_get_display_clk(struct hdac_bus *bus)
+void snd_hdac_i915_set_bclk(struct hdac_bus *bus)
 {
 	struct i915_audio_component *acomp = bus->audio_component;
+	struct pci_dev *pci = to_pci_dev(bus->dev);
+	int cdclk_freq;
+	unsigned int bclk_m, bclk_n;
+
+	if (!acomp || !acomp->ops || !acomp->ops->get_cdclk_freq)
+		return; /* only for i915 binding */
+	if (!CONTROLLER_IN_GPU(pci))
+		return; /* only HSW/BDW */
+
+	cdclk_freq = acomp->ops->get_cdclk_freq(acomp->dev);
+	switch (cdclk_freq) {
+	case 337500:
+		bclk_m = 16;
+		bclk_n = 225;
+		break;
+
+	case 450000:
+	default: /* default CDCLK 450MHz */
+		bclk_m = 4;
+		bclk_n = 75;
+		break;
+
+	case 540000:
+		bclk_m = 4;
+		bclk_n = 90;
+		break;
+
+	case 675000:
+		bclk_m = 8;
+		bclk_n = 225;
+		break;
+	}
 
-	if (!acomp || !acomp->ops)
-		return -ENODEV;
-
-	return acomp->ops->get_cdclk_freq(acomp->dev);
+	snd_hdac_chip_writew(bus, HSW_EM4, bclk_m);
+	snd_hdac_chip_writew(bus, HSW_EM5, bclk_n);
 }
-EXPORT_SYMBOL_GPL(snd_hdac_get_display_clk);
+EXPORT_SYMBOL_GPL(snd_hdac_i915_set_bclk);
 
 /* There is a fixed mapping between audio pin node and display port
  * on current Intel platforms:

commit a99e31512aa435e8391ba5f5e64abeac9c5f2f32
Merge: 86c8dd7f4da3 f03b24a851d3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 4 11:51:08 2016 +0200

    Merge branch 'for-linus' into for-next
    
    Conflicts:
            sound/hda/hdac_i915.c
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit bfa5fb14fb9e698ae2d9429a82ef0ab67a17df37
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 29 15:03:06 2016 +0200

    ALSA: hda - Bind with i915 only when Intel graphics is present
    
    On Skylake and onwards, the HD-audio controller driver needs to bind
    with i915 for having the control of power well audio domain before
    actually probing the codec.  This leads to the load of i915 driver
    from the audio driver side.  But, there are systems that have no Intel
    graphics but Nvidia or AMD GPU, although they still use HD-audio bus
    for the onboard audio codecs.  On these, loading the i915 driver is
    nothing but a useless memory and CPU consumption.
    
    A simple way to avoid it is just to look for the Intel graphics PCI
    entry beforehand, and try to bind with i915 only when such an entry is
    found.  Currently, it assumes the PCI display class.  If another class
    appears, this needs to be extended (although it's very unlikely).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index fb96aead8257..54babe1c0b16 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -267,6 +267,18 @@ int snd_hdac_i915_register_notifier(const struct i915_audio_component_audio_ops
 }
 EXPORT_SYMBOL_GPL(snd_hdac_i915_register_notifier);
 
+/* check whether intel graphics is present */
+static bool i915_gfx_present(void)
+{
+	static struct pci_device_id ids[] = {
+		{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_ANY_ID),
+		  .class = PCI_BASE_CLASS_DISPLAY << 16,
+		  .class_mask = 0xff << 16 },
+		{}
+	};
+	return pci_dev_present(ids);
+}
+
 /**
  * snd_hdac_i915_init - Initialize i915 audio component
  * @bus: HDA core bus
@@ -286,6 +298,9 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 	struct i915_audio_component *acomp;
 	int ret;
 
+	if (!i915_gfx_present())
+		return -ENODEV;
+
 	acomp = kzalloc(sizeof(*acomp), GFP_KERNEL);
 	if (!acomp)
 		return -ENOMEM;

commit 97cc2ed27e5a168cf423f67c3bc7c6cc41d12f82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 29 18:48:07 2016 +0200

    ALSA: hda - Fix yet another i915 pointer leftover in error path
    
    The hdac_acomp object in hdac_i915.c is left as assigned even after
    binding with i915 actually fails, and this leads to the WARN_ON() at
    the next load of the module.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94736
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index ae0f305a7e41..d0da2508823e 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -339,6 +339,7 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 out_err:
 	kfree(acomp);
 	bus->audio_component = NULL;
+	hdac_acomp = NULL;
 	dev_info(dev, "failed to add i915 component master (%d)\n", ret);
 
 	return ret;

commit faafd03d23c913633d2ef7e6ffebdce01b164409
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 29 12:29:24 2016 +0200

    ALSA: hda - Clear the leftover component assignment at snd_hdac_i915_exit()
    
    The commit [d745f5e7b8b2: ALSA: hda - Add the pin / port mapping on
    Intel ILK and VLV] introduced a WARN_ON() to check the pointer for
    avoiding the double initializations.  But hdac_acomp pointer wasn't
    cleared at snd_hdac_i915_exit(), thus after reloading the HD-audio
    driver, it may result in the false positive warning.  This patch makes
    sure to clear the leftover pointer at exit.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94736
    Reported-by: Daniela Doras-prodan <daniela.doras-prodan@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 750a4ea49fa9..ae0f305a7e41 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -372,6 +372,7 @@ int snd_hdac_i915_exit(struct hdac_bus *bus)
 
 	kfree(acomp);
 	bus->audio_component = NULL;
+	hdac_acomp = NULL;
 
 	return 0;
 }

commit d745f5e7b8b2961f68b0b9093a0f914a8a83c2ae
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 21 14:41:58 2016 +0100

    ALSA: hda - Add the pin / port mapping on Intel ILK and VLV
    
    Intel IronLake and ValleyView platforms have different HDMI widget pin
    and digital port mapping from other newer ones.  The recent ones
    (HSW+) have NID 0x05 to 0x07 for port B to port D, while these chips
    have NID 0x04 to 0x06.
    
    For adapting this mapping, pass the codec object instead of the bus
    object to snd_hdac_sync_audio_rate() and snd_hdac_acomp_get_eld() so
    that they can check the codec ID and calculate the mapping properly.
    
    The changes in the HDMI codec driver side will follow in the later
    patch.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index fb96aead8257..750a4ea49fa9 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -118,22 +118,40 @@ int snd_hdac_get_display_clk(struct hdac_bus *bus)
 }
 EXPORT_SYMBOL_GPL(snd_hdac_get_display_clk);
 
-/* There is a fixed mapping between audio pin node and display port
- * on current Intel platforms:
+/* There is a fixed mapping between audio pin node and display port.
+ * on SNB, IVY, HSW, BSW, SKL, BXT, KBL:
  * Pin Widget 5 - PORT B (port = 1 in i915 driver)
  * Pin Widget 6 - PORT C (port = 2 in i915 driver)
  * Pin Widget 7 - PORT D (port = 3 in i915 driver)
+ *
+ * on VLV, ILK:
+ * Pin Widget 4 - PORT B (port = 1 in i915 driver)
+ * Pin Widget 5 - PORT C (port = 2 in i915 driver)
+ * Pin Widget 6 - PORT D (port = 3 in i915 driver)
  */
-static int pin2port(hda_nid_t pin_nid)
+static int pin2port(struct hdac_device *codec, hda_nid_t pin_nid)
 {
-	if (WARN_ON(pin_nid < 5 || pin_nid > 7))
+	int base_nid;
+
+	switch (codec->vendor_id) {
+	case 0x80860054: /* ILK */
+	case 0x80862804: /* ILK */
+	case 0x80862882: /* VLV */
+		base_nid = 3;
+		break;
+	default:
+		base_nid = 4;
+		break;
+	}
+
+	if (WARN_ON(pin_nid <= base_nid || pin_nid > base_nid + 3))
 		return -1;
-	return pin_nid - 4;
+	return pin_nid - base_nid;
 }
 
 /**
  * snd_hdac_sync_audio_rate - Set N/CTS based on the sample rate
- * @bus: HDA core bus
+ * @codec: HDA codec
  * @nid: the pin widget NID
  * @rate: the sample rate to set
  *
@@ -143,14 +161,15 @@ static int pin2port(hda_nid_t pin_nid)
  * This function sets N/CTS value based on the given sample rate.
  * Returns zero for success, or a negative error code.
  */
-int snd_hdac_sync_audio_rate(struct hdac_bus *bus, hda_nid_t nid, int rate)
+int snd_hdac_sync_audio_rate(struct hdac_device *codec, hda_nid_t nid, int rate)
 {
+	struct hdac_bus *bus = codec->bus;
 	struct i915_audio_component *acomp = bus->audio_component;
 	int port;
 
 	if (!acomp || !acomp->ops || !acomp->ops->sync_audio_rate)
 		return -ENODEV;
-	port = pin2port(nid);
+	port = pin2port(codec, nid);
 	if (port < 0)
 		return -EINVAL;
 	return acomp->ops->sync_audio_rate(acomp->dev, port, rate);
@@ -159,7 +178,7 @@ EXPORT_SYMBOL_GPL(snd_hdac_sync_audio_rate);
 
 /**
  * snd_hdac_acomp_get_eld - Get the audio state and ELD via component
- * @bus: HDA core bus
+ * @codec: HDA codec
  * @nid: the pin widget NID
  * @audio_enabled: the pointer to store the current audio state
  * @buffer: the buffer pointer to store ELD bytes
@@ -177,16 +196,17 @@ EXPORT_SYMBOL_GPL(snd_hdac_sync_audio_rate);
  * thus it may be over @max_bytes.  If it's over @max_bytes, it implies
  * that only a part of ELD bytes have been fetched.
  */
-int snd_hdac_acomp_get_eld(struct hdac_bus *bus, hda_nid_t nid,
+int snd_hdac_acomp_get_eld(struct hdac_device *codec, hda_nid_t nid,
 			   bool *audio_enabled, char *buffer, int max_bytes)
 {
+	struct hdac_bus *bus = codec->bus;
 	struct i915_audio_component *acomp = bus->audio_component;
 	int port;
 
 	if (!acomp || !acomp->ops || !acomp->ops->get_eld)
 		return -ENODEV;
 
-	port = pin2port(nid);
+	port = pin2port(codec, nid);
 	if (port < 0)
 		return -EINVAL;
 	return acomp->ops->get_eld(acomp->dev, port, audio_enabled,
@@ -286,6 +306,9 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 	struct i915_audio_component *acomp;
 	int ret;
 
+	if (WARN_ON(hdac_acomp))
+		return -EBUSY;
+
 	acomp = kzalloc(sizeof(*acomp), GFP_KERNEL);
 	if (!acomp)
 		return -ENOMEM;

commit 1a414f48d7ccb197b61c18888b72327c98171844
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Mar 10 15:49:35 2016 +0100

    ALSA: hda - Add a sanity check of pin / port mapping on i915 HDMI/DP
    
    There is an implicit rule to map between pin NID and port number on
    Intel HDMI/DP codec: the mapping is fixed only for NID 0x05, 0x06 and
    0x07.  For avoiding the possible memory corruption, add a sanity check
    for the NID value and splat WARN_ON() for invalid accesses.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index f6854dbd7d8d..fb96aead8257 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -126,6 +126,8 @@ EXPORT_SYMBOL_GPL(snd_hdac_get_display_clk);
  */
 static int pin2port(hda_nid_t pin_nid)
 {
+	if (WARN_ON(pin_nid < 5 || pin_nid > 7))
+		return -1;
 	return pin_nid - 4;
 }
 
@@ -144,10 +146,14 @@ static int pin2port(hda_nid_t pin_nid)
 int snd_hdac_sync_audio_rate(struct hdac_bus *bus, hda_nid_t nid, int rate)
 {
 	struct i915_audio_component *acomp = bus->audio_component;
+	int port;
 
 	if (!acomp || !acomp->ops || !acomp->ops->sync_audio_rate)
 		return -ENODEV;
-	return acomp->ops->sync_audio_rate(acomp->dev, pin2port(nid), rate);
+	port = pin2port(nid);
+	if (port < 0)
+		return -EINVAL;
+	return acomp->ops->sync_audio_rate(acomp->dev, port, rate);
 }
 EXPORT_SYMBOL_GPL(snd_hdac_sync_audio_rate);
 
@@ -175,11 +181,15 @@ int snd_hdac_acomp_get_eld(struct hdac_bus *bus, hda_nid_t nid,
 			   bool *audio_enabled, char *buffer, int max_bytes)
 {
 	struct i915_audio_component *acomp = bus->audio_component;
+	int port;
 
 	if (!acomp || !acomp->ops || !acomp->ops->get_eld)
 		return -ENODEV;
 
-	return acomp->ops->get_eld(acomp->dev, pin2port(nid), audio_enabled,
+	port = pin2port(nid);
+	if (port < 0)
+		return -EINVAL;
+	return acomp->ops->get_eld(acomp->dev, port, audio_enabled,
 				   buffer, max_bytes);
 }
 EXPORT_SYMBOL_GPL(snd_hdac_acomp_get_eld);

commit bed2e98e1f4db8b827df507abc30be7b11b0613d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 20 15:00:26 2016 +0100

    ALSA: hda - Degrade i915 binding failure message
    
    Currently HD-audio driver on Intel Skylake or Broxteon gives an error
    message when binding with i915 audio component fails.  However, this
    isn't any serious error on a system without Intel graphics.  Indeed
    there are such systems, where a third-party codec (e.g. Creative) is
    put on the mobo while using other discrete GPU (e.g. Nvidia).
    Printing a kernel "error" message is overreaction in such a case.
    
    This patch downgrades the print level for that message.  For systems
    that mandate the i915 binding (e.g. Haswell or Broadwell HDMI/DP),
    another kernel error message is shown in addition to make clear what
    went wrong.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=111021
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index c50177fb469f..f6854dbd7d8d 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -306,7 +306,7 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 out_err:
 	kfree(acomp);
 	bus->audio_component = NULL;
-	dev_err(dev, "failed to add i915 component master (%d)\n", ret);
+	dev_info(dev, "failed to add i915 component master (%d)\n", ret);
 
 	return ret;
 }

commit e2dc7d7d8ed3019f72855af1c3dcda3fb456b488
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 1 12:39:38 2015 +0100

    ALSA: hda - Move audio component accesses to hdac_i915.c
    
    A couple of i915_audio_component ops have been added and accessed
    directly from patch_hdmi.c.  Ideally all these should be factored out
    into hdac_i915.c.
    
    This patch does it, adds two new helper functions for setting N/CTS
    and fetching ELD bytes.  One bonus is that the hackish widget vs port
    mapping is also moved to hdac_i915.c, so that it can be fixed /
    enhanced more cleanly.
    
    Reviewed-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 8fef1b8d1fd8..c50177fb469f 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -118,6 +118,72 @@ int snd_hdac_get_display_clk(struct hdac_bus *bus)
 }
 EXPORT_SYMBOL_GPL(snd_hdac_get_display_clk);
 
+/* There is a fixed mapping between audio pin node and display port
+ * on current Intel platforms:
+ * Pin Widget 5 - PORT B (port = 1 in i915 driver)
+ * Pin Widget 6 - PORT C (port = 2 in i915 driver)
+ * Pin Widget 7 - PORT D (port = 3 in i915 driver)
+ */
+static int pin2port(hda_nid_t pin_nid)
+{
+	return pin_nid - 4;
+}
+
+/**
+ * snd_hdac_sync_audio_rate - Set N/CTS based on the sample rate
+ * @bus: HDA core bus
+ * @nid: the pin widget NID
+ * @rate: the sample rate to set
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with i915 graphics.
+ *
+ * This function sets N/CTS value based on the given sample rate.
+ * Returns zero for success, or a negative error code.
+ */
+int snd_hdac_sync_audio_rate(struct hdac_bus *bus, hda_nid_t nid, int rate)
+{
+	struct i915_audio_component *acomp = bus->audio_component;
+
+	if (!acomp || !acomp->ops || !acomp->ops->sync_audio_rate)
+		return -ENODEV;
+	return acomp->ops->sync_audio_rate(acomp->dev, pin2port(nid), rate);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_sync_audio_rate);
+
+/**
+ * snd_hdac_acomp_get_eld - Get the audio state and ELD via component
+ * @bus: HDA core bus
+ * @nid: the pin widget NID
+ * @audio_enabled: the pointer to store the current audio state
+ * @buffer: the buffer pointer to store ELD bytes
+ * @max_bytes: the max bytes to be stored on @buffer
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with i915 graphics.
+ *
+ * This function queries the current state of the audio on the given
+ * digital port and fetches the ELD bytes onto the given buffer.
+ * It returns the number of bytes for the total ELD data, zero for
+ * invalid ELD, or a negative error code.
+ *
+ * The return size is the total bytes required for the whole ELD bytes,
+ * thus it may be over @max_bytes.  If it's over @max_bytes, it implies
+ * that only a part of ELD bytes have been fetched.
+ */
+int snd_hdac_acomp_get_eld(struct hdac_bus *bus, hda_nid_t nid,
+			   bool *audio_enabled, char *buffer, int max_bytes)
+{
+	struct i915_audio_component *acomp = bus->audio_component;
+
+	if (!acomp || !acomp->ops || !acomp->ops->get_eld)
+		return -ENODEV;
+
+	return acomp->ops->get_eld(acomp->dev, pin2port(nid), audio_enabled,
+				   buffer, max_bytes);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_acomp_get_eld);
+
 static int hdac_component_master_bind(struct device *dev)
 {
 	struct i915_audio_component *acomp = hdac_acomp;

commit 78dd5e21b075053e67194ea8f496439bebc52728
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 28 12:26:48 2015 +0100

    ALSA: hda - Add / fix kernel doc comments
    
    Give some readable comment in kernel doc style for each exported
    function, as I promised in the previous meetings.  While we're at it,
    fix the wrong comments, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 55c3df4458f7..8fef1b8d1fd8 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -23,6 +23,19 @@
 
 static struct i915_audio_component *hdac_acomp;
 
+/**
+ * snd_hdac_set_codec_wakeup - Enable / disable HDMI/DP codec wakeup
+ * @bus: HDA core bus
+ * @enable: enable or disable the wakeup
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with i915 graphics.
+ *
+ * This function should be called during the chip reset, also called at
+ * resume for updating STATESTS register read.
+ *
+ * Returns zero for success or a negative error code.
+ */
 int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable)
 {
 	struct i915_audio_component *acomp = bus->audio_component;
@@ -45,6 +58,19 @@ int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable)
 }
 EXPORT_SYMBOL_GPL(snd_hdac_set_codec_wakeup);
 
+/**
+ * snd_hdac_display_power - Power up / down the power refcount
+ * @bus: HDA core bus
+ * @enable: power up or down
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with i915 graphics.
+ *
+ * This function manages a refcount and calls the i915 get_power() and
+ * put_power() ops accordingly, toggling the codec wakeup, too.
+ *
+ * Returns zero for success or a negative error code.
+ */
 int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
 {
 	struct i915_audio_component *acomp = bus->audio_component;
@@ -71,6 +97,16 @@ int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
 }
 EXPORT_SYMBOL_GPL(snd_hdac_display_power);
 
+/**
+ * snd_hdac_get_display_clk - Get CDCLK in kHz
+ * @bus: HDA core bus
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with i915 graphics.
+ *
+ * This function queries CDCLK value in kHz from the graphics driver and
+ * returns the value.  A negative code is returned in error.
+ */
 int snd_hdac_get_display_clk(struct hdac_bus *bus)
 {
 	struct i915_audio_component *acomp = bus->audio_component;
@@ -134,6 +170,17 @@ static int hdac_component_master_match(struct device *dev, void *data)
 	return !strcmp(dev->driver->name, "i915");
 }
 
+/**
+ * snd_hdac_i915_register_notifier - Register i915 audio component ops
+ * @aops: i915 audio component ops
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with i915 graphics.
+ *
+ * This function sets the given ops to be called by the i915 graphics driver.
+ *
+ * Returns zero for success or a negative error code.
+ */
 int snd_hdac_i915_register_notifier(const struct i915_audio_component_audio_ops *aops)
 {
 	if (WARN_ON(!hdac_acomp))
@@ -144,6 +191,18 @@ int snd_hdac_i915_register_notifier(const struct i915_audio_component_audio_ops
 }
 EXPORT_SYMBOL_GPL(snd_hdac_i915_register_notifier);
 
+/**
+ * snd_hdac_i915_init - Initialize i915 audio component
+ * @bus: HDA core bus
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with i915 graphics.
+ *
+ * This function initializes and sets up the audio component to communicate
+ * with i915 graphics driver.
+ *
+ * Returns zero for success or a negative error code.
+ */
 int snd_hdac_i915_init(struct hdac_bus *bus)
 {
 	struct component_match *match = NULL;
@@ -187,6 +246,17 @@ int snd_hdac_i915_init(struct hdac_bus *bus)
 }
 EXPORT_SYMBOL_GPL(snd_hdac_i915_init);
 
+/**
+ * snd_hdac_i915_exit - Finalize i915 audio component
+ * @bus: HDA core bus
+ *
+ * This function is supposed to be used only by a HD-audio controller
+ * driver that needs the interaction with i915 graphics.
+ *
+ * This function releases the i915 audio component that has been used.
+ *
+ * Returns zero for success or a negative error code.
+ */
 int snd_hdac_i915_exit(struct hdac_bus *bus)
 {
 	struct device *dev = bus->dev;

commit 45c053df5bdc4843cf19b920db6ab819ddc27ff7
Author: David Henningsson <david.henningsson@canonical.com>
Date:   Wed Aug 19 10:48:57 2015 +0200

    ALSA: hda - allow codecs to access the i915 pin/ELD callback
    
    This lets the interested codec be notified when an i915 pin/ELD
    event happens.
    
    [tiwai: Fixed a trivial build error for CONFIG_SND_HDA_I915=n]
    
    Signed-off-by: David Henningsson <david.henningsson@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 5676b849379d..55c3df4458f7 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -134,6 +134,16 @@ static int hdac_component_master_match(struct device *dev, void *data)
 	return !strcmp(dev->driver->name, "i915");
 }
 
+int snd_hdac_i915_register_notifier(const struct i915_audio_component_audio_ops *aops)
+{
+	if (WARN_ON(!hdac_acomp))
+		return -ENODEV;
+
+	hdac_acomp->audio_ops = aops;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_i915_register_notifier);
+
 int snd_hdac_i915_init(struct hdac_bus *bus)
 {
 	struct component_match *match = NULL;

commit 033ea349a7cd1aa15357cd6575de35188fc85b9a
Author: David Henningsson <david.henningsson@canonical.com>
Date:   Thu Jul 16 10:39:24 2015 +0200

    ALSA: hda - Fix Skylake codec timeout
    
    When the controller is powered up but the HDMI codec is powered down
    on Skylake, the power well is turned off. When the codec is then
    powered up again, we need to poke the codec a little extra to make
    sure it wakes up. Otherwise we'll get sad "no response from codec"
    messages and broken audio.
    
    This also changes azx_runtime_resume to actually call
    snd_hdac_set_codec_wakeup for Skylake (before STATETS read).
    (Otherwise it would only have been called for Haswell and Broadwell,
    which both do not need it, so this probably was not the author's
    intention.)
    
    Signed-off-by: David Henningsson <david.henningsson@canonical.com>
    Reviewed-by: Libin Yang <libin.yang@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index 442500e06b7c..5676b849379d 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -56,8 +56,11 @@ int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
 		enable ? "enable" : "disable");
 
 	if (enable) {
-		if (!bus->i915_power_refcount++)
+		if (!bus->i915_power_refcount++) {
 			acomp->ops->get_power(acomp->dev);
+			snd_hdac_set_codec_wakeup(bus, true);
+			snd_hdac_set_codec_wakeup(bus, false);
+		}
 	} else {
 		WARN_ON(!bus->i915_power_refcount);
 		if (!--bus->i915_power_refcount)

commit 692af901df615b7783caaccdb287cddf2d7f6059
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 10 12:15:27 2015 +0200

    ALSA: hda - Allow calling snd_hdac_i915_*() without actual binding
    
    Add the missing NULL checks so that snd_hdac_i915*() can be called
    even after the binding with i915 failed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
index cb78c25585ac..442500e06b7c 100644
--- a/sound/hda/hdac_i915.c
+++ b/sound/hda/hdac_i915.c
@@ -27,7 +27,7 @@ int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable)
 {
 	struct i915_audio_component *acomp = bus->audio_component;
 
-	if (!acomp->ops)
+	if (!acomp || !acomp->ops)
 		return -ENODEV;
 
 	if (!acomp->ops->codec_wake_override) {
@@ -49,7 +49,7 @@ int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
 {
 	struct i915_audio_component *acomp = bus->audio_component;
 
-	if (!acomp->ops)
+	if (!acomp || !acomp->ops)
 		return -ENODEV;
 
 	dev_dbg(bus->dev, "display power %s\n",
@@ -72,7 +72,7 @@ int snd_hdac_get_display_clk(struct hdac_bus *bus)
 {
 	struct i915_audio_component *acomp = bus->audio_component;
 
-	if (!acomp->ops)
+	if (!acomp || !acomp->ops)
 		return -ENODEV;
 
 	return acomp->ops->get_cdclk_freq(acomp->dev);
@@ -179,8 +179,11 @@ int snd_hdac_i915_exit(struct hdac_bus *bus)
 	struct device *dev = bus->dev;
 	struct i915_audio_component *acomp = bus->audio_component;
 
+	if (!acomp)
+		return 0;
+
 	WARN_ON(bus->i915_power_refcount);
-	if (bus->i915_power_refcount > 0 && acomp && acomp->ops)
+	if (bus->i915_power_refcount > 0 && acomp->ops)
 		acomp->ops->put_power(acomp->dev);
 
 	component_master_del(dev, &hdac_component_master_ops);

commit 98d8fc6c5d3652e91c61d78941e0fa6f94771d67
Author: Mengdong Lin <mengdong.lin@intel.com>
Date:   Tue May 19 22:29:30 2015 +0800

    ALSA: hda - Move hda_i915.c from sound/pci/hda to sound/hda
    
    The file is moved to hda core and renamed to hdac_i915.c, so can be used
    by both legacy HDA driver and new Skylake audio driver.
    
    - Add snd_hdac_ prefix to the public APIs.
    - The i915 audio component is moved to core bus and dynamically allocated.
    - A static pointer hdac_acomp is used to help bind/unbind callbacks to get
      this component, because the sound card's private_data is used by the azx
      chip pointer, which is a legacy structure. It could be removed if private
      _data changes to some core structure which can be extended to find the
      bus.
    - snd_hdac_get_display_clk() is added to get the display core clock for
      HSW/BDW.
    - haswell_set_bclk() is moved to hda_intel.c because it needs to write the
      controller registers EM4/EM5, and only legacy HD-A needs it for HSW/BDW.
    - Move definition of HSW/BDW-specific registers EM4/EM5 to hda_register.h
      and rename them to HSW_EM4/HSW_EM5, because other HD-A controllers have
      different layout for the extended mode registers.
    
    Signed-off-by: Mengdong Lin <mengdong.lin@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c
new file mode 100644
index 000000000000..cb78c25585ac
--- /dev/null
+++ b/sound/hda/hdac_i915.c
@@ -0,0 +1,193 @@
+/*
+ *  hdac_i915.c - routines for sync between HD-A core and i915 display driver
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the Free
+ *  Software Foundation; either version 2 of the License, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/component.h>
+#include <drm/i915_component.h>
+#include <sound/core.h>
+#include <sound/hdaudio.h>
+#include <sound/hda_i915.h>
+
+static struct i915_audio_component *hdac_acomp;
+
+int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable)
+{
+	struct i915_audio_component *acomp = bus->audio_component;
+
+	if (!acomp->ops)
+		return -ENODEV;
+
+	if (!acomp->ops->codec_wake_override) {
+		dev_warn(bus->dev,
+			"Invalid codec wake callback\n");
+		return 0;
+	}
+
+	dev_dbg(bus->dev, "%s codec wakeup\n",
+		enable ? "enable" : "disable");
+
+	acomp->ops->codec_wake_override(acomp->dev, enable);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_set_codec_wakeup);
+
+int snd_hdac_display_power(struct hdac_bus *bus, bool enable)
+{
+	struct i915_audio_component *acomp = bus->audio_component;
+
+	if (!acomp->ops)
+		return -ENODEV;
+
+	dev_dbg(bus->dev, "display power %s\n",
+		enable ? "enable" : "disable");
+
+	if (enable) {
+		if (!bus->i915_power_refcount++)
+			acomp->ops->get_power(acomp->dev);
+	} else {
+		WARN_ON(!bus->i915_power_refcount);
+		if (!--bus->i915_power_refcount)
+			acomp->ops->put_power(acomp->dev);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_display_power);
+
+int snd_hdac_get_display_clk(struct hdac_bus *bus)
+{
+	struct i915_audio_component *acomp = bus->audio_component;
+
+	if (!acomp->ops)
+		return -ENODEV;
+
+	return acomp->ops->get_cdclk_freq(acomp->dev);
+}
+EXPORT_SYMBOL_GPL(snd_hdac_get_display_clk);
+
+static int hdac_component_master_bind(struct device *dev)
+{
+	struct i915_audio_component *acomp = hdac_acomp;
+	int ret;
+
+	ret = component_bind_all(dev, acomp);
+	if (ret < 0)
+		return ret;
+
+	if (WARN_ON(!(acomp->dev && acomp->ops && acomp->ops->get_power &&
+		      acomp->ops->put_power && acomp->ops->get_cdclk_freq))) {
+		ret = -EINVAL;
+		goto out_unbind;
+	}
+
+	/*
+	 * Atm, we don't support dynamic unbinding initiated by the child
+	 * component, so pin its containing module until we unbind.
+	 */
+	if (!try_module_get(acomp->ops->owner)) {
+		ret = -ENODEV;
+		goto out_unbind;
+	}
+
+	return 0;
+
+out_unbind:
+	component_unbind_all(dev, acomp);
+
+	return ret;
+}
+
+static void hdac_component_master_unbind(struct device *dev)
+{
+	struct i915_audio_component *acomp = hdac_acomp;
+
+	module_put(acomp->ops->owner);
+	component_unbind_all(dev, acomp);
+	WARN_ON(acomp->ops || acomp->dev);
+}
+
+static const struct component_master_ops hdac_component_master_ops = {
+	.bind = hdac_component_master_bind,
+	.unbind = hdac_component_master_unbind,
+};
+
+static int hdac_component_master_match(struct device *dev, void *data)
+{
+	/* i915 is the only supported component */
+	return !strcmp(dev->driver->name, "i915");
+}
+
+int snd_hdac_i915_init(struct hdac_bus *bus)
+{
+	struct component_match *match = NULL;
+	struct device *dev = bus->dev;
+	struct i915_audio_component *acomp;
+	int ret;
+
+	acomp = kzalloc(sizeof(*acomp), GFP_KERNEL);
+	if (!acomp)
+		return -ENOMEM;
+	bus->audio_component = acomp;
+	hdac_acomp = acomp;
+
+	component_match_add(dev, &match, hdac_component_master_match, bus);
+	ret = component_master_add_with_match(dev, &hdac_component_master_ops,
+					      match);
+	if (ret < 0)
+		goto out_err;
+
+	/*
+	 * Atm, we don't support deferring the component binding, so make sure
+	 * i915 is loaded and that the binding successfully completes.
+	 */
+	request_module("i915");
+
+	if (!acomp->ops) {
+		ret = -ENODEV;
+		goto out_master_del;
+	}
+	dev_dbg(dev, "bound to i915 component master\n");
+
+	return 0;
+out_master_del:
+	component_master_del(dev, &hdac_component_master_ops);
+out_err:
+	kfree(acomp);
+	bus->audio_component = NULL;
+	dev_err(dev, "failed to add i915 component master (%d)\n", ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_i915_init);
+
+int snd_hdac_i915_exit(struct hdac_bus *bus)
+{
+	struct device *dev = bus->dev;
+	struct i915_audio_component *acomp = bus->audio_component;
+
+	WARN_ON(bus->i915_power_refcount);
+	if (bus->i915_power_refcount > 0 && acomp && acomp->ops)
+		acomp->ops->put_power(acomp->dev);
+
+	component_master_del(dev, &hdac_component_master_ops);
+
+	kfree(acomp);
+	bus->audio_component = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_hdac_i915_exit);
