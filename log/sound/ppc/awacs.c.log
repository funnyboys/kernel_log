commit c031b0cc77a1bef980eb360e317a6bbd54211326
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:54 2020 +0100

    ALSA: ppc: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-39-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 359d22a81ae3..73c0fd7277e6 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -464,7 +464,7 @@ static int snd_pmac_awacs_put_master_amp(struct snd_kcontrol *kcontrol,
 #define AMP_CH_SPK	0
 #define AMP_CH_HD	1
 
-static struct snd_kcontrol_new snd_pmac_awacs_amp_vol[] = {
+static const struct snd_kcontrol_new snd_pmac_awacs_amp_vol[] = {
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	  .name = "Speaker Playback Volume",
 	  .info = snd_pmac_awacs_info_volume_amp,
@@ -582,46 +582,46 @@ static int snd_pmac_screamer_mic_boost_put(struct snd_kcontrol *kcontrol,
 /*
  * lists of mixer elements
  */
-static struct snd_kcontrol_new snd_pmac_awacs_mixers[] = {
+static const struct snd_kcontrol_new snd_pmac_awacs_mixers[] = {
 	AWACS_SWITCH("Master Capture Switch", 1, SHIFT_LOOPTHRU, 0),
 	AWACS_VOLUME("Master Capture Volume", 0, 4, 0),
 /*	AWACS_SWITCH("Unknown Playback Switch", 6, SHIFT_PAROUT0, 0), */
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers_beige[] = {
+static const struct snd_kcontrol_new snd_pmac_screamer_mixers_beige[] = {
 	AWACS_VOLUME("Master Playback Volume", 2, 6, 1),
 	AWACS_VOLUME("Play-through Playback Volume", 5, 6, 1),
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_LINE, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers_lo[] = {
+static const struct snd_kcontrol_new snd_pmac_screamer_mixers_lo[] = {
 	AWACS_VOLUME("Line out Playback Volume", 2, 6, 1),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers_imac[] = {
+static const struct snd_kcontrol_new snd_pmac_screamer_mixers_imac[] = {
 	AWACS_VOLUME("Play-through Playback Volume", 5, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers_g4agp[] = {
+static const struct snd_kcontrol_new snd_pmac_screamer_mixers_g4agp[] = {
 	AWACS_VOLUME("Line out Playback Volume", 2, 6, 1),
 	AWACS_VOLUME("Master Playback Volume", 5, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac7500[] = {
+static const struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac7500[] = {
 	AWACS_VOLUME("Line out Playback Volume", 2, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac5500[] = {
+static const struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac5500[] = {
 	AWACS_VOLUME("Headphone Playback Volume", 2, 6, 1),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac[] = {
+static const struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac[] = {
 	AWACS_VOLUME("Master Playback Volume", 2, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 };
@@ -629,34 +629,34 @@ static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac[] = {
 /* FIXME: is this correct order?
  * screamer (powerbook G3 pismo) seems to have different bits...
  */
-static struct snd_kcontrol_new snd_pmac_awacs_mixers2[] = {
+static const struct snd_kcontrol_new snd_pmac_awacs_mixers2[] = {
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_LINE, 0),
 	AWACS_SWITCH("Mic Capture Switch", 0, SHIFT_MUX_MIC, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers2[] = {
+static const struct snd_kcontrol_new snd_pmac_screamer_mixers2[] = {
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
 	AWACS_SWITCH("Mic Capture Switch", 0, SHIFT_MUX_LINE, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mixers2_pmac5500[] = {
+static const struct snd_kcontrol_new snd_pmac_awacs_mixers2_pmac5500[] = {
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_master_sw =
+static const struct snd_kcontrol_new snd_pmac_awacs_master_sw =
 AWACS_SWITCH("Master Playback Switch", 1, SHIFT_HDMUTE, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_master_sw_imac =
+static const struct snd_kcontrol_new snd_pmac_awacs_master_sw_imac =
 AWACS_SWITCH("Line out Playback Switch", 1, SHIFT_HDMUTE, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_master_sw_pmac5500 =
+static const struct snd_kcontrol_new snd_pmac_awacs_master_sw_pmac5500 =
 AWACS_SWITCH("Headphone Playback Switch", 1, SHIFT_HDMUTE, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_mic_boost[] = {
+static const struct snd_kcontrol_new snd_pmac_awacs_mic_boost[] = {
 	AWACS_SWITCH("Mic Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mic_boost[] = {
+static const struct snd_kcontrol_new snd_pmac_screamer_mic_boost[] = {
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	  .name = "Mic Boost Capture Volume",
 	  .info = snd_pmac_screamer_mic_boost_info,
@@ -665,34 +665,34 @@ static struct snd_kcontrol_new snd_pmac_screamer_mic_boost[] = {
 	},
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mic_boost_pmac7500[] =
+static const struct snd_kcontrol_new snd_pmac_awacs_mic_boost_pmac7500[] =
 {
 	AWACS_SWITCH("Line Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mic_boost_beige[] =
+static const struct snd_kcontrol_new snd_pmac_screamer_mic_boost_beige[] =
 {
 	AWACS_SWITCH("Line Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
 	AWACS_SWITCH("CD Boost Capture Switch", 6, SHIFT_MIC_BOOST, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mic_boost_imac[] =
+static const struct snd_kcontrol_new snd_pmac_screamer_mic_boost_imac[] =
 {
 	AWACS_SWITCH("Line Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
 	AWACS_SWITCH("Mic Boost Capture Switch", 6, SHIFT_MIC_BOOST, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_speaker_vol[] = {
+static const struct snd_kcontrol_new snd_pmac_awacs_speaker_vol[] = {
 	AWACS_VOLUME("Speaker Playback Volume", 4, 6, 1),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw =
+static const struct snd_kcontrol_new snd_pmac_awacs_speaker_sw =
 AWACS_SWITCH("Speaker Playback Switch", 1, SHIFT_SPKMUTE, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac1 =
+static const struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac1 =
 AWACS_SWITCH("Speaker Playback Switch", 1, SHIFT_PAROUT1, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac2 =
+static const struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac2 =
 AWACS_SWITCH("Speaker Playback Switch", 1, SHIFT_PAROUT1, 0);
 
 
@@ -700,7 +700,7 @@ AWACS_SWITCH("Speaker Playback Switch", 1, SHIFT_PAROUT1, 0);
  * add new mixer elements to the card
  */
 static int build_mixers(struct snd_pmac *chip, int nums,
-			struct snd_kcontrol_new *mixers)
+			const struct snd_kcontrol_new *mixers)
 {
 	int i, err;
 

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index d1e4ef1c5c30..359d22a81ae3 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -1,22 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * PMac AWACS lowlevel functions
  *
  * Copyright (c) by Takashi Iwai <tiwai@suse.de>
  * code based on dmasound.c.
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 

commit 905e46acd3272d04566fec49afbd7ad9e2ed9ae3
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat May 27 20:16:15 2017 +0530

    ALSA: declare snd_kcontrol_new structures as const
    
    Declare snd_kcontrol_new structures as const as they are only passed an
    argument to the function snd_ctl_new1. This argument is of type const,
    so snd_kcontrol_new structures having this property can be made const.
    Done using Coccinelle:
    
    @r disable optional_qualifier@
    identifier x;
    position p;
    @@
    static struct snd_kcontrol_new x@p={...};
    
    @ok@
    identifier r.x;
    position p;
    @@
    snd_ctl_new1(&x@p,...)
    
    @bad@
    position p != {r.p,ok.p};
    identifier r.x;
    @@
    x@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.x;
    @@
    +const
    struct snd_kcontrol_new x;
    
    Cross compiled these files:
    sound/aoa/codecs/tas.c - powerpc
    sound/mips/{hal2.c/sgio2audio.c} - mips
    sound/ppc/{awacs.c/beep.c/tumbler.c} - powerpc
    sound/soc/sh/siu_dai.c - sh
    Could not find an architecture to compile sound/sh/aica.c.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 1468e4b7bf93..d1e4ef1c5c30 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -514,7 +514,7 @@ static struct snd_kcontrol_new snd_pmac_awacs_amp_vol[] = {
 	},
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_amp_hp_sw = {
+static const struct snd_kcontrol_new snd_pmac_awacs_amp_hp_sw = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Headphone Playback Switch",
 	.info = snd_pmac_boolean_stereo_info,
@@ -523,7 +523,7 @@ static struct snd_kcontrol_new snd_pmac_awacs_amp_hp_sw = {
 	.private_value = AMP_CH_HD,
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_amp_spk_sw = {
+static const struct snd_kcontrol_new snd_pmac_awacs_amp_spk_sw = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Speaker Playback Switch",
 	.info = snd_pmac_boolean_stereo_info,

commit b268c34e5ee92a4cc3099b0caaf26e6bfbdf0f18
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jul 4 17:07:45 2016 +0200

    ALSA: ppc/awacs: shut up maybe-uninitialized warning
    
    The awacs sound driver produces a false-positive warning in ppc64_defconfig:
    
    sound/ppc/awacs.c: In function 'snd_pmac_awacs_init':
    include/sound/control.h:219:9: warning: 'master_vol' may be used uninitialized in this function [-Wmaybe-uninitialized]
    
    I haven't come up with a good way to rewrite the code to avoid the
    warning, so here is a bad one: I initialize the variable before
    the conditionall initialization so gcc no longer has to worry about
    it.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 09da7b52bc2e..1468e4b7bf93 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -991,6 +991,7 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 		if (err < 0)
 			return err;
 	}
+	master_vol = NULL;
 	if (pm7500)
 		err = build_mixers(chip,
 				   ARRAY_SIZE(snd_pmac_awacs_mixers_pmac7500),

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 5fbf5db2543d..09da7b52bc2e 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -20,7 +20,7 @@
  */
 
 
-#include <asm/io.h>
+#include <linux/io.h>
 #include <asm/nvram.h>
 #include <linux/init.h>
 #include <linux/delay.h>

commit 15afafc2565bc785eb7a440b8b4a53f77910cf04
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:23 2012 -0500

    ALSA: ppc: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index b36679384b27..5fbf5db2543d 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -477,7 +477,7 @@ static int snd_pmac_awacs_put_master_amp(struct snd_kcontrol *kcontrol,
 #define AMP_CH_SPK	0
 #define AMP_CH_HD	1
 
-static struct snd_kcontrol_new snd_pmac_awacs_amp_vol[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_amp_vol[] = {
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	  .name = "Speaker Playback Volume",
 	  .info = snd_pmac_awacs_info_volume_amp,
@@ -514,7 +514,7 @@ static struct snd_kcontrol_new snd_pmac_awacs_amp_vol[] __devinitdata = {
 	},
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_amp_hp_sw __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_amp_hp_sw = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Headphone Playback Switch",
 	.info = snd_pmac_boolean_stereo_info,
@@ -523,7 +523,7 @@ static struct snd_kcontrol_new snd_pmac_awacs_amp_hp_sw __devinitdata = {
 	.private_value = AMP_CH_HD,
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_amp_spk_sw __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_amp_spk_sw = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Speaker Playback Switch",
 	.info = snd_pmac_boolean_stereo_info,
@@ -595,46 +595,46 @@ static int snd_pmac_screamer_mic_boost_put(struct snd_kcontrol *kcontrol,
 /*
  * lists of mixer elements
  */
-static struct snd_kcontrol_new snd_pmac_awacs_mixers[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mixers[] = {
 	AWACS_SWITCH("Master Capture Switch", 1, SHIFT_LOOPTHRU, 0),
 	AWACS_VOLUME("Master Capture Volume", 0, 4, 0),
 /*	AWACS_SWITCH("Unknown Playback Switch", 6, SHIFT_PAROUT0, 0), */
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers_beige[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mixers_beige[] = {
 	AWACS_VOLUME("Master Playback Volume", 2, 6, 1),
 	AWACS_VOLUME("Play-through Playback Volume", 5, 6, 1),
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_LINE, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers_lo[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mixers_lo[] = {
 	AWACS_VOLUME("Line out Playback Volume", 2, 6, 1),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers_imac[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mixers_imac[] = {
 	AWACS_VOLUME("Play-through Playback Volume", 5, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers_g4agp[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mixers_g4agp[] = {
 	AWACS_VOLUME("Line out Playback Volume", 2, 6, 1),
 	AWACS_VOLUME("Master Playback Volume", 5, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac7500[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac7500[] = {
 	AWACS_VOLUME("Line out Playback Volume", 2, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac5500[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac5500[] = {
 	AWACS_VOLUME("Headphone Playback Volume", 2, 6, 1),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac[] = {
 	AWACS_VOLUME("Master Playback Volume", 2, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 };
@@ -642,34 +642,34 @@ static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac[] __devinitdata = {
 /* FIXME: is this correct order?
  * screamer (powerbook G3 pismo) seems to have different bits...
  */
-static struct snd_kcontrol_new snd_pmac_awacs_mixers2[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mixers2[] = {
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_LINE, 0),
 	AWACS_SWITCH("Mic Capture Switch", 0, SHIFT_MUX_MIC, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers2[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mixers2[] = {
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
 	AWACS_SWITCH("Mic Capture Switch", 0, SHIFT_MUX_LINE, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mixers2_pmac5500[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mixers2_pmac5500[] = {
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_master_sw __devinitdata =
+static struct snd_kcontrol_new snd_pmac_awacs_master_sw =
 AWACS_SWITCH("Master Playback Switch", 1, SHIFT_HDMUTE, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_master_sw_imac __devinitdata =
+static struct snd_kcontrol_new snd_pmac_awacs_master_sw_imac =
 AWACS_SWITCH("Line out Playback Switch", 1, SHIFT_HDMUTE, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_master_sw_pmac5500 __devinitdata =
+static struct snd_kcontrol_new snd_pmac_awacs_master_sw_pmac5500 =
 AWACS_SWITCH("Headphone Playback Switch", 1, SHIFT_HDMUTE, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_mic_boost[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mic_boost[] = {
 	AWACS_SWITCH("Mic Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mic_boost[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mic_boost[] = {
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	  .name = "Mic Boost Capture Volume",
 	  .info = snd_pmac_screamer_mic_boost_info,
@@ -678,34 +678,34 @@ static struct snd_kcontrol_new snd_pmac_screamer_mic_boost[] __devinitdata = {
 	},
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mic_boost_pmac7500[] __devinitdata =
+static struct snd_kcontrol_new snd_pmac_awacs_mic_boost_pmac7500[] =
 {
 	AWACS_SWITCH("Line Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mic_boost_beige[] __devinitdata =
+static struct snd_kcontrol_new snd_pmac_screamer_mic_boost_beige[] =
 {
 	AWACS_SWITCH("Line Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
 	AWACS_SWITCH("CD Boost Capture Switch", 6, SHIFT_MIC_BOOST, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mic_boost_imac[] __devinitdata =
+static struct snd_kcontrol_new snd_pmac_screamer_mic_boost_imac[] =
 {
 	AWACS_SWITCH("Line Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
 	AWACS_SWITCH("Mic Boost Capture Switch", 6, SHIFT_MIC_BOOST, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_speaker_vol[] __devinitdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_speaker_vol[] = {
 	AWACS_VOLUME("Speaker Playback Volume", 4, 6, 1),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw __devinitdata =
+static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw =
 AWACS_SWITCH("Speaker Playback Switch", 1, SHIFT_SPKMUTE, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac1 __devinitdata =
+static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac1 =
 AWACS_SWITCH("Speaker Playback Switch", 1, SHIFT_PAROUT1, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac2 __devinitdata =
+static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac2 =
 AWACS_SWITCH("Speaker Playback Switch", 1, SHIFT_PAROUT1, 0);
 
 
@@ -872,7 +872,7 @@ static void snd_pmac_awacs_update_automute(struct snd_pmac *chip, int do_notify)
 /*
  * initialize chip
  */
-int __devinit
+int
 snd_pmac_awacs_init(struct snd_pmac *chip)
 {
 	int pm7500 = IS_PM7500;

commit 71a157e8edca55198e808f8561dd49017a54ee34
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Feb 1 21:34:14 2010 -0700

    of: add 'of_' prefix to machine_is_compatible()
    
    machine is compatible is an OF-specific call.  It should have
    the of_ prefix to protect the global namespace.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Michal Simek <monstr@monstr.eu>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 2e156467b814..b36679384b27 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -751,8 +751,8 @@ static void snd_pmac_awacs_suspend(struct snd_pmac *chip)
 
 static void snd_pmac_awacs_resume(struct snd_pmac *chip)
 {
-	if (machine_is_compatible("PowerBook3,1")
-	    || machine_is_compatible("PowerBook3,2")) {
+	if (of_machine_is_compatible("PowerBook3,1")
+	    || of_machine_is_compatible("PowerBook3,2")) {
 		msleep(100);
 		snd_pmac_awacs_write_reg(chip, 1,
 			chip->awacs_reg[1] & ~MASK_PAROUT);
@@ -780,16 +780,16 @@ static void snd_pmac_awacs_resume(struct snd_pmac *chip)
 }
 #endif /* CONFIG_PM */
 
-#define IS_PM7500 (machine_is_compatible("AAPL,7500") \
-		|| machine_is_compatible("AAPL,8500") \
-		|| machine_is_compatible("AAPL,9500"))
-#define IS_PM5500 (machine_is_compatible("AAPL,e411"))
-#define IS_BEIGE (machine_is_compatible("AAPL,Gossamer"))
-#define IS_IMAC1 (machine_is_compatible("PowerMac2,1"))
-#define IS_IMAC2 (machine_is_compatible("PowerMac2,2") \
-		|| machine_is_compatible("PowerMac4,1"))
-#define IS_G4AGP (machine_is_compatible("PowerMac3,1"))
-#define IS_LOMBARD (machine_is_compatible("PowerBook1,1"))
+#define IS_PM7500 (of_machine_is_compatible("AAPL,7500") \
+		|| of_machine_is_compatible("AAPL,8500") \
+		|| of_machine_is_compatible("AAPL,9500"))
+#define IS_PM5500 (of_machine_is_compatible("AAPL,e411"))
+#define IS_BEIGE (of_machine_is_compatible("AAPL,Gossamer"))
+#define IS_IMAC1 (of_machine_is_compatible("PowerMac2,1"))
+#define IS_IMAC2 (of_machine_is_compatible("PowerMac2,2") \
+		|| of_machine_is_compatible("PowerMac4,1"))
+#define IS_G4AGP (of_machine_is_compatible("PowerMac3,1"))
+#define IS_LOMBARD (of_machine_is_compatible("PowerBook1,1"))
 
 static int imac1, imac2;
 

commit ad1cd745060ae2f24026b3b3d09da3426df6ab36
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Wed Nov 4 14:30:36 2009 +0100

    ALSA: rename "PC Speaker" controls to "Speaker"
    
    To unify control names, rename "PC Speaker" to "Speaker" for PPC ALSA drivers.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 2cc0eda4f20e..2e156467b814 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -479,7 +479,7 @@ static int snd_pmac_awacs_put_master_amp(struct snd_kcontrol *kcontrol,
 
 static struct snd_kcontrol_new snd_pmac_awacs_amp_vol[] __devinitdata = {
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-	  .name = "PC Speaker Playback Volume",
+	  .name = "Speaker Playback Volume",
 	  .info = snd_pmac_awacs_info_volume_amp,
 	  .get = snd_pmac_awacs_get_volume_amp,
 	  .put = snd_pmac_awacs_put_volume_amp,
@@ -525,7 +525,7 @@ static struct snd_kcontrol_new snd_pmac_awacs_amp_hp_sw __devinitdata = {
 
 static struct snd_kcontrol_new snd_pmac_awacs_amp_spk_sw __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-	.name = "PC Speaker Playback Switch",
+	.name = "Speaker Playback Switch",
 	.info = snd_pmac_boolean_stereo_info,
 	.get = snd_pmac_awacs_get_switch_amp,
 	.put = snd_pmac_awacs_put_switch_amp,
@@ -696,17 +696,17 @@ static struct snd_kcontrol_new snd_pmac_screamer_mic_boost_imac[] __devinitdata
 };
 
 static struct snd_kcontrol_new snd_pmac_awacs_speaker_vol[] __devinitdata = {
-	AWACS_VOLUME("PC Speaker Playback Volume", 4, 6, 1),
+	AWACS_VOLUME("Speaker Playback Volume", 4, 6, 1),
 };
 
 static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw __devinitdata =
-AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_SPKMUTE, 1);
+AWACS_SWITCH("Speaker Playback Switch", 1, SHIFT_SPKMUTE, 1);
 
 static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac1 __devinitdata =
-AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_PAROUT1, 1);
+AWACS_SWITCH("Speaker Playback Switch", 1, SHIFT_PAROUT1, 1);
 
 static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac2 __devinitdata =
-AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_PAROUT1, 0);
+AWACS_SWITCH("Speaker Playback Switch", 1, SHIFT_PAROUT1, 0);
 
 
 /*

commit 3e1e0a5dd539f83438078759c8642c5dd7c24cb6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 3 08:13:15 2009 +0200

    ALSA: powermac - Replace the rest of __init*
    
    All __initdata should be __devinitdata as platform device is hotpluggable.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 0d2d62ddc543..2cc0eda4f20e 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -477,7 +477,7 @@ static int snd_pmac_awacs_put_master_amp(struct snd_kcontrol *kcontrol,
 #define AMP_CH_SPK	0
 #define AMP_CH_HD	1
 
-static struct snd_kcontrol_new snd_pmac_awacs_amp_vol[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_amp_vol[] __devinitdata = {
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	  .name = "PC Speaker Playback Volume",
 	  .info = snd_pmac_awacs_info_volume_amp,
@@ -514,7 +514,7 @@ static struct snd_kcontrol_new snd_pmac_awacs_amp_vol[] __initdata = {
 	},
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_amp_hp_sw __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_amp_hp_sw __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Headphone Playback Switch",
 	.info = snd_pmac_boolean_stereo_info,
@@ -523,7 +523,7 @@ static struct snd_kcontrol_new snd_pmac_awacs_amp_hp_sw __initdata = {
 	.private_value = AMP_CH_HD,
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_amp_spk_sw __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_amp_spk_sw __devinitdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "PC Speaker Playback Switch",
 	.info = snd_pmac_boolean_stereo_info,
@@ -595,46 +595,46 @@ static int snd_pmac_screamer_mic_boost_put(struct snd_kcontrol *kcontrol,
 /*
  * lists of mixer elements
  */
-static struct snd_kcontrol_new snd_pmac_awacs_mixers[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mixers[] __devinitdata = {
 	AWACS_SWITCH("Master Capture Switch", 1, SHIFT_LOOPTHRU, 0),
 	AWACS_VOLUME("Master Capture Volume", 0, 4, 0),
 /*	AWACS_SWITCH("Unknown Playback Switch", 6, SHIFT_PAROUT0, 0), */
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers_beige[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mixers_beige[] __devinitdata = {
 	AWACS_VOLUME("Master Playback Volume", 2, 6, 1),
 	AWACS_VOLUME("Play-through Playback Volume", 5, 6, 1),
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_LINE, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers_lo[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mixers_lo[] __devinitdata = {
 	AWACS_VOLUME("Line out Playback Volume", 2, 6, 1),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers_imac[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mixers_imac[] __devinitdata = {
 	AWACS_VOLUME("Play-through Playback Volume", 5, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers_g4agp[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mixers_g4agp[] __devinitdata = {
 	AWACS_VOLUME("Line out Playback Volume", 2, 6, 1),
 	AWACS_VOLUME("Master Playback Volume", 5, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac7500[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac7500[] __devinitdata = {
 	AWACS_VOLUME("Line out Playback Volume", 2, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac5500[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac5500[] __devinitdata = {
 	AWACS_VOLUME("Headphone Playback Volume", 2, 6, 1),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac[] __devinitdata = {
 	AWACS_VOLUME("Master Playback Volume", 2, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 };
@@ -642,34 +642,34 @@ static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac[] __initdata = {
 /* FIXME: is this correct order?
  * screamer (powerbook G3 pismo) seems to have different bits...
  */
-static struct snd_kcontrol_new snd_pmac_awacs_mixers2[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mixers2[] __devinitdata = {
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_LINE, 0),
 	AWACS_SWITCH("Mic Capture Switch", 0, SHIFT_MUX_MIC, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers2[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mixers2[] __devinitdata = {
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
 	AWACS_SWITCH("Mic Capture Switch", 0, SHIFT_MUX_LINE, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mixers2_pmac5500[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mixers2_pmac5500[] __devinitdata = {
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_master_sw __initdata =
+static struct snd_kcontrol_new snd_pmac_awacs_master_sw __devinitdata =
 AWACS_SWITCH("Master Playback Switch", 1, SHIFT_HDMUTE, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_master_sw_imac __initdata =
+static struct snd_kcontrol_new snd_pmac_awacs_master_sw_imac __devinitdata =
 AWACS_SWITCH("Line out Playback Switch", 1, SHIFT_HDMUTE, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_master_sw_pmac5500 __initdata =
+static struct snd_kcontrol_new snd_pmac_awacs_master_sw_pmac5500 __devinitdata =
 AWACS_SWITCH("Headphone Playback Switch", 1, SHIFT_HDMUTE, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_mic_boost[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mic_boost[] __devinitdata = {
 	AWACS_SWITCH("Mic Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mic_boost[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mic_boost[] __devinitdata = {
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	  .name = "Mic Boost Capture Volume",
 	  .info = snd_pmac_screamer_mic_boost_info,
@@ -678,34 +678,34 @@ static struct snd_kcontrol_new snd_pmac_screamer_mic_boost[] __initdata = {
 	},
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_mic_boost_pmac7500[] __initdata =
+static struct snd_kcontrol_new snd_pmac_awacs_mic_boost_pmac7500[] __devinitdata =
 {
 	AWACS_SWITCH("Line Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mic_boost_beige[] __initdata =
+static struct snd_kcontrol_new snd_pmac_screamer_mic_boost_beige[] __devinitdata =
 {
 	AWACS_SWITCH("Line Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
 	AWACS_SWITCH("CD Boost Capture Switch", 6, SHIFT_MIC_BOOST, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mic_boost_imac[] __initdata =
+static struct snd_kcontrol_new snd_pmac_screamer_mic_boost_imac[] __devinitdata =
 {
 	AWACS_SWITCH("Line Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
 	AWACS_SWITCH("Mic Boost Capture Switch", 6, SHIFT_MIC_BOOST, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_speaker_vol[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_speaker_vol[] __devinitdata = {
 	AWACS_VOLUME("PC Speaker Playback Volume", 4, 6, 1),
 };
 
-static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw __initdata =
+static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw __devinitdata =
 AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_SPKMUTE, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac1 __initdata =
+static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac1 __devinitdata =
 AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_PAROUT1, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac2 __initdata =
+static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac2 __devinitdata =
 AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_PAROUT1, 0);
 
 

commit 5c9b6e9e618868ac66d92c81b70ad57d82033d4e
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Wed Jun 3 15:35:19 2009 +1000

    ALSA: sound/ppc: update annotations of serveral functions
    
    [I am not sure if this is the correct approach as I don't know if any of
    this actual hardware or drivers are really hot pluggable.]
    
    Gets rid of these build warnings:
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x5c): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_new()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_new().
    If .snd_pmac_new is only used by .snd_pmac_probe then
    annotate .snd_pmac_new with a matching annotation.
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x10c): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_burgundy_init()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_burgundy_init().
    If .snd_pmac_burgundy_init is only used by .snd_pmac_probe then
    annotate .snd_pmac_burgundy_init with a matching annotation.
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x164): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_daca_init()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_daca_init().
    If .snd_pmac_daca_init is only used by .snd_pmac_probe then
    annotate .snd_pmac_daca_init with a matching annotation.
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x1dc): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_tumbler_init()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_tumbler_init().
    If .snd_pmac_tumbler_init is only used by .snd_pmac_probe then
    annotate .snd_pmac_tumbler_init with a matching annotation.
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x1ec): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_tumbler_post_init()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_tumbler_post_init().
    If .snd_pmac_tumbler_post_init is only used by .snd_pmac_probe then
    annotate .snd_pmac_tumbler_post_init with a matching annotation.
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x28c): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_awacs_init()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_awacs_init().
    If .snd_pmac_awacs_init is only used by .snd_pmac_probe then
    annotate .snd_pmac_awacs_init with a matching annotation.
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x2bc): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_pcm_new()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_pcm_new().
    If .snd_pmac_pcm_new is only used by .snd_pmac_probe then
    annotate .snd_pmac_pcm_new with a matching annotation.
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x2f8): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_attach_beep()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_attach_beep().
    If .snd_pmac_attach_beep is only used by .snd_pmac_probe then
    annotate .snd_pmac_attach_beep with a matching annotation.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 80df9b1f651e..0d2d62ddc543 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -872,7 +872,7 @@ static void snd_pmac_awacs_update_automute(struct snd_pmac *chip, int do_notify)
 /*
  * initialize chip
  */
-int __init
+int __devinit
 snd_pmac_awacs_init(struct snd_pmac *chip)
 {
 	int pm7500 = IS_PM7500;

commit dca7c74172fee0cf6ee1e303df093c31b5561039
Author: Risto Suominen <Risto.Suominen@gmail.com>
Date:   Tue Jan 20 22:01:17 2009 +0200

    ALSA: Add vmaster controls for Pmac 5500, iMac G3 SL, and PBook G3 Lombard
    
    Add virtual master controls for PowerMac 5500 (AWACS) and iMac G3 Slot-loading
    and PowerBook G3 Lombard (Screamer).
    
    Signed-off-by: Risto Suominen <Risto.Suominen@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 9abbf645eb67..80df9b1f651e 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -608,9 +608,12 @@ static struct snd_kcontrol_new snd_pmac_screamer_mixers_beige[] __initdata = {
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_LINE, 0),
 };
 
-static struct snd_kcontrol_new snd_pmac_screamer_mixers_imac[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mixers_lo[] __initdata = {
 	AWACS_VOLUME("Line out Playback Volume", 2, 6, 1),
-	AWACS_VOLUME("Master Playback Volume", 5, 6, 1),
+};
+
+static struct snd_kcontrol_new snd_pmac_screamer_mixers_imac[] __initdata = {
+	AWACS_VOLUME("Play-through Playback Volume", 5, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 };
 
@@ -627,6 +630,10 @@ static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac7500[] __initdata = {
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
 };
 
+static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac5500[] __initdata = {
+	AWACS_VOLUME("Headphone Playback Volume", 2, 6, 1),
+};
+
 static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac[] __initdata = {
 	AWACS_VOLUME("Master Playback Volume", 2, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
@@ -645,12 +652,19 @@ static struct snd_kcontrol_new snd_pmac_screamer_mixers2[] __initdata = {
 	AWACS_SWITCH("Mic Capture Switch", 0, SHIFT_MUX_LINE, 0),
 };
 
+static struct snd_kcontrol_new snd_pmac_awacs_mixers2_pmac5500[] __initdata = {
+	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
+};
+
 static struct snd_kcontrol_new snd_pmac_awacs_master_sw __initdata =
 AWACS_SWITCH("Master Playback Switch", 1, SHIFT_HDMUTE, 1);
 
 static struct snd_kcontrol_new snd_pmac_awacs_master_sw_imac __initdata =
 AWACS_SWITCH("Line out Playback Switch", 1, SHIFT_HDMUTE, 1);
 
+static struct snd_kcontrol_new snd_pmac_awacs_master_sw_pmac5500 __initdata =
+AWACS_SWITCH("Headphone Playback Switch", 1, SHIFT_HDMUTE, 1);
+
 static struct snd_kcontrol_new snd_pmac_awacs_mic_boost[] __initdata = {
 	AWACS_SWITCH("Mic Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
 };
@@ -868,6 +882,8 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 	int lombard = IS_LOMBARD;
 	int imac;
 	int err, vol;
+	struct snd_kcontrol *vmaster_sw, *vmaster_vol;
+	struct snd_kcontrol *master_vol, *speaker_vol;
 
 	imac1 = IS_IMAC1;
 	imac2 = IS_IMAC2;
@@ -968,19 +984,35 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 				   snd_pmac_awacs_mixers2);
 	if (err < 0)
 		return err;
+	if (pm5500) {
+		err = build_mixers(chip,
+				   ARRAY_SIZE(snd_pmac_awacs_mixers2_pmac5500),
+				   snd_pmac_awacs_mixers2_pmac5500);
+		if (err < 0)
+			return err;
+	}
 	if (pm7500)
 		err = build_mixers(chip,
 				   ARRAY_SIZE(snd_pmac_awacs_mixers_pmac7500),
 				   snd_pmac_awacs_mixers_pmac7500);
+	else if (pm5500)
+		err = snd_ctl_add(chip->card,
+		    (master_vol = snd_ctl_new1(snd_pmac_awacs_mixers_pmac5500,
+						chip)));
 	else if (beige)
 		err = build_mixers(chip,
 				   ARRAY_SIZE(snd_pmac_screamer_mixers_beige),
 				   snd_pmac_screamer_mixers_beige);
-	else if (imac || lombard)
+	else if (imac || lombard) {
+		err = snd_ctl_add(chip->card,
+		    (master_vol = snd_ctl_new1(snd_pmac_screamer_mixers_lo,
+						chip)));
+		if (err < 0)
+			return err;
 		err = build_mixers(chip,
 				   ARRAY_SIZE(snd_pmac_screamer_mixers_imac),
 				   snd_pmac_screamer_mixers_imac);
-	else if (g4agp)
+	} else if (g4agp)
 		err = build_mixers(chip,
 				   ARRAY_SIZE(snd_pmac_screamer_mixers_g4agp),
 				   snd_pmac_screamer_mixers_g4agp);
@@ -992,6 +1024,8 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 		return err;
 	chip->master_sw_ctl = snd_ctl_new1((pm7500 || imac || g4agp || lombard)
 			? &snd_pmac_awacs_master_sw_imac
+			: pm5500
+			? &snd_pmac_awacs_master_sw_pmac5500
 			: &snd_pmac_awacs_master_sw, chip);
 	err = snd_ctl_add(chip->card, chip->master_sw_ctl);
 	if (err < 0)
@@ -1023,8 +1057,9 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 #endif /* PMAC_AMP_AVAIL */
 	{
 		/* route A = headphone, route C = speaker */
-		err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_speaker_vol),
-					snd_pmac_awacs_speaker_vol);
+		err = snd_ctl_add(chip->card,
+		    (speaker_vol = snd_ctl_new1(snd_pmac_awacs_speaker_vol,
+						chip)));
 		if (err < 0)
 			return err;
 		chip->speaker_sw_ctl = snd_ctl_new1(imac1
@@ -1037,6 +1072,33 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 			return err;
 	}
 
+	if (pm5500 || imac || lombard) {
+		vmaster_sw = snd_ctl_make_virtual_master(
+			"Master Playback Switch", (unsigned int *) NULL);
+		err = snd_ctl_add_slave_uncached(vmaster_sw,
+						 chip->master_sw_ctl);
+		if (err < 0)
+			return err;
+		err = snd_ctl_add_slave_uncached(vmaster_sw,
+						  chip->speaker_sw_ctl);
+		if (err < 0)
+			return err;
+		err = snd_ctl_add(chip->card, vmaster_sw);
+		if (err < 0)
+			return err;
+		vmaster_vol = snd_ctl_make_virtual_master(
+			"Master Playback Volume", (unsigned int *) NULL);
+		err = snd_ctl_add_slave(vmaster_vol, master_vol);
+		if (err < 0)
+			return err;
+		err = snd_ctl_add_slave(vmaster_vol, speaker_vol);
+		if (err < 0)
+			return err;
+		err = snd_ctl_add(chip->card, vmaster_vol);
+		if (err < 0)
+			return err;
+	}
+
 	if (beige || g4agp)
 		err = build_mixers(chip,
 				ARRAY_SIZE(snd_pmac_screamer_mic_boost_beige),

commit 4d9e93b1adf2923c0a0cbc545d6e78dec3334faf
Author: Risto Suominen <Risto.Suominen@gmail.com>
Date:   Tue Jan 20 22:01:15 2009 +0200

    ALSA: powermac - Correct volume controls and HP detection for PMac 8500/9500
    
    Correct volume controls and headphone detection for PowerMac 8500/9500 (AWACS).
    
    Signed-off-by: Risto Suominen <Risto.Suominen@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index d89c23e135dc..9abbf645eb67 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -766,7 +766,9 @@ static void snd_pmac_awacs_resume(struct snd_pmac *chip)
 }
 #endif /* CONFIG_PM */
 
-#define IS_PM7500 (machine_is_compatible("AAPL,7500"))
+#define IS_PM7500 (machine_is_compatible("AAPL,7500") \
+		|| machine_is_compatible("AAPL,8500") \
+		|| machine_is_compatible("AAPL,9500"))
 #define IS_PM5500 (machine_is_compatible("AAPL,e411"))
 #define IS_BEIGE (machine_is_compatible("AAPL,Gossamer"))
 #define IS_IMAC1 (machine_is_compatible("PowerMac2,1"))

commit 573934bc038b0f47d17a5608e74b79dcd7c191ea
Author: Risto Suominen <Risto.Suominen@gmail.com>
Date:   Tue Jan 20 22:01:14 2009 +0200

    ALSA: powermac - Correct volume controls for PowerBook G3 Lombard
    
    Correct volume controls for PowerBook G3 Lombard (Screamer).
    
    Signed-off-by: Risto Suominen <Risto.Suominen@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 0258ccb8f431..d89c23e135dc 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -773,6 +773,7 @@ static void snd_pmac_awacs_resume(struct snd_pmac *chip)
 #define IS_IMAC2 (machine_is_compatible("PowerMac2,2") \
 		|| machine_is_compatible("PowerMac4,1"))
 #define IS_G4AGP (machine_is_compatible("PowerMac3,1"))
+#define IS_LOMBARD (machine_is_compatible("PowerBook1,1"))
 
 static int imac1, imac2;
 
@@ -862,6 +863,7 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 	int pm5500 = IS_PM5500;
 	int beige = IS_BEIGE;
 	int g4agp = IS_G4AGP;
+	int lombard = IS_LOMBARD;
 	int imac;
 	int err, vol;
 
@@ -972,7 +974,7 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 		err = build_mixers(chip,
 				   ARRAY_SIZE(snd_pmac_screamer_mixers_beige),
 				   snd_pmac_screamer_mixers_beige);
-	else if (imac)
+	else if (imac || lombard)
 		err = build_mixers(chip,
 				   ARRAY_SIZE(snd_pmac_screamer_mixers_imac),
 				   snd_pmac_screamer_mixers_imac);
@@ -986,7 +988,7 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 				   snd_pmac_awacs_mixers_pmac);
 	if (err < 0)
 		return err;
-	chip->master_sw_ctl = snd_ctl_new1((pm7500 || imac || g4agp)
+	chip->master_sw_ctl = snd_ctl_new1((pm7500 || imac || g4agp || lombard)
 			? &snd_pmac_awacs_master_sw_imac
 			: &snd_pmac_awacs_master_sw, chip);
 	err = snd_ctl_add(chip->card, chip->master_sw_ctl);

commit b0a8a8fd1b3bd6fbbb4b599191b859d41e12a002
Author: Risto Suominen <Risto.Suominen@gmail.com>
Date:   Tue Jan 20 22:01:13 2009 +0200

    ALSA: powermac - Correct HP detection and input selectors for PMac 5500
    
    Correct headphone detection and input selectors for PowerMac 5500 (AWACS).
    
    Signed-off-by: Risto Suominen <Risto.Suominen@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 7bd33e6552ab..0258ccb8f431 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -767,6 +767,7 @@ static void snd_pmac_awacs_resume(struct snd_pmac *chip)
 #endif /* CONFIG_PM */
 
 #define IS_PM7500 (machine_is_compatible("AAPL,7500"))
+#define IS_PM5500 (machine_is_compatible("AAPL,e411"))
 #define IS_BEIGE (machine_is_compatible("AAPL,Gossamer"))
 #define IS_IMAC1 (machine_is_compatible("PowerMac2,1"))
 #define IS_IMAC2 (machine_is_compatible("PowerMac2,2") \
@@ -858,6 +859,7 @@ int __init
 snd_pmac_awacs_init(struct snd_pmac *chip)
 {
 	int pm7500 = IS_PM7500;
+	int pm5500 = IS_PM5500;
 	int beige = IS_BEIGE;
 	int g4agp = IS_G4AGP;
 	int imac;
@@ -915,7 +917,7 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 		/* set headphone-jack detection bit */
 		switch (chip->model) {
 		case PMAC_AWACS:
-			chip->hp_stat_mask = pm7500 ? MASK_HDPCONN
+			chip->hp_stat_mask = pm7500 || pm5500 ? MASK_HDPCONN
 				: MASK_LOCONN;
 			break;
 		case PMAC_SCREAMER:
@@ -954,7 +956,7 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 		return err;
 	if (beige || g4agp)
 		;
-	else if (chip->model == PMAC_SCREAMER)
+	else if (chip->model == PMAC_SCREAMER || pm5500)
 		err = build_mixers(chip, ARRAY_SIZE(snd_pmac_screamer_mixers2),
 				   snd_pmac_screamer_mixers2);
 	else if (!pm7500)

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 106c48225bba..7bd33e6552ab 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -319,7 +319,8 @@ static void awacs_amp_set_master(struct awacs_amp *amp, int vol)
 static void awacs_amp_free(struct snd_pmac *chip)
 {
 	struct awacs_amp *amp = chip->mixer_data;
-	snd_assert(amp, return);
+	if (!amp)
+		return;
 	kfree(amp);
 	chip->mixer_data = NULL;
 	chip->mixer_free = NULL;
@@ -345,8 +346,7 @@ static int snd_pmac_awacs_get_volume_amp(struct snd_kcontrol *kcontrol,
 	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int index = kcontrol->private_value;
 	struct awacs_amp *amp = chip->mixer_data;
-	snd_assert(amp, return -EINVAL);
-	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+
 	ucontrol->value.integer.value[0] = 31 - (amp->amp_vol[index][0] & 31);
 	ucontrol->value.integer.value[1] = 31 - (amp->amp_vol[index][1] & 31);
 	return 0;
@@ -359,8 +359,6 @@ static int snd_pmac_awacs_put_volume_amp(struct snd_kcontrol *kcontrol,
 	int index = kcontrol->private_value;
 	int vol[2];
 	struct awacs_amp *amp = chip->mixer_data;
-	snd_assert(amp, return -EINVAL);
-	snd_assert(index >= 0 && index <= 1, return -EINVAL);
 
 	vol[0] = (31 - (ucontrol->value.integer.value[0] & 31))
 		| (amp->amp_vol[index][0] & 32);
@@ -375,8 +373,7 @@ static int snd_pmac_awacs_get_switch_amp(struct snd_kcontrol *kcontrol,
 	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int index = kcontrol->private_value;
 	struct awacs_amp *amp = chip->mixer_data;
-	snd_assert(amp, return -EINVAL);
-	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+
 	ucontrol->value.integer.value[0] = (amp->amp_vol[index][0] & 32)
 					? 0 : 1;
 	ucontrol->value.integer.value[1] = (amp->amp_vol[index][1] & 32)
@@ -391,8 +388,6 @@ static int snd_pmac_awacs_put_switch_amp(struct snd_kcontrol *kcontrol,
 	int index = kcontrol->private_value;
 	int vol[2];
 	struct awacs_amp *amp = chip->mixer_data;
-	snd_assert(amp, return -EINVAL);
-	snd_assert(index >= 0 && index <= 1, return -EINVAL);
 
 	vol[0] = (ucontrol->value.integer.value[0] ? 0 : 32)
 		| (amp->amp_vol[index][0] & 31);
@@ -417,8 +412,7 @@ static int snd_pmac_awacs_get_tone_amp(struct snd_kcontrol *kcontrol,
 	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int index = kcontrol->private_value;
 	struct awacs_amp *amp = chip->mixer_data;
-	snd_assert(amp, return -EINVAL);
-	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+
 	ucontrol->value.integer.value[0] = amp->amp_tone[index];
 	return 0;
 }
@@ -430,8 +424,7 @@ static int snd_pmac_awacs_put_tone_amp(struct snd_kcontrol *kcontrol,
 	int index = kcontrol->private_value;
 	struct awacs_amp *amp = chip->mixer_data;
 	unsigned int val;
-	snd_assert(amp, return -EINVAL);
-	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+
 	val = ucontrol->value.integer.value[0];
 	if (val > 14)
 		return -EINVAL;
@@ -458,7 +451,7 @@ static int snd_pmac_awacs_get_master_amp(struct snd_kcontrol *kcontrol,
 {
 	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	struct awacs_amp *amp = chip->mixer_data;
-	snd_assert(amp, return -EINVAL);
+
 	ucontrol->value.integer.value[0] = amp->amp_master;
 	return 0;
 }
@@ -469,7 +462,7 @@ static int snd_pmac_awacs_put_master_amp(struct snd_kcontrol *kcontrol,
 	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	struct awacs_amp *amp = chip->mixer_data;
 	unsigned int val;
-	snd_assert(amp, return -EINVAL);
+
 	val = ucontrol->value.integer.value[0];
 	if (val > 99)
 		return -EINVAL;

commit 030b655b062fe5190fc490e0091ea50307d7a86f
Author: Risto Suominen <Risto.Suominen@gmail.com>
Date:   Mon Aug 25 08:04:23 2008 +0200

    ALSA: snd-powermac: HP detection for 1st iMac G3 SL
    
    Correct headphone detection for 1st generation iMac G3 Slot-loading (Screamer).
    
    This patch fixes the regression in the recent snd-powermac which
    doesn't support some G3/G4 PowerMacs:
        http://lkml.org/lkml/2008/10/1/220
    
    Signed-off-by: Risto Suominen <Risto.Suominen@gmail.com>
    Tested-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Cc: stable@kernel.org
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 543d4f1784a5..106c48225bba 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -695,7 +695,10 @@ static struct snd_kcontrol_new snd_pmac_awacs_speaker_vol[] __initdata = {
 static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw __initdata =
 AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_SPKMUTE, 1);
 
-static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac __initdata =
+static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac1 __initdata =
+AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_PAROUT1, 1);
+
+static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac2 __initdata =
 AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_PAROUT1, 0);
 
 
@@ -772,12 +775,12 @@ static void snd_pmac_awacs_resume(struct snd_pmac *chip)
 
 #define IS_PM7500 (machine_is_compatible("AAPL,7500"))
 #define IS_BEIGE (machine_is_compatible("AAPL,Gossamer"))
-#define IS_IMAC (machine_is_compatible("PowerMac2,1") \
-		|| machine_is_compatible("PowerMac2,2") \
+#define IS_IMAC1 (machine_is_compatible("PowerMac2,1"))
+#define IS_IMAC2 (machine_is_compatible("PowerMac2,2") \
 		|| machine_is_compatible("PowerMac4,1"))
 #define IS_G4AGP (machine_is_compatible("PowerMac3,1"))
 
-static int imac;
+static int imac1, imac2;
 
 #ifdef PMAC_SUPPORT_AUTOMUTE
 /*
@@ -823,13 +826,18 @@ static void snd_pmac_awacs_update_automute(struct snd_pmac *chip, int do_notify)
 		{
 			int reg = chip->awacs_reg[1]
 				| (MASK_HDMUTE | MASK_SPKMUTE);
-			if (imac) {
+			if (imac1) {
+				reg &= ~MASK_SPKMUTE;
+				reg |= MASK_PAROUT1;
+			} else if (imac2) {
 				reg &= ~MASK_SPKMUTE;
 				reg &= ~MASK_PAROUT1;
 			}
 			if (snd_pmac_awacs_detect_headphone(chip))
 				reg &= ~MASK_HDMUTE;
-			else if (imac)
+			else if (imac1)
+				reg &= ~MASK_PAROUT1;
+			else if (imac2)
 				reg |= MASK_PAROUT1;
 			else
 				reg &= ~MASK_SPKMUTE;
@@ -859,9 +867,12 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 	int pm7500 = IS_PM7500;
 	int beige = IS_BEIGE;
 	int g4agp = IS_G4AGP;
+	int imac;
 	int err, vol;
 
-	imac = IS_IMAC;
+	imac1 = IS_IMAC1;
+	imac2 = IS_IMAC2;
+	imac = imac1 || imac2;
 	/* looks like MASK_GAINLINE triggers something, so we set here
 	 * as start-up
 	 */
@@ -1017,8 +1028,10 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 					snd_pmac_awacs_speaker_vol);
 		if (err < 0)
 			return err;
-		chip->speaker_sw_ctl = snd_ctl_new1(imac
-				? &snd_pmac_awacs_speaker_sw_imac
+		chip->speaker_sw_ctl = snd_ctl_new1(imac1
+				? &snd_pmac_awacs_speaker_sw_imac1
+				: imac2
+				? &snd_pmac_awacs_speaker_sw_imac2
 				: &snd_pmac_awacs_speaker_sw, chip);
 		err = snd_ctl_add(chip->card, chip->speaker_sw_ctl);
 		if (err < 0)

commit 4dbf95ba6c344186ec6d38ff514dc675da464bec
Author: Risto Suominen <Risto.Suominen@gmail.com>
Date:   Mon Aug 25 08:02:12 2008 +0200

    ALSA: snd-powermac: mixers for PowerMac G4 AGP
    
    Add mixer controls for PowerMac G4 AGP (Screamer).
    
    This patch fixes the regression in the recent snd-powermac which
    doesn't support some G3/G4 PowerMacs:
        http://lkml.org/lkml/2008/10/1/220
    
    Signed-off-by: Risto Suominen <Risto.Suominen@gmail.com>
    Tested-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Cc: stable@kernel.org
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 566a6d0daf4a..543d4f1784a5 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -621,6 +621,13 @@ static struct snd_kcontrol_new snd_pmac_screamer_mixers_imac[] __initdata = {
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 };
 
+static struct snd_kcontrol_new snd_pmac_screamer_mixers_g4agp[] __initdata = {
+	AWACS_VOLUME("Line out Playback Volume", 2, 6, 1),
+	AWACS_VOLUME("Master Playback Volume", 5, 6, 1),
+	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
+	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
+};
+
 static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac7500[] __initdata = {
 	AWACS_VOLUME("Line out Playback Volume", 2, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
@@ -768,6 +775,7 @@ static void snd_pmac_awacs_resume(struct snd_pmac *chip)
 #define IS_IMAC (machine_is_compatible("PowerMac2,1") \
 		|| machine_is_compatible("PowerMac2,2") \
 		|| machine_is_compatible("PowerMac4,1"))
+#define IS_G4AGP (machine_is_compatible("PowerMac3,1"))
 
 static int imac;
 
@@ -850,6 +858,7 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 {
 	int pm7500 = IS_PM7500;
 	int beige = IS_BEIGE;
+	int g4agp = IS_G4AGP;
 	int err, vol;
 
 	imac = IS_IMAC;
@@ -939,7 +948,7 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 				snd_pmac_awacs_mixers);
 	if (err < 0)
 		return err;
-	if (beige)
+	if (beige || g4agp)
 		;
 	else if (chip->model == PMAC_SCREAMER)
 		err = build_mixers(chip, ARRAY_SIZE(snd_pmac_screamer_mixers2),
@@ -961,13 +970,17 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 		err = build_mixers(chip,
 				   ARRAY_SIZE(snd_pmac_screamer_mixers_imac),
 				   snd_pmac_screamer_mixers_imac);
+	else if (g4agp)
+		err = build_mixers(chip,
+				   ARRAY_SIZE(snd_pmac_screamer_mixers_g4agp),
+				   snd_pmac_screamer_mixers_g4agp);
 	else
 		err = build_mixers(chip,
 				   ARRAY_SIZE(snd_pmac_awacs_mixers_pmac),
 				   snd_pmac_awacs_mixers_pmac);
 	if (err < 0)
 		return err;
-	chip->master_sw_ctl = snd_ctl_new1((pm7500 || imac)
+	chip->master_sw_ctl = snd_ctl_new1((pm7500 || imac || g4agp)
 			? &snd_pmac_awacs_master_sw_imac
 			: &snd_pmac_awacs_master_sw, chip);
 	err = snd_ctl_add(chip->card, chip->master_sw_ctl);
@@ -1012,7 +1025,7 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 			return err;
 	}
 
-	if (beige)
+	if (beige || g4agp)
 		err = build_mixers(chip,
 				ARRAY_SIZE(snd_pmac_screamer_mic_boost_beige),
 				snd_pmac_screamer_mic_boost_beige);

commit 7ae44cfa7ab29b277691327e8de790d7b880722f
Author: Risto Suominen <Risto.Suominen@gmail.com>
Date:   Wed Apr 16 19:39:27 2008 +0200

    [ALSA] snd-powermac: style awacs.s and awacs.h
    
    Coding style corrections for awacs.c and awacs.h.
    
    Signed-off-by: Risto Suominen <Risto.Suominen@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index db4e35d28244..566a6d0daf4a 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -141,7 +141,7 @@ static int snd_pmac_awacs_info_volume(struct snd_kcontrol *kcontrol,
 	uinfo->value.integer.max = 15;
 	return 0;
 }
- 
+
 static int snd_pmac_awacs_get_volume(struct snd_kcontrol *kcontrol,
 				     struct snd_ctl_elem_value *ucontrol)
 {
@@ -267,7 +267,8 @@ static int snd_pmac_awacs_put_switch(struct snd_kcontrol *kcontrol,
 static void awacs_set_cuda(int reg, int val)
 {
 	struct adb_request req;
-	cuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC, 0x8a, reg, val);
+	cuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC, 0x8a,
+			reg, val);
 	while (! req.complete)
 		cuda_poll();
 }
@@ -289,11 +290,11 @@ static void awacs_amp_set_tone(struct awacs_amp *amp, int bass, int treble)
 /*
  * vol = 0 - 31 (attenuation), 32 = mute bit, stereo
  */
-static int awacs_amp_set_vol(struct awacs_amp *amp, int index, int lvol, int rvol,
-			     int do_check)
+static int awacs_amp_set_vol(struct awacs_amp *amp, int index,
+			     int lvol, int rvol, int do_check)
 {
 	if (do_check && amp->amp_vol[index][0] == lvol &&
-	    amp->amp_vol[index][1] == rvol)
+			amp->amp_vol[index][1] == rvol)
 		return 0;
 	awacs_set_cuda(3 + index, lvol);
 	awacs_set_cuda(5 + index, rvol);
@@ -337,7 +338,7 @@ static int snd_pmac_awacs_info_volume_amp(struct snd_kcontrol *kcontrol,
 	uinfo->value.integer.max = 31;
 	return 0;
 }
- 
+
 static int snd_pmac_awacs_get_volume_amp(struct snd_kcontrol *kcontrol,
 					 struct snd_ctl_elem_value *ucontrol)
 {
@@ -361,8 +362,10 @@ static int snd_pmac_awacs_put_volume_amp(struct snd_kcontrol *kcontrol,
 	snd_assert(amp, return -EINVAL);
 	snd_assert(index >= 0 && index <= 1, return -EINVAL);
 
-	vol[0] = (31 - (ucontrol->value.integer.value[0] & 31)) | (amp->amp_vol[index][0] & 32);
-	vol[1] = (31 - (ucontrol->value.integer.value[1] & 31)) | (amp->amp_vol[index][1] & 32);
+	vol[0] = (31 - (ucontrol->value.integer.value[0] & 31))
+		| (amp->amp_vol[index][0] & 32);
+	vol[1] = (31 - (ucontrol->value.integer.value[1] & 31))
+		| (amp->amp_vol[index][1] & 32);
 	return awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);
 }
 
@@ -374,8 +377,10 @@ static int snd_pmac_awacs_get_switch_amp(struct snd_kcontrol *kcontrol,
 	struct awacs_amp *amp = chip->mixer_data;
 	snd_assert(amp, return -EINVAL);
 	snd_assert(index >= 0 && index <= 1, return -EINVAL);
-	ucontrol->value.integer.value[0] = (amp->amp_vol[index][0] & 32) ? 0 : 1;
-	ucontrol->value.integer.value[1] = (amp->amp_vol[index][1] & 32) ? 0 : 1;
+	ucontrol->value.integer.value[0] = (amp->amp_vol[index][0] & 32)
+					? 0 : 1;
+	ucontrol->value.integer.value[1] = (amp->amp_vol[index][1] & 32)
+					? 0 : 1;
 	return 0;
 }
 
@@ -389,8 +394,10 @@ static int snd_pmac_awacs_put_switch_amp(struct snd_kcontrol *kcontrol,
 	snd_assert(amp, return -EINVAL);
 	snd_assert(index >= 0 && index <= 1, return -EINVAL);
 
-	vol[0] = (ucontrol->value.integer.value[0] ? 0 : 32) | (amp->amp_vol[index][0] & 31);
-	vol[1] = (ucontrol->value.integer.value[1] ? 0 : 32) | (amp->amp_vol[index][1] & 31);
+	vol[0] = (ucontrol->value.integer.value[0] ? 0 : 32)
+		| (amp->amp_vol[index][0] & 31);
+	vol[1] = (ucontrol->value.integer.value[1] ? 0 : 32)
+		| (amp->amp_vol[index][1] & 31);
 	return awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);
 }
 
@@ -403,7 +410,7 @@ static int snd_pmac_awacs_info_tone_amp(struct snd_kcontrol *kcontrol,
 	uinfo->value.integer.max = 14;
 	return 0;
 }
- 
+
 static int snd_pmac_awacs_get_tone_amp(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_value *ucontrol)
 {
@@ -445,7 +452,7 @@ static int snd_pmac_awacs_info_master_amp(struct snd_kcontrol *kcontrol,
 	uinfo->value.integer.max = 99;
 	return 0;
 }
- 
+
 static int snd_pmac_awacs_get_master_amp(struct snd_kcontrol *kcontrol,
 					 struct snd_ctl_elem_value *ucontrol)
 {
@@ -688,12 +695,14 @@ AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_PAROUT1, 0);
 /*
  * add new mixer elements to the card
  */
-static int build_mixers(struct snd_pmac *chip, int nums, struct snd_kcontrol_new *mixers)
+static int build_mixers(struct snd_pmac *chip, int nums,
+			struct snd_kcontrol_new *mixers)
 {
 	int i, err;
 
 	for (i = 0; i < nums; i++) {
-		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&mixers[i], chip))) < 0)
+		err = snd_ctl_add(chip->card, snd_ctl_new1(&mixers[i], chip));
+		if (err < 0)
 			return err;
 	}
 	return 0;
@@ -743,8 +752,10 @@ static void snd_pmac_awacs_resume(struct snd_pmac *chip)
 #ifdef PMAC_AMP_AVAIL
 	if (chip->mixer_data) {
 		struct awacs_amp *amp = chip->mixer_data;
-		awacs_amp_set_vol(amp, 0, amp->amp_vol[0][0], amp->amp_vol[0][1], 0);
-		awacs_amp_set_vol(amp, 1, amp->amp_vol[1][0], amp->amp_vol[1][1], 0);
+		awacs_amp_set_vol(amp, 0,
+				  amp->amp_vol[0][0], amp->amp_vol[0][1], 0);
+		awacs_amp_set_vol(amp, 1,
+				  amp->amp_vol[1][0], amp->amp_vol[1][1], 0);
 		awacs_amp_set_tone(amp, amp->amp_tone[0], amp->amp_tone[1]);
 		awacs_amp_set_master(amp, amp->amp_master);
 	}
@@ -849,7 +860,7 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 	chip->awacs_reg[1] = MASK_CMUTE | MASK_AMUTE;
 	/* FIXME: Only machines with external SRS module need MASK_PAROUT */
 	if (chip->has_iic || chip->device_id == 0x5 ||
-	    /*chip->_device_id == 0x8 || */
+	    /* chip->_device_id == 0x8 || */
 	    chip->device_id == 0xb)
 		chip->awacs_reg[1] |= MASK_PAROUT;
 	/* get default volume from nvram */
@@ -860,8 +871,10 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 	chip->awacs_reg[2] = vol;
 	chip->awacs_reg[4] = vol;
 	if (chip->model == PMAC_SCREAMER) {
-		chip->awacs_reg[5] = vol; /* FIXME: screamer has loopthru vol control */
-		chip->awacs_reg[6] = MASK_MIC_BOOST; /* FIXME: maybe should be vol << 3 for PCMCIA speaker */
+		/* FIXME: screamer has loopthru vol control */
+		chip->awacs_reg[5] = vol;
+		/* FIXME: maybe should be vol << 3 for PCMCIA speaker */
+		chip->awacs_reg[6] = MASK_MIC_BOOST;
 		chip->awacs_reg[7] = 0;
 	}
 
@@ -877,7 +890,8 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 			return -ENOMEM;
 		chip->mixer_data = amp;
 		chip->mixer_free = awacs_amp_free;
-		awacs_amp_set_vol(amp, 0, 63, 63, 0); /* mute and zero vol */
+		/* mute and zero vol */
+		awacs_amp_set_vol(amp, 0, 63, 63, 0);
 		awacs_amp_set_vol(amp, 1, 63, 63, 0);
 		awacs_amp_set_tone(amp, 7, 7); /* 0 dB */
 		awacs_amp_set_master(amp, 79); /* 0 dB */
@@ -921,8 +935,9 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 	 */
 	strcpy(chip->card->mixername, "PowerMac AWACS");
 
-	if ((err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mixers),
-				snd_pmac_awacs_mixers)) < 0)
+	err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mixers),
+				snd_pmac_awacs_mixers);
+	if (err < 0)
 		return err;
 	if (beige)
 		;
@@ -955,7 +970,8 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 	chip->master_sw_ctl = snd_ctl_new1((pm7500 || imac)
 			? &snd_pmac_awacs_master_sw_imac
 			: &snd_pmac_awacs_master_sw, chip);
-	if ((err = snd_ctl_add(chip->card, chip->master_sw_ctl)) < 0)
+	err = snd_ctl_add(chip->card, chip->master_sw_ctl);
+	if (err < 0)
 		return err;
 #ifdef PMAC_AMP_AVAIL
 	if (chip->mixer_data) {
@@ -965,27 +981,34 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 		 * screamer registers.
 		 * in this case, it seems the route C is not used.
 		 */
-		if ((err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_amp_vol),
-					snd_pmac_awacs_amp_vol)) < 0)
+		err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_amp_vol),
+					snd_pmac_awacs_amp_vol);
+		if (err < 0)
 			return err;
 		/* overwrite */
-		chip->master_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_amp_hp_sw, chip);
-		if ((err = snd_ctl_add(chip->card, chip->master_sw_ctl)) < 0)
+		chip->master_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_amp_hp_sw,
+							chip);
+		err = snd_ctl_add(chip->card, chip->master_sw_ctl);
+		if (err < 0)
 			return err;
-		chip->speaker_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_amp_spk_sw, chip);
-		if ((err = snd_ctl_add(chip->card, chip->speaker_sw_ctl)) < 0)
+		chip->speaker_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_amp_spk_sw,
+							chip);
+		err = snd_ctl_add(chip->card, chip->speaker_sw_ctl);
+		if (err < 0)
 			return err;
 	} else
 #endif /* PMAC_AMP_AVAIL */
 	{
 		/* route A = headphone, route C = speaker */
-		if ((err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_speaker_vol),
-					snd_pmac_awacs_speaker_vol)) < 0)
+		err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_speaker_vol),
+					snd_pmac_awacs_speaker_vol);
+		if (err < 0)
 			return err;
 		chip->speaker_sw_ctl = snd_ctl_new1(imac
 				? &snd_pmac_awacs_speaker_sw_imac
 				: &snd_pmac_awacs_speaker_sw, chip);
-		if ((err = snd_ctl_add(chip->card, chip->speaker_sw_ctl)) < 0)
+		err = snd_ctl_add(chip->card, chip->speaker_sw_ctl);
+		if (err < 0)
 			return err;
 	}
 
@@ -1020,7 +1043,8 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 	chip->resume = snd_pmac_awacs_resume;
 #endif
 #ifdef PMAC_SUPPORT_AUTOMUTE
-	if ((err = snd_pmac_add_automute(chip)) < 0)
+	err = snd_pmac_add_automute(chip);
+	if (err < 0)
 		return err;
 	chip->detect_headphone = snd_pmac_awacs_detect_headphone;
 	chip->update_automute = snd_pmac_awacs_update_automute;

commit a8c2a6bf464d983c642c8b8b001a57aabbf76673
Author: Risto Suominen <Risto.Suominen@gmail.com>
Date:   Thu Apr 17 17:55:30 2008 +0200

    [ALSA] snd-powermac: AWACS and Screamer mixers for PM7500, Beige, and iMac SL
    
    Add mixer controls and correct headphone detection bits for PowerMacs
    7300/7500 (AWACS) and G3 Beige (Screamer), and iMac G3 Slot-loading
    (Screamer).
    
    Signed-off-by: Risto Suominen <Risto.Suominen@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 8441e780df00..db4e35d28244 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -544,7 +544,7 @@ static int snd_pmac_screamer_mic_boost_info(struct snd_kcontrol *kcontrol,
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
 	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 2;
+	uinfo->value.integer.max = 3;
 	return 0;
 }
 
@@ -552,16 +552,14 @@ static int snd_pmac_screamer_mic_boost_get(struct snd_kcontrol *kcontrol,
 					   struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
-	int val;
+	int val = 0;
 	unsigned long flags;
 
 	spin_lock_irqsave(&chip->reg_lock, flags);
 	if (chip->awacs_reg[6] & MASK_MIC_BOOST)
-		val = 2;
-	else if (chip->awacs_reg[0] & MASK_GAINLINE)
-		val = 1;
-	else
-		val = 0;
+		val |= 2;
+	if (chip->awacs_reg[0] & MASK_GAINLINE)
+		val |= 1;
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 	ucontrol->value.integer.value[0] = val;
 	return 0;
@@ -578,11 +576,10 @@ static int snd_pmac_screamer_mic_boost_put(struct snd_kcontrol *kcontrol,
 	spin_lock_irqsave(&chip->reg_lock, flags);
 	val0 = chip->awacs_reg[0] & ~MASK_GAINLINE;
 	val6 = chip->awacs_reg[6] & ~MASK_MIC_BOOST;
-	if (ucontrol->value.integer.value[0] > 0) {
+	if (ucontrol->value.integer.value[0] & 1)
 		val0 |= MASK_GAINLINE;
-		if (ucontrol->value.integer.value[0] > 1)
-			val6 |= MASK_MIC_BOOST;
-	}
+	if (ucontrol->value.integer.value[0] & 2)
+		val6 |= MASK_MIC_BOOST;
 	if (val0 != chip->awacs_reg[0]) {
 		snd_pmac_awacs_write_reg(chip, 0, val0);
 		changed = 1;
@@ -599,9 +596,32 @@ static int snd_pmac_screamer_mic_boost_put(struct snd_kcontrol *kcontrol,
  * lists of mixer elements
  */
 static struct snd_kcontrol_new snd_pmac_awacs_mixers[] __initdata = {
-	AWACS_VOLUME("Master Playback Volume", 2, 6, 1),
 	AWACS_SWITCH("Master Capture Switch", 1, SHIFT_LOOPTHRU, 0),
-	AWACS_VOLUME("Capture Volume", 0, 4, 0),
+	AWACS_VOLUME("Master Capture Volume", 0, 4, 0),
+/*	AWACS_SWITCH("Unknown Playback Switch", 6, SHIFT_PAROUT0, 0), */
+};
+
+static struct snd_kcontrol_new snd_pmac_screamer_mixers_beige[] __initdata = {
+	AWACS_VOLUME("Master Playback Volume", 2, 6, 1),
+	AWACS_VOLUME("Play-through Playback Volume", 5, 6, 1),
+	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
+	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_LINE, 0),
+};
+
+static struct snd_kcontrol_new snd_pmac_screamer_mixers_imac[] __initdata = {
+	AWACS_VOLUME("Line out Playback Volume", 2, 6, 1),
+	AWACS_VOLUME("Master Playback Volume", 5, 6, 1),
+	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
+};
+
+static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac7500[] __initdata = {
+	AWACS_VOLUME("Line out Playback Volume", 2, 6, 1),
+	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
+	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
+};
+
+static struct snd_kcontrol_new snd_pmac_awacs_mixers_pmac[] __initdata = {
+	AWACS_VOLUME("Master Playback Volume", 2, 6, 1),
 	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
 };
 
@@ -621,25 +641,49 @@ static struct snd_kcontrol_new snd_pmac_screamer_mixers2[] __initdata = {
 static struct snd_kcontrol_new snd_pmac_awacs_master_sw __initdata =
 AWACS_SWITCH("Master Playback Switch", 1, SHIFT_HDMUTE, 1);
 
+static struct snd_kcontrol_new snd_pmac_awacs_master_sw_imac __initdata =
+AWACS_SWITCH("Line out Playback Switch", 1, SHIFT_HDMUTE, 1);
+
 static struct snd_kcontrol_new snd_pmac_awacs_mic_boost[] __initdata = {
-	AWACS_SWITCH("Mic Boost", 0, SHIFT_GAINLINE, 0),
+	AWACS_SWITCH("Mic Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
 };
 
 static struct snd_kcontrol_new snd_pmac_screamer_mic_boost[] __initdata = {
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-	  .name = "Mic Boost",
+	  .name = "Mic Boost Capture Volume",
 	  .info = snd_pmac_screamer_mic_boost_info,
 	  .get = snd_pmac_screamer_mic_boost_get,
 	  .put = snd_pmac_screamer_mic_boost_put,
 	},
 };
 
+static struct snd_kcontrol_new snd_pmac_awacs_mic_boost_pmac7500[] __initdata =
+{
+	AWACS_SWITCH("Line Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
+};
+
+static struct snd_kcontrol_new snd_pmac_screamer_mic_boost_beige[] __initdata =
+{
+	AWACS_SWITCH("Line Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
+	AWACS_SWITCH("CD Boost Capture Switch", 6, SHIFT_MIC_BOOST, 0),
+};
+
+static struct snd_kcontrol_new snd_pmac_screamer_mic_boost_imac[] __initdata =
+{
+	AWACS_SWITCH("Line Boost Capture Switch", 0, SHIFT_GAINLINE, 0),
+	AWACS_SWITCH("Mic Boost Capture Switch", 6, SHIFT_MIC_BOOST, 0),
+};
+
 static struct snd_kcontrol_new snd_pmac_awacs_speaker_vol[] __initdata = {
 	AWACS_VOLUME("PC Speaker Playback Volume", 4, 6, 1),
 };
+
 static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw __initdata =
 AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_SPKMUTE, 1);
 
+static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw_imac __initdata =
+AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_PAROUT1, 0);
+
 
 /*
  * add new mixer elements to the card
@@ -708,6 +752,14 @@ static void snd_pmac_awacs_resume(struct snd_pmac *chip)
 }
 #endif /* CONFIG_PM */
 
+#define IS_PM7500 (machine_is_compatible("AAPL,7500"))
+#define IS_BEIGE (machine_is_compatible("AAPL,Gossamer"))
+#define IS_IMAC (machine_is_compatible("PowerMac2,1") \
+		|| machine_is_compatible("PowerMac2,2") \
+		|| machine_is_compatible("PowerMac4,1"))
+
+static int imac;
+
 #ifdef PMAC_SUPPORT_AUTOMUTE
 /*
  * auto-mute stuffs
@@ -750,9 +802,16 @@ static void snd_pmac_awacs_update_automute(struct snd_pmac *chip, int do_notify)
 		} else
 #endif
 		{
-			int reg = chip->awacs_reg[1] | (MASK_HDMUTE|MASK_SPKMUTE);
+			int reg = chip->awacs_reg[1]
+				| (MASK_HDMUTE | MASK_SPKMUTE);
+			if (imac) {
+				reg &= ~MASK_SPKMUTE;
+				reg &= ~MASK_PAROUT1;
+			}
 			if (snd_pmac_awacs_detect_headphone(chip))
 				reg &= ~MASK_HDMUTE;
+			else if (imac)
+				reg |= MASK_PAROUT1;
 			else
 				reg &= ~MASK_SPKMUTE;
 			if (do_notify && reg == chip->awacs_reg[1])
@@ -778,8 +837,11 @@ static void snd_pmac_awacs_update_automute(struct snd_pmac *chip, int do_notify)
 int __init
 snd_pmac_awacs_init(struct snd_pmac *chip)
 {
+	int pm7500 = IS_PM7500;
+	int beige = IS_BEIGE;
 	int err, vol;
 
+	imac = IS_IMAC;
 	/* looks like MASK_GAINLINE triggers something, so we set here
 	 * as start-up
 	 */
@@ -826,20 +888,25 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 		/* set headphone-jack detection bit */
 		switch (chip->model) {
 		case PMAC_AWACS:
-			chip->hp_stat_mask = 0x04;
+			chip->hp_stat_mask = pm7500 ? MASK_HDPCONN
+				: MASK_LOCONN;
 			break;
 		case PMAC_SCREAMER:
 			switch (chip->device_id) {
 			case 0x08:
-				/* 1 = side jack, 2 = front jack */
-				chip->hp_stat_mask = 0x03;
+			case 0x0B:
+				chip->hp_stat_mask = imac
+					? MASK_LOCONN_IMAC |
+					MASK_HDPLCONN_IMAC |
+					MASK_HDPRCONN_IMAC
+					: MASK_HDPCONN;
 				break;
 			case 0x00:
 			case 0x05:
-				chip->hp_stat_mask = 0x04;
+				chip->hp_stat_mask = MASK_LOCONN;
 				break;
 			default:
-				chip->hp_stat_mask = 0x08;
+				chip->hp_stat_mask = MASK_HDPCONN;
 				break;
 			}
 			break;
@@ -857,15 +924,37 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 	if ((err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mixers),
 				snd_pmac_awacs_mixers)) < 0)
 		return err;
-	if (chip->model == PMAC_SCREAMER)
+	if (beige)
+		;
+	else if (chip->model == PMAC_SCREAMER)
 		err = build_mixers(chip, ARRAY_SIZE(snd_pmac_screamer_mixers2),
 				   snd_pmac_screamer_mixers2);
-	else
+	else if (!pm7500)
 		err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mixers2),
 				   snd_pmac_awacs_mixers2);
 	if (err < 0)
 		return err;
-	chip->master_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_master_sw, chip);
+	if (pm7500)
+		err = build_mixers(chip,
+				   ARRAY_SIZE(snd_pmac_awacs_mixers_pmac7500),
+				   snd_pmac_awacs_mixers_pmac7500);
+	else if (beige)
+		err = build_mixers(chip,
+				   ARRAY_SIZE(snd_pmac_screamer_mixers_beige),
+				   snd_pmac_screamer_mixers_beige);
+	else if (imac)
+		err = build_mixers(chip,
+				   ARRAY_SIZE(snd_pmac_screamer_mixers_imac),
+				   snd_pmac_screamer_mixers_imac);
+	else
+		err = build_mixers(chip,
+				   ARRAY_SIZE(snd_pmac_awacs_mixers_pmac),
+				   snd_pmac_awacs_mixers_pmac);
+	if (err < 0)
+		return err;
+	chip->master_sw_ctl = snd_ctl_new1((pm7500 || imac)
+			? &snd_pmac_awacs_master_sw_imac
+			: &snd_pmac_awacs_master_sw, chip);
 	if ((err = snd_ctl_add(chip->card, chip->master_sw_ctl)) < 0)
 		return err;
 #ifdef PMAC_AMP_AVAIL
@@ -893,20 +982,34 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 		if ((err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_speaker_vol),
 					snd_pmac_awacs_speaker_vol)) < 0)
 			return err;
-		chip->speaker_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_speaker_sw, chip);
+		chip->speaker_sw_ctl = snd_ctl_new1(imac
+				? &snd_pmac_awacs_speaker_sw_imac
+				: &snd_pmac_awacs_speaker_sw, chip);
 		if ((err = snd_ctl_add(chip->card, chip->speaker_sw_ctl)) < 0)
 			return err;
 	}
 
-	if (chip->model == PMAC_SCREAMER) {
-		if ((err = build_mixers(chip, ARRAY_SIZE(snd_pmac_screamer_mic_boost),
-					snd_pmac_screamer_mic_boost)) < 0)
-			return err;
-	} else {
-		if ((err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mic_boost),
-					snd_pmac_awacs_mic_boost)) < 0)
-			return err;
-	}
+	if (beige)
+		err = build_mixers(chip,
+				ARRAY_SIZE(snd_pmac_screamer_mic_boost_beige),
+				snd_pmac_screamer_mic_boost_beige);
+	else if (imac)
+		err = build_mixers(chip,
+				ARRAY_SIZE(snd_pmac_screamer_mic_boost_imac),
+				snd_pmac_screamer_mic_boost_imac);
+	else if (chip->model == PMAC_SCREAMER)
+		err = build_mixers(chip,
+				ARRAY_SIZE(snd_pmac_screamer_mic_boost),
+				snd_pmac_screamer_mic_boost);
+	else if (pm7500)
+		err = build_mixers(chip,
+				ARRAY_SIZE(snd_pmac_awacs_mic_boost_pmac7500),
+				snd_pmac_awacs_mic_boost_pmac7500);
+	else
+		err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mic_boost),
+				snd_pmac_awacs_mic_boost);
+	if (err < 0)
+		return err;
 
 	/*
 	 * set lowlevel callbacks

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index b15bfb6f7011..8441e780df00 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -20,7 +20,6 @@
  */
 
 
-#include <sound/driver.h>
 #include <asm/io.h>
 #include <asm/nvram.h>
 #include <linux/init.h>

commit d4079ac49a08e36d6839a9ceb26aec8c24c9ed82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 15 16:14:12 2007 +0100

    [ALSA] powermac - Check value range in ctl callbacks
    
    Check the value ranges in ctl put callbacks properly in snd-powermac
    driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 05dabe454658..b15bfb6f7011 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -175,10 +175,12 @@ static int snd_pmac_awacs_put_volume(struct snd_kcontrol *kcontrol,
 	int inverted = (kcontrol->private_value >> 16) & 1;
 	int val, oldval;
 	unsigned long flags;
-	int vol[2];
+	unsigned int vol[2];
 
 	vol[0] = ucontrol->value.integer.value[0];
 	vol[1] = ucontrol->value.integer.value[1];
+	if (vol[0] > 0x0f || vol[1] > 0x0f)
+		return -EINVAL;
 	if (inverted) {
 		vol[0] = 0x0f - vol[0];
 		vol[1] = 0x0f - vol[1];
@@ -421,10 +423,14 @@ static int snd_pmac_awacs_put_tone_amp(struct snd_kcontrol *kcontrol,
 	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int index = kcontrol->private_value;
 	struct awacs_amp *amp = chip->mixer_data;
+	unsigned int val;
 	snd_assert(amp, return -EINVAL);
 	snd_assert(index >= 0 && index <= 1, return -EINVAL);
-	if (ucontrol->value.integer.value[0] != amp->amp_tone[index]) {
-		amp->amp_tone[index] = ucontrol->value.integer.value[0];
+	val = ucontrol->value.integer.value[0];
+	if (val > 14)
+		return -EINVAL;
+	if (val != amp->amp_tone[index]) {
+		amp->amp_tone[index] = val;
 		awacs_amp_set_tone(amp, amp->amp_tone[0], amp->amp_tone[1]);
 		return 1;
 	}
@@ -456,9 +462,13 @@ static int snd_pmac_awacs_put_master_amp(struct snd_kcontrol *kcontrol,
 {
 	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	struct awacs_amp *amp = chip->mixer_data;
+	unsigned int val;
 	snd_assert(amp, return -EINVAL);
-	if (ucontrol->value.integer.value[0] != amp->amp_master) {
-		amp->amp_master = ucontrol->value.integer.value[0];
+	val = ucontrol->value.integer.value[0];
+	if (val > 99)
+		return -EINVAL;
+	if (val != amp->amp_master) {
+		amp->amp_master = val;
 		awacs_amp_set_master(amp, amp->amp_master);
 		return 1;
 	}

commit 59feddb25f9d925e86ee22596802405788bc050f
Author: Panagiotis Issaris <takis@issaris.org>
Date:   Tue Jul 25 15:28:03 2006 +0200

    [ALSA] Conversions from kmalloc+memset to k(z|c)alloc
    
    sound: Conversions from kmalloc+memset to k(c|z)alloc.
    
    Signed-off-by: Panagiotis Issaris <takis@issaris.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 82d791be7499..05dabe454658 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -801,11 +801,10 @@ snd_pmac_awacs_init(struct snd_pmac *chip)
 	chip->revision = (in_le32(&chip->awacs->codec_stat) >> 12) & 0xf;
 #ifdef PMAC_AMP_AVAIL
 	if (chip->revision == 3 && chip->has_iic && CHECK_CUDA_AMP()) {
-		struct awacs_amp *amp = kmalloc(sizeof(*amp), GFP_KERNEL);
+		struct awacs_amp *amp = kzalloc(sizeof(*amp), GFP_KERNEL);
 		if (! amp)
 			return -ENOMEM;
 		chip->mixer_data = amp;
-		memset(amp, 0, sizeof(*amp));
 		chip->mixer_free = awacs_amp_free;
 		awacs_amp_set_vol(amp, 0, 63, 63, 0); /* mute and zero vol */
 		awacs_amp_set_vol(amp, 1, 63, 63, 0);

commit 65b29f5039b38a5854b5e12238b0688a33e235cc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:09:46 2005 +0100

    [ALSA] Remove xxx_t typedefs: PowerMac
    
    Remove xxx_t typedefs from the PowerMac driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 758ca1bcbcf2..82d791be7499 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -35,18 +35,18 @@
 #endif
 
 #ifdef PMAC_AMP_AVAIL
-typedef struct awacs_amp {
+struct awacs_amp {
 	unsigned char amp_master;
 	unsigned char amp_vol[2][2];
 	unsigned char amp_tone[2];
-} awacs_amp_t;
+};
 
 #define CHECK_CUDA_AMP() (sys_ctrler == SYS_CTRLER_CUDA)
 
 #endif /* PMAC_AMP_AVAIL */
 
 
-static void snd_pmac_screamer_wait(pmac_t *chip)
+static void snd_pmac_screamer_wait(struct snd_pmac *chip)
 {
 	long timeout = 2000;
 	while (!(in_le32(&chip->awacs->codec_stat) & MASK_VALID)) {
@@ -62,7 +62,7 @@ static void snd_pmac_screamer_wait(pmac_t *chip)
  * write AWACS register
  */
 static void
-snd_pmac_awacs_write(pmac_t *chip, int val)
+snd_pmac_awacs_write(struct snd_pmac *chip, int val)
 {
 	long timeout = 5000000;
 
@@ -78,21 +78,21 @@ snd_pmac_awacs_write(pmac_t *chip, int val)
 }
 
 static void
-snd_pmac_awacs_write_reg(pmac_t *chip, int reg, int val)
+snd_pmac_awacs_write_reg(struct snd_pmac *chip, int reg, int val)
 {
 	snd_pmac_awacs_write(chip, val | (reg << 12));
 	chip->awacs_reg[reg] = val;
 }
 
 static void
-snd_pmac_awacs_write_noreg(pmac_t *chip, int reg, int val)
+snd_pmac_awacs_write_noreg(struct snd_pmac *chip, int reg, int val)
 {
 	snd_pmac_awacs_write(chip, val | (reg << 12));
 }
 
 #ifdef CONFIG_PM
 /* Recalibrate chip */
-static void screamer_recalibrate(pmac_t *chip)
+static void screamer_recalibrate(struct snd_pmac *chip)
 {
 	if (chip->model != PMAC_SCREAMER)
 		return;
@@ -105,7 +105,8 @@ static void screamer_recalibrate(pmac_t *chip)
 		/* delay for broken crystal part */
 		msleep(750);
 	snd_pmac_awacs_write_noreg(chip, 1,
-				   chip->awacs_reg[1] | MASK_RECALIBRATE | MASK_CMUTE | MASK_AMUTE);
+				   chip->awacs_reg[1] | MASK_RECALIBRATE |
+				   MASK_CMUTE | MASK_AMUTE);
 	snd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);
 	snd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);
 }
@@ -118,7 +119,7 @@ static void screamer_recalibrate(pmac_t *chip)
 /*
  * additional callback to set the pcm format
  */
-static void snd_pmac_awacs_set_format(pmac_t *chip)
+static void snd_pmac_awacs_set_format(struct snd_pmac *chip)
 {
 	chip->awacs_reg[1] &= ~MASK_SAMPLERATE;
 	chip->awacs_reg[1] |= chip->rate_index << 3;
@@ -132,7 +133,8 @@ static void snd_pmac_awacs_set_format(pmac_t *chip)
 /*
  * volumes: 0-15 stereo
  */
-static int snd_pmac_awacs_info_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int snd_pmac_awacs_info_volume(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
@@ -141,9 +143,10 @@ static int snd_pmac_awacs_info_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_inf
 	return 0;
 }
  
-static int snd_pmac_awacs_get_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_pmac_awacs_get_volume(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int reg = kcontrol->private_value & 0xff;
 	int lshift = (kcontrol->private_value >> 8) & 0xff;
 	int inverted = (kcontrol->private_value >> 16) & 1;
@@ -163,9 +166,10 @@ static int snd_pmac_awacs_get_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_valu
 	return 0;
 }
 
-static int snd_pmac_awacs_put_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_pmac_awacs_put_volume(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int reg = kcontrol->private_value & 0xff;
 	int lshift = (kcontrol->private_value >> 8) & 0xff;
 	int inverted = (kcontrol->private_value >> 16) & 1;
@@ -203,9 +207,10 @@ static int snd_pmac_awacs_put_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_valu
 /*
  * mute master/ogain for AWACS: mono
  */
-static int snd_pmac_awacs_get_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_pmac_awacs_get_switch(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int reg = kcontrol->private_value & 0xff;
 	int shift = (kcontrol->private_value >> 8) & 0xff;
 	int invert = (kcontrol->private_value >> 16) & 1;
@@ -221,9 +226,10 @@ static int snd_pmac_awacs_get_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_valu
 	return 0;
 }
 
-static int snd_pmac_awacs_put_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_pmac_awacs_put_switch(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int reg = kcontrol->private_value & 0xff;
 	int shift = (kcontrol->private_value >> 8) & 0xff;
 	int invert = (kcontrol->private_value >> 16) & 1;
@@ -268,7 +274,7 @@ static void awacs_set_cuda(int reg, int val)
 /*
  * level = 0 - 14, 7 = 0 dB
  */
-static void awacs_amp_set_tone(awacs_amp_t *amp, int bass, int treble)
+static void awacs_amp_set_tone(struct awacs_amp *amp, int bass, int treble)
 {
 	amp->amp_tone[0] = bass;
 	amp->amp_tone[1] = treble;
@@ -282,7 +288,8 @@ static void awacs_amp_set_tone(awacs_amp_t *amp, int bass, int treble)
 /*
  * vol = 0 - 31 (attenuation), 32 = mute bit, stereo
  */
-static int awacs_amp_set_vol(awacs_amp_t *amp, int index, int lvol, int rvol, int do_check)
+static int awacs_amp_set_vol(struct awacs_amp *amp, int index, int lvol, int rvol,
+			     int do_check)
 {
 	if (do_check && amp->amp_vol[index][0] == lvol &&
 	    amp->amp_vol[index][1] == rvol)
@@ -297,7 +304,7 @@ static int awacs_amp_set_vol(awacs_amp_t *amp, int index, int lvol, int rvol, in
 /*
  * 0 = -79 dB, 79 = 0 dB, 99 = +20 dB
  */
-static void awacs_amp_set_master(awacs_amp_t *amp, int vol)
+static void awacs_amp_set_master(struct awacs_amp *amp, int vol)
 {
 	amp->amp_master = vol;
 	if (vol <= 79)
@@ -307,9 +314,9 @@ static void awacs_amp_set_master(awacs_amp_t *amp, int vol)
 	awacs_set_cuda(1, vol);
 }
 
-static void awacs_amp_free(pmac_t *chip)
+static void awacs_amp_free(struct snd_pmac *chip)
 {
-	awacs_amp_t *amp = chip->mixer_data;
+	struct awacs_amp *amp = chip->mixer_data;
 	snd_assert(amp, return);
 	kfree(amp);
 	chip->mixer_data = NULL;
@@ -320,7 +327,8 @@ static void awacs_amp_free(pmac_t *chip)
 /*
  * mixer controls
  */
-static int snd_pmac_awacs_info_volume_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int snd_pmac_awacs_info_volume_amp(struct snd_kcontrol *kcontrol,
+					  struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
@@ -329,11 +337,12 @@ static int snd_pmac_awacs_info_volume_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem
 	return 0;
 }
  
-static int snd_pmac_awacs_get_volume_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_pmac_awacs_get_volume_amp(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int index = kcontrol->private_value;
-	awacs_amp_t *amp = chip->mixer_data;
+	struct awacs_amp *amp = chip->mixer_data;
 	snd_assert(amp, return -EINVAL);
 	snd_assert(index >= 0 && index <= 1, return -EINVAL);
 	ucontrol->value.integer.value[0] = 31 - (amp->amp_vol[index][0] & 31);
@@ -341,12 +350,13 @@ static int snd_pmac_awacs_get_volume_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_
 	return 0;
 }
 
-static int snd_pmac_awacs_put_volume_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_pmac_awacs_put_volume_amp(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int index = kcontrol->private_value;
 	int vol[2];
-	awacs_amp_t *amp = chip->mixer_data;
+	struct awacs_amp *amp = chip->mixer_data;
 	snd_assert(amp, return -EINVAL);
 	snd_assert(index >= 0 && index <= 1, return -EINVAL);
 
@@ -355,11 +365,12 @@ static int snd_pmac_awacs_put_volume_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_
 	return awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);
 }
 
-static int snd_pmac_awacs_get_switch_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_pmac_awacs_get_switch_amp(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int index = kcontrol->private_value;
-	awacs_amp_t *amp = chip->mixer_data;
+	struct awacs_amp *amp = chip->mixer_data;
 	snd_assert(amp, return -EINVAL);
 	snd_assert(index >= 0 && index <= 1, return -EINVAL);
 	ucontrol->value.integer.value[0] = (amp->amp_vol[index][0] & 32) ? 0 : 1;
@@ -367,12 +378,13 @@ static int snd_pmac_awacs_get_switch_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_
 	return 0;
 }
 
-static int snd_pmac_awacs_put_switch_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_pmac_awacs_put_switch_amp(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int index = kcontrol->private_value;
 	int vol[2];
-	awacs_amp_t *amp = chip->mixer_data;
+	struct awacs_amp *amp = chip->mixer_data;
 	snd_assert(amp, return -EINVAL);
 	snd_assert(index >= 0 && index <= 1, return -EINVAL);
 
@@ -381,7 +393,8 @@ static int snd_pmac_awacs_put_switch_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_
 	return awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);
 }
 
-static int snd_pmac_awacs_info_tone_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int snd_pmac_awacs_info_tone_amp(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
@@ -390,22 +403,24 @@ static int snd_pmac_awacs_info_tone_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_i
 	return 0;
 }
  
-static int snd_pmac_awacs_get_tone_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_pmac_awacs_get_tone_amp(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int index = kcontrol->private_value;
-	awacs_amp_t *amp = chip->mixer_data;
+	struct awacs_amp *amp = chip->mixer_data;
 	snd_assert(amp, return -EINVAL);
 	snd_assert(index >= 0 && index <= 1, return -EINVAL);
 	ucontrol->value.integer.value[0] = amp->amp_tone[index];
 	return 0;
 }
 
-static int snd_pmac_awacs_put_tone_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_pmac_awacs_put_tone_amp(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int index = kcontrol->private_value;
-	awacs_amp_t *amp = chip->mixer_data;
+	struct awacs_amp *amp = chip->mixer_data;
 	snd_assert(amp, return -EINVAL);
 	snd_assert(index >= 0 && index <= 1, return -EINVAL);
 	if (ucontrol->value.integer.value[0] != amp->amp_tone[index]) {
@@ -416,7 +431,8 @@ static int snd_pmac_awacs_put_tone_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_va
 	return 0;
 }
 
-static int snd_pmac_awacs_info_master_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int snd_pmac_awacs_info_master_amp(struct snd_kcontrol *kcontrol,
+					  struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
@@ -425,19 +441,21 @@ static int snd_pmac_awacs_info_master_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem
 	return 0;
 }
  
-static int snd_pmac_awacs_get_master_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_pmac_awacs_get_master_amp(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
-	awacs_amp_t *amp = chip->mixer_data;
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
+	struct awacs_amp *amp = chip->mixer_data;
 	snd_assert(amp, return -EINVAL);
 	ucontrol->value.integer.value[0] = amp->amp_master;
 	return 0;
 }
 
-static int snd_pmac_awacs_put_master_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_pmac_awacs_put_master_amp(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
-	awacs_amp_t *amp = chip->mixer_data;
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
+	struct awacs_amp *amp = chip->mixer_data;
 	snd_assert(amp, return -EINVAL);
 	if (ucontrol->value.integer.value[0] != amp->amp_master) {
 		amp->amp_master = ucontrol->value.integer.value[0];
@@ -450,7 +468,7 @@ static int snd_pmac_awacs_put_master_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_
 #define AMP_CH_SPK	0
 #define AMP_CH_HD	1
 
-static snd_kcontrol_new_t snd_pmac_awacs_amp_vol[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_amp_vol[] __initdata = {
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	  .name = "PC Speaker Playback Volume",
 	  .info = snd_pmac_awacs_info_volume_amp,
@@ -487,7 +505,7 @@ static snd_kcontrol_new_t snd_pmac_awacs_amp_vol[] __initdata = {
 	},
 };
 
-static snd_kcontrol_new_t snd_pmac_awacs_amp_hp_sw __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_amp_hp_sw __initdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Headphone Playback Switch",
 	.info = snd_pmac_boolean_stereo_info,
@@ -496,7 +514,7 @@ static snd_kcontrol_new_t snd_pmac_awacs_amp_hp_sw __initdata = {
 	.private_value = AMP_CH_HD,
 };
 
-static snd_kcontrol_new_t snd_pmac_awacs_amp_spk_sw __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_amp_spk_sw __initdata = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "PC Speaker Playback Switch",
 	.info = snd_pmac_boolean_stereo_info,
@@ -511,7 +529,8 @@ static snd_kcontrol_new_t snd_pmac_awacs_amp_spk_sw __initdata = {
 /*
  * mic boost for screamer
  */
-static int snd_pmac_screamer_mic_boost_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int snd_pmac_screamer_mic_boost_info(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
@@ -520,9 +539,10 @@ static int snd_pmac_screamer_mic_boost_info(snd_kcontrol_t *kcontrol, snd_ctl_el
 	return 0;
 }
 
-static int snd_pmac_screamer_mic_boost_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_pmac_screamer_mic_boost_get(struct snd_kcontrol *kcontrol,
+					   struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int val;
 	unsigned long flags;
 
@@ -538,9 +558,10 @@ static int snd_pmac_screamer_mic_boost_get(snd_kcontrol_t *kcontrol, snd_ctl_ele
 	return 0;
 }
 
-static int snd_pmac_screamer_mic_boost_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_pmac_screamer_mic_boost_put(struct snd_kcontrol *kcontrol,
+					   struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	int changed = 0;
 	int val0, val6;
 	unsigned long flags;
@@ -568,7 +589,7 @@ static int snd_pmac_screamer_mic_boost_put(snd_kcontrol_t *kcontrol, snd_ctl_ele
 /*
  * lists of mixer elements
  */
-static snd_kcontrol_new_t snd_pmac_awacs_mixers[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mixers[] __initdata = {
 	AWACS_VOLUME("Master Playback Volume", 2, 6, 1),
 	AWACS_SWITCH("Master Capture Switch", 1, SHIFT_LOOPTHRU, 0),
 	AWACS_VOLUME("Capture Volume", 0, 4, 0),
@@ -578,24 +599,24 @@ static snd_kcontrol_new_t snd_pmac_awacs_mixers[] __initdata = {
 /* FIXME: is this correct order?
  * screamer (powerbook G3 pismo) seems to have different bits...
  */
-static snd_kcontrol_new_t snd_pmac_awacs_mixers2[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mixers2[] __initdata = {
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_LINE, 0),
 	AWACS_SWITCH("Mic Capture Switch", 0, SHIFT_MUX_MIC, 0),
 };
 
-static snd_kcontrol_new_t snd_pmac_screamer_mixers2[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mixers2[] __initdata = {
 	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
 	AWACS_SWITCH("Mic Capture Switch", 0, SHIFT_MUX_LINE, 0),
 };
 
-static snd_kcontrol_new_t snd_pmac_awacs_master_sw __initdata =
+static struct snd_kcontrol_new snd_pmac_awacs_master_sw __initdata =
 AWACS_SWITCH("Master Playback Switch", 1, SHIFT_HDMUTE, 1);
 
-static snd_kcontrol_new_t snd_pmac_awacs_mic_boost[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_mic_boost[] __initdata = {
 	AWACS_SWITCH("Mic Boost", 0, SHIFT_GAINLINE, 0),
 };
 
-static snd_kcontrol_new_t snd_pmac_screamer_mic_boost[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_screamer_mic_boost[] __initdata = {
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	  .name = "Mic Boost",
 	  .info = snd_pmac_screamer_mic_boost_info,
@@ -604,17 +625,17 @@ static snd_kcontrol_new_t snd_pmac_screamer_mic_boost[] __initdata = {
 	},
 };
 
-static snd_kcontrol_new_t snd_pmac_awacs_speaker_vol[] __initdata = {
+static struct snd_kcontrol_new snd_pmac_awacs_speaker_vol[] __initdata = {
 	AWACS_VOLUME("PC Speaker Playback Volume", 4, 6, 1),
 };
-static snd_kcontrol_new_t snd_pmac_awacs_speaker_sw __initdata =
+static struct snd_kcontrol_new snd_pmac_awacs_speaker_sw __initdata =
 AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_SPKMUTE, 1);
 
 
 /*
  * add new mixer elements to the card
  */
-static int build_mixers(pmac_t *chip, int nums, snd_kcontrol_new_t *mixers)
+static int build_mixers(struct snd_pmac *chip, int nums, struct snd_kcontrol_new *mixers)
 {
 	int i, err;
 
@@ -629,7 +650,7 @@ static int build_mixers(pmac_t *chip, int nums, snd_kcontrol_new_t *mixers)
 /*
  * restore all registers
  */
-static void awacs_restore_all_regs(pmac_t *chip)
+static void awacs_restore_all_regs(struct snd_pmac *chip)
 {
 	snd_pmac_awacs_write_noreg(chip, 0, chip->awacs_reg[0]);
 	snd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);
@@ -643,13 +664,13 @@ static void awacs_restore_all_regs(pmac_t *chip)
 }
 
 #ifdef CONFIG_PM
-static void snd_pmac_awacs_suspend(pmac_t *chip)
+static void snd_pmac_awacs_suspend(struct snd_pmac *chip)
 {
 	snd_pmac_awacs_write_noreg(chip, 1, (chip->awacs_reg[1]
 					     | MASK_AMUTE | MASK_CMUTE));
 }
 
-static void snd_pmac_awacs_resume(pmac_t *chip)
+static void snd_pmac_awacs_resume(struct snd_pmac *chip)
 {
 	if (machine_is_compatible("PowerBook3,1")
 	    || machine_is_compatible("PowerBook3,2")) {
@@ -668,7 +689,7 @@ static void snd_pmac_awacs_resume(pmac_t *chip)
 	screamer_recalibrate(chip);
 #ifdef PMAC_AMP_AVAIL
 	if (chip->mixer_data) {
-		awacs_amp_t *amp = chip->mixer_data;
+		struct awacs_amp *amp = chip->mixer_data;
 		awacs_amp_set_vol(amp, 0, amp->amp_vol[0][0], amp->amp_vol[0][1], 0);
 		awacs_amp_set_vol(amp, 1, amp->amp_vol[1][0], amp->amp_vol[1][1], 0);
 		awacs_amp_set_tone(amp, amp->amp_tone[0], amp->amp_tone[1]);
@@ -682,13 +703,13 @@ static void snd_pmac_awacs_resume(pmac_t *chip)
 /*
  * auto-mute stuffs
  */
-static int snd_pmac_awacs_detect_headphone(pmac_t *chip)
+static int snd_pmac_awacs_detect_headphone(struct snd_pmac *chip)
 {
 	return (in_le32(&chip->awacs->codec_stat) & chip->hp_stat_mask) ? 1 : 0;
 }
 
 #ifdef PMAC_AMP_AVAIL
-static int toggle_amp_mute(awacs_amp_t *amp, int index, int mute)
+static int toggle_amp_mute(struct awacs_amp *amp, int index, int mute)
 {
 	int vol[2];
 	vol[0] = amp->amp_vol[index][0] & 31;
@@ -701,12 +722,12 @@ static int toggle_amp_mute(awacs_amp_t *amp, int index, int mute)
 }
 #endif
 
-static void snd_pmac_awacs_update_automute(pmac_t *chip, int do_notify)
+static void snd_pmac_awacs_update_automute(struct snd_pmac *chip, int do_notify)
 {
 	if (chip->auto_mute) {
 #ifdef PMAC_AMP_AVAIL
 		if (chip->mixer_data) {
-			awacs_amp_t *amp = chip->mixer_data;
+			struct awacs_amp *amp = chip->mixer_data;
 			int changed;
 			if (snd_pmac_awacs_detect_headphone(chip)) {
 				changed = toggle_amp_mute(amp, AMP_CH_HD, 0);
@@ -746,7 +767,7 @@ static void snd_pmac_awacs_update_automute(pmac_t *chip, int do_notify)
  * initialize chip
  */
 int __init
-snd_pmac_awacs_init(pmac_t *chip)
+snd_pmac_awacs_init(struct snd_pmac *chip)
 {
 	int err, vol;
 
@@ -780,7 +801,7 @@ snd_pmac_awacs_init(pmac_t *chip)
 	chip->revision = (in_le32(&chip->awacs->codec_stat) >> 12) & 0xf;
 #ifdef PMAC_AMP_AVAIL
 	if (chip->revision == 3 && chip->has_iic && CHECK_CUDA_AMP()) {
-		awacs_amp_t *amp = kmalloc(sizeof(*amp), GFP_KERNEL);
+		struct awacs_amp *amp = kmalloc(sizeof(*amp), GFP_KERNEL);
 		if (! amp)
 			return -ENOMEM;
 		chip->mixer_data = amp;

commit 989a0b248bbf32c89e60dc6f02219e446b320712
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Sat Jul 9 10:53:24 2005 +0200

    [ALSA] Fix-up sleeping in sound/ppc
    
    PPC AWACS driver,PPC PMAC driver,PPC Tumbler driver
    Description: Fix-up sleeping in sound/ppc. Replace big_mdelay() with
    msleep() to guarantee the task delays as expected. This also involved
    replacing/removing custom sleep functions.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index 061e52d3d771..758ca1bcbcf2 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -103,7 +103,7 @@ static void screamer_recalibrate(pmac_t *chip)
 	snd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);
 	if (chip->manufacturer == 0x1)
 		/* delay for broken crystal part */
-		big_mdelay(750);
+		msleep(750);
 	snd_pmac_awacs_write_noreg(chip, 1,
 				   chip->awacs_reg[1] | MASK_RECALIBRATE | MASK_CMUTE | MASK_AMUTE);
 	snd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);
@@ -653,10 +653,10 @@ static void snd_pmac_awacs_resume(pmac_t *chip)
 {
 	if (machine_is_compatible("PowerBook3,1")
 	    || machine_is_compatible("PowerBook3,2")) {
-		big_mdelay(100);
+		msleep(100);
 		snd_pmac_awacs_write_reg(chip, 1,
 			chip->awacs_reg[1] & ~MASK_PAROUT);
-		big_mdelay(300);
+		msleep(300);
 	}
 
 	awacs_restore_all_regs(chip);

commit 8c8709334cec803368a432a33e0f2e116d48fe07
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jun 27 14:36:34 2005 -0700

    [PATCH] ppc32: Remove CONFIG_PMAC_PBOOK
    
    This patch removes CONFIG_PMAC_PBOOK (PowerBook support).  This is now
    split into CONFIG_PMAC_MEDIABAY for the actual hotswap bay that some
    powerbooks have, CONFIG_PM for power management related code, and just left
    out of any CONFIG_* option for some generally useful stuff that can be used
    on non-laptops as well.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
index e052bd071e5b..061e52d3d771 100644
--- a/sound/ppc/awacs.c
+++ b/sound/ppc/awacs.c
@@ -90,7 +90,7 @@ snd_pmac_awacs_write_noreg(pmac_t *chip, int reg, int val)
 	snd_pmac_awacs_write(chip, val | (reg << 12));
 }
 
-#ifdef CONFIG_PMAC_PBOOK
+#ifdef CONFIG_PM
 /* Recalibrate chip */
 static void screamer_recalibrate(pmac_t *chip)
 {
@@ -642,7 +642,7 @@ static void awacs_restore_all_regs(pmac_t *chip)
 	}
 }
 
-#ifdef CONFIG_PMAC_PBOOK
+#ifdef CONFIG_PM
 static void snd_pmac_awacs_suspend(pmac_t *chip)
 {
 	snd_pmac_awacs_write_noreg(chip, 1, (chip->awacs_reg[1]
@@ -676,7 +676,7 @@ static void snd_pmac_awacs_resume(pmac_t *chip)
 	}
 #endif
 }
-#endif /* CONFIG_PMAC_PBOOK */
+#endif /* CONFIG_PM */
 
 #ifdef PMAC_SUPPORT_AUTOMUTE
 /*
@@ -883,7 +883,7 @@ snd_pmac_awacs_init(pmac_t *chip)
 	 * set lowlevel callbacks
 	 */
 	chip->set_format = snd_pmac_awacs_set_format;
-#ifdef CONFIG_PMAC_PBOOK
+#ifdef CONFIG_PM
 	chip->suspend = snd_pmac_awacs_suspend;
 	chip->resume = snd_pmac_awacs_resume;
 #endif

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/ppc/awacs.c b/sound/ppc/awacs.c
new file mode 100644
index 000000000000..e052bd071e5b
--- /dev/null
+++ b/sound/ppc/awacs.c
@@ -0,0 +1,903 @@
+/*
+ * PMac AWACS lowlevel functions
+ *
+ * Copyright (c) by Takashi Iwai <tiwai@suse.de>
+ * code based on dmasound.c.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <asm/nvram.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include "pmac.h"
+
+
+#ifdef CONFIG_ADB_CUDA
+#define PMAC_AMP_AVAIL
+#endif
+
+#ifdef PMAC_AMP_AVAIL
+typedef struct awacs_amp {
+	unsigned char amp_master;
+	unsigned char amp_vol[2][2];
+	unsigned char amp_tone[2];
+} awacs_amp_t;
+
+#define CHECK_CUDA_AMP() (sys_ctrler == SYS_CTRLER_CUDA)
+
+#endif /* PMAC_AMP_AVAIL */
+
+
+static void snd_pmac_screamer_wait(pmac_t *chip)
+{
+	long timeout = 2000;
+	while (!(in_le32(&chip->awacs->codec_stat) & MASK_VALID)) {
+		mdelay(1);
+		if (! --timeout) {
+			snd_printd("snd_pmac_screamer_wait timeout\n");
+			break;
+		}
+	}
+}
+
+/*
+ * write AWACS register
+ */
+static void
+snd_pmac_awacs_write(pmac_t *chip, int val)
+{
+	long timeout = 5000000;
+
+	if (chip->model == PMAC_SCREAMER)
+		snd_pmac_screamer_wait(chip);
+	out_le32(&chip->awacs->codec_ctrl, val | (chip->subframe << 22));
+	while (in_le32(&chip->awacs->codec_ctrl) & MASK_NEWECMD) {
+		if (! --timeout) {
+			snd_printd("snd_pmac_awacs_write timeout\n");
+			break;
+		}
+	}
+}
+
+static void
+snd_pmac_awacs_write_reg(pmac_t *chip, int reg, int val)
+{
+	snd_pmac_awacs_write(chip, val | (reg << 12));
+	chip->awacs_reg[reg] = val;
+}
+
+static void
+snd_pmac_awacs_write_noreg(pmac_t *chip, int reg, int val)
+{
+	snd_pmac_awacs_write(chip, val | (reg << 12));
+}
+
+#ifdef CONFIG_PMAC_PBOOK
+/* Recalibrate chip */
+static void screamer_recalibrate(pmac_t *chip)
+{
+	if (chip->model != PMAC_SCREAMER)
+		return;
+
+	/* Sorry for the horrible delays... I hope to get that improved
+	 * by making the whole PM process asynchronous in a future version
+	 */
+	snd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);
+	if (chip->manufacturer == 0x1)
+		/* delay for broken crystal part */
+		big_mdelay(750);
+	snd_pmac_awacs_write_noreg(chip, 1,
+				   chip->awacs_reg[1] | MASK_RECALIBRATE | MASK_CMUTE | MASK_AMUTE);
+	snd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);
+	snd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);
+}
+
+#else
+#define screamer_recalibrate(chip) /* NOP */
+#endif
+
+
+/*
+ * additional callback to set the pcm format
+ */
+static void snd_pmac_awacs_set_format(pmac_t *chip)
+{
+	chip->awacs_reg[1] &= ~MASK_SAMPLERATE;
+	chip->awacs_reg[1] |= chip->rate_index << 3;
+	snd_pmac_awacs_write_reg(chip, 1, chip->awacs_reg[1]);
+}
+
+
+/*
+ * AWACS volume callbacks
+ */
+/*
+ * volumes: 0-15 stereo
+ */
+static int snd_pmac_awacs_info_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 15;
+	return 0;
+}
+ 
+static int snd_pmac_awacs_get_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int lshift = (kcontrol->private_value >> 8) & 0xff;
+	int inverted = (kcontrol->private_value >> 16) & 1;
+	unsigned long flags;
+	int vol[2];
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	vol[0] = (chip->awacs_reg[reg] >> lshift) & 0xf;
+	vol[1] = chip->awacs_reg[reg] & 0xf;
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	if (inverted) {
+		vol[0] = 0x0f - vol[0];
+		vol[1] = 0x0f - vol[1];
+	}
+	ucontrol->value.integer.value[0] = vol[0];
+	ucontrol->value.integer.value[1] = vol[1];
+	return 0;
+}
+
+static int snd_pmac_awacs_put_volume(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int lshift = (kcontrol->private_value >> 8) & 0xff;
+	int inverted = (kcontrol->private_value >> 16) & 1;
+	int val, oldval;
+	unsigned long flags;
+	int vol[2];
+
+	vol[0] = ucontrol->value.integer.value[0];
+	vol[1] = ucontrol->value.integer.value[1];
+	if (inverted) {
+		vol[0] = 0x0f - vol[0];
+		vol[1] = 0x0f - vol[1];
+	}
+	vol[0] &= 0x0f;
+	vol[1] &= 0x0f;
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	oldval = chip->awacs_reg[reg];
+	val = oldval & ~(0xf | (0xf << lshift));
+	val |= vol[0] << lshift;
+	val |= vol[1];
+	if (oldval != val)
+		snd_pmac_awacs_write_reg(chip, reg, val);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	return oldval != reg;
+}
+
+
+#define AWACS_VOLUME(xname, xreg, xshift, xinverted) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = 0, \
+  .info = snd_pmac_awacs_info_volume, \
+  .get = snd_pmac_awacs_get_volume, \
+  .put = snd_pmac_awacs_put_volume, \
+  .private_value = (xreg) | ((xshift) << 8) | ((xinverted) << 16) }
+
+/*
+ * mute master/ogain for AWACS: mono
+ */
+static int snd_pmac_awacs_get_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int invert = (kcontrol->private_value >> 16) & 1;
+	int val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	val = (chip->awacs_reg[reg] >> shift) & 1;
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	if (invert)
+		val = 1 - val;
+	ucontrol->value.integer.value[0] = val;
+	return 0;
+}
+
+static int snd_pmac_awacs_put_switch(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int invert = (kcontrol->private_value >> 16) & 1;
+	int mask = 1 << shift;
+	int val, changed;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	val = chip->awacs_reg[reg] & ~mask;
+	if (ucontrol->value.integer.value[0] != invert)
+		val |= mask;
+	changed = chip->awacs_reg[reg] != val;
+	if (changed)
+		snd_pmac_awacs_write_reg(chip, reg, val);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	return changed;
+}
+
+#define AWACS_SWITCH(xname, xreg, xshift, xinvert) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = 0, \
+  .info = snd_pmac_boolean_mono_info, \
+  .get = snd_pmac_awacs_get_switch, \
+  .put = snd_pmac_awacs_put_switch, \
+  .private_value = (xreg) | ((xshift) << 8) | ((xinvert) << 16) }
+
+
+#ifdef PMAC_AMP_AVAIL
+/*
+ * controls for perch/whisper extension cards, e.g. G3 desktop
+ *
+ * TDA7433 connected via i2c address 0x45 (= 0x8a),
+ * accessed through cuda
+ */
+static void awacs_set_cuda(int reg, int val)
+{
+	struct adb_request req;
+	cuda_request(&req, NULL, 5, CUDA_PACKET, CUDA_GET_SET_IIC, 0x8a, reg, val);
+	while (! req.complete)
+		cuda_poll();
+}
+
+/*
+ * level = 0 - 14, 7 = 0 dB
+ */
+static void awacs_amp_set_tone(awacs_amp_t *amp, int bass, int treble)
+{
+	amp->amp_tone[0] = bass;
+	amp->amp_tone[1] = treble;
+	if (bass > 7)
+		bass = (14 - bass) + 8;
+	if (treble > 7)
+		treble = (14 - treble) + 8;
+	awacs_set_cuda(2, (bass << 4) | treble);
+}
+
+/*
+ * vol = 0 - 31 (attenuation), 32 = mute bit, stereo
+ */
+static int awacs_amp_set_vol(awacs_amp_t *amp, int index, int lvol, int rvol, int do_check)
+{
+	if (do_check && amp->amp_vol[index][0] == lvol &&
+	    amp->amp_vol[index][1] == rvol)
+		return 0;
+	awacs_set_cuda(3 + index, lvol);
+	awacs_set_cuda(5 + index, rvol);
+	amp->amp_vol[index][0] = lvol;
+	amp->amp_vol[index][1] = rvol;
+	return 1;
+}
+
+/*
+ * 0 = -79 dB, 79 = 0 dB, 99 = +20 dB
+ */
+static void awacs_amp_set_master(awacs_amp_t *amp, int vol)
+{
+	amp->amp_master = vol;
+	if (vol <= 79)
+		vol = 32 + (79 - vol);
+	else
+		vol = 32 - (vol - 79);
+	awacs_set_cuda(1, vol);
+}
+
+static void awacs_amp_free(pmac_t *chip)
+{
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return);
+	kfree(amp);
+	chip->mixer_data = NULL;
+	chip->mixer_free = NULL;
+}
+
+
+/*
+ * mixer controls
+ */
+static int snd_pmac_awacs_info_volume_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 31;
+	return 0;
+}
+ 
+static int snd_pmac_awacs_get_volume_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int index = kcontrol->private_value;
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+	ucontrol->value.integer.value[0] = 31 - (amp->amp_vol[index][0] & 31);
+	ucontrol->value.integer.value[1] = 31 - (amp->amp_vol[index][1] & 31);
+	return 0;
+}
+
+static int snd_pmac_awacs_put_volume_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int index = kcontrol->private_value;
+	int vol[2];
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+
+	vol[0] = (31 - (ucontrol->value.integer.value[0] & 31)) | (amp->amp_vol[index][0] & 32);
+	vol[1] = (31 - (ucontrol->value.integer.value[1] & 31)) | (amp->amp_vol[index][1] & 32);
+	return awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);
+}
+
+static int snd_pmac_awacs_get_switch_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int index = kcontrol->private_value;
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+	ucontrol->value.integer.value[0] = (amp->amp_vol[index][0] & 32) ? 0 : 1;
+	ucontrol->value.integer.value[1] = (amp->amp_vol[index][1] & 32) ? 0 : 1;
+	return 0;
+}
+
+static int snd_pmac_awacs_put_switch_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int index = kcontrol->private_value;
+	int vol[2];
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+
+	vol[0] = (ucontrol->value.integer.value[0] ? 0 : 32) | (amp->amp_vol[index][0] & 31);
+	vol[1] = (ucontrol->value.integer.value[1] ? 0 : 32) | (amp->amp_vol[index][1] & 31);
+	return awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);
+}
+
+static int snd_pmac_awacs_info_tone_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 14;
+	return 0;
+}
+ 
+static int snd_pmac_awacs_get_tone_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int index = kcontrol->private_value;
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+	ucontrol->value.integer.value[0] = amp->amp_tone[index];
+	return 0;
+}
+
+static int snd_pmac_awacs_put_tone_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int index = kcontrol->private_value;
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	snd_assert(index >= 0 && index <= 1, return -EINVAL);
+	if (ucontrol->value.integer.value[0] != amp->amp_tone[index]) {
+		amp->amp_tone[index] = ucontrol->value.integer.value[0];
+		awacs_amp_set_tone(amp, amp->amp_tone[0], amp->amp_tone[1]);
+		return 1;
+	}
+	return 0;
+}
+
+static int snd_pmac_awacs_info_master_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 99;
+	return 0;
+}
+ 
+static int snd_pmac_awacs_get_master_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	ucontrol->value.integer.value[0] = amp->amp_master;
+	return 0;
+}
+
+static int snd_pmac_awacs_put_master_amp(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	awacs_amp_t *amp = chip->mixer_data;
+	snd_assert(amp, return -EINVAL);
+	if (ucontrol->value.integer.value[0] != amp->amp_master) {
+		amp->amp_master = ucontrol->value.integer.value[0];
+		awacs_amp_set_master(amp, amp->amp_master);
+		return 1;
+	}
+	return 0;
+}
+
+#define AMP_CH_SPK	0
+#define AMP_CH_HD	1
+
+static snd_kcontrol_new_t snd_pmac_awacs_amp_vol[] __initdata = {
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	  .name = "PC Speaker Playback Volume",
+	  .info = snd_pmac_awacs_info_volume_amp,
+	  .get = snd_pmac_awacs_get_volume_amp,
+	  .put = snd_pmac_awacs_put_volume_amp,
+	  .private_value = AMP_CH_SPK,
+	},
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	  .name = "Headphone Playback Volume",
+	  .info = snd_pmac_awacs_info_volume_amp,
+	  .get = snd_pmac_awacs_get_volume_amp,
+	  .put = snd_pmac_awacs_put_volume_amp,
+	  .private_value = AMP_CH_HD,
+	},
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	  .name = "Tone Control - Bass",
+	  .info = snd_pmac_awacs_info_tone_amp,
+	  .get = snd_pmac_awacs_get_tone_amp,
+	  .put = snd_pmac_awacs_put_tone_amp,
+	  .private_value = 0,
+	},
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	  .name = "Tone Control - Treble",
+	  .info = snd_pmac_awacs_info_tone_amp,
+	  .get = snd_pmac_awacs_get_tone_amp,
+	  .put = snd_pmac_awacs_put_tone_amp,
+	  .private_value = 1,
+	},
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	  .name = "Amp Master Playback Volume",
+	  .info = snd_pmac_awacs_info_master_amp,
+	  .get = snd_pmac_awacs_get_master_amp,
+	  .put = snd_pmac_awacs_put_master_amp,
+	},
+};
+
+static snd_kcontrol_new_t snd_pmac_awacs_amp_hp_sw __initdata = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Headphone Playback Switch",
+	.info = snd_pmac_boolean_stereo_info,
+	.get = snd_pmac_awacs_get_switch_amp,
+	.put = snd_pmac_awacs_put_switch_amp,
+	.private_value = AMP_CH_HD,
+};
+
+static snd_kcontrol_new_t snd_pmac_awacs_amp_spk_sw __initdata = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "PC Speaker Playback Switch",
+	.info = snd_pmac_boolean_stereo_info,
+	.get = snd_pmac_awacs_get_switch_amp,
+	.put = snd_pmac_awacs_put_switch_amp,
+	.private_value = AMP_CH_SPK,
+};
+
+#endif /* PMAC_AMP_AVAIL */
+
+
+/*
+ * mic boost for screamer
+ */
+static int snd_pmac_screamer_mic_boost_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 2;
+	return 0;
+}
+
+static int snd_pmac_screamer_mic_boost_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	if (chip->awacs_reg[6] & MASK_MIC_BOOST)
+		val = 2;
+	else if (chip->awacs_reg[0] & MASK_GAINLINE)
+		val = 1;
+	else
+		val = 0;
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	ucontrol->value.integer.value[0] = val;
+	return 0;
+}
+
+static int snd_pmac_screamer_mic_boost_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	int changed = 0;
+	int val0, val6;
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	val0 = chip->awacs_reg[0] & ~MASK_GAINLINE;
+	val6 = chip->awacs_reg[6] & ~MASK_MIC_BOOST;
+	if (ucontrol->value.integer.value[0] > 0) {
+		val0 |= MASK_GAINLINE;
+		if (ucontrol->value.integer.value[0] > 1)
+			val6 |= MASK_MIC_BOOST;
+	}
+	if (val0 != chip->awacs_reg[0]) {
+		snd_pmac_awacs_write_reg(chip, 0, val0);
+		changed = 1;
+	}
+	if (val6 != chip->awacs_reg[6]) {
+		snd_pmac_awacs_write_reg(chip, 6, val6);
+		changed = 1;
+	}
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	return changed;
+}
+
+/*
+ * lists of mixer elements
+ */
+static snd_kcontrol_new_t snd_pmac_awacs_mixers[] __initdata = {
+	AWACS_VOLUME("Master Playback Volume", 2, 6, 1),
+	AWACS_SWITCH("Master Capture Switch", 1, SHIFT_LOOPTHRU, 0),
+	AWACS_VOLUME("Capture Volume", 0, 4, 0),
+	AWACS_SWITCH("CD Capture Switch", 0, SHIFT_MUX_CD, 0),
+};
+
+/* FIXME: is this correct order?
+ * screamer (powerbook G3 pismo) seems to have different bits...
+ */
+static snd_kcontrol_new_t snd_pmac_awacs_mixers2[] __initdata = {
+	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_LINE, 0),
+	AWACS_SWITCH("Mic Capture Switch", 0, SHIFT_MUX_MIC, 0),
+};
+
+static snd_kcontrol_new_t snd_pmac_screamer_mixers2[] __initdata = {
+	AWACS_SWITCH("Line Capture Switch", 0, SHIFT_MUX_MIC, 0),
+	AWACS_SWITCH("Mic Capture Switch", 0, SHIFT_MUX_LINE, 0),
+};
+
+static snd_kcontrol_new_t snd_pmac_awacs_master_sw __initdata =
+AWACS_SWITCH("Master Playback Switch", 1, SHIFT_HDMUTE, 1);
+
+static snd_kcontrol_new_t snd_pmac_awacs_mic_boost[] __initdata = {
+	AWACS_SWITCH("Mic Boost", 0, SHIFT_GAINLINE, 0),
+};
+
+static snd_kcontrol_new_t snd_pmac_screamer_mic_boost[] __initdata = {
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	  .name = "Mic Boost",
+	  .info = snd_pmac_screamer_mic_boost_info,
+	  .get = snd_pmac_screamer_mic_boost_get,
+	  .put = snd_pmac_screamer_mic_boost_put,
+	},
+};
+
+static snd_kcontrol_new_t snd_pmac_awacs_speaker_vol[] __initdata = {
+	AWACS_VOLUME("PC Speaker Playback Volume", 4, 6, 1),
+};
+static snd_kcontrol_new_t snd_pmac_awacs_speaker_sw __initdata =
+AWACS_SWITCH("PC Speaker Playback Switch", 1, SHIFT_SPKMUTE, 1);
+
+
+/*
+ * add new mixer elements to the card
+ */
+static int build_mixers(pmac_t *chip, int nums, snd_kcontrol_new_t *mixers)
+{
+	int i, err;
+
+	for (i = 0; i < nums; i++) {
+		if ((err = snd_ctl_add(chip->card, snd_ctl_new1(&mixers[i], chip))) < 0)
+			return err;
+	}
+	return 0;
+}
+
+
+/*
+ * restore all registers
+ */
+static void awacs_restore_all_regs(pmac_t *chip)
+{
+	snd_pmac_awacs_write_noreg(chip, 0, chip->awacs_reg[0]);
+	snd_pmac_awacs_write_noreg(chip, 1, chip->awacs_reg[1]);
+	snd_pmac_awacs_write_noreg(chip, 2, chip->awacs_reg[2]);
+	snd_pmac_awacs_write_noreg(chip, 4, chip->awacs_reg[4]);
+	if (chip->model == PMAC_SCREAMER) {
+		snd_pmac_awacs_write_noreg(chip, 5, chip->awacs_reg[5]);
+		snd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);
+		snd_pmac_awacs_write_noreg(chip, 7, chip->awacs_reg[7]);
+	}
+}
+
+#ifdef CONFIG_PMAC_PBOOK
+static void snd_pmac_awacs_suspend(pmac_t *chip)
+{
+	snd_pmac_awacs_write_noreg(chip, 1, (chip->awacs_reg[1]
+					     | MASK_AMUTE | MASK_CMUTE));
+}
+
+static void snd_pmac_awacs_resume(pmac_t *chip)
+{
+	if (machine_is_compatible("PowerBook3,1")
+	    || machine_is_compatible("PowerBook3,2")) {
+		big_mdelay(100);
+		snd_pmac_awacs_write_reg(chip, 1,
+			chip->awacs_reg[1] & ~MASK_PAROUT);
+		big_mdelay(300);
+	}
+
+	awacs_restore_all_regs(chip);
+	if (chip->model == PMAC_SCREAMER) {
+		/* reset power bits in reg 6 */
+		mdelay(5);
+		snd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);
+	}
+	screamer_recalibrate(chip);
+#ifdef PMAC_AMP_AVAIL
+	if (chip->mixer_data) {
+		awacs_amp_t *amp = chip->mixer_data;
+		awacs_amp_set_vol(amp, 0, amp->amp_vol[0][0], amp->amp_vol[0][1], 0);
+		awacs_amp_set_vol(amp, 1, amp->amp_vol[1][0], amp->amp_vol[1][1], 0);
+		awacs_amp_set_tone(amp, amp->amp_tone[0], amp->amp_tone[1]);
+		awacs_amp_set_master(amp, amp->amp_master);
+	}
+#endif
+}
+#endif /* CONFIG_PMAC_PBOOK */
+
+#ifdef PMAC_SUPPORT_AUTOMUTE
+/*
+ * auto-mute stuffs
+ */
+static int snd_pmac_awacs_detect_headphone(pmac_t *chip)
+{
+	return (in_le32(&chip->awacs->codec_stat) & chip->hp_stat_mask) ? 1 : 0;
+}
+
+#ifdef PMAC_AMP_AVAIL
+static int toggle_amp_mute(awacs_amp_t *amp, int index, int mute)
+{
+	int vol[2];
+	vol[0] = amp->amp_vol[index][0] & 31;
+	vol[1] = amp->amp_vol[index][1] & 31;
+	if (mute) {
+		vol[0] |= 32;
+		vol[1] |= 32;
+	}
+	return awacs_amp_set_vol(amp, index, vol[0], vol[1], 1);
+}
+#endif
+
+static void snd_pmac_awacs_update_automute(pmac_t *chip, int do_notify)
+{
+	if (chip->auto_mute) {
+#ifdef PMAC_AMP_AVAIL
+		if (chip->mixer_data) {
+			awacs_amp_t *amp = chip->mixer_data;
+			int changed;
+			if (snd_pmac_awacs_detect_headphone(chip)) {
+				changed = toggle_amp_mute(amp, AMP_CH_HD, 0);
+				changed |= toggle_amp_mute(amp, AMP_CH_SPK, 1);
+			} else {
+				changed = toggle_amp_mute(amp, AMP_CH_HD, 1);
+				changed |= toggle_amp_mute(amp, AMP_CH_SPK, 0);
+			}
+			if (do_notify && ! changed)
+				return;
+		} else
+#endif
+		{
+			int reg = chip->awacs_reg[1] | (MASK_HDMUTE|MASK_SPKMUTE);
+			if (snd_pmac_awacs_detect_headphone(chip))
+				reg &= ~MASK_HDMUTE;
+			else
+				reg &= ~MASK_SPKMUTE;
+			if (do_notify && reg == chip->awacs_reg[1])
+				return;
+			snd_pmac_awacs_write_reg(chip, 1, reg);
+		}
+		if (do_notify) {
+			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+				       &chip->master_sw_ctl->id);
+			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+				       &chip->speaker_sw_ctl->id);
+			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+				       &chip->hp_detect_ctl->id);
+		}
+	}
+}
+#endif /* PMAC_SUPPORT_AUTOMUTE */
+
+
+/*
+ * initialize chip
+ */
+int __init
+snd_pmac_awacs_init(pmac_t *chip)
+{
+	int err, vol;
+
+	/* looks like MASK_GAINLINE triggers something, so we set here
+	 * as start-up
+	 */
+	chip->awacs_reg[0] = MASK_MUX_CD | 0xff | MASK_GAINLINE;
+	chip->awacs_reg[1] = MASK_CMUTE | MASK_AMUTE;
+	/* FIXME: Only machines with external SRS module need MASK_PAROUT */
+	if (chip->has_iic || chip->device_id == 0x5 ||
+	    /*chip->_device_id == 0x8 || */
+	    chip->device_id == 0xb)
+		chip->awacs_reg[1] |= MASK_PAROUT;
+	/* get default volume from nvram */
+	// vol = (~nvram_read_byte(0x1308) & 7) << 1;
+	// vol = ((pmac_xpram_read( 8 ) & 7 ) << 1 );
+	vol = 0x0f; /* no, on alsa, muted as default */
+	vol = vol + (vol << 6);
+	chip->awacs_reg[2] = vol;
+	chip->awacs_reg[4] = vol;
+	if (chip->model == PMAC_SCREAMER) {
+		chip->awacs_reg[5] = vol; /* FIXME: screamer has loopthru vol control */
+		chip->awacs_reg[6] = MASK_MIC_BOOST; /* FIXME: maybe should be vol << 3 for PCMCIA speaker */
+		chip->awacs_reg[7] = 0;
+	}
+
+	awacs_restore_all_regs(chip);
+	chip->manufacturer = (in_le32(&chip->awacs->codec_stat) >> 8) & 0xf;
+	screamer_recalibrate(chip);
+
+	chip->revision = (in_le32(&chip->awacs->codec_stat) >> 12) & 0xf;
+#ifdef PMAC_AMP_AVAIL
+	if (chip->revision == 3 && chip->has_iic && CHECK_CUDA_AMP()) {
+		awacs_amp_t *amp = kmalloc(sizeof(*amp), GFP_KERNEL);
+		if (! amp)
+			return -ENOMEM;
+		chip->mixer_data = amp;
+		memset(amp, 0, sizeof(*amp));
+		chip->mixer_free = awacs_amp_free;
+		awacs_amp_set_vol(amp, 0, 63, 63, 0); /* mute and zero vol */
+		awacs_amp_set_vol(amp, 1, 63, 63, 0);
+		awacs_amp_set_tone(amp, 7, 7); /* 0 dB */
+		awacs_amp_set_master(amp, 79); /* 0 dB */
+	}
+#endif /* PMAC_AMP_AVAIL */
+
+	if (chip->hp_stat_mask == 0) {
+		/* set headphone-jack detection bit */
+		switch (chip->model) {
+		case PMAC_AWACS:
+			chip->hp_stat_mask = 0x04;
+			break;
+		case PMAC_SCREAMER:
+			switch (chip->device_id) {
+			case 0x08:
+				/* 1 = side jack, 2 = front jack */
+				chip->hp_stat_mask = 0x03;
+				break;
+			case 0x00:
+			case 0x05:
+				chip->hp_stat_mask = 0x04;
+				break;
+			default:
+				chip->hp_stat_mask = 0x08;
+				break;
+			}
+			break;
+		default:
+			snd_BUG();
+			break;
+		}
+	}
+
+	/*
+	 * build mixers
+	 */
+	strcpy(chip->card->mixername, "PowerMac AWACS");
+
+	if ((err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mixers),
+				snd_pmac_awacs_mixers)) < 0)
+		return err;
+	if (chip->model == PMAC_SCREAMER)
+		err = build_mixers(chip, ARRAY_SIZE(snd_pmac_screamer_mixers2),
+				   snd_pmac_screamer_mixers2);
+	else
+		err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mixers2),
+				   snd_pmac_awacs_mixers2);
+	if (err < 0)
+		return err;
+	chip->master_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_master_sw, chip);
+	if ((err = snd_ctl_add(chip->card, chip->master_sw_ctl)) < 0)
+		return err;
+#ifdef PMAC_AMP_AVAIL
+	if (chip->mixer_data) {
+		/* use amplifier.  the signal is connected from route A
+		 * to the amp.  the amp has its headphone and speaker
+		 * volumes and mute switches, so we use them instead of
+		 * screamer registers.
+		 * in this case, it seems the route C is not used.
+		 */
+		if ((err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_amp_vol),
+					snd_pmac_awacs_amp_vol)) < 0)
+			return err;
+		/* overwrite */
+		chip->master_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_amp_hp_sw, chip);
+		if ((err = snd_ctl_add(chip->card, chip->master_sw_ctl)) < 0)
+			return err;
+		chip->speaker_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_amp_spk_sw, chip);
+		if ((err = snd_ctl_add(chip->card, chip->speaker_sw_ctl)) < 0)
+			return err;
+	} else
+#endif /* PMAC_AMP_AVAIL */
+	{
+		/* route A = headphone, route C = speaker */
+		if ((err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_speaker_vol),
+					snd_pmac_awacs_speaker_vol)) < 0)
+			return err;
+		chip->speaker_sw_ctl = snd_ctl_new1(&snd_pmac_awacs_speaker_sw, chip);
+		if ((err = snd_ctl_add(chip->card, chip->speaker_sw_ctl)) < 0)
+			return err;
+	}
+
+	if (chip->model == PMAC_SCREAMER) {
+		if ((err = build_mixers(chip, ARRAY_SIZE(snd_pmac_screamer_mic_boost),
+					snd_pmac_screamer_mic_boost)) < 0)
+			return err;
+	} else {
+		if ((err = build_mixers(chip, ARRAY_SIZE(snd_pmac_awacs_mic_boost),
+					snd_pmac_awacs_mic_boost)) < 0)
+			return err;
+	}
+
+	/*
+	 * set lowlevel callbacks
+	 */
+	chip->set_format = snd_pmac_awacs_set_format;
+#ifdef CONFIG_PMAC_PBOOK
+	chip->suspend = snd_pmac_awacs_suspend;
+	chip->resume = snd_pmac_awacs_resume;
+#endif
+#ifdef PMAC_SUPPORT_AUTOMUTE
+	if ((err = snd_pmac_add_automute(chip)) < 0)
+		return err;
+	chip->detect_headphone = snd_pmac_awacs_detect_headphone;
+	chip->update_automute = snd_pmac_awacs_update_automute;
+	snd_pmac_awacs_update_automute(chip, 0); /* update the status only */
+#endif
+	if (chip->model == PMAC_SCREAMER) {
+		snd_pmac_awacs_write_noreg(chip, 6, chip->awacs_reg[6]);
+		snd_pmac_awacs_write_noreg(chip, 0, chip->awacs_reg[0]);
+	}
+
+	return 0;
+}
