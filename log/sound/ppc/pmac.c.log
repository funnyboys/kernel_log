commit 59f00717bc09cc30cc61c05b1790db430357ced2
Author: Samuel Zou <zou_wei@huawei.com>
Date:   Thu May 7 11:54:07 2020 +0800

    ALSA: sound/ppc: Use bitwise instead of arithmetic operator for flags
    
    Fix the following coccinelle warnings:
    
    sound/ppc/pmac.c:729:57-58: WARNING: sum of probable bitmasks, consider |
    sound/ppc/pmac.c:229:37-38: WARNING: sum of probable bitmasks, consider |
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Samuel Zou <zou_wei@huawei.com>
    Link: https://lore.kernel.org/r/1588823647-12480-1-git-send-email-zou_wei@huawei.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 592532c09a82..2e750b317be1 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -226,7 +226,7 @@ static int snd_pmac_pcm_prepare(struct snd_pmac *chip, struct pmac_stream *rec,
 		offset += rec->period_size;
 	}
 	/* make loop */
-	cp->command = cpu_to_le16(DBDMA_NOP + BR_ALWAYS);
+	cp->command = cpu_to_le16(DBDMA_NOP | BR_ALWAYS);
 	cp->cmd_dep = cpu_to_le32(rec->cmd.addr);
 
 	snd_pmac_dma_stop(rec);
@@ -726,7 +726,7 @@ void snd_pmac_beep_dma_start(struct snd_pmac *chip, int bytes, unsigned long add
 	chip->extra_dma.cmds->xfer_status = cpu_to_le16(0);
 	chip->extra_dma.cmds->cmd_dep = cpu_to_le32(chip->extra_dma.addr);
 	chip->extra_dma.cmds->phy_addr = cpu_to_le32(addr);
-	chip->extra_dma.cmds->command = cpu_to_le16(OUTPUT_MORE + BR_ALWAYS);
+	chip->extra_dma.cmds->command = cpu_to_le16(OUTPUT_MORE | BR_ALWAYS);
 	out_le32(&chip->awacs->control,
 		 (in_le32(&chip->awacs->control) & ~0x1f00)
 		 | (speed << 8));

commit 6e9ef32fab28835110b5981295e6895bcac3614b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:32 2020 +0100

    ALSA: ppc: More constifications
    
    Apply const prefix to each possible place: the static tables for rate,
    volume, etc.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-18-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 87738ddc8bfd..592532c09a82 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -24,11 +24,11 @@
 
 
 /* fixed frequency table for awacs, screamer, burgundy, DACA (44100 max) */
-static int awacs_freqs[8] = {
+static const int awacs_freqs[8] = {
 	44100, 29400, 22050, 17640, 14700, 11025, 8820, 7350
 };
 /* fixed frequency table for tumbler */
-static int tumbler_freqs[1] = {
+static const int tumbler_freqs[1] = {
 	44100
 };
 
@@ -1174,7 +1174,7 @@ int snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 	np = chip->node;
 	chip->requested = 0;
 	if (chip->is_k2) {
-		static char *rnames[] = {
+		static const char * const rnames[] = {
 			"Sound Control", "Sound DMA" };
 		for (i = 0; i < 2; i ++) {
 			if (of_address_to_resource(np->parent, i,
@@ -1199,7 +1199,7 @@ int snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 		txdma_addr = chip->rsrc[1].start;
 		rxdma_addr = txdma_addr + 0x100;
 	} else {
-		static char *rnames[] = {
+		static const char * const rnames[] = {
 			"Sound Control", "Sound Tx DMA", "Sound Rx DMA" };
 		for (i = 0; i < 3; i ++) {
 			if (of_address_to_resource(np, i,

commit c031b0cc77a1bef980eb360e317a6bbd54211326
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:54 2020 +0100

    ALSA: ppc: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-39-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 6ee97008c8f0..87738ddc8bfd 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1104,7 +1104,7 @@ static int pmac_hp_detect_get(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static struct snd_kcontrol_new auto_mute_controls[] = {
+static const struct snd_kcontrol_new auto_mute_controls[] = {
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	  .name = "Auto Mute Switch",
 	  .info = snd_pmac_boolean_mono_info,

commit 46dd47c106f11587cf5887710765868e5bb53ce6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:31 2020 +0100

    ALSA: ppc: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 026410c7dd71..6ee97008c8f0 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1143,7 +1143,7 @@ int snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 	int i, err;
 	unsigned int irq;
 	unsigned long ctrl_addr, txdma_addr, rxdma_addr;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free =	snd_pmac_dev_free,
 	};
 

commit 5b6e996a6218eb91b8b44c3821b3ae109e9aca52
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:39 2019 +0100

    ALSA: ppc: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-18-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 1629f91d7ae2..026410c7dd71 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -653,7 +653,6 @@ static int snd_pmac_capture_close(struct snd_pcm_substream *subs)
 static const struct snd_pcm_ops snd_pmac_playback_ops = {
 	.open =		snd_pmac_playback_open,
 	.close =	snd_pmac_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_pmac_playback_prepare,
 	.trigger =	snd_pmac_playback_trigger,
 	.pointer =	snd_pmac_playback_pointer,
@@ -662,7 +661,6 @@ static const struct snd_pcm_ops snd_pmac_playback_ops = {
 static const struct snd_pcm_ops snd_pmac_capture_ops = {
 	.open =		snd_pmac_capture_open,
 	.close =	snd_pmac_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_pmac_capture_prepare,
 	.trigger =	snd_pmac_capture_trigger,
 	.pointer =	snd_pmac_capture_pointer,

commit 01001fa1c79e2bb6698c289010352cae7b0a142d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:30 2019 +0100

    ALSA: pmac: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The hw_params and hw_free callbacks became superfluous and got
    dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-59-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 1b11e53f6a62..1629f91d7ae2 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -107,24 +107,6 @@ static inline int another_stream(int stream)
 		SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
 }
 
-/*
- * allocate buffers
- */
-static int snd_pmac_pcm_hw_params(struct snd_pcm_substream *subs,
-				  struct snd_pcm_hw_params *hw_params)
-{
-	return snd_pcm_lib_malloc_pages(subs, params_buffer_bytes(hw_params));
-}
-
-/*
- * release buffers
- */
-static int snd_pmac_pcm_hw_free(struct snd_pcm_substream *subs)
-{
-	snd_pcm_lib_free_pages(subs);
-	return 0;
-}
-
 /*
  * get a stream of the opposite direction
  */
@@ -672,8 +654,6 @@ static const struct snd_pcm_ops snd_pmac_playback_ops = {
 	.open =		snd_pmac_playback_open,
 	.close =	snd_pmac_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_pmac_pcm_hw_params,
-	.hw_free =	snd_pmac_pcm_hw_free,
 	.prepare =	snd_pmac_playback_prepare,
 	.trigger =	snd_pmac_playback_trigger,
 	.pointer =	snd_pmac_playback_pointer,
@@ -683,8 +663,6 @@ static const struct snd_pcm_ops snd_pmac_capture_ops = {
 	.open =		snd_pmac_capture_open,
 	.close =	snd_pmac_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_pmac_pcm_hw_params,
-	.hw_free =	snd_pmac_pcm_hw_free,
 	.prepare =	snd_pmac_capture_prepare,
 	.trigger =	snd_pmac_capture_trigger,
 	.pointer =	snd_pmac_capture_pointer,
@@ -721,9 +699,9 @@ int snd_pmac_pcm_new(struct snd_pmac *chip)
 	chip->capture.cur_freqs = chip->freqs_ok;
 
 	/* preallocate 64k buffer */
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &chip->pdev->dev,
-					      64 * 1024, 64 * 1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
+				       &chip->pdev->dev,
+				       64 * 1024, 64 * 1024);
 
 	return 0;
 }

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 6d420bd3ae17..1b11e53f6a62 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1,22 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * PMac DBDMA lowlevel functions
  *
  * Copyright (c) by Takashi Iwai <tiwai@suse.de>
  * code based on dmasound.c.
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 

commit ece984a63a8d2d9132c6198d47d0a4be8ea99d17
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:03:52 2019 +0100

    ALSA: ppc: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index d692e4070167..6d420bd3ae17 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1365,7 +1365,6 @@ void snd_pmac_suspend(struct snd_pmac *chip)
 	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
 	if (chip->suspend)
 		chip->suspend(chip);
-	snd_pcm_suspend_all(chip->pcm);
 	spin_lock_irqsave(&chip->reg_lock, flags);
 	snd_pmac_beep_stop(chip);
 	spin_unlock_irqrestore(&chip->reg_lock, flags);

commit 157ab88ef64a2edccd722f120464109ceba9bac1
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 5 13:50:46 2018 -0600

    ALSA: aoa: Use of_node_name_eq for node name comparisons
    
    Convert string compares of DT node names to use of_node_name_eq helper
    instead. This removes direct access to the node name pointer.
    
    A couple of open coded iterating thru the child node names are converted
    to use for_each_child_of_node() instead.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 48dd44f8e914..d692e4070167 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -908,7 +908,7 @@ static void detect_byte_swap(struct snd_pmac *chip)
 
 	/* if seems that Keylargo can't byte-swap  */
 	for (mio = chip->node->parent; mio; mio = mio->parent) {
-		if (strcmp(mio->name, "mac-io") == 0) {
+		if (of_node_name_eq(mio, "mac-io")) {
 			if (of_device_is_compatible(mio, "Keylargo"))
 				chip->can_byte_swap = 0;
 			break;
@@ -1313,7 +1313,7 @@ int snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 	} else if (chip->is_pbook_G3) {
 		struct device_node* mio;
 		for (mio = chip->node->parent; mio; mio = mio->parent) {
-			if (strcmp(mio->name, "mac-io") == 0) {
+			if (of_node_name_eq(mio, "mac-io")) {
 				struct resource r;
 				if (of_address_to_resource(mio, 0, &r) == 0)
 					chip->macio_base =

commit 3179a3ea7125b8139aa977d7f8715f4960c241f8
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Aug 18 13:15:17 2017 +0530

    ALSA: ppc: constify snd_pcm_ops structures
    
    snd_pcm_ops are not supposed to change at runtime. All functions
    working with snd_pcm_ops provided by <sound/pcm.h> work with
    const snd_pcm_ops. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 45f0295fba56..48dd44f8e914 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -681,7 +681,7 @@ static int snd_pmac_capture_close(struct snd_pcm_substream *subs)
 /*
  */
 
-static struct snd_pcm_ops snd_pmac_playback_ops = {
+static const struct snd_pcm_ops snd_pmac_playback_ops = {
 	.open =		snd_pmac_playback_open,
 	.close =	snd_pmac_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -692,7 +692,7 @@ static struct snd_pcm_ops snd_pmac_playback_ops = {
 	.pointer =	snd_pmac_playback_pointer,
 };
 
-static struct snd_pcm_ops snd_pmac_capture_ops = {
+static const struct snd_pcm_ops snd_pmac_capture_ops = {
 	.open =		snd_pmac_capture_open,
 	.close =	snd_pmac_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,

commit 21bf6cf5565c15ea76c13ce88441212f3a1f99ef
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Thu Aug 17 14:45:56 2017 +0530

    ALSA: ppc: make snd_pcm_hardware const
    
    Make these const as they are only used in a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index a5843fc5ff20..45f0295fba56 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -509,7 +509,7 @@ static void snd_pmac_pcm_update(struct snd_pmac *chip, struct pmac_stream *rec)
  * hw info
  */
 
-static struct snd_pcm_hardware snd_pmac_playback =
+static const struct snd_pcm_hardware snd_pmac_playback =
 {
 	.info =			(SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_MMAP |
@@ -528,7 +528,7 @@ static struct snd_pcm_hardware snd_pmac_playback =
 	.periods_max =		PMAC_MAX_FRAGS,
 };
 
-static struct snd_pcm_hardware snd_pmac_capture =
+static const struct snd_pcm_hardware snd_pmac_capture =
 {
 	.info =			(SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_MMAP |

commit 952bbcb0781bd1341f6a9f5c96fc32737392c04a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 5 14:58:12 2016 -0600

    PCI: Remove includes of asm/pci-bridge.h
    
    Drivers should include asm/pci-bridge.h only when they need the arch-
    specific things provided there.  Outside of the arch/ directories, the only
    drivers that actually need things provided by asm/pci-bridge.h are the
    powerpc RPA hotplug drivers in drivers/pci/hotplug/rpa*.
    
    Remove the includes of asm/pci-bridge.h from the other drivers, adding an
    include of linux/pci.h if necessary.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 0095a80a997f..a5843fc5ff20 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -34,7 +34,6 @@
 #include "pmac.h"
 #include <sound/pcm_params.h>
 #include <asm/pmac_feature.h>
-#include <asm/pci-bridge.h>
 
 
 /* fixed frequency table for awacs, screamer, burgundy, DACA (44100 max) */

commit f5718726714cd6114876c4e3ca9b6992ab81176c
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Tue Feb 3 16:36:21 2015 +1100

    powerpc: Move Power Macintosh drivers to generic byteswappers
    
    ppc has special instruction forms to efficiently load and store values
    in non-native endianness.  These can be accessed via the arch-specific
    {ld,st}_le{16,32}() inlines in arch/powerpc/include/asm/swab.h.
    
    However, gcc is perfectly capable of generating the byte-reversing
    load/store instructions when using the normal, generic cpu_to_le*() and
    le*_to_cpu() functions eaning the arch-specific functions don't have much
    point.
    
    Worse the "le" in the names of the arch specific functions is now
    misleading, because they always generate byte-reversing forms, but some
    ppc machines can now run a little-endian kernel.
    
    To start getting rid of the arch-specific forms, this patch removes them
    from all the old Power Macintosh drivers, replacing them with the
    generic byteswappers.
    
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 13146d701413..0095a80a997f 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -240,7 +240,7 @@ static int snd_pmac_pcm_prepare(struct snd_pmac *chip, struct pmac_stream *rec,
 	 */
 	spin_lock_irq(&chip->reg_lock);
 	snd_pmac_dma_stop(rec);
-	st_le16(&chip->extra_dma.cmds->command, DBDMA_STOP);
+	chip->extra_dma.cmds->command = cpu_to_le16(DBDMA_STOP);
 	snd_pmac_dma_set_command(rec, &chip->extra_dma);
 	snd_pmac_dma_run(rec, RUN);
 	spin_unlock_irq(&chip->reg_lock);
@@ -251,15 +251,15 @@ static int snd_pmac_pcm_prepare(struct snd_pmac *chip, struct pmac_stream *rec,
 	 */
 	offset = runtime->dma_addr;
 	for (i = 0, cp = rec->cmd.cmds; i < rec->nperiods; i++, cp++) {
-		st_le32(&cp->phy_addr, offset);
-		st_le16(&cp->req_count, rec->period_size);
-		/*st_le16(&cp->res_count, 0);*/
-		st_le16(&cp->xfer_status, 0);
+		cp->phy_addr = cpu_to_le32(offset);
+		cp->req_count = cpu_to_le16(rec->period_size);
+		/*cp->res_count = cpu_to_le16(0);*/
+		cp->xfer_status = cpu_to_le16(0);
 		offset += rec->period_size;
 	}
 	/* make loop */
-	st_le16(&cp->command, DBDMA_NOP + BR_ALWAYS);
-	st_le32(&cp->cmd_dep, rec->cmd.addr);
+	cp->command = cpu_to_le16(DBDMA_NOP + BR_ALWAYS);
+	cp->cmd_dep = cpu_to_le32(rec->cmd.addr);
 
 	snd_pmac_dma_stop(rec);
 	snd_pmac_dma_set_command(rec, &rec->cmd);
@@ -328,7 +328,7 @@ static snd_pcm_uframes_t snd_pmac_pcm_pointer(struct snd_pmac *chip,
 #if 1 /* hmm.. how can we get the current dma pointer?? */
 	int stat;
 	volatile struct dbdma_cmd __iomem *cp = &rec->cmd.cmds[rec->cur_period];
-	stat = ld_le16(&cp->xfer_status);
+	stat = le16_to_cpu(cp->xfer_status);
 	if (stat & (ACTIVE|DEAD)) {
 		count = in_le16(&cp->res_count);
 		if (count)
@@ -427,26 +427,26 @@ static inline void snd_pmac_pcm_dead_xfer(struct pmac_stream *rec,
 		memcpy((void *)emergency_dbdma.cmds, (void *)cp,
 		       sizeof(struct dbdma_cmd));
 		emergency_in_use = 1;
-		st_le16(&cp->xfer_status, 0);
-		st_le16(&cp->req_count, rec->period_size);
+		cp->xfer_status = cpu_to_le16(0);
+		cp->req_count = cpu_to_le16(rec->period_size);
 		cp = emergency_dbdma.cmds;
 	}
 
 	/* now bump the values to reflect the amount
 	   we haven't yet shifted */
-	req = ld_le16(&cp->req_count);
-	res = ld_le16(&cp->res_count);
-	phy = ld_le32(&cp->phy_addr);
+	req = le16_to_cpu(cp->req_count);
+	res = le16_to_cpu(cp->res_count);
+	phy = le32_to_cpu(cp->phy_addr);
 	phy += (req - res);
-	st_le16(&cp->req_count, res);
-	st_le16(&cp->res_count, 0);
-	st_le16(&cp->xfer_status, 0);
-	st_le32(&cp->phy_addr, phy);
+	cp->req_count = cpu_to_le16(res);
+	cp->res_count = cpu_to_le16(0);
+	cp->xfer_status = cpu_to_le16(0);
+	cp->phy_addr = cpu_to_le32(phy);
 
-	st_le32(&cp->cmd_dep, rec->cmd.addr
+	cp->cmd_dep = cpu_to_le32(rec->cmd.addr
 		+ sizeof(struct dbdma_cmd)*((rec->cur_period+1)%rec->nperiods));
 
-	st_le16(&cp->command, OUTPUT_MORE | BR_ALWAYS | INTR_ALWAYS);
+	cp->command = cpu_to_le16(OUTPUT_MORE | BR_ALWAYS | INTR_ALWAYS);
 
 	/* point at our patched up command block */
 	out_le32(&rec->dma->cmdptr, emergency_dbdma.addr);
@@ -475,7 +475,7 @@ static void snd_pmac_pcm_update(struct snd_pmac *chip, struct pmac_stream *rec)
 			else
 				cp = &rec->cmd.cmds[rec->cur_period];
 
-			stat = ld_le16(&cp->xfer_status);
+			stat = le16_to_cpu(cp->xfer_status);
 
 			if (stat & DEAD) {
 				snd_pmac_pcm_dead_xfer(rec, cp);
@@ -489,9 +489,9 @@ static void snd_pmac_pcm_update(struct snd_pmac *chip, struct pmac_stream *rec)
 				break;
 
 			/*printk(KERN_DEBUG "update frag %d\n", rec->cur_period);*/
-			st_le16(&cp->xfer_status, 0);
-			st_le16(&cp->req_count, rec->period_size);
-			/*st_le16(&cp->res_count, 0);*/
+			cp->xfer_status = cpu_to_le16(0);
+			cp->req_count = cpu_to_le16(rec->period_size);
+			/*cp->res_count = cpu_to_le16(0);*/
 			rec->cur_period++;
 			if (rec->cur_period >= rec->nperiods) {
 				rec->cur_period = 0;
@@ -760,11 +760,11 @@ void snd_pmac_beep_dma_start(struct snd_pmac *chip, int bytes, unsigned long add
 	struct pmac_stream *rec = &chip->playback;
 
 	snd_pmac_dma_stop(rec);
-	st_le16(&chip->extra_dma.cmds->req_count, bytes);
-	st_le16(&chip->extra_dma.cmds->xfer_status, 0);
-	st_le32(&chip->extra_dma.cmds->cmd_dep, chip->extra_dma.addr);
-	st_le32(&chip->extra_dma.cmds->phy_addr, addr);
-	st_le16(&chip->extra_dma.cmds->command, OUTPUT_MORE + BR_ALWAYS);
+	chip->extra_dma.cmds->req_count = cpu_to_le16(bytes);
+	chip->extra_dma.cmds->xfer_status = cpu_to_le16(0);
+	chip->extra_dma.cmds->cmd_dep = cpu_to_le32(chip->extra_dma.addr);
+	chip->extra_dma.cmds->phy_addr = cpu_to_le32(addr);
+	chip->extra_dma.cmds->command = cpu_to_le16(OUTPUT_MORE + BR_ALWAYS);
 	out_le32(&chip->awacs->control,
 		 (in_le32(&chip->awacs->control) & ~0x1f00)
 		 | (speed << 8));
@@ -776,7 +776,7 @@ void snd_pmac_beep_dma_start(struct snd_pmac *chip, int bytes, unsigned long add
 void snd_pmac_beep_dma_stop(struct snd_pmac *chip)
 {
 	snd_pmac_dma_stop(&chip->playback);
-	st_le16(&chip->extra_dma.cmds->command, DBDMA_STOP);
+	chip->extra_dma.cmds->command = cpu_to_le16(DBDMA_STOP);
 	snd_pmac_pcm_set_format(chip); /* reset format */
 }
 

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index d399df473896..13146d701413 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -20,7 +20,7 @@
  */
 
 
-#include <asm/io.h>
+#include <linux/io.h>
 #include <asm/irq.h>
 #include <linux/init.h>
 #include <linux/delay.h>

commit ff6defa6a8fae12205d64f55db395b1fcf35af8e
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jan 3 22:55:54 2015 +0100

    ALSA: Deletion of checks before the function call "iounmap"
    
    The iounmap() function performs also input parameter validation.
    Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 5a13b22748b2..d399df473896 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -867,16 +867,11 @@ static int snd_pmac_free(struct snd_pmac *chip)
 	snd_pmac_dbdma_free(chip, &chip->capture.cmd);
 	snd_pmac_dbdma_free(chip, &chip->extra_dma);
 	snd_pmac_dbdma_free(chip, &emergency_dbdma);
-	if (chip->macio_base)
-		iounmap(chip->macio_base);
-	if (chip->latch_base)
-		iounmap(chip->latch_base);
-	if (chip->awacs)
-		iounmap(chip->awacs);
-	if (chip->playback.dma)
-		iounmap(chip->playback.dma);
-	if (chip->capture.dma)
-		iounmap(chip->capture.dma);
+	iounmap(chip->macio_base);
+	iounmap(chip->latch_base);
+	iounmap(chip->awacs);
+	iounmap(chip->playback.dma);
+	iounmap(chip->capture.dma);
 
 	if (chip->node) {
 		int i;

commit 1ea7a568c63a4735872fc091efbd22d2e4d9c972
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Mon Nov 17 13:35:54 2014 +0100

    ALSA: powermac: Deletion of an unnecessary check before the function call "pci_dev_put"
    
    The pci_dev_put() function tests whether its argument is NULL and then
    returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 8a431bcb056c..5a13b22748b2 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -887,8 +887,7 @@ static int snd_pmac_free(struct snd_pmac *chip)
 		}
 	}
 
-	if (chip->pdev)
-		pci_dev_put(chip->pdev);
+	pci_dev_put(chip->pdev);
 	of_node_put(chip->node);
 	kfree(chip);
 	return 0;

commit ccdb8ed3b3c739fe99a6f2f474f7ffad3203485d
Author: Grant Likely <grant.likely@linaro.org>
Date:   Wed Jun 4 16:42:26 2014 +0100

    of: Migrate of_find_node_by_name() users to for_each_node_by_name()
    
    There are a bunch of users open coding the for_each_node_by_name() by
    calling of_find_node_by_name() directly instead of using the macro. This
    is getting in the way of some cleanups, and the possibility of removing
    of_find_node_by_name() entirely. Clean it up so that all the users are
    consistent.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 7a43c0c38316..8a431bcb056c 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -992,9 +992,9 @@ static int snd_pmac_detect(struct snd_pmac *chip)
 		return -ENODEV;
 
 	if (!sound) {
-		sound = of_find_node_by_name(NULL, "sound");
-		while (sound && sound->parent != chip->node)
-			sound = of_find_node_by_name(sound, "sound");
+		for_each_node_by_name(sound, "sound")
+			if (sound->parent == chip->node)
+				break;
 	}
 	if (! sound) {
 		of_node_put(chip->node);

commit 5af5073004071cedd0343eee51d77955037ec6f3
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Sep 17 14:28:33 2013 -0500

    drivers: clean-up prom.h implicit includes
    
    Powerpc is a mess of implicit includes by prom.h. Add the necessary
    explicit includes to drivers in preparation of prom.h cleanup.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index c93fbbb201fe..7a43c0c38316 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -28,6 +28,8 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/dma-mapping.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 #include <sound/core.h>
 #include "pmac.h"
 #include <sound/pcm_params.h>

commit 15afafc2565bc785eb7a440b8b4a53f77910cf04
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:23 2012 -0500

    ALSA: ppc: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index ab96cde7417b..c93fbbb201fe 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -702,7 +702,7 @@ static struct snd_pcm_ops snd_pmac_capture_ops = {
 	.pointer =	snd_pmac_capture_pointer,
 };
 
-int __devinit snd_pmac_pcm_new(struct snd_pmac *chip)
+int snd_pmac_pcm_new(struct snd_pmac *chip)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -907,7 +907,7 @@ static int snd_pmac_dev_free(struct snd_device *device)
  * check the machine support byteswap (little-endian)
  */
 
-static void __devinit detect_byte_swap(struct snd_pmac *chip)
+static void detect_byte_swap(struct snd_pmac *chip)
 {
 	struct device_node *mio;
 
@@ -933,7 +933,7 @@ static void __devinit detect_byte_swap(struct snd_pmac *chip)
 /*
  * detect a sound chip
  */
-static int __devinit snd_pmac_detect(struct snd_pmac *chip)
+static int snd_pmac_detect(struct snd_pmac *chip)
 {
 	struct device_node *sound;
 	struct device_node *dn;
@@ -1146,7 +1146,7 @@ static int pmac_hp_detect_get(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static struct snd_kcontrol_new auto_mute_controls[] __devinitdata = {
+static struct snd_kcontrol_new auto_mute_controls[] = {
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	  .name = "Auto Mute Switch",
 	  .info = snd_pmac_boolean_mono_info,
@@ -1161,7 +1161,7 @@ static struct snd_kcontrol_new auto_mute_controls[] __devinitdata = {
 	},
 };
 
-int __devinit snd_pmac_add_automute(struct snd_pmac *chip)
+int snd_pmac_add_automute(struct snd_pmac *chip)
 {
 	int err;
 	chip->auto_mute = 1;
@@ -1178,7 +1178,7 @@ int __devinit snd_pmac_add_automute(struct snd_pmac *chip)
 /*
  * create and detect a pmac chip record
  */
-int __devinit snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
+int snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 {
 	struct snd_pmac *chip;
 	struct device_node *np;

commit 28f65c11f2ffb3957259dece647a24f8ad2e241b
Author: Joe Perches <joe@perches.com>
Date:   Thu Jun 9 09:13:32 2011 -0700

    treewide: Convert uses of struct resource to resource_size(ptr)
    
    Several fixes as well where the +1 was missing.
    
    Done via coccinelle scripts like:
    
    @@
    struct resource *ptr;
    @@
    
    - ptr->end - ptr->start + 1
    + resource_size(ptr)
    
    and some grep and typing.
    
    Mostly uncompiled, no cross-compilers.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 3ecbd67f88c9..ab96cde7417b 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -881,8 +881,7 @@ static int snd_pmac_free(struct snd_pmac *chip)
 		for (i = 0; i < 3; i++) {
 			if (chip->requested & (1 << i))
 				release_mem_region(chip->rsrc[i].start,
-						   chip->rsrc[i].end -
-						   chip->rsrc[i].start + 1);
+						   resource_size(&chip->rsrc[i]));
 		}
 	}
 
@@ -1228,8 +1227,7 @@ int __devinit snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 				goto __error;
 			}
 			if (request_mem_region(chip->rsrc[i].start,
-					       chip->rsrc[i].end -
-					       chip->rsrc[i].start + 1,
+					       resource_size(&chip->rsrc[i]),
 					       rnames[i]) == NULL) {
 				printk(KERN_ERR "snd: can't request rsrc "
 				       " %d (%s: %pR)\n",
@@ -1254,8 +1252,7 @@ int __devinit snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 				goto __error;
 			}
 			if (request_mem_region(chip->rsrc[i].start,
-					       chip->rsrc[i].end -
-					       chip->rsrc[i].start + 1,
+					       resource_size(&chip->rsrc[i]),
 					       rnames[i]) == NULL) {
 				printk(KERN_ERR "snd: can't request rsrc "
 				       " %d (%s: %pR)\n",

commit 8460ae70bb6bf1729bd247465c02b7a8c986c61d
Author: Risto Suominen <Risto.Suominen@gmail.com>
Date:   Mon Feb 28 10:38:45 2011 +0200

    ALSA: powermac - Allow input from microphone on Tumbler
    
    Allow input from microphone on remaining PowerBooks and iBooks with Tumbler.
    Tested only with PowerBook G4 Gigabit Ethernet (PowerBook3,3).
    
    [Fixed to use of_machine_is_compatible by tiwai]
    
    Signed-off-by: Risto Suominen <Risto.Suominen@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index b47cfd45b3b9..3ecbd67f88c9 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1034,7 +1034,11 @@ static int __devinit snd_pmac_detect(struct snd_pmac *chip)
 	if (of_device_is_compatible(sound, "tumbler")) {
 		chip->model = PMAC_TUMBLER;
 		chip->can_capture = of_machine_is_compatible("PowerMac4,2")
-				|| of_machine_is_compatible("PowerBook4,1");
+				|| of_machine_is_compatible("PowerBook3,2")
+				|| of_machine_is_compatible("PowerBook3,3")
+				|| of_machine_is_compatible("PowerBook4,1")
+				|| of_machine_is_compatible("PowerBook4,2")
+				|| of_machine_is_compatible("PowerBook4,3");
 		chip->can_duplex = 0;
 		// chip->can_byte_swap = 0; /* FIXME: check this */
 		chip->num_freqs = ARRAY_SIZE(tumbler_freqs);

commit 2fb50f135adba59edf2359effcce83eb17025793
Author: Joe Perches <joe@perches.com>
Date:   Fri Nov 12 13:38:04 2010 -0800

    ALSA: sound/ppc: Use printf extension %pR for struct resource
    
    Using %pR standardizes the struct resource output.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 85081172403f..b47cfd45b3b9 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1228,10 +1228,8 @@ int __devinit snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 					       chip->rsrc[i].start + 1,
 					       rnames[i]) == NULL) {
 				printk(KERN_ERR "snd: can't request rsrc "
-				       " %d (%s: 0x%016llx:%016llx)\n",
-				       i, rnames[i],
-				       (unsigned long long)chip->rsrc[i].start,
-				       (unsigned long long)chip->rsrc[i].end);
+				       " %d (%s: %pR)\n",
+				       i, rnames[i], &chip->rsrc[i]);
 				err = -ENODEV;
 				goto __error;
 			}
@@ -1256,10 +1254,8 @@ int __devinit snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 					       chip->rsrc[i].start + 1,
 					       rnames[i]) == NULL) {
 				printk(KERN_ERR "snd: can't request rsrc "
-				       " %d (%s: 0x%016llx:%016llx)\n",
-				       i, rnames[i],
-				       (unsigned long long)chip->rsrc[i].start,
-				       (unsigned long long)chip->rsrc[i].end);
+				       " %d (%s: %pR)\n",
+				       i, rnames[i], &chip->rsrc[i]);
 				err = -ENODEV;
 				goto __error;
 			}

commit 71a157e8edca55198e808f8561dd49017a54ee34
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Feb 1 21:34:14 2010 -0700

    of: add 'of_' prefix to machine_is_compatible()
    
    machine is compatible is an OF-specific call.  It should have
    the of_ prefix to protect the global namespace.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Michal Simek <monstr@monstr.eu>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 7bc492ee77ec..85081172403f 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -922,11 +922,11 @@ static void __devinit detect_byte_swap(struct snd_pmac *chip)
 	}
 
 	/* it seems the Pismo & iBook can't byte-swap in hardware. */
-	if (machine_is_compatible("PowerBook3,1") ||
-	    machine_is_compatible("PowerBook2,1"))
+	if (of_machine_is_compatible("PowerBook3,1") ||
+	    of_machine_is_compatible("PowerBook2,1"))
 		chip->can_byte_swap = 0 ;
 
-	if (machine_is_compatible("PowerBook2,1"))
+	if (of_machine_is_compatible("PowerBook2,1"))
 		chip->can_duplex = 0;
 }
 
@@ -959,11 +959,11 @@ static int __devinit snd_pmac_detect(struct snd_pmac *chip)
 	chip->control_mask = MASK_IEPC | MASK_IEE | 0x11; /* default */
 
 	/* check machine type */
-	if (machine_is_compatible("AAPL,3400/2400")
-	    || machine_is_compatible("AAPL,3500"))
+	if (of_machine_is_compatible("AAPL,3400/2400")
+	    || of_machine_is_compatible("AAPL,3500"))
 		chip->is_pbook_3400 = 1;
-	else if (machine_is_compatible("PowerBook1,1")
-		 || machine_is_compatible("AAPL,PowerBook1998"))
+	else if (of_machine_is_compatible("PowerBook1,1")
+		 || of_machine_is_compatible("AAPL,PowerBook1998"))
 		chip->is_pbook_G3 = 1;
 	chip->node = of_find_node_by_name(NULL, "awacs");
 	sound = of_node_get(chip->node);
@@ -1033,8 +1033,8 @@ static int __devinit snd_pmac_detect(struct snd_pmac *chip)
 	}
 	if (of_device_is_compatible(sound, "tumbler")) {
 		chip->model = PMAC_TUMBLER;
-		chip->can_capture = machine_is_compatible("PowerMac4,2")
-				|| machine_is_compatible("PowerBook4,1");
+		chip->can_capture = of_machine_is_compatible("PowerMac4,2")
+				|| of_machine_is_compatible("PowerBook4,1");
 		chip->can_duplex = 0;
 		// chip->can_byte_swap = 0; /* FIXME: check this */
 		chip->num_freqs = ARRAY_SIZE(tumbler_freqs);

commit 3e1e0a5dd539f83438078759c8642c5dd7c24cb6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 3 08:13:15 2009 +0200

    ALSA: powermac - Replace the rest of __init*
    
    All __initdata should be __devinitdata as platform device is hotpluggable.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index dfea116278e6..7bc492ee77ec 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -908,7 +908,7 @@ static int snd_pmac_dev_free(struct snd_device *device)
  * check the machine support byteswap (little-endian)
  */
 
-static void __init detect_byte_swap(struct snd_pmac *chip)
+static void __devinit detect_byte_swap(struct snd_pmac *chip)
 {
 	struct device_node *mio;
 
@@ -1143,7 +1143,7 @@ static int pmac_hp_detect_get(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static struct snd_kcontrol_new auto_mute_controls[] __initdata = {
+static struct snd_kcontrol_new auto_mute_controls[] __devinitdata = {
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	  .name = "Auto Mute Switch",
 	  .info = snd_pmac_boolean_mono_info,

commit 5c9b6e9e618868ac66d92c81b70ad57d82033d4e
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Wed Jun 3 15:35:19 2009 +1000

    ALSA: sound/ppc: update annotations of serveral functions
    
    [I am not sure if this is the correct approach as I don't know if any of
    this actual hardware or drivers are really hot pluggable.]
    
    Gets rid of these build warnings:
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x5c): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_new()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_new().
    If .snd_pmac_new is only used by .snd_pmac_probe then
    annotate .snd_pmac_new with a matching annotation.
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x10c): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_burgundy_init()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_burgundy_init().
    If .snd_pmac_burgundy_init is only used by .snd_pmac_probe then
    annotate .snd_pmac_burgundy_init with a matching annotation.
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x164): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_daca_init()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_daca_init().
    If .snd_pmac_daca_init is only used by .snd_pmac_probe then
    annotate .snd_pmac_daca_init with a matching annotation.
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x1dc): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_tumbler_init()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_tumbler_init().
    If .snd_pmac_tumbler_init is only used by .snd_pmac_probe then
    annotate .snd_pmac_tumbler_init with a matching annotation.
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x1ec): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_tumbler_post_init()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_tumbler_post_init().
    If .snd_pmac_tumbler_post_init is only used by .snd_pmac_probe then
    annotate .snd_pmac_tumbler_post_init with a matching annotation.
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x28c): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_awacs_init()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_awacs_init().
    If .snd_pmac_awacs_init is only used by .snd_pmac_probe then
    annotate .snd_pmac_awacs_init with a matching annotation.
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x2bc): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_pcm_new()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_pcm_new().
    If .snd_pmac_pcm_new is only used by .snd_pmac_probe then
    annotate .snd_pmac_pcm_new with a matching annotation.
    
    WARNING: sound/ppc/snd-powermac.o(.devinit.text+0x2f8): Section mismatch in reference from the function .snd_pmac_probe() to the function .init.text:.snd_pmac_attach_beep()
    The function __devinit .snd_pmac_probe() references
    a function __init .snd_pmac_attach_beep().
    If .snd_pmac_attach_beep is only used by .snd_pmac_probe then
    annotate .snd_pmac_attach_beep with a matching annotation.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 9b4e9c316695..dfea116278e6 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -702,7 +702,7 @@ static struct snd_pcm_ops snd_pmac_capture_ops = {
 	.pointer =	snd_pmac_capture_pointer,
 };
 
-int __init snd_pmac_pcm_new(struct snd_pmac *chip)
+int __devinit snd_pmac_pcm_new(struct snd_pmac *chip)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -934,7 +934,7 @@ static void __init detect_byte_swap(struct snd_pmac *chip)
 /*
  * detect a sound chip
  */
-static int __init snd_pmac_detect(struct snd_pmac *chip)
+static int __devinit snd_pmac_detect(struct snd_pmac *chip)
 {
 	struct device_node *sound;
 	struct device_node *dn;
@@ -1158,7 +1158,7 @@ static struct snd_kcontrol_new auto_mute_controls[] __initdata = {
 	},
 };
 
-int __init snd_pmac_add_automute(struct snd_pmac *chip)
+int __devinit snd_pmac_add_automute(struct snd_pmac *chip)
 {
 	int err;
 	chip->auto_mute = 1;
@@ -1175,7 +1175,7 @@ int __init snd_pmac_add_automute(struct snd_pmac *chip)
 /*
  * create and detect a pmac chip record
  */
-int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
+int __devinit snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 {
 	struct snd_pmac *chip;
 	struct device_node *np;

commit 6da6711385165eff76411b77974eec13c5ef6486
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 16:02:46 2009 +0100

    ALSA: powermac - Add missing KERN_* prefix to printk
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index bd8f92b1c224..9b4e9c316695 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -299,7 +299,7 @@ static int snd_pmac_pcm_trigger(struct snd_pmac *chip, struct pmac_stream *rec,
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 		spin_lock(&chip->reg_lock);
 		rec->running = 0;
-		/*printk("stopped!!\n");*/
+		/*printk(KERN_DEBUG "stopped!!\n");*/
 		snd_pmac_dma_stop(rec);
 		for (i = 0, cp = rec->cmd.cmds; i < rec->nperiods; i++, cp++)
 			out_le16(&cp->command, DBDMA_STOP);
@@ -334,7 +334,7 @@ static snd_pcm_uframes_t snd_pmac_pcm_pointer(struct snd_pmac *chip,
 	}
 #endif
 	count += rec->cur_period * rec->period_size;
-	/*printk("pointer=%d\n", count);*/
+	/*printk(KERN_DEBUG "pointer=%d\n", count);*/
 	return bytes_to_frames(subs->runtime, count);
 }
 
@@ -486,7 +486,7 @@ static void snd_pmac_pcm_update(struct snd_pmac *chip, struct pmac_stream *rec)
 			if (! (stat & ACTIVE))
 				break;
 
-			/*printk("update frag %d\n", rec->cur_period);*/
+			/*printk(KERN_DEBUG "update frag %d\n", rec->cur_period);*/
 			st_le16(&cp->xfer_status, 0);
 			st_le16(&cp->req_count, rec->period_size);
 			/*st_le16(&cp->res_count, 0);*/
@@ -806,7 +806,7 @@ snd_pmac_ctrl_intr(int irq, void *devid)
 	struct snd_pmac *chip = devid;
 	int ctrl = in_le32(&chip->awacs->control);
 
-	/*printk("pmac: control interrupt.. 0x%x\n", ctrl);*/
+	/*printk(KERN_DEBUG "pmac: control interrupt.. 0x%x\n", ctrl);*/
 	if (ctrl & MASK_PORTCHG) {
 		/* do something when headphone is plugged/unplugged? */
 		if (chip->update_automute)

commit ed336d3404a8fdeda1e3f1c189b5f83186675448
Author: Risto Suominen <Risto.Suominen@gmail.com>
Date:   Tue Jan 20 22:01:16 2009 +0200

    ALSA: powermac - Allow input from mic in iBook G3 Dual-USB
    
    Allow input from microphone on iBook G3 Dual-USB (Tumbler).
    
    Signed-off-by: Risto Suominen <Risto.Suominen@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index af76ee862d27..bd8f92b1c224 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1033,7 +1033,8 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 	}
 	if (of_device_is_compatible(sound, "tumbler")) {
 		chip->model = PMAC_TUMBLER;
-		chip->can_capture = machine_is_compatible("PowerMac4,2");
+		chip->can_capture = machine_is_compatible("PowerMac4,2")
+				|| machine_is_compatible("PowerBook4,1");
 		chip->can_duplex = 0;
 		// chip->can_byte_swap = 0; /* FIXME: check this */
 		chip->num_freqs = ARRAY_SIZE(tumbler_freqs);

commit bc4a68fed4b4c01005ef3c71ede6a8cbe91b7dc9
Author: Risto Suominen <Risto.Suominen@gmail.com>
Date:   Tue Nov 18 07:35:14 2008 +0100

    ALSA: snd-powermac: enable mic on iMac G4
    
    Allow input from microphone on iMac G4 Flat-panel (Tumbler).
    
    Signed-off-by: Risto Suominen <Risto.Suominen@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index a38c0c790d2b..af76ee862d27 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1033,7 +1033,7 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 	}
 	if (of_device_is_compatible(sound, "tumbler")) {
 		chip->model = PMAC_TUMBLER;
-		chip->can_capture = 0;  /* no capture */
+		chip->can_capture = machine_is_compatible("PowerMac4,2");
 		chip->can_duplex = 0;
 		// chip->can_byte_swap = 0; /* FIXME: check this */
 		chip->num_freqs = ARRAY_SIZE(tumbler_freqs);

commit 946cda7d64b81053beac5d31148996f3e379e89e
Author: Risto Suominen <Risto.Suominen@gmail.com>
Date:   Wed Apr 16 13:16:05 2008 +0200

    [ALSA] snd-powermac: style pmac.c
    
    Coding style corrections for pmac.c.
    
    Signed-off-by: Risto Suominen <Risto.Suominen@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 6f68ac9982e4..a38c0c790d2b 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -214,7 +214,7 @@ static int snd_pmac_pcm_prepare(struct snd_pmac *chip, struct pmac_stream *rec,
 	int rate_index;
 	long offset;
 	struct pmac_stream *astr;
-	
+
 	rec->dma_size = snd_pcm_lib_buffer_bytes(subs);
 	rec->period_size = snd_pcm_lib_period_bytes(subs);
 	rec->nperiods = rec->dma_size / rec->period_size;
@@ -643,7 +643,7 @@ static int snd_pmac_pcm_close(struct snd_pmac *chip, struct pmac_stream *rec,
 	/* reset constraints */
 	astr->cur_freqs = chip->freqs_ok;
 	astr->cur_formats = chip->formats_ok;
-	
+
 	return 0;
 }
 

commit 9a4f20fcbd9cd89d8e4cfcaece81802c19d467ae
Author: Risto Suominen <Risto.Suominen@gmail.com>
Date:   Wed Apr 16 13:15:38 2008 +0200

    [ALSA] snd-powermac: enable headphone detection
    
    Enable port change interrupt while initialising AWACS, Screamer, and
    Burgundy chipsets.
    
    Signed-off-by: Risto Suominen <Risto.Suominen@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 613a565e04de..6f68ac9982e4 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1300,9 +1300,9 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 
 	snd_pmac_sound_feature(chip, 1);
 
-	/* reset */
-	if (chip->model == PMAC_AWACS)
-		out_le32(&chip->awacs->control, 0x11);
+	/* reset & enable interrupts */
+	if (chip->model <= PMAC_BURGUNDY)
+		out_le32(&chip->awacs->control, chip->control_mask);
 
 	/* Powerbooks have odd ways of enabling inputs such as
 	   an expansion-bay CD or sound from an internal modem

commit e70515dd518bbd5b9e2e5c90a56347df0e871389
Author: T. H. Huth <th.huth@googlemail.com>
Date:   Wed Jan 16 15:57:08 2008 +0100

    [ALSA] snd-powermac: handle dead DMA transfers
    
    This patch provides the snd-powermac sound driver with the ability to handle
    dead DMA transfers. If a dead DMA transfer is detected, the driver now sets
    up a new DMA transfer to continue with the sound output at the point where the
    old transfer died.
    This dead DMA transfer handling has become necessary with recent kernels on
    certain G4 PowerMacs. Please refer to the following URLs for more information:
     https://bugtrack.alsa-project.org/alsa-bug/view.php?id=3126
     https://bugs.launchpad.net/ubuntu/+source/linux-source-2.6.20/+bug/87652
     http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=436723
    The patch is based on the dead DMA transfer handling code from the old dmasound
    driver which can be found in the file sound/oss/dmasound/dmasound_awacs.c in
    the Linux source code.
    
    Signed-off-by: T. H. Huth <th.huth@googlemail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index aada1d7dc3c4..613a565e04de 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -44,6 +44,18 @@ static int tumbler_freqs[1] = {
 	44100
 };
 
+
+/*
+ * we will allocate a single 'emergency' dbdma cmd block to use if the
+ * tx status comes up "DEAD".  This happens on some PowerComputing Pmac
+ * clones, either owing to a bug in dbdma or some interaction between
+ * IDE and sound.  However, this measure would deal with DEAD status if
+ * it appeared elsewhere.
+ */
+static struct pmac_dbdma emergency_dbdma;
+static int emergency_in_use;
+
+
 /*
  * allocate DBDMA command arrays
  */
@@ -374,6 +386,75 @@ static snd_pcm_uframes_t snd_pmac_capture_pointer(struct snd_pcm_substream *subs
 }
 
 
+/*
+ * Handle DEAD DMA transfers:
+ * if the TX status comes up "DEAD" - reported on some Power Computing machines
+ * we need to re-start the dbdma - but from a different physical start address
+ * and with a different transfer length.  It would get very messy to do this
+ * with the normal dbdma_cmd blocks - we would have to re-write the buffer start
+ * addresses each time.  So, we will keep a single dbdma_cmd block which can be
+ * fiddled with.
+ * When DEAD status is first reported the content of the faulted dbdma block is
+ * copied into the emergency buffer and we note that the buffer is in use.
+ * we then bump the start physical address by the amount that was successfully
+ * output before it died.
+ * On any subsequent DEAD result we just do the bump-ups (we know that we are
+ * already using the emergency dbdma_cmd).
+ * CHECK: this just tries to "do it".  It is possible that we should abandon
+ * xfers when the number of residual bytes gets below a certain value - I can
+ * see that this might cause a loop-forever if a too small transfer causes
+ * DEAD status.  However this is a TODO for now - we'll see what gets reported.
+ * When we get a successful transfer result with the emergency buffer we just
+ * pretend that it completed using the original dmdma_cmd and carry on.  The
+ * 'next_cmd' field will already point back to the original loop of blocks.
+ */
+static inline void snd_pmac_pcm_dead_xfer(struct pmac_stream *rec,
+					  volatile struct dbdma_cmd __iomem *cp)
+{
+	unsigned short req, res ;
+	unsigned int phy ;
+
+	/* printk(KERN_WARNING "snd-powermac: DMA died - patching it up!\n"); */
+
+	/* to clear DEAD status we must first clear RUN
+	   set it to quiescent to be on the safe side */
+	(void)in_le32(&rec->dma->status);
+	out_le32(&rec->dma->control, (RUN|PAUSE|FLUSH|WAKE) << 16);
+
+	if (!emergency_in_use) { /* new problem */
+		memcpy((void *)emergency_dbdma.cmds, (void *)cp,
+		       sizeof(struct dbdma_cmd));
+		emergency_in_use = 1;
+		st_le16(&cp->xfer_status, 0);
+		st_le16(&cp->req_count, rec->period_size);
+		cp = emergency_dbdma.cmds;
+	}
+
+	/* now bump the values to reflect the amount
+	   we haven't yet shifted */
+	req = ld_le16(&cp->req_count);
+	res = ld_le16(&cp->res_count);
+	phy = ld_le32(&cp->phy_addr);
+	phy += (req - res);
+	st_le16(&cp->req_count, res);
+	st_le16(&cp->res_count, 0);
+	st_le16(&cp->xfer_status, 0);
+	st_le32(&cp->phy_addr, phy);
+
+	st_le32(&cp->cmd_dep, rec->cmd.addr
+		+ sizeof(struct dbdma_cmd)*((rec->cur_period+1)%rec->nperiods));
+
+	st_le16(&cp->command, OUTPUT_MORE | BR_ALWAYS | INTR_ALWAYS);
+
+	/* point at our patched up command block */
+	out_le32(&rec->dma->cmdptr, emergency_dbdma.addr);
+
+	/* we must re-start the controller */
+	(void)in_le32(&rec->dma->status);
+	/* should complete clearing the DEAD status */
+	out_le32(&rec->dma->control, ((RUN|WAKE) << 16) + (RUN|WAKE));
+}
+
 /*
  * update playback/capture pointer from interrupts
  */
@@ -385,11 +466,26 @@ static void snd_pmac_pcm_update(struct snd_pmac *chip, struct pmac_stream *rec)
 
 	spin_lock(&chip->reg_lock);
 	if (rec->running) {
-		cp = &rec->cmd.cmds[rec->cur_period];
 		for (c = 0; c < rec->nperiods; c++) { /* at most all fragments */
+
+			if (emergency_in_use)   /* already using DEAD xfer? */
+				cp = emergency_dbdma.cmds;
+			else
+				cp = &rec->cmd.cmds[rec->cur_period];
+
 			stat = ld_le16(&cp->xfer_status);
+
+			if (stat & DEAD) {
+				snd_pmac_pcm_dead_xfer(rec, cp);
+				break; /* this block is still going */
+			}
+
+			if (emergency_in_use)
+				emergency_in_use = 0 ; /* done that */
+
 			if (! (stat & ACTIVE))
 				break;
+
 			/*printk("update frag %d\n", rec->cur_period);*/
 			st_le16(&cp->xfer_status, 0);
 			st_le16(&cp->req_count, rec->period_size);
@@ -397,9 +493,8 @@ static void snd_pmac_pcm_update(struct snd_pmac *chip, struct pmac_stream *rec)
 			rec->cur_period++;
 			if (rec->cur_period >= rec->nperiods) {
 				rec->cur_period = 0;
-				cp = rec->cmd.cmds;
-			} else
-				cp++;
+			}
+
 			spin_unlock(&chip->reg_lock);
 			snd_pcm_period_elapsed(rec->substream);
 			spin_lock(&chip->reg_lock);
@@ -769,6 +864,7 @@ static int snd_pmac_free(struct snd_pmac *chip)
 	snd_pmac_dbdma_free(chip, &chip->playback.cmd);
 	snd_pmac_dbdma_free(chip, &chip->capture.cmd);
 	snd_pmac_dbdma_free(chip, &chip->extra_dma);
+	snd_pmac_dbdma_free(chip, &emergency_dbdma);
 	if (chip->macio_base)
 		iounmap(chip->macio_base);
 	if (chip->latch_base)
@@ -1107,7 +1203,8 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 
 	if (snd_pmac_dbdma_alloc(chip, &chip->playback.cmd, PMAC_MAX_FRAGS + 1) < 0 ||
 	    snd_pmac_dbdma_alloc(chip, &chip->capture.cmd, PMAC_MAX_FRAGS + 1) < 0 ||
-	    snd_pmac_dbdma_alloc(chip, &chip->extra_dma, 2) < 0) {
+	    snd_pmac_dbdma_alloc(chip, &chip->extra_dma, 2) < 0 ||
+	    snd_pmac_dbdma_alloc(chip, &emergency_dbdma, 2) < 0) {
 		err = -ENOMEM;
 		goto __error;
 	}

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 8c47bebc77c8..aada1d7dc3c4 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -20,7 +20,6 @@
  */
 
 
-#include <sound/driver.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <linux/init.h>

commit d4079ac49a08e36d6839a9ceb26aec8c24c9ed82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 15 16:14:12 2007 +0100

    [ALSA] powermac - Check value range in ctl callbacks
    
    Check the value ranges in ctl put callbacks properly in snd-powermac
    driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 4f9b19c90a43..8c47bebc77c8 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1028,7 +1028,7 @@ static int pmac_auto_mute_put(struct snd_kcontrol *kcontrol,
 {
 	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	if (ucontrol->value.integer.value[0] != chip->auto_mute) {
-		chip->auto_mute = ucontrol->value.integer.value[0];
+		chip->auto_mute = !!ucontrol->value.integer.value[0];
 		if (chip->update_automute)
 			chip->update_automute(chip, 1);
 		return 1;

commit 918f3a0e8cf67b5db966516f255eaf24d814fac0
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 13 17:40:54 2007 +0200

    [ALSA] pcm: add snd_pcm_rate_to_rate_bit() helper
    
    Add a snd_pcm_rate_to_rate_bit() function to factor out common code used
    by several drivers.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 04b95ae5c3aa..4f9b19c90a43 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -490,35 +490,14 @@ static int snd_pmac_pcm_open(struct snd_pmac *chip, struct pmac_stream *rec,
 			     struct snd_pcm_substream *subs)
 {
 	struct snd_pcm_runtime *runtime = subs->runtime;
-	int i, j, fflags;
-	static int typical_freqs[] = {
-		44100,
-		22050,
-		11025,
-		0,
-	};
-	static int typical_freq_flags[] = {
-		SNDRV_PCM_RATE_44100,
-		SNDRV_PCM_RATE_22050,
-		SNDRV_PCM_RATE_11025,
-		0,
-	};
+	int i;
 
 	/* look up frequency table and fill bit mask */
 	runtime->hw.rates = 0;
-	fflags = chip->freqs_ok;
-	for (i = 0; typical_freqs[i]; i++) {
-		for (j = 0; j < chip->num_freqs; j++) {
-			if ((chip->freqs_ok & (1 << j)) &&
-			    chip->freq_table[j] == typical_freqs[i]) {
-				runtime->hw.rates |= typical_freq_flags[i];
-				fflags &= ~(1 << j);
-				break;
-			}
-		}
-	}
-	if (fflags) /* rest */
-		runtime->hw.rates |= SNDRV_PCM_RATE_KNOT;
+	for (i = 0; i < chip->num_freqs; i++)
+		if (chip->freqs_ok & (1 << i))
+			runtime->hw.rates |=
+				snd_pcm_rate_to_rate_bit(chip->freq_table[i]);
 
 	/* check for minimum and maximum rates */
 	for (i = 0; i < chip->num_freqs; i++) {

commit b83f346bc4d6ab358fd0da85b7eab08bf0234c0b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 13 17:37:55 2007 +0200

    [ALSA] remove incorrect usage of SNDRV_PCM_INFO_SYNC_START and snd_pcm_set_sync()
    
    Set the SNDRV_PCM_INFO_SYNC_START flag and the substream's sync ID
    (only) if the substream actually can be linked to another one.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index adbc86855b09..04b95ae5c3aa 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -551,9 +551,6 @@ static int snd_pmac_pcm_open(struct snd_pmac *chip, struct pmac_stream *rec,
 
 	runtime->hw.periods_max = rec->cmd.size - 1;
 
-	if (chip->can_duplex)
-		snd_pcm_set_sync(subs);
-
 	/* constraints to fix choppy sound */
 	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
 	return 0;

commit a5ce88909d3007caa7b65996a8f6784350beb2a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 23 15:42:26 2007 +0200

    [ALSA] Clean up with common snd_ctl_boolean_*_info callbacks
    
    Clean up codes using the new common snd_ctl_boolean_*_info() callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 7a22f0f3784a..adbc86855b09 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1035,29 +1035,6 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 	return 0;
 }
 
-/*
- * exported - boolean info callbacks for ease of programming
- */
-int snd_pmac_boolean_stereo_info(struct snd_kcontrol *kcontrol,
-				 struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 2;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
-
-int snd_pmac_boolean_mono_info(struct snd_kcontrol *kcontrol,
-			       struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
-
 #ifdef PMAC_SUPPORT_AUTOMUTE
 /*
  * auto-mute

commit 41e904dee22066ae7ac3a7f695b2c8bd43ce4e04
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jun 19 14:37:39 2007 +1000

    [POWERPC] Fix snd-powermac refcounting bugs
    
    The old snd-powermac driver has some serious refcounting issues when
    initialisation fails, which is the case on all new machines with
    a layout-id since those are handled by the new snd-aoa driver.
    
    Some of those bugs seem to have been under the radar for some time
    (like double pci_dev_put), but one was actually added in 2.6.22 with
    Stephen attempt at teaching refcounting to the driver which didn't
    do it at all.
    
    This patch fixes both, thus removing all sort of kref errors that
    would happen if that driver gets loaded on a G5 machine or a recent
    PowerBook due to OF nodes left around with a 0 refcount.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 5a2bef44a2f5..7a22f0f3784a 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -775,7 +775,8 @@ static int snd_pmac_free(struct snd_pmac *chip)
 		out_le32(&chip->awacs->control, in_le32(&chip->awacs->control) & 0xfff);
 	}
 
-	snd_pmac_sound_feature(chip, 0);
+	if (chip->node)
+		snd_pmac_sound_feature(chip, 0);
 
 	/* clean up mixer if any */
 	if (chip->mixer_free)
@@ -925,6 +926,7 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 	}
 	if (! sound) {
 		of_node_put(chip->node);
+		chip->node = NULL;
 		return -ENODEV;
 	}
 	prop = of_get_property(sound, "sub-frame", NULL);
@@ -937,7 +939,9 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 		printk(KERN_INFO "snd-powermac no longer handles any "
 				 "machines with a layout-id property "
 				 "in the device-tree, use snd-aoa.\n");
+		of_node_put(sound);
 		of_node_put(chip->node);
+		chip->node = NULL;
 		return -ENODEV;
 	}
 	/* This should be verified on older screamers */
@@ -1297,8 +1301,6 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 	return 0;
 
  __error:
-	if (chip->pdev)
-		pci_dev_put(chip->pdev);
 	snd_pmac_free(chip);
 	return err;
 }

commit 55b61fec22caa3e7872caea6c4100fc75cb8f49b
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu May 3 17:26:52 2007 +1000

    [POWERPC] Rename device_is_compatible to of_device_is_compatible
    
    for consistency with other Open Firmware interfaces (and Sparc).
    
    This is just a straight replacement.
    
    This leaves the compatibility define in place.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 2bae9c1a2b54..5a2bef44a2f5 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -843,7 +843,7 @@ static void __init detect_byte_swap(struct snd_pmac *chip)
 	/* if seems that Keylargo can't byte-swap  */
 	for (mio = chip->node->parent; mio; mio = mio->parent) {
 		if (strcmp(mio->name, "mac-io") == 0) {
-			if (device_is_compatible(mio, "Keylargo"))
+			if (of_device_is_compatible(mio, "Keylargo"))
 				chip->can_byte_swap = 0;
 			break;
 		}
@@ -910,7 +910,7 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 		chip->node = of_find_node_by_name(NULL, "i2s-a");
 		if (chip->node && chip->node->parent &&
 		    chip->node->parent->parent) {
-			if (device_is_compatible(chip->node->parent->parent,
+			if (of_device_is_compatible(chip->node->parent->parent,
 						 "K2-Keylargo"))
 				chip->is_k2 = 1;
 		}
@@ -941,22 +941,22 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 		return -ENODEV;
 	}
 	/* This should be verified on older screamers */
-	if (device_is_compatible(sound, "screamer")) {
+	if (of_device_is_compatible(sound, "screamer")) {
 		chip->model = PMAC_SCREAMER;
 		// chip->can_byte_swap = 0; /* FIXME: check this */
 	}
-	if (device_is_compatible(sound, "burgundy")) {
+	if (of_device_is_compatible(sound, "burgundy")) {
 		chip->model = PMAC_BURGUNDY;
 		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
 	}
-	if (device_is_compatible(sound, "daca")) {
+	if (of_device_is_compatible(sound, "daca")) {
 		chip->model = PMAC_DACA;
 		chip->can_capture = 0;  /* no capture */
 		chip->can_duplex = 0;
 		// chip->can_byte_swap = 0; /* FIXME: check this */
 		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
 	}
-	if (device_is_compatible(sound, "tumbler")) {
+	if (of_device_is_compatible(sound, "tumbler")) {
 		chip->model = PMAC_TUMBLER;
 		chip->can_capture = 0;  /* no capture */
 		chip->can_duplex = 0;
@@ -965,7 +965,7 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 		chip->freq_table = tumbler_freqs;
 		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
 	}
-	if (device_is_compatible(sound, "snapper")) {
+	if (of_device_is_compatible(sound, "snapper")) {
 		chip->model = PMAC_SNAPPER;
 		// chip->can_byte_swap = 0; /* FIXME: check this */
 		chip->num_freqs = ARRAY_SIZE(tumbler_freqs);

commit 30686ba6d56858657829d3eb524ed73e5dc98d2b
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Apr 24 13:53:04 2007 +1000

    [POWERPC] Remove old interface find_devices
    
    Replace uses with of_find_node_by_name and for_each_node_by_name.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 5e829683d1ad..2bae9c1a2b54 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -816,6 +816,7 @@ static int snd_pmac_free(struct snd_pmac *chip)
 
 	if (chip->pdev)
 		pci_dev_put(chip->pdev);
+	of_node_put(chip->node);
 	kfree(chip);
 	return 0;
 }
@@ -863,7 +864,8 @@ static void __init detect_byte_swap(struct snd_pmac *chip)
  */
 static int __init snd_pmac_detect(struct snd_pmac *chip)
 {
-	struct device_node *sound = NULL;
+	struct device_node *sound;
+	struct device_node *dn;
 	const unsigned int *prop;
 	unsigned int l;
 	struct macio_chip* macio;
@@ -891,22 +893,21 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 	else if (machine_is_compatible("PowerBook1,1")
 		 || machine_is_compatible("AAPL,PowerBook1998"))
 		chip->is_pbook_G3 = 1;
-	chip->node = find_devices("awacs");
-	if (chip->node)
-		sound = chip->node;
+	chip->node = of_find_node_by_name(NULL, "awacs");
+	sound = of_node_get(chip->node);
 
 	/*
 	 * powermac G3 models have a node called "davbus"
 	 * with a child called "sound".
 	 */
 	if (!chip->node)
-		chip->node = find_devices("davbus");
+		chip->node = of_find_node_by_name(NULL, "davbus");
 	/*
 	 * if we didn't find a davbus device, try 'i2s-a' since
 	 * this seems to be what iBooks have
 	 */
 	if (! chip->node) {
-		chip->node = find_devices("i2s-a");
+		chip->node = of_find_node_by_name(NULL, "i2s-a");
 		if (chip->node && chip->node->parent &&
 		    chip->node->parent->parent) {
 			if (device_is_compatible(chip->node->parent->parent,
@@ -918,12 +919,14 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 		return -ENODEV;
 
 	if (!sound) {
-		sound = find_devices("sound");
+		sound = of_find_node_by_name(NULL, "sound");
 		while (sound && sound->parent != chip->node)
-			sound = sound->next;
+			sound = of_find_node_by_name(sound, "sound");
 	}
-	if (! sound)
+	if (! sound) {
+		of_node_put(chip->node);
 		return -ENODEV;
+	}
 	prop = of_get_property(sound, "sub-frame", NULL);
 	if (prop && *prop < 16)
 		chip->subframe = *prop;
@@ -934,6 +937,7 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 		printk(KERN_INFO "snd-powermac no longer handles any "
 				 "machines with a layout-id property "
 				 "in the device-tree, use snd-aoa.\n");
+		of_node_put(chip->node);
 		return -ENODEV;
 	}
 	/* This should be verified on older screamers */
@@ -971,7 +975,9 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 	prop = of_get_property(sound, "device-id", NULL);
 	if (prop)
 		chip->device_id = *prop;
-	chip->has_iic = (find_devices("perch") != NULL);
+	dn = of_find_node_by_name(NULL, "perch");
+	chip->has_iic = (dn != NULL);
+	of_node_put(dn);
 
 	/* We need the PCI device for DMA allocations, let's use a crude method
 	 * for now ...
@@ -1021,6 +1027,7 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 		chip->freqs_ok = 1;
 	}
 
+	of_node_put(sound);
 	return 0;
 }
 

commit c4f55b394505fff6ad831d17e36e02dde1c3a8d7
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Apr 3 22:39:14 2007 +1000

    [POWERPC] Rename get_property to of_get_property: sound
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index c64af55865d4..5e829683d1ad 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -864,7 +864,8 @@ static void __init detect_byte_swap(struct snd_pmac *chip)
 static int __init snd_pmac_detect(struct snd_pmac *chip)
 {
 	struct device_node *sound = NULL;
-	unsigned int *prop, l;
+	const unsigned int *prop;
+	unsigned int l;
 	struct macio_chip* macio;
 
 	if (!machine_is(powermac))
@@ -923,10 +924,10 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 	}
 	if (! sound)
 		return -ENODEV;
-	prop = (unsigned int *) get_property(sound, "sub-frame", NULL);
+	prop = of_get_property(sound, "sub-frame", NULL);
 	if (prop && *prop < 16)
 		chip->subframe = *prop;
-	prop = (unsigned int *) get_property(sound, "layout-id", NULL);
+	prop = of_get_property(sound, "layout-id", NULL);
 	if (prop) {
 		/* partly deprecate snd-powermac, for those machines
 		 * that have a layout-id property for now */
@@ -967,7 +968,7 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 		chip->freq_table = tumbler_freqs;
 		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
 	}
-	prop = (unsigned int *)get_property(sound, "device-id", NULL);
+	prop = of_get_property(sound, "device-id", NULL);
 	if (prop)
 		chip->device_id = *prop;
 	chip->has_iic = (find_devices("perch") != NULL);
@@ -997,10 +998,9 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 
 	/* look for a property saying what sample rates
 	   are available */
-	prop = (unsigned int *) get_property(sound, "sample-rates", &l);
+	prop = of_get_property(sound, "sample-rates", &l);
 	if (! prop)
-		prop = (unsigned int *) get_property(sound,
-						     "output-frame-rates", &l);
+		prop = of_get_property(sound, "output-frame-rates", &l);
 	if (prop) {
 		int i;
 		chip->freqs_ok = 0;

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 641430631505..c64af55865d4 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -713,7 +713,7 @@ void snd_pmac_beep_dma_stop(struct snd_pmac *chip)
  * interrupt handlers
  */
 static irqreturn_t
-snd_pmac_tx_intr(int irq, void *devid, struct pt_regs *regs)
+snd_pmac_tx_intr(int irq, void *devid)
 {
 	struct snd_pmac *chip = devid;
 	snd_pmac_pcm_update(chip, &chip->playback);
@@ -722,7 +722,7 @@ snd_pmac_tx_intr(int irq, void *devid, struct pt_regs *regs)
 
 
 static irqreturn_t
-snd_pmac_rx_intr(int irq, void *devid, struct pt_regs *regs)
+snd_pmac_rx_intr(int irq, void *devid)
 {
 	struct snd_pmac *chip = devid;
 	snd_pmac_pcm_update(chip, &chip->capture);
@@ -731,7 +731,7 @@ snd_pmac_rx_intr(int irq, void *devid, struct pt_regs *regs)
 
 
 static irqreturn_t
-snd_pmac_ctrl_intr(int irq, void *devid, struct pt_regs *regs)
+snd_pmac_ctrl_intr(int irq, void *devid)
 {
 	struct snd_pmac *chip = devid;
 	int ctrl = in_le32(&chip->awacs->control);

commit 0ebfff1491ef85d41ddf9c633834838be144f69f
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jul 3 21:36:01 2006 +1000

    [POWERPC] Add new interrupt mapping core and change platforms to use it
    
    This adds the new irq remapper core and removes the old one.  Because
    there are some fundamental conflicts with the old code, like the value
    of NO_IRQ which I'm now setting to 0 (as per discussions with Linus),
    etc..., this commit also changes the relevant platform and driver code
    over to use the new remapper (so as not to cause difficulties later
    in bisecting).
    
    This patch removes the old pre-parsing of the open firmware interrupt
    tree along with all the bogus assumptions it made to try to renumber
    interrupts according to the platform. This is all to be handled by the
    new code now.
    
    For the pSeries XICS interrupt controller, a single remapper host is
    created for the whole machine regardless of how many interrupt
    presentation and source controllers are found, and it's set to match
    any device node that isn't a 8259.  That works fine on pSeries and
    avoids having to deal with some of the complexities of split source
    controllers vs. presentation controllers in the pSeries device trees.
    
    The powerpc i8259 PIC driver now always requests the legacy interrupt
    range. It also has the feature of being able to match any device node
    (including NULL) if passed no device node as an input. That will help
    porting over platforms with broken device-trees like Pegasos who don't
    have a proper interrupt tree.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 90db9a1d1e0a..641430631505 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1120,6 +1120,7 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 	struct snd_pmac *chip;
 	struct device_node *np;
 	int i, err;
+	unsigned int irq;
 	unsigned long ctrl_addr, txdma_addr, rxdma_addr;
 	static struct snd_device_ops ops = {
 		.dev_free =	snd_pmac_dev_free,
@@ -1153,10 +1154,6 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 	if (chip->is_k2) {
 		static char *rnames[] = {
 			"Sound Control", "Sound DMA" };
-		if (np->n_intrs < 3) {
-			err = -ENODEV;
-			goto __error;
-		}
 		for (i = 0; i < 2; i ++) {
 			if (of_address_to_resource(np->parent, i,
 						   &chip->rsrc[i])) {
@@ -1185,10 +1182,6 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 	} else {
 		static char *rnames[] = {
 			"Sound Control", "Sound Tx DMA", "Sound Rx DMA" };
-		if (np->n_intrs < 3) {
-			err = -ENODEV;
-			goto __error;
-		}
 		for (i = 0; i < 3; i ++) {
 			if (of_address_to_resource(np, i,
 						   &chip->rsrc[i])) {
@@ -1220,28 +1213,30 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 	chip->playback.dma = ioremap(txdma_addr, 0x100);
 	chip->capture.dma = ioremap(rxdma_addr, 0x100);
 	if (chip->model <= PMAC_BURGUNDY) {
-		if (request_irq(np->intrs[0].line, snd_pmac_ctrl_intr, 0,
+		irq = irq_of_parse_and_map(np, 0);
+		if (request_irq(irq, snd_pmac_ctrl_intr, 0,
 				"PMac", (void*)chip)) {
-			snd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n", np->intrs[0].line);
+			snd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n",
+				   irq);
 			err = -EBUSY;
 			goto __error;
 		}
-		chip->irq = np->intrs[0].line;
+		chip->irq = irq;
 	}
-	if (request_irq(np->intrs[1].line, snd_pmac_tx_intr, 0,
-			"PMac Output", (void*)chip)) {
-		snd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n", np->intrs[1].line);
+	irq = irq_of_parse_and_map(np, 1);
+	if (request_irq(irq, snd_pmac_tx_intr, 0, "PMac Output", (void*)chip)){
+		snd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n", irq);
 		err = -EBUSY;
 		goto __error;
 	}
-	chip->tx_irq = np->intrs[1].line;
-	if (request_irq(np->intrs[2].line, snd_pmac_rx_intr, 0,
-			"PMac Input", (void*)chip)) {
-		snd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n", np->intrs[2].line);
+	chip->tx_irq = irq;
+	irq = irq_of_parse_and_map(np, 2);
+	if (request_irq(irq, snd_pmac_rx_intr, 0, "PMac Input", (void*)chip)) {
+		snd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n", irq);
 		err = -EBUSY;
 		goto __error;
 	}
-	chip->rx_irq = np->intrs[2].line;
+	chip->rx_irq = irq;
 
 	snd_pmac_sound_feature(chip, 1);
 

commit d63fb6c55f5f9eb3032fc5c3ab6eb9a26dd67cdc
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sun Jul 2 11:55:03 2006 +1000

    [PATCH] powermac: Fix some 64b resource damage
    
    The 64 bits resource patches did a bit of damage on PowerMac causing a
    buffer overflow in macio_asic and a warning in a sound driver. The
    former is fixed by reverting the sprintf of the bus_id to %08x as it was
    before. The bus_id used for macio devices is always a 32 bits value
    (macio always sits in 32 bits space) and since it's exposed to userland,
    the format of the string shouldn't be changed like that anyway. The
    second by using the proper type for printk.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index be98f6377339..90db9a1d1e0a 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1170,7 +1170,7 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 					       chip->rsrc[i].start + 1,
 					       rnames[i]) == NULL) {
 				printk(KERN_ERR "snd: can't request rsrc "
-				       " %d (%s: 0x%016lx:%016lx)\n",
+				       " %d (%s: 0x%016llx:%016llx)\n",
 				       i, rnames[i],
 				       (unsigned long long)chip->rsrc[i].start,
 				       (unsigned long long)chip->rsrc[i].end);

commit aa0a2ddc54fa8a22060d17a9ca7bbc4bcc51f260
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 14:50:27 2006 -0700

    [PATCH] 64bit resource: fix up printks for resources in sound drivers
    
    This is needed if we wish to change the size of the resource structures.
    
    Based on an original patch from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index b678814975c9..be98f6377339 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1170,9 +1170,10 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 					       chip->rsrc[i].start + 1,
 					       rnames[i]) == NULL) {
 				printk(KERN_ERR "snd: can't request rsrc "
-				       " %d (%s: 0x%08lx:%08lx)\n",
-				       i, rnames[i], chip->rsrc[i].start,
-				       chip->rsrc[i].end);
+				       " %d (%s: 0x%016lx:%016lx)\n",
+				       i, rnames[i],
+				       (unsigned long long)chip->rsrc[i].start,
+				       (unsigned long long)chip->rsrc[i].end);
 				err = -ENODEV;
 				goto __error;
 			}
@@ -1201,9 +1202,10 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 					       chip->rsrc[i].start + 1,
 					       rnames[i]) == NULL) {
 				printk(KERN_ERR "snd: can't request rsrc "
-				       " %d (%s: 0x%08lx:%08lx)\n",
-				       i, rnames[i], chip->rsrc[i].start,
-				       chip->rsrc[i].end);
+				       " %d (%s: 0x%016llx:%016llx)\n",
+				       i, rnames[i],
+				       (unsigned long long)chip->rsrc[i].start,
+				       (unsigned long long)chip->rsrc[i].end);
 				err = -ENODEV;
 				goto __error;
 			}

commit 55c385ad5e1f3cda887cd6a8ad69a6d74b4b9125
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Jun 21 15:43:44 2006 +0200

    [ALSA] snd-powermac: no longer handle anything with a layout-id property
    
    This patch removes from snd-powermac the code that check for the layout-id
    and instead adds code that makes it refuse loading when a layout-id property
    is present, nothing that snd-aoa should be used.
    It also removes the 'toonie' codec from snd-powermac which was only ever
    used on the mac mini which has a layout-id property.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index f0794ef9d1ac..b678814975c9 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -867,8 +867,6 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 	unsigned int *prop, l;
 	struct macio_chip* macio;
 
-	u32 layout_id = 0;
-
 	if (!machine_is(powermac))
 		return -ENODEV;
 
@@ -929,8 +927,14 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 	if (prop && *prop < 16)
 		chip->subframe = *prop;
 	prop = (unsigned int *) get_property(sound, "layout-id", NULL);
-	if (prop)
-		layout_id = *prop;
+	if (prop) {
+		/* partly deprecate snd-powermac, for those machines
+		 * that have a layout-id property for now */
+		printk(KERN_INFO "snd-powermac no longer handles any "
+				 "machines with a layout-id property "
+				 "in the device-tree, use snd-aoa.\n");
+		return -ENODEV;
+	}
 	/* This should be verified on older screamers */
 	if (device_is_compatible(sound, "screamer")) {
 		chip->model = PMAC_SCREAMER;
@@ -963,38 +967,6 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 		chip->freq_table = tumbler_freqs;
 		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
 	}
-	if (device_is_compatible(sound, "AOAKeylargo") ||
-	    device_is_compatible(sound, "AOAbase") ||
-	    device_is_compatible(sound, "AOAK2")) {
-		/* For now, only support very basic TAS3004 based machines with
-		 * single frequency until proper i2s control is implemented
-		 */
-		switch(layout_id) {
-		case 0x24:
-		case 0x29:
-		case 0x33:
-		case 0x46:
-		case 0x48:
-		case 0x50:
-		case 0x5c:
-			chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
-			chip->model = PMAC_SNAPPER;
-			chip->can_byte_swap = 0; /* FIXME: check this */
-			chip->control_mask = MASK_IEPC | 0x11;/* disable IEE */
-			break;
-		case 0x3a:
-			chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
-			chip->model = PMAC_TOONIE;
-			chip->can_byte_swap = 0; /* FIXME: check this */
-			chip->control_mask = MASK_IEPC | 0x11;/* disable IEE */
-			break;
-		default:
-			printk(KERN_ERR "snd: Unknown layout ID 0x%x\n",
-			       layout_id);
-			return -ENODEV;
-
-		}
-	}
 	prop = (unsigned int *)get_property(sound, "device-id", NULL);
 	if (prop)
 		chip->device_id = *prop;

commit e8222502ee6157e2713da9e0792c21f4ad458d50
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Mar 28 23:15:54 2006 +1100

    [PATCH] powerpc: Kill _machine and hard-coded platform numbers
    
    This removes statically assigned platform numbers and reworks the
    powerpc platform probe code to use a better mechanism.  With this,
    board support files can simply declare a new machine type with a
    macro, and implement a probe() function that uses the flattened
    device-tree to detect if they apply for a given machine.
    
    We now have a machine_is() macro that replaces the comparisons of
    _machine with the various PLATFORM_* constants.  This commit also
    changes various drivers to use the new macro instead of looking at
    _machine.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index aa57170101fd..f0794ef9d1ac 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -869,7 +869,7 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 
 	u32 layout_id = 0;
 
-	if (_machine != _MACH_Pmac)
+	if (!machine_is(powermac))
 		return -ENODEV;
 
 	chip->subframe = 0;

commit 367636e8a9ef250d5b255f9d299e1c27cb3d7ea3
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Feb 8 15:04:18 2006 +1100

    [PATCH] powerpc: Fix sound driver use of i2c
    
    The PowerMac sound drivers used to rely on a "bug" of the i2c-keywest
    driver that implemented I2C_SMBUS_BLOCK_DATA incorrectly, that is it did
    what I2C_SMBUS_I2C_BLOCK_DATA should have done. The new i2c-powermac
    driver that replaces keywest has this bug fixed, thus the sound drivers
    must be fixed too.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 4988f873a7ba..aa57170101fd 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -66,7 +66,7 @@ static int snd_pmac_dbdma_alloc(struct snd_pmac *chip, struct pmac_dbdma *rec, i
 
 static void snd_pmac_dbdma_free(struct snd_pmac *chip, struct pmac_dbdma *rec)
 {
-	if (rec) {
+	if (rec->space) {
 		unsigned int rsize = sizeof(struct dbdma_cmd) * (rec->size + 1);
 
 		dma_free_coherent(&chip->pdev->dev, rsize, rec->space, rec->dma_base);
@@ -881,6 +881,7 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 	chip->can_capture = 1;
 	chip->num_freqs = ARRAY_SIZE(awacs_freqs);
 	chip->freq_table = awacs_freqs;
+	chip->pdev = NULL;
 
 	chip->control_mask = MASK_IEPC | MASK_IEE | 0x11; /* default */
 

commit 88356e908521a84b2220c9e8850d1a356a851aa9
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Feb 1 03:04:43 2006 -0800

    [PATCH] sound/ppc/pmac.c typo
    
    In 2.6.16-rc1 there is a small typo introduced by the 'Remove device_node
    addrs/n_addr' changes which prevents my Powerbook G4 sound from working:
    
            Advanced Linux Sound Architecture Driver Version 1.0.11rc2 (Wed Jan 04 08:57:20 2006 UTC).
            snd: can't request rsrc  0 (Sound Control: 0x80000000:80004fff)
            ALSA device list:
               No soundcards found.
    
    The patch below fixes it.  Of course, the patch fixing the i2c issues
    ('i2c_smbus_write_i2c_block_data' patch) needs to be applied to in order
    for the sound to completly work.
    
    Signed-off-by: Stelian Pop <stelian@popies.net>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index a642e4cfcf45..4988f873a7ba 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1216,7 +1216,7 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 			goto __error;
 		}
 		for (i = 0; i < 3; i ++) {
-			if (of_address_to_resource(np->parent, i,
+			if (of_address_to_resource(np, i,
 						   &chip->rsrc[i])) {
 				printk(KERN_ERR "snd: can't translate rsrc "
 				       " %d (%s)\n", i, rnames[i]);

commit cc5d0189b9ba95260857a5018a1c2fef90008507
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Dec 13 18:01:21 2005 +1100

    [PATCH] powerpc: Remove device_node addrs/n_addr
    
    The pre-parsed addrs/n_addrs fields in struct device_node are finally
    gone. Remove the dodgy heuristics that did that parsing at boot and
    remove the fields themselves since we now have a good replacement with
    the new OF parsing code. This patch also fixes a bunch of drivers to use
    the new code instead, so that at least pmac32, pseries, iseries and g5
    defconfigs build.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 9b2b00fdc1ae..a642e4cfcf45 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -803,21 +803,17 @@ static int snd_pmac_free(struct snd_pmac *chip)
 		iounmap(chip->playback.dma);
 	if (chip->capture.dma)
 		iounmap(chip->capture.dma);
-#ifndef CONFIG_PPC64
+
 	if (chip->node) {
 		int i;
-
 		for (i = 0; i < 3; i++) {
-			if (chip->of_requested & (1 << i)) {
-				if (chip->is_k2)
-					release_OF_resource(chip->node->parent,
-							    i);
-				else
-					release_OF_resource(chip->node, i);
-			}
+			if (chip->requested & (1 << i))
+				release_mem_region(chip->rsrc[i].start,
+						   chip->rsrc[i].end -
+						   chip->rsrc[i].start + 1);
 		}
 	}
-#endif /* CONFIG_PPC64 */
+
 	if (chip->pdev)
 		pci_dev_put(chip->pdev);
 	kfree(chip);
@@ -991,6 +987,11 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 			chip->can_byte_swap = 0; /* FIXME: check this */
 			chip->control_mask = MASK_IEPC | 0x11;/* disable IEE */
 			break;
+		default:
+			printk(KERN_ERR "snd: Unknown layout ID 0x%x\n",
+			       layout_id);
+			return -ENODEV;
+
 		}
 	}
 	prop = (unsigned int *)get_property(sound, "device-id", NULL);
@@ -1175,46 +1176,69 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 	}
 
 	np = chip->node;
+	chip->requested = 0;
 	if (chip->is_k2) {
-		if (np->parent->n_addrs < 2 || np->n_intrs < 3) {
+		static char *rnames[] = {
+			"Sound Control", "Sound DMA" };
+		if (np->n_intrs < 3) {
 			err = -ENODEV;
 			goto __error;
 		}
-		for (i = 0; i < 2; i++) {
-#ifndef CONFIG_PPC64
-			static char *name[2] = { "- Control", "- DMA" };
-			if (! request_OF_resource(np->parent, i, name[i])) {
-				snd_printk(KERN_ERR "pmac: can't request resource %d!\n", i);
+		for (i = 0; i < 2; i ++) {
+			if (of_address_to_resource(np->parent, i,
+						   &chip->rsrc[i])) {
+				printk(KERN_ERR "snd: can't translate rsrc "
+				       " %d (%s)\n", i, rnames[i]);
+				err = -ENODEV;
+				goto __error;
+			}
+			if (request_mem_region(chip->rsrc[i].start,
+					       chip->rsrc[i].end -
+					       chip->rsrc[i].start + 1,
+					       rnames[i]) == NULL) {
+				printk(KERN_ERR "snd: can't request rsrc "
+				       " %d (%s: 0x%08lx:%08lx)\n",
+				       i, rnames[i], chip->rsrc[i].start,
+				       chip->rsrc[i].end);
 				err = -ENODEV;
 				goto __error;
 			}
-			chip->of_requested |= (1 << i);
-#endif /* CONFIG_PPC64 */
-			ctrl_addr = np->parent->addrs[0].address;
-			txdma_addr = np->parent->addrs[1].address;
-			rxdma_addr = txdma_addr + 0x100;
+			chip->requested |= (1 << i);
 		}
-
+		ctrl_addr = chip->rsrc[0].start;
+		txdma_addr = chip->rsrc[1].start;
+		rxdma_addr = txdma_addr + 0x100;
 	} else {
-		if (np->n_addrs < 3 || np->n_intrs < 3) {
+		static char *rnames[] = {
+			"Sound Control", "Sound Tx DMA", "Sound Rx DMA" };
+		if (np->n_intrs < 3) {
 			err = -ENODEV;
 			goto __error;
 		}
-
-		for (i = 0; i < 3; i++) {
-#ifndef CONFIG_PPC64
-			static char *name[3] = { "- Control", "- Tx DMA", "- Rx DMA" };
-			if (! request_OF_resource(np, i, name[i])) {
-				snd_printk(KERN_ERR "pmac: can't request resource %d!\n", i);
+		for (i = 0; i < 3; i ++) {
+			if (of_address_to_resource(np->parent, i,
+						   &chip->rsrc[i])) {
+				printk(KERN_ERR "snd: can't translate rsrc "
+				       " %d (%s)\n", i, rnames[i]);
+				err = -ENODEV;
+				goto __error;
+			}
+			if (request_mem_region(chip->rsrc[i].start,
+					       chip->rsrc[i].end -
+					       chip->rsrc[i].start + 1,
+					       rnames[i]) == NULL) {
+				printk(KERN_ERR "snd: can't request rsrc "
+				       " %d (%s: 0x%08lx:%08lx)\n",
+				       i, rnames[i], chip->rsrc[i].start,
+				       chip->rsrc[i].end);
 				err = -ENODEV;
 				goto __error;
 			}
-			chip->of_requested |= (1 << i);
-#endif /* CONFIG_PPC64 */
-			ctrl_addr = np->addrs[0].address;
-			txdma_addr = np->addrs[1].address;
-			rxdma_addr = np->addrs[2].address;
+			chip->requested |= (1 << i);
 		}
+		ctrl_addr = chip->rsrc[0].start;
+		txdma_addr = chip->rsrc[1].start;
+		rxdma_addr = chip->rsrc[2].start;
 	}
 
 	chip->awacs = ioremap(ctrl_addr, 0x1000);
@@ -1266,9 +1290,11 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 	} else if (chip->is_pbook_G3) {
 		struct device_node* mio;
 		for (mio = chip->node->parent; mio; mio = mio->parent) {
-			if (strcmp(mio->name, "mac-io") == 0
-			    && mio->n_addrs > 0) {
-				chip->macio_base = ioremap(mio->addrs[0].address, 0x40);
+			if (strcmp(mio->name, "mac-io") == 0) {
+				struct resource r;
+				if (of_address_to_resource(mio, 0, &r) == 0)
+					chip->macio_base =
+						ioremap(r.start, 0x40);
 				break;
 			}
 		}

commit 481ba7727fa08deb389b5a2e550e04df24d3f37d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 1 11:19:41 2005 +0100

    [ALSA] powermac - Revert the last addition for 17' powerbook
    
    Modules: PPC PMAC driver
    
    The last addition of 17' powerbook support seems buggy
    (it's not Toonie indeed).  Removed again.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index d70292cd1775..9b2b00fdc1ae 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -986,7 +986,6 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 			chip->control_mask = MASK_IEPC | 0x11;/* disable IEE */
 			break;
 		case 0x3a:
-		case 0x40:
 			chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
 			chip->model = PMAC_TOONIE;
 			chip->can_byte_swap = 0; /* FIXME: check this */

commit 7cd01dd840824e7c6023ad1dbfdb94a2183a7adb
Author: Kyle Moffett <mrmacman_g4@mac.com>
Date:   Wed Nov 30 10:54:28 2005 +0100

    [ALSA] snd_powermac: Add ID for Spring 2005 17' Powerbook
    
    Modules: PPC PMAC driver
    
    The audio chip in my Spring 2005 17' PowerBook was incorrectly
    recognized as an AWACS chip.  This adds the chip ID to the
    snd_powermac driver such that it is recognized as a Toonie (I don't
    know if that's correct, but it's the only one that makes it work at
    all). and sorts the ID lists numerically.  NOTE:  This chip is only
    minimally supported at this point; it has system beep support and
    very low volume speaker output, and that's about it.
    
    Signed-off-by: Kyle Moffett <mrmacman_g4@mac.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 4f0a4204516d..d70292cd1775 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -973,11 +973,11 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 		 * single frequency until proper i2s control is implemented
 		 */
 		switch(layout_id) {
-		case 0x48:
-		case 0x46:
-		case 0x33:
-		case 0x29:
 		case 0x24:
+		case 0x29:
+		case 0x33:
+		case 0x46:
+		case 0x48:
 		case 0x50:
 		case 0x5c:
 			chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
@@ -986,6 +986,7 @@ static int __init snd_pmac_detect(struct snd_pmac *chip)
 			chip->control_mask = MASK_IEPC | 0x11;/* disable IEE */
 			break;
 		case 0x3a:
+		case 0x40:
 			chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
 			chip->model = PMAC_TOONIE;
 			chip->can_byte_swap = 0; /* FIXME: check this */

commit 5e12bea0833e47117c31f13b528e31dc8112de57
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 17:17:08 2005 +0100

    [ALSA] powermac - Use platform_device
    
    Modules: PPC,PPC PMAC driver,PPC PowerMac driver
    
    Rewrite the probe/remove with platform_device.
    Move the PM support to platform_device's callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 222765fd0dc5..4f0a4204516d 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -36,14 +36,6 @@
 #include <asm/pci-bridge.h>
 
 
-#ifdef CONFIG_PM
-static int snd_pmac_register_sleep_notifier(struct snd_pmac *chip);
-static int snd_pmac_unregister_sleep_notifier(struct snd_pmac *chip);
-static int snd_pmac_suspend(struct snd_card *card, pm_message_t state);
-static int snd_pmac_resume(struct snd_card *card);
-#endif
-
-
 /* fixed frequency table for awacs, screamer, burgundy, DACA (44100 max) */
 static int awacs_freqs[8] = {
 	44100, 29400, 22050, 17640, 14700, 11025, 8820, 7350
@@ -784,9 +776,6 @@ static int snd_pmac_free(struct snd_pmac *chip)
 	}
 
 	snd_pmac_sound_feature(chip, 0);
-#ifdef CONFIG_PM
-	snd_pmac_unregister_sleep_notifier(chip);
-#endif
 
 	/* clean up mixer if any */
 	if (chip->mixer_free)
@@ -1298,12 +1287,6 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 	/* Reset dbdma channels */
 	snd_pmac_dbdma_reset(chip);
 
-#ifdef CONFIG_PM
-	/* add sleep notifier */
-	if (! snd_pmac_register_sleep_notifier(chip))
-		snd_card_set_pm_callback(chip->card, snd_pmac_suspend, snd_pmac_resume, chip);
-#endif
-
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0)
 		goto __error;
 
@@ -1328,11 +1311,11 @@ int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
  * Save state when going to sleep, restore it afterwards.
  */
 
-static int snd_pmac_suspend(struct snd_card *card, pm_message_t state)
+void snd_pmac_suspend(struct snd_pmac *chip)
 {
-	struct snd_pmac *chip = card->pm_private_data;
 	unsigned long flags;
 
+	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
 	if (chip->suspend)
 		chip->suspend(chip);
 	snd_pcm_suspend_all(chip->pcm);
@@ -1346,22 +1329,18 @@ static int snd_pmac_suspend(struct snd_card *card, pm_message_t state)
 	if (chip->rx_irq >= 0)
 		disable_irq(chip->rx_irq);
 	snd_pmac_sound_feature(chip, 0);
-	return 0;
 }
 
-static int snd_pmac_resume(struct snd_card *card)
+void snd_pmac_resume(struct snd_pmac *chip)
 {
-	struct snd_pmac *chip = card->pm_private_data;
-
 	snd_pmac_sound_feature(chip, 1);
 	if (chip->resume)
 		chip->resume(chip);
 	/* enable CD sound input */
-	if (chip->macio_base && chip->is_pbook_G3) {
+	if (chip->macio_base && chip->is_pbook_G3)
 		out_8(chip->macio_base + 0x37, 3);
-	} else if (chip->is_pbook_3400) {
+	else if (chip->is_pbook_3400)
 		in_8(chip->latch_base + 0x190);
-	}
 
 	snd_pmac_pcm_set_format(chip);
 
@@ -1372,53 +1351,7 @@ static int snd_pmac_resume(struct snd_card *card)
 	if (chip->rx_irq >= 0)
 		enable_irq(chip->rx_irq);
 
-	return 0;
-}
-
-/* the chip is stored statically by snd_pmac_register_sleep_notifier
- * because we can't have any private data for notify callback.
- */
-static struct snd_pmac *sleeping_pmac = NULL;
-
-static int snd_pmac_sleep_notify(struct pmu_sleep_notifier *self, int when)
-{
-	struct snd_pmac *chip;
-
-	chip = sleeping_pmac;
-	if (! chip)
-		return 0;
-
-	switch (when) {
-	case PBOOK_SLEEP_NOW:
-		snd_pmac_suspend(chip->card, PMSG_SUSPEND);
-		break;
-	case PBOOK_WAKE:
-		snd_pmac_resume(chip->card);
-		break;
-	}
-	return PBOOK_SLEEP_OK;
-}
-
-static struct pmu_sleep_notifier snd_pmac_sleep_notifier = {
-	snd_pmac_sleep_notify, SLEEP_LEVEL_SOUND,
-};
-
-static int __init snd_pmac_register_sleep_notifier(struct snd_pmac *chip)
-{
-	/* should be protected here.. */
-	snd_assert(! sleeping_pmac, return -EBUSY);
-	sleeping_pmac = chip;
-	pmu_register_sleep_notifier(&snd_pmac_sleep_notifier);
-	return 0;
-}
-						    
-static int snd_pmac_unregister_sleep_notifier(struct snd_pmac *chip)
-{
-	/* should be protected here.. */
-	snd_assert(sleeping_pmac == chip, return -ENODEV);
-	pmu_unregister_sleep_notifier(&snd_pmac_sleep_notifier);
-	sleeping_pmac = NULL;
-	return 0;
+	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);
 }
 
 #endif /* CONFIG_PM */

commit 65b29f5039b38a5854b5e12238b0688a33e235cc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:09:46 2005 +0100

    [ALSA] Remove xxx_t typedefs: PowerMac
    
    Remove xxx_t typedefs from the PowerMac driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index dd28187ec0e9..222765fd0dc5 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -37,10 +37,10 @@
 
 
 #ifdef CONFIG_PM
-static int snd_pmac_register_sleep_notifier(pmac_t *chip);
-static int snd_pmac_unregister_sleep_notifier(pmac_t *chip);
-static int snd_pmac_suspend(snd_card_t *card, pm_message_t state);
-static int snd_pmac_resume(snd_card_t *card);
+static int snd_pmac_register_sleep_notifier(struct snd_pmac *chip);
+static int snd_pmac_unregister_sleep_notifier(struct snd_pmac *chip);
+static int snd_pmac_suspend(struct snd_card *card, pm_message_t state);
+static int snd_pmac_resume(struct snd_card *card);
 #endif
 
 
@@ -56,7 +56,7 @@ static int tumbler_freqs[1] = {
 /*
  * allocate DBDMA command arrays
  */
-static int snd_pmac_dbdma_alloc(pmac_t *chip, pmac_dbdma_t *rec, int size)
+static int snd_pmac_dbdma_alloc(struct snd_pmac *chip, struct pmac_dbdma *rec, int size)
 {
 	unsigned int rsize = sizeof(struct dbdma_cmd) * (size + 1);
 
@@ -72,7 +72,7 @@ static int snd_pmac_dbdma_alloc(pmac_t *chip, pmac_dbdma_t *rec, int size)
 	return 0;
 }
 
-static void snd_pmac_dbdma_free(pmac_t *chip, pmac_dbdma_t *rec)
+static void snd_pmac_dbdma_free(struct snd_pmac *chip, struct pmac_dbdma *rec)
 {
 	if (rec) {
 		unsigned int rsize = sizeof(struct dbdma_cmd) * (rec->size + 1);
@@ -90,7 +90,7 @@ static void snd_pmac_dbdma_free(pmac_t *chip, pmac_dbdma_t *rec)
  * look up frequency table
  */
 
-unsigned int snd_pmac_rate_index(pmac_t *chip, pmac_stream_t *rec, unsigned int rate)
+unsigned int snd_pmac_rate_index(struct snd_pmac *chip, struct pmac_stream *rec, unsigned int rate)
 {
 	int i, ok, found;
 
@@ -119,8 +119,8 @@ static inline int another_stream(int stream)
 /*
  * allocate buffers
  */
-static int snd_pmac_pcm_hw_params(snd_pcm_substream_t *subs,
-				  snd_pcm_hw_params_t *hw_params)
+static int snd_pmac_pcm_hw_params(struct snd_pcm_substream *subs,
+				  struct snd_pcm_hw_params *hw_params)
 {
 	return snd_pcm_lib_malloc_pages(subs, params_buffer_bytes(hw_params));
 }
@@ -128,7 +128,7 @@ static int snd_pmac_pcm_hw_params(snd_pcm_substream_t *subs,
 /*
  * release buffers
  */
-static int snd_pmac_pcm_hw_free(snd_pcm_substream_t *subs)
+static int snd_pmac_pcm_hw_free(struct snd_pcm_substream *subs)
 {
 	snd_pcm_lib_free_pages(subs);
 	return 0;
@@ -137,7 +137,7 @@ static int snd_pmac_pcm_hw_free(snd_pcm_substream_t *subs)
 /*
  * get a stream of the opposite direction
  */
-static pmac_stream_t *snd_pmac_get_stream(pmac_t *chip, int stream)
+static struct pmac_stream *snd_pmac_get_stream(struct snd_pmac *chip, int stream)
 {
 	switch (stream) {
 	case SNDRV_PCM_STREAM_PLAYBACK:
@@ -154,7 +154,7 @@ static pmac_stream_t *snd_pmac_get_stream(pmac_t *chip, int stream)
  * wait while run status is on
  */
 static inline void
-snd_pmac_wait_ack(pmac_stream_t *rec)
+snd_pmac_wait_ack(struct pmac_stream *rec)
 {
 	int timeout = 50000;
 	while ((in_le32(&rec->dma->status) & RUN) && timeout-- > 0)
@@ -165,7 +165,7 @@ snd_pmac_wait_ack(pmac_stream_t *rec)
  * set the format and rate to the chip.
  * call the lowlevel function if defined (e.g. for AWACS).
  */
-static void snd_pmac_pcm_set_format(pmac_t *chip)
+static void snd_pmac_pcm_set_format(struct snd_pmac *chip)
 {
 	/* set up frequency and format */
 	out_le32(&chip->awacs->control, chip->control_mask | (chip->rate_index << 8));
@@ -177,7 +177,7 @@ static void snd_pmac_pcm_set_format(pmac_t *chip)
 /*
  * stop the DMA transfer
  */
-static inline void snd_pmac_dma_stop(pmac_stream_t *rec)
+static inline void snd_pmac_dma_stop(struct pmac_stream *rec)
 {
 	out_le32(&rec->dma->control, (RUN|WAKE|FLUSH|PAUSE) << 16);
 	snd_pmac_wait_ack(rec);
@@ -186,7 +186,7 @@ static inline void snd_pmac_dma_stop(pmac_stream_t *rec)
 /*
  * set the command pointer address
  */
-static inline void snd_pmac_dma_set_command(pmac_stream_t *rec, pmac_dbdma_t *cmd)
+static inline void snd_pmac_dma_set_command(struct pmac_stream *rec, struct pmac_dbdma *cmd)
 {
 	out_le32(&rec->dma->cmdptr, cmd->addr);
 }
@@ -194,7 +194,7 @@ static inline void snd_pmac_dma_set_command(pmac_stream_t *rec, pmac_dbdma_t *cm
 /*
  * start the DMA
  */
-static inline void snd_pmac_dma_run(pmac_stream_t *rec, int status)
+static inline void snd_pmac_dma_run(struct pmac_stream *rec, int status)
 {
 	out_le32(&rec->dma->control, status | (status << 16));
 }
@@ -203,14 +203,14 @@ static inline void snd_pmac_dma_run(pmac_stream_t *rec, int status)
 /*
  * prepare playback/capture stream
  */
-static int snd_pmac_pcm_prepare(pmac_t *chip, pmac_stream_t *rec, snd_pcm_substream_t *subs)
+static int snd_pmac_pcm_prepare(struct snd_pmac *chip, struct pmac_stream *rec, struct snd_pcm_substream *subs)
 {
 	int i;
 	volatile struct dbdma_cmd __iomem *cp;
-	snd_pcm_runtime_t *runtime = subs->runtime;
+	struct snd_pcm_runtime *runtime = subs->runtime;
 	int rate_index;
 	long offset;
-	pmac_stream_t *astr;
+	struct pmac_stream *astr;
 	
 	rec->dma_size = snd_pcm_lib_buffer_bytes(subs);
 	rec->period_size = snd_pcm_lib_period_bytes(subs);
@@ -267,8 +267,8 @@ static int snd_pmac_pcm_prepare(pmac_t *chip, pmac_stream_t *rec, snd_pcm_substr
 /*
  * PCM trigger/stop
  */
-static int snd_pmac_pcm_trigger(pmac_t *chip, pmac_stream_t *rec,
-				snd_pcm_substream_t *subs, int cmd)
+static int snd_pmac_pcm_trigger(struct snd_pmac *chip, struct pmac_stream *rec,
+				struct snd_pcm_substream *subs, int cmd)
 {
 	volatile struct dbdma_cmd __iomem *cp;
 	int i, command;
@@ -314,8 +314,9 @@ static int snd_pmac_pcm_trigger(pmac_t *chip, pmac_stream_t *rec,
  * return the current pointer
  */
 inline
-static snd_pcm_uframes_t snd_pmac_pcm_pointer(pmac_t *chip, pmac_stream_t *rec,
-					      snd_pcm_substream_t *subs)
+static snd_pcm_uframes_t snd_pmac_pcm_pointer(struct snd_pmac *chip,
+					      struct pmac_stream *rec,
+					      struct snd_pcm_substream *subs)
 {
 	int count = 0;
 
@@ -338,22 +339,22 @@ static snd_pcm_uframes_t snd_pmac_pcm_pointer(pmac_t *chip, pmac_stream_t *rec,
  * playback
  */
 
-static int snd_pmac_playback_prepare(snd_pcm_substream_t *subs)
+static int snd_pmac_playback_prepare(struct snd_pcm_substream *subs)
 {
-	pmac_t *chip = snd_pcm_substream_chip(subs);
+	struct snd_pmac *chip = snd_pcm_substream_chip(subs);
 	return snd_pmac_pcm_prepare(chip, &chip->playback, subs);
 }
 
-static int snd_pmac_playback_trigger(snd_pcm_substream_t *subs,
+static int snd_pmac_playback_trigger(struct snd_pcm_substream *subs,
 				     int cmd)
 {
-	pmac_t *chip = snd_pcm_substream_chip(subs);
+	struct snd_pmac *chip = snd_pcm_substream_chip(subs);
 	return snd_pmac_pcm_trigger(chip, &chip->playback, subs, cmd);
 }
 
-static snd_pcm_uframes_t snd_pmac_playback_pointer(snd_pcm_substream_t *subs)
+static snd_pcm_uframes_t snd_pmac_playback_pointer(struct snd_pcm_substream *subs)
 {
-	pmac_t *chip = snd_pcm_substream_chip(subs);
+	struct snd_pmac *chip = snd_pcm_substream_chip(subs);
 	return snd_pmac_pcm_pointer(chip, &chip->playback, subs);
 }
 
@@ -362,22 +363,22 @@ static snd_pcm_uframes_t snd_pmac_playback_pointer(snd_pcm_substream_t *subs)
  * capture
  */
 
-static int snd_pmac_capture_prepare(snd_pcm_substream_t *subs)
+static int snd_pmac_capture_prepare(struct snd_pcm_substream *subs)
 {
-	pmac_t *chip = snd_pcm_substream_chip(subs);
+	struct snd_pmac *chip = snd_pcm_substream_chip(subs);
 	return snd_pmac_pcm_prepare(chip, &chip->capture, subs);
 }
 
-static int snd_pmac_capture_trigger(snd_pcm_substream_t *subs,
+static int snd_pmac_capture_trigger(struct snd_pcm_substream *subs,
 				    int cmd)
 {
-	pmac_t *chip = snd_pcm_substream_chip(subs);
+	struct snd_pmac *chip = snd_pcm_substream_chip(subs);
 	return snd_pmac_pcm_trigger(chip, &chip->capture, subs, cmd);
 }
 
-static snd_pcm_uframes_t snd_pmac_capture_pointer(snd_pcm_substream_t *subs)
+static snd_pcm_uframes_t snd_pmac_capture_pointer(struct snd_pcm_substream *subs)
 {
-	pmac_t *chip = snd_pcm_substream_chip(subs);
+	struct snd_pmac *chip = snd_pcm_substream_chip(subs);
 	return snd_pmac_pcm_pointer(chip, &chip->capture, subs);
 }
 
@@ -385,7 +386,7 @@ static snd_pcm_uframes_t snd_pmac_capture_pointer(snd_pcm_substream_t *subs)
 /*
  * update playback/capture pointer from interrupts
  */
-static void snd_pmac_pcm_update(pmac_t *chip, pmac_stream_t *rec)
+static void snd_pmac_pcm_update(struct snd_pmac *chip, struct pmac_stream *rec)
 {
 	volatile struct dbdma_cmd __iomem *cp;
 	int c;
@@ -421,7 +422,7 @@ static void snd_pmac_pcm_update(pmac_t *chip, pmac_stream_t *rec)
  * hw info
  */
 
-static snd_pcm_hardware_t snd_pmac_playback =
+static struct snd_pcm_hardware snd_pmac_playback =
 {
 	.info =			(SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_MMAP |
@@ -440,7 +441,7 @@ static snd_pcm_hardware_t snd_pmac_playback =
 	.periods_max =		PMAC_MAX_FRAGS,
 };
 
-static snd_pcm_hardware_t snd_pmac_capture =
+static struct snd_pcm_hardware snd_pmac_capture =
 {
 	.info =			(SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_MMAP |
@@ -461,11 +462,11 @@ static snd_pcm_hardware_t snd_pmac_capture =
 
 
 #if 0 // NYI
-static int snd_pmac_hw_rule_rate(snd_pcm_hw_params_t *params,
-				 snd_pcm_hw_rule_t *rule)
+static int snd_pmac_hw_rule_rate(struct snd_pcm_hw_params *params,
+				 struct snd_pcm_hw_rule *rule)
 {
-	pmac_t *chip = rule->private;
-	pmac_stream_t *rec = snd_pmac_get_stream(chip, rule->deps[0]);
+	struct snd_pmac *chip = rule->private;
+	struct pmac_stream *rec = snd_pmac_get_stream(chip, rule->deps[0]);
 	int i, freq_table[8], num_freqs;
 
 	if (! rec)
@@ -480,11 +481,11 @@ static int snd_pmac_hw_rule_rate(snd_pcm_hw_params_t *params,
 				 num_freqs, freq_table, 0);
 }
 
-static int snd_pmac_hw_rule_format(snd_pcm_hw_params_t *params,
-				   snd_pcm_hw_rule_t *rule)
+static int snd_pmac_hw_rule_format(struct snd_pcm_hw_params *params,
+				   struct snd_pcm_hw_rule *rule)
 {
-	pmac_t *chip = rule->private;
-	pmac_stream_t *rec = snd_pmac_get_stream(chip, rule->deps[0]);
+	struct snd_pmac *chip = rule->private;
+	struct pmac_stream *rec = snd_pmac_get_stream(chip, rule->deps[0]);
 
 	if (! rec)
 		return -EINVAL;
@@ -493,9 +494,10 @@ static int snd_pmac_hw_rule_format(snd_pcm_hw_params_t *params,
 }
 #endif // NYI
 
-static int snd_pmac_pcm_open(pmac_t *chip, pmac_stream_t *rec, snd_pcm_substream_t *subs)
+static int snd_pmac_pcm_open(struct snd_pmac *chip, struct pmac_stream *rec,
+			     struct snd_pcm_substream *subs)
 {
-	snd_pcm_runtime_t *runtime = subs->runtime;
+	struct snd_pcm_runtime *runtime = subs->runtime;
 	int i, j, fflags;
 	static int typical_freqs[] = {
 		44100,
@@ -565,9 +567,10 @@ static int snd_pmac_pcm_open(pmac_t *chip, pmac_stream_t *rec, snd_pcm_substream
 	return 0;
 }
 
-static int snd_pmac_pcm_close(pmac_t *chip, pmac_stream_t *rec, snd_pcm_substream_t *subs)
+static int snd_pmac_pcm_close(struct snd_pmac *chip, struct pmac_stream *rec,
+			      struct snd_pcm_substream *subs)
 {
-	pmac_stream_t *astr;
+	struct pmac_stream *astr;
 
 	snd_pmac_dma_stop(rec);
 
@@ -582,32 +585,32 @@ static int snd_pmac_pcm_close(pmac_t *chip, pmac_stream_t *rec, snd_pcm_substrea
 	return 0;
 }
 
-static int snd_pmac_playback_open(snd_pcm_substream_t *subs)
+static int snd_pmac_playback_open(struct snd_pcm_substream *subs)
 {
-	pmac_t *chip = snd_pcm_substream_chip(subs);
+	struct snd_pmac *chip = snd_pcm_substream_chip(subs);
 
 	subs->runtime->hw = snd_pmac_playback;
 	return snd_pmac_pcm_open(chip, &chip->playback, subs);
 }
 
-static int snd_pmac_capture_open(snd_pcm_substream_t *subs)
+static int snd_pmac_capture_open(struct snd_pcm_substream *subs)
 {
-	pmac_t *chip = snd_pcm_substream_chip(subs);
+	struct snd_pmac *chip = snd_pcm_substream_chip(subs);
 
 	subs->runtime->hw = snd_pmac_capture;
 	return snd_pmac_pcm_open(chip, &chip->capture, subs);
 }
 
-static int snd_pmac_playback_close(snd_pcm_substream_t *subs)
+static int snd_pmac_playback_close(struct snd_pcm_substream *subs)
 {
-	pmac_t *chip = snd_pcm_substream_chip(subs);
+	struct snd_pmac *chip = snd_pcm_substream_chip(subs);
 
 	return snd_pmac_pcm_close(chip, &chip->playback, subs);
 }
 
-static int snd_pmac_capture_close(snd_pcm_substream_t *subs)
+static int snd_pmac_capture_close(struct snd_pcm_substream *subs)
 {
-	pmac_t *chip = snd_pcm_substream_chip(subs);
+	struct snd_pmac *chip = snd_pcm_substream_chip(subs);
 
 	return snd_pmac_pcm_close(chip, &chip->capture, subs);
 }
@@ -615,7 +618,7 @@ static int snd_pmac_capture_close(snd_pcm_substream_t *subs)
 /*
  */
 
-static snd_pcm_ops_t snd_pmac_playback_ops = {
+static struct snd_pcm_ops snd_pmac_playback_ops = {
 	.open =		snd_pmac_playback_open,
 	.close =	snd_pmac_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -626,7 +629,7 @@ static snd_pcm_ops_t snd_pmac_playback_ops = {
 	.pointer =	snd_pmac_playback_pointer,
 };
 
-static snd_pcm_ops_t snd_pmac_capture_ops = {
+static struct snd_pcm_ops snd_pmac_capture_ops = {
 	.open =		snd_pmac_capture_open,
 	.close =	snd_pmac_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -637,9 +640,9 @@ static snd_pcm_ops_t snd_pmac_capture_ops = {
 	.pointer =	snd_pmac_capture_pointer,
 };
 
-int __init snd_pmac_pcm_new(pmac_t *chip)
+int __init snd_pmac_pcm_new(struct snd_pmac *chip)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 	int num_captures = 1;
 
@@ -676,7 +679,7 @@ int __init snd_pmac_pcm_new(pmac_t *chip)
 }
 
 
-static void snd_pmac_dbdma_reset(pmac_t *chip)
+static void snd_pmac_dbdma_reset(struct snd_pmac *chip)
 {
 	out_le32(&chip->playback.dma->control, (RUN|PAUSE|FLUSH|WAKE|DEAD) << 16);
 	snd_pmac_wait_ack(&chip->playback);
@@ -688,9 +691,9 @@ static void snd_pmac_dbdma_reset(pmac_t *chip)
 /*
  * handling beep
  */
-void snd_pmac_beep_dma_start(pmac_t *chip, int bytes, unsigned long addr, int speed)
+void snd_pmac_beep_dma_start(struct snd_pmac *chip, int bytes, unsigned long addr, int speed)
 {
-	pmac_stream_t *rec = &chip->playback;
+	struct pmac_stream *rec = &chip->playback;
 
 	snd_pmac_dma_stop(rec);
 	st_le16(&chip->extra_dma.cmds->req_count, bytes);
@@ -706,7 +709,7 @@ void snd_pmac_beep_dma_start(pmac_t *chip, int bytes, unsigned long addr, int sp
 	snd_pmac_dma_run(rec, RUN);
 }
 
-void snd_pmac_beep_dma_stop(pmac_t *chip)
+void snd_pmac_beep_dma_stop(struct snd_pmac *chip)
 {
 	snd_pmac_dma_stop(&chip->playback);
 	st_le16(&chip->extra_dma.cmds->command, DBDMA_STOP);
@@ -720,7 +723,7 @@ void snd_pmac_beep_dma_stop(pmac_t *chip)
 static irqreturn_t
 snd_pmac_tx_intr(int irq, void *devid, struct pt_regs *regs)
 {
-	pmac_t *chip = devid;
+	struct snd_pmac *chip = devid;
 	snd_pmac_pcm_update(chip, &chip->playback);
 	return IRQ_HANDLED;
 }
@@ -729,7 +732,7 @@ snd_pmac_tx_intr(int irq, void *devid, struct pt_regs *regs)
 static irqreturn_t
 snd_pmac_rx_intr(int irq, void *devid, struct pt_regs *regs)
 {
-	pmac_t *chip = devid;
+	struct snd_pmac *chip = devid;
 	snd_pmac_pcm_update(chip, &chip->capture);
 	return IRQ_HANDLED;
 }
@@ -738,7 +741,7 @@ snd_pmac_rx_intr(int irq, void *devid, struct pt_regs *regs)
 static irqreturn_t
 snd_pmac_ctrl_intr(int irq, void *devid, struct pt_regs *regs)
 {
-	pmac_t *chip = devid;
+	struct snd_pmac *chip = devid;
 	int ctrl = in_le32(&chip->awacs->control);
 
 	/*printk("pmac: control interrupt.. 0x%x\n", ctrl);*/
@@ -761,7 +764,7 @@ snd_pmac_ctrl_intr(int irq, void *devid, struct pt_regs *regs)
 /*
  * a wrapper to feature call for compatibility
  */
-static void snd_pmac_sound_feature(pmac_t *chip, int enable)
+static void snd_pmac_sound_feature(struct snd_pmac *chip, int enable)
 {
 	if (ppc_md.feature_call)
 		ppc_md.feature_call(PMAC_FTR_SOUND_CHIP_ENABLE, chip->node, 0, enable);
@@ -771,7 +774,7 @@ static void snd_pmac_sound_feature(pmac_t *chip, int enable)
  * release resources
  */
 
-static int snd_pmac_free(pmac_t *chip)
+static int snd_pmac_free(struct snd_pmac *chip)
 {
 	/* stop sounds */
 	if (chip->initialized) {
@@ -836,9 +839,9 @@ static int snd_pmac_free(pmac_t *chip)
 /*
  * free the device
  */
-static int snd_pmac_dev_free(snd_device_t *device)
+static int snd_pmac_dev_free(struct snd_device *device)
 {
-	pmac_t *chip = device->device_data;
+	struct snd_pmac *chip = device->device_data;
 	return snd_pmac_free(chip);
 }
 
@@ -847,7 +850,7 @@ static int snd_pmac_dev_free(snd_device_t *device)
  * check the machine support byteswap (little-endian)
  */
 
-static void __init detect_byte_swap(pmac_t *chip)
+static void __init detect_byte_swap(struct snd_pmac *chip)
 {
 	struct device_node *mio;
 
@@ -873,7 +876,7 @@ static void __init detect_byte_swap(pmac_t *chip)
 /*
  * detect a sound chip
  */
-static int __init snd_pmac_detect(pmac_t *chip)
+static int __init snd_pmac_detect(struct snd_pmac *chip)
 {
 	struct device_node *sound = NULL;
 	unsigned int *prop, l;
@@ -1061,8 +1064,8 @@ static int __init snd_pmac_detect(pmac_t *chip)
 /*
  * exported - boolean info callbacks for ease of programming
  */
-int snd_pmac_boolean_stereo_info(snd_kcontrol_t *kcontrol,
-				 snd_ctl_elem_info_t *uinfo)
+int snd_pmac_boolean_stereo_info(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 2;
@@ -1071,8 +1074,8 @@ int snd_pmac_boolean_stereo_info(snd_kcontrol_t *kcontrol,
 	return 0;
 }
 
-int snd_pmac_boolean_mono_info(snd_kcontrol_t *kcontrol,
-			       snd_ctl_elem_info_t *uinfo)
+int snd_pmac_boolean_mono_info(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
@@ -1085,16 +1088,18 @@ int snd_pmac_boolean_mono_info(snd_kcontrol_t *kcontrol,
 /*
  * auto-mute
  */
-static int pmac_auto_mute_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int pmac_auto_mute_get(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	ucontrol->value.integer.value[0] = chip->auto_mute;
 	return 0;
 }
 
-static int pmac_auto_mute_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int pmac_auto_mute_put(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	if (ucontrol->value.integer.value[0] != chip->auto_mute) {
 		chip->auto_mute = ucontrol->value.integer.value[0];
 		if (chip->update_automute)
@@ -1104,9 +1109,10 @@ static int pmac_auto_mute_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *uc
 	return 0;
 }
 
-static int pmac_hp_detect_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int pmac_hp_detect_get(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
 {
-	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_pmac *chip = snd_kcontrol_chip(kcontrol);
 	if (chip->detect_headphone)
 		ucontrol->value.integer.value[0] = chip->detect_headphone(chip);
 	else
@@ -1114,7 +1120,7 @@ static int pmac_hp_detect_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *uc
 	return 0;
 }
 
-static snd_kcontrol_new_t auto_mute_controls[] __initdata = {
+static struct snd_kcontrol_new auto_mute_controls[] __initdata = {
 	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	  .name = "Auto Mute Switch",
 	  .info = snd_pmac_boolean_mono_info,
@@ -1129,7 +1135,7 @@ static snd_kcontrol_new_t auto_mute_controls[] __initdata = {
 	},
 };
 
-int __init snd_pmac_add_automute(pmac_t *chip)
+int __init snd_pmac_add_automute(struct snd_pmac *chip)
 {
 	int err;
 	chip->auto_mute = 1;
@@ -1146,13 +1152,13 @@ int __init snd_pmac_add_automute(pmac_t *chip)
 /*
  * create and detect a pmac chip record
  */
-int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)
+int __init snd_pmac_new(struct snd_card *card, struct snd_pmac **chip_return)
 {
-	pmac_t *chip;
+	struct snd_pmac *chip;
 	struct device_node *np;
 	int i, err;
 	unsigned long ctrl_addr, txdma_addr, rxdma_addr;
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free =	snd_pmac_dev_free,
 	};
 
@@ -1322,9 +1328,9 @@ int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)
  * Save state when going to sleep, restore it afterwards.
  */
 
-static int snd_pmac_suspend(snd_card_t *card, pm_message_t state)
+static int snd_pmac_suspend(struct snd_card *card, pm_message_t state)
 {
-	pmac_t *chip = card->pm_private_data;
+	struct snd_pmac *chip = card->pm_private_data;
 	unsigned long flags;
 
 	if (chip->suspend)
@@ -1343,9 +1349,9 @@ static int snd_pmac_suspend(snd_card_t *card, pm_message_t state)
 	return 0;
 }
 
-static int snd_pmac_resume(snd_card_t *card)
+static int snd_pmac_resume(struct snd_card *card)
 {
-	pmac_t *chip = card->pm_private_data;
+	struct snd_pmac *chip = card->pm_private_data;
 
 	snd_pmac_sound_feature(chip, 1);
 	if (chip->resume)
@@ -1372,11 +1378,11 @@ static int snd_pmac_resume(snd_card_t *card)
 /* the chip is stored statically by snd_pmac_register_sleep_notifier
  * because we can't have any private data for notify callback.
  */
-static pmac_t *sleeping_pmac = NULL;
+static struct snd_pmac *sleeping_pmac = NULL;
 
 static int snd_pmac_sleep_notify(struct pmu_sleep_notifier *self, int when)
 {
-	pmac_t *chip;
+	struct snd_pmac *chip;
 
 	chip = sleeping_pmac;
 	if (! chip)
@@ -1397,7 +1403,7 @@ static struct pmu_sleep_notifier snd_pmac_sleep_notifier = {
 	snd_pmac_sleep_notify, SLEEP_LEVEL_SOUND,
 };
 
-static int __init snd_pmac_register_sleep_notifier(pmac_t *chip)
+static int __init snd_pmac_register_sleep_notifier(struct snd_pmac *chip)
 {
 	/* should be protected here.. */
 	snd_assert(! sleeping_pmac, return -EBUSY);
@@ -1406,7 +1412,7 @@ static int __init snd_pmac_register_sleep_notifier(pmac_t *chip)
 	return 0;
 }
 						    
-static int snd_pmac_unregister_sleep_notifier(pmac_t *chip)
+static int snd_pmac_unregister_sleep_notifier(struct snd_pmac *chip)
 {
 	/* should be protected here.. */
 	snd_assert(sleeping_pmac == chip, return -ENODEV);

commit c3e6f7d8763fa0400d28c57633eb323515ba05fc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 16 18:43:35 2005 +0100

    [ALSA] Remove superfluous pcm_free callbacks
    
    Remove superflous pcm_free callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index db2f1815fc30..dd28187ec0e9 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -637,11 +637,6 @@ static snd_pcm_ops_t snd_pmac_capture_ops = {
 	.pointer =	snd_pmac_capture_pointer,
 };
 
-static void pmac_pcm_free(snd_pcm_t *pcm)
-{
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
 int __init snd_pmac_pcm_new(pmac_t *chip)
 {
 	snd_pcm_t *pcm;
@@ -659,7 +654,6 @@ int __init snd_pmac_pcm_new(pmac_t *chip)
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_pmac_capture_ops);
 
 	pcm->private_data = chip;
-	pcm->private_free = pmac_pcm_free;
 	pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
 	strcpy(pcm->name, chip->card->shortname);
 	chip->pcm = pcm;

commit 7c22f1aaa23370bf9ba2dd3abbccbed70dced216
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:46:31 2005 +0200

    [ALSA] Remove snd_runtime_check() macro
    
    Remove snd_runtime_check() macro.
    This macro worsens the readability of codes.  They should be either
    normal if() or removable asserts.
    
    Also, the assert displays stack-dump, instead of only the last caller
    pointer.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 392b2abd9f13..db2f1815fc30 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -220,7 +220,8 @@ static int snd_pmac_pcm_prepare(pmac_t *chip, pmac_stream_t *rec, snd_pcm_substr
 
 	/* set up constraints */
 	astr = snd_pmac_get_stream(chip, another_stream(rec->stream));
-	snd_runtime_check(astr, return -EINVAL);
+	if (! astr)
+		return -EINVAL;
 	astr->cur_freqs = 1 << rate_index;
 	astr->cur_formats = 1 << runtime->format;
 	chip->rate_index = rate_index;
@@ -467,7 +468,8 @@ static int snd_pmac_hw_rule_rate(snd_pcm_hw_params_t *params,
 	pmac_stream_t *rec = snd_pmac_get_stream(chip, rule->deps[0]);
 	int i, freq_table[8], num_freqs;
 
-	snd_runtime_check(rec, return -EINVAL);
+	if (! rec)
+		return -EINVAL;
 	num_freqs = 0;
 	for (i = chip->num_freqs - 1; i >= 0; i--) {
 		if (rec->cur_freqs & (1 << i))
@@ -484,7 +486,8 @@ static int snd_pmac_hw_rule_format(snd_pcm_hw_params_t *params,
 	pmac_t *chip = rule->private;
 	pmac_stream_t *rec = snd_pmac_get_stream(chip, rule->deps[0]);
 
-	snd_runtime_check(rec, return -EINVAL);
+	if (! rec)
+		return -EINVAL;
 	return snd_mask_refine_set(hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT),
 				   rec->cur_formats);
 }
@@ -569,7 +572,8 @@ static int snd_pmac_pcm_close(pmac_t *chip, pmac_stream_t *rec, snd_pcm_substrea
 	snd_pmac_dma_stop(rec);
 
 	astr = snd_pmac_get_stream(chip, another_stream(rec->stream));
-	snd_runtime_check(astr, return -EINVAL);
+	if (! astr)
+		return -EINVAL;
 
 	/* reset constraints */
 	astr->cur_freqs = chip->freqs_ok;
@@ -1158,7 +1162,6 @@ int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)
 		.dev_free =	snd_pmac_dev_free,
 	};
 
-	snd_runtime_check(chip_return, return -EINVAL);
 	*chip_return = NULL;
 
 	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
@@ -1382,7 +1385,8 @@ static int snd_pmac_sleep_notify(struct pmu_sleep_notifier *self, int when)
 	pmac_t *chip;
 
 	chip = sleeping_pmac;
-	snd_runtime_check(chip, return 0);
+	if (! chip)
+		return 0;
 
 	switch (when) {
 	case PBOOK_SLEEP_NOW:

commit 1e8bdcaf82268ac713cbbaffc14801147be42ae7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 19 15:21:17 2005 +0200

    [ALSA] Add iBook 1.33GHz support
    
    PPC PMAC driver
    Added the support of iBook 1.33GHz.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index e35b48d29c45..392b2abd9f13 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -988,6 +988,7 @@ static int __init snd_pmac_detect(pmac_t *chip)
 		case 0x33:
 		case 0x29:
 		case 0x24:
+		case 0x50:
 		case 0x5c:
 			chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
 			chip->model = PMAC_SNAPPER;

commit 561b220a4dece18d67177413e6fa21b49aa4acce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:22:34 2005 +0200

    [ALSA] Replace with kzalloc() - others
    
    Documentation,SA11xx UDA1341 driver,Generic drivers,MPU401 UART,OPL3
    OPL4,Digigram VX core,I2C cs8427,I2C lib core,I2C tea6330t,L3 drivers
    AK4114 receiver,AK4117 receiver,PDAudioCF driver,PPC PMAC driver
    SPARC AMD7930 driver,SPARC cs4231 driver,Synth,Common EMU synth
    USB generic driver,USB USX2Y
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 9774e568ee08..e35b48d29c45 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -1160,7 +1160,7 @@ int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)
 	snd_runtime_check(chip_return, return -EINVAL);
 	*chip_return = NULL;
 
-	chip = kcalloc(1, sizeof(*chip), GFP_KERNEL);
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
 	if (chip == NULL)
 		return -ENOMEM;
 	chip->card = card;

commit 821690cdc82e4090ef6f91947f76a231fad5cbb1
Author: Vincent Pelletier <subdino2004@yahoo.fr>
Date:   Wed Sep 7 13:28:14 2005 +0200

    [ALSA] Correct detection of iBook G4 1420Mhz soundcard
    
    PPC PMAC driver
    Here is a patch to correct detection of the soundcard on my iBook model
    (bought really recently).
    Without that fix, there were only andui in the headphone, and the mixer
    was totaly non functional.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index c89e82eb06a6..9774e568ee08 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -988,6 +988,7 @@ static int __init snd_pmac_detect(pmac_t *chip)
 		case 0x33:
 		case 0x29:
 		case 0x24:
+		case 0x5c:
 			chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
 			chip->model = PMAC_SNAPPER;
 			chip->can_byte_swap = 0; /* FIXME: check this */

commit 4e6a06eec46067df3c30fe1fbc2e1a7cc37b9678
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Aug 17 11:36:35 2005 +0100

    [PATCH] Stop snd-powermac oopsing on non-pmac hardware.
    
    We shouldn't be assuming that ppc_md.feature_call will be present.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 844d76152ea2..c89e82eb06a6 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -765,7 +765,8 @@ snd_pmac_ctrl_intr(int irq, void *devid, struct pt_regs *regs)
  */
 static void snd_pmac_sound_feature(pmac_t *chip, int enable)
 {
-	ppc_md.feature_call(PMAC_FTR_SOUND_CHIP_ENABLE, chip->node, 0, enable);
+	if (ppc_md.feature_call)
+		ppc_md.feature_call(PMAC_FTR_SOUND_CHIP_ENABLE, chip->node, 0, enable);
 }
 
 /*

commit 77933d7276ee8fa0e2947641941a6f7a100a327b
Author: Jesper Juhl <juhl@dif.dk>
Date:   Wed Jul 27 11:46:09 2005 -0700

    [PATCH] clean up inline static vs static inline
    
    `gcc -W' likes to complain if the static keyword is not at the beginning of
    the declaration.  This patch fixes all remaining occurrences of "inline
    static" up with "static inline" in the entire kernel tree (140 occurrences in
    47 files).
    
    While making this change I came across a few lines with trailing whitespace
    that I also fixed up, I have also added or removed a blank line or two here
    and there, but there are no functional changes in the patch.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 75b8b7423036..844d76152ea2 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -153,7 +153,7 @@ static pmac_stream_t *snd_pmac_get_stream(pmac_t *chip, int stream)
 /*
  * wait while run status is on
  */
-inline static void
+static inline void
 snd_pmac_wait_ack(pmac_stream_t *rec)
 {
 	int timeout = 50000;
@@ -177,7 +177,7 @@ static void snd_pmac_pcm_set_format(pmac_t *chip)
 /*
  * stop the DMA transfer
  */
-inline static void snd_pmac_dma_stop(pmac_stream_t *rec)
+static inline void snd_pmac_dma_stop(pmac_stream_t *rec)
 {
 	out_le32(&rec->dma->control, (RUN|WAKE|FLUSH|PAUSE) << 16);
 	snd_pmac_wait_ack(rec);
@@ -186,7 +186,7 @@ inline static void snd_pmac_dma_stop(pmac_stream_t *rec)
 /*
  * set the command pointer address
  */
-inline static void snd_pmac_dma_set_command(pmac_stream_t *rec, pmac_dbdma_t *cmd)
+static inline void snd_pmac_dma_set_command(pmac_stream_t *rec, pmac_dbdma_t *cmd)
 {
 	out_le32(&rec->dma->cmdptr, cmd->addr);
 }
@@ -194,7 +194,7 @@ inline static void snd_pmac_dma_set_command(pmac_stream_t *rec, pmac_dbdma_t *cm
 /*
  * start the DMA
  */
-inline static void snd_pmac_dma_run(pmac_stream_t *rec, int status)
+static inline void snd_pmac_dma_run(pmac_stream_t *rec, int status)
 {
 	out_le32(&rec->dma->control, status | (status << 16));
 }

commit 8c8709334cec803368a432a33e0f2e116d48fe07
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jun 27 14:36:34 2005 -0700

    [PATCH] ppc32: Remove CONFIG_PMAC_PBOOK
    
    This patch removes CONFIG_PMAC_PBOOK (PowerBook support).  This is now
    split into CONFIG_PMAC_MEDIABAY for the actual hotswap bay that some
    powerbooks have, CONFIG_PM for power management related code, and just left
    out of any CONFIG_* option for some generally useful stuff that can be used
    on non-laptops as well.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 080ef3928465..75b8b7423036 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -36,7 +36,7 @@
 #include <asm/pci-bridge.h>
 
 
-#if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)
+#ifdef CONFIG_PM
 static int snd_pmac_register_sleep_notifier(pmac_t *chip);
 static int snd_pmac_unregister_sleep_notifier(pmac_t *chip);
 static int snd_pmac_suspend(snd_card_t *card, pm_message_t state);
@@ -782,7 +782,7 @@ static int snd_pmac_free(pmac_t *chip)
 	}
 
 	snd_pmac_sound_feature(chip, 0);
-#if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)
+#ifdef CONFIG_PM
 	snd_pmac_unregister_sleep_notifier(chip);
 #endif
 
@@ -1292,7 +1292,7 @@ int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)
 	/* Reset dbdma channels */
 	snd_pmac_dbdma_reset(chip);
 
-#if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)
+#ifdef CONFIG_PM
 	/* add sleep notifier */
 	if (! snd_pmac_register_sleep_notifier(chip))
 		snd_card_set_pm_callback(chip->card, snd_pmac_suspend, snd_pmac_resume, chip);
@@ -1316,7 +1316,7 @@ int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)
  * sleep notify for powerbook
  */
 
-#if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)
+#ifdef CONFIG_PM
 
 /*
  * Save state when going to sleep, restore it afterwards.
@@ -1414,4 +1414,5 @@ static int snd_pmac_unregister_sleep_notifier(pmac_t *chip)
 	return 0;
 }
 
-#endif /* CONFIG_PM && CONFIG_PMAC_PBOOK */
+#endif /* CONFIG_PM */
+

commit 5218064c885af5c49e380d09d54f3cc86891a580
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed May 18 16:31:51 2005 +0200

    [ALSA] ppc32: Fix Alsa PowerMac driver on old machines
    
    PPC PMAC driver
    The g5 support code broke some earlier models unfortunately as those
    bail out early from the detect function, before the point where I added
    the code to locate the PCI device for use with DMA allocations.
    
    This patch fixes it.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 32d94754acf8..080ef3928465 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -876,7 +876,7 @@ static void __init detect_byte_swap(pmac_t *chip)
  */
 static int __init snd_pmac_detect(pmac_t *chip)
 {
-	struct device_node *sound;
+	struct device_node *sound = NULL;
 	unsigned int *prop, l;
 	struct macio_chip* macio;
 
@@ -906,20 +906,22 @@ static int __init snd_pmac_detect(pmac_t *chip)
 		chip->is_pbook_G3 = 1;
 	chip->node = find_devices("awacs");
 	if (chip->node)
-		return 0; /* ok */
+		sound = chip->node;
 
 	/*
 	 * powermac G3 models have a node called "davbus"
 	 * with a child called "sound".
 	 */
-	chip->node = find_devices("davbus");
+	if (!chip->node)
+		chip->node = find_devices("davbus");
 	/*
 	 * if we didn't find a davbus device, try 'i2s-a' since
 	 * this seems to be what iBooks have
 	 */
 	if (! chip->node) {
 		chip->node = find_devices("i2s-a");
-		if (chip->node && chip->node->parent && chip->node->parent->parent) {
+		if (chip->node && chip->node->parent &&
+		    chip->node->parent->parent) {
 			if (device_is_compatible(chip->node->parent->parent,
 						 "K2-Keylargo"))
 				chip->is_k2 = 1;
@@ -928,9 +930,11 @@ static int __init snd_pmac_detect(pmac_t *chip)
 	if (! chip->node)
 		return -ENODEV;
 
-	sound = find_devices("sound");
-	while (sound && sound->parent != chip->node)
-		sound = sound->next;
+	if (!sound) {
+		sound = find_devices("sound");
+		while (sound && sound->parent != chip->node)
+			sound = sound->next;
+	}
 	if (! sound)
 		return -ENODEV;
 	prop = (unsigned int *) get_property(sound, "sub-frame", NULL);
@@ -1019,7 +1023,8 @@ static int __init snd_pmac_detect(pmac_t *chip)
 		}
 	}
 	if (chip->pdev == NULL)
-		printk(KERN_WARNING "snd-powermac: can't locate macio PCI device !\n");
+		printk(KERN_WARNING "snd-powermac: can't locate macio PCI"
+		       " device !\n");
 
 	detect_byte_swap(chip);
 
@@ -1027,7 +1032,8 @@ static int __init snd_pmac_detect(pmac_t *chip)
 	   are available */
 	prop = (unsigned int *) get_property(sound, "sample-rates", &l);
 	if (! prop)
-		prop = (unsigned int *) get_property(sound, "output-frame-rates", &l);
+		prop = (unsigned int *) get_property(sound,
+						     "output-frame-rates", &l);
 	if (prop) {
 		int i;
 		chip->freqs_ok = 0;
@@ -1054,7 +1060,8 @@ static int __init snd_pmac_detect(pmac_t *chip)
 /*
  * exported - boolean info callbacks for ease of programming
  */
-int snd_pmac_boolean_stereo_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+int snd_pmac_boolean_stereo_info(snd_kcontrol_t *kcontrol,
+				 snd_ctl_elem_info_t *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 2;
@@ -1063,7 +1070,8 @@ int snd_pmac_boolean_stereo_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *
 	return 0;
 }
 
-int snd_pmac_boolean_mono_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+int snd_pmac_boolean_mono_info(snd_kcontrol_t *kcontrol,
+			       snd_ctl_elem_info_t *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;

commit 1f7b49d042abfbda71f41b8aff6e1bf7685c1f00
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sun May 1 08:58:43 2005 -0700

    [PATCH] ppc32: add sound support for Mac Mini
    
    This patch applies on top of my previous g5 related sound patches and adds
    support for the Mac Mini to the PowerMac Alsa driver.
    
    However, I haven't found any kind of HW support for volume control on this
    machine.  If it exist, it's well hidden.  That means that you probably want
    to make sure you use software with the ability to do soft volume control,
    or use Alsa 0.9 pre-release with the softvol plugin.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 3bf5f069a03d..32d94754acf8 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -986,7 +986,13 @@ static int __init snd_pmac_detect(pmac_t *chip)
 			chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
 			chip->model = PMAC_SNAPPER;
 			chip->can_byte_swap = 0; /* FIXME: check this */
-			chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
+			chip->control_mask = MASK_IEPC | 0x11;/* disable IEE */
+			break;
+		case 0x3a:
+			chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
+			chip->model = PMAC_TOONIE;
+			chip->can_byte_swap = 0; /* FIXME: check this */
+			chip->control_mask = MASK_IEPC | 0x11;/* disable IEE */
 			break;
 		}
 	}

commit 7bbd827750e630003896c96d0212962276ee5d91
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sat Apr 16 15:24:32 2005 -0700

    [PATCH] ppc64: very basic desktop g5 sound support
    
    This patch hacks the current PowerMac Alsa driver to add some basic support
    of analog sound output to some desktop G5s.  It has severe limitations
    though:
    
     - Only 44100Khz 16 bits
     - Only work on G5 models using a TAS3004 analog code, that is early
       single CPU desktops and all dual CPU desktops at this date, but none
       of the more recent ones like iMac G5.
     - It does analog only, no digital/SPDIF support at all, no native
       AC3 support
    
    Better support would require a complete rewrite of the driver (which I am
    working on, but don't hold your breath), to properly support the diversity
    of apple sound HW setup, including dual codecs, several i2s busses, all the
    new codecs used in the new machines, proper clock switching with digital,
    etc etc etc...
    
    This patch applies on top of the other PowerMac sound patches I posted in
    the past couple of days (new powerbook support and sleep fixes).
    
    Note: This is a FAQ entry for PowerMac sound support with TI codecs: They
    have a feature called "DRC" which is automatically enabled for the internal
    speaker (at least when auto mute control is enabled) which will cause your
    sound to fade out to nothing after half a second of playback if you don't
    set a proper "DRC Range" in the mixer.  So if you have a problem like that,
    check alsamixer and raise your DRC Range to something reasonable.
    
    Note2: This patch will also add auto-mute of the speaker when line-out jack
    is used on some earlier desktop G4s (and on the G5) in addition to the
    headphone jack.  If that behaviour isn't what you want, just disable
    auto-muting and use the manual mute controls in alsamixer.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index f9a9601769aa..3bf5f069a03d 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -27,14 +27,13 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/dma-mapping.h>
 #include <sound/core.h>
 #include "pmac.h"
 #include <sound/pcm_params.h>
-#ifdef CONFIG_PPC_HAS_FEATURE_CALLS
 #include <asm/pmac_feature.h>
-#else
-#include <asm/feature.h>
-#endif
+#include <asm/pci-bridge.h>
 
 
 #if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)
@@ -57,22 +56,29 @@ static int tumbler_freqs[1] = {
 /*
  * allocate DBDMA command arrays
  */
-static int snd_pmac_dbdma_alloc(pmac_dbdma_t *rec, int size)
+static int snd_pmac_dbdma_alloc(pmac_t *chip, pmac_dbdma_t *rec, int size)
 {
-	rec->space = kmalloc(sizeof(struct dbdma_cmd) * (size + 1), GFP_KERNEL);
+	unsigned int rsize = sizeof(struct dbdma_cmd) * (size + 1);
+
+	rec->space = dma_alloc_coherent(&chip->pdev->dev, rsize,
+					&rec->dma_base, GFP_KERNEL);
 	if (rec->space == NULL)
 		return -ENOMEM;
 	rec->size = size;
-	memset(rec->space, 0, sizeof(struct dbdma_cmd) * (size + 1));
+	memset(rec->space, 0, rsize);
 	rec->cmds = (void __iomem *)DBDMA_ALIGN(rec->space);
-	rec->addr = virt_to_bus(rec->cmds);
+	rec->addr = rec->dma_base + (unsigned long)((char *)rec->cmds - (char *)rec->space);
+
 	return 0;
 }
 
-static void snd_pmac_dbdma_free(pmac_dbdma_t *rec)
+static void snd_pmac_dbdma_free(pmac_t *chip, pmac_dbdma_t *rec)
 {
-	if (rec)
-		kfree(rec->space);
+	if (rec) {
+		unsigned int rsize = sizeof(struct dbdma_cmd) * (rec->size + 1);
+
+		dma_free_coherent(&chip->pdev->dev, rsize, rec->space, rec->dma_base);
+	}
 }
 
 
@@ -237,7 +243,7 @@ static int snd_pmac_pcm_prepare(pmac_t *chip, pmac_stream_t *rec, snd_pcm_substr
 	/* continuous DMA memory type doesn't provide the physical address,
 	 * so we need to resolve the address here...
 	 */
-	offset = virt_to_bus(runtime->dma_area);
+	offset = runtime->dma_addr;
 	for (i = 0, cp = rec->cmd.cmds; i < rec->nperiods; i++, cp++) {
 		st_le32(&cp->phy_addr, offset);
 		st_le16(&cp->req_count, rec->period_size);
@@ -664,8 +670,8 @@ int __init snd_pmac_pcm_new(pmac_t *chip)
 	chip->capture.cur_freqs = chip->freqs_ok;
 
 	/* preallocate 64k buffer */
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS, 
-					      snd_dma_continuous_data(GFP_KERNEL),
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      &chip->pdev->dev,
 					      64 * 1024, 64 * 1024);
 
 	return 0;
@@ -757,28 +763,10 @@ snd_pmac_ctrl_intr(int irq, void *devid, struct pt_regs *regs)
 /*
  * a wrapper to feature call for compatibility
  */
-#if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)
 static void snd_pmac_sound_feature(pmac_t *chip, int enable)
 {
-#ifdef CONFIG_PPC_HAS_FEATURE_CALLS
 	ppc_md.feature_call(PMAC_FTR_SOUND_CHIP_ENABLE, chip->node, 0, enable);
-#else
-	if (chip->is_pbook_G3) {
-		pmu_suspend();
-		feature_clear(chip->node, FEATURE_Sound_power);
-		feature_clear(chip->node, FEATURE_Sound_CLK_enable);
-		big_mdelay(1000); /* XXX */
-		pmu_resume();
-	}
-	if (chip->is_pbook_3400) {
-		feature_set(chip->node, FEATURE_IOBUS_enable);
-		udelay(10);
-	}
-#endif
 }
-#else /* CONFIG_PM && CONFIG_PMAC_PBOOK */
-#define snd_pmac_sound_feature(chip,enable) /**/
-#endif /* CONFIG_PM && CONFIG_PMAC_PBOOK */
 
 /*
  * release resources
@@ -786,8 +774,6 @@ static void snd_pmac_sound_feature(pmac_t *chip, int enable)
 
 static int snd_pmac_free(pmac_t *chip)
 {
-	int i;
-
 	/* stop sounds */
 	if (chip->initialized) {
 		snd_pmac_dbdma_reset(chip);
@@ -813,9 +799,9 @@ static int snd_pmac_free(pmac_t *chip)
 		free_irq(chip->tx_irq, (void*)chip);
 	if (chip->rx_irq >= 0)
 		free_irq(chip->rx_irq, (void*)chip);
-	snd_pmac_dbdma_free(&chip->playback.cmd);
-	snd_pmac_dbdma_free(&chip->capture.cmd);
-	snd_pmac_dbdma_free(&chip->extra_dma);
+	snd_pmac_dbdma_free(chip, &chip->playback.cmd);
+	snd_pmac_dbdma_free(chip, &chip->capture.cmd);
+	snd_pmac_dbdma_free(chip, &chip->extra_dma);
 	if (chip->macio_base)
 		iounmap(chip->macio_base);
 	if (chip->latch_base)
@@ -826,12 +812,23 @@ static int snd_pmac_free(pmac_t *chip)
 		iounmap(chip->playback.dma);
 	if (chip->capture.dma)
 		iounmap(chip->capture.dma);
+#ifndef CONFIG_PPC64
 	if (chip->node) {
+		int i;
+
 		for (i = 0; i < 3; i++) {
-			if (chip->of_requested & (1 << i))
-				release_OF_resource(chip->node, i);
+			if (chip->of_requested & (1 << i)) {
+				if (chip->is_k2)
+					release_OF_resource(chip->node->parent,
+							    i);
+				else
+					release_OF_resource(chip->node, i);
+			}
 		}
 	}
+#endif /* CONFIG_PPC64 */
+	if (chip->pdev)
+		pci_dev_put(chip->pdev);
 	kfree(chip);
 	return 0;
 }
@@ -881,6 +878,8 @@ static int __init snd_pmac_detect(pmac_t *chip)
 {
 	struct device_node *sound;
 	unsigned int *prop, l;
+	struct macio_chip* macio;
+
 	u32 layout_id = 0;
 
 	if (_machine != _MACH_Pmac)
@@ -918,10 +917,17 @@ static int __init snd_pmac_detect(pmac_t *chip)
 	 * if we didn't find a davbus device, try 'i2s-a' since
 	 * this seems to be what iBooks have
 	 */
-	if (! chip->node)
+	if (! chip->node) {
 		chip->node = find_devices("i2s-a");
+		if (chip->node && chip->node->parent && chip->node->parent->parent) {
+			if (device_is_compatible(chip->node->parent->parent,
+						 "K2-Keylargo"))
+				chip->is_k2 = 1;
+		}
+	}
 	if (! chip->node)
 		return -ENODEV;
+
 	sound = find_devices("sound");
 	while (sound && sound->parent != chip->node)
 		sound = sound->next;
@@ -966,7 +972,8 @@ static int __init snd_pmac_detect(pmac_t *chip)
 		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
 	}
 	if (device_is_compatible(sound, "AOAKeylargo") ||
-	    device_is_compatible(sound, "AOAbase")) {
+	    device_is_compatible(sound, "AOAbase") ||
+	    device_is_compatible(sound, "AOAK2")) {
 		/* For now, only support very basic TAS3004 based machines with
 		 * single frequency until proper i2s control is implemented
 		 */
@@ -975,6 +982,7 @@ static int __init snd_pmac_detect(pmac_t *chip)
 		case 0x46:
 		case 0x33:
 		case 0x29:
+		case 0x24:
 			chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
 			chip->model = PMAC_SNAPPER;
 			chip->can_byte_swap = 0; /* FIXME: check this */
@@ -987,6 +995,26 @@ static int __init snd_pmac_detect(pmac_t *chip)
 		chip->device_id = *prop;
 	chip->has_iic = (find_devices("perch") != NULL);
 
+	/* We need the PCI device for DMA allocations, let's use a crude method
+	 * for now ...
+	 */
+	macio = macio_find(chip->node, macio_unknown);
+	if (macio == NULL)
+		printk(KERN_WARNING "snd-powermac: can't locate macio !\n");
+	else {
+		struct pci_dev *pdev = NULL;
+
+		for_each_pci_dev(pdev) {
+			struct device_node *np = pci_device_to_OF_node(pdev);
+			if (np && np == macio->of_node) {
+				chip->pdev = pdev;
+				break;
+			}
+		}
+	}
+	if (chip->pdev == NULL)
+		printk(KERN_WARNING "snd-powermac: can't locate macio PCI device !\n");
+
 	detect_byte_swap(chip);
 
 	/* look for a property saying what sample rates
@@ -1091,8 +1119,10 @@ int __init snd_pmac_add_automute(pmac_t *chip)
 	int err;
 	chip->auto_mute = 1;
 	err = snd_ctl_add(chip->card, snd_ctl_new1(&auto_mute_controls[0], chip));
-	if (err < 0)
+	if (err < 0) {
+		printk(KERN_ERR "snd-powermac: Failed to add automute control\n");
 		return err;
+	}
 	chip->hp_detect_ctl = snd_ctl_new1(&auto_mute_controls[1], chip);
 	return snd_ctl_add(chip->card, chip->hp_detect_ctl);
 }
@@ -1106,6 +1136,7 @@ int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)
 	pmac_t *chip;
 	struct device_node *np;
 	int i, err;
+	unsigned long ctrl_addr, txdma_addr, rxdma_addr;
 	static snd_device_ops_t ops = {
 		.dev_free =	snd_pmac_dev_free,
 	};
@@ -1127,32 +1158,59 @@ int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)
 	if ((err = snd_pmac_detect(chip)) < 0)
 		goto __error;
 
-	if (snd_pmac_dbdma_alloc(&chip->playback.cmd, PMAC_MAX_FRAGS + 1) < 0 ||
-	    snd_pmac_dbdma_alloc(&chip->capture.cmd, PMAC_MAX_FRAGS + 1) < 0 ||
-	    snd_pmac_dbdma_alloc(&chip->extra_dma, 2) < 0) {
+	if (snd_pmac_dbdma_alloc(chip, &chip->playback.cmd, PMAC_MAX_FRAGS + 1) < 0 ||
+	    snd_pmac_dbdma_alloc(chip, &chip->capture.cmd, PMAC_MAX_FRAGS + 1) < 0 ||
+	    snd_pmac_dbdma_alloc(chip, &chip->extra_dma, 2) < 0) {
 		err = -ENOMEM;
 		goto __error;
 	}
 
 	np = chip->node;
-	if (np->n_addrs < 3 || np->n_intrs < 3) {
-		err = -ENODEV;
-		goto __error;
-	}
+	if (chip->is_k2) {
+		if (np->parent->n_addrs < 2 || np->n_intrs < 3) {
+			err = -ENODEV;
+			goto __error;
+		}
+		for (i = 0; i < 2; i++) {
+#ifndef CONFIG_PPC64
+			static char *name[2] = { "- Control", "- DMA" };
+			if (! request_OF_resource(np->parent, i, name[i])) {
+				snd_printk(KERN_ERR "pmac: can't request resource %d!\n", i);
+				err = -ENODEV;
+				goto __error;
+			}
+			chip->of_requested |= (1 << i);
+#endif /* CONFIG_PPC64 */
+			ctrl_addr = np->parent->addrs[0].address;
+			txdma_addr = np->parent->addrs[1].address;
+			rxdma_addr = txdma_addr + 0x100;
+		}
 
-	for (i = 0; i < 3; i++) {
-		static char *name[3] = { NULL, "- Tx DMA", "- Rx DMA" };
-		if (! request_OF_resource(np, i, name[i])) {
-			snd_printk(KERN_ERR "pmac: can't request resource %d!\n", i);
+	} else {
+		if (np->n_addrs < 3 || np->n_intrs < 3) {
 			err = -ENODEV;
 			goto __error;
 		}
-		chip->of_requested |= (1 << i);
+
+		for (i = 0; i < 3; i++) {
+#ifndef CONFIG_PPC64
+			static char *name[3] = { "- Control", "- Tx DMA", "- Rx DMA" };
+			if (! request_OF_resource(np, i, name[i])) {
+				snd_printk(KERN_ERR "pmac: can't request resource %d!\n", i);
+				err = -ENODEV;
+				goto __error;
+			}
+			chip->of_requested |= (1 << i);
+#endif /* CONFIG_PPC64 */
+			ctrl_addr = np->addrs[0].address;
+			txdma_addr = np->addrs[1].address;
+			rxdma_addr = np->addrs[2].address;
+		}
 	}
 
-	chip->awacs = ioremap(np->addrs[0].address, 0x1000);
-	chip->playback.dma = ioremap(np->addrs[1].address, 0x100);
-	chip->capture.dma = ioremap(np->addrs[2].address, 0x100);
+	chip->awacs = ioremap(ctrl_addr, 0x1000);
+	chip->playback.dma = ioremap(txdma_addr, 0x100);
+	chip->capture.dma = ioremap(rxdma_addr, 0x100);
 	if (chip->model <= PMAC_BURGUNDY) {
 		if (request_irq(np->intrs[0].line, snd_pmac_ctrl_intr, 0,
 				"PMac", (void*)chip)) {
@@ -1180,7 +1238,8 @@ int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)
 	snd_pmac_sound_feature(chip, 1);
 
 	/* reset */
-	out_le32(&chip->awacs->control, 0x11);
+	if (chip->model == PMAC_AWACS)
+		out_le32(&chip->awacs->control, 0x11);
 
 	/* Powerbooks have odd ways of enabling inputs such as
 	   an expansion-bay CD or sound from an internal modem
@@ -1232,6 +1291,8 @@ int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)
 	return 0;
 
  __error:
+	if (chip->pdev)
+		pci_dev_put(chip->pdev);
 	snd_pmac_free(chip);
 	return err;
 }

commit b75550e1bc6b3b2c80b628e68628fca015634071
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sat Apr 16 15:24:31 2005 -0700

    [PATCH] pmac: sound support for latest laptops
    
    This patch hacks the current Alsa snd-powermac driver to add support for
    recent machine models with the tas3004 chip, that is basically new laptop
    models.  The Mac Mini is _NOT_ yet supported by this patch (soon soon ...).
     The G5s (iMac or Desktop) will need the rewritten sound driver on which
    I'm working on (I _might_ get a hack for analog only on some G5s on the
    current driver, but no promise).
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
index 6c4ed90f490e..f9a9601769aa 100644
--- a/sound/ppc/pmac.c
+++ b/sound/ppc/pmac.c
@@ -881,6 +881,7 @@ static int __init snd_pmac_detect(pmac_t *chip)
 {
 	struct device_node *sound;
 	unsigned int *prop, l;
+	u32 layout_id = 0;
 
 	if (_machine != _MACH_Pmac)
 		return -ENODEV;
@@ -929,6 +930,9 @@ static int __init snd_pmac_detect(pmac_t *chip)
 	prop = (unsigned int *) get_property(sound, "sub-frame", NULL);
 	if (prop && *prop < 16)
 		chip->subframe = *prop;
+	prop = (unsigned int *) get_property(sound, "layout-id", NULL);
+	if (prop)
+		layout_id = *prop;
 	/* This should be verified on older screamers */
 	if (device_is_compatible(sound, "screamer")) {
 		chip->model = PMAC_SCREAMER;
@@ -961,12 +965,22 @@ static int __init snd_pmac_detect(pmac_t *chip)
 		chip->freq_table = tumbler_freqs;
 		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
 	}
-	if (device_is_compatible(sound, "AOAKeylargo")) {
-		/* Seems to support the stock AWACS frequencies, but has
-		   a snapper mixer */
-		chip->model = PMAC_SNAPPER;
-		// chip->can_byte_swap = 0; /* FIXME: check this */
-		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
+	if (device_is_compatible(sound, "AOAKeylargo") ||
+	    device_is_compatible(sound, "AOAbase")) {
+		/* For now, only support very basic TAS3004 based machines with
+		 * single frequency until proper i2s control is implemented
+		 */
+		switch(layout_id) {
+		case 0x48:
+		case 0x46:
+		case 0x33:
+		case 0x29:
+			chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
+			chip->model = PMAC_SNAPPER;
+			chip->can_byte_swap = 0; /* FIXME: check this */
+			chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
+			break;
+		}
 	}
 	prop = (unsigned int *)get_property(sound, "device-id", NULL);
 	if (prop)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/ppc/pmac.c b/sound/ppc/pmac.c
new file mode 100644
index 000000000000..6c4ed90f490e
--- /dev/null
+++ b/sound/ppc/pmac.c
@@ -0,0 +1,1328 @@
+/*
+ * PMac DBDMA lowlevel functions
+ *
+ * Copyright (c) by Takashi Iwai <tiwai@suse.de>
+ * code based on dmasound.c.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <sound/core.h>
+#include "pmac.h"
+#include <sound/pcm_params.h>
+#ifdef CONFIG_PPC_HAS_FEATURE_CALLS
+#include <asm/pmac_feature.h>
+#else
+#include <asm/feature.h>
+#endif
+
+
+#if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)
+static int snd_pmac_register_sleep_notifier(pmac_t *chip);
+static int snd_pmac_unregister_sleep_notifier(pmac_t *chip);
+static int snd_pmac_suspend(snd_card_t *card, pm_message_t state);
+static int snd_pmac_resume(snd_card_t *card);
+#endif
+
+
+/* fixed frequency table for awacs, screamer, burgundy, DACA (44100 max) */
+static int awacs_freqs[8] = {
+	44100, 29400, 22050, 17640, 14700, 11025, 8820, 7350
+};
+/* fixed frequency table for tumbler */
+static int tumbler_freqs[1] = {
+	44100
+};
+
+/*
+ * allocate DBDMA command arrays
+ */
+static int snd_pmac_dbdma_alloc(pmac_dbdma_t *rec, int size)
+{
+	rec->space = kmalloc(sizeof(struct dbdma_cmd) * (size + 1), GFP_KERNEL);
+	if (rec->space == NULL)
+		return -ENOMEM;
+	rec->size = size;
+	memset(rec->space, 0, sizeof(struct dbdma_cmd) * (size + 1));
+	rec->cmds = (void __iomem *)DBDMA_ALIGN(rec->space);
+	rec->addr = virt_to_bus(rec->cmds);
+	return 0;
+}
+
+static void snd_pmac_dbdma_free(pmac_dbdma_t *rec)
+{
+	if (rec)
+		kfree(rec->space);
+}
+
+
+/*
+ * pcm stuff
+ */
+
+/*
+ * look up frequency table
+ */
+
+unsigned int snd_pmac_rate_index(pmac_t *chip, pmac_stream_t *rec, unsigned int rate)
+{
+	int i, ok, found;
+
+	ok = rec->cur_freqs;
+	if (rate > chip->freq_table[0])
+		return 0;
+	found = 0;
+	for (i = 0; i < chip->num_freqs; i++, ok >>= 1) {
+		if (! (ok & 1)) continue;
+		found = i;
+		if (rate >= chip->freq_table[i])
+			break;
+	}
+	return found;
+}
+
+/*
+ * check whether another stream is active
+ */
+static inline int another_stream(int stream)
+{
+	return (stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+		SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
+}
+
+/*
+ * allocate buffers
+ */
+static int snd_pmac_pcm_hw_params(snd_pcm_substream_t *subs,
+				  snd_pcm_hw_params_t *hw_params)
+{
+	return snd_pcm_lib_malloc_pages(subs, params_buffer_bytes(hw_params));
+}
+
+/*
+ * release buffers
+ */
+static int snd_pmac_pcm_hw_free(snd_pcm_substream_t *subs)
+{
+	snd_pcm_lib_free_pages(subs);
+	return 0;
+}
+
+/*
+ * get a stream of the opposite direction
+ */
+static pmac_stream_t *snd_pmac_get_stream(pmac_t *chip, int stream)
+{
+	switch (stream) {
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		return &chip->playback;
+	case SNDRV_PCM_STREAM_CAPTURE:
+		return &chip->capture;
+	default:
+		snd_BUG();
+		return NULL;
+	}
+}
+
+/*
+ * wait while run status is on
+ */
+inline static void
+snd_pmac_wait_ack(pmac_stream_t *rec)
+{
+	int timeout = 50000;
+	while ((in_le32(&rec->dma->status) & RUN) && timeout-- > 0)
+		udelay(1);
+}
+
+/*
+ * set the format and rate to the chip.
+ * call the lowlevel function if defined (e.g. for AWACS).
+ */
+static void snd_pmac_pcm_set_format(pmac_t *chip)
+{
+	/* set up frequency and format */
+	out_le32(&chip->awacs->control, chip->control_mask | (chip->rate_index << 8));
+	out_le32(&chip->awacs->byteswap, chip->format == SNDRV_PCM_FORMAT_S16_LE ? 1 : 0);
+	if (chip->set_format)
+		chip->set_format(chip);
+}
+
+/*
+ * stop the DMA transfer
+ */
+inline static void snd_pmac_dma_stop(pmac_stream_t *rec)
+{
+	out_le32(&rec->dma->control, (RUN|WAKE|FLUSH|PAUSE) << 16);
+	snd_pmac_wait_ack(rec);
+}
+
+/*
+ * set the command pointer address
+ */
+inline static void snd_pmac_dma_set_command(pmac_stream_t *rec, pmac_dbdma_t *cmd)
+{
+	out_le32(&rec->dma->cmdptr, cmd->addr);
+}
+
+/*
+ * start the DMA
+ */
+inline static void snd_pmac_dma_run(pmac_stream_t *rec, int status)
+{
+	out_le32(&rec->dma->control, status | (status << 16));
+}
+
+
+/*
+ * prepare playback/capture stream
+ */
+static int snd_pmac_pcm_prepare(pmac_t *chip, pmac_stream_t *rec, snd_pcm_substream_t *subs)
+{
+	int i;
+	volatile struct dbdma_cmd __iomem *cp;
+	snd_pcm_runtime_t *runtime = subs->runtime;
+	int rate_index;
+	long offset;
+	pmac_stream_t *astr;
+	
+	rec->dma_size = snd_pcm_lib_buffer_bytes(subs);
+	rec->period_size = snd_pcm_lib_period_bytes(subs);
+	rec->nperiods = rec->dma_size / rec->period_size;
+	rec->cur_period = 0;
+	rate_index = snd_pmac_rate_index(chip, rec, runtime->rate);
+
+	/* set up constraints */
+	astr = snd_pmac_get_stream(chip, another_stream(rec->stream));
+	snd_runtime_check(astr, return -EINVAL);
+	astr->cur_freqs = 1 << rate_index;
+	astr->cur_formats = 1 << runtime->format;
+	chip->rate_index = rate_index;
+	chip->format = runtime->format;
+
+	/* We really want to execute a DMA stop command, after the AWACS
+	 * is initialized.
+	 * For reasons I don't understand, it stops the hissing noise
+	 * common to many PowerBook G3 systems and random noise otherwise
+	 * captured on iBook2's about every third time. -ReneR
+	 */
+	spin_lock_irq(&chip->reg_lock);
+	snd_pmac_dma_stop(rec);
+	st_le16(&chip->extra_dma.cmds->command, DBDMA_STOP);
+	snd_pmac_dma_set_command(rec, &chip->extra_dma);
+	snd_pmac_dma_run(rec, RUN);
+	spin_unlock_irq(&chip->reg_lock);
+	mdelay(5);
+	spin_lock_irq(&chip->reg_lock);
+	/* continuous DMA memory type doesn't provide the physical address,
+	 * so we need to resolve the address here...
+	 */
+	offset = virt_to_bus(runtime->dma_area);
+	for (i = 0, cp = rec->cmd.cmds; i < rec->nperiods; i++, cp++) {
+		st_le32(&cp->phy_addr, offset);
+		st_le16(&cp->req_count, rec->period_size);
+		/*st_le16(&cp->res_count, 0);*/
+		st_le16(&cp->xfer_status, 0);
+		offset += rec->period_size;
+	}
+	/* make loop */
+	st_le16(&cp->command, DBDMA_NOP + BR_ALWAYS);
+	st_le32(&cp->cmd_dep, rec->cmd.addr);
+
+	snd_pmac_dma_stop(rec);
+	snd_pmac_dma_set_command(rec, &rec->cmd);
+	spin_unlock_irq(&chip->reg_lock);
+
+	return 0;
+}
+
+
+/*
+ * PCM trigger/stop
+ */
+static int snd_pmac_pcm_trigger(pmac_t *chip, pmac_stream_t *rec,
+				snd_pcm_substream_t *subs, int cmd)
+{
+	volatile struct dbdma_cmd __iomem *cp;
+	int i, command;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		if (rec->running)
+			return -EBUSY;
+		command = (subs->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+			   OUTPUT_MORE : INPUT_MORE) + INTR_ALWAYS;
+		spin_lock(&chip->reg_lock);
+		snd_pmac_beep_stop(chip);
+		snd_pmac_pcm_set_format(chip);
+		for (i = 0, cp = rec->cmd.cmds; i < rec->nperiods; i++, cp++)
+			out_le16(&cp->command, command);
+		snd_pmac_dma_set_command(rec, &rec->cmd);
+		(void)in_le32(&rec->dma->status);
+		snd_pmac_dma_run(rec, RUN|WAKE);
+		rec->running = 1;
+		spin_unlock(&chip->reg_lock);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		spin_lock(&chip->reg_lock);
+		rec->running = 0;
+		/*printk("stopped!!\n");*/
+		snd_pmac_dma_stop(rec);
+		for (i = 0, cp = rec->cmd.cmds; i < rec->nperiods; i++, cp++)
+			out_le16(&cp->command, DBDMA_STOP);
+		spin_unlock(&chip->reg_lock);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * return the current pointer
+ */
+inline
+static snd_pcm_uframes_t snd_pmac_pcm_pointer(pmac_t *chip, pmac_stream_t *rec,
+					      snd_pcm_substream_t *subs)
+{
+	int count = 0;
+
+#if 1 /* hmm.. how can we get the current dma pointer?? */
+	int stat;
+	volatile struct dbdma_cmd __iomem *cp = &rec->cmd.cmds[rec->cur_period];
+	stat = ld_le16(&cp->xfer_status);
+	if (stat & (ACTIVE|DEAD)) {
+		count = in_le16(&cp->res_count);
+		if (count)
+			count = rec->period_size - count;
+	}
+#endif
+	count += rec->cur_period * rec->period_size;
+	/*printk("pointer=%d\n", count);*/
+	return bytes_to_frames(subs->runtime, count);
+}
+
+/*
+ * playback
+ */
+
+static int snd_pmac_playback_prepare(snd_pcm_substream_t *subs)
+{
+	pmac_t *chip = snd_pcm_substream_chip(subs);
+	return snd_pmac_pcm_prepare(chip, &chip->playback, subs);
+}
+
+static int snd_pmac_playback_trigger(snd_pcm_substream_t *subs,
+				     int cmd)
+{
+	pmac_t *chip = snd_pcm_substream_chip(subs);
+	return snd_pmac_pcm_trigger(chip, &chip->playback, subs, cmd);
+}
+
+static snd_pcm_uframes_t snd_pmac_playback_pointer(snd_pcm_substream_t *subs)
+{
+	pmac_t *chip = snd_pcm_substream_chip(subs);
+	return snd_pmac_pcm_pointer(chip, &chip->playback, subs);
+}
+
+
+/*
+ * capture
+ */
+
+static int snd_pmac_capture_prepare(snd_pcm_substream_t *subs)
+{
+	pmac_t *chip = snd_pcm_substream_chip(subs);
+	return snd_pmac_pcm_prepare(chip, &chip->capture, subs);
+}
+
+static int snd_pmac_capture_trigger(snd_pcm_substream_t *subs,
+				    int cmd)
+{
+	pmac_t *chip = snd_pcm_substream_chip(subs);
+	return snd_pmac_pcm_trigger(chip, &chip->capture, subs, cmd);
+}
+
+static snd_pcm_uframes_t snd_pmac_capture_pointer(snd_pcm_substream_t *subs)
+{
+	pmac_t *chip = snd_pcm_substream_chip(subs);
+	return snd_pmac_pcm_pointer(chip, &chip->capture, subs);
+}
+
+
+/*
+ * update playback/capture pointer from interrupts
+ */
+static void snd_pmac_pcm_update(pmac_t *chip, pmac_stream_t *rec)
+{
+	volatile struct dbdma_cmd __iomem *cp;
+	int c;
+	int stat;
+
+	spin_lock(&chip->reg_lock);
+	if (rec->running) {
+		cp = &rec->cmd.cmds[rec->cur_period];
+		for (c = 0; c < rec->nperiods; c++) { /* at most all fragments */
+			stat = ld_le16(&cp->xfer_status);
+			if (! (stat & ACTIVE))
+				break;
+			/*printk("update frag %d\n", rec->cur_period);*/
+			st_le16(&cp->xfer_status, 0);
+			st_le16(&cp->req_count, rec->period_size);
+			/*st_le16(&cp->res_count, 0);*/
+			rec->cur_period++;
+			if (rec->cur_period >= rec->nperiods) {
+				rec->cur_period = 0;
+				cp = rec->cmd.cmds;
+			} else
+				cp++;
+			spin_unlock(&chip->reg_lock);
+			snd_pcm_period_elapsed(rec->substream);
+			spin_lock(&chip->reg_lock);
+		}
+	}
+	spin_unlock(&chip->reg_lock);
+}
+
+
+/*
+ * hw info
+ */
+
+static snd_pcm_hardware_t snd_pmac_playback =
+{
+	.info =			(SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_MMAP |
+				 SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_RESUME),
+	.formats =		SNDRV_PCM_FMTBIT_S16_BE | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_8000_44100,
+	.rate_min =		7350,
+	.rate_max =		44100,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	131072,
+	.period_bytes_min =	256,
+	.period_bytes_max =	16384,
+	.periods_min =		3,
+	.periods_max =		PMAC_MAX_FRAGS,
+};
+
+static snd_pcm_hardware_t snd_pmac_capture =
+{
+	.info =			(SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_MMAP |
+				 SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_RESUME),
+	.formats =		SNDRV_PCM_FMTBIT_S16_BE | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_8000_44100,
+	.rate_min =		7350,
+	.rate_max =		44100,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	131072,
+	.period_bytes_min =	256,
+	.period_bytes_max =	16384,
+	.periods_min =		3,
+	.periods_max =		PMAC_MAX_FRAGS,
+};
+
+
+#if 0 // NYI
+static int snd_pmac_hw_rule_rate(snd_pcm_hw_params_t *params,
+				 snd_pcm_hw_rule_t *rule)
+{
+	pmac_t *chip = rule->private;
+	pmac_stream_t *rec = snd_pmac_get_stream(chip, rule->deps[0]);
+	int i, freq_table[8], num_freqs;
+
+	snd_runtime_check(rec, return -EINVAL);
+	num_freqs = 0;
+	for (i = chip->num_freqs - 1; i >= 0; i--) {
+		if (rec->cur_freqs & (1 << i))
+			freq_table[num_freqs++] = chip->freq_table[i];
+	}
+
+	return snd_interval_list(hw_param_interval(params, rule->var),
+				 num_freqs, freq_table, 0);
+}
+
+static int snd_pmac_hw_rule_format(snd_pcm_hw_params_t *params,
+				   snd_pcm_hw_rule_t *rule)
+{
+	pmac_t *chip = rule->private;
+	pmac_stream_t *rec = snd_pmac_get_stream(chip, rule->deps[0]);
+
+	snd_runtime_check(rec, return -EINVAL);
+	return snd_mask_refine_set(hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT),
+				   rec->cur_formats);
+}
+#endif // NYI
+
+static int snd_pmac_pcm_open(pmac_t *chip, pmac_stream_t *rec, snd_pcm_substream_t *subs)
+{
+	snd_pcm_runtime_t *runtime = subs->runtime;
+	int i, j, fflags;
+	static int typical_freqs[] = {
+		44100,
+		22050,
+		11025,
+		0,
+	};
+	static int typical_freq_flags[] = {
+		SNDRV_PCM_RATE_44100,
+		SNDRV_PCM_RATE_22050,
+		SNDRV_PCM_RATE_11025,
+		0,
+	};
+
+	/* look up frequency table and fill bit mask */
+	runtime->hw.rates = 0;
+	fflags = chip->freqs_ok;
+	for (i = 0; typical_freqs[i]; i++) {
+		for (j = 0; j < chip->num_freqs; j++) {
+			if ((chip->freqs_ok & (1 << j)) &&
+			    chip->freq_table[j] == typical_freqs[i]) {
+				runtime->hw.rates |= typical_freq_flags[i];
+				fflags &= ~(1 << j);
+				break;
+			}
+		}
+	}
+	if (fflags) /* rest */
+		runtime->hw.rates |= SNDRV_PCM_RATE_KNOT;
+
+	/* check for minimum and maximum rates */
+	for (i = 0; i < chip->num_freqs; i++) {
+		if (chip->freqs_ok & (1 << i)) {
+			runtime->hw.rate_max = chip->freq_table[i];
+			break;
+		}
+	}
+	for (i = chip->num_freqs - 1; i >= 0; i--) {
+		if (chip->freqs_ok & (1 << i)) {
+			runtime->hw.rate_min = chip->freq_table[i];
+			break;
+		}
+	}
+	runtime->hw.formats = chip->formats_ok;
+	if (chip->can_capture) {
+		if (! chip->can_duplex)
+			runtime->hw.info |= SNDRV_PCM_INFO_HALF_DUPLEX;
+		runtime->hw.info |= SNDRV_PCM_INFO_JOINT_DUPLEX;
+	}
+	runtime->private_data = rec;
+	rec->substream = subs;
+
+#if 0 /* FIXME: still under development.. */
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+			    snd_pmac_hw_rule_rate, chip, rec->stream, -1);
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,
+			    snd_pmac_hw_rule_format, chip, rec->stream, -1);
+#endif
+
+	runtime->hw.periods_max = rec->cmd.size - 1;
+
+	if (chip->can_duplex)
+		snd_pcm_set_sync(subs);
+
+	/* constraints to fix choppy sound */
+	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	return 0;
+}
+
+static int snd_pmac_pcm_close(pmac_t *chip, pmac_stream_t *rec, snd_pcm_substream_t *subs)
+{
+	pmac_stream_t *astr;
+
+	snd_pmac_dma_stop(rec);
+
+	astr = snd_pmac_get_stream(chip, another_stream(rec->stream));
+	snd_runtime_check(astr, return -EINVAL);
+
+	/* reset constraints */
+	astr->cur_freqs = chip->freqs_ok;
+	astr->cur_formats = chip->formats_ok;
+	
+	return 0;
+}
+
+static int snd_pmac_playback_open(snd_pcm_substream_t *subs)
+{
+	pmac_t *chip = snd_pcm_substream_chip(subs);
+
+	subs->runtime->hw = snd_pmac_playback;
+	return snd_pmac_pcm_open(chip, &chip->playback, subs);
+}
+
+static int snd_pmac_capture_open(snd_pcm_substream_t *subs)
+{
+	pmac_t *chip = snd_pcm_substream_chip(subs);
+
+	subs->runtime->hw = snd_pmac_capture;
+	return snd_pmac_pcm_open(chip, &chip->capture, subs);
+}
+
+static int snd_pmac_playback_close(snd_pcm_substream_t *subs)
+{
+	pmac_t *chip = snd_pcm_substream_chip(subs);
+
+	return snd_pmac_pcm_close(chip, &chip->playback, subs);
+}
+
+static int snd_pmac_capture_close(snd_pcm_substream_t *subs)
+{
+	pmac_t *chip = snd_pcm_substream_chip(subs);
+
+	return snd_pmac_pcm_close(chip, &chip->capture, subs);
+}
+
+/*
+ */
+
+static snd_pcm_ops_t snd_pmac_playback_ops = {
+	.open =		snd_pmac_playback_open,
+	.close =	snd_pmac_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_pmac_pcm_hw_params,
+	.hw_free =	snd_pmac_pcm_hw_free,
+	.prepare =	snd_pmac_playback_prepare,
+	.trigger =	snd_pmac_playback_trigger,
+	.pointer =	snd_pmac_playback_pointer,
+};
+
+static snd_pcm_ops_t snd_pmac_capture_ops = {
+	.open =		snd_pmac_capture_open,
+	.close =	snd_pmac_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_pmac_pcm_hw_params,
+	.hw_free =	snd_pmac_pcm_hw_free,
+	.prepare =	snd_pmac_capture_prepare,
+	.trigger =	snd_pmac_capture_trigger,
+	.pointer =	snd_pmac_capture_pointer,
+};
+
+static void pmac_pcm_free(snd_pcm_t *pcm)
+{
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+int __init snd_pmac_pcm_new(pmac_t *chip)
+{
+	snd_pcm_t *pcm;
+	int err;
+	int num_captures = 1;
+
+	if (! chip->can_capture)
+		num_captures = 0;
+	err = snd_pcm_new(chip->card, chip->card->driver, 0, 1, num_captures, &pcm);
+	if (err < 0)
+		return err;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_pmac_playback_ops);
+	if (chip->can_capture)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_pmac_capture_ops);
+
+	pcm->private_data = chip;
+	pcm->private_free = pmac_pcm_free;
+	pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
+	strcpy(pcm->name, chip->card->shortname);
+	chip->pcm = pcm;
+
+	chip->formats_ok = SNDRV_PCM_FMTBIT_S16_BE;
+	if (chip->can_byte_swap)
+		chip->formats_ok |= SNDRV_PCM_FMTBIT_S16_LE;
+
+	chip->playback.cur_formats = chip->formats_ok;
+	chip->capture.cur_formats = chip->formats_ok;
+	chip->playback.cur_freqs = chip->freqs_ok;
+	chip->capture.cur_freqs = chip->freqs_ok;
+
+	/* preallocate 64k buffer */
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS, 
+					      snd_dma_continuous_data(GFP_KERNEL),
+					      64 * 1024, 64 * 1024);
+
+	return 0;
+}
+
+
+static void snd_pmac_dbdma_reset(pmac_t *chip)
+{
+	out_le32(&chip->playback.dma->control, (RUN|PAUSE|FLUSH|WAKE|DEAD) << 16);
+	snd_pmac_wait_ack(&chip->playback);
+	out_le32(&chip->capture.dma->control, (RUN|PAUSE|FLUSH|WAKE|DEAD) << 16);
+	snd_pmac_wait_ack(&chip->capture);
+}
+
+
+/*
+ * handling beep
+ */
+void snd_pmac_beep_dma_start(pmac_t *chip, int bytes, unsigned long addr, int speed)
+{
+	pmac_stream_t *rec = &chip->playback;
+
+	snd_pmac_dma_stop(rec);
+	st_le16(&chip->extra_dma.cmds->req_count, bytes);
+	st_le16(&chip->extra_dma.cmds->xfer_status, 0);
+	st_le32(&chip->extra_dma.cmds->cmd_dep, chip->extra_dma.addr);
+	st_le32(&chip->extra_dma.cmds->phy_addr, addr);
+	st_le16(&chip->extra_dma.cmds->command, OUTPUT_MORE + BR_ALWAYS);
+	out_le32(&chip->awacs->control,
+		 (in_le32(&chip->awacs->control) & ~0x1f00)
+		 | (speed << 8));
+	out_le32(&chip->awacs->byteswap, 0);
+	snd_pmac_dma_set_command(rec, &chip->extra_dma);
+	snd_pmac_dma_run(rec, RUN);
+}
+
+void snd_pmac_beep_dma_stop(pmac_t *chip)
+{
+	snd_pmac_dma_stop(&chip->playback);
+	st_le16(&chip->extra_dma.cmds->command, DBDMA_STOP);
+	snd_pmac_pcm_set_format(chip); /* reset format */
+}
+
+
+/*
+ * interrupt handlers
+ */
+static irqreturn_t
+snd_pmac_tx_intr(int irq, void *devid, struct pt_regs *regs)
+{
+	pmac_t *chip = devid;
+	snd_pmac_pcm_update(chip, &chip->playback);
+	return IRQ_HANDLED;
+}
+
+
+static irqreturn_t
+snd_pmac_rx_intr(int irq, void *devid, struct pt_regs *regs)
+{
+	pmac_t *chip = devid;
+	snd_pmac_pcm_update(chip, &chip->capture);
+	return IRQ_HANDLED;
+}
+
+
+static irqreturn_t
+snd_pmac_ctrl_intr(int irq, void *devid, struct pt_regs *regs)
+{
+	pmac_t *chip = devid;
+	int ctrl = in_le32(&chip->awacs->control);
+
+	/*printk("pmac: control interrupt.. 0x%x\n", ctrl);*/
+	if (ctrl & MASK_PORTCHG) {
+		/* do something when headphone is plugged/unplugged? */
+		if (chip->update_automute)
+			chip->update_automute(chip, 1);
+	}
+	if (ctrl & MASK_CNTLERR) {
+		int err = (in_le32(&chip->awacs->codec_stat) & MASK_ERRCODE) >> 16;
+		if (err && chip->model <= PMAC_SCREAMER)
+			snd_printk(KERN_DEBUG "error %x\n", err);
+	}
+	/* Writing 1s to the CNTLERR and PORTCHG bits clears them... */
+	out_le32(&chip->awacs->control, ctrl);
+	return IRQ_HANDLED;
+}
+
+
+/*
+ * a wrapper to feature call for compatibility
+ */
+#if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)
+static void snd_pmac_sound_feature(pmac_t *chip, int enable)
+{
+#ifdef CONFIG_PPC_HAS_FEATURE_CALLS
+	ppc_md.feature_call(PMAC_FTR_SOUND_CHIP_ENABLE, chip->node, 0, enable);
+#else
+	if (chip->is_pbook_G3) {
+		pmu_suspend();
+		feature_clear(chip->node, FEATURE_Sound_power);
+		feature_clear(chip->node, FEATURE_Sound_CLK_enable);
+		big_mdelay(1000); /* XXX */
+		pmu_resume();
+	}
+	if (chip->is_pbook_3400) {
+		feature_set(chip->node, FEATURE_IOBUS_enable);
+		udelay(10);
+	}
+#endif
+}
+#else /* CONFIG_PM && CONFIG_PMAC_PBOOK */
+#define snd_pmac_sound_feature(chip,enable) /**/
+#endif /* CONFIG_PM && CONFIG_PMAC_PBOOK */
+
+/*
+ * release resources
+ */
+
+static int snd_pmac_free(pmac_t *chip)
+{
+	int i;
+
+	/* stop sounds */
+	if (chip->initialized) {
+		snd_pmac_dbdma_reset(chip);
+		/* disable interrupts from awacs interface */
+		out_le32(&chip->awacs->control, in_le32(&chip->awacs->control) & 0xfff);
+	}
+
+	snd_pmac_sound_feature(chip, 0);
+#if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)
+	snd_pmac_unregister_sleep_notifier(chip);
+#endif
+
+	/* clean up mixer if any */
+	if (chip->mixer_free)
+		chip->mixer_free(chip);
+
+	snd_pmac_detach_beep(chip);
+
+	/* release resources */
+	if (chip->irq >= 0)
+		free_irq(chip->irq, (void*)chip);
+	if (chip->tx_irq >= 0)
+		free_irq(chip->tx_irq, (void*)chip);
+	if (chip->rx_irq >= 0)
+		free_irq(chip->rx_irq, (void*)chip);
+	snd_pmac_dbdma_free(&chip->playback.cmd);
+	snd_pmac_dbdma_free(&chip->capture.cmd);
+	snd_pmac_dbdma_free(&chip->extra_dma);
+	if (chip->macio_base)
+		iounmap(chip->macio_base);
+	if (chip->latch_base)
+		iounmap(chip->latch_base);
+	if (chip->awacs)
+		iounmap(chip->awacs);
+	if (chip->playback.dma)
+		iounmap(chip->playback.dma);
+	if (chip->capture.dma)
+		iounmap(chip->capture.dma);
+	if (chip->node) {
+		for (i = 0; i < 3; i++) {
+			if (chip->of_requested & (1 << i))
+				release_OF_resource(chip->node, i);
+		}
+	}
+	kfree(chip);
+	return 0;
+}
+
+
+/*
+ * free the device
+ */
+static int snd_pmac_dev_free(snd_device_t *device)
+{
+	pmac_t *chip = device->device_data;
+	return snd_pmac_free(chip);
+}
+
+
+/*
+ * check the machine support byteswap (little-endian)
+ */
+
+static void __init detect_byte_swap(pmac_t *chip)
+{
+	struct device_node *mio;
+
+	/* if seems that Keylargo can't byte-swap  */
+	for (mio = chip->node->parent; mio; mio = mio->parent) {
+		if (strcmp(mio->name, "mac-io") == 0) {
+			if (device_is_compatible(mio, "Keylargo"))
+				chip->can_byte_swap = 0;
+			break;
+		}
+	}
+
+	/* it seems the Pismo & iBook can't byte-swap in hardware. */
+	if (machine_is_compatible("PowerBook3,1") ||
+	    machine_is_compatible("PowerBook2,1"))
+		chip->can_byte_swap = 0 ;
+
+	if (machine_is_compatible("PowerBook2,1"))
+		chip->can_duplex = 0;
+}
+
+
+/*
+ * detect a sound chip
+ */
+static int __init snd_pmac_detect(pmac_t *chip)
+{
+	struct device_node *sound;
+	unsigned int *prop, l;
+
+	if (_machine != _MACH_Pmac)
+		return -ENODEV;
+
+	chip->subframe = 0;
+	chip->revision = 0;
+	chip->freqs_ok = 0xff; /* all ok */
+	chip->model = PMAC_AWACS;
+	chip->can_byte_swap = 1;
+	chip->can_duplex = 1;
+	chip->can_capture = 1;
+	chip->num_freqs = ARRAY_SIZE(awacs_freqs);
+	chip->freq_table = awacs_freqs;
+
+	chip->control_mask = MASK_IEPC | MASK_IEE | 0x11; /* default */
+
+	/* check machine type */
+	if (machine_is_compatible("AAPL,3400/2400")
+	    || machine_is_compatible("AAPL,3500"))
+		chip->is_pbook_3400 = 1;
+	else if (machine_is_compatible("PowerBook1,1")
+		 || machine_is_compatible("AAPL,PowerBook1998"))
+		chip->is_pbook_G3 = 1;
+	chip->node = find_devices("awacs");
+	if (chip->node)
+		return 0; /* ok */
+
+	/*
+	 * powermac G3 models have a node called "davbus"
+	 * with a child called "sound".
+	 */
+	chip->node = find_devices("davbus");
+	/*
+	 * if we didn't find a davbus device, try 'i2s-a' since
+	 * this seems to be what iBooks have
+	 */
+	if (! chip->node)
+		chip->node = find_devices("i2s-a");
+	if (! chip->node)
+		return -ENODEV;
+	sound = find_devices("sound");
+	while (sound && sound->parent != chip->node)
+		sound = sound->next;
+	if (! sound)
+		return -ENODEV;
+	prop = (unsigned int *) get_property(sound, "sub-frame", NULL);
+	if (prop && *prop < 16)
+		chip->subframe = *prop;
+	/* This should be verified on older screamers */
+	if (device_is_compatible(sound, "screamer")) {
+		chip->model = PMAC_SCREAMER;
+		// chip->can_byte_swap = 0; /* FIXME: check this */
+	}
+	if (device_is_compatible(sound, "burgundy")) {
+		chip->model = PMAC_BURGUNDY;
+		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
+	}
+	if (device_is_compatible(sound, "daca")) {
+		chip->model = PMAC_DACA;
+		chip->can_capture = 0;  /* no capture */
+		chip->can_duplex = 0;
+		// chip->can_byte_swap = 0; /* FIXME: check this */
+		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
+	}
+	if (device_is_compatible(sound, "tumbler")) {
+		chip->model = PMAC_TUMBLER;
+		chip->can_capture = 0;  /* no capture */
+		chip->can_duplex = 0;
+		// chip->can_byte_swap = 0; /* FIXME: check this */
+		chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
+		chip->freq_table = tumbler_freqs;
+		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
+	}
+	if (device_is_compatible(sound, "snapper")) {
+		chip->model = PMAC_SNAPPER;
+		// chip->can_byte_swap = 0; /* FIXME: check this */
+		chip->num_freqs = ARRAY_SIZE(tumbler_freqs);
+		chip->freq_table = tumbler_freqs;
+		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
+	}
+	if (device_is_compatible(sound, "AOAKeylargo")) {
+		/* Seems to support the stock AWACS frequencies, but has
+		   a snapper mixer */
+		chip->model = PMAC_SNAPPER;
+		// chip->can_byte_swap = 0; /* FIXME: check this */
+		chip->control_mask = MASK_IEPC | 0x11; /* disable IEE */
+	}
+	prop = (unsigned int *)get_property(sound, "device-id", NULL);
+	if (prop)
+		chip->device_id = *prop;
+	chip->has_iic = (find_devices("perch") != NULL);
+
+	detect_byte_swap(chip);
+
+	/* look for a property saying what sample rates
+	   are available */
+	prop = (unsigned int *) get_property(sound, "sample-rates", &l);
+	if (! prop)
+		prop = (unsigned int *) get_property(sound, "output-frame-rates", &l);
+	if (prop) {
+		int i;
+		chip->freqs_ok = 0;
+		for (l /= sizeof(int); l > 0; --l) {
+			unsigned int r = *prop++;
+			/* Apple 'Fixed' format */
+			if (r >= 0x10000)
+				r >>= 16;
+			for (i = 0; i < chip->num_freqs; ++i) {
+				if (r == chip->freq_table[i]) {
+					chip->freqs_ok |= (1 << i);
+					break;
+				}
+			}
+		}
+	} else {
+		/* assume only 44.1khz */
+		chip->freqs_ok = 1;
+	}
+
+	return 0;
+}
+
+/*
+ * exported - boolean info callbacks for ease of programming
+ */
+int snd_pmac_boolean_stereo_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+int snd_pmac_boolean_mono_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+#ifdef PMAC_SUPPORT_AUTOMUTE
+/*
+ * auto-mute
+ */
+static int pmac_auto_mute_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	ucontrol->value.integer.value[0] = chip->auto_mute;
+	return 0;
+}
+
+static int pmac_auto_mute_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	if (ucontrol->value.integer.value[0] != chip->auto_mute) {
+		chip->auto_mute = ucontrol->value.integer.value[0];
+		if (chip->update_automute)
+			chip->update_automute(chip, 1);
+		return 1;
+	}
+	return 0;
+}
+
+static int pmac_hp_detect_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	pmac_t *chip = snd_kcontrol_chip(kcontrol);
+	if (chip->detect_headphone)
+		ucontrol->value.integer.value[0] = chip->detect_headphone(chip);
+	else
+		ucontrol->value.integer.value[0] = 0;
+	return 0;
+}
+
+static snd_kcontrol_new_t auto_mute_controls[] __initdata = {
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	  .name = "Auto Mute Switch",
+	  .info = snd_pmac_boolean_mono_info,
+	  .get = pmac_auto_mute_get,
+	  .put = pmac_auto_mute_put,
+	},
+	{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	  .name = "Headphone Detection",
+	  .access = SNDRV_CTL_ELEM_ACCESS_READ,
+	  .info = snd_pmac_boolean_mono_info,
+	  .get = pmac_hp_detect_get,
+	},
+};
+
+int __init snd_pmac_add_automute(pmac_t *chip)
+{
+	int err;
+	chip->auto_mute = 1;
+	err = snd_ctl_add(chip->card, snd_ctl_new1(&auto_mute_controls[0], chip));
+	if (err < 0)
+		return err;
+	chip->hp_detect_ctl = snd_ctl_new1(&auto_mute_controls[1], chip);
+	return snd_ctl_add(chip->card, chip->hp_detect_ctl);
+}
+#endif /* PMAC_SUPPORT_AUTOMUTE */
+
+/*
+ * create and detect a pmac chip record
+ */
+int __init snd_pmac_new(snd_card_t *card, pmac_t **chip_return)
+{
+	pmac_t *chip;
+	struct device_node *np;
+	int i, err;
+	static snd_device_ops_t ops = {
+		.dev_free =	snd_pmac_dev_free,
+	};
+
+	snd_runtime_check(chip_return, return -EINVAL);
+	*chip_return = NULL;
+
+	chip = kcalloc(1, sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL)
+		return -ENOMEM;
+	chip->card = card;
+
+	spin_lock_init(&chip->reg_lock);
+	chip->irq = chip->tx_irq = chip->rx_irq = -1;
+
+	chip->playback.stream = SNDRV_PCM_STREAM_PLAYBACK;
+	chip->capture.stream = SNDRV_PCM_STREAM_CAPTURE;
+
+	if ((err = snd_pmac_detect(chip)) < 0)
+		goto __error;
+
+	if (snd_pmac_dbdma_alloc(&chip->playback.cmd, PMAC_MAX_FRAGS + 1) < 0 ||
+	    snd_pmac_dbdma_alloc(&chip->capture.cmd, PMAC_MAX_FRAGS + 1) < 0 ||
+	    snd_pmac_dbdma_alloc(&chip->extra_dma, 2) < 0) {
+		err = -ENOMEM;
+		goto __error;
+	}
+
+	np = chip->node;
+	if (np->n_addrs < 3 || np->n_intrs < 3) {
+		err = -ENODEV;
+		goto __error;
+	}
+
+	for (i = 0; i < 3; i++) {
+		static char *name[3] = { NULL, "- Tx DMA", "- Rx DMA" };
+		if (! request_OF_resource(np, i, name[i])) {
+			snd_printk(KERN_ERR "pmac: can't request resource %d!\n", i);
+			err = -ENODEV;
+			goto __error;
+		}
+		chip->of_requested |= (1 << i);
+	}
+
+	chip->awacs = ioremap(np->addrs[0].address, 0x1000);
+	chip->playback.dma = ioremap(np->addrs[1].address, 0x100);
+	chip->capture.dma = ioremap(np->addrs[2].address, 0x100);
+	if (chip->model <= PMAC_BURGUNDY) {
+		if (request_irq(np->intrs[0].line, snd_pmac_ctrl_intr, 0,
+				"PMac", (void*)chip)) {
+			snd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n", np->intrs[0].line);
+			err = -EBUSY;
+			goto __error;
+		}
+		chip->irq = np->intrs[0].line;
+	}
+	if (request_irq(np->intrs[1].line, snd_pmac_tx_intr, 0,
+			"PMac Output", (void*)chip)) {
+		snd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n", np->intrs[1].line);
+		err = -EBUSY;
+		goto __error;
+	}
+	chip->tx_irq = np->intrs[1].line;
+	if (request_irq(np->intrs[2].line, snd_pmac_rx_intr, 0,
+			"PMac Input", (void*)chip)) {
+		snd_printk(KERN_ERR "pmac: unable to grab IRQ %d\n", np->intrs[2].line);
+		err = -EBUSY;
+		goto __error;
+	}
+	chip->rx_irq = np->intrs[2].line;
+
+	snd_pmac_sound_feature(chip, 1);
+
+	/* reset */
+	out_le32(&chip->awacs->control, 0x11);
+
+	/* Powerbooks have odd ways of enabling inputs such as
+	   an expansion-bay CD or sound from an internal modem
+	   or a PC-card modem. */
+	if (chip->is_pbook_3400) {
+		/* Enable CD and PC-card sound inputs. */
+		/* This is done by reading from address
+		 * f301a000, + 0x10 to enable the expansion-bay
+		 * CD sound input, + 0x80 to enable the PC-card
+		 * sound input.  The 0x100 enables the SCSI bus
+		 * terminator power.
+		 */
+		chip->latch_base = ioremap (0xf301a000, 0x1000);
+		in_8(chip->latch_base + 0x190);
+	} else if (chip->is_pbook_G3) {
+		struct device_node* mio;
+		for (mio = chip->node->parent; mio; mio = mio->parent) {
+			if (strcmp(mio->name, "mac-io") == 0
+			    && mio->n_addrs > 0) {
+				chip->macio_base = ioremap(mio->addrs[0].address, 0x40);
+				break;
+			}
+		}
+		/* Enable CD sound input. */
+		/* The relevant bits for writing to this byte are 0x8f.
+		 * I haven't found out what the 0x80 bit does.
+		 * For the 0xf bits, writing 3 or 7 enables the CD
+		 * input, any other value disables it.  Values
+		 * 1, 3, 5, 7 enable the microphone.  Values 0, 2,
+		 * 4, 6, 8 - f enable the input from the modem.
+		 */
+		if (chip->macio_base)
+			out_8(chip->macio_base + 0x37, 3);
+	}
+
+	/* Reset dbdma channels */
+	snd_pmac_dbdma_reset(chip);
+
+#if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)
+	/* add sleep notifier */
+	if (! snd_pmac_register_sleep_notifier(chip))
+		snd_card_set_pm_callback(chip->card, snd_pmac_suspend, snd_pmac_resume, chip);
+#endif
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0)
+		goto __error;
+
+	*chip_return = chip;
+	return 0;
+
+ __error:
+	snd_pmac_free(chip);
+	return err;
+}
+
+
+/*
+ * sleep notify for powerbook
+ */
+
+#if defined(CONFIG_PM) && defined(CONFIG_PMAC_PBOOK)
+
+/*
+ * Save state when going to sleep, restore it afterwards.
+ */
+
+static int snd_pmac_suspend(snd_card_t *card, pm_message_t state)
+{
+	pmac_t *chip = card->pm_private_data;
+	unsigned long flags;
+
+	if (chip->suspend)
+		chip->suspend(chip);
+	snd_pcm_suspend_all(chip->pcm);
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	snd_pmac_beep_stop(chip);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	if (chip->irq >= 0)
+		disable_irq(chip->irq);
+	if (chip->tx_irq >= 0)
+		disable_irq(chip->tx_irq);
+	if (chip->rx_irq >= 0)
+		disable_irq(chip->rx_irq);
+	snd_pmac_sound_feature(chip, 0);
+	return 0;
+}
+
+static int snd_pmac_resume(snd_card_t *card)
+{
+	pmac_t *chip = card->pm_private_data;
+
+	snd_pmac_sound_feature(chip, 1);
+	if (chip->resume)
+		chip->resume(chip);
+	/* enable CD sound input */
+	if (chip->macio_base && chip->is_pbook_G3) {
+		out_8(chip->macio_base + 0x37, 3);
+	} else if (chip->is_pbook_3400) {
+		in_8(chip->latch_base + 0x190);
+	}
+
+	snd_pmac_pcm_set_format(chip);
+
+	if (chip->irq >= 0)
+		enable_irq(chip->irq);
+	if (chip->tx_irq >= 0)
+		enable_irq(chip->tx_irq);
+	if (chip->rx_irq >= 0)
+		enable_irq(chip->rx_irq);
+
+	return 0;
+}
+
+/* the chip is stored statically by snd_pmac_register_sleep_notifier
+ * because we can't have any private data for notify callback.
+ */
+static pmac_t *sleeping_pmac = NULL;
+
+static int snd_pmac_sleep_notify(struct pmu_sleep_notifier *self, int when)
+{
+	pmac_t *chip;
+
+	chip = sleeping_pmac;
+	snd_runtime_check(chip, return 0);
+
+	switch (when) {
+	case PBOOK_SLEEP_NOW:
+		snd_pmac_suspend(chip->card, PMSG_SUSPEND);
+		break;
+	case PBOOK_WAKE:
+		snd_pmac_resume(chip->card);
+		break;
+	}
+	return PBOOK_SLEEP_OK;
+}
+
+static struct pmu_sleep_notifier snd_pmac_sleep_notifier = {
+	snd_pmac_sleep_notify, SLEEP_LEVEL_SOUND,
+};
+
+static int __init snd_pmac_register_sleep_notifier(pmac_t *chip)
+{
+	/* should be protected here.. */
+	snd_assert(! sleeping_pmac, return -EBUSY);
+	sleeping_pmac = chip;
+	pmu_register_sleep_notifier(&snd_pmac_sleep_notifier);
+	return 0;
+}
+						    
+static int snd_pmac_unregister_sleep_notifier(pmac_t *chip)
+{
+	/* should be protected here.. */
+	snd_assert(sleeping_pmac == chip, return -ENODEV);
+	pmu_unregister_sleep_notifier(&snd_pmac_sleep_notifier);
+	sleeping_pmac = NULL;
+	return 0;
+}
+
+#endif /* CONFIG_PM && CONFIG_PMAC_PBOOK */
