commit 8e8e69d67e5fad1a1edf97acebd649a6c8f1febd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 285
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license this program
      is distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 100 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.918357685@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 477e5153307c..4099492b5080 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *   intel_hdmi_lpe_audio.h - Intel HDMI LPE audio driver
  *
@@ -9,15 +10,6 @@
  *		Aravind Siddappaji <aravindx.siddappaji@intel.com>
  *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 #ifndef __INTEL_HDMI_LPE_AUDIO_H

commit 8d48c0163d1ab0f56a18ebe9898a34ebcfdfaa1a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 7 08:05:46 2017 +0100

    ALSA: x86: Allow single period PCM operation
    
    This is an implementation of PCM streaming with only 1 period.
    Since the hardware requires the refresh of BDs after each BD
    processing finishes, we'd need at least two BDs.  The trick is that
    both BDs point to the same content: the address of the PCM buffer
    head, and the whole buffer size.  Then it loops over to the whole
    buffer again after it finished once.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 97bbca19333a..477e5153307c 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -31,7 +31,7 @@
 #define HAD_MAX_BUFFER		((1024 * 1024 - 1) & ~0x3f)
 #define HAD_DEFAULT_BUFFER	(600 * 1024) /* default prealloc size */
 #define HAD_MAX_PERIODS		256	/* arbitrary, but should suffice */
-#define HAD_MIN_PERIODS		2
+#define HAD_MIN_PERIODS		1
 #define HAD_MAX_PERIOD_BYTES	((HAD_MAX_BUFFER / HAD_MIN_PERIODS) & ~0x3f)
 #define HAD_MIN_PERIOD_BYTES	1024	/* might be smaller */
 #define HAD_FIFO_SIZE		0 /* fifo not being used */

commit 77531beeb97d079fb422d2b78a0d75c564384310
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 7 12:17:23 2017 +0100

    ALSA: x86: Rearrange defines
    
    We have two header files and everything is mixed up chaotically.
    Move the chip-specific definitions like the hardware registers to
    intel_hdmi_lpe_audio.h, and the rest, the implementation specific
    stuff into intel_hdmi_audio.h.
    
    In addition, put some more comments to the register fields, and fix
    the incorrect name prefix for AUD_HDMI_STATUS bits, too.
    
    The whole changes are merely a code shuffling, and there is no
    functional change.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 48cab1b84c7b..97bbca19333a 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -23,7 +23,6 @@
 #ifndef __INTEL_HDMI_LPE_AUDIO_H
 #define __INTEL_HDMI_LPE_AUDIO_H
 
-#define HAD_MAX_DEVICES		1
 #define HAD_MIN_CHANNEL		2
 #define HAD_MAX_CHANNEL		8
 #define HAD_NUM_OF_RING_BUFS	4
@@ -55,9 +54,7 @@
 #define DIS_SAMPLE_RATE_74_25	74250
 #define DIS_SAMPLE_RATE_148_5	148500
 #define HAD_REG_WIDTH		0x08
-#define HAD_MAX_HW_BUFS		0x04
 #define HAD_MAX_DIP_WORDS		16
-#define INTEL_HAD		"HdmiLpeAudio"
 
 /* DP Link Rates */
 #define DP_2_7_GHZ			270000
@@ -112,72 +109,34 @@ enum hdmi_ctrl_reg_offset {
 	AUD_HDMIW_INFOFR	= 0x68, /* v2 */
 };
 
-/*
- *	CEA speaker placement:
- *
- *	FL  FLC   FC   FRC   FR
- *
- *						LFE
- *
- *	RL  RLC   RC   RRC   RR
- *
- *	The Left/Right Surround channel _notions_ LS/RS in SMPTE 320M
- *	corresponds to CEA RL/RR; The SMPTE channel _assignment_ C/LFE is
- *	swapped to CEA LFE/FC.
- */
-enum cea_speaker_placement {
-	FL  = (1 <<  0),        /* Front Left           */
-	FC  = (1 <<  1),        /* Front Center         */
-	FR  = (1 <<  2),        /* Front Right          */
-	FLC = (1 <<  3),        /* Front Left Center    */
-	FRC = (1 <<  4),        /* Front Right Center   */
-	RL  = (1 <<  5),        /* Rear Left            */
-	RC  = (1 <<  6),        /* Rear Center          */
-	RR  = (1 <<  7),        /* Rear Right           */
-	RLC = (1 <<  8),        /* Rear Left Center     */
-	RRC = (1 <<  9),        /* Rear Right Center    */
-	LFE = (1 << 10),        /* Low Frequency Effect */
-};
-
-struct cea_channel_speaker_allocation {
-	int ca_index;
-	int speakers[8];
-
-	/* derived values, just for convenience */
-	int channels;
-	int spk_mask;
-};
-
-struct channel_map_table {
-	unsigned char map;              /* ALSA API channel map position */
-	unsigned char cea_slot;         /* CEA slot value */
-	int spk_mask;                   /* speaker position bit mask */
-};
-
 /* Audio configuration */
 union aud_cfg {
 	struct {
 		u32 aud_en:1;
-		u32 layout:1;
+		u32 layout:1;		/* LAYOUT[01], see below */
 		u32 fmt:2;
 		u32 num_ch:3;
 		u32 set:1;
 		u32 flat:1;
 		u32 val_bit:1;
 		u32 user_bit:1;
-		u32 underrun:1;
-		u32 packet_mode:1;
-		u32 left_align:1;
-		u32 bogus_sample:1;
-		u32 dp_modei:1;
+		u32 underrun:1;		/* 0: send null packets,
+					 * 1: send silence stream
+					 */
+		u32 packet_mode:1;	/* 0: 32bit container, 1: 16bit */
+		u32 left_align:1;	/* 0: MSB bits 0-23, 1: bits 8-31 */
+		u32 bogus_sample:1;	/* bogus sample for odd channels */
+		u32 dp_modei:1;		/* 0: HDMI, 1: DP */
 		u32 rsvd:16;
 	} regx;
 	u32 regval;
 };
 
-#define AUD_CONFIG_BLOCK_BIT			(1 << 7)
 #define AUD_CONFIG_VALID_BIT			(1 << 9)
 #define AUD_CONFIG_DP_MODE			(1 << 15)
+#define AUD_CONFIG_CH_MASK	0x70
+#define LAYOUT0			0		/* interleaved stereo */
+#define LAYOUT1			1		/* for channels > 2 */
 
 /* Audio Channel Status 0 Attributes */
 union aud_ch_status_0 {
@@ -190,13 +149,22 @@ union aud_ch_status_0 {
 		u32 ctg_code:8;
 		u32 src_num:4;
 		u32 ch_num:4;
-		u32 samp_freq:4;
+		u32 samp_freq:4;	/* CH_STATUS_MAP_XXX */
 		u32 clk_acc:2;
 		u32 rsvd:2;
 	} regx;
 	u32 regval;
 };
 
+/* samp_freq values - Sampling rate as per IEC60958 Ver 3 */
+#define CH_STATUS_MAP_32KHZ	0x3
+#define CH_STATUS_MAP_44KHZ	0x0
+#define CH_STATUS_MAP_48KHZ	0x2
+#define CH_STATUS_MAP_88KHZ	0x8
+#define CH_STATUS_MAP_96KHZ	0xA
+#define CH_STATUS_MAP_176KHZ	0xC
+#define CH_STATUS_MAP_192KHZ	0xE
+
 /* Audio Channel Status 1 Attributes */
 union aud_ch_status_1 {
 	struct {
@@ -207,6 +175,11 @@ union aud_ch_status_1 {
 	u32 regval;
 };
 
+#define MAX_SMPL_WIDTH_20	0x0
+#define MAX_SMPL_WIDTH_24	0x1
+#define SMPL_WIDTH_16BITS	0x1
+#define SMPL_WIDTH_24BITS	0x5
+
 /* CTS register */
 union aud_hdmi_cts {
 	struct {
@@ -239,6 +212,9 @@ union aud_buf_config {
 	u32 regval;
 };
 
+#define FIFO_THRESHOLD		0xFE
+#define DMA_FIFO_THRESHOLD	0x7
+
 /* Audio Sample Swapping offset */
 union aud_buf_ch_swap {
 	struct {
@@ -255,6 +231,8 @@ union aud_buf_ch_swap {
 	u32 regval;
 };
 
+#define SWAP_LFE_CENTER		0x00fac4c8	/* octal 76543210 */
+
 /* Address for Audio Buffer */
 union aud_buf_addr {
 	struct {
@@ -306,6 +284,9 @@ union aud_info_frame1 {
 	u32 regval;
 };
 
+#define HDMI_INFO_FRAME_WORD1	0x000a0184
+#define DP_INFO_FRAME_WORD1	0x00441b84
+
 /* DIP frame 2 */
 union aud_info_frame2 {
 	struct {
@@ -333,13 +314,15 @@ union aud_info_frame3 {
 	u32 regval;
 };
 
+#define VALID_DIP_WORDS		3
+
 /* AUD_HDMI_STATUS bits */
 #define HDMI_AUDIO_UNDERRUN		(1U << 31)
 #define HDMI_AUDIO_BUFFER_DONE		(1U << 29)
 
 /* AUD_HDMI_STATUS register mask */
-#define AUD_CONFIG_MASK_UNDERRUN	0xC0000000
-#define AUD_CONFIG_MASK_SRDBG		0x00000002
-#define AUD_CONFIG_MASK_FUNCRST		0x00000001
+#define AUD_HDMI_STATUS_MASK_UNDERRUN	0xC0000000
+#define AUD_HDMI_STATUS_MASK_SRDBG	0x00000002
+#define AUD_HDMI_STATUSG_MASK_FUNCRST	0x00000001
 
 #endif

commit 873ab035752e62a90eaeb1daf88a44dad1da6ea0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 7 12:14:04 2017 +0100

    ALSA: x86: Fix driver name string overflow
    
    The driver sets card->driver name string over its size (16 bytes).
    Shorten the name string to fit with it.
    
    Also, set more verbose string to card->shortname and ->longname.
    This doesn't have to be identical with card->driver at all.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index ca4212dca94e..48cab1b84c7b 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -57,7 +57,7 @@
 #define HAD_REG_WIDTH		0x08
 #define HAD_MAX_HW_BUFS		0x04
 #define HAD_MAX_DIP_WORDS		16
-#define INTEL_HAD		"IntelHdmiLpeAudio"
+#define INTEL_HAD		"HdmiLpeAudio"
 
 /* DP Link Rates */
 #define DP_2_7_GHZ			270000

commit e1b239f371c0c745542cb8108d085ec728e8a69c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 3 00:01:18 2017 +0100

    ALSA: x86: Refactor PCM process engine
    
    This is again a big rewrite of the driver; now it touches the code to
    process PCM stream transfers.
    
    The most fundamental change is that the driver may support more than
    four periods.  Instead of keeping the same index between both the ring
    buffer (with the fixed four buffer descriptors) and the PCM buffer
    periods, we keep difference indices for both (bd_head and pcm_head
    fields).  In addition, when the periods are more than four, we need to
    track both head and next indices.  That is, we now have three indices:
    bd_head, pcm_head and pcm_filled.
    
    Also, the driver works better for periods < 4, too: the remaining BDs
    out of four are marked as invalid, so that the hardware skips those
    BDs in its loop.
    
    By this flexibility, we can use even ALSA-lib dmix plugin, which
    requires 16 periods as default.
    
    The buffer size could be up to 20bit, so the max buffer size was
    increased accordingly.  However, the buffer pre-allocation is kept as
    the old value (600kB) as default.  The reason is the limited number of
    BDs: since it doesn't suffice for the useful SG page management that
    can fit with the usual page allocator like some other drivers, we have
    to still allocate continuous pages, hence we shouldn't take too big
    memories there.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index be9783910a3a..ca4212dca94e 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -28,13 +28,13 @@
 #define HAD_MAX_CHANNEL		8
 #define HAD_NUM_OF_RING_BUFS	4
 
-/* Assume 192KHz, 8channel, 25msec period */
-#define HAD_MAX_BUFFER		(600*1024)
-#define HAD_MIN_BUFFER		(32*1024)
-#define HAD_MAX_PERIODS		4
-#define HAD_MIN_PERIODS		4
-#define HAD_MAX_PERIOD_BYTES	(HAD_MAX_BUFFER/HAD_MIN_PERIODS)
-#define HAD_MIN_PERIOD_BYTES	256
+/* max 20bit address, aligned to 64 */
+#define HAD_MAX_BUFFER		((1024 * 1024 - 1) & ~0x3f)
+#define HAD_DEFAULT_BUFFER	(600 * 1024) /* default prealloc size */
+#define HAD_MAX_PERIODS		256	/* arbitrary, but should suffice */
+#define HAD_MIN_PERIODS		2
+#define HAD_MAX_PERIOD_BYTES	((HAD_MAX_BUFFER / HAD_MIN_PERIODS) & ~0x3f)
+#define HAD_MIN_PERIOD_BYTES	1024	/* might be smaller */
 #define HAD_FIFO_SIZE		0 /* fifo not being used */
 #define MAX_SPEAKERS		8
 
@@ -82,14 +82,6 @@
 /* Naud Value */
 #define DP_NAUD_VAL					32768
 
-/* enum intel_had_aud_buf_type - HDMI controller ring buffer types */
-enum intel_had_aud_buf_type {
-	HAD_BUF_TYPE_A = 0,
-	HAD_BUF_TYPE_B = 1,
-	HAD_BUF_TYPE_C = 2,
-	HAD_BUF_TYPE_D = 3,
-};
-
 /* HDMI Controller register offsets - audio domain common */
 /* Base address for below regs = 0x65000 */
 enum hdmi_ctrl_reg_offset_common {
@@ -274,6 +266,9 @@ union aud_buf_addr {
 	u32 regval;
 };
 
+#define AUD_BUF_VALID		(1U << 0)
+#define AUD_BUF_INTR_EN		(1U << 1)
+
 /* Length of Audio Buffer */
 union aud_buf_len {
 	struct {

commit 91b0cb0cc07bcb5114df2897531f4ea41c148c8e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 2 17:46:49 2017 +0100

    ALSA: x86: Rename drv_status to connected
    
    After the rewrite of the runtime PM code, we have only two driver
    status: CONNECTED and DISCONNECTED.  So it's clearer to use a boolean
    flag, and name it easier one, "connected".
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 5a5adb7f0cde..be9783910a3a 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -82,14 +82,6 @@
 /* Naud Value */
 #define DP_NAUD_VAL					32768
 
-enum had_drv_status {
-	HAD_DRV_CONNECTED,
-	HAD_DRV_RUNNING,
-	HAD_DRV_DISCONNECTED,
-	HAD_DRV_SUSPENDED,
-	HAD_DRV_ERR,
-};
-
 /* enum intel_had_aud_buf_type - HDMI controller ring buffer types */
 enum intel_had_aud_buf_type {
 	HAD_BUF_TYPE_A = 0,

commit 03c3437755881a9f6f1b5f8c05e62edf7898a87f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 2 16:19:03 2017 +0100

    ALSA: x86: Clean up unused defines and inclusions
    
    Many defines and constants are left unused.  Clean them up.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 0e8397970e4a..5a5adb7f0cde 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -23,20 +23,6 @@
 #ifndef __INTEL_HDMI_LPE_AUDIO_H
 #define __INTEL_HDMI_LPE_AUDIO_H
 
-#include <linux/types.h>
-#include <sound/initval.h>
-#include <linux/version.h>
-#include <linux/pm_runtime.h>
-#include <linux/platform_device.h>
-#include <sound/asoundef.h>
-#include <sound/control.h>
-#include <sound/pcm.h>
-
-#define AUD_CONFIG_VALID_BIT			(1<<9)
-#define AUD_CONFIG_DP_MODE			(1<<15)
-#define AUD_CONFIG_BLOCK_BIT			(1<<7)
-
-#define HMDI_LPE_AUDIO_DRIVER_NAME		"intel-hdmi-lpe-audio"
 #define HAD_MAX_DEVICES		1
 #define HAD_MIN_CHANNEL		2
 #define HAD_MAX_CHANNEL		8
@@ -96,14 +82,6 @@
 /* Naud Value */
 #define DP_NAUD_VAL					32768
 
-/* _AUD_CONFIG register MASK */
-#define AUD_CONFIG_MASK_UNDERRUN	0xC0000000
-#define AUD_CONFIG_MASK_SRDBG		0x00000002
-#define AUD_CONFIG_MASK_FUNCRST		0x00000001
-
-#define MAX_CNT			0xFF
-#define HAD_SUSPEND_DELAY	1000
-
 enum had_drv_status {
 	HAD_DRV_CONNECTED,
 	HAD_DRV_RUNNING,
@@ -120,17 +98,10 @@ enum intel_had_aud_buf_type {
 	HAD_BUF_TYPE_D = 3,
 };
 
-enum num_aud_ch {
-	CH_STEREO = 0,
-	CH_THREE_FOUR = 1,
-	CH_FIVE_SIX = 2,
-	CH_SEVEN_EIGHT = 3
-};
-
 /* HDMI Controller register offsets - audio domain common */
 /* Base address for below regs = 0x65000 */
 enum hdmi_ctrl_reg_offset_common {
-	AUDIO_HDMI_CONFIG_A	= 0x000,
+	AUDIO_HDMI_CONFIG_A = 0x000,
 	AUDIO_HDMI_CONFIG_B = 0x800,
 	AUDIO_HDMI_CONFIG_C = 0x900,
 };
@@ -220,6 +191,10 @@ union aud_cfg {
 	u32 regval;
 };
 
+#define AUD_CONFIG_BLOCK_BIT			(1 << 7)
+#define AUD_CONFIG_VALID_BIT			(1 << 9)
+#define AUD_CONFIG_DP_MODE			(1 << 15)
+
 /* Audio Channel Status 0 Attributes */
 union aud_ch_status_0 {
 	struct {
@@ -371,32 +346,13 @@ union aud_info_frame3 {
 	u32 regval;
 };
 
-#define HDMI_AUDIO_UNDERRUN     (1UL<<31)
-#define HDMI_AUDIO_BUFFER_DONE  (1UL<<29)
+/* AUD_HDMI_STATUS bits */
+#define HDMI_AUDIO_UNDERRUN		(1U << 31)
+#define HDMI_AUDIO_BUFFER_DONE		(1U << 29)
 
-
-#define PORT_ENABLE			(1 << 31)
-#define SDVO_AUDIO_ENABLE	(1 << 6)
-
-enum had_caps_list {
-	HAD_GET_ELD = 1,
-	HAD_GET_DISPLAY_RATE,
-	HAD_GET_DP_OUTPUT,
-	HAD_GET_LINK_RATE,
-	HAD_SET_ENABLE_AUDIO,
-	HAD_SET_DISABLE_AUDIO,
-	HAD_SET_ENABLE_AUDIO_INT,
-	HAD_SET_DISABLE_AUDIO_INT,
-};
-
-enum had_event_type {
-	HAD_EVENT_HOT_PLUG = 1,
-	HAD_EVENT_HOT_UNPLUG,
-	HAD_EVENT_MODE_CHANGING,
-	HAD_EVENT_AUDIO_BUFFER_DONE,
-	HAD_EVENT_AUDIO_BUFFER_UNDERRUN,
-	HAD_EVENT_QUERY_IS_AUDIO_BUSY,
-	HAD_EVENT_QUERY_IS_AUDIO_SUSPENDED,
-};
+/* AUD_HDMI_STATUS register mask */
+#define AUD_CONFIG_MASK_UNDERRUN	0xC0000000
+#define AUD_CONFIG_MASK_SRDBG		0x00000002
+#define AUD_CONFIG_MASK_FUNCRST		0x00000001
 
 #endif

commit 7ceba75f21e4ecb520b110ffada72cc0c9f5c072
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 2 15:58:35 2017 +0100

    ALSA: x86: Reduce redundant register field names
    
    Currently each register definition contains the own prefix in the
    union struct itself; for example, union aud_ch_status_0 has
    status_0_regx and status_0_regval fields.  These are simply
    superfluous, since usually the type of the variable is seen in its
    declaration or in its name.
    
    In this patch, we cut off these prefixes.  Now all register
    definitions have regx and regval fields consistently, instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index f9c184960b34..0e8397970e4a 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -199,13 +199,7 @@ struct channel_map_table {
 	int spk_mask;                   /* speaker position bit mask */
 };
 
-/**
- * union aud_cfg - Audio configuration
- *
- * @cfg_regx: individual register bits
- * @cfg_regval: full register value
- *
- */
+/* Audio configuration */
 union aud_cfg {
 	struct {
 		u32 aud_en:1;
@@ -222,17 +216,11 @@ union aud_cfg {
 		u32 bogus_sample:1;
 		u32 dp_modei:1;
 		u32 rsvd:16;
-	} cfg_regx;
-	u32 cfg_regval;
+	} regx;
+	u32 regval;
 };
 
-/**
- * union aud_ch_status_0 - Audio Channel Status 0 Attributes
- *
- * @status_0_regx:individual register bits
- * @status_0_regval:full register value
- *
- */
+/* Audio Channel Status 0 Attributes */
 union aud_ch_status_0 {
 	struct {
 		u32 ch_status:1;
@@ -246,65 +234,41 @@ union aud_ch_status_0 {
 		u32 samp_freq:4;
 		u32 clk_acc:2;
 		u32 rsvd:2;
-	} status_0_regx;
-	u32 status_0_regval;
+	} regx;
+	u32 regval;
 };
 
-/**
- * union aud_ch_status_1 - Audio Channel Status 1 Attributes
- *
- * @status_1_regx: individual register bits
- * @status_1_regval: full register value
- *
- */
+/* Audio Channel Status 1 Attributes */
 union aud_ch_status_1 {
 	struct {
 		u32 max_wrd_len:1;
 		u32 wrd_len:3;
 		u32 rsvd:28;
-		} status_1_regx;
-	u32 status_1_regval;
+	} regx;
+	u32 regval;
 };
 
-/**
- * union aud_hdmi_cts - CTS register
- *
- * @cts_regx: individual register bits
- * @cts_regval: full register value
- *
- */
+/* CTS register */
 union aud_hdmi_cts {
 	struct {
 		u32 cts_val:24;
 		u32 en_cts_prog:1;
 		u32 rsvd:7;
-	} cts_regx;
-	u32 cts_regval;
+	} regx;
+	u32 regval;
 };
 
-/**
- * union aud_hdmi_n_enable - N register
- *
- * @n_regx: individual register bits
- * @n_regval: full register value
- *
- */
+/* N register */
 union aud_hdmi_n_enable {
 	struct {
 		u32 n_val:24;
 		u32 en_n_prog:1;
 		u32 rsvd:7;
-	} n_regx;
-	u32 n_regval;
+	} regx;
+	u32 regval;
 };
 
-/**
- * union aud_buf_config -  Audio Buffer configurations
- *
- * @buf_cfg_regx: individual register bits
- * @buf_cfgval: full register value
- *
- */
+/* Audio Buffer configurations */
 union aud_buf_config {
 	struct {
 		u32 audio_fifo_watermark:8;
@@ -312,17 +276,11 @@ union aud_buf_config {
 		u32 rsvd0:5;
 		u32 aud_delay:8;
 		u32 rsvd1:8;
-	} buf_cfg_regx;
-	u32 buf_cfgval;
+	} regx;
+	u32 regval;
 };
 
-/**
- * union aud_buf_ch_swap - Audio Sample Swapping offset
- *
- * @buf_ch_swap_regx: individual register bits
- * @buf_ch_swap_val: full register value
- *
- */
+/* Audio Sample Swapping offset */
 union aud_buf_ch_swap {
 	struct {
 		u32 first_0:3;
@@ -334,49 +292,31 @@ union aud_buf_ch_swap {
 		u32 first_3:3;
 		u32 second_3:3;
 		u32 rsvd:8;
-	} buf_ch_swap_regx;
-	u32 buf_ch_swap_val;
+	} regx;
+	u32 regval;
 };
 
-/**
- * union aud_buf_addr - Address for Audio Buffer
- *
- * @buf_addr_regx: individual register bits
- * @buf_addr_val: full register value
- *
- */
+/* Address for Audio Buffer */
 union aud_buf_addr {
 	struct {
 		u32 valid:1;
 		u32 intr_en:1;
 		u32 rsvd:4;
 		u32 addr:26;
-	} buf_addr_regx;
-	u32 buf_addr_val;
+	} regx;
+	u32 regval;
 };
 
-/**
- * union aud_buf_len - Length of Audio Buffer
- *
- * @buf_len_regx: individual register bits
- * @buf_len_val: full register value
- *
- */
+/* Length of Audio Buffer */
 union aud_buf_len {
 	struct {
 		u32 buf_len:20;
 		u32 rsvd:12;
-	} buf_len_regx;
-	u32 buf_len_val;
+	} regx;
+	u32 regval;
 };
 
-/**
- * union aud_ctrl_st - Audio Control State Register offset
- *
- * @ctrl_regx: individual register bits
- * @ctrl_val: full register value
- *
- */
+/* Audio Control State Register offset */
 union aud_ctrl_st {
 	struct {
 		u32 ram_addr:4;
@@ -389,34 +329,22 @@ union aud_ctrl_st {
 		u32 dip_idx:3;
 		u32 dip_en_sta:4;
 		u32 rsvd:7;
-	} ctrl_regx;
-	u32 ctrl_val;
+	} regx;
+	u32 regval;
 };
 
-/**
- * union aud_info_frame1 - Audio HDMI Widget Data Island Packet offset
- *
- * @fr1_regx: individual register bits
- * @fr1_val: full register value
- *
- */
+/* Audio HDMI Widget Data Island Packet offset */
 union aud_info_frame1 {
 	struct {
 		u32 pkt_type:8;
 		u32 ver_num:8;
 		u32 len:5;
 		u32 rsvd:11;
-	} fr1_regx;
-	u32 fr1_val;
+	} regx;
+	u32 regval;
 };
 
-/**
- * union aud_info_frame2 - DIP frame 2
- *
- * @fr2_regx: individual register bits
- * @fr2_val: full register value
- *
- */
+/* DIP frame 2 */
 union aud_info_frame2 {
 	struct {
 		u32 chksum:8;
@@ -427,17 +355,11 @@ union aud_info_frame2 {
 		u32 smpl_freq:3;
 		u32 rsvd1:3;
 		u32 format:8;
-	} fr2_regx;
-	u32 fr2_val;
+	} regx;
+	u32 regval;
 };
 
-/**
- * union aud_info_frame3 - DIP frame 3
- *
- * @fr3_regx: individual register bits
- * @fr3_val: full register value
- *
- */
+/* DIP frame 3 */
 union aud_info_frame3 {
 	struct {
 		u32 chnl_alloc:8;
@@ -445,8 +367,8 @@ union aud_info_frame3 {
 		u32 lsv:4;
 		u32 dm_inh:1;
 		u32 rsvd1:16;
-	} fr3_regx;
-	u32 fr3_val;
+	} regx;
+	u32 regval;
 };
 
 #define HDMI_AUDIO_UNDERRUN     (1UL<<31)

commit df0435db1db9e385acdc0a354896d2c0e878dbd5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 2 15:37:11 2017 +0100

    ALSA: x86: Use the standard ELD bytes definitions
    
    We have some constants defined in drm/drm_edid.h, and clean up our own
    definitions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 1e7e6db987c6..f9c184960b34 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -104,125 +104,6 @@
 #define MAX_CNT			0xFF
 #define HAD_SUSPEND_DELAY	1000
 
-#define OTM_HDMI_ELD_SIZE 128
-
-union otm_hdmi_eld_t {
-	unsigned char eld_data[OTM_HDMI_ELD_SIZE];
-	struct {
-		/* Byte[0] = ELD Version Number */
-		union {
-			unsigned char   byte0;
-			struct {
-				unsigned char reserved:3; /* Reserf */
-				unsigned char eld_ver:5; /* ELD Version Number */
-				/* 00000b - reserved
-				 * 00001b - first rev, obsoleted
-				 * 00010b - version 2, supporting CEA version
-				 *			861D or below
-				 * 00011b:11111b - reserved
-				 * for future
-				 */
-			};
-		};
-
-		/* Byte[1] = Vendor Version Field */
-		union {
-			unsigned char vendor_version;
-			struct {
-				unsigned char reserved1:3;
-				unsigned char veld_ver:5; /* Version number of the ELD
-						     * extension. This value is
-						     * provisioned and unique to
-						     * each vendor.
-						     */
-			};
-		};
-
-		/* Byte[2] = Baseline Length field */
-		unsigned char baseline_eld_length; /* Length of the Baseline structure
-					      *	divided by Four.
-					      */
-
-		/* Byte [3] = Reserved for future use */
-		unsigned char byte3;
-
-		/* Starting of the BaseLine EELD structure
-		 * Byte[4] = Monitor Name Length
-		 */
-		union {
-			unsigned char byte4;
-			struct {
-				unsigned char mnl:5;
-				unsigned char cea_edid_rev_id:3;
-			};
-		};
-
-		/* Byte[5] = Capabilities */
-		union {
-			unsigned char capabilities;
-			struct {
-				unsigned char hdcp:1; /* HDCP support */
-				unsigned char ai_support:1;   /* AI support */
-				unsigned char connection_type:2; /* Connection type
-							    * 00 - HDMI
-							    * 01 - DP
-							    * 10 -11  Reserved
-							    * for future
-							    * connection types
-							    */
-				unsigned char sadc:4; /* Indicates number of 3 bytes
-						 * Short Audio Descriptors.
-						 */
-			};
-		};
-
-		/* Byte[6] = Audio Synch Delay */
-		unsigned char audio_synch_delay; /* Amount of time reported by the
-					    * sink that the video trails audio
-					    * in milliseconds.
-					    */
-
-		/* Byte[7] = Speaker Allocation Block */
-		union {
-			unsigned char speaker_allocation_block;
-			struct {
-				unsigned char flr:1; /*Front Left and Right channels*/
-				unsigned char lfe:1; /*Low Frequency Effect channel*/
-				unsigned char fc:1;  /*Center transmission channel*/
-				unsigned char rlr:1; /*Rear Left and Right channels*/
-				unsigned char rc:1; /*Rear Center channel*/
-				unsigned char flrc:1; /*Front left and Right of Center
-						 *transmission channels
-						 */
-				unsigned char rlrc:1; /*Rear left and Right of Center
-						 *transmission channels
-						 */
-				unsigned char reserved3:1; /* Reserved */
-			};
-		};
-
-		/* Byte[8 - 15] - 8 Byte port identification value */
-		unsigned char port_id_value[8];
-
-		/* Byte[16 - 17] - 2 Byte Manufacturer ID */
-		unsigned char manufacturer_id[2];
-
-		/* Byte[18 - 19] - 2 Byte Product ID */
-		unsigned char product_id[2];
-
-		/* Byte [20-83] - 64 Bytes of BaseLine Data */
-		unsigned char mn_sand_sads[64]; /* This will include
-					   * - ASCII string of Monitor name
-					   * - List of 3 byte SADs
-					   * - Zero padding
-					   */
-
-		/* Vendor ELD Block should continue here!
-		 * No Vendor ELD block defined as of now.
-		 */
-	} __packed;
-};
-
 enum had_drv_status {
 	HAD_DRV_CONNECTED,
 	HAD_DRV_RUNNING,

commit f69bd104b5cded0db547636fddd9512d7e6cfbf3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 2 14:57:22 2017 +0100

    ALSA: x86: Move stream status into pcm_stream_info
    
    The only remaining field in struct had_stream_data is stream_type that
    holds the current stream status.  Such information fits better in
    struct pcm_stream_info, so move it as a boolean "running" field to be
    clearer.
    
    This allows us to get rid or had_stream_data definition and
    references.
    
    Also, the superfluous status check get removed in a couple of places
    where we can call PCM helpers in anyway.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 483b9feeff30..1e7e6db987c6 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -223,14 +223,6 @@ union otm_hdmi_eld_t {
 	} __packed;
 };
 
-/**
- * enum had_status_stream - HAD stream states
- */
-enum had_status_stream {
-	HAD_INIT = 0,
-	HAD_RUNNING_STREAM,
-};
-
 enum had_drv_status {
 	HAD_DRV_CONNECTED,
 	HAD_DRV_RUNNING,

commit fa5dfe6a01481a8fa00469be42ea32beb468a501
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 1 22:03:26 2017 +0100

    ALSA: x86: Drop redundant had_stream_pvt
    
    The had_stream_pvt struct assigned to PCM runtime private data tracks
    merely the stream running status, and the very same information is
    carried by had_stream->stream_type.  Kill it.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 1bc961522d0d..483b9feeff30 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -223,21 +223,6 @@ union otm_hdmi_eld_t {
 	} __packed;
 };
 
-/**
- * enum had_status - Audio stream states
- *
- * @STREAM_INIT: Stream initialized
- * @STREAM_RUNNING: Stream running
- * @STREAM_PAUSED: Stream paused
- * @STREAM_DROPPED: Stream dropped
- */
-enum had_stream_status {
-	STREAM_INIT = 0,
-	STREAM_RUNNING = 1,
-	STREAM_PAUSED = 2,
-	STREAM_DROPPED = 3
-};
-
 /**
  * enum had_status_stream - HAD stream states
  */

commit 0e9c67d7c88ce7054288e3b61deb09bfa59f8920
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 1 17:53:19 2017 +0100

    ALSA: x86: Drop superfluous state field
    
    The state field keeps the connection state and it's basically as same
    as drv_status field.  Drop this redundancy.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 628c578ecedf..1bc961522d0d 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -591,12 +591,6 @@ union aud_info_frame3 {
 	u32 fr3_val;
 };
 
-enum hdmi_connector_status {
-	hdmi_connector_status_connected = 1,
-	hdmi_connector_status_disconnected = 2,
-	hdmi_connector_status_unknown = 3,
-};
-
 #define HDMI_AUDIO_UNDERRUN     (1UL<<31)
 #define HDMI_AUDIO_BUFFER_DONE  (1UL<<29)
 

commit 4151ee845ad8230d18ac4a0e0bf1037180c6d2d9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 31 18:14:15 2017 +0100

    ALSA: x86: Remove _v[12] suffices
    
    Although we dropped the most of the obsoleted *_v1 definitions and
    codes, some codes still keep the _v1 or _v2 suffices.  Now they are
    ripped off.
    
    The only thing to be done carefully here is the definition of control
    offsets.  The original code defines enum hdmi_ctrl_reg_offset_v1 and
    a few new elements just for v2 on its top.  After this cleanup, we
    remove the old AUD_HDMI_STATUS and AUD_HDMIW_INFOFR definitions and
    replace with the v2 values.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 8f320b4aa3b7..628c578ecedf 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -277,7 +277,7 @@ enum hdmi_ctrl_reg_offset_common {
 	AUDIO_HDMI_CONFIG_C = 0x900,
 };
 /* HDMI controller register offsets */
-enum hdmi_ctrl_reg_offset_v1 {
+enum hdmi_ctrl_reg_offset {
 	AUD_CONFIG		= 0x0,
 	AUD_CH_STATUS_0		= 0x08,
 	AUD_CH_STATUS_1		= 0x0C,
@@ -295,18 +295,8 @@ enum hdmi_ctrl_reg_offset_v1 {
 	AUD_BUF_D_ADDR		= 0x58,
 	AUD_BUF_D_LENGTH	= 0x5c,
 	AUD_CNTL_ST		= 0x60,
-	AUD_HDMI_STATUS		= 0x68,
-	AUD_HDMIW_INFOFR	= 0x114,
-};
-
-/*
- * Delta changes in HDMI controller register offsets
- * compare to v1 version
- */
-
-enum hdmi_ctrl_reg_offset_v2 {
-	AUD_HDMI_STATUS_v2	= 0x64,
-	AUD_HDMIW_INFOFR_v2	= 0x68,
+	AUD_HDMI_STATUS		= 0x64, /* v2 */
+	AUD_HDMIW_INFOFR	= 0x68, /* v2 */
 };
 
 /*
@@ -374,7 +364,7 @@ union aud_cfg {
 		u32 bogus_sample:1;
 		u32 dp_modei:1;
 		u32 rsvd:16;
-	} cfg_regx_v2;
+	} cfg_regx;
 	u32 cfg_regval;
 };
 
@@ -430,7 +420,7 @@ union aud_hdmi_cts {
 		u32 cts_val:24;
 		u32 en_cts_prog:1;
 		u32 rsvd:7;
-	} cts_regx_v2;
+	} cts_regx;
 	u32 cts_regval;
 };
 
@@ -446,7 +436,7 @@ union aud_hdmi_n_enable {
 		u32 n_val:24;
 		u32 en_n_prog:1;
 		u32 rsvd:7;
-	} n_regx_v2;
+	} n_regx;
 	u32 n_regval;
 };
 
@@ -464,7 +454,7 @@ union aud_buf_config {
 		u32 rsvd0:5;
 		u32 aud_delay:8;
 		u32 rsvd1:8;
-	} buf_cfg_regx_v2;
+	} buf_cfg_regx;
 	u32 buf_cfgval;
 };
 

commit da8648097497505d05d8cff6892351f99c029791
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 31 13:52:22 2017 +0100

    ALSA: x86: Flatten two abstraction layers
    
    This is the final stage for a big clean-up series.  Here we flatten
    the two layers into one.  Formerly, the implementation was split to
    HDMI "shell" that talks with the platform device, and HDMI audio part
    that communicates via caps and other event handlers.  All these would
    be good if there were multiple instantiations or if there were data
    protection.  But neither are true in our case.  That said, it'll be
    easier to have a flat driver structure in the end.
    
    In this patch, the former struct hdmi_lpe_audio_ctx is forged into the
    existing struct snd_intelhad.  The latter has already a few members
    that are basically the copy from the former.  Only a few new members
    for the lowlevel I/O are added by this change.
    
    Then, the had_get_caps() and had_set_caps() are simply replaced with
    the direct calls to copy the data in the struct fields.  Also, the
    had_event_handler() calls are replaced with the direct call for each
    event as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index a9d51b7c5bae..8f320b4aa3b7 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -27,12 +27,11 @@
 #include <sound/initval.h>
 #include <linux/version.h>
 #include <linux/pm_runtime.h>
+#include <linux/platform_device.h>
 #include <sound/asoundef.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
 
-struct platform_device;
-
 #define AUD_CONFIG_VALID_BIT			(1<<9)
 #define AUD_CONFIG_DP_MODE			(1<<15)
 #define AUD_CONFIG_BLOCK_BIT			(1<<7)
@@ -636,24 +635,4 @@ enum had_event_type {
 	HAD_EVENT_QUERY_IS_AUDIO_SUSPENDED,
 };
 
-/*
- * HDMI Display Controller Audio Interface
- *
- */
-struct hdmi_audio_event {
-	int type;
-};
-
-int mid_hdmi_audio_read(struct platform_device *pdev, u32 reg, u32 *val);
-int mid_hdmi_audio_write(struct platform_device *pdev, u32 reg, u32 val);
-int mid_hdmi_audio_rmw(struct platform_device *pdev,
-		       u32 reg, u32 val, u32 mask);
-
-int mid_hdmi_audio_get_caps(struct platform_device *pdev,
-			    enum had_caps_list get_element,
-			    void *capabilities);
-int mid_hdmi_audio_set_caps(struct platform_device *pdev,
-			    enum had_caps_list set_element,
-			    void *capabilties);
-
 #endif

commit bf8b24f8169096050795b552a778faaac349c73c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 30 18:09:01 2017 +0100

    ALSA: x86: Drop the global platform device reference
    
    Instead of referring to the global hlpe_pdev variable, pass the
    platform device object to each function properly.  Accessing to the
    global object is really ugly and error-prone.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index a1c3aa0fbc57..a9d51b7c5bae 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -31,6 +31,8 @@
 #include <sound/control.h>
 #include <sound/pcm.h>
 
+struct platform_device;
+
 #define AUD_CONFIG_VALID_BIT			(1<<9)
 #define AUD_CONFIG_DP_MODE			(1<<15)
 #define AUD_CONFIG_BLOCK_BIT			(1<<7)
@@ -642,15 +644,16 @@ struct hdmi_audio_event {
 	int type;
 };
 
-void mid_hdmi_audio_signal_event(enum had_event_type event);
-
-int mid_hdmi_audio_read(u32 reg, u32 *val);
-int mid_hdmi_audio_write(u32 reg, u32 val);
-int mid_hdmi_audio_rmw(u32 reg, u32 val, u32 mask);
+int mid_hdmi_audio_read(struct platform_device *pdev, u32 reg, u32 *val);
+int mid_hdmi_audio_write(struct platform_device *pdev, u32 reg, u32 val);
+int mid_hdmi_audio_rmw(struct platform_device *pdev,
+		       u32 reg, u32 val, u32 mask);
 
-int mid_hdmi_audio_get_caps(enum had_caps_list get_element,
+int mid_hdmi_audio_get_caps(struct platform_device *pdev,
+			    enum had_caps_list get_element,
 			    void *capabilities);
-int mid_hdmi_audio_set_caps(enum had_caps_list set_element,
+int mid_hdmi_audio_set_caps(struct platform_device *pdev,
+			    enum had_caps_list set_element,
 			    void *capabilties);
 
 #endif

commit af3e5c9c5d370e262da97fb8a8310a9d578efa0d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 30 17:44:00 2017 +0100

    ALSA: x86: Drop unused mid_hdmi_audio_is_busy()
    
    The function is nowhere used.  Kill it.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 511bdc30dca1..a1c3aa0fbc57 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -642,7 +642,6 @@ struct hdmi_audio_event {
 	int type;
 };
 
-bool mid_hdmi_audio_is_busy(void *dev);
 void mid_hdmi_audio_signal_event(enum had_event_type event);
 
 int mid_hdmi_audio_read(u32 reg, u32 *val);

commit 437af8f2946231ee141bc2a8d37063a8bb6047b0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 30 17:38:00 2017 +0100

    ALSA: x86: Call event callback directly
    
    Currently the driver calls the event callback stored in its ctx
    pointer, but it's obviously inefficient.  Replace it with the direct
    calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 0d285ce8d4e6..511bdc30dca1 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -638,16 +638,12 @@ enum had_event_type {
  * HDMI Display Controller Audio Interface
  *
  */
-typedef int (*had_event_call_back) (enum had_event_type event_type,
-		void *ctxt_info);
-
 struct hdmi_audio_event {
 	int type;
 };
 
 bool mid_hdmi_audio_is_busy(void *dev);
 void mid_hdmi_audio_signal_event(enum had_event_type event);
-int mid_hdmi_audio_setup(had_event_call_back audio_callbacks);
 
 int mid_hdmi_audio_read(u32 reg, u32 *val);
 int mid_hdmi_audio_write(u32 reg, u32 val);

commit 79dda75a2cfc5628f25338122d24ee8789b367cf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 30 17:23:39 2017 +0100

    ALSA: x86: Pass snd_intelhad object to helpers
    
    For reducing the global variable reference, keep snd_intelhad object
    in the context and pass it to each helper.  It's a preliminary change
    for further cleanup.
    
    This also includes the simplification of the probe procedure: the LPE
    platform driver directly gets the created snd_intelhad object by
    hdmi_audio_probe(), and passes it to each helper and destructor,
    hdmi_audio_remove().  The hdmi_audio_probe() function doesn't call the
    back-registration any longer, which is fairly useless.  The LPE
    platform driver initializes the stuff instead at the right place, and
    calls the wq after the object creation in the probe function itself.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 518d897f1806..0d285ce8d4e6 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -648,7 +648,6 @@ struct hdmi_audio_event {
 bool mid_hdmi_audio_is_busy(void *dev);
 void mid_hdmi_audio_signal_event(enum had_event_type event);
 int mid_hdmi_audio_setup(had_event_call_back audio_callbacks);
-int mid_hdmi_audio_register(void *had_data);
 
 int mid_hdmi_audio_read(u32 reg, u32 *val);
 int mid_hdmi_audio_write(u32 reg, u32 val);

commit 6f9ecc76f4e04b111160d789f36a8c5bf1cc9ab6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 30 16:52:06 2017 +0100

    ALSA: x86: Drop snd_intel_had_interface indirect calls
    
    Yet another indirection is killed: at this time, it's
    snd_intel_had_interface.  It contains also the name string, but it's
    nowhere used, thus we can kill it, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 5e925b728302..518d897f1806 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -645,21 +645,10 @@ struct hdmi_audio_event {
 	int type;
 };
 
-struct snd_intel_had_interface {
-	const char *name;
-	int (*query)(void *had_data, struct hdmi_audio_event event);
-	int (*suspend)(void *had_data, struct hdmi_audio_event event);
-	int (*resume)(void *had_data);
-};
-
 bool mid_hdmi_audio_is_busy(void *dev);
-bool mid_hdmi_audio_suspend(void *dev);
-void mid_hdmi_audio_resume(void *dev);
 void mid_hdmi_audio_signal_event(enum had_event_type event);
 int mid_hdmi_audio_setup(had_event_call_back audio_callbacks);
-int mid_hdmi_audio_register(
-	struct snd_intel_had_interface *driver,
-	void *had_data);
+int mid_hdmi_audio_register(void *had_data);
 
 int mid_hdmi_audio_read(u32 reg, u32 *val);
 int mid_hdmi_audio_write(u32 reg, u32 val);

commit 9eca88c881f1c74c7f5dda3c67cb0b4178429e93
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 30 16:37:06 2017 +0100

    ALSA: x86: Replace indirect query_ops with direct calls
    
    Like the previous patch, this replaces the indirect query_ops calls
    via direct function calls.  They are only get_caps and set_caps, so
    fairly straightforward at this time.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index ea90cf919948..5e925b728302 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -641,13 +641,6 @@ enum had_event_type {
 typedef int (*had_event_call_back) (enum had_event_type event_type,
 		void *ctxt_info);
 
-struct hdmi_audio_query_set_ops {
-	int (*hdmi_audio_get_caps)(enum had_caps_list query_element,
-			void *capabilties);
-	int (*hdmi_audio_set_caps)(enum had_caps_list set_element,
-			void *capabilties);
-};
-
 struct hdmi_audio_event {
 	int type;
 };
@@ -663,9 +656,7 @@ bool mid_hdmi_audio_is_busy(void *dev);
 bool mid_hdmi_audio_suspend(void *dev);
 void mid_hdmi_audio_resume(void *dev);
 void mid_hdmi_audio_signal_event(enum had_event_type event);
-int mid_hdmi_audio_setup(
-	had_event_call_back audio_callbacks,
-	struct hdmi_audio_query_set_ops *query_ops);
+int mid_hdmi_audio_setup(had_event_call_back audio_callbacks);
 int mid_hdmi_audio_register(
 	struct snd_intel_had_interface *driver,
 	void *had_data);
@@ -674,4 +665,9 @@ int mid_hdmi_audio_read(u32 reg, u32 *val);
 int mid_hdmi_audio_write(u32 reg, u32 val);
 int mid_hdmi_audio_rmw(u32 reg, u32 val, u32 mask);
 
+int mid_hdmi_audio_get_caps(enum had_caps_list get_element,
+			    void *capabilities);
+int mid_hdmi_audio_set_caps(enum had_caps_list set_element,
+			    void *capabilties);
+
 #endif

commit f23df8071b178dcfa4f6014baf9323ddaa33e1fd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 30 16:29:39 2017 +0100

    ALSA: x86: Replace indirect register ops with direct calls
    
    Now about the indirect register ops: they are replaced with direct
    calls, too.
    
    The read / write / modify ops are simply replaced with the
    corresponding functions.  The difference is that we calculate the
    offset inside the function now.  So all the had_config_offset
    references in the caller side are dropped.  This also simplifies the
    DP-audio check in hdmi_audio_write() and hdmi_audio_rmw().
    
    The hdmi_audio_get_register_base is dropped since it's no longer used
    when the base address and config offset are referred in the read/write
    functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 5d94aaf0b980..ea90cf919948 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -641,15 +641,6 @@ enum had_event_type {
 typedef int (*had_event_call_back) (enum had_event_type event_type,
 		void *ctxt_info);
 
-struct hdmi_audio_registers_ops {
-	int (*hdmi_audio_get_register_base)(u32 **reg_base,
-			u32 *config_offset);
-	int (*hdmi_audio_read_register)(u32 reg_addr, u32 *data);
-	int (*hdmi_audio_write_register)(u32 reg_addr, u32 data);
-	int (*hdmi_audio_read_modify)(u32 reg_addr, u32 data,
-			u32 mask);
-};
-
 struct hdmi_audio_query_set_ops {
 	int (*hdmi_audio_get_caps)(enum had_caps_list query_element,
 			void *capabilties);
@@ -674,10 +665,13 @@ void mid_hdmi_audio_resume(void *dev);
 void mid_hdmi_audio_signal_event(enum had_event_type event);
 int mid_hdmi_audio_setup(
 	had_event_call_back audio_callbacks,
-	struct hdmi_audio_registers_ops *reg_ops,
 	struct hdmi_audio_query_set_ops *query_ops);
 int mid_hdmi_audio_register(
 	struct snd_intel_had_interface *driver,
 	void *had_data);
 
+int mid_hdmi_audio_read(u32 reg, u32 *val);
+int mid_hdmi_audio_write(u32 reg, u32 val);
+int mid_hdmi_audio_rmw(u32 reg, u32 val, u32 mask);
+
 #endif

commit 4812dcc437fbe0ddc2319dae7c31254f57d4ae44
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 30 15:58:15 2017 +0100

    ALSA: x86: Remove v1 ops and structs
    
    The v1 code refers to Medfield/Clovertrail.  It's not used at all in
    the current driver, and probably won't be ever.  Let's clean this up,
    then we can go to the next stage of cleanup tasks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index 3aed89af5b45..5d94aaf0b980 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -358,19 +358,6 @@ struct channel_map_table {
  *
  */
 union aud_cfg {
-	struct {
-		u32 aud_en:1;
-		u32 layout:1;
-		u32 fmt:2;
-		u32 num_ch:2;
-		u32 rsvd0:1;
-		u32 set:1;
-		u32 flat:1;
-		u32 val_bit:1;
-		u32 user_bit:1;
-		u32 underrun:1;
-		u32 rsvd1:20;
-	} cfg_regx;
 	struct {
 		u32 aud_en:1;
 		u32 layout:1;
@@ -438,11 +425,6 @@ union aud_ch_status_1 {
  *
  */
 union aud_hdmi_cts {
-	struct {
-		u32 cts_val:20;
-		u32 en_cts_prog:1;
-		u32 rsvd:11;
-	} cts_regx;
 	struct {
 		u32 cts_val:24;
 		u32 en_cts_prog:1;
@@ -459,11 +441,6 @@ union aud_hdmi_cts {
  *
  */
 union aud_hdmi_n_enable {
-	struct {
-		u32 n_val:20;
-		u32 en_n_prog:1;
-		u32 rsvd:11;
-	} n_regx;
 	struct {
 		u32 n_val:24;
 		u32 en_n_prog:1;
@@ -480,12 +457,6 @@ union aud_hdmi_n_enable {
  *
  */
 union aud_buf_config {
-	struct {
-		u32 fifo_width:8;
-		u32 rsvd0:8;
-		u32 aud_delay:8;
-		u32 rsvd1:8;
-	} buf_cfg_regx;
 	struct {
 		u32 audio_fifo_watermark:8;
 		u32 dma_fifo_watermark:3;

commit 964ca8083c0239b5a729ed08c9f50b6c31ab3a93
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Tue Jan 31 14:16:52 2017 -0600

    ALSA: x86: intel_hdmi: add definitions and logic for DP audio
    
    Imported from legacy patches
    
    Note: the new code doesn't assume a modified ELD but
    an explicit notification that DP is present. It appears
    that the i915 code does change the ELD so we could use
    the ELD-based tests to check for DP audio
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
index ec4bde50dba7..3aed89af5b45 100644
--- a/sound/x86/intel_hdmi_lpe_audio.h
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -31,6 +31,10 @@
 #include <sound/control.h>
 #include <sound/pcm.h>
 
+#define AUD_CONFIG_VALID_BIT			(1<<9)
+#define AUD_CONFIG_DP_MODE			(1<<15)
+#define AUD_CONFIG_BLOCK_BIT			(1<<7)
+
 #define HMDI_LPE_AUDIO_DRIVER_NAME		"intel-hdmi-lpe-audio"
 #define HAD_MAX_DEVICES		1
 #define HAD_MIN_CHANNEL		2
@@ -68,6 +72,29 @@
 #define HAD_MAX_DIP_WORDS		16
 #define INTEL_HAD		"IntelHdmiLpeAudio"
 
+/* DP Link Rates */
+#define DP_2_7_GHZ			270000
+#define DP_1_62_GHZ			162000
+
+/* Maud Values */
+#define AUD_SAMPLE_RATE_32_DP_2_7_MAUD_VAL		1988
+#define AUD_SAMPLE_RATE_44_1_DP_2_7_MAUD_VAL		2740
+#define AUD_SAMPLE_RATE_48_DP_2_7_MAUD_VAL		2982
+#define AUD_SAMPLE_RATE_88_2_DP_2_7_MAUD_VAL		5480
+#define AUD_SAMPLE_RATE_96_DP_2_7_MAUD_VAL		5965
+#define AUD_SAMPLE_RATE_176_4_DP_2_7_MAUD_VAL		10961
+#define HAD_MAX_RATE_DP_2_7_MAUD_VAL			11930
+#define AUD_SAMPLE_RATE_32_DP_1_62_MAUD_VAL		3314
+#define AUD_SAMPLE_RATE_44_1_DP_1_62_MAUD_VAL		4567
+#define AUD_SAMPLE_RATE_48_DP_1_62_MAUD_VAL		4971
+#define AUD_SAMPLE_RATE_88_2_DP_1_62_MAUD_VAL		9134
+#define AUD_SAMPLE_RATE_96_DP_1_62_MAUD_VAL		9942
+#define AUD_SAMPLE_RATE_176_4_DP_1_62_MAUD_VAL		18268
+#define HAD_MAX_RATE_DP_1_62_MAUD_VAL			19884
+
+/* Naud Value */
+#define DP_NAUD_VAL					32768
+
 /* _AUD_CONFIG register MASK */
 #define AUD_CONFIG_MASK_UNDERRUN	0xC0000000
 #define AUD_CONFIG_MASK_SRDBG		0x00000002
@@ -618,6 +645,8 @@ enum hdmi_connector_status {
 enum had_caps_list {
 	HAD_GET_ELD = 1,
 	HAD_GET_DISPLAY_RATE,
+	HAD_GET_DP_OUTPUT,
+	HAD_GET_LINK_RATE,
 	HAD_SET_ENABLE_AUDIO,
 	HAD_SET_DISABLE_AUDIO,
 	HAD_SET_ENABLE_AUDIO_INT,

commit 287599cf2d7719c812774ff49db9ae8ca4fa844a
Author: Jerome Anand <jerome.anand@intel.com>
Date:   Wed Jan 25 04:27:51 2017 +0530

    ALSA: add Intel HDMI LPE audio driver for BYT/CHT-T
    
    On Baytrail and Cherrytrail, HDaudio may be fused out or disabled
    by the BIOS. This driver enables an alternate path to the i915
    display registers and DMA.
    
    Although there is no hardware path between i915 display and LPE/SST
    audio clusters, this HDMI capability is referred to in the documentation
    as "HDMI LPE Audio" so we keep the name for consistency. There is no
    hardware path or control dependencies with the LPE/SST DSP functionality.
    
    The hdmi-lpe-audio driver will be probed when the i915 driver creates
    a child platform device.
    
    Since this driver is neither SoC nor PCI, a new x86 folder is added
    Additional indirections in the code will be cleaned up in the next series
    to aid smoother DP integration
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Jerome Anand <jerome.anand@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/x86/intel_hdmi_lpe_audio.h b/sound/x86/intel_hdmi_lpe_audio.h
new file mode 100644
index 000000000000..ec4bde50dba7
--- /dev/null
+++ b/sound/x86/intel_hdmi_lpe_audio.h
@@ -0,0 +1,683 @@
+/*
+ *   intel_hdmi_lpe_audio.h - Intel HDMI LPE audio driver
+ *
+ *  Copyright (C) 2016 Intel Corp
+ *  Authors:	Sailaja Bandarupalli <sailaja.bandarupalli@intel.com>
+ *		Ramesh Babu K V <ramesh.babu@intel.com>
+ *		Vaibhav Agarwal <vaibhav.agarwal@intel.com>
+ *		Jerome Anand <jerome.anand@intel.com>
+ *		Aravind Siddappaji <aravindx.siddappaji@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#ifndef __INTEL_HDMI_LPE_AUDIO_H
+#define __INTEL_HDMI_LPE_AUDIO_H
+
+#include <linux/types.h>
+#include <sound/initval.h>
+#include <linux/version.h>
+#include <linux/pm_runtime.h>
+#include <sound/asoundef.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+
+#define HMDI_LPE_AUDIO_DRIVER_NAME		"intel-hdmi-lpe-audio"
+#define HAD_MAX_DEVICES		1
+#define HAD_MIN_CHANNEL		2
+#define HAD_MAX_CHANNEL		8
+#define HAD_NUM_OF_RING_BUFS	4
+
+/* Assume 192KHz, 8channel, 25msec period */
+#define HAD_MAX_BUFFER		(600*1024)
+#define HAD_MIN_BUFFER		(32*1024)
+#define HAD_MAX_PERIODS		4
+#define HAD_MIN_PERIODS		4
+#define HAD_MAX_PERIOD_BYTES	(HAD_MAX_BUFFER/HAD_MIN_PERIODS)
+#define HAD_MIN_PERIOD_BYTES	256
+#define HAD_FIFO_SIZE		0 /* fifo not being used */
+#define MAX_SPEAKERS		8
+
+#define AUD_SAMPLE_RATE_32	32000
+#define AUD_SAMPLE_RATE_44_1	44100
+#define AUD_SAMPLE_RATE_48	48000
+#define AUD_SAMPLE_RATE_88_2	88200
+#define AUD_SAMPLE_RATE_96	96000
+#define AUD_SAMPLE_RATE_176_4	176400
+#define AUD_SAMPLE_RATE_192	192000
+
+#define HAD_MIN_RATE		AUD_SAMPLE_RATE_32
+#define HAD_MAX_RATE		AUD_SAMPLE_RATE_192
+
+#define DIS_SAMPLE_RATE_25_2	25200
+#define DIS_SAMPLE_RATE_27	27000
+#define DIS_SAMPLE_RATE_54	54000
+#define DIS_SAMPLE_RATE_74_25	74250
+#define DIS_SAMPLE_RATE_148_5	148500
+#define HAD_REG_WIDTH		0x08
+#define HAD_MAX_HW_BUFS		0x04
+#define HAD_MAX_DIP_WORDS		16
+#define INTEL_HAD		"IntelHdmiLpeAudio"
+
+/* _AUD_CONFIG register MASK */
+#define AUD_CONFIG_MASK_UNDERRUN	0xC0000000
+#define AUD_CONFIG_MASK_SRDBG		0x00000002
+#define AUD_CONFIG_MASK_FUNCRST		0x00000001
+
+#define MAX_CNT			0xFF
+#define HAD_SUSPEND_DELAY	1000
+
+#define OTM_HDMI_ELD_SIZE 128
+
+union otm_hdmi_eld_t {
+	unsigned char eld_data[OTM_HDMI_ELD_SIZE];
+	struct {
+		/* Byte[0] = ELD Version Number */
+		union {
+			unsigned char   byte0;
+			struct {
+				unsigned char reserved:3; /* Reserf */
+				unsigned char eld_ver:5; /* ELD Version Number */
+				/* 00000b - reserved
+				 * 00001b - first rev, obsoleted
+				 * 00010b - version 2, supporting CEA version
+				 *			861D or below
+				 * 00011b:11111b - reserved
+				 * for future
+				 */
+			};
+		};
+
+		/* Byte[1] = Vendor Version Field */
+		union {
+			unsigned char vendor_version;
+			struct {
+				unsigned char reserved1:3;
+				unsigned char veld_ver:5; /* Version number of the ELD
+						     * extension. This value is
+						     * provisioned and unique to
+						     * each vendor.
+						     */
+			};
+		};
+
+		/* Byte[2] = Baseline Length field */
+		unsigned char baseline_eld_length; /* Length of the Baseline structure
+					      *	divided by Four.
+					      */
+
+		/* Byte [3] = Reserved for future use */
+		unsigned char byte3;
+
+		/* Starting of the BaseLine EELD structure
+		 * Byte[4] = Monitor Name Length
+		 */
+		union {
+			unsigned char byte4;
+			struct {
+				unsigned char mnl:5;
+				unsigned char cea_edid_rev_id:3;
+			};
+		};
+
+		/* Byte[5] = Capabilities */
+		union {
+			unsigned char capabilities;
+			struct {
+				unsigned char hdcp:1; /* HDCP support */
+				unsigned char ai_support:1;   /* AI support */
+				unsigned char connection_type:2; /* Connection type
+							    * 00 - HDMI
+							    * 01 - DP
+							    * 10 -11  Reserved
+							    * for future
+							    * connection types
+							    */
+				unsigned char sadc:4; /* Indicates number of 3 bytes
+						 * Short Audio Descriptors.
+						 */
+			};
+		};
+
+		/* Byte[6] = Audio Synch Delay */
+		unsigned char audio_synch_delay; /* Amount of time reported by the
+					    * sink that the video trails audio
+					    * in milliseconds.
+					    */
+
+		/* Byte[7] = Speaker Allocation Block */
+		union {
+			unsigned char speaker_allocation_block;
+			struct {
+				unsigned char flr:1; /*Front Left and Right channels*/
+				unsigned char lfe:1; /*Low Frequency Effect channel*/
+				unsigned char fc:1;  /*Center transmission channel*/
+				unsigned char rlr:1; /*Rear Left and Right channels*/
+				unsigned char rc:1; /*Rear Center channel*/
+				unsigned char flrc:1; /*Front left and Right of Center
+						 *transmission channels
+						 */
+				unsigned char rlrc:1; /*Rear left and Right of Center
+						 *transmission channels
+						 */
+				unsigned char reserved3:1; /* Reserved */
+			};
+		};
+
+		/* Byte[8 - 15] - 8 Byte port identification value */
+		unsigned char port_id_value[8];
+
+		/* Byte[16 - 17] - 2 Byte Manufacturer ID */
+		unsigned char manufacturer_id[2];
+
+		/* Byte[18 - 19] - 2 Byte Product ID */
+		unsigned char product_id[2];
+
+		/* Byte [20-83] - 64 Bytes of BaseLine Data */
+		unsigned char mn_sand_sads[64]; /* This will include
+					   * - ASCII string of Monitor name
+					   * - List of 3 byte SADs
+					   * - Zero padding
+					   */
+
+		/* Vendor ELD Block should continue here!
+		 * No Vendor ELD block defined as of now.
+		 */
+	} __packed;
+};
+
+/**
+ * enum had_status - Audio stream states
+ *
+ * @STREAM_INIT: Stream initialized
+ * @STREAM_RUNNING: Stream running
+ * @STREAM_PAUSED: Stream paused
+ * @STREAM_DROPPED: Stream dropped
+ */
+enum had_stream_status {
+	STREAM_INIT = 0,
+	STREAM_RUNNING = 1,
+	STREAM_PAUSED = 2,
+	STREAM_DROPPED = 3
+};
+
+/**
+ * enum had_status_stream - HAD stream states
+ */
+enum had_status_stream {
+	HAD_INIT = 0,
+	HAD_RUNNING_STREAM,
+};
+
+enum had_drv_status {
+	HAD_DRV_CONNECTED,
+	HAD_DRV_RUNNING,
+	HAD_DRV_DISCONNECTED,
+	HAD_DRV_SUSPENDED,
+	HAD_DRV_ERR,
+};
+
+/* enum intel_had_aud_buf_type - HDMI controller ring buffer types */
+enum intel_had_aud_buf_type {
+	HAD_BUF_TYPE_A = 0,
+	HAD_BUF_TYPE_B = 1,
+	HAD_BUF_TYPE_C = 2,
+	HAD_BUF_TYPE_D = 3,
+};
+
+enum num_aud_ch {
+	CH_STEREO = 0,
+	CH_THREE_FOUR = 1,
+	CH_FIVE_SIX = 2,
+	CH_SEVEN_EIGHT = 3
+};
+
+/* HDMI Controller register offsets - audio domain common */
+/* Base address for below regs = 0x65000 */
+enum hdmi_ctrl_reg_offset_common {
+	AUDIO_HDMI_CONFIG_A	= 0x000,
+	AUDIO_HDMI_CONFIG_B = 0x800,
+	AUDIO_HDMI_CONFIG_C = 0x900,
+};
+/* HDMI controller register offsets */
+enum hdmi_ctrl_reg_offset_v1 {
+	AUD_CONFIG		= 0x0,
+	AUD_CH_STATUS_0		= 0x08,
+	AUD_CH_STATUS_1		= 0x0C,
+	AUD_HDMI_CTS		= 0x10,
+	AUD_N_ENABLE		= 0x14,
+	AUD_SAMPLE_RATE		= 0x18,
+	AUD_BUF_CONFIG		= 0x20,
+	AUD_BUF_CH_SWAP		= 0x24,
+	AUD_BUF_A_ADDR		= 0x40,
+	AUD_BUF_A_LENGTH	= 0x44,
+	AUD_BUF_B_ADDR		= 0x48,
+	AUD_BUF_B_LENGTH	= 0x4c,
+	AUD_BUF_C_ADDR		= 0x50,
+	AUD_BUF_C_LENGTH	= 0x54,
+	AUD_BUF_D_ADDR		= 0x58,
+	AUD_BUF_D_LENGTH	= 0x5c,
+	AUD_CNTL_ST		= 0x60,
+	AUD_HDMI_STATUS		= 0x68,
+	AUD_HDMIW_INFOFR	= 0x114,
+};
+
+/*
+ * Delta changes in HDMI controller register offsets
+ * compare to v1 version
+ */
+
+enum hdmi_ctrl_reg_offset_v2 {
+	AUD_HDMI_STATUS_v2	= 0x64,
+	AUD_HDMIW_INFOFR_v2	= 0x68,
+};
+
+/*
+ *	CEA speaker placement:
+ *
+ *	FL  FLC   FC   FRC   FR
+ *
+ *						LFE
+ *
+ *	RL  RLC   RC   RRC   RR
+ *
+ *	The Left/Right Surround channel _notions_ LS/RS in SMPTE 320M
+ *	corresponds to CEA RL/RR; The SMPTE channel _assignment_ C/LFE is
+ *	swapped to CEA LFE/FC.
+ */
+enum cea_speaker_placement {
+	FL  = (1 <<  0),        /* Front Left           */
+	FC  = (1 <<  1),        /* Front Center         */
+	FR  = (1 <<  2),        /* Front Right          */
+	FLC = (1 <<  3),        /* Front Left Center    */
+	FRC = (1 <<  4),        /* Front Right Center   */
+	RL  = (1 <<  5),        /* Rear Left            */
+	RC  = (1 <<  6),        /* Rear Center          */
+	RR  = (1 <<  7),        /* Rear Right           */
+	RLC = (1 <<  8),        /* Rear Left Center     */
+	RRC = (1 <<  9),        /* Rear Right Center    */
+	LFE = (1 << 10),        /* Low Frequency Effect */
+};
+
+struct cea_channel_speaker_allocation {
+	int ca_index;
+	int speakers[8];
+
+	/* derived values, just for convenience */
+	int channels;
+	int spk_mask;
+};
+
+struct channel_map_table {
+	unsigned char map;              /* ALSA API channel map position */
+	unsigned char cea_slot;         /* CEA slot value */
+	int spk_mask;                   /* speaker position bit mask */
+};
+
+/**
+ * union aud_cfg - Audio configuration
+ *
+ * @cfg_regx: individual register bits
+ * @cfg_regval: full register value
+ *
+ */
+union aud_cfg {
+	struct {
+		u32 aud_en:1;
+		u32 layout:1;
+		u32 fmt:2;
+		u32 num_ch:2;
+		u32 rsvd0:1;
+		u32 set:1;
+		u32 flat:1;
+		u32 val_bit:1;
+		u32 user_bit:1;
+		u32 underrun:1;
+		u32 rsvd1:20;
+	} cfg_regx;
+	struct {
+		u32 aud_en:1;
+		u32 layout:1;
+		u32 fmt:2;
+		u32 num_ch:3;
+		u32 set:1;
+		u32 flat:1;
+		u32 val_bit:1;
+		u32 user_bit:1;
+		u32 underrun:1;
+		u32 packet_mode:1;
+		u32 left_align:1;
+		u32 bogus_sample:1;
+		u32 dp_modei:1;
+		u32 rsvd:16;
+	} cfg_regx_v2;
+	u32 cfg_regval;
+};
+
+/**
+ * union aud_ch_status_0 - Audio Channel Status 0 Attributes
+ *
+ * @status_0_regx:individual register bits
+ * @status_0_regval:full register value
+ *
+ */
+union aud_ch_status_0 {
+	struct {
+		u32 ch_status:1;
+		u32 lpcm_id:1;
+		u32 cp_info:1;
+		u32 format:3;
+		u32 mode:2;
+		u32 ctg_code:8;
+		u32 src_num:4;
+		u32 ch_num:4;
+		u32 samp_freq:4;
+		u32 clk_acc:2;
+		u32 rsvd:2;
+	} status_0_regx;
+	u32 status_0_regval;
+};
+
+/**
+ * union aud_ch_status_1 - Audio Channel Status 1 Attributes
+ *
+ * @status_1_regx: individual register bits
+ * @status_1_regval: full register value
+ *
+ */
+union aud_ch_status_1 {
+	struct {
+		u32 max_wrd_len:1;
+		u32 wrd_len:3;
+		u32 rsvd:28;
+		} status_1_regx;
+	u32 status_1_regval;
+};
+
+/**
+ * union aud_hdmi_cts - CTS register
+ *
+ * @cts_regx: individual register bits
+ * @cts_regval: full register value
+ *
+ */
+union aud_hdmi_cts {
+	struct {
+		u32 cts_val:20;
+		u32 en_cts_prog:1;
+		u32 rsvd:11;
+	} cts_regx;
+	struct {
+		u32 cts_val:24;
+		u32 en_cts_prog:1;
+		u32 rsvd:7;
+	} cts_regx_v2;
+	u32 cts_regval;
+};
+
+/**
+ * union aud_hdmi_n_enable - N register
+ *
+ * @n_regx: individual register bits
+ * @n_regval: full register value
+ *
+ */
+union aud_hdmi_n_enable {
+	struct {
+		u32 n_val:20;
+		u32 en_n_prog:1;
+		u32 rsvd:11;
+	} n_regx;
+	struct {
+		u32 n_val:24;
+		u32 en_n_prog:1;
+		u32 rsvd:7;
+	} n_regx_v2;
+	u32 n_regval;
+};
+
+/**
+ * union aud_buf_config -  Audio Buffer configurations
+ *
+ * @buf_cfg_regx: individual register bits
+ * @buf_cfgval: full register value
+ *
+ */
+union aud_buf_config {
+	struct {
+		u32 fifo_width:8;
+		u32 rsvd0:8;
+		u32 aud_delay:8;
+		u32 rsvd1:8;
+	} buf_cfg_regx;
+	struct {
+		u32 audio_fifo_watermark:8;
+		u32 dma_fifo_watermark:3;
+		u32 rsvd0:5;
+		u32 aud_delay:8;
+		u32 rsvd1:8;
+	} buf_cfg_regx_v2;
+	u32 buf_cfgval;
+};
+
+/**
+ * union aud_buf_ch_swap - Audio Sample Swapping offset
+ *
+ * @buf_ch_swap_regx: individual register bits
+ * @buf_ch_swap_val: full register value
+ *
+ */
+union aud_buf_ch_swap {
+	struct {
+		u32 first_0:3;
+		u32 second_0:3;
+		u32 first_1:3;
+		u32 second_1:3;
+		u32 first_2:3;
+		u32 second_2:3;
+		u32 first_3:3;
+		u32 second_3:3;
+		u32 rsvd:8;
+	} buf_ch_swap_regx;
+	u32 buf_ch_swap_val;
+};
+
+/**
+ * union aud_buf_addr - Address for Audio Buffer
+ *
+ * @buf_addr_regx: individual register bits
+ * @buf_addr_val: full register value
+ *
+ */
+union aud_buf_addr {
+	struct {
+		u32 valid:1;
+		u32 intr_en:1;
+		u32 rsvd:4;
+		u32 addr:26;
+	} buf_addr_regx;
+	u32 buf_addr_val;
+};
+
+/**
+ * union aud_buf_len - Length of Audio Buffer
+ *
+ * @buf_len_regx: individual register bits
+ * @buf_len_val: full register value
+ *
+ */
+union aud_buf_len {
+	struct {
+		u32 buf_len:20;
+		u32 rsvd:12;
+	} buf_len_regx;
+	u32 buf_len_val;
+};
+
+/**
+ * union aud_ctrl_st - Audio Control State Register offset
+ *
+ * @ctrl_regx: individual register bits
+ * @ctrl_val: full register value
+ *
+ */
+union aud_ctrl_st {
+	struct {
+		u32 ram_addr:4;
+		u32 eld_ack:1;
+		u32 eld_addr:4;
+		u32 eld_buf_size:5;
+		u32 eld_valid:1;
+		u32 cp_ready:1;
+		u32 dip_freq:2;
+		u32 dip_idx:3;
+		u32 dip_en_sta:4;
+		u32 rsvd:7;
+	} ctrl_regx;
+	u32 ctrl_val;
+};
+
+/**
+ * union aud_info_frame1 - Audio HDMI Widget Data Island Packet offset
+ *
+ * @fr1_regx: individual register bits
+ * @fr1_val: full register value
+ *
+ */
+union aud_info_frame1 {
+	struct {
+		u32 pkt_type:8;
+		u32 ver_num:8;
+		u32 len:5;
+		u32 rsvd:11;
+	} fr1_regx;
+	u32 fr1_val;
+};
+
+/**
+ * union aud_info_frame2 - DIP frame 2
+ *
+ * @fr2_regx: individual register bits
+ * @fr2_val: full register value
+ *
+ */
+union aud_info_frame2 {
+	struct {
+		u32 chksum:8;
+		u32 chnl_cnt:3;
+		u32 rsvd0:1;
+		u32 coding_type:4;
+		u32 smpl_size:2;
+		u32 smpl_freq:3;
+		u32 rsvd1:3;
+		u32 format:8;
+	} fr2_regx;
+	u32 fr2_val;
+};
+
+/**
+ * union aud_info_frame3 - DIP frame 3
+ *
+ * @fr3_regx: individual register bits
+ * @fr3_val: full register value
+ *
+ */
+union aud_info_frame3 {
+	struct {
+		u32 chnl_alloc:8;
+		u32 rsvd0:3;
+		u32 lsv:4;
+		u32 dm_inh:1;
+		u32 rsvd1:16;
+	} fr3_regx;
+	u32 fr3_val;
+};
+
+enum hdmi_connector_status {
+	hdmi_connector_status_connected = 1,
+	hdmi_connector_status_disconnected = 2,
+	hdmi_connector_status_unknown = 3,
+};
+
+#define HDMI_AUDIO_UNDERRUN     (1UL<<31)
+#define HDMI_AUDIO_BUFFER_DONE  (1UL<<29)
+
+
+#define PORT_ENABLE			(1 << 31)
+#define SDVO_AUDIO_ENABLE	(1 << 6)
+
+enum had_caps_list {
+	HAD_GET_ELD = 1,
+	HAD_GET_DISPLAY_RATE,
+	HAD_SET_ENABLE_AUDIO,
+	HAD_SET_DISABLE_AUDIO,
+	HAD_SET_ENABLE_AUDIO_INT,
+	HAD_SET_DISABLE_AUDIO_INT,
+};
+
+enum had_event_type {
+	HAD_EVENT_HOT_PLUG = 1,
+	HAD_EVENT_HOT_UNPLUG,
+	HAD_EVENT_MODE_CHANGING,
+	HAD_EVENT_AUDIO_BUFFER_DONE,
+	HAD_EVENT_AUDIO_BUFFER_UNDERRUN,
+	HAD_EVENT_QUERY_IS_AUDIO_BUSY,
+	HAD_EVENT_QUERY_IS_AUDIO_SUSPENDED,
+};
+
+/*
+ * HDMI Display Controller Audio Interface
+ *
+ */
+typedef int (*had_event_call_back) (enum had_event_type event_type,
+		void *ctxt_info);
+
+struct hdmi_audio_registers_ops {
+	int (*hdmi_audio_get_register_base)(u32 **reg_base,
+			u32 *config_offset);
+	int (*hdmi_audio_read_register)(u32 reg_addr, u32 *data);
+	int (*hdmi_audio_write_register)(u32 reg_addr, u32 data);
+	int (*hdmi_audio_read_modify)(u32 reg_addr, u32 data,
+			u32 mask);
+};
+
+struct hdmi_audio_query_set_ops {
+	int (*hdmi_audio_get_caps)(enum had_caps_list query_element,
+			void *capabilties);
+	int (*hdmi_audio_set_caps)(enum had_caps_list set_element,
+			void *capabilties);
+};
+
+struct hdmi_audio_event {
+	int type;
+};
+
+struct snd_intel_had_interface {
+	const char *name;
+	int (*query)(void *had_data, struct hdmi_audio_event event);
+	int (*suspend)(void *had_data, struct hdmi_audio_event event);
+	int (*resume)(void *had_data);
+};
+
+bool mid_hdmi_audio_is_busy(void *dev);
+bool mid_hdmi_audio_suspend(void *dev);
+void mid_hdmi_audio_resume(void *dev);
+void mid_hdmi_audio_signal_event(enum had_event_type event);
+int mid_hdmi_audio_setup(
+	had_event_call_back audio_callbacks,
+	struct hdmi_audio_registers_ops *reg_ops,
+	struct hdmi_audio_query_set_ops *query_ops);
+int mid_hdmi_audio_register(
+	struct snd_intel_had_interface *driver,
+	void *had_data);
+
+#endif
