commit c7cd7c748a3250ca33509f9235efab9c803aca09
Author: Wenwen Wang <wenwen@cs.uga.edu>
Date:   Thu Aug 8 00:15:21 2019 -0500

    sound: fix a memory leak bug
    
    In sound_insert_unit(), the controlling structure 's' is allocated through
    kmalloc(). Then it is added to the sound driver list by invoking
    __sound_insert_unit(). Later on, if __register_chrdev() fails, 's' is
    removed from the list through __sound_remove_unit(). If 'index' is not less
    than 0, -EBUSY is returned to indicate the error. However, 's' is not
    deallocated on this execution path, leading to a memory leak bug.
    
    To fix the above issue, free 's' before -EBUSY is returned.
    
    Signed-off-by: Wenwen Wang <wenwen@cs.uga.edu>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index b730d97c4de6..90d118cd9164 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -275,7 +275,8 @@ static int sound_insert_unit(struct sound_unit **list, const struct file_operati
 				goto retry;
 			}
 			spin_unlock(&sound_loader_lock);
-			return -EBUSY;
+			r = -EBUSY;
+			goto fail;
 		}
 	}
 

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 40ad000c2e3c..b730d97c4de6 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *	Sound core.  This file is composed of two parts.  sound_class
  *	which is common to both OSS and ALSA and OSS sound core which
@@ -73,12 +74,6 @@ module_exit(cleanup_soundcore);
  *
  *	Fixes:
  *
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License
- *	as published by the Free Software Foundation; either version
- *	2 of the License, or (at your option) any later version.
- *
  *                         --------------------
  * 
  *	Top level handler for the sound subsystem. Various devices can

commit 6a73cf46ce9d1b382ea14d74ce4bc9aa0c52337a
Author: Joe Perches <joe@perches.com>
Date:   Wed May 23 12:20:59 2018 -0700

    sound: Use octal not symbolic permissions
    
    Convert the S_<FOO> symbolic permissions to their octal equivalents as
    using octal and not symbolic permissions is preferred by many as more
    readable.
    
    see: https://lkml.org/lkml/2016/8/2/1945
    
    Done with automated conversion via:
    $ ./scripts/checkpatch.pl -f --types=SYMBOLIC_PERMS --fix-inplace <files...>
    
    Miscellanea:
    
    o Wrapped one multi-line call to a single line
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index b4efb22db561..40ad000c2e3c 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -413,7 +413,7 @@ int register_sound_special_device(const struct file_operations *fops, int unit,
 		break;
 	}
 	return sound_insert_unit(&chains[chain], fops, -1, unit, max_unit,
-				 name, S_IRUSR | S_IWUSR, dev);
+				 name, 0600, dev);
 }
  
 EXPORT_SYMBOL(register_sound_special_device);
@@ -440,7 +440,7 @@ EXPORT_SYMBOL(register_sound_special);
 int register_sound_mixer(const struct file_operations *fops, int dev)
 {
 	return sound_insert_unit(&chains[0], fops, dev, 0, 128,
-				 "mixer", S_IRUSR | S_IWUSR, NULL);
+				 "mixer", 0600, NULL);
 }
 
 EXPORT_SYMBOL(register_sound_mixer);
@@ -468,7 +468,7 @@ EXPORT_SYMBOL(register_sound_mixer);
 int register_sound_dsp(const struct file_operations *fops, int dev)
 {
 	return sound_insert_unit(&chains[3], fops, dev, 3, 131,
-				 "dsp", S_IWUSR | S_IRUSR, NULL);
+				 "dsp", 0600, NULL);
 }
 
 EXPORT_SYMBOL(register_sound_dsp);

commit 8ac60e733f7c9c41e4c125619a2f8390aca9d4db
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 11 17:10:34 2018 +0100

    sound: Remove leftover msnd init declarations
    
    Some obsoleted functions are still declared in sound_core.c.
    Get rid of them.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 8b026b66cf18..b4efb22db561 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -119,13 +119,6 @@ struct sound_unit
 	char name[32];
 };
 
-#ifdef CONFIG_SOUND_MSNDCLAS
-extern int msnd_classic_init(void);
-#endif
-#ifdef CONFIG_SOUND_MSNDPIN
-extern int msnd_pinnacle_init(void);
-#endif
-
 /*
  * By default, OSS sound_core claims full legacy minor range (0-255)
  * of SOUND_MAJOR to trap open attempts to any sound minor and

commit 4d885f2d3b778681f22ab7df9b4ccd104ffcd7f4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 11 17:05:23 2018 +0100

    sound: Remove unused register_sound_midi() and co
    
    These helpers are no longer used after the removal of the legacy OSS
    drivers.  Let's clean up.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 99b73c675743..8b026b66cf18 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -452,26 +452,6 @@ int register_sound_mixer(const struct file_operations *fops, int dev)
 
 EXPORT_SYMBOL(register_sound_mixer);
 
-/**
- *	register_sound_midi - register a midi device
- *	@fops: File operations for the driver
- *	@dev: Unit number to allocate
- *
- *	Allocate a midi device. Unit is the number of the midi device requested.
- *	Pass -1 to request the next free midi unit.
- *
- *	Return: On success, the allocated number is returned. On failure,
- *	a negative error code is returned.
- */
-
-int register_sound_midi(const struct file_operations *fops, int dev)
-{
-	return sound_insert_unit(&chains[2], fops, dev, 2, 130,
-				 "midi", S_IRUSR | S_IWUSR, NULL);
-}
-
-EXPORT_SYMBOL(register_sound_midi);
-
 /*
  *	DSP's are registered as a triple. Register only one and cheat
  *	in open - see below.
@@ -532,21 +512,6 @@ void unregister_sound_mixer(int unit)
 
 EXPORT_SYMBOL(unregister_sound_mixer);
 
-/**
- *	unregister_sound_midi - unregister a midi device
- *	@unit: unit number to allocate
- *
- *	Release a sound device that was allocated with register_sound_midi().
- *	The unit passed is the return value from the register function.
- */
-
-void unregister_sound_midi(int unit)
-{
-	sound_remove_unit(&chains[2], unit);
-}
-
-EXPORT_SYMBOL(unregister_sound_midi);
-
 /**
  *	unregister_sound_dsp - unregister a DSP device
  *	@unit: unit number to allocate

commit cb68429d155507ec46f1922d2beb7bc637de4836
Author: Alexey Khoroshilov <khoroshilov@ispras.ru>
Date:   Sat Nov 7 01:56:05 2015 +0300

    sound: fix check for error condition of register_chrdev()
    
    init_oss_soundcore() compares returned value of register_chrdev()
    with -1, while other error codes can be returned.
    
    Found by Linux Driver Verification project (linuxtesting.org).
    
    Signed-off-by: Alexey Khoroshilov <khoroshilov@ispras.ru>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 11e953a1fa45..99b73c675743 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -655,7 +655,7 @@ static void cleanup_oss_soundcore(void)
 static int __init init_oss_soundcore(void)
 {
 	if (preclaim_oss &&
-	    register_chrdev(SOUND_MAJOR, "sound", &soundcore_fops) == -1) {
+	    register_chrdev(SOUND_MAJOR, "sound", &soundcore_fops) < 0) {
 		printk(KERN_ERR "soundcore: sound device already in use.\n");
 		return -EBUSY;
 	}

commit e84f9e57b90ca89664d733a7cef19aa7ccd832f3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Sep 22 14:17:15 2013 -0400

    consolidate the reassignments of ->f_op in ->open() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 45759f4cca75..11e953a1fa45 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -626,31 +626,20 @@ static int soundcore_open(struct inode *inode, struct file *file)
 		if (s)
 			new_fops = fops_get(s->unit_fops);
 	}
+	spin_unlock(&sound_loader_lock);
 	if (new_fops) {
 		/*
 		 * We rely upon the fact that we can't be unloaded while the
-		 * subdriver is there, so if ->open() is successful we can
-		 * safely drop the reference counter and if it is not we can
-		 * revert to old ->f_op. Ugly, indeed, but that's the cost of
-		 * switching ->f_op in the first place.
+		 * subdriver is there.
 		 */
 		int err = 0;
-		const struct file_operations *old_fops = file->f_op;
-		file->f_op = new_fops;
-		spin_unlock(&sound_loader_lock);
+		replace_fops(file, new_fops);
 
 		if (file->f_op->open)
 			err = file->f_op->open(inode,file);
 
-		if (err) {
-			fops_put(file->f_op);
-			file->f_op = fops_get(old_fops);
-		}
-
-		fops_put(old_fops);
 		return err;
 	}
-	spin_unlock(&sound_loader_lock);
 	return -ENODEV;
 }
 

commit 02aa2a37636c8fa4fb9322d91be46ff8225b7de0
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jul 3 15:04:56 2013 -0700

    drivers: avoid format string in dev_set_name
    
    Calling dev_set_name with a single paramter causes it to be handled as a
    format string.  Many callers are passing potentially dynamic string
    content, so use "%s" in those cases to avoid any potential accidents,
    including wrappers like device_create*() and bdi_register().
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 359753fc24e1..45759f4cca75 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -292,7 +292,7 @@ static int sound_insert_unit(struct sound_unit **list, const struct file_operati
 	}
 
 	device_create(sound_class, dev, MKDEV(SOUND_MAJOR, s->unit_minor),
-		      NULL, s->name+6);
+		      NULL, "%s", s->name+6);
 	return s->unit_minor;
 
 fail:

commit eb7c06e8e9c93b495e355421cffd3c43c266d7d2
Author: Yacine Belkadi <yacine.belkadi.1@gmail.com>
Date:   Mon Mar 11 22:05:14 2013 +0100

    ALSA: add/change some comments describing function return values
    
    script/kernel-doc reports the following type of warnings (when run in verbose
    mode):
    
    Warning(sound/core/init.c:152): No description found for return value of
    'snd_card_create'
    
    To fix that:
    - add missing descriptions of function return values
    - use "Return:" sections to describe those return values
    
    Along the way:
    - complete some descriptions
    - fix some typos
    
    Signed-off-by: Yacine Belkadi <yacine.belkadi.1@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index bb23009edc8d..359753fc24e1 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -352,7 +352,9 @@ static struct sound_unit *chains[SOUND_STEP];
  *      @dev: device pointer
  *
  *	Allocate a special sound device by minor number from the sound
- *	subsystem. The allocated number is returned on success. On failure
+ *	subsystem.
+ *
+ *	Return: The allocated number is returned on success. On failure,
  *	a negative error code is returned.
  */
  
@@ -436,8 +438,10 @@ EXPORT_SYMBOL(register_sound_special);
  *	@dev: Unit number to allocate
  *
  *	Allocate a mixer device. Unit is the number of the mixer requested.
- *	Pass -1 to request the next free mixer unit. On success the allocated
- *	number is returned, on failure a negative error code is returned.
+ *	Pass -1 to request the next free mixer unit.
+ *
+ *	Return: On success, the allocated number is returned. On failure,
+ *	a negative error code is returned.
  */
 
 int register_sound_mixer(const struct file_operations *fops, int dev)
@@ -454,8 +458,10 @@ EXPORT_SYMBOL(register_sound_mixer);
  *	@dev: Unit number to allocate
  *
  *	Allocate a midi device. Unit is the number of the midi device requested.
- *	Pass -1 to request the next free midi unit. On success the allocated
- *	number is returned, on failure a negative error code is returned.
+ *	Pass -1 to request the next free midi unit.
+ *
+ *	Return: On success, the allocated number is returned. On failure,
+ *	a negative error code is returned.
  */
 
 int register_sound_midi(const struct file_operations *fops, int dev)
@@ -477,11 +483,13 @@ EXPORT_SYMBOL(register_sound_midi);
  *	@dev: Unit number to allocate
  *
  *	Allocate a DSP device. Unit is the number of the DSP requested.
- *	Pass -1 to request the next free DSP unit. On success the allocated
- *	number is returned, on failure a negative error code is returned.
+ *	Pass -1 to request the next free DSP unit.
  *
  *	This function allocates both the audio and dsp device entries together
  *	and will always allocate them as a matching pair - eg dsp3/audio3
+ *
+ *	Return: On success, the allocated number is returned. On failure,
+ *	a negative error code is returned.
  */
 
 int register_sound_dsp(const struct file_operations *fops, int dev)

commit 8f6e60419645f7fea84c361ca2c16dd1feee08e4
Author: Tao Ma <boyu.mt@taobao.com>
Date:   Mon Dec 17 15:59:37 2012 -0800

    sound: remove reference to feature-removal-schedule.txt
    
    In commit 9c0ece069b32 ("Get rid of Documentation/feature-removal.txt"),
    Linus removed feature-removal-schedule.txt from Documentation, but there
    is still some reference to this file.  So remove them.
    
    Signed-off-by: Tao Ma <boyu.mt@taobao.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index fb9255cca214..bb23009edc8d 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -146,8 +146,7 @@ extern int msnd_pinnacle_init(void);
  * devices only the standard chrdev aliases are requested.
  *
  * All these clutters are scheduled to be removed along with
- * sound-slot/service-* module aliases.  Please take a look at
- * feature-removal-schedule.txt for details.
+ * sound-slot/service-* module aliases.
  */
 #ifdef CONFIG_SOUND_OSS_CORE_PRECLAIM
 static int preclaim_oss = 1;

commit 2abb80176cd80ad8e939ead9c785ac17dc9890a4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 8 17:27:03 2012 +0200

    sound: allow the unit search until 256 in sound_core.c
    
    The upper limit of the available minors isn't necessarily 128 + unit,
    but it's rather up to 256.  Fixing this allows more than 8 devices.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index c6e81fb928e9..fb9255cca214 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -361,7 +361,7 @@ int register_sound_special_device(const struct file_operations *fops, int unit,
 				  struct device *dev)
 {
 	const int chain = unit % SOUND_STEP;
-	int max_unit = 128 + chain;
+	int max_unit = 256;
 	const char *name;
 	char _name[16];
 

commit 2c9ede55ecec58099b72e4bb8eab719f32f72c31
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 23 20:24:48 2011 -0400

    switch device_get_devnode() and ->devnode() to umode_t *
    
    both callers of device_get_devnode() are only interested in lower 16bits
    and nobody tries to return anything wider than 16bit anyway.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 6ce277860fd7..c6e81fb928e9 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -29,7 +29,7 @@ MODULE_DESCRIPTION("Core sound module");
 MODULE_AUTHOR("Alan Cox");
 MODULE_LICENSE("GPL");
 
-static char *sound_devnode(struct device *dev, mode_t *mode)
+static char *sound_devnode(struct device *dev, umode_t *mode)
 {
 	if (MAJOR(dev->devt) == SOUND_MAJOR)
 		return NULL;

commit 848669da3a92fa6ab815e0517af3294afb3ea928
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 9 17:33:48 2011 +0100

    sound: Use sound_register_*() for additional OSS minor devices
    
    Since OSS driver creates the device entries for /dev/audio* and
    /dev/dspW* by itself without coping with sound_core, it leads to
    conflicts with others and let sysfs spewing warnings.
    
    This patch rewrites the registration part of OSS driver to use
    the standard method also for additional minor devices.
    
    Reported-by: Steven Rostedt <rostedt@goodmis.org> (with ktest.pl)
    Tested-by: Steven Rostedt <rostedt@goodmis.org> (with ktest.pl)
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 5580aced8730..6ce277860fd7 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -384,6 +384,9 @@ int register_sound_special_device(const struct file_operations *fops, int unit,
 	    case 4:
 		name = "audio";
 		break;
+	    case 5:
+		name = "dspW";
+		break;
 	    case 8:
 		name = "sequencer2";
 		if (unit >= SOUND_STEP)

commit 451a3c24b0135bce54542009b5fde43846c7cf67
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 17 16:26:55 2010 +0100

    BKL: remove extraneous #include <smp_lock.h>
    
    The big kernel lock has been removed from all these files at some point,
    leaving only the #include.
    
    Remove this too as a cleanup.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index c03bbaefdbc3..5580aced8730 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -104,7 +104,6 @@ module_exit(cleanup_soundcore);
 
 #include <linux/init.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/sound.h>

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index cb61317df509..c03bbaefdbc3 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -165,6 +165,7 @@ static const struct file_operations soundcore_fops =
 	/* We must have an owner or the module locking fails */
 	.owner	= THIS_MODULE,
 	.open	= soundcore_open,
+	.llseek = noop_llseek,
 };
 
 /*

commit 90dc763fef4c869e60b2a7ad92e1a7dab68575ea
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Jul 11 12:16:36 2010 +0200

    sound: push BKL into open functions
    
    This moves the lock_kernel() call from soundcore_open
    to the individual OSS device drivers, where we can deal
    with it one driver at a time if needed, or just kill
    off the drivers.
    
    All core components in ALSA already provide
    adequate locking in their open()-functions
    and do not require the big kernel lock, so
    there is no need to add the BKL there.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index c8627fcd4900..cb61317df509 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -629,12 +629,8 @@ static int soundcore_open(struct inode *inode, struct file *file)
 		file->f_op = new_fops;
 		spin_unlock(&sound_loader_lock);
 
-		if (file->f_op->open) {
-			/* TODO: push down BKL into indivial open functions */
-			lock_kernel();
+		if (file->f_op->open)
 			err = file->f_op->open(inode,file);
-			unlock_kernel();
-		}
 
 		if (err) {
 			fops_put(file->f_op);

commit 171d9f7d786681e76bb289d01d8f897cbc50de57
Author: John Kacur <jkacur@redhat.com>
Date:   Sun Jul 4 00:02:31 2010 +0200

    soundcore_open: Reduce the area BKL coverage
    
    Most of this function is protected by the sound_loader_lock.
    We can push down the BKL to this call out err = file->f_op->open(inode,file);
    
    In order to build the sound core without the BKL, we
    will need to push the lock_kernel() call into the ~20
    device drivers that register their file operations.
    
    Signed-off-by: John Kacur <jkacur@redhat.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 7c2d677a2df5..c8627fcd4900 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -576,8 +576,6 @@ static int soundcore_open(struct inode *inode, struct file *file)
 	struct sound_unit *s;
 	const struct file_operations *new_fops = NULL;
 
-	lock_kernel ();
-
 	chain=unit&0x0F;
 	if(chain==4 || chain==5)	/* dsp/audio/dsp16 */
 	{
@@ -630,18 +628,23 @@ static int soundcore_open(struct inode *inode, struct file *file)
 		const struct file_operations *old_fops = file->f_op;
 		file->f_op = new_fops;
 		spin_unlock(&sound_loader_lock);
-		if(file->f_op->open)
+
+		if (file->f_op->open) {
+			/* TODO: push down BKL into indivial open functions */
+			lock_kernel();
 			err = file->f_op->open(inode,file);
+			unlock_kernel();
+		}
+
 		if (err) {
 			fops_put(file->f_op);
 			file->f_op = fops_get(old_fops);
 		}
+
 		fops_put(old_fops);
-		unlock_kernel();
 		return err;
 	}
 	spin_unlock(&sound_loader_lock);
-	unlock_kernel();
 	return -ENODEV;
 }
 

commit c181a13a41ef32c9037393f4b42b780e1a36eb91
Author: Thadeu Lima de Souza Cascardo <cascardo@holoscopio.com>
Date:   Tue Jan 12 20:20:39 2010 -0200

    ALSA: use subsys_initcall for sound core instead of module_init
    
    This is needed for built-in drivers which are built before the sound directory,
    like thinkpad_acpi.
    
    Otherwise, registering a card fails.
    
    Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@holoscopio.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index dbca7c909a31..7c2d677a2df5 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -61,7 +61,7 @@ static void __exit cleanup_soundcore(void)
 	class_destroy(sound_class);
 }
 
-module_init(init_soundcore);
+subsys_initcall(init_soundcore);
 module_exit(cleanup_soundcore);
 
 

commit af901ca181d92aac3a7dc265144a9081a86d8f39
Author: André Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:05 2009 -0200

    tree-wide: fix assorted typos all over the place
    
    That is "success", "unknown", "through", "performance", "[re|un]mapping"
    , "access", "default", "reasonable", "[con]currently", "temperature"
    , "channel", "[un]used", "application", "example","hierarchy", "therefore"
    , "[over|under]flow", "contiguous", "threshold", "enough" and others.
    
    Signed-off-by: André Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 49c998186592..dbca7c909a31 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -353,7 +353,7 @@ static struct sound_unit *chains[SOUND_STEP];
  *      @dev: device pointer
  *
  *	Allocate a special sound device by minor number from the sound
- *	subsystem. The allocated number is returned on succes. On failure
+ *	subsystem. The allocated number is returned on success. On failure
  *	a negative error code is returned.
  */
  

commit e454cea20bdcff10ee698d11b8882662a0153a47
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Sep 18 23:01:12 2009 +0200

    Driver-Core: extend devnode callbacks to provide permissions
    
    This allows subsytems to provide devtmpfs with non-default permissions
    for the device node. Instead of the default mode of 0600, null, zero,
    random, urandom, full, tty, ptmx now have a mode of 0666, which allows
    non-privileged processes to access standard device nodes in case no
    other userspace process applies the expected permissions.
    
    This also fixes a wrong assignment in pktcdvd and a checkpatch.pl complain.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index bb4b88e606bb..49c998186592 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -29,7 +29,7 @@ MODULE_DESCRIPTION("Core sound module");
 MODULE_AUTHOR("Alan Cox");
 MODULE_LICENSE("GPL");
 
-static char *sound_nodename(struct device *dev)
+static char *sound_devnode(struct device *dev, mode_t *mode)
 {
 	if (MAJOR(dev->devt) == SOUND_MAJOR)
 		return NULL;
@@ -50,7 +50,7 @@ static int __init init_soundcore(void)
 		return PTR_ERR(sound_class);
 	}
 
-	sound_class->nodename = sound_nodename;
+	sound_class->devnode = sound_devnode;
 
 	return 0;
 }

commit 93fe4483e6fd3e71d17cd919de14b3b1f9eb3795
Author: Tejun Heo <teheo@suse.de>
Date:   Thu Aug 6 18:14:26 2009 +0900

    sound: make OSS device number claiming optional and schedule its removal
    
    If any OSS support is enabled, regardless of built-in or module,
    sound_core claims full OSS major number (that is, the old 0-255
    region) to trap open attempts and request sound modules using custom
    module aliases.  This feature is redundant as chrdev already has such
    mechanism.  This preemptive claiming prevents alternative OSS
    implementation.
    
    The custom module aliases are scheduled to be removed and the previous
    patch made soundcore emit the standard chrdev aliases too to help
    transition.
    
    This patch schedule the feature for removal in a year and makes it
    optional so that developers and distros can try new things in the
    meantime without rebuilding the kernel.  The pre-claiming can be
    turned off by using SOUND_OSS_CORE_PRECLAIM and/or kernel parameter
    soundcore.preclaim_oss.
    
    As this allows sound minors to be individually grabbed by other users,
    this patch updates sound_insert_unit() such that if registering
    individual device region fails, it tries the next available slot.
    
    For details on removal plan, please read the entry added by this patch
    in feature-removal-schedule.txt .
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 786067c49b01..bb4b88e606bb 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -127,6 +127,46 @@ extern int msnd_classic_init(void);
 extern int msnd_pinnacle_init(void);
 #endif
 
+/*
+ * By default, OSS sound_core claims full legacy minor range (0-255)
+ * of SOUND_MAJOR to trap open attempts to any sound minor and
+ * requests modules using custom sound-slot/service-* module aliases.
+ * The only benefit of doing this is allowing use of custom module
+ * aliases instead of the standard char-major-* ones.  This behavior
+ * prevents alternative OSS implementation and is scheduled to be
+ * removed.
+ *
+ * CONFIG_SOUND_OSS_CORE_PRECLAIM and soundcore.preclaim_oss kernel
+ * parameter are added to allow distros and developers to try and
+ * switch to alternative implementations without needing to rebuild
+ * the kernel in the meantime.  If preclaim_oss is non-zero, the
+ * kernel will behave the same as before.  All SOUND_MAJOR minors are
+ * preclaimed and the custom module aliases along with standard chrdev
+ * ones are emitted if a missing device is opened.  If preclaim_oss is
+ * zero, sound_core only grabs what's actually in use and for missing
+ * devices only the standard chrdev aliases are requested.
+ *
+ * All these clutters are scheduled to be removed along with
+ * sound-slot/service-* module aliases.  Please take a look at
+ * feature-removal-schedule.txt for details.
+ */
+#ifdef CONFIG_SOUND_OSS_CORE_PRECLAIM
+static int preclaim_oss = 1;
+#else
+static int preclaim_oss = 0;
+#endif
+
+module_param(preclaim_oss, int, 0444);
+
+static int soundcore_open(struct inode *, struct file *);
+
+static const struct file_operations soundcore_fops =
+{
+	/* We must have an owner or the module locking fails */
+	.owner	= THIS_MODULE,
+	.open	= soundcore_open,
+};
+
 /*
  *	Low level list operator. Scan the ordered list, find a hole and
  *	join into it. Called with the lock asserted
@@ -219,8 +259,9 @@ static int sound_insert_unit(struct sound_unit **list, const struct file_operati
 
 	if (!s)
 		return -ENOMEM;
-		
+
 	spin_lock(&sound_loader_lock);
+retry:
 	r = __sound_insert_unit(s, list, fops, index, low, top);
 	spin_unlock(&sound_loader_lock);
 	
@@ -231,11 +272,31 @@ static int sound_insert_unit(struct sound_unit **list, const struct file_operati
 	else
 		sprintf(s->name, "sound/%s%d", name, r / SOUND_STEP);
 
+	if (!preclaim_oss) {
+		/*
+		 * Something else might have grabbed the minor.  If
+		 * first free slot is requested, rescan with @low set
+		 * to the next unit; otherwise, -EBUSY.
+		 */
+		r = __register_chrdev(SOUND_MAJOR, s->unit_minor, 1, s->name,
+				      &soundcore_fops);
+		if (r < 0) {
+			spin_lock(&sound_loader_lock);
+			__sound_remove_unit(list, s->unit_minor);
+			if (index < 0) {
+				low = s->unit_minor + SOUND_STEP;
+				goto retry;
+			}
+			spin_unlock(&sound_loader_lock);
+			return -EBUSY;
+		}
+	}
+
 	device_create(sound_class, dev, MKDEV(SOUND_MAJOR, s->unit_minor),
 		      NULL, s->name+6);
-	return r;
+	return s->unit_minor;
 
- fail:
+fail:
 	kfree(s);
 	return r;
 }
@@ -254,6 +315,9 @@ static void sound_remove_unit(struct sound_unit **list, int unit)
 	p = __sound_remove_unit(list, unit);
 	spin_unlock(&sound_loader_lock);
 	if (p) {
+		if (!preclaim_oss)
+			__unregister_chrdev(SOUND_MAJOR, p->unit_minor, 1,
+					    p->name);
 		device_destroy(sound_class, MKDEV(SOUND_MAJOR, p->unit_minor));
 		kfree(p);
 	}
@@ -491,19 +555,6 @@ void unregister_sound_dsp(int unit)
 
 EXPORT_SYMBOL(unregister_sound_dsp);
 
-/*
- *	Now our file operations
- */
-
-static int soundcore_open(struct inode *, struct file *);
-
-static const struct file_operations soundcore_fops=
-{
-	/* We must have an owner or the module locking fails */
-	.owner	= THIS_MODULE,
-	.open	= soundcore_open,
-};
-
 static struct sound_unit *__look_for_unit(int chain, int unit)
 {
 	struct sound_unit *s;
@@ -539,7 +590,7 @@ static int soundcore_open(struct inode *inode, struct file *file)
 	s = __look_for_unit(chain, unit);
 	if (s)
 		new_fops = fops_get(s->unit_fops);
-	if (!new_fops) {
+	if (preclaim_oss && !new_fops) {
 		spin_unlock(&sound_loader_lock);
 
 		/*
@@ -605,7 +656,8 @@ static void cleanup_oss_soundcore(void)
 
 static int __init init_oss_soundcore(void)
 {
-	if (register_chrdev(SOUND_MAJOR, "sound", &soundcore_fops)==-1) {
+	if (preclaim_oss &&
+	    register_chrdev(SOUND_MAJOR, "sound", &soundcore_fops) == -1) {
 		printk(KERN_ERR "soundcore: sound device already in use.\n");
 		return -EBUSY;
 	}

commit 0a848680a82e47854347cdfecbe9adf8842719e6
Author: Tejun Heo <teheo@suse.de>
Date:   Thu Aug 6 18:13:58 2009 +0900

    sound: request char-major-* module aliases for missing OSS devices
    
    Till now missing OSS devices emitted sound-slot/service-* module
    alises instead of the standard char-major-* if a missing device number
    is opened if soundcore is loaded.  The custom module aliases don't
    have any inherent benefit than backward compatibility.
    
    sound-slot/service-* module aliases is scheduled to be removed and to
    help the transition this patch makes soundcore emit the standard
    module alises along with the custom ones.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index a41f8b127f49..786067c49b01 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -541,6 +541,7 @@ static int soundcore_open(struct inode *inode, struct file *file)
 		new_fops = fops_get(s->unit_fops);
 	if (!new_fops) {
 		spin_unlock(&sound_loader_lock);
+
 		/*
 		 *  Please, don't change this order or code.
 		 *  For ALSA slot means soundcard and OSS emulation code
@@ -550,6 +551,17 @@ static int soundcore_open(struct inode *inode, struct file *file)
 		 */
 		request_module("sound-slot-%i", unit>>4);
 		request_module("sound-service-%i-%i", unit>>4, chain);
+
+		/*
+		 * sound-slot/service-* module aliases are scheduled
+		 * for removal in favor of the standard char-major-*
+		 * module aliases.  For the time being, generate both
+		 * the legacy and standard module aliases to ease
+		 * transition.
+		 */
+		if (request_module("char-major-%d-%d", SOUND_MAJOR, unit) > 0)
+			request_module("char-major-%d", SOUND_MAJOR);
+
 		spin_lock(&sound_loader_lock);
 		s = __look_for_unit(chain, unit);
 		if (s)

commit 954a973cab37ad5df3f87f08964166abd956cc17
Author: Kay Sievers <kay.sievers@suse.de>
Date:   Fri Jul 3 20:56:05 2009 +0200

    sound: do not set DEVNAME for OSS devices
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 12522e6913d9..a41f8b127f49 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -10,6 +10,8 @@
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/err.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
 #include <sound/core.h>
 
 #ifdef CONFIG_SOUND_OSS_CORE
@@ -29,6 +31,8 @@ MODULE_LICENSE("GPL");
 
 static char *sound_nodename(struct device *dev)
 {
+	if (MAJOR(dev->devt) == SOUND_MAJOR)
+		return NULL;
 	return kasprintf(GFP_KERNEL, "snd/%s", dev_name(dev));
 }
 
@@ -104,7 +108,6 @@ module_exit(cleanup_soundcore);
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/sound.h>
-#include <linux/major.h>
 #include <linux/kmod.h>
 
 #define SOUND_STEP 16

commit 7a9d56f6a459472bc4383aeb85612d72e79d1818
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Apr 30 15:23:42 2009 +0200

    Driver Core: sound: add nodename for sound drivers
    
    This adds support to the sound core to report the proper device name to
    userspace for their devices.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 2b302bbffe73..12522e6913d9 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -27,6 +27,11 @@ MODULE_DESCRIPTION("Core sound module");
 MODULE_AUTHOR("Alan Cox");
 MODULE_LICENSE("GPL");
 
+static char *sound_nodename(struct device *dev)
+{
+	return kasprintf(GFP_KERNEL, "snd/%s", dev_name(dev));
+}
+
 static int __init init_soundcore(void)
 {
 	int rc;
@@ -41,6 +46,8 @@ static int __init init_soundcore(void)
 		return PTR_ERR(sound_class);
 	}
 
+	sound_class->nodename = sound_nodename;
+
 	return 0;
 }
 

commit 3d1ee379bd576c0830050c2d313e77b9f98a8013
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Dec 15 15:43:43 2008 +0000

    ALSA: Fix declaration of sound_class
    
    Include sound/core.h in sound_core.c so that sound_class is declared
    before it is defined, avoiding it looking like it should be static.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 10ba4218161b..2b302bbffe73 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/err.h>
+#include <sound/core.h>
 
 #ifdef CONFIG_SOUND_OSS_CORE
 static int __init init_oss_soundcore(void);

commit a39c4ad1089be34d8dc66e926e93a52c44993a0a
Author: Hannes Eder <hannes@hanneseder.net>
Date:   Thu Nov 20 21:25:25 2008 +0100

    sound/sound_core: Fix sparse warnings
    
    Fix the following sparse warnings:
    
    sound/sound_core.c:460:2: warning: returning void-valued expression
    sound/sound_core.c:477:2: warning: returning void-valued expression
    sound/sound_core.c:510:5: warning: symbol 'soundcore_open' was not
    declared. Should it be static?
    
    Signed-off-by: Hannes Eder <hannes@hanneseder.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index a75b289a5d78..10ba4218161b 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -457,7 +457,7 @@ EXPORT_SYMBOL(unregister_sound_mixer);
 
 void unregister_sound_midi(int unit)
 {
-	return sound_remove_unit(&chains[2], unit);
+	sound_remove_unit(&chains[2], unit);
 }
 
 EXPORT_SYMBOL(unregister_sound_midi);
@@ -474,7 +474,7 @@ EXPORT_SYMBOL(unregister_sound_midi);
 
 void unregister_sound_dsp(int unit)
 {
-	return sound_remove_unit(&chains[3], unit);
+	sound_remove_unit(&chains[3], unit);
 }
 
 
@@ -507,7 +507,7 @@ static struct sound_unit *__look_for_unit(int chain, int unit)
 	return NULL;
 }
 
-int soundcore_open(struct inode *inode, struct file *file)
+static int soundcore_open(struct inode *inode, struct file *file)
 {
 	int chain;
 	int unit = iminor(inode);

commit 0a9b86381c76e9d33a9b6edb66aef32d7a3306e3
Merge: bfd4e66b8d0d c3e5203bed19 e044c39ae258 2f1e593d4209 2f5ad54ea6e2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 27 17:08:11 2008 +0100

    Merge branches 'topic/fix/asoc', 'topic/fix/hda', 'topic/fix/misc' and 'topic/pci-ioremap-bar' into for-linus

commit 2f1e593d4209d0194f9639c5d11aa91171435963
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Oct 27 15:21:19 2008 +0000

    sound: use a common working email address
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 4ae07e236b36..ee66d43f848c 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -57,7 +57,7 @@ module_exit(cleanup_soundcore);
 /*
  *	OSS sound core handling. Breaks out sound functions to submodules
  *	
- *	Author:		Alan Cox <alan.cox@linux.org>
+ *	Author:		Alan Cox <alan@lxorguk.ukuu.org.uk>
  *
  *	Fixes:
  *

commit abe9ab8f62203ced11119fb96acc3b8dd107ebc4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jul 21 20:03:34 2008 -0700

    device create: sound: convert device_create_drvdata to device_create
    
    Now that device_create() has been audited, rename things back to the
    original call to be sane.
    
    Cc: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 4ae07e236b36..faef87a9bc3f 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -220,9 +220,8 @@ static int sound_insert_unit(struct sound_unit **list, const struct file_operati
 	else
 		sprintf(s->name, "sound/%s%d", name, r / SOUND_STEP);
 
-	device_create_drvdata(sound_class, dev,
-			      MKDEV(SOUND_MAJOR, s->unit_minor),
-			      NULL, s->name+6);
+	device_create(sound_class, dev, MKDEV(SOUND_MAJOR, s->unit_minor),
+		      NULL, s->name+6);
 	return r;
 
  fail:

commit de30d36be171c05dfd66fa49e3d785e004f5ecdf
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Sun Sep 7 17:24:33 2008 +0200

    ALSA: fix section mismatch in the sound_core
    
    The __exit cleanup_oss_soundcore() is called from
    the __init init_soundcore(). This causes section mismatch
    and breaks kernel's linking on sparc64.
    
    Remove the __exit attribute from the cleanup_oss_soundcore().
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 68614c3ed541..4ae07e236b36 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -13,7 +13,7 @@
 
 #ifdef CONFIG_SOUND_OSS_CORE
 static int __init init_oss_soundcore(void);
-static void __exit cleanup_oss_soundcore(void);
+static void cleanup_oss_soundcore(void);
 #else
 static inline int init_oss_soundcore(void)	{ return 0; }
 static inline void cleanup_oss_soundcore(void)	{ }
@@ -574,7 +574,7 @@ int soundcore_open(struct inode *inode, struct file *file)
 
 MODULE_ALIAS_CHARDEV_MAJOR(SOUND_MAJOR);
 
-static void __exit cleanup_oss_soundcore(void)
+static void cleanup_oss_soundcore(void)
 {
 	/* We have nothing to really do here - we know the lists must be
 	   empty */

commit d886e87cb82b0f6636476c1104bb84d7c8dc87d9
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Aug 28 16:42:51 2008 +0200

    sound: make OSS sound core optional
    
    sound/sound_core.c implements soundcore.ko and contains two parts -
    sound_class which is shared by both ALSA and OSS and device
    redirection support for OSS.  It's always compiled when any sound
    support is enabled although it's necessary only when OSS (the actual
    one or emulation) is enabled.  This is slightly wasteful and as device
    redirection always registers character device region for major 14, it
    prevents alternative implementation.
    
    This patch introduces a new config SOUND_OSS_CORE which is selected
    iff OSS support is actually necessary and build the OSS core part
    conditionally.
    
    If OSS is disabled, soundcore merely contains sound_class but leaving
    it that way seems to be the simplest approach as otherwise sound_class
    should be in ALSA core file if OSS is disabled but should be in
    soundcore if OSS is enabled.  Also, there's also the user confusion
    factor.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 1b04259a4328..68614c3ed541 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -1,5 +1,61 @@
 /*
- *	Sound core handling. Breaks out sound functions to submodules
+ *	Sound core.  This file is composed of two parts.  sound_class
+ *	which is common to both OSS and ALSA and OSS sound core which
+ *	is used OSS or emulation of it.
+ */
+
+/*
+ * First, the common part.
+ */
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+
+#ifdef CONFIG_SOUND_OSS_CORE
+static int __init init_oss_soundcore(void);
+static void __exit cleanup_oss_soundcore(void);
+#else
+static inline int init_oss_soundcore(void)	{ return 0; }
+static inline void cleanup_oss_soundcore(void)	{ }
+#endif
+
+struct class *sound_class;
+EXPORT_SYMBOL(sound_class);
+
+MODULE_DESCRIPTION("Core sound module");
+MODULE_AUTHOR("Alan Cox");
+MODULE_LICENSE("GPL");
+
+static int __init init_soundcore(void)
+{
+	int rc;
+
+	rc = init_oss_soundcore();
+	if (rc)
+		return rc;
+
+	sound_class = class_create(THIS_MODULE, "sound");
+	if (IS_ERR(sound_class)) {
+		cleanup_oss_soundcore();
+		return PTR_ERR(sound_class);
+	}
+
+	return 0;
+}
+
+static void __exit cleanup_soundcore(void)
+{
+	cleanup_oss_soundcore();
+	class_destroy(sound_class);
+}
+
+module_init(init_soundcore);
+module_exit(cleanup_soundcore);
+
+
+#ifdef CONFIG_SOUND_OSS_CORE
+/*
+ *	OSS sound core handling. Breaks out sound functions to submodules
  *	
  *	Author:		Alan Cox <alan.cox@linux.org>
  *
@@ -34,21 +90,17 @@
  *	locking at some point in 2.3.x.
  */
 
-#include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
-#include <linux/fs.h>
 #include <linux/sound.h>
 #include <linux/major.h>
 #include <linux/kmod.h>
-#include <linux/device.h>
 
 #define SOUND_STEP 16
 
-
 struct sound_unit
 {
 	int unit_minor;
@@ -64,9 +116,6 @@ extern int msnd_classic_init(void);
 extern int msnd_pinnacle_init(void);
 #endif
 
-struct class *sound_class;
-EXPORT_SYMBOL(sound_class);
-
 /*
  *	Low level list operator. Scan the ordered list, find a hole and
  *	join into it. Called with the lock asserted
@@ -523,31 +572,23 @@ int soundcore_open(struct inode *inode, struct file *file)
 	return -ENODEV;
 }
 
-MODULE_DESCRIPTION("Core sound module");
-MODULE_AUTHOR("Alan Cox");
-MODULE_LICENSE("GPL");
 MODULE_ALIAS_CHARDEV_MAJOR(SOUND_MAJOR);
 
-static void __exit cleanup_soundcore(void)
+static void __exit cleanup_oss_soundcore(void)
 {
 	/* We have nothing to really do here - we know the lists must be
 	   empty */
 	unregister_chrdev(SOUND_MAJOR, "sound");
-	class_destroy(sound_class);
 }
 
-static int __init init_soundcore(void)
+static int __init init_oss_soundcore(void)
 {
 	if (register_chrdev(SOUND_MAJOR, "sound", &soundcore_fops)==-1) {
 		printk(KERN_ERR "soundcore: sound device already in use.\n");
 		return -EBUSY;
 	}
-	sound_class = class_create(THIS_MODULE, "sound");
-	if (IS_ERR(sound_class))
-		return PTR_ERR(sound_class);
 
 	return 0;
 }
 
-module_init(init_soundcore);
-module_exit(cleanup_soundcore);
+#endif /* CONFIG_SOUND_OSS_CORE */

commit 89409211ff97bf82295d1fb98ab18302a03e9199
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 21 12:52:33 2008 -0700

    device create: sound: convert device_create to device_create_drvdata
    
    device_create() is race-prone, so use the race-free
    device_create_drvdata() instead as device_create() is going away.
    
    Cc: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index dcfc1d5ce631..1b04259a4328 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -171,8 +171,9 @@ static int sound_insert_unit(struct sound_unit **list, const struct file_operati
 	else
 		sprintf(s->name, "sound/%s%d", name, r / SOUND_STEP);
 
-	device_create(sound_class, dev, MKDEV(SOUND_MAJOR, s->unit_minor),
-		      s->name+6);
+	device_create_drvdata(sound_class, dev,
+			      MKDEV(SOUND_MAJOR, s->unit_minor),
+			      NULL, s->name+6);
 	return r;
 
  fail:

commit 78a3c3d7c6b89085610edfe86f7790144afc737e
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Thu May 15 16:39:03 2008 -0600

    sound: cdev lock_kernel() pushdown
    
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 46daca175502..dcfc1d5ce631 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -37,6 +37,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>
+#include <linux/smp_lock.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/fs.h>
@@ -464,6 +465,8 @@ int soundcore_open(struct inode *inode, struct file *file)
 	struct sound_unit *s;
 	const struct file_operations *new_fops = NULL;
 
+	lock_kernel ();
+
 	chain=unit&0x0F;
 	if(chain==4 || chain==5)	/* dsp/audio/dsp16 */
 	{
@@ -511,9 +514,11 @@ int soundcore_open(struct inode *inode, struct file *file)
 			file->f_op = fops_get(old_fops);
 		}
 		fops_put(old_fops);
+		unlock_kernel();
 		return err;
 	}
 	spin_unlock(&sound_loader_lock);
+	unlock_kernel();
 	return -ENODEV;
 }
 

commit 9c2e08c592cd357a8330c34def1e8ecfdcf53275
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:37 2007 -0800

    [PATCH] mark struct file_operations const 9
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 8f1ced4ab34c..46daca175502 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -436,7 +436,7 @@ EXPORT_SYMBOL(unregister_sound_dsp);
 
 static int soundcore_open(struct inode *, struct file *);
 
-static struct file_operations soundcore_fops=
+static const struct file_operations soundcore_fops=
 {
 	/* We must have an owner or the module locking fails */
 	.owner	= THIS_MODULE,

commit d80f19fab89cba8a6d16193154c8ff3edab00942
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 7 22:19:37 2006 -0700

    Driver core: convert sound core to use struct device
    
    Converts from using struct "class_device" to "struct device" making
    everything show up properly in /sys/devices/ with symlinks from the
    /sys/class directory.
    
    It also makes the struct sound_card to show up as a "real" device
    where all the different sound class devices are placed as childs
    and different card attribute files can hang off of. /sys/class/sound is
    still a flat directory, but the symlink targets of all devices belonging
    to the same card, point the the /sys/devices tree below the new card
    device object.
    
    Thanks to Kay for the updates to this patch.
    
    Signed-off-by: Kay Sievers <kay.sievers@novell.com>
    Acked-by: Jaroslav Kysela <perex@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 5322c50c9617..8f1ced4ab34c 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -170,8 +170,8 @@ static int sound_insert_unit(struct sound_unit **list, const struct file_operati
 	else
 		sprintf(s->name, "sound/%s%d", name, r / SOUND_STEP);
 
-	class_device_create(sound_class, NULL, MKDEV(SOUND_MAJOR, s->unit_minor),
-			    dev, s->name+6);
+	device_create(sound_class, dev, MKDEV(SOUND_MAJOR, s->unit_minor),
+		      s->name+6);
 	return r;
 
  fail:
@@ -193,7 +193,7 @@ static void sound_remove_unit(struct sound_unit **list, int unit)
 	p = __sound_remove_unit(list, unit);
 	spin_unlock(&sound_loader_lock);
 	if (p) {
-		class_device_destroy(sound_class, MKDEV(SOUND_MAJOR, p->unit_minor));
+		device_destroy(sound_class, MKDEV(SOUND_MAJOR, p->unit_minor));
 		kfree(p);
 	}
 }

commit d56b9b9c464a10ab1ee51a4c6190a2b57b8ef7a6
Author: Adrian Bunk <bunk@stusta.de>
Date:   Wed Oct 4 02:17:22 2006 -0700

    [PATCH] The scheduled removal of some OSS drivers
    
    This patch contains the scheduled removal of OSS drivers that:
    - have ALSA drivers for the same hardware without known regressions and
    - whose Kconfig options have been removed in 2.6.17.
    
    [michal.k.k.piotrowski@gmail.com: build fix]
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Michal Piotrowski <michal.k.k.piotrowski@gmail.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 0b0a016ca6d6..5322c50c9617 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -365,25 +365,6 @@ int register_sound_dsp(const struct file_operations *fops, int dev)
 
 EXPORT_SYMBOL(register_sound_dsp);
 
-/**
- *	register_sound_synth - register a synth device
- *	@fops: File operations for the driver
- *	@dev: Unit number to allocate
- *
- *	Allocate a synth device. Unit is the number of the synth device requested.
- *	Pass -1 to request the next free synth unit. On success the allocated
- *	number is returned, on failure a negative error code is returned.
- */
-
-
-int register_sound_synth(const struct file_operations *fops, int dev)
-{
-	return sound_insert_unit(&chains[9], fops, dev, 9, 137,
-				 "synth", S_IRUSR | S_IWUSR, NULL);
-}
-
-EXPORT_SYMBOL(register_sound_synth);
-
 /**
  *	unregister_sound_special - unregister a special sound device
  *	@unit: unit number to allocate
@@ -449,21 +430,6 @@ void unregister_sound_dsp(int unit)
 
 EXPORT_SYMBOL(unregister_sound_dsp);
 
-/**
- *	unregister_sound_synth - unregister a synth device
- *	@unit: unit number to allocate
- *
- *	Release a sound device that was allocated with register_sound_synth().
- *	The unit passed is the return value from the register function.
- */
-
-void unregister_sound_synth(int unit)
-{
-	return sound_remove_unit(&chains[9], unit);
-}
-
-EXPORT_SYMBOL(unregister_sound_synth);
-
 /*
  *	Now our file operations
  */

commit b9dd6ffc3d6b56417a2c4c917f51dab6470166e6
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Sep 29 02:01:36 2006 -0700

    [PATCH] build sound/sound_firmware.c only for OSS
    
    All sound/sound_firmware.c contains is mod_firmware_load() that is a legacy
    API only used by some OSS drivers.
    
    This patch builds it into an own sound_firmware module that is only built
    depending on CONFIG_SOUND_PRIME making the kernel slightly smaller for ALSA
    users.
    
    [alan@lxorguk.ukuu.org.uk: comment fix]
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 62d4d0c81261..0b0a016ca6d6 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -551,10 +551,6 @@ int soundcore_open(struct inode *inode, struct file *file)
 	return -ENODEV;
 }
 
-extern int mod_firmware_load(const char *, char **);
-EXPORT_SYMBOL(mod_firmware_load);
-
-
 MODULE_DESCRIPTION("Core sound module");
 MODULE_AUTHOR("Alan Cox");
 MODULE_LICENSE("GPL");

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 7535ec821dcf..62d4d0c81261 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -34,7 +34,6 @@
  *	locking at some point in 2.3.x.
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/slab.h>

commit 0936f26f55918af595b108208e64c37a0a481722
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] devfs: Remove devfs support from the sound subsystem
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 6f849720aef3..7535ec821dcf 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -44,7 +44,6 @@
 #include <linux/sound.h>
 #include <linux/major.h>
 #include <linux/kmod.h>
-#include <linux/devfs_fs_kernel.h>
 #include <linux/device.h>
 
 #define SOUND_STEP 16
@@ -172,8 +171,6 @@ static int sound_insert_unit(struct sound_unit **list, const struct file_operati
 	else
 		sprintf(s->name, "sound/%s%d", name, r / SOUND_STEP);
 
-	devfs_mk_cdev(MKDEV(SOUND_MAJOR, s->unit_minor),
-			S_IFCHR | mode, s->name);
 	class_device_create(sound_class, NULL, MKDEV(SOUND_MAJOR, s->unit_minor),
 			    dev, s->name+6);
 	return r;
@@ -197,7 +194,6 @@ static void sound_remove_unit(struct sound_unit **list, int unit)
 	p = __sound_remove_unit(list, unit);
 	spin_unlock(&sound_loader_lock);
 	if (p) {
-		devfs_remove(p->name);
 		class_device_destroy(sound_class, MKDEV(SOUND_MAJOR, p->unit_minor));
 		kfree(p);
 	}
@@ -570,7 +566,6 @@ static void __exit cleanup_soundcore(void)
 	/* We have nothing to really do here - we know the lists must be
 	   empty */
 	unregister_chrdev(SOUND_MAJOR, "sound");
-	devfs_remove("sound");
 	class_destroy(sound_class);
 }
 
@@ -580,7 +575,6 @@ static int __init init_soundcore(void)
 		printk(KERN_ERR "soundcore: sound device already in use.\n");
 		return -EBUSY;
 	}
-	devfs_mk_dir ("sound");
 	sound_class = class_create(THIS_MODULE, "sound");
 	if (IS_ERR(sound_class))
 		return PTR_ERR(sound_class);

commit 99ac48f54a91d02140c497edc31dc57d4bc5c85d
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Mar 28 01:56:41 2006 -0800

    [PATCH] mark f_ops const in the inode
    
    Mark the f_ops members of inodes as const, as well as fix the
    ripple-through this causes by places that copy this f_ops and then "do
    stuff" with it.
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 394b53e20cb8..6f849720aef3 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -53,7 +53,7 @@
 struct sound_unit
 {
 	int unit_minor;
-	struct file_operations *unit_fops;
+	const struct file_operations *unit_fops;
 	struct sound_unit *next;
 	char name[32];
 };
@@ -73,7 +73,7 @@ EXPORT_SYMBOL(sound_class);
  *	join into it. Called with the lock asserted
  */
 
-static int __sound_insert_unit(struct sound_unit * s, struct sound_unit **list, struct file_operations *fops, int index, int low, int top)
+static int __sound_insert_unit(struct sound_unit * s, struct sound_unit **list, const struct file_operations *fops, int index, int low, int top)
 {
 	int n=low;
 
@@ -153,7 +153,7 @@ static DEFINE_SPINLOCK(sound_loader_lock);
  *	list. Acquires locks as needed
  */
 
-static int sound_insert_unit(struct sound_unit **list, struct file_operations *fops, int index, int low, int top, const char *name, umode_t mode, struct device *dev)
+static int sound_insert_unit(struct sound_unit **list, const struct file_operations *fops, int index, int low, int top, const char *name, umode_t mode, struct device *dev)
 {
 	struct sound_unit *s = kmalloc(sizeof(*s), GFP_KERNEL);
 	int r;
@@ -237,7 +237,7 @@ static struct sound_unit *chains[SOUND_STEP];
  *	a negative error code is returned.
  */
  
-int register_sound_special_device(struct file_operations *fops, int unit,
+int register_sound_special_device(const struct file_operations *fops, int unit,
 				  struct device *dev)
 {
 	const int chain = unit % SOUND_STEP;
@@ -301,7 +301,7 @@ int register_sound_special_device(struct file_operations *fops, int unit,
  
 EXPORT_SYMBOL(register_sound_special_device);
 
-int register_sound_special(struct file_operations *fops, int unit)
+int register_sound_special(const struct file_operations *fops, int unit)
 {
 	return register_sound_special_device(fops, unit, NULL);
 }
@@ -318,7 +318,7 @@ EXPORT_SYMBOL(register_sound_special);
  *	number is returned, on failure a negative error code is returned.
  */
 
-int register_sound_mixer(struct file_operations *fops, int dev)
+int register_sound_mixer(const struct file_operations *fops, int dev)
 {
 	return sound_insert_unit(&chains[0], fops, dev, 0, 128,
 				 "mixer", S_IRUSR | S_IWUSR, NULL);
@@ -336,7 +336,7 @@ EXPORT_SYMBOL(register_sound_mixer);
  *	number is returned, on failure a negative error code is returned.
  */
 
-int register_sound_midi(struct file_operations *fops, int dev)
+int register_sound_midi(const struct file_operations *fops, int dev)
 {
 	return sound_insert_unit(&chains[2], fops, dev, 2, 130,
 				 "midi", S_IRUSR | S_IWUSR, NULL);
@@ -362,7 +362,7 @@ EXPORT_SYMBOL(register_sound_midi);
  *	and will always allocate them as a matching pair - eg dsp3/audio3
  */
 
-int register_sound_dsp(struct file_operations *fops, int dev)
+int register_sound_dsp(const struct file_operations *fops, int dev)
 {
 	return sound_insert_unit(&chains[3], fops, dev, 3, 131,
 				 "dsp", S_IWUSR | S_IRUSR, NULL);
@@ -381,7 +381,7 @@ EXPORT_SYMBOL(register_sound_dsp);
  */
 
 
-int register_sound_synth(struct file_operations *fops, int dev)
+int register_sound_synth(const struct file_operations *fops, int dev)
 {
 	return sound_insert_unit(&chains[9], fops, dev, 9, 137,
 				 "synth", S_IRUSR | S_IWUSR, NULL);
@@ -501,7 +501,7 @@ int soundcore_open(struct inode *inode, struct file *file)
 	int chain;
 	int unit = iminor(inode);
 	struct sound_unit *s;
-	struct file_operations *new_fops = NULL;
+	const struct file_operations *new_fops = NULL;
 
 	chain=unit&0x0F;
 	if(chain==4 || chain==5)	/* dsp/audio/dsp16 */
@@ -540,7 +540,7 @@ int soundcore_open(struct inode *inode, struct file *file)
 		 * switching ->f_op in the first place.
 		 */
 		int err = 0;
-		struct file_operations *old_fops = file->f_op;
+		const struct file_operations *old_fops = file->f_op;
 		file->f_op = new_fops;
 		spin_unlock(&sound_loader_lock);
 		if(file->f_op->open)

commit 53f4654272df7c51064825024340554b39c9efba
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 27 22:25:43 2005 -0700

    [PATCH] Driver Core: fix up all callers of class_device_create()
    
    The previous patch adding the ability to nest struct class_device
    changed the paramaters to the call class_device_create().  This patch
    fixes up all in-kernel users of the function.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 954f994592ab..394b53e20cb8 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -174,7 +174,7 @@ static int sound_insert_unit(struct sound_unit **list, struct file_operations *f
 
 	devfs_mk_cdev(MKDEV(SOUND_MAJOR, s->unit_minor),
 			S_IFCHR | mode, s->name);
-	class_device_create(sound_class, MKDEV(SOUND_MAJOR, s->unit_minor),
+	class_device_create(sound_class, NULL, MKDEV(SOUND_MAJOR, s->unit_minor),
 			    dev, s->name+6);
 	return r;
 

commit d568121ce3151c36cc4718dd4e977f217c6144c2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 30 08:58:37 2005 +0200

    [PATCH] Assign device pointer to OSS devices
    
    Add register_sound_special_device() function to allow assignment of
    device pointer to a specific OSS device for HAL.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 21a69e096225..954f994592ab 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -153,7 +153,7 @@ static DEFINE_SPINLOCK(sound_loader_lock);
  *	list. Acquires locks as needed
  */
 
-static int sound_insert_unit(struct sound_unit **list, struct file_operations *fops, int index, int low, int top, const char *name, umode_t mode)
+static int sound_insert_unit(struct sound_unit **list, struct file_operations *fops, int index, int low, int top, const char *name, umode_t mode, struct device *dev)
 {
 	struct sound_unit *s = kmalloc(sizeof(*s), GFP_KERNEL);
 	int r;
@@ -175,7 +175,7 @@ static int sound_insert_unit(struct sound_unit **list, struct file_operations *f
 	devfs_mk_cdev(MKDEV(SOUND_MAJOR, s->unit_minor),
 			S_IFCHR | mode, s->name);
 	class_device_create(sound_class, MKDEV(SOUND_MAJOR, s->unit_minor),
-				NULL, s->name+6);
+			    dev, s->name+6);
 	return r;
 
  fail:
@@ -227,16 +227,18 @@ static void sound_remove_unit(struct sound_unit **list, int unit)
 static struct sound_unit *chains[SOUND_STEP];
 
 /**
- *	register_sound_special - register a special sound node
+ *	register_sound_special_device - register a special sound node
  *	@fops: File operations for the driver
  *	@unit: Unit number to allocate
+ *      @dev: device pointer
  *
  *	Allocate a special sound device by minor number from the sound
  *	subsystem. The allocated number is returned on succes. On failure
  *	a negative error code is returned.
  */
  
-int register_sound_special(struct file_operations *fops, int unit)
+int register_sound_special_device(struct file_operations *fops, int unit,
+				  struct device *dev)
 {
 	const int chain = unit % SOUND_STEP;
 	int max_unit = 128 + chain;
@@ -294,9 +296,16 @@ int register_sound_special(struct file_operations *fops, int unit)
 		break;
 	}
 	return sound_insert_unit(&chains[chain], fops, -1, unit, max_unit,
-				 name, S_IRUSR | S_IWUSR);
+				 name, S_IRUSR | S_IWUSR, dev);
 }
  
+EXPORT_SYMBOL(register_sound_special_device);
+
+int register_sound_special(struct file_operations *fops, int unit)
+{
+	return register_sound_special_device(fops, unit, NULL);
+}
+
 EXPORT_SYMBOL(register_sound_special);
 
 /**
@@ -312,7 +321,7 @@ EXPORT_SYMBOL(register_sound_special);
 int register_sound_mixer(struct file_operations *fops, int dev)
 {
 	return sound_insert_unit(&chains[0], fops, dev, 0, 128,
-				 "mixer", S_IRUSR | S_IWUSR);
+				 "mixer", S_IRUSR | S_IWUSR, NULL);
 }
 
 EXPORT_SYMBOL(register_sound_mixer);
@@ -330,7 +339,7 @@ EXPORT_SYMBOL(register_sound_mixer);
 int register_sound_midi(struct file_operations *fops, int dev)
 {
 	return sound_insert_unit(&chains[2], fops, dev, 2, 130,
-				 "midi", S_IRUSR | S_IWUSR);
+				 "midi", S_IRUSR | S_IWUSR, NULL);
 }
 
 EXPORT_SYMBOL(register_sound_midi);
@@ -356,7 +365,7 @@ EXPORT_SYMBOL(register_sound_midi);
 int register_sound_dsp(struct file_operations *fops, int dev)
 {
 	return sound_insert_unit(&chains[3], fops, dev, 3, 131,
-				 "dsp", S_IWUSR | S_IRUSR);
+				 "dsp", S_IWUSR | S_IRUSR, NULL);
 }
 
 EXPORT_SYMBOL(register_sound_dsp);
@@ -375,7 +384,7 @@ EXPORT_SYMBOL(register_sound_dsp);
 int register_sound_synth(struct file_operations *fops, int dev)
 {
 	return sound_insert_unit(&chains[9], fops, dev, 9, 137,
-				 "synth", S_IRUSR | S_IWUSR);
+				 "synth", S_IRUSR | S_IWUSR, NULL);
 }
 
 EXPORT_SYMBOL(register_sound_synth);

commit 619e666b7e9d2b0545ab60a9c824ae5f77c20c3b
Author: gregkh@suse.de <gregkh@suse.de>
Date:   Wed Mar 23 09:51:41 2005 -0800

    [PATCH] class: convert sound/* to use the new class api instead of class_simple
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/sound_core.c b/sound/sound_core.c
index 30f75c9288cb..21a69e096225 100644
--- a/sound/sound_core.c
+++ b/sound/sound_core.c
@@ -65,7 +65,7 @@ extern int msnd_classic_init(void);
 extern int msnd_pinnacle_init(void);
 #endif
 
-struct class_simple *sound_class;
+struct class *sound_class;
 EXPORT_SYMBOL(sound_class);
 
 /*
@@ -174,7 +174,7 @@ static int sound_insert_unit(struct sound_unit **list, struct file_operations *f
 
 	devfs_mk_cdev(MKDEV(SOUND_MAJOR, s->unit_minor),
 			S_IFCHR | mode, s->name);
-	class_simple_device_add(sound_class, MKDEV(SOUND_MAJOR, s->unit_minor),
+	class_device_create(sound_class, MKDEV(SOUND_MAJOR, s->unit_minor),
 				NULL, s->name+6);
 	return r;
 
@@ -198,7 +198,7 @@ static void sound_remove_unit(struct sound_unit **list, int unit)
 	spin_unlock(&sound_loader_lock);
 	if (p) {
 		devfs_remove(p->name);
-		class_simple_device_remove(MKDEV(SOUND_MAJOR, p->unit_minor));
+		class_device_destroy(sound_class, MKDEV(SOUND_MAJOR, p->unit_minor));
 		kfree(p);
 	}
 }
@@ -562,7 +562,7 @@ static void __exit cleanup_soundcore(void)
 	   empty */
 	unregister_chrdev(SOUND_MAJOR, "sound");
 	devfs_remove("sound");
-	class_simple_destroy(sound_class);
+	class_destroy(sound_class);
 }
 
 static int __init init_soundcore(void)
@@ -572,7 +572,7 @@ static int __init init_soundcore(void)
 		return -EBUSY;
 	}
 	devfs_mk_dir ("sound");
-	sound_class = class_simple_create(THIS_MODULE, "sound");
+	sound_class = class_create(THIS_MODULE, "sound");
 	if (IS_ERR(sound_class))
 		return PTR_ERR(sound_class);
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/sound_core.c b/sound/sound_core.c
new file mode 100644
index 000000000000..30f75c9288cb
--- /dev/null
+++ b/sound/sound_core.c
@@ -0,0 +1,583 @@
+/*
+ *	Sound core handling. Breaks out sound functions to submodules
+ *	
+ *	Author:		Alan Cox <alan.cox@linux.org>
+ *
+ *	Fixes:
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *                         --------------------
+ * 
+ *	Top level handler for the sound subsystem. Various devices can
+ *	plug into this. The fact they don't all go via OSS doesn't mean 
+ *	they don't have to implement the OSS API. There is a lot of logic
+ *	to keeping much of the OSS weight out of the code in a compatibility
+ *	module, but it's up to the driver to rember to load it...
+ *
+ *	The code provides a set of functions for registration of devices
+ *	by type. This is done rather than providing a single call so that
+ *	we can hide any future changes in the internals (eg when we go to
+ *	32bit dev_t) from the modules and their interface.
+ *
+ *	Secondly we need to allocate the dsp, dsp16 and audio devices as
+ *	one. Thus we misuse the chains a bit to simplify this.
+ *
+ *	Thirdly to make it more fun and for 2.3.x and above we do all
+ *	of this using fine grained locking.
+ *
+ *	FIXME: we have to resolve modules and fine grained load/unload
+ *	locking at some point in 2.3.x.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/sound.h>
+#include <linux/major.h>
+#include <linux/kmod.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/device.h>
+
+#define SOUND_STEP 16
+
+
+struct sound_unit
+{
+	int unit_minor;
+	struct file_operations *unit_fops;
+	struct sound_unit *next;
+	char name[32];
+};
+
+#ifdef CONFIG_SOUND_MSNDCLAS
+extern int msnd_classic_init(void);
+#endif
+#ifdef CONFIG_SOUND_MSNDPIN
+extern int msnd_pinnacle_init(void);
+#endif
+
+struct class_simple *sound_class;
+EXPORT_SYMBOL(sound_class);
+
+/*
+ *	Low level list operator. Scan the ordered list, find a hole and
+ *	join into it. Called with the lock asserted
+ */
+
+static int __sound_insert_unit(struct sound_unit * s, struct sound_unit **list, struct file_operations *fops, int index, int low, int top)
+{
+	int n=low;
+
+	if (index < 0) {	/* first free */
+
+		while (*list && (*list)->unit_minor<n)
+			list=&((*list)->next);
+
+		while(n<top)
+		{
+			/* Found a hole ? */
+			if(*list==NULL || (*list)->unit_minor>n)
+				break;
+			list=&((*list)->next);
+			n+=SOUND_STEP;
+		}
+
+		if(n>=top)
+			return -ENOENT;
+	} else {
+		n = low+(index*16);
+		while (*list) {
+			if ((*list)->unit_minor==n)
+				return -EBUSY;
+			if ((*list)->unit_minor>n)
+				break;
+			list=&((*list)->next);
+		}
+	}	
+		
+	/*
+	 *	Fill it in
+	 */
+	 
+	s->unit_minor=n;
+	s->unit_fops=fops;
+	
+	/*
+	 *	Link it
+	 */
+	 
+	s->next=*list;
+	*list=s;
+	
+	
+	return n;
+}
+
+/*
+ *	Remove a node from the chain. Called with the lock asserted
+ */
+ 
+static struct sound_unit *__sound_remove_unit(struct sound_unit **list, int unit)
+{
+	while(*list)
+	{
+		struct sound_unit *p=*list;
+		if(p->unit_minor==unit)
+		{
+			*list=p->next;
+			return p;
+		}
+		list=&(p->next);
+	}
+	printk(KERN_ERR "Sound device %d went missing!\n", unit);
+	return NULL;
+}
+
+/*
+ *	This lock guards the sound loader list.
+ */
+
+static DEFINE_SPINLOCK(sound_loader_lock);
+
+/*
+ *	Allocate the controlling structure and add it to the sound driver
+ *	list. Acquires locks as needed
+ */
+
+static int sound_insert_unit(struct sound_unit **list, struct file_operations *fops, int index, int low, int top, const char *name, umode_t mode)
+{
+	struct sound_unit *s = kmalloc(sizeof(*s), GFP_KERNEL);
+	int r;
+
+	if (!s)
+		return -ENOMEM;
+		
+	spin_lock(&sound_loader_lock);
+	r = __sound_insert_unit(s, list, fops, index, low, top);
+	spin_unlock(&sound_loader_lock);
+	
+	if (r < 0)
+		goto fail;
+	else if (r < SOUND_STEP)
+		sprintf(s->name, "sound/%s", name);
+	else
+		sprintf(s->name, "sound/%s%d", name, r / SOUND_STEP);
+
+	devfs_mk_cdev(MKDEV(SOUND_MAJOR, s->unit_minor),
+			S_IFCHR | mode, s->name);
+	class_simple_device_add(sound_class, MKDEV(SOUND_MAJOR, s->unit_minor),
+				NULL, s->name+6);
+	return r;
+
+ fail:
+	kfree(s);
+	return r;
+}
+
+/*
+ *	Remove a unit. Acquires locks as needed. The drivers MUST have
+ *	completed the removal before their file operations become
+ *	invalid.
+ */
+ 	
+static void sound_remove_unit(struct sound_unit **list, int unit)
+{
+	struct sound_unit *p;
+
+	spin_lock(&sound_loader_lock);
+	p = __sound_remove_unit(list, unit);
+	spin_unlock(&sound_loader_lock);
+	if (p) {
+		devfs_remove(p->name);
+		class_simple_device_remove(MKDEV(SOUND_MAJOR, p->unit_minor));
+		kfree(p);
+	}
+}
+
+/*
+ *	Allocations
+ *
+ *	0	*16		Mixers
+ *	1	*8		Sequencers
+ *	2	*16		Midi
+ *	3	*16		DSP
+ *	4	*16		SunDSP
+ *	5	*16		DSP16
+ *	6	--		sndstat (obsolete)
+ *	7	*16		unused
+ *	8	--		alternate sequencer (see above)
+ *	9	*16		raw synthesizer access
+ *	10	*16		unused
+ *	11	*16		unused
+ *	12	*16		unused
+ *	13	*16		unused
+ *	14	*16		unused
+ *	15	*16		unused
+ */
+
+static struct sound_unit *chains[SOUND_STEP];
+
+/**
+ *	register_sound_special - register a special sound node
+ *	@fops: File operations for the driver
+ *	@unit: Unit number to allocate
+ *
+ *	Allocate a special sound device by minor number from the sound
+ *	subsystem. The allocated number is returned on succes. On failure
+ *	a negative error code is returned.
+ */
+ 
+int register_sound_special(struct file_operations *fops, int unit)
+{
+	const int chain = unit % SOUND_STEP;
+	int max_unit = 128 + chain;
+	const char *name;
+	char _name[16];
+
+	switch (chain) {
+	    case 0:
+		name = "mixer";
+		break;
+	    case 1:
+		name = "sequencer";
+		if (unit >= SOUND_STEP)
+			goto __unknown;
+		max_unit = unit + 1;
+		break;
+	    case 2:
+		name = "midi";
+		break;
+	    case 3:
+		name = "dsp";
+		break;
+	    case 4:
+		name = "audio";
+		break;
+	    case 8:
+		name = "sequencer2";
+		if (unit >= SOUND_STEP)
+			goto __unknown;
+		max_unit = unit + 1;
+		break;
+	    case 9:
+		name = "dmmidi";
+		break;
+	    case 10:
+		name = "dmfm";
+		break;
+	    case 12:
+		name = "adsp";
+		break;
+	    case 13:
+		name = "amidi";
+		break;
+	    case 14:
+		name = "admmidi";
+		break;
+	    default:
+	    	{
+		    __unknown:
+			sprintf(_name, "unknown%d", chain);
+		    	if (unit >= SOUND_STEP)
+		    		strcat(_name, "-");
+		    	name = _name;
+		}
+		break;
+	}
+	return sound_insert_unit(&chains[chain], fops, -1, unit, max_unit,
+				 name, S_IRUSR | S_IWUSR);
+}
+ 
+EXPORT_SYMBOL(register_sound_special);
+
+/**
+ *	register_sound_mixer - register a mixer device
+ *	@fops: File operations for the driver
+ *	@dev: Unit number to allocate
+ *
+ *	Allocate a mixer device. Unit is the number of the mixer requested.
+ *	Pass -1 to request the next free mixer unit. On success the allocated
+ *	number is returned, on failure a negative error code is returned.
+ */
+
+int register_sound_mixer(struct file_operations *fops, int dev)
+{
+	return sound_insert_unit(&chains[0], fops, dev, 0, 128,
+				 "mixer", S_IRUSR | S_IWUSR);
+}
+
+EXPORT_SYMBOL(register_sound_mixer);
+
+/**
+ *	register_sound_midi - register a midi device
+ *	@fops: File operations for the driver
+ *	@dev: Unit number to allocate
+ *
+ *	Allocate a midi device. Unit is the number of the midi device requested.
+ *	Pass -1 to request the next free midi unit. On success the allocated
+ *	number is returned, on failure a negative error code is returned.
+ */
+
+int register_sound_midi(struct file_operations *fops, int dev)
+{
+	return sound_insert_unit(&chains[2], fops, dev, 2, 130,
+				 "midi", S_IRUSR | S_IWUSR);
+}
+
+EXPORT_SYMBOL(register_sound_midi);
+
+/*
+ *	DSP's are registered as a triple. Register only one and cheat
+ *	in open - see below.
+ */
+ 
+/**
+ *	register_sound_dsp - register a DSP device
+ *	@fops: File operations for the driver
+ *	@dev: Unit number to allocate
+ *
+ *	Allocate a DSP device. Unit is the number of the DSP requested.
+ *	Pass -1 to request the next free DSP unit. On success the allocated
+ *	number is returned, on failure a negative error code is returned.
+ *
+ *	This function allocates both the audio and dsp device entries together
+ *	and will always allocate them as a matching pair - eg dsp3/audio3
+ */
+
+int register_sound_dsp(struct file_operations *fops, int dev)
+{
+	return sound_insert_unit(&chains[3], fops, dev, 3, 131,
+				 "dsp", S_IWUSR | S_IRUSR);
+}
+
+EXPORT_SYMBOL(register_sound_dsp);
+
+/**
+ *	register_sound_synth - register a synth device
+ *	@fops: File operations for the driver
+ *	@dev: Unit number to allocate
+ *
+ *	Allocate a synth device. Unit is the number of the synth device requested.
+ *	Pass -1 to request the next free synth unit. On success the allocated
+ *	number is returned, on failure a negative error code is returned.
+ */
+
+
+int register_sound_synth(struct file_operations *fops, int dev)
+{
+	return sound_insert_unit(&chains[9], fops, dev, 9, 137,
+				 "synth", S_IRUSR | S_IWUSR);
+}
+
+EXPORT_SYMBOL(register_sound_synth);
+
+/**
+ *	unregister_sound_special - unregister a special sound device
+ *	@unit: unit number to allocate
+ *
+ *	Release a sound device that was allocated with
+ *	register_sound_special(). The unit passed is the return value from
+ *	the register function.
+ */
+
+
+void unregister_sound_special(int unit)
+{
+	sound_remove_unit(&chains[unit % SOUND_STEP], unit);
+}
+ 
+EXPORT_SYMBOL(unregister_sound_special);
+
+/**
+ *	unregister_sound_mixer - unregister a mixer
+ *	@unit: unit number to allocate
+ *
+ *	Release a sound device that was allocated with register_sound_mixer().
+ *	The unit passed is the return value from the register function.
+ */
+
+void unregister_sound_mixer(int unit)
+{
+	sound_remove_unit(&chains[0], unit);
+}
+
+EXPORT_SYMBOL(unregister_sound_mixer);
+
+/**
+ *	unregister_sound_midi - unregister a midi device
+ *	@unit: unit number to allocate
+ *
+ *	Release a sound device that was allocated with register_sound_midi().
+ *	The unit passed is the return value from the register function.
+ */
+
+void unregister_sound_midi(int unit)
+{
+	return sound_remove_unit(&chains[2], unit);
+}
+
+EXPORT_SYMBOL(unregister_sound_midi);
+
+/**
+ *	unregister_sound_dsp - unregister a DSP device
+ *	@unit: unit number to allocate
+ *
+ *	Release a sound device that was allocated with register_sound_dsp().
+ *	The unit passed is the return value from the register function.
+ *
+ *	Both of the allocated units are released together automatically.
+ */
+
+void unregister_sound_dsp(int unit)
+{
+	return sound_remove_unit(&chains[3], unit);
+}
+
+
+EXPORT_SYMBOL(unregister_sound_dsp);
+
+/**
+ *	unregister_sound_synth - unregister a synth device
+ *	@unit: unit number to allocate
+ *
+ *	Release a sound device that was allocated with register_sound_synth().
+ *	The unit passed is the return value from the register function.
+ */
+
+void unregister_sound_synth(int unit)
+{
+	return sound_remove_unit(&chains[9], unit);
+}
+
+EXPORT_SYMBOL(unregister_sound_synth);
+
+/*
+ *	Now our file operations
+ */
+
+static int soundcore_open(struct inode *, struct file *);
+
+static struct file_operations soundcore_fops=
+{
+	/* We must have an owner or the module locking fails */
+	.owner	= THIS_MODULE,
+	.open	= soundcore_open,
+};
+
+static struct sound_unit *__look_for_unit(int chain, int unit)
+{
+	struct sound_unit *s;
+	
+	s=chains[chain];
+	while(s && s->unit_minor <= unit)
+	{
+		if(s->unit_minor==unit)
+			return s;
+		s=s->next;
+	}
+	return NULL;
+}
+
+int soundcore_open(struct inode *inode, struct file *file)
+{
+	int chain;
+	int unit = iminor(inode);
+	struct sound_unit *s;
+	struct file_operations *new_fops = NULL;
+
+	chain=unit&0x0F;
+	if(chain==4 || chain==5)	/* dsp/audio/dsp16 */
+	{
+		unit&=0xF0;
+		unit|=3;
+		chain=3;
+	}
+	
+	spin_lock(&sound_loader_lock);
+	s = __look_for_unit(chain, unit);
+	if (s)
+		new_fops = fops_get(s->unit_fops);
+	if (!new_fops) {
+		spin_unlock(&sound_loader_lock);
+		/*
+		 *  Please, don't change this order or code.
+		 *  For ALSA slot means soundcard and OSS emulation code
+		 *  comes as add-on modules which aren't depend on
+		 *  ALSA toplevel modules for soundcards, thus we need
+		 *  load them at first.	  [Jaroslav Kysela <perex@jcu.cz>]
+		 */
+		request_module("sound-slot-%i", unit>>4);
+		request_module("sound-service-%i-%i", unit>>4, chain);
+		spin_lock(&sound_loader_lock);
+		s = __look_for_unit(chain, unit);
+		if (s)
+			new_fops = fops_get(s->unit_fops);
+	}
+	if (new_fops) {
+		/*
+		 * We rely upon the fact that we can't be unloaded while the
+		 * subdriver is there, so if ->open() is successful we can
+		 * safely drop the reference counter and if it is not we can
+		 * revert to old ->f_op. Ugly, indeed, but that's the cost of
+		 * switching ->f_op in the first place.
+		 */
+		int err = 0;
+		struct file_operations *old_fops = file->f_op;
+		file->f_op = new_fops;
+		spin_unlock(&sound_loader_lock);
+		if(file->f_op->open)
+			err = file->f_op->open(inode,file);
+		if (err) {
+			fops_put(file->f_op);
+			file->f_op = fops_get(old_fops);
+		}
+		fops_put(old_fops);
+		return err;
+	}
+	spin_unlock(&sound_loader_lock);
+	return -ENODEV;
+}
+
+extern int mod_firmware_load(const char *, char **);
+EXPORT_SYMBOL(mod_firmware_load);
+
+
+MODULE_DESCRIPTION("Core sound module");
+MODULE_AUTHOR("Alan Cox");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_CHARDEV_MAJOR(SOUND_MAJOR);
+
+static void __exit cleanup_soundcore(void)
+{
+	/* We have nothing to really do here - we know the lists must be
+	   empty */
+	unregister_chrdev(SOUND_MAJOR, "sound");
+	devfs_remove("sound");
+	class_simple_destroy(sound_class);
+}
+
+static int __init init_soundcore(void)
+{
+	if (register_chrdev(SOUND_MAJOR, "sound", &soundcore_fops)==-1) {
+		printk(KERN_ERR "soundcore: sound device already in use.\n");
+		return -EBUSY;
+	}
+	devfs_mk_dir ("sound");
+	sound_class = class_simple_create(THIS_MODULE, "sound");
+	if (IS_ERR(sound_class))
+		return PTR_ERR(sound_class);
+
+	return 0;
+}
+
+module_init(init_soundcore);
+module_exit(cleanup_soundcore);
