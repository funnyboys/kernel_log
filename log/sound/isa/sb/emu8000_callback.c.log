commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/isa/sb/emu8000_callback.c b/sound/isa/sb/emu8000_callback.c
index 5a485504f607..7609a5b640cb 100644
--- a/sound/isa/sb/emu8000_callback.c
+++ b/sound/isa/sb/emu8000_callback.c
@@ -1,22 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  synth callback routines for the emu8000 (AWE32/64)
  *
  *  Copyright (C) 1999 Steve Ratcliffe
  *  Copyright (C) 1999-2000 Takashi Iwai <tiwai@suse.de>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include "emu8000_local.h"

commit c9480d055e306a855f8a8d2b3b097773cd0d5ad0
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Mon Aug 14 19:13:26 2017 +0200

    sound: emu8000: constify emu8000_ops
    
    The structure emu8000_ops is only copied into another structure, so
    it can be const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sb/emu8000_callback.c b/sound/isa/sb/emu8000_callback.c
index d28d712f99f4..5a485504f607 100644
--- a/sound/isa/sb/emu8000_callback.c
+++ b/sound/isa/sb/emu8000_callback.c
@@ -62,7 +62,7 @@ static void snd_emu8000_tweak_voice(struct snd_emu8000 *emu, int ch);
 /*
  * set up operators
  */
-static struct snd_emux_operators emu8000_ops = {
+static const struct snd_emux_operators emu8000_ops = {
 	.owner =	THIS_MODULE,
 	.get_voice =	get_voice,
 	.prepare =	start_voice,

commit 3d774d5ef066971aee1839150bf47d100d8e43d3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 9 14:06:46 2017 +0200

    ALSA: seq: Allow the tristate build of OSS emulation
    
    Currently OSS sequencer emulation is tied with ALSA sequencer core,
    both are built in the same level; i.e. when CONFIG_SND_SEQUENCER=y,
    the OSS sequencer emulation is also always built-in, even though the
    functionality can be built as an individual module.
    
    This patch changes the rule and allows users to build snd-seq-oss
    module while others are built-in.  Essentially, it's just a few simple
    changes in Kconfig and Makefile.  Some driver codes like opl3 need to
    convert from the simple ifdef to IS_ENABLED().  But that's all.
    
    You might wonder how about the dependency: right, it can be messy, but
    it still works.  Since we rewrote the sequencer binding with the
    standard bus, the driver can be bound at any time on demand.  So, the
    synthesizer driver module can be loaded individually from the OSS
    emulation core before/after it.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sb/emu8000_callback.c b/sound/isa/sb/emu8000_callback.c
index 72a9ac5efb40..d28d712f99f4 100644
--- a/sound/isa/sb/emu8000_callback.c
+++ b/sound/isa/sb/emu8000_callback.c
@@ -36,7 +36,7 @@ static void reset_voice(struct snd_emux *emu, int ch);
 static void terminate_voice(struct snd_emux_voice *vp);
 static void sysex(struct snd_emux *emu, char *buf, int len, int parsed,
 		  struct snd_midi_channel_set *chset);
-#ifdef CONFIG_SND_SEQUENCER_OSS
+#if IS_ENABLED(CONFIG_SND_SEQUENCER_OSS)
 static int oss_ioctl(struct snd_emux *emu, int cmd, int p1, int p2);
 #endif
 static int load_fx(struct snd_emux *emu, int type, int mode,
@@ -76,7 +76,7 @@ static struct snd_emux_operators emu8000_ops = {
 	.sample_reset = snd_emu8000_sample_reset,
 	.load_fx =	load_fx,
 	.sysex =	sysex,
-#ifdef CONFIG_SND_SEQUENCER_OSS
+#if IS_ENABLED(CONFIG_SND_SEQUENCER_OSS)
 	.oss_ioctl =	oss_ioctl,
 #endif
 };
@@ -477,7 +477,7 @@ sysex(struct snd_emux *emu, char *buf, int len, int parsed, struct snd_midi_chan
 }
 
 
-#ifdef CONFIG_SND_SEQUENCER_OSS
+#if IS_ENABLED(CONFIG_SND_SEQUENCER_OSS)
 /*
  * OSS ioctl callback
  */

commit 395d9dd5dd13c6aa3c8c61a31126af98cd1e747d
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Fri Sep 28 11:24:57 2012 +0200

    sound: Remove unnecessary semicolon
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r1@
    statement S;
    position p,p1;
    @@
    S@p1;@p
    
    @script:python r2@
    p << r1.p;
    p1 << r1.p1;
    @@
    if p[0].line != p1[0].line_end:
            cocci.include_match(False)
    @@
    position r1.p;
    @@
    -;@p
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sb/emu8000_callback.c b/sound/isa/sb/emu8000_callback.c
index 344b4355be1c..72a9ac5efb40 100644
--- a/sound/isa/sb/emu8000_callback.c
+++ b/sound/isa/sb/emu8000_callback.c
@@ -175,7 +175,7 @@ get_voice(struct snd_emux *emu, struct snd_emux_port *port)
 	hw = emu->hw;
 
 	for (i = 0; i < END; i++) {
-		best[i].time = (unsigned int)(-1); /* XXX MAX_?INT really */;
+		best[i].time = (unsigned int)(-1); /* XXX MAX_?INT really */
 		best[i].voice = -1;
 	}
 

commit d81a6d71760c4d8323f1f9a506c64084caa09063
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Sep 22 09:34:58 2011 -0400

    sound: Add export.h for THIS_MODULE/EXPORT_SYMBOL where needed
    
    These aren't modules, but they do make use of these macros, so
    they will need export.h to get that definition.  Previously,
    they got it via the implicit module.h inclusion.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/isa/sb/emu8000_callback.c b/sound/isa/sb/emu8000_callback.c
index 9a3c71cc2e07..344b4355be1c 100644
--- a/sound/isa/sb/emu8000_callback.c
+++ b/sound/isa/sb/emu8000_callback.c
@@ -20,6 +20,7 @@
  */
 
 #include "emu8000_local.h"
+#include <linux/export.h>
 #include <sound/asoundef.h>
 
 /*

commit 029d64b0cfa30abc10f722e2f67d282abe09c9da
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:34:36 2005 +0100

    [ALSA] Remove xxx_t typedefs: ISA SB8/SB16/SBAWE
    
    Remove xxx_t typedefs from the ISA SB8/SB16/SBAWE drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sb/emu8000_callback.c b/sound/isa/sb/emu8000_callback.c
index 1cc4101a17a4..9a3c71cc2e07 100644
--- a/sound/isa/sb/emu8000_callback.c
+++ b/sound/isa/sb/emu8000_callback.c
@@ -25,27 +25,30 @@
 /*
  * prototypes
  */
-static snd_emux_voice_t *get_voice(snd_emux_t *emu, snd_emux_port_t *port);
-static int start_voice(snd_emux_voice_t *vp);
-static void trigger_voice(snd_emux_voice_t *vp);
-static void release_voice(snd_emux_voice_t *vp);
-static void update_voice(snd_emux_voice_t *vp, int update);
-static void reset_voice(snd_emux_t *emu, int ch);
-static void terminate_voice(snd_emux_voice_t *vp);
-static void sysex(snd_emux_t *emu, char *buf, int len, int parsed, snd_midi_channel_set_t *chset);
+static struct snd_emux_voice *get_voice(struct snd_emux *emu,
+					struct snd_emux_port *port);
+static int start_voice(struct snd_emux_voice *vp);
+static void trigger_voice(struct snd_emux_voice *vp);
+static void release_voice(struct snd_emux_voice *vp);
+static void update_voice(struct snd_emux_voice *vp, int update);
+static void reset_voice(struct snd_emux *emu, int ch);
+static void terminate_voice(struct snd_emux_voice *vp);
+static void sysex(struct snd_emux *emu, char *buf, int len, int parsed,
+		  struct snd_midi_channel_set *chset);
 #ifdef CONFIG_SND_SEQUENCER_OSS
-static int oss_ioctl(snd_emux_t *emu, int cmd, int p1, int p2);
+static int oss_ioctl(struct snd_emux *emu, int cmd, int p1, int p2);
 #endif
-static int load_fx(snd_emux_t *emu, int type, int mode, const void __user *buf, long len);
-
-static void set_pitch(emu8000_t *hw, snd_emux_voice_t *vp);
-static void set_volume(emu8000_t *hw, snd_emux_voice_t *vp);
-static void set_pan(emu8000_t *hw, snd_emux_voice_t *vp);
-static void set_fmmod(emu8000_t *hw, snd_emux_voice_t *vp);
-static void set_tremfreq(emu8000_t *hw, snd_emux_voice_t *vp);
-static void set_fm2frq2(emu8000_t *hw, snd_emux_voice_t *vp);
-static void set_filterQ(emu8000_t *hw, snd_emux_voice_t *vp);
-static void snd_emu8000_tweak_voice(emu8000_t *emu, int ch);
+static int load_fx(struct snd_emux *emu, int type, int mode,
+		   const void __user *buf, long len);
+
+static void set_pitch(struct snd_emu8000 *hw, struct snd_emux_voice *vp);
+static void set_volume(struct snd_emu8000 *hw, struct snd_emux_voice *vp);
+static void set_pan(struct snd_emu8000 *hw, struct snd_emux_voice *vp);
+static void set_fmmod(struct snd_emu8000 *hw, struct snd_emux_voice *vp);
+static void set_tremfreq(struct snd_emu8000 *hw, struct snd_emux_voice *vp);
+static void set_fm2frq2(struct snd_emu8000 *hw, struct snd_emux_voice *vp);
+static void set_filterQ(struct snd_emu8000 *hw, struct snd_emux_voice *vp);
+static void snd_emu8000_tweak_voice(struct snd_emu8000 *emu, int ch);
 
 /*
  * Ensure a value is between two points
@@ -58,7 +61,7 @@ static void snd_emu8000_tweak_voice(emu8000_t *emu, int ch);
 /*
  * set up operators
  */
-static snd_emux_operators_t emu8000_ops = {
+static struct snd_emux_operators emu8000_ops = {
 	.owner =	THIS_MODULE,
 	.get_voice =	get_voice,
 	.prepare =	start_voice,
@@ -78,7 +81,7 @@ static snd_emux_operators_t emu8000_ops = {
 };
 
 void
-snd_emu8000_ops_setup(emu8000_t *hw)
+snd_emu8000_ops_setup(struct snd_emu8000 *hw)
 {
 	hw->emu->ops = emu8000_ops;
 }
@@ -89,10 +92,10 @@ snd_emu8000_ops_setup(emu8000_t *hw)
  * Terminate a voice
  */
 static void
-release_voice(snd_emux_voice_t *vp)
+release_voice(struct snd_emux_voice *vp)
 {
 	int dcysusv;
-	emu8000_t *hw;
+	struct snd_emu8000 *hw;
 
 	hw = vp->hw;
 	dcysusv = 0x8000 | (unsigned char)vp->reg.parm.modrelease;
@@ -105,9 +108,9 @@ release_voice(snd_emux_voice_t *vp)
 /*
  */
 static void
-terminate_voice(snd_emux_voice_t *vp)
+terminate_voice(struct snd_emux_voice *vp)
 {
-	emu8000_t *hw; 
+	struct snd_emu8000 *hw; 
 
 	hw = vp->hw;
 	EMU8000_DCYSUSV_WRITE(hw, vp->ch, 0x807F);
@@ -117,9 +120,9 @@ terminate_voice(snd_emux_voice_t *vp)
 /*
  */
 static void
-update_voice(snd_emux_voice_t *vp, int update)
+update_voice(struct snd_emux_voice *vp, int update)
 {
-	emu8000_t *hw;
+	struct snd_emu8000 *hw;
 
 	hw = vp->hw;
 	if (update & SNDRV_EMUX_UPDATE_VOLUME)
@@ -149,12 +152,12 @@ update_voice(snd_emux_voice_t *vp, int update)
  * The channel index (vp->ch) must be initialized in this routine.
  * In Emu8k, it is identical with the array index.
  */
-static snd_emux_voice_t *
-get_voice(snd_emux_t *emu, snd_emux_port_t *port)
+static struct snd_emux_voice *
+get_voice(struct snd_emux *emu, struct snd_emux_port *port)
 {
 	int  i;
-	snd_emux_voice_t *vp;
-	emu8000_t *hw;
+	struct snd_emux_voice *vp;
+	struct snd_emu8000 *hw;
 
 	/* what we are looking for, in order of preference */
 	enum {
@@ -227,13 +230,13 @@ get_voice(snd_emux_t *emu, snd_emux_port_t *port)
 /*
  */
 static int
-start_voice(snd_emux_voice_t *vp)
+start_voice(struct snd_emux_voice *vp)
 {
 	unsigned int temp;
 	int ch;
 	int addr;
-	snd_midi_channel_t *chan;
-	emu8000_t *hw;
+	struct snd_midi_channel *chan;
+	struct snd_emu8000 *hw;
 
 	hw = vp->hw;
 	ch = vp->ch;
@@ -307,11 +310,11 @@ start_voice(snd_emux_voice_t *vp)
  * Start envelope
  */
 static void
-trigger_voice(snd_emux_voice_t *vp)
+trigger_voice(struct snd_emux_voice *vp)
 {
 	int ch = vp->ch;
 	unsigned int temp;
-	emu8000_t *hw;
+	struct snd_emu8000 *hw;
 
 	hw = vp->hw;
 
@@ -329,9 +332,9 @@ trigger_voice(snd_emux_voice_t *vp)
  * reset voice parameters
  */
 static void
-reset_voice(snd_emux_t *emu, int ch)
+reset_voice(struct snd_emux *emu, int ch)
 {
-	emu8000_t *hw;
+	struct snd_emu8000 *hw;
 
 	hw = emu->hw;
 	EMU8000_DCYSUSV_WRITE(hw, ch, 0x807F);
@@ -342,7 +345,7 @@ reset_voice(snd_emux_t *emu, int ch)
  * Set the pitch of a possibly playing note.
  */
 static void
-set_pitch(emu8000_t *hw, snd_emux_voice_t *vp)
+set_pitch(struct snd_emu8000 *hw, struct snd_emux_voice *vp)
 {
 	EMU8000_IP_WRITE(hw, vp->ch, vp->apitch);
 }
@@ -351,7 +354,7 @@ set_pitch(emu8000_t *hw, snd_emux_voice_t *vp)
  * Set the volume of a possibly already playing note
  */
 static void
-set_volume(emu8000_t *hw, snd_emux_voice_t *vp)
+set_volume(struct snd_emu8000 *hw, struct snd_emux_voice *vp)
 {
 	int  ifatn;
 
@@ -365,7 +368,7 @@ set_volume(emu8000_t *hw, snd_emux_voice_t *vp)
  * Set pan and loop start address.
  */
 static void
-set_pan(emu8000_t *hw, snd_emux_voice_t *vp)
+set_pan(struct snd_emu8000 *hw, struct snd_emux_voice *vp)
 {
 	unsigned int temp;
 
@@ -376,7 +379,7 @@ set_pan(emu8000_t *hw, snd_emux_voice_t *vp)
 #define MOD_SENSE 18
 
 static void
-set_fmmod(emu8000_t *hw, snd_emux_voice_t *vp)
+set_fmmod(struct snd_emu8000 *hw, struct snd_emux_voice *vp)
 {
 	unsigned short fmmod;
 	short pitch;
@@ -394,14 +397,14 @@ set_fmmod(emu8000_t *hw, snd_emux_voice_t *vp)
 
 /* set tremolo (lfo1) volume & frequency */
 static void
-set_tremfreq(emu8000_t *hw, snd_emux_voice_t *vp)
+set_tremfreq(struct snd_emu8000 *hw, struct snd_emux_voice *vp)
 {
 	EMU8000_TREMFRQ_WRITE(hw, vp->ch, vp->reg.parm.tremfrq);
 }
 
 /* set lfo2 pitch & frequency */
 static void
-set_fm2frq2(emu8000_t *hw, snd_emux_voice_t *vp)
+set_fm2frq2(struct snd_emu8000 *hw, struct snd_emux_voice *vp)
 {
 	unsigned short fm2frq2;
 	short pitch;
@@ -419,7 +422,7 @@ set_fm2frq2(emu8000_t *hw, snd_emux_voice_t *vp)
 
 /* set filterQ */
 static void
-set_filterQ(emu8000_t *hw, snd_emux_voice_t *vp)
+set_filterQ(struct snd_emu8000 *hw, struct snd_emux_voice *vp)
 {
 	unsigned int addr;
 	addr = EMU8000_CCCA_READ(hw, vp->ch) & 0xffffff;
@@ -431,7 +434,7 @@ set_filterQ(emu8000_t *hw, snd_emux_voice_t *vp)
  * set the envelope & LFO parameters to the default values
  */
 static void
-snd_emu8000_tweak_voice(emu8000_t *emu, int i)
+snd_emu8000_tweak_voice(struct snd_emu8000 *emu, int i)
 {
 	/* set all mod/vol envelope shape to minimum */
 	EMU8000_ENVVOL_WRITE(emu, i, 0x8000);
@@ -453,9 +456,9 @@ snd_emu8000_tweak_voice(emu8000_t *emu, int i)
  * sysex callback
  */
 static void
-sysex(snd_emux_t *emu, char *buf, int len, int parsed, snd_midi_channel_set_t *chset)
+sysex(struct snd_emux *emu, char *buf, int len, int parsed, struct snd_midi_channel_set *chset)
 {
-	emu8000_t *hw;
+	struct snd_emu8000 *hw;
 
 	hw = emu->hw;
 
@@ -478,9 +481,9 @@ sysex(snd_emux_t *emu, char *buf, int len, int parsed, snd_midi_channel_set_t *c
  * OSS ioctl callback
  */
 static int
-oss_ioctl(snd_emux_t *emu, int cmd, int p1, int p2)
+oss_ioctl(struct snd_emux *emu, int cmd, int p1, int p2)
 {
-	emu8000_t *hw;
+	struct snd_emu8000 *hw;
 
 	hw = emu->hw;
 
@@ -523,9 +526,9 @@ oss_ioctl(snd_emux_t *emu, int cmd, int p1, int p2)
  */
 
 static int
-load_fx(snd_emux_t *emu, int type, int mode, const void __user *buf, long len)
+load_fx(struct snd_emux *emu, int type, int mode, const void __user *buf, long len)
 {
-	emu8000_t *hw;
+	struct snd_emu8000 *hw;
 	hw = emu->hw;
 
 	/* skip header */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/isa/sb/emu8000_callback.c b/sound/isa/sb/emu8000_callback.c
new file mode 100644
index 000000000000..1cc4101a17a4
--- /dev/null
+++ b/sound/isa/sb/emu8000_callback.c
@@ -0,0 +1,543 @@
+/*
+ *  synth callback routines for the emu8000 (AWE32/64)
+ *
+ *  Copyright (C) 1999 Steve Ratcliffe
+ *  Copyright (C) 1999-2000 Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include "emu8000_local.h"
+#include <sound/asoundef.h>
+
+/*
+ * prototypes
+ */
+static snd_emux_voice_t *get_voice(snd_emux_t *emu, snd_emux_port_t *port);
+static int start_voice(snd_emux_voice_t *vp);
+static void trigger_voice(snd_emux_voice_t *vp);
+static void release_voice(snd_emux_voice_t *vp);
+static void update_voice(snd_emux_voice_t *vp, int update);
+static void reset_voice(snd_emux_t *emu, int ch);
+static void terminate_voice(snd_emux_voice_t *vp);
+static void sysex(snd_emux_t *emu, char *buf, int len, int parsed, snd_midi_channel_set_t *chset);
+#ifdef CONFIG_SND_SEQUENCER_OSS
+static int oss_ioctl(snd_emux_t *emu, int cmd, int p1, int p2);
+#endif
+static int load_fx(snd_emux_t *emu, int type, int mode, const void __user *buf, long len);
+
+static void set_pitch(emu8000_t *hw, snd_emux_voice_t *vp);
+static void set_volume(emu8000_t *hw, snd_emux_voice_t *vp);
+static void set_pan(emu8000_t *hw, snd_emux_voice_t *vp);
+static void set_fmmod(emu8000_t *hw, snd_emux_voice_t *vp);
+static void set_tremfreq(emu8000_t *hw, snd_emux_voice_t *vp);
+static void set_fm2frq2(emu8000_t *hw, snd_emux_voice_t *vp);
+static void set_filterQ(emu8000_t *hw, snd_emux_voice_t *vp);
+static void snd_emu8000_tweak_voice(emu8000_t *emu, int ch);
+
+/*
+ * Ensure a value is between two points
+ * macro evaluates its args more than once, so changed to upper-case.
+ */
+#define LIMITVALUE(x, a, b) do { if ((x) < (a)) (x) = (a); else if ((x) > (b)) (x) = (b); } while (0)
+#define LIMITMAX(x, a) do {if ((x) > (a)) (x) = (a); } while (0)
+
+
+/*
+ * set up operators
+ */
+static snd_emux_operators_t emu8000_ops = {
+	.owner =	THIS_MODULE,
+	.get_voice =	get_voice,
+	.prepare =	start_voice,
+	.trigger =	trigger_voice,
+	.release =	release_voice,
+	.update =	update_voice,
+	.terminate =	terminate_voice,
+	.reset =	reset_voice,
+	.sample_new =	snd_emu8000_sample_new,
+	.sample_free =	snd_emu8000_sample_free,
+	.sample_reset = snd_emu8000_sample_reset,
+	.load_fx =	load_fx,
+	.sysex =	sysex,
+#ifdef CONFIG_SND_SEQUENCER_OSS
+	.oss_ioctl =	oss_ioctl,
+#endif
+};
+
+void
+snd_emu8000_ops_setup(emu8000_t *hw)
+{
+	hw->emu->ops = emu8000_ops;
+}
+
+
+
+/*
+ * Terminate a voice
+ */
+static void
+release_voice(snd_emux_voice_t *vp)
+{
+	int dcysusv;
+	emu8000_t *hw;
+
+	hw = vp->hw;
+	dcysusv = 0x8000 | (unsigned char)vp->reg.parm.modrelease;
+	EMU8000_DCYSUS_WRITE(hw, vp->ch, dcysusv);
+	dcysusv = 0x8000 | (unsigned char)vp->reg.parm.volrelease;
+	EMU8000_DCYSUSV_WRITE(hw, vp->ch, dcysusv);
+}
+
+
+/*
+ */
+static void
+terminate_voice(snd_emux_voice_t *vp)
+{
+	emu8000_t *hw; 
+
+	hw = vp->hw;
+	EMU8000_DCYSUSV_WRITE(hw, vp->ch, 0x807F);
+}
+
+
+/*
+ */
+static void
+update_voice(snd_emux_voice_t *vp, int update)
+{
+	emu8000_t *hw;
+
+	hw = vp->hw;
+	if (update & SNDRV_EMUX_UPDATE_VOLUME)
+		set_volume(hw, vp);
+	if (update & SNDRV_EMUX_UPDATE_PITCH)
+		set_pitch(hw, vp);
+	if ((update & SNDRV_EMUX_UPDATE_PAN) &&
+	    vp->port->ctrls[EMUX_MD_REALTIME_PAN])
+		set_pan(hw, vp);
+	if (update & SNDRV_EMUX_UPDATE_FMMOD)
+		set_fmmod(hw, vp);
+	if (update & SNDRV_EMUX_UPDATE_TREMFREQ)
+		set_tremfreq(hw, vp);
+	if (update & SNDRV_EMUX_UPDATE_FM2FRQ2)
+		set_fm2frq2(hw, vp);
+	if (update & SNDRV_EMUX_UPDATE_Q)
+		set_filterQ(hw, vp);
+}
+
+
+/*
+ * Find a channel (voice) within the EMU that is not in use or at least
+ * less in use than other channels.  Always returns a valid pointer
+ * no matter what.  If there is a real shortage of voices then one
+ * will be cut. Such is life.
+ *
+ * The channel index (vp->ch) must be initialized in this routine.
+ * In Emu8k, it is identical with the array index.
+ */
+static snd_emux_voice_t *
+get_voice(snd_emux_t *emu, snd_emux_port_t *port)
+{
+	int  i;
+	snd_emux_voice_t *vp;
+	emu8000_t *hw;
+
+	/* what we are looking for, in order of preference */
+	enum {
+		OFF=0, RELEASED, PLAYING, END
+	};
+
+	/* Keeps track of what we are finding */
+	struct best {
+		unsigned int  time;
+		int voice;
+	} best[END];
+	struct best *bp;
+
+	hw = emu->hw;
+
+	for (i = 0; i < END; i++) {
+		best[i].time = (unsigned int)(-1); /* XXX MAX_?INT really */;
+		best[i].voice = -1;
+	}
+
+	/*
+	 * Go through them all and get a best one to use.
+	 */
+	for (i = 0; i < emu->max_voices; i++) {
+		int state, val;
+
+		vp = &emu->voices[i];
+		state = vp->state;
+
+		if (state == SNDRV_EMUX_ST_OFF)
+			bp = best + OFF;
+		else if (state == SNDRV_EMUX_ST_RELEASED ||
+			 state == SNDRV_EMUX_ST_PENDING) {
+			bp = best + RELEASED;
+			val = (EMU8000_CVCF_READ(hw, vp->ch) >> 16) & 0xffff;
+			if (! val)
+				bp = best + OFF;
+		}
+		else if (state & SNDRV_EMUX_ST_ON)
+			bp = best + PLAYING;
+		else
+			continue;
+
+		/* check if sample is finished playing (non-looping only) */
+		if (state != SNDRV_EMUX_ST_OFF &&
+		    (vp->reg.sample_mode & SNDRV_SFNT_SAMPLE_SINGLESHOT)) {
+			val = EMU8000_CCCA_READ(hw, vp->ch) & 0xffffff;
+			if (val >= vp->reg.loopstart)
+				bp = best + OFF;
+		}
+
+		if (vp->time < bp->time) {
+			bp->time = vp->time;
+			bp->voice = i;
+		}
+	}
+
+	for (i = 0; i < END; i++) {
+		if (best[i].voice >= 0) {
+			vp = &emu->voices[best[i].voice];
+			vp->ch = best[i].voice;
+			return vp;
+		}
+	}
+
+	/* not found */
+	return NULL;
+}
+
+/*
+ */
+static int
+start_voice(snd_emux_voice_t *vp)
+{
+	unsigned int temp;
+	int ch;
+	int addr;
+	snd_midi_channel_t *chan;
+	emu8000_t *hw;
+
+	hw = vp->hw;
+	ch = vp->ch;
+	chan = vp->chan;
+
+	/* channel to be silent and idle */
+	EMU8000_DCYSUSV_WRITE(hw, ch, 0x0080);
+	EMU8000_VTFT_WRITE(hw, ch, 0x0000FFFF);
+	EMU8000_CVCF_WRITE(hw, ch, 0x0000FFFF);
+	EMU8000_PTRX_WRITE(hw, ch, 0);
+	EMU8000_CPF_WRITE(hw, ch, 0);
+
+	/* set pitch offset */
+	set_pitch(hw, vp);
+
+	/* set envelope parameters */
+	EMU8000_ENVVAL_WRITE(hw, ch, vp->reg.parm.moddelay);
+	EMU8000_ATKHLD_WRITE(hw, ch, vp->reg.parm.modatkhld);
+	EMU8000_DCYSUS_WRITE(hw, ch, vp->reg.parm.moddcysus);
+	EMU8000_ENVVOL_WRITE(hw, ch, vp->reg.parm.voldelay);
+	EMU8000_ATKHLDV_WRITE(hw, ch, vp->reg.parm.volatkhld);
+	/* decay/sustain parameter for volume envelope is used
+	   for triggerg the voice */
+
+	/* cutoff and volume */
+	set_volume(hw, vp);
+
+	/* modulation envelope heights */
+	EMU8000_PEFE_WRITE(hw, ch, vp->reg.parm.pefe);
+
+	/* lfo1/2 delay */
+	EMU8000_LFO1VAL_WRITE(hw, ch, vp->reg.parm.lfo1delay);
+	EMU8000_LFO2VAL_WRITE(hw, ch, vp->reg.parm.lfo2delay);
+
+	/* lfo1 pitch & cutoff shift */
+	set_fmmod(hw, vp);
+	/* lfo1 volume & freq */
+	set_tremfreq(hw, vp);
+	/* lfo2 pitch & freq */
+	set_fm2frq2(hw, vp);
+	/* pan & loop start */
+	set_pan(hw, vp);
+
+	/* chorus & loop end (chorus 8bit, MSB) */
+	addr = vp->reg.loopend - 1;
+	temp = vp->reg.parm.chorus;
+	temp += (int)chan->control[MIDI_CTL_E3_CHORUS_DEPTH] * 9 / 10;
+	LIMITMAX(temp, 255);
+	temp = (temp <<24) | (unsigned int)addr;
+	EMU8000_CSL_WRITE(hw, ch, temp);
+
+	/* Q & current address (Q 4bit value, MSB) */
+	addr = vp->reg.start - 1;
+	temp = vp->reg.parm.filterQ;
+	temp = (temp<<28) | (unsigned int)addr;
+	EMU8000_CCCA_WRITE(hw, ch, temp);
+
+	/* clear unknown registers */
+	EMU8000_00A0_WRITE(hw, ch, 0);
+	EMU8000_0080_WRITE(hw, ch, 0);
+
+	/* reset volume */
+	temp = vp->vtarget << 16;
+	EMU8000_VTFT_WRITE(hw, ch, temp | vp->ftarget);
+	EMU8000_CVCF_WRITE(hw, ch, temp | 0xff00);
+
+	return 0;
+}
+
+/*
+ * Start envelope
+ */
+static void
+trigger_voice(snd_emux_voice_t *vp)
+{
+	int ch = vp->ch;
+	unsigned int temp;
+	emu8000_t *hw;
+
+	hw = vp->hw;
+
+	/* set reverb and pitch target */
+	temp = vp->reg.parm.reverb;
+	temp += (int)vp->chan->control[MIDI_CTL_E1_REVERB_DEPTH] * 9 / 10;
+	LIMITMAX(temp, 255);
+	temp = (temp << 8) | (vp->ptarget << 16) | vp->aaux;
+	EMU8000_PTRX_WRITE(hw, ch, temp);
+	EMU8000_CPF_WRITE(hw, ch, vp->ptarget << 16);
+	EMU8000_DCYSUSV_WRITE(hw, ch, vp->reg.parm.voldcysus);
+}
+
+/*
+ * reset voice parameters
+ */
+static void
+reset_voice(snd_emux_t *emu, int ch)
+{
+	emu8000_t *hw;
+
+	hw = emu->hw;
+	EMU8000_DCYSUSV_WRITE(hw, ch, 0x807F);
+	snd_emu8000_tweak_voice(hw, ch);
+}
+
+/*
+ * Set the pitch of a possibly playing note.
+ */
+static void
+set_pitch(emu8000_t *hw, snd_emux_voice_t *vp)
+{
+	EMU8000_IP_WRITE(hw, vp->ch, vp->apitch);
+}
+
+/*
+ * Set the volume of a possibly already playing note
+ */
+static void
+set_volume(emu8000_t *hw, snd_emux_voice_t *vp)
+{
+	int  ifatn;
+
+	ifatn = (unsigned char)vp->acutoff;
+	ifatn = (ifatn << 8);
+	ifatn |= (unsigned char)vp->avol;
+	EMU8000_IFATN_WRITE(hw, vp->ch, ifatn);
+}
+
+/*
+ * Set pan and loop start address.
+ */
+static void
+set_pan(emu8000_t *hw, snd_emux_voice_t *vp)
+{
+	unsigned int temp;
+
+	temp = ((unsigned int)vp->apan<<24) | ((unsigned int)vp->reg.loopstart - 1);
+	EMU8000_PSST_WRITE(hw, vp->ch, temp);
+}
+
+#define MOD_SENSE 18
+
+static void
+set_fmmod(emu8000_t *hw, snd_emux_voice_t *vp)
+{
+	unsigned short fmmod;
+	short pitch;
+	unsigned char cutoff;
+	int modulation;
+
+	pitch = (char)(vp->reg.parm.fmmod>>8);
+	cutoff = (vp->reg.parm.fmmod & 0xff);
+	modulation = vp->chan->gm_modulation + vp->chan->midi_pressure;
+	pitch += (MOD_SENSE * modulation) / 1200;
+	LIMITVALUE(pitch, -128, 127);
+	fmmod = ((unsigned char)pitch<<8) | cutoff;
+	EMU8000_FMMOD_WRITE(hw, vp->ch, fmmod);
+}
+
+/* set tremolo (lfo1) volume & frequency */
+static void
+set_tremfreq(emu8000_t *hw, snd_emux_voice_t *vp)
+{
+	EMU8000_TREMFRQ_WRITE(hw, vp->ch, vp->reg.parm.tremfrq);
+}
+
+/* set lfo2 pitch & frequency */
+static void
+set_fm2frq2(emu8000_t *hw, snd_emux_voice_t *vp)
+{
+	unsigned short fm2frq2;
+	short pitch;
+	unsigned char freq;
+	int modulation;
+
+	pitch = (char)(vp->reg.parm.fm2frq2>>8);
+	freq = vp->reg.parm.fm2frq2 & 0xff;
+	modulation = vp->chan->gm_modulation + vp->chan->midi_pressure;
+	pitch += (MOD_SENSE * modulation) / 1200;
+	LIMITVALUE(pitch, -128, 127);
+	fm2frq2 = ((unsigned char)pitch<<8) | freq;
+	EMU8000_FM2FRQ2_WRITE(hw, vp->ch, fm2frq2);
+}
+
+/* set filterQ */
+static void
+set_filterQ(emu8000_t *hw, snd_emux_voice_t *vp)
+{
+	unsigned int addr;
+	addr = EMU8000_CCCA_READ(hw, vp->ch) & 0xffffff;
+	addr |= (vp->reg.parm.filterQ << 28);
+	EMU8000_CCCA_WRITE(hw, vp->ch, addr);
+}
+
+/*
+ * set the envelope & LFO parameters to the default values
+ */
+static void
+snd_emu8000_tweak_voice(emu8000_t *emu, int i)
+{
+	/* set all mod/vol envelope shape to minimum */
+	EMU8000_ENVVOL_WRITE(emu, i, 0x8000);
+	EMU8000_ENVVAL_WRITE(emu, i, 0x8000);
+	EMU8000_DCYSUS_WRITE(emu, i, 0x7F7F);
+	EMU8000_ATKHLDV_WRITE(emu, i, 0x7F7F);
+	EMU8000_ATKHLD_WRITE(emu, i, 0x7F7F);
+	EMU8000_PEFE_WRITE(emu, i, 0);  /* mod envelope height to zero */
+	EMU8000_LFO1VAL_WRITE(emu, i, 0x8000); /* no delay for LFO1 */
+	EMU8000_LFO2VAL_WRITE(emu, i, 0x8000);
+	EMU8000_IP_WRITE(emu, i, 0xE000);	/* no pitch shift */
+	EMU8000_IFATN_WRITE(emu, i, 0xFF00);	/* volume to minimum */
+	EMU8000_FMMOD_WRITE(emu, i, 0);
+	EMU8000_TREMFRQ_WRITE(emu, i, 0);
+	EMU8000_FM2FRQ2_WRITE(emu, i, 0);
+}
+
+/*
+ * sysex callback
+ */
+static void
+sysex(snd_emux_t *emu, char *buf, int len, int parsed, snd_midi_channel_set_t *chset)
+{
+	emu8000_t *hw;
+
+	hw = emu->hw;
+
+	switch (parsed) {
+	case SNDRV_MIDI_SYSEX_GS_CHORUS_MODE:
+		hw->chorus_mode = chset->gs_chorus_mode;
+		snd_emu8000_update_chorus_mode(hw);
+		break;
+
+	case SNDRV_MIDI_SYSEX_GS_REVERB_MODE:
+		hw->reverb_mode = chset->gs_reverb_mode;
+		snd_emu8000_update_reverb_mode(hw);
+		break;
+	}
+}
+
+
+#ifdef CONFIG_SND_SEQUENCER_OSS
+/*
+ * OSS ioctl callback
+ */
+static int
+oss_ioctl(snd_emux_t *emu, int cmd, int p1, int p2)
+{
+	emu8000_t *hw;
+
+	hw = emu->hw;
+
+	switch (cmd) {
+	case _EMUX_OSS_REVERB_MODE:
+		hw->reverb_mode = p1;
+		snd_emu8000_update_reverb_mode(hw);
+		break;
+
+	case _EMUX_OSS_CHORUS_MODE:
+		hw->chorus_mode = p1;
+		snd_emu8000_update_chorus_mode(hw);
+		break;
+
+	case _EMUX_OSS_INITIALIZE_CHIP:
+		/* snd_emu8000_init(hw); */ /*ignored*/
+		break;
+
+	case _EMUX_OSS_EQUALIZER:
+		hw->bass_level = p1;
+		hw->treble_level = p2;
+		snd_emu8000_update_equalizer(hw);
+		break;
+	}
+	return 0;
+}
+#endif
+
+
+/*
+ * additional patch keys
+ */
+
+#define SNDRV_EMU8000_LOAD_CHORUS_FX	0x10	/* optarg=mode */
+#define SNDRV_EMU8000_LOAD_REVERB_FX	0x11	/* optarg=mode */
+
+
+/*
+ * callback routine
+ */
+
+static int
+load_fx(snd_emux_t *emu, int type, int mode, const void __user *buf, long len)
+{
+	emu8000_t *hw;
+	hw = emu->hw;
+
+	/* skip header */
+	buf += 16;
+	len -= 16;
+
+	switch (type) {
+	case SNDRV_EMU8000_LOAD_CHORUS_FX:
+		return snd_emu8000_load_chorus_fx(hw, mode, buf, len);
+	case SNDRV_EMU8000_LOAD_REVERB_FX:
+		return snd_emu8000_load_reverb_fx(hw, mode, buf, len);
+	}
+	return -EINVAL;
+}
+
