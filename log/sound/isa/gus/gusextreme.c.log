commit 15a1af95d65729d35071445b9459c1e22f776347
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:48:04 2020 +0100

    ALSA: gus: More constifications
    
    Apply const prefix to each possible place: the static resource tables,
    the volume table, etc.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-50-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 8cf366bbdd8d..ed2f9d64efae 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -83,9 +83,9 @@ static int snd_gusextreme_es1688_create(struct snd_card *card,
 					struct snd_es1688 *chip,
 					struct device *dev, unsigned int n)
 {
-	static long possible_ports[] = {0x220, 0x240, 0x260};
-	static int possible_irqs[] = {5, 9, 10, 7, -1};
-	static int possible_dmas[] = {1, 3, 0, -1};
+	static const long possible_ports[] = {0x220, 0x240, 0x260};
+	static const int possible_irqs[] = {5, 9, 10, 7, -1};
+	static const int possible_dmas[] = {1, 3, 0, -1};
 
 	int i, error;
 
@@ -122,8 +122,8 @@ static int snd_gusextreme_gus_card_create(struct snd_card *card,
 					  struct device *dev, unsigned int n,
 					  struct snd_gus_card **rgus)
 {
-	static int possible_irqs[] = {11, 12, 15, 9, 5, 7, 3, -1};
-	static int possible_dmas[] = {5, 6, 7, 3, 1, -1};
+	static const int possible_irqs[] = {11, 12, 15, 9, 5, 7, 3, -1};
+	static const int possible_dmas[] = {5, 6, 7, 3, 1, -1};
 
 	if (gf1_irq[n] == SNDRV_AUTO_IRQ) {
 		gf1_irq[n] = snd_legacy_find_free_irq(possible_irqs);

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index beb52c0f70ea..8cf366bbdd8d 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -1,22 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Driver for Gravis UltraSound Extreme soundcards
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/init.h>

commit e992ef5705c1e154acb248869b39e0be4c003a8b
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:30 2017 +0100

    Annotate hardware config module parameters in sound/isa/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in sound/isa/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jaroslav Kysela <perex@perex.cz>
    cc: Takashi Iwai <tiwai@suse.com>
    cc: alsa-devel@alsa-project.org

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 77ac2fd723b4..beb52c0f70ea 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -66,21 +66,21 @@ module_param_array(id, charp, NULL, 0444);
 MODULE_PARM_DESC(id, "ID string for " CRD_NAME " soundcard.");
 module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable " CRD_NAME " soundcard.");
-module_param_array(port, long, NULL, 0444);
+module_param_hw_array(port, long, ioport, NULL, 0444);
 MODULE_PARM_DESC(port, "Port # for " CRD_NAME " driver.");
-module_param_array(gf1_port, long, NULL, 0444);
+module_param_hw_array(gf1_port, long, ioport, NULL, 0444);
 MODULE_PARM_DESC(gf1_port, "GF1 port # for " CRD_NAME " driver (optional).");
-module_param_array(mpu_port, long, NULL, 0444);
+module_param_hw_array(mpu_port, long, ioport, NULL, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for " CRD_NAME " driver.");
-module_param_array(irq, int, NULL, 0444);
+module_param_hw_array(irq, int, irq, NULL, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for " CRD_NAME " driver.");
-module_param_array(mpu_irq, int, NULL, 0444);
+module_param_hw_array(mpu_irq, int, irq, NULL, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU-401 IRQ # for " CRD_NAME " driver.");
-module_param_array(gf1_irq, int, NULL, 0444);
+module_param_hw_array(gf1_irq, int, irq, NULL, 0444);
 MODULE_PARM_DESC(gf1_irq, "GF1 IRQ # for " CRD_NAME " driver.");
-module_param_array(dma8, int, NULL, 0444);
+module_param_hw_array(dma8, int, dma, NULL, 0444);
 MODULE_PARM_DESC(dma8, "8-bit DMA # for " CRD_NAME " driver.");
-module_param_array(dma1, int, NULL, 0444);
+module_param_hw_array(dma1, int, dma, NULL, 0444);
 MODULE_PARM_DESC(dma1, "GF1 DMA # for " CRD_NAME " driver.");
 module_param_array(joystick_dac, int, NULL, 0444);
 MODULE_PARM_DESC(joystick_dac, "Joystick DAC level 0.59V-4.52V or 0.389V-2.98V for " CRD_NAME " driver.");

commit bfc7e0ffce0a31e1b1552d19c87340f7edeb80f3
Author: William Breathitt Gray <vilhelm.gray@gmail.com>
Date:   Tue May 31 11:55:58 2016 -0400

    ALSA: gusextreme: Utilize the module_isa_driver macro
    
    This driver does not do anything special in module init/exit. This patch
    eliminates the module init/exit boilerplate code by utilizing the
    module_isa_driver macro.
    
    Signed-off-by: William Breathitt Gray <vilhelm.gray@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 693d95f46804..77ac2fd723b4 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -358,15 +358,4 @@ static struct isa_driver snd_gusextreme_driver = {
 	}
 };
 
-static int __init alsa_card_gusextreme_init(void)
-{
-	return isa_register_driver(&snd_gusextreme_driver, SNDRV_CARDS);
-}
-
-static void __exit alsa_card_gusextreme_exit(void)
-{
-	isa_unregister_driver(&snd_gusextreme_driver);
-}
-
-module_init(alsa_card_gusextreme_init);
-module_exit(alsa_card_gusextreme_exit);
+module_isa_driver(snd_gusextreme_driver, SNDRV_CARDS);

commit db5abb3c499e553a8afedee1417d6a6308dda7bd
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Jan 2 12:24:39 2015 +0100

    ALSA: gus: Remove always NULL parameters
    
    snd_gf1_pcm_new() and snd_gf1_rawmidi_new() take a pointer to a pointer of a
    PCM/MIDI where if this parameter is provided the newly allocated object is
    stored. All callers pass NULL though, so remove the parameter. This makes
    the code a bit cleaner and shorter.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index acc655284a9c..693d95f46804 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -295,7 +295,7 @@ static int snd_gusextreme_probe(struct device *dev, unsigned int n)
 	snd_component_add(card, "ES1688");
 
 	if (pcm_channels[n] > 0) {
-		error = snd_gf1_pcm_new(gus, 1, 1, NULL);
+		error = snd_gf1_pcm_new(gus, 1, 1);
 		if (error < 0)
 			goto out;
 	}

commit 4b8ab88518726197c8659bc9aca96c6af01dab57
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Jan 2 12:24:37 2015 +0100

    ALSA: es1688: Remove almost always NULL parameter
    
    snd_es1688_pcm() takes a pointer to a pointer of a PCM where if this
    parameter is provided the newly allocated PCM is stored. This PCM is also
    available from the pcm field of the snd_es1688 struct that got passed to the
    same function. This patch updates all callers which passed a pointer to use
    that field instead and then removes the parameter from the function. This
    makes the code a bit shorter and cleaner.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 28a16936a397..acc655284a9c 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -284,7 +284,7 @@ static int snd_gusextreme_probe(struct device *dev, unsigned int n)
 	}
 	gus->codec_flag = 1;
 
-	error = snd_es1688_pcm(card, es1688, 0, NULL);
+	error = snd_es1688_pcm(card, es1688, 0);
 	if (error < 0)
 		goto out;
 

commit 4323cc4d5b25b5138c0791e3c7d3b09bd7062b49
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 13:03:56 2014 +0100

    ALSA: isa: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 38e1e3260c24..28a16936a397 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -242,8 +242,8 @@ static int snd_gusextreme_probe(struct device *dev, unsigned int n)
 	struct snd_opl3 *opl3;
 	int error;
 
-	error = snd_card_create(index[n], id[n], THIS_MODULE,
-				sizeof(struct snd_es1688), &card);
+	error = snd_card_new(dev, index[n], id[n], THIS_MODULE,
+			     sizeof(struct snd_es1688), &card);
 	if (error < 0)
 		return error;
 
@@ -328,8 +328,6 @@ static int snd_gusextreme_probe(struct device *dev, unsigned int n)
 		"irq %i&%i, dma %i&%i", es1688->port,
 		gus->gf1.irq, es1688->irq, gus->gf1.dma1, es1688->dma8);
 
-	snd_card_set_dev(card, dev);
-
 	error = snd_card_register(card);
 	if (error < 0)
 		goto out;

commit 8b5a1f9c46c2b78716794b8762edf659ec25a87d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:49:32 2013 +0200

    ALSA: ISA: Remove superfluous *_set_drvdata(NULL) calls
    
    Similarly like the previous commit for PCI drivers, remove
    dev_set_drvdata(NULL) and pnp_set_drvdata(NULL) calls in ISA drivers
    now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 0b9c2426b49f..38e1e3260c24 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -344,7 +344,6 @@ out:	snd_card_free(card);
 static int snd_gusextreme_remove(struct device *dev, unsigned int n)
 {
 	snd_card_free(dev_get_drvdata(dev));
-	dev_set_drvdata(dev, NULL);
 	return 0;
 }
 

commit 1bff292e9abec7477d43abb2b93c7fd26c44859b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:21 2012 -0500

    ALSA: isa: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index bc10cc26e5f9..0b9c2426b49f 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -89,13 +89,14 @@ MODULE_PARM_DESC(channels, "GF1 channels for " CRD_NAME " driver.");
 module_param_array(pcm_channels, int, NULL, 0444);
 MODULE_PARM_DESC(pcm_channels, "Reserved PCM channels for " CRD_NAME " driver.");
 
-static int __devinit snd_gusextreme_match(struct device *dev, unsigned int n)
+static int snd_gusextreme_match(struct device *dev, unsigned int n)
 {
 	return enable[n];
 }
 
-static int __devinit snd_gusextreme_es1688_create(struct snd_card *card,
-		struct snd_es1688 *chip, struct device *dev, unsigned int n)
+static int snd_gusextreme_es1688_create(struct snd_card *card,
+					struct snd_es1688 *chip,
+					struct device *dev, unsigned int n)
 {
 	static long possible_ports[] = {0x220, 0x240, 0x260};
 	static int possible_irqs[] = {5, 9, 10, 7, -1};
@@ -132,8 +133,9 @@ static int __devinit snd_gusextreme_es1688_create(struct snd_card *card,
 	return error;
 }
 
-static int __devinit snd_gusextreme_gus_card_create(struct snd_card *card,
-		struct device *dev, unsigned int n, struct snd_gus_card **rgus)
+static int snd_gusextreme_gus_card_create(struct snd_card *card,
+					  struct device *dev, unsigned int n,
+					  struct snd_gus_card **rgus)
 {
 	static int possible_irqs[] = {11, 12, 15, 9, 5, 7, 3, -1};
 	static int possible_dmas[] = {5, 6, 7, 3, 1, -1};
@@ -156,8 +158,8 @@ static int __devinit snd_gusextreme_gus_card_create(struct snd_card *card,
 			0, channels[n], pcm_channels[n], 0, rgus);
 }
 
-static int __devinit snd_gusextreme_detect(struct snd_gus_card *gus,
-	struct snd_es1688 *es1688)
+static int snd_gusextreme_detect(struct snd_gus_card *gus,
+				 struct snd_es1688 *es1688)
 {
 	unsigned long flags;
 	unsigned char d;
@@ -206,7 +208,7 @@ static int __devinit snd_gusextreme_detect(struct snd_gus_card *gus,
 	return 0;
 }
 
-static int __devinit snd_gusextreme_mixer(struct snd_card *card)
+static int snd_gusextreme_mixer(struct snd_card *card)
 {
 	struct snd_ctl_elem_id id1, id2;
 	int error;
@@ -232,7 +234,7 @@ static int __devinit snd_gusextreme_mixer(struct snd_card *card)
 	return 0;
 }
 
-static int __devinit snd_gusextreme_probe(struct device *dev, unsigned int n)
+static int snd_gusextreme_probe(struct device *dev, unsigned int n)
 {
 	struct snd_card *card;
 	struct snd_gus_card *gus;
@@ -339,7 +341,7 @@ out:	snd_card_free(card);
 	return error;
 }
 
-static int __devexit snd_gusextreme_remove(struct device *dev, unsigned int n)
+static int snd_gusextreme_remove(struct device *dev, unsigned int n)
 {
 	snd_card_free(dev_get_drvdata(dev));
 	dev_set_drvdata(dev, NULL);
@@ -349,7 +351,7 @@ static int __devexit snd_gusextreme_remove(struct device *dev, unsigned int n)
 static struct isa_driver snd_gusextreme_driver = {
 	.match		= snd_gusextreme_match,
 	.probe		= snd_gusextreme_probe,
-	.remove		= __devexit_p(snd_gusextreme_remove),
+	.remove		= snd_gusextreme_remove,
 #if 0	/* FIXME */
 	.suspend	= snd_gusextreme_suspend,
 	.resume		= snd_gusextreme_resume,

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 597accdb15d2..bc10cc26e5f9 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -46,7 +46,7 @@ MODULE_SUPPORTED_DEVICE("{{Gravis,UltraSound Extreme}}");
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;	/* Enable this card */
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;	/* Enable this card */
 static long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;	/* 0x220,0x240,0x260 */
 static long gf1_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS) - 1] = -1}; /* 0x210,0x220,0x230,0x240,0x250,0x260,0x270 */
 static long mpu_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS) - 1] = -1}; /* 0x300,0x310,0x320 */

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index c4733c08b60b..597accdb15d2 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -24,7 +24,7 @@
 #include <linux/isa.h>
 #include <linux/delay.h>
 #include <linux/time.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <asm/dma.h>
 #include <sound/core.h>
 #include <sound/gus.h>

commit dba8b46992c55946d3b092934f581a343403118f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Sep 13 11:24:41 2011 +0200

    ALSA: mpu401: clean up interrupt specification
    
    The semantics of snd_mpu401_uart_new()'s interrupt parameters are
    somewhat counterintuitive:  To prevent the function from allocating its
    own interrupt, either the irq number must be invalid, or the irq_flags
    parameter must be zero.  At the same time, the irq parameter being
    invalid specifies that the mpu401 code has to work without an interrupt
    allocated by the caller.  This implies that, if there is an interrupt
    and it is allocated by the caller, the irq parameter must be set to
    a valid-looking number which then isn't actually used.
    
    With the removal of IRQF_DISABLED, zero becomes a valid irq_flags value,
    which forces us to handle the parameters differently.
    
    This patch introduces a new flag MPU401_INFO_IRQ_HOOK for when the
    device interrupt is handled by the caller, and makes the allocation of
    the interrupt to depend only on the irq parameter.  As suggested by
    Takashi, the irq_flags parameter was dropped because, when used, it had
    the constant value IRQF_DISABLED.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 008e8e5bfa37..c4733c08b60b 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -317,8 +317,7 @@ static int __devinit snd_gusextreme_probe(struct device *dev, unsigned int n)
 
 	if (es1688->mpu_port >= 0x300) {
 		error = snd_mpu401_uart_new(card, 0, MPU401_HW_ES1688,
-				es1688->mpu_port, 0,
-				mpu_irq[n], IRQF_DISABLED, NULL);
+				es1688->mpu_port, 0, mpu_irq[n], NULL);
 		if (error < 0)
 			goto out;
 	}

commit 396fa8272601c3d488cb8391c3962a7ee552afd0
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Sun May 9 20:35:44 2010 +0200

    ALSA: es1688: allocate snd_es1688 structure as a part of snd_card structure
    
    Allocate the snd_es1688 during the snd_card allocation.
    This allows to remove the card pointer from the snd_es1688 structure.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 65e4b18581a6..008e8e5bfa37 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -95,7 +95,7 @@ static int __devinit snd_gusextreme_match(struct device *dev, unsigned int n)
 }
 
 static int __devinit snd_gusextreme_es1688_create(struct snd_card *card,
-		struct device *dev, unsigned int n, struct snd_es1688 **rchip)
+		struct snd_es1688 *chip, struct device *dev, unsigned int n)
 {
 	static long possible_ports[] = {0x220, 0x240, 0x260};
 	static int possible_irqs[] = {5, 9, 10, 7, -1};
@@ -119,14 +119,14 @@ static int __devinit snd_gusextreme_es1688_create(struct snd_card *card,
 	}
 
 	if (port[n] != SNDRV_AUTO_PORT)
-		return snd_es1688_create(card, port[n], mpu_port[n], irq[n],
-				mpu_irq[n], dma8[n], ES1688_HW_1688, rchip);
+		return snd_es1688_create(card, chip, port[n], mpu_port[n],
+				irq[n], mpu_irq[n], dma8[n], ES1688_HW_1688);
 
 	i = 0;
 	do {
 		port[n] = possible_ports[i];
-		error = snd_es1688_create(card, port[n], mpu_port[n], irq[n],
-				mpu_irq[n], dma8[n], ES1688_HW_1688, rchip);
+		error = snd_es1688_create(card, chip, port[n], mpu_port[n],
+				irq[n], mpu_irq[n], dma8[n], ES1688_HW_1688);
 	} while (error < 0 && ++i < ARRAY_SIZE(possible_ports));
 
 	return error;
@@ -206,9 +206,8 @@ static int __devinit snd_gusextreme_detect(struct snd_gus_card *gus,
 	return 0;
 }
 
-static int __devinit snd_gusextreme_mixer(struct snd_es1688 *chip)
+static int __devinit snd_gusextreme_mixer(struct snd_card *card)
 {
-	struct snd_card *card = chip->card;
 	struct snd_ctl_elem_id id1, id2;
 	int error;
 
@@ -241,17 +240,20 @@ static int __devinit snd_gusextreme_probe(struct device *dev, unsigned int n)
 	struct snd_opl3 *opl3;
 	int error;
 
-	error = snd_card_create(index[n], id[n], THIS_MODULE, 0, &card);
+	error = snd_card_create(index[n], id[n], THIS_MODULE,
+				sizeof(struct snd_es1688), &card);
 	if (error < 0)
 		return error;
 
+	es1688 = card->private_data;
+
 	if (mpu_port[n] == SNDRV_AUTO_PORT)
 		mpu_port[n] = 0;
 
 	if (mpu_irq[n] > 15)
 		mpu_irq[n] = -1;
 
-	error = snd_gusextreme_es1688_create(card, dev, n, &es1688);
+	error = snd_gusextreme_es1688_create(card, es1688, dev, n);
 	if (error < 0)
 		goto out;
 
@@ -280,11 +282,11 @@ static int __devinit snd_gusextreme_probe(struct device *dev, unsigned int n)
 	}
 	gus->codec_flag = 1;
 
-	error = snd_es1688_pcm(es1688, 0, NULL);
+	error = snd_es1688_pcm(card, es1688, 0, NULL);
 	if (error < 0)
 		goto out;
 
-	error = snd_es1688_mixer(es1688);
+	error = snd_es1688_mixer(card, es1688);
 	if (error < 0)
 		goto out;
 
@@ -300,7 +302,7 @@ static int __devinit snd_gusextreme_probe(struct device *dev, unsigned int n)
 	if (error < 0)
 		goto out;
 
-	error = snd_gusextreme_mixer(es1688);
+	error = snd_gusextreme_mixer(card);
 	if (error < 0)
 		goto out;
 

commit 82ced6fd28653ab456c3e5b25e9ef3c1c96cd6e9
Author: Jean Delvare <khali@linux-fr.org>
Date:   Thu Jun 4 10:46:43 2009 +0200

    ALSA: Add missing __devexit_p() markers
    
    3 ISA sound drivers lack their __devexit_p() markers, which would
    cause build failures when the kernel is built without hotplug support.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 180a8dea6bd9..65e4b18581a6 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -348,7 +348,7 @@ static int __devexit snd_gusextreme_remove(struct device *dev, unsigned int n)
 static struct isa_driver snd_gusextreme_driver = {
 	.match		= snd_gusextreme_match,
 	.probe		= snd_gusextreme_probe,
-	.remove		= snd_gusextreme_remove,
+	.remove		= __devexit_p(snd_gusextreme_remove),
 #if 0	/* FIXME */
 	.suspend	= snd_gusextreme_suspend,
 	.resume		= snd_gusextreme_resume,

commit c95eadd2f1afd2ba643e85a8dfc9079a3f03ae47
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:43:35 2008 +0100

    ALSA: Convert to snd_card_create() in sound/isa/*
    
    Convert from snd_card_new() to the new snd_card_create() function.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 7ad4c3b41a84..180a8dea6bd9 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -241,9 +241,9 @@ static int __devinit snd_gusextreme_probe(struct device *dev, unsigned int n)
 	struct snd_opl3 *opl3;
 	int error;
 
-	card = snd_card_new(index[n], id[n], THIS_MODULE, 0);
-	if (!card)
-		return -EINVAL;
+	error = snd_card_create(index[n], id[n], THIS_MODULE, 0, &card);
+	if (error < 0)
+		return error;
 
 	if (mpu_port[n] == SNDRV_AUTO_PORT)
 		mpu_port[n] = 0;

commit 0418ff0c8e48aae4e5e0cbcd3e19a057bea2e55a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 3 08:51:33 2008 +0100

    ALSA: remove direct access of dev->bus_id in sound/isa/*
    
    Removed the direct accesses of dev->bus_id in sound/isa/* by replacement
    with dev_err() or dev_warn() functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index da13185eb0a0..7ad4c3b41a84 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -106,16 +106,14 @@ static int __devinit snd_gusextreme_es1688_create(struct snd_card *card,
 	if (irq[n] == SNDRV_AUTO_IRQ) {
 		irq[n] = snd_legacy_find_free_irq(possible_irqs);
 		if (irq[n] < 0) {
-			snd_printk(KERN_ERR "%s: unable to find a free IRQ "
-				"for ES1688\n", dev->bus_id);
+			dev_err(dev, "unable to find a free IRQ for ES1688\n");
 			return -EBUSY;
 		}
 	}
 	if (dma8[n] == SNDRV_AUTO_DMA) {
 		dma8[n] = snd_legacy_find_free_dma(possible_dmas);
 		if (dma8[n] < 0) {
-			snd_printk(KERN_ERR "%s: unable to find a free DMA "
-				"for ES1688\n", dev->bus_id);
+			dev_err(dev, "unable to find a free DMA for ES1688\n");
 			return -EBUSY;
 		}
 	}
@@ -143,16 +141,14 @@ static int __devinit snd_gusextreme_gus_card_create(struct snd_card *card,
 	if (gf1_irq[n] == SNDRV_AUTO_IRQ) {
 		gf1_irq[n] = snd_legacy_find_free_irq(possible_irqs);
 		if (gf1_irq[n] < 0) {
-			snd_printk(KERN_ERR "%s: unable to find a free IRQ "
-				"for GF1\n", dev->bus_id);
+			dev_err(dev, "unable to find a free IRQ for GF1\n");
 			return -EBUSY;
 		}
 	}
 	if (dma1[n] == SNDRV_AUTO_DMA) {
 		dma1[n] = snd_legacy_find_free_dma(possible_dmas);
 		if (dma1[n] < 0) {
-			snd_printk(KERN_ERR "%s: unable to find a free DMA "
-				"for GF1\n", dev->bus_id);
+			dev_err(dev, "unable to find a free DMA for GF1\n");
 			return -EBUSY;
 		}
 	}
@@ -278,8 +274,8 @@ static int __devinit snd_gusextreme_probe(struct device *dev, unsigned int n)
 
 	error = -ENODEV;
 	if (!gus->ess_flag) {
-		snd_printk(KERN_ERR "%s: GUS Extreme soundcard was not "
-			"detected at 0x%lx\n", dev->bus_id, gus->gf1.port);
+		dev_err(dev, "GUS Extreme soundcard was not "
+			"detected at 0x%lx\n", gus->gf1.port);
 		goto out;
 	}
 	gus->codec_flag = 1;
@@ -310,8 +306,7 @@ static int __devinit snd_gusextreme_probe(struct device *dev, unsigned int n)
 
 	if (snd_opl3_create(card, es1688->port, es1688->port + 2,
 			OPL3_HW_OPL3, 0, &opl3) < 0)
-		printk(KERN_ERR "%s: opl3 not detected at 0x%lx\n",
-			dev->bus_id, es1688->port);
+		dev_warn(dev, "opl3 not detected at 0x%lx\n", es1688->port);
 	else {
 		error = snd_opl3_hwdep_new(opl3, 0, 2, NULL);
 		if (error < 0)

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index fc59536c918e..da13185eb0a0 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -19,7 +19,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/err.h>
 #include <linux/isa.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 0aeaa6cf6cf0..fc59536c918e 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -1,6 +1,6 @@
 /*
  *  Driver for Gravis UltraSound Extreme soundcards
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *
  *
  *   This program is free software; you can redistribute it and/or modify
@@ -41,7 +41,7 @@
 #define DEV_NAME "gusextreme"
 
 MODULE_DESCRIPTION(CRD_NAME);
-MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{Gravis,UltraSound Extreme}}");
 

commit 442f4f36bed8bcadcbda299c615c12fae95eda99
Author: Rene Herman <rene.herman@gmail.com>
Date:   Mon Feb 19 13:07:50 2007 +0100

    [ALSA] gusextreme: set codec_flag
    
    The gusextreme driver neglects to set the gus->codec_flag meaning
    snd_gf1_pcm_new() allocates a second 'PCM Playback Volume' control,
    which makes the driver fail to load.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 74e34e6e16f2..0aeaa6cf6cf0 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -283,6 +283,7 @@ static int __devinit snd_gusextreme_probe(struct device *dev, unsigned int n)
 			"detected at 0x%lx\n", dev->bus_id, gus->gf1.port);
 		goto out;
 	}
+	gus->codec_flag = 1;
 
 	error = snd_es1688_pcm(es1688, 0, NULL);
 	if (error < 0)

commit b44dfe1a4a39dbf55d204486a45aa3263eb12df0
Author: Rene Herman <rene.herman@gmail.com>
Date:   Mon Feb 19 13:07:17 2007 +0100

    [ALSA] isa_bus: gusextreeme
    
    gusextreme: port to isa_bus infrastructure
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 4f55fc3e66c1..74e34e6e16f2 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -22,7 +22,7 @@
 #include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/err.h>
-#include <linux/platform_device.h>
+#include <linux/isa.h>
 #include <linux/delay.h>
 #include <linux/time.h>
 #include <linux/moduleparam.h>
@@ -37,8 +37,11 @@
 #define SNDRV_LEGACY_FIND_FREE_DMA
 #include <sound/initval.h>
 
+#define CRD_NAME "Gravis UltraSound Extreme"
+#define DEV_NAME "gusextreme"
+
+MODULE_DESCRIPTION(CRD_NAME);
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
-MODULE_DESCRIPTION("Gravis UltraSound Extreme");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{Gravis,UltraSound Extreme}}");
 
@@ -59,43 +62,107 @@ static int channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 24};
 static int pcm_channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
 
 module_param_array(index, int, NULL, 0444);
-MODULE_PARM_DESC(index, "Index value for GUS Extreme soundcard.");
+MODULE_PARM_DESC(index, "Index value for " CRD_NAME " soundcard.");
 module_param_array(id, charp, NULL, 0444);
-MODULE_PARM_DESC(id, "ID string for GUS Extreme soundcard.");
+MODULE_PARM_DESC(id, "ID string for " CRD_NAME " soundcard.");
 module_param_array(enable, bool, NULL, 0444);
-MODULE_PARM_DESC(enable, "Enable GUS Extreme soundcard.");
+MODULE_PARM_DESC(enable, "Enable " CRD_NAME " soundcard.");
 module_param_array(port, long, NULL, 0444);
-MODULE_PARM_DESC(port, "Port # for GUS Extreme driver.");
+MODULE_PARM_DESC(port, "Port # for " CRD_NAME " driver.");
 module_param_array(gf1_port, long, NULL, 0444);
-MODULE_PARM_DESC(gf1_port, "GF1 port # for GUS Extreme driver (optional).");
+MODULE_PARM_DESC(gf1_port, "GF1 port # for " CRD_NAME " driver (optional).");
 module_param_array(mpu_port, long, NULL, 0444);
-MODULE_PARM_DESC(mpu_port, "MPU-401 port # for GUS Extreme driver.");
+MODULE_PARM_DESC(mpu_port, "MPU-401 port # for " CRD_NAME " driver.");
 module_param_array(irq, int, NULL, 0444);
-MODULE_PARM_DESC(irq, "IRQ # for GUS Extreme driver.");
+MODULE_PARM_DESC(irq, "IRQ # for " CRD_NAME " driver.");
 module_param_array(mpu_irq, int, NULL, 0444);
-MODULE_PARM_DESC(mpu_irq, "MPU-401 IRQ # for GUS Extreme driver.");
+MODULE_PARM_DESC(mpu_irq, "MPU-401 IRQ # for " CRD_NAME " driver.");
 module_param_array(gf1_irq, int, NULL, 0444);
-MODULE_PARM_DESC(gf1_irq, "GF1 IRQ # for GUS Extreme driver.");
+MODULE_PARM_DESC(gf1_irq, "GF1 IRQ # for " CRD_NAME " driver.");
 module_param_array(dma8, int, NULL, 0444);
-MODULE_PARM_DESC(dma8, "8-bit DMA # for GUS Extreme driver.");
+MODULE_PARM_DESC(dma8, "8-bit DMA # for " CRD_NAME " driver.");
 module_param_array(dma1, int, NULL, 0444);
-MODULE_PARM_DESC(dma1, "GF1 DMA # for GUS Extreme driver.");
+MODULE_PARM_DESC(dma1, "GF1 DMA # for " CRD_NAME " driver.");
 module_param_array(joystick_dac, int, NULL, 0444);
-MODULE_PARM_DESC(joystick_dac, "Joystick DAC level 0.59V-4.52V or 0.389V-2.98V for GUS Extreme driver.");
+MODULE_PARM_DESC(joystick_dac, "Joystick DAC level 0.59V-4.52V or 0.389V-2.98V for " CRD_NAME " driver.");
 module_param_array(channels, int, NULL, 0444);
-MODULE_PARM_DESC(channels, "GF1 channels for GUS Extreme driver.");
+MODULE_PARM_DESC(channels, "GF1 channels for " CRD_NAME " driver.");
 module_param_array(pcm_channels, int, NULL, 0444);
-MODULE_PARM_DESC(pcm_channels, "Reserved PCM channels for GUS Extreme driver.");
+MODULE_PARM_DESC(pcm_channels, "Reserved PCM channels for " CRD_NAME " driver.");
+
+static int __devinit snd_gusextreme_match(struct device *dev, unsigned int n)
+{
+	return enable[n];
+}
+
+static int __devinit snd_gusextreme_es1688_create(struct snd_card *card,
+		struct device *dev, unsigned int n, struct snd_es1688 **rchip)
+{
+	static long possible_ports[] = {0x220, 0x240, 0x260};
+	static int possible_irqs[] = {5, 9, 10, 7, -1};
+	static int possible_dmas[] = {1, 3, 0, -1};
+
+	int i, error;
+
+	if (irq[n] == SNDRV_AUTO_IRQ) {
+		irq[n] = snd_legacy_find_free_irq(possible_irqs);
+		if (irq[n] < 0) {
+			snd_printk(KERN_ERR "%s: unable to find a free IRQ "
+				"for ES1688\n", dev->bus_id);
+			return -EBUSY;
+		}
+	}
+	if (dma8[n] == SNDRV_AUTO_DMA) {
+		dma8[n] = snd_legacy_find_free_dma(possible_dmas);
+		if (dma8[n] < 0) {
+			snd_printk(KERN_ERR "%s: unable to find a free DMA "
+				"for ES1688\n", dev->bus_id);
+			return -EBUSY;
+		}
+	}
 
-static struct platform_device *devices[SNDRV_CARDS];
+	if (port[n] != SNDRV_AUTO_PORT)
+		return snd_es1688_create(card, port[n], mpu_port[n], irq[n],
+				mpu_irq[n], dma8[n], ES1688_HW_1688, rchip);
 
+	i = 0;
+	do {
+		port[n] = possible_ports[i];
+		error = snd_es1688_create(card, port[n], mpu_port[n], irq[n],
+				mpu_irq[n], dma8[n], ES1688_HW_1688, rchip);
+	} while (error < 0 && ++i < ARRAY_SIZE(possible_ports));
 
-#define PFX	"gusextreme: "
+	return error;
+}
 
-static int __devinit snd_gusextreme_detect(int dev,
-					struct snd_card *card,
-					struct snd_gus_card * gus,
-					struct snd_es1688 *es1688)
+static int __devinit snd_gusextreme_gus_card_create(struct snd_card *card,
+		struct device *dev, unsigned int n, struct snd_gus_card **rgus)
+{
+	static int possible_irqs[] = {11, 12, 15, 9, 5, 7, 3, -1};
+	static int possible_dmas[] = {5, 6, 7, 3, 1, -1};
+
+	if (gf1_irq[n] == SNDRV_AUTO_IRQ) {
+		gf1_irq[n] = snd_legacy_find_free_irq(possible_irqs);
+		if (gf1_irq[n] < 0) {
+			snd_printk(KERN_ERR "%s: unable to find a free IRQ "
+				"for GF1\n", dev->bus_id);
+			return -EBUSY;
+		}
+	}
+	if (dma1[n] == SNDRV_AUTO_DMA) {
+		dma1[n] = snd_legacy_find_free_dma(possible_dmas);
+		if (dma1[n] < 0) {
+			snd_printk(KERN_ERR "%s: unable to find a free DMA "
+				"for GF1\n", dev->bus_id);
+			return -EBUSY;
+		}
+	}
+	return snd_gus_create(card, gf1_port[n], gf1_irq[n], dma1[n], -1,
+			0, channels[n], pcm_channels[n], 0, rgus);
+}
+
+static int __devinit snd_gusextreme_detect(struct snd_gus_card *gus,
+	struct snd_es1688 *es1688)
 {
 	unsigned long flags;
 	unsigned char d;
@@ -117,12 +184,13 @@ static int __devinit snd_gusextreme_detect(int dev,
 	spin_lock_irqsave(&es1688->mixer_lock, flags);
 	snd_es1688_mixer_write(es1688, 0x40, 0x0b);	/* don't change!!! */
 	spin_unlock_irqrestore(&es1688->mixer_lock, flags);
+
 	spin_lock_irqsave(&es1688->reg_lock, flags);
-	outb(gf1_port[dev] & 0x040 ? 2 : 0, ES1688P(es1688, INIT1));
+	outb(gus->gf1.port & 0x040 ? 2 : 0, ES1688P(es1688, INIT1));
 	outb(0, 0x201);
-	outb(gf1_port[dev] & 0x020 ? 2 : 0, ES1688P(es1688, INIT1));
+	outb(gus->gf1.port & 0x020 ? 2 : 0, ES1688P(es1688, INIT1));
 	outb(0, 0x201);
-	outb(gf1_port[dev] & 0x010 ? 3 : 1, ES1688P(es1688, INIT1));
+	outb(gus->gf1.port & 0x010 ? 3 : 1, ES1688P(es1688, INIT1));
 	spin_unlock_irqrestore(&es1688->reg_lock, flags);
 
 	udelay(100);
@@ -139,253 +207,171 @@ static int __devinit snd_gusextreme_detect(int dev,
 		snd_printdd("[0x%lx] check 2 failed - 0x%x\n", gus->gf1.port, d);
 		return -EIO;
 	}
-	return 0;
-}
 
-static void __devinit snd_gusextreme_init(int dev, struct snd_gus_card * gus)
-{
-	gus->joystick_dac = joystick_dac[dev];
+	return 0;
 }
 
 static int __devinit snd_gusextreme_mixer(struct snd_es1688 *chip)
 {
 	struct snd_card *card = chip->card;
 	struct snd_ctl_elem_id id1, id2;
-	int err;
+	int error;
 
 	memset(&id1, 0, sizeof(id1));
 	memset(&id2, 0, sizeof(id2));
 	id1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+
 	/* reassign AUX to SYNTHESIZER */
 	strcpy(id1.name, "Aux Playback Volume");
 	strcpy(id2.name, "Synth Playback Volume");
-	if ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0)
-		return err;
+	error = snd_ctl_rename_id(card, &id1, &id2);
+	if (error < 0)
+		return error;
+
 	/* reassign Master Playback Switch to Synth Playback Switch */
 	strcpy(id1.name, "Master Playback Switch");
 	strcpy(id2.name, "Synth Playback Switch");
-	if ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0)
-		return err;
+	error = snd_ctl_rename_id(card, &id1, &id2);
+	if (error < 0)
+		return error;
+
 	return 0;
 }
 
-static int __devinit snd_gusextreme_probe(struct platform_device *pdev)
+static int __devinit snd_gusextreme_probe(struct device *dev, unsigned int n)
 {
-	int dev = pdev->id;
-	static int possible_ess_irqs[] = {5, 9, 10, 7, -1};
-	static int possible_ess_dmas[] = {1, 3, 0, -1};
-	static int possible_gf1_irqs[] = {5, 11, 12, 9, 7, 15, 3, -1};
-	static int possible_gf1_dmas[] = {5, 6, 7, 1, 3, -1};
-	int xgf1_irq, xgf1_dma, xess_irq, xmpu_irq, xess_dma;
 	struct snd_card *card;
 	struct snd_gus_card *gus;
 	struct snd_es1688 *es1688;
 	struct snd_opl3 *opl3;
-	int err;
+	int error;
 
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
-	if (card == NULL)
-		return -ENOMEM;
+	card = snd_card_new(index[n], id[n], THIS_MODULE, 0);
+	if (!card)
+		return -EINVAL;
 
-	xgf1_irq = gf1_irq[dev];
-	if (xgf1_irq == SNDRV_AUTO_IRQ) {
-		if ((xgf1_irq = snd_legacy_find_free_irq(possible_gf1_irqs)) < 0) {
-			snd_printk(KERN_ERR PFX "unable to find a free IRQ for GF1\n");
-			err = -EBUSY;
-			goto out;
-		}
-	}
-	xess_irq = irq[dev];
-	if (xess_irq == SNDRV_AUTO_IRQ) {
-		if ((xess_irq = snd_legacy_find_free_irq(possible_ess_irqs)) < 0) {
-			snd_printk(KERN_ERR PFX "unable to find a free IRQ for ES1688\n");
-			err = -EBUSY;
-			goto out;
-		}
-	}
-	if (mpu_port[dev] == SNDRV_AUTO_PORT)
-		mpu_port[dev] = 0;
-	xmpu_irq = mpu_irq[dev];
-	if (xmpu_irq > 15)
-		xmpu_irq = -1;
-	xgf1_dma = dma1[dev];
-	if (xgf1_dma == SNDRV_AUTO_DMA) {
-		if ((xgf1_dma = snd_legacy_find_free_dma(possible_gf1_dmas)) < 0) {
-			snd_printk(KERN_ERR PFX "unable to find a free DMA for GF1\n");
-			err = -EBUSY;
-			goto out;
-		}
-	}
-	xess_dma = dma8[dev];
-	if (xess_dma == SNDRV_AUTO_DMA) {
-		if ((xess_dma = snd_legacy_find_free_dma(possible_ess_dmas)) < 0) {
-			snd_printk(KERN_ERR PFX "unable to find a free DMA for ES1688\n");
-			err = -EBUSY;
-			goto out;
-		}
-	}
+	if (mpu_port[n] == SNDRV_AUTO_PORT)
+		mpu_port[n] = 0;
 
-	if (port[dev] != SNDRV_AUTO_PORT) {
-		err = snd_es1688_create(card, port[dev], mpu_port[dev],
-					xess_irq, xmpu_irq, xess_dma,
-					ES1688_HW_1688, &es1688);
-	} else {
-		/* auto-probe legacy ports */
-		static unsigned long possible_ports[] = {0x220, 0x240, 0x260};
-		int i;
-		for (i = 0; i < ARRAY_SIZE(possible_ports); i++) {
-			err = snd_es1688_create(card,
-						possible_ports[i],
-						mpu_port[dev],
-						xess_irq, xmpu_irq, xess_dma,
-						ES1688_HW_1688, &es1688);
-			if (err >= 0) {
-				port[dev] = possible_ports[i];
-				break;
-			}
-		}
-	}
-	if (err < 0)
+	if (mpu_irq[n] > 15)
+		mpu_irq[n] = -1;
+
+	error = snd_gusextreme_es1688_create(card, dev, n, &es1688);
+	if (error < 0)
 		goto out;
 
-	if (gf1_port[dev] < 0)
-		gf1_port[dev] = port[dev] + 0x20;
-	if ((err = snd_gus_create(card,
-				  gf1_port[dev],
-				  xgf1_irq,
-				  xgf1_dma,
-				  -1,
-				  0, channels[dev],
-				  pcm_channels[dev], 0,
-				  &gus)) < 0)
+	if (gf1_port[n] < 0)
+		gf1_port[n] = es1688->port + 0x20;
+
+	error = snd_gusextreme_gus_card_create(card, dev, n, &gus);
+	if (error < 0)
 		goto out;
 
-	if ((err = snd_gusextreme_detect(dev, card, gus, es1688)) < 0)
+	error = snd_gusextreme_detect(gus, es1688);
+	if (error < 0)
 		goto out;
 
-	snd_gusextreme_init(dev, gus);
-	if ((err = snd_gus_initialize(gus)) < 0)
+	gus->joystick_dac = joystick_dac[n];
+
+	error = snd_gus_initialize(gus);
+	if (error < 0)
 		goto out;
 
+	error = -ENODEV;
 	if (!gus->ess_flag) {
-		snd_printk(KERN_ERR PFX "GUS Extreme soundcard was not detected at 0x%lx\n", gus->gf1.port);
-		err = -ENODEV;
+		snd_printk(KERN_ERR "%s: GUS Extreme soundcard was not "
+			"detected at 0x%lx\n", dev->bus_id, gus->gf1.port);
 		goto out;
 	}
-	if ((err = snd_es1688_pcm(es1688, 0, NULL)) < 0)
+
+	error = snd_es1688_pcm(es1688, 0, NULL);
+	if (error < 0)
 		goto out;
 
-	if ((err = snd_es1688_mixer(es1688)) < 0)
+	error = snd_es1688_mixer(es1688);
+	if (error < 0)
 		goto out;
 
 	snd_component_add(card, "ES1688");
-	if (pcm_channels[dev] > 0) {
-		if ((err = snd_gf1_pcm_new(gus, 1, 1, NULL)) < 0)
+
+	if (pcm_channels[n] > 0) {
+		error = snd_gf1_pcm_new(gus, 1, 1, NULL);
+		if (error < 0)
 			goto out;
 	}
-	if ((err = snd_gf1_new_mixer(gus)) < 0)
+
+	error = snd_gf1_new_mixer(gus);
+	if (error < 0)
 		goto out;
 
-	if ((err = snd_gusextreme_mixer(es1688)) < 0)
+	error = snd_gusextreme_mixer(es1688);
+	if (error < 0)
 		goto out;
 
 	if (snd_opl3_create(card, es1688->port, es1688->port + 2,
-			    OPL3_HW_OPL3, 0, &opl3) < 0) {
-		printk(KERN_ERR PFX "gusextreme: opl3 not detected at 0x%lx\n", es1688->port);
-	} else {
-		if ((err = snd_opl3_hwdep_new(opl3, 0, 2, NULL)) < 0)
+			OPL3_HW_OPL3, 0, &opl3) < 0)
+		printk(KERN_ERR "%s: opl3 not detected at 0x%lx\n",
+			dev->bus_id, es1688->port);
+	else {
+		error = snd_opl3_hwdep_new(opl3, 0, 2, NULL);
+		if (error < 0)
 			goto out;
 	}
 
-	if (es1688->mpu_port >= 0x300 &&
-	    (err = snd_mpu401_uart_new(card, 0, MPU401_HW_ES1688,
-					       es1688->mpu_port, 0,
-					       xmpu_irq,
-					       IRQF_DISABLED,
-					       NULL)) < 0)
-		goto out;
+	if (es1688->mpu_port >= 0x300) {
+		error = snd_mpu401_uart_new(card, 0, MPU401_HW_ES1688,
+				es1688->mpu_port, 0,
+				mpu_irq[n], IRQF_DISABLED, NULL);
+		if (error < 0)
+			goto out;
+	}
 
-	sprintf(card->longname, "Gravis UltraSound Extreme at 0x%lx, irq %i&%i, dma %i&%i",
-		es1688->port, xgf1_irq, xess_irq, xgf1_dma, xess_dma);
+	sprintf(card->longname, "Gravis UltraSound Extreme at 0x%lx, "
+		"irq %i&%i, dma %i&%i", es1688->port,
+		gus->gf1.irq, es1688->irq, gus->gf1.dma1, es1688->dma8);
 
-	snd_card_set_dev(card, &pdev->dev);
+	snd_card_set_dev(card, dev);
 
-	if ((err = snd_card_register(card)) < 0)
+	error = snd_card_register(card);
+	if (error < 0)
 		goto out;
 
-	platform_set_drvdata(pdev, card);
+	dev_set_drvdata(dev, card);
 	return 0;
 
-      out:
-	snd_card_free(card);
-	return err;
+out:	snd_card_free(card);
+	return error;
 }
 
-static int __devexit snd_gusextreme_remove(struct platform_device *devptr)
+static int __devexit snd_gusextreme_remove(struct device *dev, unsigned int n)
 {
-	snd_card_free(platform_get_drvdata(devptr));
-	platform_set_drvdata(devptr, NULL);
+	snd_card_free(dev_get_drvdata(dev));
+	dev_set_drvdata(dev, NULL);
 	return 0;
 }
 
-#define GUSEXTREME_DRIVER	"snd_gusextreme"
-
-static struct platform_driver snd_gusextreme_driver = {
+static struct isa_driver snd_gusextreme_driver = {
+	.match		= snd_gusextreme_match,
 	.probe		= snd_gusextreme_probe,
-	.remove		= __devexit_p(snd_gusextreme_remove),
-	/* FIXME: suspend/resume */
+	.remove		= snd_gusextreme_remove,
+#if 0	/* FIXME */
+	.suspend	= snd_gusextreme_suspend,
+	.resume		= snd_gusextreme_resume,
+#endif
 	.driver		= {
-		.name	= GUSEXTREME_DRIVER
-	},
+		.name	= DEV_NAME
+	}
 };
 
-static void __init_or_module snd_gusextreme_unregister_all(void)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(devices); ++i)
-		platform_device_unregister(devices[i]);
-	platform_driver_unregister(&snd_gusextreme_driver);
-}
-
 static int __init alsa_card_gusextreme_init(void)
 {
-	int i, cards, err;
-
-	err = platform_driver_register(&snd_gusextreme_driver);
-	if (err < 0)
-		return err;
-
-	cards = 0;
-	for (i = 0; i < SNDRV_CARDS; i++) {
-		struct platform_device *device;
-		if (! enable[i])
-			continue;
-		device = platform_device_register_simple(GUSEXTREME_DRIVER,
-							 i, NULL, 0);
-		if (IS_ERR(device))
-			continue;
-		if (!platform_get_drvdata(device)) {
-			platform_device_unregister(device);
-			continue;
-		}
-		devices[i] = device;
-		cards++;
-	}
-	if (!cards) {
-#ifdef MODULE
-		printk(KERN_ERR "GUS Extreme soundcard not found or device busy\n");
-#endif
-		snd_gusextreme_unregister_all();
-		return -ENODEV;
-	}
-	return 0;
+	return isa_register_driver(&snd_gusextreme_driver, SNDRV_CARDS);
 }
 
 static void __exit alsa_card_gusextreme_exit(void)
 {
-	snd_gusextreme_unregister_all();
+	isa_unregister_driver(&snd_gusextreme_driver);
 }
 
-module_init(alsa_card_gusextreme_init)
-module_exit(alsa_card_gusextreme_exit)
+module_init(alsa_card_gusextreme_init);
+module_exit(alsa_card_gusextreme_exit);

commit 788c6043335590e0a483fdc18f85b1405a157bf9
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Tue Feb 13 13:11:11 2007 +0100

    [ALSA] Fix __devinit and __devexit issues with sound drivers
    
    Fix __devinit and __devexit issues with sound drivers.
    Resolves MODPOST warnings similar to:
    WARNING: sound/drivers/snd-dummy.o - Section mismatch: reference to .init.text:snd_dummy_probe from .data.rel.local between 'snd_dummy_driver' (at offset 0x0) and 'snd_dummy_controls'
    WARNING: sound/drivers/snd-mtpav.o - Section mismatch: reference to .init.text:snd_mtpav_probe from .data.rel.local between 'snd_mtpav_driver' (at offset 0x0) and 'snd_mtpav_input'
    WARNING: sound/drivers/snd-virmidi.o - Section mismatch: reference to .init.text:snd_virmidi_probe from .data.rel.local after 'snd_virmidi_driver' (at offset 0x0)
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 532c56e35ca4..4f55fc3e66c1 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -92,7 +92,7 @@ static struct platform_device *devices[SNDRV_CARDS];
 
 #define PFX	"gusextreme: "
 
-static int __init snd_gusextreme_detect(int dev,
+static int __devinit snd_gusextreme_detect(int dev,
 					struct snd_card *card,
 					struct snd_gus_card * gus,
 					struct snd_es1688 *es1688)
@@ -142,12 +142,12 @@ static int __init snd_gusextreme_detect(int dev,
 	return 0;
 }
 
-static void __init snd_gusextreme_init(int dev, struct snd_gus_card * gus)
+static void __devinit snd_gusextreme_init(int dev, struct snd_gus_card * gus)
 {
 	gus->joystick_dac = joystick_dac[dev];
 }
 
-static int __init snd_gusextreme_mixer(struct snd_es1688 *chip)
+static int __devinit snd_gusextreme_mixer(struct snd_es1688 *chip)
 {
 	struct snd_card *card = chip->card;
 	struct snd_ctl_elem_id id1, id2;
@@ -169,7 +169,7 @@ static int __init snd_gusextreme_mixer(struct snd_es1688 *chip)
 	return 0;
 }
 
-static int __init snd_gusextreme_probe(struct platform_device *pdev)
+static int __devinit snd_gusextreme_probe(struct platform_device *pdev)
 {
 	int dev = pdev->id;
 	static int possible_ess_irqs[] = {5, 9, 10, 7, -1};
@@ -321,7 +321,7 @@ static int __init snd_gusextreme_probe(struct platform_device *pdev)
 	return err;
 }
 
-static int snd_gusextreme_remove(struct platform_device *devptr)
+static int __devexit snd_gusextreme_remove(struct platform_device *devptr)
 {
 	snd_card_free(platform_get_drvdata(devptr));
 	platform_set_drvdata(devptr, NULL);
@@ -332,7 +332,7 @@ static int snd_gusextreme_remove(struct platform_device *devptr)
 
 static struct platform_driver snd_gusextreme_driver = {
 	.probe		= snd_gusextreme_probe,
-	.remove		= snd_gusextreme_remove,
+	.remove		= __devexit_p(snd_gusextreme_remove),
 	/* FIXME: suspend/resume */
 	.driver		= {
 		.name	= GUSEXTREME_DRIVER

commit d35367e1cbe4cb69f6ced0bf347c0c478752d95d
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Jul 11 12:09:20 2006 +0200

    [ALSA] make sound/isa/gus/gusextreme.c:devices static
    
    'devices' is not a good name for a global variable.
    Thankfully, it can become static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 22cdddbfd824..532c56e35ca4 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -87,7 +87,7 @@ MODULE_PARM_DESC(channels, "GF1 channels for GUS Extreme driver.");
 module_param_array(pcm_channels, int, NULL, 0444);
 MODULE_PARM_DESC(pcm_channels, "Reserved PCM channels for GUS Extreme driver.");
 
-struct platform_device *devices[SNDRV_CARDS];
+static struct platform_device *devices[SNDRV_CARDS];
 
 
 #define PFX	"gusextreme: "

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 05852fcc613b..22cdddbfd824 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -301,7 +301,7 @@ static int __init snd_gusextreme_probe(struct platform_device *pdev)
 	    (err = snd_mpu401_uart_new(card, 0, MPU401_HW_ES1688,
 					       es1688->mpu_port, 0,
 					       xmpu_irq,
-					       SA_INTERRUPT,
+					       IRQF_DISABLED,
 					       NULL)) < 0)
 		goto out;
 

commit dcccdd938ef0c5d96145957217b814b14bd46cdc
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Tue Apr 11 14:09:37 2006 +0200

    [ALSA] unregister platform device again if probe was unsuccessful
    
    Unregister the platform device again if the probe was unsuccessful.
    
    This restores the behaviour of not loading the driver on probe() failure.
    
    Signed-off-by: Rene Herman <rene.herman@keyaccess.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index aa312dee99c8..05852fcc613b 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -365,6 +365,10 @@ static int __init alsa_card_gusextreme_init(void)
 							 i, NULL, 0);
 		if (IS_ERR(device))
 			continue;
+		if (!platform_get_drvdata(device)) {
+			platform_device_unregister(device);
+			continue;
+		}
 		devices[i] = device;
 		cards++;
 	}

commit d0ac642d76c79c5cc673c4cdfe43e926379784e1
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Tue Apr 11 14:08:33 2006 +0200

    [ALSA] continue on IS_ERR from platform device registration
    
    Continue with the next one on error from device registration.
    
    This would seem the correct thing to do, even if it's not the probe()
    error that we're getting.
    
    Signed-off-by: Rene Herman <rene.herman@keyaccess.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 31dc20501d0c..aa312dee99c8 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -363,10 +363,8 @@ static int __init alsa_card_gusextreme_init(void)
 			continue;
 		device = platform_device_register_simple(GUSEXTREME_DRIVER,
 							 i, NULL, 0);
-		if (IS_ERR(device)) {
-			err = PTR_ERR(device);
-			goto errout;
-		}
+		if (IS_ERR(device))
+			continue;
 		devices[i] = device;
 		cards++;
 	}
@@ -374,14 +372,10 @@ static int __init alsa_card_gusextreme_init(void)
 #ifdef MODULE
 		printk(KERN_ERR "GUS Extreme soundcard not found or device busy\n");
 #endif
-		err = -ENODEV;
-		goto errout;
+		snd_gusextreme_unregister_all();
+		return -ENODEV;
 	}
 	return 0;
-
- errout:
-	snd_gusextreme_unregister_all();
-	return err;
 }
 
 static void __exit alsa_card_gusextreme_exit(void)

commit 8278ca8feb2748cf02d756ac6c5b9ab2e047c84a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 20 11:57:34 2006 +0100

    [ALSA] Fix check of enable module option
    
    Fix the check of enable module option in probe of platform_device drivers.
    It shouldn't break the loop but just ignore if enable[i] is false.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 239f16e6b9ee..31dc20501d0c 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -357,8 +357,10 @@ static int __init alsa_card_gusextreme_init(void)
 		return err;
 
 	cards = 0;
-	for (i = 0; i < SNDRV_CARDS && enable[i]; i++) {
+	for (i = 0; i < SNDRV_CARDS; i++) {
 		struct platform_device *device;
+		if (! enable[i])
+			continue;
 		device = platform_device_register_simple(GUSEXTREME_DRIVER,
 							 i, NULL, 0);
 		if (IS_ERR(device)) {

commit f7a9275d949cb0bf1f259a1546e52a0bf518151c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Dec 7 09:13:42 2005 +0100

    [ALSA] unregister platform devices
    
    Call platform_device_unregister() for all platform devices that we've
    registered.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 6fad9734a853..239f16e6b9ee 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -87,6 +87,8 @@ MODULE_PARM_DESC(channels, "GF1 channels for GUS Extreme driver.");
 module_param_array(pcm_channels, int, NULL, 0444);
 MODULE_PARM_DESC(pcm_channels, "Reserved PCM channels for GUS Extreme driver.");
 
+struct platform_device *devices[SNDRV_CARDS];
+
 
 #define PFX	"gusextreme: "
 
@@ -337,6 +339,15 @@ static struct platform_driver snd_gusextreme_driver = {
 	},
 };
 
+static void __init_or_module snd_gusextreme_unregister_all(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(devices); ++i)
+		platform_device_unregister(devices[i]);
+	platform_driver_unregister(&snd_gusextreme_driver);
+}
+
 static int __init alsa_card_gusextreme_init(void)
 {
 	int i, cards, err;
@@ -354,6 +365,7 @@ static int __init alsa_card_gusextreme_init(void)
 			err = PTR_ERR(device);
 			goto errout;
 		}
+		devices[i] = device;
 		cards++;
 	}
 	if (!cards) {
@@ -366,13 +378,13 @@ static int __init alsa_card_gusextreme_init(void)
 	return 0;
 
  errout:
-	platform_driver_unregister(&snd_gusextreme_driver);
+	snd_gusextreme_unregister_all();
 	return err;
 }
 
 static void __exit alsa_card_gusextreme_exit(void)
 {
-	platform_driver_unregister(&snd_gusextreme_driver);
+	snd_gusextreme_unregister_all();
 }
 
 module_init(alsa_card_gusextreme_init)

commit 654aa661779703d3b22ba04a83ddeb1a0dd7a09a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 17:13:43 2005 +0100

    [ALSA] gus - Use platform_device
    
    Rewrite the probe/remove with platform_device.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index 9be59d501333..6fad9734a853 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -20,11 +20,13 @@
  */
 
 #include <sound/driver.h>
-#include <asm/dma.h>
 #include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <linux/time.h>
 #include <linux/moduleparam.h>
+#include <asm/dma.h>
 #include <sound/core.h>
 #include <sound/gus.h>
 #include <sound/es1688.h>
@@ -85,7 +87,6 @@ MODULE_PARM_DESC(channels, "GF1 channels for GUS Extreme driver.");
 module_param_array(pcm_channels, int, NULL, 0444);
 MODULE_PARM_DESC(pcm_channels, "Reserved PCM channels for GUS Extreme driver.");
 
-static struct snd_card *snd_gusextreme_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
 
 #define PFX	"gusextreme: "
 
@@ -166,15 +167,15 @@ static int __init snd_gusextreme_mixer(struct snd_es1688 *chip)
 	return 0;
 }
 
-static int __init snd_gusextreme_probe(int dev)
+static int __init snd_gusextreme_probe(struct platform_device *pdev)
 {
+	int dev = pdev->id;
 	static int possible_ess_irqs[] = {5, 9, 10, 7, -1};
 	static int possible_ess_dmas[] = {1, 3, 0, -1};
 	static int possible_gf1_irqs[] = {5, 11, 12, 9, 7, 15, 3, -1};
 	static int possible_gf1_dmas[] = {5, 6, 7, 1, 3, -1};
 	int xgf1_irq, xgf1_dma, xess_irq, xmpu_irq, xess_dma;
 	struct snd_card *card;
-	struct snd_gusextreme *acard;
 	struct snd_gus_card *gus;
 	struct snd_es1688 *es1688;
 	struct snd_opl3 *opl3;
@@ -183,7 +184,6 @@ static int __init snd_gusextreme_probe(int dev)
 	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
 	if (card == NULL)
 		return -ENOMEM;
-	acard = (struct snd_gusextreme *)card->private_data;
 
 	xgf1_irq = gf1_irq[dev];
 	if (xgf1_irq == SNDRV_AUTO_IRQ) {
@@ -223,10 +223,29 @@ static int __init snd_gusextreme_probe(int dev)
 		}
 	}
 
-	if ((err = snd_es1688_create(card, port[dev], mpu_port[dev],
-				     xess_irq, xmpu_irq, xess_dma,
-				     ES1688_HW_1688, &es1688)) < 0)
+	if (port[dev] != SNDRV_AUTO_PORT) {
+		err = snd_es1688_create(card, port[dev], mpu_port[dev],
+					xess_irq, xmpu_irq, xess_dma,
+					ES1688_HW_1688, &es1688);
+	} else {
+		/* auto-probe legacy ports */
+		static unsigned long possible_ports[] = {0x220, 0x240, 0x260};
+		int i;
+		for (i = 0; i < ARRAY_SIZE(possible_ports); i++) {
+			err = snd_es1688_create(card,
+						possible_ports[i],
+						mpu_port[dev],
+						xess_irq, xmpu_irq, xess_dma,
+						ES1688_HW_1688, &es1688);
+			if (err >= 0) {
+				port[dev] = possible_ports[i];
+				break;
+			}
+		}
+	}
+	if (err < 0)
 		goto out;
+
 	if (gf1_port[dev] < 0)
 		gf1_port[dev] = port[dev] + 0x20;
 	if ((err = snd_gus_create(card,
@@ -287,13 +306,12 @@ static int __init snd_gusextreme_probe(int dev)
 	sprintf(card->longname, "Gravis UltraSound Extreme at 0x%lx, irq %i&%i, dma %i&%i",
 		es1688->port, xgf1_irq, xess_irq, xgf1_dma, xess_dma);
 
-	if ((err = snd_card_set_generic_dev(card)) < 0)
-		goto out;
+	snd_card_set_dev(card, &pdev->dev);
 
 	if ((err = snd_card_register(card)) < 0)
 		goto out;
 
-	snd_gusextreme_cards[dev] = card;
+	platform_set_drvdata(pdev, card);
 	return 0;
 
       out:
@@ -301,60 +319,60 @@ static int __init snd_gusextreme_probe(int dev)
 	return err;
 }
 
-static int __init snd_gusextreme_legacy_auto_probe(unsigned long xport)
+static int snd_gusextreme_remove(struct platform_device *devptr)
 {
-        static int dev;
-        int res;
-
-        for ( ; dev < SNDRV_CARDS; dev++) {
-                if (!enable[dev] || port[dev] != SNDRV_AUTO_PORT)
-                        continue;
-                port[dev] = xport;
-                res = snd_gusextreme_probe(dev);
-                if (res < 0)
-                        port[dev] = SNDRV_AUTO_PORT;
-                return res;
-        }
-        return -ENODEV;
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+	return 0;
 }
 
+#define GUSEXTREME_DRIVER	"snd_gusextreme"
+
+static struct platform_driver snd_gusextreme_driver = {
+	.probe		= snd_gusextreme_probe,
+	.remove		= snd_gusextreme_remove,
+	/* FIXME: suspend/resume */
+	.driver		= {
+		.name	= GUSEXTREME_DRIVER
+	},
+};
+
 static int __init alsa_card_gusextreme_init(void)
 {
-	static unsigned long possible_ports[] = {0x220, 0x240, 0x260, -1};
-	int dev, cards, i;
-
-	for (dev = cards = 0; dev < SNDRV_CARDS && enable[dev] > 0; dev++) {
-		if (port[dev] == SNDRV_AUTO_PORT)
-			continue;
-		if (snd_gusextreme_probe(dev) >= 0)
-			cards++;
-	}
-	i = snd_legacy_auto_probe(possible_ports, snd_gusextreme_legacy_auto_probe);
-	if (i > 0)
-		cards += i;
+	int i, cards, err;
+
+	err = platform_driver_register(&snd_gusextreme_driver);
+	if (err < 0)
+		return err;
 
+	cards = 0;
+	for (i = 0; i < SNDRV_CARDS && enable[i]; i++) {
+		struct platform_device *device;
+		device = platform_device_register_simple(GUSEXTREME_DRIVER,
+							 i, NULL, 0);
+		if (IS_ERR(device)) {
+			err = PTR_ERR(device);
+			goto errout;
+		}
+		cards++;
+	}
 	if (!cards) {
 #ifdef MODULE
 		printk(KERN_ERR "GUS Extreme soundcard not found or device busy\n");
 #endif
-		return -ENODEV;
+		err = -ENODEV;
+		goto errout;
 	}
 	return 0;
+
+ errout:
+	platform_driver_unregister(&snd_gusextreme_driver);
+	return err;
 }
 
 static void __exit alsa_card_gusextreme_exit(void)
 {
-	int idx;
-	struct snd_card *card;
-	struct snd_gusextreme *acard;
-
-	for (idx = 0; idx < SNDRV_CARDS; idx++) {
-		card = snd_gusextreme_cards[idx];
-		if (card == NULL)
-			continue;
-		acard = (struct snd_gusextreme *)card->private_data;
-		snd_card_free(snd_gusextreme_cards[idx]);
-	}
+	platform_driver_unregister(&snd_gusextreme_driver);
 }
 
 module_init(alsa_card_gusextreme_init)

commit 5e2da20648e39a0e3cb33861499b686a6fe38112
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:36:44 2005 +0100

    [ALSA] Remove xxx_t typedefs: ISA GUS
    
    Remove xxx_t typedefs from the ISA GUS drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index d2e7cb1df537..9be59d501333 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -85,14 +85,14 @@ MODULE_PARM_DESC(channels, "GF1 channels for GUS Extreme driver.");
 module_param_array(pcm_channels, int, NULL, 0444);
 MODULE_PARM_DESC(pcm_channels, "Reserved PCM channels for GUS Extreme driver.");
 
-static snd_card_t *snd_gusextreme_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
+static struct snd_card *snd_gusextreme_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
 
 #define PFX	"gusextreme: "
 
 static int __init snd_gusextreme_detect(int dev,
-					snd_card_t * card,
-					snd_gus_card_t * gus,
-					es1688_t *es1688)
+					struct snd_card *card,
+					struct snd_gus_card * gus,
+					struct snd_es1688 *es1688)
 {
 	unsigned long flags;
 	unsigned char d;
@@ -139,15 +139,15 @@ static int __init snd_gusextreme_detect(int dev,
 	return 0;
 }
 
-static void __init snd_gusextreme_init(int dev, snd_gus_card_t * gus)
+static void __init snd_gusextreme_init(int dev, struct snd_gus_card * gus)
 {
 	gus->joystick_dac = joystick_dac[dev];
 }
 
-static int __init snd_gusextreme_mixer(es1688_t *chip)
+static int __init snd_gusextreme_mixer(struct snd_es1688 *chip)
 {
-	snd_card_t *card = chip->card;
-	snd_ctl_elem_id_t id1, id2;
+	struct snd_card *card = chip->card;
+	struct snd_ctl_elem_id id1, id2;
 	int err;
 
 	memset(&id1, 0, sizeof(id1));
@@ -173,11 +173,11 @@ static int __init snd_gusextreme_probe(int dev)
 	static int possible_gf1_irqs[] = {5, 11, 12, 9, 7, 15, 3, -1};
 	static int possible_gf1_dmas[] = {5, 6, 7, 1, 3, -1};
 	int xgf1_irq, xgf1_dma, xess_irq, xmpu_irq, xess_dma;
-	snd_card_t *card;
+	struct snd_card *card;
 	struct snd_gusextreme *acard;
-	snd_gus_card_t *gus;
-	es1688_t *es1688;
-	opl3_t *opl3;
+	struct snd_gus_card *gus;
+	struct snd_es1688 *es1688;
+	struct snd_opl3 *opl3;
 	int err;
 
 	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
@@ -345,7 +345,7 @@ static int __init alsa_card_gusextreme_init(void)
 static void __exit alsa_card_gusextreme_exit(void)
 {
 	int idx;
-	snd_card_t *card;
+	struct snd_card *card;
 	struct snd_gusextreme *acard;
 
 	for (idx = 0; idx < SNDRV_CARDS; idx++) {

commit 43bcd973d6d05d16b876e09dcc49a09d3e48e88d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 5 17:19:20 2005 +0200

    [ALSA] Add snd_card_set_generic_dev() call to ISA drivers
    
    ISA,CMI8330 driver,ES18xx driver,OPL3SA2 driver,Sound Galaxy driver
    Sound Scape driver,AD1848 driver,CS4231 driver,CS4236+ driver
    ES1688 driver,GUS Classic driver,GUS Extreme driver,GUS MAX driver
    AMD InterWave driver,Opti9xx drivers,SB16/AWE driver,SB8 driver
    Wavefront drivers
    - Added snd_card_set_generic_dev() call.
    - Added SND_GENERIC_DRIVER to Kconfig.
    - Clean up the error path in probe if necessary.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
index bc6fecb18dcf..d2e7cb1df537 100644
--- a/sound/isa/gus/gusextreme.c
+++ b/sound/isa/gus/gusextreme.c
@@ -87,6 +87,7 @@ MODULE_PARM_DESC(pcm_channels, "Reserved PCM channels for GUS Extreme driver.");
 
 static snd_card_t *snd_gusextreme_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
 
+#define PFX	"gusextreme: "
 
 static int __init snd_gusextreme_detect(int dev,
 					snd_card_t * card,
@@ -94,6 +95,7 @@ static int __init snd_gusextreme_detect(int dev,
 					es1688_t *es1688)
 {
 	unsigned long flags;
+	unsigned char d;
 
 	/*
 	 * This is main stuff - enable access to GF1 chip...
@@ -123,36 +125,17 @@ static int __init snd_gusextreme_detect(int dev,
 	udelay(100);
 
 	snd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 0);	/* reset GF1 */
-#ifdef CONFIG_SND_DEBUG_DETECT
-	{
-		unsigned char d;
-
-		if (((d = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET)) & 0x07) != 0) {
-			snd_printk("[0x%lx] check 1 failed - 0x%x\n", gus->gf1.port, d);
-			return -EIO;
-		}
-	}
-#else
-	if ((snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET) & 0x07) != 0)
+	if (((d = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET)) & 0x07) != 0) {
+		snd_printdd("[0x%lx] check 1 failed - 0x%x\n", gus->gf1.port, d);
 		return -EIO;
-#endif
+	}
 	udelay(160);
 	snd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 1);	/* release reset */
 	udelay(160);
-#ifdef CONFIG_SND_DEBUG_DETECT
-	{
-		unsigned char d;
-
-		if (((d = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET)) & 0x07) != 1) {
-			snd_printk("[0x%lx] check 2 failed - 0x%x\n", gus->gf1.port, d);
-			return -EIO;
-		}
-	}
-#else
-	if ((snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET) & 0x07) != 1)
+	if (((d = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET)) & 0x07) != 1) {
+		snd_printdd("[0x%lx] check 2 failed - 0x%x\n", gus->gf1.port, d);
 		return -EIO;
-#endif
-
+	}
 	return 0;
 }
 
@@ -205,7 +188,7 @@ static int __init snd_gusextreme_probe(int dev)
 	xgf1_irq = gf1_irq[dev];
 	if (xgf1_irq == SNDRV_AUTO_IRQ) {
 		if ((xgf1_irq = snd_legacy_find_free_irq(possible_gf1_irqs)) < 0) {
-			snd_printk("unable to find a free IRQ for GF1\n");
+			snd_printk(KERN_ERR PFX "unable to find a free IRQ for GF1\n");
 			err = -EBUSY;
 			goto out;
 		}
@@ -213,7 +196,7 @@ static int __init snd_gusextreme_probe(int dev)
 	xess_irq = irq[dev];
 	if (xess_irq == SNDRV_AUTO_IRQ) {
 		if ((xess_irq = snd_legacy_find_free_irq(possible_ess_irqs)) < 0) {
-			snd_printk("unable to find a free IRQ for ES1688\n");
+			snd_printk(KERN_ERR PFX "unable to find a free IRQ for ES1688\n");
 			err = -EBUSY;
 			goto out;
 		}
@@ -226,7 +209,7 @@ static int __init snd_gusextreme_probe(int dev)
 	xgf1_dma = dma1[dev];
 	if (xgf1_dma == SNDRV_AUTO_DMA) {
 		if ((xgf1_dma = snd_legacy_find_free_dma(possible_gf1_dmas)) < 0) {
-			snd_printk("unable to find a free DMA for GF1\n");
+			snd_printk(KERN_ERR PFX "unable to find a free DMA for GF1\n");
 			err = -EBUSY;
 			goto out;
 		}
@@ -234,7 +217,7 @@ static int __init snd_gusextreme_probe(int dev)
 	xess_dma = dma8[dev];
 	if (xess_dma == SNDRV_AUTO_DMA) {
 		if ((xess_dma = snd_legacy_find_free_dma(possible_ess_dmas)) < 0) {
-			snd_printk("unable to find a free DMA for ES1688\n");
+			snd_printk(KERN_ERR PFX "unable to find a free DMA for ES1688\n");
 			err = -EBUSY;
 			goto out;
 		}
@@ -264,7 +247,7 @@ static int __init snd_gusextreme_probe(int dev)
 		goto out;
 
 	if (!gus->ess_flag) {
-		snd_printdd("GUS Extreme soundcard was not detected at 0x%lx\n", gus->gf1.port);
+		snd_printk(KERN_ERR PFX "GUS Extreme soundcard was not detected at 0x%lx\n", gus->gf1.port);
 		err = -ENODEV;
 		goto out;
 	}
@@ -287,7 +270,7 @@ static int __init snd_gusextreme_probe(int dev)
 
 	if (snd_opl3_create(card, es1688->port, es1688->port + 2,
 			    OPL3_HW_OPL3, 0, &opl3) < 0) {
-		printk(KERN_ERR "gusextreme: opl3 not detected at 0x%lx\n", es1688->port);
+		printk(KERN_ERR PFX "gusextreme: opl3 not detected at 0x%lx\n", es1688->port);
 	} else {
 		if ((err = snd_opl3_hwdep_new(opl3, 0, 2, NULL)) < 0)
 			goto out;
@@ -303,6 +286,10 @@ static int __init snd_gusextreme_probe(int dev)
 
 	sprintf(card->longname, "Gravis UltraSound Extreme at 0x%lx, irq %i&%i, dma %i&%i",
 		es1688->port, xgf1_irq, xess_irq, xgf1_dma, xess_dma);
+
+	if ((err = snd_card_set_generic_dev(card)) < 0)
+		goto out;
+
 	if ((err = snd_card_register(card)) < 0)
 		goto out;
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/isa/gus/gusextreme.c b/sound/isa/gus/gusextreme.c
new file mode 100644
index 000000000000..bc6fecb18dcf
--- /dev/null
+++ b/sound/isa/gus/gusextreme.c
@@ -0,0 +1,374 @@
+/*
+ *  Driver for Gravis UltraSound Extreme soundcards
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <asm/dma.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/time.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/gus.h>
+#include <sound/es1688.h>
+#include <sound/mpu401.h>
+#include <sound/opl3.h>
+#define SNDRV_LEGACY_AUTO_PROBE
+#define SNDRV_LEGACY_FIND_FREE_IRQ
+#define SNDRV_LEGACY_FIND_FREE_DMA
+#include <sound/initval.h>
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_DESCRIPTION("Gravis UltraSound Extreme");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{Gravis,UltraSound Extreme}}");
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;	/* Enable this card */
+static long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;	/* 0x220,0x240,0x260 */
+static long gf1_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS) - 1] = -1}; /* 0x210,0x220,0x230,0x240,0x250,0x260,0x270 */
+static long mpu_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS) - 1] = -1}; /* 0x300,0x310,0x320 */
+static int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* 5,7,9,10 */
+static int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* 5,7,9,10 */
+static int gf1_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;	/* 2,3,5,9,11,12,15 */
+static int dma8[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;	/* 0,1,3 */
+static int dma1[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;
+static int joystick_dac[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 29};
+				/* 0 to 31, (0.59V-4.52V or 0.389V-2.98V) */
+static int channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 24};
+static int pcm_channels[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for GUS Extreme soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for GUS Extreme soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable GUS Extreme soundcard.");
+module_param_array(port, long, NULL, 0444);
+MODULE_PARM_DESC(port, "Port # for GUS Extreme driver.");
+module_param_array(gf1_port, long, NULL, 0444);
+MODULE_PARM_DESC(gf1_port, "GF1 port # for GUS Extreme driver (optional).");
+module_param_array(mpu_port, long, NULL, 0444);
+MODULE_PARM_DESC(mpu_port, "MPU-401 port # for GUS Extreme driver.");
+module_param_array(irq, int, NULL, 0444);
+MODULE_PARM_DESC(irq, "IRQ # for GUS Extreme driver.");
+module_param_array(mpu_irq, int, NULL, 0444);
+MODULE_PARM_DESC(mpu_irq, "MPU-401 IRQ # for GUS Extreme driver.");
+module_param_array(gf1_irq, int, NULL, 0444);
+MODULE_PARM_DESC(gf1_irq, "GF1 IRQ # for GUS Extreme driver.");
+module_param_array(dma8, int, NULL, 0444);
+MODULE_PARM_DESC(dma8, "8-bit DMA # for GUS Extreme driver.");
+module_param_array(dma1, int, NULL, 0444);
+MODULE_PARM_DESC(dma1, "GF1 DMA # for GUS Extreme driver.");
+module_param_array(joystick_dac, int, NULL, 0444);
+MODULE_PARM_DESC(joystick_dac, "Joystick DAC level 0.59V-4.52V or 0.389V-2.98V for GUS Extreme driver.");
+module_param_array(channels, int, NULL, 0444);
+MODULE_PARM_DESC(channels, "GF1 channels for GUS Extreme driver.");
+module_param_array(pcm_channels, int, NULL, 0444);
+MODULE_PARM_DESC(pcm_channels, "Reserved PCM channels for GUS Extreme driver.");
+
+static snd_card_t *snd_gusextreme_cards[SNDRV_CARDS] = SNDRV_DEFAULT_PTR;
+
+
+static int __init snd_gusextreme_detect(int dev,
+					snd_card_t * card,
+					snd_gus_card_t * gus,
+					es1688_t *es1688)
+{
+	unsigned long flags;
+
+	/*
+	 * This is main stuff - enable access to GF1 chip...
+	 * I'm not sure, if this will work for card which have
+	 * ES1688 chip in another place than 0x220.
+         *
+         * I used reverse-engineering in DOSEMU. [--jk]
+	 *
+	 * ULTRINIT.EXE:
+	 * 0x230 = 0,2,3
+	 * 0x240 = 2,0,1
+	 * 0x250 = 2,0,3
+	 * 0x260 = 2,2,1
+	 */
+
+	spin_lock_irqsave(&es1688->mixer_lock, flags);
+	snd_es1688_mixer_write(es1688, 0x40, 0x0b);	/* don't change!!! */
+	spin_unlock_irqrestore(&es1688->mixer_lock, flags);
+	spin_lock_irqsave(&es1688->reg_lock, flags);
+	outb(gf1_port[dev] & 0x040 ? 2 : 0, ES1688P(es1688, INIT1));
+	outb(0, 0x201);
+	outb(gf1_port[dev] & 0x020 ? 2 : 0, ES1688P(es1688, INIT1));
+	outb(0, 0x201);
+	outb(gf1_port[dev] & 0x010 ? 3 : 1, ES1688P(es1688, INIT1));
+	spin_unlock_irqrestore(&es1688->reg_lock, flags);
+
+	udelay(100);
+
+	snd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 0);	/* reset GF1 */
+#ifdef CONFIG_SND_DEBUG_DETECT
+	{
+		unsigned char d;
+
+		if (((d = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET)) & 0x07) != 0) {
+			snd_printk("[0x%lx] check 1 failed - 0x%x\n", gus->gf1.port, d);
+			return -EIO;
+		}
+	}
+#else
+	if ((snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET) & 0x07) != 0)
+		return -EIO;
+#endif
+	udelay(160);
+	snd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 1);	/* release reset */
+	udelay(160);
+#ifdef CONFIG_SND_DEBUG_DETECT
+	{
+		unsigned char d;
+
+		if (((d = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET)) & 0x07) != 1) {
+			snd_printk("[0x%lx] check 2 failed - 0x%x\n", gus->gf1.port, d);
+			return -EIO;
+		}
+	}
+#else
+	if ((snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET) & 0x07) != 1)
+		return -EIO;
+#endif
+
+	return 0;
+}
+
+static void __init snd_gusextreme_init(int dev, snd_gus_card_t * gus)
+{
+	gus->joystick_dac = joystick_dac[dev];
+}
+
+static int __init snd_gusextreme_mixer(es1688_t *chip)
+{
+	snd_card_t *card = chip->card;
+	snd_ctl_elem_id_t id1, id2;
+	int err;
+
+	memset(&id1, 0, sizeof(id1));
+	memset(&id2, 0, sizeof(id2));
+	id1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	/* reassign AUX to SYNTHESIZER */
+	strcpy(id1.name, "Aux Playback Volume");
+	strcpy(id2.name, "Synth Playback Volume");
+	if ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0)
+		return err;
+	/* reassign Master Playback Switch to Synth Playback Switch */
+	strcpy(id1.name, "Master Playback Switch");
+	strcpy(id2.name, "Synth Playback Switch");
+	if ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0)
+		return err;
+	return 0;
+}
+
+static int __init snd_gusextreme_probe(int dev)
+{
+	static int possible_ess_irqs[] = {5, 9, 10, 7, -1};
+	static int possible_ess_dmas[] = {1, 3, 0, -1};
+	static int possible_gf1_irqs[] = {5, 11, 12, 9, 7, 15, 3, -1};
+	static int possible_gf1_dmas[] = {5, 6, 7, 1, 3, -1};
+	int xgf1_irq, xgf1_dma, xess_irq, xmpu_irq, xess_dma;
+	snd_card_t *card;
+	struct snd_gusextreme *acard;
+	snd_gus_card_t *gus;
+	es1688_t *es1688;
+	opl3_t *opl3;
+	int err;
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+	acard = (struct snd_gusextreme *)card->private_data;
+
+	xgf1_irq = gf1_irq[dev];
+	if (xgf1_irq == SNDRV_AUTO_IRQ) {
+		if ((xgf1_irq = snd_legacy_find_free_irq(possible_gf1_irqs)) < 0) {
+			snd_printk("unable to find a free IRQ for GF1\n");
+			err = -EBUSY;
+			goto out;
+		}
+	}
+	xess_irq = irq[dev];
+	if (xess_irq == SNDRV_AUTO_IRQ) {
+		if ((xess_irq = snd_legacy_find_free_irq(possible_ess_irqs)) < 0) {
+			snd_printk("unable to find a free IRQ for ES1688\n");
+			err = -EBUSY;
+			goto out;
+		}
+	}
+	if (mpu_port[dev] == SNDRV_AUTO_PORT)
+		mpu_port[dev] = 0;
+	xmpu_irq = mpu_irq[dev];
+	if (xmpu_irq > 15)
+		xmpu_irq = -1;
+	xgf1_dma = dma1[dev];
+	if (xgf1_dma == SNDRV_AUTO_DMA) {
+		if ((xgf1_dma = snd_legacy_find_free_dma(possible_gf1_dmas)) < 0) {
+			snd_printk("unable to find a free DMA for GF1\n");
+			err = -EBUSY;
+			goto out;
+		}
+	}
+	xess_dma = dma8[dev];
+	if (xess_dma == SNDRV_AUTO_DMA) {
+		if ((xess_dma = snd_legacy_find_free_dma(possible_ess_dmas)) < 0) {
+			snd_printk("unable to find a free DMA for ES1688\n");
+			err = -EBUSY;
+			goto out;
+		}
+	}
+
+	if ((err = snd_es1688_create(card, port[dev], mpu_port[dev],
+				     xess_irq, xmpu_irq, xess_dma,
+				     ES1688_HW_1688, &es1688)) < 0)
+		goto out;
+	if (gf1_port[dev] < 0)
+		gf1_port[dev] = port[dev] + 0x20;
+	if ((err = snd_gus_create(card,
+				  gf1_port[dev],
+				  xgf1_irq,
+				  xgf1_dma,
+				  -1,
+				  0, channels[dev],
+				  pcm_channels[dev], 0,
+				  &gus)) < 0)
+		goto out;
+
+	if ((err = snd_gusextreme_detect(dev, card, gus, es1688)) < 0)
+		goto out;
+
+	snd_gusextreme_init(dev, gus);
+	if ((err = snd_gus_initialize(gus)) < 0)
+		goto out;
+
+	if (!gus->ess_flag) {
+		snd_printdd("GUS Extreme soundcard was not detected at 0x%lx\n", gus->gf1.port);
+		err = -ENODEV;
+		goto out;
+	}
+	if ((err = snd_es1688_pcm(es1688, 0, NULL)) < 0)
+		goto out;
+
+	if ((err = snd_es1688_mixer(es1688)) < 0)
+		goto out;
+
+	snd_component_add(card, "ES1688");
+	if (pcm_channels[dev] > 0) {
+		if ((err = snd_gf1_pcm_new(gus, 1, 1, NULL)) < 0)
+			goto out;
+	}
+	if ((err = snd_gf1_new_mixer(gus)) < 0)
+		goto out;
+
+	if ((err = snd_gusextreme_mixer(es1688)) < 0)
+		goto out;
+
+	if (snd_opl3_create(card, es1688->port, es1688->port + 2,
+			    OPL3_HW_OPL3, 0, &opl3) < 0) {
+		printk(KERN_ERR "gusextreme: opl3 not detected at 0x%lx\n", es1688->port);
+	} else {
+		if ((err = snd_opl3_hwdep_new(opl3, 0, 2, NULL)) < 0)
+			goto out;
+	}
+
+	if (es1688->mpu_port >= 0x300 &&
+	    (err = snd_mpu401_uart_new(card, 0, MPU401_HW_ES1688,
+					       es1688->mpu_port, 0,
+					       xmpu_irq,
+					       SA_INTERRUPT,
+					       NULL)) < 0)
+		goto out;
+
+	sprintf(card->longname, "Gravis UltraSound Extreme at 0x%lx, irq %i&%i, dma %i&%i",
+		es1688->port, xgf1_irq, xess_irq, xgf1_dma, xess_dma);
+	if ((err = snd_card_register(card)) < 0)
+		goto out;
+
+	snd_gusextreme_cards[dev] = card;
+	return 0;
+
+      out:
+	snd_card_free(card);
+	return err;
+}
+
+static int __init snd_gusextreme_legacy_auto_probe(unsigned long xport)
+{
+        static int dev;
+        int res;
+
+        for ( ; dev < SNDRV_CARDS; dev++) {
+                if (!enable[dev] || port[dev] != SNDRV_AUTO_PORT)
+                        continue;
+                port[dev] = xport;
+                res = snd_gusextreme_probe(dev);
+                if (res < 0)
+                        port[dev] = SNDRV_AUTO_PORT;
+                return res;
+        }
+        return -ENODEV;
+}
+
+static int __init alsa_card_gusextreme_init(void)
+{
+	static unsigned long possible_ports[] = {0x220, 0x240, 0x260, -1};
+	int dev, cards, i;
+
+	for (dev = cards = 0; dev < SNDRV_CARDS && enable[dev] > 0; dev++) {
+		if (port[dev] == SNDRV_AUTO_PORT)
+			continue;
+		if (snd_gusextreme_probe(dev) >= 0)
+			cards++;
+	}
+	i = snd_legacy_auto_probe(possible_ports, snd_gusextreme_legacy_auto_probe);
+	if (i > 0)
+		cards += i;
+
+	if (!cards) {
+#ifdef MODULE
+		printk(KERN_ERR "GUS Extreme soundcard not found or device busy\n");
+#endif
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void __exit alsa_card_gusextreme_exit(void)
+{
+	int idx;
+	snd_card_t *card;
+	struct snd_gusextreme *acard;
+
+	for (idx = 0; idx < SNDRV_CARDS; idx++) {
+		card = snd_gusextreme_cards[idx];
+		if (card == NULL)
+			continue;
+		acard = (struct snd_gusextreme *)card->private_data;
+		snd_card_free(snd_gusextreme_cards[idx]);
+	}
+}
+
+module_init(alsa_card_gusextreme_init)
+module_exit(alsa_card_gusextreme_exit)
