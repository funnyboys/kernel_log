commit 5ce00760a84848d008554c693ceb6286f4d9c509
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Apr 29 21:02:03 2020 +0200

    ALSA: opti9xx: shut up gcc-10 range warning
    
    gcc-10 points out a few instances of suspicious integer arithmetic
    leading to value truncation:
    
    sound/isa/opti9xx/opti92x-ad1848.c: In function 'snd_opti9xx_configure':
    sound/isa/opti9xx/opti92x-ad1848.c:322:43: error: overflow in conversion from 'int' to 'unsigned char' changes value from '(int)snd_opti9xx_read(chip, 3) & -256 | 240' to '240' [-Werror=overflow]
      322 |   (snd_opti9xx_read(chip, reg) & ~(mask)) | ((value) & (mask)))
          |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
    sound/isa/opti9xx/opti92x-ad1848.c:351:3: note: in expansion of macro 'snd_opti9xx_write_mask'
      351 |   snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(3), 0xf0, 0xff);
          |   ^~~~~~~~~~~~~~~~~~~~~~
    sound/isa/opti9xx/miro.c: In function 'snd_miro_configure':
    sound/isa/opti9xx/miro.c:873:40: error: overflow in conversion from 'int' to 'unsigned char' changes value from '(int)snd_miro_read(chip, 3) & -256 | 240' to '240' [-Werror=overflow]
      873 |   (snd_miro_read(chip, reg) & ~(mask)) | ((value) & (mask)))
          |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
    sound/isa/opti9xx/miro.c:1010:3: note: in expansion of macro 'snd_miro_write_mask'
     1010 |   snd_miro_write_mask(chip, OPTi9XX_MC_REG(3), 0xf0, 0xff);
          |   ^~~~~~~~~~~~~~~~~~~
    
    These are all harmless here as only the low 8 bit are passed down
    anyway. Change the macros to inline functions to make the code
    more readable and also avoid the warning.
    
    Strictly speaking those functions also need locking to make the
    read/write pair atomic, but it seems unlikely that anyone would
    still run into that issue.
    
    Fixes: 1841f613fd2e ("[ALSA] Add snd-miro driver")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lore.kernel.org/r/20200429190216.85919-1-arnd@arndb.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index d06b29693c85..0e6d20e49158 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -317,10 +317,13 @@ static void snd_opti9xx_write(struct snd_opti9xx *chip, unsigned char reg,
 }
 
 
-#define snd_opti9xx_write_mask(chip, reg, value, mask)	\
-	snd_opti9xx_write(chip, reg,			\
-		(snd_opti9xx_read(chip, reg) & ~(mask)) | ((value) & (mask)))
+static inline void snd_opti9xx_write_mask(struct snd_opti9xx *chip,
+		unsigned char reg, unsigned char value, unsigned char mask)
+{
+	unsigned char oldval = snd_opti9xx_read(chip, reg);
 
+	snd_opti9xx_write(chip, reg, (oldval & ~mask) | (value & mask));
+}
 
 static int snd_opti9xx_configure(struct snd_opti9xx *chip,
 					   long port,

commit 80e0a7c095462e24f48908e6effd7a44099249f9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:48:05 2020 +0100

    ALSA: opti9xx: More constifications
    
    Apply const prefix to the static resource tables, the mc size tables
    and the string arrays.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-51-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 697576459f71..d06b29693c85 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -163,7 +163,7 @@ MODULE_DEVICE_TABLE(pnp_card, snd_opti9xx_pnpids);
 
 #define DEV_NAME KBUILD_MODNAME
 
-static char * snd_opti9xx_names[] = {
+static const char * const snd_opti9xx_names[] = {
 	"unknown",
 	"82C928",	"82C929",
 	"82C924",	"82C925",
@@ -173,7 +173,7 @@ static char * snd_opti9xx_names[] = {
 static int snd_opti9xx_init(struct snd_opti9xx *chip,
 			    unsigned short hardware)
 {
-	static int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};
+	static const int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};
 
 	chip->hardware = hardware;
 	strcpy(chip->name, snd_opti9xx_names[hardware]);
@@ -808,7 +808,7 @@ static void snd_card_opti9xx_free(struct snd_card *card)
 
 static int snd_opti9xx_probe(struct snd_card *card)
 {
-	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
+	static const long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
 	int error;
 	int xdma2;
 	struct snd_opti9xx *chip = card->private_data;
@@ -958,16 +958,16 @@ static int snd_opti9xx_isa_probe(struct device *devptr,
 {
 	struct snd_card *card;
 	int error;
-	static long possible_mpu_ports[] = {0x300, 0x310, 0x320, 0x330, -1};
+	static const long possible_mpu_ports[] = {0x300, 0x310, 0x320, 0x330, -1};
 #ifdef OPTi93X
-	static int possible_irqs[] = {5, 9, 10, 11, 7, -1};
+	static const int possible_irqs[] = {5, 9, 10, 11, 7, -1};
 #else
-	static int possible_irqs[] = {9, 10, 11, 7, -1};
+	static const int possible_irqs[] = {9, 10, 11, 7, -1};
 #endif	/* OPTi93X */
-	static int possible_mpu_irqs[] = {5, 9, 10, 7, -1};
-	static int possible_dma1s[] = {3, 1, 0, -1};
+	static const int possible_mpu_irqs[] = {5, 9, 10, 7, -1};
+	static const int possible_dma1s[] = {3, 1, 0, -1};
 #if defined(CS4231) || defined(OPTi93X)
-	static int possible_dma2s[][2] = {{1,-1}, {0,-1}, {-1,-1}, {0,-1}};
+	static const int possible_dma2s[][2] = {{1,-1}, {0,-1}, {-1,-1}, {0,-1}};
 #endif	/* CS4231 || OPTi93X */
 
 	if (mpu_port == SNDRV_AUTO_PORT) {

commit fdd1f6fd328ff2e3723fe2a5c94378ef6f217edc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:51 2020 +0100

    ALSA: isa: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-36-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index b40ab806c349..697576459f71 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -550,7 +550,7 @@ static const DECLARE_TLV_DB_SCALE(db_scale_5bit_3db_step, -9300, 300, 0);
 static const DECLARE_TLV_DB_SCALE(db_scale_5bit, -4650, 150, 0);
 static const DECLARE_TLV_DB_SCALE(db_scale_4bit_12db_max, -3300, 300, 0);
 
-static struct snd_kcontrol_new snd_opti93x_controls[] = {
+static const struct snd_kcontrol_new snd_opti93x_controls[] = {
 WSS_DOUBLE("Master Playback Switch", 0,
 		OPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 7, 7, 1, 1),
 WSS_DOUBLE_TLV("Master Playback Volume", 0,

commit 16d9fb1deef8cf0c83c86a6538f8522a89676d4c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:44 2019 +0100

    ALSA: opti9xx: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-46-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index fb36bb5d55df..b40ab806c349 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -869,6 +869,7 @@ static int snd_opti9xx_probe(struct snd_card *card)
 	}
 #endif
 	chip->irq = irq;
+	card->sync_irq = chip->irq;
 	strcpy(card->driver, chip->name);
 	sprintf(card->shortname, "OPTi %s", card->driver);
 #if defined(CS4231) || defined(OPTi93X)

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 47e0b2820ace..fb36bb5d55df 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
     card-opti92x-ad1848.c - driver for OPTi 82c92x based soundcards.
     Copyright (C) 1998-2000 by Massimo Piccioni <dafastidio@libero.it>
@@ -7,19 +8,6 @@
 
     Thanks to Maria Grazia Pollarini, Salvatore Vassallo.
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 */
 
 

commit 74ce5a46bb7b0298dc0be11bae944fca5d1f18a7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 4 20:02:06 2018 +0200

    ALSA: opti92xx-ad1848: Use the standard fall-through annotation
    
    As a preparatory patch for the upcoming -Wimplicit-fallthrough
    compiler checks, replace with the standard "fall through" annotation
    at the right places.  They have to be put right before the next
    labels.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index ac0ab6eb40f0..47e0b2820ace 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -389,7 +389,8 @@ static int snd_opti9xx_configure(struct snd_opti9xx *chip,
 	case OPTi9XX_HW_82C931:
 		/* disable 3D sound (set GPIO1 as output, low) */
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(20), 0x04, 0x0c);
-	case OPTi9XX_HW_82C933: /* FALL THROUGH */
+		/* fall through */
+	case OPTi9XX_HW_82C933:
 		/*
 		 * The BTC 1817DW has QS1000 wavetable which is connected
 		 * to the serial digital input of the OPTI931.
@@ -400,7 +401,8 @@ static int snd_opti9xx_configure(struct snd_opti9xx *chip,
 		 * or digital input signal.
 		 */
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(26), 0x01, 0x01);
-	case OPTi9XX_HW_82C930: /* FALL THROUGH */
+		/* fall through */
+	case OPTi9XX_HW_82C930:
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x03);
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(3), 0x00, 0xff);
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(4), 0x10 |

commit 3e313f34720ea1bb876636263e30a779ff65836e
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Aug 2 15:41:21 2018 -0500

    ALSA: opti92x: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Addresses-Coverity-ID: 1165394 ("Missing break in switch")
    Addresses-Coverity-ID: 1167851 ("Missing break in switch")
    Addresses-Coverity-ID: 402015 ("Missing break in switch")
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 505cd81e19fa..ac0ab6eb40f0 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -261,6 +261,7 @@ static unsigned char snd_opti9xx_read(struct snd_opti9xx *chip,
 			retval = inb(chip->mc_base + 9);
 			break;
 		}
+		/* Fall through */
 
 	case OPTi9XX_HW_82C928:
 	case OPTi9XX_HW_82C929:
@@ -303,6 +304,7 @@ static void snd_opti9xx_write(struct snd_opti9xx *chip, unsigned char reg,
 			outb(value, chip->mc_base + 9);
 			break;
 		}
+		/* Fall through */
 
 	case OPTi9XX_HW_82C928:
 	case OPTi9XX_HW_82C929:
@@ -350,6 +352,7 @@ static int snd_opti9xx_configure(struct snd_opti9xx *chip,
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(4), 0xf0, 0xfc);
 		/* enable wave audio */
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x02);
+		/* Fall through */
 
 	case OPTi9XX_HW_82C925:
 		/* enable WSS mode */

commit 529d25761173cba9e5cd8e1629c6477a141fce6d
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Thu Aug 17 15:36:27 2017 +0530

    ALSA: opti9xx: constify pnp_card_device_id
    
    pnp_card_device_id are not supposed to change at runtime. All functions
    working with pnp_card_device_id provided by <linux/pnp.h> work with
    const pnp_card_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 56dc581c57d5..505cd81e19fa 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -151,7 +151,7 @@ static int snd_opti9xx_pnp_is_probed;
 
 #ifdef CONFIG_PNP
 
-static struct pnp_card_device_id snd_opti9xx_pnpids[] = {
+static const struct pnp_card_device_id snd_opti9xx_pnpids[] = {
 #ifndef OPTi93X
 	/* OPTi 82C924 */
 	{ .id = "OPT0924",

commit 24d220773139ae03fc7bda692c5f6335ea457059
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jul 18 13:48:07 2017 +0200

    ALSA: opti9xx: fix format string overflow warning
    
    We pass a long name from "codec->pcm->name" into the longname
    string of the same length:
    
    sound/isa/opti9xx/miro.c: In function 'snd_miro_probe':
    sound/isa/opti9xx/miro.c:1356:39: error: '%s' directive writing up to 79 bytes into a region of size between 35 and 72 [-Werror=format-overflow=]
      sprintf(card->longname, "%s: OPTi%s, %s at 0x%lx, irq %d, dma %d&%d",
                                           ^~
    sound/isa/opti9xx/miro.c:1356:26: note: using the range [0, 4294967295] for directive argument
      sprintf(card->longname, "%s: OPTi%s, %s at 0x%lx, irq %d, dma %d&%d",
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    sound/isa/opti9xx/miro.c:1356:2: note: 'sprintf' output between 32 and 185 bytes into a destination of size 80
      sprintf(card->longname, "%s: OPTi%s, %s at 0x%lx, irq %d, dma %d&%d",
    
    There is no easy way to avoid the theoretical overflow in this case,
    but using snprintf() will turn it into a harmless truncation.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index ceddb392b1e3..56dc581c57d5 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -879,13 +879,15 @@ static int snd_opti9xx_probe(struct snd_card *card)
 	strcpy(card->driver, chip->name);
 	sprintf(card->shortname, "OPTi %s", card->driver);
 #if defined(CS4231) || defined(OPTi93X)
-	sprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d&%d",
-		card->shortname, codec->pcm->name,
-		chip->wss_base + 4, irq, dma1, xdma2);
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s, %s at 0x%lx, irq %d, dma %d&%d",
+		 card->shortname, codec->pcm->name,
+		 chip->wss_base + 4, irq, dma1, xdma2);
 #else
-	sprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d",
-		card->shortname, codec->pcm->name, chip->wss_base + 4, irq,
-		dma1);
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s, %s at 0x%lx, irq %d, dma %d",
+		 card->shortname, codec->pcm->name, chip->wss_base + 4, irq,
+		 dma1);
 #endif	/* CS4231 || OPTi93X */
 
 	if (mpu_port <= 0 || mpu_port == SNDRV_AUTO_PORT)

commit e992ef5705c1e154acb248869b39e0be4c003a8b
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:30 2017 +0100

    Annotate hardware config module parameters in sound/isa/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in sound/isa/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jaroslav Kysela <perex@perex.cz>
    cc: Takashi Iwai <tiwai@suse.com>
    cc: alsa-devel@alsa-project.org

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 0a5266003786..ceddb392b1e3 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -88,20 +88,20 @@ MODULE_PARM_DESC(id, "ID string for opti9xx based soundcard.");
 module_param(isapnp, bool, 0444);
 MODULE_PARM_DESC(isapnp, "Enable ISA PnP detection for specified soundcard.");
 #endif
-module_param(port, long, 0444);
+module_param_hw(port, long, ioport, 0444);
 MODULE_PARM_DESC(port, "WSS port # for opti9xx driver.");
-module_param(mpu_port, long, 0444);
+module_param_hw(mpu_port, long, ioport, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for opti9xx driver.");
-module_param(fm_port, long, 0444);
+module_param_hw(fm_port, long, ioport, 0444);
 MODULE_PARM_DESC(fm_port, "FM port # for opti9xx driver.");
-module_param(irq, int, 0444);
+module_param_hw(irq, int, irq, 0444);
 MODULE_PARM_DESC(irq, "WSS irq # for opti9xx driver.");
-module_param(mpu_irq, int, 0444);
+module_param_hw(mpu_irq, int, irq, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU-401 irq # for opti9xx driver.");
-module_param(dma1, int, 0444);
+module_param_hw(dma1, int, dma, 0444);
 MODULE_PARM_DESC(dma1, "1st dma # for opti9xx driver.");
 #if defined(CS4231) || defined(OPTi93X)
-module_param(dma2, int, 0444);
+module_param_hw(dma2, int, dma, 0444);
 MODULE_PARM_DESC(dma2, "2nd dma # for opti9xx driver.");
 #endif	/* CS4231 || OPTi93X */
 

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 840831f1dd4e..0a5266003786 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -29,7 +29,7 @@
 #include <linux/delay.h>
 #include <linux/pnp.h>
 #include <linux/module.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <asm/dma.h>
 #include <sound/core.h>
 #include <sound/tlv.h>

commit fa60c065694a81e534c61809ab7dd419366e9335
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Jan 2 12:24:43 2015 +0100

    ALSA: wss: Remove (almost) always NULL parameters
    
    Most callers of snd_wss_pcm(), snd_wss_timer() and snd_cs4236_pcm() pass
    NULL as the last parameter, some callers pass a pointer but never use it
    after the function has been called and only a few callers pass a pointer and
    actually use it. The later is only the case for snd_wss_pcm() for
    snd_cs4236_pcm() and it is possible to get the same PCM object by accessing
    the pcm field of the snd_wss struct that was passed as the first parameter.
    
    This function removes the last parameters from the functions mentioned above
    and updates the callers which used it to use chip->pcm instead. This allows
    us to slightly simplify the functions since they don't have to check and set
    the last parameter anymore which makes the code slightly shorter and
    cleaner.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index c9b582848603..840831f1dd4e 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -820,10 +820,6 @@ static int snd_opti9xx_probe(struct snd_card *card)
 	int xdma2;
 	struct snd_opti9xx *chip = card->private_data;
 	struct snd_wss *codec;
-#ifdef CS4231
-	struct snd_timer *timer;
-#endif
-	struct snd_pcm *pcm;
 	struct snd_rawmidi *rmidi;
 	struct snd_hwdep *synth;
 
@@ -855,7 +851,7 @@ static int snd_opti9xx_probe(struct snd_card *card)
 	if (error < 0)
 		return error;
 	chip->codec = codec;
-	error = snd_wss_pcm(codec, 0, &pcm);
+	error = snd_wss_pcm(codec, 0);
 	if (error < 0)
 		return error;
 	error = snd_wss_mixer(codec);
@@ -867,7 +863,7 @@ static int snd_opti9xx_probe(struct snd_card *card)
 		return error;
 #endif
 #ifdef CS4231
-	error = snd_wss_timer(codec, 0, &timer);
+	error = snd_wss_timer(codec, 0);
 	if (error < 0)
 		return error;
 #endif
@@ -884,11 +880,12 @@ static int snd_opti9xx_probe(struct snd_card *card)
 	sprintf(card->shortname, "OPTi %s", card->driver);
 #if defined(CS4231) || defined(OPTi93X)
 	sprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d&%d",
-		card->shortname, pcm->name,
+		card->shortname, codec->pcm->name,
 		chip->wss_base + 4, irq, dma1, xdma2);
 #else
 	sprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d",
-		card->shortname, pcm->name, chip->wss_base + 4, irq, dma1);
+		card->shortname, codec->pcm->name, chip->wss_base + 4, irq,
+		dma1);
 #endif	/* CS4231 || OPTi93X */
 
 	if (mpu_port <= 0 || mpu_port == SNDRV_AUTO_PORT)

commit 4323cc4d5b25b5138c0791e3c7d3b09bd7062b49
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 13:03:56 2014 +0100

    ALSA: isa: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 6effe99bbb9c..c9b582848603 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -934,13 +934,13 @@ static int snd_opti9xx_probe(struct snd_card *card)
 	return snd_card_register(card);
 }
 
-static int snd_opti9xx_card_new(struct snd_card **cardp)
+static int snd_opti9xx_card_new(struct device *pdev, struct snd_card **cardp)
 {
 	struct snd_card *card;
 	int err;
 
-	err = snd_card_create(index, id, THIS_MODULE,
-			      sizeof(struct snd_opti9xx), &card);
+	err = snd_card_new(pdev, index, id, THIS_MODULE,
+			   sizeof(struct snd_opti9xx), &card);
 	if (err < 0)
 		return err;
 	card->private_free = snd_card_opti9xx_free;
@@ -1010,7 +1010,7 @@ static int snd_opti9xx_isa_probe(struct device *devptr,
 	}
 #endif
 
-	error = snd_opti9xx_card_new(&card);
+	error = snd_opti9xx_card_new(devptr, &card);
 	if (error < 0)
 		return error;
 
@@ -1018,7 +1018,6 @@ static int snd_opti9xx_isa_probe(struct device *devptr,
 		snd_card_free(card);
 		return error;
 	}
-	snd_card_set_dev(card, devptr);
 	if ((error = snd_opti9xx_probe(card)) < 0) {
 		snd_card_free(card);
 		return error;
@@ -1100,7 +1099,7 @@ static int snd_opti9xx_pnp_probe(struct pnp_card_link *pcard,
 		return -EBUSY;
 	if (! isapnp)
 		return -ENODEV;
-	error = snd_opti9xx_card_new(&card);
+	error = snd_opti9xx_card_new(&pcard->card->dev, &card);
 	if (error < 0)
 		return error;
 	chip = card->private_data;
@@ -1131,7 +1130,6 @@ static int snd_opti9xx_pnp_probe(struct pnp_card_link *pcard,
 		snd_card_free(card);
 		return error;
 	}
-	snd_card_set_dev(card, &pcard->card->dev);
 	if ((error = snd_opti9xx_probe(card)) < 0) {
 		snd_card_free(card);
 		return error;

commit fb615499f0ad28ed74201c1cdfddf9e64e205424
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 27 12:03:01 2013 +0200

    ALSA: opti9xx: Fix conflicting driver object name
    
    The recent commit to delay the release of kobject triggered NULL
    dereferences of opti9xx drivers.  The cause is that all
    snd-opti92x-ad1848, snd-opti92x-cs4231 and snd-opti93x drivers
    register the PnP card driver with the very same name, and also
    snd-opti92x-ad1848 and -cs4231 drivers register the ISA driver with
    the same name, too.  When these drivers are built in, quick
    "register-release-and-re-register" actions occur, and this results in
    Oops because of the same name is assigned to the kobject.
    
    The fix is simply to assign individual names.  As a bonus, by using
    KBUILD_MODNAME, the patch reduces more lines than it adds.
    
    The fix is based on the suggestion by Russell King.
    
    Reported-and-tested-by: Fengguang Wu <fengguang.wu@intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 103b33373fd4..6effe99bbb9c 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -173,11 +173,7 @@ MODULE_DEVICE_TABLE(pnp_card, snd_opti9xx_pnpids);
 
 #endif	/* CONFIG_PNP */
 
-#ifdef OPTi93X
-#define DEV_NAME "opti93x"
-#else
-#define DEV_NAME "opti92x"
-#endif
+#define DEV_NAME KBUILD_MODNAME
 
 static char * snd_opti9xx_names[] = {
 	"unknown",
@@ -1167,7 +1163,7 @@ static int snd_opti9xx_pnp_resume(struct pnp_card_link *pcard)
 
 static struct pnp_card_driver opti9xx_pnpc_driver = {
 	.flags		= PNP_DRIVER_RES_DISABLE,
-	.name		= "opti9xx",
+	.name		= DEV_NAME,
 	.id_table	= snd_opti9xx_pnpids,
 	.probe		= snd_opti9xx_pnp_probe,
 	.remove		= snd_opti9xx_pnp_remove,

commit 8b5a1f9c46c2b78716794b8762edf659ec25a87d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:49:32 2013 +0200

    ALSA: ISA: Remove superfluous *_set_drvdata(NULL) calls
    
    Similarly like the previous commit for PCI drivers, remove
    dev_set_drvdata(NULL) and pnp_set_drvdata(NULL) calls in ISA drivers
    now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index b41ed8661b23..103b33373fd4 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -1035,7 +1035,6 @@ static int snd_opti9xx_isa_remove(struct device *devptr,
 				  unsigned int dev)
 {
 	snd_card_free(dev_get_drvdata(devptr));
-	dev_set_drvdata(devptr, NULL);
 	return 0;
 }
 

commit 1bff292e9abec7477d43abb2b93c7fd26c44859b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:21 2012 -0500

    ALSA: isa: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 2899c9fd1ceb..b41ed8661b23 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -186,8 +186,8 @@ static char * snd_opti9xx_names[] = {
 	"82C930",	"82C931",	"82C933"
 };
 
-static int __devinit snd_opti9xx_init(struct snd_opti9xx *chip,
-				      unsigned short hardware)
+static int snd_opti9xx_init(struct snd_opti9xx *chip,
+			    unsigned short hardware)
 {
 	static int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};
 
@@ -593,7 +593,7 @@ WSS_DOUBLE_TLV("Aux Playback Volume", 0,
 		db_scale_4bit_12db_max),
 };
 
-static int __devinit snd_opti93x_mixer(struct snd_wss *chip)
+static int snd_opti93x_mixer(struct snd_wss *chip)
 {
 	struct snd_card *card;
 	unsigned int idx;
@@ -666,7 +666,7 @@ static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id)
 
 #endif /* OPTi93X */
 
-static int __devinit snd_opti9xx_read_check(struct snd_opti9xx *chip)
+static int snd_opti9xx_read_check(struct snd_opti9xx *chip)
 {
 	unsigned char value;
 #ifdef OPTi93X
@@ -707,8 +707,8 @@ static int __devinit snd_opti9xx_read_check(struct snd_opti9xx *chip)
 	return -ENODEV;
 }
 
-static int __devinit snd_card_opti9xx_detect(struct snd_card *card,
-					     struct snd_opti9xx *chip)
+static int snd_card_opti9xx_detect(struct snd_card *card,
+				   struct snd_opti9xx *chip)
 {
 	int i, err;
 
@@ -732,9 +732,9 @@ static int __devinit snd_card_opti9xx_detect(struct snd_card *card,
 }
 
 #ifdef CONFIG_PNP
-static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip,
-					  struct pnp_card_link *card,
-					  const struct pnp_card_device_id *pid)
+static int snd_card_opti9xx_pnp(struct snd_opti9xx *chip,
+				struct pnp_card_link *card,
+				const struct pnp_card_device_id *pid)
 {
 	struct pnp_dev *pdev;
 	int err;
@@ -817,7 +817,7 @@ static void snd_card_opti9xx_free(struct snd_card *card)
 	}
 }
 
-static int __devinit snd_opti9xx_probe(struct snd_card *card)
+static int snd_opti9xx_probe(struct snd_card *card)
 {
 	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
 	int error;
@@ -952,8 +952,8 @@ static int snd_opti9xx_card_new(struct snd_card **cardp)
 	return 0;
 }
 
-static int __devinit snd_opti9xx_isa_match(struct device *devptr,
-					   unsigned int dev)
+static int snd_opti9xx_isa_match(struct device *devptr,
+				 unsigned int dev)
 {
 #ifdef CONFIG_PNP
 	if (snd_opti9xx_pnp_is_probed)
@@ -964,8 +964,8 @@ static int __devinit snd_opti9xx_isa_match(struct device *devptr,
 	return 1;
 }
 
-static int __devinit snd_opti9xx_isa_probe(struct device *devptr,
-					   unsigned int dev)
+static int snd_opti9xx_isa_probe(struct device *devptr,
+				 unsigned int dev)
 {
 	struct snd_card *card;
 	int error;
@@ -1031,8 +1031,8 @@ static int __devinit snd_opti9xx_isa_probe(struct device *devptr,
 	return 0;
 }
 
-static int __devexit snd_opti9xx_isa_remove(struct device *devptr,
-					    unsigned int dev)
+static int snd_opti9xx_isa_remove(struct device *devptr,
+				  unsigned int dev)
 {
 	snd_card_free(dev_get_drvdata(devptr));
 	dev_set_drvdata(devptr, NULL);
@@ -1083,7 +1083,7 @@ static int snd_opti9xx_isa_resume(struct device *dev, unsigned int n)
 static struct isa_driver snd_opti9xx_driver = {
 	.match		= snd_opti9xx_isa_match,
 	.probe		= snd_opti9xx_isa_probe,
-	.remove		= __devexit_p(snd_opti9xx_isa_remove),
+	.remove		= snd_opti9xx_isa_remove,
 #ifdef CONFIG_PM
 	.suspend	= snd_opti9xx_isa_suspend,
 	.resume		= snd_opti9xx_isa_resume,
@@ -1094,8 +1094,8 @@ static struct isa_driver snd_opti9xx_driver = {
 };
 
 #ifdef CONFIG_PNP
-static int __devinit snd_opti9xx_pnp_probe(struct pnp_card_link *pcard,
-					   const struct pnp_card_device_id *pid)
+static int snd_opti9xx_pnp_probe(struct pnp_card_link *pcard,
+				 const struct pnp_card_device_id *pid)
 {
 	struct snd_card *card;
 	int error, hw;
@@ -1146,7 +1146,7 @@ static int __devinit snd_opti9xx_pnp_probe(struct pnp_card_link *pcard,
 	return 0;
 }
 
-static void __devexit snd_opti9xx_pnp_remove(struct pnp_card_link * pcard)
+static void snd_opti9xx_pnp_remove(struct pnp_card_link *pcard)
 {
 	snd_card_free(pnp_get_card_drvdata(pcard));
 	pnp_set_card_drvdata(pcard, NULL);
@@ -1171,7 +1171,7 @@ static struct pnp_card_driver opti9xx_pnpc_driver = {
 	.name		= "opti9xx",
 	.id_table	= snd_opti9xx_pnpids,
 	.probe		= snd_opti9xx_pnp_probe,
-	.remove		= __devexit_p(snd_opti9xx_pnp_remove),
+	.remove		= snd_opti9xx_pnp_remove,
 #ifdef CONFIG_PM
 	.suspend	= snd_opti9xx_pnp_suspend,
 	.resume		= snd_opti9xx_pnp_resume,

commit 988aec3de5f0fa848f26fbf64f9e83364d6b3c25
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Wed Aug 1 16:05:39 2012 +0200

    ALSA: isa: Move snd_legacy_find_free_ioport to initval.h
    
    Move snd_legacy_find_free_ioport() function back to initval.h as it is used
    by two drivers.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index f8fbe22515c9..2899c9fd1ceb 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -39,6 +39,7 @@
 #ifndef OPTi93X
 #include <sound/opl4.h>
 #endif
+#define SNDRV_LEGACY_FIND_FREE_IOPORT
 #define SNDRV_LEGACY_FIND_FREE_IRQ
 #define SNDRV_LEGACY_FIND_FREE_DMA
 #include <sound/initval.h>
@@ -185,19 +186,6 @@ static char * snd_opti9xx_names[] = {
 	"82C930",	"82C931",	"82C933"
 };
 
-
-static long __devinit snd_legacy_find_free_ioport(long *port_table, long size)
-{
-	while (*port_table != -1) {
-		if (request_region(*port_table, size, "ALSA test")) {
-			release_region(*port_table, size);
-			return *port_table;
-		}
-		port_table++;
-	}
-	return -1;
-}
-
 static int __devinit snd_opti9xx_init(struct snd_opti9xx *chip,
 				      unsigned short hardware)
 {

commit 59b1f084abd8690ffe68c67758ad08bbcb7d1af0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jul 17 12:14:17 2012 +0200

    ALSA: opti9xx: Fix section mismatch by PM support
    
    In the previous commit, snd_opti9xx_configure() is called from the
    resume handler but it's still marked as __devinit.  Fix it.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index d7ce0125dcf2..f8fbe22515c9 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -348,7 +348,7 @@ static void snd_opti9xx_write(struct snd_opti9xx *chip, unsigned char reg,
 		(snd_opti9xx_read(chip, reg) & ~(mask)) | ((value) & (mask)))
 
 
-static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip,
+static int snd_opti9xx_configure(struct snd_opti9xx *chip,
 					   long port,
 					   int irq, int dma1, int dma2,
 					   long mpu_port, int mpu_irq)

commit 5dd250728aa4cad49cfa18eb8ed11ba470ce382a
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Jul 17 09:16:44 2012 +0200

    ALSA: snd-opti9xx: Implement suspend/resume
    
    Implement suspend/resume support for Opti 92x and 93x chips.
    Tested with Opti 929A+AD1848 and Opti 931.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index ecc68dfe7b54..d7ce0125dcf2 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -136,8 +136,8 @@ struct snd_opti9xx {
 #ifdef OPTi93X
 	unsigned long mc_indir_index;
 	struct resource *res_mc_indir;
-	struct snd_wss *codec;
 #endif	/* OPTi93X */
+	struct snd_wss *codec;
 	unsigned long pwd_reg;
 
 	spinlock_t lock;
@@ -870,9 +870,7 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 			       &codec);
 	if (error < 0)
 		return error;
-#ifdef OPTi93X
 	chip->codec = codec;
-#endif
 	error = snd_wss_pcm(codec, 0, &pcm);
 	if (error < 0)
 		return error;
@@ -1053,11 +1051,55 @@ static int __devexit snd_opti9xx_isa_remove(struct device *devptr,
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static int snd_opti9xx_suspend(struct snd_card *card)
+{
+	struct snd_opti9xx *chip = card->private_data;
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	chip->codec->suspend(chip->codec);
+	return 0;
+}
+
+static int snd_opti9xx_resume(struct snd_card *card)
+{
+	struct snd_opti9xx *chip = card->private_data;
+	int error, xdma2;
+#if defined(CS4231) || defined(OPTi93X)
+	xdma2 = dma2;
+#else
+	xdma2 = -1;
+#endif
+
+	error = snd_opti9xx_configure(chip, port, irq, dma1, xdma2,
+				      mpu_port, mpu_irq);
+	if (error)
+		return error;
+	chip->codec->resume(chip->codec);
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	return 0;
+}
+
+static int snd_opti9xx_isa_suspend(struct device *dev, unsigned int n,
+				   pm_message_t state)
+{
+	return snd_opti9xx_suspend(dev_get_drvdata(dev));
+}
+
+static int snd_opti9xx_isa_resume(struct device *dev, unsigned int n)
+{
+	return snd_opti9xx_resume(dev_get_drvdata(dev));
+}
+#endif
+
 static struct isa_driver snd_opti9xx_driver = {
 	.match		= snd_opti9xx_isa_match,
 	.probe		= snd_opti9xx_isa_probe,
 	.remove		= __devexit_p(snd_opti9xx_isa_remove),
-	/* FIXME: suspend/resume */
+#ifdef CONFIG_PM
+	.suspend	= snd_opti9xx_isa_suspend,
+	.resume		= snd_opti9xx_isa_resume,
+#endif
 	.driver		= {
 		.name	= DEV_NAME
 	},
@@ -1123,12 +1165,29 @@ static void __devexit snd_opti9xx_pnp_remove(struct pnp_card_link * pcard)
 	snd_opti9xx_pnp_is_probed = 0;
 }
 
+#ifdef CONFIG_PM
+static int snd_opti9xx_pnp_suspend(struct pnp_card_link *pcard,
+				   pm_message_t state)
+{
+	return snd_opti9xx_suspend(pnp_get_card_drvdata(pcard));
+}
+
+static int snd_opti9xx_pnp_resume(struct pnp_card_link *pcard)
+{
+	return snd_opti9xx_resume(pnp_get_card_drvdata(pcard));
+}
+#endif
+
 static struct pnp_card_driver opti9xx_pnpc_driver = {
 	.flags		= PNP_DRIVER_RES_DISABLE,
 	.name		= "opti9xx",
 	.id_table	= snd_opti9xx_pnpids,
 	.probe		= snd_opti9xx_pnp_probe,
 	.remove		= __devexit_p(snd_opti9xx_pnp_remove),
+#ifdef CONFIG_PM
+	.suspend	= snd_opti9xx_pnp_suspend,
+	.resume		= snd_opti9xx_pnp_resume,
+#endif
 };
 #endif
 

commit 10a3061accd897c9e4e3821cbd501660ac482497
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Jun 15 20:55:54 2012 +0200

    ALSA: snd-opti9xx: fixes for MED3931 card (opti931)
    
    MED3931 card did not work (failed with "OPTI chip not found") because
    snd-opti9xx gets mc_indir_index from pnp by adding 2 to the pnp-reported port.
    It probably works for some cards but not for this one. Datasheet says that
    the port is always at 0xe?e so just force the lowest nibble to be 0xe.
    
    Also this card powers up with (ugly) 3D sound enabled. As there's no mixer
    control for this, just disable it.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index d7ccf28bd66a..ecc68dfe7b54 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -135,7 +135,6 @@ struct snd_opti9xx {
 	unsigned long mc_base_size;
 #ifdef OPTi93X
 	unsigned long mc_indir_index;
-	unsigned long mc_indir_size;
 	struct resource *res_mc_indir;
 	struct snd_wss *codec;
 #endif	/* OPTi93X */
@@ -245,10 +244,8 @@ static int __devinit snd_opti9xx_init(struct snd_opti9xx *chip,
 	case OPTi9XX_HW_82C931:
 	case OPTi9XX_HW_82C933:
 		chip->mc_base = (hardware == OPTi9XX_HW_82C930) ? 0xf8f : 0xf8d;
-		if (!chip->mc_indir_index) {
+		if (!chip->mc_indir_index)
 			chip->mc_indir_index = 0xe0e;
-			chip->mc_indir_size = 2;
-		}
 		chip->password = 0xe4;
 		chip->pwd_reg = 0;
 		break;
@@ -403,7 +400,9 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip,
 
 #else	/* OPTi93X */
 	case OPTi9XX_HW_82C931:
-	case OPTi9XX_HW_82C933:
+		/* disable 3D sound (set GPIO1 as output, low) */
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(20), 0x04, 0x0c);
+	case OPTi9XX_HW_82C933: /* FALL THROUGH */
 		/*
 		 * The BTC 1817DW has QS1000 wavetable which is connected
 		 * to the serial digital input of the OPTI931.
@@ -696,8 +695,7 @@ static int __devinit snd_opti9xx_read_check(struct snd_opti9xx *chip)
 		if (value == snd_opti9xx_read(chip, OPTi9XX_MC_REG(1)))
 			return 0;
 #else	/* OPTi93X */
-	chip->res_mc_indir = request_region(chip->mc_indir_index,
-					    chip->mc_indir_size,
+	chip->res_mc_indir = request_region(chip->mc_indir_index, 2,
 					    "OPTi93x MC");
 	if (chip->res_mc_indir == NULL)
 		return -EBUSY;
@@ -770,8 +768,9 @@ static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip,
 #ifdef OPTi93X
 	port = pnp_port_start(pdev, 0) - 4;
 	fm_port = pnp_port_start(pdev, 1) + 8;
-	chip->mc_indir_index = pnp_port_start(pdev, 3) + 2;
-	chip->mc_indir_size = pnp_port_len(pdev, 3) - 2;
+	/* adjust mc_indir_index - some cards report it at 0xe?d,
+	   other at 0xe?c but it really is always at 0xe?e */
+	chip->mc_indir_index = (pnp_port_start(pdev, 3) & ~0xf) | 0xe;
 #else
 	devmc = pnp_request_card_device(card, pid->devs[2].id, NULL);
 	if (devmc == NULL)

commit c578ae0026da81a589245ee08e0fd1b1d8a55f4e
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Wed Mar 28 18:26:17 2012 -0700

    ALSA: fix isa/opti9xx module param type
    
    Fix module parameter data type to eliminate build warnings.
    
    sound/isa/opti9xx/opti92x-ad1848.c:87:1: warning: return from incompatible pointer type
    sound/isa/opti9xx/opti92x-ad1848.c:87:1: warning: return from incompatible pointer type
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index babaedd242f7..d7ccf28bd66a 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -65,7 +65,7 @@ static int index = SNDRV_DEFAULT_IDX1;	/* Index 0-MAX */
 static char *id = SNDRV_DEFAULT_STR1;		/* ID for this card */
 //static bool enable = SNDRV_DEFAULT_ENABLE1;	/* Enable this card */
 #ifdef CONFIG_PNP
-static int isapnp = 1;			/* Enable ISA PnP detection */
+static bool isapnp = true;			/* Enable ISA PnP detection */
 #endif
 static long port = SNDRV_DEFAULT_PORT1; 	/* 0x530,0xe80,0xf40,0x604 */
 static long mpu_port = SNDRV_DEFAULT_PORT1;	/* 0x300,0x310,0x320,0x330 */

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 97871bebea90..babaedd242f7 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -63,7 +63,7 @@ MODULE_SUPPORTED_DEVICE("{{OPTi,82C924 (AD1848)},"
 
 static int index = SNDRV_DEFAULT_IDX1;	/* Index 0-MAX */
 static char *id = SNDRV_DEFAULT_STR1;		/* ID for this card */
-//static int enable = SNDRV_DEFAULT_ENABLE1;	/* Enable this card */
+//static bool enable = SNDRV_DEFAULT_ENABLE1;	/* Enable this card */
 #ifdef CONFIG_PNP
 static int isapnp = 1;			/* Enable ISA PnP detection */
 #endif

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 6dbbfa76b440..97871bebea90 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -28,7 +28,7 @@
 #include <linux/isa.h>
 #include <linux/delay.h>
 #include <linux/pnp.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <asm/io.h>
 #include <asm/dma.h>
 #include <sound/core.h>

commit 88e24c3a4b30a6bd361f2b5ce602667a8161b2e8
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Thu Sep 22 16:59:20 2011 +0800

    sound: irq: Remove IRQF_DISABLED
    
    Since commit [e58aa3d2: genirq: Run irq handlers with interrupts disabled],
    We run all interrupt handlers with interrupts disabled
    and we even check and yell when an interrupt handler
    returns with interrupts enabled (see commit [b738a50a:
    genirq: Warn when handler enables interrupts]).
    
    So now this flag is a NOOP and can be removed.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 346e12baa98e..6dbbfa76b440 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -892,7 +892,7 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 #endif
 #ifdef OPTi93X
 	error = request_irq(irq, snd_opti93x_interrupt,
-			    IRQF_DISABLED, DEV_NAME" - WSS", chip);
+			    0, DEV_NAME" - WSS", chip);
 	if (error < 0) {
 		snd_printk(KERN_ERR "opti9xx: can't grab IRQ %d\n", irq);
 		return error;

commit dba8b46992c55946d3b092934f581a343403118f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Sep 13 11:24:41 2011 +0200

    ALSA: mpu401: clean up interrupt specification
    
    The semantics of snd_mpu401_uart_new()'s interrupt parameters are
    somewhat counterintuitive:  To prevent the function from allocating its
    own interrupt, either the irq number must be invalid, or the irq_flags
    parameter must be zero.  At the same time, the irq parameter being
    invalid specifies that the mpu401 code has to work without an interrupt
    allocated by the caller.  This implies that, if there is an interrupt
    and it is allocated by the caller, the irq parameter must be set to
    a valid-looking number which then isn't actually used.
    
    With the removal of IRQF_DISABLED, zero becomes a valid irq_flags value,
    which forces us to handle the parameters differently.
    
    This patch introduces a new flag MPU401_INFO_IRQ_HOOK for when the
    device interrupt is handled by the caller, and makes the allocation of
    the interrupt to depend only on the irq parameter.  As suggested by
    Takashi, the irq_flags parameter was dropped because, when used, it had
    the constant value IRQF_DISABLED.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index c35dc68930dc..346e12baa98e 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -914,7 +914,7 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 		rmidi = NULL;
 	else {
 		error = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
-				mpu_port, 0, mpu_irq, IRQF_DISABLED, &rmidi);
+				mpu_port, 0, mpu_irq, &rmidi);
 		if (error)
 			snd_printk(KERN_WARNING "no MPU-401 device at 0x%lx?\n",
 				   mpu_port);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 4d2d0405bdc7..c35dc68930dc 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -27,7 +27,6 @@
 #include <linux/err.h>
 #include <linux/isa.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
 #include <linux/pnp.h>
 #include <linux/moduleparam.h>
 #include <asm/io.h>

commit 89c0ac7cab2440a771ba1e2ab953186bc9c29786
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Mar 8 09:32:42 2010 -0800

    sound: fix opti92x-ad1848 build
    
    Fix 'else' placement in ifdef block so that build succeeds:
    
    sound/isa/opti9xx/opti92x-ad1848.c:221: error: 'else' without a previous 'if'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index becd90d7536d..4d2d0405bdc7 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -217,8 +217,9 @@ static int __devinit snd_opti9xx_init(struct snd_opti9xx *chip,
 	if (isapnp && chip->mc_base)
 		/* PnP resource gives the least 10 bits */
 		chip->mc_base |= 0xc00;
+	else
 #endif	/* CONFIG_PNP */
-	else {
+	{
 		chip->mc_base = 0xf8c;
 		chip->mc_base_size = opti9xx_mc_size[hardware];
 	}

commit fd8d47351d2e241f3168eeb697ce55cc28c75b78
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Wed Mar 3 19:41:44 2010 +0100

    ALSA: opti92x: use PnP data to select Master Control port
    
    The Master Control port (MC) is available as the last
    PnP resource (OPT005). Use this value instead fo guessing.
    
    Also, add some comments to the code.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index a4af53b5c1cf..becd90d7536d 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -144,12 +144,8 @@ struct snd_opti9xx {
 
 	spinlock_t lock;
 
+	long wss_base;
 	int irq;
-
-#ifdef CONFIG_PNP
-	struct pnp_dev *dev;
-	struct pnp_dev *devmpu;
-#endif	/* CONFIG_PNP */
 };
 
 static int snd_opti9xx_pnp_is_probed;
@@ -159,12 +155,17 @@ static int snd_opti9xx_pnp_is_probed;
 static struct pnp_card_device_id snd_opti9xx_pnpids[] = {
 #ifndef OPTi93X
 	/* OPTi 82C924 */
-	{ .id = "OPT0924", .devs = { { "OPT0000" }, { "OPT0002" } }, .driver_data = 0x0924 },
+	{ .id = "OPT0924",
+	  .devs = { { "OPT0000" }, { "OPT0002" }, { "OPT0005" } },
+	  .driver_data = 0x0924 },
 	/* OPTi 82C925 */
-	{ .id = "OPT0925", .devs = { { "OPT9250" }, { "OPT0002" } }, .driver_data = 0x0925 },
+	{ .id = "OPT0925",
+	  .devs = { { "OPT9250" }, { "OPT0002" }, { "OPT0005" } },
+	  .driver_data = 0x0925 },
 #else
 	/* OPTi 82C931/3 */
-	{ .id = "OPT0931", .devs = { { "OPT9310" }, { "OPT0002" } }, .driver_data = 0x0931 },
+	{ .id = "OPT0931", .devs = { { "OPT9310" }, { "OPT0002" } },
+	  .driver_data = 0x0931 },
 #endif	/* OPTi93X */
 	{ .id = "" }
 };
@@ -207,24 +208,34 @@ static int __devinit snd_opti9xx_init(struct snd_opti9xx *chip,
 	chip->hardware = hardware;
 	strcpy(chip->name, snd_opti9xx_names[hardware]);
 
-	chip->mc_base_size = opti9xx_mc_size[hardware];  
-
 	spin_lock_init(&chip->lock);
 
 	chip->irq = -1;
 
+#ifndef OPTi93X
+#ifdef CONFIG_PNP
+	if (isapnp && chip->mc_base)
+		/* PnP resource gives the least 10 bits */
+		chip->mc_base |= 0xc00;
+#endif	/* CONFIG_PNP */
+	else {
+		chip->mc_base = 0xf8c;
+		chip->mc_base_size = opti9xx_mc_size[hardware];
+	}
+#else
+		chip->mc_base_size = opti9xx_mc_size[hardware];
+#endif
+
 	switch (hardware) {
 #ifndef OPTi93X
 	case OPTi9XX_HW_82C928:
 	case OPTi9XX_HW_82C929:
-		chip->mc_base = 0xf8c;
 		chip->password = (hardware == OPTi9XX_HW_82C928) ? 0xe2 : 0xe3;
 		chip->pwd_reg = 3;
 		break;
 
 	case OPTi9XX_HW_82C924:
 	case OPTi9XX_HW_82C925:
-		chip->mc_base = 0xf8c;
 		chip->password = 0xe5;
 		chip->pwd_reg = 3;
 		break;
@@ -292,7 +303,7 @@ static unsigned char snd_opti9xx_read(struct snd_opti9xx *chip,
 	spin_unlock_irqrestore(&chip->lock, flags);
 	return retval;
 }
-	
+
 static void snd_opti9xx_write(struct snd_opti9xx *chip, unsigned char reg,
 			      unsigned char value)
 {
@@ -341,7 +352,7 @@ static void snd_opti9xx_write(struct snd_opti9xx *chip, unsigned char reg,
 
 
 static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip,
-					   long wss_base,
+					   long port,
 					   int irq, int dma1, int dma2,
 					   long mpu_port, int mpu_irq)
 {
@@ -354,16 +365,23 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip,
 	switch (chip->hardware) {
 #ifndef OPTi93X
 	case OPTi9XX_HW_82C924:
+		/* opti 929 mode (?), OPL3 clock output, audio enable */
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(4), 0xf0, 0xfc);
+		/* enable wave audio */
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x02);
 
 	case OPTi9XX_HW_82C925:
+		/* enable WSS mode */
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);
+		/* OPL3 FM synthesis */
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2), 0x00, 0x20);
+		/* disable Sound Blaster IRQ and DMA */
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(3), 0xf0, 0xff);
 #ifdef CS4231
+		/* cs4231/4248 fix enabled */
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);
 #else
+		/* cs4231/4248 fix disabled */
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x00, 0x02);
 #endif	/* CS4231 */
 		break;
@@ -411,21 +429,26 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip,
 		return -EINVAL;
 	}
 
-	switch (wss_base) {
-	case 0x530:
+	/* PnP resource says it decodes only 10 bits of address */
+	switch (port & 0x3ff) {
+	case 0x130:
+		chip->wss_base = 0x530;
 		wss_base_bits = 0x00;
 		break;
-	case 0x604:
+	case 0x204:
+		chip->wss_base = 0x604;
 		wss_base_bits = 0x03;
 		break;
-	case 0xe80:
+	case 0x280:
+		chip->wss_base = 0xe80;
 		wss_base_bits = 0x01;
 		break;
-	case 0xf40:
+	case 0x340:
+		chip->wss_base = 0xf40;
 		wss_base_bits = 0x02;
 		break;
 	default:
-		snd_printk(KERN_WARNING "WSS port 0x%lx not valid\n", wss_base);
+		snd_printk(KERN_WARNING "WSS port 0x%lx not valid\n", port);
 		goto __skip_base;
 	}
 	snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(1), wss_base_bits << 4, 0x30);
@@ -487,7 +510,7 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip,
 #endif	/* CS4231 || OPTi93X */
 
 #ifndef OPTi93X
-	 outb(irq_bits << 3 | dma_bits, wss_base);
+	 outb(irq_bits << 3 | dma_bits, chip->wss_base);
 #else /* OPTi93X */
 	snd_opti9xx_write(chip, OPTi9XX_MC_REG(3), (irq_bits << 3 | dma_bits));
 #endif /* OPTi93X */
@@ -729,15 +752,15 @@ static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip,
 {
 	struct pnp_dev *pdev;
 	int err;
+	struct pnp_dev *devmpu;
+#ifndef OPTi93X
+	struct pnp_dev *devmc;
+#endif
 
-	chip->dev = pnp_request_card_device(card, pid->devs[0].id, NULL);
-	if (chip->dev == NULL)
+	pdev = pnp_request_card_device(card, pid->devs[0].id, NULL);
+	if (pdev == NULL)
 		return -EBUSY;
 
-	chip->devmpu = pnp_request_card_device(card, pid->devs[1].id, NULL);
-
-	pdev = chip->dev;
-
 	err = pnp_activate_dev(pdev);
 	if (err < 0) {
 		snd_printk(KERN_ERR "AUDIO pnp configure failure: %d\n", err);
@@ -750,9 +773,24 @@ static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip,
 	chip->mc_indir_index = pnp_port_start(pdev, 3) + 2;
 	chip->mc_indir_size = pnp_port_len(pdev, 3) - 2;
 #else
-	if (pid->driver_data != 0x0924)
-		port = pnp_port_start(pdev, 1);
+	devmc = pnp_request_card_device(card, pid->devs[2].id, NULL);
+	if (devmc == NULL)
+		return -EBUSY;
+
+	err = pnp_activate_dev(devmc);
+	if (err < 0) {
+		snd_printk(KERN_ERR "MC pnp configure failure: %d\n", err);
+		return err;
+	}
+
+	port = pnp_port_start(pdev, 1);
 	fm_port = pnp_port_start(pdev, 2) + 8;
+	/*
+	 * The MC(0) is never accessed and card does not
+	 * include it in the PnP resource range. OPTI93x include it.
+	 */
+	chip->mc_base = pnp_port_start(devmc, 0) - 1;
+	chip->mc_base_size = pnp_port_len(devmc, 0) + 1;
 #endif	/* OPTi93X */
 	irq = pnp_irq(pdev, 0);
 	dma1 = pnp_dma(pdev, 0);
@@ -760,16 +798,16 @@ static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip,
 	dma2 = pnp_dma(pdev, 1);
 #endif	/* CS4231 || OPTi93X */
 
-	pdev = chip->devmpu;
-	if (pdev && mpu_port > 0) {
-		err = pnp_activate_dev(pdev);
+	devmpu = pnp_request_card_device(card, pid->devs[1].id, NULL);
+
+	if (devmpu && mpu_port > 0) {
+		err = pnp_activate_dev(devmpu);
 		if (err < 0) {
-			snd_printk(KERN_ERR "AUDIO pnp configure failure\n");
+			snd_printk(KERN_ERR "MPU401 pnp configure failure\n");
 			mpu_port = -1;
-			chip->devmpu = NULL;
 		} else {
-			mpu_port = pnp_port_start(pdev, 0);
-			mpu_irq = pnp_irq(pdev, 0);
+			mpu_port = pnp_port_start(devmpu, 0);
+			mpu_irq = pnp_irq(devmpu, 0);
 		}
 	}
 	return pid->driver_data;
@@ -824,7 +862,7 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 	if (error)
 		return error;
 
-	error = snd_wss_create(card, port + 4, -1, irq, dma1, xdma2,
+	error = snd_wss_create(card, chip->wss_base + 4, -1, irq, dma1, xdma2,
 #ifdef OPTi93X
 			       WSS_HW_OPTI93X, WSS_HWSHARE_IRQ,
 #else
@@ -865,10 +903,11 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 	sprintf(card->shortname, "OPTi %s", card->driver);
 #if defined(CS4231) || defined(OPTi93X)
 	sprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d&%d",
-		card->shortname, pcm->name, port + 4, irq, dma1, xdma2);
+		card->shortname, pcm->name,
+		chip->wss_base + 4, irq, dma1, xdma2);
 #else
 	sprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d",
-		card->shortname, pcm->name, port + 4, irq, dma1);
+		card->shortname, pcm->name, chip->wss_base + 4, irq, dma1);
 #endif	/* CS4231 || OPTi93X */
 
 	if (mpu_port <= 0 || mpu_port == SNDRV_AUTO_PORT)
@@ -1062,9 +1101,6 @@ static int __devinit snd_opti9xx_pnp_probe(struct pnp_card_link *pcard,
 		snd_card_free(card);
 		return error;
 	}
-	if (hw <= OPTi9XX_HW_82C930)
-		chip->mc_base -= 0x80;
-
 	error = snd_opti9xx_read_check(chip);
 	if (error) {
 		snd_printk(KERN_ERR "OPTI chip not found\n");

commit b89371621e5bedc84498ced2c5c33976bd1b2f64
Merge: 63978ab3e3e9 74c2b45b714e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 14 18:01:56 2009 +0100

    Merge branch 'next/isa' into topic/misc

commit e9d0a803c127e2e30afb0df780ccb3af4e2adb28
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Sat Dec 12 09:51:03 2009 +0100

    ALSA: opti93x: use dB scale for mixer controls
    
    Add dB scale for mixer controls. Fix dB scale for
    Master Volume control.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index ea4a67120468..b0ea310c87de 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -547,32 +547,40 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip,
 
 #ifdef OPTi93X
 
-static const DECLARE_TLV_DB_SCALE(db_scale_6bit, -9450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_5bit_3db_step, -9300, 300, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_5bit, -4650, 150, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_4bit_12db_max, -3300, 300, 0);
 
 static struct snd_kcontrol_new snd_opti93x_controls[] = {
 WSS_DOUBLE("Master Playback Switch", 0,
 		OPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 7, 7, 1, 1),
 WSS_DOUBLE_TLV("Master Playback Volume", 0,
 		OPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 1, 1, 31, 1,
-		db_scale_6bit),
-WSS_DOUBLE("PCM Playback Volume", 0,
-		CS4231_LEFT_OUTPUT, CS4231_RIGHT_OUTPUT, 0, 0, 31, 1),
-WSS_DOUBLE("FM Playback Volume", 0,
-		CS4231_AUX2_LEFT_INPUT, CS4231_AUX2_RIGHT_INPUT, 1, 1, 15, 1),
+		db_scale_5bit_3db_step),
+WSS_DOUBLE_TLV("PCM Playback Volume", 0,
+		CS4231_LEFT_OUTPUT, CS4231_RIGHT_OUTPUT, 0, 0, 31, 1,
+		db_scale_5bit),
+WSS_DOUBLE_TLV("FM Playback Volume", 0,
+		CS4231_AUX2_LEFT_INPUT, CS4231_AUX2_RIGHT_INPUT, 1, 1, 15, 1,
+		db_scale_4bit_12db_max),
 WSS_DOUBLE("Line Playback Switch", 0,
 		CS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 7, 7, 1, 1),
-WSS_DOUBLE("Line Playback Volume", 0,
-		CS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 0, 0, 15, 1),
+WSS_DOUBLE_TLV("Line Playback Volume", 0,
+		CS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 0, 0, 15, 1,
+		db_scale_4bit_12db_max),
 WSS_DOUBLE("Mic Playback Switch", 0,
 		OPTi93X_MIC_LEFT_INPUT, OPTi93X_MIC_RIGHT_INPUT, 7, 7, 1, 1),
-WSS_DOUBLE("Mic Playback Volume", 0,
-		OPTi93X_MIC_LEFT_INPUT, OPTi93X_MIC_RIGHT_INPUT, 1, 1, 15, 1),
-WSS_DOUBLE("CD Playback Volume", 0,
-		CS4231_AUX1_LEFT_INPUT, CS4231_AUX1_RIGHT_INPUT, 1, 1, 15, 1),
+WSS_DOUBLE_TLV("Mic Playback Volume", 0,
+		OPTi93X_MIC_LEFT_INPUT, OPTi93X_MIC_RIGHT_INPUT, 1, 1, 15, 1,
+		db_scale_4bit_12db_max),
+WSS_DOUBLE_TLV("CD Playback Volume", 0,
+		CS4231_AUX1_LEFT_INPUT, CS4231_AUX1_RIGHT_INPUT, 1, 1, 15, 1,
+		db_scale_4bit_12db_max),
 WSS_DOUBLE("Aux Playback Switch", 0,
 		OPTi931_AUX_LEFT_INPUT, OPTi931_AUX_RIGHT_INPUT, 7, 7, 1, 1),
-WSS_DOUBLE("Aux Playback Volume", 0,
-		OPTi931_AUX_LEFT_INPUT, OPTi931_AUX_RIGHT_INPUT, 1, 1, 15, 1),
+WSS_DOUBLE_TLV("Aux Playback Volume", 0,
+		OPTi931_AUX_LEFT_INPUT, OPTi931_AUX_RIGHT_INPUT, 1, 1, 15, 1,
+		db_scale_4bit_12db_max),
 };
 
 static int __devinit snd_opti93x_mixer(struct snd_wss *chip)

commit b2e8d7dab9d82be3851b8cbcc1ab64b1b2575844
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Thu Dec 10 20:40:18 2009 +0100

    ALSA: opti93x: move controls definitions to opti93x driver
    
    Move OPTi93x controls definitions to the opti93x driver
    from the common wss-lib library module. These controls
    are used only by the opti93x driver.
    
    Also, fix capture source names. They are the same as
    opl3sa2 names.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 106be6e471f7..ea4a67120468 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -33,6 +33,7 @@
 #include <asm/io.h>
 #include <asm/dma.h>
 #include <sound/core.h>
+#include <sound/tlv.h>
 #include <sound/wss.h>
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
@@ -546,6 +547,85 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip,
 
 #ifdef OPTi93X
 
+static const DECLARE_TLV_DB_SCALE(db_scale_6bit, -9450, 150, 0);
+
+static struct snd_kcontrol_new snd_opti93x_controls[] = {
+WSS_DOUBLE("Master Playback Switch", 0,
+		OPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 7, 7, 1, 1),
+WSS_DOUBLE_TLV("Master Playback Volume", 0,
+		OPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 1, 1, 31, 1,
+		db_scale_6bit),
+WSS_DOUBLE("PCM Playback Volume", 0,
+		CS4231_LEFT_OUTPUT, CS4231_RIGHT_OUTPUT, 0, 0, 31, 1),
+WSS_DOUBLE("FM Playback Volume", 0,
+		CS4231_AUX2_LEFT_INPUT, CS4231_AUX2_RIGHT_INPUT, 1, 1, 15, 1),
+WSS_DOUBLE("Line Playback Switch", 0,
+		CS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 7, 7, 1, 1),
+WSS_DOUBLE("Line Playback Volume", 0,
+		CS4231_LEFT_LINE_IN, CS4231_RIGHT_LINE_IN, 0, 0, 15, 1),
+WSS_DOUBLE("Mic Playback Switch", 0,
+		OPTi93X_MIC_LEFT_INPUT, OPTi93X_MIC_RIGHT_INPUT, 7, 7, 1, 1),
+WSS_DOUBLE("Mic Playback Volume", 0,
+		OPTi93X_MIC_LEFT_INPUT, OPTi93X_MIC_RIGHT_INPUT, 1, 1, 15, 1),
+WSS_DOUBLE("CD Playback Volume", 0,
+		CS4231_AUX1_LEFT_INPUT, CS4231_AUX1_RIGHT_INPUT, 1, 1, 15, 1),
+WSS_DOUBLE("Aux Playback Switch", 0,
+		OPTi931_AUX_LEFT_INPUT, OPTi931_AUX_RIGHT_INPUT, 7, 7, 1, 1),
+WSS_DOUBLE("Aux Playback Volume", 0,
+		OPTi931_AUX_LEFT_INPUT, OPTi931_AUX_RIGHT_INPUT, 1, 1, 15, 1),
+};
+
+static int __devinit snd_opti93x_mixer(struct snd_wss *chip)
+{
+	struct snd_card *card;
+	unsigned int idx;
+	struct snd_ctl_elem_id id1, id2;
+	int err;
+
+	if (snd_BUG_ON(!chip || !chip->pcm))
+		return -EINVAL;
+
+	card = chip->card;
+
+	strcpy(card->mixername, chip->pcm->name);
+
+	memset(&id1, 0, sizeof(id1));
+	memset(&id2, 0, sizeof(id2));
+	id1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	/* reassign AUX0 switch to CD */
+	strcpy(id1.name, "Aux Playback Switch");
+	strcpy(id2.name, "CD Playback Switch");
+	err = snd_ctl_rename_id(card, &id1, &id2);
+	if (err < 0) {
+		snd_printk(KERN_ERR "Cannot rename opti93x control\n");
+		return err;
+	}
+	/* reassign AUX1 switch to FM */
+	strcpy(id1.name, "Aux Playback Switch"); id1.index = 1;
+	strcpy(id2.name, "FM Playback Switch");
+	err = snd_ctl_rename_id(card, &id1, &id2);
+	if (err < 0) {
+		snd_printk(KERN_ERR "Cannot rename opti93x control\n");
+		return err;
+	}
+	/* remove AUX1 volume */
+	strcpy(id1.name, "Aux Playback Volume"); id1.index = 1;
+	snd_ctl_remove_id(card, &id1);
+
+	/* Replace WSS volume controls with OPTi93x volume controls */
+	id1.index = 0;
+	for (idx = 0; idx < ARRAY_SIZE(snd_opti93x_controls); idx++) {
+		strcpy(id1.name, snd_opti93x_controls[idx].name);
+		snd_ctl_remove_id(card, &id1);
+
+		err = snd_ctl_add(card,
+				snd_ctl_new1(&snd_opti93x_controls[idx], chip));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
 static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id)
 {
 	struct snd_wss *codec = dev_id;
@@ -752,6 +832,11 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 	error = snd_wss_mixer(codec);
 	if (error < 0)
 		return error;
+#ifdef OPTi93X
+	error = snd_opti93x_mixer(codec);
+	if (error < 0)
+		return error;
+#endif
 #ifdef CS4231
 	error = snd_wss_timer(codec, 0, &timer);
 	if (error < 0)

commit 5f60e496083efb01893a899b6885828330db971f
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Wed Dec 9 20:12:43 2009 +0100

    ALSA: opti93x: fix irq releasing if the irq cannot be allocated
    
    Use the chip->irq to check if the irq should be released so the irq is not released
    if it has not been allocated.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 8c88401c79bc..d8eac3f28947 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -548,10 +548,13 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip,
 
 static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id)
 {
-	struct snd_wss *codec = dev_id;
-	struct snd_opti9xx *chip = codec->card->private_data;
+	struct snd_opti9xx *chip = dev_id;
+	struct snd_wss *codec = chip->codec;
 	unsigned char status;
 
+	if (!codec)
+		return IRQ_HANDLED;
+
 	status = snd_opti9xx_read(chip, OPTi9XX_MC_REG(11));
 	if ((status & OPTi93X_IRQ_PLAYBACK) && codec->playback_substream)
 		snd_pcm_period_elapsed(codec->playback_substream);
@@ -691,10 +694,9 @@ static void snd_card_opti9xx_free(struct snd_card *card)
 
 	if (chip) {
 #ifdef OPTi93X
-		struct snd_wss *codec = chip->codec;
-		if (codec && codec->irq > 0) {
-			disable_irq(codec->irq);
-			free_irq(codec->irq, codec);
+		if (chip->irq > 0) {
+			disable_irq(chip->irq);
+			free_irq(chip->irq, chip);
 		}
 		release_and_free_resource(chip->res_mc_indir);
 #endif
@@ -759,9 +761,9 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 #endif
 #ifdef OPTi93X
 	error = request_irq(irq, snd_opti93x_interrupt,
-			    IRQF_DISABLED, DEV_NAME" - WSS", codec);
+			    IRQF_DISABLED, DEV_NAME" - WSS", chip);
 	if (error < 0) {
-		snd_printk(KERN_ERR "opti9xx: can't grab IRQ %d\n", chip->irq);
+		snd_printk(KERN_ERR "opti9xx: can't grab IRQ %d\n", irq);
 		return error;
 	}
 #endif

commit 78f1ae193d1662c22cfebb916e788e1ca896c0fe
Merge: fa395aaec823 84194883bcf8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 9 19:52:13 2009 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6:
      ALSA: ice1724 - aureon - modify WM8770 Master & DAC volume
      ALSA: hda/realtek: quirk for D945GCLF2 mainboard
      ALSA: hda - Terradici HDA controllers does not support 64-bit mode
      ALSA: document: Add direct git link to grub hda-analyzer
      ALSA: radio/sound/miro: fix build, cleanup depends/selects
      ALSA: hda - Generalize EAPD inversion check in patch_analog.c
      ASoC: Wrong variable returned on error
      ALSA: snd-usb-us122l: add product IDs of US-122MKII and US-144MKII
      ALSA: hda - Exclude unusable ADCs for ALC88x
      ALSA: hda - Add missing Line-Out and PCM switches as slave
      ALSA: hda - iMac 9,1 sound patch.
      ALSA: opti93x: set MC indirect registers base from PnP data

commit 4ef58d4e2ad1fa2a3e5bbf41af2284671fca8cf8
Merge: f6c4c8195b5e d014d043869c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 9 19:43:33 2009 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (42 commits)
      tree-wide: fix misspelling of "definition" in comments
      reiserfs: fix misspelling of "journaled"
      doc: Fix a typo in slub.txt.
      inotify: remove superfluous return code check
      hdlc: spelling fix in find_pvc() comment
      doc: fix regulator docs cut-and-pasteism
      mtd: Fix comment in Kconfig
      doc: Fix IRQ chip docs
      tree-wide: fix assorted typos all over the place
      drivers/ata/libata-sff.c: comment spelling fixes
      fix typos/grammos in Documentation/edac.txt
      sysctl: add missing comments
      fs/debugfs/inode.c: fix comment typos
      sgivwfb: Make use of ARRAY_SIZE.
      sky2: fix sky2_link_down copy/paste comment error
      tree-wide: fix typos "couter" -> "counter"
      tree-wide: fix typos "offest" -> "offset"
      fix kerneldoc for set_irq_msi()
      spidev: fix double "of of" in comment
      comment typo fix: sybsystem -> subsystem
      ...

commit e6960e194a7dfb8197822225e04eca95fbd61a7f
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Fri Dec 4 18:30:18 2009 +0100

    ALSA: opti93x: set MC indirect registers base from PnP data
    
    The PnP data on the OPTI931 and OPTI933 contains io port
    range for the MC indirect registers. Use the PnP range
    instead of hardwired value 0xE0E.
    
    Also, request region of MC indirect registers so it is
    marked as used to other drivers (this was missing previously).
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index d08c38906449..8c88401c79bc 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -135,6 +135,8 @@ struct snd_opti9xx {
 	unsigned long mc_base_size;
 #ifdef OPTi93X
 	unsigned long mc_indir_index;
+	unsigned long mc_indir_size;
+	struct resource *res_mc_indir;
 	struct snd_wss *codec;
 #endif	/* OPTi93X */
 	unsigned long pwd_reg;
@@ -231,7 +233,10 @@ static int __devinit snd_opti9xx_init(struct snd_opti9xx *chip,
 	case OPTi9XX_HW_82C931:
 	case OPTi9XX_HW_82C933:
 		chip->mc_base = (hardware == OPTi9XX_HW_82C930) ? 0xf8f : 0xf8d;
-		chip->mc_indir_index = 0xe0e;
+		if (!chip->mc_indir_index) {
+			chip->mc_indir_index = 0xe0e;
+			chip->mc_indir_size = 2;
+		}
 		chip->password = 0xe4;
 		chip->pwd_reg = 0;
 		break;
@@ -560,57 +565,69 @@ static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id)
 
 #endif /* OPTi93X */
 
-static int __devinit snd_card_opti9xx_detect(struct snd_card *card,
-					     struct snd_opti9xx *chip)
+static int __devinit snd_opti9xx_read_check(struct snd_opti9xx *chip)
 {
-	int i, err;
+	unsigned char value;
+#ifdef OPTi93X
+	unsigned long flags;
+#endif
 
+	chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size,
+					   "OPTi9xx MC");
+	if (chip->res_mc_base == NULL)
+		return -EBUSY;
 #ifndef OPTi93X
-	for (i = OPTi9XX_HW_82C928; i < OPTi9XX_HW_82C930; i++) {
-		unsigned char value;
+	value = snd_opti9xx_read(chip, OPTi9XX_MC_REG(1));
+	if (value != 0xff && value != inb(chip->mc_base + OPTi9XX_MC_REG(1)))
+		if (value == snd_opti9xx_read(chip, OPTi9XX_MC_REG(1)))
+			return 0;
+#else	/* OPTi93X */
+	chip->res_mc_indir = request_region(chip->mc_indir_index,
+					    chip->mc_indir_size,
+					    "OPTi93x MC");
+	if (chip->res_mc_indir == NULL)
+		return -EBUSY;
 
-		if ((err = snd_opti9xx_init(chip, i)) < 0)
-			return err;
+	spin_lock_irqsave(&chip->lock, flags);
+	outb(chip->password, chip->mc_base + chip->pwd_reg);
+	outb(((chip->mc_indir_index & 0x1f0) >> 4), chip->mc_base);
+	spin_unlock_irqrestore(&chip->lock, flags);
 
-		if ((chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size, "OPTi9xx MC")) == NULL)
-			continue;
+	value = snd_opti9xx_read(chip, OPTi9XX_MC_REG(7));
+	snd_opti9xx_write(chip, OPTi9XX_MC_REG(7), 0xff - value);
+	if (snd_opti9xx_read(chip, OPTi9XX_MC_REG(7)) == 0xff - value)
+		return 0;
 
-		value = snd_opti9xx_read(chip, OPTi9XX_MC_REG(1));
-		if ((value != 0xff) && (value != inb(chip->mc_base + 1)))
-			if (value == snd_opti9xx_read(chip, OPTi9XX_MC_REG(1)))
-				return 1;
+	release_and_free_resource(chip->res_mc_indir);
+	chip->res_mc_indir = NULL;
+#endif	/* OPTi93X */
+	release_and_free_resource(chip->res_mc_base);
+	chip->res_mc_base = NULL;
 
-		release_and_free_resource(chip->res_mc_base);
-		chip->res_mc_base = NULL;
+	return -ENODEV;
+}
 
-	}
-#else	/* OPTi93X */
-	for (i = OPTi9XX_HW_82C931; i >= OPTi9XX_HW_82C930; i--) {
-		unsigned long flags;
-		unsigned char value;
+static int __devinit snd_card_opti9xx_detect(struct snd_card *card,
+					     struct snd_opti9xx *chip)
+{
+	int i, err;
 
-		if ((err = snd_opti9xx_init(chip, i)) < 0)
+#ifndef OPTi93X
+	for (i = OPTi9XX_HW_82C928; i < OPTi9XX_HW_82C930; i++) {
+#else
+	for (i = OPTi9XX_HW_82C931; i >= OPTi9XX_HW_82C930; i--) {
+#endif
+		err = snd_opti9xx_init(chip, i);
+		if (err < 0)
 			return err;
 
-		if ((chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size, "OPTi9xx MC")) == NULL)
-			continue;
-
-		spin_lock_irqsave(&chip->lock, flags);
-		outb(chip->password, chip->mc_base + chip->pwd_reg);
-		outb(((chip->mc_indir_index & (1 << 8)) >> 4) |
-			((chip->mc_indir_index & 0xf0) >> 4), chip->mc_base);
-		spin_unlock_irqrestore(&chip->lock, flags);
-
-		value = snd_opti9xx_read(chip, OPTi9XX_MC_REG(7));
-		snd_opti9xx_write(chip, OPTi9XX_MC_REG(7), 0xff - value);
-		if (snd_opti9xx_read(chip, OPTi9XX_MC_REG(7)) == 0xff - value)
+		err = snd_opti9xx_read_check(chip);
+		if (err == 0)
 			return 1;
-
-		release_and_free_resource(chip->res_mc_base);
-		chip->res_mc_base = NULL;
+#ifdef OPTi93X
+		chip->mc_indir_index = 0;
+#endif
 	}
-#endif	/* OPTi93X */
-
 	return -ENODEV;
 }
 
@@ -639,6 +656,8 @@ static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip,
 #ifdef OPTi93X
 	port = pnp_port_start(pdev, 0) - 4;
 	fm_port = pnp_port_start(pdev, 1) + 8;
+	chip->mc_indir_index = pnp_port_start(pdev, 3) + 2;
+	chip->mc_indir_size = pnp_port_len(pdev, 3) - 2;
 #else
 	if (pid->driver_data != 0x0924)
 		port = pnp_port_start(pdev, 1);
@@ -669,7 +688,7 @@ static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip,
 static void snd_card_opti9xx_free(struct snd_card *card)
 {
 	struct snd_opti9xx *chip = card->private_data;
-        
+
 	if (chip) {
 #ifdef OPTi93X
 		struct snd_wss *codec = chip->codec;
@@ -677,6 +696,7 @@ static void snd_card_opti9xx_free(struct snd_card *card)
 			disable_irq(codec->irq);
 			free_irq(codec->irq, codec);
 		}
+		release_and_free_resource(chip->res_mc_indir);
 #endif
 		release_and_free_resource(chip->res_mc_base);
 	}
@@ -696,11 +716,6 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 	struct snd_rawmidi *rmidi;
 	struct snd_hwdep *synth;
 
-	if (! chip->res_mc_base &&
-	    (chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size,
-						"OPTi9xx MC")) == NULL)
-		return -ENOMEM;
-
 #if defined(CS4231) || defined(OPTi93X)
 	xdma2 = dma2;
 #else
@@ -954,6 +969,13 @@ static int __devinit snd_opti9xx_pnp_probe(struct pnp_card_link *pcard,
 	}
 	if (hw <= OPTi9XX_HW_82C930)
 		chip->mc_base -= 0x80;
+
+	error = snd_opti9xx_read_check(chip);
+	if (error) {
+		snd_printk(KERN_ERR "OPTI chip not found\n");
+		snd_card_free(card);
+		return error;
+	}
 	snd_card_set_dev(card, &pcard->card->dev);
 	if ((error = snd_opti9xx_probe(card)) < 0) {
 		snd_card_free(card);

commit af901ca181d92aac3a7dc265144a9081a86d8f39
Author: Andr Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:05 2009 -0200

    tree-wide: fix assorted typos all over the place
    
    That is "success", "unknown", "through", "performance", "[re|un]mapping"
    , "access", "default", "reasonable", "[con]currently", "temperature"
    , "channel", "[un]used", "application", "example","hierarchy", "therefore"
    , "[over|under]flow", "contiguous", "threshold", "enough" and others.
    
    Signed-off-by: Andr Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 5cd555325b9d..848007508ffd 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -185,7 +185,7 @@ MODULE_DEVICE_TABLE(pnp_card, snd_opti9xx_pnpids);
 #endif
 
 static char * snd_opti9xx_names[] = {
-	"unkown",
+	"unknown",
 	"82C928",	"82C929",
 	"82C924",	"82C925",
 	"82C930",	"82C931",	"82C933"

commit d8ea23931ce83b56801976e6f1fa893462c1c477
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Wed Dec 2 23:27:12 2009 +0100

    ALSA: opti9xx: remove snd_opti9xx fields
    
    Remove snd_opti9xx fields which are indirect arguments to
    the snd_opti9xx_configure(). Pass these values as function
    arguments.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 5cd555325b9d..d08c38906449 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -141,15 +141,7 @@ struct snd_opti9xx {
 
 	spinlock_t lock;
 
-	long wss_base;
 	int irq;
-	int dma1;
-	int dma2;
-
-	long fm_port;
-
-	long mpu_port;
-	int mpu_irq;
 
 #ifdef CONFIG_PNP
 	struct pnp_dev *dev;
@@ -216,13 +208,7 @@ static int __devinit snd_opti9xx_init(struct snd_opti9xx *chip,
 
 	spin_lock_init(&chip->lock);
 
-	chip->wss_base = -1;
 	chip->irq = -1;
-	chip->dma1 = -1;
-	chip->dma2 = -1;
-	chip->fm_port = -1;
-	chip->mpu_port = -1;
-	chip->mpu_irq = -1;
 
 	switch (hardware) {
 #ifndef OPTi93X
@@ -348,7 +334,10 @@ static void snd_opti9xx_write(struct snd_opti9xx *chip, unsigned char reg,
 		(snd_opti9xx_read(chip, reg) & ~(mask)) | ((value) & (mask)))
 
 
-static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
+static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip,
+					   long wss_base,
+					   int irq, int dma1, int dma2,
+					   long mpu_port, int mpu_irq)
 {
 	unsigned char wss_base_bits;
 	unsigned char irq_bits;
@@ -416,7 +405,7 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 		return -EINVAL;
 	}
 
-	switch (chip->wss_base) {
+	switch (wss_base) {
 	case 0x530:
 		wss_base_bits = 0x00;
 		break;
@@ -430,14 +419,13 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 		wss_base_bits = 0x02;
 		break;
 	default:
-		snd_printk(KERN_WARNING "WSS port 0x%lx not valid\n",
-			   chip->wss_base);
+		snd_printk(KERN_WARNING "WSS port 0x%lx not valid\n", wss_base);
 		goto __skip_base;
 	}
 	snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(1), wss_base_bits << 4, 0x30);
 
 __skip_base:
-	switch (chip->irq) {
+	switch (irq) {
 //#ifdef OPTi93X
 	case 5:
 		irq_bits = 0x05;
@@ -456,11 +444,11 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 		irq_bits = 0x04;
 		break;
 	default:
-		snd_printk(KERN_WARNING "WSS irq # %d not valid\n", chip->irq);
+		snd_printk(KERN_WARNING "WSS irq # %d not valid\n", irq);
 		goto __skip_resources;
 	}
 
-	switch (chip->dma1) {
+	switch (dma1) {
 	case 0:
 		dma_bits = 0x01;
 		break;
@@ -471,38 +459,36 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 		dma_bits = 0x03;
 		break;
 	default:
-		snd_printk(KERN_WARNING "WSS dma1 # %d not valid\n",
-			   chip->dma1);
+		snd_printk(KERN_WARNING "WSS dma1 # %d not valid\n", dma1);
 		goto __skip_resources;
 	}
 
 #if defined(CS4231) || defined(OPTi93X)
-	if (chip->dma1 == chip->dma2) {
+	if (dma1 == dma2) {
 		snd_printk(KERN_ERR "don't want to share dmas\n");
 		return -EBUSY;
 	}
 
-	switch (chip->dma2) {
+	switch (dma2) {
 	case 0:
 	case 1:
 		break;
 	default:
-		snd_printk(KERN_WARNING "WSS dma2 # %d not valid\n",
-			   chip->dma2);
+		snd_printk(KERN_WARNING "WSS dma2 # %d not valid\n", dma2);
 		goto __skip_resources;
 	}
 	dma_bits |= 0x04;
 #endif	/* CS4231 || OPTi93X */
 
 #ifndef OPTi93X
-	 outb(irq_bits << 3 | dma_bits, chip->wss_base);
+	 outb(irq_bits << 3 | dma_bits, wss_base);
 #else /* OPTi93X */
 	snd_opti9xx_write(chip, OPTi9XX_MC_REG(3), (irq_bits << 3 | dma_bits));
 #endif /* OPTi93X */
 
 __skip_resources:
 	if (chip->hardware > OPTi9XX_HW_82C928) {
-		switch (chip->mpu_port) {
+		switch (mpu_port) {
 		case 0:
 		case -1:
 			break;
@@ -520,12 +506,11 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 			break;
 		default:
 			snd_printk(KERN_WARNING
-				   "MPU-401 port 0x%lx not valid\n",
-				chip->mpu_port);
+				   "MPU-401 port 0x%lx not valid\n", mpu_port);
 			goto __skip_mpu;
 		}
 
-		switch (chip->mpu_irq) {
+		switch (mpu_irq) {
 		case 5:
 			mpu_irq_bits = 0x02;
 			break;
@@ -540,12 +525,12 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 			break;
 		default:
 			snd_printk(KERN_WARNING "MPU-401 irq # %d not valid\n",
-				chip->mpu_irq);
+				mpu_irq);
 			goto __skip_mpu;
 		}
 
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6),
-			(chip->mpu_port <= 0) ? 0x00 :
+			(mpu_port <= 0) ? 0x00 :
 				0x80 | mpu_port_bits << 5 | mpu_irq_bits << 3,
 			0xf8);
 	}
@@ -701,6 +686,7 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 {
 	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
 	int error;
+	int xdma2;
 	struct snd_opti9xx *chip = card->private_data;
 	struct snd_wss *codec;
 #ifdef CS4231
@@ -715,31 +701,25 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 						"OPTi9xx MC")) == NULL)
 		return -ENOMEM;
 
-	chip->wss_base = port;
-	chip->fm_port = fm_port;
-	chip->mpu_port = mpu_port;
-	chip->irq = irq;
-	chip->mpu_irq = mpu_irq;
-	chip->dma1 = dma1;
 #if defined(CS4231) || defined(OPTi93X)
-	chip->dma2 = dma2;
+	xdma2 = dma2;
 #else
-	chip->dma2 = -1;
+	xdma2 = -1;
 #endif
 
-	if (chip->wss_base == SNDRV_AUTO_PORT) {
-		chip->wss_base = snd_legacy_find_free_ioport(possible_ports, 4);
-		if (chip->wss_base < 0) {
+	if (port == SNDRV_AUTO_PORT) {
+		port = snd_legacy_find_free_ioport(possible_ports, 4);
+		if (port < 0) {
 			snd_printk(KERN_ERR "unable to find a free WSS port\n");
 			return -EBUSY;
 		}
 	}
-	error = snd_opti9xx_configure(chip);
+	error = snd_opti9xx_configure(chip, port, irq, dma1, xdma2,
+				      mpu_port, mpu_irq);
 	if (error)
 		return error;
 
-	error = snd_wss_create(card, chip->wss_base + 4, -1,
-			       chip->irq, chip->dma1, chip->dma2,
+	error = snd_wss_create(card, port + 4, -1, irq, dma1, xdma2,
 #ifdef OPTi93X
 			       WSS_HW_OPTI93X, WSS_HWSHARE_IRQ,
 #else
@@ -763,35 +743,35 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 		return error;
 #endif
 #ifdef OPTi93X
-	error = request_irq(chip->irq, snd_opti93x_interrupt,
+	error = request_irq(irq, snd_opti93x_interrupt,
 			    IRQF_DISABLED, DEV_NAME" - WSS", codec);
 	if (error < 0) {
 		snd_printk(KERN_ERR "opti9xx: can't grab IRQ %d\n", chip->irq);
 		return error;
 	}
 #endif
+	chip->irq = irq;
 	strcpy(card->driver, chip->name);
 	sprintf(card->shortname, "OPTi %s", card->driver);
 #if defined(CS4231) || defined(OPTi93X)
 	sprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d&%d",
-		card->shortname, pcm->name, chip->wss_base + 4,
-		chip->irq, chip->dma1, chip->dma2);
+		card->shortname, pcm->name, port + 4, irq, dma1, xdma2);
 #else
 	sprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d",
-		card->shortname, pcm->name, chip->wss_base + 4,
-		chip->irq, chip->dma1);
+		card->shortname, pcm->name, port + 4, irq, dma1);
 #endif	/* CS4231 || OPTi93X */
 
-	if (chip->mpu_port <= 0 || chip->mpu_port == SNDRV_AUTO_PORT)
+	if (mpu_port <= 0 || mpu_port == SNDRV_AUTO_PORT)
 		rmidi = NULL;
-	else
-		if ((error = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
-				chip->mpu_port, 0, chip->mpu_irq, IRQF_DISABLED,
-				&rmidi)))
+	else {
+		error = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
+				mpu_port, 0, mpu_irq, IRQF_DISABLED, &rmidi);
+		if (error)
 			snd_printk(KERN_WARNING "no MPU-401 device at 0x%lx?\n",
-				   chip->mpu_port);
+				   mpu_port);
+	}
 
-	if (chip->fm_port > 0 && chip->fm_port != SNDRV_AUTO_PORT) {
+	if (fm_port > 0 && fm_port != SNDRV_AUTO_PORT) {
 		struct snd_opl3 *opl3 = NULL;
 #ifndef OPTi93X
 		if (chip->hardware == OPTi9XX_HW_82C928 ||
@@ -801,9 +781,7 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 			/* assume we have an OPL4 */
 			snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2),
 					       0x20, 0x20);
-			if (snd_opl4_create(card,
-					    chip->fm_port,
-					    chip->fm_port - 8,
+			if (snd_opl4_create(card, fm_port, fm_port - 8,
 					    2, &opl3, &opl4) < 0) {
 				/* no luck, use OPL3 instead */
 				snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2),
@@ -811,12 +789,10 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 			}
 		}
 #endif	/* !OPTi93X */
-		if (!opl3 && snd_opl3_create(card,
-					     chip->fm_port,
-					     chip->fm_port + 2,
+		if (!opl3 && snd_opl3_create(card, fm_port, fm_port + 2,
 					     OPL3_HW_AUTO, 0, &opl3) < 0) {
 			snd_printk(KERN_WARNING "no OPL device at 0x%lx-0x%lx\n",
-				   chip->fm_port, chip->fm_port + 4 - 1);
+				   fm_port, fm_port + 4 - 1);
 		}
 		if (opl3) {
 			error = snd_opl3_hwdep_new(opl3, 0, 1, &synth);

commit 96cf45cf559be375de29dd45afc50fa8946fb2aa
Merge: 4c9f1d3ed7e5 b1a0aac05f04
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 16 23:03:57 2009 +0100

    Merge branch 'topic/snd_card_new-err' into topic/cs423x-merge

commit 4c9f1d3ed7e5f910b66dc4d1456cfac17e58cf0e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 15:47:51 2009 +0100

    ALSA: isa/*: Add missing KERN_* prefix to printk
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 5deb7e69a029..d5bc0e03132a 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -252,7 +252,7 @@ static int __devinit snd_opti9xx_init(struct snd_opti9xx *chip,
 #endif	/* OPTi93X */
 
 	default:
-		snd_printk("chip %d not supported\n", hardware);
+		snd_printk(KERN_ERR "chip %d not supported\n", hardware);
 		return -ENODEV;
 	}
 	return 0;
@@ -294,7 +294,7 @@ static unsigned char snd_opti9xx_read(struct snd_opti9xx *chip,
 #endif	/* OPTi93X */
 
 	default:
-		snd_printk("chip %d not supported\n", chip->hardware);
+		snd_printk(KERN_ERR "chip %d not supported\n", chip->hardware);
 	}
 
 	spin_unlock_irqrestore(&chip->lock, flags);
@@ -336,7 +336,7 @@ static void snd_opti9xx_write(struct snd_opti9xx *chip, unsigned char reg,
 #endif	/* OPTi93X */
 
 	default:
-		snd_printk("chip %d not supported\n", chip->hardware);
+		snd_printk(KERN_ERR "chip %d not supported\n", chip->hardware);
 	}
 
 	spin_unlock_irqrestore(&chip->lock, flags);
@@ -412,7 +412,7 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 #endif	/* OPTi93X */
 
 	default:
-		snd_printk("chip %d not supported\n", chip->hardware);
+		snd_printk(KERN_ERR "chip %d not supported\n", chip->hardware);
 		return -EINVAL;
 	}
 
@@ -430,7 +430,8 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 		wss_base_bits = 0x02;
 		break;
 	default:
-		snd_printk("WSS port 0x%lx not valid\n", chip->wss_base);
+		snd_printk(KERN_WARNING "WSS port 0x%lx not valid\n",
+			   chip->wss_base);
 		goto __skip_base;
 	}
 	snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(1), wss_base_bits << 4, 0x30);
@@ -455,7 +456,7 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 		irq_bits = 0x04;
 		break;
 	default:
-		snd_printk("WSS irq # %d not valid\n", chip->irq);
+		snd_printk(KERN_WARNING "WSS irq # %d not valid\n", chip->irq);
 		goto __skip_resources;
 	}
 
@@ -470,13 +471,14 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 		dma_bits = 0x03;
 		break;
 	default:
-		snd_printk("WSS dma1 # %d not valid\n", chip->dma1);
+		snd_printk(KERN_WARNING "WSS dma1 # %d not valid\n",
+			   chip->dma1);
 		goto __skip_resources;
 	}
 
 #if defined(CS4231) || defined(OPTi93X)
 	if (chip->dma1 == chip->dma2) {
-		snd_printk("don't want to share dmas\n");
+		snd_printk(KERN_ERR "don't want to share dmas\n");
 		return -EBUSY;
 	}
 
@@ -485,7 +487,8 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 	case 1:
 		break;
 	default:
-		snd_printk("WSS dma2 # %d not valid\n", chip->dma2);
+		snd_printk(KERN_WARNING "WSS dma2 # %d not valid\n",
+			   chip->dma2);
 		goto __skip_resources;
 	}
 	dma_bits |= 0x04;
@@ -516,7 +519,8 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 			mpu_port_bits = 0x00;
 			break;
 		default:
-			snd_printk("MPU-401 port 0x%lx not valid\n",
+			snd_printk(KERN_WARNING
+				   "MPU-401 port 0x%lx not valid\n",
 				chip->mpu_port);
 			goto __skip_mpu;
 		}
@@ -535,7 +539,7 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 			mpu_irq_bits = 0x01;
 			break;
 		default:
-			snd_printk("MPU-401 irq # %d not valid\n",
+			snd_printk(KERN_WARNING "MPU-401 irq # %d not valid\n",
 				chip->mpu_irq);
 			goto __skip_mpu;
 		}
@@ -726,7 +730,7 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 	if (chip->wss_base == SNDRV_AUTO_PORT) {
 		chip->wss_base = snd_legacy_find_free_ioport(possible_ports, 4);
 		if (chip->wss_base < 0) {
-			snd_printk("unable to find a free WSS port\n");
+			snd_printk(KERN_ERR "unable to find a free WSS port\n");
 			return -EBUSY;
 		}
 	}
@@ -891,7 +895,7 @@ static int __devinit snd_opti9xx_isa_probe(struct device *devptr,
 #if defined(CS4231) || defined(OPTi93X)
 	if (dma2 == SNDRV_AUTO_DMA) {
 		if ((dma2 = snd_legacy_find_free_dma(possible_dma2s[dma1 % 4])) < 0) {
-			snd_printk("unable to find a free DMA2\n");
+			snd_printk(KERN_ERR "unable to find a free DMA2\n");
 			return -EBUSY;
 		}
 	}

commit aa9c293ae46d71f5add0761bce8db67b162e3f29
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Wed Jan 21 15:08:03 2009 +0100

    ALSA: do not create OPL3 timers if there is no OPL3 irq wired
    
    Most cards have OPL3 FM synthetiser but
    they do not have OPL3 interrupt wired to
    a sound chip or CPU.
    
    Do not create OPL3 timers for such cards
    as the timers are useless witthout interrupt.
    
    This patch removes OPL3 timers for following
    alsa drivers: snd-ad1816a, snd-opti93x,
    snd-opti92x, snd-sc6000, snd-cmi8330.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 19706b0d8497..5deb7e69a029 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -815,14 +815,8 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 				   chip->fm_port, chip->fm_port + 4 - 1);
 		}
 		if (opl3) {
-#ifdef CS4231
-			const int t1dev = 1;
-#else
-			const int t1dev = 0;
-#endif
-			if ((error = snd_opl3_timer_new(opl3, t1dev, t1dev+1)) < 0)
-				return error;
-			if ((error = snd_opl3_hwdep_new(opl3, 0, 1, &synth)) < 0)
+			error = snd_opl3_hwdep_new(opl3, 0, 1, &synth);
+			if (error < 0)
 				return error;
 		}
 	}

commit b1a0aac05f044e78a589bfd7a9e2334aa640eb45
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 14 09:34:06 2009 +0100

    ALSA: opti9xx - Fix build breakage by snd_card_create() conversion
    
    Add a missing variable declaration.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 87a4feb50109..cd6e60a6a4ea 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -833,6 +833,7 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 static int snd_opti9xx_card_new(struct snd_card **cardp)
 {
 	struct snd_card *card;
+	int err;
 
 	err = snd_card_create(index, id, THIS_MODULE,
 			      sizeof(struct snd_opti9xx), &card);

commit 3e7fb9f7ec00fd7cefd0d8e83df0cff86ce12515
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:47:30 2008 +0100

    ALSA: Return proper error code at probe in sound/isa/*
    
    Some drivers in sound/isa/* don't handle the error code properly
    from snd_card_create().  This patch fixes these places.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 5750f38bb797..87a4feb50109 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -830,17 +830,17 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 	return snd_card_register(card);
 }
 
-static struct snd_card *snd_opti9xx_card_new(void)
+static int snd_opti9xx_card_new(struct snd_card **cardp)
 {
 	struct snd_card *card;
-	int err;
 
 	err = snd_card_create(index, id, THIS_MODULE,
 			      sizeof(struct snd_opti9xx), &card);
 	if (err < 0)
-		return NULL;
+		return err;
 	card->private_free = snd_card_opti9xx_free;
-	return card;
+	*cardp = card;
+	return 0;
 }
 
 static int __devinit snd_opti9xx_isa_match(struct device *devptr,
@@ -905,9 +905,9 @@ static int __devinit snd_opti9xx_isa_probe(struct device *devptr,
 	}
 #endif
 
-	card = snd_opti9xx_card_new();
-	if (! card)
-		return -ENOMEM;
+	error = snd_opti9xx_card_new(&card);
+	if (error < 0)
+		return error;
 
 	if ((error = snd_card_opti9xx_detect(card, card->private_data)) < 0) {
 		snd_card_free(card);
@@ -952,9 +952,9 @@ static int __devinit snd_opti9xx_pnp_probe(struct pnp_card_link *pcard,
 		return -EBUSY;
 	if (! isapnp)
 		return -ENODEV;
-	card = snd_opti9xx_card_new();
-	if (! card)
-		return -ENOMEM;
+	error = snd_opti9xx_card_new(&card);
+	if (error < 0)
+		return error;
 	chip = card->private_data;
 
 	hw = snd_card_opti9xx_pnp(chip, pcard, pid);

commit c95eadd2f1afd2ba643e85a8dfc9079a3f03ae47
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:43:35 2008 +0100

    ALSA: Convert to snd_card_create() in sound/isa/*
    
    Convert from snd_card_new() to the new snd_card_create() function.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 19706b0d8497..5750f38bb797 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -833,9 +833,11 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 static struct snd_card *snd_opti9xx_card_new(void)
 {
 	struct snd_card *card;
+	int err;
 
-	card = snd_card_new(index, id, THIS_MODULE, sizeof(struct snd_opti9xx));
-	if (! card)
+	err = snd_card_create(index, id, THIS_MODULE,
+			      sizeof(struct snd_opti9xx), &card);
+	if (err < 0)
 		return NULL;
 	card->private_free = snd_card_opti9xx_free;
 	return card;

commit a0d9274cd888ada59fe2734f45019d84bc40ac3d
Author: Rene Herman <rene.herman@gmail.com>
Date:   Mon Aug 4 05:26:26 2008 +0200

    ALSA: wss_lib: opti92x-ad1848 WSS_HW_DETECT fix
    
    snd-opti92x-ad1848 mistakingly passes WSS_HW_OPTI93X currently. This
    fixes it as tested with a OPTi 82C929A/AD1848 card.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Acked-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index cb5f66bde5d3..19706b0d8497 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -719,6 +719,8 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 	chip->dma1 = dma1;
 #if defined(CS4231) || defined(OPTi93X)
 	chip->dma2 = dma2;
+#else
+	chip->dma2 = -1;
 #endif
 
 	if (chip->wss_base == SNDRV_AUTO_PORT) {
@@ -734,10 +736,10 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 
 	error = snd_wss_create(card, chip->wss_base + 4, -1,
 			       chip->irq, chip->dma1, chip->dma2,
-#ifdef CS4231
-			       WSS_HW_DETECT, 0,
-#else /* OPTi93x */
+#ifdef OPTi93X
 			       WSS_HW_OPTI93X, WSS_HWSHARE_IRQ,
+#else
+			       WSS_HW_DETECT, 0,
 #endif
 			       &codec);
 	if (error < 0)

commit 760fc6b838d8c783c363e8bdb3714bd92a8945c4
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Thu Jul 31 21:10:47 2008 +0200

    ALSA: wss_lib: use wss detection code instead of ad1848 one
    
    Use the wss detection code and kill the ad1848 library.
    The library is fully assimilated into the new wss library.
    
    This required reworking of the AD1848 family code
    so the code is changed to correctly detect chips from
    the AD1848 and CS4231 families.
    
    I have tested it on following cards:
    Gallant SC-6600 (codec: AD1848, driver: snd-sc6600)
    SoundScape VIVO/90 (codec: AD1845, driver: snd-sscape)
    SG Waverider (codec: CS4231A, driver: Rene Herman's snd-galaxy)
    Opti930 (codec: built-in - CS4231 compatible, driver: snd-opti93x)
    Opti931 (codec: built-in - CS4231 compatible, driver: snd-opti93x)
    Gallant SC-70P (chip/codec: CS4237B, driver: snd-cs4236)
    Audio Plus 3D (chip/codec: CMI8330A, driver: snd-cmi8330)
    Dell Latitude CP (chip/codec: cs4236, driver snd-cs4232)
    
    Sound playback and recording works on all these cards.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Reviewed-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 561d4b3ed098..cb5f66bde5d3 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -33,11 +33,7 @@
 #include <asm/io.h>
 #include <asm/dma.h>
 #include <sound/core.h>
-#if defined(CS4231) || defined(OPTi93X)
 #include <sound/wss.h>
-#else
-#include <sound/ad1848.h>
-#endif	/* CS4231 */
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
 #ifndef OPTi93X
@@ -148,9 +144,7 @@ struct snd_opti9xx {
 	long wss_base;
 	int irq;
 	int dma1;
-#if defined(CS4231) || defined(OPTi93X)
 	int dma2;
-#endif	/* CS4231 || OPTi93X */
 
 	long fm_port;
 
@@ -225,9 +219,7 @@ static int __devinit snd_opti9xx_init(struct snd_opti9xx *chip,
 	chip->wss_base = -1;
 	chip->irq = -1;
 	chip->dma1 = -1;
-#if defined(CS4231) || defined (OPTi93X)
 	chip->dma2 = -1;
-#endif 	/* CS4231 || OPTi93X */
 	chip->fm_port = -1;
 	chip->mpu_port = -1;
 	chip->mpu_irq = -1;
@@ -740,7 +732,6 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 	if (error)
 		return error;
 
-#if defined(CS4231) || defined(OPTi93X)
 	error = snd_wss_create(card, chip->wss_base + 4, -1,
 			       chip->irq, chip->dma1, chip->dma2,
 #ifdef CS4231
@@ -753,12 +744,6 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 		return error;
 #ifdef OPTi93X
 	chip->codec = codec;
-#endif
-#else
-	error = snd_ad1848_create(card, chip->wss_base + 4, chip->irq,
-				  chip->dma1, WSS_HW_DETECT, &codec);
-	if (error < 0)
-		return error;
 #endif
 	error = snd_wss_pcm(codec, 0, &pcm);
 	if (error < 0)

commit ead893c0deeec165524cc8a06e7e739d7d84b4c4
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Thu Jul 31 21:09:32 2008 +0200

    ALSA: wss_lib: use wss pcm code instead of ad1848 one
    
    Use the wss pcm code and kill the ad1848 pcm code.
    
    The AD1848 chip is much slower than CS4231 chips
    so the waiting loop was increased 100x (10x is not
    enough).
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Reviewed-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 4f172a219244..561d4b3ed098 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -754,18 +754,15 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 #ifdef OPTi93X
 	chip->codec = codec;
 #endif
-	error = snd_wss_pcm(codec, 0, &pcm);
-	if (error < 0)
-		return error;
 #else
 	error = snd_ad1848_create(card, chip->wss_base + 4, chip->irq,
 				  chip->dma1, WSS_HW_DETECT, &codec);
 	if (error < 0)
 		return error;
-	error = snd_ad1848_pcm(codec, 0, &pcm);
+#endif
+	error = snd_wss_pcm(codec, 0, &pcm);
 	if (error < 0)
 		return error;
-#endif
 	error = snd_wss_mixer(codec);
 	if (error < 0)
 		return error;

commit 5664daa1c1fa250dd7f6b336278b0402638e8edc
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Thu Jul 31 21:08:32 2008 +0200

    ALSA: wss_lib: use wss mixer code instead of ad1848 one
    
    Use the wss mixer code and kill the ad1848 mixer code.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Reviewed-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 1f6d6fcd6e57..4f172a219244 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -757,6 +757,15 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 	error = snd_wss_pcm(codec, 0, &pcm);
 	if (error < 0)
 		return error;
+#else
+	error = snd_ad1848_create(card, chip->wss_base + 4, chip->irq,
+				  chip->dma1, WSS_HW_DETECT, &codec);
+	if (error < 0)
+		return error;
+	error = snd_ad1848_pcm(codec, 0, &pcm);
+	if (error < 0)
+		return error;
+#endif
 	error = snd_wss_mixer(codec);
 	if (error < 0)
 		return error;
@@ -764,23 +773,14 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 	error = snd_wss_timer(codec, 0, &timer);
 	if (error < 0)
 		return error;
-#else /* OPTI93X */
+#endif
+#ifdef OPTi93X
 	error = request_irq(chip->irq, snd_opti93x_interrupt,
 			    IRQF_DISABLED, DEV_NAME" - WSS", codec);
 	if (error < 0) {
 		snd_printk(KERN_ERR "opti9xx: can't grab IRQ %d\n", chip->irq);
 		return error;
 	}
-#endif
-#else
-	if ((error = snd_ad1848_create(card, chip->wss_base + 4,
-				       chip->irq, chip->dma1,
-				       WSS_HW_DETECT, &codec)) < 0)
-		return error;
-	if ((error = snd_ad1848_pcm(codec, 0, &pcm)) < 0)
-		return error;
-	if ((error = snd_ad1848_mixer(codec)) < 0)
-		return error;
 #endif
 	strcpy(card->driver, chip->name);
 	sprintf(card->shortname, "OPTi %s", card->driver);

commit ece11c9b6db5b96179df8eb9cdc54c78953a4c0f
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Thu Jul 31 21:05:44 2008 +0200

    ALSA: wss_lib: use wss constants instead of ad1848 ones
    
    Use wss constants for mode.
    Move ad1848 hardware constants to the wss.h.
    Move mixer tlv macros into the ad1848_lib.c from the ad1848.h.
    
    Drop the MODE_RUNNING spurious IRQ guard on AD1848 as it doesn not seem
    to be needed.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Reviewed-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index ff9baf751b22..1f6d6fcd6e57 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -775,7 +775,7 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 #else
 	if ((error = snd_ad1848_create(card, chip->wss_base + 4,
 				       chip->irq, chip->dma1,
-				       AD1848_HW_DETECT, &codec)) < 0)
+				       WSS_HW_DETECT, &codec)) < 0)
 		return error;
 	if ((error = snd_ad1848_pcm(codec, 0, &pcm)) < 0)
 		return error;

commit 241b3ee70d2d69e88d5c144ce938b1887cd6d3fc
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Thu Jul 31 21:04:37 2008 +0200

    ALSA: wss_lib: use struct snd_wss instead of snd_ad1848
    
    The snd_wss is superset of the snd_ad1848 so kill
    the latter and replace it with the snd_wss.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Reviewed-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index fefb8597717c..ff9baf751b22 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -706,13 +706,9 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
 	int error;
 	struct snd_opti9xx *chip = card->private_data;
-#if defined(CS4231) || defined(OPTi93X)
 	struct snd_wss *codec;
 #ifdef CS4231
 	struct snd_timer *timer;
-#endif
-#else
-	struct snd_ad1848 *codec;
 #endif
 	struct snd_pcm *pcm;
 	struct snd_rawmidi *rmidi;

commit 7779f75f072784d3fccf721b8ec43107f93619a0
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Thu Jul 31 21:03:41 2008 +0200

    ALSA: wss_lib: rename cs4321_foo to wss_foo
    
    Rename functions and structures from the former
    cs4321_lib to names more corresponding with the
    new name: wss_lib.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Reviewed-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 93a03d9c7a95..fefb8597717c 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -139,7 +139,7 @@ struct snd_opti9xx {
 	unsigned long mc_base_size;
 #ifdef OPTi93X
 	unsigned long mc_indir_index;
-	struct snd_cs4231 *codec;
+	struct snd_wss *codec;
 #endif	/* OPTi93X */
 	unsigned long pwd_reg;
 
@@ -562,7 +562,7 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 
 static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id)
 {
-	struct snd_cs4231 *codec = dev_id;
+	struct snd_wss *codec = dev_id;
 	struct snd_opti9xx *chip = codec->card->private_data;
 	unsigned char status;
 
@@ -570,7 +570,7 @@ static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id)
 	if ((status & OPTi93X_IRQ_PLAYBACK) && codec->playback_substream)
 		snd_pcm_period_elapsed(codec->playback_substream);
 	if ((status & OPTi93X_IRQ_CAPTURE) && codec->capture_substream) {
-		snd_cs4231_overrange(codec);
+		snd_wss_overrange(codec);
 		snd_pcm_period_elapsed(codec->capture_substream);
 	}
 	outb(0x00, OPTi93X_PORT(codec, STATUS));
@@ -691,7 +691,7 @@ static void snd_card_opti9xx_free(struct snd_card *card)
         
 	if (chip) {
 #ifdef OPTi93X
-		struct snd_cs4231 *codec = chip->codec;
+		struct snd_wss *codec = chip->codec;
 		if (codec && codec->irq > 0) {
 			disable_irq(codec->irq);
 			free_irq(codec->irq, codec);
@@ -707,7 +707,7 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 	int error;
 	struct snd_opti9xx *chip = card->private_data;
 #if defined(CS4231) || defined(OPTi93X)
-	struct snd_cs4231 *codec;
+	struct snd_wss *codec;
 #ifdef CS4231
 	struct snd_timer *timer;
 #endif
@@ -734,33 +734,39 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 #endif
 
 	if (chip->wss_base == SNDRV_AUTO_PORT) {
-		if ((chip->wss_base = snd_legacy_find_free_ioport(possible_ports, 4)) < 0) {
+		chip->wss_base = snd_legacy_find_free_ioport(possible_ports, 4);
+		if (chip->wss_base < 0) {
 			snd_printk("unable to find a free WSS port\n");
 			return -EBUSY;
 		}
 	}
-	if ((error = snd_opti9xx_configure(chip)))
+	error = snd_opti9xx_configure(chip);
+	if (error)
 		return error;
 
 #if defined(CS4231) || defined(OPTi93X)
-	if ((error = snd_cs4231_create(card, chip->wss_base + 4, -1,
-				       chip->irq, chip->dma1, chip->dma2,
+	error = snd_wss_create(card, chip->wss_base + 4, -1,
+			       chip->irq, chip->dma1, chip->dma2,
 #ifdef CS4231
-				       CS4231_HW_DETECT, 0,
+			       WSS_HW_DETECT, 0,
 #else /* OPTi93x */
-				       CS4231_HW_OPTI93X, CS4231_HWSHARE_IRQ,
+			       WSS_HW_OPTI93X, WSS_HWSHARE_IRQ,
 #endif
-				       &codec)) < 0)
+			       &codec);
+	if (error < 0)
 		return error;
 #ifdef OPTi93X
 	chip->codec = codec;
 #endif
-	if ((error = snd_cs4231_pcm(codec, 0, &pcm)) < 0)
+	error = snd_wss_pcm(codec, 0, &pcm);
+	if (error < 0)
 		return error;
-	if ((error = snd_cs4231_mixer(codec)) < 0)
+	error = snd_wss_mixer(codec);
+	if (error < 0)
 		return error;
 #ifdef CS4231
-	if ((error = snd_cs4231_timer(codec, 0, &timer)) < 0)
+	error = snd_wss_timer(codec, 0, &timer);
+	if (error < 0)
 		return error;
 #else /* OPTI93X */
 	error = request_irq(chip->irq, snd_opti93x_interrupt,

commit 61ef19d7e771ce021edb0dff0da134b6d688d4aa
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Thu Jul 31 21:02:42 2008 +0200

    ALSA: wss_lib: rename cs4231.h into wss.h
    
    Rename file include/sound/cs4231.h
    into include/sound/wss.h
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Reviewed-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 0797ca441a37..93a03d9c7a95 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -34,7 +34,7 @@
 #include <asm/dma.h>
 #include <sound/core.h>
 #if defined(CS4231) || defined(OPTi93X)
-#include <sound/cs4231.h>
+#include <sound/wss.h>
 #else
 #include <sound/ad1848.h>
 #endif	/* CS4231 */

commit 51f6baad264ca4bacdbf4fa25c676fa30d344bfa
Author: Rene Herman <rene.herman@gmail.com>
Date:   Fri Jul 18 11:15:12 2008 +0200

    ALSA: opti9xx: no isapnp param for !CONFIG_PNP
    
    "isapnp" needs CONFIG_PNP to be useful.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index d20abb286124..0797ca441a37 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -68,7 +68,9 @@ MODULE_SUPPORTED_DEVICE("{{OPTi,82C924 (AD1848)},"
 static int index = SNDRV_DEFAULT_IDX1;	/* Index 0-MAX */
 static char *id = SNDRV_DEFAULT_STR1;		/* ID for this card */
 //static int enable = SNDRV_DEFAULT_ENABLE1;	/* Enable this card */
+#ifdef CONFIG_PNP
 static int isapnp = 1;			/* Enable ISA PnP detection */
+#endif
 static long port = SNDRV_DEFAULT_PORT1; 	/* 0x530,0xe80,0xf40,0x604 */
 static long mpu_port = SNDRV_DEFAULT_PORT1;	/* 0x300,0x310,0x320,0x330 */
 static long fm_port = SNDRV_DEFAULT_PORT1;	/* 0x388 */
@@ -85,8 +87,10 @@ module_param(id, charp, 0444);
 MODULE_PARM_DESC(id, "ID string for opti9xx based soundcard.");
 //module_param(enable, bool, 0444);
 //MODULE_PARM_DESC(enable, "Enable opti9xx soundcard.");
+#ifdef CONFIG_PNP
 module_param(isapnp, bool, 0444);
 MODULE_PARM_DESC(isapnp, "Enable ISA PnP detection for specified soundcard.");
+#endif
 module_param(port, long, 0444);
 MODULE_PARM_DESC(port, "WSS port # for opti9xx driver.");
 module_param(mpu_port, long, 0444);

commit 82af6bc0986c5140efc875b2d91326031f0254ab
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jul 17 23:37:20 2008 +0200

    ALSA: opti93x - Fix NULL dereference
    
    Probing non-existing device causes Oops with snd-opti93x driver
    due to NULL access in the destructor of the error path.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Tested-by: Rene Herman <rene.herman@gmail.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Tested-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 41c047e665ec..d20abb286124 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -688,7 +688,7 @@ static void snd_card_opti9xx_free(struct snd_card *card)
 	if (chip) {
 #ifdef OPTi93X
 		struct snd_cs4231 *codec = chip->codec;
-		if (codec->irq > 0) {
+		if (codec && codec->irq > 0) {
 			disable_irq(codec->irq);
 			free_irq(codec->irq, codec);
 		}

commit 9f240a558f94bea839e14c46c8fccf93bdd35ef6
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Wed Jun 11 12:26:32 2008 +0200

    ALSA: opti93x: use cs4231 lib
    
    This patch converts the Opti93x driver to use
    the cs4231 library instead of duplicating the code.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Tested-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index fc15b88364b4..41c047e665ec 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -33,15 +33,10 @@
 #include <asm/io.h>
 #include <asm/dma.h>
 #include <sound/core.h>
-#ifdef CS4231
+#if defined(CS4231) || defined(OPTi93X)
 #include <sound/cs4231.h>
 #else
-#ifndef OPTi93X
 #include <sound/ad1848.h>
-#else
-#include <sound/control.h>
-#include <sound/pcm.h>
-#endif	/* OPTi93X */
 #endif	/* CS4231 */
 #include <sound/mpu401.h>
 #include <sound/opl3.h>
@@ -109,7 +104,6 @@ module_param(dma2, int, 0444);
 MODULE_PARM_DESC(dma2, "2nd dma # for opti9xx driver.");
 #endif	/* CS4231 || OPTi93X */
 
-#define OPTi9XX_HW_DETECT	0
 #define OPTi9XX_HW_82C928	1
 #define OPTi9XX_HW_82C929	2
 #define OPTi9XX_HW_82C924	3
@@ -123,105 +117,12 @@ MODULE_PARM_DESC(dma2, "2nd dma # for opti9xx driver.");
 
 #ifdef OPTi93X
 
-#define OPTi93X_INDEX			0x00
-#define OPTi93X_DATA			0x01
 #define OPTi93X_STATUS			0x02
-#define OPTi93X_DDATA			0x03
 #define OPTi93X_PORT(chip, r)		((chip)->port + OPTi93X_##r)
 
-#define OPTi93X_MIXOUT_LEFT		0x00
-#define OPTi93X_MIXOUT_RIGHT		0x01
-#define OPTi93X_CD_LEFT_INPUT		0x02
-#define OPTi93X_CD_RIGHT_INPUT		0x03
-#define OPTi930_AUX_LEFT_INPUT		0x04
-#define OPTi930_AUX_RIGHT_INPUT		0x05
-#define OPTi931_FM_LEFT_INPUT		0x04
-#define OPTi931_FM_RIGHT_INPUT		0x05
-#define OPTi93X_DAC_LEFT		0x06
-#define OPTi93X_DAC_RIGHT		0x07
-#define OPTi93X_PLAY_FORMAT		0x08
-#define OPTi93X_IFACE_CONF		0x09
-#define OPTi93X_PIN_CTRL		0x0a
-#define OPTi93X_ERR_INIT		0x0b
-#define OPTi93X_ID			0x0c
-#define OPTi93X_PLAY_UPR_CNT		0x0e
-#define OPTi93X_PLAY_LWR_CNT		0x0f
-#define OPTi931_AUX_LEFT_INPUT		0x10
-#define OPTi931_AUX_RIGHT_INPUT		0x11
-#define OPTi93X_LINE_LEFT_INPUT		0x12
-#define OPTi93X_LINE_RIGHT_INPUT	0x13
-#define OPTi93X_MIC_LEFT_INPUT		0x14
-#define OPTi93X_MIC_RIGHT_INPUT		0x15
-#define OPTi93X_OUT_LEFT		0x16
-#define OPTi93X_OUT_RIGHT		0x17
-#define OPTi93X_CAPT_FORMAT		0x1c
-#define OPTi93X_CAPT_UPR_CNT		0x1e
-#define OPTi93X_CAPT_LWR_CNT		0x1f
-
-#define OPTi93X_TRD			0x20
-#define OPTi93X_MCE			0x40
-#define OPTi93X_INIT			0x80
-
-#define OPTi93X_MIXOUT_MIC_GAIN		0x20
-#define OPTi93X_MIXOUT_LINE		0x00
-#define OPTi93X_MIXOUT_CD		0x40
-#define OPTi93X_MIXOUT_MIC		0x80
-#define OPTi93X_MIXOUT_MIXER		0xc0
-
-#define OPTi93X_STEREO			0x10
-#define OPTi93X_LINEAR_8		0x00
-#define OPTi93X_ULAW_8			0x20
-#define OPTi93X_LINEAR_16_LIT		0x40
-#define OPTi93X_ALAW_8			0x60
-#define OPTi93X_ADPCM_16		0xa0
-#define OPTi93X_LINEAR_16_BIG		0xc0
-
-#define OPTi93X_CAPTURE_PIO		0x80
-#define OPTi93X_PLAYBACK_PIO		0x40
-#define OPTi93X_AUTOCALIB		0x08
-#define OPTi93X_SINGLE_DMA		0x04
-#define OPTi93X_CAPTURE_ENABLE		0x02
-#define OPTi93X_PLAYBACK_ENABLE		0x01
-
-#define OPTi93X_IRQ_ENABLE		0x02
-
-#define OPTi93X_DMA_REQUEST		0x10
-#define OPTi93X_CALIB_IN_PROGRESS	0x20
-
 #define OPTi93X_IRQ_PLAYBACK		0x04
 #define OPTi93X_IRQ_CAPTURE		0x08
 
-
-struct snd_opti93x {
-	unsigned long port;
-	struct resource *res_port;
-	int irq;
-	int dma1;
-	int dma2;
-
-	struct snd_opti9xx *chip;
-	unsigned short hardware;
-	unsigned char image[32];
-
-	unsigned char mce_bit;
-	unsigned short mode;
-	int mute;
-
-	spinlock_t lock;
-
-	struct snd_card *card;
-	struct snd_pcm *pcm;
-	struct snd_pcm_substream *playback_substream;
-	struct snd_pcm_substream *capture_substream;
-	unsigned int p_dma_size;
-	unsigned int c_dma_size;
-};
-
-#define OPTi93X_MODE_NONE	0x00
-#define OPTi93X_MODE_PLAY	0x01
-#define OPTi93X_MODE_CAPTURE	0x02
-#define OPTi93X_MODE_OPEN	(OPTi93X_MODE_PLAY | OPTi93X_MODE_CAPTURE)
-
 #endif /* OPTi93X */
 
 struct snd_opti9xx {
@@ -234,6 +135,7 @@ struct snd_opti9xx {
 	unsigned long mc_base_size;
 #ifdef OPTi93X
 	unsigned long mc_indir_index;
+	struct snd_cs4231 *codec;
 #endif	/* OPTi93X */
 	unsigned long pwd_reg;
 
@@ -654,979 +556,23 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 
 #ifdef OPTi93X
 
-static unsigned char snd_opti93x_default_image[32] =
-{
-	0x00,		/* 00/00 - l_mixout_outctrl */
-	0x00,		/* 01/01 - r_mixout_outctrl */
-	0x88,		/* 02/02 - l_cd_inctrl */
-	0x88,		/* 03/03 - r_cd_inctrl */
-	0x88,		/* 04/04 - l_a1/fm_inctrl */
-	0x88,		/* 05/05 - r_a1/fm_inctrl */
-	0x80,		/* 06/06 - l_dac_inctrl */
-	0x80,		/* 07/07 - r_dac_inctrl */
-	0x00,		/* 08/08 - ply_dataform_reg */
-	0x00,		/* 09/09 - if_conf */
-	0x00,		/* 0a/10 - pin_ctrl */
-	0x00,		/* 0b/11 - err_init_reg */
-	0x0a,		/* 0c/12 - id_reg */
-	0x00,		/* 0d/13 - reserved */
-	0x00,		/* 0e/14 - ply_upcount_reg */
-	0x00,		/* 0f/15 - ply_lowcount_reg */
-	0x88,		/* 10/16 - reserved/l_a1_inctrl */
-	0x88,		/* 11/17 - reserved/r_a1_inctrl */
-	0x88,		/* 12/18 - l_line_inctrl */
-	0x88,		/* 13/19 - r_line_inctrl */
-	0x88,		/* 14/20 - l_mic_inctrl */
-	0x88,		/* 15/21 - r_mic_inctrl */
-	0x80,		/* 16/22 - l_out_outctrl */
-	0x80,		/* 17/23 - r_out_outctrl */
-	0x00,		/* 18/24 - reserved */
-	0x00,		/* 19/25 - reserved */
-	0x00,		/* 1a/26 - reserved */
-	0x00,		/* 1b/27 - reserved */
-	0x00,		/* 1c/28 - cap_dataform_reg */
-	0x00,		/* 1d/29 - reserved */
-	0x00,		/* 1e/30 - cap_upcount_reg */
-	0x00		/* 1f/31 - cap_lowcount_reg */
-};
-
-
-static int snd_opti93x_busy_wait(struct snd_opti93x *chip)
-{
-	int timeout;
-
-	for (timeout = 250; timeout-- > 0; udelay(10))
-		if (!(inb(OPTi93X_PORT(chip, INDEX)) & OPTi93X_INIT))
-			return 0;
-
-	snd_printk("chip still busy.\n");
-	return -EBUSY;
-}
-
-static unsigned char snd_opti93x_in(struct snd_opti93x *chip, unsigned char reg)
-{
-	snd_opti93x_busy_wait(chip);
-	outb(chip->mce_bit | (reg & 0x1f), OPTi93X_PORT(chip, INDEX));
-	return inb(OPTi93X_PORT(chip, DATA));
-}
-
-static void snd_opti93x_out(struct snd_opti93x *chip, unsigned char reg,
-			    unsigned char value)
-{
-	snd_opti93x_busy_wait(chip);
-	outb(chip->mce_bit | (reg & 0x1f), OPTi93X_PORT(chip, INDEX));
-	outb(value, OPTi93X_PORT(chip, DATA));
-}
-
-static void snd_opti93x_out_image(struct snd_opti93x *chip, unsigned char reg,
-				  unsigned char value)
-{
-	snd_opti93x_out(chip, reg, chip->image[reg] = value);
-}
-
-static void snd_opti93x_out_mask(struct snd_opti93x *chip, unsigned char reg,
-				 unsigned char mask, unsigned char value)
-{
-	snd_opti93x_out_image(chip, reg,
-		(chip->image[reg] & ~mask) | (value & mask));
-}
-
-
-static void snd_opti93x_mce_up(struct snd_opti93x *chip)
-{
-	snd_opti93x_busy_wait(chip);
-
-	chip->mce_bit = OPTi93X_MCE;
-	if (!(inb(OPTi93X_PORT(chip, INDEX)) & OPTi93X_MCE))
-		outb(chip->mce_bit, OPTi93X_PORT(chip, INDEX));
-}
-
-static void snd_opti93x_mce_down(struct snd_opti93x *chip)
-{
-	snd_opti93x_busy_wait(chip);
-
-	chip->mce_bit = 0;
-	if (inb(OPTi93X_PORT(chip, INDEX)) & OPTi93X_MCE)
-		outb(chip->mce_bit, OPTi93X_PORT(chip, INDEX));
-}
-
-#define snd_opti93x_mute_reg(chip, reg, mute)	\
-	snd_opti93x_out(chip, reg, mute ? 0x80 : chip->image[reg]);
-
-static void snd_opti93x_mute(struct snd_opti93x *chip, int mute)
-{
-	mute = mute ? 1 : 0;
-	if (chip->mute == mute)
-		return;
-
-	chip->mute = mute;
-
-	snd_opti93x_mute_reg(chip, OPTi93X_CD_LEFT_INPUT, mute);
-	snd_opti93x_mute_reg(chip, OPTi93X_CD_RIGHT_INPUT, mute);
-	switch (chip->hardware) {
-	case OPTi9XX_HW_82C930:
-		snd_opti93x_mute_reg(chip, OPTi930_AUX_LEFT_INPUT, mute);
-		snd_opti93x_mute_reg(chip, OPTi930_AUX_RIGHT_INPUT, mute);
-		break;
-	case OPTi9XX_HW_82C931:
-	case OPTi9XX_HW_82C933:
-		snd_opti93x_mute_reg(chip, OPTi931_FM_LEFT_INPUT, mute);
-		snd_opti93x_mute_reg(chip, OPTi931_FM_RIGHT_INPUT, mute);
-		snd_opti93x_mute_reg(chip, OPTi931_AUX_LEFT_INPUT, mute);
-		snd_opti93x_mute_reg(chip, OPTi931_AUX_RIGHT_INPUT, mute);
-	}
-	snd_opti93x_mute_reg(chip, OPTi93X_DAC_LEFT, mute);
-	snd_opti93x_mute_reg(chip, OPTi93X_DAC_RIGHT, mute);
-	snd_opti93x_mute_reg(chip, OPTi93X_LINE_LEFT_INPUT, mute);
-	snd_opti93x_mute_reg(chip, OPTi93X_LINE_RIGHT_INPUT, mute);
-	snd_opti93x_mute_reg(chip, OPTi93X_MIC_LEFT_INPUT, mute);
-	snd_opti93x_mute_reg(chip, OPTi93X_MIC_RIGHT_INPUT, mute);
-	snd_opti93x_mute_reg(chip, OPTi93X_OUT_LEFT, mute);
-	snd_opti93x_mute_reg(chip, OPTi93X_OUT_RIGHT, mute);
-}
-
-
-static unsigned int snd_opti93x_get_count(unsigned char format,
-					  unsigned int size)
-{
-	switch (format & 0xe0) {
-	case OPTi93X_LINEAR_16_LIT:
-	case OPTi93X_LINEAR_16_BIG:
-		size >>= 1;
-		break;
-	case OPTi93X_ADPCM_16:
-		return size >> 2;
-	}
-	return (format & OPTi93X_STEREO) ? (size >> 1) : size;
-}
-
-static unsigned int rates[] = {  5512,  6615,  8000,  9600, 11025, 16000, 
-				18900, 22050, 27428, 32000, 33075, 37800,
-				44100, 48000 };
-#define RATES ARRAY_SIZE(rates)
-
-static struct snd_pcm_hw_constraint_list hw_constraints_rates = {
-	.count = RATES,
-	.list = rates,
-	.mask = 0,
-};
-
-static unsigned char bits[] = {  0x01,  0x0f,  0x00,  0x0e,  0x03,  0x02,
-				 0x05,  0x07,  0x04,  0x06,  0x0d,  0x09,
-				 0x0b,  0x0c};
-
-static unsigned char snd_opti93x_get_freq(unsigned int rate)
-{
-	unsigned int i;
-
-	for (i = 0; i < RATES; i++) {
-		if (rate == rates[i])
-			return bits[i];
-	}
-	snd_BUG();
-	return bits[RATES-1];
-}
-
-static unsigned char snd_opti93x_get_format(struct snd_opti93x *chip,
-					    unsigned int format, int channels)
-{
-	unsigned char retval = OPTi93X_LINEAR_8;
-
-	switch (format) {
-	case SNDRV_PCM_FORMAT_MU_LAW:
-		retval = OPTi93X_ULAW_8;
-		break;
-	case SNDRV_PCM_FORMAT_A_LAW:
-		retval = OPTi93X_ALAW_8;
-		break;
-	case SNDRV_PCM_FORMAT_S16_LE:
-		retval = OPTi93X_LINEAR_16_LIT;
-		break;
-	case SNDRV_PCM_FORMAT_S16_BE:
-		retval = OPTi93X_LINEAR_16_BIG;
-		break;
-	case SNDRV_PCM_FORMAT_IMA_ADPCM:
-		retval = OPTi93X_ADPCM_16;
-	}
-	return (channels > 1) ? (retval | OPTi93X_STEREO) : retval;
-}
-
-
-static void snd_opti93x_playback_format(struct snd_opti93x *chip, unsigned char fmt)
-{
-	unsigned char mask;
-
-	snd_opti93x_mute(chip, 1);
-
-	snd_opti93x_mce_up(chip);
-	mask = (chip->mode & OPTi93X_MODE_CAPTURE) ? 0xf0 : 0xff;
-	snd_opti93x_out_mask(chip, OPTi93X_PLAY_FORMAT, mask, fmt);
-	snd_opti93x_mce_down(chip);
-
-	snd_opti93x_mute(chip, 0);
-}
-
-static void snd_opti93x_capture_format(struct snd_opti93x *chip, unsigned char fmt)
-{
-	snd_opti93x_mute(chip, 1);
-
-	snd_opti93x_mce_up(chip);
-	if (!(chip->mode & OPTi93X_MODE_PLAY))
-		snd_opti93x_out_mask(chip, OPTi93X_PLAY_FORMAT, 0x0f, fmt);
-	else
-		fmt = chip->image[OPTi93X_PLAY_FORMAT] & 0xf0;
-	snd_opti93x_out_image(chip, OPTi93X_CAPT_FORMAT, fmt);
-	snd_opti93x_mce_down(chip);
-
-	snd_opti93x_mute(chip, 0);
-}
-
-
-static int snd_opti93x_open(struct snd_opti93x *chip, unsigned int mode)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&chip->lock, flags);
-
-	if (chip->mode & mode) {
-		spin_unlock_irqrestore(&chip->lock, flags);
-		return -EAGAIN;
-	}
-
-	if (!(chip->mode & OPTi93X_MODE_OPEN)) {
-		outb(0x00, OPTi93X_PORT(chip, STATUS));
-		snd_opti93x_out_mask(chip, OPTi93X_PIN_CTRL,
-			OPTi93X_IRQ_ENABLE, OPTi93X_IRQ_ENABLE);
-		chip->mode = mode;
-	}
-	else
-		chip->mode |= mode;
-
-	spin_unlock_irqrestore(&chip->lock, flags);
-	return 0;
-}
-
-static void snd_opti93x_close(struct snd_opti93x *chip, unsigned int mode)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&chip->lock, flags);
-
-	chip->mode &= ~mode;
-	if (chip->mode & OPTi93X_MODE_OPEN) {
-		spin_unlock_irqrestore(&chip->lock, flags);
-		return;
-	}
-
-	snd_opti93x_mute(chip, 1);
-
-	outb(0, OPTi93X_PORT(chip, STATUS));
-	snd_opti93x_out_mask(chip, OPTi93X_PIN_CTRL, OPTi93X_IRQ_ENABLE,
-		~OPTi93X_IRQ_ENABLE);
-
-	snd_opti93x_mce_up(chip);
-	snd_opti93x_out_image(chip, OPTi93X_IFACE_CONF, 0x00);
-	snd_opti93x_mce_down(chip);
-	chip->mode = 0;
-
-	snd_opti93x_mute(chip, 0);
-	spin_unlock_irqrestore(&chip->lock, flags);
-}
-
-static int snd_opti93x_trigger(struct snd_pcm_substream *substream, 
-			       unsigned char what, int cmd)
-{
-	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_STOP:
-	{
-		unsigned int what = 0;
-		struct snd_pcm_substream *s;
-		snd_pcm_group_for_each_entry(s, substream) {
-			if (s == chip->playback_substream) {
-				what |= OPTi93X_PLAYBACK_ENABLE;
-				snd_pcm_trigger_done(s, substream);
-			} else if (s == chip->capture_substream) {
-				what |= OPTi93X_CAPTURE_ENABLE;
-				snd_pcm_trigger_done(s, substream);
-			}
-		}
-		spin_lock(&chip->lock);
-		if (cmd == SNDRV_PCM_TRIGGER_START) {
-			snd_opti93x_out_mask(chip, OPTi93X_IFACE_CONF, what, what);
-			if (what & OPTi93X_CAPTURE_ENABLE)
-				udelay(50);
-		} else
-			snd_opti93x_out_mask(chip, OPTi93X_IFACE_CONF, what, 0x00);
-		spin_unlock(&chip->lock);
-		break;
-	}
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int snd_opti93x_playback_trigger(struct snd_pcm_substream *substream, int cmd)
-{
-	return snd_opti93x_trigger(substream,
-				   OPTi93X_PLAYBACK_ENABLE, cmd);
-}
-
-static int snd_opti93x_capture_trigger(struct snd_pcm_substream *substream, int cmd)
-{
-	return snd_opti93x_trigger(substream,
-				   OPTi93X_CAPTURE_ENABLE, cmd);
-}
-
-static int snd_opti93x_hw_params(struct snd_pcm_substream *substream,
-				 struct snd_pcm_hw_params *hw_params)
-{
-	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
-}
-
-
-static int snd_opti93x_hw_free(struct snd_pcm_substream *substream)
-{
-	snd_pcm_lib_free_pages(substream);
-	return 0;
-}
-
-
-static int snd_opti93x_playback_prepare(struct snd_pcm_substream *substream)
-{
-	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	unsigned long flags;
-	unsigned char format;
-	unsigned int count = snd_pcm_lib_period_bytes(substream);
-	unsigned int size = snd_pcm_lib_buffer_bytes(substream);
-
-	spin_lock_irqsave(&chip->lock, flags);
-
-	chip->p_dma_size = size;
-	snd_opti93x_out_mask(chip, OPTi93X_IFACE_CONF,
-		OPTi93X_PLAYBACK_ENABLE | OPTi93X_PLAYBACK_PIO,
-		~(OPTi93X_PLAYBACK_ENABLE | OPTi93X_PLAYBACK_PIO));
-
-	snd_dma_program(chip->dma1, runtime->dma_addr, size,
-		DMA_MODE_WRITE | DMA_AUTOINIT);
-
-	format = snd_opti93x_get_freq(runtime->rate);
-	format |= snd_opti93x_get_format(chip, runtime->format,
-		runtime->channels);
-	snd_opti93x_playback_format(chip, format);
-	format = chip->image[OPTi93X_PLAY_FORMAT];
-
-	count = snd_opti93x_get_count(format, count) - 1;
-	snd_opti93x_out_image(chip, OPTi93X_PLAY_LWR_CNT, count);
-	snd_opti93x_out_image(chip, OPTi93X_PLAY_UPR_CNT, count >> 8);
-
-	spin_unlock_irqrestore(&chip->lock, flags);
-	return 0;
-}
-
-static int snd_opti93x_capture_prepare(struct snd_pcm_substream *substream)
-{
-	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	unsigned long flags;
-	unsigned char format;
-	unsigned int count = snd_pcm_lib_period_bytes(substream);
-	unsigned int size = snd_pcm_lib_buffer_bytes(substream);
-
-	spin_lock_irqsave(&chip->lock, flags);
-
-	chip->c_dma_size = size;
-	snd_opti93x_out_mask(chip, OPTi93X_IFACE_CONF,
-		OPTi93X_CAPTURE_ENABLE | OPTi93X_CAPTURE_PIO, 0);
-
-	snd_dma_program(chip->dma2, runtime->dma_addr, size,
-		DMA_MODE_READ | DMA_AUTOINIT);
-
-	format = snd_opti93x_get_freq(runtime->rate);
-	format |= snd_opti93x_get_format(chip, runtime->format,
-		runtime->channels);
-	snd_opti93x_capture_format(chip, format);
-	format = chip->image[OPTi93X_CAPT_FORMAT];
-
-	count = snd_opti93x_get_count(format, count) - 1;
-	snd_opti93x_out_image(chip, OPTi93X_CAPT_LWR_CNT, count);
-	snd_opti93x_out_image(chip, OPTi93X_CAPT_UPR_CNT, count >> 8);
-
-	spin_unlock_irqrestore(&chip->lock, flags);
-	return 0;
-}
-
-static snd_pcm_uframes_t snd_opti93x_playback_pointer(struct snd_pcm_substream *substream)
-{
-	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
-	size_t ptr;
-
-	if (!(chip->image[OPTi93X_IFACE_CONF] & OPTi93X_PLAYBACK_ENABLE))
-		return 0;
-
-	ptr = snd_dma_pointer(chip->dma1, chip->p_dma_size);
-	return bytes_to_frames(substream->runtime, ptr);
-}
-
-static snd_pcm_uframes_t snd_opti93x_capture_pointer(struct snd_pcm_substream *substream)
-{
-	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
-	size_t ptr;
-	
-	if (!(chip->image[OPTi93X_IFACE_CONF] & OPTi93X_CAPTURE_ENABLE))
-		return 0;
-
-	ptr = snd_dma_pointer(chip->dma2, chip->c_dma_size);
-	return bytes_to_frames(substream->runtime, ptr);
-}
-
-
-static void snd_opti93x_overrange(struct snd_opti93x *chip)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&chip->lock, flags);
-
-	if (snd_opti93x_in(chip, OPTi93X_ERR_INIT) & (0x08 | 0x02))
-		chip->capture_substream->runtime->overrange++;
-
-	spin_unlock_irqrestore(&chip->lock, flags);
-}
-
 static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id)
 {
-	struct snd_opti93x *codec = dev_id;
+	struct snd_cs4231 *codec = dev_id;
+	struct snd_opti9xx *chip = codec->card->private_data;
 	unsigned char status;
 
-	status = snd_opti9xx_read(codec->chip, OPTi9XX_MC_REG(11));
+	status = snd_opti9xx_read(chip, OPTi9XX_MC_REG(11));
 	if ((status & OPTi93X_IRQ_PLAYBACK) && codec->playback_substream)
 		snd_pcm_period_elapsed(codec->playback_substream);
 	if ((status & OPTi93X_IRQ_CAPTURE) && codec->capture_substream) {
-		snd_opti93x_overrange(codec);
+		snd_cs4231_overrange(codec);
 		snd_pcm_period_elapsed(codec->capture_substream);
 	}
 	outb(0x00, OPTi93X_PORT(codec, STATUS));
 	return IRQ_HANDLED;
 }
 
-
-static struct snd_pcm_hardware snd_opti93x_playback = {
-	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
-				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START),
-	.formats =		(SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW | SNDRV_PCM_FMTBIT_IMA_ADPCM |
-				 SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE),
-	.rates =		SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,
-	.rate_min =		5512,
-	.rate_max =		48000,
-	.channels_min =		1,
-	.channels_max =		2,
-	.buffer_bytes_max =	(128*1024),
-	.period_bytes_min =	64,
-	.period_bytes_max =	(128*1024),
-	.periods_min =		1,
-	.periods_max =		1024,
-	.fifo_size =		0,
-};
-
-static struct snd_pcm_hardware snd_opti93x_capture = {
-	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
-				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START),
-	.formats =		(SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW | SNDRV_PCM_FMTBIT_IMA_ADPCM |
-				 SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE),
-	.rates =		SNDRV_PCM_RATE_8000_48000,
-	.rate_min =		5512,
-	.rate_max =		48000,
-	.channels_min =		1,
-	.channels_max =		2,
-	.buffer_bytes_max =	(128*1024),
-	.period_bytes_min =	64,
-	.period_bytes_max =	(128*1024),
-	.periods_min =		1,
-	.periods_max =		1024,
-	.fifo_size =		0,
-};
-
-static int snd_opti93x_playback_open(struct snd_pcm_substream *substream)
-{
-	int error;
-	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	if ((error = snd_opti93x_open(chip, OPTi93X_MODE_PLAY)) < 0)
-		return error;
-	snd_pcm_set_sync(substream);
-	chip->playback_substream = substream;
-	runtime->hw = snd_opti93x_playback;
-	snd_pcm_limit_isa_dma_size(chip->dma1, &runtime->hw.buffer_bytes_max);
-	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);
-	return error;
-}
-
-static int snd_opti93x_capture_open(struct snd_pcm_substream *substream)
-{
-	int error;
-	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	if ((error = snd_opti93x_open(chip, OPTi93X_MODE_CAPTURE)) < 0)
-		return error;
-	runtime->hw = snd_opti93x_capture;
-	snd_pcm_set_sync(substream);
-	chip->capture_substream = substream;
-	snd_pcm_limit_isa_dma_size(chip->dma2, &runtime->hw.buffer_bytes_max);
-	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);
-	return error;
-}
-
-static int snd_opti93x_playback_close(struct snd_pcm_substream *substream)
-{
-	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
-
-	chip->playback_substream = NULL;
-	snd_opti93x_close(chip, OPTi93X_MODE_PLAY);
-	return 0;
-}
-
-static int snd_opti93x_capture_close(struct snd_pcm_substream *substream)
-{
-	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
-
-	chip->capture_substream = NULL;
-	snd_opti93x_close(chip, OPTi93X_MODE_CAPTURE);
-	return 0;
-}
-
-
-static void snd_opti93x_init(struct snd_opti93x *chip)
-{
-	unsigned long flags;
-	int i;
-
-	spin_lock_irqsave(&chip->lock, flags);
-	snd_opti93x_mce_up(chip);
-
-	for (i = 0; i < 32; i++)
-		snd_opti93x_out_image(chip, i, snd_opti93x_default_image[i]);
-
-	snd_opti93x_mce_down(chip);
-	spin_unlock_irqrestore(&chip->lock, flags);
-}
-
-static int snd_opti93x_probe(struct snd_opti93x *chip)
-{
-	unsigned long flags;
-	unsigned char val;
-
-	spin_lock_irqsave(&chip->lock, flags);
-	val = snd_opti93x_in(chip, OPTi93X_ID) & 0x0f;
-	spin_unlock_irqrestore(&chip->lock, flags);
-
-	return (val == 0x0a) ? 0 : -ENODEV;
-}
-
-static int snd_opti93x_free(struct snd_opti93x *chip)
-{
-	release_and_free_resource(chip->res_port);
-	if (chip->dma1 >= 0) {
-		disable_dma(chip->dma1);
-		free_dma(chip->dma1);
-	}
-	if (chip->dma2 >= 0) {
-		disable_dma(chip->dma2);
-		free_dma(chip->dma2);
-	}
-	if (chip->irq >= 0) {
-	  free_irq(chip->irq, chip);
-	}
-	kfree(chip);
-	return 0;
-}
-
-static int snd_opti93x_dev_free(struct snd_device *device)
-{
-	struct snd_opti93x *chip = device->device_data;
-	return snd_opti93x_free(chip);
-}
-
-static const char *snd_opti93x_chip_id(struct snd_opti93x *codec)
-{
-	switch (codec->hardware) {
-	case OPTi9XX_HW_82C930: return "82C930";
-	case OPTi9XX_HW_82C931: return "82C931";
-	case OPTi9XX_HW_82C933: return "82C933";
-	default:		return "???";
-	}
-}
-
-static int snd_opti93x_create(struct snd_card *card, struct snd_opti9xx *chip,
-			      int dma1, int dma2,
-			      struct snd_opti93x **rcodec)
-{
-	static struct snd_device_ops ops = {
-		.dev_free =	snd_opti93x_dev_free,
-	};
-	int error;
-	struct snd_opti93x *codec;
-
-	*rcodec = NULL;
-	codec = kzalloc(sizeof(*codec), GFP_KERNEL);
-	if (codec == NULL)
-		return -ENOMEM;
-	codec->irq = -1;
-	codec->dma1 = -1;
-	codec->dma2 = -1;
-
-	if ((codec->res_port = request_region(chip->wss_base + 4, 4, "OPTI93x CODEC")) == NULL) {
-		snd_printk(KERN_ERR "opti9xx: can't grab port 0x%lx\n", chip->wss_base + 4);
-		snd_opti93x_free(codec);
-		return -EBUSY;
-	}
-	if (request_dma(dma1, "OPTI93x - 1")) {
-		snd_printk(KERN_ERR "opti9xx: can't grab DMA1 %d\n", dma1);
-		snd_opti93x_free(codec);
-		return -EBUSY;
-	}
-	codec->dma1 = chip->dma1;
-	if (request_dma(dma2, "OPTI93x - 2")) {
-		snd_printk(KERN_ERR "opti9xx: can't grab DMA2 %d\n", dma2);
-		snd_opti93x_free(codec);
-		return -EBUSY;
-	}
-	codec->dma2 = chip->dma2;
-
-	if (request_irq(chip->irq, snd_opti93x_interrupt, IRQF_DISABLED, DEV_NAME" - WSS", codec)) {
-		snd_printk(KERN_ERR "opti9xx: can't grab IRQ %d\n", chip->irq);
-		snd_opti93x_free(codec);
-		return -EBUSY;
-	}
-
-	codec->card = card;
-	codec->port = chip->wss_base + 4;
-	codec->irq = chip->irq;
-
-	spin_lock_init(&codec->lock);
-	codec->hardware = chip->hardware;
-	codec->chip = chip;
-
-	if ((error = snd_opti93x_probe(codec))) {
-		snd_opti93x_free(codec);
-		return error;
-	}
-
-	snd_opti93x_init(codec);
-
-	/* Register device */
-	if ((error = snd_device_new(card, SNDRV_DEV_LOWLEVEL, codec, &ops)) < 0) {
-		snd_opti93x_free(codec);
-		return error;
-	}
-
-	*rcodec = codec;
-	return 0;
-}
-
-static struct snd_pcm_ops snd_opti93x_playback_ops = {
-	.open =		snd_opti93x_playback_open,
-	.close =	snd_opti93x_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_opti93x_hw_params,
-	.hw_free =	snd_opti93x_hw_free,
-	.prepare =	snd_opti93x_playback_prepare,
-	.trigger =	snd_opti93x_playback_trigger,
-	.pointer =	snd_opti93x_playback_pointer,
-};
-
-static struct snd_pcm_ops snd_opti93x_capture_ops = {
-	.open =		snd_opti93x_capture_open,
-	.close =	snd_opti93x_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_opti93x_hw_params,
-	.hw_free =	snd_opti93x_hw_free,
-	.prepare =	snd_opti93x_capture_prepare,
-	.trigger =	snd_opti93x_capture_trigger,
-	.pointer =	snd_opti93x_capture_pointer,
-};
-
-static int snd_opti93x_pcm(struct snd_opti93x *codec, int device, struct snd_pcm **rpcm)
-{
-	int error;
-	struct snd_pcm *pcm;
-
-	if ((error = snd_pcm_new(codec->card, "OPTi 82C93X", device, 1, 1, &pcm)) < 0)
-		return error;
-
-	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_opti93x_playback_ops);
-	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_opti93x_capture_ops);
-
-	pcm->private_data = codec;
-	pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
-
-	strcpy(pcm->name, snd_opti93x_chip_id(codec));
-
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      snd_dma_isa_data(),
-					      64*1024, codec->dma1 > 3 || codec->dma2 > 3 ? 128*1024 : 64*1024);
-
-	codec->pcm = pcm;
-	if (rpcm)
-		*rpcm = pcm;
-	return 0;
-}
-
-/*
- *  MIXER part
- */
-
-static int snd_opti93x_info_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
-{
-	static char *texts[4] = {
-		"Line1", "Aux", "Mic", "Mix"
-	};
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 2;
-	uinfo->value.enumerated.items = 4;
-	if (uinfo->value.enumerated.item > 3)
-		uinfo->value.enumerated.item = 3;
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
-	return 0;
-}
-
-static int snd_opti93x_get_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_opti93x *chip = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
-	
-	spin_lock_irqsave(&chip->lock, flags);
-	ucontrol->value.enumerated.item[0] = (chip->image[OPTi93X_MIXOUT_LEFT] & OPTi93X_MIXOUT_MIXER) >> 6;
-	ucontrol->value.enumerated.item[1] = (chip->image[OPTi93X_MIXOUT_RIGHT] & OPTi93X_MIXOUT_MIXER) >> 6;
-	spin_unlock_irqrestore(&chip->lock, flags);
-	return 0;
-}
-
-static int snd_opti93x_put_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_opti93x *chip = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
-	unsigned short left, right;
-	int change;
-	
-	if (ucontrol->value.enumerated.item[0] > 3 ||
-	    ucontrol->value.enumerated.item[1] > 3)
-		return -EINVAL;
-	left = ucontrol->value.enumerated.item[0] << 6;
-	right = ucontrol->value.enumerated.item[1] << 6;
-	spin_lock_irqsave(&chip->lock, flags);
-	left = (chip->image[OPTi93X_MIXOUT_LEFT] & ~OPTi93X_MIXOUT_MIXER) | left;
-	right = (chip->image[OPTi93X_MIXOUT_RIGHT] & ~OPTi93X_MIXOUT_MIXER) | right;
-	change = left != chip->image[OPTi93X_MIXOUT_LEFT] ||
-	         right != chip->image[OPTi93X_MIXOUT_RIGHT];
-	snd_opti93x_out_image(chip, OPTi93X_MIXOUT_LEFT, left);
-	snd_opti93x_out_image(chip, OPTi93X_MIXOUT_RIGHT, right);
-	spin_unlock_irqrestore(&chip->lock, flags);
-	return change;
-}
-
-#if 0
-
-#define OPTi93X_SINGLE(xname, xindex, reg, shift, mask, invert) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
-  .info = snd_opti93x_info_single, \
-  .get = snd_opti93x_get_single, .put = snd_opti93x_put_single, \
-  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }
-
-static int snd_opti93x_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
-{
-	int mask = (kcontrol->private_value >> 16) & 0xff;
-
-	uinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = mask;
-	return 0;
-}
-
-static int snd_opti93x_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_opti93x *chip = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
-	int reg = kcontrol->private_value & 0xff;
-	int shift = (kcontrol->private_value >> 8) & 0xff;
-	int mask = (kcontrol->private_value >> 16) & 0xff;
-	int invert = (kcontrol->private_value >> 24) & 0xff;
-	
-	spin_lock_irqsave(&chip->lock, flags);
-	ucontrol->value.integer.value[0] = (chip->image[reg] >> shift) & mask;
-	spin_unlock_irqrestore(&chip->lock, flags);
-	if (invert)
-		ucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];
-	return 0;
-}
-
-static int snd_opti93x_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_opti93x *chip = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
-	int reg = kcontrol->private_value & 0xff;
-	int shift = (kcontrol->private_value >> 8) & 0xff;
-	int mask = (kcontrol->private_value >> 16) & 0xff;
-	int invert = (kcontrol->private_value >> 24) & 0xff;
-	int change;
-	unsigned short val;
-	
-	val = (ucontrol->value.integer.value[0] & mask);
-	if (invert)
-		val = mask - val;
-	val <<= shift;
-	spin_lock_irqsave(&chip->lock, flags);
-	val = (chip->image[reg] & ~(mask << shift)) | val;
-	change = val != chip->image[reg];
-	snd_opti93x_out(chip, reg, val);
-	spin_unlock_irqrestore(&chip->lock, flags);
-	return change;
-}
-
-#endif /* single */
-
-#define OPTi93X_DOUBLE(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
-  .info = snd_opti93x_info_double, \
-  .get = snd_opti93x_get_double, .put = snd_opti93x_put_double, \
-  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22) }
-
-#define OPTi93X_DOUBLE_INVERT_INVERT(xctl) \
-	do { xctl.private_value ^= 22; } while (0)
-#define OPTi93X_DOUBLE_CHANGE_REGS(xctl, left_reg, right_reg) \
-	do { xctl.private_value &= ~0x0000ffff; \
-	     xctl.private_value |= left_reg | (right_reg << 8); } while (0)
-
-static int snd_opti93x_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
-{
-	int mask = (kcontrol->private_value >> 24) & 0xff;
-
-	uinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 2;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = mask;
-	return 0;
-}
-
-static int snd_opti93x_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_opti93x *chip = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
-	int left_reg = kcontrol->private_value & 0xff;
-	int right_reg = (kcontrol->private_value >> 8) & 0xff;
-	int shift_left = (kcontrol->private_value >> 16) & 0x07;
-	int shift_right = (kcontrol->private_value >> 19) & 0x07;
-	int mask = (kcontrol->private_value >> 24) & 0xff;
-	int invert = (kcontrol->private_value >> 22) & 1;
-	
-	spin_lock_irqsave(&chip->lock, flags);
-	ucontrol->value.integer.value[0] = (chip->image[left_reg] >> shift_left) & mask;
-	ucontrol->value.integer.value[1] = (chip->image[right_reg] >> shift_right) & mask;
-	spin_unlock_irqrestore(&chip->lock, flags);
-	if (invert) {
-		ucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];
-		ucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];
-	}
-	return 0;
-}
-
-static int snd_opti93x_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_opti93x *chip = snd_kcontrol_chip(kcontrol);
-	unsigned long flags;
-	int left_reg = kcontrol->private_value & 0xff;
-	int right_reg = (kcontrol->private_value >> 8) & 0xff;
-	int shift_left = (kcontrol->private_value >> 16) & 0x07;
-	int shift_right = (kcontrol->private_value >> 19) & 0x07;
-	int mask = (kcontrol->private_value >> 24) & 0xff;
-	int invert = (kcontrol->private_value >> 22) & 1;
-	int change;
-	unsigned short val1, val2;
-	
-	val1 = ucontrol->value.integer.value[0] & mask;
-	val2 = ucontrol->value.integer.value[1] & mask;
-	if (invert) {
-		val1 = mask - val1;
-		val2 = mask - val2;
-	}
-	val1 <<= shift_left;
-	val2 <<= shift_right;
-	spin_lock_irqsave(&chip->lock, flags);
-	val1 = (chip->image[left_reg] & ~(mask << shift_left)) | val1;
-	val2 = (chip->image[right_reg] & ~(mask << shift_right)) | val2;
-	change = val1 != chip->image[left_reg] || val2 != chip->image[right_reg];
-	snd_opti93x_out_image(chip, left_reg, val1);
-	snd_opti93x_out_image(chip, right_reg, val2);
-	spin_unlock_irqrestore(&chip->lock, flags);
-	return change;
-}
-
-static struct snd_kcontrol_new snd_opti93x_controls[] __devinitdata = {
-OPTi93X_DOUBLE("Master Playback Switch", 0, OPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 7, 7, 1, 1),
-OPTi93X_DOUBLE("Master Playback Volume", 0, OPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 1, 1, 31, 1), 
-OPTi93X_DOUBLE("PCM Playback Switch", 0, OPTi93X_DAC_LEFT, OPTi93X_DAC_RIGHT, 7, 7, 1, 1),
-OPTi93X_DOUBLE("PCM Playback Volume", 0, OPTi93X_DAC_LEFT, OPTi93X_DAC_RIGHT, 0, 0, 31, 1),
-OPTi93X_DOUBLE("FM Playback Switch", 0, OPTi931_FM_LEFT_INPUT, OPTi931_FM_RIGHT_INPUT, 7, 7, 1, 1),
-OPTi93X_DOUBLE("FM Playback Volume", 0, OPTi931_FM_LEFT_INPUT, OPTi931_FM_RIGHT_INPUT, 1, 1, 15, 1),
-OPTi93X_DOUBLE("Line Playback Switch", 0, OPTi93X_LINE_LEFT_INPUT, OPTi93X_LINE_RIGHT_INPUT, 7, 7, 1, 1),
-OPTi93X_DOUBLE("Line Playback Volume", 0, OPTi93X_LINE_LEFT_INPUT, OPTi93X_LINE_RIGHT_INPUT, 1, 1, 15, 1), 
-OPTi93X_DOUBLE("Mic Playback Switch", 0, OPTi93X_MIC_LEFT_INPUT, OPTi93X_MIC_RIGHT_INPUT, 7, 7, 1, 1),
-OPTi93X_DOUBLE("Mic Playback Volume", 0, OPTi93X_MIC_LEFT_INPUT, OPTi93X_MIC_RIGHT_INPUT, 1, 1, 15, 1), 
-OPTi93X_DOUBLE("Mic Boost", 0, OPTi93X_MIXOUT_LEFT, OPTi93X_MIXOUT_RIGHT, 5, 5, 1, 1),
-OPTi93X_DOUBLE("CD Playback Switch", 0, OPTi93X_CD_LEFT_INPUT, OPTi93X_CD_RIGHT_INPUT, 7, 7, 1, 1),
-OPTi93X_DOUBLE("CD Playback Volume", 0, OPTi93X_CD_LEFT_INPUT, OPTi93X_CD_RIGHT_INPUT, 1, 1, 15, 1),
-OPTi93X_DOUBLE("Aux Playback Switch", 0, OPTi931_AUX_LEFT_INPUT, OPTi931_AUX_RIGHT_INPUT, 7, 7, 1, 1),
-OPTi93X_DOUBLE("Aux Playback Volume", 0, OPTi931_AUX_LEFT_INPUT, OPTi931_AUX_RIGHT_INPUT, 1, 1, 15, 1), 
-OPTi93X_DOUBLE("Capture Volume", 0, OPTi93X_MIXOUT_LEFT, OPTi93X_MIXOUT_RIGHT, 0, 0, 15, 0),
-{
-	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-	.name = "Capture Source",
-	.info = snd_opti93x_info_mux,
-	.get = snd_opti93x_get_mux,
-	.put = snd_opti93x_put_mux,
-}
-};
-                                        
-static int __devinit snd_opti93x_mixer(struct snd_opti93x *chip)
-{
-	struct snd_card *card;
-	struct snd_kcontrol_new knew;
-	int err;
-	unsigned int idx;
-
-	snd_assert(chip != NULL && chip->card != NULL, return -EINVAL);
-
-	card = chip->card;
-
-	strcpy(card->mixername, snd_opti93x_chip_id(chip));
-
-	for (idx = 0; idx < ARRAY_SIZE(snd_opti93x_controls); idx++) {
-		knew = snd_opti93x_controls[idx];
-		if (chip->hardware == OPTi9XX_HW_82C930) {
-			if (strstr(knew.name, "FM"))	/* skip FM controls */
-				continue;
-			else if (strcmp(knew.name, "Mic Playback Volume"))
-				OPTi93X_DOUBLE_INVERT_INVERT(knew);
-			else if (strstr(knew.name, "Aux"))
-				OPTi93X_DOUBLE_CHANGE_REGS(knew, OPTi930_AUX_LEFT_INPUT, OPTi930_AUX_RIGHT_INPUT);
-			else if (strcmp(knew.name, "PCM Playback Volume"))
-				OPTi93X_DOUBLE_INVERT_INVERT(knew);
-			else if (strcmp(knew.name, "Master Playback Volume"))
-				OPTi93X_DOUBLE_INVERT_INVERT(knew);
-		}
-		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_opti93x_controls[idx], chip))) < 0)
-			return err;
-	}
-	return 0;
-}
-
 #endif /* OPTi93X */
 
 static int __devinit snd_card_opti9xx_detect(struct snd_card *card,
@@ -1739,8 +685,16 @@ static void snd_card_opti9xx_free(struct snd_card *card)
 {
 	struct snd_opti9xx *chip = card->private_data;
         
-	if (chip)
+	if (chip) {
+#ifdef OPTi93X
+		struct snd_cs4231 *codec = chip->codec;
+		if (codec->irq > 0) {
+			disable_irq(codec->irq);
+			free_irq(codec->irq, codec);
+		}
+#endif
 		release_and_free_resource(chip->res_mc_base);
+	}
 }
 
 static int __devinit snd_opti9xx_probe(struct snd_card *card)
@@ -1748,11 +702,11 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
 	int error;
 	struct snd_opti9xx *chip = card->private_data;
-#if defined(OPTi93X)
-	struct snd_opti93x *codec;
-#elif defined(CS4231)
+#if defined(CS4231) || defined(OPTi93X)
 	struct snd_cs4231 *codec;
+#ifdef CS4231
 	struct snd_timer *timer;
+#endif
 #else
 	struct snd_ad1848 *codec;
 #endif
@@ -1784,26 +738,34 @@ static int __devinit snd_opti9xx_probe(struct snd_card *card)
 	if ((error = snd_opti9xx_configure(chip)))
 		return error;
 
-#if defined(OPTi93X)
-	if ((error = snd_opti93x_create(card, chip, chip->dma1, chip->dma2, &codec)))
-		return error;
-	if ((error = snd_opti93x_pcm(codec, 0, &pcm)) < 0)
-		return error;
-	if ((error = snd_opti93x_mixer(codec)) < 0)
-		return error;
-#elif defined(CS4231)
+#if defined(CS4231) || defined(OPTi93X)
 	if ((error = snd_cs4231_create(card, chip->wss_base + 4, -1,
 				       chip->irq, chip->dma1, chip->dma2,
-				       CS4231_HW_DETECT,
-				       0,
+#ifdef CS4231
+				       CS4231_HW_DETECT, 0,
+#else /* OPTi93x */
+				       CS4231_HW_OPTI93X, CS4231_HWSHARE_IRQ,
+#endif
 				       &codec)) < 0)
 		return error;
+#ifdef OPTi93X
+	chip->codec = codec;
+#endif
 	if ((error = snd_cs4231_pcm(codec, 0, &pcm)) < 0)
 		return error;
 	if ((error = snd_cs4231_mixer(codec)) < 0)
 		return error;
+#ifdef CS4231
 	if ((error = snd_cs4231_timer(codec, 0, &timer)) < 0)
 		return error;
+#else /* OPTI93X */
+	error = request_irq(chip->irq, snd_opti93x_interrupt,
+			    IRQF_DISABLED, DEV_NAME" - WSS", codec);
+	if (error < 0) {
+		snd_printk(KERN_ERR "opti9xx: can't grab IRQ %d\n", chip->irq);
+		return error;
+	}
+#endif
 #else
 	if ((error = snd_ad1848_create(card, chip->wss_base + 4,
 				       chip->irq, chip->dma1,

commit 3ae5f36a368b143cfd8a6f7a988a012c1b46eda0
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Sun Jun 8 07:57:53 2008 +0200

    [ALSA] opti93x: fix sound ouput for Opti930
    
    This patch fixes silenced output from the Opti930.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index fe1afc13a01d..fc15b88364b4 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -491,16 +491,9 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 		break;
 
 #else	/* OPTi93X */
-	case OPTi9XX_HW_82C930:
 	case OPTi9XX_HW_82C931:
 	case OPTi9XX_HW_82C933:
-		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x03);
-		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(3), 0x00, 0xff);
-		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(4), 0x10 |
-			(chip->hardware == OPTi9XX_HW_82C930 ? 0x00 : 0x04),
-			0x34);
-		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x20, 0xbf);
-		/* 
+		/*
 		 * The BTC 1817DW has QS1000 wavetable which is connected
 		 * to the serial digital input of the OPTI931.
 		 */
@@ -510,6 +503,13 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 		 * or digital input signal.
 		 */
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(26), 0x01, 0x01);
+	case OPTi9XX_HW_82C930: /* FALL THROUGH */
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x03);
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(3), 0x00, 0xff);
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(4), 0x10 |
+			(chip->hardware == OPTi9XX_HW_82C930 ? 0x00 : 0x04),
+			0x34);
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x20, 0xbf);
 		break;
 #endif	/* OPTi93X */
 

commit 9478bc3bed1e15208f8041b44d45505cb93e6cc8
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed Jan 23 11:52:38 2008 +0100

    [ALSA] fix opti9xx/miro section mismatch
    
    snd_opti93x_mixer() is only called by __devinit snd_opti93x_probe(),
    so the former can also be __devinit.
    snd_miro_mixer() is only called by __devinit snd_miro_probe(),
    so the former can also be __devinit.
    sound/isa/opti9xx/opti92x-ad1848.c:
    WARNING: vmlinux.o(.text+0xf91cd7): Section mismatch: reference to .init.data:snd_opti93x_controls (between 'snd_opti93x_mixer' and 'snd_card_opti9xx_free')
    WARNING: vmlinux.o(.text+0xf91d66): Section mismatch: reference to .init.data:snd_miro_controls (between 'snd_opti93x_mixer' and 'snd_card_opti9xx_free')
    opti9xx/miro.c:
    WARNING: vmlinux.o(.text+0xf926c2): Section mismatch: reference to .init.data:snd_miro_controls (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf926e5): Section mismatch: reference to .init.data:snd_miro_eq_controls (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf926f9): Section mismatch: reference to .init.data:snd_miro_line_control (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf92716): Section mismatch: reference to .init.data:snd_miro_amp_control (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf9273e): Section mismatch: reference to .init.data:snd_miro_preamp_control (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf92764): Section mismatch: reference to .init.data:snd_miro_capture_control (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf92783): Section mismatch: reference to .init.data:snd_miro_radio_control (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf9279a): Section mismatch: reference to .init.data:snd_miro_eq_controls (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf927b9): Section mismatch: reference to .init.data:snd_miro_radio_control (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 1f9c55768439..fe1afc13a01d 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -1594,7 +1594,7 @@ OPTi93X_DOUBLE("Capture Volume", 0, OPTi93X_MIXOUT_LEFT, OPTi93X_MIXOUT_RIGHT, 0
 }
 };
                                         
-static int snd_opti93x_mixer(struct snd_opti93x *chip)
+static int __devinit snd_opti93x_mixer(struct snd_opti93x *chip)
 {
 	struct snd_card *card;
 	struct snd_kcontrol_new knew;

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 9300cf371ee8..1f9c55768439 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -23,7 +23,6 @@
 */
 
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/err.h>
 #include <linux/isa.h>

commit 109c53f840e551d6e99ecfd8b0131a968332c89f
Author: Rene Herman <rene.herman@gmail.com>
Date:   Fri Nov 30 17:59:25 2007 +0100

    [ALSA] sound/isa: kill pnp_resource_change
    
    This removes the pnp_resource_change use from the ALSA ISAPnP drivers. In
    2.4 these were useful in providing an easy path to setting the resources,
    but in 2.6 they retain function as a layering violation only.
    This makes for a nice cleanup (-550 lines) of ALSA but moreover, ALSA is the
    only remaining user of pnp_init_resource_table(), pnp_resource_change() and
    pnp_manual_config_dev() (and, in fact, of 'struct pnp_resource_table') in
    the tree outide of drivers/pnp itself meaning it makes for more cleanup
    potential inside the PnP layer.
    Thomas Renninger acked their removal from that side, you did from the ALSA
    side (CC list just copied from that thread).
    Against current alsa-kernel HG. Many more potential cleanups in there, but
    this _only_ removes the pnp_resource_change code. Compile tested against
    current alsa-kernel HG and compile- and use-tested against 2.6.23.x (few
    offsets).
    Cc: Thomas Renninger <trenn@suse.de>
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index ee1a824d8fc0..9300cf371ee8 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -1690,53 +1690,19 @@ static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip,
 					  const struct pnp_card_device_id *pid)
 {
 	struct pnp_dev *pdev;
-	struct pnp_resource_table *cfg = kmalloc(sizeof(*cfg), GFP_KERNEL);
 	int err;
 
-	if (!cfg)
-		return -ENOMEM;
 	chip->dev = pnp_request_card_device(card, pid->devs[0].id, NULL);
-	if (chip->dev == NULL) {
-		kfree(cfg);
+	if (chip->dev == NULL)
 		return -EBUSY;
-	}
+
 	chip->devmpu = pnp_request_card_device(card, pid->devs[1].id, NULL);
 
 	pdev = chip->dev;
-	pnp_init_resource_table(cfg);
 
-#ifdef OPTi93X
-	if (port != SNDRV_AUTO_PORT)
-		pnp_resource_change(&cfg->port_resource[0], port + 4, 4);
-#else
-	if (pid->driver_data != 0x0924 && port != SNDRV_AUTO_PORT)
-		pnp_resource_change(&cfg->port_resource[1], port, 4);
-#endif	/* OPTi93X */
-	if (irq != SNDRV_AUTO_IRQ)
-		pnp_resource_change(&cfg->irq_resource[0], irq, 1);
-	if (dma1 != SNDRV_AUTO_DMA)
-		pnp_resource_change(&cfg->dma_resource[0], dma1, 1);
-#if defined(CS4231) || defined(OPTi93X)
-	if (dma2 != SNDRV_AUTO_DMA)
-		pnp_resource_change(&cfg->dma_resource[1], dma2, 1);
-#else
-#ifdef snd_opti9xx_fixup_dma2
-	snd_opti9xx_fixup_dma2(pdev);
-#endif
-#endif	/* CS4231 || OPTi93X */
-#ifdef OPTi93X
-	if (fm_port > 0 && fm_port != SNDRV_AUTO_PORT)
-		pnp_resource_change(&cfg->port_resource[1], fm_port, 4);
-#else
-	if (fm_port > 0 && fm_port != SNDRV_AUTO_PORT)
-		pnp_resource_change(&cfg->port_resource[2], fm_port, 4);
-#endif
-	if (pnp_manual_config_dev(pdev, cfg, 0) < 0)
-		snd_printk(KERN_ERR "AUDIO the requested resources are invalid, using auto config\n");
 	err = pnp_activate_dev(pdev);
 	if (err < 0) {
 		snd_printk(KERN_ERR "AUDIO pnp configure failure: %d\n", err);
-		kfree(cfg);
 		return err;
 	}
 
@@ -1756,15 +1722,6 @@ static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip,
 
 	pdev = chip->devmpu;
 	if (pdev && mpu_port > 0) {
-		pnp_init_resource_table(cfg);
-
-		if (mpu_port != SNDRV_AUTO_PORT)
-			pnp_resource_change(&cfg->port_resource[0], mpu_port, 2);
-		if (mpu_irq != SNDRV_AUTO_IRQ)
-			pnp_resource_change(&cfg->irq_resource[0], mpu_irq, 1);
-
-		if (pnp_manual_config_dev(pdev, cfg, 0) < 0)
-			snd_printk(KERN_ERR "AUDIO the requested resources are invalid, using auto config\n");
 		err = pnp_activate_dev(pdev);
 		if (err < 0) {
 			snd_printk(KERN_ERR "AUDIO pnp configure failure\n");
@@ -1775,7 +1732,6 @@ static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip,
 			mpu_irq = pnp_irq(pdev, 0);
 		}
 	}
-	kfree(cfg);
 	return pid->driver_data;
 }
 #endif	/* CONFIG_PNP */

commit f81b953d43c2c12f617da3ecec25e04b5c9e6eb2
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Tue Oct 16 14:54:37 2007 +0200

    [ALSA] This patch adds support for a wavetable chip on
    
    the BTC 1817DW board.
    The QS1000 is connected through the digital input
    to the Opti931 chip.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index fb1d0704f2f9..ee1a824d8fc0 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -501,6 +501,16 @@ static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 			(chip->hardware == OPTi9XX_HW_82C930 ? 0x00 : 0x04),
 			0x34);
 		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x20, 0xbf);
+		/* 
+		 * The BTC 1817DW has QS1000 wavetable which is connected
+		 * to the serial digital input of the OPTI931.
+		 */
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(21), 0x82, 0xff);
+		/* 
+		 * This bit sets OPTI931 to automaticaly select FM
+		 * or digital input signal.
+		 */
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(26), 0x01, 0x01);
 		break;
 #endif	/* OPTi93X */
 

commit 1ea73412b27ddd88decbdafb83bb2bfc288fe56c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 17 16:44:06 2007 +0200

    [ALSA] opti9xx: adjust OPL3 FM resource value
    
    The OPTi ISA-PnP chips advertise their OPL4 base at 0x380 (to 0x3f0) through
    pnp and put their on-chip OPL3 at +8. The driver assumes the provided
    value is the ALBase (OPL3 address) though and checks for an OPL4 at -8,
    which means that simply adding 8 to the pnp provides value works to fix
    detection of both OPL3 and OPL4.
    Problem spotted on 931 and 933 by Krzysztof Helt and confirmed on 924 and
    925 (together all OPTi ISA-PnP chips) by me.
    Signed-off-by; Rene Herman <rene.herman@gmail.com>
    Acked-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 049d479ce2b3..fb1d0704f2f9 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -1732,11 +1732,11 @@ static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip,
 
 #ifdef OPTi93X
 	port = pnp_port_start(pdev, 0) - 4;
-	fm_port = pnp_port_start(pdev, 1);
+	fm_port = pnp_port_start(pdev, 1) + 8;
 #else
 	if (pid->driver_data != 0x0924)
 		port = pnp_port_start(pdev, 1);
-	fm_port = pnp_port_start(pdev, 2);
+	fm_port = pnp_port_start(pdev, 2) + 8;
 #endif	/* OPTi93X */
 	irq = pnp_irq(pdev, 0);
 	dma1 = pnp_dma(pdev, 0);

commit 101f6f4ba7109aafd7b3f2eafd7124f854dda451
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 20 12:03:09 2007 +0200

    [ALSA] Fix unfreed pnp driver in opti9xx ISA driver
    
    - Added the missing pnp_unregister_card_driver() in the case ISA PnP
      isn't found, which caused an error at kobject_add with -EEXIST
       Jun 11 09:07:31 rain kernel: kobject_add failed for opti9xx with -EEXIST, don't try to register things with the same name in the same directory.
       Jun 11 09:07:31 rain kernel:  [<c01c18fa>] kobject_shadow_add+0x12a/0x1c0
       Jun 11 09:07:31 rain kernel:  [<c01c1a81>] kobject_register+0x21/0x50
       Jun 11 09:07:31 rain kernel:  [<c01f09a2>] bus_add_driver+0x72/0x1b0
       Jun 11 09:07:31 rain kernel:  [<c01d3dff>] pnp_register_card_driver+0x4f/0xc0
       Jun 11 09:07:31 rain kernel:  [<c89bc00a>] alsa_card_opti9xx_init+0xa/0x25 [snd_opti92x_ad1848]
       Jun 11 09:07:31 rain kernel:  [<c0136947>] sys_init_module+0x157/0x1610
       Jun 11 09:07:31 rain kernel:  [<c01029b4>] syscall_call+0x7/0xb
    - Fixed the probe behavior when no PnP is set up.  Now it behaves
      like the former version.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 60c120ffb9de..049d479ce2b3 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -1927,10 +1927,12 @@ static struct snd_card *snd_opti9xx_card_new(void)
 static int __devinit snd_opti9xx_isa_match(struct device *devptr,
 					   unsigned int dev)
 {
+#ifdef CONFIG_PNP
 	if (snd_opti9xx_pnp_is_probed)
 		return 0;
 	if (isapnp)
 		return 0;
+#endif
 	return 1;
 }
 
@@ -2096,6 +2098,7 @@ static int __init alsa_card_opti9xx_init(void)
 	pnp_register_card_driver(&opti9xx_pnpc_driver);
 	if (snd_opti9xx_pnp_is_probed)
 		return 0;
+	pnp_unregister_card_driver(&opti9xx_pnpc_driver);
 #endif
 	return isa_register_driver(&snd_opti9xx_driver, 1);
 }

commit 83c51c0ab08f55468d8f5444ff2f70a36841a21f
Author: Rene Herman <rene.herman@gmail.com>
Date:   Tue Mar 20 11:33:46 2007 +0100

    [ALSA] isa_bus device/driver naming
    
    isa_bus: delete snd_ prefix from the (sysfs visible) device/driver names.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 95d0ab124d5b..60c120ffb9de 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -280,10 +280,10 @@ MODULE_DEVICE_TABLE(pnp_card, snd_opti9xx_pnpids);
 #endif	/* CONFIG_PNP */
 
 #ifdef OPTi93X
-#define DRIVER_NAME	"snd-card-opti93x"
+#define DEV_NAME "opti93x"
 #else
-#define DRIVER_NAME	"snd-card-opti92x"
-#endif	/* OPTi93X */
+#define DEV_NAME "opti92x"
+#endif
 
 static char * snd_opti9xx_names[] = {
 	"unkown",
@@ -1289,7 +1289,7 @@ static int snd_opti93x_create(struct snd_card *card, struct snd_opti9xx *chip,
 	}
 	codec->dma2 = chip->dma2;
 
-	if (request_irq(chip->irq, snd_opti93x_interrupt, IRQF_DISABLED, DRIVER_NAME" - WSS", codec)) {
+	if (request_irq(chip->irq, snd_opti93x_interrupt, IRQF_DISABLED, DEV_NAME" - WSS", codec)) {
 		snd_printk(KERN_ERR "opti9xx: can't grab IRQ %d\n", chip->irq);
 		snd_opti93x_free(codec);
 		return -EBUSY;
@@ -2015,7 +2015,7 @@ static struct isa_driver snd_opti9xx_driver = {
 	.remove		= __devexit_p(snd_opti9xx_isa_remove),
 	/* FIXME: suspend/resume */
 	.driver		= {
-		.name	= DRIVER_NAME
+		.name	= DEV_NAME
 	},
 };
 

commit ef991b95aa1351a5782cfaccb9aefba76ca8b990
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 22 12:52:53 2007 +0100

    [ALSA] Add snd_pcm_group_for_each_entry() for code cleanup
    
    Added a new macro snd_pcm_group_for_each_entry() just for code cleanup.
    Old macros, snd_pcm_group_for_each() and snd_pcm_group_substream_entry(),
    are removed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 1c390580bd50..95d0ab124d5b 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -934,10 +934,8 @@ static int snd_opti93x_trigger(struct snd_pcm_substream *substream,
 	case SNDRV_PCM_TRIGGER_STOP:
 	{
 		unsigned int what = 0;
-		struct list_head *pos;
 		struct snd_pcm_substream *s;
-		snd_pcm_group_for_each(pos, substream) {
-			s = snd_pcm_group_substream_entry(pos);
+		snd_pcm_group_for_each_entry(s, substream) {
 			if (s == chip->playback_substream) {
 				what |= OPTi93X_PLAYBACK_ENABLE;
 				snd_pcm_trigger_done(s, substream);

commit 5e24c1c1c496c4603395d6e9cc320f85008fc891
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 22 12:50:54 2007 +0100

    [ALSA] Port the rest of ALSA ISA drivers to isa_driver
    
    Port the rest of ALSA ISA drivers to use isa_driver framework
    instead of platform_driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index df227377c333..1c390580bd50 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -26,7 +26,7 @@
 #include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/err.h>
-#include <linux/platform_device.h>
+#include <linux/isa.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/pnp.h>
@@ -259,7 +259,6 @@ struct snd_opti9xx {
 };
 
 static int snd_opti9xx_pnp_is_probed;
-static struct platform_device *snd_opti9xx_platform_device;
 
 #ifdef CONFIG_PNP
 
@@ -294,7 +293,7 @@ static char * snd_opti9xx_names[] = {
 };
 
 
-static long __init snd_legacy_find_free_ioport(long *port_table, long size)
+static long __devinit snd_legacy_find_free_ioport(long *port_table, long size)
 {
 	while (*port_table != -1) {
 		if (request_region(*port_table, size, "ALSA test")) {
@@ -306,7 +305,8 @@ static long __init snd_legacy_find_free_ioport(long *port_table, long size)
 	return -1;
 }
 
-static int __init snd_opti9xx_init(struct snd_opti9xx *chip, unsigned short hardware)
+static int __devinit snd_opti9xx_init(struct snd_opti9xx *chip,
+				      unsigned short hardware)
 {
 	static int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};
 
@@ -451,7 +451,7 @@ static void snd_opti9xx_write(struct snd_opti9xx *chip, unsigned char reg,
 		(snd_opti9xx_read(chip, reg) & ~(mask)) | ((value) & (mask)))
 
 
-static int __init snd_opti9xx_configure(struct snd_opti9xx *chip)
+static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 {
 	unsigned char wss_base_bits;
 	unsigned char irq_bits;
@@ -1561,7 +1561,7 @@ static int snd_opti93x_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_
 	return change;
 }
 
-static struct snd_kcontrol_new snd_opti93x_controls[] = {
+static struct snd_kcontrol_new snd_opti93x_controls[] __devinitdata = {
 OPTi93X_DOUBLE("Master Playback Switch", 0, OPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 7, 7, 1, 1),
 OPTi93X_DOUBLE("Master Playback Volume", 0, OPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 1, 1, 31, 1), 
 OPTi93X_DOUBLE("PCM Playback Switch", 0, OPTi93X_DAC_LEFT, OPTi93X_DAC_RIGHT, 7, 7, 1, 1),
@@ -1622,7 +1622,8 @@ static int snd_opti93x_mixer(struct snd_opti93x *chip)
 
 #endif /* OPTi93X */
 
-static int __init snd_card_opti9xx_detect(struct snd_card *card, struct snd_opti9xx *chip)
+static int __devinit snd_card_opti9xx_detect(struct snd_card *card,
+					     struct snd_opti9xx *chip)
 {
 	int i, err;
 
@@ -1676,8 +1677,9 @@ static int __init snd_card_opti9xx_detect(struct snd_card *card, struct snd_opti
 }
 
 #ifdef CONFIG_PNP
-static int __init snd_card_opti9xx_pnp(struct snd_opti9xx *chip, struct pnp_card_link *card,
-				       const struct pnp_card_device_id *pid)
+static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip,
+					  struct pnp_card_link *card,
+					  const struct pnp_card_device_id *pid)
 {
 	struct pnp_dev *pdev;
 	struct pnp_resource_table *cfg = kmalloc(sizeof(*cfg), GFP_KERNEL);
@@ -1778,7 +1780,7 @@ static void snd_card_opti9xx_free(struct snd_card *card)
 		release_and_free_resource(chip->res_mc_base);
 }
 
-static int __init snd_opti9xx_probe(struct snd_card *card)
+static int __devinit snd_opti9xx_probe(struct snd_card *card)
 {
 	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
 	int error;
@@ -1924,7 +1926,18 @@ static struct snd_card *snd_opti9xx_card_new(void)
 	return card;
 }
 
-static int __init snd_opti9xx_nonpnp_probe(struct platform_device *devptr)
+static int __devinit snd_opti9xx_isa_match(struct device *devptr,
+					   unsigned int dev)
+{
+	if (snd_opti9xx_pnp_is_probed)
+		return 0;
+	if (isapnp)
+		return 0;
+	return 1;
+}
+
+static int __devinit snd_opti9xx_isa_probe(struct device *devptr,
+					   unsigned int dev)
 {
 	struct snd_card *card;
 	int error;
@@ -1940,9 +1953,6 @@ static int __init snd_opti9xx_nonpnp_probe(struct platform_device *devptr)
 	static int possible_dma2s[][2] = {{1,-1}, {0,-1}, {-1,-1}, {0,-1}};
 #endif	/* CS4231 || OPTi93X */
 
-	if (snd_opti9xx_pnp_is_probed)
-		return -EBUSY;
-
 	if (mpu_port == SNDRV_AUTO_PORT) {
 		if ((mpu_port = snd_legacy_find_free_ioport(possible_mpu_ports, 2)) < 0) {
 			snd_printk(KERN_ERR "unable to find a free MPU401 port\n");
@@ -1984,25 +1994,27 @@ static int __init snd_opti9xx_nonpnp_probe(struct platform_device *devptr)
 		snd_card_free(card);
 		return error;
 	}
-	snd_card_set_dev(card, &devptr->dev);
+	snd_card_set_dev(card, devptr);
 	if ((error = snd_opti9xx_probe(card)) < 0) {
 		snd_card_free(card);
 		return error;
 	}
-	platform_set_drvdata(devptr, card);
+	dev_set_drvdata(devptr, card);
 	return 0;
 }
 
-static int __devexit snd_opti9xx_nonpnp_remove(struct platform_device *devptr)
+static int __devexit snd_opti9xx_isa_remove(struct device *devptr,
+					    unsigned int dev)
 {
-	snd_card_free(platform_get_drvdata(devptr));
-	platform_set_drvdata(devptr, NULL);
+	snd_card_free(dev_get_drvdata(devptr));
+	dev_set_drvdata(devptr, NULL);
 	return 0;
 }
 
-static struct platform_driver snd_opti9xx_driver = {
-	.probe		= snd_opti9xx_nonpnp_probe,
-	.remove		= __devexit_p(snd_opti9xx_nonpnp_remove),
+static struct isa_driver snd_opti9xx_driver = {
+	.match		= snd_opti9xx_isa_match,
+	.probe		= snd_opti9xx_isa_probe,
+	.remove		= __devexit_p(snd_opti9xx_isa_remove),
 	/* FIXME: suspend/resume */
 	.driver		= {
 		.name	= DRIVER_NAME
@@ -2010,8 +2022,8 @@ static struct platform_driver snd_opti9xx_driver = {
 };
 
 #ifdef CONFIG_PNP
-static int __init snd_opti9xx_pnp_probe(struct pnp_card_link *pcard,
-					const struct pnp_card_device_id *pid)
+static int __devinit snd_opti9xx_pnp_probe(struct pnp_card_link *pcard,
+					   const struct pnp_card_device_id *pid)
 {
 	struct snd_card *card;
 	int error, hw;
@@ -2074,11 +2086,6 @@ static struct pnp_card_driver opti9xx_pnpc_driver = {
 };
 #endif
 
-#ifdef CONFIG_PNP
-#define is_isapnp_selected()	isapnp
-#else
-#define is_isapnp_selected()	0
-#endif
 #ifdef OPTi93X
 #define CHIP_NAME	"82C93x"
 #else
@@ -2087,42 +2094,19 @@ static struct pnp_card_driver opti9xx_pnpc_driver = {
 
 static int __init alsa_card_opti9xx_init(void)
 {
-	int error;
-	struct platform_device *device;
-
 #ifdef CONFIG_PNP
 	pnp_register_card_driver(&opti9xx_pnpc_driver);
 	if (snd_opti9xx_pnp_is_probed)
 		return 0;
 #endif
-	if (! is_isapnp_selected()) {
-		error = platform_driver_register(&snd_opti9xx_driver);
-		if (error < 0)
-			return error;
-		device = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0);
-		if (!IS_ERR(device)) {
-			if (platform_get_drvdata(device)) {
-				snd_opti9xx_platform_device = device;
-				return 0;
-			}
-			platform_device_unregister(device);
-		}
-		platform_driver_unregister(&snd_opti9xx_driver);
-	}
-#ifdef CONFIG_PNP
-	pnp_unregister_card_driver(&opti9xx_pnpc_driver);
-#endif
-#ifdef MODULE
-	printk(KERN_ERR "no OPTi " CHIP_NAME " soundcard found\n");
-#endif
-	return -ENODEV;
+	return isa_register_driver(&snd_opti9xx_driver, 1);
 }
 
 static void __exit alsa_card_opti9xx_exit(void)
 {
 	if (!snd_opti9xx_pnp_is_probed) {
-		platform_device_unregister(snd_opti9xx_platform_device);
-		platform_driver_unregister(&snd_opti9xx_driver);
+		isa_unregister_driver(&snd_opti9xx_driver);
+		return;
 	}
 #ifdef CONFIG_PNP
 	pnp_unregister_card_driver(&opti9xx_pnpc_driver);

commit 5019f75ea1a98c36e9139ffb2bf8614a2e9f0a03
Author: Amit Choudhary <amit2030@gmail.com>
Date:   Mon Oct 9 16:04:34 2006 +0200

    [ALSA] sound/isa/opti9xx/opti92x-ad1848.c: check kmalloc() return value
    
    Check the return value of kmalloc() in function snd_card_opti9xx_pnp(),
    in file sound/isa/opti9xx/opti92x-ad1848.c.
    
    Signed-off-by: Amit Choudhary <amit2030@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index a1ad39a8cdce..df227377c333 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -1683,6 +1683,8 @@ static int __init snd_card_opti9xx_pnp(struct snd_opti9xx *chip, struct pnp_card
 	struct pnp_resource_table *cfg = kmalloc(sizeof(*cfg), GFP_KERNEL);
 	int err;
 
+	if (!cfg)
+		return -ENOMEM;
 	chip->dev = pnp_request_card_device(card, pid->devs[0].id, NULL);
 	if (chip->dev == NULL) {
 		kfree(cfg);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 9d528ae00bff..a1ad39a8cdce 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -1090,7 +1090,7 @@ static void snd_opti93x_overrange(struct snd_opti93x *chip)
 	spin_unlock_irqrestore(&chip->lock, flags);
 }
 
-static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id)
 {
 	struct snd_opti93x *codec = dev_id;
 	unsigned char status;

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 8ee0d70536f9..9d528ae00bff 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -1291,7 +1291,7 @@ static int snd_opti93x_create(struct snd_card *card, struct snd_opti9xx *chip,
 	}
 	codec->dma2 = chip->dma2;
 
-	if (request_irq(chip->irq, snd_opti93x_interrupt, SA_INTERRUPT, DRIVER_NAME" - WSS", codec)) {
+	if (request_irq(chip->irq, snd_opti93x_interrupt, IRQF_DISABLED, DRIVER_NAME" - WSS", codec)) {
 		snd_printk(KERN_ERR "opti9xx: can't grab IRQ %d\n", chip->irq);
 		snd_opti93x_free(codec);
 		return -EBUSY;
@@ -1863,7 +1863,7 @@ static int __init snd_opti9xx_probe(struct snd_card *card)
 		rmidi = NULL;
 	else
 		if ((error = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
-				chip->mpu_port, 0, chip->mpu_irq, SA_INTERRUPT,
+				chip->mpu_port, 0, chip->mpu_irq, IRQF_DISABLED,
 				&rmidi)))
 			snd_printk(KERN_WARNING "no MPU-401 device at 0x%lx?\n",
 				   chip->mpu_port);

commit dcccdd938ef0c5d96145957217b814b14bd46cdc
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Tue Apr 11 14:09:37 2006 +0200

    [ALSA] unregister platform device again if probe was unsuccessful
    
    Unregister the platform device again if the probe was unsuccessful.
    
    This restores the behaviour of not loading the driver on probe() failure.
    
    Signed-off-by: Rene Herman <rene.herman@keyaccess.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 65b28cbc0ebd..8ee0d70536f9 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -2099,8 +2099,11 @@ static int __init alsa_card_opti9xx_init(void)
 			return error;
 		device = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0);
 		if (!IS_ERR(device)) {
-			snd_opti9xx_platform_device = device;
-			return 0;
+			if (platform_get_drvdata(device)) {
+				snd_opti9xx_platform_device = device;
+				return 0;
+			}
+			platform_device_unregister(device);
 		}
 		platform_driver_unregister(&snd_opti9xx_driver);
 	}

commit 0bbbc4ca7e2459f2750bd4bd8dda2ccbf7a71f02
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 27 17:23:46 2006 +0100

    [ALSA] opti9x - Fix compile without CONFIG_PNP
    
    Modules: Opti9xx drivers
    
    Fix compile errors without CONFIG_PNP.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 63d96be11b2b..65b28cbc0ebd 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -2088,9 +2088,11 @@ static int __init alsa_card_opti9xx_init(void)
 	int error;
 	struct platform_device *device;
 
+#ifdef CONFIG_PNP
 	pnp_register_card_driver(&opti9xx_pnpc_driver);
 	if (snd_opti9xx_pnp_is_probed)
 		return 0;
+#endif
 	if (! is_isapnp_selected()) {
 		error = platform_driver_register(&snd_opti9xx_driver);
 		if (error < 0)
@@ -2102,7 +2104,9 @@ static int __init alsa_card_opti9xx_init(void)
 		}
 		platform_driver_unregister(&snd_opti9xx_driver);
 	}
+#ifdef CONFIG_PNP
 	pnp_unregister_card_driver(&opti9xx_pnpc_driver);
+#endif
 #ifdef MODULE
 	printk(KERN_ERR "no OPTi " CHIP_NAME " soundcard found\n");
 #endif
@@ -2115,7 +2119,9 @@ static void __exit alsa_card_opti9xx_exit(void)
 		platform_device_unregister(snd_opti9xx_platform_device);
 		platform_driver_unregister(&snd_opti9xx_driver);
 	}
+#ifdef CONFIG_PNP
 	pnp_unregister_card_driver(&opti9xx_pnpc_driver);
+#endif
 }
 
 module_init(alsa_card_opti9xx_init)

commit 91134859702e66e5946383f66e6eb50ba4325458
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 23 15:21:05 2006 +0100

    [ALSA] opti93x - Fix a compile warning
    
    Modules: Opti9xx drivers
    
    Fix a gcc-4.1 compile warning regarding uninitialized variables.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 1ea3944ef7ab..63d96be11b2b 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -1349,7 +1349,7 @@ static int snd_opti93x_pcm(struct snd_opti93x *codec, int device, struct snd_pcm
 	int error;
 	struct snd_pcm *pcm;
 
-	if ((error = snd_pcm_new(codec->card, "OPTi 82C93X", device, 1, 1, &pcm)))
+	if ((error = snd_pcm_new(codec->card, "OPTi 82C93X", device, 1, 1, &pcm)) < 0)
 		return error;
 
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_opti93x_playback_ops);

commit f7a9275d949cb0bf1f259a1546e52a0bf518151c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Dec 7 09:13:42 2005 +0100

    [ALSA] unregister platform devices
    
    Call platform_device_unregister() for all platform devices that we've
    registered.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 39211e58cd68..1ea3944ef7ab 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -259,6 +259,7 @@ struct snd_opti9xx {
 };
 
 static int snd_opti9xx_pnp_is_probed;
+static struct platform_device *snd_opti9xx_platform_device;
 
 #ifdef CONFIG_PNP
 
@@ -2095,8 +2096,10 @@ static int __init alsa_card_opti9xx_init(void)
 		if (error < 0)
 			return error;
 		device = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0);
-		if (! IS_ERR(device))
+		if (!IS_ERR(device)) {
+			snd_opti9xx_platform_device = device;
 			return 0;
+		}
 		platform_driver_unregister(&snd_opti9xx_driver);
 	}
 	pnp_unregister_card_driver(&opti9xx_pnpc_driver);
@@ -2108,8 +2111,10 @@ static int __init alsa_card_opti9xx_init(void)
 
 static void __exit alsa_card_opti9xx_exit(void)
 {
-	if (! snd_opti9xx_pnp_is_probed)
+	if (!snd_opti9xx_pnp_is_probed) {
+		platform_device_unregister(snd_opti9xx_platform_device);
 		platform_driver_unregister(&snd_opti9xx_driver);
+	}
 	pnp_unregister_card_driver(&opti9xx_pnpc_driver);
 }
 

commit 99a0b7687ef991a577506a1974be146f02f18d74
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 17:13:59 2005 +0100

    [ALSA] opti9xx - Use platform_device
    
    Modules: Opti9xx drivers
    
    Rewrite the probe/remove with platform_device.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index fddf7b9549ba..39211e58cd68 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -24,13 +24,15 @@
 
 
 #include <sound/driver.h>
-#include <asm/io.h>
-#include <asm/dma.h>
-#include <linux/delay.h>
 #include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/pnp.h>
 #include <linux/moduleparam.h>
+#include <asm/io.h>
+#include <asm/dma.h>
 #include <sound/core.h>
 #ifdef CS4231
 #include <sound/cs4231.h>
@@ -256,8 +258,7 @@ struct snd_opti9xx {
 #endif	/* CONFIG_PNP */
 };
 
-static int snd_opti9xx_first_hit = 1;
-static struct snd_card *snd_opti9xx_legacy = SNDRV_DEFAULT_PTR1;
+static int snd_opti9xx_pnp_is_probed;
 
 #ifdef CONFIG_PNP
 
@@ -292,7 +293,7 @@ static char * snd_opti9xx_names[] = {
 };
 
 
-static long snd_legacy_find_free_ioport(long *port_table, long size)
+static long __init snd_legacy_find_free_ioport(long *port_table, long size)
 {
 	while (*port_table != -1) {
 		if (request_region(*port_table, size, "ALSA test")) {
@@ -304,7 +305,7 @@ static long snd_legacy_find_free_ioport(long *port_table, long size)
 	return -1;
 }
 
-static int __devinit snd_opti9xx_init(struct snd_opti9xx *chip, unsigned short hardware)
+static int __init snd_opti9xx_init(struct snd_opti9xx *chip, unsigned short hardware)
 {
 	static int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};
 
@@ -449,7 +450,7 @@ static void snd_opti9xx_write(struct snd_opti9xx *chip, unsigned char reg,
 		(snd_opti9xx_read(chip, reg) & ~(mask)) | ((value) & (mask)))
 
 
-static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
+static int __init snd_opti9xx_configure(struct snd_opti9xx *chip)
 {
 	unsigned char wss_base_bits;
 	unsigned char irq_bits;
@@ -1620,7 +1621,7 @@ static int snd_opti93x_mixer(struct snd_opti93x *chip)
 
 #endif /* OPTi93X */
 
-static int __devinit snd_card_opti9xx_detect(struct snd_card *card, struct snd_opti9xx *chip)
+static int __init snd_card_opti9xx_detect(struct snd_card *card, struct snd_opti9xx *chip)
 {
 	int i, err;
 
@@ -1674,8 +1675,8 @@ static int __devinit snd_card_opti9xx_detect(struct snd_card *card, struct snd_o
 }
 
 #ifdef CONFIG_PNP
-static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip, struct pnp_card_link *card,
-					  const struct pnp_card_device_id *pid)
+static int __init snd_card_opti9xx_pnp(struct snd_opti9xx *chip, struct pnp_card_link *card,
+				       const struct pnp_card_device_id *pid)
 {
 	struct pnp_dev *pdev;
 	struct pnp_resource_table *cfg = kmalloc(sizeof(*cfg), GFP_KERNEL);
@@ -1766,128 +1767,19 @@ static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip, struct pnp_c
 }
 #endif	/* CONFIG_PNP */
 
-#if 0
-static int __devinit snd_card_opti9xx_resources(struct snd_card_opti9xx *chip,
-						struct snd_card *card)
-{
-	int error, i, pnp = 0;
-
-#ifdef CONFIG_PNP
-	pnp = chip->dev != NULL;
-#endif	/* CONFIG_PNP */
-
-#ifndef OPTi93X
-	if (chip->chip->hardware == OPTi9XX_HW_82C928)
-		mpu_port = -1;
-#endif	/* OPTi93X */
-	error = 0;
-	if (!pnp && (mpu_port == SNDRV_DEFAULT_PORT1)) {
-		for (i = 0; possible_mpu_ports[i] != -1; i++)
-			if (!snd_register_ioport(card, possible_mpu_ports[i], 2,
-					DRIVER_NAME" - MPU-401", NULL)) {
-				mpu_port = possible_mpu_ports[i];
-				break;
-			}
-		if (mpu_port == SNDRV_DEFAULT_PORT1)
-			error = -EBUSY;
-	}
-	else
-		error = (mpu_port == -1) ? -ENODEV :
-			snd_register_ioport(card, mpu_port, 2,
-			DRIVER_NAME" - MPU-401", NULL);
-	if (error)
-		chip->chip->mpu_port = -1;
-	else if (pnp && (irq == mpu_irq))
-		chip->chip->mpu_irq = mpu_irq;
-	else if (!snd_register_interrupt(card,
-			DRIVER_NAME" - MPU-401",
-			mpu_irq, SNDRV_IRQ_TYPE_ISA,
-			snd_card_opti9xx_mpu_interrupt, chip,
-			pnp ? no_alternatives : possible_mpu_irqs,
-			&chip->mpuirqptr)) {
-		chip->chip->mpu_port = mpu_port;
-		chip->chip->mpu_irq = chip->mpuirqptr->irq;
-	}
-	else
-		chip->chip->mpu_port = -1;
-
-	if (!pnp && (port == SNDRV_DEFAULT_PORT1)) {
-		for (i = 0; possible_ports[i] != -1; i++)
-			if (!snd_register_ioport(card, possible_ports[i], 8,
-					DRIVER_NAME" - WSS", NULL)) {
-				port = possible_ports[i];
-				break;
-			}
-		if (port == SNDRV_DEFAULT_PORT1)
-			return -EBUSY;
-	}
-	else if ((error = snd_register_ioport(card, port, 8,
-			DRIVER_NAME" - WSS", NULL)) < 0)
-		return error;
-	chip->chip->wss_base = port;
-	if ((error = snd_register_interrupt(card, DRIVER_NAME" - WSS",
-			irq, SNDRV_IRQ_TYPE_ISA,
-			snd_card_opti9xx_interrupt, chip,
-			pnp ? no_alternatives : possible_irqs,
-			&chip->irqptr)) < 0)
-		return error;
-	chip->chip->irq = chip->irqptr->irq;
-	if ((error = snd_register_dma_channel(card,
-#if defined(CS4231) || defined(OPTi93X)
-			DRIVER_NAME" - WSS playback",
-#else
-			DRIVER_NAME" - WSS",
-#endif	/* CS4231 || OPTi93X */
-			dma1, SNDRV_DMA_TYPE_ISA, dma1_size,
-			pnp ? no_alternatives : possible_dma1s,
-			&chip->dma1ptr)) < 0)
-		return error;
-	chip->chip->dma1 = chip->dma1ptr->dma;
-#if defined(CS4231) || defined(OPTi93X)
-	if ((error = snd_register_dma_channel(card, DRIVER_NAME" - WSS capture",
-			dma2, SNDRV_DMA_TYPE_ISA, dma2_size,
-			pnp ? no_alternatives :
-				possible_dma2s[chip->dma1ptr->dma],
-			&chip->dma2ptr)) < 0)
-		return error;
-	chip->chip->dma2 = chip->dma2ptr->dma;
-#endif	/* CS4231 || OPTi93X */
-
-	if (snd_register_ioport(card,
-			pnp ? fm_port : fm_port = 0x388, 4,
-			DRIVER_NAME" - OPL", NULL) < 0)
-		fm_port = -1;
-	chip->chip->fm_port = fm_port;
-
-	return 0;
-}
-#endif
-
 static void snd_card_opti9xx_free(struct snd_card *card)
 {
-	struct snd_opti9xx *chip = (struct snd_opti9xx *)card->private_data;
+	struct snd_opti9xx *chip = card->private_data;
         
 	if (chip)
 		release_and_free_resource(chip->res_mc_base);
 }
 
-static int snd_card_opti9xx_probe(struct pnp_card_link *pcard,
-				  const struct pnp_card_device_id *pid)
+static int __init snd_opti9xx_probe(struct snd_card *card)
 {
 	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
-	static long possible_mpu_ports[] = {0x300, 0x310, 0x320, 0x330, -1};
-#ifdef OPTi93X
-	static int possible_irqs[] = {5, 9, 10, 11, 7, -1};
-#else
-	static int possible_irqs[] = {9, 10, 11, 7, -1};
-#endif	/* OPTi93X */
-	static int possible_mpu_irqs[] = {5, 9, 10, 7, -1};
-	static int possible_dma1s[] = {3, 1, 0, -1};
-#if defined(CS4231) || defined(OPTi93X)
-	static int possible_dma2s[][2] = {{1,-1}, {0,-1}, {-1,-1}, {0,-1}};
-#endif	/* CS4231 || OPTi93X */
 	int error;
-	struct snd_opti9xx *chip;
+	struct snd_opti9xx *chip = card->private_data;
 #if defined(OPTi93X)
 	struct snd_opti93x *codec;
 #elif defined(CS4231)
@@ -1896,65 +1788,14 @@ static int snd_card_opti9xx_probe(struct pnp_card_link *pcard,
 #else
 	struct snd_ad1848 *codec;
 #endif
-	struct snd_card *card;
 	struct snd_pcm *pcm;
 	struct snd_rawmidi *rmidi;
 	struct snd_hwdep *synth;
-#ifdef CONFIG_PNP
-	int hw;
-#endif	/* CONFIG_PNP */
-
-	if (pcard && !snd_opti9xx_first_hit)
-		return -EBUSY;
-	if (!(card = snd_card_new(index, id, THIS_MODULE,
-				  sizeof(struct snd_opti9xx))))
-		return -ENOMEM;
-	card->private_free = snd_card_opti9xx_free;
-	chip = (struct snd_opti9xx *)card->private_data;
-
-#ifdef CONFIG_PNP
-	if (isapnp && pcard && (hw = snd_card_opti9xx_pnp(chip, pcard, pid)) > 0) {
-		switch (hw) {
-		case 0x0924:
-			hw = OPTi9XX_HW_82C924;
-			break;
-		case 0x0925:
-			hw = OPTi9XX_HW_82C925;
-			break;
-		case 0x0931:
-			hw = OPTi9XX_HW_82C931;
-			break;
-		default:
-			snd_card_free(card);
-			return -ENODEV;
-		}
-
-		if ((error = snd_opti9xx_init(chip, hw))) {
-			snd_card_free(card);
-			return error;
-		}
-		if (hw <= OPTi9XX_HW_82C930)
-			chip->mc_base -= 0x80;
-		snd_card_set_dev(card, &pcard->card->dev);
-	} else {
-#endif	/* CONFIG_PNP */
-		if ((error = snd_card_opti9xx_detect(card, chip)) < 0) {
-			snd_card_free(card);
-			return error;
-		}
-		if ((error = snd_card_set_generic_dev(card)) < 0) {
-			snd_card_free(card);
-			return error;
-		}
-#ifdef CONFIG_PNP
-	}
-#endif	/* CONFIG_PNP */
 
 	if (! chip->res_mc_base &&
-	    (chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size, "OPTi9xx MC")) == NULL) {
-		snd_card_free(card);
+	    (chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size,
+						"OPTi9xx MC")) == NULL)
 		return -ENOMEM;
-	}
 
 	chip->wss_base = port;
 	chip->fm_port = fm_port;
@@ -1968,110 +1809,42 @@ static int snd_card_opti9xx_probe(struct pnp_card_link *pcard,
 
 	if (chip->wss_base == SNDRV_AUTO_PORT) {
 		if ((chip->wss_base = snd_legacy_find_free_ioport(possible_ports, 4)) < 0) {
-			snd_card_free(card);
 			snd_printk("unable to find a free WSS port\n");
 			return -EBUSY;
 		}
 	}
-#ifdef CONFIG_PNP
-	if (!isapnp) {
-#endif
-	if (chip->mpu_port == SNDRV_AUTO_PORT) {
-		if ((chip->mpu_port = snd_legacy_find_free_ioport(possible_mpu_ports, 2)) < 0) {
-			snd_card_free(card);
-			snd_printk("unable to find a free MPU401 port\n");
-			return -EBUSY;
-		}
-	}
-	if (chip->irq == SNDRV_AUTO_IRQ) {
-		if ((chip->irq = snd_legacy_find_free_irq(possible_irqs)) < 0) {
-			snd_card_free(card);
-			snd_printk("unable to find a free IRQ\n");
-			return -EBUSY;
-		}
-	}
-	if (chip->mpu_irq == SNDRV_AUTO_IRQ) {
-		if ((chip->mpu_irq = snd_legacy_find_free_irq(possible_mpu_irqs)) < 0) {
-			snd_card_free(card);
-			snd_printk("unable to find a free MPU401 IRQ\n");
-			return -EBUSY;
-		}
-	}
-	if (chip->dma1 == SNDRV_AUTO_DMA) {
-                if ((chip->dma1 = snd_legacy_find_free_dma(possible_dma1s)) < 0) {
-                        snd_card_free(card);
-			snd_printk("unable to find a free DMA1\n");
-			return -EBUSY;
-		}
-        }
-#if defined(CS4231) || defined(OPTi93X)
-	if (chip->dma2 == SNDRV_AUTO_DMA) {
-                if ((chip->dma2 = snd_legacy_find_free_dma(possible_dma2s[chip->dma1 % 4])) < 0) {
-                        snd_card_free(card);
-			snd_printk("unable to find a free DMA2\n");
-			return -EBUSY;
-		}
-        }
-#endif
-
-#ifdef CONFIG_PNP
-	}
-#endif
-
-	if ((error = snd_opti9xx_configure(chip))) {
-		snd_card_free(card);
+	if ((error = snd_opti9xx_configure(chip)))
 		return error;
-	}
 
 #if defined(OPTi93X)
-	if ((error = snd_opti93x_create(card, chip, chip->dma1, chip->dma2, &codec))) {
-		snd_card_free(card);
+	if ((error = snd_opti93x_create(card, chip, chip->dma1, chip->dma2, &codec)))
 		return error;
-	}
-	if ((error = snd_opti93x_pcm(codec, 0, &pcm)) < 0) {
-		snd_card_free(card);
+	if ((error = snd_opti93x_pcm(codec, 0, &pcm)) < 0)
 		return error;
-	}
-	if ((error = snd_opti93x_mixer(codec)) < 0) {
-		snd_card_free(card);
+	if ((error = snd_opti93x_mixer(codec)) < 0)
 		return error;
-	}
 #elif defined(CS4231)
 	if ((error = snd_cs4231_create(card, chip->wss_base + 4, -1,
 				       chip->irq, chip->dma1, chip->dma2,
 				       CS4231_HW_DETECT,
 				       0,
-				       &codec)) < 0) {
-		snd_card_free(card);
+				       &codec)) < 0)
 		return error;
-	}
-	if ((error = snd_cs4231_pcm(codec, 0, &pcm)) < 0) {
-		snd_card_free(card);
+	if ((error = snd_cs4231_pcm(codec, 0, &pcm)) < 0)
 		return error;
-	}
-	if ((error = snd_cs4231_mixer(codec)) < 0) {
-		snd_card_free(card);
+	if ((error = snd_cs4231_mixer(codec)) < 0)
 		return error;
-	}
-	if ((error = snd_cs4231_timer(codec, 0, &timer)) < 0) {
-		snd_card_free(card);
+	if ((error = snd_cs4231_timer(codec, 0, &timer)) < 0)
 		return error;
-	}
 #else
 	if ((error = snd_ad1848_create(card, chip->wss_base + 4,
 				       chip->irq, chip->dma1,
-				       AD1848_HW_DETECT, &codec)) < 0) {
-		snd_card_free(card);
+				       AD1848_HW_DETECT, &codec)) < 0)
 		return error;
-	}
-	if ((error = snd_ad1848_pcm(codec, 0, &pcm)) < 0) {
-		snd_card_free(card);
+	if ((error = snd_ad1848_pcm(codec, 0, &pcm)) < 0)
 		return error;
-	}
-	if ((error = snd_ad1848_mixer(codec)) < 0) {
-		snd_card_free(card);
+	if ((error = snd_ad1848_mixer(codec)) < 0)
 		return error;
-	}
 #endif
 	strcpy(card->driver, chip->name);
 	sprintf(card->shortname, "OPTi %s", card->driver);
@@ -2091,7 +1864,8 @@ static int snd_card_opti9xx_probe(struct pnp_card_link *pcard,
 		if ((error = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
 				chip->mpu_port, 0, chip->mpu_irq, SA_INTERRUPT,
 				&rmidi)))
-			snd_printk("no MPU-401 device at 0x%lx?\n", chip->mpu_port);
+			snd_printk(KERN_WARNING "no MPU-401 device at 0x%lx?\n",
+				   chip->mpu_port);
 
 	if (chip->fm_port > 0 && chip->fm_port != SNDRV_AUTO_PORT) {
 		struct snd_opl3 *opl3 = NULL;
@@ -2117,89 +1891,226 @@ static int snd_card_opti9xx_probe(struct pnp_card_link *pcard,
 					     chip->fm_port,
 					     chip->fm_port + 2,
 					     OPL3_HW_AUTO, 0, &opl3) < 0) {
-			snd_printk("no OPL device at 0x%lx-0x%lx\n",
+			snd_printk(KERN_WARNING "no OPL device at 0x%lx-0x%lx\n",
 				   chip->fm_port, chip->fm_port + 4 - 1);
 		}
 		if (opl3) {
-			if ((error = snd_opl3_timer_new(opl3,
 #ifdef CS4231
-							1, 2)) < 0) {
+			const int t1dev = 1;
 #else
-							0, 1)) < 0) {
-#endif	/* CS4231 */
-				snd_card_free(card);
+			const int t1dev = 0;
+#endif
+			if ((error = snd_opl3_timer_new(opl3, t1dev, t1dev+1)) < 0)
 				return error;
-			}
-			if ((error = snd_opl3_hwdep_new(opl3, 0, 1, &synth)) < 0) {
-				snd_card_free(card);
+			if ((error = snd_opl3_hwdep_new(opl3, 0, 1, &synth)) < 0)
 				return error;
-			}
 		}
 	}
 
-	if ((error = snd_card_register(card))) {
+	return snd_card_register(card);
+}
+
+static struct snd_card *snd_opti9xx_card_new(void)
+{
+	struct snd_card *card;
+
+	card = snd_card_new(index, id, THIS_MODULE, sizeof(struct snd_opti9xx));
+	if (! card)
+		return NULL;
+	card->private_free = snd_card_opti9xx_free;
+	return card;
+}
+
+static int __init snd_opti9xx_nonpnp_probe(struct platform_device *devptr)
+{
+	struct snd_card *card;
+	int error;
+	static long possible_mpu_ports[] = {0x300, 0x310, 0x320, 0x330, -1};
+#ifdef OPTi93X
+	static int possible_irqs[] = {5, 9, 10, 11, 7, -1};
+#else
+	static int possible_irqs[] = {9, 10, 11, 7, -1};
+#endif	/* OPTi93X */
+	static int possible_mpu_irqs[] = {5, 9, 10, 7, -1};
+	static int possible_dma1s[] = {3, 1, 0, -1};
+#if defined(CS4231) || defined(OPTi93X)
+	static int possible_dma2s[][2] = {{1,-1}, {0,-1}, {-1,-1}, {0,-1}};
+#endif	/* CS4231 || OPTi93X */
+
+	if (snd_opti9xx_pnp_is_probed)
+		return -EBUSY;
+
+	if (mpu_port == SNDRV_AUTO_PORT) {
+		if ((mpu_port = snd_legacy_find_free_ioport(possible_mpu_ports, 2)) < 0) {
+			snd_printk(KERN_ERR "unable to find a free MPU401 port\n");
+			return -EBUSY;
+		}
+	}
+	if (irq == SNDRV_AUTO_IRQ) {
+		if ((irq = snd_legacy_find_free_irq(possible_irqs)) < 0) {
+			snd_printk(KERN_ERR "unable to find a free IRQ\n");
+			return -EBUSY;
+		}
+	}
+	if (mpu_irq == SNDRV_AUTO_IRQ) {
+		if ((mpu_irq = snd_legacy_find_free_irq(possible_mpu_irqs)) < 0) {
+			snd_printk(KERN_ERR "unable to find a free MPU401 IRQ\n");
+			return -EBUSY;
+		}
+	}
+	if (dma1 == SNDRV_AUTO_DMA) {
+		if ((dma1 = snd_legacy_find_free_dma(possible_dma1s)) < 0) {
+			snd_printk(KERN_ERR "unable to find a free DMA1\n");
+			return -EBUSY;
+		}
+	}
+#if defined(CS4231) || defined(OPTi93X)
+	if (dma2 == SNDRV_AUTO_DMA) {
+		if ((dma2 = snd_legacy_find_free_dma(possible_dma2s[dma1 % 4])) < 0) {
+			snd_printk("unable to find a free DMA2\n");
+			return -EBUSY;
+		}
+	}
+#endif
+
+	card = snd_opti9xx_card_new();
+	if (! card)
+		return -ENOMEM;
+
+	if ((error = snd_card_opti9xx_detect(card, card->private_data)) < 0) {
 		snd_card_free(card);
 		return error;
 	}
-	snd_opti9xx_first_hit = 0;
-	if (pcard)
-		pnp_set_card_drvdata(pcard, card);
-	else
-		snd_opti9xx_legacy = card;
+	snd_card_set_dev(card, &devptr->dev);
+	if ((error = snd_opti9xx_probe(card)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+	platform_set_drvdata(devptr, card);
+	return 0;
+}
+
+static int __devexit snd_opti9xx_nonpnp_remove(struct platform_device *devptr)
+{
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
 	return 0;
 }
 
+static struct platform_driver snd_opti9xx_driver = {
+	.probe		= snd_opti9xx_nonpnp_probe,
+	.remove		= __devexit_p(snd_opti9xx_nonpnp_remove),
+	/* FIXME: suspend/resume */
+	.driver		= {
+		.name	= DRIVER_NAME
+	},
+};
+
 #ifdef CONFIG_PNP
-static void __devexit snd_opti9xx_pnp_remove(struct pnp_card_link * pcard)
+static int __init snd_opti9xx_pnp_probe(struct pnp_card_link *pcard,
+					const struct pnp_card_device_id *pid)
 {
-	struct snd_card *card = (struct snd_card *) pnp_get_card_drvdata(pcard);
+	struct snd_card *card;
+	int error, hw;
+	struct snd_opti9xx *chip;
+
+	if (snd_opti9xx_pnp_is_probed)
+		return -EBUSY;
+	if (! isapnp)
+		return -ENODEV;
+	card = snd_opti9xx_card_new();
+	if (! card)
+		return -ENOMEM;
+	chip = card->private_data;
 
-	snd_card_disconnect(card);
-	snd_card_free_in_thread(card);
-	snd_opti9xx_first_hit = 0;
+	hw = snd_card_opti9xx_pnp(chip, pcard, pid);
+	switch (hw) {
+	case 0x0924:
+		hw = OPTi9XX_HW_82C924;
+		break;
+	case 0x0925:
+		hw = OPTi9XX_HW_82C925;
+		break;
+	case 0x0931:
+		hw = OPTi9XX_HW_82C931;
+		break;
+	default:
+		snd_card_free(card);
+		return -ENODEV;
+	}
+
+	if ((error = snd_opti9xx_init(chip, hw))) {
+		snd_card_free(card);
+		return error;
+	}
+	if (hw <= OPTi9XX_HW_82C930)
+		chip->mc_base -= 0x80;
+	snd_card_set_dev(card, &pcard->card->dev);
+	if ((error = snd_opti9xx_probe(card)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+	pnp_set_card_drvdata(pcard, card);
+	snd_opti9xx_pnp_is_probed = 1;
+	return 0;
+}
+
+static void __devexit snd_opti9xx_pnp_remove(struct pnp_card_link * pcard)
+{
+	snd_card_free(pnp_get_card_drvdata(pcard));
+	pnp_set_card_drvdata(pcard, NULL);
+	snd_opti9xx_pnp_is_probed = 0;
 }
 
 static struct pnp_card_driver opti9xx_pnpc_driver = {
 	.flags		= PNP_DRIVER_RES_DISABLE,
 	.name		= "opti9xx",
 	.id_table	= snd_opti9xx_pnpids,
-	.probe		= snd_card_opti9xx_probe,
+	.probe		= snd_opti9xx_pnp_probe,
 	.remove		= __devexit_p(snd_opti9xx_pnp_remove),
 };
 #endif
 
-static int __init alsa_card_opti9xx_init(void)
-{
-	int cards, error;
-
 #ifdef CONFIG_PNP
-	cards = pnp_register_card_driver(&opti9xx_pnpc_driver);
+#define is_isapnp_selected()	isapnp
 #else
-	cards = 0;
-#endif
-	if (cards == 0 && (error = snd_card_opti9xx_probe(NULL, NULL)) < 0) {
-#ifdef CONFIG_PNP
-		pnp_unregister_card_driver(&opti9xx_pnpc_driver);
+#define is_isapnp_selected()	0
 #endif
-#ifdef MODULE
 #ifdef OPTi93X
-		printk(KERN_ERR "no OPTi 82C93x soundcard found\n");
+#define CHIP_NAME	"82C93x"
 #else
-		printk(KERN_ERR "no OPTi 82C92x soundcard found\n");
-#endif	/* OPTi93X */
+#define CHIP_NAME	"82C92x"
 #endif
-		return error;
+
+static int __init alsa_card_opti9xx_init(void)
+{
+	int error;
+	struct platform_device *device;
+
+	pnp_register_card_driver(&opti9xx_pnpc_driver);
+	if (snd_opti9xx_pnp_is_probed)
+		return 0;
+	if (! is_isapnp_selected()) {
+		error = platform_driver_register(&snd_opti9xx_driver);
+		if (error < 0)
+			return error;
+		device = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0);
+		if (! IS_ERR(device))
+			return 0;
+		platform_driver_unregister(&snd_opti9xx_driver);
 	}
-	return 0;
+	pnp_unregister_card_driver(&opti9xx_pnpc_driver);
+#ifdef MODULE
+	printk(KERN_ERR "no OPTi " CHIP_NAME " soundcard found\n");
+#endif
+	return -ENODEV;
 }
 
 static void __exit alsa_card_opti9xx_exit(void)
 {
-#ifdef CONFIG_PNP
+	if (! snd_opti9xx_pnp_is_probed)
+		platform_driver_unregister(&snd_opti9xx_driver);
 	pnp_unregister_card_driver(&opti9xx_pnpc_driver);
-#endif
-	if (snd_opti9xx_legacy)
-		snd_card_free(snd_opti9xx_legacy);
 }
 
 module_init(alsa_card_opti9xx_init)

commit 346c7a689542285aef9b899eda7693d4b912d60d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:37:56 2005 +0100

    [ALSA] Remove xxx_t typedefs: ISA Opti9xx
    
    Modules: Opti9xx drivers
    
    Remove xxx_t typedefs from the ISA Opti 9xx drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 1be32999dfe1..fddf7b9549ba 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -120,8 +120,6 @@ MODULE_PARM_DESC(dma2, "2nd dma # for opti9xx driver.");
 
 #define OPTi9XX_MC_REG(n)	n
 
-typedef struct _snd_opti9xx opti9xx_t;
-
 #ifdef OPTi93X
 
 #define OPTi93X_INDEX			0x00
@@ -193,16 +191,14 @@ typedef struct _snd_opti9xx opti9xx_t;
 #define OPTi93X_IRQ_CAPTURE		0x08
 
 
-typedef struct _snd_opti93x opti93x_t;
-
-struct _snd_opti93x {
+struct snd_opti93x {
 	unsigned long port;
 	struct resource *res_port;
 	int irq;
 	int dma1;
 	int dma2;
 
-	opti9xx_t *chip;
+	struct snd_opti9xx *chip;
 	unsigned short hardware;
 	unsigned char image[32];
 
@@ -212,10 +208,10 @@ struct _snd_opti93x {
 
 	spinlock_t lock;
 
-	snd_card_t *card;
-	snd_pcm_t *pcm;
-	snd_pcm_substream_t *playback_substream;
-	snd_pcm_substream_t *capture_substream;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	struct snd_pcm_substream *playback_substream;
+	struct snd_pcm_substream *capture_substream;
 	unsigned int p_dma_size;
 	unsigned int c_dma_size;
 };
@@ -227,7 +223,7 @@ struct _snd_opti93x {
 
 #endif /* OPTi93X */
 
-struct _snd_opti9xx {
+struct snd_opti9xx {
 	unsigned short hardware;
 	unsigned char password;
 	char name[7];
@@ -261,7 +257,7 @@ struct _snd_opti9xx {
 };
 
 static int snd_opti9xx_first_hit = 1;
-static snd_card_t *snd_opti9xx_legacy = SNDRV_DEFAULT_PTR1;
+static struct snd_card *snd_opti9xx_legacy = SNDRV_DEFAULT_PTR1;
 
 #ifdef CONFIG_PNP
 
@@ -308,7 +304,7 @@ static long snd_legacy_find_free_ioport(long *port_table, long size)
 	return -1;
 }
 
-static int __devinit snd_opti9xx_init(opti9xx_t *chip, unsigned short hardware)
+static int __devinit snd_opti9xx_init(struct snd_opti9xx *chip, unsigned short hardware)
 {
 	static int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};
 
@@ -363,7 +359,7 @@ static int __devinit snd_opti9xx_init(opti9xx_t *chip, unsigned short hardware)
 	return 0;
 }
 
-static unsigned char snd_opti9xx_read(opti9xx_t *chip,
+static unsigned char snd_opti9xx_read(struct snd_opti9xx *chip,
 				      unsigned char reg)
 {
 	unsigned long flags;
@@ -406,7 +402,7 @@ static unsigned char snd_opti9xx_read(opti9xx_t *chip,
 	return retval;
 }
 	
-static void snd_opti9xx_write(opti9xx_t *chip, unsigned char reg,
+static void snd_opti9xx_write(struct snd_opti9xx *chip, unsigned char reg,
 			      unsigned char value)
 {
 	unsigned long flags;
@@ -453,7 +449,7 @@ static void snd_opti9xx_write(opti9xx_t *chip, unsigned char reg,
 		(snd_opti9xx_read(chip, reg) & ~(mask)) | ((value) & (mask)))
 
 
-static int __devinit snd_opti9xx_configure(opti9xx_t *chip)
+static int __devinit snd_opti9xx_configure(struct snd_opti9xx *chip)
 {
 	unsigned char wss_base_bits;
 	unsigned char irq_bits;
@@ -684,7 +680,7 @@ static unsigned char snd_opti93x_default_image[32] =
 };
 
 
-static int snd_opti93x_busy_wait(opti93x_t *chip)
+static int snd_opti93x_busy_wait(struct snd_opti93x *chip)
 {
 	int timeout;
 
@@ -696,14 +692,14 @@ static int snd_opti93x_busy_wait(opti93x_t *chip)
 	return -EBUSY;
 }
 
-static unsigned char snd_opti93x_in(opti93x_t *chip, unsigned char reg)
+static unsigned char snd_opti93x_in(struct snd_opti93x *chip, unsigned char reg)
 {
 	snd_opti93x_busy_wait(chip);
 	outb(chip->mce_bit | (reg & 0x1f), OPTi93X_PORT(chip, INDEX));
 	return inb(OPTi93X_PORT(chip, DATA));
 }
 
-static void snd_opti93x_out(opti93x_t *chip, unsigned char reg,
+static void snd_opti93x_out(struct snd_opti93x *chip, unsigned char reg,
 			    unsigned char value)
 {
 	snd_opti93x_busy_wait(chip);
@@ -711,13 +707,13 @@ static void snd_opti93x_out(opti93x_t *chip, unsigned char reg,
 	outb(value, OPTi93X_PORT(chip, DATA));
 }
 
-static void snd_opti93x_out_image(opti93x_t *chip, unsigned char reg,
+static void snd_opti93x_out_image(struct snd_opti93x *chip, unsigned char reg,
 				  unsigned char value)
 {
 	snd_opti93x_out(chip, reg, chip->image[reg] = value);
 }
 
-static void snd_opti93x_out_mask(opti93x_t *chip, unsigned char reg,
+static void snd_opti93x_out_mask(struct snd_opti93x *chip, unsigned char reg,
 				 unsigned char mask, unsigned char value)
 {
 	snd_opti93x_out_image(chip, reg,
@@ -725,7 +721,7 @@ static void snd_opti93x_out_mask(opti93x_t *chip, unsigned char reg,
 }
 
 
-static void snd_opti93x_mce_up(opti93x_t *chip)
+static void snd_opti93x_mce_up(struct snd_opti93x *chip)
 {
 	snd_opti93x_busy_wait(chip);
 
@@ -734,7 +730,7 @@ static void snd_opti93x_mce_up(opti93x_t *chip)
 		outb(chip->mce_bit, OPTi93X_PORT(chip, INDEX));
 }
 
-static void snd_opti93x_mce_down(opti93x_t *chip)
+static void snd_opti93x_mce_down(struct snd_opti93x *chip)
 {
 	snd_opti93x_busy_wait(chip);
 
@@ -746,7 +742,7 @@ static void snd_opti93x_mce_down(opti93x_t *chip)
 #define snd_opti93x_mute_reg(chip, reg, mute)	\
 	snd_opti93x_out(chip, reg, mute ? 0x80 : chip->image[reg]);
 
-static void snd_opti93x_mute(opti93x_t *chip, int mute)
+static void snd_opti93x_mute(struct snd_opti93x *chip, int mute)
 {
 	mute = mute ? 1 : 0;
 	if (chip->mute == mute)
@@ -798,7 +794,7 @@ static unsigned int rates[] = {  5512,  6615,  8000,  9600, 11025, 16000,
 				44100, 48000 };
 #define RATES ARRAY_SIZE(rates)
 
-static snd_pcm_hw_constraint_list_t hw_constraints_rates = {
+static struct snd_pcm_hw_constraint_list hw_constraints_rates = {
 	.count = RATES,
 	.list = rates,
 	.mask = 0,
@@ -820,7 +816,7 @@ static unsigned char snd_opti93x_get_freq(unsigned int rate)
 	return bits[RATES-1];
 }
 
-static unsigned char snd_opti93x_get_format(opti93x_t *chip,
+static unsigned char snd_opti93x_get_format(struct snd_opti93x *chip,
 					    unsigned int format, int channels)
 {
 	unsigned char retval = OPTi93X_LINEAR_8;
@@ -845,7 +841,7 @@ static unsigned char snd_opti93x_get_format(opti93x_t *chip,
 }
 
 
-static void snd_opti93x_playback_format(opti93x_t *chip, unsigned char fmt)
+static void snd_opti93x_playback_format(struct snd_opti93x *chip, unsigned char fmt)
 {
 	unsigned char mask;
 
@@ -859,7 +855,7 @@ static void snd_opti93x_playback_format(opti93x_t *chip, unsigned char fmt)
 	snd_opti93x_mute(chip, 0);
 }
 
-static void snd_opti93x_capture_format(opti93x_t *chip, unsigned char fmt)
+static void snd_opti93x_capture_format(struct snd_opti93x *chip, unsigned char fmt)
 {
 	snd_opti93x_mute(chip, 1);
 
@@ -875,7 +871,7 @@ static void snd_opti93x_capture_format(opti93x_t *chip, unsigned char fmt)
 }
 
 
-static int snd_opti93x_open(opti93x_t *chip, unsigned int mode)
+static int snd_opti93x_open(struct snd_opti93x *chip, unsigned int mode)
 {
 	unsigned long flags;
 
@@ -899,7 +895,7 @@ static int snd_opti93x_open(opti93x_t *chip, unsigned int mode)
 	return 0;
 }
 
-static void snd_opti93x_close(opti93x_t *chip, unsigned int mode)
+static void snd_opti93x_close(struct snd_opti93x *chip, unsigned int mode)
 {
 	unsigned long flags;
 
@@ -926,10 +922,10 @@ static void snd_opti93x_close(opti93x_t *chip, unsigned int mode)
 	spin_unlock_irqrestore(&chip->lock, flags);
 }
 
-static int snd_opti93x_trigger(snd_pcm_substream_t *substream, 
+static int snd_opti93x_trigger(struct snd_pcm_substream *substream, 
 			       unsigned char what, int cmd)
 {
-	opti93x_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -937,7 +933,7 @@ static int snd_opti93x_trigger(snd_pcm_substream_t *substream,
 	{
 		unsigned int what = 0;
 		struct list_head *pos;
-		snd_pcm_substream_t *s;
+		struct snd_pcm_substream *s;
 		snd_pcm_group_for_each(pos, substream) {
 			s = snd_pcm_group_substream_entry(pos);
 			if (s == chip->playback_substream) {
@@ -964,36 +960,36 @@ static int snd_opti93x_trigger(snd_pcm_substream_t *substream,
 	return 0;
 }
 
-static int snd_opti93x_playback_trigger(snd_pcm_substream_t *substream, int cmd)
+static int snd_opti93x_playback_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	return snd_opti93x_trigger(substream,
 				   OPTi93X_PLAYBACK_ENABLE, cmd);
 }
 
-static int snd_opti93x_capture_trigger(snd_pcm_substream_t * substream, int cmd)
+static int snd_opti93x_capture_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	return snd_opti93x_trigger(substream,
 				   OPTi93X_CAPTURE_ENABLE, cmd);
 }
 
-static int snd_opti93x_hw_params(snd_pcm_substream_t * substream,
-				 snd_pcm_hw_params_t * hw_params)
+static int snd_opti93x_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *hw_params)
 {
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 }
 
 
-static int snd_opti93x_hw_free(snd_pcm_substream_t * substream)
+static int snd_opti93x_hw_free(struct snd_pcm_substream *substream)
 {
 	snd_pcm_lib_free_pages(substream);
 	return 0;
 }
 
 
-static int snd_opti93x_playback_prepare(snd_pcm_substream_t * substream)
+static int snd_opti93x_playback_prepare(struct snd_pcm_substream *substream)
 {
-	opti93x_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned long flags;
 	unsigned char format;
 	unsigned int count = snd_pcm_lib_period_bytes(substream);
@@ -1023,10 +1019,10 @@ static int snd_opti93x_playback_prepare(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_opti93x_capture_prepare(snd_pcm_substream_t *substream)
+static int snd_opti93x_capture_prepare(struct snd_pcm_substream *substream)
 {
-	opti93x_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned long flags;
 	unsigned char format;
 	unsigned int count = snd_pcm_lib_period_bytes(substream);
@@ -1055,9 +1051,9 @@ static int snd_opti93x_capture_prepare(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static snd_pcm_uframes_t snd_opti93x_playback_pointer(snd_pcm_substream_t *substream)
+static snd_pcm_uframes_t snd_opti93x_playback_pointer(struct snd_pcm_substream *substream)
 {
-	opti93x_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
 	size_t ptr;
 
 	if (!(chip->image[OPTi93X_IFACE_CONF] & OPTi93X_PLAYBACK_ENABLE))
@@ -1067,9 +1063,9 @@ static snd_pcm_uframes_t snd_opti93x_playback_pointer(snd_pcm_substream_t *subst
 	return bytes_to_frames(substream->runtime, ptr);
 }
 
-static snd_pcm_uframes_t snd_opti93x_capture_pointer(snd_pcm_substream_t *substream)
+static snd_pcm_uframes_t snd_opti93x_capture_pointer(struct snd_pcm_substream *substream)
 {
-	opti93x_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
 	size_t ptr;
 	
 	if (!(chip->image[OPTi93X_IFACE_CONF] & OPTi93X_CAPTURE_ENABLE))
@@ -1080,7 +1076,7 @@ static snd_pcm_uframes_t snd_opti93x_capture_pointer(snd_pcm_substream_t *substr
 }
 
 
-static void snd_opti93x_overrange(opti93x_t *chip)
+static void snd_opti93x_overrange(struct snd_opti93x *chip)
 {
 	unsigned long flags;
 
@@ -1094,7 +1090,7 @@ static void snd_opti93x_overrange(opti93x_t *chip)
 
 static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	opti93x_t *codec = dev_id;
+	struct snd_opti93x *codec = dev_id;
 	unsigned char status;
 
 	status = snd_opti9xx_read(codec->chip, OPTi9XX_MC_REG(11));
@@ -1109,7 +1105,7 @@ static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id, struct pt_regs *
 }
 
 
-static snd_pcm_hardware_t snd_opti93x_playback = {
+static struct snd_pcm_hardware snd_opti93x_playback = {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START),
 	.formats =		(SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW | SNDRV_PCM_FMTBIT_IMA_ADPCM |
@@ -1127,7 +1123,7 @@ static snd_pcm_hardware_t snd_opti93x_playback = {
 	.fifo_size =		0,
 };
 
-static snd_pcm_hardware_t snd_opti93x_capture = {
+static struct snd_pcm_hardware snd_opti93x_capture = {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START),
 	.formats =		(SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW | SNDRV_PCM_FMTBIT_IMA_ADPCM |
@@ -1145,11 +1141,11 @@ static snd_pcm_hardware_t snd_opti93x_capture = {
 	.fifo_size =		0,
 };
 
-static int snd_opti93x_playback_open(snd_pcm_substream_t *substream)
+static int snd_opti93x_playback_open(struct snd_pcm_substream *substream)
 {
 	int error;
-	opti93x_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	if ((error = snd_opti93x_open(chip, OPTi93X_MODE_PLAY)) < 0)
 		return error;
@@ -1161,11 +1157,11 @@ static int snd_opti93x_playback_open(snd_pcm_substream_t *substream)
 	return error;
 }
 
-static int snd_opti93x_capture_open(snd_pcm_substream_t *substream)
+static int snd_opti93x_capture_open(struct snd_pcm_substream *substream)
 {
 	int error;
-	opti93x_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	if ((error = snd_opti93x_open(chip, OPTi93X_MODE_CAPTURE)) < 0)
 		return error;
@@ -1177,18 +1173,18 @@ static int snd_opti93x_capture_open(snd_pcm_substream_t *substream)
 	return error;
 }
 
-static int snd_opti93x_playback_close(snd_pcm_substream_t *substream)
+static int snd_opti93x_playback_close(struct snd_pcm_substream *substream)
 {
-	opti93x_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
 
 	chip->playback_substream = NULL;
 	snd_opti93x_close(chip, OPTi93X_MODE_PLAY);
 	return 0;
 }
 
-static int snd_opti93x_capture_close(snd_pcm_substream_t *substream)
+static int snd_opti93x_capture_close(struct snd_pcm_substream *substream)
 {
-	opti93x_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_opti93x *chip = snd_pcm_substream_chip(substream);
 
 	chip->capture_substream = NULL;
 	snd_opti93x_close(chip, OPTi93X_MODE_CAPTURE);
@@ -1196,7 +1192,7 @@ static int snd_opti93x_capture_close(snd_pcm_substream_t *substream)
 }
 
 
-static void snd_opti93x_init(opti93x_t *chip)
+static void snd_opti93x_init(struct snd_opti93x *chip)
 {
 	unsigned long flags;
 	int i;
@@ -1211,7 +1207,7 @@ static void snd_opti93x_init(opti93x_t *chip)
 	spin_unlock_irqrestore(&chip->lock, flags);
 }
 
-static int snd_opti93x_probe(opti93x_t *chip)
+static int snd_opti93x_probe(struct snd_opti93x *chip)
 {
 	unsigned long flags;
 	unsigned char val;
@@ -1223,7 +1219,7 @@ static int snd_opti93x_probe(opti93x_t *chip)
 	return (val == 0x0a) ? 0 : -ENODEV;
 }
 
-static int snd_opti93x_free(opti93x_t *chip)
+static int snd_opti93x_free(struct snd_opti93x *chip)
 {
 	release_and_free_resource(chip->res_port);
 	if (chip->dma1 >= 0) {
@@ -1241,13 +1237,13 @@ static int snd_opti93x_free(opti93x_t *chip)
 	return 0;
 }
 
-static int snd_opti93x_dev_free(snd_device_t *device)
+static int snd_opti93x_dev_free(struct snd_device *device)
 {
-	opti93x_t *chip = device->device_data;
+	struct snd_opti93x *chip = device->device_data;
 	return snd_opti93x_free(chip);
 }
 
-static const char *snd_opti93x_chip_id(opti93x_t *codec)
+static const char *snd_opti93x_chip_id(struct snd_opti93x *codec)
 {
 	switch (codec->hardware) {
 	case OPTi9XX_HW_82C930: return "82C930";
@@ -1257,15 +1253,15 @@ static const char *snd_opti93x_chip_id(opti93x_t *codec)
 	}
 }
 
-static int snd_opti93x_create(snd_card_t *card, opti9xx_t *chip,
+static int snd_opti93x_create(struct snd_card *card, struct snd_opti9xx *chip,
 			      int dma1, int dma2,
-			      opti93x_t **rcodec)
+			      struct snd_opti93x **rcodec)
 {
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free =	snd_opti93x_dev_free,
 	};
 	int error;
-	opti93x_t *codec;
+	struct snd_opti93x *codec;
 
 	*rcodec = NULL;
 	codec = kzalloc(sizeof(*codec), GFP_KERNEL);
@@ -1324,7 +1320,7 @@ static int snd_opti93x_create(snd_card_t *card, opti9xx_t *chip,
 	return 0;
 }
 
-static snd_pcm_ops_t snd_opti93x_playback_ops = {
+static struct snd_pcm_ops snd_opti93x_playback_ops = {
 	.open =		snd_opti93x_playback_open,
 	.close =	snd_opti93x_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1335,7 +1331,7 @@ static snd_pcm_ops_t snd_opti93x_playback_ops = {
 	.pointer =	snd_opti93x_playback_pointer,
 };
 
-static snd_pcm_ops_t snd_opti93x_capture_ops = {
+static struct snd_pcm_ops snd_opti93x_capture_ops = {
 	.open =		snd_opti93x_capture_open,
 	.close =	snd_opti93x_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1346,10 +1342,10 @@ static snd_pcm_ops_t snd_opti93x_capture_ops = {
 	.pointer =	snd_opti93x_capture_pointer,
 };
 
-static int snd_opti93x_pcm(opti93x_t *codec, int device, snd_pcm_t **rpcm)
+static int snd_opti93x_pcm(struct snd_opti93x *codec, int device, struct snd_pcm **rpcm)
 {
 	int error;
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 
 	if ((error = snd_pcm_new(codec->card, "OPTi 82C93X", device, 1, 1, &pcm)))
 		return error;
@@ -1376,7 +1372,7 @@ static int snd_opti93x_pcm(opti93x_t *codec, int device, snd_pcm_t **rpcm)
  *  MIXER part
  */
 
-static int snd_opti93x_info_mux(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_opti93x_info_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[4] = {
 		"Line1", "Aux", "Mic", "Mix"
@@ -1391,9 +1387,9 @@ static int snd_opti93x_info_mux(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *
 	return 0;
 }
 
-static int snd_opti93x_get_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_opti93x_get_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	opti93x_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_opti93x *chip = snd_kcontrol_chip(kcontrol);
 	unsigned long flags;
 	
 	spin_lock_irqsave(&chip->lock, flags);
@@ -1403,9 +1399,9 @@ static int snd_opti93x_get_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t *
 	return 0;
 }
 
-static int snd_opti93x_put_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_opti93x_put_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	opti93x_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_opti93x *chip = snd_kcontrol_chip(kcontrol);
 	unsigned long flags;
 	unsigned short left, right;
 	int change;
@@ -1434,7 +1430,7 @@ static int snd_opti93x_put_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t *
   .get = snd_opti93x_get_single, .put = snd_opti93x_put_single, \
   .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }
 
-static int snd_opti93x_info_single(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_opti93x_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	int mask = (kcontrol->private_value >> 16) & 0xff;
 
@@ -1445,9 +1441,9 @@ static int snd_opti93x_info_single(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t
 	return 0;
 }
 
-static int snd_opti93x_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_opti93x_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	opti93x_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_opti93x *chip = snd_kcontrol_chip(kcontrol);
 	unsigned long flags;
 	int reg = kcontrol->private_value & 0xff;
 	int shift = (kcontrol->private_value >> 8) & 0xff;
@@ -1462,9 +1458,9 @@ static int snd_opti93x_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_
 	return 0;
 }
 
-static int snd_opti93x_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_opti93x_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	opti93x_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_opti93x *chip = snd_kcontrol_chip(kcontrol);
 	unsigned long flags;
 	int reg = kcontrol->private_value & 0xff;
 	int shift = (kcontrol->private_value >> 8) & 0xff;
@@ -1499,7 +1495,7 @@ static int snd_opti93x_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_
 	do { xctl.private_value &= ~0x0000ffff; \
 	     xctl.private_value |= left_reg | (right_reg << 8); } while (0)
 
-static int snd_opti93x_info_double(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_opti93x_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	int mask = (kcontrol->private_value >> 24) & 0xff;
 
@@ -1510,9 +1506,9 @@ static int snd_opti93x_info_double(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t
 	return 0;
 }
 
-static int snd_opti93x_get_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_opti93x_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	opti93x_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_opti93x *chip = snd_kcontrol_chip(kcontrol);
 	unsigned long flags;
 	int left_reg = kcontrol->private_value & 0xff;
 	int right_reg = (kcontrol->private_value >> 8) & 0xff;
@@ -1532,9 +1528,9 @@ static int snd_opti93x_get_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_
 	return 0;
 }
 
-static int snd_opti93x_put_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_opti93x_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	opti93x_t *chip = snd_kcontrol_chip(kcontrol);
+	struct snd_opti93x *chip = snd_kcontrol_chip(kcontrol);
 	unsigned long flags;
 	int left_reg = kcontrol->private_value & 0xff;
 	int right_reg = (kcontrol->private_value >> 8) & 0xff;
@@ -1563,7 +1559,7 @@ static int snd_opti93x_put_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_
 	return change;
 }
 
-static snd_kcontrol_new_t snd_opti93x_controls[] = {
+static struct snd_kcontrol_new snd_opti93x_controls[] = {
 OPTi93X_DOUBLE("Master Playback Switch", 0, OPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 7, 7, 1, 1),
 OPTi93X_DOUBLE("Master Playback Volume", 0, OPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 1, 1, 31, 1), 
 OPTi93X_DOUBLE("PCM Playback Switch", 0, OPTi93X_DAC_LEFT, OPTi93X_DAC_RIGHT, 7, 7, 1, 1),
@@ -1589,10 +1585,10 @@ OPTi93X_DOUBLE("Capture Volume", 0, OPTi93X_MIXOUT_LEFT, OPTi93X_MIXOUT_RIGHT, 0
 }
 };
                                         
-static int snd_opti93x_mixer(opti93x_t *chip)
+static int snd_opti93x_mixer(struct snd_opti93x *chip)
 {
-	snd_card_t *card;
-	snd_kcontrol_new_t knew;
+	struct snd_card *card;
+	struct snd_kcontrol_new knew;
 	int err;
 	unsigned int idx;
 
@@ -1624,7 +1620,7 @@ static int snd_opti93x_mixer(opti93x_t *chip)
 
 #endif /* OPTi93X */
 
-static int __devinit snd_card_opti9xx_detect(snd_card_t *card, opti9xx_t *chip)
+static int __devinit snd_card_opti9xx_detect(struct snd_card *card, struct snd_opti9xx *chip)
 {
 	int i, err;
 
@@ -1678,7 +1674,7 @@ static int __devinit snd_card_opti9xx_detect(snd_card_t *card, opti9xx_t *chip)
 }
 
 #ifdef CONFIG_PNP
-static int __devinit snd_card_opti9xx_pnp(opti9xx_t *chip, struct pnp_card_link *card,
+static int __devinit snd_card_opti9xx_pnp(struct snd_opti9xx *chip, struct pnp_card_link *card,
 					  const struct pnp_card_device_id *pid)
 {
 	struct pnp_dev *pdev;
@@ -1772,7 +1768,7 @@ static int __devinit snd_card_opti9xx_pnp(opti9xx_t *chip, struct pnp_card_link
 
 #if 0
 static int __devinit snd_card_opti9xx_resources(struct snd_card_opti9xx *chip,
-						snd_card_t *card)
+						struct snd_card *card)
 {
 	int error, i, pnp = 0;
 
@@ -1867,9 +1863,9 @@ static int __devinit snd_card_opti9xx_resources(struct snd_card_opti9xx *chip,
 }
 #endif
 
-static void snd_card_opti9xx_free(snd_card_t *card)
+static void snd_card_opti9xx_free(struct snd_card *card)
 {
-	opti9xx_t *chip = (opti9xx_t *)card->private_data;
+	struct snd_opti9xx *chip = (struct snd_opti9xx *)card->private_data;
         
 	if (chip)
 		release_and_free_resource(chip->res_mc_base);
@@ -1891,19 +1887,19 @@ static int snd_card_opti9xx_probe(struct pnp_card_link *pcard,
 	static int possible_dma2s[][2] = {{1,-1}, {0,-1}, {-1,-1}, {0,-1}};
 #endif	/* CS4231 || OPTi93X */
 	int error;
-	opti9xx_t *chip;
+	struct snd_opti9xx *chip;
 #if defined(OPTi93X)
-	opti93x_t *codec;
+	struct snd_opti93x *codec;
 #elif defined(CS4231)
-	cs4231_t *codec;
-	snd_timer_t *timer;
+	struct snd_cs4231 *codec;
+	struct snd_timer *timer;
 #else
-	ad1848_t *codec;
+	struct snd_ad1848 *codec;
 #endif
-	snd_card_t *card;
-	snd_pcm_t *pcm;
-	snd_rawmidi_t *rmidi;
-	snd_hwdep_t *synth;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	struct snd_rawmidi *rmidi;
+	struct snd_hwdep *synth;
 #ifdef CONFIG_PNP
 	int hw;
 #endif	/* CONFIG_PNP */
@@ -1911,10 +1907,10 @@ static int snd_card_opti9xx_probe(struct pnp_card_link *pcard,
 	if (pcard && !snd_opti9xx_first_hit)
 		return -EBUSY;
 	if (!(card = snd_card_new(index, id, THIS_MODULE,
-				  sizeof(opti9xx_t))))
+				  sizeof(struct snd_opti9xx))))
 		return -ENOMEM;
 	card->private_free = snd_card_opti9xx_free;
-	chip = (opti9xx_t *)card->private_data;
+	chip = (struct snd_opti9xx *)card->private_data;
 
 #ifdef CONFIG_PNP
 	if (isapnp && pcard && (hw = snd_card_opti9xx_pnp(chip, pcard, pid)) > 0) {
@@ -2098,12 +2094,12 @@ static int snd_card_opti9xx_probe(struct pnp_card_link *pcard,
 			snd_printk("no MPU-401 device at 0x%lx?\n", chip->mpu_port);
 
 	if (chip->fm_port > 0 && chip->fm_port != SNDRV_AUTO_PORT) {
-		opl3_t *opl3 = NULL;
+		struct snd_opl3 *opl3 = NULL;
 #ifndef OPTi93X
 		if (chip->hardware == OPTi9XX_HW_82C928 ||
 		    chip->hardware == OPTi9XX_HW_82C929 ||
 		    chip->hardware == OPTi9XX_HW_82C924) {
-			opl4_t *opl4;
+			struct snd_opl4 *opl4;
 			/* assume we have an OPL4 */
 			snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2),
 					       0x20, 0x20);
@@ -2156,7 +2152,7 @@ static int snd_card_opti9xx_probe(struct pnp_card_link *pcard,
 #ifdef CONFIG_PNP
 static void __devexit snd_opti9xx_pnp_remove(struct pnp_card_link * pcard)
 {
-	snd_card_t *card = (snd_card_t *) pnp_get_card_drvdata(pcard);
+	struct snd_card *card = (struct snd_card *) pnp_get_card_drvdata(pcard);
 
 	snd_card_disconnect(card);
 	snd_card_free_in_thread(card);

commit c3e6f7d8763fa0400d28c57633eb323515ba05fc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 16 18:43:35 2005 +0100

    [ALSA] Remove superfluous pcm_free callbacks
    
    Remove superflous pcm_free callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index b94339f8306f..1be32999dfe1 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -1346,13 +1346,6 @@ static snd_pcm_ops_t snd_opti93x_capture_ops = {
 	.pointer =	snd_opti93x_capture_pointer,
 };
 
-static void snd_opti93x_pcm_free(snd_pcm_t *pcm)
-{
-	opti93x_t *codec = pcm->private_data;
-	codec->pcm = NULL;
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
 static int snd_opti93x_pcm(opti93x_t *codec, int device, snd_pcm_t **rpcm)
 {
 	int error;
@@ -1365,7 +1358,6 @@ static int snd_opti93x_pcm(opti93x_t *codec, int device, snd_pcm_t **rpcm)
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_opti93x_capture_ops);
 
 	pcm->private_data = codec;
-	pcm->private_free = snd_opti93x_pcm_free;
 	pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
 
 	strcpy(pcm->name, snd_opti93x_chip_id(codec));

commit b1d5776d865951c213a1caaab5d8bf5de7615dbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:56:31 2005 +0200

    [ALSA] Remove vmalloc wrapper, kfree_nocheck()
    
    - Remove vmalloc wrapper
    - Add release_and_free_resource() to remove kfree_nocheck() from each driver
      and simplify the code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 73573cb1db6a..b94339f8306f 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -299,10 +299,8 @@ static char * snd_opti9xx_names[] = {
 static long snd_legacy_find_free_ioport(long *port_table, long size)
 {
 	while (*port_table != -1) {
-		struct resource *res;
-		if ((res = request_region(*port_table, size, "ALSA test")) != NULL) {
-			release_resource(res);
-			kfree_nocheck(res);
+		if (request_region(*port_table, size, "ALSA test")) {
+			release_region(*port_table, size);
 			return *port_table;
 		}
 		port_table++;
@@ -1227,10 +1225,7 @@ static int snd_opti93x_probe(opti93x_t *chip)
 
 static int snd_opti93x_free(opti93x_t *chip)
 {
-	if (chip->res_port) {
-		release_resource(chip->res_port);
-		kfree_nocheck(chip->res_port);
-	}
+	release_and_free_resource(chip->res_port);
 	if (chip->dma1 >= 0) {
 		disable_dma(chip->dma1);
 		free_dma(chip->dma1);
@@ -1656,8 +1651,7 @@ static int __devinit snd_card_opti9xx_detect(snd_card_t *card, opti9xx_t *chip)
 			if (value == snd_opti9xx_read(chip, OPTi9XX_MC_REG(1)))
 				return 1;
 
-		release_resource(chip->res_mc_base);
-		kfree_nocheck(chip->res_mc_base);
+		release_and_free_resource(chip->res_mc_base);
 		chip->res_mc_base = NULL;
 
 	}
@@ -1683,8 +1677,7 @@ static int __devinit snd_card_opti9xx_detect(snd_card_t *card, opti9xx_t *chip)
 		if (snd_opti9xx_read(chip, OPTi9XX_MC_REG(7)) == 0xff - value)
 			return 1;
 
-		release_resource(chip->res_mc_base);
-		kfree_nocheck(chip->res_mc_base);
+		release_and_free_resource(chip->res_mc_base);
 		chip->res_mc_base = NULL;
 	}
 #endif	/* OPTi93X */
@@ -1886,12 +1879,8 @@ static void snd_card_opti9xx_free(snd_card_t *card)
 {
 	opti9xx_t *chip = (opti9xx_t *)card->private_data;
         
-	if (chip) {
-		if (chip->res_mc_base) {
-			release_resource(chip->res_mc_base);
-			kfree_nocheck(chip->res_mc_base);
-		}
-	}
+	if (chip)
+		release_and_free_resource(chip->res_mc_base);
 }
 
 static int snd_card_opti9xx_probe(struct pnp_card_link *pcard,

commit 9e76a76efc43d604a20bf0c5564caaf028a24d2e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:21:17 2005 +0200

    [ALSA] Replace with kzalloc() - isa stuff
    
    ES18xx driver,OPL3SA2 driver,AD1816A driver,AD1848 driver,CS4231 driver
    ES1688 driver,GUS Library,Opti9xx drivers,EMU8000 driver
    SB16/AWE driver,SB drivers
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index a490bcacdfa8..73573cb1db6a 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -1273,7 +1273,7 @@ static int snd_opti93x_create(snd_card_t *card, opti9xx_t *chip,
 	opti93x_t *codec;
 
 	*rcodec = NULL;
-	codec = kcalloc(1, sizeof(*codec), GFP_KERNEL);
+	codec = kzalloc(sizeof(*codec), GFP_KERNEL);
 	if (codec == NULL)
 		return -ENOMEM;
 	codec->irq = -1;

commit 43bcd973d6d05d16b876e09dcc49a09d3e48e88d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 5 17:19:20 2005 +0200

    [ALSA] Add snd_card_set_generic_dev() call to ISA drivers
    
    ISA,CMI8330 driver,ES18xx driver,OPL3SA2 driver,Sound Galaxy driver
    Sound Scape driver,AD1848 driver,CS4231 driver,CS4236+ driver
    ES1688 driver,GUS Classic driver,GUS Extreme driver,GUS MAX driver
    AMD InterWave driver,Opti9xx drivers,SB16/AWE driver,SB8 driver
    Wavefront drivers
    - Added snd_card_set_generic_dev() call.
    - Added SND_GENERIC_DRIVER to Kconfig.
    - Clean up the error path in probe if necessary.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 782750d62ebb..a490bcacdfa8 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -1894,8 +1894,8 @@ static void snd_card_opti9xx_free(snd_card_t *card)
 	}
 }
 
-static int __devinit snd_card_opti9xx_probe(struct pnp_card_link *pcard,
-					    const struct pnp_card_device_id *pid)
+static int snd_card_opti9xx_probe(struct pnp_card_link *pcard,
+				  const struct pnp_card_device_id *pid)
 {
 	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
 	static long possible_mpu_ports[] = {0x300, 0x310, 0x320, 0x330, -1};
@@ -1965,6 +1965,10 @@ static int __devinit snd_card_opti9xx_probe(struct pnp_card_link *pcard,
 			snd_card_free(card);
 			return error;
 		}
+		if ((error = snd_card_set_generic_dev(card)) < 0) {
+			snd_card_free(card);
+			return error;
+		}
 #ifdef CONFIG_PNP
 	}
 #endif	/* CONFIG_PNP */

commit db67319ac29d2f35ece30bce6a9b611afd6b600f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 5 10:36:27 2005 +0200

    [ALSA] opti93x: optimize a register access
    
    Opti9xx drivers
    When clearing some bits in a register, don't bother with the bits that
    won't be changed anyway.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
index 411a702d85ba..782750d62ebb 100644
--- a/sound/isa/opti9xx/opti92x-ad1848.c
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -1038,8 +1038,7 @@ static int snd_opti93x_capture_prepare(snd_pcm_substream_t *substream)
 
 	chip->c_dma_size = size;
 	snd_opti93x_out_mask(chip, OPTi93X_IFACE_CONF,
-		OPTi93X_CAPTURE_ENABLE | OPTi93X_CAPTURE_PIO,
-		(unsigned char)~(OPTi93X_CAPTURE_ENABLE | OPTi93X_CAPTURE_PIO));
+		OPTi93X_CAPTURE_ENABLE | OPTi93X_CAPTURE_PIO, 0);
 
 	snd_dma_program(chip->dma2, runtime->dma_addr, size,
 		DMA_MODE_READ | DMA_AUTOINIT);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/isa/opti9xx/opti92x-ad1848.c b/sound/isa/opti9xx/opti92x-ad1848.c
new file mode 100644
index 000000000000..411a702d85ba
--- /dev/null
+++ b/sound/isa/opti9xx/opti92x-ad1848.c
@@ -0,0 +1,2226 @@
+/*
+    card-opti92x-ad1848.c - driver for OPTi 82c92x based soundcards.
+    Copyright (C) 1998-2000 by Massimo Piccioni <dafastidio@libero.it>
+
+    Part of this code was developed at the Italian Ministry of Air Defence,
+    Sixth Division (oh, che pace ...), Rome.
+
+    Thanks to Maria Grazia Pollarini, Salvatore Vassallo.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/pnp.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#ifdef CS4231
+#include <sound/cs4231.h>
+#else
+#ifndef OPTi93X
+#include <sound/ad1848.h>
+#else
+#include <sound/control.h>
+#include <sound/pcm.h>
+#endif	/* OPTi93X */
+#endif	/* CS4231 */
+#include <sound/mpu401.h>
+#include <sound/opl3.h>
+#ifndef OPTi93X
+#include <sound/opl4.h>
+#endif
+#define SNDRV_LEGACY_FIND_FREE_IRQ
+#define SNDRV_LEGACY_FIND_FREE_DMA
+#include <sound/initval.h>
+
+MODULE_AUTHOR("Massimo Piccioni <dafastidio@libero.it>");
+MODULE_LICENSE("GPL");
+#ifdef OPTi93X
+MODULE_DESCRIPTION("OPTi93X");
+MODULE_SUPPORTED_DEVICE("{{OPTi,82C931/3}}");
+#else	/* OPTi93X */
+#ifdef CS4231
+MODULE_DESCRIPTION("OPTi92X - CS4231");
+MODULE_SUPPORTED_DEVICE("{{OPTi,82C924 (CS4231)},"
+		"{OPTi,82C925 (CS4231)}}");
+#else	/* CS4231 */
+MODULE_DESCRIPTION("OPTi92X - AD1848");
+MODULE_SUPPORTED_DEVICE("{{OPTi,82C924 (AD1848)},"
+		"{OPTi,82C925 (AD1848)},"
+	        "{OAK,Mozart}}");
+#endif	/* CS4231 */
+#endif	/* OPTi93X */
+
+static int index = SNDRV_DEFAULT_IDX1;	/* Index 0-MAX */
+static char *id = SNDRV_DEFAULT_STR1;		/* ID for this card */
+//static int enable = SNDRV_DEFAULT_ENABLE1;	/* Enable this card */
+static int isapnp = 1;			/* Enable ISA PnP detection */
+static long port = SNDRV_DEFAULT_PORT1; 	/* 0x530,0xe80,0xf40,0x604 */
+static long mpu_port = SNDRV_DEFAULT_PORT1;	/* 0x300,0x310,0x320,0x330 */
+static long fm_port = SNDRV_DEFAULT_PORT1;	/* 0x388 */
+static int irq = SNDRV_DEFAULT_IRQ1;		/* 5,7,9,10,11 */
+static int mpu_irq = SNDRV_DEFAULT_IRQ1;	/* 5,7,9,10 */
+static int dma1 = SNDRV_DEFAULT_DMA1;		/* 0,1,3 */
+#if defined(CS4231) || defined(OPTi93X)
+static int dma2 = SNDRV_DEFAULT_DMA1;		/* 0,1,3 */
+#endif	/* CS4231 || OPTi93X */
+
+module_param(index, int, 0444);
+MODULE_PARM_DESC(index, "Index value for opti9xx based soundcard.");
+module_param(id, charp, 0444);
+MODULE_PARM_DESC(id, "ID string for opti9xx based soundcard.");
+//module_param(enable, bool, 0444);
+//MODULE_PARM_DESC(enable, "Enable opti9xx soundcard.");
+module_param(isapnp, bool, 0444);
+MODULE_PARM_DESC(isapnp, "Enable ISA PnP detection for specified soundcard.");
+module_param(port, long, 0444);
+MODULE_PARM_DESC(port, "WSS port # for opti9xx driver.");
+module_param(mpu_port, long, 0444);
+MODULE_PARM_DESC(mpu_port, "MPU-401 port # for opti9xx driver.");
+module_param(fm_port, long, 0444);
+MODULE_PARM_DESC(fm_port, "FM port # for opti9xx driver.");
+module_param(irq, int, 0444);
+MODULE_PARM_DESC(irq, "WSS irq # for opti9xx driver.");
+module_param(mpu_irq, int, 0444);
+MODULE_PARM_DESC(mpu_irq, "MPU-401 irq # for opti9xx driver.");
+module_param(dma1, int, 0444);
+MODULE_PARM_DESC(dma1, "1st dma # for opti9xx driver.");
+#if defined(CS4231) || defined(OPTi93X)
+module_param(dma2, int, 0444);
+MODULE_PARM_DESC(dma2, "2nd dma # for opti9xx driver.");
+#endif	/* CS4231 || OPTi93X */
+
+#define OPTi9XX_HW_DETECT	0
+#define OPTi9XX_HW_82C928	1
+#define OPTi9XX_HW_82C929	2
+#define OPTi9XX_HW_82C924	3
+#define OPTi9XX_HW_82C925	4
+#define OPTi9XX_HW_82C930	5
+#define OPTi9XX_HW_82C931	6
+#define OPTi9XX_HW_82C933	7
+#define OPTi9XX_HW_LAST		OPTi9XX_HW_82C933
+
+#define OPTi9XX_MC_REG(n)	n
+
+typedef struct _snd_opti9xx opti9xx_t;
+
+#ifdef OPTi93X
+
+#define OPTi93X_INDEX			0x00
+#define OPTi93X_DATA			0x01
+#define OPTi93X_STATUS			0x02
+#define OPTi93X_DDATA			0x03
+#define OPTi93X_PORT(chip, r)		((chip)->port + OPTi93X_##r)
+
+#define OPTi93X_MIXOUT_LEFT		0x00
+#define OPTi93X_MIXOUT_RIGHT		0x01
+#define OPTi93X_CD_LEFT_INPUT		0x02
+#define OPTi93X_CD_RIGHT_INPUT		0x03
+#define OPTi930_AUX_LEFT_INPUT		0x04
+#define OPTi930_AUX_RIGHT_INPUT		0x05
+#define OPTi931_FM_LEFT_INPUT		0x04
+#define OPTi931_FM_RIGHT_INPUT		0x05
+#define OPTi93X_DAC_LEFT		0x06
+#define OPTi93X_DAC_RIGHT		0x07
+#define OPTi93X_PLAY_FORMAT		0x08
+#define OPTi93X_IFACE_CONF		0x09
+#define OPTi93X_PIN_CTRL		0x0a
+#define OPTi93X_ERR_INIT		0x0b
+#define OPTi93X_ID			0x0c
+#define OPTi93X_PLAY_UPR_CNT		0x0e
+#define OPTi93X_PLAY_LWR_CNT		0x0f
+#define OPTi931_AUX_LEFT_INPUT		0x10
+#define OPTi931_AUX_RIGHT_INPUT		0x11
+#define OPTi93X_LINE_LEFT_INPUT		0x12
+#define OPTi93X_LINE_RIGHT_INPUT	0x13
+#define OPTi93X_MIC_LEFT_INPUT		0x14
+#define OPTi93X_MIC_RIGHT_INPUT		0x15
+#define OPTi93X_OUT_LEFT		0x16
+#define OPTi93X_OUT_RIGHT		0x17
+#define OPTi93X_CAPT_FORMAT		0x1c
+#define OPTi93X_CAPT_UPR_CNT		0x1e
+#define OPTi93X_CAPT_LWR_CNT		0x1f
+
+#define OPTi93X_TRD			0x20
+#define OPTi93X_MCE			0x40
+#define OPTi93X_INIT			0x80
+
+#define OPTi93X_MIXOUT_MIC_GAIN		0x20
+#define OPTi93X_MIXOUT_LINE		0x00
+#define OPTi93X_MIXOUT_CD		0x40
+#define OPTi93X_MIXOUT_MIC		0x80
+#define OPTi93X_MIXOUT_MIXER		0xc0
+
+#define OPTi93X_STEREO			0x10
+#define OPTi93X_LINEAR_8		0x00
+#define OPTi93X_ULAW_8			0x20
+#define OPTi93X_LINEAR_16_LIT		0x40
+#define OPTi93X_ALAW_8			0x60
+#define OPTi93X_ADPCM_16		0xa0
+#define OPTi93X_LINEAR_16_BIG		0xc0
+
+#define OPTi93X_CAPTURE_PIO		0x80
+#define OPTi93X_PLAYBACK_PIO		0x40
+#define OPTi93X_AUTOCALIB		0x08
+#define OPTi93X_SINGLE_DMA		0x04
+#define OPTi93X_CAPTURE_ENABLE		0x02
+#define OPTi93X_PLAYBACK_ENABLE		0x01
+
+#define OPTi93X_IRQ_ENABLE		0x02
+
+#define OPTi93X_DMA_REQUEST		0x10
+#define OPTi93X_CALIB_IN_PROGRESS	0x20
+
+#define OPTi93X_IRQ_PLAYBACK		0x04
+#define OPTi93X_IRQ_CAPTURE		0x08
+
+
+typedef struct _snd_opti93x opti93x_t;
+
+struct _snd_opti93x {
+	unsigned long port;
+	struct resource *res_port;
+	int irq;
+	int dma1;
+	int dma2;
+
+	opti9xx_t *chip;
+	unsigned short hardware;
+	unsigned char image[32];
+
+	unsigned char mce_bit;
+	unsigned short mode;
+	int mute;
+
+	spinlock_t lock;
+
+	snd_card_t *card;
+	snd_pcm_t *pcm;
+	snd_pcm_substream_t *playback_substream;
+	snd_pcm_substream_t *capture_substream;
+	unsigned int p_dma_size;
+	unsigned int c_dma_size;
+};
+
+#define OPTi93X_MODE_NONE	0x00
+#define OPTi93X_MODE_PLAY	0x01
+#define OPTi93X_MODE_CAPTURE	0x02
+#define OPTi93X_MODE_OPEN	(OPTi93X_MODE_PLAY | OPTi93X_MODE_CAPTURE)
+
+#endif /* OPTi93X */
+
+struct _snd_opti9xx {
+	unsigned short hardware;
+	unsigned char password;
+	char name[7];
+
+	unsigned long mc_base;
+	struct resource *res_mc_base;
+	unsigned long mc_base_size;
+#ifdef OPTi93X
+	unsigned long mc_indir_index;
+#endif	/* OPTi93X */
+	unsigned long pwd_reg;
+
+	spinlock_t lock;
+
+	long wss_base;
+	int irq;
+	int dma1;
+#if defined(CS4231) || defined(OPTi93X)
+	int dma2;
+#endif	/* CS4231 || OPTi93X */
+
+	long fm_port;
+
+	long mpu_port;
+	int mpu_irq;
+
+#ifdef CONFIG_PNP
+	struct pnp_dev *dev;
+	struct pnp_dev *devmpu;
+#endif	/* CONFIG_PNP */
+};
+
+static int snd_opti9xx_first_hit = 1;
+static snd_card_t *snd_opti9xx_legacy = SNDRV_DEFAULT_PTR1;
+
+#ifdef CONFIG_PNP
+
+static struct pnp_card_device_id snd_opti9xx_pnpids[] = {
+#ifndef OPTi93X
+	/* OPTi 82C924 */
+	{ .id = "OPT0924", .devs = { { "OPT0000" }, { "OPT0002" } }, .driver_data = 0x0924 },
+	/* OPTi 82C925 */
+	{ .id = "OPT0925", .devs = { { "OPT9250" }, { "OPT0002" } }, .driver_data = 0x0925 },
+#else
+	/* OPTi 82C931/3 */
+	{ .id = "OPT0931", .devs = { { "OPT9310" }, { "OPT0002" } }, .driver_data = 0x0931 },
+#endif	/* OPTi93X */
+	{ .id = "" }
+};
+
+MODULE_DEVICE_TABLE(pnp_card, snd_opti9xx_pnpids);
+
+#endif	/* CONFIG_PNP */
+
+#ifdef OPTi93X
+#define DRIVER_NAME	"snd-card-opti93x"
+#else
+#define DRIVER_NAME	"snd-card-opti92x"
+#endif	/* OPTi93X */
+
+static char * snd_opti9xx_names[] = {
+	"unkown",
+	"82C928",	"82C929",
+	"82C924",	"82C925",
+	"82C930",	"82C931",	"82C933"
+};
+
+
+static long snd_legacy_find_free_ioport(long *port_table, long size)
+{
+	while (*port_table != -1) {
+		struct resource *res;
+		if ((res = request_region(*port_table, size, "ALSA test")) != NULL) {
+			release_resource(res);
+			kfree_nocheck(res);
+			return *port_table;
+		}
+		port_table++;
+	}
+	return -1;
+}
+
+static int __devinit snd_opti9xx_init(opti9xx_t *chip, unsigned short hardware)
+{
+	static int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};
+
+	chip->hardware = hardware;
+	strcpy(chip->name, snd_opti9xx_names[hardware]);
+
+	chip->mc_base_size = opti9xx_mc_size[hardware];  
+
+	spin_lock_init(&chip->lock);
+
+	chip->wss_base = -1;
+	chip->irq = -1;
+	chip->dma1 = -1;
+#if defined(CS4231) || defined (OPTi93X)
+	chip->dma2 = -1;
+#endif 	/* CS4231 || OPTi93X */
+	chip->fm_port = -1;
+	chip->mpu_port = -1;
+	chip->mpu_irq = -1;
+
+	switch (hardware) {
+#ifndef OPTi93X
+	case OPTi9XX_HW_82C928:
+	case OPTi9XX_HW_82C929:
+		chip->mc_base = 0xf8c;
+		chip->password = (hardware == OPTi9XX_HW_82C928) ? 0xe2 : 0xe3;
+		chip->pwd_reg = 3;
+		break;
+
+	case OPTi9XX_HW_82C924:
+	case OPTi9XX_HW_82C925:
+		chip->mc_base = 0xf8c;
+		chip->password = 0xe5;
+		chip->pwd_reg = 3;
+		break;
+#else	/* OPTi93X */
+
+	case OPTi9XX_HW_82C930:
+	case OPTi9XX_HW_82C931:
+	case OPTi9XX_HW_82C933:
+		chip->mc_base = (hardware == OPTi9XX_HW_82C930) ? 0xf8f : 0xf8d;
+		chip->mc_indir_index = 0xe0e;
+		chip->password = 0xe4;
+		chip->pwd_reg = 0;
+		break;
+#endif	/* OPTi93X */
+
+	default:
+		snd_printk("chip %d not supported\n", hardware);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static unsigned char snd_opti9xx_read(opti9xx_t *chip,
+				      unsigned char reg)
+{
+	unsigned long flags;
+	unsigned char retval = 0xff;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	outb(chip->password, chip->mc_base + chip->pwd_reg);
+
+	switch (chip->hardware) {
+#ifndef OPTi93X
+	case OPTi9XX_HW_82C924:
+	case OPTi9XX_HW_82C925:
+		if (reg > 7) {
+			outb(reg, chip->mc_base + 8);
+			outb(chip->password, chip->mc_base + chip->pwd_reg);
+			retval = inb(chip->mc_base + 9);
+			break;
+		}
+
+	case OPTi9XX_HW_82C928:
+	case OPTi9XX_HW_82C929:
+		retval = inb(chip->mc_base + reg);
+		break;
+#else	/* OPTi93X */
+
+	case OPTi9XX_HW_82C930:
+	case OPTi9XX_HW_82C931:
+	case OPTi9XX_HW_82C933:
+		outb(reg, chip->mc_indir_index);
+		outb(chip->password, chip->mc_base + chip->pwd_reg);
+		retval = inb(chip->mc_indir_index + 1);
+		break;
+#endif	/* OPTi93X */
+
+	default:
+		snd_printk("chip %d not supported\n", chip->hardware);
+	}
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+	return retval;
+}
+	
+static void snd_opti9xx_write(opti9xx_t *chip, unsigned char reg,
+			      unsigned char value)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	outb(chip->password, chip->mc_base + chip->pwd_reg);
+
+	switch (chip->hardware) {
+#ifndef OPTi93X
+	case OPTi9XX_HW_82C924:
+	case OPTi9XX_HW_82C925:
+		if (reg > 7) {
+			outb(reg, chip->mc_base + 8);
+			outb(chip->password, chip->mc_base + chip->pwd_reg);
+			outb(value, chip->mc_base + 9);
+			break;
+		}
+
+	case OPTi9XX_HW_82C928:
+	case OPTi9XX_HW_82C929:
+		outb(value, chip->mc_base + reg);
+		break;
+#else	/* OPTi93X */
+
+	case OPTi9XX_HW_82C930:
+	case OPTi9XX_HW_82C931:
+	case OPTi9XX_HW_82C933:
+		outb(reg, chip->mc_indir_index);
+		outb(chip->password, chip->mc_base + chip->pwd_reg);
+		outb(value, chip->mc_indir_index + 1);
+		break;
+#endif	/* OPTi93X */
+
+	default:
+		snd_printk("chip %d not supported\n", chip->hardware);
+	}
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+
+#define snd_opti9xx_write_mask(chip, reg, value, mask)	\
+	snd_opti9xx_write(chip, reg,			\
+		(snd_opti9xx_read(chip, reg) & ~(mask)) | ((value) & (mask)))
+
+
+static int __devinit snd_opti9xx_configure(opti9xx_t *chip)
+{
+	unsigned char wss_base_bits;
+	unsigned char irq_bits;
+	unsigned char dma_bits;
+	unsigned char mpu_port_bits = 0;
+	unsigned char mpu_irq_bits;
+
+	switch (chip->hardware) {
+#ifndef OPTi93X
+	case OPTi9XX_HW_82C924:
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(4), 0xf0, 0xfc);
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x02);
+
+	case OPTi9XX_HW_82C925:
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2), 0x00, 0x20);
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(3), 0xf0, 0xff);
+#ifdef CS4231
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);
+#else
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x00, 0x02);
+#endif	/* CS4231 */
+		break;
+
+	case OPTi9XX_HW_82C928:
+	case OPTi9XX_HW_82C929:
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2), 0x00, 0x20);
+		/*
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(3), 0xa2, 0xae);
+		*/
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(4), 0x00, 0x0c);
+#ifdef CS4231
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);
+#else
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x00, 0x02);
+#endif	/* CS4231 */
+		break;
+
+#else	/* OPTi93X */
+	case OPTi9XX_HW_82C930:
+	case OPTi9XX_HW_82C931:
+	case OPTi9XX_HW_82C933:
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x03);
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(3), 0x00, 0xff);
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(4), 0x10 |
+			(chip->hardware == OPTi9XX_HW_82C930 ? 0x00 : 0x04),
+			0x34);
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(5), 0x20, 0xbf);
+		break;
+#endif	/* OPTi93X */
+
+	default:
+		snd_printk("chip %d not supported\n", chip->hardware);
+		return -EINVAL;
+	}
+
+	switch (chip->wss_base) {
+	case 0x530:
+		wss_base_bits = 0x00;
+		break;
+	case 0x604:
+		wss_base_bits = 0x03;
+		break;
+	case 0xe80:
+		wss_base_bits = 0x01;
+		break;
+	case 0xf40:
+		wss_base_bits = 0x02;
+		break;
+	default:
+		snd_printk("WSS port 0x%lx not valid\n", chip->wss_base);
+		goto __skip_base;
+	}
+	snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(1), wss_base_bits << 4, 0x30);
+
+__skip_base:
+	switch (chip->irq) {
+//#ifdef OPTi93X
+	case 5:
+		irq_bits = 0x05;
+		break;
+//#endif	/* OPTi93X */
+	case 7:
+		irq_bits = 0x01;
+		break;
+	case 9:
+		irq_bits = 0x02;
+		break;
+	case 10:
+		irq_bits = 0x03;
+		break;
+	case 11:
+		irq_bits = 0x04;
+		break;
+	default:
+		snd_printk("WSS irq # %d not valid\n", chip->irq);
+		goto __skip_resources;
+	}
+
+	switch (chip->dma1) {
+	case 0:
+		dma_bits = 0x01;
+		break;
+	case 1:
+		dma_bits = 0x02;
+		break;
+	case 3:
+		dma_bits = 0x03;
+		break;
+	default:
+		snd_printk("WSS dma1 # %d not valid\n", chip->dma1);
+		goto __skip_resources;
+	}
+
+#if defined(CS4231) || defined(OPTi93X)
+	if (chip->dma1 == chip->dma2) {
+		snd_printk("don't want to share dmas\n");
+		return -EBUSY;
+	}
+
+	switch (chip->dma2) {
+	case 0:
+	case 1:
+		break;
+	default:
+		snd_printk("WSS dma2 # %d not valid\n", chip->dma2);
+		goto __skip_resources;
+	}
+	dma_bits |= 0x04;
+#endif	/* CS4231 || OPTi93X */
+
+#ifndef OPTi93X
+	 outb(irq_bits << 3 | dma_bits, chip->wss_base);
+#else /* OPTi93X */
+	snd_opti9xx_write(chip, OPTi9XX_MC_REG(3), (irq_bits << 3 | dma_bits));
+#endif /* OPTi93X */
+
+__skip_resources:
+	if (chip->hardware > OPTi9XX_HW_82C928) {
+		switch (chip->mpu_port) {
+		case 0:
+		case -1:
+			break;
+		case 0x300:
+			mpu_port_bits = 0x03;
+			break;
+		case 0x310:
+			mpu_port_bits = 0x02;
+			break;
+		case 0x320:
+			mpu_port_bits = 0x01;
+			break;
+		case 0x330:
+			mpu_port_bits = 0x00;
+			break;
+		default:
+			snd_printk("MPU-401 port 0x%lx not valid\n",
+				chip->mpu_port);
+			goto __skip_mpu;
+		}
+
+		switch (chip->mpu_irq) {
+		case 5:
+			mpu_irq_bits = 0x02;
+			break;
+		case 7:
+			mpu_irq_bits = 0x03;
+			break;
+		case 9:
+			mpu_irq_bits = 0x00;
+			break;
+		case 10:
+			mpu_irq_bits = 0x01;
+			break;
+		default:
+			snd_printk("MPU-401 irq # %d not valid\n",
+				chip->mpu_irq);
+			goto __skip_mpu;
+		}
+
+		snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(6),
+			(chip->mpu_port <= 0) ? 0x00 :
+				0x80 | mpu_port_bits << 5 | mpu_irq_bits << 3,
+			0xf8);
+	}
+__skip_mpu:
+
+	return 0;
+}
+
+#ifdef OPTi93X
+
+static unsigned char snd_opti93x_default_image[32] =
+{
+	0x00,		/* 00/00 - l_mixout_outctrl */
+	0x00,		/* 01/01 - r_mixout_outctrl */
+	0x88,		/* 02/02 - l_cd_inctrl */
+	0x88,		/* 03/03 - r_cd_inctrl */
+	0x88,		/* 04/04 - l_a1/fm_inctrl */
+	0x88,		/* 05/05 - r_a1/fm_inctrl */
+	0x80,		/* 06/06 - l_dac_inctrl */
+	0x80,		/* 07/07 - r_dac_inctrl */
+	0x00,		/* 08/08 - ply_dataform_reg */
+	0x00,		/* 09/09 - if_conf */
+	0x00,		/* 0a/10 - pin_ctrl */
+	0x00,		/* 0b/11 - err_init_reg */
+	0x0a,		/* 0c/12 - id_reg */
+	0x00,		/* 0d/13 - reserved */
+	0x00,		/* 0e/14 - ply_upcount_reg */
+	0x00,		/* 0f/15 - ply_lowcount_reg */
+	0x88,		/* 10/16 - reserved/l_a1_inctrl */
+	0x88,		/* 11/17 - reserved/r_a1_inctrl */
+	0x88,		/* 12/18 - l_line_inctrl */
+	0x88,		/* 13/19 - r_line_inctrl */
+	0x88,		/* 14/20 - l_mic_inctrl */
+	0x88,		/* 15/21 - r_mic_inctrl */
+	0x80,		/* 16/22 - l_out_outctrl */
+	0x80,		/* 17/23 - r_out_outctrl */
+	0x00,		/* 18/24 - reserved */
+	0x00,		/* 19/25 - reserved */
+	0x00,		/* 1a/26 - reserved */
+	0x00,		/* 1b/27 - reserved */
+	0x00,		/* 1c/28 - cap_dataform_reg */
+	0x00,		/* 1d/29 - reserved */
+	0x00,		/* 1e/30 - cap_upcount_reg */
+	0x00		/* 1f/31 - cap_lowcount_reg */
+};
+
+
+static int snd_opti93x_busy_wait(opti93x_t *chip)
+{
+	int timeout;
+
+	for (timeout = 250; timeout-- > 0; udelay(10))
+		if (!(inb(OPTi93X_PORT(chip, INDEX)) & OPTi93X_INIT))
+			return 0;
+
+	snd_printk("chip still busy.\n");
+	return -EBUSY;
+}
+
+static unsigned char snd_opti93x_in(opti93x_t *chip, unsigned char reg)
+{
+	snd_opti93x_busy_wait(chip);
+	outb(chip->mce_bit | (reg & 0x1f), OPTi93X_PORT(chip, INDEX));
+	return inb(OPTi93X_PORT(chip, DATA));
+}
+
+static void snd_opti93x_out(opti93x_t *chip, unsigned char reg,
+			    unsigned char value)
+{
+	snd_opti93x_busy_wait(chip);
+	outb(chip->mce_bit | (reg & 0x1f), OPTi93X_PORT(chip, INDEX));
+	outb(value, OPTi93X_PORT(chip, DATA));
+}
+
+static void snd_opti93x_out_image(opti93x_t *chip, unsigned char reg,
+				  unsigned char value)
+{
+	snd_opti93x_out(chip, reg, chip->image[reg] = value);
+}
+
+static void snd_opti93x_out_mask(opti93x_t *chip, unsigned char reg,
+				 unsigned char mask, unsigned char value)
+{
+	snd_opti93x_out_image(chip, reg,
+		(chip->image[reg] & ~mask) | (value & mask));
+}
+
+
+static void snd_opti93x_mce_up(opti93x_t *chip)
+{
+	snd_opti93x_busy_wait(chip);
+
+	chip->mce_bit = OPTi93X_MCE;
+	if (!(inb(OPTi93X_PORT(chip, INDEX)) & OPTi93X_MCE))
+		outb(chip->mce_bit, OPTi93X_PORT(chip, INDEX));
+}
+
+static void snd_opti93x_mce_down(opti93x_t *chip)
+{
+	snd_opti93x_busy_wait(chip);
+
+	chip->mce_bit = 0;
+	if (inb(OPTi93X_PORT(chip, INDEX)) & OPTi93X_MCE)
+		outb(chip->mce_bit, OPTi93X_PORT(chip, INDEX));
+}
+
+#define snd_opti93x_mute_reg(chip, reg, mute)	\
+	snd_opti93x_out(chip, reg, mute ? 0x80 : chip->image[reg]);
+
+static void snd_opti93x_mute(opti93x_t *chip, int mute)
+{
+	mute = mute ? 1 : 0;
+	if (chip->mute == mute)
+		return;
+
+	chip->mute = mute;
+
+	snd_opti93x_mute_reg(chip, OPTi93X_CD_LEFT_INPUT, mute);
+	snd_opti93x_mute_reg(chip, OPTi93X_CD_RIGHT_INPUT, mute);
+	switch (chip->hardware) {
+	case OPTi9XX_HW_82C930:
+		snd_opti93x_mute_reg(chip, OPTi930_AUX_LEFT_INPUT, mute);
+		snd_opti93x_mute_reg(chip, OPTi930_AUX_RIGHT_INPUT, mute);
+		break;
+	case OPTi9XX_HW_82C931:
+	case OPTi9XX_HW_82C933:
+		snd_opti93x_mute_reg(chip, OPTi931_FM_LEFT_INPUT, mute);
+		snd_opti93x_mute_reg(chip, OPTi931_FM_RIGHT_INPUT, mute);
+		snd_opti93x_mute_reg(chip, OPTi931_AUX_LEFT_INPUT, mute);
+		snd_opti93x_mute_reg(chip, OPTi931_AUX_RIGHT_INPUT, mute);
+	}
+	snd_opti93x_mute_reg(chip, OPTi93X_DAC_LEFT, mute);
+	snd_opti93x_mute_reg(chip, OPTi93X_DAC_RIGHT, mute);
+	snd_opti93x_mute_reg(chip, OPTi93X_LINE_LEFT_INPUT, mute);
+	snd_opti93x_mute_reg(chip, OPTi93X_LINE_RIGHT_INPUT, mute);
+	snd_opti93x_mute_reg(chip, OPTi93X_MIC_LEFT_INPUT, mute);
+	snd_opti93x_mute_reg(chip, OPTi93X_MIC_RIGHT_INPUT, mute);
+	snd_opti93x_mute_reg(chip, OPTi93X_OUT_LEFT, mute);
+	snd_opti93x_mute_reg(chip, OPTi93X_OUT_RIGHT, mute);
+}
+
+
+static unsigned int snd_opti93x_get_count(unsigned char format,
+					  unsigned int size)
+{
+	switch (format & 0xe0) {
+	case OPTi93X_LINEAR_16_LIT:
+	case OPTi93X_LINEAR_16_BIG:
+		size >>= 1;
+		break;
+	case OPTi93X_ADPCM_16:
+		return size >> 2;
+	}
+	return (format & OPTi93X_STEREO) ? (size >> 1) : size;
+}
+
+static unsigned int rates[] = {  5512,  6615,  8000,  9600, 11025, 16000, 
+				18900, 22050, 27428, 32000, 33075, 37800,
+				44100, 48000 };
+#define RATES ARRAY_SIZE(rates)
+
+static snd_pcm_hw_constraint_list_t hw_constraints_rates = {
+	.count = RATES,
+	.list = rates,
+	.mask = 0,
+};
+
+static unsigned char bits[] = {  0x01,  0x0f,  0x00,  0x0e,  0x03,  0x02,
+				 0x05,  0x07,  0x04,  0x06,  0x0d,  0x09,
+				 0x0b,  0x0c};
+
+static unsigned char snd_opti93x_get_freq(unsigned int rate)
+{
+	unsigned int i;
+
+	for (i = 0; i < RATES; i++) {
+		if (rate == rates[i])
+			return bits[i];
+	}
+	snd_BUG();
+	return bits[RATES-1];
+}
+
+static unsigned char snd_opti93x_get_format(opti93x_t *chip,
+					    unsigned int format, int channels)
+{
+	unsigned char retval = OPTi93X_LINEAR_8;
+
+	switch (format) {
+	case SNDRV_PCM_FORMAT_MU_LAW:
+		retval = OPTi93X_ULAW_8;
+		break;
+	case SNDRV_PCM_FORMAT_A_LAW:
+		retval = OPTi93X_ALAW_8;
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		retval = OPTi93X_LINEAR_16_LIT;
+		break;
+	case SNDRV_PCM_FORMAT_S16_BE:
+		retval = OPTi93X_LINEAR_16_BIG;
+		break;
+	case SNDRV_PCM_FORMAT_IMA_ADPCM:
+		retval = OPTi93X_ADPCM_16;
+	}
+	return (channels > 1) ? (retval | OPTi93X_STEREO) : retval;
+}
+
+
+static void snd_opti93x_playback_format(opti93x_t *chip, unsigned char fmt)
+{
+	unsigned char mask;
+
+	snd_opti93x_mute(chip, 1);
+
+	snd_opti93x_mce_up(chip);
+	mask = (chip->mode & OPTi93X_MODE_CAPTURE) ? 0xf0 : 0xff;
+	snd_opti93x_out_mask(chip, OPTi93X_PLAY_FORMAT, mask, fmt);
+	snd_opti93x_mce_down(chip);
+
+	snd_opti93x_mute(chip, 0);
+}
+
+static void snd_opti93x_capture_format(opti93x_t *chip, unsigned char fmt)
+{
+	snd_opti93x_mute(chip, 1);
+
+	snd_opti93x_mce_up(chip);
+	if (!(chip->mode & OPTi93X_MODE_PLAY))
+		snd_opti93x_out_mask(chip, OPTi93X_PLAY_FORMAT, 0x0f, fmt);
+	else
+		fmt = chip->image[OPTi93X_PLAY_FORMAT] & 0xf0;
+	snd_opti93x_out_image(chip, OPTi93X_CAPT_FORMAT, fmt);
+	snd_opti93x_mce_down(chip);
+
+	snd_opti93x_mute(chip, 0);
+}
+
+
+static int snd_opti93x_open(opti93x_t *chip, unsigned int mode)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	if (chip->mode & mode) {
+		spin_unlock_irqrestore(&chip->lock, flags);
+		return -EAGAIN;
+	}
+
+	if (!(chip->mode & OPTi93X_MODE_OPEN)) {
+		outb(0x00, OPTi93X_PORT(chip, STATUS));
+		snd_opti93x_out_mask(chip, OPTi93X_PIN_CTRL,
+			OPTi93X_IRQ_ENABLE, OPTi93X_IRQ_ENABLE);
+		chip->mode = mode;
+	}
+	else
+		chip->mode |= mode;
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+	return 0;
+}
+
+static void snd_opti93x_close(opti93x_t *chip, unsigned int mode)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	chip->mode &= ~mode;
+	if (chip->mode & OPTi93X_MODE_OPEN) {
+		spin_unlock_irqrestore(&chip->lock, flags);
+		return;
+	}
+
+	snd_opti93x_mute(chip, 1);
+
+	outb(0, OPTi93X_PORT(chip, STATUS));
+	snd_opti93x_out_mask(chip, OPTi93X_PIN_CTRL, OPTi93X_IRQ_ENABLE,
+		~OPTi93X_IRQ_ENABLE);
+
+	snd_opti93x_mce_up(chip);
+	snd_opti93x_out_image(chip, OPTi93X_IFACE_CONF, 0x00);
+	snd_opti93x_mce_down(chip);
+	chip->mode = 0;
+
+	snd_opti93x_mute(chip, 0);
+	spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+static int snd_opti93x_trigger(snd_pcm_substream_t *substream, 
+			       unsigned char what, int cmd)
+{
+	opti93x_t *chip = snd_pcm_substream_chip(substream);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_STOP:
+	{
+		unsigned int what = 0;
+		struct list_head *pos;
+		snd_pcm_substream_t *s;
+		snd_pcm_group_for_each(pos, substream) {
+			s = snd_pcm_group_substream_entry(pos);
+			if (s == chip->playback_substream) {
+				what |= OPTi93X_PLAYBACK_ENABLE;
+				snd_pcm_trigger_done(s, substream);
+			} else if (s == chip->capture_substream) {
+				what |= OPTi93X_CAPTURE_ENABLE;
+				snd_pcm_trigger_done(s, substream);
+			}
+		}
+		spin_lock(&chip->lock);
+		if (cmd == SNDRV_PCM_TRIGGER_START) {
+			snd_opti93x_out_mask(chip, OPTi93X_IFACE_CONF, what, what);
+			if (what & OPTi93X_CAPTURE_ENABLE)
+				udelay(50);
+		} else
+			snd_opti93x_out_mask(chip, OPTi93X_IFACE_CONF, what, 0x00);
+		spin_unlock(&chip->lock);
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int snd_opti93x_playback_trigger(snd_pcm_substream_t *substream, int cmd)
+{
+	return snd_opti93x_trigger(substream,
+				   OPTi93X_PLAYBACK_ENABLE, cmd);
+}
+
+static int snd_opti93x_capture_trigger(snd_pcm_substream_t * substream, int cmd)
+{
+	return snd_opti93x_trigger(substream,
+				   OPTi93X_CAPTURE_ENABLE, cmd);
+}
+
+static int snd_opti93x_hw_params(snd_pcm_substream_t * substream,
+				 snd_pcm_hw_params_t * hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+}
+
+
+static int snd_opti93x_hw_free(snd_pcm_substream_t * substream)
+{
+	snd_pcm_lib_free_pages(substream);
+	return 0;
+}
+
+
+static int snd_opti93x_playback_prepare(snd_pcm_substream_t * substream)
+{
+	opti93x_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned long flags;
+	unsigned char format;
+	unsigned int count = snd_pcm_lib_period_bytes(substream);
+	unsigned int size = snd_pcm_lib_buffer_bytes(substream);
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	chip->p_dma_size = size;
+	snd_opti93x_out_mask(chip, OPTi93X_IFACE_CONF,
+		OPTi93X_PLAYBACK_ENABLE | OPTi93X_PLAYBACK_PIO,
+		~(OPTi93X_PLAYBACK_ENABLE | OPTi93X_PLAYBACK_PIO));
+
+	snd_dma_program(chip->dma1, runtime->dma_addr, size,
+		DMA_MODE_WRITE | DMA_AUTOINIT);
+
+	format = snd_opti93x_get_freq(runtime->rate);
+	format |= snd_opti93x_get_format(chip, runtime->format,
+		runtime->channels);
+	snd_opti93x_playback_format(chip, format);
+	format = chip->image[OPTi93X_PLAY_FORMAT];
+
+	count = snd_opti93x_get_count(format, count) - 1;
+	snd_opti93x_out_image(chip, OPTi93X_PLAY_LWR_CNT, count);
+	snd_opti93x_out_image(chip, OPTi93X_PLAY_UPR_CNT, count >> 8);
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+	return 0;
+}
+
+static int snd_opti93x_capture_prepare(snd_pcm_substream_t *substream)
+{
+	opti93x_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned long flags;
+	unsigned char format;
+	unsigned int count = snd_pcm_lib_period_bytes(substream);
+	unsigned int size = snd_pcm_lib_buffer_bytes(substream);
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	chip->c_dma_size = size;
+	snd_opti93x_out_mask(chip, OPTi93X_IFACE_CONF,
+		OPTi93X_CAPTURE_ENABLE | OPTi93X_CAPTURE_PIO,
+		(unsigned char)~(OPTi93X_CAPTURE_ENABLE | OPTi93X_CAPTURE_PIO));
+
+	snd_dma_program(chip->dma2, runtime->dma_addr, size,
+		DMA_MODE_READ | DMA_AUTOINIT);
+
+	format = snd_opti93x_get_freq(runtime->rate);
+	format |= snd_opti93x_get_format(chip, runtime->format,
+		runtime->channels);
+	snd_opti93x_capture_format(chip, format);
+	format = chip->image[OPTi93X_CAPT_FORMAT];
+
+	count = snd_opti93x_get_count(format, count) - 1;
+	snd_opti93x_out_image(chip, OPTi93X_CAPT_LWR_CNT, count);
+	snd_opti93x_out_image(chip, OPTi93X_CAPT_UPR_CNT, count >> 8);
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+	return 0;
+}
+
+static snd_pcm_uframes_t snd_opti93x_playback_pointer(snd_pcm_substream_t *substream)
+{
+	opti93x_t *chip = snd_pcm_substream_chip(substream);
+	size_t ptr;
+
+	if (!(chip->image[OPTi93X_IFACE_CONF] & OPTi93X_PLAYBACK_ENABLE))
+		return 0;
+
+	ptr = snd_dma_pointer(chip->dma1, chip->p_dma_size);
+	return bytes_to_frames(substream->runtime, ptr);
+}
+
+static snd_pcm_uframes_t snd_opti93x_capture_pointer(snd_pcm_substream_t *substream)
+{
+	opti93x_t *chip = snd_pcm_substream_chip(substream);
+	size_t ptr;
+	
+	if (!(chip->image[OPTi93X_IFACE_CONF] & OPTi93X_CAPTURE_ENABLE))
+		return 0;
+
+	ptr = snd_dma_pointer(chip->dma2, chip->c_dma_size);
+	return bytes_to_frames(substream->runtime, ptr);
+}
+
+
+static void snd_opti93x_overrange(opti93x_t *chip)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->lock, flags);
+
+	if (snd_opti93x_in(chip, OPTi93X_ERR_INIT) & (0x08 | 0x02))
+		chip->capture_substream->runtime->overrange++;
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+static irqreturn_t snd_opti93x_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	opti93x_t *codec = dev_id;
+	unsigned char status;
+
+	status = snd_opti9xx_read(codec->chip, OPTi9XX_MC_REG(11));
+	if ((status & OPTi93X_IRQ_PLAYBACK) && codec->playback_substream)
+		snd_pcm_period_elapsed(codec->playback_substream);
+	if ((status & OPTi93X_IRQ_CAPTURE) && codec->capture_substream) {
+		snd_opti93x_overrange(codec);
+		snd_pcm_period_elapsed(codec->capture_substream);
+	}
+	outb(0x00, OPTi93X_PORT(codec, STATUS));
+	return IRQ_HANDLED;
+}
+
+
+static snd_pcm_hardware_t snd_opti93x_playback = {
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START),
+	.formats =		(SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW | SNDRV_PCM_FMTBIT_IMA_ADPCM |
+				 SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE),
+	.rates =		SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		5512,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+static snd_pcm_hardware_t snd_opti93x_capture = {
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START),
+	.formats =		(SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW | SNDRV_PCM_FMTBIT_IMA_ADPCM |
+				 SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE),
+	.rates =		SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		5512,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+static int snd_opti93x_playback_open(snd_pcm_substream_t *substream)
+{
+	int error;
+	opti93x_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	if ((error = snd_opti93x_open(chip, OPTi93X_MODE_PLAY)) < 0)
+		return error;
+	snd_pcm_set_sync(substream);
+	chip->playback_substream = substream;
+	runtime->hw = snd_opti93x_playback;
+	snd_pcm_limit_isa_dma_size(chip->dma1, &runtime->hw.buffer_bytes_max);
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);
+	return error;
+}
+
+static int snd_opti93x_capture_open(snd_pcm_substream_t *substream)
+{
+	int error;
+	opti93x_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	if ((error = snd_opti93x_open(chip, OPTi93X_MODE_CAPTURE)) < 0)
+		return error;
+	runtime->hw = snd_opti93x_capture;
+	snd_pcm_set_sync(substream);
+	chip->capture_substream = substream;
+	snd_pcm_limit_isa_dma_size(chip->dma2, &runtime->hw.buffer_bytes_max);
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);
+	return error;
+}
+
+static int snd_opti93x_playback_close(snd_pcm_substream_t *substream)
+{
+	opti93x_t *chip = snd_pcm_substream_chip(substream);
+
+	chip->playback_substream = NULL;
+	snd_opti93x_close(chip, OPTi93X_MODE_PLAY);
+	return 0;
+}
+
+static int snd_opti93x_capture_close(snd_pcm_substream_t *substream)
+{
+	opti93x_t *chip = snd_pcm_substream_chip(substream);
+
+	chip->capture_substream = NULL;
+	snd_opti93x_close(chip, OPTi93X_MODE_CAPTURE);
+	return 0;
+}
+
+
+static void snd_opti93x_init(opti93x_t *chip)
+{
+	unsigned long flags;
+	int i;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	snd_opti93x_mce_up(chip);
+
+	for (i = 0; i < 32; i++)
+		snd_opti93x_out_image(chip, i, snd_opti93x_default_image[i]);
+
+	snd_opti93x_mce_down(chip);
+	spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+static int snd_opti93x_probe(opti93x_t *chip)
+{
+	unsigned long flags;
+	unsigned char val;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	val = snd_opti93x_in(chip, OPTi93X_ID) & 0x0f;
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+	return (val == 0x0a) ? 0 : -ENODEV;
+}
+
+static int snd_opti93x_free(opti93x_t *chip)
+{
+	if (chip->res_port) {
+		release_resource(chip->res_port);
+		kfree_nocheck(chip->res_port);
+	}
+	if (chip->dma1 >= 0) {
+		disable_dma(chip->dma1);
+		free_dma(chip->dma1);
+	}
+	if (chip->dma2 >= 0) {
+		disable_dma(chip->dma2);
+		free_dma(chip->dma2);
+	}
+	if (chip->irq >= 0) {
+	  free_irq(chip->irq, chip);
+	}
+	kfree(chip);
+	return 0;
+}
+
+static int snd_opti93x_dev_free(snd_device_t *device)
+{
+	opti93x_t *chip = device->device_data;
+	return snd_opti93x_free(chip);
+}
+
+static const char *snd_opti93x_chip_id(opti93x_t *codec)
+{
+	switch (codec->hardware) {
+	case OPTi9XX_HW_82C930: return "82C930";
+	case OPTi9XX_HW_82C931: return "82C931";
+	case OPTi9XX_HW_82C933: return "82C933";
+	default:		return "???";
+	}
+}
+
+static int snd_opti93x_create(snd_card_t *card, opti9xx_t *chip,
+			      int dma1, int dma2,
+			      opti93x_t **rcodec)
+{
+	static snd_device_ops_t ops = {
+		.dev_free =	snd_opti93x_dev_free,
+	};
+	int error;
+	opti93x_t *codec;
+
+	*rcodec = NULL;
+	codec = kcalloc(1, sizeof(*codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+	codec->irq = -1;
+	codec->dma1 = -1;
+	codec->dma2 = -1;
+
+	if ((codec->res_port = request_region(chip->wss_base + 4, 4, "OPTI93x CODEC")) == NULL) {
+		snd_printk(KERN_ERR "opti9xx: can't grab port 0x%lx\n", chip->wss_base + 4);
+		snd_opti93x_free(codec);
+		return -EBUSY;
+	}
+	if (request_dma(dma1, "OPTI93x - 1")) {
+		snd_printk(KERN_ERR "opti9xx: can't grab DMA1 %d\n", dma1);
+		snd_opti93x_free(codec);
+		return -EBUSY;
+	}
+	codec->dma1 = chip->dma1;
+	if (request_dma(dma2, "OPTI93x - 2")) {
+		snd_printk(KERN_ERR "opti9xx: can't grab DMA2 %d\n", dma2);
+		snd_opti93x_free(codec);
+		return -EBUSY;
+	}
+	codec->dma2 = chip->dma2;
+
+	if (request_irq(chip->irq, snd_opti93x_interrupt, SA_INTERRUPT, DRIVER_NAME" - WSS", codec)) {
+		snd_printk(KERN_ERR "opti9xx: can't grab IRQ %d\n", chip->irq);
+		snd_opti93x_free(codec);
+		return -EBUSY;
+	}
+
+	codec->card = card;
+	codec->port = chip->wss_base + 4;
+	codec->irq = chip->irq;
+
+	spin_lock_init(&codec->lock);
+	codec->hardware = chip->hardware;
+	codec->chip = chip;
+
+	if ((error = snd_opti93x_probe(codec))) {
+		snd_opti93x_free(codec);
+		return error;
+	}
+
+	snd_opti93x_init(codec);
+
+	/* Register device */
+	if ((error = snd_device_new(card, SNDRV_DEV_LOWLEVEL, codec, &ops)) < 0) {
+		snd_opti93x_free(codec);
+		return error;
+	}
+
+	*rcodec = codec;
+	return 0;
+}
+
+static snd_pcm_ops_t snd_opti93x_playback_ops = {
+	.open =		snd_opti93x_playback_open,
+	.close =	snd_opti93x_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_opti93x_hw_params,
+	.hw_free =	snd_opti93x_hw_free,
+	.prepare =	snd_opti93x_playback_prepare,
+	.trigger =	snd_opti93x_playback_trigger,
+	.pointer =	snd_opti93x_playback_pointer,
+};
+
+static snd_pcm_ops_t snd_opti93x_capture_ops = {
+	.open =		snd_opti93x_capture_open,
+	.close =	snd_opti93x_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_opti93x_hw_params,
+	.hw_free =	snd_opti93x_hw_free,
+	.prepare =	snd_opti93x_capture_prepare,
+	.trigger =	snd_opti93x_capture_trigger,
+	.pointer =	snd_opti93x_capture_pointer,
+};
+
+static void snd_opti93x_pcm_free(snd_pcm_t *pcm)
+{
+	opti93x_t *codec = pcm->private_data;
+	codec->pcm = NULL;
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static int snd_opti93x_pcm(opti93x_t *codec, int device, snd_pcm_t **rpcm)
+{
+	int error;
+	snd_pcm_t *pcm;
+
+	if ((error = snd_pcm_new(codec->card, "OPTi 82C93X", device, 1, 1, &pcm)))
+		return error;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_opti93x_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_opti93x_capture_ops);
+
+	pcm->private_data = codec;
+	pcm->private_free = snd_opti93x_pcm_free;
+	pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
+
+	strcpy(pcm->name, snd_opti93x_chip_id(codec));
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      snd_dma_isa_data(),
+					      64*1024, codec->dma1 > 3 || codec->dma2 > 3 ? 128*1024 : 64*1024);
+
+	codec->pcm = pcm;
+	if (rpcm)
+		*rpcm = pcm;
+	return 0;
+}
+
+/*
+ *  MIXER part
+ */
+
+static int snd_opti93x_info_mux(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[4] = {
+		"Line1", "Aux", "Mic", "Mix"
+	};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 2;
+	uinfo->value.enumerated.items = 4;
+	if (uinfo->value.enumerated.item > 3)
+		uinfo->value.enumerated.item = 3;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_opti93x_get_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	opti93x_t *chip = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	
+	spin_lock_irqsave(&chip->lock, flags);
+	ucontrol->value.enumerated.item[0] = (chip->image[OPTi93X_MIXOUT_LEFT] & OPTi93X_MIXOUT_MIXER) >> 6;
+	ucontrol->value.enumerated.item[1] = (chip->image[OPTi93X_MIXOUT_RIGHT] & OPTi93X_MIXOUT_MIXER) >> 6;
+	spin_unlock_irqrestore(&chip->lock, flags);
+	return 0;
+}
+
+static int snd_opti93x_put_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	opti93x_t *chip = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	unsigned short left, right;
+	int change;
+	
+	if (ucontrol->value.enumerated.item[0] > 3 ||
+	    ucontrol->value.enumerated.item[1] > 3)
+		return -EINVAL;
+	left = ucontrol->value.enumerated.item[0] << 6;
+	right = ucontrol->value.enumerated.item[1] << 6;
+	spin_lock_irqsave(&chip->lock, flags);
+	left = (chip->image[OPTi93X_MIXOUT_LEFT] & ~OPTi93X_MIXOUT_MIXER) | left;
+	right = (chip->image[OPTi93X_MIXOUT_RIGHT] & ~OPTi93X_MIXOUT_MIXER) | right;
+	change = left != chip->image[OPTi93X_MIXOUT_LEFT] ||
+	         right != chip->image[OPTi93X_MIXOUT_RIGHT];
+	snd_opti93x_out_image(chip, OPTi93X_MIXOUT_LEFT, left);
+	snd_opti93x_out_image(chip, OPTi93X_MIXOUT_RIGHT, right);
+	spin_unlock_irqrestore(&chip->lock, flags);
+	return change;
+}
+
+#if 0
+
+#define OPTi93X_SINGLE(xname, xindex, reg, shift, mask, invert) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+  .info = snd_opti93x_info_single, \
+  .get = snd_opti93x_get_single, .put = snd_opti93x_put_single, \
+  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }
+
+static int snd_opti93x_info_single(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+
+	uinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+
+static int snd_opti93x_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	opti93x_t *chip = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0xff;
+	
+	spin_lock_irqsave(&chip->lock, flags);
+	ucontrol->value.integer.value[0] = (chip->image[reg] >> shift) & mask;
+	spin_unlock_irqrestore(&chip->lock, flags);
+	if (invert)
+		ucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static int snd_opti93x_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	opti93x_t *chip = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0xff;
+	int change;
+	unsigned short val;
+	
+	val = (ucontrol->value.integer.value[0] & mask);
+	if (invert)
+		val = mask - val;
+	val <<= shift;
+	spin_lock_irqsave(&chip->lock, flags);
+	val = (chip->image[reg] & ~(mask << shift)) | val;
+	change = val != chip->image[reg];
+	snd_opti93x_out(chip, reg, val);
+	spin_unlock_irqrestore(&chip->lock, flags);
+	return change;
+}
+
+#endif /* single */
+
+#define OPTi93X_DOUBLE(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+  .info = snd_opti93x_info_double, \
+  .get = snd_opti93x_get_double, .put = snd_opti93x_put_double, \
+  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22) }
+
+#define OPTi93X_DOUBLE_INVERT_INVERT(xctl) \
+	do { xctl.private_value ^= 22; } while (0)
+#define OPTi93X_DOUBLE_CHANGE_REGS(xctl, left_reg, right_reg) \
+	do { xctl.private_value &= ~0x0000ffff; \
+	     xctl.private_value |= left_reg | (right_reg << 8); } while (0)
+
+static int snd_opti93x_info_double(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	int mask = (kcontrol->private_value >> 24) & 0xff;
+
+	uinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+
+static int snd_opti93x_get_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	opti93x_t *chip = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int left_reg = kcontrol->private_value & 0xff;
+	int right_reg = (kcontrol->private_value >> 8) & 0xff;
+	int shift_left = (kcontrol->private_value >> 16) & 0x07;
+	int shift_right = (kcontrol->private_value >> 19) & 0x07;
+	int mask = (kcontrol->private_value >> 24) & 0xff;
+	int invert = (kcontrol->private_value >> 22) & 1;
+	
+	spin_lock_irqsave(&chip->lock, flags);
+	ucontrol->value.integer.value[0] = (chip->image[left_reg] >> shift_left) & mask;
+	ucontrol->value.integer.value[1] = (chip->image[right_reg] >> shift_right) & mask;
+	spin_unlock_irqrestore(&chip->lock, flags);
+	if (invert) {
+		ucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];
+		ucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];
+	}
+	return 0;
+}
+
+static int snd_opti93x_put_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	opti93x_t *chip = snd_kcontrol_chip(kcontrol);
+	unsigned long flags;
+	int left_reg = kcontrol->private_value & 0xff;
+	int right_reg = (kcontrol->private_value >> 8) & 0xff;
+	int shift_left = (kcontrol->private_value >> 16) & 0x07;
+	int shift_right = (kcontrol->private_value >> 19) & 0x07;
+	int mask = (kcontrol->private_value >> 24) & 0xff;
+	int invert = (kcontrol->private_value >> 22) & 1;
+	int change;
+	unsigned short val1, val2;
+	
+	val1 = ucontrol->value.integer.value[0] & mask;
+	val2 = ucontrol->value.integer.value[1] & mask;
+	if (invert) {
+		val1 = mask - val1;
+		val2 = mask - val2;
+	}
+	val1 <<= shift_left;
+	val2 <<= shift_right;
+	spin_lock_irqsave(&chip->lock, flags);
+	val1 = (chip->image[left_reg] & ~(mask << shift_left)) | val1;
+	val2 = (chip->image[right_reg] & ~(mask << shift_right)) | val2;
+	change = val1 != chip->image[left_reg] || val2 != chip->image[right_reg];
+	snd_opti93x_out_image(chip, left_reg, val1);
+	snd_opti93x_out_image(chip, right_reg, val2);
+	spin_unlock_irqrestore(&chip->lock, flags);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_opti93x_controls[] = {
+OPTi93X_DOUBLE("Master Playback Switch", 0, OPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 7, 7, 1, 1),
+OPTi93X_DOUBLE("Master Playback Volume", 0, OPTi93X_OUT_LEFT, OPTi93X_OUT_RIGHT, 1, 1, 31, 1), 
+OPTi93X_DOUBLE("PCM Playback Switch", 0, OPTi93X_DAC_LEFT, OPTi93X_DAC_RIGHT, 7, 7, 1, 1),
+OPTi93X_DOUBLE("PCM Playback Volume", 0, OPTi93X_DAC_LEFT, OPTi93X_DAC_RIGHT, 0, 0, 31, 1),
+OPTi93X_DOUBLE("FM Playback Switch", 0, OPTi931_FM_LEFT_INPUT, OPTi931_FM_RIGHT_INPUT, 7, 7, 1, 1),
+OPTi93X_DOUBLE("FM Playback Volume", 0, OPTi931_FM_LEFT_INPUT, OPTi931_FM_RIGHT_INPUT, 1, 1, 15, 1),
+OPTi93X_DOUBLE("Line Playback Switch", 0, OPTi93X_LINE_LEFT_INPUT, OPTi93X_LINE_RIGHT_INPUT, 7, 7, 1, 1),
+OPTi93X_DOUBLE("Line Playback Volume", 0, OPTi93X_LINE_LEFT_INPUT, OPTi93X_LINE_RIGHT_INPUT, 1, 1, 15, 1), 
+OPTi93X_DOUBLE("Mic Playback Switch", 0, OPTi93X_MIC_LEFT_INPUT, OPTi93X_MIC_RIGHT_INPUT, 7, 7, 1, 1),
+OPTi93X_DOUBLE("Mic Playback Volume", 0, OPTi93X_MIC_LEFT_INPUT, OPTi93X_MIC_RIGHT_INPUT, 1, 1, 15, 1), 
+OPTi93X_DOUBLE("Mic Boost", 0, OPTi93X_MIXOUT_LEFT, OPTi93X_MIXOUT_RIGHT, 5, 5, 1, 1),
+OPTi93X_DOUBLE("CD Playback Switch", 0, OPTi93X_CD_LEFT_INPUT, OPTi93X_CD_RIGHT_INPUT, 7, 7, 1, 1),
+OPTi93X_DOUBLE("CD Playback Volume", 0, OPTi93X_CD_LEFT_INPUT, OPTi93X_CD_RIGHT_INPUT, 1, 1, 15, 1),
+OPTi93X_DOUBLE("Aux Playback Switch", 0, OPTi931_AUX_LEFT_INPUT, OPTi931_AUX_RIGHT_INPUT, 7, 7, 1, 1),
+OPTi93X_DOUBLE("Aux Playback Volume", 0, OPTi931_AUX_LEFT_INPUT, OPTi931_AUX_RIGHT_INPUT, 1, 1, 15, 1), 
+OPTi93X_DOUBLE("Capture Volume", 0, OPTi93X_MIXOUT_LEFT, OPTi93X_MIXOUT_RIGHT, 0, 0, 15, 0),
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Capture Source",
+	.info = snd_opti93x_info_mux,
+	.get = snd_opti93x_get_mux,
+	.put = snd_opti93x_put_mux,
+}
+};
+                                        
+static int snd_opti93x_mixer(opti93x_t *chip)
+{
+	snd_card_t *card;
+	snd_kcontrol_new_t knew;
+	int err;
+	unsigned int idx;
+
+	snd_assert(chip != NULL && chip->card != NULL, return -EINVAL);
+
+	card = chip->card;
+
+	strcpy(card->mixername, snd_opti93x_chip_id(chip));
+
+	for (idx = 0; idx < ARRAY_SIZE(snd_opti93x_controls); idx++) {
+		knew = snd_opti93x_controls[idx];
+		if (chip->hardware == OPTi9XX_HW_82C930) {
+			if (strstr(knew.name, "FM"))	/* skip FM controls */
+				continue;
+			else if (strcmp(knew.name, "Mic Playback Volume"))
+				OPTi93X_DOUBLE_INVERT_INVERT(knew);
+			else if (strstr(knew.name, "Aux"))
+				OPTi93X_DOUBLE_CHANGE_REGS(knew, OPTi930_AUX_LEFT_INPUT, OPTi930_AUX_RIGHT_INPUT);
+			else if (strcmp(knew.name, "PCM Playback Volume"))
+				OPTi93X_DOUBLE_INVERT_INVERT(knew);
+			else if (strcmp(knew.name, "Master Playback Volume"))
+				OPTi93X_DOUBLE_INVERT_INVERT(knew);
+		}
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_opti93x_controls[idx], chip))) < 0)
+			return err;
+	}
+	return 0;
+}
+
+#endif /* OPTi93X */
+
+static int __devinit snd_card_opti9xx_detect(snd_card_t *card, opti9xx_t *chip)
+{
+	int i, err;
+
+#ifndef OPTi93X
+	for (i = OPTi9XX_HW_82C928; i < OPTi9XX_HW_82C930; i++) {
+		unsigned char value;
+
+		if ((err = snd_opti9xx_init(chip, i)) < 0)
+			return err;
+
+		if ((chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size, "OPTi9xx MC")) == NULL)
+			continue;
+
+		value = snd_opti9xx_read(chip, OPTi9XX_MC_REG(1));
+		if ((value != 0xff) && (value != inb(chip->mc_base + 1)))
+			if (value == snd_opti9xx_read(chip, OPTi9XX_MC_REG(1)))
+				return 1;
+
+		release_resource(chip->res_mc_base);
+		kfree_nocheck(chip->res_mc_base);
+		chip->res_mc_base = NULL;
+
+	}
+#else	/* OPTi93X */
+	for (i = OPTi9XX_HW_82C931; i >= OPTi9XX_HW_82C930; i--) {
+		unsigned long flags;
+		unsigned char value;
+
+		if ((err = snd_opti9xx_init(chip, i)) < 0)
+			return err;
+
+		if ((chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size, "OPTi9xx MC")) == NULL)
+			continue;
+
+		spin_lock_irqsave(&chip->lock, flags);
+		outb(chip->password, chip->mc_base + chip->pwd_reg);
+		outb(((chip->mc_indir_index & (1 << 8)) >> 4) |
+			((chip->mc_indir_index & 0xf0) >> 4), chip->mc_base);
+		spin_unlock_irqrestore(&chip->lock, flags);
+
+		value = snd_opti9xx_read(chip, OPTi9XX_MC_REG(7));
+		snd_opti9xx_write(chip, OPTi9XX_MC_REG(7), 0xff - value);
+		if (snd_opti9xx_read(chip, OPTi9XX_MC_REG(7)) == 0xff - value)
+			return 1;
+
+		release_resource(chip->res_mc_base);
+		kfree_nocheck(chip->res_mc_base);
+		chip->res_mc_base = NULL;
+	}
+#endif	/* OPTi93X */
+
+	return -ENODEV;
+}
+
+#ifdef CONFIG_PNP
+static int __devinit snd_card_opti9xx_pnp(opti9xx_t *chip, struct pnp_card_link *card,
+					  const struct pnp_card_device_id *pid)
+{
+	struct pnp_dev *pdev;
+	struct pnp_resource_table *cfg = kmalloc(sizeof(*cfg), GFP_KERNEL);
+	int err;
+
+	chip->dev = pnp_request_card_device(card, pid->devs[0].id, NULL);
+	if (chip->dev == NULL) {
+		kfree(cfg);
+		return -EBUSY;
+	}
+	chip->devmpu = pnp_request_card_device(card, pid->devs[1].id, NULL);
+
+	pdev = chip->dev;
+	pnp_init_resource_table(cfg);
+
+#ifdef OPTi93X
+	if (port != SNDRV_AUTO_PORT)
+		pnp_resource_change(&cfg->port_resource[0], port + 4, 4);
+#else
+	if (pid->driver_data != 0x0924 && port != SNDRV_AUTO_PORT)
+		pnp_resource_change(&cfg->port_resource[1], port, 4);
+#endif	/* OPTi93X */
+	if (irq != SNDRV_AUTO_IRQ)
+		pnp_resource_change(&cfg->irq_resource[0], irq, 1);
+	if (dma1 != SNDRV_AUTO_DMA)
+		pnp_resource_change(&cfg->dma_resource[0], dma1, 1);
+#if defined(CS4231) || defined(OPTi93X)
+	if (dma2 != SNDRV_AUTO_DMA)
+		pnp_resource_change(&cfg->dma_resource[1], dma2, 1);
+#else
+#ifdef snd_opti9xx_fixup_dma2
+	snd_opti9xx_fixup_dma2(pdev);
+#endif
+#endif	/* CS4231 || OPTi93X */
+#ifdef OPTi93X
+	if (fm_port > 0 && fm_port != SNDRV_AUTO_PORT)
+		pnp_resource_change(&cfg->port_resource[1], fm_port, 4);
+#else
+	if (fm_port > 0 && fm_port != SNDRV_AUTO_PORT)
+		pnp_resource_change(&cfg->port_resource[2], fm_port, 4);
+#endif
+	if (pnp_manual_config_dev(pdev, cfg, 0) < 0)
+		snd_printk(KERN_ERR "AUDIO the requested resources are invalid, using auto config\n");
+	err = pnp_activate_dev(pdev);
+	if (err < 0) {
+		snd_printk(KERN_ERR "AUDIO pnp configure failure: %d\n", err);
+		kfree(cfg);
+		return err;
+	}
+
+#ifdef OPTi93X
+	port = pnp_port_start(pdev, 0) - 4;
+	fm_port = pnp_port_start(pdev, 1);
+#else
+	if (pid->driver_data != 0x0924)
+		port = pnp_port_start(pdev, 1);
+	fm_port = pnp_port_start(pdev, 2);
+#endif	/* OPTi93X */
+	irq = pnp_irq(pdev, 0);
+	dma1 = pnp_dma(pdev, 0);
+#if defined(CS4231) || defined(OPTi93X)
+	dma2 = pnp_dma(pdev, 1);
+#endif	/* CS4231 || OPTi93X */
+
+	pdev = chip->devmpu;
+	if (pdev && mpu_port > 0) {
+		pnp_init_resource_table(cfg);
+
+		if (mpu_port != SNDRV_AUTO_PORT)
+			pnp_resource_change(&cfg->port_resource[0], mpu_port, 2);
+		if (mpu_irq != SNDRV_AUTO_IRQ)
+			pnp_resource_change(&cfg->irq_resource[0], mpu_irq, 1);
+
+		if (pnp_manual_config_dev(pdev, cfg, 0) < 0)
+			snd_printk(KERN_ERR "AUDIO the requested resources are invalid, using auto config\n");
+		err = pnp_activate_dev(pdev);
+		if (err < 0) {
+			snd_printk(KERN_ERR "AUDIO pnp configure failure\n");
+			mpu_port = -1;
+			chip->devmpu = NULL;
+		} else {
+			mpu_port = pnp_port_start(pdev, 0);
+			mpu_irq = pnp_irq(pdev, 0);
+		}
+	}
+	kfree(cfg);
+	return pid->driver_data;
+}
+#endif	/* CONFIG_PNP */
+
+#if 0
+static int __devinit snd_card_opti9xx_resources(struct snd_card_opti9xx *chip,
+						snd_card_t *card)
+{
+	int error, i, pnp = 0;
+
+#ifdef CONFIG_PNP
+	pnp = chip->dev != NULL;
+#endif	/* CONFIG_PNP */
+
+#ifndef OPTi93X
+	if (chip->chip->hardware == OPTi9XX_HW_82C928)
+		mpu_port = -1;
+#endif	/* OPTi93X */
+	error = 0;
+	if (!pnp && (mpu_port == SNDRV_DEFAULT_PORT1)) {
+		for (i = 0; possible_mpu_ports[i] != -1; i++)
+			if (!snd_register_ioport(card, possible_mpu_ports[i], 2,
+					DRIVER_NAME" - MPU-401", NULL)) {
+				mpu_port = possible_mpu_ports[i];
+				break;
+			}
+		if (mpu_port == SNDRV_DEFAULT_PORT1)
+			error = -EBUSY;
+	}
+	else
+		error = (mpu_port == -1) ? -ENODEV :
+			snd_register_ioport(card, mpu_port, 2,
+			DRIVER_NAME" - MPU-401", NULL);
+	if (error)
+		chip->chip->mpu_port = -1;
+	else if (pnp && (irq == mpu_irq))
+		chip->chip->mpu_irq = mpu_irq;
+	else if (!snd_register_interrupt(card,
+			DRIVER_NAME" - MPU-401",
+			mpu_irq, SNDRV_IRQ_TYPE_ISA,
+			snd_card_opti9xx_mpu_interrupt, chip,
+			pnp ? no_alternatives : possible_mpu_irqs,
+			&chip->mpuirqptr)) {
+		chip->chip->mpu_port = mpu_port;
+		chip->chip->mpu_irq = chip->mpuirqptr->irq;
+	}
+	else
+		chip->chip->mpu_port = -1;
+
+	if (!pnp && (port == SNDRV_DEFAULT_PORT1)) {
+		for (i = 0; possible_ports[i] != -1; i++)
+			if (!snd_register_ioport(card, possible_ports[i], 8,
+					DRIVER_NAME" - WSS", NULL)) {
+				port = possible_ports[i];
+				break;
+			}
+		if (port == SNDRV_DEFAULT_PORT1)
+			return -EBUSY;
+	}
+	else if ((error = snd_register_ioport(card, port, 8,
+			DRIVER_NAME" - WSS", NULL)) < 0)
+		return error;
+	chip->chip->wss_base = port;
+	if ((error = snd_register_interrupt(card, DRIVER_NAME" - WSS",
+			irq, SNDRV_IRQ_TYPE_ISA,
+			snd_card_opti9xx_interrupt, chip,
+			pnp ? no_alternatives : possible_irqs,
+			&chip->irqptr)) < 0)
+		return error;
+	chip->chip->irq = chip->irqptr->irq;
+	if ((error = snd_register_dma_channel(card,
+#if defined(CS4231) || defined(OPTi93X)
+			DRIVER_NAME" - WSS playback",
+#else
+			DRIVER_NAME" - WSS",
+#endif	/* CS4231 || OPTi93X */
+			dma1, SNDRV_DMA_TYPE_ISA, dma1_size,
+			pnp ? no_alternatives : possible_dma1s,
+			&chip->dma1ptr)) < 0)
+		return error;
+	chip->chip->dma1 = chip->dma1ptr->dma;
+#if defined(CS4231) || defined(OPTi93X)
+	if ((error = snd_register_dma_channel(card, DRIVER_NAME" - WSS capture",
+			dma2, SNDRV_DMA_TYPE_ISA, dma2_size,
+			pnp ? no_alternatives :
+				possible_dma2s[chip->dma1ptr->dma],
+			&chip->dma2ptr)) < 0)
+		return error;
+	chip->chip->dma2 = chip->dma2ptr->dma;
+#endif	/* CS4231 || OPTi93X */
+
+	if (snd_register_ioport(card,
+			pnp ? fm_port : fm_port = 0x388, 4,
+			DRIVER_NAME" - OPL", NULL) < 0)
+		fm_port = -1;
+	chip->chip->fm_port = fm_port;
+
+	return 0;
+}
+#endif
+
+static void snd_card_opti9xx_free(snd_card_t *card)
+{
+	opti9xx_t *chip = (opti9xx_t *)card->private_data;
+        
+	if (chip) {
+		if (chip->res_mc_base) {
+			release_resource(chip->res_mc_base);
+			kfree_nocheck(chip->res_mc_base);
+		}
+	}
+}
+
+static int __devinit snd_card_opti9xx_probe(struct pnp_card_link *pcard,
+					    const struct pnp_card_device_id *pid)
+{
+	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
+	static long possible_mpu_ports[] = {0x300, 0x310, 0x320, 0x330, -1};
+#ifdef OPTi93X
+	static int possible_irqs[] = {5, 9, 10, 11, 7, -1};
+#else
+	static int possible_irqs[] = {9, 10, 11, 7, -1};
+#endif	/* OPTi93X */
+	static int possible_mpu_irqs[] = {5, 9, 10, 7, -1};
+	static int possible_dma1s[] = {3, 1, 0, -1};
+#if defined(CS4231) || defined(OPTi93X)
+	static int possible_dma2s[][2] = {{1,-1}, {0,-1}, {-1,-1}, {0,-1}};
+#endif	/* CS4231 || OPTi93X */
+	int error;
+	opti9xx_t *chip;
+#if defined(OPTi93X)
+	opti93x_t *codec;
+#elif defined(CS4231)
+	cs4231_t *codec;
+	snd_timer_t *timer;
+#else
+	ad1848_t *codec;
+#endif
+	snd_card_t *card;
+	snd_pcm_t *pcm;
+	snd_rawmidi_t *rmidi;
+	snd_hwdep_t *synth;
+#ifdef CONFIG_PNP
+	int hw;
+#endif	/* CONFIG_PNP */
+
+	if (pcard && !snd_opti9xx_first_hit)
+		return -EBUSY;
+	if (!(card = snd_card_new(index, id, THIS_MODULE,
+				  sizeof(opti9xx_t))))
+		return -ENOMEM;
+	card->private_free = snd_card_opti9xx_free;
+	chip = (opti9xx_t *)card->private_data;
+
+#ifdef CONFIG_PNP
+	if (isapnp && pcard && (hw = snd_card_opti9xx_pnp(chip, pcard, pid)) > 0) {
+		switch (hw) {
+		case 0x0924:
+			hw = OPTi9XX_HW_82C924;
+			break;
+		case 0x0925:
+			hw = OPTi9XX_HW_82C925;
+			break;
+		case 0x0931:
+			hw = OPTi9XX_HW_82C931;
+			break;
+		default:
+			snd_card_free(card);
+			return -ENODEV;
+		}
+
+		if ((error = snd_opti9xx_init(chip, hw))) {
+			snd_card_free(card);
+			return error;
+		}
+		if (hw <= OPTi9XX_HW_82C930)
+			chip->mc_base -= 0x80;
+		snd_card_set_dev(card, &pcard->card->dev);
+	} else {
+#endif	/* CONFIG_PNP */
+		if ((error = snd_card_opti9xx_detect(card, chip)) < 0) {
+			snd_card_free(card);
+			return error;
+		}
+#ifdef CONFIG_PNP
+	}
+#endif	/* CONFIG_PNP */
+
+	if (! chip->res_mc_base &&
+	    (chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size, "OPTi9xx MC")) == NULL) {
+		snd_card_free(card);
+		return -ENOMEM;
+	}
+
+	chip->wss_base = port;
+	chip->fm_port = fm_port;
+	chip->mpu_port = mpu_port;
+	chip->irq = irq;
+	chip->mpu_irq = mpu_irq;
+	chip->dma1 = dma1;
+#if defined(CS4231) || defined(OPTi93X)
+	chip->dma2 = dma2;
+#endif
+
+	if (chip->wss_base == SNDRV_AUTO_PORT) {
+		if ((chip->wss_base = snd_legacy_find_free_ioport(possible_ports, 4)) < 0) {
+			snd_card_free(card);
+			snd_printk("unable to find a free WSS port\n");
+			return -EBUSY;
+		}
+	}
+#ifdef CONFIG_PNP
+	if (!isapnp) {
+#endif
+	if (chip->mpu_port == SNDRV_AUTO_PORT) {
+		if ((chip->mpu_port = snd_legacy_find_free_ioport(possible_mpu_ports, 2)) < 0) {
+			snd_card_free(card);
+			snd_printk("unable to find a free MPU401 port\n");
+			return -EBUSY;
+		}
+	}
+	if (chip->irq == SNDRV_AUTO_IRQ) {
+		if ((chip->irq = snd_legacy_find_free_irq(possible_irqs)) < 0) {
+			snd_card_free(card);
+			snd_printk("unable to find a free IRQ\n");
+			return -EBUSY;
+		}
+	}
+	if (chip->mpu_irq == SNDRV_AUTO_IRQ) {
+		if ((chip->mpu_irq = snd_legacy_find_free_irq(possible_mpu_irqs)) < 0) {
+			snd_card_free(card);
+			snd_printk("unable to find a free MPU401 IRQ\n");
+			return -EBUSY;
+		}
+	}
+	if (chip->dma1 == SNDRV_AUTO_DMA) {
+                if ((chip->dma1 = snd_legacy_find_free_dma(possible_dma1s)) < 0) {
+                        snd_card_free(card);
+			snd_printk("unable to find a free DMA1\n");
+			return -EBUSY;
+		}
+        }
+#if defined(CS4231) || defined(OPTi93X)
+	if (chip->dma2 == SNDRV_AUTO_DMA) {
+                if ((chip->dma2 = snd_legacy_find_free_dma(possible_dma2s[chip->dma1 % 4])) < 0) {
+                        snd_card_free(card);
+			snd_printk("unable to find a free DMA2\n");
+			return -EBUSY;
+		}
+        }
+#endif
+
+#ifdef CONFIG_PNP
+	}
+#endif
+
+	if ((error = snd_opti9xx_configure(chip))) {
+		snd_card_free(card);
+		return error;
+	}
+
+#if defined(OPTi93X)
+	if ((error = snd_opti93x_create(card, chip, chip->dma1, chip->dma2, &codec))) {
+		snd_card_free(card);
+		return error;
+	}
+	if ((error = snd_opti93x_pcm(codec, 0, &pcm)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+	if ((error = snd_opti93x_mixer(codec)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+#elif defined(CS4231)
+	if ((error = snd_cs4231_create(card, chip->wss_base + 4, -1,
+				       chip->irq, chip->dma1, chip->dma2,
+				       CS4231_HW_DETECT,
+				       0,
+				       &codec)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+	if ((error = snd_cs4231_pcm(codec, 0, &pcm)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+	if ((error = snd_cs4231_mixer(codec)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+	if ((error = snd_cs4231_timer(codec, 0, &timer)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+#else
+	if ((error = snd_ad1848_create(card, chip->wss_base + 4,
+				       chip->irq, chip->dma1,
+				       AD1848_HW_DETECT, &codec)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+	if ((error = snd_ad1848_pcm(codec, 0, &pcm)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+	if ((error = snd_ad1848_mixer(codec)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+#endif
+	strcpy(card->driver, chip->name);
+	sprintf(card->shortname, "OPTi %s", card->driver);
+#if defined(CS4231) || defined(OPTi93X)
+	sprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d&%d",
+		card->shortname, pcm->name, chip->wss_base + 4,
+		chip->irq, chip->dma1, chip->dma2);
+#else
+	sprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d",
+		card->shortname, pcm->name, chip->wss_base + 4,
+		chip->irq, chip->dma1);
+#endif	/* CS4231 || OPTi93X */
+
+	if (chip->mpu_port <= 0 || chip->mpu_port == SNDRV_AUTO_PORT)
+		rmidi = NULL;
+	else
+		if ((error = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
+				chip->mpu_port, 0, chip->mpu_irq, SA_INTERRUPT,
+				&rmidi)))
+			snd_printk("no MPU-401 device at 0x%lx?\n", chip->mpu_port);
+
+	if (chip->fm_port > 0 && chip->fm_port != SNDRV_AUTO_PORT) {
+		opl3_t *opl3 = NULL;
+#ifndef OPTi93X
+		if (chip->hardware == OPTi9XX_HW_82C928 ||
+		    chip->hardware == OPTi9XX_HW_82C929 ||
+		    chip->hardware == OPTi9XX_HW_82C924) {
+			opl4_t *opl4;
+			/* assume we have an OPL4 */
+			snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2),
+					       0x20, 0x20);
+			if (snd_opl4_create(card,
+					    chip->fm_port,
+					    chip->fm_port - 8,
+					    2, &opl3, &opl4) < 0) {
+				/* no luck, use OPL3 instead */
+				snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(2),
+						       0x00, 0x20);
+			}
+		}
+#endif	/* !OPTi93X */
+		if (!opl3 && snd_opl3_create(card,
+					     chip->fm_port,
+					     chip->fm_port + 2,
+					     OPL3_HW_AUTO, 0, &opl3) < 0) {
+			snd_printk("no OPL device at 0x%lx-0x%lx\n",
+				   chip->fm_port, chip->fm_port + 4 - 1);
+		}
+		if (opl3) {
+			if ((error = snd_opl3_timer_new(opl3,
+#ifdef CS4231
+							1, 2)) < 0) {
+#else
+							0, 1)) < 0) {
+#endif	/* CS4231 */
+				snd_card_free(card);
+				return error;
+			}
+			if ((error = snd_opl3_hwdep_new(opl3, 0, 1, &synth)) < 0) {
+				snd_card_free(card);
+				return error;
+			}
+		}
+	}
+
+	if ((error = snd_card_register(card))) {
+		snd_card_free(card);
+		return error;
+	}
+	snd_opti9xx_first_hit = 0;
+	if (pcard)
+		pnp_set_card_drvdata(pcard, card);
+	else
+		snd_opti9xx_legacy = card;
+	return 0;
+}
+
+#ifdef CONFIG_PNP
+static void __devexit snd_opti9xx_pnp_remove(struct pnp_card_link * pcard)
+{
+	snd_card_t *card = (snd_card_t *) pnp_get_card_drvdata(pcard);
+
+	snd_card_disconnect(card);
+	snd_card_free_in_thread(card);
+	snd_opti9xx_first_hit = 0;
+}
+
+static struct pnp_card_driver opti9xx_pnpc_driver = {
+	.flags		= PNP_DRIVER_RES_DISABLE,
+	.name		= "opti9xx",
+	.id_table	= snd_opti9xx_pnpids,
+	.probe		= snd_card_opti9xx_probe,
+	.remove		= __devexit_p(snd_opti9xx_pnp_remove),
+};
+#endif
+
+static int __init alsa_card_opti9xx_init(void)
+{
+	int cards, error;
+
+#ifdef CONFIG_PNP
+	cards = pnp_register_card_driver(&opti9xx_pnpc_driver);
+#else
+	cards = 0;
+#endif
+	if (cards == 0 && (error = snd_card_opti9xx_probe(NULL, NULL)) < 0) {
+#ifdef CONFIG_PNP
+		pnp_unregister_card_driver(&opti9xx_pnpc_driver);
+#endif
+#ifdef MODULE
+#ifdef OPTi93X
+		printk(KERN_ERR "no OPTi 82C93x soundcard found\n");
+#else
+		printk(KERN_ERR "no OPTi 82C92x soundcard found\n");
+#endif	/* OPTi93X */
+#endif
+		return error;
+	}
+	return 0;
+}
+
+static void __exit alsa_card_opti9xx_exit(void)
+{
+#ifdef CONFIG_PNP
+	pnp_unregister_card_driver(&opti9xx_pnpc_driver);
+#endif
+	if (snd_opti9xx_legacy)
+		snd_card_free(snd_opti9xx_legacy);
+}
+
+module_init(alsa_card_opti9xx_init)
+module_exit(alsa_card_opti9xx_exit)
