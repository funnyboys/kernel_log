commit 5ce00760a84848d008554c693ceb6286f4d9c509
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Apr 29 21:02:03 2020 +0200

    ALSA: opti9xx: shut up gcc-10 range warning
    
    gcc-10 points out a few instances of suspicious integer arithmetic
    leading to value truncation:
    
    sound/isa/opti9xx/opti92x-ad1848.c: In function 'snd_opti9xx_configure':
    sound/isa/opti9xx/opti92x-ad1848.c:322:43: error: overflow in conversion from 'int' to 'unsigned char' changes value from '(int)snd_opti9xx_read(chip, 3) & -256 | 240' to '240' [-Werror=overflow]
      322 |   (snd_opti9xx_read(chip, reg) & ~(mask)) | ((value) & (mask)))
          |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
    sound/isa/opti9xx/opti92x-ad1848.c:351:3: note: in expansion of macro 'snd_opti9xx_write_mask'
      351 |   snd_opti9xx_write_mask(chip, OPTi9XX_MC_REG(3), 0xf0, 0xff);
          |   ^~~~~~~~~~~~~~~~~~~~~~
    sound/isa/opti9xx/miro.c: In function 'snd_miro_configure':
    sound/isa/opti9xx/miro.c:873:40: error: overflow in conversion from 'int' to 'unsigned char' changes value from '(int)snd_miro_read(chip, 3) & -256 | 240' to '240' [-Werror=overflow]
      873 |   (snd_miro_read(chip, reg) & ~(mask)) | ((value) & (mask)))
          |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
    sound/isa/opti9xx/miro.c:1010:3: note: in expansion of macro 'snd_miro_write_mask'
     1010 |   snd_miro_write_mask(chip, OPTi9XX_MC_REG(3), 0xf0, 0xff);
          |   ^~~~~~~~~~~~~~~~~~~
    
    These are all harmless here as only the low 8 bit are passed down
    anyway. Change the macros to inline functions to make the code
    more readable and also avoid the warning.
    
    Strictly speaking those functions also need locking to make the
    read/write pair atomic, but it seems unlikely that anyone would
    still run into that issue.
    
    Fixes: 1841f613fd2e ("[ALSA] Add snd-miro driver")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lore.kernel.org/r/20200429190216.85919-1-arnd@arndb.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index e764816a8f7a..b039429e6871 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -867,10 +867,13 @@ static void snd_miro_write(struct snd_miro *chip, unsigned char reg,
 	spin_unlock_irqrestore(&chip->lock, flags);
 }
 
+static inline void snd_miro_write_mask(struct snd_miro *chip,
+		unsigned char reg, unsigned char value, unsigned char mask)
+{
+	unsigned char oldval = snd_miro_read(chip, reg);
 
-#define snd_miro_write_mask(chip, reg, value, mask)	\
-	snd_miro_write(chip, reg,			\
-		(snd_miro_read(chip, reg) & ~(mask)) | ((value) & (mask)))
+	snd_miro_write(chip, reg, (oldval & ~mask) | (value & mask));
+}
 
 /*
  *  Proc Interface

commit 80e0a7c095462e24f48908e6effd7a44099249f9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:48:05 2020 +0100

    ALSA: opti9xx: More constifications
    
    Apply const prefix to the static resource tables, the mc size tables
    and the string arrays.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-51-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index a9c773b9f471..e764816a8f7a 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -119,7 +119,7 @@ struct snd_miro {
 
 static struct snd_miro_aci aci_device;
 
-static char * snd_opti9xx_names[] = {
+static const char * const snd_opti9xx_names[] = {
 	"unknown",
 	"82C928", "82C929",
 	"82C924", "82C925",
@@ -637,7 +637,7 @@ static const struct snd_kcontrol_new snd_miro_capture_control[] = {
 	.put = snd_miro_put_capture,
 }};
 
-static unsigned char aci_init_values[][2] = {
+static const unsigned char aci_init_values[][2] = {
 	{ ACI_SET_MUTE, 0x00 },
 	{ ACI_SET_POWERAMP, 0x00 },
 	{ ACI_SET_PREAMP, 0x00 },
@@ -764,7 +764,7 @@ static int snd_miro_mixer(struct snd_card *card,
 static int snd_miro_init(struct snd_miro *chip,
 			 unsigned short hardware)
 {
-	static int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};
+	static const int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};
 
 	chip->hardware = hardware;
 	strcpy(chip->name, snd_opti9xx_names[hardware]);
@@ -1387,12 +1387,12 @@ static int snd_miro_isa_match(struct device *devptr, unsigned int n)
 
 static int snd_miro_isa_probe(struct device *devptr, unsigned int n)
 {
-	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
-	static long possible_mpu_ports[] = {0x330, 0x300, 0x310, 0x320, -1};
-	static int possible_irqs[] = {11, 9, 10, 7, -1};
-	static int possible_mpu_irqs[] = {10, 5, 9, 7, -1};
-	static int possible_dma1s[] = {3, 1, 0, -1};
-	static int possible_dma2s[][2] = { {1, -1}, {0, -1}, {-1, -1},
+	static const long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
+	static const long possible_mpu_ports[] = {0x330, 0x300, 0x310, 0x320, -1};
+	static const int possible_irqs[] = {11, 9, 10, 7, -1};
+	static const int possible_mpu_irqs[] = {10, 5, 9, 7, -1};
+	static const int possible_dma1s[] = {3, 1, 0, -1};
+	static const int possible_dma2s[][2] = { {1, -1}, {0, -1}, {-1, -1},
 					   {0, -1} };
 
 	int error;

commit fdd1f6fd328ff2e3723fe2a5c94378ef6f217edc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:51 2020 +0100

    ALSA: isa: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-36-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 0458934de1c7..a9c773b9f471 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -577,7 +577,7 @@ static int snd_miro_put_double(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_miro_controls[] = {
+static const struct snd_kcontrol_new snd_miro_controls[] = {
 MIRO_DOUBLE("Master Playback Volume", 0, ACI_GET_MASTER, ACI_SET_MASTER),
 MIRO_DOUBLE("Mic Playback Volume", 1, ACI_GET_MIC, ACI_SET_MIC),
 MIRO_DOUBLE("Line Playback Volume", 1, ACI_GET_LINE, ACI_SET_LINE),
@@ -589,7 +589,7 @@ MIRO_DOUBLE("Aux Playback Volume", 2, ACI_GET_LINE2, ACI_SET_LINE2),
 
 /* Equalizer with seven bands (only PCM20) 
    from -12dB up to +12dB on each band */
-static struct snd_kcontrol_new snd_miro_eq_controls[] = {
+static const struct snd_kcontrol_new snd_miro_eq_controls[] = {
 MIRO_DOUBLE("Tone Control - 28 Hz", 0, ACI_GET_EQ1, ACI_SET_EQ1),
 MIRO_DOUBLE("Tone Control - 160 Hz", 0, ACI_GET_EQ2, ACI_SET_EQ2),
 MIRO_DOUBLE("Tone Control - 400 Hz", 0, ACI_GET_EQ3, ACI_SET_EQ3),
@@ -599,15 +599,15 @@ MIRO_DOUBLE("Tone Control - 6.3 kHz", 0, ACI_GET_EQ6, ACI_SET_EQ6),
 MIRO_DOUBLE("Tone Control - 16 kHz", 0, ACI_GET_EQ7, ACI_SET_EQ7),
 };
 
-static struct snd_kcontrol_new snd_miro_radio_control[] = {
+static const struct snd_kcontrol_new snd_miro_radio_control[] = {
 MIRO_DOUBLE("Radio Playback Volume", 0, ACI_GET_LINE1, ACI_SET_LINE1),
 };
 
-static struct snd_kcontrol_new snd_miro_line_control[] = {
+static const struct snd_kcontrol_new snd_miro_line_control[] = {
 MIRO_DOUBLE("Line Playback Volume", 2, ACI_GET_LINE1, ACI_SET_LINE1),
 };
 
-static struct snd_kcontrol_new snd_miro_preamp_control[] = {
+static const struct snd_kcontrol_new snd_miro_preamp_control[] = {
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Mic Boost",
@@ -617,7 +617,7 @@ static struct snd_kcontrol_new snd_miro_preamp_control[] = {
 	.put = snd_miro_put_preamp,
 }};
 
-static struct snd_kcontrol_new snd_miro_amp_control[] = {
+static const struct snd_kcontrol_new snd_miro_amp_control[] = {
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Line Boost",
@@ -627,7 +627,7 @@ static struct snd_kcontrol_new snd_miro_amp_control[] = {
 	.put = snd_miro_put_amp,
 }};
 
-static struct snd_kcontrol_new snd_miro_capture_control[] = {
+static const struct snd_kcontrol_new snd_miro_capture_control[] = {
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "PCM Capture Switch",

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 997cdfd7b1ea..0458934de1c7 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *   ALSA soundcard driver for Miro miroSOUND PCM1 pro
  *                                  miroSOUND PCM12
@@ -6,20 +7,6 @@
  *   Copyright (C) 2004-2005 Martin Langer <martin-langer@gmx.de>
  *
  *   Based on OSS ACI and ALSA OPTi9xx drivers
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include <linux/init.h>

commit 1bac5e1c814220e1a199ceffb34b427930283d84
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:00:13 2019 +0100

    ALSA: isa: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index c6136c6b0214..997cdfd7b1ea 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -997,10 +997,7 @@ static void snd_miro_proc_read(struct snd_info_entry * entry,
 static void snd_miro_proc_init(struct snd_card *card,
 			       struct snd_miro *miro)
 {
-	struct snd_info_entry *entry;
-
-	if (!snd_card_proc_new(card, "miro", &entry))
-		snd_info_set_text_ops(entry, miro, snd_miro_proc_read);
+	snd_card_ro_proc_new(card, "miro", miro, snd_miro_proc_read);
 }
 
 /*

commit 734be97b967c7e2bab72b34da87534ccd854c72d
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Aug 2 15:41:55 2018 -0500

    ALSA: opti9xx: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Addresses-Coverity-ID: 402016 ("Missing break in switch")
    Addresses-Coverity-ID: 1056542 ("Missing break in switch")
    Addresses-Coverity-ID: 1339579 ("Missing break in switch")
    Addresses-Coverity-ID: 1369526 ("Missing break in switch")
    Addresses-Coverity-ID: 1369529 ("Missing break in switch")
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 8894c7c18ad6..c6136c6b0214 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -176,10 +176,13 @@ static int aci_busy_wait(struct snd_miro_aci *aci)
 			switch (timeout-ACI_MINTIME) {
 			case 0 ... 9:
 				out /= 10;
+				/* fall through */
 			case 10 ... 19:
 				out /= 10;
+				/* fall through */
 			case 20 ... 30:
 				out /= 10;
+				/* fall through */
 			default:
 				set_current_state(TASK_UNINTERRUPTIBLE);
 				schedule_timeout(out);
@@ -834,6 +837,7 @@ static unsigned char snd_miro_read(struct snd_miro *chip,
 			retval = inb(chip->mc_base + 9);
 			break;
 		}
+		/* fall through */
 
 	case OPTi9XX_HW_82C929:
 		retval = inb(chip->mc_base + reg);
@@ -863,6 +867,7 @@ static void snd_miro_write(struct snd_miro *chip, unsigned char reg,
 			outb(value, chip->mc_base + 9);
 			break;
 		}
+		/* fall through */
 
 	case OPTi9XX_HW_82C929:
 		outb(value, chip->mc_base + reg);

commit 529d25761173cba9e5cd8e1629c6477a141fce6d
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Thu Aug 17 15:36:27 2017 +0530

    ALSA: opti9xx: constify pnp_card_device_id
    
    pnp_card_device_id are not supposed to change at runtime. All functions
    working with pnp_card_device_id provided by <linux/pnp.h> work with
    const pnp_card_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 1c5a12fa8be3..8894c7c18ad6 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -143,7 +143,7 @@ static int snd_miro_pnp_is_probed;
 
 #ifdef CONFIG_PNP
 
-static struct pnp_card_device_id snd_miro_pnpids[] = {
+static const struct pnp_card_device_id snd_miro_pnpids[] = {
 	/* PCM20 and PCM12 in PnP mode */
 	{ .id = "MIR0924",
 	  .devs = { { "MIR0000" }, { "MIR0002" }, { "MIR0005" } }, },

commit 24d220773139ae03fc7bda692c5f6335ea457059
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jul 18 13:48:07 2017 +0200

    ALSA: opti9xx: fix format string overflow warning
    
    We pass a long name from "codec->pcm->name" into the longname
    string of the same length:
    
    sound/isa/opti9xx/miro.c: In function 'snd_miro_probe':
    sound/isa/opti9xx/miro.c:1356:39: error: '%s' directive writing up to 79 bytes into a region of size between 35 and 72 [-Werror=format-overflow=]
      sprintf(card->longname, "%s: OPTi%s, %s at 0x%lx, irq %d, dma %d&%d",
                                           ^~
    sound/isa/opti9xx/miro.c:1356:26: note: using the range [0, 4294967295] for directive argument
      sprintf(card->longname, "%s: OPTi%s, %s at 0x%lx, irq %d, dma %d&%d",
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    sound/isa/opti9xx/miro.c:1356:2: note: 'sprintf' output between 32 and 185 bytes into a destination of size 80
      sprintf(card->longname, "%s: OPTi%s, %s at 0x%lx, irq %d, dma %d&%d",
    
    There is no easy way to avoid the theoretical overflow in this case,
    but using snprintf() will turn it into a harmless truncation.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index bcbff56f060d..1c5a12fa8be3 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1353,9 +1353,10 @@ static int snd_miro_probe(struct snd_card *card)
 	}
 
 	strcpy(card->driver, "miro");
-	sprintf(card->longname, "%s: OPTi%s, %s at 0x%lx, irq %d, dma %d&%d",
-		card->shortname, miro->name, codec->pcm->name,
-		miro->wss_base + 4, miro->irq, miro->dma1, miro->dma2);
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s: OPTi%s, %s at 0x%lx, irq %d, dma %d&%d",
+		 card->shortname, miro->name, codec->pcm->name,
+		 miro->wss_base + 4, miro->irq, miro->dma1, miro->dma2);
 
 	if (mpu_port <= 0 || mpu_port == SNDRV_AUTO_PORT)
 		rmidi = NULL;

commit e992ef5705c1e154acb248869b39e0be4c003a8b
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:30 2017 +0100

    Annotate hardware config module parameters in sound/isa/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in sound/isa/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jaroslav Kysela <perex@perex.cz>
    cc: Takashi Iwai <tiwai@suse.com>
    cc: alsa-devel@alsa-project.org

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 3a9067db1a84..bcbff56f060d 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -69,19 +69,19 @@ module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for miro soundcard.");
 module_param(id, charp, 0444);
 MODULE_PARM_DESC(id, "ID string for miro soundcard.");
-module_param(port, long, 0444);
+module_param_hw(port, long, ioport, 0444);
 MODULE_PARM_DESC(port, "WSS port # for miro driver.");
-module_param(mpu_port, long, 0444);
+module_param_hw(mpu_port, long, ioport, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port # for miro driver.");
-module_param(fm_port, long, 0444);
+module_param_hw(fm_port, long, ioport, 0444);
 MODULE_PARM_DESC(fm_port, "FM Port # for miro driver.");
-module_param(irq, int, 0444);
+module_param_hw(irq, int, irq, 0444);
 MODULE_PARM_DESC(irq, "WSS irq # for miro driver.");
-module_param(mpu_irq, int, 0444);
+module_param_hw(mpu_irq, int, irq, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU-401 irq # for miro driver.");
-module_param(dma1, int, 0444);
+module_param_hw(dma1, int, dma, 0444);
 MODULE_PARM_DESC(dma1, "1st dma # for miro driver.");
-module_param(dma2, int, 0444);
+module_param_hw(dma2, int, dma, 0444);
 MODULE_PARM_DESC(dma2, "2nd dma # for miro driver.");
 module_param(wss, int, 0444);
 MODULE_PARM_DESC(wss, "wss mode");

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 546452888aed..3a9067db1a84 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -29,7 +29,7 @@
 #include <linux/delay.h>
 #include <linux/ioport.h>
 #include <linux/module.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <asm/dma.h>
 #include <sound/core.h>
 #include <sound/wss.h>

commit fa60c065694a81e534c61809ab7dd419366e9335
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Jan 2 12:24:43 2015 +0100

    ALSA: wss: Remove (almost) always NULL parameters
    
    Most callers of snd_wss_pcm(), snd_wss_timer() and snd_cs4236_pcm() pass
    NULL as the last parameter, some callers pass a pointer but never use it
    after the function has been called and only a few callers pass a pointer and
    actually use it. The later is only the case for snd_wss_pcm() for
    snd_cs4236_pcm() and it is possible to get the same PCM object by accessing
    the pcm field of the snd_wss struct that was passed as the first parameter.
    
    This function removes the last parameters from the functions mentioned above
    and updates the callers which used it to use chip->pcm instead. This allows
    us to slightly simplify the functions since they don't have to check and set
    the last parameter anymore which makes the code slightly shorter and
    cleaner.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index c2ca681ac51b..546452888aed 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1270,8 +1270,6 @@ static int snd_miro_probe(struct snd_card *card)
 	int error;
 	struct snd_miro *miro = card->private_data;
 	struct snd_wss *codec;
-	struct snd_timer *timer;
-	struct snd_pcm *pcm;
 	struct snd_rawmidi *rmidi;
 
 	if (!miro->res_mc_base) {
@@ -1310,7 +1308,7 @@ static int snd_miro_probe(struct snd_card *card)
 	if (error < 0)
 		return error;
 
-	error = snd_wss_pcm(codec, 0, &pcm);
+	error = snd_wss_pcm(codec, 0);
 	if (error < 0)
 		return error;
 
@@ -1318,11 +1316,11 @@ static int snd_miro_probe(struct snd_card *card)
 	if (error < 0)
 		return error;
 
-	error = snd_wss_timer(codec, 0, &timer);
+	error = snd_wss_timer(codec, 0);
 	if (error < 0)
 		return error;
 
-	miro->pcm = pcm;
+	miro->pcm = codec->pcm;
 
 	error = snd_miro_mixer(card, miro);
 	if (error < 0)
@@ -1356,8 +1354,8 @@ static int snd_miro_probe(struct snd_card *card)
 
 	strcpy(card->driver, "miro");
 	sprintf(card->longname, "%s: OPTi%s, %s at 0x%lx, irq %d, dma %d&%d",
-		card->shortname, miro->name, pcm->name, miro->wss_base + 4,
-		miro->irq, miro->dma1, miro->dma2);
+		card->shortname, miro->name, codec->pcm->name,
+		miro->wss_base + 4, miro->irq, miro->dma1, miro->dma2);
 
 	if (mpu_port <= 0 || mpu_port == SNDRV_AUTO_PORT)
 		rmidi = NULL;

commit 4323cc4d5b25b5138c0791e3c7d3b09bd7062b49
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 13:03:56 2014 +0100

    ALSA: isa: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 619753d96ca5..c2ca681ac51b 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1411,8 +1411,8 @@ static int snd_miro_isa_probe(struct device *devptr, unsigned int n)
 	struct snd_miro *miro;
 	struct snd_card *card;
 
-	error = snd_card_create(index, id, THIS_MODULE,
-				sizeof(struct snd_miro), &card);
+	error = snd_card_new(devptr, index, id, THIS_MODULE,
+			     sizeof(struct snd_miro), &card);
 	if (error < 0)
 		return error;
 
@@ -1479,8 +1479,6 @@ static int snd_miro_isa_probe(struct device *devptr, unsigned int n)
 		}
 	}
 
-	snd_card_set_dev(card, devptr);
-
 	error = snd_miro_probe(card);
 	if (error < 0) {
 		snd_card_free(card);
@@ -1584,8 +1582,8 @@ static int snd_miro_pnp_probe(struct pnp_card_link *pcard,
 		return -EBUSY;
 	if (!isapnp)
 		return -ENODEV;
-	err = snd_card_create(index, id, THIS_MODULE,
-				sizeof(struct snd_miro), &card);
+	err = snd_card_new(&pcard->card->dev, index, id, THIS_MODULE,
+			   sizeof(struct snd_miro), &card);
 	if (err < 0)
 		return err;
 
@@ -1612,7 +1610,6 @@ static int snd_miro_pnp_probe(struct pnp_card_link *pcard,
 		return err;
 	}
 
-	snd_card_set_dev(card, &pcard->card->dev);
 	err = snd_miro_probe(card);
 	if (err < 0) {
 		snd_card_free(card);

commit 8b5a1f9c46c2b78716794b8762edf659ec25a87d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:49:32 2013 +0200

    ALSA: ISA: Remove superfluous *_set_drvdata(NULL) calls
    
    Similarly like the previous commit for PCI drivers, remove
    dev_set_drvdata(NULL) and pnp_set_drvdata(NULL) calls in ISA drivers
    now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index c3da1df9371d..619753d96ca5 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1495,7 +1495,6 @@ static int snd_miro_isa_remove(struct device *devptr,
 			       unsigned int dev)
 {
 	snd_card_free(dev_get_drvdata(devptr));
-	dev_set_drvdata(devptr, NULL);
 	return 0;
 }
 

commit 1bff292e9abec7477d43abb2b93c7fd26c44859b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:21 2012 -0500

    ALSA: isa: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 4a7ff4e8985b..c3da1df9371d 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -587,7 +587,7 @@ static int snd_miro_put_double(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_miro_controls[] __devinitdata = {
+static struct snd_kcontrol_new snd_miro_controls[] = {
 MIRO_DOUBLE("Master Playback Volume", 0, ACI_GET_MASTER, ACI_SET_MASTER),
 MIRO_DOUBLE("Mic Playback Volume", 1, ACI_GET_MIC, ACI_SET_MIC),
 MIRO_DOUBLE("Line Playback Volume", 1, ACI_GET_LINE, ACI_SET_LINE),
@@ -599,7 +599,7 @@ MIRO_DOUBLE("Aux Playback Volume", 2, ACI_GET_LINE2, ACI_SET_LINE2),
 
 /* Equalizer with seven bands (only PCM20) 
    from -12dB up to +12dB on each band */
-static struct snd_kcontrol_new snd_miro_eq_controls[] __devinitdata = {
+static struct snd_kcontrol_new snd_miro_eq_controls[] = {
 MIRO_DOUBLE("Tone Control - 28 Hz", 0, ACI_GET_EQ1, ACI_SET_EQ1),
 MIRO_DOUBLE("Tone Control - 160 Hz", 0, ACI_GET_EQ2, ACI_SET_EQ2),
 MIRO_DOUBLE("Tone Control - 400 Hz", 0, ACI_GET_EQ3, ACI_SET_EQ3),
@@ -609,15 +609,15 @@ MIRO_DOUBLE("Tone Control - 6.3 kHz", 0, ACI_GET_EQ6, ACI_SET_EQ6),
 MIRO_DOUBLE("Tone Control - 16 kHz", 0, ACI_GET_EQ7, ACI_SET_EQ7),
 };
 
-static struct snd_kcontrol_new snd_miro_radio_control[] __devinitdata = {
+static struct snd_kcontrol_new snd_miro_radio_control[] = {
 MIRO_DOUBLE("Radio Playback Volume", 0, ACI_GET_LINE1, ACI_SET_LINE1),
 };
 
-static struct snd_kcontrol_new snd_miro_line_control[] __devinitdata = {
+static struct snd_kcontrol_new snd_miro_line_control[] = {
 MIRO_DOUBLE("Line Playback Volume", 2, ACI_GET_LINE1, ACI_SET_LINE1),
 };
 
-static struct snd_kcontrol_new snd_miro_preamp_control[] __devinitdata = {
+static struct snd_kcontrol_new snd_miro_preamp_control[] = {
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Mic Boost",
@@ -627,7 +627,7 @@ static struct snd_kcontrol_new snd_miro_preamp_control[] __devinitdata = {
 	.put = snd_miro_put_preamp,
 }};
 
-static struct snd_kcontrol_new snd_miro_amp_control[] __devinitdata = {
+static struct snd_kcontrol_new snd_miro_amp_control[] = {
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Line Boost",
@@ -637,7 +637,7 @@ static struct snd_kcontrol_new snd_miro_amp_control[] __devinitdata = {
 	.put = snd_miro_put_amp,
 }};
 
-static struct snd_kcontrol_new snd_miro_capture_control[] __devinitdata = {
+static struct snd_kcontrol_new snd_miro_capture_control[] = {
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "PCM Capture Switch",
@@ -647,7 +647,7 @@ static struct snd_kcontrol_new snd_miro_capture_control[] __devinitdata = {
 	.put = snd_miro_put_capture,
 }};
 
-static unsigned char aci_init_values[][2] __devinitdata = {
+static unsigned char aci_init_values[][2] = {
 	{ ACI_SET_MUTE, 0x00 },
 	{ ACI_SET_POWERAMP, 0x00 },
 	{ ACI_SET_PREAMP, 0x00 },
@@ -670,7 +670,7 @@ static unsigned char aci_init_values[][2] __devinitdata = {
 	{ ACI_SET_MASTER + 1, 0x20 },
 };
 
-static int __devinit snd_set_aci_init_values(struct snd_miro *miro)
+static int snd_set_aci_init_values(struct snd_miro *miro)
 {
 	int idx, error;
 	struct snd_miro_aci *aci = miro->aci;
@@ -713,8 +713,8 @@ static int __devinit snd_set_aci_init_values(struct snd_miro *miro)
 	return 0;
 }
 
-static int __devinit snd_miro_mixer(struct snd_card *card,
-				    struct snd_miro *miro)
+static int snd_miro_mixer(struct snd_card *card,
+			  struct snd_miro *miro)
 {
 	unsigned int idx;
 	int err;
@@ -771,8 +771,8 @@ static int __devinit snd_miro_mixer(struct snd_card *card,
 	return 0;
 }
 
-static int __devinit snd_miro_init(struct snd_miro *chip,
-				   unsigned short hardware)
+static int snd_miro_init(struct snd_miro *chip,
+			 unsigned short hardware)
 {
 	static int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};
 
@@ -989,8 +989,8 @@ static void snd_miro_proc_read(struct snd_info_entry * entry,
 	snd_iprintf(buffer, "  preamp  : 0x%x\n", aci->aci_preamp);
 }
 
-static void __devinit snd_miro_proc_init(struct snd_card *card,
-					 struct snd_miro *miro)
+static void snd_miro_proc_init(struct snd_card *card,
+			       struct snd_miro *miro)
 {
 	struct snd_info_entry *entry;
 
@@ -1002,7 +1002,7 @@ static void __devinit snd_miro_proc_init(struct snd_card *card,
  *  Init
  */
 
-static int __devinit snd_miro_configure(struct snd_miro *chip)
+static int snd_miro_configure(struct snd_miro *chip)
 {
 	unsigned char wss_base_bits;
 	unsigned char irq_bits;
@@ -1162,7 +1162,7 @@ static int __devinit snd_miro_configure(struct snd_miro *chip)
 	return 0;
 }
 
-static int __devinit snd_miro_opti_check(struct snd_miro *chip)
+static int snd_miro_opti_check(struct snd_miro *chip)
 {
 	unsigned char value;
 
@@ -1182,8 +1182,8 @@ static int __devinit snd_miro_opti_check(struct snd_miro *chip)
 	return -ENODEV;
 }
 
-static int __devinit snd_card_miro_detect(struct snd_card *card,
-					  struct snd_miro *chip)
+static int snd_card_miro_detect(struct snd_card *card,
+				struct snd_miro *chip)
 {
 	int i, err;
 
@@ -1200,8 +1200,8 @@ static int __devinit snd_card_miro_detect(struct snd_card *card,
 	return -ENODEV;
 }
 
-static int __devinit snd_card_miro_aci_detect(struct snd_card *card,
-					      struct snd_miro *miro)
+static int snd_card_miro_aci_detect(struct snd_card *card,
+				    struct snd_miro *miro)
 {
 	unsigned char regval;
 	int i;
@@ -1265,7 +1265,7 @@ static void snd_card_miro_free(struct snd_card *card)
 	release_and_free_resource(miro->res_mc_base);
 }
 
-static int __devinit snd_miro_probe(struct snd_card *card)
+static int snd_miro_probe(struct snd_card *card)
 {
 	int error;
 	struct snd_miro *miro = card->private_data;
@@ -1386,7 +1386,7 @@ static int __devinit snd_miro_probe(struct snd_card *card)
 	return snd_card_register(card);
 }
 
-static int __devinit snd_miro_isa_match(struct device *devptr, unsigned int n)
+static int snd_miro_isa_match(struct device *devptr, unsigned int n)
 {
 #ifdef CONFIG_PNP
 	if (snd_miro_pnp_is_probed)
@@ -1397,7 +1397,7 @@ static int __devinit snd_miro_isa_match(struct device *devptr, unsigned int n)
 	return 1;
 }
 
-static int __devinit snd_miro_isa_probe(struct device *devptr, unsigned int n)
+static int snd_miro_isa_probe(struct device *devptr, unsigned int n)
 {
 	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
 	static long possible_mpu_ports[] = {0x330, 0x300, 0x310, 0x320, -1};
@@ -1491,8 +1491,8 @@ static int __devinit snd_miro_isa_probe(struct device *devptr, unsigned int n)
 	return 0;
 }
 
-static int __devexit snd_miro_isa_remove(struct device *devptr,
-					 unsigned int dev)
+static int snd_miro_isa_remove(struct device *devptr,
+			       unsigned int dev)
 {
 	snd_card_free(dev_get_drvdata(devptr));
 	dev_set_drvdata(devptr, NULL);
@@ -1504,7 +1504,7 @@ static int __devexit snd_miro_isa_remove(struct device *devptr,
 static struct isa_driver snd_miro_driver = {
 	.match		= snd_miro_isa_match,
 	.probe		= snd_miro_isa_probe,
-	.remove		= __devexit_p(snd_miro_isa_remove),
+	.remove		= snd_miro_isa_remove,
 	/* FIXME: suspend/resume */
 	.driver		= {
 		.name	= DEV_NAME
@@ -1513,9 +1513,9 @@ static struct isa_driver snd_miro_driver = {
 
 #ifdef CONFIG_PNP
 
-static int __devinit snd_card_miro_pnp(struct snd_miro *chip,
-					struct pnp_card_link *card,
-					const struct pnp_card_device_id *pid)
+static int snd_card_miro_pnp(struct snd_miro *chip,
+			     struct pnp_card_link *card,
+			     const struct pnp_card_device_id *pid)
 {
 	struct pnp_dev *pdev;
 	int err;
@@ -1574,8 +1574,8 @@ static int __devinit snd_card_miro_pnp(struct snd_miro *chip,
 	return 0;
 }
 
-static int __devinit snd_miro_pnp_probe(struct pnp_card_link *pcard,
-					const struct pnp_card_device_id *pid)
+static int snd_miro_pnp_probe(struct pnp_card_link *pcard,
+			      const struct pnp_card_device_id *pid)
 {
 	struct snd_card *card;
 	int err;
@@ -1624,7 +1624,7 @@ static int __devinit snd_miro_pnp_probe(struct pnp_card_link *pcard,
 	return 0;
 }
 
-static void __devexit snd_miro_pnp_remove(struct pnp_card_link * pcard)
+static void snd_miro_pnp_remove(struct pnp_card_link *pcard)
 {
 	snd_card_free(pnp_get_card_drvdata(pcard));
 	pnp_set_card_drvdata(pcard, NULL);
@@ -1636,7 +1636,7 @@ static struct pnp_card_driver miro_pnpc_driver = {
 	.name		= "miro",
 	.id_table	= snd_miro_pnpids,
 	.probe		= snd_miro_pnp_probe,
-	.remove		= __devexit_p(snd_miro_pnp_remove),
+	.remove		= snd_miro_pnp_remove,
 };
 #endif
 

commit edb66893860dbc0631afc2807efdb209a03d57a2
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Oct 21 12:52:03 2012 +0200

    ALSA: sound/isa/opti9xx/miro.c: eliminate possible double free
    
    snd_miro_probe is a static function that is only called twice in the file
    that defines it.  At each call site, its argument is freed using
    snd_card_free.  Thus, there is no need for snd_miro_probe to call
    snd_card_free on its argument on any of its error exit paths.
    
    Because snd_card_free both reads the fields of its argument and kfrees its
    argments, the results of the second snd_card_free should be unpredictable.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    identifier f,free,a;
    parameter list[n] ps;
    type T;
    expression e;
    @@
    
    f(ps,T a,...) {
      ... when any
          when != a = e
      if(...) { ... free(a); ... return ...; }
      ... when any
    }
    
    @@
    identifier r.f,r.free;
    expression x,a;
    expression list[r.n] xs;
    @@
    
    * x = f(xs,a,...);
      if (...) { ... free(a); ... return ...; }
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 3d1afb612b35..4a7ff4e8985b 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1286,7 +1286,6 @@ static int __devinit snd_miro_probe(struct snd_card *card)
 
 	error = snd_card_miro_aci_detect(card, miro);
 	if (error < 0) {
-		snd_card_free(card);
 		snd_printk(KERN_ERR "unable to detect aci chip\n");
 		return -ENODEV;
 	}

commit 988aec3de5f0fa848f26fbf64f9e83364d6b3c25
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Wed Aug 1 16:05:39 2012 +0200

    ALSA: isa: Move snd_legacy_find_free_ioport to initval.h
    
    Move snd_legacy_find_free_ioport() function back to initval.h as it is used
    by two drivers.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index c24594c866f4..3d1afb612b35 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -37,6 +37,7 @@
 #include <sound/opl4.h>
 #include <sound/control.h>
 #include <sound/info.h>
+#define SNDRV_LEGACY_FIND_FREE_IOPORT
 #define SNDRV_LEGACY_FIND_FREE_IRQ
 #define SNDRV_LEGACY_FIND_FREE_DMA
 #include <sound/initval.h>
@@ -770,20 +771,6 @@ static int __devinit snd_miro_mixer(struct snd_card *card,
 	return 0;
 }
 
-static long snd_legacy_find_free_ioport(long *port_table, long size)
-{
-	while (*port_table != -1) {
-		struct resource *res;
-		if ((res = request_region(*port_table, size, 
-					  "ALSA test")) != NULL) {
-			release_and_free_resource(res);
-			return *port_table;
-		}
-		port_table++;
-	}
-	return -1;
-}
-
 static int __devinit snd_miro_init(struct snd_miro *chip,
 				   unsigned short hardware)
 {

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 3785b7a784c9..c24594c866f4 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -61,7 +61,7 @@ static int dma2 = SNDRV_DEFAULT_DMA1;		/* 0,1,3 */
 static int wss;
 static int ide;
 #ifdef CONFIG_PNP
-static int isapnp = 1;				/* Enable ISA PnP detection */
+static bool isapnp = 1;				/* Enable ISA PnP detection */
 #endif
 
 module_param(index, int, 0444);

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index d94d0f35cb76..3785b7a784c9 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -28,7 +28,7 @@
 #include <linux/pnp.h>
 #include <linux/delay.h>
 #include <linux/ioport.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <asm/io.h>
 #include <asm/dma.h>
 #include <sound/core.h>

commit dba8b46992c55946d3b092934f581a343403118f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Sep 13 11:24:41 2011 +0200

    ALSA: mpu401: clean up interrupt specification
    
    The semantics of snd_mpu401_uart_new()'s interrupt parameters are
    somewhat counterintuitive:  To prevent the function from allocating its
    own interrupt, either the irq number must be invalid, or the irq_flags
    parameter must be zero.  At the same time, the irq parameter being
    invalid specifies that the mpu401 code has to work without an interrupt
    allocated by the caller.  This implies that, if there is an interrupt
    and it is allocated by the caller, the irq parameter must be set to
    a valid-looking number which then isn't actually used.
    
    With the removal of IRQF_DISABLED, zero becomes a valid irq_flags value,
    which forces us to handle the parameters differently.
    
    This patch introduces a new flag MPU401_INFO_IRQ_HOOK for when the
    device interrupt is handled by the caller, and makes the allocation of
    the interrupt to depend only on the irq parameter.  As suggested by
    Takashi, the irq_flags parameter was dropped because, when used, it had
    the constant value IRQF_DISABLED.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 8c24102d0d93..d94d0f35cb76 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1377,8 +1377,7 @@ static int __devinit snd_miro_probe(struct snd_card *card)
 		rmidi = NULL;
 	else {
 		error = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
-				mpu_port, 0, miro->mpu_irq, IRQF_DISABLED,
-				&rmidi);
+				mpu_port, 0, miro->mpu_irq, &rmidi);
 		if (error < 0)
 			snd_printk(KERN_WARNING "no MPU-401 device at 0x%lx?\n",
 				   mpu_port);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 5913717c1be6..8c24102d0d93 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -27,7 +27,6 @@
 #include <linux/isa.h>
 #include <linux/pnp.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
 #include <linux/ioport.h>
 #include <linux/moduleparam.h>
 #include <asm/io.h>

commit fd8d47351d2e241f3168eeb697ce55cc28c75b78
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Wed Mar 3 19:41:44 2010 +0100

    ALSA: opti92x: use PnP data to select Master Control port
    
    The Master Control port (MC) is available as the last
    PnP resource (OPT005). Use this value instead fo guessing.
    
    Also, add some comments to the code.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index b865e45a8f9b..5913717c1be6 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1558,7 +1558,7 @@ static int __devinit snd_card_miro_pnp(struct snd_miro *chip,
 
 	err = pnp_activate_dev(devmc);
 	if (err < 0) {
-		snd_printk(KERN_ERR "OPL syntg pnp configure failure: %d\n",
+		snd_printk(KERN_ERR "MC pnp configure failure: %d\n",
 				    err);
 		return err;
 	}

commit 4ef58d4e2ad1fa2a3e5bbf41af2284671fca8cf8
Merge: f6c4c8195b5e d014d043869c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 9 19:43:33 2009 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (42 commits)
      tree-wide: fix misspelling of "definition" in comments
      reiserfs: fix misspelling of "journaled"
      doc: Fix a typo in slub.txt.
      inotify: remove superfluous return code check
      hdlc: spelling fix in find_pvc() comment
      doc: fix regulator docs cut-and-pasteism
      mtd: Fix comment in Kconfig
      doc: Fix IRQ chip docs
      tree-wide: fix assorted typos all over the place
      drivers/ata/libata-sff.c: comment spelling fixes
      fix typos/grammos in Documentation/edac.txt
      sysctl: add missing comments
      fs/debugfs/inode.c: fix comment typos
      sgivwfb: Make use of ARRAY_SIZE.
      sky2: fix sky2_link_down copy/paste comment error
      tree-wide: fix typos "couter" -> "counter"
      tree-wide: fix typos "offest" -> "offset"
      fix kerneldoc for set_irq_msi()
      spidev: fix double "of of" in comment
      comment typo fix: sybsystem -> subsystem
      ...

commit af901ca181d92aac3a7dc265144a9081a86d8f39
Author: André Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:05 2009 -0200

    tree-wide: fix assorted typos all over the place
    
    That is "success", "unknown", "through", "performance", "[re|un]mapping"
    , "access", "default", "reasonable", "[con]currently", "temperature"
    , "channel", "[un]used", "application", "example","hierarchy", "therefore"
    , "[over|under]flow", "contiguous", "threshold", "enough" and others.
    
    Signed-off-by: André Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 02e30d7c6a93..ddad60ef3f37 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -137,7 +137,7 @@ struct snd_miro {
 static void snd_miro_proc_init(struct snd_miro * miro);
 
 static char * snd_opti9xx_names[] = {
-	"unkown",
+	"unknown",
 	"82C928", "82C929",
 	"82C924", "82C925",
 	"82C930", "82C931", "82C933"

commit 306ecee926cf79f1b3b5f6035be09ef3d83f1b76
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Mon Nov 30 07:46:56 2009 +0100

    ALSA: opti-miro: add PnP detection
    
    The PCM12 and PCM20 can be set into the ISA PnP mode. The PCM12 PnP
    was sold as the PnP device.
    Add code to handle detection of these cards using ISA PnP framework.
    
    Tested on the PCM20 in PnP mode. The PCM12 PnP has the same MS Windows
    INF file except for a card name displayed for user.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index c67bc3cd2c65..6123c7531110 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -25,6 +25,7 @@
 #include <linux/init.h>
 #include <linux/err.h>
 #include <linux/isa.h>
+#include <linux/pnp.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/ioport.h>
@@ -60,6 +61,9 @@ static int dma1 = SNDRV_DEFAULT_DMA1;		/* 0,1,3 */
 static int dma2 = SNDRV_DEFAULT_DMA1;		/* 0,1,3 */
 static int wss;
 static int ide;
+#ifdef CONFIG_PNP
+static int isapnp = 1;				/* Enable ISA PnP detection */
+#endif
 
 module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for miro soundcard.");
@@ -83,6 +87,10 @@ module_param(wss, int, 0444);
 MODULE_PARM_DESC(wss, "wss mode");
 module_param(ide, int, 0444);
 MODULE_PARM_DESC(ide, "enable ide port");
+#ifdef CONFIG_PNP
+module_param(isapnp, bool, 0444);
+MODULE_PARM_DESC(isapnp, "Enable ISA PnP detection for specified soundcard.");
+#endif
 
 #define OPTi9XX_HW_DETECT	0
 #define OPTi9XX_HW_82C928	1
@@ -131,6 +139,21 @@ static char * snd_opti9xx_names[] = {
 	"82C930", "82C931", "82C933"
 };
 
+static int snd_miro_pnp_is_probed;
+
+#ifdef CONFIG_PNP
+
+static struct pnp_card_device_id snd_miro_pnpids[] = {
+	/* PCM20 and PCM12 in PnP mode */
+	{ .id = "MIR0924",
+	  .devs = { { "MIR0000" }, { "MIR0002" }, { "MIR0005" } }, },
+	{ .id = "" }
+};
+
+MODULE_DEVICE_TABLE(pnp_card, snd_miro_pnpids);
+
+#endif	/* CONFIG_PNP */
+
 /* 
  *  ACI control
  */
@@ -781,17 +804,23 @@ static int __devinit snd_miro_init(struct snd_miro *chip,
 	chip->mpu_port = -1;
 	chip->mpu_irq = -1;
 
+	chip->pwd_reg = 3;
+
+#ifdef CONFIG_PNP
+	if (isapnp && chip->mc_base)
+		/* PnP resource gives the least 10 bits */
+		chip->mc_base |= 0xc00;
+	else
+#endif
+		chip->mc_base = 0xf8c;
+
 	switch (hardware) {
 	case OPTi9XX_HW_82C929:
-		chip->mc_base = 0xf8c;
 		chip->password = 0xe3;
-		chip->pwd_reg = 3;
 		break;
 
 	case OPTi9XX_HW_82C924:
-		chip->mc_base = 0xf8c;
 		chip->password = 0xe5;
-		chip->pwd_reg = 3;
 		break;
 
 	default:
@@ -1014,17 +1043,22 @@ static int __devinit snd_miro_configure(struct snd_miro *chip)
 		return -EINVAL;
 	}
 
-	switch (chip->wss_base) {
-	case 0x530:
+	/* PnP resource says it decodes only 10 bits of address */
+	switch (chip->wss_base & 0x3ff) {
+	case 0x130:
+		chip->wss_base = 0x530;
 		wss_base_bits = 0x00;
 		break;
-	case 0x604:
+	case 0x204:
+		chip->wss_base = 0x604;
 		wss_base_bits = 0x03;
 		break;
-	case 0xe80:
+	case 0x280:
+		chip->wss_base = 0xe80;
 		wss_base_bits = 0x01;
 		break;
-	case 0xf40:
+	case 0x340:
+		chip->wss_base = 0xf40;
 		wss_base_bits = 0x02;
 		break;
 	default:
@@ -1238,7 +1272,7 @@ static int __devinit snd_card_miro_aci_detect(struct snd_card *card,
 static void snd_card_miro_free(struct snd_card *card)
 {
 	struct snd_miro *miro = card->private_data;
-        
+
 	release_and_free_resource(miro->res_aci_port);
 	if (miro->aci)
 		miro->aci->aci_port = 0;
@@ -1370,6 +1404,12 @@ static int __devinit snd_miro_probe(struct snd_card *card)
 
 static int __devinit snd_miro_isa_match(struct device *devptr, unsigned int n)
 {
+#ifdef CONFIG_PNP
+	if (snd_miro_pnp_is_probed)
+		return 0;
+	if (isapnp)
+		return 0;
+#endif
 	return 1;
 }
 
@@ -1487,14 +1527,155 @@ static struct isa_driver snd_miro_driver = {
 	},
 };
 
+#ifdef CONFIG_PNP
+
+static int __devinit snd_card_miro_pnp(struct snd_miro *chip,
+					struct pnp_card_link *card,
+					const struct pnp_card_device_id *pid)
+{
+	struct pnp_dev *pdev;
+	int err;
+	struct pnp_dev *devmpu;
+	struct pnp_dev *devmc;
+
+	pdev = pnp_request_card_device(card, pid->devs[0].id, NULL);
+	if (pdev == NULL)
+		return -EBUSY;
+
+	devmpu = pnp_request_card_device(card, pid->devs[1].id, NULL);
+	if (devmpu == NULL)
+		return -EBUSY;
+
+	devmc = pnp_request_card_device(card, pid->devs[2].id, NULL);
+	if (devmc == NULL)
+		return -EBUSY;
+
+	err = pnp_activate_dev(pdev);
+	if (err < 0) {
+		snd_printk(KERN_ERR "AUDIO pnp configure failure: %d\n", err);
+		return err;
+	}
+
+	err = pnp_activate_dev(devmc);
+	if (err < 0) {
+		snd_printk(KERN_ERR "OPL syntg pnp configure failure: %d\n",
+				    err);
+		return err;
+	}
+
+	port = pnp_port_start(pdev, 1);
+	fm_port = pnp_port_start(pdev, 2) + 8;
+
+	/*
+	 * The MC(0) is never accessed and the miroSOUND PCM20 card does not
+	 * include it in the PnP resource range. OPTI93x include it.
+	 */
+	chip->mc_base = pnp_port_start(devmc, 0) - 1;
+	chip->mc_base_size = pnp_port_len(devmc, 0) + 1;
+
+	irq = pnp_irq(pdev, 0);
+	dma1 = pnp_dma(pdev, 0);
+	dma2 = pnp_dma(pdev, 1);
+
+	if (mpu_port > 0) {
+		err = pnp_activate_dev(devmpu);
+		if (err < 0) {
+			snd_printk(KERN_ERR "MPU401 pnp configure failure\n");
+			mpu_port = -1;
+			return err;
+		}
+		mpu_port = pnp_port_start(devmpu, 0);
+		mpu_irq = pnp_irq(devmpu, 0);
+	}
+	return 0;
+}
+
+static int __devinit snd_miro_pnp_probe(struct pnp_card_link *pcard,
+					const struct pnp_card_device_id *pid)
+{
+	struct snd_card *card;
+	int err;
+	struct snd_miro *miro;
+
+	if (snd_miro_pnp_is_probed)
+		return -EBUSY;
+	if (!isapnp)
+		return -ENODEV;
+	err = snd_card_create(index, id, THIS_MODULE,
+				sizeof(struct snd_miro), &card);
+	if (err < 0)
+		return err;
+
+	card->private_free = snd_card_miro_free;
+	miro = card->private_data;
+
+	err = snd_card_miro_pnp(miro, pcard, pid);
+	if (err) {
+		snd_card_free(card);
+		return err;
+	}
+
+	/* only miroSOUND PCM20 and PCM12 == OPTi924 */
+	err = snd_miro_init(miro, OPTi9XX_HW_82C924);
+	if (err) {
+		snd_card_free(card);
+		return err;
+	}
+
+	err = snd_miro_opti_check(miro);
+	if (err) {
+		snd_printk(KERN_ERR "OPTI chip not found\n");
+		snd_card_free(card);
+		return err;
+	}
+
+	snd_card_set_dev(card, &pcard->card->dev);
+	err = snd_miro_probe(card);
+	if (err < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	pnp_set_card_drvdata(pcard, card);
+	snd_miro_pnp_is_probed = 1;
+	return 0;
+}
+
+static void __devexit snd_miro_pnp_remove(struct pnp_card_link * pcard)
+{
+	snd_card_free(pnp_get_card_drvdata(pcard));
+	pnp_set_card_drvdata(pcard, NULL);
+	snd_miro_pnp_is_probed = 0;
+}
+
+static struct pnp_card_driver miro_pnpc_driver = {
+	.flags		= PNP_DRIVER_RES_DISABLE,
+	.name		= "miro",
+	.id_table	= snd_miro_pnpids,
+	.probe		= snd_miro_pnp_probe,
+	.remove		= __devexit_p(snd_miro_pnp_remove),
+};
+#endif
+
 static int __init alsa_card_miro_init(void)
 {
+#ifdef CONFIG_PNP
+	pnp_register_card_driver(&miro_pnpc_driver);
+	if (snd_miro_pnp_is_probed)
+		return 0;
+	pnp_unregister_card_driver(&miro_pnpc_driver);
+#endif
 	return isa_register_driver(&snd_miro_driver, 1);
 }
 
 static void __exit alsa_card_miro_exit(void)
 {
-	isa_unregister_driver(&snd_miro_driver);
+	if (!snd_miro_pnp_is_probed) {
+		isa_unregister_driver(&snd_miro_driver);
+		return;
+	}
+#ifdef CONFIG_PNP
+	pnp_unregister_card_driver(&miro_pnpc_driver);
+#endif
 }
 
 module_init(alsa_card_miro_init)

commit 70a5f1187bcb3fac93a7d5c5fcfc5fc76b9c3f55
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Mon Nov 30 07:45:47 2009 +0100

    ALSA: opti-miro: separate comon probing code
    
    Separate common probing code in order to use it
    for PnP probing.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index e374869e3e21..c67bc3cd2c65 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1142,28 +1142,39 @@ static int __devinit snd_miro_configure(struct snd_miro *chip)
 	return 0;
 }
 
+static int __devinit snd_miro_opti_check(struct snd_miro *chip)
+{
+	unsigned char value;
+
+	chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size,
+					   "OPTi9xx MC");
+	if (chip->res_mc_base == NULL)
+		return -ENOMEM;
+
+	value = snd_miro_read(chip, OPTi9XX_MC_REG(1));
+	if (value != 0xff && value != inb(chip->mc_base + OPTi9XX_MC_REG(1)))
+		if (value == snd_miro_read(chip, OPTi9XX_MC_REG(1)))
+			return 0;
+
+	release_and_free_resource(chip->res_mc_base);
+	chip->res_mc_base = NULL;
+
+	return -ENODEV;
+}
+
 static int __devinit snd_card_miro_detect(struct snd_card *card,
 					  struct snd_miro *chip)
 {
 	int i, err;
-	unsigned char value;
 
 	for (i = OPTi9XX_HW_82C929; i <= OPTi9XX_HW_82C924; i++) {
 
 		if ((err = snd_miro_init(chip, i)) < 0)
 			return err;
 
-		if ((chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size, "OPTi9xx MC")) == NULL)
-			continue;
-
-		value = snd_miro_read(chip, OPTi9XX_MC_REG(1));
-		if ((value != 0xff) && (value != inb(chip->mc_base + 1)))
-			if (value == snd_miro_read(chip, OPTi9XX_MC_REG(1)))
-				return 1;
-
-		release_and_free_resource(chip->res_mc_base);
-		chip->res_mc_base = NULL;
-
+		err = snd_miro_opti_check(chip);
+		if (err == 0)
+			return 1;
 	}
 
 	return -ENODEV;
@@ -1234,151 +1245,69 @@ static void snd_card_miro_free(struct snd_card *card)
 	release_and_free_resource(miro->res_mc_base);
 }
 
-static int __devinit snd_miro_match(struct device *devptr, unsigned int n)
-{
-	return 1;
-}
-
-static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
+static int __devinit snd_miro_probe(struct snd_card *card)
 {
-	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
-	static long possible_mpu_ports[] = {0x330, 0x300, 0x310, 0x320, -1};
-	static int possible_irqs[] = {11, 9, 10, 7, -1};
-	static int possible_mpu_irqs[] = {10, 5, 9, 7, -1};
-	static int possible_dma1s[] = {3, 1, 0, -1};
-	static int possible_dma2s[][2] = {{1,-1}, {0,-1}, {-1,-1}, {0,-1}};
-
 	int error;
-	struct snd_miro *miro;
+	struct snd_miro *miro = card->private_data;
 	struct snd_wss *codec;
 	struct snd_timer *timer;
-	struct snd_card *card;
 	struct snd_pcm *pcm;
 	struct snd_rawmidi *rmidi;
 
-	error = snd_card_create(index, id, THIS_MODULE,
-				sizeof(struct snd_miro), &card);
-	if (error < 0)
-		return error;
-
-	card->private_free = snd_card_miro_free;
-	miro = card->private_data;
-
-	error = snd_card_miro_detect(card, miro);
-	if (error < 0) {
-		snd_card_free(card);
-		snd_printk(KERN_ERR "unable to detect OPTi9xx chip\n");
-		return -ENODEV;
+	if (!miro->res_mc_base) {
+		miro->res_mc_base = request_region(miro->mc_base,
+						miro->mc_base_size,
+						"miro (OPTi9xx MC)");
+		if (miro->res_mc_base == NULL) {
+			snd_printk(KERN_ERR "request for OPTI9xx MC failed\n");
+			return -ENOMEM;
+		}
 	}
 
-	if ((error = snd_card_miro_aci_detect(card, miro)) < 0) {
+	error = snd_card_miro_aci_detect(card, miro);
+	if (error < 0) {
 		snd_card_free(card);
 		snd_printk(KERN_ERR "unable to detect aci chip\n");
 		return -ENODEV;
 	}
 
-	/* init proc interface */
-	snd_miro_proc_init(card, miro);
-
-
-	if (! miro->res_mc_base &&
-	    (miro->res_mc_base = request_region(miro->mc_base, miro->mc_base_size,
-						"miro (OPTi9xx MC)")) == NULL) {
-		snd_card_free(card);
-		snd_printk(KERN_ERR "request for OPTI9xx MC failed\n");
-		return -ENOMEM;
-	}
-
 	miro->wss_base = port;
+	miro->mpu_port = mpu_port;
 	miro->irq = irq;
 	miro->mpu_irq = mpu_irq;
 	miro->dma1 = dma1;
 	miro->dma2 = dma2;
 
-	if (miro->wss_base == SNDRV_AUTO_PORT) {
-		if ((miro->wss_base = snd_legacy_find_free_ioport(possible_ports, 4)) < 0) {
-			snd_card_free(card);
-			snd_printk(KERN_ERR "unable to find a free WSS port\n");
-			return -EBUSY;
-		}
-	}
-
-	if (mpu_port == SNDRV_AUTO_PORT) {
-		mpu_port = snd_legacy_find_free_ioport(possible_mpu_ports, 2);
-		if (mpu_port < 0) {
-			snd_card_free(card);
-			snd_printk(KERN_ERR "unable to find a free MPU401 port\n");
-			return -EBUSY;
-		}
-	}
-	miro->mpu_port = mpu_port;
-
-	if (miro->irq == SNDRV_AUTO_IRQ) {
-		if ((miro->irq = snd_legacy_find_free_irq(possible_irqs)) < 0) {
-			snd_card_free(card);
-			snd_printk(KERN_ERR "unable to find a free IRQ\n");
-			return -EBUSY;
-		}
-	}
-	if (miro->mpu_irq == SNDRV_AUTO_IRQ) {
-		if ((miro->mpu_irq = snd_legacy_find_free_irq(possible_mpu_irqs)) < 0) {
-			snd_card_free(card);
-			snd_printk(KERN_ERR "unable to find a free MPU401 IRQ\n");
-			return -EBUSY;
-		}
-	}
-	if (miro->dma1 == SNDRV_AUTO_DMA) {
-		if ((miro->dma1 = snd_legacy_find_free_dma(possible_dma1s)) < 0) {
-			snd_card_free(card);
-			snd_printk(KERN_ERR "unable to find a free DMA1\n");
-			return -EBUSY;
-		}
-	}
-	if (miro->dma2 == SNDRV_AUTO_DMA) {
-		if ((miro->dma2 = snd_legacy_find_free_dma(possible_dma2s[miro->dma1 % 4])) < 0) {
-			snd_card_free(card);
-			snd_printk(KERN_ERR "unable to find a free DMA2\n");
-			return -EBUSY;
-		}
-	}
+	/* init proc interface */
+	snd_miro_proc_init(card, miro);
 
 	error = snd_miro_configure(miro);
-	if (error) {
-		snd_card_free(card);
+	if (error)
 		return error;
-	}
 
 	error = snd_wss_create(card, miro->wss_base + 4, -1,
-				miro->irq, miro->dma1, miro->dma2,
-				WSS_HW_AD1845, 0, &codec);
-	if (error < 0) {
-		snd_card_free(card);
+			       miro->irq, miro->dma1, miro->dma2,
+			       WSS_HW_DETECT, 0, &codec);
+	if (error < 0)
 		return error;
-	}
 
 	error = snd_wss_pcm(codec, 0, &pcm);
-	if (error < 0)  {
-		snd_card_free(card);
+	if (error < 0)
 		return error;
-	}
+
 	error = snd_wss_mixer(codec);
-	if (error < 0) {
-		snd_card_free(card);
+	if (error < 0)
 		return error;
-	}
+
 	error = snd_wss_timer(codec, 0, &timer);
-	if (error < 0) {
-		snd_card_free(card);
+	if (error < 0)
 		return error;
-	}
 
 	miro->pcm = pcm;
 
 	error = snd_miro_mixer(card, miro);
-	if (error < 0) {
-		snd_card_free(card);
+	if (error < 0)
 		return error;
-	}
 
 	if (miro->aci->aci_vendor == 'm') {
 		/* It looks like a miro sound card. */
@@ -1425,20 +1354,111 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 	if (fm_port > 0 && fm_port != SNDRV_AUTO_PORT) {
 		struct snd_opl3 *opl3 = NULL;
 		struct snd_opl4 *opl4;
+
 		if (snd_opl4_create(card, fm_port, fm_port - 8,
 				    2, &opl3, &opl4) < 0)
 			snd_printk(KERN_WARNING "no OPL4 device at 0x%lx\n",
 				   fm_port);
 	}
 
-	if ((error = snd_set_aci_init_values(miro)) < 0) {
-		snd_card_free(card);
+	error = snd_set_aci_init_values(miro);
+	if (error < 0)
                 return error;
+
+	return snd_card_register(card);
+}
+
+static int __devinit snd_miro_isa_match(struct device *devptr, unsigned int n)
+{
+	return 1;
+}
+
+static int __devinit snd_miro_isa_probe(struct device *devptr, unsigned int n)
+{
+	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
+	static long possible_mpu_ports[] = {0x330, 0x300, 0x310, 0x320, -1};
+	static int possible_irqs[] = {11, 9, 10, 7, -1};
+	static int possible_mpu_irqs[] = {10, 5, 9, 7, -1};
+	static int possible_dma1s[] = {3, 1, 0, -1};
+	static int possible_dma2s[][2] = { {1, -1}, {0, -1}, {-1, -1},
+					   {0, -1} };
+
+	int error;
+	struct snd_miro *miro;
+	struct snd_card *card;
+
+	error = snd_card_create(index, id, THIS_MODULE,
+				sizeof(struct snd_miro), &card);
+	if (error < 0)
+		return error;
+
+	card->private_free = snd_card_miro_free;
+	miro = card->private_data;
+
+	error = snd_card_miro_detect(card, miro);
+	if (error < 0) {
+		snd_card_free(card);
+		snd_printk(KERN_ERR "unable to detect OPTi9xx chip\n");
+		return -ENODEV;
+	}
+
+	if (port == SNDRV_AUTO_PORT) {
+		port = snd_legacy_find_free_ioport(possible_ports, 4);
+		if (port < 0) {
+			snd_card_free(card);
+			snd_printk(KERN_ERR "unable to find a free WSS port\n");
+			return -EBUSY;
+		}
+	}
+
+	if (mpu_port == SNDRV_AUTO_PORT) {
+		mpu_port = snd_legacy_find_free_ioport(possible_mpu_ports, 2);
+		if (mpu_port < 0) {
+			snd_card_free(card);
+			snd_printk(KERN_ERR
+				   "unable to find a free MPU401 port\n");
+			return -EBUSY;
+		}
+	}
+
+	if (irq == SNDRV_AUTO_IRQ) {
+		irq = snd_legacy_find_free_irq(possible_irqs);
+		if (irq < 0) {
+			snd_card_free(card);
+			snd_printk(KERN_ERR "unable to find a free IRQ\n");
+			return -EBUSY;
+		}
+	}
+	if (mpu_irq == SNDRV_AUTO_IRQ) {
+		mpu_irq = snd_legacy_find_free_irq(possible_mpu_irqs);
+		if (mpu_irq < 0) {
+			snd_card_free(card);
+			snd_printk(KERN_ERR
+				   "unable to find a free MPU401 IRQ\n");
+			return -EBUSY;
+		}
+	}
+	if (dma1 == SNDRV_AUTO_DMA) {
+		dma1 = snd_legacy_find_free_dma(possible_dma1s);
+		if (dma1 < 0) {
+			snd_card_free(card);
+			snd_printk(KERN_ERR "unable to find a free DMA1\n");
+			return -EBUSY;
+		}
+	}
+	if (dma2 == SNDRV_AUTO_DMA) {
+		dma2 = snd_legacy_find_free_dma(possible_dma2s[dma1 % 4]);
+		if (dma2 < 0) {
+			snd_card_free(card);
+			snd_printk(KERN_ERR "unable to find a free DMA2\n");
+			return -EBUSY;
+		}
 	}
 
 	snd_card_set_dev(card, devptr);
 
-	if ((error = snd_card_register(card))) {
+	error = snd_miro_probe(card);
+	if (error < 0) {
 		snd_card_free(card);
 		return error;
 	}
@@ -1447,7 +1467,8 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 	return 0;
 }
 
-static int __devexit snd_miro_remove(struct device *devptr, unsigned int dev)
+static int __devexit snd_miro_isa_remove(struct device *devptr,
+					 unsigned int dev)
 {
 	snd_card_free(dev_get_drvdata(devptr));
 	dev_set_drvdata(devptr, NULL);
@@ -1457,9 +1478,9 @@ static int __devexit snd_miro_remove(struct device *devptr, unsigned int dev)
 #define DEV_NAME "miro"
 
 static struct isa_driver snd_miro_driver = {
-	.match		= snd_miro_match,
-	.probe		= snd_miro_probe,
-	.remove		= __devexit_p(snd_miro_remove),
+	.match		= snd_miro_isa_match,
+	.probe		= snd_miro_isa_probe,
+	.remove		= __devexit_p(snd_miro_isa_remove),
 	/* FIXME: suspend/resume */
 	.driver		= {
 		.name	= DEV_NAME

commit 8700055e0a30b3f67c1474b09200b59c32dd3796
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Fri Nov 27 11:20:56 2009 +0100

    ALSA: opti-miro: fix OOPS if hardware is not detected
    
    If a hardware is not detected there is a kernel crash
    due to not initialized snd_miro->aci pointer. This pointer
    is initialized after detection of the opti (miro) chip.
    
    This bug was introduced by patches to expose
    ACI mikser outside the snd-miro driver.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 40b64cd54c85..e374869e3e21 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1229,7 +1229,8 @@ static void snd_card_miro_free(struct snd_card *card)
 	struct snd_miro *miro = card->private_data;
         
 	release_and_free_resource(miro->res_aci_port);
-	miro->aci->aci_port = 0;
+	if (miro->aci)
+		miro->aci->aci_port = 0;
 	release_and_free_resource(miro->res_mc_base);
 }
 

commit 9dc9120c774e1d7e3d939542200bd44829c0059d
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Sun Nov 22 17:26:34 2009 +0100

    ALSA: opti-miro: expose ACI mixer to outside drivers
    
    The ACI mixer is used to control the radio FM module
    installed on the Miro PCM20 sound card. Expose ACI mixer
    outside the sound card driver.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 932a067ef980..40b64cd54c85 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -96,7 +96,6 @@ MODULE_PARM_DESC(ide, "enable ide port");
 
 #define OPTi9XX_MC_REG(n)	n
 
-
 struct snd_miro {
 	unsigned short hardware;
 	unsigned char password;
@@ -120,17 +119,11 @@ struct snd_miro {
 	long mpu_port;
 	int mpu_irq;
 
-	unsigned long aci_port;
-	int aci_vendor;
-	int aci_product;
-	int aci_version;
-	int aci_amp;
-	int aci_preamp;
-	int aci_solomode;
-
-	struct mutex aci_mutex;
+	struct snd_miro_aci *aci;
 };
 
+static struct snd_miro_aci aci_device;
+
 static char * snd_opti9xx_names[] = {
 	"unkown",
 	"82C928", "82C929",
@@ -142,13 +135,14 @@ static char * snd_opti9xx_names[] = {
  *  ACI control
  */
 
-static int aci_busy_wait(struct snd_miro * miro)
+static int aci_busy_wait(struct snd_miro_aci *aci)
 {
 	long timeout;
 	unsigned char byte;
 
-	for (timeout = 1; timeout <= ACI_MINTIME+30; timeout++) {
-		if (((byte=inb(miro->aci_port + ACI_REG_BUSY)) & 1) == 0) {
+	for (timeout = 1; timeout <= ACI_MINTIME + 30; timeout++) {
+		byte = inb(aci->aci_port + ACI_REG_BUSY);
+		if ((byte & 1) == 0) {
 			if (timeout >= ACI_MINTIME)
 				snd_printd("aci ready in round %ld.\n",
 					   timeout-ACI_MINTIME);
@@ -174,10 +168,10 @@ static int aci_busy_wait(struct snd_miro * miro)
 	return -EBUSY;
 }
 
-static inline int aci_write(struct snd_miro * miro, unsigned char byte)
+static inline int aci_write(struct snd_miro_aci *aci, unsigned char byte)
 {
-	if (aci_busy_wait(miro) >= 0) {
-		outb(byte, miro->aci_port + ACI_REG_COMMAND);
+	if (aci_busy_wait(aci) >= 0) {
+		outb(byte, aci->aci_port + ACI_REG_COMMAND);
 		return 0;
 	} else {
 		snd_printk(KERN_ERR "aci busy, aci_write(0x%x) stopped.\n", byte);
@@ -185,12 +179,12 @@ static inline int aci_write(struct snd_miro * miro, unsigned char byte)
 	}
 }
 
-static inline int aci_read(struct snd_miro * miro)
+static inline int aci_read(struct snd_miro_aci *aci)
 {
 	unsigned char byte;
 
-	if (aci_busy_wait(miro) >= 0) {
-		byte=inb(miro->aci_port + ACI_REG_STATUS);
+	if (aci_busy_wait(aci) >= 0) {
+		byte = inb(aci->aci_port + ACI_REG_STATUS);
 		return byte;
 	} else {
 		snd_printk(KERN_ERR "aci busy, aci_read() stopped.\n");
@@ -198,39 +192,49 @@ static inline int aci_read(struct snd_miro * miro)
 	}
 }
 
-static int aci_cmd(struct snd_miro * miro, int write1, int write2, int write3)
+int snd_aci_cmd(struct snd_miro_aci *aci, int write1, int write2, int write3)
 {
 	int write[] = {write1, write2, write3};
 	int value, i;
 
-	if (mutex_lock_interruptible(&miro->aci_mutex))
+	if (mutex_lock_interruptible(&aci->aci_mutex))
 		return -EINTR;
 
 	for (i=0; i<3; i++) {
 		if (write[i]< 0 || write[i] > 255)
 			break;
 		else {
-			value = aci_write(miro, write[i]);
+			value = aci_write(aci, write[i]);
 			if (value < 0)
 				goto out;
 		}
 	}
 
-	value = aci_read(miro);
+	value = aci_read(aci);
 
-out:	mutex_unlock(&miro->aci_mutex);
+out:	mutex_unlock(&aci->aci_mutex);
 	return value;
 }
+EXPORT_SYMBOL(snd_aci_cmd);
+
+static int aci_getvalue(struct snd_miro_aci *aci, unsigned char index)
+{
+	return snd_aci_cmd(aci, ACI_STATUS, index, -1);
+}
 
-static int aci_getvalue(struct snd_miro * miro, unsigned char index)
+static int aci_setvalue(struct snd_miro_aci *aci, unsigned char index,
+			int value)
 {
-	return aci_cmd(miro, ACI_STATUS, index, -1);
+	return snd_aci_cmd(aci, index, value, -1);
 }
 
-static int aci_setvalue(struct snd_miro * miro, unsigned char index, int value)
+struct snd_miro_aci *snd_aci_get_aci(void)
 {
-	return aci_cmd(miro, index, value, -1);
+	if (aci_device.aci_port == 0)
+		return NULL;
+	return &aci_device;
 }
+EXPORT_SYMBOL(snd_aci_get_aci);
 
 /*
  *  MIXER part
@@ -244,8 +248,10 @@ static int snd_miro_get_capture(struct snd_kcontrol *kcontrol,
 	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
 	int value;
 
-	if ((value = aci_getvalue(miro, ACI_S_GENERAL)) < 0) {
-		snd_printk(KERN_ERR "snd_miro_get_capture() failed: %d\n", value);
+	value = aci_getvalue(miro->aci, ACI_S_GENERAL);
+	if (value < 0) {
+		snd_printk(KERN_ERR "snd_miro_get_capture() failed: %d\n",
+			   value);
 		return value;
 	}
 
@@ -262,13 +268,15 @@ static int snd_miro_put_capture(struct snd_kcontrol *kcontrol,
 
 	value = !(ucontrol->value.integer.value[0]);
 
-	if ((error = aci_setvalue(miro, ACI_SET_SOLOMODE, value)) < 0) {
-		snd_printk(KERN_ERR "snd_miro_put_capture() failed: %d\n", error);
+	error = aci_setvalue(miro->aci, ACI_SET_SOLOMODE, value);
+	if (error < 0) {
+		snd_printk(KERN_ERR "snd_miro_put_capture() failed: %d\n",
+			   error);
 		return error;
 	}
 
-	change = (value != miro->aci_solomode);
-	miro->aci_solomode = value;
+	change = (value != miro->aci->aci_solomode);
+	miro->aci->aci_solomode = value;
 	
 	return change;
 }
@@ -290,7 +298,7 @@ static int snd_miro_get_preamp(struct snd_kcontrol *kcontrol,
 	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
 	int value;
 
-	if (miro->aci_version <= 176) {
+	if (miro->aci->aci_version <= 176) {
 
 		/* 
 		   OSS says it's not readable with versions < 176.
@@ -298,12 +306,14 @@ static int snd_miro_get_preamp(struct snd_kcontrol *kcontrol,
 		   which is a PCM12 with aci_version = 176.
 		*/
 
-		ucontrol->value.integer.value[0] = miro->aci_preamp;
+		ucontrol->value.integer.value[0] = miro->aci->aci_preamp;
 		return 0;
 	}
 
-	if ((value = aci_getvalue(miro, ACI_GET_PREAMP)) < 0) {
-		snd_printk(KERN_ERR "snd_miro_get_preamp() failed: %d\n", value);
+	value = aci_getvalue(miro->aci, ACI_GET_PREAMP);
+	if (value < 0) {
+		snd_printk(KERN_ERR "snd_miro_get_preamp() failed: %d\n",
+			   value);
 		return value;
 	}
 	
@@ -320,13 +330,15 @@ static int snd_miro_put_preamp(struct snd_kcontrol *kcontrol,
 
 	value = ucontrol->value.integer.value[0];
 
-	if ((error = aci_setvalue(miro, ACI_SET_PREAMP, value)) < 0) {
-		snd_printk(KERN_ERR "snd_miro_put_preamp() failed: %d\n", error);
+	error = aci_setvalue(miro->aci, ACI_SET_PREAMP, value);
+	if (error < 0) {
+		snd_printk(KERN_ERR "snd_miro_put_preamp() failed: %d\n",
+			   error);
 		return error;
 	}
 
-	change = (value != miro->aci_preamp);
-	miro->aci_preamp = value;
+	change = (value != miro->aci->aci_preamp);
+	miro->aci->aci_preamp = value;
 
 	return change;
 }
@@ -337,7 +349,7 @@ static int snd_miro_get_amp(struct snd_kcontrol *kcontrol,
 			    struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
-	ucontrol->value.integer.value[0] = miro->aci_amp;
+	ucontrol->value.integer.value[0] = miro->aci->aci_amp;
 
 	return 0;
 }
@@ -350,13 +362,14 @@ static int snd_miro_put_amp(struct snd_kcontrol *kcontrol,
 
 	value = ucontrol->value.integer.value[0];
 
-	if ((error = aci_setvalue(miro, ACI_SET_POWERAMP, value)) < 0) {
+	error = aci_setvalue(miro->aci, ACI_SET_POWERAMP, value);
+	if (error < 0) {
 		snd_printk(KERN_ERR "snd_miro_put_amp() to %d failed: %d\n", value, error);
 		return error;
 	}
 
-	change = (value != miro->aci_amp);
-	miro->aci_amp = value;
+	change = (value != miro->aci->aci_amp);
+	miro->aci->aci_amp = value;
 
 	return change;
 }
@@ -405,12 +418,14 @@ static int snd_miro_get_double(struct snd_kcontrol *kcontrol,
 	int right_reg = kcontrol->private_value & 0xff;
 	int left_reg = right_reg + 1;
 
-	if ((right_val = aci_getvalue(miro, right_reg)) < 0) {
+	right_val = aci_getvalue(miro->aci, right_reg);
+	if (right_val < 0) {
 		snd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", right_reg, right_val);
 		return right_val;
 	}
 
-	if ((left_val = aci_getvalue(miro, left_reg)) < 0) {
+	left_val = aci_getvalue(miro->aci, left_reg);
+	if (left_val < 0) {
 		snd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", left_reg, left_val);
 		return left_val;
 	}
@@ -446,6 +461,7 @@ static int snd_miro_put_double(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
+	struct snd_miro_aci *aci = miro->aci;
 	int left, right, left_old, right_old;
 	int setreg_left, setreg_right, getreg_left, getreg_right;
 	int change, error;
@@ -461,12 +477,14 @@ static int snd_miro_put_double(struct snd_kcontrol *kcontrol,
 	getreg_right = kcontrol->private_value & 0xff;
 	getreg_left = getreg_right + 1;
 
-	if ((left_old = aci_getvalue(miro, getreg_left)) < 0) {
+	left_old = aci_getvalue(aci, getreg_left);
+	if (left_old < 0) {
 		snd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", getreg_left, left_old);
 		return left_old;
 	}
 
-	if ((right_old = aci_getvalue(miro, getreg_right)) < 0) {
+	right_old = aci_getvalue(aci, getreg_right);
+	if (right_old < 0) {
 		snd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", getreg_right, right_old);
 		return right_old;
 	}
@@ -485,13 +503,15 @@ static int snd_miro_put_double(struct snd_kcontrol *kcontrol,
 			right_old = 0x80 - right_old;
 
 		if (left >= 0) {
-			if ((error = aci_setvalue(miro, setreg_left, left)) < 0) {
+			error = aci_setvalue(aci, setreg_left, left);
+			if (error < 0) {
 				snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
 					   left, error);
 				return error;
 			}
 		} else {
-			if ((error = aci_setvalue(miro, setreg_left, 0x80 - left)) < 0) {
+			error = aci_setvalue(aci, setreg_left, 0x80 - left);
+			if (error < 0) {
 				snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
 					   0x80 - left, error);
 				return error;
@@ -499,13 +519,15 @@ static int snd_miro_put_double(struct snd_kcontrol *kcontrol,
 		}
 
 		if (right >= 0) {
-			if ((error = aci_setvalue(miro, setreg_right, right)) < 0) {
+			error = aci_setvalue(aci, setreg_right, right);
+			if (error < 0) {
 				snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
 					   right, error);
 				return error;
 			}
 		} else {
-			if ((error = aci_setvalue(miro, setreg_right, 0x80 - right)) < 0) {
+			error = aci_setvalue(aci, setreg_right, 0x80 - right);
+			if (error < 0) {
 				snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
 					   0x80 - right, error);
 				return error;
@@ -523,12 +545,14 @@ static int snd_miro_put_double(struct snd_kcontrol *kcontrol,
 		left_old = 0x20 - left_old;
 		right_old = 0x20 - right_old;
 
-		if ((error = aci_setvalue(miro, setreg_left, 0x20 - left)) < 0) {
+		error = aci_setvalue(aci, setreg_left, 0x20 - left);
+		if (error < 0) {
 			snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
 				   0x20 - left, error);
 			return error;
 		}
-		if ((error = aci_setvalue(miro, setreg_right, 0x20 - right)) < 0) {
+		error = aci_setvalue(aci, setreg_right, 0x20 - right);
+		if (error < 0) {
 			snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
 				   0x20 - right, error);
 			return error;
@@ -626,11 +650,13 @@ static unsigned char aci_init_values[][2] __devinitdata = {
 static int __devinit snd_set_aci_init_values(struct snd_miro *miro)
 {
 	int idx, error;
+	struct snd_miro_aci *aci = miro->aci;
 
 	/* enable WSS on PCM1 */
 
-	if ((miro->aci_product == 'A') && wss) {
-		if ((error = aci_setvalue(miro, ACI_SET_WSS, wss)) < 0) {
+	if ((aci->aci_product == 'A') && wss) {
+		error = aci_setvalue(aci, ACI_SET_WSS, wss);
+		if (error < 0) {
 			snd_printk(KERN_ERR "enabling WSS mode failed\n");
 			return error;
 		}
@@ -639,7 +665,8 @@ static int __devinit snd_set_aci_init_values(struct snd_miro *miro)
 	/* enable IDE port */
 
 	if (ide) {
-		if ((error = aci_setvalue(miro, ACI_SET_IDE, ide)) < 0) {
+		error = aci_setvalue(aci, ACI_SET_IDE, ide);
+		if (error < 0) {
 			snd_printk(KERN_ERR "enabling IDE port failed\n");
 			return error;
 		}
@@ -647,17 +674,18 @@ static int __devinit snd_set_aci_init_values(struct snd_miro *miro)
 
 	/* set common aci values */
 
-	for (idx = 0; idx < ARRAY_SIZE(aci_init_values); idx++)
-                if ((error = aci_setvalue(miro, aci_init_values[idx][0], 
-					  aci_init_values[idx][1])) < 0) {
+	for (idx = 0; idx < ARRAY_SIZE(aci_init_values); idx++) {
+		error = aci_setvalue(aci, aci_init_values[idx][0],
+				     aci_init_values[idx][1]);
+		if (error < 0) {
 			snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n", 
 				   aci_init_values[idx][0], error);
                         return error;
                 }
-
-	miro->aci_amp = 0;
-	miro->aci_preamp = 0;
-	miro->aci_solomode = 1;
+	}
+	aci->aci_amp = 0;
+	aci->aci_preamp = 0;
+	aci->aci_solomode = 1;
 
 	return 0;
 }
@@ -688,7 +716,8 @@ static int __devinit snd_miro_mixer(struct snd_card *card,
 			return err;
 	}
 
-	if ((miro->aci_product == 'A') || (miro->aci_product == 'B')) {
+	if ((miro->aci->aci_product == 'A') ||
+	    (miro->aci->aci_product == 'B')) {
 		/* PCM1/PCM12 with power-amp and Line 2 */
 		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_line_control[0], miro))) < 0)
 			return err;
@@ -696,16 +725,17 @@ static int __devinit snd_miro_mixer(struct snd_card *card,
 			return err;
 	}
 
-	if ((miro->aci_product == 'B') || (miro->aci_product == 'C')) {
+	if ((miro->aci->aci_product == 'B') ||
+	    (miro->aci->aci_product == 'C')) {
 		/* PCM12/PCM20 with mic-preamp */
 		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_preamp_control[0], miro))) < 0)
 			return err;
-		if (miro->aci_version >= 176)
+		if (miro->aci->aci_version >= 176)
 			if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_capture_control[0], miro))) < 0)
 				return err;
 	}
 
-	if (miro->aci_product == 'C') {
+	if (miro->aci->aci_product == 'C') {
 		/* PCM20 with radio and 7 band equalizer */
 		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_radio_control[0], miro))) < 0)
 			return err;
@@ -843,14 +873,15 @@ static void snd_miro_proc_read(struct snd_info_entry * entry,
 			       struct snd_info_buffer *buffer)
 {
 	struct snd_miro *miro = (struct snd_miro *) entry->private_data;
+	struct snd_miro_aci *aci = miro->aci;
 	char* model = "unknown";
 
 	/* miroSOUND PCM1 pro, early PCM12 */
 
 	if ((miro->hardware == OPTi9XX_HW_82C929) &&
-	    (miro->aci_vendor == 'm') && 
-	    (miro->aci_product == 'A')) {
-		switch(miro->aci_version) {
+	    (aci->aci_vendor == 'm') &&
+	    (aci->aci_product == 'A')) {
+		switch (aci->aci_version) {
 		case 3:
 			model = "miroSOUND PCM1 pro";
 			break;
@@ -863,9 +894,9 @@ static void snd_miro_proc_read(struct snd_info_entry * entry,
 	/* miroSOUND PCM12, PCM12 (Rev. E), PCM12 pnp */
 
 	if ((miro->hardware == OPTi9XX_HW_82C924) &&
-	    (miro->aci_vendor == 'm') && 
-	    (miro->aci_product == 'B')) {
-		switch(miro->aci_version) {
+	    (aci->aci_vendor == 'm') &&
+	    (aci->aci_product == 'B')) {
+		switch (aci->aci_version) {
 		case 4:
 			model = "miroSOUND PCM12";
 			break;
@@ -881,9 +912,9 @@ static void snd_miro_proc_read(struct snd_info_entry * entry,
 	/* miroSOUND PCM20 radio */
 
 	if ((miro->hardware == OPTi9XX_HW_82C924) &&
-	    (miro->aci_vendor == 'm') && 
-	    (miro->aci_product == 'C')) {
-		switch(miro->aci_version) {
+	    (aci->aci_vendor == 'm') &&
+	    (aci->aci_product == 'C')) {
+		switch (aci->aci_version) {
 		case 7:
 			model = "miroSOUND PCM20 radio (Rev. E)";
 			break;
@@ -907,17 +938,17 @@ static void snd_miro_proc_read(struct snd_info_entry * entry,
 
 	snd_iprintf(buffer, "ACI information:\n");
 	snd_iprintf(buffer, "  vendor  : ");
-	switch(miro->aci_vendor) {
+	switch (aci->aci_vendor) {
 	case 'm':
 		snd_iprintf(buffer, "Miro\n");
 		break;
 	default:
-		snd_iprintf(buffer, "unknown (0x%x)\n", miro->aci_vendor);
+		snd_iprintf(buffer, "unknown (0x%x)\n", aci->aci_vendor);
 		break;
 	}
 
 	snd_iprintf(buffer, "  product : ");
-	switch(miro->aci_product) {
+	switch (aci->aci_product) {
 	case 'A':
 		snd_iprintf(buffer, "miroSOUND PCM1 pro / (early) PCM12\n");
 		break;
@@ -928,19 +959,19 @@ static void snd_miro_proc_read(struct snd_info_entry * entry,
 		snd_iprintf(buffer, "miroSOUND PCM20 radio\n");
 		break;
 	default:
-		snd_iprintf(buffer, "unknown (0x%x)\n", miro->aci_product);
+		snd_iprintf(buffer, "unknown (0x%x)\n", aci->aci_product);
 		break;
 	}
 
 	snd_iprintf(buffer, "  firmware: %d (0x%x)\n",
-		    miro->aci_version, miro->aci_version);
+		    aci->aci_version, aci->aci_version);
 	snd_iprintf(buffer, "  port    : 0x%lx-0x%lx\n", 
-		    miro->aci_port, miro->aci_port+2);
+		    aci->aci_port, aci->aci_port+2);
 	snd_iprintf(buffer, "  wss     : 0x%x\n", wss);
 	snd_iprintf(buffer, "  ide     : 0x%x\n", ide);
-	snd_iprintf(buffer, "  solomode: 0x%x\n", miro->aci_solomode);
-	snd_iprintf(buffer, "  amp     : 0x%x\n", miro->aci_amp);
-	snd_iprintf(buffer, "  preamp  : 0x%x\n", miro->aci_preamp);
+	snd_iprintf(buffer, "  solomode: 0x%x\n", aci->aci_solomode);
+	snd_iprintf(buffer, "  amp     : 0x%x\n", aci->aci_amp);
+	snd_iprintf(buffer, "  preamp  : 0x%x\n", aci->aci_preamp);
 }
 
 static void __devinit snd_miro_proc_init(struct snd_card *card,
@@ -1139,46 +1170,53 @@ static int __devinit snd_card_miro_detect(struct snd_card *card,
 }
 
 static int __devinit snd_card_miro_aci_detect(struct snd_card *card,
-					      struct snd_miro * miro)
+					      struct snd_miro *miro)
 {
 	unsigned char regval;
 	int i;
+	struct snd_miro_aci *aci = &aci_device;
+
+	miro->aci = aci;
 
-	mutex_init(&miro->aci_mutex);
+	mutex_init(&aci->aci_mutex);
 
 	/* get ACI port from OPTi9xx MC 4 */
 
 	regval=inb(miro->mc_base + 4);
-	miro->aci_port = (regval & 0x10) ? 0x344: 0x354;
+	aci->aci_port = (regval & 0x10) ? 0x344 : 0x354;
 
-	if ((miro->res_aci_port = request_region(miro->aci_port, 3, "miro aci")) == NULL) {
+	miro->res_aci_port = request_region(aci->aci_port, 3, "miro aci");
+	if (miro->res_aci_port == NULL) {
 		snd_printk(KERN_ERR "aci i/o area 0x%lx-0x%lx already used.\n", 
-			   miro->aci_port, miro->aci_port+2);
+			   aci->aci_port, aci->aci_port+2);
 		return -ENOMEM;
 	}
 
         /* force ACI into a known state */
 	for (i = 0; i < 3; i++)
-		if (aci_cmd(miro, ACI_ERROR_OP, -1, -1) < 0) {
+		if (snd_aci_cmd(aci, ACI_ERROR_OP, -1, -1) < 0) {
 			snd_printk(KERN_ERR "can't force aci into known state.\n");
 			return -ENXIO;
 		}
 
-	if ((miro->aci_vendor=aci_cmd(miro, ACI_READ_IDCODE, -1, -1)) < 0 ||
-	    (miro->aci_product=aci_cmd(miro, ACI_READ_IDCODE, -1, -1)) < 0) {
-		snd_printk(KERN_ERR "can't read aci id on 0x%lx.\n", miro->aci_port);
+	aci->aci_vendor = snd_aci_cmd(aci, ACI_READ_IDCODE, -1, -1);
+	aci->aci_product = snd_aci_cmd(aci, ACI_READ_IDCODE, -1, -1);
+	if (aci->aci_vendor < 0 || aci->aci_product < 0) {
+		snd_printk(KERN_ERR "can't read aci id on 0x%lx.\n",
+			   aci->aci_port);
 		return -ENXIO;
 	}
 
-	if ((miro->aci_version=aci_cmd(miro, ACI_READ_VERSION, -1, -1)) < 0) {
+	aci->aci_version = snd_aci_cmd(aci, ACI_READ_VERSION, -1, -1);
+	if (aci->aci_version < 0) {
 		snd_printk(KERN_ERR "can't read aci version on 0x%lx.\n", 
-			   miro->aci_port);
+			   aci->aci_port);
 		return -ENXIO;
 	}
 
-	if (aci_cmd(miro, ACI_INIT, -1, -1) < 0 ||
-	    aci_cmd(miro, ACI_ERROR_OP, ACI_ERROR_OP, ACI_ERROR_OP) < 0 ||
-	    aci_cmd(miro, ACI_ERROR_OP, ACI_ERROR_OP, ACI_ERROR_OP) < 0) {
+	if (snd_aci_cmd(aci, ACI_INIT, -1, -1) < 0 ||
+	    snd_aci_cmd(aci, ACI_ERROR_OP, ACI_ERROR_OP, ACI_ERROR_OP) < 0 ||
+	    snd_aci_cmd(aci, ACI_ERROR_OP, ACI_ERROR_OP, ACI_ERROR_OP) < 0) {
 		snd_printk(KERN_ERR "can't initialize aci.\n"); 
 		return -ENXIO;
 	}
@@ -1191,6 +1229,7 @@ static void snd_card_miro_free(struct snd_card *card)
 	struct snd_miro *miro = card->private_data;
         
 	release_and_free_resource(miro->res_aci_port);
+	miro->aci->aci_port = 0;
 	release_and_free_resource(miro->res_mc_base);
 }
 
@@ -1250,7 +1289,6 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 	}
 
 	miro->wss_base = port;
-	miro->mpu_port = mpu_port;
 	miro->irq = irq;
 	miro->mpu_irq = mpu_irq;
 	miro->dma1 = dma1;
@@ -1272,6 +1310,8 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 			return -EBUSY;
 		}
 	}
+	miro->mpu_port = mpu_port;
+
 	if (miro->irq == SNDRV_AUTO_IRQ) {
 		if ((miro->irq = snd_legacy_find_free_irq(possible_irqs)) < 0) {
 			snd_card_free(card);
@@ -1339,9 +1379,9 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 		return error;
 	}
 
-	if (miro->aci_vendor == 'm') {
+	if (miro->aci->aci_vendor == 'm') {
 		/* It looks like a miro sound card. */
-		switch (miro->aci_product) {
+		switch (miro->aci->aci_product) {
 		case 'A':
 			sprintf(card->shortname, 
 				"miroSOUND PCM1 pro / PCM12");

commit 9aeba6297151abcb1b34f3237e4c028aae500ce4
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Sun Nov 22 17:23:45 2009 +0100

    ALSA: opti-miro: make miro.h header available outside the alsa directory
    
    Move the miro.h header to the include/sound directory. It can
    be used in the Miro PCM20 radio driver (v4l).
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index db4a4fbdc5ca..932a067ef980 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -40,7 +40,7 @@
 #define SNDRV_LEGACY_FIND_FREE_IRQ
 #define SNDRV_LEGACY_FIND_FREE_DMA
 #include <sound/initval.h>
-#include "miro.h"
+#include <sound/aci.h>
 
 MODULE_AUTHOR("Martin Langer <martin-langer@gmx.de>");
 MODULE_LICENSE("GPL");

commit 616ad593fe37ef265e5cb1282db6ca264197ffb2
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Sat Nov 21 01:01:18 2009 +0100

    ALSA: opti-miro: remove snd_card pointer from snd_miro structure
    
    Remove the snd_card pointer from the snd_miro structure and
    do some small code improvements.
    
    Also, move Opti chipset detection before detection of the
    ACI mixer, so the mci_base value is set in one place only.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 17761030affa..db4a4fbdc5ca 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -110,7 +110,6 @@ struct snd_miro {
 	unsigned long pwd_reg;
 
 	spinlock_t lock;
-	struct snd_card *card;
 	struct snd_pcm *pcm;
 
 	long wss_base;
@@ -132,8 +131,6 @@ struct snd_miro {
 	struct mutex aci_mutex;
 };
 
-static void snd_miro_proc_init(struct snd_miro * miro);
-
 static char * snd_opti9xx_names[] = {
 	"unkown",
 	"82C928", "82C929",
@@ -457,11 +454,9 @@ static int snd_miro_put_double(struct snd_kcontrol *kcontrol,
 	right = ucontrol->value.integer.value[1];
 
 	setreg_right = (kcontrol->private_value >> 8) & 0xff;
-	if (setreg_right == ACI_SET_MASTER) {
-		setreg_left = setreg_right + 1;
-	} else {
-		setreg_left = setreg_right + 8;
-	}
+	setreg_left = setreg_right + 8;
+	if (setreg_right == ACI_SET_MASTER)
+		setreg_left -= 7;
 
 	getreg_right = kcontrol->private_value & 0xff;
 	getreg_left = getreg_right + 1;
@@ -667,17 +662,15 @@ static int __devinit snd_set_aci_init_values(struct snd_miro *miro)
 	return 0;
 }
 
-static int __devinit snd_miro_mixer(struct snd_miro *miro)
+static int __devinit snd_miro_mixer(struct snd_card *card,
+				    struct snd_miro *miro)
 {
-	struct snd_card *card;
 	unsigned int idx;
 	int err;
 
-	if (snd_BUG_ON(!miro || !miro->card))
+	if (snd_BUG_ON(!miro || !card))
 		return -EINVAL;
 
-	card = miro->card;
-
 	switch (miro->hardware) {
 	case OPTi9XX_HW_82C924:
 		strcpy(card->mixername, "ACI & OPTi924");
@@ -950,11 +943,12 @@ static void snd_miro_proc_read(struct snd_info_entry * entry,
 	snd_iprintf(buffer, "  preamp  : 0x%x\n", miro->aci_preamp);
 }
 
-static void __devinit snd_miro_proc_init(struct snd_miro * miro)
+static void __devinit snd_miro_proc_init(struct snd_card *card,
+					 struct snd_miro *miro)
 {
 	struct snd_info_entry *entry;
 
-	if (! snd_card_proc_new(miro->card, "miro", &entry))
+	if (!snd_card_proc_new(card, "miro", &entry))
 		snd_info_set_text_ops(entry, miro, snd_miro_proc_read);
 }
 
@@ -971,20 +965,18 @@ static int __devinit snd_miro_configure(struct snd_miro *chip)
 	unsigned char mpu_irq_bits;
 	unsigned long flags;
 
+	snd_miro_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);
+	snd_miro_write_mask(chip, OPTi9XX_MC_REG(2), 0x20, 0x20); /* OPL4 */
+	snd_miro_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);
+
 	switch (chip->hardware) {
 	case OPTi9XX_HW_82C924:
 		snd_miro_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x02);
-		snd_miro_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);
-		snd_miro_write_mask(chip, OPTi9XX_MC_REG(2), 0x20, 0x20); /* OPL4 */
 		snd_miro_write_mask(chip, OPTi9XX_MC_REG(3), 0xf0, 0xff);
-		snd_miro_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);
 		break;
 	case OPTi9XX_HW_82C929:
 		/* untested init commands for OPTi929 */
-		snd_miro_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);
-		snd_miro_write_mask(chip, OPTi9XX_MC_REG(2), 0x20, 0x20); /* OPL4 */
 		snd_miro_write_mask(chip, OPTi9XX_MC_REG(4), 0x00, 0x0c);
-		snd_miro_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);
 		break;
 	default:
 		snd_printk(KERN_ERR "chip %d not supported\n", chip->hardware);
@@ -1156,7 +1148,6 @@ static int __devinit snd_card_miro_aci_detect(struct snd_card *card,
 
 	/* get ACI port from OPTi9xx MC 4 */
 
-	miro->mc_base = 0xf8c;
 	regval=inb(miro->mc_base + 4);
 	miro->aci_port = (regval & 0x10) ? 0x344: 0x354;
 
@@ -1232,7 +1223,13 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 
 	card->private_free = snd_card_miro_free;
 	miro = card->private_data;
-	miro->card = card;
+
+	error = snd_card_miro_detect(card, miro);
+	if (error < 0) {
+		snd_card_free(card);
+		snd_printk(KERN_ERR "unable to detect OPTi9xx chip\n");
+		return -ENODEV;
+	}
 
 	if ((error = snd_card_miro_aci_detect(card, miro)) < 0) {
 		snd_card_free(card);
@@ -1241,13 +1238,8 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 	}
 
 	/* init proc interface */
-	snd_miro_proc_init(miro);
+	snd_miro_proc_init(card, miro);
 
-	if ((error = snd_card_miro_detect(card, miro)) < 0) {
-		snd_card_free(card);
-		snd_printk(KERN_ERR "unable to detect OPTi9xx chip\n");
-		return -ENODEV;
-	}
 
 	if (! miro->res_mc_base &&
 	    (miro->res_mc_base = request_region(miro->mc_base, miro->mc_base_size,
@@ -1341,7 +1333,8 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 
 	miro->pcm = pcm;
 
-	if ((error = snd_miro_mixer(miro)) < 0) {
+	error = snd_miro_mixer(card, miro);
+	if (error < 0) {
 		snd_card_free(card);
 		return error;
 	}

commit 67f2db24fbfdb63495d995d6fbbbe42980004ee0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 18 08:37:59 2009 +0100

    ALSA: opti-miro: Fix missing semicolon
    
    To fix a build error
      sound/isa/opti9xx/miro.c:1281: error: expected ';' before '}' token
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index b8170adeeff6..17761030affa 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1277,7 +1277,7 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 		if (mpu_port < 0) {
 			snd_card_free(card);
 			snd_printk(KERN_ERR "unable to find a free MPU401 port\n");
-			return -EBUSY
+			return -EBUSY;
 		}
 	}
 	if (miro->irq == SNDRV_AUTO_IRQ) {

commit b67cad932c4e45edca2f4da2ee4f46001ba17363
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Tue Nov 17 18:35:41 2009 +0100

    ALSA: opti-miro: use variables directly in the probe function
    
    Use the fm_port and mpu_port variables directly in a probe function.
    This completely eliminates a need to copy the fm_port value to
    the snd_miro structure.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 02e30d7c6a93..b8170adeeff6 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -118,8 +118,6 @@ struct snd_miro {
 	int dma1;
 	int dma2;
 
-	long fm_port;
-
 	long mpu_port;
 	int mpu_irq;
 
@@ -757,7 +755,6 @@ static int __devinit snd_miro_init(struct snd_miro *chip,
 	chip->irq = -1;
 	chip->dma1 = -1;
 	chip->dma2 = -1;
-	chip->fm_port = -1;
 	chip->mpu_port = -1;
 	chip->mpu_irq = -1;
 
@@ -1261,7 +1258,6 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 	}
 
 	miro->wss_base = port;
-	miro->fm_port = fm_port;
 	miro->mpu_port = mpu_port;
 	miro->irq = irq;
 	miro->mpu_irq = mpu_irq;
@@ -1276,11 +1272,12 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 		}
 	}
 
-	if (miro->mpu_port == SNDRV_AUTO_PORT) {
-		if ((miro->mpu_port = snd_legacy_find_free_ioport(possible_mpu_ports, 2)) < 0) {
+	if (mpu_port == SNDRV_AUTO_PORT) {
+		mpu_port = snd_legacy_find_free_ioport(possible_mpu_ports, 2);
+		if (mpu_port < 0) {
 			snd_card_free(card);
 			snd_printk(KERN_ERR "unable to find a free MPU401 port\n");
-			return -EBUSY;
+			return -EBUSY
 		}
 	}
 	if (miro->irq == SNDRV_AUTO_IRQ) {
@@ -1380,20 +1377,24 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 		card->shortname, miro->name, pcm->name, miro->wss_base + 4,
 		miro->irq, miro->dma1, miro->dma2);
 
-	if (miro->mpu_port <= 0 || miro->mpu_port == SNDRV_AUTO_PORT)
+	if (mpu_port <= 0 || mpu_port == SNDRV_AUTO_PORT)
 		rmidi = NULL;
-	else
-		if ((error = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
-				miro->mpu_port, 0, miro->mpu_irq, IRQF_DISABLED,
-				&rmidi)))
-			snd_printk(KERN_WARNING "no MPU-401 device at 0x%lx?\n", miro->mpu_port);
+	else {
+		error = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
+				mpu_port, 0, miro->mpu_irq, IRQF_DISABLED,
+				&rmidi);
+		if (error < 0)
+			snd_printk(KERN_WARNING "no MPU-401 device at 0x%lx?\n",
+				   mpu_port);
+	}
 
-	if (miro->fm_port > 0 && miro->fm_port != SNDRV_AUTO_PORT) {
+	if (fm_port > 0 && fm_port != SNDRV_AUTO_PORT) {
 		struct snd_opl3 *opl3 = NULL;
 		struct snd_opl4 *opl4;
-		if (snd_opl4_create(card, miro->fm_port, miro->fm_port - 8, 
+		if (snd_opl4_create(card, fm_port, fm_port - 8,
 				    2, &opl3, &opl4) < 0)
-			snd_printk(KERN_WARNING "no OPL4 device at 0x%lx\n", miro->fm_port);
+			snd_printk(KERN_WARNING "no OPL4 device at 0x%lx\n",
+				   fm_port);
 	}
 
 	if ((error = snd_set_aci_init_values(miro)) < 0) {

commit c95eadd2f1afd2ba643e85a8dfc9079a3f03ae47
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:43:35 2008 +0100

    ALSA: Convert to snd_card_create() in sound/isa/*
    
    Convert from snd_card_new() to the new snd_card_create() function.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 440755cc0013..02e30d7c6a93 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1228,9 +1228,10 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 	struct snd_pcm *pcm;
 	struct snd_rawmidi *rmidi;
 
-	if (!(card = snd_card_new(index, id, THIS_MODULE,
-				  sizeof(struct snd_miro))))
-		return -ENOMEM;
+	error = snd_card_create(index, id, THIS_MODULE,
+				sizeof(struct snd_miro), &card);
+	if (error < 0)
+		return error;
 
 	card->private_free = snd_card_miro_free;
 	miro = card->private_data;

commit 622207dc31895b4e82c39100db8635d885c795e2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:11:45 2008 +0200

    ALSA: Kill snd_assert() in sound/isa/*
    
    Kill snd_assert() in sound/isa/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 4641daa7844d..440755cc0013 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -675,7 +675,8 @@ static int __devinit snd_miro_mixer(struct snd_miro *miro)
 	unsigned int idx;
 	int err;
 
-	snd_assert(miro != NULL && miro->card != NULL, return -EINVAL);
+	if (snd_BUG_ON(!miro || !miro->card))
+		return -EINVAL;
 
 	card = miro->card;
 

commit 7779f75f072784d3fccf721b8ec43107f93619a0
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Thu Jul 31 21:03:41 2008 +0200

    ALSA: wss_lib: rename cs4321_foo to wss_foo
    
    Rename functions and structures from the former
    cs4321_lib to names more corresponding with the
    new name: wss_lib.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Reviewed-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 59f7c55baf30..4641daa7844d 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1221,7 +1221,7 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 
 	int error;
 	struct snd_miro *miro;
-	struct snd_cs4231 *codec;
+	struct snd_wss *codec;
 	struct snd_timer *timer;
 	struct snd_card *card;
 	struct snd_pcm *pcm;
@@ -1310,29 +1310,32 @@ static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 		}
 	}
 
-	if ((error = snd_miro_configure(miro))) {
+	error = snd_miro_configure(miro);
+	if (error) {
 		snd_card_free(card);
 		return error;
 	}
 
-	if ((error = snd_cs4231_create(card, miro->wss_base + 4, -1,
-				       miro->irq, miro->dma1, miro->dma2,
-				       CS4231_HW_AD1845,
-				       0,
-				       &codec)) < 0) {
+	error = snd_wss_create(card, miro->wss_base + 4, -1,
+				miro->irq, miro->dma1, miro->dma2,
+				WSS_HW_AD1845, 0, &codec);
+	if (error < 0) {
 		snd_card_free(card);
 		return error;
 	}
 
-	if ((error = snd_cs4231_pcm(codec, 0, &pcm)) < 0) {
+	error = snd_wss_pcm(codec, 0, &pcm);
+	if (error < 0)  {
 		snd_card_free(card);
 		return error;
 	}
-	if ((error = snd_cs4231_mixer(codec)) < 0) {
+	error = snd_wss_mixer(codec);
+	if (error < 0) {
 		snd_card_free(card);
 		return error;
 	}
-	if ((error = snd_cs4231_timer(codec, 0, &timer)) < 0) {
+	error = snd_wss_timer(codec, 0, &timer);
+	if (error < 0) {
 		snd_card_free(card);
 		return error;
 	}

commit 61ef19d7e771ce021edb0dff0da134b6d688d4aa
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Thu Jul 31 21:02:42 2008 +0200

    ALSA: wss_lib: rename cs4231.h into wss.h
    
    Rename file include/sound/cs4231.h
    into include/sound/wss.h
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Reviewed-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 2a1e2f5d12c2..59f7c55baf30 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -32,7 +32,7 @@
 #include <asm/io.h>
 #include <asm/dma.h>
 #include <sound/core.h>
-#include <sound/cs4231.h>
+#include <sound/wss.h>
 #include <sound/mpu401.h>
 #include <sound/opl4.h>
 #include <sound/control.h>

commit 9478bc3bed1e15208f8041b44d45505cb93e6cc8
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed Jan 23 11:52:38 2008 +0100

    [ALSA] fix opti9xx/miro section mismatch
    
    snd_opti93x_mixer() is only called by __devinit snd_opti93x_probe(),
    so the former can also be __devinit.
    snd_miro_mixer() is only called by __devinit snd_miro_probe(),
    so the former can also be __devinit.
    sound/isa/opti9xx/opti92x-ad1848.c:
    WARNING: vmlinux.o(.text+0xf91cd7): Section mismatch: reference to .init.data:snd_opti93x_controls (between 'snd_opti93x_mixer' and 'snd_card_opti9xx_free')
    WARNING: vmlinux.o(.text+0xf91d66): Section mismatch: reference to .init.data:snd_miro_controls (between 'snd_opti93x_mixer' and 'snd_card_opti9xx_free')
    opti9xx/miro.c:
    WARNING: vmlinux.o(.text+0xf926c2): Section mismatch: reference to .init.data:snd_miro_controls (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf926e5): Section mismatch: reference to .init.data:snd_miro_eq_controls (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf926f9): Section mismatch: reference to .init.data:snd_miro_line_control (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf92716): Section mismatch: reference to .init.data:snd_miro_amp_control (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf9273e): Section mismatch: reference to .init.data:snd_miro_preamp_control (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf92764): Section mismatch: reference to .init.data:snd_miro_capture_control (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf92783): Section mismatch: reference to .init.data:snd_miro_radio_control (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf9279a): Section mismatch: reference to .init.data:snd_miro_eq_controls (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    WARNING: vmlinux.o(.text+0xf927b9): Section mismatch: reference to .init.data:snd_miro_radio_control (between 'snd_miro_mixer' and 'snd_legacy_find_free_ioport')
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index b18d14f29db4..2a1e2f5d12c2 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -669,7 +669,7 @@ static int __devinit snd_set_aci_init_values(struct snd_miro *miro)
 	return 0;
 }
 
-static int snd_miro_mixer(struct snd_miro *miro)
+static int __devinit snd_miro_mixer(struct snd_miro *miro)
 {
 	struct snd_card *card;
 	unsigned int idx;

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index c2baf4cfb958..b18d14f29db4 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -22,7 +22,6 @@
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/err.h>
 #include <linux/isa.h>

commit 3b892467786410f26dffc2c7bccd3ea445604037
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 15 16:17:24 2007 +0100

    [ALSA] Check value range in ctl callbacks
    
    Check the value ranges in ctl put callbacks properly (in the rest drivers).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index d295936611f8..c2baf4cfb958 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -483,6 +483,10 @@ static int snd_miro_put_double(struct snd_kcontrol *kcontrol,
 
 		/* equalizer elements */
 
+		if (left < -0x7f || left > 0x7f ||
+		    right < -0x7f || right > 0x7f)
+			return -EINVAL;
+
 		if (left_old > 0x80) 
 			left_old = 0x80 - left_old;
 		if (right_old > 0x80) 
@@ -520,6 +524,10 @@ static int snd_miro_put_double(struct snd_kcontrol *kcontrol,
 
 		/* non-equalizer elements */
 
+		if (left < 0 || left > 0x20 ||
+		    right < 0 || right > 0x20)
+			return -EINVAL;
+
 		left_old = 0x20 - left_old;
 		right_old = 0x20 - right_old;
 

commit a5ce88909d3007caa7b65996a8f6784350beb2a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 23 15:42:26 2007 +0200

    [ALSA] Clean up with common snd_ctl_boolean_*_info callbacks
    
    Clean up codes using the new common snd_ctl_boolean_*_info() callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index cd29b30b362e..d295936611f8 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -242,14 +242,7 @@ static int aci_setvalue(struct snd_miro * miro, unsigned char index, int value)
  *  MIXER part
  */
 
-static int snd_miro_info_capture(struct snd_kcontrol *kcontrol,
-				 struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-
-	return 0;
-}
+#define snd_miro_info_capture	snd_ctl_boolean_mono_info
 
 static int snd_miro_get_capture(struct snd_kcontrol *kcontrol,
 				struct snd_ctl_elem_value *ucontrol)
@@ -344,14 +337,7 @@ static int snd_miro_put_preamp(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static int snd_miro_info_amp(struct snd_kcontrol *kcontrol,
-			     struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-
-	return 0;
-}
+#define snd_miro_info_amp	snd_ctl_boolean_mono_info
 
 static int snd_miro_get_amp(struct snd_kcontrol *kcontrol,
 			    struct snd_ctl_elem_value *ucontrol)

commit 83c51c0ab08f55468d8f5444ff2f70a36841a21f
Author: Rene Herman <rene.herman@gmail.com>
Date:   Tue Mar 20 11:33:46 2007 +0100

    [ALSA] isa_bus device/driver naming
    
    isa_bus: delete snd_ prefix from the (sysfs visible) device/driver names.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 33471bdbe269..cd29b30b362e 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -137,8 +137,6 @@ struct snd_miro {
 
 static void snd_miro_proc_init(struct snd_miro * miro);
 
-#define DRIVER_NAME "snd-miro"
-
 static char * snd_opti9xx_names[] = {
 	"unkown",
 	"82C928", "82C929",
@@ -1423,13 +1421,15 @@ static int __devexit snd_miro_remove(struct device *devptr, unsigned int dev)
 	return 0;
 }
 
+#define DEV_NAME "miro"
+
 static struct isa_driver snd_miro_driver = {
 	.match		= snd_miro_match,
 	.probe		= snd_miro_probe,
 	.remove		= __devexit_p(snd_miro_remove),
 	/* FIXME: suspend/resume */
 	.driver		= {
-		.name	= DRIVER_NAME
+		.name	= DEV_NAME
 	},
 };
 

commit 5e24c1c1c496c4603395d6e9cc320f85008fc891
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 22 12:50:54 2007 +0100

    [ALSA] Port the rest of ALSA ISA drivers to isa_driver
    
    Port the rest of ALSA ISA drivers to use isa_driver framework
    instead of platform_driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 1dd98375ac85..33471bdbe269 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -25,7 +25,7 @@
 #include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/err.h>
-#include <linux/platform_device.h>
+#include <linux/isa.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/ioport.h>
@@ -139,8 +139,6 @@ static void snd_miro_proc_init(struct snd_miro * miro);
 
 #define DRIVER_NAME "snd-miro"
 
-static struct platform_device *device;
-
 static char * snd_opti9xx_names[] = {
 	"unkown",
 	"82C928", "82C929",
@@ -558,7 +556,7 @@ static int snd_miro_put_double(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_miro_controls[] = {
+static struct snd_kcontrol_new snd_miro_controls[] __devinitdata = {
 MIRO_DOUBLE("Master Playback Volume", 0, ACI_GET_MASTER, ACI_SET_MASTER),
 MIRO_DOUBLE("Mic Playback Volume", 1, ACI_GET_MIC, ACI_SET_MIC),
 MIRO_DOUBLE("Line Playback Volume", 1, ACI_GET_LINE, ACI_SET_LINE),
@@ -570,7 +568,7 @@ MIRO_DOUBLE("Aux Playback Volume", 2, ACI_GET_LINE2, ACI_SET_LINE2),
 
 /* Equalizer with seven bands (only PCM20) 
    from -12dB up to +12dB on each band */
-static struct snd_kcontrol_new snd_miro_eq_controls[] = {
+static struct snd_kcontrol_new snd_miro_eq_controls[] __devinitdata = {
 MIRO_DOUBLE("Tone Control - 28 Hz", 0, ACI_GET_EQ1, ACI_SET_EQ1),
 MIRO_DOUBLE("Tone Control - 160 Hz", 0, ACI_GET_EQ2, ACI_SET_EQ2),
 MIRO_DOUBLE("Tone Control - 400 Hz", 0, ACI_GET_EQ3, ACI_SET_EQ3),
@@ -580,15 +578,15 @@ MIRO_DOUBLE("Tone Control - 6.3 kHz", 0, ACI_GET_EQ6, ACI_SET_EQ6),
 MIRO_DOUBLE("Tone Control - 16 kHz", 0, ACI_GET_EQ7, ACI_SET_EQ7),
 };
 
-static struct snd_kcontrol_new snd_miro_radio_control[] = {
+static struct snd_kcontrol_new snd_miro_radio_control[] __devinitdata = {
 MIRO_DOUBLE("Radio Playback Volume", 0, ACI_GET_LINE1, ACI_SET_LINE1),
 };
 
-static struct snd_kcontrol_new snd_miro_line_control[] = {
+static struct snd_kcontrol_new snd_miro_line_control[] __devinitdata = {
 MIRO_DOUBLE("Line Playback Volume", 2, ACI_GET_LINE1, ACI_SET_LINE1),
 };
 
-static struct snd_kcontrol_new snd_miro_preamp_control[] = {
+static struct snd_kcontrol_new snd_miro_preamp_control[] __devinitdata = {
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Mic Boost",
@@ -598,7 +596,7 @@ static struct snd_kcontrol_new snd_miro_preamp_control[] = {
 	.put = snd_miro_put_preamp,
 }};
 
-static struct snd_kcontrol_new snd_miro_amp_control[] = {
+static struct snd_kcontrol_new snd_miro_amp_control[] __devinitdata = {
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Line Boost",
@@ -608,7 +606,7 @@ static struct snd_kcontrol_new snd_miro_amp_control[] = {
 	.put = snd_miro_put_amp,
 }};
 
-static struct snd_kcontrol_new snd_miro_capture_control[] = {
+static struct snd_kcontrol_new snd_miro_capture_control[] __devinitdata = {
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "PCM Capture Switch",
@@ -618,7 +616,7 @@ static struct snd_kcontrol_new snd_miro_capture_control[] = {
 	.put = snd_miro_put_capture,
 }};
 
-static unsigned char aci_init_values[][2] __initdata = {
+static unsigned char aci_init_values[][2] __devinitdata = {
 	{ ACI_SET_MUTE, 0x00 },
 	{ ACI_SET_POWERAMP, 0x00 },
 	{ ACI_SET_PREAMP, 0x00 },
@@ -641,7 +639,7 @@ static unsigned char aci_init_values[][2] __initdata = {
 	{ ACI_SET_MASTER + 1, 0x20 },
 };
 
-static int __init snd_set_aci_init_values(struct snd_miro *miro)
+static int __devinit snd_set_aci_init_values(struct snd_miro *miro)
 {
 	int idx, error;
 
@@ -751,7 +749,8 @@ static long snd_legacy_find_free_ioport(long *port_table, long size)
 	return -1;
 }
 
-static int __init snd_miro_init(struct snd_miro *chip, unsigned short hardware)
+static int __devinit snd_miro_init(struct snd_miro *chip,
+				   unsigned short hardware)
 {
 	static int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};
 
@@ -962,7 +961,7 @@ static void snd_miro_proc_read(struct snd_info_entry * entry,
 	snd_iprintf(buffer, "  preamp  : 0x%x\n", miro->aci_preamp);
 }
 
-static void __init snd_miro_proc_init(struct snd_miro * miro)
+static void __devinit snd_miro_proc_init(struct snd_miro * miro)
 {
 	struct snd_info_entry *entry;
 
@@ -974,7 +973,7 @@ static void __init snd_miro_proc_init(struct snd_miro * miro)
  *  Init
  */
 
-static int __init snd_miro_configure(struct snd_miro *chip)
+static int __devinit snd_miro_configure(struct snd_miro *chip)
 {
 	unsigned char wss_base_bits;
 	unsigned char irq_bits;
@@ -1131,7 +1130,8 @@ static int __init snd_miro_configure(struct snd_miro *chip)
 	return 0;
 }
 
-static int __init snd_card_miro_detect(struct snd_card *card, struct snd_miro *chip)
+static int __devinit snd_card_miro_detect(struct snd_card *card,
+					  struct snd_miro *chip)
 {
 	int i, err;
 	unsigned char value;
@@ -1157,7 +1157,8 @@ static int __init snd_card_miro_detect(struct snd_card *card, struct snd_miro *c
 	return -ENODEV;
 }
 
-static int __init snd_card_miro_aci_detect(struct snd_card *card, struct snd_miro * miro)
+static int __devinit snd_card_miro_aci_detect(struct snd_card *card,
+					      struct snd_miro * miro)
 {
 	unsigned char regval;
 	int i;
@@ -1213,7 +1214,12 @@ static void snd_card_miro_free(struct snd_card *card)
 	release_and_free_resource(miro->res_mc_base);
 }
 
-static int __init snd_miro_probe(struct platform_device *devptr)
+static int __devinit snd_miro_match(struct device *devptr, unsigned int n)
+{
+	return 1;
+}
+
+static int __devinit snd_miro_probe(struct device *devptr, unsigned int n)
 {
 	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
 	static long possible_mpu_ports[] = {0x330, 0x300, 0x310, 0x320, -1};
@@ -1399,25 +1405,26 @@ static int __init snd_miro_probe(struct platform_device *devptr)
                 return error;
 	}
 
-	snd_card_set_dev(card, &devptr->dev);
+	snd_card_set_dev(card, devptr);
 
 	if ((error = snd_card_register(card))) {
 		snd_card_free(card);
 		return error;
 	}
 
-	platform_set_drvdata(devptr, card);
+	dev_set_drvdata(devptr, card);
 	return 0;
 }
 
-static int __devexit snd_miro_remove(struct platform_device *devptr)
+static int __devexit snd_miro_remove(struct device *devptr, unsigned int dev)
 {
-	snd_card_free(platform_get_drvdata(devptr));
-	platform_set_drvdata(devptr, NULL);
+	snd_card_free(dev_get_drvdata(devptr));
+	dev_set_drvdata(devptr, NULL);
 	return 0;
 }
 
-static struct platform_driver snd_miro_driver = {
+static struct isa_driver snd_miro_driver = {
+	.match		= snd_miro_match,
 	.probe		= snd_miro_probe,
 	.remove		= __devexit_p(snd_miro_remove),
 	/* FIXME: suspend/resume */
@@ -1428,27 +1435,12 @@ static struct platform_driver snd_miro_driver = {
 
 static int __init alsa_card_miro_init(void)
 {
-	int error;
-
-	if ((error = platform_driver_register(&snd_miro_driver)) < 0)
-		return error;
-	device = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0);
-	if (! IS_ERR(device)) {
-		if (platform_get_drvdata(device))
-			return 0;
-		platform_device_unregister(device);
-	}
-#ifdef MODULE
-	printk(KERN_ERR "no miro soundcard found\n");
-#endif
-	platform_driver_unregister(&snd_miro_driver);
-	return PTR_ERR(device);
+	return isa_register_driver(&snd_miro_driver, 1);
 }
 
 static void __exit alsa_card_miro_exit(void)
 {
-	platform_device_unregister(device);
-	platform_driver_unregister(&snd_miro_driver);
+	isa_unregister_driver(&snd_miro_driver);
 }
 
 module_init(alsa_card_miro_init)

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 283817f2de75..1dd98375ac85 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1382,7 +1382,7 @@ static int __init snd_miro_probe(struct platform_device *devptr)
 		rmidi = NULL;
 	else
 		if ((error = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
-				miro->mpu_port, 0, miro->mpu_irq, SA_INTERRUPT,
+				miro->mpu_port, 0, miro->mpu_irq, IRQF_DISABLED,
 				&rmidi)))
 			snd_printk(KERN_WARNING "no MPU-401 device at 0x%lx?\n", miro->mpu_port);
 

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index e6bfcf74c1c1..283817f2de75 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -967,7 +967,7 @@ static void __init snd_miro_proc_init(struct snd_miro * miro)
 	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(miro->card, "miro", &entry))
-		snd_info_set_text_ops(entry, miro, 1024, snd_miro_proc_read);
+		snd_info_set_text_ops(entry, miro, snd_miro_proc_read);
 }
 
 /*

commit c128b82cf4095bb64aec435cf58d67fb78272f2f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 18 15:01:23 2006 +0200

    [ALSA] Fix double free in error path of miro driver
    
    Fixed the double free in error path of miro driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 83d64bc07ff0..e6bfcf74c1c1 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1179,20 +1179,17 @@ static int __init snd_card_miro_aci_detect(struct snd_card *card, struct snd_mir
         /* force ACI into a known state */
 	for (i = 0; i < 3; i++)
 		if (aci_cmd(miro, ACI_ERROR_OP, -1, -1) < 0) {
-			snd_card_free(card);
 			snd_printk(KERN_ERR "can't force aci into known state.\n");
 			return -ENXIO;
 		}
 
 	if ((miro->aci_vendor=aci_cmd(miro, ACI_READ_IDCODE, -1, -1)) < 0 ||
 	    (miro->aci_product=aci_cmd(miro, ACI_READ_IDCODE, -1, -1)) < 0) {
-		snd_card_free(card);
 		snd_printk(KERN_ERR "can't read aci id on 0x%lx.\n", miro->aci_port);
 		return -ENXIO;
 	}
 
 	if ((miro->aci_version=aci_cmd(miro, ACI_READ_VERSION, -1, -1)) < 0) {
-		snd_card_free(card);
 		snd_printk(KERN_ERR "can't read aci version on 0x%lx.\n", 
 			   miro->aci_port);
 		return -ENXIO;

commit dcccdd938ef0c5d96145957217b814b14bd46cdc
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Tue Apr 11 14:09:37 2006 +0200

    [ALSA] unregister platform device again if probe was unsuccessful
    
    Unregister the platform device again if the probe was unsuccessful.
    
    This restores the behaviour of not loading the driver on probe() failure.
    
    Signed-off-by: Rene Herman <rene.herman@keyaccess.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 09384d03dc31..83d64bc07ff0 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -1436,8 +1436,11 @@ static int __init alsa_card_miro_init(void)
 	if ((error = platform_driver_register(&snd_miro_driver)) < 0)
 		return error;
 	device = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0);
-	if (! IS_ERR(device))
-		return 0;
+	if (! IS_ERR(device)) {
+		if (platform_get_drvdata(device))
+			return 0;
+		platform_device_unregister(device);
+	}
 #ifdef MODULE
 	printk(KERN_ERR "no miro soundcard found\n");
 #endif

commit 10d150e186d069cc7e2075c4823049949933777c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 27 13:42:39 2006 +0200

    [ALSA] Remove obsolete kfree_nocheck call
    
    Fixed the compilation, removing obsolete kfree_nocheck() call
    for memory debugging.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
index 49ba334c0d24..09384d03dc31 100644
--- a/sound/isa/opti9xx/miro.c
+++ b/sound/isa/opti9xx/miro.c
@@ -743,8 +743,7 @@ static long snd_legacy_find_free_ioport(long *port_table, long size)
 		struct resource *res;
 		if ((res = request_region(*port_table, size, 
 					  "ALSA test")) != NULL) {
-			release_resource(res);
-			kfree_nocheck(res);
+			release_and_free_resource(res);
 			return *port_table;
 		}
 		port_table++;
@@ -1150,8 +1149,7 @@ static int __init snd_card_miro_detect(struct snd_card *card, struct snd_miro *c
 			if (value == snd_miro_read(chip, OPTi9XX_MC_REG(1)))
 				return 1;
 
-		release_resource(chip->res_mc_base);
-		kfree_nocheck(chip->res_mc_base);
+		release_and_free_resource(chip->res_mc_base);
 		chip->res_mc_base = NULL;
 
 	}

commit 1841f613fd2e73f09d3fa2beeccf2f8d978ec2db
Author: Martin Langer <martin-langer@gmx.de>
Date:   Mon Mar 27 12:41:01 2006 +0200

    [ALSA] Add snd-miro driver
    
    Added snd-miro driver for miroSOUND PCM by Martin Langer.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/opti9xx/miro.c b/sound/isa/opti9xx/miro.c
new file mode 100644
index 000000000000..49ba334c0d24
--- /dev/null
+++ b/sound/isa/opti9xx/miro.c
@@ -0,0 +1,1457 @@
+/*
+ *   ALSA soundcard driver for Miro miroSOUND PCM1 pro
+ *                                  miroSOUND PCM12
+ *                                  miroSOUND PCM20 Radio
+ *
+ *   Copyright (C) 2004-2005 Martin Langer <martin-langer@gmx.de>
+ *
+ *   Based on OSS ACI and ALSA OPTi9xx drivers
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/moduleparam.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <sound/core.h>
+#include <sound/cs4231.h>
+#include <sound/mpu401.h>
+#include <sound/opl4.h>
+#include <sound/control.h>
+#include <sound/info.h>
+#define SNDRV_LEGACY_FIND_FREE_IRQ
+#define SNDRV_LEGACY_FIND_FREE_DMA
+#include <sound/initval.h>
+#include "miro.h"
+
+MODULE_AUTHOR("Martin Langer <martin-langer@gmx.de>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Miro miroSOUND PCM1 pro, PCM12, PCM20 Radio");
+MODULE_SUPPORTED_DEVICE("{{Miro,miroSOUND PCM1 pro}, "
+			"{Miro,miroSOUND PCM12}, "
+			"{Miro,miroSOUND PCM20 Radio}}");
+
+static int index = SNDRV_DEFAULT_IDX1;		/* Index 0-MAX */
+static char *id = SNDRV_DEFAULT_STR1;		/* ID for this card */
+static long port = SNDRV_DEFAULT_PORT1; 	/* 0x530,0xe80,0xf40,0x604 */
+static long mpu_port = SNDRV_DEFAULT_PORT1;	/* 0x300,0x310,0x320,0x330 */
+static long fm_port = SNDRV_DEFAULT_PORT1;	/* 0x388 */
+static int irq = SNDRV_DEFAULT_IRQ1;		/* 5,7,9,10,11 */
+static int mpu_irq = SNDRV_DEFAULT_IRQ1;	/* 5,7,9,10 */
+static int dma1 = SNDRV_DEFAULT_DMA1;		/* 0,1,3 */
+static int dma2 = SNDRV_DEFAULT_DMA1;		/* 0,1,3 */
+static int wss;
+static int ide;
+
+module_param(index, int, 0444);
+MODULE_PARM_DESC(index, "Index value for miro soundcard.");
+module_param(id, charp, 0444);
+MODULE_PARM_DESC(id, "ID string for miro soundcard.");
+module_param(port, long, 0444);
+MODULE_PARM_DESC(port, "WSS port # for miro driver.");
+module_param(mpu_port, long, 0444);
+MODULE_PARM_DESC(mpu_port, "MPU-401 port # for miro driver.");
+module_param(fm_port, long, 0444);
+MODULE_PARM_DESC(fm_port, "FM Port # for miro driver.");
+module_param(irq, int, 0444);
+MODULE_PARM_DESC(irq, "WSS irq # for miro driver.");
+module_param(mpu_irq, int, 0444);
+MODULE_PARM_DESC(mpu_irq, "MPU-401 irq # for miro driver.");
+module_param(dma1, int, 0444);
+MODULE_PARM_DESC(dma1, "1st dma # for miro driver.");
+module_param(dma2, int, 0444);
+MODULE_PARM_DESC(dma2, "2nd dma # for miro driver.");
+module_param(wss, int, 0444);
+MODULE_PARM_DESC(wss, "wss mode");
+module_param(ide, int, 0444);
+MODULE_PARM_DESC(ide, "enable ide port");
+
+#define OPTi9XX_HW_DETECT	0
+#define OPTi9XX_HW_82C928	1
+#define OPTi9XX_HW_82C929	2
+#define OPTi9XX_HW_82C924	3
+#define OPTi9XX_HW_82C925	4
+#define OPTi9XX_HW_82C930	5
+#define OPTi9XX_HW_82C931	6
+#define OPTi9XX_HW_82C933	7
+#define OPTi9XX_HW_LAST		OPTi9XX_HW_82C933
+
+#define OPTi9XX_MC_REG(n)	n
+
+
+struct snd_miro {
+	unsigned short hardware;
+	unsigned char password;
+	char name[7];
+
+	struct resource *res_mc_base;
+	struct resource *res_aci_port;
+
+	unsigned long mc_base;
+	unsigned long mc_base_size;
+	unsigned long pwd_reg;
+
+	spinlock_t lock;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+
+	long wss_base;
+	int irq;
+	int dma1;
+	int dma2;
+
+	long fm_port;
+
+	long mpu_port;
+	int mpu_irq;
+
+	unsigned long aci_port;
+	int aci_vendor;
+	int aci_product;
+	int aci_version;
+	int aci_amp;
+	int aci_preamp;
+	int aci_solomode;
+
+	struct mutex aci_mutex;
+};
+
+static void snd_miro_proc_init(struct snd_miro * miro);
+
+#define DRIVER_NAME "snd-miro"
+
+static struct platform_device *device;
+
+static char * snd_opti9xx_names[] = {
+	"unkown",
+	"82C928", "82C929",
+	"82C924", "82C925",
+	"82C930", "82C931", "82C933"
+};
+
+/* 
+ *  ACI control
+ */
+
+static int aci_busy_wait(struct snd_miro * miro)
+{
+	long timeout;
+	unsigned char byte;
+
+	for (timeout = 1; timeout <= ACI_MINTIME+30; timeout++) {
+		if (((byte=inb(miro->aci_port + ACI_REG_BUSY)) & 1) == 0) {
+			if (timeout >= ACI_MINTIME)
+				snd_printd("aci ready in round %ld.\n",
+					   timeout-ACI_MINTIME);
+			return byte;
+		}
+		if (timeout >= ACI_MINTIME) {
+			long out=10*HZ;
+			switch (timeout-ACI_MINTIME) {
+			case 0 ... 9:
+				out /= 10;
+			case 10 ... 19:
+				out /= 10;
+			case 20 ... 30:
+				out /= 10;
+			default:
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				schedule_timeout(out);
+				break;
+			}
+		}
+	}
+	snd_printk(KERN_ERR "aci_busy_wait() time out\n");
+	return -EBUSY;
+}
+
+static inline int aci_write(struct snd_miro * miro, unsigned char byte)
+{
+	if (aci_busy_wait(miro) >= 0) {
+		outb(byte, miro->aci_port + ACI_REG_COMMAND);
+		return 0;
+	} else {
+		snd_printk(KERN_ERR "aci busy, aci_write(0x%x) stopped.\n", byte);
+		return -EBUSY;
+	}
+}
+
+static inline int aci_read(struct snd_miro * miro)
+{
+	unsigned char byte;
+
+	if (aci_busy_wait(miro) >= 0) {
+		byte=inb(miro->aci_port + ACI_REG_STATUS);
+		return byte;
+	} else {
+		snd_printk(KERN_ERR "aci busy, aci_read() stopped.\n");
+		return -EBUSY;
+	}
+}
+
+static int aci_cmd(struct snd_miro * miro, int write1, int write2, int write3)
+{
+	int write[] = {write1, write2, write3};
+	int value, i;
+
+	if (mutex_lock_interruptible(&miro->aci_mutex))
+		return -EINTR;
+
+	for (i=0; i<3; i++) {
+		if (write[i]< 0 || write[i] > 255)
+			break;
+		else {
+			value = aci_write(miro, write[i]);
+			if (value < 0)
+				goto out;
+		}
+	}
+
+	value = aci_read(miro);
+
+out:	mutex_unlock(&miro->aci_mutex);
+	return value;
+}
+
+static int aci_getvalue(struct snd_miro * miro, unsigned char index)
+{
+	return aci_cmd(miro, ACI_STATUS, index, -1);
+}
+
+static int aci_setvalue(struct snd_miro * miro, unsigned char index, int value)
+{
+	return aci_cmd(miro, index, value, -1);
+}
+
+/*
+ *  MIXER part
+ */
+
+static int snd_miro_info_capture(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+
+	return 0;
+}
+
+static int snd_miro_get_capture(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
+	int value;
+
+	if ((value = aci_getvalue(miro, ACI_S_GENERAL)) < 0) {
+		snd_printk(KERN_ERR "snd_miro_get_capture() failed: %d\n", value);
+		return value;
+	}
+
+	ucontrol->value.integer.value[0] = value & 0x20;
+
+	return 0;
+}
+
+static int snd_miro_put_capture(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
+	int change, value, error;
+
+	value = !(ucontrol->value.integer.value[0]);
+
+	if ((error = aci_setvalue(miro, ACI_SET_SOLOMODE, value)) < 0) {
+		snd_printk(KERN_ERR "snd_miro_put_capture() failed: %d\n", error);
+		return error;
+	}
+
+	change = (value != miro->aci_solomode);
+	miro->aci_solomode = value;
+	
+	return change;
+}
+
+static int snd_miro_info_preamp(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 3;
+
+	return 0;
+}
+
+static int snd_miro_get_preamp(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
+	int value;
+
+	if (miro->aci_version <= 176) {
+
+		/* 
+		   OSS says it's not readable with versions < 176.
+		   But it doesn't work on my card,
+		   which is a PCM12 with aci_version = 176.
+		*/
+
+		ucontrol->value.integer.value[0] = miro->aci_preamp;
+		return 0;
+	}
+
+	if ((value = aci_getvalue(miro, ACI_GET_PREAMP)) < 0) {
+		snd_printk(KERN_ERR "snd_miro_get_preamp() failed: %d\n", value);
+		return value;
+	}
+	
+	ucontrol->value.integer.value[0] = value;
+
+	return 0;
+}
+
+static int snd_miro_put_preamp(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
+	int error, value, change;
+
+	value = ucontrol->value.integer.value[0];
+
+	if ((error = aci_setvalue(miro, ACI_SET_PREAMP, value)) < 0) {
+		snd_printk(KERN_ERR "snd_miro_put_preamp() failed: %d\n", error);
+		return error;
+	}
+
+	change = (value != miro->aci_preamp);
+	miro->aci_preamp = value;
+
+	return change;
+}
+
+static int snd_miro_info_amp(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+
+	return 0;
+}
+
+static int snd_miro_get_amp(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
+	ucontrol->value.integer.value[0] = miro->aci_amp;
+
+	return 0;
+}
+
+static int snd_miro_put_amp(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
+	int error, value, change;
+
+	value = ucontrol->value.integer.value[0];
+
+	if ((error = aci_setvalue(miro, ACI_SET_POWERAMP, value)) < 0) {
+		snd_printk(KERN_ERR "snd_miro_put_amp() to %d failed: %d\n", value, error);
+		return error;
+	}
+
+	change = (value != miro->aci_amp);
+	miro->aci_amp = value;
+
+	return change;
+}
+
+#define MIRO_DOUBLE(ctl_name, ctl_index, get_right_reg, set_right_reg) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .name = ctl_name, \
+  .index = ctl_index, \
+  .info = snd_miro_info_double, \
+  .get = snd_miro_get_double, \
+  .put = snd_miro_put_double, \
+  .private_value = get_right_reg | (set_right_reg << 8) \
+}
+
+static int snd_miro_info_double(struct snd_kcontrol *kcontrol, 
+				struct snd_ctl_elem_info *uinfo)
+{
+	int reg = kcontrol->private_value & 0xff;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+
+	if ((reg >= ACI_GET_EQ1) && (reg <= ACI_GET_EQ7)) {
+
+		/* equalizer elements */
+
+		uinfo->value.integer.min = - 0x7f;
+		uinfo->value.integer.max = 0x7f;
+	} else {
+
+		/* non-equalizer elements */
+
+		uinfo->value.integer.min = 0;
+		uinfo->value.integer.max = 0x20;
+	}
+
+	return 0;
+}
+
+static int snd_miro_get_double(struct snd_kcontrol *kcontrol, 
+			       struct snd_ctl_elem_value *uinfo)
+{
+	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
+	int left_val, right_val;
+
+	int right_reg = kcontrol->private_value & 0xff;
+	int left_reg = right_reg + 1;
+
+	if ((right_val = aci_getvalue(miro, right_reg)) < 0) {
+		snd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", right_reg, right_val);
+		return right_val;
+	}
+
+	if ((left_val = aci_getvalue(miro, left_reg)) < 0) {
+		snd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", left_reg, left_val);
+		return left_val;
+	}
+
+	if ((right_reg >= ACI_GET_EQ1) && (right_reg <= ACI_GET_EQ7)) {
+
+		/* equalizer elements */
+
+		if (left_val < 0x80) {
+			uinfo->value.integer.value[0] = left_val;
+		} else {
+			uinfo->value.integer.value[0] = 0x80 - left_val;
+		}
+
+		if (right_val < 0x80) {
+			uinfo->value.integer.value[1] = right_val;
+		} else {
+			uinfo->value.integer.value[1] = 0x80 - right_val;
+		}
+
+	} else {
+
+		/* non-equalizer elements */
+
+		uinfo->value.integer.value[0] = 0x20 - left_val;
+		uinfo->value.integer.value[1] = 0x20 - right_val;
+	}
+
+	return 0;
+}
+
+static int snd_miro_put_double(struct snd_kcontrol *kcontrol, 
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_miro *miro = snd_kcontrol_chip(kcontrol);
+	int left, right, left_old, right_old;
+	int setreg_left, setreg_right, getreg_left, getreg_right;
+	int change, error;
+
+	left = ucontrol->value.integer.value[0];
+	right = ucontrol->value.integer.value[1];
+
+	setreg_right = (kcontrol->private_value >> 8) & 0xff;
+	if (setreg_right == ACI_SET_MASTER) {
+		setreg_left = setreg_right + 1;
+	} else {
+		setreg_left = setreg_right + 8;
+	}
+
+	getreg_right = kcontrol->private_value & 0xff;
+	getreg_left = getreg_right + 1;
+
+	if ((left_old = aci_getvalue(miro, getreg_left)) < 0) {
+		snd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", getreg_left, left_old);
+		return left_old;
+	}
+
+	if ((right_old = aci_getvalue(miro, getreg_right)) < 0) {
+		snd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", getreg_right, right_old);
+		return right_old;
+	}
+
+	if ((getreg_right >= ACI_GET_EQ1) && (getreg_right <= ACI_GET_EQ7)) {
+
+		/* equalizer elements */
+
+		if (left_old > 0x80) 
+			left_old = 0x80 - left_old;
+		if (right_old > 0x80) 
+			right_old = 0x80 - right_old;
+
+		if (left >= 0) {
+			if ((error = aci_setvalue(miro, setreg_left, left)) < 0) {
+				snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
+					   left, error);
+				return error;
+			}
+		} else {
+			if ((error = aci_setvalue(miro, setreg_left, 0x80 - left)) < 0) {
+				snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
+					   0x80 - left, error);
+				return error;
+			}
+		}
+
+		if (right >= 0) {
+			if ((error = aci_setvalue(miro, setreg_right, right)) < 0) {
+				snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
+					   right, error);
+				return error;
+			}
+		} else {
+			if ((error = aci_setvalue(miro, setreg_right, 0x80 - right)) < 0) {
+				snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
+					   0x80 - right, error);
+				return error;
+			}
+		}
+
+	} else {
+
+		/* non-equalizer elements */
+
+		left_old = 0x20 - left_old;
+		right_old = 0x20 - right_old;
+
+		if ((error = aci_setvalue(miro, setreg_left, 0x20 - left)) < 0) {
+			snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
+				   0x20 - left, error);
+			return error;
+		}
+		if ((error = aci_setvalue(miro, setreg_right, 0x20 - right)) < 0) {
+			snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",
+				   0x20 - right, error);
+			return error;
+		}
+	}
+
+	change = (left != left_old) || (right != right_old);
+
+	return change;
+}
+
+static struct snd_kcontrol_new snd_miro_controls[] = {
+MIRO_DOUBLE("Master Playback Volume", 0, ACI_GET_MASTER, ACI_SET_MASTER),
+MIRO_DOUBLE("Mic Playback Volume", 1, ACI_GET_MIC, ACI_SET_MIC),
+MIRO_DOUBLE("Line Playback Volume", 1, ACI_GET_LINE, ACI_SET_LINE),
+MIRO_DOUBLE("CD Playback Volume", 0, ACI_GET_CD, ACI_SET_CD),
+MIRO_DOUBLE("Synth Playback Volume", 0, ACI_GET_SYNTH, ACI_SET_SYNTH),
+MIRO_DOUBLE("PCM Playback Volume", 1, ACI_GET_PCM, ACI_SET_PCM),
+MIRO_DOUBLE("Aux Playback Volume", 2, ACI_GET_LINE2, ACI_SET_LINE2),
+};
+
+/* Equalizer with seven bands (only PCM20) 
+   from -12dB up to +12dB on each band */
+static struct snd_kcontrol_new snd_miro_eq_controls[] = {
+MIRO_DOUBLE("Tone Control - 28 Hz", 0, ACI_GET_EQ1, ACI_SET_EQ1),
+MIRO_DOUBLE("Tone Control - 160 Hz", 0, ACI_GET_EQ2, ACI_SET_EQ2),
+MIRO_DOUBLE("Tone Control - 400 Hz", 0, ACI_GET_EQ3, ACI_SET_EQ3),
+MIRO_DOUBLE("Tone Control - 1 kHz", 0, ACI_GET_EQ4, ACI_SET_EQ4),
+MIRO_DOUBLE("Tone Control - 2.5 kHz", 0, ACI_GET_EQ5, ACI_SET_EQ5),
+MIRO_DOUBLE("Tone Control - 6.3 kHz", 0, ACI_GET_EQ6, ACI_SET_EQ6),
+MIRO_DOUBLE("Tone Control - 16 kHz", 0, ACI_GET_EQ7, ACI_SET_EQ7),
+};
+
+static struct snd_kcontrol_new snd_miro_radio_control[] = {
+MIRO_DOUBLE("Radio Playback Volume", 0, ACI_GET_LINE1, ACI_SET_LINE1),
+};
+
+static struct snd_kcontrol_new snd_miro_line_control[] = {
+MIRO_DOUBLE("Line Playback Volume", 2, ACI_GET_LINE1, ACI_SET_LINE1),
+};
+
+static struct snd_kcontrol_new snd_miro_preamp_control[] = {
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Mic Boost",
+	.index = 1,
+	.info = snd_miro_info_preamp,
+	.get = snd_miro_get_preamp,
+	.put = snd_miro_put_preamp,
+}};
+
+static struct snd_kcontrol_new snd_miro_amp_control[] = {
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Line Boost",
+	.index = 0,
+	.info = snd_miro_info_amp,
+	.get = snd_miro_get_amp,
+	.put = snd_miro_put_amp,
+}};
+
+static struct snd_kcontrol_new snd_miro_capture_control[] = {
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "PCM Capture Switch",
+	.index = 0,
+	.info = snd_miro_info_capture,
+	.get = snd_miro_get_capture,
+	.put = snd_miro_put_capture,
+}};
+
+static unsigned char aci_init_values[][2] __initdata = {
+	{ ACI_SET_MUTE, 0x00 },
+	{ ACI_SET_POWERAMP, 0x00 },
+	{ ACI_SET_PREAMP, 0x00 },
+	{ ACI_SET_SOLOMODE, 0x00 },
+	{ ACI_SET_MIC + 0, 0x20 },
+	{ ACI_SET_MIC + 8, 0x20 },
+	{ ACI_SET_LINE + 0, 0x20 },
+	{ ACI_SET_LINE + 8, 0x20 },
+	{ ACI_SET_CD + 0, 0x20 },
+	{ ACI_SET_CD + 8, 0x20 },
+	{ ACI_SET_PCM + 0, 0x20 },
+	{ ACI_SET_PCM + 8, 0x20 },
+	{ ACI_SET_LINE1 + 0, 0x20 },
+	{ ACI_SET_LINE1 + 8, 0x20 },
+	{ ACI_SET_LINE2 + 0, 0x20 },
+	{ ACI_SET_LINE2 + 8, 0x20 },
+	{ ACI_SET_SYNTH + 0, 0x20 },
+	{ ACI_SET_SYNTH + 8, 0x20 },
+	{ ACI_SET_MASTER + 0, 0x20 },
+	{ ACI_SET_MASTER + 1, 0x20 },
+};
+
+static int __init snd_set_aci_init_values(struct snd_miro *miro)
+{
+	int idx, error;
+
+	/* enable WSS on PCM1 */
+
+	if ((miro->aci_product == 'A') && wss) {
+		if ((error = aci_setvalue(miro, ACI_SET_WSS, wss)) < 0) {
+			snd_printk(KERN_ERR "enabling WSS mode failed\n");
+			return error;
+		}
+	}
+
+	/* enable IDE port */
+
+	if (ide) {
+		if ((error = aci_setvalue(miro, ACI_SET_IDE, ide)) < 0) {
+			snd_printk(KERN_ERR "enabling IDE port failed\n");
+			return error;
+		}
+	}
+
+	/* set common aci values */
+
+	for (idx = 0; idx < ARRAY_SIZE(aci_init_values); idx++)
+                if ((error = aci_setvalue(miro, aci_init_values[idx][0], 
+					  aci_init_values[idx][1])) < 0) {
+			snd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n", 
+				   aci_init_values[idx][0], error);
+                        return error;
+                }
+
+	miro->aci_amp = 0;
+	miro->aci_preamp = 0;
+	miro->aci_solomode = 1;
+
+	return 0;
+}
+
+static int snd_miro_mixer(struct snd_miro *miro)
+{
+	struct snd_card *card;
+	unsigned int idx;
+	int err;
+
+	snd_assert(miro != NULL && miro->card != NULL, return -EINVAL);
+
+	card = miro->card;
+
+	switch (miro->hardware) {
+	case OPTi9XX_HW_82C924:
+		strcpy(card->mixername, "ACI & OPTi924");
+		break;
+	case OPTi9XX_HW_82C929:
+		strcpy(card->mixername, "ACI & OPTi929");
+		break;
+	default:
+		snd_BUG();
+		break;
+	}
+
+	for (idx = 0; idx < ARRAY_SIZE(snd_miro_controls); idx++) {
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_controls[idx], miro))) < 0)
+			return err;
+	}
+
+	if ((miro->aci_product == 'A') || (miro->aci_product == 'B')) {
+		/* PCM1/PCM12 with power-amp and Line 2 */
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_line_control[0], miro))) < 0)
+			return err;
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_amp_control[0], miro))) < 0)
+			return err;
+	}
+
+	if ((miro->aci_product == 'B') || (miro->aci_product == 'C')) {
+		/* PCM12/PCM20 with mic-preamp */
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_preamp_control[0], miro))) < 0)
+			return err;
+		if (miro->aci_version >= 176)
+			if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_capture_control[0], miro))) < 0)
+				return err;
+	}
+
+	if (miro->aci_product == 'C') {
+		/* PCM20 with radio and 7 band equalizer */
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_radio_control[0], miro))) < 0)
+			return err;
+		for (idx = 0; idx < ARRAY_SIZE(snd_miro_eq_controls); idx++) {
+			if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_eq_controls[idx], miro))) < 0)
+				return err;
+		}
+	}
+
+	return 0;
+}
+
+static long snd_legacy_find_free_ioport(long *port_table, long size)
+{
+	while (*port_table != -1) {
+		struct resource *res;
+		if ((res = request_region(*port_table, size, 
+					  "ALSA test")) != NULL) {
+			release_resource(res);
+			kfree_nocheck(res);
+			return *port_table;
+		}
+		port_table++;
+	}
+	return -1;
+}
+
+static int __init snd_miro_init(struct snd_miro *chip, unsigned short hardware)
+{
+	static int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};
+
+	chip->hardware = hardware;
+	strcpy(chip->name, snd_opti9xx_names[hardware]);
+
+	chip->mc_base_size = opti9xx_mc_size[hardware];  
+
+	spin_lock_init(&chip->lock);
+
+	chip->wss_base = -1;
+	chip->irq = -1;
+	chip->dma1 = -1;
+	chip->dma2 = -1;
+	chip->fm_port = -1;
+	chip->mpu_port = -1;
+	chip->mpu_irq = -1;
+
+	switch (hardware) {
+	case OPTi9XX_HW_82C929:
+		chip->mc_base = 0xf8c;
+		chip->password = 0xe3;
+		chip->pwd_reg = 3;
+		break;
+
+	case OPTi9XX_HW_82C924:
+		chip->mc_base = 0xf8c;
+		chip->password = 0xe5;
+		chip->pwd_reg = 3;
+		break;
+
+	default:
+		snd_printk(KERN_ERR "sorry, no support for %d\n", hardware);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static unsigned char snd_miro_read(struct snd_miro *chip,
+				   unsigned char reg)
+{
+	unsigned long flags;
+	unsigned char retval = 0xff;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	outb(chip->password, chip->mc_base + chip->pwd_reg);
+
+	switch (chip->hardware) {
+	case OPTi9XX_HW_82C924:
+		if (reg > 7) {
+			outb(reg, chip->mc_base + 8);
+			outb(chip->password, chip->mc_base + chip->pwd_reg);
+			retval = inb(chip->mc_base + 9);
+			break;
+		}
+
+	case OPTi9XX_HW_82C929:
+		retval = inb(chip->mc_base + reg);
+		break;
+
+	default:
+		snd_printk(KERN_ERR "sorry, no support for %d\n", chip->hardware);
+	}
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+	return retval;
+}
+
+static void snd_miro_write(struct snd_miro *chip, unsigned char reg,
+			   unsigned char value)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	outb(chip->password, chip->mc_base + chip->pwd_reg);
+
+	switch (chip->hardware) {
+	case OPTi9XX_HW_82C924:
+		if (reg > 7) {
+			outb(reg, chip->mc_base + 8);
+			outb(chip->password, chip->mc_base + chip->pwd_reg);
+			outb(value, chip->mc_base + 9);
+			break;
+		}
+
+	case OPTi9XX_HW_82C929:
+		outb(value, chip->mc_base + reg);
+		break;
+
+	default:
+		snd_printk(KERN_ERR "sorry, no support for %d\n", chip->hardware);
+	}
+
+	spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+
+#define snd_miro_write_mask(chip, reg, value, mask)	\
+	snd_miro_write(chip, reg,			\
+		(snd_miro_read(chip, reg) & ~(mask)) | ((value) & (mask)))
+
+/*
+ *  Proc Interface
+ */
+
+static void snd_miro_proc_read(struct snd_info_entry * entry, 
+			       struct snd_info_buffer *buffer)
+{
+	struct snd_miro *miro = (struct snd_miro *) entry->private_data;
+	char* model = "unknown";
+
+	/* miroSOUND PCM1 pro, early PCM12 */
+
+	if ((miro->hardware == OPTi9XX_HW_82C929) &&
+	    (miro->aci_vendor == 'm') && 
+	    (miro->aci_product == 'A')) {
+		switch(miro->aci_version) {
+		case 3:
+			model = "miroSOUND PCM1 pro";
+			break;
+		default:
+			model = "miroSOUND PCM1 pro / (early) PCM12";
+			break;
+		}
+	}
+
+	/* miroSOUND PCM12, PCM12 (Rev. E), PCM12 pnp */
+
+	if ((miro->hardware == OPTi9XX_HW_82C924) &&
+	    (miro->aci_vendor == 'm') && 
+	    (miro->aci_product == 'B')) {
+		switch(miro->aci_version) {
+		case 4:
+			model = "miroSOUND PCM12";
+			break;
+		case 176:
+			model = "miroSOUND PCM12 (Rev. E)";
+			break;
+		default:
+			model = "miroSOUND PCM12 / PCM12 pnp";
+			break;
+		}
+	}
+
+	/* miroSOUND PCM20 radio */
+
+	if ((miro->hardware == OPTi9XX_HW_82C924) &&
+	    (miro->aci_vendor == 'm') && 
+	    (miro->aci_product == 'C')) {
+		switch(miro->aci_version) {
+		case 7:
+			model = "miroSOUND PCM20 radio (Rev. E)";
+			break;
+		default:
+			model = "miroSOUND PCM20 radio";
+			break;
+		}
+	}
+
+	snd_iprintf(buffer, "\nGeneral information:\n");
+	snd_iprintf(buffer, "  model   : %s\n", model);
+	snd_iprintf(buffer, "  opti    : %s\n", miro->name);
+	snd_iprintf(buffer, "  codec   : %s\n", miro->pcm->name);
+	snd_iprintf(buffer, "  port    : 0x%lx\n", miro->wss_base);
+	snd_iprintf(buffer, "  irq     : %d\n", miro->irq);
+	snd_iprintf(buffer, "  dma     : %d,%d\n\n", miro->dma1, miro->dma2);
+
+	snd_iprintf(buffer, "MPU-401:\n");
+	snd_iprintf(buffer, "  port    : 0x%lx\n", miro->mpu_port);
+	snd_iprintf(buffer, "  irq     : %d\n\n", miro->mpu_irq);
+
+	snd_iprintf(buffer, "ACI information:\n");
+	snd_iprintf(buffer, "  vendor  : ");
+	switch(miro->aci_vendor) {
+	case 'm':
+		snd_iprintf(buffer, "Miro\n");
+		break;
+	default:
+		snd_iprintf(buffer, "unknown (0x%x)\n", miro->aci_vendor);
+		break;
+	}
+
+	snd_iprintf(buffer, "  product : ");
+	switch(miro->aci_product) {
+	case 'A':
+		snd_iprintf(buffer, "miroSOUND PCM1 pro / (early) PCM12\n");
+		break;
+	case 'B':
+		snd_iprintf(buffer, "miroSOUND PCM12\n");
+		break;
+	case 'C':
+		snd_iprintf(buffer, "miroSOUND PCM20 radio\n");
+		break;
+	default:
+		snd_iprintf(buffer, "unknown (0x%x)\n", miro->aci_product);
+		break;
+	}
+
+	snd_iprintf(buffer, "  firmware: %d (0x%x)\n",
+		    miro->aci_version, miro->aci_version);
+	snd_iprintf(buffer, "  port    : 0x%lx-0x%lx\n", 
+		    miro->aci_port, miro->aci_port+2);
+	snd_iprintf(buffer, "  wss     : 0x%x\n", wss);
+	snd_iprintf(buffer, "  ide     : 0x%x\n", ide);
+	snd_iprintf(buffer, "  solomode: 0x%x\n", miro->aci_solomode);
+	snd_iprintf(buffer, "  amp     : 0x%x\n", miro->aci_amp);
+	snd_iprintf(buffer, "  preamp  : 0x%x\n", miro->aci_preamp);
+}
+
+static void __init snd_miro_proc_init(struct snd_miro * miro)
+{
+	struct snd_info_entry *entry;
+
+	if (! snd_card_proc_new(miro->card, "miro", &entry))
+		snd_info_set_text_ops(entry, miro, 1024, snd_miro_proc_read);
+}
+
+/*
+ *  Init
+ */
+
+static int __init snd_miro_configure(struct snd_miro *chip)
+{
+	unsigned char wss_base_bits;
+	unsigned char irq_bits;
+	unsigned char dma_bits;
+	unsigned char mpu_port_bits = 0;
+	unsigned char mpu_irq_bits;
+	unsigned long flags;
+
+	switch (chip->hardware) {
+	case OPTi9XX_HW_82C924:
+		snd_miro_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x02);
+		snd_miro_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);
+		snd_miro_write_mask(chip, OPTi9XX_MC_REG(2), 0x20, 0x20); /* OPL4 */
+		snd_miro_write_mask(chip, OPTi9XX_MC_REG(3), 0xf0, 0xff);
+		snd_miro_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);
+		break;
+	case OPTi9XX_HW_82C929:
+		/* untested init commands for OPTi929 */
+		snd_miro_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);
+		snd_miro_write_mask(chip, OPTi9XX_MC_REG(2), 0x20, 0x20); /* OPL4 */
+		snd_miro_write_mask(chip, OPTi9XX_MC_REG(4), 0x00, 0x0c);
+		snd_miro_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);
+		break;
+	default:
+		snd_printk(KERN_ERR "chip %d not supported\n", chip->hardware);
+		return -EINVAL;
+	}
+
+	switch (chip->wss_base) {
+	case 0x530:
+		wss_base_bits = 0x00;
+		break;
+	case 0x604:
+		wss_base_bits = 0x03;
+		break;
+	case 0xe80:
+		wss_base_bits = 0x01;
+		break;
+	case 0xf40:
+		wss_base_bits = 0x02;
+		break;
+	default:
+		snd_printk(KERN_ERR "WSS port 0x%lx not valid\n", chip->wss_base);
+		goto __skip_base;
+	}
+	snd_miro_write_mask(chip, OPTi9XX_MC_REG(1), wss_base_bits << 4, 0x30);
+
+__skip_base:
+	switch (chip->irq) {
+	case 5:
+		irq_bits = 0x05;
+		break;
+	case 7:
+		irq_bits = 0x01;
+		break;
+	case 9:
+		irq_bits = 0x02;
+		break;
+	case 10:
+		irq_bits = 0x03;
+		break;
+	case 11:
+		irq_bits = 0x04;
+		break;
+	default:
+		snd_printk(KERN_ERR "WSS irq # %d not valid\n", chip->irq);
+		goto __skip_resources;
+	}
+
+	switch (chip->dma1) {
+	case 0:
+		dma_bits = 0x01;
+		break;
+	case 1:
+		dma_bits = 0x02;
+		break;
+	case 3:
+		dma_bits = 0x03;
+		break;
+	default:
+		snd_printk(KERN_ERR "WSS dma1 # %d not valid\n", chip->dma1);
+		goto __skip_resources;
+	}
+
+	if (chip->dma1 == chip->dma2) {
+		snd_printk(KERN_ERR "don't want to share dmas\n");
+		return -EBUSY;
+	}
+
+	switch (chip->dma2) {
+	case 0:
+	case 1:
+		break;
+	default:
+		snd_printk(KERN_ERR "WSS dma2 # %d not valid\n", chip->dma2);
+		goto __skip_resources;
+	}
+	dma_bits |= 0x04;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	outb(irq_bits << 3 | dma_bits, chip->wss_base);
+	spin_unlock_irqrestore(&chip->lock, flags);
+
+__skip_resources:
+	if (chip->hardware > OPTi9XX_HW_82C928) {
+		switch (chip->mpu_port) {
+		case 0:
+		case -1:
+			break;
+		case 0x300:
+			mpu_port_bits = 0x03;
+			break;
+		case 0x310:
+			mpu_port_bits = 0x02;
+			break;
+		case 0x320:
+			mpu_port_bits = 0x01;
+			break;
+		case 0x330:
+			mpu_port_bits = 0x00;
+			break;
+		default:
+			snd_printk(KERN_ERR "MPU-401 port 0x%lx not valid\n",
+				   chip->mpu_port);
+			goto __skip_mpu;
+		}
+
+		switch (chip->mpu_irq) {
+		case 5:
+			mpu_irq_bits = 0x02;
+			break;
+		case 7:
+			mpu_irq_bits = 0x03;
+			break;
+		case 9:
+			mpu_irq_bits = 0x00;
+			break;
+		case 10:
+			mpu_irq_bits = 0x01;
+			break;
+		default:
+			snd_printk(KERN_ERR "MPU-401 irq # %d not valid\n",
+				   chip->mpu_irq);
+			goto __skip_mpu;
+		}
+
+		snd_miro_write_mask(chip, OPTi9XX_MC_REG(6),
+			(chip->mpu_port <= 0) ? 0x00 :
+				0x80 | mpu_port_bits << 5 | mpu_irq_bits << 3,
+			0xf8);
+	}
+__skip_mpu:
+
+	return 0;
+}
+
+static int __init snd_card_miro_detect(struct snd_card *card, struct snd_miro *chip)
+{
+	int i, err;
+	unsigned char value;
+
+	for (i = OPTi9XX_HW_82C929; i <= OPTi9XX_HW_82C924; i++) {
+
+		if ((err = snd_miro_init(chip, i)) < 0)
+			return err;
+
+		if ((chip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size, "OPTi9xx MC")) == NULL)
+			continue;
+
+		value = snd_miro_read(chip, OPTi9XX_MC_REG(1));
+		if ((value != 0xff) && (value != inb(chip->mc_base + 1)))
+			if (value == snd_miro_read(chip, OPTi9XX_MC_REG(1)))
+				return 1;
+
+		release_resource(chip->res_mc_base);
+		kfree_nocheck(chip->res_mc_base);
+		chip->res_mc_base = NULL;
+
+	}
+
+	return -ENODEV;
+}
+
+static int __init snd_card_miro_aci_detect(struct snd_card *card, struct snd_miro * miro)
+{
+	unsigned char regval;
+	int i;
+
+	mutex_init(&miro->aci_mutex);
+
+	/* get ACI port from OPTi9xx MC 4 */
+
+	miro->mc_base = 0xf8c;
+	regval=inb(miro->mc_base + 4);
+	miro->aci_port = (regval & 0x10) ? 0x344: 0x354;
+
+	if ((miro->res_aci_port = request_region(miro->aci_port, 3, "miro aci")) == NULL) {
+		snd_printk(KERN_ERR "aci i/o area 0x%lx-0x%lx already used.\n", 
+			   miro->aci_port, miro->aci_port+2);
+		return -ENOMEM;
+	}
+
+        /* force ACI into a known state */
+	for (i = 0; i < 3; i++)
+		if (aci_cmd(miro, ACI_ERROR_OP, -1, -1) < 0) {
+			snd_card_free(card);
+			snd_printk(KERN_ERR "can't force aci into known state.\n");
+			return -ENXIO;
+		}
+
+	if ((miro->aci_vendor=aci_cmd(miro, ACI_READ_IDCODE, -1, -1)) < 0 ||
+	    (miro->aci_product=aci_cmd(miro, ACI_READ_IDCODE, -1, -1)) < 0) {
+		snd_card_free(card);
+		snd_printk(KERN_ERR "can't read aci id on 0x%lx.\n", miro->aci_port);
+		return -ENXIO;
+	}
+
+	if ((miro->aci_version=aci_cmd(miro, ACI_READ_VERSION, -1, -1)) < 0) {
+		snd_card_free(card);
+		snd_printk(KERN_ERR "can't read aci version on 0x%lx.\n", 
+			   miro->aci_port);
+		return -ENXIO;
+	}
+
+	if (aci_cmd(miro, ACI_INIT, -1, -1) < 0 ||
+	    aci_cmd(miro, ACI_ERROR_OP, ACI_ERROR_OP, ACI_ERROR_OP) < 0 ||
+	    aci_cmd(miro, ACI_ERROR_OP, ACI_ERROR_OP, ACI_ERROR_OP) < 0) {
+		snd_printk(KERN_ERR "can't initialize aci.\n"); 
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static void snd_card_miro_free(struct snd_card *card)
+{
+	struct snd_miro *miro = card->private_data;
+        
+	release_and_free_resource(miro->res_aci_port);
+	release_and_free_resource(miro->res_mc_base);
+}
+
+static int __init snd_miro_probe(struct platform_device *devptr)
+{
+	static long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};
+	static long possible_mpu_ports[] = {0x330, 0x300, 0x310, 0x320, -1};
+	static int possible_irqs[] = {11, 9, 10, 7, -1};
+	static int possible_mpu_irqs[] = {10, 5, 9, 7, -1};
+	static int possible_dma1s[] = {3, 1, 0, -1};
+	static int possible_dma2s[][2] = {{1,-1}, {0,-1}, {-1,-1}, {0,-1}};
+
+	int error;
+	struct snd_miro *miro;
+	struct snd_cs4231 *codec;
+	struct snd_timer *timer;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	struct snd_rawmidi *rmidi;
+
+	if (!(card = snd_card_new(index, id, THIS_MODULE,
+				  sizeof(struct snd_miro))))
+		return -ENOMEM;
+
+	card->private_free = snd_card_miro_free;
+	miro = card->private_data;
+	miro->card = card;
+
+	if ((error = snd_card_miro_aci_detect(card, miro)) < 0) {
+		snd_card_free(card);
+		snd_printk(KERN_ERR "unable to detect aci chip\n");
+		return -ENODEV;
+	}
+
+	/* init proc interface */
+	snd_miro_proc_init(miro);
+
+	if ((error = snd_card_miro_detect(card, miro)) < 0) {
+		snd_card_free(card);
+		snd_printk(KERN_ERR "unable to detect OPTi9xx chip\n");
+		return -ENODEV;
+	}
+
+	if (! miro->res_mc_base &&
+	    (miro->res_mc_base = request_region(miro->mc_base, miro->mc_base_size,
+						"miro (OPTi9xx MC)")) == NULL) {
+		snd_card_free(card);
+		snd_printk(KERN_ERR "request for OPTI9xx MC failed\n");
+		return -ENOMEM;
+	}
+
+	miro->wss_base = port;
+	miro->fm_port = fm_port;
+	miro->mpu_port = mpu_port;
+	miro->irq = irq;
+	miro->mpu_irq = mpu_irq;
+	miro->dma1 = dma1;
+	miro->dma2 = dma2;
+
+	if (miro->wss_base == SNDRV_AUTO_PORT) {
+		if ((miro->wss_base = snd_legacy_find_free_ioport(possible_ports, 4)) < 0) {
+			snd_card_free(card);
+			snd_printk(KERN_ERR "unable to find a free WSS port\n");
+			return -EBUSY;
+		}
+	}
+
+	if (miro->mpu_port == SNDRV_AUTO_PORT) {
+		if ((miro->mpu_port = snd_legacy_find_free_ioport(possible_mpu_ports, 2)) < 0) {
+			snd_card_free(card);
+			snd_printk(KERN_ERR "unable to find a free MPU401 port\n");
+			return -EBUSY;
+		}
+	}
+	if (miro->irq == SNDRV_AUTO_IRQ) {
+		if ((miro->irq = snd_legacy_find_free_irq(possible_irqs)) < 0) {
+			snd_card_free(card);
+			snd_printk(KERN_ERR "unable to find a free IRQ\n");
+			return -EBUSY;
+		}
+	}
+	if (miro->mpu_irq == SNDRV_AUTO_IRQ) {
+		if ((miro->mpu_irq = snd_legacy_find_free_irq(possible_mpu_irqs)) < 0) {
+			snd_card_free(card);
+			snd_printk(KERN_ERR "unable to find a free MPU401 IRQ\n");
+			return -EBUSY;
+		}
+	}
+	if (miro->dma1 == SNDRV_AUTO_DMA) {
+		if ((miro->dma1 = snd_legacy_find_free_dma(possible_dma1s)) < 0) {
+			snd_card_free(card);
+			snd_printk(KERN_ERR "unable to find a free DMA1\n");
+			return -EBUSY;
+		}
+	}
+	if (miro->dma2 == SNDRV_AUTO_DMA) {
+		if ((miro->dma2 = snd_legacy_find_free_dma(possible_dma2s[miro->dma1 % 4])) < 0) {
+			snd_card_free(card);
+			snd_printk(KERN_ERR "unable to find a free DMA2\n");
+			return -EBUSY;
+		}
+	}
+
+	if ((error = snd_miro_configure(miro))) {
+		snd_card_free(card);
+		return error;
+	}
+
+	if ((error = snd_cs4231_create(card, miro->wss_base + 4, -1,
+				       miro->irq, miro->dma1, miro->dma2,
+				       CS4231_HW_AD1845,
+				       0,
+				       &codec)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+
+	if ((error = snd_cs4231_pcm(codec, 0, &pcm)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+	if ((error = snd_cs4231_mixer(codec)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+	if ((error = snd_cs4231_timer(codec, 0, &timer)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+
+	miro->pcm = pcm;
+
+	if ((error = snd_miro_mixer(miro)) < 0) {
+		snd_card_free(card);
+		return error;
+	}
+
+	if (miro->aci_vendor == 'm') {
+		/* It looks like a miro sound card. */
+		switch (miro->aci_product) {
+		case 'A':
+			sprintf(card->shortname, 
+				"miroSOUND PCM1 pro / PCM12");
+			break;
+		case 'B':
+			sprintf(card->shortname, 
+				"miroSOUND PCM12");
+			break;
+		case 'C':
+			sprintf(card->shortname, 
+				"miroSOUND PCM20 radio");
+			break;
+		default:
+			sprintf(card->shortname, 
+				"unknown miro");
+			snd_printk(KERN_INFO "unknown miro aci id\n");
+			break;
+		}
+	} else {
+		snd_printk(KERN_INFO "found unsupported aci card\n");
+		sprintf(card->shortname, "unknown Cardinal Technologies");
+	}
+
+	strcpy(card->driver, "miro");
+	sprintf(card->longname, "%s: OPTi%s, %s at 0x%lx, irq %d, dma %d&%d",
+		card->shortname, miro->name, pcm->name, miro->wss_base + 4,
+		miro->irq, miro->dma1, miro->dma2);
+
+	if (miro->mpu_port <= 0 || miro->mpu_port == SNDRV_AUTO_PORT)
+		rmidi = NULL;
+	else
+		if ((error = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
+				miro->mpu_port, 0, miro->mpu_irq, SA_INTERRUPT,
+				&rmidi)))
+			snd_printk(KERN_WARNING "no MPU-401 device at 0x%lx?\n", miro->mpu_port);
+
+	if (miro->fm_port > 0 && miro->fm_port != SNDRV_AUTO_PORT) {
+		struct snd_opl3 *opl3 = NULL;
+		struct snd_opl4 *opl4;
+		if (snd_opl4_create(card, miro->fm_port, miro->fm_port - 8, 
+				    2, &opl3, &opl4) < 0)
+			snd_printk(KERN_WARNING "no OPL4 device at 0x%lx\n", miro->fm_port);
+	}
+
+	if ((error = snd_set_aci_init_values(miro)) < 0) {
+		snd_card_free(card);
+                return error;
+	}
+
+	snd_card_set_dev(card, &devptr->dev);
+
+	if ((error = snd_card_register(card))) {
+		snd_card_free(card);
+		return error;
+	}
+
+	platform_set_drvdata(devptr, card);
+	return 0;
+}
+
+static int __devexit snd_miro_remove(struct platform_device *devptr)
+{
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+	return 0;
+}
+
+static struct platform_driver snd_miro_driver = {
+	.probe		= snd_miro_probe,
+	.remove		= __devexit_p(snd_miro_remove),
+	/* FIXME: suspend/resume */
+	.driver		= {
+		.name	= DRIVER_NAME
+	},
+};
+
+static int __init alsa_card_miro_init(void)
+{
+	int error;
+
+	if ((error = platform_driver_register(&snd_miro_driver)) < 0)
+		return error;
+	device = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0);
+	if (! IS_ERR(device))
+		return 0;
+#ifdef MODULE
+	printk(KERN_ERR "no miro soundcard found\n");
+#endif
+	platform_driver_unregister(&snd_miro_driver);
+	return PTR_ERR(device);
+}
+
+static void __exit alsa_card_miro_exit(void)
+{
+	platform_device_unregister(device);
+	platform_driver_unregister(&snd_miro_driver);
+}
+
+module_init(alsa_card_miro_init)
+module_exit(alsa_card_miro_exit)
