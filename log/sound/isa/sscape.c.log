commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 8181db4db019..5363d88cc4b9 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -1,24 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *   Low-level ALSA driver for the ENSONIQ SoundScape
  *   Copyright (c) by Chris Rankin
  *
  *   This driver was written in part using information obtained from
  *   the OSS/Free SoundScape driver, written by Hannu Savolainen.
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include <linux/init.h>

commit 0b6a2c9cf4a00f54a0916499ece8a5cf3cced385
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 1 12:14:53 2019 +0100

    ALSA: isa: Avoid passing NULL to memory allocators
    
    We used to pass NULL to memory allocators for ISA devices due to
    historical reasons.  But we prefer rather a proper device object to be
    assigned, so let's fix it by replacing snd_dma_isa_data() call with
    card->dev reference, and kill snd_dma_isa_data() definition.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 733adee5afbf..8181db4db019 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -167,12 +167,13 @@ static inline struct soundscape *get_card_soundscape(struct snd_card *c)
  * I think this means that the memory has to map to
  * contiguous pages of physical memory.
  */
-static struct snd_dma_buffer *get_dmabuf(struct snd_dma_buffer *buf,
+static struct snd_dma_buffer *get_dmabuf(struct soundscape *s,
+					 struct snd_dma_buffer *buf,
 					 unsigned long size)
 {
 	if (buf) {
 		if (snd_dma_alloc_pages_fallback(SNDRV_DMA_TYPE_DEV,
-						 snd_dma_isa_data(),
+						 s->chip->card->dev,
 						 size, buf) < 0) {
 			snd_printk(KERN_ERR "sscape: Failed to allocate "
 					    "%lu bytes for DMA\n",
@@ -443,7 +444,7 @@ static int upload_dma_data(struct soundscape *s, const unsigned char *data,
 	int ret;
 	unsigned char val;
 
-	if (!get_dmabuf(&dma, PAGE_ALIGN(32 * 1024)))
+	if (!get_dmabuf(s, &dma, PAGE_ALIGN(32 * 1024)))
 		return -ENOMEM;
 
 	spin_lock_irqsave(&s->lock, flags);

commit 05e20b265c9068d2f5871e3fcddc366d5f6feecb
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Thu Aug 17 15:36:29 2017 +0530

    ALSA: sscape: constify pnp_card_device_id
    
    pnp_card_device_id are not supposed to change at runtime. All functions
    working with pnp_card_device_id provided by <linux/pnp.h> work with
    const pnp_card_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 1cd2908e4f12..733adee5afbf 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -88,7 +88,7 @@ MODULE_PARM_DESC(joystick, "Enable gameport.");
 static int isa_registered;
 static int pnp_registered;
 
-static struct pnp_card_device_id sscape_pnpids[] = {
+static const struct pnp_card_device_id sscape_pnpids[] = {
 	{ .id = "ENS3081", .devs = { { "ENS0000" } } }, /* Soundscape PnP */
 	{ .id = "ENS4081", .devs = { { "ENS1011" } } },	/* VIVO90 */
 	{ .id = "" }	/* end */

commit 3a84d6c940e666d85b1c58bbcda2248c54faa898
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Wed May 17 17:08:56 2017 +0530

    ALSA: sound/isa: constify snd_kcontrol_new structures
    
    Declare snd_kcontrol_new structures as const as they are only passed an
    argument to the function snd_ctl_new1. This argument is of type const,
    so snd_kcontrol_new structures having this property can be made const.
    Done using Coccinelle:
    
    @r disable optional_qualifier@
    identifier x;
    position p;
    @@
    static struct snd_kcontrol_new x@p={...};
    
    @ok@
    identifier r.x;
    position p;
    @@
    snd_ctl_new1(&x@p,...)
    
    @bad@
    position p != {r.p,ok.p};
    identifier r.x;
    @@
    x@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.x;
    @@
    +const
    struct snd_kcontrol_new x;
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 54f5758a1bb3..1cd2908e4f12 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -671,7 +671,7 @@ static int sscape_midi_put(struct snd_kcontrol *kctl,
 	return change;
 }
 
-static struct snd_kcontrol_new midi_mixer_ctl = {
+static const struct snd_kcontrol_new midi_mixer_ctl = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "MIDI",
 	.info = sscape_midi_info,

commit e992ef5705c1e154acb248869b39e0be4c003a8b
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:30 2017 +0100

    Annotate hardware config module parameters in sound/isa/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in sound/isa/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jaroslav Kysela <perex@perex.cz>
    cc: Takashi Iwai <tiwai@suse.com>
    cc: alsa-devel@alsa-project.org

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index fdcfa29e2205..54f5758a1bb3 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -63,22 +63,22 @@ MODULE_PARM_DESC(index, "Index number for SoundScape soundcard");
 module_param_array(id, charp, NULL, 0444);
 MODULE_PARM_DESC(id, "Description for SoundScape card");
 
-module_param_array(port, long, NULL, 0444);
+module_param_hw_array(port, long, ioport, NULL, 0444);
 MODULE_PARM_DESC(port, "Port # for SoundScape driver.");
 
-module_param_array(wss_port, long, NULL, 0444);
+module_param_hw_array(wss_port, long, ioport, NULL, 0444);
 MODULE_PARM_DESC(wss_port, "WSS Port # for SoundScape driver.");
 
-module_param_array(irq, int, NULL, 0444);
+module_param_hw_array(irq, int, irq, NULL, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for SoundScape driver.");
 
-module_param_array(mpu_irq, int, NULL, 0444);
+module_param_hw_array(mpu_irq, int, irq, NULL, 0444);
 MODULE_PARM_DESC(mpu_irq, "MPU401 IRQ # for SoundScape driver.");
 
-module_param_array(dma, int, NULL, 0444);
+module_param_hw_array(dma, int, dma, NULL, 0444);
 MODULE_PARM_DESC(dma, "DMA # for SoundScape driver.");
 
-module_param_array(dma2, int, NULL, 0444);
+module_param_hw_array(dma2, int, dma, NULL, 0444);
 MODULE_PARM_DESC(dma2, "DMA2 # for SoundScape driver.");
 
 module_param_array(joystick, bool, NULL, 0444);

commit dc5027a72369f4979a48d628ddebeeb974b7eb37
Author: William Breathitt Gray <vilhelm.gray@gmail.com>
Date:   Mon Apr 11 09:25:52 2016 -0400

    ALSA: sscape: Use correct format identifier for size_t
    
    The 'size' member of a struct firmware is passed to snd_printk with a
    respective format string using the %d identifier. The 'size' member is
    of type size_t, but format identifier %d indicates a signed int data
    type. This patch replaces the %d format identifier with the correct %zu
    format identifier for size_t data types.
    
    Signed-off-by: William Breathitt Gray <vilhelm.gray@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 7b248cdf06e2..fdcfa29e2205 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -591,7 +591,7 @@ static int sscape_upload_microcode(struct snd_card *card, int version)
 	}
 	err = upload_dma_data(sscape, init_fw->data, init_fw->size);
 	if (err == 0)
-		snd_printk(KERN_INFO "sscape: MIDI firmware loaded %d KBs\n",
+		snd_printk(KERN_INFO "sscape: MIDI firmware loaded %zu KBs\n",
 				init_fw->size >> 10);
 
 	release_firmware(init_fw);

commit 37419584abbb3abf3fae6b9eb6869f18c95f6a1d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 28 16:04:46 2015 +0100

    ALSA: sscape: add missing include of linux/io.h
    
    The soundscape driver uses the ISA inb/outb functions declared
    in linux/io.h, so it needs to include this header to avoid
    a build error:
    
    sscape.c: In function 'sscape_write_unsafe':
    sscape.c:203:2: error: implicit declaration of function 'outb' [-Werror=implicit-function-declaration]
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 018ab140c2be..7b248cdf06e2 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -23,6 +23,7 @@
 
 #include <linux/init.h>
 #include <linux/err.h>
+#include <linux/io.h>
 #include <linux/isa.h>
 #include <linux/delay.h>
 #include <linux/firmware.h>

commit fa60c065694a81e534c61809ab7dd419366e9335
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Jan 2 12:24:43 2015 +0100

    ALSA: wss: Remove (almost) always NULL parameters
    
    Most callers of snd_wss_pcm(), snd_wss_timer() and snd_cs4236_pcm() pass
    NULL as the last parameter, some callers pass a pointer but never use it
    after the function has been called and only a few callers pass a pointer and
    actually use it. The later is only the case for snd_wss_pcm() for
    snd_cs4236_pcm() and it is possible to get the same PCM object by accessing
    the pcm field of the snd_wss struct that was passed as the first parameter.
    
    This function removes the last parameters from the functions mentioned above
    and updates the callers which used it to use chip->pcm instead. This allows
    us to slightly simplify the functions since they don't have to check and set
    the last parameter anymore which makes the code slightly shorter and
    cleaner.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 44405df7d4be..018ab140c2be 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -877,7 +877,6 @@ static int create_ad1845(struct snd_card *card, unsigned port,
 			     codec_type, WSS_HWSHARE_DMA1, &chip);
 	if (!err) {
 		unsigned long flags;
-		struct snd_pcm *pcm;
 
 		if (sscape->type != SSCAPE_VIVO) {
 			/*
@@ -893,7 +892,7 @@ static int create_ad1845(struct snd_card *card, unsigned port,
 
 		}
 
-		err = snd_wss_pcm(chip, 0, &pcm);
+		err = snd_wss_pcm(chip, 0);
 		if (err < 0) {
 			snd_printk(KERN_ERR "sscape: No PCM device "
 					    "for AD1845 chip\n");
@@ -907,7 +906,7 @@ static int create_ad1845(struct snd_card *card, unsigned port,
 			goto _error;
 		}
 		if (chip->hardware != WSS_HW_AD1848) {
-			err = snd_wss_timer(chip, 0, NULL);
+			err = snd_wss_timer(chip, 0);
 			if (err < 0) {
 				snd_printk(KERN_ERR "sscape: No timer device "
 						    "for AD1845 chip\n");

commit 4323cc4d5b25b5138c0791e3c7d3b09bd7062b49
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 13:03:56 2014 +0100

    ALSA: isa: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 57b338973ede..44405df7d4be 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -1169,8 +1169,8 @@ static int snd_sscape_probe(struct device *pdev, unsigned int dev)
 	struct soundscape *sscape;
 	int ret;
 
-	ret = snd_card_create(index[dev], id[dev], THIS_MODULE,
-			      sizeof(struct soundscape), &card);
+	ret = snd_card_new(pdev, index[dev], id[dev], THIS_MODULE,
+			   sizeof(struct soundscape), &card);
 	if (ret < 0)
 		return ret;
 
@@ -1178,7 +1178,6 @@ static int snd_sscape_probe(struct device *pdev, unsigned int dev)
 	sscape->type = SSCAPE;
 
 	dma[dev] &= 0x03;
-	snd_card_set_dev(card, pdev);
 
 	ret = create_sscape(dev, card);
 	if (ret < 0)
@@ -1259,8 +1258,9 @@ static int sscape_pnp_detect(struct pnp_card_link *pcard,
 	 * Create a new ALSA sound card entry, in anticipation
 	 * of detecting our hardware ...
 	 */
-	ret = snd_card_create(index[idx], id[idx], THIS_MODULE,
-			      sizeof(struct soundscape), &card);
+	ret = snd_card_new(&pcard->card->dev,
+			   index[idx], id[idx], THIS_MODULE,
+			   sizeof(struct soundscape), &card);
 	if (ret < 0)
 		return ret;
 
@@ -1288,7 +1288,6 @@ static int sscape_pnp_detect(struct pnp_card_link *pcard,
 		wss_port[idx] = pnp_port_start(dev, 1);
 		dma2[idx] = pnp_dma(dev, 1);
 	}
-	snd_card_set_dev(card, &pcard->card->dev);
 
 	ret = create_sscape(idx, card);
 	if (ret < 0)

commit 8b5a1f9c46c2b78716794b8762edf659ec25a87d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:49:32 2013 +0200

    ALSA: ISA: Remove superfluous *_set_drvdata(NULL) calls
    
    Similarly like the previous commit for PCI drivers, remove
    dev_set_drvdata(NULL) and pnp_set_drvdata(NULL) calls in ISA drivers
    now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 42a009720b29..57b338973ede 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -1200,7 +1200,6 @@ static int snd_sscape_probe(struct device *pdev, unsigned int dev)
 static int snd_sscape_remove(struct device *devptr, unsigned int dev)
 {
 	snd_card_free(dev_get_drvdata(devptr));
-	dev_set_drvdata(devptr, NULL);
 	return 0;
 }
 

commit 1bff292e9abec7477d43abb2b93c7fd26c44859b
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:21 2012 -0500

    ALSA: isa: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 8490f59709bb..42a009720b29 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -683,7 +683,7 @@ static struct snd_kcontrol_new midi_mixer_ctl = {
  * These IRQs are encoded as bit patterns so that they can be
  * written to the control registers.
  */
-static unsigned __devinit get_irq_config(int sscape_type, int irq)
+static unsigned get_irq_config(int sscape_type, int irq)
 {
 	static const int valid_irq[] = { 9, 5, 7, 10 };
 	static const int old_irq[] = { 9, 7, 5, 15 };
@@ -706,7 +706,7 @@ static unsigned __devinit get_irq_config(int sscape_type, int irq)
  * Perform certain arcane port-checks to see whether there
  * is a SoundScape board lurking behind the given ports.
  */
-static int __devinit detect_sscape(struct soundscape *s, long wss_io)
+static int detect_sscape(struct soundscape *s, long wss_io)
 {
 	unsigned long flags;
 	unsigned d;
@@ -817,8 +817,8 @@ static int mpu401_open(struct snd_mpu401 *mpu)
 /*
  * Initialse an MPU-401 subdevice for MIDI support on the SoundScape.
  */
-static int __devinit create_mpu401(struct snd_card *card, int devnum,
-				   unsigned long port, int irq)
+static int create_mpu401(struct snd_card *card, int devnum,
+			 unsigned long port, int irq)
 {
 	struct soundscape *sscape = get_card_soundscape(card);
 	struct snd_rawmidi *rawmidi;
@@ -845,8 +845,8 @@ static int __devinit create_mpu401(struct snd_card *card, int devnum,
  * try to support at least some of the extra bits by overriding
  * some of the CS4231 callback.
  */
-static int __devinit create_ad1845(struct snd_card *card, unsigned port,
-				   int irq, int dma1, int dma2)
+static int create_ad1845(struct snd_card *card, unsigned port,
+			 int irq, int dma1, int dma2)
 {
 	register struct soundscape *sscape = get_card_soundscape(card);
 	struct snd_wss *chip;
@@ -937,7 +937,7 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
  * Create an ALSA soundcard entry for the SoundScape, using
  * the given list of port, IRQ and DMA resources.
  */
-static int __devinit create_sscape(int dev, struct snd_card *card)
+static int create_sscape(int dev, struct snd_card *card)
 {
 	struct soundscape *sscape = get_card_soundscape(card);
 	unsigned dma_cfg;
@@ -1143,7 +1143,7 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 }
 
 
-static int __devinit snd_sscape_match(struct device *pdev, unsigned int i)
+static int snd_sscape_match(struct device *pdev, unsigned int i)
 {
 	/*
 	 * Make sure we were given ALL of the other parameters.
@@ -1163,7 +1163,7 @@ static int __devinit snd_sscape_match(struct device *pdev, unsigned int i)
 	return 1;
 }
 
-static int __devinit snd_sscape_probe(struct device *pdev, unsigned int dev)
+static int snd_sscape_probe(struct device *pdev, unsigned int dev)
 {
 	struct snd_card *card;
 	struct soundscape *sscape;
@@ -1197,7 +1197,7 @@ static int __devinit snd_sscape_probe(struct device *pdev, unsigned int dev)
 	return ret;
 }
 
-static int __devexit snd_sscape_remove(struct device *devptr, unsigned int dev)
+static int snd_sscape_remove(struct device *devptr, unsigned int dev)
 {
 	snd_card_free(dev_get_drvdata(devptr));
 	dev_set_drvdata(devptr, NULL);
@@ -1209,7 +1209,7 @@ static int __devexit snd_sscape_remove(struct device *devptr, unsigned int dev)
 static struct isa_driver snd_sscape_driver = {
 	.match		= snd_sscape_match,
 	.probe		= snd_sscape_probe,
-	.remove		= __devexit_p(snd_sscape_remove),
+	.remove		= snd_sscape_remove,
 	/* FIXME: suspend/resume */
 	.driver		= {
 		.name	= DEV_NAME
@@ -1217,7 +1217,7 @@ static struct isa_driver snd_sscape_driver = {
 };
 
 #ifdef CONFIG_PNP
-static inline int __devinit get_next_autoindex(int i)
+static inline int get_next_autoindex(int i)
 {
 	while (i < SNDRV_CARDS && port[i] != SNDRV_AUTO_PORT)
 		++i;
@@ -1225,8 +1225,8 @@ static inline int __devinit get_next_autoindex(int i)
 }
 
 
-static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
-				       const struct pnp_card_device_id *pid)
+static int sscape_pnp_detect(struct pnp_card_link *pcard,
+			     const struct pnp_card_device_id *pid)
 {
 	static int idx = 0;
 	struct pnp_dev *dev;
@@ -1310,7 +1310,7 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 	return ret;
 }
 
-static void __devexit sscape_pnp_remove(struct pnp_card_link * pcard)
+static void sscape_pnp_remove(struct pnp_card_link *pcard)
 {
 	snd_card_free(pnp_get_card_drvdata(pcard));
 	pnp_set_card_drvdata(pcard, NULL);
@@ -1321,7 +1321,7 @@ static struct pnp_card_driver sscape_pnpc_driver = {
 	.name = "sscape",
 	.id_table = sscape_pnpids,
 	.probe = sscape_pnp_detect,
-	.remove = __devexit_p(sscape_pnp_remove),
+	.remove = sscape_pnp_remove,
 };
 
 #endif /* CONFIG_PNP */

commit 38be95dd3d314bd393a26f6e441ae2c57ef7f064
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Mon Apr 9 10:16:35 2012 +0200

    ALSA: sound/isa/sscape.c: add missing resource-release code
    
    At the point of this error-handling code, both regions and the dma have
    been allocated, so free it as done in previous and subsequent
    error-handling code.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index b4a6aa960f4b..8490f59709bb 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -1019,13 +1019,15 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	irq_cfg = get_irq_config(sscape->type, irq[dev]);
 	if (irq_cfg == INVALID_IRQ) {
 		snd_printk(KERN_ERR "sscape: Invalid IRQ %d\n", irq[dev]);
-		return -ENXIO;
+		err = -ENXIO;
+		goto _release_dma;
 	}
 
 	mpu_irq_cfg = get_irq_config(sscape->type, mpu_irq[dev]);
 	if (mpu_irq_cfg == INVALID_IRQ) {
 		snd_printk(KERN_ERR "sscape: Invalid IRQ %d\n", mpu_irq[dev]);
-		return -ENXIO;
+		err = -ENXIO;
+		goto _release_dma;
 	}
 
 	/*

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index f2379e102b63..b4a6aa960f4b 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -28,7 +28,7 @@
 #include <linux/firmware.h>
 #include <linux/pnp.h>
 #include <linux/spinlock.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <asm/dma.h>
 #include <sound/core.h>
 #include <sound/wss.h>

commit dba8b46992c55946d3b092934f581a343403118f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Sep 13 11:24:41 2011 +0200

    ALSA: mpu401: clean up interrupt specification
    
    The semantics of snd_mpu401_uart_new()'s interrupt parameters are
    somewhat counterintuitive:  To prevent the function from allocating its
    own interrupt, either the irq number must be invalid, or the irq_flags
    parameter must be zero.  At the same time, the irq parameter being
    invalid specifies that the mpu401 code has to work without an interrupt
    allocated by the caller.  This implies that, if there is an interrupt
    and it is allocated by the caller, the irq parameter must be set to
    a valid-looking number which then isn't actually used.
    
    With the removal of IRQF_DISABLED, zero becomes a valid irq_flags value,
    which forces us to handle the parameters differently.
    
    This patch introduces a new flag MPU401_INFO_IRQ_HOOK for when the
    device interrupt is handled by the caller, and makes the allocation of
    the interrupt to depend only on the irq parameter.  As suggested by
    Takashi, the irq_flags parameter was dropped because, when used, it had
    the constant value IRQF_DISABLED.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index e2d5d2d3ed96..f2379e102b63 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -825,8 +825,7 @@ static int __devinit create_mpu401(struct snd_card *card, int devnum,
 	int err;
 
 	err = snd_mpu401_uart_new(card, devnum, MPU401_HW_MPU401, port,
-				  MPU401_INFO_INTEGRATED, irq, IRQF_DISABLED,
-				  &rawmidi);
+				  MPU401_INFO_INTEGRATED, irq, &rawmidi);
 	if (err == 0) {
 		struct snd_mpu401 *mpu = rawmidi->private_data;
 		mpu->open_input = mpu401_open;

commit 6fcfa3959a5f5ecb7c333f54f401575d94eb8172
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Sat Oct 10 10:27:58 2009 +0200

    ALSA: sscape: coding style fixes
    
    Fix coding style errors in the driver.
    
    Also, add missing argument for CMD_XXX_MIDI_VOL command.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 579a59b9e470..e2d5d2d3ed96 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -109,14 +109,14 @@ MODULE_DEVICE_TABLE(pnp_card, sscape_pnpids);
 #define RX_READY 0x01
 #define TX_READY 0x02
 
-#define CMD_ACK           0x80
-#define CMD_SET_MIDI_VOL  0x84
-#define CMD_GET_MIDI_VOL  0x85
-#define CMD_XXX_MIDI_VOL  0x86
-#define CMD_SET_EXTMIDI   0x8a
-#define CMD_GET_EXTMIDI   0x8b
-#define CMD_SET_MT32      0x8c
-#define CMD_GET_MT32      0x8d
+#define CMD_ACK			0x80
+#define CMD_SET_MIDI_VOL	0x84
+#define CMD_GET_MIDI_VOL	0x85
+#define CMD_XXX_MIDI_VOL	0x86
+#define CMD_SET_EXTMIDI		0x8a
+#define CMD_GET_EXTMIDI		0x8b
+#define CMD_SET_MT32		0x8c
+#define CMD_GET_MT32		0x8d
 
 enum GA_REG {
 	GA_INTSTAT_REG = 0,
@@ -166,10 +166,12 @@ static inline struct soundscape *get_card_soundscape(struct snd_card *c)
  * I think this means that the memory has to map to
  * contiguous pages of physical memory.
  */
-static struct snd_dma_buffer *get_dmabuf(struct snd_dma_buffer *buf, unsigned long size)
+static struct snd_dma_buffer *get_dmabuf(struct snd_dma_buffer *buf,
+					 unsigned long size)
 {
 	if (buf) {
-		if (snd_dma_alloc_pages_fallback(SNDRV_DMA_TYPE_DEV, snd_dma_isa_data(),
+		if (snd_dma_alloc_pages_fallback(SNDRV_DMA_TYPE_DEV,
+						 snd_dma_isa_data(),
 						 size, buf) < 0) {
 			snd_printk(KERN_ERR "sscape: Failed to allocate "
 					    "%lu bytes for DMA\n",
@@ -190,13 +192,13 @@ static void free_dmabuf(struct snd_dma_buffer *buf)
 		snd_dma_free_pages(buf);
 }
 
-
 /*
  * This function writes to the SoundScape's control registers,
  * but doesn't do any locking. It's up to the caller to do that.
  * This is why this function is "unsafe" ...
  */
-static inline void sscape_write_unsafe(unsigned io_base, enum GA_REG reg, unsigned char val)
+static inline void sscape_write_unsafe(unsigned io_base, enum GA_REG reg,
+				       unsigned char val)
 {
 	outb(reg, ODIE_ADDR_IO(io_base));
 	outb(val, ODIE_DATA_IO(io_base));
@@ -206,7 +208,8 @@ static inline void sscape_write_unsafe(unsigned io_base, enum GA_REG reg, unsign
  * Write to the SoundScape's control registers, and do the
  * necessary locking ...
  */
-static void sscape_write(struct soundscape *s, enum GA_REG reg, unsigned char val)
+static void sscape_write(struct soundscape *s, enum GA_REG reg,
+			 unsigned char val)
 {
 	unsigned long flags;
 
@@ -219,7 +222,8 @@ static void sscape_write(struct soundscape *s, enum GA_REG reg, unsigned char va
  * Read from the SoundScape's control registers, but leave any
  * locking to the caller. This is why the function is "unsafe" ...
  */
-static inline unsigned char sscape_read_unsafe(unsigned io_base, enum GA_REG reg)
+static inline unsigned char sscape_read_unsafe(unsigned io_base,
+					       enum GA_REG reg)
 {
 	outb(reg, ODIE_ADDR_IO(io_base));
 	return inb(ODIE_DATA_IO(io_base));
@@ -248,9 +252,8 @@ static inline void set_midi_mode_unsafe(unsigned io_base)
 static inline int host_read_unsafe(unsigned io_base)
 {
 	int data = -1;
-	if ((inb(HOST_CTRL_IO(io_base)) & RX_READY) != 0) {
+	if ((inb(HOST_CTRL_IO(io_base)) & RX_READY) != 0)
 		data = inb(HOST_DATA_IO(io_base));
-	}
 
 	return data;
 }
@@ -292,7 +295,7 @@ static inline int host_write_unsafe(unsigned io_base, unsigned char data)
  * Also leaves all locking-issues to the caller ...
  */
 static int host_write_ctrl_unsafe(unsigned io_base, unsigned char data,
-                                  unsigned timeout)
+				  unsigned timeout)
 {
 	int err;
 
@@ -311,7 +314,7 @@ static int host_write_ctrl_unsafe(unsigned io_base, unsigned char data,
  *
  * NOTE: This check is based upon observation, not documentation.
  */
-static inline int verify_mpu401(const struct snd_mpu401 * mpu)
+static inline int verify_mpu401(const struct snd_mpu401 *mpu)
 {
 	return ((inb(MPU401C(mpu)) & 0xc0) == 0x80);
 }
@@ -319,7 +322,7 @@ static inline int verify_mpu401(const struct snd_mpu401 * mpu)
 /*
  * This is apparently the standard way to initailise an MPU-401
  */
-static inline void initialise_mpu401(const struct snd_mpu401 * mpu)
+static inline void initialise_mpu401(const struct snd_mpu401 *mpu)
 {
 	outb(0, MPU401D(mpu));
 }
@@ -329,9 +332,10 @@ static inline void initialise_mpu401(const struct snd_mpu401 * mpu)
  * The AD1845 detection fails if we *don't* do this, so I
  * think that this is a good idea ...
  */
-static inline void activate_ad1845_unsafe(unsigned io_base)
+static void activate_ad1845_unsafe(unsigned io_base)
 {
-	sscape_write_unsafe(io_base, GA_HMCTL_REG, (sscape_read_unsafe(io_base, GA_HMCTL_REG) & 0xcf) | 0x10);
+	unsigned char val = sscape_read_unsafe(io_base, GA_HMCTL_REG);
+	sscape_write_unsafe(io_base, GA_HMCTL_REG, (val & 0xcf) | 0x10);
 	sscape_write_unsafe(io_base, GA_CDCFG_REG, 0x80);
 }
 
@@ -350,24 +354,27 @@ static void soundscape_free(struct snd_card *c)
  * Tell the SoundScape to begin a DMA tranfer using the given channel.
  * All locking issues are left to the caller.
  */
-static inline void sscape_start_dma_unsafe(unsigned io_base, enum GA_REG reg)
+static void sscape_start_dma_unsafe(unsigned io_base, enum GA_REG reg)
 {
-	sscape_write_unsafe(io_base, reg, sscape_read_unsafe(io_base, reg) | 0x01);
-	sscape_write_unsafe(io_base, reg, sscape_read_unsafe(io_base, reg) & 0xfe);
+	sscape_write_unsafe(io_base, reg,
+			    sscape_read_unsafe(io_base, reg) | 0x01);
+	sscape_write_unsafe(io_base, reg,
+			    sscape_read_unsafe(io_base, reg) & 0xfe);
 }
 
 /*
  * Wait for a DMA transfer to complete. This is a "limited busy-wait",
  * and all locking issues are left to the caller.
  */
-static int sscape_wait_dma_unsafe(unsigned io_base, enum GA_REG reg, unsigned timeout)
+static int sscape_wait_dma_unsafe(unsigned io_base, enum GA_REG reg,
+				  unsigned timeout)
 {
 	while (!(sscape_read_unsafe(io_base, reg) & 0x01) && (timeout != 0)) {
 		udelay(100);
 		--timeout;
 	} /* while */
 
-	return (sscape_read_unsafe(io_base, reg) & 0x01);
+	return sscape_read_unsafe(io_base, reg) & 0x01;
 }
 
 /*
@@ -427,13 +434,13 @@ static int host_startup_ack(struct soundscape *s, unsigned timeout)
 /*
  * Upload a byte-stream into the SoundScape using DMA channel A.
  */
-static int upload_dma_data(struct soundscape *s,
-			   const unsigned char *data,
-                           size_t size)
+static int upload_dma_data(struct soundscape *s, const unsigned char *data,
+			   size_t size)
 {
 	unsigned long flags;
 	struct snd_dma_buffer dma;
 	int ret;
+	unsigned char val;
 
 	if (!get_dmabuf(&dma, PAGE_ALIGN(32 * 1024)))
 		return -ENOMEM;
@@ -443,18 +450,21 @@ static int upload_dma_data(struct soundscape *s,
 	/*
 	 * Reset the board ...
 	 */
-	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, sscape_read_unsafe(s->io_base, GA_HMCTL_REG) & 0x3f);
+	val = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);
+	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, val & 0x3f);
 
 	/*
 	 * Enable the DMA channels and configure them ...
 	 */
-	sscape_write_unsafe(s->io_base, GA_DMAA_REG, (s->chip->dma1 << 4) | DMA_8BIT);
+	val = (s->chip->dma1 << 4) | DMA_8BIT;
+	sscape_write_unsafe(s->io_base, GA_DMAA_REG, val);
 	sscape_write_unsafe(s->io_base, GA_DMAB_REG, 0x20);
 
 	/*
 	 * Take the board out of reset ...
 	 */
-	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, sscape_read_unsafe(s->io_base, GA_HMCTL_REG) | 0x80);
+	val = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);
+	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, val | 0x80);
 
 	/*
 	 * Upload the firmware to the SoundScape
@@ -472,7 +482,7 @@ static int upload_dma_data(struct soundscape *s,
 		sscape_start_dma_unsafe(s->io_base, GA_DMAA_REG);
 		if (!sscape_wait_dma_unsafe(s->io_base, GA_DMAA_REG, 5000)) {
 			/*
-			 * Don't forget to release this spinlock we're holding ...
+			 * Don't forget to release this spinlock we're holding
 			 */
 			spin_unlock_irqrestore(&s->lock, flags);
 
@@ -489,7 +499,8 @@ static int upload_dma_data(struct soundscape *s,
 	/*
 	 * Boot the board ... (I think)
 	 */
-	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, sscape_read_unsafe(s->io_base, GA_HMCTL_REG) | 0x40);
+	val = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);
+	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, val | 0x40);
 	spin_unlock_irqrestore(&s->lock, flags);
 
 	/*
@@ -591,7 +602,7 @@ static int sscape_upload_microcode(struct snd_card *card, int version)
  * Mixer control for the SoundScape's MIDI device.
  */
 static int sscape_midi_info(struct snd_kcontrol *ctl,
-                            struct snd_ctl_elem_info *uinfo)
+			    struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
@@ -601,7 +612,7 @@ static int sscape_midi_info(struct snd_kcontrol *ctl,
 }
 
 static int sscape_midi_get(struct snd_kcontrol *kctl,
-                           struct snd_ctl_elem_value *uctl)
+			   struct snd_ctl_elem_value *uctl)
 {
 	struct snd_wss *chip = snd_kcontrol_chip(kctl);
 	struct snd_card *card = chip->card;
@@ -615,16 +626,18 @@ static int sscape_midi_get(struct snd_kcontrol *kctl,
 }
 
 static int sscape_midi_put(struct snd_kcontrol *kctl,
-                           struct snd_ctl_elem_value *uctl)
+			   struct snd_ctl_elem_value *uctl)
 {
 	struct snd_wss *chip = snd_kcontrol_chip(kctl);
 	struct snd_card *card = chip->card;
-	register struct soundscape *s = get_card_soundscape(card);
+	struct soundscape *s = get_card_soundscape(card);
 	unsigned long flags;
 	int change;
+	unsigned char new_val;
 
 	spin_lock_irqsave(&s->lock, flags);
 
+	new_val = uctl->value.integer.value[0] & 127;
 	/*
 	 * We need to put the board into HOST mode before we
 	 * can send any volume-changing HOST commands ...
@@ -637,15 +650,16 @@ static int sscape_midi_put(struct snd_kcontrol *kctl,
 	 * and then perform another volume-related command. Perhaps the
 	 * first command is an "open" and the second command is a "close"?
 	 */
-	if (s->midi_vol == ((unsigned char) uctl->value.integer. value[0] & 127)) {
+	if (s->midi_vol == new_val) {
 		change = 0;
 		goto __skip_change;
 	}
-	change = (host_write_ctrl_unsafe(s->io_base, CMD_SET_MIDI_VOL, 100)
-	          && host_write_ctrl_unsafe(s->io_base, ((unsigned char) uctl->value.integer. value[0]) & 127, 100)
-	          && host_write_ctrl_unsafe(s->io_base, CMD_XXX_MIDI_VOL, 100));
-	s->midi_vol = (unsigned char) uctl->value.integer.value[0] & 127;
-      __skip_change:
+	change = host_write_ctrl_unsafe(s->io_base, CMD_SET_MIDI_VOL, 100)
+		 && host_write_ctrl_unsafe(s->io_base, new_val, 100)
+		 && host_write_ctrl_unsafe(s->io_base, CMD_XXX_MIDI_VOL, 100)
+		 && host_write_ctrl_unsafe(s->io_base, new_val, 100);
+	s->midi_vol = new_val;
+__skip_change:
 
 	/*
 	 * Take the board out of HOST mode and back into MIDI mode ...
@@ -738,7 +752,7 @@ static int __devinit detect_sscape(struct soundscape *s, long wss_io)
 	if (s->type == SSCAPE_VIVO)
 		wss_io += 4;
 
-	d  = sscape_read_unsafe(s->io_base, GA_HMCTL_REG) & 0x3f;
+	d  = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);
 	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, d | 0xc0);
 
 	/* wait for WSS codec */
@@ -762,7 +776,7 @@ static int __devinit detect_sscape(struct soundscape *s, long wss_io)
 	if ((inb(wss_io) & 0x80) != 0)
 		s->type = MEDIA_FX;
 
-	d = sscape_read_unsafe(s->io_base, GA_HMCTL_REG) & 0x3f;
+	d = sscape_read_unsafe(s->io_base, GA_HMCTL_REG);
 	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, d | 0xc0);
 	/* wait for WSS codec */
 	for (d = 0; d < 500; d++) {
@@ -778,7 +792,7 @@ static int __devinit detect_sscape(struct soundscape *s, long wss_io)
 	 */
 	retval = 1;
 
-	_done:
+_done:
 	spin_unlock_irqrestore(&s->lock, flags);
 	return retval;
 }
@@ -789,7 +803,7 @@ static int __devinit detect_sscape(struct soundscape *s, long wss_io)
  * to crash the machine. Also check that someone isn't using the hardware
  * IOCTL device.
  */
-static int mpu401_open(struct snd_mpu401 * mpu)
+static int mpu401_open(struct snd_mpu401 *mpu)
 {
 	if (!verify_mpu401(mpu)) {
 		snd_printk(KERN_ERR "sscape: MIDI disabled, "
@@ -803,18 +817,18 @@ static int mpu401_open(struct snd_mpu401 * mpu)
 /*
  * Initialse an MPU-401 subdevice for MIDI support on the SoundScape.
  */
-static int __devinit create_mpu401(struct snd_card *card, int devnum, unsigned long port, int irq)
+static int __devinit create_mpu401(struct snd_card *card, int devnum,
+				   unsigned long port, int irq)
 {
 	struct soundscape *sscape = get_card_soundscape(card);
 	struct snd_rawmidi *rawmidi;
 	int err;
 
-	if ((err = snd_mpu401_uart_new(card, devnum,
-	                               MPU401_HW_MPU401,
-	                               port, MPU401_INFO_INTEGRATED,
-	                               irq, IRQF_DISABLED,
-	                               &rawmidi)) == 0) {
-		struct snd_mpu401 *mpu = (struct snd_mpu401 *) rawmidi->private_data;
+	err = snd_mpu401_uart_new(card, devnum, MPU401_HW_MPU401, port,
+				  MPU401_INFO_INTEGRATED, irq, IRQF_DISABLED,
+				  &rawmidi);
+	if (err == 0) {
+		struct snd_mpu401 *mpu = rawmidi->private_data;
 		mpu->open_input = mpu401_open;
 		mpu->open_output = mpu401_open;
 		mpu->private_data = sscape;
@@ -866,19 +880,6 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
 		unsigned long flags;
 		struct snd_pcm *pcm;
 
-/*
- * It turns out that the PLAYBACK_ENABLE bit is set
- * by the lowlevel driver ...
- *
-#define AD1845_IFACE_CONFIG  \
-           (CS4231_AUTOCALIB | CS4231_RECORD_ENABLE | CS4231_PLAYBACK_ENABLE)
-    snd_wss_mce_up(chip);
-    spin_lock_irqsave(&chip->reg_lock, flags);
-    snd_wss_out(chip, CS4231_IFACE_CTRL, AD1845_IFACE_CONFIG);
-    spin_unlock_irqrestore(&chip->reg_lock, flags);
-    snd_wss_mce_down(chip);
- */
-
 		if (sscape->type != SSCAPE_VIVO) {
 			/*
 			 * The input clock frequency on the SoundScape must
@@ -928,7 +929,7 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
 		sscape->chip = chip;
 	}
 
-	_error:
+_error:
 	return err;
 }
 
@@ -1034,7 +1035,6 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	 */
 	spin_lock_irqsave(&sscape->lock, flags);
 
-	sscape_write_unsafe(sscape->io_base, GA_INTENA_REG, 0x00); /* disable */
 	sscape_write_unsafe(sscape->io_base, GA_SMCFGA_REG, 0x2e);
 	sscape_write_unsafe(sscape->io_base, GA_SMCFGB_REG, 0x00);
 
@@ -1055,6 +1055,10 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	sscape_write_unsafe(sscape->io_base,
 			    GA_CDCFG_REG, 0x09 | DMA_8BIT
 			    | (dma[dev] << 4) | (irq_cfg << 1));
+	/*
+	 * Enable the master IRQ ...
+	 */
+	sscape_write_unsafe(sscape->io_base, GA_INTENA_REG, 0x80);
 
 	spin_unlock_irqrestore(&sscape->lock, flags);
 
@@ -1093,11 +1097,6 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 				goto _release_dma;
 			}
 
-			/*
-			 * Enable the master IRQ ...
-			 */
-			sscape_write(sscape, GA_INTENA_REG, 0x80);
-
 			/*
 			 * Initialize mixer
 			 */
@@ -1155,7 +1154,8 @@ static int __devinit snd_sscape_match(struct device *pdev, unsigned int i)
 	    mpu_irq[i] == SNDRV_AUTO_IRQ ||
 	    dma[i] == SNDRV_AUTO_DMA) {
 		printk(KERN_INFO
-		       "sscape: insufficient parameters, need IO, IRQ, MPU-IRQ and DMA\n");
+		       "sscape: insufficient parameters, "
+		       "need IO, IRQ, MPU-IRQ and DMA\n");
 		return 0;
 	}
 
@@ -1183,7 +1183,8 @@ static int __devinit snd_sscape_probe(struct device *pdev, unsigned int dev)
 	if (ret < 0)
 		goto _release_card;
 
-	if ((ret = snd_card_register(card)) < 0) {
+	ret = snd_card_register(card);
+	if (ret < 0) {
 		snd_printk(KERN_ERR "sscape: Failed to register sound card\n");
 		goto _release_card;
 	}
@@ -1236,20 +1237,15 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 	 * Allow this function to fail *quietly* if all the ISA PnP
 	 * devices were configured using module parameters instead.
 	 */
-	if ((idx = get_next_autoindex(idx)) >= SNDRV_CARDS)
+	idx = get_next_autoindex(idx);
+	if (idx >= SNDRV_CARDS)
 		return -ENOSPC;
 
-	/*
-	 * We have found a candidate ISA PnP card. Now we
-	 * have to check that it has the devices that we
-	 * expect it to have.
-	 */
-
 	/*
 	 * Check that we still have room for another sound card ...
 	 */
 	dev = pnp_request_card_device(pcard, pid->devs[0].id, NULL);
-	if (! dev)
+	if (!dev)
 		return -ENODEV;
 
 	if (!pnp_is_active(dev)) {
@@ -1298,7 +1294,8 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 	if (ret < 0)
 		goto _release_card;
 
-	if ((ret = snd_card_register(card)) < 0) {
+	ret = snd_card_register(card);
+	if (ret < 0) {
 		snd_printk(KERN_ERR "sscape: Failed to register sound card\n");
 		goto _release_card;
 	}

commit ed76f652d5329d9dff0ea7f3953b1357ed7f8e6e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 5 18:27:28 2009 +0200

    ALSA: sscape - Remove invalid __devinitdata to module parameters
    
    Module parameters shouldn't be marked as __devinitdata since they can be
    referred via sysfs even after probing.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 279be505b72e..579a59b9e470 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -46,15 +46,15 @@ MODULE_FIRMWARE("sndscape.co3");
 MODULE_FIRMWARE("sndscape.co4");
 MODULE_FIRMWARE("scope.cod");
 
-static int index[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_IDX;
-static char* id[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_STR;
-static long port[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_PORT;
-static long wss_port[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_PORT;
-static int irq[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_IRQ;
-static int mpu_irq[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_IRQ;
-static int dma[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_DMA;
-static int dma2[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_DMA;
-static bool joystick[SNDRV_CARDS] __devinitdata;
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+static char* id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+static long port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;
+static long wss_port[SNDRV_CARDS] = SNDRV_DEFAULT_PORT;
+static int irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;
+static int mpu_irq[SNDRV_CARDS] = SNDRV_DEFAULT_IRQ;
+static int dma[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;
+static int dma2[SNDRV_CARDS] = SNDRV_DEFAULT_DMA;
+static bool joystick[SNDRV_CARDS];
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index number for SoundScape soundcard");

commit 1cb0fdebae08f6daaac81197d8dde1746e0a1d96
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Mon Oct 5 18:18:57 2009 +0200

    ALSA: sscape: force AD1848 codec mode on old Soundscape
    
    Old Soundscape cards (pre PnP) work only with AD1848 codecs.
    If the CS4231 codec is installed it must be used in AD1848
    compatible mode.
    
    Also, add gameport support and remove an unused mpu field.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index c739374af20e..279be505b72e 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -54,6 +54,7 @@ static int irq[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_IRQ;
 static int mpu_irq[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_IRQ;
 static int dma[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_DMA;
 static int dma2[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_DMA;
+static bool joystick[SNDRV_CARDS] __devinitdata;
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index number for SoundScape soundcard");
@@ -79,6 +80,9 @@ MODULE_PARM_DESC(dma, "DMA # for SoundScape driver.");
 module_param_array(dma2, int, NULL, 0444);
 MODULE_PARM_DESC(dma2, "DMA2 # for SoundScape driver.");
 
+module_param_array(joystick, bool, NULL, 0444);
+MODULE_PARM_DESC(joystick, "Enable gameport.");
+
 #ifdef CONFIG_PNP
 static int isa_registered;
 static int pnp_registered;
@@ -145,7 +149,6 @@ struct soundscape {
 	struct resource *io_res;
 	struct resource *wss_res;
 	struct snd_wss *chip;
-	struct snd_mpu401 *mpu;
 
 	unsigned char midi_vol;
 };
@@ -815,7 +818,6 @@ static int __devinit create_mpu401(struct snd_card *card, int devnum, unsigned l
 		mpu->open_input = mpu401_open;
 		mpu->open_output = mpu401_open;
 		mpu->private_data = sscape;
-		sscape->mpu = mpu;
 
 		initialise_mpu401(mpu);
 	}
@@ -836,12 +838,30 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
 	register struct soundscape *sscape = get_card_soundscape(card);
 	struct snd_wss *chip;
 	int err;
+	int codec_type = WSS_HW_DETECT;
+
+	switch (sscape->type) {
+	case MEDIA_FX:
+	case SSCAPE:
+		/*
+		 * There are some freak examples of early Soundscape cards
+		 * with CS4231 instead of AD1848/CS4248. Unfortunately, the
+		 * CS4231 works only in CS4248 compatibility mode on
+		 * these cards so force it.
+		 */
+		if (sscape->ic_type != IC_OPUS)
+			codec_type = WSS_HW_AD1848;
+		break;
 
-	if (sscape->type == SSCAPE_VIVO)
+	case SSCAPE_VIVO:
 		port += 4;
+		break;
+	default:
+		break;
+	}
 
 	err = snd_wss_create(card, port, -1, irq, dma1, dma2,
-			     WSS_HW_DETECT, WSS_HWSHARE_DMA1, &chip);
+			     codec_type, WSS_HWSHARE_DMA1, &chip);
 	if (!err) {
 		unsigned long flags;
 		struct snd_pcm *pcm;
@@ -927,6 +947,7 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	struct resource *wss_res;
 	unsigned long flags;
 	int err;
+	int val;
 	const char *name;
 
 	/*
@@ -1026,6 +1047,10 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	sscape_write_unsafe(sscape->io_base, GA_DMAB_REG, 0x20);
 
 	mpu_irq_cfg |= mpu_irq_cfg << 2;
+	val = sscape_read_unsafe(sscape->io_base, GA_HMCTL_REG) & 0xF7;
+	if (joystick[dev])
+		val |= 8;
+	sscape_write_unsafe(sscape->io_base, GA_HMCTL_REG, val | 0x10);
 	sscape_write_unsafe(sscape->io_base, GA_INTCFG_REG, 0xf0 | mpu_irq_cfg);
 	sscape_write_unsafe(sscape->io_base,
 			    GA_CDCFG_REG, 0x09 | DMA_8BIT

commit bcde1f8a80d1bdfd43fb498996dfa89666fd7fe3
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Fri Oct 2 18:41:29 2009 +0200

    ALSA: sscape: remove MIDI instances counting with limit ULONG_MAX
    
    There is no sense to limit open MIDI connections with limit
    as high as ULONG_MAX.
    
    Also, convert more messages to use the snd_printk.
    
    Correct few old and misleading comments as well.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 1ce465cc66a8..c739374af20e 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -147,12 +147,6 @@ struct soundscape {
 	struct snd_wss *chip;
 	struct snd_mpu401 *mpu;
 
-	/*
-	 * The MIDI device won't work until we've loaded
-	 * its firmware via a hardware-dependent device IOCTL
-	 */
-	spinlock_t fwlock;
-	unsigned long midi_usage;
 	unsigned char midi_vol;
 };
 
@@ -164,11 +158,6 @@ static inline struct soundscape *get_card_soundscape(struct snd_card *c)
 	return (struct soundscape *) (c->private_data);
 }
 
-static inline struct soundscape *get_mpu401_soundscape(struct snd_mpu401 * mpu)
-{
-	return (struct soundscape *) (mpu->private_data);
-}
-
 /*
  * Allocates some kernel memory that we can use for DMA.
  * I think this means that the memory has to map to
@@ -179,7 +168,9 @@ static struct snd_dma_buffer *get_dmabuf(struct snd_dma_buffer *buf, unsigned lo
 	if (buf) {
 		if (snd_dma_alloc_pages_fallback(SNDRV_DMA_TYPE_DEV, snd_dma_isa_data(),
 						 size, buf) < 0) {
-			snd_printk(KERN_ERR "sscape: Failed to allocate %lu bytes for DMA\n", size);
+			snd_printk(KERN_ERR "sscape: Failed to allocate "
+					    "%lu bytes for DMA\n",
+					    size);
 			return NULL;
 		}
 	}
@@ -482,7 +473,8 @@ static int upload_dma_data(struct soundscape *s,
 			 */
 			spin_unlock_irqrestore(&s->lock, flags);
 
-			snd_printk(KERN_ERR "sscape: DMA upload has timed out\n");
+			snd_printk(KERN_ERR
+					"sscape: DMA upload has timed out\n");
 			ret = -EAGAIN;
 			goto _release_dma;
 		}
@@ -504,10 +496,12 @@ static int upload_dma_data(struct soundscape *s,
 	 */
 	ret = 0;
 	if (!obp_startup_ack(s, 5000)) {
-		snd_printk(KERN_ERR "sscape: No response from on-board processor after upload\n");
+		snd_printk(KERN_ERR "sscape: No response "
+				    "from on-board processor after upload\n");
 		ret = -EAGAIN;
 	} else if (!host_startup_ack(s, 5000)) {
-		snd_printk(KERN_ERR "sscape: SoundScape failed to initialise\n");
+		snd_printk(KERN_ERR
+				"sscape: SoundScape failed to initialise\n");
 		ret = -EAGAIN;
 	}
 
@@ -536,7 +530,7 @@ static int sscape_upload_bootblock(struct snd_card *card)
 
 	ret = request_firmware(&init_fw, "scope.cod", card->dev);
 	if (ret < 0) {
-		snd_printk(KERN_ERR "Error loading scope.cod");
+		snd_printk(KERN_ERR "sscape: Error loading scope.cod");
 		return ret;
 	}
 	ret = upload_dma_data(sscape, init_fw->data, init_fw->size);
@@ -554,7 +548,8 @@ static int sscape_upload_bootblock(struct snd_card *card)
 
 	data &= 0xf;
 	if (ret == 0 && data > 7) {
-		snd_printk(KERN_ERR "timeout reading firmware version\n");
+		snd_printk(KERN_ERR
+				"sscape: timeout reading firmware version\n");
 		ret = -EAGAIN;
 	}
 
@@ -575,12 +570,13 @@ static int sscape_upload_microcode(struct snd_card *card, int version)
 
 	err = request_firmware(&init_fw, name, card->dev);
 	if (err < 0) {
-		snd_printk(KERN_ERR "Error loading sndscape.co%d", version);
+		snd_printk(KERN_ERR "sscape: Error loading sndscape.co%d",
+				version);
 		return err;
 	}
 	err = upload_dma_data(sscape, init_fw->data, init_fw->size);
 	if (err == 0)
-		snd_printk(KERN_INFO "MIDI firmware loaded %d KBs\n",
+		snd_printk(KERN_INFO "sscape: MIDI firmware loaded %d KBs\n",
 				init_fw->size >> 10);
 
 	release_firmware(init_fw);
@@ -750,7 +746,6 @@ static int __devinit detect_sscape(struct soundscape *s, long wss_io)
 		msleep(1);
 		spin_lock_irqsave(&s->lock, flags);
 	}
-	snd_printd(KERN_INFO "init delay = %d ms\n", d);
 
 	if ((inb(wss_io) & 0x80) != 0)
 		goto _done;
@@ -774,7 +769,6 @@ static int __devinit detect_sscape(struct soundscape *s, long wss_io)
 		msleep(1);
 		spin_lock_irqsave(&s->lock, flags);
 	}
-	snd_printd(KERN_INFO "init delay = %d ms\n", d);
 
 	/*
 	 * SoundScape successfully detected!
@@ -794,38 +788,13 @@ static int __devinit detect_sscape(struct soundscape *s, long wss_io)
  */
 static int mpu401_open(struct snd_mpu401 * mpu)
 {
-	int err;
-
 	if (!verify_mpu401(mpu)) {
-		snd_printk(KERN_ERR "sscape: MIDI disabled, please load firmware\n");
-		err = -ENODEV;
-	} else {
-		register struct soundscape *sscape = get_mpu401_soundscape(mpu);
-		unsigned long flags;
-
-		spin_lock_irqsave(&sscape->fwlock, flags);
-
-		if (sscape->midi_usage == ULONG_MAX) {
-			err = -EBUSY;
-		} else {
-			++(sscape->midi_usage);
-			err = 0;
-		}
-
-		spin_unlock_irqrestore(&sscape->fwlock, flags);
+		snd_printk(KERN_ERR "sscape: MIDI disabled, "
+				    "please load firmware\n");
+		return -ENODEV;
 	}
 
-	return err;
-}
-
-static void mpu401_close(struct snd_mpu401 * mpu)
-{
-	register struct soundscape *sscape = get_mpu401_soundscape(mpu);
-	unsigned long flags;
-
-	spin_lock_irqsave(&sscape->fwlock, flags);
-	--(sscape->midi_usage);
-	spin_unlock_irqrestore(&sscape->fwlock, flags);
+	return 0;
 }
 
 /*
@@ -845,8 +814,6 @@ static int __devinit create_mpu401(struct snd_card *card, int devnum, unsigned l
 		struct snd_mpu401 *mpu = (struct snd_mpu401 *) rawmidi->private_data;
 		mpu->open_input = mpu401_open;
 		mpu->open_output = mpu401_open;
-		mpu->close_input = mpu401_close;
-		mpu->close_output = mpu401_close;
 		mpu->private_data = sscape;
 		sscape->mpu = mpu;
 
@@ -993,13 +960,13 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	}
 
 	spin_lock_init(&sscape->lock);
-	spin_lock_init(&sscape->fwlock);
 	sscape->io_res = io_res;
 	sscape->wss_res = wss_res;
 	sscape->io_base = port[dev];
 
 	if (!detect_sscape(sscape, wss_port[dev])) {
-		printk(KERN_ERR "sscape: hardware not detected at 0x%x\n", sscape->io_base);
+		printk(KERN_ERR "sscape: hardware not detected at 0x%x\n",
+			sscape->io_base);
 		err = -ENODEV;
 		goto _release_dma;
 	}
@@ -1036,7 +1003,7 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 
 	mpu_irq_cfg = get_irq_config(sscape->type, mpu_irq[dev]);
 	if (mpu_irq_cfg == INVALID_IRQ) {
-		printk(KERN_ERR "sscape: Invalid IRQ %d\n", mpu_irq[dev]);
+		snd_printk(KERN_ERR "sscape: Invalid IRQ %d\n", mpu_irq[dev]);
 		return -ENXIO;
 	}
 
@@ -1073,8 +1040,9 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	err = create_ad1845(card, wss_port[dev], irq[dev],
 			    dma[dev], dma2[dev]);
 	if (err < 0) {
-		printk(KERN_ERR "sscape: No AD1845 device at 0x%lx, IRQ %d\n",
-		       wss_port[dev], irq[dev]);
+		snd_printk(KERN_ERR
+				"sscape: No AD1845 device at 0x%lx, IRQ %d\n",
+				wss_port[dev], irq[dev]);
 		goto _release_dma;
 	}
 	strcpy(card->driver, "SoundScape");
@@ -1094,7 +1062,7 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 			err = create_mpu401(card, MIDI_DEVNUM, port[dev],
 					    mpu_irq[dev]);
 			if (err < 0) {
-				printk(KERN_ERR "sscape: Failed to create "
+				snd_printk(KERN_ERR "sscape: Failed to create "
 						"MPU-401 device at 0x%lx\n",
 						port[dev]);
 				goto _release_dma;
@@ -1191,7 +1159,7 @@ static int __devinit snd_sscape_probe(struct device *pdev, unsigned int dev)
 		goto _release_card;
 
 	if ((ret = snd_card_register(card)) < 0) {
-		printk(KERN_ERR "sscape: Failed to register sound card\n");
+		snd_printk(KERN_ERR "sscape: Failed to register sound card\n");
 		goto _release_card;
 	}
 	dev_set_drvdata(pdev, card);
@@ -1250,18 +1218,7 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 	 * We have found a candidate ISA PnP card. Now we
 	 * have to check that it has the devices that we
 	 * expect it to have.
-	 *
-	 * We will NOT try and autoconfigure all of the resources
-	 * needed and then activate the card as we are assuming that
-	 * has already been done at boot-time using /proc/isapnp.
-	 * We shall simply try to give each active card the resources
-	 * that it wants. This is a sensible strategy for a modular
-	 * system where unused modules are unloaded regularly.
-	 *
-	 * This strategy is utterly useless if we compile the driver
-	 * into the kernel, of course.
 	 */
-	// printk(KERN_INFO "sscape: %s\n", card->name);
 
 	/*
 	 * Check that we still have room for another sound card ...
@@ -1272,7 +1229,7 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 
 	if (!pnp_is_active(dev)) {
 		if (pnp_activate_dev(dev) < 0) {
-			printk(KERN_INFO "sscape: device is inactive\n");
+			snd_printk(KERN_INFO "sscape: device is inactive\n");
 			return -EBUSY;
 		}
 	}
@@ -1317,7 +1274,7 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 		goto _release_card;
 
 	if ((ret = snd_card_register(card)) < 0) {
-		printk(KERN_ERR "sscape: Failed to register sound card\n");
+		snd_printk(KERN_ERR "sscape: Failed to register sound card\n");
 		goto _release_card;
 	}
 

commit acd47100914b2896d0699febefd077f85c4dd272
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Thu Oct 1 00:10:34 2009 +0200

    ALSA: sscape: convert to firmware loader framework
    
    The conversion solves the problem that firmware size was set to 64KB
    while non PnP cards have 128KB firmware files.
    
    An additional firmware initialization code has been moved from the OSS
    driver.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index b11c35f6aefe..1ce465cc66a8 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -1,5 +1,5 @@
 /*
- *   Low-level ALSA driver for the ENSONIQ SoundScape PnP
+ *   Low-level ALSA driver for the ENSONIQ SoundScape
  *   Copyright (c) by Chris Rankin
  *
  *   This driver was written in part using information obtained from
@@ -25,22 +25,26 @@
 #include <linux/err.h>
 #include <linux/isa.h>
 #include <linux/delay.h>
+#include <linux/firmware.h>
 #include <linux/pnp.h>
 #include <linux/spinlock.h>
 #include <linux/moduleparam.h>
 #include <asm/dma.h>
 #include <sound/core.h>
-#include <sound/hwdep.h>
 #include <sound/wss.h>
 #include <sound/mpu401.h>
 #include <sound/initval.h>
 
-#include <sound/sscape_ioctl.h>
-
 
 MODULE_AUTHOR("Chris Rankin");
-MODULE_DESCRIPTION("ENSONIQ SoundScape PnP driver");
+MODULE_DESCRIPTION("ENSONIQ SoundScape driver");
 MODULE_LICENSE("GPL");
+MODULE_FIRMWARE("sndscape.co0");
+MODULE_FIRMWARE("sndscape.co1");
+MODULE_FIRMWARE("sndscape.co2");
+MODULE_FIRMWARE("sndscape.co3");
+MODULE_FIRMWARE("sndscape.co4");
+MODULE_FIRMWARE("scope.cod");
 
 static int index[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_IDX;
 static char* id[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_STR;
@@ -142,14 +146,12 @@ struct soundscape {
 	struct resource *wss_res;
 	struct snd_wss *chip;
 	struct snd_mpu401 *mpu;
-	struct snd_hwdep *hw;
 
 	/*
 	 * The MIDI device won't work until we've loaded
 	 * its firmware via a hardware-dependent device IOCTL
 	 */
 	spinlock_t fwlock;
-	int hw_in_use;
 	unsigned long midi_usage;
 	unsigned char midi_vol;
 };
@@ -167,12 +169,6 @@ static inline struct soundscape *get_mpu401_soundscape(struct snd_mpu401 * mpu)
 	return (struct soundscape *) (mpu->private_data);
 }
 
-static inline struct soundscape *get_hwdep_soundscape(struct snd_hwdep * hw)
-{
-	return (struct soundscape *) (hw->private_data);
-}
-
-
 /*
  * Allocates some kernel memory that we can use for DMA.
  * I think this means that the memory has to map to
@@ -393,12 +389,12 @@ static int obp_startup_ack(struct soundscape *s, unsigned timeout)
 
 	do {
 		unsigned long flags;
-		unsigned char x;
+		int x;
 
 		spin_lock_irqsave(&s->lock, flags);
-		x = inb(HOST_DATA_IO(s->io_base));
+		x = host_read_unsafe(s->io_base);
 		spin_unlock_irqrestore(&s->lock, flags);
-		if ((x & 0xfe) == 0xfe)
+		if (x == 0xfe || x == 0xff)
 			return 1;
 
 		msleep(10);
@@ -420,10 +416,10 @@ static int host_startup_ack(struct soundscape *s, unsigned timeout)
 
 	do {
 		unsigned long flags;
-		unsigned char x;
+		int x;
 
 		spin_lock_irqsave(&s->lock, flags);
-		x = inb(HOST_DATA_IO(s->io_base));
+		x = host_read_unsafe(s->io_base);
 		spin_unlock_irqrestore(&s->lock, flags);
 		if (x == 0xfe)
 			return 1;
@@ -438,14 +434,14 @@ static int host_startup_ack(struct soundscape *s, unsigned timeout)
  * Upload a byte-stream into the SoundScape using DMA channel A.
  */
 static int upload_dma_data(struct soundscape *s,
-                           const unsigned char __user *data,
+			   const unsigned char *data,
                            size_t size)
 {
 	unsigned long flags;
 	struct snd_dma_buffer dma;
 	int ret;
 
-	if (!get_dmabuf(&dma, PAGE_ALIGN(size)))
+	if (!get_dmabuf(&dma, PAGE_ALIGN(32 * 1024)))
 		return -ENOMEM;
 
 	spin_lock_irqsave(&s->lock, flags);
@@ -458,7 +454,6 @@ static int upload_dma_data(struct soundscape *s,
 	/*
 	 * Enable the DMA channels and configure them ...
 	 */
-	sscape_write_unsafe(s->io_base, GA_DMACFG_REG, 0x50);
 	sscape_write_unsafe(s->io_base, GA_DMAA_REG, (s->chip->dma1 << 4) | DMA_8BIT);
 	sscape_write_unsafe(s->io_base, GA_DMAB_REG, 0x20);
 
@@ -468,35 +463,17 @@ static int upload_dma_data(struct soundscape *s,
 	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, sscape_read_unsafe(s->io_base, GA_HMCTL_REG) | 0x80);
 
 	/*
-	 * Upload the user's data (firmware?) to the SoundScape
+	 * Upload the firmware to the SoundScape
 	 * board through the DMA channel ...
 	 */
 	while (size != 0) {
 		unsigned long len;
 
-		/*
-		 * Apparently, copying to/from userspace can sleep.
-		 * We are therefore forbidden from holding any
-		 * spinlocks while we copy ...
-		 */
-		spin_unlock_irqrestore(&s->lock, flags);
-
-		/*
-		 * Remember that the data that we want to DMA
-		 * comes from USERSPACE. We have already verified
-		 * the userspace pointer ...
-		 */
 		len = min(size, dma.bytes);
-		len -= __copy_from_user(dma.area, data, len);
+		memcpy(dma.area, data, len);
 		data += len;
 		size -= len;
 
-		/*
-		 * Grab that spinlock again, now that we've
-		 * finished copying!
-		 */
-		spin_lock_irqsave(&s->lock, flags);
-
 		snd_dma_program(s->chip->dma1, dma.addr, len, DMA_MODE_WRITE);
 		sscape_start_dma_unsafe(s->io_base, GA_DMAA_REG);
 		if (!sscape_wait_dma_unsafe(s->io_base, GA_DMAA_REG, 5000)) {
@@ -512,6 +489,7 @@ static int upload_dma_data(struct soundscape *s,
 	} /* while */
 
 	set_host_mode_unsafe(s->io_base);
+	outb(0x0, s->io_base);
 
 	/*
 	 * Boot the board ... (I think)
@@ -537,7 +515,7 @@ static int upload_dma_data(struct soundscape *s,
 	/*
 	 * NOTE!!! We are NOT holding any spinlocks at this point !!!
 	 */
-	sscape_write(s, GA_DMAA_REG, (s->ic_type == IC_ODIE ? 0x70 : 0x40));
+	sscape_write(s, GA_DMAA_REG, (s->ic_type == IC_OPUS ? 0x40 : 0x70));
 	free_dmabuf(&dma);
 
 	return ret;
@@ -547,162 +525,69 @@ static int upload_dma_data(struct soundscape *s,
  * Upload the bootblock(?) into the SoundScape. The only
  * purpose of this block of code seems to be to tell
  * us which version of the microcode we should be using.
- *
- * NOTE: The boot-block data resides in USER-SPACE!!!
- *       However, we have already verified its memory
- *       addresses by the time we get here.
  */
-static int sscape_upload_bootblock(struct soundscape *sscape, struct sscape_bootblock __user *bb)
+static int sscape_upload_bootblock(struct snd_card *card)
 {
+	struct soundscape *sscape = get_card_soundscape(card);
 	unsigned long flags;
+	const struct firmware *init_fw = NULL;
 	int data = 0;
 	int ret;
 
-	ret = upload_dma_data(sscape, bb->code, sizeof(bb->code));
-
-	spin_lock_irqsave(&sscape->lock, flags);
-	if (ret == 0) {
-		data = host_read_ctrl_unsafe(sscape->io_base, 100);
-	}
-	set_midi_mode_unsafe(sscape->io_base);
-	spin_unlock_irqrestore(&sscape->lock, flags);
-
-	if (ret == 0) {
-		if (data < 0) {
-			snd_printk(KERN_ERR "sscape: timeout reading firmware version\n");
-			ret = -EAGAIN;
-		}
-		else if (__copy_to_user(&bb->version, &data, sizeof(bb->version))) {
-			ret = -EFAULT;
-		}
+	ret = request_firmware(&init_fw, "scope.cod", card->dev);
+	if (ret < 0) {
+		snd_printk(KERN_ERR "Error loading scope.cod");
+		return ret;
 	}
+	ret = upload_dma_data(sscape, init_fw->data, init_fw->size);
 
-	return ret;
-}
+	release_firmware(init_fw);
 
-/*
- * Upload the microcode into the SoundScape. The
- * microcode is 64K of data, and if we try to copy
- * it into a local variable then we will SMASH THE
- * KERNEL'S STACK! We therefore leave it in USER
- * SPACE, and save ourselves from copying it at all.
- */
-static int sscape_upload_microcode(struct soundscape *sscape,
-                                   const struct sscape_microcode __user *mc)
-{
-	unsigned long flags;
-	char __user *code;
-	int err;
-
-	/*
-	 * We are going to have to copy this data into a special
-	 * DMA-able buffer before we can upload it. We shall therefore
-	 * just check that the data pointer is valid for now.
-	 *
-	 * NOTE: This buffer is 64K long! That's WAY too big to
-	 *       copy into a stack-temporary anyway.
-	 */
-	if ( get_user(code, &mc->code) ||
-	     !access_ok(VERIFY_READ, code, SSCAPE_MICROCODE_SIZE) )
-		return -EFAULT;
+	spin_lock_irqsave(&sscape->lock, flags);
+	if (ret == 0)
+		data = host_read_ctrl_unsafe(sscape->io_base, 100);
 
-	if ((err = upload_dma_data(sscape, code, SSCAPE_MICROCODE_SIZE)) == 0) {
-		snd_printk(KERN_INFO "sscape: MIDI firmware loaded\n");
-	}
+	if (data & 0x10)
+		sscape_write_unsafe(sscape->io_base, GA_SMCFGA_REG, 0x2f);
 
-	spin_lock_irqsave(&sscape->lock, flags);
-	set_midi_mode_unsafe(sscape->io_base);
 	spin_unlock_irqrestore(&sscape->lock, flags);
 
-	initialise_mpu401(sscape->mpu);
+	data &= 0xf;
+	if (ret == 0 && data > 7) {
+		snd_printk(KERN_ERR "timeout reading firmware version\n");
+		ret = -EAGAIN;
+	}
 
-	return err;
+	return (ret == 0) ? data : ret;
 }
 
 /*
- * Hardware-specific device functions, to implement special
- * IOCTLs for the SoundScape card. This is how we upload
- * the microcode into the card, for example, and so we
- * must ensure that no two processes can open this device
- * simultaneously, and that we can't open it at all if
- * someone is using the MIDI device.
+ * Upload the microcode into the SoundScape.
  */
-static int sscape_hw_open(struct snd_hwdep * hw, struct file *file)
+static int sscape_upload_microcode(struct snd_card *card, int version)
 {
-	register struct soundscape *sscape = get_hwdep_soundscape(hw);
-	unsigned long flags;
+	struct soundscape *sscape = get_card_soundscape(card);
+	const struct firmware *init_fw = NULL;
+	char name[14];
 	int err;
 
-	spin_lock_irqsave(&sscape->fwlock, flags);
+	snprintf(name, sizeof(name), "sndscape.co%d", version);
 
-	if ((sscape->midi_usage != 0) || sscape->hw_in_use) {
-		err = -EBUSY;
-	} else {
-		sscape->hw_in_use = 1;
-		err = 0;
+	err = request_firmware(&init_fw, name, card->dev);
+	if (err < 0) {
+		snd_printk(KERN_ERR "Error loading sndscape.co%d", version);
+		return err;
 	}
+	err = upload_dma_data(sscape, init_fw->data, init_fw->size);
+	if (err == 0)
+		snd_printk(KERN_INFO "MIDI firmware loaded %d KBs\n",
+				init_fw->size >> 10);
 
-	spin_unlock_irqrestore(&sscape->fwlock, flags);
-	return err;
-}
-
-static int sscape_hw_release(struct snd_hwdep * hw, struct file *file)
-{
-	register struct soundscape *sscape = get_hwdep_soundscape(hw);
-	unsigned long flags;
-
-	spin_lock_irqsave(&sscape->fwlock, flags);
-	sscape->hw_in_use = 0;
-	spin_unlock_irqrestore(&sscape->fwlock, flags);
-	return 0;
-}
-
-static int sscape_hw_ioctl(struct snd_hwdep * hw, struct file *file,
-                           unsigned int cmd, unsigned long arg)
-{
-	struct soundscape *sscape = get_hwdep_soundscape(hw);
-	int err = -EBUSY;
-
-	switch (cmd) {
-	case SND_SSCAPE_LOAD_BOOTB:
-		{
-			register struct sscape_bootblock __user *bb = (struct sscape_bootblock __user *) arg;
-
-			/*
-			 * We are going to have to copy this data into a special
-			 * DMA-able buffer before we can upload it. We shall therefore
-			 * just check that the data pointer is valid for now ...
-			 */
-			if ( !access_ok(VERIFY_READ, bb->code, sizeof(bb->code)) )
-				return -EFAULT;
-
-			/*
-			 * Now check that we can write the firmware version number too...
-			 */
-			if ( !access_ok(VERIFY_WRITE, &bb->version, sizeof(bb->version)) )
-				return -EFAULT;
-
-			err = sscape_upload_bootblock(sscape, bb);
-		}
-		break;
-
-	case SND_SSCAPE_LOAD_MCODE:
-		{
-			register const struct sscape_microcode __user *mc = (const struct sscape_microcode __user *) arg;
-
-			err = sscape_upload_microcode(sscape, mc);
-		}
-		break;
-
-	default:
-		err = -EINVAL;
-		break;
-	} /* switch */
+	release_firmware(init_fw);
 
 	return err;
 }
 
-
 /*
  * Mixer control for the SoundScape's MIDI device.
  */
@@ -920,7 +805,7 @@ static int mpu401_open(struct snd_mpu401 * mpu)
 
 		spin_lock_irqsave(&sscape->fwlock, flags);
 
-		if (sscape->hw_in_use || (sscape->midi_usage == ULONG_MAX)) {
+		if (sscape->midi_usage == ULONG_MAX) {
 			err = -EBUSY;
 		} else {
 			++(sscape->midi_usage);
@@ -1053,13 +938,6 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
 			}
 		}
 
-		strcpy(card->driver, "SoundScape");
-		strcpy(card->shortname, pcm->name);
-		snprintf(card->longname, sizeof(card->longname),
-			 "%s at 0x%lx, IRQ %d, DMA1 %d, DMA2 %d\n",
-			 pcm->name, chip->port, chip->irq,
-			 chip->dma1, chip->dma2);
-
 		sscape->chip = chip;
 	}
 
@@ -1162,29 +1040,6 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 		return -ENXIO;
 	}
 
-	if (sscape->type != SSCAPE_VIVO) {
-		/*
-		 * Now create the hardware-specific device so that we can
-		 * load the microcode into the on-board processor.
-		 * We cannot use the MPU-401 MIDI system until this firmware
-		 * has been loaded into the card.
-		 */
-		err = snd_hwdep_new(card, "MC68EC000", 0, &(sscape->hw));
-		if (err < 0) {
-			printk(KERN_ERR "sscape: Failed to create "
-					"firmware device\n");
-			goto _release_dma;
-		}
-		strlcpy(sscape->hw->name, "SoundScape M68K",
-			sizeof(sscape->hw->name));
-		sscape->hw->name[sizeof(sscape->hw->name) - 1] = '\0';
-		sscape->hw->iface = SNDRV_HWDEP_IFACE_SSCAPE;
-		sscape->hw->ops.open = sscape_hw_open;
-		sscape->hw->ops.release = sscape_hw_release;
-		sscape->hw->ops.ioctl = sscape_hw_ioctl;
-		sscape->hw->private_data = sscape;
-	}
-
 	/*
 	 * Tell the on-board devices where their resources are (I think -
 	 * I can't be sure without a datasheet ... So many magic values!)
@@ -1222,28 +1077,56 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 		       wss_port[dev], irq[dev]);
 		goto _release_dma;
 	}
+	strcpy(card->driver, "SoundScape");
+	strcpy(card->shortname, name);
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s at 0x%lx, IRQ %d, DMA1 %d, DMA2 %d\n",
+		 name, sscape->chip->port, sscape->chip->irq,
+		 sscape->chip->dma1, sscape->chip->dma2);
+
 #define MIDI_DEVNUM  0
 	if (sscape->type != SSCAPE_VIVO) {
-		err = create_mpu401(card, MIDI_DEVNUM, port[dev], mpu_irq[dev]);
-		if (err < 0) {
-			printk(KERN_ERR "sscape: Failed to create "
-					"MPU-401 device at 0x%lx\n",
-					port[dev]);
-			goto _release_dma;
-		}
+		err = sscape_upload_bootblock(card);
+		if (err >= 0)
+			err = sscape_upload_microcode(card, err);
 
-		/*
-		 * Enable the master IRQ ...
-		 */
-		sscape_write(sscape, GA_INTENA_REG, 0x80);
-
-		/*
-		 * Initialize mixer
-		 */
-		sscape->midi_vol = 0;
-		host_write_ctrl_unsafe(sscape->io_base, CMD_SET_MIDI_VOL, 100);
-		host_write_ctrl_unsafe(sscape->io_base, 0, 100);
-		host_write_ctrl_unsafe(sscape->io_base, CMD_XXX_MIDI_VOL, 100);
+		if (err == 0) {
+			err = create_mpu401(card, MIDI_DEVNUM, port[dev],
+					    mpu_irq[dev]);
+			if (err < 0) {
+				printk(KERN_ERR "sscape: Failed to create "
+						"MPU-401 device at 0x%lx\n",
+						port[dev]);
+				goto _release_dma;
+			}
+
+			/*
+			 * Enable the master IRQ ...
+			 */
+			sscape_write(sscape, GA_INTENA_REG, 0x80);
+
+			/*
+			 * Initialize mixer
+			 */
+			spin_lock_irqsave(&sscape->lock, flags);
+			sscape->midi_vol = 0;
+			host_write_ctrl_unsafe(sscape->io_base,
+						CMD_SET_MIDI_VOL, 100);
+			host_write_ctrl_unsafe(sscape->io_base,
+						sscape->midi_vol, 100);
+			host_write_ctrl_unsafe(sscape->io_base,
+						CMD_XXX_MIDI_VOL, 100);
+			host_write_ctrl_unsafe(sscape->io_base,
+						sscape->midi_vol, 100);
+			host_write_ctrl_unsafe(sscape->io_base,
+						CMD_SET_EXTMIDI, 100);
+			host_write_ctrl_unsafe(sscape->io_base,
+						0, 100);
+			host_write_ctrl_unsafe(sscape->io_base, CMD_ACK, 100);
+
+			set_midi_mode_unsafe(sscape->io_base);
+			spin_unlock_irqrestore(&sscape->lock, flags);
+		}
 	}
 
 	/*
@@ -1301,11 +1184,12 @@ static int __devinit snd_sscape_probe(struct device *pdev, unsigned int dev)
 	sscape->type = SSCAPE;
 
 	dma[dev] &= 0x03;
+	snd_card_set_dev(card, pdev);
+
 	ret = create_sscape(dev, card);
 	if (ret < 0)
 		goto _release_card;
 
-	snd_card_set_dev(card, pdev);
 	if ((ret = snd_card_register(card)) < 0) {
 		printk(KERN_ERR "sscape: Failed to register sound card\n");
 		goto _release_card;
@@ -1426,12 +1310,12 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 		wss_port[idx] = pnp_port_start(dev, 1);
 		dma2[idx] = pnp_dma(dev, 1);
 	}
+	snd_card_set_dev(card, &pcard->card->dev);
 
 	ret = create_sscape(idx, card);
 	if (ret < 0)
 		goto _release_card;
 
-	snd_card_set_dev(card, &pcard->card->dev);
 	if ((ret = snd_card_register(card)) < 0) {
 		printk(KERN_ERR "sscape: Failed to register sound card\n");
 		goto _release_card;

commit f0968e3f7a8ea30728d2580d3043a30ea9994ec6
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Sun Sep 27 23:08:40 2009 +0200

    ALSA: sscape: add supoort for SPEA Media FX/Reveal SC-600
    
    Move code from the OSS sscape driver in order to support old Soundscape OEM models.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 66187122377c..b11c35f6aefe 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -127,7 +127,8 @@ enum GA_REG {
 
 
 enum card_type {
-	SSCAPE,
+	MEDIA_FX,	/* Sequoia S-1000 */
+	SSCAPE,		/* Sequoia S-2000 */
 	SSCAPE_PNP,
 	SSCAPE_VIVO,
 };
@@ -784,20 +785,25 @@ static struct snd_kcontrol_new midi_mixer_ctl = {
  * These IRQs are encoded as bit patterns so that they can be
  * written to the control registers.
  */
-static unsigned __devinit get_irq_config(int irq)
+static unsigned __devinit get_irq_config(int sscape_type, int irq)
 {
 	static const int valid_irq[] = { 9, 5, 7, 10 };
+	static const int old_irq[] = { 9, 7, 5, 15 };
 	unsigned cfg;
 
-	for (cfg = 0; cfg < ARRAY_SIZE(valid_irq); ++cfg) {
-		if (irq == valid_irq[cfg])
-			return cfg;
-	} /* for */
+	if (sscape_type == MEDIA_FX) {
+		for (cfg = 0; cfg < ARRAY_SIZE(old_irq); ++cfg)
+			if (irq == old_irq[cfg])
+				return cfg;
+	} else {
+		for (cfg = 0; cfg < ARRAY_SIZE(valid_irq); ++cfg)
+			if (irq == valid_irq[cfg])
+				return cfg;
+	}
 
 	return INVALID_IRQ;
 }
 
-
 /*
  * Perform certain arcane port-checks to see whether there
  * is a SoundScape board lurking behind the given ports.
@@ -842,11 +848,39 @@ static int __devinit detect_sscape(struct soundscape *s, long wss_io)
 	if (s->type != SSCAPE_VIVO && (d & 0x9f) != 0x0e)
 		goto _done;
 
-	d  = sscape_read_unsafe(s->io_base, GA_HMCTL_REG) & 0x3f;
-	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, d | 0xc0);
+	if (s->ic_type == IC_OPUS)
+		activate_ad1845_unsafe(s->io_base);
 
 	if (s->type == SSCAPE_VIVO)
 		wss_io += 4;
+
+	d  = sscape_read_unsafe(s->io_base, GA_HMCTL_REG) & 0x3f;
+	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, d | 0xc0);
+
+	/* wait for WSS codec */
+	for (d = 0; d < 500; d++) {
+		if ((inb(wss_io) & 0x80) == 0)
+			break;
+		spin_unlock_irqrestore(&s->lock, flags);
+		msleep(1);
+		spin_lock_irqsave(&s->lock, flags);
+	}
+	snd_printd(KERN_INFO "init delay = %d ms\n", d);
+
+	if ((inb(wss_io) & 0x80) != 0)
+		goto _done;
+
+	if (inb(wss_io + 2) == 0xff)
+		goto _done;
+
+	d  = sscape_read_unsafe(s->io_base, GA_HMCTL_REG) & 0x3f;
+	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, d);
+
+	if ((inb(wss_io) & 0x80) != 0)
+		s->type = MEDIA_FX;
+
+	d = sscape_read_unsafe(s->io_base, GA_HMCTL_REG) & 0x3f;
+	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, d | 0xc0);
 	/* wait for WSS codec */
 	for (d = 0; d < 500; d++) {
 		if ((inb(wss_io) & 0x80) == 0)
@@ -954,9 +988,6 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
 	if (sscape->type == SSCAPE_VIVO)
 		port += 4;
 
-	if (dma1 == dma2)
-		dma2 = -1;
-
 	err = snd_wss_create(card, port, -1, irq, dma1, dma2,
 			     WSS_HW_DETECT, WSS_HWSHARE_DMA1, &chip);
 	if (!err) {
@@ -1051,21 +1082,7 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	struct resource *wss_res;
 	unsigned long flags;
 	int err;
-
-	/*
-	 * Check that the user didn't pass us garbage data ...
-	 */
-	irq_cfg = get_irq_config(irq[dev]);
-	if (irq_cfg == INVALID_IRQ) {
-		snd_printk(KERN_ERR "sscape: Invalid IRQ %d\n", irq[dev]);
-		return -ENXIO;
-	}
-
-	mpu_irq_cfg = get_irq_config(mpu_irq[dev]);
-	if (mpu_irq_cfg == INVALID_IRQ) {
-		printk(KERN_ERR "sscape: Invalid IRQ %d\n", mpu_irq[dev]);
-		return -ENXIO;
-	}
+	const char *name;
 
 	/*
 	 * Grab IO ports that we will need to probe so that we
@@ -1109,8 +1126,41 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 		goto _release_dma;
 	}
 
-	printk(KERN_INFO "sscape: hardware detected at 0x%x, using IRQ %d, DMA %d\n",
-			 sscape->io_base, irq[dev], dma[dev]);
+	switch (sscape->type) {
+	case MEDIA_FX:
+		name = "MediaFX/SoundFX";
+		break;
+	case SSCAPE:
+		name = "Soundscape";
+		break;
+	case SSCAPE_PNP:
+		name = "Soundscape PnP";
+		break;
+	case SSCAPE_VIVO:
+		name = "Soundscape VIVO";
+		break;
+	default:
+		name = "unknown Soundscape";
+		break;
+	}
+
+	printk(KERN_INFO "sscape: %s card detected at 0x%x, using IRQ %d, DMA %d\n",
+			 name, sscape->io_base, irq[dev], dma[dev]);
+
+	/*
+	 * Check that the user didn't pass us garbage data ...
+	 */
+	irq_cfg = get_irq_config(sscape->type, irq[dev]);
+	if (irq_cfg == INVALID_IRQ) {
+		snd_printk(KERN_ERR "sscape: Invalid IRQ %d\n", irq[dev]);
+		return -ENXIO;
+	}
+
+	mpu_irq_cfg = get_irq_config(sscape->type, mpu_irq[dev]);
+	if (mpu_irq_cfg == INVALID_IRQ) {
+		printk(KERN_ERR "sscape: Invalid IRQ %d\n", mpu_irq[dev]);
+		return -ENXIO;
+	}
 
 	if (sscape->type != SSCAPE_VIVO) {
 		/*
@@ -1141,8 +1191,6 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	 */
 	spin_lock_irqsave(&sscape->lock, flags);
 
-	activate_ad1845_unsafe(sscape->io_base);
-
 	sscape_write_unsafe(sscape->io_base, GA_INTENA_REG, 0x00); /* disable */
 	sscape_write_unsafe(sscape->io_base, GA_SMCFGA_REG, 0x2e);
 	sscape_write_unsafe(sscape->io_base, GA_SMCFGB_REG, 0x00);
@@ -1151,12 +1199,12 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	 * Enable and configure the DMA channels ...
 	 */
 	sscape_write_unsafe(sscape->io_base, GA_DMACFG_REG, 0x50);
-	dma_cfg = (sscape->ic_type == IC_ODIE ? 0x70 : 0x40);
+	dma_cfg = (sscape->ic_type == IC_OPUS ? 0x40 : 0x70);
 	sscape_write_unsafe(sscape->io_base, GA_DMAA_REG, dma_cfg);
 	sscape_write_unsafe(sscape->io_base, GA_DMAB_REG, 0x20);
 
-	sscape_write_unsafe(sscape->io_base,
-	                    GA_INTCFG_REG, 0xf0 | (mpu_irq_cfg << 2) | mpu_irq_cfg);
+	mpu_irq_cfg |= mpu_irq_cfg << 2;
+	sscape_write_unsafe(sscape->io_base, GA_INTCFG_REG, 0xf0 | mpu_irq_cfg);
 	sscape_write_unsafe(sscape->io_base,
 			    GA_CDCFG_REG, 0x09 | DMA_8BIT
 			    | (dma[dev] << 4) | (irq_cfg << 1));

commit d0807323345f1cd8ab578b09aab04d10862e9414
Merge: d7b6df5d1af1 453e37b37521
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:36:21 2009 +0100

    Merge branch 'topic/sscape-fix' into for-linus

commit 453e37b37521b613f0927fcf53ccd93ad3a8b3ae
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Wed Feb 4 17:41:32 2009 +0100

    ALSA: sscape: drop redundant fields from soundscape struct
    
    The wss_base is disuised parameter for one function.
    It is converted to function parameter.
    
    The code_type is only set but never read.
    It is removed.
    
    The midi_vol is set only to 0 so it does not work
    as detection of change in midi volume. It is fixed.
    
    The xport variable is alias to the port[dev]. Use
    the port[dev] directly to increase readability.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 681e2237acb7..33c1258029f9 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -135,8 +135,6 @@ enum card_type {
 struct soundscape {
 	spinlock_t lock;
 	unsigned io_base;
-	unsigned wss_base;
-	int codec_type;
 	int ic_type;
 	enum card_type type;
 	struct resource *io_res;
@@ -726,13 +724,7 @@ static int sscape_midi_get(struct snd_kcontrol *kctl,
 	unsigned long flags;
 
 	spin_lock_irqsave(&s->lock, flags);
-	set_host_mode_unsafe(s->io_base);
-
-	if (host_write_ctrl_unsafe(s->io_base, CMD_GET_MIDI_VOL, 100)) {
-		uctl->value.integer.value[0] = host_read_ctrl_unsafe(s->io_base, 100);
-	}
-
-	set_midi_mode_unsafe(s->io_base);
+	uctl->value.integer.value[0] = s->midi_vol;
 	spin_unlock_irqrestore(&s->lock, flags);
 	return 0;
 }
@@ -767,6 +759,7 @@ static int sscape_midi_put(struct snd_kcontrol *kctl,
 	change = (host_write_ctrl_unsafe(s->io_base, CMD_SET_MIDI_VOL, 100)
 	          && host_write_ctrl_unsafe(s->io_base, ((unsigned char) uctl->value.integer. value[0]) & 127, 100)
 	          && host_write_ctrl_unsafe(s->io_base, CMD_XXX_MIDI_VOL, 100));
+	s->midi_vol = (unsigned char) uctl->value.integer.value[0] & 127;
       __skip_change:
 
 	/*
@@ -809,12 +802,11 @@ static unsigned __devinit get_irq_config(int irq)
  * Perform certain arcane port-checks to see whether there
  * is a SoundScape board lurking behind the given ports.
  */
-static int __devinit detect_sscape(struct soundscape *s)
+static int __devinit detect_sscape(struct soundscape *s, long wss_io)
 {
 	unsigned long flags;
 	unsigned d;
 	int retval = 0;
-	int codec = s->wss_base;
 
 	spin_lock_irqsave(&s->lock, flags);
 
@@ -830,13 +822,11 @@ static int __devinit detect_sscape(struct soundscape *s)
 	if ((d & 0x80) != 0)
 		goto _done;
 
-	if (d == 0) {
-		s->codec_type = 1;
+	if (d == 0)
 		s->ic_type = IC_ODIE;
-	} else if ((d & 0x60) != 0) {
-		s->codec_type = 2;
+	else if ((d & 0x60) != 0)
 		s->ic_type = IC_OPUS;
-	} else
+	else
 		goto _done;
 
 	outb(0xfa, ODIE_ADDR_IO(s->io_base));
@@ -856,10 +846,10 @@ static int __devinit detect_sscape(struct soundscape *s)
 	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, d | 0xc0);
 
 	if (s->type == SSCAPE_VIVO)
-		codec += 4;
+		wss_io += 4;
 	/* wait for WSS codec */
 	for (d = 0; d < 500; d++) {
-		if ((inb(codec) & 0x80) == 0)
+		if ((inb(wss_io) & 0x80) == 0)
 			break;
 		spin_unlock_irqrestore(&s->lock, flags);
 		msleep(1);
@@ -1057,7 +1047,6 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	unsigned dma_cfg;
 	unsigned irq_cfg;
 	unsigned mpu_irq_cfg;
-	unsigned xport;
 	struct resource *io_res;
 	struct resource *wss_res;
 	unsigned long flags;
@@ -1077,15 +1066,15 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 		printk(KERN_ERR "sscape: Invalid IRQ %d\n", mpu_irq[dev]);
 		return -ENXIO;
 	}
-	xport = port[dev];
 
 	/*
 	 * Grab IO ports that we will need to probe so that we
 	 * can detect and control this hardware ...
 	 */
-	io_res = request_region(xport, 8, "SoundScape");
+	io_res = request_region(port[dev], 8, "SoundScape");
 	if (!io_res) {
-		snd_printk(KERN_ERR "sscape: can't grab port 0x%x\n", xport);
+		snd_printk(KERN_ERR
+			   "sscape: can't grab port 0x%lx\n", port[dev]);
 		return -EBUSY;
 	}
 	wss_res = NULL;
@@ -1112,10 +1101,9 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	spin_lock_init(&sscape->fwlock);
 	sscape->io_res = io_res;
 	sscape->wss_res = wss_res;
-	sscape->io_base = xport;
-	sscape->wss_base = wss_port[dev];
+	sscape->io_base = port[dev];
 
-	if (!detect_sscape(sscape)) {
+	if (!detect_sscape(sscape, wss_port[dev])) {
 		printk(KERN_ERR "sscape: hardware not detected at 0x%x\n", sscape->io_base);
 		err = -ENODEV;
 		goto _release_dma;
@@ -1188,11 +1176,11 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	}
 #define MIDI_DEVNUM  0
 	if (sscape->type != SSCAPE_VIVO) {
-		err = create_mpu401(card, MIDI_DEVNUM, xport, mpu_irq[dev]);
+		err = create_mpu401(card, MIDI_DEVNUM, port[dev], mpu_irq[dev]);
 		if (err < 0) {
 			printk(KERN_ERR "sscape: Failed to create "
-					"MPU-401 device at 0x%x\n",
-					xport);
+					"MPU-401 device at 0x%lx\n",
+					port[dev]);
 			goto _release_dma;
 		}
 

commit c9864fd30a28aceef5293f28559c4a2f5a20d7d5
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Wed Jan 21 08:19:27 2009 +0100

    ALSA: sscape: use common MPU401 macros
    
    Remove local macros which redefines the
    common ones.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 6a7f842b9627..681e2237acb7 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -89,9 +89,6 @@ MODULE_DEVICE_TABLE(pnp_card, sscape_pnpids);
 #endif
 
 
-#define MPU401_IO(i)     ((i) + 0)
-#define MIDI_DATA_IO(i)  ((i) + 0)
-#define MIDI_CTRL_IO(i)  ((i) + 1)
 #define HOST_CTRL_IO(i)  ((i) + 2)
 #define HOST_DATA_IO(i)  ((i) + 3)
 #define ODIE_ADDR_IO(i)  ((i) + 4)
@@ -327,7 +324,7 @@ static int host_write_ctrl_unsafe(unsigned io_base, unsigned char data,
  */
 static inline int verify_mpu401(const struct snd_mpu401 * mpu)
 {
-	return ((inb(MIDI_CTRL_IO(mpu->port)) & 0xc0) == 0x80);
+	return ((inb(MPU401C(mpu)) & 0xc0) == 0x80);
 }
 
 /*
@@ -335,7 +332,7 @@ static inline int verify_mpu401(const struct snd_mpu401 * mpu)
  */
 static inline void initialise_mpu401(const struct snd_mpu401 * mpu)
 {
-	outb(0, MIDI_DATA_IO(mpu->port));
+	outb(0, MPU401D(mpu));
 }
 
 /*
@@ -1191,12 +1188,11 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	}
 #define MIDI_DEVNUM  0
 	if (sscape->type != SSCAPE_VIVO) {
-		err = create_mpu401(card, MIDI_DEVNUM,
-				    MPU401_IO(xport), mpu_irq[dev]);
+		err = create_mpu401(card, MIDI_DEVNUM, xport, mpu_irq[dev]);
 		if (err < 0) {
 			printk(KERN_ERR "sscape: Failed to create "
 					"MPU-401 device at 0x%x\n",
-					MPU401_IO(xport));
+					xport);
 			goto _release_dma;
 		}
 

commit 554b91edec1c588b889a7357ff201c0a450e31ff
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Mon Jan 12 21:25:04 2009 +0100

    ALSA: sscape: fix incorrect timeout after microcode upload
    
    A comment states that one should wait up to 5 secs
    while a waiting loop waits only 5 system ticks.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index bc449166d18d..6a7f842b9627 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -393,20 +393,20 @@ static int sscape_wait_dma_unsafe(unsigned io_base, enum GA_REG reg, unsigned ti
  */
 static int obp_startup_ack(struct soundscape *s, unsigned timeout)
 {
-	while (timeout != 0) {
+	unsigned long end_time = jiffies + msecs_to_jiffies(timeout);
+
+	do {
 		unsigned long flags;
 		unsigned char x;
 
-		schedule_timeout_uninterruptible(1);
-
 		spin_lock_irqsave(&s->lock, flags);
 		x = inb(HOST_DATA_IO(s->io_base));
 		spin_unlock_irqrestore(&s->lock, flags);
 		if ((x & 0xfe) == 0xfe)
 			return 1;
 
-		--timeout;
-	} /* while */
+		msleep(10);
+	} while (time_before(jiffies, end_time));
 
 	return 0;
 }
@@ -420,20 +420,20 @@ static int obp_startup_ack(struct soundscape *s, unsigned timeout)
  */
 static int host_startup_ack(struct soundscape *s, unsigned timeout)
 {
-	while (timeout != 0) {
+	unsigned long end_time = jiffies + msecs_to_jiffies(timeout);
+
+	do {
 		unsigned long flags;
 		unsigned char x;
 
-		schedule_timeout_uninterruptible(1);
-
 		spin_lock_irqsave(&s->lock, flags);
 		x = inb(HOST_DATA_IO(s->io_base));
 		spin_unlock_irqrestore(&s->lock, flags);
 		if (x == 0xfe)
 			return 1;
 
-		--timeout;
-	} /* while */
+		msleep(10);
+	} while (time_before(jiffies, end_time));
 
 	return 0;
 }
@@ -529,10 +529,10 @@ static int upload_dma_data(struct soundscape *s,
 	 * give it 5 seconds (max) ...
 	 */
 	ret = 0;
-	if (!obp_startup_ack(s, 5)) {
+	if (!obp_startup_ack(s, 5000)) {
 		snd_printk(KERN_ERR "sscape: No response from on-board processor after upload\n");
 		ret = -EAGAIN;
-	} else if (!host_startup_ack(s, 5)) {
+	} else if (!host_startup_ack(s, 5000)) {
 		snd_printk(KERN_ERR "sscape: SoundScape failed to initialise\n");
 		ret = -EAGAIN;
 	}

commit c95eadd2f1afd2ba643e85a8dfc9079a3f03ae47
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:43:35 2008 +0100

    ALSA: Convert to snd_card_create() in sound/isa/*
    
    Convert from snd_card_new() to the new snd_card_create() function.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 48a16d865834..4025fb558c50 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -1357,10 +1357,10 @@ static int __devinit snd_sscape_probe(struct device *pdev, unsigned int dev)
 	struct soundscape *sscape;
 	int ret;
 
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE,
-			    sizeof(struct soundscape));
-	if (!card)
-		return -ENOMEM;
+	ret = snd_card_create(index[dev], id[dev], THIS_MODULE,
+			      sizeof(struct soundscape), &card);
+	if (ret < 0)
+		return ret;
 
 	sscape = get_card_soundscape(card);
 	sscape->type = SSCAPE;
@@ -1462,10 +1462,10 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 	 * Create a new ALSA sound card entry, in anticipation
 	 * of detecting our hardware ...
 	 */
-	card = snd_card_new(index[idx], id[idx], THIS_MODULE,
-			    sizeof(struct soundscape));
-	if (!card)
-		return -ENOMEM;
+	ret = snd_card_create(index[idx], id[idx], THIS_MODULE,
+			      sizeof(struct soundscape), &card);
+	if (ret < 0)
+		return ret;
 
 	sscape = get_card_soundscape(card);
 

commit 199f7978730a4bbd88038fd84212b30759579f1a
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Fri Jan 9 23:10:52 2009 +0100

    ALSA: wss-lib: move AD1845 frequency setting into wss-lib
    
    This is required to allow the sscape driver
    to autodetect installed codec.
    
    Also, do not create a timer if detected codec
    has no hardware timer (e.g. AD1848).
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Cc: Rene Herman
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 48a16d865834..bc449166d18d 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -129,9 +129,6 @@ enum GA_REG {
 #define DMA_8BIT  0x80
 
 
-#define AD1845_FREQ_SEL_MSB    0x16
-#define AD1845_FREQ_SEL_LSB    0x17
-
 enum card_type {
 	SSCAPE,
 	SSCAPE_PNP,
@@ -954,82 +951,6 @@ static int __devinit create_mpu401(struct snd_card *card, int devnum, unsigned l
 }
 
 
-/*
- * Override for the CS4231 playback format function.
- * The AD1845 has much simpler format and rate selection.
- */
-static void ad1845_playback_format(struct snd_wss *chip,
-				   struct snd_pcm_hw_params *params,
-				   unsigned char format)
-{
-	unsigned long flags;
-	unsigned rate = params_rate(params);
-
-	/*
-	 * The AD1845 can't handle sample frequencies
-	 * outside of 4 kHZ to 50 kHZ
-	 */
-	if (rate > 50000)
-		rate = 50000;
-	else if (rate < 4000)
-		rate = 4000;
-
-	spin_lock_irqsave(&chip->reg_lock, flags);
-
-	/*
-	 * Program the AD1845 correctly for the playback stream.
-	 * Note that we do NOT need to toggle the MCE bit because
-	 * the PLAYBACK_ENABLE bit of the Interface Configuration
-	 * register is set.
-	 * 
-	 * NOTE: We seem to need to write to the MSB before the LSB
-	 *       to get the correct sample frequency.
-	 */
-	snd_wss_out(chip, CS4231_PLAYBK_FORMAT, (format & 0xf0));
-	snd_wss_out(chip, AD1845_FREQ_SEL_MSB, (unsigned char) (rate >> 8));
-	snd_wss_out(chip, AD1845_FREQ_SEL_LSB, (unsigned char) rate);
-
-	spin_unlock_irqrestore(&chip->reg_lock, flags);
-}
-
-/*
- * Override for the CS4231 capture format function. 
- * The AD1845 has much simpler format and rate selection.
- */
-static void ad1845_capture_format(struct snd_wss *chip,
-				  struct snd_pcm_hw_params *params,
-				  unsigned char format)
-{
-	unsigned long flags;
-	unsigned rate = params_rate(params);
-
-	/*
-	 * The AD1845 can't handle sample frequencies 
-	 * outside of 4 kHZ to 50 kHZ
-	 */
-	if (rate > 50000)
-		rate = 50000;
-	else if (rate < 4000)
-		rate = 4000;
-
-	spin_lock_irqsave(&chip->reg_lock, flags);
-
-	/*
-	 * Program the AD1845 correctly for the playback stream.
-	 * Note that we do NOT need to toggle the MCE bit because
-	 * the CAPTURE_ENABLE bit of the Interface Configuration
-	 * register is set.
-	 *
-	 * NOTE: We seem to need to write to the MSB before the LSB
-	 *       to get the correct sample frequency.
-	 */
-	snd_wss_out(chip, CS4231_REC_FORMAT, (format & 0xf0));
-	snd_wss_out(chip, AD1845_FREQ_SEL_MSB, (unsigned char) (rate >> 8));
-	snd_wss_out(chip, AD1845_FREQ_SEL_LSB, (unsigned char) rate);
-
-	spin_unlock_irqrestore(&chip->reg_lock, flags);
-}
-
 /*
  * Create an AD1845 PCM subdevice on the SoundScape. The AD1845
  * is very much like a CS4231, with a few extra bits. We will
@@ -1055,11 +976,6 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
 		unsigned long flags;
 		struct snd_pcm *pcm;
 
-#define AD1845_FREQ_SEL_ENABLE  0x08
-
-#define AD1845_PWR_DOWN_CTRL   0x1b
-#define AD1845_CRYS_CLOCK_SEL  0x1d
-
 /*
  * It turns out that the PLAYBACK_ENABLE bit is set
  * by the lowlevel driver ...
@@ -1074,7 +990,6 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
  */
 
 		if (sscape->type != SSCAPE_VIVO) {
-			int val;
 			/*
 			 * The input clock frequency on the SoundScape must
 			 * be 14.31818 MHz, because we must set this register
@@ -1082,22 +997,10 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
 			 */
 			snd_wss_mce_up(chip);
 			spin_lock_irqsave(&chip->reg_lock, flags);
-			snd_wss_out(chip, AD1845_CRYS_CLOCK_SEL, 0x20);
+			snd_wss_out(chip, AD1845_CLOCK, 0x20);
 			spin_unlock_irqrestore(&chip->reg_lock, flags);
 			snd_wss_mce_down(chip);
 
-			/*
-			 * More custom configuration:
-			 * a) select "mode 2" and provide a current drive of 8mA
-			 * b) enable frequency selection (for capture/playback)
-			 */
-			spin_lock_irqsave(&chip->reg_lock, flags);
-			snd_wss_out(chip, CS4231_MISC_INFO,
-				    CS4231_MODE2 | 0x10);
-			val = snd_wss_in(chip, AD1845_PWR_DOWN_CTRL);
-			snd_wss_out(chip, AD1845_PWR_DOWN_CTRL,
-				    val | AD1845_FREQ_SEL_ENABLE);
-			spin_unlock_irqrestore(&chip->reg_lock, flags);
 		}
 
 		err = snd_wss_pcm(chip, 0, &pcm);
@@ -1113,11 +1016,13 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
 					    "for AD1845 chip\n");
 			goto _error;
 		}
-		err = snd_wss_timer(chip, 0, NULL);
-		if (err < 0) {
-			snd_printk(KERN_ERR "sscape: No timer device "
-					    "for AD1845 chip\n");
-			goto _error;
+		if (chip->hardware != WSS_HW_AD1848) {
+			err = snd_wss_timer(chip, 0, NULL);
+			if (err < 0) {
+				snd_printk(KERN_ERR "sscape: No timer device "
+						    "for AD1845 chip\n");
+				goto _error;
+			}
 		}
 
 		if (sscape->type != SSCAPE_VIVO) {
@@ -1128,8 +1033,6 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
 						    "MIDI mixer control\n");
 				goto _error;
 			}
-			chip->set_playback_format = ad1845_playback_format;
-			chip->set_capture_format = ad1845_capture_format;
 		}
 
 		strcpy(card->driver, "SoundScape");

commit 7779f75f072784d3fccf721b8ec43107f93619a0
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Thu Jul 31 21:03:41 2008 +0200

    ALSA: wss_lib: rename cs4321_foo to wss_foo
    
    Rename functions and structures from the former
    cs4321_lib to names more corresponding with the
    new name: wss_lib.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Reviewed-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 1dc4224b3207..48a16d865834 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -147,7 +147,7 @@ struct soundscape {
 	enum card_type type;
 	struct resource *io_res;
 	struct resource *wss_res;
-	struct snd_cs4231 *chip;
+	struct snd_wss *chip;
 	struct snd_mpu401 *mpu;
 	struct snd_hwdep *hw;
 
@@ -726,7 +726,7 @@ static int sscape_midi_info(struct snd_kcontrol *ctl,
 static int sscape_midi_get(struct snd_kcontrol *kctl,
                            struct snd_ctl_elem_value *uctl)
 {
-	struct snd_cs4231 *chip = snd_kcontrol_chip(kctl);
+	struct snd_wss *chip = snd_kcontrol_chip(kctl);
 	struct snd_card *card = chip->card;
 	register struct soundscape *s = get_card_soundscape(card);
 	unsigned long flags;
@@ -746,7 +746,7 @@ static int sscape_midi_get(struct snd_kcontrol *kctl,
 static int sscape_midi_put(struct snd_kcontrol *kctl,
                            struct snd_ctl_elem_value *uctl)
 {
-	struct snd_cs4231 *chip = snd_kcontrol_chip(kctl);
+	struct snd_wss *chip = snd_kcontrol_chip(kctl);
 	struct snd_card *card = chip->card;
 	register struct soundscape *s = get_card_soundscape(card);
 	unsigned long flags;
@@ -958,7 +958,9 @@ static int __devinit create_mpu401(struct snd_card *card, int devnum, unsigned l
  * Override for the CS4231 playback format function.
  * The AD1845 has much simpler format and rate selection.
  */
-static void ad1845_playback_format(struct snd_cs4231 * chip, struct snd_pcm_hw_params *params, unsigned char format)
+static void ad1845_playback_format(struct snd_wss *chip,
+				   struct snd_pcm_hw_params *params,
+				   unsigned char format)
 {
 	unsigned long flags;
 	unsigned rate = params_rate(params);
@@ -983,9 +985,9 @@ static void ad1845_playback_format(struct snd_cs4231 * chip, struct snd_pcm_hw_p
 	 * NOTE: We seem to need to write to the MSB before the LSB
 	 *       to get the correct sample frequency.
 	 */
-	snd_cs4231_out(chip, CS4231_PLAYBK_FORMAT, (format & 0xf0));
-	snd_cs4231_out(chip, AD1845_FREQ_SEL_MSB, (unsigned char) (rate >> 8));
-	snd_cs4231_out(chip, AD1845_FREQ_SEL_LSB, (unsigned char) rate);
+	snd_wss_out(chip, CS4231_PLAYBK_FORMAT, (format & 0xf0));
+	snd_wss_out(chip, AD1845_FREQ_SEL_MSB, (unsigned char) (rate >> 8));
+	snd_wss_out(chip, AD1845_FREQ_SEL_LSB, (unsigned char) rate);
 
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 }
@@ -994,7 +996,9 @@ static void ad1845_playback_format(struct snd_cs4231 * chip, struct snd_pcm_hw_p
  * Override for the CS4231 capture format function. 
  * The AD1845 has much simpler format and rate selection.
  */
-static void ad1845_capture_format(struct snd_cs4231 * chip, struct snd_pcm_hw_params *params, unsigned char format)
+static void ad1845_capture_format(struct snd_wss *chip,
+				  struct snd_pcm_hw_params *params,
+				  unsigned char format)
 {
 	unsigned long flags;
 	unsigned rate = params_rate(params);
@@ -1019,9 +1023,9 @@ static void ad1845_capture_format(struct snd_cs4231 * chip, struct snd_pcm_hw_pa
 	 * NOTE: We seem to need to write to the MSB before the LSB
 	 *       to get the correct sample frequency.
 	 */
-	snd_cs4231_out(chip, CS4231_REC_FORMAT, (format & 0xf0));
-	snd_cs4231_out(chip, AD1845_FREQ_SEL_MSB, (unsigned char) (rate >> 8));
-	snd_cs4231_out(chip, AD1845_FREQ_SEL_LSB, (unsigned char) rate);
+	snd_wss_out(chip, CS4231_REC_FORMAT, (format & 0xf0));
+	snd_wss_out(chip, AD1845_FREQ_SEL_MSB, (unsigned char) (rate >> 8));
+	snd_wss_out(chip, AD1845_FREQ_SEL_LSB, (unsigned char) rate);
 
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 }
@@ -1036,7 +1040,7 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
 				   int irq, int dma1, int dma2)
 {
 	register struct soundscape *sscape = get_card_soundscape(card);
-	struct snd_cs4231 *chip;
+	struct snd_wss *chip;
 	int err;
 
 	if (sscape->type == SSCAPE_VIVO)
@@ -1045,9 +1049,8 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
 	if (dma1 == dma2)
 		dma2 = -1;
 
-	err = snd_cs4231_create(card,
-				port, -1, irq, dma1, dma2,
-				CS4231_HW_DETECT, CS4231_HWSHARE_DMA1, &chip);
+	err = snd_wss_create(card, port, -1, irq, dma1, dma2,
+			     WSS_HW_DETECT, WSS_HWSHARE_DMA1, &chip);
 	if (!err) {
 		unsigned long flags;
 		struct snd_pcm *pcm;
@@ -1063,11 +1066,11 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
  *
 #define AD1845_IFACE_CONFIG  \
            (CS4231_AUTOCALIB | CS4231_RECORD_ENABLE | CS4231_PLAYBACK_ENABLE)
-    snd_cs4231_mce_up(chip);
+    snd_wss_mce_up(chip);
     spin_lock_irqsave(&chip->reg_lock, flags);
-    snd_cs4231_out(chip, CS4231_IFACE_CTRL, AD1845_IFACE_CONFIG);
+    snd_wss_out(chip, CS4231_IFACE_CTRL, AD1845_IFACE_CONFIG);
     spin_unlock_irqrestore(&chip->reg_lock, flags);
-    snd_cs4231_mce_down(chip);
+    snd_wss_mce_down(chip);
  */
 
 		if (sscape->type != SSCAPE_VIVO) {
@@ -1077,11 +1080,11 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
 			 * be 14.31818 MHz, because we must set this register
 			 * to get the playback to sound correct ...
 			 */
-			snd_cs4231_mce_up(chip);
+			snd_wss_mce_up(chip);
 			spin_lock_irqsave(&chip->reg_lock, flags);
-			snd_cs4231_out(chip, AD1845_CRYS_CLOCK_SEL, 0x20);
+			snd_wss_out(chip, AD1845_CRYS_CLOCK_SEL, 0x20);
 			spin_unlock_irqrestore(&chip->reg_lock, flags);
-			snd_cs4231_mce_down(chip);
+			snd_wss_mce_down(chip);
 
 			/*
 			 * More custom configuration:
@@ -1089,28 +1092,28 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
 			 * b) enable frequency selection (for capture/playback)
 			 */
 			spin_lock_irqsave(&chip->reg_lock, flags);
-			snd_cs4231_out(chip, CS4231_MISC_INFO,
-					CS4231_MODE2 | 0x10);
-			val = snd_cs4231_in(chip, AD1845_PWR_DOWN_CTRL);
-			snd_cs4231_out(chip, AD1845_PWR_DOWN_CTRL,
-					val | AD1845_FREQ_SEL_ENABLE);
+			snd_wss_out(chip, CS4231_MISC_INFO,
+				    CS4231_MODE2 | 0x10);
+			val = snd_wss_in(chip, AD1845_PWR_DOWN_CTRL);
+			snd_wss_out(chip, AD1845_PWR_DOWN_CTRL,
+				    val | AD1845_FREQ_SEL_ENABLE);
 			spin_unlock_irqrestore(&chip->reg_lock, flags);
 		}
 
-		err = snd_cs4231_pcm(chip, 0, &pcm);
+		err = snd_wss_pcm(chip, 0, &pcm);
 		if (err < 0) {
 			snd_printk(KERN_ERR "sscape: No PCM device "
 					    "for AD1845 chip\n");
 			goto _error;
 		}
 
-		err = snd_cs4231_mixer(chip);
+		err = snd_wss_mixer(chip);
 		if (err < 0) {
 			snd_printk(KERN_ERR "sscape: No mixer device "
 					    "for AD1845 chip\n");
 			goto _error;
 		}
-		err = snd_cs4231_timer(chip, 0, NULL);
+		err = snd_wss_timer(chip, 0, NULL);
 		if (err < 0) {
 			snd_printk(KERN_ERR "sscape: No timer device "
 					    "for AD1845 chip\n");

commit 61ef19d7e771ce021edb0dff0da134b6d688d4aa
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Thu Jul 31 21:02:42 2008 +0200

    ALSA: wss_lib: rename cs4231.h into wss.h
    
    Rename file include/sound/cs4231.h
    into include/sound/wss.h
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Reviewed-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 06ad7863dff5..1dc4224b3207 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -31,7 +31,7 @@
 #include <asm/dma.h>
 #include <sound/core.h>
 #include <sound/hwdep.h>
-#include <sound/cs4231.h>
+#include <sound/wss.h>
 #include <sound/mpu401.h>
 #include <sound/initval.h>
 

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 1cb921d6137e..06ad7863dff5 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -21,7 +21,6 @@
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/err.h>
 #include <linux/isa.h>

commit d86d01935a4c4c818514d8c23579703abd768329
Author: Rene Herman <rene.herman>
Date:   Tue Sep 18 18:10:49 2007 +0200

    [ALSA] alsa-kernel: schedule_timeout() fixes
    
    Fix schedule_timeout() use in alsa-kernel. Mostly just
            schedule_timeout(1) --> schedule_timeout_uninterruptible(1)
    The wavefront_synth one fixes the surrounding loop as well. In ymfpci_main,
    delete a superfluous set_current_state() and in soc/soc-dapm.c replace an
    _interruptible with _uninterruptible in some debug code; it's not waiting
    for signals.
    
    Signed-off-by: Rene Herman <rene.herman>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 4902da40b6c0..1cb921d6137e 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -401,7 +401,7 @@ static int obp_startup_ack(struct soundscape *s, unsigned timeout)
 		unsigned long flags;
 		unsigned char x;
 
-		schedule_timeout(1);
+		schedule_timeout_uninterruptible(1);
 
 		spin_lock_irqsave(&s->lock, flags);
 		x = inb(HOST_DATA_IO(s->io_base));
@@ -428,7 +428,7 @@ static int host_startup_ack(struct soundscape *s, unsigned timeout)
 		unsigned long flags;
 		unsigned char x;
 
-		schedule_timeout(1);
+		schedule_timeout_uninterruptible(1);
 
 		spin_lock_irqsave(&s->lock, flags);
 		x = inb(HOST_DATA_IO(s->io_base));

commit ec1e7949327a709c83fc7338f89a8c2d1f978fa9
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Mon Sep 17 17:57:37 2007 +0200

    [ALSA] sscape: support for audio part of VIVO cards
    
    This patch adds support for audio part of the Ensoniq
    SoundScape VIVO cards. The MIDI part is not supported.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 53daa8bd9b78..4902da40b6c0 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -142,10 +142,12 @@ enum card_type {
 struct soundscape {
 	spinlock_t lock;
 	unsigned io_base;
+	unsigned wss_base;
 	int codec_type;
 	int ic_type;
 	enum card_type type;
 	struct resource *io_res;
+	struct resource *wss_res;
 	struct snd_cs4231 *chip;
 	struct snd_mpu401 *mpu;
 	struct snd_hwdep *hw;
@@ -356,8 +358,9 @@ static inline void activate_ad1845_unsafe(unsigned io_base)
  */
 static void soundscape_free(struct snd_card *c)
 {
-	register struct soundscape *sscape = get_card_soundscape(c);
+	struct soundscape *sscape = get_card_soundscape(c);
 	release_and_free_resource(sscape->io_res);
+	release_and_free_resource(sscape->wss_res);
 	free_dma(sscape->chip->dma1);
 }
 
@@ -818,6 +821,7 @@ static int __devinit detect_sscape(struct soundscape *s)
 	unsigned long flags;
 	unsigned d;
 	int retval = 0;
+	int codec = s->wss_base;
 
 	spin_lock_irqsave(&s->lock, flags);
 
@@ -849,9 +853,27 @@ static int __devinit detect_sscape(struct soundscape *s)
 	outb(0xfe, ODIE_ADDR_IO(s->io_base));
 	if ((inb(ODIE_ADDR_IO(s->io_base)) & 0x9f) != 0x0e)
 		goto _done;
-	if ((inb(ODIE_DATA_IO(s->io_base)) & 0x9f) != 0x0e)
+
+	outb(0xfe, ODIE_ADDR_IO(s->io_base));
+	d = inb(ODIE_DATA_IO(s->io_base));
+	if (s->type != SSCAPE_VIVO && (d & 0x9f) != 0x0e)
 		goto _done;
 
+	d  = sscape_read_unsafe(s->io_base, GA_HMCTL_REG) & 0x3f;
+	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, d | 0xc0);
+
+	if (s->type == SSCAPE_VIVO)
+		codec += 4;
+	/* wait for WSS codec */
+	for (d = 0; d < 500; d++) {
+		if ((inb(codec) & 0x80) == 0)
+			break;
+		spin_unlock_irqrestore(&s->lock, flags);
+		msleep(1);
+		spin_lock_irqsave(&s->lock, flags);
+	}
+	snd_printd(KERN_INFO "init delay = %d ms\n", d);
+
 	/*
 	 * SoundScape successfully detected!
 	 */
@@ -1018,6 +1040,9 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
 	struct snd_cs4231 *chip;
 	int err;
 
+	if (sscape->type == SSCAPE_VIVO)
+		port += 4;
+
 	if (dma1 == dma2)
 		dma2 = -1;
 
@@ -1046,50 +1071,72 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
     snd_cs4231_mce_down(chip);
  */
 
-		/*
-		 * The input clock frequency on the SoundScape must
-		 * be 14.31818 MHz, because we must set this register
-		 * to get the playback to sound correct ...
-		 */
-		snd_cs4231_mce_up(chip);
-		spin_lock_irqsave(&chip->reg_lock, flags);
-		snd_cs4231_out(chip, AD1845_CRYS_CLOCK_SEL, 0x20);
-		spin_unlock_irqrestore(&chip->reg_lock, flags);
-		snd_cs4231_mce_down(chip);
+		if (sscape->type != SSCAPE_VIVO) {
+			int val;
+			/*
+			 * The input clock frequency on the SoundScape must
+			 * be 14.31818 MHz, because we must set this register
+			 * to get the playback to sound correct ...
+			 */
+			snd_cs4231_mce_up(chip);
+			spin_lock_irqsave(&chip->reg_lock, flags);
+			snd_cs4231_out(chip, AD1845_CRYS_CLOCK_SEL, 0x20);
+			spin_unlock_irqrestore(&chip->reg_lock, flags);
+			snd_cs4231_mce_down(chip);
 
-		/*
-		 * More custom configuration:
-		 * a) select "mode 2", and provide a current drive of 8 mA
-		 * b) enable frequency selection (for capture/playback)
-		 */
-		spin_lock_irqsave(&chip->reg_lock, flags);
-		snd_cs4231_out(chip, CS4231_MISC_INFO, (CS4231_MODE2 | 0x10));
-		snd_cs4231_out(chip, AD1845_PWR_DOWN_CTRL, snd_cs4231_in(chip, AD1845_PWR_DOWN_CTRL) | AD1845_FREQ_SEL_ENABLE);
-		spin_unlock_irqrestore(&chip->reg_lock, flags);
+			/*
+			 * More custom configuration:
+			 * a) select "mode 2" and provide a current drive of 8mA
+			 * b) enable frequency selection (for capture/playback)
+			 */
+			spin_lock_irqsave(&chip->reg_lock, flags);
+			snd_cs4231_out(chip, CS4231_MISC_INFO,
+					CS4231_MODE2 | 0x10);
+			val = snd_cs4231_in(chip, AD1845_PWR_DOWN_CTRL);
+			snd_cs4231_out(chip, AD1845_PWR_DOWN_CTRL,
+					val | AD1845_FREQ_SEL_ENABLE);
+			spin_unlock_irqrestore(&chip->reg_lock, flags);
+		}
 
-		if ((err = snd_cs4231_pcm(chip, 0, &pcm)) < 0) {
-			snd_printk(KERN_ERR "sscape: No PCM device for AD1845 chip\n");
+		err = snd_cs4231_pcm(chip, 0, &pcm);
+		if (err < 0) {
+			snd_printk(KERN_ERR "sscape: No PCM device "
+					    "for AD1845 chip\n");
 			goto _error;
 		}
 
-		if ((err = snd_cs4231_mixer(chip)) < 0) {
-			snd_printk(KERN_ERR "sscape: No mixer device for AD1845 chip\n");
+		err = snd_cs4231_mixer(chip);
+		if (err < 0) {
+			snd_printk(KERN_ERR "sscape: No mixer device "
+					    "for AD1845 chip\n");
 			goto _error;
 		}
-
-		if ((err = snd_ctl_add(card, snd_ctl_new1(&midi_mixer_ctl, chip))) < 0) {
-			snd_printk(KERN_ERR "sscape: Could not create MIDI mixer control\n");
+		err = snd_cs4231_timer(chip, 0, NULL);
+		if (err < 0) {
+			snd_printk(KERN_ERR "sscape: No timer device "
+					    "for AD1845 chip\n");
 			goto _error;
 		}
 
+		if (sscape->type != SSCAPE_VIVO) {
+			err = snd_ctl_add(card,
+					  snd_ctl_new1(&midi_mixer_ctl, chip));
+			if (err < 0) {
+				snd_printk(KERN_ERR "sscape: Could not create "
+						    "MIDI mixer control\n");
+				goto _error;
+			}
+			chip->set_playback_format = ad1845_playback_format;
+			chip->set_capture_format = ad1845_capture_format;
+		}
+
 		strcpy(card->driver, "SoundScape");
 		strcpy(card->shortname, pcm->name);
 		snprintf(card->longname, sizeof(card->longname),
 			 "%s at 0x%lx, IRQ %d, DMA1 %d, DMA2 %d\n",
 			 pcm->name, chip->port, chip->irq,
 			 chip->dma1, chip->dma2);
-		chip->set_playback_format = ad1845_playback_format;
-		chip->set_capture_format = ad1845_capture_format;
+
 		sscape->chip = chip;
 	}
 
@@ -1104,12 +1151,13 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port,
  */
 static int __devinit create_sscape(int dev, struct snd_card *card)
 {
-	register struct soundscape *sscape;
-	register unsigned dma_cfg;
+	struct soundscape *sscape = get_card_soundscape(card);
+	unsigned dma_cfg;
 	unsigned irq_cfg;
 	unsigned mpu_irq_cfg;
 	unsigned xport;
 	struct resource *io_res;
+	struct resource *wss_res;
 	unsigned long flags;
 	int err;
 
@@ -1133,13 +1181,24 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	 * Grab IO ports that we will need to probe so that we
 	 * can detect and control this hardware ...
 	 */
-	if ((io_res = request_region(xport, 8, "SoundScape")) == NULL) {
+	io_res = request_region(xport, 8, "SoundScape");
+	if (!io_res) {
 		snd_printk(KERN_ERR "sscape: can't grab port 0x%x\n", xport);
 		return -EBUSY;
 	}
+	wss_res = NULL;
+	if (sscape->type == SSCAPE_VIVO) {
+		wss_res = request_region(wss_port[dev], 4, "SoundScape");
+		if (!wss_res) {
+			snd_printk(KERN_ERR "sscape: can't grab port 0x%lx\n",
+					    wss_port[dev]);
+			err = -EBUSY;
+			goto _release_region;
+		}
+	}
 
 	/*
-	 * Grab both DMA channels (OK, only one for now) ...
+	 * Grab one DMA channel ...
 	 */
 	err = request_dma(dma[dev], "SoundScape");
 	if (err < 0) {
@@ -1147,11 +1206,12 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 		goto _release_region;
 	}
 
-	sscape = get_card_soundscape(card);
 	spin_lock_init(&sscape->lock);
 	spin_lock_init(&sscape->fwlock);
 	sscape->io_res = io_res;
+	sscape->wss_res = wss_res;
 	sscape->io_base = xport;
+	sscape->wss_base = wss_port[dev];
 
 	if (!detect_sscape(sscape)) {
 		printk(KERN_ERR "sscape: hardware not detected at 0x%x\n", sscape->io_base);
@@ -1162,23 +1222,28 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	printk(KERN_INFO "sscape: hardware detected at 0x%x, using IRQ %d, DMA %d\n",
 			 sscape->io_base, irq[dev], dma[dev]);
 
-	/*
-	 * Now create the hardware-specific device so that we can
-	 * load the microcode into the on-board processor.
-	 * We cannot use the MPU-401 MIDI system until this firmware
-	 * has been loaded into the card.
-	 */
-	if ((err = snd_hwdep_new(card, "MC68EC000", 0, &(sscape->hw))) < 0) {
-		printk(KERN_ERR "sscape: Failed to create firmware device\n");
-		goto _release_dma;
+	if (sscape->type != SSCAPE_VIVO) {
+		/*
+		 * Now create the hardware-specific device so that we can
+		 * load the microcode into the on-board processor.
+		 * We cannot use the MPU-401 MIDI system until this firmware
+		 * has been loaded into the card.
+		 */
+		err = snd_hwdep_new(card, "MC68EC000", 0, &(sscape->hw));
+		if (err < 0) {
+			printk(KERN_ERR "sscape: Failed to create "
+					"firmware device\n");
+			goto _release_dma;
+		}
+		strlcpy(sscape->hw->name, "SoundScape M68K",
+			sizeof(sscape->hw->name));
+		sscape->hw->name[sizeof(sscape->hw->name) - 1] = '\0';
+		sscape->hw->iface = SNDRV_HWDEP_IFACE_SSCAPE;
+		sscape->hw->ops.open = sscape_hw_open;
+		sscape->hw->ops.release = sscape_hw_release;
+		sscape->hw->ops.ioctl = sscape_hw_ioctl;
+		sscape->hw->private_data = sscape;
 	}
-	strlcpy(sscape->hw->name, "SoundScape M68K", sizeof(sscape->hw->name));
-	sscape->hw->name[sizeof(sscape->hw->name) - 1] = '\0';
-	sscape->hw->iface = SNDRV_HWDEP_IFACE_SSCAPE;
-	sscape->hw->ops.open = sscape_hw_open;
-	sscape->hw->ops.release = sscape_hw_release;
-	sscape->hw->ops.ioctl = sscape_hw_ioctl;
-	sscape->hw->private_data = sscape;
 
 	/*
 	 * Tell the on-board devices where their resources are (I think -
@@ -1220,24 +1285,29 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 		goto _release_dma;
 	}
 #define MIDI_DEVNUM  0
-	if ((err = create_mpu401(card, MIDI_DEVNUM, MPU401_IO(xport), mpu_irq[dev])) < 0) {
-		printk(KERN_ERR "sscape: Failed to create MPU-401 device at 0x%x\n",
-		                MPU401_IO(xport));
-		goto _release_dma;
-	}
+	if (sscape->type != SSCAPE_VIVO) {
+		err = create_mpu401(card, MIDI_DEVNUM,
+				    MPU401_IO(xport), mpu_irq[dev]);
+		if (err < 0) {
+			printk(KERN_ERR "sscape: Failed to create "
+					"MPU-401 device at 0x%x\n",
+					MPU401_IO(xport));
+			goto _release_dma;
+		}
 
-	/*
-	 * Enable the master IRQ ...
-	 */
-	sscape_write(sscape, GA_INTENA_REG, 0x80);
+		/*
+		 * Enable the master IRQ ...
+		 */
+		sscape_write(sscape, GA_INTENA_REG, 0x80);
 
-	/*
-	 * Initialize mixer
-	 */
-	sscape->midi_vol = 0;
-	host_write_ctrl_unsafe(sscape->io_base, CMD_SET_MIDI_VOL, 100);
-	host_write_ctrl_unsafe(sscape->io_base, 0, 100);
-	host_write_ctrl_unsafe(sscape->io_base, CMD_XXX_MIDI_VOL, 100);
+		/*
+		 * Initialize mixer
+		 */
+		sscape->midi_vol = 0;
+		host_write_ctrl_unsafe(sscape->io_base, CMD_SET_MIDI_VOL, 100);
+		host_write_ctrl_unsafe(sscape->io_base, 0, 100);
+		host_write_ctrl_unsafe(sscape->io_base, CMD_XXX_MIDI_VOL, 100);
+	}
 
 	/*
 	 * Now that we have successfully created this sound card,
@@ -1253,6 +1323,7 @@ static int __devinit create_sscape(int dev, struct snd_card *card)
 	free_dma(dma[dev]);
 
 _release_region:
+	release_and_free_resource(wss_res);
 	release_and_free_resource(io_res);
 
 	return err;
@@ -1404,12 +1475,6 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 	else
 		sscape->type = SSCAPE_PNP;
 
-	/* VIVO fails for now */
-	if (sscape->type == SSCAPE_VIVO) {
-		ret = -ENODEV;
-		goto _release_card;
-	}
-
 	/*
 	 * Read the correct parameters off the ISA PnP bus ...
 	 */
@@ -1417,8 +1482,13 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 	irq[idx] = pnp_irq(dev, 0);
 	mpu_irq[idx] = pnp_irq(dev, 1);
 	dma[idx] = pnp_dma(dev, 0) & 0x03;
-	dma2[idx] = dma[idx];
-	wss_port[idx] = CODEC_IO(port[idx]);
+	if (sscape->type == SSCAPE_PNP) {
+		dma2[idx] = dma[idx];
+		wss_port[idx] = CODEC_IO(port[idx]);
+	} else {
+		wss_port[idx] = pnp_port_start(dev, 1);
+		dma2[idx] = pnp_dma(dev, 1);
+	}
 
 	ret = create_sscape(idx, card);
 	if (ret < 0)

commit 4996bca9850c0d6a1dd6c541efda3738ba2305ae
Author: Krzysztof Helt <krzysztof.h1@wp.pl>
Date:   Mon Sep 17 16:23:13 2007 +0200

    [ALSA] sscape: driver extension to 2nd DMA and WSS port
    
    This patch adds second DMA channel and WSS port settings
    to the sscape driver. Also, it adds internal card type setting.
    The Ensoniq SoundScape VIVO PnP id is added but not handled
    yet.
    
    Signed-off-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index cbad2a51cbaa..53daa8bd9b78 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -45,10 +45,12 @@ MODULE_LICENSE("GPL");
 
 static int index[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_IDX;
 static char* id[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_STR;
-static long port[SNDRV_CARDS] __devinitdata = { [0 ... (SNDRV_CARDS-1)] = SNDRV_AUTO_PORT };
+static long port[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_PORT;
+static long wss_port[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_PORT;
 static int irq[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_IRQ;
 static int mpu_irq[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_IRQ;
 static int dma[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_DMA;
+static int dma2[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_DMA;
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index number for SoundScape soundcard");
@@ -59,6 +61,9 @@ MODULE_PARM_DESC(id, "Description for SoundScape card");
 module_param_array(port, long, NULL, 0444);
 MODULE_PARM_DESC(port, "Port # for SoundScape driver.");
 
+module_param_array(wss_port, long, NULL, 0444);
+MODULE_PARM_DESC(wss_port, "WSS Port # for SoundScape driver.");
+
 module_param_array(irq, int, NULL, 0444);
 MODULE_PARM_DESC(irq, "IRQ # for SoundScape driver.");
 
@@ -68,12 +73,16 @@ MODULE_PARM_DESC(mpu_irq, "MPU401 IRQ # for SoundScape driver.");
 module_param_array(dma, int, NULL, 0444);
 MODULE_PARM_DESC(dma, "DMA # for SoundScape driver.");
 
+module_param_array(dma2, int, NULL, 0444);
+MODULE_PARM_DESC(dma2, "DMA2 # for SoundScape driver.");
+
 #ifdef CONFIG_PNP
 static int isa_registered;
 static int pnp_registered;
 
 static struct pnp_card_device_id sscape_pnpids[] = {
-	{ .id = "ENS3081", .devs = { { "ENS0000" } } },
+	{ .id = "ENS3081", .devs = { { "ENS0000" } } }, /* Soundscape PnP */
+	{ .id = "ENS4081", .devs = { { "ENS1011" } } },	/* VIVO90 */
 	{ .id = "" }	/* end */
 };
 
@@ -124,11 +133,18 @@ enum GA_REG {
 #define AD1845_FREQ_SEL_MSB    0x16
 #define AD1845_FREQ_SEL_LSB    0x17
 
+enum card_type {
+	SSCAPE,
+	SSCAPE_PNP,
+	SSCAPE_VIVO,
+};
+
 struct soundscape {
 	spinlock_t lock;
 	unsigned io_base;
 	int codec_type;
 	int ic_type;
+	enum card_type type;
 	struct resource *io_res;
 	struct snd_cs4231 *chip;
 	struct snd_mpu401 *mpu;
@@ -522,7 +538,7 @@ static int upload_dma_data(struct soundscape *s,
 		ret = -EAGAIN;
 	}
 
-	_release_dma:
+_release_dma:
 	/*
 	 * NOTE!!! We are NOT holding any spinlocks at this point !!!
 	 */
@@ -995,21 +1011,20 @@ static void ad1845_capture_format(struct snd_cs4231 * chip, struct snd_pcm_hw_pa
  * try to support at least some of the extra bits by overriding
  * some of the CS4231 callback.
  */
-static int __devinit create_ad1845(struct snd_card *card, unsigned port, int irq, int dma1)
+static int __devinit create_ad1845(struct snd_card *card, unsigned port,
+				   int irq, int dma1, int dma2)
 {
 	register struct soundscape *sscape = get_card_soundscape(card);
 	struct snd_cs4231 *chip;
 	int err;
 
-#define CS4231_SHARE_HARDWARE  (CS4231_HWSHARE_DMA1 | CS4231_HWSHARE_DMA2)
-	/*
-	 * The AD1845 PCM device is only half-duplex, and so
-	 * we only give it one DMA channel ...
-	 */
-	if ((err = snd_cs4231_create(card,
-				     port, -1, irq, dma1, dma1,
-				     CS4231_HW_DETECT,
-				     CS4231_HWSHARE_DMA1, &chip)) == 0) {
+	if (dma1 == dma2)
+		dma2 = -1;
+
+	err = snd_cs4231_create(card,
+				port, -1, irq, dma1, dma2,
+				CS4231_HW_DETECT, CS4231_HWSHARE_DMA1, &chip);
+	if (!err) {
 		unsigned long flags;
 		struct snd_pcm *pcm;
 
@@ -1070,8 +1085,9 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port, int irq
 		strcpy(card->driver, "SoundScape");
 		strcpy(card->shortname, pcm->name);
 		snprintf(card->longname, sizeof(card->longname),
-		         "%s at 0x%lx, IRQ %d, DMA %d\n",
-		         pcm->name, chip->port, chip->irq, chip->dma1);
+			 "%s at 0x%lx, IRQ %d, DMA1 %d, DMA2 %d\n",
+			 pcm->name, chip->port, chip->irq,
+			 chip->dma1, chip->dma2);
 		chip->set_playback_format = ad1845_playback_format;
 		chip->set_capture_format = ad1845_capture_format;
 		sscape->chip = chip;
@@ -1086,9 +1102,8 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port, int irq
  * Create an ALSA soundcard entry for the SoundScape, using
  * the given list of port, IRQ and DMA resources.
  */
-static int __devinit create_sscape(int dev, struct snd_card **rcardp)
+static int __devinit create_sscape(int dev, struct snd_card *card)
 {
-	struct snd_card *card;
 	register struct soundscape *sscape;
 	register unsigned dma_cfg;
 	unsigned irq_cfg;
@@ -1126,21 +1141,12 @@ static int __devinit create_sscape(int dev, struct snd_card **rcardp)
 	/*
 	 * Grab both DMA channels (OK, only one for now) ...
 	 */
-	if ((err = request_dma(dma[dev], "SoundScape")) < 0) {
+	err = request_dma(dma[dev], "SoundScape");
+	if (err < 0) {
 		snd_printk(KERN_ERR "sscape: can't grab DMA %d\n", dma[dev]);
 		goto _release_region;
 	}
 
-	/*
-	 * Create a new ALSA sound card entry, in anticipation
-	 * of detecting our hardware ...
-	 */
-	if ((card = snd_card_new(index[dev], id[dev], THIS_MODULE,
-				 sizeof(struct soundscape))) == NULL) {
-		err = -ENOMEM;
-		goto _release_dma;
-	}
-
 	sscape = get_card_soundscape(card);
 	spin_lock_init(&sscape->lock);
 	spin_lock_init(&sscape->fwlock);
@@ -1150,11 +1156,11 @@ static int __devinit create_sscape(int dev, struct snd_card **rcardp)
 	if (!detect_sscape(sscape)) {
 		printk(KERN_ERR "sscape: hardware not detected at 0x%x\n", sscape->io_base);
 		err = -ENODEV;
-		goto _release_card;
+		goto _release_dma;
 	}
 
 	printk(KERN_INFO "sscape: hardware detected at 0x%x, using IRQ %d, DMA %d\n",
-	                 sscape->io_base, irq[dev], dma[dev]);
+			 sscape->io_base, irq[dev], dma[dev]);
 
 	/*
 	 * Now create the hardware-specific device so that we can
@@ -1164,7 +1170,7 @@ static int __devinit create_sscape(int dev, struct snd_card **rcardp)
 	 */
 	if ((err = snd_hwdep_new(card, "MC68EC000", 0, &(sscape->hw))) < 0) {
 		printk(KERN_ERR "sscape: Failed to create firmware device\n");
-		goto _release_card;
+		goto _release_dma;
 	}
 	strlcpy(sscape->hw->name, "SoundScape M68K", sizeof(sscape->hw->name));
 	sscape->hw->name[sizeof(sscape->hw->name) - 1] = '\0';
@@ -1197,7 +1203,8 @@ static int __devinit create_sscape(int dev, struct snd_card **rcardp)
 	sscape_write_unsafe(sscape->io_base,
 	                    GA_INTCFG_REG, 0xf0 | (mpu_irq_cfg << 2) | mpu_irq_cfg);
 	sscape_write_unsafe(sscape->io_base,
-	                    GA_CDCFG_REG, 0x09 | DMA_8BIT | (dma[dev] << 4) | (irq_cfg << 1));
+			    GA_CDCFG_REG, 0x09 | DMA_8BIT
+			    | (dma[dev] << 4) | (irq_cfg << 1));
 
 	spin_unlock_irqrestore(&sscape->lock, flags);
 
@@ -1205,16 +1212,18 @@ static int __devinit create_sscape(int dev, struct snd_card **rcardp)
 	 * We have now enabled the codec chip, and so we should
 	 * detect the AD1845 device ...
 	 */
-	if ((err = create_ad1845(card, CODEC_IO(xport), irq[dev], dma[dev])) < 0) {
-		printk(KERN_ERR "sscape: No AD1845 device at 0x%x, IRQ %d\n",
-		                CODEC_IO(xport), irq[dev]);
-		goto _release_card;
+	err = create_ad1845(card, wss_port[dev], irq[dev],
+			    dma[dev], dma2[dev]);
+	if (err < 0) {
+		printk(KERN_ERR "sscape: No AD1845 device at 0x%lx, IRQ %d\n",
+		       wss_port[dev], irq[dev]);
+		goto _release_dma;
 	}
 #define MIDI_DEVNUM  0
 	if ((err = create_mpu401(card, MIDI_DEVNUM, MPU401_IO(xport), mpu_irq[dev])) < 0) {
 		printk(KERN_ERR "sscape: Failed to create MPU-401 device at 0x%x\n",
 		                MPU401_IO(xport));
-		goto _release_card;
+		goto _release_dma;
 	}
 
 	/*
@@ -1237,17 +1246,13 @@ static int __devinit create_sscape(int dev, struct snd_card **rcardp)
 	 *       function now that our "constructor" has completed.
 	 */
 	card->private_free = soundscape_free;
-	*rcardp = card;
 
 	return 0;
 
-	_release_card:
-	snd_card_free(card);
-
-	_release_dma:
+_release_dma:
 	free_dma(dma[dev]);
 
-	_release_region:
+_release_region:
 	release_and_free_resource(io_res);
 
 	return err;
@@ -1276,19 +1281,33 @@ static int __devinit snd_sscape_match(struct device *pdev, unsigned int i)
 static int __devinit snd_sscape_probe(struct device *pdev, unsigned int dev)
 {
 	struct snd_card *card;
+	struct soundscape *sscape;
 	int ret;
 
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE,
+			    sizeof(struct soundscape));
+	if (!card)
+		return -ENOMEM;
+
+	sscape = get_card_soundscape(card);
+	sscape->type = SSCAPE;
+
 	dma[dev] &= 0x03;
-	ret = create_sscape(dev, &card);
+	ret = create_sscape(dev, card);
 	if (ret < 0)
-		return ret;
+		goto _release_card;
+
 	snd_card_set_dev(card, pdev);
 	if ((ret = snd_card_register(card)) < 0) {
 		printk(KERN_ERR "sscape: Failed to register sound card\n");
-		return ret;
+		goto _release_card;
 	}
 	dev_set_drvdata(pdev, card);
 	return 0;
+
+_release_card:
+	snd_card_free(card);
+	return ret;
 }
 
 static int __devexit snd_sscape_remove(struct device *devptr, unsigned int dev)
@@ -1325,6 +1344,7 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 	static int idx = 0;
 	struct pnp_dev *dev;
 	struct snd_card *card;
+	struct soundscape *sscape;
 	int ret;
 
 	/*
@@ -1365,6 +1385,31 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 		}
 	}
 
+	/*
+	 * Create a new ALSA sound card entry, in anticipation
+	 * of detecting our hardware ...
+	 */
+	card = snd_card_new(index[idx], id[idx], THIS_MODULE,
+			    sizeof(struct soundscape));
+	if (!card)
+		return -ENOMEM;
+
+	sscape = get_card_soundscape(card);
+
+	/*
+	 * Identify card model ...
+	 */
+	if (!strncmp("ENS4081", pid->id, 7))
+		sscape->type = SSCAPE_VIVO;
+	else
+		sscape->type = SSCAPE_PNP;
+
+	/* VIVO fails for now */
+	if (sscape->type == SSCAPE_VIVO) {
+		ret = -ENODEV;
+		goto _release_card;
+	}
+
 	/*
 	 * Read the correct parameters off the ISA PnP bus ...
 	 */
@@ -1372,20 +1417,25 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 	irq[idx] = pnp_irq(dev, 0);
 	mpu_irq[idx] = pnp_irq(dev, 1);
 	dma[idx] = pnp_dma(dev, 0) & 0x03;
+	dma2[idx] = dma[idx];
+	wss_port[idx] = CODEC_IO(port[idx]);
 
-	ret = create_sscape(idx, &card);
+	ret = create_sscape(idx, card);
 	if (ret < 0)
-		return ret;
+		goto _release_card;
+
 	snd_card_set_dev(card, &pcard->card->dev);
 	if ((ret = snd_card_register(card)) < 0) {
 		printk(KERN_ERR "sscape: Failed to register sound card\n");
-		snd_card_free(card);
-		return ret;
+		goto _release_card;
 	}
 
 	pnp_set_card_drvdata(pcard, card);
 	++idx;
+	return 0;
 
+_release_card:
+	snd_card_free(card);
 	return ret;
 }
 

commit e65365de5ba280e058bd6b8b80c8790253268887
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jun 25 12:09:32 2007 +0200

    [ALSA] Fix invalid schedule_timeout_interruptible()
    
    Fixed the invalid use of schedule_timeout_interruptible() without
    checking pending signals.  Simply replaced with schedule_timeout().
    Suggestions thanks to Jeff Garzik.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 9ea417bcf3e5..cbad2a51cbaa 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -382,7 +382,7 @@ static int obp_startup_ack(struct soundscape *s, unsigned timeout)
 		unsigned long flags;
 		unsigned char x;
 
-		schedule_timeout_interruptible(1);
+		schedule_timeout(1);
 
 		spin_lock_irqsave(&s->lock, flags);
 		x = inb(HOST_DATA_IO(s->io_base));
@@ -409,7 +409,7 @@ static int host_startup_ack(struct soundscape *s, unsigned timeout)
 		unsigned long flags;
 		unsigned char x;
 
-		schedule_timeout_interruptible(1);
+		schedule_timeout(1);
 
 		spin_lock_irqsave(&s->lock, flags);
 		x = inb(HOST_DATA_IO(s->io_base));

commit 609d7694152f85734560ddc83be5e551b34d8c44
Author: Rene Herman <rene.herman@gmail.com>
Date:   Tue May 15 11:42:56 2007 +0200

    [ALSA] Fix probe of non-PnP ISA devices
    
    isa_register_driver() returns an error if no device is found
    and it's no fatal error for the drivers with pnp support.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 08c14978558c..9ea417bcf3e5 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -69,7 +69,9 @@ module_param_array(dma, int, NULL, 0444);
 MODULE_PARM_DESC(dma, "DMA # for SoundScape driver.");
 
 #ifdef CONFIG_PNP
+static int isa_registered;
 static int pnp_registered;
+
 static struct pnp_card_device_id sscape_pnpids[] = {
 	{ .id = "ENS3081", .devs = { { "ENS0000" } } },
 	{ .id = "" }	/* end */
@@ -1405,22 +1407,21 @@ static struct pnp_card_driver sscape_pnpc_driver = {
 
 static int __init sscape_init(void)
 {
-	int ret;
+	int err;
 
-	/*
-	 * First check whether we were passed any parameters.
-	 * These MUST take precedence over ANY automatic way
-	 * of allocating cards, because the operator is
-	 * S-P-E-L-L-I-N-G it out for us...
-	 */
-	ret = isa_register_driver(&snd_sscape_driver, SNDRV_CARDS);
-	if (ret < 0)
-		return ret;
+	err = isa_register_driver(&snd_sscape_driver, SNDRV_CARDS);
 #ifdef CONFIG_PNP
-	if (pnp_register_card_driver(&sscape_pnpc_driver) == 0)
+	if (!err)
+		isa_registered = 1;
+
+	err = pnp_register_card_driver(&sscape_pnpc_driver);
+	if (!err)
 		pnp_registered = 1;
+
+	if (isa_registered)
+		err = 0;
 #endif
-	return 0;
+	return err;
 }
 
 static void __exit sscape_exit(void)
@@ -1428,8 +1429,9 @@ static void __exit sscape_exit(void)
 #ifdef CONFIG_PNP
 	if (pnp_registered)
 		pnp_unregister_card_driver(&sscape_pnpc_driver);
+	if (isa_registered)
 #endif
-	isa_unregister_driver(&snd_sscape_driver);
+		isa_unregister_driver(&snd_sscape_driver);
 }
 
 module_init(sscape_init);

commit 83c51c0ab08f55468d8f5444ff2f70a36841a21f
Author: Rene Herman <rene.herman@gmail.com>
Date:   Tue Mar 20 11:33:46 2007 +0100

    [ALSA] isa_bus device/driver naming
    
    isa_bus: delete snd_ prefix from the (sysfs visible) device/driver names.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 369de44a6904..08c14978558c 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -1296,7 +1296,7 @@ static int __devexit snd_sscape_remove(struct device *devptr, unsigned int dev)
 	return 0;
 }
 
-#define SSCAPE_DRIVER	"snd_sscape"
+#define DEV_NAME "sscape"
 
 static struct isa_driver snd_sscape_driver = {
 	.match		= snd_sscape_match,
@@ -1304,7 +1304,7 @@ static struct isa_driver snd_sscape_driver = {
 	.remove		= __devexit_p(snd_sscape_remove),
 	/* FIXME: suspend/resume */
 	.driver		= {
-		.name	= SSCAPE_DRIVER
+		.name	= DEV_NAME
 	},
 };
 

commit 5e24c1c1c496c4603395d6e9cc320f85008fc891
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 22 12:50:54 2007 +0100

    [ALSA] Port the rest of ALSA ISA drivers to isa_driver
    
    Port the rest of ALSA ISA drivers to use isa_driver framework
    instead of platform_driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index b1f25823c652..369de44a6904 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -24,7 +24,7 @@
 #include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/err.h>
-#include <linux/platform_device.h>
+#include <linux/isa.h>
 #include <linux/delay.h>
 #include <linux/pnp.h>
 #include <linux/spinlock.h>
@@ -68,8 +68,6 @@ MODULE_PARM_DESC(mpu_irq, "MPU401 IRQ # for SoundScape driver.");
 module_param_array(dma, int, NULL, 0444);
 MODULE_PARM_DESC(dma, "DMA # for SoundScape driver.");
 
-static struct platform_device *platform_devices[SNDRV_CARDS];
-  
 #ifdef CONFIG_PNP
 static int pnp_registered;
 static struct pnp_card_device_id sscape_pnpids[] = {
@@ -1254,9 +1252,27 @@ static int __devinit create_sscape(int dev, struct snd_card **rcardp)
 }
 
 
-static int __devinit snd_sscape_probe(struct platform_device *pdev)
+static int __devinit snd_sscape_match(struct device *pdev, unsigned int i)
+{
+	/*
+	 * Make sure we were given ALL of the other parameters.
+	 */
+	if (port[i] == SNDRV_AUTO_PORT)
+		return 0;
+
+	if (irq[i] == SNDRV_AUTO_IRQ ||
+	    mpu_irq[i] == SNDRV_AUTO_IRQ ||
+	    dma[i] == SNDRV_AUTO_DMA) {
+		printk(KERN_INFO
+		       "sscape: insufficient parameters, need IO, IRQ, MPU-IRQ and DMA\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+static int __devinit snd_sscape_probe(struct device *pdev, unsigned int dev)
 {
-	int dev = pdev->id;
 	struct snd_card *card;
 	int ret;
 
@@ -1264,25 +1280,26 @@ static int __devinit snd_sscape_probe(struct platform_device *pdev)
 	ret = create_sscape(dev, &card);
 	if (ret < 0)
 		return ret;
-	snd_card_set_dev(card, &pdev->dev);
+	snd_card_set_dev(card, pdev);
 	if ((ret = snd_card_register(card)) < 0) {
 		printk(KERN_ERR "sscape: Failed to register sound card\n");
 		return ret;
 	}
-	platform_set_drvdata(pdev, card);
+	dev_set_drvdata(pdev, card);
 	return 0;
 }
 
-static int __devexit snd_sscape_remove(struct platform_device *devptr)
+static int __devexit snd_sscape_remove(struct device *devptr, unsigned int dev)
 {
-	snd_card_free(platform_get_drvdata(devptr));
-	platform_set_drvdata(devptr, NULL);
+	snd_card_free(dev_get_drvdata(devptr));
+	dev_set_drvdata(devptr, NULL);
 	return 0;
 }
 
 #define SSCAPE_DRIVER	"snd_sscape"
 
-static struct platform_driver snd_sscape_driver = {
+static struct isa_driver snd_sscape_driver = {
+	.match		= snd_sscape_match,
 	.probe		= snd_sscape_probe,
 	.remove		= __devexit_p(snd_sscape_remove),
 	/* FIXME: suspend/resume */
@@ -1386,72 +1403,6 @@ static struct pnp_card_driver sscape_pnpc_driver = {
 
 #endif /* CONFIG_PNP */
 
-static void __init_or_module sscape_unregister_all(void)
-{
-	int i;
-
-#ifdef CONFIG_PNP
-	if (pnp_registered)
-		pnp_unregister_card_driver(&sscape_pnpc_driver);
-#endif
-	for (i = 0; i < ARRAY_SIZE(platform_devices); ++i)
-		platform_device_unregister(platform_devices[i]);
-	platform_driver_unregister(&snd_sscape_driver);
-}
-
-static int __init sscape_manual_probe(void)
-{
-	struct platform_device *device;
-	int i, ret;
-
-	ret = platform_driver_register(&snd_sscape_driver);
-	if (ret < 0)
-		return ret;
-
-	for (i = 0; i < SNDRV_CARDS; ++i) {
-		/*
-		 * We do NOT probe for ports.
-		 * If we're not given a port number for this
-		 * card then we completely ignore this line
-		 * of parameters.
-		 */
-		if (port[i] == SNDRV_AUTO_PORT)
-			continue;
-
-		/*
-		 * Make sure we were given ALL of the other parameters.
-		 */
-		if (irq[i] == SNDRV_AUTO_IRQ ||
-		    mpu_irq[i] == SNDRV_AUTO_IRQ ||
-		    dma[i] == SNDRV_AUTO_DMA) {
-			printk(KERN_INFO
-			       "sscape: insufficient parameters, need IO, IRQ, MPU-IRQ and DMA\n");
-			sscape_unregister_all();
-			return -ENXIO;
-		}
-
-		/*
-		 * This cards looks OK ...
-		 */
-		device = platform_device_register_simple(SSCAPE_DRIVER,
-							 i, NULL, 0);
-		if (IS_ERR(device))
-			continue;
-		if (!platform_get_drvdata(device)) {
-			platform_device_unregister(device);
-			continue;
-		}
-		platform_devices[i] = device;
-	}
-	return 0;
-}
-
-static void sscape_exit(void)
-{
-	sscape_unregister_all();
-}
-
-
 static int __init sscape_init(void)
 {
 	int ret;
@@ -1462,7 +1413,7 @@ static int __init sscape_init(void)
 	 * of allocating cards, because the operator is
 	 * S-P-E-L-L-I-N-G it out for us...
 	 */
-	ret = sscape_manual_probe();
+	ret = isa_register_driver(&snd_sscape_driver, SNDRV_CARDS);
 	if (ret < 0)
 		return ret;
 #ifdef CONFIG_PNP
@@ -1472,5 +1423,14 @@ static int __init sscape_init(void)
 	return 0;
 }
 
+static void __exit sscape_exit(void)
+{
+#ifdef CONFIG_PNP
+	if (pnp_registered)
+		pnp_unregister_card_driver(&sscape_pnpc_driver);
+#endif
+	isa_unregister_driver(&snd_sscape_driver);
+}
+
 module_init(sscape_init);
 module_exit(sscape_exit);

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 27271c9446dc..b1f25823c652 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -900,7 +900,7 @@ static int __devinit create_mpu401(struct snd_card *card, int devnum, unsigned l
 	if ((err = snd_mpu401_uart_new(card, devnum,
 	                               MPU401_HW_MPU401,
 	                               port, MPU401_INFO_INTEGRATED,
-	                               irq, SA_INTERRUPT,
+	                               irq, IRQF_DISABLED,
 	                               &rawmidi)) == 0) {
 		struct snd_mpu401 *mpu = (struct snd_mpu401 *) rawmidi->private_data;
 		mpu->open_input = mpu401_open;

commit 302e4c2f9e2b9f07c69649782330a61c60001ac4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 23 13:24:30 2006 +0200

    [ALSA] Change an arugment of snd_mpu401_uart_new() to bit flags
    
    Change the 5th argument of snd_mpu401_uart_new() to bit flags
    instead of a boolean.  The argument takes bits that consist of
    MPU401_INFO_XXX flags.
    The callers that used the value 1 there are replaced with
    MPU401_INFO_INTEGRATED.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index d2a856f0fde2..27271c9446dc 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -897,10 +897,9 @@ static int __devinit create_mpu401(struct snd_card *card, int devnum, unsigned l
 	struct snd_rawmidi *rawmidi;
 	int err;
 
-#define MPU401_SHARE_HARDWARE  1
 	if ((err = snd_mpu401_uart_new(card, devnum,
 	                               MPU401_HW_MPU401,
-	                               port, MPU401_SHARE_HARDWARE,
+	                               port, MPU401_INFO_INTEGRATED,
 	                               irq, SA_INTERRUPT,
 	                               &rawmidi)) == 0) {
 		struct snd_mpu401 *mpu = (struct snd_mpu401 *) rawmidi->private_data;

commit dcccdd938ef0c5d96145957217b814b14bd46cdc
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Tue Apr 11 14:09:37 2006 +0200

    [ALSA] unregister platform device again if probe was unsuccessful
    
    Unregister the platform device again if the probe was unsuccessful.
    
    This restores the behaviour of not loading the driver on probe() failure.
    
    Signed-off-by: Rene Herman <rene.herman@keyaccess.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 532f6e0eff0b..d2a856f0fde2 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -1438,6 +1438,10 @@ static int __init sscape_manual_probe(void)
 							 i, NULL, 0);
 		if (IS_ERR(device))
 			continue;
+		if (!platform_get_drvdata(device)) {
+			platform_device_unregister(device);
+			continue;
+		}
 		platform_devices[i] = device;
 	}
 	return 0;

commit d0ac642d76c79c5cc673c4cdfe43e926379784e1
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Tue Apr 11 14:08:33 2006 +0200

    [ALSA] continue on IS_ERR from platform device registration
    
    Continue with the next one on error from device registration.
    
    This would seem the correct thing to do, even if it's not the probe()
    error that we're getting.
    
    Signed-off-by: Rene Herman <rene.herman@keyaccess.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 48e5552d3444..532f6e0eff0b 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -1427,8 +1427,8 @@ static int __init sscape_manual_probe(void)
 		    dma[i] == SNDRV_AUTO_DMA) {
 			printk(KERN_INFO
 			       "sscape: insufficient parameters, need IO, IRQ, MPU-IRQ and DMA\n");
-			ret = -ENXIO;
-			goto errout;
+			sscape_unregister_all();
+			return -ENXIO;
 		}
 
 		/*
@@ -1436,17 +1436,11 @@ static int __init sscape_manual_probe(void)
 		 */
 		device = platform_device_register_simple(SSCAPE_DRIVER,
 							 i, NULL, 0);
-		if (IS_ERR(device)) {
-			ret = PTR_ERR(device);
-			goto errout;
-		}
+		if (IS_ERR(device))
+			continue;
 		platform_devices[i] = device;
 	}
 	return 0;
-
- errout:
-	sscape_unregister_all();
-	return ret;
 }
 
 static void sscape_exit(void)

commit 38125956441c5cab28333414cee308d162507477
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Mar 27 01:17:17 2006 -0800

    [PATCH] PNP: adjust pnp_register_card_driver() signature: sscape
    
    Remove the assumption that pnp_register_card_driver() returns the
    number of devices claimed.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 29bba8cc3ef3..48e5552d3444 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -1255,7 +1255,7 @@ static int __devinit create_sscape(int dev, struct snd_card **rcardp)
 }
 
 
-static int __init snd_sscape_probe(struct platform_device *pdev)
+static int __devinit snd_sscape_probe(struct platform_device *pdev)
 {
 	int dev = pdev->id;
 	struct snd_card *card;
@@ -1469,7 +1469,7 @@ static int __init sscape_init(void)
 	if (ret < 0)
 		return ret;
 #ifdef CONFIG_PNP
-	if (pnp_register_card_driver(&sscape_pnpc_driver) >= 0)
+	if (pnp_register_card_driver(&sscape_pnpc_driver) == 0)
 		pnp_registered = 1;
 #endif
 	return 0;

commit 59b1b34f47e6c8ac8f00660db2cd34216819b400
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 4 15:06:44 2006 +0100

    [ALSA] Fix compilation without CONFIG_PNP
    
    Fix compilation of some ISA drivers without CONFIG_PNP.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 5fb981c0a281..29bba8cc3ef3 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -69,9 +69,9 @@ module_param_array(dma, int, NULL, 0444);
 MODULE_PARM_DESC(dma, "DMA # for SoundScape driver.");
 
 static struct platform_device *platform_devices[SNDRV_CARDS];
-static int pnp_registered;
   
 #ifdef CONFIG_PNP
+static int pnp_registered;
 static struct pnp_card_device_id sscape_pnpids[] = {
 	{ .id = "ENS3081", .devs = { { "ENS0000" } } },
 	{ .id = "" }	/* end */
@@ -1391,8 +1391,10 @@ static void __init_or_module sscape_unregister_all(void)
 {
 	int i;
 
+#ifdef CONFIG_PNP
 	if (pnp_registered)
 		pnp_unregister_card_driver(&sscape_pnpc_driver);
+#endif
 	for (i = 0; i < ARRAY_SIZE(platform_devices); ++i)
 		platform_device_unregister(platform_devices[i]);
 	platform_driver_unregister(&snd_sscape_driver);
@@ -1466,8 +1468,10 @@ static int __init sscape_init(void)
 	ret = sscape_manual_probe();
 	if (ret < 0)
 		return ret;
+#ifdef CONFIG_PNP
 	if (pnp_register_card_driver(&sscape_pnpc_driver) >= 0)
 		pnp_registered = 1;
+#endif
 	return 0;
 }
 

commit f7a9275d949cb0bf1f259a1546e52a0bf518151c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Dec 7 09:13:42 2005 +0100

    [ALSA] unregister platform devices
    
    Call platform_device_unregister() for all platform devices that we've
    registered.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 6271efe689df..5fb981c0a281 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -67,6 +67,9 @@ MODULE_PARM_DESC(mpu_irq, "MPU401 IRQ # for SoundScape driver.");
 
 module_param_array(dma, int, NULL, 0444);
 MODULE_PARM_DESC(dma, "DMA # for SoundScape driver.");
+
+static struct platform_device *platform_devices[SNDRV_CARDS];
+static int pnp_registered;
   
 #ifdef CONFIG_PNP
 static struct pnp_card_device_id sscape_pnpids[] = {
@@ -1384,6 +1387,17 @@ static struct pnp_card_driver sscape_pnpc_driver = {
 
 #endif /* CONFIG_PNP */
 
+static void __init_or_module sscape_unregister_all(void)
+{
+	int i;
+
+	if (pnp_registered)
+		pnp_unregister_card_driver(&sscape_pnpc_driver);
+	for (i = 0; i < ARRAY_SIZE(platform_devices); ++i)
+		platform_device_unregister(platform_devices[i]);
+	platform_driver_unregister(&snd_sscape_driver);
+}
+
 static int __init sscape_manual_probe(void)
 {
 	struct platform_device *device;
@@ -1411,8 +1425,8 @@ static int __init sscape_manual_probe(void)
 		    dma[i] == SNDRV_AUTO_DMA) {
 			printk(KERN_INFO
 			       "sscape: insufficient parameters, need IO, IRQ, MPU-IRQ and DMA\n");
-			platform_driver_unregister(&snd_sscape_driver);
-			return -ENXIO;
+			ret = -ENXIO;
+			goto errout;
 		}
 
 		/*
@@ -1421,17 +1435,21 @@ static int __init sscape_manual_probe(void)
 		device = platform_device_register_simple(SSCAPE_DRIVER,
 							 i, NULL, 0);
 		if (IS_ERR(device)) {
-			platform_driver_unregister(&snd_sscape_driver);
-			return PTR_ERR(device);
+			ret = PTR_ERR(device);
+			goto errout;
 		}
+		platform_devices[i] = device;
 	}
 	return 0;
+
+ errout:
+	sscape_unregister_all();
+	return ret;
 }
 
 static void sscape_exit(void)
 {
-	pnp_unregister_card_driver(&sscape_pnpc_driver);
-	platform_driver_unregister(&snd_sscape_driver);
+	sscape_unregister_all();
 }
 
 
@@ -1448,7 +1466,8 @@ static int __init sscape_init(void)
 	ret = sscape_manual_probe();
 	if (ret < 0)
 		return ret;
-	pnp_register_card_driver(&sscape_pnpc_driver);
+	if (pnp_register_card_driver(&sscape_pnpc_driver) >= 0)
+		pnp_registered = 1;
 	return 0;
 }
 

commit 277e926c9b2722317a6bf89ed921d97f6784e0cc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 17:13:12 2005 +0100

    [ALSA] sscape - Use platform_device
    
    Modules: Sound Scape driver
    
    Rewrite the probe/remove with platform_device.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index d07963eddb3f..6271efe689df 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -23,6 +23,8 @@
 
 #include <sound/driver.h>
 #include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <linux/pnp.h>
 #include <linux/spinlock.h>
@@ -75,8 +77,6 @@ static struct pnp_card_device_id sscape_pnpids[] = {
 MODULE_DEVICE_TABLE(pnp_card, sscape_pnpids);
 #endif
 
-static struct snd_card *sscape_card[SNDRV_CARDS];
-
 
 #define MPU401_IO(i)     ((i) + 0)
 #define MIDI_DATA_IO(i)  ((i) + 0)
@@ -1080,48 +1080,18 @@ static int __devinit create_ad1845(struct snd_card *card, unsigned port, int irq
 }
 
 
-struct params
-{
-	int index;
-	const char *id;
-	unsigned port;
-	int irq;
-	int mpu_irq;
-	int dma1;
-};
-
-
-static inline struct params*
-init_params(struct params *params,
-            int index,
-            const char *id,
-            unsigned port,
-            int irq,
-            int mpu_irq,
-            int dma1)
-{
-	params->index = index;
-	params->id = id;
-	params->port = port;
-	params->irq = irq;
-	params->mpu_irq = mpu_irq;  
-	params->dma1 = (dma1 & 0x03);
-
-	return params;
-}
-
-
 /*
  * Create an ALSA soundcard entry for the SoundScape, using
  * the given list of port, IRQ and DMA resources.
  */
-static int __devinit create_sscape(const struct params *params, struct snd_card **rcardp)
+static int __devinit create_sscape(int dev, struct snd_card **rcardp)
 {
 	struct snd_card *card;
 	register struct soundscape *sscape;
 	register unsigned dma_cfg;
 	unsigned irq_cfg;
 	unsigned mpu_irq_cfg;
+	unsigned xport;
 	struct resource *io_res;
 	unsigned long flags;
 	int err;
@@ -1129,32 +1099,33 @@ static int __devinit create_sscape(const struct params *params, struct snd_card
 	/*
 	 * Check that the user didn't pass us garbage data ...
 	 */
-	irq_cfg = get_irq_config(params->irq);
+	irq_cfg = get_irq_config(irq[dev]);
 	if (irq_cfg == INVALID_IRQ) {
-		snd_printk(KERN_ERR "sscape: Invalid IRQ %d\n", params->irq);
+		snd_printk(KERN_ERR "sscape: Invalid IRQ %d\n", irq[dev]);
 		return -ENXIO;
 	}
 
-	mpu_irq_cfg = get_irq_config(params->mpu_irq);
+	mpu_irq_cfg = get_irq_config(mpu_irq[dev]);
 	if (mpu_irq_cfg == INVALID_IRQ) {
-		printk(KERN_ERR "sscape: Invalid IRQ %d\n", params->mpu_irq);
+		printk(KERN_ERR "sscape: Invalid IRQ %d\n", mpu_irq[dev]);
 		return -ENXIO;
 	}
+	xport = port[dev];
 
 	/*
 	 * Grab IO ports that we will need to probe so that we
 	 * can detect and control this hardware ...
 	 */
-	if ((io_res = request_region(params->port, 8, "SoundScape")) == NULL) {
-		snd_printk(KERN_ERR "sscape: can't grab port 0x%x\n", params->port);
+	if ((io_res = request_region(xport, 8, "SoundScape")) == NULL) {
+		snd_printk(KERN_ERR "sscape: can't grab port 0x%x\n", xport);
 		return -EBUSY;
 	}
 
 	/*
 	 * Grab both DMA channels (OK, only one for now) ...
 	 */
-	if ((err = request_dma(params->dma1, "SoundScape")) < 0) {
-		snd_printk(KERN_ERR "sscape: can't grab DMA %d\n", params->dma1);
+	if ((err = request_dma(dma[dev], "SoundScape")) < 0) {
+		snd_printk(KERN_ERR "sscape: can't grab DMA %d\n", dma[dev]);
 		goto _release_region;
 	}
 
@@ -1162,7 +1133,8 @@ static int __devinit create_sscape(const struct params *params, struct snd_card
 	 * Create a new ALSA sound card entry, in anticipation
 	 * of detecting our hardware ...
 	 */
-	if ((card = snd_card_new(params->index, params->id, THIS_MODULE, sizeof(struct soundscape))) == NULL) {
+	if ((card = snd_card_new(index[dev], id[dev], THIS_MODULE,
+				 sizeof(struct soundscape))) == NULL) {
 		err = -ENOMEM;
 		goto _release_dma;
 	}
@@ -1171,7 +1143,7 @@ static int __devinit create_sscape(const struct params *params, struct snd_card
 	spin_lock_init(&sscape->lock);
 	spin_lock_init(&sscape->fwlock);
 	sscape->io_res = io_res;
-	sscape->io_base = params->port;
+	sscape->io_base = xport;
 
 	if (!detect_sscape(sscape)) {
 		printk(KERN_ERR "sscape: hardware not detected at 0x%x\n", sscape->io_base);
@@ -1180,7 +1152,7 @@ static int __devinit create_sscape(const struct params *params, struct snd_card
 	}
 
 	printk(KERN_INFO "sscape: hardware detected at 0x%x, using IRQ %d, DMA %d\n",
-	                 sscape->io_base, params->irq, params->dma1);
+	                 sscape->io_base, irq[dev], dma[dev]);
 
 	/*
 	 * Now create the hardware-specific device so that we can
@@ -1223,7 +1195,7 @@ static int __devinit create_sscape(const struct params *params, struct snd_card
 	sscape_write_unsafe(sscape->io_base,
 	                    GA_INTCFG_REG, 0xf0 | (mpu_irq_cfg << 2) | mpu_irq_cfg);
 	sscape_write_unsafe(sscape->io_base,
-	                    GA_CDCFG_REG, 0x09 | DMA_8BIT | (params->dma1 << 4) | (irq_cfg << 1));
+	                    GA_CDCFG_REG, 0x09 | DMA_8BIT | (dma[dev] << 4) | (irq_cfg << 1));
 
 	spin_unlock_irqrestore(&sscape->lock, flags);
 
@@ -1231,15 +1203,15 @@ static int __devinit create_sscape(const struct params *params, struct snd_card
 	 * We have now enabled the codec chip, and so we should
 	 * detect the AD1845 device ...
 	 */
-	if ((err = create_ad1845(card, CODEC_IO(params->port), params->irq, params->dma1)) < 0) {
+	if ((err = create_ad1845(card, CODEC_IO(xport), irq[dev], dma[dev])) < 0) {
 		printk(KERN_ERR "sscape: No AD1845 device at 0x%x, IRQ %d\n",
-		                CODEC_IO(params->port), params->irq);
+		                CODEC_IO(xport), irq[dev]);
 		goto _release_card;
 	}
 #define MIDI_DEVNUM  0
-	if ((err = create_mpu401(card, MIDI_DEVNUM, MPU401_IO(params->port), params->mpu_irq)) < 0) {
+	if ((err = create_mpu401(card, MIDI_DEVNUM, MPU401_IO(xport), mpu_irq[dev])) < 0) {
 		printk(KERN_ERR "sscape: Failed to create MPU-401 device at 0x%x\n",
-		                MPU401_IO(params->port));
+		                MPU401_IO(xport));
 		goto _release_card;
 	}
 
@@ -1271,7 +1243,7 @@ static int __devinit create_sscape(const struct params *params, struct snd_card
 	snd_card_free(card);
 
 	_release_dma:
-	free_dma(params->dma1);
+	free_dma(dma[dev]);
 
 	_release_region:
 	release_and_free_resource(io_res);
@@ -1280,44 +1252,66 @@ static int __devinit create_sscape(const struct params *params, struct snd_card
 }
 
 
-static int sscape_cards __devinitdata;
-static struct params sscape_params[SNDRV_CARDS] __devinitdata;
+static int __init snd_sscape_probe(struct platform_device *pdev)
+{
+	int dev = pdev->id;
+	struct snd_card *card;
+	int ret;
+
+	dma[dev] &= 0x03;
+	ret = create_sscape(dev, &card);
+	if (ret < 0)
+		return ret;
+	snd_card_set_dev(card, &pdev->dev);
+	if ((ret = snd_card_register(card)) < 0) {
+		printk(KERN_ERR "sscape: Failed to register sound card\n");
+		return ret;
+	}
+	platform_set_drvdata(pdev, card);
+	return 0;
+}
+
+static int __devexit snd_sscape_remove(struct platform_device *devptr)
+{
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+	return 0;
+}
+
+#define SSCAPE_DRIVER	"snd_sscape"
+
+static struct platform_driver snd_sscape_driver = {
+	.probe		= snd_sscape_probe,
+	.remove		= __devexit_p(snd_sscape_remove),
+	/* FIXME: suspend/resume */
+	.driver		= {
+		.name	= SSCAPE_DRIVER
+	},
+};
 
 #ifdef CONFIG_PNP
 static inline int __devinit get_next_autoindex(int i)
 {
-	while ((i < SNDRV_CARDS) && (port[i] != SNDRV_AUTO_PORT)) {
+	while (i < SNDRV_CARDS && port[i] != SNDRV_AUTO_PORT)
 		++i;
-	} /* while */
-
 	return i;
 }
 
 
-static inline int __devinit is_port_known(unsigned io, struct params *params, int cards)
-{
-	while (--cards >= 0) {
-		if (params[cards].port == io)
-			return 1;
-	} /* while */
-
-	return 0;
-}
-
 static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 				       const struct pnp_card_device_id *pid)
 {
-	struct pnp_dev *dev;
 	static int idx = 0;
+	struct pnp_dev *dev;
+	struct snd_card *card;
 	int ret;
 
 	/*
 	 * Allow this function to fail *quietly* if all the ISA PnP
 	 * devices were configured using module parameters instead.
 	 */
-	if ((idx = get_next_autoindex(idx)) >= SNDRV_CARDS) {
+	if ((idx = get_next_autoindex(idx)) >= SNDRV_CARDS)
 		return -ENOSPC;
-	}
 
 	/*
 	 * We have found a candidate ISA PnP card. Now we
@@ -1339,66 +1333,45 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 	/*
 	 * Check that we still have room for another sound card ...
 	 */
-	if (sscape_cards >= SNDRV_CARDS) {
-		printk(KERN_ERR "sscape: No room for another ALSA device\n");
-		return -ENOSPC;
-	}
-
-	ret = -ENODEV;
-
 	dev = pnp_request_card_device(pcard, pid->devs[0].id, NULL);
-	if (dev) {
-		struct params *this;
-		if (!pnp_is_active(dev)) {
-			if (pnp_activate_dev(dev) < 0) {
-				printk(KERN_INFO "sscape: device is inactive\n");
-				return -EBUSY;
-			}
-		}
-		/*
-		 * Read the correct parameters off the ISA PnP bus ...
-		 */
-		this = init_params(&sscape_params[sscape_cards],
-				   index[idx],
-				   id[idx],
-				   pnp_port_start(dev, 0),
-				   pnp_irq(dev, 0),
-				   pnp_irq(dev, 1),
-				   pnp_dma(dev, 0));
+	if (! dev)
+		return -ENODEV;
 
-		/*
-		 * Do we know about this sound card already?
-		 */
-		if ( !is_port_known(this->port, sscape_params, sscape_cards) ) {
-			struct snd_card *card;
-
-			ret = create_sscape(this, &card);
-			if (ret < 0)
-				return ret;
-			snd_card_set_dev(card, &pcard->card->dev);
-
-			if ((ret = snd_card_register(card)) < 0) {
-				printk(KERN_ERR "sscape: Failed to register sound card\n");
-				snd_card_free(card);
-				return ret;
-			}
-
-			pnp_set_card_drvdata(pcard, card);
-			++sscape_cards;
-			++idx;
+	if (!pnp_is_active(dev)) {
+		if (pnp_activate_dev(dev) < 0) {
+			printk(KERN_INFO "sscape: device is inactive\n");
+			return -EBUSY;
 		}
 	}
 
+	/*
+	 * Read the correct parameters off the ISA PnP bus ...
+	 */
+	port[idx] = pnp_port_start(dev, 0);
+	irq[idx] = pnp_irq(dev, 0);
+	mpu_irq[idx] = pnp_irq(dev, 1);
+	dma[idx] = pnp_dma(dev, 0) & 0x03;
+
+	ret = create_sscape(idx, &card);
+	if (ret < 0)
+		return ret;
+	snd_card_set_dev(card, &pcard->card->dev);
+	if ((ret = snd_card_register(card)) < 0) {
+		printk(KERN_ERR "sscape: Failed to register sound card\n");
+		snd_card_free(card);
+		return ret;
+	}
+
+	pnp_set_card_drvdata(pcard, card);
+	++idx;
+
 	return ret;
 }
 
 static void __devexit sscape_pnp_remove(struct pnp_card_link * pcard)
 {
-	struct snd_card *card = (struct snd_card *) pnp_get_card_drvdata(pcard);
-        
+	snd_card_free(pnp_get_card_drvdata(pcard));
 	pnp_set_card_drvdata(pcard, NULL);
-	snd_card_disconnect(card);
-	snd_card_free_in_thread(card);
 }
 
 static struct pnp_card_driver sscape_pnpc_driver = {
@@ -1411,11 +1384,14 @@ static struct pnp_card_driver sscape_pnpc_driver = {
 
 #endif /* CONFIG_PNP */
 
-static int __init sscape_manual_probe(struct params *params)
+static int __init sscape_manual_probe(void)
 {
-	int ret;
-	unsigned i;
-	struct snd_card *card;
+	struct platform_device *device;
+	int i, ret;
+
+	ret = platform_driver_register(&snd_sscape_driver);
+	if (ret < 0)
+		return ret;
 
 	for (i = 0; i < SNDRV_CARDS; ++i) {
 		/*
@@ -1430,52 +1406,32 @@ static int __init sscape_manual_probe(struct params *params)
 		/*
 		 * Make sure we were given ALL of the other parameters.
 		 */
-		if ( (irq[i] == SNDRV_AUTO_IRQ) ||
-		     (mpu_irq[i] == SNDRV_AUTO_IRQ) ||
-		     (dma[i] == SNDRV_AUTO_DMA) ) {
+		if (irq[i] == SNDRV_AUTO_IRQ ||
+		    mpu_irq[i] == SNDRV_AUTO_IRQ ||
+		    dma[i] == SNDRV_AUTO_DMA) {
 			printk(KERN_INFO
 			       "sscape: insufficient parameters, need IO, IRQ, MPU-IRQ and DMA\n");
+			platform_driver_unregister(&snd_sscape_driver);
 			return -ENXIO;
 		}
 
 		/*
 		 * This cards looks OK ...
 		 */
-		init_params(params, index[i], id[i], port[i], irq[i], mpu_irq[i], dma[i]);
-
-		ret = create_sscape(params, &card);
-		if (ret < 0)
-			return ret;
-
-		if ((ret = snd_card_set_generic_dev(card)) < 0) {
-			snd_card_free(card);
-			return ret;
-		}
-		if ((ret = snd_card_register(card)) < 0) {
-			printk(KERN_ERR "sscape: Failed to register sound card\n");
-			snd_card_free(card);
-			return ret;
+		device = platform_device_register_simple(SSCAPE_DRIVER,
+							 i, NULL, 0);
+		if (IS_ERR(device)) {
+			platform_driver_unregister(&snd_sscape_driver);
+			return PTR_ERR(device);
 		}
-
-		sscape_card[sscape_cards] = card;
-		params++;
-		sscape_cards++;
-	} /* for */
-
+	}
 	return 0;
 }
 
-
 static void sscape_exit(void)
 {
-	unsigned i;
-
-#ifdef CONFIG_PNP
 	pnp_unregister_card_driver(&sscape_pnpc_driver);
-#endif
-	for (i = 0; i < ARRAY_SIZE(sscape_card); ++i) {
-		snd_card_free(sscape_card[i]);
-	} /* for */
+	platform_driver_unregister(&snd_sscape_driver);
 }
 
 
@@ -1489,24 +1445,10 @@ static int __init sscape_init(void)
 	 * of allocating cards, because the operator is
 	 * S-P-E-L-L-I-N-G it out for us...
 	 */
-	ret = sscape_manual_probe(sscape_params);
-	if (ret < 0) {
-		int i;
-		for (i = 0; i < sscape_cards; ++i)
-			snd_card_free(sscape_card[i]);
+	ret = sscape_manual_probe();
+	if (ret < 0)
 		return ret;
-	}
-
-#ifdef CONFIG_PNP
-	if (sscape_cards < SNDRV_CARDS) {
-		ret = pnp_register_card_driver(&sscape_pnpc_driver);
-		if (ret < 0) {
-			sscape_exit();
-			return ret;
-		}
-	}
-#endif
-
+	pnp_register_card_driver(&sscape_pnpc_driver);
 	return 0;
 }
 

commit be6245373f46eb21839ba1b54c83bc7cc8274208
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:42:05 2005 +0100

    [ALSA] Remove xxx_t typedefs: ISA SoundScape
    
    Modules: Sound Scape driver
    
    Remove xxx_t typedefs from the ISA SoundScape driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 11588067fa4f..d07963eddb3f 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -75,7 +75,7 @@ static struct pnp_card_device_id sscape_pnpids[] = {
 MODULE_DEVICE_TABLE(pnp_card, sscape_pnpids);
 #endif
 
-static snd_card_t *sscape_card[SNDRV_CARDS];
+static struct snd_card *sscape_card[SNDRV_CARDS];
 
 
 #define MPU401_IO(i)     ((i) + 0)
@@ -127,9 +127,9 @@ struct soundscape {
 	int codec_type;
 	int ic_type;
 	struct resource *io_res;
-	cs4231_t *chip;
-	mpu401_t *mpu;
-	snd_hwdep_t *hw;
+	struct snd_cs4231 *chip;
+	struct snd_mpu401 *mpu;
+	struct snd_hwdep *hw;
 
 	/*
 	 * The MIDI device won't work until we've loaded
@@ -144,17 +144,17 @@ struct soundscape {
 #define INVALID_IRQ  ((unsigned)-1)
 
 
-static inline struct soundscape *get_card_soundscape(snd_card_t * c)
+static inline struct soundscape *get_card_soundscape(struct snd_card *c)
 {
 	return (struct soundscape *) (c->private_data);
 }
 
-static inline struct soundscape *get_mpu401_soundscape(mpu401_t * mpu)
+static inline struct soundscape *get_mpu401_soundscape(struct snd_mpu401 * mpu)
 {
 	return (struct soundscape *) (mpu->private_data);
 }
 
-static inline struct soundscape *get_hwdep_soundscape(snd_hwdep_t * hw)
+static inline struct soundscape *get_hwdep_soundscape(struct snd_hwdep * hw)
 {
 	return (struct soundscape *) (hw->private_data);
 }
@@ -308,7 +308,7 @@ static int host_write_ctrl_unsafe(unsigned io_base, unsigned char data,
  *
  * NOTE: This check is based upon observation, not documentation.
  */
-static inline int verify_mpu401(const mpu401_t * mpu)
+static inline int verify_mpu401(const struct snd_mpu401 * mpu)
 {
 	return ((inb(MIDI_CTRL_IO(mpu->port)) & 0xc0) == 0x80);
 }
@@ -316,7 +316,7 @@ static inline int verify_mpu401(const mpu401_t * mpu)
 /*
  * This is apparently the standard way to initailise an MPU-401
  */
-static inline void initialise_mpu401(const mpu401_t * mpu)
+static inline void initialise_mpu401(const struct snd_mpu401 * mpu)
 {
 	outb(0, MIDI_DATA_IO(mpu->port));
 }
@@ -335,7 +335,7 @@ static inline void activate_ad1845_unsafe(unsigned io_base)
 /*
  * Do the necessary ALSA-level cleanup to deallocate our driver ...
  */
-static void soundscape_free(snd_card_t * c)
+static void soundscape_free(struct snd_card *c)
 {
 	register struct soundscape *sscape = get_card_soundscape(c);
 	release_and_free_resource(sscape->io_res);
@@ -613,7 +613,7 @@ static int sscape_upload_microcode(struct soundscape *sscape,
  * simultaneously, and that we can't open it at all if
  * someone is using the MIDI device.
  */
-static int sscape_hw_open(snd_hwdep_t * hw, struct file *file)
+static int sscape_hw_open(struct snd_hwdep * hw, struct file *file)
 {
 	register struct soundscape *sscape = get_hwdep_soundscape(hw);
 	unsigned long flags;
@@ -632,7 +632,7 @@ static int sscape_hw_open(snd_hwdep_t * hw, struct file *file)
 	return err;
 }
 
-static int sscape_hw_release(snd_hwdep_t * hw, struct file *file)
+static int sscape_hw_release(struct snd_hwdep * hw, struct file *file)
 {
 	register struct soundscape *sscape = get_hwdep_soundscape(hw);
 	unsigned long flags;
@@ -643,7 +643,7 @@ static int sscape_hw_release(snd_hwdep_t * hw, struct file *file)
 	return 0;
 }
 
-static int sscape_hw_ioctl(snd_hwdep_t * hw, struct file *file,
+static int sscape_hw_ioctl(struct snd_hwdep * hw, struct file *file,
                            unsigned int cmd, unsigned long arg)
 {
 	struct soundscape *sscape = get_hwdep_soundscape(hw);
@@ -692,8 +692,8 @@ static int sscape_hw_ioctl(snd_hwdep_t * hw, struct file *file,
 /*
  * Mixer control for the SoundScape's MIDI device.
  */
-static int sscape_midi_info(snd_kcontrol_t * ctl,
-                            snd_ctl_elem_info_t * uinfo)
+static int sscape_midi_info(struct snd_kcontrol *ctl,
+                            struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
@@ -702,11 +702,11 @@ static int sscape_midi_info(snd_kcontrol_t * ctl,
 	return 0;
 }
 
-static int sscape_midi_get(snd_kcontrol_t * kctl,
-                           snd_ctl_elem_value_t * uctl)
+static int sscape_midi_get(struct snd_kcontrol *kctl,
+                           struct snd_ctl_elem_value *uctl)
 {
-	cs4231_t *chip = snd_kcontrol_chip(kctl);
-	snd_card_t *card = chip->card;
+	struct snd_cs4231 *chip = snd_kcontrol_chip(kctl);
+	struct snd_card *card = chip->card;
 	register struct soundscape *s = get_card_soundscape(card);
 	unsigned long flags;
 
@@ -722,11 +722,11 @@ static int sscape_midi_get(snd_kcontrol_t * kctl,
 	return 0;
 }
 
-static int sscape_midi_put(snd_kcontrol_t * kctl,
-                           snd_ctl_elem_value_t * uctl)
+static int sscape_midi_put(struct snd_kcontrol *kctl,
+                           struct snd_ctl_elem_value *uctl)
 {
-	cs4231_t *chip = snd_kcontrol_chip(kctl);
-	snd_card_t *card = chip->card;
+	struct snd_cs4231 *chip = snd_kcontrol_chip(kctl);
+	struct snd_card *card = chip->card;
 	register struct soundscape *s = get_card_soundscape(card);
 	unsigned long flags;
 	int change;
@@ -763,7 +763,7 @@ static int sscape_midi_put(snd_kcontrol_t * kctl,
 	return change;
 }
 
-static snd_kcontrol_new_t midi_mixer_ctl = {
+static struct snd_kcontrol_new midi_mixer_ctl = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "MIDI",
 	.info = sscape_midi_info,
@@ -849,7 +849,7 @@ static int __devinit detect_sscape(struct soundscape *s)
  * to crash the machine. Also check that someone isn't using the hardware
  * IOCTL device.
  */
-static int mpu401_open(mpu401_t * mpu)
+static int mpu401_open(struct snd_mpu401 * mpu)
 {
 	int err;
 
@@ -875,7 +875,7 @@ static int mpu401_open(mpu401_t * mpu)
 	return err;
 }
 
-static void mpu401_close(mpu401_t * mpu)
+static void mpu401_close(struct snd_mpu401 * mpu)
 {
 	register struct soundscape *sscape = get_mpu401_soundscape(mpu);
 	unsigned long flags;
@@ -888,10 +888,10 @@ static void mpu401_close(mpu401_t * mpu)
 /*
  * Initialse an MPU-401 subdevice for MIDI support on the SoundScape.
  */
-static int __devinit create_mpu401(snd_card_t * card, int devnum, unsigned long port, int irq)
+static int __devinit create_mpu401(struct snd_card *card, int devnum, unsigned long port, int irq)
 {
 	struct soundscape *sscape = get_card_soundscape(card);
-	snd_rawmidi_t *rawmidi;
+	struct snd_rawmidi *rawmidi;
 	int err;
 
 #define MPU401_SHARE_HARDWARE  1
@@ -900,7 +900,7 @@ static int __devinit create_mpu401(snd_card_t * card, int devnum, unsigned long
 	                               port, MPU401_SHARE_HARDWARE,
 	                               irq, SA_INTERRUPT,
 	                               &rawmidi)) == 0) {
-		mpu401_t *mpu = (mpu401_t *) rawmidi->private_data;
+		struct snd_mpu401 *mpu = (struct snd_mpu401 *) rawmidi->private_data;
 		mpu->open_input = mpu401_open;
 		mpu->open_output = mpu401_open;
 		mpu->close_input = mpu401_close;
@@ -919,7 +919,7 @@ static int __devinit create_mpu401(snd_card_t * card, int devnum, unsigned long
  * Override for the CS4231 playback format function.
  * The AD1845 has much simpler format and rate selection.
  */
-static void ad1845_playback_format(cs4231_t * chip, snd_pcm_hw_params_t * params, unsigned char format)
+static void ad1845_playback_format(struct snd_cs4231 * chip, struct snd_pcm_hw_params *params, unsigned char format)
 {
 	unsigned long flags;
 	unsigned rate = params_rate(params);
@@ -955,7 +955,7 @@ static void ad1845_playback_format(cs4231_t * chip, snd_pcm_hw_params_t * params
  * Override for the CS4231 capture format function. 
  * The AD1845 has much simpler format and rate selection.
  */
-static void ad1845_capture_format(cs4231_t * chip, snd_pcm_hw_params_t * params, unsigned char format)
+static void ad1845_capture_format(struct snd_cs4231 * chip, struct snd_pcm_hw_params *params, unsigned char format)
 {
 	unsigned long flags;
 	unsigned rate = params_rate(params);
@@ -993,10 +993,10 @@ static void ad1845_capture_format(cs4231_t * chip, snd_pcm_hw_params_t * params,
  * try to support at least some of the extra bits by overriding
  * some of the CS4231 callback.
  */
-static int __devinit create_ad1845(snd_card_t * card, unsigned port, int irq, int dma1)
+static int __devinit create_ad1845(struct snd_card *card, unsigned port, int irq, int dma1)
 {
 	register struct soundscape *sscape = get_card_soundscape(card);
-	cs4231_t *chip;
+	struct snd_cs4231 *chip;
 	int err;
 
 #define CS4231_SHARE_HARDWARE  (CS4231_HWSHARE_DMA1 | CS4231_HWSHARE_DMA2)
@@ -1009,7 +1009,7 @@ static int __devinit create_ad1845(snd_card_t * card, unsigned port, int irq, in
 				     CS4231_HW_DETECT,
 				     CS4231_HWSHARE_DMA1, &chip)) == 0) {
 		unsigned long flags;
-		snd_pcm_t *pcm;
+		struct snd_pcm *pcm;
 
 #define AD1845_FREQ_SEL_ENABLE  0x08
 
@@ -1115,9 +1115,9 @@ init_params(struct params *params,
  * Create an ALSA soundcard entry for the SoundScape, using
  * the given list of port, IRQ and DMA resources.
  */
-static int __devinit create_sscape(const struct params *params, snd_card_t **rcardp)
+static int __devinit create_sscape(const struct params *params, struct snd_card **rcardp)
 {
-	snd_card_t *card;
+	struct snd_card *card;
 	register struct soundscape *sscape;
 	register unsigned dma_cfg;
 	unsigned irq_cfg;
@@ -1370,7 +1370,7 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 		 * Do we know about this sound card already?
 		 */
 		if ( !is_port_known(this->port, sscape_params, sscape_cards) ) {
-			snd_card_t *card;
+			struct snd_card *card;
 
 			ret = create_sscape(this, &card);
 			if (ret < 0)
@@ -1394,7 +1394,7 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 
 static void __devexit sscape_pnp_remove(struct pnp_card_link * pcard)
 {
-	snd_card_t *card = (snd_card_t *) pnp_get_card_drvdata(pcard);
+	struct snd_card *card = (struct snd_card *) pnp_get_card_drvdata(pcard);
         
 	pnp_set_card_drvdata(pcard, NULL);
 	snd_card_disconnect(card);
@@ -1415,7 +1415,7 @@ static int __init sscape_manual_probe(struct params *params)
 {
 	int ret;
 	unsigned i;
-	snd_card_t *card;
+	struct snd_card *card;
 
 	for (i = 0; i < SNDRV_CARDS; ++i) {
 		/*

commit 8433a509c0eb6bb1f33ce39c82c580b8901619ee
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Mon Oct 24 15:02:37 2005 +0200

    [ALSA] Fix schedule_timeout usage
    
    Use schedule_timeout_{,un}interruptible() instead of
    set_current_state()/schedule_timeout() to reduce kernel size.  Also use
    human-time conversion functions instead of hard-coded division to avoid
    rounding issues.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 1036876146c4..11588067fa4f 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -342,19 +342,6 @@ static void soundscape_free(snd_card_t * c)
 	free_dma(sscape->chip->dma1);
 }
 
-/*
- * Put this process into an idle wait-state for a certain number
- * of "jiffies". The process can almost certainly be rescheduled
- * while we're waiting, and so we must NOT be holding any spinlocks
- * when we call this function. If we are then we risk DEADLOCK in
- * SMP (Ha!) or pre-emptible kernels.
- */
-static inline void sleep(long jiffs, int state)
-{
-	set_current_state(state);
-	schedule_timeout(jiffs);
-}
-
 /*
  * Tell the SoundScape to begin a DMA tranfer using the given channel.
  * All locking issues are left to the caller.
@@ -392,7 +379,7 @@ static int obp_startup_ack(struct soundscape *s, unsigned timeout)
 		unsigned long flags;
 		unsigned char x;
 
-		sleep(1, TASK_INTERRUPTIBLE);
+		schedule_timeout_interruptible(1);
 
 		spin_lock_irqsave(&s->lock, flags);
 		x = inb(HOST_DATA_IO(s->io_base));
@@ -419,7 +406,7 @@ static int host_startup_ack(struct soundscape *s, unsigned timeout)
 		unsigned long flags;
 		unsigned char x;
 
-		sleep(1, TASK_INTERRUPTIBLE);
+		schedule_timeout_interruptible(1);
 
 		spin_lock_irqsave(&s->lock, flags);
 		x = inb(HOST_DATA_IO(s->io_base));

commit b1d5776d865951c213a1caaab5d8bf5de7615dbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:56:31 2005 +0200

    [ALSA] Remove vmalloc wrapper, kfree_nocheck()
    
    - Remove vmalloc wrapper
    - Add release_and_free_resource() to remove kfree_nocheck() from each driver
      and simplify the code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 9f6b58c79209..1036876146c4 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -338,8 +338,7 @@ static inline void activate_ad1845_unsafe(unsigned io_base)
 static void soundscape_free(snd_card_t * c)
 {
 	register struct soundscape *sscape = get_card_soundscape(c);
-	release_resource(sscape->io_res);
-	kfree_nocheck(sscape->io_res);
+	release_and_free_resource(sscape->io_res);
 	free_dma(sscape->chip->dma1);
 }
 
@@ -1288,8 +1287,7 @@ static int __devinit create_sscape(const struct params *params, snd_card_t **rca
 	free_dma(params->dma1);
 
 	_release_region:
-	release_resource(io_res);
-	kfree_nocheck(io_res);
+	release_and_free_resource(io_res);
 
 	return err;
 }

commit 43bcd973d6d05d16b876e09dcc49a09d3e48e88d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Sep 5 17:19:20 2005 +0200

    [ALSA] Add snd_card_set_generic_dev() call to ISA drivers
    
    ISA,CMI8330 driver,ES18xx driver,OPL3SA2 driver,Sound Galaxy driver
    Sound Scape driver,AD1848 driver,CS4231 driver,CS4236+ driver
    ES1688 driver,GUS Classic driver,GUS Extreme driver,GUS MAX driver
    AMD InterWave driver,Opti9xx drivers,SB16/AWE driver,SB8 driver
    Wavefront drivers
    - Added snd_card_set_generic_dev() call.
    - Added SND_GENERIC_DRIVER to Kconfig.
    - Clean up the error path in probe if necessary.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
index 3959ed694eec..9f6b58c79209 100644
--- a/sound/isa/sscape.c
+++ b/sound/isa/sscape.c
@@ -1262,11 +1262,6 @@ static int __devinit create_sscape(const struct params *params, snd_card_t **rca
 	 */
 	sscape_write(sscape, GA_INTENA_REG, 0x80);
 
-	if ((err = snd_card_register(card)) < 0) {
-		printk(KERN_ERR "sscape: Failed to register sound card\n");
-		goto _release_card;
-	}
-
 	/*
 	 * Initialize mixer
 	 */
@@ -1396,6 +1391,13 @@ static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
 			if (ret < 0)
 				return ret;
 			snd_card_set_dev(card, &pcard->card->dev);
+
+			if ((ret = snd_card_register(card)) < 0) {
+				printk(KERN_ERR "sscape: Failed to register sound card\n");
+				snd_card_free(card);
+				return ret;
+			}
+
 			pnp_set_card_drvdata(pcard, card);
 			++sscape_cards;
 			++idx;
@@ -1460,6 +1462,16 @@ static int __init sscape_manual_probe(struct params *params)
 		if (ret < 0)
 			return ret;
 
+		if ((ret = snd_card_set_generic_dev(card)) < 0) {
+			snd_card_free(card);
+			return ret;
+		}
+		if ((ret = snd_card_register(card)) < 0) {
+			printk(KERN_ERR "sscape: Failed to register sound card\n");
+			snd_card_free(card);
+			return ret;
+		}
+
 		sscape_card[sscape_cards] = card;
 		params++;
 		sscape_cards++;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/isa/sscape.c b/sound/isa/sscape.c
new file mode 100644
index 000000000000..3959ed694eec
--- /dev/null
+++ b/sound/isa/sscape.c
@@ -0,0 +1,1517 @@
+/*
+ *   Low-level ALSA driver for the ENSONIQ SoundScape PnP
+ *   Copyright (c) by Chris Rankin
+ *
+ *   This driver was written in part using information obtained from
+ *   the OSS/Free SoundScape driver, written by Hannu Savolainen.
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pnp.h>
+#include <linux/spinlock.h>
+#include <linux/moduleparam.h>
+#include <asm/dma.h>
+#include <sound/core.h>
+#include <sound/hwdep.h>
+#include <sound/cs4231.h>
+#include <sound/mpu401.h>
+#include <sound/initval.h>
+
+#include <sound/sscape_ioctl.h>
+
+
+MODULE_AUTHOR("Chris Rankin");
+MODULE_DESCRIPTION("ENSONIQ SoundScape PnP driver");
+MODULE_LICENSE("GPL");
+
+static int index[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_IDX;
+static char* id[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_STR;
+static long port[SNDRV_CARDS] __devinitdata = { [0 ... (SNDRV_CARDS-1)] = SNDRV_AUTO_PORT };
+static int irq[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_IRQ;
+static int mpu_irq[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_IRQ;
+static int dma[SNDRV_CARDS] __devinitdata = SNDRV_DEFAULT_DMA;
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index number for SoundScape soundcard");
+
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "Description for SoundScape card");
+
+module_param_array(port, long, NULL, 0444);
+MODULE_PARM_DESC(port, "Port # for SoundScape driver.");
+
+module_param_array(irq, int, NULL, 0444);
+MODULE_PARM_DESC(irq, "IRQ # for SoundScape driver.");
+
+module_param_array(mpu_irq, int, NULL, 0444);
+MODULE_PARM_DESC(mpu_irq, "MPU401 IRQ # for SoundScape driver.");
+
+module_param_array(dma, int, NULL, 0444);
+MODULE_PARM_DESC(dma, "DMA # for SoundScape driver.");
+  
+#ifdef CONFIG_PNP
+static struct pnp_card_device_id sscape_pnpids[] = {
+	{ .id = "ENS3081", .devs = { { "ENS0000" } } },
+	{ .id = "" }	/* end */
+};
+
+MODULE_DEVICE_TABLE(pnp_card, sscape_pnpids);
+#endif
+
+static snd_card_t *sscape_card[SNDRV_CARDS];
+
+
+#define MPU401_IO(i)     ((i) + 0)
+#define MIDI_DATA_IO(i)  ((i) + 0)
+#define MIDI_CTRL_IO(i)  ((i) + 1)
+#define HOST_CTRL_IO(i)  ((i) + 2)
+#define HOST_DATA_IO(i)  ((i) + 3)
+#define ODIE_ADDR_IO(i)  ((i) + 4)
+#define ODIE_DATA_IO(i)  ((i) + 5)
+#define CODEC_IO(i)      ((i) + 8)
+
+#define IC_ODIE  1
+#define IC_OPUS  2
+
+#define RX_READY 0x01
+#define TX_READY 0x02
+
+#define CMD_ACK           0x80
+#define CMD_SET_MIDI_VOL  0x84
+#define CMD_GET_MIDI_VOL  0x85
+#define CMD_XXX_MIDI_VOL  0x86
+#define CMD_SET_EXTMIDI   0x8a
+#define CMD_GET_EXTMIDI   0x8b
+#define CMD_SET_MT32      0x8c
+#define CMD_GET_MT32      0x8d
+
+enum GA_REG {
+	GA_INTSTAT_REG = 0,
+	GA_INTENA_REG,
+	GA_DMAA_REG,
+	GA_DMAB_REG,
+	GA_INTCFG_REG,
+	GA_DMACFG_REG,
+	GA_CDCFG_REG,
+	GA_SMCFGA_REG,
+	GA_SMCFGB_REG,
+	GA_HMCTL_REG
+};
+
+#define DMA_8BIT  0x80
+
+
+#define AD1845_FREQ_SEL_MSB    0x16
+#define AD1845_FREQ_SEL_LSB    0x17
+
+struct soundscape {
+	spinlock_t lock;
+	unsigned io_base;
+	int codec_type;
+	int ic_type;
+	struct resource *io_res;
+	cs4231_t *chip;
+	mpu401_t *mpu;
+	snd_hwdep_t *hw;
+
+	/*
+	 * The MIDI device won't work until we've loaded
+	 * its firmware via a hardware-dependent device IOCTL
+	 */
+	spinlock_t fwlock;
+	int hw_in_use;
+	unsigned long midi_usage;
+	unsigned char midi_vol;
+};
+
+#define INVALID_IRQ  ((unsigned)-1)
+
+
+static inline struct soundscape *get_card_soundscape(snd_card_t * c)
+{
+	return (struct soundscape *) (c->private_data);
+}
+
+static inline struct soundscape *get_mpu401_soundscape(mpu401_t * mpu)
+{
+	return (struct soundscape *) (mpu->private_data);
+}
+
+static inline struct soundscape *get_hwdep_soundscape(snd_hwdep_t * hw)
+{
+	return (struct soundscape *) (hw->private_data);
+}
+
+
+/*
+ * Allocates some kernel memory that we can use for DMA.
+ * I think this means that the memory has to map to
+ * contiguous pages of physical memory.
+ */
+static struct snd_dma_buffer *get_dmabuf(struct snd_dma_buffer *buf, unsigned long size)
+{
+	if (buf) {
+		if (snd_dma_alloc_pages_fallback(SNDRV_DMA_TYPE_DEV, snd_dma_isa_data(),
+						 size, buf) < 0) {
+			snd_printk(KERN_ERR "sscape: Failed to allocate %lu bytes for DMA\n", size);
+			return NULL;
+		}
+	}
+
+	return buf;
+}
+
+/*
+ * Release the DMA-able kernel memory ...
+ */
+static void free_dmabuf(struct snd_dma_buffer *buf)
+{
+	if (buf && buf->area)
+		snd_dma_free_pages(buf);
+}
+
+
+/*
+ * This function writes to the SoundScape's control registers,
+ * but doesn't do any locking. It's up to the caller to do that.
+ * This is why this function is "unsafe" ...
+ */
+static inline void sscape_write_unsafe(unsigned io_base, enum GA_REG reg, unsigned char val)
+{
+	outb(reg, ODIE_ADDR_IO(io_base));
+	outb(val, ODIE_DATA_IO(io_base));
+}
+
+/*
+ * Write to the SoundScape's control registers, and do the
+ * necessary locking ...
+ */
+static void sscape_write(struct soundscape *s, enum GA_REG reg, unsigned char val)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&s->lock, flags);
+	sscape_write_unsafe(s->io_base, reg, val);
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+/*
+ * Read from the SoundScape's control registers, but leave any
+ * locking to the caller. This is why the function is "unsafe" ...
+ */
+static inline unsigned char sscape_read_unsafe(unsigned io_base, enum GA_REG reg)
+{
+	outb(reg, ODIE_ADDR_IO(io_base));
+	return inb(ODIE_DATA_IO(io_base));
+}
+
+/*
+ * Puts the SoundScape into "host" mode, as compared to "MIDI" mode
+ */
+static inline void set_host_mode_unsafe(unsigned io_base)
+{
+	outb(0x0, HOST_CTRL_IO(io_base));
+}
+
+/*
+ * Puts the SoundScape into "MIDI" mode, as compared to "host" mode
+ */
+static inline void set_midi_mode_unsafe(unsigned io_base)
+{
+	outb(0x3, HOST_CTRL_IO(io_base));
+}
+
+/*
+ * Read the SoundScape's host-mode control register, but leave
+ * any locking issues to the caller ...
+ */
+static inline int host_read_unsafe(unsigned io_base)
+{
+	int data = -1;
+	if ((inb(HOST_CTRL_IO(io_base)) & RX_READY) != 0) {
+		data = inb(HOST_DATA_IO(io_base));
+	}
+
+	return data;
+}
+
+/*
+ * Read the SoundScape's host-mode control register, performing
+ * a limited amount of busy-waiting if the register isn't ready.
+ * Also leaves all locking-issues to the caller ...
+ */
+static int host_read_ctrl_unsafe(unsigned io_base, unsigned timeout)
+{
+	int data;
+
+	while (((data = host_read_unsafe(io_base)) < 0) && (timeout != 0)) {
+		udelay(100);
+		--timeout;
+	} /* while */
+
+	return data;
+}
+
+/*
+ * Write to the SoundScape's host-mode control registers, but
+ * leave any locking issues to the caller ...
+ */
+static inline int host_write_unsafe(unsigned io_base, unsigned char data)
+{
+	if ((inb(HOST_CTRL_IO(io_base)) & TX_READY) != 0) {
+		outb(data, HOST_DATA_IO(io_base));
+		return 1;
+	}
+
+	return 0;
+}
+
+/*
+ * Write to the SoundScape's host-mode control registers, performing
+ * a limited amount of busy-waiting if the register isn't ready.
+ * Also leaves all locking-issues to the caller ...
+ */
+static int host_write_ctrl_unsafe(unsigned io_base, unsigned char data,
+                                  unsigned timeout)
+{
+	int err;
+
+	while (!(err = host_write_unsafe(io_base, data)) && (timeout != 0)) {
+		udelay(100);
+		--timeout;
+	} /* while */
+
+	return err;
+}
+
+
+/*
+ * Check that the MIDI subsystem is operational. If it isn't,
+ * then we will hang the computer if we try to use it ...
+ *
+ * NOTE: This check is based upon observation, not documentation.
+ */
+static inline int verify_mpu401(const mpu401_t * mpu)
+{
+	return ((inb(MIDI_CTRL_IO(mpu->port)) & 0xc0) == 0x80);
+}
+
+/*
+ * This is apparently the standard way to initailise an MPU-401
+ */
+static inline void initialise_mpu401(const mpu401_t * mpu)
+{
+	outb(0, MIDI_DATA_IO(mpu->port));
+}
+
+/*
+ * Tell the SoundScape to activate the AD1845 chip (I think).
+ * The AD1845 detection fails if we *don't* do this, so I
+ * think that this is a good idea ...
+ */
+static inline void activate_ad1845_unsafe(unsigned io_base)
+{
+	sscape_write_unsafe(io_base, GA_HMCTL_REG, (sscape_read_unsafe(io_base, GA_HMCTL_REG) & 0xcf) | 0x10);
+	sscape_write_unsafe(io_base, GA_CDCFG_REG, 0x80);
+}
+
+/*
+ * Do the necessary ALSA-level cleanup to deallocate our driver ...
+ */
+static void soundscape_free(snd_card_t * c)
+{
+	register struct soundscape *sscape = get_card_soundscape(c);
+	release_resource(sscape->io_res);
+	kfree_nocheck(sscape->io_res);
+	free_dma(sscape->chip->dma1);
+}
+
+/*
+ * Put this process into an idle wait-state for a certain number
+ * of "jiffies". The process can almost certainly be rescheduled
+ * while we're waiting, and so we must NOT be holding any spinlocks
+ * when we call this function. If we are then we risk DEADLOCK in
+ * SMP (Ha!) or pre-emptible kernels.
+ */
+static inline void sleep(long jiffs, int state)
+{
+	set_current_state(state);
+	schedule_timeout(jiffs);
+}
+
+/*
+ * Tell the SoundScape to begin a DMA tranfer using the given channel.
+ * All locking issues are left to the caller.
+ */
+static inline void sscape_start_dma_unsafe(unsigned io_base, enum GA_REG reg)
+{
+	sscape_write_unsafe(io_base, reg, sscape_read_unsafe(io_base, reg) | 0x01);
+	sscape_write_unsafe(io_base, reg, sscape_read_unsafe(io_base, reg) & 0xfe);
+}
+
+/*
+ * Wait for a DMA transfer to complete. This is a "limited busy-wait",
+ * and all locking issues are left to the caller.
+ */
+static int sscape_wait_dma_unsafe(unsigned io_base, enum GA_REG reg, unsigned timeout)
+{
+	while (!(sscape_read_unsafe(io_base, reg) & 0x01) && (timeout != 0)) {
+		udelay(100);
+		--timeout;
+	} /* while */
+
+	return (sscape_read_unsafe(io_base, reg) & 0x01);
+}
+
+/*
+ * Wait for the On-Board Processor to return its start-up
+ * acknowledgement sequence. This wait is too long for
+ * us to perform "busy-waiting", and so we must sleep.
+ * This in turn means that we must not be holding any
+ * spinlocks when we call this function.
+ */
+static int obp_startup_ack(struct soundscape *s, unsigned timeout)
+{
+	while (timeout != 0) {
+		unsigned long flags;
+		unsigned char x;
+
+		sleep(1, TASK_INTERRUPTIBLE);
+
+		spin_lock_irqsave(&s->lock, flags);
+		x = inb(HOST_DATA_IO(s->io_base));
+		spin_unlock_irqrestore(&s->lock, flags);
+		if ((x & 0xfe) == 0xfe)
+			return 1;
+
+		--timeout;
+	} /* while */
+
+	return 0;
+}
+
+/*
+ * Wait for the host to return its start-up acknowledgement
+ * sequence. This wait is too long for us to perform
+ * "busy-waiting", and so we must sleep. This in turn means
+ * that we must not be holding any spinlocks when we call
+ * this function.
+ */
+static int host_startup_ack(struct soundscape *s, unsigned timeout)
+{
+	while (timeout != 0) {
+		unsigned long flags;
+		unsigned char x;
+
+		sleep(1, TASK_INTERRUPTIBLE);
+
+		spin_lock_irqsave(&s->lock, flags);
+		x = inb(HOST_DATA_IO(s->io_base));
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (x == 0xfe)
+			return 1;
+
+		--timeout;
+	} /* while */
+
+	return 0;
+}
+
+/*
+ * Upload a byte-stream into the SoundScape using DMA channel A.
+ */
+static int upload_dma_data(struct soundscape *s,
+                           const unsigned char __user *data,
+                           size_t size)
+{
+	unsigned long flags;
+	struct snd_dma_buffer dma;
+	int ret;
+
+	if (!get_dmabuf(&dma, PAGE_ALIGN(size)))
+		return -ENOMEM;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	/*
+	 * Reset the board ...
+	 */
+	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, sscape_read_unsafe(s->io_base, GA_HMCTL_REG) & 0x3f);
+
+	/*
+	 * Enable the DMA channels and configure them ...
+	 */
+	sscape_write_unsafe(s->io_base, GA_DMACFG_REG, 0x50);
+	sscape_write_unsafe(s->io_base, GA_DMAA_REG, (s->chip->dma1 << 4) | DMA_8BIT);
+	sscape_write_unsafe(s->io_base, GA_DMAB_REG, 0x20);
+
+	/*
+	 * Take the board out of reset ...
+	 */
+	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, sscape_read_unsafe(s->io_base, GA_HMCTL_REG) | 0x80);
+
+	/*
+	 * Upload the user's data (firmware?) to the SoundScape
+	 * board through the DMA channel ...
+	 */
+	while (size != 0) {
+		unsigned long len;
+
+		/*
+		 * Apparently, copying to/from userspace can sleep.
+		 * We are therefore forbidden from holding any
+		 * spinlocks while we copy ...
+		 */
+		spin_unlock_irqrestore(&s->lock, flags);
+
+		/*
+		 * Remember that the data that we want to DMA
+		 * comes from USERSPACE. We have already verified
+		 * the userspace pointer ...
+		 */
+		len = min(size, dma.bytes);
+		len -= __copy_from_user(dma.area, data, len);
+		data += len;
+		size -= len;
+
+		/*
+		 * Grab that spinlock again, now that we've
+		 * finished copying!
+		 */
+		spin_lock_irqsave(&s->lock, flags);
+
+		snd_dma_program(s->chip->dma1, dma.addr, len, DMA_MODE_WRITE);
+		sscape_start_dma_unsafe(s->io_base, GA_DMAA_REG);
+		if (!sscape_wait_dma_unsafe(s->io_base, GA_DMAA_REG, 5000)) {
+			/*
+			 * Don't forget to release this spinlock we're holding ...
+			 */
+			spin_unlock_irqrestore(&s->lock, flags);
+
+			snd_printk(KERN_ERR "sscape: DMA upload has timed out\n");
+			ret = -EAGAIN;
+			goto _release_dma;
+		}
+	} /* while */
+
+	set_host_mode_unsafe(s->io_base);
+
+	/*
+	 * Boot the board ... (I think)
+	 */
+	sscape_write_unsafe(s->io_base, GA_HMCTL_REG, sscape_read_unsafe(s->io_base, GA_HMCTL_REG) | 0x40);
+	spin_unlock_irqrestore(&s->lock, flags);
+
+	/*
+	 * If all has gone well, then the board should acknowledge
+	 * the new upload and tell us that it has rebooted OK. We
+	 * give it 5 seconds (max) ...
+	 */
+	ret = 0;
+	if (!obp_startup_ack(s, 5)) {
+		snd_printk(KERN_ERR "sscape: No response from on-board processor after upload\n");
+		ret = -EAGAIN;
+	} else if (!host_startup_ack(s, 5)) {
+		snd_printk(KERN_ERR "sscape: SoundScape failed to initialise\n");
+		ret = -EAGAIN;
+	}
+
+	_release_dma:
+	/*
+	 * NOTE!!! We are NOT holding any spinlocks at this point !!!
+	 */
+	sscape_write(s, GA_DMAA_REG, (s->ic_type == IC_ODIE ? 0x70 : 0x40));
+	free_dmabuf(&dma);
+
+	return ret;
+}
+
+/*
+ * Upload the bootblock(?) into the SoundScape. The only
+ * purpose of this block of code seems to be to tell
+ * us which version of the microcode we should be using.
+ *
+ * NOTE: The boot-block data resides in USER-SPACE!!!
+ *       However, we have already verified its memory
+ *       addresses by the time we get here.
+ */
+static int sscape_upload_bootblock(struct soundscape *sscape, struct sscape_bootblock __user *bb)
+{
+	unsigned long flags;
+	int data = 0;
+	int ret;
+
+	ret = upload_dma_data(sscape, bb->code, sizeof(bb->code));
+
+	spin_lock_irqsave(&sscape->lock, flags);
+	if (ret == 0) {
+		data = host_read_ctrl_unsafe(sscape->io_base, 100);
+	}
+	set_midi_mode_unsafe(sscape->io_base);
+	spin_unlock_irqrestore(&sscape->lock, flags);
+
+	if (ret == 0) {
+		if (data < 0) {
+			snd_printk(KERN_ERR "sscape: timeout reading firmware version\n");
+			ret = -EAGAIN;
+		}
+		else if (__copy_to_user(&bb->version, &data, sizeof(bb->version))) {
+			ret = -EFAULT;
+		}
+	}
+
+	return ret;
+}
+
+/*
+ * Upload the microcode into the SoundScape. The
+ * microcode is 64K of data, and if we try to copy
+ * it into a local variable then we will SMASH THE
+ * KERNEL'S STACK! We therefore leave it in USER
+ * SPACE, and save ourselves from copying it at all.
+ */
+static int sscape_upload_microcode(struct soundscape *sscape,
+                                   const struct sscape_microcode __user *mc)
+{
+	unsigned long flags;
+	char __user *code;
+	int err;
+
+	/*
+	 * We are going to have to copy this data into a special
+	 * DMA-able buffer before we can upload it. We shall therefore
+	 * just check that the data pointer is valid for now.
+	 *
+	 * NOTE: This buffer is 64K long! That's WAY too big to
+	 *       copy into a stack-temporary anyway.
+	 */
+	if ( get_user(code, &mc->code) ||
+	     !access_ok(VERIFY_READ, code, SSCAPE_MICROCODE_SIZE) )
+		return -EFAULT;
+
+	if ((err = upload_dma_data(sscape, code, SSCAPE_MICROCODE_SIZE)) == 0) {
+		snd_printk(KERN_INFO "sscape: MIDI firmware loaded\n");
+	}
+
+	spin_lock_irqsave(&sscape->lock, flags);
+	set_midi_mode_unsafe(sscape->io_base);
+	spin_unlock_irqrestore(&sscape->lock, flags);
+
+	initialise_mpu401(sscape->mpu);
+
+	return err;
+}
+
+/*
+ * Hardware-specific device functions, to implement special
+ * IOCTLs for the SoundScape card. This is how we upload
+ * the microcode into the card, for example, and so we
+ * must ensure that no two processes can open this device
+ * simultaneously, and that we can't open it at all if
+ * someone is using the MIDI device.
+ */
+static int sscape_hw_open(snd_hwdep_t * hw, struct file *file)
+{
+	register struct soundscape *sscape = get_hwdep_soundscape(hw);
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&sscape->fwlock, flags);
+
+	if ((sscape->midi_usage != 0) || sscape->hw_in_use) {
+		err = -EBUSY;
+	} else {
+		sscape->hw_in_use = 1;
+		err = 0;
+	}
+
+	spin_unlock_irqrestore(&sscape->fwlock, flags);
+	return err;
+}
+
+static int sscape_hw_release(snd_hwdep_t * hw, struct file *file)
+{
+	register struct soundscape *sscape = get_hwdep_soundscape(hw);
+	unsigned long flags;
+
+	spin_lock_irqsave(&sscape->fwlock, flags);
+	sscape->hw_in_use = 0;
+	spin_unlock_irqrestore(&sscape->fwlock, flags);
+	return 0;
+}
+
+static int sscape_hw_ioctl(snd_hwdep_t * hw, struct file *file,
+                           unsigned int cmd, unsigned long arg)
+{
+	struct soundscape *sscape = get_hwdep_soundscape(hw);
+	int err = -EBUSY;
+
+	switch (cmd) {
+	case SND_SSCAPE_LOAD_BOOTB:
+		{
+			register struct sscape_bootblock __user *bb = (struct sscape_bootblock __user *) arg;
+
+			/*
+			 * We are going to have to copy this data into a special
+			 * DMA-able buffer before we can upload it. We shall therefore
+			 * just check that the data pointer is valid for now ...
+			 */
+			if ( !access_ok(VERIFY_READ, bb->code, sizeof(bb->code)) )
+				return -EFAULT;
+
+			/*
+			 * Now check that we can write the firmware version number too...
+			 */
+			if ( !access_ok(VERIFY_WRITE, &bb->version, sizeof(bb->version)) )
+				return -EFAULT;
+
+			err = sscape_upload_bootblock(sscape, bb);
+		}
+		break;
+
+	case SND_SSCAPE_LOAD_MCODE:
+		{
+			register const struct sscape_microcode __user *mc = (const struct sscape_microcode __user *) arg;
+
+			err = sscape_upload_microcode(sscape, mc);
+		}
+		break;
+
+	default:
+		err = -EINVAL;
+		break;
+	} /* switch */
+
+	return err;
+}
+
+
+/*
+ * Mixer control for the SoundScape's MIDI device.
+ */
+static int sscape_midi_info(snd_kcontrol_t * ctl,
+                            snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 127;
+	return 0;
+}
+
+static int sscape_midi_get(snd_kcontrol_t * kctl,
+                           snd_ctl_elem_value_t * uctl)
+{
+	cs4231_t *chip = snd_kcontrol_chip(kctl);
+	snd_card_t *card = chip->card;
+	register struct soundscape *s = get_card_soundscape(card);
+	unsigned long flags;
+
+	spin_lock_irqsave(&s->lock, flags);
+	set_host_mode_unsafe(s->io_base);
+
+	if (host_write_ctrl_unsafe(s->io_base, CMD_GET_MIDI_VOL, 100)) {
+		uctl->value.integer.value[0] = host_read_ctrl_unsafe(s->io_base, 100);
+	}
+
+	set_midi_mode_unsafe(s->io_base);
+	spin_unlock_irqrestore(&s->lock, flags);
+	return 0;
+}
+
+static int sscape_midi_put(snd_kcontrol_t * kctl,
+                           snd_ctl_elem_value_t * uctl)
+{
+	cs4231_t *chip = snd_kcontrol_chip(kctl);
+	snd_card_t *card = chip->card;
+	register struct soundscape *s = get_card_soundscape(card);
+	unsigned long flags;
+	int change;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	/*
+	 * We need to put the board into HOST mode before we
+	 * can send any volume-changing HOST commands ...
+	 */
+	set_host_mode_unsafe(s->io_base);
+
+	/*
+	 * To successfully change the MIDI volume setting, you seem to
+	 * have to write a volume command, write the new volume value,
+	 * and then perform another volume-related command. Perhaps the
+	 * first command is an "open" and the second command is a "close"?
+	 */
+	if (s->midi_vol == ((unsigned char) uctl->value.integer. value[0] & 127)) {
+		change = 0;
+		goto __skip_change;
+	}
+	change = (host_write_ctrl_unsafe(s->io_base, CMD_SET_MIDI_VOL, 100)
+	          && host_write_ctrl_unsafe(s->io_base, ((unsigned char) uctl->value.integer. value[0]) & 127, 100)
+	          && host_write_ctrl_unsafe(s->io_base, CMD_XXX_MIDI_VOL, 100));
+      __skip_change:
+
+	/*
+	 * Take the board out of HOST mode and back into MIDI mode ...
+	 */
+	set_midi_mode_unsafe(s->io_base);
+
+	spin_unlock_irqrestore(&s->lock, flags);
+	return change;
+}
+
+static snd_kcontrol_new_t midi_mixer_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "MIDI",
+	.info = sscape_midi_info,
+	.get = sscape_midi_get,
+	.put = sscape_midi_put
+};
+
+/*
+ * The SoundScape can use two IRQs from a possible set of four.
+ * These IRQs are encoded as bit patterns so that they can be
+ * written to the control registers.
+ */
+static unsigned __devinit get_irq_config(int irq)
+{
+	static const int valid_irq[] = { 9, 5, 7, 10 };
+	unsigned cfg;
+
+	for (cfg = 0; cfg < ARRAY_SIZE(valid_irq); ++cfg) {
+		if (irq == valid_irq[cfg])
+			return cfg;
+	} /* for */
+
+	return INVALID_IRQ;
+}
+
+
+/*
+ * Perform certain arcane port-checks to see whether there
+ * is a SoundScape board lurking behind the given ports.
+ */
+static int __devinit detect_sscape(struct soundscape *s)
+{
+	unsigned long flags;
+	unsigned d;
+	int retval = 0;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	/*
+	 * The following code is lifted from the original OSS driver,
+	 * and as I don't have a datasheet I cannot really comment
+	 * on what it is doing...
+	 */
+	if ((inb(HOST_CTRL_IO(s->io_base)) & 0x78) != 0)
+		goto _done;
+
+	d = inb(ODIE_ADDR_IO(s->io_base)) & 0xf0;
+	if ((d & 0x80) != 0)
+		goto _done;
+
+	if (d == 0) {
+		s->codec_type = 1;
+		s->ic_type = IC_ODIE;
+	} else if ((d & 0x60) != 0) {
+		s->codec_type = 2;
+		s->ic_type = IC_OPUS;
+	} else
+		goto _done;
+
+	outb(0xfa, ODIE_ADDR_IO(s->io_base));
+	if ((inb(ODIE_ADDR_IO(s->io_base)) & 0x9f) != 0x0a)
+		goto _done;
+
+	outb(0xfe, ODIE_ADDR_IO(s->io_base));
+	if ((inb(ODIE_ADDR_IO(s->io_base)) & 0x9f) != 0x0e)
+		goto _done;
+	if ((inb(ODIE_DATA_IO(s->io_base)) & 0x9f) != 0x0e)
+		goto _done;
+
+	/*
+	 * SoundScape successfully detected!
+	 */
+	retval = 1;
+
+	_done:
+	spin_unlock_irqrestore(&s->lock, flags);
+	return retval;
+}
+
+/*
+ * ALSA callback function, called when attempting to open the MIDI device.
+ * Check that the MIDI firmware has been loaded, because we don't want
+ * to crash the machine. Also check that someone isn't using the hardware
+ * IOCTL device.
+ */
+static int mpu401_open(mpu401_t * mpu)
+{
+	int err;
+
+	if (!verify_mpu401(mpu)) {
+		snd_printk(KERN_ERR "sscape: MIDI disabled, please load firmware\n");
+		err = -ENODEV;
+	} else {
+		register struct soundscape *sscape = get_mpu401_soundscape(mpu);
+		unsigned long flags;
+
+		spin_lock_irqsave(&sscape->fwlock, flags);
+
+		if (sscape->hw_in_use || (sscape->midi_usage == ULONG_MAX)) {
+			err = -EBUSY;
+		} else {
+			++(sscape->midi_usage);
+			err = 0;
+		}
+
+		spin_unlock_irqrestore(&sscape->fwlock, flags);
+	}
+
+	return err;
+}
+
+static void mpu401_close(mpu401_t * mpu)
+{
+	register struct soundscape *sscape = get_mpu401_soundscape(mpu);
+	unsigned long flags;
+
+	spin_lock_irqsave(&sscape->fwlock, flags);
+	--(sscape->midi_usage);
+	spin_unlock_irqrestore(&sscape->fwlock, flags);
+}
+
+/*
+ * Initialse an MPU-401 subdevice for MIDI support on the SoundScape.
+ */
+static int __devinit create_mpu401(snd_card_t * card, int devnum, unsigned long port, int irq)
+{
+	struct soundscape *sscape = get_card_soundscape(card);
+	snd_rawmidi_t *rawmidi;
+	int err;
+
+#define MPU401_SHARE_HARDWARE  1
+	if ((err = snd_mpu401_uart_new(card, devnum,
+	                               MPU401_HW_MPU401,
+	                               port, MPU401_SHARE_HARDWARE,
+	                               irq, SA_INTERRUPT,
+	                               &rawmidi)) == 0) {
+		mpu401_t *mpu = (mpu401_t *) rawmidi->private_data;
+		mpu->open_input = mpu401_open;
+		mpu->open_output = mpu401_open;
+		mpu->close_input = mpu401_close;
+		mpu->close_output = mpu401_close;
+		mpu->private_data = sscape;
+		sscape->mpu = mpu;
+
+		initialise_mpu401(mpu);
+	}
+
+	return err;
+}
+
+
+/*
+ * Override for the CS4231 playback format function.
+ * The AD1845 has much simpler format and rate selection.
+ */
+static void ad1845_playback_format(cs4231_t * chip, snd_pcm_hw_params_t * params, unsigned char format)
+{
+	unsigned long flags;
+	unsigned rate = params_rate(params);
+
+	/*
+	 * The AD1845 can't handle sample frequencies
+	 * outside of 4 kHZ to 50 kHZ
+	 */
+	if (rate > 50000)
+		rate = 50000;
+	else if (rate < 4000)
+		rate = 4000;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+
+	/*
+	 * Program the AD1845 correctly for the playback stream.
+	 * Note that we do NOT need to toggle the MCE bit because
+	 * the PLAYBACK_ENABLE bit of the Interface Configuration
+	 * register is set.
+	 * 
+	 * NOTE: We seem to need to write to the MSB before the LSB
+	 *       to get the correct sample frequency.
+	 */
+	snd_cs4231_out(chip, CS4231_PLAYBK_FORMAT, (format & 0xf0));
+	snd_cs4231_out(chip, AD1845_FREQ_SEL_MSB, (unsigned char) (rate >> 8));
+	snd_cs4231_out(chip, AD1845_FREQ_SEL_LSB, (unsigned char) rate);
+
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+}
+
+/*
+ * Override for the CS4231 capture format function. 
+ * The AD1845 has much simpler format and rate selection.
+ */
+static void ad1845_capture_format(cs4231_t * chip, snd_pcm_hw_params_t * params, unsigned char format)
+{
+	unsigned long flags;
+	unsigned rate = params_rate(params);
+
+	/*
+	 * The AD1845 can't handle sample frequencies 
+	 * outside of 4 kHZ to 50 kHZ
+	 */
+	if (rate > 50000)
+		rate = 50000;
+	else if (rate < 4000)
+		rate = 4000;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+
+	/*
+	 * Program the AD1845 correctly for the playback stream.
+	 * Note that we do NOT need to toggle the MCE bit because
+	 * the CAPTURE_ENABLE bit of the Interface Configuration
+	 * register is set.
+	 *
+	 * NOTE: We seem to need to write to the MSB before the LSB
+	 *       to get the correct sample frequency.
+	 */
+	snd_cs4231_out(chip, CS4231_REC_FORMAT, (format & 0xf0));
+	snd_cs4231_out(chip, AD1845_FREQ_SEL_MSB, (unsigned char) (rate >> 8));
+	snd_cs4231_out(chip, AD1845_FREQ_SEL_LSB, (unsigned char) rate);
+
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+}
+
+/*
+ * Create an AD1845 PCM subdevice on the SoundScape. The AD1845
+ * is very much like a CS4231, with a few extra bits. We will
+ * try to support at least some of the extra bits by overriding
+ * some of the CS4231 callback.
+ */
+static int __devinit create_ad1845(snd_card_t * card, unsigned port, int irq, int dma1)
+{
+	register struct soundscape *sscape = get_card_soundscape(card);
+	cs4231_t *chip;
+	int err;
+
+#define CS4231_SHARE_HARDWARE  (CS4231_HWSHARE_DMA1 | CS4231_HWSHARE_DMA2)
+	/*
+	 * The AD1845 PCM device is only half-duplex, and so
+	 * we only give it one DMA channel ...
+	 */
+	if ((err = snd_cs4231_create(card,
+				     port, -1, irq, dma1, dma1,
+				     CS4231_HW_DETECT,
+				     CS4231_HWSHARE_DMA1, &chip)) == 0) {
+		unsigned long flags;
+		snd_pcm_t *pcm;
+
+#define AD1845_FREQ_SEL_ENABLE  0x08
+
+#define AD1845_PWR_DOWN_CTRL   0x1b
+#define AD1845_CRYS_CLOCK_SEL  0x1d
+
+/*
+ * It turns out that the PLAYBACK_ENABLE bit is set
+ * by the lowlevel driver ...
+ *
+#define AD1845_IFACE_CONFIG  \
+           (CS4231_AUTOCALIB | CS4231_RECORD_ENABLE | CS4231_PLAYBACK_ENABLE)
+    snd_cs4231_mce_up(chip);
+    spin_lock_irqsave(&chip->reg_lock, flags);
+    snd_cs4231_out(chip, CS4231_IFACE_CTRL, AD1845_IFACE_CONFIG);
+    spin_unlock_irqrestore(&chip->reg_lock, flags);
+    snd_cs4231_mce_down(chip);
+ */
+
+		/*
+		 * The input clock frequency on the SoundScape must
+		 * be 14.31818 MHz, because we must set this register
+		 * to get the playback to sound correct ...
+		 */
+		snd_cs4231_mce_up(chip);
+		spin_lock_irqsave(&chip->reg_lock, flags);
+		snd_cs4231_out(chip, AD1845_CRYS_CLOCK_SEL, 0x20);
+		spin_unlock_irqrestore(&chip->reg_lock, flags);
+		snd_cs4231_mce_down(chip);
+
+		/*
+		 * More custom configuration:
+		 * a) select "mode 2", and provide a current drive of 8 mA
+		 * b) enable frequency selection (for capture/playback)
+		 */
+		spin_lock_irqsave(&chip->reg_lock, flags);
+		snd_cs4231_out(chip, CS4231_MISC_INFO, (CS4231_MODE2 | 0x10));
+		snd_cs4231_out(chip, AD1845_PWR_DOWN_CTRL, snd_cs4231_in(chip, AD1845_PWR_DOWN_CTRL) | AD1845_FREQ_SEL_ENABLE);
+		spin_unlock_irqrestore(&chip->reg_lock, flags);
+
+		if ((err = snd_cs4231_pcm(chip, 0, &pcm)) < 0) {
+			snd_printk(KERN_ERR "sscape: No PCM device for AD1845 chip\n");
+			goto _error;
+		}
+
+		if ((err = snd_cs4231_mixer(chip)) < 0) {
+			snd_printk(KERN_ERR "sscape: No mixer device for AD1845 chip\n");
+			goto _error;
+		}
+
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&midi_mixer_ctl, chip))) < 0) {
+			snd_printk(KERN_ERR "sscape: Could not create MIDI mixer control\n");
+			goto _error;
+		}
+
+		strcpy(card->driver, "SoundScape");
+		strcpy(card->shortname, pcm->name);
+		snprintf(card->longname, sizeof(card->longname),
+		         "%s at 0x%lx, IRQ %d, DMA %d\n",
+		         pcm->name, chip->port, chip->irq, chip->dma1);
+		chip->set_playback_format = ad1845_playback_format;
+		chip->set_capture_format = ad1845_capture_format;
+		sscape->chip = chip;
+	}
+
+	_error:
+	return err;
+}
+
+
+struct params
+{
+	int index;
+	const char *id;
+	unsigned port;
+	int irq;
+	int mpu_irq;
+	int dma1;
+};
+
+
+static inline struct params*
+init_params(struct params *params,
+            int index,
+            const char *id,
+            unsigned port,
+            int irq,
+            int mpu_irq,
+            int dma1)
+{
+	params->index = index;
+	params->id = id;
+	params->port = port;
+	params->irq = irq;
+	params->mpu_irq = mpu_irq;  
+	params->dma1 = (dma1 & 0x03);
+
+	return params;
+}
+
+
+/*
+ * Create an ALSA soundcard entry for the SoundScape, using
+ * the given list of port, IRQ and DMA resources.
+ */
+static int __devinit create_sscape(const struct params *params, snd_card_t **rcardp)
+{
+	snd_card_t *card;
+	register struct soundscape *sscape;
+	register unsigned dma_cfg;
+	unsigned irq_cfg;
+	unsigned mpu_irq_cfg;
+	struct resource *io_res;
+	unsigned long flags;
+	int err;
+
+	/*
+	 * Check that the user didn't pass us garbage data ...
+	 */
+	irq_cfg = get_irq_config(params->irq);
+	if (irq_cfg == INVALID_IRQ) {
+		snd_printk(KERN_ERR "sscape: Invalid IRQ %d\n", params->irq);
+		return -ENXIO;
+	}
+
+	mpu_irq_cfg = get_irq_config(params->mpu_irq);
+	if (mpu_irq_cfg == INVALID_IRQ) {
+		printk(KERN_ERR "sscape: Invalid IRQ %d\n", params->mpu_irq);
+		return -ENXIO;
+	}
+
+	/*
+	 * Grab IO ports that we will need to probe so that we
+	 * can detect and control this hardware ...
+	 */
+	if ((io_res = request_region(params->port, 8, "SoundScape")) == NULL) {
+		snd_printk(KERN_ERR "sscape: can't grab port 0x%x\n", params->port);
+		return -EBUSY;
+	}
+
+	/*
+	 * Grab both DMA channels (OK, only one for now) ...
+	 */
+	if ((err = request_dma(params->dma1, "SoundScape")) < 0) {
+		snd_printk(KERN_ERR "sscape: can't grab DMA %d\n", params->dma1);
+		goto _release_region;
+	}
+
+	/*
+	 * Create a new ALSA sound card entry, in anticipation
+	 * of detecting our hardware ...
+	 */
+	if ((card = snd_card_new(params->index, params->id, THIS_MODULE, sizeof(struct soundscape))) == NULL) {
+		err = -ENOMEM;
+		goto _release_dma;
+	}
+
+	sscape = get_card_soundscape(card);
+	spin_lock_init(&sscape->lock);
+	spin_lock_init(&sscape->fwlock);
+	sscape->io_res = io_res;
+	sscape->io_base = params->port;
+
+	if (!detect_sscape(sscape)) {
+		printk(KERN_ERR "sscape: hardware not detected at 0x%x\n", sscape->io_base);
+		err = -ENODEV;
+		goto _release_card;
+	}
+
+	printk(KERN_INFO "sscape: hardware detected at 0x%x, using IRQ %d, DMA %d\n",
+	                 sscape->io_base, params->irq, params->dma1);
+
+	/*
+	 * Now create the hardware-specific device so that we can
+	 * load the microcode into the on-board processor.
+	 * We cannot use the MPU-401 MIDI system until this firmware
+	 * has been loaded into the card.
+	 */
+	if ((err = snd_hwdep_new(card, "MC68EC000", 0, &(sscape->hw))) < 0) {
+		printk(KERN_ERR "sscape: Failed to create firmware device\n");
+		goto _release_card;
+	}
+	strlcpy(sscape->hw->name, "SoundScape M68K", sizeof(sscape->hw->name));
+	sscape->hw->name[sizeof(sscape->hw->name) - 1] = '\0';
+	sscape->hw->iface = SNDRV_HWDEP_IFACE_SSCAPE;
+	sscape->hw->ops.open = sscape_hw_open;
+	sscape->hw->ops.release = sscape_hw_release;
+	sscape->hw->ops.ioctl = sscape_hw_ioctl;
+	sscape->hw->private_data = sscape;
+
+	/*
+	 * Tell the on-board devices where their resources are (I think -
+	 * I can't be sure without a datasheet ... So many magic values!)
+	 */
+	spin_lock_irqsave(&sscape->lock, flags);
+
+	activate_ad1845_unsafe(sscape->io_base);
+
+	sscape_write_unsafe(sscape->io_base, GA_INTENA_REG, 0x00); /* disable */
+	sscape_write_unsafe(sscape->io_base, GA_SMCFGA_REG, 0x2e);
+	sscape_write_unsafe(sscape->io_base, GA_SMCFGB_REG, 0x00);
+
+	/*
+	 * Enable and configure the DMA channels ...
+	 */
+	sscape_write_unsafe(sscape->io_base, GA_DMACFG_REG, 0x50);
+	dma_cfg = (sscape->ic_type == IC_ODIE ? 0x70 : 0x40);
+	sscape_write_unsafe(sscape->io_base, GA_DMAA_REG, dma_cfg);
+	sscape_write_unsafe(sscape->io_base, GA_DMAB_REG, 0x20);
+
+	sscape_write_unsafe(sscape->io_base,
+	                    GA_INTCFG_REG, 0xf0 | (mpu_irq_cfg << 2) | mpu_irq_cfg);
+	sscape_write_unsafe(sscape->io_base,
+	                    GA_CDCFG_REG, 0x09 | DMA_8BIT | (params->dma1 << 4) | (irq_cfg << 1));
+
+	spin_unlock_irqrestore(&sscape->lock, flags);
+
+	/*
+	 * We have now enabled the codec chip, and so we should
+	 * detect the AD1845 device ...
+	 */
+	if ((err = create_ad1845(card, CODEC_IO(params->port), params->irq, params->dma1)) < 0) {
+		printk(KERN_ERR "sscape: No AD1845 device at 0x%x, IRQ %d\n",
+		                CODEC_IO(params->port), params->irq);
+		goto _release_card;
+	}
+#define MIDI_DEVNUM  0
+	if ((err = create_mpu401(card, MIDI_DEVNUM, MPU401_IO(params->port), params->mpu_irq)) < 0) {
+		printk(KERN_ERR "sscape: Failed to create MPU-401 device at 0x%x\n",
+		                MPU401_IO(params->port));
+		goto _release_card;
+	}
+
+	/*
+	 * Enable the master IRQ ...
+	 */
+	sscape_write(sscape, GA_INTENA_REG, 0x80);
+
+	if ((err = snd_card_register(card)) < 0) {
+		printk(KERN_ERR "sscape: Failed to register sound card\n");
+		goto _release_card;
+	}
+
+	/*
+	 * Initialize mixer
+	 */
+	sscape->midi_vol = 0;
+	host_write_ctrl_unsafe(sscape->io_base, CMD_SET_MIDI_VOL, 100);
+	host_write_ctrl_unsafe(sscape->io_base, 0, 100);
+	host_write_ctrl_unsafe(sscape->io_base, CMD_XXX_MIDI_VOL, 100);
+
+	/*
+	 * Now that we have successfully created this sound card,
+	 * it is safe to store the pointer.
+	 * NOTE: we only register the sound card's "destructor"
+	 *       function now that our "constructor" has completed.
+	 */
+	card->private_free = soundscape_free;
+	*rcardp = card;
+
+	return 0;
+
+	_release_card:
+	snd_card_free(card);
+
+	_release_dma:
+	free_dma(params->dma1);
+
+	_release_region:
+	release_resource(io_res);
+	kfree_nocheck(io_res);
+
+	return err;
+}
+
+
+static int sscape_cards __devinitdata;
+static struct params sscape_params[SNDRV_CARDS] __devinitdata;
+
+#ifdef CONFIG_PNP
+static inline int __devinit get_next_autoindex(int i)
+{
+	while ((i < SNDRV_CARDS) && (port[i] != SNDRV_AUTO_PORT)) {
+		++i;
+	} /* while */
+
+	return i;
+}
+
+
+static inline int __devinit is_port_known(unsigned io, struct params *params, int cards)
+{
+	while (--cards >= 0) {
+		if (params[cards].port == io)
+			return 1;
+	} /* while */
+
+	return 0;
+}
+
+static int __devinit sscape_pnp_detect(struct pnp_card_link *pcard,
+				       const struct pnp_card_device_id *pid)
+{
+	struct pnp_dev *dev;
+	static int idx = 0;
+	int ret;
+
+	/*
+	 * Allow this function to fail *quietly* if all the ISA PnP
+	 * devices were configured using module parameters instead.
+	 */
+	if ((idx = get_next_autoindex(idx)) >= SNDRV_CARDS) {
+		return -ENOSPC;
+	}
+
+	/*
+	 * We have found a candidate ISA PnP card. Now we
+	 * have to check that it has the devices that we
+	 * expect it to have.
+	 *
+	 * We will NOT try and autoconfigure all of the resources
+	 * needed and then activate the card as we are assuming that
+	 * has already been done at boot-time using /proc/isapnp.
+	 * We shall simply try to give each active card the resources
+	 * that it wants. This is a sensible strategy for a modular
+	 * system where unused modules are unloaded regularly.
+	 *
+	 * This strategy is utterly useless if we compile the driver
+	 * into the kernel, of course.
+	 */
+	// printk(KERN_INFO "sscape: %s\n", card->name);
+
+	/*
+	 * Check that we still have room for another sound card ...
+	 */
+	if (sscape_cards >= SNDRV_CARDS) {
+		printk(KERN_ERR "sscape: No room for another ALSA device\n");
+		return -ENOSPC;
+	}
+
+	ret = -ENODEV;
+
+	dev = pnp_request_card_device(pcard, pid->devs[0].id, NULL);
+	if (dev) {
+		struct params *this;
+		if (!pnp_is_active(dev)) {
+			if (pnp_activate_dev(dev) < 0) {
+				printk(KERN_INFO "sscape: device is inactive\n");
+				return -EBUSY;
+			}
+		}
+		/*
+		 * Read the correct parameters off the ISA PnP bus ...
+		 */
+		this = init_params(&sscape_params[sscape_cards],
+				   index[idx],
+				   id[idx],
+				   pnp_port_start(dev, 0),
+				   pnp_irq(dev, 0),
+				   pnp_irq(dev, 1),
+				   pnp_dma(dev, 0));
+
+		/*
+		 * Do we know about this sound card already?
+		 */
+		if ( !is_port_known(this->port, sscape_params, sscape_cards) ) {
+			snd_card_t *card;
+
+			ret = create_sscape(this, &card);
+			if (ret < 0)
+				return ret;
+			snd_card_set_dev(card, &pcard->card->dev);
+			pnp_set_card_drvdata(pcard, card);
+			++sscape_cards;
+			++idx;
+		}
+	}
+
+	return ret;
+}
+
+static void __devexit sscape_pnp_remove(struct pnp_card_link * pcard)
+{
+	snd_card_t *card = (snd_card_t *) pnp_get_card_drvdata(pcard);
+        
+	pnp_set_card_drvdata(pcard, NULL);
+	snd_card_disconnect(card);
+	snd_card_free_in_thread(card);
+}
+
+static struct pnp_card_driver sscape_pnpc_driver = {
+	.flags = PNP_DRIVER_RES_DO_NOT_CHANGE,
+	.name = "sscape",
+	.id_table = sscape_pnpids,
+	.probe = sscape_pnp_detect,
+	.remove = __devexit_p(sscape_pnp_remove),
+};
+
+#endif /* CONFIG_PNP */
+
+static int __init sscape_manual_probe(struct params *params)
+{
+	int ret;
+	unsigned i;
+	snd_card_t *card;
+
+	for (i = 0; i < SNDRV_CARDS; ++i) {
+		/*
+		 * We do NOT probe for ports.
+		 * If we're not given a port number for this
+		 * card then we completely ignore this line
+		 * of parameters.
+		 */
+		if (port[i] == SNDRV_AUTO_PORT)
+			continue;
+
+		/*
+		 * Make sure we were given ALL of the other parameters.
+		 */
+		if ( (irq[i] == SNDRV_AUTO_IRQ) ||
+		     (mpu_irq[i] == SNDRV_AUTO_IRQ) ||
+		     (dma[i] == SNDRV_AUTO_DMA) ) {
+			printk(KERN_INFO
+			       "sscape: insufficient parameters, need IO, IRQ, MPU-IRQ and DMA\n");
+			return -ENXIO;
+		}
+
+		/*
+		 * This cards looks OK ...
+		 */
+		init_params(params, index[i], id[i], port[i], irq[i], mpu_irq[i], dma[i]);
+
+		ret = create_sscape(params, &card);
+		if (ret < 0)
+			return ret;
+
+		sscape_card[sscape_cards] = card;
+		params++;
+		sscape_cards++;
+	} /* for */
+
+	return 0;
+}
+
+
+static void sscape_exit(void)
+{
+	unsigned i;
+
+#ifdef CONFIG_PNP
+	pnp_unregister_card_driver(&sscape_pnpc_driver);
+#endif
+	for (i = 0; i < ARRAY_SIZE(sscape_card); ++i) {
+		snd_card_free(sscape_card[i]);
+	} /* for */
+}
+
+
+static int __init sscape_init(void)
+{
+	int ret;
+
+	/*
+	 * First check whether we were passed any parameters.
+	 * These MUST take precedence over ANY automatic way
+	 * of allocating cards, because the operator is
+	 * S-P-E-L-L-I-N-G it out for us...
+	 */
+	ret = sscape_manual_probe(sscape_params);
+	if (ret < 0) {
+		int i;
+		for (i = 0; i < sscape_cards; ++i)
+			snd_card_free(sscape_card[i]);
+		return ret;
+	}
+
+#ifdef CONFIG_PNP
+	if (sscape_cards < SNDRV_CARDS) {
+		ret = pnp_register_card_driver(&sscape_pnpc_driver);
+		if (ret < 0) {
+			sscape_exit();
+			return ret;
+		}
+	}
+#endif
+
+	return 0;
+}
+
+module_init(sscape_init);
+module_exit(sscape_exit);
