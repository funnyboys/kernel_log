commit f0bd62b64016508938df9babe47f65c2c727d25c
Author: Alexander Tsoy <alexander@tsoy.me>
Date:   Fri Apr 24 05:24:48 2020 +0300

    ALSA: usb-audio: Improve frames size computation
    
    For computation of the the next frame size current value of fs/fps and
    accumulated fractional parts of fs/fps are used, where values are stored
    in Q16.16 format. This is quite natural for computing frame size for
    asynchronous endpoints driven by explicit feedback, since in this case
    fs/fps is a value provided by the feedback endpoint and it's already in
    the Q format. If an error is accumulated over time, the device can
    adjust fs/fps value to prevent buffer overruns/underruns.
    
    But for synchronous endpoints the accuracy provided by these computations
    is not enough. Due to accumulated error the driver periodically produces
    frames with incorrect size (+/- 1 audio sample).
    
    This patch fixes this issue by implementing a different algorithm for
    frame size computation. It is based on accumulating of the remainders
    from division fs/fps and it doesn't accumulate errors over time. This
    new method is enabled for synchronous and adaptive playback endpoints.
    
    Signed-off-by: Alexander Tsoy <alexander@tsoy.me>
    Link: https://lore.kernel.org/r/20200424022449.14972-1-alexander@tsoy.me
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index 63a39d4fa8d8..d23fa0a8c11b 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -28,6 +28,7 @@ void snd_usb_endpoint_release(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_free(struct snd_usb_endpoint *ep);
 
 int snd_usb_endpoint_implicit_feedback_sink(struct snd_usb_endpoint *ep);
+int snd_usb_endpoint_slave_next_packet_size(struct snd_usb_endpoint *ep);
 int snd_usb_endpoint_next_packet_size(struct snd_usb_endpoint *ep);
 
 void snd_usb_handle_sync_urb(struct snd_usb_endpoint *ep,

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index 584f295d7c77..63a39d4fa8d8 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __USBAUDIO_ENDPOINT_H
 #define __USBAUDIO_ENDPOINT_H
 

commit 1d0f953086f090a022f2c0e1448300c15372db46
Author: Ioan-Adrian Ratiu <adi@adirat.com>
Date:   Thu Jan 5 00:37:46 2017 +0200

    ALSA: usb-audio: Fix irq/process data synchronization
    
    Commit 16200948d83 ("ALSA: usb-audio: Fix race at stopping the stream") was
    incomplete causing another more severe kernel panic, so it got reverted.
    This fixes both the original problem and its fallout kernel race/crash.
    
    The original fix is to move the endpoint member NULL clearing logic inside
    wait_clear_urbs() so the irq triggering the urb completion doesn't call
    retire_capture/playback_urb() after the NULL clearing and generate a panic.
    
    However this creates a new race between snd_usb_endpoint_start()'s call
    to wait_clear_urbs() and the irq urb completion handler which again calls
    retire_capture/playback_urb() leading to a new NULL dereference.
    
    We keep the EP deactivation code in snd_usb_endpoint_start() because
    removing it will break the EP reference counting (see [1] [2] for info),
    however we don't need the "can_sleep" mechanism anymore because a new
    function was introduced (snd_usb_endpoint_sync_pending_stop()) which
    synchronizes pending stops and gets called inside the pcm prepare callback.
    
    It also makes sense to remove can_sleep because it was also removed from
    deactivate_urbs() signature in [3] so we benefit from more simplification.
    
    [1] commit 015618b90 ("ALSA: snd-usb: Fix URB cancellation at stream start")
    [2] commit e9ba389c5 ("ALSA: usb-audio: Fix scheduling-while-atomic bug in PCM capture stream")
    [3] commit ccc1696d5 ("ALSA: usb-audio: simplify endpoint deactivation code")
    
    Fixes: f8114f8583bb ("Revert "ALSA: usb-audio: Fix race at stopping the stream"")
    
    Signed-off-by: Ioan-Adrian Ratiu <adi@adirat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index 6428392d8f62..584f295d7c77 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -18,7 +18,7 @@ int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
 				struct audioformat *fmt,
 				struct snd_usb_endpoint *sync_ep);
 
-int  snd_usb_endpoint_start(struct snd_usb_endpoint *ep, bool can_sleep);
+int  snd_usb_endpoint_start(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_stop(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_sync_pending_stop(struct snd_usb_endpoint *ep);
 int  snd_usb_endpoint_activate(struct snd_usb_endpoint *ep);

commit a6cece9d81990e729c1f9da2a5bff2d29f7df649
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Oct 31 11:24:32 2014 +0100

    ALSA: usb-audio: Pass direct struct pointer instead of list_head
    
    Some functions in mixer.c and endpoint.c receive list_head instead of
    the object itself.  This is not obvious and rather error-prone.  Let's
    pass the proper object directly instead.
    
    The functions in midi.c still receive list_head and this can't be
    changed since the object definition isn't exposed to the outside of
    midi.c, so left as is.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index e61ee5c356a3..6428392d8f62 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -24,7 +24,7 @@ void snd_usb_endpoint_sync_pending_stop(struct snd_usb_endpoint *ep);
 int  snd_usb_endpoint_activate(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_deactivate(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_release(struct snd_usb_endpoint *ep);
-void snd_usb_endpoint_free(struct list_head *head);
+void snd_usb_endpoint_free(struct snd_usb_endpoint *ep);
 
 int snd_usb_endpoint_implicit_feedback_sink(struct snd_usb_endpoint *ep);
 int snd_usb_endpoint_next_packet_size(struct snd_usb_endpoint *ep);

commit 92a586bdc06de6629dae1b357dac221253f55ff8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 25 14:24:47 2014 +0200

    ALSA: usb-audio: Fix races at disconnection and PCM closing
    
    When a USB-audio device is disconnected while PCM is still running, we
    still see some race: the disconnect callback calls
    snd_usb_endpoint_free() that calls release_urbs() and then kfree()
    while a PCM stream would be closed at the same time and calls
    stop_endpoints() that leads to wait_clear_urbs().  That is, the EP
    object might be deallocated while a PCM stream is syncing with
    wait_clear_urbs() with the same EP.
    
    Basically calling multiple wait_clear_urbs() would work fine, also
    calling wait_clear_urbs() and release_urbs() would work, too, as
    wait_clear_urbs() just reads some fields in ep.  The problem is the
    succeeding kfree() in snd_pcm_endpoint_free().
    
    This patch moves out the EP deallocation into the later point, the
    destructor callback.  At this stage, all PCMs must have been already
    closed, so it's safe to free the objects.
    
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index 1c7e8ee48abc..e61ee5c356a3 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -23,6 +23,7 @@ void snd_usb_endpoint_stop(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_sync_pending_stop(struct snd_usb_endpoint *ep);
 int  snd_usb_endpoint_activate(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_deactivate(struct snd_usb_endpoint *ep);
+void snd_usb_endpoint_release(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_free(struct list_head *head);
 
 int snd_usb_endpoint_implicit_feedback_sink(struct snd_usb_endpoint *ep);

commit 9b7c552bba88748001574925b80ba520691b0e4d
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Sun Oct 6 22:31:10 2013 +0200

    ALSA: usb-audio: void return type of snd_usb_endpoint_deactivate()
    
    The return value of snd_usb_endpoint_deactivate() is not used,
    make the function have no return value.
    Update the documentation to reflect what the function is actually
    doing.
    
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index 3bd02f0d226c..1c7e8ee48abc 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -22,7 +22,7 @@ int  snd_usb_endpoint_start(struct snd_usb_endpoint *ep, bool can_sleep);
 void snd_usb_endpoint_stop(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_sync_pending_stop(struct snd_usb_endpoint *ep);
 int  snd_usb_endpoint_activate(struct snd_usb_endpoint *ep);
-int  snd_usb_endpoint_deactivate(struct snd_usb_endpoint *ep);
+void snd_usb_endpoint_deactivate(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_free(struct list_head *head);
 
 int snd_usb_endpoint_implicit_feedback_sink(struct snd_usb_endpoint *ep);

commit 976b6c064a957445eb0573b270f2d0282630e9b9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 24 15:51:58 2013 -0400

    ALSA: improve buffer size computations for USB PCM audio
    
    This patch changes the way URBs are allocated and their sizes are
    determined for PCM playback in the snd-usb-audio driver.  Currently
    the driver allocates too few URBs for endpoints that don't use
    implicit sync, making underruns more likely to occur.  This may be a
    holdover from before I/O delays could be measured accurately; in any
    case, it is no longer necessary.
    
    The patch allocates as many URBs as possible, subject to four
    limitations:
    
            The total number of URBs for the endpoint is not allowed to
            exceed MAX_URBS (which the patch increases from 8 to 12).
    
            The total number of packets per URB is not allowed to exceed
            MAX_PACKS (or MAX_PACKS_HS for high-speed devices), which is
            decreased from 20 to 6.
    
            The total duration of queued data is not allowed to exceed
            MAX_QUEUE, which is decreased from 24 ms to 18 ms.
    
            The total number of ALSA frames in the output queue is not
            allowed to exceed the ALSA buffer size.
    
    The last requirement is the hardest to implement.  Currently the
    number of URBs needed to fill a buffer cannot be determined in
    advance, because a buffer contains a fixed number of frames whereas
    the number of frames in an URB varies to match shifts in the device's
    clock rate.  To solve this problem, the patch changes the logic for
    deciding how many packets an URB should contain.  Rather than using as
    many as possible without exceeding an ALSA period boundary, now the
    driver uses only as many packets as needed to transfer a predetermined
    number of frames.  As a result, unless the device's clock has an
    exceedingly variable rate, the number of URBs making up each period
    (and hence each buffer) will remain constant.
    
    The overall effect of the patch is that playback works better in
    low-latency settings.  The user can still specify values for
    frames/period and periods/buffer that exceed the capabilities of the
    hardware, of course.  But for values that are within those
    capabilities, the performance will be improved.  For example, testing
    shows that a high-speed device can handle 32 frames/period and 3
    periods/buffer at 48 KHz, whereas the current driver starts to get
    glitchy at 64 frames/period and 2 periods/buffer.
    
    A side effect of these changes is that the "nrpacks" module parameter
    is no longer used.  The patch removes it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Clemens Ladisch <clemens@ladisch.de>
    Tested-by: Daniel Mack <zonque@gmail.com>
    Tested-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index 2287adf5ca59..3bd02f0d226c 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -12,6 +12,8 @@ int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
 				snd_pcm_format_t pcm_format,
 				unsigned int channels,
 				unsigned int period_bytes,
+				unsigned int period_frames,
+				unsigned int buffer_periods,
 				unsigned int rate,
 				struct audioformat *fmt,
 				struct snd_usb_endpoint *sync_ep);

commit 98ae472b574647e36b2c8306091dff6de4606222
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Wed Apr 3 23:18:52 2013 +0200

    ALSA: usb-audio: spelling correction
    
    Correct spelling of snd_usb_endpoint_implict_feedback_sink in all
    occurances.
    
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index 447902dd8a4a..2287adf5ca59 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -23,7 +23,7 @@ int  snd_usb_endpoint_activate(struct snd_usb_endpoint *ep);
 int  snd_usb_endpoint_deactivate(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_free(struct list_head *head);
 
-int snd_usb_endpoint_implict_feedback_sink(struct snd_usb_endpoint *ep);
+int snd_usb_endpoint_implicit_feedback_sink(struct snd_usb_endpoint *ep);
 int snd_usb_endpoint_next_packet_size(struct snd_usb_endpoint *ep);
 
 void snd_usb_handle_sync_urb(struct snd_usb_endpoint *ep,

commit b2eb950de2f09435d5156f4dc6d5dbf284cd97f3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 21 08:30:48 2012 +0100

    ALSA: usb-audio: stop both data and sync endpoints asynchronously
    
    As we are stopping the endpoints asynchronously now, it's better to
    trigger the stop of both data and sync endpoints and wait for pending
    stopping operations, instead of the sequential trigger-and-wait
    procedure.
    
    So the wait argument in snd_usb_endpoint_stop() is dropped, and it's
    expected that the caller synchronizes explicitly by calling
    snd_usb_endpoint_sync_pending_stop().  (Actually there is only one
    place calling this, so it was safe to change.)
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index f1e451da9a67..447902dd8a4a 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -17,7 +17,7 @@ int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
 				struct snd_usb_endpoint *sync_ep);
 
 int  snd_usb_endpoint_start(struct snd_usb_endpoint *ep, bool can_sleep);
-void snd_usb_endpoint_stop(struct snd_usb_endpoint *ep, bool wait);
+void snd_usb_endpoint_stop(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_sync_pending_stop(struct snd_usb_endpoint *ep);
 int  snd_usb_endpoint_activate(struct snd_usb_endpoint *ep);
 int  snd_usb_endpoint_deactivate(struct snd_usb_endpoint *ep);

commit a9bb36261ef5c7e25564d5ce8a5129920a29bff9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 20 18:32:06 2012 +0100

    ALSA: usb-audio: simplify snd_usb_endpoint_start/stop arguments
    
    Reduce the redundant arguments for snd_usb_endpoint_start() and
    snd_usb_endpoint_stop().  Also replaced from int to bool.
    
    No functional changes by this commit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index 3d4c9705041f..f1e451da9a67 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -16,9 +16,8 @@ int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
 				struct audioformat *fmt,
 				struct snd_usb_endpoint *sync_ep);
 
-int  snd_usb_endpoint_start(struct snd_usb_endpoint *ep, int can_sleep);
-void snd_usb_endpoint_stop(struct snd_usb_endpoint *ep,
-			   int force, int can_sleep, int wait);
+int  snd_usb_endpoint_start(struct snd_usb_endpoint *ep, bool can_sleep);
+void snd_usb_endpoint_stop(struct snd_usb_endpoint *ep, bool wait);
 void snd_usb_endpoint_sync_pending_stop(struct snd_usb_endpoint *ep);
 int  snd_usb_endpoint_activate(struct snd_usb_endpoint *ep);
 int  snd_usb_endpoint_deactivate(struct snd_usb_endpoint *ep);

commit f58161ba1b05a968e5136824b5a16b714b6a5317
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 8 08:52:45 2012 +0100

    ALSA: usb-audio: Fix crash at re-preparing the PCM stream
    
    There are bug reports of a crash with USB-audio devices when PCM
    prepare is performed immediately after the stream is stopped via
    trigger callback.  It turned out that the problem is that we don't
    wait until all URBs are killed.
    
    This patch adds a new function to synchronize the pending stop
    operation on an endpoint, and calls in the prepare callback for
    avoiding the crash above.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=49181
    
    Reported-and-tested-by: Artem S. Tashkinov <t.artem@lycos.com>
    Cc: <stable@vger.kernel.org> [v3.6]
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index 6376ccf10fd4..3d4c9705041f 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -19,6 +19,7 @@ int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
 int  snd_usb_endpoint_start(struct snd_usb_endpoint *ep, int can_sleep);
 void snd_usb_endpoint_stop(struct snd_usb_endpoint *ep,
 			   int force, int can_sleep, int wait);
+void snd_usb_endpoint_sync_pending_stop(struct snd_usb_endpoint *ep);
 int  snd_usb_endpoint_activate(struct snd_usb_endpoint *ep);
 int  snd_usb_endpoint_deactivate(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_free(struct list_head *head);

commit 35ec7aa29833de350f51922736aefe22ebf76c4d
Author: Dylan Reid <dgreid@chromium.org>
Date:   Tue Sep 18 09:49:47 2012 -0700

    ALSA: usb-audio: Don't require hw_params in endpoint.
    
    Change the interface to configure an endpoint so that it doesn't require
    a hw_params struct.  This will allow it to be called from prepare
    instead of hw_params, configuring it after system resume.
    
    Signed-off-by: Dylan Reid <dgreid@chromium.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index cbbbdf226d66..6376ccf10fd4 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -9,7 +9,10 @@ struct snd_usb_endpoint *snd_usb_add_endpoint(struct snd_usb_audio *chip,
 					      int ep_num, int direction, int type);
 
 int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
-				struct snd_pcm_hw_params *hw_params,
+				snd_pcm_format_t pcm_format,
+				unsigned int channels,
+				unsigned int period_bytes,
+				unsigned int rate,
 				struct audioformat *fmt,
 				struct snd_usb_endpoint *sync_ep);
 

commit 245baf983cc39524cce39c24d01b276e6e653c9e
Author: Daniel Mack <zonque@gmail.com>
Date:   Thu Aug 30 18:52:30 2012 +0200

    ALSA: snd-usb: fix calls to next_packet_size
    
    In order to support devices with implicit feedback streaming models,
    packet sizes are now stored with each individual urb, and the PCM
    handling code which fills the buffers purely relies on the size fields
    now.
    
    However, calling snd_usb_audio_next_packet_size() for all possible
    packets in an URB at once, prior to letting the PCM code do its job
    does in fact not lead to the same behaviour than what the old code did:
    The PCM code will break its loop once a period boundary is reached,
    consequently using up less packets that it really could.
    
    As snd_usb_audio_next_packet_size() implements a feedback mechanism to
    the endpoints phase accumulator, the number of calls to that function
    matters, and when called too often, the data rate runs out of bounds.
    
    Fix this by making the next_packet function public, and call it from the
    PCM code as before if the packet data sizes are not defined.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Cc: stable@kernel.org [v3.5+]
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index a8e60c1408e5..cbbbdf226d66 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -21,6 +21,7 @@ int  snd_usb_endpoint_deactivate(struct snd_usb_endpoint *ep);
 void snd_usb_endpoint_free(struct list_head *head);
 
 int snd_usb_endpoint_implict_feedback_sink(struct snd_usb_endpoint *ep);
+int snd_usb_endpoint_next_packet_size(struct snd_usb_endpoint *ep);
 
 void snd_usb_handle_sync_urb(struct snd_usb_endpoint *ep,
 			     struct snd_usb_endpoint *sender,

commit 015618b902ae8e28705b7af9b4668615fea48ddd
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Aug 29 13:17:05 2012 +0200

    ALSA: snd-usb: Fix URB cancellation at stream start
    
    Commit e9ba389c5 ("ALSA: usb-audio: Fix scheduling-while-atomic bug in
    PCM capture stream") fixed a scheduling-while-atomic bug that happened
    when snd_usb_endpoint_start was called from the trigger callback, which
    is an atmic context. However, the patch breaks the idea of the endpoints
    reference counting, which is the reason why the driver has been
    refactored lately.
    
    Revert that commit and let snd_usb_endpoint_start() take care of the URB
    cancellation again. As this function is called from both atomic and
    non-atomic context, add a flag to denote whether the function may sleep.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Cc: stable@kernel.org [3.5+]
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index ee2723fb174f..a8e60c1408e5 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -13,7 +13,7 @@ int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
 				struct audioformat *fmt,
 				struct snd_usb_endpoint *sync_ep);
 
-int  snd_usb_endpoint_start(struct snd_usb_endpoint *ep);
+int  snd_usb_endpoint_start(struct snd_usb_endpoint *ep, int can_sleep);
 void snd_usb_endpoint_stop(struct snd_usb_endpoint *ep,
 			   int force, int can_sleep, int wait);
 int  snd_usb_endpoint_activate(struct snd_usb_endpoint *ep);

commit d399ff9593e088d33fb38f5206c6427825892baa
Author: Daniel Mack <zonque@gmail.com>
Date:   Thu Apr 12 13:51:13 2012 +0200

    ALSA: snd-usb: remove old streaming logic
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index e540768de3d5..ee2723fb174f 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -1,21 +1,6 @@
 #ifndef __USBAUDIO_ENDPOINT_H
 #define __USBAUDIO_ENDPOINT_H
 
-void snd_usb_init_substream(struct snd_usb_stream *as,
-			    int stream,
-			    struct audioformat *fp);
-
-int snd_usb_init_substream_urbs(struct snd_usb_substream *subs,
-				unsigned int period_bytes,
-				unsigned int rate,
-				unsigned int frame_bits);
-
-void snd_usb_release_substream_urbs(struct snd_usb_substream *subs, int force);
-
-int snd_usb_substream_prepare(struct snd_usb_substream *subs,
-			      struct snd_pcm_runtime *runtime);
-
-
 #define SND_USB_ENDPOINT_TYPE_DATA     0
 #define SND_USB_ENDPOINT_TYPE_SYNC     1
 

commit edcd3633e72a1590c4cf46befe5e6cd03b5aec3e
Author: Daniel Mack <zonque@gmail.com>
Date:   Thu Apr 12 13:51:12 2012 +0200

    ALSA: snd-usb: switch over to new endpoint streaming logic
    
    With the previous commit that added the new streaming model, all
    endpoint and streaming related code is now in endpoint.c, and pcm.c
    only acts as a wrapper for handling the packet's payload.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index 9f083d7d6cf1..e540768de3d5 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -15,9 +15,6 @@ void snd_usb_release_substream_urbs(struct snd_usb_substream *subs, int force);
 int snd_usb_substream_prepare(struct snd_usb_substream *subs,
 			      struct snd_pcm_runtime *runtime);
 
-int snd_usb_substream_playback_trigger(struct snd_pcm_substream *substream, int cmd);
-int snd_usb_substream_capture_trigger(struct snd_pcm_substream *substream, int cmd);
-
 
 #define SND_USB_ENDPOINT_TYPE_DATA     0
 #define SND_USB_ENDPOINT_TYPE_SYNC     1

commit 8fdff6a319e7dac757c558bd283dc4577e68cde7
Author: Daniel Mack <zonque@gmail.com>
Date:   Thu Apr 12 13:51:11 2012 +0200

    ALSA: snd-usb: implement new endpoint streaming model
    
    This patch adds a new generic streaming logic for audio over USB.
    
    It defines a model (snd_usb_endpoint) that handles everything that
    is related to an USB endpoint and its streaming. There are functions to
    activate and deactivate an endpoint (which call usb_set_interface()),
    and to start and stop its URBs. It also has function pointers to be
    called when data was received or is about to be sent, and pointer to
    a sync slave (another snd_usb_endpoint) that is informed when data has
    been received.
    
    A snd_usb_endpoint knows about its state and implements a refcounting,
    so only the first user will actually start the URBs and only the last
    one to stop it will tear them down again.
    
    With this sort of abstraction, the actual streaming is decoupled from
    the pcm handling, which makes the "implicit feedback" mechanisms easy to
    implement.
    
    In order to split changes properly, this patch only adds the new
    implementation but leaves the old one around, so the the driver doesn't
    change its behaviour. The switch to actually use the new code is
    submitted separately.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index 88eb63a636eb..9f083d7d6cf1 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -18,4 +18,30 @@ int snd_usb_substream_prepare(struct snd_usb_substream *subs,
 int snd_usb_substream_playback_trigger(struct snd_pcm_substream *substream, int cmd);
 int snd_usb_substream_capture_trigger(struct snd_pcm_substream *substream, int cmd);
 
+
+#define SND_USB_ENDPOINT_TYPE_DATA     0
+#define SND_USB_ENDPOINT_TYPE_SYNC     1
+
+struct snd_usb_endpoint *snd_usb_add_endpoint(struct snd_usb_audio *chip,
+					      struct usb_host_interface *alts,
+					      int ep_num, int direction, int type);
+
+int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
+				struct snd_pcm_hw_params *hw_params,
+				struct audioformat *fmt,
+				struct snd_usb_endpoint *sync_ep);
+
+int  snd_usb_endpoint_start(struct snd_usb_endpoint *ep);
+void snd_usb_endpoint_stop(struct snd_usb_endpoint *ep,
+			   int force, int can_sleep, int wait);
+int  snd_usb_endpoint_activate(struct snd_usb_endpoint *ep);
+int  snd_usb_endpoint_deactivate(struct snd_usb_endpoint *ep);
+void snd_usb_endpoint_free(struct list_head *head);
+
+int snd_usb_endpoint_implict_feedback_sink(struct snd_usb_endpoint *ep);
+
+void snd_usb_handle_sync_urb(struct snd_usb_endpoint *ep,
+			     struct snd_usb_endpoint *sender,
+			     const struct urb *urb);
+
 #endif /* __USBAUDIO_ENDPOINT_H */

commit c731bc96ad641a5fa3d50a87b474652505507282
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Sep 14 12:46:57 2011 +0200

    ALSA: snd-usb: move code from urb.c to endpoint.c
    
    No code altered at this point, simply preparing for upcoming
    refactorizations.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index e5d8a6adf38f..88eb63a636eb 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -1,4 +1,21 @@
 #ifndef __USBAUDIO_ENDPOINT_H
 #define __USBAUDIO_ENDPOINT_H
 
+void snd_usb_init_substream(struct snd_usb_stream *as,
+			    int stream,
+			    struct audioformat *fp);
+
+int snd_usb_init_substream_urbs(struct snd_usb_substream *subs,
+				unsigned int period_bytes,
+				unsigned int rate,
+				unsigned int frame_bits);
+
+void snd_usb_release_substream_urbs(struct snd_usb_substream *subs, int force);
+
+int snd_usb_substream_prepare(struct snd_usb_substream *subs,
+			      struct snd_pcm_runtime *runtime);
+
+int snd_usb_substream_playback_trigger(struct snd_pcm_substream *substream, int cmd);
+int snd_usb_substream_capture_trigger(struct snd_pcm_substream *substream, int cmd);
+
 #endif /* __USBAUDIO_ENDPOINT_H */

commit e8e8babf561c9560f37b9bd80407ebaf90ad2ca4
Author: Daniel Mack <zonque@gmail.com>
Date:   Mon Sep 12 18:54:12 2011 +0200

    ALSA: snd-usb: re-order code
    
    Move code from endpoint.c into a new file called stream.c and rename
    functions so that their names actually reflect what they're doing.
    
    This way, endpoint.c will be available to functions that hold all the
    endpoint logic.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index 64dd0db023b2..e5d8a6adf38f 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -1,11 +1,4 @@
 #ifndef __USBAUDIO_ENDPOINT_H
 #define __USBAUDIO_ENDPOINT_H
 
-int snd_usb_parse_audio_endpoints(struct snd_usb_audio *chip,
-				  int iface_no);
-
-int snd_usb_add_audio_endpoint(struct snd_usb_audio *chip,
-			       int stream,
-			       struct audioformat *fp);
-
 #endif /* __USBAUDIO_ENDPOINT_H */

commit e5779998bf8b70e48a6cc208c8b61b33bd6117ea
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Mar 4 19:46:13 2010 +0100

    ALSA: usb-audio: refactor code
    
    Clean up the usb audio driver by factoring out a lot of functions to
    separate files. Code for procfs, quirks, urbs, format parsers etc all
    got a new home now.
    
    Moved almost all special quirk handling to quirks.c and introduced new
    generic functions to handle them, so the exceptions do not pollute the
    whole driver.
    
    Renamed usbaudio.c to card.c because this is what it actually does now.
    Renamed usbmidi.c to midi.c for namespace clarity.
    Removed more things from usbaudio.h.
    
    The non-standard drivers were adopted accordingly.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
new file mode 100644
index 000000000000..64dd0db023b2
--- /dev/null
+++ b/sound/usb/endpoint.h
@@ -0,0 +1,11 @@
+#ifndef __USBAUDIO_ENDPOINT_H
+#define __USBAUDIO_ENDPOINT_H
+
+int snd_usb_parse_audio_endpoints(struct snd_usb_audio *chip,
+				  int iface_no);
+
+int snd_usb_add_audio_endpoint(struct snd_usb_audio *chip,
+			       int stream,
+			       struct audioformat *fp);
+
+#endif /* __USBAUDIO_ENDPOINT_H */
