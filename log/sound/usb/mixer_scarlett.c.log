commit a01df925d1bbc97d6f7fe07b157aadb565315337
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:26 2020 +0100

    ALSA: usb-audio: More constifications
    
    Apply const prefix to the remaining places: the static table for the
    unit information, the mixer maps, the validator tables, etc.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-12-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/mixer_scarlett.c b/sound/usb/mixer_scarlett.c
index 9d10cbf1b5ed..49fcd2505443 100644
--- a/sound/usb/mixer_scarlett.c
+++ b/sound/usb/mixer_scarlett.c
@@ -633,7 +633,7 @@ static int add_output_ctls(struct usb_mixer_interface *mixer,
 /********************** device-specific config *************************/
 
 /*  untested...  */
-static struct scarlett_device_info s6i6_info = {
+static const struct scarlett_device_info s6i6_info = {
 	.matrix_in = 18,
 	.matrix_out = 8,
 	.input_len = 6,
@@ -675,7 +675,7 @@ static struct scarlett_device_info s6i6_info = {
 };
 
 /*  untested...  */
-static struct scarlett_device_info s8i6_info = {
+static const struct scarlett_device_info s8i6_info = {
 	.matrix_in = 18,
 	.matrix_out = 6,
 	.input_len = 8,
@@ -714,7 +714,7 @@ static struct scarlett_device_info s8i6_info = {
 	}
 };
 
-static struct scarlett_device_info s18i6_info = {
+static const struct scarlett_device_info s18i6_info = {
 	.matrix_in = 18,
 	.matrix_out = 6,
 	.input_len = 18,
@@ -751,7 +751,7 @@ static struct scarlett_device_info s18i6_info = {
 	}
 };
 
-static struct scarlett_device_info s18i8_info = {
+static const struct scarlett_device_info s18i8_info = {
 	.matrix_in = 18,
 	.matrix_out = 8,
 	.input_len = 18,
@@ -793,7 +793,7 @@ static struct scarlett_device_info s18i8_info = {
 	}
 };
 
-static struct scarlett_device_info s18i20_info = {
+static const struct scarlett_device_info s18i20_info = {
 	.matrix_in = 18,
 	.matrix_out = 8,
 	.input_len = 18,
@@ -843,7 +843,7 @@ static struct scarlett_device_info s18i20_info = {
 
 
 static int scarlett_controls_create_generic(struct usb_mixer_interface *mixer,
-	struct scarlett_device_info *info)
+	const struct scarlett_device_info *info)
 {
 	int i, err;
 	char mx[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
@@ -915,7 +915,7 @@ int snd_scarlett_controls_create(struct usb_mixer_interface *mixer)
 {
 	int err, i, o;
 	char mx[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
-	struct scarlett_device_info *info;
+	const struct scarlett_device_info *info;
 	struct usb_mixer_elem_info *elem;
 	static char sample_rate_buffer[4] = { '\x80', '\xbb', '\x00', '\x00' };
 

commit bf2aa5cadd1c7bb91af4b5b1218e643cfffb5c9a
Author: Jens Verwiebe <info@jensverwiebe.de>
Date:   Sun Nov 24 13:35:44 2019 +0100

    ALSA: usb-audio: Fix Focusrite Scarlett 6i6 gen1 - input handling
    
    The Scarlett 6i6 has no padding on rear inputs 3/4 but a gainstage.
    This patch introduces this functionality as to be seen in the mac
    or windows scarlett control.
    
    The correct address could already be found in the dump info, but was
    never used. Without this patch inputs 3/4 are quite unusable else.
    
    Signed-off-by: Jens Verwiebe <info@jensverwiebe.de>
    Link: https://lore.kernel.org/r/384d65cd-5e87-91eb-9fc3-e57226f534c6@jensverwiebe.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/mixer_scarlett.c b/sound/usb/mixer_scarlett.c
index 83715fd8dfd6..9d10cbf1b5ed 100644
--- a/sound/usb/mixer_scarlett.c
+++ b/sound/usb/mixer_scarlett.c
@@ -142,6 +142,7 @@ enum {
 	SCARLETT_OUTPUTS,
 	SCARLETT_SWITCH_IMPEDANCE,
 	SCARLETT_SWITCH_PAD,
+	SCARLETT_SWITCH_GAIN,
 };
 
 enum {
@@ -192,6 +193,15 @@ static const struct scarlett_mixer_elem_enum_info opt_pad = {
 	}
 };
 
+static const struct scarlett_mixer_elem_enum_info opt_gain = {
+	.start = 0,
+	.len = 2,
+	.offsets = {},
+	.names = (char const * const []){
+		"Lo", "Hi"
+	}
+};
+
 static const struct scarlett_mixer_elem_enum_info opt_impedance = {
 	.start = 0,
 	.len = 2,
@@ -652,8 +662,8 @@ static struct scarlett_device_info s6i6_info = {
 		{ .num = 1, .type = SCARLETT_SWITCH_PAD, .name = NULL},
 		{ .num = 2, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},
 		{ .num = 2, .type = SCARLETT_SWITCH_PAD, .name = NULL},
-		{ .num = 3, .type = SCARLETT_SWITCH_PAD, .name = NULL},
-		{ .num = 4, .type = SCARLETT_SWITCH_PAD, .name = NULL},
+		{ .num = 3, .type = SCARLETT_SWITCH_GAIN, .name = NULL},
+		{ .num = 4, .type = SCARLETT_SWITCH_GAIN, .name = NULL},
 	},
 
 	.matrix_mux_init = {
@@ -883,6 +893,15 @@ static int scarlett_controls_create_generic(struct usb_mixer_interface *mixer,
 			if (err < 0)
 				return err;
 			break;
+		case SCARLETT_SWITCH_GAIN:
+			sprintf(mx, "Input %d Gain Switch", ctl->num);
+			err = add_new_ctl(mixer, &usb_scarlett_ctl_enum,
+					  scarlett_ctl_enum_resume, 0x01,
+					  0x08, ctl->num, USB_MIXER_S16, 1, mx,
+					  &opt_gain, &elem);
+			if (err < 0)
+				return err;
+			break;
 		}
 	}
 

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/usb/mixer_scarlett.c b/sound/usb/mixer_scarlett.c
index 4aeb9488a0c9..83715fd8dfd6 100644
--- a/sound/usb/mixer_scarlett.c
+++ b/sound/usb/mixer_scarlett.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *   Scarlett Driver for ALSA
  *
@@ -12,17 +13,6 @@
  *
  *   Code cleanup:
  *   David Henningsson <david.henningsson at canonical.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
  */
 
 /*

commit 8c558076c740e8009a96c6fdc3d4245dde62be77
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu May 3 12:33:32 2018 +0200

    ALSA: usb-audio: Clean up mixer element list traverse
    
    Introduce a new macro for iterating over mixer element list for
    avoiding the open codes in many places.  Also the open-coded
    container_of() and the forced cast to struct usb_mixer_elem_info are
    replaced with another simple macro, too.
    
    No functional changes but just readability improvement.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/mixer_scarlett.c b/sound/usb/mixer_scarlett.c
index c33e2378089d..4aeb9488a0c9 100644
--- a/sound/usb/mixer_scarlett.c
+++ b/sound/usb/mixer_scarlett.c
@@ -287,8 +287,7 @@ static int scarlett_ctl_switch_put(struct snd_kcontrol *kctl,
 
 static int scarlett_ctl_resume(struct usb_mixer_elem_list *list)
 {
-	struct usb_mixer_elem_info *elem =
-		container_of(list, struct usb_mixer_elem_info, head);
+	struct usb_mixer_elem_info *elem = mixer_elem_list_to_info(list);
 	int i;
 
 	for (i = 0; i < elem->channels; i++)
@@ -447,8 +446,7 @@ static int scarlett_ctl_enum_put(struct snd_kcontrol *kctl,
 
 static int scarlett_ctl_enum_resume(struct usb_mixer_elem_list *list)
 {
-	struct usb_mixer_elem_info *elem =
-		container_of(list, struct usb_mixer_elem_info, head);
+	struct usb_mixer_elem_info *elem = mixer_elem_list_to_info(list);
 
 	if (elem->cached)
 		snd_usb_set_cur_mix_value(elem, 0, 0, *elem->cache_val);

commit 04bab35044e7aa54031e55e3f7039141c54e70d7
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Wed Feb 22 01:33:27 2017 +0530

    ALSA: usb-audio: constify snd_kcontrol_new structures
    
    Declare snd_kcontrol_new structures as const as they are only passed as
    an argument to the function add_new_ctl. This agrument is of type const,
    so snd_kcontrol_new structures having this property can be made const
    too.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/mixer_scarlett.c b/sound/usb/mixer_scarlett.c
index 7438e7c4a842..c33e2378089d 100644
--- a/sound/usb/mixer_scarlett.c
+++ b/sound/usb/mixer_scarlett.c
@@ -477,7 +477,7 @@ static int scarlett_ctl_meter_get(struct snd_kcontrol *kctl,
 	return 0;
 }
 
-static struct snd_kcontrol_new usb_scarlett_ctl_switch = {
+static const struct snd_kcontrol_new usb_scarlett_ctl_switch = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "",
 	.info = scarlett_ctl_switch_info,
@@ -487,7 +487,7 @@ static struct snd_kcontrol_new usb_scarlett_ctl_switch = {
 
 static const DECLARE_TLV_DB_SCALE(db_scale_scarlett_gain, -12800, 100, 0);
 
-static struct snd_kcontrol_new usb_scarlett_ctl = {
+static const struct snd_kcontrol_new usb_scarlett_ctl = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
 		  SNDRV_CTL_ELEM_ACCESS_TLV_READ,
@@ -499,7 +499,7 @@ static struct snd_kcontrol_new usb_scarlett_ctl = {
 	.tlv = { .p = db_scale_scarlett_gain }
 };
 
-static struct snd_kcontrol_new usb_scarlett_ctl_master = {
+static const struct snd_kcontrol_new usb_scarlett_ctl_master = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
 		  SNDRV_CTL_ELEM_ACCESS_TLV_READ,
@@ -511,7 +511,7 @@ static struct snd_kcontrol_new usb_scarlett_ctl_master = {
 	.tlv = { .p = db_scale_scarlett_gain }
 };
 
-static struct snd_kcontrol_new usb_scarlett_ctl_enum = {
+static const struct snd_kcontrol_new usb_scarlett_ctl_enum = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "",
 	.info = scarlett_ctl_enum_info,
@@ -519,7 +519,7 @@ static struct snd_kcontrol_new usb_scarlett_ctl_enum = {
 	.put =  scarlett_ctl_enum_put,
 };
 
-static struct snd_kcontrol_new usb_scarlett_ctl_dynamic_enum = {
+static const struct snd_kcontrol_new usb_scarlett_ctl_dynamic_enum = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "",
 	.info = scarlett_ctl_enum_dynamic_info,
@@ -527,7 +527,7 @@ static struct snd_kcontrol_new usb_scarlett_ctl_dynamic_enum = {
 	.put =  scarlett_ctl_enum_put,
 };
 
-static struct snd_kcontrol_new usb_scarlett_ctl_sync = {
+static const struct snd_kcontrol_new usb_scarlett_ctl_sync = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
 	.name = "",

commit c99b9e853d3951fe521cc7b2357eec93d5c16246
Author: Chris J Arges <chris.j.arges@canonical.com>
Date:   Wed Dec 17 16:09:35 2014 -0600

    ALSA: usb-audio: Fix Scarlett 6i6 initialization typo
    
    The num_controls field was incorrectly set to 0 causing 6i6 to not be
    initialized. Set this to 9.
    
    Reported-and-tested-by: Mark Roberts <sunifiram@gmail.com>
    Signed-off-by: Chris J Arges <chris.j.arges@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/mixer_scarlett.c b/sound/usb/mixer_scarlett.c
index 9109652b88b9..7438e7c4a842 100644
--- a/sound/usb/mixer_scarlett.c
+++ b/sound/usb/mixer_scarlett.c
@@ -655,7 +655,7 @@ static struct scarlett_device_info s6i6_info = {
 		.names = NULL
 	},
 
-	.num_controls = 0,
+	.num_controls = 9,
 	.controls = {
 		{ .num = 0, .type = SCARLETT_OUTPUTS, .name = "Monitor" },
 		{ .num = 1, .type = SCARLETT_OUTPUTS, .name = "Headphone" },

commit b61f90eac1ff9d1b30497e611aba4651d4066706
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 20 17:20:46 2014 +0100

    ALSA: usb-audio: Add resume support for Scarlett mixers
    
    Scarlett driver uses almost compatible usb_mixer_elem_info struct, so
    we just need to add a couple of simple resume callbacks to handle them
    accordingly.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/mixer_scarlett.c b/sound/usb/mixer_scarlett.c
index 92dba35660b3..9109652b88b9 100644
--- a/sound/usb/mixer_scarlett.c
+++ b/sound/usb/mixer_scarlett.c
@@ -285,6 +285,19 @@ static int scarlett_ctl_switch_put(struct snd_kcontrol *kctl,
 	return changed;
 }
 
+static int scarlett_ctl_resume(struct usb_mixer_elem_list *list)
+{
+	struct usb_mixer_elem_info *elem =
+		container_of(list, struct usb_mixer_elem_info, head);
+	int i;
+
+	for (i = 0; i < elem->channels; i++)
+		if (elem->cached & (1 << i))
+			snd_usb_set_cur_mix_value(elem, i, i,
+						  elem->cache_val[i]);
+	return 0;
+}
+
 static int scarlett_ctl_info(struct snd_kcontrol *kctl,
 			     struct snd_ctl_elem_info *uinfo)
 {
@@ -432,6 +445,16 @@ static int scarlett_ctl_enum_put(struct snd_kcontrol *kctl,
 	return 0;
 }
 
+static int scarlett_ctl_enum_resume(struct usb_mixer_elem_list *list)
+{
+	struct usb_mixer_elem_info *elem =
+		container_of(list, struct usb_mixer_elem_info, head);
+
+	if (elem->cached)
+		snd_usb_set_cur_mix_value(elem, 0, 0, *elem->cache_val);
+	return 0;
+}
+
 static int scarlett_ctl_meter_get(struct snd_kcontrol *kctl,
 				  struct snd_ctl_elem_value *ucontrol)
 {
@@ -514,6 +537,7 @@ static struct snd_kcontrol_new usb_scarlett_ctl_sync = {
 
 static int add_new_ctl(struct usb_mixer_interface *mixer,
 		       const struct snd_kcontrol_new *ncontrol,
+		       usb_mixer_elem_resume_func_t resume,
 		       int index, int offset, int num,
 		       int val_type, int channels, const char *name,
 		       const struct scarlett_mixer_elem_enum_info *opt,
@@ -529,6 +553,7 @@ static int add_new_ctl(struct usb_mixer_interface *mixer,
 		return -ENOMEM;
 
 	elem->head.mixer = mixer;
+	elem->head.resume = resume;
 	elem->control = offset;
 	elem->idx_off = num;
 	elem->head.id = index;
@@ -548,7 +573,7 @@ static int add_new_ctl(struct usb_mixer_interface *mixer,
 
 	strlcpy(kctl->id.name, name, sizeof(kctl->id.name));
 
-	err = snd_ctl_add(mixer->chip->card, kctl);
+	err = snd_usb_mixer_add_control(&elem->head, kctl);
 	if (err < 0)
 		return err;
 
@@ -569,7 +594,8 @@ static int add_output_ctls(struct usb_mixer_interface *mixer,
 	/* Add mute switch */
 	snprintf(mx, sizeof(mx), "Master %d (%s) Playback Switch",
 		index + 1, name);
-	err = add_new_ctl(mixer, &usb_scarlett_ctl_switch, 0x0a, 0x01,
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_switch,
+			  scarlett_ctl_resume, 0x0a, 0x01,
 			  2*index+1, USB_MIXER_S16, 2, mx, NULL, &elem);
 	if (err < 0)
 		return err;
@@ -577,7 +603,8 @@ static int add_output_ctls(struct usb_mixer_interface *mixer,
 	/* Add volume control and initialize to 0 */
 	snprintf(mx, sizeof(mx), "Master %d (%s) Playback Volume",
 		index + 1, name);
-	err = add_new_ctl(mixer, &usb_scarlett_ctl_master, 0x0a, 0x02,
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_master,
+			  scarlett_ctl_resume, 0x0a, 0x02,
 			  2*index+1, USB_MIXER_S16, 2, mx, NULL, &elem);
 	if (err < 0)
 		return err;
@@ -585,7 +612,8 @@ static int add_output_ctls(struct usb_mixer_interface *mixer,
 	/* Add L channel source playback enumeration */
 	snprintf(mx, sizeof(mx), "Master %dL (%s) Source Playback Enum",
 		index + 1, name);
-	err = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum, 0x33, 0x00,
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum,
+			  scarlett_ctl_enum_resume, 0x33, 0x00,
 			  2*index, USB_MIXER_S16, 1, mx, &info->opt_master,
 			  &elem);
 	if (err < 0)
@@ -594,7 +622,8 @@ static int add_output_ctls(struct usb_mixer_interface *mixer,
 	/* Add R channel source playback enumeration */
 	snprintf(mx, sizeof(mx), "Master %dR (%s) Source Playback Enum",
 		index + 1, name);
-	err = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum, 0x33, 0x00,
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum,
+			  scarlett_ctl_enum_resume, 0x33, 0x00,
 			  2*index+1, USB_MIXER_S16, 1, mx, &info->opt_master,
 			  &elem);
 	if (err < 0)
@@ -824,13 +853,15 @@ static int scarlett_controls_create_generic(struct usb_mixer_interface *mixer,
 	struct usb_mixer_elem_info *elem;
 
 	/* create master switch and playback volume */
-	err = add_new_ctl(mixer, &usb_scarlett_ctl_switch, 0x0a, 0x01, 0,
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_switch,
+			  scarlett_ctl_resume, 0x0a, 0x01, 0,
 			  USB_MIXER_S16, 1, "Master Playback Switch", NULL,
 			  &elem);
 	if (err < 0)
 		return err;
 
-	err = add_new_ctl(mixer, &usb_scarlett_ctl_master, 0x0a, 0x02, 0,
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_master,
+			  scarlett_ctl_resume, 0x0a, 0x02, 0,
 			  USB_MIXER_S16, 1, "Master Playback Volume", NULL,
 			  &elem);
 	if (err < 0)
@@ -848,7 +879,8 @@ static int scarlett_controls_create_generic(struct usb_mixer_interface *mixer,
 			break;
 		case SCARLETT_SWITCH_IMPEDANCE:
 			sprintf(mx, "Input %d Impedance Switch", ctl->num);
-			err = add_new_ctl(mixer, &usb_scarlett_ctl_enum, 0x01,
+			err = add_new_ctl(mixer, &usb_scarlett_ctl_enum,
+					  scarlett_ctl_enum_resume, 0x01,
 					  0x09, ctl->num, USB_MIXER_S16, 1, mx,
 					  &opt_impedance, &elem);
 			if (err < 0)
@@ -856,7 +888,8 @@ static int scarlett_controls_create_generic(struct usb_mixer_interface *mixer,
 			break;
 		case SCARLETT_SWITCH_PAD:
 			sprintf(mx, "Input %d Pad Switch", ctl->num);
-			err = add_new_ctl(mixer, &usb_scarlett_ctl_enum, 0x01,
+			err = add_new_ctl(mixer, &usb_scarlett_ctl_enum,
+					  scarlett_ctl_enum_resume, 0x01,
 					  0x0b, ctl->num, USB_MIXER_S16, 1, mx,
 					  &opt_pad, &elem);
 			if (err < 0)
@@ -912,7 +945,8 @@ int snd_scarlett_controls_create(struct usb_mixer_interface *mixer)
 	for (i = 0; i < info->matrix_in; i++) {
 		snprintf(mx, sizeof(mx), "Matrix %02d Input Playback Route",
 			 i+1);
-		err = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum, 0x32,
+		err = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum,
+				  scarlett_ctl_enum_resume, 0x32,
 				  0x06, i, USB_MIXER_S16, 1, mx,
 				  &info->opt_matrix, &elem);
 		if (err < 0)
@@ -921,7 +955,8 @@ int snd_scarlett_controls_create(struct usb_mixer_interface *mixer)
 		for (o = 0; o < info->matrix_out; o++) {
 			sprintf(mx, "Matrix %02d Mix %c Playback Volume", i+1,
 				o+'A');
-			err = add_new_ctl(mixer, &usb_scarlett_ctl, 0x3c, 0x00,
+			err = add_new_ctl(mixer, &usb_scarlett_ctl,
+					  scarlett_ctl_resume, 0x3c, 0x00,
 					  (i << 3) + (o & 0x07), USB_MIXER_S16,
 					  1, mx, NULL, &elem);
 			if (err < 0)
@@ -933,7 +968,8 @@ int snd_scarlett_controls_create(struct usb_mixer_interface *mixer)
 	for (i = 0; i < info->input_len; i++) {
 		snprintf(mx, sizeof(mx), "Input Source %02d Capture Route",
 			 i+1);
-		err = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum, 0x34,
+		err = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum,
+				  scarlett_ctl_enum_resume, 0x34,
 				  0x00, i, USB_MIXER_S16, 1, mx,
 				  &info->opt_master, &elem);
 		if (err < 0)
@@ -941,14 +977,15 @@ int snd_scarlett_controls_create(struct usb_mixer_interface *mixer)
 	}
 
 	/* val_len == 1 needed here */
-	err = add_new_ctl(mixer, &usb_scarlett_ctl_enum, 0x28, 0x01, 0,
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_enum,
+			  scarlett_ctl_enum_resume, 0x28, 0x01, 0,
 			  USB_MIXER_U8, 1, "Sample Clock Source",
 			  &opt_clock, &elem);
 	if (err < 0)
 		return err;
 
 	/* val_len == 1 and UAC2_CS_MEM */
-	err = add_new_ctl(mixer, &usb_scarlett_ctl_sync, 0x3c, 0x00, 2,
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_sync, NULL, 0x3c, 0x00, 2,
 			  USB_MIXER_U8, 1, "Sample Clock Sync Status",
 			  &opt_sync, &elem);
 	if (err < 0)

commit 3360b84b8ed1f08bfb39743465b858a04492fcc3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 18 11:47:04 2014 +0100

    ALSA: usb-audio: Allow quirks to handle own resume and proc dump
    
    So far, we blindly assumed that the all usb-audio mixer elements
    follow the standard and apply the standard resume method for the
    registered elements in the id_elems[] list.  However, some quirks
    really need the own resume and it's incomplete for now.
    
    This patch enhances the resume handling in two folds:
    - split some fields in struct usb_mixer_elem_info into a smaller
      header struct (usb_mixer_elem_list) for keeping the minimal
      information in the linked-list; the usb_mixer_elem_info embeds this
      header struct instead
    - add resume and dump callbacks to usb_mixer_elem_list struct to allow
      quirks providing the own methods
    
    For the standard mixer elements, these new callbacks are set to the
    standard ones as default, thus there is no functional change by this
    patch yet.
    
    The dump and resume callbacks are typedef'ed for ease of later patches
    using arrays of such function pointers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/mixer_scarlett.c b/sound/usb/mixer_scarlett.c
index a0a874507de5..92dba35660b3 100644
--- a/sound/usb/mixer_scarlett.c
+++ b/sound/usb/mixer_scarlett.c
@@ -436,10 +436,10 @@ static int scarlett_ctl_meter_get(struct snd_kcontrol *kctl,
 				  struct snd_ctl_elem_value *ucontrol)
 {
 	struct usb_mixer_elem_info *elem = kctl->private_data;
-	struct snd_usb_audio *chip = elem->mixer->chip;
+	struct snd_usb_audio *chip = elem->head.mixer->chip;
 	unsigned char buf[2 * MAX_CHANNELS] = {0, };
 	int wValue = (elem->control << 8) | elem->idx_off;
-	int idx = snd_usb_ctrl_intf(chip) | (elem->id << 8);
+	int idx = snd_usb_ctrl_intf(chip) | (elem->head.id << 8);
 	int err;
 
 	err = snd_usb_ctl_msg(chip->dev,
@@ -528,10 +528,10 @@ static int add_new_ctl(struct usb_mixer_interface *mixer,
 	if (!elem)
 		return -ENOMEM;
 
-	elem->mixer = mixer;
+	elem->head.mixer = mixer;
 	elem->control = offset;
 	elem->idx_off = num;
-	elem->id = index;
+	elem->head.id = index;
 	elem->val_type = val_type;
 
 	elem->channels = channels;

commit 76b188c4b370876018e3a778ec11a94a5316dbe4
Author: Chris J Arges <chris.j.arges@canonical.com>
Date:   Wed Nov 12 12:07:02 2014 -0600

    ALSA: usb-audio: Scarlett mixer interface for 6i6, 18i6, 18i8 and 18i20
    
    This code contains the Scarlett mixer interface code that was originally
    written by Tobias Hoffman and Robin Gareus. Because the device doesn't
    properly implement UAC2 this code adds a mixer quirk for the device.
    
    Changes from the original code include removing the metering code along with
    dead code and comments. Compiler warnings were fixed. The code to initialize
    the sampling rate was causing a crash this was fixed as discussed on the
    mailing list. Error, and info messages were convered to dev_err and dev_info
    interfaces. The custom scarlett_mixer_elem_info struct was replaced with the
    more generic usb_mixer_elem_info to be able to recycle more code from mixer.c.
    
    This patch also makes additional modifications based on upstream comments.
    Individual control creation functions are removed and a generic
    function is no used. Macros for function calls are removed to improve
    readability. Hardcoded control initialization is removed. Save to HW
    functionality has been removed. Strings for enums are created dynamically for
    the mixer. Strings used for controls are now SNDRV_CTL_ELEM_ID_NAME_MAXLEN
    length.
    
    Signed-off-by: Chris J Arges <chris.j.arges@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/mixer_scarlett.c b/sound/usb/mixer_scarlett.c
new file mode 100644
index 000000000000..a0a874507de5
--- /dev/null
+++ b/sound/usb/mixer_scarlett.c
@@ -0,0 +1,967 @@
+/*
+ *   Scarlett Driver for ALSA
+ *
+ *   Copyright (c) 2013 by Tobias Hoffmann
+ *   Copyright (c) 2013 by Robin Gareus <robin at gareus.org>
+ *   Copyright (c) 2002 by Takashi Iwai <tiwai at suse.de>
+ *   Copyright (c) 2014 by Chris J Arges <chris.j.arges at canonical.com>
+ *
+ *   Many codes borrowed from audio.c by
+ *	    Alan Cox (alan at lxorguk.ukuu.org.uk)
+ *	    Thomas Sailer (sailer at ife.ee.ethz.ch)
+ *
+ *   Code cleanup:
+ *   David Henningsson <david.henningsson at canonical.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ */
+
+/*
+ * Rewritten and extended to support more models, e.g. Scarlett 18i8.
+ *
+ * Auto-detection via UAC2 is not feasible to properly discover the vast
+ * majority of features. It's related to both Linux/ALSA's UAC2 as well as
+ * Focusrite's implementation of it. Eventually quirks may be sufficient but
+ * right now it's a major headache to work arount these things.
+ *
+ * NB. Neither the OSX nor the win driver provided by Focusrite performs
+ * discovery, they seem to operate the same as this driver.
+ */
+
+/* Mixer Interface for the Focusrite Scarlett 18i6 audio interface.
+ *
+ * The protocol was reverse engineered by looking at communication between
+ * Scarlett MixControl (v 1.2.128.0) and the Focusrite(R) Scarlett 18i6
+ * (firmware v305) using wireshark and usbmon in January 2013.
+ * Extended in July 2013.
+ *
+ * this mixer gives complete access to all features of the device:
+ *  - change Impedance of inputs (Line-in, Mic / Instrument, Hi-Z)
+ *  - select clock source
+ *  - dynamic input to mixer-matrix assignment
+ *  - 18 x 6 mixer-matrix gain stages
+ *  - bus routing & volume control
+ *  - automatic re-initialization on connect if device was power-cycled
+ *
+ * USB URB commands overview (bRequest = 0x01 = UAC2_CS_CUR)
+ * wIndex
+ * 0x01 Analog Input line/instrument impedance switch, wValue=0x0901 +
+ *      channel, data=Line/Inst (2bytes)
+ *      pad (-10dB) switch, wValue=0x0b01 + channel, data=Off/On (2bytes)
+ *      ?? wValue=0x0803/04, ?? (2bytes)
+ * 0x0a Master Volume, wValue=0x0200+bus[0:all + only 1..4?] data(2bytes)
+ *      Bus Mute/Unmute wValue=0x0100+bus[0:all + only 1..4?], data(2bytes)
+ * 0x28 Clock source, wValue=0x0100, data={1:int,2:spdif,3:adat} (1byte)
+ * 0x29 Set Sample-rate, wValue=0x0100, data=sample-rate(4bytes)
+ * 0x32 Mixer mux, wValue=0x0600 + mixer-channel, data=input-to-connect(2bytes)
+ * 0x33 Output mux, wValue=bus, data=input-to-connect(2bytes)
+ * 0x34 Capture mux, wValue=0...18, data=input-to-connect(2bytes)
+ * 0x3c Matrix Mixer gains, wValue=mixer-node  data=gain(2bytes)
+ *      ?? [sometimes](4bytes, e.g 0x000003be 0x000003bf ...03ff)
+ *
+ * USB reads: (i.e. actually issued by original software)
+ * 0x01 wValue=0x0901+channel (1byte!!), wValue=0x0b01+channed (1byte!!)
+ * 0x29 wValue=0x0100 sample-rate(4bytes)
+ *      wValue=0x0200 ?? 1byte (only once)
+ * 0x2a wValue=0x0100 ?? 4bytes, sample-rate2 ??
+ *
+ * USB reads with bRequest = 0x03 = UAC2_CS_MEM
+ * 0x3c wValue=0x0002 1byte: sync status (locked=1)
+ *      wValue=0x0000 18*2byte: peak meter (inputs)
+ *      wValue=0x0001 8(?)*2byte: peak meter (mix)
+ *      wValue=0x0003 6*2byte: peak meter (pcm/daw)
+ *
+ * USB write with bRequest = 0x03
+ * 0x3c Save settings to hardware: wValue=0x005a, data=0xa5
+ *
+ *
+ * <ditaa>
+ *  /--------------\    18chn            6chn    /--------------\
+ *  | Hardware  in +--+-------\        /------+--+ ALSA PCM out |
+ *  \--------------/  |       |        |      |  \--------------/
+ *                    |       |        |      |
+ *                    |       v        v      |
+ *                    |   +---------------+   |
+ *                    |    \ Matrix  Mux /    |
+ *                    |     +-----+-----+     |
+ *                    |           |           |
+ *                    |           | 18chn     |
+ *                    |           v           |
+ *                    |     +-----------+     |
+ *                    |     | Mixer     |     |
+ *                    |     |    Matrix |     |
+ *                    |     |           |     |
+ *                    |     | 18x6 Gain |     |
+ *                    |     |   stages  |     |
+ *                    |     +-----+-----+     |
+ *                    |           |           |
+ *                    |           |           |
+ *                    | 18chn     | 6chn      | 6chn
+ *                    v           v           v
+ *                    =========================
+ *             +---------------+     +--—------------+
+ *              \ Output  Mux /       \ Capture Mux /
+ *               +-----+-----+         +-----+-----+
+ *                     |                     |
+ *                     | 6chn                |
+ *                     v                     |
+ *              +-------------+              |
+ *              | Master Gain |              |
+ *              +------+------+              |
+ *                     |                     |
+ *                     | 6chn                | 18chn
+ *                     | (3 stereo pairs)    |
+ *  /--------------\   |                     |   /--------------\
+ *  | Hardware out |<--/                     \-->| ALSA PCM  in |
+ *  \--------------/                             \--------------/
+ * </ditaa>
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/usb.h>
+#include <linux/usb/audio-v2.h>
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/tlv.h>
+
+#include "usbaudio.h"
+#include "mixer.h"
+#include "helper.h"
+#include "power.h"
+
+#include "mixer_scarlett.h"
+
+/* some gui mixers can't handle negative ctl values */
+#define SND_SCARLETT_LEVEL_BIAS 128
+#define SND_SCARLETT_MATRIX_IN_MAX 18
+#define SND_SCARLETT_CONTROLS_MAX 10
+#define SND_SCARLETT_OFFSETS_MAX 5
+
+enum {
+	SCARLETT_OUTPUTS,
+	SCARLETT_SWITCH_IMPEDANCE,
+	SCARLETT_SWITCH_PAD,
+};
+
+enum {
+	SCARLETT_OFFSET_PCM = 0,
+	SCARLETT_OFFSET_ANALOG = 1,
+	SCARLETT_OFFSET_SPDIF = 2,
+	SCARLETT_OFFSET_ADAT = 3,
+	SCARLETT_OFFSET_MIX = 4,
+};
+
+struct scarlett_mixer_elem_enum_info {
+	int start;
+	int len;
+	int offsets[SND_SCARLETT_OFFSETS_MAX];
+	char const * const *names;
+};
+
+struct scarlett_mixer_control {
+	unsigned char num;
+	unsigned char type;
+	const char *name;
+};
+
+struct scarlett_device_info {
+	int matrix_in;
+	int matrix_out;
+	int input_len;
+	int output_len;
+
+	struct scarlett_mixer_elem_enum_info opt_master;
+	struct scarlett_mixer_elem_enum_info opt_matrix;
+
+	/* initial values for matrix mux */
+	int matrix_mux_init[SND_SCARLETT_MATRIX_IN_MAX];
+
+	int num_controls;	/* number of items in controls */
+	const struct scarlett_mixer_control controls[SND_SCARLETT_CONTROLS_MAX];
+};
+
+/********************** Enum Strings *************************/
+
+static const struct scarlett_mixer_elem_enum_info opt_pad = {
+	.start = 0,
+	.len = 2,
+	.offsets = {},
+	.names = (char const * const []){
+		"0dB", "-10dB"
+	}
+};
+
+static const struct scarlett_mixer_elem_enum_info opt_impedance = {
+	.start = 0,
+	.len = 2,
+	.offsets = {},
+	.names = (char const * const []){
+		"Line", "Hi-Z"
+	}
+};
+
+static const struct scarlett_mixer_elem_enum_info opt_clock = {
+	.start = 1,
+	.len = 3,
+	.offsets = {},
+	.names = (char const * const []){
+		"Internal", "SPDIF", "ADAT"
+	}
+};
+
+static const struct scarlett_mixer_elem_enum_info opt_sync = {
+	.start = 0,
+	.len = 2,
+	.offsets = {},
+	.names = (char const * const []){
+		"No Lock", "Locked"
+	}
+};
+
+static int scarlett_ctl_switch_info(struct snd_kcontrol *kctl,
+		struct snd_ctl_elem_info *uinfo)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = elem->channels;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int scarlett_ctl_switch_get(struct snd_kcontrol *kctl,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	int i, err, val;
+
+	for (i = 0; i < elem->channels; i++) {
+		err = snd_usb_get_cur_mix_value(elem, i, i, &val);
+		if (err < 0)
+			return err;
+
+		val = !val; /* invert mute logic for mixer */
+		ucontrol->value.integer.value[i] = val;
+	}
+
+	return 0;
+}
+
+static int scarlett_ctl_switch_put(struct snd_kcontrol *kctl,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	int i, changed = 0;
+	int err, oval, val;
+
+	for (i = 0; i < elem->channels; i++) {
+		err = snd_usb_get_cur_mix_value(elem, i, i, &oval);
+		if (err < 0)
+			return err;
+
+		val = ucontrol->value.integer.value[i];
+		val = !val;
+		if (oval != val) {
+			err = snd_usb_set_cur_mix_value(elem, i, i, val);
+			if (err < 0)
+				return err;
+
+			changed = 1;
+		}
+	}
+
+	return changed;
+}
+
+static int scarlett_ctl_info(struct snd_kcontrol *kctl,
+			     struct snd_ctl_elem_info *uinfo)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = elem->channels;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = (int)kctl->private_value +
+		SND_SCARLETT_LEVEL_BIAS;
+	uinfo->value.integer.step = 1;
+	return 0;
+}
+
+static int scarlett_ctl_get(struct snd_kcontrol *kctl,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	int i, err, val;
+
+	for (i = 0; i < elem->channels; i++) {
+		err = snd_usb_get_cur_mix_value(elem, i, i, &val);
+		if (err < 0)
+			return err;
+
+		val = clamp(val / 256, -128, (int)kctl->private_value) +
+				    SND_SCARLETT_LEVEL_BIAS;
+		ucontrol->value.integer.value[i] = val;
+	}
+
+	return 0;
+}
+
+static int scarlett_ctl_put(struct snd_kcontrol *kctl,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	int i, changed = 0;
+	int err, oval, val;
+
+	for (i = 0; i < elem->channels; i++) {
+		err = snd_usb_get_cur_mix_value(elem, i, i, &oval);
+		if (err < 0)
+			return err;
+
+		val = ucontrol->value.integer.value[i] -
+			SND_SCARLETT_LEVEL_BIAS;
+		val = val * 256;
+		if (oval != val) {
+			err = snd_usb_set_cur_mix_value(elem, i, i, val);
+			if (err < 0)
+				return err;
+
+			changed = 1;
+		}
+	}
+
+	return changed;
+}
+
+static void scarlett_generate_name(int i, char *dst, int offsets[])
+{
+	if (i > offsets[SCARLETT_OFFSET_MIX])
+		sprintf(dst, "Mix %c",
+			'A'+(i - offsets[SCARLETT_OFFSET_MIX] - 1));
+	else if (i > offsets[SCARLETT_OFFSET_ADAT])
+		sprintf(dst, "ADAT %d", i - offsets[SCARLETT_OFFSET_ADAT]);
+	else if (i > offsets[SCARLETT_OFFSET_SPDIF])
+		sprintf(dst, "SPDIF %d", i - offsets[SCARLETT_OFFSET_SPDIF]);
+	else if (i > offsets[SCARLETT_OFFSET_ANALOG])
+		sprintf(dst, "Analog %d", i - offsets[SCARLETT_OFFSET_ANALOG]);
+	else if (i > offsets[SCARLETT_OFFSET_PCM])
+		sprintf(dst, "PCM %d", i - offsets[SCARLETT_OFFSET_PCM]);
+	else
+		sprintf(dst, "Off");
+}
+
+static int scarlett_ctl_enum_dynamic_info(struct snd_kcontrol *kctl,
+					  struct snd_ctl_elem_info *uinfo)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct scarlett_mixer_elem_enum_info *opt = elem->private_data;
+	unsigned int items = opt->len;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = elem->channels;
+	uinfo->value.enumerated.items = items;
+
+	if (uinfo->value.enumerated.item >= items)
+		uinfo->value.enumerated.item = items - 1;
+
+	/* generate name dynamically based on item number and offset info */
+	scarlett_generate_name(uinfo->value.enumerated.item,
+			       uinfo->value.enumerated.name,
+			       opt->offsets);
+
+	return 0;
+}
+
+static int scarlett_ctl_enum_info(struct snd_kcontrol *kctl,
+				  struct snd_ctl_elem_info *uinfo)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct scarlett_mixer_elem_enum_info *opt = elem->private_data;
+
+	return snd_ctl_enum_info(uinfo, elem->channels, opt->len,
+				 (const char * const *)opt->names);
+}
+
+static int scarlett_ctl_enum_get(struct snd_kcontrol *kctl,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct scarlett_mixer_elem_enum_info *opt = elem->private_data;
+	int err, val;
+
+	err = snd_usb_get_cur_mix_value(elem, 0, 0, &val);
+	if (err < 0)
+		return err;
+
+	val = clamp(val - opt->start, 0, opt->len-1);
+
+	ucontrol->value.enumerated.item[0] = val;
+
+	return 0;
+}
+
+static int scarlett_ctl_enum_put(struct snd_kcontrol *kctl,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct scarlett_mixer_elem_enum_info *opt = elem->private_data;
+	int err, oval, val;
+
+	err = snd_usb_get_cur_mix_value(elem, 0, 0, &oval);
+	if (err < 0)
+		return err;
+
+	val = ucontrol->value.integer.value[0];
+	val = val + opt->start;
+	if (val != oval) {
+		snd_usb_set_cur_mix_value(elem, 0, 0, val);
+		return 1;
+	}
+	return 0;
+}
+
+static int scarlett_ctl_meter_get(struct snd_kcontrol *kctl,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+	struct snd_usb_audio *chip = elem->mixer->chip;
+	unsigned char buf[2 * MAX_CHANNELS] = {0, };
+	int wValue = (elem->control << 8) | elem->idx_off;
+	int idx = snd_usb_ctrl_intf(chip) | (elem->id << 8);
+	int err;
+
+	err = snd_usb_ctl_msg(chip->dev,
+				usb_rcvctrlpipe(chip->dev, 0),
+				UAC2_CS_MEM,
+				USB_RECIP_INTERFACE | USB_TYPE_CLASS |
+				USB_DIR_IN, wValue, idx, buf, elem->channels);
+	if (err < 0)
+		return err;
+
+	ucontrol->value.enumerated.item[0] = clamp((int)buf[0], 0, 1);
+	return 0;
+}
+
+static struct snd_kcontrol_new usb_scarlett_ctl_switch = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "",
+	.info = scarlett_ctl_switch_info,
+	.get =  scarlett_ctl_switch_get,
+	.put =  scarlett_ctl_switch_put,
+};
+
+static const DECLARE_TLV_DB_SCALE(db_scale_scarlett_gain, -12800, 100, 0);
+
+static struct snd_kcontrol_new usb_scarlett_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
+		  SNDRV_CTL_ELEM_ACCESS_TLV_READ,
+	.name = "",
+	.info = scarlett_ctl_info,
+	.get =  scarlett_ctl_get,
+	.put =  scarlett_ctl_put,
+	.private_value = 6,  /* max value */
+	.tlv = { .p = db_scale_scarlett_gain }
+};
+
+static struct snd_kcontrol_new usb_scarlett_ctl_master = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
+		  SNDRV_CTL_ELEM_ACCESS_TLV_READ,
+	.name = "",
+	.info = scarlett_ctl_info,
+	.get =  scarlett_ctl_get,
+	.put =  scarlett_ctl_put,
+	.private_value = 6,  /* max value */
+	.tlv = { .p = db_scale_scarlett_gain }
+};
+
+static struct snd_kcontrol_new usb_scarlett_ctl_enum = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "",
+	.info = scarlett_ctl_enum_info,
+	.get =  scarlett_ctl_enum_get,
+	.put =  scarlett_ctl_enum_put,
+};
+
+static struct snd_kcontrol_new usb_scarlett_ctl_dynamic_enum = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "",
+	.info = scarlett_ctl_enum_dynamic_info,
+	.get =  scarlett_ctl_enum_get,
+	.put =  scarlett_ctl_enum_put,
+};
+
+static struct snd_kcontrol_new usb_scarlett_ctl_sync = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.name = "",
+	.info = scarlett_ctl_enum_info,
+	.get =  scarlett_ctl_meter_get,
+};
+
+static int add_new_ctl(struct usb_mixer_interface *mixer,
+		       const struct snd_kcontrol_new *ncontrol,
+		       int index, int offset, int num,
+		       int val_type, int channels, const char *name,
+		       const struct scarlett_mixer_elem_enum_info *opt,
+		       struct usb_mixer_elem_info **elem_ret
+)
+{
+	struct snd_kcontrol *kctl;
+	struct usb_mixer_elem_info *elem;
+	int err;
+
+	elem = kzalloc(sizeof(*elem), GFP_KERNEL);
+	if (!elem)
+		return -ENOMEM;
+
+	elem->mixer = mixer;
+	elem->control = offset;
+	elem->idx_off = num;
+	elem->id = index;
+	elem->val_type = val_type;
+
+	elem->channels = channels;
+
+	/* add scarlett_mixer_elem_enum_info struct */
+	elem->private_data = (void *)opt;
+
+	kctl = snd_ctl_new1(ncontrol, elem);
+	if (!kctl) {
+		kfree(elem);
+		return -ENOMEM;
+	}
+	kctl->private_free = snd_usb_mixer_elem_free;
+
+	strlcpy(kctl->id.name, name, sizeof(kctl->id.name));
+
+	err = snd_ctl_add(mixer->chip->card, kctl);
+	if (err < 0)
+		return err;
+
+	if (elem_ret)
+		*elem_ret = elem;
+
+	return 0;
+}
+
+static int add_output_ctls(struct usb_mixer_interface *mixer,
+			   int index, const char *name,
+			   const struct scarlett_device_info *info)
+{
+	int err;
+	char mx[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
+	struct usb_mixer_elem_info *elem;
+
+	/* Add mute switch */
+	snprintf(mx, sizeof(mx), "Master %d (%s) Playback Switch",
+		index + 1, name);
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_switch, 0x0a, 0x01,
+			  2*index+1, USB_MIXER_S16, 2, mx, NULL, &elem);
+	if (err < 0)
+		return err;
+
+	/* Add volume control and initialize to 0 */
+	snprintf(mx, sizeof(mx), "Master %d (%s) Playback Volume",
+		index + 1, name);
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_master, 0x0a, 0x02,
+			  2*index+1, USB_MIXER_S16, 2, mx, NULL, &elem);
+	if (err < 0)
+		return err;
+
+	/* Add L channel source playback enumeration */
+	snprintf(mx, sizeof(mx), "Master %dL (%s) Source Playback Enum",
+		index + 1, name);
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum, 0x33, 0x00,
+			  2*index, USB_MIXER_S16, 1, mx, &info->opt_master,
+			  &elem);
+	if (err < 0)
+		return err;
+
+	/* Add R channel source playback enumeration */
+	snprintf(mx, sizeof(mx), "Master %dR (%s) Source Playback Enum",
+		index + 1, name);
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum, 0x33, 0x00,
+			  2*index+1, USB_MIXER_S16, 1, mx, &info->opt_master,
+			  &elem);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/********************** device-specific config *************************/
+
+/*  untested...  */
+static struct scarlett_device_info s6i6_info = {
+	.matrix_in = 18,
+	.matrix_out = 8,
+	.input_len = 6,
+	.output_len = 6,
+
+	.opt_master = {
+		.start = -1,
+		.len = 27,
+		.offsets = {0, 12, 16, 18, 18},
+		.names = NULL
+	},
+
+	.opt_matrix = {
+		.start = -1,
+		.len = 19,
+		.offsets = {0, 12, 16, 18, 18},
+		.names = NULL
+	},
+
+	.num_controls = 0,
+	.controls = {
+		{ .num = 0, .type = SCARLETT_OUTPUTS, .name = "Monitor" },
+		{ .num = 1, .type = SCARLETT_OUTPUTS, .name = "Headphone" },
+		{ .num = 2, .type = SCARLETT_OUTPUTS, .name = "SPDIF" },
+		{ .num = 1, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},
+		{ .num = 1, .type = SCARLETT_SWITCH_PAD, .name = NULL},
+		{ .num = 2, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},
+		{ .num = 2, .type = SCARLETT_SWITCH_PAD, .name = NULL},
+		{ .num = 3, .type = SCARLETT_SWITCH_PAD, .name = NULL},
+		{ .num = 4, .type = SCARLETT_SWITCH_PAD, .name = NULL},
+	},
+
+	.matrix_mux_init = {
+		12, 13, 14, 15,                 /* Analog -> 1..4 */
+		16, 17,                          /* SPDIF -> 5,6 */
+		0, 1, 2, 3, 4, 5, 6, 7,     /* PCM[1..12] -> 7..18 */
+		8, 9, 10, 11
+	}
+};
+
+/*  untested...  */
+static struct scarlett_device_info s8i6_info = {
+	.matrix_in = 18,
+	.matrix_out = 6,
+	.input_len = 8,
+	.output_len = 6,
+
+	.opt_master = {
+		.start = -1,
+		.len = 25,
+		.offsets = {0, 12, 16, 18, 18},
+		.names = NULL
+	},
+
+	.opt_matrix = {
+		.start = -1,
+		.len = 19,
+		.offsets = {0, 12, 16, 18, 18},
+		.names = NULL
+	},
+
+	.num_controls = 7,
+	.controls = {
+		{ .num = 0, .type = SCARLETT_OUTPUTS, .name = "Monitor" },
+		{ .num = 1, .type = SCARLETT_OUTPUTS, .name = "Headphone" },
+		{ .num = 2, .type = SCARLETT_OUTPUTS, .name = "SPDIF" },
+		{ .num = 1, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},
+		{ .num = 2, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},
+		{ .num = 3, .type = SCARLETT_SWITCH_PAD, .name = NULL},
+		{ .num = 4, .type = SCARLETT_SWITCH_PAD, .name = NULL},
+	},
+
+	.matrix_mux_init = {
+		12, 13, 14, 15,                 /* Analog -> 1..4 */
+		16, 17,                          /* SPDIF -> 5,6 */
+		0, 1, 2, 3, 4, 5, 6, 7,     /* PCM[1..12] -> 7..18 */
+		8, 9, 10, 11
+	}
+};
+
+static struct scarlett_device_info s18i6_info = {
+	.matrix_in = 18,
+	.matrix_out = 6,
+	.input_len = 18,
+	.output_len = 6,
+
+	.opt_master = {
+		.start = -1,
+		.len = 31,
+		.offsets = {0, 6, 14, 16, 24},
+		.names = NULL,
+	},
+
+	.opt_matrix = {
+		.start = -1,
+		.len = 25,
+		.offsets = {0, 6, 14, 16, 24},
+		.names = NULL,
+	},
+
+	.num_controls = 5,
+	.controls = {
+		{ .num = 0, .type = SCARLETT_OUTPUTS, .name = "Monitor" },
+		{ .num = 1, .type = SCARLETT_OUTPUTS, .name = "Headphone" },
+		{ .num = 2, .type = SCARLETT_OUTPUTS, .name = "SPDIF" },
+		{ .num = 1, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},
+		{ .num = 2, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},
+	},
+
+	.matrix_mux_init = {
+		 6,  7,  8,  9, 10, 11, 12, 13, /* Analog -> 1..8 */
+		16, 17, 18, 19, 20, 21,     /* ADAT[1..6] -> 9..14 */
+		14, 15,                          /* SPDIF -> 15,16 */
+		0, 1                          /* PCM[1,2] -> 17,18 */
+	}
+};
+
+static struct scarlett_device_info s18i8_info = {
+	.matrix_in = 18,
+	.matrix_out = 8,
+	.input_len = 18,
+	.output_len = 8,
+
+	.opt_master = {
+		.start = -1,
+		.len = 35,
+		.offsets = {0, 8, 16, 18, 26},
+		.names = NULL
+	},
+
+	.opt_matrix = {
+		.start = -1,
+		.len = 27,
+		.offsets = {0, 8, 16, 18, 26},
+		.names = NULL
+	},
+
+	.num_controls = 10,
+	.controls = {
+		{ .num = 0, .type = SCARLETT_OUTPUTS, .name = "Monitor" },
+		{ .num = 1, .type = SCARLETT_OUTPUTS, .name = "Headphone 1" },
+		{ .num = 2, .type = SCARLETT_OUTPUTS, .name = "Headphone 2" },
+		{ .num = 3, .type = SCARLETT_OUTPUTS, .name = "SPDIF" },
+		{ .num = 1, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},
+		{ .num = 1, .type = SCARLETT_SWITCH_PAD, .name = NULL},
+		{ .num = 2, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},
+		{ .num = 2, .type = SCARLETT_SWITCH_PAD, .name = NULL},
+		{ .num = 3, .type = SCARLETT_SWITCH_PAD, .name = NULL},
+		{ .num = 4, .type = SCARLETT_SWITCH_PAD, .name = NULL},
+	},
+
+	.matrix_mux_init = {
+		 8,  9, 10, 11, 12, 13, 14, 15, /* Analog -> 1..8 */
+		18, 19, 20, 21, 22, 23,     /* ADAT[1..6] -> 9..14 */
+		16, 17,                          /* SPDIF -> 15,16 */
+		0, 1                          /* PCM[1,2] -> 17,18 */
+	}
+};
+
+static struct scarlett_device_info s18i20_info = {
+	.matrix_in = 18,
+	.matrix_out = 8,
+	.input_len = 18,
+	.output_len = 20,
+
+	.opt_master = {
+		.start = -1,
+		.len = 47,
+		.offsets = {0, 20, 28, 30, 38},
+		.names = NULL
+	},
+
+	.opt_matrix = {
+		.start = -1,
+		.len = 39,
+		.offsets = {0, 20, 28, 30, 38},
+		.names = NULL
+	},
+
+	.num_controls = 10,
+	.controls = {
+		{ .num = 0, .type = SCARLETT_OUTPUTS, .name = "Monitor" },
+		{ .num = 1, .type = SCARLETT_OUTPUTS, .name = "Line 3/4" },
+		{ .num = 2, .type = SCARLETT_OUTPUTS, .name = "Line 5/6" },
+		{ .num = 3, .type = SCARLETT_OUTPUTS, .name = "Line 7/8" },
+		{ .num = 4, .type = SCARLETT_OUTPUTS, .name = "Line 9/10" },
+		{ .num = 5, .type = SCARLETT_OUTPUTS, .name = "SPDIF" },
+		{ .num = 6, .type = SCARLETT_OUTPUTS, .name = "ADAT 1/2" },
+		{ .num = 7, .type = SCARLETT_OUTPUTS, .name = "ADAT 3/4" },
+		{ .num = 8, .type = SCARLETT_OUTPUTS, .name = "ADAT 5/6" },
+		{ .num = 9, .type = SCARLETT_OUTPUTS, .name = "ADAT 7/8" },
+		/*{ .num = 1, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},
+		{ .num = 1, .type = SCARLETT_SWITCH_PAD, .name = NULL},
+		{ .num = 2, .type = SCARLETT_SWITCH_IMPEDANCE, .name = NULL},
+		{ .num = 2, .type = SCARLETT_SWITCH_PAD, .name = NULL},
+		{ .num = 3, .type = SCARLETT_SWITCH_PAD, .name = NULL},
+		{ .num = 4, .type = SCARLETT_SWITCH_PAD, .name = NULL},*/
+	},
+
+	.matrix_mux_init = {
+		20, 21, 22, 23, 24, 25, 26, 27, /* Analog -> 1..8 */
+		30, 31, 32, 33, 34, 35,     /* ADAT[1..6] -> 9..14 */
+		28, 29,                          /* SPDIF -> 15,16 */
+		0, 1                          /* PCM[1,2] -> 17,18 */
+	}
+};
+
+
+static int scarlett_controls_create_generic(struct usb_mixer_interface *mixer,
+	struct scarlett_device_info *info)
+{
+	int i, err;
+	char mx[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
+	const struct scarlett_mixer_control *ctl;
+	struct usb_mixer_elem_info *elem;
+
+	/* create master switch and playback volume */
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_switch, 0x0a, 0x01, 0,
+			  USB_MIXER_S16, 1, "Master Playback Switch", NULL,
+			  &elem);
+	if (err < 0)
+		return err;
+
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_master, 0x0a, 0x02, 0,
+			  USB_MIXER_S16, 1, "Master Playback Volume", NULL,
+			  &elem);
+	if (err < 0)
+		return err;
+
+	/* iterate through controls in info struct and create each one */
+	for (i = 0; i < info->num_controls; i++) {
+		ctl = &info->controls[i];
+
+		switch (ctl->type) {
+		case SCARLETT_OUTPUTS:
+			err = add_output_ctls(mixer, ctl->num, ctl->name, info);
+			if (err < 0)
+				return err;
+			break;
+		case SCARLETT_SWITCH_IMPEDANCE:
+			sprintf(mx, "Input %d Impedance Switch", ctl->num);
+			err = add_new_ctl(mixer, &usb_scarlett_ctl_enum, 0x01,
+					  0x09, ctl->num, USB_MIXER_S16, 1, mx,
+					  &opt_impedance, &elem);
+			if (err < 0)
+				return err;
+			break;
+		case SCARLETT_SWITCH_PAD:
+			sprintf(mx, "Input %d Pad Switch", ctl->num);
+			err = add_new_ctl(mixer, &usb_scarlett_ctl_enum, 0x01,
+					  0x0b, ctl->num, USB_MIXER_S16, 1, mx,
+					  &opt_pad, &elem);
+			if (err < 0)
+				return err;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Create and initialize a mixer for the Focusrite(R) Scarlett
+ */
+int snd_scarlett_controls_create(struct usb_mixer_interface *mixer)
+{
+	int err, i, o;
+	char mx[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
+	struct scarlett_device_info *info;
+	struct usb_mixer_elem_info *elem;
+	static char sample_rate_buffer[4] = { '\x80', '\xbb', '\x00', '\x00' };
+
+	/* only use UAC_VERSION_2 */
+	if (!mixer->protocol)
+		return 0;
+
+	switch (mixer->chip->usb_id) {
+	case USB_ID(0x1235, 0x8012):
+		info = &s6i6_info;
+		break;
+	case USB_ID(0x1235, 0x8002):
+		info = &s8i6_info;
+		break;
+	case USB_ID(0x1235, 0x8004):
+		info = &s18i6_info;
+		break;
+	case USB_ID(0x1235, 0x8014):
+		info = &s18i8_info;
+		break;
+	case USB_ID(0x1235, 0x800c):
+		info = &s18i20_info;
+		break;
+	default: /* device not (yet) supported */
+		return -EINVAL;
+	}
+
+	/* generic function to create controls */
+	err = scarlett_controls_create_generic(mixer, info);
+	if (err < 0)
+		return err;
+
+	/* setup matrix controls */
+	for (i = 0; i < info->matrix_in; i++) {
+		snprintf(mx, sizeof(mx), "Matrix %02d Input Playback Route",
+			 i+1);
+		err = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum, 0x32,
+				  0x06, i, USB_MIXER_S16, 1, mx,
+				  &info->opt_matrix, &elem);
+		if (err < 0)
+			return err;
+
+		for (o = 0; o < info->matrix_out; o++) {
+			sprintf(mx, "Matrix %02d Mix %c Playback Volume", i+1,
+				o+'A');
+			err = add_new_ctl(mixer, &usb_scarlett_ctl, 0x3c, 0x00,
+					  (i << 3) + (o & 0x07), USB_MIXER_S16,
+					  1, mx, NULL, &elem);
+			if (err < 0)
+				return err;
+
+		}
+	}
+
+	for (i = 0; i < info->input_len; i++) {
+		snprintf(mx, sizeof(mx), "Input Source %02d Capture Route",
+			 i+1);
+		err = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum, 0x34,
+				  0x00, i, USB_MIXER_S16, 1, mx,
+				  &info->opt_master, &elem);
+		if (err < 0)
+			return err;
+	}
+
+	/* val_len == 1 needed here */
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_enum, 0x28, 0x01, 0,
+			  USB_MIXER_U8, 1, "Sample Clock Source",
+			  &opt_clock, &elem);
+	if (err < 0)
+		return err;
+
+	/* val_len == 1 and UAC2_CS_MEM */
+	err = add_new_ctl(mixer, &usb_scarlett_ctl_sync, 0x3c, 0x00, 2,
+			  USB_MIXER_U8, 1, "Sample Clock Sync Status",
+			  &opt_sync, &elem);
+	if (err < 0)
+		return err;
+
+	/* initialize sampling rate to 48000 */
+	err = snd_usb_ctl_msg(mixer->chip->dev,
+		usb_sndctrlpipe(mixer->chip->dev, 0), UAC2_CS_CUR,
+		USB_RECIP_INTERFACE | USB_TYPE_CLASS |
+		USB_DIR_OUT, 0x0100, snd_usb_ctrl_intf(mixer->chip) |
+		(0x29 << 8), sample_rate_buffer, 4);
+	if (err < 0)
+		return err;
+
+	return err;
+}
