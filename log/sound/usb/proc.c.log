commit 8137d2763bf77d68babb38a7323c5152c945f20e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Apr 22 12:22:55 2020 +0300

    ALSA: usb-audio: Fix a limit check in proc_dump_substream_formats()
    
    This should be ARRAY_SIZE() instead of sizeof().  The sizeof() limit is
    too high so it doesn't work.
    
    Fixes: 093b8494f299 ("ALSA: usb-audio: Print more information in stream proc files")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Link: https://lore.kernel.org/r/20200422092255.GB195357@mwanda
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index 5a36e192ebb0..889c550c9f29 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -140,7 +140,7 @@ static void proc_dump_substream_formats(struct snd_usb_substream *subs, struct s
 
 			snd_iprintf(buffer, "    Channel map:");
 			for (c = 0; c < map->channels; c++) {
-				if (map->map[c] >= sizeof(channel_labels) ||
+				if (map->map[c] >= ARRAY_SIZE(channel_labels) ||
 				    !channel_labels[map->map[c]])
 					snd_iprintf(buffer, " --");
 				else

commit 093b8494f2992e58c2bef6fc26c7e11464ad415a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Apr 19 23:21:34 2020 +0200

    ALSA: usb-audio: Print more information in stream proc files
    
    For more debug and usability information, add the entry showing the
    DSD raw states and the channel mapping in each stream proc file.
    
    Link: https://lore.kernel.org/r/20200419212134.14200-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index 4174ad11fca6..5a36e192ebb0 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -54,6 +54,38 @@ void snd_usb_audio_create_proc(struct snd_usb_audio *chip)
 			     proc_audio_usbid_read);
 }
 
+static const char * const channel_labels[] = {
+	[SNDRV_CHMAP_NA]	= "N/A",
+	[SNDRV_CHMAP_MONO]	= "MONO",
+	[SNDRV_CHMAP_FL]	= "FL",
+	[SNDRV_CHMAP_FR]	= "FR",
+	[SNDRV_CHMAP_FC]	= "FC",
+	[SNDRV_CHMAP_LFE]	= "LFE",
+	[SNDRV_CHMAP_RL]	= "RL",
+	[SNDRV_CHMAP_RR]	= "RR",
+	[SNDRV_CHMAP_FLC]	= "FLC",
+	[SNDRV_CHMAP_FRC]	= "FRC",
+	[SNDRV_CHMAP_RC]	= "RC",
+	[SNDRV_CHMAP_SL]	= "SL",
+	[SNDRV_CHMAP_SR]	= "SR",
+	[SNDRV_CHMAP_TC]	= "TC",
+	[SNDRV_CHMAP_TFL]	= "TFL",
+	[SNDRV_CHMAP_TFC]	= "TFC",
+	[SNDRV_CHMAP_TFR]	= "TFR",
+	[SNDRV_CHMAP_TRL]	= "TRL",
+	[SNDRV_CHMAP_TRC]	= "TRC",
+	[SNDRV_CHMAP_TRR]	= "TRR",
+	[SNDRV_CHMAP_TFLC]	= "TFLC",
+	[SNDRV_CHMAP_TFRC]	= "TFRC",
+	[SNDRV_CHMAP_LLFE]	= "LLFE",
+	[SNDRV_CHMAP_RLFE]	= "RLFE",
+	[SNDRV_CHMAP_TSL]	= "TSL",
+	[SNDRV_CHMAP_TSR]	= "TSR",
+	[SNDRV_CHMAP_BC]	= "BC",
+	[SNDRV_CHMAP_RLC]	= "RLC",
+	[SNDRV_CHMAP_RRC]	= "RRC",
+};
+
 /*
  * proc interface for list the supported pcm formats
  */
@@ -97,6 +129,27 @@ static void proc_dump_substream_formats(struct snd_usb_substream *subs, struct s
 			snd_iprintf(buffer, "    Data packet interval: %d us\n",
 				    125 * (1 << fp->datainterval));
 		snd_iprintf(buffer, "    Bits: %d\n", fp->fmt_bits);
+
+		if (fp->dsd_raw)
+			snd_iprintf(buffer, "    DSD raw: DOP=%d, bitrev=%d\n",
+				    fp->dsd_dop, fp->dsd_bitrev);
+
+		if (fp->chmap) {
+			const struct snd_pcm_chmap_elem *map = fp->chmap;
+			int c;
+
+			snd_iprintf(buffer, "    Channel map:");
+			for (c = 0; c < map->channels; c++) {
+				if (map->map[c] >= sizeof(channel_labels) ||
+				    !channel_labels[map->map[c]])
+					snd_iprintf(buffer, " --");
+				else
+					snd_iprintf(buffer, " %s",
+						    channel_labels[map->map[c]]);
+			}
+			snd_iprintf(buffer, "\n");
+		}
+
 		// snd_iprintf(buffer, "    Max Packet Size = %d\n", fp->maxpacksize);
 		// snd_iprintf(buffer, "    EP Attribute = %#x\n", fp->attributes);
 	}

commit 5b29f05396bde54788a18633155ffa3f4d745f0d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 6 17:39:40 2020 +0100

    ALSA: usb-audio: Use pcm_for_each_format() macro for PCM format iterations
    
    The new macro can fix the sparse warnings gracefully:
      sound/usb/proc.c:73:31: warning: restricted snd_pcm_format_t degrades to integer
      sound/usb/proc.c:73:38: warning: restricted snd_pcm_format_t degrades to integer
      sound/usb/proc.c:73:61: warning: restricted snd_pcm_format_t degrades to integer
    
    No functional changes, just sparse warning fixes.
    
    Link: https://lore.kernel.org/r/20200206163945.6797-4-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index ffbf4bd9208c..4174ad11fca6 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -70,7 +70,7 @@ static void proc_dump_substream_formats(struct snd_usb_substream *subs, struct s
 		snd_iprintf(buffer, "  Interface %d\n", fp->iface);
 		snd_iprintf(buffer, "    Altset %d\n", fp->altsetting);
 		snd_iprintf(buffer, "    Format:");
-		for (fmt = 0; fmt <= SNDRV_PCM_FORMAT_LAST; ++fmt)
+		pcm_for_each_format(fmt)
 			if (fp->formats & pcm_format_to_bits(fmt))
 				snd_iprintf(buffer, " %s",
 					    snd_pcm_format_name(fmt));

commit a01df925d1bbc97d6f7fe07b157aadb565315337
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:26 2020 +0100

    ALSA: usb-audio: More constifications
    
    Apply const prefix to the remaining places: the static table for the
    unit information, the mixer maps, the validator tables, etc.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-12-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index 49e3f176aaf5..ffbf4bd9208c 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -60,7 +60,7 @@ void snd_usb_audio_create_proc(struct snd_usb_audio *chip)
 static void proc_dump_substream_formats(struct snd_usb_substream *subs, struct snd_info_buffer *buffer)
 {
 	struct audioformat *fp;
-	static char *sync_types[4] = {
+	static const char * const sync_types[4] = {
 		"NONE", "ASYNC", "ADAPTIVE", "SYNC"
 	};
 

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index ef9190530fd2..49e3f176aaf5 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -1,18 +1,5 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/init.h>

commit c7a13264918b9796f80c634f20fea56e1612572d
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Mon Feb 18 00:17:21 2019 +0200

    ALSA: usb-audio: Expose sample resolution through proc interface
    
    At least some USB devices use (MSB-aligned) audio format larger
    than the actual resolution of the device. In order to expose the
    actual device resolution (bBitResolution), add extra field to the
    procfs stream info interface.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index e80c9d0749c9..ef9190530fd2 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -109,6 +109,7 @@ static void proc_dump_substream_formats(struct snd_usb_substream *subs, struct s
 		if (subs->speed != USB_SPEED_FULL)
 			snd_iprintf(buffer, "    Data packet interval: %d us\n",
 				    125 * (1 << fp->datainterval));
+		snd_iprintf(buffer, "    Bits: %d\n", fp->fmt_bits);
 		// snd_iprintf(buffer, "    Max Packet Size = %d\n", fp->maxpacksize);
 		// snd_iprintf(buffer, "    EP Attribute = %#x\n", fp->attributes);
 	}

commit 7449054af0dcfa2839bb2da0a393bd35cf08daff
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:07:35 2019 +0100

    ALSA: usb: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index 0ac89e294d31..e80c9d0749c9 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -61,11 +61,10 @@ static void proc_audio_usbid_read(struct snd_info_entry *entry, struct snd_info_
 
 void snd_usb_audio_create_proc(struct snd_usb_audio *chip)
 {
-	struct snd_info_entry *entry;
-	if (!snd_card_proc_new(chip->card, "usbbus", &entry))
-		snd_info_set_text_ops(entry, chip, proc_audio_usbbus_read);
-	if (!snd_card_proc_new(chip->card, "usbid", &entry))
-		snd_info_set_text_ops(entry, chip, proc_audio_usbid_read);
+	snd_card_ro_proc_new(chip->card, "usbbus", chip,
+			     proc_audio_usbbus_read);
+	snd_card_ro_proc_new(chip->card, "usbid", chip,
+			     proc_audio_usbid_read);
 }
 
 /*
@@ -167,12 +166,10 @@ static void proc_pcm_format_read(struct snd_info_entry *entry, struct snd_info_b
 
 void snd_usb_proc_pcm_format_add(struct snd_usb_stream *stream)
 {
-	struct snd_info_entry *entry;
 	char name[32];
 	struct snd_card *card = stream->chip->card;
 
 	sprintf(name, "stream%d", stream->pcm_index);
-	if (!snd_card_proc_new(card, name, &entry))
-		snd_info_set_text_ops(entry, stream, proc_pcm_format_read);
+	snd_card_ro_proc_new(card, name, stream, proc_pcm_format_read);
 }
 

commit 47ab154593827b1a8f0713a2b9dd445753d551d8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 25 16:09:00 2015 +0200

    ALSA: usb-audio: Avoid nested autoresume calls
    
    After the recent fix of runtime PM for USB-audio driver, we got a
    lockdep warning like:
    
      =============================================
      [ INFO: possible recursive locking detected ]
      4.2.0-rc8+ #61 Not tainted
      ---------------------------------------------
      pulseaudio/980 is trying to acquire lock:
       (&chip->shutdown_rwsem){.+.+.+}, at: [<ffffffffa0355dac>] snd_usb_autoresume+0x1d/0x52 [snd_usb_audio]
      but task is already holding lock:
       (&chip->shutdown_rwsem){.+.+.+}, at: [<ffffffffa0355dac>] snd_usb_autoresume+0x1d/0x52 [snd_usb_audio]
    
    This comes from snd_usb_autoresume() invoking down_read() and it's
    used in a nested way.  Although it's basically safe, per se (as these
    are read locks), it's better to reduce such spurious warnings.
    
    The read lock is needed to guarantee the execution of "shutdown"
    (cleanup at disconnection) task after all concurrent tasks are
    finished.  This can be implemented in another better way.
    
    Also, the current check of chip->in_pm isn't good enough for
    protecting the racy execution of multiple auto-resumes.
    
    This patch rewrites the logic of snd_usb_autoresume() & co; namely,
    - The recursive call of autopm is avoided by the new refcount,
      chip->active.  The chip->in_pm flag is removed accordingly.
    - Instead of rwsem, another refcount, chip->usage_count, is introduced
      for tracking the period to delay the shutdown procedure.  At
      the last clear of this refcount, wake_up() to the shutdown waiter is
      called.
    - The shutdown flag is replaced with shutdown atomic count; this is
      for reducing the lock.
    - Two new helpers are introduced to simplify the management of these
      refcounts; snd_usb_lock_shutdown() increases the usage_count, checks
      the shutdown state, and does autoresume.  snd_usb_unlock_shutdown()
      does the opposite.  Most of mixer and other codes just need this,
      and simply returns an error if it receives an error from lock.
    
    Fixes: 9003ebb13f61 ('ALSA: usb-audio: Fix runtime PM unbalance')
    Reported-and-tested-by: Alexnader Kuleshov <kuleshovmail@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index 5f761ab34c01..0ac89e294d31 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -46,14 +46,14 @@ static inline unsigned get_high_speed_hz(unsigned int usb_rate)
 static void proc_audio_usbbus_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
 	struct snd_usb_audio *chip = entry->private_data;
-	if (!chip->shutdown)
+	if (!atomic_read(&chip->shutdown))
 		snd_iprintf(buffer, "%03d/%03d\n", chip->dev->bus->busnum, chip->dev->devnum);
 }
 
 static void proc_audio_usbid_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
 	struct snd_usb_audio *chip = entry->private_data;
-	if (!chip->shutdown)
+	if (!atomic_read(&chip->shutdown))
 		snd_iprintf(buffer, "%04x:%04x\n", 
 			    USB_ID_VENDOR(chip->usb_id),
 			    USB_ID_PRODUCT(chip->usb_id));

commit e6135fe960bba1d1a3a6b6818839e6d8d3f21293
Author: Torstein Hegge <hegge@resisty.net>
Date:   Thu May 16 20:26:17 2013 +0200

    ALSA: usb-audio: proc: use found syncmaxsize to determine feedback format
    
    freqshift is only set for the data endpoint and syncmaxsize is only set
    for the sync endpoint. This results in a syncmaxsize of zero used in the
    proc output feedback format calculation, which gives a feedback format
    incorrectly shown as 8.16 for UAC2 devices.
    
    As neither the data nor the sync endpoint gives all the relevant
    content, output the two combined.
    
    Also remove the sync_endpoint "packet size" which is always zero
    and the sync_endpoint "momentary freq" which is constant.
    
    Tested with UAC2 async and UAC1 adaptive, not tested with UAC1 async.
    
    Reported-by: B. Zhang <bb.zhang@free.fr>
    Signed-off-by: Torstein Hegge <hegge@resisty.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index 135c76871063..5f761ab34c01 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -116,21 +116,22 @@ static void proc_dump_substream_formats(struct snd_usb_substream *subs, struct s
 }
 
 static void proc_dump_ep_status(struct snd_usb_substream *subs,
-				struct snd_usb_endpoint *ep,
+				struct snd_usb_endpoint *data_ep,
+				struct snd_usb_endpoint *sync_ep,
 				struct snd_info_buffer *buffer)
 {
-	if (!ep)
+	if (!data_ep)
 		return;
-	snd_iprintf(buffer, "    Packet Size = %d\n", ep->curpacksize);
+	snd_iprintf(buffer, "    Packet Size = %d\n", data_ep->curpacksize);
 	snd_iprintf(buffer, "    Momentary freq = %u Hz (%#x.%04x)\n",
 		    subs->speed == USB_SPEED_FULL
-		    ? get_full_speed_hz(ep->freqm)
-		    : get_high_speed_hz(ep->freqm),
-		    ep->freqm >> 16, ep->freqm & 0xffff);
-	if (ep->freqshift != INT_MIN) {
-		int res = 16 - ep->freqshift;
+		    ? get_full_speed_hz(data_ep->freqm)
+		    : get_high_speed_hz(data_ep->freqm),
+		    data_ep->freqm >> 16, data_ep->freqm & 0xffff);
+	if (sync_ep && data_ep->freqshift != INT_MIN) {
+		int res = 16 - data_ep->freqshift;
 		snd_iprintf(buffer, "    Feedback Format = %d.%d\n",
-			    (ep->syncmaxsize > 3 ? 32 : 24) - res, res);
+			    (sync_ep->syncmaxsize > 3 ? 32 : 24) - res, res);
 	}
 }
 
@@ -140,8 +141,7 @@ static void proc_dump_substream_status(struct snd_usb_substream *subs, struct sn
 		snd_iprintf(buffer, "  Status: Running\n");
 		snd_iprintf(buffer, "    Interface = %d\n", subs->interface);
 		snd_iprintf(buffer, "    Altset = %d\n", subs->altset_idx);
-		proc_dump_ep_status(subs, subs->data_endpoint, buffer);
-		proc_dump_ep_status(subs, subs->sync_endpoint, buffer);
+		proc_dump_ep_status(subs, subs->data_endpoint, subs->sync_endpoint, buffer);
 	} else {
 		snd_iprintf(buffer, "  Status: Stop\n");
 	}

commit 74c34ca1cc12884703c70d34ed333517d978c2e7
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Tue Apr 23 01:00:41 2013 +0200

    ALSA: pcm_format_to_bits strong-typed conversion
    
    Add a function to handle conversion from snd_pcm_format_t
    to bitwise with proper typing.
    
    Change such conversions to use this function and silence sparse
    warnings.
    
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index 0182ef634d8b..135c76871063 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -85,7 +85,7 @@ static void proc_dump_substream_formats(struct snd_usb_substream *subs, struct s
 		snd_iprintf(buffer, "    Altset %d\n", fp->altsetting);
 		snd_iprintf(buffer, "    Format:");
 		for (fmt = 0; fmt <= SNDRV_PCM_FORMAT_LAST; ++fmt)
-			if (fp->formats & (1uLL << fmt))
+			if (fp->formats & pcm_format_to_bits(fmt))
 				snd_iprintf(buffer, " %s",
 					    snd_pcm_format_name(fmt));
 		snd_iprintf(buffer, "\n");

commit 88766f04c4142c0a388a1de354616c3deafba513
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Wed Apr 3 23:18:49 2013 +0200

    ALSA: usb-audio: convert list_for_each to entry variant
    
    Change occurances of list_for_each into list_for_each_entry where
    applicable.
    
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index d218f763501f..0182ef634d8b 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -73,15 +73,14 @@ void snd_usb_audio_create_proc(struct snd_usb_audio *chip)
  */
 static void proc_dump_substream_formats(struct snd_usb_substream *subs, struct snd_info_buffer *buffer)
 {
-	struct list_head *p;
+	struct audioformat *fp;
 	static char *sync_types[4] = {
 		"NONE", "ASYNC", "ADAPTIVE", "SYNC"
 	};
 
-	list_for_each(p, &subs->fmt_list) {
-		struct audioformat *fp;
+	list_for_each_entry(fp, &subs->fmt_list, list) {
 		snd_pcm_format_t fmt;
-		fp = list_entry(p, struct audioformat, list);
+
 		snd_iprintf(buffer, "  Interface %d\n", fp->iface);
 		snd_iprintf(buffer, "    Altset %d\n", fp->altsetting);
 		snd_iprintf(buffer, "    Format:");

commit 978520b75f0a1ce82b17e1e8186417250de6d545
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Oct 12 15:12:55 2012 +0200

    ALSA: usb-audio: Fix races at disconnection
    
    Close some races at disconnection of a USB audio device by adding the
    chip->shutdown_mutex and chip->shutdown check at appropriate places.
    
    The spots to put bandaids are:
    - PCM prepare, hw_params and hw_free
    - where the usb device is accessed for communication or get speed, in
     mixer.c and others; the device speed is now cached in subs->speed
     instead of accessing to chip->dev
    
    The accesses in PCM open and close don't need the mutex protection
    because these are already handled in the core PCM disconnection code.
    
    The autosuspend/autoresume codes are still uncovered by this patch
    because of possible mutex deadlocks.  They'll be covered by the
    upcoming change to rwsem.
    
    Also the mixer codes are untouched, too.  These will be fixed in
    another patch, too.
    
    Reported-by: Matthieu CASTET <matthieu.castet@parrot.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index ebc1a5b5b3f1..d218f763501f 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -108,7 +108,7 @@ static void proc_dump_substream_formats(struct snd_usb_substream *subs, struct s
 			}
 			snd_iprintf(buffer, "\n");
 		}
-		if (snd_usb_get_speed(subs->dev) != USB_SPEED_FULL)
+		if (subs->speed != USB_SPEED_FULL)
 			snd_iprintf(buffer, "    Data packet interval: %d us\n",
 				    125 * (1 << fp->datainterval));
 		// snd_iprintf(buffer, "    Max Packet Size = %d\n", fp->maxpacksize);
@@ -124,7 +124,7 @@ static void proc_dump_ep_status(struct snd_usb_substream *subs,
 		return;
 	snd_iprintf(buffer, "    Packet Size = %d\n", ep->curpacksize);
 	snd_iprintf(buffer, "    Momentary freq = %u Hz (%#x.%04x)\n",
-		    snd_usb_get_speed(subs->dev) == USB_SPEED_FULL
+		    subs->speed == USB_SPEED_FULL
 		    ? get_full_speed_hz(ep->freqm)
 		    : get_high_speed_hz(ep->freqm),
 		    ep->freqm >> 16, ep->freqm & 0xffff);

commit c89a5d9cacf2b862fea986a30b75359f6cf997c1
Author: Daniel Mack <zonque@gmail.com>
Date:   Sat Apr 21 13:52:12 2012 +0200

    ALSA: snd-usb: remove refactorization left-overs
    
    Drop some struct members and definitions that became obsolete during
    the refactorization of the driver.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index 06e23d89d111..ebc1a5b5b3f1 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -25,6 +25,7 @@
 #include "usbaudio.h"
 #include "helper.h"
 #include "card.h"
+#include "endpoint.h"
 #include "proc.h"
 
 /* convert our full speed USB rate into sampling rate in Hz */
@@ -137,14 +138,9 @@ static void proc_dump_ep_status(struct snd_usb_substream *subs,
 static void proc_dump_substream_status(struct snd_usb_substream *subs, struct snd_info_buffer *buffer)
 {
 	if (subs->running) {
-		unsigned int i;
 		snd_iprintf(buffer, "  Status: Running\n");
 		snd_iprintf(buffer, "    Interface = %d\n", subs->interface);
 		snd_iprintf(buffer, "    Altset = %d\n", subs->altset_idx);
-		snd_iprintf(buffer, "    URBs = %d [ ", subs->nurbs);
-		for (i = 0; i < subs->nurbs; i++)
-			snd_iprintf(buffer, "%d ", subs->dataurb[i].packets);
-		snd_iprintf(buffer, "]\n");
 		proc_dump_ep_status(subs, subs->data_endpoint, buffer);
 		proc_dump_ep_status(subs, subs->sync_endpoint, buffer);
 	} else {

commit 22026c1a7be900cc6dabd6be37a77bb217d2d837
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 13 12:57:39 2012 +0200

    ALSA: usb: Remove obsoleted fields from struct snd_usb_substream
    
    Many fields have been moved to struct snd_usb_endpoint.
    Also fix the proc output to correspond to the new structure.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index 961c9a250686..06e23d89d111 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -115,6 +115,25 @@ static void proc_dump_substream_formats(struct snd_usb_substream *subs, struct s
 	}
 }
 
+static void proc_dump_ep_status(struct snd_usb_substream *subs,
+				struct snd_usb_endpoint *ep,
+				struct snd_info_buffer *buffer)
+{
+	if (!ep)
+		return;
+	snd_iprintf(buffer, "    Packet Size = %d\n", ep->curpacksize);
+	snd_iprintf(buffer, "    Momentary freq = %u Hz (%#x.%04x)\n",
+		    snd_usb_get_speed(subs->dev) == USB_SPEED_FULL
+		    ? get_full_speed_hz(ep->freqm)
+		    : get_high_speed_hz(ep->freqm),
+		    ep->freqm >> 16, ep->freqm & 0xffff);
+	if (ep->freqshift != INT_MIN) {
+		int res = 16 - ep->freqshift;
+		snd_iprintf(buffer, "    Feedback Format = %d.%d\n",
+			    (ep->syncmaxsize > 3 ? 32 : 24) - res, res);
+	}
+}
+
 static void proc_dump_substream_status(struct snd_usb_substream *subs, struct snd_info_buffer *buffer)
 {
 	if (subs->running) {
@@ -126,17 +145,8 @@ static void proc_dump_substream_status(struct snd_usb_substream *subs, struct sn
 		for (i = 0; i < subs->nurbs; i++)
 			snd_iprintf(buffer, "%d ", subs->dataurb[i].packets);
 		snd_iprintf(buffer, "]\n");
-		snd_iprintf(buffer, "    Packet Size = %d\n", subs->curpacksize);
-		snd_iprintf(buffer, "    Momentary freq = %u Hz (%#x.%04x)\n",
-			    snd_usb_get_speed(subs->dev) == USB_SPEED_FULL
-			    ? get_full_speed_hz(subs->freqm)
-			    : get_high_speed_hz(subs->freqm),
-			    subs->freqm >> 16, subs->freqm & 0xffff);
-		if (subs->freqshift != INT_MIN)
-			snd_iprintf(buffer, "    Feedback Format = %d.%d\n",
-				    (subs->syncmaxsize > 3 ? 32 : 24)
-						- (16 - subs->freqshift),
-				    16 - subs->freqshift);
+		proc_dump_ep_status(subs, subs->data_endpoint, buffer);
+		proc_dump_ep_status(subs, subs->sync_endpoint, buffer);
 	} else {
 		snd_iprintf(buffer, "  Status: Stop\n");
 	}

commit 89e1e66d6be8a520cdcd26043cda2cc870a34015
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Oct 26 17:14:41 2010 +0200

    ALSA: usb-audio: automatically detect feedback format
    
    There are two USB Audio Class specifications (v1 and v2), but neither of
    them clearly defines the feedback format for high-speed UAC v1 devices.
    Add to this whatever the Creative and M-Audio firmware writers have been
    smoking, and it becomes impossible to predict the exact feedback format
    used by a particular device.
    
    Therefore, automatically detect the feedback format by looking at the
    magnitude of the first received feedback value.
    
    Also, this allows us to get rid of some special cases for E-Mu devices.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index 3c650ab3c91d..961c9a250686 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -132,6 +132,11 @@ static void proc_dump_substream_status(struct snd_usb_substream *subs, struct sn
 			    ? get_full_speed_hz(subs->freqm)
 			    : get_high_speed_hz(subs->freqm),
 			    subs->freqm >> 16, subs->freqm & 0xffff);
+		if (subs->freqshift != INT_MIN)
+			snd_iprintf(buffer, "    Feedback Format = %d.%d\n",
+				    (subs->syncmaxsize > 3 ? 32 : 24)
+						- (16 - subs->freqshift),
+				    16 - subs->freqshift);
 	} else {
 		snd_iprintf(buffer, "  Status: Stop\n");
 	}

commit 4f4e8f69895c8696a4bcc751817d4b186023ac44
Author: Paul Zimmerman <Paul.Zimmerman@synopsys.com>
Date:   Fri Aug 13 12:42:07 2010 -0700

    ALSA: usb: USB3 SuperSpeed sound support
    
    This is V2 of the patch, after feedback from Clemens and Daniel.
    
    This patch adds SuperSpeed support to the USB drivers under sound/. It adds
    tests for USB_SPEED_SUPER to the appropriate places that check for the USB
    speed.
    
    This patch has been tested with our SS USB3 device emulating a set of Yamaha
    speakers and a Logitech microphone, but with the descriptors modified to add
    USB3 support. It has also been tested with the real speakers and microphone,
    to make sure that USB2 devices still work.
    
    Signed-off-by: Paul Zimmerman <paulz@synopsys.com>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Cc: Daniel Mack <daniel@caiaq.de>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index f5e3f356b95f..3c650ab3c91d 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -107,7 +107,7 @@ static void proc_dump_substream_formats(struct snd_usb_substream *subs, struct s
 			}
 			snd_iprintf(buffer, "\n");
 		}
-		if (snd_usb_get_speed(subs->dev) == USB_SPEED_HIGH)
+		if (snd_usb_get_speed(subs->dev) != USB_SPEED_FULL)
 			snd_iprintf(buffer, "    Data packet interval: %d us\n",
 				    125 * (1 << fp->datainterval));
 		// snd_iprintf(buffer, "    Max Packet Size = %d\n", fp->maxpacksize);

commit 015eb0b08150c6fef843efe22609589ead3d4fb8
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Mar 4 19:46:15 2010 +0100

    ALSA: usb-audio: use a format bitmask per alternate setting
    
    In preparation for USB audio 2.0 support, change the audioformat
    structure so that it uses a bitmask to specify possible formats.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index 78fc3ba2522c..f5e3f356b95f 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -79,11 +79,16 @@ static void proc_dump_substream_formats(struct snd_usb_substream *subs, struct s
 
 	list_for_each(p, &subs->fmt_list) {
 		struct audioformat *fp;
+		snd_pcm_format_t fmt;
 		fp = list_entry(p, struct audioformat, list);
 		snd_iprintf(buffer, "  Interface %d\n", fp->iface);
 		snd_iprintf(buffer, "    Altset %d\n", fp->altsetting);
-		snd_iprintf(buffer, "    Format: %s\n",
-			    snd_pcm_format_name(fp->format));
+		snd_iprintf(buffer, "    Format:");
+		for (fmt = 0; fmt <= SNDRV_PCM_FORMAT_LAST; ++fmt)
+			if (fp->formats & (1uLL << fmt))
+				snd_iprintf(buffer, " %s",
+					    snd_pcm_format_name(fmt));
+		snd_iprintf(buffer, "\n");
 		snd_iprintf(buffer, "    Channels: %d\n", fp->channels);
 		snd_iprintf(buffer, "    Endpoint: %d %s (%s)\n",
 			    fp->endpoint & USB_ENDPOINT_NUMBER_MASK,

commit e11b4e0e4f5ab40ec342dc07b7201c09a45f9574
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Mar 4 19:46:14 2010 +0100

    ALSA: usb-audio: rename substream format field to altset_idx
    
    The snd_usb_substream::format field actually contains the index of the
    current alternate setting, so rename it to altset_idx to avoid
    confusion.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
index be3065ea1afa..78fc3ba2522c 100644
--- a/sound/usb/proc.c
+++ b/sound/usb/proc.c
@@ -116,7 +116,7 @@ static void proc_dump_substream_status(struct snd_usb_substream *subs, struct sn
 		unsigned int i;
 		snd_iprintf(buffer, "  Status: Running\n");
 		snd_iprintf(buffer, "    Interface = %d\n", subs->interface);
-		snd_iprintf(buffer, "    Altset = %d\n", subs->format);
+		snd_iprintf(buffer, "    Altset = %d\n", subs->altset_idx);
 		snd_iprintf(buffer, "    URBs = %d [ ", subs->nurbs);
 		for (i = 0; i < subs->nurbs; i++)
 			snd_iprintf(buffer, "%d ", subs->dataurb[i].packets);

commit e5779998bf8b70e48a6cc208c8b61b33bd6117ea
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Mar 4 19:46:13 2010 +0100

    ALSA: usb-audio: refactor code
    
    Clean up the usb audio driver by factoring out a lot of functions to
    separate files. Code for procfs, quirks, urbs, format parsers etc all
    got a new home now.
    
    Moved almost all special quirk handling to quirks.c and introduced new
    generic functions to handle them, so the exceptions do not pollute the
    whole driver.
    
    Renamed usbaudio.c to card.c because this is what it actually does now.
    Renamed usbmidi.c to midi.c for namespace clarity.
    Removed more things from usbaudio.h.
    
    The non-standard drivers were adopted accordingly.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/proc.c b/sound/usb/proc.c
new file mode 100644
index 000000000000..be3065ea1afa
--- /dev/null
+++ b/sound/usb/proc.c
@@ -0,0 +1,163 @@
+/*
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/usb.h>
+
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/pcm.h>
+
+#include "usbaudio.h"
+#include "helper.h"
+#include "card.h"
+#include "proc.h"
+
+/* convert our full speed USB rate into sampling rate in Hz */
+static inline unsigned get_full_speed_hz(unsigned int usb_rate)
+{
+	return (usb_rate * 125 + (1 << 12)) >> 13;
+}
+
+/* convert our high speed USB rate into sampling rate in Hz */
+static inline unsigned get_high_speed_hz(unsigned int usb_rate)
+{
+	return (usb_rate * 125 + (1 << 9)) >> 10;
+}
+
+/*
+ * common proc files to show the usb device info
+ */
+static void proc_audio_usbbus_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
+{
+	struct snd_usb_audio *chip = entry->private_data;
+	if (!chip->shutdown)
+		snd_iprintf(buffer, "%03d/%03d\n", chip->dev->bus->busnum, chip->dev->devnum);
+}
+
+static void proc_audio_usbid_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
+{
+	struct snd_usb_audio *chip = entry->private_data;
+	if (!chip->shutdown)
+		snd_iprintf(buffer, "%04x:%04x\n", 
+			    USB_ID_VENDOR(chip->usb_id),
+			    USB_ID_PRODUCT(chip->usb_id));
+}
+
+void snd_usb_audio_create_proc(struct snd_usb_audio *chip)
+{
+	struct snd_info_entry *entry;
+	if (!snd_card_proc_new(chip->card, "usbbus", &entry))
+		snd_info_set_text_ops(entry, chip, proc_audio_usbbus_read);
+	if (!snd_card_proc_new(chip->card, "usbid", &entry))
+		snd_info_set_text_ops(entry, chip, proc_audio_usbid_read);
+}
+
+/*
+ * proc interface for list the supported pcm formats
+ */
+static void proc_dump_substream_formats(struct snd_usb_substream *subs, struct snd_info_buffer *buffer)
+{
+	struct list_head *p;
+	static char *sync_types[4] = {
+		"NONE", "ASYNC", "ADAPTIVE", "SYNC"
+	};
+
+	list_for_each(p, &subs->fmt_list) {
+		struct audioformat *fp;
+		fp = list_entry(p, struct audioformat, list);
+		snd_iprintf(buffer, "  Interface %d\n", fp->iface);
+		snd_iprintf(buffer, "    Altset %d\n", fp->altsetting);
+		snd_iprintf(buffer, "    Format: %s\n",
+			    snd_pcm_format_name(fp->format));
+		snd_iprintf(buffer, "    Channels: %d\n", fp->channels);
+		snd_iprintf(buffer, "    Endpoint: %d %s (%s)\n",
+			    fp->endpoint & USB_ENDPOINT_NUMBER_MASK,
+			    fp->endpoint & USB_DIR_IN ? "IN" : "OUT",
+			    sync_types[(fp->ep_attr & USB_ENDPOINT_SYNCTYPE) >> 2]);
+		if (fp->rates & SNDRV_PCM_RATE_CONTINUOUS) {
+			snd_iprintf(buffer, "    Rates: %d - %d (continuous)\n",
+				    fp->rate_min, fp->rate_max);
+		} else {
+			unsigned int i;
+			snd_iprintf(buffer, "    Rates: ");
+			for (i = 0; i < fp->nr_rates; i++) {
+				if (i > 0)
+					snd_iprintf(buffer, ", ");
+				snd_iprintf(buffer, "%d", fp->rate_table[i]);
+			}
+			snd_iprintf(buffer, "\n");
+		}
+		if (snd_usb_get_speed(subs->dev) == USB_SPEED_HIGH)
+			snd_iprintf(buffer, "    Data packet interval: %d us\n",
+				    125 * (1 << fp->datainterval));
+		// snd_iprintf(buffer, "    Max Packet Size = %d\n", fp->maxpacksize);
+		// snd_iprintf(buffer, "    EP Attribute = %#x\n", fp->attributes);
+	}
+}
+
+static void proc_dump_substream_status(struct snd_usb_substream *subs, struct snd_info_buffer *buffer)
+{
+	if (subs->running) {
+		unsigned int i;
+		snd_iprintf(buffer, "  Status: Running\n");
+		snd_iprintf(buffer, "    Interface = %d\n", subs->interface);
+		snd_iprintf(buffer, "    Altset = %d\n", subs->format);
+		snd_iprintf(buffer, "    URBs = %d [ ", subs->nurbs);
+		for (i = 0; i < subs->nurbs; i++)
+			snd_iprintf(buffer, "%d ", subs->dataurb[i].packets);
+		snd_iprintf(buffer, "]\n");
+		snd_iprintf(buffer, "    Packet Size = %d\n", subs->curpacksize);
+		snd_iprintf(buffer, "    Momentary freq = %u Hz (%#x.%04x)\n",
+			    snd_usb_get_speed(subs->dev) == USB_SPEED_FULL
+			    ? get_full_speed_hz(subs->freqm)
+			    : get_high_speed_hz(subs->freqm),
+			    subs->freqm >> 16, subs->freqm & 0xffff);
+	} else {
+		snd_iprintf(buffer, "  Status: Stop\n");
+	}
+}
+
+static void proc_pcm_format_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
+{
+	struct snd_usb_stream *stream = entry->private_data;
+
+	snd_iprintf(buffer, "%s : %s\n", stream->chip->card->longname, stream->pcm->name);
+
+	if (stream->substream[SNDRV_PCM_STREAM_PLAYBACK].num_formats) {
+		snd_iprintf(buffer, "\nPlayback:\n");
+		proc_dump_substream_status(&stream->substream[SNDRV_PCM_STREAM_PLAYBACK], buffer);
+		proc_dump_substream_formats(&stream->substream[SNDRV_PCM_STREAM_PLAYBACK], buffer);
+	}
+	if (stream->substream[SNDRV_PCM_STREAM_CAPTURE].num_formats) {
+		snd_iprintf(buffer, "\nCapture:\n");
+		proc_dump_substream_status(&stream->substream[SNDRV_PCM_STREAM_CAPTURE], buffer);
+		proc_dump_substream_formats(&stream->substream[SNDRV_PCM_STREAM_CAPTURE], buffer);
+	}
+}
+
+void snd_usb_proc_pcm_format_add(struct snd_usb_stream *stream)
+{
+	struct snd_info_entry *entry;
+	char name[32];
+	struct snd_card *card = stream->chip->card;
+
+	sprintf(name, "stream%d", stream->pcm_index);
+	if (!snd_card_proc_new(card, name, &entry))
+		snd_info_set_text_ops(entry, stream, proc_pcm_format_read);
+}
+
