commit 88d8822d30cc6f668d44a1a7466bed5a1f85f607
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 5 08:41:17 2020 +0200

    ALSA: usb-audio: Manage auto-pm of all bundled interfaces
    
    Currently USB-audio driver manages the auto-pm of the primary
    interface although a card may consist of multiple interfaces.
    This may leave the secondary and other interfaces left running
    unnecessarily after the auto-suspend.
    
    This patch allows the driver managing the auto-pm of all bundled
    interfaces per card.  The chip->pm_intf field is extended as
    chip->intf[] to contain the array of assigned interfaces, and the
    runtime-PM is performed to all those interfaces.
    
    Tested-by: Macpaul Lin <macpaul.lin@mediatek.com>
    Link: https://lore.kernel.org/r/20200605064117.28504-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 359f7a04be1c..162bdd6eb4d4 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -634,7 +634,6 @@ static int usb_audio_probe(struct usb_interface *intf,
 								   id, &chip);
 					if (err < 0)
 						goto __error;
-					chip->pm_intf = intf;
 					break;
 				} else if (vid[i] != -1 || pid[i] != -1) {
 					dev_info(&dev->dev,
@@ -651,6 +650,13 @@ static int usb_audio_probe(struct usb_interface *intf,
 			goto __error;
 		}
 	}
+
+	if (chip->num_interfaces >= MAX_CARD_INTERFACES) {
+		dev_info(&dev->dev, "Too many interfaces assigned to the single USB-audio card\n");
+		err = -EINVAL;
+		goto __error;
+	}
+
 	dev_set_drvdata(&dev->dev, chip);
 
 	/*
@@ -703,6 +709,7 @@ static int usb_audio_probe(struct usb_interface *intf,
 	}
 
 	usb_chip[chip->index] = chip;
+	chip->intf[chip->num_interfaces] = intf;
 	chip->num_interfaces++;
 	usb_set_intfdata(intf, chip);
 	atomic_dec(&chip->active);
@@ -818,19 +825,37 @@ void snd_usb_unlock_shutdown(struct snd_usb_audio *chip)
 
 int snd_usb_autoresume(struct snd_usb_audio *chip)
 {
+	int i, err;
+
 	if (atomic_read(&chip->shutdown))
 		return -EIO;
-	if (atomic_inc_return(&chip->active) == 1)
-		return usb_autopm_get_interface(chip->pm_intf);
+	if (atomic_inc_return(&chip->active) != 1)
+		return 0;
+
+	for (i = 0; i < chip->num_interfaces; i++) {
+		err = usb_autopm_get_interface(chip->intf[i]);
+		if (err < 0) {
+			/* rollback */
+			while (--i >= 0)
+				usb_autopm_put_interface(chip->intf[i]);
+			atomic_dec(&chip->active);
+			return err;
+		}
+	}
 	return 0;
 }
 
 void snd_usb_autosuspend(struct snd_usb_audio *chip)
 {
+	int i;
+
 	if (atomic_read(&chip->shutdown))
 		return;
-	if (atomic_dec_and_test(&chip->active))
-		usb_autopm_put_interface(chip->pm_intf);
+	if (!atomic_dec_and_test(&chip->active))
+		return;
+
+	for (i = 0; i < chip->num_interfaces; i++)
+		usb_autopm_put_interface(chip->intf[i]);
 }
 
 static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)

commit 862b2509d157c629dd26d7ac6c6cdbf043d332eb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 3 17:37:08 2020 +0200

    ALSA: usb-audio: Fix inconsistent card PM state after resume
    
    When a USB-audio interface gets runtime-suspended via auto-pm feature,
    the driver suspends all functionality and increment
    chip->num_suspended_intf.  Later on, when the system gets suspended to
    S3, the driver increments chip->num_suspended_intf again, skips the
    device changes, and sets the card power state to
    SNDRV_CTL_POWER_D3hot.  In return, when the system gets resumed from
    S3, the resume callback decrements chip->num_suspended_intf.  Since
    this refcount is still not zero (it's been runtime-suspended), the
    whole resume is skipped.  But there is a small pitfall here.
    
    The problem is that the driver doesn't restore the card power state
    after this resume call, leaving it as SNDRV_CTL_POWER_D3hot.  So,
    even after the system resume finishes, the card instance still appears
    as if it were system-suspended, and this confuses many ioctl accesses
    that are blocked unexpectedly.
    
    In details, we have two issues behind the scene: one is that the card
    power state is changed only when the refcount becomes zero, and
    another is that the prior auto-suspend check is kept in a boolean
    flag.  Although the latter problem is almost negligible since the
    auto-pm feature is imposed only on the primary interface, but this can
    be a potential problem on the devices with multiple interfaces.
    
    This patch addresses those issues by the following:
    
    - Replace chip->autosuspended boolean flag with chip->system_suspend
      counter
    
    - At the first system-suspend, chip->num_suspended_intf is recorded to
      chip->system_suspend
    
    - At system-resume, the card power state is restored when the
      chip->num_suspended_intf refcount reaches to chip->system_suspend,
      i.e. the state returns to the auto-suspended
    
    Also, the patch fixes yet another hidden problem by the code
    refactoring along with the fixes above: namely, when some resume
    procedure failed, the driver left chip->num_suspended_intf that was
    already decreased, and it might lead to the refcount unbalance.
    In the new code, the refcount decrement is done after the whole resume
    procedure, and the problem is avoided as well.
    
    Fixes: 0662292aec05 ("ALSA: usb-audio: Handle normal and auto-suspend equally")
    Reported-and-tested-by: Macpaul Lin <macpaul.lin@mediatek.com>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200603153709.6293-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index fd6fd1726ea0..359f7a04be1c 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -843,9 +843,6 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 	if (chip == (void *)-1L)
 		return 0;
 
-	chip->autosuspended = !!PMSG_IS_AUTO(message);
-	if (!chip->autosuspended)
-		snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
 	if (!chip->num_suspended_intf++) {
 		list_for_each_entry(as, &chip->pcm_list, list) {
 			snd_usb_pcm_suspend(as);
@@ -858,6 +855,11 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 			snd_usb_mixer_suspend(mixer);
 	}
 
+	if (!PMSG_IS_AUTO(message) && !chip->system_suspend) {
+		snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
+		chip->system_suspend = chip->num_suspended_intf;
+	}
+
 	return 0;
 }
 
@@ -871,10 +873,10 @@ static int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)
 
 	if (chip == (void *)-1L)
 		return 0;
-	if (--chip->num_suspended_intf)
-		return 0;
 
 	atomic_inc(&chip->active); /* avoid autopm */
+	if (chip->num_suspended_intf > 1)
+		goto out;
 
 	list_for_each_entry(as, &chip->pcm_list, list) {
 		err = snd_usb_pcm_resume(as);
@@ -896,9 +898,12 @@ static int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)
 		snd_usbmidi_resume(p);
 	}
 
-	if (!chip->autosuspended)
+ out:
+	if (chip->num_suspended_intf == chip->system_suspend) {
 		snd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);
-	chip->autosuspended = 0;
+		chip->system_suspend = 0;
+	}
+	chip->num_suspended_intf--;
 
 err_out:
 	atomic_dec(&chip->active); /* allow autopm after this point */

commit a4aad5636c7298eecfb60fc9d73933336cb0c4d8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 25 11:33:21 2020 +0100

    ALSA: usb-audio: Inform devices that need delayed registration
    
    The USB-audio driver may call snd_card_register() multiple times as
    its probe function is per USB interface while some USB-audio devices
    may provide multiple interfaces to assign different streams although
    they belong to the same device.  This works in most cases but the
    registration is racy, hence it may miss the device recognition,
    e.g. PA doesn't see certain devices when hotplugged.
    
    The recent addition of the delayed registration quirk allows to sync
    the registration at the last known interface, and the previous commit
    added a new module option to allow the dynamic setup for that
    purpose.
    
    Now, this patch tries to find out and notifies for such devices that
    require the delayed registration.  It shows a message like:
    
      Found post-registration device assignment: 1234abcd:02
    
    If you hit this message, you can pass delayed_register module option
    like:
    
      snd_usb_audio.delayed_register=1234abcd:02
    
    by just copying the last shown entry.  If this works, it can be added
    statically in the quirk list, registration_quirks[] found at the end
    of sound/usb/quirks.c.
    
    Link: https://lore.kernel.org/r/20200325103322.2508-4-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 951134238669..fd6fd1726ea0 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -680,6 +680,13 @@ static int usb_audio_probe(struct usb_interface *intf,
 			goto __error;
 	}
 
+	if (chip->need_delayed_register) {
+		dev_info(&dev->dev,
+			 "Found post-registration device assignment: %08x:%02x\n",
+			 chip->usb_id, ifnum);
+		chip->need_delayed_register = false; /* clear again */
+	}
+
 	/* we are allowed to call snd_card_register() many times, but first
 	 * check to see if a device needs to skip it or do anything special
 	 */

commit b70038ef4feae9c5c9d01de4cd799ae52ccafc08
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 25 11:33:20 2020 +0100

    ALSA: usb-audio: Add delayed_register option
    
    Add a new option for specifying the quirk for delayed registration of
    the certain device.  A list of devices can be passed in a form
            ID:IFACE,ID:IFACE,ID:IFACE,....
    where ID is the 32bit hex number combo of vendor and device IDs and
    IFACE is the interface number to trigger the register.
    
    When a matching device is probed, the card registration is delayed
    until the given interface is probed.  It's needed for syncing the
    registration until the last interface when multiple interfaces are
    provided for the same card.
    
    Link: https://lore.kernel.org/r/20200325103322.2508-3-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 55d563a8154d..951134238669 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -72,6 +72,7 @@ static int device_setup[SNDRV_CARDS]; /* device parameter for this card */
 static bool ignore_ctl_error;
 static bool autoclock = true;
 static char *quirk_alias[SNDRV_CARDS];
+static char *delayed_register[SNDRV_CARDS];
 
 bool snd_usb_use_vmalloc = true;
 bool snd_usb_skip_validation;
@@ -95,6 +96,8 @@ module_param(autoclock, bool, 0444);
 MODULE_PARM_DESC(autoclock, "Enable auto-clock selection for UAC2 devices (default: yes).");
 module_param_array(quirk_alias, charp, NULL, 0444);
 MODULE_PARM_DESC(quirk_alias, "Quirk aliases, e.g. 0123abcd:5678beef.");
+module_param_array(delayed_register, charp, NULL, 0444);
+MODULE_PARM_DESC(delayed_register, "Quirk for delayed registration, given by id:iface, e.g. 0123abcd:4.");
 module_param_named(use_vmalloc, snd_usb_use_vmalloc, bool, 0444);
 MODULE_PARM_DESC(use_vmalloc, "Use vmalloc for PCM intermediate buffers (default: yes).");
 module_param_named(skip_validation, snd_usb_skip_validation, bool, 0444);
@@ -525,6 +528,21 @@ static bool get_alias_id(struct usb_device *dev, unsigned int *id)
 	return false;
 }
 
+static bool check_delayed_register_option(struct snd_usb_audio *chip, int iface)
+{
+	int i;
+	unsigned int id, inum;
+
+	for (i = 0; i < ARRAY_SIZE(delayed_register); i++) {
+		if (delayed_register[i] &&
+		    sscanf(delayed_register[i], "%x:%x", &id, &inum) == 2 &&
+		    id == chip->usb_id)
+			return inum != iface;
+	}
+
+	return false;
+}
+
 static const struct usb_device_id usb_audio_ids[]; /* defined below */
 
 /* look for the corresponding quirk */
@@ -665,7 +683,8 @@ static int usb_audio_probe(struct usb_interface *intf,
 	/* we are allowed to call snd_card_register() many times, but first
 	 * check to see if a device needs to skip it or do anything special
 	 */
-	if (!snd_usb_registration_quirk(chip, ifnum)) {
+	if (!snd_usb_registration_quirk(chip, ifnum) &&
+	    !check_delayed_register_option(chip, ifnum)) {
 		err = snd_card_register(chip->card);
 		if (err < 0)
 			goto __error;

commit d8695bc5b1fe88305396b1f788d3b5f218e28a30
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 25 11:33:19 2020 +0100

    ALSA: usb-audio: Rewrite registration quirk handling
    
    A slight refactoring of the registration quirk code.  Now it uses the
    table lookup for easy additions in future.  Also the return type was
    changed to bool, and got a few more comments.
    
    Link: https://lore.kernel.org/r/20200325103322.2508-2-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 16bbe2a50fb7..55d563a8154d 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -665,7 +665,7 @@ static int usb_audio_probe(struct usb_interface *intf,
 	/* we are allowed to call snd_card_register() many times, but first
 	 * check to see if a device needs to skip it or do anything special
 	 */
-	if (snd_usb_registration_quirk(chip, ifnum) == 0) {
+	if (!snd_usb_registration_quirk(chip, ifnum)) {
 		err = snd_card_register(chip->card);
 		if (err < 0)
 			goto __error;

commit 55f7326170d9e83e2d828591938e1101982a679c
Author: Chris Wulff <crwulff@gmail.com>
Date:   Sat Mar 14 12:54:49 2020 -0400

    ALSA: usb-audio: Create a registration quirk for Kingston HyperX Amp (0951:16d8)
    
    Create a quirk that allows special processing and/or
    skipping the call to snd_card_register.
    
    For HyperX AMP, which uses two interfaces, but only has
    a capture stream in the second, this allows the capture
    stream to merge with the first PCM.
    
    Signed-off-by: Chris Wulff <crwulff@gmail.com>
    Link: https://lore.kernel.org/r/20200314165449.4086-3-crwulff@gmail.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 827fb0bc8b56..16bbe2a50fb7 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -662,10 +662,14 @@ static int usb_audio_probe(struct usb_interface *intf,
 			goto __error;
 	}
 
-	/* we are allowed to call snd_card_register() many times */
-	err = snd_card_register(chip->card);
-	if (err < 0)
-		goto __error;
+	/* we are allowed to call snd_card_register() many times, but first
+	 * check to see if a device needs to skip it or do anything special
+	 */
+	if (snd_usb_registration_quirk(chip, ifnum) == 0) {
+		err = snd_card_register(chip->card);
+		if (err < 0)
+			goto __error;
+	}
 
 	if (quirk && quirk->shares_media_device) {
 		/* don't want to fail when snd_media_device_create() fails */

commit a3afa29942b84b4e2548beacccc3a68b8d77e3dc
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Jan 15 20:46:04 2020 +0300

    ALSA: usb-audio: unlock on error in probe
    
    We need to unlock before we returning on this error path.
    
    Fixes: 73ac9f5e5b43 ("ALSA: usb-audio: Add boot quirk for MOTU M Series")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Link: https://lore.kernel.org/r/20200115174604.rhanfgy4j3uc65cx@kili.mountain
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 2f582ac7cf78..827fb0bc8b56 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -602,7 +602,7 @@ static int usb_audio_probe(struct usb_interface *intf,
 	if (! chip) {
 		err = snd_usb_apply_boot_quirk_once(dev, intf, quirk, id);
 		if (err < 0)
-			return err;
+			goto __error;
 
 		/* it's a fresh one.
 		 * now look for an empty slot and create a new card instance

commit 73ac9f5e5b43a5dbadb61f27dae7a971f7ec0d22
Author: Alexander Tsoy <alexander@tsoy.me>
Date:   Sun Jan 12 13:23:58 2020 +0300

    ALSA: usb-audio: Add boot quirk for MOTU M Series
    
    Add delay to make sure that audio urbs are not sent too early.
    Otherwise the device hangs. Windows driver makes ~2s delay, so use
    about the same time delay value.
    
    snd_usb_apply_boot_quirk() is called 3 times for my MOTU M4, which
    is an overkill. Thus a quirk that is called only once is implemented.
    
    Also send two vendor-specific control messages before and after
    the delay. This behaviour is blindly copied from the Windows driver.
    
    Signed-off-by: Alexander Tsoy <alexander@tsoy.me>
    Link: https://lore.kernel.org/r/20200112102358.18085-1-alexander@tsoy.me
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 9f743ebae615..2f582ac7cf78 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -600,6 +600,10 @@ static int usb_audio_probe(struct usb_interface *intf,
 		}
 	}
 	if (! chip) {
+		err = snd_usb_apply_boot_quirk_once(dev, intf, quirk, id);
+		if (err < 0)
+			return err;
+
 		/* it's a fresh one.
 		 * now look for an empty slot and create a new card instance
 		 */

commit f35ef592477c5347b8f780a5f0d4970671e22c61
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 14 17:56:13 2019 +0100

    ALSA: usb-audio: Add skip_validation option
    
    The unit descriptor validation may lead to a probe error when the
    device provides a buggy descriptor or the validator detected
    incorrectly.  For identifying such an error and band-aiding, give a
    new module option, skip_validation.  With this option, the driver
    ignores the validation errors with the hexdump of the unit
    descriptor, so we can check it in a bit more details.
    
    Link: https://lore.kernel.org/r/20191114165613.7422-2-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index db91dc76cc91..9f743ebae615 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -74,6 +74,7 @@ static bool autoclock = true;
 static char *quirk_alias[SNDRV_CARDS];
 
 bool snd_usb_use_vmalloc = true;
+bool snd_usb_skip_validation;
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for the USB audio adapter.");
@@ -96,6 +97,8 @@ module_param_array(quirk_alias, charp, NULL, 0444);
 MODULE_PARM_DESC(quirk_alias, "Quirk aliases, e.g. 0123abcd:5678beef.");
 module_param_named(use_vmalloc, snd_usb_use_vmalloc, bool, 0444);
 MODULE_PARM_DESC(use_vmalloc, "Use vmalloc for PCM intermediate buffers (default: yes).");
+module_param_named(skip_validation, snd_usb_skip_validation, bool, 0444);
+MODULE_PARM_DESC(skip_validation, "Skip unit descriptor validation (default: no).");
 
 /*
  * we keep the snd_usb_audio_t instances by ourselves for merging

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 04465d581204..db91dc76cc91 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *   (Tentative) USB Audio Driver for ALSA
  *
@@ -9,21 +10,6 @@
  *
  *   Audio Class 3.0 support by Ruslan Bilovol <ruslan.bilovol@gmail.com>
  *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- *
  *  NOTES:
  *
  *   - the linked URBs would be preferred but not used so far because of

commit 66354f18fe5fbb65f7b10a519654013d6df09f80
Author: Shuah Khan <shuah@kernel.org>
Date:   Mon Apr 1 20:40:22 2019 -0400

    media: sound/usb: Use Media Controller API to share media resources
    
    Media Device Allocator API to allows multiple drivers share a media device.
    This API solves a very common use-case for media devices where one physical
    device (an USB stick) provides both audio and video. When such media device
    exposes a standard USB Audio class, a proprietary Video class, two or more
    independent drivers will share a single physical USB bridge. In such cases,
    it is necessary to coordinate access to the shared resource.
    
    Using this API, drivers can allocate a media device with the shared struct
    device as the key. Once the media device is allocated by a driver, other
    drivers can get a reference to it. The media device is released when all
    the references are released.
    
    Change the ALSA driver to use the Media Controller API to share media
    resources with DVB, and V4L2 drivers on a AU0828 media device.
    
    The Media Controller specific initialization is done after sound card is
    registered. ALSA creates Media interface and entity function graph nodes
    for Control, Mixer, PCM Playback, and PCM Capture devices.
    
    snd_usb_hw_params() will call Media Controller enable source handler
    interface to request the media resource. If resource request is granted,
    it will release it from snd_usb_hw_free(). If resource is busy, -EBUSY is
    returned.
    
    Media specific cleanup is done in usb_audio_disconnect().
    
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Shuah Khan <shuah@kernel.org>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 719e10034553..04465d581204 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -68,6 +68,7 @@
 #include "format.h"
 #include "power.h"
 #include "stream.h"
+#include "media.h"
 
 MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
 MODULE_DESCRIPTION("USB Audio");
@@ -673,6 +674,11 @@ static int usb_audio_probe(struct usb_interface *intf,
 	if (err < 0)
 		goto __error;
 
+	if (quirk && quirk->shares_media_device) {
+		/* don't want to fail when snd_media_device_create() fails */
+		snd_media_device_create(chip, intf);
+	}
+
 	usb_chip[chip->index] = chip;
 	chip->num_interfaces++;
 	usb_set_intfdata(intf, chip);
@@ -732,6 +738,14 @@ static void usb_audio_disconnect(struct usb_interface *intf)
 		list_for_each(p, &chip->midi_list) {
 			snd_usbmidi_disconnect(p);
 		}
+		/*
+		 * Nice to check quirk && quirk->shares_media_device and
+		 * then call the snd_media_device_delete(). Don't have
+		 * access to the quirk here. snd_media_device_delete()
+		 * accesses mixer_list
+		 */
+		snd_media_device_delete(chip);
+
 		/* release mixer resources */
 		list_for_each_entry(mixer, &chip->mixer_list, list) {
 			snd_usb_mixer_disconnect(mixer);

commit 436ec40e0cdf74eae90af6be6c287396e388f1fb
Merge: 053b055948e9 ce7f93e2bd6f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 18 17:37:14 2019 +0100

    Merge branch 'topic/pcm-device-suspend' into for-next
    
    Pull the PCM suspend improvement / cleanup.
    This moves the most of snd_pcm_suspend*() calls into PCM's own device
    PM ops.  There should be no change from the functionality POV.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 2c76706843c998ceb136e8b04af1822832911e7b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:03:16 2019 +0100

    ALSA: usb: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index a105947eaf55..dfa38b78c494 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -811,7 +811,6 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 		snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
 	if (!chip->num_suspended_intf++) {
 		list_for_each_entry(as, &chip->pcm_list, list) {
-			snd_pcm_suspend_all(as->pcm);
 			snd_usb_pcm_suspend(as);
 			as->substream[0].need_setup_ep =
 				as->substream[1].need_setup_ep = true;

commit 3e96d7280f16e2f787307f695a31296b9e4a1cd7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 2 17:12:21 2019 +0100

    ALSA: usb-audio: Always check descriptor sizes in parser code
    
    There are a few places where we access the data without checking the
    actual object size from the USB audio descriptor.  This may result in
    OOB access, as recently reported.
    
    This patch addresses these missing checks.  Most of added codes are
    simple bLength checks in the caller side.  For the input and output
    terminal parsers, we put the length check in the parser functions.
    For the input terminal, a new argument is added to distinguish between
    UAC1 and the rest, as they treat different objects.
    
    Reported-by: Mathias Payer <mathias.payer@nebelwelt.net>
    Reported-by: Hui Peng <benquike@163.com>
    Tested-by: Hui Peng <benquike@163.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index a105947eaf55..746a72e23cf9 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -246,7 +246,7 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 		h1 = snd_usb_find_csint_desc(host_iface->extra,
 							 host_iface->extralen,
 							 NULL, UAC_HEADER);
-		if (!h1) {
+		if (!h1 || h1->bLength < sizeof(*h1)) {
 			dev_err(&dev->dev, "cannot find UAC_HEADER\n");
 			return -EINVAL;
 		}

commit 5f8cf712582617d523120df67d392059eaf2fc4b
Author: Hui Peng <benquike@gmail.com>
Date:   Mon Dec 3 16:09:34 2018 +0100

    ALSA: usb-audio: Fix UAF decrement if card has no live interfaces in card.c
    
    If a USB sound card reports 0 interfaces, an error condition is triggered
    and the function usb_audio_probe errors out. In the error path, there was a
    use-after-free vulnerability where the memory object of the card was first
    freed, followed by a decrement of the number of active chips. Moving the
    decrement above the atomic_dec fixes the UAF.
    
    [ The original problem was introduced in 3.1 kernel, while it was
      developed in a different form.  The Fixes tag below indicates the
      original commit but it doesn't mean that the patch is applicable
      cleanly. -- tiwai ]
    
    Fixes: 362e4e49abe5 ("ALSA: usb-audio - clear chip->probing on error exit")
    Reported-by: Hui Peng <benquike@gmail.com>
    Reported-by: Mathias Payer <mathias.payer@nebelwelt.net>
    Signed-off-by: Hui Peng <benquike@gmail.com>
    Signed-off-by: Mathias Payer <mathias.payer@nebelwelt.net>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 2bfe4e80a6b9..a105947eaf55 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -682,9 +682,12 @@ static int usb_audio_probe(struct usb_interface *intf,
 
  __error:
 	if (chip) {
+		/* chip->active is inside the chip->card object,
+		 * decrement before memory is possibly returned.
+		 */
+		atomic_dec(&chip->active);
 		if (!chip->num_interfaces)
 			snd_card_free(chip->card);
-		atomic_dec(&chip->active);
 	}
 	mutex_unlock(&register_mutex);
 	return err;

commit 3f59aa11c6776da8d0f9f50c741ef02bfc4a8766
Author: Jorge Sanjuan <jorge.sanjuan@codethink.co.uk>
Date:   Tue Jul 31 13:28:44 2018 +0100

    ALSA: usb-audio: Add UAC3 Power Domains to suspend/resume
    
    Set the UAC3 Power Domain state for an Audio Streaming interface
    to D2 state before suspending the device (usb_driver callback).
    This lets the device know there is no intention to use any of the
    Units in the Audio Function and that the host is not going to
    even listen for wake-up events (interrupts) on the units.
    
    When the usb_driver gets resumed, the state D0 (fully powered) will
    be set. This ties up the UAC3 Power Domains to the runtime PM.
    
    Signed-off-by: Jorge Sanjuan <jorge.sanjuan@codethink.co.uk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index a1ed798a1c6b..2bfe4e80a6b9 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -809,6 +809,7 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 	if (!chip->num_suspended_intf++) {
 		list_for_each_entry(as, &chip->pcm_list, list) {
 			snd_pcm_suspend_all(as->pcm);
+			snd_usb_pcm_suspend(as);
 			as->substream[0].need_setup_ep =
 				as->substream[1].need_setup_ep = true;
 		}
@@ -824,6 +825,7 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 static int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)
 {
 	struct snd_usb_audio *chip = usb_get_intfdata(intf);
+	struct snd_usb_stream *as;
 	struct usb_mixer_interface *mixer;
 	struct list_head *p;
 	int err = 0;
@@ -834,6 +836,13 @@ static int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)
 		return 0;
 
 	atomic_inc(&chip->active); /* avoid autopm */
+
+	list_for_each_entry(as, &chip->pcm_list, list) {
+		err = snd_usb_pcm_resume(as);
+		if (err < 0)
+			goto err_out;
+	}
+
 	/*
 	 * ALSA leaves material resumption to user space
 	 * we just notify and restart the mixers

commit f274baa49be67dd8a9f318cd95da6ef9f565d06b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun May 27 13:01:17 2018 +0200

    ALSA: usb-audio: Allow non-vmalloc buffer for PCM buffers
    
    Currently, USB-audio driver allocates the PCM buffer via vmalloc(), as
    this serves merely as an intermediate buffer that is copied to each
    URB transfer buffer.  This works well in general on x86, but on some
    archs this may result in cache coherency issues when mmap is used.
    OTOH, it works also on such arch unless mmap is used.
    
    This patch is a step for mitigating the inconvenience; a new module
    option "use_vmalloc" is provided so that user can choose to allocate
    the DMA coherent buffer instead of the existing vmalloc buffer.
    The drawback is that it'd be the standard dma_alloc_coherent() calls
    and the system would require contiguous pages on non-x86 archs.
    
    Note that it's a global option and not dynamically switchable since
    the buffer is pre-allocated at the probe time.  In theory, it's
    possible to be switchable, but it'd be trickier and racier.
    
    As default use_vmalloc option is set to true, so that the old behavior
    is kept.  For allowing the coherent mmap on ARM or MIPS, pass
    use_vmalloc=0 option explicitly.
    
    Reported-and-tested-by: Daniel Danzberger <daniel@dd-wrt.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index c80224807e8f..a1ed798a1c6b 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -86,6 +86,8 @@ static bool ignore_ctl_error;
 static bool autoclock = true;
 static char *quirk_alias[SNDRV_CARDS];
 
+bool snd_usb_use_vmalloc = true;
+
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for the USB audio adapter.");
 module_param_array(id, charp, NULL, 0444);
@@ -105,6 +107,8 @@ module_param(autoclock, bool, 0444);
 MODULE_PARM_DESC(autoclock, "Enable auto-clock selection for UAC2 devices (default: yes).");
 module_param_array(quirk_alias, charp, NULL, 0444);
 MODULE_PARM_DESC(quirk_alias, "Quirk aliases, e.g. 0123abcd:5678beef.");
+module_param_named(use_vmalloc, snd_usb_use_vmalloc, bool, 0444);
+MODULE_PARM_DESC(use_vmalloc, "Use vmalloc for PCM intermediate buffers (default: yes).");
 
 /*
  * we keep the snd_usb_audio_t instances by ourselves for merging

commit 011ae2bf06690c9fd6209537b4775855122f5c86
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun May 27 15:07:01 2018 +0200

    ALSA: usb-audio: Avoid lowlevel device object
    
    Simplify the device management by replacing the lowlevel device object
    allocation with the card->private_data.  Nowadays there is almost no
    advantage by the lowlevel device, and with card->private_data, the
    code becomes cleaner.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 54c77d407a6d..c80224807e8f 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -342,8 +342,9 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
  *
  */
 
-static int snd_usb_audio_free(struct snd_usb_audio *chip)
+static void snd_usb_audio_free(struct snd_card *card)
 {
+	struct snd_usb_audio *chip = card->private_data;
 	struct snd_usb_endpoint *ep, *n;
 
 	list_for_each_entry_safe(ep, n, &chip->ep_list, list)
@@ -352,14 +353,6 @@ static int snd_usb_audio_free(struct snd_usb_audio *chip)
 	mutex_destroy(&chip->mutex);
 	if (!atomic_read(&chip->shutdown))
 		dev_set_drvdata(&chip->dev->dev, NULL);
-	kfree(chip);
-	return 0;
-}
-
-static int snd_usb_audio_dev_free(struct snd_device *device)
-{
-	struct snd_usb_audio *chip = device->device_data;
-	return snd_usb_audio_free(chip);
 }
 
 static void usb_audio_make_shortname(struct usb_device *dev,
@@ -459,9 +452,6 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 	struct snd_usb_audio *chip;
 	int err;
 	char component[14];
-	static struct snd_device_ops ops = {
-		.dev_free =	snd_usb_audio_dev_free,
-	};
 
 	*rchip = NULL;
 
@@ -479,18 +469,13 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 	}
 
 	err = snd_card_new(&intf->dev, index[idx], id[idx], THIS_MODULE,
-			   0, &card);
+			   sizeof(*chip), &card);
 	if (err < 0) {
 		dev_err(&dev->dev, "cannot create card instance %d\n", idx);
 		return err;
 	}
 
-	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
-	if (! chip) {
-		snd_card_free(card);
-		return -ENOMEM;
-	}
-
+	chip = card->private_data;
 	mutex_init(&chip->mutex);
 	init_waitqueue_head(&chip->shutdown_wait);
 	chip->index = idx;
@@ -508,12 +493,7 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 	INIT_LIST_HEAD(&chip->midi_list);
 	INIT_LIST_HEAD(&chip->mixer_list);
 
-	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
-	if (err < 0) {
-		snd_usb_audio_free(chip);
-		snd_card_free(card);
-		return err;
-	}
+	card->private_free = snd_usb_audio_free;
 
 	strcpy(card->driver, "USB-Audio");
 	sprintf(component, "USB%04x:%04x",

commit f25ecf8f987d51be388e53de7b9e0e5815acc10b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun May 27 15:18:22 2018 +0200

    ALSA: usb-audio: Follow standard coding style
    
    Avoid if ((err = ...) style and expand to multiple lines instead.
    No change in the end result, but just the beautification.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index f6c3c1cd591e..54c77d407a6d 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -508,7 +508,8 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 	INIT_LIST_HEAD(&chip->midi_list);
 	INIT_LIST_HEAD(&chip->mixer_list);
 
-	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
+	err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
+	if (err < 0) {
 		snd_usb_audio_free(chip);
 		snd_card_free(card);
 		return err;

commit 17156f23e93c0f59e06dd2aaffd06221341caaee
Author: Ruslan Bilovol <ruslan.bilovol@gmail.com>
Date:   Fri May 4 04:24:04 2018 +0300

    ALSA: usb: add UAC3 BADD profiles support
    
    Recently released USB Audio Class 3.0 specification
    contains BADD (Basic Audio Device Definition) document
    which describes pre-defined UAC3 configurations.
    
    BADD support is mandatory for UAC3 devices, it should be
    implemented as a separate USB device configuration.
    As per BADD document, class-specific descriptors
    shall not be included in the Deviceâ€™s Configuration
    descriptor ("inferred"), but host can guess them
    from BADD profile number, number of endpoints and
    their max packed sizes.
    
    This patch adds support of all BADD profiles from the spec
    
    Signed-off-by: Ruslan Bilovol <ruslan.bilovol@gmail.com>
    Tested-by: Jorge Sanjuan <jorge.sanjuan@codethink.co.uk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 0d7a5d70634e..f6c3c1cd591e 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -307,6 +307,20 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 			return -EINVAL;
 		}
 
+		if (protocol == UAC_VERSION_3) {
+			int badd = assoc->bFunctionSubClass;
+
+			if (badd != UAC3_FUNCTION_SUBCLASS_FULL_ADC_3_0 &&
+			    (badd < UAC3_FUNCTION_SUBCLASS_GENERIC_IO ||
+			     badd > UAC3_FUNCTION_SUBCLASS_SPEAKERPHONE)) {
+				dev_err(&dev->dev,
+					"Unsupported UAC3 BADD profile\n");
+				return -EINVAL;
+			}
+
+			chip->badd_profile = badd;
+		}
+
 		for (i = 0; i < assoc->bInterfaceCount; i++) {
 			int intf = assoc->bFirstInterface + i;
 

commit 3763f6186703d9939913996da1c71d8f8ddb035c
Author: Jorge Sanjuan <jorge.sanjuan@codethink.co.uk>
Date:   Fri May 4 04:24:01 2018 +0300

    ALSA: usb: Only get AudioControl header for UAC1 class.
    
    The control header needs to be read from buffer at this point only
    in the case of UAC1 protocol. Move it inside the switch case as other
    protocols such as the Basic Audio Device spec will have an empty buffer
    that is latter filled as inferred.
    
    Signed-off-by: Jorge Sanjuan <jorge.sanjuan@codethink.co.uk>
    [Ruslan: updated with recently added sanity checks]
    Signed-off-by: Ruslan Bilovol <ruslan.bilovol@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 36c289bae169..0d7a5d70634e 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -221,32 +221,13 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 	struct usb_device *dev = chip->dev;
 	struct usb_host_interface *host_iface;
 	struct usb_interface_descriptor *altsd;
-	void *control_header;
 	int i, protocol;
-	int rest_bytes;
 
 	/* find audiocontrol interface */
 	host_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];
-	control_header = snd_usb_find_csint_desc(host_iface->extra,
-						 host_iface->extralen,
-						 NULL, UAC_HEADER);
 	altsd = get_iface_desc(host_iface);
 	protocol = altsd->bInterfaceProtocol;
 
-	if (!control_header) {
-		dev_err(&dev->dev, "cannot find UAC_HEADER\n");
-		return -EINVAL;
-	}
-
-	rest_bytes = (void *)(host_iface->extra + host_iface->extralen) -
-		control_header;
-
-	/* just to be sure -- this shouldn't hit at all */
-	if (rest_bytes <= 0) {
-		dev_err(&dev->dev, "invalid control header\n");
-		return -EINVAL;
-	}
-
 	switch (protocol) {
 	default:
 		dev_warn(&dev->dev,
@@ -255,7 +236,25 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 		/* fall through */
 
 	case UAC_VERSION_1: {
-		struct uac1_ac_header_descriptor *h1 = control_header;
+		struct uac1_ac_header_descriptor *h1;
+		int rest_bytes;
+
+		h1 = snd_usb_find_csint_desc(host_iface->extra,
+							 host_iface->extralen,
+							 NULL, UAC_HEADER);
+		if (!h1) {
+			dev_err(&dev->dev, "cannot find UAC_HEADER\n");
+			return -EINVAL;
+		}
+
+		rest_bytes = (void *)(host_iface->extra +
+				host_iface->extralen) - (void *)h1;
+
+		/* just to be sure -- this shouldn't hit at all */
+		if (rest_bytes <= 0) {
+			dev_err(&dev->dev, "invalid control header\n");
+			return -EINVAL;
+		}
 
 		if (rest_bytes < sizeof(*h1)) {
 			dev_err(&dev->dev, "too short v1 buffer descriptor\n");

commit 07eca5fc3ebad1d33bc12a2f09670c0edd8e6eb6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 2 14:45:37 2018 +0200

    ALSA: usb-audio: Allow to override the longname string
    
    Historically USB-audio driver sets the card's longname field with the
    details of the device and the bus information.  It's good per se, but
    not preferable when it's referred as the identifier for UCM profile.
    
    This patch adds a quirk profile_name field to override the card's
    longname string to a pre-defined one, so that one can create a unique
    and consistent ID string for the specific USB device via a quirk table
    to be used as a UCM profile name.
    
    The patch does a slight code refactoring to split out the functions to
    set shortname and longname fields as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 4a1c6bb3dfa0..36c289bae169 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -349,6 +349,90 @@ static int snd_usb_audio_dev_free(struct snd_device *device)
 	return snd_usb_audio_free(chip);
 }
 
+static void usb_audio_make_shortname(struct usb_device *dev,
+				     struct snd_usb_audio *chip,
+				     const struct snd_usb_audio_quirk *quirk)
+{
+	struct snd_card *card = chip->card;
+
+	if (quirk && quirk->product_name && *quirk->product_name) {
+		strlcpy(card->shortname, quirk->product_name,
+			sizeof(card->shortname));
+		return;
+	}
+
+	/* retrieve the device string as shortname */
+	if (!dev->descriptor.iProduct ||
+	    usb_string(dev, dev->descriptor.iProduct,
+		       card->shortname, sizeof(card->shortname)) <= 0) {
+		/* no name available from anywhere, so use ID */
+		sprintf(card->shortname, "USB Device %#04x:%#04x",
+			USB_ID_VENDOR(chip->usb_id),
+			USB_ID_PRODUCT(chip->usb_id));
+	}
+
+	strim(card->shortname);
+}
+
+static void usb_audio_make_longname(struct usb_device *dev,
+				    struct snd_usb_audio *chip,
+				    const struct snd_usb_audio_quirk *quirk)
+{
+	struct snd_card *card = chip->card;
+	int len;
+
+	/* shortcut - if any pre-defined string is given, use it */
+	if (quirk && quirk->profile_name && *quirk->profile_name) {
+		strlcpy(card->longname, quirk->profile_name,
+			sizeof(card->longname));
+		return;
+	}
+
+	if (quirk && quirk->vendor_name && *quirk->vendor_name) {
+		len = strlcpy(card->longname, quirk->vendor_name, sizeof(card->longname));
+	} else {
+		/* retrieve the vendor and device strings as longname */
+		if (dev->descriptor.iManufacturer)
+			len = usb_string(dev, dev->descriptor.iManufacturer,
+					 card->longname, sizeof(card->longname));
+		else
+			len = 0;
+		/* we don't really care if there isn't any vendor string */
+	}
+	if (len > 0) {
+		strim(card->longname);
+		if (*card->longname)
+			strlcat(card->longname, " ", sizeof(card->longname));
+	}
+
+	strlcat(card->longname, card->shortname, sizeof(card->longname));
+
+	len = strlcat(card->longname, " at ", sizeof(card->longname));
+
+	if (len < sizeof(card->longname))
+		usb_make_path(dev, card->longname + len, sizeof(card->longname) - len);
+
+	switch (snd_usb_get_speed(dev)) {
+	case USB_SPEED_LOW:
+		strlcat(card->longname, ", low speed", sizeof(card->longname));
+		break;
+	case USB_SPEED_FULL:
+		strlcat(card->longname, ", full speed", sizeof(card->longname));
+		break;
+	case USB_SPEED_HIGH:
+		strlcat(card->longname, ", high speed", sizeof(card->longname));
+		break;
+	case USB_SPEED_SUPER:
+		strlcat(card->longname, ", super speed", sizeof(card->longname));
+		break;
+	case USB_SPEED_SUPER_PLUS:
+		strlcat(card->longname, ", super speed plus", sizeof(card->longname));
+		break;
+	default:
+		break;
+	}
+}
+
 /*
  * create a chip instance and set its names.
  */
@@ -360,7 +444,7 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 {
 	struct snd_card *card;
 	struct snd_usb_audio *chip;
-	int err, len;
+	int err;
 	char component[14];
 	static struct snd_device_ops ops = {
 		.dev_free =	snd_usb_audio_dev_free,
@@ -422,64 +506,8 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 		USB_ID_VENDOR(chip->usb_id), USB_ID_PRODUCT(chip->usb_id));
 	snd_component_add(card, component);
 
-	/* retrieve the device string as shortname */
-	if (quirk && quirk->product_name && *quirk->product_name) {
-		strlcpy(card->shortname, quirk->product_name, sizeof(card->shortname));
-	} else {
-		if (!dev->descriptor.iProduct ||
-		    usb_string(dev, dev->descriptor.iProduct,
-		    card->shortname, sizeof(card->shortname)) <= 0) {
-			/* no name available from anywhere, so use ID */
-			sprintf(card->shortname, "USB Device %#04x:%#04x",
-				USB_ID_VENDOR(chip->usb_id),
-				USB_ID_PRODUCT(chip->usb_id));
-		}
-	}
-	strim(card->shortname);
-
-	/* retrieve the vendor and device strings as longname */
-	if (quirk && quirk->vendor_name && *quirk->vendor_name) {
-		len = strlcpy(card->longname, quirk->vendor_name, sizeof(card->longname));
-	} else {
-		if (dev->descriptor.iManufacturer)
-			len = usb_string(dev, dev->descriptor.iManufacturer,
-					 card->longname, sizeof(card->longname));
-		else
-			len = 0;
-		/* we don't really care if there isn't any vendor string */
-	}
-	if (len > 0) {
-		strim(card->longname);
-		if (*card->longname)
-			strlcat(card->longname, " ", sizeof(card->longname));
-	}
-
-	strlcat(card->longname, card->shortname, sizeof(card->longname));
-
-	len = strlcat(card->longname, " at ", sizeof(card->longname));
-
-	if (len < sizeof(card->longname))
-		usb_make_path(dev, card->longname + len, sizeof(card->longname) - len);
-
-	switch (snd_usb_get_speed(dev)) {
-	case USB_SPEED_LOW:
-		strlcat(card->longname, ", low speed", sizeof(card->longname));
-		break;
-	case USB_SPEED_FULL:
-		strlcat(card->longname, ", full speed", sizeof(card->longname));
-		break;
-	case USB_SPEED_HIGH:
-		strlcat(card->longname, ", high speed", sizeof(card->longname));
-		break;
-	case USB_SPEED_SUPER:
-		strlcat(card->longname, ", super speed", sizeof(card->longname));
-		break;
-	case USB_SPEED_SUPER_PLUS:
-		strlcat(card->longname, ", super speed plus", sizeof(card->longname));
-		break;
-	default:
-		break;
-	}
+	usb_audio_make_shortname(dev, chip, quirk);
+	usb_audio_make_longname(dev, chip, quirk);
 
 	snd_usb_audio_create_proc(chip);
 

commit 9a2fe9b801f585baccf8352d82839dcd54b300cf
Author: Ruslan Bilovol <ruslan.bilovol@gmail.com>
Date:   Wed Mar 21 02:03:59 2018 +0200

    ALSA: usb: initial USB Audio Device Class 3.0 support
    
    Recently released USB Audio Class 3.0 specification
    introduces many significant changes comparing to
    previous versions, like
     - new Power Domains, support for LPM/L1
     - new Cluster descriptor
     - changed layout of all class-specific descriptors
     - new High Capability descriptors
     - New class-specific String descriptors
     - new and removed units
     - additional sources for interrupts
     - removed Type II Audio Data Formats
     - ... and many other things (check spec)
    
    It also provides backward compatibility through
    multiple configurations, as well as requires
    mandatory support for BADD (Basic Audio Device
    Definition) on each ADC3.0 compliant device
    
    This patch adds initial support of UAC3 specification
    that is enough for Generic I/O Profile (BAOF, BAIF)
    device support from BADD document.
    
    Signed-off-by: Ruslan Bilovol <ruslan.bilovol@gmail.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 8018d56cfecc..4a1c6bb3dfa0 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -7,6 +7,7 @@
  *	    Alan Cox (alan@lxorguk.ukuu.org.uk)
  *	    Thomas Sailer (sailer@ife.ee.ethz.ch)
  *
+ *   Audio Class 3.0 support by Ruslan Bilovol <ruslan.bilovol@gmail.com>
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -44,6 +45,7 @@
 #include <linux/mutex.h>
 #include <linux/usb/audio.h>
 #include <linux/usb/audio-v2.h>
+#include <linux/usb/audio-v3.h>
 #include <linux/module.h>
 
 #include <sound/control.h>
@@ -281,7 +283,8 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 		break;
 	}
 
-	case UAC_VERSION_2: {
+	case UAC_VERSION_2:
+	case UAC_VERSION_3: {
 		struct usb_interface_assoc_descriptor *assoc =
 			usb_ifnum_to_if(dev, ctrlif)->intf_assoc;
 
@@ -301,7 +304,7 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 		}
 
 		if (!assoc) {
-			dev_err(&dev->dev, "Audio class v2 interfaces need an interface association\n");
+			dev_err(&dev->dev, "Audio class v2/v3 interfaces need an interface association\n");
 			return -EINVAL;
 		}
 

commit 108884e6c5aa731c6704000e27444d51d090078b
Author: Tamaki Nishino <otamachan@gmail.com>
Date:   Thu Nov 30 20:27:52 2017 +0900

    ALSA: usb-audio: Change the semantics of the enable option
    
    This patch changes the semantics of the enable option for snd-usb-audio
    in order to allow users to disable a device specified by either or both
    of the vendor id and the product id.
    
    Signed-off-by: Tamaki Nishino <otamachan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 23d1d23aefec..8018d56cfecc 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -585,15 +585,24 @@ static int usb_audio_probe(struct usb_interface *intf,
 		 * now look for an empty slot and create a new card instance
 		 */
 		for (i = 0; i < SNDRV_CARDS; i++)
-			if (enable[i] && ! usb_chip[i] &&
+			if (!usb_chip[i] &&
 			    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&
 			    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {
-				err = snd_usb_audio_create(intf, dev, i, quirk,
-							   id, &chip);
-				if (err < 0)
+				if (enable[i]) {
+					err = snd_usb_audio_create(intf, dev, i, quirk,
+								   id, &chip);
+					if (err < 0)
+						goto __error;
+					chip->pm_intf = intf;
+					break;
+				} else if (vid[i] != -1 || pid[i] != -1) {
+					dev_info(&dev->dev,
+						 "device (%04x:%04x) is disabled\n",
+						 USB_ID_VENDOR(id),
+						 USB_ID_PRODUCT(id));
+					err = -ENOENT;
 					goto __error;
-				chip->pm_intf = intf;
-				break;
+				}
 			}
 		if (!chip) {
 			dev_err(&dev->dev, "no available usb audio device\n");

commit bfc81a8bc18e3c4ba0cbaa7666ff76be2f998991
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 22 16:18:53 2017 +0200

    ALSA: usb-audio: Check out-of-bounds access by corrupted buffer descriptor
    
    When a USB-audio device receives a maliciously adjusted or corrupted
    buffer descriptor, the USB-audio driver may access an out-of-bounce
    value at its parser.  This was detected by syzkaller, something like:
    
      BUG: KASAN: slab-out-of-bounds in usb_audio_probe+0x27b2/0x2ab0
      Read of size 1 at addr ffff88006b83a9e8 by task kworker/0:1/24
      CPU: 0 PID: 24 Comm: kworker/0:1 Not tainted 4.14.0-rc1-42251-gebb2c2437d80 #224
      Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
      Workqueue: usb_hub_wq hub_event
      Call Trace:
       __dump_stack lib/dump_stack.c:16
       dump_stack+0x292/0x395 lib/dump_stack.c:52
       print_address_description+0x78/0x280 mm/kasan/report.c:252
       kasan_report_error mm/kasan/report.c:351
       kasan_report+0x22f/0x340 mm/kasan/report.c:409
       __asan_report_load1_noabort+0x19/0x20 mm/kasan/report.c:427
       snd_usb_create_streams sound/usb/card.c:248
       usb_audio_probe+0x27b2/0x2ab0 sound/usb/card.c:605
       usb_probe_interface+0x35d/0x8e0 drivers/usb/core/driver.c:361
       really_probe drivers/base/dd.c:413
       driver_probe_device+0x610/0xa00 drivers/base/dd.c:557
       __device_attach_driver+0x230/0x290 drivers/base/dd.c:653
       bus_for_each_drv+0x161/0x210 drivers/base/bus.c:463
       __device_attach+0x26e/0x3d0 drivers/base/dd.c:710
       device_initial_probe+0x1f/0x30 drivers/base/dd.c:757
       bus_probe_device+0x1eb/0x290 drivers/base/bus.c:523
       device_add+0xd0b/0x1660 drivers/base/core.c:1835
       usb_set_configuration+0x104e/0x1870 drivers/usb/core/message.c:1932
       generic_probe+0x73/0xe0 drivers/usb/core/generic.c:174
       usb_probe_device+0xaf/0xe0 drivers/usb/core/driver.c:266
       really_probe drivers/base/dd.c:413
       driver_probe_device+0x610/0xa00 drivers/base/dd.c:557
       __device_attach_driver+0x230/0x290 drivers/base/dd.c:653
       bus_for_each_drv+0x161/0x210 drivers/base/bus.c:463
       __device_attach+0x26e/0x3d0 drivers/base/dd.c:710
       device_initial_probe+0x1f/0x30 drivers/base/dd.c:757
       bus_probe_device+0x1eb/0x290 drivers/base/bus.c:523
       device_add+0xd0b/0x1660 drivers/base/core.c:1835
       usb_new_device+0x7b8/0x1020 drivers/usb/core/hub.c:2457
       hub_port_connect drivers/usb/core/hub.c:4903
       hub_port_connect_change drivers/usb/core/hub.c:5009
       port_event drivers/usb/core/hub.c:5115
       hub_event+0x194d/0x3740 drivers/usb/core/hub.c:5195
       process_one_work+0xc7f/0x1db0 kernel/workqueue.c:2119
       worker_thread+0x221/0x1850 kernel/workqueue.c:2253
       kthread+0x3a1/0x470 kernel/kthread.c:231
       ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:431
    
    This patch adds the checks of out-of-bounce accesses at appropriate
    places and bails out when it goes out of the given buffer.
    
    Reported-by: Andrey Konovalov <andreyknvl@google.com>
    Tested-by: Andrey Konovalov <andreyknvl@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 3dc36d913550..23d1d23aefec 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -221,6 +221,7 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 	struct usb_interface_descriptor *altsd;
 	void *control_header;
 	int i, protocol;
+	int rest_bytes;
 
 	/* find audiocontrol interface */
 	host_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];
@@ -235,6 +236,15 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 		return -EINVAL;
 	}
 
+	rest_bytes = (void *)(host_iface->extra + host_iface->extralen) -
+		control_header;
+
+	/* just to be sure -- this shouldn't hit at all */
+	if (rest_bytes <= 0) {
+		dev_err(&dev->dev, "invalid control header\n");
+		return -EINVAL;
+	}
+
 	switch (protocol) {
 	default:
 		dev_warn(&dev->dev,
@@ -245,11 +255,21 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 	case UAC_VERSION_1: {
 		struct uac1_ac_header_descriptor *h1 = control_header;
 
+		if (rest_bytes < sizeof(*h1)) {
+			dev_err(&dev->dev, "too short v1 buffer descriptor\n");
+			return -EINVAL;
+		}
+
 		if (!h1->bInCollection) {
 			dev_info(&dev->dev, "skipping empty audio interface (v1)\n");
 			return -EINVAL;
 		}
 
+		if (rest_bytes < h1->bLength) {
+			dev_err(&dev->dev, "invalid buffer length (v1)\n");
+			return -EINVAL;
+		}
+
 		if (h1->bLength < sizeof(*h1) + h1->bInCollection) {
 			dev_err(&dev->dev, "invalid UAC_HEADER (v1)\n");
 			return -EINVAL;

commit 8824ae2de876f7e73ca64937dca88e558db5b681
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Sun Aug 6 12:18:56 2017 +0530

    ALSA: usb-audio: constify usb_device_id.
    
    usb_device_id are not supposed to change at runtime. All functions
    working with usb_device_id provided by <linux/usb.h> work with
    const usb_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 6640277a725b..3dc36d913550 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -486,7 +486,7 @@ static bool get_alias_id(struct usb_device *dev, unsigned int *id)
 	return false;
 }
 
-static struct usb_device_id usb_audio_ids[]; /* defined below */
+static const struct usb_device_id usb_audio_ids[]; /* defined below */
 
 /* look for the corresponding quirk */
 static const struct snd_usb_audio_quirk *
@@ -814,7 +814,7 @@ static int usb_audio_reset_resume(struct usb_interface *intf)
 #define usb_audio_reset_resume	NULL
 #endif		/* CONFIG_PM */
 
-static struct usb_device_id usb_audio_ids [] = {
+static const struct usb_device_id usb_audio_ids [] = {
 #include "quirks-table.h"
     { .match_flags = (USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS),
       .bInterfaceClass = USB_CLASS_AUDIO,

commit 03a1f48e5371a252b3b8c16a7cbea3c0bd8689bb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 31 11:19:19 2017 +0200

    ALSA: usb-audio: Fake also USB device id when alias is given
    
    Recently snd-usb-audio driver received a new option, quirk_alias, to
    allow user to apply the existing quirk for a different device.  This
    works for many quirks as is, but some still need more tune-ups:
    namely, some quirks check the USB vendor/device IDs in various places,
    thus it doesn't work as long as the ID is different from the expected
    one.
    
    With this patch, the driver stores the aliased USB ID, so that these
    rest quirks per device ID are applied.  The transition to use the
    cached USB ID was already done in the past, so what we needed now is
    only to overwrite chip->usb_id.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index f36cb068dad3..6640277a725b 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -332,6 +332,7 @@ static int snd_usb_audio_dev_free(struct snd_device *device)
 static int snd_usb_audio_create(struct usb_interface *intf,
 				struct usb_device *dev, int idx,
 				const struct snd_usb_audio_quirk *quirk,
+				unsigned int usb_id,
 				struct snd_usb_audio **rchip)
 {
 	struct snd_card *card;
@@ -381,8 +382,7 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 	atomic_set(&chip->usage_count, 0);
 	atomic_set(&chip->shutdown, 0);
 
-	chip->usb_id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),
-			      le16_to_cpu(dev->descriptor.idProduct));
+	chip->usb_id = usb_id;
 	INIT_LIST_HEAD(&chip->pcm_list);
 	INIT_LIST_HEAD(&chip->ep_list);
 	INIT_LIST_HEAD(&chip->midi_list);
@@ -569,7 +569,7 @@ static int usb_audio_probe(struct usb_interface *intf,
 			    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&
 			    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {
 				err = snd_usb_audio_create(intf, dev, i, quirk,
-							   &chip);
+							   id, &chip);
 				if (err < 0)
 					goto __error;
 				chip->pm_intf = intf;

commit 4763601a56f155ddf94ef35fc2c41504a2de15f5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 29 22:28:40 2016 +0100

    ALSA: usb-audio: Fix bogus error return in snd_usb_create_stream()
    
    The function returns -EINVAL even if it builds the stream properly.
    The bogus error code sneaked in during the code refactoring, but it
    wasn't noticed until now since the returned error code itself is
    ignored in anyway.  Kill it here, but there is no behavior change by
    this patch, obviously.
    
    Fixes: e5779998bf8b ('ALSA: usb-audio: refactor code')
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 2ddc034673a8..f36cb068dad3 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -206,7 +206,6 @@ static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int int
 	if (! snd_usb_parse_audio_interface(chip, interface)) {
 		usb_set_interface(dev, interface, 0); /* reset the current interface */
 		usb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);
-		return -EINVAL;
 	}
 
 	return 0;

commit 6ff1a25318ebf688ef9593fe09cd449f6fb4ad31
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 14 21:46:47 2016 +0100

    ALSA: usb-audio: Fix use-after-free of usb_device at disconnect
    
    The usb-audio driver implements the deferred device disconnection for
    the device in use.  In this mode, the disconnection callback returns
    immediately while the actual ALSA card object removal happens later
    when all files get closed.  As Shuah reported, this code flow,
    however, leads to a use-after-free, detected by KASAN:
    
     BUG: KASAN: use-after-free in snd_usb_audio_free+0x134/0x160 [snd_usb_audio] at addr ffff8801c863ce10
     Write of size 8 by task pulseaudio/2244
     Call Trace:
      [<ffffffff81b31473>] dump_stack+0x67/0x94
      [<ffffffff81564ef1>] kasan_object_err+0x21/0x70
      [<ffffffff8156518a>] kasan_report_error+0x1fa/0x4e0
      [<ffffffff81564ad7>] ? kasan_slab_free+0x87/0xb0
      [<ffffffff81565733>] __asan_report_store8_noabort+0x43/0x50
      [<ffffffffa0fc0f54>] ? snd_usb_audio_free+0x134/0x160 [snd_usb_audio]
      [<ffffffffa0fc0f54>] snd_usb_audio_free+0x134/0x160 [snd_usb_audio]
      [<ffffffffa0fc0fb1>] snd_usb_audio_dev_free+0x31/0x40 [snd_usb_audio]
      [<ffffffff8243c78a>] __snd_device_free+0x12a/0x210
      [<ffffffff8243d1f5>] snd_device_free_all+0x85/0xd0
      [<ffffffff8242cae4>] release_card_device+0x34/0x130
      [<ffffffff81ef1846>] device_release+0x76/0x1e0
      [<ffffffff81b37ad7>] kobject_release+0x107/0x370
      .....
     Object at ffff8801c863cc80, in cache kmalloc-2048 size: 2048
     Allocated:
      [<ffffffff810804eb>] save_stack_trace+0x2b/0x50
      [<ffffffff81564296>] save_stack+0x46/0xd0
      [<ffffffff8156450d>] kasan_kmalloc+0xad/0xe0
      [<ffffffff81560d1a>] kmem_cache_alloc_trace+0xfa/0x240
      [<ffffffff8214ea47>] usb_alloc_dev+0x57/0xc90
      [<ffffffff8216349d>] hub_event+0xf1d/0x35f0
      ....
     Freed:
      [<ffffffff810804eb>] save_stack_trace+0x2b/0x50
      [<ffffffff81564296>] save_stack+0x46/0xd0
      [<ffffffff81564ac1>] kasan_slab_free+0x71/0xb0
      [<ffffffff81560929>] kfree+0xd9/0x280
      [<ffffffff8214de6e>] usb_release_dev+0xde/0x110
      [<ffffffff81ef1846>] device_release+0x76/0x1e0
      ....
    
    It's the code trying to clear drvdata of the assigned usb_device where
    the usb_device itself was already released in usb_release_dev() after
    the disconnect callback.
    
    This patch fixes it by checking whether the code path is via the
    disconnect callback, i.e. chip->shutdown flag is set.
    
    Fixes: 79289e24194a ('ALSA: usb-audio: Refer to chip->usb_id for quirks...')
    Reported-and-tested-by: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: <stable@vger.kernel.org> # v4.6+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 9e5276d6dda0..2ddc034673a8 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -315,7 +315,8 @@ static int snd_usb_audio_free(struct snd_usb_audio *chip)
 		snd_usb_endpoint_free(ep);
 
 	mutex_destroy(&chip->mutex);
-	dev_set_drvdata(&chip->dev->dev, NULL);
+	if (!atomic_read(&chip->shutdown))
+		dev_set_drvdata(&chip->dev->dev, NULL);
 	kfree(chip);
 	return 0;
 }

commit 76df52969711ae3725a98f26fbbc6a349803dcbf
Author: Kazuki Oikawa <k@oikw.org>
Date:   Mon Jul 18 01:16:15 2016 +0900

    ALSA: usb-audio: Fix quirks code is not called
    
    snd_usb_{set_interface,ctl_msg}_quirk checks chip->usb_id to need
    calling a quirks code. But existed code path that not calling
    dev_set_drvdata in usb_audio_probe.
    
    Fixes: 79289e24194a ("ALSA: usb-audio: Refer to chip->usb_id for quirks and MIDI creation")
    Signed-off-by: Kazuki Oikawa <k@oikw.org>
    Cc: <stable@vger.kernel.org> # v4.6+
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Tested-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 69860da473ea..9e5276d6dda0 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -556,7 +556,6 @@ static int usb_audio_probe(struct usb_interface *intf,
 				goto __error;
 			}
 			chip = usb_chip[i];
-			dev_set_drvdata(&dev->dev, chip);
 			atomic_inc(&chip->active); /* avoid autopm */
 			break;
 		}
@@ -582,6 +581,7 @@ static int usb_audio_probe(struct usb_interface *intf,
 			goto __error;
 		}
 	}
+	dev_set_drvdata(&dev->dev, chip);
 
 	/*
 	 * For devices with more than one control interface, we assume the

commit 2e00fde5c6ed8535244332ebb55e881baa54ae46
Merge: 39f0ccde3624 3231e2053eae
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 10 16:06:04 2016 +0200

    Merge branch 'for-linus' into for-next

commit 748a1ccc433f1c4edb214fff4b340af9c1da3f88
Author: Oliver Neukum <ONeukum@suse.com>
Date:   Wed May 4 14:18:39 2016 +0200

    ALSA: usb-audio: correct speed checking
    
    Allow handling SS+ USB devices correctly.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 63244bbba8c7..c4665dc606ca 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -351,6 +351,7 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 	case USB_SPEED_HIGH:
 	case USB_SPEED_WIRELESS:
 	case USB_SPEED_SUPER:
+	case USB_SPEED_SUPER_PLUS:
 		break;
 	default:
 		dev_err(&dev->dev, "unknown device speed %d\n", snd_usb_get_speed(dev));
@@ -451,6 +452,9 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 	case USB_SPEED_SUPER:
 		strlcat(card->longname, ", super speed", sizeof(card->longname));
 		break;
+	case USB_SPEED_SUPER_PLUS:
+		strlcat(card->longname, ", super speed plus", sizeof(card->longname));
+		break;
 	default:
 		break;
 	}

commit c89178f57a19300b2056f58167e183e966a4836d
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Thu Mar 31 09:57:29 2016 -0300

    [media] Revert "[media] sound/usb: Use Media Controller API to share media resources"
    
    Unfortunately, this patch caused several regressions at au0828 and
    snd-usb-audio, like this one:
            https://bugzilla.kernel.org/show_bug.cgi?id=115561
    
    It also showed several troubles at the MC core that handles pretty
    poorly the memory protections and data lifetime management.
    
    So, better to revert it and fix the core before reapplying this
    change.
    
    This reverts commit aebb2b89bff0 ("[media] sound/usb: Use Media
    Controller API to share media resources")'
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 63244bbba8c7..3fc63583a537 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -66,7 +66,6 @@
 #include "format.h"
 #include "power.h"
 #include "stream.h"
-#include "media.h"
 
 MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
 MODULE_DESCRIPTION("USB Audio");
@@ -612,11 +611,6 @@ static int usb_audio_probe(struct usb_interface *intf,
 	if (err < 0)
 		goto __error;
 
-	if (quirk->media_device) {
-		/* don't want to fail when media_snd_device_create() fails */
-		media_snd_device_create(chip, intf);
-	}
-
 	usb_chip[chip->index] = chip;
 	chip->num_interfaces++;
 	usb_set_intfdata(intf, chip);
@@ -673,14 +667,6 @@ static void usb_audio_disconnect(struct usb_interface *intf)
 		list_for_each(p, &chip->midi_list) {
 			snd_usbmidi_disconnect(p);
 		}
-		/*
-		 * Nice to check quirk && quirk->media_device
-		 * need some special handlings. Doesn't look like
-		 * we have access to quirk here
-		 * Acceses mixer_list
-		*/
-		media_snd_device_delete(chip);
-
 		/* release mixer resources */
 		list_for_each_entry(mixer, &chip->mixer_list, list) {
 			snd_usb_mixer_disconnect(mixer);

commit 021f163d696caed5a336fa1569efdd22216da340
Merge: 9ea446352047 222bde03881c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 18 10:05:46 2016 -0700

    Merge tag 'sound-4.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "After a heavy storm by syzkaller in 4.5 cycle, we have relatively few
      changes in the core at this time while a lot of changes are found in
      the driver side, unsurprisingly.  Below are some highlights:
    
      ALSA core:
       - A few more hardening in ALSA timer codes
       - An extension of sequencer API for advertising the card / pid
       - Small fixes in compress-offload and jack layers
    
      HD-audio:
       - Dynamic PCM assignment in HDMI/DP codec; preparation for upcoming
         DP-MST support
       - Lots of code refactoring for sharing with ASoC SKL driver
       - Regression fixes for Intel HDMI/DP
       - Fixups for CX20724 codec, Lenovo AiO
    
      USB-audio:
       - Add quirk_alias option to make quirk debugging easier
       - Fixes for possible Oops by malformed firmware
    
      Firewire:
       - Add support for FW-1804 in tascam driver
       - Improvements / changes in card registration, multi stream handling,
         etc for DICE
       - Lots of code refactoring
    
      ASoC:
       - Enhancements of still ongoing topology API
       - Lots of commits for Intel Skylake support including HDMI support
       - A few Intel Atom driver updates for recent devices
       - Lots of improvements to the Renesas drivers
       - Capture support for Qualcomm drivers
       - Support for TI DaVinci DRA7xxx devices
       - New machine drivers for Freescale systems with Cirrus CODECs,
         Mediatek systems with RT5650 CODECs
       - New CPU drivers for Allwinner S/PDIF controllers
       - New CODEC drivers for Maxim MAX9867 and MAX98926 and Realtek RT5514"
    
    * tag 'sound-4.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (291 commits)
      ALSA: hda - Fix mutex deadlock at HDMI/DP hotplug
      ALSA: ctl: change return value in compatibility layer so that it's the same value in core implementation
      ALSA: mixart: silence an uninitialized variable warning
      ALSA: usb-audio: Add sanity checks for endpoint accesses
      ALSA: usb-audio: Minor code cleanup in create_fixed_stream_quirk()
      ALSA: usb-audio: Fix NULL dereference in create_fixed_stream_quirk()
      ALSA: hda - Limit i915 HDMI binding only for HSW and later
      ALSA: hda - Fix unconditional GPIO toggle via automute
      ALSA: mixart: silence unitialized variable warnings
      ALSA: hda - Fixes double fault in nvhdmi_chmap_cea_alloc_validate_get_type
      ALSA: intel8x0: Add clock quirk entry for AD1981B on IBM ThinkPad X41.
      ALSA: hda - Add new GPU codec ID 0x10de0082 to snd-hda
      ASoC: rsnd: add simplified module explanation
      ASoC: hdac_hdmi: Add broxton device ID
      ASoC: Intel: Bxtn: Add Broxton PCI ID
      ASoC: Intel: Skylake: Move Skylake dsp ops & loader ops
      ASoC: Intel: add dmabuffer to common sst_dsp
      ASoC: Intel: Skylake: Unstatify skl_dsp_enable_core
      ASoC: Intel: Skylake: Fix whitepsace issues
      ASoC: Intel: Skylake: Move module id defines
      ...

commit aebb2b89bff0fdeb4e7ddd73dcbccde1a0f27554
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Wed Mar 2 13:50:31 2016 -0300

    [media] sound/usb: Use Media Controller API to share media resources
    
    Change ALSA driver to use Media Controller API to share media resources
    with DVB and V4L2 drivers on a AU0828 media device. Media Controller
    specific initialization is done after sound card is registered. ALSA
    creates Media interface and entity function graph nodes for Control,
    Mixer, PCM Playback, and PCM Capture devices.
    
    snd_usb_hw_params() will call Media Controller enable source handler
    interface to request the media resource. If resource request is
    granted, it will release it from snd_usb_hw_free(). If resource is
    busy, -EBUSY is returned.
    
    Media specific cleanup is done in usb_audio_disconnect().
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 1f09d9591276..258cf7015ce2 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -66,6 +66,7 @@
 #include "format.h"
 #include "power.h"
 #include "stream.h"
+#include "media.h"
 
 MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
 MODULE_DESCRIPTION("USB Audio");
@@ -561,6 +562,11 @@ static int usb_audio_probe(struct usb_interface *intf,
 	if (err < 0)
 		goto __error;
 
+	if (quirk->media_device) {
+		/* don't want to fail when media_snd_device_create() fails */
+		media_snd_device_create(chip, intf);
+	}
+
 	usb_chip[chip->index] = chip;
 	chip->num_interfaces++;
 	usb_set_intfdata(intf, chip);
@@ -617,6 +623,14 @@ static void usb_audio_disconnect(struct usb_interface *intf)
 		list_for_each(p, &chip->midi_list) {
 			snd_usbmidi_disconnect(p);
 		}
+		/*
+		 * Nice to check quirk && quirk->media_device
+		 * need some special handlings. Doesn't look like
+		 * we have access to quirk here
+		 * Acceses mixer_list
+		*/
+		media_snd_device_delete(chip);
+
 		/* release mixer resources */
 		list_for_each_entry(mixer, &chip->mixer_list, list) {
 			snd_usb_mixer_disconnect(mixer);

commit e2703363316278cd4a8880671d38f783f7de18ba
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 11 14:39:12 2016 +0100

    ALSA: usb-audio: Add quirk_alias option
    
    This patch adds a new option "quirk_alias" to snd-usb-audio driver for
    allowing user to pass the quirk alias list.  A quirk alias consists of
    a string form like 0123abcd:5678beef, which makes to apply a quirk to
    a device with USB ID 0123:abcd treated as if it were 5678:beef.
    This feature is useful to test an existing quirk, typically for a
    newer model of the same vendor, without patching / rebuilding the
    kernel driver.
    
    The current implementation is fairly simplistic: since there is no API
    for matching a usb_device_id to the given ID pair, it has an open code
    to loop over the id table and matches only with vendor:product pair.
    So far, this is OK, as all existing entries are with vendor:product
    pairs, indeed.  Once when we have another matching entry, however,
    we'd need to update get_alias_quirk() as well.
    
    Note that this option is provided only for testing / development.  If
    you want to have a proper support, contact to upstream for adding the
    matching quirk in the driver code statically.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 2c0269014b85..3fc63583a537 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -82,6 +82,7 @@ static int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };
 static int device_setup[SNDRV_CARDS]; /* device parameter for this card */
 static bool ignore_ctl_error;
 static bool autoclock = true;
+static char *quirk_alias[SNDRV_CARDS];
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for the USB audio adapter.");
@@ -100,6 +101,8 @@ MODULE_PARM_DESC(ignore_ctl_error,
 		 "Ignore errors from USB controller for mixer interfaces.");
 module_param(autoclock, bool, 0444);
 MODULE_PARM_DESC(autoclock, "Enable auto-clock selection for UAC2 devices (default: yes).");
+module_param_array(quirk_alias, charp, NULL, 0444);
+MODULE_PARM_DESC(quirk_alias, "Quirk aliases, e.g. 0123abcd:5678beef.");
 
 /*
  * we keep the snd_usb_audio_t instances by ourselves for merging
@@ -457,6 +460,48 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 	return 0;
 }
 
+/* look for a matching quirk alias id */
+static bool get_alias_id(struct usb_device *dev, unsigned int *id)
+{
+	int i;
+	unsigned int src, dst;
+
+	for (i = 0; i < ARRAY_SIZE(quirk_alias); i++) {
+		if (!quirk_alias[i] ||
+		    sscanf(quirk_alias[i], "%x:%x", &src, &dst) != 2 ||
+		    src != *id)
+			continue;
+		dev_info(&dev->dev,
+			 "device (%04x:%04x): applying quirk alias %04x:%04x\n",
+			 USB_ID_VENDOR(*id), USB_ID_PRODUCT(*id),
+			 USB_ID_VENDOR(dst), USB_ID_PRODUCT(dst));
+		*id = dst;
+		return true;
+	}
+
+	return false;
+}
+
+static struct usb_device_id usb_audio_ids[]; /* defined below */
+
+/* look for the corresponding quirk */
+static const struct snd_usb_audio_quirk *
+get_alias_quirk(struct usb_device *dev, unsigned int id)
+{
+	const struct usb_device_id *p;
+
+	for (p = usb_audio_ids; p->match_flags; p++) {
+		/* FIXME: this checks only vendor:product pair in the list */
+		if ((p->match_flags & USB_DEVICE_ID_MATCH_DEVICE) ==
+		    USB_DEVICE_ID_MATCH_DEVICE &&
+		    p->idVendor == USB_ID_VENDOR(id) &&
+		    p->idProduct == USB_ID_PRODUCT(id))
+			return (const struct snd_usb_audio_quirk *)p->driver_info;
+	}
+
+	return NULL;
+}
+
 /*
  * probe the active usb device
  *
@@ -483,6 +528,8 @@ static int usb_audio_probe(struct usb_interface *intf,
 	ifnum = get_iface_desc(alts)->bInterfaceNumber;
 	id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),
 		    le16_to_cpu(dev->descriptor.idProduct));
+	if (get_alias_id(dev, &id))
+		quirk = get_alias_quirk(dev, id);
 	if (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)
 		return -ENXIO;
 

commit 79289e24194a9d099bf18f200894832c5760cd83
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 11 11:33:34 2016 +0100

    ALSA: usb-audio: Refer to chip->usb_id for quirks and MIDI creation
    
    This is a preliminary patch for the later change to allow a better
    quirk ID management.  In the current USB-audio code, there are a few
    places looking at usb_device idVendor and idProduct fields directly
    even though we have already a static member in snd_usb_audio.usb_id.
    This patch modifies such codes to refer to the latter field.
    
    For achieving this, two slightly intensive changes have been done:
    - The snd_usb_audio object is set/reset via dev_getdrv() for the given
      USB device; it's needed for minimizing the changes for some existing
      quirks that take only usb_device object.
    
    - __snd_usbmidi_create() is introduced to receive the pre-given usb_id
      argument.  The exported snd_usbmidi_create() is unchanged by calling
      this new function internally.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 1f09d9591276..2c0269014b85 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -171,8 +171,9 @@ static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int int
 	if ((altsd->bInterfaceClass == USB_CLASS_AUDIO ||
 	     altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC) &&
 	    altsd->bInterfaceSubClass == USB_SUBCLASS_MIDISTREAMING) {
-		int err = snd_usbmidi_create(chip->card, iface,
-					     &chip->midi_list, NULL);
+		int err = __snd_usbmidi_create(chip->card, iface,
+					     &chip->midi_list, NULL,
+					     chip->usb_id);
 		if (err < 0) {
 			dev_err(&dev->dev,
 				"%u:%d: cannot create sequencer device\n",
@@ -311,6 +312,7 @@ static int snd_usb_audio_free(struct snd_usb_audio *chip)
 		snd_usb_endpoint_free(ep);
 
 	mutex_destroy(&chip->mutex);
+	dev_set_drvdata(&chip->dev->dev, NULL);
 	kfree(chip);
 	return 0;
 }
@@ -484,7 +486,7 @@ static int usb_audio_probe(struct usb_interface *intf,
 	if (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)
 		return -ENXIO;
 
-	err = snd_usb_apply_boot_quirk(dev, intf, quirk);
+	err = snd_usb_apply_boot_quirk(dev, intf, quirk, id);
 	if (err < 0)
 		return err;
 
@@ -503,6 +505,7 @@ static int usb_audio_probe(struct usb_interface *intf,
 				goto __error;
 			}
 			chip = usb_chip[i];
+			dev_set_drvdata(&dev->dev, chip);
 			atomic_inc(&chip->active); /* avoid autopm */
 			break;
 		}

commit 5c06d68bc2a174a6b82dce9f100f55173b9a5189
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 12 14:03:33 2016 +0100

    ALSA: usb-audio: Avoid calling usb_autopm_put_interface() at disconnect
    
    ALSA PCM may still have a leftover instance after disconnection and
    it delays its release.  The problem is that the PCM close code path of
    USB-audio driver has a call of snd_usb_autosuspend().  This involves
    with the call of usb_autopm_put_interface() and it may lead to a
    kernel Oops due to the NULL object like:
    
     BUG: unable to handle kernel NULL pointer dereference at 0000000000000190
     IP: [<ffffffff815ae7ef>] usb_autopm_put_interface+0xf/0x30 PGD 0
     Call Trace:
      [<ffffffff8173bd94>] snd_usb_autosuspend+0x14/0x20
      [<ffffffff817461bc>] snd_usb_pcm_close.isra.14+0x5c/0x90
      [<ffffffff8174621f>] snd_usb_playback_close+0xf/0x20
      [<ffffffff816ef58a>] snd_pcm_release_substream.part.36+0x3a/0x90
      [<ffffffff816ef6b3>] snd_pcm_release+0xa3/0xb0
      [<ffffffff816debb0>] snd_disconnect_release+0xd0/0xe0
      [<ffffffff8114d417>] __fput+0x97/0x1d0
      [<ffffffff8114d589>] ____fput+0x9/0x10
      [<ffffffff8109e452>] task_work_run+0x72/0x90
      [<ffffffff81088510>] do_exit+0x280/0xa80
      [<ffffffff8108996a>] do_group_exit+0x3a/0xa0
      [<ffffffff8109261f>] get_signal+0x1df/0x540
      [<ffffffff81040903>] do_signal+0x23/0x620
      [<ffffffff8114c128>] ? do_readv_writev+0x128/0x200
      [<ffffffff810012e1>] prepare_exit_to_usermode+0x91/0xd0
      [<ffffffff810013ba>] syscall_return_slowpath+0x9a/0x120
      [<ffffffff817587cd>] ? __sys_recvmsg+0x5d/0x70
      [<ffffffff810d2765>] ? ktime_get_ts64+0x45/0xe0
      [<ffffffff8115dea0>] ? SyS_poll+0x60/0xf0
      [<ffffffff818d2327>] int_ret_from_sys_call+0x25/0x8f
    
    We have already a check of disconnection in snd_usb_autoresume(), but
    the check is missing its counterpart.  The fix is just to put the same
    check in snd_usb_autosuspend(), too.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=109431
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 18f56646ce86..1f09d9591276 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -675,6 +675,8 @@ int snd_usb_autoresume(struct snd_usb_audio *chip)
 
 void snd_usb_autosuspend(struct snd_usb_audio *chip)
 {
+	if (atomic_read(&chip->shutdown))
+		return;
 	if (atomic_dec_and_test(&chip->active))
 		usb_autopm_put_interface(chip->pm_intf);
 }

commit 0662292aec0528363df037ad7c66bf9949c7ce46
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 26 10:23:26 2015 +0200

    ALSA: usb-audio: Handle normal and auto-suspend equally
    
    In theory, the device may get suspended even at runtime PM suspend.
    Currently we don't save the mixer state for autopm, and it may bring
    inconsistency.
    
    This patch removes the special handling for autosuspend.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 73c5833e7657..18f56646ce86 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -689,30 +689,20 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 	if (chip == (void *)-1L)
 		return 0;
 
-	if (!PMSG_IS_AUTO(message)) {
+	chip->autosuspended = !!PMSG_IS_AUTO(message);
+	if (!chip->autosuspended)
 		snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
-		if (!chip->num_suspended_intf++) {
-			list_for_each_entry(as, &chip->pcm_list, list) {
-				snd_pcm_suspend_all(as->pcm);
-				as->substream[0].need_setup_ep =
-					as->substream[1].need_setup_ep = true;
-			}
-			list_for_each(p, &chip->midi_list) {
-				snd_usbmidi_suspend(p);
-			}
+	if (!chip->num_suspended_intf++) {
+		list_for_each_entry(as, &chip->pcm_list, list) {
+			snd_pcm_suspend_all(as->pcm);
+			as->substream[0].need_setup_ep =
+				as->substream[1].need_setup_ep = true;
 		}
-	} else {
-		/*
-		 * otherwise we keep the rest of the system in the dark
-		 * to keep this transparent
-		 */
-		if (!chip->num_suspended_intf++)
-			chip->autosuspended = 1;
-	}
-
-	if (chip->num_suspended_intf == 1)
+		list_for_each(p, &chip->midi_list)
+			snd_usbmidi_suspend(p);
 		list_for_each_entry(mixer, &chip->mixer_list, list)
 			snd_usb_mixer_suspend(mixer);
+	}
 
 	return 0;
 }

commit a6da499b76b1a75412f047ac388e9ffd69a5c55b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 26 10:20:59 2015 +0200

    ALSA: usb-audio: Replace probing flag with active refcount
    
    We can use active refcount for preventing autopm during probe.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index b6621bcba2dc..73c5833e7657 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -371,7 +371,7 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 	chip->card = card;
 	chip->setup = device_setup[idx];
 	chip->autoclock = autoclock;
-	chip->probing = 1;
+	atomic_set(&chip->active, 1); /* avoid autopm during probing */
 	atomic_set(&chip->usage_count, 0);
 	atomic_set(&chip->shutdown, 0);
 
@@ -503,7 +503,7 @@ static int usb_audio_probe(struct usb_interface *intf,
 				goto __error;
 			}
 			chip = usb_chip[i];
-			chip->probing = 1;
+			atomic_inc(&chip->active); /* avoid autopm */
 			break;
 		}
 	}
@@ -563,8 +563,8 @@ static int usb_audio_probe(struct usb_interface *intf,
 
 	usb_chip[chip->index] = chip;
 	chip->num_interfaces++;
-	chip->probing = 0;
 	usb_set_intfdata(intf, chip);
+	atomic_dec(&chip->active);
 	mutex_unlock(&register_mutex);
 	return 0;
 
@@ -572,7 +572,7 @@ static int usb_audio_probe(struct usb_interface *intf,
 	if (chip) {
 		if (!chip->num_interfaces)
 			snd_card_free(chip->card);
-		chip->probing = 0;
+		atomic_dec(&chip->active);
 	}
 	mutex_unlock(&register_mutex);
 	return err;
@@ -668,8 +668,6 @@ int snd_usb_autoresume(struct snd_usb_audio *chip)
 {
 	if (atomic_read(&chip->shutdown))
 		return -EIO;
-	if (chip->probing)
-		return 0;
 	if (atomic_inc_return(&chip->active) == 1)
 		return usb_autopm_get_interface(chip->pm_intf);
 	return 0;
@@ -677,8 +675,6 @@ int snd_usb_autoresume(struct snd_usb_audio *chip)
 
 void snd_usb_autosuspend(struct snd_usb_audio *chip)
 {
-	if (chip->probing)
-		return;
 	if (atomic_dec_and_test(&chip->active))
 		usb_autopm_put_interface(chip->pm_intf);
 }

commit 47ab154593827b1a8f0713a2b9dd445753d551d8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 25 16:09:00 2015 +0200

    ALSA: usb-audio: Avoid nested autoresume calls
    
    After the recent fix of runtime PM for USB-audio driver, we got a
    lockdep warning like:
    
      =============================================
      [ INFO: possible recursive locking detected ]
      4.2.0-rc8+ #61 Not tainted
      ---------------------------------------------
      pulseaudio/980 is trying to acquire lock:
       (&chip->shutdown_rwsem){.+.+.+}, at: [<ffffffffa0355dac>] snd_usb_autoresume+0x1d/0x52 [snd_usb_audio]
      but task is already holding lock:
       (&chip->shutdown_rwsem){.+.+.+}, at: [<ffffffffa0355dac>] snd_usb_autoresume+0x1d/0x52 [snd_usb_audio]
    
    This comes from snd_usb_autoresume() invoking down_read() and it's
    used in a nested way.  Although it's basically safe, per se (as these
    are read locks), it's better to reduce such spurious warnings.
    
    The read lock is needed to guarantee the execution of "shutdown"
    (cleanup at disconnection) task after all concurrent tasks are
    finished.  This can be implemented in another better way.
    
    Also, the current check of chip->in_pm isn't good enough for
    protecting the racy execution of multiple auto-resumes.
    
    This patch rewrites the logic of snd_usb_autoresume() & co; namely,
    - The recursive call of autopm is avoided by the new refcount,
      chip->active.  The chip->in_pm flag is removed accordingly.
    - Instead of rwsem, another refcount, chip->usage_count, is introduced
      for tracking the period to delay the shutdown procedure.  At
      the last clear of this refcount, wake_up() to the shutdown waiter is
      called.
    - The shutdown flag is replaced with shutdown atomic count; this is
      for reducing the lock.
    - Two new helpers are introduced to simplify the management of these
      refcounts; snd_usb_lock_shutdown() increases the usage_count, checks
      the shutdown state, and does autoresume.  snd_usb_unlock_shutdown()
      does the opposite.  Most of mixer and other codes just need this,
      and simply returns an error if it receives an error from lock.
    
    Fixes: 9003ebb13f61 ('ALSA: usb-audio: Fix runtime PM unbalance')
    Reported-and-tested-by: Alexnader Kuleshov <kuleshovmail@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 0450593980fd..b6621bcba2dc 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -365,13 +365,15 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 	}
 
 	mutex_init(&chip->mutex);
-	init_rwsem(&chip->shutdown_rwsem);
+	init_waitqueue_head(&chip->shutdown_wait);
 	chip->index = idx;
 	chip->dev = dev;
 	chip->card = card;
 	chip->setup = device_setup[idx];
 	chip->autoclock = autoclock;
 	chip->probing = 1;
+	atomic_set(&chip->usage_count, 0);
+	atomic_set(&chip->shutdown, 0);
 
 	chip->usb_id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),
 			      le16_to_cpu(dev->descriptor.idProduct));
@@ -495,7 +497,7 @@ static int usb_audio_probe(struct usb_interface *intf,
 	mutex_lock(&register_mutex);
 	for (i = 0; i < SNDRV_CARDS; i++) {
 		if (usb_chip[i] && usb_chip[i]->dev == dev) {
-			if (usb_chip[i]->shutdown) {
+			if (atomic_read(&usb_chip[i]->shutdown)) {
 				dev_err(&dev->dev, "USB device is in the shutdown state, cannot create a card instance\n");
 				err = -EIO;
 				goto __error;
@@ -585,23 +587,23 @@ static void usb_audio_disconnect(struct usb_interface *intf)
 	struct snd_usb_audio *chip = usb_get_intfdata(intf);
 	struct snd_card *card;
 	struct list_head *p;
-	bool was_shutdown;
 
 	if (chip == (void *)-1L)
 		return;
 
 	card = chip->card;
-	down_write(&chip->shutdown_rwsem);
-	was_shutdown = chip->shutdown;
-	chip->shutdown = 1;
-	up_write(&chip->shutdown_rwsem);
 
 	mutex_lock(&register_mutex);
-	if (!was_shutdown) {
+	if (atomic_inc_return(&chip->shutdown) == 1) {
 		struct snd_usb_stream *as;
 		struct snd_usb_endpoint *ep;
 		struct usb_mixer_interface *mixer;
 
+		/* wait until all pending tasks done;
+		 * they are protected by snd_usb_lock_shutdown()
+		 */
+		wait_event(chip->shutdown_wait,
+			   !atomic_read(&chip->usage_count));
 		snd_card_disconnect(card);
 		/* release the pcm resources */
 		list_for_each_entry(as, &chip->pcm_list, list) {
@@ -631,28 +633,54 @@ static void usb_audio_disconnect(struct usb_interface *intf)
 	}
 }
 
-#ifdef CONFIG_PM
-
-int snd_usb_autoresume(struct snd_usb_audio *chip)
+/* lock the shutdown (disconnect) task and autoresume */
+int snd_usb_lock_shutdown(struct snd_usb_audio *chip)
 {
-	int err = -ENODEV;
+	int err;
 
-	down_read(&chip->shutdown_rwsem);
-	if (chip->probing || chip->in_pm)
-		err = 0;
-	else if (!chip->shutdown)
-		err = usb_autopm_get_interface(chip->pm_intf);
-	up_read(&chip->shutdown_rwsem);
+	atomic_inc(&chip->usage_count);
+	if (atomic_read(&chip->shutdown)) {
+		err = -EIO;
+		goto error;
+	}
+	err = snd_usb_autoresume(chip);
+	if (err < 0)
+		goto error;
+	return 0;
 
+ error:
+	if (atomic_dec_and_test(&chip->usage_count))
+		wake_up(&chip->shutdown_wait);
 	return err;
 }
 
+/* autosuspend and unlock the shutdown */
+void snd_usb_unlock_shutdown(struct snd_usb_audio *chip)
+{
+	snd_usb_autosuspend(chip);
+	if (atomic_dec_and_test(&chip->usage_count))
+		wake_up(&chip->shutdown_wait);
+}
+
+#ifdef CONFIG_PM
+
+int snd_usb_autoresume(struct snd_usb_audio *chip)
+{
+	if (atomic_read(&chip->shutdown))
+		return -EIO;
+	if (chip->probing)
+		return 0;
+	if (atomic_inc_return(&chip->active) == 1)
+		return usb_autopm_get_interface(chip->pm_intf);
+	return 0;
+}
+
 void snd_usb_autosuspend(struct snd_usb_audio *chip)
 {
-	down_read(&chip->shutdown_rwsem);
-	if (!chip->shutdown && !chip->probing && !chip->in_pm)
+	if (chip->probing)
+		return;
+	if (atomic_dec_and_test(&chip->active))
 		usb_autopm_put_interface(chip->pm_intf);
-	up_read(&chip->shutdown_rwsem);
 }
 
 static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
@@ -705,7 +733,7 @@ static int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)
 	if (--chip->num_suspended_intf)
 		return 0;
 
-	chip->in_pm = 1;
+	atomic_inc(&chip->active); /* avoid autopm */
 	/*
 	 * ALSA leaves material resumption to user space
 	 * we just notify and restart the mixers
@@ -725,7 +753,7 @@ static int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)
 	chip->autosuspended = 0;
 
 err_out:
-	chip->in_pm = 0;
+	atomic_dec(&chip->active); /* allow autopm after this point */
 	return err;
 }
 

commit 9003ebb13f61e8c78a641e0dda7775183ada0625
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 19 07:20:14 2015 +0200

    ALSA: usb-audio: Fix runtime PM unbalance
    
    The fix for deadlock in PM in commit [1ee23fe07ee8: ALSA: usb-audio:
    Fix deadlocks at resuming] introduced a new check of in_pm flag.
    However, the brainless patch author evaluated it in a wrong way
    (logical AND instead of logical OR), thus usb_autopm_get_interface()
    is wrongly called at probing, leading to unbalance of runtime PM
    refcount.
    
    This patch fixes it by correcting the logic.
    
    Reported-by: Hans Yang <hansy@nvidia.com>
    Fixes: 1ee23fe07ee8 ('ALSA: usb-audio: Fix deadlocks at resuming')
    Cc: <stable@vger.kernel.org> [v3.15+]
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 1fab9778807a..0450593980fd 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -638,7 +638,7 @@ int snd_usb_autoresume(struct snd_usb_audio *chip)
 	int err = -ENODEV;
 
 	down_read(&chip->shutdown_rwsem);
-	if (chip->probing && chip->in_pm)
+	if (chip->probing || chip->in_pm)
 		err = 0;
 	else if (!chip->shutdown)
 		err = usb_autopm_get_interface(chip->pm_intf);

commit 19566b0bd93c34e4941822ed3c0d76a5abddcf82
Merge: 9161bd0d1cf3 0725dda207e9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 5 15:37:22 2014 +0100

    Merge branch 'for-linus' into for-next
    
    This merges the USB-audio disconnect fix and resolves the conflicts
    so that we can continue working on development of usb-audio stuff.
    
    Conflicts:
            sound/usb/card.c

commit 0725dda207e95ff25f1aa01432250323e0ec49d6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 5 15:08:49 2014 +0100

    ALSA: usb-audio: Fix device_del() sysfs warnings at disconnect
    
    Some USB-audio devices show weird sysfs warnings at disconnecting the
    devices, e.g.
     usb 1-3: USB disconnect, device number 3
     ------------[ cut here ]------------
     WARNING: CPU: 0 PID: 973 at fs/sysfs/group.c:216 device_del+0x39/0x180()
     sysfs group ffffffff8183df40 not found for kobject 'midiC1D0'
     Call Trace:
      [<ffffffff814a3e38>] ? dump_stack+0x49/0x71
      [<ffffffff8103cb72>] ? warn_slowpath_common+0x82/0xb0
      [<ffffffff8103cc55>] ? warn_slowpath_fmt+0x45/0x50
      [<ffffffff813521e9>] ? device_del+0x39/0x180
      [<ffffffff81352339>] ? device_unregister+0x9/0x20
      [<ffffffff81352384>] ? device_destroy+0x34/0x40
      [<ffffffffa00ba29f>] ? snd_unregister_device+0x7f/0xd0 [snd]
      [<ffffffffa025124e>] ? snd_rawmidi_dev_disconnect+0xce/0x100 [snd_rawmidi]
      [<ffffffffa00c0192>] ? snd_device_disconnect+0x62/0x90 [snd]
      [<ffffffffa00c025c>] ? snd_device_disconnect_all+0x3c/0x60 [snd]
      [<ffffffffa00bb574>] ? snd_card_disconnect+0x124/0x1a0 [snd]
      [<ffffffffa02e54e8>] ? usb_audio_disconnect+0x88/0x1c0 [snd_usb_audio]
      [<ffffffffa015260e>] ? usb_unbind_interface+0x5e/0x1b0 [usbcore]
      [<ffffffff813553e9>] ? __device_release_driver+0x79/0xf0
      [<ffffffff81355485>] ? device_release_driver+0x25/0x40
      [<ffffffff81354e11>] ? bus_remove_device+0xf1/0x130
      [<ffffffff813522b9>] ? device_del+0x109/0x180
      [<ffffffffa01501d5>] ? usb_disable_device+0x95/0x1f0 [usbcore]
      [<ffffffffa014634f>] ? usb_disconnect+0x8f/0x190 [usbcore]
      [<ffffffffa0149179>] ? hub_thread+0x539/0x13a0 [usbcore]
      [<ffffffff810669f5>] ? sched_clock_local+0x15/0x80
      [<ffffffff81066c98>] ? sched_clock_cpu+0xb8/0xd0
      [<ffffffff81070730>] ? bit_waitqueue+0xb0/0xb0
      [<ffffffffa0148c40>] ? usb_port_resume+0x430/0x430 [usbcore]
      [<ffffffffa0148c40>] ? usb_port_resume+0x430/0x430 [usbcore]
      [<ffffffff8105973e>] ? kthread+0xce/0xf0
      [<ffffffff81059670>] ? kthread_create_on_node+0x1c0/0x1c0
      [<ffffffff814a8b7c>] ? ret_from_fork+0x7c/0xb0
      [<ffffffff81059670>] ? kthread_create_on_node+0x1c0/0x1c0
     ---[ end trace 40b1928d1136b91e ]---
    
    This comes from the fact that usb-audio driver may receive the
    disconnect callback multiple times, per each usb interface.  When a
    device has both audio and midi interfaces, it gets called twice, and
    currently the driver tries to release resources at the last call.
    At this point, the first parent interface has been already deleted,
    thus deleting a child of the first parent hits such a warning.
    
    For fixing this problem, we need to call snd_card_disconnect() and
    cancel pending operations at the very first disconnect while the
    release of the whole objects waits until the last disconnect call.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=80931
    Reported-and-tested-by: Tomas Gayoso <tgayoso@gmail.com>
    Reported-and-tested-by: Chris J Arges <chris.j.arges@canonical.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 7ecd0e8a5c51..f61ebb17cc64 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -591,18 +591,19 @@ static void snd_usb_audio_disconnect(struct usb_device *dev,
 {
 	struct snd_card *card;
 	struct list_head *p;
+	bool was_shutdown;
 
 	if (chip == (void *)-1L)
 		return;
 
 	card = chip->card;
 	down_write(&chip->shutdown_rwsem);
+	was_shutdown = chip->shutdown;
 	chip->shutdown = 1;
 	up_write(&chip->shutdown_rwsem);
 
 	mutex_lock(&register_mutex);
-	chip->num_interfaces--;
-	if (chip->num_interfaces <= 0) {
+	if (!was_shutdown) {
 		struct snd_usb_endpoint *ep;
 
 		snd_card_disconnect(card);
@@ -622,6 +623,10 @@ static void snd_usb_audio_disconnect(struct usb_device *dev,
 		list_for_each(p, &chip->mixer_list) {
 			snd_usb_mixer_disconnect(p);
 		}
+	}
+
+	chip->num_interfaces--;
+	if (chip->num_interfaces <= 0) {
 		usb_chip[chip->index] = NULL;
 		mutex_unlock(&register_mutex);
 		snd_card_free_when_closed(card);

commit ae366c2049b48b54e5250cb57438bbebd1dbe610
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Oct 31 11:32:19 2014 +0100

    ALSA: usb-audio: Use strim() instead of open code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index fa6c0972aa23..69725d5fa2d6 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -321,16 +321,6 @@ static int snd_usb_audio_dev_free(struct snd_device *device)
 	return snd_usb_audio_free(chip);
 }
 
-static void remove_trailing_spaces(char *str)
-{
-	char *p;
-
-	if (!*str)
-		return;
-	for (p = str + strlen(str) - 1; p >= str && isspace(*p); p--)
-		*p = 0;
-}
-
 /*
  * create a chip instance and set its names.
  */
@@ -414,7 +404,7 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 				USB_ID_PRODUCT(chip->usb_id));
 		}
 	}
-	remove_trailing_spaces(card->shortname);
+	strim(card->shortname);
 
 	/* retrieve the vendor and device strings as longname */
 	if (quirk && quirk->vendor_name && *quirk->vendor_name) {
@@ -428,7 +418,7 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 		/* we don't really care if there isn't any vendor string */
 	}
 	if (len > 0) {
-		remove_trailing_spaces(card->longname);
+		strim(card->longname);
 		if (*card->longname)
 			strlcat(card->longname, " ", sizeof(card->longname));
 	}

commit a6cece9d81990e729c1f9da2a5bff2d29f7df649
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Oct 31 11:24:32 2014 +0100

    ALSA: usb-audio: Pass direct struct pointer instead of list_head
    
    Some functions in mixer.c and endpoint.c receive list_head instead of
    the object itself.  This is not obvious and rather error-prone.  Let's
    pass the proper object directly instead.
    
    The functions in midi.c still receive list_head and this can't be
    changed since the object definition isn't exposed to the outside of
    midi.c, so left as is.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index be16bdc53c2a..fa6c0972aa23 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -114,13 +114,11 @@ static struct usb_driver usb_audio_driver;
  * disconnect streams
  * called from usb_audio_disconnect()
  */
-static void snd_usb_stream_disconnect(struct list_head *head)
+static void snd_usb_stream_disconnect(struct snd_usb_stream *as)
 {
 	int idx;
-	struct snd_usb_stream *as;
 	struct snd_usb_substream *subs;
 
-	as = list_entry(head, struct snd_usb_stream, list);
 	for (idx = 0; idx < 2; idx++) {
 		subs = &as->substream[idx];
 		if (!subs->num_formats)
@@ -307,10 +305,10 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 
 static int snd_usb_audio_free(struct snd_usb_audio *chip)
 {
-	struct list_head *p, *n;
+	struct snd_usb_endpoint *ep, *n;
 
-	list_for_each_safe(p, n, &chip->ep_list)
-		snd_usb_endpoint_free(p);
+	list_for_each_entry_safe(ep, n, &chip->ep_list, list)
+		snd_usb_endpoint_free(ep);
 
 	mutex_destroy(&chip->mutex);
 	kfree(chip);
@@ -609,12 +607,14 @@ static void usb_audio_disconnect(struct usb_interface *intf)
 	mutex_lock(&register_mutex);
 	chip->num_interfaces--;
 	if (chip->num_interfaces <= 0) {
+		struct snd_usb_stream *as;
 		struct snd_usb_endpoint *ep;
+		struct usb_mixer_interface *mixer;
 
 		snd_card_disconnect(card);
 		/* release the pcm resources */
-		list_for_each(p, &chip->pcm_list) {
-			snd_usb_stream_disconnect(p);
+		list_for_each_entry(as, &chip->pcm_list, list) {
+			snd_usb_stream_disconnect(as);
 		}
 		/* release the endpoint resources */
 		list_for_each_entry(ep, &chip->ep_list, list) {
@@ -625,8 +625,8 @@ static void usb_audio_disconnect(struct usb_interface *intf)
 			snd_usbmidi_disconnect(p);
 		}
 		/* release mixer resources */
-		list_for_each(p, &chip->mixer_list) {
-			snd_usb_mixer_disconnect(p);
+		list_for_each_entry(mixer, &chip->mixer_list, list) {
+			snd_usb_mixer_disconnect(mixer);
 		}
 		usb_chip[chip->index] = NULL;
 		mutex_unlock(&register_mutex);

commit 4c8c3a4fcc021677c9a363b4e77f61dd09dbfd1a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Oct 31 11:00:23 2014 +0100

    ALSA: usb-audio: Flatten probe and disconnect functions
    
    The usb-audio probe and disconnect functions have been split just for
    adapting the (new!) API at 2.5 kernel time.  We left them until now,
    partly because we wanted to build with the pretty old kernels in the
    external alsa-driver tree.  But the support of such old kernels has
    been longly stopped, so it's good time to clean up this mess.
    
    One good point by this cleanup is that now the probe function returns
    a proper error code instead of only -EIO.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 7ecd0e8a5c51..be16bdc53c2a 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -112,7 +112,7 @@ static struct usb_driver usb_audio_driver;
 
 /*
  * disconnect streams
- * called from snd_usb_audio_disconnect()
+ * called from usb_audio_disconnect()
  */
 static void snd_usb_stream_disconnect(struct list_head *head)
 {
@@ -475,14 +475,14 @@ static int snd_usb_audio_create(struct usb_interface *intf,
  * only at the first time.  the successive calls of this function will
  * append the pcm interface to the corresponding card.
  */
-static struct snd_usb_audio *
-snd_usb_audio_probe(struct usb_device *dev,
-		    struct usb_interface *intf,
-		    const struct usb_device_id *usb_id)
+static int usb_audio_probe(struct usb_interface *intf,
+			   const struct usb_device_id *usb_id)
 {
-	const struct snd_usb_audio_quirk *quirk = (const struct snd_usb_audio_quirk *)usb_id->driver_info;
-	int i, err;
+	struct usb_device *dev = interface_to_usbdev(intf);
+	const struct snd_usb_audio_quirk *quirk =
+		(const struct snd_usb_audio_quirk *)usb_id->driver_info;
 	struct snd_usb_audio *chip;
+	int i, err;
 	struct usb_host_interface *alts;
 	int ifnum;
 	u32 id;
@@ -492,10 +492,11 @@ snd_usb_audio_probe(struct usb_device *dev,
 	id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),
 		    le16_to_cpu(dev->descriptor.idProduct));
 	if (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)
-		goto __err_val;
+		return -ENXIO;
 
-	if (snd_usb_apply_boot_quirk(dev, intf, quirk) < 0)
-		goto __err_val;
+	err = snd_usb_apply_boot_quirk(dev, intf, quirk);
+	if (err < 0)
+		return err;
 
 	/*
 	 * found a config.  now register to ALSA
@@ -508,6 +509,7 @@ snd_usb_audio_probe(struct usb_device *dev,
 		if (usb_chip[i] && usb_chip[i]->dev == dev) {
 			if (usb_chip[i]->shutdown) {
 				dev_err(&dev->dev, "USB device is in the shutdown state, cannot create a card instance\n");
+				err = -EIO;
 				goto __error;
 			}
 			chip = usb_chip[i];
@@ -523,15 +525,16 @@ snd_usb_audio_probe(struct usb_device *dev,
 			if (enable[i] && ! usb_chip[i] &&
 			    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&
 			    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {
-				if (snd_usb_audio_create(intf, dev, i, quirk,
-							 &chip) < 0) {
+				err = snd_usb_audio_create(intf, dev, i, quirk,
+							   &chip);
+				if (err < 0)
 					goto __error;
-				}
 				chip->pm_intf = intf;
 				break;
 			}
 		if (!chip) {
 			dev_err(&dev->dev, "no available usb audio device\n");
+			err = -ENODEV;
 			goto __error;
 		}
 	}
@@ -548,28 +551,32 @@ snd_usb_audio_probe(struct usb_device *dev,
 	err = 1; /* continue */
 	if (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {
 		/* need some special handlings */
-		if ((err = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk)) < 0)
+		err = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);
+		if (err < 0)
 			goto __error;
 	}
 
 	if (err > 0) {
 		/* create normal USB audio interfaces */
-		if (snd_usb_create_streams(chip, ifnum) < 0 ||
-		    snd_usb_create_mixer(chip, ifnum, ignore_ctl_error) < 0) {
+		err = snd_usb_create_streams(chip, ifnum);
+		if (err < 0)
+			goto __error;
+		err = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);
+		if (err < 0)
 			goto __error;
-		}
 	}
 
 	/* we are allowed to call snd_card_register() many times */
-	if (snd_card_register(chip->card) < 0) {
+	err = snd_card_register(chip->card);
+	if (err < 0)
 		goto __error;
-	}
 
 	usb_chip[chip->index] = chip;
 	chip->num_interfaces++;
 	chip->probing = 0;
+	usb_set_intfdata(intf, chip);
 	mutex_unlock(&register_mutex);
-	return chip;
+	return 0;
 
  __error:
 	if (chip) {
@@ -578,17 +585,16 @@ snd_usb_audio_probe(struct usb_device *dev,
 		chip->probing = 0;
 	}
 	mutex_unlock(&register_mutex);
- __err_val:
-	return NULL;
+	return err;
 }
 
 /*
  * we need to take care of counter, since disconnection can be called also
  * many times as well as usb_audio_probe().
  */
-static void snd_usb_audio_disconnect(struct usb_device *dev,
-				     struct snd_usb_audio *chip)
+static void usb_audio_disconnect(struct usb_interface *intf)
 {
+	struct snd_usb_audio *chip = usb_get_intfdata(intf);
 	struct snd_card *card;
 	struct list_head *p;
 
@@ -630,27 +636,6 @@ static void snd_usb_audio_disconnect(struct usb_device *dev,
 	}
 }
 
-/*
- * new 2.5 USB kernel API
- */
-static int usb_audio_probe(struct usb_interface *intf,
-			   const struct usb_device_id *id)
-{
-	struct snd_usb_audio *chip;
-	chip = snd_usb_audio_probe(interface_to_usbdev(intf), intf, id);
-	if (chip) {
-		usb_set_intfdata(intf, chip);
-		return 0;
-	} else
-		return -EIO;
-}
-
-static void usb_audio_disconnect(struct usb_interface *intf)
-{
-	snd_usb_audio_disconnect(interface_to_usbdev(intf),
-				 usb_get_intfdata(intf));
-}
-
 #ifdef CONFIG_PM
 
 int snd_usb_autoresume(struct snd_usb_audio *chip)

commit f7881e5e8ef305e62084bf3d31b5b0d827fdf511
Author: Adam Goode <agoode@google.com>
Date:   Tue Aug 5 12:44:50 2014 -0400

    ALSA: usb-audio: Respond to suspend and resume callbacks for MIDI input
    
    sound/usb/card.c registers USB suspend and resume but did not previously
    kill the input URBs. This means that USB MIDI devices left open across
    suspend/resume had non-functional input (output still usually worked,
    but it looks like that is another issue). Before this change, we would
    get ESHUTDOWN for each of the input URBs at suspend time, killing input.
    
    Signed-off-by: Adam Goode <agoode@google.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index a09e5f3519e3..7ecd0e8a5c51 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -680,6 +680,7 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 	struct snd_usb_audio *chip = usb_get_intfdata(intf);
 	struct snd_usb_stream *as;
 	struct usb_mixer_interface *mixer;
+	struct list_head *p;
 
 	if (chip == (void *)-1L)
 		return 0;
@@ -692,6 +693,9 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 				as->substream[0].need_setup_ep =
 					as->substream[1].need_setup_ep = true;
 			}
+			list_for_each(p, &chip->midi_list) {
+				snd_usbmidi_suspend(p);
+			}
 		}
 	} else {
 		/*
@@ -713,6 +717,7 @@ static int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)
 {
 	struct snd_usb_audio *chip = usb_get_intfdata(intf);
 	struct usb_mixer_interface *mixer;
+	struct list_head *p;
 	int err = 0;
 
 	if (chip == (void *)-1L)
@@ -731,6 +736,10 @@ static int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)
 			goto err_out;
 	}
 
+	list_for_each(p, &chip->midi_list) {
+		snd_usbmidi_resume(p);
+	}
+
 	if (!chip->autosuspended)
 		snd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);
 	chip->autosuspended = 0;

commit 92a586bdc06de6629dae1b357dac221253f55ff8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 25 14:24:47 2014 +0200

    ALSA: usb-audio: Fix races at disconnection and PCM closing
    
    When a USB-audio device is disconnected while PCM is still running, we
    still see some race: the disconnect callback calls
    snd_usb_endpoint_free() that calls release_urbs() and then kfree()
    while a PCM stream would be closed at the same time and calls
    stop_endpoints() that leads to wait_clear_urbs().  That is, the EP
    object might be deallocated while a PCM stream is syncing with
    wait_clear_urbs() with the same EP.
    
    Basically calling multiple wait_clear_urbs() would work fine, also
    calling wait_clear_urbs() and release_urbs() would work, too, as
    wait_clear_urbs() just reads some fields in ep.  The problem is the
    succeeding kfree() in snd_pcm_endpoint_free().
    
    This patch moves out the EP deallocation into the later point, the
    destructor callback.  At this stage, all PCMs must have been already
    closed, so it's safe to free the objects.
    
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index c3b5b7dca1c3..a09e5f3519e3 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -307,6 +307,11 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 
 static int snd_usb_audio_free(struct snd_usb_audio *chip)
 {
+	struct list_head *p, *n;
+
+	list_for_each_safe(p, n, &chip->ep_list)
+		snd_usb_endpoint_free(p);
+
 	mutex_destroy(&chip->mutex);
 	kfree(chip);
 	return 0;
@@ -585,7 +590,7 @@ static void snd_usb_audio_disconnect(struct usb_device *dev,
 				     struct snd_usb_audio *chip)
 {
 	struct snd_card *card;
-	struct list_head *p, *n;
+	struct list_head *p;
 
 	if (chip == (void *)-1L)
 		return;
@@ -598,14 +603,16 @@ static void snd_usb_audio_disconnect(struct usb_device *dev,
 	mutex_lock(&register_mutex);
 	chip->num_interfaces--;
 	if (chip->num_interfaces <= 0) {
+		struct snd_usb_endpoint *ep;
+
 		snd_card_disconnect(card);
 		/* release the pcm resources */
 		list_for_each(p, &chip->pcm_list) {
 			snd_usb_stream_disconnect(p);
 		}
 		/* release the endpoint resources */
-		list_for_each_safe(p, n, &chip->ep_list) {
-			snd_usb_endpoint_free(p);
+		list_for_each_entry(ep, &chip->ep_list, list) {
+			snd_usb_endpoint_release(ep);
 		}
 		/* release the midi resources */
 		list_for_each(p, &chip->midi_list) {

commit 1ee23fe07ee83a38ecee927e701f762888ada942
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 2 18:17:06 2014 +0200

    ALSA: usb-audio: Fix deadlocks at resuming
    
    The recent addition of the USB audio mixer suspend/resume may lead to
    deadlocks when the driver tries to call usb_autopm_get_interface()
    recursively, since the function tries to sync with the finish of the
    other calls.  For avoiding it, introduce a flag indicating the resume
    operation and avoids the recursive usb_autopm_get_interface() calls
    during the resume.
    
    Reported-and-tested-by: Bryan Quigley <gquigs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index e769d3977716..c3b5b7dca1c3 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -651,7 +651,7 @@ int snd_usb_autoresume(struct snd_usb_audio *chip)
 	int err = -ENODEV;
 
 	down_read(&chip->shutdown_rwsem);
-	if (chip->probing)
+	if (chip->probing && chip->in_pm)
 		err = 0;
 	else if (!chip->shutdown)
 		err = usb_autopm_get_interface(chip->pm_intf);
@@ -663,7 +663,7 @@ int snd_usb_autoresume(struct snd_usb_audio *chip)
 void snd_usb_autosuspend(struct snd_usb_audio *chip)
 {
 	down_read(&chip->shutdown_rwsem);
-	if (!chip->shutdown && !chip->probing)
+	if (!chip->shutdown && !chip->probing && !chip->in_pm)
 		usb_autopm_put_interface(chip->pm_intf);
 	up_read(&chip->shutdown_rwsem);
 }
@@ -712,6 +712,8 @@ static int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)
 		return 0;
 	if (--chip->num_suspended_intf)
 		return 0;
+
+	chip->in_pm = 1;
 	/*
 	 * ALSA leaves material resumption to user space
 	 * we just notify and restart the mixers
@@ -727,6 +729,7 @@ static int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)
 	chip->autosuspended = 0;
 
 err_out:
+	chip->in_pm = 0;
 	return err;
 }
 

commit 1c53e7253ed8769a00afa0f06777d731dbe1ba6f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 2 18:14:42 2014 +0200

    ALSA: usb-audio: Save mixer status only once at suspend
    
    The suspend callback of usb-audio driver may be called multiple times
    per suspend when multiple USB interfaces are bound to a single sound
    card instance.  In such a case, it's superfluous to save the mixer
    values multiple times.  This patch fixes it by checking the counter.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 893d5a1afc3c..e769d3977716 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -695,8 +695,9 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 			chip->autosuspended = 1;
 	}
 
-	list_for_each_entry(mixer, &chip->mixer_list, list)
-		snd_usb_mixer_suspend(mixer);
+	if (chip->num_suspended_intf == 1)
+		list_for_each_entry(mixer, &chip->mixer_list, list)
+			snd_usb_mixer_suspend(mixer);
 
 	return 0;
 }

commit 0ba41d917eeb87f608cf147f870ff2f4c1056bab
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 26 13:02:17 2014 +0100

    ALSA: usb-audio: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    As there are too deep indirections (e.g. ep->chip->dev->dev),
    a few new local macros, usb_audio_err() & co, are introduced.
    
    Also, the device numbers in some messages are dropped, as they are
    shown in the prefix automatically.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 0cfdc2d3b631..893d5a1afc3c 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -139,8 +139,8 @@ static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int int
 	struct usb_interface *iface = usb_ifnum_to_if(dev, interface);
 
 	if (!iface) {
-		snd_printk(KERN_ERR "%d:%u:%d : does not exist\n",
-			   dev->devnum, ctrlif, interface);
+		dev_err(&dev->dev, "%u:%d : does not exist\n",
+			ctrlif, interface);
 		return -EINVAL;
 	}
 
@@ -165,8 +165,8 @@ static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int int
 	}
 
 	if (usb_interface_claimed(iface)) {
-		snd_printdd(KERN_INFO "%d:%d:%d: skipping, already claimed\n",
-						dev->devnum, ctrlif, interface);
+		dev_dbg(&dev->dev, "%d:%d: skipping, already claimed\n",
+			ctrlif, interface);
 		return -EINVAL;
 	}
 
@@ -176,8 +176,9 @@ static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int int
 		int err = snd_usbmidi_create(chip->card, iface,
 					     &chip->midi_list, NULL);
 		if (err < 0) {
-			snd_printk(KERN_ERR "%d:%u:%d: cannot create sequencer device\n",
-						dev->devnum, ctrlif, interface);
+			dev_err(&dev->dev,
+				"%u:%d: cannot create sequencer device\n",
+				ctrlif, interface);
 			return -EINVAL;
 		}
 		usb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);
@@ -188,14 +189,15 @@ static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int int
 	if ((altsd->bInterfaceClass != USB_CLASS_AUDIO &&
 	     altsd->bInterfaceClass != USB_CLASS_VENDOR_SPEC) ||
 	    altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING) {
-		snd_printdd(KERN_ERR "%d:%u:%d: skipping non-supported interface %d\n",
-					dev->devnum, ctrlif, interface, altsd->bInterfaceClass);
+		dev_dbg(&dev->dev,
+			"%u:%d: skipping non-supported interface %d\n",
+			ctrlif, interface, altsd->bInterfaceClass);
 		/* skip non-supported classes */
 		return -EINVAL;
 	}
 
 	if (snd_usb_get_speed(dev) == USB_SPEED_LOW) {
-		snd_printk(KERN_ERR "low speed audio streaming not supported\n");
+		dev_err(&dev->dev, "low speed audio streaming not supported\n");
 		return -EINVAL;
 	}
 
@@ -228,26 +230,27 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 	protocol = altsd->bInterfaceProtocol;
 
 	if (!control_header) {
-		snd_printk(KERN_ERR "cannot find UAC_HEADER\n");
+		dev_err(&dev->dev, "cannot find UAC_HEADER\n");
 		return -EINVAL;
 	}
 
 	switch (protocol) {
 	default:
-		snd_printdd(KERN_WARNING "unknown interface protocol %#02x, assuming v1\n",
-			    protocol);
+		dev_warn(&dev->dev,
+			 "unknown interface protocol %#02x, assuming v1\n",
+			 protocol);
 		/* fall through */
 
 	case UAC_VERSION_1: {
 		struct uac1_ac_header_descriptor *h1 = control_header;
 
 		if (!h1->bInCollection) {
-			snd_printk(KERN_INFO "skipping empty audio interface (v1)\n");
+			dev_info(&dev->dev, "skipping empty audio interface (v1)\n");
 			return -EINVAL;
 		}
 
 		if (h1->bLength < sizeof(*h1) + h1->bInCollection) {
-			snd_printk(KERN_ERR "invalid UAC_HEADER (v1)\n");
+			dev_err(&dev->dev, "invalid UAC_HEADER (v1)\n");
 			return -EINVAL;
 		}
 
@@ -277,7 +280,7 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 		}
 
 		if (!assoc) {
-			snd_printk(KERN_ERR "Audio class v2 interfaces need an interface association\n");
+			dev_err(&dev->dev, "Audio class v2 interfaces need an interface association\n");
 			return -EINVAL;
 		}
 
@@ -351,14 +354,14 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 	case USB_SPEED_SUPER:
 		break;
 	default:
-		snd_printk(KERN_ERR "unknown device speed %d\n", snd_usb_get_speed(dev));
+		dev_err(&dev->dev, "unknown device speed %d\n", snd_usb_get_speed(dev));
 		return -ENXIO;
 	}
 
 	err = snd_card_new(&intf->dev, index[idx], id[idx], THIS_MODULE,
 			   0, &card);
 	if (err < 0) {
-		snd_printk(KERN_ERR "cannot create card instance %d\n", idx);
+		dev_err(&dev->dev, "cannot create card instance %d\n", idx);
 		return err;
 	}
 
@@ -499,7 +502,7 @@ snd_usb_audio_probe(struct usb_device *dev,
 	for (i = 0; i < SNDRV_CARDS; i++) {
 		if (usb_chip[i] && usb_chip[i]->dev == dev) {
 			if (usb_chip[i]->shutdown) {
-				snd_printk(KERN_ERR "USB device is in the shutdown state, cannot create a card instance\n");
+				dev_err(&dev->dev, "USB device is in the shutdown state, cannot create a card instance\n");
 				goto __error;
 			}
 			chip = usb_chip[i];
@@ -523,7 +526,7 @@ snd_usb_audio_probe(struct usb_device *dev,
 				break;
 			}
 		if (!chip) {
-			printk(KERN_ERR "no available usb audio device\n");
+			dev_err(&dev->dev, "no available usb audio device\n");
 			goto __error;
 		}
 	}

commit 874b8d422e26e21dd432657e25f679c75440c1bc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:22:20 2014 +0100

    ALSA: usb: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 025224136129..0cfdc2d3b631 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -328,7 +328,8 @@ static void remove_trailing_spaces(char *str)
 /*
  * create a chip instance and set its names.
  */
-static int snd_usb_audio_create(struct usb_device *dev, int idx,
+static int snd_usb_audio_create(struct usb_interface *intf,
+				struct usb_device *dev, int idx,
 				const struct snd_usb_audio_quirk *quirk,
 				struct snd_usb_audio **rchip)
 {
@@ -354,7 +355,8 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 		return -ENXIO;
 	}
 
-	err = snd_card_create(index[idx], id[idx], THIS_MODULE, 0, &card);
+	err = snd_card_new(&intf->dev, index[idx], id[idx], THIS_MODULE,
+			   0, &card);
 	if (err < 0) {
 		snd_printk(KERN_ERR "cannot create card instance %d\n", idx);
 		return err;
@@ -513,10 +515,10 @@ snd_usb_audio_probe(struct usb_device *dev,
 			if (enable[i] && ! usb_chip[i] &&
 			    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&
 			    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {
-				if (snd_usb_audio_create(dev, i, quirk, &chip) < 0) {
+				if (snd_usb_audio_create(intf, dev, i, quirk,
+							 &chip) < 0) {
 					goto __error;
 				}
-				snd_card_set_dev(chip->card, &intf->dev);
 				chip->pm_intf = intf;
 				break;
 			}

commit 400362f1d8dcfda3562e80e88cfc2a92cffaf9bf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 20 16:51:16 2014 +0100

    ALSA: usb-audio: Resume mixer values properly
    
    Implement reset_resume callback so that the mixer values are properly
    restored.  Still no boot quirks are called, so it might not work well
    on some devices.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index d979050e6a6a..025224136129 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -691,12 +691,12 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 	}
 
 	list_for_each_entry(mixer, &chip->mixer_list, list)
-		snd_usb_mixer_inactivate(mixer);
+		snd_usb_mixer_suspend(mixer);
 
 	return 0;
 }
 
-static int usb_audio_resume(struct usb_interface *intf)
+static int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)
 {
 	struct snd_usb_audio *chip = usb_get_intfdata(intf);
 	struct usb_mixer_interface *mixer;
@@ -711,7 +711,7 @@ static int usb_audio_resume(struct usb_interface *intf)
 	 * we just notify and restart the mixers
 	 */
 	list_for_each_entry(mixer, &chip->mixer_list, list) {
-		err = snd_usb_mixer_activate(mixer);
+		err = snd_usb_mixer_resume(mixer, reset_resume);
 		if (err < 0)
 			goto err_out;
 	}
@@ -723,9 +723,20 @@ static int usb_audio_resume(struct usb_interface *intf)
 err_out:
 	return err;
 }
+
+static int usb_audio_resume(struct usb_interface *intf)
+{
+	return __usb_audio_resume(intf, false);
+}
+
+static int usb_audio_reset_resume(struct usb_interface *intf)
+{
+	return __usb_audio_resume(intf, true);
+}
 #else
 #define usb_audio_suspend	NULL
 #define usb_audio_resume	NULL
+#define usb_audio_reset_resume	NULL
 #endif		/* CONFIG_PM */
 
 static struct usb_device_id usb_audio_ids [] = {
@@ -747,6 +758,7 @@ static struct usb_driver usb_audio_driver = {
 	.disconnect =	usb_audio_disconnect,
 	.suspend =	usb_audio_suspend,
 	.resume =	usb_audio_resume,
+	.reset_resume =	usb_audio_reset_resume,
 	.id_table =	usb_audio_ids,
 	.supports_autosuspend = 1,
 };

commit 6b5a7c66ce396242e504dbf3d9d5c06d8b1aa488
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Wed Oct 9 17:22:32 2013 +0530

    ALSA: usb-audio: Use module_usb_driver
    
    module_usb_driver makes code simpler by removing the boilerplate.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 9d9de8d53469..d979050e6a6a 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -751,15 +751,4 @@ static struct usb_driver usb_audio_driver = {
 	.supports_autosuspend = 1,
 };
 
-static int __init snd_usb_audio_init(void)
-{
-	return usb_register(&usb_audio_driver);
-}
-
-static void __exit snd_usb_audio_cleanup(void)
-{
-	usb_deregister(&usb_audio_driver);
-}
-
-module_init(snd_usb_audio_init);
-module_exit(snd_usb_audio_cleanup);
+module_usb_driver(usb_audio_driver);

commit df3774c5c53305eda4053d5c941bb17a2145e3c6
Author: Thomas Pugliese <thomas.pugliese@gmail.com>
Date:   Tue Oct 1 14:32:15 2013 -0500

    ALSA: usb-audio: add support for wireless USB devices
    
    This patch updates snd_usb_audio_create also support devices whose
    speed == USB_SPEED_WIRELESS.
    
    Signed-off-by: Thomas Pugliese <thomas.pugliese@gmail.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index d1f54dfe41d5..9d9de8d53469 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -346,6 +346,7 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 	case USB_SPEED_LOW:
 	case USB_SPEED_FULL:
 	case USB_SPEED_HIGH:
+	case USB_SPEED_WIRELESS:
 	case USB_SPEED_SUPER:
 		break;
 	default:

commit 976b6c064a957445eb0573b270f2d0282630e9b9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 24 15:51:58 2013 -0400

    ALSA: improve buffer size computations for USB PCM audio
    
    This patch changes the way URBs are allocated and their sizes are
    determined for PCM playback in the snd-usb-audio driver.  Currently
    the driver allocates too few URBs for endpoints that don't use
    implicit sync, making underruns more likely to occur.  This may be a
    holdover from before I/O delays could be measured accurately; in any
    case, it is no longer necessary.
    
    The patch allocates as many URBs as possible, subject to four
    limitations:
    
            The total number of URBs for the endpoint is not allowed to
            exceed MAX_URBS (which the patch increases from 8 to 12).
    
            The total number of packets per URB is not allowed to exceed
            MAX_PACKS (or MAX_PACKS_HS for high-speed devices), which is
            decreased from 20 to 6.
    
            The total duration of queued data is not allowed to exceed
            MAX_QUEUE, which is decreased from 24 ms to 18 ms.
    
            The total number of ALSA frames in the output queue is not
            allowed to exceed the ALSA buffer size.
    
    The last requirement is the hardest to implement.  Currently the
    number of URBs needed to fill a buffer cannot be determined in
    advance, because a buffer contains a fixed number of frames whereas
    the number of frames in an URB varies to match shifts in the device's
    clock rate.  To solve this problem, the patch changes the logic for
    deciding how many packets an URB should contain.  Rather than using as
    many as possible without exceeding an ALSA period boundary, now the
    driver uses only as many packets as needed to transfer a predetermined
    number of frames.  As a result, unless the device's clock has an
    exceedingly variable rate, the number of URBs making up each period
    (and hence each buffer) will remain constant.
    
    The overall effect of the patch is that playback works better in
    low-latency settings.  The user can still specify values for
    frames/period and periods/buffer that exceed the capabilities of the
    hardware, of course.  But for values that are within those
    capabilities, the performance will be improved.  For example, testing
    shows that a high-speed device can handle 32 frames/period and 3
    periods/buffer at 48 KHz, whereas the current driver starts to get
    glitchy at 64 frames/period and 2 periods/buffer.
    
    A side effect of these changes is that the "nrpacks" module parameter
    is no longer used.  The patch removes it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Clemens Ladisch <clemens@ladisch.de>
    Tested-by: Daniel Mack <zonque@gmail.com>
    Tested-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 64952e2d3ed1..d1f54dfe41d5 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -79,7 +79,6 @@ static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card *
 /* Vendor/product IDs for this card */
 static int vid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };
 static int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };
-static int nrpacks = 8;		/* max. number of packets per urb */
 static int device_setup[SNDRV_CARDS]; /* device parameter for this card */
 static bool ignore_ctl_error;
 static bool autoclock = true;
@@ -94,8 +93,6 @@ module_param_array(vid, int, NULL, 0444);
 MODULE_PARM_DESC(vid, "Vendor ID for the USB audio device.");
 module_param_array(pid, int, NULL, 0444);
 MODULE_PARM_DESC(pid, "Product ID for the USB audio device.");
-module_param(nrpacks, int, 0644);
-MODULE_PARM_DESC(nrpacks, "Max. number of packets per URB.");
 module_param_array(device_setup, int, NULL, 0444);
 MODULE_PARM_DESC(device_setup, "Specific device setup (if needed).");
 module_param(ignore_ctl_error, bool, 0444);
@@ -374,7 +371,6 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 	chip->dev = dev;
 	chip->card = card;
 	chip->setup = device_setup[idx];
-	chip->nrpacks = nrpacks;
 	chip->autoclock = autoclock;
 	chip->probing = 1;
 
@@ -756,10 +752,6 @@ static struct usb_driver usb_audio_driver = {
 
 static int __init snd_usb_audio_init(void)
 {
-	if (nrpacks < 1 || nrpacks > MAX_PACKS) {
-		printk(KERN_WARNING "invalid nrpacks value.\n");
-		return -EINVAL;
-	}
 	return usb_register(&usb_audio_driver);
 }
 

commit 342cda29343a6272c630f94ed56810a76740251b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sat Jun 15 11:21:09 2013 +0200

    ALSA: usb-audio: work around Android accessory firmware bug
    
    When the Android firmware enables the audio interfaces in accessory
    mode, it always declares in the control interface's baInterfaceNr array
    that interfaces 0 and 1 belong to the audio function.  However, the
    accessory interface itself, if also enabled, already is at index 0 and
    shifts the actual audio interface numbers to 1 and 2, which prevents the
    PCM streaming interface from being seen by the host driver.
    
    To get the PCM interface interface to work, detect when the descriptors
    point to the (for this driver useless) accessory interface, and redirect
    to the correct one.
    
    Reported-by: Jeremy Rosen <jeremy.rosen@openwide.fr>
    Tested-by: Jeremy Rosen <jeremy.rosen@openwide.fr>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 1a033177b83f..64952e2d3ed1 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -147,14 +147,32 @@ static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int int
 		return -EINVAL;
 	}
 
+	alts = &iface->altsetting[0];
+	altsd = get_iface_desc(alts);
+
+	/*
+	 * Android with both accessory and audio interfaces enabled gets the
+	 * interface numbers wrong.
+	 */
+	if ((chip->usb_id == USB_ID(0x18d1, 0x2d04) ||
+	     chip->usb_id == USB_ID(0x18d1, 0x2d05)) &&
+	    interface == 0 &&
+	    altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC &&
+	    altsd->bInterfaceSubClass == USB_SUBCLASS_VENDOR_SPEC) {
+		interface = 2;
+		iface = usb_ifnum_to_if(dev, interface);
+		if (!iface)
+			return -EINVAL;
+		alts = &iface->altsetting[0];
+		altsd = get_iface_desc(alts);
+	}
+
 	if (usb_interface_claimed(iface)) {
 		snd_printdd(KERN_INFO "%d:%d:%d: skipping, already claimed\n",
 						dev->devnum, ctrlif, interface);
 		return -EINVAL;
 	}
 
-	alts = &iface->altsetting[0];
-	altsd = get_iface_desc(alts);
 	if ((altsd->bInterfaceClass == USB_CLASS_AUDIO ||
 	     altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC) &&
 	    altsd->bInterfaceSubClass == USB_SUBCLASS_MIDISTREAMING) {

commit 60af3d037eb8c670dcce31401501d1271e7c5d95
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 25 07:38:15 2013 +0200

    ALSA: usb-audio: Fix autopm error during probing
    
    We've got strange errors in get_ctl_value() in mixer.c during
    probing, e.g. on Hercules RMX2 DJ Controller:
    
      ALSA mixer.c:352 cannot get ctl value: req = 0x83, wValue = 0x201, wIndex = 0xa00, type = 4
      ALSA mixer.c:352 cannot get ctl value: req = 0x83, wValue = 0x200, wIndex = 0xa00, type = 4
      ....
    
    It turned out that the culprit is autopm: snd_usb_autoresume() returns
    -ENODEV when called during card->probing = 1.
    
    Since the call itself during card->probing = 1 is valid, let's fix the
    return value of snd_usb_autoresume() as success.
    
    Reported-and-tested-by: Daniel SchÃ¼rmann <daschuer@mixxx.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 5254b18cedcd..1a033177b83f 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -631,7 +631,9 @@ int snd_usb_autoresume(struct snd_usb_audio *chip)
 	int err = -ENODEV;
 
 	down_read(&chip->shutdown_rwsem);
-	if (!chip->shutdown && !chip->probing)
+	if (chip->probing)
+		err = 0;
+	else if (!chip->shutdown)
 		err = usb_autopm_get_interface(chip->pm_intf);
 	up_read(&chip->shutdown_rwsem);
 

commit ef02e29b0180ddbcc1ecf3c362e333c572f27c08
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Wed Apr 3 23:18:56 2013 +0200

    ALSA: usb-audio: UAC2: auto clock selection module param
    
    Add a module param to disable auto clock selection.
    This is provided for users that expect the audio stream to
    fail when the clock source is invalid (e.g., the word clock
    was unintentionally disconnected).
    
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 314e8a211c9a..5254b18cedcd 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -82,6 +82,7 @@ static int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };
 static int nrpacks = 8;		/* max. number of packets per urb */
 static int device_setup[SNDRV_CARDS]; /* device parameter for this card */
 static bool ignore_ctl_error;
+static bool autoclock = true;
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for the USB audio adapter.");
@@ -100,6 +101,8 @@ MODULE_PARM_DESC(device_setup, "Specific device setup (if needed).");
 module_param(ignore_ctl_error, bool, 0444);
 MODULE_PARM_DESC(ignore_ctl_error,
 		 "Ignore errors from USB controller for mixer interfaces.");
+module_param(autoclock, bool, 0444);
+MODULE_PARM_DESC(autoclock, "Enable auto-clock selection for UAC2 devices (default: yes).");
 
 /*
  * we keep the snd_usb_audio_t instances by ourselves for merging
@@ -354,6 +357,7 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 	chip->card = card;
 	chip->setup = device_setup[idx];
 	chip->nrpacks = nrpacks;
+	chip->autoclock = autoclock;
 	chip->probing = 1;
 
 	chip->usb_id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),

commit f9d354359145fae6ad1b0a2cf2b1a49ec817796a
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Wed Apr 3 23:18:50 2013 +0200

    ALSA: usb-audio: neaten MODULE_DEVICE_TABLE placement
    
    Minor style fix, following a general code style in the kernel.
    
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 8bab36cdf2ea..314e8a211c9a 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -714,8 +714,7 @@ static struct usb_device_id usb_audio_ids [] = {
       .bInterfaceSubClass = USB_SUBCLASS_AUDIOCONTROL },
     { }						/* Terminating entry */
 };
-
-MODULE_DEVICE_TABLE (usb, usb_audio_ids);
+MODULE_DEVICE_TABLE(usb, usb_audio_ids);
 
 /*
  * entry point for linux usb interface

commit 88766f04c4142c0a388a1de354616c3deafba513
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Wed Apr 3 23:18:49 2013 +0200

    ALSA: usb-audio: convert list_for_each to entry variant
    
    Change occurances of list_for_each into list_for_each_entry where
    applicable.
    
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 2da8ad75fd96..8bab36cdf2ea 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -645,7 +645,6 @@ void snd_usb_autosuspend(struct snd_usb_audio *chip)
 static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct snd_usb_audio *chip = usb_get_intfdata(intf);
-	struct list_head *p;
 	struct snd_usb_stream *as;
 	struct usb_mixer_interface *mixer;
 
@@ -655,8 +654,7 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 	if (!PMSG_IS_AUTO(message)) {
 		snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
 		if (!chip->num_suspended_intf++) {
-			list_for_each(p, &chip->pcm_list) {
-				as = list_entry(p, struct snd_usb_stream, list);
+			list_for_each_entry(as, &chip->pcm_list, list) {
 				snd_pcm_suspend_all(as->pcm);
 				as->substream[0].need_setup_ep =
 					as->substream[1].need_setup_ep = true;

commit 281a6ac0f54052c81bbee156914459ba5a08f924
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Mar 11 20:15:34 2013 +0100

    ALSA: usb-audio: add a workaround for the NuForce UDH-100
    
    The NuForce UDH-100 numbers its interfaces incorrectly, which makes the
    interface associations come out wrong, which results in the driver
    erroring out with the message "Audio class v2 interfaces need an
    interface association".
    
    Work around this by searching for the interface association descriptor
    also in some other place where it might have ended up.
    
    Reported-and-tested-by: Dave Helstroom <helstroom@google.com>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 803953a9bff3..2da8ad75fd96 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -243,6 +243,21 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 		struct usb_interface_assoc_descriptor *assoc =
 			usb_ifnum_to_if(dev, ctrlif)->intf_assoc;
 
+		if (!assoc) {
+			/*
+			 * Firmware writers cannot count to three.  So to find
+			 * the IAD on the NuForce UDH-100, also check the next
+			 * interface.
+			 */
+			struct usb_interface *iface =
+				usb_ifnum_to_if(dev, ctrlif + 1);
+			if (iface &&
+			    iface->intf_assoc &&
+			    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO &&
+			    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2)
+				assoc = iface->intf_assoc;
+		}
+
 		if (!assoc) {
 			snd_printk(KERN_ERR "Audio class v2 interfaces need an interface association\n");
 			return -EINVAL;

commit aa53f98674a5c21a3098018be2c8ac0984273d8f
Author: Antonio Ospite <ao2@amarulasolutions.com>
Date:   Tue Jan 29 12:56:30 2013 +0100

    ALSA: usb: cosmetics, remove a leading space
    
    Signed-off-by: Antonio Ospite <ao2@amarulasolutions.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index ccf95cfe186f..803953a9bff3 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -646,7 +646,7 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 				as->substream[0].need_setup_ep =
 					as->substream[1].need_setup_ep = true;
 			}
- 		}
+		}
 	} else {
 		/*
 		 * otherwise we keep the rest of the system in the dark

commit 20d32022a8d8639a33d0e429f2d3c51b527ea362
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 20 18:24:47 2012 +0100

    ALSA: usb-audio: Deprecate async_unlink option
    
    The async unlink behavior has been working over years.  The option was
    provided only as a workaround for 2.4.x kernel.  Let's get rid of it.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index dbf7999d18b4..ccf95cfe186f 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -25,9 +25,6 @@
  *
  *  NOTES:
  *
- *   - async unlink should be used for avoiding the sleep inside lock.
- *     2.4.22 usb-uhci seems buggy for async unlinking and results in
- *     oops.  in such a cse, pass async_unlink=0 option.
  *   - the linked URBs would be preferred but not used so far because of
  *     the instability of unlinking.
  *   - type II is not supported properly.  there is no device which supports
@@ -83,7 +80,6 @@ static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card *
 static int vid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };
 static int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };
 static int nrpacks = 8;		/* max. number of packets per urb */
-static bool async_unlink = 1;
 static int device_setup[SNDRV_CARDS]; /* device parameter for this card */
 static bool ignore_ctl_error;
 
@@ -99,8 +95,6 @@ module_param_array(pid, int, NULL, 0444);
 MODULE_PARM_DESC(pid, "Product ID for the USB audio device.");
 module_param(nrpacks, int, 0644);
 MODULE_PARM_DESC(nrpacks, "Max. number of packets per URB.");
-module_param(async_unlink, bool, 0444);
-MODULE_PARM_DESC(async_unlink, "Use async unlink mode.");
 module_param_array(device_setup, int, NULL, 0444);
 MODULE_PARM_DESC(device_setup, "Specific device setup (if needed).");
 module_param(ignore_ctl_error, bool, 0444);
@@ -345,7 +339,6 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 	chip->card = card;
 	chip->setup = device_setup[idx];
 	chip->nrpacks = nrpacks;
-	chip->async_unlink = async_unlink;
 	chip->probing = 1;
 
 	chip->usb_id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),

commit 10e44239f67d0b6fb74006e61a7e883b8075247a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 13 11:22:48 2012 +0100

    ALSA: usb-audio: Fix mutex deadlock at disconnection
    
    The recent change for USB-audio disconnection race fixes introduced a
    mutex deadlock again.  There is a circular dependency between
    chip->shutdown_rwsem and pcm->open_mutex, depicted like below, when a
    device is opened during the disconnection operation:
    
    A. snd_usb_audio_disconnect() ->
         card.c::register_mutex ->
           chip->shutdown_rwsem (write) ->
             snd_card_disconnect() ->
               pcm.c::register_mutex ->
                 pcm->open_mutex
    
    B. snd_pcm_open() ->
         pcm->open_mutex ->
           snd_usb_pcm_open() ->
             chip->shutdown_rwsem (read)
    
    Since the chip->shutdown_rwsem protection in the case A is required
    only for turning on the chip->shutdown flag and it doesn't have to be
    taken for the whole operation, we can reduce its window in
    snd_usb_audio_disconnect().
    
    Reported-by: Jiri Slaby <jslaby@suse.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 282f0fc9fed1..dbf7999d18b4 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -559,9 +559,11 @@ static void snd_usb_audio_disconnect(struct usb_device *dev,
 		return;
 
 	card = chip->card;
-	mutex_lock(&register_mutex);
 	down_write(&chip->shutdown_rwsem);
 	chip->shutdown = 1;
+	up_write(&chip->shutdown_rwsem);
+
+	mutex_lock(&register_mutex);
 	chip->num_interfaces--;
 	if (chip->num_interfaces <= 0) {
 		snd_card_disconnect(card);
@@ -582,11 +584,9 @@ static void snd_usb_audio_disconnect(struct usb_device *dev,
 			snd_usb_mixer_disconnect(p);
 		}
 		usb_chip[chip->index] = NULL;
-		up_write(&chip->shutdown_rwsem);
 		mutex_unlock(&register_mutex);
 		snd_card_free_when_closed(card);
 	} else {
-		up_write(&chip->shutdown_rwsem);
 		mutex_unlock(&register_mutex);
 	}
 }

commit 34f3c89fda4fba9fe689db22253ca8db2f5e6386
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 15 12:16:02 2012 +0200

    ALSA: usb-audio: Use rwsem for disconnect protection
    
    Replace mutex with rwsem for codec->shutdown protection so that
    concurrent accesses are allowed.
    
    Also add the protection to snd_usb_autosuspend() and
    snd_usb_autoresume(), too.
    
    Reported-by: Matthieu CASTET <matthieu.castet@parrot.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 561bb74fd364..282f0fc9fed1 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -339,7 +339,7 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 	}
 
 	mutex_init(&chip->mutex);
-	mutex_init(&chip->shutdown_mutex);
+	init_rwsem(&chip->shutdown_rwsem);
 	chip->index = idx;
 	chip->dev = dev;
 	chip->card = card;
@@ -560,7 +560,7 @@ static void snd_usb_audio_disconnect(struct usb_device *dev,
 
 	card = chip->card;
 	mutex_lock(&register_mutex);
-	mutex_lock(&chip->shutdown_mutex);
+	down_write(&chip->shutdown_rwsem);
 	chip->shutdown = 1;
 	chip->num_interfaces--;
 	if (chip->num_interfaces <= 0) {
@@ -582,11 +582,11 @@ static void snd_usb_audio_disconnect(struct usb_device *dev,
 			snd_usb_mixer_disconnect(p);
 		}
 		usb_chip[chip->index] = NULL;
-		mutex_unlock(&chip->shutdown_mutex);
+		up_write(&chip->shutdown_rwsem);
 		mutex_unlock(&register_mutex);
 		snd_card_free_when_closed(card);
 	} else {
-		mutex_unlock(&chip->shutdown_mutex);
+		up_write(&chip->shutdown_rwsem);
 		mutex_unlock(&register_mutex);
 	}
 }
@@ -618,16 +618,20 @@ int snd_usb_autoresume(struct snd_usb_audio *chip)
 {
 	int err = -ENODEV;
 
+	down_read(&chip->shutdown_rwsem);
 	if (!chip->shutdown && !chip->probing)
 		err = usb_autopm_get_interface(chip->pm_intf);
+	up_read(&chip->shutdown_rwsem);
 
 	return err;
 }
 
 void snd_usb_autosuspend(struct snd_usb_audio *chip)
 {
+	down_read(&chip->shutdown_rwsem);
 	if (!chip->shutdown && !chip->probing)
 		usb_autopm_put_interface(chip->pm_intf);
+	up_read(&chip->shutdown_rwsem);
 }
 
 static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)

commit 384dc085c32285e6548511bf80c5d5a5b246ed24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 18 14:49:31 2012 +0200

    ALSA: usb-audio: Avoid unnecessary EP setups in prepare
    
    The recent fix for USB suspend breakage moved the code to set up EP
    from hw_params to prepare, but it means also the EP setup might be
    called multiple times unnecessarily because the prepare callback can
    be called multiple times without starting the stream (e.g. OSS
    emulation).
    
    This patch adds a new flag to struct snd_usb_substream indicating
    whether the setup of EP is required, and do it only when necessary,
    i.e. right after hw_params or suspend.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 4a469f0cb6d4..561bb74fd364 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -646,6 +646,8 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 			list_for_each(p, &chip->pcm_list) {
 				as = list_entry(p, struct snd_usb_stream, list);
 				snd_pcm_suspend_all(as->pcm);
+				as->substream[0].need_setup_ep =
+					as->substream[1].need_setup_ep = true;
 			}
  		}
 	} else {

commit 03d2f44e967b3c2cf79a6dfb904c8880616c7f83
Author: Pavel Roskin <proski@gnu.org>
Date:   Thu Aug 30 17:11:17 2012 -0400

    ALSA: snd-usb: use list_for_each_safe for endpoint resources
    
    snd_usb_endpoint_free() frees the structure that contains its argument.
    
    Signed-off-by: Pavel Roskin <proski@gnu.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index d5b5c3388e28..4a469f0cb6d4 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -553,7 +553,7 @@ static void snd_usb_audio_disconnect(struct usb_device *dev,
 				     struct snd_usb_audio *chip)
 {
 	struct snd_card *card;
-	struct list_head *p;
+	struct list_head *p, *n;
 
 	if (chip == (void *)-1L)
 		return;
@@ -570,7 +570,7 @@ static void snd_usb_audio_disconnect(struct usb_device *dev,
 			snd_usb_stream_disconnect(p);
 		}
 		/* release the endpoint resources */
-		list_for_each(p, &chip->ep_list) {
+		list_for_each_safe(p, n, &chip->ep_list) {
 			snd_usb_endpoint_free(p);
 		}
 		/* release the midi resources */

commit edcd3633e72a1590c4cf46befe5e6cd03b5aec3e
Author: Daniel Mack <zonque@gmail.com>
Date:   Thu Apr 12 13:51:12 2012 +0200

    ALSA: snd-usb: switch over to new endpoint streaming logic
    
    With the previous commit that added the new streaming model, all
    endpoint and streaming related code is now in endpoint.c, and pcm.c
    only acts as a wrapper for handling the packet's payload.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 6bc88b7ce4fd..d5b5c3388e28 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -131,8 +131,9 @@ static void snd_usb_stream_disconnect(struct list_head *head)
 		subs = &as->substream[idx];
 		if (!subs->num_formats)
 			continue;
-		snd_usb_release_substream_urbs(subs, 1);
 		subs->interface = -1;
+		subs->data_endpoint = NULL;
+		subs->sync_endpoint = NULL;
 	}
 }
 
@@ -350,6 +351,7 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 	chip->usb_id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),
 			      le16_to_cpu(dev->descriptor.idProduct));
 	INIT_LIST_HEAD(&chip->pcm_list);
+	INIT_LIST_HEAD(&chip->ep_list);
 	INIT_LIST_HEAD(&chip->midi_list);
 	INIT_LIST_HEAD(&chip->mixer_list);
 
@@ -567,6 +569,10 @@ static void snd_usb_audio_disconnect(struct usb_device *dev,
 		list_for_each(p, &chip->pcm_list) {
 			snd_usb_stream_disconnect(p);
 		}
+		/* release the endpoint resources */
+		list_for_each(p, &chip->ep_list) {
+			snd_usb_endpoint_free(p);
+		}
 		/* release the midi resources */
 		list_for_each(p, &chip->midi_list) {
 			snd_usbmidi_disconnect(p);

commit 596580d0ee1d17af70920a7bb06c963418014dd1
Author: Daniel Mack <zonque@gmail.com>
Date:   Thu Apr 12 13:51:10 2012 +0200

    ALSA: snd-usb: add snd_usb_audio-wide mutex
    
    This is needed for new card-wide list operations.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 4a7be7b98331..6bc88b7ce4fd 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -276,6 +276,7 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 
 static int snd_usb_audio_free(struct snd_usb_audio *chip)
 {
+	mutex_destroy(&chip->mutex);
 	kfree(chip);
 	return 0;
 }
@@ -336,6 +337,7 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 		return -ENOMEM;
 	}
 
+	mutex_init(&chip->mutex);
 	mutex_init(&chip->shutdown_mutex);
 	chip->index = idx;
 	chip->dev = dev;

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 0f6dc0d457bf..4a7be7b98331 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -78,14 +78,14 @@ MODULE_SUPPORTED_DEVICE("{{Generic,USB Audio}}");
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */
 /* Vendor/product IDs for this card */
 static int vid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };
 static int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };
 static int nrpacks = 8;		/* max. number of packets per urb */
-static int async_unlink = 1;
+static bool async_unlink = 1;
 static int device_setup[SNDRV_CARDS]; /* device parameter for this card */
-static int ignore_ctl_error;
+static bool ignore_ctl_error;
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for the USB audio adapter.");

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 05c1aae0b010..0f6dc0d457bf 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -47,6 +47,7 @@
 #include <linux/mutex.h>
 #include <linux/usb/audio.h>
 #include <linux/usb/audio-v2.h>
+#include <linux/module.h>
 
 #include <sound/control.h>
 #include <sound/core.h>

commit 68d99b2c8efcb6ed3807a55569300c53b5f88be5
Merge: 0e59e7e7feb5 8128c9f21509
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 28 14:25:01 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (549 commits)
      ALSA: hda - Fix ADC input-amp handling for Cx20549 codec
      ALSA: hda - Keep EAPD turned on for old Conexant chips
      ALSA: hda/realtek - Fix missing volume controls with ALC260
      ASoC: wm8940: Properly set codec->dapm.bias_level
      ALSA: hda - Fix pin-config for ASUS W90V
      ALSA: hda - Fix surround/CLFE headphone and speaker pins order
      ALSA: hda - Fix typo
      ALSA: Update the sound git tree URL
      ALSA: HDA: Add new revision for ALC662
      ASoC: max98095: Convert codec->hw_write to snd_soc_write
      ASoC: keep pointer to resource so it can be freed
      ASoC: sgtl5000: Fix wrong mask in some snd_soc_update_bits calls
      ASoC: wm8996: Fix wrong mask for setting WM8996_AIF_CLOCKING_2
      ASoC: da7210: Add support for line out and DAC
      ASoC: da7210: Add support for DAPM
      ALSA: hda/realtek - Fix DAC assignments of multiple speakers
      ASoC: Use SGTL5000_LINREG_VDDD_MASK instead of hardcoded mask value
      ASoC: Set sgtl5000->ldo in ldo_regulator_register
      ASoC: wm8996: Use SND_SOC_DAPM_AIF_OUT for AIF2 Capture
      ASoC: wm8994: Use SND_SOC_DAPM_AIF_OUT for AIF3 Capture
      ...

commit d22665702226e9c40bc331098559e3d55e7cd43d
Merge: 5cdf745ebae0 dde7ad8dee27
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 26 23:51:43 2011 +0200

    Merge branch 'topic/misc' into for-linus

commit d727b60659a1173eb4142a5fc521ce67c28b34e1
Merge: 3ee72ca99288 2a5306cc5f38
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Oct 7 23:16:55 2011 +0200

    Merge branch 'pm-runtime' into pm-for-linus
    
    * pm-runtime:
      PM / Tracing: build rpm-traces.c only if CONFIG_PM_RUNTIME is set
      PM / Runtime: Replace dev_dbg() with trace_rpm_*()
      PM / Runtime: Introduce trace points for tracing rpm_* functions
      PM / Runtime: Don't run callbacks under lock for power.irq_safe set
      USB: Add wakeup info to debugging messages
      PM / Runtime: pm_runtime_idle() can be called in atomic context
      PM / Runtime: Add macro to test for runtime PM events
      PM / Runtime: Add might_sleep() to runtime PM functions

commit 61a6a108d15213f5ee06332e1e7766d3860e4453
Author: Thomas Pfaff <tpfaff@gmx.net>
Date:   Mon Sep 26 15:43:59 2011 +0200

    ALSA: usb-audio: Check for possible chip NULL pointer before clearing probing flag
    
    Before clearing the probing flag in the error exit path, check that the
    chip pointer is not NULL.
    
    Signed-off-by: Thomas Pfaff <tpfaff@gmx.net>
    Cc: <stable@kernel.org> [2.6.39+]
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index ed120ca2353d..d8f2bf401458 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -530,9 +530,11 @@ snd_usb_audio_probe(struct usb_device *dev,
 	return chip;
 
  __error:
-	if (chip && !chip->num_interfaces)
-		snd_card_free(chip->card);
-	chip->probing = 0;
+	if (chip) {
+		if (!chip->num_interfaces)
+			snd_card_free(chip->card);
+		chip->probing = 0;
+	}
 	mutex_unlock(&register_mutex);
  __err_val:
 	return NULL;

commit 362e4e49abe53e89d87455dfcd7c1bbaf08a839d
Author: Thomas Pfaff <tpfaff@gmx.net>
Date:   Thu Sep 22 18:26:06 2011 +0200

    ALSA: usb-audio - clear chip->probing on error exit
    
    The Terratec Aureon 5.1 USB sound card support is broken since kernel
    2.6.39.
    2.6.39 introduced power management support for USB sound cards that added
    a probing flag in struct snd_usb_audio.
    
    During the probe of the card it gives following error message :
    
    usb 7-2: new full speed USB device number 2 using uhci_hcd
    cannot find UAC_HEADER
    snd-usb-audio: probe of 7-2:1.3 failed with error -5
    input: USB Audio as
    /devices/pci0000:00/0000:00:1d.1/usb7/7-2/7-2:1.3/input/input6
    generic-usb 0003:0CCD:0028.0001: input: USB HID v1.00 Device [USB Audio]
    on usb-0000:00:1d.1-2/input3
    
    I can not comment about that "cannot find UAC_HEADER" error, but until
    2.6.38 the card worked anyway.
    With 2.6.39 chip->probing remains 1 on error exit, and any later ioctl
    stops in snd_usb_autoresume with -ENODEV.
    
    Signed-off-by: Thomas Pfaff <tpfaff@gmx.net>
    Cc: <stable@kernel.org> [2.6.39+]
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 781d9e61adfb..ed120ca2353d 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -532,6 +532,7 @@ snd_usb_audio_probe(struct usb_device *dev,
  __error:
 	if (chip && !chip->num_interfaces)
 		snd_card_free(chip->card);
+	chip->probing = 0;
 	mutex_unlock(&register_mutex);
  __err_val:
 	return NULL;

commit c731bc96ad641a5fa3d50a87b474652505507282
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Sep 14 12:46:57 2011 +0200

    ALSA: snd-usb: move code from urb.c to endpoint.c
    
    No code altered at this point, simply preparing for upcoming
    refactorizations.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index a3136afb2198..d2a79d166e04 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -65,7 +65,6 @@
 #include "helper.h"
 #include "debug.h"
 #include "pcm.h"
-#include "urb.h"
 #include "format.h"
 #include "power.h"
 #include "stream.h"

commit e8e8babf561c9560f37b9bd80407ebaf90ad2ca4
Author: Daniel Mack <zonque@gmail.com>
Date:   Mon Sep 12 18:54:12 2011 +0200

    ALSA: snd-usb: re-order code
    
    Move code from endpoint.c into a new file called stream.c and rename
    functions so that their names actually reflect what they're doing.
    
    This way, endpoint.c will be available to functions that hold all the
    endpoint logic.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 781d9e61adfb..a3136afb2198 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -68,6 +68,7 @@
 #include "urb.h"
 #include "format.h"
 #include "power.h"
+#include "stream.h"
 
 MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
 MODULE_DESCRIPTION("USB Audio");
@@ -185,7 +186,7 @@ static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int int
 		return -EINVAL;
 	}
 
-	if (! snd_usb_parse_audio_endpoints(chip, interface)) {
+	if (! snd_usb_parse_audio_interface(chip, interface)) {
 		usb_set_interface(dev, interface, 0); /* reset the current interface */
 		usb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);
 		return -EINVAL;

commit 5b1b0b812a7b1a5b968c5d06d90d1cb88621b941
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Aug 19 23:49:48 2011 +0200

    PM / Runtime: Add macro to test for runtime PM events
    
    This patch (as1482) adds a macro for testing whether or not a
    pm_message value represents an autosuspend or autoresume (i.e., a
    runtime PM) event.  Encapsulating this notion seems preferable to
    open-coding the test all over the place.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 781d9e61adfb..d5754fa5e551 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -628,7 +628,7 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 	if (chip == (void *)-1L)
 		return 0;
 
-	if (!(message.event & PM_EVENT_AUTO)) {
+	if (!PMSG_IS_AUTO(message)) {
 		snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
 		if (!chip->num_suspended_intf++) {
 			list_for_each(p, &chip->pcm_list) {

commit 81b85b6bd91e58bf800cbb3047aa74e61aff7bd9
Author: Pavel Roskin <proski@gnu.org>
Date:   Wed Jul 6 11:20:13 2011 -0400

    ALSA: usb-audio: replace "void *" with more specific pointers
    
    Signed-off-by: Pavel Roskin <proski@gnu.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 220c6167dd86..781d9e61adfb 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -433,9 +433,10 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
  * only at the first time.  the successive calls of this function will
  * append the pcm interface to the corresponding card.
  */
-static void *snd_usb_audio_probe(struct usb_device *dev,
-				 struct usb_interface *intf,
-				 const struct usb_device_id *usb_id)
+static struct snd_usb_audio *
+snd_usb_audio_probe(struct usb_device *dev,
+		    struct usb_interface *intf,
+		    const struct usb_device_id *usb_id)
 {
 	const struct snd_usb_audio_quirk *quirk = (const struct snd_usb_audio_quirk *)usb_id->driver_info;
 	int i, err;
@@ -540,16 +541,15 @@ static void *snd_usb_audio_probe(struct usb_device *dev,
  * we need to take care of counter, since disconnection can be called also
  * many times as well as usb_audio_probe().
  */
-static void snd_usb_audio_disconnect(struct usb_device *dev, void *ptr)
+static void snd_usb_audio_disconnect(struct usb_device *dev,
+				     struct snd_usb_audio *chip)
 {
-	struct snd_usb_audio *chip;
 	struct snd_card *card;
 	struct list_head *p;
 
-	if (ptr == (void *)-1L)
+	if (chip == (void *)-1L)
 		return;
 
-	chip = ptr;
 	card = chip->card;
 	mutex_lock(&register_mutex);
 	mutex_lock(&chip->shutdown_mutex);
@@ -585,7 +585,7 @@ static void snd_usb_audio_disconnect(struct usb_device *dev, void *ptr)
 static int usb_audio_probe(struct usb_interface *intf,
 			   const struct usb_device_id *id)
 {
-	void *chip;
+	struct snd_usb_audio *chip;
 	chip = snd_usb_audio_probe(interface_to_usbdev(intf), intf, id);
 	if (chip) {
 		usb_set_intfdata(intf, chip);

commit 9e38658f703732cb69936553cef4bdb4e5294f3f
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed May 25 09:09:01 2011 +0200

    ALSA: usb-audio: export snd_usb_feature_unit_ctl
    
    In order to allow quirks functions to hook up to the standard feature
    unit op tables, this patch exports a pointer to the struct that is used
    internally.
    
    That way, all the code handling the control can be kept private, and
    external code can reference the symbol to re-use it.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 84a5ce70a2b0..220c6167dd86 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -48,6 +48,7 @@
 #include <linux/usb/audio.h>
 #include <linux/usb/audio-v2.h>
 
+#include <sound/control.h>
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/pcm.h>

commit 5875c2cb7633ca280c2ece43389d6a6f3c00e951
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed May 25 09:08:59 2011 +0200

    ALSA: usb-audio: move assignment of chip->ctrl_intf
    
    This is needed for upcoming changes to the quirks mechanism.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index a90662af2d6b..84a5ce70a2b0 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -492,14 +492,6 @@ static void *snd_usb_audio_probe(struct usb_device *dev,
 		}
 	}
 
-	chip->txfr_quirk = 0;
-	err = 1; /* continue */
-	if (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {
-		/* need some special handlings */
-		if ((err = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk)) < 0)
-			goto __error;
-	}
-
 	/*
 	 * For devices with more than one control interface, we assume the
 	 * first contains the audio controls. We might need a more specific
@@ -508,6 +500,14 @@ static void *snd_usb_audio_probe(struct usb_device *dev,
 	if (!chip->ctrl_intf)
 		chip->ctrl_intf = alts;
 
+	chip->txfr_quirk = 0;
+	err = 1; /* continue */
+	if (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {
+		/* need some special handlings */
+		if ((err = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk)) < 0)
+			goto __error;
+	}
+
 	if (err > 0) {
 		/* create normal USB audio interfaces */
 		if (snd_usb_create_streams(chip, ifnum) < 0 ||

commit 3ffc1222bd2c30b0ef2d3a797b0e0070c7c61a98
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 21 12:00:00 2011 +0100

    ALSA: usb - Remove trailing spaces from USB card name strings
    
    Some USB devices give trailing spaces in strings returned from
    usb_string().  This confuses the automatic card-id creation, resulting
    always in "default".
    This patch fixes the behavior by removing trailing spaces.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 40722f8711ad..a90662af2d6b 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -41,6 +41,7 @@
 #include <linux/list.h>
 #include <linux/slab.h>
 #include <linux/string.h>
+#include <linux/ctype.h>
 #include <linux/usb.h>
 #include <linux/moduleparam.h>
 #include <linux/mutex.h>
@@ -283,6 +284,15 @@ static int snd_usb_audio_dev_free(struct snd_device *device)
 	return snd_usb_audio_free(chip);
 }
 
+static void remove_trailing_spaces(char *str)
+{
+	char *p;
+
+	if (!*str)
+		return;
+	for (p = str + strlen(str) - 1; p >= str && isspace(*p); p--)
+		*p = 0;
+}
 
 /*
  * create a chip instance and set its names.
@@ -351,7 +361,7 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 	snd_component_add(card, component);
 
 	/* retrieve the device string as shortname */
-	if (quirk && quirk->product_name) {
+	if (quirk && quirk->product_name && *quirk->product_name) {
 		strlcpy(card->shortname, quirk->product_name, sizeof(card->shortname));
 	} else {
 		if (!dev->descriptor.iProduct ||
@@ -363,9 +373,10 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 				USB_ID_PRODUCT(chip->usb_id));
 		}
 	}
+	remove_trailing_spaces(card->shortname);
 
 	/* retrieve the vendor and device strings as longname */
-	if (quirk && quirk->vendor_name) {
+	if (quirk && quirk->vendor_name && *quirk->vendor_name) {
 		len = strlcpy(card->longname, quirk->vendor_name, sizeof(card->longname));
 	} else {
 		if (dev->descriptor.iManufacturer)
@@ -375,8 +386,11 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 			len = 0;
 		/* we don't really care if there isn't any vendor string */
 	}
-	if (len > 0)
-		strlcat(card->longname, " ", sizeof(card->longname));
+	if (len > 0) {
+		remove_trailing_spaces(card->longname);
+		if (*card->longname)
+			strlcat(card->longname, " ", sizeof(card->longname));
+	}
 
 	strlcat(card->longname, card->shortname, sizeof(card->longname));
 

commit 88a8516a2128a6d078a106ead48092240e8a138f
Author: Oliver Neukum <oneukum@suse.de>
Date:   Fri Mar 11 14:51:12 2011 +0100

    ALSA: usbaudio: implement USB autosuspend
    
    Devices are autosuspended if no pcm nor midi channel is open
    Mixer devices may be opened. This way they are active when
    in use to play or record sound, but can be suspended while
    users have a mixer application running.
    
    [Small clean-ups using static inline by tiwai]
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 7fa53d91e73b..40722f8711ad 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -65,6 +65,7 @@
 #include "pcm.h"
 #include "urb.h"
 #include "format.h"
+#include "power.h"
 
 MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
 MODULE_DESCRIPTION("USB Audio");
@@ -330,6 +331,7 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 	chip->setup = device_setup[idx];
 	chip->nrpacks = nrpacks;
 	chip->async_unlink = async_unlink;
+	chip->probing = 1;
 
 	chip->usb_id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),
 			      le16_to_cpu(dev->descriptor.idProduct));
@@ -451,6 +453,7 @@ static void *snd_usb_audio_probe(struct usb_device *dev,
 				goto __error;
 			}
 			chip = usb_chip[i];
+			chip->probing = 1;
 			break;
 		}
 	}
@@ -466,6 +469,7 @@ static void *snd_usb_audio_probe(struct usb_device *dev,
 					goto __error;
 				}
 				snd_card_set_dev(chip->card, &intf->dev);
+				chip->pm_intf = intf;
 				break;
 			}
 		if (!chip) {
@@ -505,6 +509,7 @@ static void *snd_usb_audio_probe(struct usb_device *dev,
 
 	usb_chip[chip->index] = chip;
 	chip->num_interfaces++;
+	chip->probing = 0;
 	mutex_unlock(&register_mutex);
 	return chip;
 
@@ -581,6 +586,23 @@ static void usb_audio_disconnect(struct usb_interface *intf)
 }
 
 #ifdef CONFIG_PM
+
+int snd_usb_autoresume(struct snd_usb_audio *chip)
+{
+	int err = -ENODEV;
+
+	if (!chip->shutdown && !chip->probing)
+		err = usb_autopm_get_interface(chip->pm_intf);
+
+	return err;
+}
+
+void snd_usb_autosuspend(struct snd_usb_audio *chip)
+{
+	if (!chip->shutdown && !chip->probing)
+		usb_autopm_put_interface(chip->pm_intf);
+}
+
 static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct snd_usb_audio *chip = usb_get_intfdata(intf);
@@ -591,18 +613,26 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 	if (chip == (void *)-1L)
 		return 0;
 
-	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
-	if (!chip->num_suspended_intf++) {
-		list_for_each(p, &chip->pcm_list) {
-			as = list_entry(p, struct snd_usb_stream, list);
-			snd_pcm_suspend_all(as->pcm);
-		}
-
-		list_for_each_entry(mixer, &chip->mixer_list, list) {
-			snd_usb_mixer_inactivate(mixer);
-		}
+	if (!(message.event & PM_EVENT_AUTO)) {
+		snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
+		if (!chip->num_suspended_intf++) {
+			list_for_each(p, &chip->pcm_list) {
+				as = list_entry(p, struct snd_usb_stream, list);
+				snd_pcm_suspend_all(as->pcm);
+			}
+ 		}
+	} else {
+		/*
+		 * otherwise we keep the rest of the system in the dark
+		 * to keep this transparent
+		 */
+		if (!chip->num_suspended_intf++)
+			chip->autosuspended = 1;
 	}
 
+	list_for_each_entry(mixer, &chip->mixer_list, list)
+		snd_usb_mixer_inactivate(mixer);
+
 	return 0;
 }
 
@@ -610,6 +640,7 @@ static int usb_audio_resume(struct usb_interface *intf)
 {
 	struct snd_usb_audio *chip = usb_get_intfdata(intf);
 	struct usb_mixer_interface *mixer;
+	int err = 0;
 
 	if (chip == (void *)-1L)
 		return 0;
@@ -619,12 +650,18 @@ static int usb_audio_resume(struct usb_interface *intf)
 	 * ALSA leaves material resumption to user space
 	 * we just notify and restart the mixers
 	 */
-	list_for_each_entry(mixer, &chip->mixer_list, list)
-		snd_usb_mixer_activate(mixer);
+	list_for_each_entry(mixer, &chip->mixer_list, list) {
+		err = snd_usb_mixer_activate(mixer);
+		if (err < 0)
+			goto err_out;
+	}
 
-	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);
+	if (!chip->autosuspended)
+		snd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);
+	chip->autosuspended = 0;
 
-	return 0;
+err_out:
+	return err;
 }
 #else
 #define usb_audio_suspend	NULL
@@ -652,6 +689,7 @@ static struct usb_driver usb_audio_driver = {
 	.suspend =	usb_audio_suspend,
 	.resume =	usb_audio_resume,
 	.id_table =	usb_audio_ids,
+	.supports_autosuspend = 1,
 };
 
 static int __init snd_usb_audio_init(void)

commit edf7de31c25ce72f163bf7d1fc0d2711869d073c
Author: Oliver Neukum <oneukum@suse.de>
Date:   Fri Mar 11 13:19:43 2011 +0100

    ALSA: usbaudio: fix suspend/resume
    
    - ESHUTDOWN must be correctly handled
    - the optional interrupt endpoint's URB must be stopped and restarted
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index c0f8270bc199..7fa53d91e73b 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -586,6 +586,7 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 	struct snd_usb_audio *chip = usb_get_intfdata(intf);
 	struct list_head *p;
 	struct snd_usb_stream *as;
+	struct usb_mixer_interface *mixer;
 
 	if (chip == (void *)-1L)
 		return 0;
@@ -596,6 +597,10 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 			as = list_entry(p, struct snd_usb_stream, list);
 			snd_pcm_suspend_all(as->pcm);
 		}
+
+		list_for_each_entry(mixer, &chip->mixer_list, list) {
+			snd_usb_mixer_inactivate(mixer);
+		}
 	}
 
 	return 0;
@@ -604,6 +609,7 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 static int usb_audio_resume(struct usb_interface *intf)
 {
 	struct snd_usb_audio *chip = usb_get_intfdata(intf);
+	struct usb_mixer_interface *mixer;
 
 	if (chip == (void *)-1L)
 		return 0;
@@ -611,8 +617,10 @@ static int usb_audio_resume(struct usb_interface *intf)
 		return 0;
 	/*
 	 * ALSA leaves material resumption to user space
-	 * we just notify
+	 * we just notify and restart the mixers
 	 */
+	list_for_each_entry(mixer, &chip->mixer_list, list)
+		snd_usb_mixer_activate(mixer);
 
 	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);
 

commit 382225e62bdb8059b7f915b133426425516dd300
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 22 10:21:18 2011 +0100

    ALSA: usb-audio: fix oops due to cleanup race when disconnecting
    
    When a USB audio device is disconnected, snd_usb_audio_disconnect()
    kills all audio URBs.  At the same time, the application, after being
    notified of the disconnection, might close the device, in which case
    ALSA calls the .hw_free callback, which should free the URBs too.
    
    Commit de1b8b93a0ba "[ALSA] Fix hang-up at disconnection of usb-audio"
    prevented snd_usb_hw_free() from freeing the URBs to avoid a hang that
    resulted from this race, but this introduced another race because the
    URB callbacks could now be executed after snd_usb_hw_free() has
    returned, and try to access already freed data.
    
    Fix the first race by introducing a mutex to serialize the disconnect
    callback and all PCM callbacks that manage URBs (hw_free and hw_params).
    
    Reported-and-tested-by: Pierre-Louis Bossart <pierre-louis.bossart@intel.com>
    Cc: <stable@kernel.org>
    [CL: also serialize hw_params callback]
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 800f7cb4f251..c0f8270bc199 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -323,6 +323,7 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 		return -ENOMEM;
 	}
 
+	mutex_init(&chip->shutdown_mutex);
 	chip->index = idx;
 	chip->dev = dev;
 	chip->card = card;
@@ -531,6 +532,7 @@ static void snd_usb_audio_disconnect(struct usb_device *dev, void *ptr)
 	chip = ptr;
 	card = chip->card;
 	mutex_lock(&register_mutex);
+	mutex_lock(&chip->shutdown_mutex);
 	chip->shutdown = 1;
 	chip->num_interfaces--;
 	if (chip->num_interfaces <= 0) {
@@ -548,9 +550,11 @@ static void snd_usb_audio_disconnect(struct usb_device *dev, void *ptr)
 			snd_usb_mixer_disconnect(p);
 		}
 		usb_chip[chip->index] = NULL;
+		mutex_unlock(&chip->shutdown_mutex);
 		mutex_unlock(&register_mutex);
 		snd_card_free_when_closed(card);
 	} else {
+		mutex_unlock(&chip->shutdown_mutex);
 		mutex_unlock(&register_mutex);
 	}
 }

commit c8bdfacb63c85d39ff55d365f1e48cce011b219e
Merge: add7c0a6a4b8 a7a13d067633
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 9 10:51:45 2010 +0200

    Merge branch 'fix/misc' into topic/misc

commit 76195fb096ca6db2f8bbaffb96e3025aaf1649a0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 8 08:27:02 2010 +0200

    ALSA: usb - Release capture substream URBs properly
    
    Due to the wrong "return" in the loop, a capture substream won't be
    released at disconnection properly if the device is capture only and has
    no playback substream.  This caused Oops occasionally at the device
    reconnection.
    
    Reported-by: Kim Minhyoung <minhyoung.kim@lge.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 32e4be8a187c..4eabafa5b037 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -126,7 +126,7 @@ static void snd_usb_stream_disconnect(struct list_head *head)
 	for (idx = 0; idx < 2; idx++) {
 		subs = &as->substream[idx];
 		if (!subs->num_formats)
-			return;
+			continue;
 		snd_usb_release_substream_urbs(subs, 1);
 		subs->interface = -1;
 	}

commit 68885a3ff38ed51fa02f241feb405c9922a90ee0
Merge: 7b28079b3284 a2acad8298a4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 3 22:38:52 2010 +0200

    Merge branch 'fix/misc' into topic/misc

commit a2acad8298a42b7be684a32fafaf83332bba9c2b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Sep 3 10:53:11 2010 +0200

    ALSA: usb-audio: fix detection of vendor-specific device protocol settings
    
    The Audio Class v2 support code in 2.6.35 added checks for the
    bInterfaceProtocol field.  However, there are devices (usually those
    detected by vendor-specific quirks) that do not have one of the
    predefined values in this field, which made the driver reject them.
    
    To fix this regression, restore the old behaviour, i.e., assume that
    a device with an unknown bInterfaceProtocol field (other than
    UAC_VERSION_2) has more or less UAC-v1-compatible descriptors.
    
    [compile warning fixes by tiwai]
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: Daniel Mack <daniel@caiaq.de>
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index b443a33d31c9..32e4be8a187c 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -216,6 +216,11 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 	}
 
 	switch (protocol) {
+	default:
+		snd_printdd(KERN_WARNING "unknown interface protocol %#02x, assuming v1\n",
+			    protocol);
+		/* fall through */
+
 	case UAC_VERSION_1: {
 		struct uac1_ac_header_descriptor *h1 = control_header;
 
@@ -253,10 +258,6 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 
 		break;
 	}
-
-	default:
-		snd_printk(KERN_ERR "unknown protocol version 0x%02x\n", protocol);
-		return -EINVAL;
 	}
 
 	return 0;

commit 7b6717e144de6592e614fd7fc3b914b6bf686a9d
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Sep 2 17:13:15 2010 +0800

    ALSA: usb-audio: Assume first control interface is for audio
    
    For devices with more than one control interface, let's assume the first
    one contains the audio controls. Unfortunately, there is no field in any
    of the descriptors to tell us whether a control interface is for audio
    or MIDI controls, so a better check is not easy to implement.
    
    On a composite device with audio and MIDI functions, for example, the
    code currently overwrites chip->ctrl_intf, causing operations on the
    control interface to fail if they are issued after the device probe.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 9feb00c831a0..b443a33d31c9 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -465,7 +465,13 @@ static void *snd_usb_audio_probe(struct usb_device *dev,
 			goto __error;
 	}
 
-	chip->ctrl_intf = alts;
+	/*
+	 * For devices with more than one control interface, we assume the
+	 * first contains the audio controls. We might need a more specific
+	 * check here in the future.
+	 */
+	if (!chip->ctrl_intf)
+		chip->ctrl_intf = alts;
 
 	if (err > 0) {
 		/* create normal USB audio interfaces */

commit 4f4e8f69895c8696a4bcc751817d4b186023ac44
Author: Paul Zimmerman <Paul.Zimmerman@synopsys.com>
Date:   Fri Aug 13 12:42:07 2010 -0700

    ALSA: usb: USB3 SuperSpeed sound support
    
    This is V2 of the patch, after feedback from Clemens and Daniel.
    
    This patch adds SuperSpeed support to the USB drivers under sound/. It adds
    tests for USB_SPEED_SUPER to the appropriate places that check for the USB
    speed.
    
    This patch has been tested with our SS USB3 device emulating a set of Yamaha
    speakers and a Logitech microphone, but with the descriptors modified to add
    USB3 support. It has also been tested with the real speakers and microphone,
    to make sure that USB2 devices still work.
    
    Signed-off-by: Paul Zimmerman <paulz@synopsys.com>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Cc: Daniel Mack <daniel@caiaq.de>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 9feb00c831a0..498a2d8fa4bb 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -299,9 +299,13 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 
 	*rchip = NULL;
 
-	if (snd_usb_get_speed(dev) != USB_SPEED_LOW &&
-	    snd_usb_get_speed(dev) != USB_SPEED_FULL &&
-	    snd_usb_get_speed(dev) != USB_SPEED_HIGH) {
+	switch (snd_usb_get_speed(dev)) {
+	case USB_SPEED_LOW:
+	case USB_SPEED_FULL:
+	case USB_SPEED_HIGH:
+	case USB_SPEED_SUPER:
+		break;
+	default:
 		snd_printk(KERN_ERR "unknown device speed %d\n", snd_usb_get_speed(dev));
 		return -ENXIO;
 	}
@@ -377,11 +381,22 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 	if (len < sizeof(card->longname))
 		usb_make_path(dev, card->longname + len, sizeof(card->longname) - len);
 
-	strlcat(card->longname,
-		snd_usb_get_speed(dev) == USB_SPEED_LOW ? ", low speed" :
-		snd_usb_get_speed(dev) == USB_SPEED_FULL ? ", full speed" :
-		", high speed",
-		sizeof(card->longname));
+	switch (snd_usb_get_speed(dev)) {
+	case USB_SPEED_LOW:
+		strlcat(card->longname, ", low speed", sizeof(card->longname));
+		break;
+	case USB_SPEED_FULL:
+		strlcat(card->longname, ", full speed", sizeof(card->longname));
+		break;
+	case USB_SPEED_HIGH:
+		strlcat(card->longname, ", high speed", sizeof(card->longname));
+		break;
+	case USB_SPEED_SUPER:
+		strlcat(card->longname, ", super speed", sizeof(card->longname));
+		break;
+	default:
+		break;
+	}
 
 	snd_usb_audio_create_proc(chip);
 

commit 69da9bcb98ccbfb5d5f751bc13418f1307332925
Author: Daniel Mack <daniel@caiaq.de>
Date:   Wed Jun 16 17:57:28 2010 +0200

    ALSA: usb-audio: unify UAC macros and struct names
    
    Get rid of the last occurances of _v1 suffixes, and move the version
    number right after the "uac" string. Now things are consitent again.
    
    Sorry for the forth and back, but it just looks much nicer this way.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 7a8ac1d81be7..9feb00c831a0 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -217,7 +217,7 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 
 	switch (protocol) {
 	case UAC_VERSION_1: {
-		struct uac_ac_header_descriptor_v1 *h1 = control_header;
+		struct uac1_ac_header_descriptor *h1 = control_header;
 
 		if (!h1->bInCollection) {
 			snd_printk(KERN_INFO "skipping empty audio interface (v1)\n");

commit 79f920fbff566ffc9de44111eb1456a3cef310f0
Author: Daniel Mack <daniel@caiaq.de>
Date:   Mon May 31 14:51:31 2010 +0200

    ALSA: usb-audio: parse clock topology of UAC2 devices
    
    Audio devices which comply to the UAC2 standard can export complex clock
    topologies in its descriptors and set up links between them.
    
    The entities that are defined are
    
     - clock sources, which define the end-leafs.
     - clock selectors, which act as switch to select one out of many
       possible clocks sources.
     - clock multipliers, which have an input clock source, and act as clock
       source again. They can be used to derive one clock from another.
    
    All sample rate changes, clock validity queries and the like must go to
    clock source elements, while clock selectors and multipliers can be used
    as terminal clock source.
    
    The following patch adds a parser for these elements and functions to
    iterate over the tree and find the leaf nodes (clock sources).
    
    The samplerate set functions were moved to the new clock.c file.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index da1346bd4856..7a8ac1d81be7 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -236,7 +236,6 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 	}
 
 	case UAC_VERSION_2: {
-		struct uac_clock_source_descriptor *cs;
 		struct usb_interface_assoc_descriptor *assoc =
 			usb_ifnum_to_if(dev, ctrlif)->intf_assoc;
 
@@ -245,21 +244,6 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 			return -EINVAL;
 		}
 
-		/* FIXME: for now, we expect there is at least one clock source
-		 * descriptor and we always take the first one.
-		 * We should properly support devices with multiple clock sources,
-		 * clock selectors and sample rate conversion units. */
-
-		cs = snd_usb_find_csint_desc(host_iface->extra, host_iface->extralen,
-						NULL, UAC2_CLOCK_SOURCE);
-
-		if (!cs) {
-			snd_printk(KERN_ERR "CLOCK_SOURCE descriptor not found\n");
-			return -EINVAL;
-		}
-
-		chip->clock_id = cs->bClockID;
-
 		for (i = 0; i < assoc->bInterfaceCount; i++) {
 			int intf = assoc->bFirstInterface + i;
 
@@ -481,6 +465,8 @@ static void *snd_usb_audio_probe(struct usb_device *dev,
 			goto __error;
 	}
 
+	chip->ctrl_intf = alts;
+
 	if (err > 0) {
 		/* create normal USB audio interfaces */
 		if (snd_usb_create_streams(chip, ifnum) < 0 ||

commit 6407d474e6ae6a798fa5ba40b32f508a52de80ff
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Mar 22 08:55:35 2010 -0700

    ALSA: usb: fix usb build error when PM is not enabled
    
    Fix build errors when CONFIG_PM is not enabled:
    
    sound/usb/card.c:629: error: 'usb_audio_suspend' undeclared here (not in a function)
    sound/usb/card.c:630: error: 'usb_audio_resume' undeclared here (not in a function)
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 0bd62a1aa4f2..da1346bd4856 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -606,6 +606,9 @@ static int usb_audio_resume(struct usb_interface *intf)
 
 	return 0;
 }
+#else
+#define usb_audio_suspend	NULL
+#define usb_audio_resume	NULL
 #endif		/* CONFIG_PM */
 
 static struct usb_device_id usb_audio_ids [] = {

commit f0b5e634ff25e02a64676022ee13284a9c810879
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Mar 11 21:13:23 2010 +0100

    ALSA: usbmixer: rename usbmixer.[ch] -> mixer.[ch]
    
    For clearer namespace, also rename usbmixer_maps.c -> mixer_maps.c
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 78d12ff00e8a..0bd62a1aa4f2 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -56,7 +56,7 @@
 #include "usbaudio.h"
 #include "card.h"
 #include "midi.h"
-#include "usbmixer.h"
+#include "mixer.h"
 #include "proc.h"
 #include "quirks.h"
 #include "endpoint.h"

commit 7e847894039d7590321de306fca2b1ae58662f29
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Mar 11 21:13:20 2010 +0100

    linux/usb/audio.h: split header
    
    - Split the audio.h file in two to clearly denote the differences
      between the standards.
    - Add many more defines to audio-v2.h. Most of them are not currently
      used.
    - Replaced a magic value with a proper define
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 426aabc729d9..78d12ff00e8a 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -45,6 +45,7 @@
 #include <linux/moduleparam.h>
 #include <linux/mutex.h>
 #include <linux/usb/audio.h>
+#include <linux/usb/audio-v2.h>
 
 #include <sound/core.h>
 #include <sound/info.h>
@@ -250,7 +251,7 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 		 * clock selectors and sample rate conversion units. */
 
 		cs = snd_usb_find_csint_desc(host_iface->extra, host_iface->extralen,
-						NULL, UAC_CLOCK_SOURCE);
+						NULL, UAC2_CLOCK_SOURCE);
 
 		if (!cs) {
 			snd_printk(KERN_ERR "CLOCK_SOURCE descriptor not found\n");

commit e5779998bf8b70e48a6cc208c8b61b33bd6117ea
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Mar 4 19:46:13 2010 +0100

    ALSA: usb-audio: refactor code
    
    Clean up the usb audio driver by factoring out a lot of functions to
    separate files. Code for procfs, quirks, urbs, format parsers etc all
    got a new home now.
    
    Moved almost all special quirk handling to quirks.c and introduced new
    generic functions to handle them, so the exceptions do not pollute the
    whole driver.
    
    Renamed usbaudio.c to card.c because this is what it actually does now.
    Renamed usbmidi.c to midi.c for namespace clarity.
    Removed more things from usbaudio.h.
    
    The non-standard drivers were adopted accordingly.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.c b/sound/usb/card.c
new file mode 100644
index 000000000000..426aabc729d9
--- /dev/null
+++ b/sound/usb/card.c
@@ -0,0 +1,648 @@
+/*
+ *   (Tentative) USB Audio Driver for ALSA
+ *
+ *   Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>
+ *
+ *   Many codes borrowed from audio.c by
+ *	    Alan Cox (alan@lxorguk.ukuu.org.uk)
+ *	    Thomas Sailer (sailer@ife.ee.ethz.ch)
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *
+ *  NOTES:
+ *
+ *   - async unlink should be used for avoiding the sleep inside lock.
+ *     2.4.22 usb-uhci seems buggy for async unlinking and results in
+ *     oops.  in such a cse, pass async_unlink=0 option.
+ *   - the linked URBs would be preferred but not used so far because of
+ *     the instability of unlinking.
+ *   - type II is not supported properly.  there is no device which supports
+ *     this type *correctly*.  SB extigy looks as if it supports, but it's
+ *     indeed an AC3 stream packed in SPDIF frames (i.e. no real AC3 stream).
+ */
+
+
+#include <linux/bitops.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/usb.h>
+#include <linux/moduleparam.h>
+#include <linux/mutex.h>
+#include <linux/usb/audio.h>
+
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+
+#include "usbaudio.h"
+#include "card.h"
+#include "midi.h"
+#include "usbmixer.h"
+#include "proc.h"
+#include "quirks.h"
+#include "endpoint.h"
+#include "helper.h"
+#include "debug.h"
+#include "pcm.h"
+#include "urb.h"
+#include "format.h"
+
+MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
+MODULE_DESCRIPTION("USB Audio");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{Generic,USB Audio}}");
+
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */
+/* Vendor/product IDs for this card */
+static int vid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };
+static int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };
+static int nrpacks = 8;		/* max. number of packets per urb */
+static int async_unlink = 1;
+static int device_setup[SNDRV_CARDS]; /* device parameter for this card */
+static int ignore_ctl_error;
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for the USB audio adapter.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for the USB audio adapter.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable USB audio adapter.");
+module_param_array(vid, int, NULL, 0444);
+MODULE_PARM_DESC(vid, "Vendor ID for the USB audio device.");
+module_param_array(pid, int, NULL, 0444);
+MODULE_PARM_DESC(pid, "Product ID for the USB audio device.");
+module_param(nrpacks, int, 0644);
+MODULE_PARM_DESC(nrpacks, "Max. number of packets per URB.");
+module_param(async_unlink, bool, 0444);
+MODULE_PARM_DESC(async_unlink, "Use async unlink mode.");
+module_param_array(device_setup, int, NULL, 0444);
+MODULE_PARM_DESC(device_setup, "Specific device setup (if needed).");
+module_param(ignore_ctl_error, bool, 0444);
+MODULE_PARM_DESC(ignore_ctl_error,
+		 "Ignore errors from USB controller for mixer interfaces.");
+
+/*
+ * we keep the snd_usb_audio_t instances by ourselves for merging
+ * the all interfaces on the same card as one sound device.
+ */
+
+static DEFINE_MUTEX(register_mutex);
+static struct snd_usb_audio *usb_chip[SNDRV_CARDS];
+static struct usb_driver usb_audio_driver;
+
+/*
+ * disconnect streams
+ * called from snd_usb_audio_disconnect()
+ */
+static void snd_usb_stream_disconnect(struct list_head *head)
+{
+	int idx;
+	struct snd_usb_stream *as;
+	struct snd_usb_substream *subs;
+
+	as = list_entry(head, struct snd_usb_stream, list);
+	for (idx = 0; idx < 2; idx++) {
+		subs = &as->substream[idx];
+		if (!subs->num_formats)
+			return;
+		snd_usb_release_substream_urbs(subs, 1);
+		subs->interface = -1;
+	}
+}
+
+static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int interface)
+{
+	struct usb_device *dev = chip->dev;
+	struct usb_host_interface *alts;
+	struct usb_interface_descriptor *altsd;
+	struct usb_interface *iface = usb_ifnum_to_if(dev, interface);
+
+	if (!iface) {
+		snd_printk(KERN_ERR "%d:%u:%d : does not exist\n",
+			   dev->devnum, ctrlif, interface);
+		return -EINVAL;
+	}
+
+	if (usb_interface_claimed(iface)) {
+		snd_printdd(KERN_INFO "%d:%d:%d: skipping, already claimed\n",
+						dev->devnum, ctrlif, interface);
+		return -EINVAL;
+	}
+
+	alts = &iface->altsetting[0];
+	altsd = get_iface_desc(alts);
+	if ((altsd->bInterfaceClass == USB_CLASS_AUDIO ||
+	     altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC) &&
+	    altsd->bInterfaceSubClass == USB_SUBCLASS_MIDISTREAMING) {
+		int err = snd_usbmidi_create(chip->card, iface,
+					     &chip->midi_list, NULL);
+		if (err < 0) {
+			snd_printk(KERN_ERR "%d:%u:%d: cannot create sequencer device\n",
+						dev->devnum, ctrlif, interface);
+			return -EINVAL;
+		}
+		usb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);
+
+		return 0;
+	}
+
+	if ((altsd->bInterfaceClass != USB_CLASS_AUDIO &&
+	     altsd->bInterfaceClass != USB_CLASS_VENDOR_SPEC) ||
+	    altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING) {
+		snd_printdd(KERN_ERR "%d:%u:%d: skipping non-supported interface %d\n",
+					dev->devnum, ctrlif, interface, altsd->bInterfaceClass);
+		/* skip non-supported classes */
+		return -EINVAL;
+	}
+
+	if (snd_usb_get_speed(dev) == USB_SPEED_LOW) {
+		snd_printk(KERN_ERR "low speed audio streaming not supported\n");
+		return -EINVAL;
+	}
+
+	if (! snd_usb_parse_audio_endpoints(chip, interface)) {
+		usb_set_interface(dev, interface, 0); /* reset the current interface */
+		usb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * parse audio control descriptor and create pcm/midi streams
+ */
+static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
+{
+	struct usb_device *dev = chip->dev;
+	struct usb_host_interface *host_iface;
+	struct usb_interface_descriptor *altsd;
+	void *control_header;
+	int i, protocol;
+
+	/* find audiocontrol interface */
+	host_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];
+	control_header = snd_usb_find_csint_desc(host_iface->extra,
+						 host_iface->extralen,
+						 NULL, UAC_HEADER);
+	altsd = get_iface_desc(host_iface);
+	protocol = altsd->bInterfaceProtocol;
+
+	if (!control_header) {
+		snd_printk(KERN_ERR "cannot find UAC_HEADER\n");
+		return -EINVAL;
+	}
+
+	switch (protocol) {
+	case UAC_VERSION_1: {
+		struct uac_ac_header_descriptor_v1 *h1 = control_header;
+
+		if (!h1->bInCollection) {
+			snd_printk(KERN_INFO "skipping empty audio interface (v1)\n");
+			return -EINVAL;
+		}
+
+		if (h1->bLength < sizeof(*h1) + h1->bInCollection) {
+			snd_printk(KERN_ERR "invalid UAC_HEADER (v1)\n");
+			return -EINVAL;
+		}
+
+		for (i = 0; i < h1->bInCollection; i++)
+			snd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);
+
+		break;
+	}
+
+	case UAC_VERSION_2: {
+		struct uac_clock_source_descriptor *cs;
+		struct usb_interface_assoc_descriptor *assoc =
+			usb_ifnum_to_if(dev, ctrlif)->intf_assoc;
+
+		if (!assoc) {
+			snd_printk(KERN_ERR "Audio class v2 interfaces need an interface association\n");
+			return -EINVAL;
+		}
+
+		/* FIXME: for now, we expect there is at least one clock source
+		 * descriptor and we always take the first one.
+		 * We should properly support devices with multiple clock sources,
+		 * clock selectors and sample rate conversion units. */
+
+		cs = snd_usb_find_csint_desc(host_iface->extra, host_iface->extralen,
+						NULL, UAC_CLOCK_SOURCE);
+
+		if (!cs) {
+			snd_printk(KERN_ERR "CLOCK_SOURCE descriptor not found\n");
+			return -EINVAL;
+		}
+
+		chip->clock_id = cs->bClockID;
+
+		for (i = 0; i < assoc->bInterfaceCount; i++) {
+			int intf = assoc->bFirstInterface + i;
+
+			if (intf != ctrlif)
+				snd_usb_create_stream(chip, ctrlif, intf);
+		}
+
+		break;
+	}
+
+	default:
+		snd_printk(KERN_ERR "unknown protocol version 0x%02x\n", protocol);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * free the chip instance
+ *
+ * here we have to do not much, since pcm and controls are already freed
+ *
+ */
+
+static int snd_usb_audio_free(struct snd_usb_audio *chip)
+{
+	kfree(chip);
+	return 0;
+}
+
+static int snd_usb_audio_dev_free(struct snd_device *device)
+{
+	struct snd_usb_audio *chip = device->device_data;
+	return snd_usb_audio_free(chip);
+}
+
+
+/*
+ * create a chip instance and set its names.
+ */
+static int snd_usb_audio_create(struct usb_device *dev, int idx,
+				const struct snd_usb_audio_quirk *quirk,
+				struct snd_usb_audio **rchip)
+{
+	struct snd_card *card;
+	struct snd_usb_audio *chip;
+	int err, len;
+	char component[14];
+	static struct snd_device_ops ops = {
+		.dev_free =	snd_usb_audio_dev_free,
+	};
+
+	*rchip = NULL;
+
+	if (snd_usb_get_speed(dev) != USB_SPEED_LOW &&
+	    snd_usb_get_speed(dev) != USB_SPEED_FULL &&
+	    snd_usb_get_speed(dev) != USB_SPEED_HIGH) {
+		snd_printk(KERN_ERR "unknown device speed %d\n", snd_usb_get_speed(dev));
+		return -ENXIO;
+	}
+
+	err = snd_card_create(index[idx], id[idx], THIS_MODULE, 0, &card);
+	if (err < 0) {
+		snd_printk(KERN_ERR "cannot create card instance %d\n", idx);
+		return err;
+	}
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (! chip) {
+		snd_card_free(card);
+		return -ENOMEM;
+	}
+
+	chip->index = idx;
+	chip->dev = dev;
+	chip->card = card;
+	chip->setup = device_setup[idx];
+	chip->nrpacks = nrpacks;
+	chip->async_unlink = async_unlink;
+
+	chip->usb_id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),
+			      le16_to_cpu(dev->descriptor.idProduct));
+	INIT_LIST_HEAD(&chip->pcm_list);
+	INIT_LIST_HEAD(&chip->midi_list);
+	INIT_LIST_HEAD(&chip->mixer_list);
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
+		snd_usb_audio_free(chip);
+		snd_card_free(card);
+		return err;
+	}
+
+	strcpy(card->driver, "USB-Audio");
+	sprintf(component, "USB%04x:%04x",
+		USB_ID_VENDOR(chip->usb_id), USB_ID_PRODUCT(chip->usb_id));
+	snd_component_add(card, component);
+
+	/* retrieve the device string as shortname */
+	if (quirk && quirk->product_name) {
+		strlcpy(card->shortname, quirk->product_name, sizeof(card->shortname));
+	} else {
+		if (!dev->descriptor.iProduct ||
+		    usb_string(dev, dev->descriptor.iProduct,
+		    card->shortname, sizeof(card->shortname)) <= 0) {
+			/* no name available from anywhere, so use ID */
+			sprintf(card->shortname, "USB Device %#04x:%#04x",
+				USB_ID_VENDOR(chip->usb_id),
+				USB_ID_PRODUCT(chip->usb_id));
+		}
+	}
+
+	/* retrieve the vendor and device strings as longname */
+	if (quirk && quirk->vendor_name) {
+		len = strlcpy(card->longname, quirk->vendor_name, sizeof(card->longname));
+	} else {
+		if (dev->descriptor.iManufacturer)
+			len = usb_string(dev, dev->descriptor.iManufacturer,
+					 card->longname, sizeof(card->longname));
+		else
+			len = 0;
+		/* we don't really care if there isn't any vendor string */
+	}
+	if (len > 0)
+		strlcat(card->longname, " ", sizeof(card->longname));
+
+	strlcat(card->longname, card->shortname, sizeof(card->longname));
+
+	len = strlcat(card->longname, " at ", sizeof(card->longname));
+
+	if (len < sizeof(card->longname))
+		usb_make_path(dev, card->longname + len, sizeof(card->longname) - len);
+
+	strlcat(card->longname,
+		snd_usb_get_speed(dev) == USB_SPEED_LOW ? ", low speed" :
+		snd_usb_get_speed(dev) == USB_SPEED_FULL ? ", full speed" :
+		", high speed",
+		sizeof(card->longname));
+
+	snd_usb_audio_create_proc(chip);
+
+	*rchip = chip;
+	return 0;
+}
+
+/*
+ * probe the active usb device
+ *
+ * note that this can be called multiple times per a device, when it
+ * includes multiple audio control interfaces.
+ *
+ * thus we check the usb device pointer and creates the card instance
+ * only at the first time.  the successive calls of this function will
+ * append the pcm interface to the corresponding card.
+ */
+static void *snd_usb_audio_probe(struct usb_device *dev,
+				 struct usb_interface *intf,
+				 const struct usb_device_id *usb_id)
+{
+	const struct snd_usb_audio_quirk *quirk = (const struct snd_usb_audio_quirk *)usb_id->driver_info;
+	int i, err;
+	struct snd_usb_audio *chip;
+	struct usb_host_interface *alts;
+	int ifnum;
+	u32 id;
+
+	alts = &intf->altsetting[0];
+	ifnum = get_iface_desc(alts)->bInterfaceNumber;
+	id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),
+		    le16_to_cpu(dev->descriptor.idProduct));
+	if (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)
+		goto __err_val;
+
+	if (snd_usb_apply_boot_quirk(dev, intf, quirk) < 0)
+		goto __err_val;
+
+	/*
+	 * found a config.  now register to ALSA
+	 */
+
+	/* check whether it's already registered */
+	chip = NULL;
+	mutex_lock(&register_mutex);
+	for (i = 0; i < SNDRV_CARDS; i++) {
+		if (usb_chip[i] && usb_chip[i]->dev == dev) {
+			if (usb_chip[i]->shutdown) {
+				snd_printk(KERN_ERR "USB device is in the shutdown state, cannot create a card instance\n");
+				goto __error;
+			}
+			chip = usb_chip[i];
+			break;
+		}
+	}
+	if (! chip) {
+		/* it's a fresh one.
+		 * now look for an empty slot and create a new card instance
+		 */
+		for (i = 0; i < SNDRV_CARDS; i++)
+			if (enable[i] && ! usb_chip[i] &&
+			    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&
+			    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {
+				if (snd_usb_audio_create(dev, i, quirk, &chip) < 0) {
+					goto __error;
+				}
+				snd_card_set_dev(chip->card, &intf->dev);
+				break;
+			}
+		if (!chip) {
+			printk(KERN_ERR "no available usb audio device\n");
+			goto __error;
+		}
+	}
+
+	chip->txfr_quirk = 0;
+	err = 1; /* continue */
+	if (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {
+		/* need some special handlings */
+		if ((err = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk)) < 0)
+			goto __error;
+	}
+
+	if (err > 0) {
+		/* create normal USB audio interfaces */
+		if (snd_usb_create_streams(chip, ifnum) < 0 ||
+		    snd_usb_create_mixer(chip, ifnum, ignore_ctl_error) < 0) {
+			goto __error;
+		}
+	}
+
+	/* we are allowed to call snd_card_register() many times */
+	if (snd_card_register(chip->card) < 0) {
+		goto __error;
+	}
+
+	usb_chip[chip->index] = chip;
+	chip->num_interfaces++;
+	mutex_unlock(&register_mutex);
+	return chip;
+
+ __error:
+	if (chip && !chip->num_interfaces)
+		snd_card_free(chip->card);
+	mutex_unlock(&register_mutex);
+ __err_val:
+	return NULL;
+}
+
+/*
+ * we need to take care of counter, since disconnection can be called also
+ * many times as well as usb_audio_probe().
+ */
+static void snd_usb_audio_disconnect(struct usb_device *dev, void *ptr)
+{
+	struct snd_usb_audio *chip;
+	struct snd_card *card;
+	struct list_head *p;
+
+	if (ptr == (void *)-1L)
+		return;
+
+	chip = ptr;
+	card = chip->card;
+	mutex_lock(&register_mutex);
+	chip->shutdown = 1;
+	chip->num_interfaces--;
+	if (chip->num_interfaces <= 0) {
+		snd_card_disconnect(card);
+		/* release the pcm resources */
+		list_for_each(p, &chip->pcm_list) {
+			snd_usb_stream_disconnect(p);
+		}
+		/* release the midi resources */
+		list_for_each(p, &chip->midi_list) {
+			snd_usbmidi_disconnect(p);
+		}
+		/* release mixer resources */
+		list_for_each(p, &chip->mixer_list) {
+			snd_usb_mixer_disconnect(p);
+		}
+		usb_chip[chip->index] = NULL;
+		mutex_unlock(&register_mutex);
+		snd_card_free_when_closed(card);
+	} else {
+		mutex_unlock(&register_mutex);
+	}
+}
+
+/*
+ * new 2.5 USB kernel API
+ */
+static int usb_audio_probe(struct usb_interface *intf,
+			   const struct usb_device_id *id)
+{
+	void *chip;
+	chip = snd_usb_audio_probe(interface_to_usbdev(intf), intf, id);
+	if (chip) {
+		usb_set_intfdata(intf, chip);
+		return 0;
+	} else
+		return -EIO;
+}
+
+static void usb_audio_disconnect(struct usb_interface *intf)
+{
+	snd_usb_audio_disconnect(interface_to_usbdev(intf),
+				 usb_get_intfdata(intf));
+}
+
+#ifdef CONFIG_PM
+static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct snd_usb_audio *chip = usb_get_intfdata(intf);
+	struct list_head *p;
+	struct snd_usb_stream *as;
+
+	if (chip == (void *)-1L)
+		return 0;
+
+	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);
+	if (!chip->num_suspended_intf++) {
+		list_for_each(p, &chip->pcm_list) {
+			as = list_entry(p, struct snd_usb_stream, list);
+			snd_pcm_suspend_all(as->pcm);
+		}
+	}
+
+	return 0;
+}
+
+static int usb_audio_resume(struct usb_interface *intf)
+{
+	struct snd_usb_audio *chip = usb_get_intfdata(intf);
+
+	if (chip == (void *)-1L)
+		return 0;
+	if (--chip->num_suspended_intf)
+		return 0;
+	/*
+	 * ALSA leaves material resumption to user space
+	 * we just notify
+	 */
+
+	snd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);
+
+	return 0;
+}
+#endif		/* CONFIG_PM */
+
+static struct usb_device_id usb_audio_ids [] = {
+#include "quirks-table.h"
+    { .match_flags = (USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS),
+      .bInterfaceClass = USB_CLASS_AUDIO,
+      .bInterfaceSubClass = USB_SUBCLASS_AUDIOCONTROL },
+    { }						/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, usb_audio_ids);
+
+/*
+ * entry point for linux usb interface
+ */
+
+static struct usb_driver usb_audio_driver = {
+	.name =		"snd-usb-audio",
+	.probe =	usb_audio_probe,
+	.disconnect =	usb_audio_disconnect,
+	.suspend =	usb_audio_suspend,
+	.resume =	usb_audio_resume,
+	.id_table =	usb_audio_ids,
+};
+
+static int __init snd_usb_audio_init(void)
+{
+	if (nrpacks < 1 || nrpacks > MAX_PACKS) {
+		printk(KERN_WARNING "invalid nrpacks value.\n");
+		return -EINVAL;
+	}
+	return usb_register(&usb_audio_driver);
+}
+
+static void __exit snd_usb_audio_cleanup(void)
+{
+	usb_deregister(&usb_audio_driver);
+}
+
+module_init(snd_usb_audio_init);
+module_exit(snd_usb_audio_cleanup);
