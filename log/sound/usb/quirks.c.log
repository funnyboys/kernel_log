commit a32a1fc99807244d920d274adc46ba04b538cc8a
Author: Macpaul Lin <macpaul.lin@mediatek.com>
Date:   Tue Jun 23 19:03:23 2020 +0800

    ALSA: usb-audio: add quirk for Samsung USBC Headset (AKG)
    
    We've found Samsung USBC Headset (AKG) (VID: 0x04e8, PID: 0xa051)
    need a tiny delay after each class compliant request.
    Otherwise the device might not be able to be recognized each times.
    
    Signed-off-by: Chihhao Chen <chihhao.chen@mediatek.com>
    Signed-off-by: Macpaul Lin <macpaul.lin@mediatek.com>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/1592910203-24035-1-git-send-email-macpaul.lin@mediatek.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 54d4b4b5bd11..fca72730a802 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1674,6 +1674,14 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	     chip->usb_id == USB_ID(0x0951, 0x16ad)) &&
 	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		usleep_range(1000, 2000);
+
+	/*
+	 * Samsung USBC Headset (AKG) need a tiny delay after each
+	 * class compliant request. (Model number: AAM625R or AAM627R)
+	 */
+	if (chip->usb_id == USB_ID(0x04e8, 0xa051) &&
+	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
+		usleep_range(5000, 6000);
 }
 
 /*

commit 73094608b8e214952444fb104651704c98a37aeb
Author: Christoffer Nielsen <cn@obviux.dk>
Date:   Fri Jun 19 13:48:22 2020 +0200

    ALSA: usb-audio: Add registration quirk for Kingston HyperX Cloud Flight S
    
    Similar to the Kingston HyperX AMP, the Kingston HyperX Cloud
    Alpha S (0951:0x16ea) uses two interfaces, but only the second
    interface contains the capture stream. This patch delays the
    registration until the second interface appears.
    
    Signed-off-by: Christoffer Nielsen <cn@obviux.dk>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/CAOtG2YHOM3zy+ed9KS-J4HkZo_QGzcUG9MigSp4e4_-13r6B=Q@mail.gmail.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index c495e720e2f1..54d4b4b5bd11 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1857,6 +1857,7 @@ struct registration_quirk {
 static const struct registration_quirk registration_quirks[] = {
 	REG_QUIRK_ENTRY(0x0951, 0x16d8, 2),	/* Kingston HyperX AMP */
 	REG_QUIRK_ENTRY(0x0951, 0x16ed, 2),	/* Kingston HyperX Cloud Alpha S */
+	REG_QUIRK_ENTRY(0x0951, 0x16ea, 2),	/* Kingston HyperX Cloud Flight S */
 	{ 0 }					/* terminator */
 };
 

commit c9808bbfed3cfc911ecb60fe8e80c0c27876c657
Author: Yick W. Tse <y_w_tse@yahoo.com.hk>
Date:   Sat Jun 13 11:40:06 2020 +0000

    ALSA: usb-audio: add quirk for Denon DCD-1500RE
    
    fix error "clock source 41 is not valid, cannot use"
    
    [] New USB device found, idVendor=154e, idProduct=1002, bcdDevice= 1.00
    [] New USB device strings: Mfr=1, Product=2, SerialNumber=0
    [] Product: DCD-1500RE
    [] Manufacturer: D & M Holdings Inc.
    []
    [] clock source 41 is not valid, cannot use
    [] usbcore: registered new interface driver snd-usb-audio
    
    Signed-off-by: Yick W. Tse <y_w_tse@yahoo.com.hk>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/1373857985.210365.1592048406997@mail.yahoo.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index bca0179a0ef8..c495e720e2f1 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1532,6 +1532,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 static bool is_itf_usb_dsd_dac(unsigned int id)
 {
 	switch (id) {
+	case USB_ID(0x154e, 0x1002): /* Denon DCD-1500RE */
 	case USB_ID(0x154e, 0x1003): /* Denon DA-300USB */
 	case USB_ID(0x154e, 0x3005): /* Marantz HD-DAC1 */
 	case USB_ID(0x154e, 0x3006): /* Marantz SA-14S1 */

commit 7fccfecf24fd1248c619e2cd7d55916327bf8dc1
Author: Dmitry Panchenko <dmitry@d-systems.ee>
Date:   Mon Jun 1 13:22:24 2020 +0300

    ALSA: usb-audio: Add Pioneer DJ DJM-900NXS2 support
    
    Pioneer DJ DJM-900NXS2 is a widely used DJ mixer with 2 audio USB
    interfaces. Both have a MIDI controller, 10 playback and 12 capture
    channels. Audio endpoints are vendor-specific and 3 files need to be
    patched. All playback and capture channels work fine with all supported
    sample rates (44.1k, 48k, 96k). Patches are attached.
    
    Signed-off-by: Dmitry Panchenko <dmitry@d-systems.ee>
    Link: https://lore.kernel.org/r/48ab19ff-3303-9bf8-ed0e-bcb31d8537eb@d-systems.ee
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index c0e3bc4afec6..bca0179a0ef8 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1458,6 +1458,30 @@ static void set_format_emu_quirk(struct snd_usb_substream *subs,
 	subs->pkt_offset_adj = (emu_samplerate_id >= EMU_QUIRK_SR_176400HZ) ? 4 : 0;
 }
 
+
+/*
+ * Pioneer DJ DJM-900NXS2
+ * Device needs to know the sample rate each time substream is started
+ */
+static int pioneer_djm_set_format_quirk(struct snd_usb_substream *subs)
+{
+
+	/* Convert sample rate value to little endian */
+	u8 sr[3];
+
+	sr[0] = subs->cur_rate & 0xff;
+	sr[1] = (subs->cur_rate >> 8) & 0xff;
+	sr[2] = (subs->cur_rate >> 16) & 0xff;
+
+	/* Configure device */
+	usb_set_interface(subs->dev, 0, 1);
+	snd_usb_ctl_msg(subs->stream->chip->dev,
+		usb_rcvctrlpipe(subs->stream->chip->dev, 0),
+		0x01, 0x22, 0x0100, 0x0082, &sr, 0x0003);
+
+	return 0;
+}
+
 void snd_usb_set_format_quirk(struct snd_usb_substream *subs,
 			      struct audioformat *fmt)
 {
@@ -1468,6 +1492,9 @@ void snd_usb_set_format_quirk(struct snd_usb_substream *subs,
 	case USB_ID(0x041e, 0x3f19): /* E-Mu 0204 USB */
 		set_format_emu_quirk(subs, fmt);
 		break;
+	case USB_ID(0x2b73, 0x000a): /* Pioneer DJ DJM-900NXS2 */
+		pioneer_djm_set_format_quirk(subs);
+		break;
 	}
 }
 

commit 6d2848402619f33895e419430ad43a223c4866fc
Merge: e0b2db351bc7 630e36126e42
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu May 28 10:08:46 2020 +0200

    Merge branch 'for-linus' into for-next
    
    Back-merge 5.7-devel branch for further development.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 073919e09ca445d4486968e3f851372ff44cf2b5
Author: Jesus Ramos <jesus-ramos@live.com>
Date:   Mon Apr 27 06:21:39 2020 -0700

    ALSA: usb-audio: Add control message quirk delay for Kingston HyperX headset
    
    Kingston HyperX headset with 0951:16ad also needs the same quirk for
    delaying the frequency controls.
    
    Signed-off-by: Jesus Ramos <jesus-ramos@live.com>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/BY5PR19MB3634BA68C7CCA23D8DF428E796AF0@BY5PR19MB3634.namprd19.prod.outlook.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 848a4cc25bed..d8a765be5dfe 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1636,13 +1636,14 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	    && (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		msleep(20);
 
-	/* Zoom R16/24, Logitech H650e, Jabra 550a needs a tiny delay here,
-	 * otherwise requests like get/set frequency return as failed despite
-	 * actually succeeding.
+	/* Zoom R16/24, Logitech H650e, Jabra 550a, Kingston HyperX needs a tiny
+	 * delay here, otherwise requests like get/set frequency return as
+	 * failed despite actually succeeding.
 	 */
 	if ((chip->usb_id == USB_ID(0x1686, 0x00dd) ||
 	     chip->usb_id == USB_ID(0x046d, 0x0a46) ||
-	     chip->usb_id == USB_ID(0x0b0e, 0x0349)) &&
+	     chip->usb_id == USB_ID(0x0b0e, 0x0349) ||
+	     chip->usb_id == USB_ID(0x0951, 0x16ad)) &&
 	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		usleep_range(1000, 2000);
 }

commit 547d2c9cf4f1f72adfecacbd5b093681fb0e8b3e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 30 14:47:55 2020 +0200

    ALSA: usb-audio: Correct a typo of NuPrime DAC-10 USB ID
    
    The USB vendor ID of NuPrime DAC-10 is not 16b0 but 16d0.
    
    Fixes: f656891c6619 ("ALSA: usb-audio: add more quirks for DSD interfaces")
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200430124755.15940-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 351ba214a9d3..848a4cc25bed 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1687,7 +1687,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 
 	case USB_ID(0x0d8c, 0x0316): /* Hegel HD12 DSD */
 	case USB_ID(0x10cb, 0x0103): /* The Bit Opus #3; with fp->dsd_raw */
-	case USB_ID(0x16b0, 0x06b2): /* NuPrime DAC-10 */
+	case USB_ID(0x16d0, 0x06b2): /* NuPrime DAC-10 */
 	case USB_ID(0x16d0, 0x09dd): /* Encore mDSD */
 	case USB_ID(0x16d0, 0x0733): /* Furutech ADL Stratos */
 	case USB_ID(0x16d0, 0x09db): /* NuPrime Audio DAC-9 */

commit 04c96460bfdb483de5aaad0f9f75b2f3eca500be
Author: Alexander Tsoy <alexander@tsoy.me>
Date:   Fri Apr 24 05:24:49 2020 +0300

    ALSA: usb-audio: Remove async workaround for Scarlett 2nd gen
    
    Frame size computation has been fixed and the workaround is no longer
    needed.
    
    Signed-off-by: Alexander Tsoy <alexander@tsoy.me>
    Link: https://lore.kernel.org/r/20200424022449.14972-2-alexander@tsoy.me
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 351ba214a9d3..a8ece1701068 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1806,20 +1806,6 @@ void snd_usb_audioformat_attributes_quirk(struct snd_usb_audio *chip,
 		 */
 		fp->attributes &= ~UAC_EP_CS_ATTR_FILL_MAX;
 		break;
-	case USB_ID(0x1235, 0x8200):  /* Focusrite Scarlett 2i4 2nd gen */
-	case USB_ID(0x1235, 0x8202):  /* Focusrite Scarlett 2i2 2nd gen */
-	case USB_ID(0x1235, 0x8205):  /* Focusrite Scarlett Solo 2nd gen */
-		/*
-		 * Reports that playback should use Synch: Synchronous
-		 * while still providing a feedback endpoint.
-		 * Synchronous causes snapping on some sample rates.
-		 * Force it to use Synch: Asynchronous.
-		 */
-		if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			fp->ep_attr &= ~USB_ENDPOINT_SYNCTYPE;
-			fp->ep_attr |= USB_ENDPOINT_SYNC_ASYNC;
-		}
-		break;
 	}
 }
 

commit cf9fb7b8737694818e783fc61e8fe220b7eaaf60
Author: Alexander Tsoy <alexander@tsoy.me>
Date:   Tue Apr 21 22:09:08 2020 +0300

    ALSA: usb-audio: Apply async workaround for Scarlett 2i4 2nd gen
    
    Due to rounding error driver sometimes incorrectly calculate next packet
    size, which results in audible clicks on devices with synchronous playback
    endpoints. For example on a high speed bus and a sample rate 44.1 kHz it
    loses one sample every ~40.9 seconds. Fortunately playback interface on
    Scarlett 2i4 2nd gen has a working explicit feedback endpoint, so we can
    switch playback data endpoint to asynchronous mode as a workaround.
    
    Signed-off-by: Alexander Tsoy <alexander@tsoy.me>
    Link: https://lore.kernel.org/r/20200421190908.462860-1-alexander@tsoy.me
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 6c2dfd3bfcbf..351ba214a9d3 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1806,6 +1806,7 @@ void snd_usb_audioformat_attributes_quirk(struct snd_usb_audio *chip,
 		 */
 		fp->attributes &= ~UAC_EP_CS_ATTR_FILL_MAX;
 		break;
+	case USB_ID(0x1235, 0x8200):  /* Focusrite Scarlett 2i4 2nd gen */
 	case USB_ID(0x1235, 0x8202):  /* Focusrite Scarlett 2i2 2nd gen */
 	case USB_ID(0x1235, 0x8205):  /* Focusrite Scarlett Solo 2nd gen */
 		/*

commit 6f4ea2074ddf689ac6f892afa58515032dabf2e4
Author: Gregor Pintar <grpintar@gmail.com>
Date:   Mon Apr 20 23:40:30 2020 +0200

    ALSA: usb-audio: Add quirk for Focusrite Scarlett 2i2
    
    Force it to use asynchronous playback.
    
    Same quirk has already been added for Focusrite Scarlett Solo (2nd gen)
    with a commit 46f5710f0b88 ("ALSA: usb-audio: Add quirk for Focusrite
    Scarlett Solo").
    
    This also seems to prevent regular clicks when playing at 44100Hz
    on Scarlett 2i2 (2nd gen). I did not notice any side effects.
    
    Moved both quirks to snd_usb_audioformat_attributes_quirk() as suggested.
    
    Signed-off-by: Gregor Pintar <grpintar@gmail.com>
    Reviewed-by: Alexander Tsoy <alexander@tsoy.me>
    Link: https://lore.kernel.org/r/20200420214030.2361-1-grpintar@gmail.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index a8ece1701068..6c2dfd3bfcbf 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1806,6 +1806,19 @@ void snd_usb_audioformat_attributes_quirk(struct snd_usb_audio *chip,
 		 */
 		fp->attributes &= ~UAC_EP_CS_ATTR_FILL_MAX;
 		break;
+	case USB_ID(0x1235, 0x8202):  /* Focusrite Scarlett 2i2 2nd gen */
+	case USB_ID(0x1235, 0x8205):  /* Focusrite Scarlett Solo 2nd gen */
+		/*
+		 * Reports that playback should use Synch: Synchronous
+		 * while still providing a feedback endpoint.
+		 * Synchronous causes snapping on some sample rates.
+		 * Force it to use Synch: Asynchronous.
+		 */
+		if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			fp->ep_attr &= ~USB_ENDPOINT_SYNCTYPE;
+			fp->ep_attr |= USB_ENDPOINT_SYNC_ASYNC;
+		}
+		break;
 	}
 }
 

commit fd60e0683e8e9107e09cd2e4798f3e27e85d2705
Author: Emmanuel Pescosta <emmanuelpescosta099@gmail.com>
Date:   Sat Apr 4 17:38:43 2020 +0200

    ALSA: usb-audio: Add registration quirk for Kingston HyperX Cloud Alpha S
    
    Similar to the Kingston HyperX AMP, the Kingston HyperX Cloud
    Alpha S (0951:16d8) uses two interfaces, but only the second
    interface contains the capture stream. This patch delays the
    registration until the second interface appears.
    
    Signed-off-by: Emmanuel Pescosta <emmanuelpescosta099@gmail.com>
    Link: https://lore.kernel.org/r/20200404153843.9288-1-emmanuelpescosta099@gmail.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 86f192a3043d..a8ece1701068 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1827,6 +1827,7 @@ struct registration_quirk {
 
 static const struct registration_quirk registration_quirks[] = {
 	REG_QUIRK_ENTRY(0x0951, 0x16d8, 2),	/* Kingston HyperX AMP */
+	REG_QUIRK_ENTRY(0x0951, 0x16ed, 2),	/* Kingston HyperX Cloud Alpha S */
 	{ 0 }					/* terminator */
 };
 

commit d8695bc5b1fe88305396b1f788d3b5f218e28a30
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 25 11:33:19 2020 +0100

    ALSA: usb-audio: Rewrite registration quirk handling
    
    A slight refactoring of the registration quirk code.  Now it uses the
    table lookup for easy additions in future.  Also the return type was
    changed to bool, and got a few more comments.
    
    Link: https://lore.kernel.org/r/20200325103322.2508-2-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index d605aff801b8..86f192a3043d 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1809,16 +1809,36 @@ void snd_usb_audioformat_attributes_quirk(struct snd_usb_audio *chip,
 	}
 }
 
-int snd_usb_registration_quirk(struct snd_usb_audio *chip,
-			       int iface)
+/*
+ * registration quirk:
+ * the registration is skipped if a device matches with the given ID,
+ * unless the interface reaches to the defined one.  This is for delaying
+ * the registration until the last known interface, so that the card and
+ * devices appear at the same time.
+ */
+
+struct registration_quirk {
+	unsigned int usb_id;	/* composed via USB_ID() */
+	unsigned int interface;	/* the interface to trigger register */
+};
+
+#define REG_QUIRK_ENTRY(vendor, product, iface) \
+	{ .usb_id = USB_ID(vendor, product), .interface = (iface) }
+
+static const struct registration_quirk registration_quirks[] = {
+	REG_QUIRK_ENTRY(0x0951, 0x16d8, 2),	/* Kingston HyperX AMP */
+	{ 0 }					/* terminator */
+};
+
+/* return true if skipping registration */
+bool snd_usb_registration_quirk(struct snd_usb_audio *chip, int iface)
 {
-	switch (chip->usb_id) {
-	case USB_ID(0x0951, 0x16d8): /* Kingston HyperX AMP */
-		/* Register only when we reach interface 2 so that streams can
-		 * merge correctly into PCMs from interface 0
-		 */
-		return (iface != 2);
-	}
+	const struct registration_quirk *q;
+
+	for (q = registration_quirks; q->usb_id; q++)
+		if (chip->usb_id == q->usb_id)
+			return iface != q->interface;
+
 	/* Register as normal */
-	return 0;
+	return false;
 }

commit 55f7326170d9e83e2d828591938e1101982a679c
Author: Chris Wulff <crwulff@gmail.com>
Date:   Sat Mar 14 12:54:49 2020 -0400

    ALSA: usb-audio: Create a registration quirk for Kingston HyperX Amp (0951:16d8)
    
    Create a quirk that allows special processing and/or
    skipping the call to snd_card_register.
    
    For HyperX AMP, which uses two interfaces, but only has
    a capture stream in the second, this allows the capture
    stream to merge with the first PCM.
    
    Signed-off-by: Chris Wulff <crwulff@gmail.com>
    Link: https://lore.kernel.org/r/20200314165449.4086-3-crwulff@gmail.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 3cc745fe24d8..d605aff801b8 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1808,3 +1808,17 @@ void snd_usb_audioformat_attributes_quirk(struct snd_usb_audio *chip,
 		break;
 	}
 }
+
+int snd_usb_registration_quirk(struct snd_usb_audio *chip,
+			       int iface)
+{
+	switch (chip->usb_id) {
+	case USB_ID(0x0951, 0x16d8): /* Kingston HyperX AMP */
+		/* Register only when we reach interface 2 so that streams can
+		 * merge correctly into PCMs from interface 0
+		 */
+		return (iface != 2);
+	}
+	/* Register as normal */
+	return 0;
+}

commit 2edb84e3047b93da2f2b234219cdc304df042d9e
Author: Alexander Tsoy <alexander@tsoy.me>
Date:   Sat Feb 29 18:18:15 2020 +0300

    ALSA: usb-audio: Add support for MOTU MicroBook IIc
    
    MicroBook IIc operates in UAC2 mode by default. This patch addresses
    several issues with it:
    
    - MicroBook II and IIc shares the same USB ID. We can distinguish them
      by interface class.
    - MaxPacketsOnly attribute is erroneously set in endpoint descriptors.
      As a result this card produces noise with all sample rates other than
      96 KHz. This also causes issues like IOMMU page faults and other
      problems with host controller.
    - Sample rate changes takes more than 2 seconds for this device. Clock
      validity request returns false during that period, so the clock validity
      quirk is required.
    
    Signed-off-by: Alexander Tsoy <alexander@tsoy.me>
    Link: https://lore.kernel.org/r/20200229151815.14199-1-alexander@tsoy.me
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 915aea256f65..3cc745fe24d8 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1352,7 +1352,15 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
 	case USB_ID(0x2466, 0x8010): /* Fractal Audio Axe-Fx 3 */
 		return snd_usb_axefx3_boot_quirk(dev);
 	case USB_ID(0x07fd, 0x0004): /* MOTU MicroBook II */
-		return snd_usb_motu_microbookii_boot_quirk(dev);
+		/*
+		 * For some reason interface 3 with vendor-spec class is
+		 * detected on MicroBook IIc.
+		 */
+		if (get_iface_desc(intf->altsetting)->bInterfaceClass ==
+		    USB_CLASS_VENDOR_SPEC &&
+		    get_iface_desc(intf->altsetting)->bInterfaceNumber < 3)
+			return snd_usb_motu_microbookii_boot_quirk(dev);
+		break;
 	}
 
 	return 0;
@@ -1790,5 +1798,13 @@ void snd_usb_audioformat_attributes_quirk(struct snd_usb_audio *chip,
 		else
 			fp->ep_attr |= USB_ENDPOINT_SYNC_SYNC;
 		break;
+	case USB_ID(0x07fd, 0x0004):  /* MOTU MicroBook IIc */
+		/*
+		 * MaxPacketsOnly attribute is erroneously set in endpoint
+		 * descriptors. As a result this card produces noise with
+		 * all sample rates other than 96 KHz.
+		 */
+		fp->attributes &= ~UAC_EP_CS_ATTR_FILL_MAX;
+		break;
 	}
 }

commit 2948f4a4e583a4d283a4b57b7b1101761daee5cc
Merge: 8dc5efe3d17c 60081b35c68b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 17 15:30:27 2020 +0100

    Merge branch 'topic/usb-uac2-effect-unit' into for-next
    
    Merging the UAC2 effect unit parser improvement.  As it's based on the
    previous usb-audio driver fix, it was deviated from for-next branch.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 8dc5efe3d17cd572328ac4f1ebde629c83317f54
Author: Nick Kossifidis <mickflemm@gmail.com>
Date:   Sat Feb 15 03:23:35 2020 +0200

    ALSA: usb-audio: Add support for Presonus Studio 1810c
    
    This patch adds support for Presonus Studio 1810c, a usb interface
    that's UAC2 compliant with a few quirks and a few extra hw-specific
    controls. I've tested all 3 altsettings and the added switch
    controls and they work as expected.
    
    More infos on the card:
    https://www.presonus.com/products/Studio-1810c
    
    Note that this work is based on packet inspection with
    usbmon. I just wanted to get this card to work for using
    it on our open-source radio station:
    https://github.com/UoC-Radio
    
    v2 address issues reported by Takashi:
    * Properly get/set enum type controls
    * Prevent race condition on switch_get/set
    * Various control naming changes
    * Various coding style fixes
    
    v3 improve readability of sample rate filtering
    and some other minor changes.
    
    Signed-off-by: Nick Kossifidis <mickflemm@gmail.com>
    Link: https://lore.kernel.org/r/5e47481a.1c69fb81.befb3.8dac@mx.google.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 3a5242e383b2..58761d408759 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1252,6 +1252,38 @@ static int fasttrackpro_skip_setting_quirk(struct snd_usb_audio *chip,
 	return 0; /* keep this altsetting */
 }
 
+static int s1810c_skip_setting_quirk(struct snd_usb_audio *chip,
+					   int iface, int altno)
+{
+	/*
+	 * Altno settings:
+	 *
+	 * Playback (Interface 1):
+	 * 1: 6 Analog + 2 S/PDIF
+	 * 2: 6 Analog + 2 S/PDIF
+	 * 3: 6 Analog
+	 *
+	 * Capture (Interface 2):
+	 * 1: 8 Analog + 2 S/PDIF + 8 ADAT
+	 * 2: 8 Analog + 2 S/PDIF + 4 ADAT
+	 * 3: 8 Analog
+	 */
+
+	/*
+	 * I'll leave 2 as the default one and
+	 * use device_setup to switch to the
+	 * other two.
+	 */
+	if ((chip->setup == 0 || chip->setup > 2) && altno != 2)
+		return 1;
+	else if (chip->setup == 1 && altno != 1)
+		return 1;
+	else if (chip->setup == 2 && altno != 3)
+		return 1;
+
+	return 0;
+}
+
 int snd_usb_apply_interface_quirk(struct snd_usb_audio *chip,
 				  int iface,
 				  int altno)
@@ -1265,6 +1297,10 @@ int snd_usb_apply_interface_quirk(struct snd_usb_audio *chip,
 	/* fasttrackpro usb: skip altsets incompatible with device_setup */
 	if (chip->usb_id == USB_ID(0x0763, 0x2012))
 		return fasttrackpro_skip_setting_quirk(chip, iface, altno);
+	/* presonus studio 1810c: skip altsets incompatible with device_setup */
+	if (chip->usb_id == USB_ID(0x0194f, 0x010c))
+		return s1810c_skip_setting_quirk(chip, iface, altno);
+
 
 	return 0;
 }

commit 93f9d1a4ac5930654c17412e3911b46ece73755a
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Tue Feb 11 11:22:35 2020 -0500

    ALSA: usb-audio: Apply sample rate quirk for Audioengine D1
    
    The Audioengine D1 (0x2912:0x30c8) does support reading the sample rate,
    but it returns the rate in byte-reversed order.
    
    When setting sampling rate, the driver produces these warning messages:
    [168840.944226] usb 3-2.2: current rate 4500480 is different from the runtime rate 44100
    [168854.930414] usb 3-2.2: current rate 8436480 is different from the runtime rate 48000
    [168905.185825] usb 3-2.1.2: current rate 30465 is different from the runtime rate 96000
    
    As can be seen from the hexadecimal conversion, the current rate read
    back is byte-reversed from the rate that was set.
    
    44100 == 0x00ac44, 4500480 == 0x44ac00
    48000 == 0x00bb80, 8436480 == 0x80bb00
    96000 == 0x017700,   30465 == 0x007701
    
    Rather than implementing a new quirk to reverse the order, just skip
    checking the rate to avoid spamming the log.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200211162235.1639889-1-nivedita@alum.mit.edu
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 3a5242e383b2..7f558f4b4520 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1440,6 +1440,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x1395, 0x740a): /* Sennheiser DECT */
 	case USB_ID(0x1901, 0x0191): /* GE B850V3 CP2114 audio interface */
 	case USB_ID(0x21b4, 0x0081): /* AudioQuest DragonFly */
+	case USB_ID(0x2912, 0x30c8): /* Audioengine D1 */
 		return true;
 	}
 

commit 73ac9f5e5b43a5dbadb61f27dae7a971f7ec0d22
Author: Alexander Tsoy <alexander@tsoy.me>
Date:   Sun Jan 12 13:23:58 2020 +0300

    ALSA: usb-audio: Add boot quirk for MOTU M Series
    
    Add delay to make sure that audio urbs are not sent too early.
    Otherwise the device hangs. Windows driver makes ~2s delay, so use
    about the same time delay value.
    
    snd_usb_apply_boot_quirk() is called 3 times for my MOTU M4, which
    is an overkill. Thus a quirk that is called only once is implemented.
    
    Also send two vendor-specific control messages before and after
    the delay. This behaviour is blindly copied from the Windows driver.
    
    Signed-off-by: Alexander Tsoy <alexander@tsoy.me>
    Link: https://lore.kernel.org/r/20200112102358.18085-1-alexander@tsoy.me
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 11159fcfdcdf..3a5242e383b2 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1113,6 +1113,31 @@ static int snd_usb_motu_microbookii_boot_quirk(struct usb_device *dev)
 	return err;
 }
 
+static int snd_usb_motu_m_series_boot_quirk(struct usb_device *dev)
+{
+	int ret;
+
+	if (snd_usb_pipe_sanity_check(dev, usb_sndctrlpipe(dev, 0)))
+		return -EINVAL;
+	ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+			      1, USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			      0x0, 0, NULL, 0, 1000);
+
+	if (ret < 0)
+		return ret;
+
+	msleep(2000);
+
+	ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+			      1, USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+			      0x20, 0, NULL, 0, 1000);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
 /*
  * Setup quirks
  */
@@ -1297,6 +1322,19 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
 	return 0;
 }
 
+int snd_usb_apply_boot_quirk_once(struct usb_device *dev,
+				  struct usb_interface *intf,
+				  const struct snd_usb_audio_quirk *quirk,
+				  unsigned int id)
+{
+	switch (id) {
+	case USB_ID(0x07fd, 0x0008): /* MOTU M Series */
+		return snd_usb_motu_m_series_boot_quirk(dev);
+	}
+
+	return 0;
+}
+
 /*
  * check if the device uses big-endian samples
  */

commit 8be03a7177c36bfc05bbe9f4949cdeba57f1c2ab
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 09:19:00 2020 +0100

    ALSA: usb-audio: Use lower hex numbers for IDs
    
    For consistency reason, make all hex numbers with lower alphabets for
    USB ID entries.  It improves grep-ability and reduces careless
    mistakes.
    
    Link: https://lore.kernel.org/r/20200105081900.21870-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 82184036437b..11159fcfdcdf 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1393,22 +1393,22 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 {
 	/* devices which do not support reading the sample rate. */
 	switch (chip->usb_id) {
-	case USB_ID(0x041E, 0x4080): /* Creative Live Cam VF0610 */
-	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
+	case USB_ID(0x041e, 0x4080): /* Creative Live Cam VF0610 */
+	case USB_ID(0x04d8, 0xfeea): /* Benchmark DAC1 Pre */
 	case USB_ID(0x0556, 0x0014): /* Phoenix Audio TMX320VC */
-	case USB_ID(0x05A3, 0x9420): /* ELP HD USB Camera */
+	case USB_ID(0x05a3, 0x9420): /* ELP HD USB Camera */
 	case USB_ID(0x05a7, 0x1020): /* Bose Companion 5 */
-	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
+	case USB_ID(0x074d, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
 	case USB_ID(0x1395, 0x740a): /* Sennheiser DECT */
 	case USB_ID(0x1901, 0x0191): /* GE B850V3 CP2114 audio interface */
-	case USB_ID(0x21B4, 0x0081): /* AudioQuest DragonFly */
+	case USB_ID(0x21b4, 0x0081): /* AudioQuest DragonFly */
 		return true;
 	}
 
 	/* devices of these vendors don't support reading rate, either */
 	switch (USB_ID_VENDOR(chip->usb_id)) {
-	case 0x045E: /* MS Lifecam */
-	case 0x047F: /* Plantronics */
+	case 0x045e: /* MS Lifecam */
+	case 0x047f: /* Plantronics */
 	case 0x1de7: /* Phoenix Audio */
 		return true;
 	}

commit 51d4efab7865e6ea6a4ebcd25b3f03c019515c4c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat Jan 4 12:09:36 2020 +0100

    ALSA: usb-audio: Apply the sample rate quirk for Bose Companion 5
    
    Bose Companion 5 (with USB ID 05a7:1020) doesn't seem supporting
    reading back the sample rate, so the existing quirk is needed.
    
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=206063
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200104110936.14288-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index a81c2066499f..82184036437b 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1397,6 +1397,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 	case USB_ID(0x0556, 0x0014): /* Phoenix Audio TMX320VC */
 	case USB_ID(0x05A3, 0x9420): /* ELP HD USB Camera */
+	case USB_ID(0x05a7, 0x1020): /* Bose Companion 5 */
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
 	case USB_ID(0x1395, 0x740a): /* Sennheiser DECT */
 	case USB_ID(0x1901, 0x0191): /* GE B850V3 CP2114 audio interface */

commit 92adc96f8eecd9522a907c197cc3d62e405539fe
Author: Hui Wang <hui.wang@canonical.com>
Date:   Wed Dec 18 21:26:50 2019 +0800

    ALSA: usb-audio: set the interface format after resume on Dell WD19
    
    Recently we found the headset-mic on the Dell Dock WD19 doesn't work
    anymore after s3 (s2i or deep), this problem could be workarounded by
    closing (pcm_close) the app and then reopening (pcm_open) the app, so
    this bug is not easy to be detected by users.
    
    When problem happens, retire_capture_urb() could still be called
    periodically, but the size of captured data is always 0, it could be
    a firmware bug on the dock. Anyway I found after resuming, the
    snd_usb_pcm_prepare() will be called, and if we forcibly run
    set_format() to set the interface and its endpoint, the capture
    size will be normal again. This problem and workaound also apply to
    playback.
    
    To fix it in the kernel, add a quirk to let set_format() run
    forcibly once after resume.
    
    Signed-off-by: Hui Wang <hui.wang@canonical.com>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20191218132650.6303-1-hui.wang@canonical.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 349e1e52996d..a81c2066499f 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -508,6 +508,16 @@ static int create_standard_mixer_quirk(struct snd_usb_audio *chip,
 	return snd_usb_create_mixer(chip, quirk->ifnum, 0);
 }
 
+
+static int setup_fmt_after_resume_quirk(struct snd_usb_audio *chip,
+				       struct usb_interface *iface,
+				       struct usb_driver *driver,
+				       const struct snd_usb_audio_quirk *quirk)
+{
+	chip->setup_fmt_after_resume_quirk = 1;
+	return 1;	/* Continue with creating streams and mixer */
+}
+
 /*
  * audio-interface quirks
  *
@@ -546,6 +556,7 @@ int snd_usb_create_quirk(struct snd_usb_audio *chip,
 		[QUIRK_AUDIO_EDIROL_UAXX] = create_uaxx_quirk,
 		[QUIRK_AUDIO_ALIGN_TRANSFER] = create_align_transfer_quirk,
 		[QUIRK_AUDIO_STANDARD_MIXER] = create_standard_mixer_quirk,
+		[QUIRK_SETUP_FMT_AFTER_RESUME] = setup_fmt_after_resume_quirk,
 	};
 
 	if (quirk->type < QUIRK_TYPE_COUNT) {

commit cc9dbfa9707868fb0ca864c05e0c42d3f4d15cf2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 13 12:12:59 2019 +0100

    ALSA: usb-audio: Fix incorrect NULL check in create_yamaha_midi_quirk()
    
    The commit 60849562a5db ("ALSA: usb-audio: Fix possible NULL
    dereference at create_yamaha_midi_quirk()") added NULL checks in
    create_yamaha_midi_quirk(), but there was an overlook.  The code
    allows one of either injd or outjd is NULL, but the second if check
    made returning -ENODEV if any of them is NULL.  Fix it in a proper
    form.
    
    Fixes: 60849562a5db ("ALSA: usb-audio: Fix possible NULL dereference at create_yamaha_midi_quirk()")
    Reported-by: Pavel Machek <pavel@denx.de>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20191113111259.24123-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 0bbe1201a6ac..349e1e52996d 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -248,8 +248,8 @@ static int create_yamaha_midi_quirk(struct snd_usb_audio *chip,
 					NULL, USB_MS_MIDI_OUT_JACK);
 	if (!injd && !outjd)
 		return -ENODEV;
-	if (!(injd && snd_usb_validate_midi_desc(injd)) ||
-	    !(outjd && snd_usb_validate_midi_desc(outjd)))
+	if ((injd && !snd_usb_validate_midi_desc(injd)) ||
+	    (outjd && !snd_usb_validate_midi_desc(outjd)))
 		return -ENODEV;
 	if (injd && (injd->bLength < 5 ||
 		     (injd->bJackType != USB_MS_EMBEDDED &&

commit e2995b95a914bbc6b5352be27d5d5f33ec802d2c
Author: Justin Song <flyingecar@gmail.com>
Date:   Thu Oct 24 12:27:14 2019 +0200

    ALSA: usb-audio: Add DSD support for Gustard U16/X26 USB Interface
    
    This patch adds native DSD support for Gustard U16/X26 USB Interface.
    Tested using VID and fp->dsd_raw method.
    
    Signed-off-by: Justin Song <flyingecar@gmail.com>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/CA+9XP1ipsFn+r3bCBKRinQv-JrJ+EHOGBdZWZoMwxFv0R8Y1MQ@mail.gmail.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index fbfde996fee7..0bbe1201a6ac 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1657,6 +1657,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	case 0x23ba:  /* Playback Designs */
 	case 0x25ce:  /* Mytek devices */
 	case 0x278b:  /* Rotel? */
+	case 0x292b:  /* Gustard/Ess based devices */
 	case 0x2ab6:  /* T+A devices */
 	case 0x3842:  /* EVGA */
 	case 0xc502:  /* HiBy devices */

commit f41f900568d9ffd896cc941db7021eb14bd55910
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Tue Sep 24 10:11:43 2019 +0300

    ALSA: usb-audio: Add DSD support for EVGA NU Audio
    
    EVGA NU Audio is actually a USB audio device on a PCIexpress card,
    with it's own USB controller. It supports both PCM and DSD.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20190924071143.30911-1-jussi@sonarnerd.net
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 5fd4ccce452d..fbfde996fee7 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1658,6 +1658,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	case 0x25ce:  /* Mytek devices */
 	case 0x278b:  /* Rotel? */
 	case 0x2ab6:  /* T+A devices */
+	case 0x3842:  /* EVGA */
 	case 0xc502:  /* HiBy devices */
 		if (fp->dsd_raw)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;

commit 029d2c0fd61eac74700fb4ffff36fc63bfff7e5e
Author: Ilya Pshonkin <sudokamikaze@protonmail.com>
Date:   Tue Sep 17 10:49:34 2019 +0300

    ALSA: usb-audio: Add Hiby device family to quirks for native DSD support
    
    This patch adds quirk VID ID for Hiby portable players family with
    native DSD playback support.
    
    Signed-off-by: Ilya Pshonkin <sudokamikaze@protonmail.com>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20190917074937.157802-1-ilya.pshonkin@netforce.ua
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 25faf2d3c639..5fd4ccce452d 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1658,6 +1658,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	case 0x25ce:  /* Mytek devices */
 	case 0x278b:  /* Rotel? */
 	case 0x2ab6:  /* T+A devices */
+	case 0xc502:  /* HiBy devices */
 		if (fp->dsd_raw)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

commit 0067e154b11e236d62a7a8205f321b097c21a35b
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Wed Aug 28 00:08:47 2019 +0300

    ALSA: usb-audio: Update DSD support quirks for Oppo and Rotel
    
    Oppo has issued firmware updates that change alt setting used for DSD
    support. However, these devices seem to support auto-detection, so
    support is moved from explicit whitelisting to auto-detection.
    
    Also Rotel devices have USB interfaces that support DSD with
    auto-detection.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 08ec3dac5dfe..25faf2d3c639 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1584,9 +1584,6 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	/* XMOS based USB DACs */
 	switch (chip->usb_id) {
 	case USB_ID(0x1511, 0x0037): /* AURALiC VEGA */
-	case USB_ID(0x22d9, 0x0416): /* OPPO HA-1 */
-	case USB_ID(0x22d9, 0x0436): /* OPPO Sonica */
-	case USB_ID(0x22d9, 0x0461): /* OPPO UDP-205 */
 	case USB_ID(0x2522, 0x0012): /* LH Labs VI DAC Infinity */
 	case USB_ID(0x2772, 0x0230): /* Pro-Ject Pre Box S2 Digital */
 		if (fp->altsetting == 2)
@@ -1600,7 +1597,6 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	case USB_ID(0x16d0, 0x0733): /* Furutech ADL Stratos */
 	case USB_ID(0x16d0, 0x09db): /* NuPrime Audio DAC-9 */
 	case USB_ID(0x1db5, 0x0003): /* Bryston BDA3 */
-	case USB_ID(0x22d9, 0x0426): /* OPPO HA-2 */
 	case USB_ID(0x22e1, 0xca01): /* HDTA Serenade DSD */
 	case USB_ID(0x249c, 0x9326): /* M2Tech Young MkIII */
 	case USB_ID(0x2616, 0x0106): /* PS Audio NuWave DAC */
@@ -1657,8 +1653,10 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	switch (USB_ID_VENDOR(chip->usb_id)) {
 	case 0x152a:  /* Thesycon devices */
 	case 0x20b1:  /* XMOS based devices */
+	case 0x22d9:  /* Oppo */
 	case 0x23ba:  /* Playback Designs */
 	case 0x25ce:  /* Mytek devices */
+	case 0x278b:  /* Rotel? */
 	case 0x2ab6:  /* T+A devices */
 		if (fp->dsd_raw)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;

commit eb7505d52a2f8b0cfc3fd7146d8cb2dab5a73f0d
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Wed Aug 28 00:08:46 2019 +0300

    ALSA: usb-audio: DSD auto-detection for Playback Designs
    
    Add DSD support auto-detection for newer Playback Designs devices. Older
    device generations have a different USB interface implementation.
    
    Keep the auto-detection VID whitelist sorted.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 5c0fa5cf1987..08ec3dac5dfe 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1566,7 +1566,8 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	struct usb_interface *iface;
 
 	/* Playback Designs */
-	if (USB_ID_VENDOR(chip->usb_id) == 0x23ba) {
+	if (USB_ID_VENDOR(chip->usb_id) == 0x23ba &&
+	    USB_ID_PRODUCT(chip->usb_id) < 0x0110) {
 		switch (fp->altsetting) {
 		case 1:
 			fp->dsd_dop = true;
@@ -1654,8 +1655,9 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	 * from XMOS/Thesycon
 	 */
 	switch (USB_ID_VENDOR(chip->usb_id)) {
-	case 0x20b1:  /* XMOS based devices */
 	case 0x152a:  /* Thesycon devices */
+	case 0x20b1:  /* XMOS based devices */
+	case 0x23ba:  /* Playback Designs */
 	case 0x25ce:  /* Mytek devices */
 	case 0x2ab6:  /* T+A devices */
 		if (fp->dsd_raw)

commit 60849562a5db4a1eee2160167e4dce4590d3eafe
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Aug 26 13:55:21 2019 +0200

    ALSA: usb-audio: Fix possible NULL dereference at create_yamaha_midi_quirk()
    
    The previous addition of descriptor validation may lead to a NULL
    dereference at create_yamaha_midi_quirk() when either injd or outjd is
    NULL.  Add proper non-NULL checks.
    
    Fixes: 57f8770620e9 ("ALSA: usb-audio: More validations of descriptor units")
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 7e9735aa7ac9..5c0fa5cf1987 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -248,8 +248,8 @@ static int create_yamaha_midi_quirk(struct snd_usb_audio *chip,
 					NULL, USB_MS_MIDI_OUT_JACK);
 	if (!injd && !outjd)
 		return -ENODEV;
-	if (!snd_usb_validate_midi_desc(injd) ||
-	    !snd_usb_validate_midi_desc(outjd))
+	if (!(injd && snd_usb_validate_midi_desc(injd)) ||
+	    !(outjd && snd_usb_validate_midi_desc(outjd)))
 		return -ENODEV;
 	if (injd && (injd->bLength < 5 ||
 		     (injd->bJackType != USB_MS_EMBEDDED &&

commit 57f8770620e9b51c61089751f0b5ad3dbe376ff2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 20 17:17:09 2019 +0200

    ALSA: usb-audio: More validations of descriptor units
    
    Introduce a new helper to validate each audio descriptor unit before
    and check the unit before actually accessing it.  This should harden
    against the OOB access cases with malformed descriptors that have been
    recently frequently reported by fuzzers.
    
    The existing descriptor checks are still kept although they become
    superfluous after this patch.  They'll be cleaned up eventually
    later.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 78858918cbc1..7e9735aa7ac9 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -248,6 +248,9 @@ static int create_yamaha_midi_quirk(struct snd_usb_audio *chip,
 					NULL, USB_MS_MIDI_OUT_JACK);
 	if (!injd && !outjd)
 		return -ENODEV;
+	if (!snd_usb_validate_midi_desc(injd) ||
+	    !snd_usb_validate_midi_desc(outjd))
+		return -ENODEV;
 	if (injd && (injd->bLength < 5 ||
 		     (injd->bJackType != USB_MS_EMBEDDED &&
 		      injd->bJackType != USB_MS_EXTERNAL)))

commit 3c53c6255d598db7084c5c3d7553d7200e857818
Merge: b89b889a326a a98429acadef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 8 14:45:20 2019 +0200

    Merge tag 'asoc-v5.3' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.3
    
    This is a very big update, mainly thanks to Morimoto-san's refactoring
    work and some fairly large new drivers.
    
     - Lots more work on moving towards a component based framework from
       Morimoto-san.
     - Support for force disconnecting muxes from Jerome Brunet.
     - New drivers for Cirrus Logic CS47L35, CS47L85 and CS47L90, Conexant
       CX2072X, Realtek RT1011 and RT1308.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 801ebf1043ae7b182588554cc9b9ad3c14bc2ab5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jun 24 15:08:28 2019 +0200

    ALSA: usb-audio: Sanity checks for each pipe and EP types
    
    The recent USB core code performs sanity checks for the given pipe and
    EP types, and it can be hit by manipulated USB descriptors by syzbot.
    For making syzbot happier, this patch introduces a local helper for a
    sanity check in the driver side and calls it at each place before the
    message handling, so that we can avoid the WARNING splats.
    
    Reported-by: syzbot+d952e5e28f5fb7718d23@syzkaller.appspotmail.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index e6ce1bbe6ca6..057143330a28 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -840,11 +840,13 @@ static int snd_usb_novation_boot_quirk(struct usb_device *dev)
 static int snd_usb_accessmusic_boot_quirk(struct usb_device *dev)
 {
 	int err, actual_length;
-
 	/* "midi send" enable */
 	static const u8 seq[] = { 0x4e, 0x73, 0x52, 0x01 };
+	void *buf;
 
-	void *buf = kmemdup(seq, ARRAY_SIZE(seq), GFP_KERNEL);
+	if (snd_usb_pipe_sanity_check(dev, usb_sndintpipe(dev, 0x05)))
+		return -EINVAL;
+	buf = kmemdup(seq, ARRAY_SIZE(seq), GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 	err = usb_interrupt_msg(dev, usb_sndintpipe(dev, 0x05), buf,
@@ -869,7 +871,11 @@ static int snd_usb_accessmusic_boot_quirk(struct usb_device *dev)
 
 static int snd_usb_nativeinstruments_boot_quirk(struct usb_device *dev)
 {
-	int ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+	int ret;
+
+	if (snd_usb_pipe_sanity_check(dev, usb_sndctrlpipe(dev, 0)))
+		return -EINVAL;
+	ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				  0xaf, USB_TYPE_VENDOR | USB_RECIP_DEVICE,
 				  1, 0, NULL, 0, 1000);
 
@@ -976,6 +982,8 @@ static int snd_usb_axefx3_boot_quirk(struct usb_device *dev)
 
 	dev_dbg(&dev->dev, "Waiting for Axe-Fx III to boot up...\n");
 
+	if (snd_usb_pipe_sanity_check(dev, usb_sndctrlpipe(dev, 0)))
+		return -EINVAL;
 	/* If the Axe-Fx III has not fully booted, it will timeout when trying
 	 * to enable the audio streaming interface. A more generous timeout is
 	 * used here to detect when the Axe-Fx III has finished booting as the
@@ -1008,6 +1016,8 @@ static int snd_usb_motu_microbookii_communicate(struct usb_device *dev, u8 *buf,
 {
 	int err, actual_length;
 
+	if (snd_usb_pipe_sanity_check(dev, usb_sndintpipe(dev, 0x01)))
+		return -EINVAL;
 	err = usb_interrupt_msg(dev, usb_sndintpipe(dev, 0x01), buf, *length,
 				&actual_length, 1000);
 	if (err < 0)
@@ -1018,6 +1028,8 @@ static int snd_usb_motu_microbookii_communicate(struct usb_device *dev, u8 *buf,
 
 	memset(buf, 0, buf_size);
 
+	if (snd_usb_pipe_sanity_check(dev, usb_rcvintpipe(dev, 0x82)))
+		return -EINVAL;
 	err = usb_interrupt_msg(dev, usb_rcvintpipe(dev, 0x82), buf, buf_size,
 				&actual_length, 1000);
 	if (err < 0)

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index e6ce1bbe6ca6..cf5cff10c08e 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1,17 +1,5 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include <linux/init.h>

commit a634090a0f242caa8ebc91967b118995a80eb13b
Author: Manuel Reinhardt <manuel.rhdt@gmail.com>
Date:   Thu Feb 28 20:34:04 2019 +0100

    ALSA: usb-audio: Add quirk for MOTU MicroBook II
    
    Add an entry to the quirks-table to for usb-audio to recognize the
    Microbook II (although it only exposes vendor interfaces). A simple boot
    quirk is also implemented to set up the sample rate and  make sure that
    no audio urbs are sent before the device is ready.
    
    This patch only provides audio playback and capture at 96kHz sample
    rate. Notice the following shortcomings:
    
    - The sample rate is currently hardcoded to 96k although the device also
      supports 48k and 44.1k.
    
    - The various mixer controls of the MicroBook are not made available.
    
    - The keep-iface control should be on by default because the device
      shuts down whenever the altsetting is reset which is usually unwanted.
      (I don't know the best way to do this)
    
    - The communication format used by the MicroBook for sample rate setting
      and also other setup has been reverse engineered by looking at the
      usbmon output while running the windows driver through virtualbox. In
      this patch the first byte of every message is set to \0 while in the
      observed communications the first byte acts as a "message-counter"
      increasing its value with every message sent. Leaving it at \0 does
      not seem to affect the device.
    
    Signed-off-by: Manuel Reinhardt <manuel.rhdt@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index f372c624bbf4..e6ce1bbe6ca6 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1000,6 +1000,105 @@ static int snd_usb_axefx3_boot_quirk(struct usb_device *dev)
 	return 0;
 }
 
+
+#define MICROBOOK_BUF_SIZE 128
+
+static int snd_usb_motu_microbookii_communicate(struct usb_device *dev, u8 *buf,
+						int buf_size, int *length)
+{
+	int err, actual_length;
+
+	err = usb_interrupt_msg(dev, usb_sndintpipe(dev, 0x01), buf, *length,
+				&actual_length, 1000);
+	if (err < 0)
+		return err;
+
+	print_hex_dump(KERN_DEBUG, "MicroBookII snd: ", DUMP_PREFIX_NONE, 16, 1,
+		       buf, actual_length, false);
+
+	memset(buf, 0, buf_size);
+
+	err = usb_interrupt_msg(dev, usb_rcvintpipe(dev, 0x82), buf, buf_size,
+				&actual_length, 1000);
+	if (err < 0)
+		return err;
+
+	print_hex_dump(KERN_DEBUG, "MicroBookII rcv: ", DUMP_PREFIX_NONE, 16, 1,
+		       buf, actual_length, false);
+
+	*length = actual_length;
+	return 0;
+}
+
+static int snd_usb_motu_microbookii_boot_quirk(struct usb_device *dev)
+{
+	int err, actual_length, poll_attempts = 0;
+	static const u8 set_samplerate_seq[] = { 0x00, 0x00, 0x00, 0x00,
+						 0x00, 0x00, 0x0b, 0x14,
+						 0x00, 0x00, 0x00, 0x01 };
+	static const u8 poll_ready_seq[] = { 0x00, 0x04, 0x00, 0x00,
+					     0x00, 0x00, 0x0b, 0x18 };
+	u8 *buf = kzalloc(MICROBOOK_BUF_SIZE, GFP_KERNEL);
+
+	if (!buf)
+		return -ENOMEM;
+
+	dev_info(&dev->dev, "Waiting for MOTU Microbook II to boot up...\n");
+
+	/* First we tell the device which sample rate to use. */
+	memcpy(buf, set_samplerate_seq, sizeof(set_samplerate_seq));
+	actual_length = sizeof(set_samplerate_seq);
+	err = snd_usb_motu_microbookii_communicate(dev, buf, MICROBOOK_BUF_SIZE,
+						   &actual_length);
+
+	if (err < 0) {
+		dev_err(&dev->dev,
+			"failed setting the sample rate for Motu MicroBook II: %d\n",
+			err);
+		goto free_buf;
+	}
+
+	/* Then we poll every 100 ms until the device informs of its readiness. */
+	while (true) {
+		if (++poll_attempts > 100) {
+			dev_err(&dev->dev,
+				"failed booting Motu MicroBook II: timeout\n");
+			err = -ENODEV;
+			goto free_buf;
+		}
+
+		memset(buf, 0, MICROBOOK_BUF_SIZE);
+		memcpy(buf, poll_ready_seq, sizeof(poll_ready_seq));
+
+		actual_length = sizeof(poll_ready_seq);
+		err = snd_usb_motu_microbookii_communicate(
+			dev, buf, MICROBOOK_BUF_SIZE, &actual_length);
+		if (err < 0) {
+			dev_err(&dev->dev,
+				"failed booting Motu MicroBook II: communication error %d\n",
+				err);
+			goto free_buf;
+		}
+
+		/* the device signals its readiness through a message of the
+		 * form
+		 *           XX 06 00 00 00 00 0b 18  00 00 00 01
+		 * If the device is not yet ready to accept audio data, the
+		 * last byte of that sequence is 00.
+		 */
+		if (actual_length == 12 && buf[actual_length - 1] == 1)
+			break;
+
+		msleep(100);
+	}
+
+	dev_info(&dev->dev, "MOTU MicroBook II ready\n");
+
+free_buf:
+	kfree(buf);
+	return err;
+}
+
 /*
  * Setup quirks
  */
@@ -1177,6 +1276,8 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
 		return snd_usb_gamecon780_boot_quirk(dev);
 	case USB_ID(0x2466, 0x8010): /* Fractal Audio Axe-Fx 3 */
 		return snd_usb_axefx3_boot_quirk(dev);
+	case USB_ID(0x07fd, 0x0004): /* MOTU MicroBook II */
+		return snd_usb_motu_microbookii_boot_quirk(dev);
 	}
 
 	return 0;

commit 7b48b3b2263c275168b6c6192d487d939c097e8d
Merge: d02cac152c97 0a5cf9e88b51
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 8 14:22:45 2019 +0100

    Merge branch 'for-linus' into for-next
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 3bff2407fbd28fd55ad5b5cccd98fc0c9598f23b
Author: Udo Eberhardt <udo.eberhardt@thesycon.de>
Date:   Tue Feb 5 17:20:47 2019 +0100

    ALSA: usb-audio: Add support for new T+A USB DAC
    
    This patch adds the T+A VID to the generic check in order to enable
    native DSD support for T+A devices. This works with the new T+A USB
    DAC model SD3100HV and will also work with future devices which
    support the XMOS/Thesycon style DSD format.
    
    Signed-off-by: Udo Eberhardt <udo.eberhardt@thesycon.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index bb8372833fc2..7e65fe853ee3 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1567,6 +1567,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	case 0x20b1:  /* XMOS based devices */
 	case 0x152a:  /* Thesycon devices */
 	case 0x25ce:  /* Mytek devices */
+	case 0x2ab6:  /* T+A devices */
 		if (fp->dsd_raw)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

commit 202e69e645545e8dcec5e239658125276a7a315a
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Tue Jan 29 00:47:01 2019 +0200

    ALSA: usb-audio: Cleanup DSD whitelist
    
    XMOS/Thesycon family of USB Audio Class firmware flags DSD altsetting
    separate from the PCM ones. Thus the DSD altsetting can be auto-detected
    based on the flag and doesn't need maintaining specific altsetting
    whitelist.
    
    In addition, static VID:PID-to-altsetting whitelisting causes problems
    when firmware update changes the altsetting, or same VID:PID is reused
    for another device that has different kind of firmware.
    
    This patch removes existing explicit whitelist mappings for XMOS VID
    (0x20b1) and Thesycon VID (0x152a).
    
    Also corrects placement of Hegel HD12 and NuPrime DAC-10 to keep list
    sorted based on VID.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index bb8372833fc2..ef67d19117c4 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1479,10 +1479,6 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	/* XMOS based USB DACs */
 	switch (chip->usb_id) {
 	case USB_ID(0x1511, 0x0037): /* AURALiC VEGA */
-	case USB_ID(0x20b1, 0x0002): /* Wyred 4 Sound DAC-2 DSD */
-	case USB_ID(0x20b1, 0x2004): /* Matrix Audio X-SPDIF 2 */
-	case USB_ID(0x20b1, 0x2008): /* Matrix Audio X-Sabre */
-	case USB_ID(0x20b1, 0x300a): /* Matrix Audio Mini-i Pro */
 	case USB_ID(0x22d9, 0x0416): /* OPPO HA-1 */
 	case USB_ID(0x22d9, 0x0436): /* OPPO Sonica */
 	case USB_ID(0x22d9, 0x0461): /* OPPO UDP-205 */
@@ -1492,23 +1488,13 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
 
-	case USB_ID(0x10cb, 0x0103): /* The Bit Opus #3; with fp->dsd_raw */
-	case USB_ID(0x152a, 0x85de): /* SMSL D1 DAC */
-	case USB_ID(0x16d0, 0x09dd): /* Encore mDSD */
 	case USB_ID(0x0d8c, 0x0316): /* Hegel HD12 DSD */
+	case USB_ID(0x10cb, 0x0103): /* The Bit Opus #3; with fp->dsd_raw */
 	case USB_ID(0x16b0, 0x06b2): /* NuPrime DAC-10 */
+	case USB_ID(0x16d0, 0x09dd): /* Encore mDSD */
 	case USB_ID(0x16d0, 0x0733): /* Furutech ADL Stratos */
 	case USB_ID(0x16d0, 0x09db): /* NuPrime Audio DAC-9 */
 	case USB_ID(0x1db5, 0x0003): /* Bryston BDA3 */
-	case USB_ID(0x20b1, 0x000a): /* Gustard DAC-X20U */
-	case USB_ID(0x20b1, 0x2005): /* Denafrips Ares DAC */
-	case USB_ID(0x20b1, 0x2009): /* DIYINHK DSD DXD 384kHz USB to I2S/DSD */
-	case USB_ID(0x20b1, 0x2023): /* JLsounds I2SoverUSB */
-	case USB_ID(0x20b1, 0x3021): /* Eastern El. MiniMax Tube DAC Supreme */
-	case USB_ID(0x20b1, 0x3023): /* Aune X1S 32BIT/384 DSD DAC */
-	case USB_ID(0x20b1, 0x302d): /* Unison Research Unico CD Due */
-	case USB_ID(0x20b1, 0x307b): /* CH Precision C1 DAC */
-	case USB_ID(0x20b1, 0x3086): /* Singxer F-1 converter board */
 	case USB_ID(0x22d9, 0x0426): /* OPPO HA-2 */
 	case USB_ID(0x22e1, 0xca01): /* HDTA Serenade DSD */
 	case USB_ID(0x249c, 0x9326): /* M2Tech Young MkIII */

commit 9e6966646b6bc5078d579151b90016522d4ff2cb
Author: Olek Poplavsky <woodenbits@gmail.com>
Date:   Thu Jan 24 23:30:03 2019 -0500

    ALSA: usb-audio: Add Opus #3 to quirks for native DSD support
    
    This patch adds quirk VID/PID IDs for the Opus #3 DAP (made by 'The Bit')
    in order to enable Native DSD support.
    
    [ NOTE: this could be handled in the generic way with fp->dvd_raw if
      we add 0x10cb to the vendor whitelist, but since 0x10cb shows a
      different vendor name (Erantech), put to the individual entry at
      this time -- tiwai ]
    
    Signed-off-by: Olek Poplavsky <woodenbits@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index ebbadb3a7094..bb8372833fc2 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1492,6 +1492,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
 
+	case USB_ID(0x10cb, 0x0103): /* The Bit Opus #3; with fp->dsd_raw */
 	case USB_ID(0x152a, 0x85de): /* SMSL D1 DAC */
 	case USB_ID(0x16d0, 0x09dd): /* Encore mDSD */
 	case USB_ID(0x0d8c, 0x0316): /* Hegel HD12 DSD */

commit f5c9571e2265b3cbfad2ed41ba60c3da474daa61
Author: Amadeusz Sawiski <amade@asmblr.net>
Date:   Tue Jan 8 21:03:11 2019 +0100

    ALSA: usb-audio: fix CM6206 register definitions
    
    fix typo after a recent commit causing headphones to have no sound
    
    Fixes: ad43d528a7ac (ALSA: usb-audio: Define registers for CM6206)
    Signed-off-by: Amadeusz Sawiski <amade@asmblr.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 96340f23f86d..ebbadb3a7094 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -768,7 +768,7 @@ static int snd_usb_cm6206_boot_quirk(struct usb_device *dev)
 		 * REG1: PLL binary search enable, soft mute enable.
 		 */
 		CM6206_REG1_PLLBIN_EN |
-		CM6206_REG1_SOFT_MUTE_EN |
+		CM6206_REG1_SOFT_MUTE_EN,
 		/*
 		 * REG2: enable output drivers,
 		 * select front channels to the headphone output,

commit 2bff7e97ebbb1119e9f22936706294f4e85d4db6
Merge: 157ab88ef64a bde1a7459623
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Dec 7 11:40:00 2018 +0100

    Merge branch 'for-linus' into for-next
    
    Back-merge for applying the more HD-audio quirks on top of the latest
    code.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 44ff57e685f96d0cb9540004cc9d1d880e7a4315
Author: Tony Das <tdas444@gmail.com>
Date:   Wed Nov 28 20:16:37 2018 +0000

    ALSA: usb-audio: Add SMSL D1 to quirks for native DSD support
    
    This patch adds quirk VID/PID IDs for the SMSL D1 in order to enable
    Native DSD support.
    
    [ Moved the added entry in numerical order -- tiwai ]
    
    Signed-off-by: Tony Das <tdas444@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 8a945ece9869..6623cafc94f2 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1373,6 +1373,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
 
+	case USB_ID(0x152a, 0x85de): /* SMSL D1 DAC */
 	case USB_ID(0x16d0, 0x09dd): /* Encore mDSD */
 	case USB_ID(0x0d8c, 0x0316): /* Hegel HD12 DSD */
 	case USB_ID(0x16b0, 0x06b2): /* NuPrime DAC-10 */

commit ad43d528a7ac5636cf113cb09644d3ec18129123
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Nov 2 22:11:33 2018 +0100

    ALSA: usb-audio: Define registers for CM6206
    
    The register map for CM6206 is known and we can define what
    the values written to the different registers actually mean.
    
    I tested to print the hex values before/after this change,
    there is no functional change.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 8a945ece9869..3d0f09108c98 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -19,6 +19,7 @@
 #include <linux/usb.h>
 #include <linux/usb/audio.h>
 #include <linux/usb/midi.h>
+#include <linux/bits.h>
 
 #include <sound/control.h>
 #include <sound/core.h>
@@ -668,15 +669,133 @@ static int snd_usb_cm106_boot_quirk(struct usb_device *dev)
 }
 
 /*
- * C-Media CM6206 is based on CM106 with two additional
- * registers that are not documented in the data sheet.
- * Values here are chosen based on sniffing USB traffic
- * under Windows.
+ * CM6206 registers from the CM6206 datasheet rev 2.1
  */
+#define CM6206_REG0_DMA_MASTER BIT(15)
+#define CM6206_REG0_SPDIFO_RATE_48K (2 << 12)
+#define CM6206_REG0_SPDIFO_RATE_96K (7 << 12)
+/* Bit 4 thru 11 is the S/PDIF category code */
+#define CM6206_REG0_SPDIFO_CAT_CODE_GENERAL (0 << 4)
+#define CM6206_REG0_SPDIFO_EMPHASIS_CD BIT(3)
+#define CM6206_REG0_SPDIFO_COPYRIGHT_NA BIT(2)
+#define CM6206_REG0_SPDIFO_NON_AUDIO BIT(1)
+#define CM6206_REG0_SPDIFO_PRO_FORMAT BIT(0)
+
+#define CM6206_REG1_TEST_SEL_CLK BIT(14)
+#define CM6206_REG1_PLLBIN_EN BIT(13)
+#define CM6206_REG1_SOFT_MUTE_EN BIT(12)
+#define CM6206_REG1_GPIO4_OUT BIT(11)
+#define CM6206_REG1_GPIO4_OE BIT(10)
+#define CM6206_REG1_GPIO3_OUT BIT(9)
+#define CM6206_REG1_GPIO3_OE BIT(8)
+#define CM6206_REG1_GPIO2_OUT BIT(7)
+#define CM6206_REG1_GPIO2_OE BIT(6)
+#define CM6206_REG1_GPIO1_OUT BIT(5)
+#define CM6206_REG1_GPIO1_OE BIT(4)
+#define CM6206_REG1_SPDIFO_INVALID BIT(3)
+#define CM6206_REG1_SPDIF_LOOP_EN BIT(2)
+#define CM6206_REG1_SPDIFO_DIS BIT(1)
+#define CM6206_REG1_SPDIFI_MIX BIT(0)
+
+#define CM6206_REG2_DRIVER_ON BIT(15)
+#define CM6206_REG2_HEADP_SEL_SIDE_CHANNELS (0 << 13)
+#define CM6206_REG2_HEADP_SEL_SURROUND_CHANNELS (1 << 13)
+#define CM6206_REG2_HEADP_SEL_CENTER_SUBW (2 << 13)
+#define CM6206_REG2_HEADP_SEL_FRONT_CHANNELS (3 << 13)
+#define CM6206_REG2_MUTE_HEADPHONE_RIGHT BIT(12)
+#define CM6206_REG2_MUTE_HEADPHONE_LEFT BIT(11)
+#define CM6206_REG2_MUTE_REAR_SURROUND_RIGHT BIT(10)
+#define CM6206_REG2_MUTE_REAR_SURROUND_LEFT BIT(9)
+#define CM6206_REG2_MUTE_SIDE_SURROUND_RIGHT BIT(8)
+#define CM6206_REG2_MUTE_SIDE_SURROUND_LEFT BIT(7)
+#define CM6206_REG2_MUTE_SUBWOOFER BIT(6)
+#define CM6206_REG2_MUTE_CENTER BIT(5)
+#define CM6206_REG2_MUTE_RIGHT_FRONT BIT(3)
+#define CM6206_REG2_MUTE_LEFT_FRONT BIT(3)
+#define CM6206_REG2_EN_BTL BIT(2)
+#define CM6206_REG2_MCUCLKSEL_1_5_MHZ (0)
+#define CM6206_REG2_MCUCLKSEL_3_MHZ (1)
+#define CM6206_REG2_MCUCLKSEL_6_MHZ (2)
+#define CM6206_REG2_MCUCLKSEL_12_MHZ (3)
+
+/* Bit 11..13 sets the sensitivity to FLY tuner volume control VP/VD signal */
+#define CM6206_REG3_FLYSPEED_DEFAULT (2 << 11)
+#define CM6206_REG3_VRAP25EN BIT(10)
+#define CM6206_REG3_MSEL1 BIT(9)
+#define CM6206_REG3_SPDIFI_RATE_44_1K BIT(0 << 7)
+#define CM6206_REG3_SPDIFI_RATE_48K BIT(2 << 7)
+#define CM6206_REG3_SPDIFI_RATE_32K BIT(3 << 7)
+#define CM6206_REG3_PINSEL BIT(6)
+#define CM6206_REG3_FOE BIT(5)
+#define CM6206_REG3_ROE BIT(4)
+#define CM6206_REG3_CBOE BIT(3)
+#define CM6206_REG3_LOSE BIT(2)
+#define CM6206_REG3_HPOE BIT(1)
+#define CM6206_REG3_SPDIFI_CANREC BIT(0)
+
+#define CM6206_REG5_DA_RSTN BIT(13)
+#define CM6206_REG5_AD_RSTN BIT(12)
+#define CM6206_REG5_SPDIFO_AD2SPDO BIT(12)
+#define CM6206_REG5_SPDIFO_SEL_FRONT (0 << 9)
+#define CM6206_REG5_SPDIFO_SEL_SIDE_SUR (1 << 9)
+#define CM6206_REG5_SPDIFO_SEL_CEN_LFE (2 << 9)
+#define CM6206_REG5_SPDIFO_SEL_REAR_SUR (3 << 9)
+#define CM6206_REG5_CODECM BIT(8)
+#define CM6206_REG5_EN_HPF BIT(7)
+#define CM6206_REG5_T_SEL_DSDA4 BIT(6)
+#define CM6206_REG5_T_SEL_DSDA3 BIT(5)
+#define CM6206_REG5_T_SEL_DSDA2 BIT(4)
+#define CM6206_REG5_T_SEL_DSDA1 BIT(3)
+#define CM6206_REG5_T_SEL_DSDAD_NORMAL 0
+#define CM6206_REG5_T_SEL_DSDAD_FRONT 4
+#define CM6206_REG5_T_SEL_DSDAD_S_SURROUND 5
+#define CM6206_REG5_T_SEL_DSDAD_CEN_LFE 6
+#define CM6206_REG5_T_SEL_DSDAD_R_SURROUND 7
+
 static int snd_usb_cm6206_boot_quirk(struct usb_device *dev)
 {
 	int err  = 0, reg;
-	int val[] = {0x2004, 0x3000, 0xf800, 0x143f, 0x0000, 0x3000};
+	int val[] = {
+		/*
+		 * Values here are chosen based on sniffing USB traffic
+		 * under Windows.
+		 *
+		 * REG0: DAC is master, sample rate 48kHz, no copyright
+		 */
+		CM6206_REG0_SPDIFO_RATE_48K |
+		CM6206_REG0_SPDIFO_COPYRIGHT_NA,
+		/*
+		 * REG1: PLL binary search enable, soft mute enable.
+		 */
+		CM6206_REG1_PLLBIN_EN |
+		CM6206_REG1_SOFT_MUTE_EN |
+		/*
+		 * REG2: enable output drivers,
+		 * select front channels to the headphone output,
+		 * then mute the headphone channels, run the MCU
+		 * at 1.5 MHz.
+		 */
+		CM6206_REG2_DRIVER_ON |
+		CM6206_REG2_HEADP_SEL_FRONT_CHANNELS |
+		CM6206_REG2_MUTE_HEADPHONE_RIGHT |
+		CM6206_REG2_MUTE_HEADPHONE_LEFT,
+		/*
+		 * REG3: default flyspeed, set 2.5V mic bias
+		 * enable all line out ports and enable SPDIF
+		 */
+		CM6206_REG3_FLYSPEED_DEFAULT |
+		CM6206_REG3_VRAP25EN |
+		CM6206_REG3_FOE |
+		CM6206_REG3_ROE |
+		CM6206_REG3_CBOE |
+		CM6206_REG3_LOSE |
+		CM6206_REG3_HPOE |
+		CM6206_REG3_SPDIFI_CANREC,
+		/* REG4 is just a bunch of GPIO lines */
+		0x0000,
+		/* REG5: de-assert AD/DA reset signals */
+		CM6206_REG5_DA_RSTN |
+		CM6206_REG5_AD_RSTN };
 
 	for (reg = 0; reg < ARRAY_SIZE(val); reg++) {
 		err = snd_usb_cm106_write_int_reg(dev, reg, val[reg]);

commit df3f0347fd856272ca9fdbb6e691b7b512b7acb4
Author: Jia-Ju Bai <baijiaju1990@gmail.com>
Date:   Fri Jul 27 16:55:28 2018 +0800

    ALSA: usb-audio: quirks: Replace mdelay() with msleep() and usleep_range()
    
    snd_usb_select_mode_quirk(), snd_usb_set_interface_quirk() and
    snd_usb_ctl_msg_quirk() are never called in atomic context.
    They call mdelay() to busily wait, which is not necessary.
    mdelay() can be replaced with msleep() and usleep_range().
    
    This is found by a static analysis tool named DCNS written by myself.
    
    Signed-off-by: Jia-Ju Bai <baijiaju1990@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index dde87d64bc32..8a945ece9869 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1213,7 +1213,7 @@ int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
 		if (err < 0)
 			return err;
 
-		mdelay(20); /* Delay needed after setting the interface */
+		msleep(20); /* Delay needed after setting the interface */
 
 		/* Vendor mode switch cmd is required. */
 		if (fmt->formats & SNDRV_PCM_FMTBIT_DSD_U32_BE) {
@@ -1234,7 +1234,7 @@ int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
 				return err;
 
 		}
-		mdelay(20);
+		msleep(20);
 	}
 	return 0;
 }
@@ -1281,7 +1281,7 @@ void snd_usb_set_interface_quirk(struct usb_device *dev)
 	switch (USB_ID_VENDOR(chip->usb_id)) {
 	case 0x23ba: /* Playback Design */
 	case 0x0644: /* TEAC Corp. */
-		mdelay(50);
+		msleep(50);
 		break;
 	}
 }
@@ -1301,7 +1301,7 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	 */
 	if (USB_ID_VENDOR(chip->usb_id) == 0x23ba &&
 	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
-		mdelay(20);
+		msleep(20);
 
 	/*
 	 * "TEAC Corp." products need a 20ms delay after each
@@ -1309,14 +1309,14 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	 */
 	if (USB_ID_VENDOR(chip->usb_id) == 0x0644 &&
 	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
-		mdelay(20);
+		msleep(20);
 
 	/* ITF-USB DSD based DACs functionality need a delay
 	 * after each class compliant request
 	 */
 	if (is_itf_usb_dsd_dac(chip->usb_id)
 	    && (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
-		mdelay(20);
+		msleep(20);
 
 	/* Zoom R16/24, Logitech H650e, Jabra 550a needs a tiny delay here,
 	 * otherwise requests like get/set frequency return as failed despite
@@ -1326,7 +1326,7 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	     chip->usb_id == USB_ID(0x046d, 0x0a46) ||
 	     chip->usb_id == USB_ID(0x0b0e, 0x0349)) &&
 	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
-		mdelay(1);
+		usleep_range(1000, 2000);
 }
 
 /*

commit b080dc5bd0dfc0b33c6cfc31f909c93d5e63c186
Author: Jeff Crukley <jcrukley@gmail.com>
Date:   Wed Jul 25 15:05:01 2018 -0400

    ALSA: usb-audio: Add support for Encore mDSD USB DAC
    
    This patch adds native DSD playback support for the Encore mDSD USB DAC by
    specifying the vendor and product ID's
    
    Signed-off-by: Jeff Crukley <jcrukley@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 06ae3f5adf4b..dde87d64bc32 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1373,6 +1373,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
 
+	case USB_ID(0x16d0, 0x09dd): /* Encore mDSD */
 	case USB_ID(0x0d8c, 0x0316): /* Hegel HD12 DSD */
 	case USB_ID(0x16b0, 0x06b2): /* NuPrime DAC-10 */
 	case USB_ID(0x16d0, 0x0733): /* Furutech ADL Stratos */

commit 1ea0358ecb848058b35b6da13d7f4c08610a73a8
Author: Yue Wang <yuleopen@gmail.com>
Date:   Mon Jul 23 01:56:46 2018 -0700

    ALSA: usb-audio: Generic DSD detection for Thesycon-based implementations
    
    Thesycon provides solutions to XMOS chips, and has its own device
    vendor id.
    
    In this patch, we use generic method to detect DSD capability of
    Thesycon-based UAC2 implementations in order to support a wide range
    of current and future devices.
    
    The patch will enable the SNDRV_PCM_FMTBIT_DSD_U32_BE bit for the DAC
    hence enable native DSD playback up to DSD512 format.
    
    Signed-off-by: Yue Wang <yuleopen@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 02b6cc02767f..06ae3f5adf4b 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1443,6 +1443,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	 */
 	switch (USB_ID_VENDOR(chip->usb_id)) {
 	case 0x20b1:  /* XMOS based devices */
+	case 0x152a:  /* Thesycon devices */
 	case 0x25ce:  /* Mytek devices */
 		if (fp->dsd_raw)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;

commit d9d5ed1ad5d8a256c8c3f6b7736d9dad10232637
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Wed Jun 13 09:08:55 2018 +0300

    ALSA: usb-audio: Remove explicitly listed Mytek devices
    
    Remove explicitly listed Mytek devices covered by the more generic DSD
    detection method.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 4cf79b26645e..02b6cc02767f 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1368,9 +1368,6 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	case USB_ID(0x22d9, 0x0436): /* OPPO Sonica */
 	case USB_ID(0x22d9, 0x0461): /* OPPO UDP-205 */
 	case USB_ID(0x2522, 0x0012): /* LH Labs VI DAC Infinity */
-	case USB_ID(0x25ce, 0x001f): /* Mytek Brooklyn DAC */
-	case USB_ID(0x25ce, 0x0021): /* Mytek Manhattan DAC */
-	case USB_ID(0x25ce, 0x8025): /* Mytek Brooklyn DAC+ */
 	case USB_ID(0x2772, 0x0230): /* Pro-Ject Pre Box S2 Digital */
 		if (fp->altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;

commit f332485fb37baecc3e2e598870f33d06c15a74f3
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Wed Jun 13 01:43:02 2018 +0300

    ALSA: usb-audio: Generic DSD detection for XMOS-based implementations
    
    Use more generic method to detect DSD capability of XMOS-based UAC2
    implementations in order to support future devices without having to
    explicitly list every device separately.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index c616c251dbac..4cf79b26645e 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1362,7 +1362,6 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	case USB_ID(0x1511, 0x0037): /* AURALiC VEGA */
 	case USB_ID(0x20b1, 0x0002): /* Wyred 4 Sound DAC-2 DSD */
 	case USB_ID(0x20b1, 0x2004): /* Matrix Audio X-SPDIF 2 */
-	case USB_ID(0x20b1, 0x3008): /* iFi Audio micro/nano iDSD */
 	case USB_ID(0x20b1, 0x2008): /* Matrix Audio X-Sabre */
 	case USB_ID(0x20b1, 0x300a): /* Matrix Audio Mini-i Pro */
 	case USB_ID(0x22d9, 0x0416): /* OPPO HA-1 */
@@ -1389,7 +1388,6 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	case USB_ID(0x20b1, 0x3021): /* Eastern El. MiniMax Tube DAC Supreme */
 	case USB_ID(0x20b1, 0x3023): /* Aune X1S 32BIT/384 DSD DAC */
 	case USB_ID(0x20b1, 0x302d): /* Unison Research Unico CD Due */
-	case USB_ID(0x20b1, 0x3036): /* Holo Springs Level 3 R2R DAC */
 	case USB_ID(0x20b1, 0x307b): /* CH Precision C1 DAC */
 	case USB_ID(0x20b1, 0x3086): /* Singxer F-1 converter board */
 	case USB_ID(0x22d9, 0x0426): /* OPPO HA-2 */
@@ -1447,6 +1445,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	 * from XMOS/Thesycon
 	 */
 	switch (USB_ID_VENDOR(chip->usb_id)) {
+	case 0x20b1:  /* XMOS based devices */
 	case 0x25ce:  /* Mytek devices */
 		if (fp->dsd_raw)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;

commit 3a572d94bcff98a14c94fe686881a169a26f3fca
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Wed Jun 13 01:43:01 2018 +0300

    ALSA: usb-audio: Add native DSD support for Mytek DACs
    
    Add new mostly generic code with Mytek VID to support native DSD mode.
    
    This implementation should be easier to maintain when manufacturers
    release new products.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index f4b69173682c..c616c251dbac 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1443,6 +1443,19 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 	}
 
+	/* Mostly generic method to detect many DSD-capable implementations -
+	 * from XMOS/Thesycon
+	 */
+	switch (USB_ID_VENDOR(chip->usb_id)) {
+	case 0x25ce:  /* Mytek devices */
+		if (fp->dsd_raw)
+			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
+		break;
+	default:
+		break;
+
+	}
+
 	return 0;
 }
 

commit 16bafa792c860e50768b2527ded364137c6ed21e
Author: Alberto Aguirre <albaguirre@gmail.com>
Date:   Tue May 8 17:14:13 2018 -0500

    ALSA: usb-audio: add boot quirk for Axe-Fx III
    
    Wait for Axe-Fx III to fully bootup before initializing card.
    
    Signed-off-by: Alberto Aguirre <albaguirre@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 5681767cc0d5..f4b69173682c 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -851,6 +851,36 @@ static int snd_usb_mbox2_boot_quirk(struct usb_device *dev)
 	return 0; /* Successful boot */
 }
 
+static int snd_usb_axefx3_boot_quirk(struct usb_device *dev)
+{
+	int err;
+
+	dev_dbg(&dev->dev, "Waiting for Axe-Fx III to boot up...\n");
+
+	/* If the Axe-Fx III has not fully booted, it will timeout when trying
+	 * to enable the audio streaming interface. A more generous timeout is
+	 * used here to detect when the Axe-Fx III has finished booting as the
+	 * set interface message will be acked once it has
+	 */
+	err = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				USB_REQ_SET_INTERFACE, USB_RECIP_INTERFACE,
+				1, 1, NULL, 0, 120000);
+	if (err < 0) {
+		dev_err(&dev->dev,
+			"failed waiting for Axe-Fx III to boot: %d\n", err);
+		return err;
+	}
+
+	dev_dbg(&dev->dev, "Axe-Fx III is now ready\n");
+
+	err = usb_set_interface(dev, 1, 0);
+	if (err < 0)
+		dev_dbg(&dev->dev,
+			"error stopping Axe-Fx III interface: %d\n", err);
+
+	return 0;
+}
+
 /*
  * Setup quirks
  */
@@ -1026,6 +1056,8 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
 		return snd_usb_fasttrackpro_boot_quirk(dev);
 	case USB_ID(0x047f, 0xc010): /* Plantronics Gamecom 780 */
 		return snd_usb_gamecon780_boot_quirk(dev);
+	case USB_ID(0x2466, 0x8010): /* Fractal Audio Axe-Fx 3 */
+		return snd_usb_axefx3_boot_quirk(dev);
 	}
 
 	return 0;

commit f656891c66193345ee90b212b280d726792dc16c
Author: Daniel Mack <daniel@zonque.org>
Date:   Fri Apr 20 22:29:41 2018 +0200

    ALSA: usb-audio: add more quirks for DSD interfaces
    
    Based on a downstream patch from Harry ten Berge.
    
    Signed-off-by: Daniel Mack <daniel@zonque.org>
    Reported-and-tested-by: wenyi@tianyu-wool.com
    Original-by: Harry ten Berge <htenberge@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index acbeb52f6fd6..5681767cc0d5 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1327,20 +1327,47 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 
 	/* XMOS based USB DACs */
 	switch (chip->usb_id) {
+	case USB_ID(0x1511, 0x0037): /* AURALiC VEGA */
+	case USB_ID(0x20b1, 0x0002): /* Wyred 4 Sound DAC-2 DSD */
+	case USB_ID(0x20b1, 0x2004): /* Matrix Audio X-SPDIF 2 */
 	case USB_ID(0x20b1, 0x3008): /* iFi Audio micro/nano iDSD */
 	case USB_ID(0x20b1, 0x2008): /* Matrix Audio X-Sabre */
 	case USB_ID(0x20b1, 0x300a): /* Matrix Audio Mini-i Pro */
 	case USB_ID(0x22d9, 0x0416): /* OPPO HA-1 */
+	case USB_ID(0x22d9, 0x0436): /* OPPO Sonica */
+	case USB_ID(0x22d9, 0x0461): /* OPPO UDP-205 */
+	case USB_ID(0x2522, 0x0012): /* LH Labs VI DAC Infinity */
+	case USB_ID(0x25ce, 0x001f): /* Mytek Brooklyn DAC */
+	case USB_ID(0x25ce, 0x0021): /* Mytek Manhattan DAC */
+	case USB_ID(0x25ce, 0x8025): /* Mytek Brooklyn DAC+ */
 	case USB_ID(0x2772, 0x0230): /* Pro-Ject Pre Box S2 Digital */
 		if (fp->altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
 
+	case USB_ID(0x0d8c, 0x0316): /* Hegel HD12 DSD */
+	case USB_ID(0x16b0, 0x06b2): /* NuPrime DAC-10 */
+	case USB_ID(0x16d0, 0x0733): /* Furutech ADL Stratos */
+	case USB_ID(0x16d0, 0x09db): /* NuPrime Audio DAC-9 */
+	case USB_ID(0x1db5, 0x0003): /* Bryston BDA3 */
 	case USB_ID(0x20b1, 0x000a): /* Gustard DAC-X20U */
+	case USB_ID(0x20b1, 0x2005): /* Denafrips Ares DAC */
 	case USB_ID(0x20b1, 0x2009): /* DIYINHK DSD DXD 384kHz USB to I2S/DSD */
 	case USB_ID(0x20b1, 0x2023): /* JLsounds I2SoverUSB */
+	case USB_ID(0x20b1, 0x3021): /* Eastern El. MiniMax Tube DAC Supreme */
 	case USB_ID(0x20b1, 0x3023): /* Aune X1S 32BIT/384 DSD DAC */
+	case USB_ID(0x20b1, 0x302d): /* Unison Research Unico CD Due */
+	case USB_ID(0x20b1, 0x3036): /* Holo Springs Level 3 R2R DAC */
+	case USB_ID(0x20b1, 0x307b): /* CH Precision C1 DAC */
+	case USB_ID(0x20b1, 0x3086): /* Singxer F-1 converter board */
+	case USB_ID(0x22d9, 0x0426): /* OPPO HA-2 */
+	case USB_ID(0x22e1, 0xca01): /* HDTA Serenade DSD */
+	case USB_ID(0x249c, 0x9326): /* M2Tech Young MkIII */
 	case USB_ID(0x2616, 0x0106): /* PS Audio NuWave DAC */
+	case USB_ID(0x2622, 0x0041): /* Audiolab M-DAC+ */
+	case USB_ID(0x27f7, 0x3002): /* W4S DAC-2v2SE */
+	case USB_ID(0x29a2, 0x0086): /* Mutec MC3+ USB */
+	case USB_ID(0x6b42, 0x0042): /* MSB Technology */
 		if (fp->altsetting == 3)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

commit f3b906d720e429a3acd95f8cbd4fda366fb1659d
Author: Nobutaka Okabe <nob77413@gmail.com>
Date:   Fri Mar 23 19:21:13 2018 +0900

    ALSA: usb-audio: Integrate native DSD support for ITF-USB based DACs.
    
    Integrate the native DSD support quirk codes of "ITF-USB DSD" based DACs.
    
    Now, "is_itf_usb_dsd_2alts_dac()" and "is_itf_usb_dsd_3alts_dac()" is
    integrated into one function "is_itf_usb_dsd_dac()".
    So, remove the logic to distinguish UD-501 and UD-501V2 by the
    "Product Name".
    
    The integration is possible by changing the following two functions.
    
    - snd_usb_select_mode_quirk():
    Change the determination condition of the DSD mode switch command,
    from the altset number being used, to the audio format being played.
    Actually, this operation is same as playback using ASIO driver in
    Windows environment.
    
    - snd_usb_interface_dsd_format_quirk():
    To which altset supports native DSD is determined by the number of altsets.
    Previously, it's a constant "2" or "3".
    
    Signed-off-by: Nobutaka Okabe <nob77413@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index da73405c3115..acbeb52f6fd6 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1151,48 +1151,18 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 
 /* ITF-USB DSD based DACs need a vendor cmd to switch
  * between PCM and native DSD mode
- * (2 altsets version)
  */
-static bool is_itf_usb_dsd_2alts_dac(struct snd_usb_audio *chip)
+static bool is_itf_usb_dsd_dac(unsigned int id)
 {
-	char *product = chip->dev->product; /* DAC product name */
-
-	switch (chip->usb_id) {
+	switch (id) {
 	case USB_ID(0x154e, 0x1003): /* Denon DA-300USB */
 	case USB_ID(0x154e, 0x3005): /* Marantz HD-DAC1 */
 	case USB_ID(0x154e, 0x3006): /* Marantz SA-14S1 */
 	case USB_ID(0x1852, 0x5065): /* Luxman DA-06 */
-		return true;
-	case USB_ID(0x0644, 0x8043):
-		/* TEAC UD-501 */
-		if (product && strcmp("UD-501", product)) {
-			return true;
-		} else {
-			return false;
-		}
-	}
-	return false;
-}
-
-/* ITF-USB DSD based DACs need a vendor cmd to switch
- * between PCM and native DSD mode
- * (3 altsets version)
- */
-static bool is_itf_usb_dsd_3alts_dac(struct snd_usb_audio *chip)
-{
-	char *product = chip->dev->product; /* DAC product name */
-
-	switch (chip->usb_id) {
+	case USB_ID(0x0644, 0x8043): /* TEAC UD-501/UD-501V2/UD-503/NT-503 */
 	case USB_ID(0x0644, 0x8044): /* Esoteric D-05X */
 	case USB_ID(0x0644, 0x804a): /* TEAC UD-301 */
 		return true;
-	case USB_ID(0x0644, 0x8043):
-		/* TEAC UD-501V2/UD-503/NT-503 */
-		if (product && !strcmp("UD-501", product)) {
-			return true;
-		} else {
-			return false;
-		}
 	}
 	return false;
 }
@@ -1203,7 +1173,7 @@ int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
 	struct usb_device *dev = subs->dev;
 	int err;
 
-	if (is_itf_usb_dsd_2alts_dac(subs->stream->chip)) {
+	if (is_itf_usb_dsd_dac(subs->stream->chip->usb_id)) {
 		/* First switch to alt set 0, otherwise the mode switch cmd
 		 * will not be accepted by the DAC
 		 */
@@ -1213,37 +1183,26 @@ int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
 
 		mdelay(20); /* Delay needed after setting the interface */
 
-		switch (fmt->altsetting) {
-		case 2: /* DSD mode requested */
-		case 1: /* PCM mode requested */
-			err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), 0,
-					      USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,
-					      fmt->altsetting - 1, 1, NULL, 0);
-			if (err < 0)
-				return err;
-			break;
-		}
-		mdelay(20);
-	} else if (is_itf_usb_dsd_3alts_dac(subs->stream->chip)) {
 		/* Vendor mode switch cmd is required. */
-		switch (fmt->altsetting) {
-		case 3: /* DSD mode (DSD_U32) requested */
+		if (fmt->formats & SNDRV_PCM_FMTBIT_DSD_U32_BE) {
+			/* DSD mode (DSD_U32) requested */
 			err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), 0,
 					      USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,
 					      1, 1, NULL, 0);
 			if (err < 0)
 				return err;
-			break;
 
-		case 2: /* PCM or DOP mode (S32) requested */
-		case 1: /* PCM mode (S16) requested */
+		} else {
+			/* PCM or DOP mode (S32) requested */
+			/* PCM mode (S16) requested */
 			err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), 0,
 					      USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,
 					      0, 1, NULL, 0);
 			if (err < 0)
 				return err;
-			break;
+
 		}
+		mdelay(20);
 	}
 	return 0;
 }
@@ -1323,7 +1282,7 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	/* ITF-USB DSD based DACs functionality need a delay
 	 * after each class compliant request
 	 */
-	if (is_itf_usb_dsd_2alts_dac(chip)
+	if (is_itf_usb_dsd_dac(chip->usb_id)
 	    && (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(20);
 
@@ -1349,6 +1308,8 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 					struct audioformat *fp,
 					unsigned int sample_bytes)
 {
+	struct usb_interface *iface;
+
 	/* Playback Designs */
 	if (USB_ID_VENDOR(chip->usb_id) == 0x23ba) {
 		switch (fp->altsetting) {
@@ -1410,15 +1371,16 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 		break;
 	}
 
-	/* ITF-USB DSD based DACs (2 altsets version) */
-	if (is_itf_usb_dsd_2alts_dac(chip)) {
-		if (fp->altsetting == 2)
-			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
-	}
+	/* ITF-USB DSD based DACs */
+	if (is_itf_usb_dsd_dac(chip->usb_id)) {
+		iface = usb_ifnum_to_if(chip->dev, fp->iface);
 
-	/* ITF-USB DSD based DACs (3 altsets version) */
-	if (is_itf_usb_dsd_3alts_dac(chip)) {
-		if (fp->altsetting == 3)
+		/* Altsetting 2 support native DSD if the num of altsets is
+		 * three (0-2),
+		 * Altsetting 3 support native DSD if the num of altsets is
+		 * four (0-3).
+		 */
+		if (fp->altsetting == iface->num_altsetting - 1)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 	}
 

commit 74dc71f83e500b2c6bb0d01a947e1b7231456dd8
Author: Nobutaka Okabe <nob77413@gmail.com>
Date:   Fri Mar 23 19:20:00 2018 +0900

    ALSA: usb-audio: FIX native DSD support for TEAC UD-501 DAC
    
    There are two versions of TEAC UD-501, the normal version and
    the vendor updated version(UD-501V2).
    
    They have the same VID/PID, but the num of the altsetting is different,
    UD-501 has 2 altsets for stream, and UD-501V2 has 3.
    
    So, add the logic to distinguish them by the Product Name, not by the PID.
    
    Signed-off-by: Nobutaka Okabe <nob77413@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index dec86df3f47a..da73405c3115 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1153,14 +1153,23 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
  * between PCM and native DSD mode
  * (2 altsets version)
  */
-static bool is_itf_usb_dsd_2alts_dac(unsigned int id)
+static bool is_itf_usb_dsd_2alts_dac(struct snd_usb_audio *chip)
 {
-	switch (id) {
+	char *product = chip->dev->product; /* DAC product name */
+
+	switch (chip->usb_id) {
 	case USB_ID(0x154e, 0x1003): /* Denon DA-300USB */
 	case USB_ID(0x154e, 0x3005): /* Marantz HD-DAC1 */
 	case USB_ID(0x154e, 0x3006): /* Marantz SA-14S1 */
 	case USB_ID(0x1852, 0x5065): /* Luxman DA-06 */
 		return true;
+	case USB_ID(0x0644, 0x8043):
+		/* TEAC UD-501 */
+		if (product && strcmp("UD-501", product)) {
+			return true;
+		} else {
+			return false;
+		}
 	}
 	return false;
 }
@@ -1169,13 +1178,21 @@ static bool is_itf_usb_dsd_2alts_dac(unsigned int id)
  * between PCM and native DSD mode
  * (3 altsets version)
  */
-static bool is_itf_usb_dsd_3alts_dac(unsigned int id)
+static bool is_itf_usb_dsd_3alts_dac(struct snd_usb_audio *chip)
 {
-	switch (id) {
-	case USB_ID(0x0644, 0x8043): /* TEAC UD-501/UD-503/NT-503 */
+	char *product = chip->dev->product; /* DAC product name */
+
+	switch (chip->usb_id) {
 	case USB_ID(0x0644, 0x8044): /* Esoteric D-05X */
 	case USB_ID(0x0644, 0x804a): /* TEAC UD-301 */
 		return true;
+	case USB_ID(0x0644, 0x8043):
+		/* TEAC UD-501V2/UD-503/NT-503 */
+		if (product && !strcmp("UD-501", product)) {
+			return true;
+		} else {
+			return false;
+		}
 	}
 	return false;
 }
@@ -1186,7 +1203,7 @@ int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
 	struct usb_device *dev = subs->dev;
 	int err;
 
-	if (is_itf_usb_dsd_2alts_dac(subs->stream->chip->usb_id)) {
+	if (is_itf_usb_dsd_2alts_dac(subs->stream->chip)) {
 		/* First switch to alt set 0, otherwise the mode switch cmd
 		 * will not be accepted by the DAC
 		 */
@@ -1207,7 +1224,7 @@ int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
 			break;
 		}
 		mdelay(20);
-	} else if (is_itf_usb_dsd_3alts_dac(subs->stream->chip->usb_id)) {
+	} else if (is_itf_usb_dsd_3alts_dac(subs->stream->chip)) {
 		/* Vendor mode switch cmd is required. */
 		switch (fmt->altsetting) {
 		case 3: /* DSD mode (DSD_U32) requested */
@@ -1306,7 +1323,7 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	/* ITF-USB DSD based DACs functionality need a delay
 	 * after each class compliant request
 	 */
-	if (is_itf_usb_dsd_2alts_dac(chip->usb_id)
+	if (is_itf_usb_dsd_2alts_dac(chip)
 	    && (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(20);
 
@@ -1394,13 +1411,13 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	}
 
 	/* ITF-USB DSD based DACs (2 altsets version) */
-	if (is_itf_usb_dsd_2alts_dac(chip->usb_id)) {
+	if (is_itf_usb_dsd_2alts_dac(chip)) {
 		if (fp->altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 	}
 
 	/* ITF-USB DSD based DACs (3 altsets version) */
-	if (is_itf_usb_dsd_3alts_dac(chip->usb_id)) {
+	if (is_itf_usb_dsd_3alts_dac(chip)) {
 		if (fp->altsetting == 3)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 	}

commit 71426535f49fe6034d0e0db77608b91a0c1a022d
Author: Nobutaka Okabe <nob77413@gmail.com>
Date:   Fri Mar 23 19:18:22 2018 +0900

    ALSA: usb-audio: Add native DSD support for Luxman DA-06
    
    Add native DSD support quirk for Luxman DA-06 DAC, by adding the
    PID/VID 1852:5065.
    
    Rename "is_marantz_denon_dac()" function to "is_itf_usb_dsd_2alts_dac()"
    to cover broader device family sharing the same USB audio
    implementation(*).
    For the same reason, rename "is_teac_dsd_dac()" function to
    "is_itf_usb_dsd_3alts_dac()".
    
    (*)
    These devices have the same USB controller "ITF-USB DSD", supplied by
    INTERFACE Co., Ltd.
    "ITF-USB DSD" USB controller has two patterns,
    
    Pattern 1. (2 altsets version)
    - Altset 0: for control
    - Altset 1: for stream (S32)
    - Altset 2: for stream (S32, DSD_U32)
    
    Pattern 2. (3 altsets version)
    - Altset 0: for control
    - Altset 1: for stream (S16)
    - Altset 2: for stream (S32)
    - Altset 3: for stream (S32, DSD_U32)
    
    "is_itf_usb_dsd_2alts_dac()" returns true, if the DAC has "Pattern 1"
    USB controller, and "is_itf_usb_dsd_3alts_dac()" returns true, if
    "Pattern2".
    
    Signed-off-by: Nobutaka Okabe <nob77413@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 6aa0ebd4a5a2..dec86df3f47a 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1149,24 +1149,27 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	return false;
 }
 
-/* Marantz/Denon USB DACs need a vendor cmd to switch
+/* ITF-USB DSD based DACs need a vendor cmd to switch
  * between PCM and native DSD mode
+ * (2 altsets version)
  */
-static bool is_marantz_denon_dac(unsigned int id)
+static bool is_itf_usb_dsd_2alts_dac(unsigned int id)
 {
 	switch (id) {
 	case USB_ID(0x154e, 0x1003): /* Denon DA-300USB */
 	case USB_ID(0x154e, 0x3005): /* Marantz HD-DAC1 */
 	case USB_ID(0x154e, 0x3006): /* Marantz SA-14S1 */
+	case USB_ID(0x1852, 0x5065): /* Luxman DA-06 */
 		return true;
 	}
 	return false;
 }
 
-/* TEAC UD-501/UD-503/NT-503 USB DACs need a vendor cmd to switch
- * between PCM/DOP and native DSD mode
+/* ITF-USB DSD based DACs need a vendor cmd to switch
+ * between PCM and native DSD mode
+ * (3 altsets version)
  */
-static bool is_teac_dsd_dac(unsigned int id)
+static bool is_itf_usb_dsd_3alts_dac(unsigned int id)
 {
 	switch (id) {
 	case USB_ID(0x0644, 0x8043): /* TEAC UD-501/UD-503/NT-503 */
@@ -1183,7 +1186,7 @@ int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
 	struct usb_device *dev = subs->dev;
 	int err;
 
-	if (is_marantz_denon_dac(subs->stream->chip->usb_id)) {
+	if (is_itf_usb_dsd_2alts_dac(subs->stream->chip->usb_id)) {
 		/* First switch to alt set 0, otherwise the mode switch cmd
 		 * will not be accepted by the DAC
 		 */
@@ -1204,7 +1207,7 @@ int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
 			break;
 		}
 		mdelay(20);
-	} else if (is_teac_dsd_dac(subs->stream->chip->usb_id)) {
+	} else if (is_itf_usb_dsd_3alts_dac(subs->stream->chip->usb_id)) {
 		/* Vendor mode switch cmd is required. */
 		switch (fmt->altsetting) {
 		case 3: /* DSD mode (DSD_U32) requested */
@@ -1300,10 +1303,10 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(20);
 
-	/* Marantz/Denon devices with USB DAC functionality need a delay
+	/* ITF-USB DSD based DACs functionality need a delay
 	 * after each class compliant request
 	 */
-	if (is_marantz_denon_dac(chip->usb_id)
+	if (is_itf_usb_dsd_2alts_dac(chip->usb_id)
 	    && (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(20);
 
@@ -1390,14 +1393,14 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 		break;
 	}
 
-	/* Denon/Marantz devices with USB DAC functionality */
-	if (is_marantz_denon_dac(chip->usb_id)) {
+	/* ITF-USB DSD based DACs (2 altsets version) */
+	if (is_itf_usb_dsd_2alts_dac(chip->usb_id)) {
 		if (fp->altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 	}
 
-	/* TEAC devices with USB DAC functionality */
-	if (is_teac_dsd_dac(chip->usb_id)) {
+	/* ITF-USB DSD based DACs (3 altsets version) */
+	if (is_itf_usb_dsd_3alts_dac(chip->usb_id)) {
 		if (fp->altsetting == 3)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 	}

commit 3446b1e962b387b8cec53e85fdd9392da25a2737
Merge: 21e9b3e931f7 b00214865d65
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 23 22:02:24 2018 +0100

    Merge branch 'for-linus' into for-next
    
    Back-merge for applying more series of fixes for USB DSD support.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit b00214865d65100163574ba250008f182cf90869
Author: Nobutaka Okabe <nob77413@gmail.com>
Date:   Fri Mar 23 19:49:44 2018 +0900

    ALSA: usb-audio: Add native DSD support for TEAC UD-301
    
    Add native DSD support quirk for TEAC UD-301 DAC,
    by adding the PID/VID 0644:804a.
    
    Signed-off-by: Nobutaka Okabe <nob77413@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index ea8f3de92fa4..794224e1d6df 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1171,6 +1171,7 @@ static bool is_teac_dsd_dac(unsigned int id)
 	switch (id) {
 	case USB_ID(0x0644, 0x8043): /* TEAC UD-501/UD-503/NT-503 */
 	case USB_ID(0x0644, 0x8044): /* Esoteric D-05X */
+	case USB_ID(0x0644, 0x804a): /* TEAC UD-301 */
 		return true;
 	}
 	return false;

commit ceb18f511beeb8b750f027f170eb6d901a082e9a
Author: Ruslan Bilovol <ruslan.bilovol@gmail.com>
Date:   Mon Mar 19 03:46:02 2018 +0200

    ALSA: usb-audio: move audioformat quirks to quirks.c
    
    Offload USB audio interface parsing function by
    moving quirks to a specially designed location (quirks.c)
    
    Signed-off-by: Ruslan Bilovol <ruslan.bilovol@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index ea8f3de92fa4..eeea8e18aea3 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1403,3 +1403,37 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 
 	return 0;
 }
+
+void snd_usb_audioformat_attributes_quirk(struct snd_usb_audio *chip,
+					  struct audioformat *fp,
+					  int stream)
+{
+	switch (chip->usb_id) {
+	case USB_ID(0x0a92, 0x0053): /* AudioTrak Optoplay */
+		/* Optoplay sets the sample rate attribute although
+		 * it seems not supporting it in fact.
+		 */
+		fp->attributes &= ~UAC_EP_CS_ATTR_SAMPLE_RATE;
+		break;
+	case USB_ID(0x041e, 0x3020): /* Creative SB Audigy 2 NX */
+	case USB_ID(0x0763, 0x2003): /* M-Audio Audiophile USB */
+		/* doesn't set the sample rate attribute, but supports it */
+		fp->attributes |= UAC_EP_CS_ATTR_SAMPLE_RATE;
+		break;
+	case USB_ID(0x0763, 0x2001):  /* M-Audio Quattro USB */
+	case USB_ID(0x0763, 0x2012):  /* M-Audio Fast Track Pro USB */
+	case USB_ID(0x047f, 0x0ca1): /* plantronics headset */
+	case USB_ID(0x077d, 0x07af): /* Griffin iMic (note that there is
+					an older model 77d:223) */
+	/*
+	 * plantronics headset and Griffin iMic have set adaptive-in
+	 * although it's really not...
+	 */
+		fp->ep_attr &= ~USB_ENDPOINT_SYNCTYPE;
+		if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+			fp->ep_attr |= USB_ENDPOINT_SYNC_ADAPTIVE;
+		else
+			fp->ep_attr |= USB_ENDPOINT_SYNC_SYNC;
+		break;
+	}
+}

commit 7c74866baef1827e18f8269aec85030063520bd4
Author: Daniel Mack <daniel@zonque.org>
Date:   Sun Feb 11 09:50:27 2018 -0400

    ALSA: usb: add more device quirks for USB DSD devices
    
    Add some more devices that need quirks to handle DSD modes correctly.
    
    Signed-off-by: Daniel Mack <daniel@zonque.org>
    Reported-and-tested-by: Thomas Gresens <tgresens@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index a66ef5777887..ea8f3de92fa4 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1363,8 +1363,11 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
 
-	/* Amanero Combo384 USB interface with native DSD support */
-	case USB_ID(0x16d0, 0x071a):
+	/* Amanero Combo384 USB based DACs with native DSD support */
+	case USB_ID(0x16d0, 0x071a):  /* Amanero - Combo384 */
+	case USB_ID(0x2ab6, 0x0004):  /* T+A DAC8DSD-V2.0, MP1000E-V2.0, MP2000R-V2.0, MP2500R-V2.0, MP3100HV-V2.0 */
+	case USB_ID(0x2ab6, 0x0005):  /* T+A USB HD Audio 1 */
+	case USB_ID(0x2ab6, 0x0006):  /* T+A USB HD Audio 2 */
 		if (fp->altsetting == 2) {
 			switch (le16_to_cpu(chip->dev->descriptor.bcdDevice)) {
 			case 0x199:

commit 866f7ed7d67936dcdbcddc111c8af878c918fe7c
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Thu Dec 7 12:58:33 2017 +0200

    ALSA: usb-audio: Add native DSD support for Esoteric D-05X
    
    Adds VID:PID of Esoteric D-05X to the TEAC device id's.
    Renames the is_teac_50X_dac() function to is_teac_dsd_dac() to cover
    broader device family from the same corporation sharing the same USB
    audio implementation.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 77eecaa4db1f..a66ef5777887 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1166,10 +1166,11 @@ static bool is_marantz_denon_dac(unsigned int id)
 /* TEAC UD-501/UD-503/NT-503 USB DACs need a vendor cmd to switch
  * between PCM/DOP and native DSD mode
  */
-static bool is_teac_50X_dac(unsigned int id)
+static bool is_teac_dsd_dac(unsigned int id)
 {
 	switch (id) {
 	case USB_ID(0x0644, 0x8043): /* TEAC UD-501/UD-503/NT-503 */
+	case USB_ID(0x0644, 0x8044): /* Esoteric D-05X */
 		return true;
 	}
 	return false;
@@ -1202,7 +1203,7 @@ int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
 			break;
 		}
 		mdelay(20);
-	} else if (is_teac_50X_dac(subs->stream->chip->usb_id)) {
+	} else if (is_teac_dsd_dac(subs->stream->chip->usb_id)) {
 		/* Vendor mode switch cmd is required. */
 		switch (fmt->altsetting) {
 		case 3: /* DSD mode (DSD_U32) requested */
@@ -1392,7 +1393,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	}
 
 	/* TEAC devices with USB DAC functionality */
-	if (is_teac_50X_dac(chip->usb_id)) {
+	if (is_teac_dsd_dac(chip->usb_id)) {
 		if (fp->altsetting == 3)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 	}

commit c429bda21ffafb28f02fb2eb4055b4ab6879ed58
Merge: 75ee94b20b46 9718a29d40b7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 13 15:43:04 2017 +0100

    Merge branch 'for-next' into for-linus
    
    Pull 4.15 updates to take over the previous urgent fixes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit f5ce817951f38023588b2b8308beca79abe20507
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Wed Nov 1 23:32:33 2017 +0200

    ALSA: usb-audio: support new Amanero Combo384 firmware version
    
    Support DSD_U32_BE sample format on new Amanero Combo384 firmware
    version on older VID/PID.
    
    Fixes: 3eff682d765b ("ALSA: usb-audio: Support both DSD LE/BE Amanero firmware versions")
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 4f5f18f22974..20624320b753 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1375,6 +1375,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 			case 0x199:
 				return SNDRV_PCM_FMTBIT_DSD_U32_LE;
 			case 0x19b:
+			case 0x203:
 				return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 			default:
 				break;

commit 9bb201a5d5acc733943e8af7151cceab9d976a69
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Sun Oct 15 12:41:32 2017 +0300

    ALSA: usb-audio: Add native DSD support for Pro-Ject Pre Box S2 Digital
    
    Add native DSD support quirk for Pro-Ject Pre Box S2 Digital USB id
    2772:0230.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 9ddaae3784f5..4f5f18f22974 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1354,6 +1354,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	case USB_ID(0x20b1, 0x2008): /* Matrix Audio X-Sabre */
 	case USB_ID(0x20b1, 0x300a): /* Matrix Audio Mini-i Pro */
 	case USB_ID(0x22d9, 0x0416): /* OPPO HA-1 */
+	case USB_ID(0x2772, 0x0230): /* Pro-Ject Pre Box S2 Digital */
 		if (fp->altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

commit a6aa6cdcecfc0eb8a6fe634535384b4a63f38258
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 5 20:19:38 2017 +0200

    ALSA: usb-audio: Apply vendor ID matching for sample rate quirk
    
    So far, lots of Plantronics, MS and Phoenix Audio devices need the
    quirk not to read sample rate back, and the list just grows.
    In this patch, instead of adding each device, apply the quirk by
    matching with these vendors.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 9ddaae3784f5..9aeb05f61f78 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1128,30 +1128,24 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	/* devices which do not support reading the sample rate. */
 	switch (chip->usb_id) {
 	case USB_ID(0x041E, 0x4080): /* Creative Live Cam VF0610 */
-	case USB_ID(0x045E, 0x075D): /* MS Lifecam Cinema  */
-	case USB_ID(0x045E, 0x076D): /* MS Lifecam HD-5000 */
-	case USB_ID(0x045E, 0x076E): /* MS Lifecam HD-5001 */
-	case USB_ID(0x045E, 0x076F): /* MS Lifecam HD-6000 */
-	case USB_ID(0x045E, 0x0772): /* MS Lifecam Studio */
-	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */
-	case USB_ID(0x047F, 0x02F7): /* Plantronics BT-600 */
-	case USB_ID(0x047F, 0x0415): /* Plantronics BT-300 */
-	case USB_ID(0x047F, 0xAA05): /* Plantronics DA45 */
-	case USB_ID(0x047F, 0xC022): /* Plantronics C310 */
-	case USB_ID(0x047F, 0xC02F): /* Plantronics P610 */
-	case USB_ID(0x047F, 0xC036): /* Plantronics C520-M */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 	case USB_ID(0x0556, 0x0014): /* Phoenix Audio TMX320VC */
 	case USB_ID(0x05A3, 0x9420): /* ELP HD USB Camera */
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
 	case USB_ID(0x1395, 0x740a): /* Sennheiser DECT */
 	case USB_ID(0x1901, 0x0191): /* GE B850V3 CP2114 audio interface */
-	case USB_ID(0x1de7, 0x0013): /* Phoenix Audio MT202exe */
-	case USB_ID(0x1de7, 0x0014): /* Phoenix Audio TMX320 */
-	case USB_ID(0x1de7, 0x0114): /* Phoenix Audio MT202pcs */
 	case USB_ID(0x21B4, 0x0081): /* AudioQuest DragonFly */
 		return true;
 	}
+
+	/* devices of these vendors don't support reading rate, either */
+	switch (USB_ID_VENDOR(chip->usb_id)) {
+	case 0x045E: /* MS Lifecam */
+	case 0x047F: /* Plantronics */
+	case 0x1de7: /* Phoenix Audio */
+		return true;
+	}
+
 	return false;
 }
 

commit c247487c0dd6fefff6ed0cbcbe66f037721755fb
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Fri Oct 6 02:04:06 2017 +0800

    ALSA: usb-audio: Add sample rate quirk for Plantronics P610
    
    Like other Plantronics devices, P610 does not support sample
    rate reading. Apply sample rate quirk to it.
    
    BugLink: https://bugs.launchpad.net/bugs/1719853
    
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index b8cb57aeec77..9ddaae3784f5 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1138,6 +1138,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x047F, 0x0415): /* Plantronics BT-300 */
 	case USB_ID(0x047F, 0xAA05): /* Plantronics DA45 */
 	case USB_ID(0x047F, 0xC022): /* Plantronics C310 */
+	case USB_ID(0x047F, 0xC02F): /* Plantronics P610 */
 	case USB_ID(0x047F, 0xC036): /* Plantronics C520-M */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 	case USB_ID(0x0556, 0x0014): /* Phoenix Audio TMX320VC */

commit 0dcd020b7abbff238f188d4db8f02389dc849553
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Wed Sep 20 09:21:40 2017 +0800

    ALSA: usb-audio: Add sample rate quirk for Plantronics C310/C520-M
    
    Like other Plantronics devices, C310 and C520-M do not support sample
    rate reading. Add them to the sample rate quirk accordingly.
    
    BugLink: https://bugs.launchpad.net/bugs/1708499
    BugLink: https://bugs.launchpad.net/bugs/1709282
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 913552078285..b8cb57aeec77 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1137,6 +1137,8 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x047F, 0x02F7): /* Plantronics BT-600 */
 	case USB_ID(0x047F, 0x0415): /* Plantronics BT-300 */
 	case USB_ID(0x047F, 0xAA05): /* Plantronics DA45 */
+	case USB_ID(0x047F, 0xC022): /* Plantronics C310 */
+	case USB_ID(0x047F, 0xC036): /* Plantronics C520-M */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 	case USB_ID(0x0556, 0x0014): /* Phoenix Audio TMX320VC */
 	case USB_ID(0x05A3, 0x9420): /* ELP HD USB Camera */

commit 241bc82e62b28fdb7223b85180fd814f4963c971
Merge: 3a93d082bacf 88c54cdf61f5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 22 15:44:45 2017 +0200

    Merge branch 'for-linus' into for-next
    
    Conflicts:
            sound/core/control.c

commit 07b3b5e9ed807a0d2077319b8e43a42e941db818
Author: Joakim Tjernlund <joakim.tjernlund@infinera.com>
Date:   Tue Aug 22 08:33:53 2017 +0200

    ALSA: usb-audio: Add delay quirk for H650e/Jabra 550a USB headsets
    
    These headsets reports a lot of: cannot set freq 44100 to ep 0x81
    and need a small delay between sample rate settings, just like
    Zoom R16/24. Add both headsets to the Zoom R16/24 quirk for
    a 1 ms delay between control msgs.
    
    Signed-off-by: Joakim Tjernlund <joakim.tjernlund@infinera.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 6a03f9697039..5d2a63248b1d 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1309,10 +1309,13 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	    && (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(20);
 
-	/* Zoom R16/24 needs a tiny delay here, otherwise requests like
-	 * get/set frequency return as failed despite actually succeeding.
+	/* Zoom R16/24, Logitech H650e, Jabra 550a needs a tiny delay here,
+	 * otherwise requests like get/set frequency return as failed despite
+	 * actually succeeding.
 	 */
-	if (chip->usb_id == USB_ID(0x1686, 0x00dd) &&
+	if ((chip->usb_id == USB_ID(0x1686, 0x00dd) ||
+	     chip->usb_id == USB_ID(0x046d, 0x0a46) ||
+	     chip->usb_id == USB_ID(0x0b0e, 0x0349)) &&
 	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(1);
 }

commit ed993c6fdfa7734881a4516852d95ae2d3b604d3
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Fri Aug 18 10:42:14 2017 +0300

    ALSA: usb-audio: add DSD support for new Amanero PID
    
    Add DSD support for new Amanero Combo384 firmware version with a new
    PID. This firmware uses DSD_U32_BE.
    
    Fixes: 3eff682d765b ("ALSA: usb-audio: Support both DSD LE/BE Amanero firmware versions")
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index f3e9e30172f3..6a03f9697039 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1375,6 +1375,10 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 			}
 		}
 		break;
+	case USB_ID(0x16d0, 0x0a23):
+		if (fp->altsetting == 2)
+			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
+		break;
 
 	default:
 		break;

commit a8e800fe0f68bc28ce309914f47e432742b865ed
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Aug 14 14:35:50 2017 +0200

    ALSA: usb-audio: Apply sample rate quirk to Sennheiser headset
    
    A Senheisser headset requires the typical sample-rate quirk for
    avoiding spurious errors from inquiring the current sample rate like:
     usb 1-1: 2:1: cannot get freq at ep 0x4
     usb 1-1: 3:1: cannot get freq at ep 0x83
    
    The USB ID 1395:740a has to be added to the entries in
    snd_usb_get_sample_rate_quirk().
    
    Bugzilla: https://bugzilla.suse.com/show_bug.cgi?id=1052580
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index d7b0b0a3a2db..f3e9e30172f3 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1142,6 +1142,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x0556, 0x0014): /* Phoenix Audio TMX320VC */
 	case USB_ID(0x05A3, 0x9420): /* ELP HD USB Camera */
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
+	case USB_ID(0x1395, 0x740a): /* Sennheiser DECT */
 	case USB_ID(0x1901, 0x0191): /* GE B850V3 CP2114 audio interface */
 	case USB_ID(0x1de7, 0x0013): /* Phoenix Audio MT202exe */
 	case USB_ID(0x1de7, 0x0014): /* Phoenix Audio TMX320 */

commit 9ecb2406de33470b70b48a2e107730bd37547e31
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Fri Aug 11 18:38:25 2017 +0200

    ALSA: usb: Delete an error message for a failed memory allocation in two functions
    
    Omit an extra message for a memory allocation failure in these functions.
    
    This issue was detected by using the Coccinelle software.
    
    Link: http://events.linuxfoundation.org/sites/events/files/slides/LCJ16-Refactor_Strings-WSang_0.pdf
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index d7b0b0a3a2db..9db40d58b4e2 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -146,10 +146,9 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 	unsigned *rate_table = NULL;
 
 	fp = kmemdup(quirk->data, sizeof(*fp), GFP_KERNEL);
-	if (!fp) {
-		usb_audio_err(chip, "cannot memdup\n");
+	if (!fp)
 		return -ENOMEM;
-	}
+
 	INIT_LIST_HEAD(&fp->list);
 	if (fp->nr_rates > MAX_NR_RATES) {
 		kfree(fp);

commit f83914fdfcc3ecb62a5a83eeb609ff59a9c2052d
Author: Johan Hovold <johan@kernel.org>
Date:   Fri May 12 14:34:37 2017 +0200

    ALSA: usb-audio: fix Amanero Combo384 quirk on big-endian hosts
    
    Add missing endianness conversion when using the USB device-descriptor
    bcdDevice field when applying the Amanero Combo384 (endianness!) quirk.
    
    Fixes: 3eff682d765b ("ALSA: usb-audio: Support both DSD LE/BE Amanero firmware versions")
    Cc: Jussi Laako <jussi@sonarnerd.net>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 01eff6ce6401..d7b0b0a3a2db 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1364,7 +1364,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	/* Amanero Combo384 USB interface with native DSD support */
 	case USB_ID(0x16d0, 0x071a):
 		if (fp->altsetting == 2) {
-			switch (chip->dev->descriptor.bcdDevice) {
+			switch (le16_to_cpu(chip->dev->descriptor.bcdDevice)) {
 			case 0x199:
 				return SNDRV_PCM_FMTBIT_DSD_U32_LE;
 			case 0x19b:

commit e1a063f43a5e0435ecf8a2b6d42e10e20e8caf61
Merge: 9eb5d0e635eb 0369d6315bc2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 25 22:11:17 2017 +0100

    Merge branch 'topic/intel-lpe-audio' into for-next

commit 2e40795c3bf344cfb5220d94566205796e3ef19a
Author: Dennis Kadioglu <denk@post.com>
Date:   Mon Jan 9 17:10:46 2017 +0100

    ALSA: usb-audio: Add a quirk for Plantronics BT600
    
    Plantronics BT600 does not support reading the sample rate which leads
    to many lines of "cannot get freq at ep 0x1" and "cannot get freq at
    ep 0x82". This patch adds the USB ID of the BT600 to quirks.c and
    avoids those error messages.
    
    Signed-off-by: Dennis Kadioglu <denk@post.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index b3fd2382fdd9..eb4b9f7a571e 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1135,6 +1135,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x045E, 0x076F): /* MS Lifecam HD-6000 */
 	case USB_ID(0x045E, 0x0772): /* MS Lifecam Studio */
 	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */
+	case USB_ID(0x047F, 0x02F7): /* Plantronics BT-600 */
 	case USB_ID(0x047F, 0x0415): /* Plantronics BT-300 */
 	case USB_ID(0x047F, 0xAA05): /* Plantronics DA45 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */

commit 3eff682d765b496ce2f9727bb1e001ec77b21453
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Sat Dec 17 23:51:41 2016 +0200

    ALSA: usb-audio: Support both DSD LE/BE Amanero firmware versions
    
    Add DSD support for both little endian (DSD_U32_LE) and big endian
    (DSD_U32_BE) version of the Amanero firmware.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index b3fd2382fdd9..f5c68ea0468e 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1359,6 +1359,21 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 		if (fp->altsetting == 3)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
+
+	/* Amanero Combo384 USB interface with native DSD support */
+	case USB_ID(0x16d0, 0x071a):
+		if (fp->altsetting == 2) {
+			switch (chip->dev->descriptor.bcdDevice) {
+			case 0x199:
+				return SNDRV_PCM_FMTBIT_DSD_U32_LE;
+			case 0x19b:
+				return SNDRV_PCM_FMTBIT_DSD_U32_BE;
+			default:
+				break;
+			}
+		}
+		break;
+
 	default:
 		break;
 	}

commit 7f38ca047b0cb54df7f6d9e4110e292e45dba6ad
Author: Nobutaka Okabe <nob77413@gmail.com>
Date:   Tue Dec 13 01:24:08 2016 +0900

    ALSA: usb-audio: Add native DSD support for TEAC 501/503 DAC
    
    This patch adds native DSD support for the following devices.
    
    - TEAC NT-503
    - TEAC UD-503
    - TEAC UD-501
    
    (1) Add quirks for native DSD support for TEAC devices.
    (2) A specific vendor command is needed to switch between PCM/DOP and
        DSD mode, same as Denon/Marantz devices.
    
    Signed-off-by: Nobutaka Okabe <nob77413@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 2782155ae3ce..b3fd2382fdd9 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1165,6 +1165,18 @@ static bool is_marantz_denon_dac(unsigned int id)
 	return false;
 }
 
+/* TEAC UD-501/UD-503/NT-503 USB DACs need a vendor cmd to switch
+ * between PCM/DOP and native DSD mode
+ */
+static bool is_teac_50X_dac(unsigned int id)
+{
+	switch (id) {
+	case USB_ID(0x0644, 0x8043): /* TEAC UD-501/UD-503/NT-503 */
+		return true;
+	}
+	return false;
+}
+
 int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
 			      struct audioformat *fmt)
 {
@@ -1192,6 +1204,26 @@ int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
 			break;
 		}
 		mdelay(20);
+	} else if (is_teac_50X_dac(subs->stream->chip->usb_id)) {
+		/* Vendor mode switch cmd is required. */
+		switch (fmt->altsetting) {
+		case 3: /* DSD mode (DSD_U32) requested */
+			err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), 0,
+					      USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,
+					      1, 1, NULL, 0);
+			if (err < 0)
+				return err;
+			break;
+
+		case 2: /* PCM or DOP mode (S32) requested */
+		case 1: /* PCM mode (S16) requested */
+			err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), 0,
+					      USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,
+					      0, 1, NULL, 0);
+			if (err < 0)
+				return err;
+			break;
+		}
 	}
 	return 0;
 }
@@ -1337,5 +1369,11 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 	}
 
+	/* TEAC devices with USB DAC functionality */
+	if (is_teac_50X_dac(chip->usb_id)) {
+		if (fp->altsetting == 3)
+			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
+	}
+
 	return 0;
 }

commit 3d2f4d0c0d4f3b676ecca504a3916b8e9843a181
Merge: 09da111aef57 3f640970a414
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Sep 11 09:33:12 2016 +0200

    Merge branch 'for-linus' into for-next
    
    Back-merge from for-linus just to make the further development easier.

commit 83d9956b7e6b310c1062df7894257251c625b22e
Author: Ken Lin <ken.lin@advantech.com.tw>
Date:   Fri Aug 12 14:08:47 2016 -0400

    ALSA: usb-audio: Add sample rate inquiry quirk for B850V3 CP2114
    
    Avoid getting sample rate on B850V3 CP2114 as it is unsupported and
    causes noisy "current rate is different from the runtime rate" messages
    when playback starts.
    
    Signed-off-by: Ken Lin <ken.lin@advantech.com.tw>
    Signed-off-by: Akshay Bhat <akshay.bhat@timesys.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 6cf1f3597455..152292e5ee2b 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1141,6 +1141,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x0556, 0x0014): /* Phoenix Audio TMX320VC */
 	case USB_ID(0x05A3, 0x9420): /* ELP HD USB Camera */
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
+	case USB_ID(0x1901, 0x0191): /* GE B850V3 CP2114 audio interface */
 	case USB_ID(0x1de7, 0x0013): /* Phoenix Audio MT202exe */
 	case USB_ID(0x1de7, 0x0014): /* Phoenix Audio TMX320 */
 	case USB_ID(0x1de7, 0x0114): /* Phoenix Audio MT202pcs */

commit ca0dd2736a05d1df94c8657b4865f9d6c6637085
Author: Daniel Mack <daniel@zonque.org>
Date:   Mon Aug 22 08:53:37 2016 +0200

    ALSA: usb: use TEAC UD-H01 quirk for more devices
    
    The quirk seems to be necessary not only for TEAC UD-H01 devices, but to
    more that are based on the Tenor 8802TL chipset. Devices built by T+A
    are affected too, and they apparently all use the same USB PID:PID.
    
    Extend the quirky handling for that device as well, and rename the
    quirks flag.
    
    Reported-and-tested-by: Thomas Gresens <T.Gresens@intershop.de>
    Signed-off-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 299813f30630..d47d9275874c 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1218,9 +1218,10 @@ void snd_usb_endpoint_start_quirk(struct snd_usb_endpoint *ep)
 		ep->skip_packets = 16;
 
 	/* Work around devices that report unreasonable feedback data */
-	if (ep->chip->usb_id == USB_ID(0x0644, 0x8038) /* TEAC UD-H01 */ &&
+	if ((ep->chip->usb_id == USB_ID(0x0644, 0x8038) ||  /* TEAC UD-H01 */
+	     ep->chip->usb_id == USB_ID(0x1852, 0x5034)) && /* T+A Dac8 */
 	    ep->syncmaxsize == 4)
-		ep->udh01_fb_quirk = 1;
+		ep->tenor_fb_quirk = 1;
 }
 
 void snd_usb_set_interface_quirk(struct usb_device *dev)

commit 9abc134167249ded16a8c776813121609610f119
Author: Daniel Mack <daniel@zonque.org>
Date:   Mon Aug 22 08:53:36 2016 +0200

    ALSA: usb: move udh01_fb_quirk setting to quirks.c
    
    That's a quirk, after all, so move it where to all the other quirks
    live.
    
    Signed-off-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 6cf1f3597455..299813f30630 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1216,6 +1216,11 @@ void snd_usb_endpoint_start_quirk(struct snd_usb_endpoint *ep)
 	     ep->chip->usb_id == USB_ID(0x0763, 0x2031)) &&
 	    ep->type == SND_USB_ENDPOINT_TYPE_DATA)
 		ep->skip_packets = 16;
+
+	/* Work around devices that report unreasonable feedback data */
+	if (ep->chip->usb_id == USB_ID(0x0644, 0x8038) /* TEAC UD-H01 */ &&
+	    ep->syncmaxsize == 4)
+		ep->udh01_fb_quirk = 1;
 }
 
 void snd_usb_set_interface_quirk(struct usb_device *dev)

commit 41f5e3bdbf706a9e98194bf0c4b62a875c02f170
Author: Vittorio Gambaletta (VittGam) <linuxbugs@vittgam.net>
Date:   Mon Aug 8 12:35:40 2016 +0200

    ALSA: usb-audio: Add quirk for ELP HD USB Camera
    
    The ELP HD USB Camera (05a3:9420) needs this quirk for suppressing
    the unsupported sample rate inquiry.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=98481
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Vittorio Gambaletta <linuxbugs@vittgam.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index b70d4dc4ef10..6cf1f3597455 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1139,6 +1139,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x047F, 0xAA05): /* Plantronics DA45 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 	case USB_ID(0x0556, 0x0014): /* Phoenix Audio TMX320VC */
+	case USB_ID(0x05A3, 0x9420): /* ELP HD USB Camera */
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
 	case USB_ID(0x1de7, 0x0013): /* Phoenix Audio MT202exe */
 	case USB_ID(0x1de7, 0x0014): /* Phoenix Audio TMX320 */

commit 7627e40c66b5547e12b6c5673646ceea84797a74
Author: Piotr Karasinski <peter.karasinski@gmail.com>
Date:   Sat Aug 6 21:23:05 2016 +0200

    ALSA: usb-audio: Add a sample rate quirk for Creative Live! Cam Socialize HD (VF0610)
    
    VF0610 does not support reading the sample rate which leads to many
    lines of "cannot get freq at ep 0x82". This patch adds the USB ID
    (0x041E:4080) to snd_usb_get_sample_rate_quirk() list.
    
    Signed-off-by: Piotr Karasinski <peter.karasinski@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 6adde457b602..b70d4dc4ef10 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1128,6 +1128,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 {
 	/* devices which do not support reading the sample rate. */
 	switch (chip->usb_id) {
+	case USB_ID(0x041E, 0x4080): /* Creative Live Cam VF0610 */
 	case USB_ID(0x045E, 0x075D): /* MS Lifecam Cinema  */
 	case USB_ID(0x045E, 0x076D): /* MS Lifecam HD-5000 */
 	case USB_ID(0x045E, 0x076E): /* MS Lifecam HD-5001 */

commit 84add303ef950b8d85f54bc2248c2bc73467c329
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 11 17:48:00 2016 +0200

    ALSA: usb-audio: Yet another Phoneix Audio device quirk
    
    Phoenix Audio has yet another device with another id (even a different
    vendor id, 0556:0014) that requires the same quirk for the sample
    rate.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=110221
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 7b6dca2d7488..6adde457b602 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1137,6 +1137,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x047F, 0x0415): /* Plantronics BT-300 */
 	case USB_ID(0x047F, 0xAA05): /* Plantronics DA45 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
+	case USB_ID(0x0556, 0x0014): /* Phoenix Audio TMX320VC */
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
 	case USB_ID(0x1de7, 0x0013): /* Phoenix Audio MT202exe */
 	case USB_ID(0x1de7, 0x0014): /* Phoenix Audio TMX320 */

commit 2d2c038a9999f423e820d89db2b5d7774b67ba49
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 29 11:20:15 2016 +0200

    ALSA: usb-audio: Quirk for yet another Phoenix Audio devices (v2)
    
    Phoenix Audio MT202pcs (1de7:0114) and MT202exe (1de7:0013) need the
    same workaround as TMX320 for avoiding the firmware bug.  It fixes the
    frequent error about the sample rate inquiries and the slow device
    probe as consequence.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=117321
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 0adfd9537cf7..7b6dca2d7488 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1138,7 +1138,9 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x047F, 0xAA05): /* Plantronics DA45 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
+	case USB_ID(0x1de7, 0x0013): /* Phoenix Audio MT202exe */
 	case USB_ID(0x1de7, 0x0014): /* Phoenix Audio TMX320 */
+	case USB_ID(0x1de7, 0x0114): /* Phoenix Audio MT202pcs */
 	case USB_ID(0x21B4, 0x0081): /* AudioQuest DragonFly */
 		return true;
 	}

commit b4203ff5464da00b7812e7b480192745b0d66bbf
Author: Dennis Kadioglu <denk@post.com>
Date:   Wed Apr 6 08:39:01 2016 +0200

    ALSA: usb-audio: Add a quirk for Plantronics BT300
    
    Plantronics BT300 does not support reading the sample rate which leads
    to many lines of "cannot get freq at ep 0x1". This patch adds the USB
    ID of the BT300 to quirks.c and avoids those error messages.
    
    Signed-off-by: Dennis Kadioglu <denk@post.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 24c7c2311b47..0adfd9537cf7 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1134,6 +1134,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x045E, 0x076F): /* MS Lifecam HD-6000 */
 	case USB_ID(0x045E, 0x0772): /* MS Lifecam Studio */
 	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */
+	case USB_ID(0x047F, 0x0415): /* Plantronics BT-300 */
 	case USB_ID(0x047F, 0xAA05): /* Plantronics DA45 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */

commit f03b24a851d32ca85dacab01785b24a7ee717d37
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 4 11:47:50 2016 +0200

    ALSA: usb-audio: Add a sample rate quirk for Phoenix Audio TMX320
    
    Phoenix Audio TMX320 gives the similar error when the sample rate is
    asked:
      usb 2-1.3: 2:1: cannot get freq at ep 0x85
      usb 2-1.3: 1:1: cannot get freq at ep 0x2
      ....
    
    Add the corresponding USB-device ID (1de7:0014) to
    snd_usb_get_sample_rate_quirk() list.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=110221
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 6178bb5d0731..24c7c2311b47 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1137,6 +1137,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x047F, 0xAA05): /* Plantronics DA45 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
+	case USB_ID(0x1de7, 0x0014): /* Phoenix Audio TMX320 */
 	case USB_ID(0x21B4, 0x0081): /* AudioQuest DragonFly */
 		return true;
 	}

commit 836b34a935abc91e13e63053d0a83b24dfb5ea78
Author: Vladis Dronov <vdronov@redhat.com>
Date:   Thu Mar 31 12:05:43 2016 -0400

    ALSA: usb-audio: Fix double-free in error paths after snd_usb_add_audio_stream() call
    
    create_fixed_stream_quirk(), snd_usb_parse_audio_interface() and
    create_uaxx_quirk() functions allocate the audioformat object by themselves
    and free it upon error before returning. However, once the object is linked
    to a stream, it's freed again in snd_usb_audio_pcm_free(), thus it'll be
    double-freed, eventually resulting in a memory corruption.
    
    This patch fixes these failures in the error paths by unlinking the audioformat
    object before freeing it.
    
    Based on a patch by Takashi Iwai <tiwai@suse.de>
    
    [Note for stable backports:
     this patch requires the commit 902eb7fd1e4a ('ALSA: usb-audio: Minor
     code cleanup in create_fixed_stream_quirk()')]
    
    Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1283358
    Reported-by: Ralf Spenneberg <ralf@spenneberg.net>
    Cc: <stable@vger.kernel.org> # see the note above
    Signed-off-by: Vladis Dronov <vdronov@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index fb62bce2435c..6178bb5d0731 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -150,6 +150,7 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 		usb_audio_err(chip, "cannot memdup\n");
 		return -ENOMEM;
 	}
+	INIT_LIST_HEAD(&fp->list);
 	if (fp->nr_rates > MAX_NR_RATES) {
 		kfree(fp);
 		return -EINVAL;
@@ -193,6 +194,7 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 	return 0;
 
  error:
+	list_del(&fp->list); /* unlink for avoiding double-free */
 	kfree(fp);
 	kfree(rate_table);
 	return err;
@@ -469,6 +471,7 @@ static int create_uaxx_quirk(struct snd_usb_audio *chip,
 	fp->ep_attr = get_endpoint(alts, 0)->bmAttributes;
 	fp->datainterval = 0;
 	fp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);
+	INIT_LIST_HEAD(&fp->list);
 
 	switch (fp->maxpacksize) {
 	case 0x120:
@@ -492,6 +495,7 @@ static int create_uaxx_quirk(struct snd_usb_audio *chip,
 		? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
 	err = snd_usb_add_audio_stream(chip, stream, fp);
 	if (err < 0) {
+		list_del(&fp->list); /* unlink for avoiding double-free */
 		kfree(fp);
 		return err;
 	}

commit 0ef21100ae912f76ed89f76ecd894f4ffb3689c1
Author: Victor Clment <victor.clement@openmailbox.org>
Date:   Sat Mar 19 13:17:42 2016 +0100

    ALSA: usb-audio: add Microsoft HD-5001 to quirks
    
    The Microsoft HD-5001 webcam microphone does not support sample rate
    reading as the HD-5000 one.
    This results in dmesg errors and sound hanging with pulseaudio.
    
    Signed-off-by: Victor Clment <victor.clement@openmailbox.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index a889d433cbdf..fb62bce2435c 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1126,6 +1126,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	switch (chip->usb_id) {
 	case USB_ID(0x045E, 0x075D): /* MS Lifecam Cinema  */
 	case USB_ID(0x045E, 0x076D): /* MS Lifecam HD-5000 */
+	case USB_ID(0x045E, 0x076E): /* MS Lifecam HD-5001 */
 	case USB_ID(0x045E, 0x076F): /* MS Lifecam HD-6000 */
 	case USB_ID(0x045E, 0x0772): /* MS Lifecam Studio */
 	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */

commit 902eb7fd1e4af3ac69b9b30f8373f118c92b9729
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 15 12:14:49 2016 +0100

    ALSA: usb-audio: Minor code cleanup in create_fixed_stream_quirk()
    
    Just a minor code cleanup: unify the error paths.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 529c35cceaa6..a889d433cbdf 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -167,23 +167,18 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 	stream = (fp->endpoint & USB_DIR_IN)
 		? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
 	err = snd_usb_add_audio_stream(chip, stream, fp);
-	if (err < 0) {
-		kfree(fp);
-		kfree(rate_table);
-		return err;
-	}
+	if (err < 0)
+		goto error;
 	if (fp->iface != get_iface_desc(&iface->altsetting[0])->bInterfaceNumber ||
 	    fp->altset_idx >= iface->num_altsetting) {
-		kfree(fp);
-		kfree(rate_table);
-		return -EINVAL;
+		err = -EINVAL;
+		goto error;
 	}
 	alts = &iface->altsetting[fp->altset_idx];
 	altsd = get_iface_desc(alts);
 	if (altsd->bNumEndpoints < 1) {
-		kfree(fp);
-		kfree(rate_table);
-		return -EINVAL;
+		err = -EINVAL;
+		goto error;
 	}
 
 	fp->protocol = altsd->bInterfaceProtocol;
@@ -196,6 +191,11 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 	snd_usb_init_pitch(chip, fp->iface, alts, fp);
 	snd_usb_init_sample_rate(chip, fp->iface, alts, fp, fp->rate_max);
 	return 0;
+
+ error:
+	kfree(fp);
+	kfree(rate_table);
+	return err;
 }
 
 static int create_auto_pcm_quirk(struct snd_usb_audio *chip,

commit 0f886ca12765d20124bd06291c82951fd49a33be
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 15 12:09:10 2016 +0100

    ALSA: usb-audio: Fix NULL dereference in create_fixed_stream_quirk()
    
    create_fixed_stream_quirk() may cause a NULL-pointer dereference by
    accessing the non-existing endpoint when a USB device with a malformed
    USB descriptor is used.
    
    This patch avoids it simply by adding a sanity check of bNumEndpoints
    before the accesses.
    
    Bugzilla: https://bugzilla.suse.com/show_bug.cgi?id=971125
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 5b03296a5bd9..529c35cceaa6 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -180,6 +180,12 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 	}
 	alts = &iface->altsetting[fp->altset_idx];
 	altsd = get_iface_desc(alts);
+	if (altsd->bNumEndpoints < 1) {
+		kfree(fp);
+		kfree(rate_table);
+		return -EINVAL;
+	}
+
 	fp->protocol = altsd->bInterfaceProtocol;
 
 	if (fp->datainterval == 0)

commit 6defb60ae4ffe92c29291ed49695daa255b8f559
Merge: 03367bf7fd30 790b415c98de
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 4 08:41:41 2016 +0100

    Merge branch 'for-linus' into for-next
    
    Resolved the conflicts with the latest HDA HDMI fixes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 17e2df4613be57d0fab68df749f6b8114e453152
Author: Dennis Kadioglu <denk@post.com>
Date:   Tue Mar 1 14:23:29 2016 +0100

    ALSA: usb-audio: Add a quirk for Plantronics DA45
    
    Plantronics DA45 does not support reading the sample rate which leads
    to many lines of "cannot get freq at ep 0x4" and "cannot get freq at
    ep 0x84". This patch adds the USB ID of the DA45 to quirks.c and
    avoids those error messages.
    
    Signed-off-by: Dennis Kadioglu <denk@post.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 4f6ce1cac8e2..c458d60d5030 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1124,6 +1124,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x045E, 0x076F): /* MS Lifecam HD-6000 */
 	case USB_ID(0x045E, 0x0772): /* MS Lifecam Studio */
 	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */
+	case USB_ID(0x047F, 0xAA05): /* Plantronics DA45 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
 	case USB_ID(0x21B4, 0x0081): /* AudioQuest DragonFly */

commit c9e9daccc7a6a670a6619723138ace6752f4773b
Merge: 1f5e35636cc2 ddce57a6f0a2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 8 08:16:55 2016 +0100

    Merge branch 'topic/core-fixes' into for-next

commit 1b3c993a699bed282e47c3f7c49d539c331dae04
Author: Lev Lybin <lev.lybin@gmail.com>
Date:   Fri Jan 29 22:55:11 2016 +0700

    ALSA: usb-audio: Add quirk for Microsoft LifeCam HD-6000
    
    Microsoft LifeCam HD-6000 (045e:076f) requires the similar quirk for
    avoiding the stall due to the invalid sample rate reads.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=111491
    Signed-off-by: Lev Lybin <lev.lybin@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 75f0e26514e7..4f6ce1cac8e2 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1121,6 +1121,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	switch (chip->usb_id) {
 	case USB_ID(0x045E, 0x075D): /* MS Lifecam Cinema  */
 	case USB_ID(0x045E, 0x076D): /* MS Lifecam HD-5000 */
+	case USB_ID(0x045E, 0x076F): /* MS Lifecam HD-6000 */
 	case USB_ID(0x045E, 0x0772): /* MS Lifecam Studio */
 	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */

commit ad678b4ccd41aa51cf5f142c0e8cffe9d61fc2bf
Author: Jurgen Kramer <gtmkramer@xs4all.nl>
Date:   Fri Jan 29 14:59:25 2016 +0100

    ALSA: usb-audio: Add native DSD support for PS Audio NuWave DAC
    
    This patch adds native DSD support for the PS Audio NuWave DAC.
    
    Signed-off-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 62e677dd8654..75f0e26514e7 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1290,6 +1290,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	case USB_ID(0x20b1, 0x2009): /* DIYINHK DSD DXD 384kHz USB to I2S/DSD */
 	case USB_ID(0x20b1, 0x2023): /* JLsounds I2SoverUSB */
 	case USB_ID(0x20b1, 0x3023): /* Aune X1S 32BIT/384 DSD DAC */
+	case USB_ID(0x2616, 0x0106): /* PS Audio NuWave DAC */
 		if (fp->altsetting == 3)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

commit 5327d6ba975042fd3da50ac6e94d1e9551ebeaec
Author: Jurgen Kramer <gtmkramer@xs4all.nl>
Date:   Fri Jan 29 14:49:55 2016 +0100

    ALSA: usb-audio: Fix OPPO HA-1 vendor ID
    
    In my patch adding native DSD support for the Oppo HA-1, the wrong vendor ID got
    through. This patch fixes the vendor ID and aligns the comment.
    
    Fixes: a4eae3a506ea ('ALSA: usb: Add native DSD support for Oppo HA-1')
    Signed-off-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index a75d9ce7d77a..62e677dd8654 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1281,7 +1281,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	case USB_ID(0x20b1, 0x3008): /* iFi Audio micro/nano iDSD */
 	case USB_ID(0x20b1, 0x2008): /* Matrix Audio X-Sabre */
 	case USB_ID(0x20b1, 0x300a): /* Matrix Audio Mini-i Pro */
-	case USB_ID(0x22d8, 0x0416): /* OPPO HA-1*/
+	case USB_ID(0x22d9, 0x0416): /* OPPO HA-1 */
 		if (fp->altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

commit 79289e24194a9d099bf18f200894832c5760cd83
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 11 11:33:34 2016 +0100

    ALSA: usb-audio: Refer to chip->usb_id for quirks and MIDI creation
    
    This is a preliminary patch for the later change to allow a better
    quirk ID management.  In the current USB-audio code, there are a few
    places looking at usb_device idVendor and idProduct fields directly
    even though we have already a static member in snd_usb_audio.usb_id.
    This patch modifies such codes to refer to the latter field.
    
    For achieving this, two slightly intensive changes have been done:
    - The snd_usb_audio object is set/reset via dev_getdrv() for the given
      USB device; it's needed for minimizing the changes for some existing
      quirks that take only usb_device object.
    
    - __snd_usbmidi_create() is introduced to receive the pre-given usb_id
      argument.  The exported snd_usbmidi_create() is unchanged by calling
      this new function internally.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index a75d9ce7d77a..16364d94f17b 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -446,8 +446,9 @@ static int create_uaxx_quirk(struct snd_usb_audio *chip,
 		const struct snd_usb_audio_quirk *quirk =
 			chip->usb_id == USB_ID(0x0582, 0x002b)
 			? &ua700_quirk : &uaxx_quirk;
-		return snd_usbmidi_create(chip->card, iface,
-					  &chip->midi_list, quirk);
+		return __snd_usbmidi_create(chip->card, iface,
+					  &chip->midi_list, quirk,
+					  chip->usb_id);
 	}
 
 	if (altsd->bNumEndpoints != 1)
@@ -974,11 +975,9 @@ int snd_usb_apply_interface_quirk(struct snd_usb_audio *chip,
 
 int snd_usb_apply_boot_quirk(struct usb_device *dev,
 			     struct usb_interface *intf,
-			     const struct snd_usb_audio_quirk *quirk)
+			     const struct snd_usb_audio_quirk *quirk,
+			     unsigned int id)
 {
-	u32 id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),
-			le16_to_cpu(dev->descriptor.idProduct));
-
 	switch (id) {
 	case USB_ID(0x041e, 0x3000):
 		/* SB Extigy needs special boot-up sequence */
@@ -1182,7 +1181,7 @@ void snd_usb_endpoint_start_quirk(struct snd_usb_endpoint *ep)
 	 * "Playback Design" products send bogus feedback data at the start
 	 * of the stream. Ignore them.
 	 */
-	if ((le16_to_cpu(ep->chip->dev->descriptor.idVendor) == 0x23ba) &&
+	if (USB_ID_VENDOR(ep->chip->usb_id) == 0x23ba &&
 	    ep->type == SND_USB_ENDPOINT_TYPE_SYNC)
 		ep->skip_packets = 4;
 
@@ -1201,11 +1200,15 @@ void snd_usb_endpoint_start_quirk(struct snd_usb_endpoint *ep)
 
 void snd_usb_set_interface_quirk(struct usb_device *dev)
 {
+	struct snd_usb_audio *chip = dev_get_drvdata(&dev->dev);
+
+	if (!chip)
+		return;
 	/*
 	 * "Playback Design" products need a 50ms delay after setting the
 	 * USB interface.
 	 */
-	switch (le16_to_cpu(dev->descriptor.idVendor)) {
+	switch (USB_ID_VENDOR(chip->usb_id)) {
 	case 0x23ba: /* Playback Design */
 	case 0x0644: /* TEAC Corp. */
 		mdelay(50);
@@ -1213,15 +1216,20 @@ void snd_usb_set_interface_quirk(struct usb_device *dev)
 	}
 }
 
+/* quirk applied after snd_usb_ctl_msg(); not applied during boot quirks */
 void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 			   __u8 request, __u8 requesttype, __u16 value,
 			   __u16 index, void *data, __u16 size)
 {
+	struct snd_usb_audio *chip = dev_get_drvdata(&dev->dev);
+
+	if (!chip)
+		return;
 	/*
 	 * "Playback Design" products need a 20ms delay after each
 	 * class compliant request
 	 */
-	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x23ba) &&
+	if (USB_ID_VENDOR(chip->usb_id) == 0x23ba &&
 	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(20);
 
@@ -1229,23 +1237,21 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	 * "TEAC Corp." products need a 20ms delay after each
 	 * class compliant request
 	 */
-	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x0644) &&
+	if (USB_ID_VENDOR(chip->usb_id) == 0x0644 &&
 	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(20);
 
 	/* Marantz/Denon devices with USB DAC functionality need a delay
 	 * after each class compliant request
 	 */
-	if (is_marantz_denon_dac(USB_ID(le16_to_cpu(dev->descriptor.idVendor),
-					le16_to_cpu(dev->descriptor.idProduct)))
+	if (is_marantz_denon_dac(chip->usb_id)
 	    && (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(20);
 
 	/* Zoom R16/24 needs a tiny delay here, otherwise requests like
 	 * get/set frequency return as failed despite actually succeeding.
 	 */
-	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x1686) &&
-	    (le16_to_cpu(dev->descriptor.idProduct) == 0x00dd) &&
+	if (chip->usb_id == USB_ID(0x1686, 0x00dd) &&
 	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(1);
 }
@@ -1262,7 +1268,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 					unsigned int sample_bytes)
 {
 	/* Playback Designs */
-	if (le16_to_cpu(chip->dev->descriptor.idVendor) == 0x23ba) {
+	if (USB_ID_VENDOR(chip->usb_id) == 0x23ba) {
 		switch (fp->altsetting) {
 		case 1:
 			fp->dsd_dop = true;

commit 5a4ff9ec8d6edd2ab1cfe8ce6a080d6e57cbea9a
Author: Guillaume Fougnies <guillaume@eulerian.com>
Date:   Tue Jan 26 00:28:27 2016 +0100

    ALSA: usb-audio: Fix TEAC UD-501/UD-503/NT-503 usb delay
    
    TEAC UD-501/UD-503/NT-503 fail to switch properly between different
    rate/format. Similar to 'Playback Design', this patch corrects the
    invalid clock source error for TEAC products and avoids complete
    freeze of the usb interface of 503 series.
    
    Signed-off-by: Guillaume Fougnies <guillaume@eulerian.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 23ea6d800c4c..a75d9ce7d77a 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1205,8 +1205,12 @@ void snd_usb_set_interface_quirk(struct usb_device *dev)
 	 * "Playback Design" products need a 50ms delay after setting the
 	 * USB interface.
 	 */
-	if (le16_to_cpu(dev->descriptor.idVendor) == 0x23ba)
+	switch (le16_to_cpu(dev->descriptor.idVendor)) {
+	case 0x23ba: /* Playback Design */
+	case 0x0644: /* TEAC Corp. */
 		mdelay(50);
+		break;
+	}
 }
 
 void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
@@ -1221,6 +1225,14 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(20);
 
+	/*
+	 * "TEAC Corp." products need a 20ms delay after each
+	 * class compliant request
+	 */
+	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x0644) &&
+	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
+		mdelay(20);
+
 	/* Marantz/Denon devices with USB DAC functionality need a delay
 	 * after each class compliant request
 	 */

commit a4eae3a506ea4a7d4474cd74e20b423fa8053d91
Author: Jurgen Kramer <gtmkramer@xs4all.nl>
Date:   Mon Jan 11 08:16:58 2016 +0100

    ALSA: usb: Add native DSD support for Oppo HA-1
    
    This patch adds native DSD support for the Oppo HA-1. It uses a XMOS chipset
    but they use their own vendor ID.
    
    Signed-off-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index b6c0c8e3b450..23ea6d800c4c 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1269,6 +1269,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	case USB_ID(0x20b1, 0x3008): /* iFi Audio micro/nano iDSD */
 	case USB_ID(0x20b1, 0x2008): /* Matrix Audio X-Sabre */
 	case USB_ID(0x20b1, 0x300a): /* Matrix Audio Mini-i Pro */
+	case USB_ID(0x22d8, 0x0416): /* OPPO HA-1*/
 		if (fp->altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

commit 12a6116e66695a728bcb9616416c508ce9c051a1
Author: Anssi Hannula <anssi.hannula@iki.fi>
Date:   Sun Dec 13 20:49:59 2015 +0200

    ALSA: usb-audio: Add sample rate inquiry quirk for AudioQuest DragonFly
    
    Avoid getting sample rate on AudioQuest DragonFly as it is unsupported
    and causes noisy "cannot get freq at ep 0x1" messages when playback
    starts.
    
    Signed-off-by: Anssi Hannula <anssi.hannula@iki.fi>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 7016ad898187..b6c0c8e3b450 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1125,6 +1125,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
+	case USB_ID(0x21B4, 0x0081): /* AudioQuest DragonFly */
 		return true;
 	}
 	return false;

commit 1ca8b201309d842642f221db7f02f71c0af5be2d
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 15 22:38:29 2015 +0100

    ALSA: usb-audio: prevent CH345 multiport output SysEx corruption
    
    The CH345 USB MIDI chip has two output ports.  However, they are
    multiplexed through one pin, and the number of ports cannot be reduced
    even for hardware that implements only one connector, so for those
    devices, data sent to either port ends up on the same hardware output.
    This becomes a problem when both ports are used at the same time, as
    longer MIDI commands (such as SysEx messages) are likely to be
    interrupted by messages from the other port, and thus to get lost.
    
    It would not be possible for the driver to detect how many ports the
    device actually has, except that in practice, _all_ devices built with
    the CH345 have only one port.  So we can just ignore the device's
    descriptors, and hardcode one output port.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 5ca80e7d30cd..7016ad898187 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -538,6 +538,7 @@ int snd_usb_create_quirk(struct snd_usb_audio *chip,
 		[QUIRK_MIDI_CME] = create_any_midi_quirk,
 		[QUIRK_MIDI_AKAI] = create_any_midi_quirk,
 		[QUIRK_MIDI_FTDI] = create_any_midi_quirk,
+		[QUIRK_MIDI_CH345] = create_any_midi_quirk,
 		[QUIRK_AUDIO_STANDARD_INTERFACE] = create_standard_audio_quirk,
 		[QUIRK_AUDIO_FIXED_ENDPOINT] = create_fixed_stream_quirk,
 		[QUIRK_AUDIO_EDIROL_UAXX] = create_uaxx_quirk,

commit 16771c7c704769c5f3d70c024630b6e5b3eafa67
Author: Jurgen Kramer <gtmkramer@xs4all.nl>
Date:   Mon Nov 9 12:13:55 2015 +0100

    ALSA: usb: Add native DSD support for Aune X1S
    
    This patch adds native DSD support for the Aune X1S 32BIT/384 DSD DAC
    
    Signed-off-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 4897ea171194..5ca80e7d30cd 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1274,6 +1274,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	case USB_ID(0x20b1, 0x000a): /* Gustard DAC-X20U */
 	case USB_ID(0x20b1, 0x2009): /* DIYINHK DSD DXD 384kHz USB to I2S/DSD */
 	case USB_ID(0x20b1, 0x2023): /* JLsounds I2SoverUSB */
+	case USB_ID(0x20b1, 0x3023): /* Aune X1S 32BIT/384 DSD DAC */
 		if (fp->altsetting == 3)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

commit e05704467736231199503e5a21c587e7ec36b829
Author: Ricard Wanderlof <ricard.wanderlof@axis.com>
Date:   Mon Oct 19 08:52:53 2015 +0200

    ALSA: USB-audio: Add quirk for Zoom R16/24 playback
    
    The Zoom R16/24 have a nonstandard playback format where each isochronous
    packet contains a length descriptor in the first four bytes. (Curiously,
    capture data does not contain this and requires no quirk.)
    
    The quirk involves adding the extra length descriptor whenever outgoing
    isochronous packets are generated, both in pcm.c (outgoing audio) and
    endpoint.c (silent data).
    
    In order to make the quirk as unintrusive as possible, for
    pcm.c:prepare_playback_urb(), the isochronous packet descriptors are
    initially set up in the same way no matter if the quirk is enabled or not.
    Once it is time to actually copy the data into the outgoing packet buffer
    (together with the added length descriptors) the isochronous descriptors
    are adjusted in order take the increased payload length into account.
    
    For endpoint.c:prepare_silent_urb() it makes more sense to modify the
    actual function, partly because the function is less complex to start with
    and partly because it is not as time-critical as prepare_playback_urb()
    (whose bulk is run with interrupts disabled), so the (minute) additional
    time spent in the non-quirk case is motivated by the simplicity of having
    a single function for all cases.
    
    The quirk is controlled by the new tx_length_quirk member in struct
    snd_usb_substream and struct snd_usb_audio, which is conveyed to pcm.c
    and endpoint.c from quirks.c in a similar manner to the txfr_quirk member
    in the same structs.
    
    In contrast to txfr_quirk however, the quirk is enabled directly in
    quirks.c:create_standard_audio_quirk() by checking the USB ID in that
    function. Another option would be to introduce a new
    QUIRK_AUDIO_ZOOM_INTERFACE or somesuch, which would have made the quirk
    very plain to see in the quirk table, but it was felt that the additional
    code needed to implement it this way would just make the implementation
    more complex with no real gain.
    
    Tested with a Zoom R16, both by doing capture and playback separately
    using arecord and aplay (8 channel capture and 2 channel playback,
    respectively), as well as capture and playback together using Ardour, as
    well as Audacity and Qtractor together with jackd.
    
    The R24 is reportedly compatible with the R16 when used as an audio
    interface. Both devices share the same USB ID and have the same number of
    inputs (8) and outputs (2). Therefore "R16/24" is mentioned throughout the
    patch.
    
    Regression tested using an Edirol UA-5 in both class compliant (16-bit)
    and "advanced" (24 bit, forces the use of quirks) modes.
    
    Signed-off-by: Ricard Wanderlof <ricardw@axis.com>
    Tested-by: Panu Matilainen <pmatilai@laiskiainen.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 00ebc0ca008e..4897ea171194 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -115,6 +115,9 @@ static int create_standard_audio_quirk(struct snd_usb_audio *chip,
 	struct usb_interface_descriptor *altsd;
 	int err;
 
+	if (chip->usb_id == USB_ID(0x1686, 0x00dd)) /* Zoom R16/24 */
+		chip->tx_length_quirk = 1;
+
 	alts = &iface->altsetting[0];
 	altsd = get_iface_desc(alts);
 	err = snd_usb_parse_audio_interface(chip, altsd->bInterfaceNumber);

commit 9544f8b6e2ee9ed02d2322ff018837b185f51d45
Author: Jurgen Kramer <gtmkramer@xs4all.nl>
Date:   Fri Aug 21 09:48:35 2015 +0200

    ALSA: usb: Add native DSD support for Gustard DAC-X20U
    
    This patch adds native DSD support for the Gustard DAC-X20U.
    
    Signed-off-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 754e689596a2..00ebc0ca008e 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1268,6 +1268,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
 
+	case USB_ID(0x20b1, 0x000a): /* Gustard DAC-X20U */
 	case USB_ID(0x20b1, 0x2009): /* DIYINHK DSD DXD 384kHz USB to I2S/DSD */
 	case USB_ID(0x20b1, 0x2023): /* JLsounds I2SoverUSB */
 		if (fp->altsetting == 3)

commit 3b7e5c7e36ed4a046bbea6d36c9be9d1d6107ae0
Author: Jurgen Kramer <gtmkramer@xs4all.nl>
Date:   Fri Jun 5 09:42:49 2015 +0200

    ALSA: usb-audio: add native DSD support for JLsounds I2SoverUSB
    
    This patch adds native DSD support for the XMOS based JLsounds I2SoverUSB board
    
    Signed-off-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index b8c97d092a47..754e689596a2 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1267,8 +1267,9 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 		if (fp->altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
-	/* DIYINHK DSD DXD 384kHz USB to I2S/DSD */
-	case USB_ID(0x20b1, 0x2009):
+
+	case USB_ID(0x20b1, 0x2009): /* DIYINHK DSD DXD 384kHz USB to I2S/DSD */
+	case USB_ID(0x20b1, 0x2023): /* JLsounds I2SoverUSB */
 		if (fp->altsetting == 3)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

commit 2f80b2958abe5658000d5ad9b45a36ecf879666e
Author: Eric Wong <normalperson@yhbt.net>
Date:   Sat May 30 09:15:39 2015 +0000

    ALSA: usb-audio: don't try to get Outlaw RR2150 sample rate
    
    This quirk allows us to avoid the noisy:
    
            current rate 0 is different from the runtime rate
    
    message every time playback starts.  While USB DAC in the RR2150
    supports reading the sample rate, it never returns a sample rate
    other than zero in my observation with common sample rates.
    
    Signed-off-by: Eric Wong <normalperson@yhbt.net>
    Cc: Joe Turner <joe@oampo.co.uk>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 29175346cc4f..b8c97d092a47 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1120,6 +1120,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x045E, 0x0772): /* MS Lifecam Studio */
 	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
+	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
 		return true;
 	}
 	return false;

commit ae425bb2a05bebe786a25cc8ae64e9d16c4d9b83
Author: Vittorio G (VittGam) <linuxbugs@vittgam.net>
Date:   Fri May 22 21:15:19 2015 +0200

    ALSA: usb-audio: Add quirk for MS LifeCam HD-3000
    
    Microsoft LifeCam HD-3000 (045e:0779) needs a similar quirk for
    suppressing the unsupported sample rate inquiry.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=98481
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Vittorio Gambaletta <linuxbugs@vittgam.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 46facfc9aec1..29175346cc4f 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1118,6 +1118,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	case USB_ID(0x045E, 0x075D): /* MS Lifecam Cinema  */
 	case USB_ID(0x045E, 0x076D): /* MS Lifecam HD-5000 */
 	case USB_ID(0x045E, 0x0772): /* MS Lifecam Studio */
+	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 		return true;
 	}

commit fa94b0d72511add5822dc4124f2a3eae66b8863f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 19 10:46:49 2015 +0200

    ALSA: usb-audio: Add quirk for MS LifeCam Studio
    
    Microsoft LifeCam Studio (045e:0772) needs a similar quirk for
    suppressing the wrong sample rate inquiry.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=98481
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 7c5a70139278..46facfc9aec1 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1117,6 +1117,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 	switch (chip->usb_id) {
 	case USB_ID(0x045E, 0x075D): /* MS Lifecam Cinema  */
 	case USB_ID(0x045E, 0x076D): /* MS Lifecam HD-5000 */
+	case USB_ID(0x045E, 0x0772): /* MS Lifecam Studio */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 		return true;
 	}

commit 9a4f35865ffcb2f4603375eadabe0d475fab1a0f
Merge: eef0342cf326 c30cf8cbe554
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 13 10:23:18 2015 +0200

    Merge branch 'for-next' into for-linus

commit eef0342cf32689f77d78ee3302999e5caaa6a8f3
Author: Adam Honse <calcprogrammer1@gmail.com>
Date:   Sun Apr 12 01:03:07 2015 -0500

    ALSA: usb-audio: Don't attempt to get Microsoft Lifecam Cinema sample rate
    
    Adds Microsoft LifeCam Cinema USB ID to the snd_usb_get_sample_rate_quirk list as the Lifecam Cinema does not appear to support getting the sample rate.
    
    Fixes the issue where the LifeCam Cinema would wait for USB timeout and log the message "cannot get freq at ep 0x82" when accessed.
    
    Addresses bug report https://bugzilla.kernel.org/show_bug.cgi?id=95961.
    
    Signed-off-by: Adam Honse <calcprogrammer1@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 9a28365126f9..32631a86078b 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1115,6 +1115,7 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 {
 	/* devices which do not support reading the sample rate. */
 	switch (chip->usb_id) {
+	case USB_ID(0x045E, 0x075D): /* MS Lifecam Cinema  */
 	case USB_ID(0x045E, 0x076D): /* MS Lifecam HD-5000 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 		return true;

commit 0a599838737a2527c35e4d94f794aefe59df1781
Merge: 2d846c740272 a59d7199f62b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Apr 8 11:29:56 2015 +0200

    Merge branch 'for-linus' into for-next
    
    Back merge HD-audio quirks to for-next branch, so that we can apply
    a couple of more quirks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 9fc88ad6fd86ff6ce979105c633c58cc3980129c
Author: Eric Wong <normalperson@yhbt.net>
Date:   Tue Mar 31 07:34:05 2015 +0000

    ALSA: usb-audio: don't try to get Benchmark DAC1 sample rate
    
    Adding this quirk allows us to avoid the noisy
    "cannot get freq at ep 0x1" message in dmesg output every time
    playback starts.
    
    This ought to affect other Benchmark DAC1 variations using the same
    "Microchip Technology, Inc." chip as well, but I have only tested
    with the "Pre" variant.
    
    Signed-off-by: Eric Wong <normalperson@yhbt.net>
    Cc: Joe Turner <joe@oampo.co.uk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 753a47de8459..9a28365126f9 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1113,8 +1113,13 @@ void snd_usb_set_format_quirk(struct snd_usb_substream *subs,
 
 bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 {
-	/* MS Lifecam HD-5000 doesn't support reading the sample rate. */
-	return chip->usb_id == USB_ID(0x045E, 0x076D);
+	/* devices which do not support reading the sample rate. */
+	switch (chip->usb_id) {
+	case USB_ID(0x045E, 0x076D): /* MS Lifecam HD-5000 */
+	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
+		return true;
+	}
+	return false;
 }
 
 /* Marantz/Denon USB DACs need a vendor cmd to switch

commit 8b28c93fe5a55873ce22b7126e84eb59290f8603
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 4 15:37:01 2015 +0100

    ALSA: usb-audio: Check Marantz/Denon USB DACs in a single place
    
    There are three places doing the same check.  Let's make them
    together.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 753a47de8459..353532b8aee4 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1120,17 +1120,24 @@ bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
 /* Marantz/Denon USB DACs need a vendor cmd to switch
  * between PCM and native DSD mode
  */
+static bool is_marantz_denon_dac(unsigned int id)
+{
+	switch (id) {
+	case USB_ID(0x154e, 0x1003): /* Denon DA-300USB */
+	case USB_ID(0x154e, 0x3005): /* Marantz HD-DAC1 */
+	case USB_ID(0x154e, 0x3006): /* Marantz SA-14S1 */
+		return true;
+	}
+	return false;
+}
+
 int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
 			      struct audioformat *fmt)
 {
 	struct usb_device *dev = subs->dev;
 	int err;
 
-	switch (subs->stream->chip->usb_id) {
-	case USB_ID(0x154e, 0x1003): /* Denon DA-300USB */
-	case USB_ID(0x154e, 0x3005): /* Marantz HD-DAC1 */
-	case USB_ID(0x154e, 0x3006): /* Marantz SA-14S1 */
-
+	if (is_marantz_denon_dac(subs->stream->chip->usb_id)) {
 		/* First switch to alt set 0, otherwise the mode switch cmd
 		 * will not be accepted by the DAC
 		 */
@@ -1203,17 +1210,10 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	/* Marantz/Denon devices with USB DAC functionality need a delay
 	 * after each class compliant request
 	 */
-	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x154e) &&
-	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS) {
-
-		switch (le16_to_cpu(dev->descriptor.idProduct)) {
-		case 0x1003: /* Denon DA300-USB */
-		case 0x3005: /* Marantz HD-DAC1 */
-		case 0x3006: /* Marantz SA-14S1 */
-			mdelay(20);
-			break;
-		}
-	}
+	if (is_marantz_denon_dac(USB_ID(le16_to_cpu(dev->descriptor.idVendor),
+					le16_to_cpu(dev->descriptor.idProduct)))
+	    && (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
+		mdelay(20);
 
 	/* Zoom R16/24 needs a tiny delay here, otherwise requests like
 	 * get/set frequency return as failed despite actually succeeding.
@@ -1268,15 +1268,9 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	}
 
 	/* Denon/Marantz devices with USB DAC functionality */
-	switch (chip->usb_id) {
-	case USB_ID(0x154e, 0x1003): /* Denon DA300-USB */
-	case USB_ID(0x154e, 0x3005): /* Marantz HD-DAC1 */
-	case USB_ID(0x154e, 0x3006): /* Marantz SA-14S1 */
+	if (is_marantz_denon_dac(chip->usb_id)) {
 		if (fp->altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
-		break;
-	default:
-		break;
 	}
 
 	return 0;

commit 3cd1ce0420ce89937bef9096d5bdb13fbdf0f8b0
Author: Frank C Guenther <bugzilla.frnkcg@spamgourmet.com>
Date:   Tue Feb 17 22:13:32 2015 +0100

    ALSA: usb: Fix support for Denon DA-300USB DAC (ID 154e:1003)
    
    Fix problem where playback of Denon DA-300USB DAC sometimes does not
    start and leads to error messages like "clock source 41 is not valid,
    cannot use".
    
    Solution: Treat this device the same as other Denon/Marantz devices in
    sound/usb/quirks.c.
    
    Tested with both PCM and DSD formats.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=93261
    Signed-off-by: Frank C Guenther <bugzilla.frnkcg@spamgourmet.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 5c0c05314df0..753a47de8459 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1127,6 +1127,7 @@ int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
 	int err;
 
 	switch (subs->stream->chip->usb_id) {
+	case USB_ID(0x154e, 0x1003): /* Denon DA-300USB */
 	case USB_ID(0x154e, 0x3005): /* Marantz HD-DAC1 */
 	case USB_ID(0x154e, 0x3006): /* Marantz SA-14S1 */
 
@@ -1206,6 +1207,7 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS) {
 
 		switch (le16_to_cpu(dev->descriptor.idProduct)) {
+		case 0x1003: /* Denon DA300-USB */
 		case 0x3005: /* Marantz HD-DAC1 */
 		case 0x3006: /* Marantz SA-14S1 */
 			mdelay(20);
@@ -1267,6 +1269,7 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 
 	/* Denon/Marantz devices with USB DAC functionality */
 	switch (chip->usb_id) {
+	case USB_ID(0x154e, 0x1003): /* Denon DA300-USB */
 	case USB_ID(0x154e, 0x3005): /* Marantz HD-DAC1 */
 	case USB_ID(0x154e, 0x3006): /* Marantz SA-14S1 */
 		if (fp->altsetting == 2)

commit b62b998010028c4dfd7db7c26990efb2a0985a1e
Author: Joe Turner <joe@oampo.co.uk>
Date:   Mon Feb 16 20:44:33 2015 +0000

    ALSA: usb-audio: Don't attempt to get Lifecam HD-5000 sample rate
    
    Adds a quirk to disable the check that the sample rate has been set correctly, as the Lifecam does not support getting the sample rate.
    
    This means that we don't need to wait for the USB timeout when attempting to get the sample rate. Waiting for the timeout causes problems in some applications, which give up on the device acquisition process before it has had time to complete, resulting in no sound.
    
    [minor tidy up by tiwai]
    
    Signed-off-by: Joe Turner <joe@oampo.co.uk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index a7398412310b..5c0c05314df0 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1111,6 +1111,11 @@ void snd_usb_set_format_quirk(struct snd_usb_substream *subs,
 	}
 }
 
+bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)
+{
+	/* MS Lifecam HD-5000 doesn't support reading the sample rate. */
+	return chip->usb_id == USB_ID(0x045E, 0x076D);
+}
 
 /* Marantz/Denon USB DACs need a vendor cmd to switch
  * between PCM and native DSD mode

commit 38f74d5b82b329dff5bdf8626e8776a36a1835da
Author: Jurgen Kramer <gtmkramer@xs4all.nl>
Date:   Wed Dec 17 17:45:20 2014 +0100

    ALSA: usb-audio: add native DSD support for Matrix Audio DACs
    
    This patch adds native DSD support for two XMOS based DACs from Matrix Audio:
    - X-Sabre
    - Mini-i Pro
    
    Signed-off-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 4dbfb3d18ee2..a7398412310b 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1245,8 +1245,9 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 
 	/* XMOS based USB DACs */
 	switch (chip->usb_id) {
-	/* iFi Audio micro/nano iDSD */
-	case USB_ID(0x20b1, 0x3008):
+	case USB_ID(0x20b1, 0x3008): /* iFi Audio micro/nano iDSD */
+	case USB_ID(0x20b1, 0x2008): /* Matrix Audio X-Sabre */
+	case USB_ID(0x20b1, 0x300a): /* Matrix Audio Mini-i Pro */
 		if (fp->altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

commit dacacb0aa0cb6fdeb69313db6acfc82456945d7e
Author: Panu Matilainen <pmatilai@laiskiainen.org>
Date:   Sun Nov 30 18:45:40 2014 +0200

    ALSA: usb-audio: Add support for Zoom R16/24 capture and midi interfaces
    
    This makes the midi interface and capture work out of the box with
    R16 (and presumably R24 too but untested). Playback stream would also
    seem to function fine except for one caveat: no sound is produced,
    so it is disabled for now. Mixer descriptors are garbage and will
    require further quirks to enable functionality, also disabled here.
    
    Signed-off-by: Panu Matilainen <pmatilai@laiskiainen.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index e45cc3af9b9c..4dbfb3d18ee2 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1207,6 +1207,14 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 			break;
 		}
 	}
+
+	/* Zoom R16/24 needs a tiny delay here, otherwise requests like
+	 * get/set frequency return as failed despite actually succeeding.
+	 */
+	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x1686) &&
+	    (le16_to_cpu(dev->descriptor.idProduct) == 0x00dd) &&
+	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
+		mdelay(1);
 }
 
 /*

commit 50314663877b3c5f08b2573c0bb161b6a2c63c3e
Merge: 6874daad4b0f d42472ecffd7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 28 18:30:19 2014 +0100

    Merge branch 'for-linus' into for-next
    
    The commit [7a2e9ddc: ALSA: usb-audio: Add native DSD support for
    Denon/Marantz DACs] requires the new format definition that has
    landed only in for-next branch.

commit 6874daad4b0fbed5b2f9bef7f4d3f2b895463a95
Author: Jurgen Kramer <gtmkramer@xs4all.nl>
Date:   Fri Nov 28 17:32:54 2014 +0100

    ALSA: usb-audio: Add mode select quirk for Denon/Marantz DACs
    
    Denon/Marantz USB DACs need a specific vendor command to switch between PCM and
    DSD mode. This patch adds a new quirk function to switch between the two modes
    using the specific USB vendor command.
    
    This patch applies to the following devices:
    - Marantz SA-14S1
    - Marantz HD-DAC1
    
    Signed-off-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index a9d4add89bbe..e0cde741e41d 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1111,6 +1111,44 @@ void snd_usb_set_format_quirk(struct snd_usb_substream *subs,
 	}
 }
 
+
+/* Marantz/Denon USB DACs need a vendor cmd to switch
+ * between PCM and native DSD mode
+ */
+int snd_usb_select_mode_quirk(struct snd_usb_substream *subs,
+			      struct audioformat *fmt)
+{
+	struct usb_device *dev = subs->dev;
+	int err;
+
+	switch (subs->stream->chip->usb_id) {
+	case USB_ID(0x154e, 0x3005): /* Marantz HD-DAC1 */
+	case USB_ID(0x154e, 0x3006): /* Marantz SA-14S1 */
+
+		/* First switch to alt set 0, otherwise the mode switch cmd
+		 * will not be accepted by the DAC
+		 */
+		err = usb_set_interface(dev, fmt->iface, 0);
+		if (err < 0)
+			return err;
+
+		mdelay(20); /* Delay needed after setting the interface */
+
+		switch (fmt->altsetting) {
+		case 2: /* DSD mode requested */
+		case 1: /* PCM mode requested */
+			err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), 0,
+					      USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,
+					      fmt->altsetting - 1, 1, NULL, 0);
+			if (err < 0)
+				return err;
+			break;
+		}
+		mdelay(20);
+	}
+	return 0;
+}
+
 void snd_usb_endpoint_start_quirk(struct snd_usb_endpoint *ep)
 {
 	/*

commit 7a2e9ddc903225d8fb3a510a842144a239017ee4
Author: Jurgen Kramer <gtmkramer@xs4all.nl>
Date:   Fri Nov 28 17:32:53 2014 +0100

    ALSA: usb-audio: Add native DSD support for Denon/Marantz DACs
    
    This patch adds native DSD support for the following devices:
    - Marantz SA-14S1
    - Marants HD-DAC1
    
    Signed-off-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 2c1018e447b1..a9d4add89bbe 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1213,5 +1213,16 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 		break;
 	}
 
+	/* Denon/Marantz devices with USB DAC functionality */
+	switch (chip->usb_id) {
+	case USB_ID(0x154e, 0x3005): /* Marantz HD-DAC1 */
+	case USB_ID(0x154e, 0x3006): /* Marantz SA-14S1 */
+		if (fp->altsetting == 2)
+			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
+		break;
+	default:
+		break;
+	}
+
 	return 0;
 }

commit d42472ecffd7c42086c6e5b1335c99a3adf58a09
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Fri Nov 21 16:04:46 2014 +0200

    ALSA: pcm: Add big-endian DSD sample formats and fix XMOS DSD sample format
    
    This patch fixes XMOS DSD sample format to DSD_U32_BE and also adds
    DSD_U16_BE and DSD_U32_BE sample formats.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Acked-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index a5941f80fc5b..60dfe0d28771 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1193,12 +1193,12 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 	/* iFi Audio micro/nano iDSD */
 	case USB_ID(0x20b1, 0x3008):
 		if (fp->altsetting == 2)
-			return SNDRV_PCM_FMTBIT_DSD_U32_LE;
+			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
 	/* DIYINHK DSD DXD 384kHz USB to I2S/DSD */
 	case USB_ID(0x20b1, 0x2009):
 		if (fp->altsetting == 3)
-			return SNDRV_PCM_FMTBIT_DSD_U32_LE;
+			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
 	default:
 		break;

commit a69862d8d04e4877965cc938140c9f8e6da0b827
Merge: 0f32fd1900e6 01cb156edbbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 20 21:46:04 2014 +0100

    Merge branch 'for-linus' into test/usb-resume

commit 6e84a8d7ac3ba246ef44e313e92bc16a1da1b04a
Author: Jurgen Kramer <gtmkramer@xs4all.nl>
Date:   Sat Nov 15 14:01:21 2014 +0100

    ALSA: usb-audio: Add ctrl message delay quirk for Marantz/Denon devices
    
    This patch adds a USB control message delay quirk for a few specific Marantz/Denon
    devices. Without the delay the DACs will not work properly and produces the
    following type of messages:
    
    Nov 15 10:09:21 orwell kernel: [   91.342880] usb 3-13: clock source 41 is not valid, cannot use
    Nov 15 10:09:21 orwell kernel: [   91.343775] usb 3-13: clock source 41 is not valid, cannot use
    
    There are likely other Marantz/Denon devices using the same USB module which exhibit the
    same problems. But as this cannot be verified I limited the patch to the devices
    I could test.
    
    The following two devices are covered by this path:
    - Marantz SA-14S1
    - Marantz HD-DAC1
    
    Signed-off-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index d2aa45a8d895..a5941f80fc5b 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1146,6 +1146,20 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x23ba) &&
 	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(20);
+
+	/* Marantz/Denon devices with USB DAC functionality need a delay
+	 * after each class compliant request
+	 */
+	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x154e) &&
+	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS) {
+
+		switch (le16_to_cpu(dev->descriptor.idProduct)) {
+		case 0x3005: /* Marantz HD-DAC1 */
+		case 0x3006: /* Marantz SA-14S1 */
+			mdelay(20);
+			break;
+		}
+	}
 }
 
 /*

commit 85a8181329a919d58b7ef99211251f47d5e1049e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 10 07:41:59 2014 +0100

    ALSA: usb-audio: Fix Oops by composite quirk enhancement
    
    The quirk argument itself was used as iterator, so it cannot be taken
    back to the original value, obviously.
    
    Fixes: d4b8fc66f770 ('ALSA: usb-audio: Allow multiple entries for the same iface in composite quirk')
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index e9ff3a6c60e4..809d7fab4633 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -43,12 +43,13 @@
 static int create_composite_quirk(struct snd_usb_audio *chip,
 				  struct usb_interface *iface,
 				  struct usb_driver *driver,
-				  const struct snd_usb_audio_quirk *quirk)
+				  const struct snd_usb_audio_quirk *quirk_comp)
 {
 	int probed_ifnum = get_iface_desc(iface->altsetting)->bInterfaceNumber;
+	const struct snd_usb_audio_quirk *quirk;
 	int err;
 
-	for (quirk = quirk->data; quirk->ifnum >= 0; ++quirk) {
+	for (quirk = quirk_comp->data; quirk->ifnum >= 0; ++quirk) {
 		iface = usb_ifnum_to_if(chip->dev, quirk->ifnum);
 		if (!iface)
 			continue;
@@ -60,7 +61,7 @@ static int create_composite_quirk(struct snd_usb_audio *chip,
 			return err;
 	}
 
-	for (quirk = quirk->data; quirk->ifnum >= 0; ++quirk) {
+	for (quirk = quirk_comp->data; quirk->ifnum >= 0; ++quirk) {
 		iface = usb_ifnum_to_if(chip->dev, quirk->ifnum);
 		if (!iface)
 			continue;

commit d4b8fc66f770e9b79830cfe6c342846293b99fda
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Nov 9 18:21:23 2014 +0100

    ALSA: usb-audio: Allow multiple entries for the same iface in composite quirk
    
    Currently the composite quirk doesn't work when multiple entries are
    assigned to the same interface because it marks the interface as
    claimed then checks whether the interface has been already claimed for
    the secondary entry.  But, if you look at the code, you'll notice that
    multiple entries are allowed if the entry is the current interface;
    i.e. the current behavior is anyway inconsistent, and this is an
    unintended shortcoming.
    
    This patch fixes the problem by marking the relevant interfaces as
    claimed after applying the all composite entries.  This fix will be
    needed for the upcoming enhancements for Digidesign Mbox 1 quirks.
    
    Reviewed-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index d2aa45a8d895..e9ff3a6c60e4 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -58,9 +58,17 @@ static int create_composite_quirk(struct snd_usb_audio *chip,
 		err = snd_usb_create_quirk(chip, iface, driver, quirk);
 		if (err < 0)
 			return err;
-		if (quirk->ifnum != probed_ifnum)
+	}
+
+	for (quirk = quirk->data; quirk->ifnum >= 0; ++quirk) {
+		iface = usb_ifnum_to_if(chip->dev, quirk->ifnum);
+		if (!iface)
+			continue;
+		if (quirk->ifnum != probed_ifnum &&
+		    !usb_interface_claimed(iface))
 			usb_driver_claim_interface(driver, iface, (void *)-1L);
 	}
+
 	return 0;
 }
 

commit 848f3a82df50fcc68a78c9d7d45e210b626b0283
Author: Jurgen Kramer <gtmkramer@xs4all.nl>
Date:   Fri Sep 5 18:14:46 2014 +0200

    ALSA: usb-audio: add native DSD support for XMOS based DACs
    
    Add quirks for XMOS based DACs for native DSD playback support using the new
    DSD_U32_LE sample format.
    
    This version adds native DSD support for:
    - iFi Audio micro iDSD/nano iDSD (they use the same prod. id)
    - DIYINHK USB to I2S/DSD converter
    
    Changes from v2:
    - fix and simplify switch statement
    Changes from v1:
    - use specific product id and alt setting per XMOS based device
    
    [fixed a misc coding style issue by tiwai]
    
    Signed-off-by: Jurgen Kramer <gtmkramer@xs4all.nl>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 19a921eb75f1..d2aa45a8d895 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1174,5 +1174,21 @@ u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
 		}
 	}
 
+	/* XMOS based USB DACs */
+	switch (chip->usb_id) {
+	/* iFi Audio micro/nano iDSD */
+	case USB_ID(0x20b1, 0x3008):
+		if (fp->altsetting == 2)
+			return SNDRV_PCM_FMTBIT_DSD_U32_LE;
+		break;
+	/* DIYINHK DSD DXD 384kHz USB to I2S/DSD */
+	case USB_ID(0x20b1, 0x2009):
+		if (fp->altsetting == 3)
+			return SNDRV_PCM_FMTBIT_DSD_U32_LE;
+		break;
+	default:
+		break;
+	}
+
 	return 0;
 }

commit 542baf94ec3c5526955b4c9fd899c7f30fae4ebe
Author: Paul S McSpadden <fisch602@gmail.com>
Date:   Sun Aug 3 17:47:36 2014 -0500

    ALSA: usb-audio: Adjust Gamecom 780 volume level
    
    Original patch fixed the original problem, but the sound was far too low
    for most users. This patch references a compare matrix to allow the
    volume levels to act normally. I personally tested this patch myself,
    and volume levels returned to normal. Please see this discussion for
    more details: https://bugzilla.kernel.org/show_bug.cgi?id=65251
    
    Signed-off-by: Paul S McSpadden <fisch602@gmail.com>
    Cc: <stable@vger.kernel.org> [v3.14+]
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 7c57f2268dd7..19a921eb75f1 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -670,7 +670,7 @@ static int snd_usb_gamecon780_boot_quirk(struct usb_device *dev)
 	/* set the initial volume and don't change; other values are either
 	 * too loud or silent due to firmware bug (bko#65251)
 	 */
-	u8 buf[2] = { 0x74, 0xdc };
+	u8 buf[2] = { 0x74, 0xe3 };
 	return snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), UAC_SET_CUR,
 			USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,
 			UAC_FU_VOLUME << 8, 9 << 8, buf, 2);

commit 0ba41d917eeb87f608cf147f870ff2f4c1056bab
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 26 13:02:17 2014 +0100

    ALSA: usb-audio: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    As there are too deep indirections (e.g. ep->chip->dev->dev),
    a few new local macros, usb_audio_err() & co, are introduced.
    
    Also, the device numbers in some messages are dropped, as they are
    shown in the prefix automatically.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 89730707614c..7c57f2268dd7 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -110,7 +110,7 @@ static int create_standard_audio_quirk(struct snd_usb_audio *chip,
 	altsd = get_iface_desc(alts);
 	err = snd_usb_parse_audio_interface(chip, altsd->bInterfaceNumber);
 	if (err < 0) {
-		snd_printk(KERN_ERR "cannot setup if %d: error %d\n",
+		usb_audio_err(chip, "cannot setup if %d: error %d\n",
 			   altsd->bInterfaceNumber, err);
 		return err;
 	}
@@ -135,7 +135,7 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 
 	fp = kmemdup(quirk->data, sizeof(*fp), GFP_KERNEL);
 	if (!fp) {
-		snd_printk(KERN_ERR "cannot memdup\n");
+		usb_audio_err(chip, "cannot memdup\n");
 		return -ENOMEM;
 	}
 	if (fp->nr_rates > MAX_NR_RATES) {
@@ -464,7 +464,7 @@ static int create_uaxx_quirk(struct snd_usb_audio *chip,
 		fp->rate_max = fp->rate_min = 96000;
 		break;
 	default:
-		snd_printk(KERN_ERR "unknown sample rate\n");
+		usb_audio_err(chip, "unknown sample rate\n");
 		kfree(fp);
 		return -ENXIO;
 	}
@@ -536,7 +536,7 @@ int snd_usb_create_quirk(struct snd_usb_audio *chip,
 	if (quirk->type < QUIRK_TYPE_COUNT) {
 		return quirk_funcs[quirk->type](chip, iface, driver, quirk);
 	} else {
-		snd_printd(KERN_ERR "invalid quirk type %d\n", quirk->type);
+		usb_audio_err(chip, "invalid quirk type %d\n", quirk->type);
 		return -ENXIO;
 	}
 }
@@ -555,18 +555,21 @@ static int snd_usb_extigy_boot_quirk(struct usb_device *dev, struct usb_interfac
 
 	if (le16_to_cpu(get_cfg_desc(config)->wTotalLength) == EXTIGY_FIRMWARE_SIZE_OLD ||
 	    le16_to_cpu(get_cfg_desc(config)->wTotalLength) == EXTIGY_FIRMWARE_SIZE_NEW) {
-		snd_printdd("sending Extigy boot sequence...\n");
+		dev_dbg(&dev->dev, "sending Extigy boot sequence...\n");
 		/* Send message to force it to reconnect with full interface. */
 		err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev,0),
 				      0x10, 0x43, 0x0001, 0x000a, NULL, 0);
-		if (err < 0) snd_printdd("error sending boot message: %d\n", err);
+		if (err < 0)
+			dev_dbg(&dev->dev, "error sending boot message: %d\n", err);
 		err = usb_get_descriptor(dev, USB_DT_DEVICE, 0,
 				&dev->descriptor, sizeof(dev->descriptor));
 		config = dev->actconfig;
-		if (err < 0) snd_printdd("error usb_get_descriptor: %d\n", err);
+		if (err < 0)
+			dev_dbg(&dev->dev, "error usb_get_descriptor: %d\n", err);
 		err = usb_reset_configuration(dev);
-		if (err < 0) snd_printdd("error usb_reset_configuration: %d\n", err);
-		snd_printdd("extigy_boot: new boot length = %d\n",
+		if (err < 0)
+			dev_dbg(&dev->dev, "error usb_reset_configuration: %d\n", err);
+		dev_dbg(&dev->dev, "extigy_boot: new boot length = %d\n",
 			    le16_to_cpu(get_cfg_desc(config)->wTotalLength));
 		return -ENODEV; /* quit this anyway */
 	}
@@ -594,7 +597,7 @@ static int snd_usb_fasttrackpro_boot_quirk(struct usb_device *dev)
 	int err;
 
 	if (dev->actconfig->desc.bConfigurationValue == 1) {
-		snd_printk(KERN_INFO "usb-audio: "
+		dev_info(&dev->dev,
 			   "Fast Track Pro switching to config #2\n");
 		/* This function has to be available by the usb core module.
 		 * if it is not avialable the boot quirk has to be left out
@@ -603,14 +606,15 @@ static int snd_usb_fasttrackpro_boot_quirk(struct usb_device *dev)
 		 */
 		err = usb_driver_set_configuration(dev, 2);
 		if (err < 0)
-			snd_printdd("error usb_driver_set_configuration: %d\n",
-				    err);
+			dev_dbg(&dev->dev,
+				"error usb_driver_set_configuration: %d\n",
+				err);
 		/* Always return an error, so that we stop creating a device
 		   that will just be destroyed and recreated with a new
 		   configuration */
 		return -ENODEV;
 	} else
-		snd_printk(KERN_INFO "usb-audio: Fast Track Pro config OK\n");
+		dev_info(&dev->dev, "Fast Track Pro config OK\n");
 
 	return 0;
 }
@@ -779,11 +783,11 @@ static int snd_usb_mbox2_boot_quirk(struct usb_device *dev)
 	fwsize = le16_to_cpu(get_cfg_desc(config)->wTotalLength);
 
 	if (fwsize != MBOX2_FIRMWARE_SIZE) {
-		snd_printk(KERN_ERR "usb-audio: Invalid firmware size=%d.\n", fwsize);
+		dev_err(&dev->dev, "Invalid firmware size=%d.\n", fwsize);
 		return -ENODEV;
 	}
 
-	snd_printd("usb-audio: Sending Digidesign Mbox 2 boot sequence...\n");
+	dev_dbg(&dev->dev, "Sending Digidesign Mbox 2 boot sequence...\n");
 
 	count = 0;
 	bootresponse[0] = MBOX2_BOOT_LOADING;
@@ -794,32 +798,32 @@ static int snd_usb_mbox2_boot_quirk(struct usb_device *dev)
 			0x85, 0xc0, 0x0001, 0x0000, &bootresponse, 0x0012);
 		if (bootresponse[0] == MBOX2_BOOT_READY)
 			break;
-		snd_printd("usb-audio: device not ready, resending boot sequence...\n");
+		dev_dbg(&dev->dev, "device not ready, resending boot sequence...\n");
 		count++;
 	}
 
 	if (bootresponse[0] != MBOX2_BOOT_READY) {
-		snd_printk(KERN_ERR "usb-audio: Unknown bootresponse=%d, or timed out, ignoring device.\n", bootresponse[0]);
+		dev_err(&dev->dev, "Unknown bootresponse=%d, or timed out, ignoring device.\n", bootresponse[0]);
 		return -ENODEV;
 	}
 
-	snd_printdd("usb-audio: device initialised!\n");
+	dev_dbg(&dev->dev, "device initialised!\n");
 
 	err = usb_get_descriptor(dev, USB_DT_DEVICE, 0,
 		&dev->descriptor, sizeof(dev->descriptor));
 	config = dev->actconfig;
 	if (err < 0)
-		snd_printd("error usb_get_descriptor: %d\n", err);
+		dev_dbg(&dev->dev, "error usb_get_descriptor: %d\n", err);
 
 	err = usb_reset_configuration(dev);
 	if (err < 0)
-		snd_printd("error usb_reset_configuration: %d\n", err);
-	snd_printdd("mbox2_boot: new boot length = %d\n",
+		dev_dbg(&dev->dev, "error usb_reset_configuration: %d\n", err);
+	dev_dbg(&dev->dev, "mbox2_boot: new boot length = %d\n",
 		le16_to_cpu(get_cfg_desc(config)->wTotalLength));
 
 	mbox2_setup_48_24_magic(dev);
 
-	snd_printk(KERN_INFO "usb-audio: Digidesign Mbox 2: 24bit 48kHz");
+	dev_info(&dev->dev, "Digidesign Mbox 2: 24bit 48kHz");
 
 	return 0; /* Successful boot */
 }
@@ -865,7 +869,7 @@ static int quattro_skip_setting_quirk(struct snd_usb_audio *chip,
 				return 1; /* skip this altsetting */
 		}
 	}
-	snd_printdd(KERN_INFO
+	usb_audio_dbg(chip,
 		    "using altsetting %d for interface %d config %d\n",
 		    altno, iface, chip->setup);
 	return 0; /* keep this altsetting */
@@ -932,7 +936,7 @@ static int fasttrackpro_skip_setting_quirk(struct snd_usb_audio *chip,
 			return 1;
 	}
 
-	snd_printdd(KERN_INFO
+	usb_audio_dbg(chip,
 		    "using altsetting %d for interface %d config %d\n",
 		    altno, iface, chip->setup);
 	return 0; /* keep this altsetting */

commit 11e424e88bd493b5d55d73d96c82bd889002ef30
Author: Eduard Gilmutdinov <edgilmutdinov@gmail.com>
Date:   Fri Dec 20 14:06:58 2013 +0600

    ALSA: usb-audio: Add support for Focusrite Saffire 6 USB
    
    Signed-off-by: Eduard Gilmutdinov <edgilmutdinov@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index ede753685491..89730707614c 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -674,8 +674,9 @@ static int snd_usb_gamecon780_boot_quirk(struct usb_device *dev)
 
 /*
  * Novation Twitch DJ controller
+ * Focusrite Novation Saffire 6 USB audio card
  */
-static int snd_usb_twitch_boot_quirk(struct usb_device *dev)
+static int snd_usb_novation_boot_quirk(struct usb_device *dev)
 {
 	/* preemptively set up the device because otherwise the
 	 * raw MIDI endpoints are not active */
@@ -984,9 +985,9 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
 		/* Digidesign Mbox 2 */
 		return snd_usb_mbox2_boot_quirk(dev);
 
-	case USB_ID(0x1235, 0x0018):
-		/* Focusrite Novation Twitch */
-		return snd_usb_twitch_boot_quirk(dev);
+	case USB_ID(0x1235, 0x0010): /* Focusrite Novation Saffire 6 USB */
+	case USB_ID(0x1235, 0x0018): /* Focusrite Novation Twitch */
+		return snd_usb_novation_boot_quirk(dev);
 
 	case USB_ID(0x133e, 0x0815):
 		/* Access Music VirusTI Desktop */

commit 19570d747795f0ecff79403698b868dc5ad7fa86
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 19 14:32:53 2013 +0100

    ALSA: usb-audio: Add a quirk for Plantronics Gamecom 780
    
    Plantronics Gamecom 780 headset has a firmware problem, and when the
    FU 0x09 volume is changed, it results in either too loud or silence
    except for a very narrow range.  This patch provides a workaround,
    ignoring the node, initialize the volume in a sane value and keep
    untouched.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=65251
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 0df9ede99dfd..ede753685491 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -660,6 +660,18 @@ static int snd_usb_cm6206_boot_quirk(struct usb_device *dev)
 	return err;
 }
 
+/* quirk for Plantronics GameCom 780 with CM6302 chip */
+static int snd_usb_gamecon780_boot_quirk(struct usb_device *dev)
+{
+	/* set the initial volume and don't change; other values are either
+	 * too loud or silent due to firmware bug (bko#65251)
+	 */
+	u8 buf[2] = { 0x74, 0xdc };
+	return snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), UAC_SET_CUR,
+			USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,
+			UAC_FU_VOLUME << 8, 9 << 8, buf, 2);
+}
+
 /*
  * Novation Twitch DJ controller
  */
@@ -986,6 +998,8 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
 		return snd_usb_nativeinstruments_boot_quirk(dev);
 	case USB_ID(0x0763, 0x2012):  /* M-Audio Fast Track Pro USB */
 		return snd_usb_fasttrackpro_boot_quirk(dev);
+	case USB_ID(0x047f, 0xc010): /* Plantronics Gamecom 780 */
+		return snd_usb_gamecon780_boot_quirk(dev);
 	}
 
 	return 0;

commit aa773bfe8f860173752258c9ba4bf51060fb0d07
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Aug 11 14:13:13 2013 +0200

    ALSA: usb-audio: fix automatic Roland/Yamaha MIDI detection
    
    Commit aafe77cc45a5 (ALSA: usb-audio: add support for many Roland/Yamaha
    devices) had several logic errors that prevented create_auto_midi_quirk
    from enumerating any MIDI ports.
    
    Reported-by: Keith A. Milner <maillist@superlative.org>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 1bc45e71f1fe..0df9ede99dfd 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -319,19 +319,19 @@ static int create_auto_midi_quirk(struct snd_usb_audio *chip,
 	if (altsd->bNumEndpoints < 1)
 		return -ENODEV;
 	epd = get_endpoint(alts, 0);
-	if (!usb_endpoint_xfer_bulk(epd) ||
+	if (!usb_endpoint_xfer_bulk(epd) &&
 	    !usb_endpoint_xfer_int(epd))
 		return -ENODEV;
 
 	switch (USB_ID_VENDOR(chip->usb_id)) {
 	case 0x0499: /* Yamaha */
 		err = create_yamaha_midi_quirk(chip, iface, driver, alts);
-		if (err < 0 && err != -ENODEV)
+		if (err != -ENODEV)
 			return err;
 		break;
 	case 0x0582: /* Roland */
 		err = create_roland_midi_quirk(chip, iface, driver, alts);
-		if (err < 0 && err != -ENODEV)
+		if (err != -ENODEV)
 			return err;
 		break;
 	}

commit 42d4ab832d843b5a512b373c86e70caa43a041c8
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Tue Jul 9 20:36:15 2013 +0200

    ALSA: usb-audio: fix regression for fixed stream quirk
    
    Commit 8f898e92aea2c24c7f379ee265d178f69ebb9c07 removed the redundant
    reads of bInterfaceProtocol from the descriptors, but introduced a
    regression to devices with quirks of type QUIRK_AUDIO_FIXED_ENDPOINT,
    since fp->protocol is not set in setup process.
    
    As a consequence, audio streams would not get initialized, as the
    following logs show:
    
    [   48.923043] setting usb interface 3:1
    [   48.923056] Creating new capture data endpoint #81
    [   48.923484] 4:3:1: cannot set freq 48000 to ep 0x81
    
    This patch sets fp->protocol in create_fixed_stream_quirk() and
    resolves the regression.
    
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 5b01330b8452..1bc45e71f1fe 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -129,6 +129,7 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 {
 	struct audioformat *fp;
 	struct usb_host_interface *alts;
+	struct usb_interface_descriptor *altsd;
 	int stream, err;
 	unsigned *rate_table = NULL;
 
@@ -166,6 +167,9 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 		return -EINVAL;
 	}
 	alts = &iface->altsetting[fp->altset_idx];
+	altsd = get_iface_desc(alts);
+	fp->protocol = altsd->bInterfaceProtocol;
+
 	if (fp->datainterval == 0)
 		fp->datainterval = snd_usb_parse_datainterval(chip, alts);
 	if (fp->maxpacksize == 0)

commit b1ce7ba619d9de53db7fad25f445ca9abc2b63df
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Apr 4 21:43:57 2013 +0200

    ALSA: usb-audio: claim autodetected PCM interfaces all at once
    
    snd_card_register() registers all devices newly added since the last
    call.  However, the playback/capture streams are handled as one ALSA
    device, so the second /dev device will not be registered if the PCM
    streams are added in two steps.
    
    QUIRK_AUTODETECT caused the probe callback to be called once for each
    interface, which triggered this problem.  Work around this by handling
    this like the composite quirk, i.e., autodetecting all other interfaces
    that might be used for PCM or MIDI.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 5363bcca9494..5b01330b8452 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -337,8 +337,7 @@ static int create_auto_midi_quirk(struct snd_usb_audio *chip,
 
 static int create_autodetect_quirk(struct snd_usb_audio *chip,
 				   struct usb_interface *iface,
-				   struct usb_driver *driver,
-				   const struct snd_usb_audio_quirk *quirk)
+				   struct usb_driver *driver)
 {
 	int err;
 
@@ -348,6 +347,41 @@ static int create_autodetect_quirk(struct snd_usb_audio *chip,
 	return err;
 }
 
+static int create_autodetect_quirks(struct snd_usb_audio *chip,
+				    struct usb_interface *iface,
+				    struct usb_driver *driver,
+				    const struct snd_usb_audio_quirk *quirk)
+{
+	int probed_ifnum = get_iface_desc(iface->altsetting)->bInterfaceNumber;
+	int ifcount, ifnum, err;
+
+	err = create_autodetect_quirk(chip, iface, driver);
+	if (err < 0)
+		return err;
+
+	/*
+	 * ALSA PCM playback/capture devices cannot be registered in two steps,
+	 * so we have to claim the other corresponding interface here.
+	 */
+	ifcount = chip->dev->actconfig->desc.bNumInterfaces;
+	for (ifnum = 0; ifnum < ifcount; ifnum++) {
+		if (ifnum == probed_ifnum || quirk->ifnum >= 0)
+			continue;
+		iface = usb_ifnum_to_if(chip->dev, ifnum);
+		if (!iface ||
+		    usb_interface_claimed(iface) ||
+		    get_iface_desc(iface->altsetting)->bInterfaceClass !=
+							USB_CLASS_VENDOR_SPEC)
+			continue;
+
+		err = create_autodetect_quirk(chip, iface, driver);
+		if (err >= 0)
+			usb_driver_claim_interface(driver, iface, (void *)-1L);
+	}
+
+	return 0;
+}
+
 /*
  * Create a stream for an Edirol UA-700/UA-25/UA-4FX interface.  
  * The only way to detect the sample rate is by looking at wMaxPacketSize.
@@ -476,7 +510,7 @@ int snd_usb_create_quirk(struct snd_usb_audio *chip,
 	static const quirk_func_t quirk_funcs[] = {
 		[QUIRK_IGNORE_INTERFACE] = ignore_interface_quirk,
 		[QUIRK_COMPOSITE] = create_composite_quirk,
-		[QUIRK_AUTODETECT] = create_autodetect_quirk,
+		[QUIRK_AUTODETECT] = create_autodetect_quirks,
 		[QUIRK_MIDI_STANDARD_INTERFACE] = create_any_midi_quirk,
 		[QUIRK_MIDI_FIXED_ENDPOINT] = create_any_midi_quirk,
 		[QUIRK_MIDI_YAMAHA] = create_any_midi_quirk,

commit aafe77cc45a595ca1d4536f2412ddf671ea9108c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Mar 31 23:43:12 2013 +0200

    ALSA: usb-audio: add support for many Roland/Yamaha devices
    
    Add quirks to detect the various vendor-specific descriptors used by
    Roland and Yamaha in most of their recent USB audio and MIDI devices.
    
    Together with the previous patch, this should add audio/MIDI support for
    the following USB devices:
    - Edirol motion dive .tokyo performance package
    - Roland MC-808 Synthesizer
    - Roland BK-7m Synthesizer
    - Roland VIMA JM-5/8 Synthesizer
    - Roland SP-555 Sequencer
    - Roland V-Synth GT Synthesizer
    - Roland Music Atelier AT-75/100/300/350C/500/800/900/900C Organ
    - Edirol V-Mixer M-200i/300/380/400/480/R-1000
    - BOSS GT-10B Effects Processor
    - Roland Fantom G6/G7/G8 Keyboard
    - Cakewalk Sonar V-Studio 20/100/700 Audio Interface
    - Roland GW-8 Keyboard
    - Roland AX-Synth Keyboard
    - Roland JUNO-Di/STAGE/Gi Keyboard
    - Roland VB-99 Effects Processor
    - Cakewalk UM-2G MIDI Interface
    - Roland A-500S Keyboard
    - Roland SD-50 Synthesizer
    - Roland OCTAPAD SPD-30 Controller
    - Roland Lucina AX-09 Synthesizer
    - BOSS BR-800 Digital Recorder
    - Roland DUO/TRI-CAPTURE (EX) Audio Interface
    - BOSS RC-300 Loop Station
    - Roland JUPITER-50/80 Keyboard
    - Roland R-26 Recorder
    - Roland SPD-SX Controller
    - BOSS JS-10 Audio Player
    - Roland TD-11/15/30 Drum Module
    - Roland A-49/88 Keyboard
    - Roland INTEGRA-7 Synthesizer
    - Roland R-88 Recorder
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 3879eae7e874..5363bcca9494 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -18,6 +18,7 @@
 #include <linux/slab.h>
 #include <linux/usb.h>
 #include <linux/usb/audio.h>
+#include <linux/usb/midi.h>
 
 #include <sound/control.h>
 #include <sound/core.h>
@@ -175,6 +176,178 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 	return 0;
 }
 
+static int create_auto_pcm_quirk(struct snd_usb_audio *chip,
+				 struct usb_interface *iface,
+				 struct usb_driver *driver)
+{
+	struct usb_host_interface *alts;
+	struct usb_interface_descriptor *altsd;
+	struct usb_endpoint_descriptor *epd;
+	struct uac1_as_header_descriptor *ashd;
+	struct uac_format_type_i_discrete_descriptor *fmtd;
+
+	/*
+	 * Most Roland/Yamaha audio streaming interfaces have more or less
+	 * standard descriptors, but older devices might lack descriptors, and
+	 * future ones might change, so ensure that we fail silently if the
+	 * interface doesn't look exactly right.
+	 */
+
+	/* must have a non-zero altsetting for streaming */
+	if (iface->num_altsetting < 2)
+		return -ENODEV;
+	alts = &iface->altsetting[1];
+	altsd = get_iface_desc(alts);
+
+	/* must have an isochronous endpoint for streaming */
+	if (altsd->bNumEndpoints < 1)
+		return -ENODEV;
+	epd = get_endpoint(alts, 0);
+	if (!usb_endpoint_xfer_isoc(epd))
+		return -ENODEV;
+
+	/* must have format descriptors */
+	ashd = snd_usb_find_csint_desc(alts->extra, alts->extralen, NULL,
+				       UAC_AS_GENERAL);
+	fmtd = snd_usb_find_csint_desc(alts->extra, alts->extralen, NULL,
+				       UAC_FORMAT_TYPE);
+	if (!ashd || ashd->bLength < 7 ||
+	    !fmtd || fmtd->bLength < 8)
+		return -ENODEV;
+
+	return create_standard_audio_quirk(chip, iface, driver, NULL);
+}
+
+static int create_yamaha_midi_quirk(struct snd_usb_audio *chip,
+				    struct usb_interface *iface,
+				    struct usb_driver *driver,
+				    struct usb_host_interface *alts)
+{
+	static const struct snd_usb_audio_quirk yamaha_midi_quirk = {
+		.type = QUIRK_MIDI_YAMAHA
+	};
+	struct usb_midi_in_jack_descriptor *injd;
+	struct usb_midi_out_jack_descriptor *outjd;
+
+	/* must have some valid jack descriptors */
+	injd = snd_usb_find_csint_desc(alts->extra, alts->extralen,
+				       NULL, USB_MS_MIDI_IN_JACK);
+	outjd = snd_usb_find_csint_desc(alts->extra, alts->extralen,
+					NULL, USB_MS_MIDI_OUT_JACK);
+	if (!injd && !outjd)
+		return -ENODEV;
+	if (injd && (injd->bLength < 5 ||
+		     (injd->bJackType != USB_MS_EMBEDDED &&
+		      injd->bJackType != USB_MS_EXTERNAL)))
+		return -ENODEV;
+	if (outjd && (outjd->bLength < 6 ||
+		      (outjd->bJackType != USB_MS_EMBEDDED &&
+		       outjd->bJackType != USB_MS_EXTERNAL)))
+		return -ENODEV;
+	return create_any_midi_quirk(chip, iface, driver, &yamaha_midi_quirk);
+}
+
+static int create_roland_midi_quirk(struct snd_usb_audio *chip,
+				    struct usb_interface *iface,
+				    struct usb_driver *driver,
+				    struct usb_host_interface *alts)
+{
+	static const struct snd_usb_audio_quirk roland_midi_quirk = {
+		.type = QUIRK_MIDI_ROLAND
+	};
+	u8 *roland_desc = NULL;
+
+	/* might have a vendor-specific descriptor <06 24 F1 02 ...> */
+	for (;;) {
+		roland_desc = snd_usb_find_csint_desc(alts->extra,
+						      alts->extralen,
+						      roland_desc, 0xf1);
+		if (!roland_desc)
+			return -ENODEV;
+		if (roland_desc[0] < 6 || roland_desc[3] != 2)
+			continue;
+		return create_any_midi_quirk(chip, iface, driver,
+					     &roland_midi_quirk);
+	}
+}
+
+static int create_std_midi_quirk(struct snd_usb_audio *chip,
+				 struct usb_interface *iface,
+				 struct usb_driver *driver,
+				 struct usb_host_interface *alts)
+{
+	struct usb_ms_header_descriptor *mshd;
+	struct usb_ms_endpoint_descriptor *msepd;
+
+	/* must have the MIDIStreaming interface header descriptor*/
+	mshd = (struct usb_ms_header_descriptor *)alts->extra;
+	if (alts->extralen < 7 ||
+	    mshd->bLength < 7 ||
+	    mshd->bDescriptorType != USB_DT_CS_INTERFACE ||
+	    mshd->bDescriptorSubtype != USB_MS_HEADER)
+		return -ENODEV;
+	/* must have the MIDIStreaming endpoint descriptor*/
+	msepd = (struct usb_ms_endpoint_descriptor *)alts->endpoint[0].extra;
+	if (alts->endpoint[0].extralen < 4 ||
+	    msepd->bLength < 4 ||
+	    msepd->bDescriptorType != USB_DT_CS_ENDPOINT ||
+	    msepd->bDescriptorSubtype != UAC_MS_GENERAL ||
+	    msepd->bNumEmbMIDIJack < 1 ||
+	    msepd->bNumEmbMIDIJack > 16)
+		return -ENODEV;
+
+	return create_any_midi_quirk(chip, iface, driver, NULL);
+}
+
+static int create_auto_midi_quirk(struct snd_usb_audio *chip,
+				  struct usb_interface *iface,
+				  struct usb_driver *driver)
+{
+	struct usb_host_interface *alts;
+	struct usb_interface_descriptor *altsd;
+	struct usb_endpoint_descriptor *epd;
+	int err;
+
+	alts = &iface->altsetting[0];
+	altsd = get_iface_desc(alts);
+
+	/* must have at least one bulk/interrupt endpoint for streaming */
+	if (altsd->bNumEndpoints < 1)
+		return -ENODEV;
+	epd = get_endpoint(alts, 0);
+	if (!usb_endpoint_xfer_bulk(epd) ||
+	    !usb_endpoint_xfer_int(epd))
+		return -ENODEV;
+
+	switch (USB_ID_VENDOR(chip->usb_id)) {
+	case 0x0499: /* Yamaha */
+		err = create_yamaha_midi_quirk(chip, iface, driver, alts);
+		if (err < 0 && err != -ENODEV)
+			return err;
+		break;
+	case 0x0582: /* Roland */
+		err = create_roland_midi_quirk(chip, iface, driver, alts);
+		if (err < 0 && err != -ENODEV)
+			return err;
+		break;
+	}
+
+	return create_std_midi_quirk(chip, iface, driver, alts);
+}
+
+static int create_autodetect_quirk(struct snd_usb_audio *chip,
+				   struct usb_interface *iface,
+				   struct usb_driver *driver,
+				   const struct snd_usb_audio_quirk *quirk)
+{
+	int err;
+
+	err = create_auto_pcm_quirk(chip, iface, driver);
+	if (err == -ENODEV)
+		err = create_auto_midi_quirk(chip, iface, driver);
+	return err;
+}
+
 /*
  * Create a stream for an Edirol UA-700/UA-25/UA-4FX interface.  
  * The only way to detect the sample rate is by looking at wMaxPacketSize.
@@ -303,9 +476,11 @@ int snd_usb_create_quirk(struct snd_usb_audio *chip,
 	static const quirk_func_t quirk_funcs[] = {
 		[QUIRK_IGNORE_INTERFACE] = ignore_interface_quirk,
 		[QUIRK_COMPOSITE] = create_composite_quirk,
+		[QUIRK_AUTODETECT] = create_autodetect_quirk,
 		[QUIRK_MIDI_STANDARD_INTERFACE] = create_any_midi_quirk,
 		[QUIRK_MIDI_FIXED_ENDPOINT] = create_any_midi_quirk,
 		[QUIRK_MIDI_YAMAHA] = create_any_midi_quirk,
+		[QUIRK_MIDI_ROLAND] = create_any_midi_quirk,
 		[QUIRK_MIDI_MIDIMAN] = create_any_midi_quirk,
 		[QUIRK_MIDI_NOVATION] = create_any_midi_quirk,
 		[QUIRK_MIDI_RAW_BYTES] = create_any_midi_quirk,

commit 8dd2b66d1a961231685a3bfe5937c85d846fbf5d
Merge: 126825e7ea27 24568ea4bef5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 18 16:24:31 2013 +0200

    Merge tag 'asoc-v3.10-2' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-next
    
    ASoC: More updates for v3.10
    
    The main additional change here is Lars-Peter's DMA work plus the
    platform conversions which have been tested - getting this in mainline
    will make life easier for development after the merge window.  These
    factor a large chunk of code out of the drivers for the platforms using
    dmaengine, greatly simplifying development.

commit 126825e7ea271ae8e3172e10ca1fc22c908b5385
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Apr 17 00:01:40 2013 +0800

    ALSA: snd-usb: add quirks handler for DSD streams
    
    Unfortunately, none of the UAC standards provides a way to identify DSD
    (Direct Stream Digital) formats. Hence, this patch adds a quirks
    handler to identify USB interfaces that are capable of handling DSD.
    
    That quirks handler can augment the already parsed formats bit-field,
    by any of the new SNDRV_PCM_FMTBIT_DSD_{U8_U16} and setting the dsd_dop
    flag in the audio format, if the driver should take care for the DOP
    byte stuffing.
    
    The only devices that are known to work with this are the ones with
    a 'Playback Designs' vendor id.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 175fbb7d334a..e564adb74852 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -916,3 +916,31 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 		mdelay(20);
 }
 
+/*
+ * snd_usb_interface_dsd_format_quirks() is called from format.c to
+ * augment the PCM format bit-field for DSD types. The UAC standards
+ * don't have a designated bit field to denote DSD-capable interfaces,
+ * hence all hardware that is known to support this format has to be
+ * listed here.
+ */
+u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,
+					struct audioformat *fp,
+					unsigned int sample_bytes)
+{
+	/* Playback Designs */
+	if (le16_to_cpu(chip->dev->descriptor.idVendor) == 0x23ba) {
+		switch (fp->altsetting) {
+		case 1:
+			fp->dsd_dop = true;
+			return SNDRV_PCM_FMTBIT_DSD_U16_LE;
+		case 2:
+			fp->dsd_bitrev = true;
+			return SNDRV_PCM_FMTBIT_DSD_U8;
+		case 3:
+			fp->dsd_bitrev = true;
+			return SNDRV_PCM_FMTBIT_DSD_U16_LE;
+		}
+	}
+
+	return 0;
+}

commit 1539d4f82ad534431cc67935e8e442ccf107d17d
Author: Calvin Owens <jcalvinowens@gmail.com>
Date:   Fri Apr 12 22:33:59 2013 -0500

    ALSA: usb: Add quirk for 192KHz recording on E-Mu devices
    
    When recording at 176.2KHz or 192Khz, the device adds a 32-bit length
    header to the capture packets, which obviously needs to be ignored for
    recording to work properly.
    
    Userspace expected:  L0 L1 L2 R0 R1 R2
    ...but actually got: R2 L0 L1 L2 R0 R1
    
    Also, the last byte of the length header being interpreted as L0 of
    the first sample caused spikes every 0.5ms, resulting in a loud 16KHz
    tone (about the highest 'B' on a piano) being present throughout
    captures.
    
    Tested at all sample rates on an E-Mu 0404USB, and tested for
    regressions on a generic USB headset.
    
    Signed-off-by: Calvin Owens <jcalvinowens@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 292798185afc..175fbb7d334a 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -854,6 +854,7 @@ static void set_format_emu_quirk(struct snd_usb_substream *subs,
 		break;
 	}
 	snd_emuusb_set_samplerate(subs->stream->chip, emu_samplerate_id);
+	subs->pkt_offset_adj = (emu_samplerate_id >= EMU_QUIRK_SR_176400HZ) ? 4 : 0;
 }
 
 void snd_usb_set_format_quirk(struct snd_usb_substream *subs,

commit 21bb5aafce4350e243f9be3d981c0beb2e2c5ab4
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Apr 10 00:56:03 2013 +0800

    ALSA: snd-usb: Playback Design: use usb_set_inferface quirk from more locations
    
    It turns out the devices from Playback Design need the delay quirk
    after usb_set_interface from clocks.c as well. Make it a proper
    quirks function and factor out the code to quirks.c.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index a2ac004bbd9a..292798185afc 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -892,6 +892,16 @@ void snd_usb_endpoint_start_quirk(struct snd_usb_endpoint *ep)
 		ep->skip_packets = 16;
 }
 
+void snd_usb_set_interface_quirk(struct usb_device *dev)
+{
+	/*
+	 * "Playback Design" products need a 50ms delay after setting the
+	 * USB interface.
+	 */
+	if (le16_to_cpu(dev->descriptor.idVendor) == 0x23ba)
+		mdelay(50);
+}
+
 void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 			   __u8 request, __u8 requesttype, __u16 value,
 			   __u16 index, void *data, __u16 size)

commit 889d66848b12d891248b03abcb2a42047f8e172a
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Fri Apr 5 20:49:46 2013 +0200

    ALSA: usb-audio: fix endianness bug in snd_nativeinstruments_*
    
    The usb_control_msg() function expects __u16 types and performs
    the endianness conversions by itself.
    However, in three places, a conversion is performed before it is
    handed over to usb_control_msg(), which leads to a double conversion
    (= no conversion):
    * snd_usb_nativeinstruments_boot_quirk()
    * snd_nativeinstruments_control_get()
    * snd_nativeinstruments_control_put()
    
    Caught by sparse:
    
    sound/usb/mixer_quirks.c:512:38: warning: incorrect type in argument 6 (different base types)
    sound/usb/mixer_quirks.c:512:38:    expected unsigned short [unsigned] [usertype] index
    sound/usb/mixer_quirks.c:512:38:    got restricted __le16 [usertype] <noident>
    sound/usb/mixer_quirks.c:543:35: warning: incorrect type in argument 5 (different base types)
    sound/usb/mixer_quirks.c:543:35:    expected unsigned short [unsigned] [usertype] value
    sound/usb/mixer_quirks.c:543:35:    got restricted __le16 [usertype] <noident>
    sound/usb/mixer_quirks.c:543:56: warning: incorrect type in argument 6 (different base types)
    sound/usb/mixer_quirks.c:543:56:    expected unsigned short [unsigned] [usertype] index
    sound/usb/mixer_quirks.c:543:56:    got restricted __le16 [usertype] <noident>
    sound/usb/quirks.c:502:35: warning: incorrect type in argument 5 (different base types)
    sound/usb/quirks.c:502:35:    expected unsigned short [unsigned] [usertype] value
    sound/usb/quirks.c:502:35:    got restricted __le16 [usertype] <noident>
    
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Acked-by: Daniel Mack <zonque@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 5325a3869bb7..9c5ab22358b1 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -486,7 +486,7 @@ static int snd_usb_nativeinstruments_boot_quirk(struct usb_device *dev)
 {
 	int ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				  0xaf, USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-				  cpu_to_le16(1), 0, NULL, 0, 1000);
+				  1, 0, NULL, 0, 1000);
 
 	if (ret < 0)
 		return ret;

commit 59ea586f54f27fde1202214f1525713356a44918
Author: Mark Hills <mark@xwax.org>
Date:   Sun Mar 17 11:07:54 2013 +0000

    ALSA: usb-audio: Trust fields given in the quirk
    
    The maxpacksize field is given in some quirks, but it gets ignored (in
    favour of wMaxPacketSize from the first endpoint.) This patch favours
    the one in the quirk.
    
    Digidesign Mbox and Mbox 2 are the only affected quirks and the devices
    are assumed to be working without this patch. So for safety against the
    values in the quirk being incorrect, remove them.
    
    The datainterval is also ignored but there are not currently any quirks
    which choose to override this.
    
    Cc: Damien Zammit <damien@zamaudio.com>
    Cc: Chris J Arges <christopherarges@gmail.com>
    Signed-off-by: Mark Hills <mark@xwax.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 7c4fe5a634f0..a2ac004bbd9a 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -165,8 +165,10 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 		return -EINVAL;
 	}
 	alts = &iface->altsetting[fp->altset_idx];
-	fp->datainterval = snd_usb_parse_datainterval(chip, alts);
-	fp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);
+	if (fp->datainterval == 0)
+		fp->datainterval = snd_usb_parse_datainterval(chip, alts);
+	if (fp->maxpacksize == 0)
+		fp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);
 	usb_set_interface(chip->dev, fp->iface, 0);
 	snd_usb_init_pitch(chip, fp->iface, alts, fp);
 	snd_usb_init_sample_rate(chip, fp->iface, alts, fp, fp->rate_max);

commit 5e212332cc7eed0ffbf91fbe5bab6e2a44b83de6
Author: Mark Hills <mark@xwax.org>
Date:   Sun Mar 17 11:07:53 2013 +0000

    ALSA: usb-audio: Playback and MIDI support for Novation Twitch DJ controller
    
    The hardware also has a PCM capture device which is not implemented in
    this patch.
    
    It may be possible to generalise this to Saffire 6 USB support and some
    of the other Focusrite interfaces, but as I don't have access to these
    devices we should wait until capture support is working first.
    
    Capture support is not implemented because the code assumes the endpoint
    to have its own interface (instead, it shares the interface with playback)
    and some thought will be needed to lift this limitation.
    
    Signed-off-by: Mark Hills <mark@xwax.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 5325a3869bb7..7c4fe5a634f0 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -445,6 +445,17 @@ static int snd_usb_cm6206_boot_quirk(struct usb_device *dev)
 	return err;
 }
 
+/*
+ * Novation Twitch DJ controller
+ */
+static int snd_usb_twitch_boot_quirk(struct usb_device *dev)
+{
+	/* preemptively set up the device because otherwise the
+	 * raw MIDI endpoints are not active */
+	usb_set_interface(dev, 0, 1);
+	return 0;
+}
+
 /*
  * This call will put the synth in "USB send" mode, i.e it will send MIDI
  * messages through USB (this is disabled at startup). The synth will
@@ -746,6 +757,10 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
 		/* Digidesign Mbox 2 */
 		return snd_usb_mbox2_boot_quirk(dev);
 
+	case USB_ID(0x1235, 0x0018):
+		/* Focusrite Novation Twitch */
+		return snd_usb_twitch_boot_quirk(dev);
+
 	case USB_ID(0x133e, 0x0815):
 		/* Access Music VirusTI Desktop */
 		return snd_usb_accessmusic_boot_quirk(dev);

commit 4909a0caabb8b4352efcea223e58b86f8bc1f98b
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Sun Feb 17 14:33:04 2013 +0100

    ALSA: usb/quirks, fix out-of-bounds access
    
    bootresponse in snd_usb_mbox2_boot_quirk is only 12 (decimal) u8's
    long, but i9s passed to snd_usb_ctl_msg as it would be 0x12 (hexa)
    long. Fix that by having proper size of the array, i.e. 0x12.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 7d7ad0b0620e..5325a3869bb7 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -533,7 +533,7 @@ static int snd_usb_mbox2_boot_quirk(struct usb_device *dev)
 {
 	struct usb_host_config *config = dev->actconfig;
 	int err;
-	u8 bootresponse[12];
+	u8 bootresponse[0x12];
 	int fwsize;
 	int count;
 

commit e9a25e04b845aade311aaa268a696c5c4ff3eece
Author: Matt Gruskin <matthew.gruskin@gmail.com>
Date:   Sat Feb 9 12:56:35 2013 -0500

    ALSA: usb-audio: add support for M-Audio FT C600
    
    Adds quirks and mixer support for the M-Audio Fast Track C600 USB
    audio interface. This device is very similar to the C400 - the C600
    simply has some more inputs and outputs, so the existing C400 support
    is extended to support this device as well.
    
    Signed-off-by: Matt Gruskin <matthew.gruskin@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 2c971858d6b7..7d7ad0b0620e 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -863,13 +863,14 @@ void snd_usb_endpoint_start_quirk(struct snd_usb_endpoint *ep)
 		ep->skip_packets = 4;
 
 	/*
-	 * M-Audio Fast Track C400 - when packets are not skipped, real world
-	 * latency varies by approx. +/- 50 frames (at 96KHz) each time the
-	 * stream is (re)started. When skipping packets 16 at endpoint start
-	 * up, the real world latency is stable within +/- 1 frame (also
+	 * M-Audio Fast Track C400/C600 - when packets are not skipped, real
+	 * world latency varies by approx. +/- 50 frames (at 96KHz) each time
+	 * the stream is (re)started. When skipping packets 16 at endpoint
+	 * start up, the real world latency is stable within +/- 1 frame (also
 	 * across power cycles).
 	 */
-	if (ep->chip->usb_id == USB_ID(0x0763, 0x2030) &&
+	if ((ep->chip->usb_id == USB_ID(0x0763, 0x2030) ||
+	     ep->chip->usb_id == USB_ID(0x0763, 0x2031)) &&
 	    ep->type == SND_USB_ENDPOINT_TYPE_DATA)
 		ep->skip_packets = 16;
 }

commit 83e3acd494f47dc5dababfe6156c6178aca5c3a9
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Sun Jan 13 23:02:03 2013 +0100

    ALSA: usb-audio: M-Audio FT C400 skip packet quirk
    
    Attain constant real-world latency by skipping 16 data packets.
    The number of packets to be skipped was found by trial and error.
    
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index e71fc8bc3a70..2c971858d6b7 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -861,6 +861,17 @@ void snd_usb_endpoint_start_quirk(struct snd_usb_endpoint *ep)
 	if ((le16_to_cpu(ep->chip->dev->descriptor.idVendor) == 0x23ba) &&
 	    ep->type == SND_USB_ENDPOINT_TYPE_SYNC)
 		ep->skip_packets = 4;
+
+	/*
+	 * M-Audio Fast Track C400 - when packets are not skipped, real world
+	 * latency varies by approx. +/- 50 frames (at 96KHz) each time the
+	 * stream is (re)started. When skipping packets 16 at endpoint start
+	 * up, the real world latency is stable within +/- 1 frame (also
+	 * across power cycles).
+	 */
+	if (ep->chip->usb_id == USB_ID(0x0763, 0x2030) &&
+	    ep->type == SND_USB_ENDPOINT_TYPE_DATA)
+		ep->skip_packets = 16;
 }
 
 void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,

commit b98ae2729dea161edc96c9d177459b6c28bcbba5
Author: David Henningsson <david.henningsson@canonical.com>
Date:   Fri Jan 4 17:02:18 2013 +0100

    ALSA: usb - fix race in creation of M-Audio Fast track pro driver
    
    A patch in the 3.2 kernel caused regression with hotplugging the
    M-Audio Fast track pro, or sound after suspend. I don't have the
    device so I haven't done a full analysis, but it seems userspace
    (both udev and pulseaudio) got confused when a card was created,
    immediately destroyed, and then created again.
    
    However, at least one person in the bug report (martin djfun)
    reports that this patch resolves the issue for him. It also leaves
    a message in the log:
    "snd-usb-audio: probe of 1-1.1:1.1 failed with error -5" which is
    a bit misleading. It is better than non-working audio, but maybe
    there's a more elegant solution?
    
    BugLink: https://bugs.launchpad.net/bugs/1095315
    Signed-off-by: David Henningsson <david.henningsson@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index acc12f004c23..e71fc8bc3a70 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -387,11 +387,13 @@ static int snd_usb_fasttrackpro_boot_quirk(struct usb_device *dev)
 		 * rules
 		 */
 		err = usb_driver_set_configuration(dev, 2);
-		if (err < 0) {
+		if (err < 0)
 			snd_printdd("error usb_driver_set_configuration: %d\n",
 				    err);
-			return -ENODEV;
-		}
+		/* Always return an error, so that we stop creating a device
+		   that will just be destroyed and recreated with a new
+		   configuration */
+		return -ENODEV;
 	} else
 		snd_printk(KERN_INFO "usb-audio: Fast Track Pro config OK\n");
 

commit b7b435e81b7228af68b5d3bef277fce10100b369
Author: Damien Zammit <damien@zamaudio.com>
Date:   Fri Jan 4 09:51:44 2013 +0100

    ALSA: usb-audio: Fix kernel panic of Digidesign Mbox2 quirk
    
    This patch is based on 3.8-rc1. It fixes two things:
    1) A kernel panic caused by incorrect allocation of a u8 variable
       "bootresponse".
    2) A noisy dmesg (urb status -32) caused by broken pipe to an
       invalid midi endpoint.
    
    It is also a little cleaner because there is no need for a new
    QUIRK_MIDI type as suggested by kernel developers, since the device
    follows exactly the MIDIMAN protocol.
    
    Signed-off-by: Damien Zammit <damien@zamaudio.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index f104c68fe1e0..acc12f004c23 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -306,7 +306,6 @@ int snd_usb_create_quirk(struct snd_usb_audio *chip,
 		[QUIRK_MIDI_YAMAHA] = create_any_midi_quirk,
 		[QUIRK_MIDI_MIDIMAN] = create_any_midi_quirk,
 		[QUIRK_MIDI_NOVATION] = create_any_midi_quirk,
-		[QUIRK_MIDI_MBOX2] = create_any_midi_quirk,
 		[QUIRK_MIDI_RAW_BYTES] = create_any_midi_quirk,
 		[QUIRK_MIDI_EMAGIC] = create_any_midi_quirk,
 		[QUIRK_MIDI_CME] = create_any_midi_quirk,
@@ -528,11 +527,11 @@ static void mbox2_setup_48_24_magic(struct usb_device *dev)
 #define MBOX2_BOOT_LOADING     0x01 /* Hard coded into the device */
 #define MBOX2_BOOT_READY       0x02 /* Hard coded into the device */
 
-int snd_usb_mbox2_boot_quirk(struct usb_device *dev)
+static int snd_usb_mbox2_boot_quirk(struct usb_device *dev)
 {
 	struct usb_host_config *config = dev->actconfig;
 	int err;
-	u8 bootresponse;
+	u8 bootresponse[12];
 	int fwsize;
 	int count;
 
@@ -546,20 +545,20 @@ int snd_usb_mbox2_boot_quirk(struct usb_device *dev)
 	snd_printd("usb-audio: Sending Digidesign Mbox 2 boot sequence...\n");
 
 	count = 0;
-	bootresponse = MBOX2_BOOT_LOADING;
-	while ((bootresponse == MBOX2_BOOT_LOADING) && (count < 10)) {
+	bootresponse[0] = MBOX2_BOOT_LOADING;
+	while ((bootresponse[0] == MBOX2_BOOT_LOADING) && (count < 10)) {
 		msleep(500); /* 0.5 second delay */
 		snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),
 			/* Control magic - load onboard firmware */
 			0x85, 0xc0, 0x0001, 0x0000, &bootresponse, 0x0012);
-		if (bootresponse == MBOX2_BOOT_READY)
+		if (bootresponse[0] == MBOX2_BOOT_READY)
 			break;
 		snd_printd("usb-audio: device not ready, resending boot sequence...\n");
 		count++;
 	}
 
-	if (bootresponse != MBOX2_BOOT_READY) {
-		snd_printk(KERN_ERR "usb-audio: Unknown bootresponse=%d, or timed out, ignoring device.\n", bootresponse);
+	if (bootresponse[0] != MBOX2_BOOT_READY) {
+		snd_printk(KERN_ERR "usb-audio: Unknown bootresponse=%d, or timed out, ignoring device.\n", bootresponse[0]);
 		return -ENODEV;
 	}
 
@@ -660,7 +659,6 @@ static int audiophile_skip_setting_quirk(struct snd_usb_audio *chip,
 	return 0; /* keep this altsetting */
 }
 
-
 static int fasttrackpro_skip_setting_quirk(struct snd_usb_audio *chip,
 					   int iface, int altno)
 {

commit 03c850ec327c42a97e44c448b75983e12da417d9
Merge: 85d5b70d8a06 cb99864d40e4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 20 07:52:13 2012 -0800

    Merge tag 'sound-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound fixes from Takashi Iwai:
     "This update contains overall only driver-specific fixes.  Slightly
      large LOC are seen in usb-audio driver for a couple of new device
      quirks and cs42l71 ASoC driver for enhanced features.  The others are
      a few small (regression) fixes HD-audio, and yet other small / trival
      ASoC fixes."
    
    * tag 'sound-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound:
      ALSA: usb-audio: Support for Digidesign Mbox 2 USB sound card:
      ALSA: HDA: Fix sound resume hang
      ALSA: hda - bug fix for invalid connection list of Haswell HDMI codec pins
      ALSA: hda - Fix the wrong pincaps set in ALC861VD dallas/hp fixup
      ALSA: hda - Set codec->single_adc_amp flag for Realtek codecs
      ASoC: atmel-ssc: change disable to disable in dts node
      ASoC: Prevent pop_wait overwrite
      ALSA: usb-audio: ignore-quirk for HP Wireless Audio
      ALSA: hda - Always turn on pins for HDMI/DP
      ALSA: hda - Fix pin configuration of HP Pavilion dv7
      ASoC: core: Fix splitting of log messages
      ASoC: cs42l73: Change VSPIN/VSPOUT to VSPINOUT
      ASoC: cs42l73: Add DAPM events for power down.
      ASoC: cs42l73: Add DMIC's as DAPM inputs.
      ASoC: sigmadsp: Fix endianness conversion issue
      ASoC: tpa6130a2: Use devm_* APIs

commit cb99864d40e46dea9c2aa3eaa97517b776f91024
Author: Damien Zammit <damien@zamaudio.com>
Date:   Wed Dec 19 11:27:22 2012 +0100

    ALSA: usb-audio: Support for Digidesign Mbox 2 USB sound card:
    
    This patch is the result of a lot of trial and error, since there are no specs
    available for the device.
    
    Full duplex support is provided, i.e. playback and recording in stereo.
    The format is hardcoded at 48000Hz @ 24 bit, which is the maximum that the
    device supports.  Also, MIDI in and MIDI out both work.
    
    Users will notice that the S/PDIF light also flashes when playback or recording
    is active.  I believe this means that S/PDIF input/output is simultaneously
    activated with the analogue i/o during use.
    But this particular functionality remains untested.
    
    Note that this particular version of the patch is so far untested on the
    physical hardware because I have not compiled a full kernel with the changes.
    However, extensive testing has been done by many users of the hardware
    who believe other versions of my patch have worked since circa 2009.
    
    [Modified to make a function static by tiwai]
    
    Signed-off-by: Damien Zammit <damien@zamaudio.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 0f58b4b6d702..203d72b8a037 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -306,6 +306,7 @@ int snd_usb_create_quirk(struct snd_usb_audio *chip,
 		[QUIRK_MIDI_YAMAHA] = create_any_midi_quirk,
 		[QUIRK_MIDI_MIDIMAN] = create_any_midi_quirk,
 		[QUIRK_MIDI_NOVATION] = create_any_midi_quirk,
+		[QUIRK_MIDI_MBOX2] = create_any_midi_quirk,
 		[QUIRK_MIDI_RAW_BYTES] = create_any_midi_quirk,
 		[QUIRK_MIDI_EMAGIC] = create_any_midi_quirk,
 		[QUIRK_MIDI_CME] = create_any_midi_quirk,
@@ -497,6 +498,92 @@ static int snd_usb_nativeinstruments_boot_quirk(struct usb_device *dev)
 	return -EAGAIN;
 }
 
+static void mbox2_setup_48_24_magic(struct usb_device *dev)
+{
+	u8 srate[3];
+	u8 temp[12];
+
+	/* Choose 48000Hz permanently */
+	srate[0] = 0x80;
+	srate[1] = 0xbb;
+	srate[2] = 0x00;
+
+	/* Send the magic! */
+	snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),
+		0x01, 0x22, 0x0100, 0x0085, &temp, 0x0003);
+	snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),
+		0x81, 0xa2, 0x0100, 0x0085, &srate, 0x0003);
+	snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),
+		0x81, 0xa2, 0x0100, 0x0086, &srate, 0x0003);
+	snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0),
+		0x81, 0xa2, 0x0100, 0x0003, &srate, 0x0003);
+	return;
+}
+
+/* Digidesign Mbox 2 needs to load firmware onboard
+ * and driver must wait a few seconds for initialisation.
+ */
+
+#define MBOX2_FIRMWARE_SIZE    646
+#define MBOX2_BOOT_LOADING     0x01 /* Hard coded into the device */
+#define MBOX2_BOOT_READY       0x02 /* Hard coded into the device */
+
+int snd_usb_mbox2_boot_quirk(struct usb_device *dev)
+{
+	struct usb_host_config *config = dev->actconfig;
+	int err;
+	u8 bootresponse;
+	int fwsize;
+	int count;
+
+	fwsize = le16_to_cpu(get_cfg_desc(config)->wTotalLength);
+
+	if (fwsize != MBOX2_FIRMWARE_SIZE) {
+		snd_printk(KERN_ERR "usb-audio: Invalid firmware size=%d.\n", fwsize);
+		return -ENODEV;
+	}
+
+	snd_printd("usb-audio: Sending Digidesign Mbox 2 boot sequence...\n");
+
+	count = 0;
+	bootresponse = MBOX2_BOOT_LOADING;
+	while ((bootresponse == MBOX2_BOOT_LOADING) && (count < 10)) {
+		msleep(500); /* 0.5 second delay */
+		snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),
+			/* Control magic - load onboard firmware */
+			0x85, 0xc0, 0x0001, 0x0000, &bootresponse, 0x0012);
+		if (bootresponse == MBOX2_BOOT_READY)
+			break;
+		snd_printd("usb-audio: device not ready, resending boot sequence...\n");
+		count++;
+	}
+
+	if (bootresponse != MBOX2_BOOT_READY) {
+		snd_printk(KERN_ERR "usb-audio: Unknown bootresponse=%d, or timed out, ignoring device.\n", bootresponse);
+		return -ENODEV;
+	}
+
+	snd_printdd("usb-audio: device initialised!\n");
+
+	err = usb_get_descriptor(dev, USB_DT_DEVICE, 0,
+		&dev->descriptor, sizeof(dev->descriptor));
+	config = dev->actconfig;
+	if (err < 0)
+		snd_printd("error usb_get_descriptor: %d\n", err);
+
+	err = usb_reset_configuration(dev);
+	if (err < 0)
+		snd_printd("error usb_reset_configuration: %d\n", err);
+	snd_printdd("mbox2_boot: new boot length = %d\n",
+		le16_to_cpu(get_cfg_desc(config)->wTotalLength));
+
+	mbox2_setup_48_24_magic(dev);
+
+	snd_printk(KERN_INFO "usb-audio: Digidesign Mbox 2: 24bit 48kHz");
+
+	return 0; /* Successful boot */
+}
+
 /*
  * Setup quirks
  */
@@ -655,6 +742,10 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
 	case USB_ID(0x0ccd, 0x00b1): /* Terratec Aureon 7.1 USB */
 		return snd_usb_cm6206_boot_quirk(dev);
 
+	case USB_ID(0x0dba, 0x3000):
+		/* Digidesign Mbox 2 */
+		return snd_usb_mbox2_boot_quirk(dev);
+
 	case USB_ID(0x133e, 0x0815):
 		/* Access Music VirusTI Desktop */
 		return snd_usb_accessmusic_boot_quirk(dev);

commit 48fc7f7e787dd65ffe88521bce31f4062ba273eb
Author: Adam Buchbinder <adam.buchbinder@gmail.com>
Date:   Wed Sep 19 21:48:00 2012 -0400

    Fix misspellings of "whether" in comments.
    
    "Whether" is misspelled in various comments across the tree; this
    fixes them. No code changes.
    
    Signed-off-by: Adam Buchbinder <adam.buchbinder@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 0f58b4b6d702..007fcecdf5cd 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -675,7 +675,7 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
  */
 int snd_usb_is_big_endian_format(struct snd_usb_audio *chip, struct audioformat *fp)
 {
-	/* it depends on altsetting wether the device is big-endian or not */
+	/* it depends on altsetting whether the device is big-endian or not */
 	switch (chip->usb_id) {
 	case USB_ID(0x0763, 0x2001): /* M-Audio Quattro: captured data only */
 		if (fp->altsetting == 2 || fp->altsetting == 3 ||

commit 2b58fd5b3193fd3af3d15114d95706087d25a7fe
Author: Daniel Mack <zonque@gmail.com>
Date:   Tue Sep 4 10:23:07 2012 +0200

    ALSA: snd-usb: Add quirks for Playback Designs devices
    
    Playback Designs' USB devices have some hardware limitations on their
    USB interface. In particular:
    
     - They need a 20ms delay after each class compliant request as the
       hardware ACKs the USB packets before the device is actually ready
       for the next command. Sending data immediately will result in buffer
       overflows in the hardware.
     - The devices send bogus feedback data at the start of each stream
       which confuse the feedback format auto-detection.
    
    This patch introduces a new quirks hook that is called after each
    control packet and which adds a delay for all devices that match
    Playback Designs' USB VID for now.
    
    In addition, it adds a counter to snd_usb_endpoint to drop received
    packets on the floor. Another new quirks function that is called once
    an endpoint is started initializes that counter for these devices on
    their sync endpoint.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Reported-and-tested-by: Andreas Koch <andreas@akdesigninc.com>
    Supported-by: Demian Martin <demianm_1@yahoo.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 27817266867a..0f58b4b6d702 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -761,3 +761,27 @@ void snd_usb_set_format_quirk(struct snd_usb_substream *subs,
 	}
 }
 
+void snd_usb_endpoint_start_quirk(struct snd_usb_endpoint *ep)
+{
+	/*
+	 * "Playback Design" products send bogus feedback data at the start
+	 * of the stream. Ignore them.
+	 */
+	if ((le16_to_cpu(ep->chip->dev->descriptor.idVendor) == 0x23ba) &&
+	    ep->type == SND_USB_ENDPOINT_TYPE_SYNC)
+		ep->skip_packets = 4;
+}
+
+void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
+			   __u8 request, __u8 requesttype, __u16 value,
+			   __u16 index, void *data, __u16 size)
+{
+	/*
+	 * "Playback Design" products need a 20ms delay after each
+	 * class compliant request
+	 */
+	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x23ba) &&
+	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
+		mdelay(20);
+}
+

commit 8866f405efd4171f9d9c91901d2dd02f01bacb60
Author: Xi Wang <xi.wang@gmail.com>
Date:   Tue Feb 14 05:18:48 2012 -0500

    ALSA: usb-audio: avoid integer overflow in create_fixed_stream_quirk()
    
    A malicious USB device could feed in a large nr_rates value.  This would
    cause the subsequent call to kmemdup() to allocate a smaller buffer than
    expected, leading to out-of-bounds access.
    
    This patch validates the nr_rates value and reuses the limit introduced
    in commit 4fa0e81b ("ALSA: usb-audio: fix possible hang and overflow
    in parse_uac2_sample_rate_range()").
    
    Signed-off-by: Xi Wang <xi.wang@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index a3ddac0deffd..27817266867a 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -132,10 +132,14 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 	unsigned *rate_table = NULL;
 
 	fp = kmemdup(quirk->data, sizeof(*fp), GFP_KERNEL);
-	if (! fp) {
+	if (!fp) {
 		snd_printk(KERN_ERR "cannot memdup\n");
 		return -ENOMEM;
 	}
+	if (fp->nr_rates > MAX_NR_RATES) {
+		kfree(fp);
+		return -EINVAL;
+	}
 	if (fp->nr_rates > 0) {
 		rate_table = kmemdup(fp->rate_table,
 				     sizeof(int) * fp->nr_rates, GFP_KERNEL);

commit 43df2a57b773596cd0bdd2316889ff9653121015
Author: Thomas Meyer <thomas@m3y3r.de>
Date:   Thu Nov 10 19:38:43 2011 +0100

    ALSA: usb-audio: Use kmemdup rather than duplicating its implementation
    
    Use kmemdup rather than duplicating its implementation
    
    The semantic patch that makes this change is available
    in scripts/coccinelle/api/memdup.cocci.
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 2e5bc7344026..a3ddac0deffd 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -137,12 +137,12 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 		return -ENOMEM;
 	}
 	if (fp->nr_rates > 0) {
-		rate_table = kmalloc(sizeof(int) * fp->nr_rates, GFP_KERNEL);
+		rate_table = kmemdup(fp->rate_table,
+				     sizeof(int) * fp->nr_rates, GFP_KERNEL);
 		if (!rate_table) {
 			kfree(fp);
 			return -ENOMEM;
 		}
-		memcpy(rate_table, fp->rate_table, sizeof(int) * fp->nr_rates);
 		fp->rate_table = rate_table;
 	}
 
@@ -224,10 +224,9 @@ static int create_uaxx_quirk(struct snd_usb_audio *chip,
 	if (altsd->bNumEndpoints != 1)
 		return -ENXIO;
 
-	fp = kmalloc(sizeof(*fp), GFP_KERNEL);
+	fp = kmemdup(&ua_format, sizeof(*fp), GFP_KERNEL);
 	if (!fp)
 		return -ENOMEM;
-	memcpy(fp, &ua_format, sizeof(*fp));
 
 	fp->iface = altsd->bInterfaceNumber;
 	fp->endpoint = get_endpoint(alts, 0)->bEndpointAddress;

commit 17d900c4a1b50bc191b3ca58cbd78acc04a1c5b3
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 26 21:15:27 2011 +0200

    ALSA: usb-audio: increase control transfer timeout
    
    There are certain devices that are reportedly so slow that they need
    more than 100 ms to handle control transfers.  Therefore, increase the
    timeout in mixer(_quirks).c to 1000 ms.
    
    The timeout parameter of snd_usb_ctl_msg() is now constant, so we can
    drop it.
    
    Reported-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 556edea28b90..2e5bc7344026 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -340,7 +340,7 @@ static int snd_usb_extigy_boot_quirk(struct usb_device *dev, struct usb_interfac
 		snd_printdd("sending Extigy boot sequence...\n");
 		/* Send message to force it to reconnect with full interface. */
 		err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev,0),
-				      0x10, 0x43, 0x0001, 0x000a, NULL, 0, 1000);
+				      0x10, 0x43, 0x0001, 0x000a, NULL, 0);
 		if (err < 0) snd_printdd("error sending boot message: %d\n", err);
 		err = usb_get_descriptor(dev, USB_DT_DEVICE, 0,
 				&dev->descriptor, sizeof(dev->descriptor));
@@ -361,11 +361,11 @@ static int snd_usb_audigy2nx_boot_quirk(struct usb_device *dev)
 
 	snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), 0x2a,
 			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_OTHER,
-			0, 0, &buf, 1, 1000);
+			0, 0, &buf, 1);
 	if (buf == 0) {
 		snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), 0x29,
 				USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,
-				1, 2000, NULL, 0, 1000);
+				1, 2000, NULL, 0);
 		return -ENODEV;
 	}
 	return 0;
@@ -408,7 +408,7 @@ static int snd_usb_cm106_write_int_reg(struct usb_device *dev, int reg, u16 valu
 	buf[3] = reg;
 	return snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), USB_REQ_SET_CONFIGURATION,
 			       USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,
-			       0, 0, &buf, 4, 1000);
+			       0, 0, &buf, 4);
 }
 
 static int snd_usb_cm106_boot_quirk(struct usb_device *dev)

commit e8e8babf561c9560f37b9bd80407ebaf90ad2ca4
Author: Daniel Mack <zonque@gmail.com>
Date:   Mon Sep 12 18:54:12 2011 +0200

    ALSA: snd-usb: re-order code
    
    Move code from endpoint.c into a new file called stream.c and rename
    functions so that their names actually reflect what they're doing.
    
    This way, endpoint.c will be available to functions that hold all the
    endpoint logic.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index cf61b0340026..556edea28b90 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -34,6 +34,7 @@
 #include "endpoint.h"
 #include "pcm.h"
 #include "clock.h"
+#include "stream.h"
 
 /*
  * handle the quirks for the contained interfaces
@@ -106,7 +107,7 @@ static int create_standard_audio_quirk(struct snd_usb_audio *chip,
 
 	alts = &iface->altsetting[0];
 	altsd = get_iface_desc(alts);
-	err = snd_usb_parse_audio_endpoints(chip, altsd->bInterfaceNumber);
+	err = snd_usb_parse_audio_interface(chip, altsd->bInterfaceNumber);
 	if (err < 0) {
 		snd_printk(KERN_ERR "cannot setup if %d: error %d\n",
 			   altsd->bInterfaceNumber, err);
@@ -147,7 +148,7 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 
 	stream = (fp->endpoint & USB_DIR_IN)
 		? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
-	err = snd_usb_add_audio_endpoint(chip, stream, fp);
+	err = snd_usb_add_audio_stream(chip, stream, fp);
 	if (err < 0) {
 		kfree(fp);
 		kfree(rate_table);
@@ -254,7 +255,7 @@ static int create_uaxx_quirk(struct snd_usb_audio *chip,
 
 	stream = (fp->endpoint & USB_DIR_IN)
 		? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
-	err = snd_usb_add_audio_endpoint(chip, stream, fp);
+	err = snd_usb_add_audio_stream(chip, stream, fp);
 	if (err < 0) {
 		kfree(fp);
 		return err;

commit 1ef0e0a05345b7411bdabbfca27f58bd33dcc7c8
Author: Kristian Amlie <kristian@amlie.name>
Date:   Fri Aug 26 13:19:49 2011 +0200

    ALSA: usb-audio: add Starr Labs USB MIDI support
    
    Add support for Starr Labs USB MIDI devices such as the Z7S, which are
    based on an FTDI serial UART chip.
    
    Based on a patch by Daniel Mack.
    
    Signed-off-by: Kristian Amlie <kristian@amlie.name>
    Acked-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 81e07d842581..cf61b0340026 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -306,6 +306,7 @@ int snd_usb_create_quirk(struct snd_usb_audio *chip,
 		[QUIRK_MIDI_EMAGIC] = create_any_midi_quirk,
 		[QUIRK_MIDI_CME] = create_any_midi_quirk,
 		[QUIRK_MIDI_AKAI] = create_any_midi_quirk,
+		[QUIRK_MIDI_FTDI] = create_any_midi_quirk,
 		[QUIRK_AUDIO_STANDARD_INTERFACE] = create_standard_audio_quirk,
 		[QUIRK_AUDIO_FIXED_ENDPOINT] = create_fixed_stream_quirk,
 		[QUIRK_AUDIO_EDIROL_UAXX] = create_uaxx_quirk,

commit dac8f847c48adeeece5aba57600d08d2499d39b2
Author: Daniel Mack <zonque@gmail.com>
Date:   Sat Aug 6 00:23:18 2011 +0200

    ALSA: snd-usb: Fix uninitialized variable usage
    
    Purely cosmetic, but fixes the following build warning.
    
      CC [M]  sound/usb/quirks.o
    sound/usb/quirks.c: In function snd_usb_apply_boot_quirk:
    sound/usb/quirks.c:429:6: warning: err may be used uninitialized in this function [-Wuninitialized]
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 77762c99afbe..81e07d842581 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -426,7 +426,7 @@ static int snd_usb_cm106_boot_quirk(struct usb_device *dev)
  */
 static int snd_usb_cm6206_boot_quirk(struct usb_device *dev)
 {
-	int err, reg;
+	int err  = 0, reg;
 	int val[] = {0x2004, 0x3000, 0xf800, 0x143f, 0x0000, 0x3000};
 
 	for (reg = 0; reg < ARRAY_SIZE(val); reg++) {

commit 0f5733b0c883158b13366ae34b5e4bd52a1ac346
Author: Guillaume Pellerin <yomguy@parisson.com>
Date:   Tue Jul 12 18:13:46 2011 +0200

    ALSA: usb-audio - Add quirks for M-Audio Fast Track Pro and Quattro
    
    This patch gives M-Audio Fast Track Pro and M-Audio Quattro quirks and
    endpoints to boot and setup those devices with special options (digital
    inputs and outputs, 24 bits mode, etc...). M-Audio Audiophile quirks are
    just adapted to match the new global M-Audio parameters.
    
    Special configurations can be then loaded through a modprobe conf file.
    For example, to set the 24 bits mode on the Fast Track Pro add
    /etc/modprobe.d/fast_track_pro.conf :
    
        options snd_usb_audio   vid=0x763 pid=0x2012 device_setup=0x08
    
    Here is a list of the possibilities in this example :
    http://files.parisson.com/debian/fast-track-pro.conf
    
    Signed-off-by: Guillaume Pellerin <yomguy@parisson.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 090e1930dfdc..77762c99afbe 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -369,6 +369,30 @@ static int snd_usb_audigy2nx_boot_quirk(struct usb_device *dev)
 	return 0;
 }
 
+static int snd_usb_fasttrackpro_boot_quirk(struct usb_device *dev)
+{
+	int err;
+
+	if (dev->actconfig->desc.bConfigurationValue == 1) {
+		snd_printk(KERN_INFO "usb-audio: "
+			   "Fast Track Pro switching to config #2\n");
+		/* This function has to be available by the usb core module.
+		 * if it is not avialable the boot quirk has to be left out
+		 * and the configuration has to be set by udev or hotplug
+		 * rules
+		 */
+		err = usb_driver_set_configuration(dev, 2);
+		if (err < 0) {
+			snd_printdd("error usb_driver_set_configuration: %d\n",
+				    err);
+			return -ENODEV;
+		}
+	} else
+		snd_printk(KERN_INFO "usb-audio: Fast Track Pro config OK\n");
+
+	return 0;
+}
+
 /*
  * C-Media CM106/CM106+ have four 16-bit internal registers that are nicely
  * documented in the device's data sheet.
@@ -471,16 +495,49 @@ static int snd_usb_nativeinstruments_boot_quirk(struct usb_device *dev)
 /*
  * Setup quirks
  */
-#define AUDIOPHILE_SET			0x01 /* if set, parse device_setup */
-#define AUDIOPHILE_SET_DTS              0x02 /* if set, enable DTS Digital Output */
-#define AUDIOPHILE_SET_96K              0x04 /* 48-96KHz rate if set, 8-48KHz otherwise */
-#define AUDIOPHILE_SET_24B		0x08 /* 24bits sample if set, 16bits otherwise */
-#define AUDIOPHILE_SET_DI		0x10 /* if set, enable Digital Input */
-#define AUDIOPHILE_SET_MASK		0x1F /* bit mask for setup value */
-#define AUDIOPHILE_SET_24B_48K_DI	0x19 /* value for 24bits+48KHz+Digital Input */
-#define AUDIOPHILE_SET_24B_48K_NOTDI	0x09 /* value for 24bits+48KHz+No Digital Input */
-#define AUDIOPHILE_SET_16B_48K_DI	0x11 /* value for 16bits+48KHz+Digital Input */
-#define AUDIOPHILE_SET_16B_48K_NOTDI	0x01 /* value for 16bits+48KHz+No Digital Input */
+#define MAUDIO_SET		0x01 /* parse device_setup */
+#define MAUDIO_SET_COMPATIBLE	0x80 /* use only "win-compatible" interfaces */
+#define MAUDIO_SET_DTS		0x02 /* enable DTS Digital Output */
+#define MAUDIO_SET_96K		0x04 /* 48-96KHz rate if set, 8-48KHz otherwise */
+#define MAUDIO_SET_24B		0x08 /* 24bits sample if set, 16bits otherwise */
+#define MAUDIO_SET_DI		0x10 /* enable Digital Input */
+#define MAUDIO_SET_MASK		0x1f /* bit mask for setup value */
+#define MAUDIO_SET_24B_48K_DI	 0x19 /* 24bits+48KHz+Digital Input */
+#define MAUDIO_SET_24B_48K_NOTDI 0x09 /* 24bits+48KHz+No Digital Input */
+#define MAUDIO_SET_16B_48K_DI	 0x11 /* 16bits+48KHz+Digital Input */
+#define MAUDIO_SET_16B_48K_NOTDI 0x01 /* 16bits+48KHz+No Digital Input */
+
+static int quattro_skip_setting_quirk(struct snd_usb_audio *chip,
+				      int iface, int altno)
+{
+	/* Reset ALL ifaces to 0 altsetting.
+	 * Call it for every possible altsetting of every interface.
+	 */
+	usb_set_interface(chip->dev, iface, 0);
+	if (chip->setup & MAUDIO_SET) {
+		if (chip->setup & MAUDIO_SET_COMPATIBLE) {
+			if (iface != 1 && iface != 2)
+				return 1; /* skip all interfaces but 1 and 2 */
+		} else {
+			unsigned int mask;
+			if (iface == 1 || iface == 2)
+				return 1; /* skip interfaces 1 and 2 */
+			if ((chip->setup & MAUDIO_SET_96K) && altno != 1)
+				return 1; /* skip this altsetting */
+			mask = chip->setup & MAUDIO_SET_MASK;
+			if (mask == MAUDIO_SET_24B_48K_DI && altno != 2)
+				return 1; /* skip this altsetting */
+			if (mask == MAUDIO_SET_24B_48K_NOTDI && altno != 3)
+				return 1; /* skip this altsetting */
+			if (mask == MAUDIO_SET_16B_48K_NOTDI && altno != 4)
+				return 1; /* skip this altsetting */
+		}
+	}
+	snd_printdd(KERN_INFO
+		    "using altsetting %d for interface %d config %d\n",
+		    altno, iface, chip->setup);
+	return 0; /* keep this altsetting */
+}
 
 static int audiophile_skip_setting_quirk(struct snd_usb_audio *chip,
 					 int iface,
@@ -491,30 +548,65 @@ static int audiophile_skip_setting_quirk(struct snd_usb_audio *chip,
 	 */
 	usb_set_interface(chip->dev, iface, 0);
 
-	if (chip->setup & AUDIOPHILE_SET) {
-		if ((chip->setup & AUDIOPHILE_SET_DTS)
-		    && altno != 6)
+	if (chip->setup & MAUDIO_SET) {
+		unsigned int mask;
+		if ((chip->setup & MAUDIO_SET_DTS) && altno != 6)
 			return 1; /* skip this altsetting */
-		if ((chip->setup & AUDIOPHILE_SET_96K)
-		    && altno != 1)
+		if ((chip->setup & MAUDIO_SET_96K) && altno != 1)
 			return 1; /* skip this altsetting */
-		if ((chip->setup & AUDIOPHILE_SET_MASK) ==
-		    AUDIOPHILE_SET_24B_48K_DI && altno != 2)
+		mask = chip->setup & MAUDIO_SET_MASK;
+		if (mask == MAUDIO_SET_24B_48K_DI && altno != 2)
 			return 1; /* skip this altsetting */
-		if ((chip->setup & AUDIOPHILE_SET_MASK) ==
-		    AUDIOPHILE_SET_24B_48K_NOTDI && altno != 3)
+		if (mask == MAUDIO_SET_24B_48K_NOTDI && altno != 3)
 			return 1; /* skip this altsetting */
-		if ((chip->setup & AUDIOPHILE_SET_MASK) ==
-		    AUDIOPHILE_SET_16B_48K_DI && altno != 4)
+		if (mask == MAUDIO_SET_16B_48K_DI && altno != 4)
 			return 1; /* skip this altsetting */
-		if ((chip->setup & AUDIOPHILE_SET_MASK) ==
-		    AUDIOPHILE_SET_16B_48K_NOTDI && altno != 5)
+		if (mask == MAUDIO_SET_16B_48K_NOTDI && altno != 5)
 			return 1; /* skip this altsetting */
 	}
 
 	return 0; /* keep this altsetting */
 }
 
+
+static int fasttrackpro_skip_setting_quirk(struct snd_usb_audio *chip,
+					   int iface, int altno)
+{
+	/* Reset ALL ifaces to 0 altsetting.
+	 * Call it for every possible altsetting of every interface.
+	 */
+	usb_set_interface(chip->dev, iface, 0);
+
+	/* possible configuration where both inputs and only one output is
+	 *used is not supported by the current setup
+	 */
+	if (chip->setup & (MAUDIO_SET | MAUDIO_SET_24B)) {
+		if (chip->setup & MAUDIO_SET_96K) {
+			if (altno != 3 && altno != 6)
+				return 1;
+		} else if (chip->setup & MAUDIO_SET_DI) {
+			if (iface == 4)
+				return 1; /* no analog input */
+			if (altno != 2 && altno != 5)
+				return 1; /* enable only altsets 2 and 5 */
+		} else {
+			if (iface == 5)
+				return 1; /* disable digialt input */
+			if (altno != 2 && altno != 5)
+				return 1; /* enalbe only altsets 2 and 5 */
+		}
+	} else {
+		/* keep only 16-Bit mode */
+		if (altno != 1)
+			return 1;
+	}
+
+	snd_printdd(KERN_INFO
+		    "using altsetting %d for interface %d config %d\n",
+		    altno, iface, chip->setup);
+	return 0; /* keep this altsetting */
+}
+
 int snd_usb_apply_interface_quirk(struct snd_usb_audio *chip,
 				  int iface,
 				  int altno)
@@ -522,6 +614,12 @@ int snd_usb_apply_interface_quirk(struct snd_usb_audio *chip,
 	/* audiophile usb: skip altsets incompatible with device_setup */
 	if (chip->usb_id == USB_ID(0x0763, 0x2003))
 		return audiophile_skip_setting_quirk(chip, iface, altno);
+	/* quattro usb: skip altsets incompatible with device_setup */
+	if (chip->usb_id == USB_ID(0x0763, 0x2001))
+		return quattro_skip_setting_quirk(chip, iface, altno);
+	/* fasttrackpro usb: skip altsets incompatible with device_setup */
+	if (chip->usb_id == USB_ID(0x0763, 0x2012))
+		return fasttrackpro_skip_setting_quirk(chip, iface, altno);
 
 	return 0;
 }
@@ -560,6 +658,8 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
 	case USB_ID(0x17cc, 0x1010): /* Traktor Audio 6 */
 	case USB_ID(0x17cc, 0x1020): /* Traktor Audio 10 */
 		return snd_usb_nativeinstruments_boot_quirk(dev);
+	case USB_ID(0x0763, 0x2012):  /* M-Audio Fast Track Pro USB */
+		return snd_usb_fasttrackpro_boot_quirk(dev);
 	}
 
 	return 0;
@@ -570,15 +670,24 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
  */
 int snd_usb_is_big_endian_format(struct snd_usb_audio *chip, struct audioformat *fp)
 {
+	/* it depends on altsetting wether the device is big-endian or not */
 	switch (chip->usb_id) {
 	case USB_ID(0x0763, 0x2001): /* M-Audio Quattro: captured data only */
-		if (fp->endpoint & USB_DIR_IN)
+		if (fp->altsetting == 2 || fp->altsetting == 3 ||
+			fp->altsetting == 5 || fp->altsetting == 6)
 			return 1;
 		break;
 	case USB_ID(0x0763, 0x2003): /* M-Audio Audiophile USB */
 		if (chip->setup == 0x00 ||
-		    fp->altsetting==1 || fp->altsetting==2 || fp->altsetting==3)
+			fp->altsetting == 1 || fp->altsetting == 2 ||
+			fp->altsetting == 3)
+			return 1;
+		break;
+	case USB_ID(0x0763, 0x2012): /* M-Audio Fast Track Pro */
+		if (fp->altsetting == 2 || fp->altsetting == 3 ||
+			fp->altsetting == 5 || fp->altsetting == 6)
 			return 1;
+		break;
 	}
 	return 0;
 }

commit 157186bc185cdf588fecba0fc5d7466e3e5d49d7
Author: Eric Lammerts <alsa-devel@lists.lammerts.org>
Date:   Fri May 27 18:16:52 2011 -0400

    ALSA: usb - turn off de-emphasis in s/pdif for cm6206
    
    CM6206: Turn off de-emphasis channel status bit in S/PDIF output.
    
    Signed-off-by: Eric Lammerts <eric@lammerts.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 2e969cbb393b..090e1930dfdc 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -403,7 +403,7 @@ static int snd_usb_cm106_boot_quirk(struct usb_device *dev)
 static int snd_usb_cm6206_boot_quirk(struct usb_device *dev)
 {
 	int err, reg;
-	int val[] = {0x200c, 0x3000, 0xf800, 0x143f, 0x0000, 0x3000};
+	int val[] = {0x2004, 0x3000, 0xf800, 0x143f, 0x0000, 0x3000};
 
 	for (reg = 0; reg < ARRAY_SIZE(val); reg++) {
 		err = snd_usb_cm106_write_int_reg(dev, reg, val[reg]);

commit 014950b013b7966b7e4a3ae6931c75e3c115296f
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed May 25 09:09:02 2011 +0200

    ALSA: usb-audio: add new quirk type QUIRK_AUDIO_STANDARD_MIXER
    
    This quirk type will let the driver assume that there is a standard
    mixer on a given interface, or that a specific mixer quirks will handle
    the device.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 2546dc808e43..2e969cbb393b 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -263,6 +263,20 @@ static int create_uaxx_quirk(struct snd_usb_audio *chip,
 	return 0;
 }
 
+/*
+ * Create a standard mixer for the specified interface.
+ */
+static int create_standard_mixer_quirk(struct snd_usb_audio *chip,
+				       struct usb_interface *iface,
+				       struct usb_driver *driver,
+				       const struct snd_usb_audio_quirk *quirk)
+{
+	if (quirk->ifnum < 0)
+		return 0;
+
+	return snd_usb_create_mixer(chip, quirk->ifnum, 0);
+}
+
 /*
  * audio-interface quirks
  *
@@ -295,7 +309,8 @@ int snd_usb_create_quirk(struct snd_usb_audio *chip,
 		[QUIRK_AUDIO_STANDARD_INTERFACE] = create_standard_audio_quirk,
 		[QUIRK_AUDIO_FIXED_ENDPOINT] = create_fixed_stream_quirk,
 		[QUIRK_AUDIO_EDIROL_UAXX] = create_uaxx_quirk,
-		[QUIRK_AUDIO_ALIGN_TRANSFER] = create_align_transfer_quirk
+		[QUIRK_AUDIO_ALIGN_TRANSFER] = create_align_transfer_quirk,
+		[QUIRK_AUDIO_STANDARD_MIXER] = create_standard_mixer_quirk,
 	};
 
 	if (quirk->type < QUIRK_TYPE_COUNT) {

commit 9e38658f703732cb69936553cef4bdb4e5294f3f
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed May 25 09:09:01 2011 +0200

    ALSA: usb-audio: export snd_usb_feature_unit_ctl
    
    In order to allow quirks functions to hook up to the standard feature
    unit op tables, this patch exports a pointer to the struct that is used
    internally.
    
    That way, all the code handling the control can be kept private, and
    external code can reference the symbol to re-use it.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index bd13d7257240..2546dc808e43 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -19,6 +19,7 @@
 #include <linux/usb.h>
 #include <linux/usb/audio.h>
 
+#include <sound/control.h>
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/pcm.h>

commit 02e5fbf622aabf68bdc02282a17a3aeed054237a
Merge: b759b3ac9aee bfe9fc8aebc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun May 22 10:01:29 2011 +0200

    Merge branch 'topic/misc' into for-linus

commit 759e890f5c25ef087d866b330261e793b03ef7a4
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed May 18 11:28:41 2011 +0200

    ALSA: usb-audio: remove invalid extra mixers for Komplete Audio 6
    
    This was a flaw in the reading of the spec tables - Native Instrument's
    "Komplete Audio 6" device has no such extra controls.
    
    This patch also fixes the device name in two comments.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 2452edd2f141..c1a5d7d4580b 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -539,7 +539,7 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
 		/* Access Music VirusTI Desktop */
 		return snd_usb_accessmusic_boot_quirk(dev);
 
-	case USB_ID(0x17cc, 0x1000): /* Audio Kontrol 6 */
+	case USB_ID(0x17cc, 0x1000): /* Komplete Audio 6 */
 	case USB_ID(0x17cc, 0x1010): /* Traktor Audio 6 */
 	case USB_ID(0x17cc, 0x1020): /* Traktor Audio 10 */
 		return snd_usb_nativeinstruments_boot_quirk(dev);

commit 8129e79ed7932bd11d60518d62434a0b687e5771
Author: Wolfgang Breyha <wbreyha@gmx.net>
Date:   Thu Apr 28 16:18:40 2011 +0200

    ALSA: usb-audio - Terratec Aureon 7.1 USB ID as C-Media cm6206 quirks
    
    This patch adds support for the Terratec Aureon 7.1 USB which uses a
    C-Media cm6206 and needs all the quirks already found in the past.
    
    Signed-off-by: Wolfgang Breyha <wbreyha@gmx.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index ec07e62e53f3..1b94ec3a3368 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -533,6 +533,7 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
 
 	case USB_ID(0x0d8c, 0x0102):
 		/* C-Media CM6206 / CM106-Like Sound Device */
+	case USB_ID(0x0ccd, 0x00b1): /* Terratec Aureon 7.1 USB */
 		return snd_usb_cm6206_boot_quirk(dev);
 
 	case USB_ID(0x133e, 0x0815):

commit 9cdc352936311eea55624cbabafda296b99ff137
Author: Daniel Mack <zonque@gmail.com>
Date:   Mon Apr 11 17:56:32 2011 +0200

    ALSA: usb-audio: Add quirks for Audio Kontrol 6
    
    This new device by Native Instruments is also compliant to the USB
    standard v2.0, but hides this detail at when connected.
    
    It needs the same boot quirks than other models, and also has two
    non-class-compliant mixer controls.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 355759bad581..2452edd2f141 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -539,6 +539,7 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
 		/* Access Music VirusTI Desktop */
 		return snd_usb_accessmusic_boot_quirk(dev);
 
+	case USB_ID(0x17cc, 0x1000): /* Audio Kontrol 6 */
 	case USB_ID(0x17cc, 0x1010): /* Traktor Audio 6 */
 	case USB_ID(0x17cc, 0x1020): /* Traktor Audio 10 */
 		return snd_usb_nativeinstruments_boot_quirk(dev);

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 355759bad581..ec07e62e53f3 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -266,7 +266,7 @@ static int create_uaxx_quirk(struct snd_usb_audio *chip,
  * audio-interface quirks
  *
  * returns zero if no standard audio/MIDI parsing is needed.
- * returns a postive value if standard audio/midi interfaces are parsed
+ * returns a positive value if standard audio/midi interfaces are parsed
  * after this.
  * returns a negative value at error.
  */

commit cc99a0861fa1c72335dc91a2e06d0b431911d55e
Merge: bc3a8a01def4 382225e62bdb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Mar 11 14:48:09 2011 +0100

    Merge branch 'fix/misc' into topic/misc

commit 3347b26cab60e20534b9a46ceea70b9fb74297fb
Author: Daniel Mack <daniel@caiaq.de>
Date:   Fri Feb 11 11:34:12 2011 +0000

    ALSA: usb-audio: reconstruct some dispatcher functions to use switch-case
    
    The number of cases has increased so use switch-case rather than
    if-statements.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index e55bd1cac77d..ca860e611263 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -517,31 +517,32 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
 	u32 id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),
 			le16_to_cpu(dev->descriptor.idProduct));
 
-	/* SB Extigy needs special boot-up sequence */
-	/* if more models come, this will go to the quirk list. */
-	if (id == USB_ID(0x041e, 0x3000))
+	switch (id) {
+	case USB_ID(0x041e, 0x3000):
+		/* SB Extigy needs special boot-up sequence */
+		/* if more models come, this will go to the quirk list. */
 		return snd_usb_extigy_boot_quirk(dev, intf);
 
-	/* SB Audigy 2 NX needs its own boot-up magic, too */
-	if (id == USB_ID(0x041e, 0x3020))
+	case USB_ID(0x041e, 0x3020):
+		/* SB Audigy 2 NX needs its own boot-up magic, too */
 		return snd_usb_audigy2nx_boot_quirk(dev);
 
-	/* C-Media CM106 / Turtle Beach Audio Advantage Roadie */
-	if (id == USB_ID(0x10f5, 0x0200))
+	case USB_ID(0x10f5, 0x0200):
+		/* C-Media CM106 / Turtle Beach Audio Advantage Roadie */
 		return snd_usb_cm106_boot_quirk(dev);
 
-	/* C-Media CM6206 / CM106-Like Sound Device */
-	if (id == USB_ID(0x0d8c, 0x0102))
+	case USB_ID(0x0d8c, 0x0102):
+		/* C-Media CM6206 / CM106-Like Sound Device */
 		return snd_usb_cm6206_boot_quirk(dev);
 
-	/* Access Music VirusTI Desktop */
-	if (id == USB_ID(0x133e, 0x0815))
+	case USB_ID(0x133e, 0x0815):
+		/* Access Music VirusTI Desktop */
 		return snd_usb_accessmusic_boot_quirk(dev);
 
-	/* Native Instruments Devices */
-	if (id == USB_ID(0x17cc, 0x1010) || /* Traktor Audio 6 */
-		id == USB_ID(0x17cc, 0x1020)) /* Traktor Audio 10 */
+	case USB_ID(0x17cc, 0x1010): /* Traktor Audio 6 */
+	case USB_ID(0x17cc, 0x1020): /* Traktor Audio 10 */
 		return snd_usb_nativeinstruments_boot_quirk(dev);
+	}
 
 	return 0;
 }

commit 54a8c500d5b80c83e0f14cbcfcfd4a84abff8a80
Author: Daniel Mack <daniel@caiaq.de>
Date:   Fri Feb 11 11:08:06 2011 +0000

    ALSA: usb-audio: add support for Native Instruments MK2 devices
    
    The MK2 generation of Native Instruments' sound cards are in fact
    compliant to the USB audio standard of version 2 and other approved USB
    standards. However, they come up as vendor-specific device when first
    connected but can be told to come up with a new set of descriptors
    upon their next enumeration. The interfaces announced by the new
    descriptors will be handled by the kernel's class drivers. This is done
    by issuing a vendor specific device request and sending the device to
    reset.
    
    There are also some vendor-specific USB requests for some mixer elements
    that can't be exported in a standard compliant way. The driver now
    supports them with quirks handling mechanisms.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index cf8bf088394b..e55bd1cac77d 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -424,6 +424,34 @@ static int snd_usb_accessmusic_boot_quirk(struct usb_device *dev)
 	return 0;
 }
 
+/*
+ * Some sound cards from Native Instruments are in fact compliant to the USB
+ * audio standard of version 2 and other approved USB standards, even though
+ * they come up as vendor-specific device when first connected.
+ *
+ * However, they can be told to come up with a new set of descriptors
+ * upon their next enumeration, and the interfaces announced by the new
+ * descriptors will then be handled by the kernel's class drivers. As the
+ * product ID will also change, no further checks are required.
+ */
+
+static int snd_usb_nativeinstruments_boot_quirk(struct usb_device *dev)
+{
+	int ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				  0xaf, USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+				  cpu_to_le16(1), 0, NULL, 0, 1000);
+
+	if (ret < 0)
+		return ret;
+
+	usb_reset_device(dev);
+
+	/* return -EAGAIN, so the creation of an audio interface for this
+	 * temporary device is aborted. The device will reconnect with a
+	 * new product ID */
+	return -EAGAIN;
+}
+
 /*
  * Setup quirks
  */
@@ -510,6 +538,11 @@ int snd_usb_apply_boot_quirk(struct usb_device *dev,
 	if (id == USB_ID(0x133e, 0x0815))
 		return snd_usb_accessmusic_boot_quirk(dev);
 
+	/* Native Instruments Devices */
+	if (id == USB_ID(0x17cc, 0x1010) || /* Traktor Audio 6 */
+		id == USB_ID(0x17cc, 0x1020)) /* Traktor Audio 10 */
+		return snd_usb_nativeinstruments_boot_quirk(dev);
+
 	return 0;
 }
 

commit 1cdfa9f34acb9780e0fe7b8a41fb1a885ab94735
Author: Joseph Teichman <josteich@gmail.com>
Date:   Tue Feb 8 01:22:36 2011 -0500

    ALSA: usbaudio - Enable the E-MU 0204 USB
    
    Signed-off-by: Joseph Teichman <josteich@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index cf8bf088394b..e314cdb85003 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -532,7 +532,7 @@ int snd_usb_is_big_endian_format(struct snd_usb_audio *chip, struct audioformat
 }
 
 /*
- * For E-Mu 0404USB/0202USB/TrackerPre sample rate should be set for device,
+ * For E-Mu 0404USB/0202USB/TrackerPre/0204 sample rate should be set for device,
  * not for interface.
  */
 
@@ -589,6 +589,7 @@ void snd_usb_set_format_quirk(struct snd_usb_substream *subs,
 	case USB_ID(0x041e, 0x3f02): /* E-Mu 0202 USB */
 	case USB_ID(0x041e, 0x3f04): /* E-Mu 0404 USB */
 	case USB_ID(0x041e, 0x3f0a): /* E-Mu Tracker Pre */
+	case USB_ID(0x041e, 0x3f19): /* E-Mu 0204 USB */
 		set_format_emu_quirk(subs, fmt);
 		break;
 	}

commit c7f572168fc4840727c9bda955b7f103922209cd
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Oct 22 18:20:48 2010 +0200

    ALSA: usb-audio: add Novation Launchpad support
    
    Add a quirk entry for the Novation Launchpad USB MIDI controller.
    
    QUIRK_MIDI_FASTLANE gets renamed to *_RAW_BYTES because this quirk type
    is now shared by different devices.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Tested-by: Jakob Flierl <jakob.flierl@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 9a9da09586a5..cf8bf088394b 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -287,7 +287,7 @@ int snd_usb_create_quirk(struct snd_usb_audio *chip,
 		[QUIRK_MIDI_YAMAHA] = create_any_midi_quirk,
 		[QUIRK_MIDI_MIDIMAN] = create_any_midi_quirk,
 		[QUIRK_MIDI_NOVATION] = create_any_midi_quirk,
-		[QUIRK_MIDI_FASTLANE] = create_any_midi_quirk,
+		[QUIRK_MIDI_RAW_BYTES] = create_any_midi_quirk,
 		[QUIRK_MIDI_EMAGIC] = create_any_midi_quirk,
 		[QUIRK_MIDI_CME] = create_any_midi_quirk,
 		[QUIRK_MIDI_AKAI] = create_any_midi_quirk,

commit 3d8d4dcfd423b01ef7ea7c3c97720764b7adb6df
Author: Daniel Mack <daniel@caiaq.de>
Date:   Wed Jun 16 17:57:31 2010 +0200

    ALSA: usb-audio: simplify control interface access
    
    As the control interface is now carried in struct snd_usb_audio, we can
    simplify the API a little and also drop the private ctrlif field from
    struct usb_mixer_interface.
    
    Also remove a left-over function prototype in pcm.h.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index b45e54c09ba2..9a9da09586a5 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -32,6 +32,7 @@
 #include "helper.h"
 #include "endpoint.h"
 #include "pcm.h"
+#include "clock.h"
 
 /*
  * handle the quirks for the contained interfaces

commit 4434ade8c9334a3ab975d8993de456f06841899e
Author: Krzysztof Foltman <wdev@foltman.com>
Date:   Thu May 20 20:31:10 2010 +0100

    ALSA: usb-audio: add support for Akai MPD16
    
    The decoding/encoding is based on own reverse-engineering. Both control and
    data ports are handled. Writing to control port supports SysEx events only,
    as this is the only type of messages that MPD16 recognizes.
    
    Signed-off-by: Krzysztof Foltman <wdev@foltman.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 136e5b4cf6de..b45e54c09ba2 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -289,6 +289,7 @@ int snd_usb_create_quirk(struct snd_usb_audio *chip,
 		[QUIRK_MIDI_FASTLANE] = create_any_midi_quirk,
 		[QUIRK_MIDI_EMAGIC] = create_any_midi_quirk,
 		[QUIRK_MIDI_CME] = create_any_midi_quirk,
+		[QUIRK_MIDI_AKAI] = create_any_midi_quirk,
 		[QUIRK_AUDIO_STANDARD_INTERFACE] = create_standard_audio_quirk,
 		[QUIRK_AUDIO_FIXED_ENDPOINT] = create_fixed_stream_quirk,
 		[QUIRK_AUDIO_EDIROL_UAXX] = create_uaxx_quirk,

commit 36db0456582484aa78809376f1e41ec2873fc9d5
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Mon Mar 29 16:02:50 2010 +1100

    ALSA: usb - use of kmalloc/kfree requires the include of slab.h
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index d4ced64e465b..136e5b4cf6de 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -15,6 +15,7 @@
  */
 
 #include <linux/init.h>
+#include <linux/slab.h>
 #include <linux/usb.h>
 #include <linux/usb/audio.h>
 

commit f0b5e634ff25e02a64676022ee13284a9c810879
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Mar 11 21:13:23 2010 +0100

    ALSA: usbmixer: rename usbmixer.[ch] -> mixer.[ch]
    
    For clearer namespace, also rename usbmixer_maps.c -> mixer_maps.c
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index a82cfeda21f0..d4ced64e465b 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -24,7 +24,7 @@
 
 #include "usbaudio.h"
 #include "card.h"
-#include "usbmixer.h"
+#include "mixer.h"
 #include "mixer_quirks.h"
 #include "midi.h"
 #include "quirks.h"

commit 7b1eda223debcba706ab989a09c4eecb327aebdf
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Mar 11 21:13:22 2010 +0100

    ALSA: usb-mixer: factor out quirks
    
    Move all non-standard mixer controls and vendor-specific extensions to a
    separate file. Some structs need to be exported now.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 0c0b23b63794..a82cfeda21f0 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -25,6 +25,7 @@
 #include "usbaudio.h"
 #include "card.h"
 #include "usbmixer.h"
+#include "mixer_quirks.h"
 #include "midi.h"
 #include "quirks.h"
 #include "helper.h"

commit 767d75ad1c08c31646498a13837a5c59db90ccad
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Mar 4 19:46:17 2010 +0100

    ALSA: usb-audio: add support for samplerate setting on v2 devices
    
    Sample rate setting is done with a 4-byte long class request that
    addresses the interface.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 99a19ba43207..0c0b23b63794 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -159,8 +159,8 @@ static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 	fp->datainterval = snd_usb_parse_datainterval(chip, alts);
 	fp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);
 	usb_set_interface(chip->dev, fp->iface, 0);
-	snd_usb_init_pitch(chip->dev, fp->iface, alts, fp);
-	snd_usb_init_sample_rate(chip->dev, fp->iface, alts, fp, fp->rate_max);
+	snd_usb_init_pitch(chip, fp->iface, alts, fp);
+	snd_usb_init_sample_rate(chip, fp->iface, alts, fp, fp->rate_max);
 	return 0;
 }
 

commit 015eb0b08150c6fef843efe22609589ead3d4fb8
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Mar 4 19:46:15 2010 +0100

    ALSA: usb-audio: use a format bitmask per alternate setting
    
    In preparation for USB audio 2.0 support, change the audioformat
    structure so that it uses a bitmask to specify possible formats.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 4c16920844ea..99a19ba43207 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -174,7 +174,7 @@ static int create_uaxx_quirk(struct snd_usb_audio *chip,
 			     const struct snd_usb_audio_quirk *quirk)
 {
 	static const struct audioformat ua_format = {
-		.format = SNDRV_PCM_FORMAT_S24_3LE,
+		.formats = SNDRV_PCM_FMTBIT_S24_3LE,
 		.channels = 2,
 		.fmt_type = UAC_FORMAT_TYPE_I,
 		.altsetting = 1,

commit e5779998bf8b70e48a6cc208c8b61b33bd6117ea
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Mar 4 19:46:13 2010 +0100

    ALSA: usb-audio: refactor code
    
    Clean up the usb audio driver by factoring out a lot of functions to
    separate files. Code for procfs, quirks, urbs, format parsers etc all
    got a new home now.
    
    Moved almost all special quirk handling to quirks.c and introduced new
    generic functions to handle them, so the exceptions do not pollute the
    whole driver.
    
    Renamed usbaudio.c to card.c because this is what it actually does now.
    Renamed usbmidi.c to midi.c for namespace clarity.
    Removed more things from usbaudio.h.
    
    The non-standard drivers were adopted accordingly.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
new file mode 100644
index 000000000000..4c16920844ea
--- /dev/null
+++ b/sound/usb/quirks.c
@@ -0,0 +1,592 @@
+/*
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/usb.h>
+#include <linux/usb/audio.h>
+
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/pcm.h>
+
+#include "usbaudio.h"
+#include "card.h"
+#include "usbmixer.h"
+#include "midi.h"
+#include "quirks.h"
+#include "helper.h"
+#include "endpoint.h"
+#include "pcm.h"
+
+/*
+ * handle the quirks for the contained interfaces
+ */
+static int create_composite_quirk(struct snd_usb_audio *chip,
+				  struct usb_interface *iface,
+				  struct usb_driver *driver,
+				  const struct snd_usb_audio_quirk *quirk)
+{
+	int probed_ifnum = get_iface_desc(iface->altsetting)->bInterfaceNumber;
+	int err;
+
+	for (quirk = quirk->data; quirk->ifnum >= 0; ++quirk) {
+		iface = usb_ifnum_to_if(chip->dev, quirk->ifnum);
+		if (!iface)
+			continue;
+		if (quirk->ifnum != probed_ifnum &&
+		    usb_interface_claimed(iface))
+			continue;
+		err = snd_usb_create_quirk(chip, iface, driver, quirk);
+		if (err < 0)
+			return err;
+		if (quirk->ifnum != probed_ifnum)
+			usb_driver_claim_interface(driver, iface, (void *)-1L);
+	}
+	return 0;
+}
+
+static int ignore_interface_quirk(struct snd_usb_audio *chip,
+				  struct usb_interface *iface,
+				  struct usb_driver *driver,
+				  const struct snd_usb_audio_quirk *quirk)
+{
+	return 0;
+}
+
+
+/*
+ * Allow alignment on audio sub-slot (channel samples) rather than
+ * on audio slots (audio frames)
+ */
+static int create_align_transfer_quirk(struct snd_usb_audio *chip,
+				       struct usb_interface *iface,
+				       struct usb_driver *driver,
+				       const struct snd_usb_audio_quirk *quirk)
+{
+	chip->txfr_quirk = 1;
+	return 1;	/* Continue with creating streams and mixer */
+}
+
+static int create_any_midi_quirk(struct snd_usb_audio *chip,
+				 struct usb_interface *intf,
+				 struct usb_driver *driver,
+				 const struct snd_usb_audio_quirk *quirk)
+{
+	return snd_usbmidi_create(chip->card, intf, &chip->midi_list, quirk);
+}
+
+/*
+ * create a stream for an interface with proper descriptors
+ */
+static int create_standard_audio_quirk(struct snd_usb_audio *chip,
+				       struct usb_interface *iface,
+				       struct usb_driver *driver,
+				       const struct snd_usb_audio_quirk *quirk)
+{
+	struct usb_host_interface *alts;
+	struct usb_interface_descriptor *altsd;
+	int err;
+
+	alts = &iface->altsetting[0];
+	altsd = get_iface_desc(alts);
+	err = snd_usb_parse_audio_endpoints(chip, altsd->bInterfaceNumber);
+	if (err < 0) {
+		snd_printk(KERN_ERR "cannot setup if %d: error %d\n",
+			   altsd->bInterfaceNumber, err);
+		return err;
+	}
+	/* reset the current interface */
+	usb_set_interface(chip->dev, altsd->bInterfaceNumber, 0);
+	return 0;
+}
+
+/*
+ * create a stream for an endpoint/altsetting without proper descriptors
+ */
+static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
+				     struct usb_interface *iface,
+				     struct usb_driver *driver,
+				     const struct snd_usb_audio_quirk *quirk)
+{
+	struct audioformat *fp;
+	struct usb_host_interface *alts;
+	int stream, err;
+	unsigned *rate_table = NULL;
+
+	fp = kmemdup(quirk->data, sizeof(*fp), GFP_KERNEL);
+	if (! fp) {
+		snd_printk(KERN_ERR "cannot memdup\n");
+		return -ENOMEM;
+	}
+	if (fp->nr_rates > 0) {
+		rate_table = kmalloc(sizeof(int) * fp->nr_rates, GFP_KERNEL);
+		if (!rate_table) {
+			kfree(fp);
+			return -ENOMEM;
+		}
+		memcpy(rate_table, fp->rate_table, sizeof(int) * fp->nr_rates);
+		fp->rate_table = rate_table;
+	}
+
+	stream = (fp->endpoint & USB_DIR_IN)
+		? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
+	err = snd_usb_add_audio_endpoint(chip, stream, fp);
+	if (err < 0) {
+		kfree(fp);
+		kfree(rate_table);
+		return err;
+	}
+	if (fp->iface != get_iface_desc(&iface->altsetting[0])->bInterfaceNumber ||
+	    fp->altset_idx >= iface->num_altsetting) {
+		kfree(fp);
+		kfree(rate_table);
+		return -EINVAL;
+	}
+	alts = &iface->altsetting[fp->altset_idx];
+	fp->datainterval = snd_usb_parse_datainterval(chip, alts);
+	fp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);
+	usb_set_interface(chip->dev, fp->iface, 0);
+	snd_usb_init_pitch(chip->dev, fp->iface, alts, fp);
+	snd_usb_init_sample_rate(chip->dev, fp->iface, alts, fp, fp->rate_max);
+	return 0;
+}
+
+/*
+ * Create a stream for an Edirol UA-700/UA-25/UA-4FX interface.  
+ * The only way to detect the sample rate is by looking at wMaxPacketSize.
+ */
+static int create_uaxx_quirk(struct snd_usb_audio *chip,
+			     struct usb_interface *iface,
+			     struct usb_driver *driver,
+			     const struct snd_usb_audio_quirk *quirk)
+{
+	static const struct audioformat ua_format = {
+		.format = SNDRV_PCM_FORMAT_S24_3LE,
+		.channels = 2,
+		.fmt_type = UAC_FORMAT_TYPE_I,
+		.altsetting = 1,
+		.altset_idx = 1,
+		.rates = SNDRV_PCM_RATE_CONTINUOUS,
+	};
+	struct usb_host_interface *alts;
+	struct usb_interface_descriptor *altsd;
+	struct audioformat *fp;
+	int stream, err;
+
+	/* both PCM and MIDI interfaces have 2 or more altsettings */
+	if (iface->num_altsetting < 2)
+		return -ENXIO;
+	alts = &iface->altsetting[1];
+	altsd = get_iface_desc(alts);
+
+	if (altsd->bNumEndpoints == 2) {
+		static const struct snd_usb_midi_endpoint_info ua700_ep = {
+			.out_cables = 0x0003,
+			.in_cables  = 0x0003
+		};
+		static const struct snd_usb_audio_quirk ua700_quirk = {
+			.type = QUIRK_MIDI_FIXED_ENDPOINT,
+			.data = &ua700_ep
+		};
+		static const struct snd_usb_midi_endpoint_info uaxx_ep = {
+			.out_cables = 0x0001,
+			.in_cables  = 0x0001
+		};
+		static const struct snd_usb_audio_quirk uaxx_quirk = {
+			.type = QUIRK_MIDI_FIXED_ENDPOINT,
+			.data = &uaxx_ep
+		};
+		const struct snd_usb_audio_quirk *quirk =
+			chip->usb_id == USB_ID(0x0582, 0x002b)
+			? &ua700_quirk : &uaxx_quirk;
+		return snd_usbmidi_create(chip->card, iface,
+					  &chip->midi_list, quirk);
+	}
+
+	if (altsd->bNumEndpoints != 1)
+		return -ENXIO;
+
+	fp = kmalloc(sizeof(*fp), GFP_KERNEL);
+	if (!fp)
+		return -ENOMEM;
+	memcpy(fp, &ua_format, sizeof(*fp));
+
+	fp->iface = altsd->bInterfaceNumber;
+	fp->endpoint = get_endpoint(alts, 0)->bEndpointAddress;
+	fp->ep_attr = get_endpoint(alts, 0)->bmAttributes;
+	fp->datainterval = 0;
+	fp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);
+
+	switch (fp->maxpacksize) {
+	case 0x120:
+		fp->rate_max = fp->rate_min = 44100;
+		break;
+	case 0x138:
+	case 0x140:
+		fp->rate_max = fp->rate_min = 48000;
+		break;
+	case 0x258:
+	case 0x260:
+		fp->rate_max = fp->rate_min = 96000;
+		break;
+	default:
+		snd_printk(KERN_ERR "unknown sample rate\n");
+		kfree(fp);
+		return -ENXIO;
+	}
+
+	stream = (fp->endpoint & USB_DIR_IN)
+		? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
+	err = snd_usb_add_audio_endpoint(chip, stream, fp);
+	if (err < 0) {
+		kfree(fp);
+		return err;
+	}
+	usb_set_interface(chip->dev, fp->iface, 0);
+	return 0;
+}
+
+/*
+ * audio-interface quirks
+ *
+ * returns zero if no standard audio/MIDI parsing is needed.
+ * returns a postive value if standard audio/midi interfaces are parsed
+ * after this.
+ * returns a negative value at error.
+ */
+int snd_usb_create_quirk(struct snd_usb_audio *chip,
+			 struct usb_interface *iface,
+			 struct usb_driver *driver,
+			 const struct snd_usb_audio_quirk *quirk)
+{
+	typedef int (*quirk_func_t)(struct snd_usb_audio *,
+				    struct usb_interface *,
+				    struct usb_driver *,
+				    const struct snd_usb_audio_quirk *);
+	static const quirk_func_t quirk_funcs[] = {
+		[QUIRK_IGNORE_INTERFACE] = ignore_interface_quirk,
+		[QUIRK_COMPOSITE] = create_composite_quirk,
+		[QUIRK_MIDI_STANDARD_INTERFACE] = create_any_midi_quirk,
+		[QUIRK_MIDI_FIXED_ENDPOINT] = create_any_midi_quirk,
+		[QUIRK_MIDI_YAMAHA] = create_any_midi_quirk,
+		[QUIRK_MIDI_MIDIMAN] = create_any_midi_quirk,
+		[QUIRK_MIDI_NOVATION] = create_any_midi_quirk,
+		[QUIRK_MIDI_FASTLANE] = create_any_midi_quirk,
+		[QUIRK_MIDI_EMAGIC] = create_any_midi_quirk,
+		[QUIRK_MIDI_CME] = create_any_midi_quirk,
+		[QUIRK_AUDIO_STANDARD_INTERFACE] = create_standard_audio_quirk,
+		[QUIRK_AUDIO_FIXED_ENDPOINT] = create_fixed_stream_quirk,
+		[QUIRK_AUDIO_EDIROL_UAXX] = create_uaxx_quirk,
+		[QUIRK_AUDIO_ALIGN_TRANSFER] = create_align_transfer_quirk
+	};
+
+	if (quirk->type < QUIRK_TYPE_COUNT) {
+		return quirk_funcs[quirk->type](chip, iface, driver, quirk);
+	} else {
+		snd_printd(KERN_ERR "invalid quirk type %d\n", quirk->type);
+		return -ENXIO;
+	}
+}
+
+/*
+ * boot quirks
+ */
+
+#define EXTIGY_FIRMWARE_SIZE_OLD 794
+#define EXTIGY_FIRMWARE_SIZE_NEW 483
+
+static int snd_usb_extigy_boot_quirk(struct usb_device *dev, struct usb_interface *intf)
+{
+	struct usb_host_config *config = dev->actconfig;
+	int err;
+
+	if (le16_to_cpu(get_cfg_desc(config)->wTotalLength) == EXTIGY_FIRMWARE_SIZE_OLD ||
+	    le16_to_cpu(get_cfg_desc(config)->wTotalLength) == EXTIGY_FIRMWARE_SIZE_NEW) {
+		snd_printdd("sending Extigy boot sequence...\n");
+		/* Send message to force it to reconnect with full interface. */
+		err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev,0),
+				      0x10, 0x43, 0x0001, 0x000a, NULL, 0, 1000);
+		if (err < 0) snd_printdd("error sending boot message: %d\n", err);
+		err = usb_get_descriptor(dev, USB_DT_DEVICE, 0,
+				&dev->descriptor, sizeof(dev->descriptor));
+		config = dev->actconfig;
+		if (err < 0) snd_printdd("error usb_get_descriptor: %d\n", err);
+		err = usb_reset_configuration(dev);
+		if (err < 0) snd_printdd("error usb_reset_configuration: %d\n", err);
+		snd_printdd("extigy_boot: new boot length = %d\n",
+			    le16_to_cpu(get_cfg_desc(config)->wTotalLength));
+		return -ENODEV; /* quit this anyway */
+	}
+	return 0;
+}
+
+static int snd_usb_audigy2nx_boot_quirk(struct usb_device *dev)
+{
+	u8 buf = 1;
+
+	snd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0), 0x2a,
+			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_OTHER,
+			0, 0, &buf, 1, 1000);
+	if (buf == 0) {
+		snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), 0x29,
+				USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER,
+				1, 2000, NULL, 0, 1000);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+/*
+ * C-Media CM106/CM106+ have four 16-bit internal registers that are nicely
+ * documented in the device's data sheet.
+ */
+static int snd_usb_cm106_write_int_reg(struct usb_device *dev, int reg, u16 value)
+{
+	u8 buf[4];
+	buf[0] = 0x20;
+	buf[1] = value & 0xff;
+	buf[2] = (value >> 8) & 0xff;
+	buf[3] = reg;
+	return snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), USB_REQ_SET_CONFIGURATION,
+			       USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,
+			       0, 0, &buf, 4, 1000);
+}
+
+static int snd_usb_cm106_boot_quirk(struct usb_device *dev)
+{
+	/*
+	 * Enable line-out driver mode, set headphone source to front
+	 * channels, enable stereo mic.
+	 */
+	return snd_usb_cm106_write_int_reg(dev, 2, 0x8004);
+}
+
+/*
+ * C-Media CM6206 is based on CM106 with two additional
+ * registers that are not documented in the data sheet.
+ * Values here are chosen based on sniffing USB traffic
+ * under Windows.
+ */
+static int snd_usb_cm6206_boot_quirk(struct usb_device *dev)
+{
+	int err, reg;
+	int val[] = {0x200c, 0x3000, 0xf800, 0x143f, 0x0000, 0x3000};
+
+	for (reg = 0; reg < ARRAY_SIZE(val); reg++) {
+		err = snd_usb_cm106_write_int_reg(dev, reg, val[reg]);
+		if (err < 0)
+			return err;
+	}
+
+	return err;
+}
+
+/*
+ * This call will put the synth in "USB send" mode, i.e it will send MIDI
+ * messages through USB (this is disabled at startup). The synth will
+ * acknowledge by sending a sysex on endpoint 0x85 and by displaying a USB
+ * sign on its LCD. Values here are chosen based on sniffing USB traffic
+ * under Windows.
+ */
+static int snd_usb_accessmusic_boot_quirk(struct usb_device *dev)
+{
+	int err, actual_length;
+
+	/* "midi send" enable */
+	static const u8 seq[] = { 0x4e, 0x73, 0x52, 0x01 };
+
+	void *buf = kmemdup(seq, ARRAY_SIZE(seq), GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	err = usb_interrupt_msg(dev, usb_sndintpipe(dev, 0x05), buf,
+			ARRAY_SIZE(seq), &actual_length, 1000);
+	kfree(buf);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+/*
+ * Setup quirks
+ */
+#define AUDIOPHILE_SET			0x01 /* if set, parse device_setup */
+#define AUDIOPHILE_SET_DTS              0x02 /* if set, enable DTS Digital Output */
+#define AUDIOPHILE_SET_96K              0x04 /* 48-96KHz rate if set, 8-48KHz otherwise */
+#define AUDIOPHILE_SET_24B		0x08 /* 24bits sample if set, 16bits otherwise */
+#define AUDIOPHILE_SET_DI		0x10 /* if set, enable Digital Input */
+#define AUDIOPHILE_SET_MASK		0x1F /* bit mask for setup value */
+#define AUDIOPHILE_SET_24B_48K_DI	0x19 /* value for 24bits+48KHz+Digital Input */
+#define AUDIOPHILE_SET_24B_48K_NOTDI	0x09 /* value for 24bits+48KHz+No Digital Input */
+#define AUDIOPHILE_SET_16B_48K_DI	0x11 /* value for 16bits+48KHz+Digital Input */
+#define AUDIOPHILE_SET_16B_48K_NOTDI	0x01 /* value for 16bits+48KHz+No Digital Input */
+
+static int audiophile_skip_setting_quirk(struct snd_usb_audio *chip,
+					 int iface,
+					 int altno)
+{
+	/* Reset ALL ifaces to 0 altsetting.
+	 * Call it for every possible altsetting of every interface.
+	 */
+	usb_set_interface(chip->dev, iface, 0);
+
+	if (chip->setup & AUDIOPHILE_SET) {
+		if ((chip->setup & AUDIOPHILE_SET_DTS)
+		    && altno != 6)
+			return 1; /* skip this altsetting */
+		if ((chip->setup & AUDIOPHILE_SET_96K)
+		    && altno != 1)
+			return 1; /* skip this altsetting */
+		if ((chip->setup & AUDIOPHILE_SET_MASK) ==
+		    AUDIOPHILE_SET_24B_48K_DI && altno != 2)
+			return 1; /* skip this altsetting */
+		if ((chip->setup & AUDIOPHILE_SET_MASK) ==
+		    AUDIOPHILE_SET_24B_48K_NOTDI && altno != 3)
+			return 1; /* skip this altsetting */
+		if ((chip->setup & AUDIOPHILE_SET_MASK) ==
+		    AUDIOPHILE_SET_16B_48K_DI && altno != 4)
+			return 1; /* skip this altsetting */
+		if ((chip->setup & AUDIOPHILE_SET_MASK) ==
+		    AUDIOPHILE_SET_16B_48K_NOTDI && altno != 5)
+			return 1; /* skip this altsetting */
+	}
+
+	return 0; /* keep this altsetting */
+}
+
+int snd_usb_apply_interface_quirk(struct snd_usb_audio *chip,
+				  int iface,
+				  int altno)
+{
+	/* audiophile usb: skip altsets incompatible with device_setup */
+	if (chip->usb_id == USB_ID(0x0763, 0x2003))
+		return audiophile_skip_setting_quirk(chip, iface, altno);
+
+	return 0;
+}
+
+int snd_usb_apply_boot_quirk(struct usb_device *dev,
+			     struct usb_interface *intf,
+			     const struct snd_usb_audio_quirk *quirk)
+{
+	u32 id = USB_ID(le16_to_cpu(dev->descriptor.idVendor),
+			le16_to_cpu(dev->descriptor.idProduct));
+
+	/* SB Extigy needs special boot-up sequence */
+	/* if more models come, this will go to the quirk list. */
+	if (id == USB_ID(0x041e, 0x3000))
+		return snd_usb_extigy_boot_quirk(dev, intf);
+
+	/* SB Audigy 2 NX needs its own boot-up magic, too */
+	if (id == USB_ID(0x041e, 0x3020))
+		return snd_usb_audigy2nx_boot_quirk(dev);
+
+	/* C-Media CM106 / Turtle Beach Audio Advantage Roadie */
+	if (id == USB_ID(0x10f5, 0x0200))
+		return snd_usb_cm106_boot_quirk(dev);
+
+	/* C-Media CM6206 / CM106-Like Sound Device */
+	if (id == USB_ID(0x0d8c, 0x0102))
+		return snd_usb_cm6206_boot_quirk(dev);
+
+	/* Access Music VirusTI Desktop */
+	if (id == USB_ID(0x133e, 0x0815))
+		return snd_usb_accessmusic_boot_quirk(dev);
+
+	return 0;
+}
+
+/*
+ * check if the device uses big-endian samples
+ */
+int snd_usb_is_big_endian_format(struct snd_usb_audio *chip, struct audioformat *fp)
+{
+	switch (chip->usb_id) {
+	case USB_ID(0x0763, 0x2001): /* M-Audio Quattro: captured data only */
+		if (fp->endpoint & USB_DIR_IN)
+			return 1;
+		break;
+	case USB_ID(0x0763, 0x2003): /* M-Audio Audiophile USB */
+		if (chip->setup == 0x00 ||
+		    fp->altsetting==1 || fp->altsetting==2 || fp->altsetting==3)
+			return 1;
+	}
+	return 0;
+}
+
+/*
+ * For E-Mu 0404USB/0202USB/TrackerPre sample rate should be set for device,
+ * not for interface.
+ */
+
+enum {
+	EMU_QUIRK_SR_44100HZ = 0,
+	EMU_QUIRK_SR_48000HZ,
+	EMU_QUIRK_SR_88200HZ,
+	EMU_QUIRK_SR_96000HZ,
+	EMU_QUIRK_SR_176400HZ,
+	EMU_QUIRK_SR_192000HZ
+};
+
+static void set_format_emu_quirk(struct snd_usb_substream *subs,
+				 struct audioformat *fmt)
+{
+	unsigned char emu_samplerate_id = 0;
+
+	/* When capture is active
+	 * sample rate shouldn't be changed
+	 * by playback substream
+	 */
+	if (subs->direction == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (subs->stream->substream[SNDRV_PCM_STREAM_CAPTURE].interface != -1)
+			return;
+	}
+
+	switch (fmt->rate_min) {
+	case 48000:
+		emu_samplerate_id = EMU_QUIRK_SR_48000HZ;
+		break;
+	case 88200:
+		emu_samplerate_id = EMU_QUIRK_SR_88200HZ;
+		break;
+	case 96000:
+		emu_samplerate_id = EMU_QUIRK_SR_96000HZ;
+		break;
+	case 176400:
+		emu_samplerate_id = EMU_QUIRK_SR_176400HZ;
+		break;
+	case 192000:
+		emu_samplerate_id = EMU_QUIRK_SR_192000HZ;
+		break;
+	default:
+		emu_samplerate_id = EMU_QUIRK_SR_44100HZ;
+		break;
+	}
+	snd_emuusb_set_samplerate(subs->stream->chip, emu_samplerate_id);
+}
+
+void snd_usb_set_format_quirk(struct snd_usb_substream *subs,
+			      struct audioformat *fmt)
+{
+	switch (subs->stream->chip->usb_id) {
+	case USB_ID(0x041e, 0x3f02): /* E-Mu 0202 USB */
+	case USB_ID(0x041e, 0x3f04): /* E-Mu 0404 USB */
+	case USB_ID(0x041e, 0x3f0a): /* E-Mu Tracker Pre */
+		set_format_emu_quirk(subs, fmt);
+		break;
+	}
+}
+
