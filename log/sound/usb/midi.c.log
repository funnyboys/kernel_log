commit 9b7e5208a941e2e491a83eb5fa83d889e888fa2f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jul 10 18:06:56 2020 +0200

    ALSA: usb-audio: Fix race against the error recovery URB submission
    
    USB MIDI driver has an error recovery mechanism to resubmit the URB in
    the delayed timer handler, and this may race with the standard start /
    stop operations.  Although both start and stop operations themselves
    don't race with each other due to the umidi->mutex protection, but
    this isn't applied to the timer handler.
    
    For fixing this potential race, the following changes are applied:
    
    - Since the timer handler can't use the mutex, we apply the
      umidi->disc_lock protection at each input stream URB submission;
      this also needs to change the GFP flag to GFP_ATOMIC
    - Add a check of the URB refcount and skip if already submitted
    - Move the timer cancel call at disconnection to the beginning of the
      procedure; this assures the in-flight timer handler is gone properly
      before killing all pending URBs
    
    Reported-by: syzbot+0f4ecfe6a2c322c81728@syzkaller.appspotmail.com
    Reported-by: syzbot+5f1d24c49c1d2c427497@syzkaller.appspotmail.com
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200710160656.16819-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 047b90595d65..354f57692938 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1499,6 +1499,8 @@ void snd_usbmidi_disconnect(struct list_head *p)
 	spin_unlock_irq(&umidi->disc_lock);
 	up_write(&umidi->disc_rwsem);
 
+	del_timer_sync(&umidi->error_timer);
+
 	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
 		struct snd_usb_midi_endpoint *ep = &umidi->endpoints[i];
 		if (ep->out)
@@ -1525,7 +1527,6 @@ void snd_usbmidi_disconnect(struct list_head *p)
 			ep->in = NULL;
 		}
 	}
-	del_timer_sync(&umidi->error_timer);
 }
 EXPORT_SYMBOL(snd_usbmidi_disconnect);
 
@@ -2301,16 +2302,22 @@ void snd_usbmidi_input_stop(struct list_head *p)
 }
 EXPORT_SYMBOL(snd_usbmidi_input_stop);
 
-static void snd_usbmidi_input_start_ep(struct snd_usb_midi_in_endpoint *ep)
+static void snd_usbmidi_input_start_ep(struct snd_usb_midi *umidi,
+				       struct snd_usb_midi_in_endpoint *ep)
 {
 	unsigned int i;
+	unsigned long flags;
 
 	if (!ep)
 		return;
 	for (i = 0; i < INPUT_URBS; ++i) {
 		struct urb *urb = ep->urbs[i];
-		urb->dev = ep->umidi->dev;
-		snd_usbmidi_submit_urb(urb, GFP_KERNEL);
+		spin_lock_irqsave(&umidi->disc_lock, flags);
+		if (!atomic_read(&urb->use_count)) {
+			urb->dev = ep->umidi->dev;
+			snd_usbmidi_submit_urb(urb, GFP_ATOMIC);
+		}
+		spin_unlock_irqrestore(&umidi->disc_lock, flags);
 	}
 }
 
@@ -2326,7 +2333,7 @@ void snd_usbmidi_input_start(struct list_head *p)
 	if (umidi->input_running || !umidi->opened[1])
 		return;
 	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)
-		snd_usbmidi_input_start_ep(umidi->endpoints[i].in);
+		snd_usbmidi_input_start_ep(umidi, umidi->endpoints[i].in);
 	umidi->input_running = 1;
 }
 EXPORT_SYMBOL(snd_usbmidi_input_start);

commit 5c6cd7021a05a02fcf37f360592d7c18d4d807fb
Author: Andreas Steinmetz <ast@domdv.de>
Date:   Tue Mar 31 14:25:54 2020 +0200

    ALSA: usb-audio: Fix case when USB MIDI interface has more than one extra endpoint descriptor
    
    The Miditech MIDIFACE 16x16 (USB ID 1290:1749) has more than one extra
    endpoint descriptor.
    
    The first extra descriptor is: 0x06 0x30 0x00 0x00 0x00 0x00
    
    As the code in snd_usbmidi_get_ms_info() looks only at the
    first extra descriptor to find USB_DT_CS_ENDPOINT the device
    as such is recognized but there is neither input nor output
    configured.
    
    The patch iterates through the extra descriptors to find the
    proper one. With this patch the device is correctly configured.
    
    Signed-off-by: Andreas Steinmetz <ast@domdv.de>
    Link: https://lore.kernel.org/r/1c3b431a86f69e1d60745b6110cdb93c299f120b.camel@domdv.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index be5c597ed40c..047b90595d65 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1826,6 +1826,28 @@ static int snd_usbmidi_create_endpoints(struct snd_usb_midi *umidi,
 	return 0;
 }
 
+static struct usb_ms_endpoint_descriptor *find_usb_ms_endpoint_descriptor(
+					struct usb_host_endpoint *hostep)
+{
+	unsigned char *extra = hostep->extra;
+	int extralen = hostep->extralen;
+
+	while (extralen > 3) {
+		struct usb_ms_endpoint_descriptor *ms_ep =
+				(struct usb_ms_endpoint_descriptor *)extra;
+
+		if (ms_ep->bLength > 3 &&
+		    ms_ep->bDescriptorType == USB_DT_CS_ENDPOINT &&
+		    ms_ep->bDescriptorSubtype == UAC_MS_GENERAL)
+			return ms_ep;
+		if (!extra[0])
+			break;
+		extralen -= extra[0];
+		extra += extra[0];
+	}
+	return NULL;
+}
+
 /*
  * Returns MIDIStreaming device capabilities.
  */
@@ -1863,11 +1885,8 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi *umidi,
 		ep = get_ep_desc(hostep);
 		if (!usb_endpoint_xfer_bulk(ep) && !usb_endpoint_xfer_int(ep))
 			continue;
-		ms_ep = (struct usb_ms_endpoint_descriptor *)hostep->extra;
-		if (hostep->extralen < 4 ||
-		    ms_ep->bLength < 4 ||
-		    ms_ep->bDescriptorType != USB_DT_CS_ENDPOINT ||
-		    ms_ep->bDescriptorSubtype != UAC_MS_GENERAL)
+		ms_ep = find_usb_ms_endpoint_descriptor(hostep);
+		if (!ms_ep)
 			continue;
 		if (usb_endpoint_dir_out(ep)) {
 			if (endpoints[epidx].out_ep) {

commit 6c8019d08e0e84ecad78f726c737dc6a49b58b57
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Feb 11 13:42:24 2020 -0600

    ALSA: usb-midi: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertenly introduced[3] to the codebase from now on.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Link: https://lore.kernel.org/r/20200211194224.GA9383@embeddedor
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 392e5fda680c..be5c597ed40c 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -91,7 +91,7 @@ struct usb_ms_endpoint_descriptor {
 	__u8  bDescriptorType;
 	__u8  bDescriptorSubtype;
 	__u8  bNumEmbMIDIJack;
-	__u8  baAssocJackID[0];
+	__u8  baAssocJackID[];
 } __attribute__ ((packed));
 
 struct snd_usb_midi_in_endpoint;

commit 8be03a7177c36bfc05bbe9f4949cdeba57f1c2ab
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 09:19:00 2020 +0100

    ALSA: usb-audio: Use lower hex numbers for IDs
    
    For consistency reason, make all hex numbers with lower alphabets for
    USB ID entries.  It improves grep-ability and reduces careless
    mistakes.
    
    Link: https://lore.kernel.org/r/20200105081900.21870-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index b737f0ec77d0..392e5fda680c 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1408,8 +1408,8 @@ static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi *umidi,
 		/*
 		 * Some devices only work with 9 bytes packet size:
 		 */
-	case USB_ID(0x0644, 0x800E): /* Tascam US-122L */
-	case USB_ID(0x0644, 0x800F): /* Tascam US-144 */
+	case USB_ID(0x0644, 0x800e): /* Tascam US-122L */
+	case USB_ID(0x0644, 0x800f): /* Tascam US-144 */
 		ep->max_transfer = 9;
 		break;
 	}

commit 6aea5702e27ebc85747d6e4943a0c378e1752be0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 13 08:20:43 2018 +0200

    ALSA: rawmidi: A lightweight function to discard pending bytes
    
    For discarding the pending bytes on rawmidi, we process with a loop of
    snd_rawmidi_transmit() which is just a waste of CPU power.
    Implement a lightweight API function to discard the pending bytes and
    the proceed the ring buffer instantly, and use it instead of open
    codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index dcfc546d81b9..b737f0ec77d0 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1175,8 +1175,7 @@ static void snd_usbmidi_output_trigger(struct snd_rawmidi_substream *substream,
 		if (port->ep->umidi->disconnected) {
 			/* gobble up remaining bytes to prevent wait in
 			 * snd_rawmidi_drain_output */
-			while (!snd_rawmidi_transmit_empty(substream))
-				snd_rawmidi_transmit_ack(substream, 1);
+			snd_rawmidi_proceed(substream);
 			return;
 		}
 		tasklet_schedule(&port->ep->tasklet);

commit 1259d239799bf9c898091d92adc4317f2c3d74ad
Author: John Ogness <john.ogness@linutronix.de>
Date:   Sun Jul 1 17:28:08 2018 +0200

    ALSA: usb-midi: use irqsave() in USB's complete callback
    
    The USB completion callback does not disable interrupts while acquiring
    the lock. We want to remove the local_irq_disable() invocation from
    __usb_hcd_giveback_urb() and therefore it is required for the callback
    handler to disable the interrupts while acquiring the lock.
    The callback may be invoked either in IRQ or BH context depending on the
    USB host controller.
    Use the _irqsave() variant of the locking primitives.
    
    Signed-off-by: John Ogness <john.ogness@linutronix.de>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 2c1aaa3292bf..dcfc546d81b9 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -281,15 +281,16 @@ static void snd_usbmidi_out_urb_complete(struct urb *urb)
 	struct out_urb_context *context = urb->context;
 	struct snd_usb_midi_out_endpoint *ep = context->ep;
 	unsigned int urb_index;
+	unsigned long flags;
 
-	spin_lock(&ep->buffer_lock);
+	spin_lock_irqsave(&ep->buffer_lock, flags);
 	urb_index = context - ep->urbs;
 	ep->active_urbs &= ~(1 << urb_index);
 	if (unlikely(ep->drain_urbs)) {
 		ep->drain_urbs &= ~(1 << urb_index);
 		wake_up(&ep->drain_wait);
 	}
-	spin_unlock(&ep->buffer_lock);
+	spin_unlock_irqrestore(&ep->buffer_lock, flags);
 	if (urb->status < 0) {
 		int err = snd_usbmidi_urb_error(urb);
 		if (err < 0) {

commit a6162afa7135548973ba633c7795db9648fbd4a2
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 16:07:31 2017 -0700

    ALSA: usb-audio: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 7ab25de5ca0a..2c1aaa3292bf 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -352,9 +352,9 @@ static void snd_usbmidi_out_tasklet(unsigned long data)
 }
 
 /* called after transfers had been interrupted due to some USB error */
-static void snd_usbmidi_error_timer(unsigned long data)
+static void snd_usbmidi_error_timer(struct timer_list *t)
 {
-	struct snd_usb_midi *umidi = (struct snd_usb_midi *)data;
+	struct snd_usb_midi *umidi = from_timer(umidi, t, error_timer);
 	unsigned int i, j;
 
 	spin_lock(&umidi->disc_lock);
@@ -2369,8 +2369,7 @@ int __snd_usbmidi_create(struct snd_card *card,
 		usb_id = USB_ID(le16_to_cpu(umidi->dev->descriptor.idVendor),
 			       le16_to_cpu(umidi->dev->descriptor.idProduct));
 	umidi->usb_id = usb_id;
-	setup_timer(&umidi->error_timer, snd_usbmidi_error_timer,
-		    (unsigned long)umidi);
+	timer_setup(&umidi->error_timer, snd_usbmidi_error_timer, 0);
 
 	/* detect the endpoint(s) to use */
 	memset(endpoints, 0, sizeof(endpoints));

commit 738d9edcfd44f154924692e54109fb439fcf8bdd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 4 17:22:05 2017 +0200

    ALSA: usb-audio: Add sanity checks for invalid EPs
    
    USB-audio driver may set up a URB containing the fixed EP without
    validating its presence for some non-class-compliant devices.  This
    may end up with an oops-like kernel warning when submitted.
    
    For avoiding it, this patch adds the call of the new sanity-check
    helper for URBs.  The checks are needed only for MIDI I/O as the other
    places have already some other checks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index a92e2b2a91ec..7ab25de5ca0a 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1282,6 +1282,7 @@ static int snd_usbmidi_in_endpoint_create(struct snd_usb_midi *umidi,
 	unsigned int pipe;
 	int length;
 	unsigned int i;
+	int err;
 
 	rep->in = NULL;
 	ep = kzalloc(sizeof(*ep), GFP_KERNEL);
@@ -1292,8 +1293,8 @@ static int snd_usbmidi_in_endpoint_create(struct snd_usb_midi *umidi,
 	for (i = 0; i < INPUT_URBS; ++i) {
 		ep->urbs[i] = usb_alloc_urb(0, GFP_KERNEL);
 		if (!ep->urbs[i]) {
-			snd_usbmidi_in_endpoint_delete(ep);
-			return -ENOMEM;
+			err = -ENOMEM;
+			goto error;
 		}
 	}
 	if (ep_info->in_interval)
@@ -1305,8 +1306,8 @@ static int snd_usbmidi_in_endpoint_create(struct snd_usb_midi *umidi,
 		buffer = usb_alloc_coherent(umidi->dev, length, GFP_KERNEL,
 					    &ep->urbs[i]->transfer_dma);
 		if (!buffer) {
-			snd_usbmidi_in_endpoint_delete(ep);
-			return -ENOMEM;
+			err = -ENOMEM;
+			goto error;
 		}
 		if (ep_info->in_interval)
 			usb_fill_int_urb(ep->urbs[i], umidi->dev,
@@ -1318,10 +1319,20 @@ static int snd_usbmidi_in_endpoint_create(struct snd_usb_midi *umidi,
 					  pipe, buffer, length,
 					  snd_usbmidi_in_urb_complete, ep);
 		ep->urbs[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
+		err = usb_urb_ep_type_check(ep->urbs[i]);
+		if (err < 0) {
+			dev_err(&umidi->dev->dev, "invalid MIDI in EP %x\n",
+				ep_info->in_ep);
+			goto error;
+		}
 	}
 
 	rep->in = ep;
 	return 0;
+
+ error:
+	snd_usbmidi_in_endpoint_delete(ep);
+	return -ENOMEM;
 }
 
 /*
@@ -1357,6 +1368,7 @@ static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi *umidi,
 	unsigned int i;
 	unsigned int pipe;
 	void *buffer;
+	int err;
 
 	rep->out = NULL;
 	ep = kzalloc(sizeof(*ep), GFP_KERNEL);
@@ -1367,8 +1379,8 @@ static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi *umidi,
 	for (i = 0; i < OUTPUT_URBS; ++i) {
 		ep->urbs[i].urb = usb_alloc_urb(0, GFP_KERNEL);
 		if (!ep->urbs[i].urb) {
-			snd_usbmidi_out_endpoint_delete(ep);
-			return -ENOMEM;
+			err = -ENOMEM;
+			goto error;
 		}
 		ep->urbs[i].ep = ep;
 	}
@@ -1406,8 +1418,8 @@ static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi *umidi,
 					    ep->max_transfer, GFP_KERNEL,
 					    &ep->urbs[i].urb->transfer_dma);
 		if (!buffer) {
-			snd_usbmidi_out_endpoint_delete(ep);
-			return -ENOMEM;
+			err = -ENOMEM;
+			goto error;
 		}
 		if (ep_info->out_interval)
 			usb_fill_int_urb(ep->urbs[i].urb, umidi->dev,
@@ -1419,6 +1431,12 @@ static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi *umidi,
 					  pipe, buffer, ep->max_transfer,
 					  snd_usbmidi_out_urb_complete,
 					  &ep->urbs[i]);
+		err = usb_urb_ep_type_check(ep->urbs[i].urb);
+		if (err < 0) {
+			dev_err(&umidi->dev->dev, "invalid MIDI out EP %x\n",
+				ep_info->out_ep);
+			goto error;
+		}
 		ep->urbs[i].urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
 	}
 
@@ -1437,6 +1455,10 @@ static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi *umidi,
 
 	rep->out = ep;
 	return 0;
+
+ error:
+	snd_usbmidi_out_endpoint_delete(ep);
+	return err;
 }
 
 /*

commit 5659f244584cf414aa08c2bcf4dfa52fd972df64
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 31 10:59:12 2017 +0200

    ALSA: usb-audio: Put missing KERN_CONT prefix
    
    The usb-audio driver has a debug printk code without proper KERN_
    prefix.  On recent kernels, KERN_CONT prefix is mandatory for
    continued output lines.  Put it properly.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index bd9d02268724..a92e2b2a91ec 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -242,8 +242,8 @@ static void dump_urb(const char *type, const u8 *data, int length)
 {
 	snd_printk(KERN_DEBUG "%s packet: [", type);
 	for (; length > 0; ++data, --length)
-		printk(" %02x", *data);
-	printk(" ]\n");
+		printk(KERN_CONT " %02x", *data);
+	printk(KERN_CONT " ]\n");
 }
 #else
 #define dump_urb(type, data, length) /* nothing */

commit 731209cc041779faac963578d901cb1caacbd738
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Wed Aug 23 12:20:07 2017 +0200

    ALSA: usb-midi: Use common error handling code in __snd_usbmidi_create()
    
    Add jump targets so that a bit of exception handling can be better reused
    at the end of this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index a35f41467237..bd9d02268724 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -2435,10 +2435,8 @@ int __snd_usbmidi_create(struct snd_card *card,
 		err = -ENXIO;
 		break;
 	}
-	if (err < 0) {
-		kfree(umidi);
-		return err;
-	}
+	if (err < 0)
+		goto free_midi;
 
 	/* create rawmidi device */
 	out_ports = 0;
@@ -2448,23 +2446,25 @@ int __snd_usbmidi_create(struct snd_card *card,
 		in_ports += hweight16(endpoints[i].in_cables);
 	}
 	err = snd_usbmidi_create_rawmidi(umidi, out_ports, in_ports);
-	if (err < 0) {
-		kfree(umidi);
-		return err;
-	}
+	if (err < 0)
+		goto free_midi;
 
 	/* create endpoint/port structures */
 	if (quirk && quirk->type == QUIRK_MIDI_MIDIMAN)
 		err = snd_usbmidi_create_endpoints_midiman(umidi, &endpoints[0]);
 	else
 		err = snd_usbmidi_create_endpoints(umidi, endpoints);
-	if (err < 0) {
-		return err;
-	}
+	if (err < 0)
+		goto exit;
 
 	usb_autopm_get_interface_no_resume(umidi->iface);
 
 	list_add_tail(&umidi->list, midi_list);
 	return 0;
+
+free_midi:
+	kfree(umidi);
+exit:
+	return err;
 }
 EXPORT_SYMBOL(__snd_usbmidi_create);

commit 8fdaebbb83b4e734c7ec1fcab5f1b26ec264965d
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Wed Apr 12 18:38:06 2017 +0530

    ALSA: usb-audio: constify snd_kcontrol_new structures
    
    Declare snd_kcontrol_new strcutures as const as they are only passed as
    an argument to the function snd_ctl_new1. This argument is of type const,
    so snd_kcontrol_new structures having this property can be made const too.
    Done using Coccinelle:
    
    @r disable optional_qualifier@
    identifier x;
    position p;
    @@
    static struct snd_kcontrol_new x@p={...};
    
    @ok@
    identifier r.x;
    position p;
    @@
    snd_ctl_new1(&x@p,...)
    
    @bad@
    position p != {r.p,ok.p};
    identifier r.x;
    @@
    x@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.x;
    @@
    +const
    struct snd_kcontrol_new x;
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 6e763bc8d7db..a35f41467237 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1922,7 +1922,7 @@ static int roland_load_put(struct snd_kcontrol *kcontrol,
 	return changed;
 }
 
-static struct snd_kcontrol_new roland_load_ctl = {
+static const struct snd_kcontrol_new roland_load_ctl = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "MIDI Input Mode",
 	.info = roland_load_info,

commit f43e5407e4184ef0e5a31272f80ca893cb5ee24c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 5 17:30:12 2017 +0100

    ALSA: usb: Constify snd_rawmidi_ops
    
    Now snd_rawmidi_ops is maintained as a const pointer in snd_rawmidi,
    we can constify the definitions.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 7ba92921bf28..6e763bc8d7db 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1234,14 +1234,14 @@ static void snd_usbmidi_input_trigger(struct snd_rawmidi_substream *substream,
 		clear_bit(substream->number, &umidi->input_triggered);
 }
 
-static struct snd_rawmidi_ops snd_usbmidi_output_ops = {
+static const struct snd_rawmidi_ops snd_usbmidi_output_ops = {
 	.open = snd_usbmidi_output_open,
 	.close = snd_usbmidi_output_close,
 	.trigger = snd_usbmidi_output_trigger,
 	.drain = snd_usbmidi_output_drain,
 };
 
-static struct snd_rawmidi_ops snd_usbmidi_input_ops = {
+static const struct snd_rawmidi_ops snd_usbmidi_input_ops = {
 	.open = snd_usbmidi_input_open,
 	.close = snd_usbmidi_input_close,
 	.trigger = snd_usbmidi_input_trigger

commit 89e448b33a101dfc7218f3181bc3095af850db7a
Author: Oliver Neukum <ONeukum@suse.com>
Date:   Wed May 4 14:18:40 2016 +0200

    ALSA: usb-midi: correct speed checking
    
    Allow for SS+ USB devices
    
    Signed-off-by: Oliver Neukum <oneukum@suse.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 47de8af42f16..7ba92921bf28 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -911,6 +911,7 @@ static void snd_usbmidi_us122l_output(struct snd_usb_midi_out_endpoint *ep,
 	switch (snd_usb_get_speed(ep->umidi->dev)) {
 	case USB_SPEED_HIGH:
 	case USB_SPEED_SUPER:
+	case USB_SPEED_SUPER_PLUS:
 		count = 1;
 		break;
 	default:

commit d61b04f801e6005182d432ebe4a0211c1d6feadd
Merge: 30ff5957c3f1 473f41456452
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 26 20:26:09 2016 +0100

    Merge branch 'for-linus' into for-next

commit 07d86ca93db7e5cdf4743564d98292042ec21af7
Author: Andrey Konovalov <andreyknvl@gmail.com>
Date:   Sat Feb 13 11:08:06 2016 +0300

    ALSA: usb-audio: avoid freeing umidi object twice
    
    The 'umidi' object will be free'd on the error path by snd_usbmidi_free()
    when tearing down the rawmidi interface. So we shouldn't try to free it
    in snd_usbmidi_create() after having registered the rawmidi interface.
    
    Found by KASAN.
    
    Signed-off-by: Andrey Konovalov <andreyknvl@gmail.com>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index cc39f63299ef..007cf5831121 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -2455,7 +2455,6 @@ int snd_usbmidi_create(struct snd_card *card,
 	else
 		err = snd_usbmidi_create_endpoints(umidi, endpoints);
 	if (err < 0) {
-		snd_usbmidi_free(umidi);
 		return err;
 	}
 

commit 79289e24194a9d099bf18f200894832c5760cd83
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 11 11:33:34 2016 +0100

    ALSA: usb-audio: Refer to chip->usb_id for quirks and MIDI creation
    
    This is a preliminary patch for the later change to allow a better
    quirk ID management.  In the current USB-audio code, there are a few
    places looking at usb_device idVendor and idProduct fields directly
    even though we have already a static member in snd_usb_audio.usb_id.
    This patch modifies such codes to refer to the latter field.
    
    For achieving this, two slightly intensive changes have been done:
    - The snd_usb_audio object is set/reset via dev_getdrv() for the given
      USB device; it's needed for minimizing the changes for some existing
      quirks that take only usb_device object.
    
    - __snd_usbmidi_create() is introduced to receive the pre-given usb_id
      argument.  The exported snd_usbmidi_create() is unchanged by calling
      this new function internally.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index cc39f63299ef..b79875ebec1e 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -2320,10 +2320,11 @@ EXPORT_SYMBOL(snd_usbmidi_resume);
 /*
  * Creates and registers everything needed for a MIDI streaming interface.
  */
-int snd_usbmidi_create(struct snd_card *card,
-		       struct usb_interface *iface,
-		       struct list_head *midi_list,
-		       const struct snd_usb_audio_quirk *quirk)
+int __snd_usbmidi_create(struct snd_card *card,
+			 struct usb_interface *iface,
+			 struct list_head *midi_list,
+			 const struct snd_usb_audio_quirk *quirk,
+			 unsigned int usb_id)
 {
 	struct snd_usb_midi *umidi;
 	struct snd_usb_midi_endpoint_info endpoints[MIDI_MAX_ENDPOINTS];
@@ -2341,8 +2342,10 @@ int snd_usbmidi_create(struct snd_card *card,
 	spin_lock_init(&umidi->disc_lock);
 	init_rwsem(&umidi->disc_rwsem);
 	mutex_init(&umidi->mutex);
-	umidi->usb_id = USB_ID(le16_to_cpu(umidi->dev->descriptor.idVendor),
+	if (!usb_id)
+		usb_id = USB_ID(le16_to_cpu(umidi->dev->descriptor.idVendor),
 			       le16_to_cpu(umidi->dev->descriptor.idProduct));
+	umidi->usb_id = usb_id;
 	setup_timer(&umidi->error_timer, snd_usbmidi_error_timer,
 		    (unsigned long)umidi);
 
@@ -2464,4 +2467,4 @@ int snd_usbmidi_create(struct snd_card *card,
 	list_add_tail(&umidi->list, midi_list);
 	return 0;
 }
-EXPORT_SYMBOL(snd_usbmidi_create);
+EXPORT_SYMBOL(__snd_usbmidi_create);

commit 17074c1a5f1bbbf352fe071b2947a498db42661f
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Dec 11 15:52:37 2015 +0100

    ALSA: usb-audio: constify usb_protocol_ops structures
    
    The usb_protocol_ops structures are never modified, so declare them as
    const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index ee212e71f180..cc39f63299ef 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -112,7 +112,7 @@ struct snd_usb_midi {
 	struct usb_interface *iface;
 	const struct snd_usb_audio_quirk *quirk;
 	struct snd_rawmidi *rmidi;
-	struct usb_protocol_ops *usb_protocol_ops;
+	const struct usb_protocol_ops *usb_protocol_ops;
 	struct list_head list;
 	struct timer_list error_timer;
 	spinlock_t disc_lock;
@@ -671,31 +671,32 @@ static void snd_usbmidi_standard_output(struct snd_usb_midi_out_endpoint *ep,
 	}
 }
 
-static struct usb_protocol_ops snd_usbmidi_standard_ops = {
+static const struct usb_protocol_ops snd_usbmidi_standard_ops = {
 	.input = snd_usbmidi_standard_input,
 	.output = snd_usbmidi_standard_output,
 	.output_packet = snd_usbmidi_output_standard_packet,
 };
 
-static struct usb_protocol_ops snd_usbmidi_midiman_ops = {
+static const struct usb_protocol_ops snd_usbmidi_midiman_ops = {
 	.input = snd_usbmidi_midiman_input,
 	.output = snd_usbmidi_standard_output,
 	.output_packet = snd_usbmidi_output_midiman_packet,
 };
 
-static struct usb_protocol_ops snd_usbmidi_maudio_broken_running_status_ops = {
+static const
+struct usb_protocol_ops snd_usbmidi_maudio_broken_running_status_ops = {
 	.input = snd_usbmidi_maudio_broken_running_status_input,
 	.output = snd_usbmidi_standard_output,
 	.output_packet = snd_usbmidi_output_standard_packet,
 };
 
-static struct usb_protocol_ops snd_usbmidi_cme_ops = {
+static const struct usb_protocol_ops snd_usbmidi_cme_ops = {
 	.input = snd_usbmidi_cme_input,
 	.output = snd_usbmidi_standard_output,
 	.output_packet = snd_usbmidi_output_standard_packet,
 };
 
-static struct usb_protocol_ops snd_usbmidi_ch345_broken_sysex_ops = {
+static const struct usb_protocol_ops snd_usbmidi_ch345_broken_sysex_ops = {
 	.input = ch345_broken_sysex_input,
 	.output = snd_usbmidi_standard_output,
 	.output_packet = snd_usbmidi_output_standard_packet,
@@ -795,7 +796,7 @@ static void snd_usbmidi_akai_output(struct snd_usb_midi_out_endpoint *ep,
 	}
 }
 
-static struct usb_protocol_ops snd_usbmidi_akai_ops = {
+static const struct usb_protocol_ops snd_usbmidi_akai_ops = {
 	.input = snd_usbmidi_akai_input,
 	.output = snd_usbmidi_akai_output,
 };
@@ -835,7 +836,7 @@ static void snd_usbmidi_novation_output(struct snd_usb_midi_out_endpoint *ep,
 	urb->transfer_buffer_length = 2 + count;
 }
 
-static struct usb_protocol_ops snd_usbmidi_novation_ops = {
+static const struct usb_protocol_ops snd_usbmidi_novation_ops = {
 	.input = snd_usbmidi_novation_input,
 	.output = snd_usbmidi_novation_output,
 };
@@ -867,7 +868,7 @@ static void snd_usbmidi_raw_output(struct snd_usb_midi_out_endpoint *ep,
 	urb->transfer_buffer_length = count;
 }
 
-static struct usb_protocol_ops snd_usbmidi_raw_ops = {
+static const struct usb_protocol_ops snd_usbmidi_raw_ops = {
 	.input = snd_usbmidi_raw_input,
 	.output = snd_usbmidi_raw_output,
 };
@@ -883,7 +884,7 @@ static void snd_usbmidi_ftdi_input(struct snd_usb_midi_in_endpoint *ep,
 		snd_usbmidi_input_data(ep, 0, buffer + 2, buffer_length - 2);
 }
 
-static struct usb_protocol_ops snd_usbmidi_ftdi_ops = {
+static const struct usb_protocol_ops snd_usbmidi_ftdi_ops = {
 	.input = snd_usbmidi_ftdi_input,
 	.output = snd_usbmidi_raw_output,
 };
@@ -927,7 +928,7 @@ static void snd_usbmidi_us122l_output(struct snd_usb_midi_out_endpoint *ep,
 	urb->transfer_buffer_length = ep->max_transfer;
 }
 
-static struct usb_protocol_ops snd_usbmidi_122l_ops = {
+static const struct usb_protocol_ops snd_usbmidi_122l_ops = {
 	.input = snd_usbmidi_us122l_input,
 	.output = snd_usbmidi_us122l_output,
 };
@@ -1060,7 +1061,7 @@ static void snd_usbmidi_emagic_output(struct snd_usb_midi_out_endpoint *ep,
 	urb->transfer_buffer_length = ep->max_transfer - buf_free;
 }
 
-static struct usb_protocol_ops snd_usbmidi_emagic_ops = {
+static const struct usb_protocol_ops snd_usbmidi_emagic_ops = {
 	.input = snd_usbmidi_emagic_input,
 	.output = snd_usbmidi_emagic_output,
 	.init_out_endpoint = snd_usbmidi_emagic_init_out,

commit efdbe3c3edb6c8c98a8be863f60916780a5375c1
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Nov 22 08:55:07 2015 +0100

    ALSA: midi: constify snd_rawmidi_global_ops structures
    
    The snd_rawmidi_global_ops structures are never modified, so declare them
    as const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 5b4c58c3e2c5..ee212e71f180 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -2206,7 +2206,7 @@ static int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi *umidi,
 	return 0;
 }
 
-static struct snd_rawmidi_global_ops snd_usbmidi_ops = {
+static const struct snd_rawmidi_global_ops snd_usbmidi_ops = {
 	.get_port_info = snd_usbmidi_get_port_info,
 };
 

commit a91e627e3f0ed820b11d86cdc04df38f65f33a70
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 15 22:39:08 2015 +0100

    ALSA: usb-audio: work around CH345 input SysEx corruption
    
    One of the many faults of the QinHeng CH345 USB MIDI interface chip is
    that it does not handle received SysEx messages correctly -- every second
    event packet has a wrong code index number, which is the one from the last
    seen message, instead of 4.  For example, the two messages "FE F0 01 02 03
    04 05 06 07 08 09 0A 0B 0C 0D 0E F7" result in the following event
    packets:
    
    correct:       CH345:
    0F FE 00 00    0F FE 00 00
    04 F0 01 02    04 F0 01 02
    04 03 04 05    0F 03 04 05
    04 06 07 08    04 06 07 08
    04 09 0A 0B    0F 09 0A 0B
    04 0C 0D 0E    04 0C 0D 0E
    05 F7 00 00    05 F7 00 00
    
    A class-compliant driver must interpret an event packet with CIN 15 as
    having a single data byte, so the other two bytes would be ignored.  The
    message received by the host would then be missing two bytes out of six;
    in this example, "F0 01 02 03 06 07 08 09 0C 0D 0E F7".
    
    These corrupted SysEx event packages contain only data bytes, while the
    CH345 uses event packets with a correct CIN value only for messages with
    a status byte, so it is possible to distinguish between these two cases by
    checking for the presence of this status byte.
    
    (Other bugs in the CH345's input handling, such as the corruption resulting
    from running status, cannot be worked around.)
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 010094abf752..5b4c58c3e2c5 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -174,6 +174,8 @@ struct snd_usb_midi_in_endpoint {
 		u8 running_status_length;
 	} ports[0x10];
 	u8 seen_f5;
+	bool in_sysex;
+	u8 last_cin;
 	u8 error_resubmit;
 	int current_port;
 };
@@ -467,6 +469,39 @@ static void snd_usbmidi_maudio_broken_running_status_input(
 		}
 }
 
+/*
+ * QinHeng CH345 is buggy: every second packet inside a SysEx has not CIN 4
+ * but the previously seen CIN, but still with three data bytes.
+ */
+static void ch345_broken_sysex_input(struct snd_usb_midi_in_endpoint *ep,
+				     uint8_t *buffer, int buffer_length)
+{
+	unsigned int i, cin, length;
+
+	for (i = 0; i + 3 < buffer_length; i += 4) {
+		if (buffer[i] == 0 && i > 0)
+			break;
+		cin = buffer[i] & 0x0f;
+		if (ep->in_sysex &&
+		    cin == ep->last_cin &&
+		    (buffer[i + 1 + (cin == 0x6)] & 0x80) == 0)
+			cin = 0x4;
+#if 0
+		if (buffer[i + 1] == 0x90) {
+			/*
+			 * Either a corrupted running status or a real note-on
+			 * message; impossible to detect reliably.
+			 */
+		}
+#endif
+		length = snd_usbmidi_cin_length[cin];
+		snd_usbmidi_input_data(ep, 0, &buffer[i + 1], length);
+		ep->in_sysex = cin == 0x4;
+		if (!ep->in_sysex)
+			ep->last_cin = cin;
+	}
+}
+
 /*
  * CME protocol: like the standard protocol, but SysEx commands are sent as a
  * single USB packet preceded by a 0x0F byte.
@@ -660,6 +695,12 @@ static struct usb_protocol_ops snd_usbmidi_cme_ops = {
 	.output_packet = snd_usbmidi_output_standard_packet,
 };
 
+static struct usb_protocol_ops snd_usbmidi_ch345_broken_sysex_ops = {
+	.input = ch345_broken_sysex_input,
+	.output = snd_usbmidi_standard_output,
+	.output_packet = snd_usbmidi_output_standard_packet,
+};
+
 /*
  * AKAI MPD16 protocol:
  *
@@ -2380,6 +2421,7 @@ int snd_usbmidi_create(struct snd_card *card,
 		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
 		break;
 	case QUIRK_MIDI_CH345:
+		umidi->usb_protocol_ops = &snd_usbmidi_ch345_broken_sysex_ops;
 		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
 		break;
 	default:

commit 1ca8b201309d842642f221db7f02f71c0af5be2d
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 15 22:38:29 2015 +0100

    ALSA: usb-audio: prevent CH345 multiport output SysEx corruption
    
    The CH345 USB MIDI chip has two output ports.  However, they are
    multiplexed through one pin, and the number of ports cannot be reduced
    even for hardware that implements only one connector, so for those
    devices, data sent to either port ends up on the same hardware output.
    This becomes a problem when both ports are used at the same time, as
    longer MIDI commands (such as SysEx messages) are likely to be
    interrupted by messages from the other port, and thus to get lost.
    
    It would not be possible for the driver to detect how many ports the
    device actually has, except that in practice, _all_ devices built with
    the CH345 have only one port.  So we can just ignore the device's
    descriptors, and hardcode one output port.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 68e9f9a83fde..010094abf752 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -2377,6 +2377,9 @@ int snd_usbmidi_create(struct snd_card *card,
 		if (err < 0)
 			break;
 
+		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
+		break;
+	case QUIRK_MIDI_CH345:
 		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
 		break;
 	default:

commit 98d362becb6621bebdda7ed0eac7ad7ec6c37898
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 15 22:37:44 2015 +0100

    ALSA: usb-audio: add packet size quirk for the Medeli DD305
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 7661616f3636..68e9f9a83fde 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1341,6 +1341,7 @@ static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi *umidi,
 		 * Various chips declare a packet size larger than 4 bytes, but
 		 * do not actually work with larger packets:
 		 */
+	case USB_ID(0x0a67, 0x5011): /* Medeli DD305 */
 	case USB_ID(0x0a92, 0x1020): /* ESI M4U */
 	case USB_ID(0x1430, 0x474b): /* RedOctane GH MIDI INTERFACE */
 	case USB_ID(0x15ca, 0x0101): /* Textech USB Midi Cable */

commit ac77423609aa499265a0ab75c497661bc7157f37
Author: Keith A. Milner <maillist@superlative.org>
Date:   Sun Oct 11 15:19:48 2015 +0100

    ALSA: usb-audio: Allow any MIDI endpoint to drive use of interrupt transfer on newer Roland devices
    
    This patch enables interrupt transfer mode for MIDI ports on newer
    Boss/Roland devices such as the GT-100/001 which support interrupt
    transfer on both IN and OUT MIDI endpoints. Previously this wasn't being
    enabled for these devices as the code was specifically looking for the
    scenario where the IN endpoint supported interrupt transfer and the OUT
    endpoint was bulk transfer. Newer devices support interrupt transfer for
    both endpoints.
    
    This has been tested on Boss devices GT-001, BR-80 and JS-8 and Roland
    VS-20.
    
    It would benefit from some regresison testing with other devices if
    possible.
    
    Signed-off-by: Keith A. Milner <maillist@superlative.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 417ebb11cf48..7661616f3636 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1903,11 +1903,14 @@ static void snd_usbmidi_switch_roland_altsetting(struct snd_usb_midi *umidi)
 
 	hostif = &intf->altsetting[1];
 	intfd = get_iface_desc(hostif);
+       /* If either or both of the endpoints support interrupt transfer,
+        * then use the alternate setting
+        */
 	if (intfd->bNumEndpoints != 2 ||
-	    (get_endpoint(hostif, 0)->bmAttributes &
-	     USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_BULK ||
-	    (get_endpoint(hostif, 1)->bmAttributes &
-	     USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_INT)
+	    !((get_endpoint(hostif, 0)->bmAttributes &
+	       USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT ||
+	      (get_endpoint(hostif, 1)->bmAttributes &
+	       USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT))
 		return;
 
 	dev_dbg(&umidi->dev->dev, "switching to altsetting %d with int ep\n",

commit 28e237a9b7bc45d048ba7cb683ab348701e099fd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 11:43:50 2015 +0100

    ALSA: usb-audio: Use setup_timer() and mod_timer()
    
    No functional change, refactoring with the standard helpers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 5bfb695547f8..417ebb11cf48 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -2292,14 +2292,13 @@ int snd_usbmidi_create(struct snd_card *card,
 	umidi->iface = iface;
 	umidi->quirk = quirk;
 	umidi->usb_protocol_ops = &snd_usbmidi_standard_ops;
-	init_timer(&umidi->error_timer);
 	spin_lock_init(&umidi->disc_lock);
 	init_rwsem(&umidi->disc_rwsem);
 	mutex_init(&umidi->mutex);
 	umidi->usb_id = USB_ID(le16_to_cpu(umidi->dev->descriptor.idVendor),
 			       le16_to_cpu(umidi->dev->descriptor.idProduct));
-	umidi->error_timer.function = snd_usbmidi_error_timer;
-	umidi->error_timer.data = (unsigned long)umidi;
+	setup_timer(&umidi->error_timer, snd_usbmidi_error_timer,
+		    (unsigned long)umidi);
 
 	/* detect the endpoint(s) to use */
 	memset(endpoints, 0, sizeof(endpoints));

commit 66139a48cee1530c91f37c145384b4ee7043f0b7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat Dec 6 18:02:55 2014 +0100

    ALSA: usb-audio: Don't resubmit pending URBs at MIDI error recovery
    
    In snd_usbmidi_error_timer(), the driver tries to resubmit MIDI input
    URBs to reactivate the MIDI stream, but this causes the error when
    some of URBs are still pending like:
    
     WARNING: CPU: 0 PID: 0 at ../drivers/usb/core/urb.c:339 usb_submit_urb+0x5f/0x70()
     URB ef705c40 submitted while active
     CPU: 0 PID: 0 Comm: swapper/0 Not tainted 3.16.6-2-desktop #1
     Hardware name: FOXCONN TPS01/TPS01, BIOS 080015  03/23/2010
      c0984bfa f4009ed4 c078deaf f4009ee4 c024c884 c09a135c f4009f00 00000000
      c0984bfa 00000153 c061ac4f c061ac4f 00000009 00000001 ef705c40 e854d1c0
      f4009eec c024c8d3 00000009 f4009ee4 c09a135c f4009f00 f4009f04 c061ac4f
     Call Trace:
      [<c0205df6>] try_stack_unwind+0x156/0x170
      [<c020482a>] dump_trace+0x5a/0x1b0
      [<c0205e56>] show_trace_log_lvl+0x46/0x50
      [<c02049d1>] show_stack_log_lvl+0x51/0xe0
      [<c0205eb7>] show_stack+0x27/0x50
      [<c078deaf>] dump_stack+0x45/0x65
      [<c024c884>] warn_slowpath_common+0x84/0xa0
      [<c024c8d3>] warn_slowpath_fmt+0x33/0x40
      [<c061ac4f>] usb_submit_urb+0x5f/0x70
      [<f7974104>] snd_usbmidi_submit_urb+0x14/0x60 [snd_usbmidi_lib]
      [<f797483a>] snd_usbmidi_error_timer+0x6a/0xa0 [snd_usbmidi_lib]
      [<c02570c0>] call_timer_fn+0x30/0x130
      [<c0257442>] run_timer_softirq+0x1c2/0x260
      [<c0251493>] __do_softirq+0xc3/0x270
      [<c0204732>] do_softirq_own_stack+0x22/0x30
      [<c025186d>] irq_exit+0x8d/0xa0
      [<c0795228>] smp_apic_timer_interrupt+0x38/0x50
      [<c0794a3c>] apic_timer_interrupt+0x34/0x3c
      [<c0673d9e>] cpuidle_enter_state+0x3e/0xd0
      [<c028bb8d>] cpu_idle_loop+0x29d/0x3e0
      [<c028bd23>] cpu_startup_entry+0x53/0x60
      [<c0bfac1e>] start_kernel+0x415/0x41a
    
    For avoiding these errors, check the pending URBs and skip
    resubmitting such ones.
    
    Reported-and-tested-by: Stefan Seyfried <stefan.seyfried@googlemail.com>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index d3d49525a16b..5bfb695547f8 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -365,6 +365,8 @@ static void snd_usbmidi_error_timer(unsigned long data)
 		if (in && in->error_resubmit) {
 			in->error_resubmit = 0;
 			for (j = 0; j < INPUT_URBS; ++j) {
+				if (atomic_read(&in->urbs[j]->use_count))
+					continue;
 				in->urbs[j]->dev = umidi->dev;
 				snd_usbmidi_submit_urb(in->urbs[j], GFP_ATOMIC);
 			}

commit a2ce35273c2f1aa0dcddd8822681d64ee5f31852
Merge: bf65dea87e87 fd1a2a90d08b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 10 22:13:25 2014 -0400

    Merge tag 'sound-3.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "This time it's a relatively calm update batch, but the amount isn't
      too small in the end.  Here we go over some highlights:
    
      ALSA core:
       - One major change is the support of nonatomic PCM operations.  This
         allows the trigger and other callbacks to call schedule(), which
         would be useful for mailbox type communications.  Already some
         drivers (Digigram ones) have been converted to use together with
         threaded irqs as an example.
       - Improvement / fixes of DSD PCM format support
    
      HD-audio:
       - Large volume of rewrites are found in Realtek codec driver for
         converting Dell and HP quirks to generic forms.
       - Inverted dmic code cleanup from David.
       - Realtek COEF access has been optimized.
       - Now HD-audio jack infrastructure allows multiple callbacks, which
         fixes / simplifies the jack-dependent power controls on STAC/IDT
         and VIA codecs.
       - Many additional device-specific fixups as usual
       - A few deadcode cleanups, CA0132 code cleanup, etc.
    
      ASoC:
       - More componentization work from Lars-Peter, this time mainly
         cleaning up the suspend and bias level transition callbacks.
       - Real system support for the Intel drivers and a bunch of fixes and
         enhancements for the associated CODEC drivers, this is going to
         need a lot quirks over time due to the lack of any firmware
         description of the boards.
       - Jack detect support for simple card from Dylan Reid.
       - A bunch of small fixes and enhancements for the Freescale drivers.
       - New drivers for Analog Devices SSM4567, Cirrus Logic CS35L32,
         Everest Semiconductor ES8328 and Freescale cards using the ASRC in
         newer i.MX processors.
       - A few simple-card fixes, mostly cleanups but also a fix for
         interaction between GPIO 0 and simple-card.
    
      Misc:
       - Virtuoso / Oxygen updates by Clemens
       - USB-audio: Yamaha MOTIF XF MIDI port name fixes
       - Conversion of kernel messages to standard dev_*() in ctxfi driver"
    
    * tag 'sound-3.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (251 commits)
      ASoC: mc13783: Ensure we only try to dereference valid of_nodes
      ASoC: rockchip-i2s: fix infinite loop in rockchip_snd_txctrl
      ALSA: hda - Add dock port support to Thinkpad L440 (71aa:501e)
      ALSA: Allow pass NULL dev for snd_pci_quirk_lookup()
      ASoC: imx-es8328: Fix of_node_put() call with uninitialized object
      ASoC: soc-pcm: fix sig_bits determination in soc_pcm_apply_msb()
      ASoC: simple-card: Initialize headphone and mic GPIO numbers
      ASoC: imx-es8328: Fix missing return code in imx_es8328_probe()
      ALSA: hda - Add dock support for Thinkpad T440 (17aa:2212)
      ALSA: usb: caiaq: check for cdev->n_streams > 1
      ASoC: 88pm860x-codec: Fix possibly missing string termination
      ASoC: core: fix use after free in snd_soc_remove_platform()
      ASoC: soc-dapm: fix use after free
      ALSA: hda - Make the inv dmic handling for Realtek use generic parser
      ALSA: hda - Add Inverted Internal mic for Samsung Ativ book 9 (NP900X3G)
      ALSA: hda - Add inverted internal mic for Asus Aspire 4830T
      ASoC: Intel: byt-rt5640: fix coccinelle warnings
      ASoC: fsl_esai doc: Add "fsl,vf610-esai" as compatible string
      ASoC: da732x: Remove unnecessary KERN_ERR in pr_err()
      ASoC: simple-card: Fix detect gpio documentation.
      ...

commit 37ebb54915dc42944f6ae92fe53b9531c3903801
Author: Petr Mladek <pmladek@suse.cz>
Date:   Fri Sep 19 17:32:23 2014 +0200

    usb: hub: rename khubd to hub_wq in documentation and comments
    
    USB hub has started to use a workqueue instead of kthread. Let's update
    the documentation and comments here and there.
    
    This patch mostly just replaces "khubd" with "hub_wq". There are only few
    exceptions where the whole sentence was updated. These more complicated
    changes can be found in the following files:
    
               Documentation/usb/hotplug.txt
               drivers/net/usb/usbnet.c
               drivers/usb/core/hcd.c
               drivers/usb/host/ohci-hcd.c
               drivers/usb/host/xhci.c
    
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 7b166c2be0f7..b2b6f398a4e1 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -64,7 +64,7 @@
 /* #define DUMP_PACKETS */
 
 /*
- * how long to wait after some USB errors, so that khubd can disconnect() us
+ * how long to wait after some USB errors, so that hub_wq can disconnect() us
  * without too many spurious errors
  */
 #define ERROR_DELAY_JIFFIES (HZ / 10)

commit 49f4b4d15c7c9ff8efbb18d9f8c224d3682da573
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Sep 7 21:44:29 2014 +0200

    ALSA: usb-audio: add MIDI port names for the Yamaha MOTIF XF
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 7b166c2be0f7..69e93a9d486a 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1506,6 +1506,12 @@ static struct port_info {
 	PORT_INFO(vendor, product, num, name, 0, \
 		  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \
 		  SNDRV_SEQ_PORT_TYPE_HARDWARE)
+#define GM_SYNTH_PORT(vendor, product, num, name, voices) \
+	PORT_INFO(vendor, product, num, name, voices, \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_GM | \
+		  SNDRV_SEQ_PORT_TYPE_HARDWARE | \
+		  SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)
 #define ROLAND_SYNTH_PORT(vendor, product, num, name, voices) \
 	PORT_INFO(vendor, product, num, name, voices, \
 		  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \
@@ -1525,6 +1531,11 @@ static struct port_info {
 		  SNDRV_SEQ_PORT_TYPE_MIDI_MT32 | \
 		  SNDRV_SEQ_PORT_TYPE_HARDWARE | \
 		  SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)
+	/* Yamaha MOTIF XF */
+	GM_SYNTH_PORT(0x0499, 0x105c, 0, "%s Tone Generator", 128),
+	CONTROL_PORT(0x0499, 0x105c, 1, "%s Remote Control"),
+	EXTERNAL_PORT(0x0499, 0x105c, 2, "%s Thru"),
+	CONTROL_PORT(0x0499, 0x105c, 3, "%s Editor"),
 	/* Roland UA-100 */
 	CONTROL_PORT(0x0582, 0x0000, 2, "%s Control"),
 	/* Roland SC-8850 */

commit a509574e5ea7b617268943526773ebf7e2d20a9b
Author: Adam Goode <agoode@google.com>
Date:   Tue Aug 5 12:44:51 2014 -0400

    ALSA: usb-audio: Whitespace cleanups for sound/usb/midi.*
    
    Signed-off-by: Adam Goode <agoode@google.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 9a4e82cf4ef9..7b166c2be0f7 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -102,8 +102,8 @@ struct usb_protocol_ops {
 	void (*input)(struct snd_usb_midi_in_endpoint*, uint8_t*, int);
 	void (*output)(struct snd_usb_midi_out_endpoint *ep, struct urb *urb);
 	void (*output_packet)(struct urb*, uint8_t, uint8_t, uint8_t, uint8_t);
-	void (*init_out_endpoint)(struct snd_usb_midi_out_endpoint*);
-	void (*finish_out_endpoint)(struct snd_usb_midi_out_endpoint*);
+	void (*init_out_endpoint)(struct snd_usb_midi_out_endpoint *);
+	void (*finish_out_endpoint)(struct snd_usb_midi_out_endpoint *);
 };
 
 struct snd_usb_midi {
@@ -112,7 +112,7 @@ struct snd_usb_midi {
 	struct usb_interface *iface;
 	const struct snd_usb_audio_quirk *quirk;
 	struct snd_rawmidi *rmidi;
-	struct usb_protocol_ops* usb_protocol_ops;
+	struct usb_protocol_ops *usb_protocol_ops;
 	struct list_head list;
 	struct timer_list error_timer;
 	spinlock_t disc_lock;
@@ -134,7 +134,7 @@ struct snd_usb_midi {
 };
 
 struct snd_usb_midi_out_endpoint {
-	struct snd_usb_midi* umidi;
+	struct snd_usb_midi *umidi;
 	struct out_urb_context {
 		struct urb *urb;
 		struct snd_usb_midi_out_endpoint *ep;
@@ -147,7 +147,7 @@ struct snd_usb_midi_out_endpoint {
 	spinlock_t buffer_lock;
 
 	struct usbmidi_out_port {
-		struct snd_usb_midi_out_endpoint* ep;
+		struct snd_usb_midi_out_endpoint *ep;
 		struct snd_rawmidi_substream *substream;
 		int active;
 		uint8_t cable;		/* cable number << 4 */
@@ -167,8 +167,8 @@ struct snd_usb_midi_out_endpoint {
 };
 
 struct snd_usb_midi_in_endpoint {
-	struct snd_usb_midi* umidi;
-	struct urb* urbs[INPUT_URBS];
+	struct snd_usb_midi *umidi;
+	struct urb *urbs[INPUT_URBS];
 	struct usbmidi_in_port {
 		struct snd_rawmidi_substream *substream;
 		u8 running_status_length;
@@ -178,7 +178,7 @@ struct snd_usb_midi_in_endpoint {
 	int current_port;
 };
 
-static void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint* ep);
+static void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint *ep);
 
 static const uint8_t snd_usbmidi_cin_length[] = {
 	0, 0, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 2, 2, 3, 1
@@ -187,7 +187,7 @@ static const uint8_t snd_usbmidi_cin_length[] = {
 /*
  * Submits the URB, with error handling.
  */
-static int snd_usbmidi_submit_urb(struct urb* urb, gfp_t flags)
+static int snd_usbmidi_submit_urb(struct urb *urb, gfp_t flags)
 {
 	int err = usb_submit_urb(urb, flags);
 	if (err < 0 && err != -ENODEV)
@@ -221,10 +221,10 @@ static int snd_usbmidi_urb_error(const struct urb *urb)
 /*
  * Receives a chunk of MIDI data.
  */
-static void snd_usbmidi_input_data(struct snd_usb_midi_in_endpoint* ep, int portidx,
-				   uint8_t* data, int length)
+static void snd_usbmidi_input_data(struct snd_usb_midi_in_endpoint *ep,
+				   int portidx, uint8_t *data, int length)
 {
-	struct usbmidi_in_port* port = &ep->ports[portidx];
+	struct usbmidi_in_port *port = &ep->ports[portidx];
 
 	if (!port->substream) {
 		dev_dbg(&ep->umidi->dev->dev, "unexpected port %d!\n", portidx);
@@ -250,9 +250,9 @@ static void dump_urb(const char *type, const u8 *data, int length)
 /*
  * Processes the data read from the device.
  */
-static void snd_usbmidi_in_urb_complete(struct urb* urb)
+static void snd_usbmidi_in_urb_complete(struct urb *urb)
 {
-	struct snd_usb_midi_in_endpoint* ep = urb->context;
+	struct snd_usb_midi_in_endpoint *ep = urb->context;
 
 	if (urb->status == 0) {
 		dump_urb("received", urb->transfer_buffer, urb->actual_length);
@@ -274,10 +274,10 @@ static void snd_usbmidi_in_urb_complete(struct urb* urb)
 	snd_usbmidi_submit_urb(urb, GFP_ATOMIC);
 }
 
-static void snd_usbmidi_out_urb_complete(struct urb* urb)
+static void snd_usbmidi_out_urb_complete(struct urb *urb)
 {
 	struct out_urb_context *context = urb->context;
-	struct snd_usb_midi_out_endpoint* ep = context->ep;
+	struct snd_usb_midi_out_endpoint *ep = context->ep;
 	unsigned int urb_index;
 
 	spin_lock(&ep->buffer_lock);
@@ -304,10 +304,10 @@ static void snd_usbmidi_out_urb_complete(struct urb* urb)
  * This is called when some data should be transferred to the device
  * (from one or more substreams).
  */
-static void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint* ep)
+static void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint *ep)
 {
 	unsigned int urb_index;
-	struct urb* urb;
+	struct urb *urb;
 	unsigned long flags;
 
 	spin_lock_irqsave(&ep->buffer_lock, flags);
@@ -343,7 +343,8 @@ static void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint* ep)
 
 static void snd_usbmidi_out_tasklet(unsigned long data)
 {
-	struct snd_usb_midi_out_endpoint* ep = (struct snd_usb_midi_out_endpoint *) data;
+	struct snd_usb_midi_out_endpoint *ep =
+		(struct snd_usb_midi_out_endpoint *) data;
 
 	snd_usbmidi_do_output(ep);
 }
@@ -375,7 +376,7 @@ static void snd_usbmidi_error_timer(unsigned long data)
 }
 
 /* helper function to send static data that may not DMA-able */
-static int send_bulk_static_data(struct snd_usb_midi_out_endpoint* ep,
+static int send_bulk_static_data(struct snd_usb_midi_out_endpoint *ep,
 				 const void *data, int len)
 {
 	int err = 0;
@@ -396,8 +397,8 @@ static int send_bulk_static_data(struct snd_usb_midi_out_endpoint* ep,
  * fourth byte in each packet, and uses length instead of CIN.
  */
 
-static void snd_usbmidi_standard_input(struct snd_usb_midi_in_endpoint* ep,
-				       uint8_t* buffer, int buffer_length)
+static void snd_usbmidi_standard_input(struct snd_usb_midi_in_endpoint *ep,
+				       uint8_t *buffer, int buffer_length)
 {
 	int i;
 
@@ -405,12 +406,13 @@ static void snd_usbmidi_standard_input(struct snd_usb_midi_in_endpoint* ep,
 		if (buffer[i] != 0) {
 			int cable = buffer[i] >> 4;
 			int length = snd_usbmidi_cin_length[buffer[i] & 0x0f];
-			snd_usbmidi_input_data(ep, cable, &buffer[i + 1], length);
+			snd_usbmidi_input_data(ep, cable, &buffer[i + 1],
+					       length);
 		}
 }
 
-static void snd_usbmidi_midiman_input(struct snd_usb_midi_in_endpoint* ep,
-				      uint8_t* buffer, int buffer_length)
+static void snd_usbmidi_midiman_input(struct snd_usb_midi_in_endpoint *ep,
+				      uint8_t *buffer, int buffer_length)
 {
 	int i;
 
@@ -427,8 +429,8 @@ static void snd_usbmidi_midiman_input(struct snd_usb_midi_in_endpoint* ep,
  * the data bytes but not the status byte and that is marked with CIN 4.
  */
 static void snd_usbmidi_maudio_broken_running_status_input(
-					struct snd_usb_midi_in_endpoint* ep,
-					uint8_t* buffer, int buffer_length)
+					struct snd_usb_midi_in_endpoint *ep,
+					uint8_t *buffer, int buffer_length)
 {
 	int i;
 
@@ -458,7 +460,8 @@ static void snd_usbmidi_maudio_broken_running_status_input(
 				 * doesn't use this format.)
 				 */
 				port->running_status_length = 0;
-			snd_usbmidi_input_data(ep, cable, &buffer[i + 1], length);
+			snd_usbmidi_input_data(ep, cable, &buffer[i + 1],
+					       length);
 		}
 }
 
@@ -479,11 +482,13 @@ static void snd_usbmidi_cme_input(struct snd_usb_midi_in_endpoint *ep,
 /*
  * Adds one USB MIDI packet to the output buffer.
  */
-static void snd_usbmidi_output_standard_packet(struct urb* urb, uint8_t p0,
-					       uint8_t p1, uint8_t p2, uint8_t p3)
+static void snd_usbmidi_output_standard_packet(struct urb *urb, uint8_t p0,
+					       uint8_t p1, uint8_t p2,
+					       uint8_t p3)
 {
 
-	uint8_t* buf = (uint8_t*)urb->transfer_buffer + urb->transfer_buffer_length;
+	uint8_t *buf =
+		(uint8_t *)urb->transfer_buffer + urb->transfer_buffer_length;
 	buf[0] = p0;
 	buf[1] = p1;
 	buf[2] = p2;
@@ -494,11 +499,13 @@ static void snd_usbmidi_output_standard_packet(struct urb* urb, uint8_t p0,
 /*
  * Adds one Midiman packet to the output buffer.
  */
-static void snd_usbmidi_output_midiman_packet(struct urb* urb, uint8_t p0,
-					      uint8_t p1, uint8_t p2, uint8_t p3)
+static void snd_usbmidi_output_midiman_packet(struct urb *urb, uint8_t p0,
+					      uint8_t p1, uint8_t p2,
+					      uint8_t p3)
 {
 
-	uint8_t* buf = (uint8_t*)urb->transfer_buffer + urb->transfer_buffer_length;
+	uint8_t *buf =
+		(uint8_t *)urb->transfer_buffer + urb->transfer_buffer_length;
 	buf[0] = p1;
 	buf[1] = p2;
 	buf[2] = p3;
@@ -509,8 +516,8 @@ static void snd_usbmidi_output_midiman_packet(struct urb* urb, uint8_t p0,
 /*
  * Converts MIDI commands to USB MIDI packets.
  */
-static void snd_usbmidi_transmit_byte(struct usbmidi_out_port* port,
-				      uint8_t b, struct urb* urb)
+static void snd_usbmidi_transmit_byte(struct usbmidi_out_port *port,
+				      uint8_t b, struct urb *urb)
 {
 	uint8_t p0 = port->cable;
 	void (*output_packet)(struct urb*, uint8_t, uint8_t, uint8_t, uint8_t) =
@@ -547,10 +554,12 @@ static void snd_usbmidi_transmit_byte(struct usbmidi_out_port* port,
 				output_packet(urb, p0 | 0x05, 0xf7, 0, 0);
 				break;
 			case STATE_SYSEX_1:
-				output_packet(urb, p0 | 0x06, port->data[0], 0xf7, 0);
+				output_packet(urb, p0 | 0x06, port->data[0],
+					      0xf7, 0);
 				break;
 			case STATE_SYSEX_2:
-				output_packet(urb, p0 | 0x07, port->data[0], port->data[1], 0xf7);
+				output_packet(urb, p0 | 0x07, port->data[0],
+					      port->data[1], 0xf7);
 				break;
 			}
 			port->state = STATE_UNKNOWN;
@@ -596,21 +605,22 @@ static void snd_usbmidi_transmit_byte(struct usbmidi_out_port* port,
 			port->state = STATE_SYSEX_2;
 			break;
 		case STATE_SYSEX_2:
-			output_packet(urb, p0 | 0x04, port->data[0], port->data[1], b);
+			output_packet(urb, p0 | 0x04, port->data[0],
+				      port->data[1], b);
 			port->state = STATE_SYSEX_0;
 			break;
 		}
 	}
 }
 
-static void snd_usbmidi_standard_output(struct snd_usb_midi_out_endpoint* ep,
+static void snd_usbmidi_standard_output(struct snd_usb_midi_out_endpoint *ep,
 					struct urb *urb)
 {
 	int p;
 
 	/* FIXME: lower-numbered ports can starve higher-numbered ports */
 	for (p = 0; p < 0x10; ++p) {
-		struct usbmidi_out_port* port = &ep->ports[p];
+		struct usbmidi_out_port *port = &ep->ports[p];
 		if (!port->active)
 			continue;
 		while (urb->transfer_buffer_length + 3 < ep->max_transfer) {
@@ -753,18 +763,18 @@ static struct usb_protocol_ops snd_usbmidi_akai_ops = {
  * at the third byte.
  */
 
-static void snd_usbmidi_novation_input(struct snd_usb_midi_in_endpoint* ep,
-				       uint8_t* buffer, int buffer_length)
+static void snd_usbmidi_novation_input(struct snd_usb_midi_in_endpoint *ep,
+				       uint8_t *buffer, int buffer_length)
 {
 	if (buffer_length < 2 || !buffer[0] || buffer_length < buffer[0] + 1)
 		return;
 	snd_usbmidi_input_data(ep, 0, &buffer[2], buffer[0] - 1);
 }
 
-static void snd_usbmidi_novation_output(struct snd_usb_midi_out_endpoint* ep,
+static void snd_usbmidi_novation_output(struct snd_usb_midi_out_endpoint *ep,
 					struct urb *urb)
 {
-	uint8_t* transfer_buffer;
+	uint8_t *transfer_buffer;
 	int count;
 
 	if (!ep->ports[0].active)
@@ -791,13 +801,13 @@ static struct usb_protocol_ops snd_usbmidi_novation_ops = {
  * "raw" protocol: just move raw MIDI bytes from/to the endpoint
  */
 
-static void snd_usbmidi_raw_input(struct snd_usb_midi_in_endpoint* ep,
-				  uint8_t* buffer, int buffer_length)
+static void snd_usbmidi_raw_input(struct snd_usb_midi_in_endpoint *ep,
+				  uint8_t *buffer, int buffer_length)
 {
 	snd_usbmidi_input_data(ep, 0, buffer, buffer_length);
 }
 
-static void snd_usbmidi_raw_output(struct snd_usb_midi_out_endpoint* ep,
+static void snd_usbmidi_raw_output(struct snd_usb_midi_out_endpoint *ep,
 				   struct urb *urb)
 {
 	int count;
@@ -823,8 +833,8 @@ static struct usb_protocol_ops snd_usbmidi_raw_ops = {
  * FTDI protocol: raw MIDI bytes, but input packets have two modem status bytes.
  */
 
-static void snd_usbmidi_ftdi_input(struct snd_usb_midi_in_endpoint* ep,
-				   uint8_t* buffer, int buffer_length)
+static void snd_usbmidi_ftdi_input(struct snd_usb_midi_in_endpoint *ep,
+				   uint8_t *buffer, int buffer_length)
 {
 	if (buffer_length > 2)
 		snd_usbmidi_input_data(ep, 0, buffer + 2, buffer_length - 2);
@@ -883,7 +893,7 @@ static struct usb_protocol_ops snd_usbmidi_122l_ops = {
  * Emagic USB MIDI protocol: raw MIDI with "F5 xx" port switching.
  */
 
-static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint* ep)
+static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
 {
 	static const u8 init_data[] = {
 		/* initialization magic: "get version" */
@@ -900,7 +910,7 @@ static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint* ep)
 	send_bulk_static_data(ep, init_data, sizeof(init_data));
 }
 
-static void snd_usbmidi_emagic_finish_out(struct snd_usb_midi_out_endpoint* ep)
+static void snd_usbmidi_emagic_finish_out(struct snd_usb_midi_out_endpoint *ep)
 {
 	static const u8 finish_data[] = {
 		/* switch to patch mode with last preset */
@@ -916,8 +926,8 @@ static void snd_usbmidi_emagic_finish_out(struct snd_usb_midi_out_endpoint* ep)
 	send_bulk_static_data(ep, finish_data, sizeof(finish_data));
 }
 
-static void snd_usbmidi_emagic_input(struct snd_usb_midi_in_endpoint* ep,
-				     uint8_t* buffer, int buffer_length)
+static void snd_usbmidi_emagic_input(struct snd_usb_midi_in_endpoint *ep,
+				     uint8_t *buffer, int buffer_length)
 {
 	int i;
 
@@ -960,18 +970,18 @@ static void snd_usbmidi_emagic_input(struct snd_usb_midi_in_endpoint* ep,
 	}
 }
 
-static void snd_usbmidi_emagic_output(struct snd_usb_midi_out_endpoint* ep,
+static void snd_usbmidi_emagic_output(struct snd_usb_midi_out_endpoint *ep,
 				      struct urb *urb)
 {
 	int port0 = ep->current_port;
-	uint8_t* buf = urb->transfer_buffer;
+	uint8_t *buf = urb->transfer_buffer;
 	int buf_free = ep->max_transfer;
 	int length, i;
 
 	for (i = 0; i < 0x10; ++i) {
 		/* round-robin, starting at the last current port */
 		int portnum = (port0 + i) & 15;
-		struct usbmidi_out_port* port = &ep->ports[portnum];
+		struct usbmidi_out_port *port = &ep->ports[portnum];
 
 		if (!port->active)
 			continue;
@@ -1015,7 +1025,7 @@ static struct usb_protocol_ops snd_usbmidi_emagic_ops = {
 };
 
 
-static void update_roland_altsetting(struct snd_usb_midi* umidi)
+static void update_roland_altsetting(struct snd_usb_midi *umidi)
 {
 	struct usb_interface *intf;
 	struct usb_host_interface *hostif;
@@ -1037,7 +1047,7 @@ static void update_roland_altsetting(struct snd_usb_midi* umidi)
 static int substream_open(struct snd_rawmidi_substream *substream, int dir,
 			  int open)
 {
-	struct snd_usb_midi* umidi = substream->rmidi->private_data;
+	struct snd_usb_midi *umidi = substream->rmidi->private_data;
 	struct snd_kcontrol *ctl;
 
 	down_read(&umidi->disc_rwsem);
@@ -1051,7 +1061,8 @@ static int substream_open(struct snd_rawmidi_substream *substream, int dir,
 		if (!umidi->opened[0] && !umidi->opened[1]) {
 			if (umidi->roland_load_ctl) {
 				ctl = umidi->roland_load_ctl;
-				ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+				ctl->vd[0].access |=
+					SNDRV_CTL_ELEM_ACCESS_INACTIVE;
 				snd_ctl_notify(umidi->card,
 				       SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);
 				update_roland_altsetting(umidi);
@@ -1067,7 +1078,8 @@ static int substream_open(struct snd_rawmidi_substream *substream, int dir,
 		if (!umidi->opened[0] && !umidi->opened[1]) {
 			if (umidi->roland_load_ctl) {
 				ctl = umidi->roland_load_ctl;
-				ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+				ctl->vd[0].access &=
+					~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
 				snd_ctl_notify(umidi->card,
 				       SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);
 			}
@@ -1080,8 +1092,8 @@ static int substream_open(struct snd_rawmidi_substream *substream, int dir,
 
 static int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)
 {
-	struct snd_usb_midi* umidi = substream->rmidi->private_data;
-	struct usbmidi_out_port* port = NULL;
+	struct snd_usb_midi *umidi = substream->rmidi->private_data;
+	struct usbmidi_out_port *port = NULL;
 	int i, j;
 
 	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)
@@ -1106,9 +1118,11 @@ static int snd_usbmidi_output_close(struct snd_rawmidi_substream *substream)
 	return substream_open(substream, 0, 0);
 }
 
-static void snd_usbmidi_output_trigger(struct snd_rawmidi_substream *substream, int up)
+static void snd_usbmidi_output_trigger(struct snd_rawmidi_substream *substream,
+				       int up)
 {
-	struct usbmidi_out_port* port = (struct usbmidi_out_port*)substream->runtime->private_data;
+	struct usbmidi_out_port *port =
+		(struct usbmidi_out_port *)substream->runtime->private_data;
 
 	port->active = up;
 	if (up) {
@@ -1125,7 +1139,7 @@ static void snd_usbmidi_output_trigger(struct snd_rawmidi_substream *substream,
 
 static void snd_usbmidi_output_drain(struct snd_rawmidi_substream *substream)
 {
-	struct usbmidi_out_port* port = substream->runtime->private_data;
+	struct usbmidi_out_port *port = substream->runtime->private_data;
 	struct snd_usb_midi_out_endpoint *ep = port->ep;
 	unsigned int drain_urbs;
 	DEFINE_WAIT(wait);
@@ -1164,9 +1178,10 @@ static int snd_usbmidi_input_close(struct snd_rawmidi_substream *substream)
 	return substream_open(substream, 1, 0);
 }
 
-static void snd_usbmidi_input_trigger(struct snd_rawmidi_substream *substream, int up)
+static void snd_usbmidi_input_trigger(struct snd_rawmidi_substream *substream,
+				      int up)
 {
-	struct snd_usb_midi* umidi = substream->rmidi->private_data;
+	struct snd_usb_midi *umidi = substream->rmidi->private_data;
 
 	if (up)
 		set_bit(substream->number, &umidi->input_triggered);
@@ -1199,7 +1214,7 @@ static void free_urb_and_buffer(struct snd_usb_midi *umidi, struct urb *urb,
  * Frees an input endpoint.
  * May be called when ep hasn't been initialized completely.
  */
-static void snd_usbmidi_in_endpoint_delete(struct snd_usb_midi_in_endpoint* ep)
+static void snd_usbmidi_in_endpoint_delete(struct snd_usb_midi_in_endpoint *ep)
 {
 	unsigned int i;
 
@@ -1213,12 +1228,12 @@ static void snd_usbmidi_in_endpoint_delete(struct snd_usb_midi_in_endpoint* ep)
 /*
  * Creates an input endpoint.
  */
-static int snd_usbmidi_in_endpoint_create(struct snd_usb_midi* umidi,
-					  struct snd_usb_midi_endpoint_info* ep_info,
-					  struct snd_usb_midi_endpoint* rep)
+static int snd_usbmidi_in_endpoint_create(struct snd_usb_midi *umidi,
+					  struct snd_usb_midi_endpoint_info *ep_info,
+					  struct snd_usb_midi_endpoint *rep)
 {
-	struct snd_usb_midi_in_endpoint* ep;
-	void* buffer;
+	struct snd_usb_midi_in_endpoint *ep;
+	void *buffer;
 	unsigned int pipe;
 	int length;
 	unsigned int i;
@@ -1289,14 +1304,14 @@ static void snd_usbmidi_out_endpoint_delete(struct snd_usb_midi_out_endpoint *ep
 /*
  * Creates an output endpoint, and initializes output ports.
  */
-static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi* umidi,
-					   struct snd_usb_midi_endpoint_info* ep_info,
-					   struct snd_usb_midi_endpoint* rep)
+static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi *umidi,
+					   struct snd_usb_midi_endpoint_info *ep_info,
+					   struct snd_usb_midi_endpoint *rep)
 {
-	struct snd_usb_midi_out_endpoint* ep;
+	struct snd_usb_midi_out_endpoint *ep;
 	unsigned int i;
 	unsigned int pipe;
-	void* buffer;
+	void *buffer;
 
 	rep->out = NULL;
 	ep = kzalloc(sizeof(*ep), GFP_KERNEL);
@@ -1381,12 +1396,12 @@ static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi* umidi,
 /*
  * Frees everything.
  */
-static void snd_usbmidi_free(struct snd_usb_midi* umidi)
+static void snd_usbmidi_free(struct snd_usb_midi *umidi)
 {
 	int i;
 
 	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
-		struct snd_usb_midi_endpoint* ep = &umidi->endpoints[i];
+		struct snd_usb_midi_endpoint *ep = &umidi->endpoints[i];
 		if (ep->out)
 			snd_usbmidi_out_endpoint_delete(ep->out);
 		if (ep->in)
@@ -1399,9 +1414,9 @@ static void snd_usbmidi_free(struct snd_usb_midi* umidi)
 /*
  * Unlinks all URBs (must be done before the usb_device is deleted).
  */
-void snd_usbmidi_disconnect(struct list_head* p)
+void snd_usbmidi_disconnect(struct list_head *p)
 {
-	struct snd_usb_midi* umidi;
+	struct snd_usb_midi *umidi;
 	unsigned int i, j;
 
 	umidi = list_entry(p, struct snd_usb_midi, list);
@@ -1417,7 +1432,7 @@ void snd_usbmidi_disconnect(struct list_head* p)
 	up_write(&umidi->disc_rwsem);
 
 	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
-		struct snd_usb_midi_endpoint* ep = &umidi->endpoints[i];
+		struct snd_usb_midi_endpoint *ep = &umidi->endpoints[i];
 		if (ep->out)
 			tasklet_kill(&ep->out->tasklet);
 		if (ep->out) {
@@ -1448,16 +1463,18 @@ EXPORT_SYMBOL(snd_usbmidi_disconnect);
 
 static void snd_usbmidi_rawmidi_free(struct snd_rawmidi *rmidi)
 {
-	struct snd_usb_midi* umidi = rmidi->private_data;
+	struct snd_usb_midi *umidi = rmidi->private_data;
 	snd_usbmidi_free(umidi);
 }
 
-static struct snd_rawmidi_substream *snd_usbmidi_find_substream(struct snd_usb_midi* umidi,
-								int stream, int number)
+static struct snd_rawmidi_substream *snd_usbmidi_find_substream(struct snd_usb_midi *umidi,
+								int stream,
+								int number)
 {
 	struct snd_rawmidi_substream *substream;
 
-	list_for_each_entry(substream, &umidi->rmidi->streams[stream].substreams, list) {
+	list_for_each_entry(substream, &umidi->rmidi->streams[stream].substreams,
+			    list) {
 		if (substream->number == number)
 			return substream;
 	}
@@ -1633,7 +1650,7 @@ static struct port_info {
 		SNDRV_SEQ_PORT_TYPE_SYNTHESIZER),
 };
 
-static struct port_info *find_port_info(struct snd_usb_midi* umidi, int number)
+static struct port_info *find_port_info(struct snd_usb_midi *umidi, int number)
 {
 	int i;
 
@@ -1659,16 +1676,18 @@ static void snd_usbmidi_get_port_info(struct snd_rawmidi *rmidi, int number,
 	}
 }
 
-static void snd_usbmidi_init_substream(struct snd_usb_midi* umidi,
+static void snd_usbmidi_init_substream(struct snd_usb_midi *umidi,
 				       int stream, int number,
-				       struct snd_rawmidi_substream ** rsubstream)
+				       struct snd_rawmidi_substream **rsubstream)
 {
 	struct port_info *port_info;
 	const char *name_format;
 
-	struct snd_rawmidi_substream *substream = snd_usbmidi_find_substream(umidi, stream, number);
+	struct snd_rawmidi_substream *substream =
+		snd_usbmidi_find_substream(umidi, stream, number);
 	if (!substream) {
-		dev_err(&umidi->dev->dev, "substream %d:%d not found\n", stream, number);
+		dev_err(&umidi->dev->dev, "substream %d:%d not found\n", stream,
+			number);
 		return;
 	}
 
@@ -1684,21 +1703,23 @@ static void snd_usbmidi_init_substream(struct snd_usb_midi* umidi,
 /*
  * Creates the endpoints and their ports.
  */
-static int snd_usbmidi_create_endpoints(struct snd_usb_midi* umidi,
-					struct snd_usb_midi_endpoint_info* endpoints)
+static int snd_usbmidi_create_endpoints(struct snd_usb_midi *umidi,
+					struct snd_usb_midi_endpoint_info *endpoints)
 {
 	int i, j, err;
 	int out_ports = 0, in_ports = 0;
 
 	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
 		if (endpoints[i].out_cables) {
-			err = snd_usbmidi_out_endpoint_create(umidi, &endpoints[i],
+			err = snd_usbmidi_out_endpoint_create(umidi,
+							      &endpoints[i],
 							      &umidi->endpoints[i]);
 			if (err < 0)
 				return err;
 		}
 		if (endpoints[i].in_cables) {
-			err = snd_usbmidi_in_endpoint_create(umidi, &endpoints[i],
+			err = snd_usbmidi_in_endpoint_create(umidi,
+							     &endpoints[i],
 							     &umidi->endpoints[i]);
 			if (err < 0)
 				return err;
@@ -1706,12 +1727,16 @@ static int snd_usbmidi_create_endpoints(struct snd_usb_midi* umidi,
 
 		for (j = 0; j < 0x10; ++j) {
 			if (endpoints[i].out_cables & (1 << j)) {
-				snd_usbmidi_init_substream(umidi, SNDRV_RAWMIDI_STREAM_OUTPUT, out_ports,
+				snd_usbmidi_init_substream(umidi,
+							   SNDRV_RAWMIDI_STREAM_OUTPUT,
+							   out_ports,
 							   &umidi->endpoints[i].out->ports[j].substream);
 				++out_ports;
 			}
 			if (endpoints[i].in_cables & (1 << j)) {
-				snd_usbmidi_init_substream(umidi, SNDRV_RAWMIDI_STREAM_INPUT, in_ports,
+				snd_usbmidi_init_substream(umidi,
+							   SNDRV_RAWMIDI_STREAM_INPUT,
+							   in_ports,
 							   &umidi->endpoints[i].in->ports[j].substream);
 				++in_ports;
 			}
@@ -1725,16 +1750,16 @@ static int snd_usbmidi_create_endpoints(struct snd_usb_midi* umidi,
 /*
  * Returns MIDIStreaming device capabilities.
  */
-static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
-			   	   struct snd_usb_midi_endpoint_info* endpoints)
+static int snd_usbmidi_get_ms_info(struct snd_usb_midi *umidi,
+				   struct snd_usb_midi_endpoint_info *endpoints)
 {
-	struct usb_interface* intf;
+	struct usb_interface *intf;
 	struct usb_host_interface *hostif;
-	struct usb_interface_descriptor* intfd;
-	struct usb_ms_header_descriptor* ms_header;
+	struct usb_interface_descriptor *intfd;
+	struct usb_ms_header_descriptor *ms_header;
 	struct usb_host_endpoint *hostep;
-	struct usb_endpoint_descriptor* ep;
-	struct usb_ms_endpoint_descriptor* ms_ep;
+	struct usb_endpoint_descriptor *ep;
+	struct usb_ms_endpoint_descriptor *ms_ep;
 	int i, epidx;
 
 	intf = umidi->iface;
@@ -1742,7 +1767,7 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
 		return -ENXIO;
 	hostif = &intf->altsetting[0];
 	intfd = get_iface_desc(hostif);
-	ms_header = (struct usb_ms_header_descriptor*)hostif->extra;
+	ms_header = (struct usb_ms_header_descriptor *)hostif->extra;
 	if (hostif->extralen >= 7 &&
 	    ms_header->bLength >= 7 &&
 	    ms_header->bDescriptorType == USB_DT_CS_INTERFACE &&
@@ -1759,7 +1784,7 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
 		ep = get_ep_desc(hostep);
 		if (!usb_endpoint_xfer_bulk(ep) && !usb_endpoint_xfer_int(ep))
 			continue;
-		ms_ep = (struct usb_ms_endpoint_descriptor*)hostep->extra;
+		ms_ep = (struct usb_ms_endpoint_descriptor *)hostep->extra;
 		if (hostep->extralen < 4 ||
 		    ms_ep->bLength < 4 ||
 		    ms_ep->bDescriptorType != USB_DT_CS_ENDPOINT ||
@@ -1783,9 +1808,10 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
 				 * ESI MIDI Mate that try to use them anyway.
 				 */
 				endpoints[epidx].out_interval = 1;
-			endpoints[epidx].out_cables = (1 << ms_ep->bNumEmbMIDIJack) - 1;
+			endpoints[epidx].out_cables =
+				(1 << ms_ep->bNumEmbMIDIJack) - 1;
 			dev_dbg(&umidi->dev->dev, "EP %02X: %d jack(s)\n",
-				    ep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);
+				ep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);
 		} else {
 			if (endpoints[epidx].in_ep) {
 				if (++epidx >= MIDI_MAX_ENDPOINTS) {
@@ -1799,9 +1825,10 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
 				endpoints[epidx].in_interval = ep->bInterval;
 			else if (snd_usb_get_speed(umidi->dev) == USB_SPEED_LOW)
 				endpoints[epidx].in_interval = 1;
-			endpoints[epidx].in_cables = (1 << ms_ep->bNumEmbMIDIJack) - 1;
+			endpoints[epidx].in_cables =
+				(1 << ms_ep->bNumEmbMIDIJack) - 1;
 			dev_dbg(&umidi->dev->dev, "EP %02X: %d jack(s)\n",
-				    ep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);
+				ep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);
 		}
 	}
 	return 0;
@@ -1825,7 +1852,7 @@ static int roland_load_get(struct snd_kcontrol *kcontrol,
 static int roland_load_put(struct snd_kcontrol *kcontrol,
 			   struct snd_ctl_elem_value *value)
 {
-	struct snd_usb_midi* umidi = kcontrol->private_data;
+	struct snd_usb_midi *umidi = kcontrol->private_data;
 	int changed;
 
 	if (value->value.enumerated.item[0] > 1)
@@ -1851,11 +1878,11 @@ static struct snd_kcontrol_new roland_load_ctl = {
  * On Roland devices, use the second alternate setting to be able to use
  * the interrupt input endpoint.
  */
-static void snd_usbmidi_switch_roland_altsetting(struct snd_usb_midi* umidi)
+static void snd_usbmidi_switch_roland_altsetting(struct snd_usb_midi *umidi)
 {
-	struct usb_interface* intf;
+	struct usb_interface *intf;
 	struct usb_host_interface *hostif;
-	struct usb_interface_descriptor* intfd;
+	struct usb_interface_descriptor *intfd;
 
 	intf = umidi->iface;
 	if (!intf || intf->num_altsetting != 2)
@@ -1864,8 +1891,10 @@ static void snd_usbmidi_switch_roland_altsetting(struct snd_usb_midi* umidi)
 	hostif = &intf->altsetting[1];
 	intfd = get_iface_desc(hostif);
 	if (intfd->bNumEndpoints != 2 ||
-	    (get_endpoint(hostif, 0)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_BULK ||
-	    (get_endpoint(hostif, 1)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_INT)
+	    (get_endpoint(hostif, 0)->bmAttributes &
+	     USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_BULK ||
+	    (get_endpoint(hostif, 1)->bmAttributes &
+	     USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_INT)
 		return;
 
 	dev_dbg(&umidi->dev->dev, "switching to altsetting %d with int ep\n",
@@ -1881,14 +1910,14 @@ static void snd_usbmidi_switch_roland_altsetting(struct snd_usb_midi* umidi)
 /*
  * Try to find any usable endpoints in the interface.
  */
-static int snd_usbmidi_detect_endpoints(struct snd_usb_midi* umidi,
-					struct snd_usb_midi_endpoint_info* endpoint,
+static int snd_usbmidi_detect_endpoints(struct snd_usb_midi *umidi,
+					struct snd_usb_midi_endpoint_info *endpoint,
 					int max_endpoints)
 {
-	struct usb_interface* intf;
+	struct usb_interface *intf;
 	struct usb_host_interface *hostif;
-	struct usb_interface_descriptor* intfd;
-	struct usb_endpoint_descriptor* epd;
+	struct usb_interface_descriptor *intfd;
+	struct usb_endpoint_descriptor *epd;
 	int i, out_eps = 0, in_eps = 0;
 
 	if (USB_ID_VENDOR(umidi->usb_id) == 0x0582)
@@ -1929,8 +1958,8 @@ static int snd_usbmidi_detect_endpoints(struct snd_usb_midi* umidi,
 /*
  * Detects the endpoints for one-port-per-endpoint protocols.
  */
-static int snd_usbmidi_detect_per_port_endpoints(struct snd_usb_midi* umidi,
-						 struct snd_usb_midi_endpoint_info* endpoints)
+static int snd_usbmidi_detect_per_port_endpoints(struct snd_usb_midi *umidi,
+						 struct snd_usb_midi_endpoint_info *endpoints)
 {
 	int err, i;
 
@@ -1947,13 +1976,13 @@ static int snd_usbmidi_detect_per_port_endpoints(struct snd_usb_midi* umidi,
 /*
  * Detects the endpoints and ports of Yamaha devices.
  */
-static int snd_usbmidi_detect_yamaha(struct snd_usb_midi* umidi,
-				     struct snd_usb_midi_endpoint_info* endpoint)
+static int snd_usbmidi_detect_yamaha(struct snd_usb_midi *umidi,
+				     struct snd_usb_midi_endpoint_info *endpoint)
 {
-	struct usb_interface* intf;
+	struct usb_interface *intf;
 	struct usb_host_interface *hostif;
-	struct usb_interface_descriptor* intfd;
-	uint8_t* cs_desc;
+	struct usb_interface_descriptor *intfd;
+	uint8_t *cs_desc;
 
 	intf = umidi->iface;
 	if (!intf)
@@ -1972,9 +2001,11 @@ static int snd_usbmidi_detect_yamaha(struct snd_usb_midi* umidi,
 	     cs_desc += cs_desc[0]) {
 		if (cs_desc[1] == USB_DT_CS_INTERFACE) {
 			if (cs_desc[2] == UAC_MIDI_IN_JACK)
-				endpoint->in_cables = (endpoint->in_cables << 1) | 1;
+				endpoint->in_cables =
+					(endpoint->in_cables << 1) | 1;
 			else if (cs_desc[2] == UAC_MIDI_OUT_JACK)
-				endpoint->out_cables = (endpoint->out_cables << 1) | 1;
+				endpoint->out_cables =
+					(endpoint->out_cables << 1) | 1;
 		}
 	}
 	if (!endpoint->in_cables && !endpoint->out_cables)
@@ -1986,12 +2017,12 @@ static int snd_usbmidi_detect_yamaha(struct snd_usb_midi* umidi,
 /*
  * Detects the endpoints and ports of Roland devices.
  */
-static int snd_usbmidi_detect_roland(struct snd_usb_midi* umidi,
-				     struct snd_usb_midi_endpoint_info* endpoint)
+static int snd_usbmidi_detect_roland(struct snd_usb_midi *umidi,
+				     struct snd_usb_midi_endpoint_info *endpoint)
 {
-	struct usb_interface* intf;
+	struct usb_interface *intf;
 	struct usb_host_interface *hostif;
-	u8* cs_desc;
+	u8 *cs_desc;
 
 	intf = umidi->iface;
 	if (!intf)
@@ -2024,14 +2055,14 @@ static int snd_usbmidi_detect_roland(struct snd_usb_midi* umidi,
 /*
  * Creates the endpoints and their ports for Midiman devices.
  */
-static int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi* umidi,
-						struct snd_usb_midi_endpoint_info* endpoint)
+static int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi *umidi,
+						struct snd_usb_midi_endpoint_info *endpoint)
 {
 	struct snd_usb_midi_endpoint_info ep_info;
-	struct usb_interface* intf;
+	struct usb_interface *intf;
 	struct usb_host_interface *hostif;
-	struct usb_interface_descriptor* intfd;
-	struct usb_endpoint_descriptor* epd;
+	struct usb_interface_descriptor *intfd;
+	struct usb_endpoint_descriptor *epd;
 	int cable, err;
 
 	intf = umidi->iface;
@@ -2068,39 +2099,50 @@ static int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi* umidi,
 		epd = get_endpoint(hostif, 4);
 		if (!usb_endpoint_dir_out(epd) ||
 		    !usb_endpoint_xfer_bulk(epd)) {
-			dev_dbg(&umidi->dev->dev, "endpoint[4] isn't bulk output\n");
+			dev_dbg(&umidi->dev->dev,
+				"endpoint[4] isn't bulk output\n");
 			return -ENXIO;
 		}
 	}
 
-	ep_info.out_ep = get_endpoint(hostif, 2)->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+	ep_info.out_ep = get_endpoint(hostif, 2)->bEndpointAddress &
+		USB_ENDPOINT_NUMBER_MASK;
 	ep_info.out_interval = 0;
 	ep_info.out_cables = endpoint->out_cables & 0x5555;
-	err = snd_usbmidi_out_endpoint_create(umidi, &ep_info, &umidi->endpoints[0]);
+	err = snd_usbmidi_out_endpoint_create(umidi, &ep_info,
+					      &umidi->endpoints[0]);
 	if (err < 0)
 		return err;
 
-	ep_info.in_ep = get_endpoint(hostif, 0)->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+	ep_info.in_ep = get_endpoint(hostif, 0)->bEndpointAddress &
+		USB_ENDPOINT_NUMBER_MASK;
 	ep_info.in_interval = get_endpoint(hostif, 0)->bInterval;
 	ep_info.in_cables = endpoint->in_cables;
-	err = snd_usbmidi_in_endpoint_create(umidi, &ep_info, &umidi->endpoints[0]);
+	err = snd_usbmidi_in_endpoint_create(umidi, &ep_info,
+					     &umidi->endpoints[0]);
 	if (err < 0)
 		return err;
 
 	if (endpoint->out_cables > 0x0001) {
-		ep_info.out_ep = get_endpoint(hostif, 4)->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+		ep_info.out_ep = get_endpoint(hostif, 4)->bEndpointAddress &
+			USB_ENDPOINT_NUMBER_MASK;
 		ep_info.out_cables = endpoint->out_cables & 0xaaaa;
-		err = snd_usbmidi_out_endpoint_create(umidi, &ep_info, &umidi->endpoints[1]);
+		err = snd_usbmidi_out_endpoint_create(umidi, &ep_info,
+						      &umidi->endpoints[1]);
 		if (err < 0)
 			return err;
 	}
 
 	for (cable = 0; cable < 0x10; ++cable) {
 		if (endpoint->out_cables & (1 << cable))
-			snd_usbmidi_init_substream(umidi, SNDRV_RAWMIDI_STREAM_OUTPUT, cable,
+			snd_usbmidi_init_substream(umidi,
+						   SNDRV_RAWMIDI_STREAM_OUTPUT,
+						   cable,
 						   &umidi->endpoints[cable & 1].out->ports[cable].substream);
 		if (endpoint->in_cables & (1 << cable))
-			snd_usbmidi_init_substream(umidi, SNDRV_RAWMIDI_STREAM_INPUT, cable,
+			snd_usbmidi_init_substream(umidi,
+						   SNDRV_RAWMIDI_STREAM_INPUT,
+						   cable,
 						   &umidi->endpoints[0].in->ports[cable].substream);
 	}
 	return 0;
@@ -2110,7 +2152,7 @@ static struct snd_rawmidi_global_ops snd_usbmidi_ops = {
 	.get_port_info = snd_usbmidi_get_port_info,
 };
 
-static int snd_usbmidi_create_rawmidi(struct snd_usb_midi* umidi,
+static int snd_usbmidi_create_rawmidi(struct snd_usb_midi *umidi,
 				      int out_ports, int in_ports)
 {
 	struct snd_rawmidi *rmidi;
@@ -2128,8 +2170,10 @@ static int snd_usbmidi_create_rawmidi(struct snd_usb_midi* umidi,
 	rmidi->ops = &snd_usbmidi_ops;
 	rmidi->private_data = umidi;
 	rmidi->private_free = snd_usbmidi_rawmidi_free;
-	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_usbmidi_output_ops);
-	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_usbmidi_input_ops);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,
+			    &snd_usbmidi_output_ops);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,
+			    &snd_usbmidi_input_ops);
 
 	umidi->rmidi = rmidi;
 	return 0;
@@ -2138,16 +2182,16 @@ static int snd_usbmidi_create_rawmidi(struct snd_usb_midi* umidi,
 /*
  * Temporarily stop input.
  */
-void snd_usbmidi_input_stop(struct list_head* p)
+void snd_usbmidi_input_stop(struct list_head *p)
 {
-	struct snd_usb_midi* umidi;
+	struct snd_usb_midi *umidi;
 	unsigned int i, j;
 
 	umidi = list_entry(p, struct snd_usb_midi, list);
 	if (!umidi->input_running)
 		return;
 	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
-		struct snd_usb_midi_endpoint* ep = &umidi->endpoints[i];
+		struct snd_usb_midi_endpoint *ep = &umidi->endpoints[i];
 		if (ep->in)
 			for (j = 0; j < INPUT_URBS; ++j)
 				usb_kill_urb(ep->in->urbs[j]);
@@ -2156,14 +2200,14 @@ void snd_usbmidi_input_stop(struct list_head* p)
 }
 EXPORT_SYMBOL(snd_usbmidi_input_stop);
 
-static void snd_usbmidi_input_start_ep(struct snd_usb_midi_in_endpoint* ep)
+static void snd_usbmidi_input_start_ep(struct snd_usb_midi_in_endpoint *ep)
 {
 	unsigned int i;
 
 	if (!ep)
 		return;
 	for (i = 0; i < INPUT_URBS; ++i) {
-		struct urb* urb = ep->urbs[i];
+		struct urb *urb = ep->urbs[i];
 		urb->dev = ep->umidi->dev;
 		snd_usbmidi_submit_urb(urb, GFP_KERNEL);
 	}
@@ -2172,9 +2216,9 @@ static void snd_usbmidi_input_start_ep(struct snd_usb_midi_in_endpoint* ep)
 /*
  * Resume input after a call to snd_usbmidi_input_stop().
  */
-void snd_usbmidi_input_start(struct list_head* p)
+void snd_usbmidi_input_start(struct list_head *p)
 {
-	struct snd_usb_midi* umidi;
+	struct snd_usb_midi *umidi;
 	int i;
 
 	umidi = list_entry(p, struct snd_usb_midi, list);
@@ -2218,11 +2262,11 @@ EXPORT_SYMBOL(snd_usbmidi_resume);
  * Creates and registers everything needed for a MIDI streaming interface.
  */
 int snd_usbmidi_create(struct snd_card *card,
-		       struct usb_interface* iface,
+		       struct usb_interface *iface,
 		       struct list_head *midi_list,
-		       const struct snd_usb_audio_quirk* quirk)
+		       const struct snd_usb_audio_quirk *quirk)
 {
-	struct snd_usb_midi* umidi;
+	struct snd_usb_midi *umidi;
 	struct snd_usb_midi_endpoint_info endpoints[MIDI_MAX_ENDPOINTS];
 	int out_ports, in_ports;
 	int i, err;
@@ -2320,7 +2364,8 @@ int snd_usbmidi_create(struct snd_card *card,
 		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
 		break;
 	default:
-		dev_err(&umidi->dev->dev, "invalid quirk type %d\n", quirk->type);
+		dev_err(&umidi->dev->dev, "invalid quirk type %d\n",
+			quirk->type);
 		err = -ENXIO;
 		break;
 	}

commit f7881e5e8ef305e62084bf3d31b5b0d827fdf511
Author: Adam Goode <agoode@google.com>
Date:   Tue Aug 5 12:44:50 2014 -0400

    ALSA: usb-audio: Respond to suspend and resume callbacks for MIDI input
    
    sound/usb/card.c registers USB suspend and resume but did not previously
    kill the input URBs. This means that USB MIDI devices left open across
    suspend/resume had non-functional input (output still usually worked,
    but it looks like that is another issue). Before this change, we would
    get ESHUTDOWN for each of the input URBs at suspend time, killing input.
    
    Signed-off-by: Adam Goode <agoode@google.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 9da74d2e8eee..9a4e82cf4ef9 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -2186,6 +2186,34 @@ void snd_usbmidi_input_start(struct list_head* p)
 }
 EXPORT_SYMBOL(snd_usbmidi_input_start);
 
+/*
+ * Prepare for suspend. Typically called from the USB suspend callback.
+ */
+void snd_usbmidi_suspend(struct list_head *p)
+{
+	struct snd_usb_midi *umidi;
+
+	umidi = list_entry(p, struct snd_usb_midi, list);
+	mutex_lock(&umidi->mutex);
+	snd_usbmidi_input_stop(p);
+	mutex_unlock(&umidi->mutex);
+}
+EXPORT_SYMBOL(snd_usbmidi_suspend);
+
+/*
+ * Resume. Typically called from the USB resume callback.
+ */
+void snd_usbmidi_resume(struct list_head *p)
+{
+	struct snd_usb_midi *umidi;
+
+	umidi = list_entry(p, struct snd_usb_midi, list);
+	mutex_lock(&umidi->mutex);
+	snd_usbmidi_input_start(p);
+	mutex_unlock(&umidi->mutex);
+}
+EXPORT_SYMBOL(snd_usbmidi_resume);
+
 /*
  * Creates and registers everything needed for a MIDI streaming interface.
  */

commit 0ba41d917eeb87f608cf147f870ff2f4c1056bab
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 26 13:02:17 2014 +0100

    ALSA: usb-audio: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    As there are too deep indirections (e.g. ep->chip->dev->dev),
    a few new local macros, usb_audio_err() & co, are introduced.
    
    Also, the device numbers in some messages are dropped, as they are
    shown in the prefix automatically.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index b901f468b67a..9da74d2e8eee 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -191,16 +191,16 @@ static int snd_usbmidi_submit_urb(struct urb* urb, gfp_t flags)
 {
 	int err = usb_submit_urb(urb, flags);
 	if (err < 0 && err != -ENODEV)
-		snd_printk(KERN_ERR "usb_submit_urb: %d\n", err);
+		dev_err(&urb->dev->dev, "usb_submit_urb: %d\n", err);
 	return err;
 }
 
 /*
  * Error handling for URB completion functions.
  */
-static int snd_usbmidi_urb_error(int status)
+static int snd_usbmidi_urb_error(const struct urb *urb)
 {
-	switch (status) {
+	switch (urb->status) {
 	/* manually unlinked, or device gone */
 	case -ENOENT:
 	case -ECONNRESET:
@@ -213,7 +213,7 @@ static int snd_usbmidi_urb_error(int status)
 	case -EILSEQ:
 		return -EIO;
 	default:
-		snd_printk(KERN_ERR "urb status %d\n", status);
+		dev_err(&urb->dev->dev, "urb status %d\n", urb->status);
 		return 0; /* continue */
 	}
 }
@@ -227,7 +227,7 @@ static void snd_usbmidi_input_data(struct snd_usb_midi_in_endpoint* ep, int port
 	struct usbmidi_in_port* port = &ep->ports[portidx];
 
 	if (!port->substream) {
-		snd_printd("unexpected port %d!\n", portidx);
+		dev_dbg(&ep->umidi->dev->dev, "unexpected port %d!\n", portidx);
 		return;
 	}
 	if (!test_bit(port->substream->number, &ep->umidi->input_triggered))
@@ -259,7 +259,7 @@ static void snd_usbmidi_in_urb_complete(struct urb* urb)
 		ep->umidi->usb_protocol_ops->input(ep, urb->transfer_buffer,
 						   urb->actual_length);
 	} else {
-		int err = snd_usbmidi_urb_error(urb->status);
+		int err = snd_usbmidi_urb_error(urb);
 		if (err < 0) {
 			if (err != -ENODEV) {
 				ep->error_resubmit = 1;
@@ -289,7 +289,7 @@ static void snd_usbmidi_out_urb_complete(struct urb* urb)
 	}
 	spin_unlock(&ep->buffer_lock);
 	if (urb->status < 0) {
-		int err = snd_usbmidi_urb_error(urb->status);
+		int err = snd_usbmidi_urb_error(urb);
 		if (err < 0) {
 			if (err != -ENODEV)
 				mod_timer(&ep->umidi->error_timer,
@@ -1668,7 +1668,7 @@ static void snd_usbmidi_init_substream(struct snd_usb_midi* umidi,
 
 	struct snd_rawmidi_substream *substream = snd_usbmidi_find_substream(umidi, stream, number);
 	if (!substream) {
-		snd_printd(KERN_ERR "substream %d:%d not found\n", stream, number);
+		dev_err(&umidi->dev->dev, "substream %d:%d not found\n", stream, number);
 		return;
 	}
 
@@ -1717,7 +1717,7 @@ static int snd_usbmidi_create_endpoints(struct snd_usb_midi* umidi,
 			}
 		}
 	}
-	snd_printdd(KERN_INFO "created %d output and %d input ports\n",
+	dev_dbg(&umidi->dev->dev, "created %d output and %d input ports\n",
 		    out_ports, in_ports);
 	return 0;
 }
@@ -1747,10 +1747,11 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
 	    ms_header->bLength >= 7 &&
 	    ms_header->bDescriptorType == USB_DT_CS_INTERFACE &&
 	    ms_header->bDescriptorSubtype == UAC_HEADER)
-		snd_printdd(KERN_INFO "MIDIStreaming version %02x.%02x\n",
+		dev_dbg(&umidi->dev->dev, "MIDIStreaming version %02x.%02x\n",
 			    ms_header->bcdMSC[1], ms_header->bcdMSC[0]);
 	else
-		snd_printk(KERN_WARNING "MIDIStreaming interface descriptor not found\n");
+		dev_warn(&umidi->dev->dev,
+			 "MIDIStreaming interface descriptor not found\n");
 
 	epidx = 0;
 	for (i = 0; i < intfd->bNumEndpoints; ++i) {
@@ -1767,7 +1768,8 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
 		if (usb_endpoint_dir_out(ep)) {
 			if (endpoints[epidx].out_ep) {
 				if (++epidx >= MIDI_MAX_ENDPOINTS) {
-					snd_printk(KERN_WARNING "too many endpoints\n");
+					dev_warn(&umidi->dev->dev,
+						 "too many endpoints\n");
 					break;
 				}
 			}
@@ -1782,12 +1784,13 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
 				 */
 				endpoints[epidx].out_interval = 1;
 			endpoints[epidx].out_cables = (1 << ms_ep->bNumEmbMIDIJack) - 1;
-			snd_printdd(KERN_INFO "EP %02X: %d jack(s)\n",
+			dev_dbg(&umidi->dev->dev, "EP %02X: %d jack(s)\n",
 				    ep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);
 		} else {
 			if (endpoints[epidx].in_ep) {
 				if (++epidx >= MIDI_MAX_ENDPOINTS) {
-					snd_printk(KERN_WARNING "too many endpoints\n");
+					dev_warn(&umidi->dev->dev,
+						 "too many endpoints\n");
 					break;
 				}
 			}
@@ -1797,7 +1800,7 @@ static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
 			else if (snd_usb_get_speed(umidi->dev) == USB_SPEED_LOW)
 				endpoints[epidx].in_interval = 1;
 			endpoints[epidx].in_cables = (1 << ms_ep->bNumEmbMIDIJack) - 1;
-			snd_printdd(KERN_INFO "EP %02X: %d jack(s)\n",
+			dev_dbg(&umidi->dev->dev, "EP %02X: %d jack(s)\n",
 				    ep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);
 		}
 	}
@@ -1865,7 +1868,7 @@ static void snd_usbmidi_switch_roland_altsetting(struct snd_usb_midi* umidi)
 	    (get_endpoint(hostif, 1)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_INT)
 		return;
 
-	snd_printdd(KERN_INFO "switching to altsetting %d with int ep\n",
+	dev_dbg(&umidi->dev->dev, "switching to altsetting %d with int ep\n",
 		    intfd->bAlternateSetting);
 	usb_set_interface(umidi->dev, intfd->bInterfaceNumber,
 			  intfd->bAlternateSetting);
@@ -2047,25 +2050,25 @@ static int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi* umidi,
 	 * input bulk endpoints (at indices 1 and 3) which aren't used.
 	 */
 	if (intfd->bNumEndpoints < (endpoint->out_cables > 0x0001 ? 5 : 3)) {
-		snd_printdd(KERN_ERR "not enough endpoints\n");
+		dev_dbg(&umidi->dev->dev, "not enough endpoints\n");
 		return -ENOENT;
 	}
 
 	epd = get_endpoint(hostif, 0);
 	if (!usb_endpoint_dir_in(epd) || !usb_endpoint_xfer_int(epd)) {
-		snd_printdd(KERN_ERR "endpoint[0] isn't interrupt\n");
+		dev_dbg(&umidi->dev->dev, "endpoint[0] isn't interrupt\n");
 		return -ENXIO;
 	}
 	epd = get_endpoint(hostif, 2);
 	if (!usb_endpoint_dir_out(epd) || !usb_endpoint_xfer_bulk(epd)) {
-		snd_printdd(KERN_ERR "endpoint[2] isn't bulk output\n");
+		dev_dbg(&umidi->dev->dev, "endpoint[2] isn't bulk output\n");
 		return -ENXIO;
 	}
 	if (endpoint->out_cables > 0x0001) {
 		epd = get_endpoint(hostif, 4);
 		if (!usb_endpoint_dir_out(epd) ||
 		    !usb_endpoint_xfer_bulk(epd)) {
-			snd_printdd(KERN_ERR "endpoint[4] isn't bulk output\n");
+			dev_dbg(&umidi->dev->dev, "endpoint[4] isn't bulk output\n");
 			return -ENXIO;
 		}
 	}
@@ -2289,7 +2292,7 @@ int snd_usbmidi_create(struct snd_card *card,
 		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
 		break;
 	default:
-		snd_printd(KERN_ERR "invalid quirk type %d\n", quirk->type);
+		dev_err(&umidi->dev->dev, "invalid quirk type %d\n", quirk->type);
 		err = -ENXIO;
 		break;
 	}

commit a968782e27f1c5144919edbbaf6f10e8b437ab3e
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sat Feb 9 10:05:20 2013 +0100

    ALSA: usb-audio: add MIDI port names for some Roland devices
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 63dd0545a672..b901f468b67a 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1575,8 +1575,41 @@ static struct port_info {
 	EXTERNAL_PORT(0x0582, 0x004d, 0, "%s MIDI"),
 	EXTERNAL_PORT(0x0582, 0x004d, 1, "%s 1"),
 	EXTERNAL_PORT(0x0582, 0x004d, 2, "%s 2"),
+	/* BOSS GT-PRO */
+	CONTROL_PORT(0x0582, 0x0089, 0, "%s Control"),
 	/* Edirol UM-3EX */
 	CONTROL_PORT(0x0582, 0x009a, 3, "%s Control"),
+	/* Roland VG-99 */
+	CONTROL_PORT(0x0582, 0x00b2, 0, "%s Control"),
+	EXTERNAL_PORT(0x0582, 0x00b2, 1, "%s MIDI"),
+	/* Cakewalk Sonar V-Studio 100 */
+	EXTERNAL_PORT(0x0582, 0x00eb, 0, "%s MIDI"),
+	CONTROL_PORT(0x0582, 0x00eb, 1, "%s Control"),
+	/* Roland VB-99 */
+	CONTROL_PORT(0x0582, 0x0102, 0, "%s Control"),
+	EXTERNAL_PORT(0x0582, 0x0102, 1, "%s MIDI"),
+	/* Roland A-PRO */
+	EXTERNAL_PORT(0x0582, 0x010f, 0, "%s MIDI"),
+	CONTROL_PORT(0x0582, 0x010f, 1, "%s 1"),
+	CONTROL_PORT(0x0582, 0x010f, 2, "%s 2"),
+	/* Roland SD-50 */
+	ROLAND_SYNTH_PORT(0x0582, 0x0114, 0, "%s Synth", 128),
+	EXTERNAL_PORT(0x0582, 0x0114, 1, "%s MIDI"),
+	CONTROL_PORT(0x0582, 0x0114, 2, "%s Control"),
+	/* Roland OCTA-CAPTURE */
+	EXTERNAL_PORT(0x0582, 0x0120, 0, "%s MIDI"),
+	CONTROL_PORT(0x0582, 0x0120, 1, "%s Control"),
+	EXTERNAL_PORT(0x0582, 0x0121, 0, "%s MIDI"),
+	CONTROL_PORT(0x0582, 0x0121, 1, "%s Control"),
+	/* Roland SPD-SX */
+	CONTROL_PORT(0x0582, 0x0145, 0, "%s Control"),
+	EXTERNAL_PORT(0x0582, 0x0145, 1, "%s MIDI"),
+	/* Roland A-Series */
+	CONTROL_PORT(0x0582, 0x0156, 0, "%s Keyboard"),
+	EXTERNAL_PORT(0x0582, 0x0156, 1, "%s MIDI"),
+	/* Roland INTEGRA-7 */
+	ROLAND_SYNTH_PORT(0x0582, 0x015b, 0, "%s Synth", 128),
+	CONTROL_PORT(0x0582, 0x015b, 1, "%s Control"),
 	/* M-Audio MidiSport 8x8 */
 	CONTROL_PORT(0x0763, 0x1031, 8, "%s Control"),
 	CONTROL_PORT(0x0763, 0x1033, 8, "%s Control"),

commit aafe77cc45a595ca1d4536f2412ddf671ea9108c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Mar 31 23:43:12 2013 +0200

    ALSA: usb-audio: add support for many Roland/Yamaha devices
    
    Add quirks to detect the various vendor-specific descriptors used by
    Roland and Yamaha in most of their recent USB audio and MIDI devices.
    
    Together with the previous patch, this should add audio/MIDI support for
    the following USB devices:
    - Edirol motion dive .tokyo performance package
    - Roland MC-808 Synthesizer
    - Roland BK-7m Synthesizer
    - Roland VIMA JM-5/8 Synthesizer
    - Roland SP-555 Sequencer
    - Roland V-Synth GT Synthesizer
    - Roland Music Atelier AT-75/100/300/350C/500/800/900/900C Organ
    - Edirol V-Mixer M-200i/300/380/400/480/R-1000
    - BOSS GT-10B Effects Processor
    - Roland Fantom G6/G7/G8 Keyboard
    - Cakewalk Sonar V-Studio 20/100/700 Audio Interface
    - Roland GW-8 Keyboard
    - Roland AX-Synth Keyboard
    - Roland JUNO-Di/STAGE/Gi Keyboard
    - Roland VB-99 Effects Processor
    - Cakewalk UM-2G MIDI Interface
    - Roland A-500S Keyboard
    - Roland SD-50 Synthesizer
    - Roland OCTAPAD SPD-30 Controller
    - Roland Lucina AX-09 Synthesizer
    - BOSS BR-800 Digital Recorder
    - Roland DUO/TRI-CAPTURE (EX) Audio Interface
    - BOSS RC-300 Loop Station
    - Roland JUPITER-50/80 Keyboard
    - Roland R-26 Recorder
    - Roland SPD-SX Controller
    - BOSS JS-10 Audio Player
    - Roland TD-11/15/30 Drum Module
    - Roland A-49/88 Keyboard
    - Roland INTEGRA-7 Synthesizer
    - Roland R-88 Recorder
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 8e01fa4991c5..63dd0545a672 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1947,6 +1947,44 @@ static int snd_usbmidi_detect_yamaha(struct snd_usb_midi* umidi,
 	return snd_usbmidi_detect_endpoints(umidi, endpoint, 1);
 }
 
+/*
+ * Detects the endpoints and ports of Roland devices.
+ */
+static int snd_usbmidi_detect_roland(struct snd_usb_midi* umidi,
+				     struct snd_usb_midi_endpoint_info* endpoint)
+{
+	struct usb_interface* intf;
+	struct usb_host_interface *hostif;
+	u8* cs_desc;
+
+	intf = umidi->iface;
+	if (!intf)
+		return -ENOENT;
+	hostif = intf->altsetting;
+	/*
+	 * Some devices have a descriptor <06 24 F1 02 <inputs> <outputs>>,
+	 * some have standard class descriptors, or both kinds, or neither.
+	 */
+	for (cs_desc = hostif->extra;
+	     cs_desc < hostif->extra + hostif->extralen && cs_desc[0] >= 2;
+	     cs_desc += cs_desc[0]) {
+		if (cs_desc[0] >= 6 &&
+		    cs_desc[1] == USB_DT_CS_INTERFACE &&
+		    cs_desc[2] == 0xf1 &&
+		    cs_desc[3] == 0x02) {
+			endpoint->in_cables  = (1 << cs_desc[4]) - 1;
+			endpoint->out_cables = (1 << cs_desc[5]) - 1;
+			return snd_usbmidi_detect_endpoints(umidi, endpoint, 1);
+		} else if (cs_desc[0] >= 7 &&
+			   cs_desc[1] == USB_DT_CS_INTERFACE &&
+			   cs_desc[2] == UAC_HEADER) {
+			return snd_usbmidi_get_ms_info(umidi, endpoint);
+		}
+	}
+
+	return -ENODEV;
+}
+
 /*
  * Creates the endpoints and their ports for Midiman devices.
  */
@@ -2162,6 +2200,9 @@ int snd_usbmidi_create(struct snd_card *card,
 	case QUIRK_MIDI_YAMAHA:
 		err = snd_usbmidi_detect_yamaha(umidi, &endpoints[0]);
 		break;
+	case QUIRK_MIDI_ROLAND:
+		err = snd_usbmidi_detect_roland(umidi, &endpoints[0]);
+		break;
 	case QUIRK_MIDI_MIDIMAN:
 		umidi->usb_protocol_ops = &snd_usbmidi_midiman_ops;
 		memcpy(&endpoints[0], quirk->data,

commit cbc200bca4b51a8e2406d4b654d978f8503d430b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Apr 15 15:59:51 2013 +0200

    ALSA: usb-audio: disable autopm for MIDI devices
    
    Commit 88a8516a2128 (ALSA: usbaudio: implement USB autosuspend)
    introduced autopm for all USB audio/MIDI devices.  However, many MIDI
    devices, such as synthesizers, do not merely transmit MIDI messages but
    use their MIDI inputs to control other functions.  With autopm, these
    devices would get powered down as soon as the last MIDI port device is
    closed on the host.
    
    Even some plain MIDI interfaces could get broken: they automatically
    send Active Sensing messages while powered up, but as soon as these
    messages cease, the receiving device would interpret this as an
    accidental disconnection.
    
    Commit f5f165418cab (ALSA: usb-audio: Fix missing autopm for MIDI input)
    introduced another regression: some devices (e.g. the Roland GAIA SH-01)
    are self-powered but do a reset whenever the USB interface's power state
    changes.
    
    To work around all this, just disable autopm for all USB MIDI devices.
    
    Reported-by: Laurens Holst
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 60c7aa7579cc..8e01fa4991c5 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -126,7 +126,6 @@ struct snd_usb_midi {
 		struct snd_usb_midi_in_endpoint *in;
 	} endpoints[MIDI_MAX_ENDPOINTS];
 	unsigned long input_triggered;
-	bool autopm_reference;
 	unsigned int opened[2];
 	unsigned char disconnected;
 	unsigned char input_running;
@@ -1040,7 +1039,6 @@ static int substream_open(struct snd_rawmidi_substream *substream, int dir,
 {
 	struct snd_usb_midi* umidi = substream->rmidi->private_data;
 	struct snd_kcontrol *ctl;
-	int err;
 
 	down_read(&umidi->disc_rwsem);
 	if (umidi->disconnected) {
@@ -1051,13 +1049,6 @@ static int substream_open(struct snd_rawmidi_substream *substream, int dir,
 	mutex_lock(&umidi->mutex);
 	if (open) {
 		if (!umidi->opened[0] && !umidi->opened[1]) {
-			err = usb_autopm_get_interface(umidi->iface);
-			umidi->autopm_reference = err >= 0;
-			if (err < 0 && err != -EACCES) {
-				mutex_unlock(&umidi->mutex);
-				up_read(&umidi->disc_rwsem);
-				return -EIO;
-			}
 			if (umidi->roland_load_ctl) {
 				ctl = umidi->roland_load_ctl;
 				ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
@@ -1080,8 +1071,6 @@ static int substream_open(struct snd_rawmidi_substream *substream, int dir,
 				snd_ctl_notify(umidi->card,
 				       SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);
 			}
-			if (umidi->autopm_reference)
-				usb_autopm_put_interface(umidi->iface);
 		}
 	}
 	mutex_unlock(&umidi->mutex);
@@ -2258,6 +2247,8 @@ int snd_usbmidi_create(struct snd_card *card,
 		return err;
 	}
 
+	usb_autopm_get_interface_no_resume(umidi->iface);
+
 	list_add_tail(&umidi->list, midi_list);
 	return 0;
 }

commit ed136aca77144ccc790b58a0a54201909cddc6d6
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Wed Apr 3 23:18:51 2013 +0200

    ALSA: usb-audio: neaten EXPORT_SYMBOLS placement
    
    Put EXPORT_SYMBOLS directly under the exported function.
    
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 1cf943d86bcd..60c7aa7579cc 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1455,6 +1455,7 @@ void snd_usbmidi_disconnect(struct list_head* p)
 	}
 	del_timer_sync(&umidi->error_timer);
 }
+EXPORT_SYMBOL(snd_usbmidi_disconnect);
 
 static void snd_usbmidi_rawmidi_free(struct snd_rawmidi *rmidi)
 {
@@ -2090,6 +2091,7 @@ void snd_usbmidi_input_stop(struct list_head* p)
 	}
 	umidi->input_running = 0;
 }
+EXPORT_SYMBOL(snd_usbmidi_input_stop);
 
 static void snd_usbmidi_input_start_ep(struct snd_usb_midi_in_endpoint* ep)
 {
@@ -2119,6 +2121,7 @@ void snd_usbmidi_input_start(struct list_head* p)
 		snd_usbmidi_input_start_ep(umidi->endpoints[i].in);
 	umidi->input_running = 1;
 }
+EXPORT_SYMBOL(snd_usbmidi_input_start);
 
 /*
  * Creates and registers everything needed for a MIDI streaming interface.
@@ -2258,8 +2261,4 @@ int snd_usbmidi_create(struct snd_card *card,
 	list_add_tail(&umidi->list, midi_list);
 	return 0;
 }
-
 EXPORT_SYMBOL(snd_usbmidi_create);
-EXPORT_SYMBOL(snd_usbmidi_input_stop);
-EXPORT_SYMBOL(snd_usbmidi_input_start);
-EXPORT_SYMBOL(snd_usbmidi_disconnect);

commit 88766f04c4142c0a388a1de354616c3deafba513
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Wed Apr 3 23:18:49 2013 +0200

    ALSA: usb-audio: convert list_for_each to entry variant
    
    Change occurances of list_for_each into list_for_each_entry where
    applicable.
    
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 34b9bb7fe87c..1cf943d86bcd 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1465,10 +1465,9 @@ static void snd_usbmidi_rawmidi_free(struct snd_rawmidi *rmidi)
 static struct snd_rawmidi_substream *snd_usbmidi_find_substream(struct snd_usb_midi* umidi,
 								int stream, int number)
 {
-	struct list_head* list;
+	struct snd_rawmidi_substream *substream;
 
-	list_for_each(list, &umidi->rmidi->streams[stream].substreams) {
-		struct snd_rawmidi_substream *substream = list_entry(list, struct snd_rawmidi_substream, list);
+	list_for_each_entry(substream, &umidi->rmidi->streams[stream].substreams, list) {
 		if (substream->number == number)
 			return substream;
 	}

commit b7b435e81b7228af68b5d3bef277fce10100b369
Author: Damien Zammit <damien@zamaudio.com>
Date:   Fri Jan 4 09:51:44 2013 +0100

    ALSA: usb-audio: Fix kernel panic of Digidesign Mbox2 quirk
    
    This patch is based on 3.8-rc1. It fixes two things:
    1) A kernel panic caused by incorrect allocation of a u8 variable
       "bootresponse".
    2) A noisy dmesg (urb status -32) caused by broken pipe to an
       invalid midi endpoint.
    
    It is also a little cleaner because there is no need for a new
    QUIRK_MIDI type as suggested by kernel developers, since the device
    follows exactly the MIDIMAN protocol.
    
    Signed-off-by: Damien Zammit <damien@zamaudio.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index c183d34842ac..34b9bb7fe87c 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -2181,10 +2181,6 @@ int snd_usbmidi_create(struct snd_card *card,
 		umidi->usb_protocol_ops = &snd_usbmidi_novation_ops;
 		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
 		break;
-	case QUIRK_MIDI_MBOX2:
-		umidi->usb_protocol_ops = &snd_usbmidi_midiman_ops;
-		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
-		break;
 	case QUIRK_MIDI_RAW_BYTES:
 		umidi->usb_protocol_ops = &snd_usbmidi_raw_ops;
 		/*

commit cb99864d40e46dea9c2aa3eaa97517b776f91024
Author: Damien Zammit <damien@zamaudio.com>
Date:   Wed Dec 19 11:27:22 2012 +0100

    ALSA: usb-audio: Support for Digidesign Mbox 2 USB sound card:
    
    This patch is the result of a lot of trial and error, since there are no specs
    available for the device.
    
    Full duplex support is provided, i.e. playback and recording in stereo.
    The format is hardcoded at 48000Hz @ 24 bit, which is the maximum that the
    device supports.  Also, MIDI in and MIDI out both work.
    
    Users will notice that the S/PDIF light also flashes when playback or recording
    is active.  I believe this means that S/PDIF input/output is simultaneously
    activated with the analogue i/o during use.
    But this particular functionality remains untested.
    
    Note that this particular version of the patch is so far untested on the
    physical hardware because I have not compiled a full kernel with the changes.
    However, extensive testing has been done by many users of the hardware
    who believe other versions of my patch have worked since circa 2009.
    
    [Modified to make a function static by tiwai]
    
    Signed-off-by: Damien Zammit <damien@zamaudio.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 34b9bb7fe87c..c183d34842ac 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -2181,6 +2181,10 @@ int snd_usbmidi_create(struct snd_card *card,
 		umidi->usb_protocol_ops = &snd_usbmidi_novation_ops;
 		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
 		break;
+	case QUIRK_MIDI_MBOX2:
+		umidi->usb_protocol_ops = &snd_usbmidi_midiman_ops;
+		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
+		break;
 	case QUIRK_MIDI_RAW_BYTES:
 		umidi->usb_protocol_ops = &snd_usbmidi_raw_ops;
 		/*

commit f5f165418cabf2218eb466c0e94693b8b1aee88b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 3 11:30:50 2012 +0100

    ALSA: usb-audio: Fix missing autopm for MIDI input
    
    The commit [88a8516a: ALSA: usbaudio: implement USB autosuspend] added
    the support of autopm for USB MIDI output, but it didn't take the MIDI
    input into account.
    
    This patch adds the following for fixing the autopm:
    - Manage the URB start at the first MIDI input stream open, instead of
      the time of instance creation
    - Move autopm code to the common substream_open()
    - Make snd_usbmidi_input_start/_stop() more robust and add the running
      state check
    
    Reviewd-by: Clemens Ladisch <clemens@ladisch.de>
    Tested-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index c0054ee9389b..34b9bb7fe87c 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -126,8 +126,10 @@ struct snd_usb_midi {
 		struct snd_usb_midi_in_endpoint *in;
 	} endpoints[MIDI_MAX_ENDPOINTS];
 	unsigned long input_triggered;
-	unsigned int opened;
+	bool autopm_reference;
+	unsigned int opened[2];
 	unsigned char disconnected;
+	unsigned char input_running;
 
 	struct snd_kcontrol *roland_load_ctl;
 };
@@ -149,7 +151,6 @@ struct snd_usb_midi_out_endpoint {
 		struct snd_usb_midi_out_endpoint* ep;
 		struct snd_rawmidi_substream *substream;
 		int active;
-		bool autopm_reference;
 		uint8_t cable;		/* cable number << 4 */
 		uint8_t state;
 #define STATE_UNKNOWN	0
@@ -1034,36 +1035,58 @@ static void update_roland_altsetting(struct snd_usb_midi* umidi)
 	snd_usbmidi_input_start(&umidi->list);
 }
 
-static void substream_open(struct snd_rawmidi_substream *substream, int open)
+static int substream_open(struct snd_rawmidi_substream *substream, int dir,
+			  int open)
 {
 	struct snd_usb_midi* umidi = substream->rmidi->private_data;
 	struct snd_kcontrol *ctl;
+	int err;
 
 	down_read(&umidi->disc_rwsem);
 	if (umidi->disconnected) {
 		up_read(&umidi->disc_rwsem);
-		return;
+		return open ? -ENODEV : 0;
 	}
 
 	mutex_lock(&umidi->mutex);
 	if (open) {
-		if (umidi->opened++ == 0 && umidi->roland_load_ctl) {
-			ctl = umidi->roland_load_ctl;
-			ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
-			snd_ctl_notify(umidi->card,
+		if (!umidi->opened[0] && !umidi->opened[1]) {
+			err = usb_autopm_get_interface(umidi->iface);
+			umidi->autopm_reference = err >= 0;
+			if (err < 0 && err != -EACCES) {
+				mutex_unlock(&umidi->mutex);
+				up_read(&umidi->disc_rwsem);
+				return -EIO;
+			}
+			if (umidi->roland_load_ctl) {
+				ctl = umidi->roland_load_ctl;
+				ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+				snd_ctl_notify(umidi->card,
 				       SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);
-			update_roland_altsetting(umidi);
+				update_roland_altsetting(umidi);
+			}
 		}
+		umidi->opened[dir]++;
+		if (umidi->opened[1])
+			snd_usbmidi_input_start(&umidi->list);
 	} else {
-		if (--umidi->opened == 0 && umidi->roland_load_ctl) {
-			ctl = umidi->roland_load_ctl;
-			ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
-			snd_ctl_notify(umidi->card,
+		umidi->opened[dir]--;
+		if (!umidi->opened[1])
+			snd_usbmidi_input_stop(&umidi->list);
+		if (!umidi->opened[0] && !umidi->opened[1]) {
+			if (umidi->roland_load_ctl) {
+				ctl = umidi->roland_load_ctl;
+				ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+				snd_ctl_notify(umidi->card,
 				       SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);
+			}
+			if (umidi->autopm_reference)
+				usb_autopm_put_interface(umidi->iface);
 		}
 	}
 	mutex_unlock(&umidi->mutex);
 	up_read(&umidi->disc_rwsem);
+	return 0;
 }
 
 static int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)
@@ -1071,7 +1094,6 @@ static int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)
 	struct snd_usb_midi* umidi = substream->rmidi->private_data;
 	struct usbmidi_out_port* port = NULL;
 	int i, j;
-	int err;
 
 	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)
 		if (umidi->endpoints[i].out)
@@ -1085,33 +1107,14 @@ static int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)
 		return -ENXIO;
 	}
 
-	down_read(&umidi->disc_rwsem);
-	if (umidi->disconnected) {
-		up_read(&umidi->disc_rwsem);
-		return -ENODEV;
-	}
-	err = usb_autopm_get_interface(umidi->iface);
-	port->autopm_reference = err >= 0;
-	up_read(&umidi->disc_rwsem);
-	if (err < 0 && err != -EACCES)
-		return -EIO;
 	substream->runtime->private_data = port;
 	port->state = STATE_UNKNOWN;
-	substream_open(substream, 1);
-	return 0;
+	return substream_open(substream, 0, 1);
 }
 
 static int snd_usbmidi_output_close(struct snd_rawmidi_substream *substream)
 {
-	struct snd_usb_midi* umidi = substream->rmidi->private_data;
-	struct usbmidi_out_port *port = substream->runtime->private_data;
-
-	substream_open(substream, 0);
-	down_read(&umidi->disc_rwsem);
-	if (!umidi->disconnected && port->autopm_reference)
-		usb_autopm_put_interface(umidi->iface);
-	up_read(&umidi->disc_rwsem);
-	return 0;
+	return substream_open(substream, 0, 0);
 }
 
 static void snd_usbmidi_output_trigger(struct snd_rawmidi_substream *substream, int up)
@@ -1164,14 +1167,12 @@ static void snd_usbmidi_output_drain(struct snd_rawmidi_substream *substream)
 
 static int snd_usbmidi_input_open(struct snd_rawmidi_substream *substream)
 {
-	substream_open(substream, 1);
-	return 0;
+	return substream_open(substream, 1, 1);
 }
 
 static int snd_usbmidi_input_close(struct snd_rawmidi_substream *substream)
 {
-	substream_open(substream, 0);
-	return 0;
+	return substream_open(substream, 1, 0);
 }
 
 static void snd_usbmidi_input_trigger(struct snd_rawmidi_substream *substream, int up)
@@ -2080,12 +2081,15 @@ void snd_usbmidi_input_stop(struct list_head* p)
 	unsigned int i, j;
 
 	umidi = list_entry(p, struct snd_usb_midi, list);
+	if (!umidi->input_running)
+		return;
 	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
 		struct snd_usb_midi_endpoint* ep = &umidi->endpoints[i];
 		if (ep->in)
 			for (j = 0; j < INPUT_URBS; ++j)
 				usb_kill_urb(ep->in->urbs[j]);
 	}
+	umidi->input_running = 0;
 }
 
 static void snd_usbmidi_input_start_ep(struct snd_usb_midi_in_endpoint* ep)
@@ -2110,8 +2114,11 @@ void snd_usbmidi_input_start(struct list_head* p)
 	int i;
 
 	umidi = list_entry(p, struct snd_usb_midi, list);
+	if (umidi->input_running || !umidi->opened[1])
+		return;
 	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)
 		snd_usbmidi_input_start_ep(umidi->endpoints[i].in);
+	umidi->input_running = 1;
 }
 
 /*
@@ -2250,9 +2257,6 @@ int snd_usbmidi_create(struct snd_card *card,
 	}
 
 	list_add_tail(&umidi->list, midi_list);
-
-	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)
-		snd_usbmidi_input_start_ep(umidi->endpoints[i].in);
 	return 0;
 }
 

commit 59866da9e4ae54819e3c4e0a8f426bdb0c2ef993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 3 11:12:46 2012 +0100

    ALSA: usb-audio: Avoid autopm calls after disconnection
    
    Add a similar protection against the disconnection race and the
    invalid use of usb instance after disconnection, as well as we've done
    for the USB audio PCM.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=51201
    
    Reviewd-by: Clemens Ladisch <clemens@ladisch.de>
    Tested-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index eeefbce3873c..c0054ee9389b 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -116,6 +116,7 @@ struct snd_usb_midi {
 	struct list_head list;
 	struct timer_list error_timer;
 	spinlock_t disc_lock;
+	struct rw_semaphore disc_rwsem;
 	struct mutex mutex;
 	u32 usb_id;
 	int next_midi_device;
@@ -1038,6 +1039,12 @@ static void substream_open(struct snd_rawmidi_substream *substream, int open)
 	struct snd_usb_midi* umidi = substream->rmidi->private_data;
 	struct snd_kcontrol *ctl;
 
+	down_read(&umidi->disc_rwsem);
+	if (umidi->disconnected) {
+		up_read(&umidi->disc_rwsem);
+		return;
+	}
+
 	mutex_lock(&umidi->mutex);
 	if (open) {
 		if (umidi->opened++ == 0 && umidi->roland_load_ctl) {
@@ -1056,6 +1063,7 @@ static void substream_open(struct snd_rawmidi_substream *substream, int open)
 		}
 	}
 	mutex_unlock(&umidi->mutex);
+	up_read(&umidi->disc_rwsem);
 }
 
 static int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)
@@ -1076,8 +1084,15 @@ static int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)
 		snd_BUG();
 		return -ENXIO;
 	}
+
+	down_read(&umidi->disc_rwsem);
+	if (umidi->disconnected) {
+		up_read(&umidi->disc_rwsem);
+		return -ENODEV;
+	}
 	err = usb_autopm_get_interface(umidi->iface);
 	port->autopm_reference = err >= 0;
+	up_read(&umidi->disc_rwsem);
 	if (err < 0 && err != -EACCES)
 		return -EIO;
 	substream->runtime->private_data = port;
@@ -1092,8 +1107,10 @@ static int snd_usbmidi_output_close(struct snd_rawmidi_substream *substream)
 	struct usbmidi_out_port *port = substream->runtime->private_data;
 
 	substream_open(substream, 0);
-	if (port->autopm_reference)
+	down_read(&umidi->disc_rwsem);
+	if (!umidi->disconnected && port->autopm_reference)
 		usb_autopm_put_interface(umidi->iface);
+	up_read(&umidi->disc_rwsem);
 	return 0;
 }
 
@@ -1403,9 +1420,12 @@ void snd_usbmidi_disconnect(struct list_head* p)
 	 * a timer may submit an URB. To reliably break the cycle
 	 * a flag under lock must be used
 	 */
+	down_write(&umidi->disc_rwsem);
 	spin_lock_irq(&umidi->disc_lock);
 	umidi->disconnected = 1;
 	spin_unlock_irq(&umidi->disc_lock);
+	up_write(&umidi->disc_rwsem);
+
 	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
 		struct snd_usb_midi_endpoint* ep = &umidi->endpoints[i];
 		if (ep->out)
@@ -2117,6 +2137,7 @@ int snd_usbmidi_create(struct snd_card *card,
 	umidi->usb_protocol_ops = &snd_usbmidi_standard_ops;
 	init_timer(&umidi->error_timer);
 	spin_lock_init(&umidi->disc_lock);
+	init_rwsem(&umidi->disc_rwsem);
 	mutex_init(&umidi->mutex);
 	umidi->usb_id = USB_ID(le16_to_cpu(umidi->dev->descriptor.idVendor),
 			       le16_to_cpu(umidi->dev->descriptor.idProduct));

commit e99ddfde6ae0dd2662bb40435696002b590e4057
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Oct 31 16:35:30 2012 +0100

    ALSA: ua101, usx2y: fix broken MIDI output
    
    Commit 88a8516a2128 (ALSA: usbaudio: implement USB autosuspend) added
    autosuspend code to all files making up the snd-usb-audio driver.
    However, midi.c is part of snd-usb-lib and is also used by other
    drivers, not all of which support autosuspend.  Thus, calls to
    usb_autopm_get_interface() could fail, and this unexpected error would
    result in the MIDI output being completely unusable.
    
    Make it work by ignoring the error that is expected with drivers that do
    not support autosuspend.
    
    Reported-by: Colin Fletcher <colin.m.fletcher@googlemail.com>
    Reported-by: Devin Venable <venable.devin@gmail.com>
    Reported-by: Dr Nick Bailey <nicholas.bailey@glasgow.ac.uk>
    Reported-by: Jannis Achstetter <jannis_achstetter@web.de>
    Reported-by: Rui Nuno Capela <rncbc@rncbc.org>
    Cc: Oliver Neukum <oliver@neukum.org>
    Cc: 2.6.39+ <stable@vger.kernel.org>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index c83f6143c0eb..eeefbce3873c 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -148,6 +148,7 @@ struct snd_usb_midi_out_endpoint {
 		struct snd_usb_midi_out_endpoint* ep;
 		struct snd_rawmidi_substream *substream;
 		int active;
+		bool autopm_reference;
 		uint8_t cable;		/* cable number << 4 */
 		uint8_t state;
 #define STATE_UNKNOWN	0
@@ -1076,7 +1077,8 @@ static int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)
 		return -ENXIO;
 	}
 	err = usb_autopm_get_interface(umidi->iface);
-	if (err < 0)
+	port->autopm_reference = err >= 0;
+	if (err < 0 && err != -EACCES)
 		return -EIO;
 	substream->runtime->private_data = port;
 	port->state = STATE_UNKNOWN;
@@ -1087,9 +1089,11 @@ static int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)
 static int snd_usbmidi_output_close(struct snd_rawmidi_substream *substream)
 {
 	struct snd_usb_midi* umidi = substream->rmidi->private_data;
+	struct usbmidi_out_port *port = substream->runtime->private_data;
 
 	substream_open(substream, 0);
-	usb_autopm_put_interface(umidi->iface);
+	if (port->autopm_reference)
+		usb_autopm_put_interface(umidi->iface);
 	return 0;
 }
 

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index e21f026d9577..c83f6143c0eb 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -47,6 +47,7 @@
 #include <linux/usb.h>
 #include <linux/wait.h>
 #include <linux/usb/audio.h>
+#include <linux/module.h>
 
 #include <sound/core.h>
 #include <sound/control.h>

commit 1ef0e0a05345b7411bdabbfca27f58bd33dcc7c8
Author: Kristian Amlie <kristian@amlie.name>
Date:   Fri Aug 26 13:19:49 2011 +0200

    ALSA: usb-audio: add Starr Labs USB MIDI support
    
    Add support for Starr Labs USB MIDI devices such as the Z7S, which are
    based on an FTDI serial UART chip.
    
    Based on a patch by Daniel Mack.
    
    Signed-off-by: Kristian Amlie <kristian@amlie.name>
    Acked-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index f9289102886a..e21f026d9577 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -816,6 +816,22 @@ static struct usb_protocol_ops snd_usbmidi_raw_ops = {
 	.output = snd_usbmidi_raw_output,
 };
 
+/*
+ * FTDI protocol: raw MIDI bytes, but input packets have two modem status bytes.
+ */
+
+static void snd_usbmidi_ftdi_input(struct snd_usb_midi_in_endpoint* ep,
+				   uint8_t* buffer, int buffer_length)
+{
+	if (buffer_length > 2)
+		snd_usbmidi_input_data(ep, 0, buffer + 2, buffer_length - 2);
+}
+
+static struct usb_protocol_ops snd_usbmidi_ftdi_ops = {
+	.input = snd_usbmidi_ftdi_input,
+	.output = snd_usbmidi_raw_output,
+};
+
 static void snd_usbmidi_us122l_input(struct snd_usb_midi_in_endpoint *ep,
 				     uint8_t *buffer, int buffer_length)
 {
@@ -2163,6 +2179,17 @@ int snd_usbmidi_create(struct snd_card *card,
 		/* endpoint 1 is input-only */
 		endpoints[1].out_cables = 0;
 		break;
+	case QUIRK_MIDI_FTDI:
+		umidi->usb_protocol_ops = &snd_usbmidi_ftdi_ops;
+
+		/* set baud rate to 31250 (48 MHz / 16 / 96) */
+		err = usb_control_msg(umidi->dev, usb_sndctrlpipe(umidi->dev, 0),
+				      3, 0x40, 0x60, 0, NULL, 0, 1000);
+		if (err < 0)
+			break;
+
+		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
+		break;
 	default:
 		snd_printd(KERN_ERR "invalid quirk type %d\n", quirk->type);
 		err = -ENXIO;

commit 49c039f071d36586ba32da75996ef339e4ab8405
Author: Tarek Soliman <tarek@bashasoliman.com>
Date:   Mon Apr 4 09:23:53 2011 -0500

    ALSA: usb-audio: define another USB ID for a buggy USB MIDI cable
    
    There are many USB MIDI cables out there that have buggy
    firmware that reports it can do more than 4 bytes in a
    packet when they can only properly handle 4
    
    This patch adds the ID of yet another one of those cables
    
    Signed-off-by: Tarek Soliman <tarek@bashasoliman.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index b4b39c0b6c9e..f9289102886a 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1301,6 +1301,7 @@ static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi* umidi,
 	case USB_ID(0x15ca, 0x0101): /* Textech USB Midi Cable */
 	case USB_ID(0x15ca, 0x1806): /* Textech USB Midi Cable */
 	case USB_ID(0x1a86, 0x752d): /* QinHeng CH345 "USB2.0-MIDI" */
+	case USB_ID(0xfc08, 0x0101): /* Unknown vendor Cable */
 		ep->max_transfer = 4;
 		break;
 		/*

commit 88a8516a2128a6d078a106ead48092240e8a138f
Author: Oliver Neukum <oneukum@suse.de>
Date:   Fri Mar 11 14:51:12 2011 +0100

    ALSA: usbaudio: implement USB autosuspend
    
    Devices are autosuspended if no pcm nor midi channel is open
    Mixer devices may be opened. This way they are active when
    in use to play or record sound, but can be suspended while
    users have a mixer application running.
    
    [Small clean-ups using static inline by tiwai]
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index db2dc5ffe6dd..b4b39c0b6c9e 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -54,6 +54,7 @@
 #include <sound/asequencer.h>
 #include "usbaudio.h"
 #include "midi.h"
+#include "power.h"
 #include "helper.h"
 
 /*
@@ -1044,6 +1045,7 @@ static int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)
 	struct snd_usb_midi* umidi = substream->rmidi->private_data;
 	struct usbmidi_out_port* port = NULL;
 	int i, j;
+	int err;
 
 	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)
 		if (umidi->endpoints[i].out)
@@ -1056,6 +1058,9 @@ static int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)
 		snd_BUG();
 		return -ENXIO;
 	}
+	err = usb_autopm_get_interface(umidi->iface);
+	if (err < 0)
+		return -EIO;
 	substream->runtime->private_data = port;
 	port->state = STATE_UNKNOWN;
 	substream_open(substream, 1);
@@ -1064,7 +1069,10 @@ static int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)
 
 static int snd_usbmidi_output_close(struct snd_rawmidi_substream *substream)
 {
+	struct snd_usb_midi* umidi = substream->rmidi->private_data;
+
 	substream_open(substream, 0);
+	usb_autopm_put_interface(umidi->iface);
 	return 0;
 }
 

commit 921eebdc18c82268eab446592191b39e35d031d6
Author: Karsten Wiese <fzu@wemgehoertderstaat.de>
Date:   Mon Jan 3 02:41:58 2011 +0100

    ALSA: snd-usb-us122l: Fix MIDI output
    
    The US-122L always reads 9 bytes per urb unless they are set to 0xFD.
    
    Signed-off-by: Karsten Wiese <fzu@wemgehoertderstaat.de>
    Cc: stable@kernel.org
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index d7021cb01047..db2dc5ffe6dd 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -850,8 +850,8 @@ static void snd_usbmidi_us122l_output(struct snd_usb_midi_out_endpoint *ep,
 		return;
 	}
 
-	memset(urb->transfer_buffer + count, 0xFD, 9 - count);
-	urb->transfer_buffer_length = count;
+	memset(urb->transfer_buffer + count, 0xFD, ep->max_transfer - count);
+	urb->transfer_buffer_length = ep->max_transfer;
 }
 
 static struct usb_protocol_ops snd_usbmidi_122l_ops = {
@@ -1295,6 +1295,13 @@ static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi* umidi,
 	case USB_ID(0x1a86, 0x752d): /* QinHeng CH345 "USB2.0-MIDI" */
 		ep->max_transfer = 4;
 		break;
+		/*
+		 * Some devices only work with 9 bytes packet size:
+		 */
+	case USB_ID(0x0644, 0x800E): /* Tascam US-122L */
+	case USB_ID(0x0644, 0x800F): /* Tascam US-144 */
+		ep->max_transfer = 9;
+		break;
 	}
 	for (i = 0; i < OUTPUT_URBS; ++i) {
 		buffer = usb_alloc_coherent(umidi->dev,

commit 2a1803a7291e82823effef0b48b0039324d224c6
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jan 10 16:30:13 2011 +0100

    ALSA: usb-audio: use enum control info helper
    
    Simplify info callbacks by using the snd_ctl_enum_info() helper function.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 25bce7e5b1af..d7021cb01047 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1729,13 +1729,7 @@ static int roland_load_info(struct snd_kcontrol *kcontrol,
 {
 	static const char *const names[] = { "High Load", "Light Load" };
 
-	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	info->count = 1;
-	info->value.enumerated.items = 2;
-	if (info->value.enumerated.item > 1)
-		info->value.enumerated.item = 1;
-	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(info, 1, 2, names);
 }
 
 static int roland_load_get(struct snd_kcontrol *kcontrol,

commit c7f572168fc4840727c9bda955b7f103922209cd
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Oct 22 18:20:48 2010 +0200

    ALSA: usb-audio: add Novation Launchpad support
    
    Add a quirk entry for the Novation Launchpad USB MIDI controller.
    
    QUIRK_MIDI_FASTLANE gets renamed to *_RAW_BYTES because this quirk type
    is now shared by different devices.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Tested-by: Jakob Flierl <jakob.flierl@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 156cd0716c42..25bce7e5b1af 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -784,7 +784,7 @@ static struct usb_protocol_ops snd_usbmidi_novation_ops = {
 };
 
 /*
- * "raw" protocol: used by the MOTU FastLane.
+ * "raw" protocol: just move raw MIDI bytes from/to the endpoint
  */
 
 static void snd_usbmidi_raw_input(struct snd_usb_midi_in_endpoint* ep,
@@ -2122,7 +2122,7 @@ int snd_usbmidi_create(struct snd_card *card,
 		umidi->usb_protocol_ops = &snd_usbmidi_novation_ops;
 		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
 		break;
-	case QUIRK_MIDI_FASTLANE:
+	case QUIRK_MIDI_RAW_BYTES:
 		umidi->usb_protocol_ops = &snd_usbmidi_raw_ops;
 		/*
 		 * Interface 1 contains isochronous endpoints, but with the same
@@ -2133,7 +2133,8 @@ int snd_usbmidi_create(struct snd_card *card,
 		 * interface 0, so we have to make sure that the USB core looks
 		 * again at interface 0 by calling usb_set_interface() on it.
 		 */
-		usb_set_interface(umidi->dev, 0, 0);
+		if (umidi->usb_id == USB_ID(0x07fd, 0x0001)) /* MOTU Fastlane */
+			usb_set_interface(umidi->dev, 0, 0);
 		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
 		break;
 	case QUIRK_MIDI_EMAGIC:

commit 4f4e8f69895c8696a4bcc751817d4b186023ac44
Author: Paul Zimmerman <Paul.Zimmerman@synopsys.com>
Date:   Fri Aug 13 12:42:07 2010 -0700

    ALSA: usb: USB3 SuperSpeed sound support
    
    This is V2 of the patch, after feedback from Clemens and Daniel.
    
    This patch adds SuperSpeed support to the USB drivers under sound/. It adds
    tests for USB_SPEED_SUPER to the appropriate places that check for the USB
    speed.
    
    This patch has been tested with our SS USB3 device emulating a set of Yamaha
    speakers and a Logitech microphone, but with the descriptors modified to add
    USB3 support. It has also been tested with the real speakers and microphone,
    to make sure that USB2 devices still work.
    
    Signed-off-by: Paul Zimmerman <paulz@synopsys.com>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Cc: Daniel Mack <daniel@caiaq.de>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index b9c2bc65f51a..156cd0716c42 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -834,7 +834,14 @@ static void snd_usbmidi_us122l_output(struct snd_usb_midi_out_endpoint *ep,
 
 	if (!ep->ports[0].active)
 		return;
-	count = snd_usb_get_speed(ep->umidi->dev) == USB_SPEED_HIGH ? 1 : 2;
+	switch (snd_usb_get_speed(ep->umidi->dev)) {
+	case USB_SPEED_HIGH:
+	case USB_SPEED_SUPER:
+		count = 1;
+		break;
+	default:
+		count = 2;
+	}
 	count = snd_rawmidi_transmit(ep->ports[0].substream,
 				     urb->transfer_buffer,
 				     count);

commit 21af7d8c0c0a88f6f9fc6993d73001b4caf23b08
Author: Daniel Mack <daniel@caiaq.de>
Date:   Wed Jun 16 17:57:29 2010 +0200

    ALSA: usb-midi: whitespace fixes
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 46785643c66d..b9c2bc65f51a 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -434,7 +434,7 @@ static void snd_usbmidi_maudio_broken_running_status_input(
 			u8 cin = buffer[i] & 0x0f;
 			struct usbmidi_in_port *port = &ep->ports[cable];
 			int length;
-			
+
 			length = snd_usbmidi_cin_length[cin];
 			if (cin == 0xf && buffer[i + 1] >= 0xf8)
 				; /* realtime msg: no running status change */
@@ -628,13 +628,13 @@ static struct usb_protocol_ops snd_usbmidi_standard_ops = {
 
 static struct usb_protocol_ops snd_usbmidi_midiman_ops = {
 	.input = snd_usbmidi_midiman_input,
-	.output = snd_usbmidi_standard_output, 
+	.output = snd_usbmidi_standard_output,
 	.output_packet = snd_usbmidi_output_midiman_packet,
 };
 
 static struct usb_protocol_ops snd_usbmidi_maudio_broken_running_status_ops = {
 	.input = snd_usbmidi_maudio_broken_running_status_input,
-	.output = snd_usbmidi_standard_output, 
+	.output = snd_usbmidi_standard_output,
 	.output_packet = snd_usbmidi_output_standard_packet,
 };
 
@@ -1248,7 +1248,7 @@ static void snd_usbmidi_out_endpoint_delete(struct snd_usb_midi_out_endpoint *ep
  */
 static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi* umidi,
 					   struct snd_usb_midi_endpoint_info* ep_info,
-			 		   struct snd_usb_midi_endpoint* rep)
+					   struct snd_usb_midi_endpoint* rep)
 {
 	struct snd_usb_midi_out_endpoint* ep;
 	unsigned int i;
@@ -1398,7 +1398,7 @@ static void snd_usbmidi_rawmidi_free(struct snd_rawmidi *rmidi)
 }
 
 static struct snd_rawmidi_substream *snd_usbmidi_find_substream(struct snd_usb_midi* umidi,
-							   int stream, int number)
+								int stream, int number)
 {
 	struct list_head* list;
 
@@ -1811,7 +1811,7 @@ static int snd_usbmidi_detect_endpoints(struct snd_usb_midi* umidi,
 		snd_usbmidi_switch_roland_altsetting(umidi);
 
 	if (endpoint[0].out_ep || endpoint[0].in_ep)
-		return 0;	
+		return 0;
 
 	intf = umidi->iface;
 	if (!intf || intf->num_altsetting < 1)
@@ -1849,7 +1849,7 @@ static int snd_usbmidi_detect_per_port_endpoints(struct snd_usb_midi* umidi,
 						 struct snd_usb_midi_endpoint_info* endpoints)
 {
 	int err, i;
-	
+
 	err = snd_usbmidi_detect_endpoints(umidi, endpoints, MIDI_MAX_ENDPOINTS);
 	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
 		if (endpoints[i].out_ep)

commit 2214482cb00e6da1397c2ecde5b392490eb9637f
Merge: 13da9e200fe4 d21921215af2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 26 08:41:25 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6:
      ALSA: emu10k1: allow high-resolution mixer controls
      ALSA: pcm: fix delta calculation at boundary wraparound
      ALSA: hda_intel: fix handling of non-completion stream interrupts
      ALSA: usb/caiaq: fix Traktor Kontrol X1 ABS_HAT2X axis
      ALSA: hda: Fix model quirk for Dell M1730
      ALSA: hda - iMac9,1 sound fixes
      ALSA: hda: Use LPIB for Toshiba A100-259
      ALSA: hda: Use LPIB for Acer Aspire 5110
      ALSA: aw2-alsa.c: use pci_ids.h defines and fix checkpatch.pl noise
      ALSA: usb-audio: add support for Akai MPD16
      ALSA: pcm: fix the fix of the runtime->boundary calculation

commit 4434ade8c9334a3ab975d8993de456f06841899e
Author: Krzysztof Foltman <wdev@foltman.com>
Date:   Thu May 20 20:31:10 2010 +0100

    ALSA: usb-audio: add support for Akai MPD16
    
    The decoding/encoding is based on own reverse-engineering. Both control and
    data ports are handled. Writing to control port supports SysEx events only,
    as this is the only type of messages that MPD16 recognizes.
    
    Signed-off-by: Krzysztof Foltman <wdev@foltman.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 2c1558c327bb..9c23d89066e4 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -644,6 +644,105 @@ static struct usb_protocol_ops snd_usbmidi_cme_ops = {
 	.output_packet = snd_usbmidi_output_standard_packet,
 };
 
+/*
+ * AKAI MPD16 protocol:
+ *
+ * For control port (endpoint 1):
+ * ==============================
+ * One or more chunks consisting of first byte of (0x10 | msg_len) and then a
+ * SysEx message (msg_len=9 bytes long).
+ *
+ * For data port (endpoint 2):
+ * ===========================
+ * One or more chunks consisting of first byte of (0x20 | msg_len) and then a
+ * MIDI message (msg_len bytes long)
+ *
+ * Messages sent: Active Sense, Note On, Poly Pressure, Control Change.
+ */
+static void snd_usbmidi_akai_input(struct snd_usb_midi_in_endpoint *ep,
+				   uint8_t *buffer, int buffer_length)
+{
+	unsigned int pos = 0;
+	unsigned int len = (unsigned int)buffer_length;
+	while (pos < len) {
+		unsigned int port = (buffer[pos] >> 4) - 1;
+		unsigned int msg_len = buffer[pos] & 0x0f;
+		pos++;
+		if (pos + msg_len <= len && port < 2)
+			snd_usbmidi_input_data(ep, 0, &buffer[pos], msg_len);
+		pos += msg_len;
+	}
+}
+
+#define MAX_AKAI_SYSEX_LEN 9
+
+static void snd_usbmidi_akai_output(struct snd_usb_midi_out_endpoint *ep,
+				    struct urb *urb)
+{
+	uint8_t *msg;
+	int pos, end, count, buf_end;
+	uint8_t tmp[MAX_AKAI_SYSEX_LEN];
+	struct snd_rawmidi_substream *substream = ep->ports[0].substream;
+
+	if (!ep->ports[0].active)
+		return;
+
+	msg = urb->transfer_buffer + urb->transfer_buffer_length;
+	buf_end = ep->max_transfer - MAX_AKAI_SYSEX_LEN - 1;
+
+	/* only try adding more data when there's space for at least 1 SysEx */
+	while (urb->transfer_buffer_length < buf_end) {
+		count = snd_rawmidi_transmit_peek(substream,
+						  tmp, MAX_AKAI_SYSEX_LEN);
+		if (!count) {
+			ep->ports[0].active = 0;
+			return;
+		}
+		/* try to skip non-SysEx data */
+		for (pos = 0; pos < count && tmp[pos] != 0xF0; pos++)
+			;
+
+		if (pos > 0) {
+			snd_rawmidi_transmit_ack(substream, pos);
+			continue;
+		}
+
+		/* look for the start or end marker */
+		for (end = 1; end < count && tmp[end] < 0xF0; end++)
+			;
+
+		/* next SysEx started before the end of current one */
+		if (end < count && tmp[end] == 0xF0) {
+			/* it's incomplete - drop it */
+			snd_rawmidi_transmit_ack(substream, end);
+			continue;
+		}
+		/* SysEx complete */
+		if (end < count && tmp[end] == 0xF7) {
+			/* queue it, ack it, and get the next one */
+			count = end + 1;
+			msg[0] = 0x10 | count;
+			memcpy(&msg[1], tmp, count);
+			snd_rawmidi_transmit_ack(substream, count);
+			urb->transfer_buffer_length += count + 1;
+			msg += count + 1;
+			continue;
+		}
+		/* less than 9 bytes and no end byte - wait for more */
+		if (count < MAX_AKAI_SYSEX_LEN) {
+			ep->ports[0].active = 0;
+			return;
+		}
+		/* 9 bytes and no end marker in sight - malformed, skip it */
+		snd_rawmidi_transmit_ack(substream, count);
+	}
+}
+
+static struct usb_protocol_ops snd_usbmidi_akai_ops = {
+	.input = snd_usbmidi_akai_input,
+	.output = snd_usbmidi_akai_output,
+};
+
 /*
  * Novation USB MIDI protocol: number of data bytes is in the first byte
  * (when receiving) (+1!) or in the second byte (when sending); data begins
@@ -1434,6 +1533,11 @@ static struct port_info {
 	EXTERNAL_PORT(0x086a, 0x0001, 8, "%s Broadcast"),
 	EXTERNAL_PORT(0x086a, 0x0002, 8, "%s Broadcast"),
 	EXTERNAL_PORT(0x086a, 0x0003, 4, "%s Broadcast"),
+	/* Akai MPD16 */
+	CONTROL_PORT(0x09e8, 0x0062, 0, "%s Control"),
+	PORT_INFO(0x09e8, 0x0062, 1, "%s MIDI", 0,
+		SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |
+		SNDRV_SEQ_PORT_TYPE_HARDWARE),
 	/* Access Music Virus TI */
 	EXTERNAL_PORT(0x133e, 0x0815, 0, "%s MIDI"),
 	PORT_INFO(0x133e, 0x0815, 1, "%s Synth", 0,
@@ -2035,6 +2139,12 @@ int snd_usbmidi_create(struct snd_card *card,
 		umidi->usb_protocol_ops = &snd_usbmidi_cme_ops;
 		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
 		break;
+	case QUIRK_MIDI_AKAI:
+		umidi->usb_protocol_ops = &snd_usbmidi_akai_ops;
+		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
+		/* endpoint 1 is input-only */
+		endpoints[1].out_cables = 0;
+		break;
 	default:
 		snd_printd(KERN_ERR "invalid quirk type %d\n", quirk->type);
 		err = -ENXIO;

commit 7a9b149212f3716c598afe973b6261fd58453b7a
Merge: 3d62e3fdce8e e26bcf37234c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 20 21:26:12 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6: (229 commits)
      USB: remove unused usb_buffer_alloc and usb_buffer_free macros
      usb: musb: update gfp/slab.h includes
      USB: ftdi_sio: fix legacy SIO-device header
      USB: kl5usb105: reimplement using generic framework
      USB: kl5usb105: minor clean ups
      USB: kl5usb105: fix memory leak
      USB: io_ti: use kfifo to implement write buffering
      USB: io_ti: remove unsused private counter
      USB: ti_usb: use kfifo to implement write buffering
      USB: ir-usb: fix incorrect write-buffer length
      USB: aircable: fix incorrect write-buffer length
      USB: safe_serial: straighten out read processing
      USB: safe_serial: reimplement read using generic framework
      USB: safe_serial: reimplement write using generic framework
      usb-storage: always print quirks
      USB: usb-storage: trivial debug improvements
      USB: oti6858: use port write fifo
      USB: oti6858: use kfifo to implement write buffering
      USB: cypress_m8: use kfifo to implement write buffering
      USB: cypress_m8: remove unused drain define
      ...
    
    Fix up conflicts (due to usb_buffer_alloc/free renaming) in
            drivers/input/tablet/acecad.c
            drivers/input/tablet/kbtab.c
            drivers/input/tablet/wacom_sys.c
            drivers/media/video/gspca/gspca.c
            sound/usb/usbaudio.c

commit 27762b2ce16d5c6f7bc8ab1aad1b9179076f997a
Merge: 7b7b9042263f 29aac005ff4d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat Apr 10 21:34:56 2010 +0200

    Merge branch 'fix/misc' into topic/usb

commit e5779998bf8b70e48a6cc208c8b61b33bd6117ea
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Mar 4 19:46:13 2010 +0100

    ALSA: usb-audio: refactor code
    
    Clean up the usb audio driver by factoring out a lot of functions to
    separate files. Code for procfs, quirks, urbs, format parsers etc all
    got a new home now.
    
    Moved almost all special quirk handling to quirks.c and introduced new
    generic functions to handle them, so the exceptions do not pollute the
    whole driver.
    
    Renamed usbaudio.c to card.c because this is what it actually does now.
    Renamed usbmidi.c to midi.c for namespace clarity.
    Removed more things from usbaudio.h.
    
    The non-standard drivers were adopted accordingly.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/midi.c b/sound/usb/midi.c
new file mode 100644
index 000000000000..c6ee4a18e513
--- /dev/null
+++ b/sound/usb/midi.c
@@ -0,0 +1,2069 @@
+/*
+ * usbmidi.c - ALSA USB MIDI driver
+ *
+ * Copyright (c) 2002-2009 Clemens Ladisch
+ * All rights reserved.
+ *
+ * Based on the OSS usb-midi driver by NAGANO Daisuke,
+ *          NetBSD's umidi driver by Takuya SHIOZAKI,
+ *          the "USB Device Class Definition for MIDI Devices" by Roland
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed and/or modified under the
+ * terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/bitops.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/usb.h>
+#include <linux/wait.h>
+#include <linux/usb/audio.h>
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/rawmidi.h>
+#include <sound/asequencer.h>
+#include "usbaudio.h"
+#include "midi.h"
+#include "helper.h"
+
+/*
+ * define this to log all USB packets
+ */
+/* #define DUMP_PACKETS */
+
+/*
+ * how long to wait after some USB errors, so that khubd can disconnect() us
+ * without too many spurious errors
+ */
+#define ERROR_DELAY_JIFFIES (HZ / 10)
+
+#define OUTPUT_URBS 7
+#define INPUT_URBS 7
+
+
+MODULE_AUTHOR("Clemens Ladisch <clemens@ladisch.de>");
+MODULE_DESCRIPTION("USB Audio/MIDI helper module");
+MODULE_LICENSE("Dual BSD/GPL");
+
+
+struct usb_ms_header_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubtype;
+	__u8  bcdMSC[2];
+	__le16 wTotalLength;
+} __attribute__ ((packed));
+
+struct usb_ms_endpoint_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubtype;
+	__u8  bNumEmbMIDIJack;
+	__u8  baAssocJackID[0];
+} __attribute__ ((packed));
+
+struct snd_usb_midi_in_endpoint;
+struct snd_usb_midi_out_endpoint;
+struct snd_usb_midi_endpoint;
+
+struct usb_protocol_ops {
+	void (*input)(struct snd_usb_midi_in_endpoint*, uint8_t*, int);
+	void (*output)(struct snd_usb_midi_out_endpoint *ep, struct urb *urb);
+	void (*output_packet)(struct urb*, uint8_t, uint8_t, uint8_t, uint8_t);
+	void (*init_out_endpoint)(struct snd_usb_midi_out_endpoint*);
+	void (*finish_out_endpoint)(struct snd_usb_midi_out_endpoint*);
+};
+
+struct snd_usb_midi {
+	struct usb_device *dev;
+	struct snd_card *card;
+	struct usb_interface *iface;
+	const struct snd_usb_audio_quirk *quirk;
+	struct snd_rawmidi *rmidi;
+	struct usb_protocol_ops* usb_protocol_ops;
+	struct list_head list;
+	struct timer_list error_timer;
+	spinlock_t disc_lock;
+	struct mutex mutex;
+	u32 usb_id;
+	int next_midi_device;
+
+	struct snd_usb_midi_endpoint {
+		struct snd_usb_midi_out_endpoint *out;
+		struct snd_usb_midi_in_endpoint *in;
+	} endpoints[MIDI_MAX_ENDPOINTS];
+	unsigned long input_triggered;
+	unsigned int opened;
+	unsigned char disconnected;
+
+	struct snd_kcontrol *roland_load_ctl;
+};
+
+struct snd_usb_midi_out_endpoint {
+	struct snd_usb_midi* umidi;
+	struct out_urb_context {
+		struct urb *urb;
+		struct snd_usb_midi_out_endpoint *ep;
+	} urbs[OUTPUT_URBS];
+	unsigned int active_urbs;
+	unsigned int drain_urbs;
+	int max_transfer;		/* size of urb buffer */
+	struct tasklet_struct tasklet;
+	unsigned int next_urb;
+	spinlock_t buffer_lock;
+
+	struct usbmidi_out_port {
+		struct snd_usb_midi_out_endpoint* ep;
+		struct snd_rawmidi_substream *substream;
+		int active;
+		uint8_t cable;		/* cable number << 4 */
+		uint8_t state;
+#define STATE_UNKNOWN	0
+#define STATE_1PARAM	1
+#define STATE_2PARAM_1	2
+#define STATE_2PARAM_2	3
+#define STATE_SYSEX_0	4
+#define STATE_SYSEX_1	5
+#define STATE_SYSEX_2	6
+		uint8_t data[2];
+	} ports[0x10];
+	int current_port;
+
+	wait_queue_head_t drain_wait;
+};
+
+struct snd_usb_midi_in_endpoint {
+	struct snd_usb_midi* umidi;
+	struct urb* urbs[INPUT_URBS];
+	struct usbmidi_in_port {
+		struct snd_rawmidi_substream *substream;
+		u8 running_status_length;
+	} ports[0x10];
+	u8 seen_f5;
+	u8 error_resubmit;
+	int current_port;
+};
+
+static void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint* ep);
+
+static const uint8_t snd_usbmidi_cin_length[] = {
+	0, 0, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 2, 2, 3, 1
+};
+
+/*
+ * Submits the URB, with error handling.
+ */
+static int snd_usbmidi_submit_urb(struct urb* urb, gfp_t flags)
+{
+	int err = usb_submit_urb(urb, flags);
+	if (err < 0 && err != -ENODEV)
+		snd_printk(KERN_ERR "usb_submit_urb: %d\n", err);
+	return err;
+}
+
+/*
+ * Error handling for URB completion functions.
+ */
+static int snd_usbmidi_urb_error(int status)
+{
+	switch (status) {
+	/* manually unlinked, or device gone */
+	case -ENOENT:
+	case -ECONNRESET:
+	case -ESHUTDOWN:
+	case -ENODEV:
+		return -ENODEV;
+	/* errors that might occur during unplugging */
+	case -EPROTO:
+	case -ETIME:
+	case -EILSEQ:
+		return -EIO;
+	default:
+		snd_printk(KERN_ERR "urb status %d\n", status);
+		return 0; /* continue */
+	}
+}
+
+/*
+ * Receives a chunk of MIDI data.
+ */
+static void snd_usbmidi_input_data(struct snd_usb_midi_in_endpoint* ep, int portidx,
+				   uint8_t* data, int length)
+{
+	struct usbmidi_in_port* port = &ep->ports[portidx];
+
+	if (!port->substream) {
+		snd_printd("unexpected port %d!\n", portidx);
+		return;
+	}
+	if (!test_bit(port->substream->number, &ep->umidi->input_triggered))
+		return;
+	snd_rawmidi_receive(port->substream, data, length);
+}
+
+#ifdef DUMP_PACKETS
+static void dump_urb(const char *type, const u8 *data, int length)
+{
+	snd_printk(KERN_DEBUG "%s packet: [", type);
+	for (; length > 0; ++data, --length)
+		printk(" %02x", *data);
+	printk(" ]\n");
+}
+#else
+#define dump_urb(type, data, length) /* nothing */
+#endif
+
+/*
+ * Processes the data read from the device.
+ */
+static void snd_usbmidi_in_urb_complete(struct urb* urb)
+{
+	struct snd_usb_midi_in_endpoint* ep = urb->context;
+
+	if (urb->status == 0) {
+		dump_urb("received", urb->transfer_buffer, urb->actual_length);
+		ep->umidi->usb_protocol_ops->input(ep, urb->transfer_buffer,
+						   urb->actual_length);
+	} else {
+		int err = snd_usbmidi_urb_error(urb->status);
+		if (err < 0) {
+			if (err != -ENODEV) {
+				ep->error_resubmit = 1;
+				mod_timer(&ep->umidi->error_timer,
+					  jiffies + ERROR_DELAY_JIFFIES);
+			}
+			return;
+		}
+	}
+
+	urb->dev = ep->umidi->dev;
+	snd_usbmidi_submit_urb(urb, GFP_ATOMIC);
+}
+
+static void snd_usbmidi_out_urb_complete(struct urb* urb)
+{
+	struct out_urb_context *context = urb->context;
+	struct snd_usb_midi_out_endpoint* ep = context->ep;
+	unsigned int urb_index;
+
+	spin_lock(&ep->buffer_lock);
+	urb_index = context - ep->urbs;
+	ep->active_urbs &= ~(1 << urb_index);
+	if (unlikely(ep->drain_urbs)) {
+		ep->drain_urbs &= ~(1 << urb_index);
+		wake_up(&ep->drain_wait);
+	}
+	spin_unlock(&ep->buffer_lock);
+	if (urb->status < 0) {
+		int err = snd_usbmidi_urb_error(urb->status);
+		if (err < 0) {
+			if (err != -ENODEV)
+				mod_timer(&ep->umidi->error_timer,
+					  jiffies + ERROR_DELAY_JIFFIES);
+			return;
+		}
+	}
+	snd_usbmidi_do_output(ep);
+}
+
+/*
+ * This is called when some data should be transferred to the device
+ * (from one or more substreams).
+ */
+static void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint* ep)
+{
+	unsigned int urb_index;
+	struct urb* urb;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ep->buffer_lock, flags);
+	if (ep->umidi->disconnected) {
+		spin_unlock_irqrestore(&ep->buffer_lock, flags);
+		return;
+	}
+
+	urb_index = ep->next_urb;
+	for (;;) {
+		if (!(ep->active_urbs & (1 << urb_index))) {
+			urb = ep->urbs[urb_index].urb;
+			urb->transfer_buffer_length = 0;
+			ep->umidi->usb_protocol_ops->output(ep, urb);
+			if (urb->transfer_buffer_length == 0)
+				break;
+
+			dump_urb("sending", urb->transfer_buffer,
+				 urb->transfer_buffer_length);
+			urb->dev = ep->umidi->dev;
+			if (snd_usbmidi_submit_urb(urb, GFP_ATOMIC) < 0)
+				break;
+			ep->active_urbs |= 1 << urb_index;
+		}
+		if (++urb_index >= OUTPUT_URBS)
+			urb_index = 0;
+		if (urb_index == ep->next_urb)
+			break;
+	}
+	ep->next_urb = urb_index;
+	spin_unlock_irqrestore(&ep->buffer_lock, flags);
+}
+
+static void snd_usbmidi_out_tasklet(unsigned long data)
+{
+	struct snd_usb_midi_out_endpoint* ep = (struct snd_usb_midi_out_endpoint *) data;
+
+	snd_usbmidi_do_output(ep);
+}
+
+/* called after transfers had been interrupted due to some USB error */
+static void snd_usbmidi_error_timer(unsigned long data)
+{
+	struct snd_usb_midi *umidi = (struct snd_usb_midi *)data;
+	unsigned int i, j;
+
+	spin_lock(&umidi->disc_lock);
+	if (umidi->disconnected) {
+		spin_unlock(&umidi->disc_lock);
+		return;
+	}
+	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
+		struct snd_usb_midi_in_endpoint *in = umidi->endpoints[i].in;
+		if (in && in->error_resubmit) {
+			in->error_resubmit = 0;
+			for (j = 0; j < INPUT_URBS; ++j) {
+				in->urbs[j]->dev = umidi->dev;
+				snd_usbmidi_submit_urb(in->urbs[j], GFP_ATOMIC);
+			}
+		}
+		if (umidi->endpoints[i].out)
+			snd_usbmidi_do_output(umidi->endpoints[i].out);
+	}
+	spin_unlock(&umidi->disc_lock);
+}
+
+/* helper function to send static data that may not DMA-able */
+static int send_bulk_static_data(struct snd_usb_midi_out_endpoint* ep,
+				 const void *data, int len)
+{
+	int err = 0;
+	void *buf = kmemdup(data, len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	dump_urb("sending", buf, len);
+	if (ep->urbs[0].urb)
+		err = usb_bulk_msg(ep->umidi->dev, ep->urbs[0].urb->pipe,
+				   buf, len, NULL, 250);
+	kfree(buf);
+	return err;
+}
+
+/*
+ * Standard USB MIDI protocol: see the spec.
+ * Midiman protocol: like the standard protocol, but the control byte is the
+ * fourth byte in each packet, and uses length instead of CIN.
+ */
+
+static void snd_usbmidi_standard_input(struct snd_usb_midi_in_endpoint* ep,
+				       uint8_t* buffer, int buffer_length)
+{
+	int i;
+
+	for (i = 0; i + 3 < buffer_length; i += 4)
+		if (buffer[i] != 0) {
+			int cable = buffer[i] >> 4;
+			int length = snd_usbmidi_cin_length[buffer[i] & 0x0f];
+			snd_usbmidi_input_data(ep, cable, &buffer[i + 1], length);
+		}
+}
+
+static void snd_usbmidi_midiman_input(struct snd_usb_midi_in_endpoint* ep,
+				      uint8_t* buffer, int buffer_length)
+{
+	int i;
+
+	for (i = 0; i + 3 < buffer_length; i += 4)
+		if (buffer[i + 3] != 0) {
+			int port = buffer[i + 3] >> 4;
+			int length = buffer[i + 3] & 3;
+			snd_usbmidi_input_data(ep, port, &buffer[i], length);
+		}
+}
+
+/*
+ * Buggy M-Audio device: running status on input results in a packet that has
+ * the data bytes but not the status byte and that is marked with CIN 4.
+ */
+static void snd_usbmidi_maudio_broken_running_status_input(
+					struct snd_usb_midi_in_endpoint* ep,
+					uint8_t* buffer, int buffer_length)
+{
+	int i;
+
+	for (i = 0; i + 3 < buffer_length; i += 4)
+		if (buffer[i] != 0) {
+			int cable = buffer[i] >> 4;
+			u8 cin = buffer[i] & 0x0f;
+			struct usbmidi_in_port *port = &ep->ports[cable];
+			int length;
+			
+			length = snd_usbmidi_cin_length[cin];
+			if (cin == 0xf && buffer[i + 1] >= 0xf8)
+				; /* realtime msg: no running status change */
+			else if (cin >= 0x8 && cin <= 0xe)
+				/* channel msg */
+				port->running_status_length = length - 1;
+			else if (cin == 0x4 &&
+				 port->running_status_length != 0 &&
+				 buffer[i + 1] < 0x80)
+				/* CIN 4 that is not a SysEx */
+				length = port->running_status_length;
+			else
+				/*
+				 * All other msgs cannot begin running status.
+				 * (A channel msg sent as two or three CIN 0xF
+				 * packets could in theory, but this device
+				 * doesn't use this format.)
+				 */
+				port->running_status_length = 0;
+			snd_usbmidi_input_data(ep, cable, &buffer[i + 1], length);
+		}
+}
+
+/*
+ * CME protocol: like the standard protocol, but SysEx commands are sent as a
+ * single USB packet preceded by a 0x0F byte.
+ */
+static void snd_usbmidi_cme_input(struct snd_usb_midi_in_endpoint *ep,
+				  uint8_t *buffer, int buffer_length)
+{
+	if (buffer_length < 2 || (buffer[0] & 0x0f) != 0x0f)
+		snd_usbmidi_standard_input(ep, buffer, buffer_length);
+	else
+		snd_usbmidi_input_data(ep, buffer[0] >> 4,
+				       &buffer[1], buffer_length - 1);
+}
+
+/*
+ * Adds one USB MIDI packet to the output buffer.
+ */
+static void snd_usbmidi_output_standard_packet(struct urb* urb, uint8_t p0,
+					       uint8_t p1, uint8_t p2, uint8_t p3)
+{
+
+	uint8_t* buf = (uint8_t*)urb->transfer_buffer + urb->transfer_buffer_length;
+	buf[0] = p0;
+	buf[1] = p1;
+	buf[2] = p2;
+	buf[3] = p3;
+	urb->transfer_buffer_length += 4;
+}
+
+/*
+ * Adds one Midiman packet to the output buffer.
+ */
+static void snd_usbmidi_output_midiman_packet(struct urb* urb, uint8_t p0,
+					      uint8_t p1, uint8_t p2, uint8_t p3)
+{
+
+	uint8_t* buf = (uint8_t*)urb->transfer_buffer + urb->transfer_buffer_length;
+	buf[0] = p1;
+	buf[1] = p2;
+	buf[2] = p3;
+	buf[3] = (p0 & 0xf0) | snd_usbmidi_cin_length[p0 & 0x0f];
+	urb->transfer_buffer_length += 4;
+}
+
+/*
+ * Converts MIDI commands to USB MIDI packets.
+ */
+static void snd_usbmidi_transmit_byte(struct usbmidi_out_port* port,
+				      uint8_t b, struct urb* urb)
+{
+	uint8_t p0 = port->cable;
+	void (*output_packet)(struct urb*, uint8_t, uint8_t, uint8_t, uint8_t) =
+		port->ep->umidi->usb_protocol_ops->output_packet;
+
+	if (b >= 0xf8) {
+		output_packet(urb, p0 | 0x0f, b, 0, 0);
+	} else if (b >= 0xf0) {
+		switch (b) {
+		case 0xf0:
+			port->data[0] = b;
+			port->state = STATE_SYSEX_1;
+			break;
+		case 0xf1:
+		case 0xf3:
+			port->data[0] = b;
+			port->state = STATE_1PARAM;
+			break;
+		case 0xf2:
+			port->data[0] = b;
+			port->state = STATE_2PARAM_1;
+			break;
+		case 0xf4:
+		case 0xf5:
+			port->state = STATE_UNKNOWN;
+			break;
+		case 0xf6:
+			output_packet(urb, p0 | 0x05, 0xf6, 0, 0);
+			port->state = STATE_UNKNOWN;
+			break;
+		case 0xf7:
+			switch (port->state) {
+			case STATE_SYSEX_0:
+				output_packet(urb, p0 | 0x05, 0xf7, 0, 0);
+				break;
+			case STATE_SYSEX_1:
+				output_packet(urb, p0 | 0x06, port->data[0], 0xf7, 0);
+				break;
+			case STATE_SYSEX_2:
+				output_packet(urb, p0 | 0x07, port->data[0], port->data[1], 0xf7);
+				break;
+			}
+			port->state = STATE_UNKNOWN;
+			break;
+		}
+	} else if (b >= 0x80) {
+		port->data[0] = b;
+		if (b >= 0xc0 && b <= 0xdf)
+			port->state = STATE_1PARAM;
+		else
+			port->state = STATE_2PARAM_1;
+	} else { /* b < 0x80 */
+		switch (port->state) {
+		case STATE_1PARAM:
+			if (port->data[0] < 0xf0) {
+				p0 |= port->data[0] >> 4;
+			} else {
+				p0 |= 0x02;
+				port->state = STATE_UNKNOWN;
+			}
+			output_packet(urb, p0, port->data[0], b, 0);
+			break;
+		case STATE_2PARAM_1:
+			port->data[1] = b;
+			port->state = STATE_2PARAM_2;
+			break;
+		case STATE_2PARAM_2:
+			if (port->data[0] < 0xf0) {
+				p0 |= port->data[0] >> 4;
+				port->state = STATE_2PARAM_1;
+			} else {
+				p0 |= 0x03;
+				port->state = STATE_UNKNOWN;
+			}
+			output_packet(urb, p0, port->data[0], port->data[1], b);
+			break;
+		case STATE_SYSEX_0:
+			port->data[0] = b;
+			port->state = STATE_SYSEX_1;
+			break;
+		case STATE_SYSEX_1:
+			port->data[1] = b;
+			port->state = STATE_SYSEX_2;
+			break;
+		case STATE_SYSEX_2:
+			output_packet(urb, p0 | 0x04, port->data[0], port->data[1], b);
+			port->state = STATE_SYSEX_0;
+			break;
+		}
+	}
+}
+
+static void snd_usbmidi_standard_output(struct snd_usb_midi_out_endpoint* ep,
+					struct urb *urb)
+{
+	int p;
+
+	/* FIXME: lower-numbered ports can starve higher-numbered ports */
+	for (p = 0; p < 0x10; ++p) {
+		struct usbmidi_out_port* port = &ep->ports[p];
+		if (!port->active)
+			continue;
+		while (urb->transfer_buffer_length + 3 < ep->max_transfer) {
+			uint8_t b;
+			if (snd_rawmidi_transmit(port->substream, &b, 1) != 1) {
+				port->active = 0;
+				break;
+			}
+			snd_usbmidi_transmit_byte(port, b, urb);
+		}
+	}
+}
+
+static struct usb_protocol_ops snd_usbmidi_standard_ops = {
+	.input = snd_usbmidi_standard_input,
+	.output = snd_usbmidi_standard_output,
+	.output_packet = snd_usbmidi_output_standard_packet,
+};
+
+static struct usb_protocol_ops snd_usbmidi_midiman_ops = {
+	.input = snd_usbmidi_midiman_input,
+	.output = snd_usbmidi_standard_output, 
+	.output_packet = snd_usbmidi_output_midiman_packet,
+};
+
+static struct usb_protocol_ops snd_usbmidi_maudio_broken_running_status_ops = {
+	.input = snd_usbmidi_maudio_broken_running_status_input,
+	.output = snd_usbmidi_standard_output, 
+	.output_packet = snd_usbmidi_output_standard_packet,
+};
+
+static struct usb_protocol_ops snd_usbmidi_cme_ops = {
+	.input = snd_usbmidi_cme_input,
+	.output = snd_usbmidi_standard_output,
+	.output_packet = snd_usbmidi_output_standard_packet,
+};
+
+/*
+ * Novation USB MIDI protocol: number of data bytes is in the first byte
+ * (when receiving) (+1!) or in the second byte (when sending); data begins
+ * at the third byte.
+ */
+
+static void snd_usbmidi_novation_input(struct snd_usb_midi_in_endpoint* ep,
+				       uint8_t* buffer, int buffer_length)
+{
+	if (buffer_length < 2 || !buffer[0] || buffer_length < buffer[0] + 1)
+		return;
+	snd_usbmidi_input_data(ep, 0, &buffer[2], buffer[0] - 1);
+}
+
+static void snd_usbmidi_novation_output(struct snd_usb_midi_out_endpoint* ep,
+					struct urb *urb)
+{
+	uint8_t* transfer_buffer;
+	int count;
+
+	if (!ep->ports[0].active)
+		return;
+	transfer_buffer = urb->transfer_buffer;
+	count = snd_rawmidi_transmit(ep->ports[0].substream,
+				     &transfer_buffer[2],
+				     ep->max_transfer - 2);
+	if (count < 1) {
+		ep->ports[0].active = 0;
+		return;
+	}
+	transfer_buffer[0] = 0;
+	transfer_buffer[1] = count;
+	urb->transfer_buffer_length = 2 + count;
+}
+
+static struct usb_protocol_ops snd_usbmidi_novation_ops = {
+	.input = snd_usbmidi_novation_input,
+	.output = snd_usbmidi_novation_output,
+};
+
+/*
+ * "raw" protocol: used by the MOTU FastLane.
+ */
+
+static void snd_usbmidi_raw_input(struct snd_usb_midi_in_endpoint* ep,
+				  uint8_t* buffer, int buffer_length)
+{
+	snd_usbmidi_input_data(ep, 0, buffer, buffer_length);
+}
+
+static void snd_usbmidi_raw_output(struct snd_usb_midi_out_endpoint* ep,
+				   struct urb *urb)
+{
+	int count;
+
+	if (!ep->ports[0].active)
+		return;
+	count = snd_rawmidi_transmit(ep->ports[0].substream,
+				     urb->transfer_buffer,
+				     ep->max_transfer);
+	if (count < 1) {
+		ep->ports[0].active = 0;
+		return;
+	}
+	urb->transfer_buffer_length = count;
+}
+
+static struct usb_protocol_ops snd_usbmidi_raw_ops = {
+	.input = snd_usbmidi_raw_input,
+	.output = snd_usbmidi_raw_output,
+};
+
+static void snd_usbmidi_us122l_input(struct snd_usb_midi_in_endpoint *ep,
+				     uint8_t *buffer, int buffer_length)
+{
+	if (buffer_length != 9)
+		return;
+	buffer_length = 8;
+	while (buffer_length && buffer[buffer_length - 1] == 0xFD)
+		buffer_length--;
+	if (buffer_length)
+		snd_usbmidi_input_data(ep, 0, buffer, buffer_length);
+}
+
+static void snd_usbmidi_us122l_output(struct snd_usb_midi_out_endpoint *ep,
+				      struct urb *urb)
+{
+	int count;
+
+	if (!ep->ports[0].active)
+		return;
+	count = snd_usb_get_speed(ep->umidi->dev) == USB_SPEED_HIGH ? 1 : 2;
+	count = snd_rawmidi_transmit(ep->ports[0].substream,
+				     urb->transfer_buffer,
+				     count);
+	if (count < 1) {
+		ep->ports[0].active = 0;
+		return;
+	}
+
+	memset(urb->transfer_buffer + count, 0xFD, 9 - count);
+	urb->transfer_buffer_length = count;
+}
+
+static struct usb_protocol_ops snd_usbmidi_122l_ops = {
+	.input = snd_usbmidi_us122l_input,
+	.output = snd_usbmidi_us122l_output,
+};
+
+/*
+ * Emagic USB MIDI protocol: raw MIDI with "F5 xx" port switching.
+ */
+
+static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint* ep)
+{
+	static const u8 init_data[] = {
+		/* initialization magic: "get version" */
+		0xf0,
+		0x00, 0x20, 0x31,	/* Emagic */
+		0x64,			/* Unitor8 */
+		0x0b,			/* version number request */
+		0x00,			/* command version */
+		0x00,			/* EEPROM, box 0 */
+		0xf7
+	};
+	send_bulk_static_data(ep, init_data, sizeof(init_data));
+	/* while we're at it, pour on more magic */
+	send_bulk_static_data(ep, init_data, sizeof(init_data));
+}
+
+static void snd_usbmidi_emagic_finish_out(struct snd_usb_midi_out_endpoint* ep)
+{
+	static const u8 finish_data[] = {
+		/* switch to patch mode with last preset */
+		0xf0,
+		0x00, 0x20, 0x31,	/* Emagic */
+		0x64,			/* Unitor8 */
+		0x10,			/* patch switch command */
+		0x00,			/* command version */
+		0x7f,			/* to all boxes */
+		0x40,			/* last preset in EEPROM */
+		0xf7
+	};
+	send_bulk_static_data(ep, finish_data, sizeof(finish_data));
+}
+
+static void snd_usbmidi_emagic_input(struct snd_usb_midi_in_endpoint* ep,
+				     uint8_t* buffer, int buffer_length)
+{
+	int i;
+
+	/* FF indicates end of valid data */
+	for (i = 0; i < buffer_length; ++i)
+		if (buffer[i] == 0xff) {
+			buffer_length = i;
+			break;
+		}
+
+	/* handle F5 at end of last buffer */
+	if (ep->seen_f5)
+		goto switch_port;
+
+	while (buffer_length > 0) {
+		/* determine size of data until next F5 */
+		for (i = 0; i < buffer_length; ++i)
+			if (buffer[i] == 0xf5)
+				break;
+		snd_usbmidi_input_data(ep, ep->current_port, buffer, i);
+		buffer += i;
+		buffer_length -= i;
+
+		if (buffer_length <= 0)
+			break;
+		/* assert(buffer[0] == 0xf5); */
+		ep->seen_f5 = 1;
+		++buffer;
+		--buffer_length;
+
+	switch_port:
+		if (buffer_length <= 0)
+			break;
+		if (buffer[0] < 0x80) {
+			ep->current_port = (buffer[0] - 1) & 15;
+			++buffer;
+			--buffer_length;
+		}
+		ep->seen_f5 = 0;
+	}
+}
+
+static void snd_usbmidi_emagic_output(struct snd_usb_midi_out_endpoint* ep,
+				      struct urb *urb)
+{
+	int port0 = ep->current_port;
+	uint8_t* buf = urb->transfer_buffer;
+	int buf_free = ep->max_transfer;
+	int length, i;
+
+	for (i = 0; i < 0x10; ++i) {
+		/* round-robin, starting at the last current port */
+		int portnum = (port0 + i) & 15;
+		struct usbmidi_out_port* port = &ep->ports[portnum];
+
+		if (!port->active)
+			continue;
+		if (snd_rawmidi_transmit_peek(port->substream, buf, 1) != 1) {
+			port->active = 0;
+			continue;
+		}
+
+		if (portnum != ep->current_port) {
+			if (buf_free < 2)
+				break;
+			ep->current_port = portnum;
+			buf[0] = 0xf5;
+			buf[1] = (portnum + 1) & 15;
+			buf += 2;
+			buf_free -= 2;
+		}
+
+		if (buf_free < 1)
+			break;
+		length = snd_rawmidi_transmit(port->substream, buf, buf_free);
+		if (length > 0) {
+			buf += length;
+			buf_free -= length;
+			if (buf_free < 1)
+				break;
+		}
+	}
+	if (buf_free < ep->max_transfer && buf_free > 0) {
+		*buf = 0xff;
+		--buf_free;
+	}
+	urb->transfer_buffer_length = ep->max_transfer - buf_free;
+}
+
+static struct usb_protocol_ops snd_usbmidi_emagic_ops = {
+	.input = snd_usbmidi_emagic_input,
+	.output = snd_usbmidi_emagic_output,
+	.init_out_endpoint = snd_usbmidi_emagic_init_out,
+	.finish_out_endpoint = snd_usbmidi_emagic_finish_out,
+};
+
+
+static void update_roland_altsetting(struct snd_usb_midi* umidi)
+{
+	struct usb_interface *intf;
+	struct usb_host_interface *hostif;
+	struct usb_interface_descriptor *intfd;
+	int is_light_load;
+
+	intf = umidi->iface;
+	is_light_load = intf->cur_altsetting != intf->altsetting;
+	if (umidi->roland_load_ctl->private_value == is_light_load)
+		return;
+	hostif = &intf->altsetting[umidi->roland_load_ctl->private_value];
+	intfd = get_iface_desc(hostif);
+	snd_usbmidi_input_stop(&umidi->list);
+	usb_set_interface(umidi->dev, intfd->bInterfaceNumber,
+			  intfd->bAlternateSetting);
+	snd_usbmidi_input_start(&umidi->list);
+}
+
+static void substream_open(struct snd_rawmidi_substream *substream, int open)
+{
+	struct snd_usb_midi* umidi = substream->rmidi->private_data;
+	struct snd_kcontrol *ctl;
+
+	mutex_lock(&umidi->mutex);
+	if (open) {
+		if (umidi->opened++ == 0 && umidi->roland_load_ctl) {
+			ctl = umidi->roland_load_ctl;
+			ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+			snd_ctl_notify(umidi->card,
+				       SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);
+			update_roland_altsetting(umidi);
+		}
+	} else {
+		if (--umidi->opened == 0 && umidi->roland_load_ctl) {
+			ctl = umidi->roland_load_ctl;
+			ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+			snd_ctl_notify(umidi->card,
+				       SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);
+		}
+	}
+	mutex_unlock(&umidi->mutex);
+}
+
+static int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream)
+{
+	struct snd_usb_midi* umidi = substream->rmidi->private_data;
+	struct usbmidi_out_port* port = NULL;
+	int i, j;
+
+	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)
+		if (umidi->endpoints[i].out)
+			for (j = 0; j < 0x10; ++j)
+				if (umidi->endpoints[i].out->ports[j].substream == substream) {
+					port = &umidi->endpoints[i].out->ports[j];
+					break;
+				}
+	if (!port) {
+		snd_BUG();
+		return -ENXIO;
+	}
+	substream->runtime->private_data = port;
+	port->state = STATE_UNKNOWN;
+	substream_open(substream, 1);
+	return 0;
+}
+
+static int snd_usbmidi_output_close(struct snd_rawmidi_substream *substream)
+{
+	substream_open(substream, 0);
+	return 0;
+}
+
+static void snd_usbmidi_output_trigger(struct snd_rawmidi_substream *substream, int up)
+{
+	struct usbmidi_out_port* port = (struct usbmidi_out_port*)substream->runtime->private_data;
+
+	port->active = up;
+	if (up) {
+		if (port->ep->umidi->disconnected) {
+			/* gobble up remaining bytes to prevent wait in
+			 * snd_rawmidi_drain_output */
+			while (!snd_rawmidi_transmit_empty(substream))
+				snd_rawmidi_transmit_ack(substream, 1);
+			return;
+		}
+		tasklet_schedule(&port->ep->tasklet);
+	}
+}
+
+static void snd_usbmidi_output_drain(struct snd_rawmidi_substream *substream)
+{
+	struct usbmidi_out_port* port = substream->runtime->private_data;
+	struct snd_usb_midi_out_endpoint *ep = port->ep;
+	unsigned int drain_urbs;
+	DEFINE_WAIT(wait);
+	long timeout = msecs_to_jiffies(50);
+
+	/*
+	 * The substream buffer is empty, but some data might still be in the
+	 * currently active URBs, so we have to wait for those to complete.
+	 */
+	spin_lock_irq(&ep->buffer_lock);
+	drain_urbs = ep->active_urbs;
+	if (drain_urbs) {
+		ep->drain_urbs |= drain_urbs;
+		do {
+			prepare_to_wait(&ep->drain_wait, &wait,
+					TASK_UNINTERRUPTIBLE);
+			spin_unlock_irq(&ep->buffer_lock);
+			timeout = schedule_timeout(timeout);
+			spin_lock_irq(&ep->buffer_lock);
+			drain_urbs &= ep->drain_urbs;
+		} while (drain_urbs && timeout);
+		finish_wait(&ep->drain_wait, &wait);
+	}
+	spin_unlock_irq(&ep->buffer_lock);
+}
+
+static int snd_usbmidi_input_open(struct snd_rawmidi_substream *substream)
+{
+	substream_open(substream, 1);
+	return 0;
+}
+
+static int snd_usbmidi_input_close(struct snd_rawmidi_substream *substream)
+{
+	substream_open(substream, 0);
+	return 0;
+}
+
+static void snd_usbmidi_input_trigger(struct snd_rawmidi_substream *substream, int up)
+{
+	struct snd_usb_midi* umidi = substream->rmidi->private_data;
+
+	if (up)
+		set_bit(substream->number, &umidi->input_triggered);
+	else
+		clear_bit(substream->number, &umidi->input_triggered);
+}
+
+static struct snd_rawmidi_ops snd_usbmidi_output_ops = {
+	.open = snd_usbmidi_output_open,
+	.close = snd_usbmidi_output_close,
+	.trigger = snd_usbmidi_output_trigger,
+	.drain = snd_usbmidi_output_drain,
+};
+
+static struct snd_rawmidi_ops snd_usbmidi_input_ops = {
+	.open = snd_usbmidi_input_open,
+	.close = snd_usbmidi_input_close,
+	.trigger = snd_usbmidi_input_trigger
+};
+
+static void free_urb_and_buffer(struct snd_usb_midi *umidi, struct urb *urb,
+				unsigned int buffer_length)
+{
+	usb_buffer_free(umidi->dev, buffer_length,
+			urb->transfer_buffer, urb->transfer_dma);
+	usb_free_urb(urb);
+}
+
+/*
+ * Frees an input endpoint.
+ * May be called when ep hasn't been initialized completely.
+ */
+static void snd_usbmidi_in_endpoint_delete(struct snd_usb_midi_in_endpoint* ep)
+{
+	unsigned int i;
+
+	for (i = 0; i < INPUT_URBS; ++i)
+		if (ep->urbs[i])
+			free_urb_and_buffer(ep->umidi, ep->urbs[i],
+					    ep->urbs[i]->transfer_buffer_length);
+	kfree(ep);
+}
+
+/*
+ * Creates an input endpoint.
+ */
+static int snd_usbmidi_in_endpoint_create(struct snd_usb_midi* umidi,
+					  struct snd_usb_midi_endpoint_info* ep_info,
+					  struct snd_usb_midi_endpoint* rep)
+{
+	struct snd_usb_midi_in_endpoint* ep;
+	void* buffer;
+	unsigned int pipe;
+	int length;
+	unsigned int i;
+
+	rep->in = NULL;
+	ep = kzalloc(sizeof(*ep), GFP_KERNEL);
+	if (!ep)
+		return -ENOMEM;
+	ep->umidi = umidi;
+
+	for (i = 0; i < INPUT_URBS; ++i) {
+		ep->urbs[i] = usb_alloc_urb(0, GFP_KERNEL);
+		if (!ep->urbs[i]) {
+			snd_usbmidi_in_endpoint_delete(ep);
+			return -ENOMEM;
+		}
+	}
+	if (ep_info->in_interval)
+		pipe = usb_rcvintpipe(umidi->dev, ep_info->in_ep);
+	else
+		pipe = usb_rcvbulkpipe(umidi->dev, ep_info->in_ep);
+	length = usb_maxpacket(umidi->dev, pipe, 0);
+	for (i = 0; i < INPUT_URBS; ++i) {
+		buffer = usb_buffer_alloc(umidi->dev, length, GFP_KERNEL,
+					  &ep->urbs[i]->transfer_dma);
+		if (!buffer) {
+			snd_usbmidi_in_endpoint_delete(ep);
+			return -ENOMEM;
+		}
+		if (ep_info->in_interval)
+			usb_fill_int_urb(ep->urbs[i], umidi->dev,
+					 pipe, buffer, length,
+					 snd_usbmidi_in_urb_complete,
+					 ep, ep_info->in_interval);
+		else
+			usb_fill_bulk_urb(ep->urbs[i], umidi->dev,
+					  pipe, buffer, length,
+					  snd_usbmidi_in_urb_complete, ep);
+		ep->urbs[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
+	}
+
+	rep->in = ep;
+	return 0;
+}
+
+/*
+ * Frees an output endpoint.
+ * May be called when ep hasn't been initialized completely.
+ */
+static void snd_usbmidi_out_endpoint_delete(struct snd_usb_midi_out_endpoint* ep)
+{
+	unsigned int i;
+
+	for (i = 0; i < OUTPUT_URBS; ++i)
+		if (ep->urbs[i].urb)
+			free_urb_and_buffer(ep->umidi, ep->urbs[i].urb,
+					    ep->max_transfer);
+	kfree(ep);
+}
+
+/*
+ * Creates an output endpoint, and initializes output ports.
+ */
+static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi* umidi,
+					   struct snd_usb_midi_endpoint_info* ep_info,
+			 		   struct snd_usb_midi_endpoint* rep)
+{
+	struct snd_usb_midi_out_endpoint* ep;
+	unsigned int i;
+	unsigned int pipe;
+	void* buffer;
+
+	rep->out = NULL;
+	ep = kzalloc(sizeof(*ep), GFP_KERNEL);
+	if (!ep)
+		return -ENOMEM;
+	ep->umidi = umidi;
+
+	for (i = 0; i < OUTPUT_URBS; ++i) {
+		ep->urbs[i].urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!ep->urbs[i].urb) {
+			snd_usbmidi_out_endpoint_delete(ep);
+			return -ENOMEM;
+		}
+		ep->urbs[i].ep = ep;
+	}
+	if (ep_info->out_interval)
+		pipe = usb_sndintpipe(umidi->dev, ep_info->out_ep);
+	else
+		pipe = usb_sndbulkpipe(umidi->dev, ep_info->out_ep);
+	switch (umidi->usb_id) {
+	default:
+		ep->max_transfer = usb_maxpacket(umidi->dev, pipe, 1);
+		break;
+		/*
+		 * Various chips declare a packet size larger than 4 bytes, but
+		 * do not actually work with larger packets:
+		 */
+	case USB_ID(0x0a92, 0x1020): /* ESI M4U */
+	case USB_ID(0x1430, 0x474b): /* RedOctane GH MIDI INTERFACE */
+	case USB_ID(0x15ca, 0x0101): /* Textech USB Midi Cable */
+	case USB_ID(0x15ca, 0x1806): /* Textech USB Midi Cable */
+	case USB_ID(0x1a86, 0x752d): /* QinHeng CH345 "USB2.0-MIDI" */
+		ep->max_transfer = 4;
+		break;
+	}
+	for (i = 0; i < OUTPUT_URBS; ++i) {
+		buffer = usb_buffer_alloc(umidi->dev,
+					  ep->max_transfer, GFP_KERNEL,
+					  &ep->urbs[i].urb->transfer_dma);
+		if (!buffer) {
+			snd_usbmidi_out_endpoint_delete(ep);
+			return -ENOMEM;
+		}
+		if (ep_info->out_interval)
+			usb_fill_int_urb(ep->urbs[i].urb, umidi->dev,
+					 pipe, buffer, ep->max_transfer,
+					 snd_usbmidi_out_urb_complete,
+					 &ep->urbs[i], ep_info->out_interval);
+		else
+			usb_fill_bulk_urb(ep->urbs[i].urb, umidi->dev,
+					  pipe, buffer, ep->max_transfer,
+					  snd_usbmidi_out_urb_complete,
+					  &ep->urbs[i]);
+		ep->urbs[i].urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
+	}
+
+	spin_lock_init(&ep->buffer_lock);
+	tasklet_init(&ep->tasklet, snd_usbmidi_out_tasklet, (unsigned long)ep);
+	init_waitqueue_head(&ep->drain_wait);
+
+	for (i = 0; i < 0x10; ++i)
+		if (ep_info->out_cables & (1 << i)) {
+			ep->ports[i].ep = ep;
+			ep->ports[i].cable = i << 4;
+		}
+
+	if (umidi->usb_protocol_ops->init_out_endpoint)
+		umidi->usb_protocol_ops->init_out_endpoint(ep);
+
+	rep->out = ep;
+	return 0;
+}
+
+/*
+ * Frees everything.
+ */
+static void snd_usbmidi_free(struct snd_usb_midi* umidi)
+{
+	int i;
+
+	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
+		struct snd_usb_midi_endpoint* ep = &umidi->endpoints[i];
+		if (ep->out)
+			snd_usbmidi_out_endpoint_delete(ep->out);
+		if (ep->in)
+			snd_usbmidi_in_endpoint_delete(ep->in);
+	}
+	mutex_destroy(&umidi->mutex);
+	kfree(umidi);
+}
+
+/*
+ * Unlinks all URBs (must be done before the usb_device is deleted).
+ */
+void snd_usbmidi_disconnect(struct list_head* p)
+{
+	struct snd_usb_midi* umidi;
+	unsigned int i, j;
+
+	umidi = list_entry(p, struct snd_usb_midi, list);
+	/*
+	 * an URB's completion handler may start the timer and
+	 * a timer may submit an URB. To reliably break the cycle
+	 * a flag under lock must be used
+	 */
+	spin_lock_irq(&umidi->disc_lock);
+	umidi->disconnected = 1;
+	spin_unlock_irq(&umidi->disc_lock);
+	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
+		struct snd_usb_midi_endpoint* ep = &umidi->endpoints[i];
+		if (ep->out)
+			tasklet_kill(&ep->out->tasklet);
+		if (ep->out) {
+			for (j = 0; j < OUTPUT_URBS; ++j)
+				usb_kill_urb(ep->out->urbs[j].urb);
+			if (umidi->usb_protocol_ops->finish_out_endpoint)
+				umidi->usb_protocol_ops->finish_out_endpoint(ep->out);
+		}
+		if (ep->in)
+			for (j = 0; j < INPUT_URBS; ++j)
+				usb_kill_urb(ep->in->urbs[j]);
+		/* free endpoints here; later call can result in Oops */
+		if (ep->out) {
+			snd_usbmidi_out_endpoint_delete(ep->out);
+			ep->out = NULL;
+		}
+		if (ep->in) {
+			snd_usbmidi_in_endpoint_delete(ep->in);
+			ep->in = NULL;
+		}
+	}
+	del_timer_sync(&umidi->error_timer);
+}
+
+static void snd_usbmidi_rawmidi_free(struct snd_rawmidi *rmidi)
+{
+	struct snd_usb_midi* umidi = rmidi->private_data;
+	snd_usbmidi_free(umidi);
+}
+
+static struct snd_rawmidi_substream *snd_usbmidi_find_substream(struct snd_usb_midi* umidi,
+							   int stream, int number)
+{
+	struct list_head* list;
+
+	list_for_each(list, &umidi->rmidi->streams[stream].substreams) {
+		struct snd_rawmidi_substream *substream = list_entry(list, struct snd_rawmidi_substream, list);
+		if (substream->number == number)
+			return substream;
+	}
+	return NULL;
+}
+
+/*
+ * This list specifies names for ports that do not fit into the standard
+ * "(product) MIDI (n)" schema because they aren't external MIDI ports,
+ * such as internal control or synthesizer ports.
+ */
+static struct port_info {
+	u32 id;
+	short int port;
+	short int voices;
+	const char *name;
+	unsigned int seq_flags;
+} snd_usbmidi_port_info[] = {
+#define PORT_INFO(vendor, product, num, name_, voices_, flags) \
+	{ .id = USB_ID(vendor, product), \
+	  .port = num, .voices = voices_, \
+	  .name = name_, .seq_flags = flags }
+#define EXTERNAL_PORT(vendor, product, num, name) \
+	PORT_INFO(vendor, product, num, name, 0, \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \
+		  SNDRV_SEQ_PORT_TYPE_HARDWARE | \
+		  SNDRV_SEQ_PORT_TYPE_PORT)
+#define CONTROL_PORT(vendor, product, num, name) \
+	PORT_INFO(vendor, product, num, name, 0, \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \
+		  SNDRV_SEQ_PORT_TYPE_HARDWARE)
+#define ROLAND_SYNTH_PORT(vendor, product, num, name, voices) \
+	PORT_INFO(vendor, product, num, name, voices, \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_GM | \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_GM2 | \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_GS | \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_XG | \
+		  SNDRV_SEQ_PORT_TYPE_HARDWARE | \
+		  SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)
+#define SOUNDCANVAS_PORT(vendor, product, num, name, voices) \
+	PORT_INFO(vendor, product, num, name, voices, \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC | \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_GM | \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_GM2 | \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_GS | \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_XG | \
+		  SNDRV_SEQ_PORT_TYPE_MIDI_MT32 | \
+		  SNDRV_SEQ_PORT_TYPE_HARDWARE | \
+		  SNDRV_SEQ_PORT_TYPE_SYNTHESIZER)
+	/* Roland UA-100 */
+	CONTROL_PORT(0x0582, 0x0000, 2, "%s Control"),
+	/* Roland SC-8850 */
+	SOUNDCANVAS_PORT(0x0582, 0x0003, 0, "%s Part A", 128),
+	SOUNDCANVAS_PORT(0x0582, 0x0003, 1, "%s Part B", 128),
+	SOUNDCANVAS_PORT(0x0582, 0x0003, 2, "%s Part C", 128),
+	SOUNDCANVAS_PORT(0x0582, 0x0003, 3, "%s Part D", 128),
+	EXTERNAL_PORT(0x0582, 0x0003, 4, "%s MIDI 1"),
+	EXTERNAL_PORT(0x0582, 0x0003, 5, "%s MIDI 2"),
+	/* Roland U-8 */
+	EXTERNAL_PORT(0x0582, 0x0004, 0, "%s MIDI"),
+	CONTROL_PORT(0x0582, 0x0004, 1, "%s Control"),
+	/* Roland SC-8820 */
+	SOUNDCANVAS_PORT(0x0582, 0x0007, 0, "%s Part A", 64),
+	SOUNDCANVAS_PORT(0x0582, 0x0007, 1, "%s Part B", 64),
+	EXTERNAL_PORT(0x0582, 0x0007, 2, "%s MIDI"),
+	/* Roland SK-500 */
+	SOUNDCANVAS_PORT(0x0582, 0x000b, 0, "%s Part A", 64),
+	SOUNDCANVAS_PORT(0x0582, 0x000b, 1, "%s Part B", 64),
+	EXTERNAL_PORT(0x0582, 0x000b, 2, "%s MIDI"),
+	/* Roland SC-D70 */
+	SOUNDCANVAS_PORT(0x0582, 0x000c, 0, "%s Part A", 64),
+	SOUNDCANVAS_PORT(0x0582, 0x000c, 1, "%s Part B", 64),
+	EXTERNAL_PORT(0x0582, 0x000c, 2, "%s MIDI"),
+	/* Edirol UM-880 */
+	CONTROL_PORT(0x0582, 0x0014, 8, "%s Control"),
+	/* Edirol SD-90 */
+	ROLAND_SYNTH_PORT(0x0582, 0x0016, 0, "%s Part A", 128),
+	ROLAND_SYNTH_PORT(0x0582, 0x0016, 1, "%s Part B", 128),
+	EXTERNAL_PORT(0x0582, 0x0016, 2, "%s MIDI 1"),
+	EXTERNAL_PORT(0x0582, 0x0016, 3, "%s MIDI 2"),
+	/* Edirol UM-550 */
+	CONTROL_PORT(0x0582, 0x0023, 5, "%s Control"),
+	/* Edirol SD-20 */
+	ROLAND_SYNTH_PORT(0x0582, 0x0027, 0, "%s Part A", 64),
+	ROLAND_SYNTH_PORT(0x0582, 0x0027, 1, "%s Part B", 64),
+	EXTERNAL_PORT(0x0582, 0x0027, 2, "%s MIDI"),
+	/* Edirol SD-80 */
+	ROLAND_SYNTH_PORT(0x0582, 0x0029, 0, "%s Part A", 128),
+	ROLAND_SYNTH_PORT(0x0582, 0x0029, 1, "%s Part B", 128),
+	EXTERNAL_PORT(0x0582, 0x0029, 2, "%s MIDI 1"),
+	EXTERNAL_PORT(0x0582, 0x0029, 3, "%s MIDI 2"),
+	/* Edirol UA-700 */
+	EXTERNAL_PORT(0x0582, 0x002b, 0, "%s MIDI"),
+	CONTROL_PORT(0x0582, 0x002b, 1, "%s Control"),
+	/* Roland VariOS */
+	EXTERNAL_PORT(0x0582, 0x002f, 0, "%s MIDI"),
+	EXTERNAL_PORT(0x0582, 0x002f, 1, "%s External MIDI"),
+	EXTERNAL_PORT(0x0582, 0x002f, 2, "%s Sync"),
+	/* Edirol PCR */
+	EXTERNAL_PORT(0x0582, 0x0033, 0, "%s MIDI"),
+	EXTERNAL_PORT(0x0582, 0x0033, 1, "%s 1"),
+	EXTERNAL_PORT(0x0582, 0x0033, 2, "%s 2"),
+	/* BOSS GS-10 */
+	EXTERNAL_PORT(0x0582, 0x003b, 0, "%s MIDI"),
+	CONTROL_PORT(0x0582, 0x003b, 1, "%s Control"),
+	/* Edirol UA-1000 */
+	EXTERNAL_PORT(0x0582, 0x0044, 0, "%s MIDI"),
+	CONTROL_PORT(0x0582, 0x0044, 1, "%s Control"),
+	/* Edirol UR-80 */
+	EXTERNAL_PORT(0x0582, 0x0048, 0, "%s MIDI"),
+	EXTERNAL_PORT(0x0582, 0x0048, 1, "%s 1"),
+	EXTERNAL_PORT(0x0582, 0x0048, 2, "%s 2"),
+	/* Edirol PCR-A */
+	EXTERNAL_PORT(0x0582, 0x004d, 0, "%s MIDI"),
+	EXTERNAL_PORT(0x0582, 0x004d, 1, "%s 1"),
+	EXTERNAL_PORT(0x0582, 0x004d, 2, "%s 2"),
+	/* Edirol UM-3EX */
+	CONTROL_PORT(0x0582, 0x009a, 3, "%s Control"),
+	/* M-Audio MidiSport 8x8 */
+	CONTROL_PORT(0x0763, 0x1031, 8, "%s Control"),
+	CONTROL_PORT(0x0763, 0x1033, 8, "%s Control"),
+	/* MOTU Fastlane */
+	EXTERNAL_PORT(0x07fd, 0x0001, 0, "%s MIDI A"),
+	EXTERNAL_PORT(0x07fd, 0x0001, 1, "%s MIDI B"),
+	/* Emagic Unitor8/AMT8/MT4 */
+	EXTERNAL_PORT(0x086a, 0x0001, 8, "%s Broadcast"),
+	EXTERNAL_PORT(0x086a, 0x0002, 8, "%s Broadcast"),
+	EXTERNAL_PORT(0x086a, 0x0003, 4, "%s Broadcast"),
+	/* Access Music Virus TI */
+	EXTERNAL_PORT(0x133e, 0x0815, 0, "%s MIDI"),
+	PORT_INFO(0x133e, 0x0815, 1, "%s Synth", 0,
+		SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |
+		SNDRV_SEQ_PORT_TYPE_HARDWARE |
+		SNDRV_SEQ_PORT_TYPE_SYNTHESIZER),
+};
+
+static struct port_info *find_port_info(struct snd_usb_midi* umidi, int number)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(snd_usbmidi_port_info); ++i) {
+		if (snd_usbmidi_port_info[i].id == umidi->usb_id &&
+		    snd_usbmidi_port_info[i].port == number)
+			return &snd_usbmidi_port_info[i];
+	}
+	return NULL;
+}
+
+static void snd_usbmidi_get_port_info(struct snd_rawmidi *rmidi, int number,
+				      struct snd_seq_port_info *seq_port_info)
+{
+	struct snd_usb_midi *umidi = rmidi->private_data;
+	struct port_info *port_info;
+
+	/* TODO: read port flags from descriptors */
+	port_info = find_port_info(umidi, number);
+	if (port_info) {
+		seq_port_info->type = port_info->seq_flags;
+		seq_port_info->midi_voices = port_info->voices;
+	}
+}
+
+static void snd_usbmidi_init_substream(struct snd_usb_midi* umidi,
+				       int stream, int number,
+				       struct snd_rawmidi_substream ** rsubstream)
+{
+	struct port_info *port_info;
+	const char *name_format;
+
+	struct snd_rawmidi_substream *substream = snd_usbmidi_find_substream(umidi, stream, number);
+	if (!substream) {
+		snd_printd(KERN_ERR "substream %d:%d not found\n", stream, number);
+		return;
+	}
+
+	/* TODO: read port name from jack descriptor */
+	port_info = find_port_info(umidi, number);
+	name_format = port_info ? port_info->name : "%s MIDI %d";
+	snprintf(substream->name, sizeof(substream->name),
+		 name_format, umidi->card->shortname, number + 1);
+
+	*rsubstream = substream;
+}
+
+/*
+ * Creates the endpoints and their ports.
+ */
+static int snd_usbmidi_create_endpoints(struct snd_usb_midi* umidi,
+					struct snd_usb_midi_endpoint_info* endpoints)
+{
+	int i, j, err;
+	int out_ports = 0, in_ports = 0;
+
+	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
+		if (endpoints[i].out_cables) {
+			err = snd_usbmidi_out_endpoint_create(umidi, &endpoints[i],
+							      &umidi->endpoints[i]);
+			if (err < 0)
+				return err;
+		}
+		if (endpoints[i].in_cables) {
+			err = snd_usbmidi_in_endpoint_create(umidi, &endpoints[i],
+							     &umidi->endpoints[i]);
+			if (err < 0)
+				return err;
+		}
+
+		for (j = 0; j < 0x10; ++j) {
+			if (endpoints[i].out_cables & (1 << j)) {
+				snd_usbmidi_init_substream(umidi, SNDRV_RAWMIDI_STREAM_OUTPUT, out_ports,
+							   &umidi->endpoints[i].out->ports[j].substream);
+				++out_ports;
+			}
+			if (endpoints[i].in_cables & (1 << j)) {
+				snd_usbmidi_init_substream(umidi, SNDRV_RAWMIDI_STREAM_INPUT, in_ports,
+							   &umidi->endpoints[i].in->ports[j].substream);
+				++in_ports;
+			}
+		}
+	}
+	snd_printdd(KERN_INFO "created %d output and %d input ports\n",
+		    out_ports, in_ports);
+	return 0;
+}
+
+/*
+ * Returns MIDIStreaming device capabilities.
+ */
+static int snd_usbmidi_get_ms_info(struct snd_usb_midi* umidi,
+			   	   struct snd_usb_midi_endpoint_info* endpoints)
+{
+	struct usb_interface* intf;
+	struct usb_host_interface *hostif;
+	struct usb_interface_descriptor* intfd;
+	struct usb_ms_header_descriptor* ms_header;
+	struct usb_host_endpoint *hostep;
+	struct usb_endpoint_descriptor* ep;
+	struct usb_ms_endpoint_descriptor* ms_ep;
+	int i, epidx;
+
+	intf = umidi->iface;
+	if (!intf)
+		return -ENXIO;
+	hostif = &intf->altsetting[0];
+	intfd = get_iface_desc(hostif);
+	ms_header = (struct usb_ms_header_descriptor*)hostif->extra;
+	if (hostif->extralen >= 7 &&
+	    ms_header->bLength >= 7 &&
+	    ms_header->bDescriptorType == USB_DT_CS_INTERFACE &&
+	    ms_header->bDescriptorSubtype == UAC_HEADER)
+		snd_printdd(KERN_INFO "MIDIStreaming version %02x.%02x\n",
+			    ms_header->bcdMSC[1], ms_header->bcdMSC[0]);
+	else
+		snd_printk(KERN_WARNING "MIDIStreaming interface descriptor not found\n");
+
+	epidx = 0;
+	for (i = 0; i < intfd->bNumEndpoints; ++i) {
+		hostep = &hostif->endpoint[i];
+		ep = get_ep_desc(hostep);
+		if (!usb_endpoint_xfer_bulk(ep) && !usb_endpoint_xfer_int(ep))
+			continue;
+		ms_ep = (struct usb_ms_endpoint_descriptor*)hostep->extra;
+		if (hostep->extralen < 4 ||
+		    ms_ep->bLength < 4 ||
+		    ms_ep->bDescriptorType != USB_DT_CS_ENDPOINT ||
+		    ms_ep->bDescriptorSubtype != UAC_MS_GENERAL)
+			continue;
+		if (usb_endpoint_dir_out(ep)) {
+			if (endpoints[epidx].out_ep) {
+				if (++epidx >= MIDI_MAX_ENDPOINTS) {
+					snd_printk(KERN_WARNING "too many endpoints\n");
+					break;
+				}
+			}
+			endpoints[epidx].out_ep = usb_endpoint_num(ep);
+			if (usb_endpoint_xfer_int(ep))
+				endpoints[epidx].out_interval = ep->bInterval;
+			else if (snd_usb_get_speed(umidi->dev) == USB_SPEED_LOW)
+				/*
+				 * Low speed bulk transfers don't exist, so
+				 * force interrupt transfers for devices like
+				 * ESI MIDI Mate that try to use them anyway.
+				 */
+				endpoints[epidx].out_interval = 1;
+			endpoints[epidx].out_cables = (1 << ms_ep->bNumEmbMIDIJack) - 1;
+			snd_printdd(KERN_INFO "EP %02X: %d jack(s)\n",
+				    ep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);
+		} else {
+			if (endpoints[epidx].in_ep) {
+				if (++epidx >= MIDI_MAX_ENDPOINTS) {
+					snd_printk(KERN_WARNING "too many endpoints\n");
+					break;
+				}
+			}
+			endpoints[epidx].in_ep = usb_endpoint_num(ep);
+			if (usb_endpoint_xfer_int(ep))
+				endpoints[epidx].in_interval = ep->bInterval;
+			else if (snd_usb_get_speed(umidi->dev) == USB_SPEED_LOW)
+				endpoints[epidx].in_interval = 1;
+			endpoints[epidx].in_cables = (1 << ms_ep->bNumEmbMIDIJack) - 1;
+			snd_printdd(KERN_INFO "EP %02X: %d jack(s)\n",
+				    ep->bEndpointAddress, ms_ep->bNumEmbMIDIJack);
+		}
+	}
+	return 0;
+}
+
+static int roland_load_info(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_info *info)
+{
+	static const char *const names[] = { "High Load", "Light Load" };
+
+	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	info->count = 1;
+	info->value.enumerated.items = 2;
+	if (info->value.enumerated.item > 1)
+		info->value.enumerated.item = 1;
+	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
+	return 0;
+}
+
+static int roland_load_get(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *value)
+{
+	value->value.enumerated.item[0] = kcontrol->private_value;
+	return 0;
+}
+
+static int roland_load_put(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *value)
+{
+	struct snd_usb_midi* umidi = kcontrol->private_data;
+	int changed;
+
+	if (value->value.enumerated.item[0] > 1)
+		return -EINVAL;
+	mutex_lock(&umidi->mutex);
+	changed = value->value.enumerated.item[0] != kcontrol->private_value;
+	if (changed)
+		kcontrol->private_value = value->value.enumerated.item[0];
+	mutex_unlock(&umidi->mutex);
+	return changed;
+}
+
+static struct snd_kcontrol_new roland_load_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "MIDI Input Mode",
+	.info = roland_load_info,
+	.get = roland_load_get,
+	.put = roland_load_put,
+	.private_value = 1,
+};
+
+/*
+ * On Roland devices, use the second alternate setting to be able to use
+ * the interrupt input endpoint.
+ */
+static void snd_usbmidi_switch_roland_altsetting(struct snd_usb_midi* umidi)
+{
+	struct usb_interface* intf;
+	struct usb_host_interface *hostif;
+	struct usb_interface_descriptor* intfd;
+
+	intf = umidi->iface;
+	if (!intf || intf->num_altsetting != 2)
+		return;
+
+	hostif = &intf->altsetting[1];
+	intfd = get_iface_desc(hostif);
+	if (intfd->bNumEndpoints != 2 ||
+	    (get_endpoint(hostif, 0)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_BULK ||
+	    (get_endpoint(hostif, 1)->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_INT)
+		return;
+
+	snd_printdd(KERN_INFO "switching to altsetting %d with int ep\n",
+		    intfd->bAlternateSetting);
+	usb_set_interface(umidi->dev, intfd->bInterfaceNumber,
+			  intfd->bAlternateSetting);
+
+	umidi->roland_load_ctl = snd_ctl_new1(&roland_load_ctl, umidi);
+	if (snd_ctl_add(umidi->card, umidi->roland_load_ctl) < 0)
+		umidi->roland_load_ctl = NULL;
+}
+
+/*
+ * Try to find any usable endpoints in the interface.
+ */
+static int snd_usbmidi_detect_endpoints(struct snd_usb_midi* umidi,
+					struct snd_usb_midi_endpoint_info* endpoint,
+					int max_endpoints)
+{
+	struct usb_interface* intf;
+	struct usb_host_interface *hostif;
+	struct usb_interface_descriptor* intfd;
+	struct usb_endpoint_descriptor* epd;
+	int i, out_eps = 0, in_eps = 0;
+
+	if (USB_ID_VENDOR(umidi->usb_id) == 0x0582)
+		snd_usbmidi_switch_roland_altsetting(umidi);
+
+	if (endpoint[0].out_ep || endpoint[0].in_ep)
+		return 0;	
+
+	intf = umidi->iface;
+	if (!intf || intf->num_altsetting < 1)
+		return -ENOENT;
+	hostif = intf->cur_altsetting;
+	intfd = get_iface_desc(hostif);
+
+	for (i = 0; i < intfd->bNumEndpoints; ++i) {
+		epd = get_endpoint(hostif, i);
+		if (!usb_endpoint_xfer_bulk(epd) &&
+		    !usb_endpoint_xfer_int(epd))
+			continue;
+		if (out_eps < max_endpoints &&
+		    usb_endpoint_dir_out(epd)) {
+			endpoint[out_eps].out_ep = usb_endpoint_num(epd);
+			if (usb_endpoint_xfer_int(epd))
+				endpoint[out_eps].out_interval = epd->bInterval;
+			++out_eps;
+		}
+		if (in_eps < max_endpoints &&
+		    usb_endpoint_dir_in(epd)) {
+			endpoint[in_eps].in_ep = usb_endpoint_num(epd);
+			if (usb_endpoint_xfer_int(epd))
+				endpoint[in_eps].in_interval = epd->bInterval;
+			++in_eps;
+		}
+	}
+	return (out_eps || in_eps) ? 0 : -ENOENT;
+}
+
+/*
+ * Detects the endpoints for one-port-per-endpoint protocols.
+ */
+static int snd_usbmidi_detect_per_port_endpoints(struct snd_usb_midi* umidi,
+						 struct snd_usb_midi_endpoint_info* endpoints)
+{
+	int err, i;
+	
+	err = snd_usbmidi_detect_endpoints(umidi, endpoints, MIDI_MAX_ENDPOINTS);
+	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
+		if (endpoints[i].out_ep)
+			endpoints[i].out_cables = 0x0001;
+		if (endpoints[i].in_ep)
+			endpoints[i].in_cables = 0x0001;
+	}
+	return err;
+}
+
+/*
+ * Detects the endpoints and ports of Yamaha devices.
+ */
+static int snd_usbmidi_detect_yamaha(struct snd_usb_midi* umidi,
+				     struct snd_usb_midi_endpoint_info* endpoint)
+{
+	struct usb_interface* intf;
+	struct usb_host_interface *hostif;
+	struct usb_interface_descriptor* intfd;
+	uint8_t* cs_desc;
+
+	intf = umidi->iface;
+	if (!intf)
+		return -ENOENT;
+	hostif = intf->altsetting;
+	intfd = get_iface_desc(hostif);
+	if (intfd->bNumEndpoints < 1)
+		return -ENOENT;
+
+	/*
+	 * For each port there is one MIDI_IN/OUT_JACK descriptor, not
+	 * necessarily with any useful contents.  So simply count 'em.
+	 */
+	for (cs_desc = hostif->extra;
+	     cs_desc < hostif->extra + hostif->extralen && cs_desc[0] >= 2;
+	     cs_desc += cs_desc[0]) {
+		if (cs_desc[1] == USB_DT_CS_INTERFACE) {
+			if (cs_desc[2] == UAC_MIDI_IN_JACK)
+				endpoint->in_cables = (endpoint->in_cables << 1) | 1;
+			else if (cs_desc[2] == UAC_MIDI_OUT_JACK)
+				endpoint->out_cables = (endpoint->out_cables << 1) | 1;
+		}
+	}
+	if (!endpoint->in_cables && !endpoint->out_cables)
+		return -ENOENT;
+
+	return snd_usbmidi_detect_endpoints(umidi, endpoint, 1);
+}
+
+/*
+ * Creates the endpoints and their ports for Midiman devices.
+ */
+static int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi* umidi,
+						struct snd_usb_midi_endpoint_info* endpoint)
+{
+	struct snd_usb_midi_endpoint_info ep_info;
+	struct usb_interface* intf;
+	struct usb_host_interface *hostif;
+	struct usb_interface_descriptor* intfd;
+	struct usb_endpoint_descriptor* epd;
+	int cable, err;
+
+	intf = umidi->iface;
+	if (!intf)
+		return -ENOENT;
+	hostif = intf->altsetting;
+	intfd = get_iface_desc(hostif);
+	/*
+	 * The various MidiSport devices have more or less random endpoint
+	 * numbers, so we have to identify the endpoints by their index in
+	 * the descriptor array, like the driver for that other OS does.
+	 *
+	 * There is one interrupt input endpoint for all input ports, one
+	 * bulk output endpoint for even-numbered ports, and one for odd-
+	 * numbered ports.  Both bulk output endpoints have corresponding
+	 * input bulk endpoints (at indices 1 and 3) which aren't used.
+	 */
+	if (intfd->bNumEndpoints < (endpoint->out_cables > 0x0001 ? 5 : 3)) {
+		snd_printdd(KERN_ERR "not enough endpoints\n");
+		return -ENOENT;
+	}
+
+	epd = get_endpoint(hostif, 0);
+	if (!usb_endpoint_dir_in(epd) || !usb_endpoint_xfer_int(epd)) {
+		snd_printdd(KERN_ERR "endpoint[0] isn't interrupt\n");
+		return -ENXIO;
+	}
+	epd = get_endpoint(hostif, 2);
+	if (!usb_endpoint_dir_out(epd) || !usb_endpoint_xfer_bulk(epd)) {
+		snd_printdd(KERN_ERR "endpoint[2] isn't bulk output\n");
+		return -ENXIO;
+	}
+	if (endpoint->out_cables > 0x0001) {
+		epd = get_endpoint(hostif, 4);
+		if (!usb_endpoint_dir_out(epd) ||
+		    !usb_endpoint_xfer_bulk(epd)) {
+			snd_printdd(KERN_ERR "endpoint[4] isn't bulk output\n");
+			return -ENXIO;
+		}
+	}
+
+	ep_info.out_ep = get_endpoint(hostif, 2)->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+	ep_info.out_interval = 0;
+	ep_info.out_cables = endpoint->out_cables & 0x5555;
+	err = snd_usbmidi_out_endpoint_create(umidi, &ep_info, &umidi->endpoints[0]);
+	if (err < 0)
+		return err;
+
+	ep_info.in_ep = get_endpoint(hostif, 0)->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+	ep_info.in_interval = get_endpoint(hostif, 0)->bInterval;
+	ep_info.in_cables = endpoint->in_cables;
+	err = snd_usbmidi_in_endpoint_create(umidi, &ep_info, &umidi->endpoints[0]);
+	if (err < 0)
+		return err;
+
+	if (endpoint->out_cables > 0x0001) {
+		ep_info.out_ep = get_endpoint(hostif, 4)->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+		ep_info.out_cables = endpoint->out_cables & 0xaaaa;
+		err = snd_usbmidi_out_endpoint_create(umidi, &ep_info, &umidi->endpoints[1]);
+		if (err < 0)
+			return err;
+	}
+
+	for (cable = 0; cable < 0x10; ++cable) {
+		if (endpoint->out_cables & (1 << cable))
+			snd_usbmidi_init_substream(umidi, SNDRV_RAWMIDI_STREAM_OUTPUT, cable,
+						   &umidi->endpoints[cable & 1].out->ports[cable].substream);
+		if (endpoint->in_cables & (1 << cable))
+			snd_usbmidi_init_substream(umidi, SNDRV_RAWMIDI_STREAM_INPUT, cable,
+						   &umidi->endpoints[0].in->ports[cable].substream);
+	}
+	return 0;
+}
+
+static struct snd_rawmidi_global_ops snd_usbmidi_ops = {
+	.get_port_info = snd_usbmidi_get_port_info,
+};
+
+static int snd_usbmidi_create_rawmidi(struct snd_usb_midi* umidi,
+				      int out_ports, int in_ports)
+{
+	struct snd_rawmidi *rmidi;
+	int err;
+
+	err = snd_rawmidi_new(umidi->card, "USB MIDI",
+			      umidi->next_midi_device++,
+			      out_ports, in_ports, &rmidi);
+	if (err < 0)
+		return err;
+	strcpy(rmidi->name, umidi->card->shortname);
+	rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
+			    SNDRV_RAWMIDI_INFO_INPUT |
+			    SNDRV_RAWMIDI_INFO_DUPLEX;
+	rmidi->ops = &snd_usbmidi_ops;
+	rmidi->private_data = umidi;
+	rmidi->private_free = snd_usbmidi_rawmidi_free;
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_usbmidi_output_ops);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_usbmidi_input_ops);
+
+	umidi->rmidi = rmidi;
+	return 0;
+}
+
+/*
+ * Temporarily stop input.
+ */
+void snd_usbmidi_input_stop(struct list_head* p)
+{
+	struct snd_usb_midi* umidi;
+	unsigned int i, j;
+
+	umidi = list_entry(p, struct snd_usb_midi, list);
+	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
+		struct snd_usb_midi_endpoint* ep = &umidi->endpoints[i];
+		if (ep->in)
+			for (j = 0; j < INPUT_URBS; ++j)
+				usb_kill_urb(ep->in->urbs[j]);
+	}
+}
+
+static void snd_usbmidi_input_start_ep(struct snd_usb_midi_in_endpoint* ep)
+{
+	unsigned int i;
+
+	if (!ep)
+		return;
+	for (i = 0; i < INPUT_URBS; ++i) {
+		struct urb* urb = ep->urbs[i];
+		urb->dev = ep->umidi->dev;
+		snd_usbmidi_submit_urb(urb, GFP_KERNEL);
+	}
+}
+
+/*
+ * Resume input after a call to snd_usbmidi_input_stop().
+ */
+void snd_usbmidi_input_start(struct list_head* p)
+{
+	struct snd_usb_midi* umidi;
+	int i;
+
+	umidi = list_entry(p, struct snd_usb_midi, list);
+	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)
+		snd_usbmidi_input_start_ep(umidi->endpoints[i].in);
+}
+
+/*
+ * Creates and registers everything needed for a MIDI streaming interface.
+ */
+int snd_usbmidi_create(struct snd_card *card,
+		       struct usb_interface* iface,
+		       struct list_head *midi_list,
+		       const struct snd_usb_audio_quirk* quirk)
+{
+	struct snd_usb_midi* umidi;
+	struct snd_usb_midi_endpoint_info endpoints[MIDI_MAX_ENDPOINTS];
+	int out_ports, in_ports;
+	int i, err;
+
+	umidi = kzalloc(sizeof(*umidi), GFP_KERNEL);
+	if (!umidi)
+		return -ENOMEM;
+	umidi->dev = interface_to_usbdev(iface);
+	umidi->card = card;
+	umidi->iface = iface;
+	umidi->quirk = quirk;
+	umidi->usb_protocol_ops = &snd_usbmidi_standard_ops;
+	init_timer(&umidi->error_timer);
+	spin_lock_init(&umidi->disc_lock);
+	mutex_init(&umidi->mutex);
+	umidi->usb_id = USB_ID(le16_to_cpu(umidi->dev->descriptor.idVendor),
+			       le16_to_cpu(umidi->dev->descriptor.idProduct));
+	umidi->error_timer.function = snd_usbmidi_error_timer;
+	umidi->error_timer.data = (unsigned long)umidi;
+
+	/* detect the endpoint(s) to use */
+	memset(endpoints, 0, sizeof(endpoints));
+	switch (quirk ? quirk->type : QUIRK_MIDI_STANDARD_INTERFACE) {
+	case QUIRK_MIDI_STANDARD_INTERFACE:
+		err = snd_usbmidi_get_ms_info(umidi, endpoints);
+		if (umidi->usb_id == USB_ID(0x0763, 0x0150)) /* M-Audio Uno */
+			umidi->usb_protocol_ops =
+				&snd_usbmidi_maudio_broken_running_status_ops;
+		break;
+	case QUIRK_MIDI_US122L:
+		umidi->usb_protocol_ops = &snd_usbmidi_122l_ops;
+		/* fall through */
+	case QUIRK_MIDI_FIXED_ENDPOINT:
+		memcpy(&endpoints[0], quirk->data,
+		       sizeof(struct snd_usb_midi_endpoint_info));
+		err = snd_usbmidi_detect_endpoints(umidi, &endpoints[0], 1);
+		break;
+	case QUIRK_MIDI_YAMAHA:
+		err = snd_usbmidi_detect_yamaha(umidi, &endpoints[0]);
+		break;
+	case QUIRK_MIDI_MIDIMAN:
+		umidi->usb_protocol_ops = &snd_usbmidi_midiman_ops;
+		memcpy(&endpoints[0], quirk->data,
+		       sizeof(struct snd_usb_midi_endpoint_info));
+		err = 0;
+		break;
+	case QUIRK_MIDI_NOVATION:
+		umidi->usb_protocol_ops = &snd_usbmidi_novation_ops;
+		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
+		break;
+	case QUIRK_MIDI_FASTLANE:
+		umidi->usb_protocol_ops = &snd_usbmidi_raw_ops;
+		/*
+		 * Interface 1 contains isochronous endpoints, but with the same
+		 * numbers as in interface 0.  Since it is interface 1 that the
+		 * USB core has most recently seen, these descriptors are now
+		 * associated with the endpoint numbers.  This will foul up our
+		 * attempts to submit bulk/interrupt URBs to the endpoints in
+		 * interface 0, so we have to make sure that the USB core looks
+		 * again at interface 0 by calling usb_set_interface() on it.
+		 */
+		usb_set_interface(umidi->dev, 0, 0);
+		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
+		break;
+	case QUIRK_MIDI_EMAGIC:
+		umidi->usb_protocol_ops = &snd_usbmidi_emagic_ops;
+		memcpy(&endpoints[0], quirk->data,
+		       sizeof(struct snd_usb_midi_endpoint_info));
+		err = snd_usbmidi_detect_endpoints(umidi, &endpoints[0], 1);
+		break;
+	case QUIRK_MIDI_CME:
+		umidi->usb_protocol_ops = &snd_usbmidi_cme_ops;
+		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
+		break;
+	default:
+		snd_printd(KERN_ERR "invalid quirk type %d\n", quirk->type);
+		err = -ENXIO;
+		break;
+	}
+	if (err < 0) {
+		kfree(umidi);
+		return err;
+	}
+
+	/* create rawmidi device */
+	out_ports = 0;
+	in_ports = 0;
+	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) {
+		out_ports += hweight16(endpoints[i].out_cables);
+		in_ports += hweight16(endpoints[i].in_cables);
+	}
+	err = snd_usbmidi_create_rawmidi(umidi, out_ports, in_ports);
+	if (err < 0) {
+		kfree(umidi);
+		return err;
+	}
+
+	/* create endpoint/port structures */
+	if (quirk && quirk->type == QUIRK_MIDI_MIDIMAN)
+		err = snd_usbmidi_create_endpoints_midiman(umidi, &endpoints[0]);
+	else
+		err = snd_usbmidi_create_endpoints(umidi, endpoints);
+	if (err < 0) {
+		snd_usbmidi_free(umidi);
+		return err;
+	}
+
+	list_add_tail(&umidi->list, midi_list);
+
+	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)
+		snd_usbmidi_input_start_ep(umidi->endpoints[i].in);
+	return 0;
+}
+
+EXPORT_SYMBOL(snd_usbmidi_create);
+EXPORT_SYMBOL(snd_usbmidi_input_stop);
+EXPORT_SYMBOL(snd_usbmidi_input_start);
+EXPORT_SYMBOL(snd_usbmidi_disconnect);
