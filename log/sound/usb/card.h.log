commit b9fd2007c97413154e16bda01a6d5d5fc0c3bd44
Author: Alexander Tsoy <alexander@tsoy.me>
Date:   Mon Jun 29 05:59:34 2020 +0300

    ALSA: usb-audio: Replace s/frame/packet/ where appropriate
    
    Replace several occurences of "frame" with a "packet" where appropriate.
    
    Signed-off-by: Alexander Tsoy <alexander@tsoy.me>
    Link: https://lore.kernel.org/r/20200629025934.154288-2-alexander@tsoy.me
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index d6219fba9699..de43267b9c8a 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -84,10 +84,10 @@ struct snd_usb_endpoint {
 	dma_addr_t sync_dma;		/* DMA address of syncbuf */
 
 	unsigned int pipe;		/* the data i/o pipe */
-	unsigned int framesize[2];	/* small/large frame sizes in samples */
-	unsigned int sample_rem;	/* remainder from division fs/fps */
+	unsigned int packsize[2];	/* small/large packet sizes in samples */
+	unsigned int sample_rem;	/* remainder from division fs/pps */
 	unsigned int sample_accum;	/* sample accumulator */
-	unsigned int fps;		/* frames per second */
+	unsigned int pps;		/* packets per second */
 	unsigned int freqn;		/* nominal sampling rate in fs/fps in Q16.16 format */
 	unsigned int freqm;		/* momentary sampling rate in fs/fps in Q16.16 format */
 	int	   freqshift;		/* how much to shift the feedback value to get Q16.16 */

commit 10ce77e4817fef99e1166be7e6685a80c63bf77f
Author: Erwin Burema <e.burema@gmail.com>
Date:   Sun May 10 20:29:11 2020 +0200

    ALSA: usb-audio: Add duplex sound support for USB devices using implicit feedback
    
    For USB sound devices using implicit feedback the endpoint used for
    this feedback should be able to be opened twice, once for required
    feedback and second time for audio data. This way these devices can be
    put in duplex audio mode. Since this only works if the settings of the
    endpoint don't change a check is included for this.
    
    This fixes bug 207023 ("MOTU M2 regression on duplex audio") and
    should also fix bug 103751 ("M-Audio Fast Track Ultra usb audio device
    will not operate full-duplex")
    
    Fixes: c249177944b6 ("ALSA: usb-audio: add implicit fb quirk for MOTU M Series")
    Signed-off-by: Erwin Burema <e.burema@gmail.com>
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=207023
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=103751
    Link: https://lore.kernel.org/r/2410739.SCZni40SNb@alpha-wolf
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 820e564656ed..d6219fba9699 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -108,6 +108,7 @@ struct snd_usb_endpoint {
 	int iface, altsetting;
 	int skip_packets;		/* quirks for devices to ignore the first n packets
 					   in a stream */
+	bool is_implicit_feedback;      /* This endpoint is used as implicit feedback */
 
 	spinlock_t lock;
 	struct list_head list;

commit f0bd62b64016508938df9babe47f65c2c727d25c
Author: Alexander Tsoy <alexander@tsoy.me>
Date:   Fri Apr 24 05:24:48 2020 +0300

    ALSA: usb-audio: Improve frames size computation
    
    For computation of the the next frame size current value of fs/fps and
    accumulated fractional parts of fs/fps are used, where values are stored
    in Q16.16 format. This is quite natural for computing frame size for
    asynchronous endpoints driven by explicit feedback, since in this case
    fs/fps is a value provided by the feedback endpoint and it's already in
    the Q format. If an error is accumulated over time, the device can
    adjust fs/fps value to prevent buffer overruns/underruns.
    
    But for synchronous endpoints the accuracy provided by these computations
    is not enough. Due to accumulated error the driver periodically produces
    frames with incorrect size (+/- 1 audio sample).
    
    This patch fixes this issue by implementing a different algorithm for
    frame size computation. It is based on accumulating of the remainders
    from division fs/fps and it doesn't accumulate errors over time. This
    new method is enabled for synchronous and adaptive playback endpoints.
    
    Signed-off-by: Alexander Tsoy <alexander@tsoy.me>
    Link: https://lore.kernel.org/r/20200424022449.14972-1-alexander@tsoy.me
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 395403a2d33f..820e564656ed 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -84,6 +84,10 @@ struct snd_usb_endpoint {
 	dma_addr_t sync_dma;		/* DMA address of syncbuf */
 
 	unsigned int pipe;		/* the data i/o pipe */
+	unsigned int framesize[2];	/* small/large frame sizes in samples */
+	unsigned int sample_rem;	/* remainder from division fs/fps */
+	unsigned int sample_accum;	/* sample accumulator */
+	unsigned int fps;		/* frames per second */
 	unsigned int freqn;		/* nominal sampling rate in fs/fps in Q16.16 format */
 	unsigned int freqm;		/* momentary sampling rate in fs/fps in Q16.16 format */
 	int	   freqshift;		/* how much to shift the feedback value to get Q16.16 */

commit 92adc96f8eecd9522a907c197cc3d62e405539fe
Author: Hui Wang <hui.wang@canonical.com>
Date:   Wed Dec 18 21:26:50 2019 +0800

    ALSA: usb-audio: set the interface format after resume on Dell WD19
    
    Recently we found the headset-mic on the Dell Dock WD19 doesn't work
    anymore after s3 (s2i or deep), this problem could be workarounded by
    closing (pcm_close) the app and then reopening (pcm_open) the app, so
    this bug is not easy to be detected by users.
    
    When problem happens, retire_capture_urb() could still be called
    periodically, but the size of captured data is always 0, it could be
    a firmware bug on the dock. Anyway I found after resuming, the
    snd_usb_pcm_prepare() will be called, and if we forcibly run
    set_format() to set the interface and its endpoint, the capture
    size will be normal again. This problem and workaound also apply to
    playback.
    
    To fix it in the kernel, add a quirk to let set_format() run
    forcibly once after resume.
    
    Signed-off-by: Hui Wang <hui.wang@canonical.com>
    Cc: <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20191218132650.6303-1-hui.wang@canonical.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 2991b9986f66..395403a2d33f 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -145,6 +145,7 @@ struct snd_usb_substream {
 	struct snd_usb_endpoint *sync_endpoint;
 	unsigned long flags;
 	bool need_setup_ep;		/* (re)configure EP at prepare? */
+	bool need_setup_fmt;		/* (re)configure fmt after resume? */
 	unsigned int speed;		/* USB_SPEED_XXX */
 
 	u64 formats;			/* format bitmasks (all or'ed) */

commit 66354f18fe5fbb65f7b10a519654013d6df09f80
Author: Shuah Khan <shuah@kernel.org>
Date:   Mon Apr 1 20:40:22 2019 -0400

    media: sound/usb: Use Media Controller API to share media resources
    
    Media Device Allocator API to allows multiple drivers share a media device.
    This API solves a very common use-case for media devices where one physical
    device (an USB stick) provides both audio and video. When such media device
    exposes a standard USB Audio class, a proprietary Video class, two or more
    independent drivers will share a single physical USB bridge. In such cases,
    it is necessary to coordinate access to the shared resource.
    
    Using this API, drivers can allocate a media device with the shared struct
    device as the key. Once the media device is allocated by a driver, other
    drivers can get a reference to it. The media device is released when all
    the references are released.
    
    Change the ALSA driver to use the Media Controller API to share media
    resources with DVB, and V4L2 drivers on a AU0828 media device.
    
    The Media Controller specific initialization is done after sound card is
    registered. ALSA creates Media interface and entity function graph nodes
    for Control, Mixer, PCM Playback, and PCM Capture devices.
    
    snd_usb_hw_params() will call Media Controller enable source handler
    interface to request the media resource. If resource request is granted,
    it will release it from snd_usb_hw_free(). If resource is busy, -EBUSY is
    returned.
    
    Media specific cleanup is done in usb_audio_disconnect().
    
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Shuah Khan <shuah@kernel.org>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 79fa2a19fb7b..2991b9986f66 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -109,6 +109,8 @@ struct snd_usb_endpoint {
 	struct list_head list;
 };
 
+struct media_ctl;
+
 struct snd_usb_substream {
 	struct snd_usb_stream *stream;
 	struct usb_device *dev;
@@ -161,6 +163,7 @@ struct snd_usb_substream {
 	} dsd_dop;
 
 	bool trigger_tstamp_pending_update; /* trigger timestamp being updated from initial estimate */
+	struct media_ctl *media_ctl;
 };
 
 struct snd_usb_stream {

commit c7a13264918b9796f80c634f20fea56e1612572d
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Mon Feb 18 00:17:21 2019 +0200

    ALSA: usb-audio: Expose sample resolution through proc interface
    
    At least some USB devices use (MSB-aligned) audio format larger
    than the actual resolution of the device. In order to expose the
    actual device resolution (bBitResolution), add extra field to the
    procfs stream info interface.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index ac785d15ced4..79fa2a19fb7b 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -14,6 +14,7 @@ struct audioformat {
 	u64 formats;			/* ALSA format bits */
 	unsigned int channels;		/* # channels */
 	unsigned int fmt_type;		/* USB audio format type (1-3) */
+	unsigned int fmt_bits;		/* number of significant bits */
 	unsigned int frame_size;	/* samples per frame for non-audio */
 	int iface;			/* interface number */
 	unsigned char altsetting;	/* corresponding alternate setting */

commit 7edf3b5e6a4544b42d3572a7058f8ffe96349ee8
Author: Jorge Sanjuan <jorge.sanjuan@codethink.co.uk>
Date:   Tue Jul 31 13:28:43 2018 +0100

    ALSA: usb-audio: AudioStreaming Power Domain parsing
    
    Power Domains in the UAC3 spec are mainly intended to be
    associated to an Input or Output Terminal so the host
    changes the power state of the entire capture or playback
    path within the topology.
    
    This patch adds support for finding Power Domains associated
    to an Audio Streaming Interface (bTerminalLink) and adds a
    reference to them in the usb audio substreams (snd_usb_substream).
    
    Signed-off-by: Jorge Sanjuan <jorge.sanjuan@codethink.co.uk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 9b41b7dda84f..ac785d15ced4 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -37,6 +37,7 @@ struct audioformat {
 
 struct snd_usb_substream;
 struct snd_usb_endpoint;
+struct snd_usb_power_domain;
 
 struct snd_urb_ctx {
 	struct urb *urb;
@@ -115,6 +116,7 @@ struct snd_usb_substream {
 	int interface;	/* current interface */
 	int endpoint;	/* assigned endpoint */
 	struct audioformat *cur_audiofmt;	/* current audioformat pointer (for hw_params callback) */
+	struct snd_usb_power_domain *str_pd;	/* UAC3 Power Domain for streaming path */
 	snd_pcm_format_t pcm_format;	/* current audio format (for hw_params callback) */
 	unsigned int channels;		/* current number of channels (for hw_params callback) */
 	unsigned int channels_max;	/* max channels in the all audiofmts */

commit 3a572d94bcff98a14c94fe686881a169a26f3fca
Author: Jussi Laako <jussi@sonarnerd.net>
Date:   Wed Jun 13 01:43:01 2018 +0300

    ALSA: usb-audio: Add native DSD support for Mytek DACs
    
    Add new mostly generic code with Mytek VID to support native DSD mode.
    
    This implementation should be easier to maintain when manufacturers
    release new products.
    
    Signed-off-by: Jussi Laako <jussi@sonarnerd.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 1406292d50ec..9b41b7dda84f 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -32,6 +32,7 @@ struct audioformat {
 	struct snd_pcm_chmap_elem *chmap; /* (optional) channel map */
 	bool dsd_dop;			/* add DOP headers in case of DSD samples */
 	bool dsd_bitrev;		/* reverse the bits of each DSD sample */
+	bool dsd_raw;			/* altsetting is raw DSD */
 };
 
 struct snd_usb_substream;

commit 9a2fe9b801f585baccf8352d82839dcd54b300cf
Author: Ruslan Bilovol <ruslan.bilovol@gmail.com>
Date:   Wed Mar 21 02:03:59 2018 +0200

    ALSA: usb: initial USB Audio Device Class 3.0 support
    
    Recently released USB Audio Class 3.0 specification
    introduces many significant changes comparing to
    previous versions, like
     - new Power Domains, support for LPM/L1
     - new Cluster descriptor
     - changed layout of all class-specific descriptors
     - new High Capability descriptors
     - New class-specific String descriptors
     - new and removed units
     - additional sources for interrupts
     - removed Type II Audio Data Formats
     - ... and many other things (check spec)
    
    It also provides backward compatibility through
    multiple configurations, as well as requires
    mandatory support for BADD (Basic Audio Device
    Definition) on each ADC3.0 compliant device
    
    This patch adds initial support of UAC3 specification
    that is enough for Generic I/O Profile (BAOF, BAIF)
    device support from BADD document.
    
    Signed-off-by: Ruslan Bilovol <ruslan.bilovol@gmail.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index ed87cc83eb47..1406292d50ec 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -22,7 +22,7 @@ struct audioformat {
 	unsigned char endpoint;		/* endpoint */
 	unsigned char ep_attr;		/* endpoint attributes */
 	unsigned char datainterval;	/* log_2 of data packet interval */
-	unsigned char protocol;		/* UAC_VERSION_1/2 */
+	unsigned char protocol;		/* UAC_VERSION_1/2/3 */
 	unsigned int maxpacksize;	/* max. packet size */
 	unsigned int rates;		/* rate bitmasks */
 	unsigned int rate_min, rate_max;	/* min/max rates */

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 111b0f009afa..ed87cc83eb47 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __USBAUDIO_CARD_H
 #define __USBAUDIO_CARD_H
 

commit ca0dd2736a05d1df94c8657b4865f9d6c6637085
Author: Daniel Mack <daniel@zonque.org>
Date:   Mon Aug 22 08:53:37 2016 +0200

    ALSA: usb: use TEAC UD-H01 quirk for more devices
    
    The quirk seems to be necessary not only for TEAC UD-H01 devices, but to
    more that are based on the Tenor 8802TL chipset. Devices built by T+A
    are affected too, and they apparently all use the same USB PID:PID.
    
    Extend the quirky handling for that device as well, and rename the
    quirks flag.
    
    Reported-and-tested-by: Thomas Gresens <T.Gresens@intershop.de>
    Signed-off-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 71778ca4b26a..111b0f009afa 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -92,7 +92,7 @@ struct snd_usb_endpoint {
 	unsigned int curframesize;      /* current packet size in frames (for capture) */
 	unsigned int syncmaxsize;	/* sync endpoint packet size */
 	unsigned int fill_max:1;	/* fill max packet size always */
-	unsigned int udh01_fb_quirk:1;	/* corrupted feedback data */
+	unsigned int tenor_fb_quirk:1;	/* corrupted feedback data */
 	unsigned int datainterval;      /* log_2 of data packet interval */
 	unsigned int syncinterval;	/* P for adaptive mode, 0 otherwise */
 	unsigned char silence_value;

commit c89178f57a19300b2056f58167e183e966a4836d
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Thu Mar 31 09:57:29 2016 -0300

    [media] Revert "[media] sound/usb: Use Media Controller API to share media resources"
    
    Unfortunately, this patch caused several regressions at au0828 and
    snd-usb-audio, like this one:
            https://bugzilla.kernel.org/show_bug.cgi?id=115561
    
    It also showed several troubles at the MC core that handles pretty
    poorly the memory protections and data lifetime management.
    
    So, better to revert it and fix the core before reapplying this
    change.
    
    This reverts commit aebb2b89bff0 ("[media] sound/usb: Use Media
    Controller API to share media resources")'
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 34a0898e2238..71778ca4b26a 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -105,8 +105,6 @@ struct snd_usb_endpoint {
 	struct list_head list;
 };
 
-struct media_ctl;
-
 struct snd_usb_substream {
 	struct snd_usb_stream *stream;
 	struct usb_device *dev;
@@ -158,7 +156,6 @@ struct snd_usb_substream {
 	} dsd_dop;
 
 	bool trigger_tstamp_pending_update; /* trigger timestamp being updated from initial estimate */
-	struct media_ctl *media_ctl;
 };
 
 struct snd_usb_stream {

commit aebb2b89bff0fdeb4e7ddd73dcbccde1a0f27554
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Wed Mar 2 13:50:31 2016 -0300

    [media] sound/usb: Use Media Controller API to share media resources
    
    Change ALSA driver to use Media Controller API to share media resources
    with DVB and V4L2 drivers on a AU0828 media device. Media Controller
    specific initialization is done after sound card is registered. ALSA
    creates Media interface and entity function graph nodes for Control,
    Mixer, PCM Playback, and PCM Capture devices.
    
    snd_usb_hw_params() will call Media Controller enable source handler
    interface to request the media resource. If resource request is
    granted, it will release it from snd_usb_hw_free(). If resource is
    busy, -EBUSY is returned.
    
    Media specific cleanup is done in usb_audio_disconnect().
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 71778ca4b26a..34a0898e2238 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -105,6 +105,8 @@ struct snd_usb_endpoint {
 	struct list_head list;
 };
 
+struct media_ctl;
+
 struct snd_usb_substream {
 	struct snd_usb_stream *stream;
 	struct usb_device *dev;
@@ -156,6 +158,7 @@ struct snd_usb_substream {
 	} dsd_dop;
 
 	bool trigger_tstamp_pending_update; /* trigger timestamp being updated from initial estimate */
+	struct media_ctl *media_ctl;
 };
 
 struct snd_usb_stream {

commit e05704467736231199503e5a21c587e7ec36b829
Author: Ricard Wanderlof <ricard.wanderlof@axis.com>
Date:   Mon Oct 19 08:52:53 2015 +0200

    ALSA: USB-audio: Add quirk for Zoom R16/24 playback
    
    The Zoom R16/24 have a nonstandard playback format where each isochronous
    packet contains a length descriptor in the first four bytes. (Curiously,
    capture data does not contain this and requires no quirk.)
    
    The quirk involves adding the extra length descriptor whenever outgoing
    isochronous packets are generated, both in pcm.c (outgoing audio) and
    endpoint.c (silent data).
    
    In order to make the quirk as unintrusive as possible, for
    pcm.c:prepare_playback_urb(), the isochronous packet descriptors are
    initially set up in the same way no matter if the quirk is enabled or not.
    Once it is time to actually copy the data into the outgoing packet buffer
    (together with the added length descriptors) the isochronous descriptors
    are adjusted in order take the increased payload length into account.
    
    For endpoint.c:prepare_silent_urb() it makes more sense to modify the
    actual function, partly because the function is less complex to start with
    and partly because it is not as time-critical as prepare_playback_urb()
    (whose bulk is run with interrupts disabled), so the (minute) additional
    time spent in the non-quirk case is motivated by the simplicity of having
    a single function for all cases.
    
    The quirk is controlled by the new tx_length_quirk member in struct
    snd_usb_substream and struct snd_usb_audio, which is conveyed to pcm.c
    and endpoint.c from quirks.c in a similar manner to the txfr_quirk member
    in the same structs.
    
    In contrast to txfr_quirk however, the quirk is enabled directly in
    quirks.c:create_standard_audio_quirk() by checking the USB ID in that
    function. Another option would be to introduce a new
    QUIRK_AUDIO_ZOOM_INTERFACE or somesuch, which would have made the quirk
    very plain to see in the quirk table, but it was felt that the additional
    code needed to implement it this way would just make the implementation
    more complex with no real gain.
    
    Tested with a Zoom R16, both by doing capture and playback separately
    using arecord and aplay (8 channel capture and 2 channel playback,
    respectively), as well as capture and playback together using Ardour, as
    well as Audacity and Qtractor together with jackd.
    
    The R24 is reportedly compatible with the R16 when used as an audio
    interface. Both devices share the same USB ID and have the same number of
    inputs (8) and outputs (2). Therefore "R16/24" is mentioned throughout the
    patch.
    
    Regression tested using an Edirol UA-5 in both class compliant (16-bit)
    and "advanced" (24 bit, forces the use of quirks) modes.
    
    Signed-off-by: Ricard Wanderlof <ricardw@axis.com>
    Tested-by: Panu Matilainen <pmatilai@laiskiainen.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index ef580b43f1e3..71778ca4b26a 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -122,6 +122,7 @@ struct snd_usb_substream {
 	unsigned int buffer_periods;	/* current periods per buffer */
 	unsigned int altset_idx;     /* USB data format: index of alternate setting */
 	unsigned int txfr_quirk:1;	/* allow sub-frame alignment */
+	unsigned int tx_length_quirk:1;	/* add length specifier to transfers */
 	unsigned int fmt_type;		/* USB audio format type (1-3) */
 	unsigned int pkt_offset_adj;	/* Bytes to drop from beginning of packets (for non-compliant devices) */
 

commit ea33d359c4421f369443f6fee92a1e893541eb73
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Fri Feb 6 15:55:53 2015 -0600

    ALSA: usb: update trigger timestamp on first non-zero URB submitted
    
    The first URBs are submitted during the prepare stage. When .trigger is
    called, the ALSA core saves a trigger tstamp that doesn't correspond to
    the actual time when the samples are submitted. The trigger_tstamp is
    now updated when the first data are submitted to avoid any time offsets.
    
    A usb-specific trigger_tstamp_pending_update flag is used for now,
    at some point the flag would need to move to the ALSA core, USB
    is not the only interface where silent block transfers are programmed
    as part of the prepare stage, with actual data enabled when .trigger
    is called.
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 97acb906acc2..ef580b43f1e3 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -153,6 +153,8 @@ struct snd_usb_substream {
 		int channel;
 		int byte_idx;
 	} dsd_dop;
+
+	bool trigger_tstamp_pending_update; /* trigger timestamp being updated from initial estimate */
 };
 
 struct snd_usb_stream {

commit 7040b6d1febfdbd9c1595efb751d492cd2503f96
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu May 1 12:20:22 2014 +0200

    ALSA: usb-audio: work around corrupted TEAC UD-H01 feedback data
    
    The TEAC UD-H01 firmware sends wrong feedback frequency values, thus
    causing the PC to send the samples at a wrong rate, which results in
    clicks and crackles in the output.
    
    Add a workaround to detect and fix the corruption.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    [mick37@gmx.de: use sender->udh01_fb_quirk rather than
     ep->udh01_fb_quirk in snd_usb_handle_sync_urb()]
    Reported-and-tested-by: Mick <mick37@gmx.de>
    Reported-and-tested-by: Andrea Messa <andr.messa@tiscali.it>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 9867ab866857..97acb906acc2 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -92,6 +92,7 @@ struct snd_usb_endpoint {
 	unsigned int curframesize;      /* current packet size in frames (for capture) */
 	unsigned int syncmaxsize;	/* sync endpoint packet size */
 	unsigned int fill_max:1;	/* fill max packet size always */
+	unsigned int udh01_fb_quirk:1;	/* corrupted feedback data */
 	unsigned int datainterval;      /* log_2 of data packet interval */
 	unsigned int syncinterval;	/* P for adaptive mode, 0 otherwise */
 	unsigned char silence_value;

commit df23a2466a4961092625b487ead60f526e401062
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Sun Oct 6 22:31:13 2013 +0200

    ALSA: usb-audio: rename alt_idx to altsetting
    
    As Clemens Ladisch kindly explained:
     "Please note that there are two methods to identify alternate settings:
      the number, which is the value in bAlternateSetting, and the index,
      which is the index in the descriptor array.  There might be some wording
      in the USB spec that these two values must be the same, but in reality,
      [insert standard rant about firmware writers], bAlternateSetting
      must be treated as a random ID value."
    
    This patch changes the name to express the correct usage semantics.
    No functional change.
    
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index ca98a9b915c9..9867ab866857 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -96,7 +96,7 @@ struct snd_usb_endpoint {
 	unsigned int syncinterval;	/* P for adaptive mode, 0 otherwise */
 	unsigned char silence_value;
 	unsigned int stride;
-	int iface, alt_idx;
+	int iface, altsetting;
 	int skip_packets;		/* quirks for devices to ignore the first n packets
 					   in a stream */
 

commit 976b6c064a957445eb0573b270f2d0282630e9b9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 24 15:51:58 2013 -0400

    ALSA: improve buffer size computations for USB PCM audio
    
    This patch changes the way URBs are allocated and their sizes are
    determined for PCM playback in the snd-usb-audio driver.  Currently
    the driver allocates too few URBs for endpoints that don't use
    implicit sync, making underruns more likely to occur.  This may be a
    holdover from before I/O delays could be measured accurately; in any
    case, it is no longer necessary.
    
    The patch allocates as many URBs as possible, subject to four
    limitations:
    
            The total number of URBs for the endpoint is not allowed to
            exceed MAX_URBS (which the patch increases from 8 to 12).
    
            The total number of packets per URB is not allowed to exceed
            MAX_PACKS (or MAX_PACKS_HS for high-speed devices), which is
            decreased from 20 to 6.
    
            The total duration of queued data is not allowed to exceed
            MAX_QUEUE, which is decreased from 24 ms to 18 ms.
    
            The total number of ALSA frames in the output queue is not
            allowed to exceed the ALSA buffer size.
    
    The last requirement is the hardest to implement.  Currently the
    number of URBs needed to fill a buffer cannot be determined in
    advance, because a buffer contains a fixed number of frames whereas
    the number of frames in an URB varies to match shifts in the device's
    clock rate.  To solve this problem, the patch changes the logic for
    deciding how many packets an URB should contain.  Rather than using as
    many as possible without exceeding an ALSA period boundary, now the
    driver uses only as many packets as needed to transfer a predetermined
    number of frames.  As a result, unless the device's clock has an
    exceedingly variable rate, the number of URBs making up each period
    (and hence each buffer) will remain constant.
    
    The overall effect of the patch is that playback works better in
    low-latency settings.  The user can still specify values for
    frames/period and periods/buffer that exceed the capabilities of the
    hardware, of course.  But for values that are within those
    capabilities, the performance will be improved.  For example, testing
    shows that a high-speed device can handle 32 frames/period and 3
    periods/buffer at 48 KHz, whereas the current driver starts to get
    glitchy at 64 frames/period and 2 periods/buffer.
    
    A side effect of these changes is that the "nrpacks" module parameter
    is no longer used.  The patch removes it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Clemens Ladisch <clemens@ladisch.de>
    Tested-by: Daniel Mack <zonque@gmail.com>
    Tested-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 5ecacaa90b53..ca98a9b915c9 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -2,11 +2,11 @@
 #define __USBAUDIO_CARD_H
 
 #define MAX_NR_RATES	1024
-#define MAX_PACKS	20
+#define MAX_PACKS	6		/* per URB */
 #define MAX_PACKS_HS	(MAX_PACKS * 8)	/* in high speed mode */
-#define MAX_URBS	8
+#define MAX_URBS	12
 #define SYNC_URBS	4	/* always four urbs for sync */
-#define MAX_QUEUE	24	/* try not to exceed this queue length, in ms */
+#define MAX_QUEUE	18	/* try not to exceed this queue length, in ms */
 
 struct audioformat {
 	struct list_head list;
@@ -87,6 +87,7 @@ struct snd_usb_endpoint {
 	unsigned int phase;		/* phase accumulator */
 	unsigned int maxpacksize;	/* max packet size in bytes */
 	unsigned int maxframesize;      /* max packet size in frames */
+	unsigned int max_urb_frames;	/* max URB size in frames */
 	unsigned int curpacksize;	/* current packet size in bytes (for capture) */
 	unsigned int curframesize;      /* current packet size in frames (for capture) */
 	unsigned int syncmaxsize;	/* sync endpoint packet size */
@@ -116,6 +117,8 @@ struct snd_usb_substream {
 	unsigned int channels_max;	/* max channels in the all audiofmts */
 	unsigned int cur_rate;		/* current rate (for hw_params callback) */
 	unsigned int period_bytes;	/* current period bytes (for hw_params callback) */
+	unsigned int period_frames;	/* current frames per period */
+	unsigned int buffer_periods;	/* current periods per buffer */
 	unsigned int altset_idx;     /* USB data format: index of alternate setting */
 	unsigned int txfr_quirk:1;	/* allow sub-frame alignment */
 	unsigned int fmt_type;		/* USB audio format type (1-3) */
@@ -125,6 +128,7 @@ struct snd_usb_substream {
 
 	unsigned int hwptr_done;	/* processed byte position in the buffer */
 	unsigned int transfer_done;		/* processed frames since last period update */
+	unsigned int frame_limit;	/* limits number of packets in URB */
 
 	/* data and sync endpoints for this stream */
 	unsigned int ep_num;		/* the endpoint number */

commit 8f898e92aea2c24c7f379ee265d178f69ebb9c07
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Jan 31 21:39:17 2013 +0100

    ALSA: usb-audio: store protocol version in struct audioformat
    
    Instead of reading bInterfaceProtocol from the descriptor whenever it's
    needed, store this value in the audioformat structure.  Besides
    simplifying some code, this will allow us to correctly handle vendor-
    specific devices where the descriptors are marked with other values.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index bf2889a2cae5..5ecacaa90b53 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -21,6 +21,7 @@ struct audioformat {
 	unsigned char endpoint;		/* endpoint */
 	unsigned char ep_attr;		/* endpoint attributes */
 	unsigned char datainterval;	/* log_2 of data packet interval */
+	unsigned char protocol;		/* UAC_VERSION_1/2 */
 	unsigned int maxpacksize;	/* max. packet size */
 	unsigned int rates;		/* rate bitmasks */
 	unsigned int rate_min, rate_max;	/* min/max rates */

commit 44dcbbb1cd615634c09d1bf31c124332795903a8
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Apr 17 00:01:39 2013 +0800

    ALSA: snd-usb: add support for bit-reversed byte formats
    
    There is quite some confusion around the bit-ordering in DSD samples,
    and no general agreement that defines whether hardware is supposed to
    expect the oldest sample in the MSB or the LSB of a byte.
    
    ALSA will hence set the rule that on the software API layer, bytes
    always carry the oldest bit in the most significant bit of a byte, and
    the driver has to translate that at runtime in order to match the
    hardware layout.
    
    This patch adds support for this by adding a boolean flag to the
    audio format struct.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index ac55477ce6dd..bf2889a2cae5 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -29,6 +29,7 @@ struct audioformat {
 	unsigned char clock;		/* associated clock */
 	struct snd_pcm_chmap_elem *chmap; /* (optional) channel map */
 	bool dsd_dop;			/* add DOP headers in case of DSD samples */
+	bool dsd_bitrev;		/* reverse the bits of each DSD sample */
 };
 
 struct snd_usb_substream;

commit d24f5061ee7b9b58a7e97f3c2a72f0a9b115e7e0
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Apr 17 00:01:38 2013 +0800

    ALSA: snd-usb: add support for DSD DOP stream transport
    
    In order to provide a compatibility way for pushing DSD
    samples through ordinary PCM channels, the "DoP open Standard" was
    invented. See http://www.dsd-guide.com for the official document.
    
    The host is required to stuff DSD marker bytes (0x05, 0xfa,
    alternating) in the MSB of 24 bit wide samples on the bus, in addition
    to the 16 bits of actual DSD sample payload.
    
    To support this, the hardware and software stride logic in the driver
    has to be tweaked a bit, as we make the userspace believe we're
    operating on 16 bit samples, while we in fact push one more byte per
    channel down to the hardware.
    
    The DOP runtime information is stored in struct snd_usb_substream, so
    we can keep track of our state across multiple calls to
    prepare_playback_urb_dsd_dop().
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index d32ea411545a..ac55477ce6dd 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -28,6 +28,7 @@ struct audioformat {
 	unsigned int *rate_table;	/* rate table */
 	unsigned char clock;		/* associated clock */
 	struct snd_pcm_chmap_elem *chmap; /* (optional) channel map */
+	bool dsd_dop;			/* add DOP headers in case of DSD samples */
 };
 
 struct snd_usb_substream;
@@ -139,6 +140,12 @@ struct snd_usb_substream {
 
 	int last_frame_number;          /* stored frame number */
 	int last_delay;                 /* stored delay */
+
+	struct {
+		int marker;
+		int channel;
+		int byte_idx;
+	} dsd_dop;
 };
 
 struct snd_usb_stream {

commit 1539d4f82ad534431cc67935e8e442ccf107d17d
Author: Calvin Owens <jcalvinowens@gmail.com>
Date:   Fri Apr 12 22:33:59 2013 -0500

    ALSA: usb: Add quirk for 192KHz recording on E-Mu devices
    
    When recording at 176.2KHz or 192Khz, the device adds a 32-bit length
    header to the capture packets, which obviously needs to be ignored for
    recording to work properly.
    
    Userspace expected:  L0 L1 L2 R0 R1 R2
    ...but actually got: R2 L0 L1 L2 R0 R1
    
    Also, the last byte of the length header being interpreted as L0 of
    the first sample caused spikes every 0.5ms, resulting in a loud 16KHz
    tone (about the highest 'B' on a piano) being present throughout
    captures.
    
    Tested at all sample rates on an E-Mu 0404USB, and tested for
    regressions on a generic USB headset.
    
    Signed-off-by: Calvin Owens <jcalvinowens@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 8a751b4887ea..d32ea411545a 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -116,6 +116,7 @@ struct snd_usb_substream {
 	unsigned int altset_idx;     /* USB data format: index of alternate setting */
 	unsigned int txfr_quirk:1;	/* allow sub-frame alignment */
 	unsigned int fmt_type;		/* USB audio format type (1-3) */
+	unsigned int pkt_offset_adj;	/* Bytes to drop from beginning of packets (for non-compliant devices) */
 
 	unsigned int running: 1;	/* running status */
 

commit 04324ccc75f96b3ed7aad1c866d1b7925e977bdf
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 26 16:24:02 2012 +0100

    ALSA: usb-audio: add channel map support
    
    Add the support for channel maps of the PCM streams on USB audio
    devices.  The channel map information is already found in
    ChannelConfig descriptor entries, which haven't been referred until
    now.
    
    Each chmap entry is added to audioformat list entry and copied to TLV
    dynamically instead of creating a whole chmap array.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 814cb357ff88..8a751b4887ea 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -27,6 +27,7 @@ struct audioformat {
 	unsigned int nr_rates;		/* number of rate table entries */
 	unsigned int *rate_table;	/* rate table */
 	unsigned char clock;		/* associated clock */
+	struct snd_pcm_chmap_elem *chmap; /* (optional) channel map */
 };
 
 struct snd_usb_substream;
@@ -109,6 +110,7 @@ struct snd_usb_substream {
 	struct audioformat *cur_audiofmt;	/* current audioformat pointer (for hw_params callback) */
 	snd_pcm_format_t pcm_format;	/* current audio format (for hw_params callback) */
 	unsigned int channels;		/* current number of channels (for hw_params callback) */
+	unsigned int channels_max;	/* max channels in the all audiofmts */
 	unsigned int cur_rate;		/* current rate (for hw_params callback) */
 	unsigned int period_bytes;	/* current period bytes (for hw_params callback) */
 	unsigned int altset_idx;     /* USB data format: index of alternate setting */

commit 978520b75f0a1ce82b17e1e8186417250de6d545
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Oct 12 15:12:55 2012 +0200

    ALSA: usb-audio: Fix races at disconnection
    
    Close some races at disconnection of a USB audio device by adding the
    chip->shutdown_mutex and chip->shutdown check at appropriate places.
    
    The spots to put bandaids are:
    - PCM prepare, hw_params and hw_free
    - where the usb device is accessed for communication or get speed, in
     mixer.c and others; the device speed is now cached in subs->speed
     instead of accessing to chip->dev
    
    The accesses in PCM open and close don't need the mutex protection
    because these are already handled in the core PCM disconnection code.
    
    The autosuspend/autoresume codes are still uncovered by this patch
    because of possible mutex deadlocks.  They'll be covered by the
    upcoming change to rwsem.
    
    Also the mixer codes are untouched, too.  These will be fixed in
    another patch, too.
    
    Reported-by: Matthieu CASTET <matthieu.castet@parrot.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index afa4f9e9b27a..814cb357ff88 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -126,6 +126,7 @@ struct snd_usb_substream {
 	struct snd_usb_endpoint *sync_endpoint;
 	unsigned long flags;
 	bool need_setup_ep;		/* (re)configure EP at prepare? */
+	unsigned int speed;		/* USB_SPEED_XXX */
 
 	u64 formats;			/* format bitmasks (all or'ed) */
 	unsigned int num_formats;		/* number of supported audio formats (list) */

commit 384dc085c32285e6548511bf80c5d5a5b246ed24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 18 14:49:31 2012 +0200

    ALSA: usb-audio: Avoid unnecessary EP setups in prepare
    
    The recent fix for USB suspend breakage moved the code to set up EP
    from hw_params to prepare, but it means also the EP setup might be
    called multiple times unnecessarily because the prepare callback can
    be called multiple times without starting the stream (e.g. OSS
    emulation).
    
    This patch adds a new flag to struct snd_usb_substream indicating
    whether the setup of EP is required, and do it only when necessary,
    i.e. right after hw_params or suspend.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 6cc883c3567d..afa4f9e9b27a 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -125,6 +125,7 @@ struct snd_usb_substream {
 	struct snd_usb_endpoint *data_endpoint;
 	struct snd_usb_endpoint *sync_endpoint;
 	unsigned long flags;
+	bool need_setup_ep;		/* (re)configure EP at prepare? */
 
 	u64 formats;			/* format bitmasks (all or'ed) */
 	unsigned int num_formats;		/* number of supported audio formats (list) */

commit 61a709504b079110cd5b12ea9a4590ffea687a5c
Author: Dylan Reid <dgreid@chromium.org>
Date:   Tue Sep 18 09:49:48 2012 -0700

    ALSA: usb-audio: Move configuration to prepare.
    
    Move interface and endpoint configuration from hw_params to prepare
    callback.  During system suspend/resume when the USB device power isn't
    cycled the interface and endpoint configuration need to be set before
    audio playback can continue.  Resume involves another call to prepare
    but not to hw_params, moving it here allows a playing stream to continue
    after resume.
    
    Signed-off-by: Dylan Reid <dgreid@chromium.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 23b6f23bd36a..6cc883c3567d 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -107,6 +107,8 @@ struct snd_usb_substream {
 	int interface;	/* current interface */
 	int endpoint;	/* assigned endpoint */
 	struct audioformat *cur_audiofmt;	/* current audioformat pointer (for hw_params callback) */
+	snd_pcm_format_t pcm_format;	/* current audio format (for hw_params callback) */
+	unsigned int channels;		/* current number of channels (for hw_params callback) */
 	unsigned int cur_rate;		/* current rate (for hw_params callback) */
 	unsigned int period_bytes;	/* current period bytes (for hw_params callback) */
 	unsigned int altset_idx;     /* USB data format: index of alternate setting */

commit 2b58fd5b3193fd3af3d15114d95706087d25a7fe
Author: Daniel Mack <zonque@gmail.com>
Date:   Tue Sep 4 10:23:07 2012 +0200

    ALSA: snd-usb: Add quirks for Playback Designs devices
    
    Playback Designs' USB devices have some hardware limitations on their
    USB interface. In particular:
    
     - They need a 20ms delay after each class compliant request as the
       hardware ACKs the USB packets before the device is actually ready
       for the next command. Sending data immediately will result in buffer
       overflows in the hardware.
     - The devices send bogus feedback data at the start of each stream
       which confuse the feedback format auto-detection.
    
    This patch introduces a new quirks hook that is called after each
    control packet and which adds a delay for all devices that match
    Playback Designs' USB VID for now.
    
    In addition, it adds a counter to snd_usb_endpoint to drop received
    packets on the floor. Another new quirks function that is called once
    an endpoint is started initializes that counter for these devices on
    their sync endpoint.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Reported-and-tested-by: Andreas Koch <andreas@akdesigninc.com>
    Supported-by: Demian Martin <demianm_1@yahoo.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index bcb5267a02e8..23b6f23bd36a 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -92,6 +92,8 @@ struct snd_usb_endpoint {
 	unsigned char silence_value;
 	unsigned int stride;
 	int iface, alt_idx;
+	int skip_packets;		/* quirks for devices to ignore the first n packets
+					   in a stream */
 
 	spinlock_t lock;
 	struct list_head list;

commit 48ee7cb8b4867093c75eb5102f2359c9799b3341
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 28 16:27:26 2012 -0700

    ALSA: usb-audio: Remove obsoleted fields in struct snd_usb_substream
    
    The two entries are duplicated in struct snd_usb_endpoint.
    Seems forgotten in the last clean-up.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 2b9fffff23b6..bcb5267a02e8 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -115,8 +115,6 @@ struct snd_usb_substream {
 
 	unsigned int hwptr_done;	/* processed byte position in the buffer */
 	unsigned int transfer_done;		/* processed frames since last period update */
-	unsigned long active_mask;	/* bitmask of active urbs */
-	unsigned long unlink_mask;	/* bitmask of unlinked urbs */
 
 	/* data and sync endpoints for this stream */
 	unsigned int ep_num;		/* the endpoint number */

commit 8260ef075bd9848ce6a8004ec73b7454d410cc15
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 8 09:01:37 2012 +0200

    ALSA: usb-audio: Fix substream assignments
    
    In 3.5 kernel, the endpoint is assigned dynamically for the
    substreams, but the PCM assignment still checks the presence of the
    endpoint pointer.  This ended up in duplicated PCM substream creations
    at probing time, resulting in kernel warnings like:
    
    WARNING: at fs/proc/generic.c:586 proc_register+0x169/0x1a6()
    Pid: 1152, comm: modprobe Not tainted 3.5.0-rc1-00110-g71fae7e #2
    Call Trace:
     [<ffffffff8102a400>] warn_slowpath_common+0x83/0x9c
     [<ffffffff8102a4bc>] warn_slowpath_fmt+0x46/0x48
     [<ffffffff813829ad>] ? add_preempt_count+0x39/0x3b
     [<ffffffff811292f0>] proc_register+0x169/0x1a6
     [<ffffffff8112962e>] create_proc_entry+0x74/0x8c
     [<ffffffffa018eb63>] snd_info_register+0x3e/0xc3 [snd]
     [<ffffffffa01fde2e>] snd_pcm_new_stream+0xb1/0x404 [snd_pcm]
     [<ffffffffa024861f>] snd_usb_add_audio_stream+0xd2/0x230 [snd_usb_audio]
     [<ffffffffa0241d33>] ? snd_usb_parse_audio_format+0x252/0x34f [snd_usb_audio]
     [<ffffffff810d6b17>] ? kmem_cache_alloc_trace+0xab/0xbb
     [<ffffffffa0248c29>] snd_usb_parse_audio_interface+0x4ac/0x567 [snd_usb_audio]
     [<ffffffffa023f0ff>] snd_usb_create_stream+0xe9/0x125 [snd_usb_audio]
     [<ffffffffa023f9b1>] usb_audio_probe+0x62a/0x72c [snd_usb_audio]
     .....
    
    This patch fixes the regression by checking the fixed endpoint number
    for each substream instead of the endpoint pointer.
    
    Reported-and-tested-by: Jamie Heilman <jamie@audible.transient.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 0d37238b8457..2b9fffff23b6 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -119,6 +119,7 @@ struct snd_usb_substream {
 	unsigned long unlink_mask;	/* bitmask of unlinked urbs */
 
 	/* data and sync endpoints for this stream */
+	unsigned int ep_num;		/* the endpoint number */
 	struct snd_usb_endpoint *data_endpoint;
 	struct snd_usb_endpoint *sync_endpoint;
 	unsigned long flags;

commit c89a5d9cacf2b862fea986a30b75359f6cf997c1
Author: Daniel Mack <zonque@gmail.com>
Date:   Sat Apr 21 13:52:12 2012 +0200

    ALSA: snd-usb: remove refactorization left-overs
    
    Drop some struct members and definitions that became obsolete during
    the refactorization of the driver.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 77d2eec5e897..0d37238b8457 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -43,13 +43,6 @@ struct snd_urb_ctx {
 	struct list_head ready_list;
 };
 
-struct snd_urb_ops {
-	int (*prepare)(struct snd_usb_substream *subs, struct snd_pcm_runtime *runtime, struct urb *u);
-	int (*retire)(struct snd_usb_substream *subs, struct snd_pcm_runtime *runtime, struct urb *u);
-	int (*prepare_sync)(struct snd_usb_substream *subs, struct snd_pcm_runtime *runtime, struct urb *u);
-	int (*retire_sync)(struct snd_usb_substream *subs, struct snd_pcm_runtime *runtime, struct urb *u);
-};
-
 struct snd_usb_endpoint {
 	struct snd_usb_audio *chip;
 
@@ -125,11 +118,6 @@ struct snd_usb_substream {
 	unsigned long active_mask;	/* bitmask of active urbs */
 	unsigned long unlink_mask;	/* bitmask of unlinked urbs */
 
-	unsigned int nurbs;			/* # urbs */
-	struct snd_urb_ctx dataurb[MAX_URBS];	/* data urb table */
-	struct snd_urb_ctx syncurb[SYNC_URBS];	/* sync urb table */
-	char *syncbuf;				/* sync buffer for all sync URBs */
-	dma_addr_t sync_dma;			/* DMA address of syncbuf */
 	/* data and sync endpoints for this stream */
 	struct snd_usb_endpoint *data_endpoint;
 	struct snd_usb_endpoint *sync_endpoint;
@@ -141,7 +129,6 @@ struct snd_usb_substream {
 	struct snd_pcm_hw_constraint_list rate_list;	/* limited rates */
 	spinlock_t lock;
 
-	struct snd_urb_ops ops;		/* callbacks (must be filled at init) */
 	int last_frame_number;          /* stored frame number */
 	int last_delay;                 /* stored delay */
 };

commit 22026c1a7be900cc6dabd6be37a77bb217d2d837
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 13 12:57:39 2012 +0200

    ALSA: usb: Remove obsoleted fields from struct snd_usb_substream
    
    Many fields have been moved to struct snd_usb_endpoint.
    Also fix the proc output to correspond to the new structure.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 8a08687e5bc0..77d2eec5e897 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -115,21 +115,6 @@ struct snd_usb_substream {
 	unsigned int cur_rate;		/* current rate (for hw_params callback) */
 	unsigned int period_bytes;	/* current period bytes (for hw_params callback) */
 	unsigned int altset_idx;     /* USB data format: index of alternate setting */
-	unsigned int datapipe;   /* the data i/o pipe */
-	unsigned int syncpipe;   /* 1 - async out or adaptive in */
-	unsigned int datainterval;	/* log_2 of data packet interval */
-	unsigned int syncinterval;  /* P for adaptive mode, 0 otherwise */
-	unsigned int freqn;      /* nominal sampling rate in fs/fps in Q16.16 format */
-	unsigned int freqm;      /* momentary sampling rate in fs/fps in Q16.16 format */
-	int          freqshift;  /* how much to shift the feedback value to get Q16.16 */
-	unsigned int freqmax;    /* maximum sampling rate, used for buffer management */
-	unsigned int phase;      /* phase accumulator */
-	unsigned int maxpacksize;	/* max packet size in bytes */
-	unsigned int maxframesize;	/* max packet size in frames */
-	unsigned int curpacksize;	/* current packet size in bytes (for capture) */
-	unsigned int curframesize;	/* current packet size in frames (for capture) */
-	unsigned int syncmaxsize;	/* sync endpoint packet size */
-	unsigned int fill_max: 1;	/* fill max packet size always */
 	unsigned int txfr_quirk:1;	/* allow sub-frame alignment */
 	unsigned int fmt_type;		/* USB audio format type (1-3) */
 

commit edcd3633e72a1590c4cf46befe5e6cd03b5aec3e
Author: Daniel Mack <zonque@gmail.com>
Date:   Thu Apr 12 13:51:12 2012 +0200

    ALSA: snd-usb: switch over to new endpoint streaming logic
    
    With the previous commit that added the new streaming model, all
    endpoint and streaming related code is now in endpoint.c, and pcm.c
    only acts as a wrapper for handling the packet's payload.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 9acbd4a1228d..8a08687e5bc0 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -145,6 +145,10 @@ struct snd_usb_substream {
 	struct snd_urb_ctx syncurb[SYNC_URBS];	/* sync urb table */
 	char *syncbuf;				/* sync buffer for all sync URBs */
 	dma_addr_t sync_dma;			/* DMA address of syncbuf */
+	/* data and sync endpoints for this stream */
+	struct snd_usb_endpoint *data_endpoint;
+	struct snd_usb_endpoint *sync_endpoint;
+	unsigned long flags;
 
 	u64 formats;			/* format bitmasks (all or'ed) */
 	unsigned int num_formats;		/* number of supported audio formats (list) */

commit 8fdff6a319e7dac757c558bd283dc4577e68cde7
Author: Daniel Mack <zonque@gmail.com>
Date:   Thu Apr 12 13:51:11 2012 +0200

    ALSA: snd-usb: implement new endpoint streaming model
    
    This patch adds a new generic streaming logic for audio over USB.
    
    It defines a model (snd_usb_endpoint) that handles everything that
    is related to an USB endpoint and its streaming. There are functions to
    activate and deactivate an endpoint (which call usb_set_interface()),
    and to start and stop its URBs. It also has function pointers to be
    called when data was received or is about to be sent, and pointer to
    a sync slave (another snd_usb_endpoint) that is informed when data has
    been received.
    
    A snd_usb_endpoint knows about its state and implements a refcounting,
    so only the first user will actually start the URBs and only the last
    one to stop it will tear them down again.
    
    With this sort of abstraction, the actual streaming is decoupled from
    the pcm handling, which makes the "implicit feedback" mechanisms easy to
    implement.
    
    In order to split changes properly, this patch only adds the new
    implementation but leaves the old one around, so the the driver doesn't
    change its behaviour. The switch to actually use the new code is
    submitted separately.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index da5fa1ac4eda..9acbd4a1228d 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -30,13 +30,17 @@ struct audioformat {
 };
 
 struct snd_usb_substream;
+struct snd_usb_endpoint;
 
 struct snd_urb_ctx {
 	struct urb *urb;
 	unsigned int buffer_size;	/* size of data buffer, if data URB */
 	struct snd_usb_substream *subs;
+	struct snd_usb_endpoint *ep;
 	int index;	/* index for urb array */
 	int packets;	/* number of packets per urb */
+	int packet_size[MAX_PACKS_HS]; /* size of packets for next submission */
+	struct list_head ready_list;
 };
 
 struct snd_urb_ops {
@@ -46,6 +50,60 @@ struct snd_urb_ops {
 	int (*retire_sync)(struct snd_usb_substream *subs, struct snd_pcm_runtime *runtime, struct urb *u);
 };
 
+struct snd_usb_endpoint {
+	struct snd_usb_audio *chip;
+
+	int use_count;
+	int ep_num;		/* the referenced endpoint number */
+	int type;		/* SND_USB_ENDPOINT_TYPE_* */
+	unsigned long flags;
+
+	void (*prepare_data_urb) (struct snd_usb_substream *subs,
+				  struct urb *urb);
+	void (*retire_data_urb) (struct snd_usb_substream *subs,
+				 struct urb *urb);
+
+	struct snd_usb_substream *data_subs;
+	struct snd_usb_endpoint *sync_master;
+	struct snd_usb_endpoint *sync_slave;
+
+	struct snd_urb_ctx urb[MAX_URBS];
+
+	struct snd_usb_packet_info {
+		uint32_t packet_size[MAX_PACKS_HS];
+		int packets;
+	} next_packet[MAX_URBS];
+	int next_packet_read_pos, next_packet_write_pos;
+	struct list_head ready_playback_urbs;
+
+	unsigned int nurbs;		/* # urbs */
+	unsigned long active_mask;	/* bitmask of active urbs */
+	unsigned long unlink_mask;	/* bitmask of unlinked urbs */
+	char *syncbuf;			/* sync buffer for all sync URBs */
+	dma_addr_t sync_dma;		/* DMA address of syncbuf */
+
+	unsigned int pipe;		/* the data i/o pipe */
+	unsigned int freqn;		/* nominal sampling rate in fs/fps in Q16.16 format */
+	unsigned int freqm;		/* momentary sampling rate in fs/fps in Q16.16 format */
+	int	   freqshift;		/* how much to shift the feedback value to get Q16.16 */
+	unsigned int freqmax;		/* maximum sampling rate, used for buffer management */
+	unsigned int phase;		/* phase accumulator */
+	unsigned int maxpacksize;	/* max packet size in bytes */
+	unsigned int maxframesize;      /* max packet size in frames */
+	unsigned int curpacksize;	/* current packet size in bytes (for capture) */
+	unsigned int curframesize;      /* current packet size in frames (for capture) */
+	unsigned int syncmaxsize;	/* sync endpoint packet size */
+	unsigned int fill_max:1;	/* fill max packet size always */
+	unsigned int datainterval;      /* log_2 of data packet interval */
+	unsigned int syncinterval;	/* P for adaptive mode, 0 otherwise */
+	unsigned char silence_value;
+	unsigned int stride;
+	int iface, alt_idx;
+
+	spinlock_t lock;
+	struct list_head list;
+};
+
 struct snd_usb_substream {
 	struct snd_usb_stream *stream;
 	struct usb_device *dev;

commit 8866f405efd4171f9d9c91901d2dd02f01bacb60
Author: Xi Wang <xi.wang@gmail.com>
Date:   Tue Feb 14 05:18:48 2012 -0500

    ALSA: usb-audio: avoid integer overflow in create_fixed_stream_quirk()
    
    A malicious USB device could feed in a large nr_rates value.  This would
    cause the subsequent call to kmemdup() to allocate a smaller buffer than
    expected, leading to out-of-bounds access.
    
    This patch validates the nr_rates value and reuses the limit introduced
    in commit 4fa0e81b ("ALSA: usb-audio: fix possible hang and overflow
    in parse_uac2_sample_rate_range()").
    
    Signed-off-by: Xi Wang <xi.wang@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index a39edcc32a93..da5fa1ac4eda 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -1,6 +1,7 @@
 #ifndef __USBAUDIO_CARD_H
 #define __USBAUDIO_CARD_H
 
+#define MAX_NR_RATES	1024
 #define MAX_PACKS	20
 #define MAX_PACKS_HS	(MAX_PACKS * 8)	/* in high speed mode */
 #define MAX_URBS	8

commit 294c4fb8ab01728358836f478bcc1174ba7fb9d8
Author: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Date:   Tue Sep 6 19:15:34 2011 -0500

    ALSA: usb: refine delay information with USB frame counter
    
    Existing code only updates the audio delay when URBs were
    submitted/retired. This can introduce an uncertainty of 8ms
    on the number of samples played out with the default settings,
    and a lot more when URBs convey more packets to reduce the
    interrupt rate and power consumption.
    
    This patch relies on the USB frame counter to reduce the
    uncertainty to less than 2ms worst-case. The delay information
    essentially becomes independent of the URB size and number of
    packets. This should help applications like PulseAudio which
    require accurate audio timing. Clemens Ladisch reported
    a decrease of mplayer's A-V difference from nrpacks down to at
    most 1ms.
    
    Thanks to Clemens for also pointing out that the implementation
    of frame counters varies between different HCDs. Only the
    8 lowest-bits are used to estimate the delay.
    
    Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
    [clemens: changed debug code]
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index ae4251d5abf7..a39edcc32a93 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -94,6 +94,8 @@ struct snd_usb_substream {
 	spinlock_t lock;
 
 	struct snd_urb_ops ops;		/* callbacks (must be filled at init) */
+	int last_frame_number;          /* stored frame number */
+	int last_delay;                 /* stored delay */
 };
 
 struct snd_usb_stream {

commit 89e1e66d6be8a520cdcd26043cda2cc870a34015
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Oct 26 17:14:41 2010 +0200

    ALSA: usb-audio: automatically detect feedback format
    
    There are two USB Audio Class specifications (v1 and v2), but neither of
    them clearly defines the feedback format for high-speed UAC v1 devices.
    Add to this whatever the Creative and M-Audio firmware writers have been
    smoking, and it becomes impossible to predict the exact feedback format
    used by a particular device.
    
    Therefore, automatically detect the feedback format by looking at the
    magnitude of the first received feedback value.
    
    Also, this allows us to get rid of some special cases for E-Mu devices.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 1febf2f23754..ae4251d5abf7 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -62,12 +62,14 @@ struct snd_usb_substream {
 	unsigned int syncinterval;  /* P for adaptive mode, 0 otherwise */
 	unsigned int freqn;      /* nominal sampling rate in fs/fps in Q16.16 format */
 	unsigned int freqm;      /* momentary sampling rate in fs/fps in Q16.16 format */
+	int          freqshift;  /* how much to shift the feedback value to get Q16.16 */
 	unsigned int freqmax;    /* maximum sampling rate, used for buffer management */
 	unsigned int phase;      /* phase accumulator */
 	unsigned int maxpacksize;	/* max packet size in bytes */
 	unsigned int maxframesize;	/* max packet size in frames */
 	unsigned int curpacksize;	/* current packet size in bytes (for capture) */
 	unsigned int curframesize;	/* current packet size in frames (for capture) */
+	unsigned int syncmaxsize;	/* sync endpoint packet size */
 	unsigned int fill_max: 1;	/* fill max packet size always */
 	unsigned int txfr_quirk:1;	/* allow sub-frame alignment */
 	unsigned int fmt_type;		/* USB audio format type (1-3) */

commit 79f920fbff566ffc9de44111eb1456a3cef310f0
Author: Daniel Mack <daniel@caiaq.de>
Date:   Mon May 31 14:51:31 2010 +0200

    ALSA: usb-audio: parse clock topology of UAC2 devices
    
    Audio devices which comply to the UAC2 standard can export complex clock
    topologies in its descriptors and set up links between them.
    
    The entities that are defined are
    
     - clock sources, which define the end-leafs.
     - clock selectors, which act as switch to select one out of many
       possible clocks sources.
     - clock multipliers, which have an input clock source, and act as clock
       source again. They can be used to derive one clock from another.
    
    All sample rate changes, clock validity queries and the like must go to
    clock source elements, while clock selectors and multipliers can be used
    as terminal clock source.
    
    The following patch adds a parser for these elements and functions to
    iterate over the tree and find the leaf nodes (clock sources).
    
    The samplerate set functions were moved to the new clock.c file.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index ed92420c1095..1febf2f23754 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -25,6 +25,7 @@ struct audioformat {
 	unsigned int rate_min, rate_max;	/* min/max rates */
 	unsigned int nr_rates;		/* number of rate table entries */
 	unsigned int *rate_table;	/* rate table */
+	unsigned char clock;		/* associated clock */
 };
 
 struct snd_usb_substream;

commit 015eb0b08150c6fef843efe22609589ead3d4fb8
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Mar 4 19:46:15 2010 +0100

    ALSA: usb-audio: use a format bitmask per alternate setting
    
    In preparation for USB audio 2.0 support, change the audioformat
    structure so that it uses a bitmask to specify possible formats.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 856d71b7407d..ed92420c1095 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -9,7 +9,7 @@
 
 struct audioformat {
 	struct list_head list;
-	snd_pcm_format_t format;	/* format type */
+	u64 formats;			/* ALSA format bits */
 	unsigned int channels;		/* # channels */
 	unsigned int fmt_type;		/* USB audio format type (1-3) */
 	unsigned int frame_size;	/* samples per frame for non-audio */

commit e11b4e0e4f5ab40ec342dc07b7201c09a45f9574
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Mar 4 19:46:14 2010 +0100

    ALSA: usb-audio: rename substream format field to altset_idx
    
    The snd_usb_substream::format field actually contains the index of the
    current alternate setting, so rename it to altset_idx to avoid
    confusion.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
index 71f03c151030..856d71b7407d 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -54,7 +54,7 @@ struct snd_usb_substream {
 	struct audioformat *cur_audiofmt;	/* current audioformat pointer (for hw_params callback) */
 	unsigned int cur_rate;		/* current rate (for hw_params callback) */
 	unsigned int period_bytes;	/* current period bytes (for hw_params callback) */
-	unsigned int format;     /* USB data format */
+	unsigned int altset_idx;     /* USB data format: index of alternate setting */
 	unsigned int datapipe;   /* the data i/o pipe */
 	unsigned int syncpipe;   /* 1 - async out or adaptive in */
 	unsigned int datainterval;	/* log_2 of data packet interval */

commit e5779998bf8b70e48a6cc208c8b61b33bd6117ea
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Mar 4 19:46:13 2010 +0100

    ALSA: usb-audio: refactor code
    
    Clean up the usb audio driver by factoring out a lot of functions to
    separate files. Code for procfs, quirks, urbs, format parsers etc all
    got a new home now.
    
    Moved almost all special quirk handling to quirks.c and introduced new
    generic functions to handle them, so the exceptions do not pollute the
    whole driver.
    
    Renamed usbaudio.c to card.c because this is what it actually does now.
    Renamed usbmidi.c to midi.c for namespace clarity.
    Removed more things from usbaudio.h.
    
    The non-standard drivers were adopted accordingly.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/card.h b/sound/usb/card.h
new file mode 100644
index 000000000000..71f03c151030
--- /dev/null
+++ b/sound/usb/card.h
@@ -0,0 +1,105 @@
+#ifndef __USBAUDIO_CARD_H
+#define __USBAUDIO_CARD_H
+
+#define MAX_PACKS	20
+#define MAX_PACKS_HS	(MAX_PACKS * 8)	/* in high speed mode */
+#define MAX_URBS	8
+#define SYNC_URBS	4	/* always four urbs for sync */
+#define MAX_QUEUE	24	/* try not to exceed this queue length, in ms */
+
+struct audioformat {
+	struct list_head list;
+	snd_pcm_format_t format;	/* format type */
+	unsigned int channels;		/* # channels */
+	unsigned int fmt_type;		/* USB audio format type (1-3) */
+	unsigned int frame_size;	/* samples per frame for non-audio */
+	int iface;			/* interface number */
+	unsigned char altsetting;	/* corresponding alternate setting */
+	unsigned char altset_idx;	/* array index of altenate setting */
+	unsigned char attributes;	/* corresponding attributes of cs endpoint */
+	unsigned char endpoint;		/* endpoint */
+	unsigned char ep_attr;		/* endpoint attributes */
+	unsigned char datainterval;	/* log_2 of data packet interval */
+	unsigned int maxpacksize;	/* max. packet size */
+	unsigned int rates;		/* rate bitmasks */
+	unsigned int rate_min, rate_max;	/* min/max rates */
+	unsigned int nr_rates;		/* number of rate table entries */
+	unsigned int *rate_table;	/* rate table */
+};
+
+struct snd_usb_substream;
+
+struct snd_urb_ctx {
+	struct urb *urb;
+	unsigned int buffer_size;	/* size of data buffer, if data URB */
+	struct snd_usb_substream *subs;
+	int index;	/* index for urb array */
+	int packets;	/* number of packets per urb */
+};
+
+struct snd_urb_ops {
+	int (*prepare)(struct snd_usb_substream *subs, struct snd_pcm_runtime *runtime, struct urb *u);
+	int (*retire)(struct snd_usb_substream *subs, struct snd_pcm_runtime *runtime, struct urb *u);
+	int (*prepare_sync)(struct snd_usb_substream *subs, struct snd_pcm_runtime *runtime, struct urb *u);
+	int (*retire_sync)(struct snd_usb_substream *subs, struct snd_pcm_runtime *runtime, struct urb *u);
+};
+
+struct snd_usb_substream {
+	struct snd_usb_stream *stream;
+	struct usb_device *dev;
+	struct snd_pcm_substream *pcm_substream;
+	int direction;	/* playback or capture */
+	int interface;	/* current interface */
+	int endpoint;	/* assigned endpoint */
+	struct audioformat *cur_audiofmt;	/* current audioformat pointer (for hw_params callback) */
+	unsigned int cur_rate;		/* current rate (for hw_params callback) */
+	unsigned int period_bytes;	/* current period bytes (for hw_params callback) */
+	unsigned int format;     /* USB data format */
+	unsigned int datapipe;   /* the data i/o pipe */
+	unsigned int syncpipe;   /* 1 - async out or adaptive in */
+	unsigned int datainterval;	/* log_2 of data packet interval */
+	unsigned int syncinterval;  /* P for adaptive mode, 0 otherwise */
+	unsigned int freqn;      /* nominal sampling rate in fs/fps in Q16.16 format */
+	unsigned int freqm;      /* momentary sampling rate in fs/fps in Q16.16 format */
+	unsigned int freqmax;    /* maximum sampling rate, used for buffer management */
+	unsigned int phase;      /* phase accumulator */
+	unsigned int maxpacksize;	/* max packet size in bytes */
+	unsigned int maxframesize;	/* max packet size in frames */
+	unsigned int curpacksize;	/* current packet size in bytes (for capture) */
+	unsigned int curframesize;	/* current packet size in frames (for capture) */
+	unsigned int fill_max: 1;	/* fill max packet size always */
+	unsigned int txfr_quirk:1;	/* allow sub-frame alignment */
+	unsigned int fmt_type;		/* USB audio format type (1-3) */
+
+	unsigned int running: 1;	/* running status */
+
+	unsigned int hwptr_done;	/* processed byte position in the buffer */
+	unsigned int transfer_done;		/* processed frames since last period update */
+	unsigned long active_mask;	/* bitmask of active urbs */
+	unsigned long unlink_mask;	/* bitmask of unlinked urbs */
+
+	unsigned int nurbs;			/* # urbs */
+	struct snd_urb_ctx dataurb[MAX_URBS];	/* data urb table */
+	struct snd_urb_ctx syncurb[SYNC_URBS];	/* sync urb table */
+	char *syncbuf;				/* sync buffer for all sync URBs */
+	dma_addr_t sync_dma;			/* DMA address of syncbuf */
+
+	u64 formats;			/* format bitmasks (all or'ed) */
+	unsigned int num_formats;		/* number of supported audio formats (list) */
+	struct list_head fmt_list;	/* format list */
+	struct snd_pcm_hw_constraint_list rate_list;	/* limited rates */
+	spinlock_t lock;
+
+	struct snd_urb_ops ops;		/* callbacks (must be filled at init) */
+};
+
+struct snd_usb_stream {
+	struct snd_usb_audio *chip;
+	struct snd_pcm *pcm;
+	int pcm_index;
+	unsigned int fmt_type;		/* USB audio format type (1-3) */
+	struct snd_usb_substream substream[2];
+	struct list_head list;
+};
+
+#endif /* __USBAUDIO_CARD_H */
