commit a10e763b87134a9a4ca3a38b5c4b533e75ec63a3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 31 01:09:32 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 372
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 135 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531081036.435762997@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index bb0c9cbf2a78..9c683042ff06 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Line 6 Linux USB driver
  *
  * Copyright (C) 2004-2010 Markus Grabner (grabner@icg.tugraz.at)
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License as
- *	published by the Free Software Foundation, version 2.
- *
  */
 
 /*

commit f56742cc41895b1ed3742406dc3587b0d6424acb
Author: Andrej Krutak <dev@andree.sk>
Date:   Sun Sep 18 20:59:25 2016 +0200

    ALSA: line6: Add LINE6_CAP_IN_NEEDS_OUT, a void playback stream during capture
    
    E.g. POD X3 seems to require playback data to be sent to it to generate
    capture data. Otherwise the device stalls and doesn't send any more capture
    data until it's reset.
    
    Signed-off-by: Andrej Krutak <dev@andree.sk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index 67fda315aa89..bb0c9cbf2a78 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -73,6 +73,7 @@ enum {
 	LINE6_STREAM_PCM,
 	LINE6_STREAM_MONITOR,
 	LINE6_STREAM_IMPULSE,
+	LINE6_STREAM_CAPTURE_HELPER,
 };
 
 /* misc bit flags for PCM operation */
@@ -191,7 +192,8 @@ extern int snd_line6_hw_params(struct snd_pcm_substream *substream,
 extern int snd_line6_hw_free(struct snd_pcm_substream *substream);
 extern snd_pcm_uframes_t snd_line6_pointer(struct snd_pcm_substream *substream);
 extern void line6_pcm_disconnect(struct snd_line6_pcm *line6pcm);
-extern int line6_pcm_acquire(struct snd_line6_pcm *line6pcm, int type);
+extern int line6_pcm_acquire(struct snd_line6_pcm *line6pcm, int type,
+			       bool start);
 extern void line6_pcm_release(struct snd_line6_pcm *line6pcm, int type);
 
 #endif

commit 97d78acfb870a67339957e9c4d36dc03242df315
Author: Andrej Krutak <dev@andree.sk>
Date:   Sun Sep 18 20:59:24 2016 +0200

    ALSA: line6: Allow different channel numbers for in/out
    
    Changes bytes_per_frame to bytes_per_channel.
    
    Signed-off-by: Andrej Krutak <dev@andree.sk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index f040c81a4843..67fda315aa89 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -84,7 +84,7 @@ enum {
 struct line6_pcm_properties {
 	struct snd_pcm_hardware playback_hw, capture_hw;
 	struct snd_pcm_hw_constraint_ratdens rates;
-	int bytes_per_frame;
+	int bytes_per_channel;
 };
 
 struct line6_pcm_stream {

commit 7a0f55aeeb8f1fa32a119d34ddfefc6100936692
Author: Andrej Krutak <dev@andree.sk>
Date:   Sun Sep 18 20:59:23 2016 +0200

    ALSA: line6: Support assymetrical in/out configurations
    
    Splits max_packet_size to max_packet_size_in/out (e.g. for
    different channel counts).
    
    Signed-off-by: Andrej Krutak <dev@andree.sk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index f41e34166d68..f040c81a4843 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -156,11 +156,12 @@ struct snd_line6_pcm {
 	/* Previously captured frame (for software monitoring) */
 	unsigned char *prev_fbuf;
 
-	/* Size of previously captured frame (for software monitoring) */
+	/* Size of previously captured frame (for software monitoring/sync) */
 	int prev_fsize;
 
 	/* Maximum size of USB packet */
-	int max_packet_size;
+	int max_packet_size_in;
+	int max_packet_size_out;
 
 	/* PCM playback volume (left and right) */
 	int volume_playback[2];

commit 79faa2b048b23f28a24a7b232d8933cb53df95b7
Author: Andrej Krutak <dev@andree.sk>
Date:   Sun Sep 18 20:59:22 2016 +0200

    ALSA: line6: Add high-speed USB support
    
    This has two parts:
    * intervals_per_second setup
      (high speed needs 8000, instead of 1000)
    * iso_buffers setup (count of iso buffers depends on
      USB speed, 2 is not enough for high speed)
    
    Signed-off-by: Andrej Krutak <dev@andree.sk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index e983880703ea..f41e34166d68 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -20,9 +20,6 @@
 
 #include "driver.h"
 
-/* number of URBs */
-#define LINE6_ISO_BUFFERS	2
-
 /*
 	number of USB frames per URB
 	The Line 6 Windows driver always transmits two frames per packet, but
@@ -31,7 +28,9 @@
 */
 #define LINE6_ISO_PACKETS	1
 
-/* in a "full speed" device (such as the PODxt Pro) this means 1ms */
+/* in a "full speed" device (such as the PODxt Pro) this means 1ms,
+ *  for "high speed" it's 1/8ms
+ */
 #define LINE6_ISO_INTERVAL	1
 
 #define LINE6_IMPULSE_DEFAULT_PERIOD 100

commit b2233d97a0e64aa1f0557ffb409c957748ae7f3a
Author: Andrej Krutak <dev@andree.sk>
Date:   Sun Sep 18 20:59:21 2016 +0200

    ALSA: line6: Enable different number of URBs for frame transfers
    
    This basically changes LINE6_ISO_BUFFERS constant to a configurable
    iso_buffers property.
    
    Signed-off-by: Andrej Krutak <dev@andree.sk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index 508410adbd51..e983880703ea 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -90,7 +90,7 @@ struct line6_pcm_properties {
 
 struct line6_pcm_stream {
 	/* allocated URBs */
-	struct urb *urbs[LINE6_ISO_BUFFERS];
+	struct urb **urbs;
 
 	/* Temporary buffer;
 	 * Since the packet size is not known in advance, this buffer is

commit 1263f61179821df60cca4bccdb69e2f71fdebaa7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 15:08:59 2015 +0100

    ALSA: line6: Remove snd_line6_ prefix of pcm property fields
    
    It's just superfluous and doesn't give any better readability.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index 3a3cfba40ec7..508410adbd51 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -83,8 +83,8 @@ enum {
 };
 
 struct line6_pcm_properties {
-	struct snd_pcm_hardware snd_line6_playback_hw, snd_line6_capture_hw;
-	struct snd_pcm_hw_constraint_ratdens snd_line6_rates;
+	struct snd_pcm_hardware playback_hw, capture_hw;
+	struct snd_pcm_hw_constraint_ratdens rates;
 	int bytes_per_frame;
 };
 

commit 129b3be6895c01e137dbb88c699f9f706bdc6c9d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 14:50:08 2015 +0100

    ALSA: line6: Move the contents of usbdefs.h into driver.h
    
    Most of them are rather relevant with the definitions in driver.h,
    and there are only a few lines, so just rip it off.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index 19c12f0a9008..3a3cfba40ec7 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -19,7 +19,6 @@
 #include <sound/pcm.h>
 
 #include "driver.h"
-#include "usbdefs.h"
 
 /* number of URBs */
 #define LINE6_ISO_BUFFERS	2

commit cddbd4f17078530b4914a42f6d7f3e543b5fad0e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 14:43:11 2015 +0100

    ALSA: line6: Tidy up and typo fixes in comments
    
    Just reformatting the comments and typos fixed, no functional
    changes.  Particularly,
    - avoid the kerneldoc marker "/**",
    - reduce multiple comment lines into single lines,
    - corrected wrongly referred function names
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index 42d3e6fc2c61..19c12f0a9008 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -66,8 +66,8 @@
 	the running flag indicates whether the stream is running.
 
 	For monitor or impulse operations, the driver needs to call
-	snd_line6_duplex_acquire() or snd_line6_duplex_release() with the
-	appropriate LINE6_STREAM_* flag.
+	line6_pcm_acquire() or line6_pcm_release() with the appropriate
+	LINE6_STREAM_* flag.
 */
 
 /* stream types */
@@ -139,19 +139,13 @@ struct line6_pcm_stream {
 };
 
 struct snd_line6_pcm {
-	/**
-		 Pointer back to the Line 6 driver data structure.
-	*/
+	/* Pointer back to the Line 6 driver data structure */
 	struct usb_line6 *line6;
 
-	/**
-		 Properties.
-	*/
+	/* Properties. */
 	struct line6_pcm_properties *properties;
 
-	/**
-		 ALSA pcm stream
-	*/
+	/* ALSA pcm stream */
 	struct snd_pcm *pcm;
 
 	/* protection to state changes of in/out streams */
@@ -161,49 +155,31 @@ struct snd_line6_pcm {
 	struct line6_pcm_stream in;
 	struct line6_pcm_stream out;
 
-	/**
-		 Previously captured frame (for software monitoring).
-	*/
+	/* Previously captured frame (for software monitoring) */
 	unsigned char *prev_fbuf;
 
-	/**
-		 Size of previously captured frame (for software monitoring).
-	*/
+	/* Size of previously captured frame (for software monitoring) */
 	int prev_fsize;
 
-	/**
-		 Maximum size of USB packet.
-	*/
+	/* Maximum size of USB packet */
 	int max_packet_size;
 
-	/**
-		 PCM playback volume (left and right).
-	*/
+	/* PCM playback volume (left and right) */
 	int volume_playback[2];
 
-	/**
-		 PCM monitor volume.
-	*/
+	/* PCM monitor volume */
 	int volume_monitor;
 
-	/**
-		 Volume of impulse response test signal (if zero, test is disabled).
-	*/
+	/* Volume of impulse response test signal (if zero, test is disabled) */
 	int impulse_volume;
 
-	/**
-		 Period of impulse response test signal.
-	*/
+	/* Period of impulse response test signal */
 	int impulse_period;
 
-	/**
-		 Counter for impulse response test signal.
-	*/
+	/* Counter for impulse response test signal */
 	int impulse_count;
 
-	/**
-		 Several status bits (see LINE6_FLAG_*).
-	*/
+	/* Several status bits (see LINE6_FLAG_*) */
 	unsigned long flags;
 };
 

commit 2954f914f2816738b800be7909b771f30bf6a856
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 27 15:41:27 2015 +0100

    ALSA: line6: Make common PCM pointer callback
    
    Both playback and capture callbacks are identical, so let's merge
    them.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index 66f603dfa34e..42d3e6fc2c61 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -214,6 +214,7 @@ extern int snd_line6_prepare(struct snd_pcm_substream *substream);
 extern int snd_line6_hw_params(struct snd_pcm_substream *substream,
 			       struct snd_pcm_hw_params *hw_params);
 extern int snd_line6_hw_free(struct snd_pcm_substream *substream);
+extern snd_pcm_uframes_t snd_line6_pointer(struct snd_pcm_substream *substream);
 extern void line6_pcm_disconnect(struct snd_line6_pcm *line6pcm);
 extern int line6_pcm_acquire(struct snd_line6_pcm *line6pcm, int type);
 extern void line6_pcm_release(struct snd_line6_pcm *line6pcm, int type);

commit 63e20df1e5b2ef8d871ecbdb6c038d554ed1ca74
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 27 15:24:09 2015 +0100

    ALSA: line6: Reorganize PCM stream handling
    
    The current code deals with the stream start / stop solely via
    line6_pcm_acquire() and line6_pcm_release().  This was (supposedly)
    intended to avoid the races, but it doesn't work as expected.  The
    concurrent acquire and release calls can be performed without proper
    protections, thus this might result in memory corruption.
    Furthermore, we can't take a mutex to protect the whole function
    because it can be called from the PCM trigger callback that is an
    atomic context.  Also spinlock isn't appropriate because the function
    allocates with kmalloc with GFP_KERNEL.  That is, these function just
    lead to singular problems.
    
    This is an attempt to reduce the existing races.  First off, separate
    both the stream buffer management and the stream URB management.  The
    former is protected via a newly introduced state_mutex while the
    latter is protected via each line6_pcm_stream lock.
    
    Secondly, the stream state are now managed in opened and running bit
    flags of each line6_pcm_stream.  Not only this a bit clearer than
    previous combined bit flags, this also gives a better abstraction.
    These rewrites allows us to make common hw_params and hw_free
    callbacks for both playback and capture directions.
    
    For the monitor and impulse operations, still line6_pcm_acquire() and
    line6_pcm_release() are used.  They call internally the corresponding
    functions for both playback and capture streams with proper lock or
    mutex.  Unlike the previous versions, these function don't take the
    bit masks but the only single type value.  Also they are supposed to
    be applied only as duplex operations.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index 4c74f4e85074..66f603dfa34e 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -54,109 +54,33 @@
 	However, from the device's point of view, there is just a single
 	capture and playback stream, which must be shared between these
 	subsystems. It is therefore necessary to maintain the state of the
-	subsystems with respect to PCM usage. We define several constants of
-	the form LINE6_BIT_PCM_<subsystem>_<direction>_<resource> with the
-	following meanings:
-	*) <subsystem> is one of
-	-) ALSA: PCM playback and capture via ALSA
-	-) MONITOR: software monitoring
-	-) IMPULSE: optional impulse response measurement
-	*) <direction> is one of
-	-) PLAYBACK: audio output (from host to device)
-	-) CAPTURE: audio input (from device to host)
-	*) <resource> is one of
-	-) BUFFER: buffer required by PCM data stream
-	-) STREAM: actual PCM data stream
-
-	The subsystems call line6_pcm_acquire() to acquire the (shared)
-	resources needed for a particular operation (e.g., allocate the buffer
-	for ALSA playback or start the capture stream for software monitoring).
-	When a resource is no longer needed, it is released by calling
-	line6_pcm_release(). Buffer allocation and stream startup are handled
-	separately to allow the ALSA kernel driver to perform them at
-	appropriate places (since the callback which starts a PCM stream is not
-	allowed to sleep).
+	subsystems with respect to PCM usage.
+
+	We define two bit flags, "opened" and "running", for each playback
+	or capture stream.  Both can contain the bit flag corresponding to
+	LINE6_STREAM_* type,
+	  LINE6_STREAM_PCM = ALSA PCM playback or capture
+	  LINE6_STREAM_MONITOR = software monitoring
+	  IMPULSE = optional impulse response measurement
+	The opened flag indicates whether the buffer is allocated while
+	the running flag indicates whether the stream is running.
+
+	For monitor or impulse operations, the driver needs to call
+	snd_line6_duplex_acquire() or snd_line6_duplex_release() with the
+	appropriate LINE6_STREAM_* flag.
 */
+
+/* stream types */
+enum {
+	LINE6_STREAM_PCM,
+	LINE6_STREAM_MONITOR,
+	LINE6_STREAM_IMPULSE,
+};
+
+/* misc bit flags for PCM operation */
 enum {
-	/* individual bit indices: */
-	LINE6_INDEX_PCM_ALSA_PLAYBACK_BUFFER,
-	LINE6_INDEX_PCM_ALSA_PLAYBACK_STREAM,
-	LINE6_INDEX_PCM_ALSA_CAPTURE_BUFFER,
-	LINE6_INDEX_PCM_ALSA_CAPTURE_STREAM,
-	LINE6_INDEX_PCM_MONITOR_PLAYBACK_BUFFER,
-	LINE6_INDEX_PCM_MONITOR_PLAYBACK_STREAM,
-	LINE6_INDEX_PCM_MONITOR_CAPTURE_BUFFER,
-	LINE6_INDEX_PCM_MONITOR_CAPTURE_STREAM,
-	LINE6_INDEX_PCM_IMPULSE_PLAYBACK_BUFFER,
-	LINE6_INDEX_PCM_IMPULSE_PLAYBACK_STREAM,
-	LINE6_INDEX_PCM_IMPULSE_CAPTURE_BUFFER,
-	LINE6_INDEX_PCM_IMPULSE_CAPTURE_STREAM,
-	LINE6_INDEX_PAUSE_PLAYBACK,
-	LINE6_INDEX_PREPARED,
-
-#define LINE6_BIT(x) LINE6_BIT_ ## x = 1 << LINE6_INDEX_ ## x
-
-	/* individual bit masks: */
-	LINE6_BIT(PCM_ALSA_PLAYBACK_BUFFER),
-	LINE6_BIT(PCM_ALSA_PLAYBACK_STREAM),
-	LINE6_BIT(PCM_ALSA_CAPTURE_BUFFER),
-	LINE6_BIT(PCM_ALSA_CAPTURE_STREAM),
-	LINE6_BIT(PCM_MONITOR_PLAYBACK_BUFFER),
-	LINE6_BIT(PCM_MONITOR_PLAYBACK_STREAM),
-	LINE6_BIT(PCM_MONITOR_CAPTURE_BUFFER),
-	LINE6_BIT(PCM_MONITOR_CAPTURE_STREAM),
-	LINE6_BIT(PCM_IMPULSE_PLAYBACK_BUFFER),
-	LINE6_BIT(PCM_IMPULSE_PLAYBACK_STREAM),
-	LINE6_BIT(PCM_IMPULSE_CAPTURE_BUFFER),
-	LINE6_BIT(PCM_IMPULSE_CAPTURE_STREAM),
-	LINE6_BIT(PAUSE_PLAYBACK),
-	LINE6_BIT(PREPARED),
-
-	/* combined bit masks (by operation): */
-	LINE6_BITS_PCM_ALSA_BUFFER =
-	    LINE6_BIT_PCM_ALSA_PLAYBACK_BUFFER |
-	    LINE6_BIT_PCM_ALSA_CAPTURE_BUFFER,
-
-	LINE6_BITS_PCM_ALSA_STREAM =
-	    LINE6_BIT_PCM_ALSA_PLAYBACK_STREAM |
-	    LINE6_BIT_PCM_ALSA_CAPTURE_STREAM,
-
-	LINE6_BITS_PCM_MONITOR =
-	    LINE6_BIT_PCM_MONITOR_PLAYBACK_BUFFER |
-	    LINE6_BIT_PCM_MONITOR_PLAYBACK_STREAM |
-	    LINE6_BIT_PCM_MONITOR_CAPTURE_BUFFER |
-	    LINE6_BIT_PCM_MONITOR_CAPTURE_STREAM,
-
-	LINE6_BITS_PCM_IMPULSE =
-	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_BUFFER |
-	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_STREAM |
-	    LINE6_BIT_PCM_IMPULSE_CAPTURE_BUFFER |
-	    LINE6_BIT_PCM_IMPULSE_CAPTURE_STREAM,
-
-	/* combined bit masks (by direction): */
-	LINE6_BITS_PLAYBACK_BUFFER =
-	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_BUFFER |
-	    LINE6_BIT_PCM_ALSA_PLAYBACK_BUFFER |
-	    LINE6_BIT_PCM_MONITOR_PLAYBACK_BUFFER,
-
-	LINE6_BITS_PLAYBACK_STREAM =
-	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_STREAM |
-	    LINE6_BIT_PCM_ALSA_PLAYBACK_STREAM |
-	    LINE6_BIT_PCM_MONITOR_PLAYBACK_STREAM,
-
-	LINE6_BITS_CAPTURE_BUFFER =
-	    LINE6_BIT_PCM_IMPULSE_CAPTURE_BUFFER |
-	    LINE6_BIT_PCM_ALSA_CAPTURE_BUFFER |
-	    LINE6_BIT_PCM_MONITOR_CAPTURE_BUFFER,
-
-	LINE6_BITS_CAPTURE_STREAM =
-	    LINE6_BIT_PCM_IMPULSE_CAPTURE_STREAM |
-	    LINE6_BIT_PCM_ALSA_CAPTURE_STREAM |
-	    LINE6_BIT_PCM_MONITOR_CAPTURE_STREAM,
-
-	LINE6_BITS_STREAM =
-	    LINE6_BITS_PLAYBACK_STREAM |
-	    LINE6_BITS_CAPTURE_STREAM
+	LINE6_FLAG_PAUSE_PLAYBACK,
+	LINE6_FLAG_PREPARED,
 };
 
 struct line6_pcm_properties {
@@ -205,6 +129,12 @@ struct line6_pcm_stream {
 	 */
 	spinlock_t lock;
 
+	/* Bit flags for operational stream types */
+	unsigned long opened;
+
+	/* Bit flags for running stream types */
+	unsigned long running;
+
 	int last_frame;
 };
 
@@ -224,6 +154,9 @@ struct snd_line6_pcm {
 	*/
 	struct snd_pcm *pcm;
 
+	/* protection to state changes of in/out streams */
+	struct mutex state_mutex;
+
 	/* Capture and playback streams */
 	struct line6_pcm_stream in;
 	struct line6_pcm_stream out;
@@ -269,7 +202,7 @@ struct snd_line6_pcm {
 	int impulse_count;
 
 	/**
-		 Several status bits (see LINE6_BIT_*).
+		 Several status bits (see LINE6_FLAG_*).
 	*/
 	unsigned long flags;
 };
@@ -278,8 +211,11 @@ extern int line6_init_pcm(struct usb_line6 *line6,
 			  struct line6_pcm_properties *properties);
 extern int snd_line6_trigger(struct snd_pcm_substream *substream, int cmd);
 extern int snd_line6_prepare(struct snd_pcm_substream *substream);
+extern int snd_line6_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *hw_params);
+extern int snd_line6_hw_free(struct snd_pcm_substream *substream);
 extern void line6_pcm_disconnect(struct snd_line6_pcm *line6pcm);
-extern int line6_pcm_acquire(struct snd_line6_pcm *line6pcm, int channels);
-extern int line6_pcm_release(struct snd_line6_pcm *line6pcm, int channels);
+extern int line6_pcm_acquire(struct snd_line6_pcm *line6pcm, int type);
+extern void line6_pcm_release(struct snd_line6_pcm *line6pcm, int type);
 
 #endif

commit ad0119abe29fe3d506486a789de4c4619fa7602c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 23 16:10:57 2015 +0100

    ALSA: line6: Rearrange PCM structure
    
    Introduce a new line6_pcm_stream structure and group individual
    fields of snd_line6_pcm struct to playback and capture groups.
    
    This patch itself just does rename and nothing else.  More
    meaningful cleanups based on these fields shuffling will follow.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index a84753ee0fa2..4c74f4e85074 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -165,148 +165,84 @@ struct line6_pcm_properties {
 	int bytes_per_frame;
 };
 
-struct snd_line6_pcm {
-	/**
-		 Pointer back to the Line 6 driver data structure.
-	*/
-	struct usb_line6 *line6;
+struct line6_pcm_stream {
+	/* allocated URBs */
+	struct urb *urbs[LINE6_ISO_BUFFERS];
 
-	/**
-		 Properties.
-	*/
-	struct line6_pcm_properties *properties;
+	/* Temporary buffer;
+	 * Since the packet size is not known in advance, this buffer is
+	 * large enough to store maximum size packets.
+	 */
+	unsigned char *buffer;
 
-	/**
-		 ALSA pcm stream
-	*/
-	struct snd_pcm *pcm;
+	/* Free frame position in the buffer. */
+	snd_pcm_uframes_t pos;
 
-	/**
-		 URBs for audio playback.
-	*/
-	struct urb *urb_audio_out[LINE6_ISO_BUFFERS];
+	/* Count processed bytes;
+	 * This is modulo period size (to determine when a period is finished).
+	 */
+	unsigned bytes;
 
-	/**
-		 URBs for audio capture.
-	*/
-	struct urb *urb_audio_in[LINE6_ISO_BUFFERS];
+	/* Counter to create desired sample rate */
+	unsigned count;
 
-	/**
-		 Temporary buffer for playback.
-		 Since the packet size is not known in advance, this buffer is
-		 large enough to store maximum size packets.
-	*/
-	unsigned char *buffer_out;
+	/* period size in bytes */
+	unsigned period;
 
-	/**
-		 Temporary buffer for capture.
-		 Since the packet size is not known in advance, this buffer is
-		 large enough to store maximum size packets.
-	*/
-	unsigned char *buffer_in;
+	/* Processed frame position in the buffer;
+	 * The contents of the ring buffer have been consumed by the USB
+	 * subsystem (i.e., sent to the USB device) up to this position.
+	 */
+	snd_pcm_uframes_t pos_done;
 
-	/**
-		 Previously captured frame (for software monitoring).
-	*/
-	unsigned char *prev_fbuf;
+	/* Bit mask of active URBs */
+	unsigned long active_urbs;
 
-	/**
-		 Size of previously captured frame (for software monitoring).
-	*/
-	int prev_fsize;
-
-	/**
-		 Free frame position in the playback buffer.
-	*/
-	snd_pcm_uframes_t pos_out;
+	/* Bit mask of URBs currently being unlinked */
+	unsigned long unlink_urbs;
 
-	/**
-		 Count processed bytes for playback.
-		 This is modulo period size (to determine when a period is
-		 finished).
-	*/
-	unsigned bytes_out;
+	/* Spin lock to protect updates of the buffer positions (not contents)
+	 */
+	spinlock_t lock;
 
-	/**
-		 Counter to create desired playback sample rate.
-	*/
-	unsigned count_out;
-
-	/**
-		 Playback period size in bytes
-	*/
-	unsigned period_out;
+	int last_frame;
+};
 
+struct snd_line6_pcm {
 	/**
-		 Processed frame position in the playback buffer.
-		 The contents of the output ring buffer have been consumed by
-		 the USB subsystem (i.e., sent to the USB device) up to this
-		 position.
+		 Pointer back to the Line 6 driver data structure.
 	*/
-	snd_pcm_uframes_t pos_out_done;
+	struct usb_line6 *line6;
 
 	/**
-		 Count processed bytes for capture.
-		 This is modulo period size (to determine when a period is
-		 finished).
+		 Properties.
 	*/
-	unsigned bytes_in;
+	struct line6_pcm_properties *properties;
 
 	/**
-		 Counter to create desired capture sample rate.
+		 ALSA pcm stream
 	*/
-	unsigned count_in;
+	struct snd_pcm *pcm;
 
-	/**
-		 Capture period size in bytes
-	*/
-	unsigned period_in;
+	/* Capture and playback streams */
+	struct line6_pcm_stream in;
+	struct line6_pcm_stream out;
 
 	/**
-		 Processed frame position in the capture buffer.
-		 The contents of the output ring buffer have been consumed by
-		 the USB subsystem (i.e., sent to the USB device) up to this
-		 position.
+		 Previously captured frame (for software monitoring).
 	*/
-	snd_pcm_uframes_t pos_in_done;
+	unsigned char *prev_fbuf;
 
 	/**
-		 Bit mask of active playback URBs.
+		 Size of previously captured frame (for software monitoring).
 	*/
-	unsigned long active_urb_out;
+	int prev_fsize;
 
 	/**
 		 Maximum size of USB packet.
 	*/
 	int max_packet_size;
 
-	/**
-		 Bit mask of active capture URBs.
-	*/
-	unsigned long active_urb_in;
-
-	/**
-		 Bit mask of playback URBs currently being unlinked.
-	*/
-	unsigned long unlink_urb_out;
-
-	/**
-		 Bit mask of capture URBs currently being unlinked.
-	*/
-	unsigned long unlink_urb_in;
-
-	/**
-		 Spin lock to protect updates of the playback buffer positions (not
-		 contents!)
-	*/
-	spinlock_t lock_audio_out;
-
-	/**
-		 Spin lock to protect updates of the capture buffer positions (not
-		 contents!)
-	*/
-	spinlock_t lock_audio_in;
-
 	/**
 		 PCM playback volume (left and right).
 	*/
@@ -336,8 +272,6 @@ struct snd_line6_pcm {
 		 Several status bits (see LINE6_BIT_*).
 	*/
 	unsigned long flags;
-
-	int last_frame_in, last_frame_out;
 };
 
 extern int line6_init_pcm(struct usb_line6 *line6,

commit f2a76225b962f00642002fb109aee2e5b0dc4259
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 23 14:49:22 2015 +0100

    ALSA: line6: Drop superfluous spinlock for trigger
    
    The trigger callback is already spinlocked, so we need no more lock
    here (even for the linked substreams).  Let's drop it.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index c742b33666eb..a84753ee0fa2 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -307,11 +307,6 @@ struct snd_line6_pcm {
 	*/
 	spinlock_t lock_audio_in;
 
-	/**
-		 Spin lock to protect trigger.
-	*/
-	spinlock_t lock_trigger;
-
 	/**
 		 PCM playback volume (left and right).
 	*/

commit c078a4aac2944cb9cac5cdb4e9a482623435578b
Author: Chris Rorvick <chris@rorvick.com>
Date:   Tue Jan 20 02:20:50 2015 -0600

    ALSA: line6: Remove driver version from header comment
    
    The driver version string was removed in an ealier commit for being
    useless.  These are equally useless.
    
    Signed-off-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index 715e84b3057c..c742b33666eb 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -1,5 +1,5 @@
 /*
- * Line 6 Linux USB driver - 0.9.1beta
+ * Line 6 Linux USB driver
  *
  * Copyright (C) 2004-2010 Markus Grabner (grabner@icg.tugraz.at)
  *

commit c6fffce92e1a8cda8c1b552f5a24295839f3f93a
Author: Chris Rorvick <chris@rorvick.com>
Date:   Tue Jan 20 02:20:49 2015 -0600

    ALSA: line6: Refer to manufacturer as "Line 6"
    
    The correct spelling includes the space.  Fix this in strings and
    comments that refer to the manufacturer.
    
    Signed-off-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index 9328e6ffb191..715e84b3057c 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -1,5 +1,5 @@
 /*
- * Line6 Linux USB driver - 0.9.1beta
+ * Line 6 Linux USB driver - 0.9.1beta
  *
  * Copyright (C) 2004-2010 Markus Grabner (grabner@icg.tugraz.at)
  *
@@ -26,7 +26,7 @@
 
 /*
 	number of USB frames per URB
-	The Line6 Windows driver always transmits two frames per packet, but
+	The Line 6 Windows driver always transmits two frames per packet, but
 	the Linux driver performs significantly better (i.e., lower latency)
 	with only one frame per packet.
 */
@@ -38,7 +38,7 @@
 #define LINE6_IMPULSE_DEFAULT_PERIOD 100
 
 /*
-	Get substream from Line6 PCM data structure
+	Get substream from Line 6 PCM data structure
 */
 #define get_substream(line6pcm, stream)	\
 		(line6pcm->pcm->streams[stream].substream)
@@ -46,7 +46,7 @@
 /*
 	PCM mode bits.
 
-	There are several features of the Line6 USB driver which require PCM
+	There are several features of the Line 6 USB driver which require PCM
 	data to be exchanged with the device:
 	*) PCM playback and capture via ALSA
 	*) software monitoring (for devices without hardware monitoring)
@@ -167,7 +167,7 @@ struct line6_pcm_properties {
 
 struct snd_line6_pcm {
 	/**
-		 Pointer back to the Line6 driver data structure.
+		 Pointer back to the Line 6 driver data structure.
 	*/
 	struct usb_line6 *line6;
 

commit 075587b723ec5d90d1788b9cdba3034f524a64c9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 14:28:25 2015 +0100

    ALSA: line6: Handle impulse response via control API
    
    Instead of sysfs and the conditional build with Kconfig, implement the
    handling of the impulse response controls via control API, and always
    enable the build.  Two new controls, "Impulse Response Volume" and
    "Impulse Response Period" are added as a replacement for the former
    sysfs files.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
index 7315e8131184..9328e6ffb191 100644
--- a/sound/usb/line6/pcm.h
+++ b/sound/usb/line6/pcm.h
@@ -35,9 +35,7 @@
 /* in a "full speed" device (such as the PODxt Pro) this means 1ms */
 #define LINE6_ISO_INTERVAL	1
 
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 #define LINE6_IMPULSE_DEFAULT_PERIOD 100
-#endif
 
 /*
 	Get substream from Line6 PCM data structure
@@ -89,12 +87,10 @@ enum {
 	LINE6_INDEX_PCM_MONITOR_PLAYBACK_STREAM,
 	LINE6_INDEX_PCM_MONITOR_CAPTURE_BUFFER,
 	LINE6_INDEX_PCM_MONITOR_CAPTURE_STREAM,
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	LINE6_INDEX_PCM_IMPULSE_PLAYBACK_BUFFER,
 	LINE6_INDEX_PCM_IMPULSE_PLAYBACK_STREAM,
 	LINE6_INDEX_PCM_IMPULSE_CAPTURE_BUFFER,
 	LINE6_INDEX_PCM_IMPULSE_CAPTURE_STREAM,
-#endif
 	LINE6_INDEX_PAUSE_PLAYBACK,
 	LINE6_INDEX_PREPARED,
 
@@ -109,12 +105,10 @@ enum {
 	LINE6_BIT(PCM_MONITOR_PLAYBACK_STREAM),
 	LINE6_BIT(PCM_MONITOR_CAPTURE_BUFFER),
 	LINE6_BIT(PCM_MONITOR_CAPTURE_STREAM),
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	LINE6_BIT(PCM_IMPULSE_PLAYBACK_BUFFER),
 	LINE6_BIT(PCM_IMPULSE_PLAYBACK_STREAM),
 	LINE6_BIT(PCM_IMPULSE_CAPTURE_BUFFER),
 	LINE6_BIT(PCM_IMPULSE_CAPTURE_STREAM),
-#endif
 	LINE6_BIT(PAUSE_PLAYBACK),
 	LINE6_BIT(PREPARED),
 
@@ -133,40 +127,30 @@ enum {
 	    LINE6_BIT_PCM_MONITOR_CAPTURE_BUFFER |
 	    LINE6_BIT_PCM_MONITOR_CAPTURE_STREAM,
 
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	LINE6_BITS_PCM_IMPULSE =
 	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_BUFFER |
 	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_STREAM |
 	    LINE6_BIT_PCM_IMPULSE_CAPTURE_BUFFER |
 	    LINE6_BIT_PCM_IMPULSE_CAPTURE_STREAM,
-#endif
 
 	/* combined bit masks (by direction): */
 	LINE6_BITS_PLAYBACK_BUFFER =
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_BUFFER |
-#endif
 	    LINE6_BIT_PCM_ALSA_PLAYBACK_BUFFER |
 	    LINE6_BIT_PCM_MONITOR_PLAYBACK_BUFFER,
 
 	LINE6_BITS_PLAYBACK_STREAM =
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_STREAM |
-#endif
 	    LINE6_BIT_PCM_ALSA_PLAYBACK_STREAM |
 	    LINE6_BIT_PCM_MONITOR_PLAYBACK_STREAM,
 
 	LINE6_BITS_CAPTURE_BUFFER =
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	    LINE6_BIT_PCM_IMPULSE_CAPTURE_BUFFER |
-#endif
 	    LINE6_BIT_PCM_ALSA_CAPTURE_BUFFER |
 	    LINE6_BIT_PCM_MONITOR_CAPTURE_BUFFER,
 
 	LINE6_BITS_CAPTURE_STREAM =
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	    LINE6_BIT_PCM_IMPULSE_CAPTURE_STREAM |
-#endif
 	    LINE6_BIT_PCM_ALSA_CAPTURE_STREAM |
 	    LINE6_BIT_PCM_MONITOR_CAPTURE_STREAM,
 
@@ -338,7 +322,6 @@ struct snd_line6_pcm {
 	*/
 	int volume_monitor;
 
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	/**
 		 Volume of impulse response test signal (if zero, test is disabled).
 	*/
@@ -353,7 +336,6 @@ struct snd_line6_pcm {
 		 Counter for impulse response test signal.
 	*/
 	int impulse_count;
-#endif
 
 	/**
 		 Several status bits (see LINE6_BIT_*).

commit 61864d844c296933d40c02683252bbea5193b101
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 12 22:29:57 2015 +0100

    ALSA: move line6 usb driver into sound/usb
    
    Promote line6 driver from staging to sound/usb/line6 directory, and
    maintain through sound subsystem tree.
    
    This commit just moves the code and adapts Makefile / Kconfig.
    The further renames and misc cleanups will follow.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/pcm.h b/sound/usb/line6/pcm.h
new file mode 100644
index 000000000000..7315e8131184
--- /dev/null
+++ b/sound/usb/line6/pcm.h
@@ -0,0 +1,374 @@
+/*
+ * Line6 Linux USB driver - 0.9.1beta
+ *
+ * Copyright (C) 2004-2010 Markus Grabner (grabner@icg.tugraz.at)
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2.
+ *
+ */
+
+/*
+	PCM interface to POD series devices.
+*/
+
+#ifndef PCM_H
+#define PCM_H
+
+#include <sound/pcm.h>
+
+#include "driver.h"
+#include "usbdefs.h"
+
+/* number of URBs */
+#define LINE6_ISO_BUFFERS	2
+
+/*
+	number of USB frames per URB
+	The Line6 Windows driver always transmits two frames per packet, but
+	the Linux driver performs significantly better (i.e., lower latency)
+	with only one frame per packet.
+*/
+#define LINE6_ISO_PACKETS	1
+
+/* in a "full speed" device (such as the PODxt Pro) this means 1ms */
+#define LINE6_ISO_INTERVAL	1
+
+#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
+#define LINE6_IMPULSE_DEFAULT_PERIOD 100
+#endif
+
+/*
+	Get substream from Line6 PCM data structure
+*/
+#define get_substream(line6pcm, stream)	\
+		(line6pcm->pcm->streams[stream].substream)
+
+/*
+	PCM mode bits.
+
+	There are several features of the Line6 USB driver which require PCM
+	data to be exchanged with the device:
+	*) PCM playback and capture via ALSA
+	*) software monitoring (for devices without hardware monitoring)
+	*) optional impulse response measurement
+	However, from the device's point of view, there is just a single
+	capture and playback stream, which must be shared between these
+	subsystems. It is therefore necessary to maintain the state of the
+	subsystems with respect to PCM usage. We define several constants of
+	the form LINE6_BIT_PCM_<subsystem>_<direction>_<resource> with the
+	following meanings:
+	*) <subsystem> is one of
+	-) ALSA: PCM playback and capture via ALSA
+	-) MONITOR: software monitoring
+	-) IMPULSE: optional impulse response measurement
+	*) <direction> is one of
+	-) PLAYBACK: audio output (from host to device)
+	-) CAPTURE: audio input (from device to host)
+	*) <resource> is one of
+	-) BUFFER: buffer required by PCM data stream
+	-) STREAM: actual PCM data stream
+
+	The subsystems call line6_pcm_acquire() to acquire the (shared)
+	resources needed for a particular operation (e.g., allocate the buffer
+	for ALSA playback or start the capture stream for software monitoring).
+	When a resource is no longer needed, it is released by calling
+	line6_pcm_release(). Buffer allocation and stream startup are handled
+	separately to allow the ALSA kernel driver to perform them at
+	appropriate places (since the callback which starts a PCM stream is not
+	allowed to sleep).
+*/
+enum {
+	/* individual bit indices: */
+	LINE6_INDEX_PCM_ALSA_PLAYBACK_BUFFER,
+	LINE6_INDEX_PCM_ALSA_PLAYBACK_STREAM,
+	LINE6_INDEX_PCM_ALSA_CAPTURE_BUFFER,
+	LINE6_INDEX_PCM_ALSA_CAPTURE_STREAM,
+	LINE6_INDEX_PCM_MONITOR_PLAYBACK_BUFFER,
+	LINE6_INDEX_PCM_MONITOR_PLAYBACK_STREAM,
+	LINE6_INDEX_PCM_MONITOR_CAPTURE_BUFFER,
+	LINE6_INDEX_PCM_MONITOR_CAPTURE_STREAM,
+#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
+	LINE6_INDEX_PCM_IMPULSE_PLAYBACK_BUFFER,
+	LINE6_INDEX_PCM_IMPULSE_PLAYBACK_STREAM,
+	LINE6_INDEX_PCM_IMPULSE_CAPTURE_BUFFER,
+	LINE6_INDEX_PCM_IMPULSE_CAPTURE_STREAM,
+#endif
+	LINE6_INDEX_PAUSE_PLAYBACK,
+	LINE6_INDEX_PREPARED,
+
+#define LINE6_BIT(x) LINE6_BIT_ ## x = 1 << LINE6_INDEX_ ## x
+
+	/* individual bit masks: */
+	LINE6_BIT(PCM_ALSA_PLAYBACK_BUFFER),
+	LINE6_BIT(PCM_ALSA_PLAYBACK_STREAM),
+	LINE6_BIT(PCM_ALSA_CAPTURE_BUFFER),
+	LINE6_BIT(PCM_ALSA_CAPTURE_STREAM),
+	LINE6_BIT(PCM_MONITOR_PLAYBACK_BUFFER),
+	LINE6_BIT(PCM_MONITOR_PLAYBACK_STREAM),
+	LINE6_BIT(PCM_MONITOR_CAPTURE_BUFFER),
+	LINE6_BIT(PCM_MONITOR_CAPTURE_STREAM),
+#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
+	LINE6_BIT(PCM_IMPULSE_PLAYBACK_BUFFER),
+	LINE6_BIT(PCM_IMPULSE_PLAYBACK_STREAM),
+	LINE6_BIT(PCM_IMPULSE_CAPTURE_BUFFER),
+	LINE6_BIT(PCM_IMPULSE_CAPTURE_STREAM),
+#endif
+	LINE6_BIT(PAUSE_PLAYBACK),
+	LINE6_BIT(PREPARED),
+
+	/* combined bit masks (by operation): */
+	LINE6_BITS_PCM_ALSA_BUFFER =
+	    LINE6_BIT_PCM_ALSA_PLAYBACK_BUFFER |
+	    LINE6_BIT_PCM_ALSA_CAPTURE_BUFFER,
+
+	LINE6_BITS_PCM_ALSA_STREAM =
+	    LINE6_BIT_PCM_ALSA_PLAYBACK_STREAM |
+	    LINE6_BIT_PCM_ALSA_CAPTURE_STREAM,
+
+	LINE6_BITS_PCM_MONITOR =
+	    LINE6_BIT_PCM_MONITOR_PLAYBACK_BUFFER |
+	    LINE6_BIT_PCM_MONITOR_PLAYBACK_STREAM |
+	    LINE6_BIT_PCM_MONITOR_CAPTURE_BUFFER |
+	    LINE6_BIT_PCM_MONITOR_CAPTURE_STREAM,
+
+#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
+	LINE6_BITS_PCM_IMPULSE =
+	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_BUFFER |
+	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_STREAM |
+	    LINE6_BIT_PCM_IMPULSE_CAPTURE_BUFFER |
+	    LINE6_BIT_PCM_IMPULSE_CAPTURE_STREAM,
+#endif
+
+	/* combined bit masks (by direction): */
+	LINE6_BITS_PLAYBACK_BUFFER =
+#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
+	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_BUFFER |
+#endif
+	    LINE6_BIT_PCM_ALSA_PLAYBACK_BUFFER |
+	    LINE6_BIT_PCM_MONITOR_PLAYBACK_BUFFER,
+
+	LINE6_BITS_PLAYBACK_STREAM =
+#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
+	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_STREAM |
+#endif
+	    LINE6_BIT_PCM_ALSA_PLAYBACK_STREAM |
+	    LINE6_BIT_PCM_MONITOR_PLAYBACK_STREAM,
+
+	LINE6_BITS_CAPTURE_BUFFER =
+#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
+	    LINE6_BIT_PCM_IMPULSE_CAPTURE_BUFFER |
+#endif
+	    LINE6_BIT_PCM_ALSA_CAPTURE_BUFFER |
+	    LINE6_BIT_PCM_MONITOR_CAPTURE_BUFFER,
+
+	LINE6_BITS_CAPTURE_STREAM =
+#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
+	    LINE6_BIT_PCM_IMPULSE_CAPTURE_STREAM |
+#endif
+	    LINE6_BIT_PCM_ALSA_CAPTURE_STREAM |
+	    LINE6_BIT_PCM_MONITOR_CAPTURE_STREAM,
+
+	LINE6_BITS_STREAM =
+	    LINE6_BITS_PLAYBACK_STREAM |
+	    LINE6_BITS_CAPTURE_STREAM
+};
+
+struct line6_pcm_properties {
+	struct snd_pcm_hardware snd_line6_playback_hw, snd_line6_capture_hw;
+	struct snd_pcm_hw_constraint_ratdens snd_line6_rates;
+	int bytes_per_frame;
+};
+
+struct snd_line6_pcm {
+	/**
+		 Pointer back to the Line6 driver data structure.
+	*/
+	struct usb_line6 *line6;
+
+	/**
+		 Properties.
+	*/
+	struct line6_pcm_properties *properties;
+
+	/**
+		 ALSA pcm stream
+	*/
+	struct snd_pcm *pcm;
+
+	/**
+		 URBs for audio playback.
+	*/
+	struct urb *urb_audio_out[LINE6_ISO_BUFFERS];
+
+	/**
+		 URBs for audio capture.
+	*/
+	struct urb *urb_audio_in[LINE6_ISO_BUFFERS];
+
+	/**
+		 Temporary buffer for playback.
+		 Since the packet size is not known in advance, this buffer is
+		 large enough to store maximum size packets.
+	*/
+	unsigned char *buffer_out;
+
+	/**
+		 Temporary buffer for capture.
+		 Since the packet size is not known in advance, this buffer is
+		 large enough to store maximum size packets.
+	*/
+	unsigned char *buffer_in;
+
+	/**
+		 Previously captured frame (for software monitoring).
+	*/
+	unsigned char *prev_fbuf;
+
+	/**
+		 Size of previously captured frame (for software monitoring).
+	*/
+	int prev_fsize;
+
+	/**
+		 Free frame position in the playback buffer.
+	*/
+	snd_pcm_uframes_t pos_out;
+
+	/**
+		 Count processed bytes for playback.
+		 This is modulo period size (to determine when a period is
+		 finished).
+	*/
+	unsigned bytes_out;
+
+	/**
+		 Counter to create desired playback sample rate.
+	*/
+	unsigned count_out;
+
+	/**
+		 Playback period size in bytes
+	*/
+	unsigned period_out;
+
+	/**
+		 Processed frame position in the playback buffer.
+		 The contents of the output ring buffer have been consumed by
+		 the USB subsystem (i.e., sent to the USB device) up to this
+		 position.
+	*/
+	snd_pcm_uframes_t pos_out_done;
+
+	/**
+		 Count processed bytes for capture.
+		 This is modulo period size (to determine when a period is
+		 finished).
+	*/
+	unsigned bytes_in;
+
+	/**
+		 Counter to create desired capture sample rate.
+	*/
+	unsigned count_in;
+
+	/**
+		 Capture period size in bytes
+	*/
+	unsigned period_in;
+
+	/**
+		 Processed frame position in the capture buffer.
+		 The contents of the output ring buffer have been consumed by
+		 the USB subsystem (i.e., sent to the USB device) up to this
+		 position.
+	*/
+	snd_pcm_uframes_t pos_in_done;
+
+	/**
+		 Bit mask of active playback URBs.
+	*/
+	unsigned long active_urb_out;
+
+	/**
+		 Maximum size of USB packet.
+	*/
+	int max_packet_size;
+
+	/**
+		 Bit mask of active capture URBs.
+	*/
+	unsigned long active_urb_in;
+
+	/**
+		 Bit mask of playback URBs currently being unlinked.
+	*/
+	unsigned long unlink_urb_out;
+
+	/**
+		 Bit mask of capture URBs currently being unlinked.
+	*/
+	unsigned long unlink_urb_in;
+
+	/**
+		 Spin lock to protect updates of the playback buffer positions (not
+		 contents!)
+	*/
+	spinlock_t lock_audio_out;
+
+	/**
+		 Spin lock to protect updates of the capture buffer positions (not
+		 contents!)
+	*/
+	spinlock_t lock_audio_in;
+
+	/**
+		 Spin lock to protect trigger.
+	*/
+	spinlock_t lock_trigger;
+
+	/**
+		 PCM playback volume (left and right).
+	*/
+	int volume_playback[2];
+
+	/**
+		 PCM monitor volume.
+	*/
+	int volume_monitor;
+
+#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
+	/**
+		 Volume of impulse response test signal (if zero, test is disabled).
+	*/
+	int impulse_volume;
+
+	/**
+		 Period of impulse response test signal.
+	*/
+	int impulse_period;
+
+	/**
+		 Counter for impulse response test signal.
+	*/
+	int impulse_count;
+#endif
+
+	/**
+		 Several status bits (see LINE6_BIT_*).
+	*/
+	unsigned long flags;
+
+	int last_frame_in, last_frame_out;
+};
+
+extern int line6_init_pcm(struct usb_line6 *line6,
+			  struct line6_pcm_properties *properties);
+extern int snd_line6_trigger(struct snd_pcm_substream *substream, int cmd);
+extern int snd_line6_prepare(struct snd_pcm_substream *substream);
+extern void line6_pcm_disconnect(struct snd_line6_pcm *line6pcm);
+extern int line6_pcm_acquire(struct snd_line6_pcm *line6pcm, int channels);
+extern int line6_pcm_release(struct snd_line6_pcm *line6pcm, int channels);
+
+#endif
