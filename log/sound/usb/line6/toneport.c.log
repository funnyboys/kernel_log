commit 37cc306b723f94d2be73578069ed1e88e1a30cdb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:17:06 2020 +0100

    ALSA: line6: Constify snd_ratden definitions
    
    The snd_ratden definitions used in line6 drivers are all read-only, so
    they can be marked as const.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-51-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index d0a555dbe324..94dd5e7ab2e6 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -63,7 +63,7 @@ static int toneport_send_cmd(struct usb_device *usbdev, int cmd1, int cmd2);
 
 #define TONEPORT_PCM_DELAY 1
 
-static struct snd_ratden toneport_ratden = {
+static const struct snd_ratden toneport_ratden = {
 	.num_min = 44100,
 	.num_max = 44100,
 	.num_step = 1,

commit 3c53c6255d598db7084c5c3d7553d7200e857818
Merge: b89b889a326a a98429acadef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 8 14:45:20 2019 +0200

    Merge tag 'asoc-v5.3' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.3
    
    This is a very big update, mainly thanks to Morimoto-san's refactoring
    work and some fairly large new drivers.
    
     - Lots more work on moving towards a component based framework from
       Morimoto-san.
     - Support for force disconnecting muxes from Jerome Brunet.
     - New drivers for Cirrus Logic CS47L35, CS47L85 and CS47L90, Conexant
       CX2072X, Realtek RT1011 and RT1308.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit a10e763b87134a9a4ca3a38b5c4b533e75ec63a3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 31 01:09:32 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 372
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 135 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531081036.435762997@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 55865f7e437d..974ab3e62b68 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Line 6 Linux USB driver
  *
  * Copyright (C) 2004-2010 Markus Grabner (grabner@icg.tugraz.at)
  *                         Emil Myhrman (emil.myhrman@gmail.com)
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License as
- *	published by the Free Software Foundation, version 2.
- *
  */
 
 #include <linux/wait.h>

commit f23a09eea1e7947611d985d8cd13d55428ff0af8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 28 09:05:31 2019 +0200

    ALSA: line6: Use container_of()
    
    ... instead of unconditional cast.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 55865f7e437d..94a9764110d3 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -61,6 +61,8 @@ struct usb_line6_toneport {
 	struct toneport_led leds[2];
 };
 
+#define line6_to_toneport(x) container_of(x, struct usb_line6_toneport, line6)
+
 static int toneport_send_cmd(struct usb_device *usbdev, int cmd1, int cmd2);
 
 #define TONEPORT_PCM_DELAY 1
@@ -211,8 +213,8 @@ static int snd_toneport_source_get(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);
-	struct usb_line6_toneport *toneport =
-	    (struct usb_line6_toneport *)line6pcm->line6;
+	struct usb_line6_toneport *toneport = line6_to_toneport(line6pcm->line6);
+
 	ucontrol->value.enumerated.item[0] = toneport->source;
 	return 0;
 }
@@ -222,8 +224,7 @@ static int snd_toneport_source_put(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);
-	struct usb_line6_toneport *toneport =
-	    (struct usb_line6_toneport *)line6pcm->line6;
+	struct usb_line6_toneport *toneport = line6_to_toneport(line6pcm->line6);
 	unsigned int source;
 
 	source = ucontrol->value.enumerated.item[0];
@@ -397,8 +398,7 @@ static int toneport_setup(struct usb_line6_toneport *toneport)
 */
 static void line6_toneport_disconnect(struct usb_line6 *line6)
 {
-	struct usb_line6_toneport *toneport =
-		(struct usb_line6_toneport *)line6;
+	struct usb_line6_toneport *toneport = line6_to_toneport(line6);
 
 	if (toneport_has_led(toneport))
 		toneport_remove_leds(toneport);
@@ -412,7 +412,7 @@ static int toneport_init(struct usb_line6 *line6,
 			 const struct usb_device_id *id)
 {
 	int err;
-	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
+	struct usb_line6_toneport *toneport = line6_to_toneport(line6);
 
 	toneport->type = id->driver_info;
 

commit 0b074ab7fc0d575247b9cc9f93bb7e007ca38840
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 28 08:39:44 2019 +0200

    ALSA: line6: Assure canceling delayed work at disconnection
    
    The current code performs the cancel of a delayed work at the late
    stage of disconnection procedure, which may lead to the access to the
    already cleared state.
    
    This patch assures to call cancel_delayed_work_sync() at the beginning
    of the disconnection procedure for avoiding that race.  The delayed
    work object is now assigned in the common line6 object instead of its
    derivative, so that we can call cancel_delayed_work_sync().
    
    Along with the change, the startup function is called via the new
    callback instead.  This will make it easier to port other LINE6
    drivers to use the delayed work for startup in later patches.
    
    Reported-by: syzbot+5255458d5e0a2b10bbb9@syzkaller.appspotmail.com
    Fixes: 7f84ff68be05 ("ALSA: line6: toneport: Fix broken usage of timer for delayed execution")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index e28368d8eba2..55865f7e437d 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -54,9 +54,6 @@ struct usb_line6_toneport {
 	/* Firmware version (x 100) */
 	u8 firmware_version;
 
-	/* Work for delayed PCM startup */
-	struct delayed_work pcm_work;
-
 	/* Device type */
 	enum line6_device_type type;
 
@@ -241,12 +238,8 @@ static int snd_toneport_source_put(struct snd_kcontrol *kcontrol,
 	return 1;
 }
 
-static void toneport_start_pcm(struct work_struct *work)
+static void toneport_startup(struct usb_line6 *line6)
 {
-	struct usb_line6_toneport *toneport =
-		container_of(work, struct usb_line6_toneport, pcm_work.work);
-	struct usb_line6 *line6 = &toneport->line6;
-
 	line6_pcm_acquire(line6->line6pcm, LINE6_STREAM_MONITOR, true);
 }
 
@@ -394,7 +387,7 @@ static int toneport_setup(struct usb_line6_toneport *toneport)
 	if (toneport_has_led(toneport))
 		toneport_update_led(toneport);
 
-	schedule_delayed_work(&toneport->pcm_work,
+	schedule_delayed_work(&toneport->line6.startup_work,
 			      msecs_to_jiffies(TONEPORT_PCM_DELAY * 1000));
 	return 0;
 }
@@ -407,8 +400,6 @@ static void line6_toneport_disconnect(struct usb_line6 *line6)
 	struct usb_line6_toneport *toneport =
 		(struct usb_line6_toneport *)line6;
 
-	cancel_delayed_work_sync(&toneport->pcm_work);
-
 	if (toneport_has_led(toneport))
 		toneport_remove_leds(toneport);
 }
@@ -424,9 +415,9 @@ static int toneport_init(struct usb_line6 *line6,
 	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
 
 	toneport->type = id->driver_info;
-	INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);
 
 	line6->disconnect = line6_toneport_disconnect;
+	line6->startup = toneport_startup;
 
 	/* initialize PCM subsystem: */
 	err = line6_init_pcm(line6, &toneport_pcm_properties);

commit e57ccca1ba33e1d92cc3bbf8b6304a46948844b0
Merge: a2d635decbfa ed97c988bdc6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 9 08:26:55 2019 -0700

    Merge tag 'sound-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "The most significant changes at this cycle are the Sound Open Firmware
      support from Intel for the common DSP framework along with its support
      for Intel platforms. It's a door opened to a real "free" firmware (in
      the sense of FOSS), and other parties show interests in it.
    
      In addition to SOF, we've got a bunch of updates and fixes as usual.
      Some highlights are below.
    
      ALSA core:
       - Cleanups and fixes in ALSA timer code to cover some races spotted
         by syzkaller
       - Cleanups and fixes in ALSA sequencer code to cover some races,
         again unsurprisingly, spotted by syzkaller
       - Optimize the common page allocation helper with alloc_pages_exact()
    
      ASoC:
       - Add SOF core support, as well as Intel SOF platform support
       - Generic card driver improvements: support for MCLK/sample rate
         ratio and pin switches
       - A big set of improvements to TLV320AIC32x4 drivers
       - New drivers for Freescale audio mixers, several Intel machines,
         several Mediatek machines, Meson G12A, Spreadtrum compressed audio
         and DMA devices
    
      HD-audio:
       - A few Realtek codec fixes for reducing pop noises
       - Quirks for Chromebooks
       - Workaround for faulty connection report on AMD/Nvidia HDMI
    
      Others:
       - A quirk for Focusrite Scarlett Solo USB-audio
       - Add support for MOTU 8pre FireWire
       - 24bit sample format support in aloop
       - GUS patch format support (finally, over a decade) in native emux
         synth code"
    
    * tag 'sound-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (375 commits)
      ASoC: SOF: Fix unused variable warnings
      ALSA: line6: toneport: Fix broken usage of timer for delayed execution
      ALSA: aica: Fix a long-time build breakage
      ALSA: hda/realtek - Support low power consumption for ALC256
      ASoC: stm32: i2s: update pcm hardware constraints
      ASoC: codec: hdac_hdmi: no checking monitor in hw_params
      ASoC: mediatek: mt6358: save PGA for mixer control
      ASoC: mediatek: mt6358: save output volume for mixer controls
      ASoC: mediatek: mt6358: initialize setting when ramping volume
      ASoC: SOF: core: fix undefined nocodec reference
      ASoC: SOF: xtensa: fix undefined references
      ASoC: SOF: Propagate sof_get_ctrl_copy_params() error properly
      ALSA: hdea/realtek - Headset fixup for System76 Gazelle (gaze14)
      ALSA: hda/intel: add CometLake PCI IDs
      ALSA: hda/realtek - Support low power consumption for ALC295
      ASoC: rockchip: Fix an uninitialized variable compile warning
      ASoC: SOF: Fix a compile warning with CONFIG_PCI=n
      ASoC: da7219: Fix a compile warning at CONFIG_COMMON_CLK=n
      ASoC: sound/soc/sof/: fix kconfig dependency warning
      ASoC: stm32: spdifrx: change trace level on iec control
      ...

commit 7f84ff68be05ec7a5d2acf8fdc734fe5897af48f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 8 15:01:24 2019 +0200

    ALSA: line6: toneport: Fix broken usage of timer for delayed execution
    
    The line6 toneport driver has code for some delayed initialization,
    and this hits the kernel Oops because mutex and other sleepable
    functions are used in the timer callback.  Fix the abuse by a delayed
    work instead so that everything works gracefully.
    
    Reported-by: syzbot+a07d0142e74fdd595cfb@syzkaller.appspotmail.com
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 19bee725de00..325b07b98b3c 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -54,8 +54,8 @@ struct usb_line6_toneport {
 	/* Firmware version (x 100) */
 	u8 firmware_version;
 
-	/* Timer for delayed PCM startup */
-	struct timer_list timer;
+	/* Work for delayed PCM startup */
+	struct delayed_work pcm_work;
 
 	/* Device type */
 	enum line6_device_type type;
@@ -241,9 +241,10 @@ static int snd_toneport_source_put(struct snd_kcontrol *kcontrol,
 	return 1;
 }
 
-static void toneport_start_pcm(struct timer_list *t)
+static void toneport_start_pcm(struct work_struct *work)
 {
-	struct usb_line6_toneport *toneport = from_timer(toneport, t, timer);
+	struct usb_line6_toneport *toneport =
+		container_of(work, struct usb_line6_toneport, pcm_work.work);
 	struct usb_line6 *line6 = &toneport->line6;
 
 	line6_pcm_acquire(line6->line6pcm, LINE6_STREAM_MONITOR, true);
@@ -393,7 +394,8 @@ static int toneport_setup(struct usb_line6_toneport *toneport)
 	if (toneport_has_led(toneport))
 		toneport_update_led(toneport);
 
-	mod_timer(&toneport->timer, jiffies + TONEPORT_PCM_DELAY * HZ);
+	schedule_delayed_work(&toneport->pcm_work,
+			      msecs_to_jiffies(TONEPORT_PCM_DELAY * 1000));
 	return 0;
 }
 
@@ -405,7 +407,7 @@ static void line6_toneport_disconnect(struct usb_line6 *line6)
 	struct usb_line6_toneport *toneport =
 		(struct usb_line6_toneport *)line6;
 
-	del_timer_sync(&toneport->timer);
+	cancel_delayed_work_sync(&toneport->pcm_work);
 
 	if (toneport_has_led(toneport))
 		toneport_remove_leds(toneport);
@@ -422,7 +424,7 @@ static int toneport_init(struct usb_line6 *line6,
 	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
 
 	toneport->type = id->driver_info;
-	timer_setup(&toneport->timer, toneport_start_pcm, 0);
+	INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);
 
 	line6->disconnect = line6_toneport_disconnect;
 

commit 8b35ad6232c462b02e397e87ce702bcddd4ba543
Merge: f678d6da7499 0db37915d912
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 18:02:51 2019 -0700

    Merge tag 'leds-for-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/j.anaszewski/linux-leds
    
    Pull LED updates from Jacek Anaszewski:
     "LED core fixes and improvements:
    
          - avoid races with workqueue
          - Kconfig: pedantic cleanup
          - small fixes for Flash class description
    
      leds-lt3593:
    
          - remove unneeded assignment in lt3593_led_probe
          - drop pdata handling code
    
      leds-blinkm:
    
          - clean up double assignment to data->i2c_addr
    
      leds-pca955x, leds-pca963x:
    
          - revert ACPI support, as it turned out that there is no evidence
              of officially registered ACPI IDs for these devices.
          - make use of device property API
    
      leds-as3645a:
    
          - switch to fwnode property API
    
      LED related addition to ACPI documentation:
    
          - document how to refer to LEDs from remote nodes
    
      LED related fix to ALSA line6/toneport driver:
    
          - avoid polluting led_* namespace
    
      And lm3532 driver relocation from MFD to LED subsystem, accompanied by
      various improvements and optimizations; it entails also a change in
      omap4-droid4-xt894.dts:
    
          - leds: lm3532: Introduce the lm3532 LED driver
          - mfd: ti-lmu: Remove LM3532 backlight driver references
          - ARM: dts: omap4-droid4: Update backlight dt properties
          - dt: lm3532: Add lm3532 dt doc and update ti_lmu doc"
    
    * tag 'leds-for-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/j.anaszewski/linux-leds:
      leds: avoid races with workqueue
      ALSA: line6: Avoid polluting led_* namespace
      leds: lm3532: Introduce the lm3532 LED driver
      mfd: ti-lmu: Remove LM3532 backlight driver references
      ARM: dts: omap4-droid4: Update backlight dt properties
      dt: lm3532: Add lm3532 dt doc and update ti_lmu doc
      leds: Small fixes for Flash class description
      leds: blinkm: clean up double assignment to data->i2c_addr
      leds: pca963x: Make use of device property API
      leds: pca955x: Make use of device property API
      leds: lt3593: Remove unneeded assignment in lt3593_led_probe
      leds: lt3593: drop pdata handling code
      leds: pca955x: Revert "Add ACPI support"
      leds: pca963x: Revert "Add ACPI support"
      drivers: leds: Kconfig: pedantic cleanups
      ACPI: Document how to refer to LEDs from remote nodes
      leds: as3645a: Switch to fwnode property API

commit e5c812e84f0dece3400d5caf42522287e6ef139f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Apr 28 18:04:11 2019 +0200

    ALSA: line6: use dynamic buffers
    
    The line6 driver uses a lot of USB buffers off of the stack, which is
    not allowed on many systems, causing the driver to crash on some of
    them.  Fix this up by dynamically allocating the buffers with kmalloc()
    which allows for proper DMA-able memory.
    
    Reported-by: Christo Gouws <gouws.christo@gmail.com>
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Christo Gouws <gouws.christo@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index f47ba94e6f4a..19bee725de00 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -365,16 +365,21 @@ static bool toneport_has_source_select(struct usb_line6_toneport *toneport)
 /*
 	Setup Toneport device.
 */
-static void toneport_setup(struct usb_line6_toneport *toneport)
+static int toneport_setup(struct usb_line6_toneport *toneport)
 {
-	u32 ticks;
+	u32 *ticks;
 	struct usb_line6 *line6 = &toneport->line6;
 	struct usb_device *usbdev = line6->usbdev;
 
+	ticks = kmalloc(sizeof(*ticks), GFP_KERNEL);
+	if (!ticks)
+		return -ENOMEM;
+
 	/* sync time on device with host: */
 	/* note: 32-bit timestamps overflow in year 2106 */
-	ticks = (u32)ktime_get_real_seconds();
-	line6_write_data(line6, 0x80c6, &ticks, 4);
+	*ticks = (u32)ktime_get_real_seconds();
+	line6_write_data(line6, 0x80c6, ticks, 4);
+	kfree(ticks);
 
 	/* enable device: */
 	toneport_send_cmd(usbdev, 0x0301, 0x0000);
@@ -389,6 +394,7 @@ static void toneport_setup(struct usb_line6_toneport *toneport)
 		toneport_update_led(toneport);
 
 	mod_timer(&toneport->timer, jiffies + TONEPORT_PCM_DELAY * HZ);
+	return 0;
 }
 
 /*
@@ -451,7 +457,9 @@ static int toneport_init(struct usb_line6 *line6,
 			return err;
 	}
 
-	toneport_setup(toneport);
+	err = toneport_setup(toneport);
+	if (err)
+		return err;
 
 	/* register audio system: */
 	return snd_card_register(line6->card);
@@ -463,7 +471,11 @@ static int toneport_init(struct usb_line6 *line6,
 */
 static int toneport_reset_resume(struct usb_interface *interface)
 {
-	toneport_setup(usb_get_intfdata(interface));
+	int err;
+
+	err = toneport_setup(usb_get_intfdata(interface));
+	if (err)
+		return err;
 	return line6_resume(interface);
 }
 #endif

commit 05b8ccfba5d4621072e541603b0f0a14c2203ca8
Author: Jacek Anaszewski <jacek.anaszewski@gmail.com>
Date:   Sat Apr 6 19:04:44 2019 +0200

    ALSA: line6: Avoid polluting led_* namespace
    
    led_colors clashes with the array of the same name being added
    to the LED class. Do the following amendments to fix this issue
    and the other prospective one.
    
    led_colors -> toneport_led_colors
    led_init_vals -> toneport_led_init_vals
    
    Fixes: f44edd7b2bbed ("ALSA: line6/toneport: Implement LED controls via LED class")
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index f47ba94e6f4a..56875526b182 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -291,8 +291,8 @@ static bool toneport_has_led(struct usb_line6_toneport *toneport)
 	}
 }
 
-static const char * const led_colors[2] = { "red", "green" };
-static const int led_init_vals[2] = { 0x00, 0x26 };
+static const char * const toneport_led_colors[2] = { "red", "green" };
+static const int toneport_led_init_vals[2] = { 0x00, 0x26 };
 
 static void toneport_update_led(struct usb_line6_toneport *toneport)
 {
@@ -320,9 +320,9 @@ static int toneport_init_leds(struct usb_line6_toneport *toneport)
 
 		led->toneport = toneport;
 		snprintf(led->name, sizeof(led->name), "%s::%s",
-			 dev_name(dev), led_colors[i]);
+			 dev_name(dev), toneport_led_colors[i]);
 		leddev->name = led->name;
-		leddev->brightness = led_init_vals[i];
+		leddev->brightness = toneport_led_init_vals[i];
 		leddev->max_brightness = 0x26;
 		leddev->brightness_set = toneport_led_brightness_set;
 		err = led_classdev_register(dev, leddev);

commit a8eaad7b04eaab3df6b8db722d4418286815b46c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 17:41:01 2018 +0200

    ALSA: line6: stop using get_seconds()
    
    The get_seconds() function is deprecated because it truncates the
    timestamp to 32 bits, so all users should change to ktime_get_seconds()
    or ktime_get_real_seconds().
    
    The firmware interface for passing the timestamp is also limited to
    32 bits, so this patch only has the cosmetic effect of avoiding the
    old interface.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 750467fb95db..f47ba94e6f4a 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -367,12 +367,13 @@ static bool toneport_has_source_select(struct usb_line6_toneport *toneport)
 */
 static void toneport_setup(struct usb_line6_toneport *toneport)
 {
-	int ticks;
+	u32 ticks;
 	struct usb_line6 *line6 = &toneport->line6;
 	struct usb_device *usbdev = line6->usbdev;
 
 	/* sync time on device with host: */
-	ticks = (int)get_seconds();
+	/* note: 32-bit timestamps overflow in year 2106 */
+	ticks = (u32)ktime_get_real_seconds();
 	line6_write_data(line6, 0x80c6, &ticks, 4);
 
 	/* enable device: */

commit a6162afa7135548973ba633c7795db9648fbd4a2
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 16:07:31 2017 -0700

    ALSA: usb-audio: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index ba7975c0d03d..750467fb95db 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -241,9 +241,9 @@ static int snd_toneport_source_put(struct snd_kcontrol *kcontrol,
 	return 1;
 }
 
-static void toneport_start_pcm(unsigned long arg)
+static void toneport_start_pcm(struct timer_list *t)
 {
-	struct usb_line6_toneport *toneport = (struct usb_line6_toneport *)arg;
+	struct usb_line6_toneport *toneport = from_timer(toneport, t, timer);
 	struct usb_line6 *line6 = &toneport->line6;
 
 	line6_pcm_acquire(line6->line6pcm, LINE6_STREAM_MONITOR, true);
@@ -415,8 +415,7 @@ static int toneport_init(struct usb_line6 *line6,
 	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
 
 	toneport->type = id->driver_info;
-	setup_timer(&toneport->timer, toneport_start_pcm,
-		    (unsigned long)toneport);
+	timer_setup(&toneport->timer, toneport_start_pcm, 0);
 
 	line6->disconnect = line6_toneport_disconnect;
 

commit 49c41e1f23882f7950cff66992115bba03f1bbcf
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Wed Apr 12 18:40:47 2017 +0530

    ALSA: line6: constify snd_kcontrol_new structures
    
    Declare snd_kcontrol_new strcutures as const as they are only passed as
    an argument to the function snd_ctl_new1. This argument is of type const,
    so snd_kcontrol_new structures having this property can be made const too.
    Done using Coccinelle:
    
    @r disable optional_qualifier@
    identifier x;
    position p;
    @@
    static struct snd_kcontrol_new x@p={...};
    
    @ok@
    identifier r.x;
    position p;
    @@
    snd_ctl_new1(&x@p,...)
    
    @bad@
    position p != {r.p,ok.p};
    identifier r.x;
    @@
    x@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.x;
    @@
    +const
    struct snd_kcontrol_new x;
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 8e22f430d700..ba7975c0d03d 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -250,7 +250,7 @@ static void toneport_start_pcm(unsigned long arg)
 }
 
 /* control definition */
-static struct snd_kcontrol_new toneport_control_monitor = {
+static const struct snd_kcontrol_new toneport_control_monitor = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Monitor Playback Volume",
 	.index = 0,
@@ -261,7 +261,7 @@ static struct snd_kcontrol_new toneport_control_monitor = {
 };
 
 /* source selector definition */
-static struct snd_kcontrol_new toneport_control_source = {
+static const struct snd_kcontrol_new toneport_control_source = {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "PCM Capture Source",
 	.index = 0,

commit f56742cc41895b1ed3742406dc3587b0d6424acb
Author: Andrej Krutak <dev@andree.sk>
Date:   Sun Sep 18 20:59:25 2016 +0200

    ALSA: line6: Add LINE6_CAP_IN_NEEDS_OUT, a void playback stream during capture
    
    E.g. POD X3 seems to require playback data to be sent to it to generate
    capture data. Otherwise the device stalls and doesn't send any more capture
    data until it's reset.
    
    Signed-off-by: Andrej Krutak <dev@andree.sk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index da76e030eefc..8e22f430d700 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -177,7 +177,7 @@ static int snd_toneport_monitor_put(struct snd_kcontrol *kcontrol,
 	line6pcm->volume_monitor = ucontrol->value.integer.value[0];
 
 	if (line6pcm->volume_monitor > 0) {
-		err = line6_pcm_acquire(line6pcm, LINE6_STREAM_MONITOR);
+		err = line6_pcm_acquire(line6pcm, LINE6_STREAM_MONITOR, true);
 		if (err < 0) {
 			line6pcm->volume_monitor = 0;
 			line6_pcm_release(line6pcm, LINE6_STREAM_MONITOR);
@@ -246,7 +246,7 @@ static void toneport_start_pcm(unsigned long arg)
 	struct usb_line6_toneport *toneport = (struct usb_line6_toneport *)arg;
 	struct usb_line6 *line6 = &toneport->line6;
 
-	line6_pcm_acquire(line6->line6pcm, LINE6_STREAM_MONITOR);
+	line6_pcm_acquire(line6->line6pcm, LINE6_STREAM_MONITOR, true);
 }
 
 /* control definition */

commit 97d78acfb870a67339957e9c4d36dc03242df315
Author: Andrej Krutak <dev@andree.sk>
Date:   Sun Sep 18 20:59:24 2016 +0200

    ALSA: line6: Allow different channel numbers for in/out
    
    Changes bytes_per_frame to bytes_per_channel.
    
    Signed-off-by: Andrej Krutak <dev@andree.sk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 6d4c50c9b17d..da76e030eefc 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -114,7 +114,7 @@ static struct line6_pcm_properties toneport_pcm_properties = {
 	.rates = {
 			    .nrats = 1,
 			    .rats = &toneport_ratden},
-	.bytes_per_frame = 4
+	.bytes_per_channel = 2
 };
 
 static const struct {

commit 0e806151e86be52caa1349fa490eab8f09a2b6f5
Author: Chris Rorvick <chris@rorvick.com>
Date:   Tue Feb 10 23:03:17 2015 -0600

    ALSA: line6: toneport: Use explicit type for firmware version
    
    The firmware version is a single byte so have the variable type agree.
    Since the address to this member is passed to the read function, using
    an int is not even portable.
    
    Signed-off-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index ddf7368c2001..6d4c50c9b17d 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -52,7 +52,7 @@ struct usb_line6_toneport {
 	u32 serial_number;
 
 	/* Firmware version (x 100) */
-	int firmware_version;
+	u8 firmware_version;
 
 	/* Timer for delayed PCM startup */
 	struct timer_list timer;

commit 12b00157fd8572ee1f54b70bbf496641a1608924
Author: Chris Rorvick <chris@rorvick.com>
Date:   Tue Feb 10 23:03:16 2015 -0600

    ALSA: line6: Use explicit type for serial number
    
    The serial number (aka ESN) is a 32-bit value.
    
    Signed-off-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 1a0a485b6654..ddf7368c2001 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -49,7 +49,7 @@ struct usb_line6_toneport {
 	int source;
 
 	/* Serial number of device */
-	int serial_number;
+	u32 serial_number;
 
 	/* Firmware version (x 100) */
 	int firmware_version;

commit 12865cac38cc9e808ce8b479f4bb12fd00bfee7c
Author: Chris Rorvick <chris@rorvick.com>
Date:   Sat Feb 7 10:43:19 2015 -0600

    ALSA: line6: Pass driver name to line6_probe()
    
    Provide a unique name for each driver instead of using "line6usb" for
    all of them.  This will allow for different configurations based on the
    driver type.
    
    Signed-off-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 2420d2fc8aa2..1a0a485b6654 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -557,7 +557,7 @@ static const struct line6_properties toneport_properties_table[] = {
 static int toneport_probe(struct usb_interface *interface,
 			  const struct usb_device_id *id)
 {
-	return line6_probe(interface, id,
+	return line6_probe(interface, id, "Line6-TonePort",
 			   &toneport_properties_table[id->driver_info],
 			   toneport_init, sizeof(struct usb_line6_toneport));
 }

commit f2bd242fa114df07ab8ed0d2f445a9a313e3aaa1
Author: Chris Rorvick <chris@rorvick.com>
Date:   Sat Feb 7 10:43:18 2015 -0600

    ALSA: line6: Pass toneport pointer to toneport_has_led()
    
    It is unlikely this function would ever be used in a context without a
    pointer to a `struct usb_line6_toneport', so grab the device type from
    it rather than having the caller do it.
    
    Signed-off-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 6dd6d4f41310..2420d2fc8aa2 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -278,12 +278,17 @@ static struct snd_kcontrol_new toneport_control_source = {
 	(void cmd_0x02(byte red, byte green)
 */
 
-static bool toneport_has_led(enum line6_device_type type)
+static bool toneport_has_led(struct usb_line6_toneport *toneport)
 {
-	return
-	    (type == LINE6_GUITARPORT) ||
-	    (type == LINE6_TONEPORT_GX);
+	switch (toneport->type) {
+	case LINE6_GUITARPORT:
+	case LINE6_TONEPORT_GX:
 	/* add your device here if you are missing support for the LEDs */
+		return true;
+
+	default:
+		return false;
+	}
 }
 
 static const char * const led_colors[2] = { "red", "green" };
@@ -379,7 +384,7 @@ static void toneport_setup(struct usb_line6_toneport *toneport)
 				  toneport_source_info[toneport->source].code,
 				  0x0000);
 
-	if (toneport_has_led(toneport->type))
+	if (toneport_has_led(toneport))
 		toneport_update_led(toneport);
 
 	mod_timer(&toneport->timer, jiffies + TONEPORT_PCM_DELAY * HZ);
@@ -395,7 +400,7 @@ static void line6_toneport_disconnect(struct usb_line6 *line6)
 
 	del_timer_sync(&toneport->timer);
 
-	if (toneport_has_led(toneport->type))
+	if (toneport_has_led(toneport))
 		toneport_remove_leds(toneport);
 }
 
@@ -440,7 +445,7 @@ static int toneport_init(struct usb_line6 *line6,
 	line6_read_serial_number(line6, &toneport->serial_number);
 	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);
 
-	if (toneport_has_led(toneport->type)) {
+	if (toneport_has_led(toneport)) {
 		err = toneport_init_leds(toneport);
 		if (err < 0)
 			return err;

commit 89444601e5878042812e33da0c17807197c2669c
Author: Chris Rorvick <chris@rorvick.com>
Date:   Sat Feb 7 10:43:17 2015 -0600

    ALSA: line6: Add toneport_has_source_select()
    
    Add a predicate for testing if the device supports source selection to
    make the conditional logic around this a bit cleaner.
    
    Signed-off-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index b107cf481819..6dd6d4f41310 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -343,6 +343,20 @@ static void toneport_remove_leds(struct usb_line6_toneport *toneport)
 	}
 }
 
+static bool toneport_has_source_select(struct usb_line6_toneport *toneport)
+{
+	switch (toneport->type) {
+	case LINE6_TONEPORT_UX1:
+	case LINE6_TONEPORT_UX2:
+	case LINE6_PODSTUDIO_UX1:
+	case LINE6_PODSTUDIO_UX2:
+		return true;
+
+	default:
+		return false;
+	}
+}
+
 /*
 	Setup Toneport device.
 */
@@ -360,17 +374,10 @@ static void toneport_setup(struct usb_line6_toneport *toneport)
 	toneport_send_cmd(usbdev, 0x0301, 0x0000);
 
 	/* initialize source select: */
-	switch (toneport->type) {
-	case LINE6_TONEPORT_UX1:
-	case LINE6_TONEPORT_UX2:
-	case LINE6_PODSTUDIO_UX1:
-	case LINE6_PODSTUDIO_UX2:
+	if (toneport_has_source_select(toneport))
 		toneport_send_cmd(usbdev,
 				  toneport_source_info[toneport->source].code,
 				  0x0000);
-	default:
-		break;
-	}
 
 	if (toneport_has_led(toneport->type))
 		toneport_update_led(toneport);
@@ -421,20 +428,13 @@ static int toneport_init(struct usb_line6 *line6,
 		return err;
 
 	/* register source select control: */
-	switch (toneport->type) {
-	case LINE6_TONEPORT_UX1:
-	case LINE6_TONEPORT_UX2:
-	case LINE6_PODSTUDIO_UX1:
-	case LINE6_PODSTUDIO_UX2:
+	if (toneport_has_source_select(toneport)) {
 		err =
 		    snd_ctl_add(line6->card,
 				snd_ctl_new1(&toneport_control_source,
 					     line6->line6pcm));
 		if (err < 0)
 			return err;
-
-	default:
-		break;
 	}
 
 	line6_read_serial_number(line6, &toneport->serial_number);

commit 1263f61179821df60cca4bccdb69e2f71fdebaa7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 15:08:59 2015 +0100

    ALSA: line6: Remove snd_line6_ prefix of pcm property fields
    
    It's just superfluous and doesn't give any better readability.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index cffcd7f83bfd..b107cf481819 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -76,7 +76,7 @@ static struct snd_ratden toneport_ratden = {
 };
 
 static struct line6_pcm_properties toneport_pcm_properties = {
-	.snd_line6_playback_hw = {
+	.playback_hw = {
 				  .info = (SNDRV_PCM_INFO_MMAP |
 					   SNDRV_PCM_INFO_INTERLEAVED |
 					   SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -94,7 +94,7 @@ static struct line6_pcm_properties toneport_pcm_properties = {
 				  .period_bytes_max = 8192,
 				  .periods_min = 1,
 				  .periods_max = 1024},
-	.snd_line6_capture_hw = {
+	.capture_hw = {
 				 .info = (SNDRV_PCM_INFO_MMAP |
 					  SNDRV_PCM_INFO_INTERLEAVED |
 					  SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -111,7 +111,7 @@ static struct line6_pcm_properties toneport_pcm_properties = {
 				 .period_bytes_max = 8192,
 				 .periods_min = 1,
 				 .periods_max = 1024},
-	.snd_line6_rates = {
+	.rates = {
 			    .nrats = 1,
 			    .rats = &toneport_ratden},
 	.bytes_per_frame = 4

commit 129b3be6895c01e137dbb88c699f9f706bdc6c9d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 14:50:08 2015 +0100

    ALSA: line6: Move the contents of usbdefs.h into driver.h
    
    Most of them are rather relevant with the definitions in driver.h,
    and there are only a few lines, so just rip it off.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 9024acb2b850..cffcd7f83bfd 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -21,7 +21,6 @@
 #include "capture.h"
 #include "driver.h"
 #include "playback.h"
-#include "usbdefs.h"
 
 enum line6_device_type {
 	LINE6_GUITARPORT,

commit cddbd4f17078530b4914a42f6d7f3e543b5fad0e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 14:43:11 2015 +0100

    ALSA: line6: Tidy up and typo fixes in comments
    
    Just reformatting the comments and typos fixed, no functional
    changes.  Particularly,
    - avoid the kerneldoc marker "/**",
    - reduce multiple comment lines into single lines,
    - corrected wrongly referred function names
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 819e06b3f3db..9024acb2b850 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -43,34 +43,22 @@ struct toneport_led {
 };
 
 struct usb_line6_toneport {
-	/**
-		Generic Line 6 USB data.
-	*/
+	/* Generic Line 6 USB data */
 	struct usb_line6 line6;
 
-	/**
-		Source selector.
-	*/
+	/* Source selector */
 	int source;
 
-	/**
-		Serial number of device.
-	*/
+	/* Serial number of device */
 	int serial_number;
 
-	/**
-		Firmware version (x 100).
-	*/
+	/* Firmware version (x 100) */
 	int firmware_version;
 
-	/**
-		 Timer for delayed PCM startup.
-	*/
+	/* Timer for delayed PCM startup */
 	struct timer_list timer;
 
-	/**
-		 Device type.
-	*/
+	/* Device type */
 	enum line6_device_type type;
 
 	/* LED instances */

commit 247d95ee6dd22e5323ecf7a73ff64110ef2fa2da
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 27 16:42:14 2015 +0100

    ALSA: line6: Handle error from line6_pcm_acquire()
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 61fa6256d7b0..819e06b3f3db 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -182,16 +182,23 @@ static int snd_toneport_monitor_put(struct snd_kcontrol *kcontrol,
 				    struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);
+	int err;
 
 	if (ucontrol->value.integer.value[0] == line6pcm->volume_monitor)
 		return 0;
 
 	line6pcm->volume_monitor = ucontrol->value.integer.value[0];
 
-	if (line6pcm->volume_monitor > 0)
-		line6_pcm_acquire(line6pcm, LINE6_STREAM_MONITOR);
-	else
+	if (line6pcm->volume_monitor > 0) {
+		err = line6_pcm_acquire(line6pcm, LINE6_STREAM_MONITOR);
+		if (err < 0) {
+			line6pcm->volume_monitor = 0;
+			line6_pcm_release(line6pcm, LINE6_STREAM_MONITOR);
+			return err;
+		}
+	} else {
 		line6_pcm_release(line6pcm, LINE6_STREAM_MONITOR);
+	}
 
 	return 1;
 }

commit 63e20df1e5b2ef8d871ecbdb6c038d554ed1ca74
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 27 15:24:09 2015 +0100

    ALSA: line6: Reorganize PCM stream handling
    
    The current code deals with the stream start / stop solely via
    line6_pcm_acquire() and line6_pcm_release().  This was (supposedly)
    intended to avoid the races, but it doesn't work as expected.  The
    concurrent acquire and release calls can be performed without proper
    protections, thus this might result in memory corruption.
    Furthermore, we can't take a mutex to protect the whole function
    because it can be called from the PCM trigger callback that is an
    atomic context.  Also spinlock isn't appropriate because the function
    allocates with kmalloc with GFP_KERNEL.  That is, these function just
    lead to singular problems.
    
    This is an attempt to reduce the existing races.  First off, separate
    both the stream buffer management and the stream URB management.  The
    former is protected via a newly introduced state_mutex while the
    latter is protected via each line6_pcm_stream lock.
    
    Secondly, the stream state are now managed in opened and running bit
    flags of each line6_pcm_stream.  Not only this a bit clearer than
    previous combined bit flags, this also gives a better abstraction.
    These rewrites allows us to make common hw_params and hw_free
    callbacks for both playback and capture directions.
    
    For the monitor and impulse operations, still line6_pcm_acquire() and
    line6_pcm_release() are used.  They call internally the corresponding
    functions for both playback and capture streams with proper lock or
    mutex.  Unlike the previous versions, these function don't take the
    bit masks but the only single type value.  Also they are supposed to
    be applied only as duplex operations.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 33d16ecf18a0..61fa6256d7b0 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -189,9 +189,9 @@ static int snd_toneport_monitor_put(struct snd_kcontrol *kcontrol,
 	line6pcm->volume_monitor = ucontrol->value.integer.value[0];
 
 	if (line6pcm->volume_monitor > 0)
-		line6_pcm_acquire(line6pcm, LINE6_BITS_PCM_MONITOR);
+		line6_pcm_acquire(line6pcm, LINE6_STREAM_MONITOR);
 	else
-		line6_pcm_release(line6pcm, LINE6_BITS_PCM_MONITOR);
+		line6_pcm_release(line6pcm, LINE6_STREAM_MONITOR);
 
 	return 1;
 }
@@ -252,7 +252,7 @@ static void toneport_start_pcm(unsigned long arg)
 	struct usb_line6_toneport *toneport = (struct usb_line6_toneport *)arg;
 	struct usb_line6 *line6 = &toneport->line6;
 
-	line6_pcm_acquire(line6->line6pcm, LINE6_BITS_PCM_MONITOR);
+	line6_pcm_acquire(line6->line6pcm, LINE6_STREAM_MONITOR);
 }
 
 /* control definition */

commit aca514b82356dcc3575da33453382bd27593aea1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 25 18:36:29 2015 +0100

    ALSA: line6: Let snd_card_new() allocate private data
    
    Instead of allocating the private data individually in each driver's
    probe at first, let snd_card_new() allocate the data that is called in
    line6_probe().  This simplifies the primary probe functions.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 8e7020df0d10..33d16ecf18a0 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -558,14 +558,9 @@ static const struct line6_properties toneport_properties_table[] = {
 static int toneport_probe(struct usb_interface *interface,
 			  const struct usb_device_id *id)
 {
-	struct usb_line6_toneport *toneport;
-
-	toneport = kzalloc(sizeof(*toneport), GFP_KERNEL);
-	if (!toneport)
-		return -ENODEV;
-	return line6_probe(interface, id, &toneport->line6,
+	return line6_probe(interface, id,
 			   &toneport_properties_table[id->driver_info],
-			   toneport_init);
+			   toneport_init, sizeof(struct usb_line6_toneport));
 }
 
 static struct usb_driver toneport_driver = {

commit f66fd990c5db177d6b9f0eae301ca6b15882eb2e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 25 18:22:58 2015 +0100

    ALSA: line6: Drop interface argument from private_init and disconnect callbacks
    
    The interface argument is used just for retrieving the assigned
    device, which can be already found in line6->ifcdev.  Drop them from
    the callbacks.  Also, pass the usb id to private_init so that the
    driver can deal with it there.  This is a preliminary work for the
    further cleanup to move the whole allocation into driver.c.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 9a769463f7bf..8e7020df0d10 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -387,11 +387,11 @@ static void toneport_setup(struct usb_line6_toneport *toneport)
 /*
 	Toneport device disconnected.
 */
-static void line6_toneport_disconnect(struct usb_interface *interface)
+static void line6_toneport_disconnect(struct usb_line6 *line6)
 {
-	struct usb_line6_toneport *toneport;
+	struct usb_line6_toneport *toneport =
+		(struct usb_line6_toneport *)line6;
 
-	toneport = usb_get_intfdata(interface);
 	del_timer_sync(&toneport->timer);
 
 	if (toneport_has_led(toneport->type))
@@ -402,12 +402,13 @@ static void line6_toneport_disconnect(struct usb_interface *interface)
 /*
 	 Try to init Toneport device.
 */
-static int toneport_init(struct usb_interface *interface,
-			 struct usb_line6 *line6)
+static int toneport_init(struct usb_line6 *line6,
+			 const struct usb_device_id *id)
 {
 	int err;
 	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
 
+	toneport->type = id->driver_info;
 	setup_timer(&toneport->timer, toneport_start_pcm,
 		    (unsigned long)toneport);
 
@@ -562,8 +563,7 @@ static int toneport_probe(struct usb_interface *interface,
 	toneport = kzalloc(sizeof(*toneport), GFP_KERNEL);
 	if (!toneport)
 		return -ENODEV;
-	toneport->type = id->driver_info;
-	return line6_probe(interface, &toneport->line6,
+	return line6_probe(interface, id, &toneport->line6,
 			   &toneport_properties_table[id->driver_info],
 			   toneport_init);
 }

commit f44edd7b2bbeddef602fe84d3b175818024d7fce
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 20 09:36:31 2015 +0100

    ALSA: line6/toneport: Implement LED controls via LED class
    
    Instead of non-standard sysfs, reimplement the LED controls on
    TonePort as LED class devices.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 9a4f5403569e..9a769463f7bf 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -14,6 +14,7 @@
 #include <linux/usb.h>
 #include <linux/slab.h>
 #include <linux/module.h>
+#include <linux/leds.h>
 #include <sound/core.h>
 #include <sound/control.h>
 
@@ -32,6 +33,15 @@ enum line6_device_type {
 	LINE6_TONEPORT_UX2,
 };
 
+struct usb_line6_toneport;
+
+struct toneport_led {
+	struct led_classdev dev;
+	char name[64];
+	struct usb_line6_toneport *toneport;
+	bool registered;
+};
+
 struct usb_line6_toneport {
 	/**
 		Generic Line 6 USB data.
@@ -62,6 +72,9 @@ struct usb_line6_toneport {
 		 Device type.
 	*/
 	enum line6_device_type type;
+
+	/* LED instances */
+	struct toneport_led leds[2];
 };
 
 static int toneport_send_cmd(struct usb_device *usbdev, int cmd1, int cmd2);
@@ -117,15 +130,6 @@ static struct line6_pcm_properties toneport_pcm_properties = {
 	.bytes_per_frame = 4
 };
 
-/*
-	For the led on Guitarport.
-	Brightness goes from 0x00 to 0x26. Set a value above this to have led
-	blink.
-	(void cmd_0x02(byte red, byte green)
-*/
-static int led_red = 0x00;
-static int led_green = 0x26;
-
 static const struct {
 	const char *name;
 	int code;
@@ -136,62 +140,6 @@ static const struct {
 	{"Inst & Mic", 0x0901}
 };
 
-static bool toneport_has_led(enum line6_device_type type)
-{
-	return
-	    (type == LINE6_GUITARPORT) ||
-	    (type == LINE6_TONEPORT_GX);
-	/* add your device here if you are missing support for the LEDs */
-}
-
-static void toneport_update_led(struct device *dev)
-{
-	struct usb_interface *interface = to_usb_interface(dev);
-	struct usb_line6_toneport *tp = usb_get_intfdata(interface);
-	struct usb_line6 *line6;
-
-	if (!tp)
-		return;
-
-	line6 = &tp->line6;
-	if (line6)
-		toneport_send_cmd(line6->usbdev, (led_red << 8) | 0x0002,
-				  led_green);
-}
-
-static ssize_t toneport_set_led_red(struct device *dev,
-				    struct device_attribute *attr,
-				    const char *buf, size_t count)
-{
-	int retval;
-
-	retval = kstrtoint(buf, 10, &led_red);
-	if (retval)
-		return retval;
-
-	toneport_update_led(dev);
-	return count;
-}
-
-static ssize_t toneport_set_led_green(struct device *dev,
-				      struct device_attribute *attr,
-				      const char *buf, size_t count)
-{
-	int retval;
-
-	retval = kstrtoint(buf, 10, &led_green);
-	if (retval)
-		return retval;
-
-	toneport_update_led(dev);
-	return count;
-}
-
-static DEVICE_ATTR(led_red, S_IWUSR | S_IRUGO, line6_nop_read,
-		   toneport_set_led_red);
-static DEVICE_ATTR(led_green, S_IWUSR | S_IRUGO, line6_nop_read,
-		   toneport_set_led_green);
-
 static int toneport_send_cmd(struct usb_device *usbdev, int cmd1, int cmd2)
 {
 	int ret;
@@ -329,6 +277,78 @@ static struct snd_kcontrol_new toneport_control_source = {
 	.put = snd_toneport_source_put
 };
 
+/*
+	For the led on Guitarport.
+	Brightness goes from 0x00 to 0x26. Set a value above this to have led
+	blink.
+	(void cmd_0x02(byte red, byte green)
+*/
+
+static bool toneport_has_led(enum line6_device_type type)
+{
+	return
+	    (type == LINE6_GUITARPORT) ||
+	    (type == LINE6_TONEPORT_GX);
+	/* add your device here if you are missing support for the LEDs */
+}
+
+static const char * const led_colors[2] = { "red", "green" };
+static const int led_init_vals[2] = { 0x00, 0x26 };
+
+static void toneport_update_led(struct usb_line6_toneport *toneport)
+{
+	toneport_send_cmd(toneport->line6.usbdev,
+			  (toneport->leds[0].dev.brightness << 8) | 0x0002,
+			  toneport->leds[1].dev.brightness);
+}
+
+static void toneport_led_brightness_set(struct led_classdev *led_cdev,
+					enum led_brightness brightness)
+{
+	struct toneport_led *leds =
+		container_of(led_cdev, struct toneport_led, dev);
+	toneport_update_led(leds->toneport);
+}
+
+static int toneport_init_leds(struct usb_line6_toneport *toneport)
+{
+	struct device *dev = &toneport->line6.usbdev->dev;
+	int i, err;
+
+	for (i = 0; i < 2; i++) {
+		struct toneport_led *led = &toneport->leds[i];
+		struct led_classdev *leddev = &led->dev;
+
+		led->toneport = toneport;
+		snprintf(led->name, sizeof(led->name), "%s::%s",
+			 dev_name(dev), led_colors[i]);
+		leddev->name = led->name;
+		leddev->brightness = led_init_vals[i];
+		leddev->max_brightness = 0x26;
+		leddev->brightness_set = toneport_led_brightness_set;
+		err = led_classdev_register(dev, leddev);
+		if (err)
+			return err;
+		led->registered = true;
+	}
+
+	return 0;
+}
+
+static void toneport_remove_leds(struct usb_line6_toneport *toneport)
+{
+	struct toneport_led *led;
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		led = &toneport->leds[i];
+		if (!led->registered)
+			break;
+		led_classdev_unregister(&led->dev);
+		led->registered = false;
+	}
+}
+
 /*
 	Setup Toneport device.
 */
@@ -359,7 +379,7 @@ static void toneport_setup(struct usb_line6_toneport *toneport)
 	}
 
 	if (toneport_has_led(toneport->type))
-		toneport_update_led(&usbdev->dev);
+		toneport_update_led(toneport);
 
 	mod_timer(&toneport->timer, jiffies + TONEPORT_PCM_DELAY * HZ);
 }
@@ -374,10 +394,8 @@ static void line6_toneport_disconnect(struct usb_interface *interface)
 	toneport = usb_get_intfdata(interface);
 	del_timer_sync(&toneport->timer);
 
-	if (toneport_has_led(toneport->type)) {
-		device_remove_file(&interface->dev, &dev_attr_led_red);
-		device_remove_file(&interface->dev, &dev_attr_led_green);
-	}
+	if (toneport_has_led(toneport->type))
+		toneport_remove_leds(toneport);
 }
 
 
@@ -428,10 +446,7 @@ static int toneport_init(struct usb_interface *interface,
 	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);
 
 	if (toneport_has_led(toneport->type)) {
-		err = device_create_file(&interface->dev, &dev_attr_led_red);
-		if (err < 0)
-			return err;
-		err = device_create_file(&interface->dev, &dev_attr_led_green);
+		err = toneport_init_leds(toneport);
 		if (err < 0)
 			return err;
 	}

commit bf115fcf957f080a1766bb785e23980c1440d06e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 20 08:55:06 2015 +0100

    ALSA: line6/toneport: Fix wrong argument for toneport_has_led()
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index fb6d5e1e2ade..9a4f5403569e 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -370,13 +370,11 @@ static void toneport_setup(struct usb_line6_toneport *toneport)
 static void line6_toneport_disconnect(struct usb_interface *interface)
 {
 	struct usb_line6_toneport *toneport;
-	u16 idProduct;
 
 	toneport = usb_get_intfdata(interface);
 	del_timer_sync(&toneport->timer);
-	idProduct = le16_to_cpu(toneport->line6.usbdev->descriptor.idProduct);
 
-	if (toneport_has_led(idProduct)) {
+	if (toneport_has_led(toneport->type)) {
 		device_remove_file(&interface->dev, &dev_attr_led_red);
 		device_remove_file(&interface->dev, &dev_attr_led_green);
 	}

commit 6dd1c05cd7c26a463bbcca1ab50b59b86d88de64
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 20 09:40:20 2015 +0100

    ALSA: line6/toneport: Move setup_timer() at the beginning
    
    ... so that timer_del_sync() in the destructor can be called safely at
    any time.  Also move the mod_timer() call in toneport_setup(), which
    is a bit clearer place.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index e5669bd3233a..fb6d5e1e2ade 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -360,6 +360,8 @@ static void toneport_setup(struct usb_line6_toneport *toneport)
 
 	if (toneport_has_led(toneport->type))
 		toneport_update_led(&usbdev->dev);
+
+	mod_timer(&toneport->timer, jiffies + TONEPORT_PCM_DELAY * HZ);
 }
 
 /*
@@ -390,6 +392,9 @@ static int toneport_init(struct usb_interface *interface,
 	int err;
 	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
 
+	setup_timer(&toneport->timer, toneport_start_pcm,
+		    (unsigned long)toneport);
+
 	line6->disconnect = line6_toneport_disconnect;
 
 	/* initialize PCM subsystem: */
@@ -435,10 +440,6 @@ static int toneport_init(struct usb_interface *interface,
 
 	toneport_setup(toneport);
 
-	setup_timer(&toneport->timer, toneport_start_pcm,
-		    (unsigned long)toneport);
-	mod_timer(&toneport->timer, jiffies + TONEPORT_PCM_DELAY * HZ);
-
 	/* register audio system: */
 	return snd_card_register(line6->card);
 }

commit 8a3b7c086a509d90c312ebab6d8e5a9bf48c6cf5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 20 08:42:42 2015 +0100

    ALSA: line6: Remove superfluous NULL checks in each driver
    
    The interface and driver objects are always set when callbacks are
    called.  Drop such superfluous NULL checks in init and disconnect
    calls of each driver.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index c1f61cde52ab..e5669bd3233a 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -370,9 +370,6 @@ static void line6_toneport_disconnect(struct usb_interface *interface)
 	struct usb_line6_toneport *toneport;
 	u16 idProduct;
 
-	if (interface == NULL)
-		return;
-
 	toneport = usb_get_intfdata(interface);
 	del_timer_sync(&toneport->timer);
 	idProduct = le16_to_cpu(toneport->line6.usbdev->descriptor.idProduct);
@@ -393,9 +390,6 @@ static int toneport_init(struct usb_interface *interface,
 	int err;
 	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
 
-	if ((interface == NULL) || (toneport == NULL))
-		return -ENODEV;
-
 	line6->disconnect = line6_toneport_disconnect;
 
 	/* initialize PCM subsystem: */

commit c078a4aac2944cb9cac5cdb4e9a482623435578b
Author: Chris Rorvick <chris@rorvick.com>
Date:   Tue Jan 20 02:20:50 2015 -0600

    ALSA: line6: Remove driver version from header comment
    
    The driver version string was removed in an ealier commit for being
    useless.  These are equally useless.
    
    Signed-off-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 77ad98c1a948..c1f61cde52ab 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -1,5 +1,5 @@
 /*
- * Line 6 Linux USB driver - 0.9.1beta
+ * Line 6 Linux USB driver
  *
  * Copyright (C) 2004-2010 Markus Grabner (grabner@icg.tugraz.at)
  *                         Emil Myhrman (emil.myhrman@gmail.com)

commit c6fffce92e1a8cda8c1b552f5a24295839f3f93a
Author: Chris Rorvick <chris@rorvick.com>
Date:   Tue Jan 20 02:20:49 2015 -0600

    ALSA: line6: Refer to manufacturer as "Line 6"
    
    The correct spelling includes the space.  Fix this in strings and
    comments that refer to the manufacturer.
    
    Signed-off-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 24544b7ab476..77ad98c1a948 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -1,5 +1,5 @@
 /*
- * Line6 Linux USB driver - 0.9.1beta
+ * Line 6 Linux USB driver - 0.9.1beta
  *
  * Copyright (C) 2004-2010 Markus Grabner (grabner@icg.tugraz.at)
  *                         Emil Myhrman (emil.myhrman@gmail.com)
@@ -34,7 +34,7 @@ enum line6_device_type {
 
 struct usb_line6_toneport {
 	/**
-		Generic Line6 USB data.
+		Generic Line 6 USB data.
 	*/
 	struct usb_line6 line6;
 

commit b2a3b02392836b8cc0aa4246d7496028911f1539
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 16:08:02 2015 +0100

    ALSA: line6: Remove CHECK_RETURN macro
    
    Such a macro doesn't improve readability.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 3097a75a9bec..24544b7ab476 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -431,10 +431,12 @@ static int toneport_init(struct usb_interface *interface,
 	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);
 
 	if (toneport_has_led(toneport->type)) {
-		CHECK_RETURN(device_create_file
-			     (&interface->dev, &dev_attr_led_red));
-		CHECK_RETURN(device_create_file
-			     (&interface->dev, &dev_attr_led_green));
+		err = device_create_file(&interface->dev, &dev_attr_led_red);
+		if (err < 0)
+			return err;
+		err = device_create_file(&interface->dev, &dev_attr_led_green);
+		if (err < 0)
+			return err;
 	}
 
 	toneport_setup(toneport);

commit 85a9339becf0af4d547ceb6bb16d1893b05fbce4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 15:54:00 2015 +0100

    ALSA: line6: Reorganize card resource handling
    
    This is a fairly big rewrite regarding the card resource management in
    line6 drivers:
    
    - The card creation is moved into line6_probe().  This adds the global
      destructor to private_free, so that each driver doesn't have to call
      it any longer.
    
    - The USB disconnect callback handles the card release, thus each
      driver needs to concentrate on only its own resources.  No need to
      snd_card_*() call in the destructor.
    
    - Fix the potential stall in disconnection by removing
      snd_card_free().   It's replaced with snd_card_free_when_closed()
      for asynchronous release.
    
    - The only remaining operation for the card in each driver is the call
      of snd_card_register().  All the rest are dealt in the common module
      by itself.
    
    - These ended up with removal of audio.[ch] as a result of a reduction
      of one layer.  Each driver just needs to call line6_probe().
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 6ec3268a6153..3097a75a9bec 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -17,7 +17,6 @@
 #include <sound/core.h>
 #include <sound/control.h>
 
-#include "audio.h"
 #include "capture.h"
 #include "driver.h"
 #include "playback.h"
@@ -330,18 +329,6 @@ static struct snd_kcontrol_new toneport_control_source = {
 	.put = snd_toneport_source_put
 };
 
-/*
-	Toneport destructor.
-*/
-static void toneport_destruct(struct usb_interface *interface)
-{
-	struct usb_line6_toneport *toneport = usb_get_intfdata(interface);
-
-	if (toneport == NULL)
-		return;
-	line6_cleanup_audio(&toneport->line6);
-}
-
 /*
 	Setup Toneport device.
 */
@@ -394,25 +381,14 @@ static void line6_toneport_disconnect(struct usb_interface *interface)
 		device_remove_file(&interface->dev, &dev_attr_led_red);
 		device_remove_file(&interface->dev, &dev_attr_led_green);
 	}
-
-	if (toneport != NULL) {
-		struct snd_line6_pcm *line6pcm = toneport->line6.line6pcm;
-
-		if (line6pcm != NULL) {
-			line6_pcm_release(line6pcm, LINE6_BITS_PCM_MONITOR);
-			line6_pcm_disconnect(line6pcm);
-		}
-	}
-
-	toneport_destruct(interface);
 }
 
 
 /*
 	 Try to init Toneport device.
 */
-static int toneport_try_init(struct usb_interface *interface,
-			     struct usb_line6 *line6)
+static int toneport_init(struct usb_interface *interface,
+			 struct usb_line6 *line6)
 {
 	int err;
 	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
@@ -422,11 +398,6 @@ static int toneport_try_init(struct usb_interface *interface,
 
 	line6->disconnect = line6_toneport_disconnect;
 
-	/* initialize audio system: */
-	err = line6_init_audio(line6);
-	if (err < 0)
-		return err;
-
 	/* initialize PCM subsystem: */
 	err = line6_init_pcm(line6, &toneport_pcm_properties);
 	if (err < 0)
@@ -456,11 +427,6 @@ static int toneport_try_init(struct usb_interface *interface,
 		break;
 	}
 
-	/* register audio system: */
-	err = line6_register_audio(line6);
-	if (err < 0)
-		return err;
-
 	line6_read_serial_number(line6, &toneport->serial_number);
 	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);
 
@@ -477,21 +443,8 @@ static int toneport_try_init(struct usb_interface *interface,
 		    (unsigned long)toneport);
 	mod_timer(&toneport->timer, jiffies + TONEPORT_PCM_DELAY * HZ);
 
-	return 0;
-}
-
-/*
-	 Init Toneport device (and clean up in case of failure).
-*/
-static int toneport_init(struct usb_interface *interface,
-			 struct usb_line6 *line6)
-{
-	int err = toneport_try_init(interface, line6);
-
-	if (err < 0)
-		toneport_destruct(interface);
-
-	return err;
+	/* register audio system: */
+	return snd_card_register(line6->card);
 }
 
 #ifdef CONFIG_PM
@@ -595,18 +548,14 @@ static int toneport_probe(struct usb_interface *interface,
 			  const struct usb_device_id *id)
 {
 	struct usb_line6_toneport *toneport;
-	int err;
 
 	toneport = kzalloc(sizeof(*toneport), GFP_KERNEL);
 	if (!toneport)
 		return -ENODEV;
 	toneport->type = id->driver_info;
-	err = line6_probe(interface, &toneport->line6,
-			  &toneport_properties_table[id->driver_info],
-			  toneport_init);
-	if (err < 0)
-		kfree(toneport);
-	return err;
+	return line6_probe(interface, &toneport->line6,
+			   &toneport_properties_table[id->driver_info],
+			   toneport_init);
 }
 
 static struct usb_driver toneport_driver = {

commit 988d350aef30b798198e7915c574f82ba173f40f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 14:58:29 2015 +0100

    ALSA: line6: Drop invalid SNDRV_PCM_INFO_RESUME flag
    
    The line6 drivers don't support the full resume although they set
    SNDRV_PCM_INFO_RESUME.  These flags have to be dropped to inform
    properly to the user-space.
    
    Also, drop the CONFIG_PM in trigger callbacks, too, which are rather
    superfluous.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 4f07643e47f2..6ec3268a6153 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -83,9 +83,6 @@ static struct line6_pcm_properties toneport_pcm_properties = {
 					   SNDRV_PCM_INFO_BLOCK_TRANSFER |
 					   SNDRV_PCM_INFO_MMAP_VALID |
 					   SNDRV_PCM_INFO_PAUSE |
-#ifdef CONFIG_PM
-					   SNDRV_PCM_INFO_RESUME |
-#endif
 					   SNDRV_PCM_INFO_SYNC_START),
 				  .formats = SNDRV_PCM_FMTBIT_S16_LE,
 				  .rates = SNDRV_PCM_RATE_KNOT,
@@ -103,9 +100,6 @@ static struct line6_pcm_properties toneport_pcm_properties = {
 					  SNDRV_PCM_INFO_INTERLEAVED |
 					  SNDRV_PCM_INFO_BLOCK_TRANSFER |
 					  SNDRV_PCM_INFO_MMAP_VALID |
-#ifdef CONFIG_PM
-					  SNDRV_PCM_INFO_RESUME |
-#endif
 					  SNDRV_PCM_INFO_SYNC_START),
 				 .formats = SNDRV_PCM_FMTBIT_S16_LE,
 				 .rates = SNDRV_PCM_RATE_KNOT,

commit ccddbe4a99536154e61d16c0f1c2df8a6d63f52a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 15 08:22:31 2015 +0100

    ALSA: line6: Split to each driver
    
    Split to each individual driver for POD, PODHD, TonePort and Variax
    with a core LINE6 helper module.  The new modules follow the standard
    ALSA naming rule with snd prefix: snd-usb-pod, snd-usb-podhd,
    snd-usb-toneport and snd-usb-variax, together with the corresponding
    CONFIG_SND_USB_* Kconfig items.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index 7f97f4a812a7..4f07643e47f2 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -11,13 +11,59 @@
  */
 
 #include <linux/wait.h>
+#include <linux/usb.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <sound/core.h>
 #include <sound/control.h>
 
 #include "audio.h"
 #include "capture.h"
 #include "driver.h"
 #include "playback.h"
-#include "toneport.h"
+#include "usbdefs.h"
+
+enum line6_device_type {
+	LINE6_GUITARPORT,
+	LINE6_PODSTUDIO_GX,
+	LINE6_PODSTUDIO_UX1,
+	LINE6_PODSTUDIO_UX2,
+	LINE6_TONEPORT_GX,
+	LINE6_TONEPORT_UX1,
+	LINE6_TONEPORT_UX2,
+};
+
+struct usb_line6_toneport {
+	/**
+		Generic Line6 USB data.
+	*/
+	struct usb_line6 line6;
+
+	/**
+		Source selector.
+	*/
+	int source;
+
+	/**
+		Serial number of device.
+	*/
+	int serial_number;
+
+	/**
+		Firmware version (x 100).
+	*/
+	int firmware_version;
+
+	/**
+		 Timer for delayed PCM startup.
+	*/
+	struct timer_list timer;
+
+	/**
+		 Device type.
+	*/
+	enum line6_device_type type;
+};
 
 static int toneport_send_cmd(struct usb_device *usbdev, int cmd1, int cmd2);
 
@@ -319,7 +365,7 @@ static void toneport_setup(struct usb_line6_toneport *toneport)
 	toneport_send_cmd(usbdev, 0x0301, 0x0000);
 
 	/* initialize source select: */
-	switch (line6->type) {
+	switch (toneport->type) {
 	case LINE6_TONEPORT_UX1:
 	case LINE6_TONEPORT_UX2:
 	case LINE6_PODSTUDIO_UX1:
@@ -331,7 +377,7 @@ static void toneport_setup(struct usb_line6_toneport *toneport)
 		break;
 	}
 
-	if (toneport_has_led(line6->type))
+	if (toneport_has_led(toneport->type))
 		toneport_update_led(&usbdev->dev);
 }
 
@@ -400,7 +446,7 @@ static int toneport_try_init(struct usb_interface *interface,
 		return err;
 
 	/* register source select control: */
-	switch (line6->type) {
+	switch (toneport->type) {
 	case LINE6_TONEPORT_UX1:
 	case LINE6_TONEPORT_UX2:
 	case LINE6_PODSTUDIO_UX1:
@@ -424,7 +470,7 @@ static int toneport_try_init(struct usb_interface *interface,
 	line6_read_serial_number(line6, &toneport->serial_number);
 	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);
 
-	if (toneport_has_led(line6->type)) {
+	if (toneport_has_led(toneport->type)) {
 		CHECK_RETURN(device_create_file
 			     (&interface->dev, &dev_attr_led_red));
 		CHECK_RETURN(device_create_file
@@ -443,8 +489,8 @@ static int toneport_try_init(struct usb_interface *interface,
 /*
 	 Init Toneport device (and clean up in case of failure).
 */
-int line6_toneport_init(struct usb_interface *interface,
-			struct usb_line6 *line6)
+static int toneport_init(struct usb_interface *interface,
+			 struct usb_line6 *line6)
 {
 	int err = toneport_try_init(interface, line6);
 
@@ -454,10 +500,134 @@ int line6_toneport_init(struct usb_interface *interface,
 	return err;
 }
 
+#ifdef CONFIG_PM
 /*
 	Resume Toneport device after reset.
 */
-void line6_toneport_reset_resume(struct usb_line6_toneport *toneport)
+static int toneport_reset_resume(struct usb_interface *interface)
 {
-	toneport_setup(toneport);
+	toneport_setup(usb_get_intfdata(interface));
+	return line6_resume(interface);
 }
+#endif
+
+#define LINE6_DEVICE(prod) USB_DEVICE(0x0e41, prod)
+#define LINE6_IF_NUM(prod, n) USB_DEVICE_INTERFACE_NUMBER(0x0e41, prod, n)
+
+/* table of devices that work with this driver */
+static const struct usb_device_id toneport_id_table[] = {
+	{ LINE6_DEVICE(0x4750),    .driver_info = LINE6_GUITARPORT },
+	{ LINE6_DEVICE(0x4153),    .driver_info = LINE6_PODSTUDIO_GX },
+	{ LINE6_DEVICE(0x4150),    .driver_info = LINE6_PODSTUDIO_UX1 },
+	{ LINE6_IF_NUM(0x4151, 0), .driver_info = LINE6_PODSTUDIO_UX2 },
+	{ LINE6_DEVICE(0x4147),    .driver_info = LINE6_TONEPORT_GX },
+	{ LINE6_DEVICE(0x4141),    .driver_info = LINE6_TONEPORT_UX1 },
+	{ LINE6_IF_NUM(0x4142, 0), .driver_info = LINE6_TONEPORT_UX2 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(usb, toneport_id_table);
+
+static const struct line6_properties toneport_properties_table[] = {
+	[LINE6_GUITARPORT] = {
+		.id = "GuitarPort",
+		.name = "GuitarPort",
+		.capabilities	= LINE6_CAP_PCM,
+		.altsetting = 2,  /* 1..4 seem to be ok */
+		/* no control channel */
+		.ep_audio_r = 0x82,
+		.ep_audio_w = 0x01,
+	},
+	[LINE6_PODSTUDIO_GX] = {
+		.id = "PODStudioGX",
+		.name = "POD Studio GX",
+		.capabilities	= LINE6_CAP_PCM,
+		.altsetting = 2,  /* 1..4 seem to be ok */
+		/* no control channel */
+		.ep_audio_r = 0x82,
+		.ep_audio_w = 0x01,
+	},
+	[LINE6_PODSTUDIO_UX1] = {
+		.id = "PODStudioUX1",
+		.name = "POD Studio UX1",
+		.capabilities	= LINE6_CAP_PCM,
+		.altsetting = 2,  /* 1..4 seem to be ok */
+		/* no control channel */
+		.ep_audio_r = 0x82,
+		.ep_audio_w = 0x01,
+	},
+	[LINE6_PODSTUDIO_UX2] = {
+		.id = "PODStudioUX2",
+		.name = "POD Studio UX2",
+		.capabilities	= LINE6_CAP_PCM,
+		.altsetting = 2,  /* defaults to 44.1kHz, 16-bit */
+		/* no control channel */
+		.ep_audio_r = 0x82,
+		.ep_audio_w = 0x01,
+	},
+	[LINE6_TONEPORT_GX] = {
+		.id = "TonePortGX",
+		.name = "TonePort GX",
+		.capabilities	= LINE6_CAP_PCM,
+		.altsetting = 2,  /* 1..4 seem to be ok */
+		/* no control channel */
+		.ep_audio_r = 0x82,
+		.ep_audio_w = 0x01,
+	},
+	[LINE6_TONEPORT_UX1] = {
+		.id = "TonePortUX1",
+		.name = "TonePort UX1",
+		.capabilities	= LINE6_CAP_PCM,
+		.altsetting = 2,  /* 1..4 seem to be ok */
+		/* no control channel */
+		.ep_audio_r = 0x82,
+		.ep_audio_w = 0x01,
+	},
+	[LINE6_TONEPORT_UX2] = {
+		.id = "TonePortUX2",
+		.name = "TonePort UX2",
+		.capabilities	= LINE6_CAP_PCM,
+		.altsetting = 2,  /* defaults to 44.1kHz, 16-bit */
+		/* no control channel */
+		.ep_audio_r = 0x82,
+		.ep_audio_w = 0x01,
+	},
+};
+
+/*
+	Probe USB device.
+*/
+static int toneport_probe(struct usb_interface *interface,
+			  const struct usb_device_id *id)
+{
+	struct usb_line6_toneport *toneport;
+	int err;
+
+	toneport = kzalloc(sizeof(*toneport), GFP_KERNEL);
+	if (!toneport)
+		return -ENODEV;
+	toneport->type = id->driver_info;
+	err = line6_probe(interface, &toneport->line6,
+			  &toneport_properties_table[id->driver_info],
+			  toneport_init);
+	if (err < 0)
+		kfree(toneport);
+	return err;
+}
+
+static struct usb_driver toneport_driver = {
+	.name = KBUILD_MODNAME,
+	.probe = toneport_probe,
+	.disconnect = line6_disconnect,
+#ifdef CONFIG_PM
+	.suspend = line6_suspend,
+	.resume = line6_resume,
+	.reset_resume = toneport_reset_resume,
+#endif
+	.id_table = toneport_id_table,
+};
+
+module_usb_driver(toneport_driver);
+
+MODULE_DESCRIPTION("TonePort USB driver");
+MODULE_LICENSE("GPL");

commit 0f2524b347b1ce16ce6a34cb194445e25bc6ae42
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 11:44:40 2015 +0100

    ALSA: line6: Use setup_timer() and mod_timer()
    
    No functional change, refactoring with the standard helpers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
index aae78d8a82d9..7f97f4a812a7 100644
--- a/sound/usb/line6/toneport.c
+++ b/sound/usb/line6/toneport.c
@@ -433,11 +433,9 @@ static int toneport_try_init(struct usb_interface *interface,
 
 	toneport_setup(toneport);
 
-	init_timer(&toneport->timer);
-	toneport->timer.expires = jiffies + TONEPORT_PCM_DELAY * HZ;
-	toneport->timer.function = toneport_start_pcm;
-	toneport->timer.data = (unsigned long)toneport;
-	add_timer(&toneport->timer);
+	setup_timer(&toneport->timer, toneport_start_pcm,
+		    (unsigned long)toneport);
+	mod_timer(&toneport->timer, jiffies + TONEPORT_PCM_DELAY * HZ);
 
 	return 0;
 }

commit 61864d844c296933d40c02683252bbea5193b101
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 12 22:29:57 2015 +0100

    ALSA: move line6 usb driver into sound/usb
    
    Promote line6 driver from staging to sound/usb/line6 directory, and
    maintain through sound subsystem tree.
    
    This commit just moves the code and adapts Makefile / Kconfig.
    The further renames and misc cleanups will follow.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/toneport.c b/sound/usb/line6/toneport.c
new file mode 100644
index 000000000000..aae78d8a82d9
--- /dev/null
+++ b/sound/usb/line6/toneport.c
@@ -0,0 +1,465 @@
+/*
+ * Line6 Linux USB driver - 0.9.1beta
+ *
+ * Copyright (C) 2004-2010 Markus Grabner (grabner@icg.tugraz.at)
+ *                         Emil Myhrman (emil.myhrman@gmail.com)
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2.
+ *
+ */
+
+#include <linux/wait.h>
+#include <sound/control.h>
+
+#include "audio.h"
+#include "capture.h"
+#include "driver.h"
+#include "playback.h"
+#include "toneport.h"
+
+static int toneport_send_cmd(struct usb_device *usbdev, int cmd1, int cmd2);
+
+#define TONEPORT_PCM_DELAY 1
+
+static struct snd_ratden toneport_ratden = {
+	.num_min = 44100,
+	.num_max = 44100,
+	.num_step = 1,
+	.den = 1
+};
+
+static struct line6_pcm_properties toneport_pcm_properties = {
+	.snd_line6_playback_hw = {
+				  .info = (SNDRV_PCM_INFO_MMAP |
+					   SNDRV_PCM_INFO_INTERLEAVED |
+					   SNDRV_PCM_INFO_BLOCK_TRANSFER |
+					   SNDRV_PCM_INFO_MMAP_VALID |
+					   SNDRV_PCM_INFO_PAUSE |
+#ifdef CONFIG_PM
+					   SNDRV_PCM_INFO_RESUME |
+#endif
+					   SNDRV_PCM_INFO_SYNC_START),
+				  .formats = SNDRV_PCM_FMTBIT_S16_LE,
+				  .rates = SNDRV_PCM_RATE_KNOT,
+				  .rate_min = 44100,
+				  .rate_max = 44100,
+				  .channels_min = 2,
+				  .channels_max = 2,
+				  .buffer_bytes_max = 60000,
+				  .period_bytes_min = 64,
+				  .period_bytes_max = 8192,
+				  .periods_min = 1,
+				  .periods_max = 1024},
+	.snd_line6_capture_hw = {
+				 .info = (SNDRV_PCM_INFO_MMAP |
+					  SNDRV_PCM_INFO_INTERLEAVED |
+					  SNDRV_PCM_INFO_BLOCK_TRANSFER |
+					  SNDRV_PCM_INFO_MMAP_VALID |
+#ifdef CONFIG_PM
+					  SNDRV_PCM_INFO_RESUME |
+#endif
+					  SNDRV_PCM_INFO_SYNC_START),
+				 .formats = SNDRV_PCM_FMTBIT_S16_LE,
+				 .rates = SNDRV_PCM_RATE_KNOT,
+				 .rate_min = 44100,
+				 .rate_max = 44100,
+				 .channels_min = 2,
+				 .channels_max = 2,
+				 .buffer_bytes_max = 60000,
+				 .period_bytes_min = 64,
+				 .period_bytes_max = 8192,
+				 .periods_min = 1,
+				 .periods_max = 1024},
+	.snd_line6_rates = {
+			    .nrats = 1,
+			    .rats = &toneport_ratden},
+	.bytes_per_frame = 4
+};
+
+/*
+	For the led on Guitarport.
+	Brightness goes from 0x00 to 0x26. Set a value above this to have led
+	blink.
+	(void cmd_0x02(byte red, byte green)
+*/
+static int led_red = 0x00;
+static int led_green = 0x26;
+
+static const struct {
+	const char *name;
+	int code;
+} toneport_source_info[] = {
+	{"Microphone", 0x0a01},
+	{"Line", 0x0801},
+	{"Instrument", 0x0b01},
+	{"Inst & Mic", 0x0901}
+};
+
+static bool toneport_has_led(enum line6_device_type type)
+{
+	return
+	    (type == LINE6_GUITARPORT) ||
+	    (type == LINE6_TONEPORT_GX);
+	/* add your device here if you are missing support for the LEDs */
+}
+
+static void toneport_update_led(struct device *dev)
+{
+	struct usb_interface *interface = to_usb_interface(dev);
+	struct usb_line6_toneport *tp = usb_get_intfdata(interface);
+	struct usb_line6 *line6;
+
+	if (!tp)
+		return;
+
+	line6 = &tp->line6;
+	if (line6)
+		toneport_send_cmd(line6->usbdev, (led_red << 8) | 0x0002,
+				  led_green);
+}
+
+static ssize_t toneport_set_led_red(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	int retval;
+
+	retval = kstrtoint(buf, 10, &led_red);
+	if (retval)
+		return retval;
+
+	toneport_update_led(dev);
+	return count;
+}
+
+static ssize_t toneport_set_led_green(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	int retval;
+
+	retval = kstrtoint(buf, 10, &led_green);
+	if (retval)
+		return retval;
+
+	toneport_update_led(dev);
+	return count;
+}
+
+static DEVICE_ATTR(led_red, S_IWUSR | S_IRUGO, line6_nop_read,
+		   toneport_set_led_red);
+static DEVICE_ATTR(led_green, S_IWUSR | S_IRUGO, line6_nop_read,
+		   toneport_set_led_green);
+
+static int toneport_send_cmd(struct usb_device *usbdev, int cmd1, int cmd2)
+{
+	int ret;
+
+	ret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0), 0x67,
+			      USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,
+			      cmd1, cmd2, NULL, 0, LINE6_TIMEOUT * HZ);
+
+	if (ret < 0) {
+		dev_err(&usbdev->dev, "send failed (error %d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+/* monitor info callback */
+static int snd_toneport_monitor_info(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 256;
+	return 0;
+}
+
+/* monitor get callback */
+static int snd_toneport_monitor_get(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.integer.value[0] = line6pcm->volume_monitor;
+	return 0;
+}
+
+/* monitor put callback */
+static int snd_toneport_monitor_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);
+
+	if (ucontrol->value.integer.value[0] == line6pcm->volume_monitor)
+		return 0;
+
+	line6pcm->volume_monitor = ucontrol->value.integer.value[0];
+
+	if (line6pcm->volume_monitor > 0)
+		line6_pcm_acquire(line6pcm, LINE6_BITS_PCM_MONITOR);
+	else
+		line6_pcm_release(line6pcm, LINE6_BITS_PCM_MONITOR);
+
+	return 1;
+}
+
+/* source info callback */
+static int snd_toneport_source_info(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
+{
+	const int size = ARRAY_SIZE(toneport_source_info);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = size;
+
+	if (uinfo->value.enumerated.item >= size)
+		uinfo->value.enumerated.item = size - 1;
+
+	strcpy(uinfo->value.enumerated.name,
+	       toneport_source_info[uinfo->value.enumerated.item].name);
+
+	return 0;
+}
+
+/* source get callback */
+static int snd_toneport_source_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);
+	struct usb_line6_toneport *toneport =
+	    (struct usb_line6_toneport *)line6pcm->line6;
+	ucontrol->value.enumerated.item[0] = toneport->source;
+	return 0;
+}
+
+/* source put callback */
+static int snd_toneport_source_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);
+	struct usb_line6_toneport *toneport =
+	    (struct usb_line6_toneport *)line6pcm->line6;
+	unsigned int source;
+
+	source = ucontrol->value.enumerated.item[0];
+	if (source >= ARRAY_SIZE(toneport_source_info))
+		return -EINVAL;
+	if (source == toneport->source)
+		return 0;
+
+	toneport->source = source;
+	toneport_send_cmd(toneport->line6.usbdev,
+			  toneport_source_info[source].code, 0x0000);
+	return 1;
+}
+
+static void toneport_start_pcm(unsigned long arg)
+{
+	struct usb_line6_toneport *toneport = (struct usb_line6_toneport *)arg;
+	struct usb_line6 *line6 = &toneport->line6;
+
+	line6_pcm_acquire(line6->line6pcm, LINE6_BITS_PCM_MONITOR);
+}
+
+/* control definition */
+static struct snd_kcontrol_new toneport_control_monitor = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Monitor Playback Volume",
+	.index = 0,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.info = snd_toneport_monitor_info,
+	.get = snd_toneport_monitor_get,
+	.put = snd_toneport_monitor_put
+};
+
+/* source selector definition */
+static struct snd_kcontrol_new toneport_control_source = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "PCM Capture Source",
+	.index = 0,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.info = snd_toneport_source_info,
+	.get = snd_toneport_source_get,
+	.put = snd_toneport_source_put
+};
+
+/*
+	Toneport destructor.
+*/
+static void toneport_destruct(struct usb_interface *interface)
+{
+	struct usb_line6_toneport *toneport = usb_get_intfdata(interface);
+
+	if (toneport == NULL)
+		return;
+	line6_cleanup_audio(&toneport->line6);
+}
+
+/*
+	Setup Toneport device.
+*/
+static void toneport_setup(struct usb_line6_toneport *toneport)
+{
+	int ticks;
+	struct usb_line6 *line6 = &toneport->line6;
+	struct usb_device *usbdev = line6->usbdev;
+
+	/* sync time on device with host: */
+	ticks = (int)get_seconds();
+	line6_write_data(line6, 0x80c6, &ticks, 4);
+
+	/* enable device: */
+	toneport_send_cmd(usbdev, 0x0301, 0x0000);
+
+	/* initialize source select: */
+	switch (line6->type) {
+	case LINE6_TONEPORT_UX1:
+	case LINE6_TONEPORT_UX2:
+	case LINE6_PODSTUDIO_UX1:
+	case LINE6_PODSTUDIO_UX2:
+		toneport_send_cmd(usbdev,
+				  toneport_source_info[toneport->source].code,
+				  0x0000);
+	default:
+		break;
+	}
+
+	if (toneport_has_led(line6->type))
+		toneport_update_led(&usbdev->dev);
+}
+
+/*
+	Toneport device disconnected.
+*/
+static void line6_toneport_disconnect(struct usb_interface *interface)
+{
+	struct usb_line6_toneport *toneport;
+	u16 idProduct;
+
+	if (interface == NULL)
+		return;
+
+	toneport = usb_get_intfdata(interface);
+	del_timer_sync(&toneport->timer);
+	idProduct = le16_to_cpu(toneport->line6.usbdev->descriptor.idProduct);
+
+	if (toneport_has_led(idProduct)) {
+		device_remove_file(&interface->dev, &dev_attr_led_red);
+		device_remove_file(&interface->dev, &dev_attr_led_green);
+	}
+
+	if (toneport != NULL) {
+		struct snd_line6_pcm *line6pcm = toneport->line6.line6pcm;
+
+		if (line6pcm != NULL) {
+			line6_pcm_release(line6pcm, LINE6_BITS_PCM_MONITOR);
+			line6_pcm_disconnect(line6pcm);
+		}
+	}
+
+	toneport_destruct(interface);
+}
+
+
+/*
+	 Try to init Toneport device.
+*/
+static int toneport_try_init(struct usb_interface *interface,
+			     struct usb_line6 *line6)
+{
+	int err;
+	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
+
+	if ((interface == NULL) || (toneport == NULL))
+		return -ENODEV;
+
+	line6->disconnect = line6_toneport_disconnect;
+
+	/* initialize audio system: */
+	err = line6_init_audio(line6);
+	if (err < 0)
+		return err;
+
+	/* initialize PCM subsystem: */
+	err = line6_init_pcm(line6, &toneport_pcm_properties);
+	if (err < 0)
+		return err;
+
+	/* register monitor control: */
+	err = snd_ctl_add(line6->card,
+			  snd_ctl_new1(&toneport_control_monitor,
+				       line6->line6pcm));
+	if (err < 0)
+		return err;
+
+	/* register source select control: */
+	switch (line6->type) {
+	case LINE6_TONEPORT_UX1:
+	case LINE6_TONEPORT_UX2:
+	case LINE6_PODSTUDIO_UX1:
+	case LINE6_PODSTUDIO_UX2:
+		err =
+		    snd_ctl_add(line6->card,
+				snd_ctl_new1(&toneport_control_source,
+					     line6->line6pcm));
+		if (err < 0)
+			return err;
+
+	default:
+		break;
+	}
+
+	/* register audio system: */
+	err = line6_register_audio(line6);
+	if (err < 0)
+		return err;
+
+	line6_read_serial_number(line6, &toneport->serial_number);
+	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);
+
+	if (toneport_has_led(line6->type)) {
+		CHECK_RETURN(device_create_file
+			     (&interface->dev, &dev_attr_led_red));
+		CHECK_RETURN(device_create_file
+			     (&interface->dev, &dev_attr_led_green));
+	}
+
+	toneport_setup(toneport);
+
+	init_timer(&toneport->timer);
+	toneport->timer.expires = jiffies + TONEPORT_PCM_DELAY * HZ;
+	toneport->timer.function = toneport_start_pcm;
+	toneport->timer.data = (unsigned long)toneport;
+	add_timer(&toneport->timer);
+
+	return 0;
+}
+
+/*
+	 Init Toneport device (and clean up in case of failure).
+*/
+int line6_toneport_init(struct usb_interface *interface,
+			struct usb_line6 *line6)
+{
+	int err = toneport_try_init(interface, line6);
+
+	if (err < 0)
+		toneport_destruct(interface);
+
+	return err;
+}
+
+/*
+	Resume Toneport device after reset.
+*/
+void line6_toneport_reset_resume(struct usb_line6_toneport *toneport)
+{
+	toneport_setup(toneport);
+}
