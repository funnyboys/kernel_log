commit e4091bdd2fd957793a10449a8682c767578b0430
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Sun Jul 21 12:25:58 2019 +0200

    ALSA: line6: Fix a typo
    
    s/Vairax/Variax/
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index 0d24c72c155f..ed158f04de80 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -244,5 +244,5 @@ static struct usb_driver variax_driver = {
 
 module_usb_driver(variax_driver);
 
-MODULE_DESCRIPTION("Vairax Workbench USB driver");
+MODULE_DESCRIPTION("Variax Workbench USB driver");
 MODULE_LICENSE("GPL");

commit 3c53c6255d598db7084c5c3d7553d7200e857818
Merge: b89b889a326a a98429acadef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 8 14:45:20 2019 +0200

    Merge tag 'asoc-v5.3' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.3
    
    This is a very big update, mainly thanks to Morimoto-san's refactoring
    work and some fairly large new drivers.
    
     - Lots more work on moving towards a component based framework from
       Morimoto-san.
     - Support for force disconnecting muxes from Jerome Brunet.
     - New drivers for Cirrus Logic CS47L35, CS47L85 and CS47L90, Conexant
       CX2072X, Realtek RT1011 and RT1308.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit a10e763b87134a9a4ca3a38b5c4b533e75ec63a3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 31 01:09:32 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 372
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 135 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531081036.435762997@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index e8c852b2ce35..e59b97444399 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Line 6 Linux USB driver
  *
  * Copyright (C) 2004-2010 Markus Grabner (grabner@icg.tugraz.at)
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License as
- *	published by the Free Software Foundation, version 2.
- *
  */
 
 #include <linux/slab.h>

commit f23a09eea1e7947611d985d8cd13d55428ff0af8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 28 09:05:31 2019 +0200

    ALSA: line6: Use container_of()
    
    ... instead of unconditional cast.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index fb114156b7ca..0d0de907d497 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -47,6 +47,8 @@ struct usb_line6_variax {
 	int startup_progress;
 };
 
+#define line6_to_variax(x)	container_of(x, struct usb_line6_variax, line6)
+
 #define VARIAX_OFFSET_ACTIVATE 7
 
 /*
@@ -86,7 +88,7 @@ static void variax_activate_async(struct usb_line6_variax *variax, int a)
 
 static void variax_startup(struct usb_line6 *line6)
 {
-	struct usb_line6_variax *variax = (struct usb_line6_variax *)line6;
+	struct usb_line6_variax *variax = line6_to_variax(line6);
 
 	switch (variax->startup_progress) {
 	case VARIAX_STARTUP_VERSIONREQ:
@@ -115,7 +117,7 @@ static void variax_startup(struct usb_line6 *line6)
 */
 static void line6_variax_process_message(struct usb_line6 *line6)
 {
-	struct usb_line6_variax *variax = (struct usb_line6_variax *) line6;
+	struct usb_line6_variax *variax = line6_to_variax(line6);
 	const unsigned char *buf = variax->line6.buffer_message;
 
 	switch (buf[0]) {
@@ -149,7 +151,7 @@ static void line6_variax_process_message(struct usb_line6 *line6)
 */
 static void line6_variax_disconnect(struct usb_line6 *line6)
 {
-	struct usb_line6_variax *variax = (struct usb_line6_variax *)line6;
+	struct usb_line6_variax *variax = line6_to_variax(line6);
 
 	kfree(variax->buffer_activate);
 }
@@ -160,7 +162,7 @@ static void line6_variax_disconnect(struct usb_line6 *line6)
 static int variax_init(struct usb_line6 *line6,
 		       const struct usb_device_id *id)
 {
-	struct usb_line6_variax *variax = (struct usb_line6_variax *) line6;
+	struct usb_line6_variax *variax = line6_to_variax(line6);
 	int err;
 
 	line6->process_message = line6_variax_process_message;

commit 6ea53391c04ebc84ff62e2df20f75d65f727f4e8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 8 15:55:36 2019 +0200

    ALSA: line6: variax: Rewrite complex timer & work combo with a delayed work
    
    Variax driver had a very complex and staged startup sequence using
    multiple timers and a work.  This patch simplifies the procedure to a
    single delayed work.
    
    Now the startup stage consists of:
    - VARIAX_STARTUP_VERSIONREQ:
      requesting the version and the message handler raises up to the next
      stage upon receiving the reply.  The request is repeated until a
      reply arrives.
    - VARIAX_STARTUP_ACTIVATE:
      does activation, and queue for the next stage.
    - VARIAX_STARTUP_SETUP:
      registers the card.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index e8c852b2ce35..fb114156b7ca 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -26,13 +26,9 @@
 	Stages of Variax startup procedure
 */
 enum {
-	VARIAX_STARTUP_INIT = 1,
 	VARIAX_STARTUP_VERSIONREQ,
-	VARIAX_STARTUP_WAIT,
 	VARIAX_STARTUP_ACTIVATE,
-	VARIAX_STARTUP_WORKQUEUE,
 	VARIAX_STARTUP_SETUP,
-	VARIAX_STARTUP_LAST = VARIAX_STARTUP_SETUP - 1
 };
 
 enum {
@@ -47,13 +43,6 @@ struct usb_line6_variax {
 	/* Buffer for activation code */
 	unsigned char *buffer_activate;
 
-	/* Handler for device initialization */
-	struct work_struct startup_work;
-
-	/* Timers for device initialization */
-	struct timer_list startup_timer1;
-	struct timer_list startup_timer2;
-
 	/* Current progress in startup procedure */
 	int startup_progress;
 };
@@ -81,11 +70,6 @@ static const char variax_activate[] = {
 	0xf7
 };
 
-/* forward declarations: */
-static void variax_startup2(struct timer_list *t);
-static void variax_startup4(struct timer_list *t);
-static void variax_startup5(struct timer_list *t);
-
 static void variax_activate_async(struct usb_line6_variax *variax, int a)
 {
 	variax->buffer_activate[VARIAX_OFFSET_ACTIVATE] = a;
@@ -100,74 +84,30 @@ static void variax_activate_async(struct usb_line6_variax *variax, int a)
 	context). After the last one has finished, the device is ready to use.
 */
 
-static void variax_startup1(struct usb_line6_variax *variax)
-{
-	CHECK_STARTUP_PROGRESS(variax->startup_progress, VARIAX_STARTUP_INIT);
-
-	/* delay startup procedure: */
-	line6_start_timer(&variax->startup_timer1, VARIAX_STARTUP_DELAY1,
-			  variax_startup2);
-}
-
-static void variax_startup2(struct timer_list *t)
-{
-	struct usb_line6_variax *variax = from_timer(variax, t, startup_timer1);
-	struct usb_line6 *line6 = &variax->line6;
-
-	/* schedule another startup procedure until startup is complete: */
-	if (variax->startup_progress >= VARIAX_STARTUP_LAST)
-		return;
-
-	variax->startup_progress = VARIAX_STARTUP_VERSIONREQ;
-	line6_start_timer(&variax->startup_timer1, VARIAX_STARTUP_DELAY1,
-			  variax_startup2);
-
-	/* request firmware version: */
-	line6_version_request_async(line6);
-}
-
-static void variax_startup3(struct usb_line6_variax *variax)
+static void variax_startup(struct usb_line6 *line6)
 {
-	CHECK_STARTUP_PROGRESS(variax->startup_progress, VARIAX_STARTUP_WAIT);
-
-	/* delay startup procedure: */
-	line6_start_timer(&variax->startup_timer2, VARIAX_STARTUP_DELAY3,
-			  variax_startup4);
-}
-
-static void variax_startup4(struct timer_list *t)
-{
-	struct usb_line6_variax *variax = from_timer(variax, t, startup_timer2);
-
-	CHECK_STARTUP_PROGRESS(variax->startup_progress,
-			       VARIAX_STARTUP_ACTIVATE);
-
-	/* activate device: */
-	variax_activate_async(variax, 1);
-	line6_start_timer(&variax->startup_timer2, VARIAX_STARTUP_DELAY4,
-			  variax_startup5);
-}
-
-static void variax_startup5(struct timer_list *t)
-{
-	struct usb_line6_variax *variax = from_timer(variax, t, startup_timer2);
-
-	CHECK_STARTUP_PROGRESS(variax->startup_progress,
-			       VARIAX_STARTUP_WORKQUEUE);
-
-	/* schedule work for global work queue: */
-	schedule_work(&variax->startup_work);
-}
-
-static void variax_startup6(struct work_struct *work)
-{
-	struct usb_line6_variax *variax =
-	    container_of(work, struct usb_line6_variax, startup_work);
-
-	CHECK_STARTUP_PROGRESS(variax->startup_progress, VARIAX_STARTUP_SETUP);
+	struct usb_line6_variax *variax = (struct usb_line6_variax *)line6;
 
-	/* ALSA audio interface: */
-	snd_card_register(variax->line6.card);
+	switch (variax->startup_progress) {
+	case VARIAX_STARTUP_VERSIONREQ:
+		/* repeat request until getting the response */
+		schedule_delayed_work(&line6->startup_work,
+				      msecs_to_jiffies(VARIAX_STARTUP_DELAY1));
+		/* request firmware version: */
+		line6_version_request_async(line6);
+		break;
+	case VARIAX_STARTUP_ACTIVATE:
+		/* activate device: */
+		variax_activate_async(variax, 1);
+		variax->startup_progress = VARIAX_STARTUP_SETUP;
+		schedule_delayed_work(&line6->startup_work,
+				      msecs_to_jiffies(VARIAX_STARTUP_DELAY4));
+		break;
+	case VARIAX_STARTUP_SETUP:
+		/* ALSA audio interface: */
+		snd_card_register(variax->line6.card);
+		break;
+	}
 }
 
 /*
@@ -186,11 +126,19 @@ static void line6_variax_process_message(struct usb_line6 *line6)
 	case LINE6_SYSEX_BEGIN:
 		if (memcmp(buf + 1, variax_init_version + 1,
 			   sizeof(variax_init_version) - 1) == 0) {
-			variax_startup3(variax);
+			if (variax->startup_progress >= VARIAX_STARTUP_ACTIVATE)
+				break;
+			variax->startup_progress = VARIAX_STARTUP_ACTIVATE;
+			cancel_delayed_work(&line6->startup_work);
+			schedule_delayed_work(&line6->startup_work,
+					      msecs_to_jiffies(VARIAX_STARTUP_DELAY3));
 		} else if (memcmp(buf + 1, variax_init_done + 1,
 				  sizeof(variax_init_done) - 1) == 0) {
 			/* notify of complete initialization: */
-			variax_startup4(&variax->startup_timer2);
+			if (variax->startup_progress >= VARIAX_STARTUP_SETUP)
+				break;
+			cancel_delayed_work(&line6->startup_work);
+			schedule_delayed_work(&line6->startup_work, 0);
 		}
 		break;
 	}
@@ -203,10 +151,6 @@ static void line6_variax_disconnect(struct usb_line6 *line6)
 {
 	struct usb_line6_variax *variax = (struct usb_line6_variax *)line6;
 
-	del_timer(&variax->startup_timer1);
-	del_timer(&variax->startup_timer2);
-	cancel_work_sync(&variax->startup_work);
-
 	kfree(variax->buffer_activate);
 }
 
@@ -221,10 +165,7 @@ static int variax_init(struct usb_line6 *line6,
 
 	line6->process_message = line6_variax_process_message;
 	line6->disconnect = line6_variax_disconnect;
-
-	timer_setup(&variax->startup_timer1, NULL, 0);
-	timer_setup(&variax->startup_timer2, NULL, 0);
-	INIT_WORK(&variax->startup_work, variax_startup6);
+	line6->startup = variax_startup;
 
 	/* initialize USB buffers: */
 	variax->buffer_activate = kmemdup(variax_activate,
@@ -239,7 +180,8 @@ static int variax_init(struct usb_line6 *line6,
 		return err;
 
 	/* initiate startup procedure: */
-	variax_startup1(variax);
+	schedule_delayed_work(&line6->startup_work,
+			      msecs_to_jiffies(VARIAX_STARTUP_DELAY1));
 	return 0;
 }
 

commit a6162afa7135548973ba633c7795db9648fbd4a2
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 16:07:31 2017 -0700

    ALSA: usb-audio: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index 0c4512d0382e..e8c852b2ce35 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -82,9 +82,9 @@ static const char variax_activate[] = {
 };
 
 /* forward declarations: */
-static void variax_startup2(unsigned long data);
-static void variax_startup4(unsigned long data);
-static void variax_startup5(unsigned long data);
+static void variax_startup2(struct timer_list *t);
+static void variax_startup4(struct timer_list *t);
+static void variax_startup5(struct timer_list *t);
 
 static void variax_activate_async(struct usb_line6_variax *variax, int a)
 {
@@ -106,12 +106,12 @@ static void variax_startup1(struct usb_line6_variax *variax)
 
 	/* delay startup procedure: */
 	line6_start_timer(&variax->startup_timer1, VARIAX_STARTUP_DELAY1,
-			  variax_startup2, (unsigned long)variax);
+			  variax_startup2);
 }
 
-static void variax_startup2(unsigned long data)
+static void variax_startup2(struct timer_list *t)
 {
-	struct usb_line6_variax *variax = (struct usb_line6_variax *)data;
+	struct usb_line6_variax *variax = from_timer(variax, t, startup_timer1);
 	struct usb_line6 *line6 = &variax->line6;
 
 	/* schedule another startup procedure until startup is complete: */
@@ -120,7 +120,7 @@ static void variax_startup2(unsigned long data)
 
 	variax->startup_progress = VARIAX_STARTUP_VERSIONREQ;
 	line6_start_timer(&variax->startup_timer1, VARIAX_STARTUP_DELAY1,
-			  variax_startup2, (unsigned long)variax);
+			  variax_startup2);
 
 	/* request firmware version: */
 	line6_version_request_async(line6);
@@ -132,12 +132,12 @@ static void variax_startup3(struct usb_line6_variax *variax)
 
 	/* delay startup procedure: */
 	line6_start_timer(&variax->startup_timer2, VARIAX_STARTUP_DELAY3,
-			  variax_startup4, (unsigned long)variax);
+			  variax_startup4);
 }
 
-static void variax_startup4(unsigned long data)
+static void variax_startup4(struct timer_list *t)
 {
-	struct usb_line6_variax *variax = (struct usb_line6_variax *)data;
+	struct usb_line6_variax *variax = from_timer(variax, t, startup_timer2);
 
 	CHECK_STARTUP_PROGRESS(variax->startup_progress,
 			       VARIAX_STARTUP_ACTIVATE);
@@ -145,12 +145,12 @@ static void variax_startup4(unsigned long data)
 	/* activate device: */
 	variax_activate_async(variax, 1);
 	line6_start_timer(&variax->startup_timer2, VARIAX_STARTUP_DELAY4,
-			  variax_startup5, (unsigned long)variax);
+			  variax_startup5);
 }
 
-static void variax_startup5(unsigned long data)
+static void variax_startup5(struct timer_list *t)
 {
-	struct usb_line6_variax *variax = (struct usb_line6_variax *)data;
+	struct usb_line6_variax *variax = from_timer(variax, t, startup_timer2);
 
 	CHECK_STARTUP_PROGRESS(variax->startup_progress,
 			       VARIAX_STARTUP_WORKQUEUE);
@@ -190,7 +190,7 @@ static void line6_variax_process_message(struct usb_line6 *line6)
 		} else if (memcmp(buf + 1, variax_init_done + 1,
 				  sizeof(variax_init_done) - 1) == 0) {
 			/* notify of complete initialization: */
-			variax_startup4((unsigned long)variax);
+			variax_startup4(&variax->startup_timer2);
 		}
 		break;
 	}
@@ -222,8 +222,8 @@ static int variax_init(struct usb_line6 *line6,
 	line6->process_message = line6_variax_process_message;
 	line6->disconnect = line6_variax_disconnect;
 
-	init_timer(&variax->startup_timer1);
-	init_timer(&variax->startup_timer2);
+	timer_setup(&variax->startup_timer1, NULL, 0);
+	timer_setup(&variax->startup_timer2, NULL, 0);
 	INIT_WORK(&variax->startup_work, variax_startup6);
 
 	/* initialize USB buffers: */

commit 174e1fc0bff5e0bbdf5eb0cbf1b8c0d64a0f38d2
Author: Andrej Krutak <dev@andree.sk>
Date:   Sun Sep 18 20:59:26 2016 +0200

    ALSA: line6: Distinguish device init (ctrl EP) and MIDI data transfer (int EP)
    
    POD X3 can initialize similarly to older PODs, but it doesn't have the MIDI
    interface. Instead, configuration is done via proprietary bulk EP messages.
    
    Signed-off-by: Andrej Krutak <dev@andree.sk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index ddc23ddf0750..0c4512d0382e 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -259,7 +259,8 @@ static const struct line6_properties variax_properties_table[] = {
 	[LINE6_PODXTLIVE_VARIAX] = {
 		.id = "PODxtLive",
 		.name = "PODxt Live",
-		.capabilities	= LINE6_CAP_CONTROL,
+		.capabilities	= LINE6_CAP_CONTROL
+				| LINE6_CAP_CONTROL_MIDI,
 		.altsetting = 1,
 		.ep_ctrl_r = 0x86,
 		.ep_ctrl_w = 0x05,
@@ -269,7 +270,8 @@ static const struct line6_properties variax_properties_table[] = {
 	[LINE6_VARIAX] = {
 		.id = "Variax",
 		.name = "Variax Workbench",
-		.capabilities	= LINE6_CAP_CONTROL,
+		.capabilities	= LINE6_CAP_CONTROL
+				| LINE6_CAP_CONTROL_MIDI,
 		.altsetting = 1,
 		.ep_ctrl_r = 0x82,
 		.ep_ctrl_w = 0x01,

commit 12865cac38cc9e808ce8b479f4bb12fd00bfee7c
Author: Chris Rorvick <chris@rorvick.com>
Date:   Sat Feb 7 10:43:19 2015 -0600

    ALSA: line6: Pass driver name to line6_probe()
    
    Provide a unique name for each driver instead of using "line6usb" for
    all of them.  This will allow for different configurations based on the
    driver type.
    
    Signed-off-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index b1c1de65d584..ddc23ddf0750 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -283,7 +283,7 @@ static const struct line6_properties variax_properties_table[] = {
 static int variax_probe(struct usb_interface *interface,
 			const struct usb_device_id *id)
 {
-	return line6_probe(interface, id,
+	return line6_probe(interface, id, "Line6-Variax",
 			   &variax_properties_table[id->driver_info],
 			   variax_init, sizeof(struct usb_line6_variax));
 }

commit 72f18d00757e182c1adeb747ea39a66f1b54698b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 15:03:31 2015 +0100

    ALSA: line6: Remove invalid capability bits for PODxt Live Variax
    
    PODxt Live Variax doesn't have PCM and HWMON but only MIDI.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index 9dfbe7916d99..b1c1de65d584 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -259,9 +259,7 @@ static const struct line6_properties variax_properties_table[] = {
 	[LINE6_PODXTLIVE_VARIAX] = {
 		.id = "PODxtLive",
 		.name = "PODxt Live",
-		.capabilities	= LINE6_CAP_CONTROL
-				| LINE6_CAP_PCM
-				| LINE6_CAP_HWMON,
+		.capabilities	= LINE6_CAP_CONTROL,
 		.altsetting = 1,
 		.ep_ctrl_r = 0x86,
 		.ep_ctrl_w = 0x05,

commit 129b3be6895c01e137dbb88c699f9f706bdc6c9d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 14:50:08 2015 +0100

    ALSA: line6: Move the contents of usbdefs.h into driver.h
    
    Most of them are rather relevant with the definitions in driver.h,
    and there are only a few lines, so just rip it off.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index 44042cbdef01..9dfbe7916d99 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -17,7 +17,6 @@
 #include <sound/core.h>
 
 #include "driver.h"
-#include "usbdefs.h"
 
 #define VARIAX_STARTUP_DELAY1 1000
 #define VARIAX_STARTUP_DELAY3 100

commit cddbd4f17078530b4914a42f6d7f3e543b5fad0e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 14:43:11 2015 +0100

    ALSA: line6: Tidy up and typo fixes in comments
    
    Just reformatting the comments and typos fixed, no functional
    changes.  Particularly,
    - avoid the kerneldoc marker "/**",
    - reduce multiple comment lines into single lines,
    - corrected wrongly referred function names
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index 9701ffa61365..44042cbdef01 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -42,30 +42,20 @@ enum {
 };
 
 struct usb_line6_variax {
-	/**
-		Generic Line 6 USB data.
-	*/
+	/* Generic Line 6 USB data */
 	struct usb_line6 line6;
 
-	/**
-		Buffer for activation code.
-	*/
+	/* Buffer for activation code */
 	unsigned char *buffer_activate;
 
-	/**
-		Handler for device initializaton.
-	*/
+	/* Handler for device initialization */
 	struct work_struct startup_work;
 
-	/**
-		Timers for device initializaton.
-	*/
+	/* Timers for device initialization */
 	struct timer_list startup_timer1;
 	struct timer_list startup_timer2;
 
-	/**
-		Current progress in startup procedure.
-	*/
+	/* Current progress in startup procedure */
 	int startup_progress;
 };
 

commit aca514b82356dcc3575da33453382bd27593aea1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 25 18:36:29 2015 +0100

    ALSA: line6: Let snd_card_new() allocate private data
    
    Instead of allocating the private data individually in each driver's
    probe at first, let snd_card_new() allocate the data that is called in
    line6_probe().  This simplifies the primary probe functions.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index ba6e85eed2ba..9701ffa61365 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -296,14 +296,9 @@ static const struct line6_properties variax_properties_table[] = {
 static int variax_probe(struct usb_interface *interface,
 			const struct usb_device_id *id)
 {
-	struct usb_line6_variax *variax;
-
-	variax = kzalloc(sizeof(*variax), GFP_KERNEL);
-	if (!variax)
-		return -ENODEV;
-	return line6_probe(interface, id, &variax->line6,
+	return line6_probe(interface, id,
 			   &variax_properties_table[id->driver_info],
-			   variax_init);
+			   variax_init, sizeof(struct usb_line6_variax));
 }
 
 static struct usb_driver variax_driver = {

commit f66fd990c5db177d6b9f0eae301ca6b15882eb2e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 25 18:22:58 2015 +0100

    ALSA: line6: Drop interface argument from private_init and disconnect callbacks
    
    The interface argument is used just for retrieving the assigned
    device, which can be already found in line6->ifcdev.  Drop them from
    the callbacks.  Also, pass the usb id to private_init so that the
    driver can deal with it there.  This is a preliminary work for the
    further cleanup to move the whole allocation into driver.c.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index cd3adeffde02..ba6e85eed2ba 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -210,11 +210,9 @@ static void line6_variax_process_message(struct usb_line6 *line6)
 /*
 	Variax destructor.
 */
-static void line6_variax_disconnect(struct usb_interface *interface)
+static void line6_variax_disconnect(struct usb_line6 *line6)
 {
-	struct usb_line6_variax *variax;
-
-	variax = usb_get_intfdata(interface);
+	struct usb_line6_variax *variax = (struct usb_line6_variax *)line6;
 
 	del_timer(&variax->startup_timer1);
 	del_timer(&variax->startup_timer2);
@@ -226,8 +224,8 @@ static void line6_variax_disconnect(struct usb_interface *interface)
 /*
 	 Try to init workbench device.
 */
-static int variax_init(struct usb_interface *interface,
-		       struct usb_line6 *line6)
+static int variax_init(struct usb_line6 *line6,
+		       const struct usb_device_id *id)
 {
 	struct usb_line6_variax *variax = (struct usb_line6_variax *) line6;
 	int err;
@@ -303,7 +301,7 @@ static int variax_probe(struct usb_interface *interface,
 	variax = kzalloc(sizeof(*variax), GFP_KERNEL);
 	if (!variax)
 		return -ENODEV;
-	return line6_probe(interface, &variax->line6,
+	return line6_probe(interface, id, &variax->line6,
 			   &variax_properties_table[id->driver_info],
 			   variax_init);
 }

commit 8a3b7c086a509d90c312ebab6d8e5a9bf48c6cf5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 20 08:42:42 2015 +0100

    ALSA: line6: Remove superfluous NULL checks in each driver
    
    The interface and driver objects are always set when callbacks are
    called.  Drop such superfluous NULL checks in init and disconnect
    calls of each driver.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index 99a58cbfd2da..cd3adeffde02 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -214,12 +214,7 @@ static void line6_variax_disconnect(struct usb_interface *interface)
 {
 	struct usb_line6_variax *variax;
 
-	if (!interface)
-		return;
-
 	variax = usb_get_intfdata(interface);
-	if (!variax)
-		return;
 
 	del_timer(&variax->startup_timer1);
 	del_timer(&variax->startup_timer2);
@@ -244,9 +239,6 @@ static int variax_init(struct usb_interface *interface,
 	init_timer(&variax->startup_timer2);
 	INIT_WORK(&variax->startup_work, variax_startup6);
 
-	if ((interface == NULL) || (variax == NULL))
-		return -ENODEV;
-
 	/* initialize USB buffers: */
 	variax->buffer_activate = kmemdup(variax_activate,
 					  sizeof(variax_activate), GFP_KERNEL);

commit c078a4aac2944cb9cac5cdb4e9a482623435578b
Author: Chris Rorvick <chris@rorvick.com>
Date:   Tue Jan 20 02:20:50 2015 -0600

    ALSA: line6: Remove driver version from header comment
    
    The driver version string was removed in an ealier commit for being
    useless.  These are equally useless.
    
    Signed-off-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index 5e4da466da50..99a58cbfd2da 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -1,5 +1,5 @@
 /*
- * Line 6 Linux USB driver - 0.9.1beta
+ * Line 6 Linux USB driver
  *
  * Copyright (C) 2004-2010 Markus Grabner (grabner@icg.tugraz.at)
  *

commit c6fffce92e1a8cda8c1b552f5a24295839f3f93a
Author: Chris Rorvick <chris@rorvick.com>
Date:   Tue Jan 20 02:20:49 2015 -0600

    ALSA: line6: Refer to manufacturer as "Line 6"
    
    The correct spelling includes the space.  Fix this in strings and
    comments that refer to the manufacturer.
    
    Signed-off-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index a591c2c5794f..5e4da466da50 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -1,5 +1,5 @@
 /*
- * Line6 Linux USB driver - 0.9.1beta
+ * Line 6 Linux USB driver - 0.9.1beta
  *
  * Copyright (C) 2004-2010 Markus Grabner (grabner@icg.tugraz.at)
  *
@@ -43,7 +43,7 @@ enum {
 
 struct usb_line6_variax {
 	/**
-		Generic Line6 USB data.
+		Generic Line 6 USB data.
 	*/
 	struct usb_line6 line6;
 

commit 85a9339becf0af4d547ceb6bb16d1893b05fbce4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 15:54:00 2015 +0100

    ALSA: line6: Reorganize card resource handling
    
    This is a fairly big rewrite regarding the card resource management in
    line6 drivers:
    
    - The card creation is moved into line6_probe().  This adds the global
      destructor to private_free, so that each driver doesn't have to call
      it any longer.
    
    - The USB disconnect callback handles the card release, thus each
      driver needs to concentrate on only its own resources.  No need to
      snd_card_*() call in the destructor.
    
    - Fix the potential stall in disconnection by removing
      snd_card_free().   It's replaced with snd_card_free_when_closed()
      for asynchronous release.
    
    - The only remaining operation for the card in each driver is the call
      of snd_card_register().  All the rest are dealt in the common module
      by itself.
    
    - These ended up with removal of audio.[ch] as a result of a reduction
      of one layer.  Each driver just needs to call line6_probe().
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index 9a9c7e48e24f..a591c2c5794f 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -16,7 +16,6 @@
 #include <linux/module.h>
 #include <sound/core.h>
 
-#include "audio.h"
 #include "driver.h"
 #include "usbdefs.h"
 
@@ -179,7 +178,7 @@ static void variax_startup6(struct work_struct *work)
 	CHECK_STARTUP_PROGRESS(variax->startup_progress, VARIAX_STARTUP_SETUP);
 
 	/* ALSA audio interface: */
-	line6_register_audio(&variax->line6);
+	snd_card_register(variax->line6.card);
 }
 
 /*
@@ -211,13 +210,16 @@ static void line6_variax_process_message(struct usb_line6 *line6)
 /*
 	Variax destructor.
 */
-static void variax_destruct(struct usb_interface *interface)
+static void line6_variax_disconnect(struct usb_interface *interface)
 {
-	struct usb_line6_variax *variax = usb_get_intfdata(interface);
+	struct usb_line6_variax *variax;
+
+	if (!interface)
+		return;
 
-	if (variax == NULL)
+	variax = usb_get_intfdata(interface);
+	if (!variax)
 		return;
-	line6_cleanup_audio(&variax->line6);
 
 	del_timer(&variax->startup_timer1);
 	del_timer(&variax->startup_timer2);
@@ -226,22 +228,11 @@ static void variax_destruct(struct usb_interface *interface)
 	kfree(variax->buffer_activate);
 }
 
-/*
-	Workbench device disconnected.
-*/
-static void line6_variax_disconnect(struct usb_interface *interface)
-{
-	if (interface == NULL)
-		return;
-
-	variax_destruct(interface);
-}
-
 /*
 	 Try to init workbench device.
 */
-static int variax_try_init(struct usb_interface *interface,
-			   struct usb_line6 *line6)
+static int variax_init(struct usb_interface *interface,
+		       struct usb_line6 *line6)
 {
 	struct usb_line6_variax *variax = (struct usb_line6_variax *) line6;
 	int err;
@@ -263,11 +254,6 @@ static int variax_try_init(struct usb_interface *interface,
 	if (variax->buffer_activate == NULL)
 		return -ENOMEM;
 
-	/* initialize audio system: */
-	err = line6_init_audio(&variax->line6);
-	if (err < 0)
-		return err;
-
 	/* initialize MIDI subsystem: */
 	err = line6_init_midi(&variax->line6);
 	if (err < 0)
@@ -278,20 +264,6 @@ static int variax_try_init(struct usb_interface *interface,
 	return 0;
 }
 
-/*
-	 Init workbench device (and clean up in case of failure).
-*/
-static int variax_init(struct usb_interface *interface,
-		       struct usb_line6 *line6)
-{
-	int err = variax_try_init(interface, line6);
-
-	if (err < 0)
-		variax_destruct(interface);
-
-	return err;
-}
-
 #define LINE6_DEVICE(prod) USB_DEVICE(0x0e41, prod)
 #define LINE6_IF_NUM(prod, n) USB_DEVICE_INTERFACE_NUMBER(0x0e41, prod, n)
 
@@ -335,17 +307,13 @@ static int variax_probe(struct usb_interface *interface,
 			const struct usb_device_id *id)
 {
 	struct usb_line6_variax *variax;
-	int err;
 
 	variax = kzalloc(sizeof(*variax), GFP_KERNEL);
 	if (!variax)
 		return -ENODEV;
-	err = line6_probe(interface, &variax->line6,
-			  &variax_properties_table[id->driver_info],
-			  variax_init);
-	if (err < 0)
-		kfree(variax);
-	return err;
+	return line6_probe(interface, &variax->line6,
+			   &variax_properties_table[id->driver_info],
+			   variax_init);
 }
 
 static struct usb_driver variax_driver = {

commit a019f5e8c522f5b5f8b3419a1e56d142ea4c7621
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 15:05:10 2015 +0100

    ALSA: line6: Remove superfluous out-of-memory error messages
    
    Kernel already shows the error in the common path.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index 0c852bb1e76c..9a9c7e48e24f 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -260,10 +260,8 @@ static int variax_try_init(struct usb_interface *interface,
 	variax->buffer_activate = kmemdup(variax_activate,
 					  sizeof(variax_activate), GFP_KERNEL);
 
-	if (variax->buffer_activate == NULL) {
-		dev_err(&interface->dev, "Out of memory\n");
+	if (variax->buffer_activate == NULL)
 		return -ENOMEM;
-	}
 
 	/* initialize audio system: */
 	err = line6_init_audio(&variax->line6);

commit ccddbe4a99536154e61d16c0f1c2df8a6d63f52a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 15 08:22:31 2015 +0100

    ALSA: line6: Split to each driver
    
    Split to each individual driver for POD, PODHD, TonePort and Variax
    with a core LINE6 helper module.  The new modules follow the standard
    ALSA naming rule with snd prefix: snd-usb-pod, snd-usb-podhd,
    snd-usb-toneport and snd-usb-variax, together with the corresponding
    CONFIG_SND_USB_* Kconfig items.
    
    Tested-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
index b4a41b0ad0ea..0c852bb1e76c 100644
--- a/sound/usb/line6/variax.c
+++ b/sound/usb/line6/variax.c
@@ -10,10 +10,65 @@
  */
 
 #include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/usb.h>
+#include <linux/wait.h>
+#include <linux/module.h>
+#include <sound/core.h>
 
 #include "audio.h"
 #include "driver.h"
-#include "variax.h"
+#include "usbdefs.h"
+
+#define VARIAX_STARTUP_DELAY1 1000
+#define VARIAX_STARTUP_DELAY3 100
+#define VARIAX_STARTUP_DELAY4 100
+
+/*
+	Stages of Variax startup procedure
+*/
+enum {
+	VARIAX_STARTUP_INIT = 1,
+	VARIAX_STARTUP_VERSIONREQ,
+	VARIAX_STARTUP_WAIT,
+	VARIAX_STARTUP_ACTIVATE,
+	VARIAX_STARTUP_WORKQUEUE,
+	VARIAX_STARTUP_SETUP,
+	VARIAX_STARTUP_LAST = VARIAX_STARTUP_SETUP - 1
+};
+
+enum {
+	LINE6_PODXTLIVE_VARIAX,
+	LINE6_VARIAX
+};
+
+struct usb_line6_variax {
+	/**
+		Generic Line6 USB data.
+	*/
+	struct usb_line6 line6;
+
+	/**
+		Buffer for activation code.
+	*/
+	unsigned char *buffer_activate;
+
+	/**
+		Handler for device initializaton.
+	*/
+	struct work_struct startup_work;
+
+	/**
+		Timers for device initializaton.
+	*/
+	struct timer_list startup_timer1;
+	struct timer_list startup_timer2;
+
+	/**
+		Current progress in startup procedure.
+	*/
+	int startup_progress;
+};
 
 #define VARIAX_OFFSET_ACTIVATE 7
 
@@ -228,7 +283,8 @@ static int variax_try_init(struct usb_interface *interface,
 /*
 	 Init workbench device (and clean up in case of failure).
 */
-int line6_variax_init(struct usb_interface *interface, struct usb_line6 *line6)
+static int variax_init(struct usb_interface *interface,
+		       struct usb_line6 *line6)
 {
 	int err = variax_try_init(interface, line6);
 
@@ -237,3 +293,76 @@ int line6_variax_init(struct usb_interface *interface, struct usb_line6 *line6)
 
 	return err;
 }
+
+#define LINE6_DEVICE(prod) USB_DEVICE(0x0e41, prod)
+#define LINE6_IF_NUM(prod, n) USB_DEVICE_INTERFACE_NUMBER(0x0e41, prod, n)
+
+/* table of devices that work with this driver */
+static const struct usb_device_id variax_id_table[] = {
+	{ LINE6_IF_NUM(0x4650, 1), .driver_info = LINE6_PODXTLIVE_VARIAX },
+	{ LINE6_DEVICE(0x534d),    .driver_info = LINE6_VARIAX },
+	{}
+};
+
+MODULE_DEVICE_TABLE(usb, variax_id_table);
+
+static const struct line6_properties variax_properties_table[] = {
+	[LINE6_PODXTLIVE_VARIAX] = {
+		.id = "PODxtLive",
+		.name = "PODxt Live",
+		.capabilities	= LINE6_CAP_CONTROL
+				| LINE6_CAP_PCM
+				| LINE6_CAP_HWMON,
+		.altsetting = 1,
+		.ep_ctrl_r = 0x86,
+		.ep_ctrl_w = 0x05,
+		.ep_audio_r = 0x82,
+		.ep_audio_w = 0x01,
+	},
+	[LINE6_VARIAX] = {
+		.id = "Variax",
+		.name = "Variax Workbench",
+		.capabilities	= LINE6_CAP_CONTROL,
+		.altsetting = 1,
+		.ep_ctrl_r = 0x82,
+		.ep_ctrl_w = 0x01,
+		/* no audio channel */
+	}
+};
+
+/*
+	Probe USB device.
+*/
+static int variax_probe(struct usb_interface *interface,
+			const struct usb_device_id *id)
+{
+	struct usb_line6_variax *variax;
+	int err;
+
+	variax = kzalloc(sizeof(*variax), GFP_KERNEL);
+	if (!variax)
+		return -ENODEV;
+	err = line6_probe(interface, &variax->line6,
+			  &variax_properties_table[id->driver_info],
+			  variax_init);
+	if (err < 0)
+		kfree(variax);
+	return err;
+}
+
+static struct usb_driver variax_driver = {
+	.name = KBUILD_MODNAME,
+	.probe = variax_probe,
+	.disconnect = line6_disconnect,
+#ifdef CONFIG_PM
+	.suspend = line6_suspend,
+	.resume = line6_resume,
+	.reset_resume = line6_resume,
+#endif
+	.id_table = variax_id_table,
+};
+
+module_usb_driver(variax_driver);
+
+MODULE_DESCRIPTION("Vairax Workbench USB driver");
+MODULE_LICENSE("GPL");

commit 61864d844c296933d40c02683252bbea5193b101
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 12 22:29:57 2015 +0100

    ALSA: move line6 usb driver into sound/usb
    
    Promote line6 driver from staging to sound/usb/line6 directory, and
    maintain through sound subsystem tree.
    
    This commit just moves the code and adapts Makefile / Kconfig.
    The further renames and misc cleanups will follow.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/usb/line6/variax.c b/sound/usb/line6/variax.c
new file mode 100644
index 000000000000..b4a41b0ad0ea
--- /dev/null
+++ b/sound/usb/line6/variax.c
@@ -0,0 +1,239 @@
+/*
+ * Line6 Linux USB driver - 0.9.1beta
+ *
+ * Copyright (C) 2004-2010 Markus Grabner (grabner@icg.tugraz.at)
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation, version 2.
+ *
+ */
+
+#include <linux/slab.h>
+
+#include "audio.h"
+#include "driver.h"
+#include "variax.h"
+
+#define VARIAX_OFFSET_ACTIVATE 7
+
+/*
+	This message is sent by the device during initialization and identifies
+	the connected guitar version.
+*/
+static const char variax_init_version[] = {
+	0xf0, 0x7e, 0x7f, 0x06, 0x02, 0x00, 0x01, 0x0c,
+	0x07, 0x00, 0x00, 0x00
+};
+
+/*
+	This message is the last one sent by the device during initialization.
+*/
+static const char variax_init_done[] = {
+	0xf0, 0x00, 0x01, 0x0c, 0x07, 0x00, 0x6b
+};
+
+static const char variax_activate[] = {
+	0xf0, 0x00, 0x01, 0x0c, 0x07, 0x00, 0x2a, 0x01,
+	0xf7
+};
+
+/* forward declarations: */
+static void variax_startup2(unsigned long data);
+static void variax_startup4(unsigned long data);
+static void variax_startup5(unsigned long data);
+
+static void variax_activate_async(struct usb_line6_variax *variax, int a)
+{
+	variax->buffer_activate[VARIAX_OFFSET_ACTIVATE] = a;
+	line6_send_raw_message_async(&variax->line6, variax->buffer_activate,
+				     sizeof(variax_activate));
+}
+
+/*
+	Variax startup procedure.
+	This is a sequence of functions with special requirements (e.g., must
+	not run immediately after initialization, must not run in interrupt
+	context). After the last one has finished, the device is ready to use.
+*/
+
+static void variax_startup1(struct usb_line6_variax *variax)
+{
+	CHECK_STARTUP_PROGRESS(variax->startup_progress, VARIAX_STARTUP_INIT);
+
+	/* delay startup procedure: */
+	line6_start_timer(&variax->startup_timer1, VARIAX_STARTUP_DELAY1,
+			  variax_startup2, (unsigned long)variax);
+}
+
+static void variax_startup2(unsigned long data)
+{
+	struct usb_line6_variax *variax = (struct usb_line6_variax *)data;
+	struct usb_line6 *line6 = &variax->line6;
+
+	/* schedule another startup procedure until startup is complete: */
+	if (variax->startup_progress >= VARIAX_STARTUP_LAST)
+		return;
+
+	variax->startup_progress = VARIAX_STARTUP_VERSIONREQ;
+	line6_start_timer(&variax->startup_timer1, VARIAX_STARTUP_DELAY1,
+			  variax_startup2, (unsigned long)variax);
+
+	/* request firmware version: */
+	line6_version_request_async(line6);
+}
+
+static void variax_startup3(struct usb_line6_variax *variax)
+{
+	CHECK_STARTUP_PROGRESS(variax->startup_progress, VARIAX_STARTUP_WAIT);
+
+	/* delay startup procedure: */
+	line6_start_timer(&variax->startup_timer2, VARIAX_STARTUP_DELAY3,
+			  variax_startup4, (unsigned long)variax);
+}
+
+static void variax_startup4(unsigned long data)
+{
+	struct usb_line6_variax *variax = (struct usb_line6_variax *)data;
+
+	CHECK_STARTUP_PROGRESS(variax->startup_progress,
+			       VARIAX_STARTUP_ACTIVATE);
+
+	/* activate device: */
+	variax_activate_async(variax, 1);
+	line6_start_timer(&variax->startup_timer2, VARIAX_STARTUP_DELAY4,
+			  variax_startup5, (unsigned long)variax);
+}
+
+static void variax_startup5(unsigned long data)
+{
+	struct usb_line6_variax *variax = (struct usb_line6_variax *)data;
+
+	CHECK_STARTUP_PROGRESS(variax->startup_progress,
+			       VARIAX_STARTUP_WORKQUEUE);
+
+	/* schedule work for global work queue: */
+	schedule_work(&variax->startup_work);
+}
+
+static void variax_startup6(struct work_struct *work)
+{
+	struct usb_line6_variax *variax =
+	    container_of(work, struct usb_line6_variax, startup_work);
+
+	CHECK_STARTUP_PROGRESS(variax->startup_progress, VARIAX_STARTUP_SETUP);
+
+	/* ALSA audio interface: */
+	line6_register_audio(&variax->line6);
+}
+
+/*
+	Process a completely received message.
+*/
+static void line6_variax_process_message(struct usb_line6 *line6)
+{
+	struct usb_line6_variax *variax = (struct usb_line6_variax *) line6;
+	const unsigned char *buf = variax->line6.buffer_message;
+
+	switch (buf[0]) {
+	case LINE6_RESET:
+		dev_info(variax->line6.ifcdev, "VARIAX reset\n");
+		break;
+
+	case LINE6_SYSEX_BEGIN:
+		if (memcmp(buf + 1, variax_init_version + 1,
+			   sizeof(variax_init_version) - 1) == 0) {
+			variax_startup3(variax);
+		} else if (memcmp(buf + 1, variax_init_done + 1,
+				  sizeof(variax_init_done) - 1) == 0) {
+			/* notify of complete initialization: */
+			variax_startup4((unsigned long)variax);
+		}
+		break;
+	}
+}
+
+/*
+	Variax destructor.
+*/
+static void variax_destruct(struct usb_interface *interface)
+{
+	struct usb_line6_variax *variax = usb_get_intfdata(interface);
+
+	if (variax == NULL)
+		return;
+	line6_cleanup_audio(&variax->line6);
+
+	del_timer(&variax->startup_timer1);
+	del_timer(&variax->startup_timer2);
+	cancel_work_sync(&variax->startup_work);
+
+	kfree(variax->buffer_activate);
+}
+
+/*
+	Workbench device disconnected.
+*/
+static void line6_variax_disconnect(struct usb_interface *interface)
+{
+	if (interface == NULL)
+		return;
+
+	variax_destruct(interface);
+}
+
+/*
+	 Try to init workbench device.
+*/
+static int variax_try_init(struct usb_interface *interface,
+			   struct usb_line6 *line6)
+{
+	struct usb_line6_variax *variax = (struct usb_line6_variax *) line6;
+	int err;
+
+	line6->process_message = line6_variax_process_message;
+	line6->disconnect = line6_variax_disconnect;
+
+	init_timer(&variax->startup_timer1);
+	init_timer(&variax->startup_timer2);
+	INIT_WORK(&variax->startup_work, variax_startup6);
+
+	if ((interface == NULL) || (variax == NULL))
+		return -ENODEV;
+
+	/* initialize USB buffers: */
+	variax->buffer_activate = kmemdup(variax_activate,
+					  sizeof(variax_activate), GFP_KERNEL);
+
+	if (variax->buffer_activate == NULL) {
+		dev_err(&interface->dev, "Out of memory\n");
+		return -ENOMEM;
+	}
+
+	/* initialize audio system: */
+	err = line6_init_audio(&variax->line6);
+	if (err < 0)
+		return err;
+
+	/* initialize MIDI subsystem: */
+	err = line6_init_midi(&variax->line6);
+	if (err < 0)
+		return err;
+
+	/* initiate startup procedure: */
+	variax_startup1(variax);
+	return 0;
+}
+
+/*
+	 Init workbench device (and clean up in case of failure).
+*/
+int line6_variax_init(struct usb_interface *interface, struct usb_line6 *line6)
+{
+	int err = variax_try_init(interface, line6);
+
+	if (err < 0)
+		variax_destruct(interface);
+
+	return err;
+}
