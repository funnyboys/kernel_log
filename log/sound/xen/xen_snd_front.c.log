commit 58f9d806d16a38ed3bae11e2ada83393436a4956
Author: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
Date:   Fri Nov 30 09:42:05 2018 +0200

    ALSA: xen-front: Use Xen common shared buffer implementation
    
    Use page directory based shared buffer implementation
    now available as common code for Xen frontend drivers.
    
    Signed-off-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/sound/xen/xen_snd_front.c b/sound/xen/xen_snd_front.c
index b089b13b5160..a9e5c2cd7698 100644
--- a/sound/xen/xen_snd_front.c
+++ b/sound/xen/xen_snd_front.c
@@ -16,12 +16,12 @@
 #include <xen/xen.h>
 #include <xen/xenbus.h>
 
+#include <xen/xen-front-pgdir-shbuf.h>
 #include <xen/interface/io/sndif.h>
 
 #include "xen_snd_front.h"
 #include "xen_snd_front_alsa.h"
 #include "xen_snd_front_evtchnl.h"
-#include "xen_snd_front_shbuf.h"
 
 static struct xensnd_req *
 be_stream_prepare_req(struct xen_snd_front_evtchnl *evtchnl, u8 operation)
@@ -82,7 +82,7 @@ int xen_snd_front_stream_query_hw_param(struct xen_snd_front_evtchnl *evtchnl,
 }
 
 int xen_snd_front_stream_prepare(struct xen_snd_front_evtchnl *evtchnl,
-				 struct xen_snd_front_shbuf *sh_buf,
+				 struct xen_front_pgdir_shbuf *shbuf,
 				 u8 format, unsigned int channels,
 				 unsigned int rate, u32 buffer_sz,
 				 u32 period_sz)
@@ -99,7 +99,8 @@ int xen_snd_front_stream_prepare(struct xen_snd_front_evtchnl *evtchnl,
 	req->op.open.pcm_rate = rate;
 	req->op.open.buffer_sz = buffer_sz;
 	req->op.open.period_sz = period_sz;
-	req->op.open.gref_directory = xen_snd_front_shbuf_get_dir_start(sh_buf);
+	req->op.open.gref_directory =
+		xen_front_pgdir_shbuf_get_dir_start(shbuf);
 	mutex_unlock(&evtchnl->ring_io_lock);
 
 	ret = be_stream_do_io(evtchnl);

commit 0d5bcfc9974ad8ce0fc77a95a53ab704faa0dfb7
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu May 31 09:25:07 2018 +0300

    ALSA: xen-front: fix a loop timeout
    
    We want the loop to exit when "to" is set to zero, but in the current
    code it's set to -1.  Also I tweaked the indenting so it doesn't look
    like we're passing "--to" to xenbus_read_unsigned().
    
    Fixes: cc3196ae197c ("ALSA: xen-front: Introduce Xen para-virtualized sound frontend driver")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/xen/xen_snd_front.c b/sound/xen/xen_snd_front.c
index c18973a9bc9b..b089b13b5160 100644
--- a/sound/xen/xen_snd_front.c
+++ b/sound/xen/xen_snd_front.c
@@ -334,7 +334,7 @@ static int xen_drv_remove(struct xenbus_device *dev)
 	 */
 	while ((xenbus_read_unsigned(front_info->xb_dev->otherend, "state",
 				     XenbusStateUnknown) != XenbusStateInitWait) &&
-				     to--)
+	       --to)
 		msleep(10);
 
 	if (!to) {

commit 1cee559351a7cb57b405554bac10a6f33c28ed09
Author: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
Date:   Mon May 14 09:27:41 2018 +0300

    ALSA: xen-front: Implement ALSA virtual sound driver
    
    Implement essential initialization of the sound driver:
      - introduce required data structures
      - handle driver registration
      - handle sound card registration
      - register sound driver on backend connection
      - remove sound driver on backend disconnect
    
    Initialize virtual sound card with streams according to the
    Xen store configuration.
    
    Implement ALSA driver operations including:
      - manage frontend/backend shared buffers
      - manage Xen bus event channel states
    
    Implement requests from front to back for ALSA
    PCM operations.
      - report ALSA period elapsed event: handle XENSND_EVT_CUR_POS
        notifications from the backend when stream position advances
        during playback/capture. The event carries a value of how
        many octets were played/captured at the time of the event.
      - implement explicit stream parameter negotiation between
        backend and frontend: handle XENSND_OP_HW_PARAM_QUERY request
        to read/update configuration space for the parameter given:
        request passes desired parameter interval and the response to
        this request returns min/max interval for the parameter to be used.
    
    Signed-off-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/xen/xen_snd_front.c b/sound/xen/xen_snd_front.c
index cdf66ea516c4..c18973a9bc9b 100644
--- a/sound/xen/xen_snd_front.c
+++ b/sound/xen/xen_snd_front.c
@@ -19,10 +19,189 @@
 #include <xen/interface/io/sndif.h>
 
 #include "xen_snd_front.h"
+#include "xen_snd_front_alsa.h"
 #include "xen_snd_front_evtchnl.h"
+#include "xen_snd_front_shbuf.h"
+
+static struct xensnd_req *
+be_stream_prepare_req(struct xen_snd_front_evtchnl *evtchnl, u8 operation)
+{
+	struct xensnd_req *req;
+
+	req = RING_GET_REQUEST(&evtchnl->u.req.ring,
+			       evtchnl->u.req.ring.req_prod_pvt);
+	req->operation = operation;
+	req->id = evtchnl->evt_next_id++;
+	evtchnl->evt_id = req->id;
+	return req;
+}
+
+static int be_stream_do_io(struct xen_snd_front_evtchnl *evtchnl)
+{
+	if (unlikely(evtchnl->state != EVTCHNL_STATE_CONNECTED))
+		return -EIO;
+
+	reinit_completion(&evtchnl->u.req.completion);
+	xen_snd_front_evtchnl_flush(evtchnl);
+	return 0;
+}
+
+static int be_stream_wait_io(struct xen_snd_front_evtchnl *evtchnl)
+{
+	if (wait_for_completion_timeout(&evtchnl->u.req.completion,
+			msecs_to_jiffies(VSND_WAIT_BACK_MS)) <= 0)
+		return -ETIMEDOUT;
+
+	return evtchnl->u.req.resp_status;
+}
+
+int xen_snd_front_stream_query_hw_param(struct xen_snd_front_evtchnl *evtchnl,
+					struct xensnd_query_hw_param *hw_param_req,
+					struct xensnd_query_hw_param *hw_param_resp)
+{
+	struct xensnd_req *req;
+	int ret;
+
+	mutex_lock(&evtchnl->u.req.req_io_lock);
+
+	mutex_lock(&evtchnl->ring_io_lock);
+	req = be_stream_prepare_req(evtchnl, XENSND_OP_HW_PARAM_QUERY);
+	req->op.hw_param = *hw_param_req;
+	mutex_unlock(&evtchnl->ring_io_lock);
+
+	ret = be_stream_do_io(evtchnl);
+
+	if (ret == 0)
+		ret = be_stream_wait_io(evtchnl);
+
+	if (ret == 0)
+		*hw_param_resp = evtchnl->u.req.resp.hw_param;
+
+	mutex_unlock(&evtchnl->u.req.req_io_lock);
+	return ret;
+}
+
+int xen_snd_front_stream_prepare(struct xen_snd_front_evtchnl *evtchnl,
+				 struct xen_snd_front_shbuf *sh_buf,
+				 u8 format, unsigned int channels,
+				 unsigned int rate, u32 buffer_sz,
+				 u32 period_sz)
+{
+	struct xensnd_req *req;
+	int ret;
+
+	mutex_lock(&evtchnl->u.req.req_io_lock);
+
+	mutex_lock(&evtchnl->ring_io_lock);
+	req = be_stream_prepare_req(evtchnl, XENSND_OP_OPEN);
+	req->op.open.pcm_format = format;
+	req->op.open.pcm_channels = channels;
+	req->op.open.pcm_rate = rate;
+	req->op.open.buffer_sz = buffer_sz;
+	req->op.open.period_sz = period_sz;
+	req->op.open.gref_directory = xen_snd_front_shbuf_get_dir_start(sh_buf);
+	mutex_unlock(&evtchnl->ring_io_lock);
+
+	ret = be_stream_do_io(evtchnl);
+
+	if (ret == 0)
+		ret = be_stream_wait_io(evtchnl);
+
+	mutex_unlock(&evtchnl->u.req.req_io_lock);
+	return ret;
+}
+
+int xen_snd_front_stream_close(struct xen_snd_front_evtchnl *evtchnl)
+{
+	struct xensnd_req *req;
+	int ret;
+
+	mutex_lock(&evtchnl->u.req.req_io_lock);
+
+	mutex_lock(&evtchnl->ring_io_lock);
+	req = be_stream_prepare_req(evtchnl, XENSND_OP_CLOSE);
+	mutex_unlock(&evtchnl->ring_io_lock);
+
+	ret = be_stream_do_io(evtchnl);
+
+	if (ret == 0)
+		ret = be_stream_wait_io(evtchnl);
+
+	mutex_unlock(&evtchnl->u.req.req_io_lock);
+	return ret;
+}
+
+int xen_snd_front_stream_write(struct xen_snd_front_evtchnl *evtchnl,
+			       unsigned long pos, unsigned long count)
+{
+	struct xensnd_req *req;
+	int ret;
+
+	mutex_lock(&evtchnl->u.req.req_io_lock);
+
+	mutex_lock(&evtchnl->ring_io_lock);
+	req = be_stream_prepare_req(evtchnl, XENSND_OP_WRITE);
+	req->op.rw.length = count;
+	req->op.rw.offset = pos;
+	mutex_unlock(&evtchnl->ring_io_lock);
+
+	ret = be_stream_do_io(evtchnl);
+
+	if (ret == 0)
+		ret = be_stream_wait_io(evtchnl);
+
+	mutex_unlock(&evtchnl->u.req.req_io_lock);
+	return ret;
+}
+
+int xen_snd_front_stream_read(struct xen_snd_front_evtchnl *evtchnl,
+			      unsigned long pos, unsigned long count)
+{
+	struct xensnd_req *req;
+	int ret;
+
+	mutex_lock(&evtchnl->u.req.req_io_lock);
+
+	mutex_lock(&evtchnl->ring_io_lock);
+	req = be_stream_prepare_req(evtchnl, XENSND_OP_READ);
+	req->op.rw.length = count;
+	req->op.rw.offset = pos;
+	mutex_unlock(&evtchnl->ring_io_lock);
+
+	ret = be_stream_do_io(evtchnl);
+
+	if (ret == 0)
+		ret = be_stream_wait_io(evtchnl);
+
+	mutex_unlock(&evtchnl->u.req.req_io_lock);
+	return ret;
+}
+
+int xen_snd_front_stream_trigger(struct xen_snd_front_evtchnl *evtchnl,
+				 int type)
+{
+	struct xensnd_req *req;
+	int ret;
+
+	mutex_lock(&evtchnl->u.req.req_io_lock);
+
+	mutex_lock(&evtchnl->ring_io_lock);
+	req = be_stream_prepare_req(evtchnl, XENSND_OP_TRIGGER);
+	req->op.trigger.type = type;
+	mutex_unlock(&evtchnl->ring_io_lock);
+
+	ret = be_stream_do_io(evtchnl);
+
+	if (ret == 0)
+		ret = be_stream_wait_io(evtchnl);
+
+	mutex_unlock(&evtchnl->u.req.req_io_lock);
+	return ret;
+}
 
 static void xen_snd_drv_fini(struct xen_snd_front_info *front_info)
 {
+	xen_snd_front_alsa_fini(front_info);
 	xen_snd_front_evtchnl_free_all(front_info);
 }
 
@@ -45,7 +224,7 @@ static int sndback_initwait(struct xen_snd_front_info *front_info)
 
 static int sndback_connect(struct xen_snd_front_info *front_info)
 {
-	return 0;
+	return xen_snd_front_alsa_init(front_info);
 }
 
 static void sndback_disconnect(struct xen_snd_front_info *front_info)

commit d6e0fbb82e73a01e4cb3631b8b3dd7aae09ab14c
Author: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
Date:   Mon May 14 09:27:40 2018 +0300

    ALSA: xen-front: Implement handling of shared buffers
    
    Implement shared buffer handling according to the
    para-virtualized sound device protocol at xen/interface/io/sndif.h:
      - manage buffer memory
      - handle granted references
      - handle page directories
    
    [ Fixed missing linux/kernel.h inclusion -- tiwai ]
    
    Signed-off-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/xen/xen_snd_front.c b/sound/xen/xen_snd_front.c
index 277214d4fd0a..cdf66ea516c4 100644
--- a/sound/xen/xen_snd_front.c
+++ b/sound/xen/xen_snd_front.c
@@ -11,6 +11,7 @@
 #include <linux/delay.h>
 #include <linux/module.h>
 
+#include <xen/page.h>
 #include <xen/platform_pci.h>
 #include <xen/xen.h>
 #include <xen/xenbus.h>
@@ -191,6 +192,13 @@ static int __init xen_drv_init(void)
 	if (!xen_has_pv_devices())
 		return -ENODEV;
 
+	/* At the moment we only support case with XEN_PAGE_SIZE == PAGE_SIZE */
+	if (XEN_PAGE_SIZE != PAGE_SIZE) {
+		pr_err(XENSND_DRIVER_NAME ": different kernel and Xen page sizes are not supported: XEN_PAGE_SIZE (%lu) != PAGE_SIZE (%lu)\n",
+		       XEN_PAGE_SIZE, PAGE_SIZE);
+		return -ENODEV;
+	}
+
 	pr_info("Initialising Xen " XENSND_DRIVER_NAME " frontend driver\n");
 	return xenbus_register_frontend(&xen_driver);
 }

commit 788ef64a2caee38cc4b8890abd3d7e54dfa3bcc9
Author: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
Date:   Mon May 14 09:27:39 2018 +0300

    ALSA: xen-front: Implement Xen event channel handling
    
    Handle Xen event channels:
      - create for all configured streams and publish
        corresponding ring references and event channels in Xen store,
        so backend can connect
      - implement event channels interrupt handlers
      - create and destroy event channels with respect to Xen bus state
    
    Signed-off-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/xen/xen_snd_front.c b/sound/xen/xen_snd_front.c
index 70fa91683c71..277214d4fd0a 100644
--- a/sound/xen/xen_snd_front.c
+++ b/sound/xen/xen_snd_front.c
@@ -18,9 +18,11 @@
 #include <xen/interface/io/sndif.h>
 
 #include "xen_snd_front.h"
+#include "xen_snd_front_evtchnl.h"
 
 static void xen_snd_drv_fini(struct xen_snd_front_info *front_info)
 {
+	xen_snd_front_evtchnl_free_all(front_info);
 }
 
 static int sndback_initwait(struct xen_snd_front_info *front_info)
@@ -32,7 +34,12 @@ static int sndback_initwait(struct xen_snd_front_info *front_info)
 	if (ret < 0)
 		return ret;
 
-	return 0;
+	/* create event channels for all streams and publish */
+	ret = xen_snd_front_evtchnl_create_all(front_info, num_streams);
+	if (ret < 0)
+		return ret;
+
+	return xen_snd_front_evtchnl_publish_all(front_info);
 }
 
 static int sndback_connect(struct xen_snd_front_info *front_info)

commit fd3b36045c2c612b5f44a47f388677af256d1d0a
Author: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
Date:   Mon May 14 09:27:38 2018 +0300

    ALSA: xen-front: Read sound driver configuration from Xen store
    
    Read configuration values from Xen store according
    to xen/interface/io/sndif.h protocol:
      - introduce configuration structures for different
        components, e.g. sound card, device, stream
      - read PCM HW parameters, e.g rate, format etc.
      - detect stream type (capture/playback)
      - read device and card parameters
    
    Signed-off-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/xen/xen_snd_front.c b/sound/xen/xen_snd_front.c
index bbbe2767b565..70fa91683c71 100644
--- a/sound/xen/xen_snd_front.c
+++ b/sound/xen/xen_snd_front.c
@@ -25,6 +25,13 @@ static void xen_snd_drv_fini(struct xen_snd_front_info *front_info)
 
 static int sndback_initwait(struct xen_snd_front_info *front_info)
 {
+	int num_streams;
+	int ret;
+
+	ret = xen_snd_front_cfg_card(front_info, &num_streams);
+	if (ret < 0)
+		return ret;
+
 	return 0;
 }
 

commit cc3196ae197c28cd6db0a2e9ddddc2e0aa1e694f
Author: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
Date:   Mon May 14 09:27:37 2018 +0300

    ALSA: xen-front: Introduce Xen para-virtualized sound frontend driver
    
    Introduce skeleton of the para-virtualized Xen sound
    frontend driver.
    
    Initial handling for Xen bus states: implement
    Xen bus state machine for the frontend driver according to
    the state diagram and recovery flow from sound para-virtualized
    protocol: xen/interface/io/sndif.h.
    
    Signed-off-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Reviewed-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/xen/xen_snd_front.c b/sound/xen/xen_snd_front.c
new file mode 100644
index 000000000000..bbbe2767b565
--- /dev/null
+++ b/sound/xen/xen_snd_front.c
@@ -0,0 +1,196 @@
+// SPDX-License-Identifier: GPL-2.0 OR MIT
+
+/*
+ * Xen para-virtual sound device
+ *
+ * Copyright (C) 2016-2018 EPAM Systems Inc.
+ *
+ * Author: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+
+#include <xen/platform_pci.h>
+#include <xen/xen.h>
+#include <xen/xenbus.h>
+
+#include <xen/interface/io/sndif.h>
+
+#include "xen_snd_front.h"
+
+static void xen_snd_drv_fini(struct xen_snd_front_info *front_info)
+{
+}
+
+static int sndback_initwait(struct xen_snd_front_info *front_info)
+{
+	return 0;
+}
+
+static int sndback_connect(struct xen_snd_front_info *front_info)
+{
+	return 0;
+}
+
+static void sndback_disconnect(struct xen_snd_front_info *front_info)
+{
+	xen_snd_drv_fini(front_info);
+	xenbus_switch_state(front_info->xb_dev, XenbusStateInitialising);
+}
+
+static void sndback_changed(struct xenbus_device *xb_dev,
+			    enum xenbus_state backend_state)
+{
+	struct xen_snd_front_info *front_info = dev_get_drvdata(&xb_dev->dev);
+	int ret;
+
+	dev_dbg(&xb_dev->dev, "Backend state is %s, front is %s\n",
+		xenbus_strstate(backend_state),
+		xenbus_strstate(xb_dev->state));
+
+	switch (backend_state) {
+	case XenbusStateReconfiguring:
+		/* fall through */
+	case XenbusStateReconfigured:
+		/* fall through */
+	case XenbusStateInitialised:
+		/* fall through */
+		break;
+
+	case XenbusStateInitialising:
+		/* Recovering after backend unexpected closure. */
+		sndback_disconnect(front_info);
+		break;
+
+	case XenbusStateInitWait:
+		/* Recovering after backend unexpected closure. */
+		sndback_disconnect(front_info);
+
+		ret = sndback_initwait(front_info);
+		if (ret < 0)
+			xenbus_dev_fatal(xb_dev, ret, "initializing frontend");
+		else
+			xenbus_switch_state(xb_dev, XenbusStateInitialised);
+		break;
+
+	case XenbusStateConnected:
+		if (xb_dev->state != XenbusStateInitialised)
+			break;
+
+		ret = sndback_connect(front_info);
+		if (ret < 0)
+			xenbus_dev_fatal(xb_dev, ret, "initializing frontend");
+		else
+			xenbus_switch_state(xb_dev, XenbusStateConnected);
+		break;
+
+	case XenbusStateClosing:
+		/*
+		 * In this state backend starts freeing resources,
+		 * so let it go into closed state first, so we can also
+		 * remove ours.
+		 */
+		break;
+
+	case XenbusStateUnknown:
+		/* fall through */
+	case XenbusStateClosed:
+		if (xb_dev->state == XenbusStateClosed)
+			break;
+
+		sndback_disconnect(front_info);
+		break;
+	}
+}
+
+static int xen_drv_probe(struct xenbus_device *xb_dev,
+			 const struct xenbus_device_id *id)
+{
+	struct xen_snd_front_info *front_info;
+
+	front_info = devm_kzalloc(&xb_dev->dev,
+				  sizeof(*front_info), GFP_KERNEL);
+	if (!front_info)
+		return -ENOMEM;
+
+	front_info->xb_dev = xb_dev;
+	dev_set_drvdata(&xb_dev->dev, front_info);
+
+	return xenbus_switch_state(xb_dev, XenbusStateInitialising);
+}
+
+static int xen_drv_remove(struct xenbus_device *dev)
+{
+	struct xen_snd_front_info *front_info = dev_get_drvdata(&dev->dev);
+	int to = 100;
+
+	xenbus_switch_state(dev, XenbusStateClosing);
+
+	/*
+	 * On driver removal it is disconnected from XenBus,
+	 * so no backend state change events come via .otherend_changed
+	 * callback. This prevents us from exiting gracefully, e.g.
+	 * signaling the backend to free event channels, waiting for its
+	 * state to change to XenbusStateClosed and cleaning at our end.
+	 * Normally when front driver removed backend will finally go into
+	 * XenbusStateInitWait state.
+	 *
+	 * Workaround: read backend's state manually and wait with time-out.
+	 */
+	while ((xenbus_read_unsigned(front_info->xb_dev->otherend, "state",
+				     XenbusStateUnknown) != XenbusStateInitWait) &&
+				     to--)
+		msleep(10);
+
+	if (!to) {
+		unsigned int state;
+
+		state = xenbus_read_unsigned(front_info->xb_dev->otherend,
+					     "state", XenbusStateUnknown);
+		pr_err("Backend state is %s while removing driver\n",
+		       xenbus_strstate(state));
+	}
+
+	xen_snd_drv_fini(front_info);
+	xenbus_frontend_closed(dev);
+	return 0;
+}
+
+static const struct xenbus_device_id xen_drv_ids[] = {
+	{ XENSND_DRIVER_NAME },
+	{ "" }
+};
+
+static struct xenbus_driver xen_driver = {
+	.ids = xen_drv_ids,
+	.probe = xen_drv_probe,
+	.remove = xen_drv_remove,
+	.otherend_changed = sndback_changed,
+};
+
+static int __init xen_drv_init(void)
+{
+	if (!xen_domain())
+		return -ENODEV;
+
+	if (!xen_has_pv_devices())
+		return -ENODEV;
+
+	pr_info("Initialising Xen " XENSND_DRIVER_NAME " frontend driver\n");
+	return xenbus_register_frontend(&xen_driver);
+}
+
+static void __exit xen_drv_fini(void)
+{
+	pr_info("Unregistering Xen " XENSND_DRIVER_NAME " frontend driver\n");
+	xenbus_unregister_driver(&xen_driver);
+}
+
+module_init(xen_drv_init);
+module_exit(xen_drv_fini);
+
+MODULE_DESCRIPTION("Xen virtual sound device frontend");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("xen:" XENSND_DRIVER_NAME);
+MODULE_SUPPORTED_DEVICE("{{ALSA,Virtual soundcard}}");
