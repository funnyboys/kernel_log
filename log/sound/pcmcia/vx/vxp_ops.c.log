commit c09482455ca586539802282380f59f54a1febf16
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:22 2020 +0100

    ALSA: vx: More constifications
    
    Apply const prefix to every possible place: the static tables for DSP
    commands, the string tables, and register/offset tables.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-8-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index f7cf707d315f..45eeb0f57d59 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -15,7 +15,7 @@
 #include "vxpocket.h"
 
 
-static int vxp_reg_offset[VX_REG_MAX] = {
+static const int vxp_reg_offset[VX_REG_MAX] = {
 	[VX_ICR]	= 0x00,		// ICR
 	[VX_CVR]	= 0x01,		// CVR
 	[VX_ISR]	= 0x02,		// ISR

commit f8ae2d2919481817d2e942617c203fc792687c66
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:46 2020 +0100

    ALSA: vx: Constify snd_vx_hardware and snd_vx_ops definitions
    
    Both snd_vx_hardware and snd_vx_ops are only referred without
    modification, hence they can be constified gracefully for further
    optimizations.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-31-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index 447c6342eec8..f7cf707d315f 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -581,7 +581,7 @@ static void vxp_reset_board(struct vx_core *_chip, int cold_reset)
  * callbacks
  */
 /* exported */
-struct snd_vx_ops snd_vxpocket_ops = {
+const struct snd_vx_ops snd_vxpocket_ops = {
 	.in8 = vxp_inb,
 	.out8 = vxp_outb,
 	.test_and_ack = vxp_test_and_ack,

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index 4c4ef1fec69f..447c6342eec8 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Driver for Digigram VXpocket soundcards
  *
  * lowlevel routines for VXpocket soundcards
  *
  * Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include <linux/delay.h>

commit 3acd3e3bab95ec3622ff98da313290ee823a0f68
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 17:11:38 2018 +0200

    ALSA: vxpocket: Fix invalid endian conversions
    
    The endian conversions used in vxp_dma_read() and vxp_dma_write() are
    superfluous and even wrong on big-endian machines, as inw() and outw()
    already do conversions.  Kill them.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index 8cde40226355..4c4ef1fec69f 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -375,7 +375,7 @@ static void vxp_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 		length >>= 1; /* in 16bit words */
 		/* Transfer using pseudo-dma. */
 		for (; length > 0; length--) {
-			outw(cpu_to_le16(*addr), port);
+			outw(*addr, port);
 			addr++;
 		}
 		addr = (unsigned short *)runtime->dma_area;
@@ -385,7 +385,7 @@ static void vxp_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 	count >>= 1; /* in 16bit words */
 	/* Transfer using pseudo-dma. */
 	for (; count > 0; count--) {
-		outw(cpu_to_le16(*addr), port);
+		outw(*addr, port);
 		addr++;
 	}
 	vx_release_pseudo_dma(chip);
@@ -417,7 +417,7 @@ static void vxp_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 		length >>= 1; /* in 16bit words */
 		/* Transfer using pseudo-dma. */
 		for (; length > 0; length--)
-			*addr++ = le16_to_cpu(inw(port));
+			*addr++ = inw(port);
 		addr = (unsigned short *)runtime->dma_area;
 		pipe->hw_ptr = 0;
 	}
@@ -425,12 +425,12 @@ static void vxp_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 	count >>= 1; /* in 16bit words */
 	/* Transfer using pseudo-dma. */
 	for (; count > 1; count--)
-		*addr++ = le16_to_cpu(inw(port));
+		*addr++ = inw(port);
 	/* Disable DMA */
 	pchip->regDIALOG &= ~VXP_DLG_DMAREAD_SEL_MASK;
 	vx_outb(chip, DIALOG, pchip->regDIALOG);
 	/* Read the last word (16 bits) */
-	*addr = le16_to_cpu(inw(port));
+	*addr = inw(port);
 	/* Disable 16-bit accesses */
 	pchip->regDIALOG &= ~VXP_DLG_DMA16_SEL_MASK;
 	vx_outb(chip, DIALOG, pchip->regDIALOG);

commit 2e0de6ea956ff429cf11bd1a92d7444bc6000698
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 12 10:03:35 2017 +0200

    ALSA: vxpocket: Use container_of()
    
    The vxpocket driver is using the explicit cast from the parent class
    pointer, but it'll be broken when the structure field randomization is
    applied.  Use container_of() in a modern manner, instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index 5f97791f00d7..8cde40226355 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -50,7 +50,7 @@ static int vxp_reg_offset[VX_REG_MAX] = {
 
 static inline unsigned long vxp_reg_addr(struct vx_core *_chip, int reg)
 {
-	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+	struct snd_vxpocket *chip = to_vxpocket(_chip);
 	return chip->port + vxp_reg_offset[reg];
 }
 
@@ -110,7 +110,7 @@ static int vx_check_magic(struct vx_core *chip)
 
 static void vxp_reset_dsp(struct vx_core *_chip)
 {
-	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+	struct snd_vxpocket *chip = to_vxpocket(_chip);
 
 	/* set the reset dsp bit to 1 */
 	vx_outb(chip, CDSP, chip->regCDSP | VXP_CDSP_DSP_RESET_MASK);
@@ -128,7 +128,7 @@ static void vxp_reset_dsp(struct vx_core *_chip)
  */
 static void vxp_reset_codec(struct vx_core *_chip)
 {
-	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+	struct snd_vxpocket *chip = to_vxpocket(_chip);
 
 	/* Set the reset CODEC bit to 1. */
 	vx_outb(chip, CDSP, chip->regCDSP | VXP_CDSP_CODEC_RESET_MASK);
@@ -147,7 +147,7 @@ static void vxp_reset_codec(struct vx_core *_chip)
  */
 static int vxp_load_xilinx_binary(struct vx_core *_chip, const struct firmware *fw)
 {
-	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+	struct snd_vxpocket *chip = to_vxpocket(_chip);
 	unsigned int i;
 	int c;
 	int regCSUER, regRUER;
@@ -280,7 +280,7 @@ static int vxp_load_dsp(struct vx_core *vx, int index, const struct firmware *fw
  */
 static int vxp_test_and_ack(struct vx_core *_chip)
 {
-	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+	struct snd_vxpocket *chip = to_vxpocket(_chip);
 
 	/* not booted yet? */
 	if (! (_chip->chip_status & VX_STAT_XILINX_LOADED))
@@ -307,7 +307,7 @@ static int vxp_test_and_ack(struct vx_core *_chip)
  */
 static void vxp_validate_irq(struct vx_core *_chip, int enable)
 {
-	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+	struct snd_vxpocket *chip = to_vxpocket(_chip);
 
 	/* Set the interrupt enable bit to 1 in CDSP register */
 	if (enable)
@@ -323,7 +323,7 @@ static void vxp_validate_irq(struct vx_core *_chip, int enable)
  */
 static void vx_setup_pseudo_dma(struct vx_core *_chip, int do_write)
 {
-	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+	struct snd_vxpocket *chip = to_vxpocket(_chip);
 
 	/* Interrupt mode and HREQ pin enabled for host transmit / receive data transfers */
 	vx_outb(chip, ICR, do_write ? ICR_TREQ : ICR_RREQ);
@@ -343,7 +343,7 @@ static void vx_setup_pseudo_dma(struct vx_core *_chip, int do_write)
  */
 static void vx_release_pseudo_dma(struct vx_core *_chip)
 {
-	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+	struct snd_vxpocket *chip = to_vxpocket(_chip);
 
 	/* Disable DMA and 16-bit accesses */
 	chip->regDIALOG &= ~(VXP_DLG_DMAWRITE_SEL_MASK|
@@ -403,7 +403,7 @@ static void vxp_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 static void vxp_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 			 struct vx_pipe *pipe, int count)
 {
-	struct snd_vxpocket *pchip = (struct snd_vxpocket *)chip;
+	struct snd_vxpocket *pchip = to_vxpocket(chip);
 	long port = vxp_reg_addr(chip, VX_DMA);
 	int offset = pipe->hw_ptr;
 	unsigned short *addr = (unsigned short *)(runtime->dma_area + offset);
@@ -467,7 +467,7 @@ static void vxp_write_codec_reg(struct vx_core *chip, int codec, unsigned int da
  */
 void vx_set_mic_boost(struct vx_core *chip, int boost)
 {
-	struct snd_vxpocket *pchip = (struct snd_vxpocket *)chip;
+	struct snd_vxpocket *pchip = to_vxpocket(chip);
 
 	if (chip->chip_status & VX_STAT_IS_STALE)
 		return;
@@ -509,7 +509,7 @@ static int vx_compute_mic_level(int level)
  */
 void vx_set_mic_level(struct vx_core *chip, int level)
 {
-	struct snd_vxpocket *pchip = (struct snd_vxpocket *)chip;
+	struct snd_vxpocket *pchip = to_vxpocket(chip);
 
 	if (chip->chip_status & VX_STAT_IS_STALE)
 		return;
@@ -528,7 +528,7 @@ void vx_set_mic_level(struct vx_core *chip, int level)
  */
 static void vxp_change_audio_source(struct vx_core *_chip, int src)
 {
-	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+	struct snd_vxpocket *chip = to_vxpocket(_chip);
 
 	switch (src) {
 	case VX_AUDIO_SRC_DIGITAL:
@@ -568,7 +568,7 @@ static void vxp_change_audio_source(struct vx_core *_chip, int src)
  */
 static void vxp_set_clock_source(struct vx_core *_chip, int source)
 {
-	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+	struct snd_vxpocket *chip = to_vxpocket(_chip);
 
 	if (source == INTERNAL_QUARTZ)
 		chip->regCDSP &= ~VXP_CDSP_CLOCKIN_SEL_MASK;
@@ -583,7 +583,7 @@ static void vxp_set_clock_source(struct vx_core *_chip, int source)
  */
 static void vxp_reset_board(struct vx_core *_chip, int cold_reset)
 {
-	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+	struct snd_vxpocket *chip = to_vxpocket(_chip);
 
 	chip->regCDSP = 0;
 	chip->regDIALOG = 0;

commit 5b5e0928f742cfa853b2411400a1b19fa379d758
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Feb 27 14:30:02 2017 -0800

    lib/vsprintf.c: remove %Z support
    
    Now that %z is standartised in C99 there is no reason to support %Z.
    Unlike %L it doesn't even make format strings smaller.
    
    Use BUILD_BUG_ON in a couple ATM drivers.
    
    In case anyone didn't notice lib/vsprintf.o is about half of SLUB which
    is in my opinion is quite an achievement.  Hopefully this patch inspires
    someone else to trim vsprintf.c more.
    
    Link: http://lkml.kernel.org/r/20170103230126.GA30170@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index 56aa1ba73ccc..5f97791f00d7 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -201,7 +201,7 @@ static int vxp_load_xilinx_binary(struct vx_core *_chip, const struct firmware *
 	c |= (int)vx_inb(chip, RXM) << 8;
 	c |= vx_inb(chip, RXL);
 
-	snd_printdd(KERN_DEBUG "xilinx: dsp size received 0x%x, orig 0x%Zx\n", c, fw->size);
+	snd_printdd(KERN_DEBUG "xilinx: dsp size received 0x%x, orig 0x%zx\n", c, fw->size);
 
 	vx_outb(chip, ICR, ICR_HF0);
 

commit 874e1f6fad9a5184b67f4cee37c1335cd2cc5677
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 4 12:19:15 2017 +0100

    ALSA: vx: Fix possible transfer overflow
    
    The pseudo DMA transfer codes in VX222 and VX-pocket driver have a
    slight bug where they check the buffer boundary wrongly, and may
    overflow.  Also, the zero sample count might be handled badly for the
    playback (although it shouldn't happen in theory).  This patch
    addresses these issues.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=141541
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index 281972913c32..56aa1ba73ccc 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -369,12 +369,12 @@ static void vxp_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 	unsigned short *addr = (unsigned short *)(runtime->dma_area + offset);
 
 	vx_setup_pseudo_dma(chip, 1);
-	if (offset + count > pipe->buffer_bytes) {
+	if (offset + count >= pipe->buffer_bytes) {
 		int length = pipe->buffer_bytes - offset;
 		count -= length;
 		length >>= 1; /* in 16bit words */
 		/* Transfer using pseudo-dma. */
-		while (length-- > 0) {
+		for (; length > 0; length--) {
 			outw(cpu_to_le16(*addr), port);
 			addr++;
 		}
@@ -384,7 +384,7 @@ static void vxp_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 	pipe->hw_ptr += count;
 	count >>= 1; /* in 16bit words */
 	/* Transfer using pseudo-dma. */
-	while (count-- > 0) {
+	for (; count > 0; count--) {
 		outw(cpu_to_le16(*addr), port);
 		addr++;
 	}
@@ -411,12 +411,12 @@ static void vxp_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 	if (snd_BUG_ON(count % 2))
 		return;
 	vx_setup_pseudo_dma(chip, 0);
-	if (offset + count > pipe->buffer_bytes) {
+	if (offset + count >= pipe->buffer_bytes) {
 		int length = pipe->buffer_bytes - offset;
 		count -= length;
 		length >>= 1; /* in 16bit words */
 		/* Transfer using pseudo-dma. */
-		while (length-- > 0)
+		for (; length > 0; length--)
 			*addr++ = le16_to_cpu(inw(port));
 		addr = (unsigned short *)runtime->dma_area;
 		pipe->hw_ptr = 0;
@@ -424,7 +424,7 @@ static void vxp_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 	pipe->hw_ptr += count;
 	count >>= 1; /* in 16bit words */
 	/* Transfer using pseudo-dma. */
-	while (count-- > 1)
+	for (; count > 1; count--)
 		*addr++ = le16_to_cpu(inw(port));
 	/* Disable DMA */
 	pchip->regDIALOG &= ~VXP_DLG_DMAREAD_SEL_MASK;

commit db0a5214b8d6cc7a90ce3336d24a85b90cbb4e67
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 9 17:17:20 2014 +0200

    ALSA: vx: Use nonatomic PCM ops
    
    Rewrite VXpocket and VX222 drivers to use the new PCM nonatomic ops.
    The former irq tasklet is replaced with a threaded irq handler, and
    the tasklet for the PCM delayed start is simply merged into the normal
    PCM trigger, as well as the replacement of spinlock with mutex.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index fe33e122e372..281972913c32 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -468,12 +468,11 @@ static void vxp_write_codec_reg(struct vx_core *chip, int codec, unsigned int da
 void vx_set_mic_boost(struct vx_core *chip, int boost)
 {
 	struct snd_vxpocket *pchip = (struct snd_vxpocket *)chip;
-	unsigned long flags;
 
 	if (chip->chip_status & VX_STAT_IS_STALE)
 		return;
 
-	spin_lock_irqsave(&chip->lock, flags);
+	mutex_lock(&chip->lock);
 	if (pchip->regCDSP & P24_CDSP_MICS_SEL_MASK) {
 		if (boost) {
 			/* boost: 38 dB */
@@ -486,7 +485,7 @@ void vx_set_mic_boost(struct vx_core *chip, int boost)
                 }
 		vx_outb(chip, CDSP, pchip->regCDSP);
 	}
-	spin_unlock_irqrestore(&chip->lock, flags);
+	mutex_unlock(&chip->lock);
 }
 
 /*
@@ -511,17 +510,16 @@ static int vx_compute_mic_level(int level)
 void vx_set_mic_level(struct vx_core *chip, int level)
 {
 	struct snd_vxpocket *pchip = (struct snd_vxpocket *)chip;
-	unsigned long flags;
 
 	if (chip->chip_status & VX_STAT_IS_STALE)
 		return;
 
-	spin_lock_irqsave(&chip->lock, flags);
+	mutex_lock(&chip->lock);
 	if (pchip->regCDSP & VXP_CDSP_MIC_SEL_MASK) {
 		level = vx_compute_mic_level(level);
 		vx_outb(chip, MICRO, level);
 	}
-	spin_unlock_irqrestore(&chip->lock, flags);
+	mutex_unlock(&chip->lock);
 }
 
 

commit ddfb319926462fd9670b7c1678a1f6a14a68e421
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 2 17:49:53 2011 +0100

    ALSA: use linux/io.h to fix compile warnings
    
    For helping to reduce Greert's regression list...
      src/sound/drivers/mtpav.c: error: implicit declaration of function 'inb'
      src/sound/drivers/mtpav.c: error: implicit declaration of function 'outb'
      ...
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index 989e04abb520..fe33e122e372 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -23,8 +23,8 @@
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/firmware.h>
+#include <linux/io.h>
 #include <sound/core.h>
-#include <asm/io.h>
 #include "vxpocket.h"
 
 

commit 5e246b850df563224be26f1d409cf66fd6c968df
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:47 2008 +0200

    ALSA: Kill snd_assert() in other places
    
    Kill snd_assert() in other places, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index 99bf2a65a6f5..989e04abb520 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -408,7 +408,8 @@ static void vxp_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
 	int offset = pipe->hw_ptr;
 	unsigned short *addr = (unsigned short *)(runtime->dma_area + offset);
 
-	snd_assert(count % 2 == 0, return);
+	if (snd_BUG_ON(count % 2))
+		return;
 	vx_setup_pseudo_dma(chip, 0);
 	if (offset + count > pipe->buffer_bytes) {
 		int length = pipe->buffer_bytes - offset;

commit 7fc077fba5f8896c6fed3b35c5a10e7fdae82bbe
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jul 8 17:52:10 2008 +0100

    ALSA: Fix a const to non-const assignment in the Digigram VXpocket sound driver
    
    Fix a const to non-const pointer assignment warning in the Digigram VXpocket
    sound driver.
    
    This may be due to patch 0aa4937648b91e9e6d3879b2cbeaa5f0c9863ac0.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index 157b0b539f39..99bf2a65a6f5 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -151,7 +151,7 @@ static int vxp_load_xilinx_binary(struct vx_core *_chip, const struct firmware *
 	unsigned int i;
 	int c;
 	int regCSUER, regRUER;
-	unsigned char *image;
+	const unsigned char *image;
 	unsigned char data;
 
 	/* Switch to programmation mode */

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index 1ee0918c3b9f..157b0b539f39 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -20,7 +20,6 @@
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
-#include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/firmware.h>

commit 3f3488b84c261ab3cb64b9f0b9f40b61e33edb98
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Thu Jun 8 12:01:44 2006 +0200

    [ALSA] sound/vxpocket: fix printk warning
    
    Fix printk format warning:
    sound/pcmcia/vx/vxp_ops.c:205: warning: format '%x' expects type 'unsigned int', but argument 5 has type 'size_t'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index 7f82f619f9f4..1ee0918c3b9f 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -202,7 +202,7 @@ static int vxp_load_xilinx_binary(struct vx_core *_chip, const struct firmware *
 	c |= (int)vx_inb(chip, RXM) << 8;
 	c |= vx_inb(chip, RXL);
 
-	snd_printdd(KERN_DEBUG "xilinx: dsp size received 0x%x, orig 0x%x\n", c, fw->size);
+	snd_printdd(KERN_DEBUG "xilinx: dsp size received 0x%x, orig 0x%Zx\n", c, fw->size);
 
 	vx_outb(chip, ICR, ICR_HF0);
 

commit af26367f69a474ed809e4a59abb5855b47daaff4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:46:59 2005 +0100

    [ALSA] Remove xxx_t typedefs: VXdriver
    
    Remove xxx_t typedefs from the VXdriver codes
    (vx_core support, vx222 and vxpocket).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index 2754d657a4d6..7f82f619f9f4 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -49,7 +49,7 @@ static int vxp_reg_offset[VX_REG_MAX] = {
 };
 
 
-static inline unsigned long vxp_reg_addr(vx_core_t *_chip, int reg)
+static inline unsigned long vxp_reg_addr(struct vx_core *_chip, int reg)
 {
 	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
 	return chip->port + vxp_reg_offset[reg];
@@ -59,7 +59,7 @@ static inline unsigned long vxp_reg_addr(vx_core_t *_chip, int reg)
  * snd_vx_inb - read a byte from the register
  * @offset: register offset
  */
-static unsigned char vxp_inb(vx_core_t *chip, int offset)
+static unsigned char vxp_inb(struct vx_core *chip, int offset)
 {
 	return inb(vxp_reg_addr(chip, offset));
 }
@@ -69,7 +69,7 @@ static unsigned char vxp_inb(vx_core_t *chip, int offset)
  * @offset: the register offset
  * @val: the value to write
  */
-static void vxp_outb(vx_core_t *chip, int offset, unsigned char val)
+static void vxp_outb(struct vx_core *chip, int offset, unsigned char val)
 {
 	outb(val, vxp_reg_addr(chip, offset));
 }
@@ -78,9 +78,9 @@ static void vxp_outb(vx_core_t *chip, int offset, unsigned char val)
  * redefine macros to call directly
  */
 #undef vx_inb
-#define vx_inb(chip,reg)	vxp_inb((vx_core_t*)(chip), VX_##reg)
+#define vx_inb(chip,reg)	vxp_inb((struct vx_core *)(chip), VX_##reg)
 #undef vx_outb
-#define vx_outb(chip,reg,val)	vxp_outb((vx_core_t*)(chip), VX_##reg,val)
+#define vx_outb(chip,reg,val)	vxp_outb((struct vx_core *)(chip), VX_##reg,val)
 
 
 /*
@@ -88,7 +88,7 @@ static void vxp_outb(vx_core_t *chip, int offset, unsigned char val)
  *
  * returns zero if a magic word is detected, or a negative error code.
  */
-static int vx_check_magic(vx_core_t *chip)
+static int vx_check_magic(struct vx_core *chip)
 {
 	unsigned long end_time = jiffies + HZ / 5;
 	int c;
@@ -109,7 +109,7 @@ static int vx_check_magic(vx_core_t *chip)
 
 #define XX_DSP_RESET_WAIT_TIME		2	/* ms */
 
-static void vxp_reset_dsp(vx_core_t *_chip)
+static void vxp_reset_dsp(struct vx_core *_chip)
 {
 	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
 
@@ -127,7 +127,7 @@ static void vxp_reset_dsp(vx_core_t *_chip)
 /*
  * reset codec bit
  */
-static void vxp_reset_codec(vx_core_t *_chip)
+static void vxp_reset_codec(struct vx_core *_chip)
 {
 	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
 
@@ -146,7 +146,7 @@ static void vxp_reset_codec(vx_core_t *_chip)
  * vx_load_xilinx_binary - load the xilinx binary image
  * the binary image is the binary array converted from the bitstream file.
  */
-static int vxp_load_xilinx_binary(vx_core_t *_chip, const struct firmware *fw)
+static int vxp_load_xilinx_binary(struct vx_core *_chip, const struct firmware *fw)
 {
 	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
 	unsigned int i;
@@ -244,7 +244,7 @@ static int vxp_load_xilinx_binary(vx_core_t *_chip, const struct firmware *fw)
 /*
  * vxp_load_dsp - load_dsp callback
  */
-static int vxp_load_dsp(vx_core_t *vx, int index, const struct firmware *fw)
+static int vxp_load_dsp(struct vx_core *vx, int index, const struct firmware *fw)
 {
 	int err;
 
@@ -279,7 +279,7 @@ static int vxp_load_dsp(vx_core_t *vx, int index, const struct firmware *fw)
  *
  * spinlock held!
  */
-static int vxp_test_and_ack(vx_core_t *_chip)
+static int vxp_test_and_ack(struct vx_core *_chip)
 {
 	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
 
@@ -306,7 +306,7 @@ static int vxp_test_and_ack(vx_core_t *_chip)
 /*
  * vx_validate_irq - enable/disable IRQ
  */
-static void vxp_validate_irq(vx_core_t *_chip, int enable)
+static void vxp_validate_irq(struct vx_core *_chip, int enable)
 {
 	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
 
@@ -322,7 +322,7 @@ static void vxp_validate_irq(vx_core_t *_chip, int enable)
  * vx_setup_pseudo_dma - set up the pseudo dma read/write mode.
  * @do_write: 0 = read, 1 = set up for DMA write
  */
-static void vx_setup_pseudo_dma(vx_core_t *_chip, int do_write)
+static void vx_setup_pseudo_dma(struct vx_core *_chip, int do_write)
 {
 	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
 
@@ -342,7 +342,7 @@ static void vx_setup_pseudo_dma(vx_core_t *_chip, int do_write)
 /*
  * vx_release_pseudo_dma - disable the pseudo-DMA mode
  */
-static void vx_release_pseudo_dma(vx_core_t *_chip)
+static void vx_release_pseudo_dma(struct vx_core *_chip)
 {
 	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
 
@@ -362,8 +362,8 @@ static void vx_release_pseudo_dma(vx_core_t *_chip)
  * data size must be aligned to 6 bytes to ensure the 24bit alignment on DSP.
  * NB: call with a certain lock!
  */
-static void vxp_dma_write(vx_core_t *chip, snd_pcm_runtime_t *runtime,
-			  vx_pipe_t *pipe, int count)
+static void vxp_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,
+			  struct vx_pipe *pipe, int count)
 {
 	long port = vxp_reg_addr(chip, VX_DMA);
 	int offset = pipe->hw_ptr;
@@ -401,8 +401,8 @@ static void vxp_dma_write(vx_core_t *chip, snd_pcm_runtime_t *runtime,
  * the read length must be aligned to 6 bytes, as well as write.
  * NB: call with a certain lock!
  */
-static void vxp_dma_read(vx_core_t *chip, snd_pcm_runtime_t *runtime,
-			 vx_pipe_t *pipe, int count)
+static void vxp_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,
+			 struct vx_pipe *pipe, int count)
 {
 	struct snd_vxpocket *pchip = (struct snd_vxpocket *)chip;
 	long port = vxp_reg_addr(chip, VX_DMA);
@@ -442,7 +442,7 @@ static void vxp_dma_read(vx_core_t *chip, snd_pcm_runtime_t *runtime,
 /*
  * write a codec data (24bit)
  */
-static void vxp_write_codec_reg(vx_core_t *chip, int codec, unsigned int data)
+static void vxp_write_codec_reg(struct vx_core *chip, int codec, unsigned int data)
 {
 	int i;
 
@@ -465,7 +465,7 @@ static void vxp_write_codec_reg(vx_core_t *chip, int codec, unsigned int data)
  * vx_set_mic_boost - set mic boost level (on vxp440 only)
  * @boost: 0 = 20dB, 1 = +38dB
  */
-void vx_set_mic_boost(vx_core_t *chip, int boost)
+void vx_set_mic_boost(struct vx_core *chip, int boost)
 {
 	struct snd_vxpocket *pchip = (struct snd_vxpocket *)chip;
 	unsigned long flags;
@@ -508,7 +508,7 @@ static int vx_compute_mic_level(int level)
  * vx_set_mic_level - set mic level (on vxpocket only)
  * @level: the mic level = 0 - 8 (max)
  */
-void vx_set_mic_level(vx_core_t *chip, int level)
+void vx_set_mic_level(struct vx_core *chip, int level)
 {
 	struct snd_vxpocket *pchip = (struct snd_vxpocket *)chip;
 	unsigned long flags;
@@ -528,7 +528,7 @@ void vx_set_mic_level(vx_core_t *chip, int level)
 /*
  * change the input audio source
  */
-static void vxp_change_audio_source(vx_core_t *_chip, int src)
+static void vxp_change_audio_source(struct vx_core *_chip, int src)
 {
 	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
 
@@ -568,7 +568,7 @@ static void vxp_change_audio_source(vx_core_t *_chip, int src)
  * change the clock source
  * source = INTERNAL_QUARTZ or UER_SYNC
  */
-static void vxp_set_clock_source(vx_core_t *_chip, int source)
+static void vxp_set_clock_source(struct vx_core *_chip, int source)
 {
 	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
 
@@ -583,7 +583,7 @@ static void vxp_set_clock_source(vx_core_t *_chip, int source)
 /*
  * reset the board
  */
-static void vxp_reset_board(vx_core_t *_chip, int cold_reset)
+static void vxp_reset_board(struct vx_core *_chip, int cold_reset)
 {
 	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
 

commit bdbae7e62837c22c5399df0789a24e9d8a1d675f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 10:21:19 2005 +0100

    [ALSA] Remove snd_vx_delay() function
    
    Replace snd_vx_delay() with appropriate delay/sleep functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index 6f15c3d03ab5..2754d657a4d6 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -96,7 +96,7 @@ static int vx_check_magic(vx_core_t *chip)
 		c = vx_inb(chip, CDSP);
 		if (c == CDSP_MAGIC)
 			return 0;
-		snd_vx_delay(chip, 10);
+		msleep(10);
 	} while (time_after_eq(end_time, jiffies));
 	snd_printk(KERN_ERR "cannot find xilinx magic word (%x)\n", c);
 	return -EIO;
@@ -134,12 +134,12 @@ static void vxp_reset_codec(vx_core_t *_chip)
 	/* Set the reset CODEC bit to 1. */
 	vx_outb(chip, CDSP, chip->regCDSP | VXP_CDSP_CODEC_RESET_MASK);
 	vx_inb(chip, CDSP);
-	snd_vx_delay(_chip, 10);
+	msleep(10);
 	/* Set the reset CODEC bit to 0. */
 	chip->regCDSP &= ~VXP_CDSP_CODEC_RESET_MASK;
 	vx_outb(chip, CDSP, chip->regCDSP);
 	vx_inb(chip, CDSP);
-	snd_vx_delay(_chip, 1);
+	msleep(1);
 }
 
 /*
@@ -207,7 +207,7 @@ static int vxp_load_xilinx_binary(vx_core_t *_chip, const struct firmware *fw)
 	vx_outb(chip, ICR, ICR_HF0);
 
 	/* TEMPO 250ms : wait until Xilinx is downloaded */
-	snd_vx_delay(_chip, 300);
+	msleep(300);
 
 	/* test magical word */
 	if (vx_check_magic(_chip) < 0)
@@ -221,7 +221,7 @@ static int vxp_load_xilinx_binary(vx_core_t *_chip, const struct firmware *fw)
 	chip->regDIALOG |= VXP_DLG_XILINX_REPROG_MASK;
 	vx_outb(chip, DIALOG, chip->regDIALOG);
 	vx_inb(chip, DIALOG);
-	snd_vx_delay(_chip, 10);
+	msleep(10);
 	chip->regDIALOG &= ~VXP_DLG_XILINX_REPROG_MASK;
 	vx_outb(chip, DIALOG, chip->regDIALOG);
 	vx_inb(chip, DIALOG);

commit 77933d7276ee8fa0e2947641941a6f7a100a327b
Author: Jesper Juhl <juhl@dif.dk>
Date:   Wed Jul 27 11:46:09 2005 -0700

    [PATCH] clean up inline static vs static inline
    
    `gcc -W' likes to complain if the static keyword is not at the beginning of
    the declaration.  This patch fixes all remaining occurrences of "inline
    static" up with "static inline" in the entire kernel tree (140 occurrences in
    47 files).
    
    While making this change I came across a few lines with trailing whitespace
    that I also fixed up, I have also added or removed a blank line or two here
    and there, but there are no functional changes in the patch.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
index ef6734271607..6f15c3d03ab5 100644
--- a/sound/pcmcia/vx/vxp_ops.c
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -49,7 +49,7 @@ static int vxp_reg_offset[VX_REG_MAX] = {
 };
 
 
-inline static unsigned long vxp_reg_addr(vx_core_t *_chip, int reg)
+static inline unsigned long vxp_reg_addr(vx_core_t *_chip, int reg)
 {
 	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
 	return chip->port + vxp_reg_offset[reg];

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pcmcia/vx/vxp_ops.c b/sound/pcmcia/vx/vxp_ops.c
new file mode 100644
index 000000000000..ef6734271607
--- /dev/null
+++ b/sound/pcmcia/vx/vxp_ops.c
@@ -0,0 +1,614 @@
+/*
+ * Driver for Digigram VXpocket soundcards
+ *
+ * lowlevel routines for VXpocket soundcards
+ *
+ * Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <sound/core.h>
+#include <asm/io.h>
+#include "vxpocket.h"
+
+
+static int vxp_reg_offset[VX_REG_MAX] = {
+	[VX_ICR]	= 0x00,		// ICR
+	[VX_CVR]	= 0x01,		// CVR
+	[VX_ISR]	= 0x02,		// ISR
+	[VX_IVR]	= 0x03,		// IVR
+	[VX_RXH]	= 0x05,		// RXH
+	[VX_RXM]	= 0x06,		// RXM
+	[VX_RXL]	= 0x07,		// RXL
+	[VX_DMA]	= 0x04,		// DMA
+	[VX_CDSP]	= 0x08,		// CDSP
+	[VX_LOFREQ]	= 0x09,		// LFREQ
+	[VX_HIFREQ]	= 0x0a,		// HFREQ
+	[VX_DATA]	= 0x0b,		// DATA
+	[VX_MICRO]	= 0x0c,		// MICRO
+	[VX_DIALOG]	= 0x0d,		// DIALOG
+	[VX_CSUER]	= 0x0e,		// CSUER
+	[VX_RUER]	= 0x0f,		// RUER
+};
+
+
+inline static unsigned long vxp_reg_addr(vx_core_t *_chip, int reg)
+{
+	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+	return chip->port + vxp_reg_offset[reg];
+}
+
+/*
+ * snd_vx_inb - read a byte from the register
+ * @offset: register offset
+ */
+static unsigned char vxp_inb(vx_core_t *chip, int offset)
+{
+	return inb(vxp_reg_addr(chip, offset));
+}
+
+/*
+ * snd_vx_outb - write a byte on the register
+ * @offset: the register offset
+ * @val: the value to write
+ */
+static void vxp_outb(vx_core_t *chip, int offset, unsigned char val)
+{
+	outb(val, vxp_reg_addr(chip, offset));
+}
+
+/*
+ * redefine macros to call directly
+ */
+#undef vx_inb
+#define vx_inb(chip,reg)	vxp_inb((vx_core_t*)(chip), VX_##reg)
+#undef vx_outb
+#define vx_outb(chip,reg,val)	vxp_outb((vx_core_t*)(chip), VX_##reg,val)
+
+
+/*
+ * vx_check_magic - check the magic word on xilinx
+ *
+ * returns zero if a magic word is detected, or a negative error code.
+ */
+static int vx_check_magic(vx_core_t *chip)
+{
+	unsigned long end_time = jiffies + HZ / 5;
+	int c;
+	do {
+		c = vx_inb(chip, CDSP);
+		if (c == CDSP_MAGIC)
+			return 0;
+		snd_vx_delay(chip, 10);
+	} while (time_after_eq(end_time, jiffies));
+	snd_printk(KERN_ERR "cannot find xilinx magic word (%x)\n", c);
+	return -EIO;
+}
+
+
+/*
+ * vx_reset_dsp - reset the DSP
+ */
+
+#define XX_DSP_RESET_WAIT_TIME		2	/* ms */
+
+static void vxp_reset_dsp(vx_core_t *_chip)
+{
+	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+
+	/* set the reset dsp bit to 1 */
+	vx_outb(chip, CDSP, chip->regCDSP | VXP_CDSP_DSP_RESET_MASK);
+	vx_inb(chip, CDSP);
+	mdelay(XX_DSP_RESET_WAIT_TIME);
+	/* reset the bit */
+	chip->regCDSP &= ~VXP_CDSP_DSP_RESET_MASK;
+	vx_outb(chip, CDSP, chip->regCDSP);
+	vx_inb(chip, CDSP);
+	mdelay(XX_DSP_RESET_WAIT_TIME);
+}
+
+/*
+ * reset codec bit
+ */
+static void vxp_reset_codec(vx_core_t *_chip)
+{
+	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+
+	/* Set the reset CODEC bit to 1. */
+	vx_outb(chip, CDSP, chip->regCDSP | VXP_CDSP_CODEC_RESET_MASK);
+	vx_inb(chip, CDSP);
+	snd_vx_delay(_chip, 10);
+	/* Set the reset CODEC bit to 0. */
+	chip->regCDSP &= ~VXP_CDSP_CODEC_RESET_MASK;
+	vx_outb(chip, CDSP, chip->regCDSP);
+	vx_inb(chip, CDSP);
+	snd_vx_delay(_chip, 1);
+}
+
+/*
+ * vx_load_xilinx_binary - load the xilinx binary image
+ * the binary image is the binary array converted from the bitstream file.
+ */
+static int vxp_load_xilinx_binary(vx_core_t *_chip, const struct firmware *fw)
+{
+	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+	unsigned int i;
+	int c;
+	int regCSUER, regRUER;
+	unsigned char *image;
+	unsigned char data;
+
+	/* Switch to programmation mode */
+	chip->regDIALOG |= VXP_DLG_XILINX_REPROG_MASK;
+	vx_outb(chip, DIALOG, chip->regDIALOG);
+
+	/* Save register CSUER and RUER */
+	regCSUER = vx_inb(chip, CSUER);
+	regRUER = vx_inb(chip, RUER);
+
+	/* reset HF0 and HF1 */
+	vx_outb(chip, ICR, 0);
+
+	/* Wait for answer HF2 equal to 1 */
+	snd_printdd(KERN_DEBUG "check ISR_HF2\n");
+	if (vx_check_isr(_chip, ISR_HF2, ISR_HF2, 20) < 0)
+		goto _error;
+
+	/* set HF1 for loading xilinx binary */
+	vx_outb(chip, ICR, ICR_HF1);
+	image = fw->data;
+	for (i = 0; i < fw->size; i++, image++) {
+		data = *image;
+		if (vx_wait_isr_bit(_chip, ISR_TX_EMPTY) < 0)
+			goto _error;
+		vx_outb(chip, TXL, data);
+		/* wait for reading */
+		if (vx_wait_for_rx_full(_chip) < 0)
+			goto _error;
+		c = vx_inb(chip, RXL);
+		if (c != (int)data)
+			snd_printk(KERN_ERR "vxpocket: load xilinx mismatch at %d: 0x%x != 0x%x\n", i, c, (int)data);
+        }
+
+	/* reset HF1 */
+	vx_outb(chip, ICR, 0);
+
+	/* wait for HF3 */
+	if (vx_check_isr(_chip, ISR_HF3, ISR_HF3, 20) < 0)
+		goto _error;
+
+	/* read the number of bytes received */
+	if (vx_wait_for_rx_full(_chip) < 0)
+		goto _error;
+
+	c = (int)vx_inb(chip, RXH) << 16;
+	c |= (int)vx_inb(chip, RXM) << 8;
+	c |= vx_inb(chip, RXL);
+
+	snd_printdd(KERN_DEBUG "xilinx: dsp size received 0x%x, orig 0x%x\n", c, fw->size);
+
+	vx_outb(chip, ICR, ICR_HF0);
+
+	/* TEMPO 250ms : wait until Xilinx is downloaded */
+	snd_vx_delay(_chip, 300);
+
+	/* test magical word */
+	if (vx_check_magic(_chip) < 0)
+		goto _error;
+
+	/* Restore register 0x0E and 0x0F (thus replacing COR and FCSR) */
+	vx_outb(chip, CSUER, regCSUER);
+	vx_outb(chip, RUER, regRUER);
+
+	/* Reset the Xilinx's signal enabling IO access */
+	chip->regDIALOG |= VXP_DLG_XILINX_REPROG_MASK;
+	vx_outb(chip, DIALOG, chip->regDIALOG);
+	vx_inb(chip, DIALOG);
+	snd_vx_delay(_chip, 10);
+	chip->regDIALOG &= ~VXP_DLG_XILINX_REPROG_MASK;
+	vx_outb(chip, DIALOG, chip->regDIALOG);
+	vx_inb(chip, DIALOG);
+
+	/* Reset of the Codec */
+	vxp_reset_codec(_chip);
+	vx_reset_dsp(_chip);
+
+	return 0;
+
+ _error:
+	vx_outb(chip, CSUER, regCSUER);
+	vx_outb(chip, RUER, regRUER);
+	chip->regDIALOG &= ~VXP_DLG_XILINX_REPROG_MASK;
+	vx_outb(chip, DIALOG, chip->regDIALOG);
+	return -EIO;
+}
+
+
+/*
+ * vxp_load_dsp - load_dsp callback
+ */
+static int vxp_load_dsp(vx_core_t *vx, int index, const struct firmware *fw)
+{
+	int err;
+
+	switch (index) {
+	case 0:
+		/* xilinx boot */
+		if ((err = vx_check_magic(vx)) < 0)
+			return err;
+		if ((err = snd_vx_load_boot_image(vx, fw)) < 0)
+			return err;
+		return 0;
+	case 1:
+		/* xilinx image */
+		return vxp_load_xilinx_binary(vx, fw);
+	case 2:
+		/* DSP boot */
+		return snd_vx_dsp_boot(vx, fw);
+	case 3:
+		/* DSP image */
+		return snd_vx_dsp_load(vx, fw);
+	default:
+		snd_BUG();
+		return -EINVAL;
+	}
+}
+		
+
+/*
+ * vx_test_and_ack - test and acknowledge interrupt
+ *
+ * called from irq hander, too
+ *
+ * spinlock held!
+ */
+static int vxp_test_and_ack(vx_core_t *_chip)
+{
+	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+
+	/* not booted yet? */
+	if (! (_chip->chip_status & VX_STAT_XILINX_LOADED))
+		return -ENXIO;
+
+	if (! (vx_inb(chip, DIALOG) & VXP_DLG_MEMIRQ_MASK))
+		return -EIO;
+	
+	/* ok, interrupts generated, now ack it */
+	/* set ACQUIT bit up and down */
+	vx_outb(chip, DIALOG, chip->regDIALOG | VXP_DLG_ACK_MEMIRQ_MASK);
+	/* useless read just to spend some time and maintain
+	 * the ACQUIT signal up for a while ( a bus cycle )
+	 */
+	vx_inb(chip, DIALOG);
+	vx_outb(chip, DIALOG, chip->regDIALOG & ~VXP_DLG_ACK_MEMIRQ_MASK);
+
+	return 0;
+}
+
+
+/*
+ * vx_validate_irq - enable/disable IRQ
+ */
+static void vxp_validate_irq(vx_core_t *_chip, int enable)
+{
+	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+
+	/* Set the interrupt enable bit to 1 in CDSP register */
+	if (enable)
+		chip->regCDSP |= VXP_CDSP_VALID_IRQ_MASK;
+	else
+		chip->regCDSP &= ~VXP_CDSP_VALID_IRQ_MASK;
+	vx_outb(chip, CDSP, chip->regCDSP);
+}
+
+/*
+ * vx_setup_pseudo_dma - set up the pseudo dma read/write mode.
+ * @do_write: 0 = read, 1 = set up for DMA write
+ */
+static void vx_setup_pseudo_dma(vx_core_t *_chip, int do_write)
+{
+	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+
+	/* Interrupt mode and HREQ pin enabled for host transmit / receive data transfers */
+	vx_outb(chip, ICR, do_write ? ICR_TREQ : ICR_RREQ);
+	/* Reset the pseudo-dma register */
+	vx_inb(chip, ISR);
+	vx_outb(chip, ISR, 0);
+
+	/* Select DMA in read/write transfer mode and in 16-bit accesses */
+	chip->regDIALOG |= VXP_DLG_DMA16_SEL_MASK;
+	chip->regDIALOG |= do_write ? VXP_DLG_DMAWRITE_SEL_MASK : VXP_DLG_DMAREAD_SEL_MASK;
+	vx_outb(chip, DIALOG, chip->regDIALOG);
+
+}
+
+/*
+ * vx_release_pseudo_dma - disable the pseudo-DMA mode
+ */
+static void vx_release_pseudo_dma(vx_core_t *_chip)
+{
+	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+
+	/* Disable DMA and 16-bit accesses */
+	chip->regDIALOG &= ~(VXP_DLG_DMAWRITE_SEL_MASK|
+			     VXP_DLG_DMAREAD_SEL_MASK|
+			     VXP_DLG_DMA16_SEL_MASK);
+	vx_outb(chip, DIALOG, chip->regDIALOG);
+	/* HREQ pin disabled. */
+	vx_outb(chip, ICR, 0);
+}
+
+/*
+ * vx_pseudo_dma_write - write bulk data on pseudo-DMA mode
+ * @count: data length to transfer in bytes
+ *
+ * data size must be aligned to 6 bytes to ensure the 24bit alignment on DSP.
+ * NB: call with a certain lock!
+ */
+static void vxp_dma_write(vx_core_t *chip, snd_pcm_runtime_t *runtime,
+			  vx_pipe_t *pipe, int count)
+{
+	long port = vxp_reg_addr(chip, VX_DMA);
+	int offset = pipe->hw_ptr;
+	unsigned short *addr = (unsigned short *)(runtime->dma_area + offset);
+
+	vx_setup_pseudo_dma(chip, 1);
+	if (offset + count > pipe->buffer_bytes) {
+		int length = pipe->buffer_bytes - offset;
+		count -= length;
+		length >>= 1; /* in 16bit words */
+		/* Transfer using pseudo-dma. */
+		while (length-- > 0) {
+			outw(cpu_to_le16(*addr), port);
+			addr++;
+		}
+		addr = (unsigned short *)runtime->dma_area;
+		pipe->hw_ptr = 0;
+	}
+	pipe->hw_ptr += count;
+	count >>= 1; /* in 16bit words */
+	/* Transfer using pseudo-dma. */
+	while (count-- > 0) {
+		outw(cpu_to_le16(*addr), port);
+		addr++;
+	}
+	vx_release_pseudo_dma(chip);
+}
+
+
+/*
+ * vx_pseudo_dma_read - read bulk data on pseudo DMA mode
+ * @offset: buffer offset in bytes
+ * @count: data length to transfer in bytes
+ *
+ * the read length must be aligned to 6 bytes, as well as write.
+ * NB: call with a certain lock!
+ */
+static void vxp_dma_read(vx_core_t *chip, snd_pcm_runtime_t *runtime,
+			 vx_pipe_t *pipe, int count)
+{
+	struct snd_vxpocket *pchip = (struct snd_vxpocket *)chip;
+	long port = vxp_reg_addr(chip, VX_DMA);
+	int offset = pipe->hw_ptr;
+	unsigned short *addr = (unsigned short *)(runtime->dma_area + offset);
+
+	snd_assert(count % 2 == 0, return);
+	vx_setup_pseudo_dma(chip, 0);
+	if (offset + count > pipe->buffer_bytes) {
+		int length = pipe->buffer_bytes - offset;
+		count -= length;
+		length >>= 1; /* in 16bit words */
+		/* Transfer using pseudo-dma. */
+		while (length-- > 0)
+			*addr++ = le16_to_cpu(inw(port));
+		addr = (unsigned short *)runtime->dma_area;
+		pipe->hw_ptr = 0;
+	}
+	pipe->hw_ptr += count;
+	count >>= 1; /* in 16bit words */
+	/* Transfer using pseudo-dma. */
+	while (count-- > 1)
+		*addr++ = le16_to_cpu(inw(port));
+	/* Disable DMA */
+	pchip->regDIALOG &= ~VXP_DLG_DMAREAD_SEL_MASK;
+	vx_outb(chip, DIALOG, pchip->regDIALOG);
+	/* Read the last word (16 bits) */
+	*addr = le16_to_cpu(inw(port));
+	/* Disable 16-bit accesses */
+	pchip->regDIALOG &= ~VXP_DLG_DMA16_SEL_MASK;
+	vx_outb(chip, DIALOG, pchip->regDIALOG);
+	/* HREQ pin disabled. */
+	vx_outb(chip, ICR, 0);
+}
+
+
+/*
+ * write a codec data (24bit)
+ */
+static void vxp_write_codec_reg(vx_core_t *chip, int codec, unsigned int data)
+{
+	int i;
+
+	/* Activate access to the corresponding codec register */
+	if (! codec)
+		vx_inb(chip, LOFREQ);
+	else
+		vx_inb(chip, CODEC2);
+		
+	/* We have to send 24 bits (3 x 8 bits). Start with most signif. Bit */
+	for (i = 0; i < 24; i++, data <<= 1)
+		vx_outb(chip, DATA, ((data & 0x800000) ? VX_DATA_CODEC_MASK : 0));
+	
+	/* Terminate access to codec registers */
+	vx_inb(chip, HIFREQ);
+}
+
+
+/*
+ * vx_set_mic_boost - set mic boost level (on vxp440 only)
+ * @boost: 0 = 20dB, 1 = +38dB
+ */
+void vx_set_mic_boost(vx_core_t *chip, int boost)
+{
+	struct snd_vxpocket *pchip = (struct snd_vxpocket *)chip;
+	unsigned long flags;
+
+	if (chip->chip_status & VX_STAT_IS_STALE)
+		return;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	if (pchip->regCDSP & P24_CDSP_MICS_SEL_MASK) {
+		if (boost) {
+			/* boost: 38 dB */
+			pchip->regCDSP &= ~P24_CDSP_MIC20_SEL_MASK;
+			pchip->regCDSP |=  P24_CDSP_MIC38_SEL_MASK;
+		} else {
+			/* minimum value: 20 dB */
+			pchip->regCDSP |=  P24_CDSP_MIC20_SEL_MASK;
+			pchip->regCDSP &= ~P24_CDSP_MIC38_SEL_MASK;
+                }
+		vx_outb(chip, CDSP, pchip->regCDSP);
+	}
+	spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+/*
+ * remap the linear value (0-8) to the actual value (0-15)
+ */
+static int vx_compute_mic_level(int level)
+{
+	switch (level) {
+	case 5: level = 6 ; break;
+	case 6: level = 8 ; break;
+	case 7: level = 11; break;
+	case 8: level = 15; break;
+	default: break ;
+	}
+	return level;
+}
+
+/*
+ * vx_set_mic_level - set mic level (on vxpocket only)
+ * @level: the mic level = 0 - 8 (max)
+ */
+void vx_set_mic_level(vx_core_t *chip, int level)
+{
+	struct snd_vxpocket *pchip = (struct snd_vxpocket *)chip;
+	unsigned long flags;
+
+	if (chip->chip_status & VX_STAT_IS_STALE)
+		return;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	if (pchip->regCDSP & VXP_CDSP_MIC_SEL_MASK) {
+		level = vx_compute_mic_level(level);
+		vx_outb(chip, MICRO, level);
+	}
+	spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+
+/*
+ * change the input audio source
+ */
+static void vxp_change_audio_source(vx_core_t *_chip, int src)
+{
+	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+
+	switch (src) {
+	case VX_AUDIO_SRC_DIGITAL:
+		chip->regCDSP |= VXP_CDSP_DATAIN_SEL_MASK;
+		vx_outb(chip, CDSP, chip->regCDSP);
+		break;
+	case VX_AUDIO_SRC_LINE:
+		chip->regCDSP &= ~VXP_CDSP_DATAIN_SEL_MASK;
+		if (_chip->type == VX_TYPE_VXP440)
+			chip->regCDSP &= ~P24_CDSP_MICS_SEL_MASK;
+		else
+			chip->regCDSP &= ~VXP_CDSP_MIC_SEL_MASK;
+		vx_outb(chip, CDSP, chip->regCDSP);
+		break;
+	case VX_AUDIO_SRC_MIC:
+		chip->regCDSP &= ~VXP_CDSP_DATAIN_SEL_MASK;
+		/* reset mic levels */
+		if (_chip->type == VX_TYPE_VXP440) {
+			chip->regCDSP &= ~P24_CDSP_MICS_SEL_MASK;
+			if (chip->mic_level)
+				chip->regCDSP |=  P24_CDSP_MIC38_SEL_MASK;
+			else
+				chip->regCDSP |= P24_CDSP_MIC20_SEL_MASK;
+			vx_outb(chip, CDSP, chip->regCDSP);
+		} else {
+			chip->regCDSP |= VXP_CDSP_MIC_SEL_MASK;
+			vx_outb(chip, CDSP, chip->regCDSP);
+			vx_outb(chip, MICRO, vx_compute_mic_level(chip->mic_level));
+		}
+		break;
+	}
+}
+
+/*
+ * change the clock source
+ * source = INTERNAL_QUARTZ or UER_SYNC
+ */
+static void vxp_set_clock_source(vx_core_t *_chip, int source)
+{
+	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+
+	if (source == INTERNAL_QUARTZ)
+		chip->regCDSP &= ~VXP_CDSP_CLOCKIN_SEL_MASK;
+	else
+		chip->regCDSP |= VXP_CDSP_CLOCKIN_SEL_MASK;
+	vx_outb(chip, CDSP, chip->regCDSP);
+}
+
+
+/*
+ * reset the board
+ */
+static void vxp_reset_board(vx_core_t *_chip, int cold_reset)
+{
+	struct snd_vxpocket *chip = (struct snd_vxpocket *)_chip;
+
+	chip->regCDSP = 0;
+	chip->regDIALOG = 0;
+}
+
+
+/*
+ * callbacks
+ */
+/* exported */
+struct snd_vx_ops snd_vxpocket_ops = {
+	.in8 = vxp_inb,
+	.out8 = vxp_outb,
+	.test_and_ack = vxp_test_and_ack,
+	.validate_irq = vxp_validate_irq,
+	.write_codec = vxp_write_codec_reg,
+	.reset_codec = vxp_reset_codec,
+	.change_audio_source = vxp_change_audio_source,
+	.set_clock_source = vxp_set_clock_source,
+	.load_dsp = vxp_load_dsp,
+	.add_controls = vxp_add_mic_controls,
+	.reset_dsp = vxp_reset_dsp,
+	.reset_board = vxp_reset_board,
+	.dma_write = vxp_dma_write,
+	.dma_read = vxp_dma_read,
+};
