commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/mixart/mixart_core.h b/sound/pci/mixart/mixart_core.h
index d1722e575409..fbf4731a276d 100644
--- a/sound/pci/mixart/mixart_core.h
+++ b/sound/pci/mixart/mixart_core.h
@@ -1,23 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Driver for Digigram miXart soundcards
  *
  * low level interface with interrupt handling and mail box implementation
  *
  * Copyright (c) 2003 by Digigram <alsa@digigram.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #ifndef __SOUND_MIXART_CORE_H

commit 8d3a8b5cb57da4e327bdaf7c81a90d4105b73205
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 10 11:48:07 2014 +0200

    ALSA: mixart: Use nonatomic PCM ops
    
    Like the previous patch for VX boards, miXart device driver can be
    also rewritten to use nonatomic PCM ops.  Simply spinlocks are
    replaced with mutex, the tasklet code is merged into the threaded irq
    handler.  Also, now mgr->msg_mutex is superfluous, so merged to
    msg_lock.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/mixart/mixart_core.h b/sound/pci/mixart/mixart_core.h
index c919b734756f..d1722e575409 100644
--- a/sound/pci/mixart/mixart_core.h
+++ b/sound/pci/mixart/mixart_core.h
@@ -564,7 +564,7 @@ int  snd_mixart_send_msg_wait_notif(struct mixart_mgr *mgr, struct mixart_msg *r
 int  snd_mixart_send_msg_nonblock(struct mixart_mgr *mgr, struct mixart_msg *request);
 
 irqreturn_t snd_mixart_interrupt(int irq, void *dev_id);
-void snd_mixart_msg_tasklet(unsigned long arg);
+irqreturn_t snd_mixart_threaded_irq(int irq, void *dev_id);
 
 void snd_mixart_reset_board(struct mixart_mgr *mgr);
 

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/mixart/mixart_core.h b/sound/pci/mixart/mixart_core.h
index 1fe2bcfcc57c..c919b734756f 100644
--- a/sound/pci/mixart/mixart_core.h
+++ b/sound/pci/mixart/mixart_core.h
@@ -563,7 +563,7 @@ int  snd_mixart_send_msg(struct mixart_mgr *mgr, struct mixart_msg *request, int
 int  snd_mixart_send_msg_wait_notif(struct mixart_mgr *mgr, struct mixart_msg *request, u32 notif_event);
 int  snd_mixart_send_msg_nonblock(struct mixart_mgr *mgr, struct mixart_msg *request);
 
-irqreturn_t snd_mixart_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+irqreturn_t snd_mixart_interrupt(int irq, void *dev_id);
 void snd_mixart_msg_tasklet(unsigned long arg);
 
 void snd_mixart_reset_board(struct mixart_mgr *mgr);

commit 67b48b880062ba1775f424c2dd2c68bc30ec180f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:01:08 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI miXart
    
    Modules: MIXART driver
    
    Remove xxx_t typedefs from the PCI miXart driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/mixart/mixart_core.h b/sound/pci/mixart/mixart_core.h
index 99450eba15c0..1fe2bcfcc57c 100644
--- a/sound/pci/mixart/mixart_core.h
+++ b/sound/pci/mixart/mixart_core.h
@@ -63,25 +63,23 @@ enum mixart_message_id {
 };
 
 
-typedef struct mixart_msg mixart_msg_t;
 struct mixart_msg
 {
 	u32          message_id;
-	mixart_uid_t uid;
+	struct mixart_uid uid;
 	void*        data;
 	size_t       size;
 };
 
 /* structs used to communicate with miXart */
 
-typedef struct mixart_enum_connector_resp mixart_enum_connector_resp_t;
 struct mixart_enum_connector_resp
 {
 	u32  error_code;
 	u32  first_uid_offset;
 	u32  uid_count;
 	u32  current_uid_index;
-	mixart_uid_t uid[MIXART_MAX_PHYS_CONNECTORS];
+	struct mixart_uid uid[MIXART_MAX_PHYS_CONNECTORS];
 } __attribute__((packed));
 
 
@@ -90,7 +88,6 @@ struct mixart_enum_connector_resp
 #define MIXART_FLOAT_M_20_0_TO_HEX      0xc1a00000  /* -20.0f */
 #define MIXART_FLOAT____0_0_TO_HEX      0x00000000  /* 0.0f */
 
-typedef struct mixart_audio_info_req mixart_audio_info_req_t;
 struct mixart_audio_info_req
 {
 	u32 line_max_level;    /* float */
@@ -98,7 +95,6 @@ struct mixart_audio_info_req
 	u32 cd_max_level;      /* float */
 } __attribute__((packed));
 
-typedef struct mixart_analog_hw_info mixart_analog_hw_info_t;
 struct mixart_analog_hw_info
 {
 	u32 is_present;
@@ -111,7 +107,6 @@ struct mixart_analog_hw_info
 	u32 zero_var;          /* float */
 } __attribute__((packed));
 
-typedef struct mixart_digital_hw_info mixart_digital_hw_info_t;
 struct mixart_digital_hw_info
 {
 	u32   hw_connection_type;
@@ -120,37 +115,33 @@ struct mixart_digital_hw_info
 	u32   reserved;
 } __attribute__((packed));
 
-typedef struct mixart_analog_info mixart_analog_info_t;
 struct mixart_analog_info
 {
 	u32                     type_mask;
-	mixart_analog_hw_info_t micro_info;
-	mixart_analog_hw_info_t line_info;
-	mixart_analog_hw_info_t cd_info;
+	struct mixart_analog_hw_info micro_info;
+	struct mixart_analog_hw_info line_info;
+	struct mixart_analog_hw_info cd_info;
 	u32                     analog_level_present;
 } __attribute__((packed));
 
-typedef struct mixart_digital_info mixart_digital_info_t;
 struct mixart_digital_info
 {
 	u32 type_mask;
-	mixart_digital_hw_info_t aes_info;
-	mixart_digital_hw_info_t adat_info;
+	struct mixart_digital_hw_info aes_info;
+	struct mixart_digital_hw_info adat_info;
 } __attribute__((packed));
 
-typedef struct mixart_audio_info mixart_audio_info_t;
 struct mixart_audio_info
 {
 	u32                   clock_type_mask;
-	mixart_analog_info_t  analog_info;
-	mixart_digital_info_t digital_info;
+	struct mixart_analog_info  analog_info;
+	struct mixart_digital_info digital_info;
 } __attribute__((packed));
 
-typedef struct mixart_audio_info_resp mixart_audio_info_resp_t;
 struct mixart_audio_info_resp
 {
 	u32                 txx_status;
-	mixart_audio_info_t info;
+	struct mixart_audio_info info;
 } __attribute__((packed));
 
 
@@ -158,7 +149,6 @@ struct mixart_audio_info_resp
 #define MIXART_FLOAT_P__4_0_TO_HEX      0x40800000  /* +4.0f */
 #define MIXART_FLOAT_P__8_0_TO_HEX      0x41000000  /* +8.0f */
 
-typedef struct mixart_stream_info mixart_stream_info_t;
 struct mixart_stream_info
 {
 	u32 size_max_byte_frame;
@@ -169,7 +159,6 @@ struct mixart_stream_info
 /*  MSG_STREAM_ADD_INPUT_GROUP */
 /*  MSG_STREAM_ADD_OUTPUT_GROUP */
 
-typedef struct mixart_streaming_group_req mixart_streaming_group_req_t;
 struct mixart_streaming_group_req
 {
 	u32 stream_count;
@@ -177,33 +166,30 @@ struct mixart_streaming_group_req
 	u32 user_grp_number;
 	u32 first_phys_audio;
 	u32 latency;
-	mixart_stream_info_t stream_info[32];
-	mixart_uid_t connector;
+	struct mixart_stream_info stream_info[32];
+	struct mixart_uid connector;
 	u32 flow_entry[32];
 } __attribute__((packed));
 
-typedef struct mixart_stream_desc mixart_stream_desc_t;
 struct mixart_stream_desc
 {
-	mixart_uid_t stream_uid;
+	struct mixart_uid stream_uid;
 	u32          stream_desc;
 } __attribute__((packed));
 
-typedef struct mixart_streaming_group mixart_streaming_group_t;
 struct mixart_streaming_group
 {
 	u32                  status;
-	mixart_uid_t         group;
+	struct mixart_uid    group;
 	u32                  pipe_desc;
 	u32                  stream_count;
-	mixart_stream_desc_t stream[32];
+	struct mixart_stream_desc stream[32];
 } __attribute__((packed));
 
 /* MSG_STREAM_DELETE_GROUP */
 
 /* request : mixart_uid_t group */
 
-typedef struct mixart_delete_group_resp mixart_delete_group_resp_t;
 struct mixart_delete_group_resp
 {
 	u32  status;
@@ -217,55 +203,49 @@ struct mixart_delete_group_resp
 	MSG_STREAM_STOP_OUTPUT_STAGE_PACKET  = 0x130000 + 11,
  */
 
-typedef struct mixart_fx_couple_uid mixart_fx_couple_uid_t;
 struct mixart_fx_couple_uid
 {
-	mixart_uid_t uid_fx_code;
-	mixart_uid_t uid_fx_data;
+	struct mixart_uid uid_fx_code;
+	struct mixart_uid uid_fx_data;
 } __attribute__((packed));
 
-typedef struct mixart_txx_stream_desc mixart_txx_stream_desc_t;
 struct mixart_txx_stream_desc
 {
-	mixart_uid_t            uid_pipe;
+	struct mixart_uid       uid_pipe;
 	u32                     stream_idx;
 	u32                     fx_number;
-	mixart_fx_couple_uid_t  uid_fx[4];
+	struct mixart_fx_couple_uid  uid_fx[4];
 } __attribute__((packed));
 
-typedef struct mixart_flow_info mixart_flow_info_t;
 struct mixart_flow_info
 {
-	mixart_txx_stream_desc_t  stream_desc;
+	struct mixart_txx_stream_desc  stream_desc;
 	u32                       flow_entry;
 	u32                       flow_phy_addr;
 } __attribute__((packed));
 
-typedef struct mixart_stream_state_req mixart_stream_state_req_t;
 struct mixart_stream_state_req
 {
 	u32                 delayed;
 	u64                 scheduler;
 	u32                 reserved4np[3];
 	u32                 stream_count;  /* set to 1 for instance */
-	mixart_flow_info_t  stream_info;   /* could be an array[stream_count] */
+	struct mixart_flow_info  stream_info;   /* could be an array[stream_count] */
 } __attribute__((packed));
 
 /* 	MSG_STREAM_START_STREAM_GRP_PACKET   = 0x130000 + 6
 	MSG_STREAM_STOP_STREAM_GRP_PACKET    = 0x130000 + 9
  */
 
-typedef struct mixart_group_state_req mixart_group_state_req_t;
 struct mixart_group_state_req
 {
 	u32           delayed;
 	u64           scheduler;
 	u32           reserved4np[2];
 	u32           pipe_count;    /* set to 1 for instance */
-	mixart_uid_t  pipe_uid[1];   /* could be an array[pipe_count] */
+	struct mixart_uid  pipe_uid[1];   /* could be an array[pipe_count] */
 } __attribute__((packed));
 
-typedef struct mixart_group_state_resp mixart_group_state_resp_t;
 struct mixart_group_state_resp
 {
 	u32           txx_status;
@@ -276,7 +256,6 @@ struct mixart_group_state_resp
 
 /* Structures used by the MSG_SERVICES_TIMER_NOTIFY command */
 
-typedef struct mixart_sample_pos mixart_sample_pos_t;
 struct mixart_sample_pos
 {
 	u32   buffer_id;
@@ -285,11 +264,10 @@ struct mixart_sample_pos
 	u32   sample_pos_low_part;
 } __attribute__((packed));
 
-typedef struct mixart_timer_notify mixart_timer_notify_t;
 struct mixart_timer_notify
 {
 	u32                  stream_count;
-	mixart_sample_pos_t  streams[MIXART_MAX_STREAM_PER_CARD * MIXART_MAX_CARDS];
+	struct mixart_sample_pos  streams[MIXART_MAX_STREAM_PER_CARD * MIXART_MAX_CARDS];
 } __attribute__((packed));
 
 
@@ -298,11 +276,10 @@ struct mixart_timer_notify
 
 /* request is a uid with desc = MSG_CONSOLE_MANAGER | cardindex */
 
-typedef struct mixart_return_uid mixart_return_uid_t;
 struct mixart_return_uid
 {
 	u32 error_code;
-	mixart_uid_t uid;
+	struct mixart_uid uid;
 } __attribute__((packed));
 
 /*	MSG_CLOCK_CHECK_PROPERTIES           = 0x200001,
@@ -327,7 +304,6 @@ enum mixart_clock_mode {
 };
 
 
-typedef struct mixart_clock_properties mixart_clock_properties_t;
 struct mixart_clock_properties
 {
 	u32 error_code;
@@ -336,17 +312,16 @@ struct mixart_clock_properties
 	u32 reference_frequency;
 	u32 clock_generic_type;
 	u32 clock_mode;
-	mixart_uid_t uid_clock_source;
-	mixart_uid_t uid_event_source;
+	struct mixart_uid uid_clock_source;
+	struct mixart_uid uid_event_source;
 	u32 event_mode;
 	u32 synchro_signal_presence;
 	u32 format;
 	u32 board_mask;
 	u32 nb_callers; /* set to 1 (see below) */
-	mixart_uid_t uid_caller[1];
+	struct mixart_uid uid_caller[1];
 } __attribute__((packed));
 
-typedef struct mixart_clock_properties_resp mixart_clock_properties_resp_t;
 struct mixart_clock_properties_resp
 {
 	u32 status;
@@ -388,7 +363,6 @@ enum mixart_sample_type {
 	ST_INTEGER_32LE
 };
 
-typedef struct mixart_stream_param_desc mixart_stream_param_desc_t;
 struct mixart_stream_param_desc
 {
 	u32 coding_type;  /* use enum mixart_coding_type */
@@ -432,7 +406,7 @@ struct mixart_stream_param_desc
 	u32 reserved4np[3];
 	u32 pipe_count;                           /* set to 1 (array size !) */
 	u32 stream_count;                         /* set to 1 (array size !) */
-	mixart_txx_stream_desc_t stream_desc[1];  /* only one stream per command, but this could be an array */
+	struct mixart_txx_stream_desc stream_desc[1];  /* only one stream per command, but this could be an array */
 
 } __attribute__((packed));
 
@@ -441,7 +415,6 @@ struct mixart_stream_param_desc
  */
 
 
-typedef struct mixart_get_out_audio_level mixart_get_out_audio_level_t;
 struct mixart_get_out_audio_level
 {
 	u32 txx_status;
@@ -465,7 +438,6 @@ struct mixart_get_out_audio_level
 #define MIXART_AUDIO_LEVEL_MUTE_M1_MASK	0x10
 #define MIXART_AUDIO_LEVEL_MUTE_M2_MASK	0x20
 
-typedef struct mixart_set_out_audio_level mixart_set_out_audio_level_t;
 struct mixart_set_out_audio_level
 {
 	u32 delayed;
@@ -487,14 +459,13 @@ struct mixart_set_out_audio_level
 
 #define MIXART_MAX_PHYS_IO  (MIXART_MAX_CARDS * 2 * 2) /* 4 * (analog+digital) * (playback+capture) */
 
-typedef struct mixart_uid_enumeration mixart_uid_enumeration_t;
 struct mixart_uid_enumeration
 {
 	u32 error_code;
 	u32 first_uid_offset;
 	u32 nb_uid;
 	u32 current_uid_index;
-	mixart_uid_t uid[MIXART_MAX_PHYS_IO];
+	struct mixart_uid uid[MIXART_MAX_PHYS_IO];
 } __attribute__((packed));
 
 
@@ -502,42 +473,38 @@ struct mixart_uid_enumeration
 	MSG_PHYSICALIO_GET_LEVEL             = 0x0F000C,
 */
 
-typedef struct mixart_io_channel_level mixart_io_channel_level_t;
 struct mixart_io_channel_level
 {
 	u32 analog_level;   /* float */
 	u32 unused[2];
 } __attribute__((packed));
 
-typedef struct mixart_io_level mixart_io_level_t;
 struct mixart_io_level
 {
 	s32 channel; /* 0=left, 1=right, -1=both, -2=both same */
-	mixart_io_channel_level_t level[2];
+	struct mixart_io_channel_level level[2];
 } __attribute__((packed));
 
 
 /*	MSG_STREAM_SET_IN_AUDIO_LEVEL        = 0x130015,
  */
 
-typedef struct mixart_in_audio_level_info mixart_in_audio_level_info_t;
 struct mixart_in_audio_level_info
 {
-	mixart_uid_t connector;
+	struct mixart_uid connector;
 	u32 valid_mask1;
 	u32 valid_mask2;
 	u32 digital_level;
 	u32 analog_level;
 } __attribute__((packed));
 
-typedef struct mixart_set_in_audio_level_req mixart_set_in_audio_level_req_t;
 struct mixart_set_in_audio_level_req
 {
 	u32 delayed;
 	u64 scheduler;
 	u32 audio_count;  /* set to <= 2 */
 	u32 reserved4np;
-	mixart_in_audio_level_info_t level[2];
+	struct mixart_in_audio_level_info level[2];
 } __attribute__((packed));
 
 /* response is a 32 bit status */
@@ -556,7 +523,6 @@ struct mixart_set_in_audio_level_req
 #define MIXART_OUT_STREAM_SET_LEVEL_MUTE_1		0x40
 #define MIXART_OUT_STREAM_SET_LEVEL_MUTE_2		0x80
 
-typedef struct mixart_out_stream_level_info mixart_out_stream_level_info_t;
 struct mixart_out_stream_level_info
 {
 	u32 valid_mask1;
@@ -571,37 +537,35 @@ struct mixart_out_stream_level_info
 	u32 mute2;
 } __attribute__((packed));
 
-typedef struct mixart_set_out_stream_level mixart_set_out_stream_level_t;
 struct mixart_set_out_stream_level
 {
-	mixart_txx_stream_desc_t desc;
-	mixart_out_stream_level_info_t out_level;
+	struct mixart_txx_stream_desc desc;
+	struct mixart_out_stream_level_info out_level;
 } __attribute__((packed));
 
-typedef struct mixart_set_out_stream_level_req mixart_set_out_stream_level_req_t;
 struct mixart_set_out_stream_level_req
 {
 	u32 delayed;
 	u64 scheduler;
 	u32 reserved4np[2];
 	u32 nb_of_stream;  /* set to 1 */
-	mixart_set_out_stream_level_t stream_level; /* could be an array */
+	struct mixart_set_out_stream_level stream_level; /* could be an array */
 } __attribute__((packed));
 
 /* response to this request is a u32 status value */
 
 
 /* exported */
-void snd_mixart_init_mailbox(mixart_mgr_t *mgr);
-void snd_mixart_exit_mailbox(mixart_mgr_t *mgr);
+void snd_mixart_init_mailbox(struct mixart_mgr *mgr);
+void snd_mixart_exit_mailbox(struct mixart_mgr *mgr);
 
-int  snd_mixart_send_msg(mixart_mgr_t *mgr, mixart_msg_t *request, int max_resp_size, void *resp_data);
-int  snd_mixart_send_msg_wait_notif(mixart_mgr_t *mgr, mixart_msg_t *request, u32 notif_event);
-int  snd_mixart_send_msg_nonblock(mixart_mgr_t *mgr, mixart_msg_t *request);
+int  snd_mixart_send_msg(struct mixart_mgr *mgr, struct mixart_msg *request, int max_resp_size, void *resp_data);
+int  snd_mixart_send_msg_wait_notif(struct mixart_mgr *mgr, struct mixart_msg *request, u32 notif_event);
+int  snd_mixart_send_msg_nonblock(struct mixart_mgr *mgr, struct mixart_msg *request);
 
 irqreturn_t snd_mixart_interrupt(int irq, void *dev_id, struct pt_regs *regs);
-void snd_mixart_msg_tasklet( unsigned long arg);
+void snd_mixart_msg_tasklet(unsigned long arg);
 
-void snd_mixart_reset_board(mixart_mgr_t *mgr);
+void snd_mixart_reset_board(struct mixart_mgr *mgr);
 
 #endif /* __SOUND_MIXART_CORE_H */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/mixart/mixart_core.h b/sound/pci/mixart/mixart_core.h
new file mode 100644
index 000000000000..99450eba15c0
--- /dev/null
+++ b/sound/pci/mixart/mixart_core.h
@@ -0,0 +1,607 @@
+/*
+ * Driver for Digigram miXart soundcards
+ *
+ * low level interface with interrupt handling and mail box implementation
+ *
+ * Copyright (c) 2003 by Digigram <alsa@digigram.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef __SOUND_MIXART_CORE_H
+#define __SOUND_MIXART_CORE_H
+
+
+enum mixart_message_id {
+	MSG_CONNECTOR_GET_AUDIO_INFO         = 0x050008,
+	MSG_CONNECTOR_GET_OUT_AUDIO_LEVEL    = 0x050009,
+	MSG_CONNECTOR_SET_OUT_AUDIO_LEVEL    = 0x05000A,
+
+	MSG_CONSOLE_MANAGER                  = 0x070000,
+	MSG_CONSOLE_GET_CLOCK_UID            = 0x070003,
+
+	MSG_PHYSICALIO_SET_LEVEL             = 0x0F0008,
+
+	MSG_STREAM_ADD_INPUT_GROUP           = 0x130000,
+	MSG_STREAM_ADD_OUTPUT_GROUP          = 0x130001,
+	MSG_STREAM_DELETE_GROUP              = 0x130004,
+	MSG_STREAM_START_STREAM_GRP_PACKET   = 0x130006,
+	MSG_STREAM_START_INPUT_STAGE_PACKET  = 0x130007,
+	MSG_STREAM_START_OUTPUT_STAGE_PACKET = 0x130008,
+	MSG_STREAM_STOP_STREAM_GRP_PACKET    = 0x130009,
+	MSG_STREAM_STOP_INPUT_STAGE_PACKET   = 0x13000A,
+	MSG_STREAM_STOP_OUTPUT_STAGE_PACKET  = 0x13000B,
+	MSG_STREAM_SET_INPUT_STAGE_PARAM     = 0x13000F,
+	MSG_STREAM_SET_OUTPUT_STAGE_PARAM    = 0x130010,
+	MSG_STREAM_SET_IN_AUDIO_LEVEL        = 0x130015,
+	MSG_STREAM_SET_OUT_STREAM_LEVEL      = 0x130017,
+
+	MSG_SYSTEM_FIRST_ID                  = 0x160000,
+	MSG_SYSTEM_ENUM_PHYSICAL_IO          = 0x16000E,
+	MSG_SYSTEM_ENUM_PLAY_CONNECTOR       = 0x160017,
+	MSG_SYSTEM_ENUM_RECORD_CONNECTOR     = 0x160018,
+	MSG_SYSTEM_WAIT_SYNCHRO_CMD          = 0x16002C,
+	MSG_SYSTEM_SEND_SYNCHRO_CMD          = 0x16002D,
+
+	MSG_SERVICES_TIMER_NOTIFY            = 0x1D0404,
+	MSG_SERVICES_REPORT_TRACES           = 0x1D0700,
+
+	MSG_CLOCK_CHECK_PROPERTIES           = 0x200001,
+	MSG_CLOCK_SET_PROPERTIES             = 0x200002,
+};
+
+
+typedef struct mixart_msg mixart_msg_t;
+struct mixart_msg
+{
+	u32          message_id;
+	mixart_uid_t uid;
+	void*        data;
+	size_t       size;
+};
+
+/* structs used to communicate with miXart */
+
+typedef struct mixart_enum_connector_resp mixart_enum_connector_resp_t;
+struct mixart_enum_connector_resp
+{
+	u32  error_code;
+	u32  first_uid_offset;
+	u32  uid_count;
+	u32  current_uid_index;
+	mixart_uid_t uid[MIXART_MAX_PHYS_CONNECTORS];
+} __attribute__((packed));
+
+
+/* used for following struct */
+#define MIXART_FLOAT_P_22_0_TO_HEX      0x41b00000  /* 22.0f */
+#define MIXART_FLOAT_M_20_0_TO_HEX      0xc1a00000  /* -20.0f */
+#define MIXART_FLOAT____0_0_TO_HEX      0x00000000  /* 0.0f */
+
+typedef struct mixart_audio_info_req mixart_audio_info_req_t;
+struct mixart_audio_info_req
+{
+	u32 line_max_level;    /* float */
+	u32 micro_max_level;   /* float */
+	u32 cd_max_level;      /* float */
+} __attribute__((packed));
+
+typedef struct mixart_analog_hw_info mixart_analog_hw_info_t;
+struct mixart_analog_hw_info
+{
+	u32 is_present;
+	u32 hw_connection_type;
+	u32 max_level;         /* float */
+	u32 min_var_level;     /* float */
+	u32 max_var_level;     /* float */
+	u32 step_var_level;    /* float */
+	u32 fix_gain;          /* float */
+	u32 zero_var;          /* float */
+} __attribute__((packed));
+
+typedef struct mixart_digital_hw_info mixart_digital_hw_info_t;
+struct mixart_digital_hw_info
+{
+	u32   hw_connection_type;
+	u32   presence;
+	u32   clock;
+	u32   reserved;
+} __attribute__((packed));
+
+typedef struct mixart_analog_info mixart_analog_info_t;
+struct mixart_analog_info
+{
+	u32                     type_mask;
+	mixart_analog_hw_info_t micro_info;
+	mixart_analog_hw_info_t line_info;
+	mixart_analog_hw_info_t cd_info;
+	u32                     analog_level_present;
+} __attribute__((packed));
+
+typedef struct mixart_digital_info mixart_digital_info_t;
+struct mixart_digital_info
+{
+	u32 type_mask;
+	mixart_digital_hw_info_t aes_info;
+	mixart_digital_hw_info_t adat_info;
+} __attribute__((packed));
+
+typedef struct mixart_audio_info mixart_audio_info_t;
+struct mixart_audio_info
+{
+	u32                   clock_type_mask;
+	mixart_analog_info_t  analog_info;
+	mixart_digital_info_t digital_info;
+} __attribute__((packed));
+
+typedef struct mixart_audio_info_resp mixart_audio_info_resp_t;
+struct mixart_audio_info_resp
+{
+	u32                 txx_status;
+	mixart_audio_info_t info;
+} __attribute__((packed));
+
+
+/* used for nb_bytes_max_per_sample */
+#define MIXART_FLOAT_P__4_0_TO_HEX      0x40800000  /* +4.0f */
+#define MIXART_FLOAT_P__8_0_TO_HEX      0x41000000  /* +8.0f */
+
+typedef struct mixart_stream_info mixart_stream_info_t;
+struct mixart_stream_info
+{
+	u32 size_max_byte_frame;
+	u32 size_max_sample_frame;
+	u32 nb_bytes_max_per_sample;  /* float */
+} __attribute__((packed));
+
+/*  MSG_STREAM_ADD_INPUT_GROUP */
+/*  MSG_STREAM_ADD_OUTPUT_GROUP */
+
+typedef struct mixart_streaming_group_req mixart_streaming_group_req_t;
+struct mixart_streaming_group_req
+{
+	u32 stream_count;
+	u32 channel_count;
+	u32 user_grp_number;
+	u32 first_phys_audio;
+	u32 latency;
+	mixart_stream_info_t stream_info[32];
+	mixart_uid_t connector;
+	u32 flow_entry[32];
+} __attribute__((packed));
+
+typedef struct mixart_stream_desc mixart_stream_desc_t;
+struct mixart_stream_desc
+{
+	mixart_uid_t stream_uid;
+	u32          stream_desc;
+} __attribute__((packed));
+
+typedef struct mixart_streaming_group mixart_streaming_group_t;
+struct mixart_streaming_group
+{
+	u32                  status;
+	mixart_uid_t         group;
+	u32                  pipe_desc;
+	u32                  stream_count;
+	mixart_stream_desc_t stream[32];
+} __attribute__((packed));
+
+/* MSG_STREAM_DELETE_GROUP */
+
+/* request : mixart_uid_t group */
+
+typedef struct mixart_delete_group_resp mixart_delete_group_resp_t;
+struct mixart_delete_group_resp
+{
+	u32  status;
+	u32  unused[2];
+} __attribute__((packed));
+
+
+/* 	MSG_STREAM_START_INPUT_STAGE_PACKET  = 0x130000 + 7,
+	MSG_STREAM_START_OUTPUT_STAGE_PACKET = 0x130000 + 8,
+	MSG_STREAM_STOP_INPUT_STAGE_PACKET   = 0x130000 + 10,
+	MSG_STREAM_STOP_OUTPUT_STAGE_PACKET  = 0x130000 + 11,
+ */
+
+typedef struct mixart_fx_couple_uid mixart_fx_couple_uid_t;
+struct mixart_fx_couple_uid
+{
+	mixart_uid_t uid_fx_code;
+	mixart_uid_t uid_fx_data;
+} __attribute__((packed));
+
+typedef struct mixart_txx_stream_desc mixart_txx_stream_desc_t;
+struct mixart_txx_stream_desc
+{
+	mixart_uid_t            uid_pipe;
+	u32                     stream_idx;
+	u32                     fx_number;
+	mixart_fx_couple_uid_t  uid_fx[4];
+} __attribute__((packed));
+
+typedef struct mixart_flow_info mixart_flow_info_t;
+struct mixart_flow_info
+{
+	mixart_txx_stream_desc_t  stream_desc;
+	u32                       flow_entry;
+	u32                       flow_phy_addr;
+} __attribute__((packed));
+
+typedef struct mixart_stream_state_req mixart_stream_state_req_t;
+struct mixart_stream_state_req
+{
+	u32                 delayed;
+	u64                 scheduler;
+	u32                 reserved4np[3];
+	u32                 stream_count;  /* set to 1 for instance */
+	mixart_flow_info_t  stream_info;   /* could be an array[stream_count] */
+} __attribute__((packed));
+
+/* 	MSG_STREAM_START_STREAM_GRP_PACKET   = 0x130000 + 6
+	MSG_STREAM_STOP_STREAM_GRP_PACKET    = 0x130000 + 9
+ */
+
+typedef struct mixart_group_state_req mixart_group_state_req_t;
+struct mixart_group_state_req
+{
+	u32           delayed;
+	u64           scheduler;
+	u32           reserved4np[2];
+	u32           pipe_count;    /* set to 1 for instance */
+	mixart_uid_t  pipe_uid[1];   /* could be an array[pipe_count] */
+} __attribute__((packed));
+
+typedef struct mixart_group_state_resp mixart_group_state_resp_t;
+struct mixart_group_state_resp
+{
+	u32           txx_status;
+	u64           scheduler;
+} __attribute__((packed));
+
+
+
+/* Structures used by the MSG_SERVICES_TIMER_NOTIFY command */
+
+typedef struct mixart_sample_pos mixart_sample_pos_t;
+struct mixart_sample_pos
+{
+	u32   buffer_id;
+	u32   validity;
+	u32   sample_pos_high_part;
+	u32   sample_pos_low_part;
+} __attribute__((packed));
+
+typedef struct mixart_timer_notify mixart_timer_notify_t;
+struct mixart_timer_notify
+{
+	u32                  stream_count;
+	mixart_sample_pos_t  streams[MIXART_MAX_STREAM_PER_CARD * MIXART_MAX_CARDS];
+} __attribute__((packed));
+
+
+/*	MSG_CONSOLE_GET_CLOCK_UID            = 0x070003,
+ */
+
+/* request is a uid with desc = MSG_CONSOLE_MANAGER | cardindex */
+
+typedef struct mixart_return_uid mixart_return_uid_t;
+struct mixart_return_uid
+{
+	u32 error_code;
+	mixart_uid_t uid;
+} __attribute__((packed));
+
+/*	MSG_CLOCK_CHECK_PROPERTIES           = 0x200001,
+	MSG_CLOCK_SET_PROPERTIES             = 0x200002,
+*/
+
+enum mixart_clock_generic_type {
+	CGT_NO_CLOCK,
+	CGT_INTERNAL_CLOCK,
+	CGT_PROGRAMMABLE_CLOCK,
+	CGT_INTERNAL_ENSLAVED_CLOCK,
+	CGT_EXTERNAL_CLOCK,
+	CGT_CURRENT_CLOCK
+};
+
+enum mixart_clock_mode {
+	CM_UNDEFINED,
+	CM_MASTER,
+	CM_SLAVE,
+	CM_STANDALONE,
+	CM_NOT_CONCERNED
+};
+
+
+typedef struct mixart_clock_properties mixart_clock_properties_t;
+struct mixart_clock_properties
+{
+	u32 error_code;
+	u32 validation_mask;
+	u32 frequency;
+	u32 reference_frequency;
+	u32 clock_generic_type;
+	u32 clock_mode;
+	mixart_uid_t uid_clock_source;
+	mixart_uid_t uid_event_source;
+	u32 event_mode;
+	u32 synchro_signal_presence;
+	u32 format;
+	u32 board_mask;
+	u32 nb_callers; /* set to 1 (see below) */
+	mixart_uid_t uid_caller[1];
+} __attribute__((packed));
+
+typedef struct mixart_clock_properties_resp mixart_clock_properties_resp_t;
+struct mixart_clock_properties_resp
+{
+	u32 status;
+	u32 clock_mode;
+} __attribute__((packed));
+
+
+/*	MSG_STREAM_SET_INPUT_STAGE_PARAM     = 0x13000F */
+/*	MSG_STREAM_SET_OUTPUT_STAGE_PARAM    = 0x130010 */
+
+enum mixart_coding_type {
+	CT_NOT_DEFINED,
+	CT_LINEAR,
+	CT_MPEG_L1,
+	CT_MPEG_L2,
+	CT_MPEG_L3,
+	CT_MPEG_L3_LSF,
+	CT_GSM
+};
+enum mixart_sample_type {
+	ST_NOT_DEFINED,
+	ST_FLOATING_POINT_32BE,
+	ST_FLOATING_POINT_32LE,
+	ST_FLOATING_POINT_64BE,
+	ST_FLOATING_POINT_64LE,
+	ST_FIXED_POINT_8,
+	ST_FIXED_POINT_16BE,
+	ST_FIXED_POINT_16LE,
+	ST_FIXED_POINT_24BE,
+	ST_FIXED_POINT_24LE,
+	ST_FIXED_POINT_32BE,
+	ST_FIXED_POINT_32LE,
+	ST_INTEGER_8,
+	ST_INTEGER_16BE,
+	ST_INTEGER_16LE,
+	ST_INTEGER_24BE,
+	ST_INTEGER_24LE,
+	ST_INTEGER_32BE,
+	ST_INTEGER_32LE
+};
+
+typedef struct mixart_stream_param_desc mixart_stream_param_desc_t;
+struct mixart_stream_param_desc
+{
+	u32 coding_type;  /* use enum mixart_coding_type */
+	u32 sample_type;  /* use enum mixart_sample_type */
+
+	union {
+		struct {
+			u32 linear_endian_ness;
+			u32 linear_bits;
+			u32 is_signed;
+			u32 is_float;
+		} linear_format_info;
+
+		struct {
+			u32 mpeg_layer;
+			u32 mpeg_mode;
+			u32 mpeg_mode_extension;
+			u32 mpeg_pre_emphasis;
+			u32 mpeg_has_padding_bit;
+			u32 mpeg_has_crc;
+			u32 mpeg_has_extension;
+			u32 mpeg_is_original;
+			u32 mpeg_has_copyright;
+		} mpeg_format_info;
+	} format_info;
+
+	u32 delayed;
+	u64 scheduler;
+	u32 sample_size;
+	u32 has_header;
+	u32 has_suffix;
+	u32 has_bitrate;
+	u32 samples_per_frame;
+	u32 bytes_per_frame;
+	u32 bytes_per_sample;
+	u32 sampling_freq;
+	u32 number_of_channel;
+	u32 stream_number;
+	u32 buffer_size;
+	u32 differed_time;
+	u32 reserved4np[3];
+	u32 pipe_count;                           /* set to 1 (array size !) */
+	u32 stream_count;                         /* set to 1 (array size !) */
+	mixart_txx_stream_desc_t stream_desc[1];  /* only one stream per command, but this could be an array */
+
+} __attribute__((packed));
+
+
+/*	MSG_CONNECTOR_GET_OUT_AUDIO_LEVEL    = 0x050009,
+ */
+
+
+typedef struct mixart_get_out_audio_level mixart_get_out_audio_level_t;
+struct mixart_get_out_audio_level
+{
+	u32 txx_status;
+	u32 digital_level;   /* float */
+	u32 analog_level;    /* float */
+	u32 monitor_level;   /* float */
+	u32 mute;
+	u32 monitor_mute1;
+	u32 monitor_mute2;
+} __attribute__((packed));
+
+
+/*	MSG_CONNECTOR_SET_OUT_AUDIO_LEVEL    = 0x05000A,
+ */
+
+/* used for valid_mask below */
+#define MIXART_AUDIO_LEVEL_ANALOG_MASK	0x01
+#define MIXART_AUDIO_LEVEL_DIGITAL_MASK	0x02
+#define MIXART_AUDIO_LEVEL_MONITOR_MASK	0x04
+#define MIXART_AUDIO_LEVEL_MUTE_MASK	0x08
+#define MIXART_AUDIO_LEVEL_MUTE_M1_MASK	0x10
+#define MIXART_AUDIO_LEVEL_MUTE_M2_MASK	0x20
+
+typedef struct mixart_set_out_audio_level mixart_set_out_audio_level_t;
+struct mixart_set_out_audio_level
+{
+	u32 delayed;
+	u64 scheduler;
+	u32 valid_mask1;
+	u32 valid_mask2;
+	u32 digital_level;   /* float */
+	u32 analog_level;    /* float */
+	u32 monitor_level;   /* float */
+	u32 mute;
+	u32 monitor_mute1;
+	u32 monitor_mute2;
+	u32 reserved4np;
+} __attribute__((packed));
+
+
+/*	MSG_SYSTEM_ENUM_PHYSICAL_IO          = 0x16000E,
+ */
+
+#define MIXART_MAX_PHYS_IO  (MIXART_MAX_CARDS * 2 * 2) /* 4 * (analog+digital) * (playback+capture) */
+
+typedef struct mixart_uid_enumeration mixart_uid_enumeration_t;
+struct mixart_uid_enumeration
+{
+	u32 error_code;
+	u32 first_uid_offset;
+	u32 nb_uid;
+	u32 current_uid_index;
+	mixart_uid_t uid[MIXART_MAX_PHYS_IO];
+} __attribute__((packed));
+
+
+/*	MSG_PHYSICALIO_SET_LEVEL             = 0x0F0008,
+	MSG_PHYSICALIO_GET_LEVEL             = 0x0F000C,
+*/
+
+typedef struct mixart_io_channel_level mixart_io_channel_level_t;
+struct mixart_io_channel_level
+{
+	u32 analog_level;   /* float */
+	u32 unused[2];
+} __attribute__((packed));
+
+typedef struct mixart_io_level mixart_io_level_t;
+struct mixart_io_level
+{
+	s32 channel; /* 0=left, 1=right, -1=both, -2=both same */
+	mixart_io_channel_level_t level[2];
+} __attribute__((packed));
+
+
+/*	MSG_STREAM_SET_IN_AUDIO_LEVEL        = 0x130015,
+ */
+
+typedef struct mixart_in_audio_level_info mixart_in_audio_level_info_t;
+struct mixart_in_audio_level_info
+{
+	mixart_uid_t connector;
+	u32 valid_mask1;
+	u32 valid_mask2;
+	u32 digital_level;
+	u32 analog_level;
+} __attribute__((packed));
+
+typedef struct mixart_set_in_audio_level_req mixart_set_in_audio_level_req_t;
+struct mixart_set_in_audio_level_req
+{
+	u32 delayed;
+	u64 scheduler;
+	u32 audio_count;  /* set to <= 2 */
+	u32 reserved4np;
+	mixart_in_audio_level_info_t level[2];
+} __attribute__((packed));
+
+/* response is a 32 bit status */
+
+
+/*	MSG_STREAM_SET_OUT_STREAM_LEVEL      = 0x130017,
+ */
+
+/* defines used for valid_mask1 */
+#define MIXART_OUT_STREAM_SET_LEVEL_LEFT_AUDIO1		0x01
+#define MIXART_OUT_STREAM_SET_LEVEL_LEFT_AUDIO2		0x02
+#define MIXART_OUT_STREAM_SET_LEVEL_RIGHT_AUDIO1	0x04
+#define MIXART_OUT_STREAM_SET_LEVEL_RIGHT_AUDIO2	0x08
+#define MIXART_OUT_STREAM_SET_LEVEL_STREAM_1		0x10
+#define MIXART_OUT_STREAM_SET_LEVEL_STREAM_2		0x20
+#define MIXART_OUT_STREAM_SET_LEVEL_MUTE_1		0x40
+#define MIXART_OUT_STREAM_SET_LEVEL_MUTE_2		0x80
+
+typedef struct mixart_out_stream_level_info mixart_out_stream_level_info_t;
+struct mixart_out_stream_level_info
+{
+	u32 valid_mask1;
+	u32 valid_mask2;
+	u32 left_to_out1_level;
+	u32 left_to_out2_level;
+	u32 right_to_out1_level;
+	u32 right_to_out2_level;
+	u32 digital_level1;
+	u32 digital_level2;
+	u32 mute1;
+	u32 mute2;
+} __attribute__((packed));
+
+typedef struct mixart_set_out_stream_level mixart_set_out_stream_level_t;
+struct mixart_set_out_stream_level
+{
+	mixart_txx_stream_desc_t desc;
+	mixart_out_stream_level_info_t out_level;
+} __attribute__((packed));
+
+typedef struct mixart_set_out_stream_level_req mixart_set_out_stream_level_req_t;
+struct mixart_set_out_stream_level_req
+{
+	u32 delayed;
+	u64 scheduler;
+	u32 reserved4np[2];
+	u32 nb_of_stream;  /* set to 1 */
+	mixart_set_out_stream_level_t stream_level; /* could be an array */
+} __attribute__((packed));
+
+/* response to this request is a u32 status value */
+
+
+/* exported */
+void snd_mixart_init_mailbox(mixart_mgr_t *mgr);
+void snd_mixart_exit_mailbox(mixart_mgr_t *mgr);
+
+int  snd_mixart_send_msg(mixart_mgr_t *mgr, mixart_msg_t *request, int max_resp_size, void *resp_data);
+int  snd_mixart_send_msg_wait_notif(mixart_mgr_t *mgr, mixart_msg_t *request, u32 notif_event);
+int  snd_mixart_send_msg_nonblock(mixart_mgr_t *mgr, mixart_msg_t *request);
+
+irqreturn_t snd_mixart_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+void snd_mixart_msg_tasklet( unsigned long arg);
+
+void snd_mixart_reset_board(mixart_mgr_t *mgr);
+
+#endif /* __SOUND_MIXART_CORE_H */
