commit f16a4e960ab3475d71df6f0d968c5393f3eca2aa
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:31 2020 +0100

    ALSA: ice1712: More constifications
    
    Apply const prefix to each possible place: the EEPROM tables, the
    static string arrays, the init verb tables, etc.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-17-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ice1712/se.c b/sound/pci/ice1712/se.c
index fdc502783e07..ffa9d8860a5a 100644
--- a/sound/pci/ice1712/se.c
+++ b/sound/pci/ice1712/se.c
@@ -245,7 +245,7 @@ static const char * const se200pci_sel[] = {
 static void se200pci_WM8776_set_input_selector(struct snd_ice1712 *ice,
 					       unsigned int sel)
 {
-	static unsigned char vals[] = {
+	static const unsigned char vals[] = {
 		/* LINE, CD, MIC, ALL, GND */
 		0x10, 0x04, 0x08, 0x1c, 0x03
 	};
@@ -288,7 +288,7 @@ static void se200pci_WM8776_set_agc(struct snd_ice1712 *ice, unsigned int agc)
 static void se200pci_WM8776_init(struct snd_ice1712 *ice)
 {
 	int i;
-	static unsigned short default_values[] = {
+	static const unsigned short default_values[] = {
 		0x100, 0x100, 0x100,
 		0x100, 0x100, 0x100,
 		0x000, 0x090, 0x000, 0x000,
@@ -701,7 +701,7 @@ static int se_add_controls(struct snd_ice1712 *ice)
 /*  entry point                                                             */
 /****************************************************************************/
 
-static unsigned char se200pci_eeprom[] = {
+static const unsigned char se200pci_eeprom[] = {
 	[ICE_EEP2_SYSCONF]	= 0x4b,	/* 49.152Hz, spdif-in/ADC, 4DACs */
 	[ICE_EEP2_ACLINK]	= 0x80,	/* I2S */
 	[ICE_EEP2_I2S]		= 0x78,	/* 96k-ok, 24bit, 192k-ok */
@@ -720,7 +720,7 @@ static unsigned char se200pci_eeprom[] = {
 	[ICE_EEP2_GPIO_STATE2]	= 0x07, /* WM8766 ML/MC/MD */
 };
 
-static unsigned char se90pci_eeprom[] = {
+static const unsigned char se90pci_eeprom[] = {
 	[ICE_EEP2_SYSCONF]	= 0x4b,	/* 49.152Hz, spdif-in/ADC, 4DACs */
 	[ICE_EEP2_ACLINK]	= 0x80,	/* I2S */
 	[ICE_EEP2_I2S]		= 0x78,	/* 96k-ok, 24bit, 192k-ok */

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/ice1712/se.c b/sound/pci/ice1712/se.c
index 1c5d5b22c7a0..fdc502783e07 100644
--- a/sound/pci/ice1712/se.c
+++ b/sound/pci/ice1712/se.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *   ALSA driver for ICEnsemble VT1724 (Envy24HT)
  *
@@ -5,21 +6,6 @@
  *
  *	Copyright (c) 2007 Shin-ya Okada  sh_okada(at)d4.dion.ne.jp
  *                                        (at) -> @
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */      
 
 #include <linux/delay.h>

commit 597da2e4dfa04c8ee66b09fce931ab6825bc3e75
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 20 18:18:50 2014 +0200

    ALSA: ice1724: Use snd_ctl_enum_info()
    
    ... and reduce the open codes.  Also add missing const to text arrays.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ice1712/se.c b/sound/pci/ice1712/se.c
index ffd894bb4507..1c5d5b22c7a0 100644
--- a/sound/pci/ice1712/se.c
+++ b/sound/pci/ice1712/se.c
@@ -452,14 +452,7 @@ static int se200pci_cont_enum_info(struct snd_kcontrol *kc,
 	c = se200pci_get_enum_count(n);
 	if (!c)
 		return -EINVAL;
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = c;
-	if (uinfo->value.enumerated.item >= c)
-		uinfo->value.enumerated.item = c - 1;
-	strcpy(uinfo->value.enumerated.name,
-	       se200pci_cont[n].member[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1, c, se200pci_cont[n].member);
 }
 
 static int se200pci_cont_volume_get(struct snd_kcontrol *kc,

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ice1712/se.c b/sound/pci/ice1712/se.c
index 53b555f5bbea..ffd894bb4507 100644
--- a/sound/pci/ice1712/se.c
+++ b/sound/pci/ice1712/se.c
@@ -113,7 +113,7 @@ struct se_spec {
 /*  WM8740 interface                                                        */
 /****************************************************************************/
 
-static void __devinit se200pci_WM8740_init(struct snd_ice1712 *ice)
+static void se200pci_WM8740_init(struct snd_ice1712 *ice)
 {
 	/* nothing to do */
 }
@@ -195,7 +195,7 @@ static void se200pci_WM8766_set_volume(struct snd_ice1712 *ice, int ch,
 	}
 }
 
-static void __devinit se200pci_WM8766_init(struct snd_ice1712 *ice)
+static void se200pci_WM8766_init(struct snd_ice1712 *ice)
 {
 	se200pci_WM8766_write(ice, 0x1f, 0x000); /* RESET ALL */
 	udelay(10);
@@ -299,10 +299,10 @@ static void se200pci_WM8776_set_agc(struct snd_ice1712 *ice, unsigned int agc)
 	}
 }
 
-static void __devinit se200pci_WM8776_init(struct snd_ice1712 *ice)
+static void se200pci_WM8776_init(struct snd_ice1712 *ice)
 {
 	int i;
-	static unsigned short __devinitdata default_values[] = {
+	static unsigned short default_values[] = {
 		0x100, 0x100, 0x100,
 		0x100, 0x100, 0x100,
 		0x000, 0x090, 0x000, 0x000,
@@ -599,7 +599,7 @@ static int se200pci_cont_enum_put(struct snd_kcontrol *kc,
 static const DECLARE_TLV_DB_SCALE(db_scale_gain1, -12750, 50, 1);
 static const DECLARE_TLV_DB_SCALE(db_scale_gain2, -10350, 50, 1);
 
-static int __devinit se200pci_add_controls(struct snd_ice1712 *ice)
+static int se200pci_add_controls(struct snd_ice1712 *ice)
 {
 	int i;
 	struct snd_kcontrol_new cont;
@@ -677,7 +677,7 @@ static int __devinit se200pci_add_controls(struct snd_ice1712 *ice)
 /*  probe/initialize/setup                                                  */
 /****************************************************************************/
 
-static int __devinit se_init(struct snd_ice1712 *ice)
+static int se_init(struct snd_ice1712 *ice)
 {
 	struct se_spec *spec;
 
@@ -705,7 +705,7 @@ static int __devinit se_init(struct snd_ice1712 *ice)
 	return -ENOENT;
 }
 
-static int __devinit se_add_controls(struct snd_ice1712 *ice)
+static int se_add_controls(struct snd_ice1712 *ice)
 {
 	int err;
 
@@ -722,7 +722,7 @@ static int __devinit se_add_controls(struct snd_ice1712 *ice)
 /*  entry point                                                             */
 /****************************************************************************/
 
-static unsigned char se200pci_eeprom[] __devinitdata = {
+static unsigned char se200pci_eeprom[] = {
 	[ICE_EEP2_SYSCONF]	= 0x4b,	/* 49.152Hz, spdif-in/ADC, 4DACs */
 	[ICE_EEP2_ACLINK]	= 0x80,	/* I2S */
 	[ICE_EEP2_I2S]		= 0x78,	/* 96k-ok, 24bit, 192k-ok */
@@ -741,7 +741,7 @@ static unsigned char se200pci_eeprom[] __devinitdata = {
 	[ICE_EEP2_GPIO_STATE2]	= 0x07, /* WM8766 ML/MC/MD */
 };
 
-static unsigned char se90pci_eeprom[] __devinitdata = {
+static unsigned char se90pci_eeprom[] = {
 	[ICE_EEP2_SYSCONF]	= 0x4b,	/* 49.152Hz, spdif-in/ADC, 4DACs */
 	[ICE_EEP2_ACLINK]	= 0x80,	/* I2S */
 	[ICE_EEP2_I2S]		= 0x78,	/* 96k-ok, 24bit, 192k-ok */
@@ -750,7 +750,7 @@ static unsigned char se90pci_eeprom[] __devinitdata = {
 	/* ALL GPIO bits are in input mode */
 };
 
-struct snd_ice1712_card_info snd_vt1724_se_cards[] __devinitdata = {
+struct snd_ice1712_card_info snd_vt1724_se_cards[] = {
 	{
 		.subvendor = VT1724_SUBDEVICE_SE200PCI,
 		.name = "ONKYO SE200PCI",

commit de3ab850a0e883329594f62ec18fecef4fcfe5ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 18 08:14:50 2012 +0200

    ALSA: ice17xx: Fix inclusion of linux/io.h
    
    Include linux/io.h in ice1712.h since inb() and outb() are used in
    inline functions there.  Remove the redundant inclusion of that file
    in other places at the same time.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ice1712/se.c b/sound/pci/ice1712/se.c
index 62d0fc90abfb..53b555f5bbea 100644
--- a/sound/pci/ice1712/se.c
+++ b/sound/pci/ice1712/se.c
@@ -22,7 +22,6 @@
  *
  */      
 
-#include <asm/io.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>

commit a2af050f8df6eeec29818639859f14eb237d6957
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 17 09:21:48 2012 +0200

    ALSA: ice17xx: Constify strings and string arrays
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ice1712/se.c b/sound/pci/ice1712/se.c
index 69673b95869d..62d0fc90abfb 100644
--- a/sound/pci/ice1712/se.c
+++ b/sound/pci/ice1712/se.c
@@ -253,7 +253,7 @@ static void se200pci_WM8776_set_input_volume(struct snd_ice1712 *ice,
 	se200pci_WM8776_write(ice, 0x0f, vol2 | 0x100);
 }
 
-static const char *se200pci_sel[] = {
+static const char * const se200pci_sel[] = {
 	"LINE-IN", "CD-IN", "MIC-IN", "ALL-MIX", NULL
 };
 
@@ -278,7 +278,7 @@ static void se200pci_WM8776_set_afl(struct snd_ice1712 *ice, unsigned int afl)
 		se200pci_WM8776_write(ice, 0x16, 0x001);
 }
 
-static const char *se200pci_agc[] = {
+static const char * const se200pci_agc[] = {
 	"Off", "LimiterMode", "ALCMode", NULL
 };
 
@@ -352,7 +352,7 @@ static void se200pci_set_pro_rate(struct snd_ice1712 *ice, unsigned int rate)
 }
 
 struct se200pci_control {
-	char *name;
+	const char *name;
 	enum {
 		WM8766,
 		WM8776in,
@@ -363,7 +363,7 @@ struct se200pci_control {
 	} target;
 	enum { VOLUME1, VOLUME2, BOOLEAN, ENUM } type;
 	int ch;
-	const char **member;
+	const char * const *member;
 	const char *comment;
 };
 
@@ -421,7 +421,7 @@ static const struct se200pci_control se200pci_cont[] = {
 
 static int se200pci_get_enum_count(int n)
 {
-	const char **member;
+	const char * const *member;
 	int c;
 
 	member = se200pci_cont[n].member;

commit 7cda8ba9f4e471dfba914ecf67fd14ebffb17c16
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 18 13:36:07 2008 +0100

    [ALSA] ice1712, ice1724 - Code clean up
    
    Clean up ice1712/ice1724 codes.  The board-specific data is allocated
    locally in each code instead of having an ungly union in struct ice1712.
    Also, fix coding issues in prodigy_hifi.c.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/ice1712/se.c b/sound/pci/ice1712/se.c
index 6661f65a6f2e..69673b95869d 100644
--- a/sound/pci/ice1712/se.c
+++ b/sound/pci/ice1712/se.c
@@ -34,6 +34,11 @@
 #include "envy24ht.h"
 #include "se.h"
 
+struct se_spec {
+	struct {
+		unsigned char ch1, ch2;
+	} vol[8];
+};
 
 /****************************************************************************/
 /*  ONKYO WAVIO SE-200PCI                                                   */
@@ -462,9 +467,10 @@ static int se200pci_cont_volume_get(struct snd_kcontrol *kc,
 				    struct snd_ctl_elem_value *uc)
 {
 	struct snd_ice1712 *ice = snd_kcontrol_chip(kc);
+	struct se_spec *spec = ice->spec;
 	int n = kc->private_value;
-	uc->value.integer.value[0] = ice->spec.se.vol[n].ch1;
-	uc->value.integer.value[1] = ice->spec.se.vol[n].ch2;
+	uc->value.integer.value[0] = spec->vol[n].ch1;
+	uc->value.integer.value[1] = spec->vol[n].ch2;
 	return 0;
 }
 
@@ -472,8 +478,9 @@ static int se200pci_cont_boolean_get(struct snd_kcontrol *kc,
 				     struct snd_ctl_elem_value *uc)
 {
 	struct snd_ice1712 *ice = snd_kcontrol_chip(kc);
+	struct se_spec *spec = ice->spec;
 	int n = kc->private_value;
-	uc->value.integer.value[0] = ice->spec.se.vol[n].ch1;
+	uc->value.integer.value[0] = spec->vol[n].ch1;
 	return 0;
 }
 
@@ -481,44 +488,46 @@ static int se200pci_cont_enum_get(struct snd_kcontrol *kc,
 				  struct snd_ctl_elem_value *uc)
 {
 	struct snd_ice1712 *ice = snd_kcontrol_chip(kc);
+	struct se_spec *spec = ice->spec;
 	int n = kc->private_value;
-	uc->value.enumerated.item[0] = ice->spec.se.vol[n].ch1;
+	uc->value.enumerated.item[0] = spec->vol[n].ch1;
 	return 0;
 }
 
 static void se200pci_cont_update(struct snd_ice1712 *ice, int n)
 {
+	struct se_spec *spec = ice->spec;
 	switch (se200pci_cont[n].target) {
 	case WM8766:
 		se200pci_WM8766_set_volume(ice,
 					   se200pci_cont[n].ch,
-					   ice->spec.se.vol[n].ch1,
-					   ice->spec.se.vol[n].ch2);
+					   spec->vol[n].ch1,
+					   spec->vol[n].ch2);
 		break;
 
 	case WM8776in:
 		se200pci_WM8776_set_input_volume(ice,
-						 ice->spec.se.vol[n].ch1,
-						 ice->spec.se.vol[n].ch2);
+						 spec->vol[n].ch1,
+						 spec->vol[n].ch2);
 		break;
 
 	case WM8776out:
 		se200pci_WM8776_set_output_volume(ice,
-						  ice->spec.se.vol[n].ch1,
-						  ice->spec.se.vol[n].ch2);
+						  spec->vol[n].ch1,
+						  spec->vol[n].ch2);
 		break;
 
 	case WM8776sel:
 		se200pci_WM8776_set_input_selector(ice,
-						   ice->spec.se.vol[n].ch1);
+						   spec->vol[n].ch1);
 		break;
 
 	case WM8776agc:
-		se200pci_WM8776_set_agc(ice, ice->spec.se.vol[n].ch1);
+		se200pci_WM8776_set_agc(ice, spec->vol[n].ch1);
 		break;
 
 	case WM8776afl:
-		se200pci_WM8776_set_afl(ice, ice->spec.se.vol[n].ch1);
+		se200pci_WM8776_set_afl(ice, spec->vol[n].ch1);
 		break;
 
 	default:
@@ -530,6 +539,7 @@ static int se200pci_cont_volume_put(struct snd_kcontrol *kc,
 				    struct snd_ctl_elem_value *uc)
 {
 	struct snd_ice1712 *ice = snd_kcontrol_chip(kc);
+	struct se_spec *spec = ice->spec;
 	int n = kc->private_value;
 	unsigned int vol1, vol2;
 	int changed;
@@ -537,12 +547,12 @@ static int se200pci_cont_volume_put(struct snd_kcontrol *kc,
 	changed = 0;
 	vol1 = uc->value.integer.value[0] & 0xff;
 	vol2 = uc->value.integer.value[1] & 0xff;
-	if (ice->spec.se.vol[n].ch1 != vol1) {
-		ice->spec.se.vol[n].ch1 = vol1;
+	if (spec->vol[n].ch1 != vol1) {
+		spec->vol[n].ch1 = vol1;
 		changed = 1;
 	}
-	if (ice->spec.se.vol[n].ch2 != vol2) {
-		ice->spec.se.vol[n].ch2 = vol2;
+	if (spec->vol[n].ch2 != vol2) {
+		spec->vol[n].ch2 = vol2;
 		changed = 1;
 	}
 	if (changed)
@@ -555,12 +565,13 @@ static int se200pci_cont_boolean_put(struct snd_kcontrol *kc,
 				     struct snd_ctl_elem_value *uc)
 {
 	struct snd_ice1712 *ice = snd_kcontrol_chip(kc);
+	struct se_spec *spec = ice->spec;
 	int n = kc->private_value;
 	unsigned int vol1;
 
 	vol1 = !!uc->value.integer.value[0];
-	if (ice->spec.se.vol[n].ch1 != vol1) {
-		ice->spec.se.vol[n].ch1 = vol1;
+	if (spec->vol[n].ch1 != vol1) {
+		spec->vol[n].ch1 = vol1;
 		se200pci_cont_update(ice, n);
 		return 1;
 	}
@@ -571,14 +582,15 @@ static int se200pci_cont_enum_put(struct snd_kcontrol *kc,
 				  struct snd_ctl_elem_value *uc)
 {
 	struct snd_ice1712 *ice = snd_kcontrol_chip(kc);
+	struct se_spec *spec = ice->spec;
 	int n = kc->private_value;
 	unsigned int vol1;
 
 	vol1 = uc->value.enumerated.item[0];
 	if (vol1 >= se200pci_get_enum_count(n))
 		return -EINVAL;
-	if (ice->spec.se.vol[n].ch1 != vol1) {
-		ice->spec.se.vol[n].ch1 = vol1;
+	if (spec->vol[n].ch1 != vol1) {
+		spec->vol[n].ch1 = vol1;
 		se200pci_cont_update(ice, n);
 		return 1;
 	}
@@ -668,6 +680,13 @@ static int __devinit se200pci_add_controls(struct snd_ice1712 *ice)
 
 static int __devinit se_init(struct snd_ice1712 *ice)
 {
+	struct se_spec *spec;
+
+	spec = kzalloc(sizeof(*spec), GFP_KERNEL);
+	if (!spec)
+		return -ENOMEM;
+	ice->spec = spec;
+
 	if (ice->eeprom.subvendor == VT1724_SUBDEVICE_SE90PCI) {
 		ice->num_total_dacs = 2;
 		ice->num_total_adcs = 0;

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/ice1712/se.c b/sound/pci/ice1712/se.c
index 3c8b518118e9..6661f65a6f2e 100644
--- a/sound/pci/ice1712/se.c
+++ b/sound/pci/ice1712/se.c
@@ -22,7 +22,6 @@
  *
  */      
 
-#include <sound/driver.h>
 #include <asm/io.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>

commit 9c45ba100501c206658f356ea1db3263947b9a30
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 15 16:05:26 2007 +0100

    [ALSA] ice1724 - Clean up ctl callbacks in se.c
    
    Clean up ctl callbacks of SE-200PCI driver.  Also make sure to check
    the value ranges.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/ice1712/se.c b/sound/pci/ice1712/se.c
index ebfe2454a08b..3c8b518118e9 100644
--- a/sound/pci/ice1712/se.c
+++ b/sound/pci/ice1712/se.c
@@ -415,134 +415,177 @@ static const struct se200pci_control se200pci_cont[] = {
 	}
 };
 
-static int se200pci_cont_info(struct snd_kcontrol *kc,
-				struct snd_ctl_elem_info *uinfo)
+static int se200pci_get_enum_count(int n)
 {
-	struct snd_ice1712 *ice;
-	int n;
-	int c;
 	const char **member;
+	int c;
 
-	ice = snd_kcontrol_chip(kc);
-	n = kc->private_value;
-
-	if (se200pci_cont[n].type == VOLUME1 ||
-	    se200pci_cont[n].type == VOLUME2) {
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-		uinfo->count = 2;
-		uinfo->value.integer.min = 0; /* mute */
-		uinfo->value.integer.max = 0xff; /* 0dB */
-
-	} else if (se200pci_cont[n].type == BOOLEAN) {
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-		uinfo->count = 1;
-		uinfo->value.integer.min = 0;
-		uinfo->value.integer.max = 1;
-
-	} else if (se200pci_cont[n].type == ENUM) {
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-		member = se200pci_cont[n].member;
-		if (member == NULL)
-			return -EINVAL;
-		for (c = 0; member[c]; c++)
-			;
-
-		uinfo->count = 1;
-		uinfo->value.enumerated.items = c;
-		if (uinfo->value.enumerated.item >= c)
-			uinfo->value.enumerated.item = c - 1;
-		strcpy(uinfo->value.enumerated.name,
-			member[uinfo->value.enumerated.item]);
-	}
+	member = se200pci_cont[n].member;
+	if (!member)
+		return 0;
+	for (c = 0; member[c]; c++)
+		;
+	return c;
+}
 
+static int se200pci_cont_volume_info(struct snd_kcontrol *kc,
+				     struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0; /* mute */
+	uinfo->value.integer.max = 0xff; /* 0dB */
 	return 0;
 }
 
-static int se200pci_cont_get(struct snd_kcontrol *kc,
-				struct snd_ctl_elem_value *uc)
+#define se200pci_cont_boolean_info	snd_ctl_boolean_mono_info
+
+static int se200pci_cont_enum_info(struct snd_kcontrol *kc,
+				   struct snd_ctl_elem_info *uinfo)
 {
-	struct snd_ice1712 *ice;
-	int n;
+	int n, c;
 
-	ice = snd_kcontrol_chip(kc);
 	n = kc->private_value;
-	if (se200pci_cont[n].type == VOLUME1 ||
-	    se200pci_cont[n].type == VOLUME2) {
-		uc->value.integer.value[0] = ice->spec.se.vol[n].ch1;
-		uc->value.integer.value[1] = ice->spec.se.vol[n].ch2;
-
-	} else if (se200pci_cont[n].type == BOOLEAN ||
-		   se200pci_cont[n].type == ENUM)
-		uc->value.integer.value[0] = ice->spec.se.vol[n].ch1;
-
+	c = se200pci_get_enum_count(n);
+	if (!c)
+		return -EINVAL;
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = c;
+	if (uinfo->value.enumerated.item >= c)
+		uinfo->value.enumerated.item = c - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       se200pci_cont[n].member[uinfo->value.enumerated.item]);
 	return 0;
 }
 
-static int se200pci_cont_put(struct snd_kcontrol *kc,
-				struct snd_ctl_elem_value *uc)
+static int se200pci_cont_volume_get(struct snd_kcontrol *kc,
+				    struct snd_ctl_elem_value *uc)
 {
-	struct snd_ice1712 *ice;
-	int n;
-	unsigned int vol1, vol2;
-	int changed;
-
-	ice = snd_kcontrol_chip(kc);
-	n = kc->private_value;
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kc);
+	int n = kc->private_value;
+	uc->value.integer.value[0] = ice->spec.se.vol[n].ch1;
+	uc->value.integer.value[1] = ice->spec.se.vol[n].ch2;
+	return 0;
+}
 
-	changed = 0;
-	vol1 = 0; vol2 = 0;
-	if (se200pci_cont[n].type == VOLUME1 ||
-	    se200pci_cont[n].type == VOLUME2) {
-		vol1 = uc->value.integer.value[0];
-		vol2 = uc->value.integer.value[1];
-		if (ice->spec.se.vol[n].ch1 != vol1)
-			changed = 1;
-		if (ice->spec.se.vol[n].ch2 != vol2)
-			changed = 1;
-		ice->spec.se.vol[n].ch1 = vol1;
-		ice->spec.se.vol[n].ch2 = vol2;
+static int se200pci_cont_boolean_get(struct snd_kcontrol *kc,
+				     struct snd_ctl_elem_value *uc)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kc);
+	int n = kc->private_value;
+	uc->value.integer.value[0] = ice->spec.se.vol[n].ch1;
+	return 0;
+}
 
-	} else if (se200pci_cont[n].type == BOOLEAN ||
-		   se200pci_cont[n].type == ENUM) {
-		vol1 = uc->value.integer.value[0];
-		if (ice->spec.se.vol[n].ch1 != vol1)
-			changed = 1;
-		ice->spec.se.vol[n].ch1 = vol1;
-	}
+static int se200pci_cont_enum_get(struct snd_kcontrol *kc,
+				  struct snd_ctl_elem_value *uc)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kc);
+	int n = kc->private_value;
+	uc->value.enumerated.item[0] = ice->spec.se.vol[n].ch1;
+	return 0;
+}
 
+static void se200pci_cont_update(struct snd_ice1712 *ice, int n)
+{
 	switch (se200pci_cont[n].target) {
 	case WM8766:
 		se200pci_WM8766_set_volume(ice,
-			se200pci_cont[n].ch, vol1, vol2);
+					   se200pci_cont[n].ch,
+					   ice->spec.se.vol[n].ch1,
+					   ice->spec.se.vol[n].ch2);
 		break;
 
 	case WM8776in:
-		se200pci_WM8776_set_input_volume(ice, vol1, vol2);
+		se200pci_WM8776_set_input_volume(ice,
+						 ice->spec.se.vol[n].ch1,
+						 ice->spec.se.vol[n].ch2);
 		break;
 
 	case WM8776out:
-		se200pci_WM8776_set_output_volume(ice, vol1, vol2);
+		se200pci_WM8776_set_output_volume(ice,
+						  ice->spec.se.vol[n].ch1,
+						  ice->spec.se.vol[n].ch2);
 		break;
 
 	case WM8776sel:
-		se200pci_WM8776_set_input_selector(ice, vol1);
+		se200pci_WM8776_set_input_selector(ice,
+						   ice->spec.se.vol[n].ch1);
 		break;
 
 	case WM8776agc:
-		se200pci_WM8776_set_agc(ice, vol1);
+		se200pci_WM8776_set_agc(ice, ice->spec.se.vol[n].ch1);
 		break;
 
 	case WM8776afl:
-		se200pci_WM8776_set_afl(ice, vol1);
+		se200pci_WM8776_set_afl(ice, ice->spec.se.vol[n].ch1);
 		break;
 
 	default:
 		break;
 	}
+}
+
+static int se200pci_cont_volume_put(struct snd_kcontrol *kc,
+				    struct snd_ctl_elem_value *uc)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kc);
+	int n = kc->private_value;
+	unsigned int vol1, vol2;
+	int changed;
+
+	changed = 0;
+	vol1 = uc->value.integer.value[0] & 0xff;
+	vol2 = uc->value.integer.value[1] & 0xff;
+	if (ice->spec.se.vol[n].ch1 != vol1) {
+		ice->spec.se.vol[n].ch1 = vol1;
+		changed = 1;
+	}
+	if (ice->spec.se.vol[n].ch2 != vol2) {
+		ice->spec.se.vol[n].ch2 = vol2;
+		changed = 1;
+	}
+	if (changed)
+		se200pci_cont_update(ice, n);
 
 	return changed;
 }
 
+static int se200pci_cont_boolean_put(struct snd_kcontrol *kc,
+				     struct snd_ctl_elem_value *uc)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kc);
+	int n = kc->private_value;
+	unsigned int vol1;
+
+	vol1 = !!uc->value.integer.value[0];
+	if (ice->spec.se.vol[n].ch1 != vol1) {
+		ice->spec.se.vol[n].ch1 = vol1;
+		se200pci_cont_update(ice, n);
+		return 1;
+	}
+	return 0;
+}
+
+static int se200pci_cont_enum_put(struct snd_kcontrol *kc,
+				  struct snd_ctl_elem_value *uc)
+{
+	struct snd_ice1712 *ice = snd_kcontrol_chip(kc);
+	int n = kc->private_value;
+	unsigned int vol1;
+
+	vol1 = uc->value.enumerated.item[0];
+	if (vol1 >= se200pci_get_enum_count(n))
+		return -EINVAL;
+	if (ice->spec.se.vol[n].ch1 != vol1) {
+		ice->spec.se.vol[n].ch1 = vol1;
+		se200pci_cont_update(ice, n);
+		return 1;
+	}
+	return 0;
+}
+
 static const DECLARE_TLV_DB_SCALE(db_scale_gain1, -12750, 50, 1);
 static const DECLARE_TLV_DB_SCALE(db_scale_gain2, -10350, 50, 1);
 
@@ -554,23 +597,36 @@ static int __devinit se200pci_add_controls(struct snd_ice1712 *ice)
 
 	memset(&cont, 0, sizeof(cont));
 	cont.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
-	cont.info = se200pci_cont_info;
-	cont.get = se200pci_cont_get;
-	cont.put = se200pci_cont_put;
 	for (i = 0; i < ARRAY_SIZE(se200pci_cont); i++) {
 		cont.private_value = i;
 		cont.name = se200pci_cont[i].name;
 		cont.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;
 		cont.tlv.p = NULL;
-		if (se200pci_cont[i].type == VOLUME1 ||
-		    se200pci_cont[i].type == VOLUME2) {
-
+		switch (se200pci_cont[i].type) {
+		case VOLUME1:
+		case VOLUME2:
+			cont.info = se200pci_cont_volume_info;
+			cont.get = se200pci_cont_volume_get;
+			cont.put = se200pci_cont_volume_put;
 			cont.access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;
-
 			if (se200pci_cont[i].type == VOLUME1)
 				cont.tlv.p = db_scale_gain1;
 			else
 				cont.tlv.p = db_scale_gain2;
+			break;
+		case BOOLEAN:
+			cont.info = se200pci_cont_boolean_info;
+			cont.get = se200pci_cont_boolean_get;
+			cont.put = se200pci_cont_boolean_put;
+			break;
+		case ENUM:
+			cont.info = se200pci_cont_enum_info;
+			cont.get = se200pci_cont_enum_get;
+			cont.put = se200pci_cont_enum_put;
+			break;
+		default:
+			snd_BUG();
+			return -EINVAL;
 		}
 		err = snd_ctl_add(ice->card, snd_ctl_new1(&cont, ice));
 		if (err < 0)

commit f31639b8c5916f58441b529c9c364715921b29af
Author: Shin-ya Okada <sh_okada at d4.dion.ne.jp>
Date:   Tue Oct 23 15:08:18 2007 +0200

    [ALSA] ice1724 - Add support of Onkyo SE-90PCI and SE-200PCI
    
    Added the support for Onkyo SE-90PCI and SE-200PCI boards.
    
    Signed-off-by: Shin-ya Okada <sh_okada at d4.dion.ne.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/ice1712/se.c b/sound/pci/ice1712/se.c
new file mode 100644
index 000000000000..ebfe2454a08b
--- /dev/null
+++ b/sound/pci/ice1712/se.c
@@ -0,0 +1,700 @@
+/*
+ *   ALSA driver for ICEnsemble VT1724 (Envy24HT)
+ *
+ *   Lowlevel functions for ONKYO WAVIO SE-90PCI and SE-200PCI
+ *
+ *	Copyright (c) 2007 Shin-ya Okada  sh_okada(at)d4.dion.ne.jp
+ *                                        (at) -> @
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */      
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/tlv.h>
+
+#include "ice1712.h"
+#include "envy24ht.h"
+#include "se.h"
+
+
+/****************************************************************************/
+/*  ONKYO WAVIO SE-200PCI                                                   */
+/****************************************************************************/
+/*
+ *  system configuration ICE_EEP2_SYSCONF=0x4b
+ *    XIN1 49.152MHz
+ *    not have UART
+ *    one stereo ADC and a S/PDIF receiver connected
+ *    four stereo DACs connected
+ *
+ *  AC-Link configuration ICE_EEP2_ACLINK=0x80
+ *    use I2C, not use AC97
+ *
+ *  I2S converters feature ICE_EEP2_I2S=0x78
+ *    I2S codec has no volume/mute control feature
+ *    I2S codec supports 96KHz and 192KHz
+ *    I2S codec 24bits
+ *
+ *  S/PDIF configuration ICE_EEP2_SPDIF=0xc3
+ *    Enable integrated S/PDIF transmitter
+ *    internal S/PDIF out implemented
+ *    S/PDIF is stereo
+ *    External S/PDIF out implemented
+ *
+ *
+ * ** connected chips **
+ *
+ *  WM8740
+ *      A 2ch-DAC of main outputs.
+ *      It setuped as I2S mode by wire, so no way to setup from software.
+ *      The sample-rate are automatically changed. 
+ *          ML/I2S (28pin) --------+
+ *          MC/DM1 (27pin) -- 5V   |
+ *          MD/DM0 (26pin) -- GND  |
+ *          MUTEB  (25pin) -- NC   |
+ *          MODE   (24pin) -- GND  |
+ *          CSBIW  (23pin) --------+
+ *                                 |
+ *          RSTB   (22pin) --R(1K)-+
+ *      Probably it reduce the noise from the control line.
+ *
+ *  WM8766
+ *      A 6ch-DAC for surrounds.
+ *      It's control wire was connected to GPIOxx (3-wire serial interface)
+ *          ML/I2S (11pin) -- GPIO18
+ *          MC/IWL (12pin) -- GPIO17
+ *          MD/DM  (13pin) -- GPIO16
+ *          MUTE   (14pin) -- GPIO01
+ *
+ *  WM8776
+ *     A 2ch-ADC(with 10ch-selector) plus 2ch-DAC.
+ *     It's control wire was connected to SDA/SCLK (2-wire serial interface)
+ *          MODE (16pin) -- R(1K) -- GND
+ *          CE   (17pin) -- R(1K) -- GND  2-wire mode (address=0x34)
+ *          DI   (18pin) -- SDA
+ *          CL   (19pin) -- SCLK
+ *
+ *
+ * ** output pins and device names **
+ *
+ *   7.1ch name -- output connector color -- device (-D option)
+ *
+ *      FRONT 2ch                  -- green  -- plughw:0,0
+ *      CENTER(Lch) SUBWOOFER(Rch) -- black  -- plughw:0,2,0
+ *      SURROUND 2ch               -- orange -- plughw:0,2,1
+ *      SURROUND BACK 2ch          -- white  -- plughw:0,2,2
+ *
+ */
+
+
+/****************************************************************************/
+/*  WM8740 interface                                                        */
+/****************************************************************************/
+
+static void __devinit se200pci_WM8740_init(struct snd_ice1712 *ice)
+{
+	/* nothing to do */
+}
+
+
+static void se200pci_WM8740_set_pro_rate(struct snd_ice1712 *ice,
+						unsigned int rate)
+{
+	/* nothing to do */
+}
+
+
+/****************************************************************************/
+/*  WM8766 interface                                                        */
+/****************************************************************************/
+
+static void se200pci_WM8766_write(struct snd_ice1712 *ice,
+					unsigned int addr, unsigned int data)
+{
+	unsigned int st;
+	unsigned int bits;
+	int i;
+	const unsigned int DATA  = 0x010000;
+	const unsigned int CLOCK = 0x020000;
+	const unsigned int LOAD  = 0x040000;
+	const unsigned int ALL_MASK = (DATA | CLOCK | LOAD);
+
+	snd_ice1712_save_gpio_status(ice);
+
+	st = ((addr & 0x7f) << 9) | (data & 0x1ff);
+	snd_ice1712_gpio_set_dir(ice, ice->gpio.direction | ALL_MASK);
+	snd_ice1712_gpio_set_mask(ice, ice->gpio.write_mask & ~ALL_MASK);
+	bits = snd_ice1712_gpio_read(ice) & ~ALL_MASK;
+
+	snd_ice1712_gpio_write(ice, bits);
+	for (i = 0; i < 16; i++) {
+		udelay(1);
+		bits &= ~CLOCK;
+		st = (st << 1);
+		if (st & 0x10000)
+			bits |= DATA;
+		else
+			bits &= ~DATA;
+
+		snd_ice1712_gpio_write(ice, bits);
+
+		udelay(1);
+		bits |= CLOCK;
+		snd_ice1712_gpio_write(ice, bits);
+	}
+
+	udelay(1);
+	bits |= LOAD;
+	snd_ice1712_gpio_write(ice, bits);
+
+	udelay(1);
+	bits |= (DATA | CLOCK);
+	snd_ice1712_gpio_write(ice, bits);
+
+	snd_ice1712_restore_gpio_status(ice);
+}
+
+static void se200pci_WM8766_set_volume(struct snd_ice1712 *ice, int ch,
+					unsigned int vol1, unsigned int vol2)
+{
+	switch (ch) {
+	case 0:
+		se200pci_WM8766_write(ice, 0x000, vol1);
+		se200pci_WM8766_write(ice, 0x001, vol2 | 0x100);
+		break;
+	case 1:
+		se200pci_WM8766_write(ice, 0x004, vol1);
+		se200pci_WM8766_write(ice, 0x005, vol2 | 0x100);
+		break;
+	case 2:
+		se200pci_WM8766_write(ice, 0x006, vol1);
+		se200pci_WM8766_write(ice, 0x007, vol2 | 0x100);
+		break;
+	}
+}
+
+static void __devinit se200pci_WM8766_init(struct snd_ice1712 *ice)
+{
+	se200pci_WM8766_write(ice, 0x1f, 0x000); /* RESET ALL */
+	udelay(10);
+
+	se200pci_WM8766_set_volume(ice, 0, 0, 0); /* volume L=0 R=0 */
+	se200pci_WM8766_set_volume(ice, 1, 0, 0); /* volume L=0 R=0 */
+	se200pci_WM8766_set_volume(ice, 2, 0, 0); /* volume L=0 R=0 */
+
+	se200pci_WM8766_write(ice, 0x03, 0x022); /* serial mode I2S-24bits */
+	se200pci_WM8766_write(ice, 0x0a, 0x080); /* MCLK=256fs */
+	se200pci_WM8766_write(ice, 0x12, 0x000); /* MDP=0 */
+	se200pci_WM8766_write(ice, 0x15, 0x000); /* MDP=0 */
+	se200pci_WM8766_write(ice, 0x09, 0x000); /* demp=off mute=off */
+
+	se200pci_WM8766_write(ice, 0x02, 0x124); /* ch-assign L=L R=R RESET */
+	se200pci_WM8766_write(ice, 0x02, 0x120); /* ch-assign L=L R=R */
+}
+
+static void se200pci_WM8766_set_pro_rate(struct snd_ice1712 *ice,
+					unsigned int rate)
+{
+	if (rate > 96000)
+		se200pci_WM8766_write(ice, 0x0a, 0x000); /* MCLK=128fs */
+	else
+		se200pci_WM8766_write(ice, 0x0a, 0x080); /* MCLK=256fs */
+}
+
+
+/****************************************************************************/
+/*  WM8776 interface                                                        */
+/****************************************************************************/
+
+static void se200pci_WM8776_write(struct snd_ice1712 *ice,
+					unsigned int addr, unsigned int data)
+{
+	unsigned int val;
+
+	val = (addr << 9) | data;
+	snd_vt1724_write_i2c(ice, 0x34, val >> 8, val & 0xff);
+}
+
+
+static void se200pci_WM8776_set_output_volume(struct snd_ice1712 *ice,
+					unsigned int vol1, unsigned int vol2)
+{
+	se200pci_WM8776_write(ice, 0x03, vol1);
+	se200pci_WM8776_write(ice, 0x04, vol2 | 0x100);
+}
+
+static void se200pci_WM8776_set_input_volume(struct snd_ice1712 *ice,
+					unsigned int vol1, unsigned int vol2)
+{
+	se200pci_WM8776_write(ice, 0x0e, vol1);
+	se200pci_WM8776_write(ice, 0x0f, vol2 | 0x100);
+}
+
+static const char *se200pci_sel[] = {
+	"LINE-IN", "CD-IN", "MIC-IN", "ALL-MIX", NULL
+};
+
+static void se200pci_WM8776_set_input_selector(struct snd_ice1712 *ice,
+					       unsigned int sel)
+{
+	static unsigned char vals[] = {
+		/* LINE, CD, MIC, ALL, GND */
+		0x10, 0x04, 0x08, 0x1c, 0x03
+	};
+	if (sel > 4)
+		sel = 4;
+	se200pci_WM8776_write(ice, 0x15, vals[sel]);
+}
+
+static void se200pci_WM8776_set_afl(struct snd_ice1712 *ice, unsigned int afl)
+{
+	/* AFL -- After Fader Listening */
+	if (afl)
+		se200pci_WM8776_write(ice, 0x16, 0x005);
+	else
+		se200pci_WM8776_write(ice, 0x16, 0x001);
+}
+
+static const char *se200pci_agc[] = {
+	"Off", "LimiterMode", "ALCMode", NULL
+};
+
+static void se200pci_WM8776_set_agc(struct snd_ice1712 *ice, unsigned int agc)
+{
+	/* AGC -- Auto Gain Control of the input */
+	switch (agc) {
+	case 0:
+		se200pci_WM8776_write(ice, 0x11, 0x000); /* Off */
+		break;
+	case 1:
+		se200pci_WM8776_write(ice, 0x10, 0x07b);
+		se200pci_WM8776_write(ice, 0x11, 0x100); /* LimiterMode */
+		break;
+	case 2:
+		se200pci_WM8776_write(ice, 0x10, 0x1fb);
+		se200pci_WM8776_write(ice, 0x11, 0x100); /* ALCMode */
+		break;
+	}
+}
+
+static void __devinit se200pci_WM8776_init(struct snd_ice1712 *ice)
+{
+	int i;
+	static unsigned short __devinitdata default_values[] = {
+		0x100, 0x100, 0x100,
+		0x100, 0x100, 0x100,
+		0x000, 0x090, 0x000, 0x000,
+		0x022, 0x022, 0x022,
+		0x008, 0x0cf, 0x0cf, 0x07b, 0x000,
+		0x032, 0x000, 0x0a6, 0x001, 0x001
+	};
+
+	se200pci_WM8776_write(ice, 0x17, 0x000); /* reset all */
+	/* ADC and DAC interface is I2S 24bits mode */
+ 	/* The sample-rate are automatically changed */
+	udelay(10);
+	/* BUT my board can not do reset all, so I load all by manually. */
+	for (i = 0; i < ARRAY_SIZE(default_values); i++)
+		se200pci_WM8776_write(ice, i, default_values[i]);
+
+	se200pci_WM8776_set_input_selector(ice, 0);
+	se200pci_WM8776_set_afl(ice, 0);
+	se200pci_WM8776_set_agc(ice, 0);
+	se200pci_WM8776_set_input_volume(ice, 0, 0);
+	se200pci_WM8776_set_output_volume(ice, 0, 0);
+
+	/* head phone mute and power down */
+	se200pci_WM8776_write(ice, 0x00, 0);
+	se200pci_WM8776_write(ice, 0x01, 0);
+	se200pci_WM8776_write(ice, 0x02, 0x100);
+	se200pci_WM8776_write(ice, 0x0d, 0x080);
+}
+
+static void se200pci_WM8776_set_pro_rate(struct snd_ice1712 *ice,
+						unsigned int rate)
+{
+	/* nothing to do */
+}
+
+
+/****************************************************************************/
+/*  runtime interface                                                       */
+/****************************************************************************/
+
+static void se200pci_set_pro_rate(struct snd_ice1712 *ice, unsigned int rate)
+{
+	se200pci_WM8740_set_pro_rate(ice, rate);
+	se200pci_WM8766_set_pro_rate(ice, rate);
+	se200pci_WM8776_set_pro_rate(ice, rate);
+}
+
+struct se200pci_control {
+	char *name;
+	enum {
+		WM8766,
+		WM8776in,
+		WM8776out,
+		WM8776sel,
+		WM8776agc,
+		WM8776afl
+	} target;
+	enum { VOLUME1, VOLUME2, BOOLEAN, ENUM } type;
+	int ch;
+	const char **member;
+	const char *comment;
+};
+
+static const struct se200pci_control se200pci_cont[] = {
+	{
+		.name = "Front Playback Volume",
+		.target = WM8776out,
+		.type = VOLUME1,
+		.comment = "Front(green)"
+	},
+	{
+		.name = "Side Playback Volume",
+		.target = WM8766,
+		.type = VOLUME1,
+		.ch = 1,
+		.comment = "Surround(orange)"
+	},
+	{
+		.name = "Surround Playback Volume",
+		.target = WM8766,
+		.type = VOLUME1,
+		.ch = 2,
+		.comment = "SurroundBack(white)"
+	},
+	{
+		.name = "CLFE Playback Volume",
+		.target = WM8766,
+		.type = VOLUME1,
+		.ch = 0,
+		.comment = "Center(Lch)&SubWoofer(Rch)(black)"
+	},
+	{
+		.name = "Capture Volume",
+		.target = WM8776in,
+		.type = VOLUME2
+	},
+	{
+		.name = "Capture Select",
+		.target = WM8776sel,
+		.type = ENUM,
+		.member = se200pci_sel
+	},
+	{
+		.name = "AGC Capture Mode",
+		.target = WM8776agc,
+		.type = ENUM,
+		.member = se200pci_agc
+	},
+	{
+		.name = "AFL Bypass Playback Switch",
+		.target = WM8776afl,
+		.type = BOOLEAN
+	}
+};
+
+static int se200pci_cont_info(struct snd_kcontrol *kc,
+				struct snd_ctl_elem_info *uinfo)
+{
+	struct snd_ice1712 *ice;
+	int n;
+	int c;
+	const char **member;
+
+	ice = snd_kcontrol_chip(kc);
+	n = kc->private_value;
+
+	if (se200pci_cont[n].type == VOLUME1 ||
+	    se200pci_cont[n].type == VOLUME2) {
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+		uinfo->count = 2;
+		uinfo->value.integer.min = 0; /* mute */
+		uinfo->value.integer.max = 0xff; /* 0dB */
+
+	} else if (se200pci_cont[n].type == BOOLEAN) {
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+		uinfo->count = 1;
+		uinfo->value.integer.min = 0;
+		uinfo->value.integer.max = 1;
+
+	} else if (se200pci_cont[n].type == ENUM) {
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+		member = se200pci_cont[n].member;
+		if (member == NULL)
+			return -EINVAL;
+		for (c = 0; member[c]; c++)
+			;
+
+		uinfo->count = 1;
+		uinfo->value.enumerated.items = c;
+		if (uinfo->value.enumerated.item >= c)
+			uinfo->value.enumerated.item = c - 1;
+		strcpy(uinfo->value.enumerated.name,
+			member[uinfo->value.enumerated.item]);
+	}
+
+	return 0;
+}
+
+static int se200pci_cont_get(struct snd_kcontrol *kc,
+				struct snd_ctl_elem_value *uc)
+{
+	struct snd_ice1712 *ice;
+	int n;
+
+	ice = snd_kcontrol_chip(kc);
+	n = kc->private_value;
+	if (se200pci_cont[n].type == VOLUME1 ||
+	    se200pci_cont[n].type == VOLUME2) {
+		uc->value.integer.value[0] = ice->spec.se.vol[n].ch1;
+		uc->value.integer.value[1] = ice->spec.se.vol[n].ch2;
+
+	} else if (se200pci_cont[n].type == BOOLEAN ||
+		   se200pci_cont[n].type == ENUM)
+		uc->value.integer.value[0] = ice->spec.se.vol[n].ch1;
+
+	return 0;
+}
+
+static int se200pci_cont_put(struct snd_kcontrol *kc,
+				struct snd_ctl_elem_value *uc)
+{
+	struct snd_ice1712 *ice;
+	int n;
+	unsigned int vol1, vol2;
+	int changed;
+
+	ice = snd_kcontrol_chip(kc);
+	n = kc->private_value;
+
+	changed = 0;
+	vol1 = 0; vol2 = 0;
+	if (se200pci_cont[n].type == VOLUME1 ||
+	    se200pci_cont[n].type == VOLUME2) {
+		vol1 = uc->value.integer.value[0];
+		vol2 = uc->value.integer.value[1];
+		if (ice->spec.se.vol[n].ch1 != vol1)
+			changed = 1;
+		if (ice->spec.se.vol[n].ch2 != vol2)
+			changed = 1;
+		ice->spec.se.vol[n].ch1 = vol1;
+		ice->spec.se.vol[n].ch2 = vol2;
+
+	} else if (se200pci_cont[n].type == BOOLEAN ||
+		   se200pci_cont[n].type == ENUM) {
+		vol1 = uc->value.integer.value[0];
+		if (ice->spec.se.vol[n].ch1 != vol1)
+			changed = 1;
+		ice->spec.se.vol[n].ch1 = vol1;
+	}
+
+	switch (se200pci_cont[n].target) {
+	case WM8766:
+		se200pci_WM8766_set_volume(ice,
+			se200pci_cont[n].ch, vol1, vol2);
+		break;
+
+	case WM8776in:
+		se200pci_WM8776_set_input_volume(ice, vol1, vol2);
+		break;
+
+	case WM8776out:
+		se200pci_WM8776_set_output_volume(ice, vol1, vol2);
+		break;
+
+	case WM8776sel:
+		se200pci_WM8776_set_input_selector(ice, vol1);
+		break;
+
+	case WM8776agc:
+		se200pci_WM8776_set_agc(ice, vol1);
+		break;
+
+	case WM8776afl:
+		se200pci_WM8776_set_afl(ice, vol1);
+		break;
+
+	default:
+		break;
+	}
+
+	return changed;
+}
+
+static const DECLARE_TLV_DB_SCALE(db_scale_gain1, -12750, 50, 1);
+static const DECLARE_TLV_DB_SCALE(db_scale_gain2, -10350, 50, 1);
+
+static int __devinit se200pci_add_controls(struct snd_ice1712 *ice)
+{
+	int i;
+	struct snd_kcontrol_new cont;
+	int err;
+
+	memset(&cont, 0, sizeof(cont));
+	cont.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	cont.info = se200pci_cont_info;
+	cont.get = se200pci_cont_get;
+	cont.put = se200pci_cont_put;
+	for (i = 0; i < ARRAY_SIZE(se200pci_cont); i++) {
+		cont.private_value = i;
+		cont.name = se200pci_cont[i].name;
+		cont.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;
+		cont.tlv.p = NULL;
+		if (se200pci_cont[i].type == VOLUME1 ||
+		    se200pci_cont[i].type == VOLUME2) {
+
+			cont.access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;
+
+			if (se200pci_cont[i].type == VOLUME1)
+				cont.tlv.p = db_scale_gain1;
+			else
+				cont.tlv.p = db_scale_gain2;
+		}
+		err = snd_ctl_add(ice->card, snd_ctl_new1(&cont, ice));
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+
+/****************************************************************************/
+/*  ONKYO WAVIO SE-90PCI                                                    */
+/****************************************************************************/
+/*
+ *  system configuration ICE_EEP2_SYSCONF=0x4b
+ *  AC-Link configuration ICE_EEP2_ACLINK=0x80
+ *  I2S converters feature ICE_EEP2_I2S=0x78
+ *  S/PDIF configuration ICE_EEP2_SPDIF=0xc3
+ *
+ *  ** connected chip **
+ *
+ *   WM8716
+ *      A 2ch-DAC of main outputs.
+ *      It setuped as I2S mode by wire, so no way to setup from software.
+ *         ML/I2S (28pin) -- +5V
+ *         MC/DM1 (27pin) -- GND
+ *         MC/DM0 (26pin) -- GND
+ *         MUTEB  (25pin) -- open (internal pull-up)
+ *         MODE   (24pin) -- GND
+ *         CSBIWO (23pin) -- +5V
+ *
+ */
+
+ /* Nothing to do for this chip. */
+
+
+/****************************************************************************/
+/*  probe/initialize/setup                                                  */
+/****************************************************************************/
+
+static int __devinit se_init(struct snd_ice1712 *ice)
+{
+	if (ice->eeprom.subvendor == VT1724_SUBDEVICE_SE90PCI) {
+		ice->num_total_dacs = 2;
+		ice->num_total_adcs = 0;
+		ice->vt1720 = 1;
+		return 0;
+
+	} else if (ice->eeprom.subvendor == VT1724_SUBDEVICE_SE200PCI) {
+		ice->num_total_dacs = 8;
+		ice->num_total_adcs = 2;
+		se200pci_WM8740_init(ice);
+		se200pci_WM8766_init(ice);
+		se200pci_WM8776_init(ice);
+		ice->gpio.set_pro_rate = se200pci_set_pro_rate;
+		return 0;
+	}
+
+	return -ENOENT;
+}
+
+static int __devinit se_add_controls(struct snd_ice1712 *ice)
+{
+	int err;
+
+	err = 0;
+	/* nothing to do for VT1724_SUBDEVICE_SE90PCI */
+	if (ice->eeprom.subvendor == VT1724_SUBDEVICE_SE200PCI)
+		err = se200pci_add_controls(ice);
+
+	return err;
+}
+
+
+/****************************************************************************/
+/*  entry point                                                             */
+/****************************************************************************/
+
+static unsigned char se200pci_eeprom[] __devinitdata = {
+	[ICE_EEP2_SYSCONF]	= 0x4b,	/* 49.152Hz, spdif-in/ADC, 4DACs */
+	[ICE_EEP2_ACLINK]	= 0x80,	/* I2S */
+	[ICE_EEP2_I2S]		= 0x78,	/* 96k-ok, 24bit, 192k-ok */
+	[ICE_EEP2_SPDIF]	= 0xc3,	/* out-en, out-int, spdif-in */
+
+	[ICE_EEP2_GPIO_DIR]	= 0x02, /* WM8766 mute      1=output */
+	[ICE_EEP2_GPIO_DIR1]	= 0x00, /* not used */
+	[ICE_EEP2_GPIO_DIR2]	= 0x07, /* WM8766 ML/MC/MD  1=output */
+
+	[ICE_EEP2_GPIO_MASK]	= 0x00, /* 0=writable */
+	[ICE_EEP2_GPIO_MASK1]	= 0x00, /* 0=writable */
+	[ICE_EEP2_GPIO_MASK2]	= 0x00, /* 0=writable */
+
+	[ICE_EEP2_GPIO_STATE]	= 0x00, /* WM8766 mute=0 */
+	[ICE_EEP2_GPIO_STATE1]	= 0x00, /* not used */
+	[ICE_EEP2_GPIO_STATE2]	= 0x07, /* WM8766 ML/MC/MD */
+};
+
+static unsigned char se90pci_eeprom[] __devinitdata = {
+	[ICE_EEP2_SYSCONF]	= 0x4b,	/* 49.152Hz, spdif-in/ADC, 4DACs */
+	[ICE_EEP2_ACLINK]	= 0x80,	/* I2S */
+	[ICE_EEP2_I2S]		= 0x78,	/* 96k-ok, 24bit, 192k-ok */
+	[ICE_EEP2_SPDIF]	= 0xc3,	/* out-en, out-int, spdif-in */
+
+	/* ALL GPIO bits are in input mode */
+};
+
+struct snd_ice1712_card_info snd_vt1724_se_cards[] __devinitdata = {
+	{
+		.subvendor = VT1724_SUBDEVICE_SE200PCI,
+		.name = "ONKYO SE200PCI",
+		.model = "se200pci",
+		.chip_init = se_init,
+		.build_controls = se_add_controls,
+		.eeprom_size = sizeof(se200pci_eeprom),
+		.eeprom_data = se200pci_eeprom,
+	},
+	{
+		.subvendor = VT1724_SUBDEVICE_SE90PCI,
+		.name = "ONKYO SE90PCI",
+		.model = "se90pci",
+		.chip_init = se_init,
+		.build_controls = se_add_controls,
+		.eeprom_size = sizeof(se90pci_eeprom),
+		.eeprom_data = se90pci_eeprom,
+	},
+	{} /*terminator*/
+};
