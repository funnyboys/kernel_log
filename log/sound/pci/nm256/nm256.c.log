commit fb95aae6e67c4e319a24b3eea32032d4246a5335
Merge: bd2463ac7d7e 90fb04f890bc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 28 16:26:57 2020 -0800

    Merge tag 'sound-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "As the diffstat shows we've had again a lot of works done for this
      cycle: the majority of changes are the continued componentization and
      code refactoring in ASoC, the tree-wide PCM API updates and cleanups
      and SOF updates while a few ASoC driver updates are seen, too.
    
      Here we go, some highlights:
    
      Core:
       - Finally y2038 support landed to ALSA ABI; some ioctls have been
         extended and lots of tricks were applied
       - Applying the new managed PCM buffer API to all drivers; the API
         itself was already merged in 5.5
       - The already deprecated dimension support in ALSA control API is
         dropped completely now
       - Verification of ALSA control elements to catch API misuses
    
      ASoC:
       - Further code refactorings and moving things to the component level
       - Lots of updates and improvements on SOF / Intel drivers; now
         including common HDMI driver and SoundWire support
       - New driver support for Ingenic JZ4770, Mediatek MT6660, Qualcomm
         WCD934x and WSA881x, and Realtek RT700, RT711, RT715, RT1011,
         RT1015 and RT1308
    
      HD-audio:
       - Improved ring-buffer communications using waitqueue
       - Drop the superfluous buffer preallocation on x86
    
      Others:
       - Many code cleanups, mostly constifications over the whole tree
       - USB-audio: quirks for MOTU, Corsair Virtuoso, Line6 Helix
       - FireWire: code refactoring for oxfw and dice drivers"
    
    * tag 'sound-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (638 commits)
      ALSA: usb-audio: add quirks for Line6 Helix devices fw>=2.82
      ALSA: hda: Add Clevo W65_67SB the power_save blacklist
      ASoC: soc-core: remove null_snd_soc_ops
      ASoC: soc-pcm: add soc_rtd_trigger()
      ASoC: soc-pcm: add soc_rtd_hw_free()
      ASoC: soc-pcm: add soc_rtd_hw_params()
      ASoC: soc-pcm: add soc_rtd_prepare()
      ASoC: soc-pcm: add soc_rtd_shutdown()
      ASoC: soc-pcm: add soc_rtd_startup()
      ASoC: rt1015: add rt1015 amplifier driver
      ASoC: madera: Correct some kernel doc
      ASoC: topology: fix soc_tplg_fe_link_create() - link->dobj initialization order
      ASoC: Intel: skl_hda_dsp_common: Fix global-out-of-bounds bug
      ASoC: madera: Correct DMIC only input hook ups
      ALSA: cs46xx: fix spelling mistake "to" -> "too"
      ALSA: hda - Add docking station support for Lenovo Thinkpad T420s
      ASoC: Add MediaTek MT6660 Speaker Amp Driver
      ASoC: dt-bindings: rt5645: add suppliers
      ASoC: max98090: fix deadlock in max98090_dapm_put_enum_double()
      ASoC: dapm: add snd_soc_dapm_put_enum_double_locked
      ...

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 1201c9c95660..77c683d19fbf 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1353,7 +1353,7 @@ snd_nm256_peek_for_sig(struct nm256 *chip)
 	unsigned long pointer_found = chip->buffer_end - 0x1400;
 	u32 sig;
 
-	temp = ioremap_nocache(chip->buffer_addr + chip->buffer_end - 0x400, 16);
+	temp = ioremap(chip->buffer_addr + chip->buffer_end - 0x400, 16);
 	if (temp == NULL) {
 		dev_err(chip->card->dev,
 			"Unable to scan for card signature in video RAM\n");
@@ -1518,7 +1518,7 @@ snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 		err = -EBUSY;
 		goto __error;
 	}
-	chip->cport = ioremap_nocache(chip->cport_addr, NM_PORT2_SIZE);
+	chip->cport = ioremap(chip->cport_addr, NM_PORT2_SIZE);
 	if (chip->cport == NULL) {
 		dev_err(card->dev, "unable to map control port %lx\n",
 			chip->cport_addr);
@@ -1589,7 +1589,7 @@ snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 		err = -EBUSY;
 		goto __error;
 	}
-	chip->buffer = ioremap_nocache(chip->buffer_addr, chip->buffer_size);
+	chip->buffer = ioremap(chip->buffer_addr, chip->buffer_size);
 	if (chip->buffer == NULL) {
 		err = -ENOMEM;
 		dev_err(card->dev, "unable to map ring buffer at %lx\n",

commit ccfacf2b2ee49962452b8d7bd104047d681f0555
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:42 2020 +0100

    ALSA: nm256: More constifications
    
    Apply const prefix to the static tables coefs and init registers.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-28-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 25275a98e950..1726f2959ae8 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -299,7 +299,7 @@ snd_nm256_writel(struct nm256 *chip, int offset, u32 val)
 }
 
 static inline void
-snd_nm256_write_buffer(struct nm256 *chip, void *src, int offset, int size)
+snd_nm256_write_buffer(struct nm256 *chip, const void *src, int offset, int size)
 {
 	offset -= chip->buffer_start;
 #ifdef CONFIG_SND_DEBUG
@@ -1179,7 +1179,7 @@ struct initialValues {
 	unsigned short value;
 };
 
-static struct initialValues nm256_ac97_init_val[] =
+static const struct initialValues nm256_ac97_init_val[] =
 {
 	{ AC97_MASTER, 		0x8000 },
 	{ AC97_HEADPHONE,	0x8000 },

commit 88e540a8764ec0f5fb4a1185fbeb7827fefd3601
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:17:14 2020 +0100

    ALSA: pci: Constify snd_pci_quirk tables
    
    The snd_pci_quirk tables are referred as read-only, hence they can be
    declared as const gracefully.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-59-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 99228b93b3c6..25275a98e950 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1634,7 +1634,7 @@ snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 
 enum { NM_BLACKLISTED, NM_RESET_WORKAROUND, NM_RESET_WORKAROUND_2 };
 
-static struct snd_pci_quirk nm256_quirks[] = {
+static const struct snd_pci_quirk nm256_quirks[] = {
 	/* HP omnibook 4150 has cs4232 codec internally */
 	SND_PCI_QUIRK(0x103c, 0x0007, "HP omnibook 4150", NM_BLACKLISTED),
 	/* Reset workarounds to avoid lock-ups */

commit 51055da51d1e92bb089c9b9e0ecb1be69396f808
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:43 2020 +0100

    ALSA: pci: Constify snd_ac97_bus_ops definitions
    
    Now snd_ac97_bus() takes the const ops pointer, so we can define the
    snd_ac97_bus_ops locally as const as well for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-28-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 003a09788572..99228b93b3c6 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1309,7 +1309,7 @@ snd_nm256_mixer(struct nm256 *chip)
 	struct snd_ac97_bus *pbus;
 	struct snd_ac97_template ac97;
 	int err;
-	static struct snd_ac97_bus_ops ops = {
+	static const struct snd_ac97_bus_ops ops = {
 		.reset = snd_nm256_ac97_reset,
 		.write = snd_nm256_ac97_write,
 		.read = snd_nm256_ac97_read,

commit efb0ad25d370344e61bb4fca8c3b9c3c6047922e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:25 2020 +0100

    ALSA: pci: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 5da28b0adbd9..003a09788572 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1471,7 +1471,7 @@ snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 {
 	struct nm256 *chip;
 	int err, pval;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free =	snd_nm256_dev_free,
 	};
 	u32 addr;

commit c1c3981fa16688e02f629a4805c9188679b132e9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:17 2020 +0100

    ALSA: pci: Constify snd_pcm_hardware definitions
    
    Most of snd_pcm_hardware definitions are just copied to another object
    as-is, hence we can define them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-2-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index ac194485aa78..5da28b0adbd9 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -785,7 +785,7 @@ snd_nm256_capture_update(struct nm256 *chip)
 /*
  * hardware info
  */
-static struct snd_pcm_hardware snd_nm256_playback =
+static const struct snd_pcm_hardware snd_nm256_playback =
 {
 	.info =			SNDRV_PCM_INFO_MMAP_IOMEM |SNDRV_PCM_INFO_MMAP_VALID |
 				SNDRV_PCM_INFO_INTERLEAVED |
@@ -804,7 +804,7 @@ static struct snd_pcm_hardware snd_nm256_playback =
 	.period_bytes_max =	128 * 1024,
 };
 
-static struct snd_pcm_hardware snd_nm256_capture =
+static const struct snd_pcm_hardware snd_nm256_capture =
 {
 	.info =			SNDRV_PCM_INFO_MMAP_IOMEM | SNDRV_PCM_INFO_MMAP_VALID |
 				SNDRV_PCM_INFO_INTERLEAVED |
@@ -838,7 +838,7 @@ static int snd_nm256_pcm_hw_params(struct snd_pcm_substream *substream,
  */
 static void snd_nm256_setup_stream(struct nm256 *chip, struct nm256_stream *s,
 				   struct snd_pcm_substream *substream,
-				   struct snd_pcm_hardware *hw_ptr)
+				   const struct snd_pcm_hardware *hw_ptr)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 

commit 1478eb63654b367399f79edc0734a3bda1b0324b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:27 2019 +0100

    ALSA: nm256: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation.  It's cleared and reset dynamically at IRQ re-acquiring for
    the PM resume, too.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-29-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 02767f33deb7..ac194485aa78 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -460,6 +460,7 @@ static int snd_nm256_acquire_irq(struct nm256 *chip)
 			return -EBUSY;
 		}
 		chip->irq = chip->pci->irq;
+		chip->card->sync_irq = chip->irq;
 	}
 	chip->irq_acks++;
 	mutex_unlock(&chip->irq_mutex);
@@ -475,6 +476,7 @@ static void snd_nm256_release_irq(struct nm256 *chip)
 	if (chip->irq_acks == 0 && chip->irq >= 0) {
 		free_irq(chip->irq, chip);
 		chip->irq = -1;
+		chip->card->sync_irq = -1;
 	}
 	mutex_unlock(&chip->irq_mutex);
 }

commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 1201c9c95660..02767f33deb7 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -906,7 +906,6 @@ snd_nm256_capture_close(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_nm256_playback_ops = {
 	.open =		snd_nm256_playback_open,
 	.close =	snd_nm256_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_nm256_pcm_hw_params,
 	.prepare =	snd_nm256_pcm_prepare,
 	.trigger =	snd_nm256_playback_trigger,
@@ -922,7 +921,6 @@ static const struct snd_pcm_ops snd_nm256_playback_ops = {
 static const struct snd_pcm_ops snd_nm256_capture_ops = {
 	.open =		snd_nm256_capture_open,
 	.close =	snd_nm256_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_nm256_pcm_hw_params,
 	.prepare =	snd_nm256_pcm_prepare,
 	.trigger =	snd_nm256_capture_trigger,

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 85e46ff44ac3..1201c9c95660 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /* 
  * Driver for NeoMagic 256AV and 256ZX chipsets.
  * Copyright (c) 2000 by Takashi Iwai <tiwai@suse.de>
@@ -7,21 +8,6 @@
  * so I just put my acknoledgment to him/her here.
  * The original author's web page is found at
  *	http://www.uglx.org/sony.html
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
   
 #include <linux/io.h>

commit 17bc4815de586d001c82d0ddf75247283c3f002a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:02:51 2019 +0100

    ALSA: pci: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index b97f4ea6b56c..85e46ff44ac3 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1413,7 +1413,6 @@ static int nm256_suspend(struct device *dev)
 	struct nm256 *chip = card->private_data;
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
-	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
 	chip->coeffs_current = 0;
 	return 0;

commit 5d3806eea2dd19b083c729a32aded6d012ead5ae
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Thu Aug 24 11:55:28 2017 +0530

    ALSA: nm256: constify snd_ac97_res_table
    
    snd_ac97_res_table are not supposed to change at runtime. All functions
    working with snd_ac97_res_table provided by <sound/ac97_codec.h> work with
    const snd_ac97_res_table. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 0ef8054c3936..b97f4ea6b56c 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1271,7 +1271,7 @@ snd_nm256_ac97_write(struct snd_ac97 *ac97,
 }
 
 /* static resolution table */
-static struct snd_ac97_res_table nm256_res_table[] = {
+static const struct snd_ac97_res_table nm256_res_table[] = {
 	{ AC97_MASTER, 0x1f1f },
 	{ AC97_HEADPHONE, 0x1f1f },
 	{ AC97_MASTER_MONO, 0x001f },

commit 3f2bdc45f36df349d9f9984252b612c57a8b1a73
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 7 14:21:49 2017 +0200

    ALSA: nm256: Constify hw_constraints
    
    snd_pcm_hw_constraint_list(), *_ratnums() and *_ratdens() receive the
    const pointers.  Constify the corresponding static objects for better
    hardening.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 63f0985dae27..0ef8054c3936 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -398,10 +398,10 @@ snd_nm256_load_coefficient(struct nm256 *chip, int stream, int number)
 
 
 /* The actual rates supported by the card. */
-static unsigned int samplerates[8] = {
+static const unsigned int samplerates[8] = {
 	8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000,
 };
-static struct snd_pcm_hw_constraint_list constraints_rates = {
+static const struct snd_pcm_hw_constraint_list constraints_rates = {
 	.count = ARRAY_SIZE(samplerates), 
 	.list = samplerates,
 	.mask = 0,

commit 21de5673663f2620fa2838e4e2ea5db9c91fad4d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 10 20:25:17 2017 +0200

    ALSA: nm256: Convert to new PCM copy ops
    
    Replace the copy and the silence ops with the new ops.
    The conversion is straightforward with standard helper functions, and
    now we can drop the bytes <-> frames conversions in callbacks.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 103fe311e5a9..63f0985dae27 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -695,53 +695,68 @@ snd_nm256_capture_pointer(struct snd_pcm_substream *substream)
  */
 static int
 snd_nm256_playback_silence(struct snd_pcm_substream *substream,
-			   int channel, /* not used (interleaved data) */
-			   snd_pcm_uframes_t pos,
-			   snd_pcm_uframes_t count)
+			   int channel, unsigned long pos, unsigned long count)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct nm256_stream *s = runtime->private_data;
-	count = frames_to_bytes(runtime, count);
-	pos = frames_to_bytes(runtime, pos);
+
 	memset_io(s->bufptr + pos, 0, count);
 	return 0;
 }
 
 static int
 snd_nm256_playback_copy(struct snd_pcm_substream *substream,
-			int channel, /* not used (interleaved data) */
-			snd_pcm_uframes_t pos,
-			void __user *src,
-			snd_pcm_uframes_t count)
+			int channel, unsigned long pos,
+			void __user *src, unsigned long count)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct nm256_stream *s = runtime->private_data;
-	count = frames_to_bytes(runtime, count);
-	pos = frames_to_bytes(runtime, pos);
+
 	if (copy_from_user_toio(s->bufptr + pos, src, count))
 		return -EFAULT;
 	return 0;
 }
 
+static int
+snd_nm256_playback_copy_kernel(struct snd_pcm_substream *substream,
+			       int channel, unsigned long pos,
+			       void *src, unsigned long count)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct nm256_stream *s = runtime->private_data;
+
+	memcpy_toio(s->bufptr + pos, src, count);
+	return 0;
+}
+
 /*
  * copy to user
  */
 static int
 snd_nm256_capture_copy(struct snd_pcm_substream *substream,
-		       int channel, /* not used (interleaved data) */
-		       snd_pcm_uframes_t pos,
-		       void __user *dst,
-		       snd_pcm_uframes_t count)
+		       int channel, unsigned long pos,
+		       void __user *dst, unsigned long count)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct nm256_stream *s = runtime->private_data;
-	count = frames_to_bytes(runtime, count);
-	pos = frames_to_bytes(runtime, pos);
+
 	if (copy_to_user_fromio(dst, s->bufptr + pos, count))
 		return -EFAULT;
 	return 0;
 }
 
+static int
+snd_nm256_capture_copy_kernel(struct snd_pcm_substream *substream,
+			      int channel, unsigned long pos,
+			      void *dst, unsigned long count)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct nm256_stream *s = runtime->private_data;
+
+	memcpy_fromio(dst, s->bufptr + pos, count);
+	return 0;
+}
+
 #endif /* !__i386__ */
 
 
@@ -911,8 +926,9 @@ static const struct snd_pcm_ops snd_nm256_playback_ops = {
 	.trigger =	snd_nm256_playback_trigger,
 	.pointer =	snd_nm256_playback_pointer,
 #ifndef __i386__
-	.copy =		snd_nm256_playback_copy,
-	.silence =	snd_nm256_playback_silence,
+	.copy_user =	snd_nm256_playback_copy,
+	.copy_kernel =	snd_nm256_playback_copy_kernel,
+	.fill_silence =	snd_nm256_playback_silence,
 #endif
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
@@ -926,7 +942,8 @@ static const struct snd_pcm_ops snd_nm256_capture_ops = {
 	.trigger =	snd_nm256_capture_trigger,
 	.pointer =	snd_nm256_capture_pointer,
 #ifndef __i386__
-	.copy =		snd_nm256_capture_copy,
+	.copy_user =	snd_nm256_capture_copy,
+	.copy_kernel =	snd_nm256_capture_copy_kernel,
 #endif
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 4735e27cc773..103fe311e5a9 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -902,7 +902,7 @@ snd_nm256_capture_close(struct snd_pcm_substream *substream)
 /*
  * create a pcm instance
  */
-static struct snd_pcm_ops snd_nm256_playback_ops = {
+static const struct snd_pcm_ops snd_nm256_playback_ops = {
 	.open =		snd_nm256_playback_open,
 	.close =	snd_nm256_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -917,7 +917,7 @@ static struct snd_pcm_ops snd_nm256_playback_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static struct snd_pcm_ops snd_nm256_capture_ops = {
+static const struct snd_pcm_ops snd_nm256_capture_ops = {
 	.open =		snd_nm256_capture_open,
 	.close =	snd_nm256_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 90674b93b930..4735e27cc773 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -24,7 +24,7 @@
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
   
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>

commit 9e5947465d72ef1b3a88104474ab2adf78837220
Merge: 624afe4dc9a0 3e41c9b5a1ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 11 11:26:48 2015 +0100

    Merge branch 'topic/pci-cleanup' into for-next

commit fc9b6061cf9c42460e482f7a5947ee8120ff0960
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 8 12:49:03 2015 +0100

    ALSA: nm256: Simplify PM callbacks
    
    This is a similar cleanup like the commit [3db084fd0af5: ALSA: fm801:
    PCI core handles power state for us].
    
    Since pci_set_power_state(), pci_save_state() and pci_restore_state()
    are already done in the PCI core side, so we don't need to it doubly.
    
    Also, pci_enable_device(), pci_disable_device() and pci_set_master()
    calls in PM callbacks are superfluous nowadays, too, so get rid of
    them as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 4e41a4e29a1e..8598f2b47eb3 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1392,7 +1392,6 @@ snd_nm256_peek_for_sig(struct nm256 *chip)
  */
 static int nm256_suspend(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct nm256 *chip = card->private_data;
 
@@ -1400,15 +1399,11 @@ static int nm256_suspend(struct device *dev)
 	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
 	chip->coeffs_current = 0;
-	pci_disable_device(pci);
-	pci_save_state(pci);
-	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
 static int nm256_resume(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct nm256 *chip = card->private_data;
 	int i;
@@ -1416,15 +1411,6 @@ static int nm256_resume(struct device *dev)
 	/* Perform a full reset on the hardware */
 	chip->in_resume = 1;
 
-	pci_set_power_state(pci, PCI_D0);
-	pci_restore_state(pci);
-	if (pci_enable_device(pci) < 0) {
-		dev_err(dev, "pci_enable_device failed, disabling device\n");
-		snd_card_disconnect(card);
-		return -EIO;
-	}
-	pci_set_master(pci);
-
 	snd_nm256_init_chip(chip);
 
 	/* restore ac97 */

commit ff6defa6a8fae12205d64f55db395b1fcf35af8e
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jan 3 22:55:54 2015 +0100

    ALSA: Deletion of checks before the function call "iounmap"
    
    The iounmap() function performs also input parameter validation.
    Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 4e41a4e29a1e..3f52a44143a5 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1460,10 +1460,8 @@ static int snd_nm256_free(struct nm256 *chip)
 	if (chip->irq >= 0)
 		free_irq(chip->irq, chip);
 
-	if (chip->cport)
-		iounmap(chip->cport);
-	if (chip->buffer)
-		iounmap(chip->buffer);
+	iounmap(chip->cport);
+	iounmap(chip->buffer);
 	release_and_free_resource(chip->res_cport);
 	release_and_free_resource(chip->res_buffer);
 

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index ddc60215cc10..4e41a4e29a1e 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -262,7 +262,7 @@ struct nm256 {
 /*
  * PCI ids
  */
-static DEFINE_PCI_DEVICE_TABLE(snd_nm256_ids) = {
+static const struct pci_device_id snd_nm256_ids[] = {
 	{PCI_VDEVICE(NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO), 0},
 	{PCI_VDEVICE(NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO), 0},
 	{PCI_VDEVICE(NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO), 0},

commit a3fe03f412daf40ab39ba0fbd3f78bf1f0d62856
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 17:57:42 2014 +0100

    ALSA: nm256: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index b7afd9c8dcd7..ddc60215cc10 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -318,7 +318,8 @@ snd_nm256_write_buffer(struct nm256 *chip, void *src, int offset, int size)
 	offset -= chip->buffer_start;
 #ifdef CONFIG_SND_DEBUG
 	if (offset < 0 || offset >= chip->buffer_size) {
-		snd_printk(KERN_ERR "write_buffer invalid offset = %d size = %d\n",
+		dev_err(chip->card->dev,
+			"write_buffer invalid offset = %d size = %d\n",
 			   offset, size);
 		return;
 	}
@@ -366,7 +367,8 @@ snd_nm256_load_coefficient(struct nm256 *chip, int stream, int number)
 		 NM_RECORD_REG_OFFSET : NM_PLAYBACK_REG_OFFSET);
 
 	if (snd_nm256_readb(chip, poffset) & 1) {
-		snd_printd("NM256: Engine was enabled while loading coefficients!\n");
+		dev_dbg(chip->card->dev,
+			"NM256: Engine was enabled while loading coefficients!\n");
 		return;
 	}
 
@@ -466,7 +468,8 @@ static int snd_nm256_acquire_irq(struct nm256 *chip)
 	if (chip->irq < 0) {
 		if (request_irq(chip->pci->irq, chip->interrupt, IRQF_SHARED,
 				KBUILD_MODNAME, chip)) {
-			snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->pci->irq);
+			dev_err(chip->card->dev,
+				"unable to grab IRQ %d\n", chip->pci->irq);
 			mutex_unlock(&chip->irq_mutex);
 			return -EBUSY;
 		}
@@ -1039,7 +1042,7 @@ snd_nm256_interrupt(int irq, void *dev_id)
 	if (status & NM_MISC_INT_1) {
 		status &= ~NM_MISC_INT_1;
 		NM_ACK_INT(chip, NM_MISC_INT_1);
-		snd_printd("NM256: Got misc interrupt #1\n");
+		dev_dbg(chip->card->dev, "NM256: Got misc interrupt #1\n");
 		snd_nm256_writew(chip, NM_INT_REG, 0x8000);
 		cbyte = snd_nm256_readb(chip, 0x400);
 		snd_nm256_writeb(chip, 0x400, cbyte | 2);
@@ -1048,14 +1051,15 @@ snd_nm256_interrupt(int irq, void *dev_id)
 	if (status & NM_MISC_INT_2) {
 		status &= ~NM_MISC_INT_2;
 		NM_ACK_INT(chip, NM_MISC_INT_2);
-		snd_printd("NM256: Got misc interrupt #2\n");
+		dev_dbg(chip->card->dev, "NM256: Got misc interrupt #2\n");
 		cbyte = snd_nm256_readb(chip, 0x400);
 		snd_nm256_writeb(chip, 0x400, cbyte & ~2);
 	}
 
 	/* Unknown interrupt. */
 	if (status) {
-		snd_printd("NM256: Fire in the hole! Unknown status 0x%x\n",
+		dev_dbg(chip->card->dev,
+			"NM256: Fire in the hole! Unknown status 0x%x\n",
 			   status);
 		/* Pray. */
 		NM_ACK_INT(chip, status);
@@ -1104,7 +1108,7 @@ snd_nm256_interrupt_zx(int irq, void *dev_id)
 	if (status & NM2_MISC_INT_1) {
 		status &= ~NM2_MISC_INT_1;
 		NM2_ACK_INT(chip, NM2_MISC_INT_1);
-		snd_printd("NM256: Got misc interrupt #1\n");
+		dev_dbg(chip->card->dev, "NM256: Got misc interrupt #1\n");
 		cbyte = snd_nm256_readb(chip, 0x400);
 		snd_nm256_writeb(chip, 0x400, cbyte | 2);
 	}
@@ -1112,14 +1116,15 @@ snd_nm256_interrupt_zx(int irq, void *dev_id)
 	if (status & NM2_MISC_INT_2) {
 		status &= ~NM2_MISC_INT_2;
 		NM2_ACK_INT(chip, NM2_MISC_INT_2);
-		snd_printd("NM256: Got misc interrupt #2\n");
+		dev_dbg(chip->card->dev, "NM256: Got misc interrupt #2\n");
 		cbyte = snd_nm256_readb(chip, 0x400);
 		snd_nm256_writeb(chip, 0x400, cbyte & ~2);
 	}
 
 	/* Unknown interrupt. */
 	if (status) {
-		snd_printd("NM256: Fire in the hole! Unknown status 0x%x\n",
+		dev_dbg(chip->card->dev,
+			"NM256: Fire in the hole! Unknown status 0x%x\n",
 			   status);
 		/* Pray. */
 		NM2_ACK_INT(chip, status);
@@ -1245,7 +1250,7 @@ snd_nm256_ac97_write(struct snd_ac97 *ac97,
 			return;
 		}
 	}
-	snd_printd("nm256: ac97 codec not ready..\n");
+	dev_dbg(chip->card->dev, "nm256: ac97 codec not ready..\n");
 }
 
 /* static resolution table */
@@ -1347,7 +1352,8 @@ snd_nm256_peek_for_sig(struct nm256 *chip)
 
 	temp = ioremap_nocache(chip->buffer_addr + chip->buffer_end - 0x400, 16);
 	if (temp == NULL) {
-		snd_printk(KERN_ERR "Unable to scan for card signature in video RAM\n");
+		dev_err(chip->card->dev,
+			"Unable to scan for card signature in video RAM\n");
 		return -EBUSY;
 	}
 
@@ -1361,12 +1367,14 @@ snd_nm256_peek_for_sig(struct nm256 *chip)
 		if (pointer == 0xffffffff ||
 		    pointer < chip->buffer_size ||
 		    pointer > chip->buffer_end) {
-			snd_printk(KERN_ERR "invalid signature found: 0x%x\n", pointer);
+			dev_err(chip->card->dev,
+				"invalid signature found: 0x%x\n", pointer);
 			iounmap(temp);
 			return -ENODEV;
 		} else {
 			pointer_found = pointer;
-			printk(KERN_INFO "nm256: found card signature in video RAM: 0x%x\n",
+			dev_info(chip->card->dev,
+				 "found card signature in video RAM: 0x%x\n",
 			       pointer);
 		}
 	}
@@ -1411,8 +1419,7 @@ static int nm256_resume(struct device *dev)
 	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
 	if (pci_enable_device(pci) < 0) {
-		printk(KERN_ERR "nm256: pci_enable_device failed, "
-		       "disabling device\n");
+		dev_err(dev, "pci_enable_device failed, disabling device\n");
 		snd_card_disconnect(card);
 		return -EIO;
 	}
@@ -1520,14 +1527,15 @@ snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 	chip->res_cport = request_mem_region(chip->cport_addr, NM_PORT2_SIZE,
 					     card->driver);
 	if (chip->res_cport == NULL) {
-		snd_printk(KERN_ERR "memory region 0x%lx (size 0x%x) busy\n",
+		dev_err(card->dev, "memory region 0x%lx (size 0x%x) busy\n",
 			   chip->cport_addr, NM_PORT2_SIZE);
 		err = -EBUSY;
 		goto __error;
 	}
 	chip->cport = ioremap_nocache(chip->cport_addr, NM_PORT2_SIZE);
 	if (chip->cport == NULL) {
-		snd_printk(KERN_ERR "unable to map control port %lx\n", chip->cport_addr);
+		dev_err(card->dev, "unable to map control port %lx\n",
+			chip->cport_addr);
 		err = -ENOMEM;
 		goto __error;
 	}
@@ -1537,12 +1545,14 @@ snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 		pval = snd_nm256_readw(chip, NM_MIXER_PRESENCE);
 		if ((pval & NM_PRESENCE_MASK) != NM_PRESENCE_VALUE) {
 			if (! force_ac97) {
-				printk(KERN_ERR "nm256: no ac97 is found!\n");
-				printk(KERN_ERR "  force the driver to load by "
-				       "passing in the module parameter\n");
-				printk(KERN_ERR "    force_ac97=1\n");
-				printk(KERN_ERR "  or try sb16, opl3sa2, or "
-				       "cs423x drivers instead.\n");
+				dev_err(card->dev,
+					"no ac97 is found!\n");
+				dev_err(card->dev,
+					"force the driver to load by passing in the module parameter\n");
+				dev_err(card->dev,
+					" force_ac97=1\n");
+				dev_err(card->dev,
+					"or try sb16, opl3sa2, or cs423x drivers instead.\n");
 				err = -ENXIO;
 				goto __error;
 			}
@@ -1581,14 +1591,14 @@ snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 	chip->buffer_start = chip->buffer_end - chip->buffer_size;
 	chip->buffer_addr += chip->buffer_start;
 
-	printk(KERN_INFO "nm256: Mapping port 1 from 0x%x - 0x%x\n",
+	dev_info(card->dev, "Mapping port 1 from 0x%x - 0x%x\n",
 	       chip->buffer_start, chip->buffer_end);
 
 	chip->res_buffer = request_mem_region(chip->buffer_addr,
 					      chip->buffer_size,
 					      card->driver);
 	if (chip->res_buffer == NULL) {
-		snd_printk(KERN_ERR "nm256: buffer 0x%lx (size 0x%x) busy\n",
+		dev_err(card->dev, "buffer 0x%lx (size 0x%x) busy\n",
 			   chip->buffer_addr, chip->buffer_size);
 		err = -EBUSY;
 		goto __error;
@@ -1596,7 +1606,8 @@ snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 	chip->buffer = ioremap_nocache(chip->buffer_addr, chip->buffer_size);
 	if (chip->buffer == NULL) {
 		err = -ENOMEM;
-		snd_printk(KERN_ERR "unable to map ring buffer at %lx\n", chip->buffer_addr);
+		dev_err(card->dev, "unable to map ring buffer at %lx\n",
+			chip->buffer_addr);
 		goto __error;
 	}
 
@@ -1658,12 +1669,12 @@ static int snd_nm256_probe(struct pci_dev *pci,
 
 	q = snd_pci_quirk_lookup(pci, nm256_quirks);
 	if (q) {
-		snd_printdd(KERN_INFO "nm256: Enabled quirk for %s.\n",
+		dev_dbg(&pci->dev, "Enabled quirk for %s.\n",
 			    snd_pci_quirk_name(q));
 		switch (q->value) {
 		case NM_BLACKLISTED:
-			printk(KERN_INFO "nm256: The device is blacklisted. "
-			       "Loading stopped\n");
+			dev_info(&pci->dev,
+				 "The device is blacklisted. Loading stopped\n");
 			return -ENODEV;
 		case NM_RESET_WORKAROUND_2:
 			reset_workaround_2 = 1;
@@ -1689,7 +1700,7 @@ static int snd_nm256_probe(struct pci_dev *pci,
 		strcpy(card->driver, "NM256XL+");
 		break;
 	default:
-		snd_printk(KERN_ERR "invalid device id 0x%x\n", pci->device);
+		dev_err(&pci->dev, "invalid device id 0x%x\n", pci->device);
 		snd_card_free(card);
 		return -EINVAL;
 	}
@@ -1712,12 +1723,12 @@ static int snd_nm256_probe(struct pci_dev *pci,
 	card->private_data = chip;
 
 	if (reset_workaround) {
-		snd_printdd(KERN_INFO "nm256: reset_workaround activated\n");
+		dev_dbg(&pci->dev, "reset_workaround activated\n");
 		chip->reset_workaround = 1;
 	}
 
 	if (reset_workaround_2) {
-		snd_printdd(KERN_INFO "nm256: reset_workaround_2 activated\n");
+		dev_dbg(&pci->dev, "reset_workaround_2 activated\n");
 		chip->reset_workaround_2 = 1;
 	}
 

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index fe79fff4c6dc..b7afd9c8dcd7 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1626,8 +1626,6 @@ snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0)
 		goto __error;
 
-	snd_card_set_dev(card, &pci->dev);
-
 	*chip_ret = chip;
 	return 0;
 
@@ -1676,7 +1674,7 @@ static int snd_nm256_probe(struct pci_dev *pci,
 		}
 	}
 
-	err = snd_card_create(index, id, THIS_MODULE, 0, &card);
+	err = snd_card_new(&pci->dev, index, id, THIS_MODULE, 0, &card);
 	if (err < 0)
 		return err;
 

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 6febedb05936..fe79fff4c6dc 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1746,7 +1746,6 @@ static int snd_nm256_probe(struct pci_dev *pci,
 static void snd_nm256_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 

commit 86b2723725a2e186f5699d97cb20014fa893931f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 25 10:54:07 2013 +0100

    ALSA: Make snd_printd() and snd_printdd() inline
    
    Because currently snd_printd() and snd_printdd() macros are expanded
    to empty when CONFIG_SND_DEBUG=n, a compile warning like below
    appears sometimes, and we had to covert it by ugly ifdefs:
      sound/pci/hda/patch_sigmatel.c: In function ‘stac92hd71bxx_fixup_hp’:
      sound/pci/hda/patch_sigmatel.c:2434:24: warning: unused variable ‘spec’ [-Wunused-variable]
    
    For "fixing" these issues better, this patch replaces snd_printd() and
    snd_printdd() definitions with empty inline functions instead of
    macros.  This should have the same effect but shut up warnings like
    above.
    
    But since we had already put ifdefs, changing to inline functions
    would trigger compile errors.  So, such ifdefs is removed in this
    patch.
    
    In addition, snd_pci_quirk name field is defined only when
    CONFIG_SND_DEBUG_VERBOSE is set, and the reference to it in
    snd_printdd() argument triggers the build errors, too.  For avoiding
    these errors, introduce a new macro snd_pci_quirk_name() that is
    defined no matter how the debug option is set.
    
    Reported-by: Stratos Karafotis <stratosk@semaphore.gr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 563a193e36a3..6febedb05936 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1660,7 +1660,8 @@ static int snd_nm256_probe(struct pci_dev *pci,
 
 	q = snd_pci_quirk_lookup(pci, nm256_quirks);
 	if (q) {
-		snd_printdd(KERN_INFO "nm256: Enabled quirk for %s.\n", q->name);
+		snd_printdd(KERN_INFO "nm256: Enabled quirk for %s.\n",
+			    snd_pci_quirk_name(q));
 		switch (q->value) {
 		case NM_BLACKLISTED:
 			printk(KERN_INFO "nm256: The device is blacklisted. "

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index e80e9a1e84aa..563a193e36a3 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -928,7 +928,7 @@ static struct snd_pcm_ops snd_nm256_capture_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static int __devinit
+static int
 snd_nm256_pcm(struct nm256 *chip, int device)
 {
 	struct snd_pcm *pcm;
@@ -1295,7 +1295,7 @@ snd_nm256_ac97_reset(struct snd_ac97 *ac97)
 }
 
 /* create an ac97 mixer interface */
-static int __devinit
+static int
 snd_nm256_mixer(struct nm256 *chip)
 {
 	struct snd_ac97_bus *pbus;
@@ -1336,7 +1336,7 @@ snd_nm256_mixer(struct nm256 *chip)
  * RAM.
  */
 
-static int __devinit
+static int
 snd_nm256_peek_for_sig(struct nm256 *chip)
 {
 	/* The signature is located 1K below the end of video RAM.  */
@@ -1472,7 +1472,7 @@ static int snd_nm256_dev_free(struct snd_device *device)
 	return snd_nm256_free(chip);
 }
 
-static int __devinit
+static int
 snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 		 struct nm256 **chip_ret)
 {
@@ -1639,7 +1639,7 @@ snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 
 enum { NM_BLACKLISTED, NM_RESET_WORKAROUND, NM_RESET_WORKAROUND_2 };
 
-static struct snd_pci_quirk nm256_quirks[] __devinitdata = {
+static struct snd_pci_quirk nm256_quirks[] = {
 	/* HP omnibook 4150 has cs4232 codec internally */
 	SND_PCI_QUIRK(0x103c, 0x0007, "HP omnibook 4150", NM_BLACKLISTED),
 	/* Reset workarounds to avoid lock-ups */
@@ -1650,8 +1650,8 @@ static struct snd_pci_quirk nm256_quirks[] __devinitdata = {
 };
 
 
-static int __devinit snd_nm256_probe(struct pci_dev *pci,
-				     const struct pci_device_id *pci_id)
+static int snd_nm256_probe(struct pci_dev *pci,
+			   const struct pci_device_id *pci_id)
 {
 	struct snd_card *card;
 	struct nm256 *chip;
@@ -1742,7 +1742,7 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 	return 0;
 }
 
-static void __devexit snd_nm256_remove(struct pci_dev *pci)
+static void snd_nm256_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -1753,7 +1753,7 @@ static struct pci_driver nm256_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_nm256_ids,
 	.probe = snd_nm256_probe,
-	.remove = __devexit_p(snd_nm256_remove),
+	.remove = snd_nm256_remove,
 	.driver = {
 		.pm = NM256_PM_OPS,
 	},

commit c7561cd80469f2fe4a6be0984db57832ee7f2a3b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 14 18:12:04 2012 +0200

    ALSA: PCI: Replace CONFIG_PM with CONFIG_PM_SLEEP
    
    Otherwise we may get compile warnings due to unused functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 465cff25b146..e80e9a1e84aa 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1377,7 +1377,7 @@ snd_nm256_peek_for_sig(struct nm256 *chip)
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 /*
  * APM event handler, so the card is properly reinitialized after a power
  * event.
@@ -1441,7 +1441,7 @@ static SIMPLE_DEV_PM_OPS(nm256_pm, nm256_suspend, nm256_resume);
 #define NM256_PM_OPS	&nm256_pm
 #else
 #define NM256_PM_OPS	NULL
-#endif /* CONFIG_PM */
+#endif /* CONFIG_PM_SLEEP */
 
 static int snd_nm256_free(struct nm256 *chip)
 {

commit 68cb2b559278858ef9f3a7722f95df88797c7840
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 15:20:37 2012 +0200

    ALSA: Convert to new pm_ops for PCI drivers
    
    Straightforward conversion to the new pm_ops from the legacy
    suspend/resume ops.
    
    Since we change vx222, vx_core and vxpocket have to be converted,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 8159b05ee94d..465cff25b146 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1382,9 +1382,10 @@ snd_nm256_peek_for_sig(struct nm256 *chip)
  * APM event handler, so the card is properly reinitialized after a power
  * event.
  */
-static int nm256_suspend(struct pci_dev *pci, pm_message_t state)
+static int nm256_suspend(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct nm256 *chip = card->private_data;
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
@@ -1393,13 +1394,14 @@ static int nm256_suspend(struct pci_dev *pci, pm_message_t state)
 	chip->coeffs_current = 0;
 	pci_disable_device(pci);
 	pci_save_state(pci);
-	pci_set_power_state(pci, pci_choose_state(pci, state));
+	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
-static int nm256_resume(struct pci_dev *pci)
+static int nm256_resume(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct nm256 *chip = card->private_data;
 	int i;
 
@@ -1434,6 +1436,11 @@ static int nm256_resume(struct pci_dev *pci)
 	chip->in_resume = 0;
 	return 0;
 }
+
+static SIMPLE_DEV_PM_OPS(nm256_pm, nm256_suspend, nm256_resume);
+#define NM256_PM_OPS	&nm256_pm
+#else
+#define NM256_PM_OPS	NULL
 #endif /* CONFIG_PM */
 
 static int snd_nm256_free(struct nm256 *chip)
@@ -1747,10 +1754,9 @@ static struct pci_driver nm256_driver = {
 	.id_table = snd_nm256_ids,
 	.probe = snd_nm256_probe,
 	.remove = __devexit_p(snd_nm256_remove),
-#ifdef CONFIG_PM
-	.suspend = nm256_suspend,
-	.resume = nm256_resume,
-#endif
+	.driver = {
+		.pm = NM256_PM_OPS,
+	},
 };
 
 module_pci_driver(nm256_driver);

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index ade2c64bd606..8159b05ee94d 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1742,7 +1742,7 @@ static void __devexit snd_nm256_remove(struct pci_dev *pci)
 }
 
 
-static struct pci_driver driver = {
+static struct pci_driver nm256_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_nm256_ids,
 	.probe = snd_nm256_probe,
@@ -1753,16 +1753,4 @@ static struct pci_driver driver = {
 #endif
 };
 
-
-static int __init alsa_card_nm256_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit alsa_card_nm256_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(alsa_card_nm256_init)
-module_exit(alsa_card_nm256_exit)
+module_pci_driver(nm256_driver);

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index c6c45d979f7a..ade2c64bd606 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -57,12 +57,12 @@ static int index = SNDRV_DEFAULT_IDX1;	/* Index */
 static char *id = SNDRV_DEFAULT_STR1;	/* ID for this card */
 static int playback_bufsize = 16;
 static int capture_bufsize = 16;
-static int force_ac97;			/* disabled as default */
+static bool force_ac97;			/* disabled as default */
 static int buffer_top;			/* not specified */
-static int use_cache;			/* disabled */
-static int vaio_hack;			/* disabled */
-static int reset_workaround;
-static int reset_workaround_2;
+static bool use_cache;			/* disabled */
+static bool vaio_hack;			/* disabled */
+static bool reset_workaround;
+static bool reset_workaround_2;
 
 module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
@@ -86,7 +86,7 @@ module_param(reset_workaround_2, bool, 0444);
 MODULE_PARM_DESC(reset_workaround_2, "Enable extended AC97 RESET workaround for some other laptops.");
 
 /* just for backward compatibility */
-static int enable;
+static bool enable;
 module_param(enable, bool, 0444);
 
 

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 83ea7a7d3eec..c6c45d979f7a 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -30,7 +30,7 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <linux/mutex.h>
 
 #include <sound/core.h>

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index fd19b7f936ba..83ea7a7d3eec 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -465,7 +465,7 @@ static int snd_nm256_acquire_irq(struct nm256 *chip)
 	mutex_lock(&chip->irq_mutex);
 	if (chip->irq < 0) {
 		if (request_irq(chip->pci->irq, chip->interrupt, IRQF_SHARED,
-				chip->card->driver, chip)) {
+				KBUILD_MODNAME, chip)) {
 			snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->pci->irq);
 			mutex_unlock(&chip->irq_mutex);
 			return -EBUSY;

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 5a60492ac7b3..fd19b7f936ba 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1743,7 +1743,7 @@ static void __devexit snd_nm256_remove(struct pci_dev *pci)
 
 
 static struct pci_driver driver = {
-	.name = "NeoMagic 256",
+	.name = KBUILD_MODNAME,
 	.id_table = snd_nm256_ids,
 	.probe = snd_nm256_probe,
 	.remove = __devexit_p(snd_nm256_remove),

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 97a0731331a1..5a60492ac7b3 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -262,7 +262,7 @@ struct nm256 {
 /*
  * PCI ids
  */
-static struct pci_device_id snd_nm256_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_nm256_ids) = {
 	{PCI_VDEVICE(NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO), 0},
 	{PCI_VDEVICE(NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO), 0},
 	{PCI_VDEVICE(NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO), 0},

commit 28d27aae9432c300857722a917be4065c6d7abff
Author: Joe Perches <joe@perches.com>
Date:   Wed Jun 24 22:13:35 2009 -0700

    sound: Use PCI_VDEVICE
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 522a040855d4..97a0731331a1 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -263,9 +263,9 @@ struct nm256 {
  * PCI ids
  */
 static struct pci_device_id snd_nm256_ids[] = {
-	{PCI_VENDOR_ID_NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VDEVICE(NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO), 0},
+	{PCI_VDEVICE(NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO), 0},
+	{PCI_VDEVICE(NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO), 0},
 	{0,},
 };
 

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 50c9f8a05082..522a040855d4 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1668,9 +1668,9 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 		}
 	}
 
-	card = snd_card_new(index, id, THIS_MODULE, 0);
-	if (card == NULL)
-		return -ENOMEM;
+	err = snd_card_create(index, id, THIS_MODULE, 0, &card);
+	if (err < 0)
+		return err;
 
 	switch (pci->device) {
 	case PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO:

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 06d13e717114..50c9f8a05082 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -562,7 +562,8 @@ snd_nm256_playback_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct nm256_stream *s = substream->runtime->private_data;
 	int err = 0;
 
-	snd_assert(s != NULL, return -ENXIO);
+	if (snd_BUG_ON(!s))
+		return -ENXIO;
 
 	spin_lock(&chip->reg_lock);
 	switch (cmd) {
@@ -599,7 +600,8 @@ snd_nm256_capture_trigger(struct snd_pcm_substream *substream, int cmd)
 	struct nm256_stream *s = substream->runtime->private_data;
 	int err = 0;
 
-	snd_assert(s != NULL, return -ENXIO);
+	if (snd_BUG_ON(!s))
+		return -ENXIO;
 
 	spin_lock(&chip->reg_lock);
 	switch (cmd) {
@@ -635,7 +637,8 @@ static int snd_nm256_pcm_prepare(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct nm256_stream *s = runtime->private_data;
 
-	snd_assert(s, return -ENXIO);
+	if (snd_BUG_ON(!s))
+		return -ENXIO;
 	s->dma_size = frames_to_bytes(runtime, substream->runtime->buffer_size);
 	s->period_size = frames_to_bytes(runtime, substream->runtime->period_size);
 	s->periods = substream->runtime->periods;
@@ -660,7 +663,8 @@ snd_nm256_playback_pointer(struct snd_pcm_substream *substream)
 	struct nm256_stream *s = substream->runtime->private_data;
 	unsigned long curp;
 
-	snd_assert(s, return 0);
+	if (snd_BUG_ON(!s))
+		return 0;
 	curp = snd_nm256_readl(chip, NM_PBUFFER_CURRP) - (unsigned long)s->buf;
 	curp %= s->dma_size;
 	return bytes_to_frames(substream->runtime, curp);
@@ -673,7 +677,8 @@ snd_nm256_capture_pointer(struct snd_pcm_substream *substream)
 	struct nm256_stream *s = substream->runtime->private_data;
 	unsigned long curp;
 
-	snd_assert(s != NULL, return 0);
+	if (snd_BUG_ON(!s))
+		return 0;
 	curp = snd_nm256_readl(chip, NM_RBUFFER_CURRP) - (unsigned long)s->buf;
 	curp %= s->dma_size;	
 	return bytes_to_frames(substream->runtime, curp);

commit 80ca9a706b458d09b8cc8d5258bb61957f66ca5e
Author: Milton Miller <miltonm@bga.com>
Date:   Sun Jul 13 13:58:12 2008 +0200

    ALSA: correct kcalloc usage
    
    kcalloc is supposed to be called with the count as its first argument and the
    element size as the second.
    
    Both arguments are size_t so does not affect correctness.  This callsite is
    during module_init and therefore not performance critical.  Another patch will
    optimize the case when the count is variable but the size is fixed.
    
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 7efb838d18a6..06d13e717114 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1302,8 +1302,8 @@ snd_nm256_mixer(struct nm256 *chip)
 		.read = snd_nm256_ac97_read,
 	};
 
-	chip->ac97_regs = kcalloc(sizeof(short),
-				  ARRAY_SIZE(nm256_ac97_init_val), GFP_KERNEL);
+	chip->ac97_regs = kcalloc(ARRAY_SIZE(nm256_ac97_init_val),
+				  sizeof(short), GFP_KERNEL);
 	if (! chip->ac97_regs)
 		return -ENOMEM;
 

commit ebf029da38829ede6b53ac8a5ad45b149064ea16
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 22 17:28:11 2008 +0200

    [ALSA] Fix possible races at free_irq in PCI drivers
    
    The irq handler of PCI drivers must be released before releasing other
    resources since the handler for a shared irq can be still called and
    may access the freed resource again.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 7ac654e381da..7efb838d18a6 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1439,7 +1439,7 @@ static int snd_nm256_free(struct nm256 *chip)
 		snd_nm256_capture_stop(chip);
 
 	if (chip->irq >= 0)
-		synchronize_irq(chip->irq);
+		free_irq(chip->irq, chip);
 
 	if (chip->cport)
 		iounmap(chip->cport);
@@ -1447,8 +1447,6 @@ static int snd_nm256_free(struct nm256 *chip)
 		iounmap(chip->buffer);
 	release_and_free_resource(chip->res_cport);
 	release_and_free_resource(chip->res_buffer);
-	if (chip->irq >= 0)
-		free_irq(chip->irq, chip);
 
 	pci_disable_device(chip->pci);
 	kfree(chip->ac97_regs);

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 276c5763f0e5..7ac654e381da 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -24,7 +24,6 @@
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
   
-#include <sound/driver.h>
 #include <asm/io.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>

commit b83f346bc4d6ab358fd0da85b7eab08bf0234c0b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 13 17:37:55 2007 +0200

    [ALSA] remove incorrect usage of SNDRV_PCM_INFO_SYNC_START and snd_pcm_set_sync()
    
    Set the SNDRV_PCM_INFO_SYNC_START flag and the substream's sync ID
    (only) if the substream actually can be linked to another one.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index c7621bd770a6..276c5763f0e5 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -842,7 +842,6 @@ static void snd_nm256_setup_stream(struct nm256 *chip, struct nm256_stream *s,
 	runtime->private_data = s;
 	s->substream = substream;
 
-	snd_pcm_set_sync(substream);
 	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
 				   &constraints_rates);
 }

commit 4210861964145617cf27b2b9c45860bff3e8290c
Author: Paul Vojta <vojta@math.berkeley.edu>
Date:   Wed Jul 4 10:35:29 2007 +0200

    [ALSA] nm256 - Add mention of opl3sa2 to a diagnostic message
    
    Adds mention of opl3sa2 driver to a diagnostic message for NeoMagic
    nm256 driver.
    
    Signed-off-by: Paul Vojta <vojta@math.berkeley.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 03b3a4792f73..c7621bd770a6 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1533,7 +1533,8 @@ snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 				printk(KERN_ERR "  force the driver to load by "
 				       "passing in the module parameter\n");
 				printk(KERN_ERR "    force_ac97=1\n");
-				printk(KERN_ERR "  or try sb16 or cs423x drivers instead.\n");
+				printk(KERN_ERR "  or try sb16, opl3sa2, or "
+				       "cs423x drivers instead.\n");
 				err = -ENXIO;
 				goto __error;
 			}

commit e2b6d13be4ac3b564ac642a76756f6cf1a7b7b99
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 24 15:36:13 2006 +0100

    [ALSA] nm256 - Use quirk list helper function
    
    Clean up nm256-quirk lookup using snd_pci_quirk_lookup().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 879e31a9f9c6..03b3a4792f73 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1628,23 +1628,15 @@ snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 }
 
 
-struct nm256_quirk {
-	unsigned short vendor;
-	unsigned short device;
-	int type;
-};
-
 enum { NM_BLACKLISTED, NM_RESET_WORKAROUND, NM_RESET_WORKAROUND_2 };
 
-static struct nm256_quirk nm256_quirks[] __devinitdata = {
+static struct snd_pci_quirk nm256_quirks[] __devinitdata = {
 	/* HP omnibook 4150 has cs4232 codec internally */
-	{ .vendor = 0x103c, .device = 0x0007, .type = NM_BLACKLISTED },
-	/* Sony PCG-F305 */
-	{ .vendor = 0x104d, .device = 0x8041, .type = NM_RESET_WORKAROUND },
-	/* Dell Latitude LS */
-	{ .vendor = 0x1028, .device = 0x0080, .type = NM_RESET_WORKAROUND },
-	/* Dell Latitude CSx */
-	{ .vendor = 0x1028, .device = 0x0091, .type = NM_RESET_WORKAROUND_2 },
+	SND_PCI_QUIRK(0x103c, 0x0007, "HP omnibook 4150", NM_BLACKLISTED),
+	/* Reset workarounds to avoid lock-ups */
+	SND_PCI_QUIRK(0x104d, 0x8041, "Sony PCG-F305", NM_RESET_WORKAROUND),
+	SND_PCI_QUIRK(0x1028, 0x0080, "Dell Latitude LS", NM_RESET_WORKAROUND),
+	SND_PCI_QUIRK(0x1028, 0x0091, "Dell Latitude CSx", NM_RESET_WORKAROUND_2),
 	{ } /* terminator */
 };
 
@@ -1655,26 +1647,22 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 	struct snd_card *card;
 	struct nm256 *chip;
 	int err;
-	struct nm256_quirk *q;
-	u16 subsystem_vendor, subsystem_device;
-
-	pci_read_config_word(pci, PCI_SUBSYSTEM_VENDOR_ID, &subsystem_vendor);
-	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &subsystem_device);
-
-	for (q = nm256_quirks; q->vendor; q++) {
-		if (q->vendor == subsystem_vendor && q->device == subsystem_device) {
-			switch (q->type) {
-			case NM_BLACKLISTED:
-				printk(KERN_INFO "nm256: The device is blacklisted. "
-				       "Loading stopped\n");
-				return -ENODEV;
-			case NM_RESET_WORKAROUND_2:
-				reset_workaround_2 = 1;
-				/* Fall-through */
-			case NM_RESET_WORKAROUND:
-				reset_workaround = 1;
-				break;
-			}
+	const struct snd_pci_quirk *q;
+
+	q = snd_pci_quirk_lookup(pci, nm256_quirks);
+	if (q) {
+		snd_printdd(KERN_INFO "nm256: Enabled quirk for %s.\n", q->name);
+		switch (q->value) {
+		case NM_BLACKLISTED:
+			printk(KERN_INFO "nm256: The device is blacklisted. "
+			       "Loading stopped\n");
+			return -ENODEV;
+		case NM_RESET_WORKAROUND_2:
+			reset_workaround_2 = 1;
+			/* Fall-through */
+		case NM_RESET_WORKAROUND:
+			reset_workaround = 1;
+			break;
 		}
 	}
 

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 945d21bf187e..879e31a9f9c6 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -465,7 +465,7 @@ static int snd_nm256_acquire_irq(struct nm256 *chip)
 {
 	mutex_lock(&chip->irq_mutex);
 	if (chip->irq < 0) {
-		if (request_irq(chip->pci->irq, chip->interrupt, IRQF_DISABLED|IRQF_SHARED,
+		if (request_irq(chip->pci->irq, chip->interrupt, IRQF_SHARED,
 				chip->card->driver, chip)) {
 			snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->pci->irq);
 			mutex_unlock(&chip->irq_mutex);

commit 30b35399ceb2398d05837863476dcb12f12f3a82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 11 18:52:53 2006 +0200

    [ALSA] Various fixes for suspend/resume of ALSA PCI drivers
    
    - Check the return value of pci_enable_device() and request_irq()
      in the suspend.  If any error occurs there, disable the device
      using snd_card_disconnect().
    - Call pci_set_power_state() properly with pci_choose_state().
    - Fix the order to call pci_set_power_state().
    - Removed obsolete house-made PM codes in some drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index b1bbdb9e3b7b..945d21bf187e 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1390,6 +1390,7 @@ static int nm256_suspend(struct pci_dev *pci, pm_message_t state)
 	chip->coeffs_current = 0;
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -1401,8 +1402,17 @@ static int nm256_resume(struct pci_dev *pci)
 
 	/* Perform a full reset on the hardware */
 	chip->in_resume = 1;
+
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "nm256: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
+	pci_set_master(pci);
+
 	snd_nm256_init_chip(chip);
 
 	/* restore ac97 */

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 101eee0aa018..b1bbdb9e3b7b 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -236,7 +236,7 @@ struct nm256 {
 
 	int irq;
 	int irq_acks;
-	irqreturn_t (*interrupt)(int, void *, struct pt_regs *);
+	irq_handler_t interrupt;
 	int badintrcount;		/* counter to check bogus interrupts */
 	struct mutex irq_mutex;
 
@@ -1004,7 +1004,7 @@ snd_nm256_intr_check(struct nm256 *chip)
  */
 
 static irqreturn_t
-snd_nm256_interrupt(int irq, void *dev_id, struct pt_regs *dummy)
+snd_nm256_interrupt(int irq, void *dev_id)
 {
 	struct nm256 *chip = dev_id;
 	u16 status;
@@ -1069,7 +1069,7 @@ snd_nm256_interrupt(int irq, void *dev_id, struct pt_regs *dummy)
  */
 
 static irqreturn_t
-snd_nm256_interrupt_zx(int irq, void *dev_id, struct pt_regs *dummy)
+snd_nm256_interrupt_zx(int irq, void *dev_id)
 {
 	struct nm256 *chip = dev_id;
 	u32 status;

commit f40b68903ccd511ea9d658b4bce319dd032a265a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 16:51:05 2006 +0200

    [ALSA] Fix section mismatch errors in ALSA PCI drivers
    
    Fixed 'section mismatch' errors in ALSA PCI drivers:
    - removed invalid __devinitdata from pci id tables
    - fix/remove __devinit of functions called in suspend/resume
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 56d7282e6651..101eee0aa018 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -263,7 +263,7 @@ struct nm256 {
 /*
  * PCI ids
  */
-static struct pci_device_id snd_nm256_ids[] __devinitdata = {
+static struct pci_device_id snd_nm256_ids[] = {
 	{PCI_VENDOR_ID_NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index b92d6600deb9..56d7282e6651 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -465,7 +465,7 @@ static int snd_nm256_acquire_irq(struct nm256 *chip)
 {
 	mutex_lock(&chip->irq_mutex);
 	if (chip->irq < 0) {
-		if (request_irq(chip->pci->irq, chip->interrupt, SA_INTERRUPT|SA_SHIRQ,
+		if (request_irq(chip->pci->irq, chip->interrupt, IRQF_DISABLED|IRQF_SHARED,
 				chip->card->driver, chip)) {
 			snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->pci->irq);
 			mutex_unlock(&chip->irq_mutex);

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index cc297abc9d11..b92d6600deb9 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -263,7 +263,7 @@ struct nm256 {
 /*
  * PCI ids
  */
-static struct pci_device_id snd_nm256_ids[] = {
+static struct pci_device_id snd_nm256_ids[] __devinitdata = {
 	{PCI_VENDOR_ID_NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},

commit a23446c085faed6c1c90fba5cdd21d6990871750
Author: Florian Schlichting <Florian.Schlichting@gmx.de>
Date:   Wed Mar 15 14:05:19 2006 +0100

    [ALSA] Fix NM256 hard lock up
    
    Modules: NM256 driver
    
    Treat the nm256 mixer as a write-only device so as to avoid hangs on
    initialisation.
    
    Signed-off-by: Florian Schlichting <Florian.Schlichting@gmx.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 3a3ba6f547bc..cc297abc9d11 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -228,6 +228,7 @@ struct nm256 {
 	unsigned int use_cache: 1;	/* use one big coef. table */
 	unsigned int reset_workaround: 1; /* Workaround for some laptops to avoid freeze */
 	unsigned int reset_workaround_2: 1; /* Extended workaround for some other laptops to avoid freeze */
+	unsigned int in_resume: 1;
 
 	int mixer_base;			/* register offset of ac97 mixer */
 	int mixer_status_offset;	/* offset of mixer status reg. */
@@ -242,6 +243,7 @@ struct nm256 {
 	struct nm256_stream streams[2];
 
 	struct snd_ac97 *ac97;
+	unsigned short *ac97_regs; /* register caches, only for valid regs */
 
 	struct snd_pcm *pcm;
 
@@ -1153,23 +1155,63 @@ snd_nm256_ac97_ready(struct nm256 *chip)
 	return 0;
 }
 
+/* 
+ * Initial register values to be written to the AC97 mixer.
+ * While most of these are identical to the reset values, we do this
+ * so that we have most of the register contents cached--this avoids
+ * reading from the mixer directly (which seems to be problematic,
+ * probably due to ignorance).
+ */
+
+struct initialValues {
+	unsigned short reg;
+	unsigned short value;
+};
+
+static struct initialValues nm256_ac97_init_val[] =
+{
+	{ AC97_MASTER, 		0x8000 },
+	{ AC97_HEADPHONE,	0x8000 },
+	{ AC97_MASTER_MONO,	0x8000 },
+	{ AC97_PC_BEEP,		0x8000 },
+	{ AC97_PHONE,		0x8008 },
+	{ AC97_MIC,		0x8000 },
+	{ AC97_LINE,		0x8808 },
+	{ AC97_CD,		0x8808 },
+	{ AC97_VIDEO,		0x8808 },
+	{ AC97_AUX,		0x8808 },
+	{ AC97_PCM,		0x8808 },
+	{ AC97_REC_SEL,		0x0000 },
+	{ AC97_REC_GAIN,	0x0B0B },
+	{ AC97_GENERAL_PURPOSE,	0x0000 },
+	{ AC97_3D_CONTROL,	0x8000 }, 
+	{ AC97_VENDOR_ID1, 	0x8384 },
+	{ AC97_VENDOR_ID2,	0x7609 },
+};
+
+static int nm256_ac97_idx(unsigned short reg)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(nm256_ac97_init_val); i++)
+		if (nm256_ac97_init_val[i].reg == reg)
+			return i;
+	return -1;
+}
+
 /*
+ * some nm256 easily crash when reading from mixer registers
+ * thus we're treating it as a write-only mixer and cache the
+ * written values
  */
 static unsigned short
 snd_nm256_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
 {
 	struct nm256 *chip = ac97->private_data;
-	int res;
-
-	if (reg >= 128)
-		return 0;
+	int idx = nm256_ac97_idx(reg);
 
-	if (! snd_nm256_ac97_ready(chip))
+	if (idx < 0)
 		return 0;
-	res = snd_nm256_readw(chip, chip->mixer_base + reg);
-	/* Magic delay.  Bleah yucky.  */
-	msleep(1);
-	return res;
+	return chip->ac97_regs[idx];
 }
 
 /* 
@@ -1180,8 +1222,12 @@ snd_nm256_ac97_write(struct snd_ac97 *ac97,
 {
 	struct nm256 *chip = ac97->private_data;
 	int tries = 2;
+	int idx = nm256_ac97_idx(reg);
 	u32 base;
 
+	if (idx < 0)
+		return;
+
 	base = chip->mixer_base;
 
 	snd_nm256_ac97_ready(chip);
@@ -1190,12 +1236,32 @@ snd_nm256_ac97_write(struct snd_ac97 *ac97,
 	while (tries-- > 0) {
 		snd_nm256_writew(chip, base + reg, val);
 		msleep(1);  /* a little delay here seems better.. */
-		if (snd_nm256_ac97_ready(chip))
+		if (snd_nm256_ac97_ready(chip)) {
+			/* successful write: set cache */
+			chip->ac97_regs[idx] = val;
 			return;
+		}
 	}
 	snd_printd("nm256: ac97 codec not ready..\n");
 }
 
+/* static resolution table */
+static struct snd_ac97_res_table nm256_res_table[] = {
+	{ AC97_MASTER, 0x1f1f },
+	{ AC97_HEADPHONE, 0x1f1f },
+	{ AC97_MASTER_MONO, 0x001f },
+	{ AC97_PC_BEEP, 0x001f },
+	{ AC97_PHONE, 0x001f },
+	{ AC97_MIC, 0x001f },
+	{ AC97_LINE, 0x1f1f },
+	{ AC97_CD, 0x1f1f },
+	{ AC97_VIDEO, 0x1f1f },
+	{ AC97_AUX, 0x1f1f },
+	{ AC97_PCM, 0x1f1f },
+	{ AC97_REC_GAIN, 0x0f0f },
+	{ } /* terminator */
+};
+
 /* initialize the ac97 into a known state */
 static void
 snd_nm256_ac97_reset(struct snd_ac97 *ac97)
@@ -1213,6 +1279,16 @@ snd_nm256_ac97_reset(struct snd_ac97 *ac97)
 		snd_nm256_writeb(chip, 0x6cc, 0x80);
 		snd_nm256_writeb(chip, 0x6cc, 0x0);
 	}
+	if (! chip->in_resume) {
+		int i;
+		for (i = 0; i < ARRAY_SIZE(nm256_ac97_init_val); i++) {
+			/* preload the cache, so as to avoid even a single
+			 * read of the mixer regs
+			 */
+			snd_nm256_ac97_write(ac97, nm256_ac97_init_val[i].reg,
+					     nm256_ac97_init_val[i].value);
+		}
+	}
 }
 
 /* create an ac97 mixer interface */
@@ -1221,32 +1297,25 @@ snd_nm256_mixer(struct nm256 *chip)
 {
 	struct snd_ac97_bus *pbus;
 	struct snd_ac97_template ac97;
-	int i, err;
+	int err;
 	static struct snd_ac97_bus_ops ops = {
 		.reset = snd_nm256_ac97_reset,
 		.write = snd_nm256_ac97_write,
 		.read = snd_nm256_ac97_read,
 	};
-	/* looks like nm256 hangs up when unexpected registers are touched... */
-	static int mixer_regs[] = {
-		AC97_MASTER, AC97_HEADPHONE, AC97_MASTER_MONO,
-		AC97_PC_BEEP, AC97_PHONE, AC97_MIC, AC97_LINE, AC97_CD,
-		AC97_VIDEO, AC97_AUX, AC97_PCM, AC97_REC_SEL,
-		AC97_REC_GAIN, AC97_GENERAL_PURPOSE, AC97_3D_CONTROL,
-		/*AC97_EXTENDED_ID,*/
-		AC97_VENDOR_ID1, AC97_VENDOR_ID2,
-		-1
-	};
+
+	chip->ac97_regs = kcalloc(sizeof(short),
+				  ARRAY_SIZE(nm256_ac97_init_val), GFP_KERNEL);
+	if (! chip->ac97_regs)
+		return -ENOMEM;
 
 	if ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)
 		return err;
 
 	memset(&ac97, 0, sizeof(ac97));
 	ac97.scaps = AC97_SCAP_AUDIO; /* we support audio! */
-	ac97.limited_regs = 1;
-	for (i = 0; mixer_regs[i] >= 0; i++)
-		set_bit(mixer_regs[i], ac97.reg_accessed);
 	ac97.private_data = chip;
+	ac97.res_table = nm256_res_table;
 	pbus->no_vra = 1;
 	err = snd_ac97_mixer(pbus, &ac97, &chip->ac97);
 	if (err < 0)
@@ -1331,6 +1400,7 @@ static int nm256_resume(struct pci_dev *pci)
 	int i;
 
 	/* Perform a full reset on the hardware */
+	chip->in_resume = 1;
 	pci_restore_state(pci);
 	pci_enable_device(pci);
 	snd_nm256_init_chip(chip);
@@ -1348,6 +1418,7 @@ static int nm256_resume(struct pci_dev *pci)
 	}
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	chip->in_resume = 0;
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -1372,6 +1443,7 @@ static int snd_nm256_free(struct nm256 *chip)
 		free_irq(chip->irq, chip);
 
 	pci_disable_device(chip->pci);
+	kfree(chip->ac97_regs);
 	kfree(chip);
 	return 0;
 }

commit 62932df8fb20ba2fb53a95fa52445eba22e821fe
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:34:20 2006 +0100

    [ALSA] semaphore -> mutex (PCI part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 0d0ff54f0fc6..3a3ba6f547bc 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -32,6 +32,8 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/moduleparam.h>
+#include <linux/mutex.h>
+
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
@@ -235,7 +237,7 @@ struct nm256 {
 	int irq_acks;
 	irqreturn_t (*interrupt)(int, void *, struct pt_regs *);
 	int badintrcount;		/* counter to check bogus interrupts */
-	struct semaphore irq_mutex;
+	struct mutex irq_mutex;
 
 	struct nm256_stream streams[2];
 
@@ -459,32 +461,32 @@ snd_nm256_set_format(struct nm256 *chip, struct nm256_stream *s,
 /* acquire interrupt */
 static int snd_nm256_acquire_irq(struct nm256 *chip)
 {
-	down(&chip->irq_mutex);
+	mutex_lock(&chip->irq_mutex);
 	if (chip->irq < 0) {
 		if (request_irq(chip->pci->irq, chip->interrupt, SA_INTERRUPT|SA_SHIRQ,
 				chip->card->driver, chip)) {
 			snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->pci->irq);
-			up(&chip->irq_mutex);
+			mutex_unlock(&chip->irq_mutex);
 			return -EBUSY;
 		}
 		chip->irq = chip->pci->irq;
 	}
 	chip->irq_acks++;
-	up(&chip->irq_mutex);
+	mutex_unlock(&chip->irq_mutex);
 	return 0;
 }
 
 /* release interrupt */
 static void snd_nm256_release_irq(struct nm256 *chip)
 {
-	down(&chip->irq_mutex);
+	mutex_lock(&chip->irq_mutex);
 	if (chip->irq_acks > 0)
 		chip->irq_acks--;
 	if (chip->irq_acks == 0 && chip->irq >= 0) {
 		free_irq(chip->irq, chip);
 		chip->irq = -1;
 	}
-	up(&chip->irq_mutex);
+	mutex_unlock(&chip->irq_mutex);
 }
 
 /*
@@ -1407,7 +1409,7 @@ snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 	chip->use_cache = use_cache;
 	spin_lock_init(&chip->reg_lock);
 	chip->irq = -1;
-	init_MUTEX(&chip->irq_mutex);
+	mutex_init(&chip->irq_mutex);
 
 	/* store buffer sizes in bytes */
 	chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize = playback_bufsize * 1024;

commit 3fcf7d2cd8e0ebce10e4bf89da175ff9bd6aa2da
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 16:11:24 2005 +0100

    [ALSA] nm256-intel - Fix PM support
    
    Modules: NM256 driver
    
    Fix PM support on NM256 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 99ec1c17049b..0d0ff54f0fc6 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1308,24 +1308,29 @@ snd_nm256_peek_for_sig(struct nm256 *chip)
  * APM event handler, so the card is properly reinitialized after a power
  * event.
  */
-static int nm256_suspend(struct snd_card *card, pm_message_t state)
+static int nm256_suspend(struct pci_dev *pci, pm_message_t state)
 {
-	struct nm256 *chip = card->pm_private_data;
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct nm256 *chip = card->private_data;
 
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
 	chip->coeffs_current = 0;
-	pci_disable_device(chip->pci);
+	pci_disable_device(pci);
+	pci_save_state(pci);
 	return 0;
 }
 
-static int nm256_resume(struct snd_card *card)
+static int nm256_resume(struct pci_dev *pci)
 {
-	struct nm256 *chip = card->pm_private_data;
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct nm256 *chip = card->private_data;
 	int i;
 
 	/* Perform a full reset on the hardware */
-	pci_enable_device(chip->pci);
+	pci_restore_state(pci);
+	pci_enable_device(pci);
 	snd_nm256_init_chip(chip);
 
 	/* restore ac97 */
@@ -1340,6 +1345,7 @@ static int nm256_resume(struct snd_card *card)
 		}
 	}
 
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -1524,8 +1530,6 @@ snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
 
 	// pci_set_master(pci); /* needed? */
 	
-	snd_card_set_pm_callback(card, nm256_suspend, nm256_resume, chip);
-
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0)
 		goto __error;
 
@@ -1625,6 +1629,7 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 		snd_card_free(card);
 		return err;
 	}
+	card->private_data = chip;
 
 	if (reset_workaround) {
 		snd_printdd(KERN_INFO "nm256: reset_workaround activated\n");
@@ -1668,7 +1673,10 @@ static struct pci_driver driver = {
 	.id_table = snd_nm256_ids,
 	.probe = snd_nm256_probe,
 	.remove = __devexit_p(snd_nm256_remove),
-	SND_PCI_PM_CALLBACKS
+#ifdef CONFIG_PM
+	.suspend = nm256_suspend,
+	.resume = nm256_resume,
+#endif
 };
 
 

commit 10754f53450a2c2aababe69f20edd7d2077e588d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:01:29 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI NM256
    
    Modules: NM256 driver
    
    Remove xxx_t typedefs from the PCI NM256 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index a01b3e577966..99ec1c17049b 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -183,17 +183,10 @@ module_param(enable, bool, 0444);
 #define NM_PBUFFER_WMARK (NM_PLAYBACK_REG_OFFSET + 0xc)
 #define NM_PBUFFER_CURRP (NM_PLAYBACK_REG_OFFSET + 0x8)
 
-/*
- * type definitions
- */
-
-typedef struct snd_nm256 nm256_t;
-typedef struct snd_nm256_stream nm256_stream_t;
-
-struct snd_nm256_stream {
+struct nm256_stream {
 
-	nm256_t *chip;
-	snd_pcm_substream_t *substream;
+	struct nm256 *chip;
+	struct snd_pcm_substream *substream;
 	int running;
 	int suspended;
 	
@@ -210,9 +203,9 @@ struct snd_nm256_stream {
 
 };
 
-struct snd_nm256 {
+struct nm256 {
 	
-	snd_card_t *card;
+	struct snd_card *card;
 
 	void __iomem *cport;		/* control port */
 	struct resource *res_cport;	/* its resource */
@@ -244,11 +237,11 @@ struct snd_nm256 {
 	int badintrcount;		/* counter to check bogus interrupts */
 	struct semaphore irq_mutex;
 
-	nm256_stream_t streams[2];
+	struct nm256_stream streams[2];
 
-	ac97_t *ac97;
+	struct snd_ac97 *ac97;
 
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 
 	struct pci_dev *pci;
 
@@ -281,48 +274,49 @@ MODULE_DEVICE_TABLE(pci, snd_nm256_ids);
  */
 
 static inline u8
-snd_nm256_readb(nm256_t *chip, int offset)
+snd_nm256_readb(struct nm256 *chip, int offset)
 {
 	return readb(chip->cport + offset);
 }
 
 static inline u16
-snd_nm256_readw(nm256_t *chip, int offset)
+snd_nm256_readw(struct nm256 *chip, int offset)
 {
 	return readw(chip->cport + offset);
 }
 
 static inline u32
-snd_nm256_readl(nm256_t *chip, int offset)
+snd_nm256_readl(struct nm256 *chip, int offset)
 {
 	return readl(chip->cport + offset);
 }
 
 static inline void
-snd_nm256_writeb(nm256_t *chip, int offset, u8 val)
+snd_nm256_writeb(struct nm256 *chip, int offset, u8 val)
 {
 	writeb(val, chip->cport + offset);
 }
 
 static inline void
-snd_nm256_writew(nm256_t *chip, int offset, u16 val)
+snd_nm256_writew(struct nm256 *chip, int offset, u16 val)
 {
 	writew(val, chip->cport + offset);
 }
 
 static inline void
-snd_nm256_writel(nm256_t *chip, int offset, u32 val)
+snd_nm256_writel(struct nm256 *chip, int offset, u32 val)
 {
 	writel(val, chip->cport + offset);
 }
 
 static inline void
-snd_nm256_write_buffer(nm256_t *chip, void *src, int offset, int size)
+snd_nm256_write_buffer(struct nm256 *chip, void *src, int offset, int size)
 {
 	offset -= chip->buffer_start;
 #ifdef CONFIG_SND_DEBUG
 	if (offset < 0 || offset >= chip->buffer_size) {
-		snd_printk(KERN_ERR "write_buffer invalid offset = %d size = %d\n", offset, size);
+		snd_printk(KERN_ERR "write_buffer invalid offset = %d size = %d\n",
+			   offset, size);
 		return;
 	}
 #endif
@@ -343,7 +337,7 @@ snd_nm256_get_start_offset(int which)
 }
 
 static void
-snd_nm256_load_one_coefficient(nm256_t *chip, int stream, u32 port, int which)
+snd_nm256_load_one_coefficient(struct nm256 *chip, int stream, u32 port, int which)
 {
 	u32 coeff_buf = chip->coeff_buf[stream];
 	u16 offset = snd_nm256_get_start_offset(which);
@@ -358,13 +352,15 @@ snd_nm256_load_one_coefficient(nm256_t *chip, int stream, u32 port, int which)
 }
 
 static void
-snd_nm256_load_coefficient(nm256_t *chip, int stream, int number)
+snd_nm256_load_coefficient(struct nm256 *chip, int stream, int number)
 {
 	/* The enable register for the specified engine.  */
-	u32 poffset = (stream == SNDRV_PCM_STREAM_CAPTURE ? NM_RECORD_ENABLE_REG : NM_PLAYBACK_ENABLE_REG);
+	u32 poffset = (stream == SNDRV_PCM_STREAM_CAPTURE ?
+		       NM_RECORD_ENABLE_REG : NM_PLAYBACK_ENABLE_REG);
 	u32 addr = NM_COEFF_START_OFFSET;
 
-	addr += (stream == SNDRV_PCM_STREAM_CAPTURE ? NM_RECORD_REG_OFFSET : NM_PLAYBACK_REG_OFFSET);
+	addr += (stream == SNDRV_PCM_STREAM_CAPTURE ?
+		 NM_RECORD_REG_OFFSET : NM_PLAYBACK_REG_OFFSET);
 
 	if (snd_nm256_readb(chip, poffset) & 1) {
 		snd_printd("NM256: Engine was enabled while loading coefficients!\n");
@@ -400,7 +396,7 @@ snd_nm256_load_coefficient(nm256_t *chip, int stream, int number)
 static unsigned int samplerates[8] = {
 	8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000,
 };
-static snd_pcm_hw_constraint_list_t constraints_rates = {
+static struct snd_pcm_hw_constraint_list constraints_rates = {
 	.count = ARRAY_SIZE(samplerates), 
 	.list = samplerates,
 	.mask = 0,
@@ -425,9 +421,10 @@ snd_nm256_fixed_rate(unsigned int rate)
  * set sample rate and format
  */
 static void
-snd_nm256_set_format(nm256_t *chip, nm256_stream_t *s, snd_pcm_substream_t *substream)
+snd_nm256_set_format(struct nm256 *chip, struct nm256_stream *s,
+		     struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int rate_index = snd_nm256_fixed_rate(runtime->rate);
 	unsigned char ratebits = (rate_index << 4) & NM_RATE_MASK;
 
@@ -460,12 +457,12 @@ snd_nm256_set_format(nm256_t *chip, nm256_stream_t *s, snd_pcm_substream_t *subs
 }
 
 /* acquire interrupt */
-static int snd_nm256_acquire_irq(nm256_t *chip)
+static int snd_nm256_acquire_irq(struct nm256 *chip)
 {
 	down(&chip->irq_mutex);
 	if (chip->irq < 0) {
 		if (request_irq(chip->pci->irq, chip->interrupt, SA_INTERRUPT|SA_SHIRQ,
-				chip->card->driver, (void*)chip)) {
+				chip->card->driver, chip)) {
 			snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->pci->irq);
 			up(&chip->irq_mutex);
 			return -EBUSY;
@@ -478,13 +475,13 @@ static int snd_nm256_acquire_irq(nm256_t *chip)
 }
 
 /* release interrupt */
-static void snd_nm256_release_irq(nm256_t *chip)
+static void snd_nm256_release_irq(struct nm256 *chip)
 {
 	down(&chip->irq_mutex);
 	if (chip->irq_acks > 0)
 		chip->irq_acks--;
 	if (chip->irq_acks == 0 && chip->irq >= 0) {
-		free_irq(chip->irq, (void*)chip);
+		free_irq(chip->irq, chip);
 		chip->irq = -1;
 	}
 	up(&chip->irq_mutex);
@@ -495,7 +492,7 @@ static void snd_nm256_release_irq(nm256_t *chip)
  */
 
 /* update the watermark (current period) */
-static void snd_nm256_pcm_mark(nm256_t *chip, nm256_stream_t *s, int reg)
+static void snd_nm256_pcm_mark(struct nm256 *chip, struct nm256_stream *s, int reg)
 {
 	s->cur_period++;
 	s->cur_period %= s->periods;
@@ -506,7 +503,8 @@ static void snd_nm256_pcm_mark(nm256_t *chip, nm256_stream_t *s, int reg)
 #define snd_nm256_capture_mark(chip, s)  snd_nm256_pcm_mark(chip, s, NM_RBUFFER_WMARK)
 
 static void
-snd_nm256_playback_start(nm256_t *chip, nm256_stream_t *s, snd_pcm_substream_t *substream)
+snd_nm256_playback_start(struct nm256 *chip, struct nm256_stream *s,
+			 struct snd_pcm_substream *substream)
 {
 	/* program buffer pointers */
 	snd_nm256_writel(chip, NM_PBUFFER_START, s->buf);
@@ -522,7 +520,8 @@ snd_nm256_playback_start(nm256_t *chip, nm256_stream_t *s, snd_pcm_substream_t *
 }
 
 static void
-snd_nm256_capture_start(nm256_t *chip, nm256_stream_t *s, snd_pcm_substream_t *substream)
+snd_nm256_capture_start(struct nm256 *chip, struct nm256_stream *s,
+			struct snd_pcm_substream *substream)
 {
 	/* program buffer pointers */
 	snd_nm256_writel(chip, NM_RBUFFER_START, s->buf);
@@ -537,7 +536,7 @@ snd_nm256_capture_start(nm256_t *chip, nm256_stream_t *s, snd_pcm_substream_t *s
 
 /* Stop the play engine. */
 static void
-snd_nm256_playback_stop(nm256_t *chip)
+snd_nm256_playback_stop(struct nm256 *chip)
 {
 	/* Shut off sound from both channels. */
 	snd_nm256_writew(chip, NM_AUDIO_MUTE_REG,
@@ -547,17 +546,17 @@ snd_nm256_playback_stop(nm256_t *chip)
 }
 
 static void
-snd_nm256_capture_stop(nm256_t *chip)
+snd_nm256_capture_stop(struct nm256 *chip)
 {
 	/* Disable recording engine. */
 	snd_nm256_writeb(chip, NM_RECORD_ENABLE_REG, 0);
 }
 
 static int
-snd_nm256_playback_trigger(snd_pcm_substream_t *substream, int cmd)
+snd_nm256_playback_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	nm256_t *chip = snd_pcm_substream_chip(substream);
-	nm256_stream_t *s = (nm256_stream_t*)substream->runtime->private_data;
+	struct nm256 *chip = snd_pcm_substream_chip(substream);
+	struct nm256_stream *s = substream->runtime->private_data;
 	int err = 0;
 
 	snd_assert(s != NULL, return -ENXIO);
@@ -591,10 +590,10 @@ snd_nm256_playback_trigger(snd_pcm_substream_t *substream, int cmd)
 }
 
 static int
-snd_nm256_capture_trigger(snd_pcm_substream_t *substream, int cmd)
+snd_nm256_capture_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	nm256_t *chip = snd_pcm_substream_chip(substream);
-	nm256_stream_t *s = (nm256_stream_t*)substream->runtime->private_data;
+	struct nm256 *chip = snd_pcm_substream_chip(substream);
+	struct nm256_stream *s = substream->runtime->private_data;
 	int err = 0;
 
 	snd_assert(s != NULL, return -ENXIO);
@@ -627,11 +626,11 @@ snd_nm256_capture_trigger(snd_pcm_substream_t *substream, int cmd)
 /*
  * prepare playback/capture channel
  */
-static int snd_nm256_pcm_prepare(snd_pcm_substream_t *substream)
+static int snd_nm256_pcm_prepare(struct snd_pcm_substream *substream)
 {
-	nm256_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	nm256_stream_t *s = (nm256_stream_t*)runtime->private_data;
+	struct nm256 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct nm256_stream *s = runtime->private_data;
 
 	snd_assert(s, return -ENXIO);
 	s->dma_size = frames_to_bytes(runtime, substream->runtime->buffer_size);
@@ -652,10 +651,10 @@ static int snd_nm256_pcm_prepare(snd_pcm_substream_t *substream)
  * get the current pointer
  */
 static snd_pcm_uframes_t
-snd_nm256_playback_pointer(snd_pcm_substream_t * substream)
+snd_nm256_playback_pointer(struct snd_pcm_substream *substream)
 {
-	nm256_t *chip = snd_pcm_substream_chip(substream);
-	nm256_stream_t *s = (nm256_stream_t*)substream->runtime->private_data;
+	struct nm256 *chip = snd_pcm_substream_chip(substream);
+	struct nm256_stream *s = substream->runtime->private_data;
 	unsigned long curp;
 
 	snd_assert(s, return 0);
@@ -665,10 +664,10 @@ snd_nm256_playback_pointer(snd_pcm_substream_t * substream)
 }
 
 static snd_pcm_uframes_t
-snd_nm256_capture_pointer(snd_pcm_substream_t * substream)
+snd_nm256_capture_pointer(struct snd_pcm_substream *substream)
 {
-	nm256_t *chip = snd_pcm_substream_chip(substream);
-	nm256_stream_t *s = (nm256_stream_t*)substream->runtime->private_data;
+	struct nm256 *chip = snd_pcm_substream_chip(substream);
+	struct nm256_stream *s = substream->runtime->private_data;
 	unsigned long curp;
 
 	snd_assert(s != NULL, return 0);
@@ -684,13 +683,13 @@ snd_nm256_capture_pointer(snd_pcm_substream_t * substream)
  * silence / copy for playback
  */
 static int
-snd_nm256_playback_silence(snd_pcm_substream_t *substream,
+snd_nm256_playback_silence(struct snd_pcm_substream *substream,
 			   int channel, /* not used (interleaved data) */
 			   snd_pcm_uframes_t pos,
 			   snd_pcm_uframes_t count)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	nm256_stream_t *s = (nm256_stream_t*)runtime->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct nm256_stream *s = runtime->private_data;
 	count = frames_to_bytes(runtime, count);
 	pos = frames_to_bytes(runtime, pos);
 	memset_io(s->bufptr + pos, 0, count);
@@ -698,14 +697,14 @@ snd_nm256_playback_silence(snd_pcm_substream_t *substream,
 }
 
 static int
-snd_nm256_playback_copy(snd_pcm_substream_t *substream,
+snd_nm256_playback_copy(struct snd_pcm_substream *substream,
 			int channel, /* not used (interleaved data) */
 			snd_pcm_uframes_t pos,
 			void __user *src,
 			snd_pcm_uframes_t count)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	nm256_stream_t *s = (nm256_stream_t*)runtime->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct nm256_stream *s = runtime->private_data;
 	count = frames_to_bytes(runtime, count);
 	pos = frames_to_bytes(runtime, pos);
 	if (copy_from_user_toio(s->bufptr + pos, src, count))
@@ -717,14 +716,14 @@ snd_nm256_playback_copy(snd_pcm_substream_t *substream,
  * copy to user
  */
 static int
-snd_nm256_capture_copy(snd_pcm_substream_t *substream,
+snd_nm256_capture_copy(struct snd_pcm_substream *substream,
 		       int channel, /* not used (interleaved data) */
 		       snd_pcm_uframes_t pos,
 		       void __user *dst,
 		       snd_pcm_uframes_t count)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	nm256_stream_t *s = (nm256_stream_t*)runtime->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct nm256_stream *s = runtime->private_data;
 	count = frames_to_bytes(runtime, count);
 	pos = frames_to_bytes(runtime, pos);
 	if (copy_to_user_fromio(dst, s->bufptr + pos, count))
@@ -741,9 +740,9 @@ snd_nm256_capture_copy(snd_pcm_substream_t *substream,
 
 /* spinlock held! */
 static void
-snd_nm256_playback_update(nm256_t *chip)
+snd_nm256_playback_update(struct nm256 *chip)
 {
-	nm256_stream_t *s;
+	struct nm256_stream *s;
 
 	s = &chip->streams[SNDRV_PCM_STREAM_PLAYBACK];
 	if (s->running && s->substream) {
@@ -756,9 +755,9 @@ snd_nm256_playback_update(nm256_t *chip)
 
 /* spinlock held! */
 static void
-snd_nm256_capture_update(nm256_t *chip)
+snd_nm256_capture_update(struct nm256 *chip)
 {
-	nm256_stream_t *s;
+	struct nm256_stream *s;
 
 	s = &chip->streams[SNDRV_PCM_STREAM_CAPTURE];
 	if (s->running && s->substream) {
@@ -772,7 +771,7 @@ snd_nm256_capture_update(nm256_t *chip)
 /*
  * hardware info
  */
-static snd_pcm_hardware_t snd_nm256_playback =
+static struct snd_pcm_hardware snd_nm256_playback =
 {
 	.info =			SNDRV_PCM_INFO_MMAP_IOMEM |SNDRV_PCM_INFO_MMAP_VALID |
 				SNDRV_PCM_INFO_INTERLEAVED |
@@ -791,7 +790,7 @@ static snd_pcm_hardware_t snd_nm256_playback =
 	.period_bytes_max =	128 * 1024,
 };
 
-static snd_pcm_hardware_t snd_nm256_capture =
+static struct snd_pcm_hardware snd_nm256_capture =
 {
 	.info =			SNDRV_PCM_INFO_MMAP_IOMEM | SNDRV_PCM_INFO_MMAP_VALID |
 				SNDRV_PCM_INFO_INTERLEAVED |
@@ -812,7 +811,8 @@ static snd_pcm_hardware_t snd_nm256_capture =
 
 
 /* set dma transfer size */
-static int snd_nm256_pcm_hw_params(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *hw_params)
+static int snd_nm256_pcm_hw_params(struct snd_pcm_substream *substream,
+				   struct snd_pcm_hw_params *hw_params)
 {
 	/* area and addr are already set and unchanged */
 	substream->runtime->dma_bytes = params_buffer_bytes(hw_params);
@@ -822,11 +822,11 @@ static int snd_nm256_pcm_hw_params(snd_pcm_substream_t *substream, snd_pcm_hw_pa
 /*
  * open
  */
-static void snd_nm256_setup_stream(nm256_t *chip, nm256_stream_t *s,
-				   snd_pcm_substream_t *substream,
-				   snd_pcm_hardware_t *hw_ptr)
+static void snd_nm256_setup_stream(struct nm256 *chip, struct nm256_stream *s,
+				   struct snd_pcm_substream *substream,
+				   struct snd_pcm_hardware *hw_ptr)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	s->running = 0;
 	runtime->hw = *hw_ptr;
@@ -844,9 +844,9 @@ static void snd_nm256_setup_stream(nm256_t *chip, nm256_stream_t *s,
 }
 
 static int
-snd_nm256_playback_open(snd_pcm_substream_t *substream)
+snd_nm256_playback_open(struct snd_pcm_substream *substream)
 {
-	nm256_t *chip = snd_pcm_substream_chip(substream);
+	struct nm256 *chip = snd_pcm_substream_chip(substream);
 
 	if (snd_nm256_acquire_irq(chip) < 0)
 		return -EBUSY;
@@ -856,9 +856,9 @@ snd_nm256_playback_open(snd_pcm_substream_t *substream)
 }
 
 static int
-snd_nm256_capture_open(snd_pcm_substream_t *substream)
+snd_nm256_capture_open(struct snd_pcm_substream *substream)
 {
-	nm256_t *chip = snd_pcm_substream_chip(substream);
+	struct nm256 *chip = snd_pcm_substream_chip(substream);
 
 	if (snd_nm256_acquire_irq(chip) < 0)
 		return -EBUSY;
@@ -871,9 +871,9 @@ snd_nm256_capture_open(snd_pcm_substream_t *substream)
  * close - we don't have to do special..
  */
 static int
-snd_nm256_playback_close(snd_pcm_substream_t *substream)
+snd_nm256_playback_close(struct snd_pcm_substream *substream)
 {
-	nm256_t *chip = snd_pcm_substream_chip(substream);
+	struct nm256 *chip = snd_pcm_substream_chip(substream);
 
 	snd_nm256_release_irq(chip);
 	return 0;
@@ -881,9 +881,9 @@ snd_nm256_playback_close(snd_pcm_substream_t *substream)
 
 
 static int
-snd_nm256_capture_close(snd_pcm_substream_t *substream)
+snd_nm256_capture_close(struct snd_pcm_substream *substream)
 {
-	nm256_t *chip = snd_pcm_substream_chip(substream);
+	struct nm256 *chip = snd_pcm_substream_chip(substream);
 
 	snd_nm256_release_irq(chip);
 	return 0;
@@ -892,7 +892,7 @@ snd_nm256_capture_close(snd_pcm_substream_t *substream)
 /*
  * create a pcm instance
  */
-static snd_pcm_ops_t snd_nm256_playback_ops = {
+static struct snd_pcm_ops snd_nm256_playback_ops = {
 	.open =		snd_nm256_playback_open,
 	.close =	snd_nm256_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -907,7 +907,7 @@ static snd_pcm_ops_t snd_nm256_playback_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static snd_pcm_ops_t snd_nm256_capture_ops = {
+static struct snd_pcm_ops snd_nm256_capture_ops = {
 	.open =		snd_nm256_capture_open,
 	.close =	snd_nm256_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -922,13 +922,13 @@ static snd_pcm_ops_t snd_nm256_capture_ops = {
 };
 
 static int __devinit
-snd_nm256_pcm(nm256_t *chip, int device)
+snd_nm256_pcm(struct nm256 *chip, int device)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int i, err;
 
 	for (i = 0; i < 2; i++) {
-		nm256_stream_t *s = &chip->streams[i];
+		struct nm256_stream *s = &chip->streams[i];
 		s->bufptr = chip->buffer + (s->buf - chip->buffer_start);
 		s->bufptr_addr = chip->buffer_addr + (s->buf - chip->buffer_start);
 	}
@@ -953,7 +953,7 @@ snd_nm256_pcm(nm256_t *chip, int device)
  * Initialize the hardware. 
  */
 static void
-snd_nm256_init_chip(nm256_t *chip)
+snd_nm256_init_chip(struct nm256 *chip)
 {
 	/* Reset everything. */
 	snd_nm256_writeb(chip, 0x0, 0x11);
@@ -965,7 +965,7 @@ snd_nm256_init_chip(nm256_t *chip)
 
 
 static irqreturn_t
-snd_nm256_intr_check(nm256_t *chip)
+snd_nm256_intr_check(struct nm256 *chip)
 {
 	if (chip->badintrcount++ > 1000) {
 		/*
@@ -1002,7 +1002,7 @@ snd_nm256_intr_check(nm256_t *chip)
 static irqreturn_t
 snd_nm256_interrupt(int irq, void *dev_id, struct pt_regs *dummy)
 {
-	nm256_t *chip = dev_id;
+	struct nm256 *chip = dev_id;
 	u16 status;
 	u8 cbyte;
 
@@ -1067,7 +1067,7 @@ snd_nm256_interrupt(int irq, void *dev_id, struct pt_regs *dummy)
 static irqreturn_t
 snd_nm256_interrupt_zx(int irq, void *dev_id, struct pt_regs *dummy)
 {
-	nm256_t *chip = dev_id;
+	struct nm256 *chip = dev_id;
 	u32 status;
 	u8 cbyte;
 
@@ -1131,7 +1131,7 @@ snd_nm256_interrupt_zx(int irq, void *dev_id, struct pt_regs *dummy)
  * if it timed out.
  */
 static int
-snd_nm256_ac97_ready(nm256_t *chip)
+snd_nm256_ac97_ready(struct nm256 *chip)
 {
 	int timeout = 10;
 	u32 testaddr;
@@ -1154,9 +1154,9 @@ snd_nm256_ac97_ready(nm256_t *chip)
 /*
  */
 static unsigned short
-snd_nm256_ac97_read(ac97_t *ac97, unsigned short reg)
+snd_nm256_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
 {
-	nm256_t *chip = ac97->private_data;
+	struct nm256 *chip = ac97->private_data;
 	int res;
 
 	if (reg >= 128)
@@ -1173,10 +1173,10 @@ snd_nm256_ac97_read(ac97_t *ac97, unsigned short reg)
 /* 
  */
 static void
-snd_nm256_ac97_write(ac97_t *ac97,
+snd_nm256_ac97_write(struct snd_ac97 *ac97,
 		     unsigned short reg, unsigned short val)
 {
-	nm256_t *chip = ac97->private_data;
+	struct nm256 *chip = ac97->private_data;
 	int tries = 2;
 	u32 base;
 
@@ -1196,9 +1196,9 @@ snd_nm256_ac97_write(ac97_t *ac97,
 
 /* initialize the ac97 into a known state */
 static void
-snd_nm256_ac97_reset(ac97_t *ac97)
+snd_nm256_ac97_reset(struct snd_ac97 *ac97)
 {
-	nm256_t *chip = ac97->private_data;
+	struct nm256 *chip = ac97->private_data;
 
 	/* Reset the mixer.  'Tis magic!  */
 	snd_nm256_writeb(chip, 0x6c0, 1);
@@ -1215,12 +1215,12 @@ snd_nm256_ac97_reset(ac97_t *ac97)
 
 /* create an ac97 mixer interface */
 static int __devinit
-snd_nm256_mixer(nm256_t *chip)
+snd_nm256_mixer(struct nm256 *chip)
 {
-	ac97_bus_t *pbus;
-	ac97_template_t ac97;
+	struct snd_ac97_bus *pbus;
+	struct snd_ac97_template ac97;
 	int i, err;
-	static ac97_bus_ops_t ops = {
+	static struct snd_ac97_bus_ops ops = {
 		.reset = snd_nm256_ac97_reset,
 		.write = snd_nm256_ac97_write,
 		.read = snd_nm256_ac97_read,
@@ -1263,7 +1263,7 @@ snd_nm256_mixer(nm256_t *chip)
  */
 
 static int __devinit
-snd_nm256_peek_for_sig(nm256_t *chip)
+snd_nm256_peek_for_sig(struct nm256 *chip)
 {
 	/* The signature is located 1K below the end of video RAM.  */
 	void __iomem *temp;
@@ -1292,7 +1292,8 @@ snd_nm256_peek_for_sig(nm256_t *chip)
 			return -ENODEV;
 		} else {
 			pointer_found = pointer;
-			printk(KERN_INFO "nm256: found card signature in video RAM: 0x%x\n", pointer);
+			printk(KERN_INFO "nm256: found card signature in video RAM: 0x%x\n",
+			       pointer);
 		}
 	}
 
@@ -1307,9 +1308,9 @@ snd_nm256_peek_for_sig(nm256_t *chip)
  * APM event handler, so the card is properly reinitialized after a power
  * event.
  */
-static int nm256_suspend(snd_card_t *card, pm_message_t state)
+static int nm256_suspend(struct snd_card *card, pm_message_t state)
 {
-	nm256_t *chip = card->pm_private_data;
+	struct nm256 *chip = card->pm_private_data;
 
 	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
@@ -1318,9 +1319,9 @@ static int nm256_suspend(snd_card_t *card, pm_message_t state)
 	return 0;
 }
 
-static int nm256_resume(snd_card_t *card)
+static int nm256_resume(struct snd_card *card)
 {
-	nm256_t *chip = card->pm_private_data;
+	struct nm256 *chip = card->pm_private_data;
 	int i;
 
 	/* Perform a full reset on the hardware */
@@ -1331,7 +1332,7 @@ static int nm256_resume(snd_card_t *card)
 	snd_ac97_resume(chip->ac97);
 
 	for (i = 0; i < 2; i++) {
-		nm256_stream_t *s = &chip->streams[i];
+		struct nm256_stream *s = &chip->streams[i];
 		if (s->substream && s->suspended) {
 			spin_lock_irq(&chip->reg_lock);
 			snd_nm256_set_format(chip, s, s->substream);
@@ -1343,7 +1344,7 @@ static int nm256_resume(snd_card_t *card)
 }
 #endif /* CONFIG_PM */
 
-static int snd_nm256_free(nm256_t *chip)
+static int snd_nm256_free(struct nm256 *chip)
 {
 	if (chip->streams[SNDRV_PCM_STREAM_PLAYBACK].running)
 		snd_nm256_playback_stop(chip);
@@ -1360,26 +1361,26 @@ static int snd_nm256_free(nm256_t *chip)
 	release_and_free_resource(chip->res_cport);
 	release_and_free_resource(chip->res_buffer);
 	if (chip->irq >= 0)
-		free_irq(chip->irq, (void*)chip);
+		free_irq(chip->irq, chip);
 
 	pci_disable_device(chip->pci);
 	kfree(chip);
 	return 0;
 }
 
-static int snd_nm256_dev_free(snd_device_t *device)
+static int snd_nm256_dev_free(struct snd_device *device)
 {
-	nm256_t *chip = device->device_data;
+	struct nm256 *chip = device->device_data;
 	return snd_nm256_free(chip);
 }
 
 static int __devinit
-snd_nm256_create(snd_card_t *card, struct pci_dev *pci,
-		 nm256_t **chip_ret)
+snd_nm256_create(struct snd_card *card, struct pci_dev *pci,
+		 struct nm256 **chip_ret)
 {
-	nm256_t *chip;
+	struct nm256 *chip;
 	int err, pval;
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free =	snd_nm256_dev_free,
 	};
 	u32 addr;
@@ -1439,7 +1440,8 @@ snd_nm256_create(snd_card_t *card, struct pci_dev *pci,
 		if ((pval & NM_PRESENCE_MASK) != NM_PRESENCE_VALUE) {
 			if (! force_ac97) {
 				printk(KERN_ERR "nm256: no ac97 is found!\n");
-				printk(KERN_ERR "  force the driver to load by passing in the module parameter\n");
+				printk(KERN_ERR "  force the driver to load by "
+				       "passing in the module parameter\n");
 				printk(KERN_ERR "    force_ac97=1\n");
 				printk(KERN_ERR "  or try sb16 or cs423x drivers instead.\n");
 				err = -ENXIO;
@@ -1462,7 +1464,8 @@ snd_nm256_create(snd_card_t *card, struct pci_dev *pci,
 		chip->mixer_status_mask = NM2_MIXER_READY_MASK;
 	}
 	
-	chip->buffer_size = chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize + chip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize;
+	chip->buffer_size = chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize +
+		chip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize;
 	if (chip->use_cache)
 		chip->buffer_size += NM_TOTAL_COEFF_COUNT * 4;
 	else
@@ -1561,8 +1564,8 @@ static struct nm256_quirk nm256_quirks[] __devinitdata = {
 static int __devinit snd_nm256_probe(struct pci_dev *pci,
 				     const struct pci_device_id *pci_id)
 {
-	snd_card_t *card;
-	nm256_t *chip;
+	struct snd_card *card;
+	struct nm256 *chip;
 	int err;
 	struct nm256_quirk *q;
 	u16 subsystem_vendor, subsystem_device;
@@ -1574,7 +1577,8 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 		if (q->vendor == subsystem_vendor && q->device == subsystem_device) {
 			switch (q->type) {
 			case NM_BLACKLISTED:
-				printk(KERN_INFO "nm256: The device is blacklisted.  Loading stopped\n");
+				printk(KERN_INFO "nm256: The device is blacklisted. "
+				       "Loading stopped\n");
 				return -ENODEV;
 			case NM_RESET_WORKAROUND_2:
 				reset_workaround_2 = 1;

commit 3f05f868f1112b970e7fb9c0aa42cc99370098fe
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 11:12:06 2005 +0100

    [ALSA] nm256 - Code clean up
    
    Modules: NM256 driver
    
    Clean up snd-nm256 driver code:
    
    - Simplify chip constructor function
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 089d23b4a002..a01b3e577966 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1375,10 +1375,6 @@ static int snd_nm256_dev_free(snd_device_t *device)
 
 static int __devinit
 snd_nm256_create(snd_card_t *card, struct pci_dev *pci,
-		 int play_bufsize, int capt_bufsize,
-		 int force_load,
-		 u32 buffertop,
-		 int usecache,
 		 nm256_t **chip_ret)
 {
 	nm256_t *chip;
@@ -1401,13 +1397,14 @@ snd_nm256_create(snd_card_t *card, struct pci_dev *pci,
 
 	chip->card = card;
 	chip->pci = pci;
-	chip->use_cache = usecache;
+	chip->use_cache = use_cache;
 	spin_lock_init(&chip->reg_lock);
 	chip->irq = -1;
 	init_MUTEX(&chip->irq_mutex);
 
-	chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize = play_bufsize;
-	chip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize = capt_bufsize;
+	/* store buffer sizes in bytes */
+	chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize = playback_bufsize * 1024;
+	chip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize = capture_bufsize * 1024;
 
 	/* 
 	 * The NM256 has two memory ports.  The first port is nothing
@@ -1440,7 +1437,7 @@ snd_nm256_create(snd_card_t *card, struct pci_dev *pci,
 		/* Ok, try to see if this is a non-AC97 version of the hardware. */
 		pval = snd_nm256_readw(chip, NM_MIXER_PRESENCE);
 		if ((pval & NM_PRESENCE_MASK) != NM_PRESENCE_VALUE) {
-			if (! force_load) {
+			if (! force_ac97) {
 				printk(KERN_ERR "nm256: no ac97 is found!\n");
 				printk(KERN_ERR "  force the driver to load by passing in the module parameter\n");
 				printk(KERN_ERR "    force_ac97=1\n");
@@ -1471,8 +1468,8 @@ snd_nm256_create(snd_card_t *card, struct pci_dev *pci,
 	else
 		chip->buffer_size += NM_MAX_PLAYBACK_COEF_SIZE + NM_MAX_RECORD_COEF_SIZE;
 
-	if (buffertop >= chip->buffer_size && buffertop < chip->buffer_end)
-		chip->buffer_end = buffertop;
+	if (buffer_top >= chip->buffer_size && buffer_top < chip->buffer_end)
+		chip->buffer_end = buffer_top;
 	else {
 		/* get buffer end pointer from signature */
 		if ((err = snd_nm256_peek_for_sig(chip)) < 0)
@@ -1567,7 +1564,6 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 	snd_card_t *card;
 	nm256_t *chip;
 	int err;
-	unsigned int xbuffer_top;
 	struct nm256_quirk *q;
 	u16 subsystem_vendor, subsystem_device;
 
@@ -1611,9 +1607,7 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 	}
 
 	if (vaio_hack)
-		xbuffer_top = 0x25a800;	/* this avoids conflicts with XFree86 server */
-	else
-		xbuffer_top = buffer_top;
+		buffer_top = 0x25a800;	/* this avoids conflicts with XFree86 server */
 
 	if (playback_bufsize < 4)
 		playback_bufsize = 4;
@@ -1623,13 +1617,7 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 		capture_bufsize = 4;
 	if (capture_bufsize > 128)
 		capture_bufsize = 128;
-	if ((err = snd_nm256_create(card, pci,
-				    playback_bufsize * 1024, /* in bytes */
-				    capture_bufsize * 1024,  /* in bytes */
-				    force_ac97,
-				    xbuffer_top,
-				    use_cache,
-				    &chip)) < 0) {
+	if ((err = snd_nm256_create(card, pci, &chip)) < 0) {
 		snd_card_free(card);
 		return err;
 	}

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index e7aa15178453..089d23b4a002 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1673,7 +1673,6 @@ static void __devexit snd_nm256_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "NeoMagic 256",
-	.owner = THIS_MODULE,
 	.id_table = snd_nm256_ids,
 	.probe = snd_nm256_probe,
 	.remove = __devexit_p(snd_nm256_remove),

commit 99b359ba10a582148c6725f428a33ba5356dd993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 20 18:26:44 2005 +0200

    [ALSA] Add missing KERN_* suffix to printk
    
    Add missing KERN_* suffix to printk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index cccdc576b8a3..e7aa15178453 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -320,9 +320,9 @@ static inline void
 snd_nm256_write_buffer(nm256_t *chip, void *src, int offset, int size)
 {
 	offset -= chip->buffer_start;
-#ifdef SNDRV_CONFIG_DEBUG
+#ifdef CONFIG_SND_DEBUG
 	if (offset < 0 || offset >= chip->buffer_size) {
-		snd_printk("write_buffer invalid offset = %d size = %d\n", offset, size);
+		snd_printk(KERN_ERR "write_buffer invalid offset = %d size = %d\n", offset, size);
 		return;
 	}
 #endif
@@ -466,7 +466,7 @@ static int snd_nm256_acquire_irq(nm256_t *chip)
 	if (chip->irq < 0) {
 		if (request_irq(chip->pci->irq, chip->interrupt, SA_INTERRUPT|SA_SHIRQ,
 				chip->card->driver, (void*)chip)) {
-			snd_printk("unable to grab IRQ %d\n", chip->pci->irq);
+			snd_printk(KERN_ERR "unable to grab IRQ %d\n", chip->pci->irq);
 			up(&chip->irq_mutex);
 			return -EBUSY;
 		}
@@ -1273,7 +1273,7 @@ snd_nm256_peek_for_sig(nm256_t *chip)
 
 	temp = ioremap_nocache(chip->buffer_addr + chip->buffer_end - 0x400, 16);
 	if (temp == NULL) {
-		snd_printk("Unable to scan for card signature in video RAM\n");
+		snd_printk(KERN_ERR "Unable to scan for card signature in video RAM\n");
 		return -EBUSY;
 	}
 
@@ -1287,7 +1287,7 @@ snd_nm256_peek_for_sig(nm256_t *chip)
 		if (pointer == 0xffffffff ||
 		    pointer < chip->buffer_size ||
 		    pointer > chip->buffer_end) {
-			snd_printk("invalid signature found: 0x%x\n", pointer);
+			snd_printk(KERN_ERR "invalid signature found: 0x%x\n", pointer);
 			iounmap(temp);
 			return -ENODEV;
 		} else {
@@ -1424,14 +1424,14 @@ snd_nm256_create(snd_card_t *card, struct pci_dev *pci,
 	chip->res_cport = request_mem_region(chip->cport_addr, NM_PORT2_SIZE,
 					     card->driver);
 	if (chip->res_cport == NULL) {
-		snd_printk("memory region 0x%lx (size 0x%x) busy\n",
+		snd_printk(KERN_ERR "memory region 0x%lx (size 0x%x) busy\n",
 			   chip->cport_addr, NM_PORT2_SIZE);
 		err = -EBUSY;
 		goto __error;
 	}
 	chip->cport = ioremap_nocache(chip->cport_addr, NM_PORT2_SIZE);
 	if (chip->cport == NULL) {
-		snd_printk("unable to map control port %lx\n", chip->cport_addr);
+		snd_printk(KERN_ERR "unable to map control port %lx\n", chip->cport_addr);
 		err = -ENOMEM;
 		goto __error;
 	}
@@ -1489,7 +1489,7 @@ snd_nm256_create(snd_card_t *card, struct pci_dev *pci,
 					      chip->buffer_size,
 					      card->driver);
 	if (chip->res_buffer == NULL) {
-		snd_printk("nm256: buffer 0x%lx (size 0x%x) busy\n",
+		snd_printk(KERN_ERR "nm256: buffer 0x%lx (size 0x%x) busy\n",
 			   chip->buffer_addr, chip->buffer_size);
 		err = -EBUSY;
 		goto __error;
@@ -1497,7 +1497,7 @@ snd_nm256_create(snd_card_t *card, struct pci_dev *pci,
 	chip->buffer = ioremap_nocache(chip->buffer_addr, chip->buffer_size);
 	if (chip->buffer == NULL) {
 		err = -ENOMEM;
-		snd_printk("unable to map ring buffer at %lx\n", chip->buffer_addr);
+		snd_printk(KERN_ERR "unable to map ring buffer at %lx\n", chip->buffer_addr);
 		goto __error;
 	}
 
@@ -1605,7 +1605,7 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 		strcpy(card->driver, "NM256XL+");
 		break;
 	default:
-		snd_printk("invalid device id 0x%x\n", pci->device);
+		snd_printk(KERN_ERR "invalid device id 0x%x\n", pci->device);
 		snd_card_free(card);
 		return -EINVAL;
 	}

commit 8a3fb4d0ce5cc37a765d59b65a3b3714e5806dc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 20 17:10:49 2005 +0200

    [ALSA] Remove multi-card support for ali5451 and nm256
    
    Modules: Documentation,ALI5451 driver,NM256 driver
    
    Removed multi-card supports for ali5451 and nm256 drivers.
    They are supposed to be a single device.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index d0da9a53de03..cccdc576b8a3 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -52,41 +52,44 @@ MODULE_SUPPORTED_DEVICE("{{NeoMagic,NM256AV},"
  * some compile conditions.
  */
 
-static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
-static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
-static int playback_bufsize[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 16};
-static int capture_bufsize[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 16};
-static int force_ac97[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; /* disabled as default */
-static int buffer_top[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; /* not specified */
-static int use_cache[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; /* disabled */
-static int vaio_hack[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; /* disabled */
-static int reset_workaround[SNDRV_CARDS];
-static int reset_workaround_2[SNDRV_CARDS];
-
-module_param_array(index, int, NULL, 0444);
+static int index = SNDRV_DEFAULT_IDX1;	/* Index */
+static char *id = SNDRV_DEFAULT_STR1;	/* ID for this card */
+static int playback_bufsize = 16;
+static int capture_bufsize = 16;
+static int force_ac97;			/* disabled as default */
+static int buffer_top;			/* not specified */
+static int use_cache;			/* disabled */
+static int vaio_hack;			/* disabled */
+static int reset_workaround;
+static int reset_workaround_2;
+
+module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
-module_param_array(id, charp, NULL, 0444);
+module_param(id, charp, 0444);
 MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
-module_param_array(enable, bool, NULL, 0444);
-MODULE_PARM_DESC(enable, "Enable this soundcard.");
-module_param_array(playback_bufsize, int, NULL, 0444);
+module_param(playback_bufsize, int, 0444);
 MODULE_PARM_DESC(playback_bufsize, "DAC frame size in kB for " CARD_NAME " soundcard.");
-module_param_array(capture_bufsize, int, NULL, 0444);
+module_param(capture_bufsize, int, 0444);
 MODULE_PARM_DESC(capture_bufsize, "ADC frame size in kB for " CARD_NAME " soundcard.");
-module_param_array(force_ac97, bool, NULL, 0444);
+module_param(force_ac97, bool, 0444);
 MODULE_PARM_DESC(force_ac97, "Force to use AC97 codec for " CARD_NAME " soundcard.");
-module_param_array(buffer_top, int, NULL, 0444);
+module_param(buffer_top, int, 0444);
 MODULE_PARM_DESC(buffer_top, "Set the top address of audio buffer for " CARD_NAME " soundcard.");
-module_param_array(use_cache, bool, NULL, 0444);
+module_param(use_cache, bool, 0444);
 MODULE_PARM_DESC(use_cache, "Enable the cache for coefficient table access.");
-module_param_array(vaio_hack, bool, NULL, 0444);
+module_param(vaio_hack, bool, 0444);
 MODULE_PARM_DESC(vaio_hack, "Enable workaround for Sony VAIO notebooks.");
-module_param_array(reset_workaround, bool, NULL, 0444);
+module_param(reset_workaround, bool, 0444);
 MODULE_PARM_DESC(reset_workaround, "Enable AC97 RESET workaround for some laptops.");
-module_param_array(reset_workaround_2, bool, NULL, 0444);
+module_param(reset_workaround_2, bool, 0444);
 MODULE_PARM_DESC(reset_workaround_2, "Enable extended AC97 RESET workaround for some other laptops.");
 
+/* just for backward compatibility */
+static int enable;
+module_param(enable, bool, 0444);
+
+
+
 /*
  * hw definitions
  */
@@ -1561,7 +1564,6 @@ static struct nm256_quirk nm256_quirks[] __devinitdata = {
 static int __devinit snd_nm256_probe(struct pci_dev *pci,
 				     const struct pci_device_id *pci_id)
 {
-	static int dev;
 	snd_card_t *card;
 	nm256_t *chip;
 	int err;
@@ -1569,13 +1571,6 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 	struct nm256_quirk *q;
 	u16 subsystem_vendor, subsystem_device;
 
-	if (dev >= SNDRV_CARDS)
-		return -ENODEV;
-	if (!enable[dev]) {
-		dev++;
-		return -ENOENT;
-	}
-
 	pci_read_config_word(pci, PCI_SUBSYSTEM_VENDOR_ID, &subsystem_vendor);
 	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &subsystem_device);
 
@@ -1586,16 +1581,16 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 				printk(KERN_INFO "nm256: The device is blacklisted.  Loading stopped\n");
 				return -ENODEV;
 			case NM_RESET_WORKAROUND_2:
-				reset_workaround_2[dev] = 1;
+				reset_workaround_2 = 1;
 				/* Fall-through */
 			case NM_RESET_WORKAROUND:
-				reset_workaround[dev] = 1;
+				reset_workaround = 1;
 				break;
 			}
 		}
 	}
 
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	card = snd_card_new(index, id, THIS_MODULE, 0);
 	if (card == NULL)
 		return -ENOMEM;
 
@@ -1615,36 +1610,36 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 		return -EINVAL;
 	}
 
-	if (vaio_hack[dev])
+	if (vaio_hack)
 		xbuffer_top = 0x25a800;	/* this avoids conflicts with XFree86 server */
 	else
-		xbuffer_top = buffer_top[dev];
-
-	if (playback_bufsize[dev] < 4)
-		playback_bufsize[dev] = 4;
-	if (playback_bufsize[dev] > 128)
-		playback_bufsize[dev] = 128;
-	if (capture_bufsize[dev] < 4)
-		capture_bufsize[dev] = 4;
-	if (capture_bufsize[dev] > 128)
-		capture_bufsize[dev] = 128;
+		xbuffer_top = buffer_top;
+
+	if (playback_bufsize < 4)
+		playback_bufsize = 4;
+	if (playback_bufsize > 128)
+		playback_bufsize = 128;
+	if (capture_bufsize < 4)
+		capture_bufsize = 4;
+	if (capture_bufsize > 128)
+		capture_bufsize = 128;
 	if ((err = snd_nm256_create(card, pci,
-				    playback_bufsize[dev] * 1024, /* in bytes */
-				    capture_bufsize[dev] * 1024,  /* in bytes */
-				    force_ac97[dev],
+				    playback_bufsize * 1024, /* in bytes */
+				    capture_bufsize * 1024,  /* in bytes */
+				    force_ac97,
 				    xbuffer_top,
-				    use_cache[dev],
+				    use_cache,
 				    &chip)) < 0) {
 		snd_card_free(card);
 		return err;
 	}
 
-	if (reset_workaround[dev]) {
+	if (reset_workaround) {
 		snd_printdd(KERN_INFO "nm256: reset_workaround activated\n");
 		chip->reset_workaround = 1;
 	}
 
-	if (reset_workaround_2[dev]) {
+	if (reset_workaround_2) {
 		snd_printdd(KERN_INFO "nm256: reset_workaround_2 activated\n");
 		chip->reset_workaround_2 = 1;
 	}
@@ -1666,7 +1661,6 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 	}
 
 	pci_set_drvdata(pci, card);
-	dev++;
 	return 0;
 }
 

commit 47530cf44cb5f3945ed04a5ae65d06bf423cd97b
Author: John W. Linville <linville@tuxdriver.com>
Date:   Wed Oct 19 16:03:10 2005 +0200

    [ALSA] nm256: reset workaround for Latitude CSx
    
    Modules: NM256 driver
    
    The current snd-nm256 driver can cause Dell Latitude CSx laptops to
    lock-up during module (un)load.  I have isolated this to the writes to
    the control port register at offset 0x6cc which were not already
    protected by the existing reset_workaround.
    
    I tried grouping these writes with the existing reset_workaround
    clause, but that caused the driver to have (un)load problems on the
    Dell Latitude LS laptops.  So, I have implemented a reset_workaround_2
    clause (please feel free to suggest a better name!) to cover this
    situation and added a quirk entry for the CSx laptops.
    
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index ebfa38b51128..d0da9a53de03 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -62,6 +62,7 @@ static int buffer_top[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; /* not spe
 static int use_cache[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; /* disabled */
 static int vaio_hack[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; /* disabled */
 static int reset_workaround[SNDRV_CARDS];
+static int reset_workaround_2[SNDRV_CARDS];
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
@@ -83,6 +84,8 @@ module_param_array(vaio_hack, bool, NULL, 0444);
 MODULE_PARM_DESC(vaio_hack, "Enable workaround for Sony VAIO notebooks.");
 module_param_array(reset_workaround, bool, NULL, 0444);
 MODULE_PARM_DESC(reset_workaround, "Enable AC97 RESET workaround for some laptops.");
+module_param_array(reset_workaround_2, bool, NULL, 0444);
+MODULE_PARM_DESC(reset_workaround_2, "Enable extended AC97 RESET workaround for some other laptops.");
 
 /*
  * hw definitions
@@ -226,6 +229,7 @@ struct snd_nm256 {
 	unsigned int coeffs_current: 1;	/* coeff. table is loaded? */
 	unsigned int use_cache: 1;	/* use one big coef. table */
 	unsigned int reset_workaround: 1; /* Workaround for some laptops to avoid freeze */
+	unsigned int reset_workaround_2: 1; /* Extended workaround for some other laptops to avoid freeze */
 
 	int mixer_base;			/* register offset of ac97 mixer */
 	int mixer_status_offset;	/* offset of mixer status reg. */
@@ -1199,8 +1203,11 @@ snd_nm256_ac97_reset(ac97_t *ac97)
 		/* Dell latitude LS will lock up by this */
 		snd_nm256_writeb(chip, 0x6cc, 0x87);
 	}
-	snd_nm256_writeb(chip, 0x6cc, 0x80);
-	snd_nm256_writeb(chip, 0x6cc, 0x0);
+	if (! chip->reset_workaround_2) {
+		/* Dell latitude CSx will lock up by this */
+		snd_nm256_writeb(chip, 0x6cc, 0x80);
+		snd_nm256_writeb(chip, 0x6cc, 0x0);
+	}
 }
 
 /* create an ac97 mixer interface */
@@ -1536,7 +1543,7 @@ struct nm256_quirk {
 	int type;
 };
 
-enum { NM_BLACKLISTED, NM_RESET_WORKAROUND };
+enum { NM_BLACKLISTED, NM_RESET_WORKAROUND, NM_RESET_WORKAROUND_2 };
 
 static struct nm256_quirk nm256_quirks[] __devinitdata = {
 	/* HP omnibook 4150 has cs4232 codec internally */
@@ -1545,6 +1552,8 @@ static struct nm256_quirk nm256_quirks[] __devinitdata = {
 	{ .vendor = 0x104d, .device = 0x8041, .type = NM_RESET_WORKAROUND },
 	/* Dell Latitude LS */
 	{ .vendor = 0x1028, .device = 0x0080, .type = NM_RESET_WORKAROUND },
+	/* Dell Latitude CSx */
+	{ .vendor = 0x1028, .device = 0x0091, .type = NM_RESET_WORKAROUND_2 },
 	{ } /* terminator */
 };
 
@@ -1576,6 +1585,9 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 			case NM_BLACKLISTED:
 				printk(KERN_INFO "nm256: The device is blacklisted.  Loading stopped\n");
 				return -ENODEV;
+			case NM_RESET_WORKAROUND_2:
+				reset_workaround_2[dev] = 1;
+				/* Fall-through */
 			case NM_RESET_WORKAROUND:
 				reset_workaround[dev] = 1;
 				break;
@@ -1632,6 +1644,11 @@ static int __devinit snd_nm256_probe(struct pci_dev *pci,
 		chip->reset_workaround = 1;
 	}
 
+	if (reset_workaround_2[dev]) {
+		snd_printdd(KERN_INFO "nm256: reset_workaround_2 activated\n");
+		chip->reset_workaround_2 = 1;
+	}
+
 	if ((err = snd_nm256_pcm(chip, 0)) < 0 ||
 	    (err = snd_nm256_mixer(chip)) < 0) {
 		snd_card_free(card);

commit b1d5776d865951c213a1caaab5d8bf5de7615dbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:56:31 2005 +0200

    [ALSA] Remove vmalloc wrapper, kfree_nocheck()
    
    - Remove vmalloc wrapper
    - Add release_and_free_resource() to remove kfree_nocheck() from each driver
      and simplify the code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 5c55a3b1d121..ebfa38b51128 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1347,14 +1347,8 @@ static int snd_nm256_free(nm256_t *chip)
 		iounmap(chip->cport);
 	if (chip->buffer)
 		iounmap(chip->buffer);
-	if (chip->res_cport) {
-		release_resource(chip->res_cport);
-		kfree_nocheck(chip->res_cport);
-	}
-	if (chip->res_buffer) {
-		release_resource(chip->res_buffer);
-		kfree_nocheck(chip->res_buffer);
-	}
+	release_and_free_resource(chip->res_cport);
+	release_and_free_resource(chip->res_buffer);
 	if (chip->irq >= 0)
 		free_irq(chip->irq, (void*)chip);
 

commit 3bcd4649bca99ee9242f20d7da35e3f8741c6549
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 12 08:20:54 2005 +0200

    [ALSA] set owner field in struct pci_driver
    
    AD1889 driver,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CS46xx driver,EMU10K1/EMU10K2 driver
    HDA Intel driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    MIXART driver,NM256 driver,RME HDSP driver,RME9652 driver
    Trident driver,Digigram VX222 driver,YMFPCI driver
    Set the module owner field in each driver's struct pci_driver to get
    the driver symlink in the sysfs device directory.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index b44d56c2dd3d..5c55a3b1d121 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1668,6 +1668,7 @@ static void __devexit snd_nm256_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "NeoMagic 256",
+	.owner = THIS_MODULE,
 	.id_table = snd_nm256_ids,
 	.probe = snd_nm256_probe,
 	.remove = __devexit_p(snd_nm256_remove),

commit e560d8d8368ad8b6161839984b253de622863265
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:21:46 2005 +0200

    [ALSA] Replace with kzalloc() - pci stuff
    
    AD1889 driver,ATIIXP driver,ATIIXP-modem driver,AZT3328 driver
    BT87x driver,CMIPCI driver,CS4281 driver,ENS1370/1+ driver
    ES1938 driver,ES1968 driver,FM801 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,SonicVibes driver,VIA82xx driver
    VIA82xx-modem driver,AC97 Codec,AK4531 codec,au88x0 driver
    CA0106 driver,CS46xx driver,EMU10K1/EMU10K2 driver,HDA Codec driver
    HDA generic driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,Trident driver,YMFPCI driver
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 542b58e4bf44..b44d56c2dd3d 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1389,7 +1389,7 @@ snd_nm256_create(snd_card_t *card, struct pci_dev *pci,
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 
-	chip = kcalloc(1, sizeof(*chip), GFP_KERNEL);
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
 	if (chip == NULL) {
 		pci_disable_device(pci);
 		return -ENOMEM;

commit 8cdfd2519c6c9a1e6057dc5970b2542b35895738
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 7 14:08:11 2005 +0200

    [ALSA] Remove superfluous PCI ID definitions
    
    CS46xx driver,EMU10K1/EMU10K2 driver,PCM Midlevel,Trident driver
    YMFPCI driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,RME32 driver,RME96 driver
    SonicVibes driver,VIA82xx driver,ALI5451 driver,ICE1712 driver
    ICE1724 driver,NM256 driver,RME HDSP driver,RME9652 driver
    Remove superfluous PCI ID definitions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 24f146b6ebab..542b58e4bf44 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -259,21 +259,6 @@ struct snd_nm256 {
 /*
  * PCI ids
  */
-
-#ifndef PCI_VENDOR_ID_NEOMAGIC
-#define PCI_VENDOR_ID_NEOMEGIC 0x10c8
-#endif
-#ifndef PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO
-#define PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO 0x8005
-#endif
-#ifndef PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO
-#define PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO 0x8006
-#endif
-#ifndef PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO
-#define PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO 0x8016
-#endif
-
-
 static struct pci_device_id snd_nm256_ids[] = {
 	{PCI_VENDOR_ID_NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},

commit 4d23359b7ec8b03da2154df935af7d625075f6cf
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 5 10:35:20 2005 +0200

    [ALSA] sparse address space annotations
    
    ALSA Core,RawMidi Midlevel,ALSA<-OSS emulation,ALSA sequencer
    RME32 driver,RME96 driver,EMU10K1/EMU10K2 driver,NM256 driver
    Add sparse annotations where we do strange this with __iomem/__user
    pointers.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 2bbeb10ff7c4..24f146b6ebab 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -840,7 +840,7 @@ static void snd_nm256_setup_stream(nm256_t *chip, nm256_stream_t *s,
 	runtime->hw = *hw_ptr;
 	runtime->hw.buffer_bytes_max = s->bufsize;
 	runtime->hw.period_bytes_max = s->bufsize / 2;
-	runtime->dma_area = (void*) s->bufptr;
+	runtime->dma_area = (void __force *) s->bufptr;
 	runtime->dma_addr = s->bufptr_addr;
 	runtime->dma_bytes = s->bufsize;
 	runtime->private_data = s;

commit 1204de32d0df87892e56062042e25c775ca0e08c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 16 16:54:12 2005 +0200

    [ALSA] nm256 - Fix PM and irq handling
    
    NM256 driver
    - Fixed the PCM resume - restoring the rate setting
    - Fixed the handling of buggy irqs
    - Dynamically acquire/release irq handler to make the driver more robust
      to unknown irq storms (as OSS driver does).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 7eb20b8f89f6..2bbeb10ff7c4 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -189,6 +189,7 @@ struct snd_nm256_stream {
 	nm256_t *chip;
 	snd_pcm_substream_t *substream;
 	int running;
+	int suspended;
 	
 	u32 buf;	/* offset from chip->buffer */
 	int bufsize;	/* buffer size in bytes */
@@ -231,8 +232,10 @@ struct snd_nm256 {
 	int mixer_status_mask;		/* bit mask to test the mixer status */
 
 	int irq;
+	int irq_acks;
 	irqreturn_t (*interrupt)(int, void *, struct pt_regs *);
 	int badintrcount;		/* counter to check bogus interrupts */
+	struct semaphore irq_mutex;
 
 	nm256_stream_t streams[2];
 
@@ -464,6 +467,37 @@ snd_nm256_set_format(nm256_t *chip, nm256_stream_t *s, snd_pcm_substream_t *subs
 	}
 }
 
+/* acquire interrupt */
+static int snd_nm256_acquire_irq(nm256_t *chip)
+{
+	down(&chip->irq_mutex);
+	if (chip->irq < 0) {
+		if (request_irq(chip->pci->irq, chip->interrupt, SA_INTERRUPT|SA_SHIRQ,
+				chip->card->driver, (void*)chip)) {
+			snd_printk("unable to grab IRQ %d\n", chip->pci->irq);
+			up(&chip->irq_mutex);
+			return -EBUSY;
+		}
+		chip->irq = chip->pci->irq;
+	}
+	chip->irq_acks++;
+	up(&chip->irq_mutex);
+	return 0;
+}
+
+/* release interrupt */
+static void snd_nm256_release_irq(nm256_t *chip)
+{
+	down(&chip->irq_mutex);
+	if (chip->irq_acks > 0)
+		chip->irq_acks--;
+	if (chip->irq_acks == 0 && chip->irq >= 0) {
+		free_irq(chip->irq, (void*)chip);
+		chip->irq = -1;
+	}
+	up(&chip->irq_mutex);
+}
+
 /*
  * start / stop
  */
@@ -538,15 +572,19 @@ snd_nm256_playback_trigger(snd_pcm_substream_t *substream, int cmd)
 
 	spin_lock(&chip->reg_lock);
 	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
+		s->suspended = 0;
+		/* fallthru */
+	case SNDRV_PCM_TRIGGER_START:
 		if (! s->running) {
 			snd_nm256_playback_start(chip, s, substream);
 			s->running = 1;
 		}
 		break;
-	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
+		s->suspended = 1;
+		/* fallthru */
+	case SNDRV_PCM_TRIGGER_STOP:
 		if (s->running) {
 			snd_nm256_playback_stop(chip);
 			s->running = 0;
@@ -818,6 +856,8 @@ snd_nm256_playback_open(snd_pcm_substream_t *substream)
 {
 	nm256_t *chip = snd_pcm_substream_chip(substream);
 
+	if (snd_nm256_acquire_irq(chip) < 0)
+		return -EBUSY;
 	snd_nm256_setup_stream(chip, &chip->streams[SNDRV_PCM_STREAM_PLAYBACK],
 			       substream, &snd_nm256_playback);
 	return 0;
@@ -828,6 +868,8 @@ snd_nm256_capture_open(snd_pcm_substream_t *substream)
 {
 	nm256_t *chip = snd_pcm_substream_chip(substream);
 
+	if (snd_nm256_acquire_irq(chip) < 0)
+		return -EBUSY;
 	snd_nm256_setup_stream(chip, &chip->streams[SNDRV_PCM_STREAM_CAPTURE],
 			       substream, &snd_nm256_capture);
 	return 0;
@@ -839,6 +881,9 @@ snd_nm256_capture_open(snd_pcm_substream_t *substream)
 static int
 snd_nm256_playback_close(snd_pcm_substream_t *substream)
 {
+	nm256_t *chip = snd_pcm_substream_chip(substream);
+
+	snd_nm256_release_irq(chip);
 	return 0;
 }
 
@@ -846,6 +891,9 @@ snd_nm256_playback_close(snd_pcm_substream_t *substream)
 static int
 snd_nm256_capture_close(snd_pcm_substream_t *substream)
 {
+	nm256_t *chip = snd_pcm_substream_chip(substream);
+
+	snd_nm256_release_irq(chip);
 	return 0;
 }
 
@@ -915,18 +963,16 @@ snd_nm256_pcm(nm256_t *chip, int device)
 static void
 snd_nm256_init_chip(nm256_t *chip)
 {
-	spin_lock_irq(&chip->reg_lock);
 	/* Reset everything. */
 	snd_nm256_writeb(chip, 0x0, 0x11);
 	snd_nm256_writew(chip, 0x214, 0);
 	/* stop sounds.. */
 	//snd_nm256_playback_stop(chip);
 	//snd_nm256_capture_stop(chip);
-	spin_unlock_irq(&chip->reg_lock);
 }
 
 
-static inline void
+static irqreturn_t
 snd_nm256_intr_check(nm256_t *chip)
 {
 	if (chip->badintrcount++ > 1000) {
@@ -947,7 +993,9 @@ snd_nm256_intr_check(nm256_t *chip)
 		if (chip->streams[SNDRV_PCM_STREAM_CAPTURE].running)
 			snd_nm256_capture_stop(chip);
 		chip->badintrcount = 0;
+		return IRQ_HANDLED;
 	}
+	return IRQ_NONE;
 }
 
 /* 
@@ -969,10 +1017,8 @@ snd_nm256_interrupt(int irq, void *dev_id, struct pt_regs *dummy)
 	status = snd_nm256_readw(chip, NM_INT_REG);
 
 	/* Not ours. */
-	if (status == 0) {
-		snd_nm256_intr_check(chip);
-		return IRQ_NONE;
-	}
+	if (status == 0)
+		return snd_nm256_intr_check(chip);
 
 	chip->badintrcount = 0;
 
@@ -1036,10 +1082,8 @@ snd_nm256_interrupt_zx(int irq, void *dev_id, struct pt_regs *dummy)
 	status = snd_nm256_readl(chip, NM_INT_REG);
 
 	/* Not ours. */
-	if (status == 0) {
-		snd_nm256_intr_check(chip);
-		return IRQ_NONE;
-	}
+	if (status == 0)
+		return snd_nm256_intr_check(chip);
 
 	chip->badintrcount = 0;
 
@@ -1192,7 +1236,7 @@ snd_nm256_mixer(nm256_t *chip)
 		AC97_PC_BEEP, AC97_PHONE, AC97_MIC, AC97_LINE, AC97_CD,
 		AC97_VIDEO, AC97_AUX, AC97_PCM, AC97_REC_SEL,
 		AC97_REC_GAIN, AC97_GENERAL_PURPOSE, AC97_3D_CONTROL,
-		AC97_EXTENDED_ID,
+		/*AC97_EXTENDED_ID,*/
 		AC97_VENDOR_ID1, AC97_VENDOR_ID2,
 		-1
 	};
@@ -1206,6 +1250,7 @@ snd_nm256_mixer(nm256_t *chip)
 	for (i = 0; mixer_regs[i] >= 0; i++)
 		set_bit(mixer_regs[i], ac97.reg_accessed);
 	ac97.private_data = chip;
+	pbus->no_vra = 1;
 	err = snd_ac97_mixer(pbus, &ac97, &chip->ac97);
 	if (err < 0)
 		return err;
@@ -1281,6 +1326,7 @@ static int nm256_suspend(snd_card_t *card, pm_message_t state)
 static int nm256_resume(snd_card_t *card)
 {
 	nm256_t *chip = card->pm_private_data;
+	int i;
 
 	/* Perform a full reset on the hardware */
 	pci_enable_device(chip->pci);
@@ -1289,6 +1335,15 @@ static int nm256_resume(snd_card_t *card)
 	/* restore ac97 */
 	snd_ac97_resume(chip->ac97);
 
+	for (i = 0; i < 2; i++) {
+		nm256_stream_t *s = &chip->streams[i];
+		if (s->substream && s->suspended) {
+			spin_lock_irq(&chip->reg_lock);
+			snd_nm256_set_format(chip, s, s->substream);
+			spin_unlock_irq(&chip->reg_lock);
+		}
+	}
+
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -1360,6 +1415,7 @@ snd_nm256_create(snd_card_t *card, struct pci_dev *pci,
 	chip->use_cache = usecache;
 	spin_lock_init(&chip->reg_lock);
 	chip->irq = -1;
+	init_MUTEX(&chip->irq_mutex);
 
 	chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize = play_bufsize;
 	chip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize = capt_bufsize;
@@ -1470,15 +1526,6 @@ snd_nm256_create(snd_card_t *card, struct pci_dev *pci,
 		chip->coeff_buf[SNDRV_PCM_STREAM_CAPTURE] = addr;
 	}
 
-	/* acquire interrupt */
-	if (request_irq(pci->irq, chip->interrupt, SA_INTERRUPT|SA_SHIRQ,
-			card->driver, (void*)chip)) {
-		err = -EBUSY;
-		snd_printk("unable to grab IRQ %d\n", pci->irq);
-		goto __error;
-	}
-	chip->irq = pci->irq;
-
 	/* Fixed setting. */
 	chip->mixer_base = NM_MIXER_OFFSET;
 

commit 77933d7276ee8fa0e2947641941a6f7a100a327b
Author: Jesper Juhl <juhl@dif.dk>
Date:   Wed Jul 27 11:46:09 2005 -0700

    [PATCH] clean up inline static vs static inline
    
    `gcc -W' likes to complain if the static keyword is not at the beginning of
    the declaration.  This patch fixes all remaining occurrences of "inline
    static" up with "static inline" in the entire kernel tree (140 occurrences in
    47 files).
    
    While making this change I came across a few lines with trailing whitespace
    that I also fixed up, I have also added or removed a blank line or two here
    and there, but there are no functional changes in the patch.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 8a52091f8552..7eb20b8f89f6 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -285,43 +285,43 @@ MODULE_DEVICE_TABLE(pci, snd_nm256_ids);
  * lowlvel stuffs
  */
 
-inline static u8
+static inline u8
 snd_nm256_readb(nm256_t *chip, int offset)
 {
 	return readb(chip->cport + offset);
 }
 
-inline static u16
+static inline u16
 snd_nm256_readw(nm256_t *chip, int offset)
 {
 	return readw(chip->cport + offset);
 }
 
-inline static u32
+static inline u32
 snd_nm256_readl(nm256_t *chip, int offset)
 {
 	return readl(chip->cport + offset);
 }
 
-inline static void
+static inline void
 snd_nm256_writeb(nm256_t *chip, int offset, u8 val)
 {
 	writeb(val, chip->cport + offset);
 }
 
-inline static void
+static inline void
 snd_nm256_writew(nm256_t *chip, int offset, u16 val)
 {
 	writew(val, chip->cport + offset);
 }
 
-inline static void
+static inline void
 snd_nm256_writel(nm256_t *chip, int offset, u32 val)
 {
 	writel(val, chip->cport + offset);
 }
 
-inline static void
+static inline void
 snd_nm256_write_buffer(nm256_t *chip, void *src, int offset, int size)
 {
 	offset -= chip->buffer_start;
@@ -926,7 +926,7 @@ snd_nm256_init_chip(nm256_t *chip)
 }
 
 
-inline static void
+static inline void
 snd_nm256_intr_check(nm256_t *chip)
 {
 	if (chip->badintrcount++ > 1000) {

commit 01d25d460a3b28aab537fab9a0038d1b5832ce28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 11 16:58:24 2005 +0200

    [ALSA] Replace pci_module_init() with pci_register_driver()
    
    Documentation,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CA0106 driver,CS46xx driver
    EMU10K1/EMU10K2 driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,RME HDSP driver
    RME9652 driver,Trident driver,Digigram VX222 driver,YMFPCI driver
    Replace the obsolete pci_module_init() with pci_register_driver().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
index 356fbeac6f9e..8a52091f8552 100644
--- a/sound/pci/nm256/nm256.c
+++ b/sound/pci/nm256/nm256.c
@@ -1645,7 +1645,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_nm256_init(void)
 {
-	return pci_module_init(&driver);
+	return pci_register_driver(&driver);
 }
 
 static void __exit alsa_card_nm256_exit(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/nm256/nm256.c b/sound/pci/nm256/nm256.c
new file mode 100644
index 000000000000..356fbeac6f9e
--- /dev/null
+++ b/sound/pci/nm256/nm256.c
@@ -0,0 +1,1657 @@
+/* 
+ * Driver for NeoMagic 256AV and 256ZX chipsets.
+ * Copyright (c) 2000 by Takashi Iwai <tiwai@suse.de>
+ *
+ * Based on nm256_audio.c OSS driver in linux kernel.
+ * The original author of OSS nm256 driver wishes to remain anonymous,
+ * so I just put my acknoledgment to him/her here.
+ * The original author's web page is found at
+ *	http://www.uglx.org/sony.html
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+  
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+
+#define CARD_NAME "NeoMagic 256AV/ZX"
+#define DRIVER_NAME "NM256"
+
+MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
+MODULE_DESCRIPTION("NeoMagic NM256AV/ZX");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{NeoMagic,NM256AV},"
+		"{NeoMagic,NM256ZX}}");
+
+/*
+ * some compile conditions.
+ */
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+static int playback_bufsize[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 16};
+static int capture_bufsize[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 16};
+static int force_ac97[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; /* disabled as default */
+static int buffer_top[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; /* not specified */
+static int use_cache[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; /* disabled */
+static int vaio_hack[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0}; /* disabled */
+static int reset_workaround[SNDRV_CARDS];
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable this soundcard.");
+module_param_array(playback_bufsize, int, NULL, 0444);
+MODULE_PARM_DESC(playback_bufsize, "DAC frame size in kB for " CARD_NAME " soundcard.");
+module_param_array(capture_bufsize, int, NULL, 0444);
+MODULE_PARM_DESC(capture_bufsize, "ADC frame size in kB for " CARD_NAME " soundcard.");
+module_param_array(force_ac97, bool, NULL, 0444);
+MODULE_PARM_DESC(force_ac97, "Force to use AC97 codec for " CARD_NAME " soundcard.");
+module_param_array(buffer_top, int, NULL, 0444);
+MODULE_PARM_DESC(buffer_top, "Set the top address of audio buffer for " CARD_NAME " soundcard.");
+module_param_array(use_cache, bool, NULL, 0444);
+MODULE_PARM_DESC(use_cache, "Enable the cache for coefficient table access.");
+module_param_array(vaio_hack, bool, NULL, 0444);
+MODULE_PARM_DESC(vaio_hack, "Enable workaround for Sony VAIO notebooks.");
+module_param_array(reset_workaround, bool, NULL, 0444);
+MODULE_PARM_DESC(reset_workaround, "Enable AC97 RESET workaround for some laptops.");
+
+/*
+ * hw definitions
+ */
+
+/* The BIOS signature. */
+#define NM_SIGNATURE 0x4e4d0000
+/* Signature mask. */
+#define NM_SIG_MASK 0xffff0000
+
+/* Size of the second memory area. */
+#define NM_PORT2_SIZE 4096
+
+/* The base offset of the mixer in the second memory area. */
+#define NM_MIXER_OFFSET 0x600
+
+/* The maximum size of a coefficient entry. */
+#define NM_MAX_PLAYBACK_COEF_SIZE	0x5000
+#define NM_MAX_RECORD_COEF_SIZE		0x1260
+
+/* The interrupt register. */
+#define NM_INT_REG 0xa04
+/* And its bits. */
+#define NM_PLAYBACK_INT 0x40
+#define NM_RECORD_INT 0x100
+#define NM_MISC_INT_1 0x4000
+#define NM_MISC_INT_2 0x1
+#define NM_ACK_INT(chip, X) snd_nm256_writew(chip, NM_INT_REG, (X) << 1)
+
+/* The AV's "mixer ready" status bit and location. */
+#define NM_MIXER_STATUS_OFFSET 0xa04
+#define NM_MIXER_READY_MASK 0x0800
+#define NM_MIXER_PRESENCE 0xa06
+#define NM_PRESENCE_MASK 0x0050
+#define NM_PRESENCE_VALUE 0x0040
+
+/*
+ * For the ZX.  It uses the same interrupt register, but it holds 32
+ * bits instead of 16.
+ */
+#define NM2_PLAYBACK_INT 0x10000
+#define NM2_RECORD_INT 0x80000
+#define NM2_MISC_INT_1 0x8
+#define NM2_MISC_INT_2 0x2
+#define NM2_ACK_INT(chip, X) snd_nm256_writel(chip, NM_INT_REG, (X))
+
+/* The ZX's "mixer ready" status bit and location. */
+#define NM2_MIXER_STATUS_OFFSET 0xa06
+#define NM2_MIXER_READY_MASK 0x0800
+
+/* The playback registers start from here. */
+#define NM_PLAYBACK_REG_OFFSET 0x0
+/* The record registers start from here. */
+#define NM_RECORD_REG_OFFSET 0x200
+
+/* The rate register is located 2 bytes from the start of the register area. */
+#define NM_RATE_REG_OFFSET 2
+
+/* Mono/stereo flag, number of bits on playback, and rate mask. */
+#define NM_RATE_STEREO 1
+#define NM_RATE_BITS_16 2
+#define NM_RATE_MASK 0xf0
+
+/* Playback enable register. */
+#define NM_PLAYBACK_ENABLE_REG (NM_PLAYBACK_REG_OFFSET + 0x1)
+#define NM_PLAYBACK_ENABLE_FLAG 1
+#define NM_PLAYBACK_ONESHOT 2
+#define NM_PLAYBACK_FREERUN 4
+
+/* Mutes the audio output. */
+#define NM_AUDIO_MUTE_REG (NM_PLAYBACK_REG_OFFSET + 0x18)
+#define NM_AUDIO_MUTE_LEFT 0x8000
+#define NM_AUDIO_MUTE_RIGHT 0x0080
+
+/* Recording enable register. */
+#define NM_RECORD_ENABLE_REG (NM_RECORD_REG_OFFSET + 0)
+#define NM_RECORD_ENABLE_FLAG 1
+#define NM_RECORD_FREERUN 2
+
+/* coefficient buffer pointer */
+#define NM_COEFF_START_OFFSET	0x1c
+#define NM_COEFF_END_OFFSET	0x20
+
+/* DMA buffer offsets */
+#define NM_RBUFFER_START (NM_RECORD_REG_OFFSET + 0x4)
+#define NM_RBUFFER_END   (NM_RECORD_REG_OFFSET + 0x10)
+#define NM_RBUFFER_WMARK (NM_RECORD_REG_OFFSET + 0xc)
+#define NM_RBUFFER_CURRP (NM_RECORD_REG_OFFSET + 0x8)
+
+#define NM_PBUFFER_START (NM_PLAYBACK_REG_OFFSET + 0x4)
+#define NM_PBUFFER_END   (NM_PLAYBACK_REG_OFFSET + 0x14)
+#define NM_PBUFFER_WMARK (NM_PLAYBACK_REG_OFFSET + 0xc)
+#define NM_PBUFFER_CURRP (NM_PLAYBACK_REG_OFFSET + 0x8)
+
+/*
+ * type definitions
+ */
+
+typedef struct snd_nm256 nm256_t;
+typedef struct snd_nm256_stream nm256_stream_t;
+
+struct snd_nm256_stream {
+
+	nm256_t *chip;
+	snd_pcm_substream_t *substream;
+	int running;
+	
+	u32 buf;	/* offset from chip->buffer */
+	int bufsize;	/* buffer size in bytes */
+	void __iomem *bufptr;		/* mapped pointer */
+	unsigned long bufptr_addr;	/* physical address of the mapped pointer */
+
+	int dma_size;		/* buffer size of the substream in bytes */
+	int period_size;	/* period size in bytes */
+	int periods;		/* # of periods */
+	int shift;		/* bit shifts */
+	int cur_period;		/* current period # */
+
+};
+
+struct snd_nm256 {
+	
+	snd_card_t *card;
+
+	void __iomem *cport;		/* control port */
+	struct resource *res_cport;	/* its resource */
+	unsigned long cport_addr;	/* physical address */
+
+	void __iomem *buffer;		/* buffer */
+	struct resource *res_buffer;	/* its resource */
+	unsigned long buffer_addr;	/* buffer phyiscal address */
+
+	u32 buffer_start;		/* start offset from pci resource 0 */
+	u32 buffer_end;			/* end offset */
+	u32 buffer_size;		/* total buffer size */
+
+	u32 all_coeff_buf;		/* coefficient buffer */
+	u32 coeff_buf[2];		/* coefficient buffer for each stream */
+
+	unsigned int coeffs_current: 1;	/* coeff. table is loaded? */
+	unsigned int use_cache: 1;	/* use one big coef. table */
+	unsigned int reset_workaround: 1; /* Workaround for some laptops to avoid freeze */
+
+	int mixer_base;			/* register offset of ac97 mixer */
+	int mixer_status_offset;	/* offset of mixer status reg. */
+	int mixer_status_mask;		/* bit mask to test the mixer status */
+
+	int irq;
+	irqreturn_t (*interrupt)(int, void *, struct pt_regs *);
+	int badintrcount;		/* counter to check bogus interrupts */
+
+	nm256_stream_t streams[2];
+
+	ac97_t *ac97;
+
+	snd_pcm_t *pcm;
+
+	struct pci_dev *pci;
+
+	spinlock_t reg_lock;
+
+};
+
+
+/*
+ * include coefficient table
+ */
+#include "nm256_coef.c"
+
+
+/*
+ * PCI ids
+ */
+
+#ifndef PCI_VENDOR_ID_NEOMAGIC
+#define PCI_VENDOR_ID_NEOMEGIC 0x10c8
+#endif
+#ifndef PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO
+#define PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO 0x8005
+#endif
+#ifndef PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO
+#define PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO 0x8006
+#endif
+#ifndef PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO
+#define PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO 0x8016
+#endif
+
+
+static struct pci_device_id snd_nm256_ids[] = {
+	{PCI_VENDOR_ID_NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_NEOMAGIC, PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0,},
+};
+
+MODULE_DEVICE_TABLE(pci, snd_nm256_ids);
+
+
+/*
+ * lowlvel stuffs
+ */
+
+inline static u8
+snd_nm256_readb(nm256_t *chip, int offset)
+{
+	return readb(chip->cport + offset);
+}
+
+inline static u16
+snd_nm256_readw(nm256_t *chip, int offset)
+{
+	return readw(chip->cport + offset);
+}
+
+inline static u32
+snd_nm256_readl(nm256_t *chip, int offset)
+{
+	return readl(chip->cport + offset);
+}
+
+inline static void
+snd_nm256_writeb(nm256_t *chip, int offset, u8 val)
+{
+	writeb(val, chip->cport + offset);
+}
+
+inline static void
+snd_nm256_writew(nm256_t *chip, int offset, u16 val)
+{
+	writew(val, chip->cport + offset);
+}
+
+inline static void
+snd_nm256_writel(nm256_t *chip, int offset, u32 val)
+{
+	writel(val, chip->cport + offset);
+}
+
+inline static void
+snd_nm256_write_buffer(nm256_t *chip, void *src, int offset, int size)
+{
+	offset -= chip->buffer_start;
+#ifdef SNDRV_CONFIG_DEBUG
+	if (offset < 0 || offset >= chip->buffer_size) {
+		snd_printk("write_buffer invalid offset = %d size = %d\n", offset, size);
+		return;
+	}
+#endif
+	memcpy_toio(chip->buffer + offset, src, size);
+}
+
+/*
+ * coefficient handlers -- what a magic!
+ */
+
+static u16
+snd_nm256_get_start_offset(int which)
+{
+	u16 offset = 0;
+	while (which-- > 0)
+		offset += coefficient_sizes[which];
+	return offset;
+}
+
+static void
+snd_nm256_load_one_coefficient(nm256_t *chip, int stream, u32 port, int which)
+{
+	u32 coeff_buf = chip->coeff_buf[stream];
+	u16 offset = snd_nm256_get_start_offset(which);
+	u16 size = coefficient_sizes[which];
+
+	snd_nm256_write_buffer(chip, coefficients + offset, coeff_buf, size);
+	snd_nm256_writel(chip, port, coeff_buf);
+	/* ???  Record seems to behave differently than playback.  */
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		size--;
+	snd_nm256_writel(chip, port + 4, coeff_buf + size);
+}
+
+static void
+snd_nm256_load_coefficient(nm256_t *chip, int stream, int number)
+{
+	/* The enable register for the specified engine.  */
+	u32 poffset = (stream == SNDRV_PCM_STREAM_CAPTURE ? NM_RECORD_ENABLE_REG : NM_PLAYBACK_ENABLE_REG);
+	u32 addr = NM_COEFF_START_OFFSET;
+
+	addr += (stream == SNDRV_PCM_STREAM_CAPTURE ? NM_RECORD_REG_OFFSET : NM_PLAYBACK_REG_OFFSET);
+
+	if (snd_nm256_readb(chip, poffset) & 1) {
+		snd_printd("NM256: Engine was enabled while loading coefficients!\n");
+		return;
+	}
+
+	/* The recording engine uses coefficient values 8-15.  */
+	number &= 7;
+	if (stream == SNDRV_PCM_STREAM_CAPTURE)
+		number += 8;
+
+	if (! chip->use_cache) {
+		snd_nm256_load_one_coefficient(chip, stream, addr, number);
+		return;
+	}
+	if (! chip->coeffs_current) {
+		snd_nm256_write_buffer(chip, coefficients, chip->all_coeff_buf,
+				       NM_TOTAL_COEFF_COUNT * 4);
+		chip->coeffs_current = 1;
+	} else {
+		u32 base = chip->all_coeff_buf;
+		u32 offset = snd_nm256_get_start_offset(number);
+		u32 end_offset = offset + coefficient_sizes[number];
+		snd_nm256_writel(chip, addr, base + offset);
+		if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+			end_offset--;
+		snd_nm256_writel(chip, addr + 4, base + end_offset);
+	}
+}
+
+
+/* The actual rates supported by the card. */
+static unsigned int samplerates[8] = {
+	8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000,
+};
+static snd_pcm_hw_constraint_list_t constraints_rates = {
+	.count = ARRAY_SIZE(samplerates), 
+	.list = samplerates,
+	.mask = 0,
+};
+
+/*
+ * return the index of the target rate
+ */
+static int
+snd_nm256_fixed_rate(unsigned int rate)
+{
+	unsigned int i;
+	for (i = 0; i < ARRAY_SIZE(samplerates); i++) {
+		if (rate == samplerates[i])
+			return i;
+	}
+	snd_BUG();
+	return 0;
+}
+
+/*
+ * set sample rate and format
+ */
+static void
+snd_nm256_set_format(nm256_t *chip, nm256_stream_t *s, snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int rate_index = snd_nm256_fixed_rate(runtime->rate);
+	unsigned char ratebits = (rate_index << 4) & NM_RATE_MASK;
+
+	s->shift = 0;
+	if (snd_pcm_format_width(runtime->format) == 16) {
+		ratebits |= NM_RATE_BITS_16;
+		s->shift++;
+	}
+	if (runtime->channels > 1) {
+		ratebits |= NM_RATE_STEREO;
+		s->shift++;
+	}
+
+	runtime->rate = samplerates[rate_index];
+
+	switch (substream->stream) {
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		snd_nm256_load_coefficient(chip, 0, rate_index); /* 0 = playback */
+		snd_nm256_writeb(chip,
+				 NM_PLAYBACK_REG_OFFSET + NM_RATE_REG_OFFSET,
+				 ratebits);
+		break;
+	case SNDRV_PCM_STREAM_CAPTURE:
+		snd_nm256_load_coefficient(chip, 1, rate_index); /* 1 = record */
+		snd_nm256_writeb(chip,
+				 NM_RECORD_REG_OFFSET + NM_RATE_REG_OFFSET,
+				 ratebits);
+		break;
+	}
+}
+
+/*
+ * start / stop
+ */
+
+/* update the watermark (current period) */
+static void snd_nm256_pcm_mark(nm256_t *chip, nm256_stream_t *s, int reg)
+{
+	s->cur_period++;
+	s->cur_period %= s->periods;
+	snd_nm256_writel(chip, reg, s->buf + s->cur_period * s->period_size);
+}
+
+#define snd_nm256_playback_mark(chip, s) snd_nm256_pcm_mark(chip, s, NM_PBUFFER_WMARK)
+#define snd_nm256_capture_mark(chip, s)  snd_nm256_pcm_mark(chip, s, NM_RBUFFER_WMARK)
+
+static void
+snd_nm256_playback_start(nm256_t *chip, nm256_stream_t *s, snd_pcm_substream_t *substream)
+{
+	/* program buffer pointers */
+	snd_nm256_writel(chip, NM_PBUFFER_START, s->buf);
+	snd_nm256_writel(chip, NM_PBUFFER_END, s->buf + s->dma_size - (1 << s->shift));
+	snd_nm256_writel(chip, NM_PBUFFER_CURRP, s->buf);
+	snd_nm256_playback_mark(chip, s);
+
+	/* Enable playback engine and interrupts. */
+	snd_nm256_writeb(chip, NM_PLAYBACK_ENABLE_REG,
+			 NM_PLAYBACK_ENABLE_FLAG | NM_PLAYBACK_FREERUN);
+	/* Enable both channels. */
+	snd_nm256_writew(chip, NM_AUDIO_MUTE_REG, 0x0);
+}
+
+static void
+snd_nm256_capture_start(nm256_t *chip, nm256_stream_t *s, snd_pcm_substream_t *substream)
+{
+	/* program buffer pointers */
+	snd_nm256_writel(chip, NM_RBUFFER_START, s->buf);
+	snd_nm256_writel(chip, NM_RBUFFER_END, s->buf + s->dma_size);
+	snd_nm256_writel(chip, NM_RBUFFER_CURRP, s->buf);
+	snd_nm256_capture_mark(chip, s);
+
+	/* Enable playback engine and interrupts. */
+	snd_nm256_writeb(chip, NM_RECORD_ENABLE_REG,
+			 NM_RECORD_ENABLE_FLAG | NM_RECORD_FREERUN);
+}
+
+/* Stop the play engine. */
+static void
+snd_nm256_playback_stop(nm256_t *chip)
+{
+	/* Shut off sound from both channels. */
+	snd_nm256_writew(chip, NM_AUDIO_MUTE_REG,
+			 NM_AUDIO_MUTE_LEFT | NM_AUDIO_MUTE_RIGHT);
+	/* Disable play engine. */
+	snd_nm256_writeb(chip, NM_PLAYBACK_ENABLE_REG, 0);
+}
+
+static void
+snd_nm256_capture_stop(nm256_t *chip)
+{
+	/* Disable recording engine. */
+	snd_nm256_writeb(chip, NM_RECORD_ENABLE_REG, 0);
+}
+
+static int
+snd_nm256_playback_trigger(snd_pcm_substream_t *substream, int cmd)
+{
+	nm256_t *chip = snd_pcm_substream_chip(substream);
+	nm256_stream_t *s = (nm256_stream_t*)substream->runtime->private_data;
+	int err = 0;
+
+	snd_assert(s != NULL, return -ENXIO);
+
+	spin_lock(&chip->reg_lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		if (! s->running) {
+			snd_nm256_playback_start(chip, s, substream);
+			s->running = 1;
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		if (s->running) {
+			snd_nm256_playback_stop(chip);
+			s->running = 0;
+		}
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+	spin_unlock(&chip->reg_lock);
+	return err;
+}
+
+static int
+snd_nm256_capture_trigger(snd_pcm_substream_t *substream, int cmd)
+{
+	nm256_t *chip = snd_pcm_substream_chip(substream);
+	nm256_stream_t *s = (nm256_stream_t*)substream->runtime->private_data;
+	int err = 0;
+
+	snd_assert(s != NULL, return -ENXIO);
+
+	spin_lock(&chip->reg_lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		if (! s->running) {
+			snd_nm256_capture_start(chip, s, substream);
+			s->running = 1;
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		if (s->running) {
+			snd_nm256_capture_stop(chip);
+			s->running = 0;
+		}
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+	spin_unlock(&chip->reg_lock);
+	return err;
+}
+
+
+/*
+ * prepare playback/capture channel
+ */
+static int snd_nm256_pcm_prepare(snd_pcm_substream_t *substream)
+{
+	nm256_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	nm256_stream_t *s = (nm256_stream_t*)runtime->private_data;
+
+	snd_assert(s, return -ENXIO);
+	s->dma_size = frames_to_bytes(runtime, substream->runtime->buffer_size);
+	s->period_size = frames_to_bytes(runtime, substream->runtime->period_size);
+	s->periods = substream->runtime->periods;
+	s->cur_period = 0;
+
+	spin_lock_irq(&chip->reg_lock);
+	s->running = 0;
+	snd_nm256_set_format(chip, s, substream);
+	spin_unlock_irq(&chip->reg_lock);
+
+	return 0;
+}
+
+
+/*
+ * get the current pointer
+ */
+static snd_pcm_uframes_t
+snd_nm256_playback_pointer(snd_pcm_substream_t * substream)
+{
+	nm256_t *chip = snd_pcm_substream_chip(substream);
+	nm256_stream_t *s = (nm256_stream_t*)substream->runtime->private_data;
+	unsigned long curp;
+
+	snd_assert(s, return 0);
+	curp = snd_nm256_readl(chip, NM_PBUFFER_CURRP) - (unsigned long)s->buf;
+	curp %= s->dma_size;
+	return bytes_to_frames(substream->runtime, curp);
+}
+
+static snd_pcm_uframes_t
+snd_nm256_capture_pointer(snd_pcm_substream_t * substream)
+{
+	nm256_t *chip = snd_pcm_substream_chip(substream);
+	nm256_stream_t *s = (nm256_stream_t*)substream->runtime->private_data;
+	unsigned long curp;
+
+	snd_assert(s != NULL, return 0);
+	curp = snd_nm256_readl(chip, NM_RBUFFER_CURRP) - (unsigned long)s->buf;
+	curp %= s->dma_size;	
+	return bytes_to_frames(substream->runtime, curp);
+}
+
+/* Remapped I/O space can be accessible as pointer on i386 */
+/* This might be changed in the future */
+#ifndef __i386__
+/*
+ * silence / copy for playback
+ */
+static int
+snd_nm256_playback_silence(snd_pcm_substream_t *substream,
+			   int channel, /* not used (interleaved data) */
+			   snd_pcm_uframes_t pos,
+			   snd_pcm_uframes_t count)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	nm256_stream_t *s = (nm256_stream_t*)runtime->private_data;
+	count = frames_to_bytes(runtime, count);
+	pos = frames_to_bytes(runtime, pos);
+	memset_io(s->bufptr + pos, 0, count);
+	return 0;
+}
+
+static int
+snd_nm256_playback_copy(snd_pcm_substream_t *substream,
+			int channel, /* not used (interleaved data) */
+			snd_pcm_uframes_t pos,
+			void __user *src,
+			snd_pcm_uframes_t count)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	nm256_stream_t *s = (nm256_stream_t*)runtime->private_data;
+	count = frames_to_bytes(runtime, count);
+	pos = frames_to_bytes(runtime, pos);
+	if (copy_from_user_toio(s->bufptr + pos, src, count))
+		return -EFAULT;
+	return 0;
+}
+
+/*
+ * copy to user
+ */
+static int
+snd_nm256_capture_copy(snd_pcm_substream_t *substream,
+		       int channel, /* not used (interleaved data) */
+		       snd_pcm_uframes_t pos,
+		       void __user *dst,
+		       snd_pcm_uframes_t count)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	nm256_stream_t *s = (nm256_stream_t*)runtime->private_data;
+	count = frames_to_bytes(runtime, count);
+	pos = frames_to_bytes(runtime, pos);
+	if (copy_to_user_fromio(dst, s->bufptr + pos, count))
+		return -EFAULT;
+	return 0;
+}
+
+#endif /* !__i386__ */
+
+
+/*
+ * update playback/capture watermarks
+ */
+
+/* spinlock held! */
+static void
+snd_nm256_playback_update(nm256_t *chip)
+{
+	nm256_stream_t *s;
+
+	s = &chip->streams[SNDRV_PCM_STREAM_PLAYBACK];
+	if (s->running && s->substream) {
+		spin_unlock(&chip->reg_lock);
+		snd_pcm_period_elapsed(s->substream);
+		spin_lock(&chip->reg_lock);
+		snd_nm256_playback_mark(chip, s);
+	}
+}
+
+/* spinlock held! */
+static void
+snd_nm256_capture_update(nm256_t *chip)
+{
+	nm256_stream_t *s;
+
+	s = &chip->streams[SNDRV_PCM_STREAM_CAPTURE];
+	if (s->running && s->substream) {
+		spin_unlock(&chip->reg_lock);
+		snd_pcm_period_elapsed(s->substream);
+		spin_lock(&chip->reg_lock);
+		snd_nm256_capture_mark(chip, s);
+	}
+}
+
+/*
+ * hardware info
+ */
+static snd_pcm_hardware_t snd_nm256_playback =
+{
+	.info =			SNDRV_PCM_INFO_MMAP_IOMEM |SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				/*SNDRV_PCM_INFO_PAUSE |*/
+				SNDRV_PCM_INFO_RESUME,
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_KNOT/*24k*/ | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		8000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.periods_min =		2,
+	.periods_max =		1024,
+	.buffer_bytes_max =	128 * 1024,
+	.period_bytes_min =	256,
+	.period_bytes_max =	128 * 1024,
+};
+
+static snd_pcm_hardware_t snd_nm256_capture =
+{
+	.info =			SNDRV_PCM_INFO_MMAP_IOMEM | SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				/*SNDRV_PCM_INFO_PAUSE |*/
+				SNDRV_PCM_INFO_RESUME,
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_KNOT/*24k*/ | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		8000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.periods_min =		2,
+	.periods_max =		1024,
+	.buffer_bytes_max =	128 * 1024,
+	.period_bytes_min =	256,
+	.period_bytes_max =	128 * 1024,
+};
+
+
+/* set dma transfer size */
+static int snd_nm256_pcm_hw_params(snd_pcm_substream_t *substream, snd_pcm_hw_params_t *hw_params)
+{
+	/* area and addr are already set and unchanged */
+	substream->runtime->dma_bytes = params_buffer_bytes(hw_params);
+	return 0;
+}
+
+/*
+ * open
+ */
+static void snd_nm256_setup_stream(nm256_t *chip, nm256_stream_t *s,
+				   snd_pcm_substream_t *substream,
+				   snd_pcm_hardware_t *hw_ptr)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	s->running = 0;
+	runtime->hw = *hw_ptr;
+	runtime->hw.buffer_bytes_max = s->bufsize;
+	runtime->hw.period_bytes_max = s->bufsize / 2;
+	runtime->dma_area = (void*) s->bufptr;
+	runtime->dma_addr = s->bufptr_addr;
+	runtime->dma_bytes = s->bufsize;
+	runtime->private_data = s;
+	s->substream = substream;
+
+	snd_pcm_set_sync(substream);
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				   &constraints_rates);
+}
+
+static int
+snd_nm256_playback_open(snd_pcm_substream_t *substream)
+{
+	nm256_t *chip = snd_pcm_substream_chip(substream);
+
+	snd_nm256_setup_stream(chip, &chip->streams[SNDRV_PCM_STREAM_PLAYBACK],
+			       substream, &snd_nm256_playback);
+	return 0;
+}
+
+static int
+snd_nm256_capture_open(snd_pcm_substream_t *substream)
+{
+	nm256_t *chip = snd_pcm_substream_chip(substream);
+
+	snd_nm256_setup_stream(chip, &chip->streams[SNDRV_PCM_STREAM_CAPTURE],
+			       substream, &snd_nm256_capture);
+	return 0;
+}
+
+/*
+ * close - we don't have to do special..
+ */
+static int
+snd_nm256_playback_close(snd_pcm_substream_t *substream)
+{
+	return 0;
+}
+
+
+static int
+snd_nm256_capture_close(snd_pcm_substream_t *substream)
+{
+	return 0;
+}
+
+/*
+ * create a pcm instance
+ */
+static snd_pcm_ops_t snd_nm256_playback_ops = {
+	.open =		snd_nm256_playback_open,
+	.close =	snd_nm256_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_nm256_pcm_hw_params,
+	.prepare =	snd_nm256_pcm_prepare,
+	.trigger =	snd_nm256_playback_trigger,
+	.pointer =	snd_nm256_playback_pointer,
+#ifndef __i386__
+	.copy =		snd_nm256_playback_copy,
+	.silence =	snd_nm256_playback_silence,
+#endif
+	.mmap =		snd_pcm_lib_mmap_iomem,
+};
+
+static snd_pcm_ops_t snd_nm256_capture_ops = {
+	.open =		snd_nm256_capture_open,
+	.close =	snd_nm256_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_nm256_pcm_hw_params,
+	.prepare =	snd_nm256_pcm_prepare,
+	.trigger =	snd_nm256_capture_trigger,
+	.pointer =	snd_nm256_capture_pointer,
+#ifndef __i386__
+	.copy =		snd_nm256_capture_copy,
+#endif
+	.mmap =		snd_pcm_lib_mmap_iomem,
+};
+
+static int __devinit
+snd_nm256_pcm(nm256_t *chip, int device)
+{
+	snd_pcm_t *pcm;
+	int i, err;
+
+	for (i = 0; i < 2; i++) {
+		nm256_stream_t *s = &chip->streams[i];
+		s->bufptr = chip->buffer + (s->buf - chip->buffer_start);
+		s->bufptr_addr = chip->buffer_addr + (s->buf - chip->buffer_start);
+	}
+
+	err = snd_pcm_new(chip->card, chip->card->driver, device,
+			  1, 1, &pcm);
+	if (err < 0)
+		return err;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_nm256_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_nm256_capture_ops);
+
+	pcm->private_data = chip;
+	pcm->info_flags = 0;
+	chip->pcm = pcm;
+
+	return 0;
+}
+
+
+/* 
+ * Initialize the hardware. 
+ */
+static void
+snd_nm256_init_chip(nm256_t *chip)
+{
+	spin_lock_irq(&chip->reg_lock);
+	/* Reset everything. */
+	snd_nm256_writeb(chip, 0x0, 0x11);
+	snd_nm256_writew(chip, 0x214, 0);
+	/* stop sounds.. */
+	//snd_nm256_playback_stop(chip);
+	//snd_nm256_capture_stop(chip);
+	spin_unlock_irq(&chip->reg_lock);
+}
+
+
+inline static void
+snd_nm256_intr_check(nm256_t *chip)
+{
+	if (chip->badintrcount++ > 1000) {
+		/*
+		 * I'm not sure if the best thing is to stop the card from
+		 * playing or just release the interrupt (after all, we're in
+		 * a bad situation, so doing fancy stuff may not be such a good
+		 * idea).
+		 *
+		 * I worry about the card engine continuing to play noise
+		 * over and over, however--that could become a very
+		 * obnoxious problem.  And we know that when this usually
+		 * happens things are fairly safe, it just means the user's
+		 * inserted a PCMCIA card and someone's spamming us with IRQ 9s.
+		 */
+		if (chip->streams[SNDRV_PCM_STREAM_PLAYBACK].running)
+			snd_nm256_playback_stop(chip);
+		if (chip->streams[SNDRV_PCM_STREAM_CAPTURE].running)
+			snd_nm256_capture_stop(chip);
+		chip->badintrcount = 0;
+	}
+}
+
+/* 
+ * Handle a potential interrupt for the device referred to by DEV_ID. 
+ *
+ * I don't like the cut-n-paste job here either between the two routines,
+ * but there are sufficient differences between the two interrupt handlers
+ * that parameterizing it isn't all that great either.  (Could use a macro,
+ * I suppose...yucky bleah.)
+ */
+
+static irqreturn_t
+snd_nm256_interrupt(int irq, void *dev_id, struct pt_regs *dummy)
+{
+	nm256_t *chip = dev_id;
+	u16 status;
+	u8 cbyte;
+
+	status = snd_nm256_readw(chip, NM_INT_REG);
+
+	/* Not ours. */
+	if (status == 0) {
+		snd_nm256_intr_check(chip);
+		return IRQ_NONE;
+	}
+
+	chip->badintrcount = 0;
+
+	/* Rather boring; check for individual interrupts and process them. */
+
+	spin_lock(&chip->reg_lock);
+	if (status & NM_PLAYBACK_INT) {
+		status &= ~NM_PLAYBACK_INT;
+		NM_ACK_INT(chip, NM_PLAYBACK_INT);
+		snd_nm256_playback_update(chip);
+	}
+
+	if (status & NM_RECORD_INT) {
+		status &= ~NM_RECORD_INT;
+		NM_ACK_INT(chip, NM_RECORD_INT);
+		snd_nm256_capture_update(chip);
+	}
+
+	if (status & NM_MISC_INT_1) {
+		status &= ~NM_MISC_INT_1;
+		NM_ACK_INT(chip, NM_MISC_INT_1);
+		snd_printd("NM256: Got misc interrupt #1\n");
+		snd_nm256_writew(chip, NM_INT_REG, 0x8000);
+		cbyte = snd_nm256_readb(chip, 0x400);
+		snd_nm256_writeb(chip, 0x400, cbyte | 2);
+	}
+
+	if (status & NM_MISC_INT_2) {
+		status &= ~NM_MISC_INT_2;
+		NM_ACK_INT(chip, NM_MISC_INT_2);
+		snd_printd("NM256: Got misc interrupt #2\n");
+		cbyte = snd_nm256_readb(chip, 0x400);
+		snd_nm256_writeb(chip, 0x400, cbyte & ~2);
+	}
+
+	/* Unknown interrupt. */
+	if (status) {
+		snd_printd("NM256: Fire in the hole! Unknown status 0x%x\n",
+			   status);
+		/* Pray. */
+		NM_ACK_INT(chip, status);
+	}
+
+	spin_unlock(&chip->reg_lock);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Handle a potential interrupt for the device referred to by DEV_ID.
+ * This handler is for the 256ZX, and is very similar to the non-ZX
+ * routine.
+ */
+
+static irqreturn_t
+snd_nm256_interrupt_zx(int irq, void *dev_id, struct pt_regs *dummy)
+{
+	nm256_t *chip = dev_id;
+	u32 status;
+	u8 cbyte;
+
+	status = snd_nm256_readl(chip, NM_INT_REG);
+
+	/* Not ours. */
+	if (status == 0) {
+		snd_nm256_intr_check(chip);
+		return IRQ_NONE;
+	}
+
+	chip->badintrcount = 0;
+
+	/* Rather boring; check for individual interrupts and process them. */
+
+	spin_lock(&chip->reg_lock);
+	if (status & NM2_PLAYBACK_INT) {
+		status &= ~NM2_PLAYBACK_INT;
+		NM2_ACK_INT(chip, NM2_PLAYBACK_INT);
+		snd_nm256_playback_update(chip);
+	}
+
+	if (status & NM2_RECORD_INT) {
+		status &= ~NM2_RECORD_INT;
+		NM2_ACK_INT(chip, NM2_RECORD_INT);
+		snd_nm256_capture_update(chip);
+	}
+
+	if (status & NM2_MISC_INT_1) {
+		status &= ~NM2_MISC_INT_1;
+		NM2_ACK_INT(chip, NM2_MISC_INT_1);
+		snd_printd("NM256: Got misc interrupt #1\n");
+		cbyte = snd_nm256_readb(chip, 0x400);
+		snd_nm256_writeb(chip, 0x400, cbyte | 2);
+	}
+
+	if (status & NM2_MISC_INT_2) {
+		status &= ~NM2_MISC_INT_2;
+		NM2_ACK_INT(chip, NM2_MISC_INT_2);
+		snd_printd("NM256: Got misc interrupt #2\n");
+		cbyte = snd_nm256_readb(chip, 0x400);
+		snd_nm256_writeb(chip, 0x400, cbyte & ~2);
+	}
+
+	/* Unknown interrupt. */
+	if (status) {
+		snd_printd("NM256: Fire in the hole! Unknown status 0x%x\n",
+			   status);
+		/* Pray. */
+		NM2_ACK_INT(chip, status);
+	}
+
+	spin_unlock(&chip->reg_lock);
+	return IRQ_HANDLED;
+}
+
+/*
+ * AC97 interface
+ */
+
+/*
+ * Waits for the mixer to become ready to be written; returns a zero value
+ * if it timed out.
+ */
+static int
+snd_nm256_ac97_ready(nm256_t *chip)
+{
+	int timeout = 10;
+	u32 testaddr;
+	u16 testb;
+
+	testaddr = chip->mixer_status_offset;
+	testb = chip->mixer_status_mask;
+
+	/* 
+	 * Loop around waiting for the mixer to become ready. 
+	 */
+	while (timeout-- > 0) {
+		if ((snd_nm256_readw(chip, testaddr) & testb) == 0)
+			return 1;
+		udelay(100);
+	}
+	return 0;
+}
+
+/*
+ */
+static unsigned short
+snd_nm256_ac97_read(ac97_t *ac97, unsigned short reg)
+{
+	nm256_t *chip = ac97->private_data;
+	int res;
+
+	if (reg >= 128)
+		return 0;
+
+	if (! snd_nm256_ac97_ready(chip))
+		return 0;
+	res = snd_nm256_readw(chip, chip->mixer_base + reg);
+	/* Magic delay.  Bleah yucky.  */
+	msleep(1);
+	return res;
+}
+
+/* 
+ */
+static void
+snd_nm256_ac97_write(ac97_t *ac97,
+		     unsigned short reg, unsigned short val)
+{
+	nm256_t *chip = ac97->private_data;
+	int tries = 2;
+	u32 base;
+
+	base = chip->mixer_base;
+
+	snd_nm256_ac97_ready(chip);
+
+	/* Wait for the write to take, too. */
+	while (tries-- > 0) {
+		snd_nm256_writew(chip, base + reg, val);
+		msleep(1);  /* a little delay here seems better.. */
+		if (snd_nm256_ac97_ready(chip))
+			return;
+	}
+	snd_printd("nm256: ac97 codec not ready..\n");
+}
+
+/* initialize the ac97 into a known state */
+static void
+snd_nm256_ac97_reset(ac97_t *ac97)
+{
+	nm256_t *chip = ac97->private_data;
+
+	/* Reset the mixer.  'Tis magic!  */
+	snd_nm256_writeb(chip, 0x6c0, 1);
+	if (! chip->reset_workaround) {
+		/* Dell latitude LS will lock up by this */
+		snd_nm256_writeb(chip, 0x6cc, 0x87);
+	}
+	snd_nm256_writeb(chip, 0x6cc, 0x80);
+	snd_nm256_writeb(chip, 0x6cc, 0x0);
+}
+
+/* create an ac97 mixer interface */
+static int __devinit
+snd_nm256_mixer(nm256_t *chip)
+{
+	ac97_bus_t *pbus;
+	ac97_template_t ac97;
+	int i, err;
+	static ac97_bus_ops_t ops = {
+		.reset = snd_nm256_ac97_reset,
+		.write = snd_nm256_ac97_write,
+		.read = snd_nm256_ac97_read,
+	};
+	/* looks like nm256 hangs up when unexpected registers are touched... */
+	static int mixer_regs[] = {
+		AC97_MASTER, AC97_HEADPHONE, AC97_MASTER_MONO,
+		AC97_PC_BEEP, AC97_PHONE, AC97_MIC, AC97_LINE, AC97_CD,
+		AC97_VIDEO, AC97_AUX, AC97_PCM, AC97_REC_SEL,
+		AC97_REC_GAIN, AC97_GENERAL_PURPOSE, AC97_3D_CONTROL,
+		AC97_EXTENDED_ID,
+		AC97_VENDOR_ID1, AC97_VENDOR_ID2,
+		-1
+	};
+
+	if ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)
+		return err;
+
+	memset(&ac97, 0, sizeof(ac97));
+	ac97.scaps = AC97_SCAP_AUDIO; /* we support audio! */
+	ac97.limited_regs = 1;
+	for (i = 0; mixer_regs[i] >= 0; i++)
+		set_bit(mixer_regs[i], ac97.reg_accessed);
+	ac97.private_data = chip;
+	err = snd_ac97_mixer(pbus, &ac97, &chip->ac97);
+	if (err < 0)
+		return err;
+	if (! (chip->ac97->id & (0xf0000000))) {
+		/* looks like an invalid id */
+		sprintf(chip->card->mixername, "%s AC97", chip->card->driver);
+	}
+	return 0;
+}
+
+/* 
+ * See if the signature left by the NM256 BIOS is intact; if so, we use
+ * the associated address as the end of our audio buffer in the video
+ * RAM.
+ */
+
+static int __devinit
+snd_nm256_peek_for_sig(nm256_t *chip)
+{
+	/* The signature is located 1K below the end of video RAM.  */
+	void __iomem *temp;
+	/* Default buffer end is 5120 bytes below the top of RAM.  */
+	unsigned long pointer_found = chip->buffer_end - 0x1400;
+	u32 sig;
+
+	temp = ioremap_nocache(chip->buffer_addr + chip->buffer_end - 0x400, 16);
+	if (temp == NULL) {
+		snd_printk("Unable to scan for card signature in video RAM\n");
+		return -EBUSY;
+	}
+
+	sig = readl(temp);
+	if ((sig & NM_SIG_MASK) == NM_SIGNATURE) {
+		u32 pointer = readl(temp + 4);
+
+		/*
+		 * If it's obviously invalid, don't use it
+		 */
+		if (pointer == 0xffffffff ||
+		    pointer < chip->buffer_size ||
+		    pointer > chip->buffer_end) {
+			snd_printk("invalid signature found: 0x%x\n", pointer);
+			iounmap(temp);
+			return -ENODEV;
+		} else {
+			pointer_found = pointer;
+			printk(KERN_INFO "nm256: found card signature in video RAM: 0x%x\n", pointer);
+		}
+	}
+
+	iounmap(temp);
+	chip->buffer_end = pointer_found;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/*
+ * APM event handler, so the card is properly reinitialized after a power
+ * event.
+ */
+static int nm256_suspend(snd_card_t *card, pm_message_t state)
+{
+	nm256_t *chip = card->pm_private_data;
+
+	snd_pcm_suspend_all(chip->pcm);
+	snd_ac97_suspend(chip->ac97);
+	chip->coeffs_current = 0;
+	pci_disable_device(chip->pci);
+	return 0;
+}
+
+static int nm256_resume(snd_card_t *card)
+{
+	nm256_t *chip = card->pm_private_data;
+
+	/* Perform a full reset on the hardware */
+	pci_enable_device(chip->pci);
+	snd_nm256_init_chip(chip);
+
+	/* restore ac97 */
+	snd_ac97_resume(chip->ac97);
+
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+static int snd_nm256_free(nm256_t *chip)
+{
+	if (chip->streams[SNDRV_PCM_STREAM_PLAYBACK].running)
+		snd_nm256_playback_stop(chip);
+	if (chip->streams[SNDRV_PCM_STREAM_CAPTURE].running)
+		snd_nm256_capture_stop(chip);
+
+	if (chip->irq >= 0)
+		synchronize_irq(chip->irq);
+
+	if (chip->cport)
+		iounmap(chip->cport);
+	if (chip->buffer)
+		iounmap(chip->buffer);
+	if (chip->res_cport) {
+		release_resource(chip->res_cport);
+		kfree_nocheck(chip->res_cport);
+	}
+	if (chip->res_buffer) {
+		release_resource(chip->res_buffer);
+		kfree_nocheck(chip->res_buffer);
+	}
+	if (chip->irq >= 0)
+		free_irq(chip->irq, (void*)chip);
+
+	pci_disable_device(chip->pci);
+	kfree(chip);
+	return 0;
+}
+
+static int snd_nm256_dev_free(snd_device_t *device)
+{
+	nm256_t *chip = device->device_data;
+	return snd_nm256_free(chip);
+}
+
+static int __devinit
+snd_nm256_create(snd_card_t *card, struct pci_dev *pci,
+		 int play_bufsize, int capt_bufsize,
+		 int force_load,
+		 u32 buffertop,
+		 int usecache,
+		 nm256_t **chip_ret)
+{
+	nm256_t *chip;
+	int err, pval;
+	static snd_device_ops_t ops = {
+		.dev_free =	snd_nm256_dev_free,
+	};
+	u32 addr;
+
+	*chip_ret = NULL;
+
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+
+	chip = kcalloc(1, sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+
+	chip->card = card;
+	chip->pci = pci;
+	chip->use_cache = usecache;
+	spin_lock_init(&chip->reg_lock);
+	chip->irq = -1;
+
+	chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize = play_bufsize;
+	chip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize = capt_bufsize;
+
+	/* 
+	 * The NM256 has two memory ports.  The first port is nothing
+	 * more than a chunk of video RAM, which is used as the I/O ring
+	 * buffer.  The second port has the actual juicy stuff (like the
+	 * mixer and the playback engine control registers).
+	 */
+
+	chip->buffer_addr = pci_resource_start(pci, 0);
+	chip->cport_addr = pci_resource_start(pci, 1);
+
+	/* Init the memory port info.  */
+	/* remap control port (#2) */
+	chip->res_cport = request_mem_region(chip->cport_addr, NM_PORT2_SIZE,
+					     card->driver);
+	if (chip->res_cport == NULL) {
+		snd_printk("memory region 0x%lx (size 0x%x) busy\n",
+			   chip->cport_addr, NM_PORT2_SIZE);
+		err = -EBUSY;
+		goto __error;
+	}
+	chip->cport = ioremap_nocache(chip->cport_addr, NM_PORT2_SIZE);
+	if (chip->cport == NULL) {
+		snd_printk("unable to map control port %lx\n", chip->cport_addr);
+		err = -ENOMEM;
+		goto __error;
+	}
+
+	if (!strcmp(card->driver, "NM256AV")) {
+		/* Ok, try to see if this is a non-AC97 version of the hardware. */
+		pval = snd_nm256_readw(chip, NM_MIXER_PRESENCE);
+		if ((pval & NM_PRESENCE_MASK) != NM_PRESENCE_VALUE) {
+			if (! force_load) {
+				printk(KERN_ERR "nm256: no ac97 is found!\n");
+				printk(KERN_ERR "  force the driver to load by passing in the module parameter\n");
+				printk(KERN_ERR "    force_ac97=1\n");
+				printk(KERN_ERR "  or try sb16 or cs423x drivers instead.\n");
+				err = -ENXIO;
+				goto __error;
+			}
+		}
+		chip->buffer_end = 2560 * 1024;
+		chip->interrupt = snd_nm256_interrupt;
+		chip->mixer_status_offset = NM_MIXER_STATUS_OFFSET;
+		chip->mixer_status_mask = NM_MIXER_READY_MASK;
+	} else {
+		/* Not sure if there is any relevant detect for the ZX or not.  */
+		if (snd_nm256_readb(chip, 0xa0b) != 0)
+			chip->buffer_end = 6144 * 1024;
+		else
+			chip->buffer_end = 4096 * 1024;
+
+		chip->interrupt = snd_nm256_interrupt_zx;
+		chip->mixer_status_offset = NM2_MIXER_STATUS_OFFSET;
+		chip->mixer_status_mask = NM2_MIXER_READY_MASK;
+	}
+	
+	chip->buffer_size = chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize + chip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize;
+	if (chip->use_cache)
+		chip->buffer_size += NM_TOTAL_COEFF_COUNT * 4;
+	else
+		chip->buffer_size += NM_MAX_PLAYBACK_COEF_SIZE + NM_MAX_RECORD_COEF_SIZE;
+
+	if (buffertop >= chip->buffer_size && buffertop < chip->buffer_end)
+		chip->buffer_end = buffertop;
+	else {
+		/* get buffer end pointer from signature */
+		if ((err = snd_nm256_peek_for_sig(chip)) < 0)
+			goto __error;
+	}
+
+	chip->buffer_start = chip->buffer_end - chip->buffer_size;
+	chip->buffer_addr += chip->buffer_start;
+
+	printk(KERN_INFO "nm256: Mapping port 1 from 0x%x - 0x%x\n",
+	       chip->buffer_start, chip->buffer_end);
+
+	chip->res_buffer = request_mem_region(chip->buffer_addr,
+					      chip->buffer_size,
+					      card->driver);
+	if (chip->res_buffer == NULL) {
+		snd_printk("nm256: buffer 0x%lx (size 0x%x) busy\n",
+			   chip->buffer_addr, chip->buffer_size);
+		err = -EBUSY;
+		goto __error;
+	}
+	chip->buffer = ioremap_nocache(chip->buffer_addr, chip->buffer_size);
+	if (chip->buffer == NULL) {
+		err = -ENOMEM;
+		snd_printk("unable to map ring buffer at %lx\n", chip->buffer_addr);
+		goto __error;
+	}
+
+	/* set offsets */
+	addr = chip->buffer_start;
+	chip->streams[SNDRV_PCM_STREAM_PLAYBACK].buf = addr;
+	addr += chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize;
+	chip->streams[SNDRV_PCM_STREAM_CAPTURE].buf = addr;
+	addr += chip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize;
+	if (chip->use_cache) {
+		chip->all_coeff_buf = addr;
+	} else {
+		chip->coeff_buf[SNDRV_PCM_STREAM_PLAYBACK] = addr;
+		addr += NM_MAX_PLAYBACK_COEF_SIZE;
+		chip->coeff_buf[SNDRV_PCM_STREAM_CAPTURE] = addr;
+	}
+
+	/* acquire interrupt */
+	if (request_irq(pci->irq, chip->interrupt, SA_INTERRUPT|SA_SHIRQ,
+			card->driver, (void*)chip)) {
+		err = -EBUSY;
+		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		goto __error;
+	}
+	chip->irq = pci->irq;
+
+	/* Fixed setting. */
+	chip->mixer_base = NM_MIXER_OFFSET;
+
+	chip->coeffs_current = 0;
+
+	snd_nm256_init_chip(chip);
+
+	// pci_set_master(pci); /* needed? */
+	
+	snd_card_set_pm_callback(card, nm256_suspend, nm256_resume, chip);
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0)
+		goto __error;
+
+	snd_card_set_dev(card, &pci->dev);
+
+	*chip_ret = chip;
+	return 0;
+
+__error:
+	snd_nm256_free(chip);
+	return err;
+}
+
+
+struct nm256_quirk {
+	unsigned short vendor;
+	unsigned short device;
+	int type;
+};
+
+enum { NM_BLACKLISTED, NM_RESET_WORKAROUND };
+
+static struct nm256_quirk nm256_quirks[] __devinitdata = {
+	/* HP omnibook 4150 has cs4232 codec internally */
+	{ .vendor = 0x103c, .device = 0x0007, .type = NM_BLACKLISTED },
+	/* Sony PCG-F305 */
+	{ .vendor = 0x104d, .device = 0x8041, .type = NM_RESET_WORKAROUND },
+	/* Dell Latitude LS */
+	{ .vendor = 0x1028, .device = 0x0080, .type = NM_RESET_WORKAROUND },
+	{ } /* terminator */
+};
+
+
+static int __devinit snd_nm256_probe(struct pci_dev *pci,
+				     const struct pci_device_id *pci_id)
+{
+	static int dev;
+	snd_card_t *card;
+	nm256_t *chip;
+	int err;
+	unsigned int xbuffer_top;
+	struct nm256_quirk *q;
+	u16 subsystem_vendor, subsystem_device;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	pci_read_config_word(pci, PCI_SUBSYSTEM_VENDOR_ID, &subsystem_vendor);
+	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &subsystem_device);
+
+	for (q = nm256_quirks; q->vendor; q++) {
+		if (q->vendor == subsystem_vendor && q->device == subsystem_device) {
+			switch (q->type) {
+			case NM_BLACKLISTED:
+				printk(KERN_INFO "nm256: The device is blacklisted.  Loading stopped\n");
+				return -ENODEV;
+			case NM_RESET_WORKAROUND:
+				reset_workaround[dev] = 1;
+				break;
+			}
+		}
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+
+	switch (pci->device) {
+	case PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO:
+		strcpy(card->driver, "NM256AV");
+		break;
+	case PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO:
+		strcpy(card->driver, "NM256ZX");
+		break;
+	case PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO:
+		strcpy(card->driver, "NM256XL+");
+		break;
+	default:
+		snd_printk("invalid device id 0x%x\n", pci->device);
+		snd_card_free(card);
+		return -EINVAL;
+	}
+
+	if (vaio_hack[dev])
+		xbuffer_top = 0x25a800;	/* this avoids conflicts with XFree86 server */
+	else
+		xbuffer_top = buffer_top[dev];
+
+	if (playback_bufsize[dev] < 4)
+		playback_bufsize[dev] = 4;
+	if (playback_bufsize[dev] > 128)
+		playback_bufsize[dev] = 128;
+	if (capture_bufsize[dev] < 4)
+		capture_bufsize[dev] = 4;
+	if (capture_bufsize[dev] > 128)
+		capture_bufsize[dev] = 128;
+	if ((err = snd_nm256_create(card, pci,
+				    playback_bufsize[dev] * 1024, /* in bytes */
+				    capture_bufsize[dev] * 1024,  /* in bytes */
+				    force_ac97[dev],
+				    xbuffer_top,
+				    use_cache[dev],
+				    &chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	if (reset_workaround[dev]) {
+		snd_printdd(KERN_INFO "nm256: reset_workaround activated\n");
+		chip->reset_workaround = 1;
+	}
+
+	if ((err = snd_nm256_pcm(chip, 0)) < 0 ||
+	    (err = snd_nm256_mixer(chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	sprintf(card->shortname, "NeoMagic %s", card->driver);
+	sprintf(card->longname, "%s at 0x%lx & 0x%lx, irq %d",
+		card->shortname,
+		chip->buffer_addr, chip->cport_addr, chip->irq);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_nm256_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+
+static struct pci_driver driver = {
+	.name = "NeoMagic 256",
+	.id_table = snd_nm256_ids,
+	.probe = snd_nm256_probe,
+	.remove = __devexit_p(snd_nm256_remove),
+	SND_PCI_PM_CALLBACKS
+};
+
+
+static int __init alsa_card_nm256_init(void)
+{
+	return pci_module_init(&driver);
+}
+
+static void __exit alsa_card_nm256_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_nm256_init)
+module_exit(alsa_card_nm256_exit)
