commit fb95aae6e67c4e319a24b3eea32032d4246a5335
Merge: bd2463ac7d7e 90fb04f890bc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 28 16:26:57 2020 -0800

    Merge tag 'sound-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "As the diffstat shows we've had again a lot of works done for this
      cycle: the majority of changes are the continued componentization and
      code refactoring in ASoC, the tree-wide PCM API updates and cleanups
      and SOF updates while a few ASoC driver updates are seen, too.
    
      Here we go, some highlights:
    
      Core:
       - Finally y2038 support landed to ALSA ABI; some ioctls have been
         extended and lots of tricks were applied
       - Applying the new managed PCM buffer API to all drivers; the API
         itself was already merged in 5.5
       - The already deprecated dimension support in ALSA control API is
         dropped completely now
       - Verification of ALSA control elements to catch API misuses
    
      ASoC:
       - Further code refactorings and moving things to the component level
       - Lots of updates and improvements on SOF / Intel drivers; now
         including common HDMI driver and SoundWire support
       - New driver support for Ingenic JZ4770, Mediatek MT6660, Qualcomm
         WCD934x and WSA881x, and Realtek RT700, RT711, RT715, RT1011,
         RT1015 and RT1308
    
      HD-audio:
       - Improved ring-buffer communications using waitqueue
       - Drop the superfluous buffer preallocation on x86
    
      Others:
       - Many code cleanups, mostly constifications over the whole tree
       - USB-audio: quirks for MOTU, Corsair Virtuoso, Line6 Helix
       - FireWire: code refactoring for oxfw and dice drivers"
    
    * tag 'sound-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (638 commits)
      ALSA: usb-audio: add quirks for Line6 Helix devices fw>=2.82
      ALSA: hda: Add Clevo W65_67SB the power_save blacklist
      ASoC: soc-core: remove null_snd_soc_ops
      ASoC: soc-pcm: add soc_rtd_trigger()
      ASoC: soc-pcm: add soc_rtd_hw_free()
      ASoC: soc-pcm: add soc_rtd_hw_params()
      ASoC: soc-pcm: add soc_rtd_prepare()
      ASoC: soc-pcm: add soc_rtd_shutdown()
      ASoC: soc-pcm: add soc_rtd_startup()
      ASoC: rt1015: add rt1015 amplifier driver
      ASoC: madera: Correct some kernel doc
      ASoC: topology: fix soc_tplg_fe_link_create() - link->dobj initialization order
      ASoC: Intel: skl_hda_dsp_common: Fix global-out-of-bounds bug
      ASoC: madera: Correct DMIC only input hook ups
      ALSA: cs46xx: fix spelling mistake "to" -> "too"
      ALSA: hda - Add docking station support for Lenovo Thinkpad T420s
      ASoC: Add MediaTek MT6660 Speaker Amp Driver
      ASoC: dt-bindings: rt5645: add suppliers
      ASoC: max98090: fix deadlock in max98090_dapm_put_enum_double()
      ASoC: dapm: add snd_soc_dapm_put_enum_double_locked
      ...

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index ef7dd290ae05..ce13dcde4c36 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1334,7 +1334,7 @@ static int sis_chip_create(struct snd_card *card,
 	}
 
 	rc = -EIO;
-	sis->ioaddr = ioremap_nocache(pci_resource_start(pci, 1), 0x4000);
+	sis->ioaddr = ioremap(pci_resource_start(pci, 1), 0x4000);
 	if (!sis->ioaddr) {
 		dev_err(&pci->dev, "unable to remap MMIO, aborting\n");
 		goto error_out_cleanup;

commit 51055da51d1e92bb089c9b9e0ecb1be69396f808
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:43 2020 +0100

    ALSA: pci: Constify snd_ac97_bus_ops definitions
    
    Now snd_ac97_bus() takes the const ops pointer, so we can define the
    snd_ac97_bus_ops locally as const as well for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-28-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 2e351bf1d792..4977ab0b8b3d 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -983,7 +983,7 @@ static int sis_mixer_create(struct sis7019 *sis)
 {
 	struct snd_ac97_bus *bus;
 	struct snd_ac97_template ac97;
-	static struct snd_ac97_bus_ops ops = {
+	static const struct snd_ac97_bus_ops ops = {
 		.write = sis_ac97_write,
 		.read = sis_ac97_read,
 	};

commit efb0ad25d370344e61bb4fca8c3b9c3c6047922e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:25 2020 +0100

    ALSA: pci: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 515598e3cacf..2e351bf1d792 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1280,7 +1280,7 @@ static int sis_chip_create(struct snd_card *card,
 {
 	struct sis7019 *sis = card->private_data;
 	struct voice *voice;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free = sis_dev_free,
 	};
 	int rc;

commit 39b77268c8cdfff171c09c22f7ee8069139d4f20
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:33 2019 +0100

    ALSA: sis7019: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-35-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 06dccf080bcc..515598e3cacf 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1335,6 +1335,7 @@ static int sis_chip_create(struct snd_card *card,
 	}
 
 	sis->irq = pci->irq;
+	card->sync_irq = sis->irq;
 	pci_set_master(pci);
 
 	for (i = 0; i < 64; i++) {

commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 4639bc21b42d..06dccf080bcc 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -846,7 +846,6 @@ static int sis_pcm_capture_prepare(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops sis_playback_ops = {
 	.open = sis_playback_open,
 	.close = sis_substream_close,
-	.ioctl = snd_pcm_lib_ioctl,
 	.prepare = sis_pcm_playback_prepare,
 	.trigger = sis_pcm_trigger,
 	.pointer = sis_pcm_pointer,
@@ -855,7 +854,6 @@ static const struct snd_pcm_ops sis_playback_ops = {
 static const struct snd_pcm_ops sis_capture_ops = {
 	.open = sis_capture_open,
 	.close = sis_substream_close,
-	.ioctl = snd_pcm_lib_ioctl,
 	.hw_params = sis_capture_hw_params,
 	.prepare = sis_pcm_capture_prepare,
 	.trigger = sis_pcm_trigger,

commit ff3eb3d51be9d191fe3e663d0e95ed8b28824a89
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:24 2019 +0100

    ALSA: sis7019: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The hw_params and hw_free callbacks became superfluous and got
    dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-53-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index ef7dd290ae05..4639bc21b42d 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -499,18 +499,6 @@ static int sis_substream_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static int sis_playback_hw_params(struct snd_pcm_substream *substream,
-					struct snd_pcm_hw_params *hw_params)
-{
-	return snd_pcm_lib_malloc_pages(substream,
-					params_buffer_bytes(hw_params));
-}
-
-static int sis_hw_free(struct snd_pcm_substream *substream)
-{
-	return snd_pcm_lib_free_pages(substream);
-}
-
 static int sis_pcm_playback_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -701,11 +689,6 @@ static int sis_capture_hw_params(struct snd_pcm_substream *substream,
 	if (rc)
 		goto out;
 
-	rc = snd_pcm_lib_malloc_pages(substream,
-					params_buffer_bytes(hw_params));
-	if (rc < 0)
-		goto out;
-
 	rc = sis_alloc_timing_voice(substream, hw_params);
 
 out:
@@ -864,8 +847,6 @@ static const struct snd_pcm_ops sis_playback_ops = {
 	.open = sis_playback_open,
 	.close = sis_substream_close,
 	.ioctl = snd_pcm_lib_ioctl,
-	.hw_params = sis_playback_hw_params,
-	.hw_free = sis_hw_free,
 	.prepare = sis_pcm_playback_prepare,
 	.trigger = sis_pcm_trigger,
 	.pointer = sis_pcm_pointer,
@@ -876,7 +857,6 @@ static const struct snd_pcm_ops sis_capture_ops = {
 	.close = sis_substream_close,
 	.ioctl = snd_pcm_lib_ioctl,
 	.hw_params = sis_capture_hw_params,
-	.hw_free = sis_hw_free,
 	.prepare = sis_pcm_capture_prepare,
 	.trigger = sis_pcm_trigger,
 	.pointer = sis_pcm_pointer,
@@ -904,9 +884,8 @@ static int sis_pcm_create(struct sis7019 *sis)
 	/* Try to preallocate some memory, but it's not the end of the
 	 * world if this fails.
 	 */
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &sis->pci->dev,
-					      64*1024, 128*1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
+				       &sis->pci->dev, 64*1024, 128*1024);
 
 	return 0;
 }

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index b0b5e74e776c..ef7dd290ae05 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -905,7 +905,8 @@ static int sis_pcm_create(struct sis7019 *sis)
 	 * world if this fails.
 	 */
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-				snd_dma_pci_data(sis->pci), 64*1024, 128*1024);
+					      &sis->pci->dev,
+					      64*1024, 128*1024);
 
 	return 0;
 }

commit 7614a55ea29445d77f6922c616934c5a927b1c8e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:12:48 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 274
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 this program is distributed
      in the hope that it will be useful but without any warranty without
      even the implied warranty of merchantability or fitness for a
      particular purpose see the gnu general public license for more
      details you should have received a copy of the gnu general public
      license along with this program if not write to the free software
      foundation inc 59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 2 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141334.697148568@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 6b27980d77a8..b0b5e74e776c 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  Driver for SiS7019 Audio Accelerator
  *
@@ -6,19 +7,6 @@
  *  Inspired by the Trident 4D-WaveDX/NX driver.
  *
  *  All rights reserved.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, version 2.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include <linux/init.h>

commit 17bc4815de586d001c82d0ddf75247283c3f002a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:02:51 2019 +0100

    ALSA: pci: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 964acf302479..6b27980d77a8 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1214,7 +1214,6 @@ static int sis_suspend(struct device *dev)
 	int i;
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
-	snd_pcm_suspend_all(sis->pcm);
 	if (sis->codecs_present & SIS_PRIMARY_CODEC_PRESENT)
 		snd_ac97_suspend(sis->ac97[0]);
 	if (sis->codecs_present & SIS_SECONDARY_CODEC_PRESENT)

commit dee49895b197936c02d27d651e58c90bac18f452
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:28 2017 +0530

    ALSA: pci: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 35188872d313..964acf302479 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -159,7 +159,7 @@ struct sis7019 {
  * We'll add a constraint upon open that limits the period and buffer sample
  * size to values that are legal for the hardware.
  */
-static struct snd_pcm_hardware sis_playback_hw_info = {
+static const struct snd_pcm_hardware sis_playback_hw_info = {
 	.info = (SNDRV_PCM_INFO_MMAP |
 		 SNDRV_PCM_INFO_MMAP_VALID |
 		 SNDRV_PCM_INFO_INTERLEAVED |
@@ -180,7 +180,7 @@ static struct snd_pcm_hardware sis_playback_hw_info = {
 	.periods_max = (0xfff9 / 9),
 };
 
-static struct snd_pcm_hardware sis_capture_hw_info = {
+static const struct snd_pcm_hardware sis_capture_hw_info = {
 	.info = (SNDRV_PCM_INFO_MMAP |
 		 SNDRV_PCM_INFO_MMAP_VALID |
 		 SNDRV_PCM_INFO_INTERLEAVED |

commit 2aa0eae9702ede2af21191bce8c5848eea3306e4
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Thu Aug 10 17:17:37 2017 +0530

    ALSA: sis7019: constify snd_pcm_ops structures
    
    snd_pcm_ops are not supposed to change at runtime. All functions
    working with snd_pcm_ops provided by <sound/pcm.h> work with
    const snd_pcm_ops. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index f3860b850210..35188872d313 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -872,7 +872,7 @@ static int sis_pcm_capture_prepare(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static struct snd_pcm_ops sis_playback_ops = {
+static const struct snd_pcm_ops sis_playback_ops = {
 	.open = sis_playback_open,
 	.close = sis_substream_close,
 	.ioctl = snd_pcm_lib_ioctl,
@@ -883,7 +883,7 @@ static struct snd_pcm_ops sis_playback_ops = {
 	.pointer = sis_pcm_pointer,
 };
 
-static struct snd_pcm_ops sis_capture_ops = {
+static const struct snd_pcm_ops sis_capture_ops = {
 	.open = sis_capture_open,
 	.close = sis_substream_close,
 	.ioctl = snd_pcm_lib_ioctl,

commit 412b979ccceff448dccea54bdb616c85781bc0ba
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Wed Apr 15 16:10:17 2015 +0200

    ALSA: remove deprecated use of pci api
    
    Replace occurences of the pci api by appropriate call to the dma api.
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr)
    
    @deprecated@
    idexpression id;
    position p;
    @@
    
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @bad1@
    idexpression id;
    position deprecated.p;
    @@
    ...when != &id->dev
       when != pci_get_drvdata ( id )
       when != pci_enable_device ( id )
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @depends on !bad1@
    idexpression id;
    expression direction;
    position deprecated.p;
    @@
    
    (
    - pci_dma_supported@p ( id,
    + dma_supported ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    |
    - pci_alloc_consistent@p ( id,
    + dma_alloc_coherent ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    )
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index efe669b80256..f3860b850210 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -383,9 +383,9 @@ static void __sis_map_silence(struct sis7019 *sis)
 {
 	/* Helper function: must hold sis->voice_lock on entry */
 	if (!sis->silence_users)
-		sis->silence_dma_addr = pci_map_single(sis->pci,
+		sis->silence_dma_addr = dma_map_single(&sis->pci->dev,
 						sis->suspend_state[0],
-						4096, PCI_DMA_TODEVICE);
+						4096, DMA_TO_DEVICE);
 	sis->silence_users++;
 }
 
@@ -394,8 +394,8 @@ static void __sis_unmap_silence(struct sis7019 *sis)
 	/* Helper function: must hold sis->voice_lock on entry */
 	sis->silence_users--;
 	if (!sis->silence_users)
-		pci_unmap_single(sis->pci, sis->silence_dma_addr, 4096,
-					PCI_DMA_TODEVICE);
+		dma_unmap_single(&sis->pci->dev, sis->silence_dma_addr, 4096,
+					DMA_TO_DEVICE);
 }
 
 static void sis_free_voice(struct sis7019 *sis, struct voice *voice)
@@ -1325,7 +1325,7 @@ static int sis_chip_create(struct snd_card *card,
 	if (rc)
 		goto error_out;
 
-	rc = pci_set_dma_mask(pci, DMA_BIT_MASK(30));
+	rc = dma_set_mask(&pci->dev, DMA_BIT_MASK(30));
 	if (rc < 0) {
 		dev_err(&pci->dev, "architecture does not support 30-bit PCI busmaster DMA");
 		goto error_out_enabled;

commit 9e5947465d72ef1b3a88104474ab2adf78837220
Merge: 624afe4dc9a0 3e41c9b5a1ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 11 11:26:48 2015 +0100

    Merge branch 'topic/pci-cleanup' into for-next

commit 5b3985ecdc6beab7db96a259fce0d8befd99ff07
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 8 12:50:09 2015 +0100

    ALSA: sis7019: Simplify PM callbacks
    
    This is a similar cleanup like the commit [3db084fd0af5: ALSA: fm801:
    PCI core handles power state for us].
    
    Since pci_set_power_state(), pci_save_state() and pci_restore_state()
    are already done in the PCI core side, so we don't need to it doubly.
    
    Also, pci_enable_device(), pci_disable_device() and pci_set_master()
    calls in PM callbacks are superfluous nowadays, too, so get rid of
    them as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 7f6a0a0d115a..be8952f6804d 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1211,7 +1211,6 @@ static int sis_chip_init(struct sis7019 *sis)
 #ifdef CONFIG_PM_SLEEP
 static int sis_suspend(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct sis7019 *sis = card->private_data;
 	void __iomem *ioaddr = sis->ioaddr;
@@ -1240,9 +1239,6 @@ static int sis_suspend(struct device *dev)
 		ioaddr += 4096;
 	}
 
-	pci_disable_device(pci);
-	pci_save_state(pci);
-	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
@@ -1254,14 +1250,6 @@ static int sis_resume(struct device *dev)
 	void __iomem *ioaddr = sis->ioaddr;
 	int i;
 
-	pci_set_power_state(pci, PCI_D0);
-	pci_restore_state(pci);
-
-	if (pci_enable_device(pci) < 0) {
-		dev_err(&pci->dev, "unable to re-enable device\n");
-		goto error;
-	}
-
 	if (sis_chip_init(sis)) {
 		dev_err(&pci->dev, "unable to re-init controller\n");
 		goto error;
@@ -1284,7 +1272,6 @@ static int sis_resume(struct device *dev)
 	memset(sis->suspend_state[0], 0, 4096);
 
 	sis->irq = pci->irq;
-	pci_set_master(pci);
 
 	if (sis->codecs_present & SIS_PRIMARY_CODEC_PRESENT)
 		snd_ac97_resume(sis->ac97[0]);

commit ff6defa6a8fae12205d64f55db395b1fcf35af8e
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jan 3 22:55:54 2015 +0100

    ALSA: Deletion of checks before the function call "iounmap"
    
    The iounmap() function performs also input parameter validation.
    Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 7f6a0a0d115a..5e9437ba6eec 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1064,12 +1064,9 @@ static int sis_chip_free(struct sis7019 *sis)
 	if (sis->irq >= 0)
 		free_irq(sis->irq, sis);
 
-	if (sis->ioaddr)
-		iounmap(sis->ioaddr);
-
+	iounmap(sis->ioaddr);
 	pci_release_regions(sis->pci);
 	pci_disable_device(sis->pci);
-
 	sis_free_suspend(sis);
 	return 0;
 }

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 6b26b93e001d..7f6a0a0d115a 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -52,7 +52,7 @@ MODULE_PARM_DESC(enable, "Enable SiS7019 Audio Accelerator.");
 module_param(codecs, int, 0444);
 MODULE_PARM_DESC(codecs, "Set bit to indicate that codec number is expected to be present (default 1)");
 
-static DEFINE_PCI_DEVICE_TABLE(snd_sis7019_ids) = {
+static const struct pci_device_id snd_sis7019_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_SI, 0x7019) },
 	{ 0, }
 };

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index e413b4e2c819..6b26b93e001d 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1404,8 +1404,6 @@ static int sis_chip_create(struct snd_card *card,
 	if (rc)
 		goto error_out_cleanup;
 
-	snd_card_set_dev(card, &pci->dev);
-
 	return 0;
 
 error_out_cleanup:
@@ -1440,7 +1438,8 @@ static int snd_sis7019_probe(struct pci_dev *pci,
 	if (!codecs)
 		codecs = SIS_PRIMARY_CODEC_PRESENT;
 
-	rc = snd_card_create(index, id, THIS_MODULE, sizeof(*sis), &card);
+	rc = snd_card_new(&pci->dev, index, id, THIS_MODULE,
+			  sizeof(*sis), &card);
 	if (rc < 0)
 		goto error_out;
 

commit c9e34d1525ffd554f29dc01674eac279de2e759d
Merge: 02b504d9d8e5 11e7064f35bb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 5 15:21:29 2013 +0200

    Merge branch 'for-linus' into for-next
    
    * for-linus: (778 commits)
      ALSA: usb-audio - Fix invalid volume resolution on Logitech HD webcam c270
      ALSA: usb-audio - Apply Logitech QuickCam Pro 9000 quirk only to audio iface
      ALSA: hda/via - Clean up duplicated codes
      ALSA: hda/via - Fix wrongly cleared pins after suspend on VT1802
      ALSA: hda - Add keep_eapd_on flag to generic parser
      ALSA: hda - Allow setting automute/automic hooks after parsing
      ALSA: hda/via - Disable broken dynamic power control
      ALSA: usb-audio: fix Roland/Cakewalk UM-3G support
      ALSA: hda - Add headset quirk for two Dell machines
      ALSA: hda - add dock support for Thinkpad T431s
      ALSA: sis7019: fix error return code in sis_chip_create()
      ASoC: cs42l52: fix default value for MASTERA_VOL.
      ASoC: wm8994: check for array index returned
      ASoC: wm8994: Fix reporting of accessory removal on WM8958
      ASoC: wm8994: use the correct pointer to get the control value
      Linux 3.10-rc3
      ipc/sem.c: Fix missing wakeups in do_smart_update_queue()
      score: remove redundant kcore_list entries
      ASoC: wm5110: Correct DSP4R Mixer control name
      ARC: lazy dcache flush broke gdb in non-aliasing configs
      ...

commit 8b1dacb6ae15c94d50642a474e5af8981555253b
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Thu May 30 19:55:34 2013 +0800

    ALSA: sis7019: fix error return code in sis_chip_create()
    
    Fix to return a negative error code in the pci_set_dma_mask() error
    handling case instead of 0, as done elsewhere in this function.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index d59abe1682c5..748e82d4d257 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1341,7 +1341,8 @@ static int sis_chip_create(struct snd_card *card,
 	if (rc)
 		goto error_out;
 
-	if (pci_set_dma_mask(pci, DMA_BIT_MASK(30)) < 0) {
+	rc = pci_set_dma_mask(pci, DMA_BIT_MASK(30));
+	if (rc < 0) {
 		dev_err(&pci->dev, "architecture does not support 30-bit PCI busmaster DMA");
 		goto error_out_enabled;
 	}

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index d59abe1682c5..f2639a0c5a65 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1481,7 +1481,6 @@ static int snd_sis7019_probe(struct pci_dev *pci,
 static void snd_sis7019_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 static struct pci_driver sis7019_driver = {

commit a2013a13e68354e0c8f3696b69701803e13fb737
Merge: dadfab487325 106f9d9337f6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 13 12:00:02 2012 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial branch from Jiri Kosina:
     "Usual stuff -- comment/printk typo fixes, documentation updates, dead
      code elimination."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (39 commits)
      HOWTO: fix double words typo
      x86 mtrr: fix comment typo in mtrr_bp_init
      propagate name change to comments in kernel source
      doc: Update the name of profiling based on sysfs
      treewide: Fix typos in various drivers
      treewide: Fix typos in various Kconfig
      wireless: mwifiex: Fix typo in wireless/mwifiex driver
      messages: i2o: Fix typo in messages/i2o
      scripts/kernel-doc: check that non-void fcts describe their return value
      Kernel-doc: Convention: Use a "Return" section to describe return values
      radeon: Fix typo and copy/paste error in comments
      doc: Remove unnecessary declarations from Documentation/accounting/getdelays.c
      various: Fix spelling of "asynchronous" in comments.
      Fix misspellings of "whether" in comments.
      eisa: Fix spelling of "asynchronous".
      various: Fix spelling of "registered" in comments.
      doc: fix quite a few typos within Documentation
      target: iscsi: fix comment typos in target/iscsi drivers
      treewide: fix typo of "suport" in various comments and Kconfig
      treewide: fix typo of "suppport" in various comments
      ...

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 51e43407ebc5..550b9cfb8e3e 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -894,7 +894,7 @@ static struct snd_pcm_ops sis_capture_ops = {
 	.pointer = sis_pcm_pointer,
 };
 
-static int __devinit sis_pcm_create(struct sis7019 *sis)
+static int sis_pcm_create(struct sis7019 *sis)
 {
 	struct snd_pcm *pcm;
 	int rc;
@@ -1013,7 +1013,7 @@ static unsigned short sis_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
 					(reg << 8) | cmd[ac97->num]);
 }
 
-static int __devinit sis_mixer_create(struct sis7019 *sis)
+static int sis_mixer_create(struct sis7019 *sis)
 {
 	struct snd_ac97_bus *bus;
 	struct snd_ac97_template ac97;
@@ -1326,8 +1326,8 @@ static int sis_alloc_suspend(struct sis7019 *sis)
 	return 0;
 }
 
-static int __devinit sis_chip_create(struct snd_card *card,
-					struct pci_dev *pci)
+static int sis_chip_create(struct snd_card *card,
+			   struct pci_dev *pci)
 {
 	struct sis7019 *sis = card->private_data;
 	struct voice *voice;
@@ -1417,8 +1417,8 @@ static int __devinit sis_chip_create(struct snd_card *card,
 	return rc;
 }
 
-static int __devinit snd_sis7019_probe(struct pci_dev *pci,
-					const struct pci_device_id *pci_id)
+static int snd_sis7019_probe(struct pci_dev *pci,
+			     const struct pci_device_id *pci_id)
 {
 	struct snd_card *card;
 	struct sis7019 *sis;
@@ -1478,7 +1478,7 @@ static int __devinit snd_sis7019_probe(struct pci_dev *pci,
 	return rc;
 }
 
-static void __devexit snd_sis7019_remove(struct pci_dev *pci)
+static void snd_sis7019_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -1488,7 +1488,7 @@ static struct pci_driver sis7019_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_sis7019_ids,
 	.probe = snd_sis7019_probe,
-	.remove = __devexit_p(snd_sis7019_remove),
+	.remove = snd_sis7019_remove,
 	.driver = {
 		.pm = SIS_PM_OPS,
 	},

commit b3834be5c42a5d2fd85ff4b819fa38983b1450e6
Author: Adam Buchbinder <adam.buchbinder@gmail.com>
Date:   Wed Sep 19 21:48:02 2012 -0400

    various: Fix spelling of "asynchronous" in comments.
    
    "Asynchronous" is misspelled in some comments. No code changes.
    
    Signed-off-by: Adam Buchbinder <adam.buchbinder@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 51e43407ebc5..9024545ebb86 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1171,7 +1171,7 @@ static int sis_chip_init(struct sis7019 *sis)
 	outl(SIS_DMA_CSR_PCI_SETTINGS, io + SIS_DMA_CSR);
 
 	/* Reset the synchronization groups for all of the channels
-	 * to be asyncronous. If we start doing SPDIF or 5.1 sound, etc.
+	 * to be asynchronous. If we start doing SPDIF or 5.1 sound, etc.
 	 * we'll need to change how we handle these. Until then, we just
 	 * assign sub-mixer 0 to all playback channels, and avoid any
 	 * attenuation on the audio.

commit ddf83485d7da468251716b8040bac1280622181e
Merge: 099d53c308f5 535b6c51fe82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Aug 20 22:14:26 2012 +0200

    Merge branch 'for-linus' into for-next
    
    Conflicts:
            sound/pci/hda/hda_codec.c
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit ae970eb45d8a1ea4506be23c3f776225b9575d0e
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Aug 19 09:02:55 2012 +0200

    ALSA: sound/pci/sis7019.c: fix error return code
    
    Initialize rc before returning on failure, as done elsewhere in the
    function.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    (
    if@p1 (\(ret < 0\|ret != 0\))
     { ... return ret; }
    |
    ret@p1 = 0
    )
    ... when != ret = e1
        when != &ret
    *if(...)
    {
      ... when != ret = e2
          when forall
     return ret;
    }
    
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 512434efcc31..805ab6e9a78f 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1377,8 +1377,9 @@ static int __devinit sis_chip_create(struct snd_card *card,
 	if (rc)
 		goto error_out_cleanup;
 
-	if (request_irq(pci->irq, sis_interrupt, IRQF_SHARED, KBUILD_MODNAME,
-			sis)) {
+	rc = request_irq(pci->irq, sis_interrupt, IRQF_SHARED, KBUILD_MODNAME,
+			 sis);
+	if (rc) {
 		dev_err(&pci->dev, "unable to allocate irq %d\n", sis->irq);
 		goto error_out_cleanup;
 	}

commit c7561cd80469f2fe4a6be0984db57832ee7f2a3b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 14 18:12:04 2012 +0200

    ALSA: PCI: Replace CONFIG_PM with CONFIG_PM_SLEEP
    
    Otherwise we may get compile warnings due to unused functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 512434efcc31..535efe295075 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -103,7 +103,7 @@ struct voice {
  * we're not doing power management, we still need to allocate a page
  * for the silence buffer.
  */
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 #define SIS_SUSPEND_PAGES	4
 #else
 #define SIS_SUSPEND_PAGES	1
@@ -1208,7 +1208,7 @@ static int sis_chip_init(struct sis7019 *sis)
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int sis_suspend(struct device *dev)
 {
 	struct pci_dev *pci = to_pci_dev(dev);
@@ -1305,7 +1305,7 @@ static SIMPLE_DEV_PM_OPS(sis_pm, sis_suspend, sis_resume);
 #define SIS_PM_OPS	&sis_pm
 #else
 #define SIS_PM_OPS	NULL
-#endif /* CONFIG_PM */
+#endif /* CONFIG_PM_SLEEP */
 
 static int sis_alloc_suspend(struct sis7019 *sis)
 {

commit 68cb2b559278858ef9f3a7722f95df88797c7840
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 15:20:37 2012 +0200

    ALSA: Convert to new pm_ops for PCI drivers
    
    Straightforward conversion to the new pm_ops from the legacy
    suspend/resume ops.
    
    Since we change vx222, vx_core and vxpocket have to be converted,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 1552642765d6..512434efcc31 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1209,9 +1209,10 @@ static int sis_chip_init(struct sis7019 *sis)
 }
 
 #ifdef CONFIG_PM
-static int sis_suspend(struct pci_dev *pci, pm_message_t state)
+static int sis_suspend(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct sis7019 *sis = card->private_data;
 	void __iomem *ioaddr = sis->ioaddr;
 	int i;
@@ -1241,13 +1242,14 @@ static int sis_suspend(struct pci_dev *pci, pm_message_t state)
 
 	pci_disable_device(pci);
 	pci_save_state(pci);
-	pci_set_power_state(pci, pci_choose_state(pci, state));
+	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
-static int sis_resume(struct pci_dev *pci)
+static int sis_resume(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct sis7019 *sis = card->private_data;
 	void __iomem *ioaddr = sis->ioaddr;
 	int i;
@@ -1298,6 +1300,11 @@ static int sis_resume(struct pci_dev *pci)
 	snd_card_disconnect(card);
 	return -EIO;
 }
+
+static SIMPLE_DEV_PM_OPS(sis_pm, sis_suspend, sis_resume);
+#define SIS_PM_OPS	&sis_pm
+#else
+#define SIS_PM_OPS	NULL
 #endif /* CONFIG_PM */
 
 static int sis_alloc_suspend(struct sis7019 *sis)
@@ -1481,11 +1488,9 @@ static struct pci_driver sis7019_driver = {
 	.id_table = snd_sis7019_ids,
 	.probe = snd_sis7019_probe,
 	.remove = __devexit_p(snd_sis7019_remove),
-
-#ifdef CONFIG_PM
-	.suspend = sis_suspend,
-	.resume = sis_resume,
-#endif
+	.driver = {
+		.pm = SIS_PM_OPS,
+	},
 };
 
 module_pci_driver(sis7019_driver);

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index ff500a87f769..1552642765d6 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1488,15 +1488,4 @@ static struct pci_driver sis7019_driver = {
 #endif
 };
 
-static int __init sis7019_init(void)
-{
-	return pci_register_driver(&sis7019_driver);
-}
-
-static void __exit sis7019_exit(void)
-{
-	pci_unregister_driver(&sis7019_driver);
-}
-
-module_init(sis7019_init);
-module_exit(sis7019_exit);
+module_pci_driver(sis7019_driver);

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 7331b2d649ca..ff500a87f769 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -40,7 +40,7 @@ MODULE_SUPPORTED_DEVICE("{{SiS,SiS7019 Audio Accelerator}}");
 
 static int index = SNDRV_DEFAULT_IDX1;	/* Index 0-MAX */
 static char *id = SNDRV_DEFAULT_STR1;	/* ID for this card */
-static int enable = 1;
+static bool enable = 1;
 static int codecs = 1;
 
 module_param(index, int, 0444);

commit 705978516fe4a5e0b5726e2ea860c1bfc6909472
Author: David Dillow <dave@thedillows.org>
Date:   Thu Dec 1 23:26:57 2011 -0500

    ALSA: sis7019 - convert to dev_*() logging
    
    Signed-off-by: David Dillow <dave@thedillows.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 28dfafb56dd1..7331b2d649ca 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -983,7 +983,7 @@ static unsigned short sis_ac97_rw(struct sis7019 *sis, int codec, u32 cmd)
 	mutex_unlock(&sis->ac97_mutex);
 
 	if (!count) {
-		printk(KERN_ERR "sis7019: ac97 codec %d timeout cmd 0x%08x\n",
+		dev_err(&sis->pci->dev, "ac97 codec %d timeout cmd 0x%08x\n",
 					codec, cmd);
 	}
 
@@ -1142,13 +1142,13 @@ static int sis_chip_init(struct sis7019 *sis)
 	/* All done, check for errors.
 	 */
 	if (!sis->codecs_present) {
-		printk(KERN_ERR "sis7019: could not find any codecs\n");
+		dev_err(&sis->pci->dev, "could not find any codecs\n");
 		return -EIO;
 	}
 
 	if (sis->codecs_present != codecs) {
-		printk(KERN_WARNING "sis7019: missing codecs, found %0x, expected %0x\n",
-		       sis->codecs_present, codecs);
+		dev_warn(&sis->pci->dev, "missing codecs, found %0x, expected %0x\n",
+					 sis->codecs_present, codecs);
 	}
 
 	/* Let the hardware know that the audio driver is alive,
@@ -1256,18 +1256,18 @@ static int sis_resume(struct pci_dev *pci)
 	pci_restore_state(pci);
 
 	if (pci_enable_device(pci) < 0) {
-		printk(KERN_ERR "sis7019: unable to re-enable device\n");
+		dev_err(&pci->dev, "unable to re-enable device\n");
 		goto error;
 	}
 
 	if (sis_chip_init(sis)) {
-		printk(KERN_ERR "sis7019: unable to re-init controller\n");
+		dev_err(&pci->dev, "unable to re-init controller\n");
 		goto error;
 	}
 
 	if (request_irq(pci->irq, sis_interrupt, IRQF_SHARED,
 			KBUILD_MODNAME, sis)) {
-		printk(KERN_ERR "sis7019: unable to regain IRQ %d\n", pci->irq);
+		dev_err(&pci->dev, "unable to regain IRQ %d\n", pci->irq);
 		goto error;
 	}
 
@@ -1335,8 +1335,7 @@ static int __devinit sis_chip_create(struct snd_card *card,
 		goto error_out;
 
 	if (pci_set_dma_mask(pci, DMA_BIT_MASK(30)) < 0) {
-		printk(KERN_ERR "sis7019: architecture does not support "
-					"30-bit PCI busmaster DMA");
+		dev_err(&pci->dev, "architecture does not support 30-bit PCI busmaster DMA");
 		goto error_out_enabled;
 	}
 
@@ -1350,20 +1349,20 @@ static int __devinit sis_chip_create(struct snd_card *card,
 
 	rc = pci_request_regions(pci, "SiS7019");
 	if (rc) {
-		printk(KERN_ERR "sis7019: unable request regions\n");
+		dev_err(&pci->dev, "unable request regions\n");
 		goto error_out_enabled;
 	}
 
 	rc = -EIO;
 	sis->ioaddr = ioremap_nocache(pci_resource_start(pci, 1), 0x4000);
 	if (!sis->ioaddr) {
-		printk(KERN_ERR "sis7019: unable to remap MMIO, aborting\n");
+		dev_err(&pci->dev, "unable to remap MMIO, aborting\n");
 		goto error_out_cleanup;
 	}
 
 	rc = sis_alloc_suspend(sis);
 	if (rc < 0) {
-		printk(KERN_ERR "sis7019: unable to allocate state storage\n");
+		dev_err(&pci->dev, "unable to allocate state storage\n");
 		goto error_out_cleanup;
 	}
 
@@ -1371,9 +1370,9 @@ static int __devinit sis_chip_create(struct snd_card *card,
 	if (rc)
 		goto error_out_cleanup;
 
-	if (request_irq(pci->irq, sis_interrupt, IRQF_SHARED,
-			KBUILD_MODNAME, sis)) {
-		printk(KERN_ERR "unable to allocate irq %d\n", sis->irq);
+	if (request_irq(pci->irq, sis_interrupt, IRQF_SHARED, KBUILD_MODNAME,
+			sis)) {
+		dev_err(&pci->dev, "unable to allocate irq %d\n", sis->irq);
 		goto error_out_cleanup;
 	}
 

commit fc084e0b930d546872ab23667052499f7daf0fed
Author: David Dillow <dave@thedillows.org>
Date:   Thu Dec 1 23:26:53 2011 -0500

    ALSA: sis7019 - give slow codecs more time to reset
    
    There are some AC97 codec and board combinations that have been observed
    to take a very long time to respond after the cold reset has completed.
    In one case, more than 350 ms was required. To allow users to have sound
    on those platforms, we'll wait up to 500ms for the codec to become
    ready.
    
    As a board may have multiple codecs, with some faster than others to
    reset, we add a module parameter to inform the driver which codecs
    should be present.
    
    Reported-by: KotCzarny <tjosko@yahoo.com>
    Signed-off-by: David Dillow <dave@thedillows.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index a391e622a192..28dfafb56dd1 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -41,6 +41,7 @@ MODULE_SUPPORTED_DEVICE("{{SiS,SiS7019 Audio Accelerator}}");
 static int index = SNDRV_DEFAULT_IDX1;	/* Index 0-MAX */
 static char *id = SNDRV_DEFAULT_STR1;	/* ID for this card */
 static int enable = 1;
+static int codecs = 1;
 
 module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for SiS7019 Audio Accelerator.");
@@ -48,6 +49,8 @@ module_param(id, charp, 0444);
 MODULE_PARM_DESC(id, "ID string for SiS7019 Audio Accelerator.");
 module_param(enable, bool, 0444);
 MODULE_PARM_DESC(enable, "Enable SiS7019 Audio Accelerator.");
+module_param(codecs, int, 0444);
+MODULE_PARM_DESC(codecs, "Set bit to indicate that codec number is expected to be present (default 1)");
 
 static DEFINE_PCI_DEVICE_TABLE(snd_sis7019_ids) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_SI, 0x7019) },
@@ -140,6 +143,9 @@ struct sis7019 {
 	dma_addr_t silence_dma_addr;
 };
 
+/* These values are also used by the module param 'codecs' to indicate
+ * which codecs should be present.
+ */
 #define SIS_PRIMARY_CODEC_PRESENT	0x0001
 #define SIS_SECONDARY_CODEC_PRESENT	0x0002
 #define SIS_TERTIARY_CODEC_PRESENT	0x0004
@@ -1078,6 +1084,7 @@ static int sis_chip_init(struct sis7019 *sis)
 {
 	unsigned long io = sis->ioport;
 	void __iomem *ioaddr = sis->ioaddr;
+	unsigned long timeout;
 	u16 status;
 	int count;
 	int i;
@@ -1104,21 +1111,45 @@ static int sis_chip_init(struct sis7019 *sis)
 	while ((inw(io + SIS_AC97_STATUS) & SIS_AC97_STATUS_BUSY) && --count)
 		udelay(1);
 
+	/* Command complete, we can let go of the semaphore now.
+	 */
+	outl(SIS_AC97_SEMA_RELEASE, io + SIS_AC97_SEMA);
+	if (!count)
+		return -EIO;
+
 	/* Now that we've finished the reset, find out what's attached.
+	 * There are some codec/board combinations that take an extremely
+	 * long time to come up. 350+ ms has been observed in the field,
+	 * so we'll give them up to 500ms.
 	 */
-	status = inl(io + SIS_AC97_STATUS);
-	if (status & SIS_AC97_STATUS_CODEC_READY)
-		sis->codecs_present |= SIS_PRIMARY_CODEC_PRESENT;
-	if (status & SIS_AC97_STATUS_CODEC2_READY)
-		sis->codecs_present |= SIS_SECONDARY_CODEC_PRESENT;
-	if (status & SIS_AC97_STATUS_CODEC3_READY)
-		sis->codecs_present |= SIS_TERTIARY_CODEC_PRESENT;
-
-	/* All done, let go of the semaphore, and check for errors
+	sis->codecs_present = 0;
+	timeout = msecs_to_jiffies(500) + jiffies;
+	while (time_before_eq(jiffies, timeout)) {
+		status = inl(io + SIS_AC97_STATUS);
+		if (status & SIS_AC97_STATUS_CODEC_READY)
+			sis->codecs_present |= SIS_PRIMARY_CODEC_PRESENT;
+		if (status & SIS_AC97_STATUS_CODEC2_READY)
+			sis->codecs_present |= SIS_SECONDARY_CODEC_PRESENT;
+		if (status & SIS_AC97_STATUS_CODEC3_READY)
+			sis->codecs_present |= SIS_TERTIARY_CODEC_PRESENT;
+
+		if (sis->codecs_present == codecs)
+			break;
+
+		msleep(1);
+	}
+
+	/* All done, check for errors.
 	 */
-	outl(SIS_AC97_SEMA_RELEASE, io + SIS_AC97_SEMA);
-	if (!sis->codecs_present || !count)
+	if (!sis->codecs_present) {
+		printk(KERN_ERR "sis7019: could not find any codecs\n");
 		return -EIO;
+	}
+
+	if (sis->codecs_present != codecs) {
+		printk(KERN_WARNING "sis7019: missing codecs, found %0x, expected %0x\n",
+		       sis->codecs_present, codecs);
+	}
 
 	/* Let the hardware know that the audio driver is alive,
 	 * and enable PCM slots on the AC-link for L/R playback (3 & 4) and
@@ -1390,6 +1421,17 @@ static int __devinit snd_sis7019_probe(struct pci_dev *pci,
 	if (!enable)
 		goto error_out;
 
+	/* The user can specify which codecs should be present so that we
+	 * can wait for them to show up if they are slow to recover from
+	 * the AC97 cold reset. We default to a single codec, the primary.
+	 *
+	 * We assume that SIS_PRIMARY_*_PRESENT matches bits 0-2.
+	 */
+	codecs &= SIS_PRIMARY_CODEC_PRESENT | SIS_SECONDARY_CODEC_PRESENT |
+		  SIS_TERTIARY_CODEC_PRESENT;
+	if (!codecs)
+		codecs = SIS_PRIMARY_CODEC_PRESENT;
+
 	rc = snd_card_create(index, id, THIS_MODULE, sizeof(*sis), &card);
 	if (rc < 0)
 		goto error_out;

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 5ffb20b18786..a391e622a192 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -25,7 +25,7 @@
 #include <linux/pci.h>
 #include <linux/time.h>
 #include <linux/slab.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 #include <sound/core.h>

commit 88e24c3a4b30a6bd361f2b5ce602667a8161b2e8
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Thu Sep 22 16:59:20 2011 +0800

    sound: irq: Remove IRQF_DISABLED
    
    Since commit [e58aa3d2: genirq: Run irq handlers with interrupts disabled],
    We run all interrupt handlers with interrupts disabled
    and we even check and yell when an interrupt handler
    returns with interrupts enabled (see commit [b738a50a:
    genirq: Warn when handler enables interrupts]).
    
    So now this flag is a NOOP and can be removed.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index bcf61524a13f..5ffb20b18786 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1234,7 +1234,7 @@ static int sis_resume(struct pci_dev *pci)
 		goto error;
 	}
 
-	if (request_irq(pci->irq, sis_interrupt, IRQF_DISABLED|IRQF_SHARED,
+	if (request_irq(pci->irq, sis_interrupt, IRQF_SHARED,
 			KBUILD_MODNAME, sis)) {
 		printk(KERN_ERR "sis7019: unable to regain IRQ %d\n", pci->irq);
 		goto error;
@@ -1340,7 +1340,7 @@ static int __devinit sis_chip_create(struct snd_card *card,
 	if (rc)
 		goto error_out_cleanup;
 
-	if (request_irq(pci->irq, sis_interrupt, IRQF_DISABLED|IRQF_SHARED,
+	if (request_irq(pci->irq, sis_interrupt, IRQF_SHARED,
 			KBUILD_MODNAME, sis)) {
 		printk(KERN_ERR "unable to allocate irq %d\n", sis->irq);
 		goto error_out_cleanup;

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 02654dc1d382..bcf61524a13f 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1235,7 +1235,7 @@ static int sis_resume(struct pci_dev *pci)
 	}
 
 	if (request_irq(pci->irq, sis_interrupt, IRQF_DISABLED|IRQF_SHARED,
-				card->shortname, sis)) {
+			KBUILD_MODNAME, sis)) {
 		printk(KERN_ERR "sis7019: unable to regain IRQ %d\n", pci->irq);
 		goto error;
 	}
@@ -1341,7 +1341,7 @@ static int __devinit sis_chip_create(struct snd_card *card,
 		goto error_out_cleanup;
 
 	if (request_irq(pci->irq, sis_interrupt, IRQF_DISABLED|IRQF_SHARED,
-				card->shortname, sis)) {
+			KBUILD_MODNAME, sis)) {
 		printk(KERN_ERR "unable to allocate irq %d\n", sis->irq);
 		goto error_out_cleanup;
 	}

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 2b5c7a95ae1f..02654dc1d382 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1436,7 +1436,7 @@ static void __devexit snd_sis7019_remove(struct pci_dev *pci)
 }
 
 static struct pci_driver sis7019_driver = {
-	.name = "SiS7019",
+	.name = KBUILD_MODNAME,
 	.id_table = snd_sis7019_ids,
 	.probe = snd_sis7019_probe,
 	.remove = __devexit_p(snd_sis7019_remove),

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 1b8f6742b5fa..2b5c7a95ae1f 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -308,7 +308,7 @@ static irqreturn_t sis_interrupt(int irq, void *dev)
 	u32 intr, status;
 
 	/* We only use the DMA interrupts, and we don't enable any other
-	 * source of interrupts. But, it is possible to see an interupt
+	 * source of interrupts. But, it is possible to see an interrupt
 	 * status that didn't actually interrupt us, so eliminate anything
 	 * we're not expecting to avoid falsely claiming an IRQ, and an
 	 * ensuing endless loop.
@@ -773,7 +773,7 @@ static void sis_prepare_timing_voice(struct voice *voice,
 		vperiod = 0;
 	}
 
-	/* The interrupt handler implements the timing syncronization, so
+	/* The interrupt handler implements the timing synchronization, so
 	 * setup its state.
 	 */
 	timing->flags |= VOICE_SYNC_TIMING;
@@ -1139,7 +1139,7 @@ static int sis_chip_init(struct sis7019 *sis)
 	 */
 	outl(SIS_DMA_CSR_PCI_SETTINGS, io + SIS_DMA_CSR);
 
-	/* Reset the syncronization groups for all of the channels
+	/* Reset the synchronization groups for all of the channels
 	 * to be asyncronous. If we start doing SPDIF or 5.1 sound, etc.
 	 * we'll need to change how we handle these. Until then, we just
 	 * assign sub-mixer 0 to all playback channels, and avoid any

commit 08b450988905505d12f7671bc24b8da73631d327
Author: David Dillow <dave@thedillows.org>
Date:   Sun Jun 27 00:07:57 2010 +0200

    sis7019: increase reset delays
    
    A few boards using this controller are reported to need a little extra
    time during their reset cycle.
    
    Reported-by: Michael Goeke <michael.goeke@icachip.de>
    Signed-off-by: Dave Dillow <dave@thedillows.org>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 614ff6e514fd..1b8f6742b5fa 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1049,7 +1049,7 @@ static int sis_chip_free(struct sis7019 *sis)
 	/* Reset the chip, and disable all interrputs.
 	 */
 	outl(SIS_GCR_SOFTWARE_RESET, sis->ioport + SIS_GCR);
-	udelay(10);
+	udelay(25);
 	outl(0, sis->ioport + SIS_GCR);
 	outl(0, sis->ioport + SIS_GIER);
 
@@ -1085,7 +1085,7 @@ static int sis_chip_init(struct sis7019 *sis)
 	/* Reset the audio controller
 	 */
 	outl(SIS_GCR_SOFTWARE_RESET, io + SIS_GCR);
-	udelay(10);
+	udelay(25);
 	outl(0, io + SIS_GCR);
 
 	/* Get the AC-link semaphore, and reset the codecs
@@ -1098,7 +1098,7 @@ static int sis_chip_init(struct sis7019 *sis)
 		return -EIO;
 
 	outl(SIS_AC97_CMD_CODEC_COLD_RESET, io + SIS_AC97_CMD);
-	udelay(10);
+	udelay(250);
 
 	count = 0xffff;
 	while ((inw(io + SIS_AC97_STATUS) & SIS_AC97_STATUS_BUSY) && --count)

commit 3a3d5fd125f82200019ef406c4d51ba4d9f0a604
Author: David Dillow <dave@thedillows.org>
Date:   Sun Jun 27 00:04:32 2010 +0200

    sis7019: fix capture issues with multiple periods per buffer
    
    When using a timing voice to clock out periods during capture, the
    driver would slowly loose synchronization and never catch up, eventually
    reaching a point where it no longer generated interrupts. To avoid
    this situation, the virtual period clocking was changed to shorten the
    next timing period when our timing voice falls too far behind the
    capture voice. In addition, the first virtual period for the timing
    voice was slightly too short, causing the timing voice to initially be
    ahead of the capture voice.
    
    While tracking down this problem, I noticed that the expected sample
    offset was being incorrectly initialized, causing an overrun to be
    incorrectly reported when the timing voice happened to be perfectly
    synchronized.
    
    Reported-by: Hans Schou <linux@schou.dk>
    Signed-off-by: Dave Dillow <dave@thedillows.org>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 9cc1b5aa0148..614ff6e514fd 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -264,11 +264,13 @@ static void sis_update_voice(struct voice *voice)
 		 * if using small periods.
 		 *
 		 * If we're less than 9 samples behind, we're on target.
+		 * Otherwise, shorten the next vperiod by the amount we've
+		 * been delayed.
 		 */
 		if (sync > -9)
 			voice->vperiod = voice->sync_period_size + 1;
 		else
-			voice->vperiod = voice->sync_period_size - 4;
+			voice->vperiod = voice->sync_period_size + sync + 10;
 
 		if (voice->vperiod < voice->buffer_size) {
 			sis_update_sso(voice, voice->vperiod);
@@ -736,7 +738,7 @@ static void sis_prepare_timing_voice(struct voice *voice,
 	period_size = buffer_size;
 
 	/* Initially, we want to interrupt just a bit behind the end of
-	 * the period we're clocking out. 10 samples seems to give a good
+	 * the period we're clocking out. 12 samples seems to give a good
 	 * delay.
 	 *
 	 * We want to spread our interrupts throughout the virtual period,
@@ -747,7 +749,7 @@ static void sis_prepare_timing_voice(struct voice *voice,
 	 *
 	 * This is all moot if we don't need to use virtual periods.
 	 */
-	vperiod = runtime->period_size + 10;
+	vperiod = runtime->period_size + 12;
 	if (vperiod > period_size) {
 		u16 tail = vperiod % period_size;
 		u16 quarter_period = period_size / 4;
@@ -776,7 +778,7 @@ static void sis_prepare_timing_voice(struct voice *voice,
 	 */
 	timing->flags |= VOICE_SYNC_TIMING;
 	timing->sync_base = voice->ctrl_base;
-	timing->sync_cso = runtime->period_size - 1;
+	timing->sync_cso = runtime->period_size;
 	timing->sync_period_size = runtime->period_size;
 	timing->sync_buffer_size = runtime->buffer_size;
 	timing->period_size = period_size;

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 7e3e8fbc90fe..9cc1b5aa0148 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/time.h>
+#include <linux/slab.h>
 #include <linux/moduleparam.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 1a5ff0611072..7e3e8fbc90fe 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -48,7 +48,7 @@ MODULE_PARM_DESC(id, "ID string for SiS7019 Audio Accelerator.");
 module_param(enable, bool, 0444);
 MODULE_PARM_DESC(enable, "Enable SiS7019 Audio Accelerator.");
 
-static struct pci_device_id snd_sis7019_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_sis7019_ids) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_SI, 0x7019) },
 	{ 0, }
 };

commit 28b767967763835d8526f6baedc25a8a86052640
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:17 2009 -0700

    dma-mapping: replace all DMA_30BIT_MASK macro with DMA_BIT_MASK(30)
    
    Replace all DMA_30BIT_MASK macro with DMA_BIT_MASK(30)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index baf6d8e3dabc..1a5ff0611072 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1300,7 +1300,7 @@ static int __devinit sis_chip_create(struct snd_card *card,
 	if (rc)
 		goto error_out;
 
-	if (pci_set_dma_mask(pci, DMA_30BIT_MASK) < 0) {
+	if (pci_set_dma_mask(pci, DMA_BIT_MASK(30)) < 0) {
 		printk(KERN_ERR "sis7019: architecture does not support "
 					"30-bit PCI busmaster DMA");
 		goto error_out_enabled;

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index df2007e3be7c..baf6d8e3dabc 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1387,9 +1387,8 @@ static int __devinit snd_sis7019_probe(struct pci_dev *pci,
 	if (!enable)
 		goto error_out;
 
-	rc = -ENOMEM;
-	card = snd_card_new(index, id, THIS_MODULE, sizeof(*sis));
-	if (!card)
+	rc = snd_card_create(index, id, THIS_MODULE, sizeof(*sis), &card);
+	if (rc < 0)
 		goto error_out;
 
 	strcpy(card->driver, "SiS7019");

commit f000fd80937c0d94c67f9f3e7026f1fbc8ef8873
Author: Jeff Garzik <jgarzik@redhat.com>
Date:   Tue Apr 22 13:50:34 2008 +0200

    [ALSA] Fix synchronize_irq() bugs, redundancies
    
    free_irq() calls synchronize_irq() for you, so there is no need for
    drivers to manually do the same thing (again).  Thus, calls where
    sync-irq immediately precedes free-irq can be simplified.
    
    However, during this audit several bugs were noticed, where free-irq is
    preceded by a "irq >= 0" check... but the sync-irq call is not covered
    by the same check.
    
    So, where sync-irq could not be eliminated completely, the missing check
    was added.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 742f1180c39e..df2007e3be7c 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -1194,7 +1194,6 @@ static int sis_suspend(struct pci_dev *pci, pm_message_t state)
 	/* snd_pcm_suspend_all() stopped all channels, so we're quiescent.
 	 */
 	if (sis->irq >= 0) {
-		synchronize_irq(sis->irq);
 		free_irq(sis->irq, sis);
 		sis->irq = -1;
 	}

commit 3f76d9841e9cf6dd969ff3aec96476dced9c53f8
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Mon Apr 21 22:25:51 2008 +0000

    ALSA: Storage class should be before const qualifier
    
    The C99 specification states in section 6.11.5:
    
    The placement of a storage-class specifier other than at the
    beginning of the declaration specifiers in a declaration is an
    obsolescent feature.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index dcd7cd010461..742f1180c39e 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -920,7 +920,7 @@ static unsigned short sis_ac97_rw(struct sis7019 *sis, int codec, u32 cmd)
 	u16 status;
 	u16 rdy;
 	int count;
-	const static u16 codec_ready[3] = {
+	static const u16 codec_ready[3] = {
 		SIS_AC97_STATUS_CODEC_READY,
 		SIS_AC97_STATUS_CODEC2_READY,
 		SIS_AC97_STATUS_CODEC3_READY,
@@ -984,7 +984,7 @@ static unsigned short sis_ac97_rw(struct sis7019 *sis, int codec, u32 cmd)
 static void sis_ac97_write(struct snd_ac97 *ac97, unsigned short reg,
 				unsigned short val)
 {
-	const static u32 cmd[3] = {
+	static const u32 cmd[3] = {
 		SIS_AC97_CMD_CODEC_WRITE,
 		SIS_AC97_CMD_CODEC2_WRITE,
 		SIS_AC97_CMD_CODEC3_WRITE,
@@ -995,7 +995,7 @@ static void sis_ac97_write(struct snd_ac97 *ac97, unsigned short reg,
 
 static unsigned short sis_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
 {
-	const static u32 cmd[3] = {
+	static const u32 cmd[3] = {
 		SIS_AC97_CMD_CODEC_READ,
 		SIS_AC97_CMD_CODEC2_READ,
 		SIS_AC97_CMD_CODEC3_READ,

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
index 2f178598186d..dcd7cd010461 100644
--- a/sound/pci/sis7019.c
+++ b/sound/pci/sis7019.c
@@ -21,7 +21,6 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/time.h>

commit 175859bf1602c7ee38d720daa14a287072cc2b72
Author: David Dillow <dave@thedillows.org>
Date:   Fri Dec 14 14:40:23 2007 +0100

    [ALSA] sis7019: support the SiS 7019 Audio Accelerator
    
    Basic audio support for the SiS 7019 Audio Accelerator as found in the
    SiS 55x SoC. There is currently no synth support at the moment, but
    audio playback and capture with two periods per buffer has seen
    extensive use. Arbitrary period and buffer sizes (with multiple periods
    per buffer) have seen light testing, but are believed to be production
    ready.
    
    Signed-off-by: David Dillow <dave@thedillows.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/sis7019.c b/sound/pci/sis7019.c
new file mode 100644
index 000000000000..2f178598186d
--- /dev/null
+++ b/sound/pci/sis7019.c
@@ -0,0 +1,1461 @@
+/*
+ *  Driver for SiS7019 Audio Accelerator
+ *
+ *  Copyright (C) 2004-2007, David Dillow
+ *  Written by David Dillow <dave@thedillows.org>
+ *  Inspired by the Trident 4D-WaveDX/NX driver.
+ *
+ *  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, version 2.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/time.h>
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+#include "sis7019.h"
+
+MODULE_AUTHOR("David Dillow <dave@thedillows.org>");
+MODULE_DESCRIPTION("SiS7019");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{SiS,SiS7019 Audio Accelerator}}");
+
+static int index = SNDRV_DEFAULT_IDX1;	/* Index 0-MAX */
+static char *id = SNDRV_DEFAULT_STR1;	/* ID for this card */
+static int enable = 1;
+
+module_param(index, int, 0444);
+MODULE_PARM_DESC(index, "Index value for SiS7019 Audio Accelerator.");
+module_param(id, charp, 0444);
+MODULE_PARM_DESC(id, "ID string for SiS7019 Audio Accelerator.");
+module_param(enable, bool, 0444);
+MODULE_PARM_DESC(enable, "Enable SiS7019 Audio Accelerator.");
+
+static struct pci_device_id snd_sis7019_ids[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_SI, 0x7019) },
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, snd_sis7019_ids);
+
+/* There are three timing modes for the voices.
+ *
+ * For both playback and capture, when the buffer is one or two periods long,
+ * we use the hardware's built-in Mid-Loop Interrupt and End-Loop Interrupt
+ * to let us know when the periods have ended.
+ *
+ * When performing playback with more than two periods per buffer, we set
+ * the "Stop Sample Offset" and tell the hardware to interrupt us when we
+ * reach it. We then update the offset and continue on until we are
+ * interrupted for the next period.
+ *
+ * Capture channels do not have a SSO, so we allocate a playback channel to
+ * use as a timer for the capture periods. We use the SSO on the playback
+ * channel to clock out virtual periods, and adjust the virtual period length
+ * to maintain synchronization. This algorithm came from the Trident driver.
+ *
+ * FIXME: It'd be nice to make use of some of the synth features in the
+ * hardware, but a woeful lack of documentation is a significant roadblock.
+ */
+struct voice {
+	u16 flags;
+#define 	VOICE_IN_USE		1
+#define 	VOICE_CAPTURE		2
+#define 	VOICE_SSO_TIMING	4
+#define 	VOICE_SYNC_TIMING	8
+	u16 sync_cso;
+	u16 period_size;
+	u16 buffer_size;
+	u16 sync_period_size;
+	u16 sync_buffer_size;
+	u32 sso;
+	u32 vperiod;
+	struct snd_pcm_substream *substream;
+	struct voice *timing;
+	void __iomem *ctrl_base;
+	void __iomem *wave_base;
+	void __iomem *sync_base;
+	int num;
+};
+
+/* We need four pages to store our wave parameters during a suspend. If
+ * we're not doing power management, we still need to allocate a page
+ * for the silence buffer.
+ */
+#ifdef CONFIG_PM
+#define SIS_SUSPEND_PAGES	4
+#else
+#define SIS_SUSPEND_PAGES	1
+#endif
+
+struct sis7019 {
+	unsigned long ioport;
+	void __iomem *ioaddr;
+	int irq;
+	int codecs_present;
+
+	struct pci_dev *pci;
+	struct snd_pcm *pcm;
+	struct snd_card *card;
+	struct snd_ac97 *ac97[3];
+
+	/* Protect against more than one thread hitting the AC97
+	 * registers (in a more polite manner than pounding the hardware
+	 * semaphore)
+	 */
+	struct mutex ac97_mutex;
+
+	/* voice_lock protects allocation/freeing of the voice descriptions
+	 */
+	spinlock_t voice_lock;
+
+	struct voice voices[64];
+	struct voice capture_voice;
+
+	/* Allocate pages to store the internal wave state during
+	 * suspends. When we're operating, this can be used as a silence
+	 * buffer for a timing channel.
+	 */
+	void *suspend_state[SIS_SUSPEND_PAGES];
+
+	int silence_users;
+	dma_addr_t silence_dma_addr;
+};
+
+#define SIS_PRIMARY_CODEC_PRESENT	0x0001
+#define SIS_SECONDARY_CODEC_PRESENT	0x0002
+#define SIS_TERTIARY_CODEC_PRESENT	0x0004
+
+/* The HW offset parameters (Loop End, Stop Sample, End Sample) have a
+ * documented range of 8-0xfff8 samples. Given that they are 0-based,
+ * that places our period/buffer range at 9-0xfff9 samples. That makes the
+ * max buffer size 0xfff9 samples * 2 channels * 2 bytes per sample, and
+ * max samples / min samples gives us the max periods in a buffer.
+ *
+ * We'll add a constraint upon open that limits the period and buffer sample
+ * size to values that are legal for the hardware.
+ */
+static struct snd_pcm_hardware sis_playback_hw_info = {
+	.info = (SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_INTERLEAVED |
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		 SNDRV_PCM_INFO_SYNC_START |
+		 SNDRV_PCM_INFO_RESUME),
+	.formats = (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8 |
+		    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE),
+	.rates = SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_CONTINUOUS,
+	.rate_min = 4000,
+	.rate_max = 48000,
+	.channels_min = 1,
+	.channels_max = 2,
+	.buffer_bytes_max = (0xfff9 * 4),
+	.period_bytes_min = 9,
+	.period_bytes_max = (0xfff9 * 4),
+	.periods_min = 1,
+	.periods_max = (0xfff9 / 9),
+};
+
+static struct snd_pcm_hardware sis_capture_hw_info = {
+	.info = (SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_INTERLEAVED |
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		 SNDRV_PCM_INFO_SYNC_START |
+		 SNDRV_PCM_INFO_RESUME),
+	.formats = (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8 |
+		    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE),
+	.rates = SNDRV_PCM_RATE_48000,
+	.rate_min = 4000,
+	.rate_max = 48000,
+	.channels_min = 1,
+	.channels_max = 2,
+	.buffer_bytes_max = (0xfff9 * 4),
+	.period_bytes_min = 9,
+	.period_bytes_max = (0xfff9 * 4),
+	.periods_min = 1,
+	.periods_max = (0xfff9 / 9),
+};
+
+static void sis_update_sso(struct voice *voice, u16 period)
+{
+	void __iomem *base = voice->ctrl_base;
+
+	voice->sso += period;
+	if (voice->sso >= voice->buffer_size)
+		voice->sso -= voice->buffer_size;
+
+	/* Enforce the documented hardware minimum offset */
+	if (voice->sso < 8)
+		voice->sso = 8;
+
+	/* The SSO is in the upper 16 bits of the register. */
+	writew(voice->sso & 0xffff, base + SIS_PLAY_DMA_SSO_ESO + 2);
+}
+
+static void sis_update_voice(struct voice *voice)
+{
+	if (voice->flags & VOICE_SSO_TIMING) {
+		sis_update_sso(voice, voice->period_size);
+	} else if (voice->flags & VOICE_SYNC_TIMING) {
+		int sync;
+
+		/* If we've not hit the end of the virtual period, update
+		 * our records and keep going.
+		 */
+		if (voice->vperiod > voice->period_size) {
+			voice->vperiod -= voice->period_size;
+			if (voice->vperiod < voice->period_size)
+				sis_update_sso(voice, voice->vperiod);
+			else
+				sis_update_sso(voice, voice->period_size);
+			return;
+		}
+
+		/* Calculate our relative offset between the target and
+		 * the actual CSO value. Since we're operating in a loop,
+		 * if the value is more than half way around, we can
+		 * consider ourselves wrapped.
+		 */
+		sync = voice->sync_cso;
+		sync -= readw(voice->sync_base + SIS_CAPTURE_DMA_FORMAT_CSO);
+		if (sync > (voice->sync_buffer_size / 2))
+			sync -= voice->sync_buffer_size;
+
+		/* If sync is positive, then we interrupted too early, and
+		 * we'll need to come back in a few samples and try again.
+		 * There's a minimum wait, as it takes some time for the DMA
+		 * engine to startup, etc...
+		 */
+		if (sync > 0) {
+			if (sync < 16)
+				sync = 16;
+			sis_update_sso(voice, sync);
+			return;
+		}
+
+		/* Ok, we interrupted right on time, or (hopefully) just
+		 * a bit late. We'll adjst our next waiting period based
+		 * on how close we got.
+		 *
+		 * We need to stay just behind the actual channel to ensure
+		 * it really is past a period when we get our interrupt --
+		 * otherwise we'll fall into the early code above and have
+		 * a minimum wait time, which makes us quite late here,
+		 * eating into the user's time to refresh the buffer, esp.
+		 * if using small periods.
+		 *
+		 * If we're less than 9 samples behind, we're on target.
+		 */
+		if (sync > -9)
+			voice->vperiod = voice->sync_period_size + 1;
+		else
+			voice->vperiod = voice->sync_period_size - 4;
+
+		if (voice->vperiod < voice->buffer_size) {
+			sis_update_sso(voice, voice->vperiod);
+			voice->vperiod = 0;
+		} else
+			sis_update_sso(voice, voice->period_size);
+
+		sync = voice->sync_cso + voice->sync_period_size;
+		if (sync >= voice->sync_buffer_size)
+			sync -= voice->sync_buffer_size;
+		voice->sync_cso = sync;
+	}
+
+	snd_pcm_period_elapsed(voice->substream);
+}
+
+static void sis_voice_irq(u32 status, struct voice *voice)
+{
+	int bit;
+
+	while (status) {
+		bit = __ffs(status);
+		status >>= bit + 1;
+		voice += bit;
+		sis_update_voice(voice);
+		voice++;
+	}
+}
+
+static irqreturn_t sis_interrupt(int irq, void *dev)
+{
+	struct sis7019 *sis = dev;
+	unsigned long io = sis->ioport;
+	struct voice *voice;
+	u32 intr, status;
+
+	/* We only use the DMA interrupts, and we don't enable any other
+	 * source of interrupts. But, it is possible to see an interupt
+	 * status that didn't actually interrupt us, so eliminate anything
+	 * we're not expecting to avoid falsely claiming an IRQ, and an
+	 * ensuing endless loop.
+	 */
+	intr = inl(io + SIS_GISR);
+	intr &= SIS_GISR_AUDIO_PLAY_DMA_IRQ_STATUS |
+		SIS_GISR_AUDIO_RECORD_DMA_IRQ_STATUS;
+	if (!intr)
+		return IRQ_NONE;
+
+	do {
+		status = inl(io + SIS_PISR_A);
+		if (status) {
+			sis_voice_irq(status, sis->voices);
+			outl(status, io + SIS_PISR_A);
+		}
+
+		status = inl(io + SIS_PISR_B);
+		if (status) {
+			sis_voice_irq(status, &sis->voices[32]);
+			outl(status, io + SIS_PISR_B);
+		}
+
+		status = inl(io + SIS_RISR);
+		if (status) {
+			voice = &sis->capture_voice;
+			if (!voice->timing)
+				snd_pcm_period_elapsed(voice->substream);
+
+			outl(status, io + SIS_RISR);
+		}
+
+		outl(intr, io + SIS_GISR);
+		intr = inl(io + SIS_GISR);
+		intr &= SIS_GISR_AUDIO_PLAY_DMA_IRQ_STATUS |
+			SIS_GISR_AUDIO_RECORD_DMA_IRQ_STATUS;
+	} while (intr);
+
+	return IRQ_HANDLED;
+}
+
+static u32 sis_rate_to_delta(unsigned int rate)
+{
+	u32 delta;
+
+	/* This was copied from the trident driver, but it seems its gotten
+	 * around a bit... nevertheless, it works well.
+	 *
+	 * We special case 44100 and 8000 since rounding with the equation
+	 * does not give us an accurate enough value. For 11025 and 22050
+	 * the equation gives us the best answer. All other frequencies will
+	 * also use the equation. JDW
+	 */
+	if (rate == 44100)
+		delta = 0xeb3;
+	else if (rate == 8000)
+		delta = 0x2ab;
+	else if (rate == 48000)
+		delta = 0x1000;
+	else
+		delta = (((rate << 12) + 24000) / 48000) & 0x0000ffff;
+	return delta;
+}
+
+static void __sis_map_silence(struct sis7019 *sis)
+{
+	/* Helper function: must hold sis->voice_lock on entry */
+	if (!sis->silence_users)
+		sis->silence_dma_addr = pci_map_single(sis->pci,
+						sis->suspend_state[0],
+						4096, PCI_DMA_TODEVICE);
+	sis->silence_users++;
+}
+
+static void __sis_unmap_silence(struct sis7019 *sis)
+{
+	/* Helper function: must hold sis->voice_lock on entry */
+	sis->silence_users--;
+	if (!sis->silence_users)
+		pci_unmap_single(sis->pci, sis->silence_dma_addr, 4096,
+					PCI_DMA_TODEVICE);
+}
+
+static void sis_free_voice(struct sis7019 *sis, struct voice *voice)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&sis->voice_lock, flags);
+	if (voice->timing) {
+		__sis_unmap_silence(sis);
+		voice->timing->flags &= ~(VOICE_IN_USE | VOICE_SSO_TIMING |
+						VOICE_SYNC_TIMING);
+		voice->timing = NULL;
+	}
+	voice->flags &= ~(VOICE_IN_USE | VOICE_SSO_TIMING | VOICE_SYNC_TIMING);
+	spin_unlock_irqrestore(&sis->voice_lock, flags);
+}
+
+static struct voice *__sis_alloc_playback_voice(struct sis7019 *sis)
+{
+	/* Must hold the voice_lock on entry */
+	struct voice *voice;
+	int i;
+
+	for (i = 0; i < 64; i++) {
+		voice = &sis->voices[i];
+		if (voice->flags & VOICE_IN_USE)
+			continue;
+		voice->flags |= VOICE_IN_USE;
+		goto found_one;
+	}
+	voice = NULL;
+
+found_one:
+	return voice;
+}
+
+static struct voice *sis_alloc_playback_voice(struct sis7019 *sis)
+{
+	struct voice *voice;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sis->voice_lock, flags);
+	voice = __sis_alloc_playback_voice(sis);
+	spin_unlock_irqrestore(&sis->voice_lock, flags);
+
+	return voice;
+}
+
+static int sis_alloc_timing_voice(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *hw_params)
+{
+	struct sis7019 *sis = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct voice *voice = runtime->private_data;
+	unsigned int period_size, buffer_size;
+	unsigned long flags;
+	int needed;
+
+	/* If there are one or two periods per buffer, we don't need a
+	 * timing voice, as we can use the capture channel's interrupts
+	 * to clock out the periods.
+	 */
+	period_size = params_period_size(hw_params);
+	buffer_size = params_buffer_size(hw_params);
+	needed = (period_size != buffer_size &&
+			period_size != (buffer_size / 2));
+
+	if (needed && !voice->timing) {
+		spin_lock_irqsave(&sis->voice_lock, flags);
+		voice->timing = __sis_alloc_playback_voice(sis);
+		if (voice->timing)
+			__sis_map_silence(sis);
+		spin_unlock_irqrestore(&sis->voice_lock, flags);
+		if (!voice->timing)
+			return -ENOMEM;
+		voice->timing->substream = substream;
+	} else if (!needed && voice->timing) {
+		sis_free_voice(sis, voice);
+		voice->timing = NULL;
+	}
+
+	return 0;
+}
+
+static int sis_playback_open(struct snd_pcm_substream *substream)
+{
+	struct sis7019 *sis = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct voice *voice;
+
+	voice = sis_alloc_playback_voice(sis);
+	if (!voice)
+		return -EAGAIN;
+
+	voice->substream = substream;
+	runtime->private_data = voice;
+	runtime->hw = sis_playback_hw_info;
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+						9, 0xfff9);
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+						9, 0xfff9);
+	snd_pcm_set_sync(substream);
+	return 0;
+}
+
+static int sis_substream_close(struct snd_pcm_substream *substream)
+{
+	struct sis7019 *sis = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct voice *voice = runtime->private_data;
+
+	sis_free_voice(sis, voice);
+	return 0;
+}
+
+static int sis_playback_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+}
+
+static int sis_hw_free(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int sis_pcm_playback_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct voice *voice = runtime->private_data;
+	void __iomem *ctrl_base = voice->ctrl_base;
+	void __iomem *wave_base = voice->wave_base;
+	u32 format, dma_addr, control, sso_eso, delta, reg;
+	u16 leo;
+
+	/* We rely on the PCM core to ensure that the parameters for this
+	 * substream do not change on us while we're programming the HW.
+	 */
+	format = 0;
+	if (snd_pcm_format_width(runtime->format) == 8)
+		format |= SIS_PLAY_DMA_FORMAT_8BIT;
+	if (!snd_pcm_format_signed(runtime->format))
+		format |= SIS_PLAY_DMA_FORMAT_UNSIGNED;
+	if (runtime->channels == 1)
+		format |= SIS_PLAY_DMA_FORMAT_MONO;
+
+	/* The baseline setup is for a single period per buffer, and
+	 * we add bells and whistles as needed from there.
+	 */
+	dma_addr = runtime->dma_addr;
+	leo = runtime->buffer_size - 1;
+	control = leo | SIS_PLAY_DMA_LOOP | SIS_PLAY_DMA_INTR_AT_LEO;
+	sso_eso = leo;
+
+	if (runtime->period_size == (runtime->buffer_size / 2)) {
+		control |= SIS_PLAY_DMA_INTR_AT_MLP;
+	} else if (runtime->period_size != runtime->buffer_size) {
+		voice->flags |= VOICE_SSO_TIMING;
+		voice->sso = runtime->period_size - 1;
+		voice->period_size = runtime->period_size;
+		voice->buffer_size = runtime->buffer_size;
+
+		control &= ~SIS_PLAY_DMA_INTR_AT_LEO;
+		control |= SIS_PLAY_DMA_INTR_AT_SSO;
+		sso_eso |= (runtime->period_size - 1) << 16;
+	}
+
+	delta = sis_rate_to_delta(runtime->rate);
+
+	/* Ok, we're ready to go, set up the channel.
+	 */
+	writel(format, ctrl_base + SIS_PLAY_DMA_FORMAT_CSO);
+	writel(dma_addr, ctrl_base + SIS_PLAY_DMA_BASE);
+	writel(control, ctrl_base + SIS_PLAY_DMA_CONTROL);
+	writel(sso_eso, ctrl_base + SIS_PLAY_DMA_SSO_ESO);
+
+	for (reg = 0; reg < SIS_WAVE_SIZE; reg += 4)
+		writel(0, wave_base + reg);
+
+	writel(SIS_WAVE_GENERAL_WAVE_VOLUME, wave_base + SIS_WAVE_GENERAL);
+	writel(delta << 16, wave_base + SIS_WAVE_GENERAL_ARTICULATION);
+	writel(SIS_WAVE_CHANNEL_CONTROL_FIRST_SAMPLE |
+			SIS_WAVE_CHANNEL_CONTROL_AMP_ENABLE |
+			SIS_WAVE_CHANNEL_CONTROL_INTERPOLATE_ENABLE,
+			wave_base + SIS_WAVE_CHANNEL_CONTROL);
+
+	/* Force PCI writes to post. */
+	readl(ctrl_base);
+
+	return 0;
+}
+
+static int sis_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct sis7019 *sis = snd_pcm_substream_chip(substream);
+	unsigned long io = sis->ioport;
+	struct snd_pcm_substream *s;
+	struct voice *voice;
+	void *chip;
+	int starting;
+	u32 record = 0;
+	u32 play[2] = { 0, 0 };
+
+	/* No locks needed, as the PCM core will hold the locks on the
+	 * substreams, and the HW will only start/stop the indicated voices
+	 * without changing the state of the others.
+	 */
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		starting = 1;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		starting = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	snd_pcm_group_for_each_entry(s, substream) {
+		/* Make sure it is for us... */
+		chip = snd_pcm_substream_chip(s);
+		if (chip != sis)
+			continue;
+
+		voice = s->runtime->private_data;
+		if (voice->flags & VOICE_CAPTURE) {
+			record |= 1 << voice->num;
+			voice = voice->timing;
+		}
+
+		/* voice could be NULL if this a recording stream, and it
+		 * doesn't have an external timing channel.
+		 */
+		if (voice)
+			play[voice->num / 32] |= 1 << (voice->num & 0x1f);
+
+		snd_pcm_trigger_done(s, substream);
+	}
+
+	if (starting) {
+		if (record)
+			outl(record, io + SIS_RECORD_START_REG);
+		if (play[0])
+			outl(play[0], io + SIS_PLAY_START_A_REG);
+		if (play[1])
+			outl(play[1], io + SIS_PLAY_START_B_REG);
+	} else {
+		if (record)
+			outl(record, io + SIS_RECORD_STOP_REG);
+		if (play[0])
+			outl(play[0], io + SIS_PLAY_STOP_A_REG);
+		if (play[1])
+			outl(play[1], io + SIS_PLAY_STOP_B_REG);
+	}
+	return 0;
+}
+
+static snd_pcm_uframes_t sis_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct voice *voice = runtime->private_data;
+	u32 cso;
+
+	cso = readl(voice->ctrl_base + SIS_PLAY_DMA_FORMAT_CSO);
+	cso &= 0xffff;
+	return cso;
+}
+
+static int sis_capture_open(struct snd_pcm_substream *substream)
+{
+	struct sis7019 *sis = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct voice *voice = &sis->capture_voice;
+	unsigned long flags;
+
+	/* FIXME: The driver only supports recording from one channel
+	 * at the moment, but it could support more.
+	 */
+	spin_lock_irqsave(&sis->voice_lock, flags);
+	if (voice->flags & VOICE_IN_USE)
+		voice = NULL;
+	else
+		voice->flags |= VOICE_IN_USE;
+	spin_unlock_irqrestore(&sis->voice_lock, flags);
+
+	if (!voice)
+		return -EAGAIN;
+
+	voice->substream = substream;
+	runtime->private_data = voice;
+	runtime->hw = sis_capture_hw_info;
+	runtime->hw.rates = sis->ac97[0]->rates[AC97_RATES_ADC];
+	snd_pcm_limit_hw_rates(runtime);
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+						9, 0xfff9);
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+						9, 0xfff9);
+	snd_pcm_set_sync(substream);
+	return 0;
+}
+
+static int sis_capture_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *hw_params)
+{
+	struct sis7019 *sis = snd_pcm_substream_chip(substream);
+	int rc;
+
+	rc = snd_ac97_set_rate(sis->ac97[0], AC97_PCM_LR_ADC_RATE,
+						params_rate(hw_params));
+	if (rc)
+		goto out;
+
+	rc = snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+	if (rc < 0)
+		goto out;
+
+	rc = sis_alloc_timing_voice(substream, hw_params);
+
+out:
+	return rc;
+}
+
+static void sis_prepare_timing_voice(struct voice *voice,
+					struct snd_pcm_substream *substream)
+{
+	struct sis7019 *sis = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct voice *timing = voice->timing;
+	void __iomem *play_base = timing->ctrl_base;
+	void __iomem *wave_base = timing->wave_base;
+	u16 buffer_size, period_size;
+	u32 format, control, sso_eso, delta;
+	u32 vperiod, sso, reg;
+
+	/* Set our initial buffer and period as large as we can given a
+	 * single page of silence.
+	 */
+	buffer_size = 4096 / runtime->channels;
+	buffer_size /= snd_pcm_format_size(runtime->format, 1);
+	period_size = buffer_size;
+
+	/* Initially, we want to interrupt just a bit behind the end of
+	 * the period we're clocking out. 10 samples seems to give a good
+	 * delay.
+	 *
+	 * We want to spread our interrupts throughout the virtual period,
+	 * so that we don't end up with two interrupts back to back at the
+	 * end -- this helps minimize the effects of any jitter. Adjust our
+	 * clocking period size so that the last period is at least a fourth
+	 * of a full period.
+	 *
+	 * This is all moot if we don't need to use virtual periods.
+	 */
+	vperiod = runtime->period_size + 10;
+	if (vperiod > period_size) {
+		u16 tail = vperiod % period_size;
+		u16 quarter_period = period_size / 4;
+
+		if (tail && tail < quarter_period) {
+			u16 loops = vperiod / period_size;
+
+			tail = quarter_period - tail;
+			tail += loops - 1;
+			tail /= loops;
+			period_size -= tail;
+		}
+
+		sso = period_size - 1;
+	} else {
+		/* The initial period will fit inside the buffer, so we
+		 * don't need to use virtual periods -- disable them.
+		 */
+		period_size = runtime->period_size;
+		sso = vperiod - 1;
+		vperiod = 0;
+	}
+
+	/* The interrupt handler implements the timing syncronization, so
+	 * setup its state.
+	 */
+	timing->flags |= VOICE_SYNC_TIMING;
+	timing->sync_base = voice->ctrl_base;
+	timing->sync_cso = runtime->period_size - 1;
+	timing->sync_period_size = runtime->period_size;
+	timing->sync_buffer_size = runtime->buffer_size;
+	timing->period_size = period_size;
+	timing->buffer_size = buffer_size;
+	timing->sso = sso;
+	timing->vperiod = vperiod;
+
+	/* Using unsigned samples with the all-zero silence buffer
+	 * forces the output to the lower rail, killing playback.
+	 * So ignore unsigned vs signed -- it doesn't change the timing.
+	 */
+	format = 0;
+	if (snd_pcm_format_width(runtime->format) == 8)
+		format = SIS_CAPTURE_DMA_FORMAT_8BIT;
+	if (runtime->channels == 1)
+		format |= SIS_CAPTURE_DMA_FORMAT_MONO;
+
+	control = timing->buffer_size - 1;
+	control |= SIS_PLAY_DMA_LOOP | SIS_PLAY_DMA_INTR_AT_SSO;
+	sso_eso = timing->buffer_size - 1;
+	sso_eso |= timing->sso << 16;
+
+	delta = sis_rate_to_delta(runtime->rate);
+
+	/* We've done the math, now configure the channel.
+	 */
+	writel(format, play_base + SIS_PLAY_DMA_FORMAT_CSO);
+	writel(sis->silence_dma_addr, play_base + SIS_PLAY_DMA_BASE);
+	writel(control, play_base + SIS_PLAY_DMA_CONTROL);
+	writel(sso_eso, play_base + SIS_PLAY_DMA_SSO_ESO);
+
+	for (reg = 0; reg < SIS_WAVE_SIZE; reg += 4)
+		writel(0, wave_base + reg);
+
+	writel(SIS_WAVE_GENERAL_WAVE_VOLUME, wave_base + SIS_WAVE_GENERAL);
+	writel(delta << 16, wave_base + SIS_WAVE_GENERAL_ARTICULATION);
+	writel(SIS_WAVE_CHANNEL_CONTROL_FIRST_SAMPLE |
+			SIS_WAVE_CHANNEL_CONTROL_AMP_ENABLE |
+			SIS_WAVE_CHANNEL_CONTROL_INTERPOLATE_ENABLE,
+			wave_base + SIS_WAVE_CHANNEL_CONTROL);
+}
+
+static int sis_pcm_capture_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct voice *voice = runtime->private_data;
+	void __iomem *rec_base = voice->ctrl_base;
+	u32 format, dma_addr, control;
+	u16 leo;
+
+	/* We rely on the PCM core to ensure that the parameters for this
+	 * substream do not change on us while we're programming the HW.
+	 */
+	format = 0;
+	if (snd_pcm_format_width(runtime->format) == 8)
+		format = SIS_CAPTURE_DMA_FORMAT_8BIT;
+	if (!snd_pcm_format_signed(runtime->format))
+		format |= SIS_CAPTURE_DMA_FORMAT_UNSIGNED;
+	if (runtime->channels == 1)
+		format |= SIS_CAPTURE_DMA_FORMAT_MONO;
+
+	dma_addr = runtime->dma_addr;
+	leo = runtime->buffer_size - 1;
+	control = leo | SIS_CAPTURE_DMA_LOOP;
+
+	/* If we've got more than two periods per buffer, then we have
+	 * use a timing voice to clock out the periods. Otherwise, we can
+	 * use the capture channel's interrupts.
+	 */
+	if (voice->timing) {
+		sis_prepare_timing_voice(voice, substream);
+	} else {
+		control |= SIS_CAPTURE_DMA_INTR_AT_LEO;
+		if (runtime->period_size != runtime->buffer_size)
+			control |= SIS_CAPTURE_DMA_INTR_AT_MLP;
+	}
+
+	writel(format, rec_base + SIS_CAPTURE_DMA_FORMAT_CSO);
+	writel(dma_addr, rec_base + SIS_CAPTURE_DMA_BASE);
+	writel(control, rec_base + SIS_CAPTURE_DMA_CONTROL);
+
+	/* Force the writes to post. */
+	readl(rec_base);
+
+	return 0;
+}
+
+static struct snd_pcm_ops sis_playback_ops = {
+	.open = sis_playback_open,
+	.close = sis_substream_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = sis_playback_hw_params,
+	.hw_free = sis_hw_free,
+	.prepare = sis_pcm_playback_prepare,
+	.trigger = sis_pcm_trigger,
+	.pointer = sis_pcm_pointer,
+};
+
+static struct snd_pcm_ops sis_capture_ops = {
+	.open = sis_capture_open,
+	.close = sis_substream_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = sis_capture_hw_params,
+	.hw_free = sis_hw_free,
+	.prepare = sis_pcm_capture_prepare,
+	.trigger = sis_pcm_trigger,
+	.pointer = sis_pcm_pointer,
+};
+
+static int __devinit sis_pcm_create(struct sis7019 *sis)
+{
+	struct snd_pcm *pcm;
+	int rc;
+
+	/* We have 64 voices, and the driver currently records from
+	 * only one channel, though that could change in the future.
+	 */
+	rc = snd_pcm_new(sis->card, "SiS7019", 0, 64, 1, &pcm);
+	if (rc)
+		return rc;
+
+	pcm->private_data = sis;
+	strcpy(pcm->name, "SiS7019");
+	sis->pcm = pcm;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &sis_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &sis_capture_ops);
+
+	/* Try to preallocate some memory, but it's not the end of the
+	 * world if this fails.
+	 */
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+				snd_dma_pci_data(sis->pci), 64*1024, 128*1024);
+
+	return 0;
+}
+
+static unsigned short sis_ac97_rw(struct sis7019 *sis, int codec, u32 cmd)
+{
+	unsigned long io = sis->ioport;
+	unsigned short val = 0xffff;
+	u16 status;
+	u16 rdy;
+	int count;
+	const static u16 codec_ready[3] = {
+		SIS_AC97_STATUS_CODEC_READY,
+		SIS_AC97_STATUS_CODEC2_READY,
+		SIS_AC97_STATUS_CODEC3_READY,
+	};
+
+	rdy = codec_ready[codec];
+
+
+	/* Get the AC97 semaphore -- software first, so we don't spin
+	 * pounding out IO reads on the hardware semaphore...
+	 */
+	mutex_lock(&sis->ac97_mutex);
+
+	count = 0xffff;
+	while ((inw(io + SIS_AC97_SEMA) & SIS_AC97_SEMA_BUSY) && --count)
+		udelay(1);
+
+	if (!count)
+		goto timeout;
+
+	/* ... and wait for any outstanding commands to complete ...
+	 */
+	count = 0xffff;
+	do {
+		status = inw(io + SIS_AC97_STATUS);
+		if ((status & rdy) && !(status & SIS_AC97_STATUS_BUSY))
+			break;
+
+		udelay(1);
+	} while (--count);
+
+	if (!count)
+		goto timeout_sema;
+
+	/* ... before sending our command and waiting for it to finish ...
+	 */
+	outl(cmd, io + SIS_AC97_CMD);
+	udelay(10);
+
+	count = 0xffff;
+	while ((inw(io + SIS_AC97_STATUS) & SIS_AC97_STATUS_BUSY) && --count)
+		udelay(1);
+
+	/* ... and reading the results (if any).
+	 */
+	val = inl(io + SIS_AC97_CMD) >> 16;
+
+timeout_sema:
+	outl(SIS_AC97_SEMA_RELEASE, io + SIS_AC97_SEMA);
+timeout:
+	mutex_unlock(&sis->ac97_mutex);
+
+	if (!count) {
+		printk(KERN_ERR "sis7019: ac97 codec %d timeout cmd 0x%08x\n",
+					codec, cmd);
+	}
+
+	return val;
+}
+
+static void sis_ac97_write(struct snd_ac97 *ac97, unsigned short reg,
+				unsigned short val)
+{
+	const static u32 cmd[3] = {
+		SIS_AC97_CMD_CODEC_WRITE,
+		SIS_AC97_CMD_CODEC2_WRITE,
+		SIS_AC97_CMD_CODEC3_WRITE,
+	};
+	sis_ac97_rw(ac97->private_data, ac97->num,
+			(val << 16) | (reg << 8) | cmd[ac97->num]);
+}
+
+static unsigned short sis_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
+{
+	const static u32 cmd[3] = {
+		SIS_AC97_CMD_CODEC_READ,
+		SIS_AC97_CMD_CODEC2_READ,
+		SIS_AC97_CMD_CODEC3_READ,
+	};
+	return sis_ac97_rw(ac97->private_data, ac97->num,
+					(reg << 8) | cmd[ac97->num]);
+}
+
+static int __devinit sis_mixer_create(struct sis7019 *sis)
+{
+	struct snd_ac97_bus *bus;
+	struct snd_ac97_template ac97;
+	static struct snd_ac97_bus_ops ops = {
+		.write = sis_ac97_write,
+		.read = sis_ac97_read,
+	};
+	int rc;
+
+	memset(&ac97, 0, sizeof(ac97));
+	ac97.private_data = sis;
+
+	rc = snd_ac97_bus(sis->card, 0, &ops, NULL, &bus);
+	if (!rc && sis->codecs_present & SIS_PRIMARY_CODEC_PRESENT)
+		rc = snd_ac97_mixer(bus, &ac97, &sis->ac97[0]);
+	ac97.num = 1;
+	if (!rc && (sis->codecs_present & SIS_SECONDARY_CODEC_PRESENT))
+		rc = snd_ac97_mixer(bus, &ac97, &sis->ac97[1]);
+	ac97.num = 2;
+	if (!rc && (sis->codecs_present & SIS_TERTIARY_CODEC_PRESENT))
+		rc = snd_ac97_mixer(bus, &ac97, &sis->ac97[2]);
+
+	/* If we return an error here, then snd_card_free() should
+	 * free up any ac97 codecs that got created, as well as the bus.
+	 */
+	return rc;
+}
+
+static void sis_free_suspend(struct sis7019 *sis)
+{
+	int i;
+
+	for (i = 0; i < SIS_SUSPEND_PAGES; i++)
+		kfree(sis->suspend_state[i]);
+}
+
+static int sis_chip_free(struct sis7019 *sis)
+{
+	/* Reset the chip, and disable all interrputs.
+	 */
+	outl(SIS_GCR_SOFTWARE_RESET, sis->ioport + SIS_GCR);
+	udelay(10);
+	outl(0, sis->ioport + SIS_GCR);
+	outl(0, sis->ioport + SIS_GIER);
+
+	/* Now, free everything we allocated.
+	 */
+	if (sis->irq >= 0)
+		free_irq(sis->irq, sis);
+
+	if (sis->ioaddr)
+		iounmap(sis->ioaddr);
+
+	pci_release_regions(sis->pci);
+	pci_disable_device(sis->pci);
+
+	sis_free_suspend(sis);
+	return 0;
+}
+
+static int sis_dev_free(struct snd_device *dev)
+{
+	struct sis7019 *sis = dev->device_data;
+	return sis_chip_free(sis);
+}
+
+static int sis_chip_init(struct sis7019 *sis)
+{
+	unsigned long io = sis->ioport;
+	void __iomem *ioaddr = sis->ioaddr;
+	u16 status;
+	int count;
+	int i;
+
+	/* Reset the audio controller
+	 */
+	outl(SIS_GCR_SOFTWARE_RESET, io + SIS_GCR);
+	udelay(10);
+	outl(0, io + SIS_GCR);
+
+	/* Get the AC-link semaphore, and reset the codecs
+	 */
+	count = 0xffff;
+	while ((inw(io + SIS_AC97_SEMA) & SIS_AC97_SEMA_BUSY) && --count)
+		udelay(1);
+
+	if (!count)
+		return -EIO;
+
+	outl(SIS_AC97_CMD_CODEC_COLD_RESET, io + SIS_AC97_CMD);
+	udelay(10);
+
+	count = 0xffff;
+	while ((inw(io + SIS_AC97_STATUS) & SIS_AC97_STATUS_BUSY) && --count)
+		udelay(1);
+
+	/* Now that we've finished the reset, find out what's attached.
+	 */
+	status = inl(io + SIS_AC97_STATUS);
+	if (status & SIS_AC97_STATUS_CODEC_READY)
+		sis->codecs_present |= SIS_PRIMARY_CODEC_PRESENT;
+	if (status & SIS_AC97_STATUS_CODEC2_READY)
+		sis->codecs_present |= SIS_SECONDARY_CODEC_PRESENT;
+	if (status & SIS_AC97_STATUS_CODEC3_READY)
+		sis->codecs_present |= SIS_TERTIARY_CODEC_PRESENT;
+
+	/* All done, let go of the semaphore, and check for errors
+	 */
+	outl(SIS_AC97_SEMA_RELEASE, io + SIS_AC97_SEMA);
+	if (!sis->codecs_present || !count)
+		return -EIO;
+
+	/* Let the hardware know that the audio driver is alive,
+	 * and enable PCM slots on the AC-link for L/R playback (3 & 4) and
+	 * record channels. We're going to want to use Variable Rate Audio
+	 * for recording, to avoid needlessly resampling from 48kHZ.
+	 */
+	outl(SIS_AC97_CONF_AUDIO_ALIVE, io + SIS_AC97_CONF);
+	outl(SIS_AC97_CONF_AUDIO_ALIVE | SIS_AC97_CONF_PCM_LR_ENABLE |
+		SIS_AC97_CONF_PCM_CAP_MIC_ENABLE |
+		SIS_AC97_CONF_PCM_CAP_LR_ENABLE |
+		SIS_AC97_CONF_CODEC_VRA_ENABLE, io + SIS_AC97_CONF);
+
+	/* All AC97 PCM slots should be sourced from sub-mixer 0.
+	 */
+	outl(0, io + SIS_AC97_PSR);
+
+	/* There is only one valid DMA setup for a PCI environment.
+	 */
+	outl(SIS_DMA_CSR_PCI_SETTINGS, io + SIS_DMA_CSR);
+
+	/* Reset the syncronization groups for all of the channels
+	 * to be asyncronous. If we start doing SPDIF or 5.1 sound, etc.
+	 * we'll need to change how we handle these. Until then, we just
+	 * assign sub-mixer 0 to all playback channels, and avoid any
+	 * attenuation on the audio.
+	 */
+	outl(0, io + SIS_PLAY_SYNC_GROUP_A);
+	outl(0, io + SIS_PLAY_SYNC_GROUP_B);
+	outl(0, io + SIS_PLAY_SYNC_GROUP_C);
+	outl(0, io + SIS_PLAY_SYNC_GROUP_D);
+	outl(0, io + SIS_MIXER_SYNC_GROUP);
+
+	for (i = 0; i < 64; i++) {
+		writel(i, SIS_MIXER_START_ADDR(ioaddr, i));
+		writel(SIS_MIXER_RIGHT_NO_ATTEN | SIS_MIXER_LEFT_NO_ATTEN |
+				SIS_MIXER_DEST_0, SIS_MIXER_ADDR(ioaddr, i));
+	}
+
+	/* Don't attenuate any audio set for the wave amplifier.
+	 *
+	 * FIXME: Maximum attenuation is set for the music amp, which will
+	 * need to change if we start using the synth engine.
+	 */
+	outl(0xffff0000, io + SIS_WEVCR);
+
+	/* Ensure that the wave engine is in normal operating mode.
+	 */
+	outl(0, io + SIS_WECCR);
+
+	/* Go ahead and enable the DMA interrupts. They won't go live
+	 * until we start a channel.
+	 */
+	outl(SIS_GIER_AUDIO_PLAY_DMA_IRQ_ENABLE |
+		SIS_GIER_AUDIO_RECORD_DMA_IRQ_ENABLE, io + SIS_GIER);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int sis_suspend(struct pci_dev *pci, pm_message_t state)
+{
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct sis7019 *sis = card->private_data;
+	void __iomem *ioaddr = sis->ioaddr;
+	int i;
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	snd_pcm_suspend_all(sis->pcm);
+	if (sis->codecs_present & SIS_PRIMARY_CODEC_PRESENT)
+		snd_ac97_suspend(sis->ac97[0]);
+	if (sis->codecs_present & SIS_SECONDARY_CODEC_PRESENT)
+		snd_ac97_suspend(sis->ac97[1]);
+	if (sis->codecs_present & SIS_TERTIARY_CODEC_PRESENT)
+		snd_ac97_suspend(sis->ac97[2]);
+
+	/* snd_pcm_suspend_all() stopped all channels, so we're quiescent.
+	 */
+	if (sis->irq >= 0) {
+		synchronize_irq(sis->irq);
+		free_irq(sis->irq, sis);
+		sis->irq = -1;
+	}
+
+	/* Save the internal state away
+	 */
+	for (i = 0; i < 4; i++) {
+		memcpy_fromio(sis->suspend_state[i], ioaddr, 4096);
+		ioaddr += 4096;
+	}
+
+	pci_disable_device(pci);
+	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
+	return 0;
+}
+
+static int sis_resume(struct pci_dev *pci)
+{
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct sis7019 *sis = card->private_data;
+	void __iomem *ioaddr = sis->ioaddr;
+	int i;
+
+	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "sis7019: unable to re-enable device\n");
+		goto error;
+	}
+
+	if (sis_chip_init(sis)) {
+		printk(KERN_ERR "sis7019: unable to re-init controller\n");
+		goto error;
+	}
+
+	if (request_irq(pci->irq, sis_interrupt, IRQF_DISABLED|IRQF_SHARED,
+				card->shortname, sis)) {
+		printk(KERN_ERR "sis7019: unable to regain IRQ %d\n", pci->irq);
+		goto error;
+	}
+
+	/* Restore saved state, then clear out the page we use for the
+	 * silence buffer.
+	 */
+	for (i = 0; i < 4; i++) {
+		memcpy_toio(ioaddr, sis->suspend_state[i], 4096);
+		ioaddr += 4096;
+	}
+
+	memset(sis->suspend_state[0], 0, 4096);
+
+	sis->irq = pci->irq;
+	pci_set_master(pci);
+
+	if (sis->codecs_present & SIS_PRIMARY_CODEC_PRESENT)
+		snd_ac97_resume(sis->ac97[0]);
+	if (sis->codecs_present & SIS_SECONDARY_CODEC_PRESENT)
+		snd_ac97_resume(sis->ac97[1]);
+	if (sis->codecs_present & SIS_TERTIARY_CODEC_PRESENT)
+		snd_ac97_resume(sis->ac97[2]);
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	return 0;
+
+error:
+	snd_card_disconnect(card);
+	return -EIO;
+}
+#endif /* CONFIG_PM */
+
+static int sis_alloc_suspend(struct sis7019 *sis)
+{
+	int i;
+
+	/* We need 16K to store the internal wave engine state during a
+	 * suspend, but we don't need it to be contiguous, so play nice
+	 * with the memory system. We'll also use this area for a silence
+	 * buffer.
+	 */
+	for (i = 0; i < SIS_SUSPEND_PAGES; i++) {
+		sis->suspend_state[i] = kmalloc(4096, GFP_KERNEL);
+		if (!sis->suspend_state[i])
+			return -ENOMEM;
+	}
+	memset(sis->suspend_state[0], 0, 4096);
+
+	return 0;
+}
+
+static int __devinit sis_chip_create(struct snd_card *card,
+					struct pci_dev *pci)
+{
+	struct sis7019 *sis = card->private_data;
+	struct voice *voice;
+	static struct snd_device_ops ops = {
+		.dev_free = sis_dev_free,
+	};
+	int rc;
+	int i;
+
+	rc = pci_enable_device(pci);
+	if (rc)
+		goto error_out;
+
+	if (pci_set_dma_mask(pci, DMA_30BIT_MASK) < 0) {
+		printk(KERN_ERR "sis7019: architecture does not support "
+					"30-bit PCI busmaster DMA");
+		goto error_out_enabled;
+	}
+
+	memset(sis, 0, sizeof(*sis));
+	mutex_init(&sis->ac97_mutex);
+	spin_lock_init(&sis->voice_lock);
+	sis->card = card;
+	sis->pci = pci;
+	sis->irq = -1;
+	sis->ioport = pci_resource_start(pci, 0);
+
+	rc = pci_request_regions(pci, "SiS7019");
+	if (rc) {
+		printk(KERN_ERR "sis7019: unable request regions\n");
+		goto error_out_enabled;
+	}
+
+	rc = -EIO;
+	sis->ioaddr = ioremap_nocache(pci_resource_start(pci, 1), 0x4000);
+	if (!sis->ioaddr) {
+		printk(KERN_ERR "sis7019: unable to remap MMIO, aborting\n");
+		goto error_out_cleanup;
+	}
+
+	rc = sis_alloc_suspend(sis);
+	if (rc < 0) {
+		printk(KERN_ERR "sis7019: unable to allocate state storage\n");
+		goto error_out_cleanup;
+	}
+
+	rc = sis_chip_init(sis);
+	if (rc)
+		goto error_out_cleanup;
+
+	if (request_irq(pci->irq, sis_interrupt, IRQF_DISABLED|IRQF_SHARED,
+				card->shortname, sis)) {
+		printk(KERN_ERR "unable to allocate irq %d\n", sis->irq);
+		goto error_out_cleanup;
+	}
+
+	sis->irq = pci->irq;
+	pci_set_master(pci);
+
+	for (i = 0; i < 64; i++) {
+		voice = &sis->voices[i];
+		voice->num = i;
+		voice->ctrl_base = SIS_PLAY_DMA_ADDR(sis->ioaddr, i);
+		voice->wave_base = SIS_WAVE_ADDR(sis->ioaddr, i);
+	}
+
+	voice = &sis->capture_voice;
+	voice->flags = VOICE_CAPTURE;
+	voice->num = SIS_CAPTURE_CHAN_AC97_PCM_IN;
+	voice->ctrl_base = SIS_CAPTURE_DMA_ADDR(sis->ioaddr, voice->num);
+
+	rc = snd_device_new(card, SNDRV_DEV_LOWLEVEL, sis, &ops);
+	if (rc)
+		goto error_out_cleanup;
+
+	snd_card_set_dev(card, &pci->dev);
+
+	return 0;
+
+error_out_cleanup:
+	sis_chip_free(sis);
+
+error_out_enabled:
+	pci_disable_device(pci);
+
+error_out:
+	return rc;
+}
+
+static int __devinit snd_sis7019_probe(struct pci_dev *pci,
+					const struct pci_device_id *pci_id)
+{
+	struct snd_card *card;
+	struct sis7019 *sis;
+	int rc;
+
+	rc = -ENOENT;
+	if (!enable)
+		goto error_out;
+
+	rc = -ENOMEM;
+	card = snd_card_new(index, id, THIS_MODULE, sizeof(*sis));
+	if (!card)
+		goto error_out;
+
+	strcpy(card->driver, "SiS7019");
+	strcpy(card->shortname, "SiS7019");
+	rc = sis_chip_create(card, pci);
+	if (rc)
+		goto card_error_out;
+
+	sis = card->private_data;
+
+	rc = sis_mixer_create(sis);
+	if (rc)
+		goto card_error_out;
+
+	rc = sis_pcm_create(sis);
+	if (rc)
+		goto card_error_out;
+
+	snprintf(card->longname, sizeof(card->longname),
+			"%s Audio Accelerator with %s at 0x%lx, irq %d",
+			card->shortname, snd_ac97_get_short_name(sis->ac97[0]),
+			sis->ioport, sis->irq);
+
+	rc = snd_card_register(card);
+	if (rc)
+		goto card_error_out;
+
+	pci_set_drvdata(pci, card);
+	return 0;
+
+card_error_out:
+	snd_card_free(card);
+
+error_out:
+	return rc;
+}
+
+static void __devexit snd_sis7019_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver sis7019_driver = {
+	.name = "SiS7019",
+	.id_table = snd_sis7019_ids,
+	.probe = snd_sis7019_probe,
+	.remove = __devexit_p(snd_sis7019_remove),
+
+#ifdef CONFIG_PM
+	.suspend = sis_suspend,
+	.resume = sis_resume,
+#endif
+};
+
+static int __init sis7019_init(void)
+{
+	return pci_register_driver(&sis7019_driver);
+}
+
+static void __exit sis7019_exit(void)
+{
+	pci_unregister_driver(&sis7019_driver);
+}
+
+module_init(sis7019_init);
+module_exit(sis7019_exit);
