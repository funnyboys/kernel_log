commit 98fd539841319a46ba3773d908bfde13416d57eb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:38 2020 +0100

    ALSA: pcxhr: More constifications
    
    Apply const prefix to each possible place: the board parameters and
    DSP command table, and the string arrays.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 9e59d591217b..c2e4831c3a13 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -136,7 +136,7 @@ struct board_parameters {
 	short fw_file_set;
 	short firmware_num;
 };
-static struct board_parameters pcxhr_board_params[] = {
+static const struct board_parameters pcxhr_board_params[] = {
 [PCI_ID_VX882HR] =      { "VX882HR",      4, 4, 0, 41 },
 [PCI_ID_PCX882HR] =     { "PCX882HR",     4, 4, 0, 41 },
 [PCI_ID_VX881HR] =      { "VX881HR",      4, 4, 0, 41 },

commit efb0ad25d370344e61bb4fca8c3b9c3c6047922e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:25 2020 +0100

    ALSA: pci: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index f4330832e520..9e59d591217b 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1179,7 +1179,7 @@ static int pcxhr_create(struct pcxhr_mgr *mgr,
 {
 	int err;
 	struct snd_pcxhr *chip;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free = pcxhr_chip_dev_free,
 	};
 

commit 271213ef4d0d3a3b80d4cf95c5f2bebb5643e666
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:50 2019 +0100

    ALSA: pcxhr: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the threaded
    interrupt handler.  Set card->sync_irq for enabling the missing
    sync_stop PCM operation.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-52-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index e691c372b960..f4330832e520 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1190,6 +1190,7 @@ static int pcxhr_create(struct pcxhr_mgr *mgr,
 	chip->card = card;
 	chip->chip_idx = idx;
 	chip->mgr = mgr;
+	card->sync_irq = mgr->irq;
 
 	if (idx < mgr->playback_chips)
 		/* stereo or mono streams */

commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 72c0d1552f30..e691c372b960 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1120,7 +1120,6 @@ static snd_pcm_uframes_t pcxhr_stream_pointer(struct snd_pcm_substream *subs)
 static const struct snd_pcm_ops pcxhr_ops = {
 	.open      = pcxhr_open,
 	.close     = pcxhr_close,
-	.ioctl     = snd_pcm_lib_ioctl,
 	.prepare   = pcxhr_prepare,
 	.hw_params = pcxhr_hw_params,
 	.trigger   = pcxhr_trigger,

commit dd21bf512b648b7f5241557b59f8fd22221e2f76
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:21 2019 +0100

    ALSA: pcxhr: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The hw_free callback became superfluous and got dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-50-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 4af34d6d92df..72c0d1552f30 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -940,32 +940,16 @@ static int pcxhr_hw_params(struct snd_pcm_substream *subs,
 	struct snd_pcxhr *chip = snd_pcm_substream_chip(subs);
 	struct pcxhr_mgr *mgr = chip->mgr;
 	struct pcxhr_stream *stream = subs->runtime->private_data;
-	snd_pcm_format_t format;
-	int err;
-	int channels;
-
-	/* set up channels */
-	channels = params_channels(hw);
-
-	/*  set up format for the stream */
-	format = params_format(hw);
 
 	mutex_lock(&mgr->setup_mutex);
 
-	stream->channels = channels;
-	stream->format = format;
-
-	/* allocate buffer */
-	err = snd_pcm_lib_malloc_pages(subs, params_buffer_bytes(hw));
+	/* set up channels */
+	stream->channels = params_channels(hw);
+	/* set up format for the stream */
+	stream->format = params_format(hw);
 
 	mutex_unlock(&mgr->setup_mutex);
 
-	return err;
-}
-
-static int pcxhr_hw_free(struct snd_pcm_substream *subs)
-{
-	snd_pcm_lib_free_pages(subs);
 	return 0;
 }
 
@@ -1139,7 +1123,6 @@ static const struct snd_pcm_ops pcxhr_ops = {
 	.ioctl     = snd_pcm_lib_ioctl,
 	.prepare   = pcxhr_prepare,
 	.hw_params = pcxhr_hw_params,
-	.hw_free   = pcxhr_hw_free,
 	.trigger   = pcxhr_trigger,
 	.pointer   = pcxhr_stream_pointer,
 };
@@ -1170,9 +1153,9 @@ int pcxhr_create_pcm(struct snd_pcxhr *chip)
 	pcm->nonatomic = true;
 	strcpy(pcm->name, name);
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &chip->mgr->pci->dev,
-					      32*1024, 32*1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
+				       &chip->mgr->pci->dev,
+				       32*1024, 32*1024);
 	chip->pcm = pcm;
 	return 0;
 }

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index e493962d8455..4af34d6d92df 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1171,7 +1171,7 @@ int pcxhr_create_pcm(struct snd_pcxhr *chip)
 	strcpy(pcm->name, name);
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      snd_dma_pci_data(chip->mgr->pci),
+					      &chip->mgr->pci->dev,
 					      32*1024, 32*1024);
 	chip->pcm = pcm;
 	return 0;
@@ -1644,7 +1644,7 @@ static int pcxhr_probe(struct pci_dev *pci,
 
 	/* create hostport purgebuffer */
 	size = PAGE_ALIGN(sizeof(struct pcxhr_hostport));
-	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
+	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &pci->dev,
 				size, &mgr->hostport) < 0) {
 		pcxhr_free(mgr);
 		return -ENOMEM;

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 4ab7efc6e9f7..e493962d8455 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Driver for Digigram pcxhr compatible soundcards
  *
  * main file with alsa callbacks
  *
  * Copyright (c) 2004 by Digigram <alsa@digigram.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 

commit 47f2769b4b2e267cba135fc19c89c32d202b1415
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:01:39 2019 +0100

    ALSA: pci: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index e57da4036231..4ab7efc6e9f7 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1454,21 +1454,14 @@ static void pcxhr_proc_ltc(struct snd_info_entry *entry,
 
 static void pcxhr_proc_init(struct snd_pcxhr *chip)
 {
-	struct snd_info_entry *entry;
-
-	if (! snd_card_proc_new(chip->card, "info", &entry))
-		snd_info_set_text_ops(entry, chip, pcxhr_proc_info);
-	if (! snd_card_proc_new(chip->card, "sync", &entry))
-		snd_info_set_text_ops(entry, chip, pcxhr_proc_sync);
+	snd_card_ro_proc_new(chip->card, "info", chip, pcxhr_proc_info);
+	snd_card_ro_proc_new(chip->card, "sync", chip, pcxhr_proc_sync);
 	/* gpio available on stereo sound cards only */
-	if (chip->mgr->is_hr_stereo &&
-	    !snd_card_proc_new(chip->card, "gpio", &entry)) {
-		snd_info_set_text_ops(entry, chip, pcxhr_proc_gpio_read);
-		entry->c.text.write = pcxhr_proc_gpo_write;
-		entry->mode |= 0200;
-	}
-	if (!snd_card_proc_new(chip->card, "ltc", &entry))
-		snd_info_set_text_ops(entry, chip, pcxhr_proc_ltc);
+	if (chip->mgr->is_hr_stereo)
+		snd_card_rw_proc_new(chip->card, "gpio", chip,
+				     pcxhr_proc_gpio_read,
+				     pcxhr_proc_gpo_write);
+	snd_card_ro_proc_new(chip->card, "ltc", chip, pcxhr_proc_ltc);
 }
 /* end of proc interface */
 

commit 6a73cf46ce9d1b382ea14d74ce4bc9aa0c52337a
Author: Joe Perches <joe@perches.com>
Date:   Wed May 23 12:20:59 2018 -0700

    sound: Use octal not symbolic permissions
    
    Convert the S_<FOO> symbolic permissions to their octal equivalents as
    using octal and not symbolic permissions is preferred by many as more
    readable.
    
    see: https://lkml.org/lkml/2016/8/2/1945
    
    Done with automated conversion via:
    $ ./scripts/checkpatch.pl -f --types=SYMBOLIC_PERMS --fix-inplace <files...>
    
    Miscellanea:
    
    o Wrapped one multi-line call to a single line
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index f9ae72f28ddc..e57da4036231 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1465,7 +1465,7 @@ static void pcxhr_proc_init(struct snd_pcxhr *chip)
 	    !snd_card_proc_new(chip->card, "gpio", &entry)) {
 		snd_info_set_text_ops(entry, chip, pcxhr_proc_gpio_read);
 		entry->c.text.write = pcxhr_proc_gpo_write;
-		entry->mode |= S_IWUSR;
+		entry->mode |= 0200;
 	}
 	if (!snd_card_proc_new(chip->card, "ltc", &entry))
 		snd_info_set_text_ops(entry, chip, pcxhr_proc_ltc);

commit c38774d830aef6710676e7e5797d979c2bbb45ba
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Aug 12 18:14:54 2017 +0200

    ALSA: pcxhr: Delete an error message for a failed memory allocation in pcxhr_create()
    
    Omit an extra message for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index e6f9aa67cc6f..f9ae72f28ddc 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1215,10 +1215,8 @@ static int pcxhr_create(struct pcxhr_mgr *mgr,
 	};
 
 	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
-	if (! chip) {
-		dev_err(card->dev, "cannot allocate chip\n");
+	if (!chip)
 		return -ENOMEM;
-	}
 
 	chip->card = card;
 	chip->chip_idx = idx;

commit ecc6a044eb62cad892de28d1ea80a5c6f11ff402
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:23 2017 +0530

    ALSA: pcxhr: make snd_pcm_hardware const
    
    Make this const as it is only used during a copy operation.
    Done using Coccinelle
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index fa919f52e225..e6f9aa67cc6f 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -986,7 +986,7 @@ static int pcxhr_hw_free(struct snd_pcm_substream *subs)
 /*
  *  CONFIGURATION SPACE for all pcms, mono pcm must update channels_max
  */
-static struct snd_pcm_hardware pcxhr_caps =
+static const struct snd_pcm_hardware pcxhr_caps =
 {
 	.info             = (SNDRV_PCM_INFO_MMAP |
 			     SNDRV_PCM_INFO_INTERLEAVED |

commit 5051735221ba50cb5794b9194a8ad10a13368f2f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jul 18 13:48:10 2017 +0200

    ALSA: pcxhr: fix string overflow warnings
    
    With gcc-7, we get a warning about a possible string overflow:
    
    sound/pci/pcxhr/pcxhr.c: In function 'pcxhr_probe':
    sound/pci/pcxhr/pcxhr.c:1647:28: error: ' [PCM #' directive writing 7 bytes into a region of size between 1 and 32 [-Werror=format-overflow=]
    
    The shortname can simply be removed, and the longname can
    be changed into a shorter "name" string that is used in three
    places. Making it a little shorter (40 bytes) avoids the risk of
    overflowing completely, but I also use snprintf() here for
    extra clarity.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index bb7eee9d0c2b..fa919f52e225 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1165,7 +1165,7 @@ int pcxhr_create_pcm(struct snd_pcxhr *chip)
 	struct snd_pcm *pcm;
 	char name[32];
 
-	sprintf(name, "pcxhr %d", chip->chip_idx);
+	snprintf(name, sizeof(name), "pcxhr %d", chip->chip_idx);
 	if ((err = snd_pcm_new(chip->card, name, 0,
 			       chip->nb_streams_play,
 			       chip->nb_streams_capt, &pcm)) < 0) {
@@ -1252,7 +1252,7 @@ static void pcxhr_proc_info(struct snd_info_entry *entry,
 	struct snd_pcxhr *chip = entry->private_data;
 	struct pcxhr_mgr *mgr = chip->mgr;
 
-	snd_iprintf(buffer, "\n%s\n", mgr->longname);
+	snd_iprintf(buffer, "\n%s\n", mgr->name);
 
 	/* stats available when embedded DSP is running */
 	if (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {
@@ -1339,7 +1339,7 @@ static void pcxhr_proc_sync(struct snd_info_entry *entry,
 		max_clock = PCXHR_CLOCK_TYPE_MAX;
 	}
 
-	snd_iprintf(buffer, "\n%s\n", mgr->longname);
+	snd_iprintf(buffer, "\n%s\n", mgr->name);
 	snd_iprintf(buffer, "Current Sample Clock\t: %s\n",
 		    texts[mgr->cur_clock_type]);
 	snd_iprintf(buffer, "Current Sample Rate\t= %d\n",
@@ -1597,10 +1597,9 @@ static int pcxhr_probe(struct pci_dev *pci,
 	}
 	mgr->irq = pci->irq;
 
-	sprintf(mgr->shortname, "Digigram %s", card_name);
-	sprintf(mgr->longname, "%s at 0x%lx & 0x%lx, 0x%lx irq %i",
-		mgr->shortname,
-		mgr->port[0], mgr->port[1], mgr->port[2], mgr->irq);
+	snprintf(mgr->name, sizeof(mgr->name),
+		 "Digigram at 0x%lx & 0x%lx, 0x%lx irq %i",
+		 mgr->port[0], mgr->port[1], mgr->port[2], mgr->irq);
 
 	/* ISR lock  */
 	mutex_init(&mgr->lock);
@@ -1644,8 +1643,10 @@ static int pcxhr_probe(struct pci_dev *pci,
 		}
 
 		strcpy(card->driver, DRIVER_NAME);
-		sprintf(card->shortname, "%s [PCM #%d]", mgr->shortname, i);
-		sprintf(card->longname, "%s [PCM #%d]", mgr->longname, i);
+		snprintf(card->shortname, sizeof(card->shortname),
+			 "Digigram [PCM #%d]", i);
+		snprintf(card->longname, sizeof(card->longname),
+			 "%s [PCM #%d]", mgr->name, i);
 
 		if ((err = pcxhr_create(mgr, card, i)) < 0) {
 			snd_card_free(card);

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 9293235281dc..bb7eee9d0c2b 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1146,7 +1146,7 @@ static snd_pcm_uframes_t pcxhr_stream_pointer(struct snd_pcm_substream *subs)
 }
 
 
-static struct snd_pcm_ops pcxhr_ops = {
+static const struct snd_pcm_ops pcxhr_ops = {
 	.open      = pcxhr_open,
 	.close     = pcxhr_close,
 	.ioctl     = snd_pcm_lib_ioctl,

commit 412b979ccceff448dccea54bdb616c85781bc0ba
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Wed Apr 15 16:10:17 2015 +0200

    ALSA: remove deprecated use of pci api
    
    Replace occurences of the pci api by appropriate call to the dma api.
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr)
    
    @deprecated@
    idexpression id;
    position p;
    @@
    
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @bad1@
    idexpression id;
    position deprecated.p;
    @@
    ...when != &id->dev
       when != pci_get_drvdata ( id )
       when != pci_enable_device ( id )
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @depends on !bad1@
    idexpression id;
    expression direction;
    position deprecated.p;
    @@
    
    (
    - pci_dma_supported@p ( id,
    + dma_supported ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    |
    - pci_alloc_consistent@p ( id,
    + dma_alloc_coherent ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    )
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index c6092e48ceb6..9293235281dc 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1537,7 +1537,7 @@ static int pcxhr_probe(struct pci_dev *pci,
 	pci_set_master(pci);
 
 	/* check if we can restrict PCI DMA transfers to 32 bits */
-	if (pci_set_dma_mask(pci, DMA_BIT_MASK(32)) < 0) {
+	if (dma_set_mask(&pci->dev, DMA_BIT_MASK(32)) < 0) {
 		dev_err(&pci->dev,
 			"architecture does not support 32bit PCI busmaster DMA\n");
 		pci_disable_device(pci);

commit 6e1d7a51392f06899bd7b693f28ac60fa1e00032
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Dec 10 16:26:21 2014 +0300

    ALSA: pcxhr: NULL dereference on probe failure
    
    "card" is NULL if snd_card_new() fails.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index a60293015267..c6092e48ceb6 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1638,7 +1638,7 @@ static int pcxhr_probe(struct pci_dev *pci,
 				   0, &card);
 
 		if (err < 0) {
-			dev_err(card->dev, "cannot allocate the card %d\n", i);
+			dev_err(&pci->dev, "cannot allocate the card %d\n", i);
 			pcxhr_free(mgr);
 			return err;
 		}

commit f48a6df28239f5bf35d80e43e580261d2298395a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 28 17:22:45 2014 +0100

    ALSA: pcxhr: Kill the rest snd_print*()
    
    Use the standard dev_*() instead.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 7c33c973dbd5..a60293015267 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -501,10 +501,10 @@ int pcxhr_get_external_clock(struct pcxhr_mgr *mgr,
 /*
  *  start or stop playback/capture substream
  */
-static int pcxhr_set_stream_state(struct pcxhr_stream *stream)
+static int pcxhr_set_stream_state(struct snd_pcxhr *chip,
+				  struct pcxhr_stream *stream)
 {
 	int err;
-	struct snd_pcxhr *chip;
 	struct pcxhr_rmh rmh;
 	int stream_mask, start;
 
@@ -512,8 +512,8 @@ static int pcxhr_set_stream_state(struct pcxhr_stream *stream)
 		start = 1;
 	else {
 		if (stream->status != PCXHR_STREAM_STATUS_SCHEDULE_STOP) {
-			snd_printk(KERN_ERR "ERROR pcxhr_set_stream_state "
-				   "CANNOT be stopped\n");
+			dev_err(chip->card->dev,
+				"pcxhr_set_stream_state CANNOT be stopped\n");
 			return -EINVAL;
 		}
 		start = 0;
@@ -560,6 +560,7 @@ static int pcxhr_set_format(struct pcxhr_stream *stream)
 	struct pcxhr_rmh rmh;
 	unsigned int header;
 
+	chip = snd_pcm_substream_chip(stream->substream);
 	switch (stream->format) {
 	case SNDRV_PCM_FORMAT_U8:
 		header = HEADER_FMT_BASE_LIN;
@@ -582,11 +583,10 @@ static int pcxhr_set_format(struct pcxhr_stream *stream)
 		header = HEADER_FMT_BASE_FLOAT | HEADER_FMT_INTEL;
 		break;
 	default:
-		snd_printk(KERN_ERR
-			   "error pcxhr_set_format() : unknown format\n");
+		dev_err(chip->card->dev,
+			"error pcxhr_set_format() : unknown format\n");
 		return -EINVAL;
 	}
-	chip = snd_pcm_substream_chip(stream->substream);
 
 	sample_rate = chip->mgr->sample_rate;
 	if (sample_rate <= 32000 && sample_rate !=0) {
@@ -643,11 +643,11 @@ static int pcxhr_update_r_buffer(struct pcxhr_stream *stream)
 	is_capture = (subs->stream == SNDRV_PCM_STREAM_CAPTURE);
 	stream_num = is_capture ? 0 : subs->number;
 
-	snd_printdd("pcxhr_update_r_buffer(pcm%c%d) : "
-		    "addr(%p) bytes(%zx) subs(%d)\n",
-		    is_capture ? 'c' : 'p',
-		    chip->chip_idx, (void *)(long)subs->runtime->dma_addr,
-		    subs->runtime->dma_bytes, subs->number);
+	dev_dbg(chip->card->dev,
+		"pcxhr_update_r_buffer(pcm%c%d) : addr(%p) bytes(%zx) subs(%d)\n",
+		is_capture ? 'c' : 'p',
+		chip->chip_idx, (void *)(long)subs->runtime->dma_addr,
+		subs->runtime->dma_bytes, subs->number);
 
 	pcxhr_init_rmh(&rmh, CMD_UPDATE_R_BUFFERS);
 	pcxhr_set_pipe_cmd_params(&rmh, is_capture, stream->pipe->first_audio,
@@ -687,7 +687,7 @@ static int pcxhr_pipe_sample_count(struct pcxhr_stream *stream,
 		*sample_count = ((snd_pcm_uframes_t)rmh.stat[0]) << 24;
 		*sample_count += (snd_pcm_uframes_t)rmh.stat[1];
 	}
-	snd_printdd("PIPE_SAMPLE_COUNT = %lx\n", *sample_count);
+	dev_dbg(chip->card->dev, "PIPE_SAMPLE_COUNT = %lx\n", *sample_count);
 	return err;
 }
 #endif
@@ -779,12 +779,12 @@ static void pcxhr_start_linked_stream(struct pcxhr_mgr *mgr)
 		for (j = 0; j < chip->nb_streams_capt; j++) {
 			stream = &chip->capture_stream[j];
 			if (pcxhr_stream_scheduled_get_pipe(stream, &pipe))
-				err = pcxhr_set_stream_state(stream);
+				err = pcxhr_set_stream_state(chip, stream);
 		}
 		for (j = 0; j < chip->nb_streams_play; j++) {
 			stream = &chip->playback_stream[j];
 			if (pcxhr_stream_scheduled_get_pipe(stream, &pipe))
-				err = pcxhr_set_stream_state(stream);
+				err = pcxhr_set_stream_state(chip, stream);
 		}
 	}
 
@@ -839,12 +839,12 @@ static int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)
 {
 	struct pcxhr_stream *stream;
 	struct snd_pcm_substream *s;
+	struct snd_pcxhr *chip = snd_pcm_substream_chip(subs);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
-		snd_printdd("SNDRV_PCM_TRIGGER_START\n");
+		dev_dbg(chip->card->dev, "SNDRV_PCM_TRIGGER_START\n");
 		if (snd_pcm_stream_linked(subs)) {
-			struct snd_pcxhr *chip = snd_pcm_substream_chip(subs);
 			snd_pcm_group_for_each_entry(s, subs) {
 				if (snd_pcm_substream_chip(s) != chip)
 					continue;
@@ -856,7 +856,7 @@ static int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)
 			pcxhr_start_linked_stream(chip->mgr);
 		} else {
 			stream = subs->runtime->private_data;
-			snd_printdd("Only one Substream %c %d\n",
+			dev_dbg(chip->card->dev, "Only one Substream %c %d\n",
 				    stream->pipe->is_capture ? 'C' : 'P',
 				    stream->pipe->first_audio);
 			if (pcxhr_set_format(stream))
@@ -865,17 +865,17 @@ static int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)
 				return -EINVAL;
 
 			stream->status = PCXHR_STREAM_STATUS_SCHEDULE_RUN;
-			if (pcxhr_set_stream_state(stream))
+			if (pcxhr_set_stream_state(chip, stream))
 				return -EINVAL;
 			stream->status = PCXHR_STREAM_STATUS_RUNNING;
 		}
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
-		snd_printdd("SNDRV_PCM_TRIGGER_STOP\n");
+		dev_dbg(chip->card->dev, "SNDRV_PCM_TRIGGER_STOP\n");
 		snd_pcm_group_for_each_entry(s, subs) {
 			stream = s->runtime->private_data;
 			stream->status = PCXHR_STREAM_STATUS_SCHEDULE_STOP;
-			if (pcxhr_set_stream_state(stream))
+			if (pcxhr_set_stream_state(chip, stream))
 				return -EINVAL;
 			snd_pcm_trigger_done(s, subs);
 		}

commit 326f0480b7f8504c4f594c4f36ab7874e17780bc
Author: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
Date:   Tue Oct 28 14:27:44 2014 +0200

    ALSA: pcxhr: convert timeval to ktime_t
    
    This patch is concerned with migrating the time variables in the pcxhr
    module found in the sound driver. The changes are concerend with the
    y2038 problem where timeval will overflow in the year 2038. ktime_t
    was used instead of timeval to get the wall time. The difference
    is displayed now in nanoseconds instead of microseconds.
    
    Signed-off-by: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index b854fc5e01f5..7c33c973dbd5 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -711,8 +711,9 @@ static void pcxhr_start_linked_stream(struct pcxhr_mgr *mgr)
 	int playback_mask = 0;
 
 #ifdef CONFIG_SND_DEBUG_VERBOSE
-	struct timeval my_tv1, my_tv2;
-	do_gettimeofday(&my_tv1);
+	ktime_t start_time, stop_time, diff_time;
+
+	start_time = ktime_get();
 #endif
 	mutex_lock(&mgr->setup_mutex);
 
@@ -823,9 +824,10 @@ static void pcxhr_start_linked_stream(struct pcxhr_mgr *mgr)
 	mutex_unlock(&mgr->setup_mutex);
 
 #ifdef CONFIG_SND_DEBUG_VERBOSE
-	do_gettimeofday(&my_tv2);
+	stop_time = ktime_get();
+	diff_time = ktime_sub(stop_time, start_time);
 	dev_dbg(&mgr->pci->dev, "***TRIGGER START*** TIME = %ld (err = %x)\n",
-		    (long)(my_tv2.tv_usec - my_tv1.tv_usec), err);
+		    (long)(ktime_to_ns(diff_time)), err);
 #endif
 }
 

commit 9bef72bdb26e291d6dffb04768741a0e49582666
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 10 12:21:38 2014 +0200

    ALSA: pcxhr: Use nonatomic PCM ops
    
    This time PCXHR, another Digigram boards: like the previous patches,
    the conversion is straightforward, replacing spinlocks with mutexes,
    merging the irq tasklet into the threaded irq handler and the PCM
    trigger tasklet back to the trigger callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 68a37a7906c1..b854fc5e01f5 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -702,13 +702,11 @@ static inline int pcxhr_stream_scheduled_get_pipe(struct pcxhr_stream *stream,
 	return 0;
 }
 
-static void pcxhr_trigger_tasklet(unsigned long arg)
+static void pcxhr_start_linked_stream(struct pcxhr_mgr *mgr)
 {
-	unsigned long flags;
 	int i, j, err;
 	struct pcxhr_pipe *pipe;
 	struct snd_pcxhr *chip;
-	struct pcxhr_mgr *mgr = (struct pcxhr_mgr*)(arg);
 	int capture_mask = 0;
 	int playback_mask = 0;
 
@@ -736,11 +734,11 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 	}
 	if (capture_mask == 0 && playback_mask == 0) {
 		mutex_unlock(&mgr->setup_mutex);
-		dev_err(&mgr->pci->dev, "pcxhr_trigger_tasklet : no pipes\n");
+		dev_err(&mgr->pci->dev, "pcxhr_start_linked_stream : no pipes\n");
 		return;
 	}
 
-	dev_dbg(&mgr->pci->dev, "pcxhr_trigger_tasklet : "
+	dev_dbg(&mgr->pci->dev, "pcxhr_start_linked_stream : "
 		    "playback_mask=%x capture_mask=%x\n",
 		    playback_mask, capture_mask);
 
@@ -748,7 +746,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 	err = pcxhr_set_pipe_state(mgr,  playback_mask, capture_mask, 0);
 	if (err) {
 		mutex_unlock(&mgr->setup_mutex);
-		dev_err(&mgr->pci->dev, "pcxhr_trigger_tasklet : "
+		dev_err(&mgr->pci->dev, "pcxhr_start_linked_stream : "
 			   "error stop pipes (P%x C%x)\n",
 			   playback_mask, capture_mask);
 		return;
@@ -793,7 +791,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 	err = pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 1);
 	if (err) {
 		mutex_unlock(&mgr->setup_mutex);
-		dev_err(&mgr->pci->dev, "pcxhr_trigger_tasklet : "
+		dev_err(&mgr->pci->dev, "pcxhr_start_linked_stream : "
 			   "error start pipes (P%x C%x)\n",
 			   playback_mask, capture_mask);
 		return;
@@ -802,7 +800,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 	/* put the streams into the running state now
 	 * (increment pointer by interrupt)
 	 */
-	spin_lock_irqsave(&mgr->lock, flags);
+	mutex_lock(&mgr->lock);
 	for ( i =0; i < mgr->num_cards; i++) {
 		struct pcxhr_stream *stream;
 		chip = mgr->chip[i];
@@ -820,13 +818,13 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 			}
 		}
 	}
-	spin_unlock_irqrestore(&mgr->lock, flags);
+	mutex_unlock(&mgr->lock);
 
 	mutex_unlock(&mgr->setup_mutex);
 
 #ifdef CONFIG_SND_DEBUG_VERBOSE
 	do_gettimeofday(&my_tv2);
-	dev_dbg(&mgr->pci->dev, "***TRIGGER TASKLET*** TIME = %ld (err = %x)\n",
+	dev_dbg(&mgr->pci->dev, "***TRIGGER START*** TIME = %ld (err = %x)\n",
 		    (long)(my_tv2.tv_usec - my_tv1.tv_usec), err);
 #endif
 }
@@ -853,7 +851,7 @@ static int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)
 					PCXHR_STREAM_STATUS_SCHEDULE_RUN;
 				snd_pcm_trigger_done(s, subs);
 			}
-			tasklet_schedule(&chip->mgr->trigger_taskq);
+			pcxhr_start_linked_stream(chip->mgr);
 		} else {
 			stream = subs->runtime->private_data;
 			snd_printdd("Only one Substream %c %d\n",
@@ -1127,20 +1125,19 @@ static int pcxhr_close(struct snd_pcm_substream *subs)
 
 static snd_pcm_uframes_t pcxhr_stream_pointer(struct snd_pcm_substream *subs)
 {
-	unsigned long flags;
 	u_int32_t timer_period_frag;
 	int timer_buf_periods;
 	struct snd_pcxhr *chip = snd_pcm_substream_chip(subs);
 	struct snd_pcm_runtime *runtime = subs->runtime;
 	struct pcxhr_stream *stream  = runtime->private_data;
 
-	spin_lock_irqsave(&chip->mgr->lock, flags);
+	mutex_lock(&chip->mgr->lock);
 
 	/* get the period fragment and the nb of periods in the buffer */
 	timer_period_frag = stream->timer_period_frag;
 	timer_buf_periods = stream->timer_buf_periods;
 
-	spin_unlock_irqrestore(&chip->mgr->lock, flags);
+	mutex_unlock(&chip->mgr->lock);
 
 	return (snd_pcm_uframes_t)((timer_buf_periods * runtime->period_size) +
 				   timer_period_frag);
@@ -1181,6 +1178,7 @@ int pcxhr_create_pcm(struct snd_pcxhr *chip)
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &pcxhr_ops);
 
 	pcm->info_flags = 0;
+	pcm->nonatomic = true;
 	strcpy(pcm->name, name);
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
@@ -1588,8 +1586,9 @@ static int pcxhr_probe(struct pci_dev *pci,
 	mgr->pci = pci;
 	mgr->irq = -1;
 
-	if (request_irq(pci->irq, pcxhr_interrupt, IRQF_SHARED,
-			KBUILD_MODNAME, mgr)) {
+	if (request_threaded_irq(pci->irq, pcxhr_interrupt,
+				 pcxhr_threaded_irq, IRQF_SHARED,
+				 KBUILD_MODNAME, mgr)) {
 		dev_err(&pci->dev, "unable to grab IRQ %d\n", pci->irq);
 		pcxhr_free(mgr);
 		return -EBUSY;
@@ -1601,19 +1600,13 @@ static int pcxhr_probe(struct pci_dev *pci,
 		mgr->shortname,
 		mgr->port[0], mgr->port[1], mgr->port[2], mgr->irq);
 
-	/* ISR spinlock  */
-	spin_lock_init(&mgr->lock);
-	spin_lock_init(&mgr->msg_lock);
+	/* ISR lock  */
+	mutex_init(&mgr->lock);
+	mutex_init(&mgr->msg_lock);
 
 	/* init setup mutex*/
 	mutex_init(&mgr->setup_mutex);
 
-	/* init taslket */
-	tasklet_init(&mgr->msg_taskq, pcxhr_msg_tasklet,
-		     (unsigned long) mgr);
-	tasklet_init(&mgr->trigger_taskq, pcxhr_trigger_tasklet,
-		     (unsigned long) mgr);
-
 	mgr->prmh = kmalloc(sizeof(*mgr->prmh) + 
 			    sizeof(u32) * (PCXHR_SIZE_MAX_LONG_STATUS -
 					   PCXHR_SIZE_MAX_STATUS),

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 8d09444ff88b..68a37a7906c1 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -102,7 +102,7 @@ enum {
 	PCI_ID_LAST
 };
 
-static DEFINE_PCI_DEVICE_TABLE(pcxhr_ids) = {
+static const struct pci_device_id pcxhr_ids[] = {
 	{ 0x10b5, 0x9656, 0x1369, 0xb001, 0, 0, PCI_ID_VX882HR, },
 	{ 0x10b5, 0x9656, 0x1369, 0xb101, 0, 0, PCI_ID_PCX882HR, },
 	{ 0x10b5, 0x9656, 0x1369, 0xb201, 0, 0, PCI_ID_VX881HR, },

commit b59bb8efd1c1f2eaeed13eccf1fa4e564d2383ae
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 26 11:47:55 2014 +0100

    ALSA: pcxhr: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 3880f6da9a87..8d09444ff88b 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -284,7 +284,7 @@ static int pcxhr_get_clock_reg(struct pcxhr_mgr *mgr, unsigned int rate,
 			rmh.cmd_len = 3;
 			err = pcxhr_send_msg(mgr, &rmh);
 			if (err < 0) {
-				snd_printk(KERN_ERR
+				dev_err(&mgr->pci->dev,
 					   "error CMD_ACCESS_IO_WRITE "
 					   "for PLL register : %x!\n", err);
 				return err;
@@ -357,7 +357,7 @@ static int pcxhr_sub_set_clock(struct pcxhr_mgr *mgr,
 			return err;
 	}
 	/* set the new frequency */
-	snd_printdd("clock register : set %x\n", val);
+	dev_dbg(&mgr->pci->dev, "clock register : set %x\n", val);
 	err = pcxhr_write_io_num_reg_cont(mgr, PCXHR_FREQ_REG_MASK,
 					  val, changed);
 	if (err)
@@ -380,7 +380,7 @@ static int pcxhr_sub_set_clock(struct pcxhr_mgr *mgr,
 		mgr->codec_speed = speed;	/* save new codec speed */
 	}
 
-	snd_printdd("pcxhr_sub_set_clock to %dHz (realfreq=%d)\n",
+	dev_dbg(&mgr->pci->dev, "pcxhr_sub_set_clock to %dHz (realfreq=%d)\n",
 		    rate, realfreq);
 	return 0;
 }
@@ -480,7 +480,7 @@ static int pcxhr_sub_get_external_clock(struct pcxhr_mgr *mgr,
 	case REG_STATUS_SYNC_192000 :	rate = 192000; break;
 	default: rate = 0;
 	}
-	snd_printdd("External clock is at %d Hz\n", rate);
+	dev_dbg(&mgr->pci->dev, "External clock is at %d Hz\n", rate);
 	*sample_rate = rate;
 	return 0;
 }
@@ -537,8 +537,8 @@ static int pcxhr_set_stream_state(struct pcxhr_stream *stream)
 
 	err = pcxhr_send_msg(chip->mgr, &rmh);
 	if (err)
-		snd_printk(KERN_ERR "ERROR pcxhr_set_stream_state err=%x;\n",
-			   err);
+		dev_err(chip->card->dev,
+			"ERROR pcxhr_set_stream_state err=%x;\n", err);
 	stream->status =
 	  start ? PCXHR_STREAM_STATUS_STARTED : PCXHR_STREAM_STATUS_STOPPED;
 	return err;
@@ -628,7 +628,8 @@ static int pcxhr_set_format(struct pcxhr_stream *stream)
 	rmh.cmd[rmh.cmd_len++] = (header & 0xff) << 16;
 	err = pcxhr_send_msg(chip->mgr, &rmh);
 	if (err)
-		snd_printk(KERN_ERR "ERROR pcxhr_set_format err=%x;\n", err);
+		dev_err(chip->card->dev,
+			"ERROR pcxhr_set_format err=%x;\n", err);
 	return err;
 }
 
@@ -665,7 +666,7 @@ static int pcxhr_update_r_buffer(struct pcxhr_stream *stream)
 	rmh.cmd_len = 4;
 	err = pcxhr_send_msg(chip->mgr, &rmh);
 	if (err)
-		snd_printk(KERN_ERR
+		dev_err(chip->card->dev,
 			   "ERROR CMD_UPDATE_R_BUFFERS err=%x;\n", err);
 	return err;
 }
@@ -735,11 +736,11 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 	}
 	if (capture_mask == 0 && playback_mask == 0) {
 		mutex_unlock(&mgr->setup_mutex);
-		snd_printk(KERN_ERR "pcxhr_trigger_tasklet : no pipes\n");
+		dev_err(&mgr->pci->dev, "pcxhr_trigger_tasklet : no pipes\n");
 		return;
 	}
 
-	snd_printdd("pcxhr_trigger_tasklet : "
+	dev_dbg(&mgr->pci->dev, "pcxhr_trigger_tasklet : "
 		    "playback_mask=%x capture_mask=%x\n",
 		    playback_mask, capture_mask);
 
@@ -747,7 +748,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 	err = pcxhr_set_pipe_state(mgr,  playback_mask, capture_mask, 0);
 	if (err) {
 		mutex_unlock(&mgr->setup_mutex);
-		snd_printk(KERN_ERR "pcxhr_trigger_tasklet : "
+		dev_err(&mgr->pci->dev, "pcxhr_trigger_tasklet : "
 			   "error stop pipes (P%x C%x)\n",
 			   playback_mask, capture_mask);
 		return;
@@ -792,7 +793,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 	err = pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 1);
 	if (err) {
 		mutex_unlock(&mgr->setup_mutex);
-		snd_printk(KERN_ERR "pcxhr_trigger_tasklet : "
+		dev_err(&mgr->pci->dev, "pcxhr_trigger_tasklet : "
 			   "error start pipes (P%x C%x)\n",
 			   playback_mask, capture_mask);
 		return;
@@ -825,7 +826,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 
 #ifdef CONFIG_SND_DEBUG_VERBOSE
 	do_gettimeofday(&my_tv2);
-	snd_printdd("***TRIGGER TASKLET*** TIME = %ld (err = %x)\n",
+	dev_dbg(&mgr->pci->dev, "***TRIGGER TASKLET*** TIME = %ld (err = %x)\n",
 		    (long)(my_tv2.tv_usec - my_tv1.tv_usec), err);
 #endif
 }
@@ -902,7 +903,7 @@ static int pcxhr_hardware_timer(struct pcxhr_mgr *mgr, int start)
 	}
 	err = pcxhr_send_msg(mgr, &rmh);
 	if (err < 0)
-		snd_printk(KERN_ERR "error pcxhr_hardware_timer err(%x)\n",
+		dev_err(&mgr->pci->dev, "error pcxhr_hardware_timer err(%x)\n",
 			   err);
 	return err;
 }
@@ -916,7 +917,8 @@ static int pcxhr_prepare(struct snd_pcm_substream *subs)
 	struct pcxhr_mgr *mgr = chip->mgr;
 	int err = 0;
 
-	snd_printdd("pcxhr_prepare : period_size(%lx) periods(%x) buffer_size(%lx)\n",
+	dev_dbg(chip->card->dev,
+		"pcxhr_prepare : period_size(%lx) periods(%x) buffer_size(%lx)\n",
 		    subs->runtime->period_size, subs->runtime->periods,
 		    subs->runtime->buffer_size);
 
@@ -1025,11 +1027,11 @@ static int pcxhr_open(struct snd_pcm_substream *subs)
 	runtime->hw = pcxhr_caps;
 
 	if( subs->stream == SNDRV_PCM_STREAM_PLAYBACK ) {
-		snd_printdd("pcxhr_open playback chip%d subs%d\n",
+		dev_dbg(chip->card->dev, "pcxhr_open playback chip%d subs%d\n",
 			    chip->chip_idx, subs->number);
 		stream = &chip->playback_stream[subs->number];
 	} else {
-		snd_printdd("pcxhr_open capture chip%d subs%d\n",
+		dev_dbg(chip->card->dev, "pcxhr_open capture chip%d subs%d\n",
 			    chip->chip_idx, subs->number);
 		if (mgr->mono_capture)
 			runtime->hw.channels_max = 1;
@@ -1039,7 +1041,7 @@ static int pcxhr_open(struct snd_pcm_substream *subs)
 	}
 	if (stream->status != PCXHR_STREAM_STATUS_FREE){
 		/* streams in use */
-		snd_printk(KERN_ERR "pcxhr_open chip%d subs%d in use\n",
+		dev_err(chip->card->dev, "pcxhr_open chip%d subs%d in use\n",
 			   chip->chip_idx, subs->number);
 		mutex_unlock(&mgr->setup_mutex);
 		return -EBUSY;
@@ -1105,7 +1107,7 @@ static int pcxhr_close(struct snd_pcm_substream *subs)
 
 	mutex_lock(&mgr->setup_mutex);
 
-	snd_printdd("pcxhr_close chip%d subs%d\n",
+	dev_dbg(chip->card->dev, "pcxhr_close chip%d subs%d\n",
 		    chip->chip_idx, subs->number);
 
 	/* sample rate released */
@@ -1168,7 +1170,7 @@ int pcxhr_create_pcm(struct snd_pcxhr *chip)
 	if ((err = snd_pcm_new(chip->card, name, 0,
 			       chip->nb_streams_play,
 			       chip->nb_streams_capt, &pcm)) < 0) {
-		snd_printk(KERN_ERR "cannot create pcm %s\n", name);
+		dev_err(chip->card->dev, "cannot create pcm %s\n", name);
 		return err;
 	}
 	pcm->private_data = chip;
@@ -1214,7 +1216,7 @@ static int pcxhr_create(struct pcxhr_mgr *mgr,
 
 	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
 	if (! chip) {
-		snd_printk(KERN_ERR "cannot allocate chip\n");
+		dev_err(card->dev, "cannot allocate chip\n");
 		return -ENOMEM;
 	}
 
@@ -1487,7 +1489,7 @@ static int pcxhr_free(struct pcxhr_mgr *mgr)
 	/* reset board if some firmware was loaded */
 	if(mgr->dsp_loaded) {
 		pcxhr_reset_board(mgr);
-		snd_printdd("reset pcxhr !\n");
+		dev_dbg(&mgr->pci->dev, "reset pcxhr !\n");
 	}
 
 	/* release irq  */
@@ -1536,8 +1538,8 @@ static int pcxhr_probe(struct pci_dev *pci,
 
 	/* check if we can restrict PCI DMA transfers to 32 bits */
 	if (pci_set_dma_mask(pci, DMA_BIT_MASK(32)) < 0) {
-		snd_printk(KERN_ERR "architecture does not support "
-			   "32bit PCI busmaster DMA\n");
+		dev_err(&pci->dev,
+			"architecture does not support 32bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;
 	}
@@ -1588,7 +1590,7 @@ static int pcxhr_probe(struct pci_dev *pci,
 
 	if (request_irq(pci->irq, pcxhr_interrupt, IRQF_SHARED,
 			KBUILD_MODNAME, mgr)) {
-		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		dev_err(&pci->dev, "unable to grab IRQ %d\n", pci->irq);
 		pcxhr_free(mgr);
 		return -EBUSY;
 	}
@@ -1641,7 +1643,7 @@ static int pcxhr_probe(struct pci_dev *pci,
 				   0, &card);
 
 		if (err < 0) {
-			snd_printk(KERN_ERR "cannot allocate the card %d\n", i);
+			dev_err(card->dev, "cannot allocate the card %d\n", i);
 			pcxhr_free(mgr);
 			return err;
 		}

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index d379b284955b..3880f6da9a87 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1239,7 +1239,6 @@ static int pcxhr_create(struct pcxhr_mgr *mgr,
 	}
 
 	mgr->chip[idx] = chip;
-	snd_card_set_dev(card, &mgr->pci->dev);
 
 	return 0;
 }
@@ -1638,7 +1637,8 @@ static int pcxhr_probe(struct pci_dev *pci,
 
 		snprintf(tmpid, sizeof(tmpid), "%s-%d",
 			 id[dev] ? id[dev] : card_name, i);
-		err = snd_card_create(idx, tmpid, THIS_MODULE, 0, &card);
+		err = snd_card_new(&pci->dev, idx, tmpid, THIS_MODULE,
+				   0, &card);
 
 		if (err < 0) {
 			snd_printk(KERN_ERR "cannot allocate the card %d\n", i);

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index b97384ad946d..d379b284955b 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1691,7 +1691,6 @@ static int pcxhr_probe(struct pci_dev *pci,
 static void pcxhr_remove(struct pci_dev *pci)
 {
 	pcxhr_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 static struct pci_driver pcxhr_driver = {

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index be4f1456009a..b97384ad946d 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1203,8 +1203,8 @@ static int pcxhr_chip_dev_free(struct snd_device *device)
 
 /*
  */
-static int __devinit pcxhr_create(struct pcxhr_mgr *mgr,
-				  struct snd_card *card, int idx)
+static int pcxhr_create(struct pcxhr_mgr *mgr,
+			struct snd_card *card, int idx)
 {
 	int err;
 	struct snd_pcxhr *chip;
@@ -1453,7 +1453,7 @@ static void pcxhr_proc_ltc(struct snd_info_entry *entry,
 	}
 }
 
-static void __devinit pcxhr_proc_init(struct snd_pcxhr *chip)
+static void pcxhr_proc_init(struct snd_pcxhr *chip)
 {
 	struct snd_info_entry *entry;
 
@@ -1513,8 +1513,8 @@ static int pcxhr_free(struct pcxhr_mgr *mgr)
 /*
  *    probe function - creates the card manager
  */
-static int __devinit pcxhr_probe(struct pci_dev *pci,
-				 const struct pci_device_id *pci_id)
+static int pcxhr_probe(struct pci_dev *pci,
+		       const struct pci_device_id *pci_id)
 {
 	static int dev;
 	struct pcxhr_mgr *mgr;
@@ -1688,7 +1688,7 @@ static int __devinit pcxhr_probe(struct pci_dev *pci,
 	return 0;
 }
 
-static void __devexit pcxhr_remove(struct pci_dev *pci)
+static void pcxhr_remove(struct pci_dev *pci)
 {
 	pcxhr_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -1698,7 +1698,7 @@ static struct pci_driver pcxhr_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = pcxhr_ids,
 	.probe = pcxhr_probe,
-	.remove = __devexit_p(pcxhr_remove),
+	.remove = pcxhr_remove,
 };
 
 module_pci_driver(pcxhr_driver);

commit 8c3f1b1cbc32d1fa899e3bd9edf427f0f2e7a843
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Fri Aug 24 14:54:57 2012 +0200

    ALSA: pcxhr: Add 8 new sound cards
    
    add new sound cards VX442HR VX442e PCX442HR PCX442e VX822HR VX822e PCX822HR and PCX822e
    
    Signed-off-by: Markus Bollinger <bollinger@digigram.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index e3ac1f768ff6..be4f1456009a 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -91,6 +91,14 @@ enum {
 	PCI_ID_PCX924E,
 	PCI_ID_PCX924HRMIC,
 	PCI_ID_PCX924E_MIC,
+	PCI_ID_VX442HR,
+	PCI_ID_PCX442HR,
+	PCI_ID_VX442E,
+	PCI_ID_PCX442E,
+	PCI_ID_VX822HR,
+	PCI_ID_PCX822HR,
+	PCI_ID_VX822E,
+	PCI_ID_PCX822E,
 	PCI_ID_LAST
 };
 
@@ -121,6 +129,14 @@ static DEFINE_PCI_DEVICE_TABLE(pcxhr_ids) = {
 	{ 0x10b5, 0x9056, 0x1369, 0xbb21, 0, 0, PCI_ID_PCX924E, },
 	{ 0x10b5, 0x9056, 0x1369, 0xbf01, 0, 0, PCI_ID_PCX924HRMIC, },
 	{ 0x10b5, 0x9056, 0x1369, 0xbf21, 0, 0, PCI_ID_PCX924E_MIC, },
+	{ 0x10b5, 0x9656, 0x1369, 0xd001, 0, 0, PCI_ID_VX442HR, },
+	{ 0x10b5, 0x9656, 0x1369, 0xd101, 0, 0, PCI_ID_PCX442HR, },
+	{ 0x10b5, 0x9056, 0x1369, 0xd021, 0, 0, PCI_ID_VX442E, },
+	{ 0x10b5, 0x9056, 0x1369, 0xd121, 0, 0, PCI_ID_PCX442E, },
+	{ 0x10b5, 0x9656, 0x1369, 0xd201, 0, 0, PCI_ID_VX822HR, },
+	{ 0x10b5, 0x9656, 0x1369, 0xd301, 0, 0, PCI_ID_PCX822HR, },
+	{ 0x10b5, 0x9056, 0x1369, 0xd221, 0, 0, PCI_ID_VX822E, },
+	{ 0x10b5, 0x9056, 0x1369, 0xd321, 0, 0, PCI_ID_PCX822E, },
 	{ 0, }
 };
 
@@ -160,6 +176,14 @@ static struct board_parameters pcxhr_board_params[] = {
 [PCI_ID_PCX924E] =      { "PCX924e",      1, 1, 5, 44 },
 [PCI_ID_PCX924HRMIC] =  { "PCX924HR-Mic", 1, 1, 5, 44 },
 [PCI_ID_PCX924E_MIC] =  { "PCX924e-Mic",  1, 1, 5, 44 },
+[PCI_ID_VX442HR] =      { "VX442HR",      2, 2, 0, 41 },
+[PCI_ID_PCX442HR] =     { "PCX442HR",     2, 2, 0, 41 },
+[PCI_ID_VX442E] =       { "VX442e",       2, 2, 1, 41 },
+[PCI_ID_PCX442E] =      { "PCX442e",      2, 2, 1, 41 },
+[PCI_ID_VX822HR] =      { "VX822HR",      4, 1, 2, 42 },
+[PCI_ID_PCX822HR] =     { "PCX822HR",     4, 1, 2, 42 },
+[PCI_ID_VX822E] =       { "VX822e",       4, 1, 3, 42 },
+[PCI_ID_PCX822E] =      { "PCX822e",      4, 1, 3, 42 },
 };
 
 /* boards without hw AES1 and SRC onboard are all using fw_file_set==4 */

commit fdfbaf69e0b9d6843c0da6501caf4ecacec0f775
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Wed Jun 20 08:34:40 2012 +0200

    ALSA: pcxhr: Add LTC support
    
    add LTC (linear timecode) read function via proc interface to the pcxhr driver
    
    Signed-off-by: Markus Bollinger <bollinger@digigram.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 0435f45e9513..e3ac1f768ff6 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1368,6 +1368,67 @@ static void pcxhr_proc_gpo_write(struct snd_info_entry *entry,
 	}
 }
 
+/* Access to the results of the CMD_GET_TIME_CODE RMH */
+#define TIME_CODE_VALID_MASK	0x00800000
+#define TIME_CODE_NEW_MASK	0x00400000
+#define TIME_CODE_BACK_MASK	0x00200000
+#define TIME_CODE_WAIT_MASK	0x00100000
+
+/* Values for the CMD_MANAGE_SIGNAL RMH */
+#define MANAGE_SIGNAL_TIME_CODE	0x01
+#define MANAGE_SIGNAL_MIDI	0x02
+
+/* linear time code read proc*/
+static void pcxhr_proc_ltc(struct snd_info_entry *entry,
+			   struct snd_info_buffer *buffer)
+{
+	struct snd_pcxhr *chip = entry->private_data;
+	struct pcxhr_mgr *mgr = chip->mgr;
+	struct pcxhr_rmh rmh;
+	unsigned int ltcHrs, ltcMin, ltcSec, ltcFrm;
+	int err;
+	/* commands available when embedded DSP is running */
+	if (!(mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX))) {
+		snd_iprintf(buffer, "no firmware loaded\n");
+		return;
+	}
+	if (!mgr->capture_ltc) {
+		pcxhr_init_rmh(&rmh, CMD_MANAGE_SIGNAL);
+		rmh.cmd[0] |= MANAGE_SIGNAL_TIME_CODE;
+		err = pcxhr_send_msg(mgr, &rmh);
+		if (err) {
+			snd_iprintf(buffer, "ltc not activated (%d)\n", err);
+			return;
+		}
+		if (mgr->is_hr_stereo)
+			hr222_manage_timecode(mgr, 1);
+		else
+			pcxhr_write_io_num_reg_cont(mgr, REG_CONT_VALSMPTE,
+						    REG_CONT_VALSMPTE, NULL);
+		mgr->capture_ltc = 1;
+	}
+	pcxhr_init_rmh(&rmh, CMD_GET_TIME_CODE);
+	err = pcxhr_send_msg(mgr, &rmh);
+	if (err) {
+		snd_iprintf(buffer, "ltc read error (err=%d)\n", err);
+		return ;
+	}
+	ltcHrs = 10*((rmh.stat[0] >> 8) & 0x3) + (rmh.stat[0] & 0xf);
+	ltcMin = 10*((rmh.stat[1] >> 16) & 0x7) + ((rmh.stat[1] >> 8) & 0xf);
+	ltcSec = 10*(rmh.stat[1] & 0x7) + ((rmh.stat[2] >> 16) & 0xf);
+	ltcFrm = 10*((rmh.stat[2] >> 8) & 0x3) + (rmh.stat[2] & 0xf);
+
+	snd_iprintf(buffer, "timecode: %02u:%02u:%02u-%02u\n",
+			    ltcHrs, ltcMin, ltcSec, ltcFrm);
+	snd_iprintf(buffer, "raw: 0x%04x%06x%06x\n", rmh.stat[0] & 0x00ffff,
+			    rmh.stat[1] & 0xffffff, rmh.stat[2] & 0xffffff);
+	/*snd_iprintf(buffer, "dsp ref time: 0x%06x%06x\n",
+			    rmh.stat[3] & 0xffffff, rmh.stat[4] & 0xffffff);*/
+	if (!(rmh.stat[0] & TIME_CODE_VALID_MASK)) {
+		snd_iprintf(buffer, "warning: linear timecode not valid\n");
+	}
+}
+
 static void __devinit pcxhr_proc_init(struct snd_pcxhr *chip)
 {
 	struct snd_info_entry *entry;
@@ -1383,6 +1444,8 @@ static void __devinit pcxhr_proc_init(struct snd_pcxhr *chip)
 		entry->c.text.write = pcxhr_proc_gpo_write;
 		entry->mode |= S_IWUSR;
 	}
+	if (!snd_card_proc_new(chip->card, "ltc", &entry))
+		snd_info_set_text_ops(entry, chip, pcxhr_proc_ltc);
 }
 /* end of proc interface */
 

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index fd1809ab73b4..0435f45e9513 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1607,22 +1607,11 @@ static void __devexit pcxhr_remove(struct pci_dev *pci)
 	pci_set_drvdata(pci, NULL);
 }
 
-static struct pci_driver driver = {
+static struct pci_driver pcxhr_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = pcxhr_ids,
 	.probe = pcxhr_probe,
 	.remove = __devexit_p(pcxhr_remove),
 };
 
-static int __init pcxhr_module_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit pcxhr_module_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(pcxhr_module_init)
-module_exit(pcxhr_module_exit)
+module_pci_driver(pcxhr_driver);

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 56a52659742d..fd1809ab73b4 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -52,8 +52,8 @@ MODULE_SUPPORTED_DEVICE("{{Digigram," DRIVER_NAME "}}");
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */
-static int mono[SNDRV_CARDS];				/* capture  mono only */
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */
+static bool mono[SNDRV_CARDS];				/* capture  mono only */
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for Digigram " DRIVER_NAME " soundcard");

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 046578d26f98..56a52659742d 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -27,7 +27,7 @@
 #include <linux/pci.h>
 #include <linux/dma-mapping.h>
 #include <linux/delay.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <linux/mutex.h>
 
 #include <sound/core.h>

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index cb215a01ebb6..046578d26f98 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1501,7 +1501,7 @@ static int __devinit pcxhr_probe(struct pci_dev *pci,
 	mgr->irq = -1;
 
 	if (request_irq(pci->irq, pcxhr_interrupt, IRQF_SHARED,
-			card_name, mgr)) {
+			KBUILD_MODNAME, mgr)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		pcxhr_free(mgr);
 		return -EBUSY;

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 95cfde27d25c..cb215a01ebb6 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1608,7 +1608,7 @@ static void __devexit pcxhr_remove(struct pci_dev *pci)
 }
 
 static struct pci_driver driver = {
-	.name = "Digigram pcxhr",
+	.name = KBUILD_MODNAME,
 	.id_table = pcxhr_ids,
 	.probe = pcxhr_probe,
 	.remove = __devexit_p(pcxhr_remove),

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 833e9c7b27c7..95cfde27d25c 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -94,7 +94,7 @@ enum {
 	PCI_ID_LAST
 };
 
-static struct pci_device_id pcxhr_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(pcxhr_ids) = {
 	{ 0x10b5, 0x9656, 0x1369, 0xb001, 0, 0, PCI_ID_VX882HR, },
 	{ 0x10b5, 0x9656, 0x1369, 0xb101, 0, 0, PCI_ID_PCX882HR, },
 	{ 0x10b5, 0x9656, 0x1369, 0xb201, 0, 0, PCI_ID_VX881HR, },

commit 284901a90a9e0b812ca3f5f852cbbfb60d10249d
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:15 2009 -0700

    dma-mapping: replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 80e064a3efff..833e9c7b27c7 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1449,7 +1449,7 @@ static int __devinit pcxhr_probe(struct pci_dev *pci,
 	pci_set_master(pci);
 
 	/* check if we can restrict PCI DMA transfers to 32 bits */
-	if (pci_set_dma_mask(pci, DMA_32BIT_MASK) < 0) {
+	if (pci_set_dma_mask(pci, DMA_BIT_MASK(32)) < 0) {
 		snd_printk(KERN_ERR "architecture does not support "
 			   "32bit PCI busmaster DMA\n");
 		pci_disable_device(pci);

commit 7df4f694356a125e4553ca35b215fd9e88e858c5
Merge: b54fc8dd2c43 d563ffa6b319
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:36:19 2009 +0100

    Merge branch 'topic/pcxhr' into for-linus

commit 55aef4508598d59c2baea7e2a3e6dfed415bbfc0
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Fri Jan 23 14:45:41 2009 +0100

    ALSA: pcxhr - add support for gpio ports and minor bug fix
    
    - add support for gpio ports (2 GPI, 2 GPO) of pcxhr stereo cards
    - minor bugfixes : allow setting clock to internal by the mixer
                       even if there is no stream (but monitoring)
    
    Signed-off-by: Markus Bollinger <bollinger@digigram.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 27cf2c28d113..ca89106f8c5d 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1334,6 +1334,40 @@ static void pcxhr_proc_sync(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "\n");
 }
 
+static void pcxhr_proc_gpio_read(struct snd_info_entry *entry,
+				 struct snd_info_buffer *buffer)
+{
+	struct snd_pcxhr *chip = entry->private_data;
+	struct pcxhr_mgr *mgr = chip->mgr;
+	/* commands available when embedded DSP is running */
+	if (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {
+		/* gpio ports on stereo boards only available */
+		int value = 0;
+		hr222_read_gpio(mgr, 1, &value);	/* GPI */
+		snd_iprintf(buffer, "GPI: 0x%x\n", value);
+		hr222_read_gpio(mgr, 0, &value);	/* GP0 */
+		snd_iprintf(buffer, "GPO: 0x%x\n", value);
+	} else
+		snd_iprintf(buffer, "no firmware loaded\n");
+	snd_iprintf(buffer, "\n");
+}
+static void pcxhr_proc_gpo_write(struct snd_info_entry *entry,
+				 struct snd_info_buffer *buffer)
+{
+	struct snd_pcxhr *chip = entry->private_data;
+	struct pcxhr_mgr *mgr = chip->mgr;
+	char line[64];
+	int value;
+	/* commands available when embedded DSP is running */
+	if (!(mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)))
+		return;
+	while (!snd_info_get_line(buffer, line, sizeof(line))) {
+		if (sscanf(line, "GPO: 0x%x", &value) != 1)
+			continue;
+		hr222_write_gpo(mgr, value);	/* GP0 */
+	}
+}
+
 static void __devinit pcxhr_proc_init(struct snd_pcxhr *chip)
 {
 	struct snd_info_entry *entry;
@@ -1342,6 +1376,13 @@ static void __devinit pcxhr_proc_init(struct snd_pcxhr *chip)
 		snd_info_set_text_ops(entry, chip, pcxhr_proc_info);
 	if (! snd_card_proc_new(chip->card, "sync", &entry))
 		snd_info_set_text_ops(entry, chip, pcxhr_proc_sync);
+	/* gpio available on stereo sound cards only */
+	if (chip->mgr->is_hr_stereo &&
+	    !snd_card_proc_new(chip->card, "gpio", &entry)) {
+		snd_info_set_text_ops(entry, chip, pcxhr_proc_gpio_read);
+		entry->c.text.write = pcxhr_proc_gpo_write;
+		entry->mode |= S_IWUSR;
+	}
 }
 /* end of proc interface */
 

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 27cf2c28d113..7f95459c8b1f 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1510,12 +1510,12 @@ static int __devinit pcxhr_probe(struct pci_dev *pci,
 
 		snprintf(tmpid, sizeof(tmpid), "%s-%d",
 			 id[dev] ? id[dev] : card_name, i);
-		card = snd_card_new(idx, tmpid, THIS_MODULE, 0);
+		err = snd_card_create(idx, tmpid, THIS_MODULE, 0, &card);
 
-		if (! card) {
+		if (err < 0) {
 			snd_printk(KERN_ERR "cannot allocate the card %d\n", i);
 			pcxhr_free(mgr);
-			return -ENOMEM;
+			return err;
 		}
 
 		strcpy(card->driver, DRIVER_NAME);

commit a9c3c7e04b9a744eafb2e87c770e7300bbffa375
Merge: cc4910850f93 ade9b2fb9bf8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 25 11:40:31 2008 +0100

    Merge branch 'topic/pcxhr-update' into to-push

commit 8afabfa74bbe81ac496e66f7f0ed8943dff5fdb5
Merge: 86b3aa390b4b 1f04128a3db7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 25 11:40:27 2008 +0100

    Merge branch 'topic/convert-tasklet' into to-push

commit 55fa518867978e1f5fd8353098f80d125ac734d7
Merge: bb1f24bf00a8 eea0579fc85e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat Dec 20 23:39:47 2008 +0100

    Merge branch 'topic/pcsp-fix' into topic/misc

commit 1f04128a3db7c0f0e8b5d25323eba70ac342f47f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 18 12:17:55 2008 +0100

    ALSA: hda - Convert from takslet_hi_schedule() to tasklet_schedule()
    
    Replace all tasklet_hi_schedule() callers with the normal
    tasklet_schedule().  The former often causes troubles with
    RT-kernels, and has actually no merit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 73de6e989b3d..8309d4487722 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -653,7 +653,7 @@ static int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)
 					PCXHR_STREAM_STATUS_SCHEDULE_RUN;
 				snd_pcm_trigger_done(s, subs);
 			}
-			tasklet_hi_schedule(&chip->mgr->trigger_taskq);
+			tasklet_schedule(&chip->mgr->trigger_taskq);
 		} else {
 			stream = subs->runtime->private_data;
 			snd_printdd("Only one Substream %c %d\n",

commit 73f6a12ed187b7e7ac9334d1419ba7bf7ac1be26
Author: Julia Lawall <julia@diku.dk>
Date:   Thu Nov 27 15:40:40 2008 +0100

    ALSA: sound/pci/mixart/mixart.c: Add missing snd_card_free
    
    The function snd_mixart_create creates a link between mgr and card that
    allows snd_mixart_free to free card as well.  But if snd_mixart_create
    fails, then the link has not been created and card has to be freed explicitly.
    
    The semantic match that finds the problem is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @r exists@
    local idexpression x;
    statement S,S1;
    position p1,p2,p3;
    expression E,E1;
    type T,T1;
    expression *ptr != NULL;
    @@
    
    (
     if ((x@p1 = snd_card_new(...)) == NULL) S
    |
     x@p1 = snd_card_new(...);
    )
     ... when != snd_card_free(...,(T)x,...)
         when != if (...) { <+... snd_card_free(...,(T)x,...) ...+> }
         when != true x == NULL || ...
         when != x = E
         when != E = (T)x
         when any
    (
     if (x == NULL || ...) S1
    |
     if@p2 (...) {
      ... when != snd_card_free(...,(T1)x,...)
          when != if (...) { <+... snd_card_free(...,(T1)x,...) ...+> }
          when != x = E1
          when != E1 = (T1)x
    (
      return \(0\|<+...x...+>\|ptr\);
    |
      return@p3 ...;
    )
    }
    )
    
    @ script:python @
    p1 << r.p1;
    p3 << r.p3;
    @@
    
    print "* file: %s snd_card_new: %s return: %s" % (p1[0].file,p1[0].line,p3[0].line)
    
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 0e06c6c9fcc0..58621206a2b3 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1024,7 +1024,7 @@ static int __devinit pcxhr_create(struct pcxhr_mgr *mgr, struct snd_card *card,
 		.dev_free = pcxhr_chip_dev_free,
 	};
 
-	mgr->chip[idx] = chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
 	if (! chip) {
 		snd_printk(KERN_ERR "cannot allocate chip\n");
 		return -ENOMEM;
@@ -1050,6 +1050,7 @@ static int __devinit pcxhr_create(struct pcxhr_mgr *mgr, struct snd_card *card,
 		return err;
 	}
 
+	mgr->chip[idx] = chip;
 	snd_card_set_dev(card, &mgr->pci->dev);
 
 	return 0;
@@ -1307,6 +1308,7 @@ static int __devinit pcxhr_probe(struct pci_dev *pci, const struct pci_device_id
 		sprintf(card->longname, "%s [PCM #%d]", mgr->longname, i);
 
 		if ((err = pcxhr_create(mgr, card, i)) < 0) {
+			snd_card_free(card);
 			pcxhr_free(mgr);
 			return err;
 		}

commit 9d948d270010e3552c94281bab75694580ca23e9
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Tue Nov 25 12:24:54 2008 +0100

    ALSA: pcxhr - add support for pcxhr stereo sound cards (core change)
    
    - Add support for pcxhr stereo cards
    - minor bugfixes : period and buffer size consraints
    - fix PLL register values
    - do some clean up
    
    Signed-off-by: Markus Bollinger <bollinger@digigram.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 73de6e989b3d..0327925828d1 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -40,18 +40,20 @@
 #include "pcxhr_mixer.h"
 #include "pcxhr_hwdep.h"
 #include "pcxhr_core.h"
+#include "pcxhr_mix22.h"
 
 #define DRIVER_NAME "pcxhr"
 
-MODULE_AUTHOR("Markus Bollinger <bollinger@digigram.com>");
+MODULE_AUTHOR("Markus Bollinger <bollinger@digigram.com>, "
+	      "Marc Titinger <titinger@digigram.com>");
 MODULE_DESCRIPTION("Digigram " DRIVER_NAME " " PCXHR_DRIVER_VERSION_STRING);
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{Digigram," DRIVER_NAME "}}");
 
-static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;		/* Index 0-MAX */
-static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;		/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
-static int mono[SNDRV_CARDS];					/* capture in mono only */
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */
+static int mono[SNDRV_CARDS];				/* capture  mono only */
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for Digigram " DRIVER_NAME " soundcard");
@@ -67,18 +69,58 @@ enum {
 	PCI_ID_PCX882HR,
 	PCI_ID_VX881HR,
 	PCI_ID_PCX881HR,
+	PCI_ID_VX882E,
+	PCI_ID_PCX882E,
+	PCI_ID_VX881E,
+	PCI_ID_PCX881E,
+	PCI_ID_VX1222HR,
 	PCI_ID_PCX1222HR,
+	PCI_ID_VX1221HR,
 	PCI_ID_PCX1221HR,
+	PCI_ID_VX1222E,
+	PCI_ID_PCX1222E,
+	PCI_ID_VX1221E,
+	PCI_ID_PCX1221E,
+	PCI_ID_VX222HR,
+	PCI_ID_VX222E,
+	PCI_ID_PCX22HR,
+	PCI_ID_PCX22E,
+	PCI_ID_VX222HRMIC,
+	PCI_ID_VX222E_MIC,
+	PCI_ID_PCX924HR,
+	PCI_ID_PCX924E,
+	PCI_ID_PCX924HRMIC,
+	PCI_ID_PCX924E_MIC,
 	PCI_ID_LAST
 };
 
 static struct pci_device_id pcxhr_ids[] = {
-	{ 0x10b5, 0x9656, 0x1369, 0xb001, 0, 0, PCI_ID_VX882HR, },   /* VX882HR */
-	{ 0x10b5, 0x9656, 0x1369, 0xb101, 0, 0, PCI_ID_PCX882HR, },  /* PCX882HR */
-	{ 0x10b5, 0x9656, 0x1369, 0xb201, 0, 0, PCI_ID_VX881HR, },   /* VX881HR */
-	{ 0x10b5, 0x9656, 0x1369, 0xb301, 0, 0, PCI_ID_PCX881HR, },  /* PCX881HR */
-	{ 0x10b5, 0x9656, 0x1369, 0xb501, 0, 0, PCI_ID_PCX1222HR, }, /* PCX1222HR */
-	{ 0x10b5, 0x9656, 0x1369, 0xb701, 0, 0, PCI_ID_PCX1221HR, }, /* PCX1221HR */
+	{ 0x10b5, 0x9656, 0x1369, 0xb001, 0, 0, PCI_ID_VX882HR, },
+	{ 0x10b5, 0x9656, 0x1369, 0xb101, 0, 0, PCI_ID_PCX882HR, },
+	{ 0x10b5, 0x9656, 0x1369, 0xb201, 0, 0, PCI_ID_VX881HR, },
+	{ 0x10b5, 0x9656, 0x1369, 0xb301, 0, 0, PCI_ID_PCX881HR, },
+	{ 0x10b5, 0x9056, 0x1369, 0xb021, 0, 0, PCI_ID_VX882E, },
+	{ 0x10b5, 0x9056, 0x1369, 0xb121, 0, 0, PCI_ID_PCX882E, },
+	{ 0x10b5, 0x9056, 0x1369, 0xb221, 0, 0, PCI_ID_VX881E, },
+	{ 0x10b5, 0x9056, 0x1369, 0xb321, 0, 0, PCI_ID_PCX881E, },
+	{ 0x10b5, 0x9656, 0x1369, 0xb401, 0, 0, PCI_ID_VX1222HR, },
+	{ 0x10b5, 0x9656, 0x1369, 0xb501, 0, 0, PCI_ID_PCX1222HR, },
+	{ 0x10b5, 0x9656, 0x1369, 0xb601, 0, 0, PCI_ID_VX1221HR, },
+	{ 0x10b5, 0x9656, 0x1369, 0xb701, 0, 0, PCI_ID_PCX1221HR, },
+	{ 0x10b5, 0x9056, 0x1369, 0xb421, 0, 0, PCI_ID_VX1222E, },
+	{ 0x10b5, 0x9056, 0x1369, 0xb521, 0, 0, PCI_ID_PCX1222E, },
+	{ 0x10b5, 0x9056, 0x1369, 0xb621, 0, 0, PCI_ID_VX1221E, },
+	{ 0x10b5, 0x9056, 0x1369, 0xb721, 0, 0, PCI_ID_PCX1221E, },
+	{ 0x10b5, 0x9056, 0x1369, 0xba01, 0, 0, PCI_ID_VX222HR, },
+	{ 0x10b5, 0x9056, 0x1369, 0xba21, 0, 0, PCI_ID_VX222E, },
+	{ 0x10b5, 0x9056, 0x1369, 0xbd01, 0, 0, PCI_ID_PCX22HR, },
+	{ 0x10b5, 0x9056, 0x1369, 0xbd21, 0, 0, PCI_ID_PCX22E, },
+	{ 0x10b5, 0x9056, 0x1369, 0xbc01, 0, 0, PCI_ID_VX222HRMIC, },
+	{ 0x10b5, 0x9056, 0x1369, 0xbc21, 0, 0, PCI_ID_VX222E_MIC, },
+	{ 0x10b5, 0x9056, 0x1369, 0xbb01, 0, 0, PCI_ID_PCX924HR, },
+	{ 0x10b5, 0x9056, 0x1369, 0xbb21, 0, 0, PCI_ID_PCX924E, },
+	{ 0x10b5, 0x9056, 0x1369, 0xbf01, 0, 0, PCI_ID_PCX924HRMIC, },
+	{ 0x10b5, 0x9056, 0x1369, 0xbf21, 0, 0, PCI_ID_PCX924E_MIC, },
 	{ 0, }
 };
 
@@ -88,27 +130,55 @@ struct board_parameters {
 	char* board_name;
 	short playback_chips;
 	short capture_chips;
+	short fw_file_set;
 	short firmware_num;
 };
 static struct board_parameters pcxhr_board_params[] = {
-[PCI_ID_VX882HR] =	{ "VX882HR",   4, 4, 41, },
-[PCI_ID_PCX882HR] =	{ "PCX882HR",  4, 4, 41, },
-[PCI_ID_VX881HR] =	{ "VX881HR",   4, 4, 41, },
-[PCI_ID_PCX881HR] =	{ "PCX881HR",  4, 4, 41, },
-[PCI_ID_PCX1222HR] =	{ "PCX1222HR", 6, 1, 42, },
-[PCI_ID_PCX1221HR] =	{ "PCX1221HR", 6, 1, 42, },
+[PCI_ID_VX882HR] =      { "VX882HR",      4, 4, 0, 41 },
+[PCI_ID_PCX882HR] =     { "PCX882HR",     4, 4, 0, 41 },
+[PCI_ID_VX881HR] =      { "VX881HR",      4, 4, 0, 41 },
+[PCI_ID_PCX881HR] =     { "PCX881HR",     4, 4, 0, 41 },
+[PCI_ID_VX882E] =       { "VX882e",       4, 4, 1, 41 },
+[PCI_ID_PCX882E] =      { "PCX882e",      4, 4, 1, 41 },
+[PCI_ID_VX881E] =       { "VX881e",       4, 4, 1, 41 },
+[PCI_ID_PCX881E] =      { "PCX881e",      4, 4, 1, 41 },
+[PCI_ID_VX1222HR] =     { "VX1222HR",     6, 1, 2, 42 },
+[PCI_ID_PCX1222HR] =    { "PCX1222HR",    6, 1, 2, 42 },
+[PCI_ID_VX1221HR] =     { "VX1221HR",     6, 1, 2, 42 },
+[PCI_ID_PCX1221HR] =    { "PCX1221HR",    6, 1, 2, 42 },
+[PCI_ID_VX1222E] =      { "VX1222e",      6, 1, 3, 42 },
+[PCI_ID_PCX1222E] =     { "PCX1222e",     6, 1, 3, 42 },
+[PCI_ID_VX1221E] =      { "VX1221e",      6, 1, 3, 42 },
+[PCI_ID_PCX1221E] =     { "PCX1221e",     6, 1, 3, 42 },
+[PCI_ID_VX222HR] =      { "VX222HR",      1, 1, 4, 44 },
+[PCI_ID_VX222E] =       { "VX222e",       1, 1, 4, 44 },
+[PCI_ID_PCX22HR] =      { "PCX22HR",      1, 0, 4, 44 },
+[PCI_ID_PCX22E] =       { "PCX22e",       1, 0, 4, 44 },
+[PCI_ID_VX222HRMIC] =   { "VX222HR-Mic",  1, 1, 5, 44 },
+[PCI_ID_VX222E_MIC] =   { "VX222e-Mic",   1, 1, 5, 44 },
+[PCI_ID_PCX924HR] =     { "PCX924HR",     1, 1, 5, 44 },
+[PCI_ID_PCX924E] =      { "PCX924e",      1, 1, 5, 44 },
+[PCI_ID_PCX924HRMIC] =  { "PCX924HR-Mic", 1, 1, 5, 44 },
+[PCI_ID_PCX924E_MIC] =  { "PCX924e-Mic",  1, 1, 5, 44 },
 };
 
+/* boards without hw AES1 and SRC onboard are all using fw_file_set==4 */
+/* VX222HR, VX222e, PCX22HR and PCX22e */
+#define PCXHR_BOARD_HAS_AES1(x) (x->fw_file_set != 4)
+/* some boards do not support 192kHz on digital AES input plugs */
+#define PCXHR_BOARD_AESIN_NO_192K(x) ((x->capture_chips == 0) || \
+				      (x->fw_file_set == 0)   || \
+				      (x->fw_file_set == 2))
 
 static int pcxhr_pll_freq_register(unsigned int freq, unsigned int* pllreg,
 				   unsigned int* realfreq)
 {
 	unsigned int reg;
 
-	if (freq < 6900 || freq > 110250)
+	if (freq < 6900 || freq > 110000)
 		return -EINVAL;
-	reg = (28224000 * 10) / freq;
-	reg = (reg + 5) / 10;
+	reg = (28224000 * 2) / freq;
+	reg = (reg - 1) / 2;
 	if (reg < 0x200)
 		*pllreg = reg + 0x800;
 	else if (reg < 0x400)
@@ -121,7 +191,7 @@ static int pcxhr_pll_freq_register(unsigned int freq, unsigned int* pllreg,
 		reg &= ~3;
 	}
 	if (realfreq)
-		*realfreq = ((28224000 * 10) / reg + 5) / 10;
+		*realfreq = (28224000 / (reg + 1));
 	return 0;
 }
 
@@ -151,11 +221,6 @@ static int pcxhr_pll_freq_register(unsigned int freq, unsigned int* pllreg,
 #define PCXHR_FREQ_AES_3		0x03
 #define PCXHR_FREQ_AES_4		0x0d
 
-#define PCXHR_MODIFY_CLOCK_S_BIT	0x04
-
-#define PCXHR_IRQ_TIMER_FREQ		92000
-#define PCXHR_IRQ_TIMER_PERIOD		48
-
 static int pcxhr_get_clock_reg(struct pcxhr_mgr *mgr, unsigned int rate,
 			       unsigned int *reg, unsigned int *freq)
 {
@@ -196,19 +261,32 @@ static int pcxhr_get_clock_reg(struct pcxhr_mgr *mgr, unsigned int rate,
 			err = pcxhr_send_msg(mgr, &rmh);
 			if (err < 0) {
 				snd_printk(KERN_ERR
-					   "error CMD_ACCESS_IO_WRITE for PLL register : %x!\n",
-					   err );
+					   "error CMD_ACCESS_IO_WRITE "
+					   "for PLL register : %x!\n", err);
 				return err;
 			}
 		}
 		break;
-	case PCXHR_CLOCK_TYPE_WORD_CLOCK :	val = PCXHR_FREQ_WORD_CLOCK;	break;
-	case PCXHR_CLOCK_TYPE_AES_SYNC :	val = PCXHR_FREQ_SYNC_AES;	break;
-	case PCXHR_CLOCK_TYPE_AES_1 :		val = PCXHR_FREQ_AES_1;		break;
-	case PCXHR_CLOCK_TYPE_AES_2 :		val = PCXHR_FREQ_AES_2;		break;
-	case PCXHR_CLOCK_TYPE_AES_3 :		val = PCXHR_FREQ_AES_3;		break;
-	case PCXHR_CLOCK_TYPE_AES_4 :		val = PCXHR_FREQ_AES_4;		break;
-	default : return -EINVAL;
+	case PCXHR_CLOCK_TYPE_WORD_CLOCK:
+		val = PCXHR_FREQ_WORD_CLOCK;
+		break;
+	case PCXHR_CLOCK_TYPE_AES_SYNC:
+		val = PCXHR_FREQ_SYNC_AES;
+		break;
+	case PCXHR_CLOCK_TYPE_AES_1:
+		val = PCXHR_FREQ_AES_1;
+		break;
+	case PCXHR_CLOCK_TYPE_AES_2:
+		val = PCXHR_FREQ_AES_2;
+		break;
+	case PCXHR_CLOCK_TYPE_AES_3:
+		val = PCXHR_FREQ_AES_3;
+		break;
+	case PCXHR_CLOCK_TYPE_AES_4:
+		val = PCXHR_FREQ_AES_4;
+		break;
+	default:
+		return -EINVAL;
 	}
 	*reg = val;
 	*freq = realfreq;
@@ -216,14 +294,13 @@ static int pcxhr_get_clock_reg(struct pcxhr_mgr *mgr, unsigned int rate,
 }
 
 
-int pcxhr_set_clock(struct pcxhr_mgr *mgr, unsigned int rate)
+static int pcxhr_sub_set_clock(struct pcxhr_mgr *mgr,
+			       unsigned int rate,
+			       int *changed)
 {
 	unsigned int val, realfreq, speed;
 	struct pcxhr_rmh rmh;
-	int err, changed;
-
-	if (rate == 0)
-		return 0; /* nothing to do */
+	int err;
 
 	err = pcxhr_get_clock_reg(mgr, rate, &val, &realfreq);
 	if (err)
@@ -237,13 +314,17 @@ int pcxhr_set_clock(struct pcxhr_mgr *mgr, unsigned int rate)
 	else
 		speed = 2;	/* quad speed */
 	if (mgr->codec_speed != speed) {
-		pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);	/* mute outputs */
+		pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE); /* mute outputs */
 		rmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;
+		if (DSP_EXT_CMD_SET(mgr)) {
+			rmh.cmd[1]  = 1;
+			rmh.cmd_len = 2;
+		}
 		err = pcxhr_send_msg(mgr, &rmh);
 		if (err)
 			return err;
 
-		pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);	/* set speed ratio */
+		pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE); /* set speed ratio */
 		rmh.cmd[0] |= IO_NUM_SPEED_RATIO;
 		rmh.cmd[1] = speed;
 		rmh.cmd_len = 2;
@@ -253,25 +334,57 @@ int pcxhr_set_clock(struct pcxhr_mgr *mgr, unsigned int rate)
 	}
 	/* set the new frequency */
 	snd_printdd("clock register : set %x\n", val);
-	err = pcxhr_write_io_num_reg_cont(mgr, PCXHR_FREQ_REG_MASK, val, &changed);
+	err = pcxhr_write_io_num_reg_cont(mgr, PCXHR_FREQ_REG_MASK,
+					  val, changed);
 	if (err)
 		return err;
+
 	mgr->sample_rate_real = realfreq;
 	mgr->cur_clock_type = mgr->use_clock_type;
 
 	/* unmute after codec speed modes */
 	if (mgr->codec_speed != speed) {
-		pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);	/* unmute outputs */
+		pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ); /* unmute outputs */
 		rmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;
+		if (DSP_EXT_CMD_SET(mgr)) {
+			rmh.cmd[1]  = 1;
+			rmh.cmd_len = 2;
+		}
 		err = pcxhr_send_msg(mgr, &rmh);
 		if (err)
 			return err;
-		mgr->codec_speed = speed;			/* save new codec speed */
+		mgr->codec_speed = speed;	/* save new codec speed */
 	}
 
+	snd_printdd("pcxhr_sub_set_clock to %dHz (realfreq=%d)\n",
+		    rate, realfreq);
+	return 0;
+}
+
+#define PCXHR_MODIFY_CLOCK_S_BIT	0x04
+
+#define PCXHR_IRQ_TIMER_FREQ		92000
+#define PCXHR_IRQ_TIMER_PERIOD		48
+
+int pcxhr_set_clock(struct pcxhr_mgr *mgr, unsigned int rate)
+{
+	struct pcxhr_rmh rmh;
+	int err, changed;
+
+	if (rate == 0)
+		return 0; /* nothing to do */
+
+	if (mgr->is_hr_stereo)
+		err = hr222_sub_set_clock(mgr, rate, &changed);
+	else
+		err = pcxhr_sub_set_clock(mgr, rate, &changed);
+
+	if (err)
+		return err;
+
 	if (changed) {
 		pcxhr_init_rmh(&rmh, CMD_MODIFY_CLOCK);
-		rmh.cmd[0] |= PCXHR_MODIFY_CLOCK_S_BIT;		/* resync fifos  */
+		rmh.cmd[0] |= PCXHR_MODIFY_CLOCK_S_BIT; /* resync fifos  */
 		if (rate < PCXHR_IRQ_TIMER_FREQ)
 			rmh.cmd[1] = PCXHR_IRQ_TIMER_PERIOD;
 		else
@@ -282,26 +395,39 @@ int pcxhr_set_clock(struct pcxhr_mgr *mgr, unsigned int rate)
 		if (err)
 			return err;
 	}
-	snd_printdd("pcxhr_set_clock to %dHz (realfreq=%d)\n", rate, realfreq);
 	return 0;
 }
 
 
-int pcxhr_get_external_clock(struct pcxhr_mgr *mgr, enum pcxhr_clock_type clock_type,
-			     int *sample_rate)
+static int pcxhr_sub_get_external_clock(struct pcxhr_mgr *mgr,
+					enum pcxhr_clock_type clock_type,
+					int *sample_rate)
 {
 	struct pcxhr_rmh rmh;
 	unsigned char reg;
 	int err, rate;
 
 	switch (clock_type) {
-	case PCXHR_CLOCK_TYPE_WORD_CLOCK :	reg = REG_STATUS_WORD_CLOCK;	break;
-	case PCXHR_CLOCK_TYPE_AES_SYNC :	reg = REG_STATUS_AES_SYNC;	break;
-	case PCXHR_CLOCK_TYPE_AES_1 :		reg = REG_STATUS_AES_1;		break;
-	case PCXHR_CLOCK_TYPE_AES_2 :		reg = REG_STATUS_AES_2;		break;
-	case PCXHR_CLOCK_TYPE_AES_3 :		reg = REG_STATUS_AES_3;		break;
-	case PCXHR_CLOCK_TYPE_AES_4 :		reg = REG_STATUS_AES_4;		break;
-	default : return -EINVAL;
+	case PCXHR_CLOCK_TYPE_WORD_CLOCK:
+		reg = REG_STATUS_WORD_CLOCK;
+		break;
+	case PCXHR_CLOCK_TYPE_AES_SYNC:
+		reg = REG_STATUS_AES_SYNC;
+		break;
+	case PCXHR_CLOCK_TYPE_AES_1:
+		reg = REG_STATUS_AES_1;
+		break;
+	case PCXHR_CLOCK_TYPE_AES_2:
+		reg = REG_STATUS_AES_2;
+		break;
+	case PCXHR_CLOCK_TYPE_AES_3:
+		reg = REG_STATUS_AES_3;
+		break;
+	case PCXHR_CLOCK_TYPE_AES_4:
+		reg = REG_STATUS_AES_4;
+		break;
+	default:
+		return -EINVAL;
 	}
 	pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);
 	rmh.cmd_len = 2;
@@ -311,7 +437,7 @@ int pcxhr_get_external_clock(struct pcxhr_mgr *mgr, enum pcxhr_clock_type clock_
 		err = pcxhr_send_msg(mgr, &rmh);
 		if (err)
 			return err;
-		udelay(100);		/* wait minimum 2 sample_frames at 32kHz ! */
+		udelay(100);	/* wait minimum 2 sample_frames at 32kHz ! */
 		mgr->last_reg_stat = reg;
 	}
 	rmh.cmd[1]  = REG_STATUS_CURRENT;
@@ -336,6 +462,18 @@ int pcxhr_get_external_clock(struct pcxhr_mgr *mgr, enum pcxhr_clock_type clock_
 }
 
 
+int pcxhr_get_external_clock(struct pcxhr_mgr *mgr,
+			     enum pcxhr_clock_type clock_type,
+			     int *sample_rate)
+{
+	if (mgr->is_hr_stereo)
+		return hr222_get_external_clock(mgr, clock_type,
+						sample_rate);
+	else
+		return pcxhr_sub_get_external_clock(mgr, clock_type,
+						    sample_rate);
+}
+
 /*
  *  start or stop playback/capture substream
  */
@@ -350,7 +488,8 @@ static int pcxhr_set_stream_state(struct pcxhr_stream *stream)
 		start = 1;
 	else {
 		if (stream->status != PCXHR_STREAM_STATUS_SCHEDULE_STOP) {
-			snd_printk(KERN_ERR "ERROR pcxhr_set_stream_state CANNOT be stopped\n");
+			snd_printk(KERN_ERR "ERROR pcxhr_set_stream_state "
+				   "CANNOT be stopped\n");
 			return -EINVAL;
 		}
 		start = 0;
@@ -359,11 +498,12 @@ static int pcxhr_set_stream_state(struct pcxhr_stream *stream)
 		return -EINVAL;
 
 	stream->timer_abs_periods = 0;
-	stream->timer_period_frag = 0;            /* reset theoretical stream pos */
+	stream->timer_period_frag = 0;	/* reset theoretical stream pos */
 	stream->timer_buf_periods = 0;
 	stream->timer_is_synced = 0;
 
-	stream_mask = stream->pipe->is_capture ? 1 : 1<<stream->substream->number;
+	stream_mask =
+	  stream->pipe->is_capture ? 1 : 1<<stream->substream->number;
 
 	pcxhr_init_rmh(&rmh, start ? CMD_START_STREAM : CMD_STOP_STREAM);
 	pcxhr_set_pipe_cmd_params(&rmh, stream->pipe->is_capture,
@@ -373,8 +513,10 @@ static int pcxhr_set_stream_state(struct pcxhr_stream *stream)
 
 	err = pcxhr_send_msg(chip->mgr, &rmh);
 	if (err)
-		snd_printk(KERN_ERR "ERROR pcxhr_set_stream_state err=%x;\n", err);
-	stream->status = start ? PCXHR_STREAM_STATUS_STARTED : PCXHR_STREAM_STATUS_STOPPED;
+		snd_printk(KERN_ERR "ERROR pcxhr_set_stream_state err=%x;\n",
+			   err);
+	stream->status =
+	  start ? PCXHR_STREAM_STATUS_STARTED : PCXHR_STREAM_STATUS_STOPPED;
 	return err;
 }
 
@@ -399,13 +541,15 @@ static int pcxhr_set_format(struct pcxhr_stream *stream)
 		header = HEADER_FMT_BASE_LIN;
 		break;
 	case SNDRV_PCM_FORMAT_S16_LE:
-		header = HEADER_FMT_BASE_LIN | HEADER_FMT_16BITS | HEADER_FMT_INTEL;
+		header = HEADER_FMT_BASE_LIN |
+			 HEADER_FMT_16BITS | HEADER_FMT_INTEL;
 		break;
 	case SNDRV_PCM_FORMAT_S16_BE:
 		header = HEADER_FMT_BASE_LIN | HEADER_FMT_16BITS;
 		break;
 	case SNDRV_PCM_FORMAT_S24_3LE:
-		header = HEADER_FMT_BASE_LIN | HEADER_FMT_24BITS | HEADER_FMT_INTEL;
+		header = HEADER_FMT_BASE_LIN |
+			 HEADER_FMT_24BITS | HEADER_FMT_INTEL;
 		break;
 	case SNDRV_PCM_FORMAT_S24_3BE:
 		header = HEADER_FMT_BASE_LIN | HEADER_FMT_24BITS;
@@ -414,7 +558,8 @@ static int pcxhr_set_format(struct pcxhr_stream *stream)
 		header = HEADER_FMT_BASE_FLOAT | HEADER_FMT_INTEL;
 		break;
 	default:
-		snd_printk(KERN_ERR "error pcxhr_set_format() : unknown format\n");
+		snd_printk(KERN_ERR
+			   "error pcxhr_set_format() : unknown format\n");
 		return -EINVAL;
 	}
 	chip = snd_pcm_substream_chip(stream->substream);
@@ -432,14 +577,31 @@ static int pcxhr_set_format(struct pcxhr_stream *stream)
 	is_capture = stream->pipe->is_capture;
 	stream_num = is_capture ? 0 : stream->substream->number;
 
-	pcxhr_init_rmh(&rmh, is_capture ? CMD_FORMAT_STREAM_IN : CMD_FORMAT_STREAM_OUT);
-	pcxhr_set_pipe_cmd_params(&rmh, is_capture, stream->pipe->first_audio, stream_num, 0);
-	if (is_capture)
-		rmh.cmd[0] |= 1<<12;
+	pcxhr_init_rmh(&rmh, is_capture ?
+		       CMD_FORMAT_STREAM_IN : CMD_FORMAT_STREAM_OUT);
+	pcxhr_set_pipe_cmd_params(&rmh, is_capture, stream->pipe->first_audio,
+				  stream_num, 0);
+	if (is_capture) {
+		/* bug with old dsp versions: */
+		/* bit 12 also sets the format of the playback stream */
+		if (DSP_EXT_CMD_SET(chip->mgr))
+			rmh.cmd[0] |= 1<<10;
+		else
+			rmh.cmd[0] |= 1<<12;
+	}
 	rmh.cmd[1] = 0;
-	rmh.cmd[2] = header >> 8;
-	rmh.cmd[3] = (header & 0xff) << 16;
-	rmh.cmd_len = 4;
+	rmh.cmd_len = 2;
+	if (DSP_EXT_CMD_SET(chip->mgr)) {
+		/* add channels and set bit 19 if channels>2 */
+		rmh.cmd[1] = stream->channels;
+		if (!is_capture) {
+			/* playback : add channel mask to command */
+			rmh.cmd[2] = (stream->channels == 1) ? 0x01 : 0x03;
+			rmh.cmd_len = 3;
+		}
+	}
+	rmh.cmd[rmh.cmd_len++] = header >> 8;
+	rmh.cmd[rmh.cmd_len++] = (header & 0xff) << 16;
 	err = pcxhr_send_msg(chip->mgr, &rmh);
 	if (err)
 		snd_printk(KERN_ERR "ERROR pcxhr_set_format err=%x;\n", err);
@@ -456,30 +618,38 @@ static int pcxhr_update_r_buffer(struct pcxhr_stream *stream)
 	is_capture = (subs->stream == SNDRV_PCM_STREAM_CAPTURE);
 	stream_num = is_capture ? 0 : subs->number;
 
-	snd_printdd("pcxhr_update_r_buffer(pcm%c%d) : addr(%p) bytes(%zx) subs(%d)\n",
+	snd_printdd("pcxhr_update_r_buffer(pcm%c%d) : "
+		    "addr(%p) bytes(%zx) subs(%d)\n",
 		    is_capture ? 'c' : 'p',
 		    chip->chip_idx, (void *)(long)subs->runtime->dma_addr,
 		    subs->runtime->dma_bytes, subs->number);
 
 	pcxhr_init_rmh(&rmh, CMD_UPDATE_R_BUFFERS);
-	pcxhr_set_pipe_cmd_params(&rmh, is_capture, stream->pipe->first_audio, stream_num, 0);
+	pcxhr_set_pipe_cmd_params(&rmh, is_capture, stream->pipe->first_audio,
+				  stream_num, 0);
 
 	/* max buffer size is 2 MByte */
 	snd_BUG_ON(subs->runtime->dma_bytes >= 0x200000);
-	rmh.cmd[1] = subs->runtime->dma_bytes * 8;		/* size in bits */
-	rmh.cmd[2] = subs->runtime->dma_addr >> 24;		/* most significant byte */
-	rmh.cmd[2] |= 1<<19;					/* this is a circular buffer */
-	rmh.cmd[3] = subs->runtime->dma_addr & MASK_DSP_WORD;	/* least 3 significant bytes */
+	/* size in bits */
+	rmh.cmd[1] = subs->runtime->dma_bytes * 8;
+	/* most significant byte */
+	rmh.cmd[2] = subs->runtime->dma_addr >> 24;
+	/* this is a circular buffer */
+	rmh.cmd[2] |= 1<<19;
+	/* least 3 significant bytes */
+	rmh.cmd[3] = subs->runtime->dma_addr & MASK_DSP_WORD;
 	rmh.cmd_len = 4;
 	err = pcxhr_send_msg(chip->mgr, &rmh);
 	if (err)
-		snd_printk(KERN_ERR "ERROR CMD_UPDATE_R_BUFFERS err=%x;\n", err);
+		snd_printk(KERN_ERR
+			   "ERROR CMD_UPDATE_R_BUFFERS err=%x;\n", err);
 	return err;
 }
 
 
 #if 0
-static int pcxhr_pipe_sample_count(struct pcxhr_stream *stream, snd_pcm_uframes_t *sample_count)
+static int pcxhr_pipe_sample_count(struct pcxhr_stream *stream,
+				   snd_pcm_uframes_t *sample_count)
 {
 	struct pcxhr_rmh rmh;
 	int err;
@@ -533,8 +703,8 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 		for (j = 0; j < chip->nb_streams_play; j++) {
 			if (pcxhr_stream_scheduled_get_pipe(&chip->playback_stream[j], &pipe)) {
 				playback_mask |= (1 << pipe->first_audio);
-				break;	/* add only once, as all playback streams of
-					 * one chip use the same pipe
+				break;	/* add only once, as all playback
+					 * streams of one chip use the same pipe
 					 */
 			}
 		}
@@ -545,19 +715,21 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 		return;
 	}
 
-	snd_printdd("pcxhr_trigger_tasklet : playback_mask=%x capture_mask=%x\n",
+	snd_printdd("pcxhr_trigger_tasklet : "
+		    "playback_mask=%x capture_mask=%x\n",
 		    playback_mask, capture_mask);
 
 	/* synchronous stop of all the pipes concerned */
 	err = pcxhr_set_pipe_state(mgr,  playback_mask, capture_mask, 0);
 	if (err) {
 		mutex_unlock(&mgr->setup_mutex);
-		snd_printk(KERN_ERR "pcxhr_trigger_tasklet : error stop pipes (P%x C%x)\n",
+		snd_printk(KERN_ERR "pcxhr_trigger_tasklet : "
+			   "error stop pipes (P%x C%x)\n",
 			   playback_mask, capture_mask);
 		return;
 	}
 
-	/* unfortunately the dsp lost format and buffer info with the stop pipe */
+	/* the dsp lost format and buffer info with the stop pipe */
 	for (i = 0; i < mgr->num_cards; i++) {
 		struct pcxhr_stream *stream;
 		chip = mgr->chip[i];
@@ -596,12 +768,15 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 	err = pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 1);
 	if (err) {
 		mutex_unlock(&mgr->setup_mutex);
-		snd_printk(KERN_ERR "pcxhr_trigger_tasklet : error start pipes (P%x C%x)\n",
+		snd_printk(KERN_ERR "pcxhr_trigger_tasklet : "
+			   "error start pipes (P%x C%x)\n",
 			   playback_mask, capture_mask);
 		return;
 	}
 
-	/* put the streams into the running state now (increment pointer by interrupt) */
+	/* put the streams into the running state now
+	 * (increment pointer by interrupt)
+	 */
 	spin_lock_irqsave(&mgr->lock, flags);
 	for ( i =0; i < mgr->num_cards; i++) {
 		struct pcxhr_stream *stream;
@@ -615,7 +790,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 			stream = &chip->playback_stream[j];
 			if (stream->status == PCXHR_STREAM_STATUS_STARTED) {
 				/* playback will already have advanced ! */
-				stream->timer_period_frag += PCXHR_GRANULARITY;
+				stream->timer_period_frag += mgr->granularity;
 				stream->status = PCXHR_STREAM_STATUS_RUNNING;
 			}
 		}
@@ -697,12 +872,14 @@ static int pcxhr_hardware_timer(struct pcxhr_mgr *mgr, int start)
 
 	pcxhr_init_rmh(&rmh, CMD_SET_TIMER_INTERRUPT);
 	if (start) {
-		mgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;	/* last dsp time invalid */
-		rmh.cmd[0] |= PCXHR_GRANULARITY;
+		/* last dsp time invalid */
+		mgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;
+		rmh.cmd[0] |= mgr->granularity;
 	}
 	err = pcxhr_send_msg(mgr, &rmh);
 	if (err < 0)
-		snd_printk(KERN_ERR "error pcxhr_hardware_timer err(%x)\n", err);
+		snd_printk(KERN_ERR "error pcxhr_hardware_timer err(%x)\n",
+			   err);
 	return err;
 }
 
@@ -713,38 +890,16 @@ static int pcxhr_prepare(struct snd_pcm_substream *subs)
 {
 	struct snd_pcxhr *chip = snd_pcm_substream_chip(subs);
 	struct pcxhr_mgr *mgr = chip->mgr;
-	/*
-	struct pcxhr_stream *stream = (pcxhr_stream_t*)subs->runtime->private_data;
-	*/
 	int err = 0;
 
 	snd_printdd("pcxhr_prepare : period_size(%lx) periods(%x) buffer_size(%lx)\n",
 		    subs->runtime->period_size, subs->runtime->periods,
 		    subs->runtime->buffer_size);
 
-	/*
-	if(subs->runtime->period_size <= PCXHR_GRANULARITY) {
-		snd_printk(KERN_ERR "pcxhr_prepare : error period_size too small (%x)\n",
-			   (unsigned int)subs->runtime->period_size);
-		return -EINVAL;
-	}
-	*/
-
 	mutex_lock(&mgr->setup_mutex);
 
 	do {
-		/* if the stream was stopped before, format and buffer were reset */
-		/*
-		if(stream->status == PCXHR_STREAM_STATUS_STOPPED) {
-			err = pcxhr_set_format(stream);
-			if(err) break;
-			err = pcxhr_update_r_buffer(stream);
-			if(err) break;
-		}
-		*/
-
 		/* only the first stream can choose the sample rate */
-		/* the further opened streams will be limited to its frequency (see open) */
 		/* set the clock only once (first stream) */
 		if (mgr->sample_rate != subs->runtime->rate) {
 			err = pcxhr_set_clock(mgr, subs->runtime->rate);
@@ -787,22 +942,9 @@ static int pcxhr_hw_params(struct snd_pcm_substream *subs,
 	stream->channels = channels;
 	stream->format = format;
 
-	/* set the format to the board */
-	/*
-	err = pcxhr_set_format(stream);
-	if(err) {
-		mutex_unlock(&mgr->setup_mutex);
-		return err;
-	}
-	*/
 	/* allocate buffer */
 	err = snd_pcm_lib_malloc_pages(subs, params_buffer_bytes(hw));
 
-	/*
-	if (err > 0) {
-		err = pcxhr_update_r_buffer(stream);
-	}
-	*/
 	mutex_unlock(&mgr->setup_mutex);
 
 	return err;
@@ -820,14 +962,18 @@ static int pcxhr_hw_free(struct snd_pcm_substream *subs)
  */
 static struct snd_pcm_hardware pcxhr_caps =
 {
-	.info             = ( SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
-			      SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |
-			      0 /*SNDRV_PCM_INFO_PAUSE*/),
-	.formats	  = ( SNDRV_PCM_FMTBIT_U8 |
-			      SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE |
-			      SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_3BE |
-			      SNDRV_PCM_FMTBIT_FLOAT_LE ),
-	.rates            = SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_192000,
+	.info             = (SNDRV_PCM_INFO_MMAP |
+			     SNDRV_PCM_INFO_INTERLEAVED |
+			     SNDRV_PCM_INFO_MMAP_VALID |
+			     SNDRV_PCM_INFO_SYNC_START),
+	.formats	  = (SNDRV_PCM_FMTBIT_U8 |
+			     SNDRV_PCM_FMTBIT_S16_LE |
+			     SNDRV_PCM_FMTBIT_S16_BE |
+			     SNDRV_PCM_FMTBIT_S24_3LE |
+			     SNDRV_PCM_FMTBIT_S24_3BE |
+			     SNDRV_PCM_FMTBIT_FLOAT_LE),
+	.rates            = (SNDRV_PCM_RATE_CONTINUOUS |
+			     SNDRV_PCM_RATE_8000_192000),
 	.rate_min         = 8000,
 	.rate_max         = 192000,
 	.channels_min     = 1,
@@ -847,6 +993,7 @@ static int pcxhr_open(struct snd_pcm_substream *subs)
 	struct pcxhr_mgr       *mgr = chip->mgr;
 	struct snd_pcm_runtime *runtime = subs->runtime;
 	struct pcxhr_stream    *stream;
+	int err;
 
 	mutex_lock(&mgr->setup_mutex);
 
@@ -874,6 +1021,18 @@ static int pcxhr_open(struct snd_pcm_substream *subs)
 		return -EBUSY;
 	}
 
+	/* float format support is in some cases buggy on stereo cards */
+	if (mgr->is_hr_stereo)
+		runtime->hw.formats &= ~SNDRV_PCM_FMTBIT_FLOAT_LE;
+
+	/* buffer-size should better be multiple of period-size */
+	err = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (err < 0) {
+		mutex_unlock(&mgr->setup_mutex);
+		return err;
+	}
+
 	/* if a sample rate is already used or fixed by external clock,
 	 * the stream cannot change
 	 */
@@ -889,7 +1048,8 @@ static int pcxhr_open(struct snd_pcm_substream *subs)
 				mutex_unlock(&mgr->setup_mutex);
 				return -EBUSY;
 			}
-			runtime->hw.rate_min = runtime->hw.rate_max = external_rate;
+			runtime->hw.rate_min = external_rate;
+			runtime->hw.rate_max = external_rate;
 		}
 	}
 
@@ -899,9 +1059,11 @@ static int pcxhr_open(struct snd_pcm_substream *subs)
 
 	runtime->private_data = stream;
 
-	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 4);
-	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 4);
-
+	/* better get a divisor of granularity values (96 or 192) */
+	snd_pcm_hw_constraint_step(runtime, 0,
+				   SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 32);
+	snd_pcm_hw_constraint_step(runtime, 0,
+				   SNDRV_PCM_HW_PARAM_PERIOD_SIZE, 32);
 	snd_pcm_set_sync(subs);
 
 	mgr->ref_count_rate++;
@@ -919,11 +1081,12 @@ static int pcxhr_close(struct snd_pcm_substream *subs)
 
 	mutex_lock(&mgr->setup_mutex);
 
-	snd_printdd("pcxhr_close chip%d subs%d\n", chip->chip_idx, subs->number);
+	snd_printdd("pcxhr_close chip%d subs%d\n",
+		    chip->chip_idx, subs->number);
 
 	/* sample rate released */
 	if (--mgr->ref_count_rate == 0) {
-		mgr->sample_rate = 0;		/* the sample rate is no more locked */
+		mgr->sample_rate = 0;	/* the sample rate is no more locked */
 		pcxhr_hardware_timer(mgr, 0);	/* stop the DSP-timer */
 	}
 
@@ -1016,7 +1179,8 @@ static int pcxhr_chip_dev_free(struct snd_device *device)
 
 /*
  */
-static int __devinit pcxhr_create(struct pcxhr_mgr *mgr, struct snd_card *card, int idx)
+static int __devinit pcxhr_create(struct pcxhr_mgr *mgr,
+				  struct snd_card *card, int idx)
 {
 	int err;
 	struct snd_pcxhr *chip;
@@ -1040,7 +1204,7 @@ static int __devinit pcxhr_create(struct pcxhr_mgr *mgr, struct snd_card *card,
 
 	if (idx < mgr->capture_chips) {
 		if (mgr->mono_capture)
-			chip->nb_streams_capt = 2;	/* 2 mono streams (left+right) */
+			chip->nb_streams_capt = 2;	/* 2 mono streams */
 		else
 			chip->nb_streams_capt = 1;	/* or 1 stereo stream */
 	}
@@ -1056,7 +1220,8 @@ static int __devinit pcxhr_create(struct pcxhr_mgr *mgr, struct snd_card *card,
 }
 
 /* proc interface */
-static void pcxhr_proc_info(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
+static void pcxhr_proc_info(struct snd_info_entry *entry,
+			    struct snd_info_buffer *buffer)
 {
 	struct snd_pcxhr *chip = entry->private_data;
 	struct pcxhr_mgr *mgr = chip->mgr;
@@ -1069,8 +1234,10 @@ static void pcxhr_proc_info(struct snd_info_entry *entry, struct snd_info_buffer
 		short ver_maj = (mgr->dsp_version >> 16) & 0xff;
 		short ver_min = (mgr->dsp_version >> 8) & 0xff;
 		short ver_build = mgr->dsp_version & 0xff;
-		snd_iprintf(buffer, "module version %s\n", PCXHR_DRIVER_VERSION_STRING);
-		snd_iprintf(buffer, "dsp version %d.%d.%d\n", ver_maj, ver_min, ver_build);
+		snd_iprintf(buffer, "module version %s\n",
+			    PCXHR_DRIVER_VERSION_STRING);
+		snd_iprintf(buffer, "dsp version %d.%d.%d\n",
+			    ver_maj, ver_min, ver_build);
 		if (mgr->board_has_analog)
 			snd_iprintf(buffer, "analog io available\n");
 		else
@@ -1084,18 +1251,22 @@ static void pcxhr_proc_info(struct snd_info_entry *entry, struct snd_info_buffer
 			if (ref > 0) {
 				if (mgr->sample_rate_real != 0 &&
 				    mgr->sample_rate_real != 48000) {
-					ref = (ref * 48000) / mgr->sample_rate_real;
-					if (mgr->sample_rate_real >= PCXHR_IRQ_TIMER_FREQ)
+					ref = (ref * 48000) /
+					  mgr->sample_rate_real;
+					if (mgr->sample_rate_real >=
+					    PCXHR_IRQ_TIMER_FREQ)
 						ref *= 2;
 				}
 				cur = 100 - (100 * cur) / ref;
 				snd_iprintf(buffer, "cpu load    %d%%\n", cur);
-				snd_iprintf(buffer, "buffer pool %d/%d kWords\n",
+				snd_iprintf(buffer, "buffer pool %d/%d\n",
 					    rmh.stat[2], rmh.stat[3]);
 			}
 		}
-		snd_iprintf(buffer, "dma granularity : %d\n", PCXHR_GRANULARITY);
-		snd_iprintf(buffer, "dsp time errors : %d\n", mgr->dsp_time_err);
+		snd_iprintf(buffer, "dma granularity : %d\n",
+			    mgr->granularity);
+		snd_iprintf(buffer, "dsp time errors : %d\n",
+			    mgr->dsp_time_err);
 		snd_iprintf(buffer, "dsp async pipe xrun errors : %d\n",
 			    mgr->async_err_pipe_xrun);
 		snd_iprintf(buffer, "dsp async stream xrun errors : %d\n",
@@ -1110,33 +1281,52 @@ static void pcxhr_proc_info(struct snd_info_entry *entry, struct snd_info_buffer
 		rmh.cmd_idx = CMD_LAST_INDEX;
 		if( ! pcxhr_send_msg(mgr, &rmh) ) {
 			int i;
+			if (rmh.stat_len > 8)
+				rmh.stat_len = 8;
 			for (i = 0; i < rmh.stat_len; i++)
-				snd_iprintf(buffer, "debug[%02d] = %06x\n", i,  rmh.stat[i]);
+				snd_iprintf(buffer, "debug[%02d] = %06x\n",
+					    i,  rmh.stat[i]);
 		}
 	} else
 		snd_iprintf(buffer, "no firmware loaded\n");
 	snd_iprintf(buffer, "\n");
 }
-static void pcxhr_proc_sync(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
+static void pcxhr_proc_sync(struct snd_info_entry *entry,
+			    struct snd_info_buffer *buffer)
 {
 	struct snd_pcxhr *chip = entry->private_data;
 	struct pcxhr_mgr *mgr = chip->mgr;
-	static char *texts[7] = {
-		"Internal", "Word", "AES Sync", "AES 1", "AES 2", "AES 3", "AES 4"
+	static const char *textsHR22[3] = {
+		"Internal", "AES Sync", "AES 1"
+	};
+	static const char *textsPCXHR[7] = {
+		"Internal", "Word", "AES Sync",
+		"AES 1", "AES 2", "AES 3", "AES 4"
 	};
+	const char **texts;
+	int max_clock;
+	if (mgr->is_hr_stereo) {
+		texts = textsHR22;
+		max_clock = HR22_CLOCK_TYPE_MAX;
+	} else {
+		texts = textsPCXHR;
+		max_clock = PCXHR_CLOCK_TYPE_MAX;
+	}
 
 	snd_iprintf(buffer, "\n%s\n", mgr->longname);
-	snd_iprintf(buffer, "Current Sample Clock\t: %s\n", texts[mgr->cur_clock_type]);
-	snd_iprintf(buffer, "Current Sample Rate\t= %d\n", mgr->sample_rate_real);
-
+	snd_iprintf(buffer, "Current Sample Clock\t: %s\n",
+		    texts[mgr->cur_clock_type]);
+	snd_iprintf(buffer, "Current Sample Rate\t= %d\n",
+		    mgr->sample_rate_real);
 	/* commands available when embedded DSP is running */
 	if (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {
 		int i, err, sample_rate;
-		for (i = PCXHR_CLOCK_TYPE_WORD_CLOCK; i< (3 + mgr->capture_chips); i++) {
+		for (i = 1; i <= max_clock; i++) {
 			err = pcxhr_get_external_clock(mgr, i, &sample_rate);
 			if (err)
 				break;
-			snd_iprintf(buffer, "%s Clock\t\t= %d\n", texts[i], sample_rate);
+			snd_iprintf(buffer, "%s Clock\t\t= %d\n",
+				    texts[i], sample_rate);
 		}
 	} else
 		snd_iprintf(buffer, "no firmware loaded\n");
@@ -1194,7 +1384,8 @@ static int pcxhr_free(struct pcxhr_mgr *mgr)
 /*
  *    probe function - creates the card manager
  */
-static int __devinit pcxhr_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
+static int __devinit pcxhr_probe(struct pci_dev *pci,
+				 const struct pci_device_id *pci_id)
 {
 	static int dev;
 	struct pcxhr_mgr *mgr;
@@ -1217,7 +1408,8 @@ static int __devinit pcxhr_probe(struct pci_dev *pci, const struct pci_device_id
 
 	/* check if we can restrict PCI DMA transfers to 32 bits */
 	if (pci_set_dma_mask(pci, DMA_32BIT_MASK) < 0) {
-		snd_printk(KERN_ERR "architecture does not support 32bit PCI busmaster DMA\n");
+		snd_printk(KERN_ERR "architecture does not support "
+			   "32bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;
 	}
@@ -1234,11 +1426,25 @@ static int __devinit pcxhr_probe(struct pci_dev *pci, const struct pci_device_id
 		pci_disable_device(pci);
 		return -ENODEV;
 	}
-	card_name = pcxhr_board_params[pci_id->driver_data].board_name;
-	mgr->playback_chips = pcxhr_board_params[pci_id->driver_data].playback_chips;
-	mgr->capture_chips  = pcxhr_board_params[pci_id->driver_data].capture_chips;
-	mgr->firmware_num  = pcxhr_board_params[pci_id->driver_data].firmware_num;
+	card_name =
+		pcxhr_board_params[pci_id->driver_data].board_name;
+	mgr->playback_chips =
+		pcxhr_board_params[pci_id->driver_data].playback_chips;
+	mgr->capture_chips  =
+		pcxhr_board_params[pci_id->driver_data].capture_chips;
+	mgr->fw_file_set =
+		pcxhr_board_params[pci_id->driver_data].fw_file_set;
+	mgr->firmware_num  =
+		pcxhr_board_params[pci_id->driver_data].firmware_num;
 	mgr->mono_capture = mono[dev];
+	mgr->is_hr_stereo = (mgr->playback_chips == 1);
+	mgr->board_has_aes1 = PCXHR_BOARD_HAS_AES1(mgr);
+	mgr->board_aes_in_192k = !PCXHR_BOARD_AESIN_NO_192K(mgr);
+
+	if (mgr->is_hr_stereo)
+		mgr->granularity = PCXHR_GRANULARITY_HR22;
+	else
+		mgr->granularity = PCXHR_GRANULARITY;
 
 	/* resource assignment */
 	if ((err = pci_request_regions(pci, card_name)) < 0) {
@@ -1261,7 +1467,8 @@ static int __devinit pcxhr_probe(struct pci_dev *pci, const struct pci_device_id
 	mgr->irq = pci->irq;
 
 	sprintf(mgr->shortname, "Digigram %s", card_name);
-	sprintf(mgr->longname, "%s at 0x%lx & 0x%lx, 0x%lx irq %i", mgr->shortname,
+	sprintf(mgr->longname, "%s at 0x%lx & 0x%lx, 0x%lx irq %i",
+		mgr->shortname,
 		mgr->port[0], mgr->port[1], mgr->port[2], mgr->irq);
 
 	/* ISR spinlock  */
@@ -1272,10 +1479,14 @@ static int __devinit pcxhr_probe(struct pci_dev *pci, const struct pci_device_id
 	mutex_init(&mgr->setup_mutex);
 
 	/* init taslket */
-	tasklet_init(&mgr->msg_taskq, pcxhr_msg_tasklet, (unsigned long) mgr);
-	tasklet_init(&mgr->trigger_taskq, pcxhr_trigger_tasklet, (unsigned long) mgr);
+	tasklet_init(&mgr->msg_taskq, pcxhr_msg_tasklet,
+		     (unsigned long) mgr);
+	tasklet_init(&mgr->trigger_taskq, pcxhr_trigger_tasklet,
+		     (unsigned long) mgr);
+
 	mgr->prmh = kmalloc(sizeof(*mgr->prmh) + 
-			    sizeof(u32) * (PCXHR_SIZE_MAX_LONG_STATUS - PCXHR_SIZE_MAX_STATUS),
+			    sizeof(u32) * (PCXHR_SIZE_MAX_LONG_STATUS -
+					   PCXHR_SIZE_MAX_STATUS),
 			    GFP_KERNEL);
 	if (! mgr->prmh) {
 		pcxhr_free(mgr);
@@ -1296,7 +1507,8 @@ static int __devinit pcxhr_probe(struct pci_dev *pci, const struct pci_device_id
 		else
 			idx = index[dev] + i;
 
-		snprintf(tmpid, sizeof(tmpid), "%s-%d", id[dev] ? id[dev] : card_name, i);
+		snprintf(tmpid, sizeof(tmpid), "%s-%d",
+			 id[dev] ? id[dev] : card_name, i);
 		card = snd_card_new(idx, tmpid, THIS_MODULE, 0);
 
 		if (! card) {

commit d6f35e3f0da14a5eb02114708d88ae2f59dc8283
Author: Julia Lawall <julia@diku.dk>
Date:   Fri Nov 14 19:08:18 2008 +0100

    ALSA: sound/pci/pcxhr/pcxhr.c: introduce missing kfree and pci_disable_device
    
    Error handling code following a kzalloc should free the allocated data.
    The error handling code is adjusted to call pci_disable_device(pci); as
    well, as done later in the function
    
    The semantic match that finds the problem is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @r exists@
    local idexpression x;
    statement S;
    expression E;
    identifier f,l;
    position p1,p2;
    expression *ptr != NULL;
    @@
    
    (
    if ((x@p1 = \(kmalloc\|kzalloc\|kcalloc\)(...)) == NULL) S
    |
    x@p1 = \(kmalloc\|kzalloc\|kcalloc\)(...);
    ...
    if (x == NULL) S
    )
    <... when != x
         when != if (...) { <+...x...+> }
    x->f = E
    ...>
    (
     return \(0\|<+...x...+>\|ptr\);
    |
     return@p2 ...;
    )
    
    @script:python@
    p1 << r.p1;
    p2 << r.p2;
    @@
    
    print "* file: %s kmalloc %s return %s" % (p1[0].file,p1[0].line,p2[0].line)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 0e06c6c9fcc0..73de6e989b3d 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1229,8 +1229,11 @@ static int __devinit pcxhr_probe(struct pci_dev *pci, const struct pci_device_id
 		return -ENOMEM;
 	}
 
-	if (snd_BUG_ON(pci_id->driver_data >= PCI_ID_LAST))
+	if (snd_BUG_ON(pci_id->driver_data >= PCI_ID_LAST)) {
+		kfree(mgr);
+		pci_disable_device(pci);
 		return -ENODEV;
+	}
 	card_name = pcxhr_board_params[pci_id->driver_data].board_name;
 	mgr->playback_chips = pcxhr_board_params[pci_id->driver_data].playback_chips;
 	mgr->capture_chips  = pcxhr_board_params[pci_id->driver_data].capture_chips;

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 2c7e25336795..0e06c6c9fcc0 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -464,7 +464,8 @@ static int pcxhr_update_r_buffer(struct pcxhr_stream *stream)
 	pcxhr_init_rmh(&rmh, CMD_UPDATE_R_BUFFERS);
 	pcxhr_set_pipe_cmd_params(&rmh, is_capture, stream->pipe->first_audio, stream_num, 0);
 
-	snd_assert(subs->runtime->dma_bytes < 0x200000);	/* max buffer size is 2 MByte */
+	/* max buffer size is 2 MByte */
+	snd_BUG_ON(subs->runtime->dma_bytes >= 0x200000);
 	rmh.cmd[1] = subs->runtime->dma_bytes * 8;		/* size in bits */
 	rmh.cmd[2] = subs->runtime->dma_addr >> 24;		/* most significant byte */
 	rmh.cmd[2] |= 1<<19;					/* this is a circular buffer */
@@ -1228,7 +1229,8 @@ static int __devinit pcxhr_probe(struct pci_dev *pci, const struct pci_device_id
 		return -ENOMEM;
 	}
 
-	snd_assert(pci_id->driver_data < PCI_ID_LAST, return -ENODEV);
+	if (snd_BUG_ON(pci_id->driver_data >= PCI_ID_LAST))
+		return -ENODEV;
 	card_name = pcxhr_board_params[pci_id->driver_data].board_name;
 	mgr->playback_chips = pcxhr_board_params[pci_id->driver_data].playback_chips;
 	mgr->capture_chips  = pcxhr_board_params[pci_id->driver_data].capture_chips;

commit 62cf872a8eec1f11aacbec0ac3fe3698bfa9b403
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 20 12:15:15 2008 +0200

    [ALSA] Replace CONFIG_SND_DEBUG_DETECT with CONFIG_SND_DEBUG_VERBOSE
    
    Replace CONFIG_SND_DEBUG_DETECT with CONFIG_SND_DEBUG_VERBOSE to
    represent its meaning more better.  This config isn't provided only
    for the detection but for more verbose debug prints in general.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 7fdcdc8c6b64..2c7e25336795 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -516,7 +516,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 	int capture_mask = 0;
 	int playback_mask = 0;
 
-#ifdef CONFIG_SND_DEBUG_DETECT
+#ifdef CONFIG_SND_DEBUG_VERBOSE
 	struct timeval my_tv1, my_tv2;
 	do_gettimeofday(&my_tv1);
 #endif
@@ -623,7 +623,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 
 	mutex_unlock(&mgr->setup_mutex);
 
-#ifdef CONFIG_SND_DEBUG_DETECT
+#ifdef CONFIG_SND_DEBUG_VERBOSE
 	do_gettimeofday(&my_tv2);
 	snd_printdd("***TRIGGER TASKLET*** TIME = %ld (err = %x)\n",
 		    (long)(my_tv2.tv_usec - my_tv1.tv_usec), err);

commit ff73317ea7c648cf5f59b8bda4a810f7b5d0312c
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Thu Mar 20 12:07:31 2008 +0100

    [ALSA] sound/pci/pcxhr/pcxhr.c: fix warnings
    
    sparc64:
    
    sound/pci/pcxhr/pcxhr.c: In function `pcxhr_update_r_buffer':
    sound/pci/pcxhr/pcxhr.c:459: warning: cast to pointer from integer of different size
    sound/pci/pcxhr/pcxhr.c: In function `pcxhr_trigger_tasklet':
    sound/pci/pcxhr/pcxhr.c:628: warning: long int format, different type arg (arg 4)
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index beed5818338c..7fdcdc8c6b64 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -458,7 +458,7 @@ static int pcxhr_update_r_buffer(struct pcxhr_stream *stream)
 
 	snd_printdd("pcxhr_update_r_buffer(pcm%c%d) : addr(%p) bytes(%zx) subs(%d)\n",
 		    is_capture ? 'c' : 'p',
-		    chip->chip_idx, (void*)subs->runtime->dma_addr,
+		    chip->chip_idx, (void *)(long)subs->runtime->dma_addr,
 		    subs->runtime->dma_bytes, subs->number);
 
 	pcxhr_init_rmh(&rmh, CMD_UPDATE_R_BUFFERS);
@@ -626,7 +626,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 #ifdef CONFIG_SND_DEBUG_DETECT
 	do_gettimeofday(&my_tv2);
 	snd_printdd("***TRIGGER TASKLET*** TIME = %ld (err = %x)\n",
-		    my_tv2.tv_usec - my_tv1.tv_usec, err);
+		    (long)(my_tv2.tv_usec - my_tv1.tv_usec), err);
 #endif
 }
 

commit b32300a4ce78b4df92f33c455ffe644b36f0ff1a
Author: Julia Lawall <julia@diku.dk>
Date:   Mon Mar 17 10:23:35 2008 +0100

    [ALSA] sound/pci: remove unused variable
    
    The variable is_capture is initialized but never used otherwise.
    
    The semantic patch that makes this change is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @@
    type T;
    identifier i;
    constant C;
    @@
    
    (
    extern T i;
    |
    - T i;
      <+... when != i
    - i = C;
      ...+>
    )
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 9d5bb76229a8..beed5818338c 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -846,7 +846,6 @@ static int pcxhr_open(struct snd_pcm_substream *subs)
 	struct pcxhr_mgr       *mgr = chip->mgr;
 	struct snd_pcm_runtime *runtime = subs->runtime;
 	struct pcxhr_stream    *stream;
-	int                 is_capture;
 
 	mutex_lock(&mgr->setup_mutex);
 
@@ -856,12 +855,10 @@ static int pcxhr_open(struct snd_pcm_substream *subs)
 	if( subs->stream == SNDRV_PCM_STREAM_PLAYBACK ) {
 		snd_printdd("pcxhr_open playback chip%d subs%d\n",
 			    chip->chip_idx, subs->number);
-		is_capture = 0;
 		stream = &chip->playback_stream[subs->number];
 	} else {
 		snd_printdd("pcxhr_open capture chip%d subs%d\n",
 			    chip->chip_idx, subs->number);
-		is_capture = 1;
 		if (mgr->mono_capture)
 			runtime->hw.channels_max = 1;
 		else

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 2d618bd7e62b..9d5bb76229a8 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -21,7 +21,6 @@
  */
 
 
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>

commit 768d8c7df886fc5cc9d6057cc987ef8e52d197b5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Sep 11 21:28:50 2007 +0200

    [ALSA] pcxhr - Fix trigger start with non-linked streams
    
    The non-linked streams couldn't be started properly due to missing
    setting of stream->status.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index cd4613a97bd7..2d618bd7e62b 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -664,6 +664,7 @@ static int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)
 			if (pcxhr_update_r_buffer(stream))
 				return -EINVAL;
 
+			stream->status = PCXHR_STREAM_STATUS_SCHEDULE_RUN;
 			if (pcxhr_set_stream_state(stream))
 				return -EINVAL;
 			stream->status = PCXHR_STREAM_STATUS_RUNNING;

commit b83f346bc4d6ab358fd0da85b7eab08bf0234c0b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 13 17:37:55 2007 +0200

    [ALSA] remove incorrect usage of SNDRV_PCM_INFO_SYNC_START and snd_pcm_set_sync()
    
    Set the SNDRV_PCM_INFO_SYNC_START flag and the substream's sync ID
    (only) if the substream actually can be linked to another one.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 1b787f455576..cd4613a97bd7 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -904,6 +904,8 @@ static int pcxhr_open(struct snd_pcm_substream *subs)
 	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 4);
 	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 4);
 
+	snd_pcm_set_sync(subs);
+
 	mgr->ref_count_rate++;
 
 	mutex_unlock(&mgr->setup_mutex);

commit 29998d24ab5ec488cd127488246cc749b0ac52d6
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jul 30 08:14:31 2007 +0200

    [ALSA] check for linked substreams of different cards
    
    It is possible to have linked substreams that belong to different cards
    and/or different drivers.  This patch changes some drivers to make sure
    that they do not incorrectly try to handle substreams of a different
    card.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index f7f6a687f033..1b787f455576 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -646,6 +646,8 @@ static int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)
 		if (snd_pcm_stream_linked(subs)) {
 			struct snd_pcxhr *chip = snd_pcm_substream_chip(subs);
 			snd_pcm_group_for_each_entry(s, subs) {
+				if (snd_pcm_substream_chip(s) != chip)
+					continue;
 				stream = s->runtime->private_data;
 				stream->status =
 					PCXHR_STREAM_STATUS_SCHEDULE_RUN;

commit b07a14a549589e23be40f6b344df9512ba462e3f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 28 17:19:29 2007 +0200

    [ALSA] pcxhr - Minor optimization in trigger callback
    
    Minor optimization in trigger start callback.  This fixes a nasty
    compile warning, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index e1bdeed3a465..f7f6a687f033 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -639,19 +639,21 @@ static int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)
 {
 	struct pcxhr_stream *stream;
 	struct snd_pcm_substream *s;
-	int i;
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 		snd_printdd("SNDRV_PCM_TRIGGER_START\n");
-		i = 0;
-		snd_pcm_group_for_each_entry(s, subs) {
-			stream = s->runtime->private_data;
-			stream->status = PCXHR_STREAM_STATUS_SCHEDULE_RUN;
-			snd_pcm_trigger_done(s, subs);
-			i++;
-		}
-		if (i==1) {
+		if (snd_pcm_stream_linked(subs)) {
+			struct snd_pcxhr *chip = snd_pcm_substream_chip(subs);
+			snd_pcm_group_for_each_entry(s, subs) {
+				stream = s->runtime->private_data;
+				stream->status =
+					PCXHR_STREAM_STATUS_SCHEDULE_RUN;
+				snd_pcm_trigger_done(s, subs);
+			}
+			tasklet_hi_schedule(&chip->mgr->trigger_taskq);
+		} else {
+			stream = subs->runtime->private_data;
 			snd_printdd("Only one Substream %c %d\n",
 				    stream->pipe->is_capture ? 'C' : 'P',
 				    stream->pipe->first_audio);
@@ -663,9 +665,6 @@ static int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)
 			if (pcxhr_set_stream_state(stream))
 				return -EINVAL;
 			stream->status = PCXHR_STREAM_STATUS_RUNNING;
-		} else {
-			struct snd_pcxhr *chip = snd_pcm_substream_chip(subs);
-			tasklet_hi_schedule(&chip->mgr->trigger_taskq);
 		}
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:

commit ef991b95aa1351a5782cfaccb9aefba76ca8b990
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 22 12:52:53 2007 +0100

    [ALSA] Add snd_pcm_group_for_each_entry() for code cleanup
    
    Added a new macro snd_pcm_group_for_each_entry() just for code cleanup.
    Old macros, snd_pcm_group_for_each() and snd_pcm_group_substream_entry(),
    are removed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index d97413484ae9..e1bdeed3a465 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -638,7 +638,6 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 static int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)
 {
 	struct pcxhr_stream *stream;
-	struct list_head *pos;
 	struct snd_pcm_substream *s;
 	int i;
 
@@ -646,8 +645,7 @@ static int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)
 	case SNDRV_PCM_TRIGGER_START:
 		snd_printdd("SNDRV_PCM_TRIGGER_START\n");
 		i = 0;
-		snd_pcm_group_for_each(pos, subs) {
-			s = snd_pcm_group_substream_entry(pos);
+		snd_pcm_group_for_each_entry(s, subs) {
 			stream = s->runtime->private_data;
 			stream->status = PCXHR_STREAM_STATUS_SCHEDULE_RUN;
 			snd_pcm_trigger_done(s, subs);
@@ -672,8 +670,7 @@ static int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 		snd_printdd("SNDRV_PCM_TRIGGER_STOP\n");
-		snd_pcm_group_for_each(pos, subs) {
-			s = snd_pcm_group_substream_entry(pos);
+		snd_pcm_group_for_each_entry(s, subs) {
 			stream = s->runtime->private_data;
 			stream->status = PCXHR_STREAM_STATUS_SCHEDULE_STOP;
 			if (pcxhr_set_stream_state(stream))

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 533c672ae8f3..d97413484ae9 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1250,7 +1250,7 @@ static int __devinit pcxhr_probe(struct pci_dev *pci, const struct pci_device_id
 	mgr->pci = pci;
 	mgr->irq = -1;
 
-	if (request_irq(pci->irq, pcxhr_interrupt, IRQF_DISABLED|IRQF_SHARED,
+	if (request_irq(pci->irq, pcxhr_interrupt, IRQF_SHARED,
 			card_name, mgr)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		pcxhr_free(mgr);

commit f40b68903ccd511ea9d658b4bce319dd032a265a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 16:51:05 2006 +0200

    [ALSA] Fix section mismatch errors in ALSA PCI drivers
    
    Fixed 'section mismatch' errors in ALSA PCI drivers:
    - removed invalid __devinitdata from pci id tables
    - fix/remove __devinit of functions called in suspend/resume
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index ae980e11827f..533c672ae8f3 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -73,7 +73,7 @@ enum {
 	PCI_ID_LAST
 };
 
-static struct pci_device_id pcxhr_ids[] __devinitdata = {
+static struct pci_device_id pcxhr_ids[] = {
 	{ 0x10b5, 0x9656, 0x1369, 0xb001, 0, 0, PCI_ID_VX882HR, },   /* VX882HR */
 	{ 0x10b5, 0x9656, 0x1369, 0xb101, 0, 0, PCI_ID_PCX882HR, },  /* PCX882HR */
 	{ 0x10b5, 0x9656, 0x1369, 0xb201, 0, 0, PCI_ID_VX881HR, },   /* VX881HR */

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 8198884b51ee..ae980e11827f 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1250,7 +1250,7 @@ static int __devinit pcxhr_probe(struct pci_dev *pci, const struct pci_device_id
 	mgr->pci = pci;
 	mgr->irq = -1;
 
-	if (request_irq(pci->irq, pcxhr_interrupt, SA_INTERRUPT|SA_SHIRQ,
+	if (request_irq(pci->irq, pcxhr_interrupt, IRQF_DISABLED|IRQF_SHARED,
 			card_name, mgr)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		pcxhr_free(mgr);

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index dafa2235abaa..8198884b51ee 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -1150,9 +1150,9 @@ static void __devinit pcxhr_proc_init(struct snd_pcxhr *chip)
 	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(chip->card, "info", &entry))
-		snd_info_set_text_ops(entry, chip, 1024, pcxhr_proc_info);
+		snd_info_set_text_ops(entry, chip, pcxhr_proc_info);
 	if (! snd_card_proc_new(chip->card, "sync", &entry))
-		snd_info_set_text_ops(entry, chip, 1024, pcxhr_proc_sync);
+		snd_info_set_text_ops(entry, chip, pcxhr_proc_sync);
 }
 /* end of proc interface */
 

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index f679779d96e3..dafa2235abaa 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -73,7 +73,7 @@ enum {
 	PCI_ID_LAST
 };
 
-static struct pci_device_id pcxhr_ids[] = {
+static struct pci_device_id pcxhr_ids[] __devinitdata = {
 	{ 0x10b5, 0x9656, 0x1369, 0xb001, 0, 0, PCI_ID_VX882HR, },   /* VX882HR */
 	{ 0x10b5, 0x9656, 0x1369, 0xb101, 0, 0, PCI_ID_PCX882HR, },  /* PCX882HR */
 	{ 0x10b5, 0x9656, 0x1369, 0xb201, 0, 0, PCI_ID_VX881HR, },   /* VX881HR */

commit 1d606f1ae5b9d83d8749f21bc04842596104bf55
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Apr 18 13:37:08 2006 +0200

    [ALSA] sound/pci/: remove duplicate #include's
    
    There's no reason for #include'ing linux/dma-mapping.h more than once.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 35875c8aa299..f679779d96e3 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -30,7 +30,6 @@
 #include <linux/delay.h>
 #include <linux/moduleparam.h>
 #include <linux/mutex.h>
-#include <linux/dma-mapping.h>
 
 #include <sound/core.h>
 #include <sound/initval.h>

commit 910638ae7ed4be27d6af55f6c9b5bf54b838e78b
Author: Matthias Gehre <M.Gehre@gmx.de>
Date:   Tue Mar 28 01:56:48 2006 -0800

    [PATCH] Replace 0xff.. with correct DMA_xBIT_MASK
    
    Replace all occurences of 0xff..  in calls to function pci_set_dma_mask()
    and pci_set_consistant_dma_mask() with the corresponding DMA_xBIT_MASK from
    linux/dma-mapping.h.
    
    Signed-off-by: Matthias Gehre <M.Gehre@gmx.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index f679779d96e3..35875c8aa299 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -30,6 +30,7 @@
 #include <linux/delay.h>
 #include <linux/moduleparam.h>
 #include <linux/mutex.h>
+#include <linux/dma-mapping.h>
 
 #include <sound/core.h>
 #include <sound/initval.h>

commit 9d2f928ddf64ca0361562e30faf584cd33055c60
Author: Tobias Klauser <tklauser@nuerscht.ch>
Date:   Wed Mar 22 10:53:19 2006 +0100

    [PATCH] Intruduce DMA_28BIT_MASK
    
    This patch introduces the DMA_28BIT_MASK constant in dma-mapping.h
    ALSA drivers using this mask are changed to use the new constant.
    
    Signed-off-by: Tobias Klauser <tklauser@nuerscht.ch>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 31a3e8e1b234..f679779d96e3 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -26,6 +26,7 @@
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/pci.h>
+#include <linux/dma-mapping.h>
 #include <linux/delay.h>
 #include <linux/moduleparam.h>
 #include <linux/mutex.h>
@@ -1217,7 +1218,7 @@ static int __devinit pcxhr_probe(struct pci_dev *pci, const struct pci_device_id
 	pci_set_master(pci);
 
 	/* check if we can restrict PCI DMA transfers to 32 bits */
-	if (pci_set_dma_mask(pci, 0xffffffff) < 0) {
+	if (pci_set_dma_mask(pci, DMA_32BIT_MASK) < 0) {
 		snd_printk(KERN_ERR "architecture does not support 32bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;

commit 62932df8fb20ba2fb53a95fa52445eba22e821fe
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:34:20 2006 +0100

    [ALSA] semaphore -> mutex (PCI part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index b2cba75b6b16..31a3e8e1b234 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -28,6 +28,8 @@
 #include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/moduleparam.h>
+#include <linux/mutex.h>
+
 #include <sound/core.h>
 #include <sound/initval.h>
 #include <sound/info.h>
@@ -518,7 +520,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 	struct timeval my_tv1, my_tv2;
 	do_gettimeofday(&my_tv1);
 #endif
-	down(&mgr->setup_mutex);
+	mutex_lock(&mgr->setup_mutex);
 
 	/* check the pipes concerned and build pipe_array */
 	for (i = 0; i < mgr->num_cards; i++) {
@@ -537,7 +539,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 		}
 	}
 	if (capture_mask == 0 && playback_mask == 0) {
-		up(&mgr->setup_mutex);
+		mutex_unlock(&mgr->setup_mutex);
 		snd_printk(KERN_ERR "pcxhr_trigger_tasklet : no pipes\n");
 		return;
 	}
@@ -548,7 +550,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 	/* synchronous stop of all the pipes concerned */
 	err = pcxhr_set_pipe_state(mgr,  playback_mask, capture_mask, 0);
 	if (err) {
-		up(&mgr->setup_mutex);
+		mutex_unlock(&mgr->setup_mutex);
 		snd_printk(KERN_ERR "pcxhr_trigger_tasklet : error stop pipes (P%x C%x)\n",
 			   playback_mask, capture_mask);
 		return;
@@ -592,7 +594,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 	/* synchronous start of all the pipes concerned */
 	err = pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 1);
 	if (err) {
-		up(&mgr->setup_mutex);
+		mutex_unlock(&mgr->setup_mutex);
 		snd_printk(KERN_ERR "pcxhr_trigger_tasklet : error start pipes (P%x C%x)\n",
 			   playback_mask, capture_mask);
 		return;
@@ -619,7 +621,7 @@ static void pcxhr_trigger_tasklet(unsigned long arg)
 	}
 	spin_unlock_irqrestore(&mgr->lock, flags);
 
-	up(&mgr->setup_mutex);
+	mutex_unlock(&mgr->setup_mutex);
 
 #ifdef CONFIG_SND_DEBUG_DETECT
 	do_gettimeofday(&my_tv2);
@@ -728,7 +730,7 @@ static int pcxhr_prepare(struct snd_pcm_substream *subs)
 	}
 	*/
 
-	down(&mgr->setup_mutex);
+	mutex_lock(&mgr->setup_mutex);
 
 	do {
 		/* if the stream was stopped before, format and buffer were reset */
@@ -755,7 +757,7 @@ static int pcxhr_prepare(struct snd_pcm_substream *subs)
 		}
 	} while(0);	/* do only once (so we can use break instead of goto) */
 
-	up(&mgr->setup_mutex);
+	mutex_unlock(&mgr->setup_mutex);
 
 	return err;
 }
@@ -780,7 +782,7 @@ static int pcxhr_hw_params(struct snd_pcm_substream *subs,
 	/*  set up format for the stream */
 	format = params_format(hw);
 
-	down(&mgr->setup_mutex);
+	mutex_lock(&mgr->setup_mutex);
 
 	stream->channels = channels;
 	stream->format = format;
@@ -789,7 +791,7 @@ static int pcxhr_hw_params(struct snd_pcm_substream *subs,
 	/*
 	err = pcxhr_set_format(stream);
 	if(err) {
-		up(&mgr->setup_mutex);
+		mutex_unlock(&mgr->setup_mutex);
 		return err;
 	}
 	*/
@@ -801,7 +803,7 @@ static int pcxhr_hw_params(struct snd_pcm_substream *subs,
 		err = pcxhr_update_r_buffer(stream);
 	}
 	*/
-	up(&mgr->setup_mutex);
+	mutex_unlock(&mgr->setup_mutex);
 
 	return err;
 }
@@ -847,7 +849,7 @@ static int pcxhr_open(struct snd_pcm_substream *subs)
 	struct pcxhr_stream    *stream;
 	int                 is_capture;
 
-	down(&mgr->setup_mutex);
+	mutex_lock(&mgr->setup_mutex);
 
 	/* copy the struct snd_pcm_hardware struct */
 	runtime->hw = pcxhr_caps;
@@ -871,7 +873,7 @@ static int pcxhr_open(struct snd_pcm_substream *subs)
 		/* streams in use */
 		snd_printk(KERN_ERR "pcxhr_open chip%d subs%d in use\n",
 			   chip->chip_idx, subs->number);
-		up(&mgr->setup_mutex);
+		mutex_unlock(&mgr->setup_mutex);
 		return -EBUSY;
 	}
 
@@ -887,7 +889,7 @@ static int pcxhr_open(struct snd_pcm_substream *subs)
 						     &external_rate) ||
 			    external_rate == 0) {
 				/* cannot detect the external clock rate */
-				up(&mgr->setup_mutex);
+				mutex_unlock(&mgr->setup_mutex);
 				return -EBUSY;
 			}
 			runtime->hw.rate_min = runtime->hw.rate_max = external_rate;
@@ -905,7 +907,7 @@ static int pcxhr_open(struct snd_pcm_substream *subs)
 
 	mgr->ref_count_rate++;
 
-	up(&mgr->setup_mutex);
+	mutex_unlock(&mgr->setup_mutex);
 	return 0;
 }
 
@@ -916,7 +918,7 @@ static int pcxhr_close(struct snd_pcm_substream *subs)
 	struct pcxhr_mgr *mgr = chip->mgr;
 	struct pcxhr_stream *stream = subs->runtime->private_data;
 
-	down(&mgr->setup_mutex);
+	mutex_lock(&mgr->setup_mutex);
 
 	snd_printdd("pcxhr_close chip%d subs%d\n", chip->chip_idx, subs->number);
 
@@ -929,7 +931,7 @@ static int pcxhr_close(struct snd_pcm_substream *subs)
 	stream->status    = PCXHR_STREAM_STATUS_FREE;
 	stream->substream = NULL;
 
-	up(&mgr->setup_mutex);
+	mutex_unlock(&mgr->setup_mutex);
 
 	return 0;
 }
@@ -1264,7 +1266,7 @@ static int __devinit pcxhr_probe(struct pci_dev *pci, const struct pci_device_id
 	spin_lock_init(&mgr->msg_lock);
 
 	/* init setup mutex*/
-	init_MUTEX(&mgr->setup_mutex);
+	mutex_init(&mgr->setup_mutex);
 
 	/* init taslket */
 	tasklet_init(&mgr->msg_taskq, pcxhr_msg_tasklet, (unsigned long) mgr);

commit 20cd22620ad3a8a57a942fa1f301d47a1e15d67e
Author: Andrew Morton <akpm@osdl.org>
Date:   Fri Jan 20 14:07:47 2006 +0100

    [ALSA] pcxhr - Fix printk warning
    
    Modules: Digigram PCXHR driver
    
    sound/pci/pcxhr/pcxhr.c: In function 'pcxhr_update_r_buffer':
    sound/pci/pcxhr/pcxhr.c:460: warning: unsigned int format, different type arg (arg 7)
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index 57fe9538f5a4..b2cba75b6b16 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -454,7 +454,7 @@ static int pcxhr_update_r_buffer(struct pcxhr_stream *stream)
 	is_capture = (subs->stream == SNDRV_PCM_STREAM_CAPTURE);
 	stream_num = is_capture ? 0 : subs->number;
 
-	snd_printdd("pcxhr_update_r_buffer(pcm%c%d) : addr(%p) bytes(%x) subs(%d)\n",
+	snd_printdd("pcxhr_update_r_buffer(pcm%c%d) : addr(%p) bytes(%zx) subs(%d)\n",
 		    is_capture ? 'c' : 'p',
 		    chip->chip_idx, (void*)subs->runtime->dma_addr,
 		    subs->runtime->dma_bytes, subs->number);

commit 8937fd88558d5a741d6ed29d5f8c327646a4f1db
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 10 11:14:49 2006 +0100

    [ALSA] pcxhr - Fix the sample rate changes
    
    Modules: Digigram PCXHR driver
    
    Fix the hardware set up when the sample rate is changed multiple times.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
index b8c0853a8278..57fe9538f5a4 100644
--- a/sound/pci/pcxhr/pcxhr.c
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -744,13 +744,14 @@ static int pcxhr_prepare(struct snd_pcm_substream *subs)
 		/* only the first stream can choose the sample rate */
 		/* the further opened streams will be limited to its frequency (see open) */
 		/* set the clock only once (first stream) */
-		if (mgr->sample_rate == 0) {
+		if (mgr->sample_rate != subs->runtime->rate) {
 			err = pcxhr_set_clock(mgr, subs->runtime->rate);
 			if (err)
 				break;
+			if (mgr->sample_rate == 0)
+				/* start the DSP-timer */
+				err = pcxhr_hardware_timer(mgr, 1);
 			mgr->sample_rate = subs->runtime->rate;
-
-			err = pcxhr_hardware_timer(mgr, 1);	/* start the DSP-timer */
 		}
 	} while(0);	/* do only once (so we can use break instead of goto) */
 

commit e12229b4d2b7863b1baaeca759aa87703bf9fdf8
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Tue Dec 6 13:55:26 2005 +0100

    [ALSA] Add PCXHR driver
    
    Modules: Documentation,PCI drivers,Digigram PCXHR driver
    
    Add Digigram PCXHR driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.c b/sound/pci/pcxhr/pcxhr.c
new file mode 100644
index 000000000000..b8c0853a8278
--- /dev/null
+++ b/sound/pci/pcxhr/pcxhr.c
@@ -0,0 +1,1367 @@
+/*
+ * Driver for Digigram pcxhr compatible soundcards
+ *
+ * main file with alsa callbacks
+ *
+ * Copyright (c) 2004 by Digigram <alsa@digigram.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/info.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include "pcxhr.h"
+#include "pcxhr_mixer.h"
+#include "pcxhr_hwdep.h"
+#include "pcxhr_core.h"
+
+#define DRIVER_NAME "pcxhr"
+
+MODULE_AUTHOR("Markus Bollinger <bollinger@digigram.com>");
+MODULE_DESCRIPTION("Digigram " DRIVER_NAME " " PCXHR_DRIVER_VERSION_STRING);
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{Digigram," DRIVER_NAME "}}");
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;		/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;		/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static int mono[SNDRV_CARDS];					/* capture in mono only */
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for Digigram " DRIVER_NAME " soundcard");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for Digigram " DRIVER_NAME " soundcard");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable Digigram " DRIVER_NAME " soundcard");
+module_param_array(mono, bool, NULL, 0444);
+MODULE_PARM_DESC(mono, "Mono capture mode (default is stereo)");
+
+enum {
+	PCI_ID_VX882HR,
+	PCI_ID_PCX882HR,
+	PCI_ID_VX881HR,
+	PCI_ID_PCX881HR,
+	PCI_ID_PCX1222HR,
+	PCI_ID_PCX1221HR,
+	PCI_ID_LAST
+};
+
+static struct pci_device_id pcxhr_ids[] = {
+	{ 0x10b5, 0x9656, 0x1369, 0xb001, 0, 0, PCI_ID_VX882HR, },   /* VX882HR */
+	{ 0x10b5, 0x9656, 0x1369, 0xb101, 0, 0, PCI_ID_PCX882HR, },  /* PCX882HR */
+	{ 0x10b5, 0x9656, 0x1369, 0xb201, 0, 0, PCI_ID_VX881HR, },   /* VX881HR */
+	{ 0x10b5, 0x9656, 0x1369, 0xb301, 0, 0, PCI_ID_PCX881HR, },  /* PCX881HR */
+	{ 0x10b5, 0x9656, 0x1369, 0xb501, 0, 0, PCI_ID_PCX1222HR, }, /* PCX1222HR */
+	{ 0x10b5, 0x9656, 0x1369, 0xb701, 0, 0, PCI_ID_PCX1221HR, }, /* PCX1221HR */
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, pcxhr_ids);
+
+struct board_parameters {
+	char* board_name;
+	short playback_chips;
+	short capture_chips;
+	short firmware_num;
+};
+static struct board_parameters pcxhr_board_params[] = {
+[PCI_ID_VX882HR] =	{ "VX882HR",   4, 4, 41, },
+[PCI_ID_PCX882HR] =	{ "PCX882HR",  4, 4, 41, },
+[PCI_ID_VX881HR] =	{ "VX881HR",   4, 4, 41, },
+[PCI_ID_PCX881HR] =	{ "PCX881HR",  4, 4, 41, },
+[PCI_ID_PCX1222HR] =	{ "PCX1222HR", 6, 1, 42, },
+[PCI_ID_PCX1221HR] =	{ "PCX1221HR", 6, 1, 42, },
+};
+
+
+static int pcxhr_pll_freq_register(unsigned int freq, unsigned int* pllreg,
+				   unsigned int* realfreq)
+{
+	unsigned int reg;
+
+	if (freq < 6900 || freq > 110250)
+		return -EINVAL;
+	reg = (28224000 * 10) / freq;
+	reg = (reg + 5) / 10;
+	if (reg < 0x200)
+		*pllreg = reg + 0x800;
+	else if (reg < 0x400)
+		*pllreg = reg & 0x1ff;
+	else if (reg < 0x800) {
+		*pllreg = ((reg >> 1) & 0x1ff) + 0x200;
+		reg &= ~1;
+	} else {
+		*pllreg = ((reg >> 2) & 0x1ff) + 0x400;
+		reg &= ~3;
+	}
+	if (realfreq)
+		*realfreq = ((28224000 * 10) / reg + 5) / 10;
+	return 0;
+}
+
+
+#define PCXHR_FREQ_REG_MASK		0x1f
+#define PCXHR_FREQ_QUARTZ_48000		0x00
+#define PCXHR_FREQ_QUARTZ_24000		0x01
+#define PCXHR_FREQ_QUARTZ_12000		0x09
+#define PCXHR_FREQ_QUARTZ_32000		0x08
+#define PCXHR_FREQ_QUARTZ_16000		0x04
+#define PCXHR_FREQ_QUARTZ_8000		0x0c
+#define PCXHR_FREQ_QUARTZ_44100		0x02
+#define PCXHR_FREQ_QUARTZ_22050		0x0a
+#define PCXHR_FREQ_QUARTZ_11025		0x06
+#define PCXHR_FREQ_PLL			0x05
+#define PCXHR_FREQ_QUARTZ_192000	0x10
+#define PCXHR_FREQ_QUARTZ_96000		0x18
+#define PCXHR_FREQ_QUARTZ_176400	0x14
+#define PCXHR_FREQ_QUARTZ_88200		0x1c
+#define PCXHR_FREQ_QUARTZ_128000	0x12
+#define PCXHR_FREQ_QUARTZ_64000		0x1a
+
+#define PCXHR_FREQ_WORD_CLOCK		0x0f
+#define PCXHR_FREQ_SYNC_AES		0x0e
+#define PCXHR_FREQ_AES_1		0x07
+#define PCXHR_FREQ_AES_2		0x0b
+#define PCXHR_FREQ_AES_3		0x03
+#define PCXHR_FREQ_AES_4		0x0d
+
+#define PCXHR_MODIFY_CLOCK_S_BIT	0x04
+
+#define PCXHR_IRQ_TIMER_FREQ		92000
+#define PCXHR_IRQ_TIMER_PERIOD		48
+
+static int pcxhr_get_clock_reg(struct pcxhr_mgr *mgr, unsigned int rate,
+			       unsigned int *reg, unsigned int *freq)
+{
+	unsigned int val, realfreq, pllreg;
+	struct pcxhr_rmh rmh;
+	int err;
+
+	realfreq = rate;
+	switch (mgr->use_clock_type) {
+	case PCXHR_CLOCK_TYPE_INTERNAL :	/* clock by quartz or pll */
+		switch (rate) {
+		case 48000 :	val = PCXHR_FREQ_QUARTZ_48000;	break;
+		case 24000 :	val = PCXHR_FREQ_QUARTZ_24000;	break;
+		case 12000 :	val = PCXHR_FREQ_QUARTZ_12000;	break;
+		case 32000 :	val = PCXHR_FREQ_QUARTZ_32000;	break;
+		case 16000 :	val = PCXHR_FREQ_QUARTZ_16000;	break;
+		case 8000 :	val = PCXHR_FREQ_QUARTZ_8000;	break;
+		case 44100 :	val = PCXHR_FREQ_QUARTZ_44100;	break;
+		case 22050 :	val = PCXHR_FREQ_QUARTZ_22050;	break;
+		case 11025 :	val = PCXHR_FREQ_QUARTZ_11025;	break;
+		case 192000 :	val = PCXHR_FREQ_QUARTZ_192000;	break;
+		case 96000 :	val = PCXHR_FREQ_QUARTZ_96000;	break;
+		case 176400 :	val = PCXHR_FREQ_QUARTZ_176400;	break;
+		case 88200 :	val = PCXHR_FREQ_QUARTZ_88200;	break;
+		case 128000 :	val = PCXHR_FREQ_QUARTZ_128000;	break;
+		case 64000 :	val = PCXHR_FREQ_QUARTZ_64000;	break;
+		default :
+			val = PCXHR_FREQ_PLL;
+			/* get the value for the pll register */
+			err = pcxhr_pll_freq_register(rate, &pllreg, &realfreq);
+			if (err)
+				return err;
+			pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);
+			rmh.cmd[0] |= IO_NUM_REG_GENCLK;
+			rmh.cmd[1]  = pllreg & MASK_DSP_WORD;
+			rmh.cmd[2]  = pllreg >> 24;
+			rmh.cmd_len = 3;
+			err = pcxhr_send_msg(mgr, &rmh);
+			if (err < 0) {
+				snd_printk(KERN_ERR
+					   "error CMD_ACCESS_IO_WRITE for PLL register : %x!\n",
+					   err );
+				return err;
+			}
+		}
+		break;
+	case PCXHR_CLOCK_TYPE_WORD_CLOCK :	val = PCXHR_FREQ_WORD_CLOCK;	break;
+	case PCXHR_CLOCK_TYPE_AES_SYNC :	val = PCXHR_FREQ_SYNC_AES;	break;
+	case PCXHR_CLOCK_TYPE_AES_1 :		val = PCXHR_FREQ_AES_1;		break;
+	case PCXHR_CLOCK_TYPE_AES_2 :		val = PCXHR_FREQ_AES_2;		break;
+	case PCXHR_CLOCK_TYPE_AES_3 :		val = PCXHR_FREQ_AES_3;		break;
+	case PCXHR_CLOCK_TYPE_AES_4 :		val = PCXHR_FREQ_AES_4;		break;
+	default : return -EINVAL;
+	}
+	*reg = val;
+	*freq = realfreq;
+	return 0;
+}
+
+
+int pcxhr_set_clock(struct pcxhr_mgr *mgr, unsigned int rate)
+{
+	unsigned int val, realfreq, speed;
+	struct pcxhr_rmh rmh;
+	int err, changed;
+
+	if (rate == 0)
+		return 0; /* nothing to do */
+
+	err = pcxhr_get_clock_reg(mgr, rate, &val, &realfreq);
+	if (err)
+		return err;
+
+	/* codec speed modes */
+	if (rate < 55000)
+		speed = 0;	/* single speed */
+	else if (rate < 100000)
+		speed = 1;	/* dual speed */
+	else
+		speed = 2;	/* quad speed */
+	if (mgr->codec_speed != speed) {
+		pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);	/* mute outputs */
+		rmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;
+		err = pcxhr_send_msg(mgr, &rmh);
+		if (err)
+			return err;
+
+		pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);	/* set speed ratio */
+		rmh.cmd[0] |= IO_NUM_SPEED_RATIO;
+		rmh.cmd[1] = speed;
+		rmh.cmd_len = 2;
+		err = pcxhr_send_msg(mgr, &rmh);
+		if (err)
+			return err;
+	}
+	/* set the new frequency */
+	snd_printdd("clock register : set %x\n", val);
+	err = pcxhr_write_io_num_reg_cont(mgr, PCXHR_FREQ_REG_MASK, val, &changed);
+	if (err)
+		return err;
+	mgr->sample_rate_real = realfreq;
+	mgr->cur_clock_type = mgr->use_clock_type;
+
+	/* unmute after codec speed modes */
+	if (mgr->codec_speed != speed) {
+		pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);	/* unmute outputs */
+		rmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;
+		err = pcxhr_send_msg(mgr, &rmh);
+		if (err)
+			return err;
+		mgr->codec_speed = speed;			/* save new codec speed */
+	}
+
+	if (changed) {
+		pcxhr_init_rmh(&rmh, CMD_MODIFY_CLOCK);
+		rmh.cmd[0] |= PCXHR_MODIFY_CLOCK_S_BIT;		/* resync fifos  */
+		if (rate < PCXHR_IRQ_TIMER_FREQ)
+			rmh.cmd[1] = PCXHR_IRQ_TIMER_PERIOD;
+		else
+			rmh.cmd[1] = PCXHR_IRQ_TIMER_PERIOD * 2;
+		rmh.cmd[2] = rate;
+		rmh.cmd_len = 3;
+		err = pcxhr_send_msg(mgr, &rmh);
+		if (err)
+			return err;
+	}
+	snd_printdd("pcxhr_set_clock to %dHz (realfreq=%d)\n", rate, realfreq);
+	return 0;
+}
+
+
+int pcxhr_get_external_clock(struct pcxhr_mgr *mgr, enum pcxhr_clock_type clock_type,
+			     int *sample_rate)
+{
+	struct pcxhr_rmh rmh;
+	unsigned char reg;
+	int err, rate;
+
+	switch (clock_type) {
+	case PCXHR_CLOCK_TYPE_WORD_CLOCK :	reg = REG_STATUS_WORD_CLOCK;	break;
+	case PCXHR_CLOCK_TYPE_AES_SYNC :	reg = REG_STATUS_AES_SYNC;	break;
+	case PCXHR_CLOCK_TYPE_AES_1 :		reg = REG_STATUS_AES_1;		break;
+	case PCXHR_CLOCK_TYPE_AES_2 :		reg = REG_STATUS_AES_2;		break;
+	case PCXHR_CLOCK_TYPE_AES_3 :		reg = REG_STATUS_AES_3;		break;
+	case PCXHR_CLOCK_TYPE_AES_4 :		reg = REG_STATUS_AES_4;		break;
+	default : return -EINVAL;
+	}
+	pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);
+	rmh.cmd_len = 2;
+	rmh.cmd[0] |= IO_NUM_REG_STATUS;
+	if (mgr->last_reg_stat != reg) {
+		rmh.cmd[1]  = reg;
+		err = pcxhr_send_msg(mgr, &rmh);
+		if (err)
+			return err;
+		udelay(100);		/* wait minimum 2 sample_frames at 32kHz ! */
+		mgr->last_reg_stat = reg;
+	}
+	rmh.cmd[1]  = REG_STATUS_CURRENT;
+	err = pcxhr_send_msg(mgr, &rmh);
+	if (err)
+		return err;
+	switch (rmh.stat[1] & 0x0f) {
+	case REG_STATUS_SYNC_32000 :	rate = 32000; break;
+	case REG_STATUS_SYNC_44100 :	rate = 44100; break;
+	case REG_STATUS_SYNC_48000 :	rate = 48000; break;
+	case REG_STATUS_SYNC_64000 :	rate = 64000; break;
+	case REG_STATUS_SYNC_88200 :	rate = 88200; break;
+	case REG_STATUS_SYNC_96000 :	rate = 96000; break;
+	case REG_STATUS_SYNC_128000 :	rate = 128000; break;
+	case REG_STATUS_SYNC_176400 :	rate = 176400; break;
+	case REG_STATUS_SYNC_192000 :	rate = 192000; break;
+	default: rate = 0;
+	}
+	snd_printdd("External clock is at %d Hz\n", rate);
+	*sample_rate = rate;
+	return 0;
+}
+
+
+/*
+ *  start or stop playback/capture substream
+ */
+static int pcxhr_set_stream_state(struct pcxhr_stream *stream)
+{
+	int err;
+	struct snd_pcxhr *chip;
+	struct pcxhr_rmh rmh;
+	int stream_mask, start;
+
+	if (stream->status == PCXHR_STREAM_STATUS_SCHEDULE_RUN)
+		start = 1;
+	else {
+		if (stream->status != PCXHR_STREAM_STATUS_SCHEDULE_STOP) {
+			snd_printk(KERN_ERR "ERROR pcxhr_set_stream_state CANNOT be stopped\n");
+			return -EINVAL;
+		}
+		start = 0;
+	}
+	if (!stream->substream)
+		return -EINVAL;
+
+	stream->timer_abs_periods = 0;
+	stream->timer_period_frag = 0;            /* reset theoretical stream pos */
+	stream->timer_buf_periods = 0;
+	stream->timer_is_synced = 0;
+
+	stream_mask = stream->pipe->is_capture ? 1 : 1<<stream->substream->number;
+
+	pcxhr_init_rmh(&rmh, start ? CMD_START_STREAM : CMD_STOP_STREAM);
+	pcxhr_set_pipe_cmd_params(&rmh, stream->pipe->is_capture,
+				  stream->pipe->first_audio, 0, stream_mask);
+
+	chip = snd_pcm_substream_chip(stream->substream);
+
+	err = pcxhr_send_msg(chip->mgr, &rmh);
+	if (err)
+		snd_printk(KERN_ERR "ERROR pcxhr_set_stream_state err=%x;\n", err);
+	stream->status = start ? PCXHR_STREAM_STATUS_STARTED : PCXHR_STREAM_STATUS_STOPPED;
+	return err;
+}
+
+#define HEADER_FMT_BASE_LIN		0xfed00000
+#define HEADER_FMT_BASE_FLOAT		0xfad00000
+#define HEADER_FMT_INTEL		0x00008000
+#define HEADER_FMT_24BITS		0x00004000
+#define HEADER_FMT_16BITS		0x00002000
+#define HEADER_FMT_UPTO11		0x00000200
+#define HEADER_FMT_UPTO32		0x00000100
+#define HEADER_FMT_MONO			0x00000080
+
+static int pcxhr_set_format(struct pcxhr_stream *stream)
+{
+	int err, is_capture, sample_rate, stream_num;
+	struct snd_pcxhr *chip;
+	struct pcxhr_rmh rmh;
+	unsigned int header;
+
+	switch (stream->format) {
+	case SNDRV_PCM_FORMAT_U8:
+		header = HEADER_FMT_BASE_LIN;
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		header = HEADER_FMT_BASE_LIN | HEADER_FMT_16BITS | HEADER_FMT_INTEL;
+		break;
+	case SNDRV_PCM_FORMAT_S16_BE:
+		header = HEADER_FMT_BASE_LIN | HEADER_FMT_16BITS;
+		break;
+	case SNDRV_PCM_FORMAT_S24_3LE:
+		header = HEADER_FMT_BASE_LIN | HEADER_FMT_24BITS | HEADER_FMT_INTEL;
+		break;
+	case SNDRV_PCM_FORMAT_S24_3BE:
+		header = HEADER_FMT_BASE_LIN | HEADER_FMT_24BITS;
+		break;
+	case SNDRV_PCM_FORMAT_FLOAT_LE:
+		header = HEADER_FMT_BASE_FLOAT | HEADER_FMT_INTEL;
+		break;
+	default:
+		snd_printk(KERN_ERR "error pcxhr_set_format() : unknown format\n");
+		return -EINVAL;
+	}
+	chip = snd_pcm_substream_chip(stream->substream);
+
+	sample_rate = chip->mgr->sample_rate;
+	if (sample_rate <= 32000 && sample_rate !=0) {
+		if (sample_rate <= 11025)
+			header |= HEADER_FMT_UPTO11;
+		else
+			header |= HEADER_FMT_UPTO32;
+	}
+	if (stream->channels == 1)
+		header |= HEADER_FMT_MONO;
+
+	is_capture = stream->pipe->is_capture;
+	stream_num = is_capture ? 0 : stream->substream->number;
+
+	pcxhr_init_rmh(&rmh, is_capture ? CMD_FORMAT_STREAM_IN : CMD_FORMAT_STREAM_OUT);
+	pcxhr_set_pipe_cmd_params(&rmh, is_capture, stream->pipe->first_audio, stream_num, 0);
+	if (is_capture)
+		rmh.cmd[0] |= 1<<12;
+	rmh.cmd[1] = 0;
+	rmh.cmd[2] = header >> 8;
+	rmh.cmd[3] = (header & 0xff) << 16;
+	rmh.cmd_len = 4;
+	err = pcxhr_send_msg(chip->mgr, &rmh);
+	if (err)
+		snd_printk(KERN_ERR "ERROR pcxhr_set_format err=%x;\n", err);
+	return err;
+}
+
+static int pcxhr_update_r_buffer(struct pcxhr_stream *stream)
+{
+	int err, is_capture, stream_num;
+	struct pcxhr_rmh rmh;
+	struct snd_pcm_substream *subs = stream->substream;
+	struct snd_pcxhr *chip = snd_pcm_substream_chip(subs);
+
+	is_capture = (subs->stream == SNDRV_PCM_STREAM_CAPTURE);
+	stream_num = is_capture ? 0 : subs->number;
+
+	snd_printdd("pcxhr_update_r_buffer(pcm%c%d) : addr(%p) bytes(%x) subs(%d)\n",
+		    is_capture ? 'c' : 'p',
+		    chip->chip_idx, (void*)subs->runtime->dma_addr,
+		    subs->runtime->dma_bytes, subs->number);
+
+	pcxhr_init_rmh(&rmh, CMD_UPDATE_R_BUFFERS);
+	pcxhr_set_pipe_cmd_params(&rmh, is_capture, stream->pipe->first_audio, stream_num, 0);
+
+	snd_assert(subs->runtime->dma_bytes < 0x200000);	/* max buffer size is 2 MByte */
+	rmh.cmd[1] = subs->runtime->dma_bytes * 8;		/* size in bits */
+	rmh.cmd[2] = subs->runtime->dma_addr >> 24;		/* most significant byte */
+	rmh.cmd[2] |= 1<<19;					/* this is a circular buffer */
+	rmh.cmd[3] = subs->runtime->dma_addr & MASK_DSP_WORD;	/* least 3 significant bytes */
+	rmh.cmd_len = 4;
+	err = pcxhr_send_msg(chip->mgr, &rmh);
+	if (err)
+		snd_printk(KERN_ERR "ERROR CMD_UPDATE_R_BUFFERS err=%x;\n", err);
+	return err;
+}
+
+
+#if 0
+static int pcxhr_pipe_sample_count(struct pcxhr_stream *stream, snd_pcm_uframes_t *sample_count)
+{
+	struct pcxhr_rmh rmh;
+	int err;
+	pcxhr_t *chip = snd_pcm_substream_chip(stream->substream);
+	pcxhr_init_rmh(&rmh, CMD_PIPE_SAMPLE_COUNT);
+	pcxhr_set_pipe_cmd_params(&rmh, stream->pipe->is_capture, 0, 0,
+				  1<<stream->pipe->first_audio);
+	err = pcxhr_send_msg(chip->mgr, &rmh);
+	if (err == 0) {
+		*sample_count = ((snd_pcm_uframes_t)rmh.stat[0]) << 24;
+		*sample_count += (snd_pcm_uframes_t)rmh.stat[1];
+	}
+	snd_printdd("PIPE_SAMPLE_COUNT = %lx\n", *sample_count);
+	return err;
+}
+#endif
+
+static inline int pcxhr_stream_scheduled_get_pipe(struct pcxhr_stream *stream,
+						  struct pcxhr_pipe **pipe)
+{
+	if (stream->status == PCXHR_STREAM_STATUS_SCHEDULE_RUN) {
+		*pipe = stream->pipe;
+		return 1;
+	}
+	return 0;
+}
+
+static void pcxhr_trigger_tasklet(unsigned long arg)
+{
+	unsigned long flags;
+	int i, j, err;
+	struct pcxhr_pipe *pipe;
+	struct snd_pcxhr *chip;
+	struct pcxhr_mgr *mgr = (struct pcxhr_mgr*)(arg);
+	int capture_mask = 0;
+	int playback_mask = 0;
+
+#ifdef CONFIG_SND_DEBUG_DETECT
+	struct timeval my_tv1, my_tv2;
+	do_gettimeofday(&my_tv1);
+#endif
+	down(&mgr->setup_mutex);
+
+	/* check the pipes concerned and build pipe_array */
+	for (i = 0; i < mgr->num_cards; i++) {
+		chip = mgr->chip[i];
+		for (j = 0; j < chip->nb_streams_capt; j++) {
+			if (pcxhr_stream_scheduled_get_pipe(&chip->capture_stream[j], &pipe))
+				capture_mask |= (1 << pipe->first_audio);
+		}
+		for (j = 0; j < chip->nb_streams_play; j++) {
+			if (pcxhr_stream_scheduled_get_pipe(&chip->playback_stream[j], &pipe)) {
+				playback_mask |= (1 << pipe->first_audio);
+				break;	/* add only once, as all playback streams of
+					 * one chip use the same pipe
+					 */
+			}
+		}
+	}
+	if (capture_mask == 0 && playback_mask == 0) {
+		up(&mgr->setup_mutex);
+		snd_printk(KERN_ERR "pcxhr_trigger_tasklet : no pipes\n");
+		return;
+	}
+
+	snd_printdd("pcxhr_trigger_tasklet : playback_mask=%x capture_mask=%x\n",
+		    playback_mask, capture_mask);
+
+	/* synchronous stop of all the pipes concerned */
+	err = pcxhr_set_pipe_state(mgr,  playback_mask, capture_mask, 0);
+	if (err) {
+		up(&mgr->setup_mutex);
+		snd_printk(KERN_ERR "pcxhr_trigger_tasklet : error stop pipes (P%x C%x)\n",
+			   playback_mask, capture_mask);
+		return;
+	}
+
+	/* unfortunately the dsp lost format and buffer info with the stop pipe */
+	for (i = 0; i < mgr->num_cards; i++) {
+		struct pcxhr_stream *stream;
+		chip = mgr->chip[i];
+		for (j = 0; j < chip->nb_streams_capt; j++) {
+			stream = &chip->capture_stream[j];
+			if (pcxhr_stream_scheduled_get_pipe(stream, &pipe)) {
+				err = pcxhr_set_format(stream);
+				err = pcxhr_update_r_buffer(stream);
+			}
+		}
+		for (j = 0; j < chip->nb_streams_play; j++) {
+			stream = &chip->playback_stream[j];
+			if (pcxhr_stream_scheduled_get_pipe(stream, &pipe)) {
+				err = pcxhr_set_format(stream);
+				err = pcxhr_update_r_buffer(stream);
+			}
+		}
+	}
+	/* start all the streams */
+	for (i = 0; i < mgr->num_cards; i++) {
+		struct pcxhr_stream *stream;
+		chip = mgr->chip[i];
+		for (j = 0; j < chip->nb_streams_capt; j++) {
+			stream = &chip->capture_stream[j];
+			if (pcxhr_stream_scheduled_get_pipe(stream, &pipe))
+				err = pcxhr_set_stream_state(stream);
+		}
+		for (j = 0; j < chip->nb_streams_play; j++) {
+			stream = &chip->playback_stream[j];
+			if (pcxhr_stream_scheduled_get_pipe(stream, &pipe))
+				err = pcxhr_set_stream_state(stream);
+		}
+	}
+
+	/* synchronous start of all the pipes concerned */
+	err = pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 1);
+	if (err) {
+		up(&mgr->setup_mutex);
+		snd_printk(KERN_ERR "pcxhr_trigger_tasklet : error start pipes (P%x C%x)\n",
+			   playback_mask, capture_mask);
+		return;
+	}
+
+	/* put the streams into the running state now (increment pointer by interrupt) */
+	spin_lock_irqsave(&mgr->lock, flags);
+	for ( i =0; i < mgr->num_cards; i++) {
+		struct pcxhr_stream *stream;
+		chip = mgr->chip[i];
+		for(j = 0; j < chip->nb_streams_capt; j++) {
+			stream = &chip->capture_stream[j];
+			if(stream->status == PCXHR_STREAM_STATUS_STARTED)
+				stream->status = PCXHR_STREAM_STATUS_RUNNING;
+		}
+		for (j = 0; j < chip->nb_streams_play; j++) {
+			stream = &chip->playback_stream[j];
+			if (stream->status == PCXHR_STREAM_STATUS_STARTED) {
+				/* playback will already have advanced ! */
+				stream->timer_period_frag += PCXHR_GRANULARITY;
+				stream->status = PCXHR_STREAM_STATUS_RUNNING;
+			}
+		}
+	}
+	spin_unlock_irqrestore(&mgr->lock, flags);
+
+	up(&mgr->setup_mutex);
+
+#ifdef CONFIG_SND_DEBUG_DETECT
+	do_gettimeofday(&my_tv2);
+	snd_printdd("***TRIGGER TASKLET*** TIME = %ld (err = %x)\n",
+		    my_tv2.tv_usec - my_tv1.tv_usec, err);
+#endif
+}
+
+
+/*
+ *  trigger callback
+ */
+static int pcxhr_trigger(struct snd_pcm_substream *subs, int cmd)
+{
+	struct pcxhr_stream *stream;
+	struct list_head *pos;
+	struct snd_pcm_substream *s;
+	int i;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		snd_printdd("SNDRV_PCM_TRIGGER_START\n");
+		i = 0;
+		snd_pcm_group_for_each(pos, subs) {
+			s = snd_pcm_group_substream_entry(pos);
+			stream = s->runtime->private_data;
+			stream->status = PCXHR_STREAM_STATUS_SCHEDULE_RUN;
+			snd_pcm_trigger_done(s, subs);
+			i++;
+		}
+		if (i==1) {
+			snd_printdd("Only one Substream %c %d\n",
+				    stream->pipe->is_capture ? 'C' : 'P',
+				    stream->pipe->first_audio);
+			if (pcxhr_set_format(stream))
+				return -EINVAL;
+			if (pcxhr_update_r_buffer(stream))
+				return -EINVAL;
+
+			if (pcxhr_set_stream_state(stream))
+				return -EINVAL;
+			stream->status = PCXHR_STREAM_STATUS_RUNNING;
+		} else {
+			struct snd_pcxhr *chip = snd_pcm_substream_chip(subs);
+			tasklet_hi_schedule(&chip->mgr->trigger_taskq);
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		snd_printdd("SNDRV_PCM_TRIGGER_STOP\n");
+		snd_pcm_group_for_each(pos, subs) {
+			s = snd_pcm_group_substream_entry(pos);
+			stream = s->runtime->private_data;
+			stream->status = PCXHR_STREAM_STATUS_SCHEDULE_STOP;
+			if (pcxhr_set_stream_state(stream))
+				return -EINVAL;
+			snd_pcm_trigger_done(s, subs);
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		/* TODO */
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+static int pcxhr_hardware_timer(struct pcxhr_mgr *mgr, int start)
+{
+	struct pcxhr_rmh rmh;
+	int err;
+
+	pcxhr_init_rmh(&rmh, CMD_SET_TIMER_INTERRUPT);
+	if (start) {
+		mgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;	/* last dsp time invalid */
+		rmh.cmd[0] |= PCXHR_GRANULARITY;
+	}
+	err = pcxhr_send_msg(mgr, &rmh);
+	if (err < 0)
+		snd_printk(KERN_ERR "error pcxhr_hardware_timer err(%x)\n", err);
+	return err;
+}
+
+/*
+ *  prepare callback for all pcms
+ */
+static int pcxhr_prepare(struct snd_pcm_substream *subs)
+{
+	struct snd_pcxhr *chip = snd_pcm_substream_chip(subs);
+	struct pcxhr_mgr *mgr = chip->mgr;
+	/*
+	struct pcxhr_stream *stream = (pcxhr_stream_t*)subs->runtime->private_data;
+	*/
+	int err = 0;
+
+	snd_printdd("pcxhr_prepare : period_size(%lx) periods(%x) buffer_size(%lx)\n",
+		    subs->runtime->period_size, subs->runtime->periods,
+		    subs->runtime->buffer_size);
+
+	/*
+	if(subs->runtime->period_size <= PCXHR_GRANULARITY) {
+		snd_printk(KERN_ERR "pcxhr_prepare : error period_size too small (%x)\n",
+			   (unsigned int)subs->runtime->period_size);
+		return -EINVAL;
+	}
+	*/
+
+	down(&mgr->setup_mutex);
+
+	do {
+		/* if the stream was stopped before, format and buffer were reset */
+		/*
+		if(stream->status == PCXHR_STREAM_STATUS_STOPPED) {
+			err = pcxhr_set_format(stream);
+			if(err) break;
+			err = pcxhr_update_r_buffer(stream);
+			if(err) break;
+		}
+		*/
+
+		/* only the first stream can choose the sample rate */
+		/* the further opened streams will be limited to its frequency (see open) */
+		/* set the clock only once (first stream) */
+		if (mgr->sample_rate == 0) {
+			err = pcxhr_set_clock(mgr, subs->runtime->rate);
+			if (err)
+				break;
+			mgr->sample_rate = subs->runtime->rate;
+
+			err = pcxhr_hardware_timer(mgr, 1);	/* start the DSP-timer */
+		}
+	} while(0);	/* do only once (so we can use break instead of goto) */
+
+	up(&mgr->setup_mutex);
+
+	return err;
+}
+
+
+/*
+ *  HW_PARAMS callback for all pcms
+ */
+static int pcxhr_hw_params(struct snd_pcm_substream *subs,
+			   struct snd_pcm_hw_params *hw)
+{
+	struct snd_pcxhr *chip = snd_pcm_substream_chip(subs);
+	struct pcxhr_mgr *mgr = chip->mgr;
+	struct pcxhr_stream *stream = subs->runtime->private_data;
+	snd_pcm_format_t format;
+	int err;
+	int channels;
+
+	/* set up channels */
+	channels = params_channels(hw);
+
+	/*  set up format for the stream */
+	format = params_format(hw);
+
+	down(&mgr->setup_mutex);
+
+	stream->channels = channels;
+	stream->format = format;
+
+	/* set the format to the board */
+	/*
+	err = pcxhr_set_format(stream);
+	if(err) {
+		up(&mgr->setup_mutex);
+		return err;
+	}
+	*/
+	/* allocate buffer */
+	err = snd_pcm_lib_malloc_pages(subs, params_buffer_bytes(hw));
+
+	/*
+	if (err > 0) {
+		err = pcxhr_update_r_buffer(stream);
+	}
+	*/
+	up(&mgr->setup_mutex);
+
+	return err;
+}
+
+static int pcxhr_hw_free(struct snd_pcm_substream *subs)
+{
+	snd_pcm_lib_free_pages(subs);
+	return 0;
+}
+
+
+/*
+ *  CONFIGURATION SPACE for all pcms, mono pcm must update channels_max
+ */
+static struct snd_pcm_hardware pcxhr_caps =
+{
+	.info             = ( SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+			      SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |
+			      0 /*SNDRV_PCM_INFO_PAUSE*/),
+	.formats	  = ( SNDRV_PCM_FMTBIT_U8 |
+			      SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE |
+			      SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_3BE |
+			      SNDRV_PCM_FMTBIT_FLOAT_LE ),
+	.rates            = SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_192000,
+	.rate_min         = 8000,
+	.rate_max         = 192000,
+	.channels_min     = 1,
+	.channels_max     = 2,
+	.buffer_bytes_max = (32*1024),
+	/* 1 byte == 1 frame U8 mono (PCXHR_GRANULARITY is frames!) */
+	.period_bytes_min = (2*PCXHR_GRANULARITY),
+	.period_bytes_max = (16*1024),
+	.periods_min      = 2,
+	.periods_max      = (32*1024/PCXHR_GRANULARITY),
+};
+
+
+static int pcxhr_open(struct snd_pcm_substream *subs)
+{
+	struct snd_pcxhr       *chip = snd_pcm_substream_chip(subs);
+	struct pcxhr_mgr       *mgr = chip->mgr;
+	struct snd_pcm_runtime *runtime = subs->runtime;
+	struct pcxhr_stream    *stream;
+	int                 is_capture;
+
+	down(&mgr->setup_mutex);
+
+	/* copy the struct snd_pcm_hardware struct */
+	runtime->hw = pcxhr_caps;
+
+	if( subs->stream == SNDRV_PCM_STREAM_PLAYBACK ) {
+		snd_printdd("pcxhr_open playback chip%d subs%d\n",
+			    chip->chip_idx, subs->number);
+		is_capture = 0;
+		stream = &chip->playback_stream[subs->number];
+	} else {
+		snd_printdd("pcxhr_open capture chip%d subs%d\n",
+			    chip->chip_idx, subs->number);
+		is_capture = 1;
+		if (mgr->mono_capture)
+			runtime->hw.channels_max = 1;
+		else
+			runtime->hw.channels_min = 2;
+		stream = &chip->capture_stream[subs->number];
+	}
+	if (stream->status != PCXHR_STREAM_STATUS_FREE){
+		/* streams in use */
+		snd_printk(KERN_ERR "pcxhr_open chip%d subs%d in use\n",
+			   chip->chip_idx, subs->number);
+		up(&mgr->setup_mutex);
+		return -EBUSY;
+	}
+
+	/* if a sample rate is already used or fixed by external clock,
+	 * the stream cannot change
+	 */
+	if (mgr->sample_rate)
+		runtime->hw.rate_min = runtime->hw.rate_max = mgr->sample_rate;
+	else {
+		if (mgr->use_clock_type != PCXHR_CLOCK_TYPE_INTERNAL) {
+			int external_rate;
+			if (pcxhr_get_external_clock(mgr, mgr->use_clock_type,
+						     &external_rate) ||
+			    external_rate == 0) {
+				/* cannot detect the external clock rate */
+				up(&mgr->setup_mutex);
+				return -EBUSY;
+			}
+			runtime->hw.rate_min = runtime->hw.rate_max = external_rate;
+		}
+	}
+
+	stream->status      = PCXHR_STREAM_STATUS_OPEN;
+	stream->substream   = subs;
+	stream->channels    = 0; /* not configured yet */
+
+	runtime->private_data = stream;
+
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 4);
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 4);
+
+	mgr->ref_count_rate++;
+
+	up(&mgr->setup_mutex);
+	return 0;
+}
+
+
+static int pcxhr_close(struct snd_pcm_substream *subs)
+{
+	struct snd_pcxhr *chip = snd_pcm_substream_chip(subs);
+	struct pcxhr_mgr *mgr = chip->mgr;
+	struct pcxhr_stream *stream = subs->runtime->private_data;
+
+	down(&mgr->setup_mutex);
+
+	snd_printdd("pcxhr_close chip%d subs%d\n", chip->chip_idx, subs->number);
+
+	/* sample rate released */
+	if (--mgr->ref_count_rate == 0) {
+		mgr->sample_rate = 0;		/* the sample rate is no more locked */
+		pcxhr_hardware_timer(mgr, 0);	/* stop the DSP-timer */
+	}
+
+	stream->status    = PCXHR_STREAM_STATUS_FREE;
+	stream->substream = NULL;
+
+	up(&mgr->setup_mutex);
+
+	return 0;
+}
+
+
+static snd_pcm_uframes_t pcxhr_stream_pointer(struct snd_pcm_substream *subs)
+{
+	unsigned long flags;
+	u_int32_t timer_period_frag;
+	int timer_buf_periods;
+	struct snd_pcxhr *chip = snd_pcm_substream_chip(subs);
+	struct snd_pcm_runtime *runtime = subs->runtime;
+	struct pcxhr_stream *stream  = runtime->private_data;
+
+	spin_lock_irqsave(&chip->mgr->lock, flags);
+
+	/* get the period fragment and the nb of periods in the buffer */
+	timer_period_frag = stream->timer_period_frag;
+	timer_buf_periods = stream->timer_buf_periods;
+
+	spin_unlock_irqrestore(&chip->mgr->lock, flags);
+
+	return (snd_pcm_uframes_t)((timer_buf_periods * runtime->period_size) +
+				   timer_period_frag);
+}
+
+
+static struct snd_pcm_ops pcxhr_ops = {
+	.open      = pcxhr_open,
+	.close     = pcxhr_close,
+	.ioctl     = snd_pcm_lib_ioctl,
+	.prepare   = pcxhr_prepare,
+	.hw_params = pcxhr_hw_params,
+	.hw_free   = pcxhr_hw_free,
+	.trigger   = pcxhr_trigger,
+	.pointer   = pcxhr_stream_pointer,
+};
+
+/*
+ */
+int pcxhr_create_pcm(struct snd_pcxhr *chip)
+{
+	int err;
+	struct snd_pcm *pcm;
+	char name[32];
+
+	sprintf(name, "pcxhr %d", chip->chip_idx);
+	if ((err = snd_pcm_new(chip->card, name, 0,
+			       chip->nb_streams_play,
+			       chip->nb_streams_capt, &pcm)) < 0) {
+		snd_printk(KERN_ERR "cannot create pcm %s\n", name);
+		return err;
+	}
+	pcm->private_data = chip;
+
+	if (chip->nb_streams_play)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &pcxhr_ops);
+	if (chip->nb_streams_capt)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &pcxhr_ops);
+
+	pcm->info_flags = 0;
+	strcpy(pcm->name, name);
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      snd_dma_pci_data(chip->mgr->pci),
+					      32*1024, 32*1024);
+	chip->pcm = pcm;
+	return 0;
+}
+
+static int pcxhr_chip_free(struct snd_pcxhr *chip)
+{
+	kfree(chip);
+	return 0;
+}
+
+static int pcxhr_chip_dev_free(struct snd_device *device)
+{
+	struct snd_pcxhr *chip = device->device_data;
+	return pcxhr_chip_free(chip);
+}
+
+
+/*
+ */
+static int __devinit pcxhr_create(struct pcxhr_mgr *mgr, struct snd_card *card, int idx)
+{
+	int err;
+	struct snd_pcxhr *chip;
+	static struct snd_device_ops ops = {
+		.dev_free = pcxhr_chip_dev_free,
+	};
+
+	mgr->chip[idx] = chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (! chip) {
+		snd_printk(KERN_ERR "cannot allocate chip\n");
+		return -ENOMEM;
+	}
+
+	chip->card = card;
+	chip->chip_idx = idx;
+	chip->mgr = mgr;
+
+	if (idx < mgr->playback_chips)
+		/* stereo or mono streams */
+		chip->nb_streams_play = PCXHR_PLAYBACK_STREAMS;
+
+	if (idx < mgr->capture_chips) {
+		if (mgr->mono_capture)
+			chip->nb_streams_capt = 2;	/* 2 mono streams (left+right) */
+		else
+			chip->nb_streams_capt = 1;	/* or 1 stereo stream */
+	}
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
+		pcxhr_chip_free(chip);
+		return err;
+	}
+
+	snd_card_set_dev(card, &mgr->pci->dev);
+
+	return 0;
+}
+
+/* proc interface */
+static void pcxhr_proc_info(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
+{
+	struct snd_pcxhr *chip = entry->private_data;
+	struct pcxhr_mgr *mgr = chip->mgr;
+
+	snd_iprintf(buffer, "\n%s\n", mgr->longname);
+
+	/* stats available when embedded DSP is running */
+	if (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {
+		struct pcxhr_rmh rmh;
+		short ver_maj = (mgr->dsp_version >> 16) & 0xff;
+		short ver_min = (mgr->dsp_version >> 8) & 0xff;
+		short ver_build = mgr->dsp_version & 0xff;
+		snd_iprintf(buffer, "module version %s\n", PCXHR_DRIVER_VERSION_STRING);
+		snd_iprintf(buffer, "dsp version %d.%d.%d\n", ver_maj, ver_min, ver_build);
+		if (mgr->board_has_analog)
+			snd_iprintf(buffer, "analog io available\n");
+		else
+			snd_iprintf(buffer, "digital only board\n");
+
+		/* calc cpu load of the dsp */
+		pcxhr_init_rmh(&rmh, CMD_GET_DSP_RESOURCES);
+		if( ! pcxhr_send_msg(mgr, &rmh) ) {
+			int cur = rmh.stat[0];
+			int ref = rmh.stat[1];
+			if (ref > 0) {
+				if (mgr->sample_rate_real != 0 &&
+				    mgr->sample_rate_real != 48000) {
+					ref = (ref * 48000) / mgr->sample_rate_real;
+					if (mgr->sample_rate_real >= PCXHR_IRQ_TIMER_FREQ)
+						ref *= 2;
+				}
+				cur = 100 - (100 * cur) / ref;
+				snd_iprintf(buffer, "cpu load    %d%%\n", cur);
+				snd_iprintf(buffer, "buffer pool %d/%d kWords\n",
+					    rmh.stat[2], rmh.stat[3]);
+			}
+		}
+		snd_iprintf(buffer, "dma granularity : %d\n", PCXHR_GRANULARITY);
+		snd_iprintf(buffer, "dsp time errors : %d\n", mgr->dsp_time_err);
+		snd_iprintf(buffer, "dsp async pipe xrun errors : %d\n",
+			    mgr->async_err_pipe_xrun);
+		snd_iprintf(buffer, "dsp async stream xrun errors : %d\n",
+			    mgr->async_err_stream_xrun);
+		snd_iprintf(buffer, "dsp async last other error : %x\n",
+			    mgr->async_err_other_last);
+		/* debug zone dsp */
+		rmh.cmd[0] = 0x4200 + PCXHR_SIZE_MAX_STATUS;
+		rmh.cmd_len = 1;
+		rmh.stat_len = PCXHR_SIZE_MAX_STATUS;
+		rmh.dsp_stat = 0;
+		rmh.cmd_idx = CMD_LAST_INDEX;
+		if( ! pcxhr_send_msg(mgr, &rmh) ) {
+			int i;
+			for (i = 0; i < rmh.stat_len; i++)
+				snd_iprintf(buffer, "debug[%02d] = %06x\n", i,  rmh.stat[i]);
+		}
+	} else
+		snd_iprintf(buffer, "no firmware loaded\n");
+	snd_iprintf(buffer, "\n");
+}
+static void pcxhr_proc_sync(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
+{
+	struct snd_pcxhr *chip = entry->private_data;
+	struct pcxhr_mgr *mgr = chip->mgr;
+	static char *texts[7] = {
+		"Internal", "Word", "AES Sync", "AES 1", "AES 2", "AES 3", "AES 4"
+	};
+
+	snd_iprintf(buffer, "\n%s\n", mgr->longname);
+	snd_iprintf(buffer, "Current Sample Clock\t: %s\n", texts[mgr->cur_clock_type]);
+	snd_iprintf(buffer, "Current Sample Rate\t= %d\n", mgr->sample_rate_real);
+
+	/* commands available when embedded DSP is running */
+	if (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {
+		int i, err, sample_rate;
+		for (i = PCXHR_CLOCK_TYPE_WORD_CLOCK; i< (3 + mgr->capture_chips); i++) {
+			err = pcxhr_get_external_clock(mgr, i, &sample_rate);
+			if (err)
+				break;
+			snd_iprintf(buffer, "%s Clock\t\t= %d\n", texts[i], sample_rate);
+		}
+	} else
+		snd_iprintf(buffer, "no firmware loaded\n");
+	snd_iprintf(buffer, "\n");
+}
+
+static void __devinit pcxhr_proc_init(struct snd_pcxhr *chip)
+{
+	struct snd_info_entry *entry;
+
+	if (! snd_card_proc_new(chip->card, "info", &entry))
+		snd_info_set_text_ops(entry, chip, 1024, pcxhr_proc_info);
+	if (! snd_card_proc_new(chip->card, "sync", &entry))
+		snd_info_set_text_ops(entry, chip, 1024, pcxhr_proc_sync);
+}
+/* end of proc interface */
+
+/*
+ * release all the cards assigned to a manager instance
+ */
+static int pcxhr_free(struct pcxhr_mgr *mgr)
+{
+	unsigned int i;
+
+	for (i = 0; i < mgr->num_cards; i++) {
+		if (mgr->chip[i])
+			snd_card_free(mgr->chip[i]->card);
+	}
+
+	/* reset board if some firmware was loaded */
+	if(mgr->dsp_loaded) {
+		pcxhr_reset_board(mgr);
+		snd_printdd("reset pcxhr !\n");
+	}
+
+	/* release irq  */
+	if (mgr->irq >= 0)
+		free_irq(mgr->irq, mgr);
+
+	pci_release_regions(mgr->pci);
+
+	/* free hostport purgebuffer */
+	if (mgr->hostport.area) {
+		snd_dma_free_pages(&mgr->hostport);
+		mgr->hostport.area = NULL;
+	}
+
+	kfree(mgr->prmh);
+
+	pci_disable_device(mgr->pci);
+	kfree(mgr);
+	return 0;
+}
+
+/*
+ *    probe function - creates the card manager
+ */
+static int __devinit pcxhr_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
+{
+	static int dev;
+	struct pcxhr_mgr *mgr;
+	unsigned int i;
+	int err;
+	size_t size;
+	char *card_name;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (! enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	/* enable PCI device */
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+	pci_set_master(pci);
+
+	/* check if we can restrict PCI DMA transfers to 32 bits */
+	if (pci_set_dma_mask(pci, 0xffffffff) < 0) {
+		snd_printk(KERN_ERR "architecture does not support 32bit PCI busmaster DMA\n");
+		pci_disable_device(pci);
+		return -ENXIO;
+	}
+
+	/* alloc card manager */
+	mgr = kzalloc(sizeof(*mgr), GFP_KERNEL);
+	if (! mgr) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+
+	snd_assert(pci_id->driver_data < PCI_ID_LAST, return -ENODEV);
+	card_name = pcxhr_board_params[pci_id->driver_data].board_name;
+	mgr->playback_chips = pcxhr_board_params[pci_id->driver_data].playback_chips;
+	mgr->capture_chips  = pcxhr_board_params[pci_id->driver_data].capture_chips;
+	mgr->firmware_num  = pcxhr_board_params[pci_id->driver_data].firmware_num;
+	mgr->mono_capture = mono[dev];
+
+	/* resource assignment */
+	if ((err = pci_request_regions(pci, card_name)) < 0) {
+		kfree(mgr);
+		pci_disable_device(pci);
+		return err;
+	}
+	for (i = 0; i < 3; i++)
+		mgr->port[i] = pci_resource_start(pci, i);
+
+	mgr->pci = pci;
+	mgr->irq = -1;
+
+	if (request_irq(pci->irq, pcxhr_interrupt, SA_INTERRUPT|SA_SHIRQ,
+			card_name, mgr)) {
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		pcxhr_free(mgr);
+		return -EBUSY;
+	}
+	mgr->irq = pci->irq;
+
+	sprintf(mgr->shortname, "Digigram %s", card_name);
+	sprintf(mgr->longname, "%s at 0x%lx & 0x%lx, 0x%lx irq %i", mgr->shortname,
+		mgr->port[0], mgr->port[1], mgr->port[2], mgr->irq);
+
+	/* ISR spinlock  */
+	spin_lock_init(&mgr->lock);
+	spin_lock_init(&mgr->msg_lock);
+
+	/* init setup mutex*/
+	init_MUTEX(&mgr->setup_mutex);
+
+	/* init taslket */
+	tasklet_init(&mgr->msg_taskq, pcxhr_msg_tasklet, (unsigned long) mgr);
+	tasklet_init(&mgr->trigger_taskq, pcxhr_trigger_tasklet, (unsigned long) mgr);
+	mgr->prmh = kmalloc(sizeof(*mgr->prmh) + 
+			    sizeof(u32) * (PCXHR_SIZE_MAX_LONG_STATUS - PCXHR_SIZE_MAX_STATUS),
+			    GFP_KERNEL);
+	if (! mgr->prmh) {
+		pcxhr_free(mgr);
+		return -ENOMEM;
+	}
+
+	for (i=0; i < PCXHR_MAX_CARDS; i++) {
+		struct snd_card *card;
+		char tmpid[16];
+		int idx;
+
+		if (i >= max(mgr->playback_chips, mgr->capture_chips))
+			break;
+		mgr->num_cards++;
+
+		if (index[dev] < 0)
+			idx = index[dev];
+		else
+			idx = index[dev] + i;
+
+		snprintf(tmpid, sizeof(tmpid), "%s-%d", id[dev] ? id[dev] : card_name, i);
+		card = snd_card_new(idx, tmpid, THIS_MODULE, 0);
+
+		if (! card) {
+			snd_printk(KERN_ERR "cannot allocate the card %d\n", i);
+			pcxhr_free(mgr);
+			return -ENOMEM;
+		}
+
+		strcpy(card->driver, DRIVER_NAME);
+		sprintf(card->shortname, "%s [PCM #%d]", mgr->shortname, i);
+		sprintf(card->longname, "%s [PCM #%d]", mgr->longname, i);
+
+		if ((err = pcxhr_create(mgr, card, i)) < 0) {
+			pcxhr_free(mgr);
+			return err;
+		}
+
+		if (i == 0)
+			/* init proc interface only for chip0 */
+			pcxhr_proc_init(mgr->chip[i]);
+
+		if ((err = snd_card_register(card)) < 0) {
+			pcxhr_free(mgr);
+			return err;
+		}
+	}
+
+	/* create hostport purgebuffer */
+	size = PAGE_ALIGN(sizeof(struct pcxhr_hostport));
+	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
+				size, &mgr->hostport) < 0) {
+		pcxhr_free(mgr);
+		return -ENOMEM;
+	}
+	/* init purgebuffer */
+	memset(mgr->hostport.area, 0, size);
+
+	/* create a DSP loader */
+	err = pcxhr_setup_firmware(mgr);
+	if (err < 0) {
+		pcxhr_free(mgr);
+		return err;
+	}
+
+	pci_set_drvdata(pci, mgr);
+	dev++;
+	return 0;
+}
+
+static void __devexit pcxhr_remove(struct pci_dev *pci)
+{
+	pcxhr_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name = "Digigram pcxhr",
+	.id_table = pcxhr_ids,
+	.probe = pcxhr_probe,
+	.remove = __devexit_p(pcxhr_remove),
+};
+
+static int __init pcxhr_module_init(void)
+{
+	return pci_register_driver(&driver);
+}
+
+static void __exit pcxhr_module_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(pcxhr_module_init)
+module_exit(pcxhr_module_exit)
