commit 98fd539841319a46ba3773d908bfde13416d57eb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:38 2020 +0100

    ALSA: pcxhr: More constifications
    
    Apply const prefix to each possible place: the board parameters and
    DSP command table, and the string arrays.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index 495be27e3ba2..87d24224c042 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -466,7 +466,7 @@ enum {
 /*
  * Array of DSP commands
  */
-static struct pcxhr_cmd_info pcxhr_dsp_cmds[] = {
+static const struct pcxhr_cmd_info pcxhr_dsp_cmds[] = {
 [CMD_VERSION] =				{ 0x010000, 1, RMH_SSIZE_FIXED },
 [CMD_SUPPORTED] =			{ 0x020000, 4, RMH_SSIZE_FIXED },
 [CMD_TEST_IT] =				{ 0x040000, 1, RMH_SSIZE_FIXED },
@@ -497,7 +497,7 @@ static struct pcxhr_cmd_info pcxhr_dsp_cmds[] = {
 };
 
 #ifdef CONFIG_SND_DEBUG_VERBOSE
-static char* cmd_names[] = {
+static const char * const cmd_names[] = {
 [CMD_VERSION] =				"CMD_VERSION",
 [CMD_SUPPORTED] =			"CMD_SUPPORTED",
 [CMD_TEST_IT] =				"CMD_TEST_IT",
@@ -1006,7 +1006,7 @@ static int pcxhr_handle_async_err(struct pcxhr_mgr *mgr, u32 err,
 				  enum pcxhr_async_err_src err_src, int pipe,
 				  int is_capture)
 {
-	static char* err_src_name[] = {
+	static const char * const err_src_name[] = {
 		[PCXHR_ERR_PIPE]	= "Pipe",
 		[PCXHR_ERR_STREAM]	= "Stream",
 		[PCXHR_ERR_AUDIO]	= "Audio"

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index d7e71f309299..495be27e3ba2 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Driver for Digigram pcxhr compatible soundcards
  *
  * low level interface with interrupt and message handling implementation
  *
  * Copyright (c) 2004 by Digigram <alsa@digigram.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include <linux/delay.h>

commit 67f3754b51f22b18c4820fb84062f658c30e8644
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 21 17:37:54 2016 +0200

    ALSA: pcxhr: Fix missing mutex unlock
    
    The commit [9bef72bdb26e: ALSA: pcxhr: Use nonatomic PCM ops]
    converted to non-atomic PCM ops, but shamelessly with an unbalanced
    mutex locking, which leads to the hangup easily.  Fix it.
    
    Fixes: 9bef72bdb26e ('ALSA: pcxhr: Use nonatomic PCM ops')
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=116441
    Cc: <stable@vger.kernel.org> # 3.18+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index c5194f5b150a..d7e71f309299 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -1341,5 +1341,6 @@ irqreturn_t pcxhr_threaded_irq(int irq, void *dev_id)
 	}
 
 	pcxhr_msg_thread(mgr);
+	mutex_unlock(&mgr->lock);
 	return IRQ_HANDLED;
 }

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index 181f7729d409..c5194f5b150a 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -24,7 +24,7 @@
 #include <linux/firmware.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <sound/core.h>
 #include "pcxhr.h"
 #include "pcxhr_mixer.h"

commit 326f0480b7f8504c4f594c4f36ab7874e17780bc
Author: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
Date:   Tue Oct 28 14:27:44 2014 +0200

    ALSA: pcxhr: convert timeval to ktime_t
    
    This patch is concerned with migrating the time variables in the pcxhr
    module found in the sound driver. The changes are concerend with the
    y2038 problem where timeval will overflow in the year 2038. ktime_t
    was used instead of timeval to get the wall time. The difference
    is displayed now in nanoseconds instead of microseconds.
    
    Signed-off-by: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index a584acb61c00..181f7729d409 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -910,8 +910,9 @@ int pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask,
 	int audio_mask;
 
 #ifdef CONFIG_SND_DEBUG_VERBOSE
-	struct timeval my_tv1, my_tv2;
-	do_gettimeofday(&my_tv1);
+	ktime_t start_time, stop_time, diff_time;
+
+	start_time = ktime_get();
 #endif
 	audio_mask = (playback_mask |
 		      (capture_mask << PCXHR_PIPE_STATE_CAPTURE_OFFSET));
@@ -960,9 +961,10 @@ int pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask,
 			return err;
 	}
 #ifdef CONFIG_SND_DEBUG_VERBOSE
-	do_gettimeofday(&my_tv2);
+	stop_time = ktime_get();
+	diff_time = ktime_sub(stop_time, start_time);
 	dev_dbg(&mgr->pci->dev, "***SET PIPE STATE*** TIME = %ld (err = %x)\n",
-		    (long)(my_tv2.tv_usec - my_tv1.tv_usec), err);
+			(long)(ktime_to_ns(diff_time)), err);
 #endif
 	return 0;
 }

commit 9bef72bdb26e291d6dffb04768741a0e49582666
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 10 12:21:38 2014 +0200

    ALSA: pcxhr: Use nonatomic PCM ops
    
    This time PCXHR, another Digigram boards: like the previous patches,
    the conversion is straightforward, replacing spinlocks with mutexes,
    merging the irq tasklet into the threaded irq handler and the PCM
    trigger tasklet back to the trigger callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index df9371918601..a584acb61c00 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -767,11 +767,11 @@ void pcxhr_set_pipe_cmd_params(struct pcxhr_rmh *rmh, int capture,
  */
 int pcxhr_send_msg(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 {
-	unsigned long flags;
 	int err;
-	spin_lock_irqsave(&mgr->msg_lock, flags);
+
+	mutex_lock(&mgr->msg_lock);
 	err = pcxhr_send_msg_nolock(mgr, rmh);
-	spin_unlock_irqrestore(&mgr->msg_lock, flags);
+	mutex_unlock(&mgr->msg_lock);
 	return err;
 }
 
@@ -971,17 +971,16 @@ int pcxhr_write_io_num_reg_cont(struct pcxhr_mgr *mgr, unsigned int mask,
 				unsigned int value, int *changed)
 {
 	struct pcxhr_rmh rmh;
-	unsigned long flags;
 	int err;
 
-	spin_lock_irqsave(&mgr->msg_lock, flags);
+	mutex_lock(&mgr->msg_lock);
 	if ((mgr->io_num_reg_cont & mask) == value) {
 		dev_dbg(&mgr->pci->dev,
 			"IO_NUM_REG_CONT mask %x already is set to %x\n",
 			    mask, value);
 		if (changed)
 			*changed = 0;
-		spin_unlock_irqrestore(&mgr->msg_lock, flags);
+		mutex_unlock(&mgr->msg_lock);
 		return 0;	/* already programmed */
 	}
 	pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);
@@ -996,7 +995,7 @@ int pcxhr_write_io_num_reg_cont(struct pcxhr_mgr *mgr, unsigned int mask,
 		if (changed)
 			*changed = 1;
 	}
-	spin_unlock_irqrestore(&mgr->msg_lock, flags);
+	mutex_unlock(&mgr->msg_lock);
 	return err;
 }
 
@@ -1043,22 +1042,21 @@ static int pcxhr_handle_async_err(struct pcxhr_mgr *mgr, u32 err,
 }
 
 
-void pcxhr_msg_tasklet(unsigned long arg)
+static void pcxhr_msg_thread(struct pcxhr_mgr *mgr)
 {
-	struct pcxhr_mgr *mgr = (struct pcxhr_mgr *)(arg);
 	struct pcxhr_rmh *prmh = mgr->prmh;
 	int err;
 	int i, j;
 
 	if (mgr->src_it_dsp & PCXHR_IRQ_FREQ_CHANGE)
 		dev_dbg(&mgr->pci->dev,
-			"TASKLET : PCXHR_IRQ_FREQ_CHANGE event occurred\n");
+			"PCXHR_IRQ_FREQ_CHANGE event occurred\n");
 	if (mgr->src_it_dsp & PCXHR_IRQ_TIME_CODE)
 		dev_dbg(&mgr->pci->dev,
-			"TASKLET : PCXHR_IRQ_TIME_CODE event occurred\n");
+			"PCXHR_IRQ_TIME_CODE event occurred\n");
 	if (mgr->src_it_dsp & PCXHR_IRQ_NOTIFY)
 		dev_dbg(&mgr->pci->dev,
-			"TASKLET : PCXHR_IRQ_NOTIFY event occurred\n");
+			"PCXHR_IRQ_NOTIFY event occurred\n");
 	if (mgr->src_it_dsp & (PCXHR_IRQ_FREQ_CHANGE | PCXHR_IRQ_TIME_CODE)) {
 		/* clear events FREQ_CHANGE and TIME_CODE */
 		pcxhr_init_rmh(prmh, CMD_TEST_IT);
@@ -1068,7 +1066,7 @@ void pcxhr_msg_tasklet(unsigned long arg)
 	}
 	if (mgr->src_it_dsp & PCXHR_IRQ_ASYNC) {
 		dev_dbg(&mgr->pci->dev,
-			"TASKLET : PCXHR_IRQ_ASYNC event occurred\n");
+			"PCXHR_IRQ_ASYNC event occurred\n");
 
 		pcxhr_init_rmh(prmh, CMD_ASYNC);
 		prmh->cmd[0] |= 1;	/* add SEL_ASYNC_EVENTS */
@@ -1076,7 +1074,7 @@ void pcxhr_msg_tasklet(unsigned long arg)
 		prmh->stat_len = PCXHR_SIZE_MAX_LONG_STATUS;
 		err = pcxhr_send_msg(mgr, prmh);
 		if (err)
-			dev_err(&mgr->pci->dev, "ERROR pcxhr_msg_tasklet=%x;\n",
+			dev_err(&mgr->pci->dev, "ERROR pcxhr_msg_thread=%x;\n",
 				   err);
 		i = 1;
 		while (i < prmh->stat_len) {
@@ -1220,9 +1218,9 @@ static void pcxhr_update_timer_pos(struct pcxhr_mgr *mgr,
 		}
 
 		if (elapsed) {
-			spin_unlock(&mgr->lock);
+			mutex_unlock(&mgr->lock);
 			snd_pcm_period_elapsed(stream->substream);
-			spin_lock(&mgr->lock);
+			mutex_lock(&mgr->lock);
 		}
 	}
 }
@@ -1231,14 +1229,10 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 {
 	struct pcxhr_mgr *mgr = dev_id;
 	unsigned int reg;
-	int i, j;
-	struct snd_pcxhr *chip;
-
-	spin_lock(&mgr->lock);
+	bool wake_thread = false;
 
 	reg = PCXHR_INPL(mgr, PCXHR_PLX_IRQCS);
 	if (! (reg & PCXHR_IRQCS_ACTIVE_PCIDB)) {
-		spin_unlock(&mgr->lock);
 		/* this device did not cause the interrupt */
 		return IRQ_NONE;
 	}
@@ -1250,6 +1244,44 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 	/* timer irq occurred */
 	if (reg & PCXHR_IRQ_TIMER) {
 		int timer_toggle = reg & PCXHR_IRQ_TIMER;
+		if (timer_toggle == mgr->timer_toggle) {
+			dev_dbg(&mgr->pci->dev, "ERROR TIMER TOGGLE\n");
+			mgr->dsp_time_err++;
+		}
+
+		mgr->timer_toggle = timer_toggle;
+		mgr->src_it_dsp = reg;
+		wake_thread = true;
+	}
+
+	/* other irq's handled in the thread */
+	if (reg & PCXHR_IRQ_MASK) {
+		if (reg & PCXHR_IRQ_ASYNC) {
+			/* as we didn't request any async notifications,
+			 * some kind of xrun error will probably occurred
+			 */
+			/* better resynchronize all streams next interrupt : */
+			mgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;
+		}
+		mgr->src_it_dsp = reg;
+		wake_thread = true;
+	}
+#ifdef CONFIG_SND_DEBUG_VERBOSE
+	if (reg & PCXHR_FATAL_DSP_ERR)
+		dev_dbg(&mgr->pci->dev, "FATAL DSP ERROR : %x\n", reg);
+#endif
+
+	return wake_thread ? IRQ_WAKE_THREAD : IRQ_HANDLED;
+}
+
+irqreturn_t pcxhr_threaded_irq(int irq, void *dev_id)
+{
+	struct pcxhr_mgr *mgr = dev_id;
+	int i, j;
+	struct snd_pcxhr *chip;
+
+	mutex_lock(&mgr->lock);
+	if (mgr->src_it_dsp & PCXHR_IRQ_TIMER) {
 		/* is a 24 bit counter */
 		int dsp_time_new =
 			PCXHR_INPL(mgr, PCXHR_PLX_MBOX4) & PCXHR_DSP_TIME_MASK;
@@ -1290,13 +1322,6 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 #endif
 		mgr->dsp_time_last = dsp_time_new;
 
-		if (timer_toggle == mgr->timer_toggle) {
-			dev_dbg(&mgr->pci->dev, "ERROR TIMER TOGGLE\n");
-			mgr->dsp_time_err++;
-		}
-		mgr->timer_toggle = timer_toggle;
-
-		reg &= ~PCXHR_IRQ_TIMER;
 		for (i = 0; i < mgr->num_cards; i++) {
 			chip = mgr->chip[i];
 			for (j = 0; j < chip->nb_streams_capt; j++)
@@ -1312,22 +1337,7 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 						dsp_time_diff);
 		}
 	}
-	/* other irq's handled in the tasklet */
-	if (reg & PCXHR_IRQ_MASK) {
-		if (reg & PCXHR_IRQ_ASYNC) {
-			/* as we didn't request any async notifications,
-			 * some kind of xrun error will probably occurred
-			 */
-			/* better resynchronize all streams next interrupt : */
-			mgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;
-		}
-		mgr->src_it_dsp = reg;
-		tasklet_schedule(&mgr->msg_taskq);
-	}
-#ifdef CONFIG_SND_DEBUG_VERBOSE
-	if (reg & PCXHR_FATAL_DSP_ERR)
-		dev_dbg(&mgr->pci->dev, "FATAL DSP ERROR : %x\n", reg);
-#endif
-	spin_unlock(&mgr->lock);
-	return IRQ_HANDLED;	/* this device caused the interrupt */
+
+	pcxhr_msg_thread(mgr);
+	return IRQ_HANDLED;
 }

commit b59bb8efd1c1f2eaeed13eccf1fa4e564d2383ae
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 26 11:47:55 2014 +0100

    ALSA: pcxhr: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index 37b431b9b69d..df9371918601 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -23,6 +23,7 @@
 #include <linux/delay.h>
 #include <linux/firmware.h>
 #include <linux/interrupt.h>
+#include <linux/pci.h>
 #include <asm/io.h>
 #include <sound/core.h>
 #include "pcxhr.h"
@@ -132,14 +133,14 @@ static int pcxhr_check_reg_bit(struct pcxhr_mgr *mgr, unsigned int reg,
 		*read = PCXHR_INPB(mgr, reg);
 		if ((*read & mask) == bit) {
 			if (i > 100)
-				snd_printdd("ATTENTION! check_reg(%x) "
-					    "loopcount=%d\n",
+				dev_dbg(&mgr->pci->dev,
+					"ATTENTION! check_reg(%x) loopcount=%d\n",
 					    reg, i);
 			return 0;
 		}
 		i++;
 	} while (time_after_eq(end_time, jiffies));
-	snd_printk(KERN_ERR
+	dev_err(&mgr->pci->dev,
 		   "pcxhr_check_reg_bit: timeout, reg=%x, mask=0x%x, val=%x\n",
 		   reg, mask, *read);
 	return -EIO;
@@ -216,7 +217,7 @@ static int pcxhr_send_it_dsp(struct pcxhr_mgr *mgr,
 	err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_CVR,  PCXHR_CVR_HI08_HC, 0,
 				  PCXHR_TIMEOUT_DSP, &reg);
 	if (err) {
-		snd_printk(KERN_ERR "pcxhr_send_it_dsp : TIMEOUT CVR\n");
+		dev_err(&mgr->pci->dev, "pcxhr_send_it_dsp : TIMEOUT CVR\n");
 		return err;
 	}
 	if (itdsp & PCXHR_MASK_IT_MANAGE_HF5) {
@@ -227,7 +228,7 @@ static int pcxhr_send_it_dsp(struct pcxhr_mgr *mgr,
 					  PCXHR_TIMEOUT_DSP,
 					  &reg);
 		if (err) {
-			snd_printk(KERN_ERR
+			dev_err(&mgr->pci->dev,
 				   "pcxhr_send_it_dsp : TIMEOUT HF5\n");
 			return err;
 		}
@@ -294,7 +295,7 @@ int pcxhr_load_xilinx_binary(struct pcxhr_mgr *mgr,
 	 */
 	if(second) {
 		if ((chipsc & PCXHR_CHIPSC_GPI_USERI) == 0) {
-			snd_printk(KERN_ERR "error loading first xilinx\n");
+			dev_err(&mgr->pci->dev, "error loading first xilinx\n");
 			return -EINVAL;
 		}
 		/* activate second xilinx */
@@ -360,7 +361,7 @@ static int pcxhr_download_dsp(struct pcxhr_mgr *mgr, const struct firmware *dsp)
 					  PCXHR_ISR_HI08_TRDY,
 					  PCXHR_TIMEOUT_DSP, &dummy);
 		if (err) {
-			snd_printk(KERN_ERR
+			dev_err(&mgr->pci->dev,
 				   "dsp loading error at position %d\n", i);
 			return err;
 		}
@@ -396,7 +397,7 @@ int pcxhr_load_eeprom_binary(struct pcxhr_mgr *mgr,
 		msleep(PCXHR_WAIT_DEFAULT);
 		PCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg);
 		msleep(PCXHR_WAIT_DEFAULT);
-		snd_printdd("no need to load eeprom boot\n");
+		dev_dbg(&mgr->pci->dev, "no need to load eeprom boot\n");
 		return 0;
 	}
 	PCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg);
@@ -561,9 +562,9 @@ static int pcxhr_read_rmh_status(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 					  PCXHR_ISR_HI08_RXDF,
 					  PCXHR_TIMEOUT_DSP, &reg);
 		if (err) {
-			snd_printk(KERN_ERR "ERROR RMH stat: "
-				   "ISR:RXDF=1 (ISR = %x; i=%d )\n",
-				   reg, i);
+			dev_err(&mgr->pci->dev,
+				"ERROR RMH stat: ISR:RXDF=1 (ISR = %x; i=%d )\n",
+				reg, i);
 			return err;
 		}
 		/* read data */
@@ -591,13 +592,13 @@ static int pcxhr_read_rmh_status(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 		}
 #ifdef CONFIG_SND_DEBUG_VERBOSE
 		if (rmh->cmd_idx < CMD_LAST_INDEX)
-			snd_printdd("    stat[%d]=%x\n", i, data);
+			dev_dbg(&mgr->pci->dev, "    stat[%d]=%x\n", i, data);
 #endif
 		if (i < max_stat_len)
 			rmh->stat[i] = data;
 	}
 	if (rmh->stat_len > max_stat_len) {
-		snd_printdd("PCXHR : rmh->stat_len=%x too big\n",
+		dev_dbg(&mgr->pci->dev, "PCXHR : rmh->stat_len=%x too big\n",
 			    rmh->stat_len);
 		rmh->stat_len = max_stat_len;
 	}
@@ -615,7 +616,8 @@ static int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 		return -EINVAL;
 	err = pcxhr_send_it_dsp(mgr, PCXHR_IT_MESSAGE, 1);
 	if (err) {
-		snd_printk(KERN_ERR "pcxhr_send_message : ED_DSP_CRASHED\n");
+		dev_err(&mgr->pci->dev,
+			"pcxhr_send_message : ED_DSP_CRASHED\n");
 		return err;
 	}
 	/* wait for chk bit */
@@ -641,7 +643,7 @@ static int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 		data &= 0xff7fff;	/* MASK_1_WORD_COMMAND */
 #ifdef CONFIG_SND_DEBUG_VERBOSE
 	if (rmh->cmd_idx < CMD_LAST_INDEX)
-		snd_printdd("MSG cmd[0]=%x (%s)\n",
+		dev_dbg(&mgr->pci->dev, "MSG cmd[0]=%x (%s)\n",
 			    data, cmd_names[rmh->cmd_idx]);
 #endif
 
@@ -671,7 +673,8 @@ static int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 			data = rmh->cmd[i];
 #ifdef CONFIG_SND_DEBUG_VERBOSE
 			if (rmh->cmd_idx < CMD_LAST_INDEX)
-				snd_printdd("    cmd[%d]=%x\n", i, data);
+				dev_dbg(&mgr->pci->dev,
+					"    cmd[%d]=%x\n", i, data);
 #endif
 			err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,
 						  PCXHR_ISR_HI08_TRDY,
@@ -697,14 +700,15 @@ static int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 					  PCXHR_ISR_HI08_RXDF,
 					  PCXHR_TIMEOUT_DSP, &reg);
 		if (err) {
-			snd_printk(KERN_ERR "ERROR RMH: ISR:RXDF=1 (ISR = %x)\n", reg);
+			dev_err(&mgr->pci->dev,
+				"ERROR RMH: ISR:RXDF=1 (ISR = %x)\n", reg);
 			return err;
 		}
 		/* read error code */
 		data  = PCXHR_INPB(mgr, PCXHR_DSP_TXH) << 16;
 		data |= PCXHR_INPB(mgr, PCXHR_DSP_TXM) << 8;
 		data |= PCXHR_INPB(mgr, PCXHR_DSP_TXL);
-		snd_printk(KERN_ERR "ERROR RMH(%d): 0x%x\n",
+		dev_err(&mgr->pci->dev, "ERROR RMH(%d): 0x%x\n",
 			   rmh->cmd_idx, data);
 		err = -EINVAL;
 	} else {
@@ -780,7 +784,7 @@ static inline int pcxhr_pipes_running(struct pcxhr_mgr *mgr)
 	 * (PCXHR_PIPE_STATE_CAPTURE_OFFSET)
 	 */
 	start_mask &= 0xffffff;
-	snd_printdd("CMD_PIPE_STATE MBOX2=0x%06x\n", start_mask);
+	dev_dbg(&mgr->pci->dev, "CMD_PIPE_STATE MBOX2=0x%06x\n", start_mask);
 	return start_mask;
 }
 
@@ -809,7 +813,7 @@ static int pcxhr_prepair_pipe_start(struct pcxhr_mgr *mgr,
 			}
 			err = pcxhr_send_msg(mgr, &rmh);
 			if (err) {
-				snd_printk(KERN_ERR
+				dev_err(&mgr->pci->dev,
 					   "error pipe start "
 					   "(CMD_CAN_START_PIPE) err=%x!\n",
 					   err);
@@ -847,7 +851,7 @@ static int pcxhr_stop_pipes(struct pcxhr_mgr *mgr, int audio_mask)
 			}
 			err = pcxhr_send_msg(mgr, &rmh);
 			if (err) {
-				snd_printk(KERN_ERR
+				dev_err(&mgr->pci->dev,
 					   "error pipe stop "
 					   "(CMD_STOP_PIPE) err=%x!\n", err);
 				return err;
@@ -876,7 +880,7 @@ static int pcxhr_toggle_pipes(struct pcxhr_mgr *mgr, int audio_mask)
 							  1 << (audio - PCXHR_PIPE_STATE_CAPTURE_OFFSET));
 			err = pcxhr_send_msg(mgr, &rmh);
 			if (err) {
-				snd_printk(KERN_ERR
+				dev_err(&mgr->pci->dev,
 					   "error pipe start "
 					   "(CMD_CONF_PIPE) err=%x!\n", err);
 				return err;
@@ -889,7 +893,7 @@ static int pcxhr_toggle_pipes(struct pcxhr_mgr *mgr, int audio_mask)
 	pcxhr_init_rmh(&rmh, CMD_SEND_IRQA);
 	err = pcxhr_send_msg(mgr, &rmh);
 	if (err) {
-		snd_printk(KERN_ERR
+		dev_err(&mgr->pci->dev,
 			   "error pipe start (CMD_SEND_IRQA) err=%x!\n",
 			   err);
 		return err;
@@ -913,7 +917,8 @@ int pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask,
 		      (capture_mask << PCXHR_PIPE_STATE_CAPTURE_OFFSET));
 	/* current pipe state (playback + record) */
 	state = pcxhr_pipes_running(mgr);
-	snd_printdd("pcxhr_set_pipe_state %s (mask %x current %x)\n",
+	dev_dbg(&mgr->pci->dev,
+		"pcxhr_set_pipe_state %s (mask %x current %x)\n",
 		    start ? "START" : "STOP", audio_mask, state);
 	if (start) {
 		/* start only pipes that are not yet started */
@@ -944,7 +949,7 @@ int pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask,
 		if ((state & audio_mask) == (start ? audio_mask : 0))
 			break;
 		if (++i >= MAX_WAIT_FOR_DSP * 100) {
-			snd_printk(KERN_ERR "error pipe start/stop\n");
+			dev_err(&mgr->pci->dev, "error pipe start/stop\n");
 			return -EBUSY;
 		}
 		udelay(10);			/* wait 10 microseconds */
@@ -956,7 +961,7 @@ int pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask,
 	}
 #ifdef CONFIG_SND_DEBUG_VERBOSE
 	do_gettimeofday(&my_tv2);
-	snd_printdd("***SET PIPE STATE*** TIME = %ld (err = %x)\n",
+	dev_dbg(&mgr->pci->dev, "***SET PIPE STATE*** TIME = %ld (err = %x)\n",
 		    (long)(my_tv2.tv_usec - my_tv1.tv_usec), err);
 #endif
 	return 0;
@@ -971,7 +976,8 @@ int pcxhr_write_io_num_reg_cont(struct pcxhr_mgr *mgr, unsigned int mask,
 
 	spin_lock_irqsave(&mgr->msg_lock, flags);
 	if ((mgr->io_num_reg_cont & mask) == value) {
-		snd_printdd("IO_NUM_REG_CONT mask %x already is set to %x\n",
+		dev_dbg(&mgr->pci->dev,
+			"IO_NUM_REG_CONT mask %x already is set to %x\n",
 			    mask, value);
 		if (changed)
 			*changed = 0;
@@ -1024,7 +1030,7 @@ static int pcxhr_handle_async_err(struct pcxhr_mgr *mgr, u32 err,
 		err = ((err >> 12) & 0xfff);
 	if (!err)
 		return 0;
-	snd_printdd("CMD_ASYNC : Error %s %s Pipe %d err=%x\n",
+	dev_dbg(&mgr->pci->dev, "CMD_ASYNC : Error %s %s Pipe %d err=%x\n",
 		    err_src_name[err_src],
 		    is_capture ? "Record" : "Play", pipe, err);
 	if (err == 0xe01)
@@ -1045,20 +1051,24 @@ void pcxhr_msg_tasklet(unsigned long arg)
 	int i, j;
 
 	if (mgr->src_it_dsp & PCXHR_IRQ_FREQ_CHANGE)
-		snd_printdd("TASKLET : PCXHR_IRQ_FREQ_CHANGE event occurred\n");
+		dev_dbg(&mgr->pci->dev,
+			"TASKLET : PCXHR_IRQ_FREQ_CHANGE event occurred\n");
 	if (mgr->src_it_dsp & PCXHR_IRQ_TIME_CODE)
-		snd_printdd("TASKLET : PCXHR_IRQ_TIME_CODE event occurred\n");
+		dev_dbg(&mgr->pci->dev,
+			"TASKLET : PCXHR_IRQ_TIME_CODE event occurred\n");
 	if (mgr->src_it_dsp & PCXHR_IRQ_NOTIFY)
-		snd_printdd("TASKLET : PCXHR_IRQ_NOTIFY event occurred\n");
+		dev_dbg(&mgr->pci->dev,
+			"TASKLET : PCXHR_IRQ_NOTIFY event occurred\n");
 	if (mgr->src_it_dsp & (PCXHR_IRQ_FREQ_CHANGE | PCXHR_IRQ_TIME_CODE)) {
 		/* clear events FREQ_CHANGE and TIME_CODE */
 		pcxhr_init_rmh(prmh, CMD_TEST_IT);
 		err = pcxhr_send_msg(mgr, prmh);
-		snd_printdd("CMD_TEST_IT : err=%x, stat=%x\n",
+		dev_dbg(&mgr->pci->dev, "CMD_TEST_IT : err=%x, stat=%x\n",
 			    err, prmh->stat[0]);
 	}
 	if (mgr->src_it_dsp & PCXHR_IRQ_ASYNC) {
-		snd_printdd("TASKLET : PCXHR_IRQ_ASYNC event occurred\n");
+		dev_dbg(&mgr->pci->dev,
+			"TASKLET : PCXHR_IRQ_ASYNC event occurred\n");
 
 		pcxhr_init_rmh(prmh, CMD_ASYNC);
 		prmh->cmd[0] |= 1;	/* add SEL_ASYNC_EVENTS */
@@ -1066,7 +1076,7 @@ void pcxhr_msg_tasklet(unsigned long arg)
 		prmh->stat_len = PCXHR_SIZE_MAX_LONG_STATUS;
 		err = pcxhr_send_msg(mgr, prmh);
 		if (err)
-			snd_printk(KERN_ERR "ERROR pcxhr_msg_tasklet=%x;\n",
+			dev_err(&mgr->pci->dev, "ERROR pcxhr_msg_tasklet=%x;\n",
 				   err);
 		i = 1;
 		while (i < prmh->stat_len) {
@@ -1079,7 +1089,8 @@ void pcxhr_msg_tasklet(unsigned long arg)
 			u32 err2;
 
 			if (prmh->stat[i] & 0x800000) {	/* if BIT_END */
-				snd_printdd("TASKLET : End%sPipe %d\n",
+				dev_dbg(&mgr->pci->dev,
+					"TASKLET : End%sPipe %d\n",
 					    is_capture ? "Record" : "Play",
 					    pipe);
 			}
@@ -1136,7 +1147,8 @@ static u_int64_t pcxhr_stream_read_position(struct pcxhr_mgr *mgr,
 	hw_sample_count = ((u_int64_t)rmh.stat[0]) << 24;
 	hw_sample_count += (u_int64_t)rmh.stat[1];
 
-	snd_printdd("stream %c%d : abs samples real(%llu) timer(%llu)\n",
+	dev_dbg(&mgr->pci->dev,
+		"stream %c%d : abs samples real(%llu) timer(%llu)\n",
 		    stream->pipe->is_capture ? 'C' : 'P',
 		    stream->substream->number,
 		    hw_sample_count,
@@ -1202,7 +1214,7 @@ static void pcxhr_update_timer_pos(struct pcxhr_mgr *mgr,
 				(u_int32_t)(new_sample_count -
 					    stream->timer_abs_periods);
 		} else {
-			snd_printk(KERN_ERR
+			dev_err(&mgr->pci->dev,
 				   "ERROR new_sample_count too small ??? %ld\n",
 				   (long unsigned int)new_sample_count);
 		}
@@ -1247,33 +1259,39 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 		    (mgr->dsp_time_last != PCXHR_DSP_TIME_INVALID)) {
 			/* handle dsp counter wraparound without resync */
 			int tmp_diff = dsp_time_diff + PCXHR_DSP_TIME_MASK + 1;
-			snd_printdd("WARNING DSP timestamp old(%d) new(%d)",
+			dev_dbg(&mgr->pci->dev,
+				"WARNING DSP timestamp old(%d) new(%d)",
 				    mgr->dsp_time_last, dsp_time_new);
 			if (tmp_diff > 0 && tmp_diff <= (2*mgr->granularity)) {
-				snd_printdd("-> timestamp wraparound OK: "
+				dev_dbg(&mgr->pci->dev,
+					"-> timestamp wraparound OK: "
 					    "diff=%d\n", tmp_diff);
 				dsp_time_diff = tmp_diff;
 			} else {
-				snd_printdd("-> resynchronize all streams\n");
+				dev_dbg(&mgr->pci->dev,
+					"-> resynchronize all streams\n");
 				mgr->dsp_time_err++;
 			}
 		}
 #ifdef CONFIG_SND_DEBUG_VERBOSE
 		if (dsp_time_diff == 0)
-			snd_printdd("ERROR DSP TIME NO DIFF time(%d)\n",
+			dev_dbg(&mgr->pci->dev,
+				"ERROR DSP TIME NO DIFF time(%d)\n",
 				    dsp_time_new);
 		else if (dsp_time_diff >= (2*mgr->granularity))
-			snd_printdd("ERROR DSP TIME TOO BIG old(%d) add(%d)\n",
+			dev_dbg(&mgr->pci->dev,
+				"ERROR DSP TIME TOO BIG old(%d) add(%d)\n",
 				    mgr->dsp_time_last,
 				    dsp_time_new - mgr->dsp_time_last);
 		else if (dsp_time_diff % mgr->granularity)
-			snd_printdd("ERROR DSP TIME increased by %d\n",
+			dev_dbg(&mgr->pci->dev,
+				"ERROR DSP TIME increased by %d\n",
 				    dsp_time_diff);
 #endif
 		mgr->dsp_time_last = dsp_time_new;
 
 		if (timer_toggle == mgr->timer_toggle) {
-			snd_printdd("ERROR TIMER TOGGLE\n");
+			dev_dbg(&mgr->pci->dev, "ERROR TIMER TOGGLE\n");
 			mgr->dsp_time_err++;
 		}
 		mgr->timer_toggle = timer_toggle;
@@ -1308,7 +1326,7 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 	}
 #ifdef CONFIG_SND_DEBUG_VERBOSE
 	if (reg & PCXHR_FATAL_DSP_ERR)
-		snd_printdd("FATAL DSP ERROR : %x\n", reg);
+		dev_dbg(&mgr->pci->dev, "FATAL DSP ERROR : %x\n", reg);
 #endif
 	spin_unlock(&mgr->lock);
 	return IRQ_HANDLED;	/* this device caused the interrupt */

commit 86b2723725a2e186f5699d97cb20014fa893931f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 25 10:54:07 2013 +0100

    ALSA: Make snd_printd() and snd_printdd() inline
    
    Because currently snd_printd() and snd_printdd() macros are expanded
    to empty when CONFIG_SND_DEBUG=n, a compile warning like below
    appears sometimes, and we had to covert it by ugly ifdefs:
      sound/pci/hda/patch_sigmatel.c: In function ‘stac92hd71bxx_fixup_hp’:
      sound/pci/hda/patch_sigmatel.c:2434:24: warning: unused variable ‘spec’ [-Wunused-variable]
    
    For "fixing" these issues better, this patch replaces snd_printd() and
    snd_printdd() definitions with empty inline functions instead of
    macros.  This should have the same effect but shut up warnings like
    above.
    
    But since we had already put ifdefs, changing to inline functions
    would trigger compile errors.  So, such ifdefs is removed in this
    patch.
    
    In addition, snd_pci_quirk name field is defined only when
    CONFIG_SND_DEBUG_VERBOSE is set, and the reference to it in
    snd_printdd() argument triggers the build errors, too.  For avoiding
    these errors, introduce a new macro snd_pci_quirk_name() that is
    defined no matter how the debug option is set.
    
    Reported-by: Stratos Karafotis <stratosk@semaphore.gr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index b33db1e006e7..37b431b9b69d 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -1012,13 +1012,12 @@ static int pcxhr_handle_async_err(struct pcxhr_mgr *mgr, u32 err,
 				  enum pcxhr_async_err_src err_src, int pipe,
 				  int is_capture)
 {
-#ifdef CONFIG_SND_DEBUG_VERBOSE
 	static char* err_src_name[] = {
 		[PCXHR_ERR_PIPE]	= "Pipe",
 		[PCXHR_ERR_STREAM]	= "Stream",
 		[PCXHR_ERR_AUDIO]	= "Audio"
 	};
-#endif
+
 	if (err & 0xfff)
 		err &= 0xfff;
 	else

commit fdfbaf69e0b9d6843c0da6501caf4ecacec0f775
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Wed Jun 20 08:34:40 2012 +0200

    ALSA: pcxhr: Add LTC support
    
    add LTC (linear timecode) read function via proc interface to the pcxhr driver
    
    Signed-off-by: Markus Bollinger <bollinger@digigram.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index 841703b5c52a..b33db1e006e7 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -504,6 +504,8 @@ static struct pcxhr_cmd_info pcxhr_dsp_cmds[] = {
 [CMD_FORMAT_STREAM_IN] =		{ 0x870000, 0, RMH_SSIZE_FIXED },
 [CMD_STREAM_SAMPLE_COUNT] =		{ 0x902000, 2, RMH_SSIZE_FIXED },
 [CMD_AUDIO_LEVEL_ADJUST] =		{ 0xc22000, 0, RMH_SSIZE_FIXED },
+[CMD_GET_TIME_CODE] =			{ 0x060000, 5, RMH_SSIZE_FIXED },
+[CMD_MANAGE_SIGNAL] =			{ 0x0f0000, 0, RMH_SSIZE_FIXED },
 };
 
 #ifdef CONFIG_SND_DEBUG_VERBOSE
@@ -533,6 +535,8 @@ static char* cmd_names[] = {
 [CMD_FORMAT_STREAM_IN] =		"CMD_FORMAT_STREAM_IN",
 [CMD_STREAM_SAMPLE_COUNT] =		"CMD_STREAM_SAMPLE_COUNT",
 [CMD_AUDIO_LEVEL_ADJUST] =		"CMD_AUDIO_LEVEL_ADJUST",
+[CMD_GET_TIME_CODE] =			"CMD_GET_TIME_CODE",
+[CMD_MANAGE_SIGNAL] =			"CMD_MANAGE_SIGNAL",
 };
 #endif
 

commit d7dc9e32ae64b5db777017344da61a285c2347f8
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Wed Jun 20 08:32:48 2012 +0200

    ALSA: pcxhr: Fix a counter wrap
    
    fix a counter wrap to avoid resynchronization of stream positions every several
    minutes. The resynchronization may create stream position jitter
    
    Signed-off-by: Markus Bollinger <bollinger@digigram.com>
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index 304411c1fe4b..841703b5c52a 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -1133,13 +1133,12 @@ static u_int64_t pcxhr_stream_read_position(struct pcxhr_mgr *mgr,
 	hw_sample_count = ((u_int64_t)rmh.stat[0]) << 24;
 	hw_sample_count += (u_int64_t)rmh.stat[1];
 
-	snd_printdd("stream %c%d : abs samples real(%ld) timer(%ld)\n",
+	snd_printdd("stream %c%d : abs samples real(%llu) timer(%llu)\n",
 		    stream->pipe->is_capture ? 'C' : 'P',
 		    stream->substream->number,
-		    (long unsigned int)hw_sample_count,
-		    (long unsigned int)(stream->timer_abs_periods +
-					stream->timer_period_frag +
-					mgr->granularity));
+		    hw_sample_count,
+		    stream->timer_abs_periods + stream->timer_period_frag +
+						mgr->granularity);
 	return hw_sample_count;
 }
 
@@ -1243,10 +1242,18 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 
 		if ((dsp_time_diff < 0) &&
 		    (mgr->dsp_time_last != PCXHR_DSP_TIME_INVALID)) {
-			snd_printdd("ERROR DSP TIME old(%d) new(%d) -> "
-				    "resynchronize all streams\n",
+			/* handle dsp counter wraparound without resync */
+			int tmp_diff = dsp_time_diff + PCXHR_DSP_TIME_MASK + 1;
+			snd_printdd("WARNING DSP timestamp old(%d) new(%d)",
 				    mgr->dsp_time_last, dsp_time_new);
-			mgr->dsp_time_err++;
+			if (tmp_diff > 0 && tmp_diff <= (2*mgr->granularity)) {
+				snd_printdd("-> timestamp wraparound OK: "
+					    "diff=%d\n", tmp_diff);
+				dsp_time_diff = tmp_diff;
+			} else {
+				snd_printdd("-> resynchronize all streams\n");
+				mgr->dsp_time_err++;
+			}
 		}
 #ifdef CONFIG_SND_DEBUG_VERBOSE
 		if (dsp_time_diff == 0)

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index 833e7180ad2d..304411c1fe4b 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -1042,11 +1042,11 @@ void pcxhr_msg_tasklet(unsigned long arg)
 	int i, j;
 
 	if (mgr->src_it_dsp & PCXHR_IRQ_FREQ_CHANGE)
-		snd_printdd("TASKLET : PCXHR_IRQ_FREQ_CHANGE event occured\n");
+		snd_printdd("TASKLET : PCXHR_IRQ_FREQ_CHANGE event occurred\n");
 	if (mgr->src_it_dsp & PCXHR_IRQ_TIME_CODE)
-		snd_printdd("TASKLET : PCXHR_IRQ_TIME_CODE event occured\n");
+		snd_printdd("TASKLET : PCXHR_IRQ_TIME_CODE event occurred\n");
 	if (mgr->src_it_dsp & PCXHR_IRQ_NOTIFY)
-		snd_printdd("TASKLET : PCXHR_IRQ_NOTIFY event occured\n");
+		snd_printdd("TASKLET : PCXHR_IRQ_NOTIFY event occurred\n");
 	if (mgr->src_it_dsp & (PCXHR_IRQ_FREQ_CHANGE | PCXHR_IRQ_TIME_CODE)) {
 		/* clear events FREQ_CHANGE and TIME_CODE */
 		pcxhr_init_rmh(prmh, CMD_TEST_IT);
@@ -1055,7 +1055,7 @@ void pcxhr_msg_tasklet(unsigned long arg)
 			    err, prmh->stat[0]);
 	}
 	if (mgr->src_it_dsp & PCXHR_IRQ_ASYNC) {
-		snd_printdd("TASKLET : PCXHR_IRQ_ASYNC event occured\n");
+		snd_printdd("TASKLET : PCXHR_IRQ_ASYNC event occurred\n");
 
 		pcxhr_init_rmh(prmh, CMD_ASYNC);
 		prmh->cmd[0] |= 1;	/* add SEL_ASYNC_EVENTS */
@@ -1233,7 +1233,7 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 	reg = PCXHR_INPL(mgr, PCXHR_PLX_L2PCIDB);
 	PCXHR_OUTPL(mgr, PCXHR_PLX_L2PCIDB, reg);
 
-	/* timer irq occured */
+	/* timer irq occurred */
 	if (reg & PCXHR_IRQ_TIMER) {
 		int timer_toggle = reg & PCXHR_IRQ_TIMER;
 		/* is a 24 bit counter */
@@ -1288,7 +1288,7 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 	if (reg & PCXHR_IRQ_MASK) {
 		if (reg & PCXHR_IRQ_ASYNC) {
 			/* as we didn't request any async notifications,
-			 * some kind of xrun error will probably occured
+			 * some kind of xrun error will probably occurred
 			 */
 			/* better resynchronize all streams next interrupt : */
 			mgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;

commit a9c3c7e04b9a744eafb2e87c770e7300bbffa375
Merge: cc4910850f93 ade9b2fb9bf8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 25 11:40:31 2008 +0100

    Merge branch 'topic/pcxhr-update' into to-push

commit 1f04128a3db7c0f0e8b5d25323eba70ac342f47f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 18 12:17:55 2008 +0100

    ALSA: hda - Convert from takslet_hi_schedule() to tasklet_schedule()
    
    Replace all tasklet_hi_schedule() callers with the normal
    tasklet_schedule().  The former often causes troubles with
    RT-kernels, and has actually no merit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index 7143259cfe34..4a5481f9781f 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -1213,7 +1213,7 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 		mgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;
 		
 		mgr->src_it_dsp = reg;
-		tasklet_hi_schedule(&mgr->msg_taskq);
+		tasklet_schedule(&mgr->msg_taskq);
 	}
 #ifdef CONFIG_SND_DEBUG_VERBOSE
 	if (reg & PCXHR_FATAL_DSP_ERR)

commit 93bf5d8753b2e3cc9e8982d551d119a54a31a7ec
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Tue Nov 25 12:21:05 2008 +0100

    ALSA: pcxhr - add support for pcxhr stereo sound cards
    
    - Add support for pcxhr stereo cards
    - do some clean up
    
    Signed-off-by: Markus Bollinger <bollinger@digigram.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index 7143259cfe34..d5f18226261d 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -132,13 +132,15 @@ static int pcxhr_check_reg_bit(struct pcxhr_mgr *mgr, unsigned int reg,
 		*read = PCXHR_INPB(mgr, reg);
 		if ((*read & mask) == bit) {
 			if (i > 100)
-				snd_printdd("ATTENTION! check_reg(%x) loopcount=%d\n",
+				snd_printdd("ATTENTION! check_reg(%x) "
+					    "loopcount=%d\n",
 					    reg, i);
 			return 0;
 		}
 		i++;
 	} while (time_after_eq(end_time, jiffies));
-	snd_printk(KERN_ERR "pcxhr_check_reg_bit: timeout, reg=%x, mask=0x%x, val=0x%x\n",
+	snd_printk(KERN_ERR
+		   "pcxhr_check_reg_bit: timeout, reg=%x, mask=0x%x, val=%x\n",
 		   reg, mask, *read);
 	return -EIO;
 }
@@ -159,18 +161,22 @@ static int pcxhr_check_reg_bit(struct pcxhr_mgr *mgr, unsigned int reg,
 #define PCXHR_IT_TEST_XILINX		(0x0000003C | PCXHR_MASK_IT_HF1 | \
 					 PCXHR_MASK_IT_MANAGE_HF5)
 #define PCXHR_IT_DOWNLOAD_BOOT		(0x0000000C | PCXHR_MASK_IT_HF1 | \
-					 PCXHR_MASK_IT_MANAGE_HF5 | PCXHR_MASK_IT_WAIT)
+					 PCXHR_MASK_IT_MANAGE_HF5 | \
+					 PCXHR_MASK_IT_WAIT)
 #define PCXHR_IT_RESET_BOARD_FUNC	(0x0000000C | PCXHR_MASK_IT_HF0 | \
-					 PCXHR_MASK_IT_MANAGE_HF5 | PCXHR_MASK_IT_WAIT_EXTRA)
+					 PCXHR_MASK_IT_MANAGE_HF5 | \
+					 PCXHR_MASK_IT_WAIT_EXTRA)
 #define PCXHR_IT_DOWNLOAD_DSP		(0x0000000C | \
-					 PCXHR_MASK_IT_MANAGE_HF5 | PCXHR_MASK_IT_WAIT)
+					 PCXHR_MASK_IT_MANAGE_HF5 | \
+					 PCXHR_MASK_IT_WAIT)
 #define PCXHR_IT_DEBUG			(0x0000005A | PCXHR_MASK_IT_NO_HF0_HF1)
 #define PCXHR_IT_RESET_SEMAPHORE	(0x0000005C | PCXHR_MASK_IT_NO_HF0_HF1)
 #define PCXHR_IT_MESSAGE		(0x00000074 | PCXHR_MASK_IT_NO_HF0_HF1)
 #define PCXHR_IT_RESET_CHK		(0x00000076 | PCXHR_MASK_IT_NO_HF0_HF1)
 #define PCXHR_IT_UPDATE_RBUFFER		(0x00000078 | PCXHR_MASK_IT_NO_HF0_HF1)
 
-static int pcxhr_send_it_dsp(struct pcxhr_mgr *mgr, unsigned int itdsp, int atomic)
+static int pcxhr_send_it_dsp(struct pcxhr_mgr *mgr,
+			     unsigned int itdsp, int atomic)
 {
 	int err;
 	unsigned char reg;
@@ -178,17 +184,21 @@ static int pcxhr_send_it_dsp(struct pcxhr_mgr *mgr, unsigned int itdsp, int atom
 	if (itdsp & PCXHR_MASK_IT_MANAGE_HF5) {
 		/* clear hf5 bit */
 		PCXHR_OUTPL(mgr, PCXHR_PLX_MBOX0,
-			    PCXHR_INPL(mgr, PCXHR_PLX_MBOX0) & ~PCXHR_MBOX0_HF5);
+			    PCXHR_INPL(mgr, PCXHR_PLX_MBOX0) &
+			    ~PCXHR_MBOX0_HF5);
 	}
 	if ((itdsp & PCXHR_MASK_IT_NO_HF0_HF1) == 0) {
-		reg = PCXHR_ICR_HI08_RREQ | PCXHR_ICR_HI08_TREQ | PCXHR_ICR_HI08_HDRQ;
+		reg = (PCXHR_ICR_HI08_RREQ |
+		       PCXHR_ICR_HI08_TREQ |
+		       PCXHR_ICR_HI08_HDRQ);
 		if (itdsp & PCXHR_MASK_IT_HF0)
 			reg |= PCXHR_ICR_HI08_HF0;
 		if (itdsp & PCXHR_MASK_IT_HF1)
 			reg |= PCXHR_ICR_HI08_HF1;
 		PCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg);
 	}
-	reg = (unsigned char)(((itdsp & PCXHR_MASK_EXTRA_INFO) >> 1) | PCXHR_CVR_HI08_HC);
+	reg = (unsigned char)(((itdsp & PCXHR_MASK_EXTRA_INFO) >> 1) |
+			      PCXHR_CVR_HI08_HC);
 	PCXHR_OUTPB(mgr, PCXHR_DSP_CVR, reg);
 	if (itdsp & PCXHR_MASK_IT_WAIT) {
 		if (atomic)
@@ -211,10 +221,14 @@ static int pcxhr_send_it_dsp(struct pcxhr_mgr *mgr, unsigned int itdsp, int atom
 	}
 	if (itdsp & PCXHR_MASK_IT_MANAGE_HF5) {
 		/* wait for hf5 bit */
-		err = pcxhr_check_reg_bit(mgr, PCXHR_PLX_MBOX0, PCXHR_MBOX0_HF5,
-					  PCXHR_MBOX0_HF5, PCXHR_TIMEOUT_DSP, &reg);
+		err = pcxhr_check_reg_bit(mgr, PCXHR_PLX_MBOX0,
+					  PCXHR_MBOX0_HF5,
+					  PCXHR_MBOX0_HF5,
+					  PCXHR_TIMEOUT_DSP,
+					  &reg);
 		if (err) {
-			snd_printk(KERN_ERR "pcxhr_send_it_dsp : TIMEOUT HF5\n");
+			snd_printk(KERN_ERR
+				   "pcxhr_send_it_dsp : TIMEOUT HF5\n");
 			return err;
 		}
 	}
@@ -263,7 +277,8 @@ void pcxhr_enable_dsp(struct pcxhr_mgr *mgr)
 /*
  * load the xilinx image
  */
-int pcxhr_load_xilinx_binary(struct pcxhr_mgr *mgr, const struct firmware *xilinx, int second)
+int pcxhr_load_xilinx_binary(struct pcxhr_mgr *mgr,
+			     const struct firmware *xilinx, int second)
 {
 	unsigned int i;
 	unsigned int chipsc;
@@ -274,7 +289,9 @@ int pcxhr_load_xilinx_binary(struct pcxhr_mgr *mgr, const struct firmware *xilin
 	/* test first xilinx */
 	chipsc = PCXHR_INPL(mgr, PCXHR_PLX_CHIPSC);
 	/* REV01 cards do not support the PCXHR_CHIPSC_GPI_USERI bit anymore */
-	/* this bit will always be 1; no possibility to test presence of first xilinx */
+	/* this bit will always be 1;
+	 * no possibility to test presence of first xilinx
+	 */
 	if(second) {
 		if ((chipsc & PCXHR_CHIPSC_GPI_USERI) == 0) {
 			snd_printk(KERN_ERR "error loading first xilinx\n");
@@ -290,7 +307,8 @@ int pcxhr_load_xilinx_binary(struct pcxhr_mgr *mgr, const struct firmware *xilin
 		data = *image;
 		mask = 0x80;
 		while (mask) {
-			chipsc &= ~(PCXHR_CHIPSC_DATA_CLK | PCXHR_CHIPSC_DATA_IN);
+			chipsc &= ~(PCXHR_CHIPSC_DATA_CLK |
+				    PCXHR_CHIPSC_DATA_IN);
 			if (data & mask)
 				chipsc |= PCXHR_CHIPSC_DATA_IN;
 			PCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC, chipsc);
@@ -330,15 +348,20 @@ static int pcxhr_download_dsp(struct pcxhr_mgr *mgr, const struct firmware *dsp)
 		data = dsp->data + i;
 		if (i == 0) {
 			/* test data header consistency */
-			len = (unsigned int)((data[0]<<16) + (data[1]<<8) + data[2]);
-			if (len && dsp->size != (len + 2) * 3)
+			len = (unsigned int)((data[0]<<16) +
+					     (data[1]<<8) +
+					     data[2]);
+			if (len && (dsp->size != (len + 2) * 3))
 				return -EINVAL;
 		}
 		/* wait DSP ready for new transfer */
-		err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_TRDY,
-					  PCXHR_ISR_HI08_TRDY, PCXHR_TIMEOUT_DSP, &dummy);
+		err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,
+					  PCXHR_ISR_HI08_TRDY,
+					  PCXHR_ISR_HI08_TRDY,
+					  PCXHR_TIMEOUT_DSP, &dummy);
 		if (err) {
-			snd_printk(KERN_ERR "dsp loading error at position %d\n", i);
+			snd_printk(KERN_ERR
+				   "dsp loading error at position %d\n", i);
 			return err;
 		}
 		/* send host data */
@@ -357,7 +380,8 @@ static int pcxhr_download_dsp(struct pcxhr_mgr *mgr, const struct firmware *dsp)
 /*
  * load the eeprom image
  */
-int pcxhr_load_eeprom_binary(struct pcxhr_mgr *mgr, const struct firmware *eeprom)
+int pcxhr_load_eeprom_binary(struct pcxhr_mgr *mgr,
+			     const struct firmware *eeprom)
 {
 	int err;
 	unsigned char reg;
@@ -365,7 +389,9 @@ int pcxhr_load_eeprom_binary(struct pcxhr_mgr *mgr, const struct firmware *eepro
 	/* init value of the ICR register */
 	reg = PCXHR_ICR_HI08_RREQ | PCXHR_ICR_HI08_TREQ | PCXHR_ICR_HI08_HDRQ;
 	if (PCXHR_INPL(mgr, PCXHR_PLX_MBOX0) & PCXHR_MBOX0_BOOT_HERE) {
-		/* no need to load the eeprom binary, but init the HI08 interface */
+		/* no need to load the eeprom binary,
+		 * but init the HI08 interface
+		 */
 		PCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg | PCXHR_ICR_HI08_INIT);
 		msleep(PCXHR_WAIT_DEFAULT);
 		PCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg);
@@ -429,8 +455,10 @@ int pcxhr_load_dsp_binary(struct pcxhr_mgr *mgr, const struct firmware *dsp)
 	if (err)
 		return err;
 	/* wait for chk bit */
-	return pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_CHK,
-				   PCXHR_ISR_HI08_CHK, PCXHR_TIMEOUT_DSP, &dummy);
+	return pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,
+				   PCXHR_ISR_HI08_CHK,
+				   PCXHR_ISR_HI08_CHK,
+				   PCXHR_TIMEOUT_DSP, &dummy);
 }
 
 
@@ -443,8 +471,8 @@ struct pcxhr_cmd_info {
 /* RMH status type */
 enum {
 	RMH_SSIZE_FIXED = 0,	/* status size fix (st_length = 0..x) */
-	RMH_SSIZE_ARG = 1,	/* status size given in the LSB byte (used with st_length = 1) */
-	RMH_SSIZE_MASK = 2,	/* status size given in bitmask  (used with st_length = 1) */
+	RMH_SSIZE_ARG = 1,	/* status size given in the LSB byte */
+	RMH_SSIZE_MASK = 2,	/* status size given in bitmask */
 };
 
 /*
@@ -474,7 +502,7 @@ static struct pcxhr_cmd_info pcxhr_dsp_cmds[] = {
 [CMD_UPDATE_R_BUFFERS] =		{ 0x840000, 0, RMH_SSIZE_FIXED },
 [CMD_FORMAT_STREAM_OUT] =		{ 0x860000, 0, RMH_SSIZE_FIXED },
 [CMD_FORMAT_STREAM_IN] =		{ 0x870000, 0, RMH_SSIZE_FIXED },
-[CMD_STREAM_SAMPLE_COUNT] =		{ 0x902000, 2, RMH_SSIZE_FIXED },	/* stat_len = nb_streams * 2 */
+[CMD_STREAM_SAMPLE_COUNT] =		{ 0x902000, 2, RMH_SSIZE_FIXED },
 [CMD_AUDIO_LEVEL_ADJUST] =		{ 0xc22000, 0, RMH_SSIZE_FIXED },
 };
 
@@ -524,10 +552,13 @@ static int pcxhr_read_rmh_status(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 
 	for (i = 0; i < rmh->stat_len; i++) {
 		/* wait for receiver full */
-		err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_RXDF,
-					  PCXHR_ISR_HI08_RXDF, PCXHR_TIMEOUT_DSP, &reg);
+		err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,
+					  PCXHR_ISR_HI08_RXDF,
+					  PCXHR_ISR_HI08_RXDF,
+					  PCXHR_TIMEOUT_DSP, &reg);
 		if (err) {
-			snd_printk(KERN_ERR "ERROR RMH stat: ISR:RXDF=1 (ISR = %x; i=%d )\n",
+			snd_printk(KERN_ERR "ERROR RMH stat: "
+				   "ISR:RXDF=1 (ISR = %x; i=%d )\n",
 				   reg, i);
 			return err;
 		}
@@ -537,10 +568,10 @@ static int pcxhr_read_rmh_status(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 		data |= PCXHR_INPB(mgr, PCXHR_DSP_TXL);
 
 		/* need to update rmh->stat_len on the fly ?? */
-		if (i==0) {
+		if (!i) {
 			if (rmh->dsp_stat != RMH_SSIZE_FIXED) {
 				if (rmh->dsp_stat == RMH_SSIZE_ARG) {
-					rmh->stat_len = (u16)(data & 0x0000ff) + 1;
+					rmh->stat_len = (data & 0x0000ff) + 1;
 					data &= 0xffff00;
 				} else {
 					/* rmh->dsp_stat == RMH_SSIZE_MASK */
@@ -562,7 +593,8 @@ static int pcxhr_read_rmh_status(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 			rmh->stat[i] = data;
 	}
 	if (rmh->stat_len > max_stat_len) {
-		snd_printdd("PCXHR : rmh->stat_len=%x too big\n", rmh->stat_len);
+		snd_printdd("PCXHR : rmh->stat_len=%x too big\n",
+			    rmh->stat_len);
 		rmh->stat_len = max_stat_len;
 	}
 	return 0;
@@ -605,7 +637,8 @@ static int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 		data &= 0xff7fff;	/* MASK_1_WORD_COMMAND */
 #ifdef CONFIG_SND_DEBUG_VERBOSE
 	if (rmh->cmd_idx < CMD_LAST_INDEX)
-		snd_printdd("MSG cmd[0]=%x (%s)\n", data, cmd_names[rmh->cmd_idx]);
+		snd_printdd("MSG cmd[0]=%x (%s)\n",
+			    data, cmd_names[rmh->cmd_idx]);
 #endif
 
 	err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_TRDY,
@@ -619,8 +652,10 @@ static int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 	if (rmh->cmd_len > 1) {
 		/* send length */
 		data = rmh->cmd_len - 1;
-		err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_TRDY,
-					  PCXHR_ISR_HI08_TRDY, PCXHR_TIMEOUT_DSP, &reg);
+		err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,
+					  PCXHR_ISR_HI08_TRDY,
+					  PCXHR_ISR_HI08_TRDY,
+					  PCXHR_TIMEOUT_DSP, &reg);
 		if (err)
 			return err;
 		PCXHR_OUTPB(mgr, PCXHR_DSP_TXH, (data>>16)&0xFF);
@@ -653,8 +688,10 @@ static int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 	/* test status ISR */
 	if (reg & PCXHR_ISR_HI08_ERR) {
 		/* ERROR, wait for receiver full */
-		err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_RXDF,
-					  PCXHR_ISR_HI08_RXDF, PCXHR_TIMEOUT_DSP, &reg);
+		err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,
+					  PCXHR_ISR_HI08_RXDF,
+					  PCXHR_ISR_HI08_RXDF,
+					  PCXHR_TIMEOUT_DSP, &reg);
 		if (err) {
 			snd_printk(KERN_ERR "ERROR RMH: ISR:RXDF=1 (ISR = %x)\n", reg);
 			return err;
@@ -663,7 +700,8 @@ static int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 		data  = PCXHR_INPB(mgr, PCXHR_DSP_TXH) << 16;
 		data |= PCXHR_INPB(mgr, PCXHR_DSP_TXM) << 8;
 		data |= PCXHR_INPB(mgr, PCXHR_DSP_TXL);
-		snd_printk(KERN_ERR "ERROR RMH(%d): 0x%x\n", rmh->cmd_idx, data);
+		snd_printk(KERN_ERR "ERROR RMH(%d): 0x%x\n",
+			   rmh->cmd_idx, data);
 		err = -EINVAL;
 	} else {
 		/* read the response data */
@@ -732,8 +770,9 @@ int pcxhr_send_msg(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 static inline int pcxhr_pipes_running(struct pcxhr_mgr *mgr)
 {
 	int start_mask = PCXHR_INPL(mgr, PCXHR_PLX_MBOX2);
-	/* least segnificant 12 bits are the pipe states for the playback audios */
-	/* next 12 bits are the pipe states for the capture audios
+	/* least segnificant 12 bits are the pipe states
+	 * for the playback audios
+	 * next 12 bits are the pipe states for the capture audios
 	 * (PCXHR_PIPE_STATE_CAPTURE_OFFSET)
 	 */
 	start_mask &= 0xffffff;
@@ -744,7 +783,8 @@ static inline int pcxhr_pipes_running(struct pcxhr_mgr *mgr)
 #define PCXHR_PIPE_STATE_CAPTURE_OFFSET		12
 #define MAX_WAIT_FOR_DSP			20
 
-static int pcxhr_prepair_pipe_start(struct pcxhr_mgr *mgr, int audio_mask, int *retry)
+static int pcxhr_prepair_pipe_start(struct pcxhr_mgr *mgr,
+				    int audio_mask, int *retry)
 {
 	struct pcxhr_rmh rmh;
 	int err;
@@ -760,17 +800,20 @@ static int pcxhr_prepair_pipe_start(struct pcxhr_mgr *mgr, int audio_mask, int *
 			} else {
 				/* can start capture pipe */
 				pcxhr_set_pipe_cmd_params(&rmh, 1, audio -
-							  PCXHR_PIPE_STATE_CAPTURE_OFFSET,
-							  0, 0);
+						PCXHR_PIPE_STATE_CAPTURE_OFFSET,
+						0, 0);
 			}
 			err = pcxhr_send_msg(mgr, &rmh);
 			if (err) {
 				snd_printk(KERN_ERR
-					   "error pipe start (CMD_CAN_START_PIPE) err=%x!\n",
+					   "error pipe start "
+					   "(CMD_CAN_START_PIPE) err=%x!\n",
 					   err);
 				return err;
 			}
-			/* if the pipe couldn't be prepaired for start, retry it later */
+			/* if the pipe couldn't be prepaired for start,
+			 * retry it later
+			 */
 			if (rmh.stat[0] == 0)
 				*retry |= (1<<audio);
 		}
@@ -795,14 +838,14 @@ static int pcxhr_stop_pipes(struct pcxhr_mgr *mgr, int audio_mask)
 			} else {
 				/* stop capture pipe */
 				pcxhr_set_pipe_cmd_params(&rmh, 1, audio -
-							  PCXHR_PIPE_STATE_CAPTURE_OFFSET,
-							  0, 0);
+						PCXHR_PIPE_STATE_CAPTURE_OFFSET,
+						0, 0);
 			}
 			err = pcxhr_send_msg(mgr, &rmh);
 			if (err) {
 				snd_printk(KERN_ERR
-					   "error pipe stop (CMD_STOP_PIPE) err=%x!\n",
-					   err);
+					   "error pipe stop "
+					   "(CMD_STOP_PIPE) err=%x!\n", err);
 				return err;
 			}
 		}
@@ -822,15 +865,16 @@ static int pcxhr_toggle_pipes(struct pcxhr_mgr *mgr, int audio_mask)
 		if (audio_mask & 1) {
 			pcxhr_init_rmh(&rmh, CMD_CONF_PIPE);
 			if (audio < PCXHR_PIPE_STATE_CAPTURE_OFFSET)
-				pcxhr_set_pipe_cmd_params(&rmh, 0, 0, 0, 1 << audio);
+				pcxhr_set_pipe_cmd_params(&rmh, 0, 0, 0,
+							  1 << audio);
 			else
 				pcxhr_set_pipe_cmd_params(&rmh, 1, 0, 0,
 							  1 << (audio - PCXHR_PIPE_STATE_CAPTURE_OFFSET));
 			err = pcxhr_send_msg(mgr, &rmh);
 			if (err) {
 				snd_printk(KERN_ERR
-					   "error pipe start (CMD_CONF_PIPE) err=%x!\n",
-					   err);
+					   "error pipe start "
+					   "(CMD_CONF_PIPE) err=%x!\n", err);
 				return err;
 			}
 		}
@@ -841,7 +885,9 @@ static int pcxhr_toggle_pipes(struct pcxhr_mgr *mgr, int audio_mask)
 	pcxhr_init_rmh(&rmh, CMD_SEND_IRQA);
 	err = pcxhr_send_msg(mgr, &rmh);
 	if (err) {
-		snd_printk(KERN_ERR "error pipe start (CMD_SEND_IRQA) err=%x!\n", err );
+		snd_printk(KERN_ERR
+			   "error pipe start (CMD_SEND_IRQA) err=%x!\n",
+			   err);
 		return err;
 	}
 	return 0;
@@ -849,7 +895,8 @@ static int pcxhr_toggle_pipes(struct pcxhr_mgr *mgr, int audio_mask)
 
 
 
-int pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask, int capture_mask, int start)
+int pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask,
+			 int capture_mask, int start)
 {
 	int state, i, err;
 	int audio_mask;
@@ -858,21 +905,23 @@ int pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask, int capture_m
 	struct timeval my_tv1, my_tv2;
 	do_gettimeofday(&my_tv1);
 #endif
-	audio_mask = (playback_mask | (capture_mask << PCXHR_PIPE_STATE_CAPTURE_OFFSET));
+	audio_mask = (playback_mask |
+		      (capture_mask << PCXHR_PIPE_STATE_CAPTURE_OFFSET));
 	/* current pipe state (playback + record) */
 	state = pcxhr_pipes_running(mgr);
 	snd_printdd("pcxhr_set_pipe_state %s (mask %x current %x)\n",
 		    start ? "START" : "STOP", audio_mask, state);
 	if (start) {
-		audio_mask &= ~state;	/* start only pipes that are not yet started */
+		/* start only pipes that are not yet started */
+		audio_mask &= ~state;
 		state = audio_mask;
 		for (i = 0; i < MAX_WAIT_FOR_DSP; i++) {
 			err = pcxhr_prepair_pipe_start(mgr, state, &state);
 			if (err)
 				return err;
 			if (state == 0)
-				break;	/* success, all pipes prepaired for start */
-			mdelay(1);		/* otherwise wait 1 millisecond and retry */
+				break;	/* success, all pipes prepaired */
+			mdelay(1);	/* wait 1 millisecond and retry */
 		}
 	} else {
 		audio_mask &= state;	/* stop only pipes that are started */
@@ -891,7 +940,7 @@ int pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask, int capture_m
 		if ((state & audio_mask) == (start ? audio_mask : 0))
 			break;
 		if (++i >= MAX_WAIT_FOR_DSP * 100) {
-			snd_printk(KERN_ERR "error pipe start/stop (ED_NO_RESPONSE_AT_IRQA)\n");
+			snd_printk(KERN_ERR "error pipe start/stop\n");
 			return -EBUSY;
 		}
 		udelay(10);			/* wait 10 microseconds */
@@ -918,7 +967,8 @@ int pcxhr_write_io_num_reg_cont(struct pcxhr_mgr *mgr, unsigned int mask,
 
 	spin_lock_irqsave(&mgr->msg_lock, flags);
 	if ((mgr->io_num_reg_cont & mask) == value) {
-		snd_printdd("IO_NUM_REG_CONT mask %x already is set to %x\n", mask, value);
+		snd_printdd("IO_NUM_REG_CONT mask %x already is set to %x\n",
+			    mask, value);
 		if (changed)
 			*changed = 0;
 		spin_unlock_irqrestore(&mgr->msg_lock, flags);
@@ -971,7 +1021,8 @@ static int pcxhr_handle_async_err(struct pcxhr_mgr *mgr, u32 err,
 		err = ((err >> 12) & 0xfff);
 	if (!err)
 		return 0;
-	snd_printdd("CMD_ASYNC : Error %s %s Pipe %d err=%x\n", err_src_name[err_src],
+	snd_printdd("CMD_ASYNC : Error %s %s Pipe %d err=%x\n",
+		    err_src_name[err_src],
 		    is_capture ? "Record" : "Play", pipe, err);
 	if (err == 0xe01)
 		mgr->async_err_stream_xrun++;
@@ -996,6 +1047,13 @@ void pcxhr_msg_tasklet(unsigned long arg)
 		snd_printdd("TASKLET : PCXHR_IRQ_TIME_CODE event occured\n");
 	if (mgr->src_it_dsp & PCXHR_IRQ_NOTIFY)
 		snd_printdd("TASKLET : PCXHR_IRQ_NOTIFY event occured\n");
+	if (mgr->src_it_dsp & (PCXHR_IRQ_FREQ_CHANGE | PCXHR_IRQ_TIME_CODE)) {
+		/* clear events FREQ_CHANGE and TIME_CODE */
+		pcxhr_init_rmh(prmh, CMD_TEST_IT);
+		err = pcxhr_send_msg(mgr, prmh);
+		snd_printdd("CMD_TEST_IT : err=%x, stat=%x\n",
+			    err, prmh->stat[0]);
+	}
 	if (mgr->src_it_dsp & PCXHR_IRQ_ASYNC) {
 		snd_printdd("TASKLET : PCXHR_IRQ_ASYNC event occured\n");
 
@@ -1005,18 +1063,22 @@ void pcxhr_msg_tasklet(unsigned long arg)
 		prmh->stat_len = PCXHR_SIZE_MAX_LONG_STATUS;
 		err = pcxhr_send_msg(mgr, prmh);
 		if (err)
-			snd_printk(KERN_ERR "ERROR pcxhr_msg_tasklet=%x;\n", err);
+			snd_printk(KERN_ERR "ERROR pcxhr_msg_tasklet=%x;\n",
+				   err);
 		i = 1;
 		while (i < prmh->stat_len) {
-			int nb_audio = (prmh->stat[i] >> FIELD_SIZE) & MASK_FIRST_FIELD;
-			int nb_stream = (prmh->stat[i] >> (2*FIELD_SIZE)) & MASK_FIRST_FIELD;
+			int nb_audio = ((prmh->stat[i] >> FIELD_SIZE) &
+					MASK_FIRST_FIELD);
+			int nb_stream = ((prmh->stat[i] >> (2*FIELD_SIZE)) &
+					 MASK_FIRST_FIELD);
 			int pipe = prmh->stat[i] & MASK_FIRST_FIELD;
 			int is_capture = prmh->stat[i] & 0x400000;
 			u32 err2;
 
 			if (prmh->stat[i] & 0x800000) {	/* if BIT_END */
 				snd_printdd("TASKLET : End%sPipe %d\n",
-					    is_capture ? "Record" : "Play", pipe);
+					    is_capture ? "Record" : "Play",
+					    pipe);
 			}
 			i++;
 			err2 = prmh->stat[i] ? prmh->stat[i] : prmh->stat[i+1];
@@ -1062,7 +1124,7 @@ static u_int64_t pcxhr_stream_read_position(struct pcxhr_mgr *mgr,
 	pcxhr_init_rmh(&rmh, CMD_STREAM_SAMPLE_COUNT);
 	pcxhr_set_pipe_cmd_params(&rmh, stream->pipe->is_capture,
 				  stream->pipe->first_audio, 0, stream_mask);
-	/* rmh.stat_len = 2; */		/* 2 resp data for each stream of the pipe */
+	/* rmh.stat_len = 2; */	/* 2 resp data for each stream of the pipe */
 
 	err = pcxhr_send_msg(mgr, &rmh);
 	if (err)
@@ -1072,18 +1134,21 @@ static u_int64_t pcxhr_stream_read_position(struct pcxhr_mgr *mgr,
 	hw_sample_count += (u_int64_t)rmh.stat[1];
 
 	snd_printdd("stream %c%d : abs samples real(%ld) timer(%ld)\n",
-		    stream->pipe->is_capture ? 'C':'P', stream->substream->number,
+		    stream->pipe->is_capture ? 'C' : 'P',
+		    stream->substream->number,
 		    (long unsigned int)hw_sample_count,
 		    (long unsigned int)(stream->timer_abs_periods +
-					stream->timer_period_frag + PCXHR_GRANULARITY));
-
+					stream->timer_period_frag +
+					mgr->granularity));
 	return hw_sample_count;
 }
 
 static void pcxhr_update_timer_pos(struct pcxhr_mgr *mgr,
-				   struct pcxhr_stream *stream, int samples_to_add)
+				   struct pcxhr_stream *stream,
+				   int samples_to_add)
 {
-	if (stream->substream && (stream->status == PCXHR_STREAM_STATUS_RUNNING)) {
+	if (stream->substream &&
+	    (stream->status == PCXHR_STREAM_STATUS_RUNNING)) {
 		u_int64_t new_sample_count;
 		int elapsed = 0;
 		int hardware_read = 0;
@@ -1092,20 +1157,22 @@ static void pcxhr_update_timer_pos(struct pcxhr_mgr *mgr,
 		if (samples_to_add < 0) {
 			stream->timer_is_synced = 0;
 			/* add default if no hardware_read possible */
-			samples_to_add = PCXHR_GRANULARITY;
+			samples_to_add = mgr->granularity;
 		}
 
 		if (!stream->timer_is_synced) {
-			if (stream->timer_abs_periods != 0 ||
-			    stream->timer_period_frag + PCXHR_GRANULARITY >=
-			    runtime->period_size) {
-				new_sample_count = pcxhr_stream_read_position(mgr, stream);
+			if ((stream->timer_abs_periods != 0) ||
+			    ((stream->timer_period_frag + samples_to_add) >=
+			    runtime->period_size)) {
+				new_sample_count =
+				  pcxhr_stream_read_position(mgr, stream);
 				hardware_read = 1;
-				if (new_sample_count >= PCXHR_GRANULARITY_MIN) {
-					/* sub security offset because of jitter and
-					 * finer granularity of dsp time (MBOX4)
+				if (new_sample_count >= mgr->granularity) {
+					/* sub security offset because of
+					 * jitter and finer granularity of
+					 * dsp time (MBOX4)
 					 */
-					new_sample_count -= PCXHR_GRANULARITY_MIN;
+					new_sample_count -= mgr->granularity;
 					stream->timer_is_synced = 1;
 				}
 			}
@@ -1128,12 +1195,15 @@ static void pcxhr_update_timer_pos(struct pcxhr_mgr *mgr,
 				stream->timer_buf_periods = 0;
 			stream->timer_abs_periods = new_elapse_pos;
 		}
-		if (new_sample_count >= stream->timer_abs_periods)
-			stream->timer_period_frag = (u_int32_t)(new_sample_count -
-								stream->timer_abs_periods);
-		else
-			snd_printk(KERN_ERR "ERROR new_sample_count too small ??? %lx\n",
+		if (new_sample_count >= stream->timer_abs_periods) {
+			stream->timer_period_frag =
+				(u_int32_t)(new_sample_count -
+					    stream->timer_abs_periods);
+		} else {
+			snd_printk(KERN_ERR
+				   "ERROR new_sample_count too small ??? %ld\n",
 				   (long unsigned int)new_sample_count);
+		}
 
 		if (elapsed) {
 			spin_unlock(&mgr->lock);
@@ -1143,7 +1213,6 @@ static void pcxhr_update_timer_pos(struct pcxhr_mgr *mgr,
 	}
 }
 
-
 irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 {
 	struct pcxhr_mgr *mgr = dev_id;
@@ -1156,7 +1225,8 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 	reg = PCXHR_INPL(mgr, PCXHR_PLX_IRQCS);
 	if (! (reg & PCXHR_IRQCS_ACTIVE_PCIDB)) {
 		spin_unlock(&mgr->lock);
-		return IRQ_NONE;	/* this device did not cause the interrupt */
+		/* this device did not cause the interrupt */
+		return IRQ_NONE;
 	}
 
 	/* clear interrupt */
@@ -1167,10 +1237,12 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 	if (reg & PCXHR_IRQ_TIMER) {
 		int timer_toggle = reg & PCXHR_IRQ_TIMER;
 		/* is a 24 bit counter */
-		int dsp_time_new = PCXHR_INPL(mgr, PCXHR_PLX_MBOX4) & PCXHR_DSP_TIME_MASK;
+		int dsp_time_new =
+			PCXHR_INPL(mgr, PCXHR_PLX_MBOX4) & PCXHR_DSP_TIME_MASK;
 		int dsp_time_diff = dsp_time_new - mgr->dsp_time_last;
 
-		if (dsp_time_diff < 0 && mgr->dsp_time_last != PCXHR_DSP_TIME_INVALID) {
+		if ((dsp_time_diff < 0) &&
+		    (mgr->dsp_time_last != PCXHR_DSP_TIME_INVALID)) {
 			snd_printdd("ERROR DSP TIME old(%d) new(%d) -> "
 				    "resynchronize all streams\n",
 				    mgr->dsp_time_last, dsp_time_new);
@@ -1178,40 +1250,49 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 		}
 #ifdef CONFIG_SND_DEBUG_VERBOSE
 		if (dsp_time_diff == 0)
-			snd_printdd("ERROR DSP TIME NO DIFF time(%d)\n", dsp_time_new);
-		else if (dsp_time_diff >= (2*PCXHR_GRANULARITY))
+			snd_printdd("ERROR DSP TIME NO DIFF time(%d)\n",
+				    dsp_time_new);
+		else if (dsp_time_diff >= (2*mgr->granularity))
 			snd_printdd("ERROR DSP TIME TOO BIG old(%d) add(%d)\n",
-				    mgr->dsp_time_last, dsp_time_new - mgr->dsp_time_last);
+				    mgr->dsp_time_last,
+				    dsp_time_new - mgr->dsp_time_last);
+		else if (dsp_time_diff % mgr->granularity)
+			snd_printdd("ERROR DSP TIME increased by %d\n",
+				    dsp_time_diff);
 #endif
 		mgr->dsp_time_last = dsp_time_new;
 
-		if (timer_toggle == mgr->timer_toggle)
+		if (timer_toggle == mgr->timer_toggle) {
 			snd_printdd("ERROR TIMER TOGGLE\n");
+			mgr->dsp_time_err++;
+		}
 		mgr->timer_toggle = timer_toggle;
 
 		reg &= ~PCXHR_IRQ_TIMER;
 		for (i = 0; i < mgr->num_cards; i++) {
 			chip = mgr->chip[i];
 			for (j = 0; j < chip->nb_streams_capt; j++)
-				pcxhr_update_timer_pos(mgr, &chip->capture_stream[j],
-						       dsp_time_diff);
+				pcxhr_update_timer_pos(mgr,
+						&chip->capture_stream[j],
+						dsp_time_diff);
 		}
 		for (i = 0; i < mgr->num_cards; i++) {
 			chip = mgr->chip[i];
 			for (j = 0; j < chip->nb_streams_play; j++)
-				pcxhr_update_timer_pos(mgr, &chip->playback_stream[j],
-						       dsp_time_diff);
+				pcxhr_update_timer_pos(mgr,
+						&chip->playback_stream[j],
+						dsp_time_diff);
 		}
 	}
 	/* other irq's handled in the tasklet */
 	if (reg & PCXHR_IRQ_MASK) {
-
-		/* as we didn't request any notifications, some kind of xrun error
-		 * will probably occured
-		 */
-		/* better resynchronize all streams next interrupt : */
-		mgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;
-		
+		if (reg & PCXHR_IRQ_ASYNC) {
+			/* as we didn't request any async notifications,
+			 * some kind of xrun error will probably occured
+			 */
+			/* better resynchronize all streams next interrupt : */
+			mgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;
+		}
 		mgr->src_it_dsp = reg;
 		tasklet_hi_schedule(&mgr->msg_taskq);
 	}

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index 000e6fed6e39..7143259cfe34 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -319,16 +319,20 @@ static int pcxhr_download_dsp(struct pcxhr_mgr *mgr, const struct firmware *dsp)
 	const unsigned char *data;
 	unsigned char dummy;
 	/* check the length of boot image */
-	snd_assert(dsp->size > 0, return -EINVAL);
-	snd_assert(dsp->size % 3 == 0, return -EINVAL);
-	snd_assert(dsp->data, return -EINVAL);
+	if (dsp->size <= 0)
+		return -EINVAL;
+	if (dsp->size % 3)
+		return -EINVAL;
+	if (snd_BUG_ON(!dsp->data))
+		return -EINVAL;
 	/* transfert data buffer from PC to DSP */
 	for (i = 0; i < dsp->size; i += 3) {
 		data = dsp->data + i;
 		if (i == 0) {
 			/* test data header consistency */
 			len = (unsigned int)((data[0]<<16) + (data[1]<<8) + data[2]);
-			snd_assert((len==0) || (dsp->size == (len+2)*3), return -EINVAL);
+			if (len && dsp->size != (len + 2) * 3)
+				return -EINVAL;
 		}
 		/* wait DSP ready for new transfer */
 		err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_TRDY,
@@ -389,7 +393,8 @@ int pcxhr_load_boot_binary(struct pcxhr_mgr *mgr, const struct firmware *boot)
 	unsigned char dummy;
 
 	/* send the hostport address to the DSP (only the upper 24 bit !) */
-	snd_assert((physaddr & 0xff) == 0, return -EINVAL);
+	if (snd_BUG_ON(physaddr & 0xff))
+		return -EINVAL;
 	PCXHR_OUTPL(mgr, PCXHR_PLX_MBOX1, (physaddr >> 8));
 
 	err = pcxhr_send_it_dsp(mgr, PCXHR_IT_DOWNLOAD_BOOT, 0);
@@ -570,7 +575,8 @@ static int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 	u32 data;
 	unsigned char reg;
 
-	snd_assert(rmh->cmd_len<PCXHR_SIZE_MAX_CMD, return -EINVAL);
+	if (snd_BUG_ON(rmh->cmd_len >= PCXHR_SIZE_MAX_CMD))
+		return -EINVAL;
 	err = pcxhr_send_it_dsp(mgr, PCXHR_IT_MESSAGE, 1);
 	if (err) {
 		snd_printk(KERN_ERR "pcxhr_send_message : ED_DSP_CRASHED\n");
@@ -677,7 +683,8 @@ static int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
  */
 void pcxhr_init_rmh(struct pcxhr_rmh *rmh, int cmd)
 {
-	snd_assert(cmd < CMD_LAST_INDEX, return);
+	if (snd_BUG_ON(cmd >= CMD_LAST_INDEX))
+		return;
 	rmh->cmd[0] = pcxhr_dsp_cmds[cmd].opcode;
 	rmh->cmd_len = 1;
 	rmh->stat_len = pcxhr_dsp_cmds[cmd].st_length;
@@ -690,17 +697,17 @@ void pcxhr_set_pipe_cmd_params(struct pcxhr_rmh *rmh, int capture,
 			       unsigned int param1, unsigned int param2,
 			       unsigned int param3)
 {
-	snd_assert(param1 <= MASK_FIRST_FIELD);
+	snd_BUG_ON(param1 > MASK_FIRST_FIELD);
 	if (capture)
 		rmh->cmd[0] |= 0x800;		/* COMMAND_RECORD_MASK */
 	if (param1)
 		rmh->cmd[0] |= (param1 << FIELD_SIZE);
 	if (param2) {
-		snd_assert(param2 <= MASK_FIRST_FIELD);
+		snd_BUG_ON(param2 > MASK_FIRST_FIELD);
 		rmh->cmd[0] |= param2;
 	}
 	if(param3) {
-		snd_assert(param3 <= MASK_DSP_WORD);
+		snd_BUG_ON(param3 > MASK_DSP_WORD);
 		rmh->cmd[1] = param3;
 		rmh->cmd_len = 2;
 	}

commit 751851af7aae9b8bd5a60b3897209081fbc18b2b
Merge: a41eebab7537 d71792ac3d48
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Mon Jul 14 15:49:04 2008 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
    
    Conflicts:
    
            sound/pci/Kconfig

commit b8d21807a1a479e0214a03069a88e3e93492b72d
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sat May 24 00:02:28 2008 +0100

    pcxhr: treat firmware data as const
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index 78aa81feaa4a..957e6afe94f1 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -269,7 +269,7 @@ int pcxhr_load_xilinx_binary(struct pcxhr_mgr *mgr, const struct firmware *xilin
 	unsigned int chipsc;
 	unsigned char data;
 	unsigned char mask;
-	unsigned char *image;
+	const unsigned char *image;
 
 	/* test first xilinx */
 	chipsc = PCXHR_INPL(mgr, PCXHR_PLX_CHIPSC);
@@ -316,7 +316,7 @@ static int pcxhr_download_dsp(struct pcxhr_mgr *mgr, const struct firmware *dsp)
 	int err;
 	unsigned int i;
 	unsigned int len;
-	unsigned char *data;
+	const unsigned char *data;
 	unsigned char dummy;
 	/* check the length of boot image */
 	snd_assert(dsp->size > 0, return -EINVAL);

commit 62cf872a8eec1f11aacbec0ac3fe3698bfa9b403
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 20 12:15:15 2008 +0200

    [ALSA] Replace CONFIG_SND_DEBUG_DETECT with CONFIG_SND_DEBUG_VERBOSE
    
    Replace CONFIG_SND_DEBUG_DETECT with CONFIG_SND_DEBUG_VERBOSE to
    represent its meaning more better.  This config isn't provided only
    for the detection but for more verbose debug prints in general.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index 78aa81feaa4a..abe5c59b72df 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -473,7 +473,7 @@ static struct pcxhr_cmd_info pcxhr_dsp_cmds[] = {
 [CMD_AUDIO_LEVEL_ADJUST] =		{ 0xc22000, 0, RMH_SSIZE_FIXED },
 };
 
-#ifdef CONFIG_SND_DEBUG_DETECT
+#ifdef CONFIG_SND_DEBUG_VERBOSE
 static char* cmd_names[] = {
 [CMD_VERSION] =				"CMD_VERSION",
 [CMD_SUPPORTED] =			"CMD_SUPPORTED",
@@ -549,7 +549,7 @@ static int pcxhr_read_rmh_status(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 				}
 			}
 		}
-#ifdef CONFIG_SND_DEBUG_DETECT
+#ifdef CONFIG_SND_DEBUG_VERBOSE
 		if (rmh->cmd_idx < CMD_LAST_INDEX)
 			snd_printdd("    stat[%d]=%x\n", i, data);
 #endif
@@ -597,7 +597,7 @@ static int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 		data |= 0x008000;	/* MASK_MORE_THAN_1_WORD_COMMAND */
 	else
 		data &= 0xff7fff;	/* MASK_1_WORD_COMMAND */
-#ifdef CONFIG_SND_DEBUG_DETECT
+#ifdef CONFIG_SND_DEBUG_VERBOSE
 	if (rmh->cmd_idx < CMD_LAST_INDEX)
 		snd_printdd("MSG cmd[0]=%x (%s)\n", data, cmd_names[rmh->cmd_idx]);
 #endif
@@ -624,7 +624,7 @@ static int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
 		for (i=1; i < rmh->cmd_len; i++) {
 			/* send other words */
 			data = rmh->cmd[i];
-#ifdef CONFIG_SND_DEBUG_DETECT
+#ifdef CONFIG_SND_DEBUG_VERBOSE
 			if (rmh->cmd_idx < CMD_LAST_INDEX)
 				snd_printdd("    cmd[%d]=%x\n", i, data);
 #endif
@@ -847,7 +847,7 @@ int pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask, int capture_m
 	int state, i, err;
 	int audio_mask;
 
-#ifdef CONFIG_SND_DEBUG_DETECT
+#ifdef CONFIG_SND_DEBUG_VERBOSE
 	struct timeval my_tv1, my_tv2;
 	do_gettimeofday(&my_tv1);
 #endif
@@ -894,7 +894,7 @@ int pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask, int capture_m
 		if (err)
 			return err;
 	}
-#ifdef CONFIG_SND_DEBUG_DETECT
+#ifdef CONFIG_SND_DEBUG_VERBOSE
 	do_gettimeofday(&my_tv2);
 	snd_printdd("***SET PIPE STATE*** TIME = %ld (err = %x)\n",
 		    (long)(my_tv2.tv_usec - my_tv1.tv_usec), err);
@@ -951,7 +951,7 @@ static int pcxhr_handle_async_err(struct pcxhr_mgr *mgr, u32 err,
 				  enum pcxhr_async_err_src err_src, int pipe,
 				  int is_capture)
 {
-#ifdef CONFIG_SND_DEBUG_DETECT
+#ifdef CONFIG_SND_DEBUG_VERBOSE
 	static char* err_src_name[] = {
 		[PCXHR_ERR_PIPE]	= "Pipe",
 		[PCXHR_ERR_STREAM]	= "Stream",
@@ -1169,7 +1169,7 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 				    mgr->dsp_time_last, dsp_time_new);
 			mgr->dsp_time_err++;
 		}
-#ifdef CONFIG_SND_DEBUG_DETECT
+#ifdef CONFIG_SND_DEBUG_VERBOSE
 		if (dsp_time_diff == 0)
 			snd_printdd("ERROR DSP TIME NO DIFF time(%d)\n", dsp_time_new);
 		else if (dsp_time_diff >= (2*PCXHR_GRANULARITY))
@@ -1208,7 +1208,7 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 		mgr->src_it_dsp = reg;
 		tasklet_hi_schedule(&mgr->msg_taskq);
 	}
-#ifdef CONFIG_SND_DEBUG_DETECT
+#ifdef CONFIG_SND_DEBUG_VERBOSE
 	if (reg & PCXHR_FATAL_DSP_ERR)
 		snd_printdd("FATAL DSP ERROR : %x\n", reg);
 #endif

commit ee0abefde5273c816bd3d4158e5cb9c591b82684
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Thu Mar 20 12:05:33 2008 +0100

    [ALSA] sound/pci/pcxhr/pcxhr_core.c: fix printk warning
    
    sound/pci/pcxhr/pcxhr_core.c: In function `pcxhr_set_pipe_state':
    sound/pci/pcxhr/pcxhr_core.c:899: warning: long int format, different type arg (arg 4)
    
    suseconds_t is int on sparc64.
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index 846afbd30682..78aa81feaa4a 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -897,7 +897,7 @@ int pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask, int capture_m
 #ifdef CONFIG_SND_DEBUG_DETECT
 	do_gettimeofday(&my_tv2);
 	snd_printdd("***SET PIPE STATE*** TIME = %ld (err = %x)\n",
-		    my_tv2.tv_usec - my_tv1.tv_usec, err);
+		    (long)(my_tv2.tv_usec - my_tv1.tv_usec), err);
 #endif
 	return 0;
 }

commit caba7f70fce924dc5da2019f7678189086d0acd4
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Fri Feb 29 11:53:59 2008 +0100

    [ALSA] sound: pcxhr_core.c fix shadowed variable warning
    
    Inner loop redeclares err with u32 rather than int, stupid fix here
    is to change the inner err to err2.
    sound/pci/pcxhr/pcxhr_core.c:1008:8: warning: symbol 'err' shadows an earlier one
    sound/pci/pcxhr/pcxhr_core.c:983:6: originally declared here
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index c4e415d07380..846afbd30682 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -1005,30 +1005,37 @@ void pcxhr_msg_tasklet(unsigned long arg)
 			int nb_stream = (prmh->stat[i] >> (2*FIELD_SIZE)) & MASK_FIRST_FIELD;
 			int pipe = prmh->stat[i] & MASK_FIRST_FIELD;
 			int is_capture = prmh->stat[i] & 0x400000;
-			u32 err;
+			u32 err2;
 
 			if (prmh->stat[i] & 0x800000) {	/* if BIT_END */
 				snd_printdd("TASKLET : End%sPipe %d\n",
 					    is_capture ? "Record" : "Play", pipe);
 			}
 			i++;
-			err = prmh->stat[i] ? prmh->stat[i] : prmh->stat[i+1];
-			if (err)
-				pcxhr_handle_async_err(mgr, err, PCXHR_ERR_PIPE,
+			err2 = prmh->stat[i] ? prmh->stat[i] : prmh->stat[i+1];
+			if (err2)
+				pcxhr_handle_async_err(mgr, err2,
+						       PCXHR_ERR_PIPE,
 						       pipe, is_capture);
 			i += 2;
 			for (j = 0; j < nb_stream; j++) {
-				err = prmh->stat[i] ? prmh->stat[i] : prmh->stat[i+1];
-				if (err)
-					pcxhr_handle_async_err(mgr, err, PCXHR_ERR_STREAM,
-							       pipe, is_capture);
+				err2 = prmh->stat[i] ?
+					prmh->stat[i] : prmh->stat[i+1];
+				if (err2)
+					pcxhr_handle_async_err(mgr, err2,
+							       PCXHR_ERR_STREAM,
+							       pipe,
+							       is_capture);
 				i += 2;
 			}
 			for (j = 0; j < nb_audio; j++) {
-				err = prmh->stat[i] ? prmh->stat[i] : prmh->stat[i+1];
-				if (err)
-					pcxhr_handle_async_err(mgr, err, PCXHR_ERR_AUDIO,
-							       pipe, is_capture);
+				err2 = prmh->stat[i] ?
+					prmh->stat[i] : prmh->stat[i+1];
+				if (err2)
+					pcxhr_handle_async_err(mgr, err2,
+							       PCXHR_ERR_AUDIO,
+							       pipe,
+							       is_capture);
 				i += 2;
 			}
 		}

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index 0ff8dc36fde3..c4e415d07380 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -20,7 +20,6 @@
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
-#include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/firmware.h>
 #include <linux/interrupt.h>

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index c40f59062684..0ff8dc36fde3 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -1131,7 +1131,7 @@ static void pcxhr_update_timer_pos(struct pcxhr_mgr *mgr,
 }
 
 
-irqreturn_t pcxhr_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t pcxhr_interrupt(int irq, void *dev_id)
 {
 	struct pcxhr_mgr *mgr = dev_id;
 	unsigned int reg;

commit 0bd43b5bc9e61e9dc48ad5ee68737316e5d94b60
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Fri Mar 31 12:48:51 2006 +0200

    [ALSA] pcxhr - Fix the crash with REV01 board
    
    On a new board revision for pcxhr boards, the
    PCXHR_CHIPSC_GPI_USERI bit is no more supported.
    The cards concerned have a REV01 in their PCI ID.
    
    As the current driver tests this bit and does not load the
    first Xilinx binary when it's 1, the card will crash on Xilinx
    access over PCI. (the PCI will freeze ....)
    
    The fix (fix to version 1.0.11rc4) works for both REV00 and
    REV01 cards.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index fdc652c6992d..c40f59062684 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -274,12 +274,9 @@ int pcxhr_load_xilinx_binary(struct pcxhr_mgr *mgr, const struct firmware *xilin
 
 	/* test first xilinx */
 	chipsc = PCXHR_INPL(mgr, PCXHR_PLX_CHIPSC);
-	if (!second) {
-		if (chipsc & PCXHR_CHIPSC_GPI_USERI) {
-			snd_printdd("no need to load first xilinx\n");
-			return 0; /* first xilinx is already present and cannot be reset */
-		}
-	} else {
+	/* REV01 cards do not support the PCXHR_CHIPSC_GPI_USERI bit anymore */
+	/* this bit will always be 1; no possibility to test presence of first xilinx */
+	if(second) {
 		if ((chipsc & PCXHR_CHIPSC_GPI_USERI) == 0) {
 			snd_printk(KERN_ERR "error loading first xilinx\n");
 			return -EINVAL;

commit 34226c4239861654c69888e6e98973b2cc908c0b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 4 12:14:23 2006 +0100

    [ALSA] pcxhr - Suppress debug messages
    
    Modules: Digigram PCXHR driver
    
    Suppress debug messages.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
index fa0d27e2c79b..fdc652c6992d 100644
--- a/sound/pci/pcxhr/pcxhr_core.c
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -1176,7 +1176,7 @@ irqreturn_t pcxhr_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 		mgr->dsp_time_last = dsp_time_new;
 
 		if (timer_toggle == mgr->timer_toggle)
-			snd_printk(KERN_ERR "ERROR TIMER TOGGLE\n");
+			snd_printdd("ERROR TIMER TOGGLE\n");
 		mgr->timer_toggle = timer_toggle;
 
 		reg &= ~PCXHR_IRQ_TIMER;

commit e12229b4d2b7863b1baaeca759aa87703bf9fdf8
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Tue Dec 6 13:55:26 2005 +0100

    [ALSA] Add PCXHR driver
    
    Modules: Documentation,PCI drivers,Digigram PCXHR driver
    
    Add Digigram PCXHR driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_core.c b/sound/pci/pcxhr/pcxhr_core.c
new file mode 100644
index 000000000000..fa0d27e2c79b
--- /dev/null
+++ b/sound/pci/pcxhr/pcxhr_core.c
@@ -0,0 +1,1214 @@
+/*
+ * Driver for Digigram pcxhr compatible soundcards
+ *
+ * low level interface with interrupt and message handling implementation
+ *
+ * Copyright (c) 2004 by Digigram <alsa@digigram.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <sound/core.h>
+#include "pcxhr.h"
+#include "pcxhr_mixer.h"
+#include "pcxhr_hwdep.h"
+#include "pcxhr_core.h"
+
+
+/* registers used on the PLX (port 1) */
+#define PCXHR_PLX_OFFSET_MIN	0x40
+#define PCXHR_PLX_MBOX0		0x40
+#define PCXHR_PLX_MBOX1		0x44
+#define PCXHR_PLX_MBOX2		0x48
+#define PCXHR_PLX_MBOX3		0x4C
+#define PCXHR_PLX_MBOX4		0x50
+#define PCXHR_PLX_MBOX5		0x54
+#define PCXHR_PLX_MBOX6		0x58
+#define PCXHR_PLX_MBOX7		0x5C
+#define PCXHR_PLX_L2PCIDB	0x64
+#define PCXHR_PLX_IRQCS		0x68
+#define PCXHR_PLX_CHIPSC	0x6C
+
+/* registers used on the DSP (port 2) */
+#define PCXHR_DSP_ICR		0x00
+#define PCXHR_DSP_CVR		0x04
+#define PCXHR_DSP_ISR		0x08
+#define PCXHR_DSP_IVR		0x0C
+#define PCXHR_DSP_RXH		0x14
+#define PCXHR_DSP_TXH		0x14
+#define PCXHR_DSP_RXM		0x18
+#define PCXHR_DSP_TXM		0x18
+#define PCXHR_DSP_RXL		0x1C
+#define PCXHR_DSP_TXL		0x1C
+#define PCXHR_DSP_RESET		0x20
+#define PCXHR_DSP_OFFSET_MAX	0x20
+
+/* access to the card */
+#define PCXHR_PLX 1
+#define PCXHR_DSP 2
+
+#if (PCXHR_DSP_OFFSET_MAX > PCXHR_PLX_OFFSET_MIN)
+#undef  PCXHR_REG_TO_PORT(x)
+#else
+#define PCXHR_REG_TO_PORT(x)	((x)>PCXHR_DSP_OFFSET_MAX ? PCXHR_PLX : PCXHR_DSP)
+#endif
+#define PCXHR_INPB(mgr,x)	inb((mgr)->port[PCXHR_REG_TO_PORT(x)] + (x))
+#define PCXHR_INPL(mgr,x)	inl((mgr)->port[PCXHR_REG_TO_PORT(x)] + (x))
+#define PCXHR_OUTPB(mgr,x,data)	outb((data), (mgr)->port[PCXHR_REG_TO_PORT(x)] + (x))
+#define PCXHR_OUTPL(mgr,x,data)	outl((data), (mgr)->port[PCXHR_REG_TO_PORT(x)] + (x))
+/* attention : access the PCXHR_DSP_* registers with inb and outb only ! */
+
+/* params used with PCXHR_PLX_MBOX0 */
+#define PCXHR_MBOX0_HF5			(1 << 0)
+#define PCXHR_MBOX0_HF4			(1 << 1)
+#define PCXHR_MBOX0_BOOT_HERE		(1 << 23)
+/* params used with PCXHR_PLX_IRQCS */
+#define PCXHR_IRQCS_ENABLE_PCIIRQ	(1 << 8)
+#define PCXHR_IRQCS_ENABLE_PCIDB	(1 << 9)
+#define PCXHR_IRQCS_ACTIVE_PCIDB	(1 << 13)
+/* params used with PCXHR_PLX_CHIPSC */
+#define PCXHR_CHIPSC_INIT_VALUE		0x100D767E
+#define PCXHR_CHIPSC_RESET_XILINX	(1 << 16)
+#define PCXHR_CHIPSC_GPI_USERI		(1 << 17)
+#define PCXHR_CHIPSC_DATA_CLK		(1 << 24)
+#define PCXHR_CHIPSC_DATA_IN		(1 << 26)
+
+/* params used with PCXHR_DSP_ICR */
+#define PCXHR_ICR_HI08_RREQ		0x01
+#define PCXHR_ICR_HI08_TREQ		0x02
+#define PCXHR_ICR_HI08_HDRQ		0x04
+#define PCXHR_ICR_HI08_HF0		0x08
+#define PCXHR_ICR_HI08_HF1		0x10
+#define PCXHR_ICR_HI08_HLEND		0x20
+#define PCXHR_ICR_HI08_INIT		0x80
+/* params used with PCXHR_DSP_CVR */
+#define PCXHR_CVR_HI08_HC		0x80
+/* params used with PCXHR_DSP_ISR */
+#define PCXHR_ISR_HI08_RXDF		0x01
+#define PCXHR_ISR_HI08_TXDE		0x02
+#define PCXHR_ISR_HI08_TRDY		0x04
+#define PCXHR_ISR_HI08_ERR		0x08
+#define PCXHR_ISR_HI08_CHK		0x10
+#define PCXHR_ISR_HI08_HREQ		0x80
+
+
+/* constants used for delay in msec */
+#define PCXHR_WAIT_DEFAULT		2
+#define PCXHR_WAIT_IT			25
+#define PCXHR_WAIT_IT_EXTRA		65
+
+/*
+ * pcxhr_check_reg_bit - wait for the specified bit is set/reset on a register
+ * @reg: register to check
+ * @mask: bit mask
+ * @bit: resultant bit to be checked
+ * @time: time-out of loop in msec
+ *
+ * returns zero if a bit matches, or a negative error code.
+ */
+static int pcxhr_check_reg_bit(struct pcxhr_mgr *mgr, unsigned int reg,
+			       unsigned char mask, unsigned char bit, int time,
+			       unsigned char* read)
+{
+	int i = 0;
+	unsigned long end_time = jiffies + (time * HZ + 999) / 1000;
+	do {
+		*read = PCXHR_INPB(mgr, reg);
+		if ((*read & mask) == bit) {
+			if (i > 100)
+				snd_printdd("ATTENTION! check_reg(%x) loopcount=%d\n",
+					    reg, i);
+			return 0;
+		}
+		i++;
+	} while (time_after_eq(end_time, jiffies));
+	snd_printk(KERN_ERR "pcxhr_check_reg_bit: timeout, reg=%x, mask=0x%x, val=0x%x\n",
+		   reg, mask, *read);
+	return -EIO;
+}
+
+/* constants used with pcxhr_check_reg_bit() */
+#define PCXHR_TIMEOUT_DSP		200
+
+
+#define PCXHR_MASK_EXTRA_INFO		0x0000FE
+#define PCXHR_MASK_IT_HF0		0x000100
+#define PCXHR_MASK_IT_HF1		0x000200
+#define PCXHR_MASK_IT_NO_HF0_HF1	0x000400
+#define PCXHR_MASK_IT_MANAGE_HF5	0x000800
+#define PCXHR_MASK_IT_WAIT		0x010000
+#define PCXHR_MASK_IT_WAIT_EXTRA	0x020000
+
+#define PCXHR_IT_SEND_BYTE_XILINX	(0x0000003C | PCXHR_MASK_IT_HF0)
+#define PCXHR_IT_TEST_XILINX		(0x0000003C | PCXHR_MASK_IT_HF1 | \
+					 PCXHR_MASK_IT_MANAGE_HF5)
+#define PCXHR_IT_DOWNLOAD_BOOT		(0x0000000C | PCXHR_MASK_IT_HF1 | \
+					 PCXHR_MASK_IT_MANAGE_HF5 | PCXHR_MASK_IT_WAIT)
+#define PCXHR_IT_RESET_BOARD_FUNC	(0x0000000C | PCXHR_MASK_IT_HF0 | \
+					 PCXHR_MASK_IT_MANAGE_HF5 | PCXHR_MASK_IT_WAIT_EXTRA)
+#define PCXHR_IT_DOWNLOAD_DSP		(0x0000000C | \
+					 PCXHR_MASK_IT_MANAGE_HF5 | PCXHR_MASK_IT_WAIT)
+#define PCXHR_IT_DEBUG			(0x0000005A | PCXHR_MASK_IT_NO_HF0_HF1)
+#define PCXHR_IT_RESET_SEMAPHORE	(0x0000005C | PCXHR_MASK_IT_NO_HF0_HF1)
+#define PCXHR_IT_MESSAGE		(0x00000074 | PCXHR_MASK_IT_NO_HF0_HF1)
+#define PCXHR_IT_RESET_CHK		(0x00000076 | PCXHR_MASK_IT_NO_HF0_HF1)
+#define PCXHR_IT_UPDATE_RBUFFER		(0x00000078 | PCXHR_MASK_IT_NO_HF0_HF1)
+
+static int pcxhr_send_it_dsp(struct pcxhr_mgr *mgr, unsigned int itdsp, int atomic)
+{
+	int err;
+	unsigned char reg;
+
+	if (itdsp & PCXHR_MASK_IT_MANAGE_HF5) {
+		/* clear hf5 bit */
+		PCXHR_OUTPL(mgr, PCXHR_PLX_MBOX0,
+			    PCXHR_INPL(mgr, PCXHR_PLX_MBOX0) & ~PCXHR_MBOX0_HF5);
+	}
+	if ((itdsp & PCXHR_MASK_IT_NO_HF0_HF1) == 0) {
+		reg = PCXHR_ICR_HI08_RREQ | PCXHR_ICR_HI08_TREQ | PCXHR_ICR_HI08_HDRQ;
+		if (itdsp & PCXHR_MASK_IT_HF0)
+			reg |= PCXHR_ICR_HI08_HF0;
+		if (itdsp & PCXHR_MASK_IT_HF1)
+			reg |= PCXHR_ICR_HI08_HF1;
+		PCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg);
+	}
+	reg = (unsigned char)(((itdsp & PCXHR_MASK_EXTRA_INFO) >> 1) | PCXHR_CVR_HI08_HC);
+	PCXHR_OUTPB(mgr, PCXHR_DSP_CVR, reg);
+	if (itdsp & PCXHR_MASK_IT_WAIT) {
+		if (atomic)
+			mdelay(PCXHR_WAIT_IT);
+		else
+			msleep(PCXHR_WAIT_IT);
+	}
+	if (itdsp & PCXHR_MASK_IT_WAIT_EXTRA) {
+		if (atomic)
+			mdelay(PCXHR_WAIT_IT_EXTRA);
+		else
+			msleep(PCXHR_WAIT_IT);
+	}
+	/* wait for CVR_HI08_HC == 0 */
+	err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_CVR,  PCXHR_CVR_HI08_HC, 0,
+				  PCXHR_TIMEOUT_DSP, &reg);
+	if (err) {
+		snd_printk(KERN_ERR "pcxhr_send_it_dsp : TIMEOUT CVR\n");
+		return err;
+	}
+	if (itdsp & PCXHR_MASK_IT_MANAGE_HF5) {
+		/* wait for hf5 bit */
+		err = pcxhr_check_reg_bit(mgr, PCXHR_PLX_MBOX0, PCXHR_MBOX0_HF5,
+					  PCXHR_MBOX0_HF5, PCXHR_TIMEOUT_DSP, &reg);
+		if (err) {
+			snd_printk(KERN_ERR "pcxhr_send_it_dsp : TIMEOUT HF5\n");
+			return err;
+		}
+	}
+	return 0; /* retry not handled here */
+}
+
+void pcxhr_reset_xilinx_com(struct pcxhr_mgr *mgr)
+{
+	/* reset second xilinx */
+	PCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC,
+		    PCXHR_CHIPSC_INIT_VALUE & ~PCXHR_CHIPSC_RESET_XILINX);
+}
+
+static void pcxhr_enable_irq(struct pcxhr_mgr *mgr, int enable)
+{
+	unsigned int reg = PCXHR_INPL(mgr, PCXHR_PLX_IRQCS);
+	/* enable/disable interrupts */
+	if (enable)
+		reg |=  (PCXHR_IRQCS_ENABLE_PCIIRQ | PCXHR_IRQCS_ENABLE_PCIDB);
+	else
+		reg &= ~(PCXHR_IRQCS_ENABLE_PCIIRQ | PCXHR_IRQCS_ENABLE_PCIDB);
+	PCXHR_OUTPL(mgr, PCXHR_PLX_IRQCS, reg);
+}
+
+void pcxhr_reset_dsp(struct pcxhr_mgr *mgr)
+{
+	/* disable interrupts */
+	pcxhr_enable_irq(mgr, 0);
+
+	/* let's reset the DSP */
+	PCXHR_OUTPB(mgr, PCXHR_DSP_RESET, 0);
+	msleep( PCXHR_WAIT_DEFAULT ); /* wait 2 msec */
+	PCXHR_OUTPB(mgr, PCXHR_DSP_RESET, 3);
+	msleep( PCXHR_WAIT_DEFAULT ); /* wait 2 msec */
+
+	/* reset mailbox */
+	PCXHR_OUTPL(mgr, PCXHR_PLX_MBOX0, 0);
+}
+
+void pcxhr_enable_dsp(struct pcxhr_mgr *mgr)
+{
+	/* enable interrupts */
+	pcxhr_enable_irq(mgr, 1);
+}
+
+/*
+ * load the xilinx image
+ */
+int pcxhr_load_xilinx_binary(struct pcxhr_mgr *mgr, const struct firmware *xilinx, int second)
+{
+	unsigned int i;
+	unsigned int chipsc;
+	unsigned char data;
+	unsigned char mask;
+	unsigned char *image;
+
+	/* test first xilinx */
+	chipsc = PCXHR_INPL(mgr, PCXHR_PLX_CHIPSC);
+	if (!second) {
+		if (chipsc & PCXHR_CHIPSC_GPI_USERI) {
+			snd_printdd("no need to load first xilinx\n");
+			return 0; /* first xilinx is already present and cannot be reset */
+		}
+	} else {
+		if ((chipsc & PCXHR_CHIPSC_GPI_USERI) == 0) {
+			snd_printk(KERN_ERR "error loading first xilinx\n");
+			return -EINVAL;
+		}
+		/* activate second xilinx */
+		chipsc |= PCXHR_CHIPSC_RESET_XILINX;
+		PCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC, chipsc);
+		msleep( PCXHR_WAIT_DEFAULT ); /* wait 2 msec */
+	}
+	image = xilinx->data;
+	for (i = 0; i < xilinx->size; i++, image++) {
+		data = *image;
+		mask = 0x80;
+		while (mask) {
+			chipsc &= ~(PCXHR_CHIPSC_DATA_CLK | PCXHR_CHIPSC_DATA_IN);
+			if (data & mask)
+				chipsc |= PCXHR_CHIPSC_DATA_IN;
+			PCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC, chipsc);
+			chipsc |= PCXHR_CHIPSC_DATA_CLK;
+			PCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC, chipsc);
+			mask >>= 1;
+		}
+		/* don't take too much time in this loop... */
+		cond_resched();
+	}
+	chipsc &= ~(PCXHR_CHIPSC_DATA_CLK | PCXHR_CHIPSC_DATA_IN);
+	PCXHR_OUTPL(mgr, PCXHR_PLX_CHIPSC, chipsc);
+	/* wait 2 msec (time to boot the xilinx before any access) */
+	msleep( PCXHR_WAIT_DEFAULT );
+	return 0;
+}
+
+/*
+ * send an executable file to the DSP
+ */
+static int pcxhr_download_dsp(struct pcxhr_mgr *mgr, const struct firmware *dsp)
+{
+	int err;
+	unsigned int i;
+	unsigned int len;
+	unsigned char *data;
+	unsigned char dummy;
+	/* check the length of boot image */
+	snd_assert(dsp->size > 0, return -EINVAL);
+	snd_assert(dsp->size % 3 == 0, return -EINVAL);
+	snd_assert(dsp->data, return -EINVAL);
+	/* transfert data buffer from PC to DSP */
+	for (i = 0; i < dsp->size; i += 3) {
+		data = dsp->data + i;
+		if (i == 0) {
+			/* test data header consistency */
+			len = (unsigned int)((data[0]<<16) + (data[1]<<8) + data[2]);
+			snd_assert((len==0) || (dsp->size == (len+2)*3), return -EINVAL);
+		}
+		/* wait DSP ready for new transfer */
+		err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_TRDY,
+					  PCXHR_ISR_HI08_TRDY, PCXHR_TIMEOUT_DSP, &dummy);
+		if (err) {
+			snd_printk(KERN_ERR "dsp loading error at position %d\n", i);
+			return err;
+		}
+		/* send host data */
+		PCXHR_OUTPB(mgr, PCXHR_DSP_TXH, data[0]);
+		PCXHR_OUTPB(mgr, PCXHR_DSP_TXM, data[1]);
+		PCXHR_OUTPB(mgr, PCXHR_DSP_TXL, data[2]);
+
+		/* don't take too much time in this loop... */
+		cond_resched();
+	}
+	/* give some time to boot the DSP */
+	msleep(PCXHR_WAIT_DEFAULT);
+	return 0;
+}
+
+/*
+ * load the eeprom image
+ */
+int pcxhr_load_eeprom_binary(struct pcxhr_mgr *mgr, const struct firmware *eeprom)
+{
+	int err;
+	unsigned char reg;
+
+	/* init value of the ICR register */
+	reg = PCXHR_ICR_HI08_RREQ | PCXHR_ICR_HI08_TREQ | PCXHR_ICR_HI08_HDRQ;
+	if (PCXHR_INPL(mgr, PCXHR_PLX_MBOX0) & PCXHR_MBOX0_BOOT_HERE) {
+		/* no need to load the eeprom binary, but init the HI08 interface */
+		PCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg | PCXHR_ICR_HI08_INIT);
+		msleep(PCXHR_WAIT_DEFAULT);
+		PCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg);
+		msleep(PCXHR_WAIT_DEFAULT);
+		snd_printdd("no need to load eeprom boot\n");
+		return 0;
+	}
+	PCXHR_OUTPB(mgr, PCXHR_DSP_ICR, reg);
+
+	err = pcxhr_download_dsp(mgr, eeprom);
+	if (err)
+		return err;
+	/* wait for chk bit */
+	return pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_CHK,
+				   PCXHR_ISR_HI08_CHK, PCXHR_TIMEOUT_DSP, &reg);
+}
+
+/*
+ * load the boot image
+ */
+int pcxhr_load_boot_binary(struct pcxhr_mgr *mgr, const struct firmware *boot)
+{
+	int err;
+	unsigned int physaddr = mgr->hostport.addr;
+	unsigned char dummy;
+
+	/* send the hostport address to the DSP (only the upper 24 bit !) */
+	snd_assert((physaddr & 0xff) == 0, return -EINVAL);
+	PCXHR_OUTPL(mgr, PCXHR_PLX_MBOX1, (physaddr >> 8));
+
+	err = pcxhr_send_it_dsp(mgr, PCXHR_IT_DOWNLOAD_BOOT, 0);
+	if (err)
+		return err;
+	/* clear hf5 bit */
+	PCXHR_OUTPL(mgr, PCXHR_PLX_MBOX0,
+		    PCXHR_INPL(mgr, PCXHR_PLX_MBOX0) & ~PCXHR_MBOX0_HF5);
+
+	err = pcxhr_download_dsp(mgr, boot);
+	if (err)
+		return err;
+	/* wait for hf5 bit */
+	return pcxhr_check_reg_bit(mgr, PCXHR_PLX_MBOX0, PCXHR_MBOX0_HF5,
+				   PCXHR_MBOX0_HF5, PCXHR_TIMEOUT_DSP, &dummy);
+}
+
+/*
+ * load the final dsp image
+ */
+int pcxhr_load_dsp_binary(struct pcxhr_mgr *mgr, const struct firmware *dsp)
+{
+	int err;
+	unsigned char dummy;
+	err = pcxhr_send_it_dsp(mgr, PCXHR_IT_RESET_BOARD_FUNC, 0);
+	if (err)
+		return err;
+	err = pcxhr_send_it_dsp(mgr, PCXHR_IT_DOWNLOAD_DSP, 0);
+	if (err)
+		return err;
+	err = pcxhr_download_dsp(mgr, dsp);
+	if (err)
+		return err;
+	/* wait for chk bit */
+	return pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_CHK,
+				   PCXHR_ISR_HI08_CHK, PCXHR_TIMEOUT_DSP, &dummy);
+}
+
+
+struct pcxhr_cmd_info {
+	u32 opcode;		/* command word */
+	u16 st_length;		/* status length */
+	u16 st_type;		/* status type (RMH_SSIZE_XXX) */
+};
+
+/* RMH status type */
+enum {
+	RMH_SSIZE_FIXED = 0,	/* status size fix (st_length = 0..x) */
+	RMH_SSIZE_ARG = 1,	/* status size given in the LSB byte (used with st_length = 1) */
+	RMH_SSIZE_MASK = 2,	/* status size given in bitmask  (used with st_length = 1) */
+};
+
+/*
+ * Array of DSP commands
+ */
+static struct pcxhr_cmd_info pcxhr_dsp_cmds[] = {
+[CMD_VERSION] =				{ 0x010000, 1, RMH_SSIZE_FIXED },
+[CMD_SUPPORTED] =			{ 0x020000, 4, RMH_SSIZE_FIXED },
+[CMD_TEST_IT] =				{ 0x040000, 1, RMH_SSIZE_FIXED },
+[CMD_SEND_IRQA] =			{ 0x070001, 0, RMH_SSIZE_FIXED },
+[CMD_ACCESS_IO_WRITE] =			{ 0x090000, 1, RMH_SSIZE_ARG },
+[CMD_ACCESS_IO_READ] =			{ 0x094000, 1, RMH_SSIZE_ARG },
+[CMD_ASYNC] =				{ 0x0a0000, 1, RMH_SSIZE_ARG },
+[CMD_MODIFY_CLOCK] =			{ 0x0d0000, 0, RMH_SSIZE_FIXED },
+[CMD_RESYNC_AUDIO_INPUTS] =		{ 0x0e0000, 0, RMH_SSIZE_FIXED },
+[CMD_GET_DSP_RESOURCES] =		{ 0x100000, 4, RMH_SSIZE_FIXED },
+[CMD_SET_TIMER_INTERRUPT] =		{ 0x110000, 0, RMH_SSIZE_FIXED },
+[CMD_RES_PIPE] =			{ 0x400000, 0, RMH_SSIZE_FIXED },
+[CMD_FREE_PIPE] =			{ 0x410000, 0, RMH_SSIZE_FIXED },
+[CMD_CONF_PIPE] =			{ 0x422101, 0, RMH_SSIZE_FIXED },
+[CMD_STOP_PIPE] =			{ 0x470004, 0, RMH_SSIZE_FIXED },
+[CMD_PIPE_SAMPLE_COUNT] =		{ 0x49a000, 2, RMH_SSIZE_FIXED },
+[CMD_CAN_START_PIPE] =			{ 0x4b0000, 1, RMH_SSIZE_FIXED },
+[CMD_START_STREAM] =			{ 0x802000, 0, RMH_SSIZE_FIXED },
+[CMD_STREAM_OUT_LEVEL_ADJUST] =		{ 0x822000, 0, RMH_SSIZE_FIXED },
+[CMD_STOP_STREAM] =			{ 0x832000, 0, RMH_SSIZE_FIXED },
+[CMD_UPDATE_R_BUFFERS] =		{ 0x840000, 0, RMH_SSIZE_FIXED },
+[CMD_FORMAT_STREAM_OUT] =		{ 0x860000, 0, RMH_SSIZE_FIXED },
+[CMD_FORMAT_STREAM_IN] =		{ 0x870000, 0, RMH_SSIZE_FIXED },
+[CMD_STREAM_SAMPLE_COUNT] =		{ 0x902000, 2, RMH_SSIZE_FIXED },	/* stat_len = nb_streams * 2 */
+[CMD_AUDIO_LEVEL_ADJUST] =		{ 0xc22000, 0, RMH_SSIZE_FIXED },
+};
+
+#ifdef CONFIG_SND_DEBUG_DETECT
+static char* cmd_names[] = {
+[CMD_VERSION] =				"CMD_VERSION",
+[CMD_SUPPORTED] =			"CMD_SUPPORTED",
+[CMD_TEST_IT] =				"CMD_TEST_IT",
+[CMD_SEND_IRQA] =			"CMD_SEND_IRQA",
+[CMD_ACCESS_IO_WRITE] =			"CMD_ACCESS_IO_WRITE",
+[CMD_ACCESS_IO_READ] =			"CMD_ACCESS_IO_READ",
+[CMD_ASYNC] =				"CMD_ASYNC",
+[CMD_MODIFY_CLOCK] =			"CMD_MODIFY_CLOCK",
+[CMD_RESYNC_AUDIO_INPUTS] =		"CMD_RESYNC_AUDIO_INPUTS",
+[CMD_GET_DSP_RESOURCES] =		"CMD_GET_DSP_RESOURCES",
+[CMD_SET_TIMER_INTERRUPT] =		"CMD_SET_TIMER_INTERRUPT",
+[CMD_RES_PIPE] =			"CMD_RES_PIPE",
+[CMD_FREE_PIPE] =			"CMD_FREE_PIPE",
+[CMD_CONF_PIPE] =			"CMD_CONF_PIPE",
+[CMD_STOP_PIPE] =			"CMD_STOP_PIPE",
+[CMD_PIPE_SAMPLE_COUNT] =		"CMD_PIPE_SAMPLE_COUNT",
+[CMD_CAN_START_PIPE] =			"CMD_CAN_START_PIPE",
+[CMD_START_STREAM] =			"CMD_START_STREAM",
+[CMD_STREAM_OUT_LEVEL_ADJUST] =		"CMD_STREAM_OUT_LEVEL_ADJUST",
+[CMD_STOP_STREAM] =			"CMD_STOP_STREAM",
+[CMD_UPDATE_R_BUFFERS] =		"CMD_UPDATE_R_BUFFERS",
+[CMD_FORMAT_STREAM_OUT] =		"CMD_FORMAT_STREAM_OUT",
+[CMD_FORMAT_STREAM_IN] =		"CMD_FORMAT_STREAM_IN",
+[CMD_STREAM_SAMPLE_COUNT] =		"CMD_STREAM_SAMPLE_COUNT",
+[CMD_AUDIO_LEVEL_ADJUST] =		"CMD_AUDIO_LEVEL_ADJUST",
+};
+#endif
+
+
+static int pcxhr_read_rmh_status(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
+{
+	int err;
+	int i;
+	u32 data;
+	u32 size_mask;
+	unsigned char reg;
+	int max_stat_len;
+
+	if (rmh->stat_len < PCXHR_SIZE_MAX_STATUS)
+		max_stat_len = PCXHR_SIZE_MAX_STATUS;
+	else	max_stat_len = rmh->stat_len;
+
+	for (i = 0; i < rmh->stat_len; i++) {
+		/* wait for receiver full */
+		err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_RXDF,
+					  PCXHR_ISR_HI08_RXDF, PCXHR_TIMEOUT_DSP, &reg);
+		if (err) {
+			snd_printk(KERN_ERR "ERROR RMH stat: ISR:RXDF=1 (ISR = %x; i=%d )\n",
+				   reg, i);
+			return err;
+		}
+		/* read data */
+		data  = PCXHR_INPB(mgr, PCXHR_DSP_TXH) << 16;
+		data |= PCXHR_INPB(mgr, PCXHR_DSP_TXM) << 8;
+		data |= PCXHR_INPB(mgr, PCXHR_DSP_TXL);
+
+		/* need to update rmh->stat_len on the fly ?? */
+		if (i==0) {
+			if (rmh->dsp_stat != RMH_SSIZE_FIXED) {
+				if (rmh->dsp_stat == RMH_SSIZE_ARG) {
+					rmh->stat_len = (u16)(data & 0x0000ff) + 1;
+					data &= 0xffff00;
+				} else {
+					/* rmh->dsp_stat == RMH_SSIZE_MASK */
+					rmh->stat_len = 1;
+					size_mask = data;
+					while (size_mask) {
+						if (size_mask & 1)
+							rmh->stat_len++;
+						size_mask >>= 1;
+					}
+				}
+			}
+		}
+#ifdef CONFIG_SND_DEBUG_DETECT
+		if (rmh->cmd_idx < CMD_LAST_INDEX)
+			snd_printdd("    stat[%d]=%x\n", i, data);
+#endif
+		if (i < max_stat_len)
+			rmh->stat[i] = data;
+	}
+	if (rmh->stat_len > max_stat_len) {
+		snd_printdd("PCXHR : rmh->stat_len=%x too big\n", rmh->stat_len);
+		rmh->stat_len = max_stat_len;
+	}
+	return 0;
+}
+
+static int pcxhr_send_msg_nolock(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
+{
+	int err;
+	int i;
+	u32 data;
+	unsigned char reg;
+
+	snd_assert(rmh->cmd_len<PCXHR_SIZE_MAX_CMD, return -EINVAL);
+	err = pcxhr_send_it_dsp(mgr, PCXHR_IT_MESSAGE, 1);
+	if (err) {
+		snd_printk(KERN_ERR "pcxhr_send_message : ED_DSP_CRASHED\n");
+		return err;
+	}
+	/* wait for chk bit */
+	err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_CHK,
+				  PCXHR_ISR_HI08_CHK, PCXHR_TIMEOUT_DSP, &reg);
+	if (err)
+		return err;
+	/* reset irq chk */
+	err = pcxhr_send_it_dsp(mgr, PCXHR_IT_RESET_CHK, 1);
+	if (err)
+		return err;
+	/* wait for chk bit == 0*/
+	err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_CHK, 0,
+				  PCXHR_TIMEOUT_DSP, &reg);
+	if (err)
+		return err;
+
+	data = rmh->cmd[0];
+
+	if (rmh->cmd_len > 1)
+		data |= 0x008000;	/* MASK_MORE_THAN_1_WORD_COMMAND */
+	else
+		data &= 0xff7fff;	/* MASK_1_WORD_COMMAND */
+#ifdef CONFIG_SND_DEBUG_DETECT
+	if (rmh->cmd_idx < CMD_LAST_INDEX)
+		snd_printdd("MSG cmd[0]=%x (%s)\n", data, cmd_names[rmh->cmd_idx]);
+#endif
+
+	err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_TRDY,
+				  PCXHR_ISR_HI08_TRDY, PCXHR_TIMEOUT_DSP, &reg);
+	if (err)
+		return err;
+	PCXHR_OUTPB(mgr, PCXHR_DSP_TXH, (data>>16)&0xFF);
+	PCXHR_OUTPB(mgr, PCXHR_DSP_TXM, (data>>8)&0xFF);
+	PCXHR_OUTPB(mgr, PCXHR_DSP_TXL, (data&0xFF));
+
+	if (rmh->cmd_len > 1) {
+		/* send length */
+		data = rmh->cmd_len - 1;
+		err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_TRDY,
+					  PCXHR_ISR_HI08_TRDY, PCXHR_TIMEOUT_DSP, &reg);
+		if (err)
+			return err;
+		PCXHR_OUTPB(mgr, PCXHR_DSP_TXH, (data>>16)&0xFF);
+		PCXHR_OUTPB(mgr, PCXHR_DSP_TXM, (data>>8)&0xFF);
+		PCXHR_OUTPB(mgr, PCXHR_DSP_TXL, (data&0xFF));
+
+		for (i=1; i < rmh->cmd_len; i++) {
+			/* send other words */
+			data = rmh->cmd[i];
+#ifdef CONFIG_SND_DEBUG_DETECT
+			if (rmh->cmd_idx < CMD_LAST_INDEX)
+				snd_printdd("    cmd[%d]=%x\n", i, data);
+#endif
+			err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR,
+						  PCXHR_ISR_HI08_TRDY,
+						  PCXHR_ISR_HI08_TRDY,
+						  PCXHR_TIMEOUT_DSP, &reg);
+			if (err)
+				return err;
+			PCXHR_OUTPB(mgr, PCXHR_DSP_TXH, (data>>16)&0xFF);
+			PCXHR_OUTPB(mgr, PCXHR_DSP_TXM, (data>>8)&0xFF);
+			PCXHR_OUTPB(mgr, PCXHR_DSP_TXL, (data&0xFF));
+		}
+	}
+	/* wait for chk bit */
+	err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_CHK,
+				  PCXHR_ISR_HI08_CHK, PCXHR_TIMEOUT_DSP, &reg);
+	if (err)
+		return err;
+	/* test status ISR */
+	if (reg & PCXHR_ISR_HI08_ERR) {
+		/* ERROR, wait for receiver full */
+		err = pcxhr_check_reg_bit(mgr, PCXHR_DSP_ISR, PCXHR_ISR_HI08_RXDF,
+					  PCXHR_ISR_HI08_RXDF, PCXHR_TIMEOUT_DSP, &reg);
+		if (err) {
+			snd_printk(KERN_ERR "ERROR RMH: ISR:RXDF=1 (ISR = %x)\n", reg);
+			return err;
+		}
+		/* read error code */
+		data  = PCXHR_INPB(mgr, PCXHR_DSP_TXH) << 16;
+		data |= PCXHR_INPB(mgr, PCXHR_DSP_TXM) << 8;
+		data |= PCXHR_INPB(mgr, PCXHR_DSP_TXL);
+		snd_printk(KERN_ERR "ERROR RMH(%d): 0x%x\n", rmh->cmd_idx, data);
+		err = -EINVAL;
+	} else {
+		/* read the response data */
+		err = pcxhr_read_rmh_status(mgr, rmh);
+	}
+	/* reset semaphore */
+	if (pcxhr_send_it_dsp(mgr, PCXHR_IT_RESET_SEMAPHORE, 1) < 0)
+		return -EIO;
+	return err;
+}
+
+
+/**
+ * pcxhr_init_rmh - initialize the RMH instance
+ * @rmh: the rmh pointer to be initialized
+ * @cmd: the rmh command to be set
+ */
+void pcxhr_init_rmh(struct pcxhr_rmh *rmh, int cmd)
+{
+	snd_assert(cmd < CMD_LAST_INDEX, return);
+	rmh->cmd[0] = pcxhr_dsp_cmds[cmd].opcode;
+	rmh->cmd_len = 1;
+	rmh->stat_len = pcxhr_dsp_cmds[cmd].st_length;
+	rmh->dsp_stat = pcxhr_dsp_cmds[cmd].st_type;
+	rmh->cmd_idx = cmd;
+}
+
+
+void pcxhr_set_pipe_cmd_params(struct pcxhr_rmh *rmh, int capture,
+			       unsigned int param1, unsigned int param2,
+			       unsigned int param3)
+{
+	snd_assert(param1 <= MASK_FIRST_FIELD);
+	if (capture)
+		rmh->cmd[0] |= 0x800;		/* COMMAND_RECORD_MASK */
+	if (param1)
+		rmh->cmd[0] |= (param1 << FIELD_SIZE);
+	if (param2) {
+		snd_assert(param2 <= MASK_FIRST_FIELD);
+		rmh->cmd[0] |= param2;
+	}
+	if(param3) {
+		snd_assert(param3 <= MASK_DSP_WORD);
+		rmh->cmd[1] = param3;
+		rmh->cmd_len = 2;
+	}
+}
+
+/*
+ * pcxhr_send_msg - send a DSP message with spinlock
+ * @rmh: the rmh record to send and receive
+ *
+ * returns 0 if successful, or a negative error code.
+ */
+int pcxhr_send_msg(struct pcxhr_mgr *mgr, struct pcxhr_rmh *rmh)
+{
+	unsigned long flags;
+	int err;
+	spin_lock_irqsave(&mgr->msg_lock, flags);
+	err = pcxhr_send_msg_nolock(mgr, rmh);
+	spin_unlock_irqrestore(&mgr->msg_lock, flags);
+	return err;
+}
+
+static inline int pcxhr_pipes_running(struct pcxhr_mgr *mgr)
+{
+	int start_mask = PCXHR_INPL(mgr, PCXHR_PLX_MBOX2);
+	/* least segnificant 12 bits are the pipe states for the playback audios */
+	/* next 12 bits are the pipe states for the capture audios
+	 * (PCXHR_PIPE_STATE_CAPTURE_OFFSET)
+	 */
+	start_mask &= 0xffffff;
+	snd_printdd("CMD_PIPE_STATE MBOX2=0x%06x\n", start_mask);
+	return start_mask;
+}
+
+#define PCXHR_PIPE_STATE_CAPTURE_OFFSET		12
+#define MAX_WAIT_FOR_DSP			20
+
+static int pcxhr_prepair_pipe_start(struct pcxhr_mgr *mgr, int audio_mask, int *retry)
+{
+	struct pcxhr_rmh rmh;
+	int err;
+	int audio = 0;
+
+	*retry = 0;
+	while (audio_mask) {
+		if (audio_mask & 1) {
+			pcxhr_init_rmh(&rmh, CMD_CAN_START_PIPE);
+			if (audio < PCXHR_PIPE_STATE_CAPTURE_OFFSET) {
+				/* can start playback pipe */
+				pcxhr_set_pipe_cmd_params(&rmh, 0, audio, 0, 0);
+			} else {
+				/* can start capture pipe */
+				pcxhr_set_pipe_cmd_params(&rmh, 1, audio -
+							  PCXHR_PIPE_STATE_CAPTURE_OFFSET,
+							  0, 0);
+			}
+			err = pcxhr_send_msg(mgr, &rmh);
+			if (err) {
+				snd_printk(KERN_ERR
+					   "error pipe start (CMD_CAN_START_PIPE) err=%x!\n",
+					   err);
+				return err;
+			}
+			/* if the pipe couldn't be prepaired for start, retry it later */
+			if (rmh.stat[0] == 0)
+				*retry |= (1<<audio);
+		}
+		audio_mask>>=1;
+		audio++;
+	}
+	return 0;
+}
+
+static int pcxhr_stop_pipes(struct pcxhr_mgr *mgr, int audio_mask)
+{
+	struct pcxhr_rmh rmh;
+	int err;
+	int audio = 0;
+
+	while (audio_mask) {
+		if (audio_mask & 1) {
+			pcxhr_init_rmh(&rmh, CMD_STOP_PIPE);
+			if (audio < PCXHR_PIPE_STATE_CAPTURE_OFFSET) {
+				/* stop playback pipe */
+				pcxhr_set_pipe_cmd_params(&rmh, 0, audio, 0, 0);
+			} else {
+				/* stop capture pipe */
+				pcxhr_set_pipe_cmd_params(&rmh, 1, audio -
+							  PCXHR_PIPE_STATE_CAPTURE_OFFSET,
+							  0, 0);
+			}
+			err = pcxhr_send_msg(mgr, &rmh);
+			if (err) {
+				snd_printk(KERN_ERR
+					   "error pipe stop (CMD_STOP_PIPE) err=%x!\n",
+					   err);
+				return err;
+			}
+		}
+		audio_mask>>=1;
+		audio++;
+	}
+	return 0;
+}
+
+static int pcxhr_toggle_pipes(struct pcxhr_mgr *mgr, int audio_mask)
+{
+	struct pcxhr_rmh rmh;
+	int err;
+	int audio = 0;
+
+	while (audio_mask) {
+		if (audio_mask & 1) {
+			pcxhr_init_rmh(&rmh, CMD_CONF_PIPE);
+			if (audio < PCXHR_PIPE_STATE_CAPTURE_OFFSET)
+				pcxhr_set_pipe_cmd_params(&rmh, 0, 0, 0, 1 << audio);
+			else
+				pcxhr_set_pipe_cmd_params(&rmh, 1, 0, 0,
+							  1 << (audio - PCXHR_PIPE_STATE_CAPTURE_OFFSET));
+			err = pcxhr_send_msg(mgr, &rmh);
+			if (err) {
+				snd_printk(KERN_ERR
+					   "error pipe start (CMD_CONF_PIPE) err=%x!\n",
+					   err);
+				return err;
+			}
+		}
+		audio_mask>>=1;
+		audio++;
+	}
+	/* now fire the interrupt on the card */
+	pcxhr_init_rmh(&rmh, CMD_SEND_IRQA);
+	err = pcxhr_send_msg(mgr, &rmh);
+	if (err) {
+		snd_printk(KERN_ERR "error pipe start (CMD_SEND_IRQA) err=%x!\n", err );
+		return err;
+	}
+	return 0;
+}
+
+
+
+int pcxhr_set_pipe_state(struct pcxhr_mgr *mgr, int playback_mask, int capture_mask, int start)
+{
+	int state, i, err;
+	int audio_mask;
+
+#ifdef CONFIG_SND_DEBUG_DETECT
+	struct timeval my_tv1, my_tv2;
+	do_gettimeofday(&my_tv1);
+#endif
+	audio_mask = (playback_mask | (capture_mask << PCXHR_PIPE_STATE_CAPTURE_OFFSET));
+	/* current pipe state (playback + record) */
+	state = pcxhr_pipes_running(mgr);
+	snd_printdd("pcxhr_set_pipe_state %s (mask %x current %x)\n",
+		    start ? "START" : "STOP", audio_mask, state);
+	if (start) {
+		audio_mask &= ~state;	/* start only pipes that are not yet started */
+		state = audio_mask;
+		for (i = 0; i < MAX_WAIT_FOR_DSP; i++) {
+			err = pcxhr_prepair_pipe_start(mgr, state, &state);
+			if (err)
+				return err;
+			if (state == 0)
+				break;	/* success, all pipes prepaired for start */
+			mdelay(1);		/* otherwise wait 1 millisecond and retry */
+		}
+	} else {
+		audio_mask &= state;	/* stop only pipes that are started */
+	}
+	if (audio_mask == 0)
+		return 0;
+
+	err = pcxhr_toggle_pipes(mgr, audio_mask);
+	if (err)
+		return err;
+
+	i = 0;
+	while (1) {
+		state = pcxhr_pipes_running(mgr);
+		/* have all pipes the new state ? */
+		if ((state & audio_mask) == (start ? audio_mask : 0))
+			break;
+		if (++i >= MAX_WAIT_FOR_DSP * 100) {
+			snd_printk(KERN_ERR "error pipe start/stop (ED_NO_RESPONSE_AT_IRQA)\n");
+			return -EBUSY;
+		}
+		udelay(10);			/* wait 10 microseconds */
+	}
+	if (!start) {
+		err = pcxhr_stop_pipes(mgr, audio_mask);
+		if (err)
+			return err;
+	}
+#ifdef CONFIG_SND_DEBUG_DETECT
+	do_gettimeofday(&my_tv2);
+	snd_printdd("***SET PIPE STATE*** TIME = %ld (err = %x)\n",
+		    my_tv2.tv_usec - my_tv1.tv_usec, err);
+#endif
+	return 0;
+}
+
+int pcxhr_write_io_num_reg_cont(struct pcxhr_mgr *mgr, unsigned int mask,
+				unsigned int value, int *changed)
+{
+	struct pcxhr_rmh rmh;
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&mgr->msg_lock, flags);
+	if ((mgr->io_num_reg_cont & mask) == value) {
+		snd_printdd("IO_NUM_REG_CONT mask %x already is set to %x\n", mask, value);
+		if (changed)
+			*changed = 0;
+		spin_unlock_irqrestore(&mgr->msg_lock, flags);
+		return 0;	/* already programmed */
+	}
+	pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);
+	rmh.cmd[0] |= IO_NUM_REG_CONT;
+	rmh.cmd[1]  = mask;
+	rmh.cmd[2]  = value;
+	rmh.cmd_len = 3;
+	err = pcxhr_send_msg_nolock(mgr, &rmh);
+	if (err == 0) {
+		mgr->io_num_reg_cont &= ~mask;
+		mgr->io_num_reg_cont |= value;
+		if (changed)
+			*changed = 1;
+	}
+	spin_unlock_irqrestore(&mgr->msg_lock, flags);
+	return err;
+}
+
+#define PCXHR_IRQ_TIMER		0x000300
+#define PCXHR_IRQ_FREQ_CHANGE	0x000800
+#define PCXHR_IRQ_TIME_CODE	0x001000
+#define PCXHR_IRQ_NOTIFY	0x002000
+#define PCXHR_IRQ_ASYNC		0x008000
+#define PCXHR_IRQ_MASK		0x00bb00
+#define PCXHR_FATAL_DSP_ERR	0xff0000
+
+enum pcxhr_async_err_src {
+	PCXHR_ERR_PIPE,
+	PCXHR_ERR_STREAM,
+	PCXHR_ERR_AUDIO
+};
+
+static int pcxhr_handle_async_err(struct pcxhr_mgr *mgr, u32 err,
+				  enum pcxhr_async_err_src err_src, int pipe,
+				  int is_capture)
+{
+#ifdef CONFIG_SND_DEBUG_DETECT
+	static char* err_src_name[] = {
+		[PCXHR_ERR_PIPE]	= "Pipe",
+		[PCXHR_ERR_STREAM]	= "Stream",
+		[PCXHR_ERR_AUDIO]	= "Audio"
+	};
+#endif
+	if (err & 0xfff)
+		err &= 0xfff;
+	else
+		err = ((err >> 12) & 0xfff);
+	if (!err)
+		return 0;
+	snd_printdd("CMD_ASYNC : Error %s %s Pipe %d err=%x\n", err_src_name[err_src],
+		    is_capture ? "Record" : "Play", pipe, err);
+	if (err == 0xe01)
+		mgr->async_err_stream_xrun++;
+	else if (err == 0xe10)
+		mgr->async_err_pipe_xrun++;
+	else
+		mgr->async_err_other_last = (int)err;
+	return 1;
+}
+
+
+void pcxhr_msg_tasklet(unsigned long arg)
+{
+	struct pcxhr_mgr *mgr = (struct pcxhr_mgr *)(arg);
+	struct pcxhr_rmh *prmh = mgr->prmh;
+	int err;
+	int i, j;
+
+	if (mgr->src_it_dsp & PCXHR_IRQ_FREQ_CHANGE)
+		snd_printdd("TASKLET : PCXHR_IRQ_FREQ_CHANGE event occured\n");
+	if (mgr->src_it_dsp & PCXHR_IRQ_TIME_CODE)
+		snd_printdd("TASKLET : PCXHR_IRQ_TIME_CODE event occured\n");
+	if (mgr->src_it_dsp & PCXHR_IRQ_NOTIFY)
+		snd_printdd("TASKLET : PCXHR_IRQ_NOTIFY event occured\n");
+	if (mgr->src_it_dsp & PCXHR_IRQ_ASYNC) {
+		snd_printdd("TASKLET : PCXHR_IRQ_ASYNC event occured\n");
+
+		pcxhr_init_rmh(prmh, CMD_ASYNC);
+		prmh->cmd[0] |= 1;	/* add SEL_ASYNC_EVENTS */
+		/* this is the only one extra long response command */
+		prmh->stat_len = PCXHR_SIZE_MAX_LONG_STATUS;
+		err = pcxhr_send_msg(mgr, prmh);
+		if (err)
+			snd_printk(KERN_ERR "ERROR pcxhr_msg_tasklet=%x;\n", err);
+		i = 1;
+		while (i < prmh->stat_len) {
+			int nb_audio = (prmh->stat[i] >> FIELD_SIZE) & MASK_FIRST_FIELD;
+			int nb_stream = (prmh->stat[i] >> (2*FIELD_SIZE)) & MASK_FIRST_FIELD;
+			int pipe = prmh->stat[i] & MASK_FIRST_FIELD;
+			int is_capture = prmh->stat[i] & 0x400000;
+			u32 err;
+
+			if (prmh->stat[i] & 0x800000) {	/* if BIT_END */
+				snd_printdd("TASKLET : End%sPipe %d\n",
+					    is_capture ? "Record" : "Play", pipe);
+			}
+			i++;
+			err = prmh->stat[i] ? prmh->stat[i] : prmh->stat[i+1];
+			if (err)
+				pcxhr_handle_async_err(mgr, err, PCXHR_ERR_PIPE,
+						       pipe, is_capture);
+			i += 2;
+			for (j = 0; j < nb_stream; j++) {
+				err = prmh->stat[i] ? prmh->stat[i] : prmh->stat[i+1];
+				if (err)
+					pcxhr_handle_async_err(mgr, err, PCXHR_ERR_STREAM,
+							       pipe, is_capture);
+				i += 2;
+			}
+			for (j = 0; j < nb_audio; j++) {
+				err = prmh->stat[i] ? prmh->stat[i] : prmh->stat[i+1];
+				if (err)
+					pcxhr_handle_async_err(mgr, err, PCXHR_ERR_AUDIO,
+							       pipe, is_capture);
+				i += 2;
+			}
+		}
+	}
+}
+
+static u_int64_t pcxhr_stream_read_position(struct pcxhr_mgr *mgr,
+					    struct pcxhr_stream *stream)
+{
+	u_int64_t hw_sample_count;
+	struct pcxhr_rmh rmh;
+	int err, stream_mask;
+
+	stream_mask = stream->pipe->is_capture ? 1 : 1<<stream->substream->number;
+
+	/* get sample count for one stream */
+	pcxhr_init_rmh(&rmh, CMD_STREAM_SAMPLE_COUNT);
+	pcxhr_set_pipe_cmd_params(&rmh, stream->pipe->is_capture,
+				  stream->pipe->first_audio, 0, stream_mask);
+	/* rmh.stat_len = 2; */		/* 2 resp data for each stream of the pipe */
+
+	err = pcxhr_send_msg(mgr, &rmh);
+	if (err)
+		return 0;
+
+	hw_sample_count = ((u_int64_t)rmh.stat[0]) << 24;
+	hw_sample_count += (u_int64_t)rmh.stat[1];
+
+	snd_printdd("stream %c%d : abs samples real(%ld) timer(%ld)\n",
+		    stream->pipe->is_capture ? 'C':'P', stream->substream->number,
+		    (long unsigned int)hw_sample_count,
+		    (long unsigned int)(stream->timer_abs_periods +
+					stream->timer_period_frag + PCXHR_GRANULARITY));
+
+	return hw_sample_count;
+}
+
+static void pcxhr_update_timer_pos(struct pcxhr_mgr *mgr,
+				   struct pcxhr_stream *stream, int samples_to_add)
+{
+	if (stream->substream && (stream->status == PCXHR_STREAM_STATUS_RUNNING)) {
+		u_int64_t new_sample_count;
+		int elapsed = 0;
+		int hardware_read = 0;
+		struct snd_pcm_runtime *runtime = stream->substream->runtime;
+
+		if (samples_to_add < 0) {
+			stream->timer_is_synced = 0;
+			/* add default if no hardware_read possible */
+			samples_to_add = PCXHR_GRANULARITY;
+		}
+
+		if (!stream->timer_is_synced) {
+			if (stream->timer_abs_periods != 0 ||
+			    stream->timer_period_frag + PCXHR_GRANULARITY >=
+			    runtime->period_size) {
+				new_sample_count = pcxhr_stream_read_position(mgr, stream);
+				hardware_read = 1;
+				if (new_sample_count >= PCXHR_GRANULARITY_MIN) {
+					/* sub security offset because of jitter and
+					 * finer granularity of dsp time (MBOX4)
+					 */
+					new_sample_count -= PCXHR_GRANULARITY_MIN;
+					stream->timer_is_synced = 1;
+				}
+			}
+		}
+		if (!hardware_read) {
+			/* if we didn't try to sync the position, increment it
+			 * by PCXHR_GRANULARITY every timer interrupt
+			 */
+			new_sample_count = stream->timer_abs_periods +
+				stream->timer_period_frag + samples_to_add;
+		}
+		while (1) {
+			u_int64_t new_elapse_pos = stream->timer_abs_periods +
+				runtime->period_size;
+			if (new_elapse_pos > new_sample_count)
+				break;
+			elapsed = 1;
+			stream->timer_buf_periods++;
+			if (stream->timer_buf_periods >= runtime->periods)
+				stream->timer_buf_periods = 0;
+			stream->timer_abs_periods = new_elapse_pos;
+		}
+		if (new_sample_count >= stream->timer_abs_periods)
+			stream->timer_period_frag = (u_int32_t)(new_sample_count -
+								stream->timer_abs_periods);
+		else
+			snd_printk(KERN_ERR "ERROR new_sample_count too small ??? %lx\n",
+				   (long unsigned int)new_sample_count);
+
+		if (elapsed) {
+			spin_unlock(&mgr->lock);
+			snd_pcm_period_elapsed(stream->substream);
+			spin_lock(&mgr->lock);
+		}
+	}
+}
+
+
+irqreturn_t pcxhr_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct pcxhr_mgr *mgr = dev_id;
+	unsigned int reg;
+	int i, j;
+	struct snd_pcxhr *chip;
+
+	spin_lock(&mgr->lock);
+
+	reg = PCXHR_INPL(mgr, PCXHR_PLX_IRQCS);
+	if (! (reg & PCXHR_IRQCS_ACTIVE_PCIDB)) {
+		spin_unlock(&mgr->lock);
+		return IRQ_NONE;	/* this device did not cause the interrupt */
+	}
+
+	/* clear interrupt */
+	reg = PCXHR_INPL(mgr, PCXHR_PLX_L2PCIDB);
+	PCXHR_OUTPL(mgr, PCXHR_PLX_L2PCIDB, reg);
+
+	/* timer irq occured */
+	if (reg & PCXHR_IRQ_TIMER) {
+		int timer_toggle = reg & PCXHR_IRQ_TIMER;
+		/* is a 24 bit counter */
+		int dsp_time_new = PCXHR_INPL(mgr, PCXHR_PLX_MBOX4) & PCXHR_DSP_TIME_MASK;
+		int dsp_time_diff = dsp_time_new - mgr->dsp_time_last;
+
+		if (dsp_time_diff < 0 && mgr->dsp_time_last != PCXHR_DSP_TIME_INVALID) {
+			snd_printdd("ERROR DSP TIME old(%d) new(%d) -> "
+				    "resynchronize all streams\n",
+				    mgr->dsp_time_last, dsp_time_new);
+			mgr->dsp_time_err++;
+		}
+#ifdef CONFIG_SND_DEBUG_DETECT
+		if (dsp_time_diff == 0)
+			snd_printdd("ERROR DSP TIME NO DIFF time(%d)\n", dsp_time_new);
+		else if (dsp_time_diff >= (2*PCXHR_GRANULARITY))
+			snd_printdd("ERROR DSP TIME TOO BIG old(%d) add(%d)\n",
+				    mgr->dsp_time_last, dsp_time_new - mgr->dsp_time_last);
+#endif
+		mgr->dsp_time_last = dsp_time_new;
+
+		if (timer_toggle == mgr->timer_toggle)
+			snd_printk(KERN_ERR "ERROR TIMER TOGGLE\n");
+		mgr->timer_toggle = timer_toggle;
+
+		reg &= ~PCXHR_IRQ_TIMER;
+		for (i = 0; i < mgr->num_cards; i++) {
+			chip = mgr->chip[i];
+			for (j = 0; j < chip->nb_streams_capt; j++)
+				pcxhr_update_timer_pos(mgr, &chip->capture_stream[j],
+						       dsp_time_diff);
+		}
+		for (i = 0; i < mgr->num_cards; i++) {
+			chip = mgr->chip[i];
+			for (j = 0; j < chip->nb_streams_play; j++)
+				pcxhr_update_timer_pos(mgr, &chip->playback_stream[j],
+						       dsp_time_diff);
+		}
+	}
+	/* other irq's handled in the tasklet */
+	if (reg & PCXHR_IRQ_MASK) {
+
+		/* as we didn't request any notifications, some kind of xrun error
+		 * will probably occured
+		 */
+		/* better resynchronize all streams next interrupt : */
+		mgr->dsp_time_last = PCXHR_DSP_TIME_INVALID;
+		
+		mgr->src_it_dsp = reg;
+		tasklet_hi_schedule(&mgr->msg_taskq);
+	}
+#ifdef CONFIG_SND_DEBUG_DETECT
+	if (reg & PCXHR_FATAL_DSP_ERR)
+		snd_printdd("FATAL DSP ERROR : %x\n", reg);
+#endif
+	spin_unlock(&mgr->lock);
+	return IRQ_HANDLED;	/* this device caused the interrupt */
+}
