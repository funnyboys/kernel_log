commit 98fd539841319a46ba3773d908bfde13416d57eb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:38 2020 +0100

    ALSA: pcxhr: More constifications
    
    Apply const prefix to each possible place: the board parameters and
    DSP command table, and the string arrays.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index 12a6bdb920b2..2258bd698844 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -348,7 +348,7 @@ static int pcxhr_dsp_load(struct pcxhr_mgr *mgr, int index,
  */
 int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
 {
-	static char *fw_files[][5] = {
+	static const char * const fw_files[][5] = {
 	[0] = { "xlxint.dat", "xlxc882hr.dat",
 		"dspe882.e56", "dspb882hr.b56", "dspd882.d56" },
 	[1] = { "xlxint.dat", "xlxc882e.dat",

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index a99808ab01fe..12a6bdb920b2 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -1,23 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Driver for Digigram pcxhr compatible soundcards
  *
  * hwdep device manager
  *
  * Copyright (c) 2004 by Digigram <alsa@digigram.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include <linux/interrupt.h>

commit 5b5e0928f742cfa853b2411400a1b19fa379d758
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Feb 27 14:30:02 2017 -0800

    lib/vsprintf.c: remove %Z support
    
    Now that %z is standartised in C99 there is no reason to support %Z.
    Unlike %L it doesn't even make format strings smaller.
    
    Use BUILD_BUG_ON in a couple ATM drivers.
    
    In case anyone didn't notice lib/vsprintf.o is about half of SLUB which
    is in my opinion is quite an achievement.  Hopefully this patch inspires
    someone else to trim vsprintf.c more.
    
    Link: http://lkml.kernel.org/r/20170103230126.GA30170@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index 80633055e17e..a99808ab01fe 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -292,7 +292,7 @@ static int pcxhr_dsp_load(struct pcxhr_mgr *mgr, int index,
 	int err, card_index;
 
 	dev_dbg(&mgr->pci->dev,
-		"loading dsp [%d] size = %Zd\n", index, dsp->size);
+		"loading dsp [%d] size = %zd\n", index, dsp->size);
 
 	switch (index) {
 	case PCXHR_FIRMWARE_XLX_INT_INDEX:

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index 15a8ce5f1f48..80633055e17e 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -25,7 +25,7 @@
 #include <linux/firmware.h>
 #include <linux/pci.h>
 #include <linux/module.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <sound/core.h>
 #include <sound/hwdep.h>
 #include "pcxhr.h"

commit b59bb8efd1c1f2eaeed13eccf1fa4e564d2383ae
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 26 11:47:55 2014 +0100

    ALSA: pcxhr: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index d995175c1c48..15a8ce5f1f48 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -72,7 +72,8 @@ static int pcxhr_init_board(struct pcxhr_mgr *mgr)
 	/* test max nb substream per pipe */
 	if (((rmh.stat[1] >> 7) & 0x5F) < PCXHR_PLAYBACK_STREAMS)
 		return -EINVAL;
-	snd_printdd("supported formats : playback=%x capture=%x\n",
+	dev_dbg(&mgr->pci->dev,
+		"supported formats : playback=%x capture=%x\n",
 		    rmh.stat[2], rmh.stat[3]);
 
 	pcxhr_init_rmh(&rmh, CMD_VERSION);
@@ -84,7 +85,8 @@ static int pcxhr_init_board(struct pcxhr_mgr *mgr)
 	err = pcxhr_send_msg(mgr, &rmh);
 	if (err)
 		return err;
-	snd_printdd("PCXHR DSP version is %d.%d.%d\n", (rmh.stat[0]>>16)&0xff,
+	dev_dbg(&mgr->pci->dev,
+		"PCXHR DSP version is %d.%d.%d\n", (rmh.stat[0]>>16)&0xff,
 		    (rmh.stat[0]>>8)&0xff, rmh.stat[0]&0xff);
 	mgr->dsp_version = rmh.stat[0];
 
@@ -179,7 +181,7 @@ static int pcxhr_dsp_allocate_pipe(struct pcxhr_mgr *mgr,
 		stream_count = PCXHR_PLAYBACK_STREAMS;
 		audio_count = 2;	/* always stereo */
 	}
-	snd_printdd("snd_add_ref_pipe pin(%d) pcm%c0\n",
+	dev_dbg(&mgr->pci->dev, "snd_add_ref_pipe pin(%d) pcm%c0\n",
 		    pin, is_capture ? 'c' : 'p');
 	pipe->is_capture = is_capture;
 	pipe->first_audio = pin;
@@ -194,7 +196,7 @@ static int pcxhr_dsp_allocate_pipe(struct pcxhr_mgr *mgr,
 	}
 	err = pcxhr_send_msg(mgr, &rmh);
 	if (err < 0) {
-		snd_printk(KERN_ERR "error pipe allocation "
+		dev_err(&mgr->pci->dev, "error pipe allocation "
 			   "(CMD_RES_PIPE) err=%x!\n", err);
 		return err;
 	}
@@ -222,14 +224,14 @@ static int pcxhr_dsp_free_pipe( struct pcxhr_mgr *mgr, struct pcxhr_pipe *pipe)
 	/* stop one pipe */
 	err = pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 0);
 	if (err < 0)
-		snd_printk(KERN_ERR "error stopping pipe!\n");
+		dev_err(&mgr->pci->dev, "error stopping pipe!\n");
 	/* release the pipe */
 	pcxhr_init_rmh(&rmh, CMD_FREE_PIPE);
 	pcxhr_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->first_audio,
 				  0, 0);
 	err = pcxhr_send_msg(mgr, &rmh);
 	if (err < 0)
-		snd_printk(KERN_ERR "error pipe release "
+		dev_err(&mgr->pci->dev, "error pipe release "
 			   "(CMD_FREE_PIPE) err(%x)\n", err);
 	pipe->status = PCXHR_PIPE_UNDEFINED;
 	return err;
@@ -289,7 +291,8 @@ static int pcxhr_dsp_load(struct pcxhr_mgr *mgr, int index,
 {
 	int err, card_index;
 
-	snd_printdd("loading dsp [%d] size = %Zd\n", index, dsp->size);
+	dev_dbg(&mgr->pci->dev,
+		"loading dsp [%d] size = %Zd\n", index, dsp->size);
 
 	switch (index) {
 	case PCXHR_FIRMWARE_XLX_INT_INDEX:
@@ -313,19 +316,19 @@ static int pcxhr_dsp_load(struct pcxhr_mgr *mgr, int index,
 			return err;
 		break;	/* continue with first init */
 	default:
-		snd_printk(KERN_ERR "wrong file index\n");
+		dev_err(&mgr->pci->dev, "wrong file index\n");
 		return -EFAULT;
 	} /* end of switch file index*/
 
 	/* first communication with embedded */
 	err = pcxhr_init_board(mgr);
         if (err < 0) {
-		snd_printk(KERN_ERR "pcxhr could not be set up\n");
+		dev_err(&mgr->pci->dev, "pcxhr could not be set up\n");
 		return err;
 	}
 	err = pcxhr_config_pipes(mgr);
         if (err < 0) {
-		snd_printk(KERN_ERR "pcxhr pipes could not be set up\n");
+		dev_err(&mgr->pci->dev, "pcxhr pipes could not be set up\n");
 		return err;
 	}
        	/* create devices and mixer in accordance with HW options*/
@@ -344,10 +347,11 @@ static int pcxhr_dsp_load(struct pcxhr_mgr *mgr, int index,
 	}
 	err = pcxhr_start_pipes(mgr);
         if (err < 0) {
-		snd_printk(KERN_ERR "pcxhr pipes could not be started\n");
+		dev_err(&mgr->pci->dev, "pcxhr pipes could not be started\n");
 		return err;
 	}
-	snd_printdd("pcxhr firmware downloaded and successfully set up\n");
+	dev_dbg(&mgr->pci->dev,
+		"pcxhr firmware downloaded and successfully set up\n");
 
 	return 0;
 }
@@ -382,7 +386,8 @@ int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
 			continue;
 		sprintf(path, "pcxhr/%s", fw_files[fw_set][i]);
 		if (request_firmware(&fw_entry, path, &mgr->pci->dev)) {
-			snd_printk(KERN_ERR "pcxhr: can't load firmware %s\n",
+			dev_err(&mgr->pci->dev,
+				"pcxhr: can't load firmware %s\n",
 				   path);
 			return -ENOENT;
 		}

commit d19144987c4b84bda3aaee602242060a5ab504b9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 22 16:11:21 2012 +0100

    ALSA: pcxhr: hard dependency on the standard fw loader
    
    Like the previous commit for mixart, drop the home-baked fw loader
    code.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index bf207e317f71..d995175c1c48 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -35,13 +35,6 @@
 #include "pcxhr_mix22.h"
 
 
-#if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)
-#if !defined(CONFIG_USE_PCXHRLOADER) && !defined(CONFIG_SND_PCXHR) /* built-in kernel */
-#define SND_PCXHR_FW_LOADER	/* use the standard firmware loader */
-#endif
-#endif
-
-
 static int pcxhr_sub_init(struct pcxhr_mgr *mgr);
 /*
  * get basic information and init pcxhr card
@@ -362,8 +355,6 @@ static int pcxhr_dsp_load(struct pcxhr_mgr *mgr, int index,
 /*
  * fw loader entry
  */
-#ifdef SND_PCXHR_FW_LOADER
-
 int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
 {
 	static char *fw_files[][5] = {
@@ -424,80 +415,3 @@ MODULE_FIRMWARE("pcxhr/xlxc924.dat");
 MODULE_FIRMWARE("pcxhr/dspe924.e56");
 MODULE_FIRMWARE("pcxhr/dspb924.b56");
 MODULE_FIRMWARE("pcxhr/dspd222.d56");
-
-
-#else /* old style firmware loading */
-
-/* pcxhr hwdep interface id string */
-#define PCXHR_HWDEP_ID       "pcxhr loader"
-
-
-static int pcxhr_hwdep_dsp_status(struct snd_hwdep *hw,
-				  struct snd_hwdep_dsp_status *info)
-{
-	struct pcxhr_mgr *mgr = hw->private_data;
-	sprintf(info->id, "pcxhr%d", mgr->fw_file_set);
-        info->num_dsps = PCXHR_FIRMWARE_FILES_MAX_INDEX;
-
-	if (hw->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX))
-		info->chip_ready = 1;
-
-	info->version = PCXHR_DRIVER_VERSION;
-	return 0;
-}
-
-static int pcxhr_hwdep_dsp_load(struct snd_hwdep *hw,
-				struct snd_hwdep_dsp_image *dsp)
-{
-	struct pcxhr_mgr *mgr = hw->private_data;
-	int err;
-	struct firmware fw;
-
-	fw.size = dsp->length;
-	fw.data = vmalloc(fw.size);
-	if (! fw.data) {
-		snd_printk(KERN_ERR "pcxhr: cannot allocate dsp image "
-			   "(%lu bytes)\n", (unsigned long)fw.size);
-		return -ENOMEM;
-	}
-	if (copy_from_user((void *)fw.data, dsp->image, dsp->length)) {
-		vfree(fw.data);
-		return -EFAULT;
-	}
-	err = pcxhr_dsp_load(mgr, dsp->index, &fw);
-	vfree(fw.data);
-	if (err < 0)
-		return err;
-	mgr->dsp_loaded |= 1 << dsp->index;
-	return 0;
-}
-
-int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
-{
-	int err;
-	struct snd_hwdep *hw;
-
-	/* only create hwdep interface for first cardX
-	 * (see "index" module parameter)
-	 */
-	err = snd_hwdep_new(mgr->chip[0]->card, PCXHR_HWDEP_ID, 0, &hw);
-	if (err < 0)
-		return err;
-
-	hw->iface = SNDRV_HWDEP_IFACE_PCXHR;
-	hw->private_data = mgr;
-	hw->ops.dsp_status = pcxhr_hwdep_dsp_status;
-	hw->ops.dsp_load = pcxhr_hwdep_dsp_load;
-	hw->exclusive = 1;
-	/* stereo cards don't need fw_file_0 -> dsp_loaded = 1 */
-	hw->dsp_loaded = mgr->is_hr_stereo ? 1 : 0;
-	mgr->dsp_loaded = 0;
-	sprintf(hw->name, PCXHR_HWDEP_ID);
-
-	err = snd_card_register(mgr->chip[0]->card);
-	if (err < 0)
-		return err;
-	return 0;
-}
-
-#endif /* SND_PCXHR_FW_LOADER */

commit 8c3f1b1cbc32d1fa899e3bd9edf427f0f2e7a843
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Fri Aug 24 14:54:57 2012 +0200

    ALSA: pcxhr: Add 8 new sound cards
    
    add new sound cards VX442HR VX442e PCX442HR PCX442e VX822HR VX822e PCX822HR and PCX822e
    
    Signed-off-by: Markus Bollinger <bollinger@digigram.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index ec1587cddb0c..bf207e317f71 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -66,10 +66,10 @@ static int pcxhr_init_board(struct pcxhr_mgr *mgr)
 	err = pcxhr_send_msg(mgr, &rmh);
 	if (err)
 		return err;
-	/* test 8 or 12 phys out */
-	if ((rmh.stat[0] & MASK_FIRST_FIELD) != mgr->playback_chips * 2)
+	/* test 4, 8 or 12 phys out */
+	if ((rmh.stat[0] & MASK_FIRST_FIELD) < mgr->playback_chips * 2)
 		return -EINVAL;
-	/* test 8 or 2 phys in */
+	/* test 4, 8 or 2 phys in */
 	if (((rmh.stat[0] >> (2 * FIELD_SIZE)) & MASK_FIRST_FIELD) <
 	    mgr->capture_chips * 2)
 		return -EINVAL;

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index 17cb1233a903..ec1587cddb0c 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -24,6 +24,7 @@
 #include <linux/vmalloc.h>
 #include <linux/firmware.h>
 #include <linux/pci.h>
+#include <linux/module.h>
 #include <asm/io.h>
 #include <sound/core.h>
 #include <sound/hwdep.h>

commit 28b7e343ee63454d563a71d2d5f769fc297fd5ad
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 09:28:08 2009 +0100

    ALSA: Remove superfluous hwdep ops
    
    Remove NOP hwdep ops in sound drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index 592743a298b0..17cb1233a903 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -471,16 +471,6 @@ static int pcxhr_hwdep_dsp_load(struct snd_hwdep *hw,
 	return 0;
 }
 
-static int pcxhr_hwdep_open(struct snd_hwdep *hw, struct file *file)
-{
-	return 0;
-}
-
-static int pcxhr_hwdep_release(struct snd_hwdep *hw, struct file *file)
-{
-	return 0;
-}
-
 int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
 {
 	int err;
@@ -495,8 +485,6 @@ int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
 
 	hw->iface = SNDRV_HWDEP_IFACE_PCXHR;
 	hw->private_data = mgr;
-	hw->ops.open = pcxhr_hwdep_open;
-	hw->ops.release = pcxhr_hwdep_release;
 	hw->ops.dsp_status = pcxhr_hwdep_dsp_status;
 	hw->ops.dsp_load = pcxhr_hwdep_dsp_load;
 	hw->exclusive = 1;

commit ade9b2fb9bf8114f77eefc70b9042417e62acf72
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Mon Dec 1 15:31:06 2008 +0100

    ALSA: pcxhr - change firmware filenames
    
    - compatibility issue : change firmware filenames
      the pcxhr driver version <= 1.0.18a does not work
      with new firmware > 1.0.17. Keep the old firmware files
      and add new firmware files with different names
    
    Signed-off-by: Markus Bollinger <bollinger@digigram.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index ea50018d785b..592743a298b0 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -366,18 +366,18 @@ static int pcxhr_dsp_load(struct pcxhr_mgr *mgr, int index,
 int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
 {
 	static char *fw_files[][5] = {
-	[0] = { "xi_1_882.dat", "xc_1_882.dat",
-		"e321_512.e56", "b321_512.b56", "d321_512.d56" },
-	[1] = { "xi_1_882.dat", "xc_882e.dat",
-		"e321_512.e56", "b882e.b56", "d321_512.d56" },
-	[2] = { "xi_1_882.dat", "xc_1222.dat",
-		"e321_512.e56", "b1222.b56", "d1222.d56" },
-	[3] = { "xi_1_882.dat", "xc_1222e.dat",
-		"e321_512.e56", "b1222e.b56", "d1222.d56" },
-	[4] = { NULL, "x1_222hr.dat",
-		"e924.e56", "b924.b56", "l_1_222.d56" },
-	[5] = { NULL, "x1_924hr.dat",
-		"e924.e56", "b924.b56", "l_1_222.d56" },
+	[0] = { "xlxint.dat", "xlxc882hr.dat",
+		"dspe882.e56", "dspb882hr.b56", "dspd882.d56" },
+	[1] = { "xlxint.dat", "xlxc882e.dat",
+		"dspe882.e56", "dspb882e.b56", "dspd882.d56" },
+	[2] = { "xlxint.dat", "xlxc1222hr.dat",
+		"dspe882.e56", "dspb1222hr.b56", "dspd1222.d56" },
+	[3] = { "xlxint.dat", "xlxc1222e.dat",
+		"dspe882.e56", "dspb1222e.b56", "dspd1222.d56" },
+	[4] = { NULL, "xlxc222.dat",
+		"dspe924.e56", "dspb924.b56", "dspd222.d56" },
+	[5] = { NULL, "xlxc924.dat",
+		"dspe924.e56", "dspb924.b56", "dspd222.d56" },
 	};
 	char path[32];
 
@@ -404,25 +404,25 @@ int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
 	return 0;
 }
 
-MODULE_FIRMWARE("pcxhr/xi_1_882.dat");
-MODULE_FIRMWARE("pcxhr/xc_1_882.dat");
-MODULE_FIRMWARE("pcxhr/xc_882e.dat");
-MODULE_FIRMWARE("pcxhr/e321_512.e56");
-MODULE_FIRMWARE("pcxhr/b321_512.b56");
-MODULE_FIRMWARE("pcxhr/b882e.b56");
-MODULE_FIRMWARE("pcxhr/d321_512.d56");
-
-MODULE_FIRMWARE("pcxhr/xc_1222.dat");
-MODULE_FIRMWARE("pcxhr/xc_1222e.dat");
-MODULE_FIRMWARE("pcxhr/b1222.b56");
-MODULE_FIRMWARE("pcxhr/b1222e.b56");
-MODULE_FIRMWARE("pcxhr/d1222.d56");
-
-MODULE_FIRMWARE("pcxhr/x1_222hr.dat");
-MODULE_FIRMWARE("pcxhr/x1_924hr.dat");
-MODULE_FIRMWARE("pcxhr/e924.e56");
-MODULE_FIRMWARE("pcxhr/b924.b56");
-MODULE_FIRMWARE("pcxhr/l_1_222.d56");
+MODULE_FIRMWARE("pcxhr/xlxint.dat");
+MODULE_FIRMWARE("pcxhr/xlxc882hr.dat");
+MODULE_FIRMWARE("pcxhr/xlxc882e.dat");
+MODULE_FIRMWARE("pcxhr/dspe882.e56");
+MODULE_FIRMWARE("pcxhr/dspb882hr.b56");
+MODULE_FIRMWARE("pcxhr/dspb882e.b56");
+MODULE_FIRMWARE("pcxhr/dspd882.d56");
+
+MODULE_FIRMWARE("pcxhr/xlxc1222hr.dat");
+MODULE_FIRMWARE("pcxhr/xlxc1222e.dat");
+MODULE_FIRMWARE("pcxhr/dspb1222hr.b56");
+MODULE_FIRMWARE("pcxhr/dspb1222e.b56");
+MODULE_FIRMWARE("pcxhr/dspd1222.d56");
+
+MODULE_FIRMWARE("pcxhr/xlxc222.dat");
+MODULE_FIRMWARE("pcxhr/xlxc924.dat");
+MODULE_FIRMWARE("pcxhr/dspe924.e56");
+MODULE_FIRMWARE("pcxhr/dspb924.b56");
+MODULE_FIRMWARE("pcxhr/dspd222.d56");
 
 
 #else /* old style firmware loading */

commit 7628700e08403618b0b07bd25b6456d8b2d074ef
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Tue Nov 25 12:28:06 2008 +0100

    ALSA: pcxhr - add support for pcxhr stereo sound cards (firmware support)
    
    - Add support for pcxhr stereo cards and their firmware
    - autorize sound cards without analog IO
    - do some cleanup
    
    Signed-off-by: Markus Bollinger <bollinger@digigram.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index 96640d9c227d..ea50018d785b 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -31,6 +31,7 @@
 #include "pcxhr_mixer.h"
 #include "pcxhr_hwdep.h"
 #include "pcxhr_core.h"
+#include "pcxhr_mix22.h"
 
 
 #if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)
@@ -40,10 +41,10 @@
 #endif
 
 
+static int pcxhr_sub_init(struct pcxhr_mgr *mgr);
 /*
  * get basic information and init pcxhr card
  */
-
 static int pcxhr_init_board(struct pcxhr_mgr *mgr)
 {
 	int err;
@@ -68,7 +69,7 @@ static int pcxhr_init_board(struct pcxhr_mgr *mgr)
 	if ((rmh.stat[0] & MASK_FIRST_FIELD) != mgr->playback_chips * 2)
 		return -EINVAL;
 	/* test 8 or 2 phys in */
-	if (((rmh.stat[0] >> (2 * FIELD_SIZE)) & MASK_FIRST_FIELD) !=
+	if (((rmh.stat[0] >> (2 * FIELD_SIZE)) & MASK_FIRST_FIELD) <
 	    mgr->capture_chips * 2)
 		return -EINVAL;
 	/* test max nb substream per board */
@@ -77,20 +78,34 @@ static int pcxhr_init_board(struct pcxhr_mgr *mgr)
 	/* test max nb substream per pipe */
 	if (((rmh.stat[1] >> 7) & 0x5F) < PCXHR_PLAYBACK_STREAMS)
 		return -EINVAL;
+	snd_printdd("supported formats : playback=%x capture=%x\n",
+		    rmh.stat[2], rmh.stat[3]);
 
 	pcxhr_init_rmh(&rmh, CMD_VERSION);
 	/* firmware num for DSP */
 	rmh.cmd[0] |= mgr->firmware_num;
 	/* transfer granularity in samples (should be multiple of 48) */
-	rmh.cmd[1] = (1<<23) + PCXHR_GRANULARITY;
+	rmh.cmd[1] = (1<<23) + mgr->granularity;
 	rmh.cmd_len = 2;
 	err = pcxhr_send_msg(mgr, &rmh);
 	if (err)
 		return err;
-	snd_printdd("PCXHR DSP version is %d.%d.%d\n",
-		    (rmh.stat[0]>>16)&0xff, (rmh.stat[0]>>8)&0xff, rmh.stat[0]&0xff);
+	snd_printdd("PCXHR DSP version is %d.%d.%d\n", (rmh.stat[0]>>16)&0xff,
+		    (rmh.stat[0]>>8)&0xff, rmh.stat[0]&0xff);
 	mgr->dsp_version = rmh.stat[0];
 
+	if (mgr->is_hr_stereo)
+		err = hr222_sub_init(mgr);
+	else
+		err = pcxhr_sub_init(mgr);
+	return err;
+}
+
+static int pcxhr_sub_init(struct pcxhr_mgr *mgr)
+{
+	int err;
+	struct pcxhr_rmh rmh;
+
 	/* get options */
 	pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);
 	rmh.cmd[0] |= IO_NUM_REG_STATUS;
@@ -100,20 +115,22 @@ static int pcxhr_init_board(struct pcxhr_mgr *mgr)
 	if (err)
 		return err;
 
-	if ((rmh.stat[1] & REG_STATUS_OPT_DAUGHTER_MASK) == REG_STATUS_OPT_ANALOG_BOARD)
-		mgr->board_has_analog = 1;	/* analog addon board available */
-	else
-		/* analog addon board not available -> no support for instance */
-		return -EINVAL;	
+	if ((rmh.stat[1] & REG_STATUS_OPT_DAUGHTER_MASK) ==
+	    REG_STATUS_OPT_ANALOG_BOARD)
+		mgr->board_has_analog = 1;	/* analog addon board found */
 
 	/* unmute inputs */
 	err = pcxhr_write_io_num_reg_cont(mgr, REG_CONT_UNMUTE_INPUTS,
 					  REG_CONT_UNMUTE_INPUTS, NULL);
 	if (err)
 		return err;
-	/* unmute outputs */
-	pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ); /* a write to IO_NUM_REG_MUTE_OUT mutes! */
+	/* unmute outputs (a write to IO_NUM_REG_MUTE_OUT mutes!) */
+	pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);
 	rmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;
+	if (DSP_EXT_CMD_SET(mgr)) {
+		rmh.cmd[1]  = 1;	/* unmute digital plugs */
+		rmh.cmd_len = 2;
+	}
 	err = pcxhr_send_msg(mgr, &rmh);
 	return err;
 }
@@ -124,19 +141,25 @@ void pcxhr_reset_board(struct pcxhr_mgr *mgr)
 
 	if (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {
 		/* mute outputs */
+	    if (!mgr->is_hr_stereo) {
 		/* a read to IO_NUM_REG_MUTE_OUT register unmutes! */
 		pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);
 		rmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;
 		pcxhr_send_msg(mgr, &rmh);
 		/* mute inputs */
-		pcxhr_write_io_num_reg_cont(mgr, REG_CONT_UNMUTE_INPUTS, 0, NULL);
+		pcxhr_write_io_num_reg_cont(mgr, REG_CONT_UNMUTE_INPUTS,
+					    0, NULL);
+	    }
+		/* stereo cards mute with reset of dsp */
 	}
 	/* reset pcxhr dsp */
-	if (mgr->dsp_loaded & ( 1 << PCXHR_FIRMWARE_DSP_EPRM_INDEX))
+	if (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_EPRM_INDEX))
 		pcxhr_reset_dsp(mgr);
 	/* reset second xilinx */
-	if (mgr->dsp_loaded & ( 1 << PCXHR_FIRMWARE_XLX_COM_INDEX))
+	if (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_XLX_COM_INDEX)) {
 		pcxhr_reset_xilinx_com(mgr);
+		mgr->dsp_loaded = 1;
+	}
 	return;
 }
 
@@ -144,8 +167,9 @@ void pcxhr_reset_board(struct pcxhr_mgr *mgr)
 /*
  *  allocate a playback/capture pipe (pcmp0/pcmc0)
  */
-static int pcxhr_dsp_allocate_pipe( struct pcxhr_mgr *mgr, struct pcxhr_pipe *pipe,
-				    int is_capture, int pin)
+static int pcxhr_dsp_allocate_pipe(struct pcxhr_mgr *mgr,
+				   struct pcxhr_pipe *pipe,
+				   int is_capture, int pin)
 {
 	int stream_count, audio_count;
 	int err;
@@ -161,15 +185,23 @@ static int pcxhr_dsp_allocate_pipe( struct pcxhr_mgr *mgr, struct pcxhr_pipe *pi
 		stream_count = PCXHR_PLAYBACK_STREAMS;
 		audio_count = 2;	/* always stereo */
 	}
-	snd_printdd("snd_add_ref_pipe pin(%d) pcm%c0\n", pin, is_capture ? 'c' : 'p');
+	snd_printdd("snd_add_ref_pipe pin(%d) pcm%c0\n",
+		    pin, is_capture ? 'c' : 'p');
 	pipe->is_capture = is_capture;
 	pipe->first_audio = pin;
 	/* define pipe (P_PCM_ONLY_MASK (0x020000) is not necessary) */
 	pcxhr_init_rmh(&rmh, CMD_RES_PIPE);
-	pcxhr_set_pipe_cmd_params(&rmh, is_capture, pin, audio_count, stream_count); 
+	pcxhr_set_pipe_cmd_params(&rmh, is_capture, pin,
+				  audio_count, stream_count);
+	rmh.cmd[1] |= 0x020000; /* add P_PCM_ONLY_MASK */
+	if (DSP_EXT_CMD_SET(mgr)) {
+		/* add channel mask to command */
+	  rmh.cmd[rmh.cmd_len++] = (audio_count == 1) ? 0x01 : 0x03;
+	}
 	err = pcxhr_send_msg(mgr, &rmh);
 	if (err < 0) {
-		snd_printk(KERN_ERR "error pipe allocation (CMD_RES_PIPE) err=%x!\n", err );
+		snd_printk(KERN_ERR "error pipe allocation "
+			   "(CMD_RES_PIPE) err=%x!\n", err);
 		return err;
 	}
 	pipe->status = PCXHR_PIPE_DEFINED;
@@ -199,10 +231,12 @@ static int pcxhr_dsp_free_pipe( struct pcxhr_mgr *mgr, struct pcxhr_pipe *pipe)
 		snd_printk(KERN_ERR "error stopping pipe!\n");
 	/* release the pipe */
 	pcxhr_init_rmh(&rmh, CMD_FREE_PIPE);
-	pcxhr_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->first_audio, 0, 0);
+	pcxhr_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->first_audio,
+				  0, 0);
 	err = pcxhr_send_msg(mgr, &rmh);
 	if (err < 0)
-		snd_printk(KERN_ERR "error pipe release (CMD_FREE_PIPE) err(%x)\n", err);
+		snd_printk(KERN_ERR "error pipe release "
+			   "(CMD_FREE_PIPE) err(%x)\n", err);
 	pipe->status = PCXHR_PIPE_UNDEFINED;
 	return err;
 }
@@ -248,15 +282,16 @@ static int pcxhr_start_pipes(struct pcxhr_mgr *mgr)
 	for (i = 0; i < mgr->num_cards; i++) {
 		chip = mgr->chip[i];
 		if (chip->nb_streams_play)
-			playback_mask |= (1 << chip->playback_pipe.first_audio);
+			playback_mask |= 1 << chip->playback_pipe.first_audio;
 		for (j = 0; j < chip->nb_streams_capt; j++)
-			capture_mask |= (1 << chip->capture_pipe[j].first_audio);
+			capture_mask |= 1 << chip->capture_pipe[j].first_audio;
 	}
 	return pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 1);
 }
 
 
-static int pcxhr_dsp_load(struct pcxhr_mgr *mgr, int index, const struct firmware *dsp)
+static int pcxhr_dsp_load(struct pcxhr_mgr *mgr, int index,
+			  const struct firmware *dsp)
 {
 	int err, card_index;
 
@@ -330,22 +365,33 @@ static int pcxhr_dsp_load(struct pcxhr_mgr *mgr, int index, const struct firmwar
 
 int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
 {
-	static char *fw_files[5] = {
-		"xi_1_882.dat",
-		"xc_1_882.dat",
-		"e321_512.e56",
-		"b321_512.b56",
-		"d321_512.d56"
+	static char *fw_files[][5] = {
+	[0] = { "xi_1_882.dat", "xc_1_882.dat",
+		"e321_512.e56", "b321_512.b56", "d321_512.d56" },
+	[1] = { "xi_1_882.dat", "xc_882e.dat",
+		"e321_512.e56", "b882e.b56", "d321_512.d56" },
+	[2] = { "xi_1_882.dat", "xc_1222.dat",
+		"e321_512.e56", "b1222.b56", "d1222.d56" },
+	[3] = { "xi_1_882.dat", "xc_1222e.dat",
+		"e321_512.e56", "b1222e.b56", "d1222.d56" },
+	[4] = { NULL, "x1_222hr.dat",
+		"e924.e56", "b924.b56", "l_1_222.d56" },
+	[5] = { NULL, "x1_924hr.dat",
+		"e924.e56", "b924.b56", "l_1_222.d56" },
 	};
 	char path[32];
 
 	const struct firmware *fw_entry;
 	int i, err;
+	int fw_set = mgr->fw_file_set;
 
-	for (i = 0; i < ARRAY_SIZE(fw_files); i++) {
-		sprintf(path, "pcxhr/%s", fw_files[i]);
+	for (i = 0; i < 5; i++) {
+		if (!fw_files[fw_set][i])
+			continue;
+		sprintf(path, "pcxhr/%s", fw_files[fw_set][i]);
 		if (request_firmware(&fw_entry, path, &mgr->pci->dev)) {
-			snd_printk(KERN_ERR "pcxhr: can't load firmware %s\n", path);
+			snd_printk(KERN_ERR "pcxhr: can't load firmware %s\n",
+				   path);
 			return -ENOENT;
 		}
 		/* fake hwdep dsp record */
@@ -360,10 +406,25 @@ int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
 
 MODULE_FIRMWARE("pcxhr/xi_1_882.dat");
 MODULE_FIRMWARE("pcxhr/xc_1_882.dat");
+MODULE_FIRMWARE("pcxhr/xc_882e.dat");
 MODULE_FIRMWARE("pcxhr/e321_512.e56");
 MODULE_FIRMWARE("pcxhr/b321_512.b56");
+MODULE_FIRMWARE("pcxhr/b882e.b56");
 MODULE_FIRMWARE("pcxhr/d321_512.d56");
 
+MODULE_FIRMWARE("pcxhr/xc_1222.dat");
+MODULE_FIRMWARE("pcxhr/xc_1222e.dat");
+MODULE_FIRMWARE("pcxhr/b1222.b56");
+MODULE_FIRMWARE("pcxhr/b1222e.b56");
+MODULE_FIRMWARE("pcxhr/d1222.d56");
+
+MODULE_FIRMWARE("pcxhr/x1_222hr.dat");
+MODULE_FIRMWARE("pcxhr/x1_924hr.dat");
+MODULE_FIRMWARE("pcxhr/e924.e56");
+MODULE_FIRMWARE("pcxhr/b924.b56");
+MODULE_FIRMWARE("pcxhr/l_1_222.d56");
+
+
 #else /* old style firmware loading */
 
 /* pcxhr hwdep interface id string */
@@ -373,7 +434,8 @@ MODULE_FIRMWARE("pcxhr/d321_512.d56");
 static int pcxhr_hwdep_dsp_status(struct snd_hwdep *hw,
 				  struct snd_hwdep_dsp_status *info)
 {
-	strcpy(info->id, "pcxhr");
+	struct pcxhr_mgr *mgr = hw->private_data;
+	sprintf(info->id, "pcxhr%d", mgr->fw_file_set);
         info->num_dsps = PCXHR_FIRMWARE_FILES_MAX_INDEX;
 
 	if (hw->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX))
@@ -393,8 +455,8 @@ static int pcxhr_hwdep_dsp_load(struct snd_hwdep *hw,
 	fw.size = dsp->length;
 	fw.data = vmalloc(fw.size);
 	if (! fw.data) {
-		snd_printk(KERN_ERR "pcxhr: cannot allocate dsp image (%lu bytes)\n",
-			   (unsigned long)fw.size);
+		snd_printk(KERN_ERR "pcxhr: cannot allocate dsp image "
+			   "(%lu bytes)\n", (unsigned long)fw.size);
 		return -ENOMEM;
 	}
 	if (copy_from_user((void *)fw.data, dsp->image, dsp->length)) {
@@ -424,8 +486,11 @@ int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
 	int err;
 	struct snd_hwdep *hw;
 
-	/* only create hwdep interface for first cardX (see "index" module parameter)*/
-	if ((err = snd_hwdep_new(mgr->chip[0]->card, PCXHR_HWDEP_ID, 0, &hw)) < 0)
+	/* only create hwdep interface for first cardX
+	 * (see "index" module parameter)
+	 */
+	err = snd_hwdep_new(mgr->chip[0]->card, PCXHR_HWDEP_ID, 0, &hw);
+	if (err < 0)
 		return err;
 
 	hw->iface = SNDRV_HWDEP_IFACE_PCXHR;
@@ -435,10 +500,13 @@ int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
 	hw->ops.dsp_status = pcxhr_hwdep_dsp_status;
 	hw->ops.dsp_load = pcxhr_hwdep_dsp_load;
 	hw->exclusive = 1;
+	/* stereo cards don't need fw_file_0 -> dsp_loaded = 1 */
+	hw->dsp_loaded = mgr->is_hr_stereo ? 1 : 0;
 	mgr->dsp_loaded = 0;
 	sprintf(hw->name, PCXHR_HWDEP_ID);
 
-	if ((err = snd_card_register(mgr->chip[0]->card)) < 0)
+	err = snd_card_register(mgr->chip[0]->card);
+	if (err < 0)
 		return err;
 	return 0;
 }

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index d2f043278cf4..96640d9c227d 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -65,15 +65,18 @@ static int pcxhr_init_board(struct pcxhr_mgr *mgr)
 	if (err)
 		return err;
 	/* test 8 or 12 phys out */
-	snd_assert((rmh.stat[0] & MASK_FIRST_FIELD) == mgr->playback_chips*2,
-		   return -EINVAL);
+	if ((rmh.stat[0] & MASK_FIRST_FIELD) != mgr->playback_chips * 2)
+		return -EINVAL;
 	/* test 8 or 2 phys in */
-	snd_assert(((rmh.stat[0] >> (2*FIELD_SIZE)) & MASK_FIRST_FIELD) ==
-		   mgr->capture_chips * 2, return -EINVAL);
+	if (((rmh.stat[0] >> (2 * FIELD_SIZE)) & MASK_FIRST_FIELD) !=
+	    mgr->capture_chips * 2)
+		return -EINVAL;
 	/* test max nb substream per board */
-	snd_assert((rmh.stat[1] & 0x5F) >= card_streams, return -EINVAL);
+	if ((rmh.stat[1] & 0x5F) < card_streams)
+		return -EINVAL;
 	/* test max nb substream per pipe */
-	snd_assert(((rmh.stat[1]>>7)&0x5F) >= PCXHR_PLAYBACK_STREAMS, return -EINVAL);
+	if (((rmh.stat[1] >> 7) & 0x5F) < PCXHR_PLAYBACK_STREAMS)
+		return -EINVAL;
 
 	pcxhr_init_rmh(&rmh, CMD_VERSION);
 	/* firmware num for DSP */

commit 67852dc08c0782735d48ce1e2a6eb44cd02a6ff7
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jul 8 17:45:58 2008 +0100

    Fix a const pointer usage warning in the Digigram pcxhr soundcard driver
    
    Fix a const pointer usage warning in the Digigram pcxhr compatible soundcard
    driver.  A const pointer is being passed to copy_from_user() to load the
    firmware into.  This is okay in this case because the function has allocated
    the firmware struct itself, but the const qualifier is part of the firmware
    struct - so the patch casts the const away.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index e6a4bfbb91bb..d2f043278cf4 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -394,7 +394,7 @@ static int pcxhr_hwdep_dsp_load(struct snd_hwdep *hw,
 			   (unsigned long)fw.size);
 		return -ENOMEM;
 	}
-	if (copy_from_user(fw.data, dsp->image, dsp->length)) {
+	if (copy_from_user((void *)fw.data, dsp->image, dsp->length)) {
 		vfree(fw.data);
 		return -EFAULT;
 	}

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index d55d8bc90eee..e6a4bfbb91bb 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -20,7 +20,6 @@
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
-#include <sound/driver.h>
 #include <linux/interrupt.h>
 #include <linux/vmalloc.h>
 #include <linux/firmware.h>

commit 7e0af29d6f3964bec3d72c6caeb87a603e660fdf
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu May 3 17:59:54 2007 +0200

    [ALSA] add MODULE_FIRMWARE entries
    
    Add MODULE_FIRMWARE() entries, where appropriate.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index 369c19fea985..d55d8bc90eee 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -356,6 +356,12 @@ int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
 	return 0;
 }
 
+MODULE_FIRMWARE("pcxhr/xi_1_882.dat");
+MODULE_FIRMWARE("pcxhr/xc_1_882.dat");
+MODULE_FIRMWARE("pcxhr/e321_512.e56");
+MODULE_FIRMWARE("pcxhr/b321_512.b56");
+MODULE_FIRMWARE("pcxhr/d321_512.d56");
+
 #else /* old style firmware loading */
 
 /* pcxhr hwdep interface id string */

commit 711ee39bf3e2a69005d64f388441a6f883495f83
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Thu Apr 20 12:37:00 2006 +0200

    [ALSA] pcxhr - Fix a compiler warning on 64bit architectures
    
    The patch fixes a conpile warning on 64bit architectures, caused by
    different sizes of size_t . Since size_t is unsigned I permited
    myself to cange the format, too.
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
index 03517c10e99c..369c19fea985 100644
--- a/sound/pci/pcxhr/pcxhr_hwdep.c
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -385,8 +385,8 @@ static int pcxhr_hwdep_dsp_load(struct snd_hwdep *hw,
 	fw.size = dsp->length;
 	fw.data = vmalloc(fw.size);
 	if (! fw.data) {
-		snd_printk(KERN_ERR "pcxhr: cannot allocate dsp image (%d bytes)\n",
-			   fw.size);
+		snd_printk(KERN_ERR "pcxhr: cannot allocate dsp image (%lu bytes)\n",
+			   (unsigned long)fw.size);
 		return -ENOMEM;
 	}
 	if (copy_from_user(fw.data, dsp->image, dsp->length)) {

commit e12229b4d2b7863b1baaeca759aa87703bf9fdf8
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Tue Dec 6 13:55:26 2005 +0100

    [ALSA] Add PCXHR driver
    
    Modules: Documentation,PCI drivers,Digigram PCXHR driver
    
    Add Digigram PCXHR driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr_hwdep.c b/sound/pci/pcxhr/pcxhr_hwdep.c
new file mode 100644
index 000000000000..03517c10e99c
--- /dev/null
+++ b/sound/pci/pcxhr/pcxhr_hwdep.c
@@ -0,0 +1,438 @@
+/*
+ * Driver for Digigram pcxhr compatible soundcards
+ *
+ * hwdep device manager
+ *
+ * Copyright (c) 2004 by Digigram <alsa@digigram.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <sound/driver.h>
+#include <linux/interrupt.h>
+#include <linux/vmalloc.h>
+#include <linux/firmware.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <sound/core.h>
+#include <sound/hwdep.h>
+#include "pcxhr.h"
+#include "pcxhr_mixer.h"
+#include "pcxhr_hwdep.h"
+#include "pcxhr_core.h"
+
+
+#if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)
+#if !defined(CONFIG_USE_PCXHRLOADER) && !defined(CONFIG_SND_PCXHR) /* built-in kernel */
+#define SND_PCXHR_FW_LOADER	/* use the standard firmware loader */
+#endif
+#endif
+
+
+/*
+ * get basic information and init pcxhr card
+ */
+
+static int pcxhr_init_board(struct pcxhr_mgr *mgr)
+{
+	int err;
+	struct pcxhr_rmh rmh;
+	int card_streams;
+
+	/* calc the number of all streams used */
+	if (mgr->mono_capture)
+		card_streams = mgr->capture_chips * 2;
+	else
+		card_streams = mgr->capture_chips;
+	card_streams += mgr->playback_chips * PCXHR_PLAYBACK_STREAMS;
+
+	/* enable interrupts */
+	pcxhr_enable_dsp(mgr);
+
+	pcxhr_init_rmh(&rmh, CMD_SUPPORTED);
+	err = pcxhr_send_msg(mgr, &rmh);
+	if (err)
+		return err;
+	/* test 8 or 12 phys out */
+	snd_assert((rmh.stat[0] & MASK_FIRST_FIELD) == mgr->playback_chips*2,
+		   return -EINVAL);
+	/* test 8 or 2 phys in */
+	snd_assert(((rmh.stat[0] >> (2*FIELD_SIZE)) & MASK_FIRST_FIELD) ==
+		   mgr->capture_chips * 2, return -EINVAL);
+	/* test max nb substream per board */
+	snd_assert((rmh.stat[1] & 0x5F) >= card_streams, return -EINVAL);
+	/* test max nb substream per pipe */
+	snd_assert(((rmh.stat[1]>>7)&0x5F) >= PCXHR_PLAYBACK_STREAMS, return -EINVAL);
+
+	pcxhr_init_rmh(&rmh, CMD_VERSION);
+	/* firmware num for DSP */
+	rmh.cmd[0] |= mgr->firmware_num;
+	/* transfer granularity in samples (should be multiple of 48) */
+	rmh.cmd[1] = (1<<23) + PCXHR_GRANULARITY;
+	rmh.cmd_len = 2;
+	err = pcxhr_send_msg(mgr, &rmh);
+	if (err)
+		return err;
+	snd_printdd("PCXHR DSP version is %d.%d.%d\n",
+		    (rmh.stat[0]>>16)&0xff, (rmh.stat[0]>>8)&0xff, rmh.stat[0]&0xff);
+	mgr->dsp_version = rmh.stat[0];
+
+	/* get options */
+	pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);
+	rmh.cmd[0] |= IO_NUM_REG_STATUS;
+	rmh.cmd[1]  = REG_STATUS_OPTIONS;
+	rmh.cmd_len = 2;
+	err = pcxhr_send_msg(mgr, &rmh);
+	if (err)
+		return err;
+
+	if ((rmh.stat[1] & REG_STATUS_OPT_DAUGHTER_MASK) == REG_STATUS_OPT_ANALOG_BOARD)
+		mgr->board_has_analog = 1;	/* analog addon board available */
+	else
+		/* analog addon board not available -> no support for instance */
+		return -EINVAL;	
+
+	/* unmute inputs */
+	err = pcxhr_write_io_num_reg_cont(mgr, REG_CONT_UNMUTE_INPUTS,
+					  REG_CONT_UNMUTE_INPUTS, NULL);
+	if (err)
+		return err;
+	/* unmute outputs */
+	pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ); /* a write to IO_NUM_REG_MUTE_OUT mutes! */
+	rmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;
+	err = pcxhr_send_msg(mgr, &rmh);
+	return err;
+}
+
+void pcxhr_reset_board(struct pcxhr_mgr *mgr)
+{
+	struct pcxhr_rmh rmh;
+
+	if (mgr->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX)) {
+		/* mute outputs */
+		/* a read to IO_NUM_REG_MUTE_OUT register unmutes! */
+		pcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);
+		rmh.cmd[0] |= IO_NUM_REG_MUTE_OUT;
+		pcxhr_send_msg(mgr, &rmh);
+		/* mute inputs */
+		pcxhr_write_io_num_reg_cont(mgr, REG_CONT_UNMUTE_INPUTS, 0, NULL);
+	}
+	/* reset pcxhr dsp */
+	if (mgr->dsp_loaded & ( 1 << PCXHR_FIRMWARE_DSP_EPRM_INDEX))
+		pcxhr_reset_dsp(mgr);
+	/* reset second xilinx */
+	if (mgr->dsp_loaded & ( 1 << PCXHR_FIRMWARE_XLX_COM_INDEX))
+		pcxhr_reset_xilinx_com(mgr);
+	return;
+}
+
+
+/*
+ *  allocate a playback/capture pipe (pcmp0/pcmc0)
+ */
+static int pcxhr_dsp_allocate_pipe( struct pcxhr_mgr *mgr, struct pcxhr_pipe *pipe,
+				    int is_capture, int pin)
+{
+	int stream_count, audio_count;
+	int err;
+	struct pcxhr_rmh rmh;
+
+	if (is_capture) {
+		stream_count = 1;
+		if (mgr->mono_capture)
+			audio_count = 1;
+		else
+			audio_count = 2;
+	} else {
+		stream_count = PCXHR_PLAYBACK_STREAMS;
+		audio_count = 2;	/* always stereo */
+	}
+	snd_printdd("snd_add_ref_pipe pin(%d) pcm%c0\n", pin, is_capture ? 'c' : 'p');
+	pipe->is_capture = is_capture;
+	pipe->first_audio = pin;
+	/* define pipe (P_PCM_ONLY_MASK (0x020000) is not necessary) */
+	pcxhr_init_rmh(&rmh, CMD_RES_PIPE);
+	pcxhr_set_pipe_cmd_params(&rmh, is_capture, pin, audio_count, stream_count); 
+	err = pcxhr_send_msg(mgr, &rmh);
+	if (err < 0) {
+		snd_printk(KERN_ERR "error pipe allocation (CMD_RES_PIPE) err=%x!\n", err );
+		return err;
+	}
+	pipe->status = PCXHR_PIPE_DEFINED;
+
+	return 0;
+}
+
+/*
+ *  free playback/capture pipe (pcmp0/pcmc0)
+ */
+#if 0
+static int pcxhr_dsp_free_pipe( struct pcxhr_mgr *mgr, struct pcxhr_pipe *pipe)
+{
+	struct pcxhr_rmh rmh;
+	int capture_mask = 0;
+	int playback_mask = 0;
+	int err = 0;
+
+	if (pipe->is_capture)
+		capture_mask  = (1 << pipe->first_audio);
+	else
+		playback_mask = (1 << pipe->first_audio);
+
+	/* stop one pipe */
+	err = pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 0);
+	if (err < 0)
+		snd_printk(KERN_ERR "error stopping pipe!\n");
+	/* release the pipe */
+	pcxhr_init_rmh(&rmh, CMD_FREE_PIPE);
+	pcxhr_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->first_audio, 0, 0);
+	err = pcxhr_send_msg(mgr, &rmh);
+	if (err < 0)
+		snd_printk(KERN_ERR "error pipe release (CMD_FREE_PIPE) err(%x)\n", err);
+	pipe->status = PCXHR_PIPE_UNDEFINED;
+	return err;
+}
+#endif
+
+
+static int pcxhr_config_pipes(struct pcxhr_mgr *mgr)
+{
+	int err, i, j;
+	struct snd_pcxhr *chip;
+	struct pcxhr_pipe *pipe;
+
+	/* allocate the pipes on the dsp */
+	for (i = 0; i < mgr->num_cards; i++) {
+		chip = mgr->chip[i];
+		if (chip->nb_streams_play) {
+			pipe = &chip->playback_pipe;
+			err = pcxhr_dsp_allocate_pipe( mgr, pipe, 0, i*2);
+			if (err)
+				return err;
+			for(j = 0; j < chip->nb_streams_play; j++)
+				chip->playback_stream[j].pipe = pipe;
+		}
+		for (j = 0; j < chip->nb_streams_capt; j++) {
+			pipe = &chip->capture_pipe[j];
+			err = pcxhr_dsp_allocate_pipe(mgr, pipe, 1, i*2 + j);
+			if (err)
+				return err;
+			chip->capture_stream[j].pipe = pipe;
+		}
+	}
+	return 0;
+}
+
+static int pcxhr_start_pipes(struct pcxhr_mgr *mgr)
+{
+	int i, j;
+	struct snd_pcxhr *chip;
+	int playback_mask = 0;
+	int capture_mask = 0;
+
+	/* start all the pipes on the dsp */
+	for (i = 0; i < mgr->num_cards; i++) {
+		chip = mgr->chip[i];
+		if (chip->nb_streams_play)
+			playback_mask |= (1 << chip->playback_pipe.first_audio);
+		for (j = 0; j < chip->nb_streams_capt; j++)
+			capture_mask |= (1 << chip->capture_pipe[j].first_audio);
+	}
+	return pcxhr_set_pipe_state(mgr, playback_mask, capture_mask, 1);
+}
+
+
+static int pcxhr_dsp_load(struct pcxhr_mgr *mgr, int index, const struct firmware *dsp)
+{
+	int err, card_index;
+
+	snd_printdd("loading dsp [%d] size = %Zd\n", index, dsp->size);
+
+	switch (index) {
+	case PCXHR_FIRMWARE_XLX_INT_INDEX:
+		pcxhr_reset_xilinx_com(mgr);
+		return pcxhr_load_xilinx_binary(mgr, dsp, 0);
+
+	case PCXHR_FIRMWARE_XLX_COM_INDEX:
+		pcxhr_reset_xilinx_com(mgr);
+		return pcxhr_load_xilinx_binary(mgr, dsp, 1);
+
+	case PCXHR_FIRMWARE_DSP_EPRM_INDEX:
+		pcxhr_reset_dsp(mgr);
+		return pcxhr_load_eeprom_binary(mgr, dsp);
+
+	case PCXHR_FIRMWARE_DSP_BOOT_INDEX:
+		return pcxhr_load_boot_binary(mgr, dsp);
+
+	case PCXHR_FIRMWARE_DSP_MAIN_INDEX:
+		err = pcxhr_load_dsp_binary(mgr, dsp);
+		if (err)
+			return err;
+		break;	/* continue with first init */
+	default:
+		snd_printk(KERN_ERR "wrong file index\n");
+		return -EFAULT;
+	} /* end of switch file index*/
+
+	/* first communication with embedded */
+	err = pcxhr_init_board(mgr);
+        if (err < 0) {
+		snd_printk(KERN_ERR "pcxhr could not be set up\n");
+		return err;
+	}
+	err = pcxhr_config_pipes(mgr);
+        if (err < 0) {
+		snd_printk(KERN_ERR "pcxhr pipes could not be set up\n");
+		return err;
+	}
+       	/* create devices and mixer in accordance with HW options*/
+        for (card_index = 0; card_index < mgr->num_cards; card_index++) {
+		struct snd_pcxhr *chip = mgr->chip[card_index];
+
+		if ((err = pcxhr_create_pcm(chip)) < 0)
+			return err;
+
+		if (card_index == 0) {
+			if ((err = pcxhr_create_mixer(chip->mgr)) < 0)
+				return err;
+		}
+		if ((err = snd_card_register(chip->card)) < 0)
+			return err;
+	}
+	err = pcxhr_start_pipes(mgr);
+        if (err < 0) {
+		snd_printk(KERN_ERR "pcxhr pipes could not be started\n");
+		return err;
+	}
+	snd_printdd("pcxhr firmware downloaded and successfully set up\n");
+
+	return 0;
+}
+
+/*
+ * fw loader entry
+ */
+#ifdef SND_PCXHR_FW_LOADER
+
+int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
+{
+	static char *fw_files[5] = {
+		"xi_1_882.dat",
+		"xc_1_882.dat",
+		"e321_512.e56",
+		"b321_512.b56",
+		"d321_512.d56"
+	};
+	char path[32];
+
+	const struct firmware *fw_entry;
+	int i, err;
+
+	for (i = 0; i < ARRAY_SIZE(fw_files); i++) {
+		sprintf(path, "pcxhr/%s", fw_files[i]);
+		if (request_firmware(&fw_entry, path, &mgr->pci->dev)) {
+			snd_printk(KERN_ERR "pcxhr: can't load firmware %s\n", path);
+			return -ENOENT;
+		}
+		/* fake hwdep dsp record */
+		err = pcxhr_dsp_load(mgr, i, fw_entry);
+		release_firmware(fw_entry);
+		if (err < 0)
+			return err;
+		mgr->dsp_loaded |= 1 << i;
+	}
+	return 0;
+}
+
+#else /* old style firmware loading */
+
+/* pcxhr hwdep interface id string */
+#define PCXHR_HWDEP_ID       "pcxhr loader"
+
+
+static int pcxhr_hwdep_dsp_status(struct snd_hwdep *hw,
+				  struct snd_hwdep_dsp_status *info)
+{
+	strcpy(info->id, "pcxhr");
+        info->num_dsps = PCXHR_FIRMWARE_FILES_MAX_INDEX;
+
+	if (hw->dsp_loaded & (1 << PCXHR_FIRMWARE_DSP_MAIN_INDEX))
+		info->chip_ready = 1;
+
+	info->version = PCXHR_DRIVER_VERSION;
+	return 0;
+}
+
+static int pcxhr_hwdep_dsp_load(struct snd_hwdep *hw,
+				struct snd_hwdep_dsp_image *dsp)
+{
+	struct pcxhr_mgr *mgr = hw->private_data;
+	int err;
+	struct firmware fw;
+
+	fw.size = dsp->length;
+	fw.data = vmalloc(fw.size);
+	if (! fw.data) {
+		snd_printk(KERN_ERR "pcxhr: cannot allocate dsp image (%d bytes)\n",
+			   fw.size);
+		return -ENOMEM;
+	}
+	if (copy_from_user(fw.data, dsp->image, dsp->length)) {
+		vfree(fw.data);
+		return -EFAULT;
+	}
+	err = pcxhr_dsp_load(mgr, dsp->index, &fw);
+	vfree(fw.data);
+	if (err < 0)
+		return err;
+	mgr->dsp_loaded |= 1 << dsp->index;
+	return 0;
+}
+
+static int pcxhr_hwdep_open(struct snd_hwdep *hw, struct file *file)
+{
+	return 0;
+}
+
+static int pcxhr_hwdep_release(struct snd_hwdep *hw, struct file *file)
+{
+	return 0;
+}
+
+int pcxhr_setup_firmware(struct pcxhr_mgr *mgr)
+{
+	int err;
+	struct snd_hwdep *hw;
+
+	/* only create hwdep interface for first cardX (see "index" module parameter)*/
+	if ((err = snd_hwdep_new(mgr->chip[0]->card, PCXHR_HWDEP_ID, 0, &hw)) < 0)
+		return err;
+
+	hw->iface = SNDRV_HWDEP_IFACE_PCXHR;
+	hw->private_data = mgr;
+	hw->ops.open = pcxhr_hwdep_open;
+	hw->ops.release = pcxhr_hwdep_release;
+	hw->ops.dsp_status = pcxhr_hwdep_dsp_status;
+	hw->ops.dsp_load = pcxhr_hwdep_dsp_load;
+	hw->exclusive = 1;
+	mgr->dsp_loaded = 0;
+	sprintf(hw->name, PCXHR_HWDEP_ID);
+
+	if ((err = snd_card_register(mgr->chip[0]->card)) < 0)
+		return err;
+	return 0;
+}
+
+#endif /* SND_PCXHR_FW_LOADER */
