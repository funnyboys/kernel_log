commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/pcxhr/pcxhr.h b/sound/pci/pcxhr/pcxhr.h
index d799cbd37301..1b85200d00dd 100644
--- a/sound/pci/pcxhr/pcxhr.h
+++ b/sound/pci/pcxhr/pcxhr.h
@@ -1,23 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Driver for Digigram pcxhr soundcards
  *
  * main header file
  *
  * Copyright (c) 2004 by Digigram <alsa@digigram.com>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #ifndef __SOUND_PCXHR_H

commit 5051735221ba50cb5794b9194a8ad10a13368f2f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jul 18 13:48:10 2017 +0200

    ALSA: pcxhr: fix string overflow warnings
    
    With gcc-7, we get a warning about a possible string overflow:
    
    sound/pci/pcxhr/pcxhr.c: In function 'pcxhr_probe':
    sound/pci/pcxhr/pcxhr.c:1647:28: error: ' [PCM #' directive writing 7 bytes into a region of size between 1 and 32 [-Werror=format-overflow=]
    
    The shortname can simply be removed, and the longname can
    be changed into a shorter "name" string that is used in three
    places. Making it a little shorter (40 bytes) avoids the risk of
    overflowing completely, but I also use snprintf() here for
    extra clarity.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.h b/sound/pci/pcxhr/pcxhr.h
index 9e39e509a3ef..d799cbd37301 100644
--- a/sound/pci/pcxhr/pcxhr.h
+++ b/sound/pci/pcxhr/pcxhr.h
@@ -75,8 +75,7 @@ struct pcxhr_mgr {
 	unsigned long port[3];
 
 	/* share the name */
-	char shortname[32];		/* short name of this soundcard */
-	char longname[96];		/* name of this soundcard */
+	char name[40];			/* name of this soundcard */
 
 	struct pcxhr_rmh *prmh;
 

commit 9bef72bdb26e291d6dffb04768741a0e49582666
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 10 12:21:38 2014 +0200

    ALSA: pcxhr: Use nonatomic PCM ops
    
    This time PCXHR, another Digigram boards: like the previous patches,
    the conversion is straightforward, replacing spinlocks with mutexes,
    merging the irq tasklet into the threaded irq handler and the PCM
    trigger tasklet back to the trigger callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.h b/sound/pci/pcxhr/pcxhr.h
index a4c602c45173..9e39e509a3ef 100644
--- a/sound/pci/pcxhr/pcxhr.h
+++ b/sound/pci/pcxhr/pcxhr.h
@@ -78,14 +78,10 @@ struct pcxhr_mgr {
 	char shortname[32];		/* short name of this soundcard */
 	char longname[96];		/* name of this soundcard */
 
-	/* message tasklet */
-	struct tasklet_struct msg_taskq;
 	struct pcxhr_rmh *prmh;
-	/* trigger tasklet */
-	struct tasklet_struct trigger_taskq;
 
-	spinlock_t lock;		/* interrupt spinlock */
-	spinlock_t msg_lock;		/* message spinlock */
+	struct mutex lock;		/* interrupt lock */
+	struct mutex msg_lock;		/* message lock */
 
 	struct mutex setup_mutex;	/* mutex used in hw_params, open and close */
 	struct mutex mixer_mutex;	/* mutex for mixer */

commit fdfbaf69e0b9d6843c0da6501caf4ecacec0f775
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Wed Jun 20 08:34:40 2012 +0200

    ALSA: pcxhr: Add LTC support
    
    add LTC (linear timecode) read function via proc interface to the pcxhr driver
    
    Signed-off-by: Markus Bollinger <bollinger@digigram.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.h b/sound/pci/pcxhr/pcxhr.h
index bda776c49884..a4c602c45173 100644
--- a/sound/pci/pcxhr/pcxhr.h
+++ b/sound/pci/pcxhr/pcxhr.h
@@ -103,6 +103,7 @@ struct pcxhr_mgr {
 	unsigned int board_has_mic:1; /* if 1 the board has microphone input */
 	unsigned int board_aes_in_192k:1;/* if 1 the aes input plugs do support 192kHz */
 	unsigned int mono_capture:1; /* if 1 the board does mono capture */
+	unsigned int capture_ltc:1; /* if 1 the board captures LTC input */
 
 	struct snd_dma_buffer hostport;
 

commit 7df4f694356a125e4553ca35b215fd9e88e858c5
Merge: b54fc8dd2c43 d563ffa6b319
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:36:19 2009 +0100

    Merge branch 'topic/pcxhr' into for-linus

commit e32740d9786b8a6c54f6e3d670567d9ef57b3b8c
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Feb 19 11:58:37 2009 -0800

    ALSA: pcxhr.h replace signed one-bit bitfields
    
    The usage and comments make it clear values of 1/0 were intended
    rather than -1/0
    
    Noticed by sparse:
    sound/pci/pcxhr/pcxhr.h:100:20: error: dubious one-bit signed bitfield
    sound/pci/pcxhr/pcxhr.h:101:22: error: dubious one-bit signed bitfield
    sound/pci/pcxhr/pcxhr.h:102:24: error: dubious one-bit signed bitfield
    sound/pci/pcxhr/pcxhr.h:103:21: error: dubious one-bit signed bitfield
    sound/pci/pcxhr/pcxhr.h:104:25: error: dubious one-bit signed bitfield
    sound/pci/pcxhr/pcxhr.h:105:20: error: dubious one-bit signed bitfield
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.h b/sound/pci/pcxhr/pcxhr.h
index 84131a916c92..69d87dee6995 100644
--- a/sound/pci/pcxhr/pcxhr.h
+++ b/sound/pci/pcxhr/pcxhr.h
@@ -97,12 +97,12 @@ struct pcxhr_mgr {
 	int capture_chips;
 	int fw_file_set;
 	int firmware_num;
-	int is_hr_stereo:1;
-	int board_has_aes1:1;	/* if 1 board has AES1 plug and SRC */
-	int board_has_analog:1;	/* if 0 the board is digital only */
-	int board_has_mic:1;	/* if 1 the board has microphone input */
-	int board_aes_in_192k:1;/* if 1 the aes input plugs do support 192kHz */
-	int mono_capture:1;	/* if 1 the board does mono capture */
+	unsigned int is_hr_stereo:1;
+	unsigned int board_has_aes1:1;	/* if 1 board has AES1 plug and SRC */
+	unsigned int board_has_analog:1; /* if 0 the board is digital only */
+	unsigned int board_has_mic:1; /* if 1 the board has microphone input */
+	unsigned int board_aes_in_192k:1;/* if 1 the aes input plugs do support 192kHz */
+	unsigned int mono_capture:1; /* if 1 the board does mono capture */
 
 	struct snd_dma_buffer hostport;
 

commit 55aef4508598d59c2baea7e2a3e6dfed415bbfc0
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Fri Jan 23 14:45:41 2009 +0100

    ALSA: pcxhr - add support for gpio ports and minor bug fix
    
    - add support for gpio ports (2 GPI, 2 GPO) of pcxhr stereo cards
    - minor bugfixes : allow setting clock to internal by the mixer
                       even if there is no stream (but monitoring)
    
    Signed-off-by: Markus Bollinger <bollinger@digigram.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.h b/sound/pci/pcxhr/pcxhr.h
index 84131a916c92..ac9c3b3bb4e8 100644
--- a/sound/pci/pcxhr/pcxhr.h
+++ b/sound/pci/pcxhr/pcxhr.h
@@ -27,8 +27,8 @@
 #include <linux/mutex.h>
 #include <sound/pcm.h>
 
-#define PCXHR_DRIVER_VERSION		0x000905	/* 0.9.5 */
-#define PCXHR_DRIVER_VERSION_STRING	"0.9.5"		/* 0.9.5 */
+#define PCXHR_DRIVER_VERSION		0x000906	/* 0.9.6 */
+#define PCXHR_DRIVER_VERSION_STRING	"0.9.6"		/* 0.9.6 */
 
 
 #define PCXHR_MAX_CARDS		6
@@ -124,6 +124,7 @@ struct pcxhr_mgr {
 
 	unsigned char xlx_cfg;		/* copy of PCXHR_XLX_CFG register */
 	unsigned char xlx_selmic;	/* copy of PCXHR_XLX_SELMIC register */
+	unsigned char dsp_reset;	/* copy of PCXHR_DSP_RESET register */
 };
 
 

commit 9d948d270010e3552c94281bab75694580ca23e9
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Tue Nov 25 12:24:54 2008 +0100

    ALSA: pcxhr - add support for pcxhr stereo sound cards (core change)
    
    - Add support for pcxhr stereo cards
    - minor bugfixes : period and buffer size consraints
    - fix PLL register values
    - do some clean up
    
    Signed-off-by: Markus Bollinger <bollinger@digigram.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.h b/sound/pci/pcxhr/pcxhr.h
index 652064787a55..84131a916c92 100644
--- a/sound/pci/pcxhr/pcxhr.h
+++ b/sound/pci/pcxhr/pcxhr.h
@@ -27,15 +27,18 @@
 #include <linux/mutex.h>
 #include <sound/pcm.h>
 
-#define PCXHR_DRIVER_VERSION		0x000804	/* 0.8.4 */
-#define PCXHR_DRIVER_VERSION_STRING	"0.8.4"		/* 0.8.4 */
+#define PCXHR_DRIVER_VERSION		0x000905	/* 0.9.5 */
+#define PCXHR_DRIVER_VERSION_STRING	"0.9.5"		/* 0.9.5 */
 
 
-#define PCXHR_MAX_CARDS			6
-#define PCXHR_PLAYBACK_STREAMS		4
+#define PCXHR_MAX_CARDS		6
+#define PCXHR_PLAYBACK_STREAMS	4
 
-#define PCXHR_GRANULARITY		96	/* transfer granularity (should be min 96 and multiple of 48) */
-#define PCXHR_GRANULARITY_MIN		96	/* transfer granularity of pipes and the dsp time (MBOX4) */
+#define PCXHR_GRANULARITY	96	/* min 96 and multiple of 48 */
+/* transfer granularity of pipes and the dsp time (MBOX4) */
+#define PCXHR_GRANULARITY_MIN	96
+/* TODO : granularity could be 64 or 128 */
+#define PCXHR_GRANULARITY_HR22	192	/* granularity for stereo cards */
 
 struct snd_pcxhr;
 struct pcxhr_mgr;
@@ -51,6 +54,11 @@ enum pcxhr_clock_type {
 	PCXHR_CLOCK_TYPE_AES_2,
 	PCXHR_CLOCK_TYPE_AES_3,
 	PCXHR_CLOCK_TYPE_AES_4,
+	PCXHR_CLOCK_TYPE_MAX = PCXHR_CLOCK_TYPE_AES_4,
+	HR22_CLOCK_TYPE_INTERNAL = PCXHR_CLOCK_TYPE_INTERNAL,
+	HR22_CLOCK_TYPE_AES_SYNC,
+	HR22_CLOCK_TYPE_AES_1,
+	HR22_CLOCK_TYPE_MAX = HR22_CLOCK_TYPE_AES_1,
 };
 
 struct pcxhr_mgr {
@@ -61,6 +69,8 @@ struct pcxhr_mgr {
 
 	int irq;
 
+	int granularity;
+
 	/* card access with 1 mem bar and 2 io bar's */
 	unsigned long port[3];
 
@@ -83,11 +93,16 @@ struct pcxhr_mgr {
 	/* hardware interface */
 	unsigned int dsp_loaded;	/* bit flags of loaded dsp indices */
 	unsigned int dsp_version;	/* read from embedded once firmware is loaded */
-	int board_has_analog;		/* if 0 the board is digital only */
-	int mono_capture;		/* if 1 the board does mono capture */
-	int playback_chips;		/* 4 or 6 */
-	int capture_chips;		/* 4 or 1 */
-	int firmware_num;		/* 41 or 42 */
+	int playback_chips;
+	int capture_chips;
+	int fw_file_set;
+	int firmware_num;
+	int is_hr_stereo:1;
+	int board_has_aes1:1;	/* if 1 board has AES1 plug and SRC */
+	int board_has_analog:1;	/* if 0 the board is digital only */
+	int board_has_mic:1;	/* if 1 the board has microphone input */
+	int board_aes_in_192k:1;/* if 1 the aes input plugs do support 192kHz */
+	int mono_capture:1;	/* if 1 the board does mono capture */
 
 	struct snd_dma_buffer hostport;
 
@@ -106,6 +121,9 @@ struct pcxhr_mgr {
 	int async_err_stream_xrun;
 	int async_err_pipe_xrun;
 	int async_err_other_last;
+
+	unsigned char xlx_cfg;		/* copy of PCXHR_XLX_CFG register */
+	unsigned char xlx_selmic;	/* copy of PCXHR_XLX_SELMIC register */
 };
 
 
@@ -155,24 +173,30 @@ struct snd_pcxhr {
 
 	struct snd_pcm *pcm;		/* PCM */
 
-	struct pcxhr_pipe playback_pipe;		/* 1 stereo pipe only */
-	struct pcxhr_pipe capture_pipe[2];		/* 1 stereo pipe or 2 mono pipes */
+	struct pcxhr_pipe playback_pipe;	/* 1 stereo pipe only */
+	struct pcxhr_pipe capture_pipe[2];	/* 1 stereo or 2 mono pipes */
 
 	struct pcxhr_stream playback_stream[PCXHR_PLAYBACK_STREAMS];
-	struct pcxhr_stream capture_stream[2];	/* 1 stereo stream or 2 mono streams */
+	struct pcxhr_stream capture_stream[2];	/* 1 stereo or 2 mono streams */
 	int nb_streams_play;
 	int nb_streams_capt;
 
-	int analog_playback_active[2];		/* Mixer : Master Playback active (!mute) */
-	int analog_playback_volume[2];		/* Mixer : Master Playback Volume */
-	int analog_capture_volume[2];		/* Mixer : Master Capture Volume */
-	int digital_playback_active[PCXHR_PLAYBACK_STREAMS][2];	/* Mixer : Digital Playback Active [streams][stereo]*/
-	int digital_playback_volume[PCXHR_PLAYBACK_STREAMS][2];	/* Mixer : Digital Playback Volume [streams][stereo]*/
-	int digital_capture_volume[2];		/* Mixer : Digital Capture Volume [stereo] */
-	int monitoring_active[2];		/* Mixer : Monitoring Active */
-	int monitoring_volume[2];		/* Mixer : Monitoring Volume */
-	int audio_capture_source;		/* Mixer : Audio Capture Source */
-	unsigned char aes_bits[5];		/* Mixer : IEC958_AES bits */
+	int analog_playback_active[2];	/* Mixer : Master Playback !mute */
+	int analog_playback_volume[2];	/* Mixer : Master Playback Volume */
+	int analog_capture_volume[2];	/* Mixer : Master Capture Volume */
+	int digital_playback_active[PCXHR_PLAYBACK_STREAMS][2];
+	int digital_playback_volume[PCXHR_PLAYBACK_STREAMS][2];
+	int digital_capture_volume[2];	/* Mixer : Digital Capture Volume */
+	int monitoring_active[2];	/* Mixer : Monitoring Active */
+	int monitoring_volume[2];	/* Mixer : Monitoring Volume */
+	int audio_capture_source;	/* Mixer : Audio Capture Source */
+	int mic_volume;			/* used by cards with MIC only */
+	int mic_boost;			/* used by cards with MIC only */
+	int mic_active;			/* used by cards with MIC only */
+	int analog_capture_active;	/* used by cards with MIC only */
+	int phantom_power;		/* used by cards with MIC only */
+
+	unsigned char aes_bits[5];	/* Mixer : IEC958_AES bits */
 };
 
 struct pcxhr_hostport
@@ -184,6 +208,8 @@ struct pcxhr_hostport
 /* exported */
 int pcxhr_create_pcm(struct snd_pcxhr *chip);
 int pcxhr_set_clock(struct pcxhr_mgr *mgr, unsigned int rate);
-int pcxhr_get_external_clock(struct pcxhr_mgr *mgr, enum pcxhr_clock_type clock_type, int *sample_rate);
+int pcxhr_get_external_clock(struct pcxhr_mgr *mgr,
+			     enum pcxhr_clock_type clock_type,
+			     int *sample_rate);
 
 #endif /* __SOUND_PCXHR_H */

commit 62932df8fb20ba2fb53a95fa52445eba22e821fe
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:34:20 2006 +0100

    [ALSA] semaphore -> mutex (PCI part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.h b/sound/pci/pcxhr/pcxhr.h
index 049f2b3f2867..652064787a55 100644
--- a/sound/pci/pcxhr/pcxhr.h
+++ b/sound/pci/pcxhr/pcxhr.h
@@ -24,6 +24,7 @@
 #define __SOUND_PCXHR_H
 
 #include <linux/interrupt.h>
+#include <linux/mutex.h>
 #include <sound/pcm.h>
 
 #define PCXHR_DRIVER_VERSION		0x000804	/* 0.8.4 */
@@ -76,8 +77,8 @@ struct pcxhr_mgr {
 	spinlock_t lock;		/* interrupt spinlock */
 	spinlock_t msg_lock;		/* message spinlock */
 
-	struct semaphore setup_mutex;	/* mutex used in hw_params, open and close */
-	struct semaphore mixer_mutex;	/* mutex for mixer */
+	struct mutex setup_mutex;	/* mutex used in hw_params, open and close */
+	struct mutex mixer_mutex;	/* mutex for mixer */
 
 	/* hardware interface */
 	unsigned int dsp_loaded;	/* bit flags of loaded dsp indices */

commit e12229b4d2b7863b1baaeca759aa87703bf9fdf8
Author: Markus Bollinger <bollinger@digigram.com>
Date:   Tue Dec 6 13:55:26 2005 +0100

    [ALSA] Add PCXHR driver
    
    Modules: Documentation,PCI drivers,Digigram PCXHR driver
    
    Add Digigram PCXHR driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/pcxhr/pcxhr.h b/sound/pci/pcxhr/pcxhr.h
new file mode 100644
index 000000000000..049f2b3f2867
--- /dev/null
+++ b/sound/pci/pcxhr/pcxhr.h
@@ -0,0 +1,188 @@
+/*
+ * Driver for Digigram pcxhr soundcards
+ *
+ * main header file
+ *
+ * Copyright (c) 2004 by Digigram <alsa@digigram.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef __SOUND_PCXHR_H
+#define __SOUND_PCXHR_H
+
+#include <linux/interrupt.h>
+#include <sound/pcm.h>
+
+#define PCXHR_DRIVER_VERSION		0x000804	/* 0.8.4 */
+#define PCXHR_DRIVER_VERSION_STRING	"0.8.4"		/* 0.8.4 */
+
+
+#define PCXHR_MAX_CARDS			6
+#define PCXHR_PLAYBACK_STREAMS		4
+
+#define PCXHR_GRANULARITY		96	/* transfer granularity (should be min 96 and multiple of 48) */
+#define PCXHR_GRANULARITY_MIN		96	/* transfer granularity of pipes and the dsp time (MBOX4) */
+
+struct snd_pcxhr;
+struct pcxhr_mgr;
+
+struct pcxhr_stream;
+struct pcxhr_pipe;
+
+enum pcxhr_clock_type {
+	PCXHR_CLOCK_TYPE_INTERNAL = 0,
+	PCXHR_CLOCK_TYPE_WORD_CLOCK,
+	PCXHR_CLOCK_TYPE_AES_SYNC,
+	PCXHR_CLOCK_TYPE_AES_1,
+	PCXHR_CLOCK_TYPE_AES_2,
+	PCXHR_CLOCK_TYPE_AES_3,
+	PCXHR_CLOCK_TYPE_AES_4,
+};
+
+struct pcxhr_mgr {
+	unsigned int num_cards;
+	struct snd_pcxhr *chip[PCXHR_MAX_CARDS];
+
+	struct pci_dev *pci;
+
+	int irq;
+
+	/* card access with 1 mem bar and 2 io bar's */
+	unsigned long port[3];
+
+	/* share the name */
+	char shortname[32];		/* short name of this soundcard */
+	char longname[96];		/* name of this soundcard */
+
+	/* message tasklet */
+	struct tasklet_struct msg_taskq;
+	struct pcxhr_rmh *prmh;
+	/* trigger tasklet */
+	struct tasklet_struct trigger_taskq;
+
+	spinlock_t lock;		/* interrupt spinlock */
+	spinlock_t msg_lock;		/* message spinlock */
+
+	struct semaphore setup_mutex;	/* mutex used in hw_params, open and close */
+	struct semaphore mixer_mutex;	/* mutex for mixer */
+
+	/* hardware interface */
+	unsigned int dsp_loaded;	/* bit flags of loaded dsp indices */
+	unsigned int dsp_version;	/* read from embedded once firmware is loaded */
+	int board_has_analog;		/* if 0 the board is digital only */
+	int mono_capture;		/* if 1 the board does mono capture */
+	int playback_chips;		/* 4 or 6 */
+	int capture_chips;		/* 4 or 1 */
+	int firmware_num;		/* 41 or 42 */
+
+	struct snd_dma_buffer hostport;
+
+	enum pcxhr_clock_type use_clock_type;	/* clock type selected by mixer */
+	enum pcxhr_clock_type cur_clock_type;	/* current clock type synced */
+	int sample_rate;
+	int ref_count_rate;
+	int timer_toggle;		/* timer interrupt toggles between the two values 0x200 and 0x300 */
+	int dsp_time_last;		/* the last dsp time (read by interrupt) */
+	int dsp_time_err;		/* dsp time errors */
+	unsigned int src_it_dsp;	/* dsp interrupt source */
+	unsigned int io_num_reg_cont;	/* backup of IO_NUM_REG_CONT */
+	unsigned int codec_speed;	/* speed mode of the codecs */
+	unsigned int sample_rate_real;	/* current real sample rate */
+	int last_reg_stat;
+	int async_err_stream_xrun;
+	int async_err_pipe_xrun;
+	int async_err_other_last;
+};
+
+
+enum pcxhr_stream_status {
+	PCXHR_STREAM_STATUS_FREE,
+	PCXHR_STREAM_STATUS_OPEN,
+	PCXHR_STREAM_STATUS_SCHEDULE_RUN,
+	PCXHR_STREAM_STATUS_STARTED,
+	PCXHR_STREAM_STATUS_RUNNING,
+	PCXHR_STREAM_STATUS_SCHEDULE_STOP,
+	PCXHR_STREAM_STATUS_STOPPED,
+	PCXHR_STREAM_STATUS_PAUSED
+};
+
+struct pcxhr_stream {
+	struct snd_pcm_substream *substream;
+	snd_pcm_format_t format;
+	struct pcxhr_pipe *pipe;
+
+	enum pcxhr_stream_status status;	/* free, open, running, draining, pause */
+
+	u_int64_t timer_abs_periods;	/* timer: samples elapsed since TRIGGER_START (multiple of period_size) */
+	u_int32_t timer_period_frag;	/* timer: samples elapsed since last call to snd_pcm_period_elapsed (0..period_size) */
+	u_int32_t timer_buf_periods;	/* nb of periods in the buffer that have already elapsed */
+	int timer_is_synced;		/* if(0) : timer needs to be resynced with real hardware pointer */
+
+	int channels;
+};
+
+
+enum pcxhr_pipe_status {
+	PCXHR_PIPE_UNDEFINED,
+	PCXHR_PIPE_DEFINED
+};
+
+struct pcxhr_pipe {
+	enum pcxhr_pipe_status status;
+	int is_capture;		/* this is a capture pipe */
+	int first_audio;	/* first audio num */
+};
+
+
+struct snd_pcxhr {
+	struct snd_card *card;
+	struct pcxhr_mgr *mgr;
+	int chip_idx;		/* zero based */
+
+	struct snd_pcm *pcm;		/* PCM */
+
+	struct pcxhr_pipe playback_pipe;		/* 1 stereo pipe only */
+	struct pcxhr_pipe capture_pipe[2];		/* 1 stereo pipe or 2 mono pipes */
+
+	struct pcxhr_stream playback_stream[PCXHR_PLAYBACK_STREAMS];
+	struct pcxhr_stream capture_stream[2];	/* 1 stereo stream or 2 mono streams */
+	int nb_streams_play;
+	int nb_streams_capt;
+
+	int analog_playback_active[2];		/* Mixer : Master Playback active (!mute) */
+	int analog_playback_volume[2];		/* Mixer : Master Playback Volume */
+	int analog_capture_volume[2];		/* Mixer : Master Capture Volume */
+	int digital_playback_active[PCXHR_PLAYBACK_STREAMS][2];	/* Mixer : Digital Playback Active [streams][stereo]*/
+	int digital_playback_volume[PCXHR_PLAYBACK_STREAMS][2];	/* Mixer : Digital Playback Volume [streams][stereo]*/
+	int digital_capture_volume[2];		/* Mixer : Digital Capture Volume [stereo] */
+	int monitoring_active[2];		/* Mixer : Monitoring Active */
+	int monitoring_volume[2];		/* Mixer : Monitoring Volume */
+	int audio_capture_source;		/* Mixer : Audio Capture Source */
+	unsigned char aes_bits[5];		/* Mixer : IEC958_AES bits */
+};
+
+struct pcxhr_hostport
+{
+	char purgebuffer[6];
+	char reserved[2];
+};
+
+/* exported */
+int pcxhr_create_pcm(struct snd_pcxhr *chip);
+int pcxhr_set_clock(struct pcxhr_mgr *mgr, unsigned int rate);
+int pcxhr_get_external_clock(struct pcxhr_mgr *mgr, enum pcxhr_clock_type clock_type, int *sample_rate);
+
+#endif /* __SOUND_PCXHR_H */
