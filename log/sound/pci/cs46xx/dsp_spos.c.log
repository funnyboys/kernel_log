commit ba09f5d84e3e39ffb6768e5473073cfb96ba32e3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:44 2020 +0100

    ALSA: cs46xx: More constifications
    
    Apply const prefix to each possible place: the static tables for
    registers and op codes, etc.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-30-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 887790ac33c6..05f3f6dc918d 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -27,7 +27,7 @@
 static int cs46xx_dsp_async_init (struct snd_cs46xx *chip,
 				  struct dsp_scb_descriptor * fg_entry);
 
-static enum wide_opcode wide_opcodes[] = { 
+static const enum wide_opcode wide_opcodes[] = {
 	WIDE_FOR_BEGIN_LOOP,
 	WIDE_FOR_BEGIN_LOOP2,
 	WIDE_COND_GOTO_ADDR,
@@ -1038,7 +1038,7 @@ int cs46xx_dsp_scb_and_task_init (struct snd_cs46xx *chip)
 	
 	int fifo_addr, fifo_span, valid_slots;
 
-	static struct dsp_spos_control_block sposcb = {
+	static const struct dsp_spos_control_block sposcb = {
 		/* 0 */ HFG_TREE_SCB,HFG_STACK,
 		/* 1 */ SPOSCB_ADDR,BG_TREE_SCB_ADDR,
 		/* 2 */ DSP_SPOS_DC,0,

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index c28e58602679..887790ac33c6 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -1,18 +1,5 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 /*

commit 0b2338a9bf36b5ac6ed43425e2f1357fb3d3841b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 5 16:46:27 2019 +0100

    ALSA: cs46xx: Clean up proc file creations
    
    Again no functional changes, but only code clean up.
    Use a standard macro for initializing the procfs entries, also drop
    the info entries stored in dsp_spos_instance, as they are removed
    recursively by a single snd_info_free_entry() calls.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 3555f839371e..c28e58602679 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -809,52 +809,39 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 
 	entry = snd_info_create_card_entry(card, "spos_symbols",
 					   ins->proc_dsp_dir);
-	if (entry) {
-		entry->private_data = chip;
-		entry->mode = S_IFREG | 0644;
-		entry->c.text.read = cs46xx_dsp_proc_symbol_table_read;
-	}
-	ins->proc_sym_info_entry = entry;
+	if (entry)
+		snd_info_set_text_ops(entry, chip,
+				      cs46xx_dsp_proc_symbol_table_read);
     
-	if ((entry = snd_info_create_card_entry(card, "spos_modules", ins->proc_dsp_dir)) != NULL) {
-		entry->content = SNDRV_INFO_CONTENT_TEXT;
-		entry->private_data = chip;
-		entry->mode = S_IFREG | 0644;
-		entry->c.text.read = cs46xx_dsp_proc_modules_read;
-	}
-	ins->proc_modules_info_entry = entry;
+	entry = snd_info_create_card_entry(card, "spos_modules",
+					   ins->proc_dsp_dir);
+	if (entry)
+		snd_info_set_text_ops(entry, chip,
+				      cs46xx_dsp_proc_modules_read);
 
-	if ((entry = snd_info_create_card_entry(card, "parameter", ins->proc_dsp_dir)) != NULL) {
-		entry->content = SNDRV_INFO_CONTENT_TEXT;
-		entry->private_data = chip;
-		entry->mode = S_IFREG | 0644;
-		entry->c.text.read = cs46xx_dsp_proc_parameter_dump_read;
-	}
-	ins->proc_parameter_dump_info_entry = entry;
+	entry = snd_info_create_card_entry(card, "parameter",
+					   ins->proc_dsp_dir);
+	if (entry)
+		snd_info_set_text_ops(entry, chip,
+				      cs46xx_dsp_proc_parameter_dump_read);
 
-	if ((entry = snd_info_create_card_entry(card, "sample", ins->proc_dsp_dir)) != NULL) {
-		entry->content = SNDRV_INFO_CONTENT_TEXT;
-		entry->private_data = chip;
-		entry->mode = S_IFREG | 0644;
-		entry->c.text.read = cs46xx_dsp_proc_sample_dump_read;
-	}
-	ins->proc_sample_dump_info_entry = entry;
+	entry = snd_info_create_card_entry(card, "sample",
+					   ins->proc_dsp_dir);
+	if (entry)
+		snd_info_set_text_ops(entry, chip,
+				      cs46xx_dsp_proc_sample_dump_read);
 
-	if ((entry = snd_info_create_card_entry(card, "task_tree", ins->proc_dsp_dir)) != NULL) {
-		entry->content = SNDRV_INFO_CONTENT_TEXT;
-		entry->private_data = chip;
-		entry->mode = S_IFREG | 0644;
-		entry->c.text.read = cs46xx_dsp_proc_task_tree_read;
-	}
-	ins->proc_task_info_entry = entry;
+	entry = snd_info_create_card_entry(card, "task_tree",
+					   ins->proc_dsp_dir);
+	if (entry)
+		snd_info_set_text_ops(entry, chip,
+				      cs46xx_dsp_proc_task_tree_read);
 
-	if ((entry = snd_info_create_card_entry(card, "scb_info", ins->proc_dsp_dir)) != NULL) {
-		entry->content = SNDRV_INFO_CONTENT_TEXT;
-		entry->private_data = chip;
-		entry->mode = S_IFREG | 0644;
-		entry->c.text.read = cs46xx_dsp_proc_scb_read;
-	}
-	ins->proc_scb_info_entry = entry;
+	entry = snd_info_create_card_entry(card, "scb_info",
+					   ins->proc_dsp_dir);
+	if (entry)
+		snd_info_set_text_ops(entry, chip,
+				      cs46xx_dsp_proc_scb_read);
 
 	mutex_lock(&chip->spos_mutex);
 	/* register/update SCB's entries on proc */
@@ -876,24 +863,6 @@ int cs46xx_dsp_proc_done (struct snd_cs46xx *chip)
 	if (!ins)
 		return 0;
 
-	snd_info_free_entry(ins->proc_sym_info_entry);
-	ins->proc_sym_info_entry = NULL;
-
-	snd_info_free_entry(ins->proc_modules_info_entry);
-	ins->proc_modules_info_entry = NULL;
-
-	snd_info_free_entry(ins->proc_parameter_dump_info_entry);
-	ins->proc_parameter_dump_info_entry = NULL;
-
-	snd_info_free_entry(ins->proc_sample_dump_info_entry);
-	ins->proc_sample_dump_info_entry = NULL;
-
-	snd_info_free_entry(ins->proc_scb_info_entry);
-	ins->proc_scb_info_entry = NULL;
-
-	snd_info_free_entry(ins->proc_task_info_entry);
-	ins->proc_task_info_entry = NULL;
-
 	mutex_lock(&chip->spos_mutex);
 	for (i = 0; i < ins->nscb; ++i) {
 		if (ins->scbs[i].deleted) continue;

commit eaffef0d5fca38939ac986de4625f4f070c49346
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:05:21 2019 +0100

    ALSA: pci: Remove superfluous snd_info_register() calls
    
    The calls of snd_info_register() are superfluous and should be avoided
    at the procfs creation time.  They are called at the end of the whole
    initialization via snd_card_register().  This patch drops such
    superfluous calls, as well as dropping the superfluous setup of
    SNDRV_INFO_CONTENT_TEXT.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 5fc497c6d738..3555f839371e 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -799,30 +799,20 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 
 	ins->snd_card = card;
 
-	if ((entry = snd_info_create_card_entry(card, "dsp", card->proc_root)) != NULL) {
-		entry->content = SNDRV_INFO_CONTENT_TEXT;
+	entry = snd_info_create_card_entry(card, "dsp", card->proc_root);
+	if (entry)
 		entry->mode = S_IFDIR | 0555;
-      
-		if (snd_info_register(entry) < 0) {
-			snd_info_free_entry(entry);
-			entry = NULL;
-		}
-	}
-
 	ins->proc_dsp_dir = entry;
 
 	if (!ins->proc_dsp_dir)
 		return -ENOMEM;
 
-	if ((entry = snd_info_create_card_entry(card, "spos_symbols", ins->proc_dsp_dir)) != NULL) {
-		entry->content = SNDRV_INFO_CONTENT_TEXT;
+	entry = snd_info_create_card_entry(card, "spos_symbols",
+					   ins->proc_dsp_dir);
+	if (entry) {
 		entry->private_data = chip;
 		entry->mode = S_IFREG | 0644;
 		entry->c.text.read = cs46xx_dsp_proc_symbol_table_read;
-		if (snd_info_register(entry) < 0) {
-			snd_info_free_entry(entry);
-			entry = NULL;
-		}
 	}
 	ins->proc_sym_info_entry = entry;
     
@@ -831,10 +821,6 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 		entry->private_data = chip;
 		entry->mode = S_IFREG | 0644;
 		entry->c.text.read = cs46xx_dsp_proc_modules_read;
-		if (snd_info_register(entry) < 0) {
-			snd_info_free_entry(entry);
-			entry = NULL;
-		}
 	}
 	ins->proc_modules_info_entry = entry;
 
@@ -843,10 +829,6 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 		entry->private_data = chip;
 		entry->mode = S_IFREG | 0644;
 		entry->c.text.read = cs46xx_dsp_proc_parameter_dump_read;
-		if (snd_info_register(entry) < 0) {
-			snd_info_free_entry(entry);
-			entry = NULL;
-		}
 	}
 	ins->proc_parameter_dump_info_entry = entry;
 
@@ -855,10 +837,6 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 		entry->private_data = chip;
 		entry->mode = S_IFREG | 0644;
 		entry->c.text.read = cs46xx_dsp_proc_sample_dump_read;
-		if (snd_info_register(entry) < 0) {
-			snd_info_free_entry(entry);
-			entry = NULL;
-		}
 	}
 	ins->proc_sample_dump_info_entry = entry;
 
@@ -867,10 +845,6 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 		entry->private_data = chip;
 		entry->mode = S_IFREG | 0644;
 		entry->c.text.read = cs46xx_dsp_proc_task_tree_read;
-		if (snd_info_register(entry) < 0) {
-			snd_info_free_entry(entry);
-			entry = NULL;
-		}
 	}
 	ins->proc_task_info_entry = entry;
 
@@ -879,10 +853,6 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 		entry->private_data = chip;
 		entry->mode = S_IFREG | 0644;
 		entry->c.text.read = cs46xx_dsp_proc_scb_read;
-		if (snd_info_register(entry) < 0) {
-			snd_info_free_entry(entry);
-			entry = NULL;
-		}
 	}
 	ins->proc_scb_info_entry = entry;
 

commit 1524f4e47f90b27a3ac84efbdd94c63172246a6f
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jan 8 10:43:30 2019 +0300

    ALSA: cs46xx: Potential NULL dereference in probe
    
    The "chip->dsp_spos_instance" can be NULL on some of the ealier error
    paths in snd_cs46xx_create().
    
    Reported-by: "Yavuz, Tuba" <tuba@ece.ufl.edu>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 598d140bb7cb..5fc497c6d738 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -903,6 +903,9 @@ int cs46xx_dsp_proc_done (struct snd_cs46xx *chip)
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 	int i;
 
+	if (!ins)
+		return 0;
+
 	snd_info_free_entry(ins->proc_sym_info_entry);
 	ins->proc_sym_info_entry = NULL;
 

commit 42bc47b35320e0e587a88e437e18f80f9c5bcbb2
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:27:11 2018 -0700

    treewide: Use array_size() in vmalloc()
    
    The vmalloc() function has no 2-factor argument form, so multiplication
    factors need to be wrapped in array_size(). This patch replaces cases of:
    
            vmalloc(a * b)
    
    with:
            vmalloc(array_size(a, b))
    
    as well as handling cases of:
    
            vmalloc(a * b * c)
    
    with:
    
            vmalloc(array3_size(a, b, c))
    
    This does, however, attempt to ignore constant size factors like:
    
            vmalloc(4 * 1024)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      vmalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      vmalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      vmalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
      vmalloc(
    -       sizeof(TYPE) * (COUNT_ID)
    +       array_size(COUNT_ID, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT_ID
    +       array_size(COUNT_ID, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * (COUNT_CONST)
    +       array_size(COUNT_CONST, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT_CONST
    +       array_size(COUNT_CONST, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT_ID)
    +       array_size(COUNT_ID, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT_ID
    +       array_size(COUNT_ID, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT_CONST)
    +       array_size(COUNT_CONST, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT_CONST
    +       array_size(COUNT_CONST, sizeof(THING))
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
      vmalloc(
    -       SIZE * COUNT
    +       array_size(COUNT, SIZE)
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      vmalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      vmalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      vmalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      vmalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      vmalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      vmalloc(C1 * C2 * C3, ...)
    |
      vmalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants.
    @@
    expression E1, E2;
    constant C1, C2;
    @@
    
    (
      vmalloc(C1 * C2, ...)
    |
      vmalloc(
    -       E1 * E2
    +       array_size(E1, E2)
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 99d5a02f9169..598d140bb7cb 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -240,8 +240,9 @@ struct dsp_spos_instance *cs46xx_dsp_spos_create (struct snd_cs46xx * chip)
 		return NULL;
 
 	/* better to use vmalloc for this big table */
-	ins->symbol_table.symbols = vmalloc(sizeof(struct dsp_symbol_entry) *
-					    DSP_MAX_SYMBOLS);
+	ins->symbol_table.symbols =
+		vmalloc(array_size(DSP_MAX_SYMBOLS,
+				   sizeof(struct dsp_symbol_entry)));
 	ins->code.data = kmalloc(DSP_CODE_BYTE_SIZE, GFP_KERNEL);
 	ins->modules = kmalloc_array(DSP_MAX_MODULES,
 				     sizeof(struct dsp_module_desc),

commit 6da2ec56059c3c7a7e5f729e6349e74ace1e5c57
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 13:55:00 2018 -0700

    treewide: kmalloc() -> kmalloc_array()
    
    The kmalloc() function has a 2-factor argument form, kmalloc_array(). This
    patch replaces cases of:
    
            kmalloc(a * b, gfp)
    
    with:
            kmalloc_array(a * b, gfp)
    
    as well as handling cases of:
    
            kmalloc(a * b * c, gfp)
    
    with:
    
            kmalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kmalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kmalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The tools/ directory was manually excluded, since it has its own
    implementation of kmalloc().
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kmalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kmalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kmalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kmalloc
    + kmalloc_array
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kmalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kmalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kmalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kmalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kmalloc(C1 * C2 * C3, ...)
    |
      kmalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kmalloc(sizeof(THING) * C2, ...)
    |
      kmalloc(sizeof(TYPE) * C2, ...)
    |
      kmalloc(C1 * C2 * C3, ...)
    |
      kmalloc(C1 * C2, ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index c44eadef64ae..99d5a02f9169 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -243,7 +243,9 @@ struct dsp_spos_instance *cs46xx_dsp_spos_create (struct snd_cs46xx * chip)
 	ins->symbol_table.symbols = vmalloc(sizeof(struct dsp_symbol_entry) *
 					    DSP_MAX_SYMBOLS);
 	ins->code.data = kmalloc(DSP_CODE_BYTE_SIZE, GFP_KERNEL);
-	ins->modules = kmalloc(sizeof(struct dsp_module_desc) * DSP_MAX_MODULES, GFP_KERNEL);
+	ins->modules = kmalloc_array(DSP_MAX_MODULES,
+				     sizeof(struct dsp_module_desc),
+				     GFP_KERNEL);
 	if (!ins->symbol_table.symbols || !ins->code.data || !ins->modules) {
 		cs46xx_dsp_spos_destroy(chip);
 		goto error;

commit 6a73cf46ce9d1b382ea14d74ce4bc9aa0c52337a
Author: Joe Perches <joe@perches.com>
Date:   Wed May 23 12:20:59 2018 -0700

    sound: Use octal not symbolic permissions
    
    Convert the S_<FOO> symbolic permissions to their octal equivalents as
    using octal and not symbolic permissions is preferred by many as more
    readable.
    
    see: https://lkml.org/lkml/2016/8/2/1945
    
    Done with automated conversion via:
    $ ./scripts/checkpatch.pl -f --types=SYMBOLIC_PERMS --fix-inplace <files...>
    
    Miscellanea:
    
    o Wrapped one multi-line call to a single line
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index aa61615288ff..c44eadef64ae 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -798,7 +798,7 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 
 	if ((entry = snd_info_create_card_entry(card, "dsp", card->proc_root)) != NULL) {
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
-		entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+		entry->mode = S_IFDIR | 0555;
       
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
@@ -814,7 +814,7 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 	if ((entry = snd_info_create_card_entry(card, "spos_symbols", ins->proc_dsp_dir)) != NULL) {
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = chip;
-		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+		entry->mode = S_IFREG | 0644;
 		entry->c.text.read = cs46xx_dsp_proc_symbol_table_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
@@ -826,7 +826,7 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 	if ((entry = snd_info_create_card_entry(card, "spos_modules", ins->proc_dsp_dir)) != NULL) {
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = chip;
-		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+		entry->mode = S_IFREG | 0644;
 		entry->c.text.read = cs46xx_dsp_proc_modules_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
@@ -838,7 +838,7 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 	if ((entry = snd_info_create_card_entry(card, "parameter", ins->proc_dsp_dir)) != NULL) {
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = chip;
-		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+		entry->mode = S_IFREG | 0644;
 		entry->c.text.read = cs46xx_dsp_proc_parameter_dump_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
@@ -850,7 +850,7 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 	if ((entry = snd_info_create_card_entry(card, "sample", ins->proc_dsp_dir)) != NULL) {
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = chip;
-		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+		entry->mode = S_IFREG | 0644;
 		entry->c.text.read = cs46xx_dsp_proc_sample_dump_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
@@ -862,7 +862,7 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 	if ((entry = snd_info_create_card_entry(card, "task_tree", ins->proc_dsp_dir)) != NULL) {
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = chip;
-		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+		entry->mode = S_IFREG | 0644;
 		entry->c.text.read = cs46xx_dsp_proc_task_tree_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
@@ -874,7 +874,7 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 	if ((entry = snd_info_create_card_entry(card, "scb_info", ins->proc_dsp_dir)) != NULL) {
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = chip;
-		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+		entry->mode = S_IFREG | 0644;
 		entry->c.text.read = cs46xx_dsp_proc_scb_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);

commit 048ea6dfbe94f00afe52a2403324449efb356cd6
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Dec 7 14:22:50 2016 +0300

    ALSA: cs46xx: add a new line
    
    We accidentally deleted a newline so now the "nreallocated++;" statement
    is hanging out way off to the right of the screen.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 4a0cbd2241d8..aa61615288ff 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -107,7 +107,8 @@ static int shadow_and_reallocate_code (struct snd_cs46xx * chip, u32 * data, u32
             
 						dev_dbg(chip->card->dev,
 							"handle_wideop:[2] %05x:%05x addr %04x\n",
-							hival, loval, address);						nreallocated++;
+							hival, loval, address);
+						nreallocated++;
 					} /* wide_opcodes[j] == wide_op */
 				} /* for */
 			} /* mod_type == 0 ... */

commit 16f0f01d4f7fb9cbc7a383577ef9756d7eb9afd1
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Sep 1 11:15:44 2016 +0100

    ALSA: cs46xx: fix typo "seconadry" -> "secondary"
    
    Trivial fix to typos dev_dbg messages and comment.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index d2951ed4bf71..4a0cbd2241d8 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -1441,7 +1441,7 @@ int cs46xx_dsp_scb_and_task_init (struct snd_cs46xx *chip)
 	
 	if (chip->nr_ac97_codecs == 2) {
 		/* create CODEC tasklet for rear Center/LFE output 
-		   slot 6 and 9 on seconadry CODEC */
+		   slot 6 and 9 on secondary CODEC */
 		clfe_codec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,"CodecOutSCB_CLFE",0x0030,0x0030,
 								     CLFE_MIXER_SCB_ADDR,
 								     CLFE_CODEC_SCB_ADDR,

commit 95bb6258d6bd5d6608949e2fdafbd191705175d3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 29 07:55:37 2015 +0200

    ALSA: cs46xx: Fix old ifdef CONFIG_PROC_FS
    
    Replaced with the new CONFIG_SND_PROC_FS.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 5c99efb004c0..d2951ed4bf71 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -476,7 +476,7 @@ cs46xx_dsp_lookup_symbol (struct snd_cs46xx * chip, char * symbol_name, int symb
 }
 
 
-#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_SND_PROC_FS
 static struct dsp_symbol_entry *
 cs46xx_dsp_lookup_symbol_addr (struct snd_cs46xx * chip, u32 address, int symbol_type)
 {
@@ -929,7 +929,7 @@ int cs46xx_dsp_proc_done (struct snd_cs46xx *chip)
 
 	return 0;
 }
-#endif /* CONFIG_PROC_FS */
+#endif /* CONFIG_SND_PROC_FS */
 
 static void _dsp_create_task_tree (struct snd_cs46xx *chip, u32 * task_data,
 				   u32  dest, int size)

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 1c4a0fb3ffef..5c99efb004c0 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -20,7 +20,7 @@
  */
 
 
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/delay.h>
 #include <linux/pm.h>
 #include <linux/init.h>

commit 2b96a7f1fe6678e92850d5a150f1bf361ae1cb8e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 16:36:51 2014 +0100

    ALSA: cs46xx: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 1686b4f4c44f..1c4a0fb3ffef 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -85,12 +85,15 @@ static int shadow_and_reallocate_code (struct snd_cs46xx * chip, u32 * data, u32
 						address  = (hival & 0x00FFF) << 5;
 						address |=  loval >> 15;
             
-						snd_printdd("handle_wideop[1]: %05x:%05x addr %04x\n",hival,loval,address);
+						dev_dbg(chip->card->dev,
+							"handle_wideop[1]: %05x:%05x addr %04x\n",
+							hival, loval, address);
             
 						if ( !(address & 0x8000) ) {
 							address += (ins->code.offset / 2) - overlay_begin_address;
 						} else {
-							snd_printdd("handle_wideop[1]: ROM symbol not reallocated\n");
+							dev_dbg(chip->card->dev,
+								"handle_wideop[1]: ROM symbol not reallocated\n");
 						}
             
 						hival &= 0xFF000;
@@ -102,8 +105,9 @@ static int shadow_and_reallocate_code (struct snd_cs46xx * chip, u32 * data, u32
 						address  = (hival & 0x00FFF) << 5;
 						address |=  loval >> 15;
             
-						snd_printdd("handle_wideop:[2] %05x:%05x addr %04x\n",hival,loval,address);            
-						nreallocated ++;
+						dev_dbg(chip->card->dev,
+							"handle_wideop:[2] %05x:%05x addr %04x\n",
+							hival, loval, address);						nreallocated++;
 					} /* wide_opcodes[j] == wide_op */
 				} /* for */
 			} /* mod_type == 0 ... */
@@ -113,7 +117,8 @@ static int shadow_and_reallocate_code (struct snd_cs46xx * chip, u32 * data, u32
 		ins->code.data[ins->code.size++] = hival;
 	}
 
-	snd_printdd("dsp_spos: %d instructions reallocated\n",nreallocated);
+	dev_dbg(chip->card->dev,
+		"dsp_spos: %d instructions reallocated\n", nreallocated);
 	return nreallocated;
 }
 
@@ -157,7 +162,8 @@ static int add_symbols (struct snd_cs46xx * chip, struct dsp_module_desc * modul
 
 	for (i = 0;i < module->symbol_table.nsymbols; ++i) {
 		if (ins->symbol_table.nsymbols == (DSP_MAX_SYMBOLS - 1)) {
-			snd_printk(KERN_ERR "dsp_spos: symbol table is full\n");
+			dev_err(chip->card->dev,
+				"dsp_spos: symbol table is full\n");
 			return -ENOMEM;
 		}
 
@@ -176,8 +182,11 @@ static int add_symbols (struct snd_cs46xx * chip, struct dsp_module_desc * modul
 
 			ins->symbol_table.nsymbols++;
 		} else {
-          /* if (0) printk ("dsp_spos: symbol <%s> duplicated, probably nothing wrong with that (Cirrus?)\n",
-                             module->symbol_table.symbols[i].symbol_name); */
+#if 0
+			dev_dbg(chip->card->dev,
+				"dsp_spos: symbol <%s> duplicated, probably nothing wrong with that (Cirrus?)\n",
+				module->symbol_table.symbols[i].symbol_name); */
+#endif
 		}
 	}
 
@@ -192,14 +201,15 @@ add_symbol (struct snd_cs46xx * chip, char * symbol_name, u32 address, int type)
 	int index;
 
 	if (ins->symbol_table.nsymbols == (DSP_MAX_SYMBOLS - 1)) {
-		snd_printk(KERN_ERR "dsp_spos: symbol table is full\n");
+		dev_err(chip->card->dev, "dsp_spos: symbol table is full\n");
 		return NULL;
 	}
   
 	if (cs46xx_dsp_lookup_symbol(chip,
 				     symbol_name,
 				     type) != NULL) {
-		snd_printk(KERN_ERR "dsp_spos: symbol <%s> duplicated\n", symbol_name);
+		dev_err(chip->card->dev,
+			"dsp_spos: symbol <%s> duplicated\n", symbol_name);
 		return NULL;
 	}
 
@@ -305,19 +315,20 @@ static int dsp_load_parameter(struct snd_cs46xx *chip,
 	u32 doffset, dsize;
 
 	if (!parameter) {
-		snd_printdd("dsp_spos: module got no parameter segment\n");
+		dev_dbg(chip->card->dev,
+			"dsp_spos: module got no parameter segment\n");
 		return 0;
 	}
 
 	doffset = (parameter->offset * 4 + DSP_PARAMETER_BYTE_OFFSET);
 	dsize   = parameter->size * 4;
 
-	snd_printdd("dsp_spos: "
-		    "downloading parameter data to chip (%08x-%08x)\n",
+	dev_dbg(chip->card->dev,
+		"dsp_spos: downloading parameter data to chip (%08x-%08x)\n",
 		    doffset,doffset + dsize);
 	if (snd_cs46xx_download (chip, parameter->data, doffset, dsize)) {
-		snd_printk(KERN_ERR "dsp_spos: "
-			   "failed to download parameter data to DSP\n");
+		dev_err(chip->card->dev,
+			"dsp_spos: failed to download parameter data to DSP\n");
 		return -EINVAL;
 	}
 	return 0;
@@ -329,18 +340,21 @@ static int dsp_load_sample(struct snd_cs46xx *chip,
 	u32 doffset, dsize;
 
 	if (!sample) {
-		snd_printdd("dsp_spos: module got no sample segment\n");
+		dev_dbg(chip->card->dev,
+			"dsp_spos: module got no sample segment\n");
 		return 0;
 	}
 
 	doffset = (sample->offset * 4  + DSP_SAMPLE_BYTE_OFFSET);
 	dsize   =  sample->size * 4;
 
-	snd_printdd("dsp_spos: downloading sample data to chip (%08x-%08x)\n",
+	dev_dbg(chip->card->dev,
+		"dsp_spos: downloading sample data to chip (%08x-%08x)\n",
 		    doffset,doffset + dsize);
 
 	if (snd_cs46xx_download (chip,sample->data,doffset,dsize)) {
-		snd_printk(KERN_ERR "dsp_spos: failed to sample data to DSP\n");
+		dev_err(chip->card->dev,
+			"dsp_spos: failed to sample data to DSP\n");
 		return -EINVAL;
 	}
 	return 0;
@@ -354,14 +368,16 @@ int cs46xx_dsp_load_module (struct snd_cs46xx * chip, struct dsp_module_desc * m
 	int err;
 
 	if (ins->nmodules == DSP_MAX_MODULES - 1) {
-		snd_printk(KERN_ERR "dsp_spos: to many modules loaded into DSP\n");
+		dev_err(chip->card->dev,
+			"dsp_spos: to many modules loaded into DSP\n");
 		return -ENOMEM;
 	}
 
-	snd_printdd("dsp_spos: loading module %s into DSP\n", module->module_name);
+	dev_dbg(chip->card->dev,
+		"dsp_spos: loading module %s into DSP\n", module->module_name);
   
 	if (ins->nmodules == 0) {
-		snd_printdd("dsp_spos: clearing parameter area\n");
+		dev_dbg(chip->card->dev, "dsp_spos: clearing parameter area\n");
 		snd_cs46xx_clear_BA1(chip, DSP_PARAMETER_BYTE_OFFSET, DSP_PARAMETER_BYTE_SIZE);
 	}
   
@@ -371,7 +387,7 @@ int cs46xx_dsp_load_module (struct snd_cs46xx * chip, struct dsp_module_desc * m
 		return err;
 
 	if (ins->nmodules == 0) {
-		snd_printdd("dsp_spos: clearing sample area\n");
+		dev_dbg(chip->card->dev, "dsp_spos: clearing sample area\n");
 		snd_cs46xx_clear_BA1(chip, DSP_SAMPLE_BYTE_OFFSET, DSP_SAMPLE_BYTE_SIZE);
 	}
 
@@ -381,15 +397,17 @@ int cs46xx_dsp_load_module (struct snd_cs46xx * chip, struct dsp_module_desc * m
 		return err;
 
 	if (ins->nmodules == 0) {
-		snd_printdd("dsp_spos: clearing code area\n");
+		dev_dbg(chip->card->dev, "dsp_spos: clearing code area\n");
 		snd_cs46xx_clear_BA1(chip, DSP_CODE_BYTE_OFFSET, DSP_CODE_BYTE_SIZE);
 	}
 
 	if (code == NULL) {
-		snd_printdd("dsp_spos: module got no code segment\n");
+		dev_dbg(chip->card->dev,
+			"dsp_spos: module got no code segment\n");
 	} else {
 		if (ins->code.offset + code->size > DSP_CODE_BYTE_SIZE) {
-			snd_printk(KERN_ERR "dsp_spos: no space available in DSP\n");
+			dev_err(chip->card->dev,
+				"dsp_spos: no space available in DSP\n");
 			return -ENOMEM;
 		}
 
@@ -401,19 +419,22 @@ int cs46xx_dsp_load_module (struct snd_cs46xx * chip, struct dsp_module_desc * m
 		if (snd_BUG_ON(!module->symbol_table.symbols))
 			return -ENOMEM;
 		if (add_symbols(chip,module)) {
-			snd_printk(KERN_ERR "dsp_spos: failed to load symbol table\n");
+			dev_err(chip->card->dev,
+				"dsp_spos: failed to load symbol table\n");
 			return -ENOMEM;
 		}
     
 		doffset = (code->offset * 4 + ins->code.offset * 4 + DSP_CODE_BYTE_OFFSET);
 		dsize   = code->size * 4;
-		snd_printdd("dsp_spos: downloading code to chip (%08x-%08x)\n",
+		dev_dbg(chip->card->dev,
+			"dsp_spos: downloading code to chip (%08x-%08x)\n",
 			    doffset,doffset + dsize);   
 
 		module->nfixups = shadow_and_reallocate_code(chip,code->data,code->size,module->overlay_begin_address);
 
 		if (snd_cs46xx_download (chip,(ins->code.data + ins->code.offset),doffset,dsize)) {
-			snd_printk(KERN_ERR "dsp_spos: failed to download code to DSP\n");
+			dev_err(chip->card->dev,
+				"dsp_spos: failed to download code to DSP\n");
 			return -EINVAL;
 		}
 
@@ -447,7 +468,7 @@ cs46xx_dsp_lookup_symbol (struct snd_cs46xx * chip, char * symbol_name, int symb
 	}
 
 #if 0
-	printk ("dsp_spos: symbol <%s> type %02x not found\n",
+	dev_err(chip->card->dev, "dsp_spos: symbol <%s> type %02x not found\n",
 		symbol_name,symbol_type);
 #endif
 
@@ -910,7 +931,6 @@ int cs46xx_dsp_proc_done (struct snd_cs46xx *chip)
 }
 #endif /* CONFIG_PROC_FS */
 
-static int debug_tree;
 static void _dsp_create_task_tree (struct snd_cs46xx *chip, u32 * task_data,
 				   u32  dest, int size)
 {
@@ -919,13 +939,13 @@ static void _dsp_create_task_tree (struct snd_cs46xx *chip, u32 * task_data,
 	int i;
 
 	for (i = 0; i < size; ++i) {
-		if (debug_tree) printk ("addr %p, val %08x\n",spdst,task_data[i]);
+		dev_dbg(chip->card->dev, "addr %p, val %08x\n",
+			spdst, task_data[i]);
 		writel(task_data[i],spdst);
 		spdst += sizeof(u32);
 	}
 }
 
-static int debug_scb;
 static void _dsp_create_scb (struct snd_cs46xx *chip, u32 * scb_data, u32 dest)
 {
 	void __iomem *spdst = chip->region.idx[1].remap_addr + 
@@ -933,7 +953,8 @@ static void _dsp_create_scb (struct snd_cs46xx *chip, u32 * scb_data, u32 dest)
 	int i;
 
 	for (i = 0; i < 0x10; ++i) {
-		if (debug_scb) printk ("addr %p, val %08x\n",spdst,scb_data[i]);
+		dev_dbg(chip->card->dev, "addr %p, val %08x\n",
+			spdst, scb_data[i]);
 		writel(scb_data[i],spdst);
 		spdst += sizeof(u32);
 	}
@@ -960,7 +981,8 @@ static struct dsp_scb_descriptor * _map_scb (struct snd_cs46xx *chip, char * nam
 	int index;
 
 	if (ins->nscb == DSP_MAX_SCB_DESC - 1) {
-		snd_printk(KERN_ERR "dsp_spos: got no place for other SCB\n");
+		dev_err(chip->card->dev,
+			"dsp_spos: got no place for other SCB\n");
 		return NULL;
 	}
 
@@ -991,7 +1013,8 @@ _map_task_tree (struct snd_cs46xx *chip, char * name, u32 dest, u32 size)
 	struct dsp_task_descriptor * desc = NULL;
 
 	if (ins->ntask == DSP_MAX_TASK_DESC - 1) {
-		snd_printk(KERN_ERR "dsp_spos: got no place for other TASK\n");
+		dev_err(chip->card->dev,
+			"dsp_spos: got no place for other TASK\n");
 		return NULL;
 	}
 
@@ -1031,7 +1054,7 @@ cs46xx_dsp_create_scb (struct snd_cs46xx *chip, char * name, u32 * scb_data, u32
 		desc->data = scb_data;
 		_dsp_create_scb(chip,scb_data,dest);
 	} else {
-		snd_printk(KERN_ERR "dsp_spos: failed to map SCB\n");
+		dev_err(chip->card->dev, "dsp_spos: failed to map SCB\n");
 #ifdef CONFIG_PM_SLEEP
 		kfree(scb_data);
 #endif
@@ -1052,7 +1075,7 @@ cs46xx_dsp_create_task_tree (struct snd_cs46xx *chip, char * name, u32 * task_da
 		desc->data = task_data;
 		_dsp_create_task_tree(chip,task_data,dest,size);
 	} else {
-		snd_printk(KERN_ERR "dsp_spos: failed to map TASK\n");
+		dev_err(chip->card->dev, "dsp_spos: failed to map TASK\n");
 	}
 
 	return desc;
@@ -1105,31 +1128,36 @@ int cs46xx_dsp_scb_and_task_init (struct snd_cs46xx *chip)
 
 	null_algorithm  = cs46xx_dsp_lookup_symbol(chip, "NULLALGORITHM", SYMBOL_CODE);
 	if (null_algorithm == NULL) {
-		snd_printk(KERN_ERR "dsp_spos: symbol NULLALGORITHM not found\n");
+		dev_err(chip->card->dev,
+			"dsp_spos: symbol NULLALGORITHM not found\n");
 		return -EIO;
 	}
 
 	fg_task_tree_header_code = cs46xx_dsp_lookup_symbol(chip, "FGTASKTREEHEADERCODE", SYMBOL_CODE);  
 	if (fg_task_tree_header_code == NULL) {
-		snd_printk(KERN_ERR "dsp_spos: symbol FGTASKTREEHEADERCODE not found\n");
+		dev_err(chip->card->dev,
+			"dsp_spos: symbol FGTASKTREEHEADERCODE not found\n");
 		return -EIO;
 	}
 
 	task_tree_header_code = cs46xx_dsp_lookup_symbol(chip, "TASKTREEHEADERCODE", SYMBOL_CODE);  
 	if (task_tree_header_code == NULL) {
-		snd_printk(KERN_ERR "dsp_spos: symbol TASKTREEHEADERCODE not found\n");
+		dev_err(chip->card->dev,
+			"dsp_spos: symbol TASKTREEHEADERCODE not found\n");
 		return -EIO;
 	}
   
 	task_tree_thread = cs46xx_dsp_lookup_symbol(chip, "TASKTREETHREAD", SYMBOL_CODE);
 	if (task_tree_thread == NULL) {
-		snd_printk(KERN_ERR "dsp_spos: symbol TASKTREETHREAD not found\n");
+		dev_err(chip->card->dev,
+			"dsp_spos: symbol TASKTREETHREAD not found\n");
 		return -EIO;
 	}
 
 	magic_snoop_task = cs46xx_dsp_lookup_symbol(chip, "MAGICSNOOPTASK", SYMBOL_CODE);
 	if (magic_snoop_task == NULL) {
-		snd_printk(KERN_ERR "dsp_spos: symbol MAGICSNOOPTASK not found\n");
+		dev_err(chip->card->dev,
+			"dsp_spos: symbol MAGICSNOOPTASK not found\n");
 		return -EIO;
 	}
   
@@ -1476,7 +1504,7 @@ int cs46xx_dsp_scb_and_task_init (struct snd_cs46xx *chip)
 	return 0;
 
  _fail_end:
-	snd_printk(KERN_ERR "dsp_spos: failed to setup SCB's in DSP\n");
+	dev_err(chip->card->dev, "dsp_spos: failed to setup SCB's in DSP\n");
 	return -EINVAL;
 }
 
@@ -1491,18 +1519,21 @@ static int cs46xx_dsp_async_init (struct snd_cs46xx *chip,
 
 	s16_async_codec_input_task = cs46xx_dsp_lookup_symbol(chip, "S16_ASYNCCODECINPUTTASK", SYMBOL_CODE);
 	if (s16_async_codec_input_task == NULL) {
-		snd_printk(KERN_ERR "dsp_spos: symbol S16_ASYNCCODECINPUTTASK not found\n");
+		dev_err(chip->card->dev,
+			"dsp_spos: symbol S16_ASYNCCODECINPUTTASK not found\n");
 		return -EIO;
 	}
 	spdifo_task = cs46xx_dsp_lookup_symbol(chip, "SPDIFOTASK", SYMBOL_CODE);
 	if (spdifo_task == NULL) {
-		snd_printk(KERN_ERR "dsp_spos: symbol SPDIFOTASK not found\n");
+		dev_err(chip->card->dev,
+			"dsp_spos: symbol SPDIFOTASK not found\n");
 		return -EIO;
 	}
 
 	spdifi_task = cs46xx_dsp_lookup_symbol(chip, "SPDIFITASK", SYMBOL_CODE);
 	if (spdifi_task == NULL) {
-		snd_printk(KERN_ERR "dsp_spos: symbol SPDIFITASK not found\n");
+		dev_err(chip->card->dev,
+			"dsp_spos: symbol SPDIFITASK not found\n");
 		return -EIO;
 	}
 
@@ -1883,7 +1914,8 @@ int cs46xx_poke_via_dsp (struct snd_cs46xx *chip, u32 address, u32 data)
 	}
 
 	if (i == 25) {
-		snd_printk(KERN_ERR "dsp_spos: SPIOWriteTask not responding\n");
+		dev_err(chip->card->dev,
+			"dsp_spos: SPIOWriteTask not responding\n");
 		return -EBUSY;
 	}
 

commit c7561cd80469f2fe4a6be0984db57832ee7f2a3b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 14 18:12:04 2012 +0200

    ALSA: PCI: Replace CONFIG_PM with CONFIG_PM_SLEEP
    
    Otherwise we may get compile warnings due to unused functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 56fec0bc0efb..1686b4f4c44f 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -287,7 +287,7 @@ void  cs46xx_dsp_spos_destroy (struct snd_cs46xx * chip)
 		if (ins->scbs[i].deleted) continue;
 
 		cs46xx_dsp_proc_free_scb_desc ( (ins->scbs + i) );
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 		kfree(ins->scbs[i].data);
 #endif
 	}
@@ -1019,7 +1019,7 @@ cs46xx_dsp_create_scb (struct snd_cs46xx *chip, char * name, u32 * scb_data, u32
 {
 	struct dsp_scb_descriptor * desc;
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	/* copy the data for resume */
 	scb_data = kmemdup(scb_data, SCB_BYTES, GFP_KERNEL);
 	if (!scb_data)
@@ -1032,7 +1032,7 @@ cs46xx_dsp_create_scb (struct snd_cs46xx *chip, char * name, u32 * scb_data, u32
 		_dsp_create_scb(chip,scb_data,dest);
 	} else {
 		snd_printk(KERN_ERR "dsp_spos: failed to map SCB\n");
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 		kfree(scb_data);
 #endif
 	}
@@ -1937,7 +1937,7 @@ int cs46xx_dsp_set_iec958_volume (struct snd_cs46xx * chip, u16 left, u16 right)
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 int cs46xx_dsp_resume(struct snd_cs46xx * chip)
 {
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;

commit 81fcb170852d58d7ebd8101a8ef970c82056426e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 16:37:05 2012 +0200

    ALSA: Move some headers to local directories from include/sound
    
    This is a bit clean up of public sound header directory.
    Some header files in include/sound aren't really necessary to be
    located there but can be moved to their local directories gracefully.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index e377287192aa..56fec0bc0efb 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -32,7 +32,7 @@
 #include <sound/control.h>
 #include <sound/info.h>
 #include <sound/asoundef.h>
-#include <sound/cs46xx.h>
+#include "cs46xx.h"
 
 #include "cs46xx_lib.h"
 #include "dsp_spos.h"

commit bb617ee3f82ba94072c8b08043d9166bbfe397a2
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Fri Oct 29 22:54:45 2010 +0200

    ALSA: cs46xx memory management fixes for cs46xx_dsp_spos_create()
    
    When reading through sound/pci/cs46xx/dsp_spos.c I noticed a couple of
    things in cs46xx_dsp_spos_create().
    
    It seems to me that we don't always free the various memory buffers we
    allocate and we also do some work (structure member assignment) early,
    that is completely pointless if some of the memory allocations fail and
    we end up just aborting the whole thing.
    
    I don't have hardware to test, so the patch below is compile tested only,
    but it makes the following changes:
    
    - Make sure we always free all allocated memory on failures.
    - Don't do pointless work assigning to structure members before we know
      all memory allocations, that may abort progress, have completed
      successfully.
    - Remove some trailing whitespace.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 3e5ca8fb519f..e377287192aa 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -225,39 +225,25 @@ struct dsp_spos_instance *cs46xx_dsp_spos_create (struct snd_cs46xx * chip)
 {
 	struct dsp_spos_instance * ins = kzalloc(sizeof(struct dsp_spos_instance), GFP_KERNEL);
 
-	if (ins == NULL) 
+	if (ins == NULL)
 		return NULL;
 
 	/* better to use vmalloc for this big table */
-	ins->symbol_table.nsymbols = 0;
 	ins->symbol_table.symbols = vmalloc(sizeof(struct dsp_symbol_entry) *
 					    DSP_MAX_SYMBOLS);
-	ins->symbol_table.highest_frag_index = 0;
-
-	if (ins->symbol_table.symbols == NULL) {
+	ins->code.data = kmalloc(DSP_CODE_BYTE_SIZE, GFP_KERNEL);
+	ins->modules = kmalloc(sizeof(struct dsp_module_desc) * DSP_MAX_MODULES, GFP_KERNEL);
+	if (!ins->symbol_table.symbols || !ins->code.data || !ins->modules) {
 		cs46xx_dsp_spos_destroy(chip);
 		goto error;
 	}
-
+	ins->symbol_table.nsymbols = 0;
+	ins->symbol_table.highest_frag_index = 0;
 	ins->code.offset = 0;
 	ins->code.size = 0;
-	ins->code.data = kmalloc(DSP_CODE_BYTE_SIZE, GFP_KERNEL);
-
-	if (ins->code.data == NULL) {
-		cs46xx_dsp_spos_destroy(chip);
-		goto error;
-	}
-
 	ins->nscb = 0;
 	ins->ntask = 0;
-
 	ins->nmodules = 0;
-	ins->modules = kmalloc(sizeof(struct dsp_module_desc) * DSP_MAX_MODULES, GFP_KERNEL);
-
-	if (ins->modules == NULL) {
-		cs46xx_dsp_spos_destroy(chip);
-		goto error;
-	}
 
 	/* default SPDIF input sample rate
 	   to 48000 khz */
@@ -271,8 +257,8 @@ struct dsp_spos_instance *cs46xx_dsp_spos_create (struct snd_cs46xx * chip)
 
 	/* set left and right validity bits and
 	   default channel status */
-	ins->spdif_csuv_default = 
-		ins->spdif_csuv_stream =  
+	ins->spdif_csuv_default =
+		ins->spdif_csuv_stream =
 	 /* byte 0 */  ((unsigned int)_wrap_all_bits(  (SNDRV_PCM_DEFAULT_CON_SPDIF        & 0xff)) << 24) |
 	 /* byte 1 */  ((unsigned int)_wrap_all_bits( ((SNDRV_PCM_DEFAULT_CON_SPDIF >> 8) & 0xff)) << 16) |
 	 /* byte 3 */   (unsigned int)_wrap_all_bits(  (SNDRV_PCM_DEFAULT_CON_SPDIF >> 24) & 0xff) |
@@ -281,6 +267,9 @@ struct dsp_spos_instance *cs46xx_dsp_spos_create (struct snd_cs46xx * chip)
 	return ins;
 
 error:
+	kfree(ins->modules);
+	kfree(ins->code.data);
+	vfree(ins->symbol_table.symbols);
 	kfree(ins);
 	return NULL;
 }

commit 41116e926cb92292fa4fcbe888ae8133fa0038e6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 22 09:00:14 2009 +0100

    ALSA: cs46xx - Fix suspend/resume with new DSP
    
    Fix the basic suspend/resume of snd-cs46xx drivers with new DSP.
    
    References:
            https://bugzilla.redhat.com/show_bug.cgi?id=498287
            https://bugzilla.redhat.com/show_bug.cgi?id=160751
    
    Tested-by: Florian Zumbiehl <florz@florz.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index f4f0c8f5dad7..3e5ca8fb519f 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -298,6 +298,9 @@ void  cs46xx_dsp_spos_destroy (struct snd_cs46xx * chip)
 		if (ins->scbs[i].deleted) continue;
 
 		cs46xx_dsp_proc_free_scb_desc ( (ins->scbs + i) );
+#ifdef CONFIG_PM
+		kfree(ins->scbs[i].data);
+#endif
 	}
 
 	kfree(ins->code.data);
@@ -974,13 +977,11 @@ static struct dsp_scb_descriptor * _map_scb (struct snd_cs46xx *chip, char * nam
 
 	index = find_free_scb_index (ins);
 
+	memset(&ins->scbs[index], 0, sizeof(ins->scbs[index]));
 	strcpy(ins->scbs[index].scb_name, name);
 	ins->scbs[index].address = dest;
 	ins->scbs[index].index = index;
-	ins->scbs[index].proc_info = NULL;
 	ins->scbs[index].ref_count = 1;
-	ins->scbs[index].deleted = 0;
-	spin_lock_init(&ins->scbs[index].lock);
 
 	desc = (ins->scbs + index);
 	ins->scbs[index].scb_symbol = add_symbol (chip, name, dest, SYMBOL_PARAMETER);
@@ -1022,17 +1023,29 @@ _map_task_tree (struct snd_cs46xx *chip, char * name, u32 dest, u32 size)
 	return desc;
 }
 
+#define SCB_BYTES	(0x10 * 4)
+
 struct dsp_scb_descriptor *
 cs46xx_dsp_create_scb (struct snd_cs46xx *chip, char * name, u32 * scb_data, u32 dest)
 {
 	struct dsp_scb_descriptor * desc;
 
+#ifdef CONFIG_PM
+	/* copy the data for resume */
+	scb_data = kmemdup(scb_data, SCB_BYTES, GFP_KERNEL);
+	if (!scb_data)
+		return NULL;
+#endif
+
 	desc = _map_scb (chip,name,dest);
 	if (desc) {
 		desc->data = scb_data;
 		_dsp_create_scb(chip,scb_data,dest);
 	} else {
 		snd_printk(KERN_ERR "dsp_spos: failed to map SCB\n");
+#ifdef CONFIG_PM
+		kfree(scb_data);
+#endif
 	}
 
 	return desc;
@@ -1988,7 +2001,28 @@ int cs46xx_dsp_resume(struct snd_cs46xx * chip)
 			continue;
 		_dsp_create_scb(chip, s->data, s->address);
 	}
-
+	for (i = 0; i < ins->nscb; i++) {
+		struct dsp_scb_descriptor *s = &ins->scbs[i];
+		if (s->deleted)
+			continue;
+		if (s->updated)
+			cs46xx_dsp_spos_update_scb(chip, s);
+		if (s->volume_set)
+			cs46xx_dsp_scb_set_volume(chip, s,
+						  s->volume[0], s->volume[1]);
+	}
+	if (ins->spdif_status_out & DSP_SPDIF_STATUS_HW_ENABLED) {
+		cs46xx_dsp_enable_spdif_hw(chip);
+		snd_cs46xx_poke(chip, (ins->ref_snoop_scb->address + 2) << 2,
+				(OUTPUT_SNOOP_BUFFER + 0x10) << 0x10);
+		if (ins->spdif_status_out & DSP_SPDIF_STATUS_PLAYBACK_OPEN)
+			cs46xx_poke_via_dsp(chip, SP_SPDOUT_CSUV,
+					    ins->spdif_csuv_stream);
+	}
+	if (chip->dsp_spos_instance->spdif_status_in) {
+		cs46xx_poke_via_dsp(chip, SP_ASER_COUNTDOWN, 0x80000005);
+		cs46xx_poke_via_dsp(chip, SP_SPDIN_CONTROL, 0x800003ff);
+	}
 	return 0;
 }
 #endif

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index ccc8bedb5b1a..f4f0c8f5dad7 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -63,7 +63,8 @@ static int shadow_and_reallocate_code (struct snd_cs46xx * chip, u32 * data, u32
 	u32 mop_operands,mop_type,wide_op;
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
-	snd_assert( ((size % 2) == 0), return -EINVAL);
+	if (snd_BUG_ON(size %2))
+		return -EINVAL;
   
 	while (i < size) {
 		loval = data[i++];
@@ -289,7 +290,8 @@ void  cs46xx_dsp_spos_destroy (struct snd_cs46xx * chip)
 	int i;
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
-	snd_assert(ins != NULL, return);
+	if (snd_BUG_ON(!ins))
+		return;
 
 	mutex_lock(&chip->spos_mutex);
 	for (i = 0; i < ins->nscb; ++i) {
@@ -404,7 +406,8 @@ int cs46xx_dsp_load_module (struct snd_cs46xx * chip, struct dsp_module_desc * m
 
 		/* if module has a code segment it must have
 		   symbol table */
-		snd_assert(module->symbol_table.symbols != NULL ,return -ENOMEM);
+		if (snd_BUG_ON(!module->symbol_table.symbols))
+			return -ENOMEM;
 		if (add_symbols(chip,module)) {
 			snd_printk(KERN_ERR "dsp_spos: failed to load symbol table\n");
 			return -ENOMEM;
@@ -1369,7 +1372,8 @@ int cs46xx_dsp_scb_and_task_init (struct snd_cs46xx *chip)
 
 	valid_slots = snd_cs46xx_peekBA0(chip, BA0_ACOSV);
 
-	snd_assert (chip->nr_ac97_codecs == 1 || chip->nr_ac97_codecs == 2);
+	if (snd_BUG_ON(chip->nr_ac97_codecs != 1 && chip->nr_ac97_codecs != 2))
+		goto _fail_end;
 
 	if (chip->nr_ac97_codecs == 1) {
 		/* output on slot 5 and 11 
@@ -1609,11 +1613,14 @@ static int cs46xx_dsp_async_init (struct snd_cs46xx *chip,
 
 		spdifo_scb_desc = cs46xx_dsp_create_scb(chip,"SPDIFOSCB",(u32 *)&spdifo_scb,SPDIFO_SCB_INST);
 
-		snd_assert(spdifo_scb_desc, return -EIO);
+		if (snd_BUG_ON(!spdifo_scb_desc))
+			return -EIO;
 		spdifi_scb_desc = cs46xx_dsp_create_scb(chip,"SPDIFISCB",(u32 *)&spdifi_scb,SPDIFI_SCB_INST);
-		snd_assert(spdifi_scb_desc, return -EIO);
+		if (snd_BUG_ON(!spdifi_scb_desc))
+			return -EIO;
 		async_codec_scb_desc = cs46xx_dsp_create_scb(chip,"AsynCodecInputSCB",(u32 *)&async_codec_input_scb, HFG_TREE_SCB);
-		snd_assert(async_codec_scb_desc, return -EIO);
+		if (snd_BUG_ON(!async_codec_scb_desc))
+			return -EIO;
 
 		async_codec_scb_desc->parent_scb_ptr = NULL;
 		async_codec_scb_desc->next_scb_ptr = spdifi_scb_desc;
@@ -1698,8 +1705,10 @@ int cs46xx_dsp_enable_spdif_in (struct snd_cs46xx *chip)
 	chip->active_ctrl(chip, 1);
 	chip->amplifier_ctrl(chip, 1);
 
-	snd_assert (ins->asynch_rx_scb == NULL,return -EINVAL);
-	snd_assert (ins->spdif_in_src != NULL,return -EINVAL);
+	if (snd_BUG_ON(ins->asynch_rx_scb))
+		return -EINVAL;
+	if (snd_BUG_ON(!ins->spdif_in_src))
+		return -EINVAL;
 
 	mutex_lock(&chip->spos_mutex);
 
@@ -1754,8 +1763,10 @@ int cs46xx_dsp_disable_spdif_in (struct snd_cs46xx *chip)
 {
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
-	snd_assert (ins->asynch_rx_scb != NULL, return -EINVAL);
-	snd_assert (ins->spdif_in_src != NULL,return -EINVAL);	
+	if (snd_BUG_ON(!ins->asynch_rx_scb))
+		return -EINVAL;
+	if (snd_BUG_ON(!ins->spdif_in_src))
+		return -EINVAL;
 
 	mutex_lock(&chip->spos_mutex);
 
@@ -1780,8 +1791,10 @@ int cs46xx_dsp_enable_pcm_capture (struct snd_cs46xx *chip)
 {
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
-	snd_assert (ins->pcm_input == NULL,return -EINVAL);
-	snd_assert (ins->ref_snoop_scb != NULL,return -EINVAL);
+	if (snd_BUG_ON(ins->pcm_input))
+		return -EINVAL;
+	if (snd_BUG_ON(!ins->ref_snoop_scb))
+		return -EINVAL;
 
 	mutex_lock(&chip->spos_mutex);
 	ins->pcm_input = cs46xx_add_record_source(chip,ins->ref_snoop_scb,PCMSERIALIN_PCM_SCB_ADDR,
@@ -1795,7 +1808,8 @@ int cs46xx_dsp_disable_pcm_capture (struct snd_cs46xx *chip)
 {
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
-	snd_assert (ins->pcm_input != NULL,return -EINVAL);
+	if (snd_BUG_ON(!ins->pcm_input))
+		return -EINVAL;
 
 	mutex_lock(&chip->spos_mutex);
 	cs46xx_dsp_remove_scb (chip,ins->pcm_input);
@@ -1809,8 +1823,10 @@ int cs46xx_dsp_enable_adc_capture (struct snd_cs46xx *chip)
 {
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
-	snd_assert (ins->adc_input == NULL,return -EINVAL);
-	snd_assert (ins->codec_in_scb != NULL,return -EINVAL);
+	if (snd_BUG_ON(ins->adc_input))
+		return -EINVAL;
+	if (snd_BUG_ON(!ins->codec_in_scb))
+		return -EINVAL;
 
 	mutex_lock(&chip->spos_mutex);
 	ins->adc_input = cs46xx_add_record_source(chip,ins->codec_in_scb,PCMSERIALIN_SCB_ADDR,
@@ -1824,7 +1840,8 @@ int cs46xx_dsp_disable_adc_capture (struct snd_cs46xx *chip)
 {
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
-	snd_assert (ins->adc_input != NULL,return -EINVAL);
+	if (snd_BUG_ON(!ins->adc_input))
+		return -EINVAL;
 
 	mutex_lock(&chip->spos_mutex);
 	cs46xx_dsp_remove_scb (chip,ins->adc_input);

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 590b35d91df2..ccc8bedb5b1a 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -20,7 +20,6 @@
  */
 
 
-#include <sound/driver.h>
 #include <asm/io.h>
 #include <linux/delay.h>
 #include <linux/pm.h>

commit 89f157d9e6bf08b65f93dcb1dca1de037079885f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jul 19 11:23:21 2007 +0200

    [ALSA] cs46xx - Fix PM resume
    
    Fixed PM resume of cs46xx devices.  It now restores properly the DSP
    image and kick-off the DSP.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 336e77e2600c..590b35d91df2 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -306,13 +306,59 @@ void  cs46xx_dsp_spos_destroy (struct snd_cs46xx * chip)
 	mutex_unlock(&chip->spos_mutex);
 }
 
+static int dsp_load_parameter(struct snd_cs46xx *chip,
+			      struct dsp_segment_desc *parameter)
+{
+	u32 doffset, dsize;
+
+	if (!parameter) {
+		snd_printdd("dsp_spos: module got no parameter segment\n");
+		return 0;
+	}
+
+	doffset = (parameter->offset * 4 + DSP_PARAMETER_BYTE_OFFSET);
+	dsize   = parameter->size * 4;
+
+	snd_printdd("dsp_spos: "
+		    "downloading parameter data to chip (%08x-%08x)\n",
+		    doffset,doffset + dsize);
+	if (snd_cs46xx_download (chip, parameter->data, doffset, dsize)) {
+		snd_printk(KERN_ERR "dsp_spos: "
+			   "failed to download parameter data to DSP\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int dsp_load_sample(struct snd_cs46xx *chip,
+			   struct dsp_segment_desc *sample)
+{
+	u32 doffset, dsize;
+
+	if (!sample) {
+		snd_printdd("dsp_spos: module got no sample segment\n");
+		return 0;
+	}
+
+	doffset = (sample->offset * 4  + DSP_SAMPLE_BYTE_OFFSET);
+	dsize   =  sample->size * 4;
+
+	snd_printdd("dsp_spos: downloading sample data to chip (%08x-%08x)\n",
+		    doffset,doffset + dsize);
+
+	if (snd_cs46xx_download (chip,sample->data,doffset,dsize)) {
+		snd_printk(KERN_ERR "dsp_spos: failed to sample data to DSP\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
 int cs46xx_dsp_load_module (struct snd_cs46xx * chip, struct dsp_module_desc * module)
 {
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 	struct dsp_segment_desc * code = get_segment_desc (module,SEGTYPE_SP_PROGRAM);
-	struct dsp_segment_desc * parameter = get_segment_desc (module,SEGTYPE_SP_PARAMETER);
-	struct dsp_segment_desc * sample = get_segment_desc (module,SEGTYPE_SP_SAMPLE);
 	u32 doffset, dsize;
+	int err;
 
 	if (ins->nmodules == DSP_MAX_MODULES - 1) {
 		snd_printk(KERN_ERR "dsp_spos: to many modules loaded into DSP\n");
@@ -326,49 +372,20 @@ int cs46xx_dsp_load_module (struct snd_cs46xx * chip, struct dsp_module_desc * m
 		snd_cs46xx_clear_BA1(chip, DSP_PARAMETER_BYTE_OFFSET, DSP_PARAMETER_BYTE_SIZE);
 	}
   
-	if (parameter == NULL) {
-		snd_printdd("dsp_spos: module got no parameter segment\n");
-	} else {
-		if (ins->nmodules > 0) {
-			snd_printk(KERN_WARNING "dsp_spos: WARNING current parameter data may be overwriten!\n");
-		}
-
-		doffset = (parameter->offset * 4 + DSP_PARAMETER_BYTE_OFFSET);
-		dsize   = parameter->size * 4;
-
-		snd_printdd("dsp_spos: downloading parameter data to chip (%08x-%08x)\n",
-			    doffset,doffset + dsize);
-
-		if (snd_cs46xx_download (chip, parameter->data, doffset, dsize)) {
-			snd_printk(KERN_ERR "dsp_spos: failed to download parameter data to DSP\n");
-			return -EINVAL;
-		}
-	}
+	err = dsp_load_parameter(chip, get_segment_desc(module,
+							SEGTYPE_SP_PARAMETER));
+	if (err < 0)
+		return err;
 
 	if (ins->nmodules == 0) {
 		snd_printdd("dsp_spos: clearing sample area\n");
 		snd_cs46xx_clear_BA1(chip, DSP_SAMPLE_BYTE_OFFSET, DSP_SAMPLE_BYTE_SIZE);
 	}
 
-	if (sample == NULL) {
-		snd_printdd("dsp_spos: module got no sample segment\n");
-	} else {
-		if (ins->nmodules > 0) {
-			snd_printk(KERN_WARNING "dsp_spos: WARNING current sample data may be overwriten\n");
-		}
-
-		doffset = (sample->offset * 4  + DSP_SAMPLE_BYTE_OFFSET);
-		dsize   =  sample->size * 4;
-
-		snd_printdd("dsp_spos: downloading sample data to chip (%08x-%08x)\n",
-			    doffset,doffset + dsize);
-
-		if (snd_cs46xx_download (chip,sample->data,doffset,dsize)) {
-			snd_printk(KERN_ERR "dsp_spos: failed to sample data to DSP\n");
-			return -EINVAL;
-		}
-	}
-
+	err = dsp_load_sample(chip, get_segment_desc(module,
+						     SEGTYPE_SP_SAMPLE));
+	if (err < 0)
+		return err;
 
 	if (ins->nmodules == 0) {
 		snd_printdd("dsp_spos: clearing code area\n");
@@ -986,7 +1003,10 @@ _map_task_tree (struct snd_cs46xx *chip, char * name, u32 dest, u32 size)
 		return NULL;
 	}
 
-	strcpy(ins->tasks[ins->ntask].task_name,name);
+	if (name)
+		strcpy(ins->tasks[ins->ntask].task_name, name);
+	else
+		strcpy(ins->tasks[ins->ntask].task_name, "(NULL)");
 	ins->tasks[ins->ntask].address = dest;
 	ins->tasks[ins->ntask].size = size;
 
@@ -995,7 +1015,8 @@ _map_task_tree (struct snd_cs46xx *chip, char * name, u32 dest, u32 size)
 	desc = (ins->tasks + ins->ntask);
 	ins->ntask++;
 
-	add_symbol (chip,name,dest,SYMBOL_PARAMETER);
+	if (name)
+		add_symbol (chip,name,dest,SYMBOL_PARAMETER);
 	return desc;
 }
 
@@ -1006,6 +1027,7 @@ cs46xx_dsp_create_scb (struct snd_cs46xx *chip, char * name, u32 * scb_data, u32
 
 	desc = _map_scb (chip,name,dest);
 	if (desc) {
+		desc->data = scb_data;
 		_dsp_create_scb(chip,scb_data,dest);
 	} else {
 		snd_printk(KERN_ERR "dsp_spos: failed to map SCB\n");
@@ -1023,6 +1045,7 @@ cs46xx_dsp_create_task_tree (struct snd_cs46xx *chip, char * name, u32 * task_da
 
 	desc = _map_task_tree (chip,name,dest,size);
 	if (desc) {
+		desc->data = task_data;
 		_dsp_create_task_tree(chip,task_data,dest,size);
 	} else {
 		snd_printk(KERN_ERR "dsp_spos: failed to map TASK\n");
@@ -1320,8 +1343,10 @@ int cs46xx_dsp_scb_and_task_init (struct snd_cs46xx *chip)
 			0x0000ffff
 		};
     
-		/* dirty hack ... */
-		_dsp_create_task_tree (chip,(u32 *)&mix2_ostream_spb,WRITE_BACK_SPB,2);
+		if (!cs46xx_dsp_create_task_tree(chip, NULL,
+						 (u32 *)&mix2_ostream_spb,
+						 WRITE_BACK_SPB, 2))
+			goto _fail_end;
 	}
 
 	/* input sample converter */
@@ -1622,7 +1647,6 @@ static int cs46xx_dsp_async_init (struct snd_cs46xx *chip,
 	return 0;
 }
 
-
 static void cs46xx_dsp_disable_spdif_hw (struct snd_cs46xx *chip)
 {
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
@@ -1894,3 +1918,61 @@ int cs46xx_dsp_set_iec958_volume (struct snd_cs46xx * chip, u16 left, u16 right)
 
 	return 0;
 }
+
+#ifdef CONFIG_PM
+int cs46xx_dsp_resume(struct snd_cs46xx * chip)
+{
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
+	int i, err;
+
+	/* clear parameter, sample and code areas */
+	snd_cs46xx_clear_BA1(chip, DSP_PARAMETER_BYTE_OFFSET,
+			     DSP_PARAMETER_BYTE_SIZE);
+	snd_cs46xx_clear_BA1(chip, DSP_SAMPLE_BYTE_OFFSET,
+			     DSP_SAMPLE_BYTE_SIZE);
+	snd_cs46xx_clear_BA1(chip, DSP_CODE_BYTE_OFFSET, DSP_CODE_BYTE_SIZE);
+
+	for (i = 0; i < ins->nmodules; i++) {
+		struct dsp_module_desc *module = &ins->modules[i];
+		struct dsp_segment_desc *seg;
+		u32 doffset, dsize;
+
+		seg = get_segment_desc(module, SEGTYPE_SP_PARAMETER);
+		err = dsp_load_parameter(chip, seg);
+		if (err < 0)
+			return err;
+
+		seg = get_segment_desc(module, SEGTYPE_SP_SAMPLE);
+		err = dsp_load_sample(chip, seg);
+		if (err < 0)
+			return err;
+
+		seg = get_segment_desc(module, SEGTYPE_SP_PROGRAM);
+		if (!seg)
+			continue;
+
+		doffset = seg->offset * 4 + module->load_address * 4
+			+ DSP_CODE_BYTE_OFFSET;
+		dsize   = seg->size * 4;
+		err = snd_cs46xx_download(chip,
+					  ins->code.data + module->load_address,
+					  doffset, dsize);
+		if (err < 0)
+			return err;
+	}
+
+	for (i = 0; i < ins->ntask; i++) {
+		struct dsp_task_descriptor *t = &ins->tasks[i];
+		_dsp_create_task_tree(chip, t->data, t->address, t->size);
+	}
+
+	for (i = 0; i < ins->nscb; i++) {
+		struct dsp_scb_descriptor *s = &ins->scbs[i];
+		if (s->deleted)
+			continue;
+		_dsp_create_scb(chip, s->data, s->address);
+	}
+
+	return 0;
+}
+#endif

commit 6473d160b4aba8023bcf38519a5989694dfd51a7
Author: Jean Delvare <khali@linux-fr.org>
Date:   Tue Mar 6 02:45:12 2007 -0800

    PCI: Cleanup the includes of <linux/pci.h>
    
    I noticed that many source files include <linux/pci.h> while they do
    not appear to need it. Here is an attempt to clean it all up.
    
    In order to find all possibly affected files, I searched for all
    files including <linux/pci.h> but without any other occurence of "pci"
    or "PCI". I removed the include statement from all of these, then I
    compiled an allmodconfig kernel on both i386 and x86_64 and fixed the
    false positives manually.
    
    My tests covered 66% of the affected files, so there could be false
    positives remaining. Untested files are:
    
    arch/alpha/kernel/err_common.c
    arch/alpha/kernel/err_ev6.c
    arch/alpha/kernel/err_ev7.c
    arch/ia64/sn/kernel/huberror.c
    arch/ia64/sn/kernel/xpnet.c
    arch/m68knommu/kernel/dma.c
    arch/mips/lib/iomap.c
    arch/powerpc/platforms/pseries/ras.c
    arch/ppc/8260_io/enet.c
    arch/ppc/8260_io/fcc_enet.c
    arch/ppc/8xx_io/enet.c
    arch/ppc/syslib/ppc4xx_sgdma.c
    arch/sh64/mach-cayman/iomap.c
    arch/xtensa/kernel/xtensa_ksyms.c
    arch/xtensa/platform-iss/setup.c
    drivers/i2c/busses/i2c-at91.c
    drivers/i2c/busses/i2c-mpc.c
    drivers/media/video/saa711x.c
    drivers/misc/hdpuftrs/hdpu_cpustate.c
    drivers/misc/hdpuftrs/hdpu_nexus.c
    drivers/net/au1000_eth.c
    drivers/net/fec_8xx/fec_main.c
    drivers/net/fec_8xx/fec_mii.c
    drivers/net/fs_enet/fs_enet-main.c
    drivers/net/fs_enet/mac-fcc.c
    drivers/net/fs_enet/mac-fec.c
    drivers/net/fs_enet/mac-scc.c
    drivers/net/fs_enet/mii-bitbang.c
    drivers/net/fs_enet/mii-fec.c
    drivers/net/ibm_emac/ibm_emac_core.c
    drivers/net/lasi_82596.c
    drivers/parisc/hppb.c
    drivers/sbus/sbus.c
    drivers/video/g364fb.c
    drivers/video/platinumfb.c
    drivers/video/stifb.c
    drivers/video/valkyriefb.c
    include/asm-arm/arch-ixp4xx/dma.h
    sound/oss/au1550_ac97.c
    
    I would welcome test reports for these files. I am fine with removing
    the untested files from the patch if the general opinion is that these
    changes aren't safe. The tested part would still be nice to have.
    
    Note that this patch depends on another header fixup patch I submitted
    to LKML yesterday:
      [PATCH] scatterlist.h needs types.h
      http://lkml.org/lkml/2007/3/01/141
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Cc: Badari Pulavarty <pbadari@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 89c402770a1d..336e77e2600c 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -23,7 +23,6 @@
 #include <sound/driver.h>
 #include <asm/io.h>
 #include <linux/delay.h>
-#include <linux/pci.h>
 #include <linux/pm.h>
 #include <linux/init.h>
 #include <linux/slab.h>

commit 746d4a02e68499fc6c1f8d0c43d2271853ade181
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 23 14:37:59 2006 +0200

    [ALSA] Fix disconnection of proc interface
    
    - Add the linked list to each proc entry to enable a single-shot
      disconnection (unregister)
    - Deprecate snd_info_unregister(), use snd_info_free_entry()
    - Removed NULL checks of snd_info_free_entry()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 5c9711c0265c..89c402770a1d 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -868,35 +868,23 @@ int cs46xx_dsp_proc_done (struct snd_cs46xx *chip)
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 	int i;
 
-	if (ins->proc_sym_info_entry) {
-		snd_info_unregister(ins->proc_sym_info_entry);
-		ins->proc_sym_info_entry = NULL;
-	}
-  
-	if (ins->proc_modules_info_entry) {
-		snd_info_unregister(ins->proc_modules_info_entry);
-		ins->proc_modules_info_entry = NULL;
-	}
- 
-	if (ins->proc_parameter_dump_info_entry) {
-		snd_info_unregister(ins->proc_parameter_dump_info_entry);
-		ins->proc_parameter_dump_info_entry = NULL;
-	}
-  
-	if (ins->proc_sample_dump_info_entry) {
-		snd_info_unregister(ins->proc_sample_dump_info_entry);
-		ins->proc_sample_dump_info_entry = NULL;
-	}
-  
-	if (ins->proc_scb_info_entry) {
-		snd_info_unregister(ins->proc_scb_info_entry);
-		ins->proc_scb_info_entry = NULL;
-	}
-  
-	if (ins->proc_task_info_entry) {
-		snd_info_unregister(ins->proc_task_info_entry);
-		ins->proc_task_info_entry = NULL;
-	}
+	snd_info_free_entry(ins->proc_sym_info_entry);
+	ins->proc_sym_info_entry = NULL;
+
+	snd_info_free_entry(ins->proc_modules_info_entry);
+	ins->proc_modules_info_entry = NULL;
+
+	snd_info_free_entry(ins->proc_parameter_dump_info_entry);
+	ins->proc_parameter_dump_info_entry = NULL;
+
+	snd_info_free_entry(ins->proc_sample_dump_info_entry);
+	ins->proc_sample_dump_info_entry = NULL;
+
+	snd_info_free_entry(ins->proc_scb_info_entry);
+	ins->proc_scb_info_entry = NULL;
+
+	snd_info_free_entry(ins->proc_task_info_entry);
+	ins->proc_task_info_entry = NULL;
 
 	mutex_lock(&chip->spos_mutex);
 	for (i = 0; i < ins->nscb; ++i) {
@@ -905,10 +893,8 @@ int cs46xx_dsp_proc_done (struct snd_cs46xx *chip)
 	}
 	mutex_unlock(&chip->spos_mutex);
 
-	if (ins->proc_dsp_dir) {
-		snd_info_unregister (ins->proc_dsp_dir);
-		ins->proc_dsp_dir = NULL;
-	}
+	snd_info_free_entry(ins->proc_dsp_dir);
+	ins->proc_dsp_dir = NULL;
 
 	return 0;
 }

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index f407d2a5ce3b..5c9711c0265c 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -767,7 +767,6 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 	if ((entry = snd_info_create_card_entry(card, "dsp", card->proc_root)) != NULL) {
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
-		entry->c.text.read_size = 512;
       
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
@@ -784,7 +783,6 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = chip;
 		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
-		entry->c.text.read_size = 512;
 		entry->c.text.read = cs46xx_dsp_proc_symbol_table_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
@@ -797,7 +795,6 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = chip;
 		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
-		entry->c.text.read_size = 512;
 		entry->c.text.read = cs46xx_dsp_proc_modules_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
@@ -810,7 +807,6 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = chip;
 		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
-		entry->c.text.read_size = 512;
 		entry->c.text.read = cs46xx_dsp_proc_parameter_dump_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
@@ -823,7 +819,6 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = chip;
 		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
-		entry->c.text.read_size = 512;
 		entry->c.text.read = cs46xx_dsp_proc_sample_dump_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
@@ -836,7 +831,6 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = chip;
 		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
-		entry->c.text.read_size = 512;
 		entry->c.text.read = cs46xx_dsp_proc_task_tree_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);
@@ -849,7 +843,6 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 		entry->content = SNDRV_INFO_CONTENT_TEXT;
 		entry->private_data = chip;
 		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
-		entry->c.text.read_size = 1024;
 		entry->c.text.read = cs46xx_dsp_proc_scb_read;
 		if (snd_info_register(entry) < 0) {
 			snd_info_free_entry(entry);

commit 202728d783a0fc180e7141d18186eeae167218a1
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Mar 14 09:44:19 2006 +0100

    [ALSA] fix some memory leaks
    
    Modules: Generic drivers,ES18xx driver,CS46xx driver
    
    This patch fixes two memory leaks spotted by the Coverity checker.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 8726a68051e7..f407d2a5ce3b 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -237,7 +237,7 @@ struct dsp_spos_instance *cs46xx_dsp_spos_create (struct snd_cs46xx * chip)
 
 	if (ins->symbol_table.symbols == NULL) {
 		cs46xx_dsp_spos_destroy(chip);
-		return NULL;
+		goto error;
 	}
 
 	ins->code.offset = 0;
@@ -246,7 +246,7 @@ struct dsp_spos_instance *cs46xx_dsp_spos_create (struct snd_cs46xx * chip)
 
 	if (ins->code.data == NULL) {
 		cs46xx_dsp_spos_destroy(chip);
-		return NULL;
+		goto error;
 	}
 
 	ins->nscb = 0;
@@ -257,7 +257,7 @@ struct dsp_spos_instance *cs46xx_dsp_spos_create (struct snd_cs46xx * chip)
 
 	if (ins->modules == NULL) {
 		cs46xx_dsp_spos_destroy(chip);
-		return NULL;
+		goto error;
 	}
 
 	/* default SPDIF input sample rate
@@ -280,6 +280,10 @@ struct dsp_spos_instance *cs46xx_dsp_spos_create (struct snd_cs46xx * chip)
 	 /* left and right validity bits */ (1 << 13) | (1 << 12);
 
 	return ins;
+
+error:
+	kfree(ins);
+	return NULL;
 }
 
 void  cs46xx_dsp_spos_destroy (struct snd_cs46xx * chip)

commit 62932df8fb20ba2fb53a95fa52445eba22e821fe
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:34:20 2006 +0100

    [ALSA] semaphore -> mutex (PCI part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index 445a448949e7..8726a68051e7 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -28,6 +28,8 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
+#include <linux/mutex.h>
+
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/info.h>
@@ -287,7 +289,7 @@ void  cs46xx_dsp_spos_destroy (struct snd_cs46xx * chip)
 
 	snd_assert(ins != NULL, return);
 
-	down(&chip->spos_mutex);
+	mutex_lock(&chip->spos_mutex);
 	for (i = 0; i < ins->nscb; ++i) {
 		if (ins->scbs[i].deleted) continue;
 
@@ -298,7 +300,7 @@ void  cs46xx_dsp_spos_destroy (struct snd_cs46xx * chip)
 	vfree(ins->symbol_table.symbols);
 	kfree(ins->modules);
 	kfree(ins);
-	up(&chip->spos_mutex);
+	mutex_unlock(&chip->spos_mutex);
 }
 
 int cs46xx_dsp_load_module (struct snd_cs46xx * chip, struct dsp_module_desc * module)
@@ -497,7 +499,7 @@ static void cs46xx_dsp_proc_modules_read (struct snd_info_entry *entry,
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 	int i,j;
 
-	down(&chip->spos_mutex);
+	mutex_lock(&chip->spos_mutex);
 	snd_iprintf(buffer, "MODULES:\n");
 	for ( i = 0; i < ins->nmodules; ++i ) {
 		snd_iprintf(buffer, "\n%s:\n", ins->modules[i].module_name);
@@ -510,7 +512,7 @@ static void cs46xx_dsp_proc_modules_read (struct snd_info_entry *entry,
 				    desc->segment_type,desc->offset, desc->size);
 		}
 	}
-	up(&chip->spos_mutex);
+	mutex_unlock(&chip->spos_mutex);
 }
 
 static void cs46xx_dsp_proc_task_tree_read (struct snd_info_entry *entry,
@@ -521,7 +523,7 @@ static void cs46xx_dsp_proc_task_tree_read (struct snd_info_entry *entry,
 	int i, j, col;
 	void __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;
 
-	down(&chip->spos_mutex);
+	mutex_lock(&chip->spos_mutex);
 	snd_iprintf(buffer, "TASK TREES:\n");
 	for ( i = 0; i < ins->ntask; ++i) {
 		snd_iprintf(buffer,"\n%04x %s:\n",ins->tasks[i].address,ins->tasks[i].task_name);
@@ -538,7 +540,7 @@ static void cs46xx_dsp_proc_task_tree_read (struct snd_info_entry *entry,
 	}
 
 	snd_iprintf(buffer,"\n");  
-	up(&chip->spos_mutex);
+	mutex_unlock(&chip->spos_mutex);
 }
 
 static void cs46xx_dsp_proc_scb_read (struct snd_info_entry *entry,
@@ -548,7 +550,7 @@ static void cs46xx_dsp_proc_scb_read (struct snd_info_entry *entry,
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 	int i;
 
-	down(&chip->spos_mutex);
+	mutex_lock(&chip->spos_mutex);
 	snd_iprintf(buffer, "SCB's:\n");
 	for ( i = 0; i < ins->nscb; ++i) {
 		if (ins->scbs[i].deleted)
@@ -571,7 +573,7 @@ static void cs46xx_dsp_proc_scb_read (struct snd_info_entry *entry,
 	}
 
 	snd_iprintf(buffer,"\n");
-	up(&chip->spos_mutex);
+	mutex_unlock(&chip->spos_mutex);
 }
 
 static void cs46xx_dsp_proc_parameter_dump_read (struct snd_info_entry *entry,
@@ -852,14 +854,14 @@ int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 	}
 	ins->proc_scb_info_entry = entry;
 
-	down(&chip->spos_mutex);
+	mutex_lock(&chip->spos_mutex);
 	/* register/update SCB's entries on proc */
 	for (i = 0; i < ins->nscb; ++i) {
 		if (ins->scbs[i].deleted) continue;
 
 		cs46xx_dsp_proc_register_scb_desc (chip, (ins->scbs + i));
 	}
-	up(&chip->spos_mutex);
+	mutex_unlock(&chip->spos_mutex);
 
 	return 0;
 }
@@ -899,12 +901,12 @@ int cs46xx_dsp_proc_done (struct snd_cs46xx *chip)
 		ins->proc_task_info_entry = NULL;
 	}
 
-	down(&chip->spos_mutex);
+	mutex_lock(&chip->spos_mutex);
 	for (i = 0; i < ins->nscb; ++i) {
 		if (ins->scbs[i].deleted) continue;
 		cs46xx_dsp_proc_free_scb_desc ( (ins->scbs + i) );
 	}
-	up(&chip->spos_mutex);
+	mutex_unlock(&chip->spos_mutex);
 
 	if (ins->proc_dsp_dir) {
 		snd_info_unregister (ins->proc_dsp_dir);
@@ -1694,7 +1696,7 @@ int cs46xx_dsp_enable_spdif_in (struct snd_cs46xx *chip)
 	snd_assert (ins->asynch_rx_scb == NULL,return -EINVAL);
 	snd_assert (ins->spdif_in_src != NULL,return -EINVAL);
 
-	down(&chip->spos_mutex);
+	mutex_lock(&chip->spos_mutex);
 
 	if ( ! (ins->spdif_status_out & DSP_SPDIF_STATUS_INPUT_CTRL_ENABLED) ) {
 		/* time countdown enable */
@@ -1738,7 +1740,7 @@ int cs46xx_dsp_enable_spdif_in (struct snd_cs46xx *chip)
 
 	/* monitor state */
 	ins->spdif_status_in = 1;
-	up(&chip->spos_mutex);
+	mutex_unlock(&chip->spos_mutex);
 
 	return 0;
 }
@@ -1750,7 +1752,7 @@ int cs46xx_dsp_disable_spdif_in (struct snd_cs46xx *chip)
 	snd_assert (ins->asynch_rx_scb != NULL, return -EINVAL);
 	snd_assert (ins->spdif_in_src != NULL,return -EINVAL);	
 
-	down(&chip->spos_mutex);
+	mutex_lock(&chip->spos_mutex);
 
 	/* Remove the asynchronous receiver SCB */
 	cs46xx_dsp_remove_scb (chip,ins->asynch_rx_scb);
@@ -1760,7 +1762,7 @@ int cs46xx_dsp_disable_spdif_in (struct snd_cs46xx *chip)
 
 	/* monitor state */
 	ins->spdif_status_in = 0;
-	up(&chip->spos_mutex);
+	mutex_unlock(&chip->spos_mutex);
 
 	/* restore amplifier */
 	chip->active_ctrl(chip, -1);
@@ -1776,10 +1778,10 @@ int cs46xx_dsp_enable_pcm_capture (struct snd_cs46xx *chip)
 	snd_assert (ins->pcm_input == NULL,return -EINVAL);
 	snd_assert (ins->ref_snoop_scb != NULL,return -EINVAL);
 
-	down(&chip->spos_mutex);
+	mutex_lock(&chip->spos_mutex);
 	ins->pcm_input = cs46xx_add_record_source(chip,ins->ref_snoop_scb,PCMSERIALIN_PCM_SCB_ADDR,
                                                   "PCMSerialInput_Wave");
-	up(&chip->spos_mutex);
+	mutex_unlock(&chip->spos_mutex);
 
 	return 0;
 }
@@ -1790,10 +1792,10 @@ int cs46xx_dsp_disable_pcm_capture (struct snd_cs46xx *chip)
 
 	snd_assert (ins->pcm_input != NULL,return -EINVAL);
 
-	down(&chip->spos_mutex);
+	mutex_lock(&chip->spos_mutex);
 	cs46xx_dsp_remove_scb (chip,ins->pcm_input);
 	ins->pcm_input = NULL;
-	up(&chip->spos_mutex);
+	mutex_unlock(&chip->spos_mutex);
 
 	return 0;
 }
@@ -1805,10 +1807,10 @@ int cs46xx_dsp_enable_adc_capture (struct snd_cs46xx *chip)
 	snd_assert (ins->adc_input == NULL,return -EINVAL);
 	snd_assert (ins->codec_in_scb != NULL,return -EINVAL);
 
-	down(&chip->spos_mutex);
+	mutex_lock(&chip->spos_mutex);
 	ins->adc_input = cs46xx_add_record_source(chip,ins->codec_in_scb,PCMSERIALIN_SCB_ADDR,
 						  "PCMSerialInput_ADC");
-	up(&chip->spos_mutex);
+	mutex_unlock(&chip->spos_mutex);
 
 	return 0;
 }
@@ -1819,10 +1821,10 @@ int cs46xx_dsp_disable_adc_capture (struct snd_cs46xx *chip)
 
 	snd_assert (ins->adc_input != NULL,return -EINVAL);
 
-	down(&chip->spos_mutex);
+	mutex_lock(&chip->spos_mutex);
 	cs46xx_dsp_remove_scb (chip,ins->adc_input);
 	ins->adc_input = NULL;
-	up(&chip->spos_mutex);
+	mutex_unlock(&chip->spos_mutex);
 
 	return 0;
 }
@@ -1869,7 +1871,7 @@ int cs46xx_dsp_set_dac_volume (struct snd_cs46xx * chip, u16 left, u16 right)
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 	struct dsp_scb_descriptor * scb; 
 
-	down(&chip->spos_mutex);
+	mutex_lock(&chip->spos_mutex);
 	
 	/* main output */
 	scb = ins->master_mix_scb->sub_list_ptr;
@@ -1888,7 +1890,7 @@ int cs46xx_dsp_set_dac_volume (struct snd_cs46xx * chip, u16 left, u16 right)
 	ins->dac_volume_left = left;
 	ins->dac_volume_right = right;
 
-	up(&chip->spos_mutex);
+	mutex_unlock(&chip->spos_mutex);
 
 	return 0;
 }
@@ -1897,7 +1899,7 @@ int cs46xx_dsp_set_iec958_volume (struct snd_cs46xx * chip, u16 left, u16 right)
 {
 	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
-	down(&chip->spos_mutex);
+	mutex_lock(&chip->spos_mutex);
 
 	if (ins->asynch_rx_scb != NULL)
 		cs46xx_dsp_scb_set_volume (chip,ins->asynch_rx_scb,
@@ -1906,7 +1908,7 @@ int cs46xx_dsp_set_iec958_volume (struct snd_cs46xx * chip, u16 left, u16 right)
 	ins->spdif_input_volume_left = left;
 	ins->spdif_input_volume_right = right;
 
-	up(&chip->spos_mutex);
+	mutex_unlock(&chip->spos_mutex);
 
 	return 0;
 }

commit adf1b3d25e50dbab48fdd21006bea2dd5a4cb3a8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 1 10:49:58 2005 +0100

    [ALSA] Optimize for config without PROC_FS (pci drivers)
    
    Optimize the code when compiled without CONFIG_PROC_FS for some pci drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index ac98917a1475..445a448949e7 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -439,6 +439,7 @@ cs46xx_dsp_lookup_symbol (struct snd_cs46xx * chip, char * symbol_name, int symb
 }
 
 
+#ifdef CONFIG_PROC_FS
 static struct dsp_symbol_entry *
 cs46xx_dsp_lookup_symbol_addr (struct snd_cs46xx * chip, u32 address, int symbol_type)
 {
@@ -912,6 +913,7 @@ int cs46xx_dsp_proc_done (struct snd_cs46xx *chip)
 
 	return 0;
 }
+#endif /* CONFIG_PROC_FS */
 
 static int debug_tree;
 static void _dsp_create_task_tree (struct snd_cs46xx *chip, u32 * task_data,

commit 3d19f804ef5f1d15fe001fc8d1ed58fac9d591fb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:48:14 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI CS46xx
    
    Modules: CS46xx driver
    
    Remove xxx_t typedefs from the PCI CS46xx driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
index b66304fc4e4a..ac98917a1475 100644
--- a/sound/pci/cs46xx/dsp_spos.c
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -37,9 +37,10 @@
 #include "cs46xx_lib.h"
 #include "dsp_spos.h"
 
-static int cs46xx_dsp_async_init (cs46xx_t *chip, dsp_scb_descriptor_t * fg_entry);
+static int cs46xx_dsp_async_init (struct snd_cs46xx *chip,
+				  struct dsp_scb_descriptor * fg_entry);
 
-static wide_opcode_t wide_opcodes[] = { 
+static enum wide_opcode wide_opcodes[] = { 
 	WIDE_FOR_BEGIN_LOOP,
 	WIDE_FOR_BEGIN_LOOP2,
 	WIDE_COND_GOTO_ADDR,
@@ -54,12 +55,13 @@ static wide_opcode_t wide_opcodes[] = {
 	WIDE_TBEQ_NCOND_CALL1_ADDR
 };
 
-static int shadow_and_reallocate_code (cs46xx_t * chip,u32 * data,u32 size, u32 overlay_begin_address)
+static int shadow_and_reallocate_code (struct snd_cs46xx * chip, u32 * data, u32 size,
+				       u32 overlay_begin_address)
 {
 	unsigned int i = 0, j, nreallocated = 0;
 	u32 hival,loval,address;
 	u32 mop_operands,mop_type,wide_op;
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
 	snd_assert( ((size % 2) == 0), return -EINVAL);
   
@@ -114,7 +116,7 @@ static int shadow_and_reallocate_code (cs46xx_t * chip,u32 * data,u32 size, u32
 	return nreallocated;
 }
 
-static segment_desc_t * get_segment_desc (dsp_module_desc_t * module, int seg_type)
+static struct dsp_segment_desc * get_segment_desc (struct dsp_module_desc * module, int seg_type)
 {
 	int i;
 	for (i = 0;i < module->nsegments; ++i) {
@@ -126,7 +128,7 @@ static segment_desc_t * get_segment_desc (dsp_module_desc_t * module, int seg_ty
 	return NULL;
 };
 
-static int find_free_symbol_index (dsp_spos_instance_t * ins)
+static int find_free_symbol_index (struct dsp_spos_instance * ins)
 {
 	int index = ins->symbol_table.nsymbols,i;
 
@@ -140,10 +142,10 @@ static int find_free_symbol_index (dsp_spos_instance_t * ins)
 	return index;
 }
 
-static int add_symbols (cs46xx_t * chip, dsp_module_desc_t * module)
+static int add_symbols (struct snd_cs46xx * chip, struct dsp_module_desc * module)
 {
 	int i;
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
 	if (module->symbol_table.nsymbols > 0) {
 		if (!strcmp(module->symbol_table.symbols[0].symbol_name, "OVERLAYBEGINADDRESS") &&
@@ -181,10 +183,11 @@ static int add_symbols (cs46xx_t * chip, dsp_module_desc_t * module)
 	return 0;
 }
 
-static symbol_entry_t * add_symbol (cs46xx_t * chip, char * symbol_name, u32 address, int type)
+static struct dsp_symbol_entry *
+add_symbol (struct snd_cs46xx * chip, char * symbol_name, u32 address, int type)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
-	symbol_entry_t * symbol = NULL;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
+	struct dsp_symbol_entry * symbol = NULL;
 	int index;
 
 	if (ins->symbol_table.nsymbols == (DSP_MAX_SYMBOLS - 1)) {
@@ -217,17 +220,17 @@ static symbol_entry_t * add_symbol (cs46xx_t * chip, char * symbol_name, u32 add
 	return symbol;
 }
 
-dsp_spos_instance_t *  cs46xx_dsp_spos_create (cs46xx_t * chip)
+struct dsp_spos_instance *cs46xx_dsp_spos_create (struct snd_cs46xx * chip)
 {
-	dsp_spos_instance_t * ins = kmalloc(sizeof(dsp_spos_instance_t), GFP_KERNEL);
+	struct dsp_spos_instance * ins = kzalloc(sizeof(struct dsp_spos_instance), GFP_KERNEL);
 
 	if (ins == NULL) 
 		return NULL;
-	memset(ins, 0, sizeof(*ins));
 
 	/* better to use vmalloc for this big table */
 	ins->symbol_table.nsymbols = 0;
-	ins->symbol_table.symbols = vmalloc(sizeof(symbol_entry_t) * DSP_MAX_SYMBOLS);
+	ins->symbol_table.symbols = vmalloc(sizeof(struct dsp_symbol_entry) *
+					    DSP_MAX_SYMBOLS);
 	ins->symbol_table.highest_frag_index = 0;
 
 	if (ins->symbol_table.symbols == NULL) {
@@ -248,7 +251,7 @@ dsp_spos_instance_t *  cs46xx_dsp_spos_create (cs46xx_t * chip)
 	ins->ntask = 0;
 
 	ins->nmodules = 0;
-	ins->modules = kmalloc(sizeof(dsp_module_desc_t) * DSP_MAX_MODULES, GFP_KERNEL);
+	ins->modules = kmalloc(sizeof(struct dsp_module_desc) * DSP_MAX_MODULES, GFP_KERNEL);
 
 	if (ins->modules == NULL) {
 		cs46xx_dsp_spos_destroy(chip);
@@ -277,10 +280,10 @@ dsp_spos_instance_t *  cs46xx_dsp_spos_create (cs46xx_t * chip)
 	return ins;
 }
 
-void  cs46xx_dsp_spos_destroy (cs46xx_t * chip)
+void  cs46xx_dsp_spos_destroy (struct snd_cs46xx * chip)
 {
 	int i;
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
 	snd_assert(ins != NULL, return);
 
@@ -298,12 +301,12 @@ void  cs46xx_dsp_spos_destroy (cs46xx_t * chip)
 	up(&chip->spos_mutex);
 }
 
-int cs46xx_dsp_load_module (cs46xx_t * chip, dsp_module_desc_t * module)
+int cs46xx_dsp_load_module (struct snd_cs46xx * chip, struct dsp_module_desc * module)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
-	segment_desc_t * code = get_segment_desc (module,SEGTYPE_SP_PROGRAM);
-	segment_desc_t * parameter = get_segment_desc (module,SEGTYPE_SP_PARAMETER);
-	segment_desc_t * sample = get_segment_desc (module,SEGTYPE_SP_SAMPLE);
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
+	struct dsp_segment_desc * code = get_segment_desc (module,SEGTYPE_SP_PROGRAM);
+	struct dsp_segment_desc * parameter = get_segment_desc (module,SEGTYPE_SP_PARAMETER);
+	struct dsp_segment_desc * sample = get_segment_desc (module,SEGTYPE_SP_SAMPLE);
 	u32 doffset, dsize;
 
 	if (ins->nmodules == DSP_MAX_MODULES - 1) {
@@ -410,10 +413,11 @@ int cs46xx_dsp_load_module (cs46xx_t * chip, dsp_module_desc_t * module)
 	return 0;
 }
 
-symbol_entry_t * cs46xx_dsp_lookup_symbol (cs46xx_t * chip, char * symbol_name, int symbol_type)
+struct dsp_symbol_entry *
+cs46xx_dsp_lookup_symbol (struct snd_cs46xx * chip, char * symbol_name, int symbol_type)
 {
 	int i;
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
 	for ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {
 
@@ -435,10 +439,11 @@ symbol_entry_t * cs46xx_dsp_lookup_symbol (cs46xx_t * chip, char * symbol_name,
 }
 
 
-static symbol_entry_t * cs46xx_dsp_lookup_symbol_addr (cs46xx_t * chip, u32 address, int symbol_type)
+static struct dsp_symbol_entry *
+cs46xx_dsp_lookup_symbol_addr (struct snd_cs46xx * chip, u32 address, int symbol_type)
 {
 	int i;
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
 	for ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {
 
@@ -456,10 +461,11 @@ static symbol_entry_t * cs46xx_dsp_lookup_symbol_addr (cs46xx_t * chip, u32 addr
 }
 
 
-static void cs46xx_dsp_proc_symbol_table_read (snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+static void cs46xx_dsp_proc_symbol_table_read (struct snd_info_entry *entry,
+					       struct snd_info_buffer *buffer)
 {
-	cs46xx_t *chip = entry->private_data;
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct snd_cs46xx *chip = entry->private_data;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 	int i;
 
 	snd_iprintf(buffer, "SYMBOLS:\n");
@@ -483,10 +489,11 @@ static void cs46xx_dsp_proc_symbol_table_read (snd_info_entry_t *entry, snd_info
 }
 
 
-static void cs46xx_dsp_proc_modules_read (snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+static void cs46xx_dsp_proc_modules_read (struct snd_info_entry *entry,
+					  struct snd_info_buffer *buffer)
 {
-	cs46xx_t *chip = entry->private_data;
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct snd_cs46xx *chip = entry->private_data;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 	int i,j;
 
 	down(&chip->spos_mutex);
@@ -497,7 +504,7 @@ static void cs46xx_dsp_proc_modules_read (snd_info_entry_t *entry, snd_info_buff
 		snd_iprintf(buffer, "   %d fixups\n", ins->modules[i].nfixups);
 
 		for (j = 0; j < ins->modules[i].nsegments; ++ j) {
-			segment_desc_t * desc = (ins->modules[i].segments + j);
+			struct dsp_segment_desc * desc = (ins->modules[i].segments + j);
 			snd_iprintf(buffer, "   segment %02x offset %08x size %08x\n",
 				    desc->segment_type,desc->offset, desc->size);
 		}
@@ -505,11 +512,12 @@ static void cs46xx_dsp_proc_modules_read (snd_info_entry_t *entry, snd_info_buff
 	up(&chip->spos_mutex);
 }
 
-static void cs46xx_dsp_proc_task_tree_read (snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+static void cs46xx_dsp_proc_task_tree_read (struct snd_info_entry *entry,
+					    struct snd_info_buffer *buffer)
 {
-	cs46xx_t *chip = entry->private_data;
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
-	int i,j,col;
+	struct snd_cs46xx *chip = entry->private_data;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
+	int i, j, col;
 	void __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;
 
 	down(&chip->spos_mutex);
@@ -532,10 +540,11 @@ static void cs46xx_dsp_proc_task_tree_read (snd_info_entry_t *entry, snd_info_bu
 	up(&chip->spos_mutex);
 }
 
-static void cs46xx_dsp_proc_scb_read (snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+static void cs46xx_dsp_proc_scb_read (struct snd_info_entry *entry,
+				      struct snd_info_buffer *buffer)
 {
-	cs46xx_t *chip = entry->private_data;
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct snd_cs46xx *chip = entry->private_data;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 	int i;
 
 	down(&chip->spos_mutex);
@@ -564,13 +573,14 @@ static void cs46xx_dsp_proc_scb_read (snd_info_entry_t *entry, snd_info_buffer_t
 	up(&chip->spos_mutex);
 }
 
-static void cs46xx_dsp_proc_parameter_dump_read (snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+static void cs46xx_dsp_proc_parameter_dump_read (struct snd_info_entry *entry,
+						 struct snd_info_buffer *buffer)
 {
-	cs46xx_t *chip = entry->private_data;
-	/*dsp_spos_instance_t * ins = chip->dsp_spos_instance; */
-	unsigned int i,col = 0;
+	struct snd_cs46xx *chip = entry->private_data;
+	/*struct dsp_spos_instance * ins = chip->dsp_spos_instance; */
+	unsigned int i, col = 0;
 	void __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;
-	symbol_entry_t * symbol; 
+	struct dsp_symbol_entry * symbol; 
 
 	for (i = 0;i < DSP_PARAMETER_BYTE_SIZE; i += sizeof(u32),col ++) {
 		if (col == 4) {
@@ -591,9 +601,10 @@ static void cs46xx_dsp_proc_parameter_dump_read (snd_info_entry_t *entry, snd_in
 	}
 }
 
-static void cs46xx_dsp_proc_sample_dump_read (snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+static void cs46xx_dsp_proc_sample_dump_read (struct snd_info_entry *entry,
+					      struct snd_info_buffer *buffer)
 {
-	cs46xx_t *chip = entry->private_data;
+	struct snd_cs46xx *chip = entry->private_data;
 	int i,col = 0;
 	void __iomem *dst = chip->region.idx[2].remap_addr;
 
@@ -738,10 +749,10 @@ static void cs46xx_dsp_proc_sample_dump_read (snd_info_entry_t *entry, snd_info_
 	snd_iprintf(buffer,"\n");
 }
 
-int cs46xx_dsp_proc_init (snd_card_t * card, cs46xx_t *chip)
+int cs46xx_dsp_proc_init (struct snd_card *card, struct snd_cs46xx *chip)
 {
-	snd_info_entry_t *entry;
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct snd_info_entry *entry;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 	int i;
 
 	ins->snd_card = card;
@@ -852,9 +863,9 @@ int cs46xx_dsp_proc_init (snd_card_t * card, cs46xx_t *chip)
 	return 0;
 }
 
-int cs46xx_dsp_proc_done (cs46xx_t *chip)
+int cs46xx_dsp_proc_done (struct snd_cs46xx *chip)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 	int i;
 
 	if (ins->proc_sym_info_entry) {
@@ -903,7 +914,8 @@ int cs46xx_dsp_proc_done (cs46xx_t *chip)
 }
 
 static int debug_tree;
-static void _dsp_create_task_tree (cs46xx_t *chip,u32 * task_data, u32  dest, int size)
+static void _dsp_create_task_tree (struct snd_cs46xx *chip, u32 * task_data,
+				   u32  dest, int size)
 {
 	void __iomem *spdst = chip->region.idx[1].remap_addr + 
 		DSP_PARAMETER_BYTE_OFFSET + dest * sizeof(u32);
@@ -917,7 +929,7 @@ static void _dsp_create_task_tree (cs46xx_t *chip,u32 * task_data, u32  dest, in
 }
 
 static int debug_scb;
-static void _dsp_create_scb (cs46xx_t *chip,u32 * scb_data, u32  dest)
+static void _dsp_create_scb (struct snd_cs46xx *chip, u32 * scb_data, u32 dest)
 {
 	void __iomem *spdst = chip->region.idx[1].remap_addr + 
 		DSP_PARAMETER_BYTE_OFFSET + dest * sizeof(u32);
@@ -930,7 +942,7 @@ static void _dsp_create_scb (cs46xx_t *chip,u32 * scb_data, u32  dest)
 	}
 }
 
-static int find_free_scb_index (dsp_spos_instance_t * ins)
+static int find_free_scb_index (struct dsp_spos_instance * ins)
 {
 	int index = ins->nscb, i;
 
@@ -944,10 +956,10 @@ static int find_free_scb_index (dsp_spos_instance_t * ins)
 	return index;
 }
 
-static dsp_scb_descriptor_t * _map_scb (cs46xx_t *chip,char * name,u32 dest)
+static struct dsp_scb_descriptor * _map_scb (struct snd_cs46xx *chip, char * name, u32 dest)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
-	dsp_scb_descriptor_t * desc = NULL;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
+	struct dsp_scb_descriptor * desc = NULL;
 	int index;
 
 	if (ins->nscb == DSP_MAX_SCB_DESC - 1) {
@@ -977,10 +989,11 @@ static dsp_scb_descriptor_t * _map_scb (cs46xx_t *chip,char * name,u32 dest)
 	return desc;
 }
 
-static dsp_task_descriptor_t * _map_task_tree (cs46xx_t *chip,char * name,u32 dest,u32 size)
+static struct dsp_task_descriptor *
+_map_task_tree (struct snd_cs46xx *chip, char * name, u32 dest, u32 size)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
-	dsp_task_descriptor_t * desc = NULL;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
+	struct dsp_task_descriptor * desc = NULL;
 
 	if (ins->ntask == DSP_MAX_TASK_DESC - 1) {
 		snd_printk(KERN_ERR "dsp_spos: got no place for other TASK\n");
@@ -1000,9 +1013,10 @@ static dsp_task_descriptor_t * _map_task_tree (cs46xx_t *chip,char * name,u32 de
 	return desc;
 }
 
-dsp_scb_descriptor_t * cs46xx_dsp_create_scb (cs46xx_t *chip,char * name, u32 * scb_data,u32 dest)
+struct dsp_scb_descriptor *
+cs46xx_dsp_create_scb (struct snd_cs46xx *chip, char * name, u32 * scb_data, u32 dest)
 {
-	dsp_scb_descriptor_t * desc;
+	struct dsp_scb_descriptor * desc;
 
 	desc = _map_scb (chip,name,dest);
 	if (desc) {
@@ -1015,9 +1029,11 @@ dsp_scb_descriptor_t * cs46xx_dsp_create_scb (cs46xx_t *chip,char * name, u32 *
 }
 
 
-static dsp_task_descriptor_t *  cs46xx_dsp_create_task_tree (cs46xx_t *chip,char * name, u32 * task_data,u32 dest,int size)
+static struct dsp_task_descriptor *
+cs46xx_dsp_create_task_tree (struct snd_cs46xx *chip, char * name, u32 * task_data,
+			     u32 dest, int size)
 {
-	dsp_task_descriptor_t * desc;
+	struct dsp_task_descriptor * desc;
 
 	desc = _map_task_tree (chip,name,dest,size);
 	if (desc) {
@@ -1029,31 +1045,31 @@ static dsp_task_descriptor_t *  cs46xx_dsp_create_task_tree (cs46xx_t *chip,char
 	return desc;
 }
 
-int cs46xx_dsp_scb_and_task_init (cs46xx_t *chip)
+int cs46xx_dsp_scb_and_task_init (struct snd_cs46xx *chip)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
-	symbol_entry_t * fg_task_tree_header_code;
-	symbol_entry_t * task_tree_header_code;
-	symbol_entry_t * task_tree_thread;
-	symbol_entry_t * null_algorithm;
-	symbol_entry_t * magic_snoop_task;
-
-	dsp_scb_descriptor_t * timing_master_scb;
-	dsp_scb_descriptor_t * codec_out_scb;
-	dsp_scb_descriptor_t * codec_in_scb;
-	dsp_scb_descriptor_t * src_task_scb;
-	dsp_scb_descriptor_t * master_mix_scb;
-	dsp_scb_descriptor_t * rear_mix_scb;
-	dsp_scb_descriptor_t * record_mix_scb;
-	dsp_scb_descriptor_t * write_back_scb;
-	dsp_scb_descriptor_t * vari_decimate_scb;
-	dsp_scb_descriptor_t * rear_codec_out_scb;
-	dsp_scb_descriptor_t * clfe_codec_out_scb;
-	dsp_scb_descriptor_t * magic_snoop_scb;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
+	struct dsp_symbol_entry * fg_task_tree_header_code;
+	struct dsp_symbol_entry * task_tree_header_code;
+	struct dsp_symbol_entry * task_tree_thread;
+	struct dsp_symbol_entry * null_algorithm;
+	struct dsp_symbol_entry * magic_snoop_task;
+
+	struct dsp_scb_descriptor * timing_master_scb;
+	struct dsp_scb_descriptor * codec_out_scb;
+	struct dsp_scb_descriptor * codec_in_scb;
+	struct dsp_scb_descriptor * src_task_scb;
+	struct dsp_scb_descriptor * master_mix_scb;
+	struct dsp_scb_descriptor * rear_mix_scb;
+	struct dsp_scb_descriptor * record_mix_scb;
+	struct dsp_scb_descriptor * write_back_scb;
+	struct dsp_scb_descriptor * vari_decimate_scb;
+	struct dsp_scb_descriptor * rear_codec_out_scb;
+	struct dsp_scb_descriptor * clfe_codec_out_scb;
+	struct dsp_scb_descriptor * magic_snoop_scb;
 	
-	int fifo_addr,fifo_span,valid_slots;
+	int fifo_addr, fifo_span, valid_slots;
 
-	static spos_control_block_t sposcb = {
+	static struct dsp_spos_control_block sposcb = {
 		/* 0 */ HFG_TREE_SCB,HFG_STACK,
 		/* 1 */ SPOSCB_ADDR,BG_TREE_SCB_ADDR,
 		/* 2 */ DSP_SPOS_DC,0,
@@ -1106,7 +1122,7 @@ int cs46xx_dsp_scb_and_task_init (cs46xx_t *chip)
   
 	{
 		/* create the null SCB */
-		static generic_scb_t null_scb = {
+		static struct dsp_generic_scb null_scb = {
 			{ 0, 0, 0, 0 },
 			{ 0, 0, 0, 0, 0 },
 			NULL_SCB_ADDR, NULL_SCB_ADDR,
@@ -1128,7 +1144,7 @@ int cs46xx_dsp_scb_and_task_init (cs46xx_t *chip)
 
 	{
 		/* setup foreground task tree */
-		static task_tree_control_block_t fg_task_tree_hdr =  {
+		static struct dsp_task_tree_control_block fg_task_tree_hdr =  {
 			{ FG_TASK_HEADER_ADDR | (DSP_SPOS_DC << 0x10),
 			  DSP_SPOS_DC_DC,
 			  DSP_SPOS_DC_DC,
@@ -1204,7 +1220,7 @@ int cs46xx_dsp_scb_and_task_init (cs46xx_t *chip)
 
 	{
 		/* setup foreground task tree */
-		static task_tree_control_block_t bg_task_tree_hdr =  {
+		static struct dsp_task_tree_control_block bg_task_tree_hdr =  {
 			{ DSP_SPOS_DC_DC,
 			  DSP_SPOS_DC_DC,
 			  DSP_SPOS_DC_DC,
@@ -1313,7 +1329,7 @@ int cs46xx_dsp_scb_and_task_init (cs46xx_t *chip)
 	if (!write_back_scb) goto _fail_end;
 
 	{
-		static mix2_ostream_spb_t mix2_ostream_spb = {
+		static struct dsp_mix2_ostream_spb mix2_ostream_spb = {
 			0x00020000,
 			0x0000ffff
 		};
@@ -1448,13 +1464,14 @@ int cs46xx_dsp_scb_and_task_init (cs46xx_t *chip)
 	return -EINVAL;
 }
 
-static int cs46xx_dsp_async_init (cs46xx_t *chip, dsp_scb_descriptor_t * fg_entry)
+static int cs46xx_dsp_async_init (struct snd_cs46xx *chip,
+				  struct dsp_scb_descriptor * fg_entry)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
-	symbol_entry_t * s16_async_codec_input_task;
-	symbol_entry_t * spdifo_task;
-	symbol_entry_t * spdifi_task;
-	dsp_scb_descriptor_t * spdifi_scb_desc,* spdifo_scb_desc,* async_codec_scb_desc;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
+	struct dsp_symbol_entry * s16_async_codec_input_task;
+	struct dsp_symbol_entry * spdifo_task;
+	struct dsp_symbol_entry * spdifi_task;
+	struct dsp_scb_descriptor * spdifi_scb_desc, * spdifo_scb_desc, * async_codec_scb_desc;
 
 	s16_async_codec_input_task = cs46xx_dsp_lookup_symbol(chip, "S16_ASYNCCODECINPUTTASK", SYMBOL_CODE);
 	if (s16_async_codec_input_task == NULL) {
@@ -1475,7 +1492,7 @@ static int cs46xx_dsp_async_init (cs46xx_t *chip, dsp_scb_descriptor_t * fg_entr
 
 	{
 		/* 0xBC0 */
-		spdifoscb_t spdifo_scb = {
+		struct dsp_spdifoscb spdifo_scb = {
 			/* 0 */ DSP_SPOS_UUUU,
 			{
 				/* 1 */ 0xb0, 
@@ -1504,7 +1521,7 @@ static int cs46xx_dsp_async_init (cs46xx_t *chip, dsp_scb_descriptor_t * fg_entr
 		};
 
 		/* 0xBB0 */
-		spdifiscb_t spdifi_scb = {
+		struct dsp_spdifiscb spdifi_scb = {
 			/* 0 */ DSP_SPOS_UULO,DSP_SPOS_UUHI,
 			/* 1 */ 0,
 			/* 2 */ 0,
@@ -1529,7 +1546,7 @@ static int cs46xx_dsp_async_init (cs46xx_t *chip, dsp_scb_descriptor_t * fg_entr
 		};
 
 		/* 0xBA0 */
-		async_codec_input_scb_t async_codec_input_scb = {
+		struct dsp_async_codec_input_scb async_codec_input_scb = {
 			/* 0 */ DSP_SPOS_UUUU,
 			/* 1 */ 0,
 			/* 2 */ 0,
@@ -1620,9 +1637,9 @@ static int cs46xx_dsp_async_init (cs46xx_t *chip, dsp_scb_descriptor_t * fg_entr
 }
 
 
-static void cs46xx_dsp_disable_spdif_hw (cs46xx_t *chip)
+static void cs46xx_dsp_disable_spdif_hw (struct snd_cs46xx *chip)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
 	/* set SPDIF output FIFO slot */
 	snd_cs46xx_pokeBA0(chip, BA0_ASER_FADDR, 0);
@@ -1641,9 +1658,9 @@ static void cs46xx_dsp_disable_spdif_hw (cs46xx_t *chip)
 	ins->spdif_status_out &= ~DSP_SPDIF_STATUS_HW_ENABLED;
 }
 
-int cs46xx_dsp_enable_spdif_hw (cs46xx_t *chip)
+int cs46xx_dsp_enable_spdif_hw (struct snd_cs46xx *chip)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
 	/* if hw-ctrl already enabled, turn off to reset logic ... */
 	cs46xx_dsp_disable_spdif_hw (chip);
@@ -1664,9 +1681,9 @@ int cs46xx_dsp_enable_spdif_hw (cs46xx_t *chip)
 	return 0;
 }
 
-int cs46xx_dsp_enable_spdif_in (cs46xx_t *chip)
+int cs46xx_dsp_enable_spdif_in (struct snd_cs46xx *chip)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
 	/* turn on amplifier */
 	chip->active_ctrl(chip, 1);
@@ -1724,9 +1741,9 @@ int cs46xx_dsp_enable_spdif_in (cs46xx_t *chip)
 	return 0;
 }
 
-int cs46xx_dsp_disable_spdif_in (cs46xx_t *chip)
+int cs46xx_dsp_disable_spdif_in (struct snd_cs46xx *chip)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
 	snd_assert (ins->asynch_rx_scb != NULL, return -EINVAL);
 	snd_assert (ins->spdif_in_src != NULL,return -EINVAL);	
@@ -1750,9 +1767,9 @@ int cs46xx_dsp_disable_spdif_in (cs46xx_t *chip)
 	return 0;
 }
 
-int cs46xx_dsp_enable_pcm_capture (cs46xx_t *chip)
+int cs46xx_dsp_enable_pcm_capture (struct snd_cs46xx *chip)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
 	snd_assert (ins->pcm_input == NULL,return -EINVAL);
 	snd_assert (ins->ref_snoop_scb != NULL,return -EINVAL);
@@ -1765,9 +1782,9 @@ int cs46xx_dsp_enable_pcm_capture (cs46xx_t *chip)
 	return 0;
 }
 
-int cs46xx_dsp_disable_pcm_capture (cs46xx_t *chip)
+int cs46xx_dsp_disable_pcm_capture (struct snd_cs46xx *chip)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
 	snd_assert (ins->pcm_input != NULL,return -EINVAL);
 
@@ -1779,9 +1796,9 @@ int cs46xx_dsp_disable_pcm_capture (cs46xx_t *chip)
 	return 0;
 }
 
-int cs46xx_dsp_enable_adc_capture (cs46xx_t *chip)
+int cs46xx_dsp_enable_adc_capture (struct snd_cs46xx *chip)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
 	snd_assert (ins->adc_input == NULL,return -EINVAL);
 	snd_assert (ins->codec_in_scb != NULL,return -EINVAL);
@@ -1794,9 +1811,9 @@ int cs46xx_dsp_enable_adc_capture (cs46xx_t *chip)
 	return 0;
 }
 
-int cs46xx_dsp_disable_adc_capture (cs46xx_t *chip)
+int cs46xx_dsp_disable_adc_capture (struct snd_cs46xx *chip)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
 	snd_assert (ins->adc_input != NULL,return -EINVAL);
 
@@ -1808,7 +1825,7 @@ int cs46xx_dsp_disable_adc_capture (cs46xx_t *chip)
 	return 0;
 }
 
-int cs46xx_poke_via_dsp (cs46xx_t *chip,u32 address,u32 data)
+int cs46xx_poke_via_dsp (struct snd_cs46xx *chip, u32 address, u32 data)
 {
 	u32 temp;
 	int  i;
@@ -1845,10 +1862,10 @@ int cs46xx_poke_via_dsp (cs46xx_t *chip,u32 address,u32 data)
 	return 0;
 }
 
-int cs46xx_dsp_set_dac_volume (cs46xx_t * chip,u16 left,u16 right)
+int cs46xx_dsp_set_dac_volume (struct snd_cs46xx * chip, u16 left, u16 right)
 {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
-	dsp_scb_descriptor_t * scb; 
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
+	struct dsp_scb_descriptor * scb; 
 
 	down(&chip->spos_mutex);
 	
@@ -1874,8 +1891,9 @@ int cs46xx_dsp_set_dac_volume (cs46xx_t * chip,u16 left,u16 right)
 	return 0;
 }
 
-int cs46xx_dsp_set_iec958_volume (cs46xx_t * chip,u16 left,u16 right) {
-	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+int cs46xx_dsp_set_iec958_volume (struct snd_cs46xx * chip, u16 left, u16 right)
+{
+	struct dsp_spos_instance * ins = chip->dsp_spos_instance;
 
 	down(&chip->spos_mutex);
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/cs46xx/dsp_spos.c b/sound/pci/cs46xx/dsp_spos.c
new file mode 100644
index 000000000000..b66304fc4e4a
--- /dev/null
+++ b/sound/pci/cs46xx/dsp_spos.c
@@ -0,0 +1,1892 @@
+/*
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+/*
+ * 2002-07 Benny Sjostrand benny@hostmobility.com
+ */
+
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/info.h>
+#include <sound/asoundef.h>
+#include <sound/cs46xx.h>
+
+#include "cs46xx_lib.h"
+#include "dsp_spos.h"
+
+static int cs46xx_dsp_async_init (cs46xx_t *chip, dsp_scb_descriptor_t * fg_entry);
+
+static wide_opcode_t wide_opcodes[] = { 
+	WIDE_FOR_BEGIN_LOOP,
+	WIDE_FOR_BEGIN_LOOP2,
+	WIDE_COND_GOTO_ADDR,
+	WIDE_COND_GOTO_CALL,
+	WIDE_TBEQ_COND_GOTO_ADDR,
+	WIDE_TBEQ_COND_CALL_ADDR,
+	WIDE_TBEQ_NCOND_GOTO_ADDR,
+	WIDE_TBEQ_NCOND_CALL_ADDR,
+	WIDE_TBEQ_COND_GOTO1_ADDR,
+	WIDE_TBEQ_COND_CALL1_ADDR,
+	WIDE_TBEQ_NCOND_GOTOI_ADDR,
+	WIDE_TBEQ_NCOND_CALL1_ADDR
+};
+
+static int shadow_and_reallocate_code (cs46xx_t * chip,u32 * data,u32 size, u32 overlay_begin_address)
+{
+	unsigned int i = 0, j, nreallocated = 0;
+	u32 hival,loval,address;
+	u32 mop_operands,mop_type,wide_op;
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+
+	snd_assert( ((size % 2) == 0), return -EINVAL);
+  
+	while (i < size) {
+		loval = data[i++];
+		hival = data[i++];
+
+		if (ins->code.offset > 0) {
+			mop_operands = (hival >> 6) & 0x03fff;
+			mop_type = mop_operands >> 10;
+      
+			/* check for wide type instruction */
+			if (mop_type == 0 &&
+			    (mop_operands & WIDE_LADD_INSTR_MASK) == 0 &&
+			    (mop_operands & WIDE_INSTR_MASK) != 0) {
+				wide_op = loval & 0x7f;
+				for (j = 0;j < ARRAY_SIZE(wide_opcodes); ++j) {
+					if (wide_opcodes[j] == wide_op) {
+						/* need to reallocate instruction */
+						address  = (hival & 0x00FFF) << 5;
+						address |=  loval >> 15;
+            
+						snd_printdd("handle_wideop[1]: %05x:%05x addr %04x\n",hival,loval,address);
+            
+						if ( !(address & 0x8000) ) {
+							address += (ins->code.offset / 2) - overlay_begin_address;
+						} else {
+							snd_printdd("handle_wideop[1]: ROM symbol not reallocated\n");
+						}
+            
+						hival &= 0xFF000;
+						loval &= 0x07FFF;
+            
+						hival |= ( (address >> 5)  & 0x00FFF);
+						loval |= ( (address << 15) & 0xF8000);
+            
+						address  = (hival & 0x00FFF) << 5;
+						address |=  loval >> 15;
+            
+						snd_printdd("handle_wideop:[2] %05x:%05x addr %04x\n",hival,loval,address);            
+						nreallocated ++;
+					} /* wide_opcodes[j] == wide_op */
+				} /* for */
+			} /* mod_type == 0 ... */
+		} /* ins->code.offset > 0 */
+
+		ins->code.data[ins->code.size++] = loval;
+		ins->code.data[ins->code.size++] = hival;
+	}
+
+	snd_printdd("dsp_spos: %d instructions reallocated\n",nreallocated);
+	return nreallocated;
+}
+
+static segment_desc_t * get_segment_desc (dsp_module_desc_t * module, int seg_type)
+{
+	int i;
+	for (i = 0;i < module->nsegments; ++i) {
+		if (module->segments[i].segment_type == seg_type) {
+			return (module->segments + i);
+		}
+	}
+
+	return NULL;
+};
+
+static int find_free_symbol_index (dsp_spos_instance_t * ins)
+{
+	int index = ins->symbol_table.nsymbols,i;
+
+	for (i = ins->symbol_table.highest_frag_index; i < ins->symbol_table.nsymbols; ++i) {
+		if (ins->symbol_table.symbols[i].deleted) {
+			index = i;
+			break;
+		}
+	}
+
+	return index;
+}
+
+static int add_symbols (cs46xx_t * chip, dsp_module_desc_t * module)
+{
+	int i;
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+
+	if (module->symbol_table.nsymbols > 0) {
+		if (!strcmp(module->symbol_table.symbols[0].symbol_name, "OVERLAYBEGINADDRESS") &&
+		    module->symbol_table.symbols[0].symbol_type == SYMBOL_CONSTANT ) {
+			module->overlay_begin_address = module->symbol_table.symbols[0].address;
+		}
+	}
+
+	for (i = 0;i < module->symbol_table.nsymbols; ++i) {
+		if (ins->symbol_table.nsymbols == (DSP_MAX_SYMBOLS - 1)) {
+			snd_printk(KERN_ERR "dsp_spos: symbol table is full\n");
+			return -ENOMEM;
+		}
+
+
+		if (cs46xx_dsp_lookup_symbol(chip,
+					     module->symbol_table.symbols[i].symbol_name,
+					     module->symbol_table.symbols[i].symbol_type) == NULL) {
+
+			ins->symbol_table.symbols[ins->symbol_table.nsymbols] = module->symbol_table.symbols[i];
+			ins->symbol_table.symbols[ins->symbol_table.nsymbols].address += ((ins->code.offset / 2) - module->overlay_begin_address);
+			ins->symbol_table.symbols[ins->symbol_table.nsymbols].module = module;
+			ins->symbol_table.symbols[ins->symbol_table.nsymbols].deleted = 0;
+
+			if (ins->symbol_table.nsymbols > ins->symbol_table.highest_frag_index) 
+				ins->symbol_table.highest_frag_index = ins->symbol_table.nsymbols;
+
+			ins->symbol_table.nsymbols++;
+		} else {
+          /* if (0) printk ("dsp_spos: symbol <%s> duplicated, probably nothing wrong with that (Cirrus?)\n",
+                             module->symbol_table.symbols[i].symbol_name); */
+		}
+	}
+
+	return 0;
+}
+
+static symbol_entry_t * add_symbol (cs46xx_t * chip, char * symbol_name, u32 address, int type)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	symbol_entry_t * symbol = NULL;
+	int index;
+
+	if (ins->symbol_table.nsymbols == (DSP_MAX_SYMBOLS - 1)) {
+		snd_printk(KERN_ERR "dsp_spos: symbol table is full\n");
+		return NULL;
+	}
+  
+	if (cs46xx_dsp_lookup_symbol(chip,
+				     symbol_name,
+				     type) != NULL) {
+		snd_printk(KERN_ERR "dsp_spos: symbol <%s> duplicated\n", symbol_name);
+		return NULL;
+	}
+
+	index = find_free_symbol_index (ins);
+
+	strcpy (ins->symbol_table.symbols[index].symbol_name, symbol_name);
+	ins->symbol_table.symbols[index].address = address;
+	ins->symbol_table.symbols[index].symbol_type = type;
+	ins->symbol_table.symbols[index].module = NULL;
+	ins->symbol_table.symbols[index].deleted = 0;
+	symbol = (ins->symbol_table.symbols + index);
+
+	if (index > ins->symbol_table.highest_frag_index) 
+		ins->symbol_table.highest_frag_index = index;
+
+	if (index == ins->symbol_table.nsymbols)
+		ins->symbol_table.nsymbols++; /* no frag. in list */
+
+	return symbol;
+}
+
+dsp_spos_instance_t *  cs46xx_dsp_spos_create (cs46xx_t * chip)
+{
+	dsp_spos_instance_t * ins = kmalloc(sizeof(dsp_spos_instance_t), GFP_KERNEL);
+
+	if (ins == NULL) 
+		return NULL;
+	memset(ins, 0, sizeof(*ins));
+
+	/* better to use vmalloc for this big table */
+	ins->symbol_table.nsymbols = 0;
+	ins->symbol_table.symbols = vmalloc(sizeof(symbol_entry_t) * DSP_MAX_SYMBOLS);
+	ins->symbol_table.highest_frag_index = 0;
+
+	if (ins->symbol_table.symbols == NULL) {
+		cs46xx_dsp_spos_destroy(chip);
+		return NULL;
+	}
+
+	ins->code.offset = 0;
+	ins->code.size = 0;
+	ins->code.data = kmalloc(DSP_CODE_BYTE_SIZE, GFP_KERNEL);
+
+	if (ins->code.data == NULL) {
+		cs46xx_dsp_spos_destroy(chip);
+		return NULL;
+	}
+
+	ins->nscb = 0;
+	ins->ntask = 0;
+
+	ins->nmodules = 0;
+	ins->modules = kmalloc(sizeof(dsp_module_desc_t) * DSP_MAX_MODULES, GFP_KERNEL);
+
+	if (ins->modules == NULL) {
+		cs46xx_dsp_spos_destroy(chip);
+		return NULL;
+	}
+
+	/* default SPDIF input sample rate
+	   to 48000 khz */
+	ins->spdif_in_sample_rate = 48000;
+
+	/* maximize volume */
+	ins->dac_volume_right = 0x8000;
+	ins->dac_volume_left = 0x8000;
+	ins->spdif_input_volume_right = 0x8000;
+	ins->spdif_input_volume_left = 0x8000;
+
+	/* set left and right validity bits and
+	   default channel status */
+	ins->spdif_csuv_default = 
+		ins->spdif_csuv_stream =  
+	 /* byte 0 */  ((unsigned int)_wrap_all_bits(  (SNDRV_PCM_DEFAULT_CON_SPDIF        & 0xff)) << 24) |
+	 /* byte 1 */  ((unsigned int)_wrap_all_bits( ((SNDRV_PCM_DEFAULT_CON_SPDIF >> 8) & 0xff)) << 16) |
+	 /* byte 3 */   (unsigned int)_wrap_all_bits(  (SNDRV_PCM_DEFAULT_CON_SPDIF >> 24) & 0xff) |
+	 /* left and right validity bits */ (1 << 13) | (1 << 12);
+
+	return ins;
+}
+
+void  cs46xx_dsp_spos_destroy (cs46xx_t * chip)
+{
+	int i;
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+
+	snd_assert(ins != NULL, return);
+
+	down(&chip->spos_mutex);
+	for (i = 0; i < ins->nscb; ++i) {
+		if (ins->scbs[i].deleted) continue;
+
+		cs46xx_dsp_proc_free_scb_desc ( (ins->scbs + i) );
+	}
+
+	kfree(ins->code.data);
+	vfree(ins->symbol_table.symbols);
+	kfree(ins->modules);
+	kfree(ins);
+	up(&chip->spos_mutex);
+}
+
+int cs46xx_dsp_load_module (cs46xx_t * chip, dsp_module_desc_t * module)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	segment_desc_t * code = get_segment_desc (module,SEGTYPE_SP_PROGRAM);
+	segment_desc_t * parameter = get_segment_desc (module,SEGTYPE_SP_PARAMETER);
+	segment_desc_t * sample = get_segment_desc (module,SEGTYPE_SP_SAMPLE);
+	u32 doffset, dsize;
+
+	if (ins->nmodules == DSP_MAX_MODULES - 1) {
+		snd_printk(KERN_ERR "dsp_spos: to many modules loaded into DSP\n");
+		return -ENOMEM;
+	}
+
+	snd_printdd("dsp_spos: loading module %s into DSP\n", module->module_name);
+  
+	if (ins->nmodules == 0) {
+		snd_printdd("dsp_spos: clearing parameter area\n");
+		snd_cs46xx_clear_BA1(chip, DSP_PARAMETER_BYTE_OFFSET, DSP_PARAMETER_BYTE_SIZE);
+	}
+  
+	if (parameter == NULL) {
+		snd_printdd("dsp_spos: module got no parameter segment\n");
+	} else {
+		if (ins->nmodules > 0) {
+			snd_printk(KERN_WARNING "dsp_spos: WARNING current parameter data may be overwriten!\n");
+		}
+
+		doffset = (parameter->offset * 4 + DSP_PARAMETER_BYTE_OFFSET);
+		dsize   = parameter->size * 4;
+
+		snd_printdd("dsp_spos: downloading parameter data to chip (%08x-%08x)\n",
+			    doffset,doffset + dsize);
+
+		if (snd_cs46xx_download (chip, parameter->data, doffset, dsize)) {
+			snd_printk(KERN_ERR "dsp_spos: failed to download parameter data to DSP\n");
+			return -EINVAL;
+		}
+	}
+
+	if (ins->nmodules == 0) {
+		snd_printdd("dsp_spos: clearing sample area\n");
+		snd_cs46xx_clear_BA1(chip, DSP_SAMPLE_BYTE_OFFSET, DSP_SAMPLE_BYTE_SIZE);
+	}
+
+	if (sample == NULL) {
+		snd_printdd("dsp_spos: module got no sample segment\n");
+	} else {
+		if (ins->nmodules > 0) {
+			snd_printk(KERN_WARNING "dsp_spos: WARNING current sample data may be overwriten\n");
+		}
+
+		doffset = (sample->offset * 4  + DSP_SAMPLE_BYTE_OFFSET);
+		dsize   =  sample->size * 4;
+
+		snd_printdd("dsp_spos: downloading sample data to chip (%08x-%08x)\n",
+			    doffset,doffset + dsize);
+
+		if (snd_cs46xx_download (chip,sample->data,doffset,dsize)) {
+			snd_printk(KERN_ERR "dsp_spos: failed to sample data to DSP\n");
+			return -EINVAL;
+		}
+	}
+
+
+	if (ins->nmodules == 0) {
+		snd_printdd("dsp_spos: clearing code area\n");
+		snd_cs46xx_clear_BA1(chip, DSP_CODE_BYTE_OFFSET, DSP_CODE_BYTE_SIZE);
+	}
+
+	if (code == NULL) {
+		snd_printdd("dsp_spos: module got no code segment\n");
+	} else {
+		if (ins->code.offset + code->size > DSP_CODE_BYTE_SIZE) {
+			snd_printk(KERN_ERR "dsp_spos: no space available in DSP\n");
+			return -ENOMEM;
+		}
+
+		module->load_address = ins->code.offset;
+		module->overlay_begin_address = 0x000;
+
+		/* if module has a code segment it must have
+		   symbol table */
+		snd_assert(module->symbol_table.symbols != NULL ,return -ENOMEM);
+		if (add_symbols(chip,module)) {
+			snd_printk(KERN_ERR "dsp_spos: failed to load symbol table\n");
+			return -ENOMEM;
+		}
+    
+		doffset = (code->offset * 4 + ins->code.offset * 4 + DSP_CODE_BYTE_OFFSET);
+		dsize   = code->size * 4;
+		snd_printdd("dsp_spos: downloading code to chip (%08x-%08x)\n",
+			    doffset,doffset + dsize);   
+
+		module->nfixups = shadow_and_reallocate_code(chip,code->data,code->size,module->overlay_begin_address);
+
+		if (snd_cs46xx_download (chip,(ins->code.data + ins->code.offset),doffset,dsize)) {
+			snd_printk(KERN_ERR "dsp_spos: failed to download code to DSP\n");
+			return -EINVAL;
+		}
+
+		ins->code.offset += code->size;
+	}
+
+	/* NOTE: module segments and symbol table must be
+	   statically allocated. Case that module data is
+	   not generated by the ospparser */
+	ins->modules[ins->nmodules] = *module;
+	ins->nmodules++;
+
+	return 0;
+}
+
+symbol_entry_t * cs46xx_dsp_lookup_symbol (cs46xx_t * chip, char * symbol_name, int symbol_type)
+{
+	int i;
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+
+	for ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {
+
+		if (ins->symbol_table.symbols[i].deleted)
+			continue;
+
+		if (!strcmp(ins->symbol_table.symbols[i].symbol_name,symbol_name) &&
+		    ins->symbol_table.symbols[i].symbol_type == symbol_type) {
+			return (ins->symbol_table.symbols + i);
+		}
+	}
+
+#if 0
+	printk ("dsp_spos: symbol <%s> type %02x not found\n",
+		symbol_name,symbol_type);
+#endif
+
+	return NULL;
+}
+
+
+static symbol_entry_t * cs46xx_dsp_lookup_symbol_addr (cs46xx_t * chip, u32 address, int symbol_type)
+{
+	int i;
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+
+	for ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {
+
+		if (ins->symbol_table.symbols[i].deleted)
+			continue;
+
+		if (ins->symbol_table.symbols[i].address == address &&
+		    ins->symbol_table.symbols[i].symbol_type == symbol_type) {
+			return (ins->symbol_table.symbols + i);
+		}
+	}
+
+
+	return NULL;
+}
+
+
+static void cs46xx_dsp_proc_symbol_table_read (snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+{
+	cs46xx_t *chip = entry->private_data;
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	int i;
+
+	snd_iprintf(buffer, "SYMBOLS:\n");
+	for ( i = 0; i < ins->symbol_table.nsymbols; ++i ) {
+		char *module_str = "system";
+
+		if (ins->symbol_table.symbols[i].deleted)
+			continue;
+
+		if (ins->symbol_table.symbols[i].module != NULL) {
+			module_str = ins->symbol_table.symbols[i].module->module_name;
+		}
+
+    
+		snd_iprintf(buffer, "%04X <%02X> %s [%s]\n",
+			    ins->symbol_table.symbols[i].address,
+			    ins->symbol_table.symbols[i].symbol_type,
+			    ins->symbol_table.symbols[i].symbol_name,
+			    module_str);    
+	}
+}
+
+
+static void cs46xx_dsp_proc_modules_read (snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+{
+	cs46xx_t *chip = entry->private_data;
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	int i,j;
+
+	down(&chip->spos_mutex);
+	snd_iprintf(buffer, "MODULES:\n");
+	for ( i = 0; i < ins->nmodules; ++i ) {
+		snd_iprintf(buffer, "\n%s:\n", ins->modules[i].module_name);
+		snd_iprintf(buffer, "   %d symbols\n", ins->modules[i].symbol_table.nsymbols);
+		snd_iprintf(buffer, "   %d fixups\n", ins->modules[i].nfixups);
+
+		for (j = 0; j < ins->modules[i].nsegments; ++ j) {
+			segment_desc_t * desc = (ins->modules[i].segments + j);
+			snd_iprintf(buffer, "   segment %02x offset %08x size %08x\n",
+				    desc->segment_type,desc->offset, desc->size);
+		}
+	}
+	up(&chip->spos_mutex);
+}
+
+static void cs46xx_dsp_proc_task_tree_read (snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+{
+	cs46xx_t *chip = entry->private_data;
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	int i,j,col;
+	void __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;
+
+	down(&chip->spos_mutex);
+	snd_iprintf(buffer, "TASK TREES:\n");
+	for ( i = 0; i < ins->ntask; ++i) {
+		snd_iprintf(buffer,"\n%04x %s:\n",ins->tasks[i].address,ins->tasks[i].task_name);
+
+		for (col = 0,j = 0;j < ins->tasks[i].size; j++,col++) {
+			u32 val;
+			if (col == 4) {
+				snd_iprintf(buffer,"\n");
+				col = 0;
+			}
+			val = readl(dst + (ins->tasks[i].address + j) * sizeof(u32));
+			snd_iprintf(buffer,"%08x ",val);
+		}
+	}
+
+	snd_iprintf(buffer,"\n");  
+	up(&chip->spos_mutex);
+}
+
+static void cs46xx_dsp_proc_scb_read (snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+{
+	cs46xx_t *chip = entry->private_data;
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	int i;
+
+	down(&chip->spos_mutex);
+	snd_iprintf(buffer, "SCB's:\n");
+	for ( i = 0; i < ins->nscb; ++i) {
+		if (ins->scbs[i].deleted)
+			continue;
+		snd_iprintf(buffer,"\n%04x %s:\n\n",ins->scbs[i].address,ins->scbs[i].scb_name);
+
+		if (ins->scbs[i].parent_scb_ptr != NULL) {
+			snd_iprintf(buffer,"parent [%s:%04x] ", 
+				    ins->scbs[i].parent_scb_ptr->scb_name,
+				    ins->scbs[i].parent_scb_ptr->address);
+		} else snd_iprintf(buffer,"parent [none] ");
+
+		snd_iprintf(buffer,"sub_list_ptr [%s:%04x]\nnext_scb_ptr [%s:%04x]  task_entry [%s:%04x]\n",
+			    ins->scbs[i].sub_list_ptr->scb_name,
+			    ins->scbs[i].sub_list_ptr->address,
+			    ins->scbs[i].next_scb_ptr->scb_name,
+			    ins->scbs[i].next_scb_ptr->address,
+			    ins->scbs[i].task_entry->symbol_name,
+			    ins->scbs[i].task_entry->address);
+	}
+
+	snd_iprintf(buffer,"\n");
+	up(&chip->spos_mutex);
+}
+
+static void cs46xx_dsp_proc_parameter_dump_read (snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+{
+	cs46xx_t *chip = entry->private_data;
+	/*dsp_spos_instance_t * ins = chip->dsp_spos_instance; */
+	unsigned int i,col = 0;
+	void __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;
+	symbol_entry_t * symbol; 
+
+	for (i = 0;i < DSP_PARAMETER_BYTE_SIZE; i += sizeof(u32),col ++) {
+		if (col == 4) {
+			snd_iprintf(buffer,"\n");
+			col = 0;
+		}
+
+		if ( (symbol = cs46xx_dsp_lookup_symbol_addr (chip,i / sizeof(u32), SYMBOL_PARAMETER)) != NULL) {
+			col = 0;
+			snd_iprintf (buffer,"\n%s:\n",symbol->symbol_name);
+		}
+
+		if (col == 0) {
+			snd_iprintf(buffer, "%04X ", i / (unsigned int)sizeof(u32));
+		}
+
+		snd_iprintf(buffer,"%08X ",readl(dst + i));
+	}
+}
+
+static void cs46xx_dsp_proc_sample_dump_read (snd_info_entry_t *entry, snd_info_buffer_t * buffer)
+{
+	cs46xx_t *chip = entry->private_data;
+	int i,col = 0;
+	void __iomem *dst = chip->region.idx[2].remap_addr;
+
+	snd_iprintf(buffer,"PCMREADER:\n");
+	for (i = PCM_READER_BUF1;i < PCM_READER_BUF1 + 0x30; i += sizeof(u32),col ++) {
+		if (col == 4) {
+			snd_iprintf(buffer,"\n");
+			col = 0;
+		}
+
+		if (col == 0) {
+			snd_iprintf(buffer, "%04X ",i);
+		}
+
+		snd_iprintf(buffer,"%08X ",readl(dst + i));
+	}
+
+	snd_iprintf(buffer,"\nMIX_SAMPLE_BUF1:\n");
+
+	col = 0;
+	for (i = MIX_SAMPLE_BUF1;i < MIX_SAMPLE_BUF1 + 0x40; i += sizeof(u32),col ++) {
+		if (col == 4) {
+			snd_iprintf(buffer,"\n");
+			col = 0;
+		}
+
+		if (col == 0) {
+			snd_iprintf(buffer, "%04X ",i);
+		}
+
+		snd_iprintf(buffer,"%08X ",readl(dst + i));
+	}
+
+	snd_iprintf(buffer,"\nSRC_TASK_SCB1:\n");
+	col = 0;
+	for (i = 0x2480 ; i < 0x2480 + 0x40 ; i += sizeof(u32),col ++) {
+		if (col == 4) {
+			snd_iprintf(buffer,"\n");
+			col = 0;
+		}
+		
+		if (col == 0) {
+			snd_iprintf(buffer, "%04X ",i);
+		}
+
+		snd_iprintf(buffer,"%08X ",readl(dst + i));
+	}
+
+
+	snd_iprintf(buffer,"\nSPDIFO_BUFFER:\n");
+	col = 0;
+	for (i = SPDIFO_IP_OUTPUT_BUFFER1;i < SPDIFO_IP_OUTPUT_BUFFER1 + 0x30; i += sizeof(u32),col ++) {
+		if (col == 4) {
+			snd_iprintf(buffer,"\n");
+			col = 0;
+		}
+
+		if (col == 0) {
+			snd_iprintf(buffer, "%04X ",i);
+		}
+
+		snd_iprintf(buffer,"%08X ",readl(dst + i));
+	}
+
+	snd_iprintf(buffer,"\n...\n");
+	col = 0;
+
+	for (i = SPDIFO_IP_OUTPUT_BUFFER1+0xD0;i < SPDIFO_IP_OUTPUT_BUFFER1 + 0x110; i += sizeof(u32),col ++) {
+		if (col == 4) {
+			snd_iprintf(buffer,"\n");
+			col = 0;
+		}
+
+		if (col == 0) {
+			snd_iprintf(buffer, "%04X ",i);
+		}
+
+		snd_iprintf(buffer,"%08X ",readl(dst + i));
+	}
+
+
+	snd_iprintf(buffer,"\nOUTPUT_SNOOP:\n");
+	col = 0;
+	for (i = OUTPUT_SNOOP_BUFFER;i < OUTPUT_SNOOP_BUFFER + 0x40; i += sizeof(u32),col ++) {
+		if (col == 4) {
+			snd_iprintf(buffer,"\n");
+			col = 0;
+		}
+
+		if (col == 0) {
+			snd_iprintf(buffer, "%04X ",i);
+		}
+
+		snd_iprintf(buffer,"%08X ",readl(dst + i));
+	}
+
+	snd_iprintf(buffer,"\nCODEC_INPUT_BUF1: \n");
+	col = 0;
+	for (i = CODEC_INPUT_BUF1;i < CODEC_INPUT_BUF1 + 0x40; i += sizeof(u32),col ++) {
+		if (col == 4) {
+			snd_iprintf(buffer,"\n");
+			col = 0;
+		}
+
+		if (col == 0) {
+			snd_iprintf(buffer, "%04X ",i);
+		}
+
+		snd_iprintf(buffer,"%08X ",readl(dst + i));
+	}
+#if 0
+	snd_iprintf(buffer,"\nWRITE_BACK_BUF1: \n");
+	col = 0;
+	for (i = WRITE_BACK_BUF1;i < WRITE_BACK_BUF1 + 0x40; i += sizeof(u32),col ++) {
+		if (col == 4) {
+			snd_iprintf(buffer,"\n");
+			col = 0;
+		}
+
+		if (col == 0) {
+			snd_iprintf(buffer, "%04X ",i);
+		}
+
+		snd_iprintf(buffer,"%08X ",readl(dst + i));
+	}
+#endif
+
+	snd_iprintf(buffer,"\nSPDIFI_IP_OUTPUT_BUFFER1: \n");
+	col = 0;
+	for (i = SPDIFI_IP_OUTPUT_BUFFER1;i < SPDIFI_IP_OUTPUT_BUFFER1 + 0x80; i += sizeof(u32),col ++) {
+		if (col == 4) {
+			snd_iprintf(buffer,"\n");
+			col = 0;
+		}
+
+		if (col == 0) {
+			snd_iprintf(buffer, "%04X ",i);
+		}
+		
+		snd_iprintf(buffer,"%08X ",readl(dst + i));
+	}
+	snd_iprintf(buffer,"\n");
+}
+
+int cs46xx_dsp_proc_init (snd_card_t * card, cs46xx_t *chip)
+{
+	snd_info_entry_t *entry;
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	int i;
+
+	ins->snd_card = card;
+
+	if ((entry = snd_info_create_card_entry(card, "dsp", card->proc_root)) != NULL) {
+		entry->content = SNDRV_INFO_CONTENT_TEXT;
+		entry->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+		entry->c.text.read_size = 512;
+      
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+
+	ins->proc_dsp_dir = entry;
+
+	if (!ins->proc_dsp_dir)
+		return -ENOMEM;
+
+	if ((entry = snd_info_create_card_entry(card, "spos_symbols", ins->proc_dsp_dir)) != NULL) {
+		entry->content = SNDRV_INFO_CONTENT_TEXT;
+		entry->private_data = chip;
+		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+		entry->c.text.read_size = 512;
+		entry->c.text.read = cs46xx_dsp_proc_symbol_table_read;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	ins->proc_sym_info_entry = entry;
+    
+	if ((entry = snd_info_create_card_entry(card, "spos_modules", ins->proc_dsp_dir)) != NULL) {
+		entry->content = SNDRV_INFO_CONTENT_TEXT;
+		entry->private_data = chip;
+		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+		entry->c.text.read_size = 512;
+		entry->c.text.read = cs46xx_dsp_proc_modules_read;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	ins->proc_modules_info_entry = entry;
+
+	if ((entry = snd_info_create_card_entry(card, "parameter", ins->proc_dsp_dir)) != NULL) {
+		entry->content = SNDRV_INFO_CONTENT_TEXT;
+		entry->private_data = chip;
+		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+		entry->c.text.read_size = 512;
+		entry->c.text.read = cs46xx_dsp_proc_parameter_dump_read;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	ins->proc_parameter_dump_info_entry = entry;
+
+	if ((entry = snd_info_create_card_entry(card, "sample", ins->proc_dsp_dir)) != NULL) {
+		entry->content = SNDRV_INFO_CONTENT_TEXT;
+		entry->private_data = chip;
+		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+		entry->c.text.read_size = 512;
+		entry->c.text.read = cs46xx_dsp_proc_sample_dump_read;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	ins->proc_sample_dump_info_entry = entry;
+
+	if ((entry = snd_info_create_card_entry(card, "task_tree", ins->proc_dsp_dir)) != NULL) {
+		entry->content = SNDRV_INFO_CONTENT_TEXT;
+		entry->private_data = chip;
+		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+		entry->c.text.read_size = 512;
+		entry->c.text.read = cs46xx_dsp_proc_task_tree_read;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	ins->proc_task_info_entry = entry;
+
+	if ((entry = snd_info_create_card_entry(card, "scb_info", ins->proc_dsp_dir)) != NULL) {
+		entry->content = SNDRV_INFO_CONTENT_TEXT;
+		entry->private_data = chip;
+		entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
+		entry->c.text.read_size = 1024;
+		entry->c.text.read = cs46xx_dsp_proc_scb_read;
+		if (snd_info_register(entry) < 0) {
+			snd_info_free_entry(entry);
+			entry = NULL;
+		}
+	}
+	ins->proc_scb_info_entry = entry;
+
+	down(&chip->spos_mutex);
+	/* register/update SCB's entries on proc */
+	for (i = 0; i < ins->nscb; ++i) {
+		if (ins->scbs[i].deleted) continue;
+
+		cs46xx_dsp_proc_register_scb_desc (chip, (ins->scbs + i));
+	}
+	up(&chip->spos_mutex);
+
+	return 0;
+}
+
+int cs46xx_dsp_proc_done (cs46xx_t *chip)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	int i;
+
+	if (ins->proc_sym_info_entry) {
+		snd_info_unregister(ins->proc_sym_info_entry);
+		ins->proc_sym_info_entry = NULL;
+	}
+  
+	if (ins->proc_modules_info_entry) {
+		snd_info_unregister(ins->proc_modules_info_entry);
+		ins->proc_modules_info_entry = NULL;
+	}
+ 
+	if (ins->proc_parameter_dump_info_entry) {
+		snd_info_unregister(ins->proc_parameter_dump_info_entry);
+		ins->proc_parameter_dump_info_entry = NULL;
+	}
+  
+	if (ins->proc_sample_dump_info_entry) {
+		snd_info_unregister(ins->proc_sample_dump_info_entry);
+		ins->proc_sample_dump_info_entry = NULL;
+	}
+  
+	if (ins->proc_scb_info_entry) {
+		snd_info_unregister(ins->proc_scb_info_entry);
+		ins->proc_scb_info_entry = NULL;
+	}
+  
+	if (ins->proc_task_info_entry) {
+		snd_info_unregister(ins->proc_task_info_entry);
+		ins->proc_task_info_entry = NULL;
+	}
+
+	down(&chip->spos_mutex);
+	for (i = 0; i < ins->nscb; ++i) {
+		if (ins->scbs[i].deleted) continue;
+		cs46xx_dsp_proc_free_scb_desc ( (ins->scbs + i) );
+	}
+	up(&chip->spos_mutex);
+
+	if (ins->proc_dsp_dir) {
+		snd_info_unregister (ins->proc_dsp_dir);
+		ins->proc_dsp_dir = NULL;
+	}
+
+	return 0;
+}
+
+static int debug_tree;
+static void _dsp_create_task_tree (cs46xx_t *chip,u32 * task_data, u32  dest, int size)
+{
+	void __iomem *spdst = chip->region.idx[1].remap_addr + 
+		DSP_PARAMETER_BYTE_OFFSET + dest * sizeof(u32);
+	int i;
+
+	for (i = 0; i < size; ++i) {
+		if (debug_tree) printk ("addr %p, val %08x\n",spdst,task_data[i]);
+		writel(task_data[i],spdst);
+		spdst += sizeof(u32);
+	}
+}
+
+static int debug_scb;
+static void _dsp_create_scb (cs46xx_t *chip,u32 * scb_data, u32  dest)
+{
+	void __iomem *spdst = chip->region.idx[1].remap_addr + 
+		DSP_PARAMETER_BYTE_OFFSET + dest * sizeof(u32);
+	int i;
+
+	for (i = 0; i < 0x10; ++i) {
+		if (debug_scb) printk ("addr %p, val %08x\n",spdst,scb_data[i]);
+		writel(scb_data[i],spdst);
+		spdst += sizeof(u32);
+	}
+}
+
+static int find_free_scb_index (dsp_spos_instance_t * ins)
+{
+	int index = ins->nscb, i;
+
+	for (i = ins->scb_highest_frag_index; i < ins->nscb; ++i) {
+		if (ins->scbs[i].deleted) {
+			index = i;
+			break;
+		}
+	}
+
+	return index;
+}
+
+static dsp_scb_descriptor_t * _map_scb (cs46xx_t *chip,char * name,u32 dest)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	dsp_scb_descriptor_t * desc = NULL;
+	int index;
+
+	if (ins->nscb == DSP_MAX_SCB_DESC - 1) {
+		snd_printk(KERN_ERR "dsp_spos: got no place for other SCB\n");
+		return NULL;
+	}
+
+	index = find_free_scb_index (ins);
+
+	strcpy(ins->scbs[index].scb_name, name);
+	ins->scbs[index].address = dest;
+	ins->scbs[index].index = index;
+	ins->scbs[index].proc_info = NULL;
+	ins->scbs[index].ref_count = 1;
+	ins->scbs[index].deleted = 0;
+	spin_lock_init(&ins->scbs[index].lock);
+
+	desc = (ins->scbs + index);
+	ins->scbs[index].scb_symbol = add_symbol (chip, name, dest, SYMBOL_PARAMETER);
+
+	if (index > ins->scb_highest_frag_index)
+		ins->scb_highest_frag_index = index;
+
+	if (index == ins->nscb)
+		ins->nscb++;
+
+	return desc;
+}
+
+static dsp_task_descriptor_t * _map_task_tree (cs46xx_t *chip,char * name,u32 dest,u32 size)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	dsp_task_descriptor_t * desc = NULL;
+
+	if (ins->ntask == DSP_MAX_TASK_DESC - 1) {
+		snd_printk(KERN_ERR "dsp_spos: got no place for other TASK\n");
+		return NULL;
+	}
+
+	strcpy(ins->tasks[ins->ntask].task_name,name);
+	ins->tasks[ins->ntask].address = dest;
+	ins->tasks[ins->ntask].size = size;
+
+	/* quick find in list */
+	ins->tasks[ins->ntask].index = ins->ntask;
+	desc = (ins->tasks + ins->ntask);
+	ins->ntask++;
+
+	add_symbol (chip,name,dest,SYMBOL_PARAMETER);
+	return desc;
+}
+
+dsp_scb_descriptor_t * cs46xx_dsp_create_scb (cs46xx_t *chip,char * name, u32 * scb_data,u32 dest)
+{
+	dsp_scb_descriptor_t * desc;
+
+	desc = _map_scb (chip,name,dest);
+	if (desc) {
+		_dsp_create_scb(chip,scb_data,dest);
+	} else {
+		snd_printk(KERN_ERR "dsp_spos: failed to map SCB\n");
+	}
+
+	return desc;
+}
+
+
+static dsp_task_descriptor_t *  cs46xx_dsp_create_task_tree (cs46xx_t *chip,char * name, u32 * task_data,u32 dest,int size)
+{
+	dsp_task_descriptor_t * desc;
+
+	desc = _map_task_tree (chip,name,dest,size);
+	if (desc) {
+		_dsp_create_task_tree(chip,task_data,dest,size);
+	} else {
+		snd_printk(KERN_ERR "dsp_spos: failed to map TASK\n");
+	}
+
+	return desc;
+}
+
+int cs46xx_dsp_scb_and_task_init (cs46xx_t *chip)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	symbol_entry_t * fg_task_tree_header_code;
+	symbol_entry_t * task_tree_header_code;
+	symbol_entry_t * task_tree_thread;
+	symbol_entry_t * null_algorithm;
+	symbol_entry_t * magic_snoop_task;
+
+	dsp_scb_descriptor_t * timing_master_scb;
+	dsp_scb_descriptor_t * codec_out_scb;
+	dsp_scb_descriptor_t * codec_in_scb;
+	dsp_scb_descriptor_t * src_task_scb;
+	dsp_scb_descriptor_t * master_mix_scb;
+	dsp_scb_descriptor_t * rear_mix_scb;
+	dsp_scb_descriptor_t * record_mix_scb;
+	dsp_scb_descriptor_t * write_back_scb;
+	dsp_scb_descriptor_t * vari_decimate_scb;
+	dsp_scb_descriptor_t * rear_codec_out_scb;
+	dsp_scb_descriptor_t * clfe_codec_out_scb;
+	dsp_scb_descriptor_t * magic_snoop_scb;
+	
+	int fifo_addr,fifo_span,valid_slots;
+
+	static spos_control_block_t sposcb = {
+		/* 0 */ HFG_TREE_SCB,HFG_STACK,
+		/* 1 */ SPOSCB_ADDR,BG_TREE_SCB_ADDR,
+		/* 2 */ DSP_SPOS_DC,0,
+		/* 3 */ DSP_SPOS_DC,DSP_SPOS_DC,
+		/* 4 */ 0,0,
+		/* 5 */ DSP_SPOS_UU,0,
+		/* 6 */ FG_TASK_HEADER_ADDR,0,
+		/* 7 */ 0,0,
+		/* 8 */ DSP_SPOS_UU,DSP_SPOS_DC,
+		/* 9 */ 0,
+		/* A */ 0,HFG_FIRST_EXECUTE_MODE,
+		/* B */ DSP_SPOS_UU,DSP_SPOS_UU,
+		/* C */ DSP_SPOS_DC_DC,
+		/* D */ DSP_SPOS_DC_DC,
+		/* E */ DSP_SPOS_DC_DC,
+		/* F */ DSP_SPOS_DC_DC
+	};
+
+	cs46xx_dsp_create_task_tree(chip, "sposCB", (u32 *)&sposcb, SPOSCB_ADDR, 0x10);
+
+	null_algorithm  = cs46xx_dsp_lookup_symbol(chip, "NULLALGORITHM", SYMBOL_CODE);
+	if (null_algorithm == NULL) {
+		snd_printk(KERN_ERR "dsp_spos: symbol NULLALGORITHM not found\n");
+		return -EIO;
+	}
+
+	fg_task_tree_header_code = cs46xx_dsp_lookup_symbol(chip, "FGTASKTREEHEADERCODE", SYMBOL_CODE);  
+	if (fg_task_tree_header_code == NULL) {
+		snd_printk(KERN_ERR "dsp_spos: symbol FGTASKTREEHEADERCODE not found\n");
+		return -EIO;
+	}
+
+	task_tree_header_code = cs46xx_dsp_lookup_symbol(chip, "TASKTREEHEADERCODE", SYMBOL_CODE);  
+	if (task_tree_header_code == NULL) {
+		snd_printk(KERN_ERR "dsp_spos: symbol TASKTREEHEADERCODE not found\n");
+		return -EIO;
+	}
+  
+	task_tree_thread = cs46xx_dsp_lookup_symbol(chip, "TASKTREETHREAD", SYMBOL_CODE);
+	if (task_tree_thread == NULL) {
+		snd_printk(KERN_ERR "dsp_spos: symbol TASKTREETHREAD not found\n");
+		return -EIO;
+	}
+
+	magic_snoop_task = cs46xx_dsp_lookup_symbol(chip, "MAGICSNOOPTASK", SYMBOL_CODE);
+	if (magic_snoop_task == NULL) {
+		snd_printk(KERN_ERR "dsp_spos: symbol MAGICSNOOPTASK not found\n");
+		return -EIO;
+	}
+  
+	{
+		/* create the null SCB */
+		static generic_scb_t null_scb = {
+			{ 0, 0, 0, 0 },
+			{ 0, 0, 0, 0, 0 },
+			NULL_SCB_ADDR, NULL_SCB_ADDR,
+			0, 0, 0, 0, 0,
+			{
+				0,0,
+				0,0,
+			}
+		};
+
+		null_scb.entry_point = null_algorithm->address;
+		ins->the_null_scb = cs46xx_dsp_create_scb(chip, "nullSCB", (u32 *)&null_scb, NULL_SCB_ADDR);
+		ins->the_null_scb->task_entry = null_algorithm;
+		ins->the_null_scb->sub_list_ptr = ins->the_null_scb;
+		ins->the_null_scb->next_scb_ptr = ins->the_null_scb;
+		ins->the_null_scb->parent_scb_ptr = NULL;
+		cs46xx_dsp_proc_register_scb_desc (chip,ins->the_null_scb);
+	}
+
+	{
+		/* setup foreground task tree */
+		static task_tree_control_block_t fg_task_tree_hdr =  {
+			{ FG_TASK_HEADER_ADDR | (DSP_SPOS_DC << 0x10),
+			  DSP_SPOS_DC_DC,
+			  DSP_SPOS_DC_DC,
+			  0x0000,DSP_SPOS_DC,
+			  DSP_SPOS_DC, DSP_SPOS_DC,
+			  DSP_SPOS_DC_DC,
+			  DSP_SPOS_DC_DC,
+			  DSP_SPOS_DC_DC,
+			  DSP_SPOS_DC,DSP_SPOS_DC },
+    
+			{
+				BG_TREE_SCB_ADDR,TIMINGMASTER_SCB_ADDR, 
+				0,
+				FG_TASK_HEADER_ADDR + TCBData,                  
+			},
+
+			{    
+				4,0,
+				1,0,
+				2,SPOSCB_ADDR + HFGFlags,
+				0,0,
+				FG_TASK_HEADER_ADDR + TCBContextBlk,FG_STACK
+			},
+
+			{
+				DSP_SPOS_DC,0,
+				DSP_SPOS_DC,DSP_SPOS_DC,
+				DSP_SPOS_DC,DSP_SPOS_DC,
+				DSP_SPOS_DC,DSP_SPOS_DC,
+				DSP_SPOS_DC,DSP_SPOS_DC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_UU,1,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC 
+			},                                               
+			{ 
+				FG_INTERVAL_TIMER_PERIOD,DSP_SPOS_UU,
+				0,0
+			}
+		};
+
+		fg_task_tree_hdr.links.entry_point = fg_task_tree_header_code->address;
+		fg_task_tree_hdr.context_blk.stack0 = task_tree_thread->address;
+		cs46xx_dsp_create_task_tree(chip,"FGtaskTreeHdr",(u32 *)&fg_task_tree_hdr,FG_TASK_HEADER_ADDR,0x35);
+	}
+
+
+	{
+		/* setup foreground task tree */
+		static task_tree_control_block_t bg_task_tree_hdr =  {
+			{ DSP_SPOS_DC_DC,
+			  DSP_SPOS_DC_DC,
+			  DSP_SPOS_DC_DC,
+			  DSP_SPOS_DC, DSP_SPOS_DC,
+			  DSP_SPOS_DC, DSP_SPOS_DC,
+			  DSP_SPOS_DC_DC,
+			  DSP_SPOS_DC_DC,
+			  DSP_SPOS_DC_DC,
+			  DSP_SPOS_DC,DSP_SPOS_DC },
+    
+			{
+				NULL_SCB_ADDR,NULL_SCB_ADDR,  /* Set up the background to do nothing */
+				0,
+				BG_TREE_SCB_ADDR + TCBData,
+			},
+
+			{    
+				9999,0,
+				0,1,
+				0,SPOSCB_ADDR + HFGFlags,
+				0,0,
+				BG_TREE_SCB_ADDR + TCBContextBlk,BG_STACK
+			},
+
+			{
+				DSP_SPOS_DC,0,
+				DSP_SPOS_DC,DSP_SPOS_DC,
+				DSP_SPOS_DC,DSP_SPOS_DC,
+				DSP_SPOS_DC,DSP_SPOS_DC,
+				DSP_SPOS_DC,DSP_SPOS_DC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_UU,1,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC,
+				DSP_SPOS_DCDC 
+			},                                               
+			{ 
+				BG_INTERVAL_TIMER_PERIOD,DSP_SPOS_UU,
+				0,0
+			}
+		};
+
+		bg_task_tree_hdr.links.entry_point = task_tree_header_code->address;
+		bg_task_tree_hdr.context_blk.stack0 = task_tree_thread->address;
+		cs46xx_dsp_create_task_tree(chip,"BGtaskTreeHdr",(u32 *)&bg_task_tree_hdr,BG_TREE_SCB_ADDR,0x35);
+	}
+
+	/* create timing master SCB */
+	timing_master_scb = cs46xx_dsp_create_timing_master_scb(chip);
+
+	/* create the CODEC output task */
+	codec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,"CodecOutSCB_I",0x0010,0x0000,
+							MASTERMIX_SCB_ADDR,
+							CODECOUT_SCB_ADDR,timing_master_scb,
+							SCB_ON_PARENT_SUBLIST_SCB);
+
+	if (!codec_out_scb) goto _fail_end;
+	/* create the master mix SCB */
+	master_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"MasterMixSCB",
+							MIX_SAMPLE_BUF1,MASTERMIX_SCB_ADDR,
+							codec_out_scb,
+							SCB_ON_PARENT_SUBLIST_SCB);
+	ins->master_mix_scb = master_mix_scb;
+
+	if (!master_mix_scb) goto _fail_end;
+
+	/* create codec in */
+	codec_in_scb = cs46xx_dsp_create_codec_in_scb(chip,"CodecInSCB",0x0010,0x00A0,
+						      CODEC_INPUT_BUF1,
+						      CODECIN_SCB_ADDR,codec_out_scb,
+						      SCB_ON_PARENT_NEXT_SCB);
+	if (!codec_in_scb) goto _fail_end;
+	ins->codec_in_scb = codec_in_scb;
+
+	/* create write back scb */
+	write_back_scb = cs46xx_dsp_create_mix_to_ostream_scb(chip,"WriteBackSCB",
+							      WRITE_BACK_BUF1,WRITE_BACK_SPB,
+							      WRITEBACK_SCB_ADDR,
+							      timing_master_scb,
+							      SCB_ON_PARENT_NEXT_SCB);
+	if (!write_back_scb) goto _fail_end;
+
+	{
+		static mix2_ostream_spb_t mix2_ostream_spb = {
+			0x00020000,
+			0x0000ffff
+		};
+    
+		/* dirty hack ... */
+		_dsp_create_task_tree (chip,(u32 *)&mix2_ostream_spb,WRITE_BACK_SPB,2);
+	}
+
+	/* input sample converter */
+	vari_decimate_scb = cs46xx_dsp_create_vari_decimate_scb(chip,"VariDecimateSCB",
+								VARI_DECIMATE_BUF0,
+								VARI_DECIMATE_BUF1,
+								VARIDECIMATE_SCB_ADDR,
+								write_back_scb,
+								SCB_ON_PARENT_SUBLIST_SCB);
+	if (!vari_decimate_scb) goto _fail_end;
+
+	/* create the record mixer SCB */
+	record_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"RecordMixerSCB",
+							MIX_SAMPLE_BUF2,
+							RECORD_MIXER_SCB_ADDR,
+							vari_decimate_scb,
+							SCB_ON_PARENT_SUBLIST_SCB);
+	ins->record_mixer_scb = record_mix_scb;
+
+	if (!record_mix_scb) goto _fail_end;
+
+	valid_slots = snd_cs46xx_peekBA0(chip, BA0_ACOSV);
+
+	snd_assert (chip->nr_ac97_codecs == 1 || chip->nr_ac97_codecs == 2);
+
+	if (chip->nr_ac97_codecs == 1) {
+		/* output on slot 5 and 11 
+		   on primary CODEC */
+		fifo_addr = 0x20;
+		fifo_span = 0x60;
+
+		/* enable slot 5 and 11 */
+		valid_slots |= ACOSV_SLV5 | ACOSV_SLV11;
+	} else {
+		/* output on slot 7 and 8 
+		   on secondary CODEC */
+		fifo_addr = 0x40;
+		fifo_span = 0x10;
+
+		/* enable slot 7 and 8 */
+		valid_slots |= ACOSV_SLV7 | ACOSV_SLV8;
+	}
+	/* create CODEC tasklet for rear speakers output*/
+	rear_codec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,"CodecOutSCB_Rear",fifo_span,fifo_addr,
+							     REAR_MIXER_SCB_ADDR,
+							     REAR_CODECOUT_SCB_ADDR,codec_in_scb,
+							     SCB_ON_PARENT_NEXT_SCB);
+	if (!rear_codec_out_scb) goto _fail_end;
+	
+	
+	/* create the rear PCM channel  mixer SCB */
+	rear_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"RearMixerSCB",
+						      MIX_SAMPLE_BUF3,
+						      REAR_MIXER_SCB_ADDR,
+						      rear_codec_out_scb,
+						      SCB_ON_PARENT_SUBLIST_SCB);
+	ins->rear_mix_scb = rear_mix_scb;
+	if (!rear_mix_scb) goto _fail_end;
+	
+	if (chip->nr_ac97_codecs == 2) {
+		/* create CODEC tasklet for rear Center/LFE output 
+		   slot 6 and 9 on seconadry CODEC */
+		clfe_codec_out_scb = cs46xx_dsp_create_codec_out_scb(chip,"CodecOutSCB_CLFE",0x0030,0x0030,
+								     CLFE_MIXER_SCB_ADDR,
+								     CLFE_CODEC_SCB_ADDR,
+								     rear_codec_out_scb,
+								     SCB_ON_PARENT_NEXT_SCB);
+		if (!clfe_codec_out_scb) goto _fail_end;
+		
+		
+		/* create the rear PCM channel  mixer SCB */
+		ins->center_lfe_mix_scb = cs46xx_dsp_create_mix_only_scb(chip,"CLFEMixerSCB",
+									 MIX_SAMPLE_BUF4,
+									 CLFE_MIXER_SCB_ADDR,
+									 clfe_codec_out_scb,
+									 SCB_ON_PARENT_SUBLIST_SCB);
+		if (!ins->center_lfe_mix_scb) goto _fail_end;
+
+		/* enable slot 6 and 9 */
+		valid_slots |= ACOSV_SLV6 | ACOSV_SLV9;
+	} else {
+		clfe_codec_out_scb = rear_codec_out_scb;
+		ins->center_lfe_mix_scb = rear_mix_scb;
+	}
+
+	/* enable slots depending on CODEC configuration */
+	snd_cs46xx_pokeBA0(chip, BA0_ACOSV, valid_slots);
+
+	/* the magic snooper */
+	magic_snoop_scb = cs46xx_dsp_create_magic_snoop_scb (chip,"MagicSnoopSCB_I",OUTPUTSNOOP_SCB_ADDR,
+							     OUTPUT_SNOOP_BUFFER,
+							     codec_out_scb,
+							     clfe_codec_out_scb,
+							     SCB_ON_PARENT_NEXT_SCB);
+
+    
+	if (!magic_snoop_scb) goto _fail_end;
+	ins->ref_snoop_scb = magic_snoop_scb;
+
+	/* SP IO access */
+	if (!cs46xx_dsp_create_spio_write_scb(chip,"SPIOWriteSCB",SPIOWRITE_SCB_ADDR,
+					      magic_snoop_scb,
+					      SCB_ON_PARENT_NEXT_SCB))
+		goto _fail_end;
+
+	/* SPDIF input sampel rate converter */
+	src_task_scb = cs46xx_dsp_create_src_task_scb(chip,"SrcTaskSCB_SPDIFI",
+						      ins->spdif_in_sample_rate,
+						      SRC_OUTPUT_BUF1,
+						      SRC_DELAY_BUF1,SRCTASK_SCB_ADDR,
+						      master_mix_scb,
+						      SCB_ON_PARENT_SUBLIST_SCB,1);
+
+	if (!src_task_scb) goto _fail_end;
+	cs46xx_src_unlink(chip,src_task_scb);
+
+	/* NOTE: when we now how to detect the SPDIF input
+	   sample rate we will use this SRC to adjust it */
+	ins->spdif_in_src = src_task_scb;
+
+	cs46xx_dsp_async_init(chip,timing_master_scb);
+	return 0;
+
+ _fail_end:
+	snd_printk(KERN_ERR "dsp_spos: failed to setup SCB's in DSP\n");
+	return -EINVAL;
+}
+
+static int cs46xx_dsp_async_init (cs46xx_t *chip, dsp_scb_descriptor_t * fg_entry)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	symbol_entry_t * s16_async_codec_input_task;
+	symbol_entry_t * spdifo_task;
+	symbol_entry_t * spdifi_task;
+	dsp_scb_descriptor_t * spdifi_scb_desc,* spdifo_scb_desc,* async_codec_scb_desc;
+
+	s16_async_codec_input_task = cs46xx_dsp_lookup_symbol(chip, "S16_ASYNCCODECINPUTTASK", SYMBOL_CODE);
+	if (s16_async_codec_input_task == NULL) {
+		snd_printk(KERN_ERR "dsp_spos: symbol S16_ASYNCCODECINPUTTASK not found\n");
+		return -EIO;
+	}
+	spdifo_task = cs46xx_dsp_lookup_symbol(chip, "SPDIFOTASK", SYMBOL_CODE);
+	if (spdifo_task == NULL) {
+		snd_printk(KERN_ERR "dsp_spos: symbol SPDIFOTASK not found\n");
+		return -EIO;
+	}
+
+	spdifi_task = cs46xx_dsp_lookup_symbol(chip, "SPDIFITASK", SYMBOL_CODE);
+	if (spdifi_task == NULL) {
+		snd_printk(KERN_ERR "dsp_spos: symbol SPDIFITASK not found\n");
+		return -EIO;
+	}
+
+	{
+		/* 0xBC0 */
+		spdifoscb_t spdifo_scb = {
+			/* 0 */ DSP_SPOS_UUUU,
+			{
+				/* 1 */ 0xb0, 
+				/* 2 */ 0, 
+				/* 3 */ 0, 
+				/* 4 */ 0, 
+			},
+			/* NOTE: the SPDIF output task read samples in mono
+			   format, the AsynchFGTxSCB task writes to buffer
+			   in stereo format
+			*/
+			/* 5 */ RSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_256,
+			/* 6 */ ( SPDIFO_IP_OUTPUT_BUFFER1 << 0x10 )  |  0xFFFC,
+			/* 7 */ 0,0, 
+			/* 8 */ 0, 
+			/* 9 */ FG_TASK_HEADER_ADDR, NULL_SCB_ADDR, 
+			/* A */ spdifo_task->address,
+			SPDIFO_SCB_INST + SPDIFOFIFOPointer,
+			{
+				/* B */ 0x0040, /*DSP_SPOS_UUUU,*/
+				/* C */ 0x20ff, /*DSP_SPOS_UUUU,*/
+			},
+			/* D */ 0x804c,0,							  /* SPDIFOFIFOPointer:SPDIFOStatRegAddr; */
+			/* E */ 0x0108,0x0001,					  /* SPDIFOStMoFormat:SPDIFOFIFOBaseAddr; */
+			/* F */ DSP_SPOS_UUUU	  			          /* SPDIFOFree; */
+		};
+
+		/* 0xBB0 */
+		spdifiscb_t spdifi_scb = {
+			/* 0 */ DSP_SPOS_UULO,DSP_SPOS_UUHI,
+			/* 1 */ 0,
+			/* 2 */ 0,
+			/* 3 */ 1,4000,        /* SPDIFICountLimit SPDIFICount */ 
+			/* 4 */ DSP_SPOS_UUUU, /* SPDIFIStatusData */
+			/* 5 */ 0,DSP_SPOS_UUHI, /* StatusData, Free4 */
+			/* 6 */ DSP_SPOS_UUUU,  /* Free3 */
+			/* 7 */ DSP_SPOS_UU,DSP_SPOS_DC,  /* Free2 BitCount*/
+			/* 8 */ DSP_SPOS_UUUU,	/* TempStatus */
+			/* 9 */ SPDIFO_SCB_INST, NULL_SCB_ADDR,
+			/* A */ spdifi_task->address,
+			SPDIFI_SCB_INST + SPDIFIFIFOPointer,
+			/* NOTE: The SPDIF input task write the sample in mono
+			   format from the HW FIFO, the AsynchFGRxSCB task  reads 
+			   them in stereo 
+			*/
+			/* B */ RSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_128,
+			/* C */ (SPDIFI_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC,
+			/* D */ 0x8048,0,
+			/* E */ 0x01f0,0x0001,
+			/* F */ DSP_SPOS_UUUU /* SPDIN_STATUS monitor */
+		};
+
+		/* 0xBA0 */
+		async_codec_input_scb_t async_codec_input_scb = {
+			/* 0 */ DSP_SPOS_UUUU,
+			/* 1 */ 0,
+			/* 2 */ 0,
+			/* 3 */ 1,4000,
+			/* 4 */ 0x0118,0x0001,
+			/* 5 */ RSCONFIG_SAMPLE_16MONO + RSCONFIG_MODULO_64,
+			/* 6 */ (ASYNC_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC,
+			/* 7 */ DSP_SPOS_UU,0x3,
+			/* 8 */ DSP_SPOS_UUUU,
+			/* 9 */ SPDIFI_SCB_INST,NULL_SCB_ADDR,
+			/* A */ s16_async_codec_input_task->address,
+			HFG_TREE_SCB + AsyncCIOFIFOPointer,
+              
+			/* B */ RSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_64,
+			/* C */ (ASYNC_IP_OUTPUT_BUFFER1 << 0x10),  /*(ASYNC_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC,*/
+      
+#ifdef UseASER1Input
+			/* short AsyncCIFIFOPointer:AsyncCIStatRegAddr;	       
+			   Init. 0000:8042: for ASER1
+			   0000:8044: for ASER2 */
+			/* D */ 0x8042,0,
+      
+			/* short AsyncCIStMoFormat:AsyncCIFIFOBaseAddr;
+			   Init 1 stero:8050 ASER1
+			   Init 0  mono:8070 ASER2
+			   Init 1 Stereo : 0100 ASER1 (Set by script) */
+			/* E */ 0x0100,0x0001,
+      
+#endif
+      
+#ifdef UseASER2Input
+			/* short AsyncCIFIFOPointer:AsyncCIStatRegAddr;
+			   Init. 0000:8042: for ASER1
+			   0000:8044: for ASER2 */
+			/* D */ 0x8044,0,
+      
+			/* short AsyncCIStMoFormat:AsyncCIFIFOBaseAddr;
+			   Init 1 stero:8050 ASER1
+			   Init 0  mono:8070 ASER2
+			   Init 1 Stereo : 0100 ASER1 (Set by script) */
+			/* E */ 0x0110,0x0001,
+      
+#endif
+      
+			/* short AsyncCIOutputBufModulo:AsyncCIFree;
+			   AsyncCIOutputBufModulo: The modulo size for   
+			   the output buffer of this task */
+			/* F */ 0, /* DSP_SPOS_UUUU */
+		};
+
+		spdifo_scb_desc = cs46xx_dsp_create_scb(chip,"SPDIFOSCB",(u32 *)&spdifo_scb,SPDIFO_SCB_INST);
+
+		snd_assert(spdifo_scb_desc, return -EIO);
+		spdifi_scb_desc = cs46xx_dsp_create_scb(chip,"SPDIFISCB",(u32 *)&spdifi_scb,SPDIFI_SCB_INST);
+		snd_assert(spdifi_scb_desc, return -EIO);
+		async_codec_scb_desc = cs46xx_dsp_create_scb(chip,"AsynCodecInputSCB",(u32 *)&async_codec_input_scb, HFG_TREE_SCB);
+		snd_assert(async_codec_scb_desc, return -EIO);
+
+		async_codec_scb_desc->parent_scb_ptr = NULL;
+		async_codec_scb_desc->next_scb_ptr = spdifi_scb_desc;
+		async_codec_scb_desc->sub_list_ptr = ins->the_null_scb;
+		async_codec_scb_desc->task_entry = s16_async_codec_input_task;
+
+		spdifi_scb_desc->parent_scb_ptr = async_codec_scb_desc;
+		spdifi_scb_desc->next_scb_ptr = spdifo_scb_desc;
+		spdifi_scb_desc->sub_list_ptr = ins->the_null_scb;
+		spdifi_scb_desc->task_entry = spdifi_task;
+
+		spdifo_scb_desc->parent_scb_ptr = spdifi_scb_desc;
+		spdifo_scb_desc->next_scb_ptr = fg_entry;
+		spdifo_scb_desc->sub_list_ptr = ins->the_null_scb;
+		spdifo_scb_desc->task_entry = spdifo_task;
+
+		/* this one is faked, as the parnet of SPDIFO task
+		   is the FG task tree */
+		fg_entry->parent_scb_ptr = spdifo_scb_desc;
+
+		/* for proc fs */
+		cs46xx_dsp_proc_register_scb_desc (chip,spdifo_scb_desc);
+		cs46xx_dsp_proc_register_scb_desc (chip,spdifi_scb_desc);
+		cs46xx_dsp_proc_register_scb_desc (chip,async_codec_scb_desc);
+
+		/* Async MASTER ENABLE, affects both SPDIF input and output */
+		snd_cs46xx_pokeBA0(chip, BA0_ASER_MASTER, 0x1 );
+	}
+
+	return 0;
+}
+
+
+static void cs46xx_dsp_disable_spdif_hw (cs46xx_t *chip)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+
+	/* set SPDIF output FIFO slot */
+	snd_cs46xx_pokeBA0(chip, BA0_ASER_FADDR, 0);
+
+	/* SPDIF output MASTER ENABLE */
+	cs46xx_poke_via_dsp (chip,SP_SPDOUT_CONTROL, 0);
+
+	/* right and left validate bit */
+	/*cs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, ins->spdif_csuv_default);*/
+	cs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, 0x0);
+
+	/* clear fifo pointer */
+	cs46xx_poke_via_dsp (chip,SP_SPDIN_FIFOPTR, 0x0);
+
+	/* monitor state */
+	ins->spdif_status_out &= ~DSP_SPDIF_STATUS_HW_ENABLED;
+}
+
+int cs46xx_dsp_enable_spdif_hw (cs46xx_t *chip)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+
+	/* if hw-ctrl already enabled, turn off to reset logic ... */
+	cs46xx_dsp_disable_spdif_hw (chip);
+	udelay(50);
+
+	/* set SPDIF output FIFO slot */
+	snd_cs46xx_pokeBA0(chip, BA0_ASER_FADDR, ( 0x8000 | ((SP_SPDOUT_FIFO >> 4) << 4) ));
+
+	/* SPDIF output MASTER ENABLE */
+	cs46xx_poke_via_dsp (chip,SP_SPDOUT_CONTROL, 0x80000000);
+
+	/* right and left validate bit */
+	cs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, ins->spdif_csuv_default);
+
+	/* monitor state */
+	ins->spdif_status_out |= DSP_SPDIF_STATUS_HW_ENABLED;
+
+	return 0;
+}
+
+int cs46xx_dsp_enable_spdif_in (cs46xx_t *chip)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+
+	/* turn on amplifier */
+	chip->active_ctrl(chip, 1);
+	chip->amplifier_ctrl(chip, 1);
+
+	snd_assert (ins->asynch_rx_scb == NULL,return -EINVAL);
+	snd_assert (ins->spdif_in_src != NULL,return -EINVAL);
+
+	down(&chip->spos_mutex);
+
+	if ( ! (ins->spdif_status_out & DSP_SPDIF_STATUS_INPUT_CTRL_ENABLED) ) {
+		/* time countdown enable */
+		cs46xx_poke_via_dsp (chip,SP_ASER_COUNTDOWN, 0x80000005);
+		/* NOTE: 80000005 value is just magic. With all values
+		   that I've tested this one seem to give the best result.
+		   Got no explication why. (Benny) */
+
+		/* SPDIF input MASTER ENABLE */
+		cs46xx_poke_via_dsp (chip,SP_SPDIN_CONTROL, 0x800003ff);
+
+		ins->spdif_status_out |= DSP_SPDIF_STATUS_INPUT_CTRL_ENABLED;
+	}
+
+	/* create and start the asynchronous receiver SCB */
+	ins->asynch_rx_scb = cs46xx_dsp_create_asynch_fg_rx_scb(chip,"AsynchFGRxSCB",
+								ASYNCRX_SCB_ADDR,
+								SPDIFI_SCB_INST,
+								SPDIFI_IP_OUTPUT_BUFFER1,
+								ins->spdif_in_src,
+								SCB_ON_PARENT_SUBLIST_SCB);
+
+	spin_lock_irq(&chip->reg_lock);
+
+	/* reset SPDIF input sample buffer pointer */
+	/*snd_cs46xx_poke (chip, (SPDIFI_SCB_INST + 0x0c) << 2,
+	  (SPDIFI_IP_OUTPUT_BUFFER1 << 0x10) | 0xFFFC);*/
+
+	/* reset FIFO ptr */
+	/*cs46xx_poke_via_dsp (chip,SP_SPDIN_FIFOPTR, 0x0);*/
+	cs46xx_src_link(chip,ins->spdif_in_src);
+
+	/* unmute SRC volume */
+	cs46xx_dsp_scb_set_volume (chip,ins->spdif_in_src,0x7fff,0x7fff);
+
+	spin_unlock_irq(&chip->reg_lock);
+
+	/* set SPDIF input sample rate and unmute
+	   NOTE: only 48khz support for SPDIF input this time */
+	/* cs46xx_dsp_set_src_sample_rate(chip,ins->spdif_in_src,48000); */
+
+	/* monitor state */
+	ins->spdif_status_in = 1;
+	up(&chip->spos_mutex);
+
+	return 0;
+}
+
+int cs46xx_dsp_disable_spdif_in (cs46xx_t *chip)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+
+	snd_assert (ins->asynch_rx_scb != NULL, return -EINVAL);
+	snd_assert (ins->spdif_in_src != NULL,return -EINVAL);	
+
+	down(&chip->spos_mutex);
+
+	/* Remove the asynchronous receiver SCB */
+	cs46xx_dsp_remove_scb (chip,ins->asynch_rx_scb);
+	ins->asynch_rx_scb = NULL;
+
+	cs46xx_src_unlink(chip,ins->spdif_in_src);
+
+	/* monitor state */
+	ins->spdif_status_in = 0;
+	up(&chip->spos_mutex);
+
+	/* restore amplifier */
+	chip->active_ctrl(chip, -1);
+	chip->amplifier_ctrl(chip, -1);
+
+	return 0;
+}
+
+int cs46xx_dsp_enable_pcm_capture (cs46xx_t *chip)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+
+	snd_assert (ins->pcm_input == NULL,return -EINVAL);
+	snd_assert (ins->ref_snoop_scb != NULL,return -EINVAL);
+
+	down(&chip->spos_mutex);
+	ins->pcm_input = cs46xx_add_record_source(chip,ins->ref_snoop_scb,PCMSERIALIN_PCM_SCB_ADDR,
+                                                  "PCMSerialInput_Wave");
+	up(&chip->spos_mutex);
+
+	return 0;
+}
+
+int cs46xx_dsp_disable_pcm_capture (cs46xx_t *chip)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+
+	snd_assert (ins->pcm_input != NULL,return -EINVAL);
+
+	down(&chip->spos_mutex);
+	cs46xx_dsp_remove_scb (chip,ins->pcm_input);
+	ins->pcm_input = NULL;
+	up(&chip->spos_mutex);
+
+	return 0;
+}
+
+int cs46xx_dsp_enable_adc_capture (cs46xx_t *chip)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+
+	snd_assert (ins->adc_input == NULL,return -EINVAL);
+	snd_assert (ins->codec_in_scb != NULL,return -EINVAL);
+
+	down(&chip->spos_mutex);
+	ins->adc_input = cs46xx_add_record_source(chip,ins->codec_in_scb,PCMSERIALIN_SCB_ADDR,
+						  "PCMSerialInput_ADC");
+	up(&chip->spos_mutex);
+
+	return 0;
+}
+
+int cs46xx_dsp_disable_adc_capture (cs46xx_t *chip)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+
+	snd_assert (ins->adc_input != NULL,return -EINVAL);
+
+	down(&chip->spos_mutex);
+	cs46xx_dsp_remove_scb (chip,ins->adc_input);
+	ins->adc_input = NULL;
+	up(&chip->spos_mutex);
+
+	return 0;
+}
+
+int cs46xx_poke_via_dsp (cs46xx_t *chip,u32 address,u32 data)
+{
+	u32 temp;
+	int  i;
+
+	/* santiy check the parameters.  (These numbers are not 100% correct.  They are
+	   a rough guess from looking at the controller spec.) */
+	if (address < 0x8000 || address >= 0x9000)
+		return -EINVAL;
+        
+	/* initialize the SP_IO_WRITE SCB with the data. */
+	temp = ( address << 16 ) | ( address & 0x0000FFFF);   /* offset 0 <-- address2 : address1 */
+
+	snd_cs46xx_poke(chip,( SPIOWRITE_SCB_ADDR      << 2), temp);
+	snd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 1) << 2), data); /* offset 1 <-- data1 */
+	snd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 2) << 2), data); /* offset 1 <-- data2 */
+    
+	/* Poke this location to tell the task to start */
+	snd_cs46xx_poke(chip,((SPIOWRITE_SCB_ADDR + 6) << 2), SPIOWRITE_SCB_ADDR << 0x10);
+
+	/* Verify that the task ran */
+	for (i=0; i<25; i++) {
+		udelay(125);
+
+		temp =  snd_cs46xx_peek(chip,((SPIOWRITE_SCB_ADDR + 6) << 2));
+		if (temp == 0x00000000)
+			break;
+	}
+
+	if (i == 25) {
+		snd_printk(KERN_ERR "dsp_spos: SPIOWriteTask not responding\n");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+int cs46xx_dsp_set_dac_volume (cs46xx_t * chip,u16 left,u16 right)
+{
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+	dsp_scb_descriptor_t * scb; 
+
+	down(&chip->spos_mutex);
+	
+	/* main output */
+	scb = ins->master_mix_scb->sub_list_ptr;
+	while (scb != ins->the_null_scb) {
+		cs46xx_dsp_scb_set_volume (chip,scb,left,right);
+		scb = scb->next_scb_ptr;
+	}
+
+	/* rear output */
+	scb = ins->rear_mix_scb->sub_list_ptr;
+	while (scb != ins->the_null_scb) {
+		cs46xx_dsp_scb_set_volume (chip,scb,left,right);
+		scb = scb->next_scb_ptr;
+	}
+
+	ins->dac_volume_left = left;
+	ins->dac_volume_right = right;
+
+	up(&chip->spos_mutex);
+
+	return 0;
+}
+
+int cs46xx_dsp_set_iec958_volume (cs46xx_t * chip,u16 left,u16 right) {
+	dsp_spos_instance_t * ins = chip->dsp_spos_instance;
+
+	down(&chip->spos_mutex);
+
+	if (ins->asynch_rx_scb != NULL)
+		cs46xx_dsp_scb_set_volume (chip,ins->asynch_rx_scb,
+					   left,right);
+
+	ins->spdif_input_volume_left = left;
+	ins->spdif_input_volume_right = right;
+
+	up(&chip->spos_mutex);
+
+	return 0;
+}
