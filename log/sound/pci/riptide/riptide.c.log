commit bf6f3d74c9594c3a684620d3d7418a73ee659288
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:30 2020 +0100

    ALSA: riptide: More constifications
    
    Apply const prefix to each lbus path table definition and its
    callers.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 625c85428955..b4f300281822 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -361,9 +361,9 @@ enum RT_CHANNEL_IDS {
 enum { SB_CMD = 0, MODEM_CMD, I2S_CMD0, I2S_CMD1, FM_CMD, MAX_CMD };
 
 struct lbuspath {
-	unsigned char *noconv;
-	unsigned char *stereo;
-	unsigned char *mono;
+	const unsigned char *noconv;
+	const unsigned char *stereo;
+	const unsigned char *mono;
 };
 
 struct cmdport {
@@ -464,7 +464,7 @@ struct sgd {			/* scatter gather desriptor */
 
 struct pcmhw {			/* pcm descriptor */
 	struct lbuspath paths;
-	unsigned char *lbuspath;
+	const unsigned char *lbuspath;
 	unsigned char source;
 	unsigned char intdec[2];
 	unsigned char mixer;
@@ -517,7 +517,7 @@ MODULE_DEVICE_TABLE(pci, snd_riptide_ids);
 /*
  */
 
-static unsigned char lbusin2out[E2SINK_MAX + 1][2] = {
+static const unsigned char lbusin2out[E2SINK_MAX + 1][2] = {
 	{NO_OUT, LS_NONE1}, {NO_OUT, LS_NONE2}, {NO_OUT, LS_NONE1}, {NO_OUT,
 								     LS_NONE2},
 	{NO_OUT, LS_NONE1}, {NO_OUT, LS_NONE2}, {NO_OUT, LS_NONE1}, {NO_OUT,
@@ -557,63 +557,63 @@ static unsigned char lbusin2out[E2SINK_MAX + 1][2] = {
 								     LS_NONE2},
 };
 
-static unsigned char lbus_play_opl3[] = {
+static const unsigned char lbus_play_opl3[] = {
 	DIGITAL_MIXER_IN0 + FM_MIXER, 0xff
 };
-static unsigned char lbus_play_modem[] = {
+static const unsigned char lbus_play_modem[] = {
 	DIGITAL_MIXER_IN0 + MODEM_MIXER, 0xff
 };
-static unsigned char lbus_play_i2s[] = {
+static const unsigned char lbus_play_i2s[] = {
 	INTER0_IN + I2S_INTDEC, DIGITAL_MIXER_IN0 + I2S_MIXER, 0xff
 };
-static unsigned char lbus_play_out[] = {
+static const unsigned char lbus_play_out[] = {
 	PDAC2ACLNK, 0xff
 };
-static unsigned char lbus_play_outhp[] = {
+static const unsigned char lbus_play_outhp[] = {
 	HNDSPK2ACLNK, 0xff
 };
-static unsigned char lbus_play_noconv1[] = {
+static const unsigned char lbus_play_noconv1[] = {
 	DIGITAL_MIXER_IN0, 0xff
 };
-static unsigned char lbus_play_stereo1[] = {
+static const unsigned char lbus_play_stereo1[] = {
 	INTER0_IN, DIGITAL_MIXER_IN0, 0xff
 };
-static unsigned char lbus_play_mono1[] = {
+static const unsigned char lbus_play_mono1[] = {
 	INTERM0_IN, DIGITAL_MIXER_IN0, 0xff
 };
-static unsigned char lbus_play_noconv2[] = {
+static const unsigned char lbus_play_noconv2[] = {
 	DIGITAL_MIXER_IN1, 0xff
 };
-static unsigned char lbus_play_stereo2[] = {
+static const unsigned char lbus_play_stereo2[] = {
 	INTER1_IN, DIGITAL_MIXER_IN1, 0xff
 };
-static unsigned char lbus_play_mono2[] = {
+static const unsigned char lbus_play_mono2[] = {
 	INTERM1_IN, DIGITAL_MIXER_IN1, 0xff
 };
-static unsigned char lbus_play_noconv3[] = {
+static const unsigned char lbus_play_noconv3[] = {
 	DIGITAL_MIXER_IN2, 0xff
 };
-static unsigned char lbus_play_stereo3[] = {
+static const unsigned char lbus_play_stereo3[] = {
 	INTER2_IN, DIGITAL_MIXER_IN2, 0xff
 };
-static unsigned char lbus_play_mono3[] = {
+static const unsigned char lbus_play_mono3[] = {
 	INTERM2_IN, DIGITAL_MIXER_IN2, 0xff
 };
-static unsigned char lbus_rec_noconv1[] = {
+static const unsigned char lbus_rec_noconv1[] = {
 	LBUS2ARM_FIFO5, 0xff
 };
-static unsigned char lbus_rec_stereo1[] = {
+static const unsigned char lbus_rec_stereo1[] = {
 	DECIM0_IN, LBUS2ARM_FIFO5, 0xff
 };
-static unsigned char lbus_rec_mono1[] = {
+static const unsigned char lbus_rec_mono1[] = {
 	DECIMM3_IN, LBUS2ARM_FIFO5, 0xff
 };
 
-static unsigned char play_ids[] = { 4, 1, 2, };
-static unsigned char play_sources[] = {
+static const unsigned char play_ids[] = { 4, 1, 2, };
+static const unsigned char play_sources[] = {
 	ARM2LBUS_FIFO4, ARM2LBUS_FIFO1, ARM2LBUS_FIFO2,
 };
-static struct lbuspath lbus_play_paths[] = {
+static const struct lbuspath lbus_play_paths[] = {
 	{
 	 .noconv = lbus_play_noconv1,
 	 .stereo = lbus_play_stereo1,
@@ -737,7 +737,7 @@ static int loadfirmware(struct cmdif *cif, const unsigned char *img,
 
 static void
 alloclbuspath(struct cmdif *cif, unsigned char source,
-	      unsigned char *path, unsigned char *mixer, unsigned char *s)
+	      const unsigned char *path, unsigned char *mixer, unsigned char *s)
 {
 	while (*path != 0xff) {
 		unsigned char sink, type;
@@ -765,7 +765,7 @@ alloclbuspath(struct cmdif *cif, unsigned char source,
 			}
 		}
 		if (*path++ & SPLIT_PATH) {
-			unsigned char *npath = path;
+			const unsigned char *npath = path;
 
 			while (*npath != 0xff)
 				npath++;
@@ -775,7 +775,7 @@ alloclbuspath(struct cmdif *cif, unsigned char source,
 }
 
 static void
-freelbuspath(struct cmdif *cif, unsigned char source, unsigned char *path)
+freelbuspath(struct cmdif *cif, unsigned char source, const unsigned char *path)
 {
 	while (*path != 0xff) {
 		unsigned char sink;
@@ -787,7 +787,7 @@ freelbuspath(struct cmdif *cif, unsigned char source, unsigned char *path)
 			source = lbusin2out[sink][0];
 		}
 		if (*path++ & SPLIT_PATH) {
-			unsigned char *npath = path;
+			const unsigned char *npath = path;
 
 			while (*npath != 0xff)
 				npath++;
@@ -1441,7 +1441,7 @@ static int snd_riptide_prepare(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct pcmhw *data = get_pcmhwdev(substream);
 	struct cmdif *cif = chip->cif;
-	unsigned char *lbuspath = NULL;
+	const unsigned char *lbuspath = NULL;
 	unsigned int rate, channels;
 	int err = 0;
 	snd_pcm_format_t format;

commit 51055da51d1e92bb089c9b9e0ecb1be69396f808
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:43 2020 +0100

    ALSA: pci: Constify snd_ac97_bus_ops definitions
    
    Now snd_ac97_bus() takes the const ops pointer, so we can define the
    snd_ac97_bus_ops locally as const as well for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-28-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 6617bc347bfb..625c85428955 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1963,7 +1963,7 @@ static int snd_riptide_mixer(struct snd_riptide *chip)
 	struct snd_ac97_bus *pbus;
 	struct snd_ac97_template ac97;
 	int err = 0;
-	static struct snd_ac97_bus_ops ops = {
+	static const struct snd_ac97_bus_ops ops = {
 		.write = snd_riptide_codec_write,
 		.read = snd_riptide_codec_read,
 	};

commit efb0ad25d370344e61bb4fca8c3b9c3c6047922e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:25 2020 +0100

    ALSA: pci: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index af6956e26c29..6617bc347bfb 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1824,7 +1824,7 @@ snd_riptide_create(struct snd_card *card, struct pci_dev *pci,
 	struct snd_riptide *chip;
 	struct riptideport *hwport;
 	int err;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free = snd_riptide_dev_free,
 	};
 

commit 3992f78f349f7f1565b43d244177f3975edb9aa1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:29 2019 +0100

    ALSA: riptide: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-31-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index be0283f8bda0..af6956e26c29 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1864,6 +1864,7 @@ snd_riptide_create(struct snd_card *card, struct pci_dev *pci,
 		return -EBUSY;
 	}
 	chip->irq = pci->irq;
+	card->sync_irq = chip->irq;
 	chip->device_id = pci->device;
 	pci_set_master(pci);
 	if ((err = snd_riptide_initialize(chip)) < 0) {

commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index b855de52e198..be0283f8bda0 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1656,7 +1656,6 @@ static int snd_riptide_capture_close(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_riptide_playback_ops = {
 	.open = snd_riptide_playback_open,
 	.close = snd_riptide_playback_close,
-	.ioctl = snd_pcm_lib_ioctl,
 	.hw_params = snd_riptide_hw_params,
 	.hw_free = snd_riptide_hw_free,
 	.prepare = snd_riptide_prepare,
@@ -1666,7 +1665,6 @@ static const struct snd_pcm_ops snd_riptide_playback_ops = {
 static const struct snd_pcm_ops snd_riptide_capture_ops = {
 	.open = snd_riptide_capture_open,
 	.close = snd_riptide_capture_close,
-	.ioctl = snd_pcm_lib_ioctl,
 	.hw_params = snd_riptide_hw_params,
 	.hw_free = snd_riptide_hw_free,
 	.prepare = snd_riptide_prepare,

commit 0dd323695c7b8dc33c6dc2d23bbe99a8ecd5d627
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:22 2019 +0100

    ALSA: riptide: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The superfluous snd_pcm_lib_malloc_pages() and
    snd_pcm_lib_free_pages() calls are dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-51-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index abcea86045ec..b855de52e198 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1558,8 +1558,7 @@ snd_riptide_hw_params(struct snd_pcm_substream *substream,
 		return err;
 	}
 	data->sgdbuf = (struct sgd *)sgdlist->area;
-	return snd_pcm_lib_malloc_pages(substream,
-					params_buffer_bytes(hw_params));
+	return 0;
 }
 
 static int snd_riptide_hw_free(struct snd_pcm_substream *substream)
@@ -1581,7 +1580,7 @@ static int snd_riptide_hw_free(struct snd_pcm_substream *substream)
 			data->sgdlist.area = NULL;
 		}
 	}
-	return snd_pcm_lib_free_pages(substream);
+	return 0;
 }
 
 static int snd_riptide_playback_open(struct snd_pcm_substream *substream)
@@ -1692,9 +1691,8 @@ static int snd_riptide_pcm(struct snd_riptide *chip, int device)
 	pcm->info_flags = 0;
 	strcpy(pcm->name, "RIPTIDE");
 	chip->pcm = pcm;
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
-					      &chip->pci->dev,
-					      64 * 1024, 128 * 1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
+				       &chip->pci->dev, 64 * 1024, 128 * 1024);
 	return 0;
 }
 

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index ac10d6f229d8..abcea86045ec 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1550,7 +1550,7 @@ snd_riptide_hw_params(struct snd_pcm_substream *substream,
 	if (sgdlist->area)
 		snd_dma_free_pages(sgdlist);
 	if ((err = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
-				       snd_dma_pci_data(chip->pci),
+				       &chip->pci->dev,
 				       sizeof(struct sgd) * (DESC_MAX_MASK + 1),
 				       sgdlist)) < 0) {
 		snd_printk(KERN_ERR "Riptide: failed to alloc %d dma bytes\n",
@@ -1693,7 +1693,7 @@ static int snd_riptide_pcm(struct snd_riptide *chip, int device)
 	strcpy(pcm->name, "RIPTIDE");
 	chip->pcm = pcm;
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
-					      snd_dma_pci_data(chip->pci),
+					      &chip->pci->dev,
 					      64 * 1024, 128 * 1024);
 	return 0;
 }

commit 16ccca11088c1bdd9311a2c630b453541305c48a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:50 2019 +0100

    ALSA: pci: Drop superfluous snd_pcm_sgbuf_ops_page
    
    snd_pcm_sgbuf_ops_page is no longer needed to be set explicitly to PCM
    page ops since the recent change in the PCM core (*).  Leaving it NULL
    should work as long as the preallocation has been done properly.
    
    This patch drops the redundant lines.
    
    (*) 7e8edae39fd1: ALSA: pcm: Handle special page mapping in the
                      default mmap handler
    
    Link: https://lore.kernel.org/r/20191105151856.10785-19-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 58771ae0ed63..ac10d6f229d8 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1661,7 +1661,6 @@ static const struct snd_pcm_ops snd_riptide_playback_ops = {
 	.hw_params = snd_riptide_hw_params,
 	.hw_free = snd_riptide_hw_free,
 	.prepare = snd_riptide_prepare,
-	.page = snd_pcm_sgbuf_ops_page,
 	.trigger = snd_riptide_trigger,
 	.pointer = snd_riptide_pointer,
 };
@@ -1672,7 +1671,6 @@ static const struct snd_pcm_ops snd_riptide_capture_ops = {
 	.hw_params = snd_riptide_hw_params,
 	.hw_free = snd_riptide_hw_free,
 	.prepare = snd_riptide_prepare,
-	.page = snd_pcm_sgbuf_ops_page,
 	.trigger = snd_riptide_trigger,
 	.pointer = snd_riptide_pointer,
 };

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 8d1a56a9bcfd..58771ae0ed63 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1,22 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *   Driver for the Conexant Riptide Soundchip
  *
  *	Copyright (c) 2004 Peter Gruber <nokos@gmx.net>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 /*
   History:

commit 47f2769b4b2e267cba135fc19c89c32d202b1415
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:01:39 2019 +0100

    ALSA: pci: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 1d431c8052d6..8d1a56a9bcfd 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1973,10 +1973,8 @@ snd_riptide_proc_read(struct snd_info_entry *entry,
 
 static void snd_riptide_proc_init(struct snd_riptide *chip)
 {
-	struct snd_info_entry *entry;
-
-	if (!snd_card_proc_new(chip->card, "riptide", &entry))
-		snd_info_set_text_ops(entry, chip, snd_riptide_proc_read);
+	snd_card_ro_proc_new(chip->card, "riptide", chip,
+			     snd_riptide_proc_read);
 }
 
 static int snd_riptide_mixer(struct snd_riptide *chip)

commit 17bc4815de586d001c82d0ddf75247283c3f002a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:02:51 2019 +0100

    ALSA: pci: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 23017e3bc76c..1d431c8052d6 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1158,7 +1158,6 @@ static int riptide_suspend(struct device *dev)
 
 	chip->in_suspend = 1;
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
-	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
 	return 0;
 }

commit be05e3de3a933156d472127f659d4473c461dcc5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 23:24:04 2018 +0200

    ALSA: riptide: Properly endian notations
    
    The SG descriptor of Riptide contains the little-endian values, hence
    we need to define with __le32 properly.  This fixes sparse warnings
    like:
      sound/pci/riptide/riptide.c:1112:40: warning: cast to restricted __le32
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 9d2b2ef15c6b..23017e3bc76c 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -470,10 +470,10 @@ struct snd_riptide {
 };
 
 struct sgd {			/* scatter gather desriptor */
-	u32 dwNextLink;
-	u32 dwSegPtrPhys;
-	u32 dwSegLen;
-	u32 dwStat_Ctl;
+	__le32 dwNextLink;
+	__le32 dwSegPtrPhys;
+	__le32 dwSegLen;
+	__le32 dwStat_Ctl;
 };
 
 struct pcmhw {			/* pcm descriptor */

commit 94dfee0c1a33baa974cba0bd8b83021b1d801297
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 23:19:37 2018 +0200

    ALSA: riptide: Fix PCM format type conversion
    
    The PCM format type is with __bitwise, hence it needs to be explicitly
    declared as snd_pcm_format_t, as warned by sparse:
      sound/pci/riptide/riptide.c:1028:34: warning: incorrect type in argument 1 (different base types)
      sound/pci/riptide/riptide.c:1028:34:    expected restricted snd_pcm_format_t [usertype] format
      sound/pci/riptide/riptide.c:1028:34:    got unsigned char [unsigned] format
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 44f3b48d47b1..9d2b2ef15c6b 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1017,7 +1017,7 @@ getsamplerate(struct cmdif *cif, unsigned char *intdec, unsigned int *rate)
 static int
 setsampleformat(struct cmdif *cif,
 		unsigned char mixer, unsigned char id,
-		unsigned char channels, unsigned char format)
+		unsigned char channels, snd_pcm_format_t format)
 {
 	unsigned char w, ch, sig, order;
 

commit 14ff46fd99077c3c15cbf38ab1795cbd0f16669e
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:24 2017 +0530

    ALSA: riptide: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index f067c76d77f8..44f3b48d47b1 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1315,7 +1315,7 @@ static int riptide_reset(struct cmdif *cif, struct snd_riptide *chip)
 	return 0;
 }
 
-static struct snd_pcm_hardware snd_riptide_playback = {
+static const struct snd_pcm_hardware snd_riptide_playback = {
 	.info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 		 SNDRV_PCM_INFO_BLOCK_TRANSFER |
 		 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID),
@@ -1334,7 +1334,7 @@ static struct snd_pcm_hardware snd_riptide_playback = {
 	.periods_max = 64,
 	.fifo_size = 0,
 };
-static struct snd_pcm_hardware snd_riptide_capture = {
+static const struct snd_pcm_hardware snd_riptide_capture = {
 	.info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 		 SNDRV_PCM_INFO_BLOCK_TRANSFER |
 		 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID),

commit 6192c41fc608b0a58d5540b015aa1672c266f3c5
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:30 2017 +0100

    Annotate hardware config module parameters in sound/pci/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in sound/pci/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jaroslav Kysela <perex@perex.cz>
    cc: Takashi Iwai <tiwai@suse.com>
    cc: alsa-devel@alsa-project.org

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 19c9df6b0f3d..f067c76d77f8 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -137,12 +137,12 @@ MODULE_PARM_DESC(id, "ID string for Riptide soundcard.");
 module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable Riptide soundcard.");
 #ifdef SUPPORT_JOYSTICK
-module_param_array(joystick_port, int, NULL, 0444);
+module_param_hw_array(joystick_port, int, ioport, NULL, 0444);
 MODULE_PARM_DESC(joystick_port, "Joystick port # for Riptide soundcard.");
 #endif
-module_param_array(mpu_port, int, NULL, 0444);
+module_param_hw_array(mpu_port, int, ioport, NULL, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU401 port # for Riptide driver.");
-module_param_array(opl3_port, int, NULL, 0444);
+module_param_hw_array(opl3_port, int, ioport, NULL, 0444);
 MODULE_PARM_DESC(opl3_port, "OPL3 port # for Riptide driver.");
 
 /*

commit b2fac0730347d591b528d8f0e4a9438c1bb6f558
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sat Nov 12 23:26:41 2016 +0100

    ALSA: pci: don't opencode IS_REACHABLE()
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index ada5f01d479c..19c9df6b0f3d 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -110,7 +110,7 @@
 #include <sound/opl3.h>
 #include <sound/initval.h>
 
-#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+#if IS_REACHABLE(CONFIG_GAMEPORT)
 #define SUPPORT_JOYSTICK 1
 #endif
 

commit 071f1344f47946dfcb511bf0fbc998dd9a83be29
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Sep 11 15:05:43 2016 +0200

    ALSA: pci: constify local structures
    
    For structure types defined in the same file or local header files, find
    top-level static structure declarations that have the following
    properties:
    1. Never reassigned.
    2. Address never taken
    3. Not passed to a top-level macro call
    4. No pointer or array-typed field passed to a function or stored in a
    variable.
    Declare structures having all of these properties as const.
    
    Done using Coccinelle.
    Based on a suggestion by Joe Perches <joe@perches.com>.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index ae41fcb89384..ada5f01d479c 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -644,7 +644,7 @@ static struct lbuspath lbus_play_paths[] = {
 	 .mono = lbus_play_mono3,
 	 },
 };
-static struct lbuspath lbus_rec_path = {
+static const struct lbuspath lbus_rec_path = {
 	.noconv = lbus_rec_noconv1,
 	.stereo = lbus_rec_stereo1,
 	.mono = lbus_rec_mono1,

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 067a91207d8e..ae41fcb89384 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1669,7 +1669,7 @@ static int snd_riptide_capture_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static struct snd_pcm_ops snd_riptide_playback_ops = {
+static const struct snd_pcm_ops snd_riptide_playback_ops = {
 	.open = snd_riptide_playback_open,
 	.close = snd_riptide_playback_close,
 	.ioctl = snd_pcm_lib_ioctl,
@@ -1680,7 +1680,7 @@ static struct snd_pcm_ops snd_riptide_playback_ops = {
 	.trigger = snd_riptide_trigger,
 	.pointer = snd_riptide_pointer,
 };
-static struct snd_pcm_ops snd_riptide_capture_ops = {
+static const struct snd_pcm_ops snd_riptide_capture_ops = {
 	.open = snd_riptide_capture_open,
 	.close = snd_riptide_capture_close,
 	.ioctl = snd_pcm_lib_ioctl,

commit cf7d7edc7a120fd5001f6dcc1e9f2c8e9c09e6c9
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Wed Jun 29 20:26:28 2016 +0530

    ALSA: riptide: Use DIV_ROUND_UP
    
    The kernel.h macro DIV_ROUND_UP performs the computation
    (((n) + (d) - 1) /(d)) but is perhaps more readable.
    
    The Coccinelle script used to make this change is as follows:
    @haskernel@
    @@
    
    #include <linux/kernel.h>
    
    @depends on haskernel@
    expression n,d;
    @@
    
    (
    - (n + d - 1) / d
    + DIV_ROUND_UP(n,d)
    |
    - (n + (d - 1)) / d
    + DIV_ROUND_UP(n,d)
    )
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 94639d6b5fb5..067a91207d8e 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1496,7 +1496,7 @@ static int snd_riptide_prepare(struct snd_pcm_substream *substream)
 		f = PAGE_SIZE;
 		while ((size + (f >> 1) - 1) <= (f << 7) && (f << 1) > period)
 			f = f >> 1;
-		pages = (size + f - 1) / f;
+		pages = DIV_ROUND_UP(size, f);
 		data->size = size;
 		data->pages = pages;
 		snd_printdd

commit e4940626defdf6c92da1052ad3f12741c1a28c90
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Feb 9 16:51:40 2015 +0300

    ALSA: off by one bug in snd_riptide_joystick_probe()
    
    The problem here is that we check:
    
            if (dev >= SNDRV_CARDS)
    
    Then we increment "dev".
    
           if (!joystick_port[dev++])
    
    Then we use it as an offset into a array with SNDRV_CARDS elements.
    
            if (!request_region(joystick_port[dev], 8, "Riptide gameport")) {
    
    This has 3 effects:
    1) If you use the module option to specify the joystick port then it has
       to be shifted one space over.
    2) The wrong error message will be printed on failure if you have over
       32 cards.
    3) Static checkers will correctly complain that are off by one.
    
    Fixes: db1005ec6ff8 ('ALSA: riptide - Fix joystick resource handling')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 29f28273b2cc..94639d6b5fb5 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -2011,32 +2011,43 @@ snd_riptide_joystick_probe(struct pci_dev *pci, const struct pci_device_id *id)
 {
 	static int dev;
 	struct gameport *gameport;
+	int ret;
 
 	if (dev >= SNDRV_CARDS)
 		return -ENODEV;
+
 	if (!enable[dev]) {
-		dev++;
-		return -ENOENT;
+		ret = -ENOENT;
+		goto inc_dev;
 	}
 
-	if (!joystick_port[dev++])
-		return 0;
+	if (!joystick_port[dev]) {
+		ret = 0;
+		goto inc_dev;
+	}
 
 	gameport = gameport_allocate_port();
-	if (!gameport)
-		return -ENOMEM;
+	if (!gameport) {
+		ret = -ENOMEM;
+		goto inc_dev;
+	}
 	if (!request_region(joystick_port[dev], 8, "Riptide gameport")) {
 		snd_printk(KERN_WARNING
 			   "Riptide: cannot grab gameport 0x%x\n",
 			   joystick_port[dev]);
 		gameport_free_port(gameport);
-		return -EBUSY;
+		ret = -EBUSY;
+		goto inc_dev;
 	}
 
 	gameport->io = joystick_port[dev];
 	gameport_register_port(gameport);
 	pci_set_drvdata(pci, gameport);
-	return 0;
+
+	ret = 0;
+inc_dev:
+	dev++;
+	return ret;
 }
 
 static void snd_riptide_joystick_remove(struct pci_dev *pci)

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index a1521047e619..29f28273b2cc 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -99,7 +99,7 @@
 #include <linux/firmware.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>

commit 9e5947465d72ef1b3a88104474ab2adf78837220
Merge: 624afe4dc9a0 3e41c9b5a1ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 11 11:26:48 2015 +0100

    Merge branch 'topic/pci-cleanup' into for-next

commit e066d85cc0f87c6e67bbbb7665de8b30e5ce11e4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 8 12:49:42 2015 +0100

    ALSA: riptide: Simplify PM callbacks
    
    This is a similar cleanup like the commit [3db084fd0af5: ALSA: fm801:
    PCI core handles power state for us].
    
    Since pci_set_power_state(), pci_save_state() and pci_restore_state()
    are already done in the PCI core side, so we don't need to it doubly.
    
    Also, pci_enable_device(), pci_disable_device() and pci_set_master()
    calls in PM callbacks are superfluous nowadays, too, so get rid of
    them as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 6abc2ac8fffb..7e922fa24de5 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1153,7 +1153,6 @@ static void riptide_handleirq(unsigned long dev_id)
 #ifdef CONFIG_PM_SLEEP
 static int riptide_suspend(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_riptide *chip = card->private_data;
 
@@ -1161,27 +1160,14 @@ static int riptide_suspend(struct device *dev)
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
-	pci_disable_device(pci);
-	pci_save_state(pci);
-	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
 static int riptide_resume(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_riptide *chip = card->private_data;
 
-	pci_set_power_state(pci, PCI_D0);
-	pci_restore_state(pci);
-	if (pci_enable_device(pci) < 0) {
-		printk(KERN_ERR "riptide: pci_enable_device failed, "
-		       "disabling device\n");
-		snd_card_disconnect(card);
-		return -EIO;
-	}
-	pci_set_master(pci);
 	snd_riptide_initialize(chip);
 	snd_ac97_resume(chip->ac97);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);

commit 15aded4c924ae149a38e639f421f5313125eea89
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Jan 2 12:24:52 2015 +0100

    ALSA: riptide: Remove always NULL parameter
    
    snd_riptide_pcm() takes a pointer to a pointer of a PCM where if this
    parameter is provided the newly allocated PCM is stored. All callers pass
    NULL though, so remove the parameter. This makes the code a bit cleaner and
    shorter.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 6abc2ac8fffb..121f2c09d7a7 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1706,14 +1706,11 @@ static struct snd_pcm_ops snd_riptide_capture_ops = {
 	.pointer = snd_riptide_pointer,
 };
 
-static int
-snd_riptide_pcm(struct snd_riptide *chip, int device, struct snd_pcm **rpcm)
+static int snd_riptide_pcm(struct snd_riptide *chip, int device)
 {
 	struct snd_pcm *pcm;
 	int err;
 
-	if (rpcm)
-		*rpcm = NULL;
 	if ((err =
 	     snd_pcm_new(chip->card, "RIPTIDE", device, PLAYBACK_SUBSTREAMS, 1,
 			 &pcm)) < 0)
@@ -1729,8 +1726,6 @@ snd_riptide_pcm(struct snd_riptide *chip, int device, struct snd_pcm **rpcm)
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
 					      snd_dma_pci_data(chip->pci),
 					      64 * 1024, 128 * 1024);
-	if (rpcm)
-		*rpcm = pcm;
 	return 0;
 }
 
@@ -2092,7 +2087,7 @@ snd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 	if (err < 0)
 		goto error;
 	card->private_data = chip;
-	err = snd_riptide_pcm(chip, 0, NULL);
+	err = snd_riptide_pcm(chip, 0);
 	if (err < 0)
 		goto error;
 	err = snd_riptide_mixer(chip);

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index f0315c3f7de4..6abc2ac8fffb 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -508,7 +508,7 @@ static int riptide_reset(struct cmdif *cif, struct snd_riptide *chip);
 /*
  */
 
-static DEFINE_PCI_DEVICE_TABLE(snd_riptide_ids) = {
+static const struct pci_device_id snd_riptide_ids[] = {
 	{ PCI_DEVICE(0x127a, 0x4310) },
 	{ PCI_DEVICE(0x127a, 0x4320) },
 	{ PCI_DEVICE(0x127a, 0x4330) },
@@ -517,7 +517,7 @@ static DEFINE_PCI_DEVICE_TABLE(snd_riptide_ids) = {
 };
 
 #ifdef SUPPORT_JOYSTICK
-static DEFINE_PCI_DEVICE_TABLE(snd_riptide_joystick_ids) = {
+static const struct pci_device_id snd_riptide_joystick_ids[] = {
 	{ PCI_DEVICE(0x127a, 0x4312) },
 	{ PCI_DEVICE(0x127a, 0x4322) },
 	{ PCI_DEVICE(0x127a, 0x4332) },

commit 47efe636adec37d6c259a69ee53d246cd4bba172
Author: Hans Wennborg <hans@hanshq.net>
Date:   Sun Aug 3 17:21:25 2014 -0700

    ALSA: riptide: fix %d confusingly prefixed with 0x in format strings
    
    Signed-off-by: Hans Wennborg <hans@hanshq.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index b4a8278241b1..f0315c3f7de4 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -941,7 +941,7 @@ setmixer(struct cmdif *cif, short num, unsigned short rval, unsigned short lval)
 	union cmdret rptr = CMDRET_ZERO;
 	int i = 0;
 
-	snd_printdd("sent mixer %d: 0x%d 0x%d\n", num, rval, lval);
+	snd_printdd("sent mixer %d: 0x%x 0x%x\n", num, rval, lval);
 	do {
 		SEND_SDGV(cif, num, num, rval, lval);
 		SEND_RDGV(cif, num, num, &rptr);
@@ -1080,7 +1080,7 @@ getmixer(struct cmdif *cif, short num, unsigned short *rval,
 		return -EIO;
 	*rval = rptr.retwords[0];
 	*lval = rptr.retwords[1];
-	snd_printdd("got mixer %d: 0x%d 0x%d\n", num, *rval, *lval);
+	snd_printdd("got mixer %d: 0x%x 0x%x\n", num, *rval, *lval);
 	return 0;
 }
 

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 56cc891e395e..b4a8278241b1 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1916,8 +1916,6 @@ snd_riptide_create(struct snd_card *card, struct pci_dev *pci,
 		return err;
 	}
 
-	snd_card_set_dev(card, &pci->dev);
-
 	*rchip = chip;
 	return 0;
 }
@@ -2086,7 +2084,8 @@ snd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 		return -ENOENT;
 	}
 
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
+			   0, &card);
 	if (err < 0)
 		return err;
 	err = snd_riptide_create(card, pci, &chip);

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 63c1c8041554..56cc891e395e 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -2066,7 +2066,6 @@ static void snd_riptide_joystick_remove(struct pci_dev *pci)
 	if (gameport) {
 		release_region(gameport->io, 8);
 		gameport_unregister_port(gameport);
-		pci_set_drvdata(pci, NULL);
 	}
 }
 #endif
@@ -2179,7 +2178,6 @@ snd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 static void snd_card_riptide_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 static struct pci_driver driver = {

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 7d291542c5ba..63c1c8041554 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1706,7 +1706,7 @@ static struct snd_pcm_ops snd_riptide_capture_ops = {
 	.pointer = snd_riptide_pointer,
 };
 
-static int __devinit
+static int
 snd_riptide_pcm(struct snd_riptide *chip, int device, struct snd_pcm **rpcm)
 {
 	struct snd_pcm *pcm;
@@ -1857,7 +1857,7 @@ static int snd_riptide_dev_free(struct snd_device *device)
 	return snd_riptide_free(chip);
 }
 
-static int __devinit
+static int
 snd_riptide_create(struct snd_card *card, struct pci_dev *pci,
 		   struct snd_riptide **rchip)
 {
@@ -1993,7 +1993,7 @@ snd_riptide_proc_read(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "\n");
 }
 
-static void __devinit snd_riptide_proc_init(struct snd_riptide *chip)
+static void snd_riptide_proc_init(struct snd_riptide *chip)
 {
 	struct snd_info_entry *entry;
 
@@ -2001,7 +2001,7 @@ static void __devinit snd_riptide_proc_init(struct snd_riptide *chip)
 		snd_info_set_text_ops(entry, chip, snd_riptide_proc_read);
 }
 
-static int __devinit snd_riptide_mixer(struct snd_riptide *chip)
+static int snd_riptide_mixer(struct snd_riptide *chip)
 {
 	struct snd_ac97_bus *pbus;
 	struct snd_ac97_template ac97;
@@ -2027,7 +2027,7 @@ static int __devinit snd_riptide_mixer(struct snd_riptide *chip)
 
 #ifdef SUPPORT_JOYSTICK
 
-static int __devinit
+static int
 snd_riptide_joystick_probe(struct pci_dev *pci, const struct pci_device_id *id)
 {
 	static int dev;
@@ -2060,7 +2060,7 @@ snd_riptide_joystick_probe(struct pci_dev *pci, const struct pci_device_id *id)
 	return 0;
 }
 
-static void __devexit snd_riptide_joystick_remove(struct pci_dev *pci)
+static void snd_riptide_joystick_remove(struct pci_dev *pci)
 {
 	struct gameport *gameport = pci_get_drvdata(pci);
 	if (gameport) {
@@ -2071,7 +2071,7 @@ static void __devexit snd_riptide_joystick_remove(struct pci_dev *pci)
 }
 #endif
 
-static int __devinit
+static int
 snd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 {
 	static int dev;
@@ -2176,7 +2176,7 @@ snd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 	return err;
 }
 
-static void __devexit snd_card_riptide_remove(struct pci_dev *pci)
+static void snd_card_riptide_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -2186,7 +2186,7 @@ static struct pci_driver driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_riptide_ids,
 	.probe = snd_card_riptide_probe,
-	.remove = __devexit_p(snd_card_riptide_remove),
+	.remove = snd_card_riptide_remove,
 	.driver = {
 		.pm = RIPTIDE_PM_OPS,
 	},
@@ -2197,7 +2197,7 @@ static struct pci_driver joystick_driver = {
 	.name = KBUILD_MODNAME "-joystick",
 	.id_table = snd_riptide_joystick_ids,
 	.probe = snd_riptide_joystick_probe,
-	.remove = __devexit_p(snd_riptide_joystick_remove),
+	.remove = snd_riptide_joystick_remove,
 };
 #endif
 

commit c7561cd80469f2fe4a6be0984db57832ee7f2a3b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 14 18:12:04 2012 +0200

    ALSA: PCI: Replace CONFIG_PM with CONFIG_PM_SLEEP
    
    Otherwise we may get compile warnings due to unused functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 760ee467cd9a..7d291542c5ba 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -464,7 +464,7 @@ struct snd_riptide {
 
 	unsigned long received_irqs;
 	unsigned long handled_irqs;
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	int in_suspend;
 #endif
 };
@@ -1150,7 +1150,7 @@ static void riptide_handleirq(unsigned long dev_id)
 	}
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int riptide_suspend(struct device *dev)
 {
 	struct pci_dev *pci = to_pci_dev(dev);
@@ -1193,7 +1193,7 @@ static SIMPLE_DEV_PM_OPS(riptide_pm, riptide_suspend, riptide_resume);
 #define RIPTIDE_PM_OPS	&riptide_pm
 #else
 #define RIPTIDE_PM_OPS	NULL
-#endif /* CONFIG_PM */
+#endif /* CONFIG_PM_SLEEP */
 
 static int try_to_load_firmware(struct cmdif *cif, struct snd_riptide *chip)
 {

commit 68cb2b559278858ef9f3a7722f95df88797c7840
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 15:20:37 2012 +0200

    ALSA: Convert to new pm_ops for PCI drivers
    
    Straightforward conversion to the new pm_ops from the legacy
    suspend/resume ops.
    
    Since we change vx222, vx_core and vxpocket have to be converted,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index cbeb3f77350c..760ee467cd9a 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1151,9 +1151,10 @@ static void riptide_handleirq(unsigned long dev_id)
 }
 
 #ifdef CONFIG_PM
-static int riptide_suspend(struct pci_dev *pci, pm_message_t state)
+static int riptide_suspend(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_riptide *chip = card->private_data;
 
 	chip->in_suspend = 1;
@@ -1162,13 +1163,14 @@ static int riptide_suspend(struct pci_dev *pci, pm_message_t state)
 	snd_ac97_suspend(chip->ac97);
 	pci_disable_device(pci);
 	pci_save_state(pci);
-	pci_set_power_state(pci, pci_choose_state(pci, state));
+	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
-static int riptide_resume(struct pci_dev *pci)
+static int riptide_resume(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_riptide *chip = card->private_data;
 
 	pci_set_power_state(pci, PCI_D0);
@@ -1186,7 +1188,12 @@ static int riptide_resume(struct pci_dev *pci)
 	chip->in_suspend = 0;
 	return 0;
 }
-#endif
+
+static SIMPLE_DEV_PM_OPS(riptide_pm, riptide_suspend, riptide_resume);
+#define RIPTIDE_PM_OPS	&riptide_pm
+#else
+#define RIPTIDE_PM_OPS	NULL
+#endif /* CONFIG_PM */
 
 static int try_to_load_firmware(struct cmdif *cif, struct snd_riptide *chip)
 {
@@ -2180,10 +2187,9 @@ static struct pci_driver driver = {
 	.id_table = snd_riptide_ids,
 	.probe = snd_card_riptide_probe,
 	.remove = __devexit_p(snd_card_riptide_remove),
-#ifdef CONFIG_PM
-	.suspend = riptide_suspend,
-	.resume = riptide_resume,
-#endif
+	.driver = {
+		.pm = RIPTIDE_PM_OPS,
+	},
 };
 
 #ifdef SUPPORT_JOYSTICK

commit 507230c9997ef47147818508108b97b3e189826f
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Mon Apr 9 22:52:10 2012 +0200

    ALSA: riptide: remove redundant NULL test before release_firmware()
    
    release_firmware() deals gracefully with NULL pointers, no need to check first.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 0481d94aac9b..cbeb3f77350c 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1837,8 +1837,7 @@ static int snd_riptide_free(struct snd_riptide *chip)
 	}
 	if (chip->irq >= 0)
 		free_irq(chip->irq, chip);
-	if (chip->fw_entry)
-		release_firmware(chip->fw_entry);
+	release_firmware(chip->fw_entry);
 	release_and_free_resource(chip->res_port);
 	kfree(chip);
 	return 0;

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index dcbedd33a629..0481d94aac9b 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -122,7 +122,7 @@ MODULE_FIRMWARE("riptide.hex");
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;
 
 #ifdef SUPPORT_JOYSTICK
 static int joystick_port[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS - 1)] = 0x200 };

commit da155d5b40587815a4397e1a69382fe2366d940b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 12:38:28 2011 -0400

    sound: Add module.h to the previously silent sound users
    
    Lots of sound drivers were getting module.h via the implicit presence
    of it in <linux/device.h> but we are going to clean that up.  So
    fix up those users now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 88cc776aa38b..dcbedd33a629 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -98,6 +98,7 @@
 #include <linux/device.h>
 #include <linux/firmware.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <asm/io.h>
 #include <sound/core.h>
 #include <sound/info.h>

commit dba8b46992c55946d3b092934f581a343403118f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Sep 13 11:24:41 2011 +0200

    ALSA: mpu401: clean up interrupt specification
    
    The semantics of snd_mpu401_uart_new()'s interrupt parameters are
    somewhat counterintuitive:  To prevent the function from allocating its
    own interrupt, either the irq number must be invalid, or the irq_flags
    parameter must be zero.  At the same time, the irq parameter being
    invalid specifies that the mpu401 code has to work without an interrupt
    allocated by the caller.  This implies that, if there is an interrupt
    and it is allocated by the caller, the irq parameter must be set to
    a valid-looking number which then isn't actually used.
    
    With the removal of IRQF_DISABLED, zero becomes a valid irq_flags value,
    which forces us to handle the parameters differently.
    
    This patch introduces a new flag MPU401_INFO_IRQ_HOOK for when the
    device interrupt is handled by the caller, and makes the allocation of
    the interrupt to depend only on the irq parameter.  As suggested by
    Takashi, the irq_flags parameter was dropped because, when used, it had
    the constant value IRQF_DISABLED.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index e34ae14908b3..88cc776aa38b 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -2109,7 +2109,7 @@ snd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 		val = mpu_port[dev];
 		pci_write_config_word(chip->pci, PCI_EXT_MPU_Base, val);
 		err = snd_mpu401_uart_new(card, 0, MPU401_HW_RIPTIDE,
-					  val, 0, chip->irq, 0,
+					  val, MPU401_INFO_IRQ_HOOK, -1,
 					  &chip->rmidi);
 		if (err < 0)
 			snd_printk(KERN_WARNING

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 91c0cb69d306..e34ae14908b3 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1890,7 +1890,7 @@ snd_riptide_create(struct snd_card *card, struct pci_dev *pci,
 	UNSET_AIE(hwport);
 
 	if (request_irq(pci->irq, snd_riptide_interrupt, IRQF_SHARED,
-			"RIPTIDE", chip)) {
+			KBUILD_MODNAME, chip)) {
 		snd_printk(KERN_ERR "Riptide: unable to grab IRQ %d\n",
 			   pci->irq);
 		snd_riptide_free(chip);

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index ad5202efd7a9..91c0cb69d306 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -2176,7 +2176,7 @@ static void __devexit snd_card_riptide_remove(struct pci_dev *pci)
 }
 
 static struct pci_driver driver = {
-	.name = "RIPTIDE",
+	.name = KBUILD_MODNAME,
 	.id_table = snd_riptide_ids,
 	.probe = snd_card_riptide_probe,
 	.remove = __devexit_p(snd_card_riptide_remove),
@@ -2188,7 +2188,7 @@ static struct pci_driver driver = {
 
 #ifdef SUPPORT_JOYSTICK
 static struct pci_driver joystick_driver = {
-	.name = "Riptide Joystick",
+	.name = KBUILD_MODNAME "-joystick",
 	.id_table = snd_riptide_joystick_ids,
 	.probe = snd_riptide_joystick_probe,
 	.remove = __devexit_p(snd_riptide_joystick_remove),

commit a5ba6beb839cfa288960c92cd2668a2601c24dda
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Aug 16 08:08:48 2010 +0200

    ALSA: riptide - Fix detection / load of firmware files
    
    The detection and loading of firmeware on riptide driver has been broken
    due to rewrite of some codes, checking the presense wrongly.
    This patch fixes the logic again.
    
    Reference: kernel bug 16596
            https://bugzilla.kernel.org/show_bug.cgi?id=16596
    
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index f64fb7d988cb..ad5202efd7a9 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1224,15 +1224,14 @@ static int try_to_load_firmware(struct cmdif *cif, struct snd_riptide *chip)
 		    firmware.firmware.ASIC, firmware.firmware.CODEC,
 		    firmware.firmware.AUXDSP, firmware.firmware.PROG);
 
+	if (!chip)
+		return 1;
+
 	for (i = 0; i < FIRMWARE_VERSIONS; i++) {
 		if (!memcmp(&firmware_versions[i], &firmware, sizeof(firmware)))
-			break;
-	}
-	if (i >= FIRMWARE_VERSIONS)
-		return 0; /* no match */
+			return 1; /* OK */
 
-	if (!chip)
-		return 1; /* OK */
+	}
 
 	snd_printdd("Writing Firmware\n");
 	if (!chip->fw_entry) {

commit 68bf57001f4995a25ca65f3711ff05b6ea25e8b6
Author: Kulikov Vasiliy <segooon@gmail.com>
Date:   Fri Jul 16 20:15:59 2010 +0400

    ALSA: riptide: check kzalloc() result
    
    If kzalloc() fails exit with -ENOMEM.
    
    Signed-off-by: Kulikov Vasiliy <segooon@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 59d79962f236..f64fb7d988cb 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1615,7 +1615,10 @@ static int snd_riptide_playback_open(struct snd_pcm_substream *substream)
 
 	chip->playback_substream[sub_num] = substream;
 	runtime->hw = snd_riptide_playback;
+
 	data = kzalloc(sizeof(struct pcmhw), GFP_KERNEL);
+	if (data == NULL)
+		return -ENOMEM;
 	data->paths = lbus_play_paths[sub_num];
 	data->id = play_ids[sub_num];
 	data->source = play_sources[sub_num];
@@ -1635,7 +1638,10 @@ static int snd_riptide_capture_open(struct snd_pcm_substream *substream)
 
 	chip->capture_substream = substream;
 	runtime->hw = snd_riptide_capture;
+
 	data = kzalloc(sizeof(struct pcmhw), GFP_KERNEL);
+	if (data == NULL)
+		return -ENOMEM;
 	data->paths = lbus_rec_path;
 	data->id = PADC;
 	data->source = ACLNK2PADC;

commit c9ff921abecda352e987a6aae169118a3fc9aa5d
Author: Andy Shevchenko <ext-andriy.shevchenko@nokia.com>
Date:   Tue Jun 15 17:26:28 2010 +0300

    ALSA: alsa: riptide: don't use own hex_to_bin() method
    
    Signed-off-by: Andy Shevchenko <ext-andriy.shevchenko@nokia.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index ad4462677615..59d79962f236 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -97,6 +97,7 @@
 #include <linux/gameport.h>
 #include <linux/device.h>
 #include <linux/firmware.h>
+#include <linux/kernel.h>
 #include <asm/io.h>
 #include <sound/core.h>
 #include <sound/info.h>
@@ -667,13 +668,12 @@ static u32 atoh(const unsigned char *in, unsigned int len)
 	unsigned char c;
 
 	while (len) {
+		int value;
+
 		c = in[len - 1];
-		if ((c >= '0') && (c <= '9'))
-			sum += mult * (c - '0');
-		else if ((c >= 'A') && (c <= 'F'))
-			sum += mult * (c - ('A' - 10));
-		else if ((c >= 'a') && (c <= 'f'))
-			sum += mult * (c - ('a' - 10));
+		value = hex_to_bin(c);
+		if (value >= 0)
+			sum += mult * value;
 		mult *= 16;
 		--len;
 	}

commit 282572b5ab99cf27073210ca60b80dd085e1a469
Author: Dan Carpenter <error27@gmail.com>
Date:   Wed Mar 3 10:13:49 2010 +0300

    ALSA: riptide: clean up while loop
    
    If getpaths() returned an odd number this would be a buffer under-run and an
    endless loop.  It turns out that getpaths() can only return even numbers, but
    let's make it easy for people auditing code.  With the new code you don't
    need to look at getpaths().
    
    This silences a smatch warning.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 960a227eb653..ad4462677615 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1974,9 +1974,9 @@ snd_riptide_proc_read(struct snd_info_entry *entry,
 	}
 	snd_iprintf(buffer, "Paths:\n");
 	i = getpaths(cif, p);
-	while (i--) {
-		snd_iprintf(buffer, "%x->%x ", p[i - 1], p[i]);
-		i--;
+	while (i >= 2) {
+		i -= 2;
+		snd_iprintf(buffer, "%x->%x ", p[i], p[i + 1]);
 	}
 	snd_iprintf(buffer, "\n");
 }

commit 7fb3a069bc5d3577409c2ae89f89cd264ff85816
Merge: 291186e049d7 9d3415a8cc76
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 17 14:24:46 2010 +0100

    Merge branch 'fix/misc' into topic/misc
    
    Conflicts:
            sound/pci/hda/patch_realtek.c

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index b5ca02e2038c..bb08a2855fce 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -506,7 +506,7 @@ static int riptide_reset(struct cmdif *cif, struct snd_riptide *chip);
 /*
  */
 
-static struct pci_device_id snd_riptide_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_riptide_ids) = {
 	{ PCI_DEVICE(0x127a, 0x4310) },
 	{ PCI_DEVICE(0x127a, 0x4320) },
 	{ PCI_DEVICE(0x127a, 0x4330) },
@@ -515,7 +515,7 @@ static struct pci_device_id snd_riptide_ids[] = {
 };
 
 #ifdef SUPPORT_JOYSTICK
-static struct pci_device_id snd_riptide_joystick_ids[] __devinitdata = {
+static DEFINE_PCI_DEVICE_TABLE(snd_riptide_joystick_ids) = {
 	{ PCI_DEVICE(0x127a, 0x4312) },
 	{ PCI_DEVICE(0x127a, 0x4322) },
 	{ PCI_DEVICE(0x127a, 0x4332) },

commit 9980c6209ebc2a02eb3ca51a4fae1e17f645c868
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Sun Dec 27 22:26:47 2009 +0100

    ALSA: test off by one in setsamplerate()
    
    With `while (i++ < MAX_WRITE_RETRY)' i reaches MAX_WRITE_RETRY + 1 after the loop
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index b5ca02e2038c..e66ef2b69b5d 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1058,7 +1058,7 @@ setsamplerate(struct cmdif *cif, unsigned char *intdec, unsigned int rate)
 				 rptr.retwords[2] != M &&
 				 rptr.retwords[3] != N &&
 				 i++ < MAX_WRITE_RETRY);
-			if (i == MAX_WRITE_RETRY) {
+			if (i > MAX_WRITE_RETRY) {
 				snd_printdd("sent samplerate %d: %d failed\n",
 					    *intdec, rate);
 				return -EIO;

commit cb65c8732a50f8a145d36dbdac026a1789ad1587
Author: Jaswinder Singh Rajput <jaswinder@kernel.org>
Date:   Wed Jul 15 16:45:40 2009 +0530

    ALSA: riptide -  proper handling of pci_register_driver for joystick
    
    We need to check returning error for pci_register_driver(&joystick_driver)
    
    On failure, we should unregister formerly registered audio drivers
    
    This also fixed the compiler warning :
    
      CC [M]  sound/pci/riptide/riptide.o
     sound/pci/riptide/riptide.c: In function ‘alsa_card_riptide_init’:
     sound/pci/riptide/riptide.c:2200: warning: ignoring return value of ‘__pci_register_driver’, declared with attribute warn_unused_result
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 235a71e5ac8d..b5ca02e2038c 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -2197,9 +2197,12 @@ static int __init alsa_card_riptide_init(void)
 	if (err < 0)
 		return err;
 #if defined(SUPPORT_JOYSTICK)
-	pci_register_driver(&joystick_driver);
+	err = pci_register_driver(&joystick_driver);
+	/* On failure unregister formerly registered audio driver */
+	if (err < 0)
+		pci_unregister_driver(&driver);
 #endif
-	return 0;
+	return err;
 }
 
 static void __exit alsa_card_riptide_exit(void)

commit db1005ec6ff8f250bccbc87387a955078891bfe4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 26 13:55:42 2009 +0200

    ALSA: riptide - Fix joystick resource handling
    
    The current code doesn't handle the multiple gameports properly,
    and uses unnecessary global static variables to store the data.
    This patch changes the probe / remove routines to use the driver
    data assigned to the dedicated pci device, and adds the support of
    multiple devices.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 460be038f9c7..235a71e5ac8d 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -2014,14 +2014,12 @@ static int __devinit snd_riptide_mixer(struct snd_riptide *chip)
 }
 
 #ifdef SUPPORT_JOYSTICK
-static int have_joystick;
-static struct pci_dev *riptide_gameport_pci;
-static struct gameport *riptide_gameport;
 
 static int __devinit
 snd_riptide_joystick_probe(struct pci_dev *pci, const struct pci_device_id *id)
 {
 	static int dev;
+	struct gameport *gameport;
 
 	if (dev >= SNDRV_CARDS)
 		return -ENODEV;
@@ -2030,36 +2028,33 @@ snd_riptide_joystick_probe(struct pci_dev *pci, const struct pci_device_id *id)
 		return -ENOENT;
 	}
 
-	if (joystick_port[dev]) {
-		riptide_gameport = gameport_allocate_port();
-		if (riptide_gameport) {
-			if (!request_region
-			    (joystick_port[dev], 8, "Riptide gameport")) {
-				snd_printk(KERN_WARNING
-					   "Riptide: cannot grab gameport 0x%x\n",
-					   joystick_port[dev]);
-				gameport_free_port(riptide_gameport);
-				riptide_gameport = NULL;
-			} else {
-				riptide_gameport_pci = pci;
-				riptide_gameport->io = joystick_port[dev];
-				gameport_register_port(riptide_gameport);
-			}
-		}
+	if (!joystick_port[dev++])
+		return 0;
+
+	gameport = gameport_allocate_port();
+	if (!gameport)
+		return -ENOMEM;
+	if (!request_region(joystick_port[dev], 8, "Riptide gameport")) {
+		snd_printk(KERN_WARNING
+			   "Riptide: cannot grab gameport 0x%x\n",
+			   joystick_port[dev]);
+		gameport_free_port(gameport);
+		return -EBUSY;
 	}
-	dev++;
+
+	gameport->io = joystick_port[dev];
+	gameport_register_port(gameport);
+	pci_set_drvdata(pci, gameport);
 	return 0;
 }
 
 static void __devexit snd_riptide_joystick_remove(struct pci_dev *pci)
 {
-	if (riptide_gameport) {
-		if (riptide_gameport_pci == pci) {
-			release_region(riptide_gameport->io, 8);
-			riptide_gameport_pci = NULL;
-			gameport_unregister_port(riptide_gameport);
-			riptide_gameport = NULL;
-		}
+	struct gameport *gameport = pci_get_drvdata(pci);
+	if (gameport) {
+		release_region(gameport->io, 8);
+		gameport_unregister_port(gameport);
+		pci_set_drvdata(pci, NULL);
 	}
 }
 #endif
@@ -2198,14 +2193,11 @@ static struct pci_driver joystick_driver = {
 static int __init alsa_card_riptide_init(void)
 {
 	int err;
-	if ((err = pci_register_driver(&driver)) < 0)
+	err = pci_register_driver(&driver);
+	if (err < 0)
 		return err;
 #if defined(SUPPORT_JOYSTICK)
-	if (pci_register_driver(&joystick_driver) < 0) {
-		have_joystick = 0;
-		snd_printk(KERN_INFO "no joystick found\n");
-	} else
-		have_joystick = 1;
+	pci_register_driver(&joystick_driver);
 #endif
 	return 0;
 }
@@ -2214,8 +2206,7 @@ static void __exit alsa_card_riptide_exit(void)
 {
 	pci_unregister_driver(&driver);
 #if defined(SUPPORT_JOYSTICK)
-	if (have_joystick)
-		pci_unregister_driver(&joystick_driver);
+	pci_unregister_driver(&joystick_driver);
 #endif
 }
 

commit a693a26fe0807c3c406d6b5295d222b646677288
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 26 12:58:58 2009 +0200

    ALSA: riptide - Code clean up
    
    A code clean up, coding style fixes.
    The firmware loading routine is split to an own function to improve
    the readability.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index e51a5ef1954d..460be038f9c7 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -507,41 +507,19 @@ static int riptide_reset(struct cmdif *cif, struct snd_riptide *chip);
  */
 
 static struct pci_device_id snd_riptide_ids[] = {
-	{
-	 .vendor = 0x127a,.device = 0x4310,
-	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
-	 },
-	{
-	 .vendor = 0x127a,.device = 0x4320,
-	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
-	 },
-	{
-	 .vendor = 0x127a,.device = 0x4330,
-	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
-	 },
-	{
-	 .vendor = 0x127a,.device = 0x4340,
-	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
-	 },
+	{ PCI_DEVICE(0x127a, 0x4310) },
+	{ PCI_DEVICE(0x127a, 0x4320) },
+	{ PCI_DEVICE(0x127a, 0x4330) },
+	{ PCI_DEVICE(0x127a, 0x4340) },
 	{0,},
 };
 
 #ifdef SUPPORT_JOYSTICK
 static struct pci_device_id snd_riptide_joystick_ids[] __devinitdata = {
-	{
-	 .vendor = 0x127a,.device = 0x4312,
-	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
-	 },
-	{
-	 .vendor = 0x127a,.device = 0x4322,
-	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
-	 },
-	{.vendor = 0x127a,.device = 0x4332,
-	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
-	 },
-	{.vendor = 0x127a,.device = 0x4342,
-	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
-	 },
+	{ PCI_DEVICE(0x127a, 0x4312) },
+	{ PCI_DEVICE(0x127a, 0x4322) },
+	{ PCI_DEVICE(0x127a, 0x4332) },
+	{ PCI_DEVICE(0x127a, 0x4342) },
 	{0,},
 };
 #endif
@@ -1209,12 +1187,79 @@ static int riptide_resume(struct pci_dev *pci)
 }
 #endif
 
+static int try_to_load_firmware(struct cmdif *cif, struct snd_riptide *chip)
+{
+	union firmware_version firmware = { .ret = CMDRET_ZERO };
+	int i, timeout, err;
+
+	for (i = 0; i < 2; i++) {
+		WRITE_PORT_ULONG(cif->hwport->port[i].data1, 0);
+		WRITE_PORT_ULONG(cif->hwport->port[i].data2, 0);
+	}
+	SET_GRESET(cif->hwport);
+	udelay(100);
+	UNSET_GRESET(cif->hwport);
+	udelay(100);
+
+	for (timeout = 100000; --timeout; udelay(10)) {
+		if (IS_READY(cif->hwport) && !IS_GERR(cif->hwport))
+			break;
+	}
+	if (!timeout) {
+		snd_printk(KERN_ERR
+			   "Riptide: device not ready, audio status: 0x%x "
+			   "ready: %d gerr: %d\n",
+			   READ_AUDIO_STATUS(cif->hwport),
+			   IS_READY(cif->hwport), IS_GERR(cif->hwport));
+		return -EIO;
+	} else {
+		snd_printdd
+			("Riptide: audio status: 0x%x ready: %d gerr: %d\n",
+			 READ_AUDIO_STATUS(cif->hwport),
+			 IS_READY(cif->hwport), IS_GERR(cif->hwport));
+	}
+
+	SEND_GETV(cif, &firmware.ret);
+	snd_printdd("Firmware version: ASIC: %d CODEC %d AUXDSP %d PROG %d\n",
+		    firmware.firmware.ASIC, firmware.firmware.CODEC,
+		    firmware.firmware.AUXDSP, firmware.firmware.PROG);
+
+	for (i = 0; i < FIRMWARE_VERSIONS; i++) {
+		if (!memcmp(&firmware_versions[i], &firmware, sizeof(firmware)))
+			break;
+	}
+	if (i >= FIRMWARE_VERSIONS)
+		return 0; /* no match */
+
+	if (!chip)
+		return 1; /* OK */
+
+	snd_printdd("Writing Firmware\n");
+	if (!chip->fw_entry) {
+		err = request_firmware(&chip->fw_entry, "riptide.hex",
+				       &chip->pci->dev);
+		if (err) {
+			snd_printk(KERN_ERR
+				   "Riptide: Firmware not available %d\n", err);
+			return -EIO;
+		}
+	}
+	err = loadfirmware(cif, chip->fw_entry->data, chip->fw_entry->size);
+	if (err) {
+		snd_printk(KERN_ERR
+			   "Riptide: Could not load firmware %d\n", err);
+		return err;
+	}
+
+	chip->firmware = firmware;
+
+	return 1; /* OK */
+}
+
 static int riptide_reset(struct cmdif *cif, struct snd_riptide *chip)
 {
-	int timeout, tries;
 	union cmdret rptr = CMDRET_ZERO;
-	union firmware_version firmware;
-	int i, j, err, has_firmware;
+	int err, tries;
 
 	if (!cif)
 		return -EINVAL;
@@ -1227,75 +1272,11 @@ static int riptide_reset(struct cmdif *cif, struct snd_riptide *chip)
 	cif->is_reset = 0;
 
 	tries = RESET_TRIES;
-	has_firmware = 0;
-	while (has_firmware == 0 && tries-- > 0) {
-		for (i = 0; i < 2; i++) {
-			WRITE_PORT_ULONG(cif->hwport->port[i].data1, 0);
-			WRITE_PORT_ULONG(cif->hwport->port[i].data2, 0);
-		}
-		SET_GRESET(cif->hwport);
-		udelay(100);
-		UNSET_GRESET(cif->hwport);
-		udelay(100);
-
-		for (timeout = 100000; --timeout; udelay(10)) {
-			if (IS_READY(cif->hwport) && !IS_GERR(cif->hwport))
-				break;
-		}
-		if (timeout == 0) {
-			snd_printk(KERN_ERR
-				   "Riptide: device not ready, audio status: 0x%x ready: %d gerr: %d\n",
-				   READ_AUDIO_STATUS(cif->hwport),
-				   IS_READY(cif->hwport), IS_GERR(cif->hwport));
-			return -EIO;
-		} else {
-			snd_printdd
-			    ("Riptide: audio status: 0x%x ready: %d gerr: %d\n",
-			     READ_AUDIO_STATUS(cif->hwport),
-			     IS_READY(cif->hwport), IS_GERR(cif->hwport));
-		}
-
-		SEND_GETV(cif, &rptr);
-		for (i = 0; i < 4; i++)
-			firmware.ret.retwords[i] = rptr.retwords[i];
-
-		snd_printdd
-		    ("Firmware version: ASIC: %d CODEC %d AUXDSP %d PROG %d\n",
-		     firmware.firmware.ASIC, firmware.firmware.CODEC,
-		     firmware.firmware.AUXDSP, firmware.firmware.PROG);
-
-		for (j = 0; j < FIRMWARE_VERSIONS; j++) {
-			has_firmware = 1;
-			for (i = 0; i < 4; i++) {
-				if (firmware_versions[j].ret.retwords[i] !=
-				    firmware.ret.retwords[i])
-					has_firmware = 0;
-			}
-			if (has_firmware)
-				break;
-		}
-
-		if (chip != NULL && has_firmware == 0) {
-			snd_printdd("Writing Firmware\n");
-			if (!chip->fw_entry) {
-				if ((err =
-				     request_firmware(&chip->fw_entry,
-						      "riptide.hex",
-						      &chip->pci->dev)) != 0) {
-					snd_printk(KERN_ERR
-						   "Riptide: Firmware not available %d\n",
-						   err);
-					return -EIO;
-				}
-			}
-			err = loadfirmware(cif, chip->fw_entry->data,
-					   chip->fw_entry->size);
-			if (err)
-				snd_printk(KERN_ERR
-					   "Riptide: Could not load firmware %d\n",
-					   err);
-		}
-	}
+	do {
+		err = try_to_load_firmware(cif, chip);
+		if (err < 0)
+			return err;
+	} while (!err && --tries);
 
 	SEND_SACR(cif, 0, AC97_RESET);
 	SEND_RACR(cif, AC97_RESET, &rptr);
@@ -1337,11 +1318,6 @@ static int riptide_reset(struct cmdif *cif, struct snd_riptide *chip)
 	SET_AIE(cif->hwport);
 	SET_AIACK(cif->hwport);
 	cif->is_reset = 1;
-	if (chip) {
-		for (i = 0; i < 4; i++)
-			chip->firmware.ret.retwords[i] =
-			    firmware.ret.retwords[i];
-	}
 
 	return 0;
 }
@@ -2094,8 +2070,8 @@ snd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 	static int dev;
 	struct snd_card *card;
 	struct snd_riptide *chip;
-	unsigned short addr;
-	int err = 0;
+	unsigned short val;
+	int err;
 
 	if (dev >= SNDRV_CARDS)
 		return -ENODEV;
@@ -2107,60 +2083,63 @@ snd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
 	if (err < 0)
 		return err;
-	if ((err = snd_riptide_create(card, pci, &chip)) < 0) {
-		snd_card_free(card);
-		return err;
-	}
+	err = snd_riptide_create(card, pci, &chip);
+	if (err < 0)
+		goto error;
 	card->private_data = chip;
-	if ((err = snd_riptide_pcm(chip, 0, NULL)) < 0) {
-		snd_card_free(card);
-		return err;
-	}
-	if ((err = snd_riptide_mixer(chip)) < 0) {
-		snd_card_free(card);
-		return err;
-	}
-	pci_write_config_word(chip->pci, PCI_EXT_Legacy_Mask, LEGACY_ENABLE_ALL
-			      | (opl3_port[dev] ? LEGACY_ENABLE_FM : 0)
+	err = snd_riptide_pcm(chip, 0, NULL);
+	if (err < 0)
+		goto error;
+	err = snd_riptide_mixer(chip);
+	if (err < 0)
+		goto error;
+
+	val = LEGACY_ENABLE_ALL;
+	if (opl3_port[dev])
+		val |= LEGACY_ENABLE_FM;
 #ifdef SUPPORT_JOYSTICK
-			      | (joystick_port[dev] ? LEGACY_ENABLE_GAMEPORT :
-				 0)
+	if (joystick_port[dev])
+		val |= LEGACY_ENABLE_GAMEPORT;
 #endif
-			      | (mpu_port[dev]
-				 ? (LEGACY_ENABLE_MPU_INT | LEGACY_ENABLE_MPU) :
-				 0)
-			      | ((chip->irq << 4) & 0xF0));
-	if ((addr = mpu_port[dev]) != 0) {
-		pci_write_config_word(chip->pci, PCI_EXT_MPU_Base, addr);
-		if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_RIPTIDE,
-					       addr, 0, chip->irq, 0,
-					       &chip->rmidi)) < 0)
+	if (mpu_port[dev])
+		val |= LEGACY_ENABLE_MPU_INT | LEGACY_ENABLE_MPU;
+	val |= (chip->irq << 4) & 0xf0;
+	pci_write_config_word(chip->pci, PCI_EXT_Legacy_Mask, val);
+	if (mpu_port[dev]) {
+		val = mpu_port[dev];
+		pci_write_config_word(chip->pci, PCI_EXT_MPU_Base, val);
+		err = snd_mpu401_uart_new(card, 0, MPU401_HW_RIPTIDE,
+					  val, 0, chip->irq, 0,
+					  &chip->rmidi);
+		if (err < 0)
 			snd_printk(KERN_WARNING
 				   "Riptide: Can't Allocate MPU at 0x%x\n",
-				   addr);
+				   val);
 		else
-			chip->mpuaddr = addr;
+			chip->mpuaddr = val;
 	}
-	if ((addr = opl3_port[dev]) != 0) {
-		pci_write_config_word(chip->pci, PCI_EXT_FM_Base, addr);
-		if ((err = snd_opl3_create(card, addr, addr + 2,
-					   OPL3_HW_RIPTIDE, 0,
-					   &chip->opl3)) < 0)
+	if (opl3_port[dev]) {
+		val = opl3_port[dev];
+		pci_write_config_word(chip->pci, PCI_EXT_FM_Base, val);
+		err = snd_opl3_create(card, val, val + 2,
+				      OPL3_HW_RIPTIDE, 0, &chip->opl3);
+		if (err < 0)
 			snd_printk(KERN_WARNING
 				   "Riptide: Can't Allocate OPL3 at 0x%x\n",
-				   addr);
+				   val);
 		else {
-			chip->opladdr = addr;
-			if ((err =
-			     snd_opl3_hwdep_new(chip->opl3, 0, 1, NULL)) < 0)
+			chip->opladdr = val;
+			err = snd_opl3_hwdep_new(chip->opl3, 0, 1, NULL);
+			if (err < 0)
 				snd_printk(KERN_WARNING
 					   "Riptide: Can't Allocate OPL3-HWDEP\n");
 		}
 	}
 #ifdef SUPPORT_JOYSTICK
-	if ((addr = joystick_port[dev]) != 0) {
-		pci_write_config_word(chip->pci, PCI_EXT_Game_Base, addr);
-		chip->gameaddr = addr;
+	if (joystick_port[dev]) {
+		val = joystick_port[dev];
+		pci_write_config_word(chip->pci, PCI_EXT_Game_Base, val);
+		chip->gameaddr = val;
 	}
 #endif
 
@@ -2178,13 +2157,16 @@ snd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 		 chip->opladdr);
 #endif
 	snd_riptide_proc_init(chip);
-	if ((err = snd_card_register(card)) < 0) {
-		snd_card_free(card);
-		return err;
-	}
+	err = snd_card_register(card);
+	if (err < 0)
+		goto error;
 	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
+
+ error:
+	snd_card_free(card);
+	return err;
 }
 
 static void __devexit snd_card_riptide_remove(struct pci_dev *pci)

commit 1b1cc7f21c51cc81992a547b59e174dd8c44d1bd
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Wed May 13 20:44:07 2009 +0200

    ALSA: riptide: postfix increment and off by one
    
    With a postfix increment these variables are incremented beyond
    CMDIF_TIMEOUT / MAX_WRITE_RETRY.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 6f1034417a02..e51a5ef1954d 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -889,7 +889,7 @@ static int sendcmd(struct cmdif *cif, u32 flags, u32 cmd, u32 parm,
 	spin_lock_irqsave(&cif->lock, irqflags);
 	while (i++ < CMDIF_TIMEOUT && !IS_READY(cif->hwport))
 		udelay(10);
-	if (i >= CMDIF_TIMEOUT) {
+	if (i > CMDIF_TIMEOUT) {
 		err = -EBUSY;
 		goto errout;
 	}
@@ -907,8 +907,10 @@ static int sendcmd(struct cmdif *cif, u32 flags, u32 cmd, u32 parm,
 			WRITE_PORT_ULONG(cmdport->data1, cmd);	/* write cmd */
 			if ((flags & RESP) && ret) {
 				while (!IS_DATF(cmdport) &&
-				       time++ < CMDIF_TIMEOUT)
+				       time < CMDIF_TIMEOUT) {
 					udelay(10);
+					time++;
+				}
 				if (time < CMDIF_TIMEOUT) {	/* read response */
 					ret->retlongs[0] =
 					    READ_PORT_ULONG(cmdport->data1);
@@ -1454,7 +1456,7 @@ static int snd_riptide_trigger(struct snd_pcm_substream *substream, int cmd)
 			SEND_GPOS(cif, 0, data->id, &rptr);
 			udelay(1);
 		} while (i != rptr.retlongs[1] && j++ < MAX_WRITE_RETRY);
-		if (j >= MAX_WRITE_RETRY)
+		if (j > MAX_WRITE_RETRY)
 			snd_printk(KERN_ERR "Riptide: Could not stop stream!");
 		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
@@ -1783,7 +1785,7 @@ snd_riptide_codec_write(struct snd_ac97 *ac97, unsigned short reg,
 		SEND_SACR(cif, val, reg);
 		SEND_RACR(cif, reg, &rptr);
 	} while (rptr.retwords[1] != val && i++ < MAX_WRITE_RETRY);
-	if (i == MAX_WRITE_RETRY)
+	if (i > MAX_WRITE_RETRY)
 		snd_printdd("Write AC97 reg failed\n");
 }
 

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 3caacfb9d8e0..6f1034417a02 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -2102,9 +2102,9 @@ snd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
 		return -ENOENT;
 	}
 
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
-	if (card == NULL)
-		return -ENOMEM;
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	if (err < 0)
+		return err;
 	if ((err = snd_riptide_create(card, pci, &chip)) < 0) {
 		snd_card_free(card);
 		return err;

commit 8afabfa74bbe81ac496e66f7f0ed8943dff5fdb5
Merge: 86b3aa390b4b 1f04128a3db7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 25 11:40:27 2008 +0100

    Merge branch 'topic/convert-tasklet' into to-push

commit 1f04128a3db7c0f0e8b5d25323eba70ac342f47f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 18 12:17:55 2008 +0100

    ALSA: hda - Convert from takslet_hi_schedule() to tasklet_schedule()
    
    Replace all tasklet_hi_schedule() callers with the normal
    tasklet_schedule().  The former often causes troubles with
    RT-kernels, and has actually no merit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index e9f0706ed3e4..1d0eeb1f506c 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1754,7 +1754,7 @@ snd_riptide_interrupt(int irq, void *dev_id)
 		if (IS_EOBIRQ(cif->hwport) || IS_EOSIRQ(cif->hwport) ||
 		    IS_EOCIRQ(cif->hwport)) {
 			chip->handled_irqs++;
-			tasklet_hi_schedule(&chip->riptide_tq);
+			tasklet_schedule(&chip->riptide_tq);
 		}
 		if (chip->rmidi && IS_MPUIRQ(cif->hwport)) {
 			chip->handled_irqs++;

commit 0f620830db0818ebe065b31c33892e8f0622e1b2
Author: Peter Gruber <nokos@gmx.net>
Date:   Wed Dec 3 15:32:15 2008 +0100

    ALSA: Reduce stall detection timeout in riptide.c
    
    Reduce the command timeout to 0.5sec. Should be enough to allow a
    working command interface but removes a RCU stall and slow resume on
    some revisions where the AC97 revision detection stalls in resume.
    
    Signed-off-by: Peter Gruber <nokos@gmx.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index e9f0706ed3e4..d0ccfc68c522 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -172,7 +172,7 @@ MODULE_PARM_DESC(opl3_port, "OPL3 port # for Riptide driver.");
 
 #define MAX_WRITE_RETRY  10	/* cmd interface limits */
 #define MAX_ERROR_COUNT  10
-#define CMDIF_TIMEOUT    500000
+#define CMDIF_TIMEOUT    50000
 #define RESET_TRIES      5
 
 #define READ_PORT_ULONG(p)     inl((unsigned long)&(p))

commit 77a23f2695bb2de0cd74599400dc55109c531b72
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 21 13:00:13 2008 +0200

    ALSA: Clean up SG-buffer helper functions and macros
    
    Clean up SG-buffer helper functions and macros.  Helpers take substream
    as arguments now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 124f9a2f1535..e9f0706ed3e4 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1483,7 +1483,6 @@ static int snd_riptide_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_riptide *chip = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct snd_sg_buf *sgbuf = snd_pcm_substream_sgbuf(substream);
 	struct pcmhw *data = get_pcmhwdev(substream);
 	struct cmdif *cif = chip->cif;
 	unsigned char *lbuspath = NULL;
@@ -1515,9 +1514,9 @@ static int snd_riptide_prepare(struct snd_pcm_substream *substream)
 			lbuspath = data->paths.stereo;
 		break;
 	}
-	snd_printdd("use sgdlist at 0x%p and buffer at 0x%p\n",
-		    data->sgdlist.area, sgbuf);
-	if (data->sgdlist.area && sgbuf) {
+	snd_printdd("use sgdlist at 0x%p\n",
+		    data->sgdlist.area);
+	if (data->sgdlist.area) {
 		unsigned int i, j, size, pages, f, pt, period;
 		struct sgd *c, *p = NULL;
 
@@ -1535,6 +1534,7 @@ static int snd_riptide_prepare(struct snd_pcm_substream *substream)
 		pt = 0;
 		j = 0;
 		for (i = 0; i < pages; i++) {
+			unsigned int ofs, addr;
 			c = &data->sgdbuf[i];
 			if (p)
 				p->dwNextLink = cpu_to_le32(data->sgdlist.addr +
@@ -1542,8 +1542,9 @@ static int snd_riptide_prepare(struct snd_pcm_substream *substream)
 							     sizeof(struct
 								    sgd)));
 			c->dwNextLink = cpu_to_le32(data->sgdlist.addr);
-			c->dwSegPtrPhys =
-			    cpu_to_le32(sgbuf->table[j].addr + pt);
+			ofs = j << PAGE_SHIFT;
+			addr = snd_pcm_sgbuf_get_addr(substream, ofs) + pt;
+			c->dwSegPtrPhys = cpu_to_le32(addr);
 			pt = (pt + f) % PAGE_SIZE;
 			if (pt == 0)
 				j++;

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 6a3596247348..124f9a2f1535 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -865,7 +865,8 @@ static int sendcmd(struct cmdif *cif, u32 flags, u32 cmd, u32 parm,
 	struct riptideport *hwport;
 	struct cmdport *cmdport = NULL;
 
-	snd_assert(cif, return -EINVAL);
+	if (snd_BUG_ON(!cif))
+		return -EINVAL;
 
 	hwport = cif->hwport;
 	if (cif->errcnt > MAX_ERROR_COUNT) {
@@ -1490,7 +1491,8 @@ static int snd_riptide_prepare(struct snd_pcm_substream *substream)
 	int err = 0;
 	snd_pcm_format_t format;
 
-	snd_assert(cif && data, return -EINVAL);
+	if (snd_BUG_ON(!cif || !data))
+		return -EINVAL;
 
 	snd_printdd("prepare id %d ch: %d f:0x%x r:%d\n", data->id,
 		    runtime->channels, runtime->format, runtime->rate);
@@ -1772,7 +1774,8 @@ snd_riptide_codec_write(struct snd_ac97 *ac97, unsigned short reg,
 	union cmdret rptr = CMDRET_ZERO;
 	int i = 0;
 
-	snd_assert(cif, return);
+	if (snd_BUG_ON(!cif))
+		return;
 
 	snd_printdd("Write AC97 reg 0x%x 0x%x\n", reg, val);
 	do {
@@ -1790,7 +1793,8 @@ static unsigned short snd_riptide_codec_read(struct snd_ac97 *ac97,
 	struct cmdif *cif = chip->cif;
 	union cmdret rptr = CMDRET_ZERO;
 
-	snd_assert(cif, return 0);
+	if (snd_BUG_ON(!cif))
+		return 0;
 
 	if (SEND_RACR(cif, reg, &rptr) != 0)
 		SEND_RACR(cif, reg, &rptr);
@@ -1804,7 +1808,8 @@ static int snd_riptide_initialize(struct snd_riptide *chip)
 	unsigned int device_id;
 	int err;
 
-	snd_assert(chip, return -EINVAL);
+	if (snd_BUG_ON(!chip))
+		return -EINVAL;
 
 	cif = chip->cif;
 	if (!cif) {
@@ -1836,7 +1841,8 @@ static int snd_riptide_free(struct snd_riptide *chip)
 {
 	struct cmdif *cif;
 
-	snd_assert(chip, return 0);
+	if (!chip)
+		return 0;
 
 	if ((cif = chip->cif)) {
 		SET_GRESET(cif->hwport);

commit 93a9c901c88ba2b1bae9dd55e6243896b8a580f1
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sat May 24 00:02:03 2008 +0100

    riptide: treat firmware data as const
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 979f7da641ce..6a3596247348 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -682,7 +682,7 @@ static union firmware_version firmware_versions[] = {
 	},
 };
 
-static u32 atoh(unsigned char *in, unsigned int len)
+static u32 atoh(const unsigned char *in, unsigned int len)
 {
 	u32 sum = 0;
 	unsigned int mult = 1;
@@ -702,12 +702,12 @@ static u32 atoh(unsigned char *in, unsigned int len)
 	return sum;
 }
 
-static int senddata(struct cmdif *cif, unsigned char *in, u32 offset)
+static int senddata(struct cmdif *cif, const unsigned char *in, u32 offset)
 {
 	u32 addr;
 	u32 data;
 	u32 i;
-	unsigned char *p;
+	const unsigned char *p;
 
 	i = atoh(&in[1], 2);
 	addr = offset + atoh(&in[3], 4);
@@ -726,10 +726,10 @@ static int senddata(struct cmdif *cif, unsigned char *in, u32 offset)
 	return 0;
 }
 
-static int loadfirmware(struct cmdif *cif, unsigned char *img,
+static int loadfirmware(struct cmdif *cif, const unsigned char *img,
 			unsigned int size)
 {
-	unsigned char *in;
+	const unsigned char *in;
 	u32 laddr, saddr, t, val;
 	int err = 0;
 

commit 0cd87b10ca29a351c61c8c63761ab8fb48e47b2f
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Fri Feb 29 11:54:26 2008 +0100

    [ALSA] sound: riptide.c fix shadowed variable warnings
    
    In both cases we are passing around the substream number, use
    sub_num for this.
    sound/pci/riptide/riptide.c:1633:6: warning: symbol 'index' shadows an earlier one
    sound/pci/riptide/riptide.c:121:12: originally declared here
    sound/pci/riptide/riptide.c:1673:6: warning: symbol 'index' shadows an earlier one
    sound/pci/riptide/riptide.c:121:12: originally declared here
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 9408b1eeec40..979f7da641ce 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1630,14 +1630,14 @@ static int snd_riptide_playback_open(struct snd_pcm_substream *substream)
 	struct snd_riptide *chip = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct pcmhw *data;
-	int index = substream->number;
+	int sub_num = substream->number;
 
-	chip->playback_substream[index] = substream;
+	chip->playback_substream[sub_num] = substream;
 	runtime->hw = snd_riptide_playback;
 	data = kzalloc(sizeof(struct pcmhw), GFP_KERNEL);
-	data->paths = lbus_play_paths[index];
-	data->id = play_ids[index];
-	data->source = play_sources[index];
+	data->paths = lbus_play_paths[sub_num];
+	data->id = play_ids[sub_num];
+	data->source = play_sources[sub_num];
 	data->intdec[0] = 0xff;
 	data->intdec[1] = 0xff;
 	data->state = ST_STOP;
@@ -1670,10 +1670,10 @@ static int snd_riptide_playback_close(struct snd_pcm_substream *substream)
 {
 	struct snd_riptide *chip = snd_pcm_substream_chip(substream);
 	struct pcmhw *data = get_pcmhwdev(substream);
-	int index = substream->number;
+	int sub_num = substream->number;
 
 	substream->runtime->private_data = NULL;
-	chip->playback_substream[index] = NULL;
+	chip->playback_substream[sub_num] = NULL;
 	kfree(data);
 	return 0;
 }

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 8e5410483e67..9408b1eeec40 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -88,7 +88,6 @@
             Adopted for Windows NT driver          01/20/98      CNL
 */
 
-#include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>

commit 7e0af29d6f3964bec3d72c6caeb87a603e660fdf
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu May 3 17:59:54 2007 +0200

    [ALSA] add MODULE_FIRMWARE entries
    
    Add MODULE_FIRMWARE() entries, where appropriate.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 952625dead58..8e5410483e67 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -117,6 +117,7 @@ MODULE_AUTHOR("Peter Gruber <nokos@gmx.net>");
 MODULE_DESCRIPTION("riptide");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{Conexant,Riptide}}");
+MODULE_FIRMWARE("riptide.hex");
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;

commit c187c041c6552339e4d8883a1a00c3c489354eca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 19 15:27:33 2007 +0100

    [ALSA] Add missing sysfs device assignment for ALSA PCI drivers
    
    Added the missing sysfs device assignment for ALSA PCI drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 5e1d5d2b2850..952625dead58 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1919,6 +1919,8 @@ snd_riptide_create(struct snd_card *card, struct pci_dev *pci,
 		return err;
 	}
 
+	snd_card_set_dev(card, &pci->dev);
+
 	*rchip = chip;
 	return 0;
 }

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 56e0c01123e7..5e1d5d2b2850 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1899,9 +1899,8 @@ snd_riptide_create(struct snd_card *card, struct pci_dev *pci,
 	hwport = (struct riptideport *)chip->port;
 	UNSET_AIE(hwport);
 
-	if (request_irq
-	    (pci->irq, snd_riptide_interrupt, IRQF_DISABLED | IRQF_SHARED,
-	     "RIPTIDE", chip)) {
+	if (request_irq(pci->irq, snd_riptide_interrupt, IRQF_SHARED,
+			"RIPTIDE", chip)) {
 		snd_printk(KERN_ERR "Riptide: unable to grab IRQ %d\n",
 			   pci->irq);
 		snd_riptide_free(chip);

commit 30b35399ceb2398d05837863476dcb12f12f3a82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 11 18:52:53 2006 +0200

    [ALSA] Various fixes for suspend/resume of ALSA PCI drivers
    
    - Check the return value of pci_enable_device() and request_irq()
      in the suspend.  If any error occurs there, disable the device
      using snd_card_disconnect().
    - Call pci_set_power_state() properly with pci_choose_state().
    - Fix the order to call pci_set_power_state().
    - Removed obsolete house-made PM codes in some drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index ec4899147e1d..56e0c01123e7 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1178,9 +1178,9 @@ static int riptide_suspend(struct pci_dev *pci, pm_message_t state)
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -1189,9 +1189,14 @@ static int riptide_resume(struct pci_dev *pci)
 	struct snd_card *card = pci_get_drvdata(pci);
 	struct snd_riptide *chip = card->private_data;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "riptide: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 	snd_riptide_initialize(chip);
 	snd_ac97_resume(chip->ac97);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index fe210c853442..ec4899147e1d 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1736,7 +1736,7 @@ snd_riptide_pcm(struct snd_riptide *chip, int device, struct snd_pcm **rpcm)
 }
 
 static irqreturn_t
-snd_riptide_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+snd_riptide_interrupt(int irq, void *dev_id)
 {
 	struct snd_riptide *chip = dev_id;
 	struct cmdif *cif = chip->cif;
@@ -1751,8 +1751,7 @@ snd_riptide_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 		if (chip->rmidi && IS_MPUIRQ(cif->hwport)) {
 			chip->handled_irqs++;
 			snd_mpu401_uart_interrupt(irq,
-						  chip->rmidi->private_data,
-						  regs);
+						  chip->rmidi->private_data);
 		}
 		SET_AIACK(cif->hwport);
 	}

commit adf75dcab1deb9625538f74906508c1f6136fd98
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Aug 18 09:03:45 2006 +0200

    [ALSA] riptide: fix compile errors with older gcc
    
    Change the syntax of a union initialization that is not understood by
    gcc 2.x.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index f435fcd6dca9..fe210c853442 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -673,9 +673,13 @@ static struct lbuspath lbus_rec_path = {
 #define FIRMWARE_VERSIONS 1
 static union firmware_version firmware_versions[] = {
 	{
-	 .firmware.ASIC = 3,.firmware.CODEC = 2,
-	 .firmware.AUXDSP = 3,.firmware.PROG = 773,
-	 },
+		.firmware = {
+			.ASIC = 3,
+			.CODEC = 2,
+			.AUXDSP = 3,
+			.PROG = 773,
+		},
+	},
 };
 
 static u32 atoh(unsigned char *in, unsigned int len)

commit f40b68903ccd511ea9d658b4bce319dd032a265a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 16:51:05 2006 +0200

    [ALSA] Fix section mismatch errors in ALSA PCI drivers
    
    Fixed 'section mismatch' errors in ALSA PCI drivers:
    - removed invalid __devinitdata from pci id tables
    - fix/remove __devinit of functions called in suspend/resume
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 5501a08ca23a..f435fcd6dca9 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -506,7 +506,7 @@ static int riptide_reset(struct cmdif *cif, struct snd_riptide *chip);
 /*
  */
 
-static struct pci_device_id snd_riptide_ids[] __devinitdata = {
+static struct pci_device_id snd_riptide_ids[] = {
 	{
 	 .vendor = 0x127a,.device = 0x4310,
 	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 5618ec9740bd..5501a08ca23a 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1892,7 +1892,7 @@ snd_riptide_create(struct snd_card *card, struct pci_dev *pci,
 	UNSET_AIE(hwport);
 
 	if (request_irq
-	    (pci->irq, snd_riptide_interrupt, SA_INTERRUPT | SA_SHIRQ,
+	    (pci->irq, snd_riptide_interrupt, IRQF_DISABLED | IRQF_SHARED,
 	     "RIPTIDE", chip)) {
 		snd_printk(KERN_ERR "Riptide: unable to grab IRQ %d\n",
 			   pci->irq);

commit 0a50d2b2951cb7ae12726814f9a198e1c699aa0b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jun 1 14:47:29 2006 +0200

    [ALSA] Fix possible races in PCI driver removal
    
    Call free_irq() before releasing others to avoid races when
    shared irq is issued.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index c27cd4999777..5618ec9740bd 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1836,11 +1836,11 @@ static int snd_riptide_free(struct snd_riptide *chip)
 		UNSET_GRESET(cif->hwport);
 		kfree(chip->cif);
 	}
+	if (chip->irq >= 0)
+		free_irq(chip->irq, chip);
 	if (chip->fw_entry)
 		release_firmware(chip->fw_entry);
 	release_and_free_resource(chip->res_port);
-	if (chip->irq >= 0)
-		free_irq(chip->irq, chip);
 	kfree(chip);
 	return 0;
 }

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index d8cc985d7241..c27cd4999777 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1992,7 +1992,7 @@ static void __devinit snd_riptide_proc_init(struct snd_riptide *chip)
 	struct snd_info_entry *entry;
 
 	if (!snd_card_proc_new(chip->card, "riptide", &entry))
-		snd_info_set_text_ops(entry, chip, 4096, snd_riptide_proc_read);
+		snd_info_set_text_ops(entry, chip, snd_riptide_proc_read);
 }
 
 static int __devinit snd_riptide_mixer(struct snd_riptide *chip)

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index f148ee434a6b..d8cc985d7241 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -506,7 +506,7 @@ static int riptide_reset(struct cmdif *cif, struct snd_riptide *chip);
 /*
  */
 
-static struct pci_device_id snd_riptide_ids[] = {
+static struct pci_device_id snd_riptide_ids[] __devinitdata = {
 	{
 	 .vendor = 0x127a,.device = 0x4310,
 	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
@@ -527,7 +527,7 @@ static struct pci_device_id snd_riptide_ids[] = {
 };
 
 #ifdef SUPPORT_JOYSTICK
-static struct pci_device_id snd_riptide_joystick_ids[] = {
+static struct pci_device_id snd_riptide_joystick_ids[] __devinitdata = {
 	{
 	 .vendor = 0x127a,.device = 0x4312,
 	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,

commit 43560116d1f70de274915fdec0745c6e02feef30
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Mar 27 13:45:51 2006 +0200

    [ALSA] Remove obsolete kfree_nocheck call
    
    Fixed the compilation, removing obsolete kfree_nocheck() call
    for memory debugging.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
index 5b3e49900498..f148ee434a6b 100644
--- a/sound/pci/riptide/riptide.c
+++ b/sound/pci/riptide/riptide.c
@@ -1838,10 +1838,7 @@ static int snd_riptide_free(struct snd_riptide *chip)
 	}
 	if (chip->fw_entry)
 		release_firmware(chip->fw_entry);
-	if (chip->res_port) {
-		release_resource(chip->res_port);
-		kfree_nocheck(chip->res_port);
-	}
+	release_and_free_resource(chip->res_port);
 	if (chip->irq >= 0)
 		free_irq(chip->irq, chip);
 	kfree(chip);

commit 109a9638f0fe38915838b7b9acd98e7cfa91797f
Author: Peter Gruber <nokos@gmx.net>
Date:   Mon Mar 27 13:10:28 2006 +0200

    [ALSA] Add snd-riptide driver for Conexant Riptide chip
    
    Add snd-riptide driver for Conexant Riptide chip by Peter Gruber.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c
new file mode 100644
index 000000000000..5b3e49900498
--- /dev/null
+++ b/sound/pci/riptide/riptide.c
@@ -0,0 +1,2226 @@
+/*
+ *   Driver for the Conexant Riptide Soundchip
+ *
+ *	Copyright (c) 2004 Peter Gruber <nokos@gmx.net>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+/*
+  History:
+   - 02/15/2004 first release
+   
+  This Driver is based on the OSS Driver version from Linuxant (riptide-0.6lnxtbeta03111100)
+  credits from the original files:
+  
+  MODULE NAME:        cnxt_rt.h                       
+  AUTHOR:             K. Lazarev  (Transcribed by KNL)
+  HISTORY:         Major Revision               Date        By
+            -----------------------------     --------     -----
+            Created                           02/1/2000     KNL
+
+  MODULE NAME:     int_mdl.c                       
+  AUTHOR:          Konstantin Lazarev    (Transcribed by KNL)
+  HISTORY:         Major Revision               Date        By
+            -----------------------------     --------     -----
+            Created                           10/01/99      KNL
+	    
+  MODULE NAME:        riptide.h                       
+  AUTHOR:             O. Druzhinin  (Transcribed by OLD)
+  HISTORY:         Major Revision               Date        By
+            -----------------------------     --------     -----
+            Created                           10/16/97      OLD
+
+  MODULE NAME:        Rp_Cmdif.cpp                       
+  AUTHOR:             O. Druzhinin  (Transcribed by OLD)
+                      K. Lazarev    (Transcribed by KNL)
+  HISTORY:         Major Revision               Date        By
+            -----------------------------     --------     -----
+            Adopted from NT4 driver            6/22/99      OLD
+            Ported to Linux                    9/01/99      KNL
+
+  MODULE NAME:        rt_hw.c                       
+  AUTHOR:             O. Druzhinin  (Transcribed by OLD)
+                      C. Lazarev    (Transcribed by CNL)
+  HISTORY:         Major Revision               Date        By
+            -----------------------------     --------     -----
+            Created                           11/18/97      OLD
+            Hardware functions for RipTide    11/24/97      CNL
+            (ES1) are coded
+            Hardware functions for RipTide    12/24/97      CNL
+            (A0) are coded
+            Hardware functions for RipTide    03/20/98      CNL
+            (A1) are coded
+            Boot loader is included           05/07/98      CNL
+            Redesigned for WDM                07/27/98      CNL
+            Redesigned for Linux              09/01/99      CNL
+
+  MODULE NAME:        rt_hw.h
+  AUTHOR:             C. Lazarev    (Transcribed by CNL)
+  HISTORY:         Major Revision               Date        By
+            -----------------------------     --------     -----
+            Created                           11/18/97      CNL
+
+  MODULE NAME:     rt_mdl.c                       
+  AUTHOR:          Konstantin Lazarev    (Transcribed by KNL)
+  HISTORY:         Major Revision               Date        By
+            -----------------------------     --------     -----
+            Created                           10/01/99      KNL
+
+  MODULE NAME:        mixer.h                        
+  AUTHOR:             K. Kenney
+  HISTORY:         Major Revision                   Date          By
+            -----------------------------          --------     -----
+            Created from MS W95 Sample             11/28/95      KRS
+            RipTide                                10/15/97      KRS
+            Adopted for Windows NT driver          01/20/98      CNL
+*/
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/gameport.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <asm/io.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/ac97_codec.h>
+#include <sound/mpu401.h>
+#include <sound/opl3.h>
+#include <sound/initval.h>
+
+#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+#define SUPPORT_JOYSTICK 1
+#endif
+
+MODULE_AUTHOR("Peter Gruber <nokos@gmx.net>");
+MODULE_DESCRIPTION("riptide");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{Conexant,Riptide}}");
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE;
+
+#ifdef SUPPORT_JOYSTICK
+static int joystick_port[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS - 1)] = 0x200 };
+#endif
+static int mpu_port[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS - 1)] = 0x330 };
+static int opl3_port[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS - 1)] = 0x388 };
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for Riptide soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for Riptide soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable Riptide soundcard.");
+#ifdef SUPPORT_JOYSTICK
+module_param_array(joystick_port, int, NULL, 0444);
+MODULE_PARM_DESC(joystick_port, "Joystick port # for Riptide soundcard.");
+#endif
+module_param_array(mpu_port, int, NULL, 0444);
+MODULE_PARM_DESC(mpu_port, "MPU401 port # for Riptide driver.");
+module_param_array(opl3_port, int, NULL, 0444);
+MODULE_PARM_DESC(opl3_port, "OPL3 port # for Riptide driver.");
+
+/*
+ */
+
+#define MPU401_HW_RIPTIDE MPU401_HW_MPU401
+#define OPL3_HW_RIPTIDE   OPL3_HW_OPL3
+
+#define PCI_EXT_CapId       0x40
+#define PCI_EXT_NextCapPrt  0x41
+#define PCI_EXT_PWMC        0x42
+#define PCI_EXT_PWSCR       0x44
+#define PCI_EXT_Data00      0x46
+#define PCI_EXT_PMSCR_BSE   0x47
+#define PCI_EXT_SB_Base     0x48
+#define PCI_EXT_FM_Base     0x4a
+#define PCI_EXT_MPU_Base    0x4C
+#define PCI_EXT_Game_Base   0x4E
+#define PCI_EXT_Legacy_Mask 0x50
+#define PCI_EXT_AsicRev     0x52
+#define PCI_EXT_Reserved3   0x53
+
+#define LEGACY_ENABLE_ALL      0x8000	/* legacy device options */
+#define LEGACY_ENABLE_SB       0x4000
+#define LEGACY_ENABLE_FM       0x2000
+#define LEGACY_ENABLE_MPU_INT  0x1000
+#define LEGACY_ENABLE_MPU      0x0800
+#define LEGACY_ENABLE_GAMEPORT 0x0400
+
+#define MAX_WRITE_RETRY  10	/* cmd interface limits */
+#define MAX_ERROR_COUNT  10
+#define CMDIF_TIMEOUT    500000
+#define RESET_TRIES      5
+
+#define READ_PORT_ULONG(p)     inl((unsigned long)&(p))
+#define WRITE_PORT_ULONG(p,x)  outl(x,(unsigned long)&(p))
+
+#define READ_AUDIO_CONTROL(p)     READ_PORT_ULONG(p->audio_control)
+#define WRITE_AUDIO_CONTROL(p,x)  WRITE_PORT_ULONG(p->audio_control,x)
+#define UMASK_AUDIO_CONTROL(p,x)  WRITE_PORT_ULONG(p->audio_control,READ_PORT_ULONG(p->audio_control)|x)
+#define MASK_AUDIO_CONTROL(p,x)   WRITE_PORT_ULONG(p->audio_control,READ_PORT_ULONG(p->audio_control)&x)
+#define READ_AUDIO_STATUS(p)      READ_PORT_ULONG(p->audio_status)
+
+#define SET_GRESET(p)     UMASK_AUDIO_CONTROL(p,0x0001)	/* global reset switch */
+#define UNSET_GRESET(p)   MASK_AUDIO_CONTROL(p,~0x0001)
+#define SET_AIE(p)        UMASK_AUDIO_CONTROL(p,0x0004)	/* interrupt enable */
+#define UNSET_AIE(p)      MASK_AUDIO_CONTROL(p,~0x0004)
+#define SET_AIACK(p)      UMASK_AUDIO_CONTROL(p,0x0008)	/* interrupt acknowledge */
+#define UNSET_AIACKT(p)   MASKAUDIO_CONTROL(p,~0x0008)
+#define SET_ECMDAE(p)     UMASK_AUDIO_CONTROL(p,0x0010)
+#define UNSET_ECMDAE(p)   MASK_AUDIO_CONTROL(p,~0x0010)
+#define SET_ECMDBE(p)     UMASK_AUDIO_CONTROL(p,0x0020)
+#define UNSET_ECMDBE(p)   MASK_AUDIO_CONTROL(p,~0x0020)
+#define SET_EDATAF(p)     UMASK_AUDIO_CONTROL(p,0x0040)
+#define UNSET_EDATAF(p)   MASK_AUDIO_CONTROL(p,~0x0040)
+#define SET_EDATBF(p)     UMASK_AUDIO_CONTROL(p,0x0080)
+#define UNSET_EDATBF(p)   MASK_AUDIO_CONTROL(p,~0x0080)
+#define SET_ESBIRQON(p)   UMASK_AUDIO_CONTROL(p,0x0100)
+#define UNSET_ESBIRQON(p) MASK_AUDIO_CONTROL(p,~0x0100)
+#define SET_EMPUIRQ(p)    UMASK_AUDIO_CONTROL(p,0x0200)
+#define UNSET_EMPUIRQ(p)  MASK_AUDIO_CONTROL(p,~0x0200)
+#define IS_CMDE(a)        (READ_PORT_ULONG(a->stat)&0x1)	/* cmd empty */
+#define IS_DATF(a)        (READ_PORT_ULONG(a->stat)&0x2)	/* data filled */
+#define IS_READY(p)       (READ_AUDIO_STATUS(p)&0x0001)
+#define IS_DLREADY(p)     (READ_AUDIO_STATUS(p)&0x0002)
+#define IS_DLERR(p)       (READ_AUDIO_STATUS(p)&0x0004)
+#define IS_GERR(p)        (READ_AUDIO_STATUS(p)&0x0008)	/* error ! */
+#define IS_CMDAEIRQ(p)    (READ_AUDIO_STATUS(p)&0x0010)
+#define IS_CMDBEIRQ(p)    (READ_AUDIO_STATUS(p)&0x0020)
+#define IS_DATAFIRQ(p)    (READ_AUDIO_STATUS(p)&0x0040)
+#define IS_DATBFIRQ(p)    (READ_AUDIO_STATUS(p)&0x0080)
+#define IS_EOBIRQ(p)      (READ_AUDIO_STATUS(p)&0x0100)	/* interrupt status */
+#define IS_EOSIRQ(p)      (READ_AUDIO_STATUS(p)&0x0200)
+#define IS_EOCIRQ(p)      (READ_AUDIO_STATUS(p)&0x0400)
+#define IS_UNSLIRQ(p)     (READ_AUDIO_STATUS(p)&0x0800)
+#define IS_SBIRQ(p)       (READ_AUDIO_STATUS(p)&0x1000)
+#define IS_MPUIRQ(p)      (READ_AUDIO_STATUS(p)&0x2000)
+
+#define RESP 0x00000001		/* command flags */
+#define PARM 0x00000002
+#define CMDA 0x00000004
+#define CMDB 0x00000008
+#define NILL 0x00000000
+
+#define LONG0(a)   ((u32)a)	/* shifts and masks */
+#define BYTE0(a)   (LONG0(a)&0xff)
+#define BYTE1(a)   (BYTE0(a)<<8)
+#define BYTE2(a)   (BYTE0(a)<<16)
+#define BYTE3(a)   (BYTE0(a)<<24)
+#define WORD0(a)   (LONG0(a)&0xffff)
+#define WORD1(a)   (WORD0(a)<<8)
+#define WORD2(a)   (WORD0(a)<<16)
+#define TRINIB0(a) (LONG0(a)&0xffffff)
+#define TRINIB1(a) (TRINIB0(a)<<8)
+
+#define RET(a)     ((union cmdret *)(a))
+
+#define SEND_GETV(p,b)             sendcmd(p,RESP,GETV,0,RET(b))	/* get version */
+#define SEND_GETC(p,b,c)           sendcmd(p,PARM|RESP,GETC,c,RET(b))
+#define SEND_GUNS(p,b)             sendcmd(p,RESP,GUNS,0,RET(b))
+#define SEND_SCID(p,b)             sendcmd(p,RESP,SCID,0,RET(b))
+#define SEND_RMEM(p,b,c,d)         sendcmd(p,PARM|RESP,RMEM|BYTE1(b),LONG0(c),RET(d))	/* memory access for firmware write */
+#define SEND_SMEM(p,b,c)           sendcmd(p,PARM,SMEM|BYTE1(b),LONG0(c),RET(0))	/* memory access for firmware write */
+#define SEND_WMEM(p,b,c)           sendcmd(p,PARM,WMEM|BYTE1(b),LONG0(c),RET(0))	/* memory access for firmware write */
+#define SEND_SDTM(p,b,c)           sendcmd(p,PARM|RESP,SDTM|TRINIB1(b),0,RET(c))	/* memory access for firmware write */
+#define SEND_GOTO(p,b)             sendcmd(p,PARM,GOTO,LONG0(b),RET(0))	/* memory access for firmware write */
+#define SEND_SETDPLL(p)	           sendcmd(p,0,ARM_SETDPLL,0,RET(0))
+#define SEND_SSTR(p,b,c)           sendcmd(p,PARM,SSTR|BYTE3(b),LONG0(c),RET(0))	/* start stream */
+#define SEND_PSTR(p,b)             sendcmd(p,PARM,PSTR,BYTE3(b),RET(0))	/* pause stream */
+#define SEND_KSTR(p,b)             sendcmd(p,PARM,KSTR,BYTE3(b),RET(0))	/* stop stream */
+#define SEND_KDMA(p)               sendcmd(p,0,KDMA,0,RET(0))	/* stop all dma */
+#define SEND_GPOS(p,b,c,d)         sendcmd(p,PARM|RESP,GPOS,BYTE3(c)|BYTE2(b),RET(d))	/* get position in dma */
+#define SEND_SETF(p,b,c,d,e,f,g)   sendcmd(p,PARM,SETF|WORD1(b)|BYTE3(c),d|BYTE1(e)|BYTE2(f)|BYTE3(g),RET(0))	/* set sample format at mixer */
+#define SEND_GSTS(p,b,c,d)         sendcmd(p,PARM|RESP,GSTS,BYTE3(c)|BYTE2(b),RET(d))
+#define SEND_NGPOS(p,b,c,d)        sendcmd(p,PARM|RESP,NGPOS,BYTE3(c)|BYTE2(b),RET(d))
+#define SEND_PSEL(p,b,c)           sendcmd(p,PARM,PSEL,BYTE2(b)|BYTE3(c),RET(0))	/* activate lbus path */
+#define SEND_PCLR(p,b,c)           sendcmd(p,PARM,PCLR,BYTE2(b)|BYTE3(c),RET(0))	/* deactivate lbus path */
+#define SEND_PLST(p,b)             sendcmd(p,PARM,PLST,BYTE3(b),RET(0))
+#define SEND_RSSV(p,b,c,d)         sendcmd(p,PARM|RESP,RSSV,BYTE2(b)|BYTE3(c),RET(d))
+#define SEND_LSEL(p,b,c,d,e,f,g,h) sendcmd(p,PARM,LSEL|BYTE1(b)|BYTE2(c)|BYTE3(d),BYTE0(e)|BYTE1(f)|BYTE2(g)|BYTE3(h),RET(0))	/* select paths for internal connections */
+#define SEND_SSRC(p,b,c,d,e)       sendcmd(p,PARM,SSRC|BYTE1(b)|WORD2(c),WORD0(d)|WORD2(e),RET(0))	/* configure source */
+#define SEND_SLST(p,b)             sendcmd(p,PARM,SLST,BYTE3(b),RET(0))
+#define SEND_RSRC(p,b,c)           sendcmd(p,RESP,RSRC|BYTE1(b),0,RET(c))	/* read source config */
+#define SEND_SSRB(p,b,c)           sendcmd(p,PARM,SSRB|BYTE1(b),WORD2(c),RET(0))
+#define SEND_SDGV(p,b,c,d,e)       sendcmd(p,PARM,SDGV|BYTE2(b)|BYTE3(c),WORD0(d)|WORD2(e),RET(0))	/* set digital mixer */
+#define SEND_RDGV(p,b,c,d)         sendcmd(p,PARM|RESP,RDGV|BYTE2(b)|BYTE3(c),0,RET(d))	/* read digital mixer */
+#define SEND_DLST(p,b)             sendcmd(p,PARM,DLST,BYTE3(b),RET(0))
+#define SEND_SACR(p,b,c)           sendcmd(p,PARM,SACR,WORD0(b)|WORD2(c),RET(0))	/* set AC97 register */
+#define SEND_RACR(p,b,c)           sendcmd(p,PARM|RESP,RACR,WORD2(b),RET(c))	/* get AC97 register */
+#define SEND_ALST(p,b)             sendcmd(p,PARM,ALST,BYTE3(b),RET(0))
+#define SEND_TXAC(p,b,c,d,e,f)     sendcmd(p,PARM,TXAC|BYTE1(b)|WORD2(c),WORD0(d)|BYTE2(e)|BYTE3(f),RET(0))
+#define SEND_RXAC(p,b,c,d)         sendcmd(p,PARM|RESP,RXAC,BYTE2(b)|BYTE3(c),RET(d))
+#define SEND_SI2S(p,b)             sendcmd(p,PARM,SI2S,WORD2(b),RET(0))
+
+#define EOB_STATUS         0x80000000	/* status flags : block boundary */
+#define EOS_STATUS         0x40000000	/*              : stoppped */
+#define EOC_STATUS         0x20000000	/*              : stream end */
+#define ERR_STATUS         0x10000000
+#define EMPTY_STATUS       0x08000000
+
+#define IEOB_ENABLE        0x1	/* enable interrupts for status notification above */
+#define IEOS_ENABLE        0x2
+#define IEOC_ENABLE        0x4
+#define RDONCE             0x8
+#define DESC_MAX_MASK      0xff
+
+#define ST_PLAY  0x1		/* stream states */
+#define ST_STOP  0x2
+#define ST_PAUSE 0x4
+
+#define I2S_INTDEC     3	/* config for I2S link */
+#define I2S_MERGER     0
+#define I2S_SPLITTER   0
+#define I2S_MIXER      7
+#define I2S_RATE       44100
+
+#define MODEM_INTDEC   4	/* config for modem link */
+#define MODEM_MERGER   3
+#define MODEM_SPLITTER 0
+#define MODEM_MIXER    11
+
+#define FM_INTDEC      3	/* config for FM/OPL3 link */
+#define FM_MERGER      0
+#define FM_SPLITTER    0
+#define FM_MIXER       9
+
+#define SPLIT_PATH  0x80	/* path splitting flag */
+
+enum FIRMWARE {
+	DATA_REC = 0, EXT_END_OF_FILE, EXT_SEG_ADDR_REC, EXT_GOTO_CMD_REC,
+	EXT_LIN_ADDR_REC,
+};
+
+enum CMDS {
+	GETV = 0x00, GETC, GUNS, SCID, RMEM =
+	    0x10, SMEM, WMEM, SDTM, GOTO, SSTR =
+	    0x20, PSTR, KSTR, KDMA, GPOS, SETF, GSTS, NGPOS, PSEL =
+	    0x30, PCLR, PLST, RSSV, LSEL, SSRC = 0x40, SLST, RSRC, SSRB, SDGV =
+	    0x50, RDGV, DLST, SACR = 0x60, RACR, ALST, TXAC, RXAC, SI2S =
+	    0x70, ARM_SETDPLL = 0x72,
+};
+
+enum E1SOURCE {
+	ARM2LBUS_FIFO0 = 0, ARM2LBUS_FIFO1, ARM2LBUS_FIFO2, ARM2LBUS_FIFO3,
+	ARM2LBUS_FIFO4, ARM2LBUS_FIFO5, ARM2LBUS_FIFO6, ARM2LBUS_FIFO7,
+	ARM2LBUS_FIFO8, ARM2LBUS_FIFO9, ARM2LBUS_FIFO10, ARM2LBUS_FIFO11,
+	ARM2LBUS_FIFO12, ARM2LBUS_FIFO13, ARM2LBUS_FIFO14, ARM2LBUS_FIFO15,
+	INTER0_OUT, INTER1_OUT, INTER2_OUT, INTER3_OUT, INTER4_OUT,
+	INTERM0_OUT, INTERM1_OUT, INTERM2_OUT, INTERM3_OUT, INTERM4_OUT,
+	INTERM5_OUT, INTERM6_OUT, DECIMM0_OUT, DECIMM1_OUT, DECIMM2_OUT,
+	DECIMM3_OUT, DECIM0_OUT, SR3_4_OUT, OPL3_SAMPLE, ASRC0, ASRC1,
+	ACLNK2PADC, ACLNK2MODEM0RX, ACLNK2MIC, ACLNK2MODEM1RX, ACLNK2HNDMIC,
+	DIGITAL_MIXER_OUT0, GAINFUNC0_OUT, GAINFUNC1_OUT, GAINFUNC2_OUT,
+	GAINFUNC3_OUT, GAINFUNC4_OUT, SOFTMODEMTX, SPLITTER0_OUTL,
+	SPLITTER0_OUTR, SPLITTER1_OUTL, SPLITTER1_OUTR, SPLITTER2_OUTL,
+	SPLITTER2_OUTR, SPLITTER3_OUTL, SPLITTER3_OUTR, MERGER0_OUT,
+	MERGER1_OUT, MERGER2_OUT, MERGER3_OUT, ARM2LBUS_FIFO_DIRECT, NO_OUT
+};
+
+enum E2SINK {
+	LBUS2ARM_FIFO0 = 0, LBUS2ARM_FIFO1, LBUS2ARM_FIFO2, LBUS2ARM_FIFO3,
+	LBUS2ARM_FIFO4, LBUS2ARM_FIFO5, LBUS2ARM_FIFO6, LBUS2ARM_FIFO7,
+	INTER0_IN, INTER1_IN, INTER2_IN, INTER3_IN, INTER4_IN, INTERM0_IN,
+	INTERM1_IN, INTERM2_IN, INTERM3_IN, INTERM4_IN, INTERM5_IN, INTERM6_IN,
+	DECIMM0_IN, DECIMM1_IN, DECIMM2_IN, DECIMM3_IN, DECIM0_IN, SR3_4_IN,
+	PDAC2ACLNK, MODEM0TX2ACLNK, MODEM1TX2ACLNK, HNDSPK2ACLNK,
+	DIGITAL_MIXER_IN0, DIGITAL_MIXER_IN1, DIGITAL_MIXER_IN2,
+	DIGITAL_MIXER_IN3, DIGITAL_MIXER_IN4, DIGITAL_MIXER_IN5,
+	DIGITAL_MIXER_IN6, DIGITAL_MIXER_IN7, DIGITAL_MIXER_IN8,
+	DIGITAL_MIXER_IN9, DIGITAL_MIXER_IN10, DIGITAL_MIXER_IN11,
+	GAINFUNC0_IN, GAINFUNC1_IN, GAINFUNC2_IN, GAINFUNC3_IN, GAINFUNC4_IN,
+	SOFTMODEMRX, SPLITTER0_IN, SPLITTER1_IN, SPLITTER2_IN, SPLITTER3_IN,
+	MERGER0_INL, MERGER0_INR, MERGER1_INL, MERGER1_INR, MERGER2_INL,
+	MERGER2_INR, MERGER3_INL, MERGER3_INR, E2SINK_MAX
+};
+
+enum LBUS_SINK {
+	LS_SRC_INTERPOLATOR = 0, LS_SRC_INTERPOLATORM, LS_SRC_DECIMATOR,
+	LS_SRC_DECIMATORM, LS_MIXER_IN, LS_MIXER_GAIN_FUNCTION,
+	LS_SRC_SPLITTER, LS_SRC_MERGER, LS_NONE1, LS_NONE2,
+};
+
+enum RT_CHANNEL_IDS {
+	M0TX = 0, M1TX, TAMTX, HSSPKR, PDAC, DSNDTX0, DSNDTX1, DSNDTX2,
+	DSNDTX3, DSNDTX4, DSNDTX5, DSNDTX6, DSNDTX7, WVSTRTX, COP3DTX, SPARE,
+	M0RX, HSMIC, M1RX, CLEANRX, MICADC, PADC, COPRX1, COPRX2,
+	CHANNEL_ID_COUNTER
+};
+
+enum { SB_CMD = 0, MODEM_CMD, I2S_CMD0, I2S_CMD1, FM_CMD, MAX_CMD };
+
+struct lbuspath {
+	unsigned char *noconv;
+	unsigned char *stereo;
+	unsigned char *mono;
+};
+
+struct cmdport {
+	u32 data1;		/* cmd,param */
+	u32 data2;		/* param */
+	u32 stat;		/* status */
+	u32 pad[5];
+};
+
+struct riptideport {
+	u32 audio_control;	/* status registers */
+	u32 audio_status;
+	u32 pad[2];
+	struct cmdport port[2];	/* command ports */
+};
+
+struct cmdif {
+	struct riptideport *hwport;
+	spinlock_t lock;
+	unsigned int cmdcnt;	/* cmd statistics */
+	unsigned int cmdtime;
+	unsigned int cmdtimemax;
+	unsigned int cmdtimemin;
+	unsigned int errcnt;
+	int is_reset;
+};
+
+struct riptide_firmware {
+	u16 ASIC;
+	u16 CODEC;
+	u16 AUXDSP;
+	u16 PROG;
+};
+
+union cmdret {
+	u8 retbytes[8];
+	u16 retwords[4];
+	u32 retlongs[2];
+};
+
+union firmware_version {
+	union cmdret ret;
+	struct riptide_firmware firmware;
+};
+
+#define get_pcmhwdev(substream) (struct pcmhw *)(substream->runtime->private_data)
+
+#define PLAYBACK_SUBSTREAMS 3
+struct snd_riptide {
+	struct snd_card *card;
+	struct pci_dev *pci;
+	const struct firmware *fw_entry;
+
+	struct cmdif *cif;
+
+	struct snd_pcm *pcm;
+	struct snd_pcm *pcm_i2s;
+	struct snd_rawmidi *rmidi;
+	struct snd_opl3 *opl3;
+	struct snd_ac97 *ac97;
+	struct snd_ac97_bus *ac97_bus;
+
+	struct snd_pcm_substream *playback_substream[PLAYBACK_SUBSTREAMS];
+	struct snd_pcm_substream *capture_substream;
+
+	int openstreams;
+
+	int irq;
+	unsigned long port;
+	unsigned short mpuaddr;
+	unsigned short opladdr;
+#ifdef SUPPORT_JOYSTICK
+	unsigned short gameaddr;
+#endif
+	struct resource *res_port;
+
+	unsigned short device_id;
+
+	union firmware_version firmware;
+
+	spinlock_t lock;
+	struct tasklet_struct riptide_tq;
+	struct snd_info_entry *proc_entry;
+
+	unsigned long received_irqs;
+	unsigned long handled_irqs;
+#ifdef CONFIG_PM
+	int in_suspend;
+#endif
+};
+
+struct sgd {			/* scatter gather desriptor */
+	u32 dwNextLink;
+	u32 dwSegPtrPhys;
+	u32 dwSegLen;
+	u32 dwStat_Ctl;
+};
+
+struct pcmhw {			/* pcm descriptor */
+	struct lbuspath paths;
+	unsigned char *lbuspath;
+	unsigned char source;
+	unsigned char intdec[2];
+	unsigned char mixer;
+	unsigned char id;
+	unsigned char state;
+	unsigned int rate;
+	unsigned int channels;
+	snd_pcm_format_t format;
+	struct snd_dma_buffer sgdlist;
+	struct sgd *sgdbuf;
+	unsigned int size;
+	unsigned int pages;
+	unsigned int oldpos;
+	unsigned int pointer;
+};
+
+#define CMDRET_ZERO (union cmdret){{(u32)0, (u32) 0}}
+
+static int sendcmd(struct cmdif *cif, u32 flags, u32 cmd, u32 parm,
+		   union cmdret *ret);
+static int getsourcesink(struct cmdif *cif, unsigned char source,
+			 unsigned char sink, unsigned char *a,
+			 unsigned char *b);
+static int snd_riptide_initialize(struct snd_riptide *chip);
+static int riptide_reset(struct cmdif *cif, struct snd_riptide *chip);
+
+/*
+ */
+
+static struct pci_device_id snd_riptide_ids[] = {
+	{
+	 .vendor = 0x127a,.device = 0x4310,
+	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
+	 },
+	{
+	 .vendor = 0x127a,.device = 0x4320,
+	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
+	 },
+	{
+	 .vendor = 0x127a,.device = 0x4330,
+	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
+	 },
+	{
+	 .vendor = 0x127a,.device = 0x4340,
+	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
+	 },
+	{0,},
+};
+
+#ifdef SUPPORT_JOYSTICK
+static struct pci_device_id snd_riptide_joystick_ids[] = {
+	{
+	 .vendor = 0x127a,.device = 0x4312,
+	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
+	 },
+	{
+	 .vendor = 0x127a,.device = 0x4322,
+	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
+	 },
+	{.vendor = 0x127a,.device = 0x4332,
+	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
+	 },
+	{.vendor = 0x127a,.device = 0x4342,
+	 .subvendor = PCI_ANY_ID,.subdevice = PCI_ANY_ID,
+	 },
+	{0,},
+};
+#endif
+
+MODULE_DEVICE_TABLE(pci, snd_riptide_ids);
+
+/*
+ */
+
+static unsigned char lbusin2out[E2SINK_MAX + 1][2] = {
+	{NO_OUT, LS_NONE1}, {NO_OUT, LS_NONE2}, {NO_OUT, LS_NONE1}, {NO_OUT,
+								     LS_NONE2},
+	{NO_OUT, LS_NONE1}, {NO_OUT, LS_NONE2}, {NO_OUT, LS_NONE1}, {NO_OUT,
+								     LS_NONE2},
+	{INTER0_OUT, LS_SRC_INTERPOLATOR}, {INTER1_OUT, LS_SRC_INTERPOLATOR},
+	{INTER2_OUT, LS_SRC_INTERPOLATOR}, {INTER3_OUT, LS_SRC_INTERPOLATOR},
+	{INTER4_OUT, LS_SRC_INTERPOLATOR}, {INTERM0_OUT, LS_SRC_INTERPOLATORM},
+	{INTERM1_OUT, LS_SRC_INTERPOLATORM}, {INTERM2_OUT,
+					      LS_SRC_INTERPOLATORM},
+	{INTERM3_OUT, LS_SRC_INTERPOLATORM}, {INTERM4_OUT,
+					      LS_SRC_INTERPOLATORM},
+	{INTERM5_OUT, LS_SRC_INTERPOLATORM}, {INTERM6_OUT,
+					      LS_SRC_INTERPOLATORM},
+	{DECIMM0_OUT, LS_SRC_DECIMATORM}, {DECIMM1_OUT, LS_SRC_DECIMATORM},
+	{DECIMM2_OUT, LS_SRC_DECIMATORM}, {DECIMM3_OUT, LS_SRC_DECIMATORM},
+	{DECIM0_OUT, LS_SRC_DECIMATOR}, {SR3_4_OUT, LS_NONE1}, {NO_OUT,
+								LS_NONE2},
+	{NO_OUT, LS_NONE1}, {NO_OUT, LS_NONE2}, {NO_OUT, LS_NONE1},
+	{DIGITAL_MIXER_OUT0, LS_MIXER_IN}, {DIGITAL_MIXER_OUT0, LS_MIXER_IN},
+	{DIGITAL_MIXER_OUT0, LS_MIXER_IN}, {DIGITAL_MIXER_OUT0, LS_MIXER_IN},
+	{DIGITAL_MIXER_OUT0, LS_MIXER_IN}, {DIGITAL_MIXER_OUT0, LS_MIXER_IN},
+	{DIGITAL_MIXER_OUT0, LS_MIXER_IN}, {DIGITAL_MIXER_OUT0, LS_MIXER_IN},
+	{DIGITAL_MIXER_OUT0, LS_MIXER_IN}, {DIGITAL_MIXER_OUT0, LS_MIXER_IN},
+	{DIGITAL_MIXER_OUT0, LS_MIXER_IN}, {DIGITAL_MIXER_OUT0, LS_MIXER_IN},
+	{GAINFUNC0_OUT, LS_MIXER_GAIN_FUNCTION}, {GAINFUNC1_OUT,
+						  LS_MIXER_GAIN_FUNCTION},
+	{GAINFUNC2_OUT, LS_MIXER_GAIN_FUNCTION}, {GAINFUNC3_OUT,
+						  LS_MIXER_GAIN_FUNCTION},
+	{GAINFUNC4_OUT, LS_MIXER_GAIN_FUNCTION}, {SOFTMODEMTX, LS_NONE1},
+	{SPLITTER0_OUTL, LS_SRC_SPLITTER}, {SPLITTER1_OUTL, LS_SRC_SPLITTER},
+	{SPLITTER2_OUTL, LS_SRC_SPLITTER}, {SPLITTER3_OUTL, LS_SRC_SPLITTER},
+	{MERGER0_OUT, LS_SRC_MERGER}, {MERGER0_OUT, LS_SRC_MERGER},
+	{MERGER1_OUT, LS_SRC_MERGER},
+	{MERGER1_OUT, LS_SRC_MERGER}, {MERGER2_OUT, LS_SRC_MERGER},
+	{MERGER2_OUT, LS_SRC_MERGER},
+	{MERGER3_OUT, LS_SRC_MERGER}, {MERGER3_OUT, LS_SRC_MERGER}, {NO_OUT,
+								     LS_NONE2},
+};
+
+static unsigned char lbus_play_opl3[] = {
+	DIGITAL_MIXER_IN0 + FM_MIXER, 0xff
+};
+static unsigned char lbus_play_modem[] = {
+	DIGITAL_MIXER_IN0 + MODEM_MIXER, 0xff
+};
+static unsigned char lbus_play_i2s[] = {
+	INTER0_IN + I2S_INTDEC, DIGITAL_MIXER_IN0 + I2S_MIXER, 0xff
+};
+static unsigned char lbus_play_out[] = {
+	PDAC2ACLNK, 0xff
+};
+static unsigned char lbus_play_outhp[] = {
+	HNDSPK2ACLNK, 0xff
+};
+static unsigned char lbus_play_noconv1[] = {
+	DIGITAL_MIXER_IN0, 0xff
+};
+static unsigned char lbus_play_stereo1[] = {
+	INTER0_IN, DIGITAL_MIXER_IN0, 0xff
+};
+static unsigned char lbus_play_mono1[] = {
+	INTERM0_IN, DIGITAL_MIXER_IN0, 0xff
+};
+static unsigned char lbus_play_noconv2[] = {
+	DIGITAL_MIXER_IN1, 0xff
+};
+static unsigned char lbus_play_stereo2[] = {
+	INTER1_IN, DIGITAL_MIXER_IN1, 0xff
+};
+static unsigned char lbus_play_mono2[] = {
+	INTERM1_IN, DIGITAL_MIXER_IN1, 0xff
+};
+static unsigned char lbus_play_noconv3[] = {
+	DIGITAL_MIXER_IN2, 0xff
+};
+static unsigned char lbus_play_stereo3[] = {
+	INTER2_IN, DIGITAL_MIXER_IN2, 0xff
+};
+static unsigned char lbus_play_mono3[] = {
+	INTERM2_IN, DIGITAL_MIXER_IN2, 0xff
+};
+static unsigned char lbus_rec_noconv1[] = {
+	LBUS2ARM_FIFO5, 0xff
+};
+static unsigned char lbus_rec_stereo1[] = {
+	DECIM0_IN, LBUS2ARM_FIFO5, 0xff
+};
+static unsigned char lbus_rec_mono1[] = {
+	DECIMM3_IN, LBUS2ARM_FIFO5, 0xff
+};
+
+static unsigned char play_ids[] = { 4, 1, 2, };
+static unsigned char play_sources[] = {
+	ARM2LBUS_FIFO4, ARM2LBUS_FIFO1, ARM2LBUS_FIFO2,
+};
+static struct lbuspath lbus_play_paths[] = {
+	{
+	 .noconv = lbus_play_noconv1,
+	 .stereo = lbus_play_stereo1,
+	 .mono = lbus_play_mono1,
+	 },
+	{
+	 .noconv = lbus_play_noconv2,
+	 .stereo = lbus_play_stereo2,
+	 .mono = lbus_play_mono2,
+	 },
+	{
+	 .noconv = lbus_play_noconv3,
+	 .stereo = lbus_play_stereo3,
+	 .mono = lbus_play_mono3,
+	 },
+};
+static struct lbuspath lbus_rec_path = {
+	.noconv = lbus_rec_noconv1,
+	.stereo = lbus_rec_stereo1,
+	.mono = lbus_rec_mono1,
+};
+
+#define FIRMWARE_VERSIONS 1
+static union firmware_version firmware_versions[] = {
+	{
+	 .firmware.ASIC = 3,.firmware.CODEC = 2,
+	 .firmware.AUXDSP = 3,.firmware.PROG = 773,
+	 },
+};
+
+static u32 atoh(unsigned char *in, unsigned int len)
+{
+	u32 sum = 0;
+	unsigned int mult = 1;
+	unsigned char c;
+
+	while (len) {
+		c = in[len - 1];
+		if ((c >= '0') && (c <= '9'))
+			sum += mult * (c - '0');
+		else if ((c >= 'A') && (c <= 'F'))
+			sum += mult * (c - ('A' - 10));
+		else if ((c >= 'a') && (c <= 'f'))
+			sum += mult * (c - ('a' - 10));
+		mult *= 16;
+		--len;
+	}
+	return sum;
+}
+
+static int senddata(struct cmdif *cif, unsigned char *in, u32 offset)
+{
+	u32 addr;
+	u32 data;
+	u32 i;
+	unsigned char *p;
+
+	i = atoh(&in[1], 2);
+	addr = offset + atoh(&in[3], 4);
+	if (SEND_SMEM(cif, 0, addr) != 0)
+		return -EACCES;
+	p = in + 9;
+	while (i) {
+		data = atoh(p, 8);
+		if (SEND_WMEM(cif, 2,
+			      ((data & 0x0f0f0f0f) << 4) | ((data & 0xf0f0f0f0)
+							    >> 4)))
+			return -EACCES;
+		i -= 4;
+		p += 8;
+	}
+	return 0;
+}
+
+static int loadfirmware(struct cmdif *cif, unsigned char *img,
+			unsigned int size)
+{
+	unsigned char *in;
+	u32 laddr, saddr, t, val;
+	int err = 0;
+
+	laddr = saddr = 0;
+	while (size > 0 && err == 0) {
+		in = img;
+		if (in[0] == ':') {
+			t = atoh(&in[7], 2);
+			switch (t) {
+			case DATA_REC:
+				err = senddata(cif, in, laddr + saddr);
+				break;
+			case EXT_SEG_ADDR_REC:
+				saddr = atoh(&in[9], 4) << 4;
+				break;
+			case EXT_LIN_ADDR_REC:
+				laddr = atoh(&in[9], 4) << 16;
+				break;
+			case EXT_GOTO_CMD_REC:
+				val = atoh(&in[9], 8);
+				if (SEND_GOTO(cif, val) != 0)
+					err = -EACCES;
+				break;
+			case EXT_END_OF_FILE:
+				size = 0;
+				break;
+			default:
+				break;
+			}
+			while (size > 0) {
+				size--;
+				if (*img++ == '\n')
+					break;
+			}
+		}
+	}
+	snd_printdd("load firmware return %d\n", err);
+	return err;
+}
+
+static void
+alloclbuspath(struct cmdif *cif, unsigned char source,
+	      unsigned char *path, unsigned char *mixer, unsigned char *s)
+{
+	while (*path != 0xff) {
+		unsigned char sink, type;
+
+		sink = *path & (~SPLIT_PATH);
+		if (sink != E2SINK_MAX) {
+			snd_printdd("alloc path 0x%x->0x%x\n", source, sink);
+			SEND_PSEL(cif, source, sink);
+			source = lbusin2out[sink][0];
+			type = lbusin2out[sink][1];
+			if (type == LS_MIXER_IN) {
+				if (mixer)
+					*mixer = sink - DIGITAL_MIXER_IN0;
+			}
+			if (type == LS_SRC_DECIMATORM ||
+			    type == LS_SRC_DECIMATOR ||
+			    type == LS_SRC_INTERPOLATORM ||
+			    type == LS_SRC_INTERPOLATOR) {
+				if (s) {
+					if (s[0] != 0xff)
+						s[1] = sink;
+					else
+						s[0] = sink;
+				}
+			}
+		}
+		if (*path++ & SPLIT_PATH) {
+			unsigned char *npath = path;
+
+			while (*npath != 0xff)
+				npath++;
+			alloclbuspath(cif, source + 1, ++npath, mixer, s);
+		}
+	}
+}
+
+static void
+freelbuspath(struct cmdif *cif, unsigned char source, unsigned char *path)
+{
+	while (*path != 0xff) {
+		unsigned char sink;
+
+		sink = *path & (~SPLIT_PATH);
+		if (sink != E2SINK_MAX) {
+			snd_printdd("free path 0x%x->0x%x\n", source, sink);
+			SEND_PCLR(cif, source, sink);
+			source = lbusin2out[sink][0];
+		}
+		if (*path++ & SPLIT_PATH) {
+			unsigned char *npath = path;
+
+			while (*npath != 0xff)
+				npath++;
+			freelbuspath(cif, source + 1, ++npath);
+		}
+	}
+}
+
+static int writearm(struct cmdif *cif, u32 addr, u32 data, u32 mask)
+{
+	union cmdret rptr = CMDRET_ZERO;
+	unsigned int i = MAX_WRITE_RETRY;
+	int flag = 1;
+
+	SEND_RMEM(cif, 0x02, addr, &rptr);
+	rptr.retlongs[0] &= (~mask);
+
+	while (--i) {
+		SEND_SMEM(cif, 0x01, addr);
+		SEND_WMEM(cif, 0x02, (rptr.retlongs[0] | data));
+		SEND_RMEM(cif, 0x02, addr, &rptr);
+		if ((rptr.retlongs[0] & data) == data) {
+			flag = 0;
+			break;
+		} else
+			rptr.retlongs[0] &= ~mask;
+	}
+	snd_printdd("send arm 0x%x 0x%x 0x%x return %d\n", addr, data, mask,
+		    flag);
+	return flag;
+}
+
+static int sendcmd(struct cmdif *cif, u32 flags, u32 cmd, u32 parm,
+		   union cmdret *ret)
+{
+	int i, j;
+	int err;
+	unsigned int time = 0;
+	unsigned long irqflags;
+	struct riptideport *hwport;
+	struct cmdport *cmdport = NULL;
+
+	snd_assert(cif, return -EINVAL);
+
+	hwport = cif->hwport;
+	if (cif->errcnt > MAX_ERROR_COUNT) {
+		if (cif->is_reset) {
+			snd_printk(KERN_ERR
+				   "Riptide: Too many failed cmds, reinitializing\n");
+			if (riptide_reset(cif, NULL) == 0) {
+				cif->errcnt = 0;
+				return -EIO;
+			}
+		}
+		snd_printk(KERN_ERR "Riptide: Initialization failed.\n");
+		return -EINVAL;
+	}
+	if (ret) {
+		ret->retlongs[0] = 0;
+		ret->retlongs[1] = 0;
+	}
+	i = 0;
+	spin_lock_irqsave(&cif->lock, irqflags);
+	while (i++ < CMDIF_TIMEOUT && !IS_READY(cif->hwport))
+		udelay(10);
+	if (i >= CMDIF_TIMEOUT) {
+		err = -EBUSY;
+		goto errout;
+	}
+
+	err = 0;
+	for (j = 0, time = 0; time < CMDIF_TIMEOUT; j++, time += 2) {
+		cmdport = &(hwport->port[j % 2]);
+		if (IS_DATF(cmdport)) {	/* free pending data */
+			READ_PORT_ULONG(cmdport->data1);
+			READ_PORT_ULONG(cmdport->data2);
+		}
+		if (IS_CMDE(cmdport)) {
+			if (flags & PARM)	/* put data */
+				WRITE_PORT_ULONG(cmdport->data2, parm);
+			WRITE_PORT_ULONG(cmdport->data1, cmd);	/* write cmd */
+			if ((flags & RESP) && ret) {
+				while (!IS_DATF(cmdport) &&
+				       time++ < CMDIF_TIMEOUT)
+					udelay(10);
+				if (time < CMDIF_TIMEOUT) {	/* read response */
+					ret->retlongs[0] =
+					    READ_PORT_ULONG(cmdport->data1);
+					ret->retlongs[1] =
+					    READ_PORT_ULONG(cmdport->data2);
+				} else {
+					err = -ENOSYS;
+					goto errout;
+				}
+			}
+			break;
+		}
+		udelay(20);
+	}
+	if (time == CMDIF_TIMEOUT) {
+		err = -ENODATA;
+		goto errout;
+	}
+	spin_unlock_irqrestore(&cif->lock, irqflags);
+
+	cif->cmdcnt++;		/* update command statistics */
+	cif->cmdtime += time;
+	if (time > cif->cmdtimemax)
+		cif->cmdtimemax = time;
+	if (time < cif->cmdtimemin)
+		cif->cmdtimemin = time;
+	if ((cif->cmdcnt) % 1000 == 0)
+		snd_printdd
+		    ("send cmd %d time: %d mintime: %d maxtime %d err: %d\n",
+		     cif->cmdcnt, cif->cmdtime, cif->cmdtimemin,
+		     cif->cmdtimemax, cif->errcnt);
+	return 0;
+
+      errout:
+	cif->errcnt++;
+	spin_unlock_irqrestore(&cif->lock, irqflags);
+	snd_printdd
+	    ("send cmd %d hw: 0x%x flag: 0x%x cmd: 0x%x parm: 0x%x ret: 0x%x 0x%x CMDE: %d DATF: %d failed %d\n",
+	     cif->cmdcnt, (int)((void *)&(cmdport->stat) - (void *)hwport),
+	     flags, cmd, parm, ret ? ret->retlongs[0] : 0,
+	     ret ? ret->retlongs[1] : 0, IS_CMDE(cmdport), IS_DATF(cmdport),
+	     err);
+	return err;
+}
+
+static int
+setmixer(struct cmdif *cif, short num, unsigned short rval, unsigned short lval)
+{
+	union cmdret rptr = CMDRET_ZERO;
+	int i = 0;
+
+	snd_printdd("sent mixer %d: 0x%d 0x%d\n", num, rval, lval);
+	do {
+		SEND_SDGV(cif, num, num, rval, lval);
+		SEND_RDGV(cif, num, num, &rptr);
+		if (rptr.retwords[0] == lval && rptr.retwords[1] == rval)
+			return 0;
+	} while (i++ < MAX_WRITE_RETRY);
+	snd_printdd("sent mixer failed\n");
+	return -EIO;
+}
+
+static int getpaths(struct cmdif *cif, unsigned char *o)
+{
+	unsigned char src[E2SINK_MAX];
+	unsigned char sink[E2SINK_MAX];
+	int i, j = 0;
+
+	for (i = 0; i < E2SINK_MAX; i++) {
+		getsourcesink(cif, i, i, &src[i], &sink[i]);
+		if (sink[i] < E2SINK_MAX) {
+			o[j++] = sink[i];
+			o[j++] = i;
+		}
+	}
+	return j;
+}
+
+static int
+getsourcesink(struct cmdif *cif, unsigned char source, unsigned char sink,
+	      unsigned char *a, unsigned char *b)
+{
+	union cmdret rptr = CMDRET_ZERO;
+
+	if (SEND_RSSV(cif, source, sink, &rptr) &&
+	    SEND_RSSV(cif, source, sink, &rptr))
+		return -EIO;
+	*a = rptr.retbytes[0];
+	*b = rptr.retbytes[1];
+	snd_printdd("getsourcesink 0x%x 0x%x\n", *a, *b);
+	return 0;
+}
+
+static int
+getsamplerate(struct cmdif *cif, unsigned char *intdec, unsigned int *rate)
+{
+	unsigned char *s;
+	unsigned int p[2] = { 0, 0 };
+	int i;
+	union cmdret rptr = CMDRET_ZERO;
+
+	s = intdec;
+	for (i = 0; i < 2; i++) {
+		if (*s != 0xff) {
+			if (SEND_RSRC(cif, *s, &rptr) &&
+			    SEND_RSRC(cif, *s, &rptr))
+				return -EIO;
+			p[i] += rptr.retwords[1];
+			p[i] *= rptr.retwords[2];
+			p[i] += rptr.retwords[3];
+			p[i] /= 65536;
+		}
+		s++;
+	}
+	if (p[0]) {
+		if (p[1] != p[0])
+			snd_printdd("rates differ %d %d\n", p[0], p[1]);
+		*rate = (unsigned int)p[0];
+	} else
+		*rate = (unsigned int)p[1];
+	snd_printdd("getsampleformat %d %d %d\n", intdec[0], intdec[1], *rate);
+	return 0;
+}
+
+static int
+setsampleformat(struct cmdif *cif,
+		unsigned char mixer, unsigned char id,
+		unsigned char channels, unsigned char format)
+{
+	unsigned char w, ch, sig, order;
+
+	snd_printdd
+	    ("setsampleformat mixer: %d id: %d channels: %d format: %d\n",
+	     mixer, id, channels, format);
+	ch = channels == 1;
+	w = snd_pcm_format_width(format) == 8;
+	sig = snd_pcm_format_unsigned(format) != 0;
+	order = snd_pcm_format_big_endian(format) != 0;
+
+	if (SEND_SETF(cif, mixer, w, ch, order, sig, id) &&
+	    SEND_SETF(cif, mixer, w, ch, order, sig, id)) {
+		snd_printdd("setsampleformat failed\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static int
+setsamplerate(struct cmdif *cif, unsigned char *intdec, unsigned int rate)
+{
+	u32 D, M, N;
+	union cmdret rptr = CMDRET_ZERO;
+	int i;
+
+	snd_printdd("setsamplerate intdec: %d,%d rate: %d\n", intdec[0],
+		    intdec[1], rate);
+	D = 48000;
+	M = ((rate == 48000) ? 47999 : rate) * 65536;
+	N = M % D;
+	M /= D;
+	for (i = 0; i < 2; i++) {
+		if (*intdec != 0xff) {
+			do {
+				SEND_SSRC(cif, *intdec, D, M, N);
+				SEND_RSRC(cif, *intdec, &rptr);
+			} while (rptr.retwords[1] != D &&
+				 rptr.retwords[2] != M &&
+				 rptr.retwords[3] != N &&
+				 i++ < MAX_WRITE_RETRY);
+			if (i == MAX_WRITE_RETRY) {
+				snd_printdd("sent samplerate %d: %d failed\n",
+					    *intdec, rate);
+				return -EIO;
+			}
+		}
+		intdec++;
+	}
+	return 0;
+}
+
+static int
+getmixer(struct cmdif *cif, short num, unsigned short *rval,
+	 unsigned short *lval)
+{
+	union cmdret rptr = CMDRET_ZERO;
+
+	if (SEND_RDGV(cif, num, num, &rptr) && SEND_RDGV(cif, num, num, &rptr))
+		return -EIO;
+	*rval = rptr.retwords[0];
+	*lval = rptr.retwords[1];
+	snd_printdd("got mixer %d: 0x%d 0x%d\n", num, *rval, *lval);
+	return 0;
+}
+
+static void riptide_handleirq(unsigned long dev_id)
+{
+	struct snd_riptide *chip = (void *)dev_id;
+	struct cmdif *cif = chip->cif;
+	struct snd_pcm_substream *substream[PLAYBACK_SUBSTREAMS + 1];
+	struct snd_pcm_runtime *runtime;
+	struct pcmhw *data = NULL;
+	unsigned int pos, period_bytes;
+	struct sgd *c;
+	int i, j;
+	unsigned int flag;
+
+	if (!cif)
+		return;
+
+	for (i = 0; i < PLAYBACK_SUBSTREAMS; i++)
+		substream[i] = chip->playback_substream[i];
+	substream[i] = chip->capture_substream;
+	for (i = 0; i < PLAYBACK_SUBSTREAMS + 1; i++) {
+		if (substream[i] &&
+		    (runtime = substream[i]->runtime) &&
+		    (data = runtime->private_data) && data->state != ST_STOP) {
+			pos = 0;
+			for (j = 0; j < data->pages; j++) {
+				c = &data->sgdbuf[j];
+				flag = le32_to_cpu(c->dwStat_Ctl);
+				if (flag & EOB_STATUS)
+					pos += le32_to_cpu(c->dwSegLen);
+				if (flag & EOC_STATUS)
+					pos += le32_to_cpu(c->dwSegLen);
+				if ((flag & EOS_STATUS)
+				    && (data->state == ST_PLAY)) {
+					data->state = ST_STOP;
+					snd_printk(KERN_ERR
+						   "Riptide: DMA stopped unexpectedly\n");
+				}
+				c->dwStat_Ctl =
+				    cpu_to_le32(flag &
+						~(EOS_STATUS | EOB_STATUS |
+						  EOC_STATUS));
+			}
+			data->pointer += pos;
+			pos += data->oldpos;
+			if (data->state != ST_STOP) {
+				period_bytes =
+				    frames_to_bytes(runtime,
+						    runtime->period_size);
+				snd_printdd
+				    ("interrupt 0x%x after 0x%lx of 0x%lx frames in period\n",
+				     READ_AUDIO_STATUS(cif->hwport),
+				     bytes_to_frames(runtime, pos),
+				     runtime->period_size);
+				j = 0;
+				if (pos >= period_bytes) {
+					j++;
+					while (pos >= period_bytes)
+						pos -= period_bytes;
+				}
+				data->oldpos = pos;
+				if (j > 0)
+					snd_pcm_period_elapsed(substream[i]);
+			}
+		}
+	}
+}
+
+#ifdef CONFIG_PM
+static int riptide_suspend(struct pci_dev *pci, pm_message_t state)
+{
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct snd_riptide *chip = card->private_data;
+
+	chip->in_suspend = 1;
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	snd_pcm_suspend_all(chip->pcm);
+	snd_ac97_suspend(chip->ac97);
+	pci_set_power_state(pci, PCI_D3hot);
+	pci_disable_device(pci);
+	pci_save_state(pci);
+	return 0;
+}
+
+static int riptide_resume(struct pci_dev *pci)
+{
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct snd_riptide *chip = card->private_data;
+
+	pci_restore_state(pci);
+	pci_enable_device(pci);
+	pci_set_power_state(pci, PCI_D0);
+	pci_set_master(pci);
+	snd_riptide_initialize(chip);
+	snd_ac97_resume(chip->ac97);
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	chip->in_suspend = 0;
+	return 0;
+}
+#endif
+
+static int riptide_reset(struct cmdif *cif, struct snd_riptide *chip)
+{
+	int timeout, tries;
+	union cmdret rptr = CMDRET_ZERO;
+	union firmware_version firmware;
+	int i, j, err, has_firmware;
+
+	if (!cif)
+		return -EINVAL;
+
+	cif->cmdcnt = 0;
+	cif->cmdtime = 0;
+	cif->cmdtimemax = 0;
+	cif->cmdtimemin = 0xffffffff;
+	cif->errcnt = 0;
+	cif->is_reset = 0;
+
+	tries = RESET_TRIES;
+	has_firmware = 0;
+	while (has_firmware == 0 && tries-- > 0) {
+		for (i = 0; i < 2; i++) {
+			WRITE_PORT_ULONG(cif->hwport->port[i].data1, 0);
+			WRITE_PORT_ULONG(cif->hwport->port[i].data2, 0);
+		}
+		SET_GRESET(cif->hwport);
+		udelay(100);
+		UNSET_GRESET(cif->hwport);
+		udelay(100);
+
+		for (timeout = 100000; --timeout; udelay(10)) {
+			if (IS_READY(cif->hwport) && !IS_GERR(cif->hwport))
+				break;
+		}
+		if (timeout == 0) {
+			snd_printk(KERN_ERR
+				   "Riptide: device not ready, audio status: 0x%x ready: %d gerr: %d\n",
+				   READ_AUDIO_STATUS(cif->hwport),
+				   IS_READY(cif->hwport), IS_GERR(cif->hwport));
+			return -EIO;
+		} else {
+			snd_printdd
+			    ("Riptide: audio status: 0x%x ready: %d gerr: %d\n",
+			     READ_AUDIO_STATUS(cif->hwport),
+			     IS_READY(cif->hwport), IS_GERR(cif->hwport));
+		}
+
+		SEND_GETV(cif, &rptr);
+		for (i = 0; i < 4; i++)
+			firmware.ret.retwords[i] = rptr.retwords[i];
+
+		snd_printdd
+		    ("Firmware version: ASIC: %d CODEC %d AUXDSP %d PROG %d\n",
+		     firmware.firmware.ASIC, firmware.firmware.CODEC,
+		     firmware.firmware.AUXDSP, firmware.firmware.PROG);
+
+		for (j = 0; j < FIRMWARE_VERSIONS; j++) {
+			has_firmware = 1;
+			for (i = 0; i < 4; i++) {
+				if (firmware_versions[j].ret.retwords[i] !=
+				    firmware.ret.retwords[i])
+					has_firmware = 0;
+			}
+			if (has_firmware)
+				break;
+		}
+
+		if (chip != NULL && has_firmware == 0) {
+			snd_printdd("Writing Firmware\n");
+			if (!chip->fw_entry) {
+				if ((err =
+				     request_firmware(&chip->fw_entry,
+						      "riptide.hex",
+						      &chip->pci->dev)) != 0) {
+					snd_printk(KERN_ERR
+						   "Riptide: Firmware not available %d\n",
+						   err);
+					return -EIO;
+				}
+			}
+			err = loadfirmware(cif, chip->fw_entry->data,
+					   chip->fw_entry->size);
+			if (err)
+				snd_printk(KERN_ERR
+					   "Riptide: Could not load firmware %d\n",
+					   err);
+		}
+	}
+
+	SEND_SACR(cif, 0, AC97_RESET);
+	SEND_RACR(cif, AC97_RESET, &rptr);
+	snd_printdd("AC97: 0x%x 0x%x\n", rptr.retlongs[0], rptr.retlongs[1]);
+
+	SEND_PLST(cif, 0);
+	SEND_SLST(cif, 0);
+	SEND_DLST(cif, 0);
+	SEND_ALST(cif, 0);
+	SEND_KDMA(cif);
+
+	writearm(cif, 0x301F8, 1, 1);
+	writearm(cif, 0x301F4, 1, 1);
+
+	SEND_LSEL(cif, MODEM_CMD, 0, 0, MODEM_INTDEC, MODEM_MERGER,
+		  MODEM_SPLITTER, MODEM_MIXER);
+	setmixer(cif, MODEM_MIXER, 0x7fff, 0x7fff);
+	alloclbuspath(cif, ARM2LBUS_FIFO13, lbus_play_modem, NULL, NULL);
+
+	SEND_LSEL(cif, FM_CMD, 0, 0, FM_INTDEC, FM_MERGER, FM_SPLITTER,
+		  FM_MIXER);
+	setmixer(cif, FM_MIXER, 0x7fff, 0x7fff);
+	writearm(cif, 0x30648 + FM_MIXER * 4, 0x01, 0x00000005);
+	writearm(cif, 0x301A8, 0x02, 0x00000002);
+	writearm(cif, 0x30264, 0x08, 0xffffffff);
+	alloclbuspath(cif, OPL3_SAMPLE, lbus_play_opl3, NULL, NULL);
+
+	SEND_SSRC(cif, I2S_INTDEC, 48000,
+		  ((u32) I2S_RATE * 65536) / 48000,
+		  ((u32) I2S_RATE * 65536) % 48000);
+	SEND_LSEL(cif, I2S_CMD0, 0, 0, I2S_INTDEC, I2S_MERGER, I2S_SPLITTER,
+		  I2S_MIXER);
+	SEND_SI2S(cif, 1);
+	alloclbuspath(cif, ARM2LBUS_FIFO0, lbus_play_i2s, NULL, NULL);
+	alloclbuspath(cif, DIGITAL_MIXER_OUT0, lbus_play_out, NULL, NULL);
+	alloclbuspath(cif, DIGITAL_MIXER_OUT0, lbus_play_outhp, NULL, NULL);
+
+	SET_AIACK(cif->hwport);
+	SET_AIE(cif->hwport);
+	SET_AIACK(cif->hwport);
+	cif->is_reset = 1;
+	if (chip) {
+		for (i = 0; i < 4; i++)
+			chip->firmware.ret.retwords[i] =
+			    firmware.ret.retwords[i];
+	}
+
+	return 0;
+}
+
+static struct snd_pcm_hardware snd_riptide_playback = {
+	.info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =
+	    SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8
+	    | SNDRV_PCM_FMTBIT_U16_LE,
+	.rates = SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,
+	.rate_min = 5500,
+	.rate_max = 48000,
+	.channels_min = 1,
+	.channels_max = 2,
+	.buffer_bytes_max = (64 * 1024),
+	.period_bytes_min = PAGE_SIZE >> 1,
+	.period_bytes_max = PAGE_SIZE << 8,
+	.periods_min = 2,
+	.periods_max = 64,
+	.fifo_size = 0,
+};
+static struct snd_pcm_hardware snd_riptide_capture = {
+	.info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =
+	    SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8
+	    | SNDRV_PCM_FMTBIT_U16_LE,
+	.rates = SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,
+	.rate_min = 5500,
+	.rate_max = 48000,
+	.channels_min = 1,
+	.channels_max = 2,
+	.buffer_bytes_max = (64 * 1024),
+	.period_bytes_min = PAGE_SIZE >> 1,
+	.period_bytes_max = PAGE_SIZE << 3,
+	.periods_min = 2,
+	.periods_max = 64,
+	.fifo_size = 0,
+};
+
+static snd_pcm_uframes_t snd_riptide_pointer(struct snd_pcm_substream
+					     *substream)
+{
+	struct snd_riptide *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct pcmhw *data = get_pcmhwdev(substream);
+	struct cmdif *cif = chip->cif;
+	union cmdret rptr = CMDRET_ZERO;
+	snd_pcm_uframes_t ret;
+
+	SEND_GPOS(cif, 0, data->id, &rptr);
+	if (data->size && runtime->period_size) {
+		snd_printdd
+		    ("pointer stream %d position 0x%x(0x%x in buffer) bytes 0x%lx(0x%lx in period) frames\n",
+		     data->id, rptr.retlongs[1], rptr.retlongs[1] % data->size,
+		     bytes_to_frames(runtime, rptr.retlongs[1]),
+		     bytes_to_frames(runtime,
+				     rptr.retlongs[1]) % runtime->period_size);
+		if (rptr.retlongs[1] > data->pointer)
+			ret =
+			    bytes_to_frames(runtime,
+					    rptr.retlongs[1] % data->size);
+		else
+			ret =
+			    bytes_to_frames(runtime,
+					    data->pointer % data->size);
+	} else {
+		snd_printdd("stream not started or strange parms (%d %ld)\n",
+			    data->size, runtime->period_size);
+		ret = bytes_to_frames(runtime, 0);
+	}
+	return ret;
+}
+
+static int snd_riptide_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	int i, j;
+	struct snd_riptide *chip = snd_pcm_substream_chip(substream);
+	struct pcmhw *data = get_pcmhwdev(substream);
+	struct cmdif *cif = chip->cif;
+	union cmdret rptr = CMDRET_ZERO;
+
+	spin_lock(&chip->lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		if (!(data->state & ST_PLAY)) {
+			SEND_SSTR(cif, data->id, data->sgdlist.addr);
+			SET_AIE(cif->hwport);
+			data->state = ST_PLAY;
+			if (data->mixer != 0xff)
+				setmixer(cif, data->mixer, 0x7fff, 0x7fff);
+			chip->openstreams++;
+			data->oldpos = 0;
+			data->pointer = 0;
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		if (data->mixer != 0xff)
+			setmixer(cif, data->mixer, 0, 0);
+		setmixer(cif, data->mixer, 0, 0);
+		SEND_KSTR(cif, data->id);
+		data->state = ST_STOP;
+		chip->openstreams--;
+		j = 0;
+		do {
+			i = rptr.retlongs[1];
+			SEND_GPOS(cif, 0, data->id, &rptr);
+			udelay(1);
+		} while (i != rptr.retlongs[1] && j++ < MAX_WRITE_RETRY);
+		if (j >= MAX_WRITE_RETRY)
+			snd_printk(KERN_ERR "Riptide: Could not stop stream!");
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (!(data->state & ST_PAUSE)) {
+			SEND_PSTR(cif, data->id);
+			data->state |= ST_PAUSE;
+			chip->openstreams--;
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (data->state & ST_PAUSE) {
+			SEND_SSTR(cif, data->id, data->sgdlist.addr);
+			data->state &= ~ST_PAUSE;
+			chip->openstreams++;
+		}
+		break;
+	default:
+		spin_unlock(&chip->lock);
+		return -EINVAL;
+	}
+	spin_unlock(&chip->lock);
+	return 0;
+}
+
+static int snd_riptide_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_riptide *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_sg_buf *sgbuf = snd_pcm_substream_sgbuf(substream);
+	struct pcmhw *data = get_pcmhwdev(substream);
+	struct cmdif *cif = chip->cif;
+	unsigned char *lbuspath = NULL;
+	unsigned int rate, channels;
+	int err = 0;
+	snd_pcm_format_t format;
+
+	snd_assert(cif && data, return -EINVAL);
+
+	snd_printdd("prepare id %d ch: %d f:0x%x r:%d\n", data->id,
+		    runtime->channels, runtime->format, runtime->rate);
+
+	spin_lock_irq(&chip->lock);
+	channels = runtime->channels;
+	format = runtime->format;
+	rate = runtime->rate;
+	switch (channels) {
+	case 1:
+		if (rate == 48000 && format == SNDRV_PCM_FORMAT_S16_LE)
+			lbuspath = data->paths.noconv;
+		else
+			lbuspath = data->paths.mono;
+		break;
+	case 2:
+		if (rate == 48000 && format == SNDRV_PCM_FORMAT_S16_LE)
+			lbuspath = data->paths.noconv;
+		else
+			lbuspath = data->paths.stereo;
+		break;
+	}
+	snd_printdd("use sgdlist at 0x%p and buffer at 0x%p\n",
+		    data->sgdlist.area, sgbuf);
+	if (data->sgdlist.area && sgbuf) {
+		unsigned int i, j, size, pages, f, pt, period;
+		struct sgd *c, *p = NULL;
+
+		size = frames_to_bytes(runtime, runtime->buffer_size);
+		period = frames_to_bytes(runtime, runtime->period_size);
+		f = PAGE_SIZE;
+		while ((size + (f >> 1) - 1) <= (f << 7) && (f << 1) > period)
+			f = f >> 1;
+		pages = (size + f - 1) / f;
+		data->size = size;
+		data->pages = pages;
+		snd_printdd
+		    ("create sgd size: 0x%x pages %d of size 0x%x for period 0x%x\n",
+		     size, pages, f, period);
+		pt = 0;
+		j = 0;
+		for (i = 0; i < pages; i++) {
+			c = &data->sgdbuf[i];
+			if (p)
+				p->dwNextLink = cpu_to_le32(data->sgdlist.addr +
+							    (i *
+							     sizeof(struct
+								    sgd)));
+			c->dwNextLink = cpu_to_le32(data->sgdlist.addr);
+			c->dwSegPtrPhys =
+			    cpu_to_le32(sgbuf->table[j].addr + pt);
+			pt = (pt + f) % PAGE_SIZE;
+			if (pt == 0)
+				j++;
+			c->dwSegLen = cpu_to_le32(f);
+			c->dwStat_Ctl =
+			    cpu_to_le32(IEOB_ENABLE | IEOS_ENABLE |
+					IEOC_ENABLE);
+			p = c;
+			size -= f;
+		}
+		data->sgdbuf[i].dwSegLen = cpu_to_le32(size);
+	}
+	if (lbuspath && lbuspath != data->lbuspath) {
+		if (data->lbuspath)
+			freelbuspath(cif, data->source, data->lbuspath);
+		alloclbuspath(cif, data->source, lbuspath,
+			      &data->mixer, data->intdec);
+		data->lbuspath = lbuspath;
+		data->rate = 0;
+	}
+	if (data->rate != rate || data->format != format ||
+	    data->channels != channels) {
+		data->rate = rate;
+		data->format = format;
+		data->channels = channels;
+		if (setsampleformat
+		    (cif, data->mixer, data->id, channels, format)
+		    || setsamplerate(cif, data->intdec, rate))
+			err = -EIO;
+	}
+	spin_unlock_irq(&chip->lock);
+	return err;
+}
+
+static int
+snd_riptide_hw_params(struct snd_pcm_substream *substream,
+		      struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_riptide *chip = snd_pcm_substream_chip(substream);
+	struct pcmhw *data = get_pcmhwdev(substream);
+	struct snd_dma_buffer *sgdlist = &data->sgdlist;
+	int err;
+
+	snd_printdd("hw params id %d (sgdlist: 0x%p 0x%lx %d)\n", data->id,
+		    sgdlist->area, (unsigned long)sgdlist->addr,
+		    (int)sgdlist->bytes);
+	if (sgdlist->area)
+		snd_dma_free_pages(sgdlist);
+	if ((err = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
+				       snd_dma_pci_data(chip->pci),
+				       sizeof(struct sgd) * (DESC_MAX_MASK + 1),
+				       sgdlist)) < 0) {
+		snd_printk(KERN_ERR "Riptide: failed to alloc %d dma bytes\n",
+			   (int)sizeof(struct sgd) * (DESC_MAX_MASK + 1));
+		return err;
+	}
+	data->sgdbuf = (struct sgd *)sgdlist->area;
+	return snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+}
+
+static int snd_riptide_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_riptide *chip = snd_pcm_substream_chip(substream);
+	struct pcmhw *data = get_pcmhwdev(substream);
+	struct cmdif *cif = chip->cif;
+
+	if (cif && data) {
+		if (data->lbuspath)
+			freelbuspath(cif, data->source, data->lbuspath);
+		data->lbuspath = NULL;
+		data->source = 0xff;
+		data->intdec[0] = 0xff;
+		data->intdec[1] = 0xff;
+
+		if (data->sgdlist.area) {
+			snd_dma_free_pages(&data->sgdlist);
+			data->sgdlist.area = NULL;
+		}
+	}
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int snd_riptide_playback_open(struct snd_pcm_substream *substream)
+{
+	struct snd_riptide *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct pcmhw *data;
+	int index = substream->number;
+
+	chip->playback_substream[index] = substream;
+	runtime->hw = snd_riptide_playback;
+	data = kzalloc(sizeof(struct pcmhw), GFP_KERNEL);
+	data->paths = lbus_play_paths[index];
+	data->id = play_ids[index];
+	data->source = play_sources[index];
+	data->intdec[0] = 0xff;
+	data->intdec[1] = 0xff;
+	data->state = ST_STOP;
+	runtime->private_data = data;
+	return snd_pcm_hw_constraint_integer(runtime,
+					     SNDRV_PCM_HW_PARAM_PERIODS);
+}
+
+static int snd_riptide_capture_open(struct snd_pcm_substream *substream)
+{
+	struct snd_riptide *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct pcmhw *data;
+
+	chip->capture_substream = substream;
+	runtime->hw = snd_riptide_capture;
+	data = kzalloc(sizeof(struct pcmhw), GFP_KERNEL);
+	data->paths = lbus_rec_path;
+	data->id = PADC;
+	data->source = ACLNK2PADC;
+	data->intdec[0] = 0xff;
+	data->intdec[1] = 0xff;
+	data->state = ST_STOP;
+	runtime->private_data = data;
+	return snd_pcm_hw_constraint_integer(runtime,
+					     SNDRV_PCM_HW_PARAM_PERIODS);
+}
+
+static int snd_riptide_playback_close(struct snd_pcm_substream *substream)
+{
+	struct snd_riptide *chip = snd_pcm_substream_chip(substream);
+	struct pcmhw *data = get_pcmhwdev(substream);
+	int index = substream->number;
+
+	substream->runtime->private_data = NULL;
+	chip->playback_substream[index] = NULL;
+	kfree(data);
+	return 0;
+}
+
+static int snd_riptide_capture_close(struct snd_pcm_substream *substream)
+{
+	struct snd_riptide *chip = snd_pcm_substream_chip(substream);
+	struct pcmhw *data = get_pcmhwdev(substream);
+
+	substream->runtime->private_data = NULL;
+	chip->capture_substream = NULL;
+	kfree(data);
+	return 0;
+}
+
+static struct snd_pcm_ops snd_riptide_playback_ops = {
+	.open = snd_riptide_playback_open,
+	.close = snd_riptide_playback_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = snd_riptide_hw_params,
+	.hw_free = snd_riptide_hw_free,
+	.prepare = snd_riptide_prepare,
+	.page = snd_pcm_sgbuf_ops_page,
+	.trigger = snd_riptide_trigger,
+	.pointer = snd_riptide_pointer,
+};
+static struct snd_pcm_ops snd_riptide_capture_ops = {
+	.open = snd_riptide_capture_open,
+	.close = snd_riptide_capture_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = snd_riptide_hw_params,
+	.hw_free = snd_riptide_hw_free,
+	.prepare = snd_riptide_prepare,
+	.page = snd_pcm_sgbuf_ops_page,
+	.trigger = snd_riptide_trigger,
+	.pointer = snd_riptide_pointer,
+};
+
+static int __devinit
+snd_riptide_pcm(struct snd_riptide *chip, int device, struct snd_pcm **rpcm)
+{
+	struct snd_pcm *pcm;
+	int err;
+
+	if (rpcm)
+		*rpcm = NULL;
+	if ((err =
+	     snd_pcm_new(chip->card, "RIPTIDE", device, PLAYBACK_SUBSTREAMS, 1,
+			 &pcm)) < 0)
+		return err;
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&snd_riptide_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+			&snd_riptide_capture_ops);
+	pcm->private_data = chip;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "RIPTIDE");
+	chip->pcm = pcm;
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
+					      snd_dma_pci_data(chip->pci),
+					      64 * 1024, 128 * 1024);
+	if (rpcm)
+		*rpcm = pcm;
+	return 0;
+}
+
+static irqreturn_t
+snd_riptide_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct snd_riptide *chip = dev_id;
+	struct cmdif *cif = chip->cif;
+
+	if (cif) {
+		chip->received_irqs++;
+		if (IS_EOBIRQ(cif->hwport) || IS_EOSIRQ(cif->hwport) ||
+		    IS_EOCIRQ(cif->hwport)) {
+			chip->handled_irqs++;
+			tasklet_hi_schedule(&chip->riptide_tq);
+		}
+		if (chip->rmidi && IS_MPUIRQ(cif->hwport)) {
+			chip->handled_irqs++;
+			snd_mpu401_uart_interrupt(irq,
+						  chip->rmidi->private_data,
+						  regs);
+		}
+		SET_AIACK(cif->hwport);
+	}
+	return IRQ_HANDLED;
+}
+
+static void
+snd_riptide_codec_write(struct snd_ac97 *ac97, unsigned short reg,
+			unsigned short val)
+{
+	struct snd_riptide *chip = ac97->private_data;
+	struct cmdif *cif = chip->cif;
+	union cmdret rptr = CMDRET_ZERO;
+	int i = 0;
+
+	snd_assert(cif, return);
+
+	snd_printdd("Write AC97 reg 0x%x 0x%x\n", reg, val);
+	do {
+		SEND_SACR(cif, val, reg);
+		SEND_RACR(cif, reg, &rptr);
+	} while (rptr.retwords[1] != val && i++ < MAX_WRITE_RETRY);
+	if (i == MAX_WRITE_RETRY)
+		snd_printdd("Write AC97 reg failed\n");
+}
+
+static unsigned short snd_riptide_codec_read(struct snd_ac97 *ac97,
+					     unsigned short reg)
+{
+	struct snd_riptide *chip = ac97->private_data;
+	struct cmdif *cif = chip->cif;
+	union cmdret rptr = CMDRET_ZERO;
+
+	snd_assert(cif, return 0);
+
+	if (SEND_RACR(cif, reg, &rptr) != 0)
+		SEND_RACR(cif, reg, &rptr);
+	snd_printdd("Read AC97 reg 0x%x got 0x%x\n", reg, rptr.retwords[1]);
+	return rptr.retwords[1];
+}
+
+static int snd_riptide_initialize(struct snd_riptide *chip)
+{
+	struct cmdif *cif;
+	unsigned int device_id;
+	int err;
+
+	snd_assert(chip, return -EINVAL);
+
+	cif = chip->cif;
+	if (!cif) {
+		if ((cif = kzalloc(sizeof(struct cmdif), GFP_KERNEL)) == NULL)
+			return -ENOMEM;
+		cif->hwport = (struct riptideport *)chip->port;
+		spin_lock_init(&cif->lock);
+		chip->cif = cif;
+	}
+	cif->is_reset = 0;
+	if ((err = riptide_reset(cif, chip)) != 0)
+		return err;
+	device_id = chip->device_id;
+	switch (device_id) {
+	case 0x4310:
+	case 0x4320:
+	case 0x4330:
+		snd_printdd("Modem enable?\n");
+		SEND_SETDPLL(cif);
+		break;
+	}
+	snd_printdd("Enabling MPU IRQs\n");
+	if (chip->rmidi)
+		SET_EMPUIRQ(cif->hwport);
+	return err;
+}
+
+static int snd_riptide_free(struct snd_riptide *chip)
+{
+	struct cmdif *cif;
+
+	snd_assert(chip, return 0);
+
+	if ((cif = chip->cif)) {
+		SET_GRESET(cif->hwport);
+		udelay(100);
+		UNSET_GRESET(cif->hwport);
+		kfree(chip->cif);
+	}
+	if (chip->fw_entry)
+		release_firmware(chip->fw_entry);
+	if (chip->res_port) {
+		release_resource(chip->res_port);
+		kfree_nocheck(chip->res_port);
+	}
+	if (chip->irq >= 0)
+		free_irq(chip->irq, chip);
+	kfree(chip);
+	return 0;
+}
+
+static int snd_riptide_dev_free(struct snd_device *device)
+{
+	struct snd_riptide *chip = device->device_data;
+
+	return snd_riptide_free(chip);
+}
+
+static int __devinit
+snd_riptide_create(struct snd_card *card, struct pci_dev *pci,
+		   struct snd_riptide **rchip)
+{
+	struct snd_riptide *chip;
+	struct riptideport *hwport;
+	int err;
+	static struct snd_device_ops ops = {
+		.dev_free = snd_riptide_dev_free,
+	};
+
+	*rchip = NULL;
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+	if (!(chip = kzalloc(sizeof(struct snd_riptide), GFP_KERNEL)))
+		return -ENOMEM;
+
+	spin_lock_init(&chip->lock);
+	chip->card = card;
+	chip->pci = pci;
+	chip->irq = -1;
+	chip->openstreams = 0;
+	chip->port = pci_resource_start(pci, 0);
+	chip->received_irqs = 0;
+	chip->handled_irqs = 0;
+	chip->cif = NULL;
+	tasklet_init(&chip->riptide_tq, riptide_handleirq, (unsigned long)chip);
+
+	if ((chip->res_port =
+	     request_region(chip->port, 64, "RIPTIDE")) == NULL) {
+		snd_printk(KERN_ERR
+			   "Riptide: unable to grab region 0x%lx-0x%lx\n",
+			   chip->port, chip->port + 64 - 1);
+		snd_riptide_free(chip);
+		return -EBUSY;
+	}
+	hwport = (struct riptideport *)chip->port;
+	UNSET_AIE(hwport);
+
+	if (request_irq
+	    (pci->irq, snd_riptide_interrupt, SA_INTERRUPT | SA_SHIRQ,
+	     "RIPTIDE", chip)) {
+		snd_printk(KERN_ERR "Riptide: unable to grab IRQ %d\n",
+			   pci->irq);
+		snd_riptide_free(chip);
+		return -EBUSY;
+	}
+	chip->irq = pci->irq;
+	chip->device_id = pci->device;
+	pci_set_master(pci);
+	if ((err = snd_riptide_initialize(chip)) < 0) {
+		snd_riptide_free(chip);
+		return err;
+	}
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
+		snd_riptide_free(chip);
+		return err;
+	}
+
+	*rchip = chip;
+	return 0;
+}
+
+static void
+snd_riptide_proc_read(struct snd_info_entry *entry,
+		      struct snd_info_buffer *buffer)
+{
+	struct snd_riptide *chip = entry->private_data;
+	struct pcmhw *data;
+	int i;
+	struct cmdif *cif = NULL;
+	unsigned char p[256];
+	unsigned short rval = 0, lval = 0;
+	unsigned int rate;
+
+	if (!chip)
+		return;
+
+	snd_iprintf(buffer, "%s\n\n", chip->card->longname);
+	snd_iprintf(buffer, "Device ID: 0x%x\nReceived IRQs: (%ld)%ld\nPorts:",
+		    chip->device_id, chip->handled_irqs, chip->received_irqs);
+	for (i = 0; i < 64; i += 4)
+		snd_iprintf(buffer, "%c%02x: %08x",
+			    (i % 16) ? ' ' : '\n', i, inl(chip->port + i));
+	if ((cif = chip->cif)) {
+		snd_iprintf(buffer,
+			    "\nVersion: ASIC: %d CODEC: %d AUXDSP: %d PROG: %d",
+			    chip->firmware.firmware.ASIC,
+			    chip->firmware.firmware.CODEC,
+			    chip->firmware.firmware.AUXDSP,
+			    chip->firmware.firmware.PROG);
+		snd_iprintf(buffer, "\nDigital mixer:");
+		for (i = 0; i < 12; i++) {
+			getmixer(cif, i, &rval, &lval);
+			snd_iprintf(buffer, "\n %d: %d %d", i, rval, lval);
+		}
+		snd_iprintf(buffer,
+			    "\nARM Commands num: %d failed: %d time: %d max: %d min: %d",
+			    cif->cmdcnt, cif->errcnt,
+			    cif->cmdtime, cif->cmdtimemax, cif->cmdtimemin);
+	}
+	snd_iprintf(buffer, "\nOpen streams %d:\n", chip->openstreams);
+	for (i = 0; i < PLAYBACK_SUBSTREAMS; i++) {
+		if (chip->playback_substream[i]
+		    && chip->playback_substream[i]->runtime
+		    && (data =
+			chip->playback_substream[i]->runtime->private_data)) {
+			snd_iprintf(buffer,
+				    "stream: %d mixer: %d source: %d (%d,%d)\n",
+				    data->id, data->mixer, data->source,
+				    data->intdec[0], data->intdec[1]);
+			if (!(getsamplerate(cif, data->intdec, &rate)))
+				snd_iprintf(buffer, "rate: %d\n", rate);
+		}
+	}
+	if (chip->capture_substream
+	    && chip->capture_substream->runtime
+	    && (data = chip->capture_substream->runtime->private_data)) {
+		snd_iprintf(buffer,
+			    "stream: %d mixer: %d source: %d (%d,%d)\n",
+			    data->id, data->mixer,
+			    data->source, data->intdec[0], data->intdec[1]);
+		if (!(getsamplerate(cif, data->intdec, &rate)))
+			snd_iprintf(buffer, "rate: %d\n", rate);
+	}
+	snd_iprintf(buffer, "Paths:\n");
+	i = getpaths(cif, p);
+	while (i--) {
+		snd_iprintf(buffer, "%x->%x ", p[i - 1], p[i]);
+		i--;
+	}
+	snd_iprintf(buffer, "\n");
+}
+
+static void __devinit snd_riptide_proc_init(struct snd_riptide *chip)
+{
+	struct snd_info_entry *entry;
+
+	if (!snd_card_proc_new(chip->card, "riptide", &entry))
+		snd_info_set_text_ops(entry, chip, 4096, snd_riptide_proc_read);
+}
+
+static int __devinit snd_riptide_mixer(struct snd_riptide *chip)
+{
+	struct snd_ac97_bus *pbus;
+	struct snd_ac97_template ac97;
+	int err = 0;
+	static struct snd_ac97_bus_ops ops = {
+		.write = snd_riptide_codec_write,
+		.read = snd_riptide_codec_read,
+	};
+
+	memset(&ac97, 0, sizeof(ac97));
+	ac97.private_data = chip;
+	ac97.scaps = AC97_SCAP_SKIP_MODEM;
+
+	if ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &pbus)) < 0)
+		return err;
+
+	chip->ac97_bus = pbus;
+	ac97.pci = chip->pci;
+	if ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97)) < 0)
+		return err;
+	return err;
+}
+
+#ifdef SUPPORT_JOYSTICK
+static int have_joystick;
+static struct pci_dev *riptide_gameport_pci;
+static struct gameport *riptide_gameport;
+
+static int __devinit
+snd_riptide_joystick_probe(struct pci_dev *pci, const struct pci_device_id *id)
+{
+	static int dev;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	if (joystick_port[dev]) {
+		riptide_gameport = gameport_allocate_port();
+		if (riptide_gameport) {
+			if (!request_region
+			    (joystick_port[dev], 8, "Riptide gameport")) {
+				snd_printk(KERN_WARNING
+					   "Riptide: cannot grab gameport 0x%x\n",
+					   joystick_port[dev]);
+				gameport_free_port(riptide_gameport);
+				riptide_gameport = NULL;
+			} else {
+				riptide_gameport_pci = pci;
+				riptide_gameport->io = joystick_port[dev];
+				gameport_register_port(riptide_gameport);
+			}
+		}
+	}
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_riptide_joystick_remove(struct pci_dev *pci)
+{
+	if (riptide_gameport) {
+		if (riptide_gameport_pci == pci) {
+			release_region(riptide_gameport->io, 8);
+			riptide_gameport_pci = NULL;
+			gameport_unregister_port(riptide_gameport);
+			riptide_gameport = NULL;
+		}
+	}
+}
+#endif
+
+static int __devinit
+snd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
+{
+	static int dev;
+	struct snd_card *card;
+	struct snd_riptide *chip;
+	unsigned short addr;
+	int err = 0;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+	if ((err = snd_riptide_create(card, pci, &chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	card->private_data = chip;
+	if ((err = snd_riptide_pcm(chip, 0, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_riptide_mixer(chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	pci_write_config_word(chip->pci, PCI_EXT_Legacy_Mask, LEGACY_ENABLE_ALL
+			      | (opl3_port[dev] ? LEGACY_ENABLE_FM : 0)
+#ifdef SUPPORT_JOYSTICK
+			      | (joystick_port[dev] ? LEGACY_ENABLE_GAMEPORT :
+				 0)
+#endif
+			      | (mpu_port[dev]
+				 ? (LEGACY_ENABLE_MPU_INT | LEGACY_ENABLE_MPU) :
+				 0)
+			      | ((chip->irq << 4) & 0xF0));
+	if ((addr = mpu_port[dev]) != 0) {
+		pci_write_config_word(chip->pci, PCI_EXT_MPU_Base, addr);
+		if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_RIPTIDE,
+					       addr, 0, chip->irq, 0,
+					       &chip->rmidi)) < 0)
+			snd_printk(KERN_WARNING
+				   "Riptide: Can't Allocate MPU at 0x%x\n",
+				   addr);
+		else
+			chip->mpuaddr = addr;
+	}
+	if ((addr = opl3_port[dev]) != 0) {
+		pci_write_config_word(chip->pci, PCI_EXT_FM_Base, addr);
+		if ((err = snd_opl3_create(card, addr, addr + 2,
+					   OPL3_HW_RIPTIDE, 0,
+					   &chip->opl3)) < 0)
+			snd_printk(KERN_WARNING
+				   "Riptide: Can't Allocate OPL3 at 0x%x\n",
+				   addr);
+		else {
+			chip->opladdr = addr;
+			if ((err =
+			     snd_opl3_hwdep_new(chip->opl3, 0, 1, NULL)) < 0)
+				snd_printk(KERN_WARNING
+					   "Riptide: Can't Allocate OPL3-HWDEP\n");
+		}
+	}
+#ifdef SUPPORT_JOYSTICK
+	if ((addr = joystick_port[dev]) != 0) {
+		pci_write_config_word(chip->pci, PCI_EXT_Game_Base, addr);
+		chip->gameaddr = addr;
+	}
+#endif
+
+	strcpy(card->driver, "RIPTIDE");
+	strcpy(card->shortname, "Riptide");
+#ifdef SUPPORT_JOYSTICK
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s at 0x%lx, irq %i mpu 0x%x opl3 0x%x gameport 0x%x",
+		 card->shortname, chip->port, chip->irq, chip->mpuaddr,
+		 chip->opladdr, chip->gameaddr);
+#else
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s at 0x%lx, irq %i mpu 0x%x opl3 0x%x",
+		 card->shortname, chip->port, chip->irq, chip->mpuaddr,
+		 chip->opladdr);
+#endif
+	snd_riptide_proc_init(chip);
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_card_riptide_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name = "RIPTIDE",
+	.id_table = snd_riptide_ids,
+	.probe = snd_card_riptide_probe,
+	.remove = __devexit_p(snd_card_riptide_remove),
+#ifdef CONFIG_PM
+	.suspend = riptide_suspend,
+	.resume = riptide_resume,
+#endif
+};
+
+#ifdef SUPPORT_JOYSTICK
+static struct pci_driver joystick_driver = {
+	.name = "Riptide Joystick",
+	.id_table = snd_riptide_joystick_ids,
+	.probe = snd_riptide_joystick_probe,
+	.remove = __devexit_p(snd_riptide_joystick_remove),
+};
+#endif
+
+static int __init alsa_card_riptide_init(void)
+{
+	int err;
+	if ((err = pci_register_driver(&driver)) < 0)
+		return err;
+#if defined(SUPPORT_JOYSTICK)
+	if (pci_register_driver(&joystick_driver) < 0) {
+		have_joystick = 0;
+		snd_printk(KERN_INFO "no joystick found\n");
+	} else
+		have_joystick = 1;
+#endif
+	return 0;
+}
+
+static void __exit alsa_card_riptide_exit(void)
+{
+	pci_unregister_driver(&driver);
+#if defined(SUPPORT_JOYSTICK)
+	if (have_joystick)
+		pci_unregister_driver(&joystick_driver);
+#endif
+}
+
+module_init(alsa_card_riptide_init);
+module_exit(alsa_card_riptide_exit);
