commit 7103e4a70cb9413b3b6a485c03d463bb0232c15a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:48:18 2020 +0100

    ALSA: ens137x: More constification
    
    Apply const prefix to the quirk entry, forgotten in the previous fix.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-64-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 7ef9b7a1b2e6..d9acef0826a9 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1574,7 +1574,7 @@ static int es1371_quirk_lookup(struct ensoniq *ensoniq,
 	return 0;
 }
 
-static struct es1371_quirk es1371_spdif_present[] = {
+static const struct es1371_quirk es1371_spdif_present[] = {
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_C },
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_D },
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_E },

commit 88e540a8764ec0f5fb4a1185fbeb7827fefd3601
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:17:14 2020 +0100

    ALSA: pci: Constify snd_pci_quirk tables
    
    The snd_pci_quirk tables are referred as read-only, hence they can be
    declared as const gracefully.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-59-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 4f8202980b61..7ef9b7a1b2e6 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1562,7 +1562,7 @@ struct es1371_quirk {
 };
 
 static int es1371_quirk_lookup(struct ensoniq *ensoniq,
-				struct es1371_quirk *list)
+			       const struct es1371_quirk *list)
 {
 	while (list->vid != (unsigned short)PCI_ANY_ID) {
 		if (ensoniq->pci->vendor == list->vid &&
@@ -1583,7 +1583,7 @@ static struct es1371_quirk es1371_spdif_present[] = {
 	{ .vid = PCI_ANY_ID, .did = PCI_ANY_ID }
 };
 
-static struct snd_pci_quirk ens1373_line_quirk[] = {
+static const struct snd_pci_quirk ens1373_line_quirk[] = {
 	SND_PCI_QUIRK_ID(0x1274, 0x2000), /* GA-7DXR */
 	SND_PCI_QUIRK_ID(0x1458, 0xa000), /* GA-8IEXP */
 	{ } /* end */
@@ -1909,7 +1909,7 @@ static int snd_ensoniq_dev_free(struct snd_device *device)
 }
 
 #ifdef CHIP1371
-static struct snd_pci_quirk es1371_amplifier_hack[] = {
+static const struct snd_pci_quirk es1371_amplifier_hack[] = {
 	SND_PCI_QUIRK_ID(0x107b, 0x2150),	/* Gateway Solo 2150 */
 	SND_PCI_QUIRK_ID(0x13bd, 0x100c),	/* EV1938 on Mebius PC-MJ100V */
 	SND_PCI_QUIRK_ID(0x1102, 0x5938),	/* Targa Xtender300 */
@@ -1917,7 +1917,7 @@ static struct snd_pci_quirk es1371_amplifier_hack[] = {
 	{ } /* end */
 };
 
-static struct es1371_quirk es1371_ac97_reset_hack[] = {
+static const struct es1371_quirk es1371_ac97_reset_hack[] = {
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_C },
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_D },
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_E },

commit b4e5e70775546480035e156b40040e5d0d4264d1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:53 2020 +0100

    ALSA: pci: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-38-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 15e6d2377ecf..4f8202980b61 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1433,7 +1433,7 @@ static int snd_es1371_spdif_put(struct snd_kcontrol *kcontrol,
 
 
 /* spdif controls */
-static struct snd_kcontrol_new snd_es1371_mixer_spdif[] = {
+static const struct snd_kcontrol_new snd_es1371_mixer_spdif[] = {
 	ES1371_SPDIF(SNDRV_CTL_NAME_IEC958("",PLAYBACK,SWITCH)),
 	{
 		.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -1698,7 +1698,7 @@ static int snd_ensoniq_control_put(struct snd_kcontrol *kcontrol,
  * ENS1370 mixer
  */
 
-static struct snd_kcontrol_new snd_es1370_controls[2] = {
+static const struct snd_kcontrol_new snd_es1370_controls[2] = {
 ENSONIQ_CONTROL("PCM 0 Output also on Line-In Jack", ES_1370_XCTL0),
 ENSONIQ_CONTROL("Mic +5V bias", ES_1370_XCTL1)
 };

commit 51055da51d1e92bb089c9b9e0ecb1be69396f808
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:43 2020 +0100

    ALSA: pci: Constify snd_ac97_bus_ops definitions
    
    Now snd_ac97_bus() takes the const ops pointer, so we can define the
    snd_ac97_bus_ops locally as const as well for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-28-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 7611e44e2af5..15e6d2377ecf 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1596,7 +1596,7 @@ static int snd_ensoniq_1371_mixer(struct ensoniq *ensoniq,
 	struct snd_ac97_bus *pbus;
 	struct snd_ac97_template ac97;
 	int err;
-	static struct snd_ac97_bus_ops ops = {
+	static const struct snd_ac97_bus_ops ops = {
 		.write = snd_es1371_codec_write,
 		.read = snd_es1371_codec_read,
 		.wait = snd_es1371_codec_wait,

commit efb0ad25d370344e61bb4fca8c3b9c3c6047922e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:25 2020 +0100

    ALSA: pci: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 378141aa7c7d..7611e44e2af5 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2041,7 +2041,7 @@ static int snd_ensoniq_create(struct snd_card *card,
 {
 	struct ensoniq *ensoniq;
 	int err;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free =	snd_ensoniq_dev_free,
 	};
 

commit 83720eef264bbfb6fa94b3eeb2671ffd0bd2dde7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:16 2019 +0100

    ALSA: ens137x: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation, as well as removing the superfluous synchronize_irq()
    call.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-18-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index f69555c95263..378141aa7c7d 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1888,8 +1888,6 @@ static int snd_ensoniq_free(struct ensoniq *ensoniq)
 	outl(0, ES_REG(ensoniq, CONTROL));	/* switch everything off */
 	outl(0, ES_REG(ensoniq, SERIAL));	/* clear serial interface */
 #endif
-	if (ensoniq->irq >= 0)
-		synchronize_irq(ensoniq->irq);
 	pci_set_power_state(ensoniq->pci, PCI_D3hot);
       __hw_end:
 #ifdef CHIP1370
@@ -1990,7 +1988,6 @@ static void snd_ensoniq_chip_init(struct ensoniq *ensoniq)
 	outb(ensoniq->uartc = 0x00, ES_REG(ensoniq, UART_CONTROL));
 	outb(0x00, ES_REG(ensoniq, UART_RES));
 	outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
-	synchronize_irq(ensoniq->irq);
 }
 
 #ifdef CONFIG_PM_SLEEP
@@ -2074,6 +2071,7 @@ static int snd_ensoniq_create(struct snd_card *card,
 		return -EBUSY;
 	}
 	ensoniq->irq = pci->irq;
+	card->sync_irq = ensoniq->irq;
 #ifdef CHIP1370
 	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &pci->dev,
 				16, &ensoniq->dma_bug) < 0) {

commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 19d8238e130c..f69555c95263 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1204,7 +1204,6 @@ static int snd_ensoniq_capture_close(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_ensoniq_playback1_ops = {
 	.open =		snd_ensoniq_playback1_open,
 	.close =	snd_ensoniq_playback1_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_ensoniq_playback1_prepare,
 	.trigger =	snd_ensoniq_trigger,
 	.pointer =	snd_ensoniq_playback1_pointer,
@@ -1213,7 +1212,6 @@ static const struct snd_pcm_ops snd_ensoniq_playback1_ops = {
 static const struct snd_pcm_ops snd_ensoniq_playback2_ops = {
 	.open =		snd_ensoniq_playback2_open,
 	.close =	snd_ensoniq_playback2_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_ensoniq_playback2_prepare,
 	.trigger =	snd_ensoniq_trigger,
 	.pointer =	snd_ensoniq_playback2_pointer,
@@ -1222,7 +1220,6 @@ static const struct snd_pcm_ops snd_ensoniq_playback2_ops = {
 static const struct snd_pcm_ops snd_ensoniq_capture_ops = {
 	.open =		snd_ensoniq_capture_open,
 	.close =	snd_ensoniq_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_ensoniq_capture_prepare,
 	.trigger =	snd_ensoniq_trigger,
 	.pointer =	snd_ensoniq_capture_pointer,

commit b22b2478125120e0110049ac53fdcef38ea0a167
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:09 2019 +0100

    ALSA: ens137x: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The hw_params and hw_free callbacks became superfluous and got
    dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-38-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 0499dc863202..19d8238e130c 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -856,17 +856,6 @@ static int snd_ensoniq_trigger(struct snd_pcm_substream *substream, int cmd)
  *  PCM part
  */
 
-static int snd_ensoniq_hw_params(struct snd_pcm_substream *substream,
-				 struct snd_pcm_hw_params *hw_params)
-{
-	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
-}
-
-static int snd_ensoniq_hw_free(struct snd_pcm_substream *substream)
-{
-	return snd_pcm_lib_free_pages(substream);
-}
-
 static int snd_ensoniq_playback1_prepare(struct snd_pcm_substream *substream)
 {
 	struct ensoniq *ensoniq = snd_pcm_substream_chip(substream);
@@ -1216,8 +1205,6 @@ static const struct snd_pcm_ops snd_ensoniq_playback1_ops = {
 	.open =		snd_ensoniq_playback1_open,
 	.close =	snd_ensoniq_playback1_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_ensoniq_hw_params,
-	.hw_free =	snd_ensoniq_hw_free,
 	.prepare =	snd_ensoniq_playback1_prepare,
 	.trigger =	snd_ensoniq_trigger,
 	.pointer =	snd_ensoniq_playback1_pointer,
@@ -1227,8 +1214,6 @@ static const struct snd_pcm_ops snd_ensoniq_playback2_ops = {
 	.open =		snd_ensoniq_playback2_open,
 	.close =	snd_ensoniq_playback2_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_ensoniq_hw_params,
-	.hw_free =	snd_ensoniq_hw_free,
 	.prepare =	snd_ensoniq_playback2_prepare,
 	.trigger =	snd_ensoniq_trigger,
 	.pointer =	snd_ensoniq_playback2_pointer,
@@ -1238,8 +1223,6 @@ static const struct snd_pcm_ops snd_ensoniq_capture_ops = {
 	.open =		snd_ensoniq_capture_open,
 	.close =	snd_ensoniq_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_ensoniq_hw_params,
-	.hw_free =	snd_ensoniq_hw_free,
 	.prepare =	snd_ensoniq_capture_prepare,
 	.trigger =	snd_ensoniq_trigger,
 	.pointer =	snd_ensoniq_capture_pointer,
@@ -1274,9 +1257,8 @@ static int snd_ensoniq_pcm(struct ensoniq *ensoniq, int device)
 	strcpy(pcm->name, CHIP_NAME " DAC2/ADC");
 	ensoniq->pcm1 = pcm;
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &ensoniq->pci->dev,
-					      64*1024, 128*1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
+				       &ensoniq->pci->dev, 64*1024, 128*1024);
 
 #ifdef CHIP1370
 	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
@@ -1307,9 +1289,8 @@ static int snd_ensoniq_pcm2(struct ensoniq *ensoniq, int device)
 	strcpy(pcm->name, CHIP_NAME " DAC1");
 	ensoniq->pcm2 = pcm;
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &ensoniq->pci->dev,
-					      64*1024, 128*1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
+				       &ensoniq->pci->dev, 64*1024, 128*1024);
 
 #ifdef CHIP1370
 	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index b767df8181b5..0499dc863202 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1275,7 +1275,8 @@ static int snd_ensoniq_pcm(struct ensoniq *ensoniq, int device)
 	ensoniq->pcm1 = pcm;
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      snd_dma_pci_data(ensoniq->pci), 64*1024, 128*1024);
+					      &ensoniq->pci->dev,
+					      64*1024, 128*1024);
 
 #ifdef CHIP1370
 	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
@@ -1307,7 +1308,8 @@ static int snd_ensoniq_pcm2(struct ensoniq *ensoniq, int device)
 	ensoniq->pcm2 = pcm;
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      snd_dma_pci_data(ensoniq->pci), 64*1024, 128*1024);
+					      &ensoniq->pci->dev,
+					      64*1024, 128*1024);
 
 #ifdef CHIP1370
 	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
@@ -2095,7 +2097,7 @@ static int snd_ensoniq_create(struct snd_card *card,
 	}
 	ensoniq->irq = pci->irq;
 #ifdef CHIP1370
-	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
+	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &pci->dev,
 				16, &ensoniq->dma_bug) < 0) {
 		dev_err(card->dev, "unable to allocate space for phantom area - dma_bug\n");
 		snd_ensoniq_free(ensoniq);

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 1cfff35e370e..b767df8181b5 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1,22 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Driver for Ensoniq ES1370/ES1371 AudioPCI soundcard
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>,
  *		     Thomas Sailer <sailer@ife.ee.ethz.ch>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 /* Power-Management-Code ( CONFIG_PM )

commit 47f2769b4b2e267cba135fc19c89c32d202b1415
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:01:39 2019 +0100

    ALSA: pci: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 1f2960ecc57e..1cfff35e370e 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1902,10 +1902,8 @@ static void snd_ensoniq_proc_read(struct snd_info_entry *entry,
 
 static void snd_ensoniq_proc_init(struct ensoniq *ensoniq)
 {
-	struct snd_info_entry *entry;
-
-	if (! snd_card_proc_new(ensoniq->card, "audiopci", &entry))
-		snd_info_set_text_ops(entry, ensoniq, snd_ensoniq_proc_read);
+	snd_card_ro_proc_new(ensoniq->card, "audiopci", ensoniq,
+			     snd_ensoniq_proc_read);
 }
 
 /*

commit 17bc4815de586d001c82d0ddf75247283c3f002a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:02:51 2019 +0100

    ALSA: pci: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 727eb3da1fda..1f2960ecc57e 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2037,9 +2037,6 @@ static int snd_ensoniq_suspend(struct device *dev)
 	
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 
-	snd_pcm_suspend_all(ensoniq->pcm1);
-	snd_pcm_suspend_all(ensoniq->pcm2);
-	
 #ifdef CHIP1371	
 	snd_ac97_suspend(ensoniq->u.es1371.ac97);
 #else

commit 3b0cbc7812d759ffb38d881e75c0318512283d00
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Aug 1 11:47:37 2018 +0100

    ALSA: ens137x: remove redundant array pcm_devs
    
    The array pcm_devs is being assigned but is never used hence it is
    redundant and can be removed.
    
    Cleans up clang warning:
    warning: variable 'pcm_devs' set but not used [-Wunused-but-set-variable]
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 39f79a6b5283..727eb3da1fda 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2392,7 +2392,7 @@ static int snd_audiopci_probe(struct pci_dev *pci,
 	static int dev;
 	struct snd_card *card;
 	struct ensoniq *ensoniq;
-	int err, pcm_devs[2];
+	int err;
 
 	if (dev >= SNDRV_CARDS)
 		return -ENODEV;
@@ -2412,7 +2412,6 @@ static int snd_audiopci_probe(struct pci_dev *pci,
 	}
 	card->private_data = ensoniq;
 
-	pcm_devs[0] = 0; pcm_devs[1] = 1;
 #ifdef CHIP1370
 	if ((err = snd_ensoniq_1370_mixer(ensoniq)) < 0) {
 		snd_card_free(card);

commit 40ddfe659a19baa2ccc73899a150ca03373c44aa
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sun Oct 15 22:16:45 2017 +0100

    ALSA: ens137x: remove redundant variable result
    
    Variable result is being assigned a value from a calculation
    however the variable is never read, so this redundant variable
    can be removed.
    
    Cleans up clang warning: Value stored to 'result' is never read
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index d4cd6451fdca..39f79a6b5283 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -732,7 +732,7 @@ static void snd_es1371_codec_wait(struct snd_ac97 *ac97)
 
 static void snd_es1371_adc_rate(struct ensoniq * ensoniq, unsigned int rate)
 {
-	unsigned int n, truncm, freq, result;
+	unsigned int n, truncm, freq;
 
 	mutex_lock(&ensoniq->src_mutex);
 	n = rate / 3000;
@@ -740,7 +740,6 @@ static void snd_es1371_adc_rate(struct ensoniq * ensoniq, unsigned int rate)
 		n--;
 	truncm = (21 * n - 1) | 1;
 	freq = ((48000UL << 15) / rate) * n;
-	result = (48000UL << 15) / (freq / n);
 	if (rate >= 24000) {
 		if (truncm > 239)
 			truncm = 239;

commit dee49895b197936c02d27d651e58c90bac18f452
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:28 2017 +0530

    ALSA: pci: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index f0d978e3b274..d4cd6451fdca 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1059,7 +1059,7 @@ static snd_pcm_uframes_t snd_ensoniq_capture_pointer(struct snd_pcm_substream *s
 	return ptr;
 }
 
-static struct snd_pcm_hardware snd_ensoniq_playback1 =
+static const struct snd_pcm_hardware snd_ensoniq_playback1 =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1086,7 +1086,7 @@ static struct snd_pcm_hardware snd_ensoniq_playback1 =
 	.fifo_size =		0,
 };
 
-static struct snd_pcm_hardware snd_ensoniq_playback2 =
+static const struct snd_pcm_hardware snd_ensoniq_playback2 =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1106,7 +1106,7 @@ static struct snd_pcm_hardware snd_ensoniq_playback2 =
 	.fifo_size =		0,
 };
 
-static struct snd_pcm_hardware snd_ensoniq_capture =
+static const struct snd_pcm_hardware snd_ensoniq_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |

commit 8130829a9b73dca2bd9cc7ce8ea031405cb1757f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 7 14:19:39 2017 +0200

    ALSA: ens137x: Constify hw_constraints
    
    snd_pcm_hw_constraint_list(), *_ratnums() and *_ratdens() receive the
    const pointers.  Constify the corresponding static objects for better
    hardening.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 09a63ef41ef2..f0d978e3b274 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -467,41 +467,41 @@ MODULE_DEVICE_TABLE(pci, snd_audiopci_ids);
 #define POLL_COUNT	0xa000
 
 #ifdef CHIP1370
-static unsigned int snd_es1370_fixed_rates[] =
+static const unsigned int snd_es1370_fixed_rates[] =
 	{5512, 11025, 22050, 44100};
-static struct snd_pcm_hw_constraint_list snd_es1370_hw_constraints_rates = {
+static const struct snd_pcm_hw_constraint_list snd_es1370_hw_constraints_rates = {
 	.count = 4, 
 	.list = snd_es1370_fixed_rates,
 	.mask = 0,
 };
-static struct snd_ratnum es1370_clock = {
+static const struct snd_ratnum es1370_clock = {
 	.num = ES_1370_SRCLOCK,
 	.den_min = 29, 
 	.den_max = 353,
 	.den_step = 1,
 };
-static struct snd_pcm_hw_constraint_ratnums snd_es1370_hw_constraints_clock = {
+static const struct snd_pcm_hw_constraint_ratnums snd_es1370_hw_constraints_clock = {
 	.nrats = 1,
 	.rats = &es1370_clock,
 };
 #else
-static struct snd_ratden es1371_dac_clock = {
+static const struct snd_ratden es1371_dac_clock = {
 	.num_min = 3000 * (1 << 15),
 	.num_max = 48000 * (1 << 15),
 	.num_step = 3000,
 	.den = 1 << 15,
 };
-static struct snd_pcm_hw_constraint_ratdens snd_es1371_hw_constraints_dac_clock = {
+static const struct snd_pcm_hw_constraint_ratdens snd_es1371_hw_constraints_dac_clock = {
 	.nrats = 1,
 	.rats = &es1371_dac_clock,
 };
-static struct snd_ratnum es1371_adc_clock = {
+static const struct snd_ratnum es1371_adc_clock = {
 	.num = 48000 << 15,
 	.den_min = 32768, 
 	.den_max = 393216,
 	.den_step = 1,
 };
-static struct snd_pcm_hw_constraint_ratnums snd_es1371_hw_constraints_adc_clock = {
+static const struct snd_pcm_hw_constraint_ratnums snd_es1371_hw_constraints_adc_clock = {
 	.nrats = 1,
 	.rats = &es1371_adc_clock,
 };

commit 291b38a7565b41676cafd1b4052315a94d9c8977
Merge: b5a53b61a289 6192c41fc608
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 10 19:13:03 2017 -0700

    Merge tag 'hwparam-20170420' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull hw lockdown support from David Howells:
     "Annotation of module parameters that configure hardware resources
      including ioports, iomem addresses, irq lines and dma channels.
    
      This allows a future patch to prohibit the use of such module
      parameters to prevent that hardware from being abused to gain access
      to the running kernel image as part of locking the kernel down under
      UEFI secure boot conditions.
    
      Annotations are made by changing:
    
            module_param(n, t, p)
            module_param_named(n, v, t, p)
            module_param_array(n, t, m, p)
    
      to:
    
            module_param_hw(n, t, hwtype, p)
            module_param_hw_named(n, v, t, hwtype, p)
            module_param_hw_array(n, t, hwtype, m, p)
    
      where the module parameter refers to a hardware setting
    
      hwtype specifies the type of the resource being configured. This can
      be one of:
    
            ioport          Module parameter configures an I/O port
            iomem           Module parameter configures an I/O mem address
            ioport_or_iomem Module parameter could be either (runtime set)
            irq             Module parameter configures an I/O port
            dma             Module parameter configures a DMA channel
            dma_addr        Module parameter configures a DMA buffer address
            other           Module parameter configures some other value
    
      Note that the hwtype is compile checked, but not currently stored (the
      lockdown code probably won't require it). It is, however, there for
      future use.
    
      A bonus is that the hwtype can also be used for grepping.
    
      The intention is for the kernel to ignore or reject attempts to set
      annotated module parameters if lockdown is enabled. This applies to
      options passed on the boot command line, passed to insmod/modprobe or
      direct twiddling in /sys/module/ parameter files.
    
      The module initialisation then needs to handle the parameter not being
      set, by (1) giving an error, (2) probing for a value or (3) using a
      reasonable default.
    
      What I can't do is just reject a module out of hand because it may
      take a hardware setting in the module parameters. Some important
      modules, some ipmi stuff for instance, both probe for hardware and
      allow hardware to be manually specified; if the driver is aborts with
      any error, you don't get any ipmi hardware.
    
      Further, trying to do this entirely in the module initialisation code
      doesn't protect against sysfs twiddling.
    
      [!] Note that in and of itself, this series of patches should have no
          effect on the the size of the kernel or code execution - that is
          left to a patch in the next series to effect. It does mark
          annotated kernel parameters with a KERNEL_PARAM_FL_HWPARAM flag in
          an already existing field"
    
    * tag 'hwparam-20170420' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs: (38 commits)
      Annotate hardware config module parameters in sound/pci/
      Annotate hardware config module parameters in sound/oss/
      Annotate hardware config module parameters in sound/isa/
      Annotate hardware config module parameters in sound/drivers/
      Annotate hardware config module parameters in fs/pstore/
      Annotate hardware config module parameters in drivers/watchdog/
      Annotate hardware config module parameters in drivers/video/
      Annotate hardware config module parameters in drivers/tty/
      Annotate hardware config module parameters in drivers/staging/vme/
      Annotate hardware config module parameters in drivers/staging/speakup/
      Annotate hardware config module parameters in drivers/staging/media/
      Annotate hardware config module parameters in drivers/scsi/
      Annotate hardware config module parameters in drivers/pcmcia/
      Annotate hardware config module parameters in drivers/pci/hotplug/
      Annotate hardware config module parameters in drivers/parport/
      Annotate hardware config module parameters in drivers/net/wireless/
      Annotate hardware config module parameters in drivers/net/wan/
      Annotate hardware config module parameters in drivers/net/irda/
      Annotate hardware config module parameters in drivers/net/hamradio/
      Annotate hardware config module parameters in drivers/net/ethernet/
      ...

commit 6192c41fc608b0a58d5540b015aa1672c266f3c5
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:30 2017 +0100

    Annotate hardware config module parameters in sound/pci/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in sound/pci/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jaroslav Kysela <perex@perex.cz>
    cc: Takashi Iwai <tiwai@suse.com>
    cc: alsa-devel@alsa-project.org

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 164adad91650..90376739c5e1 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -106,7 +106,7 @@ module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable Ensoniq AudioPCI soundcard.");
 #ifdef SUPPORT_JOYSTICK
 #ifdef CHIP1371
-module_param_array(joystick_port, int, NULL, 0444);
+module_param_hw_array(joystick_port, int, ioport, NULL, 0444);
 MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #else
 module_param_array(joystick, bool, NULL, 0444);

commit f3b827e0b1841f4cfc18436e09f4f269f3be908e
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Mon Feb 20 00:18:09 2017 +0530

    ALSA: pci: constify snd_kcontrol_new structures
    
    Declare snd_kcontrol_new structures as const as they are only passed as
    an argument to the function snd_ctl_new1. This argument is of type
    const, so snd_kcontrol_new structures having the same property can be
    made const too.
    Done using Coccinelle:
    
    @r1 disable optional_qualifier @
    identifier i;
    position p;
    @@
    static struct snd_kcontrol_new i@p = {...};
    
    @ok1@
    identifier r1.i;
    position p;
    expression e1;
    @@
    snd_ctl_new1(&i@p,e1)
    
    @bad@
    position p!={r1.p,ok1.p};
    identifier r1.i;
    @@
    i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r1.i;
    @@
    +const
    struct snd_kcontrol_new i;
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 164adad91650..5d10349d11ce 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1530,7 +1530,7 @@ static int snd_es1373_rear_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_ens1373_rear =
+static const struct snd_kcontrol_new snd_ens1373_rear =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"AC97 2ch->4ch Copy Switch",
@@ -1575,7 +1575,7 @@ static int snd_es1373_line_put(struct snd_kcontrol *kcontrol,
 	return changed;
 }
 
-static struct snd_kcontrol_new snd_ens1373_line =
+static const struct snd_kcontrol_new snd_ens1373_line =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"Line In->Rear Out Switch",

commit 485885b9d0474ac374297e637f479c22930bb593
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 5 17:29:31 2017 +0100

    ALSA: pci: Constify snd_rawmidi_ops
    
    Now snd_rawmidi_ops is maintained as a const pointer in snd_rawmidi,
    we can constify the definitions.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 51736c2b5a00..164adad91650 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2317,14 +2317,14 @@ static void snd_ensoniq_midi_output_trigger(struct snd_rawmidi_substream *substr
 	spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
 }
 
-static struct snd_rawmidi_ops snd_ensoniq_midi_output =
+static const struct snd_rawmidi_ops snd_ensoniq_midi_output =
 {
 	.open =		snd_ensoniq_midi_output_open,
 	.close =	snd_ensoniq_midi_output_close,
 	.trigger =	snd_ensoniq_midi_output_trigger,
 };
 
-static struct snd_rawmidi_ops snd_ensoniq_midi_input =
+static const struct snd_rawmidi_ops snd_ensoniq_midi_input =
 {
 	.open =		snd_ensoniq_midi_input_open,
 	.close =	snd_ensoniq_midi_input_close,

commit b2fac0730347d591b528d8f0e4a9438c1bb6f558
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sat Nov 12 23:26:41 2016 +0100

    ALSA: pci: don't opencode IS_REACHABLE()
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 7e760fed0728..51736c2b5a00 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -79,7 +79,7 @@ MODULE_SUPPORTED_DEVICE("{{Ensoniq,AudioPCI ES1371/73},"
 		"{Ectiva,EV1938}}");
 #endif
 
-#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+#if IS_REACHABLE(CONFIG_GAMEPORT)
 #define SUPPORT_JOYSTICK
 #endif
 

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 626cd2167d29..7e760fed0728 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1227,7 +1227,7 @@ static int snd_ensoniq_capture_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static struct snd_pcm_ops snd_ensoniq_playback1_ops = {
+static const struct snd_pcm_ops snd_ensoniq_playback1_ops = {
 	.open =		snd_ensoniq_playback1_open,
 	.close =	snd_ensoniq_playback1_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1238,7 +1238,7 @@ static struct snd_pcm_ops snd_ensoniq_playback1_ops = {
 	.pointer =	snd_ensoniq_playback1_pointer,
 };
 
-static struct snd_pcm_ops snd_ensoniq_playback2_ops = {
+static const struct snd_pcm_ops snd_ensoniq_playback2_ops = {
 	.open =		snd_ensoniq_playback2_open,
 	.close =	snd_ensoniq_playback2_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1249,7 +1249,7 @@ static struct snd_pcm_ops snd_ensoniq_playback2_ops = {
 	.pointer =	snd_ensoniq_playback2_pointer,
 };
 
-static struct snd_pcm_ops snd_ensoniq_capture_ops = {
+static const struct snd_pcm_ops snd_ensoniq_capture_ops = {
 	.open =		snd_ensoniq_capture_open,
 	.close =	snd_ensoniq_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,

commit d23f0517357ef48d2845846e899d125b3c1a492e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 19 15:28:39 2016 +0200

    ALSA: ens1371: Fix "Line In->Rear Out Switch" control
    
    The "Line In->Rear Out Switch" control on ens1371 driver returns a
    bogus value, always true, as its check is totally broken.  Fix it to
    check the proper GPIO bit mask.
    
    Reported-by: David Binderman <dcb314@hotmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 0dc44ebb0032..626cd2167d29 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1548,7 +1548,7 @@ static int snd_es1373_line_get(struct snd_kcontrol *kcontrol,
 	int val = 0;
 	
 	spin_lock_irq(&ensoniq->reg_lock);
-	if ((ensoniq->ctrl & ES_1371_GPIO_OUTM) >= 4)
+	if (ensoniq->ctrl & ES_1371_GPIO_OUT(4))
 	    	val = 1;
 	ucontrol->value.integer.value[0] = val;
 	spin_unlock_irq(&ensoniq->reg_lock);

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 219b8af29a49..0dc44ebb0032 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -26,7 +26,7 @@
  * by Kurt J. Bosch
  */
 
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>

commit 9e5947465d72ef1b3a88104474ab2adf78837220
Merge: 624afe4dc9a0 3e41c9b5a1ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 11 11:26:48 2015 +0100

    Merge branch 'topic/pci-cleanup' into for-next

commit 943cf2839637231bdb2710753b457651ea1b7204
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 8 12:47:10 2015 +0100

    ALSA: ens137x: Simplify PM callbacks
    
    This is a similar cleanup like the commit [3db084fd0af5: ALSA: fm801:
    PCI core handles power state for us].
    
    Since pci_set_power_state(), pci_save_state() and pci_restore_state()
    are already done in the PCI core side, so we don't need to it doubly.
    
    Also, pci_enable_device(), pci_disable_device() and pci_set_master()
    calls in PM callbacks are superfluous nowadays, too, so get rid of
    them as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index d94cb3ca7a64..1badd91f6283 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2049,7 +2049,6 @@ static void snd_ensoniq_chip_init(struct ensoniq *ensoniq)
 #ifdef CONFIG_PM_SLEEP
 static int snd_ensoniq_suspend(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct ensoniq *ensoniq = card->private_data;
 	
@@ -2070,28 +2069,14 @@ static int snd_ensoniq_suspend(struct device *dev)
 	udelay(100);
 	snd_ak4531_suspend(ensoniq->u.es1370.ak4531);
 #endif	
-
-	pci_disable_device(pci);
-	pci_save_state(pci);
-	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
 static int snd_ensoniq_resume(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct ensoniq *ensoniq = card->private_data;
 
-	pci_set_power_state(pci, PCI_D0);
-	pci_restore_state(pci);
-	if (pci_enable_device(pci) < 0) {
-		dev_err(dev, "pci_enable_device failed, disabling device\n");
-		snd_card_disconnect(card);
-		return -EIO;
-	}
-	pci_set_master(pci);
-
 	snd_ensoniq_chip_init(ensoniq);
 
 #ifdef CHIP1371	

commit 50b8d94e1819768e8eccae4d24698a17b8940776
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Jan 2 12:24:48 2015 +0100

    ALSA: ens1370: Remove always NULL parameters
    
    The various PCM and MIDI allocation functions in this driver take a pointer
    to a pointer of a PCM/MIDI object where if this parameter is provided the
    newly allocated object is stored. All callers pass NULL though, so remove
    the parameter. This makes the code a bit shorter and cleaner.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index d94cb3ca7a64..bb1f4d22df5f 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1268,14 +1268,11 @@ static const struct snd_pcm_chmap_elem surround_map[] = {
 	{ }
 };
 
-static int snd_ensoniq_pcm(struct ensoniq *ensoniq, int device,
-			   struct snd_pcm **rpcm)
+static int snd_ensoniq_pcm(struct ensoniq *ensoniq, int device)
 {
 	struct snd_pcm *pcm;
 	int err;
 
-	if (rpcm)
-		*rpcm = NULL;
 	err = snd_pcm_new(ensoniq->card, CHIP_NAME "/1", device, 1, 1, &pcm);
 	if (err < 0)
 		return err;
@@ -1302,22 +1299,14 @@ static int snd_ensoniq_pcm(struct ensoniq *ensoniq, int device,
 	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
 				     snd_pcm_std_chmaps, 2, 0, NULL);
 #endif
-	if (err < 0)
-		return err;
-
-	if (rpcm)
-		*rpcm = pcm;
-	return 0;
+	return err;
 }
 
-static int snd_ensoniq_pcm2(struct ensoniq *ensoniq, int device,
-			    struct snd_pcm **rpcm)
+static int snd_ensoniq_pcm2(struct ensoniq *ensoniq, int device)
 {
 	struct snd_pcm *pcm;
 	int err;
 
-	if (rpcm)
-		*rpcm = NULL;
 	err = snd_pcm_new(ensoniq->card, CHIP_NAME "/2", device, 1, 0, &pcm);
 	if (err < 0)
 		return err;
@@ -1342,12 +1331,7 @@ static int snd_ensoniq_pcm2(struct ensoniq *ensoniq, int device,
 	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
 				     surround_map, 2, 0, NULL);
 #endif
-	if (err < 0)
-		return err;
-
-	if (rpcm)
-		*rpcm = pcm;
-	return 0;
+	return err;
 }
 
 /*
@@ -2362,14 +2346,11 @@ static struct snd_rawmidi_ops snd_ensoniq_midi_input =
 	.trigger =	snd_ensoniq_midi_input_trigger,
 };
 
-static int snd_ensoniq_midi(struct ensoniq *ensoniq, int device,
-			    struct snd_rawmidi **rrawmidi)
+static int snd_ensoniq_midi(struct ensoniq *ensoniq, int device)
 {
 	struct snd_rawmidi *rmidi;
 	int err;
 
-	if (rrawmidi)
-		*rrawmidi = NULL;
 	if ((err = snd_rawmidi_new(ensoniq->card, "ES1370/1", device, 1, 1, &rmidi)) < 0)
 		return err;
 	strcpy(rmidi->name, CHIP_NAME);
@@ -2379,8 +2360,6 @@ static int snd_ensoniq_midi(struct ensoniq *ensoniq, int device,
 		SNDRV_RAWMIDI_INFO_DUPLEX;
 	rmidi->private_data = ensoniq;
 	ensoniq->rmidi = rmidi;
-	if (rrawmidi)
-		*rrawmidi = rmidi;
 	return 0;
 }
 
@@ -2462,15 +2441,15 @@ static int snd_audiopci_probe(struct pci_dev *pci,
 		return err;
 	}
 #endif
-	if ((err = snd_ensoniq_pcm(ensoniq, 0, NULL)) < 0) {
+	if ((err = snd_ensoniq_pcm(ensoniq, 0)) < 0) {
 		snd_card_free(card);
 		return err;
 	}
-	if ((err = snd_ensoniq_pcm2(ensoniq, 1, NULL)) < 0) {
+	if ((err = snd_ensoniq_pcm2(ensoniq, 1)) < 0) {
 		snd_card_free(card);
 		return err;
 	}
-	if ((err = snd_ensoniq_midi(ensoniq, 0, NULL)) < 0) {
+	if ((err = snd_ensoniq_midi(ensoniq, 0)) < 0) {
 		snd_card_free(card);
 		return err;
 	}

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 29cd339ffc37..d94cb3ca7a64 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -446,7 +446,7 @@ struct ensoniq {
 
 static irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id);
 
-static DEFINE_PCI_DEVICE_TABLE(snd_audiopci_ids) = {
+static const struct pci_device_id snd_audiopci_ids[] = {
 #ifdef CHIP1370
 	{ PCI_VDEVICE(ENSONIQ, 0x5000), 0, },	/* ES1370 */
 #endif

commit 7ddbd1819ca2a04664394aef6d4c2bb24d6c698c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 14:16:53 2014 +0100

    ALSA: ens137x: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 0f89d2a2090e..29cd339ffc37 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -525,7 +525,7 @@ static unsigned int snd_es1371_wait_src_ready(struct ensoniq * ensoniq)
 			return r;
 		cond_resched();
 	}
-	snd_printk(KERN_ERR "wait src ready timeout 0x%lx [0x%x]\n",
+	dev_err(ensoniq->card->dev, "wait src ready timeout 0x%lx [0x%x]\n",
 		   ES_REG(ensoniq, 1371_SMPRATE), r);
 	return 0;
 }
@@ -587,7 +587,7 @@ static void snd_es1370_codec_write(struct snd_ak4531 *ak4531,
 	unsigned long end_time = jiffies + HZ / 10;
 
 #if 0
-	printk(KERN_DEBUG
+	dev_dbg(ensoniq->card->dev,
 	       "CODEC WRITE: reg = 0x%x, val = 0x%x (0x%x), creg = 0x%x\n",
 	       reg, val, ES_1370_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1370_CODEC));
 #endif
@@ -598,7 +598,7 @@ static void snd_es1370_codec_write(struct snd_ak4531 *ak4531,
 		}
 		schedule_timeout_uninterruptible(1);
 	} while (time_after(end_time, jiffies));
-	snd_printk(KERN_ERR "codec write timeout, status = 0x%x\n",
+	dev_err(ensoniq->card->dev, "codec write timeout, status = 0x%x\n",
 		   inl(ES_REG(ensoniq, STATUS)));
 }
 
@@ -649,7 +649,7 @@ static void snd_es1371_codec_write(struct snd_ac97 *ac97,
 		}
 	}
 	mutex_unlock(&ensoniq->src_mutex);
-	snd_printk(KERN_ERR "codec write timeout at 0x%lx [0x%x]\n",
+	dev_err(ensoniq->card->dev, "codec write timeout at 0x%lx [0x%x]\n",
 		   ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
 }
 
@@ -706,8 +706,8 @@ static unsigned short snd_es1371_codec_read(struct snd_ac97 *ac97,
 			}
 			mutex_unlock(&ensoniq->src_mutex);
 			if (++fail > 10) {
-				snd_printk(KERN_ERR "codec read timeout (final) "
-					   "at 0x%lx, reg = 0x%x [0x%x]\n",
+				dev_err(ensoniq->card->dev,
+					"codec read timeout (final) at 0x%lx, reg = 0x%x [0x%x]\n",
 					   ES_REG(ensoniq, 1371_CODEC), reg,
 					   inl(ES_REG(ensoniq, 1371_CODEC)));
 				return 0;
@@ -716,7 +716,7 @@ static unsigned short snd_es1371_codec_read(struct snd_ac97 *ac97,
 		}
 	}
 	mutex_unlock(&ensoniq->src_mutex);
-	snd_printk(KERN_ERR "es1371: codec read timeout at 0x%lx [0x%x]\n",
+	dev_err(ensoniq->card->dev, "codec read timeout at 0x%lx [0x%x]\n",
 		   ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
 	return 0;
 }
@@ -1796,7 +1796,7 @@ static int snd_ensoniq_1370_mixer(struct ensoniq *ensoniq)
 #ifdef SUPPORT_JOYSTICK
 
 #ifdef CHIP1371
-static int snd_ensoniq_get_joystick_port(int dev)
+static int snd_ensoniq_get_joystick_port(struct ensoniq *ensoniq, int dev)
 {
 	switch (joystick_port[dev]) {
 	case 0: /* disabled */
@@ -1808,12 +1808,13 @@ static int snd_ensoniq_get_joystick_port(int dev)
 		return joystick_port[dev];
 
 	default:
-		printk(KERN_ERR "ens1371: invalid joystick port %#x", joystick_port[dev]);
+		dev_err(ensoniq->card->dev,
+			"invalid joystick port %#x", joystick_port[dev]);
 		return 0;
 	}
 }
 #else
-static inline int snd_ensoniq_get_joystick_port(int dev)
+static int snd_ensoniq_get_joystick_port(struct ensoniq *ensoniq, int dev)
 {
 	return joystick[dev] ? 0x200 : 0;
 }
@@ -1824,7 +1825,7 @@ static int snd_ensoniq_create_gameport(struct ensoniq *ensoniq, int dev)
 	struct gameport *gp;
 	int io_port;
 
-	io_port = snd_ensoniq_get_joystick_port(dev);
+	io_port = snd_ensoniq_get_joystick_port(ensoniq, dev);
 
 	switch (io_port) {
 	case 0:
@@ -1835,14 +1836,16 @@ static int snd_ensoniq_create_gameport(struct ensoniq *ensoniq, int dev)
 			if (request_region(io_port, 8, "ens137x: gameport"))
 				break;
 		if (io_port > 0x218) {
-			printk(KERN_WARNING "ens137x: no gameport ports available\n");
+			dev_warn(ensoniq->card->dev,
+				 "no gameport ports available\n");
 			return -EBUSY;
 		}
 		break;
 
 	default:
 		if (!request_region(io_port, 8, "ens137x: gameport")) {
-			printk(KERN_WARNING "ens137x: gameport io port %#x in use\n",
+			dev_warn(ensoniq->card->dev,
+				 "gameport io port %#x in use\n",
 			       io_port);
 			return -EBUSY;
 		}
@@ -1851,7 +1854,8 @@ static int snd_ensoniq_create_gameport(struct ensoniq *ensoniq, int dev)
 
 	ensoniq->gameport = gp = gameport_allocate_port();
 	if (!gp) {
-		printk(KERN_ERR "ens137x: cannot allocate memory for gameport\n");
+		dev_err(ensoniq->card->dev,
+			"cannot allocate memory for gameport\n");
 		release_region(io_port, 8);
 		return -ENOMEM;
 	}
@@ -2082,8 +2086,7 @@ static int snd_ensoniq_resume(struct device *dev)
 	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
 	if (pci_enable_device(pci) < 0) {
-		printk(KERN_ERR DRIVER_NAME ": pci_enable_device failed, "
-		       "disabling device\n");
+		dev_err(dev, "pci_enable_device failed, disabling device\n");
 		snd_card_disconnect(card);
 		return -EIO;
 	}
@@ -2137,7 +2140,7 @@ static int snd_ensoniq_create(struct snd_card *card,
 	ensoniq->port = pci_resource_start(pci, 0);
 	if (request_irq(pci->irq, snd_audiopci_interrupt, IRQF_SHARED,
 			KBUILD_MODNAME, ensoniq)) {
-		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		dev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);
 		snd_ensoniq_free(ensoniq);
 		return -EBUSY;
 	}
@@ -2145,7 +2148,7 @@ static int snd_ensoniq_create(struct snd_card *card,
 #ifdef CHIP1370
 	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
 				16, &ensoniq->dma_bug) < 0) {
-		snd_printk(KERN_ERR "unable to allocate space for phantom area - dma_bug\n");
+		dev_err(card->dev, "unable to allocate space for phantom area - dma_bug\n");
 		snd_ensoniq_free(ensoniq);
 		return -EBUSY;
 	}

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 61262f396004..0f89d2a2090e 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2180,8 +2180,6 @@ static int snd_ensoniq_create(struct snd_card *card,
 
 	snd_ensoniq_proc_init(ensoniq);
 
-	snd_card_set_dev(card, &pci->dev);
-
 	*rensoniq = ensoniq;
 	return 0;
 }
@@ -2437,7 +2435,8 @@ static int snd_audiopci_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
+			   0, &card);
 	if (err < 0)
 		return err;
 

commit 8e33a52fadddcfc9f85594a7ab4802c60ee0046a
Author: Joe Perches <joe@perches.com>
Date:   Thu Jul 25 11:53:25 2013 -0700

    treewide: Fix printks with 0x%#
    
    Using 0x%# emits 0x0x.  Only one is necessary.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index ca8929b9a5d6..61262f396004 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1842,7 +1842,7 @@ static int snd_ensoniq_create_gameport(struct ensoniq *ensoniq, int dev)
 
 	default:
 		if (!request_region(io_port, 8, "ens137x: gameport")) {
-			printk(KERN_WARNING "ens137x: gameport io port 0x%#x in use\n",
+			printk(KERN_WARNING "ens137x: gameport io port %#x in use\n",
 			       io_port);
 			return -EBUSY;
 		}

commit db10e7fbbc836fb66d4500c64c1960940cfad2b0
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Thu Jun 27 20:55:11 2013 +0800

    ALSA: pci: trivial: replace numeric with standard PM state macros
    
    Use standard PM state macros PCI_Dx instead of numeric 0/1/2..
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 372f8ea91fca..ca8929b9a5d6 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1939,7 +1939,7 @@ static int snd_ensoniq_free(struct ensoniq *ensoniq)
 #endif
 	if (ensoniq->irq >= 0)
 		synchronize_irq(ensoniq->irq);
-	pci_set_power_state(ensoniq->pci, 3);
+	pci_set_power_state(ensoniq->pci, PCI_D3hot);
       __hw_end:
 #ifdef CHIP1370
 	if (ensoniq->dma_bug.area)

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index db2dc835171d..372f8ea91fca 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2497,7 +2497,6 @@ static int snd_audiopci_probe(struct pci_dev *pci,
 static void snd_audiopci_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 static struct pci_driver ens137x_driver = {

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 5674cc316530..db2dc835171d 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1268,8 +1268,8 @@ static const struct snd_pcm_chmap_elem surround_map[] = {
 	{ }
 };
 
-static int __devinit snd_ensoniq_pcm(struct ensoniq * ensoniq, int device,
-				     struct snd_pcm ** rpcm)
+static int snd_ensoniq_pcm(struct ensoniq *ensoniq, int device,
+			   struct snd_pcm **rpcm)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -1310,8 +1310,8 @@ static int __devinit snd_ensoniq_pcm(struct ensoniq * ensoniq, int device,
 	return 0;
 }
 
-static int __devinit snd_ensoniq_pcm2(struct ensoniq * ensoniq, int device,
-				      struct snd_pcm ** rpcm)
+static int snd_ensoniq_pcm2(struct ensoniq *ensoniq, int device,
+			    struct snd_pcm **rpcm)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -1484,7 +1484,7 @@ static int snd_es1371_spdif_put(struct snd_kcontrol *kcontrol,
 
 
 /* spdif controls */
-static struct snd_kcontrol_new snd_es1371_mixer_spdif[] __devinitdata = {
+static struct snd_kcontrol_new snd_es1371_mixer_spdif[] = {
 	ES1371_SPDIF(SNDRV_CTL_NAME_IEC958("",PLAYBACK,SWITCH)),
 	{
 		.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -1546,7 +1546,7 @@ static int snd_es1373_rear_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_ens1373_rear __devinitdata =
+static struct snd_kcontrol_new snd_ens1373_rear =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"AC97 2ch->4ch Copy Switch",
@@ -1591,7 +1591,7 @@ static int snd_es1373_line_put(struct snd_kcontrol *kcontrol,
 	return changed;
 }
 
-static struct snd_kcontrol_new snd_ens1373_line __devinitdata =
+static struct snd_kcontrol_new snd_ens1373_line =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"Line In->Rear Out Switch",
@@ -1625,7 +1625,7 @@ static int es1371_quirk_lookup(struct ensoniq *ensoniq,
 	return 0;
 }
 
-static struct es1371_quirk es1371_spdif_present[] __devinitdata = {
+static struct es1371_quirk es1371_spdif_present[] = {
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_C },
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_D },
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_E },
@@ -1634,14 +1634,14 @@ static struct es1371_quirk es1371_spdif_present[] __devinitdata = {
 	{ .vid = PCI_ANY_ID, .did = PCI_ANY_ID }
 };
 
-static struct snd_pci_quirk ens1373_line_quirk[] __devinitdata = {
+static struct snd_pci_quirk ens1373_line_quirk[] = {
 	SND_PCI_QUIRK_ID(0x1274, 0x2000), /* GA-7DXR */
 	SND_PCI_QUIRK_ID(0x1458, 0xa000), /* GA-8IEXP */
 	{ } /* end */
 };
 
-static int __devinit snd_ensoniq_1371_mixer(struct ensoniq *ensoniq,
-					    int has_spdif, int has_line)
+static int snd_ensoniq_1371_mixer(struct ensoniq *ensoniq,
+				  int has_spdif, int has_line)
 {
 	struct snd_card *card = ensoniq->card;
 	struct snd_ac97_bus *pbus;
@@ -1749,7 +1749,7 @@ static int snd_ensoniq_control_put(struct snd_kcontrol *kcontrol,
  * ENS1370 mixer
  */
 
-static struct snd_kcontrol_new snd_es1370_controls[2] __devinitdata = {
+static struct snd_kcontrol_new snd_es1370_controls[2] = {
 ENSONIQ_CONTROL("PCM 0 Output also on Line-In Jack", ES_1370_XCTL0),
 ENSONIQ_CONTROL("Mic +5V bias", ES_1370_XCTL1)
 };
@@ -1762,7 +1762,7 @@ static void snd_ensoniq_mixer_free_ak4531(struct snd_ak4531 *ak4531)
 	ensoniq->u.es1370.ak4531 = NULL;
 }
 
-static int __devinit snd_ensoniq_1370_mixer(struct ensoniq * ensoniq)
+static int snd_ensoniq_1370_mixer(struct ensoniq *ensoniq)
 {
 	struct snd_card *card = ensoniq->card;
 	struct snd_ak4531 ak4531;
@@ -1796,7 +1796,7 @@ static int __devinit snd_ensoniq_1370_mixer(struct ensoniq * ensoniq)
 #ifdef SUPPORT_JOYSTICK
 
 #ifdef CHIP1371
-static int __devinit snd_ensoniq_get_joystick_port(int dev)
+static int snd_ensoniq_get_joystick_port(int dev)
 {
 	switch (joystick_port[dev]) {
 	case 0: /* disabled */
@@ -1819,7 +1819,7 @@ static inline int snd_ensoniq_get_joystick_port(int dev)
 }
 #endif
 
-static int __devinit snd_ensoniq_create_gameport(struct ensoniq *ensoniq, int dev)
+static int snd_ensoniq_create_gameport(struct ensoniq *ensoniq, int dev)
 {
 	struct gameport *gp;
 	int io_port;
@@ -1913,7 +1913,7 @@ static void snd_ensoniq_proc_read(struct snd_info_entry *entry,
 #endif
 }
 
-static void __devinit snd_ensoniq_proc_init(struct ensoniq * ensoniq)
+static void snd_ensoniq_proc_init(struct ensoniq *ensoniq)
 {
 	struct snd_info_entry *entry;
 
@@ -1960,7 +1960,7 @@ static int snd_ensoniq_dev_free(struct snd_device *device)
 }
 
 #ifdef CHIP1371
-static struct snd_pci_quirk es1371_amplifier_hack[] __devinitdata = {
+static struct snd_pci_quirk es1371_amplifier_hack[] = {
 	SND_PCI_QUIRK_ID(0x107b, 0x2150),	/* Gateway Solo 2150 */
 	SND_PCI_QUIRK_ID(0x13bd, 0x100c),	/* EV1938 on Mebius PC-MJ100V */
 	SND_PCI_QUIRK_ID(0x1102, 0x5938),	/* Targa Xtender300 */
@@ -2106,9 +2106,9 @@ static SIMPLE_DEV_PM_OPS(snd_ensoniq_pm, snd_ensoniq_suspend, snd_ensoniq_resume
 #define SND_ENSONIQ_PM_OPS	NULL
 #endif /* CONFIG_PM_SLEEP */
 
-static int __devinit snd_ensoniq_create(struct snd_card *card,
-				     struct pci_dev *pci,
-				     struct ensoniq ** rensoniq)
+static int snd_ensoniq_create(struct snd_card *card,
+			      struct pci_dev *pci,
+			      struct ensoniq **rensoniq)
 {
 	struct ensoniq *ensoniq;
 	int err;
@@ -2361,8 +2361,8 @@ static struct snd_rawmidi_ops snd_ensoniq_midi_input =
 	.trigger =	snd_ensoniq_midi_input_trigger,
 };
 
-static int __devinit snd_ensoniq_midi(struct ensoniq * ensoniq, int device,
-				      struct snd_rawmidi **rrawmidi)
+static int snd_ensoniq_midi(struct ensoniq *ensoniq, int device,
+			    struct snd_rawmidi **rrawmidi)
 {
 	struct snd_rawmidi *rmidi;
 	int err;
@@ -2422,8 +2422,8 @@ static irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int __devinit snd_audiopci_probe(struct pci_dev *pci,
-					const struct pci_device_id *pci_id)
+static int snd_audiopci_probe(struct pci_dev *pci,
+			      const struct pci_device_id *pci_id)
 {
 	static int dev;
 	struct snd_card *card;
@@ -2494,7 +2494,7 @@ static int __devinit snd_audiopci_probe(struct pci_dev *pci,
 	return 0;
 }
 
-static void __devexit snd_audiopci_remove(struct pci_dev *pci)
+static void snd_audiopci_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -2504,7 +2504,7 @@ static struct pci_driver ens137x_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_audiopci_ids,
 	.probe = snd_audiopci_probe,
-	.remove = __devexit_p(snd_audiopci_remove),
+	.remove = snd_audiopci_remove,
 	.driver = {
 		.pm = SND_ENSONIQ_PM_OPS,
 	},

commit 5efbc2610a7b2aac6c51f8fc943c019106568939
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 13 14:48:46 2012 +0200

    ALSA: Fix leftover chmap UNKNOWN -> MONO conversions
    
    A few files have been slipped from the previous commit to add MONO
    channel type.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 9d432359d1cb..5674cc316530 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1262,7 +1262,7 @@ static struct snd_pcm_ops snd_ensoniq_capture_ops = {
 
 static const struct snd_pcm_chmap_elem surround_map[] = {
 	{ .channels = 1,
-	  .map = { SNDRV_CHMAP_UNKNOWN } },
+	  .map = { SNDRV_CHMAP_MONO } },
 	{ .channels = 2,
 	  .map = { SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
 	{ }

commit 7fb6861d62b24fd0056a52275e5f74db0ef66f88
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 12 15:53:26 2012 +0200

    ALSA: ens1370: Define channel maps
    
    Provide channel maps for individual stereo streams of ENS1370 and
    ENS1371.  Note that the configuration of ENS1370 uses the secondary
    PCM as the front unlike ENS1371.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 1e615c4d12f8..9d432359d1cb 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1260,6 +1260,14 @@ static struct snd_pcm_ops snd_ensoniq_capture_ops = {
 	.pointer =	snd_ensoniq_capture_pointer,
 };
 
+static const struct snd_pcm_chmap_elem surround_map[] = {
+	{ .channels = 1,
+	  .map = { SNDRV_CHMAP_UNKNOWN } },
+	{ .channels = 2,
+	  .map = { SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+	{ }
+};
+
 static int __devinit snd_ensoniq_pcm(struct ensoniq * ensoniq, int device,
 				     struct snd_pcm ** rpcm)
 {
@@ -1287,6 +1295,16 @@ static int __devinit snd_ensoniq_pcm(struct ensoniq * ensoniq, int device,
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
 					      snd_dma_pci_data(ensoniq->pci), 64*1024, 128*1024);
 
+#ifdef CHIP1370
+	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				     surround_map, 2, 0, NULL);
+#else
+	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				     snd_pcm_std_chmaps, 2, 0, NULL);
+#endif
+	if (err < 0)
+		return err;
+
 	if (rpcm)
 		*rpcm = pcm;
 	return 0;
@@ -1317,6 +1335,16 @@ static int __devinit snd_ensoniq_pcm2(struct ensoniq * ensoniq, int device,
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
 					      snd_dma_pci_data(ensoniq->pci), 64*1024, 128*1024);
 
+#ifdef CHIP1370
+	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				     snd_pcm_std_chmaps, 2, 0, NULL);
+#else
+	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				     surround_map, 2, 0, NULL);
+#endif
+	if (err < 0)
+		return err;
+
 	if (rpcm)
 		*rpcm = pcm;
 	return 0;

commit 1fe4d42e0e28c2c004b06dd590702604f47c2402
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 12 15:46:20 2012 +0200

    ALSA: ens1370: Reduce ifdefs
    
    ... just by defining CHIP_NAME and string concats.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 2ba58d365959..1e615c4d12f8 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -55,8 +55,10 @@
 
 #ifdef CHIP1370
 #define DRIVER_NAME "ENS1370"
+#define CHIP_NAME "ES1370" /* it can be ENS but just to keep compatibility... */
 #else
 #define DRIVER_NAME "ENS1371"
+#define CHIP_NAME "ES1371"
 #endif
 
 
@@ -1266,11 +1268,7 @@ static int __devinit snd_ensoniq_pcm(struct ensoniq * ensoniq, int device,
 
 	if (rpcm)
 		*rpcm = NULL;
-#ifdef CHIP1370
-	err = snd_pcm_new(ensoniq->card, "ES1370/1", device, 1, 1, &pcm);
-#else
-	err = snd_pcm_new(ensoniq->card, "ES1371/1", device, 1, 1, &pcm);
-#endif
+	err = snd_pcm_new(ensoniq->card, CHIP_NAME "/1", device, 1, 1, &pcm);
 	if (err < 0)
 		return err;
 
@@ -1283,11 +1281,7 @@ static int __devinit snd_ensoniq_pcm(struct ensoniq * ensoniq, int device,
 
 	pcm->private_data = ensoniq;
 	pcm->info_flags = 0;
-#ifdef CHIP1370
-	strcpy(pcm->name, "ES1370 DAC2/ADC");
-#else
-	strcpy(pcm->name, "ES1371 DAC2/ADC");
-#endif
+	strcpy(pcm->name, CHIP_NAME " DAC2/ADC");
 	ensoniq->pcm1 = pcm;
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
@@ -1306,11 +1300,7 @@ static int __devinit snd_ensoniq_pcm2(struct ensoniq * ensoniq, int device,
 
 	if (rpcm)
 		*rpcm = NULL;
-#ifdef CHIP1370
-	err = snd_pcm_new(ensoniq->card, "ES1370/2", device, 1, 0, &pcm);
-#else
-	err = snd_pcm_new(ensoniq->card, "ES1371/2", device, 1, 0, &pcm);
-#endif
+	err = snd_pcm_new(ensoniq->card, CHIP_NAME "/2", device, 1, 0, &pcm);
 	if (err < 0)
 		return err;
 
@@ -1321,11 +1311,7 @@ static int __devinit snd_ensoniq_pcm2(struct ensoniq * ensoniq, int device,
 #endif
 	pcm->private_data = ensoniq;
 	pcm->info_flags = 0;
-#ifdef CHIP1370
-	strcpy(pcm->name, "ES1370 DAC1");
-#else
-	strcpy(pcm->name, "ES1371 DAC1");
-#endif
+	strcpy(pcm->name, CHIP_NAME " DAC1");
 	ensoniq->pcm2 = pcm;
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
@@ -1885,11 +1871,7 @@ static void snd_ensoniq_proc_read(struct snd_info_entry *entry,
 {
 	struct ensoniq *ensoniq = entry->private_data;
 
-#ifdef CHIP1370
-	snd_iprintf(buffer, "Ensoniq AudioPCI ES1370\n\n");
-#else
-	snd_iprintf(buffer, "Ensoniq AudioPCI ES1371\n\n");
-#endif
+	snd_iprintf(buffer, "Ensoniq AudioPCI " CHIP_NAME "\n\n");
 	snd_iprintf(buffer, "Joystick enable  : %s\n",
 		    ensoniq->ctrl & ES_JYSTK_EN ? "on" : "off");
 #ifdef CHIP1370
@@ -2361,11 +2343,7 @@ static int __devinit snd_ensoniq_midi(struct ensoniq * ensoniq, int device,
 		*rrawmidi = NULL;
 	if ((err = snd_rawmidi_new(ensoniq->card, "ES1370/1", device, 1, 1, &rmidi)) < 0)
 		return err;
-#ifdef CHIP1370
-	strcpy(rmidi->name, "ES1370");
-#else
-	strcpy(rmidi->name, "ES1371");
-#endif
+	strcpy(rmidi->name, CHIP_NAME);
 	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_ensoniq_midi_output);
 	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_ensoniq_midi_input);
 	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT |

commit c7561cd80469f2fe4a6be0984db57832ee7f2a3b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 14 18:12:04 2012 +0200

    ALSA: PCI: Replace CONFIG_PM with CONFIG_PM_SLEEP
    
    Otherwise we may get compile warnings due to unused functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index f7e6f73186e1..2ba58d365959 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2032,7 +2032,7 @@ static void snd_ensoniq_chip_init(struct ensoniq *ensoniq)
 	synchronize_irq(ensoniq->irq);
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int snd_ensoniq_suspend(struct device *dev)
 {
 	struct pci_dev *pci = to_pci_dev(dev);
@@ -2094,7 +2094,7 @@ static SIMPLE_DEV_PM_OPS(snd_ensoniq_pm, snd_ensoniq_suspend, snd_ensoniq_resume
 #define SND_ENSONIQ_PM_OPS	&snd_ensoniq_pm
 #else
 #define SND_ENSONIQ_PM_OPS	NULL
-#endif /* CONFIG_PM */
+#endif /* CONFIG_PM_SLEEP */
 
 static int __devinit snd_ensoniq_create(struct snd_card *card,
 				     struct pci_dev *pci,

commit 68cb2b559278858ef9f3a7722f95df88797c7840
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 15:20:37 2012 +0200

    ALSA: Convert to new pm_ops for PCI drivers
    
    Straightforward conversion to the new pm_ops from the legacy
    suspend/resume ops.
    
    Since we change vx222, vx_core and vxpocket have to be converted,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 3821c81d1c99..f7e6f73186e1 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2033,9 +2033,10 @@ static void snd_ensoniq_chip_init(struct ensoniq *ensoniq)
 }
 
 #ifdef CONFIG_PM
-static int snd_ensoniq_suspend(struct pci_dev *pci, pm_message_t state)
+static int snd_ensoniq_suspend(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct ensoniq *ensoniq = card->private_data;
 	
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
@@ -2058,13 +2059,14 @@ static int snd_ensoniq_suspend(struct pci_dev *pci, pm_message_t state)
 
 	pci_disable_device(pci);
 	pci_save_state(pci);
-	pci_set_power_state(pci, pci_choose_state(pci, state));
+	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
-static int snd_ensoniq_resume(struct pci_dev *pci)
+static int snd_ensoniq_resume(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct ensoniq *ensoniq = card->private_data;
 
 	pci_set_power_state(pci, PCI_D0);
@@ -2087,8 +2089,12 @@ static int snd_ensoniq_resume(struct pci_dev *pci)
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
-#endif /* CONFIG_PM */
 
+static SIMPLE_DEV_PM_OPS(snd_ensoniq_pm, snd_ensoniq_suspend, snd_ensoniq_resume);
+#define SND_ENSONIQ_PM_OPS	&snd_ensoniq_pm
+#else
+#define SND_ENSONIQ_PM_OPS	NULL
+#endif /* CONFIG_PM */
 
 static int __devinit snd_ensoniq_create(struct snd_card *card,
 				     struct pci_dev *pci,
@@ -2493,10 +2499,9 @@ static struct pci_driver ens137x_driver = {
 	.id_table = snd_audiopci_ids,
 	.probe = snd_audiopci_probe,
 	.remove = __devexit_p(snd_audiopci_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_ensoniq_suspend,
-	.resume = snd_ensoniq_resume,
-#endif
+	.driver = {
+		.pm = SND_ENSONIQ_PM_OPS,
+	},
 };
 	
 module_pci_driver(ens137x_driver);

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 47a245e84190..3821c81d1c99 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2488,7 +2488,7 @@ static void __devexit snd_audiopci_remove(struct pci_dev *pci)
 	pci_set_drvdata(pci, NULL);
 }
 
-static struct pci_driver driver = {
+static struct pci_driver ens137x_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_audiopci_ids,
 	.probe = snd_audiopci_probe,
@@ -2499,15 +2499,4 @@ static struct pci_driver driver = {
 #endif
 };
 	
-static int __init alsa_card_ens137x_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit alsa_card_ens137x_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(alsa_card_ens137x_init)
-module_exit(alsa_card_ens137x_exit)
+module_pci_driver(ens137x_driver);

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index d085ad03efe8..47a245e84190 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -83,12 +83,12 @@ MODULE_SUPPORTED_DEVICE("{{Ensoniq,AudioPCI ES1371/73},"
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
 #ifdef SUPPORT_JOYSTICK
 #ifdef CHIP1371
 static int joystick_port[SNDRV_CARDS];
 #else
-static int joystick[SNDRV_CARDS];
+static bool joystick[SNDRV_CARDS];
 #endif
 #endif
 #ifdef CHIP1371

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index f02e2f8d7122..d085ad03efe8 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -33,7 +33,7 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <linux/mutex.h>
 
 #include <sound/core.h>

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index a61dd4229773..f02e2f8d7122 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2120,7 +2120,7 @@ static int __devinit snd_ensoniq_create(struct snd_card *card,
 	}
 	ensoniq->port = pci_resource_start(pci, 0);
 	if (request_irq(pci->irq, snd_audiopci_interrupt, IRQF_SHARED,
-			"Ensoniq AudioPCI", ensoniq)) {
+			KBUILD_MODNAME, ensoniq)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_ensoniq_free(ensoniq);
 		return -EBUSY;

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 863eafea691f..a61dd4229773 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2489,7 +2489,7 @@ static void __devexit snd_audiopci_remove(struct pci_dev *pci)
 }
 
 static struct pci_driver driver = {
-	.name = DRIVER_NAME,
+	.name = KBUILD_MODNAME,
 	.id_table = snd_audiopci_ids,
 	.probe = snd_audiopci_probe,
 	.remove = __devexit_p(snd_audiopci_remove),

commit 6ebb8a4a43e34f999ab36f27f972f3cd751cda4f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Mar 30 08:24:25 2011 +0200

    ALSA: ens1371: fix Creative Ectiva support
    
    To make the EV1938 chip work, add a magic bit and an extra delay.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Tested-by: Tino Schmidt <mailtinoshomepage@gmx.net>
    Cc: all 2.6.x <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 537cfba829a5..863eafea691f 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -229,6 +229,7 @@ MODULE_PARM_DESC(lineio, "Line In to Rear Out (0 = auto, 1 = force).");
 #define ES_REG_1371_CODEC 0x14	/* W/R: Codec Read/Write register address */
 #define   ES_1371_CODEC_RDY	   (1<<31)	/* codec ready */
 #define   ES_1371_CODEC_WIP	   (1<<30)	/* codec register access in progress */
+#define   EV_1938_CODEC_MAGIC	   (1<<26)
 #define   ES_1371_CODEC_PIRD	   (1<<23)	/* codec read/write select register */
 #define   ES_1371_CODEC_WRITE(a,d) ((((a)&0x7f)<<16)|(((d)&0xffff)<<0))
 #define   ES_1371_CODEC_READS(a)   ((((a)&0x7f)<<16)|ES_1371_CODEC_PIRD)
@@ -603,12 +604,18 @@ static void snd_es1370_codec_write(struct snd_ak4531 *ak4531,
 
 #ifdef CHIP1371
 
+static inline bool is_ev1938(struct ensoniq *ensoniq)
+{
+	return ensoniq->pci->device == 0x8938;
+}
+
 static void snd_es1371_codec_write(struct snd_ac97 *ac97,
 				   unsigned short reg, unsigned short val)
 {
 	struct ensoniq *ensoniq = ac97->private_data;
-	unsigned int t, x;
+	unsigned int t, x, flag;
 
+	flag = is_ev1938(ensoniq) ? EV_1938_CODEC_MAGIC : 0;
 	mutex_lock(&ensoniq->src_mutex);
 	for (t = 0; t < POLL_COUNT; t++) {
 		if (!(inl(ES_REG(ensoniq, 1371_CODEC)) & ES_1371_CODEC_WIP)) {
@@ -630,7 +637,8 @@ static void snd_es1371_codec_write(struct snd_ac97 *ac97,
 				    0x00010000)
 					break;
 			}
-			outl(ES_1371_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1371_CODEC));
+			outl(ES_1371_CODEC_WRITE(reg, val) | flag,
+			     ES_REG(ensoniq, 1371_CODEC));
 			/* restore SRC reg */
 			snd_es1371_wait_src_ready(ensoniq);
 			outl(x, ES_REG(ensoniq, 1371_SMPRATE));
@@ -647,8 +655,9 @@ static unsigned short snd_es1371_codec_read(struct snd_ac97 *ac97,
 					    unsigned short reg)
 {
 	struct ensoniq *ensoniq = ac97->private_data;
-	unsigned int t, x, fail = 0;
+	unsigned int t, x, flag, fail = 0;
 
+	flag = is_ev1938(ensoniq) ? EV_1938_CODEC_MAGIC : 0;
       __again:
 	mutex_lock(&ensoniq->src_mutex);
 	for (t = 0; t < POLL_COUNT; t++) {
@@ -671,7 +680,8 @@ static unsigned short snd_es1371_codec_read(struct snd_ac97 *ac97,
 				    0x00010000)
 					break;
 			}
-			outl(ES_1371_CODEC_READS(reg), ES_REG(ensoniq, 1371_CODEC));
+			outl(ES_1371_CODEC_READS(reg) | flag,
+			     ES_REG(ensoniq, 1371_CODEC));
 			/* restore SRC reg */
 			snd_es1371_wait_src_ready(ensoniq);
 			outl(x, ES_REG(ensoniq, 1371_SMPRATE));
@@ -683,6 +693,11 @@ static unsigned short snd_es1371_codec_read(struct snd_ac97 *ac97,
 			/* now wait for the stinkin' data (RDY) */
 			for (t = 0; t < POLL_COUNT; t++) {
 				if ((x = inl(ES_REG(ensoniq, 1371_CODEC))) & ES_1371_CODEC_RDY) {
+					if (is_ev1938(ensoniq)) {
+						for (t = 0; t < 100; t++)
+							inl(ES_REG(ensoniq, CONTROL));
+						x = inl(ES_REG(ensoniq, 1371_CODEC));
+					}
 					mutex_unlock(&ensoniq->src_mutex);
 					return ES_1371_CODEC_READ(x);
 				}

commit 631dd1a885b6d7e9f6f51b4e5b311c2bb04c323c
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Oct 18 11:03:14 2010 +0200

    Update broken web addresses in the kernel.
    
    The patch below updates broken web addresses in the kernel
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Finn Thain <fthain@telegraphics.com.au>
    Cc: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Dimitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Mike Frysinger <vapier.adi@gmail.com>
    Acked-by: Ben Pfaff <blp@cs.stanford.edu>
    Acked-by: Hans J. Koch <hjk@linutronix.de>
    Reviewed-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index c7fba5379813..537cfba829a5 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -22,7 +22,7 @@
 /* Power-Management-Code ( CONFIG_PM )
  * for ens1371 only ( FIXME )
  * derived from cs4281.c, atiixp.c and via82xx.c
- * using http://www.alsa-project.org/~iwai/writing-an-alsa-driver/c1540.htm
+ * using http://www.alsa-project.org/~tiwai/writing-an-alsa-driver/ 
  * by Kurt J. Bosch
  */
 

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 2b82c5c723e1..c7fba5379813 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -443,7 +443,7 @@ struct ensoniq {
 
 static irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id);
 
-static struct pci_device_id snd_audiopci_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_audiopci_ids) = {
 #ifdef CHIP1370
 	{ PCI_VDEVICE(ENSONIQ, 0x5000), 0, },	/* ES1370 */
 #endif

commit 0d7392e54435476243ce08ba57745ab52d639cbb
Author: Joe Perches <joe@perches.com>
Date:   Wed Jun 24 23:18:02 2009 -0700

    sound: Use PCI_VDEVICE for CREATIVE and ECTIVA
    
    Here's a patch on top of the others to use CREATIVE and ECTIVA
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index d589bbc516e2..2b82c5c723e1 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -450,7 +450,7 @@ static struct pci_device_id snd_audiopci_ids[] = {
 #ifdef CHIP1371
 	{ PCI_VDEVICE(ENSONIQ, 0x1371), 0, },	/* ES1371 */
 	{ PCI_VDEVICE(ENSONIQ, 0x5880), 0, },	/* ES1373 - CT5880 */
-	{ 0x1102, 0x8938, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* Ectiva EV1938 */
+	{ PCI_VDEVICE(ECTIVA, 0x8938), 0, },	/* Ectiva EV1938 */
 #endif
 	{ 0, }
 };

commit 28d27aae9432c300857722a917be4065c6d7abff
Author: Joe Perches <joe@perches.com>
Date:   Wed Jun 24 22:13:35 2009 -0700

    sound: Use PCI_VDEVICE
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 18f4d1e98c46..d589bbc516e2 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -445,11 +445,11 @@ static irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id);
 
 static struct pci_device_id snd_audiopci_ids[] = {
 #ifdef CHIP1370
-	{ 0x1274, 0x5000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* ES1370 */
+	{ PCI_VDEVICE(ENSONIQ, 0x5000), 0, },	/* ES1370 */
 #endif
 #ifdef CHIP1371
-	{ 0x1274, 0x1371, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* ES1371 */
-	{ 0x1274, 0x5880, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* ES1373 - CT5880 */
+	{ PCI_VDEVICE(ENSONIQ, 0x1371), 0, },	/* ES1371 */
+	{ PCI_VDEVICE(ENSONIQ, 0x5880), 0, },	/* ES1373 - CT5880 */
 	{ 0x1102, 0x8938, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* Ectiva EV1938 */
 #endif
 	{ 0, }

commit e0d2054fd3cf167395390dc1758644486c782707
Merge: d807500a2472 c468ac29e63b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:35:50 2009 +0100

    Merge branch 'topic/misc' into for-linus

commit ee419653a38de93b75a577851d9e4003cf0bbe07
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 16:11:31 2009 +0100

    ALSA: Fix missing KERN_* prefix to printk in sound/pci
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 9bf95367c882..17674b3406bd 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -584,7 +584,8 @@ static void snd_es1370_codec_write(struct snd_ak4531 *ak4531,
 	unsigned long end_time = jiffies + HZ / 10;
 
 #if 0
-	printk("CODEC WRITE: reg = 0x%x, val = 0x%x (0x%x), creg = 0x%x\n",
+	printk(KERN_DEBUG
+	       "CODEC WRITE: reg = 0x%x, val = 0x%x (0x%x), creg = 0x%x\n",
 	       reg, val, ES_1370_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1370_CODEC));
 #endif
 	do {

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 9bf95367c882..e00614cbceff 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2409,9 +2409,9 @@ static int __devinit snd_audiopci_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
-	if (card == NULL)
-		return -ENOMEM;
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	if (err < 0)
+		return err;
 
 	if ((err = snd_ensoniq_create(card, pci, &ensoniq)) < 0) {
 		snd_card_free(card);

commit 462dba28e1921f19319d11a44b7bb97e72da2a79
Author: Rene Herman <rene.herman@gmail.com>
Date:   Thu Jul 17 14:02:16 2008 +0200

    ALSA: ALSA: ens1370: communicate PCI device to AC97
    
    communicate the ES137x PCI device to the AC97 code for its
    subsys_vendor/device values
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 33032a73ecc8..9bf95367c882 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1629,6 +1629,7 @@ static int __devinit snd_ensoniq_1371_mixer(struct ensoniq *ensoniq,
 	memset(&ac97, 0, sizeof(ac97));
 	ac97.private_data = ensoniq;
 	ac97.private_free = snd_ensoniq_mixer_free_ac97;
+	ac97.pci = ensoniq->pci;
 	ac97.scaps = AC97_SCAP_AUDIO;
 	if ((err = snd_ac97_mixer(pbus, &ac97, &ensoniq->u.es1371.ac97)) < 0)
 		return err;

commit 810fd3f3f621fef9d1ac71b198d830fdeafbc1c3
Author: Rene Herman <rene.herman@gmail.com>
Date:   Thu Jul 17 09:22:29 2008 +0200

    ALSA: ens1370: SRC stands for Sample Rate Converter
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index fbf1124f7c79..33032a73ecc8 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -522,7 +522,7 @@ static unsigned int snd_es1371_wait_src_ready(struct ensoniq * ensoniq)
 			return r;
 		cond_resched();
 	}
-	snd_printk(KERN_ERR "wait source ready timeout 0x%lx [0x%x]\n",
+	snd_printk(KERN_ERR "wait src ready timeout 0x%lx [0x%x]\n",
 		   ES_REG(ensoniq, 1371_SMPRATE), r);
 	return 0;
 }

commit f000fd80937c0d94c67f9f3e7026f1fbc8ef8873
Author: Jeff Garzik <jgarzik@redhat.com>
Date:   Tue Apr 22 13:50:34 2008 +0200

    [ALSA] Fix synchronize_irq() bugs, redundancies
    
    free_irq() calls synchronize_irq() for you, so there is no need for
    drivers to manually do the same thing (again).  Thus, calls where
    sync-irq immediately precedes free-irq can be simplified.
    
    However, during this audit several bugs were noticed, where free-irq is
    preceded by a "irq >= 0" check... but the sync-irq call is not covered
    by the same check.
    
    So, where sync-irq could not be eliminated completely, the missing check
    was added.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 52fae4a7cfdd..fbf1124f7c79 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1910,7 +1910,8 @@ static int snd_ensoniq_free(struct ensoniq *ensoniq)
 	outl(0, ES_REG(ensoniq, CONTROL));	/* switch everything off */
 	outl(0, ES_REG(ensoniq, SERIAL));	/* clear serial interface */
 #endif
-	synchronize_irq(ensoniq->irq);
+	if (ensoniq->irq >= 0)
+		synchronize_irq(ensoniq->irq);
 	pci_set_power_state(ensoniq->pci, 3);
       __hw_end:
 #ifdef CHIP1370

commit 405b0a377cfe3750f4af54b80d0402c3fe777b87
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Feb 28 11:53:07 2008 +0100

    [ALSA] sound: ens1370.c fix shadowed variable warning
    
    index is incremented only when AC97_EI_SPDIF and then assigned to
    the index field.  Change the temporary name to is_spdif.
    
    sound/pci/ens1370.c:1638:10: warning: symbol 'index' shadows an earlier one
    sound/pci/ens1370.c:84:12: originally declared here
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 72d85a5ae6a0..52fae4a7cfdd 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1635,20 +1635,20 @@ static int __devinit snd_ensoniq_1371_mixer(struct ensoniq *ensoniq,
 	if (has_spdif > 0 ||
 	    (!has_spdif && es1371_quirk_lookup(ensoniq, es1371_spdif_present))) {
 		struct snd_kcontrol *kctl;
-		int i, index = 0;
+		int i, is_spdif = 0;
 
 		ensoniq->spdif_default = ensoniq->spdif_stream =
 			SNDRV_PCM_DEFAULT_CON_SPDIF;
 		outl(ensoniq->spdif_default, ES_REG(ensoniq, CHANNEL_STATUS));
 
 		if (ensoniq->u.es1371.ac97->ext_id & AC97_EI_SPDIF)
-			index++;
+			is_spdif++;
 
 		for (i = 0; i < ARRAY_SIZE(snd_es1371_mixer_spdif); i++) {
 			kctl = snd_ctl_new1(&snd_es1371_mixer_spdif[i], ensoniq);
 			if (!kctl)
 				return -ENOMEM;
-			kctl->id.index = index;
+			kctl->id.index = is_spdif;
 			err = snd_ctl_add(card, kctl);
 			if (err < 0)
 				return err;

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index b958f869cb13..72d85a5ae6a0 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -26,7 +26,6 @@
  * by Kurt J. Bosch
  */
 
-#include <sound/driver.h>
 #include <asm/io.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 9017bdb513a1..b958f869cb13 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1,6 +1,6 @@
 /*
  *  Driver for Ensoniq ES1370/ES1371 AudioPCI soundcard
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>,
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>,
  *		     Thomas Sailer <sailer@ife.ee.ethz.ch>
  *
  *   This program is free software; you can redistribute it and/or modify
@@ -61,7 +61,7 @@
 #endif
 
 
-MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, Thomas Sailer <sailer@ife.ee.ethz.ch>");
+MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>, Thomas Sailer <sailer@ife.ee.ethz.ch>");
 MODULE_LICENSE("GPL");
 #ifdef CHIP1370
 MODULE_DESCRIPTION("Ensoniq AudioPCI ES1370");

commit a5ce88909d3007caa7b65996a8f6784350beb2a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 23 15:42:26 2007 +0200

    [ALSA] Clean up with common snd_ctl_boolean_*_info callbacks
    
    Clean up codes using the new common snd_ctl_boolean_*_info() callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 21cb4268a59b..9017bdb513a1 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1419,15 +1419,7 @@ static int snd_ens1373_spdif_stream_put(struct snd_kcontrol *kcontrol,
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_es1371_spdif_info, \
   .get = snd_es1371_spdif_get, .put = snd_es1371_spdif_put }
 
-static int snd_es1371_spdif_info(struct snd_kcontrol *kcontrol,
-				 struct snd_ctl_elem_info *uinfo)
-{
-        uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-        uinfo->count = 1;
-        uinfo->value.integer.min = 0;
-        uinfo->value.integer.max = 1;
-        return 0;
-}
+#define snd_es1371_spdif_info		snd_ctl_boolean_mono_info
 
 static int snd_es1371_spdif_get(struct snd_kcontrol *kcontrol,
 				struct snd_ctl_elem_value *ucontrol)
@@ -1489,15 +1481,7 @@ static struct snd_kcontrol_new snd_es1371_mixer_spdif[] __devinitdata = {
 };
 
 
-static int snd_es1373_rear_info(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_info *uinfo)
-{
-        uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-        uinfo->count = 1;
-        uinfo->value.integer.min = 0;
-        uinfo->value.integer.max = 1;
-        return 0;
-}
+#define snd_es1373_rear_info		snd_ctl_boolean_mono_info
 
 static int snd_es1373_rear_get(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
@@ -1542,15 +1526,7 @@ static struct snd_kcontrol_new snd_ens1373_rear __devinitdata =
 	.put =		snd_es1373_rear_put,
 };
 
-static int snd_es1373_line_info(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_es1373_line_info		snd_ctl_boolean_mono_info
 
 static int snd_es1373_line_get(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
@@ -1707,15 +1683,7 @@ static int __devinit snd_ensoniq_1371_mixer(struct ensoniq *ensoniq,
   .get = snd_ensoniq_control_get, .put = snd_ensoniq_control_put, \
   .private_value = mask }
 
-static int snd_ensoniq_control_info(struct snd_kcontrol *kcontrol,
-				    struct snd_ctl_elem_info *uinfo)
-{
-        uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-        uinfo->count = 1;
-        uinfo->value.integer.min = 0;
-        uinfo->value.integer.max = 1;
-        return 0;
-}
+#define snd_ensoniq_control_info	snd_ctl_boolean_mono_info
 
 static int snd_ensoniq_control_get(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_value *ucontrol)

commit 076c0e4fd80a43f64710fe9aabdc4c463b7f8621
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue Jun 26 11:43:52 2007 +0200

    [ALSA] fix ensoniq section mismatch
    
    Fix ensoniq driver sections when HOTPLUG=n, but code is used
    during resume, so it cannot be discarded:
    WARNING: sound/pci/snd-ens1371.o(.text+0x5c0): Section mismatch: reference to .init.text: (between 'snd_ensoniq_chip_init' and 'snd_ensoniq_free')
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 7c403965153b..21cb4268a59b 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1607,8 +1607,8 @@ struct es1371_quirk {
 	unsigned char rev;		/* revision */
 };
 
-static int __devinit es1371_quirk_lookup(struct ensoniq *ensoniq,
-					 struct es1371_quirk *list)
+static int es1371_quirk_lookup(struct ensoniq *ensoniq,
+				struct es1371_quirk *list)
 {
 	while (list->vid != (unsigned short)PCI_ANY_ID) {
 		if (ensoniq->pci->vendor == list->vid &&

commit 44c10138fd4bbc4b6d6bff0873c24902f2a9da65
Author: Auke Kok <auke-jan.h.kok@intel.com>
Date:   Fri Jun 8 15:46:36 2007 -0700

    PCI: Change all drivers to use pci_device->revision
    
    Instead of all drivers reading pci config space to get the revision
    ID, they can now use the pci_device->revision member.
    
    This exposes some issues where drivers where reading a word or a dword
    for the revision number, and adding useless error-handling around the
    read. Some drivers even just read it for no purpose of all.
    
    In devices where the revision ID is being copied over and used in what
    appears to be the equivalent of hotpath, I have left the copy code
    and the cached copy as not to influence the driver's performance.
    
    Compile tested with make all{yes,mod}config on x86_64 and i386.
    
    Signed-off-by: Auke Kok <auke-jan.h.kok@intel.com>
    Acked-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 6a0ddcf00884..7c403965153b 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2110,7 +2110,6 @@ static int __devinit snd_ensoniq_create(struct snd_card *card,
 				     struct ensoniq ** rensoniq)
 {
 	struct ensoniq *ensoniq;
-	unsigned char cmdb;
 	int err;
 	static struct snd_device_ops ops = {
 		.dev_free =	snd_ensoniq_dev_free,
@@ -2151,8 +2150,7 @@ static int __devinit snd_ensoniq_create(struct snd_card *card,
 	}
 #endif
 	pci_set_master(pci);
-	pci_read_config_byte(pci, PCI_REVISION_ID, &cmdb);
-	ensoniq->rev = cmdb;
+	ensoniq->rev = pci->revision;
 #ifdef CHIP1370
 #if 0
 	ensoniq->ctrl = ES_1370_CDC_EN | ES_1370_SERR_DISABLE |

commit ef991b95aa1351a5782cfaccb9aefba76ca8b990
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 22 12:52:53 2007 +0100

    [ALSA] Add snd_pcm_group_for_each_entry() for code cleanup
    
    Added a new macro snd_pcm_group_for_each_entry() just for code cleanup.
    Old macros, snd_pcm_group_for_each() and snd_pcm_group_substream_entry(),
    are removed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 425b167522d5..6a0ddcf00884 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -798,10 +798,8 @@ static int snd_ensoniq_trigger(struct snd_pcm_substream *substream, int cmd)
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 	{
 		unsigned int what = 0;
-		struct list_head *pos;
 		struct snd_pcm_substream *s;
-		snd_pcm_group_for_each(pos, substream) {
-			s = snd_pcm_group_substream_entry(pos);
+		snd_pcm_group_for_each_entry(s, substream) {
 			if (s == ensoniq->playback1_substream) {
 				what |= ES_P1_PAUSE;
 				snd_pcm_trigger_done(s, substream);
@@ -824,10 +822,8 @@ static int snd_ensoniq_trigger(struct snd_pcm_substream *substream, int cmd)
 	case SNDRV_PCM_TRIGGER_STOP:
 	{
 		unsigned int what = 0;
-		struct list_head *pos;
 		struct snd_pcm_substream *s;
-		snd_pcm_group_for_each(pos, substream) {
-			s = snd_pcm_group_substream_entry(pos);
+		snd_pcm_group_for_each_entry(s, substream) {
 			if (s == ensoniq->playback1_substream) {
 				what |= ES_DAC1_EN;
 				snd_pcm_trigger_done(s, substream);

commit 5da8fa2516388a20a43cd928fda19f6ac2521afc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Nov 24 15:38:18 2006 +0100

    [ALSA] ens1371 - Clean up quirks
    
    Clean up quirks in snd-ens1371 driver using snd_pci_quirk_lookup().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index a84f6b21024f..425b167522d5 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -413,8 +413,6 @@ struct ensoniq {
 	} u;
 
 	struct pci_dev *pci;
-	unsigned short subsystem_vendor_id;
-	unsigned short subsystem_device_id;
 	struct snd_card *card;
 	struct snd_pcm *pcm1;	/* DAC1/ADC PCM */
 	struct snd_pcm *pcm2;	/* DAC2 PCM */
@@ -1607,11 +1605,26 @@ static void snd_ensoniq_mixer_free_ac97(struct snd_ac97 *ac97)
 	ensoniq->u.es1371.ac97 = NULL;
 }
 
-static struct {
+struct es1371_quirk {
 	unsigned short vid;		/* vendor ID */
 	unsigned short did;		/* device ID */
 	unsigned char rev;		/* revision */
-} es1371_spdif_present[] __devinitdata = {
+};
+
+static int __devinit es1371_quirk_lookup(struct ensoniq *ensoniq,
+					 struct es1371_quirk *list)
+{
+	while (list->vid != (unsigned short)PCI_ANY_ID) {
+		if (ensoniq->pci->vendor == list->vid &&
+		    ensoniq->pci->device == list->did &&
+		    ensoniq->rev == list->rev)
+			return 1;
+		list++;
+	}
+	return 0;
+}
+
+static struct es1371_quirk es1371_spdif_present[] __devinitdata = {
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_C },
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_D },
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_E },
@@ -1620,12 +1633,19 @@ static struct {
 	{ .vid = PCI_ANY_ID, .did = PCI_ANY_ID }
 };
 
-static int snd_ensoniq_1371_mixer(struct ensoniq * ensoniq, int has_spdif, int has_line)
+static struct snd_pci_quirk ens1373_line_quirk[] __devinitdata = {
+	SND_PCI_QUIRK_ID(0x1274, 0x2000), /* GA-7DXR */
+	SND_PCI_QUIRK_ID(0x1458, 0xa000), /* GA-8IEXP */
+	{ } /* end */
+};
+
+static int __devinit snd_ensoniq_1371_mixer(struct ensoniq *ensoniq,
+					    int has_spdif, int has_line)
 {
 	struct snd_card *card = ensoniq->card;
 	struct snd_ac97_bus *pbus;
 	struct snd_ac97_template ac97;
-	int err, idx;
+	int err;
 	static struct snd_ac97_bus_ops ops = {
 		.write = snd_es1371_codec_write,
 		.read = snd_es1371_codec_read,
@@ -1641,33 +1661,28 @@ static int snd_ensoniq_1371_mixer(struct ensoniq * ensoniq, int has_spdif, int h
 	ac97.scaps = AC97_SCAP_AUDIO;
 	if ((err = snd_ac97_mixer(pbus, &ac97, &ensoniq->u.es1371.ac97)) < 0)
 		return err;
-	for (idx = 0; es1371_spdif_present[idx].vid != (unsigned short)PCI_ANY_ID; idx++)
-		if ((ensoniq->pci->vendor == es1371_spdif_present[idx].vid &&
-		     ensoniq->pci->device == es1371_spdif_present[idx].did &&
-		     ensoniq->rev == es1371_spdif_present[idx].rev) || has_spdif > 0) {
-		    	struct snd_kcontrol *kctl;
-			int i, index = 0; 
-
-                        if (has_spdif < 0)
-                                break;
-
-			ensoniq->spdif_default = ensoniq->spdif_stream =
-				SNDRV_PCM_DEFAULT_CON_SPDIF;
-			outl(ensoniq->spdif_default, ES_REG(ensoniq, CHANNEL_STATUS));
-
-		    	if (ensoniq->u.es1371.ac97->ext_id & AC97_EI_SPDIF)
-			    	index++;
-
-			for (i = 0; i < (int)ARRAY_SIZE(snd_es1371_mixer_spdif); i++) {
-				kctl = snd_ctl_new1(&snd_es1371_mixer_spdif[i], ensoniq);
-				if (! kctl)
-					return -ENOMEM;
-				kctl->id.index = index;
-				if ((err = snd_ctl_add(card, kctl)) < 0)
-					return err;
-			}
-			break;
+	if (has_spdif > 0 ||
+	    (!has_spdif && es1371_quirk_lookup(ensoniq, es1371_spdif_present))) {
+		struct snd_kcontrol *kctl;
+		int i, index = 0;
+
+		ensoniq->spdif_default = ensoniq->spdif_stream =
+			SNDRV_PCM_DEFAULT_CON_SPDIF;
+		outl(ensoniq->spdif_default, ES_REG(ensoniq, CHANNEL_STATUS));
+
+		if (ensoniq->u.es1371.ac97->ext_id & AC97_EI_SPDIF)
+			index++;
+
+		for (i = 0; i < ARRAY_SIZE(snd_es1371_mixer_spdif); i++) {
+			kctl = snd_ctl_new1(&snd_es1371_mixer_spdif[i], ensoniq);
+			if (!kctl)
+				return -ENOMEM;
+			kctl->id.index = index;
+			err = snd_ctl_add(card, kctl);
+			if (err < 0)
+				return err;
 		}
+	}
 	if (ensoniq->u.es1371.ac97->ext_id & AC97_EI_SDAC) {
 		/* mirror rear to front speakers */
 		ensoniq->cssr &= ~(ES_1373_REAR_BIT27|ES_1373_REAR_BIT24);
@@ -1676,12 +1691,10 @@ static int snd_ensoniq_1371_mixer(struct ensoniq * ensoniq, int has_spdif, int h
 		if (err < 0)
 			return err;
 	}
-	if (((ensoniq->subsystem_vendor_id == 0x1274) &&
-	    (ensoniq->subsystem_device_id == 0x2000)) || /* GA-7DXR */
-	    ((ensoniq->subsystem_vendor_id == 0x1458) &&
-	    (ensoniq->subsystem_device_id == 0xa000)) || /* GA-8IEXP */
-	    has_line > 0) {
-		 err = snd_ctl_add(card, snd_ctl_new1(&snd_ens1373_line, ensoniq));
+	if (has_line > 0 ||
+	    snd_pci_quirk_lookup(ensoniq->pci, ens1373_line_quirk)) {
+		 err = snd_ctl_add(card, snd_ctl_new1(&snd_ens1373_line,
+						      ensoniq));
 		 if (err < 0)
 			 return err;
 	}
@@ -1956,21 +1969,15 @@ static int snd_ensoniq_dev_free(struct snd_device *device)
 }
 
 #ifdef CHIP1371
-static struct {
-	unsigned short svid;		/* subsystem vendor ID */
-	unsigned short sdid;		/* subsystem device ID */
-} es1371_amplifier_hack[] = {
-	{ .svid = 0x107b, .sdid = 0x2150 },	/* Gateway Solo 2150 */
-	{ .svid = 0x13bd, .sdid = 0x100c },	/* EV1938 on Mebius PC-MJ100V */
-	{ .svid = 0x1102, .sdid = 0x5938 },	/* Targa Xtender300 */
-	{ .svid = 0x1102, .sdid = 0x8938 },	/* IPC Topnote G notebook */
-	{ .svid = PCI_ANY_ID, .sdid = PCI_ANY_ID }
+static struct snd_pci_quirk es1371_amplifier_hack[] __devinitdata = {
+	SND_PCI_QUIRK_ID(0x107b, 0x2150),	/* Gateway Solo 2150 */
+	SND_PCI_QUIRK_ID(0x13bd, 0x100c),	/* EV1938 on Mebius PC-MJ100V */
+	SND_PCI_QUIRK_ID(0x1102, 0x5938),	/* Targa Xtender300 */
+	SND_PCI_QUIRK_ID(0x1102, 0x8938),	/* IPC Topnote G notebook */
+	{ } /* end */
 };
-static struct {
-	unsigned short vid;		/* vendor ID */
-	unsigned short did;		/* device ID */
-	unsigned char rev;		/* revision */
-} es1371_ac97_reset_hack[] = {
+
+static struct es1371_quirk es1371_ac97_reset_hack[] = {
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_C },
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_D },
 	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_E },
@@ -1984,7 +1991,6 @@ static void snd_ensoniq_chip_init(struct ensoniq *ensoniq)
 {
 #ifdef CHIP1371
 	int idx;
-	struct pci_dev *pci = ensoniq->pci;
 #endif
 	/* this code was part of snd_ensoniq_create before intruduction
 	  * of suspend/resume
@@ -1999,16 +2005,12 @@ static void snd_ensoniq_chip_init(struct ensoniq *ensoniq)
 	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
 	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
 	outl(0, ES_REG(ensoniq, 1371_LEGACY));
-	for (idx = 0; es1371_ac97_reset_hack[idx].vid != (unsigned short)PCI_ANY_ID; idx++)
-		if (pci->vendor == es1371_ac97_reset_hack[idx].vid &&
-		    pci->device == es1371_ac97_reset_hack[idx].did &&
-		    ensoniq->rev == es1371_ac97_reset_hack[idx].rev) {
-			outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
-			/* need to delay around 20ms(bleech) to give
-			some CODECs enough time to wakeup */
-			msleep(20);
-			break;
-		}
+	if (es1371_quirk_lookup(ensoniq, es1371_ac97_reset_hack)) {
+	    outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
+	    /* need to delay around 20ms(bleech) to give
+	       some CODECs enough time to wakeup */
+	    msleep(20);
+	}
 	/* AC'97 warm reset to start the bitclk */
 	outl(ensoniq->ctrl | ES_1371_SYNC_RES, ES_REG(ensoniq, CONTROL));
 	inl(ES_REG(ensoniq, CONTROL));
@@ -2112,11 +2114,7 @@ static int __devinit snd_ensoniq_create(struct snd_card *card,
 				     struct ensoniq ** rensoniq)
 {
 	struct ensoniq *ensoniq;
-	unsigned short cmdw;
 	unsigned char cmdb;
-#ifdef CHIP1371
-	int idx;
-#endif
 	int err;
 	static struct snd_device_ops ops = {
 		.dev_free =	snd_ensoniq_dev_free,
@@ -2159,10 +2157,6 @@ static int __devinit snd_ensoniq_create(struct snd_card *card,
 	pci_set_master(pci);
 	pci_read_config_byte(pci, PCI_REVISION_ID, &cmdb);
 	ensoniq->rev = cmdb;
-	pci_read_config_word(pci, PCI_SUBSYSTEM_VENDOR_ID, &cmdw);
-	ensoniq->subsystem_vendor_id = cmdw;
-	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &cmdw);
-	ensoniq->subsystem_device_id = cmdw;
 #ifdef CHIP1370
 #if 0
 	ensoniq->ctrl = ES_1370_CDC_EN | ES_1370_SERR_DISABLE |
@@ -2175,19 +2169,11 @@ static int __devinit snd_ensoniq_create(struct snd_card *card,
 	ensoniq->ctrl = 0;
 	ensoniq->sctrl = 0;
 	ensoniq->cssr = 0;
-	for (idx = 0; es1371_amplifier_hack[idx].svid != (unsigned short)PCI_ANY_ID; idx++)
-		if (ensoniq->subsystem_vendor_id == es1371_amplifier_hack[idx].svid &&
-		    ensoniq->subsystem_device_id == es1371_amplifier_hack[idx].sdid) {
-			ensoniq->ctrl |= ES_1371_GPIO_OUT(1);	/* turn amplifier on */
-			break;
-		}
-	for (idx = 0; es1371_ac97_reset_hack[idx].vid != (unsigned short)PCI_ANY_ID; idx++)
-		if (pci->vendor == es1371_ac97_reset_hack[idx].vid &&
-		    pci->device == es1371_ac97_reset_hack[idx].did &&
-		    ensoniq->rev == es1371_ac97_reset_hack[idx].rev) {
-			ensoniq->cssr |= ES_1371_ST_AC97_RST;
-			break;
-		}
+	if (snd_pci_quirk_lookup(pci, es1371_amplifier_hack))
+		ensoniq->ctrl |= ES_1371_GPIO_OUT(1);	/* turn amplifier on */
+
+	if (es1371_quirk_lookup(ensoniq, es1371_ac97_reset_hack))
+		ensoniq->cssr |= ES_1371_ST_AC97_RST;
 #endif
 
 	snd_ensoniq_chip_init(ensoniq);

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index d2a811f222c9..a84f6b21024f 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2141,7 +2141,7 @@ static int __devinit snd_ensoniq_create(struct snd_card *card,
 		return err;
 	}
 	ensoniq->port = pci_resource_start(pci, 0);
-	if (request_irq(pci->irq, snd_audiopci_interrupt, IRQF_DISABLED|IRQF_SHARED,
+	if (request_irq(pci->irq, snd_audiopci_interrupt, IRQF_SHARED,
 			"Ensoniq AudioPCI", ensoniq)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_ensoniq_free(ensoniq);

commit 30b35399ceb2398d05837863476dcb12f12f3a82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 11 18:52:53 2006 +0200

    [ALSA] Various fixes for suspend/resume of ALSA PCI drivers
    
    - Check the return value of pci_enable_device() and request_irq()
      in the suspend.  If any error occurs there, disable the device
      using snd_card_disconnect().
    - Call pci_set_power_state() properly with pci_choose_state().
    - Fix the order to call pci_set_power_state().
    - Removed obsolete house-made PM codes in some drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 8cb4fb2412db..d2a811f222c9 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2072,9 +2072,10 @@ static int snd_ensoniq_suspend(struct pci_dev *pci, pm_message_t state)
 	udelay(100);
 	snd_ak4531_suspend(ensoniq->u.es1370.ak4531);
 #endif	
-	pci_set_power_state(pci, PCI_D3hot);
+
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -2083,9 +2084,14 @@ static int snd_ensoniq_resume(struct pci_dev *pci)
 	struct snd_card *card = pci_get_drvdata(pci);
 	struct ensoniq *ensoniq = card->private_data;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR DRIVER_NAME ": pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	snd_ensoniq_chip_init(ensoniq);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index a8a601fc781f..8cb4fb2412db 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -444,7 +444,7 @@ struct ensoniq {
 #endif
 };
 
-static irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+static irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id);
 
 static struct pci_device_id snd_audiopci_ids[] = {
 #ifdef CHIP1370
@@ -2404,7 +2404,7 @@ static int __devinit snd_ensoniq_midi(struct ensoniq * ensoniq, int device,
  *  Interrupt handler
  */
 
-static irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id)
 {
 	struct ensoniq *ensoniq = dev_id;
 	unsigned int status, sctrl;

commit f40b68903ccd511ea9d658b4bce319dd032a265a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 16:51:05 2006 +0200

    [ALSA] Fix section mismatch errors in ALSA PCI drivers
    
    Fixed 'section mismatch' errors in ALSA PCI drivers:
    - removed invalid __devinitdata from pci id tables
    - fix/remove __devinit of functions called in suspend/resume
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 7a985c868007..a8a601fc781f 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -446,7 +446,7 @@ struct ensoniq {
 
 static irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 
-static struct pci_device_id snd_audiopci_ids[] __devinitdata = {
+static struct pci_device_id snd_audiopci_ids[] = {
 #ifdef CHIP1370
 	{ 0x1274, 0x5000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* ES1370 */
 #endif

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 9d46bbee2a40..7a985c868007 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2135,7 +2135,7 @@ static int __devinit snd_ensoniq_create(struct snd_card *card,
 		return err;
 	}
 	ensoniq->port = pci_resource_start(pci, 0);
-	if (request_irq(pci->irq, snd_audiopci_interrupt, SA_INTERRUPT|SA_SHIRQ,
+	if (request_irq(pci->irq, snd_audiopci_interrupt, IRQF_DISABLED|IRQF_SHARED,
 			"Ensoniq AudioPCI", ensoniq)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_ensoniq_free(ensoniq);

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index ca9e34e88f62..9d46bbee2a40 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1915,7 +1915,7 @@ static void __devinit snd_ensoniq_proc_init(struct ensoniq * ensoniq)
 	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(ensoniq->card, "audiopci", &entry))
-		snd_info_set_text_ops(entry, ensoniq, 1024, snd_ensoniq_proc_read);
+		snd_info_set_text_ops(entry, ensoniq, snd_ensoniq_proc_read);
 }
 
 /*

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index a5533c86b0b6..ca9e34e88f62 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -446,7 +446,7 @@ struct ensoniq {
 
 static irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 
-static struct pci_device_id snd_audiopci_ids[] = {
+static struct pci_device_id snd_audiopci_ids[] __devinitdata = {
 #ifdef CHIP1370
 	{ 0x1274, 0x5000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* ES1370 */
 #endif

commit 62932df8fb20ba2fb53a95fa52445eba22e821fe
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:34:20 2006 +0100

    [ALSA] semaphore -> mutex (PCI part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index bee382995fe9..a5533c86b0b6 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -35,6 +35,8 @@
 #include <linux/slab.h>
 #include <linux/gameport.h>
 #include <linux/moduleparam.h>
+#include <linux/mutex.h>
+
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
@@ -379,7 +381,7 @@ MODULE_PARM_DESC(lineio, "Line In to Rear Out (0 = auto, 1 = force).");
 
 struct ensoniq {
 	spinlock_t reg_lock;
-	struct semaphore src_mutex;
+	struct mutex src_mutex;
 
 	int irq;
 
@@ -609,7 +611,7 @@ static void snd_es1371_codec_write(struct snd_ac97 *ac97,
 	struct ensoniq *ensoniq = ac97->private_data;
 	unsigned int t, x;
 
-	down(&ensoniq->src_mutex);
+	mutex_lock(&ensoniq->src_mutex);
 	for (t = 0; t < POLL_COUNT; t++) {
 		if (!(inl(ES_REG(ensoniq, 1371_CODEC)) & ES_1371_CODEC_WIP)) {
 			/* save the current state for latter */
@@ -634,11 +636,11 @@ static void snd_es1371_codec_write(struct snd_ac97 *ac97,
 			/* restore SRC reg */
 			snd_es1371_wait_src_ready(ensoniq);
 			outl(x, ES_REG(ensoniq, 1371_SMPRATE));
-			up(&ensoniq->src_mutex);
+			mutex_unlock(&ensoniq->src_mutex);
 			return;
 		}
 	}
-	up(&ensoniq->src_mutex);
+	mutex_unlock(&ensoniq->src_mutex);
 	snd_printk(KERN_ERR "codec write timeout at 0x%lx [0x%x]\n",
 		   ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
 }
@@ -650,7 +652,7 @@ static unsigned short snd_es1371_codec_read(struct snd_ac97 *ac97,
 	unsigned int t, x, fail = 0;
 
       __again:
-	down(&ensoniq->src_mutex);
+	mutex_lock(&ensoniq->src_mutex);
 	for (t = 0; t < POLL_COUNT; t++) {
 		if (!(inl(ES_REG(ensoniq, 1371_CODEC)) & ES_1371_CODEC_WIP)) {
 			/* save the current state for latter */
@@ -683,11 +685,11 @@ static unsigned short snd_es1371_codec_read(struct snd_ac97 *ac97,
 			/* now wait for the stinkin' data (RDY) */
 			for (t = 0; t < POLL_COUNT; t++) {
 				if ((x = inl(ES_REG(ensoniq, 1371_CODEC))) & ES_1371_CODEC_RDY) {
-					up(&ensoniq->src_mutex);
+					mutex_unlock(&ensoniq->src_mutex);
 					return ES_1371_CODEC_READ(x);
 				}
 			}
-			up(&ensoniq->src_mutex);
+			mutex_unlock(&ensoniq->src_mutex);
 			if (++fail > 10) {
 				snd_printk(KERN_ERR "codec read timeout (final) "
 					   "at 0x%lx, reg = 0x%x [0x%x]\n",
@@ -698,7 +700,7 @@ static unsigned short snd_es1371_codec_read(struct snd_ac97 *ac97,
 			goto __again;
 		}
 	}
-	up(&ensoniq->src_mutex);
+	mutex_unlock(&ensoniq->src_mutex);
 	snd_printk(KERN_ERR "es1371: codec read timeout at 0x%lx [0x%x]\n",
 		   ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
 	return 0;
@@ -717,7 +719,7 @@ static void snd_es1371_adc_rate(struct ensoniq * ensoniq, unsigned int rate)
 {
 	unsigned int n, truncm, freq, result;
 
-	down(&ensoniq->src_mutex);
+	mutex_lock(&ensoniq->src_mutex);
 	n = rate / 3000;
 	if ((1 << n) & ((1 << 15) | (1 << 13) | (1 << 11) | (1 << 9)))
 		n--;
@@ -742,14 +744,14 @@ static void snd_es1371_adc_rate(struct ensoniq * ensoniq, unsigned int rate)
 	snd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_VFREQ_FRAC, freq & 0x7fff);
 	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC, n << 8);
 	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC + 1, n << 8);
-	up(&ensoniq->src_mutex);
+	mutex_unlock(&ensoniq->src_mutex);
 }
 
 static void snd_es1371_dac1_rate(struct ensoniq * ensoniq, unsigned int rate)
 {
 	unsigned int freq, r;
 
-	down(&ensoniq->src_mutex);
+	mutex_lock(&ensoniq->src_mutex);
 	freq = ((rate << 15) + 1500) / 3000;
 	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |
 						   ES_1371_DIS_P2 | ES_1371_DIS_R1)) |
@@ -763,14 +765,14 @@ static void snd_es1371_dac1_rate(struct ensoniq * ensoniq, unsigned int rate)
 	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |
 						   ES_1371_DIS_P2 | ES_1371_DIS_R1));
 	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
-	up(&ensoniq->src_mutex);
+	mutex_unlock(&ensoniq->src_mutex);
 }
 
 static void snd_es1371_dac2_rate(struct ensoniq * ensoniq, unsigned int rate)
 {
 	unsigned int freq, r;
 
-	down(&ensoniq->src_mutex);
+	mutex_lock(&ensoniq->src_mutex);
 	freq = ((rate << 15) + 1500) / 3000;
 	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |
 						   ES_1371_DIS_P1 | ES_1371_DIS_R1)) |
@@ -785,7 +787,7 @@ static void snd_es1371_dac2_rate(struct ensoniq * ensoniq, unsigned int rate)
 	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |
 						   ES_1371_DIS_P1 | ES_1371_DIS_R1));
 	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
-	up(&ensoniq->src_mutex);
+	mutex_unlock(&ensoniq->src_mutex);
 }
 
 #endif /* CHIP1371 */
@@ -2123,7 +2125,7 @@ static int __devinit snd_ensoniq_create(struct snd_card *card,
 		return -ENOMEM;
 	}
 	spin_lock_init(&ensoniq->reg_lock);
-	init_MUTEX(&ensoniq->src_mutex);
+	mutex_init(&ensoniq->src_mutex);
 	ensoniq->card = card;
 	ensoniq->pci = pci;
 	ensoniq->irq = -1;

commit 15f500a6994e552b7772d8b8459ee3114c47897d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 12 11:43:49 2006 +0100

    [ALSA] ens1370 - Fix resume
    
    Modules: ENS1370/1+ driver
    
    Fix resume of ens1370 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 55aaf110331a..bee382995fe9 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2061,6 +2061,13 @@ static int snd_ensoniq_suspend(struct pci_dev *pci, pm_message_t state)
 #ifdef CHIP1371	
 	snd_ac97_suspend(ensoniq->u.es1371.ac97);
 #else
+	/* try to reset AK4531 */
+	outw(ES_1370_CODEC_WRITE(AK4531_RESET, 0x02), ES_REG(ensoniq, 1370_CODEC));
+	inw(ES_REG(ensoniq, 1370_CODEC));
+	udelay(100);
+	outw(ES_1370_CODEC_WRITE(AK4531_RESET, 0x03), ES_REG(ensoniq, 1370_CODEC));
+	inw(ES_REG(ensoniq, 1370_CODEC));
+	udelay(100);
 	snd_ak4531_suspend(ensoniq->u.es1370.ak4531);
 #endif	
 	pci_set_power_state(pci, PCI_D3hot);

commit 156b2aa3bef17c964006c6448aadd440781d7e7d
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Dec 7 09:07:25 2005 +0100

    [ALSA] ens1371: fix compilation without SUPPORT_JOYSTICK
    
    Modules: ENS1370/1+ driver
    
    Move the spdif and lineio parameters around so that they are compiled
    even when SUPPORT_JOYSTICK isn't set.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 856f7c63d32f..55aaf110331a 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -86,12 +86,14 @@ static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
 #ifdef SUPPORT_JOYSTICK
 #ifdef CHIP1371
 static int joystick_port[SNDRV_CARDS];
-static int spdif[SNDRV_CARDS];
-static int lineio[SNDRV_CARDS];
 #else
 static int joystick[SNDRV_CARDS];
 #endif
 #endif
+#ifdef CHIP1371
+static int spdif[SNDRV_CARDS];
+static int lineio[SNDRV_CARDS];
+#endif
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for Ensoniq AudioPCI soundcard.");
@@ -103,15 +105,17 @@ MODULE_PARM_DESC(enable, "Enable Ensoniq AudioPCI soundcard.");
 #ifdef CHIP1371
 module_param_array(joystick_port, int, NULL, 0444);
 MODULE_PARM_DESC(joystick_port, "Joystick port address.");
-module_param_array(spdif, int, NULL, 0444);
-MODULE_PARM_DESC(spdif, "S/PDIF output (-1 = none, 0 = auto, 1 = force).");
-module_param_array(lineio, int, NULL, 0444);
-MODULE_PARM_DESC(lineio, "Line In to Rear Out (0 = auto, 1 = force).");
 #else
 module_param_array(joystick, bool, NULL, 0444);
 MODULE_PARM_DESC(joystick, "Enable joystick.");
 #endif
 #endif /* SUPPORT_JOYSTICK */
+#ifdef CHIP1371
+module_param_array(spdif, int, NULL, 0444);
+MODULE_PARM_DESC(spdif, "S/PDIF output (-1 = none, 0 = auto, 1 = force).");
+module_param_array(lineio, int, NULL, 0444);
+MODULE_PARM_DESC(lineio, "Line In to Rear Out (0 = auto, 1 = force).");
+#endif
 
 /* ES1371 chip ID */
 /* This is a little confusing because all ES1371 compatible chips have the

commit 015b6a198f51d660797b78c6c7ee60d0252ebf40
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Mon Nov 28 10:50:59 2005 +0100

    [ALSA] ens1371: added spdif and lineio module options
    
    Modules: ENS1370/1+ driver
    
    - spdif module option: some hardware revisions are without spdif output
    - lineio module option: force shared line in / rear out jack settings
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index ff86fabc98c3..856f7c63d32f 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -86,6 +86,8 @@ static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
 #ifdef SUPPORT_JOYSTICK
 #ifdef CHIP1371
 static int joystick_port[SNDRV_CARDS];
+static int spdif[SNDRV_CARDS];
+static int lineio[SNDRV_CARDS];
 #else
 static int joystick[SNDRV_CARDS];
 #endif
@@ -101,6 +103,10 @@ MODULE_PARM_DESC(enable, "Enable Ensoniq AudioPCI soundcard.");
 #ifdef CHIP1371
 module_param_array(joystick_port, int, NULL, 0444);
 MODULE_PARM_DESC(joystick_port, "Joystick port address.");
+module_param_array(spdif, int, NULL, 0444);
+MODULE_PARM_DESC(spdif, "S/PDIF output (-1 = none, 0 = auto, 1 = force).");
+module_param_array(lineio, int, NULL, 0444);
+MODULE_PARM_DESC(lineio, "Line In to Rear Out (0 = auto, 1 = force).");
 #else
 module_param_array(joystick, bool, NULL, 0444);
 MODULE_PARM_DESC(joystick, "Enable joystick.");
@@ -1608,7 +1614,7 @@ static struct {
 	{ .vid = PCI_ANY_ID, .did = PCI_ANY_ID }
 };
 
-static int snd_ensoniq_1371_mixer(struct ensoniq * ensoniq)
+static int snd_ensoniq_1371_mixer(struct ensoniq * ensoniq, int has_spdif, int has_line)
 {
 	struct snd_card *card = ensoniq->card;
 	struct snd_ac97_bus *pbus;
@@ -1630,12 +1636,15 @@ static int snd_ensoniq_1371_mixer(struct ensoniq * ensoniq)
 	if ((err = snd_ac97_mixer(pbus, &ac97, &ensoniq->u.es1371.ac97)) < 0)
 		return err;
 	for (idx = 0; es1371_spdif_present[idx].vid != (unsigned short)PCI_ANY_ID; idx++)
-		if (ensoniq->pci->vendor == es1371_spdif_present[idx].vid &&
-		    ensoniq->pci->device == es1371_spdif_present[idx].did &&
-		    ensoniq->rev == es1371_spdif_present[idx].rev) {
+		if ((ensoniq->pci->vendor == es1371_spdif_present[idx].vid &&
+		     ensoniq->pci->device == es1371_spdif_present[idx].did &&
+		     ensoniq->rev == es1371_spdif_present[idx].rev) || has_spdif > 0) {
 		    	struct snd_kcontrol *kctl;
 			int i, index = 0; 
 
+                        if (has_spdif < 0)
+                                break;
+
 			ensoniq->spdif_default = ensoniq->spdif_stream =
 				SNDRV_PCM_DEFAULT_CON_SPDIF;
 			outl(ensoniq->spdif_default, ES_REG(ensoniq, CHANNEL_STATUS));
@@ -1664,7 +1673,8 @@ static int snd_ensoniq_1371_mixer(struct ensoniq * ensoniq)
 	if (((ensoniq->subsystem_vendor_id == 0x1274) &&
 	    (ensoniq->subsystem_device_id == 0x2000)) || /* GA-7DXR */
 	    ((ensoniq->subsystem_vendor_id == 0x1458) &&
-	    (ensoniq->subsystem_device_id == 0xa000))) { /* GA-8IEXP */
+	    (ensoniq->subsystem_device_id == 0xa000)) || /* GA-8IEXP */
+	    has_line > 0) {
 		 err = snd_ctl_add(card, snd_ctl_new1(&snd_ens1373_line, ensoniq));
 		 if (err < 0)
 			 return err;
@@ -2449,7 +2459,7 @@ static int __devinit snd_audiopci_probe(struct pci_dev *pci,
 	}
 #endif
 #ifdef CHIP1371
-	if ((err = snd_ensoniq_1371_mixer(ensoniq)) < 0) {
+	if ((err = snd_ensoniq_1371_mixer(ensoniq, spdif[dev], lineio[dev])) < 0) {
 		snd_card_free(card);
 		return err;
 	}

commit fe8be10786c040bce53c18048d75b1b23aec64ae
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 16:13:41 2005 +0100

    [ALSA] ens137x - Fix and ADD PM support
    
    Modules: ENS1370/1+ driver
    
    Fix PM support on ens1371 driver.
    Add PM support on ens1370 (together with AK4531), too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 2cc0f83a0fde..ff86fabc98c3 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2034,40 +2034,45 @@ static void snd_ensoniq_chip_init(struct ensoniq *ensoniq)
 }
 
 #ifdef CONFIG_PM
-static int snd_ensoniq_suspend(struct snd_card *card, pm_message_t state)
+static int snd_ensoniq_suspend(struct pci_dev *pci, pm_message_t state)
 {
-	struct ensoniq *ensoniq = card->pm_private_data;
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct ensoniq *ensoniq = card->private_data;
 	
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+
 	snd_pcm_suspend_all(ensoniq->pcm1);
 	snd_pcm_suspend_all(ensoniq->pcm2);
 	
 #ifdef CHIP1371	
-	if (ensoniq->u.es1371.ac97)
-		snd_ac97_suspend(ensoniq->u.es1371.ac97);
+	snd_ac97_suspend(ensoniq->u.es1371.ac97);
 #else
-	/* FIXME */
+	snd_ak4531_suspend(ensoniq->u.es1370.ak4531);
 #endif	
-	pci_set_power_state(ensoniq->pci, 3);
-	pci_disable_device(ensoniq->pci);
+	pci_set_power_state(pci, PCI_D3hot);
+	pci_disable_device(pci);
+	pci_save_state(pci);
 	return 0;
 }
 
-static int snd_ensoniq_resume(struct snd_card *card)
+static int snd_ensoniq_resume(struct pci_dev *pci)
 {
-	struct ensoniq *ensoniq = card->pm_private_data;
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct ensoniq *ensoniq = card->private_data;
 
-	pci_enable_device(ensoniq->pci);
-	pci_set_power_state(ensoniq->pci, 0);	
-	pci_set_master(ensoniq->pci);
+	pci_restore_state(pci);
+	pci_enable_device(pci);
+	pci_set_power_state(pci, PCI_D0);
+	pci_set_master(pci);
 
 	snd_ensoniq_chip_init(ensoniq);
 
 #ifdef CHIP1371	
-	if (ensoniq->u.es1371.ac97)
-		snd_ac97_resume(ensoniq->u.es1371.ac97);
+	snd_ac97_resume(ensoniq->u.es1371.ac97);
 #else
-	/* FIXME */
+	snd_ak4531_resume(ensoniq->u.es1370.ak4531);
 #endif	
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -2165,8 +2170,6 @@ static int __devinit snd_ensoniq_create(struct snd_card *card,
 
 	snd_ensoniq_proc_init(ensoniq);
 
-	snd_card_set_pm_callback(card, snd_ensoniq_suspend, snd_ensoniq_resume, ensoniq);
-
 	snd_card_set_dev(card, &pci->dev);
 
 	*rensoniq = ensoniq;
@@ -2436,6 +2439,7 @@ static int __devinit snd_audiopci_probe(struct pci_dev *pci,
 		snd_card_free(card);
 		return err;
 	}
+	card->private_data = ensoniq;
 
 	pcm_devs[0] = 0; pcm_devs[1] = 1;
 #ifdef CHIP1370
@@ -2495,7 +2499,10 @@ static struct pci_driver driver = {
 	.id_table = snd_audiopci_ids,
 	.probe = snd_audiopci_probe,
 	.remove = __devexit_p(snd_audiopci_remove),
-	SND_PCI_PM_CALLBACKS
+#ifdef CONFIG_PM
+	.suspend = snd_ensoniq_suspend,
+	.resume = snd_ensoniq_resume,
+#endif
 };
 	
 static int __init alsa_card_ens137x_init(void)

commit eb3414b4652344972e86c85ce094cc4a780e1a55
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:03:46 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI ENS137x
    
    Modules: ENS1370/1+ driver
    
    Remove xxx_t typedefs from the PCI ENS137x drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 180c49e4f6af..2cc0f83a0fde 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -367,9 +367,7 @@ MODULE_PARM_DESC(joystick, "Enable joystick.");
 
  */
 
-typedef struct _snd_ensoniq ensoniq_t;
-
-struct _snd_ensoniq {
+struct ensoniq {
 	spinlock_t reg_lock;
 	struct semaphore src_mutex;
 
@@ -392,12 +390,12 @@ struct _snd_ensoniq {
 	union {
 #ifdef CHIP1371
 		struct {
-			ac97_t *ac97;
+			struct snd_ac97 *ac97;
 		} es1371;
 #else
 		struct {
 			int pclkdiv_lock;
-			ak4531_t *ak4531;
+			struct snd_ak4531 *ak4531;
 		} es1370;
 #endif
 	} u;
@@ -405,21 +403,21 @@ struct _snd_ensoniq {
 	struct pci_dev *pci;
 	unsigned short subsystem_vendor_id;
 	unsigned short subsystem_device_id;
-	snd_card_t *card;
-	snd_pcm_t *pcm1;	/* DAC1/ADC PCM */
-	snd_pcm_t *pcm2;	/* DAC2 PCM */
-	snd_pcm_substream_t *playback1_substream;
-	snd_pcm_substream_t *playback2_substream;
-	snd_pcm_substream_t *capture_substream;
+	struct snd_card *card;
+	struct snd_pcm *pcm1;	/* DAC1/ADC PCM */
+	struct snd_pcm *pcm2;	/* DAC2 PCM */
+	struct snd_pcm_substream *playback1_substream;
+	struct snd_pcm_substream *playback2_substream;
+	struct snd_pcm_substream *capture_substream;
 	unsigned int p1_dma_size;
 	unsigned int p2_dma_size;
 	unsigned int c_dma_size;
 	unsigned int p1_period_size;
 	unsigned int p2_period_size;
 	unsigned int c_period_size;
-	snd_rawmidi_t *rmidi;
-	snd_rawmidi_substream_t *midi_input;
-	snd_rawmidi_substream_t *midi_output;
+	struct snd_rawmidi *rmidi;
+	struct snd_rawmidi_substream *midi_input;
+	struct snd_rawmidi_substream *midi_output;
 
 	unsigned int spdif;
 	unsigned int spdif_default;
@@ -459,39 +457,39 @@ MODULE_DEVICE_TABLE(pci, snd_audiopci_ids);
 #ifdef CHIP1370
 static unsigned int snd_es1370_fixed_rates[] =
 	{5512, 11025, 22050, 44100};
-static snd_pcm_hw_constraint_list_t snd_es1370_hw_constraints_rates = {
+static struct snd_pcm_hw_constraint_list snd_es1370_hw_constraints_rates = {
 	.count = 4, 
 	.list = snd_es1370_fixed_rates,
 	.mask = 0,
 };
-static ratnum_t es1370_clock = {
+static struct snd_ratnum es1370_clock = {
 	.num = ES_1370_SRCLOCK,
 	.den_min = 29, 
 	.den_max = 353,
 	.den_step = 1,
 };
-static snd_pcm_hw_constraint_ratnums_t snd_es1370_hw_constraints_clock = {
+static struct snd_pcm_hw_constraint_ratnums snd_es1370_hw_constraints_clock = {
 	.nrats = 1,
 	.rats = &es1370_clock,
 };
 #else
-static ratden_t es1371_dac_clock = {
+static struct snd_ratden es1371_dac_clock = {
 	.num_min = 3000 * (1 << 15),
 	.num_max = 48000 * (1 << 15),
 	.num_step = 3000,
 	.den = 1 << 15,
 };
-static snd_pcm_hw_constraint_ratdens_t snd_es1371_hw_constraints_dac_clock = {
+static struct snd_pcm_hw_constraint_ratdens snd_es1371_hw_constraints_dac_clock = {
 	.nrats = 1,
 	.rats = &es1371_dac_clock,
 };
-static ratnum_t es1371_adc_clock = {
+static struct snd_ratnum es1371_adc_clock = {
 	.num = 48000 << 15,
 	.den_min = 32768, 
 	.den_max = 393216,
 	.den_step = 1,
 };
-static snd_pcm_hw_constraint_ratnums_t snd_es1371_hw_constraints_adc_clock = {
+static struct snd_pcm_hw_constraint_ratnums snd_es1371_hw_constraints_adc_clock = {
 	.nrats = 1,
 	.rats = &es1371_adc_clock,
 };
@@ -505,7 +503,7 @@ static const unsigned int snd_ensoniq_sample_shift[] =
 
 #ifdef CHIP1371
 
-static unsigned int snd_es1371_wait_src_ready(ensoniq_t * ensoniq)
+static unsigned int snd_es1371_wait_src_ready(struct ensoniq * ensoniq)
 {
 	unsigned int t, r = 0;
 
@@ -515,11 +513,12 @@ static unsigned int snd_es1371_wait_src_ready(ensoniq_t * ensoniq)
 			return r;
 		cond_resched();
 	}
-	snd_printk(KERN_ERR "wait source ready timeout 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_SMPRATE), r);
+	snd_printk(KERN_ERR "wait source ready timeout 0x%lx [0x%x]\n",
+		   ES_REG(ensoniq, 1371_SMPRATE), r);
 	return 0;
 }
 
-static unsigned int snd_es1371_src_read(ensoniq_t * ensoniq, unsigned short reg)
+static unsigned int snd_es1371_src_read(struct ensoniq * ensoniq, unsigned short reg)
 {
 	unsigned int temp, i, orig, r;
 
@@ -553,7 +552,7 @@ static unsigned int snd_es1371_src_read(ensoniq_t * ensoniq, unsigned short reg)
 	return temp;
 }
 
-static void snd_es1371_src_write(ensoniq_t * ensoniq,
+static void snd_es1371_src_write(struct ensoniq * ensoniq,
 				 unsigned short reg, unsigned short data)
 {
 	unsigned int r;
@@ -569,14 +568,15 @@ static void snd_es1371_src_write(ensoniq_t * ensoniq,
 
 #ifdef CHIP1370
 
-static void snd_es1370_codec_write(ak4531_t *ak4531,
+static void snd_es1370_codec_write(struct snd_ak4531 *ak4531,
 				   unsigned short reg, unsigned short val)
 {
-	ensoniq_t *ensoniq = ak4531->private_data;
+	struct ensoniq *ensoniq = ak4531->private_data;
 	unsigned long end_time = jiffies + HZ / 10;
 
 #if 0
-	printk("CODEC WRITE: reg = 0x%x, val = 0x%x (0x%x), creg = 0x%x\n", reg, val, ES_1370_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1370_CODEC));
+	printk("CODEC WRITE: reg = 0x%x, val = 0x%x (0x%x), creg = 0x%x\n",
+	       reg, val, ES_1370_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1370_CODEC));
 #endif
 	do {
 		if (!(inl(ES_REG(ensoniq, STATUS)) & ES_1370_CSTAT)) {
@@ -585,17 +585,18 @@ static void snd_es1370_codec_write(ak4531_t *ak4531,
 		}
 		schedule_timeout_uninterruptible(1);
 	} while (time_after(end_time, jiffies));
-	snd_printk(KERN_ERR "codec write timeout, status = 0x%x\n", inl(ES_REG(ensoniq, STATUS)));
+	snd_printk(KERN_ERR "codec write timeout, status = 0x%x\n",
+		   inl(ES_REG(ensoniq, STATUS)));
 }
 
 #endif /* CHIP1370 */
 
 #ifdef CHIP1371
 
-static void snd_es1371_codec_write(ac97_t *ac97,
+static void snd_es1371_codec_write(struct snd_ac97 *ac97,
 				   unsigned short reg, unsigned short val)
 {
-	ensoniq_t *ensoniq = ac97->private_data;
+	struct ensoniq *ensoniq = ac97->private_data;
 	unsigned int t, x;
 
 	down(&ensoniq->src_mutex);
@@ -609,12 +610,14 @@ static void snd_es1371_codec_write(ac97_t *ac97,
 			/* wait for not busy (state 0) first to avoid
 			   transition states */
 			for (t = 0; t < POLL_COUNT; t++) {
-				if ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) == 0x00000000)
+				if ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) ==
+				    0x00000000)
 					break;
 			}
 			/* wait for a SAFE time to write addr/data and then do it, dammit */
 			for (t = 0; t < POLL_COUNT; t++) {
-				if ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) == 0x00010000)
+				if ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) ==
+				    0x00010000)
 					break;
 			}
 			outl(ES_1371_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1371_CODEC));
@@ -626,13 +629,14 @@ static void snd_es1371_codec_write(ac97_t *ac97,
 		}
 	}
 	up(&ensoniq->src_mutex);
-	snd_printk(KERN_ERR "codec write timeout at 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
+	snd_printk(KERN_ERR "codec write timeout at 0x%lx [0x%x]\n",
+		   ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
 }
 
-static unsigned short snd_es1371_codec_read(ac97_t *ac97,
+static unsigned short snd_es1371_codec_read(struct snd_ac97 *ac97,
 					    unsigned short reg)
 {
-	ensoniq_t *ensoniq = ac97->private_data;
+	struct ensoniq *ensoniq = ac97->private_data;
 	unsigned int t, x, fail = 0;
 
       __again:
@@ -647,12 +651,14 @@ static unsigned short snd_es1371_codec_read(ac97_t *ac97,
 			/* wait for not busy (state 0) first to avoid
 			   transition states */
 			for (t = 0; t < POLL_COUNT; t++) {
-				if ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) == 0x00000000)
+				if ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) ==
+				    0x00000000)
 					break;
 			}
 			/* wait for a SAFE time to write addr/data and then do it, dammit */
 			for (t = 0; t < POLL_COUNT; t++) {
-				if ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) == 0x00010000)
+				if ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) ==
+				    0x00010000)
 					break;
 			}
 			outl(ES_1371_CODEC_READS(reg), ES_REG(ensoniq, 1371_CODEC));
@@ -673,18 +679,22 @@ static unsigned short snd_es1371_codec_read(ac97_t *ac97,
 			}
 			up(&ensoniq->src_mutex);
 			if (++fail > 10) {
-				snd_printk(KERN_ERR "codec read timeout (final) at 0x%lx, reg = 0x%x [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), reg, inl(ES_REG(ensoniq, 1371_CODEC)));
+				snd_printk(KERN_ERR "codec read timeout (final) "
+					   "at 0x%lx, reg = 0x%x [0x%x]\n",
+					   ES_REG(ensoniq, 1371_CODEC), reg,
+					   inl(ES_REG(ensoniq, 1371_CODEC)));
 				return 0;
 			}
 			goto __again;
 		}
 	}
 	up(&ensoniq->src_mutex);
-	snd_printk(KERN_ERR "es1371: codec read timeout at 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
+	snd_printk(KERN_ERR "es1371: codec read timeout at 0x%lx [0x%x]\n",
+		   ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
 	return 0;
 }
 
-static void snd_es1371_codec_wait(ac97_t *ac97)
+static void snd_es1371_codec_wait(struct snd_ac97 *ac97)
 {
 	msleep(750);
 	snd_es1371_codec_read(ac97, AC97_RESET);
@@ -693,7 +703,7 @@ static void snd_es1371_codec_wait(ac97_t *ac97)
 	msleep(50);
 }
 
-static void snd_es1371_adc_rate(ensoniq_t * ensoniq, unsigned int rate)
+static void snd_es1371_adc_rate(struct ensoniq * ensoniq, unsigned int rate)
 {
 	unsigned int n, truncm, freq, result;
 
@@ -716,60 +726,70 @@ static void snd_es1371_adc_rate(ensoniq_t * ensoniq, unsigned int rate)
 				0x8000 | (((119 - truncm) >> 1) << 9) | (n << 4));
 	}
 	snd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_INT_REGS,
-			     (snd_es1371_src_read(ensoniq, ES_SMPREG_ADC + ES_SMPREG_INT_REGS) & 0x00ff) |
-				     ((freq >> 5) & 0xfc00));
+			     (snd_es1371_src_read(ensoniq, ES_SMPREG_ADC +
+						  ES_SMPREG_INT_REGS) & 0x00ff) |
+			     ((freq >> 5) & 0xfc00));
 	snd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_VFREQ_FRAC, freq & 0x7fff);
 	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC, n << 8);
 	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC + 1, n << 8);
 	up(&ensoniq->src_mutex);
 }
 
-static void snd_es1371_dac1_rate(ensoniq_t * ensoniq, unsigned int rate)
+static void snd_es1371_dac1_rate(struct ensoniq * ensoniq, unsigned int rate)
 {
 	unsigned int freq, r;
 
 	down(&ensoniq->src_mutex);
 	freq = ((rate << 15) + 1500) / 3000;
-	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE | ES_1371_DIS_P2 | ES_1371_DIS_R1)) | ES_1371_DIS_P1;
+	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |
+						   ES_1371_DIS_P2 | ES_1371_DIS_R1)) |
+		ES_1371_DIS_P1;
 	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
 	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_INT_REGS,
-			     (snd_es1371_src_read(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_INT_REGS) & 0x00ff) |
+			     (snd_es1371_src_read(ensoniq, ES_SMPREG_DAC1 +
+						  ES_SMPREG_INT_REGS) & 0x00ff) |
 			     ((freq >> 5) & 0xfc00));
 	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_VFREQ_FRAC, freq & 0x7fff);
-	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE | ES_1371_DIS_P2 | ES_1371_DIS_R1));
+	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |
+						   ES_1371_DIS_P2 | ES_1371_DIS_R1));
 	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
 	up(&ensoniq->src_mutex);
 }
 
-static void snd_es1371_dac2_rate(ensoniq_t * ensoniq, unsigned int rate)
+static void snd_es1371_dac2_rate(struct ensoniq * ensoniq, unsigned int rate)
 {
 	unsigned int freq, r;
 
 	down(&ensoniq->src_mutex);
 	freq = ((rate << 15) + 1500) / 3000;
-	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 | ES_1371_DIS_R1)) | ES_1371_DIS_P2;
+	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |
+						   ES_1371_DIS_P1 | ES_1371_DIS_R1)) |
+		ES_1371_DIS_P2;
 	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
 	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_INT_REGS,
-			     (snd_es1371_src_read(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_INT_REGS) & 0x00ff) |
+			     (snd_es1371_src_read(ensoniq, ES_SMPREG_DAC2 +
+						  ES_SMPREG_INT_REGS) & 0x00ff) |
 			     ((freq >> 5) & 0xfc00));
-	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_VFREQ_FRAC, freq & 0x7fff);
-	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 | ES_1371_DIS_R1));
+	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_VFREQ_FRAC,
+			     freq & 0x7fff);
+	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE |
+						   ES_1371_DIS_P1 | ES_1371_DIS_R1));
 	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
 	up(&ensoniq->src_mutex);
 }
 
 #endif /* CHIP1371 */
 
-static int snd_ensoniq_trigger(snd_pcm_substream_t *substream, int cmd)
+static int snd_ensoniq_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	struct ensoniq *ensoniq = snd_pcm_substream_chip(substream);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 	{
 		unsigned int what = 0;
 		struct list_head *pos;
-		snd_pcm_substream_t *s;
+		struct snd_pcm_substream *s;
 		snd_pcm_group_for_each(pos, substream) {
 			s = snd_pcm_group_substream_entry(pos);
 			if (s == ensoniq->playback1_substream) {
@@ -795,7 +815,7 @@ static int snd_ensoniq_trigger(snd_pcm_substream_t *substream, int cmd)
 	{
 		unsigned int what = 0;
 		struct list_head *pos;
-		snd_pcm_substream_t *s;
+		struct snd_pcm_substream *s;
 		snd_pcm_group_for_each(pos, substream) {
 			s = snd_pcm_group_substream_entry(pos);
 			if (s == ensoniq->playback1_substream) {
@@ -828,21 +848,21 @@ static int snd_ensoniq_trigger(snd_pcm_substream_t *substream, int cmd)
  *  PCM part
  */
 
-static int snd_ensoniq_hw_params(snd_pcm_substream_t * substream,
-				 snd_pcm_hw_params_t * hw_params)
+static int snd_ensoniq_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *hw_params)
 {
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 }
 
-static int snd_ensoniq_hw_free(snd_pcm_substream_t * substream)
+static int snd_ensoniq_hw_free(struct snd_pcm_substream *substream)
 {
 	return snd_pcm_lib_free_pages(substream);
 }
 
-static int snd_ensoniq_playback1_prepare(snd_pcm_substream_t * substream)
+static int snd_ensoniq_playback1_prepare(struct snd_pcm_substream *substream)
 {
-	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct ensoniq *ensoniq = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned int mode = 0;
 
 	ensoniq->p1_dma_size = snd_pcm_lib_buffer_bytes(substream);
@@ -867,7 +887,8 @@ static int snd_ensoniq_playback1_prepare(snd_pcm_substream_t * substream)
 	ensoniq->sctrl &= ~(ES_P1_LOOP_SEL | ES_P1_PAUSE | ES_P1_SCT_RLD | ES_P1_MODEM);
 	ensoniq->sctrl |= ES_P1_INT_EN | ES_P1_MODEO(mode);
 	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
-	outl((ensoniq->p1_period_size >> snd_ensoniq_sample_shift[mode]) - 1, ES_REG(ensoniq, DAC1_COUNT));
+	outl((ensoniq->p1_period_size >> snd_ensoniq_sample_shift[mode]) - 1,
+	     ES_REG(ensoniq, DAC1_COUNT));
 #ifdef CHIP1370
 	ensoniq->ctrl &= ~ES_1370_WTSRSELM;
 	switch (runtime->rate) {
@@ -886,10 +907,10 @@ static int snd_ensoniq_playback1_prepare(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_ensoniq_playback2_prepare(snd_pcm_substream_t * substream)
+static int snd_ensoniq_playback2_prepare(struct snd_pcm_substream *substream)
 {
-	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct ensoniq *ensoniq = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned int mode = 0;
 
 	ensoniq->p2_dma_size = snd_pcm_lib_buffer_bytes(substream);
@@ -909,7 +930,8 @@ static int snd_ensoniq_playback2_prepare(snd_pcm_substream_t * substream)
 	ensoniq->sctrl |= ES_P2_INT_EN | ES_P2_MODEO(mode) |
 			  ES_P2_END_INCO(mode & 2 ? 2 : 1) | ES_P2_ST_INCO(0);
 	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
-	outl((ensoniq->p2_period_size >> snd_ensoniq_sample_shift[mode]) - 1, ES_REG(ensoniq, DAC2_COUNT));
+	outl((ensoniq->p2_period_size >> snd_ensoniq_sample_shift[mode]) - 1,
+	     ES_REG(ensoniq, DAC2_COUNT));
 #ifdef CHIP1370
 	if (!(ensoniq->u.es1370.pclkdiv_lock & ES_MODE_CAPTURE)) {
 		ensoniq->ctrl &= ~ES_1370_PCLKDIVM;
@@ -925,10 +947,10 @@ static int snd_ensoniq_playback2_prepare(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_ensoniq_capture_prepare(snd_pcm_substream_t * substream)
+static int snd_ensoniq_capture_prepare(struct snd_pcm_substream *substream)
 {
-	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct ensoniq *ensoniq = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned int mode = 0;
 
 	ensoniq->c_dma_size = snd_pcm_lib_buffer_bytes(substream);
@@ -946,7 +968,8 @@ static int snd_ensoniq_capture_prepare(snd_pcm_substream_t * substream)
 	ensoniq->sctrl &= ~(ES_R1_LOOP_SEL | ES_R1_MODEM);
 	ensoniq->sctrl |= ES_R1_INT_EN | ES_R1_MODEO(mode);
 	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
-	outl((ensoniq->c_period_size >> snd_ensoniq_sample_shift[mode]) - 1, ES_REG(ensoniq, ADC_COUNT));
+	outl((ensoniq->c_period_size >> snd_ensoniq_sample_shift[mode]) - 1,
+	     ES_REG(ensoniq, ADC_COUNT));
 #ifdef CHIP1370
 	if (!(ensoniq->u.es1370.pclkdiv_lock & ES_MODE_PLAY2)) {
 		ensoniq->ctrl &= ~ES_1370_PCLKDIVM;
@@ -962,9 +985,9 @@ static int snd_ensoniq_capture_prepare(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static snd_pcm_uframes_t snd_ensoniq_playback1_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_ensoniq_playback1_pointer(struct snd_pcm_substream *substream)
 {
-	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	struct ensoniq *ensoniq = snd_pcm_substream_chip(substream);
 	size_t ptr;
 
 	spin_lock(&ensoniq->reg_lock);
@@ -979,9 +1002,9 @@ static snd_pcm_uframes_t snd_ensoniq_playback1_pointer(snd_pcm_substream_t * sub
 	return ptr;
 }
 
-static snd_pcm_uframes_t snd_ensoniq_playback2_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_ensoniq_playback2_pointer(struct snd_pcm_substream *substream)
 {
-	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	struct ensoniq *ensoniq = snd_pcm_substream_chip(substream);
 	size_t ptr;
 
 	spin_lock(&ensoniq->reg_lock);
@@ -996,9 +1019,9 @@ static snd_pcm_uframes_t snd_ensoniq_playback2_pointer(snd_pcm_substream_t * sub
 	return ptr;
 }
 
-static snd_pcm_uframes_t snd_ensoniq_capture_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_ensoniq_capture_pointer(struct snd_pcm_substream *substream)
 {
-	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	struct ensoniq *ensoniq = snd_pcm_substream_chip(substream);
 	size_t ptr;
 
 	spin_lock(&ensoniq->reg_lock);
@@ -1013,7 +1036,7 @@ static snd_pcm_uframes_t snd_ensoniq_capture_pointer(snd_pcm_substream_t * subst
 	return ptr;
 }
 
-static snd_pcm_hardware_t snd_ensoniq_playback1 =
+static struct snd_pcm_hardware snd_ensoniq_playback1 =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1040,7 +1063,7 @@ static snd_pcm_hardware_t snd_ensoniq_playback1 =
 	.fifo_size =		0,
 };
 
-static snd_pcm_hardware_t snd_ensoniq_playback2 =
+static struct snd_pcm_hardware snd_ensoniq_playback2 =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1060,7 +1083,7 @@ static snd_pcm_hardware_t snd_ensoniq_playback2 =
 	.fifo_size =		0,
 };
 
-static snd_pcm_hardware_t snd_ensoniq_capture =
+static struct snd_pcm_hardware snd_ensoniq_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1079,10 +1102,10 @@ static snd_pcm_hardware_t snd_ensoniq_capture =
 	.fifo_size =		0,
 };
 
-static int snd_ensoniq_playback1_open(snd_pcm_substream_t * substream)
+static int snd_ensoniq_playback1_open(struct snd_pcm_substream *substream)
 {
-	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct ensoniq *ensoniq = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	ensoniq->mode |= ES_MODE_PLAY1;
 	ensoniq->playback1_substream = substream;
@@ -1102,10 +1125,10 @@ static int snd_ensoniq_playback1_open(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_ensoniq_playback2_open(snd_pcm_substream_t * substream)
+static int snd_ensoniq_playback2_open(struct snd_pcm_substream *substream)
 {
-	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct ensoniq *ensoniq = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	ensoniq->mode |= ES_MODE_PLAY2;
 	ensoniq->playback2_substream = substream;
@@ -1125,10 +1148,10 @@ static int snd_ensoniq_playback2_open(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_ensoniq_capture_open(snd_pcm_substream_t * substream)
+static int snd_ensoniq_capture_open(struct snd_pcm_substream *substream)
 {
-	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct ensoniq *ensoniq = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	ensoniq->mode |= ES_MODE_CAPTURE;
 	ensoniq->capture_substream = substream;
@@ -1144,18 +1167,18 @@ static int snd_ensoniq_capture_open(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_ensoniq_playback1_close(snd_pcm_substream_t * substream)
+static int snd_ensoniq_playback1_close(struct snd_pcm_substream *substream)
 {
-	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	struct ensoniq *ensoniq = snd_pcm_substream_chip(substream);
 
 	ensoniq->playback1_substream = NULL;
 	ensoniq->mode &= ~ES_MODE_PLAY1;
 	return 0;
 }
 
-static int snd_ensoniq_playback2_close(snd_pcm_substream_t * substream)
+static int snd_ensoniq_playback2_close(struct snd_pcm_substream *substream)
 {
-	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	struct ensoniq *ensoniq = snd_pcm_substream_chip(substream);
 
 	ensoniq->playback2_substream = NULL;
 	spin_lock_irq(&ensoniq->reg_lock);
@@ -1167,9 +1190,9 @@ static int snd_ensoniq_playback2_close(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_ensoniq_capture_close(snd_pcm_substream_t * substream)
+static int snd_ensoniq_capture_close(struct snd_pcm_substream *substream)
 {
-	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	struct ensoniq *ensoniq = snd_pcm_substream_chip(substream);
 
 	ensoniq->capture_substream = NULL;
 	spin_lock_irq(&ensoniq->reg_lock);
@@ -1181,7 +1204,7 @@ static int snd_ensoniq_capture_close(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static snd_pcm_ops_t snd_ensoniq_playback1_ops = {
+static struct snd_pcm_ops snd_ensoniq_playback1_ops = {
 	.open =		snd_ensoniq_playback1_open,
 	.close =	snd_ensoniq_playback1_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1192,7 +1215,7 @@ static snd_pcm_ops_t snd_ensoniq_playback1_ops = {
 	.pointer =	snd_ensoniq_playback1_pointer,
 };
 
-static snd_pcm_ops_t snd_ensoniq_playback2_ops = {
+static struct snd_pcm_ops snd_ensoniq_playback2_ops = {
 	.open =		snd_ensoniq_playback2_open,
 	.close =	snd_ensoniq_playback2_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1203,7 +1226,7 @@ static snd_pcm_ops_t snd_ensoniq_playback2_ops = {
 	.pointer =	snd_ensoniq_playback2_pointer,
 };
 
-static snd_pcm_ops_t snd_ensoniq_capture_ops = {
+static struct snd_pcm_ops snd_ensoniq_capture_ops = {
 	.open =		snd_ensoniq_capture_open,
 	.close =	snd_ensoniq_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1214,9 +1237,10 @@ static snd_pcm_ops_t snd_ensoniq_capture_ops = {
 	.pointer =	snd_ensoniq_capture_pointer,
 };
 
-static int __devinit snd_ensoniq_pcm(ensoniq_t * ensoniq, int device, snd_pcm_t ** rpcm)
+static int __devinit snd_ensoniq_pcm(struct ensoniq * ensoniq, int device,
+				     struct snd_pcm ** rpcm)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	if (rpcm)
@@ -1253,9 +1277,10 @@ static int __devinit snd_ensoniq_pcm(ensoniq_t * ensoniq, int device, snd_pcm_t
 	return 0;
 }
 
-static int __devinit snd_ensoniq_pcm2(ensoniq_t * ensoniq, int device, snd_pcm_t ** rpcm)
+static int __devinit snd_ensoniq_pcm2(struct ensoniq * ensoniq, int device,
+				      struct snd_pcm ** rpcm)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	if (rpcm)
@@ -1298,17 +1323,18 @@ static int __devinit snd_ensoniq_pcm2(ensoniq_t * ensoniq, int device, snd_pcm_t
  * ENS1371 mixer (including SPDIF interface)
  */
 #ifdef CHIP1371
-static int snd_ens1373_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_ens1373_spdif_info(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_ens1373_spdif_default_get(snd_kcontrol_t * kcontrol,
-                                         snd_ctl_elem_value_t * ucontrol)
+static int snd_ens1373_spdif_default_get(struct snd_kcontrol *kcontrol,
+                                         struct snd_ctl_elem_value *ucontrol)
 {
-	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	struct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);
 	spin_lock_irq(&ensoniq->reg_lock);
 	ucontrol->value.iec958.status[0] = (ensoniq->spdif_default >> 0) & 0xff;
 	ucontrol->value.iec958.status[1] = (ensoniq->spdif_default >> 8) & 0xff;
@@ -1318,10 +1344,10 @@ static int snd_ens1373_spdif_default_get(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_ens1373_spdif_default_put(snd_kcontrol_t * kcontrol,
-                                         snd_ctl_elem_value_t * ucontrol)
+static int snd_ens1373_spdif_default_put(struct snd_kcontrol *kcontrol,
+                                         struct snd_ctl_elem_value *ucontrol)
 {
-	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	struct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 	int change;
 
@@ -1332,14 +1358,15 @@ static int snd_ens1373_spdif_default_put(snd_kcontrol_t * kcontrol,
 	spin_lock_irq(&ensoniq->reg_lock);
 	change = ensoniq->spdif_default != val;
 	ensoniq->spdif_default = val;
-	if (change && ensoniq->playback1_substream == NULL && ensoniq->playback2_substream == NULL)
+	if (change && ensoniq->playback1_substream == NULL &&
+	    ensoniq->playback2_substream == NULL)
 		outl(val, ES_REG(ensoniq, CHANNEL_STATUS));
 	spin_unlock_irq(&ensoniq->reg_lock);
 	return change;
 }
 
-static int snd_ens1373_spdif_mask_get(snd_kcontrol_t * kcontrol,
-                                         snd_ctl_elem_value_t * ucontrol)
+static int snd_ens1373_spdif_mask_get(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
 {
 	ucontrol->value.iec958.status[0] = 0xff;
 	ucontrol->value.iec958.status[1] = 0xff;
@@ -1348,10 +1375,10 @@ static int snd_ens1373_spdif_mask_get(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_ens1373_spdif_stream_get(snd_kcontrol_t * kcontrol,
-                                         snd_ctl_elem_value_t * ucontrol)
+static int snd_ens1373_spdif_stream_get(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
 {
-	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	struct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);
 	spin_lock_irq(&ensoniq->reg_lock);
 	ucontrol->value.iec958.status[0] = (ensoniq->spdif_stream >> 0) & 0xff;
 	ucontrol->value.iec958.status[1] = (ensoniq->spdif_stream >> 8) & 0xff;
@@ -1361,10 +1388,10 @@ static int snd_ens1373_spdif_stream_get(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_ens1373_spdif_stream_put(snd_kcontrol_t * kcontrol,
-                                        snd_ctl_elem_value_t * ucontrol)
+static int snd_ens1373_spdif_stream_put(struct snd_kcontrol *kcontrol,
+                                        struct snd_ctl_elem_value *ucontrol)
 {
-	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	struct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 	int change;
 
@@ -1375,7 +1402,8 @@ static int snd_ens1373_spdif_stream_put(snd_kcontrol_t * kcontrol,
 	spin_lock_irq(&ensoniq->reg_lock);
 	change = ensoniq->spdif_stream != val;
 	ensoniq->spdif_stream = val;
-	if (change && (ensoniq->playback1_substream != NULL || ensoniq->playback2_substream != NULL))
+	if (change && (ensoniq->playback1_substream != NULL ||
+		       ensoniq->playback2_substream != NULL))
 		outl(val, ES_REG(ensoniq, CHANNEL_STATUS));
 	spin_unlock_irq(&ensoniq->reg_lock);
 	return change;
@@ -1385,7 +1413,8 @@ static int snd_ens1373_spdif_stream_put(snd_kcontrol_t * kcontrol,
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_es1371_spdif_info, \
   .get = snd_es1371_spdif_get, .put = snd_es1371_spdif_put }
 
-static int snd_es1371_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int snd_es1371_spdif_info(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_info *uinfo)
 {
         uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
         uinfo->count = 1;
@@ -1394,9 +1423,10 @@ static int snd_es1371_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *
         return 0;
 }
 
-static int snd_es1371_spdif_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_es1371_spdif_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	struct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);
 	
 	spin_lock_irq(&ensoniq->reg_lock);
 	ucontrol->value.integer.value[0] = ensoniq->ctrl & ES_1373_SPDIF_THRU ? 1 : 0;
@@ -1404,9 +1434,10 @@ static int snd_es1371_spdif_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	return 0;
 }
 
-static int snd_es1371_spdif_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_es1371_spdif_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
 {
-	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	struct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);
 	unsigned int nval1, nval2;
 	int change;
 	
@@ -1426,7 +1457,7 @@ static int snd_es1371_spdif_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 
 
 /* spdif controls */
-static snd_kcontrol_new_t snd_es1371_mixer_spdif[] __devinitdata = {
+static struct snd_kcontrol_new snd_es1371_mixer_spdif[] __devinitdata = {
 	ES1371_SPDIF(SNDRV_CTL_NAME_IEC958("",PLAYBACK,SWITCH)),
 	{
 		.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -1452,7 +1483,8 @@ static snd_kcontrol_new_t snd_es1371_mixer_spdif[] __devinitdata = {
 };
 
 
-static int snd_es1373_rear_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int snd_es1373_rear_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
 {
         uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
         uinfo->count = 1;
@@ -1461,28 +1493,33 @@ static int snd_es1373_rear_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *u
         return 0;
 }
 
-static int snd_es1373_rear_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_es1373_rear_get(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
 {
-	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	struct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);
 	int val = 0;
 	
 	spin_lock_irq(&ensoniq->reg_lock);
-	if ((ensoniq->cssr & (ES_1373_REAR_BIT27|ES_1373_REAR_BIT26|ES_1373_REAR_BIT24)) == ES_1373_REAR_BIT26)
+	if ((ensoniq->cssr & (ES_1373_REAR_BIT27|ES_1373_REAR_BIT26|
+			      ES_1373_REAR_BIT24)) == ES_1373_REAR_BIT26)
 	    	val = 1;
 	ucontrol->value.integer.value[0] = val;
 	spin_unlock_irq(&ensoniq->reg_lock);
 	return 0;
 }
 
-static int snd_es1373_rear_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_es1373_rear_put(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
 {
-	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	struct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);
 	unsigned int nval1;
 	int change;
 	
-	nval1 = ucontrol->value.integer.value[0] ? ES_1373_REAR_BIT26 : (ES_1373_REAR_BIT27|ES_1373_REAR_BIT24);
+	nval1 = ucontrol->value.integer.value[0] ?
+		ES_1373_REAR_BIT26 : (ES_1373_REAR_BIT27|ES_1373_REAR_BIT24);
 	spin_lock_irq(&ensoniq->reg_lock);
-	change = (ensoniq->cssr & (ES_1373_REAR_BIT27|ES_1373_REAR_BIT26|ES_1373_REAR_BIT24)) != nval1;
+	change = (ensoniq->cssr & (ES_1373_REAR_BIT27|
+				   ES_1373_REAR_BIT26|ES_1373_REAR_BIT24)) != nval1;
 	ensoniq->cssr &= ~(ES_1373_REAR_BIT27|ES_1373_REAR_BIT26|ES_1373_REAR_BIT24);
 	ensoniq->cssr |= nval1;
 	outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
@@ -1490,7 +1527,7 @@ static int snd_es1373_rear_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t *
 	return change;
 }
 
-static snd_kcontrol_new_t snd_ens1373_rear __devinitdata =
+static struct snd_kcontrol_new snd_ens1373_rear __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"AC97 2ch->4ch Copy Switch",
@@ -1499,7 +1536,8 @@ static snd_kcontrol_new_t snd_ens1373_rear __devinitdata =
 	.put =		snd_es1373_rear_put,
 };
 
-static int snd_es1373_line_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int snd_es1373_line_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
@@ -1508,9 +1546,10 @@ static int snd_es1373_line_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *u
 	return 0;
 }
 
-static int snd_es1373_line_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_es1373_line_get(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
 {
-	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	struct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);
 	int val = 0;
 	
 	spin_lock_irq(&ensoniq->reg_lock);
@@ -1521,9 +1560,10 @@ static int snd_es1373_line_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t *
 	return 0;
 }
 
-static int snd_es1373_line_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_es1373_line_put(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
 {
-	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	struct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);
 	int changed;
 	unsigned int ctrl;
 	
@@ -1540,7 +1580,7 @@ static int snd_es1373_line_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t *
 	return changed;
 }
 
-static snd_kcontrol_new_t snd_ens1373_line __devinitdata =
+static struct snd_kcontrol_new snd_ens1373_line __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =		"Line In->Rear Out Switch",
@@ -1549,9 +1589,9 @@ static snd_kcontrol_new_t snd_ens1373_line __devinitdata =
 	.put =		snd_es1373_line_put,
 };
 
-static void snd_ensoniq_mixer_free_ac97(ac97_t *ac97)
+static void snd_ensoniq_mixer_free_ac97(struct snd_ac97 *ac97)
 {
-	ensoniq_t *ensoniq = ac97->private_data;
+	struct ensoniq *ensoniq = ac97->private_data;
 	ensoniq->u.es1371.ac97 = NULL;
 }
 
@@ -1568,13 +1608,13 @@ static struct {
 	{ .vid = PCI_ANY_ID, .did = PCI_ANY_ID }
 };
 
-static int snd_ensoniq_1371_mixer(ensoniq_t * ensoniq)
+static int snd_ensoniq_1371_mixer(struct ensoniq * ensoniq)
 {
-	snd_card_t *card = ensoniq->card;
-	ac97_bus_t *pbus;
-	ac97_template_t ac97;
+	struct snd_card *card = ensoniq->card;
+	struct snd_ac97_bus *pbus;
+	struct snd_ac97_template ac97;
 	int err, idx;
-	static ac97_bus_ops_t ops = {
+	static struct snd_ac97_bus_ops ops = {
 		.write = snd_es1371_codec_write,
 		.read = snd_es1371_codec_read,
 		.wait = snd_es1371_codec_wait,
@@ -1593,10 +1633,11 @@ static int snd_ensoniq_1371_mixer(ensoniq_t * ensoniq)
 		if (ensoniq->pci->vendor == es1371_spdif_present[idx].vid &&
 		    ensoniq->pci->device == es1371_spdif_present[idx].did &&
 		    ensoniq->rev == es1371_spdif_present[idx].rev) {
-		    	snd_kcontrol_t *kctl;
+		    	struct snd_kcontrol *kctl;
 			int i, index = 0; 
 
-			ensoniq->spdif_default = ensoniq->spdif_stream = SNDRV_PCM_DEFAULT_CON_SPDIF;
+			ensoniq->spdif_default = ensoniq->spdif_stream =
+				SNDRV_PCM_DEFAULT_CON_SPDIF;
 			outl(ensoniq->spdif_default, ES_REG(ensoniq, CHANNEL_STATUS));
 
 		    	if (ensoniq->u.es1371.ac97->ext_id & AC97_EI_SPDIF)
@@ -1641,7 +1682,8 @@ static int snd_ensoniq_1371_mixer(ensoniq_t * ensoniq)
   .get = snd_ensoniq_control_get, .put = snd_ensoniq_control_put, \
   .private_value = mask }
 
-static int snd_ensoniq_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int snd_ensoniq_control_info(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
 {
         uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
         uinfo->count = 1;
@@ -1650,9 +1692,10 @@ static int snd_ensoniq_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_
         return 0;
 }
 
-static int snd_ensoniq_control_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_ensoniq_control_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
 {
-	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	struct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);
 	int mask = kcontrol->private_value;
 	
 	spin_lock_irq(&ensoniq->reg_lock);
@@ -1661,9 +1704,10 @@ static int snd_ensoniq_control_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value
 	return 0;
 }
 
-static int snd_ensoniq_control_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_ensoniq_control_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
 {
-	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	struct ensoniq *ensoniq = snd_kcontrol_chip(kcontrol);
 	int mask = kcontrol->private_value;
 	unsigned int nval;
 	int change;
@@ -1682,23 +1726,23 @@ static int snd_ensoniq_control_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value
  * ENS1370 mixer
  */
 
-static snd_kcontrol_new_t snd_es1370_controls[2] __devinitdata = {
+static struct snd_kcontrol_new snd_es1370_controls[2] __devinitdata = {
 ENSONIQ_CONTROL("PCM 0 Output also on Line-In Jack", ES_1370_XCTL0),
 ENSONIQ_CONTROL("Mic +5V bias", ES_1370_XCTL1)
 };
 
 #define ES1370_CONTROLS ARRAY_SIZE(snd_es1370_controls)
 
-static void snd_ensoniq_mixer_free_ak4531(ak4531_t *ak4531)
+static void snd_ensoniq_mixer_free_ak4531(struct snd_ak4531 *ak4531)
 {
-	ensoniq_t *ensoniq = ak4531->private_data;
+	struct ensoniq *ensoniq = ak4531->private_data;
 	ensoniq->u.es1370.ak4531 = NULL;
 }
 
-static int __devinit snd_ensoniq_1370_mixer(ensoniq_t * ensoniq)
+static int __devinit snd_ensoniq_1370_mixer(struct ensoniq * ensoniq)
 {
-	snd_card_t *card = ensoniq->card;
-	ak4531_t ak4531;
+	struct snd_card *card = ensoniq->card;
+	struct snd_ak4531 ak4531;
 	unsigned int idx;
 	int err;
 
@@ -1752,7 +1796,7 @@ static inline int snd_ensoniq_get_joystick_port(int dev)
 }
 #endif
 
-static int __devinit snd_ensoniq_create_gameport(ensoniq_t *ensoniq, int dev)
+static int __devinit snd_ensoniq_create_gameport(struct ensoniq *ensoniq, int dev)
 {
 	struct gameport *gp;
 	int io_port;
@@ -1775,7 +1819,8 @@ static int __devinit snd_ensoniq_create_gameport(ensoniq_t *ensoniq, int dev)
 
 	default:
 		if (!request_region(io_port, 8, "ens137x: gameport")) {
-			printk(KERN_WARNING "ens137x: gameport io port 0x%#x in use\n", io_port);
+			printk(KERN_WARNING "ens137x: gameport io port 0x%#x in use\n",
+			       io_port);
 			return -EBUSY;
 		}
 		break;
@@ -1805,7 +1850,7 @@ static int __devinit snd_ensoniq_create_gameport(ensoniq_t *ensoniq, int dev)
 	return 0;
 }
 
-static void snd_ensoniq_free_gameport(ensoniq_t *ensoniq)
+static void snd_ensoniq_free_gameport(struct ensoniq *ensoniq)
 {
 	if (ensoniq->gameport) {
 		int port = ensoniq->gameport->io;
@@ -1818,36 +1863,40 @@ static void snd_ensoniq_free_gameport(ensoniq_t *ensoniq)
 	}
 }
 #else
-static inline int snd_ensoniq_create_gameport(ensoniq_t *ensoniq, long port) { return -ENOSYS; }
-static inline void snd_ensoniq_free_gameport(ensoniq_t *ensoniq) { }
+static inline int snd_ensoniq_create_gameport(struct ensoniq *ensoniq, long port) { return -ENOSYS; }
+static inline void snd_ensoniq_free_gameport(struct ensoniq *ensoniq) { }
 #endif /* SUPPORT_JOYSTICK */
 
 /*
 
  */
 
-static void snd_ensoniq_proc_read(snd_info_entry_t *entry, 
-				  snd_info_buffer_t * buffer)
+static void snd_ensoniq_proc_read(struct snd_info_entry *entry, 
+				  struct snd_info_buffer *buffer)
 {
-	ensoniq_t *ensoniq = entry->private_data;
+	struct ensoniq *ensoniq = entry->private_data;
 
 #ifdef CHIP1370
 	snd_iprintf(buffer, "Ensoniq AudioPCI ES1370\n\n");
 #else
 	snd_iprintf(buffer, "Ensoniq AudioPCI ES1371\n\n");
 #endif
-	snd_iprintf(buffer, "Joystick enable  : %s\n", ensoniq->ctrl & ES_JYSTK_EN ? "on" : "off");
+	snd_iprintf(buffer, "Joystick enable  : %s\n",
+		    ensoniq->ctrl & ES_JYSTK_EN ? "on" : "off");
 #ifdef CHIP1370
-	snd_iprintf(buffer, "MIC +5V bias     : %s\n", ensoniq->ctrl & ES_1370_XCTL1 ? "on" : "off");
-	snd_iprintf(buffer, "Line In to AOUT  : %s\n", ensoniq->ctrl & ES_1370_XCTL0 ? "on" : "off");
+	snd_iprintf(buffer, "MIC +5V bias     : %s\n",
+		    ensoniq->ctrl & ES_1370_XCTL1 ? "on" : "off");
+	snd_iprintf(buffer, "Line In to AOUT  : %s\n",
+		    ensoniq->ctrl & ES_1370_XCTL0 ? "on" : "off");
 #else
-	snd_iprintf(buffer, "Joystick port    : 0x%x\n", (ES_1371_JOY_ASELI(ensoniq->ctrl) * 8) + 0x200);
+	snd_iprintf(buffer, "Joystick port    : 0x%x\n",
+		    (ES_1371_JOY_ASELI(ensoniq->ctrl) * 8) + 0x200);
 #endif
 }
 
-static void __devinit snd_ensoniq_proc_init(ensoniq_t * ensoniq)
+static void __devinit snd_ensoniq_proc_init(struct ensoniq * ensoniq)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(ensoniq->card, "audiopci", &entry))
 		snd_info_set_text_ops(entry, ensoniq, 1024, snd_ensoniq_proc_read);
@@ -1857,7 +1906,7 @@ static void __devinit snd_ensoniq_proc_init(ensoniq_t * ensoniq)
 
  */
 
-static int snd_ensoniq_free(ensoniq_t *ensoniq)
+static int snd_ensoniq_free(struct ensoniq *ensoniq)
 {
 	snd_ensoniq_free_gameport(ensoniq);
 	if (ensoniq->irq < 0)
@@ -1877,16 +1926,16 @@ static int snd_ensoniq_free(ensoniq_t *ensoniq)
 		snd_dma_free_pages(&ensoniq->dma_bug);
 #endif
 	if (ensoniq->irq >= 0)
-		free_irq(ensoniq->irq, (void *)ensoniq);
+		free_irq(ensoniq->irq, ensoniq);
 	pci_release_regions(ensoniq->pci);
 	pci_disable_device(ensoniq->pci);
 	kfree(ensoniq);
 	return 0;
 }
 
-static int snd_ensoniq_dev_free(snd_device_t *device)
+static int snd_ensoniq_dev_free(struct snd_device *device)
 {
-	ensoniq_t *ensoniq = device->device_data;
+	struct ensoniq *ensoniq = device->device_data;
 	return snd_ensoniq_free(ensoniq);
 }
 
@@ -1915,13 +1964,15 @@ static struct {
 };
 #endif
 
-static void snd_ensoniq_chip_init(ensoniq_t * ensoniq)
+static void snd_ensoniq_chip_init(struct ensoniq *ensoniq)
 {
 #ifdef CHIP1371
 	int idx;
 	struct pci_dev *pci = ensoniq->pci;
 #endif
-// this code was part of snd_ensoniq_create before intruduction of suspend/resume
+	/* this code was part of snd_ensoniq_create before intruduction
+	  * of suspend/resume
+	  */
 #ifdef CHIP1370
 	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
 	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
@@ -1983,10 +2034,9 @@ static void snd_ensoniq_chip_init(ensoniq_t * ensoniq)
 }
 
 #ifdef CONFIG_PM
-static int snd_ensoniq_suspend (snd_card_t * card,
-                                pm_message_t state)
+static int snd_ensoniq_suspend(struct snd_card *card, pm_message_t state)
 {
-	ensoniq_t *ensoniq = card->pm_private_data;
+	struct ensoniq *ensoniq = card->pm_private_data;
 	
 	snd_pcm_suspend_all(ensoniq->pcm1);
 	snd_pcm_suspend_all(ensoniq->pcm2);
@@ -1997,16 +2047,14 @@ static int snd_ensoniq_suspend (snd_card_t * card,
 #else
 	/* FIXME */
 #endif	
-        pci_set_power_state(ensoniq->pci, 3);
+	pci_set_power_state(ensoniq->pci, 3);
 	pci_disable_device(ensoniq->pci);
-        // snd_power_change_state(card, SNDRV_CTL_POWER_D3hot); // only 2.6.10
 	return 0;
 }
 
-static int snd_ensoniq_resume (snd_card_t * card
-                              )
+static int snd_ensoniq_resume(struct snd_card *card)
 {
-	ensoniq_t *ensoniq = card->pm_private_data;
+	struct ensoniq *ensoniq = card->pm_private_data;
 
 	pci_enable_device(ensoniq->pci);
 	pci_set_power_state(ensoniq->pci, 0);	
@@ -2020,24 +2068,23 @@ static int snd_ensoniq_resume (snd_card_t * card
 #else
 	/* FIXME */
 #endif	
-	// snd_power_change_state(card, SNDRV_CTL_POWER_D0); // only 2.6.10
 	return 0;
 }
 #endif /* CONFIG_PM */
 
 
-static int __devinit snd_ensoniq_create(snd_card_t * card,
+static int __devinit snd_ensoniq_create(struct snd_card *card,
 				     struct pci_dev *pci,
-				     ensoniq_t ** rensoniq)
+				     struct ensoniq ** rensoniq)
 {
-	ensoniq_t *ensoniq;
+	struct ensoniq *ensoniq;
 	unsigned short cmdw;
 	unsigned char cmdb;
 #ifdef CHIP1371
 	int idx;
 #endif
 	int err;
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free =	snd_ensoniq_dev_free,
 	};
 
@@ -2060,7 +2107,8 @@ static int __devinit snd_ensoniq_create(snd_card_t * card,
 		return err;
 	}
 	ensoniq->port = pci_resource_start(pci, 0);
-	if (request_irq(pci->irq, snd_audiopci_interrupt, SA_INTERRUPT|SA_SHIRQ, "Ensoniq AudioPCI", (void *)ensoniq)) {
+	if (request_irq(pci->irq, snd_audiopci_interrupt, SA_INTERRUPT|SA_SHIRQ,
+			"Ensoniq AudioPCI", ensoniq)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_ensoniq_free(ensoniq);
 		return -EBUSY;
@@ -2083,7 +2131,8 @@ static int __devinit snd_ensoniq_create(snd_card_t * card,
 	ensoniq->subsystem_device_id = cmdw;
 #ifdef CHIP1370
 #if 0
-	ensoniq->ctrl = ES_1370_CDC_EN | ES_1370_SERR_DISABLE | ES_1370_PCLKDIVO(ES_1370_SRTODIV(8000));
+	ensoniq->ctrl = ES_1370_CDC_EN | ES_1370_SERR_DISABLE |
+		ES_1370_PCLKDIVO(ES_1370_SRTODIV(8000));
 #else	/* get microphone working */
 	ensoniq->ctrl = ES_1370_CDC_EN | ES_1370_PCLKDIVO(ES_1370_SRTODIV(8000));
 #endif
@@ -2128,9 +2177,9 @@ static int __devinit snd_ensoniq_create(snd_card_t * card,
  *  MIDI section
  */
 
-static void snd_ensoniq_midi_interrupt(ensoniq_t * ensoniq)
+static void snd_ensoniq_midi_interrupt(struct ensoniq * ensoniq)
 {
-	snd_rawmidi_t * rmidi = ensoniq->rmidi;
+	struct snd_rawmidi *rmidi = ensoniq->rmidi;
 	unsigned char status, mask, byte;
 
 	if (rmidi == NULL)
@@ -2165,9 +2214,9 @@ static void snd_ensoniq_midi_interrupt(ensoniq_t * ensoniq)
 	spin_unlock(&ensoniq->reg_lock);
 }
 
-static int snd_ensoniq_midi_input_open(snd_rawmidi_substream_t * substream)
+static int snd_ensoniq_midi_input_open(struct snd_rawmidi_substream *substream)
 {
-	ensoniq_t *ensoniq = substream->rmidi->private_data;
+	struct ensoniq *ensoniq = substream->rmidi->private_data;
 
 	spin_lock_irq(&ensoniq->reg_lock);
 	ensoniq->uartm |= ES_MODE_INPUT;
@@ -2181,9 +2230,9 @@ static int snd_ensoniq_midi_input_open(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static int snd_ensoniq_midi_input_close(snd_rawmidi_substream_t * substream)
+static int snd_ensoniq_midi_input_close(struct snd_rawmidi_substream *substream)
 {
-	ensoniq_t *ensoniq = substream->rmidi->private_data;
+	struct ensoniq *ensoniq = substream->rmidi->private_data;
 
 	spin_lock_irq(&ensoniq->reg_lock);
 	if (!(ensoniq->uartm & ES_MODE_OUTPUT)) {
@@ -2198,9 +2247,9 @@ static int snd_ensoniq_midi_input_close(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static int snd_ensoniq_midi_output_open(snd_rawmidi_substream_t * substream)
+static int snd_ensoniq_midi_output_open(struct snd_rawmidi_substream *substream)
 {
-	ensoniq_t *ensoniq = substream->rmidi->private_data;
+	struct ensoniq *ensoniq = substream->rmidi->private_data;
 
 	spin_lock_irq(&ensoniq->reg_lock);
 	ensoniq->uartm |= ES_MODE_OUTPUT;
@@ -2214,9 +2263,9 @@ static int snd_ensoniq_midi_output_open(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static int snd_ensoniq_midi_output_close(snd_rawmidi_substream_t * substream)
+static int snd_ensoniq_midi_output_close(struct snd_rawmidi_substream *substream)
 {
-	ensoniq_t *ensoniq = substream->rmidi->private_data;
+	struct ensoniq *ensoniq = substream->rmidi->private_data;
 
 	spin_lock_irq(&ensoniq->reg_lock);
 	if (!(ensoniq->uartm & ES_MODE_INPUT)) {
@@ -2231,10 +2280,10 @@ static int snd_ensoniq_midi_output_close(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static void snd_ensoniq_midi_input_trigger(snd_rawmidi_substream_t * substream, int up)
+static void snd_ensoniq_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)
 {
 	unsigned long flags;
-	ensoniq_t *ensoniq = substream->rmidi->private_data;
+	struct ensoniq *ensoniq = substream->rmidi->private_data;
 	int idx;
 
 	spin_lock_irqsave(&ensoniq->reg_lock, flags);
@@ -2255,10 +2304,10 @@ static void snd_ensoniq_midi_input_trigger(snd_rawmidi_substream_t * substream,
 	spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
 }
 
-static void snd_ensoniq_midi_output_trigger(snd_rawmidi_substream_t * substream, int up)
+static void snd_ensoniq_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)
 {
 	unsigned long flags;
-	ensoniq_t *ensoniq = substream->rmidi->private_data;
+	struct ensoniq *ensoniq = substream->rmidi->private_data;
 	unsigned char byte;
 
 	spin_lock_irqsave(&ensoniq->reg_lock, flags);
@@ -2285,23 +2334,24 @@ static void snd_ensoniq_midi_output_trigger(snd_rawmidi_substream_t * substream,
 	spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
 }
 
-static snd_rawmidi_ops_t snd_ensoniq_midi_output =
+static struct snd_rawmidi_ops snd_ensoniq_midi_output =
 {
 	.open =		snd_ensoniq_midi_output_open,
 	.close =	snd_ensoniq_midi_output_close,
 	.trigger =	snd_ensoniq_midi_output_trigger,
 };
 
-static snd_rawmidi_ops_t snd_ensoniq_midi_input =
+static struct snd_rawmidi_ops snd_ensoniq_midi_input =
 {
 	.open =		snd_ensoniq_midi_input_open,
 	.close =	snd_ensoniq_midi_input_close,
 	.trigger =	snd_ensoniq_midi_input_trigger,
 };
 
-static int __devinit snd_ensoniq_midi(ensoniq_t * ensoniq, int device, snd_rawmidi_t **rrawmidi)
+static int __devinit snd_ensoniq_midi(struct ensoniq * ensoniq, int device,
+				      struct snd_rawmidi **rrawmidi)
 {
-	snd_rawmidi_t *rmidi;
+	struct snd_rawmidi *rmidi;
 	int err;
 
 	if (rrawmidi)
@@ -2315,7 +2365,8 @@ static int __devinit snd_ensoniq_midi(ensoniq_t * ensoniq, int device, snd_rawmi
 #endif
 	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_ensoniq_midi_output);
 	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_ensoniq_midi_input);
-	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT | SNDRV_RAWMIDI_INFO_DUPLEX;
+	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT |
+		SNDRV_RAWMIDI_INFO_DUPLEX;
 	rmidi->private_data = ensoniq;
 	ensoniq->rmidi = rmidi;
 	if (rrawmidi)
@@ -2329,7 +2380,7 @@ static int __devinit snd_ensoniq_midi(ensoniq_t * ensoniq, int device, snd_rawmi
 
 static irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	ensoniq_t *ensoniq = dev_id;
+	struct ensoniq *ensoniq = dev_id;
 	unsigned int status, sctrl;
 
 	if (ensoniq == NULL)
@@ -2366,8 +2417,8 @@ static int __devinit snd_audiopci_probe(struct pci_dev *pci,
 					const struct pci_device_id *pci_id)
 {
 	static int dev;
-	snd_card_t *card;
-	ensoniq_t *ensoniq;
+	struct snd_card *card;
+	struct ensoniq *ensoniq;
 	int err, pcm_devs[2];
 
 	if (dev >= SNDRV_CARDS)

commit c3e6f7d8763fa0400d28c57633eb323515ba05fc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 16 18:43:35 2005 +0100

    [ALSA] Remove superfluous pcm_free callbacks
    
    Remove superflous pcm_free callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index fa619a959d8c..180c49e4f6af 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1214,13 +1214,6 @@ static snd_pcm_ops_t snd_ensoniq_capture_ops = {
 	.pointer =	snd_ensoniq_capture_pointer,
 };
 
-static void snd_ensoniq_pcm_free(snd_pcm_t *pcm)
-{
-	ensoniq_t *ensoniq = pcm->private_data;
-	ensoniq->pcm1 = NULL;
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
 static int __devinit snd_ensoniq_pcm(ensoniq_t * ensoniq, int device, snd_pcm_t ** rpcm)
 {
 	snd_pcm_t *pcm;
@@ -1244,7 +1237,6 @@ static int __devinit snd_ensoniq_pcm(ensoniq_t * ensoniq, int device, snd_pcm_t
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ensoniq_capture_ops);
 
 	pcm->private_data = ensoniq;
-	pcm->private_free = snd_ensoniq_pcm_free;
 	pcm->info_flags = 0;
 #ifdef CHIP1370
 	strcpy(pcm->name, "ES1370 DAC2/ADC");
@@ -1261,13 +1253,6 @@ static int __devinit snd_ensoniq_pcm(ensoniq_t * ensoniq, int device, snd_pcm_t
 	return 0;
 }
 
-static void snd_ensoniq_pcm_free2(snd_pcm_t *pcm)
-{
-	ensoniq_t *ensoniq = pcm->private_data;
-	ensoniq->pcm2 = NULL;
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
 static int __devinit snd_ensoniq_pcm2(ensoniq_t * ensoniq, int device, snd_pcm_t ** rpcm)
 {
 	snd_pcm_t *pcm;
@@ -1289,7 +1274,6 @@ static int __devinit snd_ensoniq_pcm2(ensoniq_t * ensoniq, int device, snd_pcm_t
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ensoniq_playback2_ops);
 #endif
 	pcm->private_data = ensoniq;
-	pcm->private_free = snd_ensoniq_pcm_free2;
 	pcm->info_flags = 0;
 #ifdef CHIP1370
 	strcpy(pcm->name, "ES1370 DAC1");

commit f31a31b9024f21b2ad8f5a7c30e265a652e2e211
Author: Kurt J. Bosch <kjb-temp-2005@gmx.de>
Date:   Wed Nov 16 18:41:21 2005 +0100

    [ALSA] Fix missing suspend/resume-code for ens1371
    
    Modules: ENS1370/1+ driver
    
    This patch fixes missing suspend/resume-code for snd-ens1371
    (but not for snd-ens1370)
    
    Signed-off-by: Kurt J. Bosch <kjb-temp-2005@gmx.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 2daa575f43ff..fa619a959d8c 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -19,6 +19,13 @@
  *
  */
 
+/* Power-Management-Code ( CONFIG_PM )
+ * for ens1371 only ( FIXME )
+ * derived from cs4281.c, atiixp.c and via82xx.c
+ * using http://www.alsa-project.org/~iwai/writing-an-alsa-driver/c1540.htm
+ * by Kurt J. Bosch
+ */
+
 #include <sound/driver.h>
 #include <asm/io.h>
 #include <linux/delay.h>
@@ -1924,6 +1931,117 @@ static struct {
 };
 #endif
 
+static void snd_ensoniq_chip_init(ensoniq_t * ensoniq)
+{
+#ifdef CHIP1371
+	int idx;
+	struct pci_dev *pci = ensoniq->pci;
+#endif
+// this code was part of snd_ensoniq_create before intruduction of suspend/resume
+#ifdef CHIP1370
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
+	outl(ES_MEM_PAGEO(ES_PAGE_ADC), ES_REG(ensoniq, MEM_PAGE));
+	outl(ensoniq->dma_bug.addr, ES_REG(ensoniq, PHANTOM_FRAME));
+	outl(0, ES_REG(ensoniq, PHANTOM_COUNT));
+#else
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
+	outl(0, ES_REG(ensoniq, 1371_LEGACY));
+	for (idx = 0; es1371_ac97_reset_hack[idx].vid != (unsigned short)PCI_ANY_ID; idx++)
+		if (pci->vendor == es1371_ac97_reset_hack[idx].vid &&
+		    pci->device == es1371_ac97_reset_hack[idx].did &&
+		    ensoniq->rev == es1371_ac97_reset_hack[idx].rev) {
+			outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
+			/* need to delay around 20ms(bleech) to give
+			some CODECs enough time to wakeup */
+			msleep(20);
+			break;
+		}
+	/* AC'97 warm reset to start the bitclk */
+	outl(ensoniq->ctrl | ES_1371_SYNC_RES, ES_REG(ensoniq, CONTROL));
+	inl(ES_REG(ensoniq, CONTROL));
+	udelay(20);
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	/* Init the sample rate converter */
+	snd_es1371_wait_src_ready(ensoniq);	
+	outl(ES_1371_SRC_DISABLE, ES_REG(ensoniq, 1371_SMPRATE));
+	for (idx = 0; idx < 0x80; idx++)
+		snd_es1371_src_write(ensoniq, idx, 0);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_TRUNC_N, 16 << 4);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_INT_REGS, 16 << 10);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_TRUNC_N, 16 << 4);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_INT_REGS, 16 << 10);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC, 1 << 12);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC + 1, 1 << 12);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC1, 1 << 12);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC1 + 1, 1 << 12);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC2, 1 << 12);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC2 + 1, 1 << 12);
+	snd_es1371_adc_rate(ensoniq, 22050);
+	snd_es1371_dac1_rate(ensoniq, 22050);
+	snd_es1371_dac2_rate(ensoniq, 22050);
+	/* WARNING:
+	 * enabling the sample rate converter without properly programming
+	 * its parameters causes the chip to lock up (the SRC busy bit will
+	 * be stuck high, and I've found no way to rectify this other than
+	 * power cycle) - Thomas Sailer
+	 */
+	snd_es1371_wait_src_ready(ensoniq);
+	outl(0, ES_REG(ensoniq, 1371_SMPRATE));
+	/* try reset codec directly */
+	outl(ES_1371_CODEC_WRITE(0, 0), ES_REG(ensoniq, 1371_CODEC));
+#endif
+	outb(ensoniq->uartc = 0x00, ES_REG(ensoniq, UART_CONTROL));
+	outb(0x00, ES_REG(ensoniq, UART_RES));
+	outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
+	synchronize_irq(ensoniq->irq);
+}
+
+#ifdef CONFIG_PM
+static int snd_ensoniq_suspend (snd_card_t * card,
+                                pm_message_t state)
+{
+	ensoniq_t *ensoniq = card->pm_private_data;
+	
+	snd_pcm_suspend_all(ensoniq->pcm1);
+	snd_pcm_suspend_all(ensoniq->pcm2);
+	
+#ifdef CHIP1371	
+	if (ensoniq->u.es1371.ac97)
+		snd_ac97_suspend(ensoniq->u.es1371.ac97);
+#else
+	/* FIXME */
+#endif	
+        pci_set_power_state(ensoniq->pci, 3);
+	pci_disable_device(ensoniq->pci);
+        // snd_power_change_state(card, SNDRV_CTL_POWER_D3hot); // only 2.6.10
+	return 0;
+}
+
+static int snd_ensoniq_resume (snd_card_t * card
+                              )
+{
+	ensoniq_t *ensoniq = card->pm_private_data;
+
+	pci_enable_device(ensoniq->pci);
+	pci_set_power_state(ensoniq->pci, 0);	
+	pci_set_master(ensoniq->pci);
+
+	snd_ensoniq_chip_init(ensoniq);
+
+#ifdef CHIP1371	
+	if (ensoniq->u.es1371.ac97)
+		snd_ac97_resume(ensoniq->u.es1371.ac97);
+#else
+	/* FIXME */
+#endif	
+	// snd_power_change_state(card, SNDRV_CTL_POWER_D0); // only 2.6.10
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+
 static int __devinit snd_ensoniq_create(snd_card_t * card,
 				     struct pci_dev *pci,
 				     ensoniq_t ** rensoniq)
@@ -1986,12 +2104,6 @@ static int __devinit snd_ensoniq_create(snd_card_t * card,
 	ensoniq->ctrl = ES_1370_CDC_EN | ES_1370_PCLKDIVO(ES_1370_SRTODIV(8000));
 #endif
 	ensoniq->sctrl = 0;
-	/* initialize the chips */
-	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
-	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
-	outl(ES_MEM_PAGEO(ES_PAGE_ADC), ES_REG(ensoniq, MEM_PAGE));
-	outl(ensoniq->dma_bug.addr, ES_REG(ensoniq, PHANTOM_FRAME));
-	outl(0, ES_REG(ensoniq, PHANTOM_COUNT));
 #else
 	ensoniq->ctrl = 0;
 	ensoniq->sctrl = 0;
@@ -2002,59 +2114,16 @@ static int __devinit snd_ensoniq_create(snd_card_t * card,
 			ensoniq->ctrl |= ES_1371_GPIO_OUT(1);	/* turn amplifier on */
 			break;
 		}
-	/* initialize the chips */
-	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
-	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
-	outl(0, ES_REG(ensoniq, 1371_LEGACY));
 	for (idx = 0; es1371_ac97_reset_hack[idx].vid != (unsigned short)PCI_ANY_ID; idx++)
 		if (pci->vendor == es1371_ac97_reset_hack[idx].vid &&
 		    pci->device == es1371_ac97_reset_hack[idx].did &&
 		    ensoniq->rev == es1371_ac97_reset_hack[idx].rev) {
 			ensoniq->cssr |= ES_1371_ST_AC97_RST;
-			outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
-			/* need to delay around 20ms(bleech) to give
-			some CODECs enough time to wakeup */
-			msleep(20);
 			break;
 		}
-	/* AC'97 warm reset to start the bitclk */
-	outl(ensoniq->ctrl | ES_1371_SYNC_RES, ES_REG(ensoniq, CONTROL));
-	inl(ES_REG(ensoniq, CONTROL));
-	udelay(20);
-	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
-	/* Init the sample rate converter */
-	snd_es1371_wait_src_ready(ensoniq);	
-	outl(ES_1371_SRC_DISABLE, ES_REG(ensoniq, 1371_SMPRATE));
-	for (idx = 0; idx < 0x80; idx++)
-		snd_es1371_src_write(ensoniq, idx, 0);
-	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_TRUNC_N, 16 << 4);
-	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_INT_REGS, 16 << 10);
-	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_TRUNC_N, 16 << 4);
-	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_INT_REGS, 16 << 10);
-	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC, 1 << 12);
-	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC + 1, 1 << 12);
-	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC1, 1 << 12);
-	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC1 + 1, 1 << 12);
-	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC2, 1 << 12);
-	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC2 + 1, 1 << 12);
-	snd_es1371_adc_rate(ensoniq, 22050);
-	snd_es1371_dac1_rate(ensoniq, 22050);
-	snd_es1371_dac2_rate(ensoniq, 22050);
-	/* WARNING:
-	 * enabling the sample rate converter without properly programming
-	 * its parameters causes the chip to lock up (the SRC busy bit will
-	 * be stuck high, and I've found no way to rectify this other than
-	 * power cycle) - Thomas Sailer
-	 */
-	snd_es1371_wait_src_ready(ensoniq);
-	outl(0, ES_REG(ensoniq, 1371_SMPRATE));
-	/* try reset codec directly */
-	outl(ES_1371_CODEC_WRITE(0, 0), ES_REG(ensoniq, 1371_CODEC));
 #endif
-	outb(ensoniq->uartc = 0x00, ES_REG(ensoniq, UART_CONTROL));
-	outb(0x00, ES_REG(ensoniq, UART_RES));
-	outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
-	synchronize_irq(ensoniq->irq);
+
+	snd_ensoniq_chip_init(ensoniq);
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, ensoniq, &ops)) < 0) {
 		snd_ensoniq_free(ensoniq);
@@ -2063,6 +2132,8 @@ static int __devinit snd_ensoniq_create(snd_card_t * card,
 
 	snd_ensoniq_proc_init(ensoniq);
 
+	snd_card_set_pm_callback(card, snd_ensoniq_suspend, snd_ensoniq_resume, ensoniq);
+
 	snd_card_set_dev(card, &pci->dev);
 
 	*rensoniq = ensoniq;
@@ -2389,6 +2460,7 @@ static struct pci_driver driver = {
 	.id_table = snd_audiopci_ids,
 	.probe = snd_audiopci_probe,
 	.remove = __devexit_p(snd_audiopci_remove),
+	SND_PCI_PM_CALLBACKS
 };
 	
 static int __init alsa_card_ens137x_init(void)

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 92ff7c510f2b..2daa575f43ff 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2386,7 +2386,6 @@ static void __devexit snd_audiopci_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = DRIVER_NAME,
-	.owner = THIS_MODULE,
 	.id_table = snd_audiopci_ids,
 	.probe = snd_audiopci_probe,
 	.remove = __devexit_p(snd_audiopci_remove),

commit 8433a509c0eb6bb1f33ce39c82c580b8901619ee
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Mon Oct 24 15:02:37 2005 +0200

    [ALSA] Fix schedule_timeout usage
    
    Use schedule_timeout_{,un}interruptible() instead of
    set_current_state()/schedule_timeout() to reduce kernel size.  Also use
    human-time conversion functions instead of hard-coded division to avoid
    rounding issues.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index b4d0a9c2b0b5..92ff7c510f2b 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -576,8 +576,7 @@ static void snd_es1370_codec_write(ak4531_t *ak4531,
 			outw(ES_1370_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1370_CODEC));
 			return;
 		}
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_timeout_uninterruptible(1);
 	} while (time_after(end_time, jiffies));
 	snd_printk(KERN_ERR "codec write timeout, status = 0x%x\n", inl(ES_REG(ensoniq, STATUS)));
 }

commit 99b359ba10a582148c6725f428a33ba5356dd993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 20 18:26:44 2005 +0200

    [ALSA] Add missing KERN_* suffix to printk
    
    Add missing KERN_* suffix to printk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index bef9a59f46d7..b4d0a9c2b0b5 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -508,7 +508,7 @@ static unsigned int snd_es1371_wait_src_ready(ensoniq_t * ensoniq)
 			return r;
 		cond_resched();
 	}
-	snd_printk("wait source ready timeout 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_SMPRATE), r);
+	snd_printk(KERN_ERR "wait source ready timeout 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_SMPRATE), r);
 	return 0;
 }
 
@@ -579,7 +579,7 @@ static void snd_es1370_codec_write(ak4531_t *ak4531,
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		schedule_timeout(1);
 	} while (time_after(end_time, jiffies));
-	snd_printk("codec write timeout, status = 0x%x\n", inl(ES_REG(ensoniq, STATUS)));
+	snd_printk(KERN_ERR "codec write timeout, status = 0x%x\n", inl(ES_REG(ensoniq, STATUS)));
 }
 
 #endif /* CHIP1370 */
@@ -620,7 +620,7 @@ static void snd_es1371_codec_write(ac97_t *ac97,
 		}
 	}
 	up(&ensoniq->src_mutex);
-	snd_printk("codec write timeout at 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
+	snd_printk(KERN_ERR "codec write timeout at 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
 }
 
 static unsigned short snd_es1371_codec_read(ac97_t *ac97,
@@ -667,14 +667,14 @@ static unsigned short snd_es1371_codec_read(ac97_t *ac97,
 			}
 			up(&ensoniq->src_mutex);
 			if (++fail > 10) {
-				snd_printk("codec read timeout (final) at 0x%lx, reg = 0x%x [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), reg, inl(ES_REG(ensoniq, 1371_CODEC)));
+				snd_printk(KERN_ERR "codec read timeout (final) at 0x%lx, reg = 0x%x [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), reg, inl(ES_REG(ensoniq, 1371_CODEC)));
 				return 0;
 			}
 			goto __again;
 		}
 	}
 	up(&ensoniq->src_mutex);
-	snd_printk("es1371: codec read timeout at 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
+	snd_printk(KERN_ERR "es1371: codec read timeout at 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
 	return 0;
 }
 
@@ -1960,7 +1960,7 @@ static int __devinit snd_ensoniq_create(snd_card_t * card,
 	}
 	ensoniq->port = pci_resource_start(pci, 0);
 	if (request_irq(pci->irq, snd_audiopci_interrupt, SA_INTERRUPT|SA_SHIRQ, "Ensoniq AudioPCI", (void *)ensoniq)) {
-		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_ensoniq_free(ensoniq);
 		return -EBUSY;
 	}
@@ -1968,7 +1968,7 @@ static int __devinit snd_ensoniq_create(snd_card_t * card,
 #ifdef CHIP1370
 	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
 				16, &ensoniq->dma_bug) < 0) {
-		snd_printk("unable to allocate space for phantom area - dma_bug\n");
+		snd_printk(KERN_ERR "unable to allocate space for phantom area - dma_bug\n");
 		snd_ensoniq_free(ensoniq);
 		return -EBUSY;
 	}

commit 3bcd4649bca99ee9242f20d7da35e3f8741c6549
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 12 08:20:54 2005 +0200

    [ALSA] set owner field in struct pci_driver
    
    AD1889 driver,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CS46xx driver,EMU10K1/EMU10K2 driver
    HDA Intel driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    MIXART driver,NM256 driver,RME HDSP driver,RME9652 driver
    Trident driver,Digigram VX222 driver,YMFPCI driver
    Set the module owner field in each driver's struct pci_driver to get
    the driver symlink in the sysfs device directory.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index a38f7102eccf..bef9a59f46d7 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2387,6 +2387,7 @@ static void __devexit snd_audiopci_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = DRIVER_NAME,
+	.owner = THIS_MODULE,
 	.id_table = snd_audiopci_ids,
 	.probe = snd_audiopci_probe,
 	.remove = __devexit_p(snd_audiopci_remove),

commit e560d8d8368ad8b6161839984b253de622863265
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:21:46 2005 +0200

    [ALSA] Replace with kzalloc() - pci stuff
    
    AD1889 driver,ATIIXP driver,ATIIXP-modem driver,AZT3328 driver
    BT87x driver,CMIPCI driver,CS4281 driver,ENS1370/1+ driver
    ES1938 driver,ES1968 driver,FM801 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,SonicVibes driver,VIA82xx driver
    VIA82xx-modem driver,AC97 Codec,AK4531 codec,au88x0 driver
    CA0106 driver,CS46xx driver,EMU10K1/EMU10K2 driver,HDA Codec driver
    HDA generic driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,Trident driver,YMFPCI driver
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index e2c3a375855e..a38f7102eccf 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1943,7 +1943,7 @@ static int __devinit snd_ensoniq_create(snd_card_t * card,
 	*rensoniq = NULL;
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
-	ensoniq = kcalloc(1, sizeof(*ensoniq), GFP_KERNEL);
+	ensoniq = kzalloc(sizeof(*ensoniq), GFP_KERNEL);
 	if (ensoniq == NULL) {
 		pci_disable_device(pci);
 		return -ENOMEM;

commit 8cdfd2519c6c9a1e6057dc5970b2542b35895738
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 7 14:08:11 2005 +0200

    [ALSA] Remove superfluous PCI ID definitions
    
    CS46xx driver,EMU10K1/EMU10K2 driver,PCM Midlevel,Trident driver
    YMFPCI driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,RME32 driver,RME96 driver
    SonicVibes driver,VIA82xx driver,ALI5451 driver,ICE1712 driver
    ICE1724 driver,NM256 driver,RME HDSP driver,RME9652 driver
    Remove superfluous PCI ID definitions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index f06b95f41a1d..e2c3a375855e 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -100,13 +100,6 @@ MODULE_PARM_DESC(joystick, "Enable joystick.");
 #endif
 #endif /* SUPPORT_JOYSTICK */
 
-#ifndef PCI_DEVICE_ID_ENSONIQ_CT5880
-#define PCI_DEVICE_ID_ENSONIQ_CT5880    0x5880
-#endif
-#ifndef PCI_DEVICE_ID_ENSONIQ_ES1371
-#define PCI_DEVICE_ID_ENSONIQ_ES1371	0x1371
-#endif
-
 /* ES1371 chip ID */
 /* This is a little confusing because all ES1371 compatible chips have the
    same DEVICE_ID, the only thing differentiating them is the REV_ID field.

commit 5549d54992391d81a8cbfbaac45a958876fbc9cb
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Aug 3 13:50:30 2005 +0200

    [ALSA] use PCM interface for IEC958 controls
    
    Digigram VX core,ENS1370/1+ driver,CA0106 driver,EMU10K1/EMU10K2 driver
    RME HDSP driver,RME9652 driver
    For consistency, use the PCM interface instead of MIXER for IEC958
    default/mask/stream mixer controls.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index bc8272be0031..f06b95f41a1d 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1446,7 +1446,7 @@ static int snd_es1371_spdif_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 static snd_kcontrol_new_t snd_es1371_mixer_spdif[] __devinitdata = {
 	ES1371_SPDIF(SNDRV_CTL_NAME_IEC958("",PLAYBACK,SWITCH)),
 	{
-		.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+		.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 		.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
 		.info =		snd_ens1373_spdif_info,
 		.get =		snd_ens1373_spdif_default_get,
@@ -1454,13 +1454,13 @@ static snd_kcontrol_new_t snd_es1371_mixer_spdif[] __devinitdata = {
 	},
 	{
 		.access =	SNDRV_CTL_ELEM_ACCESS_READ,
-		.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+		.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 		.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
 		.info =		snd_ens1373_spdif_info,
 		.get =		snd_ens1373_spdif_mask_get
 	},
 	{
-		.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+		.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 		.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM),
 		.info =		snd_ens1373_spdif_info,
 		.get =		snd_ens1373_spdif_stream_get,

commit 10e8d78a94fc57f1bf11d50b97ff85b005e46d0b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Aug 3 13:40:08 2005 +0200

    [ALSA] use SNDRV_CTL_NAME_IEC958 macro
    
    CMI8330 driver,ENS1370/1+ driver,FM801 driver,VIA82xx driver,AC97 Codec
    ALI5451 driver,CS46xx driver,EMU10K1/EMU10K2 driver,HDA Codec driver
    ICE1712 driver,ICE1724 driver
    Where appropriate, use the SNDRV_CTL_NAME_IEC958 instead of a literal
    string.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 0c64e65bee97..bc8272be0031 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1444,7 +1444,7 @@ static int snd_es1371_spdif_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 
 /* spdif controls */
 static snd_kcontrol_new_t snd_es1371_mixer_spdif[] __devinitdata = {
-	ES1371_SPDIF("IEC958 Playback Switch"),
+	ES1371_SPDIF(SNDRV_CTL_NAME_IEC958("",PLAYBACK,SWITCH)),
 	{
 		.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),

commit 67ed4161f60d76b3b27efc085b36357a6a90768c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Jul 29 15:32:58 2005 +0200

    [ALSA] sound - fix .iface field of mixer control elements
    
    Documentation,CS46xx driver,EMU10K1/EMU10K2 driver,AD1848 driver
    SB16/AWE driver,CMIPCI driver,ENS1370/1+ driver,RME32 driver
    RME96 driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    RME HDSP driver,RME9652 driver
    This patch changes .iface to SNDRV_CTL_ELEM_IFACE_MIXER whre _PCM or
    _HWDEP was used in controls that are not associated with a specific PCM
    (sub)stream or hwdep device, and changes some controls that got
    inconsitent .iface values due to copy+paste errors.  Furthermore, it
    makes sure that all control that do use _PCM or _HWDEP use the correct
    number in the .device field.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 78a81f3912a1..0c64e65bee97 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -1446,7 +1446,7 @@ static int snd_es1371_spdif_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 static snd_kcontrol_new_t snd_es1371_mixer_spdif[] __devinitdata = {
 	ES1371_SPDIF("IEC958 Playback Switch"),
 	{
-		.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+		.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
 		.info =		snd_ens1373_spdif_info,
 		.get =		snd_ens1373_spdif_default_get,
@@ -1454,13 +1454,13 @@ static snd_kcontrol_new_t snd_es1371_mixer_spdif[] __devinitdata = {
 	},
 	{
 		.access =	SNDRV_CTL_ELEM_ACCESS_READ,
-		.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+		.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
 		.info =		snd_ens1373_spdif_info,
 		.get =		snd_ens1373_spdif_mask_get
 	},
 	{
-		.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+		.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM),
 		.info =		snd_ens1373_spdif_info,
 		.get =		snd_ens1373_spdif_stream_get,

commit ef21ca24faf28df6d06939e77d5032a313490289
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Sat Jul 9 10:13:22 2005 +0200

    [ALSA] sound/pci: fix-up sleeping paths
    
    ENS1370/1+ driver,ES1968 driver,Intel8x0 driver,VIA82xx driver
    VIA82xx-modem driver,AC97 Codec,ALI5451 driver,CS46xx driver
    MIXART driver,RME HDSP driver,Trident driver,YMFPCI driver
    Description: Fix-up sleeping in sound/pci. These changes fall under the
    following two categories:
    
            1) Replace schedule_timeout() with msleep() to guarantee the
            task delays as expected. This also involved replacing/removing
            custom sleep functions.
            2) Do not assume jiffies will only increment by one if you
            request a 1 jiffy sleep, i.e. use time_after/time_before in
            while loops.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index d4287338c042..78a81f3912a1 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2018,21 +2018,11 @@ static int __devinit snd_ensoniq_create(snd_card_t * card,
 		if (pci->vendor == es1371_ac97_reset_hack[idx].vid &&
 		    pci->device == es1371_ac97_reset_hack[idx].did &&
 		    ensoniq->rev == es1371_ac97_reset_hack[idx].rev) {
-		        unsigned long tmo;
-			signed long tmo2;
-
 			ensoniq->cssr |= ES_1371_ST_AC97_RST;
 			outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
 			/* need to delay around 20ms(bleech) to give
 			some CODECs enough time to wakeup */
-			tmo = jiffies + (HZ / 50) + 1;
-			while (1) {
-				tmo2 = tmo - jiffies;
-				if (tmo2 <= 0)
-					break;
-				set_current_state(TASK_UNINTERRUPTIBLE);
-				schedule_timeout(tmo2);
-			}
+			msleep(20);
 			break;
 		}
 	/* AC'97 warm reset to start the bitclk */

commit 072c01194df6e4843582d09380b780987f642d6d
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Sat Jul 9 10:07:55 2005 +0200

    [ALSA] ens1371 - added extra delay for ac97 codec initialization
    
    ENS1370/1+ driver
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index 4e63498a58b2..d4287338c042 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -685,6 +685,15 @@ static unsigned short snd_es1371_codec_read(ac97_t *ac97,
 	return 0;
 }
 
+static void snd_es1371_codec_wait(ac97_t *ac97)
+{
+	msleep(750);
+	snd_es1371_codec_read(ac97, AC97_RESET);
+	snd_es1371_codec_read(ac97, AC97_VENDOR_ID1);
+	snd_es1371_codec_read(ac97, AC97_VENDOR_ID2);
+	msleep(50);
+}
+
 static void snd_es1371_adc_rate(ensoniq_t * ensoniq, unsigned int rate)
 {
 	unsigned int n, truncm, freq, result;
@@ -1585,6 +1594,7 @@ static int snd_ensoniq_1371_mixer(ensoniq_t * ensoniq)
 	static ac97_bus_ops_t ops = {
 		.write = snd_es1371_codec_write,
 		.read = snd_es1371_codec_read,
+		.wait = snd_es1371_codec_wait,
 	};
 
 	if ((err = snd_ac97_bus(card, 0, &ops, NULL, &pbus)) < 0)

commit 01d25d460a3b28aab537fab9a0038d1b5832ce28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 11 16:58:24 2005 +0200

    [ALSA] Replace pci_module_init() with pci_register_driver()
    
    Documentation,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CA0106 driver,CS46xx driver
    EMU10K1/EMU10K2 driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,RME HDSP driver
    RME9652 driver,Trident driver,Digigram VX222 driver,YMFPCI driver
    Replace the obsolete pci_module_init() with pci_register_driver().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
index f910399db5c3..4e63498a58b2 100644
--- a/sound/pci/ens1370.c
+++ b/sound/pci/ens1370.c
@@ -2401,7 +2401,7 @@ static struct pci_driver driver = {
 	
 static int __init alsa_card_ens137x_init(void)
 {
-	return pci_module_init(&driver);
+	return pci_register_driver(&driver);
 }
 
 static void __exit alsa_card_ens137x_exit(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/ens1370.c b/sound/pci/ens1370.c
new file mode 100644
index 000000000000..f910399db5c3
--- /dev/null
+++ b/sound/pci/ens1370.c
@@ -0,0 +1,2413 @@
+/*
+ *  Driver for Ensoniq ES1370/ES1371 AudioPCI soundcard
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>,
+ *		     Thomas Sailer <sailer@ife.ee.ethz.ch>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/gameport.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/rawmidi.h>
+#ifdef CHIP1371
+#include <sound/ac97_codec.h>
+#else
+#include <sound/ak4531_codec.h>
+#endif
+#include <sound/initval.h>
+#include <sound/asoundef.h>
+
+#ifndef CHIP1371
+#undef CHIP1370
+#define CHIP1370
+#endif
+
+#ifdef CHIP1370
+#define DRIVER_NAME "ENS1370"
+#else
+#define DRIVER_NAME "ENS1371"
+#endif
+
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>, Thomas Sailer <sailer@ife.ee.ethz.ch>");
+MODULE_LICENSE("GPL");
+#ifdef CHIP1370
+MODULE_DESCRIPTION("Ensoniq AudioPCI ES1370");
+MODULE_SUPPORTED_DEVICE("{{Ensoniq,AudioPCI-97 ES1370},"
+	        "{Creative Labs,SB PCI64/128 (ES1370)}}");
+#endif
+#ifdef CHIP1371
+MODULE_DESCRIPTION("Ensoniq/Creative AudioPCI ES1371+");
+MODULE_SUPPORTED_DEVICE("{{Ensoniq,AudioPCI ES1371/73},"
+		"{Ensoniq,AudioPCI ES1373},"
+		"{Creative Labs,Ectiva EV1938},"
+		"{Creative Labs,SB PCI64/128 (ES1371/73)},"
+		"{Creative Labs,Vibra PCI128},"
+		"{Ectiva,EV1938}}");
+#endif
+
+#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+#define SUPPORT_JOYSTICK
+#endif
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
+#ifdef SUPPORT_JOYSTICK
+#ifdef CHIP1371
+static int joystick_port[SNDRV_CARDS];
+#else
+static int joystick[SNDRV_CARDS];
+#endif
+#endif
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for Ensoniq AudioPCI soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for Ensoniq AudioPCI soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable Ensoniq AudioPCI soundcard.");
+#ifdef SUPPORT_JOYSTICK
+#ifdef CHIP1371
+module_param_array(joystick_port, int, NULL, 0444);
+MODULE_PARM_DESC(joystick_port, "Joystick port address.");
+#else
+module_param_array(joystick, bool, NULL, 0444);
+MODULE_PARM_DESC(joystick, "Enable joystick.");
+#endif
+#endif /* SUPPORT_JOYSTICK */
+
+#ifndef PCI_DEVICE_ID_ENSONIQ_CT5880
+#define PCI_DEVICE_ID_ENSONIQ_CT5880    0x5880
+#endif
+#ifndef PCI_DEVICE_ID_ENSONIQ_ES1371
+#define PCI_DEVICE_ID_ENSONIQ_ES1371	0x1371
+#endif
+
+/* ES1371 chip ID */
+/* This is a little confusing because all ES1371 compatible chips have the
+   same DEVICE_ID, the only thing differentiating them is the REV_ID field.
+   This is only significant if you want to enable features on the later parts.
+   Yes, I know it's stupid and why didn't we use the sub IDs?
+*/
+#define ES1371REV_ES1373_A  0x04
+#define ES1371REV_ES1373_B  0x06
+#define ES1371REV_CT5880_A  0x07
+#define CT5880REV_CT5880_C  0x02
+#define CT5880REV_CT5880_D  0x03	/* ??? -jk */
+#define CT5880REV_CT5880_E  0x04	/* mw */
+#define ES1371REV_ES1371_B  0x09
+#define EV1938REV_EV1938_A  0x00
+#define ES1371REV_ES1373_8  0x08
+
+/*
+ * Direct registers
+ */
+
+#define ES_REG(ensoniq, x) ((ensoniq)->port + ES_REG_##x)
+
+#define ES_REG_CONTROL	0x00	/* R/W: Interrupt/Chip select control register */
+#define   ES_1370_ADC_STOP	(1<<31)		/* disable capture buffer transfers */
+#define   ES_1370_XCTL1 	(1<<30)		/* general purpose output bit */
+#define   ES_1373_BYPASS_P1	(1<<31)		/* bypass SRC for PB1 */
+#define   ES_1373_BYPASS_P2	(1<<30)		/* bypass SRC for PB2 */
+#define   ES_1373_BYPASS_R	(1<<29)		/* bypass SRC for REC */
+#define   ES_1373_TEST_BIT	(1<<28)		/* should be set to 0 for normal operation */
+#define   ES_1373_RECEN_B	(1<<27)		/* mix record with playback for I2S/SPDIF out */
+#define   ES_1373_SPDIF_THRU	(1<<26)		/* 0 = SPDIF thru mode, 1 = SPDIF == dig out */
+#define   ES_1371_JOY_ASEL(o)	(((o)&0x03)<<24)/* joystick port mapping */
+#define   ES_1371_JOY_ASELM	(0x03<<24)	/* mask for above */
+#define   ES_1371_JOY_ASELI(i)  (((i)>>24)&0x03)
+#define   ES_1371_GPIO_IN(i)	(((i)>>20)&0x0f)/* GPIO in [3:0] pins - R/O */
+#define   ES_1370_PCLKDIVO(o)	(((o)&0x1fff)<<16)/* clock divide ratio for DAC2 */
+#define   ES_1370_PCLKDIVM	((0x1fff)<<16)	/* mask for above */
+#define   ES_1370_PCLKDIVI(i)	(((i)>>16)&0x1fff)/* clock divide ratio for DAC2 */
+#define   ES_1371_GPIO_OUT(o)	(((o)&0x0f)<<16)/* GPIO out [3:0] pins - W/R */
+#define   ES_1371_GPIO_OUTM     (0x0f<<16)	/* mask for above */
+#define   ES_MSFMTSEL		(1<<15)		/* MPEG serial data format; 0 = SONY, 1 = I2S */
+#define   ES_1370_M_SBB		(1<<14)		/* clock source for DAC - 0 = clock generator; 1 = MPEG clocks */
+#define   ES_1371_SYNC_RES	(1<<14)		/* Warm AC97 reset */
+#define   ES_1370_WTSRSEL(o)	(((o)&0x03)<<12)/* fixed frequency clock for DAC1 */
+#define   ES_1370_WTSRSELM	(0x03<<12)	/* mask for above */
+#define   ES_1371_ADC_STOP	(1<<13)		/* disable CCB transfer capture information */
+#define   ES_1371_PWR_INTRM	(1<<12)		/* power level change interrupts enable */
+#define   ES_1370_DAC_SYNC	(1<<11)		/* DAC's are synchronous */
+#define   ES_1371_M_CB		(1<<11)		/* capture clock source; 0 = AC'97 ADC; 1 = I2S */
+#define   ES_CCB_INTRM		(1<<10)		/* CCB voice interrupts enable */
+#define   ES_1370_M_CB		(1<<9)		/* capture clock source; 0 = ADC; 1 = MPEG */
+#define   ES_1370_XCTL0		(1<<8)		/* generap purpose output bit */
+#define   ES_1371_PDLEV(o)	(((o)&0x03)<<8)	/* current power down level */
+#define   ES_1371_PDLEVM	(0x03<<8)	/* mask for above */
+#define   ES_BREQ		(1<<7)		/* memory bus request enable */
+#define   ES_DAC1_EN		(1<<6)		/* DAC1 playback channel enable */
+#define   ES_DAC2_EN		(1<<5)		/* DAC2 playback channel enable */
+#define   ES_ADC_EN		(1<<4)		/* ADC capture channel enable */
+#define   ES_UART_EN		(1<<3)		/* UART enable */
+#define   ES_JYSTK_EN		(1<<2)		/* Joystick module enable */
+#define   ES_1370_CDC_EN	(1<<1)		/* Codec interface enable */
+#define   ES_1371_XTALCKDIS	(1<<1)		/* Xtal clock disable */
+#define   ES_1370_SERR_DISABLE	(1<<0)		/* PCI serr signal disable */
+#define   ES_1371_PCICLKDIS     (1<<0)		/* PCI clock disable */
+#define ES_REG_STATUS	0x04	/* R/O: Interrupt/Chip select status register */
+#define   ES_INTR               (1<<31)		/* Interrupt is pending */
+#define   ES_1371_ST_AC97_RST	(1<<29)		/* CT5880 AC'97 Reset bit */
+#define   ES_1373_REAR_BIT27	(1<<27)		/* rear bits: 000 - front, 010 - mirror, 101 - separate */
+#define   ES_1373_REAR_BIT26	(1<<26)
+#define   ES_1373_REAR_BIT24	(1<<24)
+#define   ES_1373_GPIO_INT_EN(o)(((o)&0x0f)<<20)/* GPIO [3:0] pins - interrupt enable */
+#define   ES_1373_SPDIF_EN	(1<<18)		/* SPDIF enable */
+#define   ES_1373_SPDIF_TEST	(1<<17)		/* SPDIF test */
+#define   ES_1371_TEST          (1<<16)		/* test ASIC */
+#define   ES_1373_GPIO_INT(i)	(((i)&0x0f)>>12)/* GPIO [3:0] pins - interrupt pending */
+#define   ES_1370_CSTAT		(1<<10)		/* CODEC is busy or register write in progress */
+#define   ES_1370_CBUSY         (1<<9)		/* CODEC is busy */
+#define   ES_1370_CWRIP		(1<<8)		/* CODEC register write in progress */
+#define   ES_1371_SYNC_ERR	(1<<8)		/* CODEC synchronization error occurred */
+#define   ES_1371_VC(i)         (((i)>>6)&0x03)	/* voice code from CCB module */
+#define   ES_1370_VC(i)		(((i)>>5)&0x03)	/* voice code from CCB module */
+#define   ES_1371_MPWR          (1<<5)		/* power level interrupt pending */
+#define   ES_MCCB		(1<<4)		/* CCB interrupt pending */
+#define   ES_UART		(1<<3)		/* UART interrupt pending */
+#define   ES_DAC1		(1<<2)		/* DAC1 channel interrupt pending */
+#define   ES_DAC2		(1<<1)		/* DAC2 channel interrupt pending */
+#define   ES_ADC		(1<<0)		/* ADC channel interrupt pending */
+#define ES_REG_UART_DATA 0x08	/* R/W: UART data register */
+#define ES_REG_UART_STATUS 0x09	/* R/O: UART status register */
+#define   ES_RXINT		(1<<7)		/* RX interrupt occurred */
+#define   ES_TXINT		(1<<2)		/* TX interrupt occurred */
+#define   ES_TXRDY		(1<<1)		/* transmitter ready */
+#define   ES_RXRDY		(1<<0)		/* receiver ready */
+#define ES_REG_UART_CONTROL 0x09	/* W/O: UART control register */
+#define   ES_RXINTEN		(1<<7)		/* RX interrupt enable */
+#define   ES_TXINTENO(o)	(((o)&0x03)<<5)	/* TX interrupt enable */
+#define   ES_TXINTENM		(0x03<<5)	/* mask for above */
+#define   ES_TXINTENI(i)	(((i)>>5)&0x03)
+#define   ES_CNTRL(o)		(((o)&0x03)<<0)	/* control */
+#define   ES_CNTRLM		(0x03<<0)	/* mask for above */
+#define ES_REG_UART_RES	0x0a	/* R/W: UART reserver register */
+#define   ES_TEST_MODE		(1<<0)		/* test mode enabled */
+#define ES_REG_MEM_PAGE	0x0c	/* R/W: Memory page register */
+#define   ES_MEM_PAGEO(o)	(((o)&0x0f)<<0)	/* memory page select - out */
+#define   ES_MEM_PAGEM		(0x0f<<0)	/* mask for above */
+#define   ES_MEM_PAGEI(i)	(((i)>>0)&0x0f) /* memory page select - in */
+#define ES_REG_1370_CODEC 0x10	/* W/O: Codec write register address */
+#define   ES_1370_CODEC_WRITE(a,d) ((((a)&0xff)<<8)|(((d)&0xff)<<0))
+#define ES_REG_1371_CODEC 0x14	/* W/R: Codec Read/Write register address */
+#define   ES_1371_CODEC_RDY	   (1<<31)	/* codec ready */
+#define   ES_1371_CODEC_WIP	   (1<<30)	/* codec register access in progress */
+#define   ES_1371_CODEC_PIRD	   (1<<23)	/* codec read/write select register */
+#define   ES_1371_CODEC_WRITE(a,d) ((((a)&0x7f)<<16)|(((d)&0xffff)<<0))
+#define   ES_1371_CODEC_READS(a)   ((((a)&0x7f)<<16)|ES_1371_CODEC_PIRD)
+#define   ES_1371_CODEC_READ(i)    (((i)>>0)&0xffff)
+
+#define ES_REG_1371_SMPRATE 0x10	/* W/R: Codec rate converter interface register */
+#define   ES_1371_SRC_RAM_ADDRO(o) (((o)&0x7f)<<25)/* address of the sample rate converter */
+#define   ES_1371_SRC_RAM_ADDRM	   (0x7f<<25)	/* mask for above */
+#define   ES_1371_SRC_RAM_ADDRI(i) (((i)>>25)&0x7f)/* address of the sample rate converter */
+#define   ES_1371_SRC_RAM_WE	   (1<<24)	/* R/W: read/write control for sample rate converter */
+#define   ES_1371_SRC_RAM_BUSY     (1<<23)	/* R/O: sample rate memory is busy */
+#define   ES_1371_SRC_DISABLE      (1<<22)	/* sample rate converter disable */
+#define   ES_1371_DIS_P1	   (1<<21)	/* playback channel 1 accumulator update disable */
+#define   ES_1371_DIS_P2	   (1<<20)	/* playback channel 1 accumulator update disable */
+#define   ES_1371_DIS_R1	   (1<<19)	/* capture channel accumulator update disable */
+#define   ES_1371_SRC_RAM_DATAO(o) (((o)&0xffff)<<0)/* current value of the sample rate converter */
+#define   ES_1371_SRC_RAM_DATAM	   (0xffff<<0)	/* mask for above */
+#define   ES_1371_SRC_RAM_DATAI(i) (((i)>>0)&0xffff)/* current value of the sample rate converter */
+
+#define ES_REG_1371_LEGACY 0x18	/* W/R: Legacy control/status register */
+#define   ES_1371_JFAST		(1<<31)		/* fast joystick timing */
+#define   ES_1371_HIB		(1<<30)		/* host interrupt blocking enable */
+#define   ES_1371_VSB		(1<<29)		/* SB; 0 = addr 0x220xH, 1 = 0x22FxH */
+#define   ES_1371_VMPUO(o)	(((o)&0x03)<<27)/* base register address; 0 = 0x320xH; 1 = 0x330xH; 2 = 0x340xH; 3 = 0x350xH */
+#define   ES_1371_VMPUM		(0x03<<27)	/* mask for above */
+#define   ES_1371_VMPUI(i)	(((i)>>27)&0x03)/* base register address */
+#define   ES_1371_VCDCO(o)	(((o)&0x03)<<25)/* CODEC; 0 = 0x530xH; 1 = undefined; 2 = 0xe80xH; 3 = 0xF40xH */
+#define   ES_1371_VCDCM		(0x03<<25)	/* mask for above */
+#define   ES_1371_VCDCI(i)	(((i)>>25)&0x03)/* CODEC address */
+#define   ES_1371_FIRQ		(1<<24)		/* force an interrupt */
+#define   ES_1371_SDMACAP	(1<<23)		/* enable event capture for slave DMA controller */
+#define   ES_1371_SPICAP	(1<<22)		/* enable event capture for slave IRQ controller */
+#define   ES_1371_MDMACAP	(1<<21)		/* enable event capture for master DMA controller */
+#define   ES_1371_MPICAP	(1<<20)		/* enable event capture for master IRQ controller */
+#define   ES_1371_ADCAP		(1<<19)		/* enable event capture for ADLIB register; 0x388xH */
+#define   ES_1371_SVCAP		(1<<18)		/* enable event capture for SB registers */
+#define   ES_1371_CDCCAP	(1<<17)		/* enable event capture for CODEC registers */
+#define   ES_1371_BACAP		(1<<16)		/* enable event capture for SoundScape base address */
+#define   ES_1371_EXI(i)	(((i)>>8)&0x07)	/* event number */
+#define   ES_1371_AI(i)		(((i)>>3)&0x1f)	/* event significant I/O address */
+#define   ES_1371_WR		(1<<2)	/* event capture; 0 = read; 1 = write */
+#define   ES_1371_LEGINT	(1<<0)	/* interrupt for legacy events; 0 = interrupt did occur */
+
+#define ES_REG_CHANNEL_STATUS 0x1c /* R/W: first 32-bits from S/PDIF channel status block, es1373 */
+
+#define ES_REG_SERIAL	0x20	/* R/W: Serial interface control register */
+#define   ES_1371_DAC_TEST	(1<<22)		/* DAC test mode enable */
+#define   ES_P2_END_INCO(o)	(((o)&0x07)<<19)/* binary offset value to increment / loop end */
+#define   ES_P2_END_INCM	(0x07<<19)	/* mask for above */
+#define   ES_P2_END_INCI(i)	(((i)>>16)&0x07)/* binary offset value to increment / loop end */
+#define   ES_P2_ST_INCO(o)	(((o)&0x07)<<16)/* binary offset value to increment / start */
+#define   ES_P2_ST_INCM		(0x07<<16)	/* mask for above */
+#define   ES_P2_ST_INCI(i)	(((i)<<16)&0x07)/* binary offset value to increment / start */
+#define   ES_R1_LOOP_SEL	(1<<15)		/* ADC; 0 - loop mode; 1 = stop mode */
+#define   ES_P2_LOOP_SEL	(1<<14)		/* DAC2; 0 - loop mode; 1 = stop mode */
+#define   ES_P1_LOOP_SEL	(1<<13)		/* DAC1; 0 - loop mode; 1 = stop mode */
+#define   ES_P2_PAUSE		(1<<12)		/* DAC2; 0 - play mode; 1 = pause mode */
+#define   ES_P1_PAUSE		(1<<11)		/* DAC1; 0 - play mode; 1 = pause mode */
+#define   ES_R1_INT_EN		(1<<10)		/* ADC interrupt enable */
+#define   ES_P2_INT_EN		(1<<9)		/* DAC2 interrupt enable */
+#define   ES_P1_INT_EN		(1<<8)		/* DAC1 interrupt enable */
+#define   ES_P1_SCT_RLD		(1<<7)		/* force sample counter reload for DAC1 */
+#define   ES_P2_DAC_SEN		(1<<6)		/* when stop mode: 0 - DAC2 play back zeros; 1 = DAC2 play back last sample */
+#define   ES_R1_MODEO(o)	(((o)&0x03)<<4)	/* ADC mode; 0 = 8-bit mono; 1 = 8-bit stereo; 2 = 16-bit mono; 3 = 16-bit stereo */
+#define   ES_R1_MODEM		(0x03<<4)	/* mask for above */
+#define   ES_R1_MODEI(i)	(((i)>>4)&0x03)
+#define   ES_P2_MODEO(o)	(((o)&0x03)<<2)	/* DAC2 mode; -- '' -- */
+#define   ES_P2_MODEM		(0x03<<2)	/* mask for above */
+#define   ES_P2_MODEI(i)	(((i)>>2)&0x03)
+#define   ES_P1_MODEO(o)	(((o)&0x03)<<0)	/* DAC1 mode; -- '' -- */
+#define   ES_P1_MODEM		(0x03<<0)	/* mask for above */
+#define   ES_P1_MODEI(i)	(((i)>>0)&0x03)
+
+#define ES_REG_DAC1_COUNT 0x24	/* R/W: DAC1 sample count register */
+#define ES_REG_DAC2_COUNT 0x28	/* R/W: DAC2 sample count register */
+#define ES_REG_ADC_COUNT  0x2c	/* R/W: ADC sample count register */
+#define   ES_REG_CURR_COUNT(i)  (((i)>>16)&0xffff)
+#define   ES_REG_COUNTO(o)	(((o)&0xffff)<<0)
+#define   ES_REG_COUNTM		(0xffff<<0)
+#define   ES_REG_COUNTI(i)	(((i)>>0)&0xffff)
+
+#define ES_REG_DAC1_FRAME 0x30	/* R/W: PAGE 0x0c; DAC1 frame address */
+#define ES_REG_DAC1_SIZE  0x34	/* R/W: PAGE 0x0c; DAC1 frame size */
+#define ES_REG_DAC2_FRAME 0x38	/* R/W: PAGE 0x0c; DAC2 frame address */
+#define ES_REG_DAC2_SIZE  0x3c	/* R/W: PAGE 0x0c; DAC2 frame size */
+#define ES_REG_ADC_FRAME  0x30	/* R/W: PAGE 0x0d; ADC frame address */
+#define ES_REG_ADC_SIZE	  0x34	/* R/W: PAGE 0x0d; ADC frame size */
+#define   ES_REG_FCURR_COUNTO(o) (((o)&0xffff)<<16)
+#define   ES_REG_FCURR_COUNTM    (0xffff<<16)
+#define   ES_REG_FCURR_COUNTI(i) (((i)>>14)&0x3fffc)
+#define   ES_REG_FSIZEO(o)	 (((o)&0xffff)<<0)
+#define   ES_REG_FSIZEM		 (0xffff<<0)
+#define   ES_REG_FSIZEI(i)	 (((i)>>0)&0xffff)
+#define ES_REG_PHANTOM_FRAME 0x38 /* R/W: PAGE 0x0d: phantom frame address */
+#define ES_REG_PHANTOM_COUNT 0x3c /* R/W: PAGE 0x0d: phantom frame count */
+
+#define ES_REG_UART_FIFO  0x30	/* R/W: PAGE 0x0e; UART FIFO register */
+#define   ES_REG_UF_VALID	 (1<<8)
+#define   ES_REG_UF_BYTEO(o)	 (((o)&0xff)<<0)
+#define   ES_REG_UF_BYTEM	 (0xff<<0)
+#define   ES_REG_UF_BYTEI(i)	 (((i)>>0)&0xff)
+
+
+/*
+ *  Pages
+ */
+
+#define ES_PAGE_DAC	0x0c
+#define ES_PAGE_ADC	0x0d
+#define ES_PAGE_UART	0x0e
+#define ES_PAGE_UART1	0x0f
+
+/*
+ *  Sample rate converter addresses
+ */
+
+#define ES_SMPREG_DAC1		0x70
+#define ES_SMPREG_DAC2		0x74
+#define ES_SMPREG_ADC		0x78
+#define ES_SMPREG_VOL_ADC	0x6c
+#define ES_SMPREG_VOL_DAC1	0x7c
+#define ES_SMPREG_VOL_DAC2	0x7e
+#define ES_SMPREG_TRUNC_N	0x00
+#define ES_SMPREG_INT_REGS	0x01
+#define ES_SMPREG_ACCUM_FRAC	0x02
+#define ES_SMPREG_VFREQ_FRAC	0x03
+
+/*
+ *  Some contants
+ */
+
+#define ES_1370_SRCLOCK	   1411200
+#define ES_1370_SRTODIV(x) (ES_1370_SRCLOCK/(x)-2)
+
+/*
+ *  Open modes
+ */
+
+#define ES_MODE_PLAY1	0x0001
+#define ES_MODE_PLAY2	0x0002
+#define ES_MODE_CAPTURE	0x0004
+
+#define ES_MODE_OUTPUT	0x0001	/* for MIDI */
+#define ES_MODE_INPUT	0x0002	/* for MIDI */
+
+/*
+
+ */
+
+typedef struct _snd_ensoniq ensoniq_t;
+
+struct _snd_ensoniq {
+	spinlock_t reg_lock;
+	struct semaphore src_mutex;
+
+	int irq;
+
+	unsigned long playback1size;
+	unsigned long playback2size;
+	unsigned long capture3size;
+
+	unsigned long port;
+	unsigned int mode;
+	unsigned int uartm;	/* UART mode */
+
+	unsigned int ctrl;	/* control register */
+	unsigned int sctrl;	/* serial control register */
+	unsigned int cssr;	/* control status register */
+	unsigned int uartc;	/* uart control register */
+	unsigned int rev;	/* chip revision */
+
+	union {
+#ifdef CHIP1371
+		struct {
+			ac97_t *ac97;
+		} es1371;
+#else
+		struct {
+			int pclkdiv_lock;
+			ak4531_t *ak4531;
+		} es1370;
+#endif
+	} u;
+
+	struct pci_dev *pci;
+	unsigned short subsystem_vendor_id;
+	unsigned short subsystem_device_id;
+	snd_card_t *card;
+	snd_pcm_t *pcm1;	/* DAC1/ADC PCM */
+	snd_pcm_t *pcm2;	/* DAC2 PCM */
+	snd_pcm_substream_t *playback1_substream;
+	snd_pcm_substream_t *playback2_substream;
+	snd_pcm_substream_t *capture_substream;
+	unsigned int p1_dma_size;
+	unsigned int p2_dma_size;
+	unsigned int c_dma_size;
+	unsigned int p1_period_size;
+	unsigned int p2_period_size;
+	unsigned int c_period_size;
+	snd_rawmidi_t *rmidi;
+	snd_rawmidi_substream_t *midi_input;
+	snd_rawmidi_substream_t *midi_output;
+
+	unsigned int spdif;
+	unsigned int spdif_default;
+	unsigned int spdif_stream;
+
+#ifdef CHIP1370
+	struct snd_dma_buffer dma_bug;
+#endif
+
+#ifdef SUPPORT_JOYSTICK
+	struct gameport *gameport;
+#endif
+};
+
+static irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+
+static struct pci_device_id snd_audiopci_ids[] = {
+#ifdef CHIP1370
+	{ 0x1274, 0x5000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* ES1370 */
+#endif
+#ifdef CHIP1371
+	{ 0x1274, 0x1371, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* ES1371 */
+	{ 0x1274, 0x5880, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* ES1373 - CT5880 */
+	{ 0x1102, 0x8938, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* Ectiva EV1938 */
+#endif
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, snd_audiopci_ids);
+
+/*
+ *  constants
+ */
+
+#define POLL_COUNT	0xa000
+
+#ifdef CHIP1370
+static unsigned int snd_es1370_fixed_rates[] =
+	{5512, 11025, 22050, 44100};
+static snd_pcm_hw_constraint_list_t snd_es1370_hw_constraints_rates = {
+	.count = 4, 
+	.list = snd_es1370_fixed_rates,
+	.mask = 0,
+};
+static ratnum_t es1370_clock = {
+	.num = ES_1370_SRCLOCK,
+	.den_min = 29, 
+	.den_max = 353,
+	.den_step = 1,
+};
+static snd_pcm_hw_constraint_ratnums_t snd_es1370_hw_constraints_clock = {
+	.nrats = 1,
+	.rats = &es1370_clock,
+};
+#else
+static ratden_t es1371_dac_clock = {
+	.num_min = 3000 * (1 << 15),
+	.num_max = 48000 * (1 << 15),
+	.num_step = 3000,
+	.den = 1 << 15,
+};
+static snd_pcm_hw_constraint_ratdens_t snd_es1371_hw_constraints_dac_clock = {
+	.nrats = 1,
+	.rats = &es1371_dac_clock,
+};
+static ratnum_t es1371_adc_clock = {
+	.num = 48000 << 15,
+	.den_min = 32768, 
+	.den_max = 393216,
+	.den_step = 1,
+};
+static snd_pcm_hw_constraint_ratnums_t snd_es1371_hw_constraints_adc_clock = {
+	.nrats = 1,
+	.rats = &es1371_adc_clock,
+};
+#endif
+static const unsigned int snd_ensoniq_sample_shift[] =
+	{0, 1, 1, 2};
+
+/*
+ *  common I/O routines
+ */
+
+#ifdef CHIP1371
+
+static unsigned int snd_es1371_wait_src_ready(ensoniq_t * ensoniq)
+{
+	unsigned int t, r = 0;
+
+	for (t = 0; t < POLL_COUNT; t++) {
+		r = inl(ES_REG(ensoniq, 1371_SMPRATE));
+		if ((r & ES_1371_SRC_RAM_BUSY) == 0)
+			return r;
+		cond_resched();
+	}
+	snd_printk("wait source ready timeout 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_SMPRATE), r);
+	return 0;
+}
+
+static unsigned int snd_es1371_src_read(ensoniq_t * ensoniq, unsigned short reg)
+{
+	unsigned int temp, i, orig, r;
+
+	/* wait for ready */
+	temp = orig = snd_es1371_wait_src_ready(ensoniq);
+
+	/* expose the SRC state bits */
+	r = temp & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |
+		    ES_1371_DIS_P2 | ES_1371_DIS_R1);
+	r |= ES_1371_SRC_RAM_ADDRO(reg) | 0x10000;
+	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
+
+	/* now, wait for busy and the correct time to read */
+	temp = snd_es1371_wait_src_ready(ensoniq);
+	
+	if ((temp & 0x00870000) != 0x00010000) {
+		/* wait for the right state */
+		for (i = 0; i < POLL_COUNT; i++) {
+			temp = inl(ES_REG(ensoniq, 1371_SMPRATE));
+			if ((temp & 0x00870000) == 0x00010000)
+				break;
+		}
+	}
+
+	/* hide the state bits */	
+	r = orig & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |
+		   ES_1371_DIS_P2 | ES_1371_DIS_R1);
+	r |= ES_1371_SRC_RAM_ADDRO(reg);
+	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
+	
+	return temp;
+}
+
+static void snd_es1371_src_write(ensoniq_t * ensoniq,
+				 unsigned short reg, unsigned short data)
+{
+	unsigned int r;
+
+	r = snd_es1371_wait_src_ready(ensoniq) &
+	    (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |
+	     ES_1371_DIS_P2 | ES_1371_DIS_R1);
+	r |= ES_1371_SRC_RAM_ADDRO(reg) | ES_1371_SRC_RAM_DATAO(data);
+	outl(r | ES_1371_SRC_RAM_WE, ES_REG(ensoniq, 1371_SMPRATE));
+}
+
+#endif /* CHIP1371 */
+
+#ifdef CHIP1370
+
+static void snd_es1370_codec_write(ak4531_t *ak4531,
+				   unsigned short reg, unsigned short val)
+{
+	ensoniq_t *ensoniq = ak4531->private_data;
+	unsigned long end_time = jiffies + HZ / 10;
+
+#if 0
+	printk("CODEC WRITE: reg = 0x%x, val = 0x%x (0x%x), creg = 0x%x\n", reg, val, ES_1370_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1370_CODEC));
+#endif
+	do {
+		if (!(inl(ES_REG(ensoniq, STATUS)) & ES_1370_CSTAT)) {
+			outw(ES_1370_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1370_CODEC));
+			return;
+		}
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	} while (time_after(end_time, jiffies));
+	snd_printk("codec write timeout, status = 0x%x\n", inl(ES_REG(ensoniq, STATUS)));
+}
+
+#endif /* CHIP1370 */
+
+#ifdef CHIP1371
+
+static void snd_es1371_codec_write(ac97_t *ac97,
+				   unsigned short reg, unsigned short val)
+{
+	ensoniq_t *ensoniq = ac97->private_data;
+	unsigned int t, x;
+
+	down(&ensoniq->src_mutex);
+	for (t = 0; t < POLL_COUNT; t++) {
+		if (!(inl(ES_REG(ensoniq, 1371_CODEC)) & ES_1371_CODEC_WIP)) {
+			/* save the current state for latter */
+			x = snd_es1371_wait_src_ready(ensoniq);
+			outl((x & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |
+			           ES_1371_DIS_P2 | ES_1371_DIS_R1)) | 0x00010000,
+			     ES_REG(ensoniq, 1371_SMPRATE));
+			/* wait for not busy (state 0) first to avoid
+			   transition states */
+			for (t = 0; t < POLL_COUNT; t++) {
+				if ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) == 0x00000000)
+					break;
+			}
+			/* wait for a SAFE time to write addr/data and then do it, dammit */
+			for (t = 0; t < POLL_COUNT; t++) {
+				if ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) == 0x00010000)
+					break;
+			}
+			outl(ES_1371_CODEC_WRITE(reg, val), ES_REG(ensoniq, 1371_CODEC));
+			/* restore SRC reg */
+			snd_es1371_wait_src_ready(ensoniq);
+			outl(x, ES_REG(ensoniq, 1371_SMPRATE));
+			up(&ensoniq->src_mutex);
+			return;
+		}
+	}
+	up(&ensoniq->src_mutex);
+	snd_printk("codec write timeout at 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
+}
+
+static unsigned short snd_es1371_codec_read(ac97_t *ac97,
+					    unsigned short reg)
+{
+	ensoniq_t *ensoniq = ac97->private_data;
+	unsigned int t, x, fail = 0;
+
+      __again:
+	down(&ensoniq->src_mutex);
+	for (t = 0; t < POLL_COUNT; t++) {
+		if (!(inl(ES_REG(ensoniq, 1371_CODEC)) & ES_1371_CODEC_WIP)) {
+			/* save the current state for latter */
+			x = snd_es1371_wait_src_ready(ensoniq);
+			outl((x & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 |
+			           ES_1371_DIS_P2 | ES_1371_DIS_R1)) | 0x00010000,
+			     ES_REG(ensoniq, 1371_SMPRATE));
+			/* wait for not busy (state 0) first to avoid
+			   transition states */
+			for (t = 0; t < POLL_COUNT; t++) {
+				if ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) == 0x00000000)
+					break;
+			}
+			/* wait for a SAFE time to write addr/data and then do it, dammit */
+			for (t = 0; t < POLL_COUNT; t++) {
+				if ((inl(ES_REG(ensoniq, 1371_SMPRATE)) & 0x00870000) == 0x00010000)
+					break;
+			}
+			outl(ES_1371_CODEC_READS(reg), ES_REG(ensoniq, 1371_CODEC));
+			/* restore SRC reg */
+			snd_es1371_wait_src_ready(ensoniq);
+			outl(x, ES_REG(ensoniq, 1371_SMPRATE));
+			/* wait for WIP again */
+			for (t = 0; t < POLL_COUNT; t++) {
+				if (!(inl(ES_REG(ensoniq, 1371_CODEC)) & ES_1371_CODEC_WIP))
+					break;		
+			}
+			/* now wait for the stinkin' data (RDY) */
+			for (t = 0; t < POLL_COUNT; t++) {
+				if ((x = inl(ES_REG(ensoniq, 1371_CODEC))) & ES_1371_CODEC_RDY) {
+					up(&ensoniq->src_mutex);
+					return ES_1371_CODEC_READ(x);
+				}
+			}
+			up(&ensoniq->src_mutex);
+			if (++fail > 10) {
+				snd_printk("codec read timeout (final) at 0x%lx, reg = 0x%x [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), reg, inl(ES_REG(ensoniq, 1371_CODEC)));
+				return 0;
+			}
+			goto __again;
+		}
+	}
+	up(&ensoniq->src_mutex);
+	snd_printk("es1371: codec read timeout at 0x%lx [0x%x]\n", ES_REG(ensoniq, 1371_CODEC), inl(ES_REG(ensoniq, 1371_CODEC)));
+	return 0;
+}
+
+static void snd_es1371_adc_rate(ensoniq_t * ensoniq, unsigned int rate)
+{
+	unsigned int n, truncm, freq, result;
+
+	down(&ensoniq->src_mutex);
+	n = rate / 3000;
+	if ((1 << n) & ((1 << 15) | (1 << 13) | (1 << 11) | (1 << 9)))
+		n--;
+	truncm = (21 * n - 1) | 1;
+	freq = ((48000UL << 15) / rate) * n;
+	result = (48000UL << 15) / (freq / n);
+	if (rate >= 24000) {
+		if (truncm > 239)
+			truncm = 239;
+		snd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_TRUNC_N,
+				(((239 - truncm) >> 1) << 9) | (n << 4));
+	} else {
+		if (truncm > 119)
+			truncm = 119;
+		snd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_TRUNC_N,
+				0x8000 | (((119 - truncm) >> 1) << 9) | (n << 4));
+	}
+	snd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_INT_REGS,
+			     (snd_es1371_src_read(ensoniq, ES_SMPREG_ADC + ES_SMPREG_INT_REGS) & 0x00ff) |
+				     ((freq >> 5) & 0xfc00));
+	snd_es1371_src_write(ensoniq, ES_SMPREG_ADC + ES_SMPREG_VFREQ_FRAC, freq & 0x7fff);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC, n << 8);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC + 1, n << 8);
+	up(&ensoniq->src_mutex);
+}
+
+static void snd_es1371_dac1_rate(ensoniq_t * ensoniq, unsigned int rate)
+{
+	unsigned int freq, r;
+
+	down(&ensoniq->src_mutex);
+	freq = ((rate << 15) + 1500) / 3000;
+	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE | ES_1371_DIS_P2 | ES_1371_DIS_R1)) | ES_1371_DIS_P1;
+	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
+	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_INT_REGS,
+			     (snd_es1371_src_read(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_INT_REGS) & 0x00ff) |
+			     ((freq >> 5) & 0xfc00));
+	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_VFREQ_FRAC, freq & 0x7fff);
+	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE | ES_1371_DIS_P2 | ES_1371_DIS_R1));
+	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
+	up(&ensoniq->src_mutex);
+}
+
+static void snd_es1371_dac2_rate(ensoniq_t * ensoniq, unsigned int rate)
+{
+	unsigned int freq, r;
+
+	down(&ensoniq->src_mutex);
+	freq = ((rate << 15) + 1500) / 3000;
+	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 | ES_1371_DIS_R1)) | ES_1371_DIS_P2;
+	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
+	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_INT_REGS,
+			     (snd_es1371_src_read(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_INT_REGS) & 0x00ff) |
+			     ((freq >> 5) & 0xfc00));
+	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_VFREQ_FRAC, freq & 0x7fff);
+	r = (snd_es1371_wait_src_ready(ensoniq) & (ES_1371_SRC_DISABLE | ES_1371_DIS_P1 | ES_1371_DIS_R1));
+	outl(r, ES_REG(ensoniq, 1371_SMPRATE));
+	up(&ensoniq->src_mutex);
+}
+
+#endif /* CHIP1371 */
+
+static int snd_ensoniq_trigger(snd_pcm_substream_t *substream, int cmd)
+{
+	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	{
+		unsigned int what = 0;
+		struct list_head *pos;
+		snd_pcm_substream_t *s;
+		snd_pcm_group_for_each(pos, substream) {
+			s = snd_pcm_group_substream_entry(pos);
+			if (s == ensoniq->playback1_substream) {
+				what |= ES_P1_PAUSE;
+				snd_pcm_trigger_done(s, substream);
+			} else if (s == ensoniq->playback2_substream) {
+				what |= ES_P2_PAUSE;
+				snd_pcm_trigger_done(s, substream);
+			} else if (s == ensoniq->capture_substream)
+				return -EINVAL;
+		}
+		spin_lock(&ensoniq->reg_lock);
+		if (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH)
+			ensoniq->sctrl |= what;
+		else
+			ensoniq->sctrl &= ~what;
+		outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
+		spin_unlock(&ensoniq->reg_lock);
+		break;
+	}
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_STOP:
+	{
+		unsigned int what = 0;
+		struct list_head *pos;
+		snd_pcm_substream_t *s;
+		snd_pcm_group_for_each(pos, substream) {
+			s = snd_pcm_group_substream_entry(pos);
+			if (s == ensoniq->playback1_substream) {
+				what |= ES_DAC1_EN;
+				snd_pcm_trigger_done(s, substream);
+			} else if (s == ensoniq->playback2_substream) {
+				what |= ES_DAC2_EN;
+				snd_pcm_trigger_done(s, substream);
+			} else if (s == ensoniq->capture_substream) {
+				what |= ES_ADC_EN;
+				snd_pcm_trigger_done(s, substream);
+			}
+		}
+		spin_lock(&ensoniq->reg_lock);
+		if (cmd == SNDRV_PCM_TRIGGER_START)
+			ensoniq->ctrl |= what;
+		else
+			ensoniq->ctrl &= ~what;
+		outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+		spin_unlock(&ensoniq->reg_lock);
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*
+ *  PCM part
+ */
+
+static int snd_ensoniq_hw_params(snd_pcm_substream_t * substream,
+				 snd_pcm_hw_params_t * hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+}
+
+static int snd_ensoniq_hw_free(snd_pcm_substream_t * substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int snd_ensoniq_playback1_prepare(snd_pcm_substream_t * substream)
+{
+	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned int mode = 0;
+
+	ensoniq->p1_dma_size = snd_pcm_lib_buffer_bytes(substream);
+	ensoniq->p1_period_size = snd_pcm_lib_period_bytes(substream);
+	if (snd_pcm_format_width(runtime->format) == 16)
+		mode |= 0x02;
+	if (runtime->channels > 1)
+		mode |= 0x01;
+	spin_lock_irq(&ensoniq->reg_lock);
+	ensoniq->ctrl &= ~ES_DAC1_EN;
+#ifdef CHIP1371
+	/* 48k doesn't need SRC (it breaks AC3-passthru) */
+	if (runtime->rate == 48000)
+		ensoniq->ctrl |= ES_1373_BYPASS_P1;
+	else
+		ensoniq->ctrl &= ~ES_1373_BYPASS_P1;
+#endif
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	outl(ES_MEM_PAGEO(ES_PAGE_DAC), ES_REG(ensoniq, MEM_PAGE));
+	outl(runtime->dma_addr, ES_REG(ensoniq, DAC1_FRAME));
+	outl((ensoniq->p1_dma_size >> 2) - 1, ES_REG(ensoniq, DAC1_SIZE));
+	ensoniq->sctrl &= ~(ES_P1_LOOP_SEL | ES_P1_PAUSE | ES_P1_SCT_RLD | ES_P1_MODEM);
+	ensoniq->sctrl |= ES_P1_INT_EN | ES_P1_MODEO(mode);
+	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
+	outl((ensoniq->p1_period_size >> snd_ensoniq_sample_shift[mode]) - 1, ES_REG(ensoniq, DAC1_COUNT));
+#ifdef CHIP1370
+	ensoniq->ctrl &= ~ES_1370_WTSRSELM;
+	switch (runtime->rate) {
+	case 5512: ensoniq->ctrl |= ES_1370_WTSRSEL(0); break;
+	case 11025: ensoniq->ctrl |= ES_1370_WTSRSEL(1); break;
+	case 22050: ensoniq->ctrl |= ES_1370_WTSRSEL(2); break;
+	case 44100: ensoniq->ctrl |= ES_1370_WTSRSEL(3); break;
+	default: snd_BUG();
+	}
+#endif
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	spin_unlock_irq(&ensoniq->reg_lock);
+#ifndef CHIP1370
+	snd_es1371_dac1_rate(ensoniq, runtime->rate);
+#endif
+	return 0;
+}
+
+static int snd_ensoniq_playback2_prepare(snd_pcm_substream_t * substream)
+{
+	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned int mode = 0;
+
+	ensoniq->p2_dma_size = snd_pcm_lib_buffer_bytes(substream);
+	ensoniq->p2_period_size = snd_pcm_lib_period_bytes(substream);
+	if (snd_pcm_format_width(runtime->format) == 16)
+		mode |= 0x02;
+	if (runtime->channels > 1)
+		mode |= 0x01;
+	spin_lock_irq(&ensoniq->reg_lock);
+	ensoniq->ctrl &= ~ES_DAC2_EN;
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	outl(ES_MEM_PAGEO(ES_PAGE_DAC), ES_REG(ensoniq, MEM_PAGE));
+	outl(runtime->dma_addr, ES_REG(ensoniq, DAC2_FRAME));
+	outl((ensoniq->p2_dma_size >> 2) - 1, ES_REG(ensoniq, DAC2_SIZE));
+	ensoniq->sctrl &= ~(ES_P2_LOOP_SEL | ES_P2_PAUSE | ES_P2_DAC_SEN |
+			    ES_P2_END_INCM | ES_P2_ST_INCM | ES_P2_MODEM);
+	ensoniq->sctrl |= ES_P2_INT_EN | ES_P2_MODEO(mode) |
+			  ES_P2_END_INCO(mode & 2 ? 2 : 1) | ES_P2_ST_INCO(0);
+	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
+	outl((ensoniq->p2_period_size >> snd_ensoniq_sample_shift[mode]) - 1, ES_REG(ensoniq, DAC2_COUNT));
+#ifdef CHIP1370
+	if (!(ensoniq->u.es1370.pclkdiv_lock & ES_MODE_CAPTURE)) {
+		ensoniq->ctrl &= ~ES_1370_PCLKDIVM;
+		ensoniq->ctrl |= ES_1370_PCLKDIVO(ES_1370_SRTODIV(runtime->rate));
+		ensoniq->u.es1370.pclkdiv_lock |= ES_MODE_PLAY2;
+	}
+#endif
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	spin_unlock_irq(&ensoniq->reg_lock);
+#ifndef CHIP1370
+	snd_es1371_dac2_rate(ensoniq, runtime->rate);
+#endif
+	return 0;
+}
+
+static int snd_ensoniq_capture_prepare(snd_pcm_substream_t * substream)
+{
+	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned int mode = 0;
+
+	ensoniq->c_dma_size = snd_pcm_lib_buffer_bytes(substream);
+	ensoniq->c_period_size = snd_pcm_lib_period_bytes(substream);
+	if (snd_pcm_format_width(runtime->format) == 16)
+		mode |= 0x02;
+	if (runtime->channels > 1)
+		mode |= 0x01;
+	spin_lock_irq(&ensoniq->reg_lock);
+	ensoniq->ctrl &= ~ES_ADC_EN;
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	outl(ES_MEM_PAGEO(ES_PAGE_ADC), ES_REG(ensoniq, MEM_PAGE));
+	outl(runtime->dma_addr, ES_REG(ensoniq, ADC_FRAME));
+	outl((ensoniq->c_dma_size >> 2) - 1, ES_REG(ensoniq, ADC_SIZE));
+	ensoniq->sctrl &= ~(ES_R1_LOOP_SEL | ES_R1_MODEM);
+	ensoniq->sctrl |= ES_R1_INT_EN | ES_R1_MODEO(mode);
+	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
+	outl((ensoniq->c_period_size >> snd_ensoniq_sample_shift[mode]) - 1, ES_REG(ensoniq, ADC_COUNT));
+#ifdef CHIP1370
+	if (!(ensoniq->u.es1370.pclkdiv_lock & ES_MODE_PLAY2)) {
+		ensoniq->ctrl &= ~ES_1370_PCLKDIVM;
+		ensoniq->ctrl |= ES_1370_PCLKDIVO(ES_1370_SRTODIV(runtime->rate));
+		ensoniq->u.es1370.pclkdiv_lock |= ES_MODE_CAPTURE;
+	}
+#endif
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	spin_unlock_irq(&ensoniq->reg_lock);
+#ifndef CHIP1370
+	snd_es1371_adc_rate(ensoniq, runtime->rate);
+#endif
+	return 0;
+}
+
+static snd_pcm_uframes_t snd_ensoniq_playback1_pointer(snd_pcm_substream_t * substream)
+{
+	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	size_t ptr;
+
+	spin_lock(&ensoniq->reg_lock);
+	if (inl(ES_REG(ensoniq, CONTROL)) & ES_DAC1_EN) {
+		outl(ES_MEM_PAGEO(ES_PAGE_DAC), ES_REG(ensoniq, MEM_PAGE));
+		ptr = ES_REG_FCURR_COUNTI(inl(ES_REG(ensoniq, DAC1_SIZE)));
+		ptr = bytes_to_frames(substream->runtime, ptr);
+	} else {
+		ptr = 0;
+	}
+	spin_unlock(&ensoniq->reg_lock);
+	return ptr;
+}
+
+static snd_pcm_uframes_t snd_ensoniq_playback2_pointer(snd_pcm_substream_t * substream)
+{
+	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	size_t ptr;
+
+	spin_lock(&ensoniq->reg_lock);
+	if (inl(ES_REG(ensoniq, CONTROL)) & ES_DAC2_EN) {
+		outl(ES_MEM_PAGEO(ES_PAGE_DAC), ES_REG(ensoniq, MEM_PAGE));
+		ptr = ES_REG_FCURR_COUNTI(inl(ES_REG(ensoniq, DAC2_SIZE)));
+		ptr = bytes_to_frames(substream->runtime, ptr);
+	} else {
+		ptr = 0;
+	}
+	spin_unlock(&ensoniq->reg_lock);
+	return ptr;
+}
+
+static snd_pcm_uframes_t snd_ensoniq_capture_pointer(snd_pcm_substream_t * substream)
+{
+	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	size_t ptr;
+
+	spin_lock(&ensoniq->reg_lock);
+	if (inl(ES_REG(ensoniq, CONTROL)) & ES_ADC_EN) {
+		outl(ES_MEM_PAGEO(ES_PAGE_ADC), ES_REG(ensoniq, MEM_PAGE));
+		ptr = ES_REG_FCURR_COUNTI(inl(ES_REG(ensoniq, ADC_SIZE)));
+		ptr = bytes_to_frames(substream->runtime, ptr);
+	} else {
+		ptr = 0;
+	}
+	spin_unlock(&ensoniq->reg_lock);
+	return ptr;
+}
+
+static snd_pcm_hardware_t snd_ensoniq_playback1 =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_SYNC_START),
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =
+#ifndef CHIP1370
+				SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+#else
+				(SNDRV_PCM_RATE_KNOT | 	/* 5512Hz rate */
+				 SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_22050 | 
+				 SNDRV_PCM_RATE_44100),
+#endif
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+static snd_pcm_hardware_t snd_ensoniq_playback2 =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_PAUSE | 
+				 SNDRV_PCM_INFO_SYNC_START),
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+static snd_pcm_hardware_t snd_ensoniq_capture =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START),
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+static int snd_ensoniq_playback1_open(snd_pcm_substream_t * substream)
+{
+	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	ensoniq->mode |= ES_MODE_PLAY1;
+	ensoniq->playback1_substream = substream;
+	runtime->hw = snd_ensoniq_playback1;
+	snd_pcm_set_sync(substream);
+	spin_lock_irq(&ensoniq->reg_lock);
+	if (ensoniq->spdif && ensoniq->playback2_substream == NULL)
+		ensoniq->spdif_stream = ensoniq->spdif_default;
+	spin_unlock_irq(&ensoniq->reg_lock);
+#ifdef CHIP1370
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				   &snd_es1370_hw_constraints_rates);
+#else
+	snd_pcm_hw_constraint_ratdens(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				      &snd_es1371_hw_constraints_dac_clock);
+#endif
+	return 0;
+}
+
+static int snd_ensoniq_playback2_open(snd_pcm_substream_t * substream)
+{
+	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	ensoniq->mode |= ES_MODE_PLAY2;
+	ensoniq->playback2_substream = substream;
+	runtime->hw = snd_ensoniq_playback2;
+	snd_pcm_set_sync(substream);
+	spin_lock_irq(&ensoniq->reg_lock);
+	if (ensoniq->spdif && ensoniq->playback1_substream == NULL)
+		ensoniq->spdif_stream = ensoniq->spdif_default;
+	spin_unlock_irq(&ensoniq->reg_lock);
+#ifdef CHIP1370
+	snd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				      &snd_es1370_hw_constraints_clock);
+#else
+	snd_pcm_hw_constraint_ratdens(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				      &snd_es1371_hw_constraints_dac_clock);
+#endif
+	return 0;
+}
+
+static int snd_ensoniq_capture_open(snd_pcm_substream_t * substream)
+{
+	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	ensoniq->mode |= ES_MODE_CAPTURE;
+	ensoniq->capture_substream = substream;
+	runtime->hw = snd_ensoniq_capture;
+	snd_pcm_set_sync(substream);
+#ifdef CHIP1370
+	snd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				      &snd_es1370_hw_constraints_clock);
+#else
+	snd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				      &snd_es1371_hw_constraints_adc_clock);
+#endif
+	return 0;
+}
+
+static int snd_ensoniq_playback1_close(snd_pcm_substream_t * substream)
+{
+	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+
+	ensoniq->playback1_substream = NULL;
+	ensoniq->mode &= ~ES_MODE_PLAY1;
+	return 0;
+}
+
+static int snd_ensoniq_playback2_close(snd_pcm_substream_t * substream)
+{
+	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+
+	ensoniq->playback2_substream = NULL;
+	spin_lock_irq(&ensoniq->reg_lock);
+#ifdef CHIP1370
+	ensoniq->u.es1370.pclkdiv_lock &= ~ES_MODE_PLAY2;
+#endif
+	ensoniq->mode &= ~ES_MODE_PLAY2;
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return 0;
+}
+
+static int snd_ensoniq_capture_close(snd_pcm_substream_t * substream)
+{
+	ensoniq_t *ensoniq = snd_pcm_substream_chip(substream);
+
+	ensoniq->capture_substream = NULL;
+	spin_lock_irq(&ensoniq->reg_lock);
+#ifdef CHIP1370
+	ensoniq->u.es1370.pclkdiv_lock &= ~ES_MODE_CAPTURE;
+#endif
+	ensoniq->mode &= ~ES_MODE_CAPTURE;
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return 0;
+}
+
+static snd_pcm_ops_t snd_ensoniq_playback1_ops = {
+	.open =		snd_ensoniq_playback1_open,
+	.close =	snd_ensoniq_playback1_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_ensoniq_hw_params,
+	.hw_free =	snd_ensoniq_hw_free,
+	.prepare =	snd_ensoniq_playback1_prepare,
+	.trigger =	snd_ensoniq_trigger,
+	.pointer =	snd_ensoniq_playback1_pointer,
+};
+
+static snd_pcm_ops_t snd_ensoniq_playback2_ops = {
+	.open =		snd_ensoniq_playback2_open,
+	.close =	snd_ensoniq_playback2_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_ensoniq_hw_params,
+	.hw_free =	snd_ensoniq_hw_free,
+	.prepare =	snd_ensoniq_playback2_prepare,
+	.trigger =	snd_ensoniq_trigger,
+	.pointer =	snd_ensoniq_playback2_pointer,
+};
+
+static snd_pcm_ops_t snd_ensoniq_capture_ops = {
+	.open =		snd_ensoniq_capture_open,
+	.close =	snd_ensoniq_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_ensoniq_hw_params,
+	.hw_free =	snd_ensoniq_hw_free,
+	.prepare =	snd_ensoniq_capture_prepare,
+	.trigger =	snd_ensoniq_trigger,
+	.pointer =	snd_ensoniq_capture_pointer,
+};
+
+static void snd_ensoniq_pcm_free(snd_pcm_t *pcm)
+{
+	ensoniq_t *ensoniq = pcm->private_data;
+	ensoniq->pcm1 = NULL;
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static int __devinit snd_ensoniq_pcm(ensoniq_t * ensoniq, int device, snd_pcm_t ** rpcm)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	if (rpcm)
+		*rpcm = NULL;
+#ifdef CHIP1370
+	err = snd_pcm_new(ensoniq->card, "ES1370/1", device, 1, 1, &pcm);
+#else
+	err = snd_pcm_new(ensoniq->card, "ES1371/1", device, 1, 1, &pcm);
+#endif
+	if (err < 0)
+		return err;
+
+#ifdef CHIP1370
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ensoniq_playback2_ops);
+#else
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ensoniq_playback1_ops);
+#endif
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ensoniq_capture_ops);
+
+	pcm->private_data = ensoniq;
+	pcm->private_free = snd_ensoniq_pcm_free;
+	pcm->info_flags = 0;
+#ifdef CHIP1370
+	strcpy(pcm->name, "ES1370 DAC2/ADC");
+#else
+	strcpy(pcm->name, "ES1371 DAC2/ADC");
+#endif
+	ensoniq->pcm1 = pcm;
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      snd_dma_pci_data(ensoniq->pci), 64*1024, 128*1024);
+
+	if (rpcm)
+		*rpcm = pcm;
+	return 0;
+}
+
+static void snd_ensoniq_pcm_free2(snd_pcm_t *pcm)
+{
+	ensoniq_t *ensoniq = pcm->private_data;
+	ensoniq->pcm2 = NULL;
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static int __devinit snd_ensoniq_pcm2(ensoniq_t * ensoniq, int device, snd_pcm_t ** rpcm)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	if (rpcm)
+		*rpcm = NULL;
+#ifdef CHIP1370
+	err = snd_pcm_new(ensoniq->card, "ES1370/2", device, 1, 0, &pcm);
+#else
+	err = snd_pcm_new(ensoniq->card, "ES1371/2", device, 1, 0, &pcm);
+#endif
+	if (err < 0)
+		return err;
+
+#ifdef CHIP1370
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ensoniq_playback1_ops);
+#else
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ensoniq_playback2_ops);
+#endif
+	pcm->private_data = ensoniq;
+	pcm->private_free = snd_ensoniq_pcm_free2;
+	pcm->info_flags = 0;
+#ifdef CHIP1370
+	strcpy(pcm->name, "ES1370 DAC1");
+#else
+	strcpy(pcm->name, "ES1371 DAC1");
+#endif
+	ensoniq->pcm2 = pcm;
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      snd_dma_pci_data(ensoniq->pci), 64*1024, 128*1024);
+
+	if (rpcm)
+		*rpcm = pcm;
+	return 0;
+}
+
+/*
+ *  Mixer section
+ */
+
+/*
+ * ENS1371 mixer (including SPDIF interface)
+ */
+#ifdef CHIP1371
+static int snd_ens1373_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_ens1373_spdif_default_get(snd_kcontrol_t * kcontrol,
+                                         snd_ctl_elem_value_t * ucontrol)
+{
+	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	spin_lock_irq(&ensoniq->reg_lock);
+	ucontrol->value.iec958.status[0] = (ensoniq->spdif_default >> 0) & 0xff;
+	ucontrol->value.iec958.status[1] = (ensoniq->spdif_default >> 8) & 0xff;
+	ucontrol->value.iec958.status[2] = (ensoniq->spdif_default >> 16) & 0xff;
+	ucontrol->value.iec958.status[3] = (ensoniq->spdif_default >> 24) & 0xff;
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return 0;
+}
+
+static int snd_ens1373_spdif_default_put(snd_kcontrol_t * kcontrol,
+                                         snd_ctl_elem_value_t * ucontrol)
+{
+	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change;
+
+	val = ((u32)ucontrol->value.iec958.status[0] << 0) |
+	      ((u32)ucontrol->value.iec958.status[1] << 8) |
+	      ((u32)ucontrol->value.iec958.status[2] << 16) |
+	      ((u32)ucontrol->value.iec958.status[3] << 24);
+	spin_lock_irq(&ensoniq->reg_lock);
+	change = ensoniq->spdif_default != val;
+	ensoniq->spdif_default = val;
+	if (change && ensoniq->playback1_substream == NULL && ensoniq->playback2_substream == NULL)
+		outl(val, ES_REG(ensoniq, CHANNEL_STATUS));
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return change;
+}
+
+static int snd_ens1373_spdif_mask_get(snd_kcontrol_t * kcontrol,
+                                         snd_ctl_elem_value_t * ucontrol)
+{
+	ucontrol->value.iec958.status[0] = 0xff;
+	ucontrol->value.iec958.status[1] = 0xff;
+	ucontrol->value.iec958.status[2] = 0xff;
+	ucontrol->value.iec958.status[3] = 0xff;
+	return 0;
+}
+
+static int snd_ens1373_spdif_stream_get(snd_kcontrol_t * kcontrol,
+                                         snd_ctl_elem_value_t * ucontrol)
+{
+	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	spin_lock_irq(&ensoniq->reg_lock);
+	ucontrol->value.iec958.status[0] = (ensoniq->spdif_stream >> 0) & 0xff;
+	ucontrol->value.iec958.status[1] = (ensoniq->spdif_stream >> 8) & 0xff;
+	ucontrol->value.iec958.status[2] = (ensoniq->spdif_stream >> 16) & 0xff;
+	ucontrol->value.iec958.status[3] = (ensoniq->spdif_stream >> 24) & 0xff;
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return 0;
+}
+
+static int snd_ens1373_spdif_stream_put(snd_kcontrol_t * kcontrol,
+                                        snd_ctl_elem_value_t * ucontrol)
+{
+	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change;
+
+	val = ((u32)ucontrol->value.iec958.status[0] << 0) |
+	      ((u32)ucontrol->value.iec958.status[1] << 8) |
+	      ((u32)ucontrol->value.iec958.status[2] << 16) |
+	      ((u32)ucontrol->value.iec958.status[3] << 24);
+	spin_lock_irq(&ensoniq->reg_lock);
+	change = ensoniq->spdif_stream != val;
+	ensoniq->spdif_stream = val;
+	if (change && (ensoniq->playback1_substream != NULL || ensoniq->playback2_substream != NULL))
+		outl(val, ES_REG(ensoniq, CHANNEL_STATUS));
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return change;
+}
+
+#define ES1371_SPDIF(xname) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .info = snd_es1371_spdif_info, \
+  .get = snd_es1371_spdif_get, .put = snd_es1371_spdif_put }
+
+static int snd_es1371_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+        uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+        uinfo->count = 1;
+        uinfo->value.integer.min = 0;
+        uinfo->value.integer.max = 1;
+        return 0;
+}
+
+static int snd_es1371_spdif_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	
+	spin_lock_irq(&ensoniq->reg_lock);
+	ucontrol->value.integer.value[0] = ensoniq->ctrl & ES_1373_SPDIF_THRU ? 1 : 0;
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return 0;
+}
+
+static int snd_es1371_spdif_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	unsigned int nval1, nval2;
+	int change;
+	
+	nval1 = ucontrol->value.integer.value[0] ? ES_1373_SPDIF_THRU : 0;
+	nval2 = ucontrol->value.integer.value[0] ? ES_1373_SPDIF_EN : 0;
+	spin_lock_irq(&ensoniq->reg_lock);
+	change = (ensoniq->ctrl & ES_1373_SPDIF_THRU) != nval1;
+	ensoniq->ctrl &= ~ES_1373_SPDIF_THRU;
+	ensoniq->ctrl |= nval1;
+	ensoniq->cssr &= ~ES_1373_SPDIF_EN;
+	ensoniq->cssr |= nval2;
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return change;
+}
+
+
+/* spdif controls */
+static snd_kcontrol_new_t snd_es1371_mixer_spdif[] __devinitdata = {
+	ES1371_SPDIF("IEC958 Playback Switch"),
+	{
+		.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+		.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
+		.info =		snd_ens1373_spdif_info,
+		.get =		snd_ens1373_spdif_default_get,
+		.put =		snd_ens1373_spdif_default_put,
+	},
+	{
+		.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+		.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+		.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
+		.info =		snd_ens1373_spdif_info,
+		.get =		snd_ens1373_spdif_mask_get
+	},
+	{
+		.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+		.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM),
+		.info =		snd_ens1373_spdif_info,
+		.get =		snd_ens1373_spdif_stream_get,
+		.put =		snd_ens1373_spdif_stream_put
+	},
+};
+
+
+static int snd_es1373_rear_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+        uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+        uinfo->count = 1;
+        uinfo->value.integer.min = 0;
+        uinfo->value.integer.max = 1;
+        return 0;
+}
+
+static int snd_es1373_rear_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	int val = 0;
+	
+	spin_lock_irq(&ensoniq->reg_lock);
+	if ((ensoniq->cssr & (ES_1373_REAR_BIT27|ES_1373_REAR_BIT26|ES_1373_REAR_BIT24)) == ES_1373_REAR_BIT26)
+	    	val = 1;
+	ucontrol->value.integer.value[0] = val;
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return 0;
+}
+
+static int snd_es1373_rear_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	unsigned int nval1;
+	int change;
+	
+	nval1 = ucontrol->value.integer.value[0] ? ES_1373_REAR_BIT26 : (ES_1373_REAR_BIT27|ES_1373_REAR_BIT24);
+	spin_lock_irq(&ensoniq->reg_lock);
+	change = (ensoniq->cssr & (ES_1373_REAR_BIT27|ES_1373_REAR_BIT26|ES_1373_REAR_BIT24)) != nval1;
+	ensoniq->cssr &= ~(ES_1373_REAR_BIT27|ES_1373_REAR_BIT26|ES_1373_REAR_BIT24);
+	ensoniq->cssr |= nval1;
+	outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_ens1373_rear __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		"AC97 2ch->4ch Copy Switch",
+	.info =		snd_es1373_rear_info,
+	.get =		snd_es1373_rear_get,
+	.put =		snd_es1373_rear_put,
+};
+
+static int snd_es1373_line_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_es1373_line_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	int val = 0;
+	
+	spin_lock_irq(&ensoniq->reg_lock);
+	if ((ensoniq->ctrl & ES_1371_GPIO_OUTM) >= 4)
+	    	val = 1;
+	ucontrol->value.integer.value[0] = val;
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return 0;
+}
+
+static int snd_es1373_line_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	int changed;
+	unsigned int ctrl;
+	
+	spin_lock_irq(&ensoniq->reg_lock);
+	ctrl = ensoniq->ctrl;
+	if (ucontrol->value.integer.value[0])
+		ensoniq->ctrl |= ES_1371_GPIO_OUT(4);	/* switch line-in -> rear out */
+	else
+		ensoniq->ctrl &= ~ES_1371_GPIO_OUT(4);
+	changed = (ctrl != ensoniq->ctrl);
+	if (changed)
+		outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return changed;
+}
+
+static snd_kcontrol_new_t snd_ens1373_line __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		"Line In->Rear Out Switch",
+	.info =		snd_es1373_line_info,
+	.get =		snd_es1373_line_get,
+	.put =		snd_es1373_line_put,
+};
+
+static void snd_ensoniq_mixer_free_ac97(ac97_t *ac97)
+{
+	ensoniq_t *ensoniq = ac97->private_data;
+	ensoniq->u.es1371.ac97 = NULL;
+}
+
+static struct {
+	unsigned short vid;		/* vendor ID */
+	unsigned short did;		/* device ID */
+	unsigned char rev;		/* revision */
+} es1371_spdif_present[] __devinitdata = {
+	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_C },
+	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_D },
+	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_E },
+	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_ES1371, .rev = ES1371REV_CT5880_A },
+	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_ES1371, .rev = ES1371REV_ES1373_8 },
+	{ .vid = PCI_ANY_ID, .did = PCI_ANY_ID }
+};
+
+static int snd_ensoniq_1371_mixer(ensoniq_t * ensoniq)
+{
+	snd_card_t *card = ensoniq->card;
+	ac97_bus_t *pbus;
+	ac97_template_t ac97;
+	int err, idx;
+	static ac97_bus_ops_t ops = {
+		.write = snd_es1371_codec_write,
+		.read = snd_es1371_codec_read,
+	};
+
+	if ((err = snd_ac97_bus(card, 0, &ops, NULL, &pbus)) < 0)
+		return err;
+
+	memset(&ac97, 0, sizeof(ac97));
+	ac97.private_data = ensoniq;
+	ac97.private_free = snd_ensoniq_mixer_free_ac97;
+	ac97.scaps = AC97_SCAP_AUDIO;
+	if ((err = snd_ac97_mixer(pbus, &ac97, &ensoniq->u.es1371.ac97)) < 0)
+		return err;
+	for (idx = 0; es1371_spdif_present[idx].vid != (unsigned short)PCI_ANY_ID; idx++)
+		if (ensoniq->pci->vendor == es1371_spdif_present[idx].vid &&
+		    ensoniq->pci->device == es1371_spdif_present[idx].did &&
+		    ensoniq->rev == es1371_spdif_present[idx].rev) {
+		    	snd_kcontrol_t *kctl;
+			int i, index = 0; 
+
+			ensoniq->spdif_default = ensoniq->spdif_stream = SNDRV_PCM_DEFAULT_CON_SPDIF;
+			outl(ensoniq->spdif_default, ES_REG(ensoniq, CHANNEL_STATUS));
+
+		    	if (ensoniq->u.es1371.ac97->ext_id & AC97_EI_SPDIF)
+			    	index++;
+
+			for (i = 0; i < (int)ARRAY_SIZE(snd_es1371_mixer_spdif); i++) {
+				kctl = snd_ctl_new1(&snd_es1371_mixer_spdif[i], ensoniq);
+				if (! kctl)
+					return -ENOMEM;
+				kctl->id.index = index;
+				if ((err = snd_ctl_add(card, kctl)) < 0)
+					return err;
+			}
+			break;
+		}
+	if (ensoniq->u.es1371.ac97->ext_id & AC97_EI_SDAC) {
+		/* mirror rear to front speakers */
+		ensoniq->cssr &= ~(ES_1373_REAR_BIT27|ES_1373_REAR_BIT24);
+		ensoniq->cssr |= ES_1373_REAR_BIT26;
+		err = snd_ctl_add(card, snd_ctl_new1(&snd_ens1373_rear, ensoniq));
+		if (err < 0)
+			return err;
+	}
+	if (((ensoniq->subsystem_vendor_id == 0x1274) &&
+	    (ensoniq->subsystem_device_id == 0x2000)) || /* GA-7DXR */
+	    ((ensoniq->subsystem_vendor_id == 0x1458) &&
+	    (ensoniq->subsystem_device_id == 0xa000))) { /* GA-8IEXP */
+		 err = snd_ctl_add(card, snd_ctl_new1(&snd_ens1373_line, ensoniq));
+		 if (err < 0)
+			 return err;
+	}
+
+	return 0;
+}
+
+#endif /* CHIP1371 */
+
+/* generic control callbacks for ens1370 */
+#ifdef CHIP1370
+#define ENSONIQ_CONTROL(xname, mask) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_CARD, .name = xname, .info = snd_ensoniq_control_info, \
+  .get = snd_ensoniq_control_get, .put = snd_ensoniq_control_put, \
+  .private_value = mask }
+
+static int snd_ensoniq_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+        uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+        uinfo->count = 1;
+        uinfo->value.integer.min = 0;
+        uinfo->value.integer.max = 1;
+        return 0;
+}
+
+static int snd_ensoniq_control_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	int mask = kcontrol->private_value;
+	
+	spin_lock_irq(&ensoniq->reg_lock);
+	ucontrol->value.integer.value[0] = ensoniq->ctrl & mask ? 1 : 0;
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return 0;
+}
+
+static int snd_ensoniq_control_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ensoniq_t *ensoniq = snd_kcontrol_chip(kcontrol);
+	int mask = kcontrol->private_value;
+	unsigned int nval;
+	int change;
+	
+	nval = ucontrol->value.integer.value[0] ? mask : 0;
+	spin_lock_irq(&ensoniq->reg_lock);
+	change = (ensoniq->ctrl & mask) != nval;
+	ensoniq->ctrl &= ~mask;
+	ensoniq->ctrl |= nval;
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return change;
+}
+
+/*
+ * ENS1370 mixer
+ */
+
+static snd_kcontrol_new_t snd_es1370_controls[2] __devinitdata = {
+ENSONIQ_CONTROL("PCM 0 Output also on Line-In Jack", ES_1370_XCTL0),
+ENSONIQ_CONTROL("Mic +5V bias", ES_1370_XCTL1)
+};
+
+#define ES1370_CONTROLS ARRAY_SIZE(snd_es1370_controls)
+
+static void snd_ensoniq_mixer_free_ak4531(ak4531_t *ak4531)
+{
+	ensoniq_t *ensoniq = ak4531->private_data;
+	ensoniq->u.es1370.ak4531 = NULL;
+}
+
+static int __devinit snd_ensoniq_1370_mixer(ensoniq_t * ensoniq)
+{
+	snd_card_t *card = ensoniq->card;
+	ak4531_t ak4531;
+	unsigned int idx;
+	int err;
+
+	/* try reset AK4531 */
+	outw(ES_1370_CODEC_WRITE(AK4531_RESET, 0x02), ES_REG(ensoniq, 1370_CODEC));
+	inw(ES_REG(ensoniq, 1370_CODEC));
+	udelay(100);
+	outw(ES_1370_CODEC_WRITE(AK4531_RESET, 0x03), ES_REG(ensoniq, 1370_CODEC));
+	inw(ES_REG(ensoniq, 1370_CODEC));
+	udelay(100);
+
+	memset(&ak4531, 0, sizeof(ak4531));
+	ak4531.write = snd_es1370_codec_write;
+	ak4531.private_data = ensoniq;
+	ak4531.private_free = snd_ensoniq_mixer_free_ak4531;
+	if ((err = snd_ak4531_mixer(card, &ak4531, &ensoniq->u.es1370.ak4531)) < 0)
+		return err;
+	for (idx = 0; idx < ES1370_CONTROLS; idx++) {
+		err = snd_ctl_add(card, snd_ctl_new1(&snd_es1370_controls[idx], ensoniq));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+#endif /* CHIP1370 */
+
+#ifdef SUPPORT_JOYSTICK
+
+#ifdef CHIP1371
+static int __devinit snd_ensoniq_get_joystick_port(int dev)
+{
+	switch (joystick_port[dev]) {
+	case 0: /* disabled */
+	case 1: /* auto-detect */
+	case 0x200:
+	case 0x208:
+	case 0x210:
+	case 0x218:
+		return joystick_port[dev];
+
+	default:
+		printk(KERN_ERR "ens1371: invalid joystick port %#x", joystick_port[dev]);
+		return 0;
+	}
+}
+#else
+static inline int snd_ensoniq_get_joystick_port(int dev)
+{
+	return joystick[dev] ? 0x200 : 0;
+}
+#endif
+
+static int __devinit snd_ensoniq_create_gameport(ensoniq_t *ensoniq, int dev)
+{
+	struct gameport *gp;
+	int io_port;
+
+	io_port = snd_ensoniq_get_joystick_port(dev);
+
+	switch (io_port) {
+	case 0:
+		return -ENOSYS;
+
+	case 1: /* auto_detect */
+		for (io_port = 0x200; io_port <= 0x218; io_port += 8)
+			if (request_region(io_port, 8, "ens137x: gameport"))
+				break;
+		if (io_port > 0x218) {
+			printk(KERN_WARNING "ens137x: no gameport ports available\n");
+			return -EBUSY;
+		}
+		break;
+
+	default:
+		if (!request_region(io_port, 8, "ens137x: gameport")) {
+			printk(KERN_WARNING "ens137x: gameport io port 0x%#x in use\n", io_port);
+			return -EBUSY;
+		}
+		break;
+	}
+
+	ensoniq->gameport = gp = gameport_allocate_port();
+	if (!gp) {
+		printk(KERN_ERR "ens137x: cannot allocate memory for gameport\n");
+		release_region(io_port, 8);
+		return -ENOMEM;
+	}
+
+	gameport_set_name(gp, "ES137x");
+	gameport_set_phys(gp, "pci%s/gameport0", pci_name(ensoniq->pci));
+	gameport_set_dev_parent(gp, &ensoniq->pci->dev);
+	gp->io = io_port;
+
+	ensoniq->ctrl |= ES_JYSTK_EN;
+#ifdef CHIP1371
+	ensoniq->ctrl &= ~ES_1371_JOY_ASELM;
+	ensoniq->ctrl |= ES_1371_JOY_ASEL((io_port - 0x200) / 8);
+#endif
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+
+	gameport_register_port(ensoniq->gameport);
+
+	return 0;
+}
+
+static void snd_ensoniq_free_gameport(ensoniq_t *ensoniq)
+{
+	if (ensoniq->gameport) {
+		int port = ensoniq->gameport->io;
+
+		gameport_unregister_port(ensoniq->gameport);
+		ensoniq->gameport = NULL;
+		ensoniq->ctrl &= ~ES_JYSTK_EN;
+		outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+		release_region(port, 8);
+	}
+}
+#else
+static inline int snd_ensoniq_create_gameport(ensoniq_t *ensoniq, long port) { return -ENOSYS; }
+static inline void snd_ensoniq_free_gameport(ensoniq_t *ensoniq) { }
+#endif /* SUPPORT_JOYSTICK */
+
+/*
+
+ */
+
+static void snd_ensoniq_proc_read(snd_info_entry_t *entry, 
+				  snd_info_buffer_t * buffer)
+{
+	ensoniq_t *ensoniq = entry->private_data;
+
+#ifdef CHIP1370
+	snd_iprintf(buffer, "Ensoniq AudioPCI ES1370\n\n");
+#else
+	snd_iprintf(buffer, "Ensoniq AudioPCI ES1371\n\n");
+#endif
+	snd_iprintf(buffer, "Joystick enable  : %s\n", ensoniq->ctrl & ES_JYSTK_EN ? "on" : "off");
+#ifdef CHIP1370
+	snd_iprintf(buffer, "MIC +5V bias     : %s\n", ensoniq->ctrl & ES_1370_XCTL1 ? "on" : "off");
+	snd_iprintf(buffer, "Line In to AOUT  : %s\n", ensoniq->ctrl & ES_1370_XCTL0 ? "on" : "off");
+#else
+	snd_iprintf(buffer, "Joystick port    : 0x%x\n", (ES_1371_JOY_ASELI(ensoniq->ctrl) * 8) + 0x200);
+#endif
+}
+
+static void __devinit snd_ensoniq_proc_init(ensoniq_t * ensoniq)
+{
+	snd_info_entry_t *entry;
+
+	if (! snd_card_proc_new(ensoniq->card, "audiopci", &entry))
+		snd_info_set_text_ops(entry, ensoniq, 1024, snd_ensoniq_proc_read);
+}
+
+/*
+
+ */
+
+static int snd_ensoniq_free(ensoniq_t *ensoniq)
+{
+	snd_ensoniq_free_gameport(ensoniq);
+	if (ensoniq->irq < 0)
+		goto __hw_end;
+#ifdef CHIP1370
+	outl(ES_1370_SERR_DISABLE, ES_REG(ensoniq, CONTROL));	/* switch everything off */
+	outl(0, ES_REG(ensoniq, SERIAL));	/* clear serial interface */
+#else
+	outl(0, ES_REG(ensoniq, CONTROL));	/* switch everything off */
+	outl(0, ES_REG(ensoniq, SERIAL));	/* clear serial interface */
+#endif
+	synchronize_irq(ensoniq->irq);
+	pci_set_power_state(ensoniq->pci, 3);
+      __hw_end:
+#ifdef CHIP1370
+	if (ensoniq->dma_bug.area)
+		snd_dma_free_pages(&ensoniq->dma_bug);
+#endif
+	if (ensoniq->irq >= 0)
+		free_irq(ensoniq->irq, (void *)ensoniq);
+	pci_release_regions(ensoniq->pci);
+	pci_disable_device(ensoniq->pci);
+	kfree(ensoniq);
+	return 0;
+}
+
+static int snd_ensoniq_dev_free(snd_device_t *device)
+{
+	ensoniq_t *ensoniq = device->device_data;
+	return snd_ensoniq_free(ensoniq);
+}
+
+#ifdef CHIP1371
+static struct {
+	unsigned short svid;		/* subsystem vendor ID */
+	unsigned short sdid;		/* subsystem device ID */
+} es1371_amplifier_hack[] = {
+	{ .svid = 0x107b, .sdid = 0x2150 },	/* Gateway Solo 2150 */
+	{ .svid = 0x13bd, .sdid = 0x100c },	/* EV1938 on Mebius PC-MJ100V */
+	{ .svid = 0x1102, .sdid = 0x5938 },	/* Targa Xtender300 */
+	{ .svid = 0x1102, .sdid = 0x8938 },	/* IPC Topnote G notebook */
+	{ .svid = PCI_ANY_ID, .sdid = PCI_ANY_ID }
+};
+static struct {
+	unsigned short vid;		/* vendor ID */
+	unsigned short did;		/* device ID */
+	unsigned char rev;		/* revision */
+} es1371_ac97_reset_hack[] = {
+	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_C },
+	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_D },
+	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_CT5880, .rev = CT5880REV_CT5880_E },
+	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_ES1371, .rev = ES1371REV_CT5880_A },
+	{ .vid = PCI_VENDOR_ID_ENSONIQ, .did = PCI_DEVICE_ID_ENSONIQ_ES1371, .rev = ES1371REV_ES1373_8 },
+	{ .vid = PCI_ANY_ID, .did = PCI_ANY_ID }
+};
+#endif
+
+static int __devinit snd_ensoniq_create(snd_card_t * card,
+				     struct pci_dev *pci,
+				     ensoniq_t ** rensoniq)
+{
+	ensoniq_t *ensoniq;
+	unsigned short cmdw;
+	unsigned char cmdb;
+#ifdef CHIP1371
+	int idx;
+#endif
+	int err;
+	static snd_device_ops_t ops = {
+		.dev_free =	snd_ensoniq_dev_free,
+	};
+
+	*rensoniq = NULL;
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+	ensoniq = kcalloc(1, sizeof(*ensoniq), GFP_KERNEL);
+	if (ensoniq == NULL) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+	spin_lock_init(&ensoniq->reg_lock);
+	init_MUTEX(&ensoniq->src_mutex);
+	ensoniq->card = card;
+	ensoniq->pci = pci;
+	ensoniq->irq = -1;
+	if ((err = pci_request_regions(pci, "Ensoniq AudioPCI")) < 0) {
+		kfree(ensoniq);
+		pci_disable_device(pci);
+		return err;
+	}
+	ensoniq->port = pci_resource_start(pci, 0);
+	if (request_irq(pci->irq, snd_audiopci_interrupt, SA_INTERRUPT|SA_SHIRQ, "Ensoniq AudioPCI", (void *)ensoniq)) {
+		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_ensoniq_free(ensoniq);
+		return -EBUSY;
+	}
+	ensoniq->irq = pci->irq;
+#ifdef CHIP1370
+	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
+				16, &ensoniq->dma_bug) < 0) {
+		snd_printk("unable to allocate space for phantom area - dma_bug\n");
+		snd_ensoniq_free(ensoniq);
+		return -EBUSY;
+	}
+#endif
+	pci_set_master(pci);
+	pci_read_config_byte(pci, PCI_REVISION_ID, &cmdb);
+	ensoniq->rev = cmdb;
+	pci_read_config_word(pci, PCI_SUBSYSTEM_VENDOR_ID, &cmdw);
+	ensoniq->subsystem_vendor_id = cmdw;
+	pci_read_config_word(pci, PCI_SUBSYSTEM_ID, &cmdw);
+	ensoniq->subsystem_device_id = cmdw;
+#ifdef CHIP1370
+#if 0
+	ensoniq->ctrl = ES_1370_CDC_EN | ES_1370_SERR_DISABLE | ES_1370_PCLKDIVO(ES_1370_SRTODIV(8000));
+#else	/* get microphone working */
+	ensoniq->ctrl = ES_1370_CDC_EN | ES_1370_PCLKDIVO(ES_1370_SRTODIV(8000));
+#endif
+	ensoniq->sctrl = 0;
+	/* initialize the chips */
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
+	outl(ES_MEM_PAGEO(ES_PAGE_ADC), ES_REG(ensoniq, MEM_PAGE));
+	outl(ensoniq->dma_bug.addr, ES_REG(ensoniq, PHANTOM_FRAME));
+	outl(0, ES_REG(ensoniq, PHANTOM_COUNT));
+#else
+	ensoniq->ctrl = 0;
+	ensoniq->sctrl = 0;
+	ensoniq->cssr = 0;
+	for (idx = 0; es1371_amplifier_hack[idx].svid != (unsigned short)PCI_ANY_ID; idx++)
+		if (ensoniq->subsystem_vendor_id == es1371_amplifier_hack[idx].svid &&
+		    ensoniq->subsystem_device_id == es1371_amplifier_hack[idx].sdid) {
+			ensoniq->ctrl |= ES_1371_GPIO_OUT(1);	/* turn amplifier on */
+			break;
+		}
+	/* initialize the chips */
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
+	outl(0, ES_REG(ensoniq, 1371_LEGACY));
+	for (idx = 0; es1371_ac97_reset_hack[idx].vid != (unsigned short)PCI_ANY_ID; idx++)
+		if (pci->vendor == es1371_ac97_reset_hack[idx].vid &&
+		    pci->device == es1371_ac97_reset_hack[idx].did &&
+		    ensoniq->rev == es1371_ac97_reset_hack[idx].rev) {
+		        unsigned long tmo;
+			signed long tmo2;
+
+			ensoniq->cssr |= ES_1371_ST_AC97_RST;
+			outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
+			/* need to delay around 20ms(bleech) to give
+			some CODECs enough time to wakeup */
+			tmo = jiffies + (HZ / 50) + 1;
+			while (1) {
+				tmo2 = tmo - jiffies;
+				if (tmo2 <= 0)
+					break;
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				schedule_timeout(tmo2);
+			}
+			break;
+		}
+	/* AC'97 warm reset to start the bitclk */
+	outl(ensoniq->ctrl | ES_1371_SYNC_RES, ES_REG(ensoniq, CONTROL));
+	inl(ES_REG(ensoniq, CONTROL));
+	udelay(20);
+	outl(ensoniq->ctrl, ES_REG(ensoniq, CONTROL));
+	/* Init the sample rate converter */
+	snd_es1371_wait_src_ready(ensoniq);	
+	outl(ES_1371_SRC_DISABLE, ES_REG(ensoniq, 1371_SMPRATE));
+	for (idx = 0; idx < 0x80; idx++)
+		snd_es1371_src_write(ensoniq, idx, 0);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_TRUNC_N, 16 << 4);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC1 + ES_SMPREG_INT_REGS, 16 << 10);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_TRUNC_N, 16 << 4);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_DAC2 + ES_SMPREG_INT_REGS, 16 << 10);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC, 1 << 12);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_ADC + 1, 1 << 12);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC1, 1 << 12);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC1 + 1, 1 << 12);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC2, 1 << 12);
+	snd_es1371_src_write(ensoniq, ES_SMPREG_VOL_DAC2 + 1, 1 << 12);
+	snd_es1371_adc_rate(ensoniq, 22050);
+	snd_es1371_dac1_rate(ensoniq, 22050);
+	snd_es1371_dac2_rate(ensoniq, 22050);
+	/* WARNING:
+	 * enabling the sample rate converter without properly programming
+	 * its parameters causes the chip to lock up (the SRC busy bit will
+	 * be stuck high, and I've found no way to rectify this other than
+	 * power cycle) - Thomas Sailer
+	 */
+	snd_es1371_wait_src_ready(ensoniq);
+	outl(0, ES_REG(ensoniq, 1371_SMPRATE));
+	/* try reset codec directly */
+	outl(ES_1371_CODEC_WRITE(0, 0), ES_REG(ensoniq, 1371_CODEC));
+#endif
+	outb(ensoniq->uartc = 0x00, ES_REG(ensoniq, UART_CONTROL));
+	outb(0x00, ES_REG(ensoniq, UART_RES));
+	outl(ensoniq->cssr, ES_REG(ensoniq, STATUS));
+	synchronize_irq(ensoniq->irq);
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, ensoniq, &ops)) < 0) {
+		snd_ensoniq_free(ensoniq);
+		return err;
+	}
+
+	snd_ensoniq_proc_init(ensoniq);
+
+	snd_card_set_dev(card, &pci->dev);
+
+	*rensoniq = ensoniq;
+	return 0;
+}
+
+/*
+ *  MIDI section
+ */
+
+static void snd_ensoniq_midi_interrupt(ensoniq_t * ensoniq)
+{
+	snd_rawmidi_t * rmidi = ensoniq->rmidi;
+	unsigned char status, mask, byte;
+
+	if (rmidi == NULL)
+		return;
+	/* do Rx at first */
+	spin_lock(&ensoniq->reg_lock);
+	mask = ensoniq->uartm & ES_MODE_INPUT ? ES_RXRDY : 0;
+	while (mask) {
+		status = inb(ES_REG(ensoniq, UART_STATUS));
+		if ((status & mask) == 0)
+			break;
+		byte = inb(ES_REG(ensoniq, UART_DATA));
+		snd_rawmidi_receive(ensoniq->midi_input, &byte, 1);
+	}
+	spin_unlock(&ensoniq->reg_lock);
+
+	/* do Tx at second */
+	spin_lock(&ensoniq->reg_lock);
+	mask = ensoniq->uartm & ES_MODE_OUTPUT ? ES_TXRDY : 0;
+	while (mask) {
+		status = inb(ES_REG(ensoniq, UART_STATUS));
+		if ((status & mask) == 0)
+			break;
+		if (snd_rawmidi_transmit(ensoniq->midi_output, &byte, 1) != 1) {
+			ensoniq->uartc &= ~ES_TXINTENM;
+			outb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));
+			mask &= ~ES_TXRDY;
+		} else {
+			outb(byte, ES_REG(ensoniq, UART_DATA));
+		}
+	}
+	spin_unlock(&ensoniq->reg_lock);
+}
+
+static int snd_ensoniq_midi_input_open(snd_rawmidi_substream_t * substream)
+{
+	ensoniq_t *ensoniq = substream->rmidi->private_data;
+
+	spin_lock_irq(&ensoniq->reg_lock);
+	ensoniq->uartm |= ES_MODE_INPUT;
+	ensoniq->midi_input = substream;
+	if (!(ensoniq->uartm & ES_MODE_OUTPUT)) {
+		outb(ES_CNTRL(3), ES_REG(ensoniq, UART_CONTROL));
+		outb(ensoniq->uartc = 0, ES_REG(ensoniq, UART_CONTROL));
+		outl(ensoniq->ctrl |= ES_UART_EN, ES_REG(ensoniq, CONTROL));
+	}
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return 0;
+}
+
+static int snd_ensoniq_midi_input_close(snd_rawmidi_substream_t * substream)
+{
+	ensoniq_t *ensoniq = substream->rmidi->private_data;
+
+	spin_lock_irq(&ensoniq->reg_lock);
+	if (!(ensoniq->uartm & ES_MODE_OUTPUT)) {
+		outb(ensoniq->uartc = 0, ES_REG(ensoniq, UART_CONTROL));
+		outl(ensoniq->ctrl &= ~ES_UART_EN, ES_REG(ensoniq, CONTROL));
+	} else {
+		outb(ensoniq->uartc &= ~ES_RXINTEN, ES_REG(ensoniq, UART_CONTROL));
+	}
+	ensoniq->midi_input = NULL;
+	ensoniq->uartm &= ~ES_MODE_INPUT;
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return 0;
+}
+
+static int snd_ensoniq_midi_output_open(snd_rawmidi_substream_t * substream)
+{
+	ensoniq_t *ensoniq = substream->rmidi->private_data;
+
+	spin_lock_irq(&ensoniq->reg_lock);
+	ensoniq->uartm |= ES_MODE_OUTPUT;
+	ensoniq->midi_output = substream;
+	if (!(ensoniq->uartm & ES_MODE_INPUT)) {
+		outb(ES_CNTRL(3), ES_REG(ensoniq, UART_CONTROL));
+		outb(ensoniq->uartc = 0, ES_REG(ensoniq, UART_CONTROL));
+		outl(ensoniq->ctrl |= ES_UART_EN, ES_REG(ensoniq, CONTROL));
+	}
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return 0;
+}
+
+static int snd_ensoniq_midi_output_close(snd_rawmidi_substream_t * substream)
+{
+	ensoniq_t *ensoniq = substream->rmidi->private_data;
+
+	spin_lock_irq(&ensoniq->reg_lock);
+	if (!(ensoniq->uartm & ES_MODE_INPUT)) {
+		outb(ensoniq->uartc = 0, ES_REG(ensoniq, UART_CONTROL));
+		outl(ensoniq->ctrl &= ~ES_UART_EN, ES_REG(ensoniq, CONTROL));
+	} else {
+		outb(ensoniq->uartc &= ~ES_TXINTENM, ES_REG(ensoniq, UART_CONTROL));
+	}
+	ensoniq->midi_output = NULL;
+	ensoniq->uartm &= ~ES_MODE_OUTPUT;
+	spin_unlock_irq(&ensoniq->reg_lock);
+	return 0;
+}
+
+static void snd_ensoniq_midi_input_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	unsigned long flags;
+	ensoniq_t *ensoniq = substream->rmidi->private_data;
+	int idx;
+
+	spin_lock_irqsave(&ensoniq->reg_lock, flags);
+	if (up) {
+		if ((ensoniq->uartc & ES_RXINTEN) == 0) {
+			/* empty input FIFO */
+			for (idx = 0; idx < 32; idx++)
+				inb(ES_REG(ensoniq, UART_DATA));
+			ensoniq->uartc |= ES_RXINTEN;
+			outb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));
+		}
+	} else {
+		if (ensoniq->uartc & ES_RXINTEN) {
+			ensoniq->uartc &= ~ES_RXINTEN;
+			outb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));
+		}
+	}
+	spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
+}
+
+static void snd_ensoniq_midi_output_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	unsigned long flags;
+	ensoniq_t *ensoniq = substream->rmidi->private_data;
+	unsigned char byte;
+
+	spin_lock_irqsave(&ensoniq->reg_lock, flags);
+	if (up) {
+		if (ES_TXINTENI(ensoniq->uartc) == 0) {
+			ensoniq->uartc |= ES_TXINTENO(1);
+			/* fill UART FIFO buffer at first, and turn Tx interrupts only if necessary */
+			while (ES_TXINTENI(ensoniq->uartc) == 1 &&
+			       (inb(ES_REG(ensoniq, UART_STATUS)) & ES_TXRDY)) {
+				if (snd_rawmidi_transmit(substream, &byte, 1) != 1) {
+					ensoniq->uartc &= ~ES_TXINTENM;
+				} else {
+					outb(byte, ES_REG(ensoniq, UART_DATA));
+				}
+			}
+			outb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));
+		}
+	} else {
+		if (ES_TXINTENI(ensoniq->uartc) == 1) {
+			ensoniq->uartc &= ~ES_TXINTENM;
+			outb(ensoniq->uartc, ES_REG(ensoniq, UART_CONTROL));
+		}
+	}
+	spin_unlock_irqrestore(&ensoniq->reg_lock, flags);
+}
+
+static snd_rawmidi_ops_t snd_ensoniq_midi_output =
+{
+	.open =		snd_ensoniq_midi_output_open,
+	.close =	snd_ensoniq_midi_output_close,
+	.trigger =	snd_ensoniq_midi_output_trigger,
+};
+
+static snd_rawmidi_ops_t snd_ensoniq_midi_input =
+{
+	.open =		snd_ensoniq_midi_input_open,
+	.close =	snd_ensoniq_midi_input_close,
+	.trigger =	snd_ensoniq_midi_input_trigger,
+};
+
+static int __devinit snd_ensoniq_midi(ensoniq_t * ensoniq, int device, snd_rawmidi_t **rrawmidi)
+{
+	snd_rawmidi_t *rmidi;
+	int err;
+
+	if (rrawmidi)
+		*rrawmidi = NULL;
+	if ((err = snd_rawmidi_new(ensoniq->card, "ES1370/1", device, 1, 1, &rmidi)) < 0)
+		return err;
+#ifdef CHIP1370
+	strcpy(rmidi->name, "ES1370");
+#else
+	strcpy(rmidi->name, "ES1371");
+#endif
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_ensoniq_midi_output);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_ensoniq_midi_input);
+	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT | SNDRV_RAWMIDI_INFO_DUPLEX;
+	rmidi->private_data = ensoniq;
+	ensoniq->rmidi = rmidi;
+	if (rrawmidi)
+		*rrawmidi = rmidi;
+	return 0;
+}
+
+/*
+ *  Interrupt handler
+ */
+
+static irqreturn_t snd_audiopci_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	ensoniq_t *ensoniq = dev_id;
+	unsigned int status, sctrl;
+
+	if (ensoniq == NULL)
+		return IRQ_NONE;
+
+	status = inl(ES_REG(ensoniq, STATUS));
+	if (!(status & ES_INTR))
+		return IRQ_NONE;
+
+	spin_lock(&ensoniq->reg_lock);
+	sctrl = ensoniq->sctrl;
+	if (status & ES_DAC1)
+		sctrl &= ~ES_P1_INT_EN;
+	if (status & ES_DAC2)
+		sctrl &= ~ES_P2_INT_EN;
+	if (status & ES_ADC)
+		sctrl &= ~ES_R1_INT_EN;
+	outl(sctrl, ES_REG(ensoniq, SERIAL));
+	outl(ensoniq->sctrl, ES_REG(ensoniq, SERIAL));
+	spin_unlock(&ensoniq->reg_lock);
+
+	if (status & ES_UART)
+		snd_ensoniq_midi_interrupt(ensoniq);
+	if ((status & ES_DAC2) && ensoniq->playback2_substream)
+		snd_pcm_period_elapsed(ensoniq->playback2_substream);
+	if ((status & ES_ADC) && ensoniq->capture_substream)
+		snd_pcm_period_elapsed(ensoniq->capture_substream);
+	if ((status & ES_DAC1) && ensoniq->playback1_substream)
+		snd_pcm_period_elapsed(ensoniq->playback1_substream);
+	return IRQ_HANDLED;
+}
+
+static int __devinit snd_audiopci_probe(struct pci_dev *pci,
+					const struct pci_device_id *pci_id)
+{
+	static int dev;
+	snd_card_t *card;
+	ensoniq_t *ensoniq;
+	int err, pcm_devs[2];
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+
+	if ((err = snd_ensoniq_create(card, pci, &ensoniq)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	pcm_devs[0] = 0; pcm_devs[1] = 1;
+#ifdef CHIP1370
+	if ((err = snd_ensoniq_1370_mixer(ensoniq)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+#endif
+#ifdef CHIP1371
+	if ((err = snd_ensoniq_1371_mixer(ensoniq)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+#endif
+	if ((err = snd_ensoniq_pcm(ensoniq, 0, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_ensoniq_pcm2(ensoniq, 1, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_ensoniq_midi(ensoniq, 0, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	snd_ensoniq_create_gameport(ensoniq, dev);
+
+	strcpy(card->driver, DRIVER_NAME);
+
+	strcpy(card->shortname, "Ensoniq AudioPCI");
+	sprintf(card->longname, "%s %s at 0x%lx, irq %i",
+		card->shortname,
+		card->driver,
+		ensoniq->port,
+		ensoniq->irq);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_audiopci_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name = DRIVER_NAME,
+	.id_table = snd_audiopci_ids,
+	.probe = snd_audiopci_probe,
+	.remove = __devexit_p(snd_audiopci_remove),
+};
+	
+static int __init alsa_card_ens137x_init(void)
+{
+	return pci_module_init(&driver);
+}
+
+static void __exit alsa_card_ens137x_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_ens137x_init)
+module_exit(alsa_card_ens137x_exit)
