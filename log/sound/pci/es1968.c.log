commit 096da809f6e87c2ec96e6d2eab6f8f2fbf3c2b65
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:50 2020 +0100

    ALSA: es1968: More constifications
    
    Apply const prefix to the quirk white/black lists.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-36-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index affd3e8d7a67..d26004b35a81 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2631,7 +2631,7 @@ struct ess_device_list {
 	unsigned short vendor;	/* subsystem vendor id */
 };
 
-static struct ess_device_list pm_whitelist[] = {
+static const struct ess_device_list pm_whitelist[] = {
 	{ TYPE_MAESTRO2E, 0x0e11 },	/* Compaq Armada */
 	{ TYPE_MAESTRO2E, 0x1028 },
 	{ TYPE_MAESTRO2E, 0x103c },
@@ -2642,7 +2642,7 @@ static struct ess_device_list pm_whitelist[] = {
 	{ TYPE_MAESTRO2, 0x125d },	/* a PCI card, e.g. SF64-PCE2 */
 };
 
-static struct ess_device_list mpu_blacklist[] = {
+static const struct ess_device_list mpu_blacklist[] = {
 	{ TYPE_MAESTRO2, 0x125d },
 };
 

commit cd6e03122be08fd6d2af0445d5f2527563d6bf49
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:17:11 2020 +0100

    ALSA: es1968: Constify snd_es1968_tea575x_gpios
    
    The snd_es1968_tea575x_gpios table is referred as read-only, hence it
    can be declared as const gracefully.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-56-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index f23a935267c3..affd3e8d7a67 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2529,7 +2529,7 @@ struct snd_es1968_tea575x_gpio {
 	char *name;
 };
 
-static struct snd_es1968_tea575x_gpio snd_es1968_tea575x_gpios[] = {
+static const struct snd_es1968_tea575x_gpio snd_es1968_tea575x_gpios[] = {
 	{ .data = 6, .clk = 7, .wren = 8, .most = 9, .name = "SF64-PCE2" },
 	{ .data = 7, .clk = 8, .wren = 6, .most = 10, .name = "M56VAP" },
 };

commit 51055da51d1e92bb089c9b9e0ecb1be69396f808
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:43 2020 +0100

    ALSA: pci: Constify snd_ac97_bus_ops definitions
    
    Now snd_ac97_bus() takes the const ops pointer, so we can define the
    snd_ac97_bus_ops locally as const as well for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-28-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 43cfdf02048b..f23a935267c3 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2007,7 +2007,7 @@ snd_es1968_mixer(struct es1968 *chip)
 	struct snd_ctl_elem_id elem_id;
 #endif
 	int err;
-	static struct snd_ac97_bus_ops ops = {
+	static const struct snd_ac97_bus_ops ops = {
 		.write = snd_es1968_ac97_write,
 		.read = snd_es1968_ac97_read,
 	};

commit efb0ad25d370344e61bb4fca8c3b9c3c6047922e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:25 2020 +0100

    ALSA: pci: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 3610aa1da94c..43cfdf02048b 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2656,7 +2656,7 @@ static int snd_es1968_create(struct snd_card *card,
 			     int radio_nr,
 			     struct es1968 **chip_ret)
 {
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free =	snd_es1968_dev_free,
 	};
 	struct es1968 *chip;

commit dbb71ab05f39162e7e65dbde36cd60be50a4bd5c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:18 2019 +0100

    ALSA: es1968: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation, as well as removing the superfluous synchronize_irq()
    call.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-20-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 4f5063ebce89..3610aa1da94c 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2602,8 +2602,6 @@ static int snd_es1968_free(struct es1968 *chip)
 #endif
 
 	if (chip->io_port) {
-		if (chip->irq >= 0)
-			synchronize_irq(chip->irq);
 		outw(1, chip->io_port + 0x04); /* clear WP interrupts */
 		outw(0, chip->io_port + ESM_PORT_HOST_IRQ); /* disable IRQ */
 	}
@@ -2712,6 +2710,7 @@ static int snd_es1968_create(struct snd_card *card,
 		return -EBUSY;
 	}
 	chip->irq = pci->irq;
+	card->sync_irq = chip->irq;
 	        
 	/* Clear Maestro_map */
 	for (i = 0; i < 32; i++)

commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 7017ca9dea4a..4f5063ebce89 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1664,7 +1664,6 @@ static int snd_es1968_capture_close(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_es1968_playback_ops = {
 	.open =		snd_es1968_playback_open,
 	.close =	snd_es1968_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_es1968_hw_params,
 	.hw_free =	snd_es1968_hw_free,
 	.prepare =	snd_es1968_pcm_prepare,
@@ -1675,7 +1674,6 @@ static const struct snd_pcm_ops snd_es1968_playback_ops = {
 static const struct snd_pcm_ops snd_es1968_capture_ops = {
 	.open =		snd_es1968_capture_open,
 	.close =	snd_es1968_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_es1968_hw_params,
 	.hw_free =	snd_es1968_hw_free,
 	.prepare =	snd_es1968_pcm_prepare,

commit af7153a29d5f0bed1f62b5347dc6cce291d40d69
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:53 2019 +0100

    ALSA: es1968: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Along with it, the unneeded assignment before snd_dma_alloc_pages*()
    call is dropped.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-22-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 974142535a25..7017ca9dea4a 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1422,10 +1422,8 @@ snd_es1968_init_dmabuf(struct es1968 *chip)
 	int err;
 	struct esm_memory *chunk;
 
-	chip->dma.dev.type = SNDRV_DMA_TYPE_DEV;
-	chip->dma.dev.dev = snd_dma_pci_data(chip->pci);
 	err = snd_dma_alloc_pages_fallback(SNDRV_DMA_TYPE_DEV,
-					   snd_dma_pci_data(chip->pci),
+					   &chip->pci->dev,
 					   chip->total_bufsize, &chip->dma);
 	if (err < 0 || ! chip->dma.area) {
 		dev_err(chip->card->dev,

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 9dcb698fc8c7..974142535a25 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Driver for ESS Maestro 1/2/2E Sound Card (started 21.8.99)
  *  Copyright (c) by Matze Braun <MatzeBraun@gmx.de>.
@@ -10,21 +11,6 @@
  *  TODO:
  *   Perhaps Synth
  *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- *
  *  Notes from Zach Brown about the driver code
  *
  *  Hardware Description

commit 17bc4815de586d001c82d0ddf75247283c3f002a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:02:51 2019 +0100

    ALSA: pci: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 0b1845ca6005..9dcb698fc8c7 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2392,7 +2392,6 @@ static int es1968_suspend(struct device *dev)
 	chip->in_suspend = 1;
 	cancel_work_sync(&chip->hwvol_work);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
-	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
 	snd_es1968_bob_stop(chip);
 	return 0;

commit dee49895b197936c02d27d651e58c90bac18f452
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:28 2017 +0530

    ALSA: pci: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 2ec2b1ce0af6..0b1845ca6005 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1290,7 +1290,7 @@ static snd_pcm_uframes_t snd_es1968_pcm_pointer(struct snd_pcm_substream *substr
 	return bytes_to_frames(substream->runtime, ptr % es->dma_size);
 }
 
-static struct snd_pcm_hardware snd_es1968_playback = {
+static const struct snd_pcm_hardware snd_es1968_playback = {
 	.info =			(SNDRV_PCM_INFO_MMAP |
                		         SNDRV_PCM_INFO_MMAP_VALID |
 				 SNDRV_PCM_INFO_INTERLEAVED |
@@ -1311,7 +1311,7 @@ static struct snd_pcm_hardware snd_es1968_playback = {
 	.fifo_size =		0,
 };
 
-static struct snd_pcm_hardware snd_es1968_capture = {
+static const struct snd_pcm_hardware snd_es1968_capture = {
 	.info =			(SNDRV_PCM_INFO_NONINTERLEAVED |
 				 SNDRV_PCM_INFO_MMAP |
 				 SNDRV_PCM_INFO_MMAP_VALID |

commit b2fac0730347d591b528d8f0e4a9438c1bb6f558
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sat Nov 12 23:26:41 2016 +0100

    ALSA: pci: don't opencode IS_REACHABLE()
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 8146fb76a4ad..2ec2b1ce0af6 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -126,7 +126,7 @@ MODULE_SUPPORTED_DEVICE("{{ESS,Maestro 2e},"
 		"{ESS,Maestro 1},"
 		"{TerraTec,DMX}}");
 
-#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+#if IS_REACHABLE(CONFIG_GAMEPORT)
 #define SUPPORT_JOYSTICK 1
 #endif
 

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 514f2604086e..8146fb76a4ad 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1677,7 +1677,7 @@ static int snd_es1968_capture_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static struct snd_pcm_ops snd_es1968_playback_ops = {
+static const struct snd_pcm_ops snd_es1968_playback_ops = {
 	.open =		snd_es1968_playback_open,
 	.close =	snd_es1968_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1688,7 +1688,7 @@ static struct snd_pcm_ops snd_es1968_playback_ops = {
 	.pointer =	snd_es1968_pcm_pointer,
 };
 
-static struct snd_pcm_ops snd_es1968_capture_ops = {
+static const struct snd_pcm_ops snd_es1968_capture_ops = {
 	.open =		snd_es1968_capture_open,
 	.close =	snd_es1968_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,

commit 22dbec265c4fbea4cecc37bcbdbb730c0bc639ff
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Nov 22 08:32:53 2015 -0200

    [media] media, sound: tea575x: constify snd_tea575x_ops structures
    
    The snd_tea575x_ops structures are never modified, so declare them as
    const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index cb38cd1c5fc4..514f2604086e 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2605,7 +2605,7 @@ static void snd_es1968_tea575x_set_direction(struct snd_tea575x *tea, bool outpu
 	}
 }
 
-static struct snd_tea575x_ops snd_es1968_tea_ops = {
+static const struct snd_tea575x_ops snd_es1968_tea_ops = {
 	.set_pins = snd_es1968_tea575x_set_pins,
 	.get_pins = snd_es1968_tea575x_get_pins,
 	.set_direction = snd_es1968_tea575x_set_direction,

commit d647f0b70ce2b4aeb443639dc92b2d859da697a7
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Nov 13 19:40:07 2015 -0200

    [media] include/media: move driver interface headers to a separate dir
    
    Let's not mix headers used by the core with those headers that
    are needed by some driver-specific interface header.
    
    The headers used on drivers were manually moved using:
        mkdir include/media/drv-intf/
        git mv include/media/cx2341x.h include/media/cx25840.h \
            include/media/exynos-fimc.h include/media/msp3400.h \
            include/media/s3c_camif.h include/media/saa7146.h \
            include/media/saa7146_vv.h  include/media/sh_mobile_ceu.h \
            include/media/sh_mobile_csi2.h include/media/sh_vou.h \
            include/media/si476x.h include/media/soc_mediabus.h \
            include/media/tea575x.h include/media/drv-intf/
    
    And the references for those headers were corrected using:
    
        MAIN_DIR="media/"
        PREV_DIR="media/"
        DIRS="drv-intf/"
    
        echo "Checking affected files" >&2
        for i in $DIRS; do
            for j in $(find include/$MAIN_DIR/$i -type f -name '*.h'); do
                     n=`basename $j`
                    git grep -l $n
            done
        done|sort|uniq >files && (
            echo "Handling files..." >&2;
            echo "for i in \$(cat files|grep -v Documentation); do cat \$i | \\";
            (
                    cd include/$MAIN_DIR;
                    for j in $DIRS; do
                            for i in $(ls $j); do
                                    echo "perl -ne 's,(include [\\\"\\<])$PREV_DIR($i)([\\\"\\>]),\1$MAIN_DIR$j\2\3,; print \$_' |\\";
                            done;
                    done;
                    echo "cat > a && mv a \$i; done";
            );
            echo "Handling documentation..." >&2;
            echo "for i in MAINTAINERS \$(cat files); do cat \$i | \\";
            (
                    cd include/$MAIN_DIR;
                    for j in $DIRS; do
                            for i in $(ls $j); do
                                    echo "  perl -ne 's,include/$PREV_DIR($i)\b,include/$MAIN_DIR$j\1,; print \$_' |\\";
                            done;
                    done;
                    echo "cat > a && mv a \$i; done"
            );
        ) >script && . ./script
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index e0d9363dc7fd..cb38cd1c5fc4 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -113,7 +113,7 @@
 #include <sound/initval.h>
 
 #ifdef CONFIG_SND_ES1968_RADIO
-#include <media/tea575x.h>
+#include <media/drv-intf/tea575x.h>
 #endif
 
 #define CARD_NAME "ESS Maestro1/2"

commit 412b979ccceff448dccea54bdb616c85781bc0ba
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Wed Apr 15 16:10:17 2015 +0200

    ALSA: remove deprecated use of pci api
    
    Replace occurences of the pci api by appropriate call to the dma api.
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr)
    
    @deprecated@
    idexpression id;
    position p;
    @@
    
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @bad1@
    idexpression id;
    position deprecated.p;
    @@
    ...when != &id->dev
       when != pci_get_drvdata ( id )
       when != pci_enable_device ( id )
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @depends on !bad1@
    idexpression id;
    expression direction;
    position deprecated.p;
    @@
    
    (
    - pci_dma_supported@p ( id,
    + dma_supported ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    |
    - pci_alloc_consistent@p ( id,
    + dma_alloc_coherent ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    )
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 059f3846d7b8..e0d9363dc7fd 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2689,8 +2689,8 @@ static int snd_es1968_create(struct snd_card *card,
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 	/* check, if we can restrict PCI DMA transfers to 28 bits */
-	if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) < 0 ||
-	    pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) < 0) {
+	if (dma_set_mask(&pci->dev, DMA_BIT_MASK(28)) < 0 ||
+	    dma_set_coherent_mask(&pci->dev, DMA_BIT_MASK(28)) < 0) {
 		dev_err(card->dev,
 			"architecture does not support 28bit PCI busmaster DMA\n");
 		pci_disable_device(pci);

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 631be029f8c0..059f3846d7b8 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -94,7 +94,7 @@
  *	places.
  */
 
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>

commit 8b1db4df201b9ad1f5a329438b823e120d463a96
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 8 12:47:31 2015 +0100

    ALSA: es1968: Simplify PM callbacks
    
    This is a similar cleanup like the commit [3db084fd0af5: ALSA: fm801:
    PCI core handles power state for us].
    
    Since pci_set_power_state(), pci_save_state() and pci_restore_state()
    are already done in the PCI core side, so we don't need to it doubly.
    
    Also, pci_enable_device(), pci_disable_device() and pci_set_master()
    calls in PM callbacks are superfluous nowadays, too, so get rid of
    them as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 6039700f8579..631be029f8c0 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2383,7 +2383,6 @@ static void snd_es1968_start_irq(struct es1968 *chip)
  */
 static int es1968_suspend(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct es1968 *chip = card->private_data;
 
@@ -2396,16 +2395,11 @@ static int es1968_suspend(struct device *dev)
 	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
 	snd_es1968_bob_stop(chip);
-
-	pci_disable_device(pci);
-	pci_save_state(pci);
-	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
 static int es1968_resume(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct es1968 *chip = card->private_data;
 	struct esschan *es;
@@ -2413,16 +2407,6 @@ static int es1968_resume(struct device *dev)
 	if (! chip->do_pm)
 		return 0;
 
-	/* restore all our config */
-	pci_set_power_state(pci, PCI_D0);
-	pci_restore_state(pci);
-	if (pci_enable_device(pci) < 0) {
-		dev_err(dev, "pci_enable_device failed, disabling device\n");
-		snd_card_disconnect(card);
-		return -EIO;
-	}
-	pci_set_master(pci);
-
 	snd_es1968_chip_init(chip);
 
 	/* need to restore the base pointers.. */ 

commit eafe8404c103b3051b6421fc17e0e8b91d369f0b
Author: Tina Ruchandani <ruchandani.tina@gmail.com>
Date:   Wed Oct 29 10:48:10 2014 -0700

    ALSA: es1968: Replace timeval with ktime_t
    
    es1968_measure_clock uses struct timeval, which on 32-bit systems will overflow
    in 2038, leading to incorrect interpretation of time.This patch changes the
    function to use ktime_t instead of struct timeval, which implies:
    - no y2038: ktime_t uses a 64-bit datatype explicitly.
    - efficent subtraction: The earlier version computes the difference in usecs
      while dealing with secs and nsecs. It requires checks to see if the nsecs of
      stop is less than start. This patch uses a direct subtract of ktime_t and
      converts to usecs.
    - use of monotonic clock (ktime_get) over real time (do_gettimeofday),
      which simplifies timekeeping, as it does not have to deal with cases
      where stop_time is less than start_time.
    
    Signed-off-by: Tina Ruchandani <ruchandani.tina@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index a9956a7c5677..6039700f8579 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1710,7 +1710,8 @@ static void es1968_measure_clock(struct es1968 *chip)
 	int i, apu;
 	unsigned int pa, offset, t;
 	struct esm_memory *memory;
-	struct timeval start_time, stop_time;
+	ktime_t start_time, stop_time;
+	ktime_t diff;
 
 	if (chip->clock == 0)
 		chip->clock = 48000; /* default clock value */
@@ -1761,12 +1762,12 @@ static void es1968_measure_clock(struct es1968 *chip)
 	snd_es1968_bob_inc(chip, ESM_BOB_FREQ);
 	__apu_set_register(chip, apu, 5, pa & 0xffff);
 	snd_es1968_trigger_apu(chip, apu, ESM_APU_16BITLINEAR);
-	do_gettimeofday(&start_time);
+	start_time = ktime_get();
 	spin_unlock_irq(&chip->reg_lock);
 	msleep(50);
 	spin_lock_irq(&chip->reg_lock);
 	offset = __apu_get_register(chip, apu, 5);
-	do_gettimeofday(&stop_time);
+	stop_time = ktime_get();
 	snd_es1968_trigger_apu(chip, apu, 0); /* stop */
 	snd_es1968_bob_dec(chip);
 	chip->in_measurement = 0;
@@ -1777,12 +1778,8 @@ static void es1968_measure_clock(struct es1968 *chip)
 	offset &= 0xfffe;
 	offset += chip->measure_count * (CLOCK_MEASURE_BUFSIZE/2);
 
-	t = stop_time.tv_sec - start_time.tv_sec;
-	t *= 1000000;
-	if (stop_time.tv_usec < start_time.tv_usec)
-		t -= start_time.tv_usec - stop_time.tv_usec;
-	else
-		t += stop_time.tv_usec - start_time.tv_usec;
+	diff = ktime_sub(stop_time, start_time);
+	t = ktime_to_us(diff);
 	if (t == 0) {
 		dev_err(chip->card->dev, "?? calculation error..\n");
 	} else {

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 5bb1cf603301..a9956a7c5677 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -570,7 +570,7 @@ struct es1968 {
 
 static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id);
 
-static DEFINE_PCI_DEVICE_TABLE(snd_es1968_ids) = {
+static const struct pci_device_id snd_es1968_ids[] = {
 	/* Maestro 1 */
         { 0x1285, 0x0100, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, TYPE_MAESTRO },
 	/* Maestro 2 */

commit 86cd372fe5c5611ffa310720c873e1d210175b5b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 14:29:55 2014 +0100

    ALSA: es1968: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 87e9cd5d3ceb..5bb1cf603301 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -632,7 +632,7 @@ static int snd_es1968_ac97_wait(struct es1968 *chip)
 			return 0;
 		cond_resched();
 	}
-	snd_printd("es1968: ac97 timeout\n");
+	dev_dbg(chip->card->dev, "ac97 timeout\n");
 	return 1; /* timeout */
 }
 
@@ -644,7 +644,7 @@ static int snd_es1968_ac97_wait_poll(struct es1968 *chip)
 		if (!(inb(chip->io_port + ESM_AC97_INDEX) & 1))
 			return 0;
 	}
-	snd_printd("es1968: ac97 timeout\n");
+	dev_dbg(chip->card->dev, "ac97 timeout\n");
 	return 1; /* timeout */
 }
 
@@ -687,7 +687,7 @@ static void apu_index_set(struct es1968 *chip, u16 index)
 	for (i = 0; i < 1000; i++)
 		if (__maestro_read(chip, IDR1_CRAM_POINTER) == index)
 			return;
-	snd_printd("es1968: APU register select failed. (Timeout)\n");
+	dev_dbg(chip->card->dev, "APU register select failed. (Timeout)\n");
 }
 
 /* no spinlock */
@@ -699,7 +699,7 @@ static void apu_data_set(struct es1968 *chip, u16 data)
 			return;
 		__maestro_write(chip, IDR0_DATA_PORT, data);
 	}
-	snd_printd("es1968: APU register set probably failed (Timeout)!\n");
+	dev_dbg(chip->card->dev, "APU register set probably failed (Timeout)!\n");
 }
 
 /* no spinlock */
@@ -1442,13 +1442,14 @@ snd_es1968_init_dmabuf(struct es1968 *chip)
 					   snd_dma_pci_data(chip->pci),
 					   chip->total_bufsize, &chip->dma);
 	if (err < 0 || ! chip->dma.area) {
-		snd_printk(KERN_ERR "es1968: can't allocate dma pages for size %d\n",
+		dev_err(chip->card->dev,
+			"can't allocate dma pages for size %d\n",
 			   chip->total_bufsize);
 		return -ENOMEM;
 	}
 	if ((chip->dma.addr + chip->dma.bytes - 1) & ~((1 << 28) - 1)) {
 		snd_dma_free_pages(&chip->dma);
-		snd_printk(KERN_ERR "es1968: DMA buffer beyond 256MB.\n");
+		dev_err(chip->card->dev, "DMA buffer beyond 256MB.\n");
 		return -ENOMEM;
 	}
 
@@ -1489,7 +1490,8 @@ static int snd_es1968_hw_params(struct snd_pcm_substream *substream,
 	}
 	chan->memory = snd_es1968_new_memory(chip, size);
 	if (chan->memory == NULL) {
-		// snd_printd("cannot allocate dma buffer: size = %d\n", size);
+		dev_dbg(chip->card->dev,
+			"cannot allocate dma buffer: size = %d\n", size);
 		return -ENOMEM;
 	}
 	snd_pcm_set_runtime_buffer(substream, &chan->memory->buf);
@@ -1715,11 +1717,13 @@ static void es1968_measure_clock(struct es1968 *chip)
 
 	/* search 2 APUs (although one apu is enough) */
 	if ((apu = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_PLAY)) < 0) {
-		snd_printk(KERN_ERR "Hmm, cannot find empty APU pair!?\n");
+		dev_err(chip->card->dev, "Hmm, cannot find empty APU pair!?\n");
 		return;
 	}
 	if ((memory = snd_es1968_new_memory(chip, CLOCK_MEASURE_BUFSIZE)) == NULL) {
-		snd_printk(KERN_ERR "cannot allocate dma buffer - using default clock %d\n", chip->clock);
+		dev_warn(chip->card->dev,
+			 "cannot allocate dma buffer - using default clock %d\n",
+			 chip->clock);
 		snd_es1968_free_apu_pair(chip, apu);
 		return;
 	}
@@ -1780,7 +1784,7 @@ static void es1968_measure_clock(struct es1968 *chip)
 	else
 		t += stop_time.tv_usec - start_time.tv_usec;
 	if (t == 0) {
-		snd_printk(KERN_ERR "?? calculation error..\n");
+		dev_err(chip->card->dev, "?? calculation error..\n");
 	} else {
 		offset *= 1000;
 		offset = (offset / t) * 1000 + ((offset % t) * 1000) / t;
@@ -1788,7 +1792,7 @@ static void es1968_measure_clock(struct es1968 *chip)
 			if (offset >= 40000 && offset <= 50000)
 				chip->clock = (chip->clock * offset) / 48000;
 		}
-		printk(KERN_INFO "es1968: clocking to %d\n", chip->clock);
+		dev_info(chip->card->dev, "clocking to %d\n", chip->clock);
 	}
 	snd_es1968_free_memory(chip, memory);
 	snd_es1968_free_apu_pair(chip, apu);
@@ -2108,7 +2112,7 @@ static void snd_es1968_ac97_reset(struct es1968 *chip)
 	outw(inw(ioaddr + 0x3c) & 0xfffc, ioaddr + 0x3c);
 
 #if 0				/* the loop here needs to be much better if we want it.. */
-	snd_printk(KERN_INFO "trying software reset\n");
+	dev_info(chip->card->dev, "trying software reset\n");
 	/* try and do a software reset */
 	outb(0x80 | 0x7c, ioaddr + 0x30);
 	for (w = 0;; w++) {
@@ -2416,8 +2420,7 @@ static int es1968_resume(struct device *dev)
 	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
 	if (pci_enable_device(pci) < 0) {
-		printk(KERN_ERR "es1968: pci_enable_device failed, "
-		       "disabling device\n");
+		dev_err(dev, "pci_enable_device failed, disabling device\n");
 		snd_card_disconnect(card);
 		return -EIO;
 	}
@@ -2479,7 +2482,8 @@ static int snd_es1968_create_gameport(struct es1968 *chip, int dev)
 
 	chip->gameport = gp = gameport_allocate_port();
 	if (!gp) {
-		printk(KERN_ERR "es1968: cannot allocate memory for gameport\n");
+		dev_err(chip->card->dev,
+			"cannot allocate memory for gameport\n");
 		release_and_free_resource(r);
 		return -ENOMEM;
 	}
@@ -2706,7 +2710,8 @@ static int snd_es1968_create(struct snd_card *card,
 	/* check, if we can restrict PCI DMA transfers to 28 bits */
 	if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) < 0 ||
 	    pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) < 0) {
-		snd_printk(KERN_ERR "architecture does not support 28bit PCI busmaster DMA\n");
+		dev_err(card->dev,
+			"architecture does not support 28bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;
 	}
@@ -2740,7 +2745,7 @@ static int snd_es1968_create(struct snd_card *card,
 	chip->io_port = pci_resource_start(pci, 0);
 	if (request_irq(pci->irq, snd_es1968_interrupt, IRQF_SHARED,
 			KBUILD_MODNAME, chip)) {
-		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		dev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);
 		snd_es1968_free(chip);
 		return -EBUSY;
 	}
@@ -2770,7 +2775,7 @@ static int snd_es1968_create(struct snd_card *card,
 		}
 		if (do_pm > 1) {
 			/* not matched; disabling pm */
-			printk(KERN_INFO "es1968: not attempting power management.\n");
+			dev_info(card->dev, "not attempting power management.\n");
 			do_pm = 0;
 		}
 	}
@@ -2800,7 +2805,7 @@ static int snd_es1968_create(struct snd_card *card,
 	for (i = 0; i < ARRAY_SIZE(snd_es1968_tea575x_gpios); i++) {
 		chip->tea575x_tuner = i;
 		if (!snd_tea575x_init(&chip->tea, THIS_MODULE)) {
-			snd_printk(KERN_INFO "es1968: detected TEA575x radio type %s\n",
+			dev_info(card->dev, "detected TEA575x radio type %s\n",
 				   get_tea575x_gpio(chip)->name);
 			strlcpy(chip->tea.card, get_tea575x_gpio(chip)->name,
 				sizeof(chip->tea.card));
@@ -2899,7 +2904,7 @@ static int snd_es1968_probe(struct pci_dev *pci,
 					       MPU401_INFO_INTEGRATED |
 					       MPU401_INFO_IRQ_HOOK,
 					       -1, &chip->rmidi)) < 0) {
-			printk(KERN_WARNING "es1968: skipping MPU-401 MIDI support..\n");
+			dev_warn(card->dev, "skipping MPU-401 MIDI support..\n");
 		}
 	}
 
@@ -2908,8 +2913,8 @@ static int snd_es1968_probe(struct pci_dev *pci,
 #ifdef CONFIG_SND_ES1968_INPUT
 	err = snd_es1968_input_register(chip);
 	if (err)
-		snd_printk(KERN_WARNING "Input device registration "
-			"failed with error %i", err);
+		dev_warn(card->dev,
+			 "Input device registration failed with error %i", err);
 #endif
 
 	snd_es1968_start_irq(chip);

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 772cc36f951d..87e9cd5d3ceb 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2783,8 +2783,6 @@ static int snd_es1968_create(struct snd_card *card,
 		return err;
 	}
 
-	snd_card_set_dev(card, &pci->dev);
-
 #ifdef CONFIG_SND_ES1968_RADIO
 	/* don't play with GPIOs on laptops */
 	if (chip->pci->subsystem_vendor != 0x125d)
@@ -2836,7 +2834,8 @@ static int snd_es1968_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
+			   0, &card);
 	if (err < 0)
 		return err;
                 

commit 47d98c026ef9a9888c36f3c4f26b81f548a0ca86
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 8 16:12:25 2014 +0100

    ALSA: Remove memory reservation code from memalloc helper
    
    Nowadays we have CMA for obtaining the contiguous memory pages
    efficiently.  Let's kill the old kludge for reserving the memory pages
    for large buffers.  It was rarely useful (only for preserving pages
    among module reloading or a little help by an early boot scripting),
    used only by a couple of drivers, and yet it gives too much ugliness
    than its benefit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index b0e3d92c4656..772cc36f951d 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1422,7 +1422,7 @@ static void snd_es1968_free_dmabuf(struct es1968 *chip)
 
 	if (! chip->dma.area)
 		return;
-	snd_dma_reserve_buf(&chip->dma, snd_dma_pci_buf_id(chip->pci));
+	snd_dma_free_pages(&chip->dma);
 	while ((p = chip->buf_list.next) != &chip->buf_list) {
 		struct esm_memory *chunk = list_entry(p, struct esm_memory, list);
 		list_del(p);
@@ -1438,20 +1438,18 @@ snd_es1968_init_dmabuf(struct es1968 *chip)
 
 	chip->dma.dev.type = SNDRV_DMA_TYPE_DEV;
 	chip->dma.dev.dev = snd_dma_pci_data(chip->pci);
-	if (! snd_dma_get_reserved_buf(&chip->dma, snd_dma_pci_buf_id(chip->pci))) {
-		err = snd_dma_alloc_pages_fallback(SNDRV_DMA_TYPE_DEV,
-						   snd_dma_pci_data(chip->pci),
-						   chip->total_bufsize, &chip->dma);
-		if (err < 0 || ! chip->dma.area) {
-			snd_printk(KERN_ERR "es1968: can't allocate dma pages for size %d\n",
-				   chip->total_bufsize);
-			return -ENOMEM;
-		}
-		if ((chip->dma.addr + chip->dma.bytes - 1) & ~((1 << 28) - 1)) {
-			snd_dma_free_pages(&chip->dma);
-			snd_printk(KERN_ERR "es1968: DMA buffer beyond 256MB.\n");
-			return -ENOMEM;
-		}
+	err = snd_dma_alloc_pages_fallback(SNDRV_DMA_TYPE_DEV,
+					   snd_dma_pci_data(chip->pci),
+					   chip->total_bufsize, &chip->dma);
+	if (err < 0 || ! chip->dma.area) {
+		snd_printk(KERN_ERR "es1968: can't allocate dma pages for size %d\n",
+			   chip->total_bufsize);
+		return -ENOMEM;
+	}
+	if ((chip->dma.addr + chip->dma.bytes - 1) & ~((1 << 28) - 1)) {
+		snd_dma_free_pages(&chip->dma);
+		snd_printk(KERN_ERR "es1968: DMA buffer beyond 256MB.\n");
+		return -ENOMEM;
 	}
 
 	INIT_LIST_HEAD(&chip->buf_list);

commit 59b564599bc66f086856b09e480f89555d47b35c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sun Jul 28 16:01:43 2013 -0300

    [media] tea575x: Move header from sound to media
    
    Move include/sound/tea575x-tuner.h to include/media/tea575x.h and update files that include it.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 5e2ec9687731..b0e3d92c4656 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -113,7 +113,7 @@
 #include <sound/initval.h>
 
 #ifdef CONFIG_SND_ES1968_RADIO
-#include <sound/tea575x-tuner.h>
+#include <media/tea575x.h>
 #endif
 
 #define CARD_NAME "ESS Maestro1/2"

commit 8e0d70434d497f0265ccfe5d92a6a509410685ba
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Thu May 30 16:13:09 2013 +0200

    ALSA: es1968: Add radio support for MediaForte M56VAP
    
    Add support for TEA5757 tuner on MediaForte M56VAP sound+modem+radio card.
    The GPIO connection type is automatically detected (like snd-fm801 driver).
    
    Also add a safety subsystem vendor check to skip radio detection if vendor
    differs from ESS (so we don't touch GPIOs on laptops).
    
    Tested with SF64-PCE2 and M56VAP cards.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 714525154605..5e2ec9687731 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -564,6 +564,7 @@ struct es1968 {
 #ifdef CONFIG_SND_ES1968_RADIO
 	struct v4l2_device v4l2_dev;
 	struct snd_tea575x tea;
+	unsigned int tea575x_tuner;
 #endif
 };
 
@@ -2557,37 +2558,47 @@ static int snd_es1968_input_register(struct es1968 *chip)
 				bits 1=unmask write to given bit */
 #define IO_DIR		8      /* direction register offset from GPIO_DATA
 				bits 0/1=read/write direction */
-/* mask bits for GPIO lines */
-#define STR_DATA	0x0040 /* GPIO6 */
-#define STR_CLK		0x0080 /* GPIO7 */
-#define STR_WREN	0x0100 /* GPIO8 */
-#define STR_MOST	0x0200 /* GPIO9 */
+
+/* GPIO to TEA575x maps */
+struct snd_es1968_tea575x_gpio {
+	u8 data, clk, wren, most;
+	char *name;
+};
+
+static struct snd_es1968_tea575x_gpio snd_es1968_tea575x_gpios[] = {
+	{ .data = 6, .clk = 7, .wren = 8, .most = 9, .name = "SF64-PCE2" },
+	{ .data = 7, .clk = 8, .wren = 6, .most = 10, .name = "M56VAP" },
+};
+
+#define get_tea575x_gpio(chip) \
+	(&snd_es1968_tea575x_gpios[(chip)->tea575x_tuner])
+
 
 static void snd_es1968_tea575x_set_pins(struct snd_tea575x *tea, u8 pins)
 {
 	struct es1968 *chip = tea->private_data;
-	unsigned long io = chip->io_port + GPIO_DATA;
+	struct snd_es1968_tea575x_gpio gpio = *get_tea575x_gpio(chip);
 	u16 val = 0;
 
-	val |= (pins & TEA575X_DATA) ? STR_DATA : 0;
-	val |= (pins & TEA575X_CLK)  ? STR_CLK  : 0;
-	val |= (pins & TEA575X_WREN) ? STR_WREN : 0;
+	val |= (pins & TEA575X_DATA) ? (1 << gpio.data) : 0;
+	val |= (pins & TEA575X_CLK)  ? (1 << gpio.clk)  : 0;
+	val |= (pins & TEA575X_WREN) ? (1 << gpio.wren) : 0;
 
-	outw(val, io);
+	outw(val, chip->io_port + GPIO_DATA);
 }
 
 static u8 snd_es1968_tea575x_get_pins(struct snd_tea575x *tea)
 {
 	struct es1968 *chip = tea->private_data;
-	unsigned long io = chip->io_port + GPIO_DATA;
-	u16 val = inw(io);
-	u8 ret;
+	struct snd_es1968_tea575x_gpio gpio = *get_tea575x_gpio(chip);
+	u16 val = inw(chip->io_port + GPIO_DATA);
+	u8 ret = 0;
 
-	ret = 0;
-	if (val & STR_DATA)
+	if (val & (1 << gpio.data))
 		ret |= TEA575X_DATA;
-	if (val & STR_MOST)
+	if (val & (1 << gpio.most))
 		ret |= TEA575X_MOST;
+
 	return ret;
 }
 
@@ -2596,13 +2607,18 @@ static void snd_es1968_tea575x_set_direction(struct snd_tea575x *tea, bool outpu
 	struct es1968 *chip = tea->private_data;
 	unsigned long io = chip->io_port + GPIO_DATA;
 	u16 odir = inw(io + IO_DIR);
+	struct snd_es1968_tea575x_gpio gpio = *get_tea575x_gpio(chip);
 
 	if (output) {
-		outw(~(STR_DATA | STR_CLK | STR_WREN), io + IO_MASK);
-		outw(odir | STR_DATA | STR_CLK | STR_WREN, io + IO_DIR);
+		outw(~((1 << gpio.data) | (1 << gpio.clk) | (1 << gpio.wren)),
+			io + IO_MASK);
+		outw(odir | (1 << gpio.data) | (1 << gpio.clk) | (1 << gpio.wren),
+			io + IO_DIR);
 	} else {
-		outw(~(STR_CLK | STR_WREN | STR_DATA | STR_MOST), io + IO_MASK);
-		outw((odir & ~(STR_DATA | STR_MOST)) | STR_CLK | STR_WREN, io + IO_DIR);
+		outw(~((1 << gpio.clk) | (1 << gpio.wren) | (1 << gpio.data) | (1 << gpio.most)),
+			io + IO_MASK);
+		outw((odir & ~((1 << gpio.data) | (1 << gpio.most)))
+			| (1 << gpio.clk) | (1 << gpio.wren), io + IO_DIR);
 	}
 }
 
@@ -2772,6 +2788,9 @@ static int snd_es1968_create(struct snd_card *card,
 	snd_card_set_dev(card, &pci->dev);
 
 #ifdef CONFIG_SND_ES1968_RADIO
+	/* don't play with GPIOs on laptops */
+	if (chip->pci->subsystem_vendor != 0x125d)
+		goto no_radio;
 	err = v4l2_device_register(&pci->dev, &chip->v4l2_dev);
 	if (err < 0) {
 		snd_es1968_free(chip);
@@ -2781,10 +2800,18 @@ static int snd_es1968_create(struct snd_card *card,
 	chip->tea.private_data = chip;
 	chip->tea.radio_nr = radio_nr;
 	chip->tea.ops = &snd_es1968_tea_ops;
-	strlcpy(chip->tea.card, "SF64-PCE2", sizeof(chip->tea.card));
 	sprintf(chip->tea.bus_info, "PCI:%s", pci_name(pci));
-	if (!snd_tea575x_init(&chip->tea, THIS_MODULE))
-		printk(KERN_INFO "es1968: detected TEA575x radio\n");
+	for (i = 0; i < ARRAY_SIZE(snd_es1968_tea575x_gpios); i++) {
+		chip->tea575x_tuner = i;
+		if (!snd_tea575x_init(&chip->tea, THIS_MODULE)) {
+			snd_printk(KERN_INFO "es1968: detected TEA575x radio type %s\n",
+				   get_tea575x_gpio(chip)->name);
+			strlcpy(chip->tea.card, get_tea575x_gpio(chip)->name,
+				sizeof(chip->tea.card));
+			break;
+		}
+	}
+no_radio:
 #endif
 
 	*chip_ret = chip;

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index a1f32b5ae0d1..714525154605 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2909,7 +2909,6 @@ static int snd_es1968_probe(struct pci_dev *pci,
 static void snd_es1968_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 static struct pci_driver es1968_driver = {

commit a2013a13e68354e0c8f3696b69701803e13fb737
Merge: dadfab487325 106f9d9337f6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 13 12:00:02 2012 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial branch from Jiri Kosina:
     "Usual stuff -- comment/printk typo fixes, documentation updates, dead
      code elimination."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (39 commits)
      HOWTO: fix double words typo
      x86 mtrr: fix comment typo in mtrr_bp_init
      propagate name change to comments in kernel source
      doc: Update the name of profiling based on sysfs
      treewide: Fix typos in various drivers
      treewide: Fix typos in various Kconfig
      wireless: mwifiex: Fix typo in wireless/mwifiex driver
      messages: i2o: Fix typo in messages/i2o
      scripts/kernel-doc: check that non-void fcts describe their return value
      Kernel-doc: Convention: Use a "Return" section to describe return values
      radeon: Fix typo and copy/paste error in comments
      doc: Remove unnecessary declarations from Documentation/accounting/getdelays.c
      various: Fix spelling of "asynchronous" in comments.
      Fix misspellings of "whether" in comments.
      eisa: Fix spelling of "asynchronous".
      various: Fix spelling of "registered" in comments.
      doc: fix quite a few typos within Documentation
      target: iscsi: fix comment typos in target/iscsi drivers
      treewide: fix typo of "suport" in various comments and Kconfig
      treewide: fix typo of "suppport" in various comments
      ...

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 7266020c16cb..879db2d7796a 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1429,7 +1429,7 @@ static void snd_es1968_free_dmabuf(struct es1968 *chip)
 	}
 }
 
-static int __devinit
+static int
 snd_es1968_init_dmabuf(struct es1968 *chip)
 {
 	int err;
@@ -1704,7 +1704,7 @@ static struct snd_pcm_ops snd_es1968_capture_ops = {
  */
 #define CLOCK_MEASURE_BUFSIZE	16768	/* enough large for a single shot */
 
-static void __devinit es1968_measure_clock(struct es1968 *chip)
+static void es1968_measure_clock(struct es1968 *chip)
 {
 	int i, apu;
 	unsigned int pa, offset, t;
@@ -1806,7 +1806,7 @@ static void snd_es1968_pcm_free(struct snd_pcm *pcm)
 	esm->pcm = NULL;
 }
 
-static int __devinit
+static int
 snd_es1968_pcm(struct es1968 *chip, int device)
 {
 	struct snd_pcm *pcm;
@@ -2016,7 +2016,7 @@ static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id)
  *  Mixer stuff
  */
 
-static int __devinit
+static int
 snd_es1968_mixer(struct es1968 *chip)
 {
 	struct snd_ac97_bus *pbus;
@@ -2465,7 +2465,7 @@ static SIMPLE_DEV_PM_OPS(es1968_pm, es1968_suspend, es1968_resume);
 
 #ifdef SUPPORT_JOYSTICK
 #define JOYSTICK_ADDR	0x200
-static int __devinit snd_es1968_create_gameport(struct es1968 *chip, int dev)
+static int snd_es1968_create_gameport(struct es1968 *chip, int dev)
 {
 	struct gameport *gp;
 	struct resource *r;
@@ -2516,7 +2516,7 @@ static inline void snd_es1968_free_gameport(struct es1968 *chip) { }
 #endif
 
 #ifdef CONFIG_SND_ES1968_INPUT
-static int __devinit snd_es1968_input_register(struct es1968 *chip)
+static int snd_es1968_input_register(struct es1968 *chip)
 {
 	struct input_dev *input_dev;
 	int err;
@@ -2653,7 +2653,7 @@ struct ess_device_list {
 	unsigned short vendor;	/* subsystem vendor id */
 };
 
-static struct ess_device_list pm_whitelist[] __devinitdata = {
+static struct ess_device_list pm_whitelist[] = {
 	{ TYPE_MAESTRO2E, 0x0e11 },	/* Compaq Armada */
 	{ TYPE_MAESTRO2E, 0x1028 },
 	{ TYPE_MAESTRO2E, 0x103c },
@@ -2664,19 +2664,19 @@ static struct ess_device_list pm_whitelist[] __devinitdata = {
 	{ TYPE_MAESTRO2, 0x125d },	/* a PCI card, e.g. SF64-PCE2 */
 };
 
-static struct ess_device_list mpu_blacklist[] __devinitdata = {
+static struct ess_device_list mpu_blacklist[] = {
 	{ TYPE_MAESTRO2, 0x125d },
 };
 
-static int __devinit snd_es1968_create(struct snd_card *card,
-				       struct pci_dev *pci,
-				       int total_bufsize,
-				       int play_streams,
-				       int capt_streams,
-				       int chip_type,
-				       int do_pm,
-				       int radio_nr,
-				       struct es1968 **chip_ret)
+static int snd_es1968_create(struct snd_card *card,
+			     struct pci_dev *pci,
+			     int total_bufsize,
+			     int play_streams,
+			     int capt_streams,
+			     int chip_type,
+			     int do_pm,
+			     int radio_nr,
+			     struct es1968 **chip_ret)
 {
 	static struct snd_device_ops ops = {
 		.dev_free =	snd_es1968_dev_free,
@@ -2795,8 +2795,8 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 
 /*
  */
-static int __devinit snd_es1968_probe(struct pci_dev *pci,
-				      const struct pci_device_id *pci_id)
+static int snd_es1968_probe(struct pci_dev *pci,
+			    const struct pci_device_id *pci_id)
 {
 	static int dev;
 	struct snd_card *card;
@@ -2906,7 +2906,7 @@ static int __devinit snd_es1968_probe(struct pci_dev *pci,
 	return 0;
 }
 
-static void __devexit snd_es1968_remove(struct pci_dev *pci)
+static void snd_es1968_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -2916,7 +2916,7 @@ static struct pci_driver es1968_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_es1968_ids,
 	.probe = snd_es1968_probe,
-	.remove = __devexit_p(snd_es1968_remove),
+	.remove = snd_es1968_remove,
 	.driver = {
 		.pm = ES1968_PM_OPS,
 	},

commit 48fc7f7e787dd65ffe88521bce31f4062ba273eb
Author: Adam Buchbinder <adam.buchbinder@gmail.com>
Date:   Wed Sep 19 21:48:00 2012 -0400

    Fix misspellings of "whether" in comments.
    
    "Whether" is misspelled in various comments across the tree; this
    fixes them. No code changes.
    
    Signed-off-by: Adam Buchbinder <adam.buchbinder@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 5d0e568fdea1..dc14234fea29 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2291,7 +2291,7 @@ static void snd_es1968_chip_init(struct es1968 *chip)
 	outb(0x88, iobase+0x1f);
 
 	/* it appears some maestros (dell 7500) only work if these are set,
-	   regardless of wether we use the assp or not. */
+	   regardless of whether we use the assp or not. */
 
 	outb(0, iobase + ASSP_CONTROL_B);
 	outb(3, iobase + ASSP_CONTROL_A);	/* M: Reserved bits... */

commit d2153a1595ee8235ecf9f9e2d1ac18eee373cbb5
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Nov 13 10:44:54 2012 +0300

    ALSA: es1968: precedence bug in snd_es1968_tea575x_get_pins()
    
    I don't think this works as intended.  '|' higher precedence than ?: so
    the bitwize OR "0 | (val & STR_MOST)" is a no-op.
    
    I have re-written it to be more clear.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 50169bcfd903..7266020c16cb 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2581,9 +2581,14 @@ static u8 snd_es1968_tea575x_get_pins(struct snd_tea575x *tea)
 	struct es1968 *chip = tea->private_data;
 	unsigned long io = chip->io_port + GPIO_DATA;
 	u16 val = inw(io);
-
-	return  (val & STR_DATA) ? TEA575X_DATA : 0 |
-		(val & STR_MOST) ? TEA575X_MOST : 0;
+	u8 ret;
+
+	ret = 0;
+	if (val & STR_DATA)
+		ret |= TEA575X_DATA;
+	if (val & STR_MOST)
+		ret |= TEA575X_MOST;
+	return ret;
 }
 
 static void snd_es1968_tea575x_set_direction(struct snd_tea575x *tea, bool output)

commit 5c0ee9497b33cde3e57460efe4f73313dc0b57a3
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sun Nov 4 23:34:58 2012 +0100

    ALSA: es1968: Add ESS vendor ID to pm_whitelist
    
    Add generic ESS vendor ID to pm_whitelist. This should fix suspend on
    all Maestro-2 and Maestro-2E based PCI cards.
    Tested on Terratec DMX and SF64-PCE2.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 5d0e568fdea1..50169bcfd903 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2655,6 +2655,8 @@ static struct ess_device_list pm_whitelist[] __devinitdata = {
 	{ TYPE_MAESTRO2E, 0x1179 },
 	{ TYPE_MAESTRO2E, 0x14c0 },	/* HP omnibook 4150 */
 	{ TYPE_MAESTRO2E, 0x1558 },
+	{ TYPE_MAESTRO2E, 0x125d },	/* a PCI card, e.g. Terratec DMX */
+	{ TYPE_MAESTRO2, 0x125d },	/* a PCI card, e.g. SF64-PCE2 */
 };
 
 static struct ess_device_list mpu_blacklist[] __devinitdata = {

commit c7561cd80469f2fe4a6be0984db57832ee7f2a3b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 14 18:12:04 2012 +0200

    ALSA: PCI: Replace CONFIG_PM with CONFIG_PM_SLEEP
    
    Otherwise we may get compile warnings due to unused functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index fb4c90b99c00..5d0e568fdea1 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -491,7 +491,7 @@ struct esschan {
 	/* linked list */
 	struct list_head list;
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	u16 wc_map[4];
 #endif
 };
@@ -544,7 +544,7 @@ struct es1968 {
 	struct list_head substream_list;
 	spinlock_t substream_lock;
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	u16 apu_map[NR_APUS][NR_APU_REGS];
 #endif
 
@@ -706,7 +706,7 @@ static void __apu_set_register(struct es1968 *chip, u16 channel, u8 reg, u16 dat
 {
 	if (snd_BUG_ON(channel >= NR_APUS))
 		return;
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	chip->apu_map[channel][reg] = data;
 #endif
 	reg |= (channel << 4);
@@ -993,7 +993,7 @@ static void snd_es1968_program_wavecache(struct es1968 *chip, struct esschan *es
 	/* set the wavecache control reg */
 	wave_set_register(chip, es->apu[channel] << 3, tmpval);
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	es->wc_map[channel] = tmpval;
 #endif
 }
@@ -2377,7 +2377,7 @@ static void snd_es1968_start_irq(struct es1968 *chip)
 	outw(w, chip->io_port + ESM_PORT_HOST_IRQ);
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 /*
  * PM support
  */
@@ -2461,7 +2461,7 @@ static SIMPLE_DEV_PM_OPS(es1968_pm, es1968_suspend, es1968_resume);
 #define ES1968_PM_OPS	&es1968_pm
 #else
 #define ES1968_PM_OPS	NULL
-#endif /* CONFIG_PM */
+#endif /* CONFIG_PM_SLEEP */
 
 #ifdef SUPPORT_JOYSTICK
 #define JOYSTICK_ADDR	0x200

commit 68cb2b559278858ef9f3a7722f95df88797c7840
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 15:20:37 2012 +0200

    ALSA: Convert to new pm_ops for PCI drivers
    
    Straightforward conversion to the new pm_ops from the legacy
    suspend/resume ops.
    
    Since we change vx222, vx_core and vxpocket have to be converted,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 52b5c0bf90c1..fb4c90b99c00 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2381,9 +2381,10 @@ static void snd_es1968_start_irq(struct es1968 *chip)
 /*
  * PM support
  */
-static int es1968_suspend(struct pci_dev *pci, pm_message_t state)
+static int es1968_suspend(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct es1968 *chip = card->private_data;
 
 	if (! chip->do_pm)
@@ -2398,13 +2399,14 @@ static int es1968_suspend(struct pci_dev *pci, pm_message_t state)
 
 	pci_disable_device(pci);
 	pci_save_state(pci);
-	pci_set_power_state(pci, pci_choose_state(pci, state));
+	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
-static int es1968_resume(struct pci_dev *pci)
+static int es1968_resume(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct es1968 *chip = card->private_data;
 	struct esschan *es;
 
@@ -2454,6 +2456,11 @@ static int es1968_resume(struct pci_dev *pci)
 	chip->in_suspend = 0;
 	return 0;
 }
+
+static SIMPLE_DEV_PM_OPS(es1968_pm, es1968_suspend, es1968_resume);
+#define ES1968_PM_OPS	&es1968_pm
+#else
+#define ES1968_PM_OPS	NULL
 #endif /* CONFIG_PM */
 
 #ifdef SUPPORT_JOYSTICK
@@ -2903,10 +2910,9 @@ static struct pci_driver es1968_driver = {
 	.id_table = snd_es1968_ids,
 	.probe = snd_es1968_probe,
 	.remove = __devexit_p(snd_es1968_remove),
-#ifdef CONFIG_PM
-	.suspend = es1968_suspend,
-	.resume = es1968_resume,
-#endif
+	.driver = {
+		.pm = ES1968_PM_OPS,
+	},
 };
 
 module_pci_driver(es1968_driver);

commit aace99e57c90353a51952e9dd1f6f110eec30d15
Merge: bbcaf4111880 099987f0aaf2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 25 14:53:09 2012 -0700

    Merge branch 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media
    
    Pull media fixes from Mauro Carvalho Chehab.
    
    Trivial conflict due to new USB HID ID's being added next to each other
    (Baanto vs Axentia).
    
    * 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media: (44 commits)
      [media] smia: Fix compile failures
      [media]  Fix VIDIOC_DQEVENT docbook entry
      [media] s5p-fimc: Fix control creation function
      [media] s5p-mfc: Fix checkpatch error in s5p_mfc_shm.h file
      [media] s5p-mfc: Fix setting controls
      [media] v4l/s5p-mfc: added image size align in VIDIOC_TRY_FMT
      [media] v4l/s5p-mfc: corrected encoder v4l control definitions
      [media] v4l: mem2mem_testdev: Fix race conditions in driver
      [media] s5p-mfc: Bug fix of timestamp/timecode copy mechanism
      [media] cxd2820r: Fix an incorrect modulation type bitmask
      [media] em28xx: Show a warning if the board does not support remote controls
      [media] em28xx: Add remote control support for Terratec's Cinergy HTC Stick HD
      [media] USB: Staging: media: lirc: initialize spinlocks before usage
      [media] Revert "[media] media: mx2_camera: Fix mbus format handling"
      [media] bw-qcam: driver and pixfmt documentation fixes
      [media] cx88: fix firmware load on big-endian systems
      [media] cx18: support big-endian systems
      [media] ivtv: fix support for big-endian systems
      [media] tuner-core: return the frequency range of the correct tuner
      [media] v4l2-dev.c: fix g_parm regression in determine_valid_ioctls()
      ...

commit 5daf53a6eb5c54c618c9def388d81c2769fd11a0
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat May 19 07:57:03 2012 -0300

    [media] snd_tea575x: Make the module using snd_tea575x the fops owner
    
    Before this patch the owner field of the /dev/radio# device fops was set to
    the snd-tea575x-tuner module itself. Meaning that the module which was using
    it could be rmmod-ed while the device is open, and then BAD things happen.
    
    I know, as I found out the hard way :)
    
    Note that there is no need to also somehow increase the refcount of the
    snd-tea575x-tuner module itself, since any drivers using it will have
    symbolic references to it.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    CC: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index a8faae1c85e4..0f2811eeeebd 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2769,7 +2769,7 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 	chip->tea.ops = &snd_es1968_tea_ops;
 	strlcpy(chip->tea.card, "SF64-PCE2", sizeof(chip->tea.card));
 	sprintf(chip->tea.bus_info, "PCI:%s", pci_name(pci));
-	if (!snd_tea575x_init(&chip->tea))
+	if (!snd_tea575x_init(&chip->tea, THIS_MODULE))
 		printk(KERN_INFO "es1968: detected TEA575x radio\n");
 #endif
 

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index a8faae1c85e4..67f47d891959 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2898,7 +2898,7 @@ static void __devexit snd_es1968_remove(struct pci_dev *pci)
 	pci_set_drvdata(pci, NULL);
 }
 
-static struct pci_driver driver = {
+static struct pci_driver es1968_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_es1968_ids,
 	.probe = snd_es1968_probe,
@@ -2909,15 +2909,4 @@ static struct pci_driver driver = {
 #endif
 };
 
-static int __init alsa_card_es1968_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit alsa_card_es1968_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(alsa_card_es1968_init)
-module_exit(alsa_card_es1968_exit)
+module_pci_driver(es1968_driver);

commit d4ecc83b79cc290eadf1ffb33a589c3c72bbc295
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon Feb 27 05:30:13 2012 -0300

    [media] tea575x-tuner: update to latest V4L2 framework requirements
    
    The tea575x-tuner module has been updated to use the latest V4L2 framework
    functionality. This also required changes in the drivers that rely on it.
    
    The tea575x changes are:
    
    - The drivers must provide a v4l2_device struct to the tea module.
    - The radio_nr module parameter must be part of the actual radio driver,
      and not of the tea module.
    - Changed the frequency range to the normal 76-108 MHz range instead of
      50-150.
    - Add hardware frequency seek support.
    - Fix broken rxsubchans/audmode handling.
    - The application can now select between stereo and mono.
    - Support polling for control events.
    - Add V4L2 priority handling.
    
    And radio-sf16fmr2.c now uses the isa bus kernel framework.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Thanks-to: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index cb557c603a80..a8faae1c85e4 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -142,6 +142,7 @@ static int enable_mpu[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
 #ifdef SUPPORT_JOYSTICK
 static bool joystick[SNDRV_CARDS];
 #endif
+static int radio_nr[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = -1};
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
@@ -165,6 +166,9 @@ MODULE_PARM_DESC(enable_mpu, "Enable MPU401.  (0 = off, 1 = on, 2 = auto)");
 module_param_array(joystick, bool, NULL, 0444);
 MODULE_PARM_DESC(joystick, "Enable joystick.");
 #endif
+module_param_array(radio_nr, int, NULL, 0444);
+MODULE_PARM_DESC(radio_nr, "Radio device numbers");
+
 
 
 #define NR_APUS			64
@@ -558,6 +562,7 @@ struct es1968 {
 	struct work_struct hwvol_work;
 
 #ifdef CONFIG_SND_ES1968_RADIO
+	struct v4l2_device v4l2_dev;
 	struct snd_tea575x tea;
 #endif
 };
@@ -2613,6 +2618,7 @@ static int snd_es1968_free(struct es1968 *chip)
 
 #ifdef CONFIG_SND_ES1968_RADIO
 	snd_tea575x_exit(&chip->tea);
+	v4l2_device_unregister(&chip->v4l2_dev);
 #endif
 
 	if (chip->irq >= 0)
@@ -2655,6 +2661,7 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 				       int capt_streams,
 				       int chip_type,
 				       int do_pm,
+				       int radio_nr,
 				       struct es1968 **chip_ret)
 {
 	static struct snd_device_ops ops = {
@@ -2751,7 +2758,14 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 	snd_card_set_dev(card, &pci->dev);
 
 #ifdef CONFIG_SND_ES1968_RADIO
+	err = v4l2_device_register(&pci->dev, &chip->v4l2_dev);
+	if (err < 0) {
+		snd_es1968_free(chip);
+		return err;
+	}
+	chip->tea.v4l2_dev = &chip->v4l2_dev;
 	chip->tea.private_data = chip;
+	chip->tea.radio_nr = radio_nr;
 	chip->tea.ops = &snd_es1968_tea_ops;
 	strlcpy(chip->tea.card, "SF64-PCE2", sizeof(chip->tea.card));
 	sprintf(chip->tea.bus_info, "PCI:%s", pci_name(pci));
@@ -2797,6 +2811,7 @@ static int __devinit snd_es1968_probe(struct pci_dev *pci,
 				     pcm_substreams_c[dev],
 				     pci_id->driver_data,
 				     use_pm[dev],
+				     radio_nr[dev],
 				     &chip)) < 0) {
 		snd_card_free(card);
 		return err;

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 297a151bdba9..cb557c603a80 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -132,7 +132,7 @@ MODULE_SUPPORTED_DEVICE("{{ESS,Maestro 2e},"
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 1-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 static int total_bufsize[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1024 };
 static int pcm_substreams_p[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 4 };
 static int pcm_substreams_c[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1 };
@@ -140,7 +140,7 @@ static int clock[SNDRV_CARDS];
 static int use_pm[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
 static int enable_mpu[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
 #ifdef SUPPORT_JOYSTICK
-static int joystick[SNDRV_CARDS];
+static bool joystick[SNDRV_CARDS];
 #endif
 
 module_param_array(index, int, NULL, 0444);

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 407e4abc4356..297a151bdba9 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -102,7 +102,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/input.h>
 

commit dba8b46992c55946d3b092934f581a343403118f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Sep 13 11:24:41 2011 +0200

    ALSA: mpu401: clean up interrupt specification
    
    The semantics of snd_mpu401_uart_new()'s interrupt parameters are
    somewhat counterintuitive:  To prevent the function from allocating its
    own interrupt, either the irq number must be invalid, or the irq_flags
    parameter must be zero.  At the same time, the irq parameter being
    invalid specifies that the mpu401 code has to work without an interrupt
    allocated by the caller.  This implies that, if there is an interrupt
    and it is allocated by the caller, the irq parameter must be set to
    a valid-looking number which then isn't actually used.
    
    With the removal of IRQF_DISABLED, zero becomes a valid irq_flags value,
    which forces us to handle the parameters differently.
    
    This patch introduces a new flag MPU401_INFO_IRQ_HOOK for when the
    device interrupt is handled by the caller, and makes the allocation of
    the interrupt to depend only on the irq parameter.  As suggested by
    Takashi, the irq_flags parameter was dropped because, when used, it had
    the constant value IRQF_DISABLED.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 99ea9320c6b5..407e4abc4356 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2843,8 +2843,9 @@ static int __devinit snd_es1968_probe(struct pci_dev *pci,
 	if (enable_mpu[dev]) {
 		if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
 					       chip->io_port + ESM_MPU401_PORT,
-					       MPU401_INFO_INTEGRATED,
-					       chip->irq, 0, &chip->rmidi)) < 0) {
+					       MPU401_INFO_INTEGRATED |
+					       MPU401_INFO_IRQ_HOOK,
+					       -1, &chip->rmidi)) < 0) {
 			printk(KERN_WARNING "es1968: skipping MPU-401 MIDI support..\n");
 		}
 	}

commit 30bdee0259093e114c711943902c834e5c3326c5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 14 13:57:02 2011 +0200

    ALSA: es1968,maestro3 - Use work for hw-volume control
    
    Instead of tasklet, use workq for handling the hw-volume control.
    This reduces lots of spinlocks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 3fa46593a3b9..99ea9320c6b5 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -554,9 +554,8 @@ struct es1968 {
 #else
 	struct snd_kcontrol *master_switch; /* for h/w volume control */
 	struct snd_kcontrol *master_volume;
-	spinlock_t ac97_lock;
-	struct tasklet_struct hwvol_tq;
 #endif
+	struct work_struct hwvol_work;
 
 #ifdef CONFIG_SND_ES1968_RADIO
 	struct snd_tea575x tea;
@@ -646,38 +645,23 @@ static int snd_es1968_ac97_wait_poll(struct es1968 *chip)
 static void snd_es1968_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)
 {
 	struct es1968 *chip = ac97->private_data;
-#ifndef CONFIG_SND_ES1968_INPUT
-	unsigned long flags;
-#endif
 
 	snd_es1968_ac97_wait(chip);
 
 	/* Write the bus */
-#ifndef CONFIG_SND_ES1968_INPUT
-	spin_lock_irqsave(&chip->ac97_lock, flags);
-#endif
 	outw(val, chip->io_port + ESM_AC97_DATA);
 	/*msleep(1);*/
 	outb(reg, chip->io_port + ESM_AC97_INDEX);
 	/*msleep(1);*/
-#ifndef CONFIG_SND_ES1968_INPUT
-	spin_unlock_irqrestore(&chip->ac97_lock, flags);
-#endif
 }
 
 static unsigned short snd_es1968_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
 {
 	u16 data = 0;
 	struct es1968 *chip = ac97->private_data;
-#ifndef CONFIG_SND_ES1968_INPUT
-	unsigned long flags;
-#endif
 
 	snd_es1968_ac97_wait(chip);
 
-#ifndef CONFIG_SND_ES1968_INPUT
-	spin_lock_irqsave(&chip->ac97_lock, flags);
-#endif
 	outb(reg | 0x80, chip->io_port + ESM_AC97_INDEX);
 	/*msleep(1);*/
 
@@ -685,9 +669,6 @@ static unsigned short snd_es1968_ac97_read(struct snd_ac97 *ac97, unsigned short
 		data = inw(chip->io_port + ESM_AC97_DATA);
 		/*msleep(1);*/
 	}
-#ifndef CONFIG_SND_ES1968_INPUT
-	spin_unlock_irqrestore(&chip->ac97_lock, flags);
-#endif
 
 	return data;
 }
@@ -1904,13 +1885,10 @@ static void snd_es1968_update_pcm(struct es1968 *chip, struct esschan *es)
    (without wrap around) in response to volume button presses and then
    generating an interrupt. The pair of counters is stored in bits 1-3 and 5-7
    of a byte wide register. The meaning of bits 0 and 4 is unknown. */
-static void es1968_update_hw_volume(unsigned long private_data)
+static void es1968_update_hw_volume(struct work_struct *work)
 {
-	struct es1968 *chip = (struct es1968 *) private_data;
+	struct es1968 *chip = container_of(work, struct es1968, hwvol_work);
 	int x, val;
-#ifndef CONFIG_SND_ES1968_INPUT
-	unsigned long flags;
-#endif
 
 	/* Figure out which volume control button was pushed,
 	   based on differences from the default register
@@ -1929,18 +1907,11 @@ static void es1968_update_hw_volume(unsigned long private_data)
 	if (! chip->master_switch || ! chip->master_volume)
 		return;
 
-	/* FIXME: we can't call snd_ac97_* functions since here is in tasklet. */
-	spin_lock_irqsave(&chip->ac97_lock, flags);
-	val = chip->ac97->regs[AC97_MASTER];
+	val = snd_ac97_read(chip->ac97, AC97_MASTER);
 	switch (x) {
 	case 0x88:
 		/* mute */
 		val ^= 0x8000;
-		chip->ac97->regs[AC97_MASTER] = val;
-		outw(val, chip->io_port + ESM_AC97_DATA);
-		outb(AC97_MASTER, chip->io_port + ESM_AC97_INDEX);
-		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
-			       &chip->master_switch->id);
 		break;
 	case 0xaa:
 		/* volume up */
@@ -1948,11 +1919,6 @@ static void es1968_update_hw_volume(unsigned long private_data)
 			val--;
 		if ((val & 0x7f00) > 0)
 			val -= 0x0100;
-		chip->ac97->regs[AC97_MASTER] = val;
-		outw(val, chip->io_port + ESM_AC97_DATA);
-		outb(AC97_MASTER, chip->io_port + ESM_AC97_INDEX);
-		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
-			       &chip->master_volume->id);
 		break;
 	case 0x66:
 		/* volume down */
@@ -1960,14 +1926,11 @@ static void es1968_update_hw_volume(unsigned long private_data)
 			val++;
 		if ((val & 0x7f00) < 0x1f00)
 			val += 0x0100;
-		chip->ac97->regs[AC97_MASTER] = val;
-		outw(val, chip->io_port + ESM_AC97_DATA);
-		outb(AC97_MASTER, chip->io_port + ESM_AC97_INDEX);
-		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
-			       &chip->master_volume->id);
 		break;
 	}
-	spin_unlock_irqrestore(&chip->ac97_lock, flags);
+	if (snd_ac97_update(chip->ac97, AC97_MASTER, val))
+		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+			       &chip->master_volume->id);
 #else
 	if (!chip->input_dev)
 		return;
@@ -2013,11 +1976,7 @@ static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id)
 	outw(inw(chip->io_port + 4) & 1, chip->io_port + 4);
 
 	if (event & ESM_HWVOL_IRQ)
-#ifdef CONFIG_SND_ES1968_INPUT
-		es1968_update_hw_volume((unsigned long)chip);
-#else
-		tasklet_schedule(&chip->hwvol_tq); /* we'll do this later */
-#endif
+		schedule_work(&chip->hwvol_work);
 
 	/* else ack 'em all, i imagine */
 	outb(0xFF, chip->io_port + 0x1A);
@@ -2426,6 +2385,7 @@ static int es1968_suspend(struct pci_dev *pci, pm_message_t state)
 		return 0;
 
 	chip->in_suspend = 1;
+	cancel_work_sync(&chip->hwvol_work);
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
@@ -2638,6 +2598,7 @@ static struct snd_tea575x_ops snd_es1968_tea_ops = {
 
 static int snd_es1968_free(struct es1968 *chip)
 {
+	cancel_work_sync(&chip->hwvol_work);
 #ifdef CONFIG_SND_ES1968_INPUT
 	if (chip->input_dev)
 		input_unregister_device(chip->input_dev);
@@ -2728,10 +2689,7 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 	INIT_LIST_HEAD(&chip->buf_list);
 	INIT_LIST_HEAD(&chip->substream_list);
 	mutex_init(&chip->memory_mutex);
-#ifndef CONFIG_SND_ES1968_INPUT
-	spin_lock_init(&chip->ac97_lock);
-	tasklet_init(&chip->hwvol_tq, es1968_update_hw_volume, (unsigned long)chip);
-#endif
+	INIT_WORK(&chip->hwvol_work, es1968_update_hw_volume);
 	chip->card = card;
 	chip->pci = pci;
 	chip->irq = -1;

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 14a2e163fa8c..3fa46593a3b9 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2746,7 +2746,7 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 	}
 	chip->io_port = pci_resource_start(pci, 0);
 	if (request_irq(pci->irq, snd_es1968_interrupt, IRQF_SHARED,
-			"ESS Maestro", chip)) {
+			KBUILD_MODNAME, chip)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_es1968_free(chip);
 		return -EBUSY;

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index ab0a6156a704..14a2e163fa8c 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2925,7 +2925,7 @@ static void __devexit snd_es1968_remove(struct pci_dev *pci)
 }
 
 static struct pci_driver driver = {
-	.name = "ES1968 (ESS Maestro)",
+	.name = KBUILD_MODNAME,
 	.id_table = snd_es1968_ids,
 	.probe = snd_es1968_probe,
 	.remove = __devexit_p(snd_es1968_remove),

commit 10ca72014741554ad37c149ff0d9e93c1e3d5b7d
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Thu May 12 22:18:22 2011 +0200

    ALSA: tea575x: use better card and bus names
    
    Provide real card and bus_info instead of hardcoded values.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index ec7f8371a812..ab0a6156a704 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2795,6 +2795,8 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 #ifdef CONFIG_SND_ES1968_RADIO
 	chip->tea.private_data = chip;
 	chip->tea.ops = &snd_es1968_tea_ops;
+	strlcpy(chip->tea.card, "SF64-PCE2", sizeof(chip->tea.card));
+	sprintf(chip->tea.bus_info, "PCI:%s", pci_name(pci));
 	if (!snd_tea575x_init(&chip->tea))
 		printk(KERN_INFO "es1968: detected TEA575x radio\n");
 #endif

commit 3d11ba5593b801b1db85e9680d585713e6039112
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Thu May 12 22:18:09 2011 +0200

    ALSA: tea575x: remove unused card from struct
    
    struct snd_card *card is present in struct snd_tea575x but never used.
    Remove it.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 3f3ff1bae814..ec7f8371a812 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2793,7 +2793,6 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 	snd_card_set_dev(card, &pci->dev);
 
 #ifdef CONFIG_SND_ES1968_RADIO
-	chip->tea.card = card;
 	chip->tea.private_data = chip;
 	chip->tea.ops = &snd_es1968_tea_ops;
 	if (!snd_tea575x_init(&chip->tea))

commit ea27316e4cd13b25727715c0db8adb0b1661f5e7
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Thu May 12 22:17:56 2011 +0200

    ALSA: tea575x: remove freq_fixup from struct
    
    freq_fixup is a constant, no need to hold it in struct snd_tea575x and set in
    each driver.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 75c5e0ed6955..3f3ff1bae814 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2794,7 +2794,6 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 
 #ifdef CONFIG_SND_ES1968_RADIO
 	chip->tea.card = card;
-	chip->tea.freq_fixup = 10700;
 	chip->tea.private_data = chip;
 	chip->tea.ops = &snd_es1968_tea_ops;
 	if (!snd_tea575x_init(&chip->tea))

commit 72587173cc31bb96db63e347b94ad0ef84878cea
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Mon May 9 23:39:37 2011 +0200

    ALSA: es1968: convert TEA575x support to new interface
    
    Use common functions to access TEA575x tuner - remove original read/write
    functions and provide new pin manipulation functions instead.
    
    Tested with SF64-PCE2 card.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index faf9138970ae..75c5e0ed6955 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2591,96 +2591,48 @@ static int __devinit snd_es1968_input_register(struct es1968 *chip)
 #define STR_WREN	0x0100 /* GPIO8 */
 #define STR_MOST	0x0200 /* GPIO9 */
 
-static void snd_es1968_tea575x_write(struct snd_tea575x *tea, unsigned int val)
+static void snd_es1968_tea575x_set_pins(struct snd_tea575x *tea, u8 pins)
 {
 	struct es1968 *chip = tea->private_data;
 	unsigned long io = chip->io_port + GPIO_DATA;
-	u16 l, bits;
-	u16 omask, odir;
+	u16 val = 0;
 
-	omask = inw(io + IO_MASK);
-	odir = (inw(io + IO_DIR) & ~STR_DATA) | (STR_CLK | STR_WREN);
-	outw(odir | STR_DATA, io + IO_DIR);
-	outw(~(STR_DATA | STR_CLK | STR_WREN), io + IO_MASK);
-	udelay(16);
+	val |= (pins & TEA575X_DATA) ? STR_DATA : 0;
+	val |= (pins & TEA575X_CLK)  ? STR_CLK  : 0;
+	val |= (pins & TEA575X_WREN) ? STR_WREN : 0;
 
-	for (l = 25; l; l--) {
-		bits = ((val >> 18) & STR_DATA) | STR_WREN;
-		val <<= 1;			/* shift data */
-		outw(bits, io);			/* start strobe */
-		udelay(2);
-		outw(bits | STR_CLK, io);	/* HI level */
-		udelay(2);
-		outw(bits, io);			/* LO level */
-		udelay(4);
-	}
-
-	if (!tea->mute)
-		outw(0, io);
-
-	udelay(4);
-	outw(omask, io + IO_MASK);
-	outw(odir, io + IO_DIR);
-	msleep(125);
+	outw(val, io);
 }
 
-static unsigned int snd_es1968_tea575x_read(struct snd_tea575x *tea)
+static u8 snd_es1968_tea575x_get_pins(struct snd_tea575x *tea)
 {
 	struct es1968 *chip = tea->private_data;
 	unsigned long io = chip->io_port + GPIO_DATA;
-	u16 l, rdata;
-	u32 data = 0;
-	u16 omask;
-
-	omask = inw(io + IO_MASK);
-	outw(~(STR_CLK | STR_WREN), io + IO_MASK);
-	outw(0, io);
-	udelay(16);
-
-	for (l = 24; l--;) {
-		outw(STR_CLK, io);		/* HI state */
-		udelay(2);
-		if (!l)
-			tea->tuned = inw(io) & STR_MOST ? 0 : 1;
-		outw(0, io);			/* LO state */
-		udelay(2);
-		data <<= 1;			/* shift data */
-		rdata = inw(io);
-		if (!l)
-			tea->stereo = (rdata & STR_MOST) ?  0 : 1;
-		else if (l && rdata & STR_DATA)
-			data++;
-		udelay(2);
-	}
-
-	if (tea->mute)
-		outw(STR_WREN, io);
-
-	udelay(4);
-	outw(omask, io + IO_MASK);
+	u16 val = inw(io);
 
-	return data & 0x3ffe;
+	return  (val & STR_DATA) ? TEA575X_DATA : 0 |
+		(val & STR_MOST) ? TEA575X_MOST : 0;
 }
 
-static void snd_es1968_tea575x_mute(struct snd_tea575x *tea, unsigned int mute)
+static void snd_es1968_tea575x_set_direction(struct snd_tea575x *tea, bool output)
 {
 	struct es1968 *chip = tea->private_data;
 	unsigned long io = chip->io_port + GPIO_DATA;
-	u16 omask;
+	u16 odir = inw(io + IO_DIR);
 
-	omask = inw(io + IO_MASK);
-	outw(~STR_WREN, io + IO_MASK);
-	tea->mute = mute;
-	outw(tea->mute ? STR_WREN : 0, io);
-	udelay(4);
-	outw(omask, io + IO_MASK);
-	msleep(125);
+	if (output) {
+		outw(~(STR_DATA | STR_CLK | STR_WREN), io + IO_MASK);
+		outw(odir | STR_DATA | STR_CLK | STR_WREN, io + IO_DIR);
+	} else {
+		outw(~(STR_CLK | STR_WREN | STR_DATA | STR_MOST), io + IO_MASK);
+		outw((odir & ~(STR_DATA | STR_MOST)) | STR_CLK | STR_WREN, io + IO_DIR);
+	}
 }
 
 static struct snd_tea575x_ops snd_es1968_tea_ops = {
-	.write = snd_es1968_tea575x_write,
-	.read  = snd_es1968_tea575x_read,
-	.mute  = snd_es1968_tea575x_mute,
+	.set_pins = snd_es1968_tea575x_set_pins,
+	.get_pins = snd_es1968_tea575x_get_pins,
+	.set_direction = snd_es1968_tea575x_set_direction,
 };
 #endif
 
@@ -2845,7 +2797,8 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 	chip->tea.freq_fixup = 10700;
 	chip->tea.private_data = chip;
 	chip->tea.ops = &snd_es1968_tea_ops;
-	snd_tea575x_init(&chip->tea);
+	if (!snd_tea575x_init(&chip->tea))
+		printk(KERN_INFO "es1968: detected TEA575x radio\n");
 #endif
 
 	*chip_ret = chip;

commit 1872f589951caee1afd7cd2ea6729ac892de9ddf
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sat Mar 19 16:33:14 2011 +0100

    ALSA: es1968: add radio (tea575x tuner) support
    
    Add TEA5757 radio tuner support to es1968 driver. This is found at least on
    MediaForte SF64-PCE2 sound cards.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 7c17f45d876d..faf9138970ae 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -112,6 +112,10 @@
 #include <sound/ac97_codec.h>
 #include <sound/initval.h>
 
+#ifdef CONFIG_SND_ES1968_RADIO
+#include <sound/tea575x-tuner.h>
+#endif
+
 #define CARD_NAME "ESS Maestro1/2"
 #define DRIVER_NAME "ES1968"
 
@@ -553,6 +557,10 @@ struct es1968 {
 	spinlock_t ac97_lock;
 	struct tasklet_struct hwvol_tq;
 #endif
+
+#ifdef CONFIG_SND_ES1968_RADIO
+	struct snd_tea575x tea;
+#endif
 };
 
 static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id);
@@ -2571,6 +2579,111 @@ static int __devinit snd_es1968_input_register(struct es1968 *chip)
 }
 #endif /* CONFIG_SND_ES1968_INPUT */
 
+#ifdef CONFIG_SND_ES1968_RADIO
+#define GPIO_DATA	0x60
+#define IO_MASK		4      /* mask      register offset from GPIO_DATA
+				bits 1=unmask write to given bit */
+#define IO_DIR		8      /* direction register offset from GPIO_DATA
+				bits 0/1=read/write direction */
+/* mask bits for GPIO lines */
+#define STR_DATA	0x0040 /* GPIO6 */
+#define STR_CLK		0x0080 /* GPIO7 */
+#define STR_WREN	0x0100 /* GPIO8 */
+#define STR_MOST	0x0200 /* GPIO9 */
+
+static void snd_es1968_tea575x_write(struct snd_tea575x *tea, unsigned int val)
+{
+	struct es1968 *chip = tea->private_data;
+	unsigned long io = chip->io_port + GPIO_DATA;
+	u16 l, bits;
+	u16 omask, odir;
+
+	omask = inw(io + IO_MASK);
+	odir = (inw(io + IO_DIR) & ~STR_DATA) | (STR_CLK | STR_WREN);
+	outw(odir | STR_DATA, io + IO_DIR);
+	outw(~(STR_DATA | STR_CLK | STR_WREN), io + IO_MASK);
+	udelay(16);
+
+	for (l = 25; l; l--) {
+		bits = ((val >> 18) & STR_DATA) | STR_WREN;
+		val <<= 1;			/* shift data */
+		outw(bits, io);			/* start strobe */
+		udelay(2);
+		outw(bits | STR_CLK, io);	/* HI level */
+		udelay(2);
+		outw(bits, io);			/* LO level */
+		udelay(4);
+	}
+
+	if (!tea->mute)
+		outw(0, io);
+
+	udelay(4);
+	outw(omask, io + IO_MASK);
+	outw(odir, io + IO_DIR);
+	msleep(125);
+}
+
+static unsigned int snd_es1968_tea575x_read(struct snd_tea575x *tea)
+{
+	struct es1968 *chip = tea->private_data;
+	unsigned long io = chip->io_port + GPIO_DATA;
+	u16 l, rdata;
+	u32 data = 0;
+	u16 omask;
+
+	omask = inw(io + IO_MASK);
+	outw(~(STR_CLK | STR_WREN), io + IO_MASK);
+	outw(0, io);
+	udelay(16);
+
+	for (l = 24; l--;) {
+		outw(STR_CLK, io);		/* HI state */
+		udelay(2);
+		if (!l)
+			tea->tuned = inw(io) & STR_MOST ? 0 : 1;
+		outw(0, io);			/* LO state */
+		udelay(2);
+		data <<= 1;			/* shift data */
+		rdata = inw(io);
+		if (!l)
+			tea->stereo = (rdata & STR_MOST) ?  0 : 1;
+		else if (l && rdata & STR_DATA)
+			data++;
+		udelay(2);
+	}
+
+	if (tea->mute)
+		outw(STR_WREN, io);
+
+	udelay(4);
+	outw(omask, io + IO_MASK);
+
+	return data & 0x3ffe;
+}
+
+static void snd_es1968_tea575x_mute(struct snd_tea575x *tea, unsigned int mute)
+{
+	struct es1968 *chip = tea->private_data;
+	unsigned long io = chip->io_port + GPIO_DATA;
+	u16 omask;
+
+	omask = inw(io + IO_MASK);
+	outw(~STR_WREN, io + IO_MASK);
+	tea->mute = mute;
+	outw(tea->mute ? STR_WREN : 0, io);
+	udelay(4);
+	outw(omask, io + IO_MASK);
+	msleep(125);
+}
+
+static struct snd_tea575x_ops snd_es1968_tea_ops = {
+	.write = snd_es1968_tea575x_write,
+	.read  = snd_es1968_tea575x_read,
+	.mute  = snd_es1968_tea575x_mute,
+};
+#endif
+
 static int snd_es1968_free(struct es1968 *chip)
 {
 #ifdef CONFIG_SND_ES1968_INPUT
@@ -2585,6 +2698,10 @@ static int snd_es1968_free(struct es1968 *chip)
 		outw(0, chip->io_port + ESM_PORT_HOST_IRQ); /* disable IRQ */
 	}
 
+#ifdef CONFIG_SND_ES1968_RADIO
+	snd_tea575x_exit(&chip->tea);
+#endif
+
 	if (chip->irq >= 0)
 		free_irq(chip->irq, chip);
 	snd_es1968_free_gameport(chip);
@@ -2723,6 +2840,14 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 
 	snd_card_set_dev(card, &pci->dev);
 
+#ifdef CONFIG_SND_ES1968_RADIO
+	chip->tea.card = card;
+	chip->tea.freq_fixup = 10700;
+	chip->tea.private_data = chip;
+	chip->tea.ops = &snd_es1968_tea_ops;
+	snd_tea575x_init(&chip->tea);
+#endif
+
 	*chip_ret = chip;
 
 	return 0;

commit b595076a180a56d1bb170e6eceda6eb9d76f4cd3
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Mon Nov 1 15:38:34 2010 -0400

    tree-wide: fix comment/printk typos
    
    "gadget", "through", "command", "maintain", "maintain", "controller", "address",
    "between", "initiali[zs]e", "instead", "function", "select", "already",
    "equal", "access", "management", "hierarchy", "registration", "interest",
    "relative", "memory", "offset", "already",
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 23a58f0d6cb9..7c17f45d876d 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -220,7 +220,7 @@ MODULE_PARM_DESC(joystick, "Enable joystick.");
 #define	RINGB_EN_2CODEC		0x0020
 #define RINGB_SING_BIT_DUAL	0x0040
 
-/* ****Port Adresses**** */
+/* ****Port Addresses**** */
 
 /*   Write & Read */
 #define ESM_INDEX		0x02

commit 6895b5262ea80c99e526d40d39e0ca48014bdb95
Author: Ville Syrjl <syrjala@sci.fi>
Date:   Fri May 7 00:12:12 2010 +0300

    ALSA: es1968: Clear interrupts before enabling them
    
    Avoid spurious interrupts when initializing the device.
    
    Signed-off-by: Ville Syrjl <syrjala@sci.fi>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index aa973cee8155..23a58f0d6cb9 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2401,6 +2401,7 @@ static void snd_es1968_start_irq(struct es1968 *chip)
 	w = ESM_HIRQ_DSIE | ESM_HIRQ_HW_VOLUME;
 	if (chip->rmidi)
 		w |= ESM_HIRQ_MPU401;
+	outb(w, chip->io_port + 0x1A);
 	outw(w, chip->io_port + ESM_PORT_HOST_IRQ);
 }
 

commit 5a5e02e5095ed89a0a1f4031e7440078c209442b
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Apr 23 05:26:43 2010 -0400

    ALSA: snd-es1968: Make hardware volume buttons an input device (rev2)
    
    The hardware volume handling code in essence just detects key presses, and
    then does some hardcoded modification of the master volume based on which key
    is pressed.
    
    Clearly the right thing to do here is just report these keypresses to
    userspace and let userspace decide what to with them.
    
    This patch adds a Kconfig option which when enabled reports the volume
    buttons as keypresses using an input device. When enabled this option
    also gets rid of the ugly direct ac97 writes from the tasklet, the ac97lock
    and the need for using a tasklet in general.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index ecaea9fb48ec..aa973cee8155 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -104,6 +104,7 @@
 #include <linux/gameport.h>
 #include <linux/moduleparam.h>
 #include <linux/mutex.h>
+#include <linux/input.h>
 
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -517,14 +518,9 @@ struct es1968 {
 
 	/* ALSA Stuff */
 	struct snd_ac97 *ac97;
-	struct snd_kcontrol *master_switch; /* for h/w volume control */
-	struct snd_kcontrol *master_volume;
-
 	struct snd_rawmidi *rmidi;
 
 	spinlock_t reg_lock;
-	spinlock_t ac97_lock;
-	struct tasklet_struct hwvol_tq;
 	unsigned int in_suspend;
 
 	/* Maestro Stuff */
@@ -547,6 +543,16 @@ struct es1968 {
 #ifdef SUPPORT_JOYSTICK
 	struct gameport *gameport;
 #endif
+
+#ifdef CONFIG_SND_ES1968_INPUT
+	struct input_dev *input_dev;
+	char phys[64];			/* physical device path */
+#else
+	struct snd_kcontrol *master_switch; /* for h/w volume control */
+	struct snd_kcontrol *master_volume;
+	spinlock_t ac97_lock;
+	struct tasklet_struct hwvol_tq;
+#endif
 };
 
 static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id);
@@ -632,28 +638,38 @@ static int snd_es1968_ac97_wait_poll(struct es1968 *chip)
 static void snd_es1968_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)
 {
 	struct es1968 *chip = ac97->private_data;
+#ifndef CONFIG_SND_ES1968_INPUT
 	unsigned long flags;
+#endif
 
 	snd_es1968_ac97_wait(chip);
 
 	/* Write the bus */
+#ifndef CONFIG_SND_ES1968_INPUT
 	spin_lock_irqsave(&chip->ac97_lock, flags);
+#endif
 	outw(val, chip->io_port + ESM_AC97_DATA);
 	/*msleep(1);*/
 	outb(reg, chip->io_port + ESM_AC97_INDEX);
 	/*msleep(1);*/
+#ifndef CONFIG_SND_ES1968_INPUT
 	spin_unlock_irqrestore(&chip->ac97_lock, flags);
+#endif
 }
 
 static unsigned short snd_es1968_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
 {
 	u16 data = 0;
 	struct es1968 *chip = ac97->private_data;
+#ifndef CONFIG_SND_ES1968_INPUT
 	unsigned long flags;
+#endif
 
 	snd_es1968_ac97_wait(chip);
 
+#ifndef CONFIG_SND_ES1968_INPUT
 	spin_lock_irqsave(&chip->ac97_lock, flags);
+#endif
 	outb(reg | 0x80, chip->io_port + ESM_AC97_INDEX);
 	/*msleep(1);*/
 
@@ -661,7 +677,9 @@ static unsigned short snd_es1968_ac97_read(struct snd_ac97 *ac97, unsigned short
 		data = inw(chip->io_port + ESM_AC97_DATA);
 		/*msleep(1);*/
 	}
+#ifndef CONFIG_SND_ES1968_INPUT
 	spin_unlock_irqrestore(&chip->ac97_lock, flags);
+#endif
 
 	return data;
 }
@@ -1874,13 +1892,17 @@ static void snd_es1968_update_pcm(struct es1968 *chip, struct esschan *es)
 	}
 }
 
-/*
- */
+/* The hardware volume works by incrementing / decrementing 2 counters
+   (without wrap around) in response to volume button presses and then
+   generating an interrupt. The pair of counters is stored in bits 1-3 and 5-7
+   of a byte wide register. The meaning of bits 0 and 4 is unknown. */
 static void es1968_update_hw_volume(unsigned long private_data)
 {
 	struct es1968 *chip = (struct es1968 *) private_data;
 	int x, val;
+#ifndef CONFIG_SND_ES1968_INPUT
 	unsigned long flags;
+#endif
 
 	/* Figure out which volume control button was pushed,
 	   based on differences from the default register
@@ -1895,6 +1917,7 @@ static void es1968_update_hw_volume(unsigned long private_data)
 	if (chip->in_suspend)
 		return;
 
+#ifndef CONFIG_SND_ES1968_INPUT
 	if (! chip->master_switch || ! chip->master_volume)
 		return;
 
@@ -1937,6 +1960,35 @@ static void es1968_update_hw_volume(unsigned long private_data)
 		break;
 	}
 	spin_unlock_irqrestore(&chip->ac97_lock, flags);
+#else
+	if (!chip->input_dev)
+		return;
+
+	val = 0;
+	switch (x) {
+	case 0x88:
+		/* The counters have not changed, yet we've received a HV
+		   interrupt. According to tests run by various people this
+		   happens when pressing the mute button. */
+		val = KEY_MUTE;
+		break;
+	case 0xaa:
+		/* counters increased by 1 -> volume up */
+		val = KEY_VOLUMEUP;
+		break;
+	case 0x66:
+		/* counters decreased by 1 -> volume down */
+		val = KEY_VOLUMEDOWN;
+		break;
+	}
+
+	if (val) {
+		input_report_key(chip->input_dev, val, 1);
+		input_sync(chip->input_dev);
+		input_report_key(chip->input_dev, val, 0);
+		input_sync(chip->input_dev);
+	}
+#endif
 }
 
 /*
@@ -1953,7 +2005,11 @@ static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id)
 	outw(inw(chip->io_port + 4) & 1, chip->io_port + 4);
 
 	if (event & ESM_HWVOL_IRQ)
+#ifdef CONFIG_SND_ES1968_INPUT
+		es1968_update_hw_volume((unsigned long)chip);
+#else
 		tasklet_schedule(&chip->hwvol_tq); /* we'll do this later */
+#endif
 
 	/* else ack 'em all, i imagine */
 	outb(0xFF, chip->io_port + 0x1A);
@@ -1993,7 +2049,9 @@ snd_es1968_mixer(struct es1968 *chip)
 {
 	struct snd_ac97_bus *pbus;
 	struct snd_ac97_template ac97;
+#ifndef CONFIG_SND_ES1968_INPUT
 	struct snd_ctl_elem_id elem_id;
+#endif
 	int err;
 	static struct snd_ac97_bus_ops ops = {
 		.write = snd_es1968_ac97_write,
@@ -2009,6 +2067,7 @@ snd_es1968_mixer(struct es1968 *chip)
 	if ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97)) < 0)
 		return err;
 
+#ifndef CONFIG_SND_ES1968_INPUT
 	/* attach master switch / volumes for h/w volume control */
 	memset(&elem_id, 0, sizeof(elem_id));
 	elem_id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
@@ -2018,6 +2077,7 @@ snd_es1968_mixer(struct es1968 *chip)
 	elem_id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 	strcpy(elem_id.name, "Master Playback Volume");
 	chip->master_volume = snd_ctl_find_id(chip->card, &elem_id);
+#endif
 
 	return 0;
 }
@@ -2474,8 +2534,49 @@ static inline int snd_es1968_create_gameport(struct es1968 *chip, int dev) { ret
 static inline void snd_es1968_free_gameport(struct es1968 *chip) { }
 #endif
 
+#ifdef CONFIG_SND_ES1968_INPUT
+static int __devinit snd_es1968_input_register(struct es1968 *chip)
+{
+	struct input_dev *input_dev;
+	int err;
+
+	input_dev = input_allocate_device();
+	if (!input_dev)
+		return -ENOMEM;
+
+	snprintf(chip->phys, sizeof(chip->phys), "pci-%s/input0",
+		 pci_name(chip->pci));
+
+	input_dev->name = chip->card->driver;
+	input_dev->phys = chip->phys;
+	input_dev->id.bustype = BUS_PCI;
+	input_dev->id.vendor  = chip->pci->vendor;
+	input_dev->id.product = chip->pci->device;
+	input_dev->dev.parent = &chip->pci->dev;
+
+	__set_bit(EV_KEY, input_dev->evbit);
+	__set_bit(KEY_MUTE, input_dev->keybit);
+	__set_bit(KEY_VOLUMEDOWN, input_dev->keybit);
+	__set_bit(KEY_VOLUMEUP, input_dev->keybit);
+
+	err = input_register_device(input_dev);
+	if (err) {
+		input_free_device(input_dev);
+		return err;
+	}
+
+	chip->input_dev = input_dev;
+	return 0;
+}
+#endif /* CONFIG_SND_ES1968_INPUT */
+
 static int snd_es1968_free(struct es1968 *chip)
 {
+#ifdef CONFIG_SND_ES1968_INPUT
+	if (chip->input_dev)
+		input_unregister_device(chip->input_dev);
+#endif
+
 	if (chip->io_port) {
 		if (chip->irq >= 0)
 			synchronize_irq(chip->irq);
@@ -2486,8 +2587,6 @@ static int snd_es1968_free(struct es1968 *chip)
 	if (chip->irq >= 0)
 		free_irq(chip->irq, chip);
 	snd_es1968_free_gameport(chip);
-	chip->master_switch = NULL;
-	chip->master_volume = NULL;
 	pci_release_regions(chip->pci);
 	pci_disable_device(chip->pci);
 	kfree(chip);
@@ -2558,9 +2657,11 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 	spin_lock_init(&chip->substream_lock);
 	INIT_LIST_HEAD(&chip->buf_list);
 	INIT_LIST_HEAD(&chip->substream_list);
-	spin_lock_init(&chip->ac97_lock);
 	mutex_init(&chip->memory_mutex);
+#ifndef CONFIG_SND_ES1968_INPUT
+	spin_lock_init(&chip->ac97_lock);
 	tasklet_init(&chip->hwvol_tq, es1968_update_hw_volume, (unsigned long)chip);
+#endif
 	chip->card = card;
 	chip->pci = pci;
 	chip->irq = -1;
@@ -2713,6 +2814,13 @@ static int __devinit snd_es1968_probe(struct pci_dev *pci,
 
 	snd_es1968_create_gameport(chip, dev);
 
+#ifdef CONFIG_SND_ES1968_INPUT
+	err = snd_es1968_input_register(chip);
+	if (err)
+		snd_printk(KERN_WARNING "Input device registration "
+			"failed with error %i", err);
+#endif
+
 	snd_es1968_start_irq(chip);
 
 	chip->clock = clock[dev];

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index a11f453a6b6d..ecaea9fb48ec 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -551,7 +551,7 @@ struct es1968 {
 
 static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id);
 
-static struct pci_device_id snd_es1968_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_es1968_ids) = {
 	/* Maestro 1 */
         { 0x1285, 0x0100, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, TYPE_MAESTRO },
 	/* Maestro 2 */

commit ce0b620160e6d15a7f5b4b00cd7b8bd956d427d1
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:17 2009 -0700

    dma-mapping: replace all DMA_28BIT_MASK macro with DMA_BIT_MASK(28)
    
    Replace all DMA_28BIT_MASK macro with DMA_BIT_MASK(28)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index dc97e8116141..a11f453a6b6d 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2539,8 +2539,8 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 	/* check, if we can restrict PCI DMA transfers to 28 bits */
-	if (pci_set_dma_mask(pci, DMA_28BIT_MASK) < 0 ||
-	    pci_set_consistent_dma_mask(pci, DMA_28BIT_MASK) < 0) {
+	if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) < 0 ||
+	    pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) < 0) {
 		snd_printk(KERN_ERR "architecture does not support 28bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index e9c3794bbcb8..dc97e8116141 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2645,9 +2645,9 @@ static int __devinit snd_es1968_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
-	if (!card)
-		return -ENOMEM;
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	if (err < 0)
+		return err;
                 
 	if (total_bufsize[dev] < 128)
 		total_bufsize[dev] = 128;

commit 1f04128a3db7c0f0e8b5d25323eba70ac342f47f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 18 12:17:55 2008 +0100

    ALSA: hda - Convert from takslet_hi_schedule() to tasklet_schedule()
    
    Replace all tasklet_hi_schedule() callers with the normal
    tasklet_schedule().  The former often causes troubles with
    RT-kernels, and has actually no merit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 20ee7599600b..e9c3794bbcb8 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1953,7 +1953,7 @@ static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id)
 	outw(inw(chip->io_port + 4) & 1, chip->io_port + 4);
 
 	if (event & ESM_HWVOL_IRQ)
-		tasklet_hi_schedule(&chip->hwvol_tq); /* we'll do this later */
+		tasklet_schedule(&chip->hwvol_tq); /* we'll do this later */
 
 	/* else ack 'em all, i imagine */
 	outb(0xFF, chip->io_port + 0x1A);

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 1bf298d214b9..20ee7599600b 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -692,7 +692,8 @@ static void apu_data_set(struct es1968 *chip, u16 data)
 /* no spinlock */
 static void __apu_set_register(struct es1968 *chip, u16 channel, u8 reg, u16 data)
 {
-	snd_assert(channel < NR_APUS, return);
+	if (snd_BUG_ON(channel >= NR_APUS))
+		return;
 #ifdef CONFIG_PM
 	chip->apu_map[channel][reg] = data;
 #endif
@@ -711,7 +712,8 @@ static void apu_set_register(struct es1968 *chip, u16 channel, u8 reg, u16 data)
 
 static u16 __apu_get_register(struct es1968 *chip, u16 channel, u8 reg)
 {
-	snd_assert(channel < NR_APUS, return 0);
+	if (snd_BUG_ON(channel >= NR_APUS))
+		return 0;
 	reg |= (channel << 4);
 	apu_index_set(chip, reg);
 	return __maestro_read(chip, IDR0_DATA_PORT);

commit f000fd80937c0d94c67f9f3e7026f1fbc8ef8873
Author: Jeff Garzik <jgarzik@redhat.com>
Date:   Tue Apr 22 13:50:34 2008 +0200

    [ALSA] Fix synchronize_irq() bugs, redundancies
    
    free_irq() calls synchronize_irq() for you, so there is no need for
    drivers to manually do the same thing (again).  Thus, calls where
    sync-irq immediately precedes free-irq can be simplified.
    
    However, during this audit several bugs were noticed, where free-irq is
    preceded by a "irq >= 0" check... but the sync-irq call is not covered
    by the same check.
    
    So, where sync-irq could not be eliminated completely, the missing check
    was added.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 138379896061..1bf298d214b9 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2475,7 +2475,8 @@ static inline void snd_es1968_free_gameport(struct es1968 *chip) { }
 static int snd_es1968_free(struct es1968 *chip)
 {
 	if (chip->io_port) {
-		synchronize_irq(chip->irq);
+		if (chip->irq >= 0)
+			synchronize_irq(chip->irq);
 		outw(1, chip->io_port + 0x04); /* clear WP interrupts */
 		outw(0, chip->io_port + ESM_PORT_HOST_IRQ); /* disable IRQ */
 	}

commit 66c9aa6043798197e1760eaf4c5f510d6c69b95a
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon Apr 14 13:09:33 2008 +0200

    [ALSA] es1968 - fix coding style in the last patch
    
    WARNING: braces {} are not necessary for single statement blocks
    #40: FILE: sound/pci/es1968.c:1831:
    +       if (diff > 1) {
    +               __maestro_write(chip, IDR0_DATA_PORT, cp1);
    +       }
    
    total: 0 errors, 1 warnings, 35 lines checked
    
    ./patches/es1968-fix-jitter-on-some-maestro-cards.patch has style problems, please review.  If any of these errors
    are false positives report them to the maintainer, see
    CHECKPATCH in MAINTAINERS.
    
    Please run checkpatch prior to sending patches
    
    Cc: Andreas Mueller <andreas@stapelspeicher.org>
    Tested-by: Rene Herman <rene.herman@keyaccess.nl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index f8f3bb662d17..138379896061 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1840,9 +1840,8 @@ static void snd_es1968_suppress_jitter(struct es1968 *chip, struct esschan *es)
 	cp2 = __apu_get_register(chip, 1, 5);
 	diff = (cp1 > cp2 ? cp1 - cp2 : cp2 - cp1);
 
-	if (diff > 1) {
+	if (diff > 1)
 		__maestro_write(chip, IDR0_DATA_PORT, cp1);
-	}
 }
 
 /*

commit f24bfa53dab478e1bde2d7fd39d3c1a69dc518f1
Author: Andreas Mueller <andreas@stapelspeicher.org>
Date:   Mon Apr 14 13:08:05 2008 +0200

    [ALSA] es1968: fix jitter on some maestro cards
    
    This patch suppresses jitter on several Maestro cards in stereo mode (ALSA of
    course).
    
    The patch is also incorporated in the *BSD drivers where I "ported" it from.
    
    Without this patch most of the stereo audio gets out of sync and really
    distorted (oss-emulation with mplayer at 48000khz worked somehow).
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 67f03264f871..f8f3bb662d17 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1827,6 +1827,23 @@ snd_es1968_pcm(struct es1968 *chip, int device)
 
 	return 0;
 }
+/*
+ * suppress jitter on some maestros when playing stereo
+ */
+static void snd_es1968_suppress_jitter(struct es1968 *chip, struct esschan *es)
+{
+	unsigned int cp1;
+	unsigned int cp2;
+	unsigned int diff;
+
+	cp1 = __apu_get_register(chip, 0, 5);
+	cp2 = __apu_get_register(chip, 1, 5);
+	diff = (cp1 > cp2 ? cp1 - cp2 : cp2 - cp1);
+
+	if (diff > 1) {
+		__maestro_write(chip, IDR0_DATA_PORT, cp1);
+	}
+}
 
 /*
  * update pointer
@@ -1948,8 +1965,11 @@ static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id)
 		struct esschan *es;
 		spin_lock(&chip->substream_lock);
 		list_for_each_entry(es, &chip->substream_list, list) {
-			if (es->running)
+			if (es->running) {
 				snd_es1968_update_pcm(chip, es);
+				if (es->fmt & ESS_FMT_STEREO)
+					snd_es1968_suppress_jitter(chip, es);
+			}
 		}
 		spin_unlock(&chip->substream_lock);
 		if (chip->in_measurement) {

commit 3463d8fa14ba2e00ede9894efdaa65189eb04b36
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Feb 28 11:53:41 2008 +0100

    [ALSA] sound: es1968.c fox shadowed variable warning
    
    id is used when initializing the mixer elements, use elem_id here
    instead.
    sound/pci/es1968.c:1963:25: warning: symbol 'id' shadows an earlier one
    sound/pci/es1968.c:129:13: originally declared here
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 7d911a18c082..67f03264f871 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1972,7 +1972,7 @@ snd_es1968_mixer(struct es1968 *chip)
 {
 	struct snd_ac97_bus *pbus;
 	struct snd_ac97_template ac97;
-	struct snd_ctl_elem_id id;
+	struct snd_ctl_elem_id elem_id;
 	int err;
 	static struct snd_ac97_bus_ops ops = {
 		.write = snd_es1968_ac97_write,
@@ -1989,14 +1989,14 @@ snd_es1968_mixer(struct es1968 *chip)
 		return err;
 
 	/* attach master switch / volumes for h/w volume control */
-	memset(&id, 0, sizeof(id));
-	id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
-	strcpy(id.name, "Master Playback Switch");
-	chip->master_switch = snd_ctl_find_id(chip->card, &id);
-	memset(&id, 0, sizeof(id));
-	id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
-	strcpy(id.name, "Master Playback Volume");
-	chip->master_volume = snd_ctl_find_id(chip->card, &id);
+	memset(&elem_id, 0, sizeof(elem_id));
+	elem_id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	strcpy(elem_id.name, "Master Playback Switch");
+	chip->master_switch = snd_ctl_find_id(chip->card, &elem_id);
+	memset(&elem_id, 0, sizeof(elem_id));
+	elem_id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	strcpy(elem_id.name, "Master Playback Volume");
+	chip->master_volume = snd_ctl_find_id(chip->card, &elem_id);
 
 	return 0;
 }

commit 4b47c971dc947cadecc20dc7681037e96ece520e
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Tue Apr 8 17:41:55 2008 -0700

    es1968: fix sleep-while-holding-lock bug
    
    snd_es1968_ac97_read() calls snd_es1968_ac97_wait() first outside a locked
    area, and later, while holding a lock.
    
    snd_es1968_ac97_wait() has a polling loop with a cond_resched() inside it..
    which sleeps, so the second call is invalid.
    
    This patch adds a version of the wait function that just pure polls.  While
    this is not very elegant in principle, it's very likely the easiest thing to
    do here, we already checked if the chip was ready (while yielding) just
    before, so it is very unlikely to take a long time here.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 25ccfce45759..7d911a18c082 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -617,6 +617,18 @@ static int snd_es1968_ac97_wait(struct es1968 *chip)
 	return 1; /* timeout */
 }
 
+static int snd_es1968_ac97_wait_poll(struct es1968 *chip)
+{
+	int timeout = 100000;
+
+	while (timeout-- > 0) {
+		if (!(inb(chip->io_port + ESM_AC97_INDEX) & 1))
+			return 0;
+	}
+	snd_printd("es1968: ac97 timeout\n");
+	return 1; /* timeout */
+}
+
 static void snd_es1968_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)
 {
 	struct es1968 *chip = ac97->private_data;
@@ -645,7 +657,7 @@ static unsigned short snd_es1968_ac97_read(struct snd_ac97 *ac97, unsigned short
 	outb(reg | 0x80, chip->io_port + ESM_AC97_INDEX);
 	/*msleep(1);*/
 
-	if (! snd_es1968_ac97_wait(chip)) {
+	if (!snd_es1968_ac97_wait_poll(chip)) {
 		data = inw(chip->io_port + ESM_AC97_DATA);
 		/*msleep(1);*/
 	}

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index d69b11d1f993..25ccfce45759 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -94,7 +94,6 @@
  *	places.
  */
 
-#include <sound/driver.h>
 #include <asm/io.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>

commit 50f47ff1b9295f126a1256d607e5b6e951d6f34e
Author: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
Date:   Mon Sep 17 14:39:05 2007 +0200

    [ALSA] ESS Maestro 1/2/2E Sound Card: Use list_for_each_entry
    
    ESS Maestro 1/2/2E Sound Card: Use list_for_each_entry instead of
    list_for_each
    
    Signed-off-by: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 2faf009076bb..d69b11d1f993 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -843,10 +843,9 @@ static void snd_es1968_bob_dec(struct es1968 *chip)
 		snd_es1968_bob_stop(chip);
 	else if (chip->bob_freq > ESM_BOB_FREQ) {
 		/* check reduction of timer frequency */
-		struct list_head *p;
 		int max_freq = ESM_BOB_FREQ;
-		list_for_each(p, &chip->substream_list) {
-			struct esschan *es = list_entry(p, struct esschan, list);
+		struct esschan *es;
+		list_for_each_entry(es, &chip->substream_list, list) {
 			if (max_freq < es->bob_freq)
 				max_freq = es->bob_freq;
 		}
@@ -1316,12 +1315,11 @@ static struct snd_pcm_hardware snd_es1968_capture = {
 
 static int calc_available_memory_size(struct es1968 *chip)
 {
-	struct list_head *p;
 	int max_size = 0;
-	
+	struct esm_memory *buf;
+
 	mutex_lock(&chip->memory_mutex);
-	list_for_each(p, &chip->buf_list) {
-		struct esm_memory *buf = list_entry(p, struct esm_memory, list);
+	list_for_each_entry(buf, &chip->buf_list, list) {
 		if (buf->empty && buf->buf.bytes > max_size)
 			max_size = buf->buf.bytes;
 	}
@@ -1335,12 +1333,10 @@ static int calc_available_memory_size(struct es1968 *chip)
 static struct esm_memory *snd_es1968_new_memory(struct es1968 *chip, int size)
 {
 	struct esm_memory *buf;
-	struct list_head *p;
-	
+
 	size = ALIGN(size, ESM_MEM_ALIGN);
 	mutex_lock(&chip->memory_mutex);
-	list_for_each(p, &chip->buf_list) {
-		buf = list_entry(p, struct esm_memory, list);
+	list_for_each_entry(buf, &chip->buf_list, list) {
 		if (buf->empty && buf->buf.bytes >= size)
 			goto __found;
 	}
@@ -1938,10 +1934,9 @@ static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id)
 	}
 
 	if (event & ESM_SOUND_IRQ) {
-		struct list_head *p;
+		struct esschan *es;
 		spin_lock(&chip->substream_lock);
-		list_for_each(p, &chip->substream_list) {
-			struct esschan *es = list_entry(p, struct esschan, list);
+		list_for_each_entry(es, &chip->substream_list, list) {
 			if (es->running)
 				snd_es1968_update_pcm(chip, es);
 		}
@@ -2345,7 +2340,7 @@ static int es1968_resume(struct pci_dev *pci)
 {
 	struct snd_card *card = pci_get_drvdata(pci);
 	struct es1968 *chip = card->private_data;
-	struct list_head *p;
+	struct esschan *es;
 
 	if (! chip->do_pm)
 		return 0;
@@ -2374,8 +2369,7 @@ static int es1968_resume(struct pci_dev *pci)
 	/* restore ac97 state */
 	snd_ac97_resume(chip->ac97);
 
-	list_for_each(p, &chip->substream_list) {
-		struct esschan *es = list_entry(p, struct esschan, list);
+	list_for_each_entry(es, &chip->substream_list, list) {
 		switch (es->mode) {
 		case ESM_MODE_PLAY:
 			snd_es1968_playback_setup(chip, es, es->substream->runtime);

commit b942cf815b5775288550f99f3790e29815bb70cb
Author: Rene Herman <rene.herman@gmail.com>
Date:   Wed Mar 28 15:23:53 2007 +0200

    [ALSA] es1968 - Fix stuttering capture
    
    Looks like the buffer size for the stereo capture has to be a
    power of two.  Now added a constraint to buffer bytes.
    Also removed unnecessary #if 0 lines.
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index dc84c189b05f..2faf009076bb 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1554,10 +1554,7 @@ static int snd_es1968_playback_open(struct snd_pcm_substream *substream)
 	runtime->hw = snd_es1968_playback;
 	runtime->hw.buffer_bytes_max = runtime->hw.period_bytes_max =
 		calc_available_memory_size(chip);
-#if 0
-	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
-				   1024);
-#endif
+
 	spin_lock_irq(&chip->substream_lock);
 	list_add(&es->list, &chip->substream_list);
 	spin_unlock_irq(&chip->substream_lock);
@@ -1613,10 +1610,8 @@ static int snd_es1968_capture_open(struct snd_pcm_substream *substream)
 	runtime->hw = snd_es1968_capture;
 	runtime->hw.buffer_bytes_max = runtime->hw.period_bytes_max =
 		calc_available_memory_size(chip) - 1024; /* keep MIXBUF size */
-#if 0
-	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
-				   1024);
-#endif
+	snd_pcm_hw_constraint_pow2(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES);
+
 	spin_lock_irq(&chip->substream_lock);
 	list_add(&es->list, &chip->substream_list);
 	spin_unlock_irq(&chip->substream_lock);

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 01c521d1b460..dc84c189b05f 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2462,7 +2462,7 @@ static int snd_es1968_free(struct es1968 *chip)
 	}
 
 	if (chip->irq >= 0)
-		free_irq(chip->irq, (void *)chip);
+		free_irq(chip->irq, chip);
 	snd_es1968_free_gameport(chip);
 	chip->master_switch = NULL;
 	chip->master_volume = NULL;
@@ -2552,8 +2552,8 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 		return err;
 	}
 	chip->io_port = pci_resource_start(pci, 0);
-	if (request_irq(pci->irq, snd_es1968_interrupt, IRQF_DISABLED|IRQF_SHARED,
-			"ESS Maestro", (void*)chip)) {
+	if (request_irq(pci->irq, snd_es1968_interrupt, IRQF_SHARED,
+			"ESS Maestro", chip)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_es1968_free(chip);
 		return -EBUSY;

commit 7ab399262ee636d19db5163a35ac406d5b892a0a
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Oct 9 08:13:32 2006 +0200

    [ALSA] use the ALIGN macro
    
    Use the ALIGN macro instead of manual calculations.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 092da53e1464..01c521d1b460 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1337,7 +1337,7 @@ static struct esm_memory *snd_es1968_new_memory(struct es1968 *chip, int size)
 	struct esm_memory *buf;
 	struct list_head *p;
 	
-	size = ((size + ESM_MEM_ALIGN - 1) / ESM_MEM_ALIGN) * ESM_MEM_ALIGN;
+	size = ALIGN(size, ESM_MEM_ALIGN);
 	mutex_lock(&chip->memory_mutex);
 	list_for_each(p, &chip->buf_list) {
 		buf = list_entry(p, struct esm_memory, list);

commit 30b35399ceb2398d05837863476dcb12f12f3a82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 11 18:52:53 2006 +0200

    [ALSA] Various fixes for suspend/resume of ALSA PCI drivers
    
    - Check the return value of pci_enable_device() and request_irq()
      in the suspend.  If any error occurs there, disable the device
      using snd_card_disconnect().
    - Call pci_set_power_state() properly with pci_choose_state().
    - Fix the order to call pci_set_power_state().
    - Removed obsolete house-made PM codes in some drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index b9d723c7e1db..092da53e1464 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -432,46 +432,6 @@ MODULE_PARM_DESC(joystick, "Enable joystick.");
 #define ESM_MODE_PLAY		0
 #define ESM_MODE_CAPTURE	1
 
-/* acpi states */
-enum {
-	ACPI_D0=0,
-	ACPI_D1,
-	ACPI_D2,
-	ACPI_D3
-};
-
-/* bits in the acpi masks */
-#define ACPI_12MHZ	( 1 << 15)
-#define ACPI_24MHZ	( 1 << 14)
-#define ACPI_978	( 1 << 13)
-#define ACPI_SPDIF	( 1 << 12)
-#define ACPI_GLUE	( 1 << 11)
-#define ACPI__10	( 1 << 10) /* reserved */
-#define ACPI_PCIINT	( 1 << 9)
-#define ACPI_HV		( 1 << 8) /* hardware volume */
-#define ACPI_GPIO	( 1 << 7)
-#define ACPI_ASSP	( 1 << 6)
-#define ACPI_SB		( 1 << 5) /* sb emul */
-#define ACPI_FM		( 1 << 4) /* fm emul */
-#define ACPI_RB		( 1 << 3) /* ringbus / aclink */
-#define ACPI_MIDI	( 1 << 2) 
-#define ACPI_GP		( 1 << 1) /* game port */
-#define ACPI_WP		( 1 << 0) /* wave processor */
-
-#define ACPI_ALL	(0xffff)
-#define ACPI_SLEEP	(~(ACPI_SPDIF|ACPI_ASSP|ACPI_SB|ACPI_FM| \
-			ACPI_MIDI|ACPI_GP|ACPI_WP))
-#define ACPI_NONE	(ACPI__10)
-
-/* these masks indicate which units we care about at
-	which states */
-static u16 acpi_state_mask[] = {
-	[ACPI_D0] = ACPI_ALL,
-	[ACPI_D1] = ACPI_SLEEP,
-	[ACPI_D2] = ACPI_SLEEP,
-	[ACPI_D3] = ACPI_NONE
-};
-
 
 /* APU use in the driver */
 enum snd_enum_apu_type {
@@ -2159,21 +2119,6 @@ static void snd_es1968_reset(struct es1968 *chip)
 	udelay(10);
 }
 
-/*
- * power management
- */
-static void snd_es1968_set_acpi(struct es1968 *chip, int state)
-{
-	u16 active_mask = acpi_state_mask[state];
-
-	pci_set_power_state(chip->pci, state);
-	/* make sure the units we care about are on 
-		XXX we might want to do this before state flipping? */
-	pci_write_config_word(chip->pci, 0x54, ~ active_mask);
-	pci_write_config_word(chip->pci, 0x56, ~ active_mask);
-}
-
-
 /*
  * initialize maestro chip
  */
@@ -2196,9 +2141,6 @@ static void snd_es1968_chip_init(struct es1968 *chip)
 	 * IRQs.
 	 */
 	
-	/* do config work at full power */
-	snd_es1968_set_acpi(chip, ACPI_D0);
-
 	/* Config Reg A */
 	pci_read_config_word(pci, ESM_CONFIG_A, &w);
 
@@ -2397,9 +2339,10 @@ static int es1968_suspend(struct pci_dev *pci, pm_message_t state)
 	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
 	snd_es1968_bob_stop(chip);
-	snd_es1968_set_acpi(chip, ACPI_D3);
+
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -2413,9 +2356,16 @@ static int es1968_resume(struct pci_dev *pci)
 		return 0;
 
 	/* restore all our config */
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "es1968: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
+
 	snd_es1968_chip_init(chip);
 
 	/* need to restore the base pointers.. */ 
@@ -2514,7 +2464,6 @@ static int snd_es1968_free(struct es1968 *chip)
 	if (chip->irq >= 0)
 		free_irq(chip->irq, (void *)chip);
 	snd_es1968_free_gameport(chip);
-	snd_es1968_set_acpi(chip, ACPI_D3);
 	chip->master_switch = NULL;
 	chip->master_volume = NULL;
 	pci_release_regions(chip->pci);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index f3c40385c87d..b9d723c7e1db 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -590,7 +590,7 @@ struct es1968 {
 #endif
 };
 
-static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id);
 
 static struct pci_device_id snd_es1968_ids[] = {
 	/* Maestro 1 */
@@ -1962,7 +1962,7 @@ static void es1968_update_hw_volume(unsigned long private_data)
 /*
  * interrupt handler
  */
-static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id)
 {
 	struct es1968 *chip = dev_id;
 	u32 event;
@@ -1979,7 +1979,7 @@ static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id, struct pt_regs *r
 	outb(0xFF, chip->io_port + 0x1A);
 
 	if ((event & ESM_MPU401_IRQ) && chip->rmidi) {
-		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data, regs);
+		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);
 	}
 
 	if (event & ESM_SOUND_IRQ) {

commit 679e28eef835cbd30de78c2f80bf488cba1b7e40
Author: Ville Syrjala <syrjala@sci.fi>
Date:   Mon Sep 4 12:28:51 2006 +0200

    [ALSA] es1968: Fix hw volume
    
    Fix maestro2 hardware volume control. Tested on a Dell Inspiron 7000.
    
    Signed-off-by: Ville Syrjala <syrjala@sci.fi>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 3c5ab7c2e72d..f3c40385c87d 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1905,7 +1905,7 @@ static void es1968_update_hw_volume(unsigned long private_data)
 	/* Figure out which volume control button was pushed,
 	   based on differences from the default register
 	   values. */
-	x = inb(chip->io_port + 0x1c);
+	x = inb(chip->io_port + 0x1c) & 0xee;
 	/* Reset the volume control registers. */
 	outb(0x88, chip->io_port + 0x1c);
 	outb(0x88, chip->io_port + 0x1d);
@@ -1921,7 +1921,8 @@ static void es1968_update_hw_volume(unsigned long private_data)
 	/* FIXME: we can't call snd_ac97_* functions since here is in tasklet. */
 	spin_lock_irqsave(&chip->ac97_lock, flags);
 	val = chip->ac97->regs[AC97_MASTER];
-	if (x & 1) {
+	switch (x) {
+	case 0x88:
 		/* mute */
 		val ^= 0x8000;
 		chip->ac97->regs[AC97_MASTER] = val;
@@ -1929,26 +1930,31 @@ static void es1968_update_hw_volume(unsigned long private_data)
 		outb(AC97_MASTER, chip->io_port + ESM_AC97_INDEX);
 		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
 			       &chip->master_switch->id);
-	} else {
-		val &= 0x7fff;
-		if (((x>>1) & 7) > 4) {
-			/* volume up */
-			if ((val & 0xff) > 0)
-				val--;
-			if ((val & 0xff00) > 0)
-				val -= 0x0100;
-		} else {
-			/* volume down */
-			if ((val & 0xff) < 0x1f)
-				val++;
-			if ((val & 0xff00) < 0x1f00)
-				val += 0x0100;
-		}
+		break;
+	case 0xaa:
+		/* volume up */
+		if ((val & 0x7f) > 0)
+			val--;
+		if ((val & 0x7f00) > 0)
+			val -= 0x0100;
+		chip->ac97->regs[AC97_MASTER] = val;
+		outw(val, chip->io_port + ESM_AC97_DATA);
+		outb(AC97_MASTER, chip->io_port + ESM_AC97_INDEX);
+		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+			       &chip->master_volume->id);
+		break;
+	case 0x66:
+		/* volume down */
+		if ((val & 0x7f) < 0x1f)
+			val++;
+		if ((val & 0x7f00) < 0x1f00)
+			val += 0x0100;
 		chip->ac97->regs[AC97_MASTER] = val;
 		outw(val, chip->io_port + ESM_AC97_DATA);
 		outb(AC97_MASTER, chip->io_port + ESM_AC97_INDEX);
 		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
 			       &chip->master_volume->id);
+		break;
 	}
 	spin_unlock_irqrestore(&chip->ac97_lock, flags);
 }

commit f40b68903ccd511ea9d658b4bce319dd032a265a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 16:51:05 2006 +0200

    [ALSA] Fix section mismatch errors in ALSA PCI drivers
    
    Fixed 'section mismatch' errors in ALSA PCI drivers:
    - removed invalid __devinitdata from pci id tables
    - fix/remove __devinit of functions called in suspend/resume
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index a491c8f8a6a8..3c5ab7c2e72d 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -592,7 +592,7 @@ struct es1968 {
 
 static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 
-static struct pci_device_id snd_es1968_ids[] __devinitdata = {
+static struct pci_device_id snd_es1968_ids[] = {
 	/* Maestro 1 */
         { 0x1285, 0x0100, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, TYPE_MAESTRO },
 	/* Maestro 2 */

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index bfa0876e715e..a491c8f8a6a8 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2597,7 +2597,7 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 		return err;
 	}
 	chip->io_port = pci_resource_start(pci, 0);
-	if (request_irq(pci->irq, snd_es1968_interrupt, SA_INTERRUPT|SA_SHIRQ,
+	if (request_irq(pci->irq, snd_es1968_interrupt, IRQF_DISABLED|IRQF_SHARED,
 			"ESS Maestro", (void*)chip)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_es1968_free(chip);

commit 302e4c2f9e2b9f07c69649782330a61c60001ac4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 23 13:24:30 2006 +0200

    [ALSA] Change an arugment of snd_mpu401_uart_new() to bit flags
    
    Change the 5th argument of snd_mpu401_uart_new() to bit flags
    instead of a boolean.  The argument takes bits that consist of
    MPU401_INFO_XXX flags.
    The callers that used the value 1 there are replaced with
    MPU401_INFO_INTEGRATED.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index f43bd380ac28..bfa0876e715e 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2727,7 +2727,8 @@ static int __devinit snd_es1968_probe(struct pci_dev *pci,
 	}
 	if (enable_mpu[dev]) {
 		if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
-					       chip->io_port + ESM_MPU401_PORT, 1,
+					       chip->io_port + ESM_MPU401_PORT,
+					       MPU401_INFO_INTEGRATED,
 					       chip->irq, 0, &chip->rmidi)) < 0) {
 			printk(KERN_WARNING "es1968: skipping MPU-401 MIDI support..\n");
 		}

commit 6581f4e74d8541dd7d579f64e94822622cbb1654
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 17 17:14:51 2006 +0200

    [ALSA] Remove zero-initialization of static variables
    
    Removed zero-initializations of static variables.
    A tiny optimization.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 5ff4175c7b6d..f43bd380ac28 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -132,7 +132,7 @@ static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card *
 static int total_bufsize[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1024 };
 static int pcm_substreams_p[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 4 };
 static int pcm_substreams_c[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1 };
-static int clock[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
+static int clock[SNDRV_CARDS];
 static int use_pm[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
 static int enable_mpu[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
 #ifdef SUPPORT_JOYSTICK

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index dd465a186e11..5ff4175c7b6d 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -592,7 +592,7 @@ struct es1968 {
 
 static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 
-static struct pci_device_id snd_es1968_ids[] = {
+static struct pci_device_id snd_es1968_ids[] __devinitdata = {
 	/* Maestro 1 */
         { 0x1285, 0x0100, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, TYPE_MAESTRO },
 	/* Maestro 2 */

commit 1d606f1ae5b9d83d8749f21bc04842596104bf55
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Apr 18 13:37:08 2006 +0200

    [ALSA] sound/pci/: remove duplicate #include's
    
    There's no reason for #include'ing linux/dma-mapping.h more than once.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index e3ad17f53c29..dd465a186e11 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -104,7 +104,6 @@
 #include <linux/slab.h>
 #include <linux/gameport.h>
 #include <linux/moduleparam.h>
-#include <linux/dma-mapping.h>
 #include <linux/mutex.h>
 
 #include <sound/core.h>

commit 910638ae7ed4be27d6af55f6c9b5bf54b838e78b
Author: Matthias Gehre <M.Gehre@gmx.de>
Date:   Tue Mar 28 01:56:48 2006 -0800

    [PATCH] Replace 0xff.. with correct DMA_xBIT_MASK
    
    Replace all occurences of 0xff..  in calls to function pci_set_dma_mask()
    and pci_set_consistant_dma_mask() with the corresponding DMA_xBIT_MASK from
    linux/dma-mapping.h.
    
    Signed-off-by: Matthias Gehre <M.Gehre@gmx.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index dd465a186e11..e3ad17f53c29 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -104,6 +104,7 @@
 #include <linux/slab.h>
 #include <linux/gameport.h>
 #include <linux/moduleparam.h>
+#include <linux/dma-mapping.h>
 #include <linux/mutex.h>
 
 #include <sound/core.h>

commit 9d2f928ddf64ca0361562e30faf584cd33055c60
Author: Tobias Klauser <tklauser@nuerscht.ch>
Date:   Wed Mar 22 10:53:19 2006 +0100

    [PATCH] Intruduce DMA_28BIT_MASK
    
    This patch introduces the DMA_28BIT_MASK constant in dma-mapping.h
    ALSA drivers using this mask are changed to use the new constant.
    
    Signed-off-by: Tobias Klauser <tklauser@nuerscht.ch>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 6a265ab3894e..dd465a186e11 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -100,6 +100,7 @@
 #include <linux/interrupt.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/dma-mapping.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
 #include <linux/moduleparam.h>
@@ -2561,8 +2562,8 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 	/* check, if we can restrict PCI DMA transfers to 28 bits */
-	if (pci_set_dma_mask(pci, 0x0fffffff) < 0 ||
-	    pci_set_consistent_dma_mask(pci, 0x0fffffff) < 0) {
+	if (pci_set_dma_mask(pci, DMA_28BIT_MASK) < 0 ||
+	    pci_set_consistent_dma_mask(pci, DMA_28BIT_MASK) < 0) {
 		snd_printk(KERN_ERR "architecture does not support 28bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;

commit 62932df8fb20ba2fb53a95fa52445eba22e821fe
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:34:20 2006 +0100

    [ALSA] semaphore -> mutex (PCI part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 3747a436f0cd..6a265ab3894e 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -103,6 +103,8 @@
 #include <linux/slab.h>
 #include <linux/gameport.h>
 #include <linux/moduleparam.h>
+#include <linux/mutex.h>
+
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/mpu401.h>
@@ -569,7 +571,7 @@ struct es1968 {
 	u16 maestro_map[32];
 	int bobclient;		/* active timer instancs */
 	int bob_freq;		/* timer frequency */
-	struct semaphore memory_mutex;	/* memory lock */
+	struct mutex memory_mutex;	/* memory lock */
 
 	/* APU states */
 	unsigned char apu[NR_APUS];
@@ -1356,13 +1358,13 @@ static int calc_available_memory_size(struct es1968 *chip)
 	struct list_head *p;
 	int max_size = 0;
 	
-	down(&chip->memory_mutex);
+	mutex_lock(&chip->memory_mutex);
 	list_for_each(p, &chip->buf_list) {
 		struct esm_memory *buf = list_entry(p, struct esm_memory, list);
 		if (buf->empty && buf->buf.bytes > max_size)
 			max_size = buf->buf.bytes;
 	}
-	up(&chip->memory_mutex);
+	mutex_unlock(&chip->memory_mutex);
 	if (max_size >= 128*1024)
 		max_size = 127*1024;
 	return max_size;
@@ -1375,20 +1377,20 @@ static struct esm_memory *snd_es1968_new_memory(struct es1968 *chip, int size)
 	struct list_head *p;
 	
 	size = ((size + ESM_MEM_ALIGN - 1) / ESM_MEM_ALIGN) * ESM_MEM_ALIGN;
-	down(&chip->memory_mutex);
+	mutex_lock(&chip->memory_mutex);
 	list_for_each(p, &chip->buf_list) {
 		buf = list_entry(p, struct esm_memory, list);
 		if (buf->empty && buf->buf.bytes >= size)
 			goto __found;
 	}
-	up(&chip->memory_mutex);
+	mutex_unlock(&chip->memory_mutex);
 	return NULL;
 
 __found:
 	if (buf->buf.bytes > size) {
 		struct esm_memory *chunk = kmalloc(sizeof(*chunk), GFP_KERNEL);
 		if (chunk == NULL) {
-			up(&chip->memory_mutex);
+			mutex_unlock(&chip->memory_mutex);
 			return NULL;
 		}
 		chunk->buf = buf->buf;
@@ -1400,7 +1402,7 @@ static struct esm_memory *snd_es1968_new_memory(struct es1968 *chip, int size)
 		list_add(&chunk->list, &buf->list);
 	}
 	buf->empty = 0;
-	up(&chip->memory_mutex);
+	mutex_unlock(&chip->memory_mutex);
 	return buf;
 }
 
@@ -1409,7 +1411,7 @@ static void snd_es1968_free_memory(struct es1968 *chip, struct esm_memory *buf)
 {
 	struct esm_memory *chunk;
 
-	down(&chip->memory_mutex);
+	mutex_lock(&chip->memory_mutex);
 	buf->empty = 1;
 	if (buf->list.prev != &chip->buf_list) {
 		chunk = list_entry(buf->list.prev, struct esm_memory, list);
@@ -1428,7 +1430,7 @@ static void snd_es1968_free_memory(struct es1968 *chip, struct esm_memory *buf)
 			kfree(chunk);
 		}
 	}
-	up(&chip->memory_mutex);
+	mutex_unlock(&chip->memory_mutex);
 }
 
 static void snd_es1968_free_dmabuf(struct es1968 *chip)
@@ -2579,7 +2581,7 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 	INIT_LIST_HEAD(&chip->buf_list);
 	INIT_LIST_HEAD(&chip->substream_list);
 	spin_lock_init(&chip->ac97_lock);
-	init_MUTEX(&chip->memory_mutex);
+	mutex_init(&chip->memory_mutex);
 	tasklet_init(&chip->hwvol_tq, es1968_update_hw_volume, (unsigned long)chip);
 	chip->card = card;
 	chip->pci = pci;

commit 858119e159384308a5dde67776691a2ebf70df0f
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Sat Jan 14 13:20:43 2006 -0800

    [PATCH] Unlinline a bunch of other functions
    
    Remove the "inline" keyword from a bunch of big functions in the kernel with
    the goal of shrinking it by 30kb to 40kb
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 9ffb600321cb..3747a436f0cd 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -727,7 +727,7 @@ static void __apu_set_register(struct es1968 *chip, u16 channel, u8 reg, u16 dat
 	apu_data_set(chip, data);
 }
 
-static inline void apu_set_register(struct es1968 *chip, u16 channel, u8 reg, u16 data)
+static void apu_set_register(struct es1968 *chip, u16 channel, u8 reg, u16 data)
 {
 	unsigned long flags;
 	spin_lock_irqsave(&chip->reg_lock, flags);
@@ -743,7 +743,7 @@ static u16 __apu_get_register(struct es1968 *chip, u16 channel, u8 reg)
 	return __maestro_read(chip, IDR0_DATA_PORT);
 }
 
-static inline u16 apu_get_register(struct es1968 *chip, u16 channel, u8 reg)
+static u16 apu_get_register(struct es1968 *chip, u16 channel, u8 reg)
 {
 	unsigned long flags;
 	u16 v;

commit 607da7f834592a723797b21c2463507a44d9cfa7
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Wed Dec 14 11:57:27 2005 +0100

    [ALSA] es1968 - Fix conflict with ISA boards
    
    Modules: ES1968 driver
    
    Fix disablement of TDMA and legacy support to prevent confliction of
    resources with ISA boards.  Confirmed with Terratec DMX and CS4236.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 240cf2b42054..9ffb600321cb 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -176,7 +176,7 @@ MODULE_PARM_DESC(joystick, "Enable joystick.");
 
 /* Values for the ESM_LEGACY_AUDIO_CONTROL */
 
-#define ESS_ENABLE_AUDIO	0x8000
+#define ESS_DISABLE_AUDIO	0x8000
 #define ESS_ENABLE_SERIAL_IRQ	0x4000
 #define IO_ADRESS_ALIAS		0x0020
 #define MPU401_IRQ_ENABLE	0x0010
@@ -195,7 +195,7 @@ MODULE_PARM_DESC(joystick, "Enable joystick.");
 #define DMA_TDMA		0x0100
 #define DMA_PCPCI		0x0200
 #define POST_WRITE		0x0080
-#define ISA_TIMING		0x0040
+#define PCI_TIMING		0x0040
 #define SWAP_LR			0x0020
 #define SUBTR_DECODE		0x0002
 
@@ -2193,14 +2193,11 @@ static void snd_es1968_chip_init(struct es1968 *chip)
 	/* Config Reg A */
 	pci_read_config_word(pci, ESM_CONFIG_A, &w);
 
-	/*      Use TDMA for now. TDMA works on all boards, so while its
-	 *      not the most efficient its the simplest. */
 	w &= ~DMA_CLEAR;	/* Clear DMA bits */
-	w |= DMA_TDMA;		/* TDMA on */
 	w &= ~(PIC_SNOOP1 | PIC_SNOOP2);	/* Clear Pic Snoop Mode Bits */
 	w &= ~SAFEGUARD;	/* Safeguard off */
 	w |= POST_WRITE;	/* Posted write */
-	w |= ISA_TIMING;	/* ISA timing on */
+	w |= PCI_TIMING;	/* PCI timing on */
 	/* XXX huh?  claims to be reserved.. */
 	w &= ~SWAP_LR;		/* swap left/right 
 				   seems to only have effect on SB
@@ -2241,7 +2238,7 @@ static void snd_es1968_chip_init(struct es1968 *chip)
 
 	pci_read_config_word(pci, ESM_LEGACY_AUDIO_CONTROL, &w);
 
-	w &= ~ESS_ENABLE_AUDIO;	/* Disable Legacy Audio */
+	w |= ESS_DISABLE_AUDIO;	/* Disable Legacy Audio */
 	w &= ~ESS_ENABLE_SERIAL_IRQ;	/* Disable SIRQ */
 	w &= ~(0x1f);		/* disable mpu irq/io, game port, fm, SB */
 

commit 1d4b822be64b119b47c172aaac7ee76949470e28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 16:08:43 2005 +0100

    [ALSA] es1968 - Fix PM support
    
    Modules: ES1968 driver
    
    Fix PM support on ES1968 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 021862d28f2b..240cf2b42054 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2378,33 +2378,38 @@ static void snd_es1968_start_irq(struct es1968 *chip)
 /*
  * PM support
  */
-static int es1968_suspend(struct snd_card *card, pm_message_t state)
+static int es1968_suspend(struct pci_dev *pci, pm_message_t state)
 {
-	struct es1968 *chip = card->pm_private_data;
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct es1968 *chip = card->private_data;
 
 	if (! chip->do_pm)
 		return 0;
 
 	chip->in_suspend = 1;
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
 	snd_es1968_bob_stop(chip);
 	snd_es1968_set_acpi(chip, ACPI_D3);
-	pci_disable_device(chip->pci);
+	pci_disable_device(pci);
+	pci_save_state(pci);
 	return 0;
 }
 
-static int es1968_resume(struct snd_card *card)
+static int es1968_resume(struct pci_dev *pci)
 {
-	struct es1968 *chip = card->pm_private_data;
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct es1968 *chip = card->private_data;
 	struct list_head *p;
 
 	if (! chip->do_pm)
 		return 0;
 
 	/* restore all our config */
-	pci_enable_device(chip->pci);
-	pci_set_master(chip->pci);
+	pci_restore_state(pci);
+	pci_enable_device(pci);
+	pci_set_master(pci);
 	snd_es1968_chip_init(chip);
 
 	/* need to restore the base pointers.. */ 
@@ -2434,6 +2439,7 @@ static int es1968_resume(struct snd_card *card)
 	if (chip->bobclient)
 		snd_es1968_bob_start(chip);
 
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	chip->in_suspend = 0;
 	return 0;
 }
@@ -2631,9 +2637,6 @@ static int __devinit snd_es1968_create(struct snd_card *card,
 
 	snd_es1968_chip_init(chip);
 
-	if (chip->do_pm)
-		snd_card_set_pm_callback(card, es1968_suspend, es1968_resume, chip);
-
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
 		snd_es1968_free(chip);
 		return err;
@@ -2683,6 +2686,7 @@ static int __devinit snd_es1968_probe(struct pci_dev *pci,
 		snd_card_free(card);
 		return err;
 	}
+	card->private_data = chip;
 
 	switch (chip->type) {
 	case TYPE_MAESTRO2E:
@@ -2760,7 +2764,10 @@ static struct pci_driver driver = {
 	.id_table = snd_es1968_ids,
 	.probe = snd_es1968_probe,
 	.remove = __devexit_p(snd_es1968_remove),
-	SND_PCI_PM_CALLBACKS
+#ifdef CONFIG_PM
+	.suspend = es1968_suspend,
+	.resume = es1968_resume,
+#endif
 };
 
 static int __init alsa_card_es1968_init(void)

commit 969165a8b5d9a5b3e3c205c312a13a1872844297
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:04:14 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI ES1968
    
    Modules: ES1968 driver
    
    Remove xxx_t typedefs from the PCI ES1968 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 50079dc90743..021862d28f2b 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -470,10 +470,6 @@ static u16 acpi_state_mask[] = {
 };
 
 
-typedef struct snd_es1968 es1968_t;
-typedef struct snd_esschan esschan_t;
-typedef struct snd_esm_memory esm_memory_t;
-
 /* APU use in the driver */
 enum snd_enum_apu_type {
 	ESM_APU_PCM_PLAY,
@@ -488,23 +484,23 @@ enum {
 };
 
 /* DMA Hack! */
-struct snd_esm_memory {
+struct esm_memory {
 	struct snd_dma_buffer buf;
 	int empty;	/* status */
 	struct list_head list;
 };
 
 /* Playback Channel */
-struct snd_esschan {
+struct esschan {
 	int running;
 
 	u8 apu[4];
 	u8 apu_mode[4];
 
 	/* playback/capture pcm buffer */
-	esm_memory_t *memory;
+	struct esm_memory *memory;
 	/* capture mixer buffer */
-	esm_memory_t *mixbuf;
+	struct esm_memory *mixbuf;
 
 	unsigned int hwptr;	/* current hw pointer in bytes */
 	unsigned int count;	/* sample counter in bytes */
@@ -519,7 +515,7 @@ struct snd_esschan {
 
 	int bob_freq;	/* required timer frequency */
 
-	snd_pcm_substream_t *substream;
+	struct snd_pcm_substream *substream;
 
 	/* linked list */
 	struct list_head list;
@@ -529,7 +525,7 @@ struct snd_esschan {
 #endif
 };
 
-struct snd_es1968 {
+struct es1968 {
 	/* Module Config */
 	int total_bufsize;			/* in bytes */
 
@@ -550,19 +546,19 @@ struct snd_es1968 {
 	unsigned long io_port;
 	int type;
 	struct pci_dev *pci;
-	snd_card_t *card;
-	snd_pcm_t *pcm;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
 	int do_pm;		/* power-management enabled */
 
 	/* DMA memory block */
 	struct list_head buf_list;
 
 	/* ALSA Stuff */
-	ac97_t *ac97;
-	snd_kcontrol_t *master_switch; /* for h/w volume control */
-	snd_kcontrol_t *master_volume;
+	struct snd_ac97 *ac97;
+	struct snd_kcontrol *master_switch; /* for h/w volume control */
+	struct snd_kcontrol *master_volume;
 
-	snd_rawmidi_t *rmidi;
+	struct snd_rawmidi *rmidi;
 
 	spinlock_t reg_lock;
 	spinlock_t ac97_lock;
@@ -610,14 +606,14 @@ MODULE_DEVICE_TABLE(pci, snd_es1968_ids);
    *********************/
 
 /* no spinlock */
-static void __maestro_write(es1968_t *chip, u16 reg, u16 data)
+static void __maestro_write(struct es1968 *chip, u16 reg, u16 data)
 {
 	outw(reg, chip->io_port + ESM_INDEX);
 	outw(data, chip->io_port + ESM_DATA);
 	chip->maestro_map[reg] = data;
 }
 
-static inline void maestro_write(es1968_t *chip, u16 reg, u16 data)
+static inline void maestro_write(struct es1968 *chip, u16 reg, u16 data)
 {
 	unsigned long flags;
 	spin_lock_irqsave(&chip->reg_lock, flags);
@@ -626,7 +622,7 @@ static inline void maestro_write(es1968_t *chip, u16 reg, u16 data)
 }
 
 /* no spinlock */
-static u16 __maestro_read(es1968_t *chip, u16 reg)
+static u16 __maestro_read(struct es1968 *chip, u16 reg)
 {
 	if (READABLE_MAP & (1 << reg)) {
 		outw(reg, chip->io_port + ESM_INDEX);
@@ -635,7 +631,7 @@ static u16 __maestro_read(es1968_t *chip, u16 reg)
 	return chip->maestro_map[reg];
 }
 
-static inline u16 maestro_read(es1968_t *chip, u16 reg)
+static inline u16 maestro_read(struct es1968 *chip, u16 reg)
 {
 	unsigned long flags;
 	u16 result;
@@ -646,7 +642,7 @@ static inline u16 maestro_read(es1968_t *chip, u16 reg)
 }
 
 /* Wait for the codec bus to be free */
-static int snd_es1968_ac97_wait(es1968_t *chip)
+static int snd_es1968_ac97_wait(struct es1968 *chip)
 {
 	int timeout = 100000;
 
@@ -659,9 +655,9 @@ static int snd_es1968_ac97_wait(es1968_t *chip)
 	return 1; /* timeout */
 }
 
-static void snd_es1968_ac97_write(ac97_t *ac97, unsigned short reg, unsigned short val)
+static void snd_es1968_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)
 {
-	es1968_t *chip = ac97->private_data;
+	struct es1968 *chip = ac97->private_data;
 	unsigned long flags;
 
 	snd_es1968_ac97_wait(chip);
@@ -675,10 +671,10 @@ static void snd_es1968_ac97_write(ac97_t *ac97, unsigned short reg, unsigned sho
 	spin_unlock_irqrestore(&chip->ac97_lock, flags);
 }
 
-static unsigned short snd_es1968_ac97_read(ac97_t *ac97, unsigned short reg)
+static unsigned short snd_es1968_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
 {
 	u16 data = 0;
-	es1968_t *chip = ac97->private_data;
+	struct es1968 *chip = ac97->private_data;
 	unsigned long flags;
 
 	snd_es1968_ac97_wait(chip);
@@ -697,7 +693,7 @@ static unsigned short snd_es1968_ac97_read(ac97_t *ac97, unsigned short reg)
 }
 
 /* no spinlock */
-static void apu_index_set(es1968_t *chip, u16 index)
+static void apu_index_set(struct es1968 *chip, u16 index)
 {
 	int i;
 	__maestro_write(chip, IDR1_CRAM_POINTER, index);
@@ -708,7 +704,7 @@ static void apu_index_set(es1968_t *chip, u16 index)
 }
 
 /* no spinlock */
-static void apu_data_set(es1968_t *chip, u16 data)
+static void apu_data_set(struct es1968 *chip, u16 data)
 {
 	int i;
 	for (i = 0; i < 1000; i++) {
@@ -720,7 +716,7 @@ static void apu_data_set(es1968_t *chip, u16 data)
 }
 
 /* no spinlock */
-static void __apu_set_register(es1968_t *chip, u16 channel, u8 reg, u16 data)
+static void __apu_set_register(struct es1968 *chip, u16 channel, u8 reg, u16 data)
 {
 	snd_assert(channel < NR_APUS, return);
 #ifdef CONFIG_PM
@@ -731,7 +727,7 @@ static void __apu_set_register(es1968_t *chip, u16 channel, u8 reg, u16 data)
 	apu_data_set(chip, data);
 }
 
-static inline void apu_set_register(es1968_t *chip, u16 channel, u8 reg, u16 data)
+static inline void apu_set_register(struct es1968 *chip, u16 channel, u8 reg, u16 data)
 {
 	unsigned long flags;
 	spin_lock_irqsave(&chip->reg_lock, flags);
@@ -739,7 +735,7 @@ static inline void apu_set_register(es1968_t *chip, u16 channel, u8 reg, u16 dat
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 }
 
-static u16 __apu_get_register(es1968_t *chip, u16 channel, u8 reg)
+static u16 __apu_get_register(struct es1968 *chip, u16 channel, u8 reg)
 {
 	snd_assert(channel < NR_APUS, return 0);
 	reg |= (channel << 4);
@@ -747,7 +743,7 @@ static u16 __apu_get_register(es1968_t *chip, u16 channel, u8 reg)
 	return __maestro_read(chip, IDR0_DATA_PORT);
 }
 
-static inline u16 apu_get_register(es1968_t *chip, u16 channel, u8 reg)
+static inline u16 apu_get_register(struct es1968 *chip, u16 channel, u8 reg)
 {
 	unsigned long flags;
 	u16 v;
@@ -759,7 +755,7 @@ static inline u16 apu_get_register(es1968_t *chip, u16 channel, u8 reg)
 
 #if 0 /* ASSP is not supported */
 
-static void assp_set_register(es1968_t *chip, u32 reg, u32 value)
+static void assp_set_register(struct es1968 *chip, u32 reg, u32 value)
 {
 	unsigned long flags;
 
@@ -769,7 +765,7 @@ static void assp_set_register(es1968_t *chip, u32 reg, u32 value)
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 }
 
-static u32 assp_get_register(es1968_t *chip, u32 reg)
+static u32 assp_get_register(struct es1968 *chip, u32 reg)
 {
 	unsigned long flags;
 	u32 value;
@@ -784,7 +780,7 @@ static u32 assp_get_register(es1968_t *chip, u32 reg)
 
 #endif
 
-static void wave_set_register(es1968_t *chip, u16 reg, u16 value)
+static void wave_set_register(struct es1968 *chip, u16 reg, u16 value)
 {
 	unsigned long flags;
 
@@ -794,7 +790,7 @@ static void wave_set_register(es1968_t *chip, u16 reg, u16 value)
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 }
 
-static u16 wave_get_register(es1968_t *chip, u16 reg)
+static u16 wave_get_register(struct es1968 *chip, u16 reg)
 {
 	unsigned long flags;
 	u16 value;
@@ -811,7 +807,7 @@ static u16 wave_get_register(es1968_t *chip, u16 reg)
    * Bob the Timer!  *
    *******************/
 
-static void snd_es1968_bob_stop(es1968_t *chip)
+static void snd_es1968_bob_stop(struct es1968 *chip)
 {
 	u16 reg;
 
@@ -823,7 +819,7 @@ static void snd_es1968_bob_stop(es1968_t *chip)
 	__maestro_write(chip, 0x17, reg);
 }
 
-static void snd_es1968_bob_start(es1968_t *chip)
+static void snd_es1968_bob_start(struct es1968 *chip)
 {
 	int prescale;
 	int divide;
@@ -863,7 +859,7 @@ static void snd_es1968_bob_start(es1968_t *chip)
 }
 
 /* call with substream spinlock */
-static void snd_es1968_bob_inc(es1968_t *chip, int freq)
+static void snd_es1968_bob_inc(struct es1968 *chip, int freq)
 {
 	chip->bobclient++;
 	if (chip->bobclient == 1) {
@@ -877,7 +873,7 @@ static void snd_es1968_bob_inc(es1968_t *chip, int freq)
 }
 
 /* call with substream spinlock */
-static void snd_es1968_bob_dec(es1968_t *chip)
+static void snd_es1968_bob_dec(struct es1968 *chip)
 {
 	chip->bobclient--;
 	if (chip->bobclient <= 0)
@@ -887,7 +883,7 @@ static void snd_es1968_bob_dec(es1968_t *chip)
 		struct list_head *p;
 		int max_freq = ESM_BOB_FREQ;
 		list_for_each(p, &chip->substream_list) {
-			esschan_t *es = list_entry(p, esschan_t, list);
+			struct esschan *es = list_entry(p, struct esschan, list);
 			if (max_freq < es->bob_freq)
 				max_freq = es->bob_freq;
 		}
@@ -900,8 +896,8 @@ static void snd_es1968_bob_dec(es1968_t *chip)
 }
 
 static int
-snd_es1968_calc_bob_rate(es1968_t *chip, esschan_t *es,
-			 snd_pcm_runtime_t *runtime)
+snd_es1968_calc_bob_rate(struct es1968 *chip, struct esschan *es,
+			 struct snd_pcm_runtime *runtime)
 {
 	/* we acquire 4 interrupts per period for precise control.. */
 	int freq = runtime->rate * 4;
@@ -922,7 +918,7 @@ snd_es1968_calc_bob_rate(es1968_t *chip, esschan_t *es,
  *  PCM Part *
  *************/
 
-static u32 snd_es1968_compute_rate(es1968_t *chip, u32 freq)
+static u32 snd_es1968_compute_rate(struct es1968 *chip, u32 freq)
 {
 	u32 rate = (freq << 16) / chip->clock;
 #if 0 /* XXX: do we need this? */ 
@@ -934,7 +930,7 @@ static u32 snd_es1968_compute_rate(es1968_t *chip, u32 freq)
 
 /* get current pointer */
 static inline unsigned int
-snd_es1968_get_dma_ptr(es1968_t *chip, esschan_t *es)
+snd_es1968_get_dma_ptr(struct es1968 *chip, struct esschan *es)
 {
 	unsigned int offset;
 
@@ -945,7 +941,7 @@ snd_es1968_get_dma_ptr(es1968_t *chip, esschan_t *es)
 	return (offset & 0xFFFE);	/* hardware is in words */
 }
 
-static void snd_es1968_apu_set_freq(es1968_t *chip, int apu, int freq)
+static void snd_es1968_apu_set_freq(struct es1968 *chip, int apu, int freq)
 {
 	apu_set_register(chip, apu, 2,
 			   (apu_get_register(chip, apu, 2) & 0x00FF) |
@@ -954,7 +950,7 @@ static void snd_es1968_apu_set_freq(es1968_t *chip, int apu, int freq)
 }
 
 /* spin lock held */
-static inline void snd_es1968_trigger_apu(es1968_t *esm, int apu, int mode)
+static inline void snd_es1968_trigger_apu(struct es1968 *esm, int apu, int mode)
 {
 	/* set the APU mode */
 	__apu_set_register(esm, apu, 0,
@@ -962,7 +958,7 @@ static inline void snd_es1968_trigger_apu(es1968_t *esm, int apu, int mode)
 			   (mode << 4));
 }
 
-static void snd_es1968_pcm_start(es1968_t *chip, esschan_t *es)
+static void snd_es1968_pcm_start(struct es1968 *chip, struct esschan *es)
 {
 	spin_lock(&chip->reg_lock);
 	__apu_set_register(chip, es->apu[0], 5, es->base[0]);
@@ -982,7 +978,7 @@ static void snd_es1968_pcm_start(es1968_t *chip, esschan_t *es)
 	spin_unlock(&chip->reg_lock);
 }
 
-static void snd_es1968_pcm_stop(es1968_t *chip, esschan_t *es)
+static void snd_es1968_pcm_stop(struct es1968 *chip, struct esschan *es)
 {
 	spin_lock(&chip->reg_lock);
 	snd_es1968_trigger_apu(chip, es->apu[0], 0);
@@ -995,7 +991,7 @@ static void snd_es1968_pcm_stop(es1968_t *chip, esschan_t *es)
 }
 
 /* set the wavecache control reg */
-static void snd_es1968_program_wavecache(es1968_t *chip, esschan_t *es,
+static void snd_es1968_program_wavecache(struct es1968 *chip, struct esschan *es,
 					 int channel, u32 addr, int capture)
 {
 	u32 tmpval = (addr - 0x10) & 0xFFF8;
@@ -1016,8 +1012,8 @@ static void snd_es1968_program_wavecache(es1968_t *chip, esschan_t *es,
 }
 
 
-static void snd_es1968_playback_setup(es1968_t *chip, esschan_t *es,
-				      snd_pcm_runtime_t *runtime)
+static void snd_es1968_playback_setup(struct es1968 *chip, struct esschan *es,
+				      struct snd_pcm_runtime *runtime)
 {
 	u32 pa;
 	int high_apu = 0;
@@ -1119,7 +1115,7 @@ static void snd_es1968_playback_setup(es1968_t *chip, esschan_t *es,
 }
 
 
-static void init_capture_apu(es1968_t *chip, esschan_t *es, int channel,
+static void init_capture_apu(struct es1968 *chip, struct esschan *es, int channel,
 			     unsigned int pa, unsigned int bsize,
 			     int mode, int route)
 {
@@ -1164,8 +1160,8 @@ static void init_capture_apu(es1968_t *chip, esschan_t *es, int channel,
 	apu_set_register(chip, apu, 0, 0x400F);
 }
 
-static void snd_es1968_capture_setup(es1968_t *chip, esschan_t *es,
-				     snd_pcm_runtime_t *runtime)
+static void snd_es1968_capture_setup(struct es1968 *chip, struct esschan *es,
+				     struct snd_pcm_runtime *runtime)
 {
 	int size;
 	u32 freq;
@@ -1233,11 +1229,11 @@ static void snd_es1968_capture_setup(es1968_t *chip, esschan_t *es,
  *  ALSA Interface *
  *******************/
 
-static int snd_es1968_pcm_prepare(snd_pcm_substream_t *substream)
+static int snd_es1968_pcm_prepare(struct snd_pcm_substream *substream)
 {
-	es1968_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	esschan_t *es = runtime->private_data;
+	struct es1968 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct esschan *es = runtime->private_data;
 
 	es->dma_size = snd_pcm_lib_buffer_bytes(substream);
 	es->frag_size = snd_pcm_lib_period_bytes(substream);
@@ -1265,10 +1261,10 @@ static int snd_es1968_pcm_prepare(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static int snd_es1968_pcm_trigger(snd_pcm_substream_t *substream, int cmd)
+static int snd_es1968_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	es1968_t *chip = snd_pcm_substream_chip(substream);
-	esschan_t *es = substream->runtime->private_data;
+	struct es1968 *chip = snd_pcm_substream_chip(substream);
+	struct esschan *es = substream->runtime->private_data;
 
 	spin_lock(&chip->substream_lock);
 	switch (cmd) {
@@ -1295,10 +1291,10 @@ static int snd_es1968_pcm_trigger(snd_pcm_substream_t *substream, int cmd)
 	return 0;
 }
 
-static snd_pcm_uframes_t snd_es1968_pcm_pointer(snd_pcm_substream_t *substream)
+static snd_pcm_uframes_t snd_es1968_pcm_pointer(struct snd_pcm_substream *substream)
 {
-	es1968_t *chip = snd_pcm_substream_chip(substream);
-	esschan_t *es = substream->runtime->private_data;
+	struct es1968 *chip = snd_pcm_substream_chip(substream);
+	struct esschan *es = substream->runtime->private_data;
 	unsigned int ptr;
 
 	ptr = snd_es1968_get_dma_ptr(chip, es) << es->wav_shift;
@@ -1306,7 +1302,7 @@ static snd_pcm_uframes_t snd_es1968_pcm_pointer(snd_pcm_substream_t *substream)
 	return bytes_to_frames(substream->runtime, ptr % es->dma_size);
 }
 
-static snd_pcm_hardware_t snd_es1968_playback = {
+static struct snd_pcm_hardware snd_es1968_playback = {
 	.info =			(SNDRV_PCM_INFO_MMAP |
                		         SNDRV_PCM_INFO_MMAP_VALID |
 				 SNDRV_PCM_INFO_INTERLEAVED |
@@ -1327,7 +1323,7 @@ static snd_pcm_hardware_t snd_es1968_playback = {
 	.fifo_size =		0,
 };
 
-static snd_pcm_hardware_t snd_es1968_capture = {
+static struct snd_pcm_hardware snd_es1968_capture = {
 	.info =			(SNDRV_PCM_INFO_NONINTERLEAVED |
 				 SNDRV_PCM_INFO_MMAP |
 				 SNDRV_PCM_INFO_MMAP_VALID |
@@ -1355,14 +1351,14 @@ static snd_pcm_hardware_t snd_es1968_capture = {
 /* Because the Maestro can only take addresses relative to the PCM base address
    register :( */
 
-static int calc_available_memory_size(es1968_t *chip)
+static int calc_available_memory_size(struct es1968 *chip)
 {
 	struct list_head *p;
 	int max_size = 0;
 	
 	down(&chip->memory_mutex);
 	list_for_each(p, &chip->buf_list) {
-		esm_memory_t *buf = list_entry(p, esm_memory_t, list);
+		struct esm_memory *buf = list_entry(p, struct esm_memory, list);
 		if (buf->empty && buf->buf.bytes > max_size)
 			max_size = buf->buf.bytes;
 	}
@@ -1373,15 +1369,15 @@ static int calc_available_memory_size(es1968_t *chip)
 }
 
 /* allocate a new memory chunk with the specified size */
-static esm_memory_t *snd_es1968_new_memory(es1968_t *chip, int size)
+static struct esm_memory *snd_es1968_new_memory(struct es1968 *chip, int size)
 {
-	esm_memory_t *buf;
+	struct esm_memory *buf;
 	struct list_head *p;
 	
 	size = ((size + ESM_MEM_ALIGN - 1) / ESM_MEM_ALIGN) * ESM_MEM_ALIGN;
 	down(&chip->memory_mutex);
 	list_for_each(p, &chip->buf_list) {
-		buf = list_entry(p, esm_memory_t, list);
+		buf = list_entry(p, struct esm_memory, list);
 		if (buf->empty && buf->buf.bytes >= size)
 			goto __found;
 	}
@@ -1390,7 +1386,7 @@ static esm_memory_t *snd_es1968_new_memory(es1968_t *chip, int size)
 
 __found:
 	if (buf->buf.bytes > size) {
-		esm_memory_t *chunk = kmalloc(sizeof(*chunk), GFP_KERNEL);
+		struct esm_memory *chunk = kmalloc(sizeof(*chunk), GFP_KERNEL);
 		if (chunk == NULL) {
 			up(&chip->memory_mutex);
 			return NULL;
@@ -1409,14 +1405,14 @@ static esm_memory_t *snd_es1968_new_memory(es1968_t *chip, int size)
 }
 
 /* free a memory chunk */
-static void snd_es1968_free_memory(es1968_t *chip, esm_memory_t *buf)
+static void snd_es1968_free_memory(struct es1968 *chip, struct esm_memory *buf)
 {
-	esm_memory_t *chunk;
+	struct esm_memory *chunk;
 
 	down(&chip->memory_mutex);
 	buf->empty = 1;
 	if (buf->list.prev != &chip->buf_list) {
-		chunk = list_entry(buf->list.prev, esm_memory_t, list);
+		chunk = list_entry(buf->list.prev, struct esm_memory, list);
 		if (chunk->empty) {
 			chunk->buf.bytes += buf->buf.bytes;
 			list_del(&buf->list);
@@ -1425,7 +1421,7 @@ static void snd_es1968_free_memory(es1968_t *chip, esm_memory_t *buf)
 		}
 	}
 	if (buf->list.next != &chip->buf_list) {
-		chunk = list_entry(buf->list.next, esm_memory_t, list);
+		chunk = list_entry(buf->list.next, struct esm_memory, list);
 		if (chunk->empty) {
 			buf->buf.bytes += chunk->buf.bytes;
 			list_del(&chunk->list);
@@ -1435,7 +1431,7 @@ static void snd_es1968_free_memory(es1968_t *chip, esm_memory_t *buf)
 	up(&chip->memory_mutex);
 }
 
-static void snd_es1968_free_dmabuf(es1968_t *chip)
+static void snd_es1968_free_dmabuf(struct es1968 *chip)
 {
 	struct list_head *p;
 
@@ -1443,17 +1439,17 @@ static void snd_es1968_free_dmabuf(es1968_t *chip)
 		return;
 	snd_dma_reserve_buf(&chip->dma, snd_dma_pci_buf_id(chip->pci));
 	while ((p = chip->buf_list.next) != &chip->buf_list) {
-		esm_memory_t *chunk = list_entry(p, esm_memory_t, list);
+		struct esm_memory *chunk = list_entry(p, struct esm_memory, list);
 		list_del(p);
 		kfree(chunk);
 	}
 }
 
 static int __devinit
-snd_es1968_init_dmabuf(es1968_t *chip)
+snd_es1968_init_dmabuf(struct es1968 *chip)
 {
 	int err;
-	esm_memory_t *chunk;
+	struct esm_memory *chunk;
 
 	chip->dma.dev.type = SNDRV_DMA_TYPE_DEV;
 	chip->dma.dev.dev = snd_dma_pci_data(chip->pci);
@@ -1493,12 +1489,12 @@ snd_es1968_init_dmabuf(es1968_t *chip)
 
 /* setup the dma_areas */
 /* buffer is extracted from the pre-allocated memory chunk */
-static int snd_es1968_hw_params(snd_pcm_substream_t *substream,
-				snd_pcm_hw_params_t *hw_params)
+static int snd_es1968_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *hw_params)
 {
-	es1968_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	esschan_t *chan = runtime->private_data;
+	struct es1968 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct esschan *chan = runtime->private_data;
 	int size = params_buffer_bytes(hw_params);
 
 	if (chan->memory) {
@@ -1518,11 +1514,11 @@ static int snd_es1968_hw_params(snd_pcm_substream_t *substream,
 }
 
 /* remove dma areas if allocated */
-static int snd_es1968_hw_free(snd_pcm_substream_t * substream)
+static int snd_es1968_hw_free(struct snd_pcm_substream *substream)
 {
-	es1968_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	esschan_t *chan;
+	struct es1968 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct esschan *chan;
 	
 	if (runtime->private_data == NULL)
 		return 0;
@@ -1538,7 +1534,7 @@ static int snd_es1968_hw_free(snd_pcm_substream_t * substream)
 /*
  * allocate APU pair
  */
-static int snd_es1968_alloc_apu_pair(es1968_t *chip, int type)
+static int snd_es1968_alloc_apu_pair(struct es1968 *chip, int type)
 {
 	int apu;
 
@@ -1555,7 +1551,7 @@ static int snd_es1968_alloc_apu_pair(es1968_t *chip, int type)
 /*
  * release APU pair
  */
-static void snd_es1968_free_apu_pair(es1968_t *chip, int apu)
+static void snd_es1968_free_apu_pair(struct es1968 *chip, int apu)
 {
 	chip->apu[apu] = chip->apu[apu + 1] = ESM_APU_FREE;
 }
@@ -1565,11 +1561,11 @@ static void snd_es1968_free_apu_pair(es1968_t *chip, int apu)
  * PCM open/close *
  ******************/
 
-static int snd_es1968_playback_open(snd_pcm_substream_t *substream)
+static int snd_es1968_playback_open(struct snd_pcm_substream *substream)
 {
-	es1968_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	esschan_t *es;
+	struct es1968 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct esschan *es;
 	int apu1;
 
 	/* search 2 APUs */
@@ -1606,11 +1602,11 @@ static int snd_es1968_playback_open(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static int snd_es1968_capture_open(snd_pcm_substream_t *substream)
+static int snd_es1968_capture_open(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	es1968_t *chip = snd_pcm_substream_chip(substream);
-	esschan_t *es;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct es1968 *chip = snd_pcm_substream_chip(substream);
+	struct esschan *es;
 	int apu1, apu2;
 
 	apu1 = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_CAPTURE);
@@ -1665,10 +1661,10 @@ static int snd_es1968_capture_open(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static int snd_es1968_playback_close(snd_pcm_substream_t * substream)
+static int snd_es1968_playback_close(struct snd_pcm_substream *substream)
 {
-	es1968_t *chip = snd_pcm_substream_chip(substream);
-	esschan_t *es;
+	struct es1968 *chip = snd_pcm_substream_chip(substream);
+	struct esschan *es;
 
 	if (substream->runtime->private_data == NULL)
 		return 0;
@@ -1682,10 +1678,10 @@ static int snd_es1968_playback_close(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_es1968_capture_close(snd_pcm_substream_t * substream)
+static int snd_es1968_capture_close(struct snd_pcm_substream *substream)
 {
-	es1968_t *chip = snd_pcm_substream_chip(substream);
-	esschan_t *es;
+	struct es1968 *chip = snd_pcm_substream_chip(substream);
+	struct esschan *es;
 
 	if (substream->runtime->private_data == NULL)
 		return 0;
@@ -1701,7 +1697,7 @@ static int snd_es1968_capture_close(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static snd_pcm_ops_t snd_es1968_playback_ops = {
+static struct snd_pcm_ops snd_es1968_playback_ops = {
 	.open =		snd_es1968_playback_open,
 	.close =	snd_es1968_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1712,7 +1708,7 @@ static snd_pcm_ops_t snd_es1968_playback_ops = {
 	.pointer =	snd_es1968_pcm_pointer,
 };
 
-static snd_pcm_ops_t snd_es1968_capture_ops = {
+static struct snd_pcm_ops snd_es1968_capture_ops = {
 	.open =		snd_es1968_capture_open,
 	.close =	snd_es1968_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1729,11 +1725,11 @@ static snd_pcm_ops_t snd_es1968_capture_ops = {
  */
 #define CLOCK_MEASURE_BUFSIZE	16768	/* enough large for a single shot */
 
-static void __devinit es1968_measure_clock(es1968_t *chip)
+static void __devinit es1968_measure_clock(struct es1968 *chip)
 {
 	int i, apu;
 	unsigned int pa, offset, t;
-	esm_memory_t *memory;
+	struct esm_memory *memory;
 	struct timeval start_time, stop_time;
 
 	if (chip->clock == 0)
@@ -1824,17 +1820,17 @@ static void __devinit es1968_measure_clock(es1968_t *chip)
 /*
  */
 
-static void snd_es1968_pcm_free(snd_pcm_t *pcm)
+static void snd_es1968_pcm_free(struct snd_pcm *pcm)
 {
-	es1968_t *esm = pcm->private_data;
+	struct es1968 *esm = pcm->private_data;
 	snd_es1968_free_dmabuf(esm);
 	esm->pcm = NULL;
 }
 
 static int __devinit
-snd_es1968_pcm(es1968_t *chip, int device)
+snd_es1968_pcm(struct es1968 *chip, int device)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	/* get DMA buffer */
@@ -1870,11 +1866,11 @@ snd_es1968_pcm(es1968_t *chip, int device)
 /*
  * update pointer
  */
-static void snd_es1968_update_pcm(es1968_t *chip, esschan_t *es)
+static void snd_es1968_update_pcm(struct es1968 *chip, struct esschan *es)
 {
 	unsigned int hwptr;
 	unsigned int diff;
-	snd_pcm_substream_t *subs = es->substream;
+	struct snd_pcm_substream *subs = es->substream;
         
 	if (subs == NULL || !es->running)
 		return;
@@ -1899,7 +1895,7 @@ static void snd_es1968_update_pcm(es1968_t *chip, esschan_t *es)
  */
 static void es1968_update_hw_volume(unsigned long private_data)
 {
-	es1968_t *chip = (es1968_t *) private_data;
+	struct es1968 *chip = (struct es1968 *) private_data;
 	int x, val;
 	unsigned long flags;
 
@@ -1959,7 +1955,7 @@ static void es1968_update_hw_volume(unsigned long private_data)
  */
 static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	es1968_t *chip = dev_id;
+	struct es1968 *chip = dev_id;
 	u32 event;
 
 	if (!(event = inb(chip->io_port + 0x1A)))
@@ -1981,7 +1977,7 @@ static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id, struct pt_regs *r
 		struct list_head *p;
 		spin_lock(&chip->substream_lock);
 		list_for_each(p, &chip->substream_list) {
-			esschan_t *es = list_entry(p, esschan_t, list);
+			struct esschan *es = list_entry(p, struct esschan, list);
 			if (es->running)
 				snd_es1968_update_pcm(chip, es);
 		}
@@ -2002,13 +1998,13 @@ static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id, struct pt_regs *r
  */
 
 static int __devinit
-snd_es1968_mixer(es1968_t *chip)
+snd_es1968_mixer(struct es1968 *chip)
 {
-	ac97_bus_t *pbus;
-	ac97_template_t ac97;
-	snd_ctl_elem_id_t id;
+	struct snd_ac97_bus *pbus;
+	struct snd_ac97_template ac97;
+	struct snd_ctl_elem_id id;
 	int err;
-	static ac97_bus_ops_t ops = {
+	static struct snd_ac97_bus_ops ops = {
 		.write = snd_es1968_ac97_write,
 		.read = snd_es1968_ac97_read,
 	};
@@ -2039,7 +2035,7 @@ snd_es1968_mixer(es1968_t *chip)
  * reset ac97 codec
  */
 
-static void snd_es1968_ac97_reset(es1968_t *chip)
+static void snd_es1968_ac97_reset(struct es1968 *chip)
 {
 	unsigned long ioaddr = chip->io_port;
 
@@ -2144,7 +2140,7 @@ static void snd_es1968_ac97_reset(es1968_t *chip)
 	outb(0x3f, ioaddr+0xd0);
 }
 
-static void snd_es1968_reset(es1968_t *chip)
+static void snd_es1968_reset(struct es1968 *chip)
 {
 	/* Reset */
 	outw(ESM_RESET_MAESTRO | ESM_RESET_DIRECTSOUND,
@@ -2157,7 +2153,7 @@ static void snd_es1968_reset(es1968_t *chip)
 /*
  * power management
  */
-static void snd_es1968_set_acpi(es1968_t *chip, int state)
+static void snd_es1968_set_acpi(struct es1968 *chip, int state)
 {
 	u16 active_mask = acpi_state_mask[state];
 
@@ -2172,7 +2168,7 @@ static void snd_es1968_set_acpi(es1968_t *chip, int state)
 /*
  * initialize maestro chip
  */
-static void snd_es1968_chip_init(es1968_t *chip)
+static void snd_es1968_chip_init(struct es1968 *chip)
 {
 	struct pci_dev *pci = chip->pci;
 	int i;
@@ -2369,7 +2365,7 @@ static void snd_es1968_chip_init(es1968_t *chip)
 }
 
 /* Enable IRQ's */
-static void snd_es1968_start_irq(es1968_t *chip)
+static void snd_es1968_start_irq(struct es1968 *chip)
 {
 	unsigned short w;
 	w = ESM_HIRQ_DSIE | ESM_HIRQ_HW_VOLUME;
@@ -2382,9 +2378,9 @@ static void snd_es1968_start_irq(es1968_t *chip)
 /*
  * PM support
  */
-static int es1968_suspend(snd_card_t *card, pm_message_t state)
+static int es1968_suspend(struct snd_card *card, pm_message_t state)
 {
-	es1968_t *chip = card->pm_private_data;
+	struct es1968 *chip = card->pm_private_data;
 
 	if (! chip->do_pm)
 		return 0;
@@ -2398,9 +2394,9 @@ static int es1968_suspend(snd_card_t *card, pm_message_t state)
 	return 0;
 }
 
-static int es1968_resume(snd_card_t *card)
+static int es1968_resume(struct snd_card *card)
 {
-	es1968_t *chip = card->pm_private_data;
+	struct es1968 *chip = card->pm_private_data;
 	struct list_head *p;
 
 	if (! chip->do_pm)
@@ -2423,7 +2419,7 @@ static int es1968_resume(snd_card_t *card)
 	snd_ac97_resume(chip->ac97);
 
 	list_for_each(p, &chip->substream_list) {
-		esschan_t *es = list_entry(p, esschan_t, list);
+		struct esschan *es = list_entry(p, struct esschan, list);
 		switch (es->mode) {
 		case ESM_MODE_PLAY:
 			snd_es1968_playback_setup(chip, es, es->substream->runtime);
@@ -2445,7 +2441,7 @@ static int es1968_resume(snd_card_t *card)
 
 #ifdef SUPPORT_JOYSTICK
 #define JOYSTICK_ADDR	0x200
-static int __devinit snd_es1968_create_gameport(es1968_t *chip, int dev)
+static int __devinit snd_es1968_create_gameport(struct es1968 *chip, int dev)
 {
 	struct gameport *gp;
 	struct resource *r;
@@ -2479,7 +2475,7 @@ static int __devinit snd_es1968_create_gameport(es1968_t *chip, int dev)
 	return 0;
 }
 
-static void snd_es1968_free_gameport(es1968_t *chip)
+static void snd_es1968_free_gameport(struct es1968 *chip)
 {
 	if (chip->gameport) {
 		struct resource *r = gameport_get_port_data(chip->gameport);
@@ -2491,11 +2487,11 @@ static void snd_es1968_free_gameport(es1968_t *chip)
 	}
 }
 #else
-static inline int snd_es1968_create_gameport(es1968_t *chip, int dev) { return -ENOSYS; }
-static inline void snd_es1968_free_gameport(es1968_t *chip) { }
+static inline int snd_es1968_create_gameport(struct es1968 *chip, int dev) { return -ENOSYS; }
+static inline void snd_es1968_free_gameport(struct es1968 *chip) { }
 #endif
 
-static int snd_es1968_free(es1968_t *chip)
+static int snd_es1968_free(struct es1968 *chip)
 {
 	if (chip->io_port) {
 		synchronize_irq(chip->irq);
@@ -2515,9 +2511,9 @@ static int snd_es1968_free(es1968_t *chip)
 	return 0;
 }
 
-static int snd_es1968_dev_free(snd_device_t *device)
+static int snd_es1968_dev_free(struct snd_device *device)
 {
-	es1968_t *chip = device->device_data;
+	struct es1968 *chip = device->device_data;
 	return snd_es1968_free(chip);
 }
 
@@ -2539,19 +2535,19 @@ static struct ess_device_list mpu_blacklist[] __devinitdata = {
 	{ TYPE_MAESTRO2, 0x125d },
 };
 
-static int __devinit snd_es1968_create(snd_card_t * card,
+static int __devinit snd_es1968_create(struct snd_card *card,
 				       struct pci_dev *pci,
 				       int total_bufsize,
 				       int play_streams,
 				       int capt_streams,
 				       int chip_type,
 				       int do_pm,
-				       es1968_t **chip_ret)
+				       struct es1968 **chip_ret)
 {
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free =	snd_es1968_dev_free,
 	};
-	es1968_t *chip;
+	struct es1968 *chip;
 	int i, err;
 
 	*chip_ret = NULL;
@@ -2657,8 +2653,8 @@ static int __devinit snd_es1968_probe(struct pci_dev *pci,
 				      const struct pci_device_id *pci_id)
 {
 	static int dev;
-	snd_card_t *card;
-	es1968_t *chip;
+	struct snd_card *card;
+	struct es1968 *chip;
 	unsigned int i;
 	int err;
 

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index ac8294e21cc1..50079dc90743 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2761,7 +2761,6 @@ static void __devexit snd_es1968_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "ES1968 (ESS Maestro)",
-	.owner = THIS_MODULE,
 	.id_table = snd_es1968_ids,
 	.probe = snd_es1968_probe,
 	.remove = __devexit_p(snd_es1968_remove),

commit 99b359ba10a582148c6725f428a33ba5356dd993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 20 18:26:44 2005 +0200

    [ALSA] Add missing KERN_* suffix to printk
    
    Add missing KERN_* suffix to printk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 1bf094b67469..ac8294e21cc1 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1462,13 +1462,13 @@ snd_es1968_init_dmabuf(es1968_t *chip)
 						   snd_dma_pci_data(chip->pci),
 						   chip->total_bufsize, &chip->dma);
 		if (err < 0 || ! chip->dma.area) {
-			snd_printk("es1968: can't allocate dma pages for size %d\n",
+			snd_printk(KERN_ERR "es1968: can't allocate dma pages for size %d\n",
 				   chip->total_bufsize);
 			return -ENOMEM;
 		}
 		if ((chip->dma.addr + chip->dma.bytes - 1) & ~((1 << 28) - 1)) {
 			snd_dma_free_pages(&chip->dma);
-			snd_printk("es1968: DMA buffer beyond 256MB.\n");
+			snd_printk(KERN_ERR "es1968: DMA buffer beyond 256MB.\n");
 			return -ENOMEM;
 		}
 	}
@@ -1741,11 +1741,11 @@ static void __devinit es1968_measure_clock(es1968_t *chip)
 
 	/* search 2 APUs (although one apu is enough) */
 	if ((apu = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_PLAY)) < 0) {
-		snd_printk("Hmm, cannot find empty APU pair!?\n");
+		snd_printk(KERN_ERR "Hmm, cannot find empty APU pair!?\n");
 		return;
 	}
 	if ((memory = snd_es1968_new_memory(chip, CLOCK_MEASURE_BUFSIZE)) == NULL) {
-		snd_printk("cannot allocate dma buffer - using default clock %d\n", chip->clock);
+		snd_printk(KERN_ERR "cannot allocate dma buffer - using default clock %d\n", chip->clock);
 		snd_es1968_free_apu_pair(chip, apu);
 		return;
 	}
@@ -1806,7 +1806,7 @@ static void __devinit es1968_measure_clock(es1968_t *chip)
 	else
 		t += stop_time.tv_usec - start_time.tv_usec;
 	if (t == 0) {
-		snd_printk("?? calculation error..\n");
+		snd_printk(KERN_ERR "?? calculation error..\n");
 	} else {
 		offset *= 1000;
 		offset = (offset / t) * 1000 + ((offset % t) * 1000) / t;
@@ -2090,7 +2090,7 @@ static void snd_es1968_ac97_reset(es1968_t *chip)
 	outw(inw(ioaddr + 0x3c) & 0xfffc, ioaddr + 0x3c);
 
 #if 0				/* the loop here needs to be much better if we want it.. */
-	snd_printk("trying software reset\n");
+	snd_printk(KERN_INFO "trying software reset\n");
 	/* try and do a software reset */
 	outb(0x80 | 0x7c, ioaddr + 0x30);
 	for (w = 0;; w++) {
@@ -2562,7 +2562,7 @@ static int __devinit snd_es1968_create(snd_card_t * card,
 	/* check, if we can restrict PCI DMA transfers to 28 bits */
 	if (pci_set_dma_mask(pci, 0x0fffffff) < 0 ||
 	    pci_set_consistent_dma_mask(pci, 0x0fffffff) < 0) {
-		snd_printk("architecture does not support 28bit PCI busmaster DMA\n");
+		snd_printk(KERN_ERR "architecture does not support 28bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;
 	}
@@ -2597,7 +2597,7 @@ static int __devinit snd_es1968_create(snd_card_t * card,
 	chip->io_port = pci_resource_start(pci, 0);
 	if (request_irq(pci->irq, snd_es1968_interrupt, SA_INTERRUPT|SA_SHIRQ,
 			"ESS Maestro", (void*)chip)) {
-		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_es1968_free(chip);
 		return -EBUSY;
 	}

commit b1d5776d865951c213a1caaab5d8bf5de7615dbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:56:31 2005 +0200

    [ALSA] Remove vmalloc wrapper, kfree_nocheck()
    
    - Remove vmalloc wrapper
    - Add release_and_free_resource() to remove kfree_nocheck() from each driver
      and simplify the code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index ecdcada90ca2..1bf094b67469 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2461,8 +2461,7 @@ static int __devinit snd_es1968_create_gameport(es1968_t *chip, int dev)
 	chip->gameport = gp = gameport_allocate_port();
 	if (!gp) {
 		printk(KERN_ERR "es1968: cannot allocate memory for gameport\n");
-		release_resource(r);
-		kfree_nocheck(r);
+		release_and_free_resource(r);
 		return -ENOMEM;
 	}
 
@@ -2488,8 +2487,7 @@ static void snd_es1968_free_gameport(es1968_t *chip)
 		gameport_unregister_port(chip->gameport);
 		chip->gameport = NULL;
 
-		release_resource(r);
-		kfree_nocheck(r);
+		release_and_free_resource(r);
 	}
 }
 #else

commit 3bcd4649bca99ee9242f20d7da35e3f8741c6549
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 12 08:20:54 2005 +0200

    [ALSA] set owner field in struct pci_driver
    
    AD1889 driver,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CS46xx driver,EMU10K1/EMU10K2 driver
    HDA Intel driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    MIXART driver,NM256 driver,RME HDSP driver,RME9652 driver
    Trident driver,Digigram VX222 driver,YMFPCI driver
    Set the module owner field in each driver's struct pci_driver to get
    the driver symlink in the sysfs device directory.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 10a487a78d68..ecdcada90ca2 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2763,6 +2763,7 @@ static void __devexit snd_es1968_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "ES1968 (ESS Maestro)",
+	.owner = THIS_MODULE,
 	.id_table = snd_es1968_ids,
 	.probe = snd_es1968_probe,
 	.remove = __devexit_p(snd_es1968_remove),

commit e560d8d8368ad8b6161839984b253de622863265
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:21:46 2005 +0200

    [ALSA] Replace with kzalloc() - pci stuff
    
    AD1889 driver,ATIIXP driver,ATIIXP-modem driver,AZT3328 driver
    BT87x driver,CMIPCI driver,CS4281 driver,ENS1370/1+ driver
    ES1938 driver,ES1968 driver,FM801 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,SonicVibes driver,VIA82xx driver
    VIA82xx-modem driver,AC97 Codec,AK4531 codec,au88x0 driver
    CA0106 driver,CS46xx driver,EMU10K1/EMU10K2 driver,HDA Codec driver
    HDA generic driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,Trident driver,YMFPCI driver
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 8cfe80fcd774..10a487a78d68 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -1577,7 +1577,7 @@ static int snd_es1968_playback_open(snd_pcm_substream_t *substream)
 	if (apu1 < 0)
 		return apu1;
 
-	es = kcalloc(1, sizeof(*es), GFP_KERNEL);
+	es = kzalloc(sizeof(*es), GFP_KERNEL);
 	if (!es) {
 		snd_es1968_free_apu_pair(chip, apu1);
 		return -ENOMEM;
@@ -1622,7 +1622,7 @@ static int snd_es1968_capture_open(snd_pcm_substream_t *substream)
 		return apu2;
 	}
 	
-	es = kcalloc(1, sizeof(*es), GFP_KERNEL);
+	es = kzalloc(sizeof(*es), GFP_KERNEL);
 	if (!es) {
 		snd_es1968_free_apu_pair(chip, apu1);
 		snd_es1968_free_apu_pair(chip, apu2);
@@ -2569,7 +2569,7 @@ static int __devinit snd_es1968_create(snd_card_t * card,
 		return -ENXIO;
 	}
 
-	chip = kcalloc(1, sizeof(*chip), GFP_KERNEL);
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
 	if (! chip) {
 		pci_disable_device(pci);
 		return -ENOMEM;

commit 8cdfd2519c6c9a1e6057dc5970b2542b35895738
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 7 14:08:11 2005 +0200

    [ALSA] Remove superfluous PCI ID definitions
    
    CS46xx driver,EMU10K1/EMU10K2 driver,PCM Midlevel,Trident driver
    YMFPCI driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,RME32 driver,RME96 driver
    SonicVibes driver,VIA82xx driver,ALI5451 driver,ICE1712 driver
    ICE1724 driver,NM256 driver,RME HDSP driver,RME9652 driver
    Remove superfluous PCI ID definitions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 9d7a28783930..8cfe80fcd774 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -160,25 +160,6 @@ MODULE_PARM_DESC(joystick, "Enable joystick.");
 #endif
 
 
-/* PCI Dev ID's */
-
-#ifndef PCI_VENDOR_ID_ESS
-#define PCI_VENDOR_ID_ESS	0x125D
-#endif
-
-#define PCI_VENDOR_ID_ESS_OLD	0x1285	/* Platform Tech, the people the ESS
-					   was bought form */
-
-#ifndef PCI_DEVICE_ID_ESS_M2E
-#define PCI_DEVICE_ID_ESS_M2E	0x1978
-#endif
-#ifndef PCI_DEVICE_ID_ESS_M2
-#define PCI_DEVICE_ID_ESS_M2	0x1968
-#endif
-#ifndef PCI_DEVICE_ID_ESS_M1
-#define PCI_DEVICE_ID_ESS_M1	0x0100
-#endif
-
 #define NR_APUS			64
 #define NR_APU_REGS		16
 

commit ef21ca24faf28df6d06939e77d5032a313490289
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Sat Jul 9 10:13:22 2005 +0200

    [ALSA] sound/pci: fix-up sleeping paths
    
    ENS1370/1+ driver,ES1968 driver,Intel8x0 driver,VIA82xx driver
    VIA82xx-modem driver,AC97 Codec,ALI5451 driver,CS46xx driver
    MIXART driver,RME HDSP driver,Trident driver,YMFPCI driver
    Description: Fix-up sleeping in sound/pci. These changes fall under the
    following two categories:
    
            1) Replace schedule_timeout() with msleep() to guarantee the
            task delays as expected. This also involved replacing/removing
            custom sleep functions.
            2) Do not assume jiffies will only increment by one if you
            request a 1 jiffy sleep, i.e. use time_after/time_before in
            while loops.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index 327a341e276b..9d7a28783930 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -664,11 +664,6 @@ static inline u16 maestro_read(es1968_t *chip, u16 reg)
 	return result;
 }
 
-#define big_mdelay(msec) do {\
-	set_current_state(TASK_UNINTERRUPTIBLE);\
-	schedule_timeout(((msec) * HZ + 999) / 1000);\
-} while (0)
-	
 /* Wait for the codec bus to be free */
 static int snd_es1968_ac97_wait(es1968_t *chip)
 {
@@ -1809,8 +1804,7 @@ static void __devinit es1968_measure_clock(es1968_t *chip)
 	snd_es1968_trigger_apu(chip, apu, ESM_APU_16BITLINEAR);
 	do_gettimeofday(&start_time);
 	spin_unlock_irq(&chip->reg_lock);
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	schedule_timeout(HZ / 20); /* 50 msec */
+	msleep(50);
 	spin_lock_irq(&chip->reg_lock);
 	offset = __apu_get_register(chip, apu, 5);
 	do_gettimeofday(&stop_time);
@@ -2093,7 +2087,7 @@ static void snd_es1968_ac97_reset(es1968_t *chip)
 	outw(0x0000, ioaddr + 0x60);	/* write 0 to gpio 0 */
 	udelay(20);
 	outw(0x0001, ioaddr + 0x60);	/* write 1 to gpio 1 */
-	big_mdelay(20);
+	msleep(20);
 
 	outw(save_68 | 0x1, ioaddr + 0x68);	/* now restore .. */
 	outw((inw(ioaddr + 0x38) & 0xfffc) | 0x1, ioaddr + 0x38);
@@ -2109,7 +2103,7 @@ static void snd_es1968_ac97_reset(es1968_t *chip)
 	outw(0x0001, ioaddr + 0x60);	/* write 1 to gpio */
 	udelay(20);
 	outw(0x0009, ioaddr + 0x60);	/* write 9 to gpio */
-	big_mdelay(500);
+	msleep(500);
 	//outw(inw(ioaddr + 0x38) & 0xfffc, ioaddr + 0x38);
 	outw(inw(ioaddr + 0x3a) & 0xfffc, ioaddr + 0x3a);
 	outw(inw(ioaddr + 0x3c) & 0xfffc, ioaddr + 0x3c);
@@ -2135,7 +2129,7 @@ static void snd_es1968_ac97_reset(es1968_t *chip)
 
 		if (w > 10000) {
 			outb(inb(ioaddr + 0x37) | 0x08, ioaddr + 0x37);	/* do a software reset */
-			big_mdelay(500);	/* oh my.. */
+			msleep(500);	/* oh my.. */
 			outb(inb(ioaddr + 0x37) & ~0x08,
 				ioaddr + 0x37);
 			udelay(1);

commit 77933d7276ee8fa0e2947641941a6f7a100a327b
Author: Jesper Juhl <juhl@dif.dk>
Date:   Wed Jul 27 11:46:09 2005 -0700

    [PATCH] clean up inline static vs static inline
    
    `gcc -W' likes to complain if the static keyword is not at the beginning of
    the declaration.  This patch fixes all remaining occurrences of "inline
    static" up with "static inline" in the entire kernel tree (140 occurrences in
    47 files).
    
    While making this change I came across a few lines with trailing whitespace
    that I also fixed up, I have also added or removed a blank line or two here
    and there, but there are no functional changes in the patch.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index ea889b311390..327a341e276b 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -636,7 +636,7 @@ static void __maestro_write(es1968_t *chip, u16 reg, u16 data)
 	chip->maestro_map[reg] = data;
 }
 
-inline static void maestro_write(es1968_t *chip, u16 reg, u16 data)
+static inline void maestro_write(es1968_t *chip, u16 reg, u16 data)
 {
 	unsigned long flags;
 	spin_lock_irqsave(&chip->reg_lock, flags);
@@ -654,7 +654,7 @@ static u16 __maestro_read(es1968_t *chip, u16 reg)
 	return chip->maestro_map[reg];
 }
 
-inline static u16 maestro_read(es1968_t *chip, u16 reg)
+static inline u16 maestro_read(es1968_t *chip, u16 reg)
 {
 	unsigned long flags;
 	u16 result;
@@ -755,7 +755,7 @@ static void __apu_set_register(es1968_t *chip, u16 channel, u8 reg, u16 data)
 	apu_data_set(chip, data);
 }
 
-inline static void apu_set_register(es1968_t *chip, u16 channel, u8 reg, u16 data)
+static inline void apu_set_register(es1968_t *chip, u16 channel, u8 reg, u16 data)
 {
 	unsigned long flags;
 	spin_lock_irqsave(&chip->reg_lock, flags);
@@ -771,7 +771,7 @@ static u16 __apu_get_register(es1968_t *chip, u16 channel, u8 reg)
 	return __maestro_read(chip, IDR0_DATA_PORT);
 }
 
-inline static u16 apu_get_register(es1968_t *chip, u16 channel, u8 reg)
+static inline u16 apu_get_register(es1968_t *chip, u16 channel, u8 reg)
 {
 	unsigned long flags;
 	u16 v;
@@ -957,7 +957,7 @@ static u32 snd_es1968_compute_rate(es1968_t *chip, u32 freq)
 }
 
 /* get current pointer */
-inline static unsigned int
+static inline unsigned int
 snd_es1968_get_dma_ptr(es1968_t *chip, esschan_t *es)
 {
 	unsigned int offset;
@@ -978,7 +978,7 @@ static void snd_es1968_apu_set_freq(es1968_t *chip, int apu, int freq)
 }
 
 /* spin lock held */
-inline static void snd_es1968_trigger_apu(es1968_t *esm, int apu, int mode)
+static inline void snd_es1968_trigger_apu(es1968_t *esm, int apu, int mode)
 {
 	/* set the APU mode */
 	__apu_set_register(esm, apu, 0,

commit e6e514fa825be7362a955ba43d6fd18896d375c2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon May 23 10:33:08 2005 +0200

    [ALSA] Add the vendor 0x1558 to PM whitelist of es1968
    
    ES1968 driver
    Added the vendor id 0x1558 to the power management whitelist of es1968 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index da10d40b2d91..ea889b311390 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2559,6 +2559,7 @@ static struct ess_device_list pm_whitelist[] __devinitdata = {
 	{ TYPE_MAESTRO2E, 0x103c },
 	{ TYPE_MAESTRO2E, 0x1179 },
 	{ TYPE_MAESTRO2E, 0x14c0 },	/* HP omnibook 4150 */
+	{ TYPE_MAESTRO2E, 0x1558 },
 };
 
 static struct ess_device_list mpu_blacklist[] __devinitdata = {

commit 01d25d460a3b28aab537fab9a0038d1b5832ce28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 11 16:58:24 2005 +0200

    [ALSA] Replace pci_module_init() with pci_register_driver()
    
    Documentation,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CA0106 driver,CS46xx driver
    EMU10K1/EMU10K2 driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,RME HDSP driver
    RME9652 driver,Trident driver,Digigram VX222 driver,YMFPCI driver
    Replace the obsolete pci_module_init() with pci_register_driver().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
index faf63ff19c42..da10d40b2d91 100644
--- a/sound/pci/es1968.c
+++ b/sound/pci/es1968.c
@@ -2795,7 +2795,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_es1968_init(void)
 {
-	return pci_module_init(&driver);
+	return pci_register_driver(&driver);
 }
 
 static void __exit alsa_card_es1968_exit(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/es1968.c b/sound/pci/es1968.c
new file mode 100644
index 000000000000..faf63ff19c42
--- /dev/null
+++ b/sound/pci/es1968.c
@@ -0,0 +1,2807 @@
+/*
+ *  Driver for ESS Maestro 1/2/2E Sound Card (started 21.8.99)
+ *  Copyright (c) by Matze Braun <MatzeBraun@gmx.de>.
+ *                   Takashi Iwai <tiwai@suse.de>
+ *                  
+ *  Most of the driver code comes from Zach Brown(zab@redhat.com)
+ *	Alan Cox OSS Driver
+ *  Rewritted from card-es1938.c source.
+ *
+ *  TODO:
+ *   Perhaps Synth
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *
+ *  Notes from Zach Brown about the driver code
+ *
+ *  Hardware Description
+ *
+ *	A working Maestro setup contains the Maestro chip wired to a 
+ *	codec or 2.  In the Maestro we have the APUs, the ASSP, and the
+ *	Wavecache.  The APUs can be though of as virtual audio routing
+ *	channels.  They can take data from a number of sources and perform
+ *	basic encodings of the data.  The wavecache is a storehouse for
+ *	PCM data.  Typically it deals with PCI and interracts with the
+ *	APUs.  The ASSP is a wacky DSP like device that ESS is loth
+ *	to release docs on.  Thankfully it isn't required on the Maestro
+ *	until you start doing insane things like FM emulation and surround
+ *	encoding.  The codecs are almost always AC-97 compliant codecs, 
+ *	but it appears that early Maestros may have had PT101 (an ESS
+ *	part?) wired to them.  The only real difference in the Maestro
+ *	families is external goop like docking capability, memory for
+ *	the ASSP, and initialization differences.
+ *
+ *  Driver Operation
+ *
+ *	We only drive the APU/Wavecache as typical DACs and drive the
+ *	mixers in the codecs.  There are 64 APUs.  We assign 6 to each
+ *	/dev/dsp? device.  2 channels for output, and 4 channels for
+ *	input.
+ *
+ *	Each APU can do a number of things, but we only really use
+ *	3 basic functions.  For playback we use them to convert PCM
+ *	data fetched over PCI by the wavecahche into analog data that
+ *	is handed to the codec.  One APU for mono, and a pair for stereo.
+ *	When in stereo, the combination of smarts in the APU and Wavecache
+ *	decide which wavecache gets the left or right channel.
+ *
+ *	For record we still use the old overly mono system.  For each in
+ *	coming channel the data comes in from the codec, through a 'input'
+ *	APU, through another rate converter APU, and then into memory via
+ *	the wavecache and PCI.  If its stereo, we mash it back into LRLR in
+ *	software.  The pass between the 2 APUs is supposedly what requires us
+ *	to have a 512 byte buffer sitting around in wavecache/memory.
+ *
+ *	The wavecache makes our life even more fun.  First off, it can
+ *	only address the first 28 bits of PCI address space, making it
+ *	useless on quite a few architectures.  Secondly, its insane.
+ *	It claims to fetch from 4 regions of PCI space, each 4 meg in length.
+ *	But that doesn't really work.  You can only use 1 region.  So all our
+ *	allocations have to be in 4meg of each other.  Booo.  Hiss.
+ *	So we have a module parameter, dsps_order, that is the order of
+ *	the number of dsps to provide.  All their buffer space is allocated
+ *	on open time.  The sonicvibes OSS routines we inherited really want
+ *	power of 2 buffers, so we have all those next to each other, then
+ *	512 byte regions for the recording wavecaches.  This ends up
+ *	wasting quite a bit of memory.  The only fixes I can see would be 
+ *	getting a kernel allocator that could work in zones, or figuring out
+ *	just how to coerce the WP into doing what we want.
+ *
+ *	The indirection of the various registers means we have to spinlock
+ *	nearly all register accesses.  We have the main register indirection
+ *	like the wave cache, maestro registers, etc.  Then we have beasts
+ *	like the APU interface that is indirect registers gotten at through
+ *	the main maestro indirection.  Ouch.  We spinlock around the actual
+ *	ports on a per card basis.  This means spinlock activity at each IO
+ *	operation, but the only IO operation clusters are in non critical 
+ *	paths and it makes the code far easier to follow.  Interrupts are
+ *	blocked while holding the locks because the int handler has to
+ *	get at some of them :(.  The mixer interface doesn't, however.
+ *	We also have an OSS state lock that is thrown around in a few
+ *	places.
+ */
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/gameport.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/mpu401.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+
+#define CARD_NAME "ESS Maestro1/2"
+#define DRIVER_NAME "ES1968"
+
+MODULE_DESCRIPTION("ESS Maestro");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{ESS,Maestro 2e},"
+		"{ESS,Maestro 2},"
+		"{ESS,Maestro 1},"
+		"{TerraTec,DMX}}");
+
+#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+#define SUPPORT_JOYSTICK 1
+#endif
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 1-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static int total_bufsize[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1024 };
+static int pcm_substreams_p[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 4 };
+static int pcm_substreams_c[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 1 };
+static int clock[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
+static int use_pm[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
+static int enable_mpu[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 2};
+#ifdef SUPPORT_JOYSTICK
+static int joystick[SNDRV_CARDS];
+#endif
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable " CARD_NAME " soundcard.");
+module_param_array(total_bufsize, int, NULL, 0444);
+MODULE_PARM_DESC(total_bufsize, "Total buffer size in kB.");
+module_param_array(pcm_substreams_p, int, NULL, 0444);
+MODULE_PARM_DESC(pcm_substreams_p, "PCM Playback substreams for " CARD_NAME " soundcard.");
+module_param_array(pcm_substreams_c, int, NULL, 0444);
+MODULE_PARM_DESC(pcm_substreams_c, "PCM Capture substreams for " CARD_NAME " soundcard.");
+module_param_array(clock, int, NULL, 0444);
+MODULE_PARM_DESC(clock, "Clock on " CARD_NAME " soundcard.  (0 = auto-detect)");
+module_param_array(use_pm, int, NULL, 0444);
+MODULE_PARM_DESC(use_pm, "Toggle power-management.  (0 = off, 1 = on, 2 = auto)");
+module_param_array(enable_mpu, int, NULL, 0444);
+MODULE_PARM_DESC(enable_mpu, "Enable MPU401.  (0 = off, 1 = on, 2 = auto)");
+#ifdef SUPPORT_JOYSTICK
+module_param_array(joystick, bool, NULL, 0444);
+MODULE_PARM_DESC(joystick, "Enable joystick.");
+#endif
+
+
+/* PCI Dev ID's */
+
+#ifndef PCI_VENDOR_ID_ESS
+#define PCI_VENDOR_ID_ESS	0x125D
+#endif
+
+#define PCI_VENDOR_ID_ESS_OLD	0x1285	/* Platform Tech, the people the ESS
+					   was bought form */
+
+#ifndef PCI_DEVICE_ID_ESS_M2E
+#define PCI_DEVICE_ID_ESS_M2E	0x1978
+#endif
+#ifndef PCI_DEVICE_ID_ESS_M2
+#define PCI_DEVICE_ID_ESS_M2	0x1968
+#endif
+#ifndef PCI_DEVICE_ID_ESS_M1
+#define PCI_DEVICE_ID_ESS_M1	0x0100
+#endif
+
+#define NR_APUS			64
+#define NR_APU_REGS		16
+
+/* NEC Versas ? */
+#define NEC_VERSA_SUBID1	0x80581033
+#define NEC_VERSA_SUBID2	0x803c1033
+
+/* Mode Flags */
+#define ESS_FMT_STEREO     	0x01
+#define ESS_FMT_16BIT      	0x02
+
+#define DAC_RUNNING		1
+#define ADC_RUNNING		2
+
+/* Values for the ESM_LEGACY_AUDIO_CONTROL */
+
+#define ESS_ENABLE_AUDIO	0x8000
+#define ESS_ENABLE_SERIAL_IRQ	0x4000
+#define IO_ADRESS_ALIAS		0x0020
+#define MPU401_IRQ_ENABLE	0x0010
+#define MPU401_IO_ENABLE	0x0008
+#define GAME_IO_ENABLE		0x0004
+#define FM_IO_ENABLE		0x0002
+#define SB_IO_ENABLE		0x0001
+
+/* Values for the ESM_CONFIG_A */
+
+#define PIC_SNOOP1		0x4000
+#define PIC_SNOOP2		0x2000
+#define SAFEGUARD		0x0800
+#define DMA_CLEAR		0x0700
+#define DMA_DDMA		0x0000
+#define DMA_TDMA		0x0100
+#define DMA_PCPCI		0x0200
+#define POST_WRITE		0x0080
+#define ISA_TIMING		0x0040
+#define SWAP_LR			0x0020
+#define SUBTR_DECODE		0x0002
+
+/* Values for the ESM_CONFIG_B */
+
+#define SPDIF_CONFB		0x0100
+#define HWV_CONFB		0x0080
+#define DEBOUNCE		0x0040
+#define GPIO_CONFB		0x0020
+#define CHI_CONFB		0x0010
+#define IDMA_CONFB		0x0008	/*undoc */
+#define MIDI_FIX		0x0004	/*undoc */
+#define IRQ_TO_ISA		0x0001	/*undoc */
+
+/* Values for Ring Bus Control B */
+#define	RINGB_2CODEC_ID_MASK	0x0003
+#define RINGB_DIS_VALIDATION	0x0008
+#define RINGB_EN_SPDIF		0x0010
+#define	RINGB_EN_2CODEC		0x0020
+#define RINGB_SING_BIT_DUAL	0x0040
+
+/* ****Port Adresses**** */
+
+/*   Write & Read */
+#define ESM_INDEX		0x02
+#define ESM_DATA		0x00
+
+/*   AC97 + RingBus */
+#define ESM_AC97_INDEX		0x30
+#define	ESM_AC97_DATA		0x32
+#define ESM_RING_BUS_DEST	0x34
+#define ESM_RING_BUS_CONTR_A	0x36
+#define ESM_RING_BUS_CONTR_B	0x38
+#define ESM_RING_BUS_SDO	0x3A
+
+/*   WaveCache*/
+#define WC_INDEX		0x10
+#define WC_DATA			0x12
+#define WC_CONTROL		0x14
+
+/*   ASSP*/
+#define ASSP_INDEX		0x80
+#define ASSP_MEMORY		0x82
+#define ASSP_DATA		0x84
+#define ASSP_CONTROL_A		0xA2
+#define ASSP_CONTROL_B		0xA4
+#define ASSP_CONTROL_C		0xA6
+#define ASSP_HOSTW_INDEX	0xA8
+#define ASSP_HOSTW_DATA		0xAA
+#define ASSP_HOSTW_IRQ		0xAC
+/* Midi */
+#define ESM_MPU401_PORT		0x98
+/* Others */
+#define ESM_PORT_HOST_IRQ	0x18
+
+#define IDR0_DATA_PORT		0x00
+#define IDR1_CRAM_POINTER	0x01
+#define IDR2_CRAM_DATA		0x02
+#define IDR3_WAVE_DATA		0x03
+#define IDR4_WAVE_PTR_LOW	0x04
+#define IDR5_WAVE_PTR_HI	0x05
+#define IDR6_TIMER_CTRL		0x06
+#define IDR7_WAVE_ROMRAM	0x07
+
+#define WRITEABLE_MAP		0xEFFFFF
+#define READABLE_MAP		0x64003F
+
+/* PCI Register */
+
+#define ESM_LEGACY_AUDIO_CONTROL 0x40
+#define ESM_ACPI_COMMAND	0x54
+#define ESM_CONFIG_A		0x50
+#define ESM_CONFIG_B		0x52
+#define ESM_DDMA		0x60
+
+/* Bob Bits */
+#define ESM_BOB_ENABLE		0x0001
+#define ESM_BOB_START		0x0001
+
+/* Host IRQ Control Bits */
+#define ESM_RESET_MAESTRO	0x8000
+#define ESM_RESET_DIRECTSOUND   0x4000
+#define ESM_HIRQ_ClkRun		0x0100
+#define ESM_HIRQ_HW_VOLUME	0x0040
+#define ESM_HIRQ_HARPO		0x0030	/* What's that? */
+#define ESM_HIRQ_ASSP		0x0010
+#define	ESM_HIRQ_DSIE		0x0004
+#define ESM_HIRQ_MPU401		0x0002
+#define ESM_HIRQ_SB		0x0001
+
+/* Host IRQ Status Bits */
+#define ESM_MPU401_IRQ		0x02
+#define ESM_SB_IRQ		0x01
+#define ESM_SOUND_IRQ		0x04
+#define	ESM_ASSP_IRQ		0x10
+#define ESM_HWVOL_IRQ		0x40
+
+#define ESS_SYSCLK		50000000
+#define ESM_BOB_FREQ 		200
+#define ESM_BOB_FREQ_MAX	800
+
+#define ESM_FREQ_ESM1  		(49152000L / 1024L)	/* default rate 48000 */
+#define ESM_FREQ_ESM2  		(50000000L / 1024L)
+
+/* APU Modes: reg 0x00, bit 4-7 */
+#define ESM_APU_MODE_SHIFT	4
+#define ESM_APU_MODE_MASK	(0xf << 4)
+#define	ESM_APU_OFF		0x00
+#define	ESM_APU_16BITLINEAR	0x01	/* 16-Bit Linear Sample Player */
+#define	ESM_APU_16BITSTEREO	0x02	/* 16-Bit Stereo Sample Player */
+#define	ESM_APU_8BITLINEAR	0x03	/* 8-Bit Linear Sample Player */
+#define	ESM_APU_8BITSTEREO	0x04	/* 8-Bit Stereo Sample Player */
+#define	ESM_APU_8BITDIFF	0x05	/* 8-Bit Differential Sample Playrer */
+#define	ESM_APU_DIGITALDELAY	0x06	/* Digital Delay Line */
+#define	ESM_APU_DUALTAP		0x07	/* Dual Tap Reader */
+#define	ESM_APU_CORRELATOR	0x08	/* Correlator */
+#define	ESM_APU_INPUTMIXER	0x09	/* Input Mixer */
+#define	ESM_APU_WAVETABLE	0x0A	/* Wave Table Mode */
+#define	ESM_APU_SRCONVERTOR	0x0B	/* Sample Rate Convertor */
+#define	ESM_APU_16BITPINGPONG	0x0C	/* 16-Bit Ping-Pong Sample Player */
+#define	ESM_APU_RESERVED1	0x0D	/* Reserved 1 */
+#define	ESM_APU_RESERVED2	0x0E	/* Reserved 2 */
+#define	ESM_APU_RESERVED3	0x0F	/* Reserved 3 */
+
+/* reg 0x00 */
+#define ESM_APU_FILTER_Q_SHIFT		0
+#define ESM_APU_FILTER_Q_MASK		(3 << 0)
+/* APU Filtey Q Control */
+#define ESM_APU_FILTER_LESSQ	0x00
+#define ESM_APU_FILTER_MOREQ	0x03
+
+#define ESM_APU_FILTER_TYPE_SHIFT	2
+#define ESM_APU_FILTER_TYPE_MASK	(3 << 2)
+#define ESM_APU_ENV_TYPE_SHIFT		8
+#define ESM_APU_ENV_TYPE_MASK		(3 << 8)
+#define ESM_APU_ENV_STATE_SHIFT		10
+#define ESM_APU_ENV_STATE_MASK		(3 << 10)
+#define ESM_APU_END_CURVE		(1 << 12)
+#define ESM_APU_INT_ON_LOOP		(1 << 13)
+#define ESM_APU_DMA_ENABLE		(1 << 14)
+
+/* reg 0x02 */
+#define ESM_APU_SUBMIX_GROUP_SHIRT	0
+#define ESM_APU_SUBMIX_GROUP_MASK	(7 << 0)
+#define ESM_APU_SUBMIX_MODE		(1 << 3)
+#define ESM_APU_6dB			(1 << 4)
+#define ESM_APU_DUAL_EFFECT		(1 << 5)
+#define ESM_APU_EFFECT_CHANNELS_SHIFT	6
+#define ESM_APU_EFFECT_CHANNELS_MASK	(3 << 6)
+
+/* reg 0x03 */
+#define ESM_APU_STEP_SIZE_MASK		0x0fff
+
+/* reg 0x04 */
+#define ESM_APU_PHASE_SHIFT		0
+#define ESM_APU_PHASE_MASK		(0xff << 0)
+#define ESM_APU_WAVE64K_PAGE_SHIFT	8	/* most 8bit of wave start offset */
+#define ESM_APU_WAVE64K_PAGE_MASK	(0xff << 8)
+
+/* reg 0x05 - wave start offset */
+/* reg 0x06 - wave end offset */
+/* reg 0x07 - wave loop length */
+
+/* reg 0x08 */
+#define ESM_APU_EFFECT_GAIN_SHIFT	0
+#define ESM_APU_EFFECT_GAIN_MASK	(0xff << 0)
+#define ESM_APU_TREMOLO_DEPTH_SHIFT	8
+#define ESM_APU_TREMOLO_DEPTH_MASK	(0xf << 8)
+#define ESM_APU_TREMOLO_RATE_SHIFT	12
+#define ESM_APU_TREMOLO_RATE_MASK	(0xf << 12)
+
+/* reg 0x09 */
+/* bit 0-7 amplitude dest? */
+#define ESM_APU_AMPLITUDE_NOW_SHIFT	8
+#define ESM_APU_AMPLITUDE_NOW_MASK	(0xff << 8)
+
+/* reg 0x0a */
+#define ESM_APU_POLAR_PAN_SHIFT		0
+#define ESM_APU_POLAR_PAN_MASK		(0x3f << 0)
+/* Polar Pan Control */
+#define	ESM_APU_PAN_CENTER_CIRCLE		0x00
+#define	ESM_APU_PAN_MIDDLE_RADIUS		0x01
+#define	ESM_APU_PAN_OUTSIDE_RADIUS		0x02
+
+#define ESM_APU_FILTER_TUNING_SHIFT	8
+#define ESM_APU_FILTER_TUNING_MASK	(0xff << 8)
+
+/* reg 0x0b */
+#define ESM_APU_DATA_SRC_A_SHIFT	0
+#define ESM_APU_DATA_SRC_A_MASK		(0x7f << 0)
+#define ESM_APU_INV_POL_A		(1 << 7)
+#define ESM_APU_DATA_SRC_B_SHIFT	8
+#define ESM_APU_DATA_SRC_B_MASK		(0x7f << 8)
+#define ESM_APU_INV_POL_B		(1 << 15)
+
+#define ESM_APU_VIBRATO_RATE_SHIFT	0
+#define ESM_APU_VIBRATO_RATE_MASK	(0xf << 0)
+#define ESM_APU_VIBRATO_DEPTH_SHIFT	4
+#define ESM_APU_VIBRATO_DEPTH_MASK	(0xf << 4)
+#define ESM_APU_VIBRATO_PHASE_SHIFT	8
+#define ESM_APU_VIBRATO_PHASE_MASK	(0xff << 8)
+
+/* reg 0x0c */
+#define ESM_APU_RADIUS_SELECT		(1 << 6)
+
+/* APU Filter Control */
+#define	ESM_APU_FILTER_2POLE_LOPASS	0x00
+#define	ESM_APU_FILTER_2POLE_BANDPASS	0x01
+#define	ESM_APU_FILTER_2POLE_HIPASS	0x02
+#define	ESM_APU_FILTER_1POLE_LOPASS	0x03
+#define	ESM_APU_FILTER_1POLE_HIPASS	0x04
+#define	ESM_APU_FILTER_OFF		0x05
+
+/* APU ATFP Type */
+#define	ESM_APU_ATFP_AMPLITUDE			0x00
+#define	ESM_APU_ATFP_TREMELO			0x01
+#define	ESM_APU_ATFP_FILTER			0x02
+#define	ESM_APU_ATFP_PAN			0x03
+
+/* APU ATFP Flags */
+#define	ESM_APU_ATFP_FLG_OFF			0x00
+#define	ESM_APU_ATFP_FLG_WAIT			0x01
+#define	ESM_APU_ATFP_FLG_DONE			0x02
+#define	ESM_APU_ATFP_FLG_INPROCESS		0x03
+
+
+/* capture mixing buffer size */
+#define ESM_MEM_ALIGN		0x1000
+#define ESM_MIXBUF_SIZE		0x400
+
+#define ESM_MODE_PLAY		0
+#define ESM_MODE_CAPTURE	1
+
+/* acpi states */
+enum {
+	ACPI_D0=0,
+	ACPI_D1,
+	ACPI_D2,
+	ACPI_D3
+};
+
+/* bits in the acpi masks */
+#define ACPI_12MHZ	( 1 << 15)
+#define ACPI_24MHZ	( 1 << 14)
+#define ACPI_978	( 1 << 13)
+#define ACPI_SPDIF	( 1 << 12)
+#define ACPI_GLUE	( 1 << 11)
+#define ACPI__10	( 1 << 10) /* reserved */
+#define ACPI_PCIINT	( 1 << 9)
+#define ACPI_HV		( 1 << 8) /* hardware volume */
+#define ACPI_GPIO	( 1 << 7)
+#define ACPI_ASSP	( 1 << 6)
+#define ACPI_SB		( 1 << 5) /* sb emul */
+#define ACPI_FM		( 1 << 4) /* fm emul */
+#define ACPI_RB		( 1 << 3) /* ringbus / aclink */
+#define ACPI_MIDI	( 1 << 2) 
+#define ACPI_GP		( 1 << 1) /* game port */
+#define ACPI_WP		( 1 << 0) /* wave processor */
+
+#define ACPI_ALL	(0xffff)
+#define ACPI_SLEEP	(~(ACPI_SPDIF|ACPI_ASSP|ACPI_SB|ACPI_FM| \
+			ACPI_MIDI|ACPI_GP|ACPI_WP))
+#define ACPI_NONE	(ACPI__10)
+
+/* these masks indicate which units we care about at
+	which states */
+static u16 acpi_state_mask[] = {
+	[ACPI_D0] = ACPI_ALL,
+	[ACPI_D1] = ACPI_SLEEP,
+	[ACPI_D2] = ACPI_SLEEP,
+	[ACPI_D3] = ACPI_NONE
+};
+
+
+typedef struct snd_es1968 es1968_t;
+typedef struct snd_esschan esschan_t;
+typedef struct snd_esm_memory esm_memory_t;
+
+/* APU use in the driver */
+enum snd_enum_apu_type {
+	ESM_APU_PCM_PLAY,
+	ESM_APU_PCM_CAPTURE,
+	ESM_APU_PCM_RATECONV,
+	ESM_APU_FREE
+};
+
+/* chip type */
+enum {
+	TYPE_MAESTRO, TYPE_MAESTRO2, TYPE_MAESTRO2E
+};
+
+/* DMA Hack! */
+struct snd_esm_memory {
+	struct snd_dma_buffer buf;
+	int empty;	/* status */
+	struct list_head list;
+};
+
+/* Playback Channel */
+struct snd_esschan {
+	int running;
+
+	u8 apu[4];
+	u8 apu_mode[4];
+
+	/* playback/capture pcm buffer */
+	esm_memory_t *memory;
+	/* capture mixer buffer */
+	esm_memory_t *mixbuf;
+
+	unsigned int hwptr;	/* current hw pointer in bytes */
+	unsigned int count;	/* sample counter in bytes */
+	unsigned int dma_size;	/* total buffer size in bytes */
+	unsigned int frag_size;	/* period size in bytes */
+	unsigned int wav_shift;
+	u16 base[4];		/* offset for ptr */
+
+	/* stereo/16bit flag */
+	unsigned char fmt;
+	int mode;	/* playback / capture */
+
+	int bob_freq;	/* required timer frequency */
+
+	snd_pcm_substream_t *substream;
+
+	/* linked list */
+	struct list_head list;
+
+#ifdef CONFIG_PM
+	u16 wc_map[4];
+#endif
+};
+
+struct snd_es1968 {
+	/* Module Config */
+	int total_bufsize;			/* in bytes */
+
+	int playback_streams, capture_streams;
+
+	unsigned int clock;		/* clock */
+	/* for clock measurement */
+	unsigned int in_measurement: 1;
+	unsigned int measure_apu;
+	unsigned int measure_lastpos;
+	unsigned int measure_count;
+
+	/* buffer */
+	struct snd_dma_buffer dma;
+
+	/* Resources... */
+	int irq;
+	unsigned long io_port;
+	int type;
+	struct pci_dev *pci;
+	snd_card_t *card;
+	snd_pcm_t *pcm;
+	int do_pm;		/* power-management enabled */
+
+	/* DMA memory block */
+	struct list_head buf_list;
+
+	/* ALSA Stuff */
+	ac97_t *ac97;
+	snd_kcontrol_t *master_switch; /* for h/w volume control */
+	snd_kcontrol_t *master_volume;
+
+	snd_rawmidi_t *rmidi;
+
+	spinlock_t reg_lock;
+	spinlock_t ac97_lock;
+	struct tasklet_struct hwvol_tq;
+	unsigned int in_suspend;
+
+	/* Maestro Stuff */
+	u16 maestro_map[32];
+	int bobclient;		/* active timer instancs */
+	int bob_freq;		/* timer frequency */
+	struct semaphore memory_mutex;	/* memory lock */
+
+	/* APU states */
+	unsigned char apu[NR_APUS];
+
+	/* active substreams */
+	struct list_head substream_list;
+	spinlock_t substream_lock;
+
+#ifdef CONFIG_PM
+	u16 apu_map[NR_APUS][NR_APU_REGS];
+#endif
+
+#ifdef SUPPORT_JOYSTICK
+	struct gameport *gameport;
+#endif
+};
+
+static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+
+static struct pci_device_id snd_es1968_ids[] = {
+	/* Maestro 1 */
+        { 0x1285, 0x0100, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, TYPE_MAESTRO },
+	/* Maestro 2 */
+	{ 0x125d, 0x1968, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, TYPE_MAESTRO2 },
+	/* Maestro 2E */
+        { 0x125d, 0x1978, PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_MULTIMEDIA_AUDIO << 8, 0xffff00, TYPE_MAESTRO2E },
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, snd_es1968_ids);
+
+/* *********************
+   * Low Level Funcs!  *
+   *********************/
+
+/* no spinlock */
+static void __maestro_write(es1968_t *chip, u16 reg, u16 data)
+{
+	outw(reg, chip->io_port + ESM_INDEX);
+	outw(data, chip->io_port + ESM_DATA);
+	chip->maestro_map[reg] = data;
+}
+
+inline static void maestro_write(es1968_t *chip, u16 reg, u16 data)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	__maestro_write(chip, reg, data);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+}
+
+/* no spinlock */
+static u16 __maestro_read(es1968_t *chip, u16 reg)
+{
+	if (READABLE_MAP & (1 << reg)) {
+		outw(reg, chip->io_port + ESM_INDEX);
+		chip->maestro_map[reg] = inw(chip->io_port + ESM_DATA);
+	}
+	return chip->maestro_map[reg];
+}
+
+inline static u16 maestro_read(es1968_t *chip, u16 reg)
+{
+	unsigned long flags;
+	u16 result;
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	result = __maestro_read(chip, reg);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	return result;
+}
+
+#define big_mdelay(msec) do {\
+	set_current_state(TASK_UNINTERRUPTIBLE);\
+	schedule_timeout(((msec) * HZ + 999) / 1000);\
+} while (0)
+	
+/* Wait for the codec bus to be free */
+static int snd_es1968_ac97_wait(es1968_t *chip)
+{
+	int timeout = 100000;
+
+	while (timeout-- > 0) {
+		if (!(inb(chip->io_port + ESM_AC97_INDEX) & 1))
+			return 0;
+		cond_resched();
+	}
+	snd_printd("es1968: ac97 timeout\n");
+	return 1; /* timeout */
+}
+
+static void snd_es1968_ac97_write(ac97_t *ac97, unsigned short reg, unsigned short val)
+{
+	es1968_t *chip = ac97->private_data;
+	unsigned long flags;
+
+	snd_es1968_ac97_wait(chip);
+
+	/* Write the bus */
+	spin_lock_irqsave(&chip->ac97_lock, flags);
+	outw(val, chip->io_port + ESM_AC97_DATA);
+	/*msleep(1);*/
+	outb(reg, chip->io_port + ESM_AC97_INDEX);
+	/*msleep(1);*/
+	spin_unlock_irqrestore(&chip->ac97_lock, flags);
+}
+
+static unsigned short snd_es1968_ac97_read(ac97_t *ac97, unsigned short reg)
+{
+	u16 data = 0;
+	es1968_t *chip = ac97->private_data;
+	unsigned long flags;
+
+	snd_es1968_ac97_wait(chip);
+
+	spin_lock_irqsave(&chip->ac97_lock, flags);
+	outb(reg | 0x80, chip->io_port + ESM_AC97_INDEX);
+	/*msleep(1);*/
+
+	if (! snd_es1968_ac97_wait(chip)) {
+		data = inw(chip->io_port + ESM_AC97_DATA);
+		/*msleep(1);*/
+	}
+	spin_unlock_irqrestore(&chip->ac97_lock, flags);
+
+	return data;
+}
+
+/* no spinlock */
+static void apu_index_set(es1968_t *chip, u16 index)
+{
+	int i;
+	__maestro_write(chip, IDR1_CRAM_POINTER, index);
+	for (i = 0; i < 1000; i++)
+		if (__maestro_read(chip, IDR1_CRAM_POINTER) == index)
+			return;
+	snd_printd("es1968: APU register select failed. (Timeout)\n");
+}
+
+/* no spinlock */
+static void apu_data_set(es1968_t *chip, u16 data)
+{
+	int i;
+	for (i = 0; i < 1000; i++) {
+		if (__maestro_read(chip, IDR0_DATA_PORT) == data)
+			return;
+		__maestro_write(chip, IDR0_DATA_PORT, data);
+	}
+	snd_printd("es1968: APU register set probably failed (Timeout)!\n");
+}
+
+/* no spinlock */
+static void __apu_set_register(es1968_t *chip, u16 channel, u8 reg, u16 data)
+{
+	snd_assert(channel < NR_APUS, return);
+#ifdef CONFIG_PM
+	chip->apu_map[channel][reg] = data;
+#endif
+	reg |= (channel << 4);
+	apu_index_set(chip, reg);
+	apu_data_set(chip, data);
+}
+
+inline static void apu_set_register(es1968_t *chip, u16 channel, u8 reg, u16 data)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	__apu_set_register(chip, channel, reg, data);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+}
+
+static u16 __apu_get_register(es1968_t *chip, u16 channel, u8 reg)
+{
+	snd_assert(channel < NR_APUS, return 0);
+	reg |= (channel << 4);
+	apu_index_set(chip, reg);
+	return __maestro_read(chip, IDR0_DATA_PORT);
+}
+
+inline static u16 apu_get_register(es1968_t *chip, u16 channel, u8 reg)
+{
+	unsigned long flags;
+	u16 v;
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	v = __apu_get_register(chip, channel, reg);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	return v;
+}
+
+#if 0 /* ASSP is not supported */
+
+static void assp_set_register(es1968_t *chip, u32 reg, u32 value)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	outl(reg, chip->io_port + ASSP_INDEX);
+	outl(value, chip->io_port + ASSP_DATA);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+}
+
+static u32 assp_get_register(es1968_t *chip, u32 reg)
+{
+	unsigned long flags;
+	u32 value;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	outl(reg, chip->io_port + ASSP_INDEX);
+	value = inl(chip->io_port + ASSP_DATA);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+
+	return value;
+}
+
+#endif
+
+static void wave_set_register(es1968_t *chip, u16 reg, u16 value)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	outw(reg, chip->io_port + WC_INDEX);
+	outw(value, chip->io_port + WC_DATA);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+}
+
+static u16 wave_get_register(es1968_t *chip, u16 reg)
+{
+	unsigned long flags;
+	u16 value;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	outw(reg, chip->io_port + WC_INDEX);
+	value = inw(chip->io_port + WC_DATA);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+
+	return value;
+}
+
+/* *******************
+   * Bob the Timer!  *
+   *******************/
+
+static void snd_es1968_bob_stop(es1968_t *chip)
+{
+	u16 reg;
+
+	reg = __maestro_read(chip, 0x11);
+	reg &= ~ESM_BOB_ENABLE;
+	__maestro_write(chip, 0x11, reg);
+	reg = __maestro_read(chip, 0x17);
+	reg &= ~ESM_BOB_START;
+	__maestro_write(chip, 0x17, reg);
+}
+
+static void snd_es1968_bob_start(es1968_t *chip)
+{
+	int prescale;
+	int divide;
+
+	/* compute ideal interrupt frequency for buffer size & play rate */
+	/* first, find best prescaler value to match freq */
+	for (prescale = 5; prescale < 12; prescale++)
+		if (chip->bob_freq > (ESS_SYSCLK >> (prescale + 9)))
+			break;
+
+	/* next, back off prescaler whilst getting divider into optimum range */
+	divide = 1;
+	while ((prescale > 5) && (divide < 32)) {
+		prescale--;
+		divide <<= 1;
+	}
+	divide >>= 1;
+
+	/* now fine-tune the divider for best match */
+	for (; divide < 31; divide++)
+		if (chip->bob_freq >
+		    ((ESS_SYSCLK >> (prescale + 9)) / (divide + 1))) break;
+
+	/* divide = 0 is illegal, but don't let prescale = 4! */
+	if (divide == 0) {
+		divide++;
+		if (prescale > 5)
+			prescale--;
+	} else if (divide > 1)
+		divide--;
+
+	__maestro_write(chip, 6, 0x9000 | (prescale << 5) | divide);	/* set reg */
+
+	/* Now set IDR 11/17 */
+	__maestro_write(chip, 0x11, __maestro_read(chip, 0x11) | 1);
+	__maestro_write(chip, 0x17, __maestro_read(chip, 0x17) | 1);
+}
+
+/* call with substream spinlock */
+static void snd_es1968_bob_inc(es1968_t *chip, int freq)
+{
+	chip->bobclient++;
+	if (chip->bobclient == 1) {
+		chip->bob_freq = freq;
+		snd_es1968_bob_start(chip);
+	} else if (chip->bob_freq < freq) {
+		snd_es1968_bob_stop(chip);
+		chip->bob_freq = freq;
+		snd_es1968_bob_start(chip);
+	}
+}
+
+/* call with substream spinlock */
+static void snd_es1968_bob_dec(es1968_t *chip)
+{
+	chip->bobclient--;
+	if (chip->bobclient <= 0)
+		snd_es1968_bob_stop(chip);
+	else if (chip->bob_freq > ESM_BOB_FREQ) {
+		/* check reduction of timer frequency */
+		struct list_head *p;
+		int max_freq = ESM_BOB_FREQ;
+		list_for_each(p, &chip->substream_list) {
+			esschan_t *es = list_entry(p, esschan_t, list);
+			if (max_freq < es->bob_freq)
+				max_freq = es->bob_freq;
+		}
+		if (max_freq != chip->bob_freq) {
+			snd_es1968_bob_stop(chip);
+			chip->bob_freq = max_freq;
+			snd_es1968_bob_start(chip);
+		}
+	}
+}
+
+static int
+snd_es1968_calc_bob_rate(es1968_t *chip, esschan_t *es,
+			 snd_pcm_runtime_t *runtime)
+{
+	/* we acquire 4 interrupts per period for precise control.. */
+	int freq = runtime->rate * 4;
+	if (es->fmt & ESS_FMT_STEREO)
+		freq <<= 1;
+	if (es->fmt & ESS_FMT_16BIT)
+		freq <<= 1;
+	freq /= es->frag_size;
+	if (freq < ESM_BOB_FREQ)
+		freq = ESM_BOB_FREQ;
+	else if (freq > ESM_BOB_FREQ_MAX)
+		freq = ESM_BOB_FREQ_MAX;
+	return freq;
+}
+
+
+/*************
+ *  PCM Part *
+ *************/
+
+static u32 snd_es1968_compute_rate(es1968_t *chip, u32 freq)
+{
+	u32 rate = (freq << 16) / chip->clock;
+#if 0 /* XXX: do we need this? */ 
+	if (rate > 0x10000)
+		rate = 0x10000;
+#endif
+	return rate;
+}
+
+/* get current pointer */
+inline static unsigned int
+snd_es1968_get_dma_ptr(es1968_t *chip, esschan_t *es)
+{
+	unsigned int offset;
+
+	offset = apu_get_register(chip, es->apu[0], 5);
+
+	offset -= es->base[0];
+
+	return (offset & 0xFFFE);	/* hardware is in words */
+}
+
+static void snd_es1968_apu_set_freq(es1968_t *chip, int apu, int freq)
+{
+	apu_set_register(chip, apu, 2,
+			   (apu_get_register(chip, apu, 2) & 0x00FF) |
+			   ((freq & 0xff) << 8) | 0x10);
+	apu_set_register(chip, apu, 3, freq >> 8);
+}
+
+/* spin lock held */
+inline static void snd_es1968_trigger_apu(es1968_t *esm, int apu, int mode)
+{
+	/* set the APU mode */
+	__apu_set_register(esm, apu, 0,
+			   (__apu_get_register(esm, apu, 0) & 0xff0f) |
+			   (mode << 4));
+}
+
+static void snd_es1968_pcm_start(es1968_t *chip, esschan_t *es)
+{
+	spin_lock(&chip->reg_lock);
+	__apu_set_register(chip, es->apu[0], 5, es->base[0]);
+	snd_es1968_trigger_apu(chip, es->apu[0], es->apu_mode[0]);
+	if (es->mode == ESM_MODE_CAPTURE) {
+		__apu_set_register(chip, es->apu[2], 5, es->base[2]);
+		snd_es1968_trigger_apu(chip, es->apu[2], es->apu_mode[2]);
+	}
+	if (es->fmt & ESS_FMT_STEREO) {
+		__apu_set_register(chip, es->apu[1], 5, es->base[1]);
+		snd_es1968_trigger_apu(chip, es->apu[1], es->apu_mode[1]);
+		if (es->mode == ESM_MODE_CAPTURE) {
+			__apu_set_register(chip, es->apu[3], 5, es->base[3]);
+			snd_es1968_trigger_apu(chip, es->apu[3], es->apu_mode[3]);
+		}
+	}
+	spin_unlock(&chip->reg_lock);
+}
+
+static void snd_es1968_pcm_stop(es1968_t *chip, esschan_t *es)
+{
+	spin_lock(&chip->reg_lock);
+	snd_es1968_trigger_apu(chip, es->apu[0], 0);
+	snd_es1968_trigger_apu(chip, es->apu[1], 0);
+	if (es->mode == ESM_MODE_CAPTURE) {
+		snd_es1968_trigger_apu(chip, es->apu[2], 0);
+		snd_es1968_trigger_apu(chip, es->apu[3], 0);
+	}
+	spin_unlock(&chip->reg_lock);
+}
+
+/* set the wavecache control reg */
+static void snd_es1968_program_wavecache(es1968_t *chip, esschan_t *es,
+					 int channel, u32 addr, int capture)
+{
+	u32 tmpval = (addr - 0x10) & 0xFFF8;
+
+	if (! capture) {
+		if (!(es->fmt & ESS_FMT_16BIT))
+			tmpval |= 4;	/* 8bit */
+		if (es->fmt & ESS_FMT_STEREO)
+			tmpval |= 2;	/* stereo */
+	}
+
+	/* set the wavecache control reg */
+	wave_set_register(chip, es->apu[channel] << 3, tmpval);
+
+#ifdef CONFIG_PM
+	es->wc_map[channel] = tmpval;
+#endif
+}
+
+
+static void snd_es1968_playback_setup(es1968_t *chip, esschan_t *es,
+				      snd_pcm_runtime_t *runtime)
+{
+	u32 pa;
+	int high_apu = 0;
+	int channel, apu;
+	int i, size;
+	unsigned long flags;
+	u32 freq;
+
+	size = es->dma_size >> es->wav_shift;
+
+	if (es->fmt & ESS_FMT_STEREO)
+		high_apu++;
+
+	for (channel = 0; channel <= high_apu; channel++) {
+		apu = es->apu[channel];
+
+		snd_es1968_program_wavecache(chip, es, channel, es->memory->buf.addr, 0);
+
+		/* Offset to PCMBAR */
+		pa = es->memory->buf.addr;
+		pa -= chip->dma.addr;
+		pa >>= 1;	/* words */
+
+		pa |= 0x00400000;	/* System RAM (Bit 22) */
+
+		if (es->fmt & ESS_FMT_STEREO) {
+			/* Enable stereo */
+			if (channel)
+				pa |= 0x00800000;	/* (Bit 23) */
+			if (es->fmt & ESS_FMT_16BIT)
+				pa >>= 1;
+		}
+
+		/* base offset of dma calcs when reading the pointer
+		   on this left one */
+		es->base[channel] = pa & 0xFFFF;
+
+		for (i = 0; i < 16; i++)
+			apu_set_register(chip, apu, i, 0x0000);
+
+		/* Load the buffer into the wave engine */
+		apu_set_register(chip, apu, 4, ((pa >> 16) & 0xFF) << 8);
+		apu_set_register(chip, apu, 5, pa & 0xFFFF);
+		apu_set_register(chip, apu, 6, (pa + size) & 0xFFFF);
+		/* setting loop == sample len */
+		apu_set_register(chip, apu, 7, size);
+
+		/* clear effects/env.. */
+		apu_set_register(chip, apu, 8, 0x0000);
+		/* set amp now to 0xd0 (?), low byte is 'amplitude dest'? */
+		apu_set_register(chip, apu, 9, 0xD000);
+
+		/* clear routing stuff */
+		apu_set_register(chip, apu, 11, 0x0000);
+		/* dma on, no envelopes, filter to all 1s) */
+		apu_set_register(chip, apu, 0, 0x400F);
+
+		if (es->fmt & ESS_FMT_16BIT)
+			es->apu_mode[channel] = ESM_APU_16BITLINEAR;
+		else
+			es->apu_mode[channel] = ESM_APU_8BITLINEAR;
+
+		if (es->fmt & ESS_FMT_STEREO) {
+			/* set panning: left or right */
+			/* Check: different panning. On my Canyon 3D Chipset the
+			   Channels are swapped. I don't know, about the output
+			   to the SPDif Link. Perhaps you have to change this
+			   and not the APU Regs 4-5. */
+			apu_set_register(chip, apu, 10,
+					 0x8F00 | (channel ? 0 : 0x10));
+			es->apu_mode[channel] += 1;	/* stereo */
+		} else
+			apu_set_register(chip, apu, 10, 0x8F08);
+	}
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	/* clear WP interrupts */
+	outw(1, chip->io_port + 0x04);
+	/* enable WP ints */
+	outw(inw(chip->io_port + ESM_PORT_HOST_IRQ) | ESM_HIRQ_DSIE, chip->io_port + ESM_PORT_HOST_IRQ);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+
+	freq = runtime->rate;
+	/* set frequency */
+	if (freq > 48000)
+		freq = 48000;
+	if (freq < 4000)
+		freq = 4000;
+
+	/* hmmm.. */
+	if (!(es->fmt & ESS_FMT_16BIT) && !(es->fmt & ESS_FMT_STEREO))
+		freq >>= 1;
+
+	freq = snd_es1968_compute_rate(chip, freq);
+
+	/* Load the frequency, turn on 6dB */
+	snd_es1968_apu_set_freq(chip, es->apu[0], freq);
+	snd_es1968_apu_set_freq(chip, es->apu[1], freq);
+}
+
+
+static void init_capture_apu(es1968_t *chip, esschan_t *es, int channel,
+			     unsigned int pa, unsigned int bsize,
+			     int mode, int route)
+{
+	int i, apu = es->apu[channel];
+
+	es->apu_mode[channel] = mode;
+
+	/* set the wavecache control reg */
+	snd_es1968_program_wavecache(chip, es, channel, pa, 1);
+
+	/* Offset to PCMBAR */
+	pa -= chip->dma.addr;
+	pa >>= 1;	/* words */
+
+	/* base offset of dma calcs when reading the pointer
+	   on this left one */
+	es->base[channel] = pa & 0xFFFF;
+	pa |= 0x00400000;	/* bit 22 -> System RAM */
+
+	/* Begin loading the APU */
+	for (i = 0; i < 16; i++)
+		apu_set_register(chip, apu, i, 0x0000);
+
+	/* need to enable subgroups.. and we should probably
+	   have different groups for different /dev/dsps..  */
+	apu_set_register(chip, apu, 2, 0x8);
+
+	/* Load the buffer into the wave engine */
+	apu_set_register(chip, apu, 4, ((pa >> 16) & 0xFF) << 8);
+	apu_set_register(chip, apu, 5, pa & 0xFFFF);
+	apu_set_register(chip, apu, 6, (pa + bsize) & 0xFFFF);
+	apu_set_register(chip, apu, 7, bsize);
+	/* clear effects/env.. */
+	apu_set_register(chip, apu, 8, 0x00F0);
+	/* amplitude now?  sure.  why not.  */
+	apu_set_register(chip, apu, 9, 0x0000);
+	/* set filter tune, radius, polar pan */
+	apu_set_register(chip, apu, 10, 0x8F08);
+	/* route input */
+	apu_set_register(chip, apu, 11, route);
+	/* dma on, no envelopes, filter to all 1s) */
+	apu_set_register(chip, apu, 0, 0x400F);
+}
+
+static void snd_es1968_capture_setup(es1968_t *chip, esschan_t *es,
+				     snd_pcm_runtime_t *runtime)
+{
+	int size;
+	u32 freq;
+	unsigned long flags;
+
+	size = es->dma_size >> es->wav_shift;
+
+	/* APU assignments:
+	   0 = mono/left SRC
+	   1 = right SRC
+	   2 = mono/left Input Mixer
+	   3 = right Input Mixer
+	*/
+	/* data seems to flow from the codec, through an apu into
+	   the 'mixbuf' bit of page, then through the SRC apu
+	   and out to the real 'buffer'.  ok.  sure.  */
+
+	/* input mixer (left/mono) */
+	/* parallel in crap, see maestro reg 0xC [8-11] */
+	init_capture_apu(chip, es, 2,
+			 es->mixbuf->buf.addr, ESM_MIXBUF_SIZE/4, /* in words */
+			 ESM_APU_INPUTMIXER, 0x14);
+	/* SRC (left/mono); get input from inputing apu */
+	init_capture_apu(chip, es, 0, es->memory->buf.addr, size,
+			 ESM_APU_SRCONVERTOR, es->apu[2]);
+	if (es->fmt & ESS_FMT_STEREO) {
+		/* input mixer (right) */
+		init_capture_apu(chip, es, 3,
+				 es->mixbuf->buf.addr + ESM_MIXBUF_SIZE/2,
+				 ESM_MIXBUF_SIZE/4, /* in words */
+				 ESM_APU_INPUTMIXER, 0x15);
+		/* SRC (right) */
+		init_capture_apu(chip, es, 1,
+				 es->memory->buf.addr + size*2, size,
+				 ESM_APU_SRCONVERTOR, es->apu[3]);
+	}
+
+	freq = runtime->rate;
+	/* Sample Rate conversion APUs don't like 0x10000 for their rate */
+	if (freq > 47999)
+		freq = 47999;
+	if (freq < 4000)
+		freq = 4000;
+
+	freq = snd_es1968_compute_rate(chip, freq);
+
+	/* Load the frequency, turn on 6dB */
+	snd_es1968_apu_set_freq(chip, es->apu[0], freq);
+	snd_es1968_apu_set_freq(chip, es->apu[1], freq);
+
+	/* fix mixer rate at 48khz.  and its _must_ be 0x10000. */
+	freq = 0x10000;
+	snd_es1968_apu_set_freq(chip, es->apu[2], freq);
+	snd_es1968_apu_set_freq(chip, es->apu[3], freq);
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	/* clear WP interrupts */
+	outw(1, chip->io_port + 0x04);
+	/* enable WP ints */
+	outw(inw(chip->io_port + ESM_PORT_HOST_IRQ) | ESM_HIRQ_DSIE, chip->io_port + ESM_PORT_HOST_IRQ);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+}
+
+/*******************
+ *  ALSA Interface *
+ *******************/
+
+static int snd_es1968_pcm_prepare(snd_pcm_substream_t *substream)
+{
+	es1968_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	esschan_t *es = runtime->private_data;
+
+	es->dma_size = snd_pcm_lib_buffer_bytes(substream);
+	es->frag_size = snd_pcm_lib_period_bytes(substream);
+
+	es->wav_shift = 1; /* maestro handles always 16bit */
+	es->fmt = 0;
+	if (snd_pcm_format_width(runtime->format) == 16)
+		es->fmt |= ESS_FMT_16BIT;
+	if (runtime->channels > 1) {
+		es->fmt |= ESS_FMT_STEREO;
+		if (es->fmt & ESS_FMT_16BIT) /* 8bit is already word shifted */
+			es->wav_shift++;
+	}
+	es->bob_freq = snd_es1968_calc_bob_rate(chip, es, runtime);
+
+	switch (es->mode) {
+	case ESM_MODE_PLAY:
+		snd_es1968_playback_setup(chip, es, runtime);
+		break;
+	case ESM_MODE_CAPTURE:
+		snd_es1968_capture_setup(chip, es, runtime);
+		break;
+	}
+
+	return 0;
+}
+
+static int snd_es1968_pcm_trigger(snd_pcm_substream_t *substream, int cmd)
+{
+	es1968_t *chip = snd_pcm_substream_chip(substream);
+	esschan_t *es = substream->runtime->private_data;
+
+	spin_lock(&chip->substream_lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		if (es->running)
+			break;
+		snd_es1968_bob_inc(chip, es->bob_freq);
+		es->count = 0;
+		es->hwptr = 0;
+		snd_es1968_pcm_start(chip, es);
+		es->running = 1;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		if (! es->running)
+			break;
+		snd_es1968_pcm_stop(chip, es);
+		es->running = 0;
+		snd_es1968_bob_dec(chip);
+		break;
+	}
+	spin_unlock(&chip->substream_lock);
+	return 0;
+}
+
+static snd_pcm_uframes_t snd_es1968_pcm_pointer(snd_pcm_substream_t *substream)
+{
+	es1968_t *chip = snd_pcm_substream_chip(substream);
+	esschan_t *es = substream->runtime->private_data;
+	unsigned int ptr;
+
+	ptr = snd_es1968_get_dma_ptr(chip, es) << es->wav_shift;
+	
+	return bytes_to_frames(substream->runtime, ptr % es->dma_size);
+}
+
+static snd_pcm_hardware_t snd_es1968_playback = {
+	.info =			(SNDRV_PCM_INFO_MMAP |
+               		         SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 /*SNDRV_PCM_INFO_PAUSE |*/
+				 SNDRV_PCM_INFO_RESUME),
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	65536,
+	.period_bytes_min =	256,
+	.period_bytes_max =	65536,
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+static snd_pcm_hardware_t snd_es1968_capture = {
+	.info =			(SNDRV_PCM_INFO_NONINTERLEAVED |
+				 SNDRV_PCM_INFO_MMAP |
+				 SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 /*SNDRV_PCM_INFO_PAUSE |*/
+				 SNDRV_PCM_INFO_RESUME),
+	.formats =		/*SNDRV_PCM_FMTBIT_U8 |*/ SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	65536,
+	.period_bytes_min =	256,
+	.period_bytes_max =	65536,
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+/* *************************
+   * DMA memory management *
+   *************************/
+
+/* Because the Maestro can only take addresses relative to the PCM base address
+   register :( */
+
+static int calc_available_memory_size(es1968_t *chip)
+{
+	struct list_head *p;
+	int max_size = 0;
+	
+	down(&chip->memory_mutex);
+	list_for_each(p, &chip->buf_list) {
+		esm_memory_t *buf = list_entry(p, esm_memory_t, list);
+		if (buf->empty && buf->buf.bytes > max_size)
+			max_size = buf->buf.bytes;
+	}
+	up(&chip->memory_mutex);
+	if (max_size >= 128*1024)
+		max_size = 127*1024;
+	return max_size;
+}
+
+/* allocate a new memory chunk with the specified size */
+static esm_memory_t *snd_es1968_new_memory(es1968_t *chip, int size)
+{
+	esm_memory_t *buf;
+	struct list_head *p;
+	
+	size = ((size + ESM_MEM_ALIGN - 1) / ESM_MEM_ALIGN) * ESM_MEM_ALIGN;
+	down(&chip->memory_mutex);
+	list_for_each(p, &chip->buf_list) {
+		buf = list_entry(p, esm_memory_t, list);
+		if (buf->empty && buf->buf.bytes >= size)
+			goto __found;
+	}
+	up(&chip->memory_mutex);
+	return NULL;
+
+__found:
+	if (buf->buf.bytes > size) {
+		esm_memory_t *chunk = kmalloc(sizeof(*chunk), GFP_KERNEL);
+		if (chunk == NULL) {
+			up(&chip->memory_mutex);
+			return NULL;
+		}
+		chunk->buf = buf->buf;
+		chunk->buf.bytes -= size;
+		chunk->buf.area += size;
+		chunk->buf.addr += size;
+		chunk->empty = 1;
+		buf->buf.bytes = size;
+		list_add(&chunk->list, &buf->list);
+	}
+	buf->empty = 0;
+	up(&chip->memory_mutex);
+	return buf;
+}
+
+/* free a memory chunk */
+static void snd_es1968_free_memory(es1968_t *chip, esm_memory_t *buf)
+{
+	esm_memory_t *chunk;
+
+	down(&chip->memory_mutex);
+	buf->empty = 1;
+	if (buf->list.prev != &chip->buf_list) {
+		chunk = list_entry(buf->list.prev, esm_memory_t, list);
+		if (chunk->empty) {
+			chunk->buf.bytes += buf->buf.bytes;
+			list_del(&buf->list);
+			kfree(buf);
+			buf = chunk;
+		}
+	}
+	if (buf->list.next != &chip->buf_list) {
+		chunk = list_entry(buf->list.next, esm_memory_t, list);
+		if (chunk->empty) {
+			buf->buf.bytes += chunk->buf.bytes;
+			list_del(&chunk->list);
+			kfree(chunk);
+		}
+	}
+	up(&chip->memory_mutex);
+}
+
+static void snd_es1968_free_dmabuf(es1968_t *chip)
+{
+	struct list_head *p;
+
+	if (! chip->dma.area)
+		return;
+	snd_dma_reserve_buf(&chip->dma, snd_dma_pci_buf_id(chip->pci));
+	while ((p = chip->buf_list.next) != &chip->buf_list) {
+		esm_memory_t *chunk = list_entry(p, esm_memory_t, list);
+		list_del(p);
+		kfree(chunk);
+	}
+}
+
+static int __devinit
+snd_es1968_init_dmabuf(es1968_t *chip)
+{
+	int err;
+	esm_memory_t *chunk;
+
+	chip->dma.dev.type = SNDRV_DMA_TYPE_DEV;
+	chip->dma.dev.dev = snd_dma_pci_data(chip->pci);
+	if (! snd_dma_get_reserved_buf(&chip->dma, snd_dma_pci_buf_id(chip->pci))) {
+		err = snd_dma_alloc_pages_fallback(SNDRV_DMA_TYPE_DEV,
+						   snd_dma_pci_data(chip->pci),
+						   chip->total_bufsize, &chip->dma);
+		if (err < 0 || ! chip->dma.area) {
+			snd_printk("es1968: can't allocate dma pages for size %d\n",
+				   chip->total_bufsize);
+			return -ENOMEM;
+		}
+		if ((chip->dma.addr + chip->dma.bytes - 1) & ~((1 << 28) - 1)) {
+			snd_dma_free_pages(&chip->dma);
+			snd_printk("es1968: DMA buffer beyond 256MB.\n");
+			return -ENOMEM;
+		}
+	}
+
+	INIT_LIST_HEAD(&chip->buf_list);
+	/* allocate an empty chunk */
+	chunk = kmalloc(sizeof(*chunk), GFP_KERNEL);
+	if (chunk == NULL) {
+		snd_es1968_free_dmabuf(chip);
+		return -ENOMEM;
+	}
+	memset(chip->dma.area, 0, ESM_MEM_ALIGN);
+	chunk->buf = chip->dma;
+	chunk->buf.area += ESM_MEM_ALIGN;
+	chunk->buf.addr += ESM_MEM_ALIGN;
+	chunk->buf.bytes -= ESM_MEM_ALIGN;
+	chunk->empty = 1;
+	list_add(&chunk->list, &chip->buf_list);
+
+	return 0;
+}
+
+/* setup the dma_areas */
+/* buffer is extracted from the pre-allocated memory chunk */
+static int snd_es1968_hw_params(snd_pcm_substream_t *substream,
+				snd_pcm_hw_params_t *hw_params)
+{
+	es1968_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	esschan_t *chan = runtime->private_data;
+	int size = params_buffer_bytes(hw_params);
+
+	if (chan->memory) {
+		if (chan->memory->buf.bytes >= size) {
+			runtime->dma_bytes = size;
+			return 0;
+		}
+		snd_es1968_free_memory(chip, chan->memory);
+	}
+	chan->memory = snd_es1968_new_memory(chip, size);
+	if (chan->memory == NULL) {
+		// snd_printd("cannot allocate dma buffer: size = %d\n", size);
+		return -ENOMEM;
+	}
+	snd_pcm_set_runtime_buffer(substream, &chan->memory->buf);
+	return 1; /* area was changed */
+}
+
+/* remove dma areas if allocated */
+static int snd_es1968_hw_free(snd_pcm_substream_t * substream)
+{
+	es1968_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	esschan_t *chan;
+	
+	if (runtime->private_data == NULL)
+		return 0;
+	chan = runtime->private_data;
+	if (chan->memory) {
+		snd_es1968_free_memory(chip, chan->memory);
+		chan->memory = NULL;
+	}
+	return 0;
+}
+
+
+/*
+ * allocate APU pair
+ */
+static int snd_es1968_alloc_apu_pair(es1968_t *chip, int type)
+{
+	int apu;
+
+	for (apu = 0; apu < NR_APUS; apu += 2) {
+		if (chip->apu[apu] == ESM_APU_FREE &&
+		    chip->apu[apu + 1] == ESM_APU_FREE) {
+			chip->apu[apu] = chip->apu[apu + 1] = type;
+			return apu;
+		}
+	}
+	return -EBUSY;
+}
+
+/*
+ * release APU pair
+ */
+static void snd_es1968_free_apu_pair(es1968_t *chip, int apu)
+{
+	chip->apu[apu] = chip->apu[apu + 1] = ESM_APU_FREE;
+}
+
+
+/******************
+ * PCM open/close *
+ ******************/
+
+static int snd_es1968_playback_open(snd_pcm_substream_t *substream)
+{
+	es1968_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	esschan_t *es;
+	int apu1;
+
+	/* search 2 APUs */
+	apu1 = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_PLAY);
+	if (apu1 < 0)
+		return apu1;
+
+	es = kcalloc(1, sizeof(*es), GFP_KERNEL);
+	if (!es) {
+		snd_es1968_free_apu_pair(chip, apu1);
+		return -ENOMEM;
+	}
+
+	es->apu[0] = apu1;
+	es->apu[1] = apu1 + 1;
+	es->apu_mode[0] = 0;
+	es->apu_mode[1] = 0;
+	es->running = 0;
+	es->substream = substream;
+	es->mode = ESM_MODE_PLAY;
+
+	runtime->private_data = es;
+	runtime->hw = snd_es1968_playback;
+	runtime->hw.buffer_bytes_max = runtime->hw.period_bytes_max =
+		calc_available_memory_size(chip);
+#if 0
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
+				   1024);
+#endif
+	spin_lock_irq(&chip->substream_lock);
+	list_add(&es->list, &chip->substream_list);
+	spin_unlock_irq(&chip->substream_lock);
+
+	return 0;
+}
+
+static int snd_es1968_capture_open(snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	es1968_t *chip = snd_pcm_substream_chip(substream);
+	esschan_t *es;
+	int apu1, apu2;
+
+	apu1 = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_CAPTURE);
+	if (apu1 < 0)
+		return apu1;
+	apu2 = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_RATECONV);
+	if (apu2 < 0) {
+		snd_es1968_free_apu_pair(chip, apu1);
+		return apu2;
+	}
+	
+	es = kcalloc(1, sizeof(*es), GFP_KERNEL);
+	if (!es) {
+		snd_es1968_free_apu_pair(chip, apu1);
+		snd_es1968_free_apu_pair(chip, apu2);
+		return -ENOMEM;
+	}
+
+	es->apu[0] = apu1;
+	es->apu[1] = apu1 + 1;
+	es->apu[2] = apu2;
+	es->apu[3] = apu2 + 1;
+	es->apu_mode[0] = 0;
+	es->apu_mode[1] = 0;
+	es->apu_mode[2] = 0;
+	es->apu_mode[3] = 0;
+	es->running = 0;
+	es->substream = substream;
+	es->mode = ESM_MODE_CAPTURE;
+
+	/* get mixbuffer */
+	if ((es->mixbuf = snd_es1968_new_memory(chip, ESM_MIXBUF_SIZE)) == NULL) {
+		snd_es1968_free_apu_pair(chip, apu1);
+		snd_es1968_free_apu_pair(chip, apu2);
+		kfree(es);
+                return -ENOMEM;
+        }
+	memset(es->mixbuf->buf.area, 0, ESM_MIXBUF_SIZE);
+
+	runtime->private_data = es;
+	runtime->hw = snd_es1968_capture;
+	runtime->hw.buffer_bytes_max = runtime->hw.period_bytes_max =
+		calc_available_memory_size(chip) - 1024; /* keep MIXBUF size */
+#if 0
+	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
+				   1024);
+#endif
+	spin_lock_irq(&chip->substream_lock);
+	list_add(&es->list, &chip->substream_list);
+	spin_unlock_irq(&chip->substream_lock);
+
+	return 0;
+}
+
+static int snd_es1968_playback_close(snd_pcm_substream_t * substream)
+{
+	es1968_t *chip = snd_pcm_substream_chip(substream);
+	esschan_t *es;
+
+	if (substream->runtime->private_data == NULL)
+		return 0;
+	es = substream->runtime->private_data;
+	spin_lock_irq(&chip->substream_lock);
+	list_del(&es->list);
+	spin_unlock_irq(&chip->substream_lock);
+	snd_es1968_free_apu_pair(chip, es->apu[0]);
+	kfree(es);
+
+	return 0;
+}
+
+static int snd_es1968_capture_close(snd_pcm_substream_t * substream)
+{
+	es1968_t *chip = snd_pcm_substream_chip(substream);
+	esschan_t *es;
+
+	if (substream->runtime->private_data == NULL)
+		return 0;
+	es = substream->runtime->private_data;
+	spin_lock_irq(&chip->substream_lock);
+	list_del(&es->list);
+	spin_unlock_irq(&chip->substream_lock);
+	snd_es1968_free_memory(chip, es->mixbuf);
+	snd_es1968_free_apu_pair(chip, es->apu[0]);
+	snd_es1968_free_apu_pair(chip, es->apu[2]);
+	kfree(es);
+
+	return 0;
+}
+
+static snd_pcm_ops_t snd_es1968_playback_ops = {
+	.open =		snd_es1968_playback_open,
+	.close =	snd_es1968_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_es1968_hw_params,
+	.hw_free =	snd_es1968_hw_free,
+	.prepare =	snd_es1968_pcm_prepare,
+	.trigger =	snd_es1968_pcm_trigger,
+	.pointer =	snd_es1968_pcm_pointer,
+};
+
+static snd_pcm_ops_t snd_es1968_capture_ops = {
+	.open =		snd_es1968_capture_open,
+	.close =	snd_es1968_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_es1968_hw_params,
+	.hw_free =	snd_es1968_hw_free,
+	.prepare =	snd_es1968_pcm_prepare,
+	.trigger =	snd_es1968_pcm_trigger,
+	.pointer =	snd_es1968_pcm_pointer,
+};
+
+
+/*
+ * measure clock
+ */
+#define CLOCK_MEASURE_BUFSIZE	16768	/* enough large for a single shot */
+
+static void __devinit es1968_measure_clock(es1968_t *chip)
+{
+	int i, apu;
+	unsigned int pa, offset, t;
+	esm_memory_t *memory;
+	struct timeval start_time, stop_time;
+
+	if (chip->clock == 0)
+		chip->clock = 48000; /* default clock value */
+
+	/* search 2 APUs (although one apu is enough) */
+	if ((apu = snd_es1968_alloc_apu_pair(chip, ESM_APU_PCM_PLAY)) < 0) {
+		snd_printk("Hmm, cannot find empty APU pair!?\n");
+		return;
+	}
+	if ((memory = snd_es1968_new_memory(chip, CLOCK_MEASURE_BUFSIZE)) == NULL) {
+		snd_printk("cannot allocate dma buffer - using default clock %d\n", chip->clock);
+		snd_es1968_free_apu_pair(chip, apu);
+		return;
+	}
+
+	memset(memory->buf.area, 0, CLOCK_MEASURE_BUFSIZE);
+
+	wave_set_register(chip, apu << 3, (memory->buf.addr - 0x10) & 0xfff8);
+
+	pa = (unsigned int)((memory->buf.addr - chip->dma.addr) >> 1);
+	pa |= 0x00400000;	/* System RAM (Bit 22) */
+
+	/* initialize apu */
+	for (i = 0; i < 16; i++)
+		apu_set_register(chip, apu, i, 0x0000);
+
+	apu_set_register(chip, apu, 0, 0x400f);
+	apu_set_register(chip, apu, 4, ((pa >> 16) & 0xff) << 8);
+	apu_set_register(chip, apu, 5, pa & 0xffff);
+	apu_set_register(chip, apu, 6, (pa + CLOCK_MEASURE_BUFSIZE/2) & 0xffff);
+	apu_set_register(chip, apu, 7, CLOCK_MEASURE_BUFSIZE/2);
+	apu_set_register(chip, apu, 8, 0x0000);
+	apu_set_register(chip, apu, 9, 0xD000);
+	apu_set_register(chip, apu, 10, 0x8F08);
+	apu_set_register(chip, apu, 11, 0x0000);
+	spin_lock_irq(&chip->reg_lock);
+	outw(1, chip->io_port + 0x04); /* clear WP interrupts */
+	outw(inw(chip->io_port + ESM_PORT_HOST_IRQ) | ESM_HIRQ_DSIE, chip->io_port + ESM_PORT_HOST_IRQ); /* enable WP ints */
+	spin_unlock_irq(&chip->reg_lock);
+
+	snd_es1968_apu_set_freq(chip, apu, ((unsigned int)48000 << 16) / chip->clock); /* 48000 Hz */
+
+	chip->in_measurement = 1;
+	chip->measure_apu = apu;
+	spin_lock_irq(&chip->reg_lock);
+	snd_es1968_bob_inc(chip, ESM_BOB_FREQ);
+	__apu_set_register(chip, apu, 5, pa & 0xffff);
+	snd_es1968_trigger_apu(chip, apu, ESM_APU_16BITLINEAR);
+	do_gettimeofday(&start_time);
+	spin_unlock_irq(&chip->reg_lock);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(HZ / 20); /* 50 msec */
+	spin_lock_irq(&chip->reg_lock);
+	offset = __apu_get_register(chip, apu, 5);
+	do_gettimeofday(&stop_time);
+	snd_es1968_trigger_apu(chip, apu, 0); /* stop */
+	snd_es1968_bob_dec(chip);
+	chip->in_measurement = 0;
+	spin_unlock_irq(&chip->reg_lock);
+
+	/* check the current position */
+	offset -= (pa & 0xffff);
+	offset &= 0xfffe;
+	offset += chip->measure_count * (CLOCK_MEASURE_BUFSIZE/2);
+
+	t = stop_time.tv_sec - start_time.tv_sec;
+	t *= 1000000;
+	if (stop_time.tv_usec < start_time.tv_usec)
+		t -= start_time.tv_usec - stop_time.tv_usec;
+	else
+		t += stop_time.tv_usec - start_time.tv_usec;
+	if (t == 0) {
+		snd_printk("?? calculation error..\n");
+	} else {
+		offset *= 1000;
+		offset = (offset / t) * 1000 + ((offset % t) * 1000) / t;
+		if (offset < 47500 || offset > 48500) {
+			if (offset >= 40000 && offset <= 50000)
+				chip->clock = (chip->clock * offset) / 48000;
+		}
+		printk(KERN_INFO "es1968: clocking to %d\n", chip->clock);
+	}
+	snd_es1968_free_memory(chip, memory);
+	snd_es1968_free_apu_pair(chip, apu);
+}
+
+
+/*
+ */
+
+static void snd_es1968_pcm_free(snd_pcm_t *pcm)
+{
+	es1968_t *esm = pcm->private_data;
+	snd_es1968_free_dmabuf(esm);
+	esm->pcm = NULL;
+}
+
+static int __devinit
+snd_es1968_pcm(es1968_t *chip, int device)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	/* get DMA buffer */
+	if ((err = snd_es1968_init_dmabuf(chip)) < 0)
+		return err;
+
+	/* set PCMBAR */
+	wave_set_register(chip, 0x01FC, chip->dma.addr >> 12);
+	wave_set_register(chip, 0x01FD, chip->dma.addr >> 12);
+	wave_set_register(chip, 0x01FE, chip->dma.addr >> 12);
+	wave_set_register(chip, 0x01FF, chip->dma.addr >> 12);
+
+	if ((err = snd_pcm_new(chip->card, "ESS Maestro", device,
+			       chip->playback_streams,
+			       chip->capture_streams, &pcm)) < 0)
+		return err;
+
+	pcm->private_data = chip;
+	pcm->private_free = snd_es1968_pcm_free;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_es1968_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_es1968_capture_ops);
+
+	pcm->info_flags = 0;
+
+	strcpy(pcm->name, "ESS Maestro");
+
+	chip->pcm = pcm;
+
+	return 0;
+}
+
+/*
+ * update pointer
+ */
+static void snd_es1968_update_pcm(es1968_t *chip, esschan_t *es)
+{
+	unsigned int hwptr;
+	unsigned int diff;
+	snd_pcm_substream_t *subs = es->substream;
+        
+	if (subs == NULL || !es->running)
+		return;
+
+	hwptr = snd_es1968_get_dma_ptr(chip, es) << es->wav_shift;
+	hwptr %= es->dma_size;
+
+	diff = (es->dma_size + hwptr - es->hwptr) % es->dma_size;
+
+	es->hwptr = hwptr;
+	es->count += diff;
+
+	if (es->count > es->frag_size) {
+		spin_unlock(&chip->substream_lock);
+		snd_pcm_period_elapsed(subs);
+		spin_lock(&chip->substream_lock);
+		es->count %= es->frag_size;
+	}
+}
+
+/*
+ */
+static void es1968_update_hw_volume(unsigned long private_data)
+{
+	es1968_t *chip = (es1968_t *) private_data;
+	int x, val;
+	unsigned long flags;
+
+	/* Figure out which volume control button was pushed,
+	   based on differences from the default register
+	   values. */
+	x = inb(chip->io_port + 0x1c);
+	/* Reset the volume control registers. */
+	outb(0x88, chip->io_port + 0x1c);
+	outb(0x88, chip->io_port + 0x1d);
+	outb(0x88, chip->io_port + 0x1e);
+	outb(0x88, chip->io_port + 0x1f);
+
+	if (chip->in_suspend)
+		return;
+
+	if (! chip->master_switch || ! chip->master_volume)
+		return;
+
+	/* FIXME: we can't call snd_ac97_* functions since here is in tasklet. */
+	spin_lock_irqsave(&chip->ac97_lock, flags);
+	val = chip->ac97->regs[AC97_MASTER];
+	if (x & 1) {
+		/* mute */
+		val ^= 0x8000;
+		chip->ac97->regs[AC97_MASTER] = val;
+		outw(val, chip->io_port + ESM_AC97_DATA);
+		outb(AC97_MASTER, chip->io_port + ESM_AC97_INDEX);
+		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+			       &chip->master_switch->id);
+	} else {
+		val &= 0x7fff;
+		if (((x>>1) & 7) > 4) {
+			/* volume up */
+			if ((val & 0xff) > 0)
+				val--;
+			if ((val & 0xff00) > 0)
+				val -= 0x0100;
+		} else {
+			/* volume down */
+			if ((val & 0xff) < 0x1f)
+				val++;
+			if ((val & 0xff00) < 0x1f00)
+				val += 0x0100;
+		}
+		chip->ac97->regs[AC97_MASTER] = val;
+		outw(val, chip->io_port + ESM_AC97_DATA);
+		outb(AC97_MASTER, chip->io_port + ESM_AC97_INDEX);
+		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+			       &chip->master_volume->id);
+	}
+	spin_unlock_irqrestore(&chip->ac97_lock, flags);
+}
+
+/*
+ * interrupt handler
+ */
+static irqreturn_t snd_es1968_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	es1968_t *chip = dev_id;
+	u32 event;
+
+	if (!(event = inb(chip->io_port + 0x1A)))
+		return IRQ_NONE;
+
+	outw(inw(chip->io_port + 4) & 1, chip->io_port + 4);
+
+	if (event & ESM_HWVOL_IRQ)
+		tasklet_hi_schedule(&chip->hwvol_tq); /* we'll do this later */
+
+	/* else ack 'em all, i imagine */
+	outb(0xFF, chip->io_port + 0x1A);
+
+	if ((event & ESM_MPU401_IRQ) && chip->rmidi) {
+		snd_mpu401_uart_interrupt(irq, chip->rmidi->private_data, regs);
+	}
+
+	if (event & ESM_SOUND_IRQ) {
+		struct list_head *p;
+		spin_lock(&chip->substream_lock);
+		list_for_each(p, &chip->substream_list) {
+			esschan_t *es = list_entry(p, esschan_t, list);
+			if (es->running)
+				snd_es1968_update_pcm(chip, es);
+		}
+		spin_unlock(&chip->substream_lock);
+		if (chip->in_measurement) {
+			unsigned int curp = __apu_get_register(chip, chip->measure_apu, 5);
+			if (curp < chip->measure_lastpos)
+				chip->measure_count++;
+			chip->measure_lastpos = curp;
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ *  Mixer stuff
+ */
+
+static int __devinit
+snd_es1968_mixer(es1968_t *chip)
+{
+	ac97_bus_t *pbus;
+	ac97_template_t ac97;
+	snd_ctl_elem_id_t id;
+	int err;
+	static ac97_bus_ops_t ops = {
+		.write = snd_es1968_ac97_write,
+		.read = snd_es1968_ac97_read,
+	};
+
+	if ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)
+		return err;
+	pbus->no_vra = 1; /* ES1968 doesn't need VRA */
+
+	memset(&ac97, 0, sizeof(ac97));
+	ac97.private_data = chip;
+	if ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97)) < 0)
+		return err;
+
+	/* attach master switch / volumes for h/w volume control */
+	memset(&id, 0, sizeof(id));
+	id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	strcpy(id.name, "Master Playback Switch");
+	chip->master_switch = snd_ctl_find_id(chip->card, &id);
+	memset(&id, 0, sizeof(id));
+	id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	strcpy(id.name, "Master Playback Volume");
+	chip->master_volume = snd_ctl_find_id(chip->card, &id);
+
+	return 0;
+}
+
+/*
+ * reset ac97 codec
+ */
+
+static void snd_es1968_ac97_reset(es1968_t *chip)
+{
+	unsigned long ioaddr = chip->io_port;
+
+	unsigned short save_ringbus_a;
+	unsigned short save_68;
+	unsigned short w;
+	unsigned int vend;
+
+	/* save configuration */
+	save_ringbus_a = inw(ioaddr + 0x36);
+
+	//outw(inw(ioaddr + 0x38) & 0xfffc, ioaddr + 0x38); /* clear second codec id? */
+	/* set command/status address i/o to 1st codec */
+	outw(inw(ioaddr + 0x3a) & 0xfffc, ioaddr + 0x3a);
+	outw(inw(ioaddr + 0x3c) & 0xfffc, ioaddr + 0x3c);
+
+	/* disable ac link */
+	outw(0x0000, ioaddr + 0x36);
+	save_68 = inw(ioaddr + 0x68);
+	pci_read_config_word(chip->pci, 0x58, &w);	/* something magical with gpio and bus arb. */
+	pci_read_config_dword(chip->pci, PCI_SUBSYSTEM_VENDOR_ID, &vend);
+	if (w & 1)
+		save_68 |= 0x10;
+	outw(0xfffe, ioaddr + 0x64);	/* unmask gpio 0 */
+	outw(0x0001, ioaddr + 0x68);	/* gpio write */
+	outw(0x0000, ioaddr + 0x60);	/* write 0 to gpio 0 */
+	udelay(20);
+	outw(0x0001, ioaddr + 0x60);	/* write 1 to gpio 1 */
+	big_mdelay(20);
+
+	outw(save_68 | 0x1, ioaddr + 0x68);	/* now restore .. */
+	outw((inw(ioaddr + 0x38) & 0xfffc) | 0x1, ioaddr + 0x38);
+	outw((inw(ioaddr + 0x3a) & 0xfffc) | 0x1, ioaddr + 0x3a);
+	outw((inw(ioaddr + 0x3c) & 0xfffc) | 0x1, ioaddr + 0x3c);
+
+	/* now the second codec */
+	/* disable ac link */
+	outw(0x0000, ioaddr + 0x36);
+	outw(0xfff7, ioaddr + 0x64);	/* unmask gpio 3 */
+	save_68 = inw(ioaddr + 0x68);
+	outw(0x0009, ioaddr + 0x68);	/* gpio write 0 & 3 ?? */
+	outw(0x0001, ioaddr + 0x60);	/* write 1 to gpio */
+	udelay(20);
+	outw(0x0009, ioaddr + 0x60);	/* write 9 to gpio */
+	big_mdelay(500);
+	//outw(inw(ioaddr + 0x38) & 0xfffc, ioaddr + 0x38);
+	outw(inw(ioaddr + 0x3a) & 0xfffc, ioaddr + 0x3a);
+	outw(inw(ioaddr + 0x3c) & 0xfffc, ioaddr + 0x3c);
+
+#if 0				/* the loop here needs to be much better if we want it.. */
+	snd_printk("trying software reset\n");
+	/* try and do a software reset */
+	outb(0x80 | 0x7c, ioaddr + 0x30);
+	for (w = 0;; w++) {
+		if ((inw(ioaddr + 0x30) & 1) == 0) {
+			if (inb(ioaddr + 0x32) != 0)
+				break;
+
+			outb(0x80 | 0x7d, ioaddr + 0x30);
+			if (((inw(ioaddr + 0x30) & 1) == 0)
+			    && (inb(ioaddr + 0x32) != 0))
+				break;
+			outb(0x80 | 0x7f, ioaddr + 0x30);
+			if (((inw(ioaddr + 0x30) & 1) == 0)
+			    && (inb(ioaddr + 0x32) != 0))
+				break;
+		}
+
+		if (w > 10000) {
+			outb(inb(ioaddr + 0x37) | 0x08, ioaddr + 0x37);	/* do a software reset */
+			big_mdelay(500);	/* oh my.. */
+			outb(inb(ioaddr + 0x37) & ~0x08,
+				ioaddr + 0x37);
+			udelay(1);
+			outw(0x80, ioaddr + 0x30);
+			for (w = 0; w < 10000; w++) {
+				if ((inw(ioaddr + 0x30) & 1) == 0)
+					break;
+			}
+		}
+	}
+#endif
+	if (vend == NEC_VERSA_SUBID1 || vend == NEC_VERSA_SUBID2) {
+		/* turn on external amp? */
+		outw(0xf9ff, ioaddr + 0x64);
+		outw(inw(ioaddr + 0x68) | 0x600, ioaddr + 0x68);
+		outw(0x0209, ioaddr + 0x60);
+	}
+
+	/* restore.. */
+	outw(save_ringbus_a, ioaddr + 0x36);
+
+	/* Turn on the 978 docking chip.
+	   First frob the "master output enable" bit,
+	   then set most of the playback volume control registers to max. */
+	outb(inb(ioaddr+0xc0)|(1<<5), ioaddr+0xc0);
+	outb(0xff, ioaddr+0xc3);
+	outb(0xff, ioaddr+0xc4);
+	outb(0xff, ioaddr+0xc6);
+	outb(0xff, ioaddr+0xc8);
+	outb(0x3f, ioaddr+0xcf);
+	outb(0x3f, ioaddr+0xd0);
+}
+
+static void snd_es1968_reset(es1968_t *chip)
+{
+	/* Reset */
+	outw(ESM_RESET_MAESTRO | ESM_RESET_DIRECTSOUND,
+	     chip->io_port + ESM_PORT_HOST_IRQ);
+	udelay(10);
+	outw(0x0000, chip->io_port + ESM_PORT_HOST_IRQ);
+	udelay(10);
+}
+
+/*
+ * power management
+ */
+static void snd_es1968_set_acpi(es1968_t *chip, int state)
+{
+	u16 active_mask = acpi_state_mask[state];
+
+	pci_set_power_state(chip->pci, state);
+	/* make sure the units we care about are on 
+		XXX we might want to do this before state flipping? */
+	pci_write_config_word(chip->pci, 0x54, ~ active_mask);
+	pci_write_config_word(chip->pci, 0x56, ~ active_mask);
+}
+
+
+/*
+ * initialize maestro chip
+ */
+static void snd_es1968_chip_init(es1968_t *chip)
+{
+	struct pci_dev *pci = chip->pci;
+	int i;
+	unsigned long iobase  = chip->io_port;
+	u16 w;
+	u32 n;
+
+	/* We used to muck around with pci config space that
+	 * we had no business messing with.  We don't know enough
+	 * about the machine to know which DMA mode is appropriate, 
+	 * etc.  We were guessing wrong on some machines and making
+	 * them unhappy.  We now trust in the BIOS to do things right,
+	 * which almost certainly means a new host of problems will
+	 * arise with broken BIOS implementations.  screw 'em. 
+	 * We're already intolerant of machines that don't assign
+	 * IRQs.
+	 */
+	
+	/* do config work at full power */
+	snd_es1968_set_acpi(chip, ACPI_D0);
+
+	/* Config Reg A */
+	pci_read_config_word(pci, ESM_CONFIG_A, &w);
+
+	/*      Use TDMA for now. TDMA works on all boards, so while its
+	 *      not the most efficient its the simplest. */
+	w &= ~DMA_CLEAR;	/* Clear DMA bits */
+	w |= DMA_TDMA;		/* TDMA on */
+	w &= ~(PIC_SNOOP1 | PIC_SNOOP2);	/* Clear Pic Snoop Mode Bits */
+	w &= ~SAFEGUARD;	/* Safeguard off */
+	w |= POST_WRITE;	/* Posted write */
+	w |= ISA_TIMING;	/* ISA timing on */
+	/* XXX huh?  claims to be reserved.. */
+	w &= ~SWAP_LR;		/* swap left/right 
+				   seems to only have effect on SB
+				   Emulation */
+	w &= ~SUBTR_DECODE;	/* Subtractive decode off */
+
+	pci_write_config_word(pci, ESM_CONFIG_A, w);
+
+	/* Config Reg B */
+
+	pci_read_config_word(pci, ESM_CONFIG_B, &w);
+
+	w &= ~(1 << 15);	/* Turn off internal clock multiplier */
+	/* XXX how do we know which to use? */
+	w &= ~(1 << 14);	/* External clock */
+
+	w &= ~SPDIF_CONFB;	/* disable S/PDIF output */
+	w |= HWV_CONFB;		/* HWV on */
+	w |= DEBOUNCE;		/* Debounce off: easier to push the HW buttons */
+	w &= ~GPIO_CONFB;	/* GPIO 4:5 */
+	w |= CHI_CONFB;		/* Disconnect from the CHI.  Enabling this made a dell 7500 work. */
+	w &= ~IDMA_CONFB;	/* IDMA off (undocumented) */
+	w &= ~MIDI_FIX;		/* MIDI fix off (undoc) */
+	w &= ~(1 << 1);		/* reserved, always write 0 */
+	w &= ~IRQ_TO_ISA;	/* IRQ to ISA off (undoc) */
+
+	pci_write_config_word(pci, ESM_CONFIG_B, w);
+
+	/* DDMA off */
+
+	pci_read_config_word(pci, ESM_DDMA, &w);
+	w &= ~(1 << 0);
+	pci_write_config_word(pci, ESM_DDMA, w);
+
+	/*
+	 *	Legacy mode
+	 */
+
+	pci_read_config_word(pci, ESM_LEGACY_AUDIO_CONTROL, &w);
+
+	w &= ~ESS_ENABLE_AUDIO;	/* Disable Legacy Audio */
+	w &= ~ESS_ENABLE_SERIAL_IRQ;	/* Disable SIRQ */
+	w &= ~(0x1f);		/* disable mpu irq/io, game port, fm, SB */
+
+	pci_write_config_word(pci, ESM_LEGACY_AUDIO_CONTROL, w);
+
+	/* Set up 978 docking control chip. */
+	pci_read_config_word(pci, 0x58, &w);
+	w|=1<<2;	/* Enable 978. */
+	w|=1<<3;	/* Turn on 978 hardware volume control. */
+	w&=~(1<<11);	/* Turn on 978 mixer volume control. */
+	pci_write_config_word(pci, 0x58, w);
+	
+	/* Sound Reset */
+
+	snd_es1968_reset(chip);
+
+	/*
+	 *	Ring Bus Setup
+	 */
+
+	/* setup usual 0x34 stuff.. 0x36 may be chip specific */
+	outw(0xC090, iobase + ESM_RING_BUS_DEST); /* direct sound, stereo */
+	udelay(20);
+	outw(0x3000, iobase + ESM_RING_BUS_CONTR_A); /* enable ringbus/serial */
+	udelay(20);
+
+	/*
+	 *	Reset the CODEC
+	 */
+	 
+	snd_es1968_ac97_reset(chip);
+
+	/* Ring Bus Control B */
+
+	n = inl(iobase + ESM_RING_BUS_CONTR_B);
+	n &= ~RINGB_EN_SPDIF;	/* SPDIF off */
+	//w |= RINGB_EN_2CODEC;	/* enable 2nd codec */
+	outl(n, iobase + ESM_RING_BUS_CONTR_B);
+
+	/* Set hardware volume control registers to midpoints.
+	   We can tell which button was pushed based on how they change. */
+	outb(0x88, iobase+0x1c);
+	outb(0x88, iobase+0x1d);
+	outb(0x88, iobase+0x1e);
+	outb(0x88, iobase+0x1f);
+
+	/* it appears some maestros (dell 7500) only work if these are set,
+	   regardless of wether we use the assp or not. */
+
+	outb(0, iobase + ASSP_CONTROL_B);
+	outb(3, iobase + ASSP_CONTROL_A);	/* M: Reserved bits... */
+	outb(0, iobase + ASSP_CONTROL_C);	/* M: Disable ASSP, ASSP IRQ's and FM Port */
+
+	/*
+	 * set up wavecache
+	 */
+	for (i = 0; i < 16; i++) {
+		/* Write 0 into the buffer area 0x1E0->1EF */
+		outw(0x01E0 + i, iobase + WC_INDEX);
+		outw(0x0000, iobase + WC_DATA);
+
+		/* The 1.10 test program seem to write 0 into the buffer area
+		 * 0x1D0-0x1DF too.*/
+		outw(0x01D0 + i, iobase + WC_INDEX);
+		outw(0x0000, iobase + WC_DATA);
+	}
+	wave_set_register(chip, IDR7_WAVE_ROMRAM,
+			  (wave_get_register(chip, IDR7_WAVE_ROMRAM) & 0xFF00));
+	wave_set_register(chip, IDR7_WAVE_ROMRAM,
+			  wave_get_register(chip, IDR7_WAVE_ROMRAM) | 0x100);
+	wave_set_register(chip, IDR7_WAVE_ROMRAM,
+			  wave_get_register(chip, IDR7_WAVE_ROMRAM) & ~0x200);
+	wave_set_register(chip, IDR7_WAVE_ROMRAM,
+			  wave_get_register(chip, IDR7_WAVE_ROMRAM) | ~0x400);
+
+
+	maestro_write(chip, IDR2_CRAM_DATA, 0x0000);
+	/* Now back to the DirectSound stuff */
+	/* audio serial configuration.. ? */
+	maestro_write(chip, 0x08, 0xB004);
+	maestro_write(chip, 0x09, 0x001B);
+	maestro_write(chip, 0x0A, 0x8000);
+	maestro_write(chip, 0x0B, 0x3F37);
+	maestro_write(chip, 0x0C, 0x0098);
+
+	/* parallel in, has something to do with recording :) */
+	maestro_write(chip, 0x0C,
+		      (maestro_read(chip, 0x0C) & ~0xF000) | 0x8000);
+	/* parallel out */
+	maestro_write(chip, 0x0C,
+		      (maestro_read(chip, 0x0C) & ~0x0F00) | 0x0500);
+
+	maestro_write(chip, 0x0D, 0x7632);
+
+	/* Wave cache control on - test off, sg off, 
+	   enable, enable extra chans 1Mb */
+
+	w = inw(iobase + WC_CONTROL);
+
+	w &= ~0xFA00;		/* Seems to be reserved? I don't know */
+	w |= 0xA000;		/* reserved... I don't know */
+	w &= ~0x0200;		/* Channels 56,57,58,59 as Extra Play,Rec Channel enable
+				   Seems to crash the Computer if enabled... */
+	w |= 0x0100;		/* Wave Cache Operation Enabled */
+	w |= 0x0080;		/* Channels 60/61 as Placback/Record enabled */
+	w &= ~0x0060;		/* Clear Wavtable Size */
+	w |= 0x0020;		/* Wavetable Size : 1MB */
+	/* Bit 4 is reserved */
+	w &= ~0x000C;		/* DMA Stuff? I don't understand what the datasheet means */
+	/* Bit 1 is reserved */
+	w &= ~0x0001;		/* Test Mode off */
+
+	outw(w, iobase + WC_CONTROL);
+
+	/* Now clear the APU control ram */
+	for (i = 0; i < NR_APUS; i++) {
+		for (w = 0; w < NR_APU_REGS; w++)
+			apu_set_register(chip, i, w, 0);
+
+	}
+}
+
+/* Enable IRQ's */
+static void snd_es1968_start_irq(es1968_t *chip)
+{
+	unsigned short w;
+	w = ESM_HIRQ_DSIE | ESM_HIRQ_HW_VOLUME;
+	if (chip->rmidi)
+		w |= ESM_HIRQ_MPU401;
+	outw(w, chip->io_port + ESM_PORT_HOST_IRQ);
+}
+
+#ifdef CONFIG_PM
+/*
+ * PM support
+ */
+static int es1968_suspend(snd_card_t *card, pm_message_t state)
+{
+	es1968_t *chip = card->pm_private_data;
+
+	if (! chip->do_pm)
+		return 0;
+
+	chip->in_suspend = 1;
+	snd_pcm_suspend_all(chip->pcm);
+	snd_ac97_suspend(chip->ac97);
+	snd_es1968_bob_stop(chip);
+	snd_es1968_set_acpi(chip, ACPI_D3);
+	pci_disable_device(chip->pci);
+	return 0;
+}
+
+static int es1968_resume(snd_card_t *card)
+{
+	es1968_t *chip = card->pm_private_data;
+	struct list_head *p;
+
+	if (! chip->do_pm)
+		return 0;
+
+	/* restore all our config */
+	pci_enable_device(chip->pci);
+	pci_set_master(chip->pci);
+	snd_es1968_chip_init(chip);
+
+	/* need to restore the base pointers.. */ 
+	if (chip->dma.addr) {
+		/* set PCMBAR */
+		wave_set_register(chip, 0x01FC, chip->dma.addr >> 12);
+	}
+
+	snd_es1968_start_irq(chip);
+
+	/* restore ac97 state */
+	snd_ac97_resume(chip->ac97);
+
+	list_for_each(p, &chip->substream_list) {
+		esschan_t *es = list_entry(p, esschan_t, list);
+		switch (es->mode) {
+		case ESM_MODE_PLAY:
+			snd_es1968_playback_setup(chip, es, es->substream->runtime);
+			break;
+		case ESM_MODE_CAPTURE:
+			snd_es1968_capture_setup(chip, es, es->substream->runtime);
+			break;
+		}
+	}
+
+	/* start timer again */
+	if (chip->bobclient)
+		snd_es1968_bob_start(chip);
+
+	chip->in_suspend = 0;
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+#ifdef SUPPORT_JOYSTICK
+#define JOYSTICK_ADDR	0x200
+static int __devinit snd_es1968_create_gameport(es1968_t *chip, int dev)
+{
+	struct gameport *gp;
+	struct resource *r;
+	u16 val;
+
+	if (!joystick[dev])
+		return -ENODEV;
+
+	r = request_region(JOYSTICK_ADDR, 8, "ES1968 gameport");
+	if (!r)
+		return -EBUSY;
+
+	chip->gameport = gp = gameport_allocate_port();
+	if (!gp) {
+		printk(KERN_ERR "es1968: cannot allocate memory for gameport\n");
+		release_resource(r);
+		kfree_nocheck(r);
+		return -ENOMEM;
+	}
+
+	pci_read_config_word(chip->pci, ESM_LEGACY_AUDIO_CONTROL, &val);
+	pci_write_config_word(chip->pci, ESM_LEGACY_AUDIO_CONTROL, val | 0x04);
+
+	gameport_set_name(gp, "ES1968 Gameport");
+	gameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));
+	gameport_set_dev_parent(gp, &chip->pci->dev);
+	gp->io = JOYSTICK_ADDR;
+	gameport_set_port_data(gp, r);
+
+	gameport_register_port(gp);
+
+	return 0;
+}
+
+static void snd_es1968_free_gameport(es1968_t *chip)
+{
+	if (chip->gameport) {
+		struct resource *r = gameport_get_port_data(chip->gameport);
+
+		gameport_unregister_port(chip->gameport);
+		chip->gameport = NULL;
+
+		release_resource(r);
+		kfree_nocheck(r);
+	}
+}
+#else
+static inline int snd_es1968_create_gameport(es1968_t *chip, int dev) { return -ENOSYS; }
+static inline void snd_es1968_free_gameport(es1968_t *chip) { }
+#endif
+
+static int snd_es1968_free(es1968_t *chip)
+{
+	if (chip->io_port) {
+		synchronize_irq(chip->irq);
+		outw(1, chip->io_port + 0x04); /* clear WP interrupts */
+		outw(0, chip->io_port + ESM_PORT_HOST_IRQ); /* disable IRQ */
+	}
+
+	if (chip->irq >= 0)
+		free_irq(chip->irq, (void *)chip);
+	snd_es1968_free_gameport(chip);
+	snd_es1968_set_acpi(chip, ACPI_D3);
+	chip->master_switch = NULL;
+	chip->master_volume = NULL;
+	pci_release_regions(chip->pci);
+	pci_disable_device(chip->pci);
+	kfree(chip);
+	return 0;
+}
+
+static int snd_es1968_dev_free(snd_device_t *device)
+{
+	es1968_t *chip = device->device_data;
+	return snd_es1968_free(chip);
+}
+
+struct ess_device_list {
+	unsigned short type;	/* chip type */
+	unsigned short vendor;	/* subsystem vendor id */
+};
+
+static struct ess_device_list pm_whitelist[] __devinitdata = {
+	{ TYPE_MAESTRO2E, 0x0e11 },	/* Compaq Armada */
+	{ TYPE_MAESTRO2E, 0x1028 },
+	{ TYPE_MAESTRO2E, 0x103c },
+	{ TYPE_MAESTRO2E, 0x1179 },
+	{ TYPE_MAESTRO2E, 0x14c0 },	/* HP omnibook 4150 */
+};
+
+static struct ess_device_list mpu_blacklist[] __devinitdata = {
+	{ TYPE_MAESTRO2, 0x125d },
+};
+
+static int __devinit snd_es1968_create(snd_card_t * card,
+				       struct pci_dev *pci,
+				       int total_bufsize,
+				       int play_streams,
+				       int capt_streams,
+				       int chip_type,
+				       int do_pm,
+				       es1968_t **chip_ret)
+{
+	static snd_device_ops_t ops = {
+		.dev_free =	snd_es1968_dev_free,
+	};
+	es1968_t *chip;
+	int i, err;
+
+	*chip_ret = NULL;
+
+	/* enable PCI device */
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+	/* check, if we can restrict PCI DMA transfers to 28 bits */
+	if (pci_set_dma_mask(pci, 0x0fffffff) < 0 ||
+	    pci_set_consistent_dma_mask(pci, 0x0fffffff) < 0) {
+		snd_printk("architecture does not support 28bit PCI busmaster DMA\n");
+		pci_disable_device(pci);
+		return -ENXIO;
+	}
+
+	chip = kcalloc(1, sizeof(*chip), GFP_KERNEL);
+	if (! chip) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+
+	/* Set Vars */
+	chip->type = chip_type;
+	spin_lock_init(&chip->reg_lock);
+	spin_lock_init(&chip->substream_lock);
+	INIT_LIST_HEAD(&chip->buf_list);
+	INIT_LIST_HEAD(&chip->substream_list);
+	spin_lock_init(&chip->ac97_lock);
+	init_MUTEX(&chip->memory_mutex);
+	tasklet_init(&chip->hwvol_tq, es1968_update_hw_volume, (unsigned long)chip);
+	chip->card = card;
+	chip->pci = pci;
+	chip->irq = -1;
+	chip->total_bufsize = total_bufsize;	/* in bytes */
+	chip->playback_streams = play_streams;
+	chip->capture_streams = capt_streams;
+
+	if ((err = pci_request_regions(pci, "ESS Maestro")) < 0) {
+		kfree(chip);
+		pci_disable_device(pci);
+		return err;
+	}
+	chip->io_port = pci_resource_start(pci, 0);
+	if (request_irq(pci->irq, snd_es1968_interrupt, SA_INTERRUPT|SA_SHIRQ,
+			"ESS Maestro", (void*)chip)) {
+		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_es1968_free(chip);
+		return -EBUSY;
+	}
+	chip->irq = pci->irq;
+	        
+	/* Clear Maestro_map */
+	for (i = 0; i < 32; i++)
+		chip->maestro_map[i] = 0;
+
+	/* Clear Apu Map */
+	for (i = 0; i < NR_APUS; i++)
+		chip->apu[i] = ESM_APU_FREE;
+
+	/* just to be sure */
+	pci_set_master(pci);
+
+	if (do_pm > 1) {
+		/* disable power-management if not on the whitelist */
+		unsigned short vend;
+		pci_read_config_word(chip->pci, PCI_SUBSYSTEM_VENDOR_ID, &vend);
+		for (i = 0; i < (int)ARRAY_SIZE(pm_whitelist); i++) {
+			if (chip->type == pm_whitelist[i].type &&
+			    vend == pm_whitelist[i].vendor) {
+				do_pm = 1;
+				break;
+			}
+		}
+		if (do_pm > 1) {
+			/* not matched; disabling pm */
+			printk(KERN_INFO "es1968: not attempting power management.\n");
+			do_pm = 0;
+		}
+	}
+	chip->do_pm = do_pm;
+
+	snd_es1968_chip_init(chip);
+
+	if (chip->do_pm)
+		snd_card_set_pm_callback(card, es1968_suspend, es1968_resume, chip);
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
+		snd_es1968_free(chip);
+		return err;
+	}
+
+	snd_card_set_dev(card, &pci->dev);
+
+	*chip_ret = chip;
+
+	return 0;
+}
+
+
+/*
+ */
+static int __devinit snd_es1968_probe(struct pci_dev *pci,
+				      const struct pci_device_id *pci_id)
+{
+	static int dev;
+	snd_card_t *card;
+	es1968_t *chip;
+	unsigned int i;
+	int err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (!card)
+		return -ENOMEM;
+                
+	if (total_bufsize[dev] < 128)
+		total_bufsize[dev] = 128;
+	if (total_bufsize[dev] > 4096)
+		total_bufsize[dev] = 4096;
+	if ((err = snd_es1968_create(card, pci,
+				     total_bufsize[dev] * 1024, /* in bytes */
+				     pcm_substreams_p[dev], 
+				     pcm_substreams_c[dev],
+				     pci_id->driver_data,
+				     use_pm[dev],
+				     &chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	switch (chip->type) {
+	case TYPE_MAESTRO2E:
+		strcpy(card->driver, "ES1978");
+		strcpy(card->shortname, "ESS ES1978 (Maestro 2E)");
+		break;
+	case TYPE_MAESTRO2:
+		strcpy(card->driver, "ES1968");
+		strcpy(card->shortname, "ESS ES1968 (Maestro 2)");
+		break;
+	case TYPE_MAESTRO:
+		strcpy(card->driver, "ESM1");
+		strcpy(card->shortname, "ESS Maestro 1");
+		break;
+	}
+
+	if ((err = snd_es1968_pcm(chip, 0)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	if ((err = snd_es1968_mixer(chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	if (enable_mpu[dev] == 2) {
+		/* check the black list */
+		unsigned short vend;
+		pci_read_config_word(chip->pci, PCI_SUBSYSTEM_VENDOR_ID, &vend);
+		for (i = 0; i < ARRAY_SIZE(mpu_blacklist); i++) {
+			if (chip->type == mpu_blacklist[i].type &&
+			    vend == mpu_blacklist[i].vendor) {
+				enable_mpu[dev] = 0;
+				break;
+			}
+		}
+	}
+	if (enable_mpu[dev]) {
+		if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,
+					       chip->io_port + ESM_MPU401_PORT, 1,
+					       chip->irq, 0, &chip->rmidi)) < 0) {
+			printk(KERN_WARNING "es1968: skipping MPU-401 MIDI support..\n");
+		}
+	}
+
+	snd_es1968_create_gameport(chip, dev);
+
+	snd_es1968_start_irq(chip);
+
+	chip->clock = clock[dev];
+	if (! chip->clock)
+		es1968_measure_clock(chip);
+
+	sprintf(card->longname, "%s at 0x%lx, irq %i",
+		card->shortname, chip->io_port, chip->irq);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_es1968_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name = "ES1968 (ESS Maestro)",
+	.id_table = snd_es1968_ids,
+	.probe = snd_es1968_probe,
+	.remove = __devexit_p(snd_es1968_remove),
+	SND_PCI_PM_CALLBACKS
+};
+
+static int __init alsa_card_es1968_init(void)
+{
+	return pci_module_init(&driver);
+}
+
+static void __exit alsa_card_es1968_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_es1968_init)
+module_exit(alsa_card_es1968_exit)
