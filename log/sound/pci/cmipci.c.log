commit 5f3aca1065e1b5a7f26ba2c991d4ebac6a69c9e8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:51 2020 +0100

    ALSA: cmipci: More constifications
    
    Apply const prefix to the static tables for rates, ports and
    registers.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-37-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 7f91742ed6f0..7363d61eaec2 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -586,7 +586,7 @@ static int snd_cmipci_clear_bit_b(struct cmipci *cm, unsigned int cmd, unsigned
  * calculate frequency
  */
 
-static unsigned int rates[] = { 5512, 11025, 22050, 44100, 8000, 16000, 32000, 48000 };
+static const unsigned int rates[] = { 5512, 11025, 22050, 44100, 8000, 16000, 32000, 48000 };
 
 static unsigned int snd_cmipci_rate_freq(unsigned int rate)
 {
@@ -2826,7 +2826,7 @@ static void query_chip(struct cmipci *cm)
 #ifdef SUPPORT_JOYSTICK
 static int snd_cmipci_create_gameport(struct cmipci *cm, int dev)
 {
-	static int ports[] = { 0x201, 0x200, 0 }; /* FIXME: majority is 0x201? */
+	static const int ports[] = { 0x201, 0x200, 0 }; /* FIXME: majority is 0x201? */
 	struct gameport *gp;
 	struct resource *r = NULL;
 	int i, io_port = 0;
@@ -3289,7 +3289,7 @@ static void snd_cmipci_remove(struct pci_dev *pci)
 /*
  * power management
  */
-static unsigned char saved_regs[] = {
+static const unsigned char saved_regs[] = {
 	CM_REG_FUNCTRL1, CM_REG_CHFORMAT, CM_REG_LEGACY_CTRL, CM_REG_MISC_CTRL,
 	CM_REG_MIXER0, CM_REG_MIXER1, CM_REG_MIXER2, CM_REG_MIXER3, CM_REG_PLL,
 	CM_REG_CH0_FRAME1, CM_REG_CH0_FRAME2,
@@ -3297,7 +3297,7 @@ static unsigned char saved_regs[] = {
 	CM_REG_INT_STATUS, CM_REG_INT_HLDCLR, CM_REG_FUNCTRL0,
 };
 
-static unsigned char saved_mixers[] = {
+static const unsigned char saved_mixers[] = {
 	SB_DSP4_MASTER_DEV, SB_DSP4_MASTER_DEV + 1,
 	SB_DSP4_PCM_DEV, SB_DSP4_PCM_DEV + 1,
 	SB_DSP4_SYNTH_DEV, SB_DSP4_SYNTH_DEV + 1,

commit b4e5e70775546480035e156b40040e5d0d4264d1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:53 2020 +0100

    ALSA: pci: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-38-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index ff5525722d58..7f91742ed6f0 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2256,7 +2256,7 @@ static int snd_cmipci_put_native_mixer_sensitive(struct snd_kcontrol *kcontrol,
 }
 
 
-static struct snd_kcontrol_new snd_cmipci_mixers[] = {
+static const struct snd_kcontrol_new snd_cmipci_mixers[] = {
 	CMIPCI_SB_VOL_STEREO("Master Playback Volume", SB_DSP4_MASTER_DEV, 3, 31),
 	CMIPCI_MIXER_SW_MONO("3D Control - Switch", CM_REG_MIXER1, CM_X3DEN_SHIFT, 0),
 	CMIPCI_SB_VOL_STEREO("PCM Playback Volume", SB_DSP4_PCM_DEV, 3, 31),
@@ -2567,7 +2567,7 @@ static int snd_cmipci_mic_in_mode_put(struct snd_kcontrol *kcontrol,
 }
 
 /* both for CM8338/8738 */
-static struct snd_kcontrol_new snd_cmipci_mixer_switches[] = {
+static const struct snd_kcontrol_new snd_cmipci_mixer_switches[] = {
 	DEFINE_MIXER_SWITCH("Four Channel Mode", fourch),
 	{
 		.name = "Line-In Mode",
@@ -2579,11 +2579,11 @@ static struct snd_kcontrol_new snd_cmipci_mixer_switches[] = {
 };
 
 /* for non-multichannel chips */
-static struct snd_kcontrol_new snd_cmipci_nomulti_switch =
+static const struct snd_kcontrol_new snd_cmipci_nomulti_switch =
 DEFINE_MIXER_SWITCH("Exchange DAC", exchange_dac);
 
 /* only for CM8738 */
-static struct snd_kcontrol_new snd_cmipci_8738_mixer_switches[] = {
+static const struct snd_kcontrol_new snd_cmipci_8738_mixer_switches[] = {
 #if 0 /* controlled in pcm device */
 	DEFINE_MIXER_SWITCH("IEC958 In Record", spdif_in),
 	DEFINE_MIXER_SWITCH("IEC958 Out", spdif_out),
@@ -2605,14 +2605,14 @@ static struct snd_kcontrol_new snd_cmipci_8738_mixer_switches[] = {
 };
 
 /* only for model 033/037 */
-static struct snd_kcontrol_new snd_cmipci_old_mixer_switches[] = {
+static const struct snd_kcontrol_new snd_cmipci_old_mixer_switches[] = {
 	DEFINE_MIXER_SWITCH("IEC958 Mix Analog", spdif_dac_out),
 	DEFINE_MIXER_SWITCH("IEC958 In Phase Inverse", spdi_phase),
 	DEFINE_MIXER_SWITCH("IEC958 In Select", spdif_in_sel1),
 };
 
 /* only for model 039 or later */
-static struct snd_kcontrol_new snd_cmipci_extra_mixer_switches[] = {
+static const struct snd_kcontrol_new snd_cmipci_extra_mixer_switches[] = {
 	DEFINE_MIXER_SWITCH("IEC958 In Select", spdif_in_sel2),
 	DEFINE_MIXER_SWITCH("IEC958 In Phase Inverse", spdi_phase2),
 	{
@@ -2625,14 +2625,14 @@ static struct snd_kcontrol_new snd_cmipci_extra_mixer_switches[] = {
 };
 
 /* card control switches */
-static struct snd_kcontrol_new snd_cmipci_modem_switch =
+static const struct snd_kcontrol_new snd_cmipci_modem_switch =
 DEFINE_CARD_SWITCH("Modem", modem);
 
 
 static int snd_cmipci_mixer_new(struct cmipci *cm, int pcm_spdif_device)
 {
 	struct snd_card *card;
-	struct snd_kcontrol_new *sw;
+	const struct snd_kcontrol_new *sw;
 	struct snd_kcontrol *kctl;
 	unsigned int idx;
 	int err;

commit efb0ad25d370344e61bb4fca8c3b9c3c6047922e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:25 2020 +0100

    ALSA: pci: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 266c4cf28b78..ff5525722d58 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2976,7 +2976,7 @@ static int snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,
 {
 	struct cmipci *cm;
 	int err;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free =	snd_cmipci_dev_free,
 	};
 	unsigned int val;

commit d8cac6207ec1abd3c85cff2625dd3898d59c4df5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 17 09:14:48 2019 +0100

    ALSA: cmipci: Allow disabling MPU port via module option
    
    Patrick May reported that his sound card with CMI8378 chip causes a
    crash / reboot when accessing the MIDI port that isn't actually
    present on the board.  Moreover, despite of the documentation,
    passing mpu_port=0 doesn't disable the MIDI port on this board.
    
    It implies that the chip is a newer revision and the MPU401 port is
    integrated and mapped on the PCI register.  For this chip model, the
    driver enables the MPU port unconditionally, so far.
    
    Although fixing the unexpected reboot would be the best solution, it's
    not so trivial to identify the cause.  So, as a plan B, this patch
    extends the existing mpu_port option usage to allow disabling the port
    by specifying the value 0, just like we applied for fm_port option in
    commit 2f24d159d5ac ("[ALSA] cmipci - Allow to disable integrated FM
    port").  As default, the MPU port is still enabled, but user can pass
    mpu_port=0 to disable it.
    
    Reported-and-tested-by: Patrick May <dusthillresident@gmail.com>
    Link: https://lore.kernel.org/r/20191217081448.1144-1-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 4bfab21c53f4..266c4cf28b78 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -42,7 +42,7 @@ MODULE_SUPPORTED_DEVICE("{{C-Media,CMI8738},"
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
-static long mpu_port[SNDRV_CARDS];
+static long mpu_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)] = 1};
 static long fm_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)]=1};
 static bool soft_ac3[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)]=1};
 #ifdef SUPPORT_JOYSTICK
@@ -3132,7 +3132,8 @@ static int snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,
 	if (cm->chip_version >= 39) {
 		val = snd_cmipci_read_b(cm, CM_REG_MPU_PCI + 1);
 		if (val != 0x00 && val != 0xff) {
-			iomidi = cm->iobase + CM_REG_MPU_PCI;
+			if (mpu_port[dev])
+				iomidi = cm->iobase + CM_REG_MPU_PCI;
 			integrated_midi = 1;
 		}
 	}

commit 3663984e07a4806c891db66c1ac4fed5c36d38f2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:09 2019 +0100

    ALSA: cmipci: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-11-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 0e0f528805bf..4bfab21c53f4 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3024,6 +3024,7 @@ static int snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,
 		return -EBUSY;
 	}
 	cm->irq = pci->irq;
+	card->sync_irq = cm->irq;
 
 	pci_set_master(cm->pci);
 

commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 1eac076f4692..0e0f528805bf 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1817,7 +1817,6 @@ static int snd_cmipci_capture_spdif_close(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_cmipci_playback_ops = {
 	.open =		snd_cmipci_playback_open,
 	.close =	snd_cmipci_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_free =	snd_cmipci_playback_hw_free,
 	.prepare =	snd_cmipci_playback_prepare,
 	.trigger =	snd_cmipci_playback_trigger,
@@ -1827,7 +1826,6 @@ static const struct snd_pcm_ops snd_cmipci_playback_ops = {
 static const struct snd_pcm_ops snd_cmipci_capture_ops = {
 	.open =		snd_cmipci_capture_open,
 	.close =	snd_cmipci_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_cmipci_capture_prepare,
 	.trigger =	snd_cmipci_capture_trigger,
 	.pointer =	snd_cmipci_capture_pointer,
@@ -1836,7 +1834,6 @@ static const struct snd_pcm_ops snd_cmipci_capture_ops = {
 static const struct snd_pcm_ops snd_cmipci_playback2_ops = {
 	.open =		snd_cmipci_playback2_open,
 	.close =	snd_cmipci_playback2_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_cmipci_playback2_hw_params,
 	.hw_free =	snd_cmipci_playback2_hw_free,
 	.prepare =	snd_cmipci_capture_prepare,	/* channel B */
@@ -1847,7 +1844,6 @@ static const struct snd_pcm_ops snd_cmipci_playback2_ops = {
 static const struct snd_pcm_ops snd_cmipci_playback_spdif_ops = {
 	.open =		snd_cmipci_playback_spdif_open,
 	.close =	snd_cmipci_playback_spdif_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_free =	snd_cmipci_playback_hw_free,
 	.prepare =	snd_cmipci_playback_spdif_prepare,	/* set up rate */
 	.trigger =	snd_cmipci_playback_trigger,
@@ -1857,7 +1853,6 @@ static const struct snd_pcm_ops snd_cmipci_playback_spdif_ops = {
 static const struct snd_pcm_ops snd_cmipci_capture_spdif_ops = {
 	.open =		snd_cmipci_capture_spdif_open,
 	.close =	snd_cmipci_capture_spdif_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_free =	snd_cmipci_capture_spdif_hw_free,
 	.prepare =	snd_cmipci_capture_spdif_prepare,
 	.trigger =	snd_cmipci_capture_trigger,

commit d841e2e88f00310b2602da3095700a0226983953
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:02 2019 +0100

    ALSA: cmipci: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The hw_params and hw_free callbacks became superfluous and got
    dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-31-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index dd9d62e2b633..1eac076f4692 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -666,12 +666,6 @@ static void snd_cmipci_set_pll(struct cmipci *cm, unsigned int rate, unsigned in
 }
 #endif /* USE_VAR48KRATE */
 
-static int snd_cmipci_hw_params(struct snd_pcm_substream *substream,
-				struct snd_pcm_hw_params *hw_params)
-{
-	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
-}
-
 static int snd_cmipci_playback2_hw_params(struct snd_pcm_substream *substream,
 					  struct snd_pcm_hw_params *hw_params)
 {
@@ -686,7 +680,7 @@ static int snd_cmipci_playback2_hw_params(struct snd_pcm_substream *substream,
 		cm->opened[CM_CH_PLAY] = CM_OPEN_PLAYBACK_MULTI;
 		mutex_unlock(&cm->open_mutex);
 	}
-	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+	return 0;
 }
 
 static void snd_cmipci_ch_reset(struct cmipci *cm, int ch)
@@ -697,11 +691,6 @@ static void snd_cmipci_ch_reset(struct cmipci *cm, int ch)
 	udelay(10);
 }
 
-static int snd_cmipci_hw_free(struct snd_pcm_substream *substream)
-{
-	return snd_pcm_lib_free_pages(substream);
-}
-
 
 /*
  */
@@ -1371,14 +1360,14 @@ static int snd_cmipci_playback_hw_free(struct snd_pcm_substream *substream)
 	setup_spdif_playback(cm, substream, 0, 0);
 	restore_mixer_state(cm);
 	snd_cmipci_silence_hack(cm, &cm->channel[0]);
-	return snd_cmipci_hw_free(substream);
+	return 0;
 }
 
 static int snd_cmipci_playback2_hw_free(struct snd_pcm_substream *substream)
 {
 	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	snd_cmipci_silence_hack(cm, &cm->channel[1]);
-	return snd_cmipci_hw_free(substream);
+	return 0;
 }
 
 /* capture */
@@ -1420,7 +1409,7 @@ static int snd_cmipci_capture_spdif_hw_free(struct snd_pcm_substream *subs)
 	snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);
 	spin_unlock_irq(&cm->reg_lock);
 
-	return snd_cmipci_hw_free(subs);
+	return 0;
 }
 
 
@@ -1829,7 +1818,6 @@ static const struct snd_pcm_ops snd_cmipci_playback_ops = {
 	.open =		snd_cmipci_playback_open,
 	.close =	snd_cmipci_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_cmipci_hw_params,
 	.hw_free =	snd_cmipci_playback_hw_free,
 	.prepare =	snd_cmipci_playback_prepare,
 	.trigger =	snd_cmipci_playback_trigger,
@@ -1840,8 +1828,6 @@ static const struct snd_pcm_ops snd_cmipci_capture_ops = {
 	.open =		snd_cmipci_capture_open,
 	.close =	snd_cmipci_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_cmipci_hw_params,
-	.hw_free =	snd_cmipci_hw_free,
 	.prepare =	snd_cmipci_capture_prepare,
 	.trigger =	snd_cmipci_capture_trigger,
 	.pointer =	snd_cmipci_capture_pointer,
@@ -1862,7 +1848,6 @@ static const struct snd_pcm_ops snd_cmipci_playback_spdif_ops = {
 	.open =		snd_cmipci_playback_spdif_open,
 	.close =	snd_cmipci_playback_spdif_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_cmipci_hw_params,
 	.hw_free =	snd_cmipci_playback_hw_free,
 	.prepare =	snd_cmipci_playback_spdif_prepare,	/* set up rate */
 	.trigger =	snd_cmipci_playback_trigger,
@@ -1873,7 +1858,6 @@ static const struct snd_pcm_ops snd_cmipci_capture_spdif_ops = {
 	.open =		snd_cmipci_capture_spdif_open,
 	.close =	snd_cmipci_capture_spdif_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_cmipci_hw_params,
 	.hw_free =	snd_cmipci_capture_spdif_hw_free,
 	.prepare =	snd_cmipci_capture_spdif_prepare,
 	.trigger =	snd_cmipci_capture_trigger,
@@ -1901,8 +1885,8 @@ static int snd_cmipci_pcm_new(struct cmipci *cm, int device)
 	strcpy(pcm->name, "C-Media PCI DAC/ADC");
 	cm->pcm = pcm;
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &cm->pci->dev, 64*1024, 128*1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
+				       &cm->pci->dev, 64*1024, 128*1024);
 
 	return 0;
 }
@@ -1923,8 +1907,8 @@ static int snd_cmipci_pcm2_new(struct cmipci *cm, int device)
 	strcpy(pcm->name, "C-Media PCI 2nd DAC");
 	cm->pcm2 = pcm;
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &cm->pci->dev, 64*1024, 128*1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
+				       &cm->pci->dev, 64*1024, 128*1024);
 
 	return 0;
 }
@@ -1946,8 +1930,8 @@ static int snd_cmipci_pcm_spdif_new(struct cmipci *cm, int device)
 	strcpy(pcm->name, "C-Media PCI IEC958");
 	cm->pcm_spdif = pcm;
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &cm->pci->dev, 64*1024, 128*1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
+				       &cm->pci->dev, 64*1024, 128*1024);
 
 	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
 				     snd_pcm_alt_chmaps, cm->max_channels, 0,

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index df720881eb99..dd9d62e2b633 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1902,7 +1902,7 @@ static int snd_cmipci_pcm_new(struct cmipci *cm, int device)
 	cm->pcm = pcm;
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      snd_dma_pci_data(cm->pci), 64*1024, 128*1024);
+					      &cm->pci->dev, 64*1024, 128*1024);
 
 	return 0;
 }
@@ -1924,7 +1924,7 @@ static int snd_cmipci_pcm2_new(struct cmipci *cm, int device)
 	cm->pcm2 = pcm;
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      snd_dma_pci_data(cm->pci), 64*1024, 128*1024);
+					      &cm->pci->dev, 64*1024, 128*1024);
 
 	return 0;
 }
@@ -1947,7 +1947,7 @@ static int snd_cmipci_pcm_spdif_new(struct cmipci *cm, int device)
 	cm->pcm_spdif = pcm;
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      snd_dma_pci_data(cm->pci), 64*1024, 128*1024);
+					      &cm->pci->dev, 64*1024, 128*1024);
 
 	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
 				     snd_pcm_alt_chmaps, cm->max_channels, 0,

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 701be04aed53..df720881eb99 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1,20 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Driver for C-Media CMI8338 and 8738 PCI soundcards.
  * Copyright (c) 2000 by Takashi Iwai <tiwai@suse.de>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
  
 /* Does not work. Warning may block system in capture mode */

commit 47f2769b4b2e267cba135fc19c89c32d202b1415
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:01:39 2019 +0100

    ALSA: pci: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 5bbf31c1695c..701be04aed53 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2792,10 +2792,7 @@ static void snd_cmipci_proc_read(struct snd_info_entry *entry,
 
 static void snd_cmipci_proc_init(struct cmipci *cm)
 {
-	struct snd_info_entry *entry;
-
-	if (! snd_card_proc_new(cm->card, "cmipci", &entry))
-		snd_info_set_text_ops(entry, cm, snd_cmipci_proc_read);
+	snd_card_ro_proc_new(cm->card, "cmipci", cm, snd_cmipci_proc_read);
 }
 
 static const struct pci_device_id snd_cmipci_ids[] = {

commit 17bc4815de586d001c82d0ddf75247283c3f002a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:02:51 2019 +0100

    ALSA: pci: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 452cc79b44af..5bbf31c1695c 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3351,10 +3351,6 @@ static int snd_cmipci_suspend(struct device *dev)
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	
-	snd_pcm_suspend_all(cm->pcm);
-	snd_pcm_suspend_all(cm->pcm2);
-	snd_pcm_suspend_all(cm->pcm_spdif);
-
 	/* save registers */
 	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
 		cm->saved_regs[i] = snd_cmipci_read(cm, saved_regs[i]);

commit 0be5168047c22ad6b2fa675f02e8090b192fbc8f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 9 22:09:27 2018 +0200

    ALSA: cmipci: Allocate with GFP_KERNEL instead of GFP_ATOMIC
    
    save_mixer_state() is called in a sleepable context, so it's safe to
    allocate with GFP_KERNEL instead of the current GFP_ATOMIC.  The
    GFP_ATOMIC usage must have been based on an incorrect assumption in
    the very old code base.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 26a657870664..452cc79b44af 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1139,7 +1139,7 @@ static int save_mixer_state(struct cmipci *cm)
 		struct snd_ctl_elem_value *val;
 		unsigned int i;
 
-		val = kmalloc(sizeof(*val), GFP_ATOMIC);
+		val = kmalloc(sizeof(*val), GFP_KERNEL);
 		if (!val)
 			return -ENOMEM;
 		for (i = 0; i < CM_SAVED_MIXERS; i++) {

commit e17a85eccfa0b7d0089af218b0c468d4b8a3c3c2
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Tue Aug 22 19:58:30 2017 +0200

    ALSA: cmipci: Use common error handling code in snd_cmipci_probe()
    
    Add a jump target so that a bit of exception handling can be better reused
    at the end of this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index a45245f16059..26a657870664 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3295,20 +3295,23 @@ static int snd_cmipci_probe(struct pci_dev *pci,
 		break;
 	}
 
-	if ((err = snd_cmipci_create(card, pci, dev, &cm)) < 0) {
-		snd_card_free(card);
-		return err;
-	}
+	err = snd_cmipci_create(card, pci, dev, &cm);
+	if (err < 0)
+		goto free_card;
+
 	card->private_data = cm;
 
-	if ((err = snd_card_register(card)) < 0) {
-		snd_card_free(card);
-		return err;
-	}
+	err = snd_card_register(card);
+	if (err < 0)
+		goto free_card;
+
 	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
 
+free_card:
+	snd_card_free(card);
+	return err;
 }
 
 static void snd_cmipci_remove(struct pci_dev *pci)

commit dee49895b197936c02d27d651e58c90bac18f452
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:28 2017 +0530

    ALSA: pci: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index a460cb63e971..a45245f16059 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1477,7 +1477,7 @@ static irqreturn_t snd_cmipci_interrupt(int irq, void *dev_id)
  */
 
 /* playback on channel A */
-static struct snd_pcm_hardware snd_cmipci_playback =
+static const struct snd_pcm_hardware snd_cmipci_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
@@ -1497,7 +1497,7 @@ static struct snd_pcm_hardware snd_cmipci_playback =
 };
 
 /* capture on channel B */
-static struct snd_pcm_hardware snd_cmipci_capture =
+static const struct snd_pcm_hardware snd_cmipci_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
@@ -1517,7 +1517,7 @@ static struct snd_pcm_hardware snd_cmipci_capture =
 };
 
 /* playback on channel B - stereo 16bit only? */
-static struct snd_pcm_hardware snd_cmipci_playback2 =
+static const struct snd_pcm_hardware snd_cmipci_playback2 =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
@@ -1537,7 +1537,7 @@ static struct snd_pcm_hardware snd_cmipci_playback2 =
 };
 
 /* spdif playback on channel A */
-static struct snd_pcm_hardware snd_cmipci_playback_spdif =
+static const struct snd_pcm_hardware snd_cmipci_playback_spdif =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
@@ -1557,7 +1557,7 @@ static struct snd_pcm_hardware snd_cmipci_playback_spdif =
 };
 
 /* spdif playback on channel A (32bit, IEC958 subframes) */
-static struct snd_pcm_hardware snd_cmipci_playback_iec958_subframe =
+static const struct snd_pcm_hardware snd_cmipci_playback_iec958_subframe =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
@@ -1577,7 +1577,7 @@ static struct snd_pcm_hardware snd_cmipci_playback_iec958_subframe =
 };
 
 /* spdif capture on channel B */
-static struct snd_pcm_hardware snd_cmipci_capture_spdif =
+static const struct snd_pcm_hardware snd_cmipci_capture_spdif =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |

commit 0fac3195a8b8677199404a62c7c5e74daaa942dd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 7 14:18:47 2017 +0200

    ALSA: cmipci: Constify hw_constraints
    
    snd_pcm_hw_constraint_list(), *_ratnums() and *_ratdens() receive the
    const pointers.  Constify the corresponding static objects for better
    hardening.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 745a0a3743b4..a460cb63e971 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -719,18 +719,18 @@ static int snd_cmipci_hw_free(struct snd_pcm_substream *substream)
 /*
  */
 
-static unsigned int hw_channels[] = {1, 2, 4, 6, 8};
-static struct snd_pcm_hw_constraint_list hw_constraints_channels_4 = {
+static const unsigned int hw_channels[] = {1, 2, 4, 6, 8};
+static const struct snd_pcm_hw_constraint_list hw_constraints_channels_4 = {
 	.count = 3,
 	.list = hw_channels,
 	.mask = 0,
 };
-static struct snd_pcm_hw_constraint_list hw_constraints_channels_6 = {
+static const struct snd_pcm_hw_constraint_list hw_constraints_channels_6 = {
 	.count = 4,
 	.list = hw_channels,
 	.mask = 0,
 };
-static struct snd_pcm_hw_constraint_list hw_constraints_channels_8 = {
+static const struct snd_pcm_hw_constraint_list hw_constraints_channels_8 = {
 	.count = 5,
 	.list = hw_channels,
 	.mask = 0,
@@ -1597,9 +1597,9 @@ static struct snd_pcm_hardware snd_cmipci_capture_spdif =
 	.fifo_size =		0,
 };
 
-static unsigned int rate_constraints[] = { 5512, 8000, 11025, 16000, 22050,
+static const unsigned int rate_constraints[] = { 5512, 8000, 11025, 16000, 22050,
 			32000, 44100, 48000, 88200, 96000, 128000 };
-static struct snd_pcm_hw_constraint_list hw_constraints_rates = {
+static const struct snd_pcm_hw_constraint_list hw_constraints_rates = {
 		.count = ARRAY_SIZE(rate_constraints),
 		.list = rate_constraints,
 		.mask = 0,

commit 291b38a7565b41676cafd1b4052315a94d9c8977
Merge: b5a53b61a289 6192c41fc608
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 10 19:13:03 2017 -0700

    Merge tag 'hwparam-20170420' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull hw lockdown support from David Howells:
     "Annotation of module parameters that configure hardware resources
      including ioports, iomem addresses, irq lines and dma channels.
    
      This allows a future patch to prohibit the use of such module
      parameters to prevent that hardware from being abused to gain access
      to the running kernel image as part of locking the kernel down under
      UEFI secure boot conditions.
    
      Annotations are made by changing:
    
            module_param(n, t, p)
            module_param_named(n, v, t, p)
            module_param_array(n, t, m, p)
    
      to:
    
            module_param_hw(n, t, hwtype, p)
            module_param_hw_named(n, v, t, hwtype, p)
            module_param_hw_array(n, t, hwtype, m, p)
    
      where the module parameter refers to a hardware setting
    
      hwtype specifies the type of the resource being configured. This can
      be one of:
    
            ioport          Module parameter configures an I/O port
            iomem           Module parameter configures an I/O mem address
            ioport_or_iomem Module parameter could be either (runtime set)
            irq             Module parameter configures an I/O port
            dma             Module parameter configures a DMA channel
            dma_addr        Module parameter configures a DMA buffer address
            other           Module parameter configures some other value
    
      Note that the hwtype is compile checked, but not currently stored (the
      lockdown code probably won't require it). It is, however, there for
      future use.
    
      A bonus is that the hwtype can also be used for grepping.
    
      The intention is for the kernel to ignore or reject attempts to set
      annotated module parameters if lockdown is enabled. This applies to
      options passed on the boot command line, passed to insmod/modprobe or
      direct twiddling in /sys/module/ parameter files.
    
      The module initialisation then needs to handle the parameter not being
      set, by (1) giving an error, (2) probing for a value or (3) using a
      reasonable default.
    
      What I can't do is just reject a module out of hand because it may
      take a hardware setting in the module parameters. Some important
      modules, some ipmi stuff for instance, both probe for hardware and
      allow hardware to be manually specified; if the driver is aborts with
      any error, you don't get any ipmi hardware.
    
      Further, trying to do this entirely in the module initialisation code
      doesn't protect against sysfs twiddling.
    
      [!] Note that in and of itself, this series of patches should have no
          effect on the the size of the kernel or code execution - that is
          left to a patch in the next series to effect. It does mark
          annotated kernel parameters with a KERNEL_PARAM_FL_HWPARAM flag in
          an already existing field"
    
    * tag 'hwparam-20170420' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs: (38 commits)
      Annotate hardware config module parameters in sound/pci/
      Annotate hardware config module parameters in sound/oss/
      Annotate hardware config module parameters in sound/isa/
      Annotate hardware config module parameters in sound/drivers/
      Annotate hardware config module parameters in fs/pstore/
      Annotate hardware config module parameters in drivers/watchdog/
      Annotate hardware config module parameters in drivers/video/
      Annotate hardware config module parameters in drivers/tty/
      Annotate hardware config module parameters in drivers/staging/vme/
      Annotate hardware config module parameters in drivers/staging/speakup/
      Annotate hardware config module parameters in drivers/staging/media/
      Annotate hardware config module parameters in drivers/scsi/
      Annotate hardware config module parameters in drivers/pcmcia/
      Annotate hardware config module parameters in drivers/pci/hotplug/
      Annotate hardware config module parameters in drivers/parport/
      Annotate hardware config module parameters in drivers/net/wireless/
      Annotate hardware config module parameters in drivers/net/wan/
      Annotate hardware config module parameters in drivers/net/irda/
      Annotate hardware config module parameters in drivers/net/hamradio/
      Annotate hardware config module parameters in drivers/net/ethernet/
      ...

commit 6192c41fc608b0a58d5540b015aa1672c266f3c5
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:30 2017 +0100

    Annotate hardware config module parameters in sound/pci/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in sound/pci/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jaroslav Kysela <perex@perex.cz>
    cc: Takashi Iwai <tiwai@suse.com>
    cc: alsa-devel@alsa-project.org

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index aeedc270ed9b..430f064c64da 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -68,14 +68,14 @@ module_param_array(id, charp, NULL, 0444);
 MODULE_PARM_DESC(id, "ID string for C-Media PCI soundcard.");
 module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable C-Media PCI soundcard.");
-module_param_array(mpu_port, long, NULL, 0444);
+module_param_hw_array(mpu_port, long, ioport, NULL, 0444);
 MODULE_PARM_DESC(mpu_port, "MPU-401 port.");
-module_param_array(fm_port, long, NULL, 0444);
+module_param_hw_array(fm_port, long, ioport, NULL, 0444);
 MODULE_PARM_DESC(fm_port, "FM port.");
 module_param_array(soft_ac3, bool, NULL, 0444);
 MODULE_PARM_DESC(soft_ac3, "Software-conversion of raw SPDIF packets (model 033 only).");
 #ifdef SUPPORT_JOYSTICK
-module_param_array(joystick_port, int, NULL, 0444);
+module_param_hw_array(joystick_port, int, ioport, NULL, 0444);
 MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #endif
 

commit f3b827e0b1841f4cfc18436e09f4f269f3be908e
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Mon Feb 20 00:18:09 2017 +0530

    ALSA: pci: constify snd_kcontrol_new structures
    
    Declare snd_kcontrol_new structures as const as they are only passed as
    an argument to the function snd_ctl_new1. This argument is of type
    const, so snd_kcontrol_new structures having the same property can be
    made const too.
    Done using Coccinelle:
    
    @r1 disable optional_qualifier @
    identifier i;
    position p;
    @@
    static struct snd_kcontrol_new i@p = {...};
    
    @ok1@
    identifier r1.i;
    position p;
    expression e1;
    @@
    snd_ctl_new1(&i@p,e1)
    
    @bad@
    position p!={r1.p,ok1.p};
    identifier r1.i;
    @@
    i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r1.i;
    @@
    +const
    struct snd_kcontrol_new i;
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index aeedc270ed9b..227c9d3802b8 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1045,7 +1045,7 @@ static int snd_cmipci_spdif_default_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_cmipci_spdif_default =
+static const struct snd_kcontrol_new snd_cmipci_spdif_default =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
@@ -1072,7 +1072,7 @@ static int snd_cmipci_spdif_mask_get(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_cmipci_spdif_mask =
+static const struct snd_kcontrol_new snd_cmipci_spdif_mask =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -1119,7 +1119,7 @@ static int snd_cmipci_spdif_stream_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_cmipci_spdif_stream =
+static const struct snd_kcontrol_new snd_cmipci_spdif_stream =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,

commit b2fac0730347d591b528d8f0e4a9438c1bb6f558
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sat Nov 12 23:26:41 2016 +0100

    ALSA: pci: don't opencode IS_REACHABLE()
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 73f593526b2d..aeedc270ed9b 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -48,7 +48,7 @@ MODULE_SUPPORTED_DEVICE("{{C-Media,CMI8738},"
 		"{C-Media,CMI8338A},"
 		"{C-Media,CMI8338B}}");
 
-#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+#if IS_REACHABLE(CONFIG_GAMEPORT)
 #define SUPPORT_JOYSTICK 1
 #endif
 

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 24cdcba06d27..73f593526b2d 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1838,7 +1838,7 @@ static int snd_cmipci_capture_spdif_close(struct snd_pcm_substream *substream)
 /*
  */
 
-static struct snd_pcm_ops snd_cmipci_playback_ops = {
+static const struct snd_pcm_ops snd_cmipci_playback_ops = {
 	.open =		snd_cmipci_playback_open,
 	.close =	snd_cmipci_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1849,7 +1849,7 @@ static struct snd_pcm_ops snd_cmipci_playback_ops = {
 	.pointer =	snd_cmipci_playback_pointer,
 };
 
-static struct snd_pcm_ops snd_cmipci_capture_ops = {
+static const struct snd_pcm_ops snd_cmipci_capture_ops = {
 	.open =		snd_cmipci_capture_open,
 	.close =	snd_cmipci_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1860,7 +1860,7 @@ static struct snd_pcm_ops snd_cmipci_capture_ops = {
 	.pointer =	snd_cmipci_capture_pointer,
 };
 
-static struct snd_pcm_ops snd_cmipci_playback2_ops = {
+static const struct snd_pcm_ops snd_cmipci_playback2_ops = {
 	.open =		snd_cmipci_playback2_open,
 	.close =	snd_cmipci_playback2_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1871,7 +1871,7 @@ static struct snd_pcm_ops snd_cmipci_playback2_ops = {
 	.pointer =	snd_cmipci_capture_pointer,	/* channel B */
 };
 
-static struct snd_pcm_ops snd_cmipci_playback_spdif_ops = {
+static const struct snd_pcm_ops snd_cmipci_playback_spdif_ops = {
 	.open =		snd_cmipci_playback_spdif_open,
 	.close =	snd_cmipci_playback_spdif_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1882,7 +1882,7 @@ static struct snd_pcm_ops snd_cmipci_playback_spdif_ops = {
 	.pointer =	snd_cmipci_playback_pointer,
 };
 
-static struct snd_pcm_ops snd_cmipci_capture_spdif_ops = {
+static const struct snd_pcm_ops snd_cmipci_capture_spdif_ops = {
 	.open =		snd_cmipci_capture_spdif_open,
 	.close =	snd_cmipci_capture_spdif_close,
 	.ioctl =	snd_pcm_lib_ioctl,

commit 3270f0dd1a35d6b785bf39e1ed7ed6e1e43c8ebb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 29 08:00:06 2015 +0200

    ALSA: pci: Drop superfluous ifdef CONFIG_PROC_FS
    
    The compiler can optimize the unused code away, so we can drop
    ifdefs.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 6cf464d9043d..24cdcba06d27 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2772,7 +2772,6 @@ static int snd_cmipci_mixer_new(struct cmipci *cm, int pcm_spdif_device)
  * proc interface
  */
 
-#ifdef CONFIG_PROC_FS
 static void snd_cmipci_proc_read(struct snd_info_entry *entry, 
 				 struct snd_info_buffer *buffer)
 {
@@ -2798,10 +2797,6 @@ static void snd_cmipci_proc_init(struct cmipci *cm)
 	if (! snd_card_proc_new(cm->card, "cmipci", &entry))
 		snd_info_set_text_ops(entry, cm, snd_cmipci_proc_read);
 }
-#else /* !CONFIG_PROC_FS */
-static inline void snd_cmipci_proc_init(struct cmipci *cm) {}
-#endif
-
 
 static const struct pci_device_id snd_cmipci_ids[] = {
 	{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338A), 0},

commit 9603cded0e2cef003a822985d84b5daff1c7232f
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Feb 25 16:33:57 2015 +0300

    ALSA: cmipci: remove a stray space character
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 1d0f2cad2f5a..6cf464d9043d 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2062,7 +2062,7 @@ static int snd_cmipci_get_volume(struct snd_kcontrol *kcontrol,
 		val = (snd_cmipci_mixer_read(cm, reg.right_reg) >> reg.right_shift) & reg.mask;
 		if (reg.invert)
 			val = reg.mask - val;
-		 ucontrol->value.integer.value[1] = val;
+		ucontrol->value.integer.value[1] = val;
 	}
 	spin_unlock_irq(&cm->reg_lock);
 	return 0;

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 63d2c8236ec6..1d0f2cad2f5a 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -20,7 +20,7 @@
 /* Does not work. Warning may block system in capture mode */
 /* #define USE_VAR48KRATE */
 
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>

commit 5762fdb5f9b18a5bf8cdbdfbc0c735ad1d88a478
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 8 12:45:12 2015 +0100

    ALSA: cmipci: Simplify PM callbacks
    
    This is a similar cleanup like the commit [3db084fd0af5: ALSA: fm801:
    PCI core handles power state for us].
    
    Since pci_set_power_state(), pci_save_state() and pci_restore_state()
    are already done in the PCI core side, so we don't need to it doubly.
    
    Also, pci_enable_device(), pci_disable_device() and pci_set_master()
    calls in PM callbacks are superfluous nowadays, too, so get rid of
    them as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 85ed40339db9..63d2c8236ec6 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3347,7 +3347,6 @@ static unsigned char saved_mixers[] = {
 
 static int snd_cmipci_suspend(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct cmipci *cm = card->private_data;
 	int i;
@@ -3366,29 +3365,15 @@ static int snd_cmipci_suspend(struct device *dev)
 
 	/* disable ints */
 	snd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);
-
-	pci_disable_device(pci);
-	pci_save_state(pci);
-	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
 static int snd_cmipci_resume(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct cmipci *cm = card->private_data;
 	int i;
 
-	pci_set_power_state(pci, PCI_D0);
-	pci_restore_state(pci);
-	if (pci_enable_device(pci) < 0) {
-		dev_err(dev, "pci_enable_device failed, disabling device\n");
-		snd_card_disconnect(card);
-		return -EIO;
-	}
-	pci_set_master(pci);
-
 	/* reset / initialize to a sane state */
 	snd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);
 	snd_cmipci_ch_reset(cm, CM_CH_PLAY);

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 12c318e175f4..85ed40339db9 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2803,7 +2803,7 @@ static inline void snd_cmipci_proc_init(struct cmipci *cm) {}
 #endif
 
 
-static DEFINE_PCI_DEVICE_TABLE(snd_cmipci_ids) = {
+static const struct pci_device_id snd_cmipci_ids[] = {
 	{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338A), 0},
 	{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338B), 0},
 	{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738), 0},
@@ -3026,7 +3026,7 @@ static int snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,
 	int integrated_midi = 0;
 	char modelstr[16];
 	int pcm_index, pcm_spdif_index;
-	static DEFINE_PCI_DEVICE_TABLE(intel_82437vx) = {
+	static const struct pci_device_id intel_82437vx[] = {
 		{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82437VX) },
 		{ },
 	};

commit 40175bdba1bbf8bea27bf521af5fdfbc0ea5eeee
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 12:39:30 2014 +0100

    ALSA: cmipci: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    Some commented debug prints are also enabled as dev_dbg().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 66c0558ce449..12c318e175f4 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -796,7 +796,7 @@ static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
 	if (runtime->channels > 1)
 		rec->fmt |= 0x01;
 	if (rec->is_dac && set_dac_channels(cm, rec, runtime->channels) < 0) {
-		snd_printd("cannot set dac channels\n");
+		dev_dbg(cm->card->dev, "cannot set dac channels\n");
 		return -EINVAL;
 	}
 
@@ -827,7 +827,7 @@ static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
 	else
 		cm->ctrl |= val;
 	snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);
-	//snd_printd("cmipci: functrl0 = %08x\n", cm->ctrl);
+	/* dev_dbg(cm->card->dev, "functrl0 = %08x\n", cm->ctrl); */
 
 	/* set sample rate */
 	freq = 0;
@@ -850,7 +850,7 @@ static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
 		val |= (freq << CM_ASFC_SHIFT) & CM_ASFC_MASK;
 	}
 	snd_cmipci_write(cm, CM_REG_FUNCTRL1, val);
-	//snd_printd("cmipci: functrl1 = %08x\n", val);
+	dev_dbg(cm->card->dev, "functrl1 = %08x\n", val);
 
 	/* set format */
 	val = snd_cmipci_read(cm, CM_REG_CHFORMAT);
@@ -866,7 +866,7 @@ static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
 		val |= freq_ext << (rec->ch * 2);
 	}
 	snd_cmipci_write(cm, CM_REG_CHFORMAT, val);
-	//snd_printd("cmipci: chformat = %08x\n", val);
+	dev_dbg(cm->card->dev, "chformat = %08x\n", val);
 
 	if (!rec->is_dac && cm->chip_version) {
 		if (runtime->rate > 44100)
@@ -904,7 +904,7 @@ static int snd_cmipci_pcm_trigger(struct cmipci *cm, struct cmipci_pcm *rec,
 		cm->ctrl |= chen;
 		/* enable channel */
 		snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);
-		//snd_printd("cmipci: functrl0 = %08x\n", cm->ctrl);
+		dev_dbg(cm->card->dev, "functrl0 = %08x\n", cm->ctrl);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 		rec->running = 0;
@@ -952,7 +952,7 @@ static snd_pcm_uframes_t snd_cmipci_pcm_pointer(struct cmipci *cm, struct cmipci
 		if (rem < rec->dma_size)
 			goto ok;
 	} 
-	printk(KERN_ERR "cmipci: invalid PCM pointer: %#x\n", rem);
+	dev_err(cm->card->dev, "invalid PCM pointer: %#x\n", rem);
 	return SNDRV_PCM_POS_XRUN;
 ok:
 	ptr = (rec->dma_size - (rem + 1)) >> rec->shift;
@@ -2889,13 +2889,13 @@ static int snd_cmipci_create_gameport(struct cmipci *cm, int dev)
 	}
 
 	if (!r) {
-		printk(KERN_WARNING "cmipci: cannot reserve joystick ports\n");
+		dev_warn(cm->card->dev, "cannot reserve joystick ports\n");
 		return -EBUSY;
 	}
 
 	cm->gameport = gp = gameport_allocate_port();
 	if (!gp) {
-		printk(KERN_ERR "cmipci: cannot allocate memory for gameport\n");
+		dev_err(cm->card->dev, "cannot allocate memory for gameport\n");
 		release_and_free_resource(r);
 		return -ENOMEM;
 	}
@@ -2995,13 +2995,14 @@ static int snd_cmipci_create_fm(struct cmipci *cm, long fm_port)
 
 		if (snd_opl3_create(cm->card, iosynth, iosynth + 2,
 				    OPL3_HW_OPL3, 0, &opl3) < 0) {
-			printk(KERN_ERR "cmipci: no OPL device at %#lx, "
-			       "skipping...\n", iosynth);
+			dev_err(cm->card->dev,
+				"no OPL device at %#lx, skipping...\n",
+				iosynth);
 			goto disable_fm;
 		}
 	}
 	if ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {
-		printk(KERN_ERR "cmipci: cannot create OPL3 hwdep\n");
+		dev_err(cm->card->dev, "cannot create OPL3 hwdep\n");
 		return err;
 	}
 	return 0;
@@ -3060,7 +3061,7 @@ static int snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,
 
 	if (request_irq(pci->irq, snd_cmipci_interrupt,
 			IRQF_SHARED, KBUILD_MODNAME, cm)) {
-		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		dev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);
 		snd_cmipci_free(cm);
 		return -EBUSY;
 	}
@@ -3192,8 +3193,9 @@ static int snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,
 			/* enable UART */
 			snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_UART_EN);
 			if (inb(iomidi + 1) == 0xff) {
-				snd_printk(KERN_ERR "cannot enable MPU-401 port"
-					   " at %#lx\n", iomidi);
+				dev_err(cm->card->dev,
+					"cannot enable MPU-401 port at %#lx\n",
+					iomidi);
 				snd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1,
 						     CM_UART_EN);
 				iomidi = 0;
@@ -3237,7 +3239,8 @@ static int snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,
 						MPU401_INFO_INTEGRATED : 0) |
 					       MPU401_INFO_IRQ_HOOK,
 					       -1, &cm->rmidi)) < 0) {
-			printk(KERN_ERR "cmipci: no UART401 device at 0x%lx\n", iomidi);
+			dev_err(cm->card->dev,
+				"no UART401 device at 0x%lx\n", iomidi);
 		}
 	}
 
@@ -3380,8 +3383,7 @@ static int snd_cmipci_resume(struct device *dev)
 	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
 	if (pci_enable_device(pci) < 0) {
-		printk(KERN_ERR "cmipci: pci_enable_device failed, "
-		       "disabling device\n");
+		dev_err(dev, "pci_enable_device failed, disabling device\n");
 		snd_card_disconnect(card);
 		return -EIO;
 	}

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 2755ec5bcc25..66c0558ce449 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3254,8 +3254,6 @@ static int snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,
 	if (snd_cmipci_create_gameport(cm, dev) < 0)
 		snd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_JYSTK_EN);
 
-	snd_card_set_dev(card, &pci->dev);
-
 	*rcmipci = cm;
 	return 0;
 }
@@ -3280,7 +3278,8 @@ static int snd_cmipci_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
+			   0, &card);
 	if (err < 0)
 		return err;
 	

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index c617435db6e6..2755ec5bcc25 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3317,7 +3317,6 @@ static int snd_cmipci_probe(struct pci_dev *pci,
 static void snd_cmipci_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 22122ff26e34..c617435db6e6 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1045,7 +1045,7 @@ static int snd_cmipci_spdif_default_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_cmipci_spdif_default __devinitdata =
+static struct snd_kcontrol_new snd_cmipci_spdif_default =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
@@ -1072,7 +1072,7 @@ static int snd_cmipci_spdif_mask_get(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_cmipci_spdif_mask __devinitdata =
+static struct snd_kcontrol_new snd_cmipci_spdif_mask =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -1119,7 +1119,7 @@ static int snd_cmipci_spdif_stream_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_cmipci_spdif_stream __devinitdata =
+static struct snd_kcontrol_new snd_cmipci_spdif_stream =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -1897,7 +1897,7 @@ static struct snd_pcm_ops snd_cmipci_capture_spdif_ops = {
 /*
  */
 
-static int __devinit snd_cmipci_pcm_new(struct cmipci *cm, int device)
+static int snd_cmipci_pcm_new(struct cmipci *cm, int device)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -1920,7 +1920,7 @@ static int __devinit snd_cmipci_pcm_new(struct cmipci *cm, int device)
 	return 0;
 }
 
-static int __devinit snd_cmipci_pcm2_new(struct cmipci *cm, int device)
+static int snd_cmipci_pcm2_new(struct cmipci *cm, int device)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -1942,7 +1942,7 @@ static int __devinit snd_cmipci_pcm2_new(struct cmipci *cm, int device)
 	return 0;
 }
 
-static int __devinit snd_cmipci_pcm_spdif_new(struct cmipci *cm, int device)
+static int snd_cmipci_pcm_spdif_new(struct cmipci *cm, int device)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -2290,7 +2290,7 @@ static int snd_cmipci_put_native_mixer_sensitive(struct snd_kcontrol *kcontrol,
 }
 
 
-static struct snd_kcontrol_new snd_cmipci_mixers[] __devinitdata = {
+static struct snd_kcontrol_new snd_cmipci_mixers[] = {
 	CMIPCI_SB_VOL_STEREO("Master Playback Volume", SB_DSP4_MASTER_DEV, 3, 31),
 	CMIPCI_MIXER_SW_MONO("3D Control - Switch", CM_REG_MIXER1, CM_X3DEN_SHIFT, 0),
 	CMIPCI_SB_VOL_STEREO("PCM Playback Volume", SB_DSP4_PCM_DEV, 3, 31),
@@ -2601,7 +2601,7 @@ static int snd_cmipci_mic_in_mode_put(struct snd_kcontrol *kcontrol,
 }
 
 /* both for CM8338/8738 */
-static struct snd_kcontrol_new snd_cmipci_mixer_switches[] __devinitdata = {
+static struct snd_kcontrol_new snd_cmipci_mixer_switches[] = {
 	DEFINE_MIXER_SWITCH("Four Channel Mode", fourch),
 	{
 		.name = "Line-In Mode",
@@ -2613,11 +2613,11 @@ static struct snd_kcontrol_new snd_cmipci_mixer_switches[] __devinitdata = {
 };
 
 /* for non-multichannel chips */
-static struct snd_kcontrol_new snd_cmipci_nomulti_switch __devinitdata =
+static struct snd_kcontrol_new snd_cmipci_nomulti_switch =
 DEFINE_MIXER_SWITCH("Exchange DAC", exchange_dac);
 
 /* only for CM8738 */
-static struct snd_kcontrol_new snd_cmipci_8738_mixer_switches[] __devinitdata = {
+static struct snd_kcontrol_new snd_cmipci_8738_mixer_switches[] = {
 #if 0 /* controlled in pcm device */
 	DEFINE_MIXER_SWITCH("IEC958 In Record", spdif_in),
 	DEFINE_MIXER_SWITCH("IEC958 Out", spdif_out),
@@ -2639,14 +2639,14 @@ static struct snd_kcontrol_new snd_cmipci_8738_mixer_switches[] __devinitdata =
 };
 
 /* only for model 033/037 */
-static struct snd_kcontrol_new snd_cmipci_old_mixer_switches[] __devinitdata = {
+static struct snd_kcontrol_new snd_cmipci_old_mixer_switches[] = {
 	DEFINE_MIXER_SWITCH("IEC958 Mix Analog", spdif_dac_out),
 	DEFINE_MIXER_SWITCH("IEC958 In Phase Inverse", spdi_phase),
 	DEFINE_MIXER_SWITCH("IEC958 In Select", spdif_in_sel1),
 };
 
 /* only for model 039 or later */
-static struct snd_kcontrol_new snd_cmipci_extra_mixer_switches[] __devinitdata = {
+static struct snd_kcontrol_new snd_cmipci_extra_mixer_switches[] = {
 	DEFINE_MIXER_SWITCH("IEC958 In Select", spdif_in_sel2),
 	DEFINE_MIXER_SWITCH("IEC958 In Phase Inverse", spdi_phase2),
 	{
@@ -2659,11 +2659,11 @@ static struct snd_kcontrol_new snd_cmipci_extra_mixer_switches[] __devinitdata =
 };
 
 /* card control switches */
-static struct snd_kcontrol_new snd_cmipci_modem_switch __devinitdata =
+static struct snd_kcontrol_new snd_cmipci_modem_switch =
 DEFINE_CARD_SWITCH("Modem", modem);
 
 
-static int __devinit snd_cmipci_mixer_new(struct cmipci *cm, int pcm_spdif_device)
+static int snd_cmipci_mixer_new(struct cmipci *cm, int pcm_spdif_device)
 {
 	struct snd_card *card;
 	struct snd_kcontrol_new *sw;
@@ -2791,7 +2791,7 @@ static void snd_cmipci_proc_read(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "\n");
 }
 
-static void __devinit snd_cmipci_proc_init(struct cmipci *cm)
+static void snd_cmipci_proc_init(struct cmipci *cm)
 {
 	struct snd_info_entry *entry;
 
@@ -2817,7 +2817,7 @@ static DEFINE_PCI_DEVICE_TABLE(snd_cmipci_ids) = {
  * check chip version and capabilities
  * driver name is modified according to the chip model
  */
-static void __devinit query_chip(struct cmipci *cm)
+static void query_chip(struct cmipci *cm)
 {
 	unsigned int detect;
 
@@ -2866,7 +2866,7 @@ static void __devinit query_chip(struct cmipci *cm)
 }
 
 #ifdef SUPPORT_JOYSTICK
-static int __devinit snd_cmipci_create_gameport(struct cmipci *cm, int dev)
+static int snd_cmipci_create_gameport(struct cmipci *cm, int dev)
 {
 	static int ports[] = { 0x201, 0x200, 0 }; /* FIXME: majority is 0x201? */
 	struct gameport *gp;
@@ -2959,7 +2959,7 @@ static int snd_cmipci_dev_free(struct snd_device *device)
 	return snd_cmipci_free(cm);
 }
 
-static int __devinit snd_cmipci_create_fm(struct cmipci *cm, long fm_port)
+static int snd_cmipci_create_fm(struct cmipci *cm, long fm_port)
 {
 	long iosynth;
 	unsigned int val;
@@ -3012,8 +3012,8 @@ static int __devinit snd_cmipci_create_fm(struct cmipci *cm, long fm_port)
 	return 0;
 }
 
-static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,
-				       int dev, struct cmipci **rcmipci)
+static int snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,
+			     int dev, struct cmipci **rcmipci)
 {
 	struct cmipci *cm;
 	int err;
@@ -3265,8 +3265,8 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 
 MODULE_DEVICE_TABLE(pci, snd_cmipci_ids);
 
-static int __devinit snd_cmipci_probe(struct pci_dev *pci,
-				      const struct pci_device_id *pci_id)
+static int snd_cmipci_probe(struct pci_dev *pci,
+			    const struct pci_device_id *pci_id)
 {
 	static int dev;
 	struct snd_card *card;
@@ -3314,7 +3314,7 @@ static int __devinit snd_cmipci_probe(struct pci_dev *pci,
 
 }
 
-static void __devexit snd_cmipci_remove(struct pci_dev *pci)
+static void snd_cmipci_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -3415,7 +3415,7 @@ static struct pci_driver cmipci_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_cmipci_ids,
 	.probe = snd_cmipci_probe,
-	.remove = __devexit_p(snd_cmipci_remove),
+	.remove = snd_cmipci_remove,
 	.driver = {
 		.pm = SND_CMIPCI_PM_OPS,
 	},

commit f49921b894ec338696e47d985acc09df3cddbfd1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 3 18:02:38 2012 +0200

    ALSA: cmipci: Implement channel mapping
    
    Simply enable the channel map according to the h/w capability.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 7c25906b5f88..22122ff26e34 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1962,6 +1962,12 @@ static int __devinit snd_cmipci_pcm_spdif_new(struct cmipci *cm, int device)
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
 					      snd_dma_pci_data(cm->pci), 64*1024, 128*1024);
 
+	err = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				     snd_pcm_alt_chmaps, cm->max_channels, 0,
+				     NULL);
+	if (err < 0)
+		return err;
+
 	return 0;
 }
 

commit c7561cd80469f2fe4a6be0984db57832ee7f2a3b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 14 18:12:04 2012 +0200

    ALSA: PCI: Replace CONFIG_PM with CONFIG_PM_SLEEP
    
    Otherwise we may get compile warnings due to unused functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index b7d6f2b886ef..7c25906b5f88 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -504,7 +504,7 @@ struct cmipci {
 
 	spinlock_t reg_lock;
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	unsigned int saved_regs[0x20];
 	unsigned char saved_mixers[0x20];
 #endif
@@ -3315,7 +3315,7 @@ static void __devexit snd_cmipci_remove(struct pci_dev *pci)
 }
 
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 /*
  * power management
  */
@@ -3403,7 +3403,7 @@ static SIMPLE_DEV_PM_OPS(snd_cmipci_pm, snd_cmipci_suspend, snd_cmipci_resume);
 #define SND_CMIPCI_PM_OPS	&snd_cmipci_pm
 #else
 #define SND_CMIPCI_PM_OPS	NULL
-#endif /* CONFIG_PM */
+#endif /* CONFIG_PM_SLEEP */
 
 static struct pci_driver cmipci_driver = {
 	.name = KBUILD_MODNAME,

commit 68cb2b559278858ef9f3a7722f95df88797c7840
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 15:20:37 2012 +0200

    ALSA: Convert to new pm_ops for PCI drivers
    
    Straightforward conversion to the new pm_ops from the legacy
    suspend/resume ops.
    
    Since we change vx222, vx_core and vxpocket have to be converted,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 3815bd4c6779..b7d6f2b886ef 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3338,9 +3338,10 @@ static unsigned char saved_mixers[] = {
 	SB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT,
 };
 
-static int snd_cmipci_suspend(struct pci_dev *pci, pm_message_t state)
+static int snd_cmipci_suspend(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct cmipci *cm = card->private_data;
 	int i;
 
@@ -3361,13 +3362,14 @@ static int snd_cmipci_suspend(struct pci_dev *pci, pm_message_t state)
 
 	pci_disable_device(pci);
 	pci_save_state(pci);
-	pci_set_power_state(pci, pci_choose_state(pci, state));
+	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
-static int snd_cmipci_resume(struct pci_dev *pci)
+static int snd_cmipci_resume(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct cmipci *cm = card->private_data;
 	int i;
 
@@ -3396,6 +3398,11 @@ static int snd_cmipci_resume(struct pci_dev *pci)
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
+
+static SIMPLE_DEV_PM_OPS(snd_cmipci_pm, snd_cmipci_suspend, snd_cmipci_resume);
+#define SND_CMIPCI_PM_OPS	&snd_cmipci_pm
+#else
+#define SND_CMIPCI_PM_OPS	NULL
 #endif /* CONFIG_PM */
 
 static struct pci_driver cmipci_driver = {
@@ -3403,10 +3410,9 @@ static struct pci_driver cmipci_driver = {
 	.id_table = snd_cmipci_ids,
 	.probe = snd_cmipci_probe,
 	.remove = __devexit_p(snd_cmipci_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_cmipci_suspend,
-	.resume = snd_cmipci_resume,
-#endif
+	.driver = {
+		.pm = SND_CMIPCI_PM_OPS,
+	},
 };
 	
 module_pci_driver(cmipci_driver);

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 19b06269adc2..3815bd4c6779 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3398,7 +3398,7 @@ static int snd_cmipci_resume(struct pci_dev *pci)
 }
 #endif /* CONFIG_PM */
 
-static struct pci_driver driver = {
+static struct pci_driver cmipci_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_cmipci_ids,
 	.probe = snd_cmipci_probe,
@@ -3409,15 +3409,4 @@ static struct pci_driver driver = {
 #endif
 };
 	
-static int __init alsa_card_cmipci_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit alsa_card_cmipci_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(alsa_card_cmipci_init)
-module_exit(alsa_card_cmipci_exit)
+module_pci_driver(cmipci_driver);

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 954c9934748a..19b06269adc2 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -54,10 +54,10 @@ MODULE_SUPPORTED_DEVICE("{{C-Media,CMI8738},"
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
 static long mpu_port[SNDRV_CARDS];
 static long fm_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)]=1};
-static int soft_ac3[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)]=1};
+static bool soft_ac3[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)]=1};
 #ifdef SUPPORT_JOYSTICK
 static int joystick_port[SNDRV_CARDS];
 #endif

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index da9c73211eca..954c9934748a 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -27,7 +27,7 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <linux/mutex.h>
 #include <sound/core.h>
 #include <sound/info.h>

commit dba8b46992c55946d3b092934f581a343403118f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Sep 13 11:24:41 2011 +0200

    ALSA: mpu401: clean up interrupt specification
    
    The semantics of snd_mpu401_uart_new()'s interrupt parameters are
    somewhat counterintuitive:  To prevent the function from allocating its
    own interrupt, either the irq number must be invalid, or the irq_flags
    parameter must be zero.  At the same time, the irq parameter being
    invalid specifies that the mpu401 code has to work without an interrupt
    allocated by the caller.  This implies that, if there is an interrupt
    and it is allocated by the caller, the irq parameter must be set to
    a valid-looking number which then isn't actually used.
    
    With the removal of IRQF_DISABLED, zero becomes a valid irq_flags value,
    which forces us to handle the parameters differently.
    
    This patch introduces a new flag MPU401_INFO_IRQ_HOOK for when the
    device interrupt is handled by the caller, and makes the allocation of
    the interrupt to depend only on the irq parameter.  As suggested by
    Takashi, the irq_flags parameter was dropped because, when used, it had
    the constant value IRQF_DISABLED.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 9cf99fb7eb9c..da9c73211eca 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3228,8 +3228,9 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 		if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_CMIPCI,
 					       iomidi,
 					       (integrated_midi ?
-						MPU401_INFO_INTEGRATED : 0),
-					       cm->irq, 0, &cm->rmidi)) < 0) {
+						MPU401_INFO_INTEGRATED : 0) |
+					       MPU401_INFO_IRQ_HOOK,
+					       -1, &cm->rmidi)) < 0) {
 			printk(KERN_ERR "cmipci: no UART401 device at 0x%lx\n", iomidi);
 		}
 	}

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 84af5bece127..9cf99fb7eb9c 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3053,7 +3053,7 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 	cm->iobase = pci_resource_start(pci, 0);
 
 	if (request_irq(pci->irq, snd_cmipci_interrupt,
-			IRQF_SHARED, card->driver, cm)) {
+			IRQF_SHARED, KBUILD_MODNAME, cm)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_cmipci_free(cm);
 		return -EBUSY;

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index f4e573555da3..84af5bece127 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3398,7 +3398,7 @@ static int snd_cmipci_resume(struct pci_dev *pci)
 #endif /* CONFIG_PM */
 
 static struct pci_driver driver = {
-	.name = "C-Media PCI",
+	.name = KBUILD_MODNAME,
 	.id_table = snd_cmipci_ids,
 	.probe = snd_cmipci_probe,
 	.remove = __devexit_p(snd_cmipci_remove),

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index b5bb036ef73c..f4e573555da3 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -73,7 +73,7 @@ MODULE_PARM_DESC(mpu_port, "MPU-401 port.");
 module_param_array(fm_port, long, NULL, 0444);
 MODULE_PARM_DESC(fm_port, "FM port.");
 module_param_array(soft_ac3, bool, NULL, 0444);
-MODULE_PARM_DESC(soft_ac3, "Sofware-conversion of raw SPDIF packets (model 033 only).");
+MODULE_PARM_DESC(soft_ac3, "Software-conversion of raw SPDIF packets (model 033 only).");
 #ifdef SUPPORT_JOYSTICK
 module_param_array(joystick_port, int, NULL, 0444);
 MODULE_PARM_DESC(joystick_port, "Joystick port address.");
@@ -656,8 +656,8 @@ static int snd_cmipci_pll_rmn(unsigned int rate, unsigned int adcmult, int *r, i
 }
 
 /*
- * Program pll register bits, I assume that the 8 registers 0xf8 upto 0xff
- * are mapped onto the 8 ADC/DAC sampling frequency which can be choosen
+ * Program pll register bits, I assume that the 8 registers 0xf8 up to 0xff
+ * are mapped onto the 8 ADC/DAC sampling frequency which can be chosen
  * at the register CM_REG_FUNCTRL1 (0x04).
  * Problem: other ways are also possible (any information about that?)
  */
@@ -666,7 +666,7 @@ static void snd_cmipci_set_pll(struct cmipci *cm, unsigned int rate, unsigned in
 	unsigned int reg = CM_REG_PLL + slot;
 	/*
 	 * Guess that this programs at reg. 0x04 the pos 15:13/12:10
-	 * for DSFC/ASFC (000 upto 111).
+	 * for DSFC/ASFC (000 up to 111).
 	 */
 
 	/* FIXME: Init (Do we've to set an other register first before programming?) */

commit 60c4ce4a0c2ffbd37d6604f68fa4408ca7226157
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jan 10 16:28:19 2011 +0100

    ALSA: cmipci: use enum control info helper
    
    Simplify info callbacks by using the snd_ctl_enum_info() helper function.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 329968edca9b..b5bb036ef73c 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2507,14 +2507,12 @@ static int snd_cmipci_line_in_mode_info(struct snd_kcontrol *kcontrol,
 					struct snd_ctl_elem_info *uinfo)
 {
 	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
-	static char *texts[3] = { "Line-In", "Rear Output", "Bass Output" };
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = cm->chip_version >= 39 ? 3 : 2;
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
-	return 0;
+	static const char *const texts[3] = {
+		"Line-In", "Rear Output", "Bass Output"
+	};
+
+	return snd_ctl_enum_info(uinfo, 1,
+				 cm->chip_version >= 39 ? 3 : 2, texts);
 }
 
 static inline unsigned int get_line_in_mode(struct cmipci *cm)
@@ -2564,14 +2562,9 @@ static int snd_cmipci_line_in_mode_put(struct snd_kcontrol *kcontrol,
 static int snd_cmipci_mic_in_mode_info(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[2] = { "Mic-In", "Center/LFE Output" };
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 2;
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
-	return 0;
+	static const char *const texts[2] = { "Mic-In", "Center/LFE Output" };
+
+	return snd_ctl_enum_info(uinfo, 1, 2, texts);
 }
 
 static int snd_cmipci_mic_in_mode_get(struct snd_kcontrol *kcontrol,

commit 1c583063a5c769fe2ec604752e383972c69e6d9b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Mar 24 07:10:54 2010 +0100

    ALSA: cmipci: work around invalid PCM pointer
    
    When the CMI8738 FRAME2 register is read, the chip sometimes (probably
    when wrapping around) returns an invalid value that would be outside the
    programmed DMA buffer. This leads to an inconsistent PCM pointer that is
    likely to result in an underrun.
    
    To work around this, read the register multiple times until we get a
    valid value; the error state seems to be very short-lived.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Reported-and-tested-by: Matija Nalis <mnalis-alsadev@voyager.hr>
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 1ded64e05643..329968edca9b 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -941,13 +941,21 @@ static snd_pcm_uframes_t snd_cmipci_pcm_pointer(struct cmipci *cm, struct cmipci
 						struct snd_pcm_substream *substream)
 {
 	size_t ptr;
-	unsigned int reg;
+	unsigned int reg, rem, tries;
+
 	if (!rec->running)
 		return 0;
 #if 1 // this seems better..
 	reg = rec->ch ? CM_REG_CH1_FRAME2 : CM_REG_CH0_FRAME2;
-	ptr = rec->dma_size - (snd_cmipci_read_w(cm, reg) + 1);
-	ptr >>= rec->shift;
+	for (tries = 0; tries < 3; tries++) {
+		rem = snd_cmipci_read_w(cm, reg);
+		if (rem < rec->dma_size)
+			goto ok;
+	} 
+	printk(KERN_ERR "cmipci: invalid PCM pointer: %#x\n", rem);
+	return SNDRV_PCM_POS_XRUN;
+ok:
+	ptr = (rec->dma_size - (rem + 1)) >> rec->shift;
 #else
 	reg = rec->ch ? CM_REG_CH1_FRAME1 : CM_REG_CH0_FRAME1;
 	ptr = snd_cmipci_read(cm, reg) - rec->offset;

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index a312bae08f52..1ded64e05643 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2796,7 +2796,7 @@ static inline void snd_cmipci_proc_init(struct cmipci *cm) {}
 #endif
 
 
-static struct pci_device_id snd_cmipci_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_cmipci_ids) = {
 	{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338A), 0},
 	{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338B), 0},
 	{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738), 0},
@@ -3018,7 +3018,7 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 	int integrated_midi = 0;
 	char modelstr[16];
 	int pcm_index, pcm_spdif_index;
-	static struct pci_device_id intel_82437vx[] = {
+	static DEFINE_PCI_DEVICE_TABLE(intel_82437vx) = {
 		{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82437VX) },
 		{ },
 	};

commit d355c82a0191d5a3e971bd5af96cc81fe3ed25b9
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Tue Nov 3 15:47:25 2009 +0100

    ALSA: rename "PC Speaker" and "PC Beep" controls to "Beep"
    
    To avoid confusion in control names for the standard analog PC Beep generator
    using a small Internal PC Speaker, rename all related "PC Speaker" and "PC
    Beep" controls to "Beep" only. This name is more universal and can be also
    used on more platforms without confusion.
    
    Introduce also "Internal Speaker" in ControlNames.txt for systems with
    full-featured build-in internal speaker.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index ddcd4a9fd7e6..a312bae08f52 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2302,7 +2302,7 @@ static struct snd_kcontrol_new snd_cmipci_mixers[] __devinitdata = {
 	CMIPCI_SB_VOL_MONO("Mic Playback Volume", SB_DSP4_MIC_DEV, 3, 31),
 	CMIPCI_SB_SW_MONO("Mic Playback Switch", 0),
 	CMIPCI_DOUBLE("Mic Capture Switch", SB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT, 0, 0, 1, 0, 0),
-	CMIPCI_SB_VOL_MONO("PC Speaker Playback Volume", SB_DSP4_SPEAKER_DEV, 6, 3),
+	CMIPCI_SB_VOL_MONO("Beep Playback Volume", SB_DSP4_SPEAKER_DEV, 6, 3),
 	CMIPCI_MIXER_VOL_STEREO("Aux Playback Volume", CM_REG_AUX_VOL, 4, 0, 15),
 	CMIPCI_MIXER_SW_STEREO("Aux Playback Switch", CM_REG_MIXER2, CM_VAUXLM_SHIFT, CM_VAUXRM_SHIFT, 0),
 	CMIPCI_MIXER_SW_STEREO("Aux Capture Switch", CM_REG_MIXER2, CM_RAUXLEN_SHIFT, CM_RAUXREN_SHIFT, 0),
@@ -2310,7 +2310,7 @@ static struct snd_kcontrol_new snd_cmipci_mixers[] __devinitdata = {
 	CMIPCI_MIXER_VOL_MONO("Mic Capture Volume", CM_REG_MIXER2, CM_VADMIC_SHIFT, 7),
 	CMIPCI_SB_VOL_MONO("Phone Playback Volume", CM_REG_EXTENT_IND, 5, 7),
 	CMIPCI_DOUBLE("Phone Playback Switch", CM_REG_EXTENT_IND, CM_REG_EXTENT_IND, 4, 4, 1, 0, 0),
-	CMIPCI_DOUBLE("PC Speaker Playback Switch", CM_REG_EXTENT_IND, CM_REG_EXTENT_IND, 3, 3, 1, 0, 0),
+	CMIPCI_DOUBLE("Beep Playback Switch", CM_REG_EXTENT_IND, CM_REG_EXTENT_IND, 3, 3, 1, 0, 0),
 	CMIPCI_DOUBLE("Mic Boost Capture Switch", CM_REG_EXTENT_IND, CM_REG_EXTENT_IND, 0, 0, 1, 0, 0),
 };
 

commit 28d27aae9432c300857722a917be4065c6d7abff
Author: Joe Perches <joe@perches.com>
Date:   Wed Jun 24 22:13:35 2009 -0700

    sound: Use PCI_VDEVICE
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 449fe02f666e..ddcd4a9fd7e6 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2797,11 +2797,11 @@ static inline void snd_cmipci_proc_init(struct cmipci *cm) {}
 
 
 static struct pci_device_id snd_cmipci_ids[] = {
-	{PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_AL, PCI_DEVICE_ID_CMEDIA_CM8738, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338A), 0},
+	{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338B), 0},
+	{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738), 0},
+	{PCI_VDEVICE(CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738B), 0},
+	{PCI_VDEVICE(AL, PCI_DEVICE_ID_CMEDIA_CM8738), 0},
 	{0,},
 };
 

commit 395a434e39cb6dc6e1ff53bb43722b534a3c68d6
Author: Subrata Modak <subrata@linux.vnet.ibm.com>
Date:   Mon Apr 27 16:42:37 2009 +0530

    ALSA: Fix Trivial Warnining in sound/pci/cmipci.c
    
    Fixed the compile warning below by initializatin iomidi variable properly.
      sound/pci/cmipci.c: In function snd_cmipci_probe:
      sound/pci/cmipci.c:3017: warning: iomidi may be used uninitialized in this function
    
    Signed-off-by: Subrata Modak <subrata@linux.vnet.ibm.com>
    Cc: linux-pci <linux-pci@atrey.karlin.mff.cuni.cz>
    Cc: Balbir Singh <balbir@linux.vnet.ibm.com>
    Cc: Sachin P Sant <sachinp@linux.vnet.ibm.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index c7899c32aba1..449fe02f666e 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3014,7 +3014,7 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 		.dev_free =	snd_cmipci_dev_free,
 	};
 	unsigned int val;
-	long iomidi;
+	long iomidi = 0;
 	int integrated_midi = 0;
 	char modelstr[16];
 	int pcm_index, pcm_spdif_index;

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 1a74ca62c314..c7899c32aba1 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3272,9 +3272,9 @@ static int __devinit snd_cmipci_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
-	if (card == NULL)
-		return -ENOMEM;
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	if (err < 0)
+		return err;
 	
 	switch (pci->device) {
 	case PCI_DEVICE_ID_CMEDIA_CM8738:

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 9971b5b7735b..1a74ca62c314 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2357,7 +2357,8 @@ static int snd_cmipci_uswitch_get(struct snd_kcontrol *kcontrol,
 {
 	struct cmipci_switch_args *args;
 	args = (struct cmipci_switch_args *)kcontrol->private_value;
-	snd_assert(args != NULL, return -EINVAL);
+	if (snd_BUG_ON(!args))
+		return -EINVAL;
 	return _snd_cmipci_uswitch_get(kcontrol, ucontrol, args);
 }
 
@@ -2401,7 +2402,8 @@ static int snd_cmipci_uswitch_put(struct snd_kcontrol *kcontrol,
 {
 	struct cmipci_switch_args *args;
 	args = (struct cmipci_switch_args *)kcontrol->private_value;
-	snd_assert(args != NULL, return -EINVAL);
+	if (snd_BUG_ON(!args))
+		return -EINVAL;
 	return _snd_cmipci_uswitch_put(kcontrol, ucontrol, args);
 }
 
@@ -2662,7 +2664,8 @@ static int __devinit snd_cmipci_mixer_new(struct cmipci *cm, int pcm_spdif_devic
 	unsigned int idx;
 	int err;
 
-	snd_assert(cm != NULL && cm->card != NULL, return -EINVAL);
+	if (snd_BUG_ON(!cm || !cm->card))
+		return -EINVAL;
 
 	card = cm->card;
 

commit f000fd80937c0d94c67f9f3e7026f1fbc8ef8873
Author: Jeff Garzik <jgarzik@redhat.com>
Date:   Tue Apr 22 13:50:34 2008 +0200

    [ALSA] Fix synchronize_irq() bugs, redundancies
    
    free_irq() calls synchronize_irq() for you, so there is no need for
    drivers to manually do the same thing (again).  Thus, calls where
    sync-irq immediately precedes free-irq can be simplified.
    
    However, during this audit several bugs were noticed, where free-irq is
    preceded by a "irq >= 0" check... but the sync-irq call is not covered
    by the same check.
    
    So, where sync-irq could not be eliminated completely, the missing check
    was added.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 4074584a7d90..9971b5b7735b 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2933,8 +2933,6 @@ static int snd_cmipci_free(struct cmipci *cm)
 		/* reset mixer */
 		snd_cmipci_mixer_write(cm, 0, 0);
 
-		synchronize_irq(cm->irq);
-
 		free_irq(cm->irq, cm);
 	}
 

commit 7dfa31ed5e1fc0ace7f1959b9564ad43d78fd7af
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Feb 28 11:52:17 2008 +0100

    [ALSA] sound: cmipci.c fix shadowed variable warning
    
    A temporary variable for each mixer element is used in an initialization
    loop, use the name elem_id.
    
    sound/pci/cmipci.c:2747:26: warning: symbol 'id' shadows an earlier one
    sound/pci/cmipci.c:56:13: originally declared here
    
    [tiwai - fixed a coding style issue as well]
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 135f30860753..4074584a7d90 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2744,12 +2744,13 @@ static int __devinit snd_cmipci_mixer_new(struct cmipci *cm, int pcm_spdif_devic
 	}
 
 	for (idx = 0; idx < CM_SAVED_MIXERS; idx++) {
-		struct snd_ctl_elem_id id;
+		struct snd_ctl_elem_id elem_id;
 		struct snd_kcontrol *ctl;
-		memset(&id, 0, sizeof(id));
-		id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
-		strcpy(id.name, cm_saved_mixer[idx].name);
-		if ((ctl = snd_ctl_find_id(cm->card, &id)) != NULL)
+		memset(&elem_id, 0, sizeof(elem_id));
+		elem_id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+		strcpy(elem_id.name, cm_saved_mixer[idx].name);
+		ctl = snd_ctl_find_id(cm->card, &elem_id);
+		if (ctl)
 			cm->mixer_res_ctl[idx] = ctl;
 	}
 

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index bc0a1959f920..135f30860753 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -20,7 +20,6 @@
 /* Does not work. Warning may block system in capture mode */
 /* #define USE_VAR48KRATE */
 
-#include <sound/driver.h>
 #include <asm/io.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>

commit 25543fa785a32ce22e7374ba403eb6d38854d037
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Dec 11 08:55:16 2007 +0100

    [ALSA] cmipci: document 'Modem' control version check
    
    Add a comment that explains why the 'Modem' control doesn't work with
    newer chips.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 8cb3436d0d9c..bc0a1959f920 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2733,6 +2733,10 @@ static int __devinit snd_cmipci_mixer_new(struct cmipci *cm, int pcm_spdif_devic
 	}
 
 	/* card switches */
+	/*
+	 * newer chips don't have the register bits to force modem link
+	 * detection; the bit that was FLINKON now mutes CH1
+	 */
 	if (cm->chip_version < 39) {
 		err = snd_ctl_add(cm->card,
 				  snd_ctl_new1(&snd_cmipci_modem_switch, cm));

commit 69a07304d52cc1080fa650c4ba7a82eed3cd143c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Dec 10 12:28:52 2007 +0100

    [ALSA] cmipci: disable 'Modem' control on version 39 or newer chips
    
    On version 39 or newer chips, we better remove the 'Modem' control
    because this register bit now mutes the front channels of the
    multichannel stream.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 187203e55d39..8cb3436d0d9c 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2651,10 +2651,8 @@ static struct snd_kcontrol_new snd_cmipci_extra_mixer_switches[] __devinitdata =
 };
 
 /* card control switches */
-static struct snd_kcontrol_new snd_cmipci_control_switches[] __devinitdata = {
-	// DEFINE_CARD_SWITCH("Joystick", joystick), /* now module option */
-	DEFINE_CARD_SWITCH("Modem", modem),
-};
+static struct snd_kcontrol_new snd_cmipci_modem_switch __devinitdata =
+DEFINE_CARD_SWITCH("Modem", modem);
 
 
 static int __devinit snd_cmipci_mixer_new(struct cmipci *cm, int pcm_spdif_device)
@@ -2735,9 +2733,9 @@ static int __devinit snd_cmipci_mixer_new(struct cmipci *cm, int pcm_spdif_devic
 	}
 
 	/* card switches */
-	sw = snd_cmipci_control_switches;
-	for (idx = 0; idx < ARRAY_SIZE(snd_cmipci_control_switches); idx++, sw++) {
-		err = snd_ctl_add(cm->card, snd_ctl_new1(sw, cm));
+	if (cm->chip_version < 39) {
+		err = snd_ctl_add(cm->card,
+				  snd_ctl_new1(&snd_cmipci_modem_switch, cm));
 		if (err < 0)
 			return err;
 	}

commit b46be727286a93056db851ababc85c0ac3f2f91c
Author: Timofei Bondarenko <tim@ipi.ac.ru>
Date:   Wed Nov 7 15:50:52 2007 +0100

    [ALSA] cmipci - allow capture of raw spdif subframes
    
    Enable capturing of raw 32bit IEC958_SUBFRAME.
    The 24-bits PCM data can be obtained using iec958 plugin.
    Known problem: captured stream may begin with either left or right
    subframe. Since the iec958 plugin doesn't decode preamble it may swap
    the channels sometime.
    
    Signed-off-by: Timofei Bondarenko <tim@ipi.ac.ru>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index d1f23ebed2ae..187203e55d39 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1407,6 +1407,11 @@ static int snd_cmipci_capture_spdif_prepare(struct snd_pcm_substream *substream)
 		else
 			snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);
 	}
+	if (snd_pcm_format_width(substream->runtime->format) > 16)
+		snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);
+	else
+		snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);
+
 	spin_unlock_irq(&cm->reg_lock);
 
 	return snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_CAPT], substream);
@@ -1418,6 +1423,7 @@ static int snd_cmipci_capture_spdif_hw_free(struct snd_pcm_substream *subs)
 
 	spin_lock_irq(&cm->reg_lock);
 	snd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_CAPTURE_SPDF);
+	snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);
 	spin_unlock_irq(&cm->reg_lock);
 
 	return snd_cmipci_hw_free(subs);
@@ -1569,7 +1575,8 @@ static struct snd_pcm_hardware snd_cmipci_capture_spdif =
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
 				 SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),
-	.formats =	        SNDRV_PCM_FMTBIT_S16_LE,
+	.formats =	        SNDRV_PCM_FMTBIT_S16_LE |
+				SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE,
 	.rates =		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
 	.rate_min =		44100,
 	.rate_max =		48000,

commit feb77712b0e780f04507cdda0529088ff0f3286f
Author: Timofei Bondarenko <tim@ipi.ac.ru>
Date:   Wed Nov 7 15:49:57 2007 +0100

    [ALSA] cmipci - utilize ADC48K44K bit
    
    Setting the ADC48K44K greatly improves capture quality at 48k sampling rate.
    With this bit clear ADC does ZOH interpolation of every 22th sample at 48k.
    At frequencies higher than 48k there ADC performs a little better with
    ADC48K44K bit set.
    At 44.1k ADC performs a little better with this bit clear.
    At frequencies below 44.1k there is no difference.
    
    Signed-off-by: Timofei Bondarenko <tim@ipi.ac.ru>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 3a2d942f22bb..d1f23ebed2ae 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -869,6 +869,13 @@ static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
 	snd_cmipci_write(cm, CM_REG_CHFORMAT, val);
 	//snd_printd("cmipci: chformat = %08x\n", val);
 
+	if (!rec->is_dac && cm->chip_version) {
+		if (runtime->rate > 44100)
+			snd_cmipci_set_bit(cm, CM_REG_EXT_MISC, CM_ADC48K44K);
+		else
+			snd_cmipci_clear_bit(cm, CM_REG_EXT_MISC, CM_ADC48K44K);
+	}
+
 	rec->running = 0;
 	spin_unlock_irq(&cm->reg_lock);
 

commit 755c48abd8ec228a9e3c3bf9b36850ef5a12cc9c
Author: Timofei Bondarenko <tim@ipi.ac.ru>
Date:   Wed Oct 31 17:36:20 2007 +0100

    [ALSA] cmipci at 96kHz
    
    This patch adds support for 88.2k, 96k, and 128k samplerates
    on cmi8738-55 chip.
    Analog playback works fine on all channels.
    Analog capture works well too, though the extra samples seems
    interpolated by hardware.
    spdif playback and capture works fine.
    
    Signed-off-by: Timofei Bondarenko <tim@ipi.ac.ru>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 1fa5f004e858..3a2d942f22bb 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -150,6 +150,8 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_CH0_SRATE_176K	0x00000200
 #define CM_CH0_SRATE_96K	0x00000200	/* model 055? */
 #define CM_CH0_SRATE_88K	0x00000100
+#define CM_CH0_SRATE_128K	0x00000300
+#define CM_CH0_SRATE_MASK	0x00000300
 
 #define CM_SPDIF_INVERSE2	0x00000080	/* model 055? */
 #define CM_DBLSPDS		0x00000040	/* double SPDIF sample rate 88.2/96 */
@@ -473,6 +475,7 @@ struct cmipci {
 	unsigned int can_ac3_sw: 1;
 	unsigned int can_ac3_hw: 1;
 	unsigned int can_multi_ch: 1;
+	unsigned int can_96k: 1;	/* samplerate above 48k */
 	unsigned int do_soft_ac3: 1;
 
 	unsigned int spdif_playback_avail: 1;	/* spdif ready? */
@@ -603,8 +606,6 @@ static unsigned int snd_cmipci_rate_freq(unsigned int rate)
 {
 	unsigned int i;
 
-	if (rate > 48000)
-		rate /= 2;
 	for (i = 0; i < ARRAY_SIZE(rates); i++) {
 		if (rates[i] == rate)
 			return i;
@@ -782,7 +783,7 @@ static int set_dac_channels(struct cmipci *cm, struct cmipci_pcm *rec, int chann
 static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
 				 struct snd_pcm_substream *substream)
 {
-	unsigned int reg, freq, val;
+	unsigned int reg, freq, freq_ext, val;
 	unsigned int period_size;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
@@ -830,7 +831,17 @@ static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
 	//snd_printd("cmipci: functrl0 = %08x\n", cm->ctrl);
 
 	/* set sample rate */
-	freq = snd_cmipci_rate_freq(runtime->rate);
+	freq = 0;
+	freq_ext = 0;
+	if (runtime->rate > 48000)
+		switch (runtime->rate) {
+		case 88200:  freq_ext = CM_CH0_SRATE_88K; break;
+		case 96000:  freq_ext = CM_CH0_SRATE_96K; break;
+		case 128000: freq_ext = CM_CH0_SRATE_128K; break;
+		default:     snd_BUG(); break;
+		}
+	else
+		freq = snd_cmipci_rate_freq(runtime->rate);
 	val = snd_cmipci_read(cm, CM_REG_FUNCTRL1);
 	if (rec->ch) {
 		val &= ~CM_DSFC_MASK;
@@ -851,15 +862,9 @@ static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
 		val &= ~CM_CH0FMT_MASK;
 		val |= rec->fmt << CM_CH0FMT_SHIFT;
 	}
-	if (cm->chip_version == 68) {
-		if (runtime->rate == 88200)
-			val |= CM_CH0_SRATE_88K << (rec->ch * 2);
-		else
-			val &= ~(CM_CH0_SRATE_88K << (rec->ch * 2));
-		if (runtime->rate == 96000)
-			val |= CM_CH0_SRATE_96K << (rec->ch * 2);
-		else
-			val &= ~(CM_CH0_SRATE_96K << (rec->ch * 2));
+	if (cm->can_96k) {
+		val &= ~(CM_CH0_SRATE_MASK << (rec->ch * 2));
+		val |= freq_ext << (rec->ch * 2);
 	}
 	snd_cmipci_write(cm, CM_REG_CHFORMAT, val);
 	//snd_printd("cmipci: chformat = %08x\n", val);
@@ -1280,7 +1285,7 @@ static int snd_cmipci_playback_prepare(struct snd_pcm_substream *substream)
 	int rate = substream->runtime->rate;
 	int err, do_spdif, do_ac3 = 0;
 
-	do_spdif = (rate >= 44100 &&
+	do_spdif = (rate >= 44100 && rate <= 96000 &&
 		    substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE &&
 		    substream->runtime->channels == 2);
 	if (do_spdif && cm->can_ac3_hw) 
@@ -1336,10 +1341,8 @@ static void snd_cmipci_silence_hack(struct cmipci *cm, struct cmipci_pcm *rec)
 		val = snd_cmipci_read(cm, CM_REG_CHFORMAT);
 		val &= ~(CM_CH0FMT_MASK << (rec->ch * 2));
 		val |= (3 << CM_CH0FMT_SHIFT) << (rec->ch * 2);
-		if (cm->chip_version == 68) {
-			val &= ~(CM_CH0_SRATE_88K << (rec->ch * 2));
-			val &= ~(CM_CH0_SRATE_96K << (rec->ch * 2));
-		}
+		if (cm->can_96k)
+			val &= ~(CM_CH0_SRATE_MASK << (rec->ch * 2));
 		snd_cmipci_write(cm, CM_REG_CHFORMAT, val);
 	
 		/* start stream (we don't need interrupts) */
@@ -1391,6 +1394,12 @@ static int snd_cmipci_capture_spdif_prepare(struct snd_pcm_substream *substream)
 
 	spin_lock_irq(&cm->reg_lock);
 	snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_CAPTURE_SPDF);
+	if (cm->can_96k) {
+		if (substream->runtime->rate > 48000)
+			snd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);
+		else
+			snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);
+	}
 	spin_unlock_irq(&cm->reg_lock);
 
 	return snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_CAPT], substream);
@@ -1567,6 +1576,14 @@ static struct snd_pcm_hardware snd_cmipci_capture_spdif =
 	.fifo_size =		0,
 };
 
+static unsigned int rate_constraints[] = { 5512, 8000, 11025, 16000, 22050,
+			32000, 44100, 48000, 88200, 96000, 128000 };
+static struct snd_pcm_hw_constraint_list hw_constraints_rates = {
+		.count = ARRAY_SIZE(rate_constraints),
+		.list = rate_constraints,
+		.mask = 0,
+};
+
 /*
  * check device open/close
  */
@@ -1636,6 +1653,13 @@ static int snd_cmipci_playback_open(struct snd_pcm_substream *substream)
 		runtime->hw.rates |= SNDRV_PCM_RATE_88200 |
 				     SNDRV_PCM_RATE_96000;
 		runtime->hw.rate_max = 96000;
+	} else if (cm->chip_version == 55) {
+		err = snd_pcm_hw_constraint_list(runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);
+		if (err < 0)
+			return err;
+		runtime->hw.rates |= SNDRV_PCM_RATE_KNOT;
+		runtime->hw.rate_max = 128000;
 	}
 	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);
 	cm->dig_pcm_status = cm->dig_status;
@@ -1654,6 +1678,13 @@ static int snd_cmipci_capture_open(struct snd_pcm_substream *substream)
 	if (cm->chip_version == 68) {	// 8768 only supports 44k/48k recording
 		runtime->hw.rate_min = 41000;
 		runtime->hw.rates = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000;
+	} else if (cm->chip_version == 55) {
+		err = snd_pcm_hw_constraint_list(runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);
+		if (err < 0)
+			return err;
+		runtime->hw.rates |= SNDRV_PCM_RATE_KNOT;
+		runtime->hw.rate_max = 128000;
 	}
 	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);
 	return 0;
@@ -1685,6 +1716,13 @@ static int snd_cmipci_playback2_open(struct snd_pcm_substream *substream)
 		runtime->hw.rates |= SNDRV_PCM_RATE_88200 |
 				     SNDRV_PCM_RATE_96000;
 		runtime->hw.rate_max = 96000;
+	} else if (cm->chip_version == 55) {
+		err = snd_pcm_hw_constraint_list(runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);
+		if (err < 0)
+			return err;
+		runtime->hw.rates |= SNDRV_PCM_RATE_KNOT;
+		runtime->hw.rate_max = 128000;
 	}
 	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);
 	return 0;
@@ -1704,7 +1742,7 @@ static int snd_cmipci_playback_spdif_open(struct snd_pcm_substream *substream)
 			runtime->hw.formats |= SNDRV_PCM_FMTBIT_S32_LE;
 			snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
 		}
-		if (cm->chip_version == 68) {
+		if (cm->can_96k) {
 			runtime->hw.rates |= SNDRV_PCM_RATE_88200 |
 					     SNDRV_PCM_RATE_96000;
 			runtime->hw.rate_max = 96000;
@@ -1726,6 +1764,11 @@ static int snd_cmipci_capture_spdif_open(struct snd_pcm_substream *substream)
 	if ((err = open_device_check(cm, CM_OPEN_SPDIF_CAPTURE, substream)) < 0) /* use channel B */
 		return err;
 	runtime->hw = snd_cmipci_capture_spdif;
+	if (cm->can_96k && !(cm->chip_version == 68)) {
+		runtime->hw.rates |= SNDRV_PCM_RATE_88200 |
+				     SNDRV_PCM_RATE_96000;
+		runtime->hw.rate_max = 96000;
+	}
 	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x40000);
 	return 0;
 }
@@ -2785,9 +2828,11 @@ static void __devinit query_chip(struct cmipci *cm)
 		} else if (detect & CM_CHIP_8768) {
 			cm->chip_version = 68;
 			cm->max_channels = 8;
+			cm->can_96k = 1;
 		} else {
 			cm->chip_version = 55;
 			cm->max_channels = 6;
+			cm->can_96k = 1;
 		}
 		cm->can_ac3_hw = 1;
 		cm->can_multi_ch = 1;

commit 56c36ca3b2df3ad8f2a3b7d3fba3670695163aaa
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Oct 30 08:59:14 2007 +0100

    [ALSA] cmipci: fix FLINKON/OFF bits
    
    Fix the definitions of the CM_FLINKON/CM_FLINKOFF register bits that
    were garbled in the last 'update register definitions' patch.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 6832649879ce..1fa5f004e858 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -246,10 +246,9 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_MMODE_MASK		0x00000E00	/* model DAA interface mode */
 #define CM_SPDIF_SELECT2	0x00000100	/* for model > 039 ? */
 #define CM_ENCENTER		0x00000080
-#define CM_FLINKON		0x00000080	/* force modem link detection on, model 037 */
+#define CM_FLINKON		0x00000040	/* force modem link detection on, model 037 */
 #define CM_MUTECH1		0x00000040	/* mute PCI ch1 to DAC */
-#define CM_FLINKOFF		0x00000040	/* force modem link detection off, model 037 */
-#define CM_UNKNOWN_18_5		0x00000020	/* ? */
+#define CM_FLINKOFF		0x00000020	/* force modem link detection off, model 037 */
 #define CM_MIDSMP		0x00000010	/* 1/2 interpolation at front end DAC */
 #define CM_UPDDMA_MASK		0x0000000C	/* TDMA position update notification */
 #define CM_UPDDMA_2048		0x00000000

commit c36fd8c3cd682fa9bbe5b2cb4b99e16625a37c94
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 17 09:41:36 2007 +0200

    [ALSA] cmipci: fix distortion on rear channels
    
    When playing multichannel data, the rear channels can get distorted if
    the last sample of the last played stereo stream was not zero.  To avoid
    this, add a hack to play a few silence samples after the stream is
    stopped.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 085a36751ac0..6832649879ce 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -434,6 +434,7 @@ struct cmipci_pcm {
 	u8 running;		/* dac/adc running? */
 	u8 fmt;			/* format bits */
 	u8 is_dac;
+	u8 needs_silencing;
 	unsigned int dma_size;	/* in frames */
 	unsigned int shift;
 	unsigned int ch;	/* channel (0/1) */
@@ -903,6 +904,7 @@ static int snd_cmipci_pcm_trigger(struct cmipci *cm, struct cmipci_pcm *rec,
 		cm->ctrl &= ~chen;
 		snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl | reset);
 		snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl & ~reset);
+		rec->needs_silencing = rec->is_dac;
 		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
@@ -1304,11 +1306,75 @@ static int snd_cmipci_playback_spdif_prepare(struct snd_pcm_substream *substream
 	return snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_PLAY], substream);
 }
 
+/*
+ * Apparently, the samples last played on channel A stay in some buffer, even
+ * after the channel is reset, and get added to the data for the rear DACs when
+ * playing a multichannel stream on channel B.  This is likely to generate
+ * wraparounds and thus distortions.
+ * To avoid this, we play at least one zero sample after the actual stream has
+ * stopped.
+ */
+static void snd_cmipci_silence_hack(struct cmipci *cm, struct cmipci_pcm *rec)
+{
+	struct snd_pcm_runtime *runtime = rec->substream->runtime;
+	unsigned int reg, val;
+
+	if (rec->needs_silencing && runtime && runtime->dma_area) {
+		/* set up a small silence buffer */
+		memset(runtime->dma_area, 0, PAGE_SIZE);
+		reg = rec->ch ? CM_REG_CH1_FRAME2 : CM_REG_CH0_FRAME2;
+		val = ((PAGE_SIZE / 4) - 1) | (((PAGE_SIZE / 4) / 2 - 1) << 16);
+		snd_cmipci_write(cm, reg, val);
+	
+		/* configure for 16 bits, 2 channels, 8 kHz */
+		if (runtime->channels > 2)
+			set_dac_channels(cm, rec, 2);
+		spin_lock_irq(&cm->reg_lock);
+		val = snd_cmipci_read(cm, CM_REG_FUNCTRL1);
+		val &= ~(CM_ASFC_MASK << (rec->ch * 3));
+		val |= (4 << CM_ASFC_SHIFT) << (rec->ch * 3);
+		snd_cmipci_write(cm, CM_REG_FUNCTRL1, val);
+		val = snd_cmipci_read(cm, CM_REG_CHFORMAT);
+		val &= ~(CM_CH0FMT_MASK << (rec->ch * 2));
+		val |= (3 << CM_CH0FMT_SHIFT) << (rec->ch * 2);
+		if (cm->chip_version == 68) {
+			val &= ~(CM_CH0_SRATE_88K << (rec->ch * 2));
+			val &= ~(CM_CH0_SRATE_96K << (rec->ch * 2));
+		}
+		snd_cmipci_write(cm, CM_REG_CHFORMAT, val);
+	
+		/* start stream (we don't need interrupts) */
+		cm->ctrl |= CM_CHEN0 << rec->ch;
+		snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);
+		spin_unlock_irq(&cm->reg_lock);
+
+		msleep(1);
+
+		/* stop and reset stream */
+		spin_lock_irq(&cm->reg_lock);
+		cm->ctrl &= ~(CM_CHEN0 << rec->ch);
+		val = CM_RST_CH0 << rec->ch;
+		snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl | val);
+		snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl & ~val);
+		spin_unlock_irq(&cm->reg_lock);
+
+		rec->needs_silencing = 0;
+	}
+}
+
 static int snd_cmipci_playback_hw_free(struct snd_pcm_substream *substream)
 {
 	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	setup_spdif_playback(cm, substream, 0, 0);
 	restore_mixer_state(cm);
+	snd_cmipci_silence_hack(cm, &cm->channel[0]);
+	return snd_cmipci_hw_free(substream);
+}
+
+static int snd_cmipci_playback2_hw_free(struct snd_pcm_substream *substream)
+{
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
+	snd_cmipci_silence_hack(cm, &cm->channel[1]);
 	return snd_cmipci_hw_free(substream);
 }
 
@@ -1736,7 +1802,7 @@ static struct snd_pcm_ops snd_cmipci_playback2_ops = {
 	.close =	snd_cmipci_playback2_close,
 	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_cmipci_playback2_hw_params,
-	.hw_free =	snd_cmipci_hw_free,
+	.hw_free =	snd_cmipci_playback2_hw_free,
 	.prepare =	snd_cmipci_capture_prepare,	/* channel B */
 	.trigger =	snd_cmipci_capture_trigger,	/* channel B */
 	.pointer =	snd_cmipci_capture_pointer,	/* channel B */

commit ebe9e289d870816b5d5dd6992a253f9a87f26cba
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 17 09:40:57 2007 +0200

    [ALSA] cmipci: clean up struct cmipci_pcm
    
    Remove some unused field from the struct cmipci_pcm, and change the type
    of some others to save some space.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 7cf4fc193419..085a36751ac0 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -431,15 +431,13 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 
 struct cmipci_pcm {
 	struct snd_pcm_substream *substream;
-	int running;		/* dac/adc running? */
+	u8 running;		/* dac/adc running? */
+	u8 fmt;			/* format bits */
+	u8 is_dac;
 	unsigned int dma_size;	/* in frames */
-	unsigned int period_size;	/* in frames */
+	unsigned int shift;
+	unsigned int ch;	/* channel (0/1) */
 	unsigned int offset;	/* physical address of the buffer */
-	unsigned int fmt;	/* format bits */
-	int ch;			/* channel (0/1) */
-	unsigned int is_dac;		/* is dac? */
-	int bytes_per_frame;
-	int shift;
 };
 
 /* mixer elements toggled/resumed during ac3 playback */
@@ -785,6 +783,7 @@ static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
 				 struct snd_pcm_substream *substream)
 {
 	unsigned int reg, freq, val;
+	unsigned int period_size;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	rec->fmt = 0;
@@ -804,11 +803,11 @@ static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
 	rec->offset = runtime->dma_addr;
 	/* buffer and period sizes in frame */
 	rec->dma_size = runtime->buffer_size << rec->shift;
-	rec->period_size = runtime->period_size << rec->shift;
+	period_size = runtime->period_size << rec->shift;
 	if (runtime->channels > 2) {
 		/* multi-channels */
 		rec->dma_size = (rec->dma_size * runtime->channels) / 2;
-		rec->period_size = (rec->period_size * runtime->channels) / 2;
+		period_size = (period_size * runtime->channels) / 2;
 	}
 
 	spin_lock_irq(&cm->reg_lock);
@@ -819,7 +818,7 @@ static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
 	/* program sample counts */
 	reg = rec->ch ? CM_REG_CH1_FRAME2 : CM_REG_CH0_FRAME2;
 	snd_cmipci_write_w(cm, reg, rec->dma_size - 1);
-	snd_cmipci_write_w(cm, reg + 2, rec->period_size - 1);
+	snd_cmipci_write_w(cm, reg + 2, period_size - 1);
 
 	/* set adc/dac flag */
 	val = rec->ch ? CM_CHADC1 : CM_CHADC0;
@@ -875,7 +874,7 @@ static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
  * PCM trigger/stop
  */
 static int snd_cmipci_pcm_trigger(struct cmipci *cm, struct cmipci_pcm *rec,
-				  struct snd_pcm_substream *substream, int cmd)
+				  int cmd)
 {
 	unsigned int inthld, chen, reset, pause;
 	int result = 0;
@@ -955,7 +954,7 @@ static int snd_cmipci_playback_trigger(struct snd_pcm_substream *substream,
 				       int cmd)
 {
 	struct cmipci *cm = snd_pcm_substream_chip(substream);
-	return snd_cmipci_pcm_trigger(cm, &cm->channel[CM_CH_PLAY], substream, cmd);
+	return snd_cmipci_pcm_trigger(cm, &cm->channel[CM_CH_PLAY], cmd);
 }
 
 static snd_pcm_uframes_t snd_cmipci_playback_pointer(struct snd_pcm_substream *substream)
@@ -974,7 +973,7 @@ static int snd_cmipci_capture_trigger(struct snd_pcm_substream *substream,
 				     int cmd)
 {
 	struct cmipci *cm = snd_pcm_substream_chip(substream);
-	return snd_cmipci_pcm_trigger(cm, &cm->channel[CM_CH_CAPT], substream, cmd);
+	return snd_cmipci_pcm_trigger(cm, &cm->channel[CM_CH_CAPT], cmd);
 }
 
 static snd_pcm_uframes_t snd_cmipci_capture_pointer(struct snd_pcm_substream *substream)

commit 0f28eca32b3064db29d4718156e692f4db75c7aa
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 17 09:40:24 2007 +0200

    [ALSA] cmipci: fix lookup of double rates
    
    When using one of the double sampling rates, use half the sample rate to
    look up in the rates[] table, otherwise we stumble over the BUG().
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index b4f74ae9c0b6..7cf4fc193419 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -604,6 +604,9 @@ static unsigned int rates[] = { 5512, 11025, 22050, 44100, 8000, 16000, 32000, 4
 static unsigned int snd_cmipci_rate_freq(unsigned int rate)
 {
 	unsigned int i;
+
+	if (rate > 48000)
+		rate /= 2;
 	for (i = 0; i < ARRAY_SIZE(rates); i++) {
 		if (rates[i] == rate)
 			return i;

commit 8ffbc01e2cb2e203df910468f236c7b4e7b36f25
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 17 09:39:51 2007 +0200

    [ALSA] cmipci: reorganize set_dac_channels()
    
    By reorganizing the code that sets the CHB3DxC bits we can not only
    simplify this code but also fix the bug where the CHB3D8C bit was not
    reset when playing a stereo stream after a 7.1 stream.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index c51ea0ef26f9..b4f74ae9c0b6 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -738,48 +738,37 @@ static struct snd_pcm_hw_constraint_list hw_constraints_channels_8 = {
 static int set_dac_channels(struct cmipci *cm, struct cmipci_pcm *rec, int channels)
 {
 	if (channels > 2) {
-		if (! cm->can_multi_ch)
+		if (!cm->can_multi_ch || !rec->ch)
 			return -EINVAL;
 		if (rec->fmt != 0x03) /* stereo 16bit only */
 			return -EINVAL;
+	}
 
+	if (cm->can_multi_ch) {
 		spin_lock_irq(&cm->reg_lock);
-		snd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_NXCHG);
-		snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);
-		if (channels > 4) {
-			snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_CHB3D);
-			snd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_CHB3D5C);
+		if (channels > 2) {
+			snd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_NXCHG);
+			snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);
 		} else {
-			snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_CHB3D5C);
-			snd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_CHB3D);
+			snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_NXCHG);
+			snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);
 		}
-		if (channels >= 6) {
+		if (channels == 8)
+			snd_cmipci_set_bit(cm, CM_REG_EXT_MISC, CM_CHB3D8C);
+		else
+			snd_cmipci_clear_bit(cm, CM_REG_EXT_MISC, CM_CHB3D8C);
+		if (channels == 6) {
+			snd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_CHB3D5C);
 			snd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_CHB3D6C);
-			snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_ENCENTER);
 		} else {
-			snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_CHB3D6C);
-			snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_ENCENTER);
-		}
-		if (cm->chip_version == 68) {
-			if (channels == 8) {
-				snd_cmipci_set_bit(cm, CM_REG_EXT_MISC, CM_CHB3D8C);
-			} else {
-				snd_cmipci_clear_bit(cm, CM_REG_EXT_MISC, CM_CHB3D8C);
-			}
-		}
-		spin_unlock_irq(&cm->reg_lock);
-
-	} else {
-		if (cm->can_multi_ch) {
-			spin_lock_irq(&cm->reg_lock);
-			snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_NXCHG);
-			snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_CHB3D);
 			snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_CHB3D5C);
 			snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_CHB3D6C);
-			snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_ENCENTER);
-			snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);
-			spin_unlock_irq(&cm->reg_lock);
 		}
+		if (channels == 4)
+			snd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_CHB3D);
+		else
+			snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_CHB3D);
+		spin_unlock_irq(&cm->reg_lock);
 	}
 	return 0;
 }

commit 35add1c295c634fdbb1072189286e4eab3fd64fa
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 17 09:39:10 2007 +0200

    [ALSA] cmipci: remove 5.0 format
    
    Disallow playback of five channels because the hardware does not support
    it (or nobody knows how to do it).
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 51ba704d4bc9..c51ea0ef26f9 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -718,19 +718,19 @@ static int snd_cmipci_hw_free(struct snd_pcm_substream *substream)
 /*
  */
 
-static unsigned int hw_channels[] = {1, 2, 4, 5, 6, 8};
+static unsigned int hw_channels[] = {1, 2, 4, 6, 8};
 static struct snd_pcm_hw_constraint_list hw_constraints_channels_4 = {
 	.count = 3,
 	.list = hw_channels,
 	.mask = 0,
 };
 static struct snd_pcm_hw_constraint_list hw_constraints_channels_6 = {
-	.count = 5,
+	.count = 4,
 	.list = hw_channels,
 	.mask = 0,
 };
 static struct snd_pcm_hw_constraint_list hw_constraints_channels_8 = {
-	.count = 6,
+	.count = 5,
 	.list = hw_channels,
 	.mask = 0,
 };

commit 22a22f5aacdbb73ca605d34df76201a2df0fe8ac
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 17 09:37:47 2007 +0200

    [ALSA] cmipci: allow 96 kHz playback on non-multichannel rear
    
    Move the code that enables 96 kHz out of the if() that checks for
    availability of both DMA channels so that it is enabled even when
    another stream is playing on the front channels.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index c33c1c778693..51ba704d4bc9 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1623,14 +1623,14 @@ static int snd_cmipci_playback2_open(struct snd_pcm_substream *substream)
 			else if (cm->max_channels == 8)
 				snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels_8);
 		}
-		if (cm->chip_version == 68) {
-			runtime->hw.rates |= SNDRV_PCM_RATE_88200 |
-					     SNDRV_PCM_RATE_96000;
-			runtime->hw.rate_max = 96000;
-		}
-		snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);
 	}
 	mutex_unlock(&cm->open_mutex);
+	if (cm->chip_version == 68) {
+		runtime->hw.rates |= SNDRV_PCM_RATE_88200 |
+				     SNDRV_PCM_RATE_96000;
+		runtime->hw.rate_max = 96000;
+	}
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);
 	return 0;
 }
 

commit 4ee72717188767b127b22f7a582762b71d448408
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 17 09:37:19 2007 +0200

    [ALSA] cmipci: initialize 0x90 registers
    
    Initialize the registers at 0x90 and 0x91 with some undocumented values.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 8c5c843099c6..c33c1c778693 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2986,6 +2986,10 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 #else
 	snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);
 #endif
+	if (cm->chip_version) {
+		snd_cmipci_write_b(cm, CM_REG_EXT_MISC, 0x20); /* magic */
+		snd_cmipci_write_b(cm, CM_REG_EXT_MISC + 1, 0x09); /* more magic */
+	}
 	/* Set Bus Master Request */
 	snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_BREQ);
 

commit 3042ef75203947920adc0ab7ae25bc62a1fec978
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 17 09:36:49 2007 +0200

    [ALSA] cmipci: reset the chip when initializing
    
    When the chip is initialized, reset it.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 12f33718e6d1..8c5c843099c6 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2971,6 +2971,8 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 #endif
 
 	/* initialize codec registers */
+	snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_RESET);
+	snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_RESET);
 	snd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);	/* disable ints */
 	snd_cmipci_ch_reset(cm, CM_CH_PLAY);
 	snd_cmipci_ch_reset(cm, CM_CH_CAPT);

commit 54d030cc400ef5565a90e71288c23c0a18299dba
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 17 09:36:16 2007 +0200

    [ALSA] cmipci: show more registers in proc file
    
    Show a dump of all registers in the 0x00-0x27 and 0x90-0x93 ranges in
    the 'cmipci' proc file.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 2d8d3331bb96..12f33718e6d1 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2652,19 +2652,18 @@ static void snd_cmipci_proc_read(struct snd_info_entry *entry,
 				 struct snd_info_buffer *buffer)
 {
 	struct cmipci *cm = entry->private_data;
-	int i;
+	int i, v;
 	
-	snd_iprintf(buffer, "%s\n\n", cm->card->longname);
-	for (i = 0; i < 0x40; i++) {
-		int v = inb(cm->iobase + i);
+	snd_iprintf(buffer, "%s\n", cm->card->longname);
+	for (i = 0; i < 0x94; i++) {
+		if (i == 0x28)
+			i = 0x90;
+		v = inb(cm->iobase + i);
 		if (i % 4 == 0)
-			snd_iprintf(buffer, "%02x: ", i);
-		snd_iprintf(buffer, "%02x", v);
-		if (i % 4 == 3)
-			snd_iprintf(buffer, "\n");
-		else
-			snd_iprintf(buffer, " ");
+			snd_iprintf(buffer, "\n%02x:", i);
+		snd_iprintf(buffer, " %02x", v);
 	}
+	snd_iprintf(buffer, "\n");
 }
 
 static void __devinit snd_cmipci_proc_init(struct cmipci *cm)

commit a839a33d85184b88735ca3d88c4f7123c5ebb6a1
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 17 09:35:46 2007 +0200

    [ALSA] cmipci: update register definitions
    
    Update comments for many register symbols, add some new register
    symbols, and rename a few ones.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 751ff00bfeca..2d8d3331bb96 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -95,30 +95,34 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_CHADC0		0x00000001	/* ch0, 0:playback, 1:record */
 
 #define CM_REG_FUNCTRL1		0x04
-#define CM_ASFC_MASK		0x0000E000	/* ADC sampling frequency */
-#define CM_ASFC_SHIFT		13
-#define CM_DSFC_MASK		0x00001C00	/* DAC sampling frequency */
-#define CM_DSFC_SHIFT		10
+#define CM_DSFC_MASK		0x0000E000	/* channel 1 (DAC?) sampling frequency */
+#define CM_DSFC_SHIFT		13
+#define CM_ASFC_MASK		0x00001C00	/* channel 0 (ADC?) sampling frequency */
+#define CM_ASFC_SHIFT		10
 #define CM_SPDF_1		0x00000200	/* SPDIF IN/OUT at channel B */
 #define CM_SPDF_0		0x00000100	/* SPDIF OUT only channel A */
-#define CM_SPDFLOOP		0x00000080	/* ext. SPDIIF/OUT -> IN loopback */
+#define CM_SPDFLOOP		0x00000080	/* ext. SPDIIF/IN -> OUT loopback */
 #define CM_SPDO2DAC		0x00000040	/* SPDIF/OUT can be heard from internal DAC */
 #define CM_INTRM		0x00000020	/* master control block (MCB) interrupt enabled */
 #define CM_BREQ			0x00000010	/* bus master enabled */
 #define CM_VOICE_EN		0x00000008	/* legacy voice (SB16,FM) */
-#define CM_UART_EN		0x00000004	/* UART */
-#define CM_JYSTK_EN		0x00000002	/* joy stick */
+#define CM_UART_EN		0x00000004	/* legacy UART */
+#define CM_JYSTK_EN		0x00000002	/* legacy joystick */
+#define CM_ZVPORT		0x00000001	/* ZVPORT */
 
 #define CM_REG_CHFORMAT		0x08
 
 #define CM_CHB3D5C		0x80000000	/* 5,6 channels */
+#define CM_FMOFFSET2		0x40000000	/* initial FM PCM offset 2 when Fmute=1 */
 #define CM_CHB3D		0x20000000	/* 4 channels */
 
 #define CM_CHIP_MASK1		0x1f000000
 #define CM_CHIP_037		0x01000000
-
-#define CM_SPDIF_SELECT1	0x00080000	/* for model <= 037 ? */
+#define CM_SETLAT48		0x00800000	/* set latency timer 48h */
+#define CM_EDGEIRQ		0x00400000	/* emulated edge trigger legacy IRQ */
+#define CM_SPD24SEL39		0x00200000	/* 24-bit spdif: model 039 */
 #define CM_AC3EN1		0x00100000	/* enable AC3: model 037 */
+#define CM_SPDIF_SELECT1	0x00080000	/* for model <= 037 ? */
 #define CM_SPD24SEL		0x00020000	/* 24bit spdif: model 037 */
 /* #define CM_SPDIF_INVERSE	0x00010000 */ /* ??? */
 
@@ -128,12 +132,18 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_ADCBITLEN_14		0x00008000
 #define CM_ADCBITLEN_13		0x0000C000
 
-#define CM_ADCDACLEN_MASK	0x00003000
+#define CM_ADCDACLEN_MASK	0x00003000	/* model 037 */
 #define CM_ADCDACLEN_060	0x00000000
 #define CM_ADCDACLEN_066	0x00001000
 #define CM_ADCDACLEN_130	0x00002000
 #define CM_ADCDACLEN_280	0x00003000
 
+#define CM_ADCDLEN_MASK		0x00003000	/* model 039 */
+#define CM_ADCDLEN_ORIGINAL	0x00000000
+#define CM_ADCDLEN_EXTRA	0x00001000
+#define CM_ADCDLEN_24K		0x00002000
+#define CM_ADCDLEN_WEIGHT	0x00003000
+
 #define CM_CH1_SRATE_176K	0x00000800
 #define CM_CH1_SRATE_96K	0x00000800	/* model 055? */
 #define CM_CH1_SRATE_88K	0x00000400
@@ -142,24 +152,25 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_CH0_SRATE_88K	0x00000100
 
 #define CM_SPDIF_INVERSE2	0x00000080	/* model 055? */
-#define CM_DBLSPDS		0x00000040
+#define CM_DBLSPDS		0x00000040	/* double SPDIF sample rate 88.2/96 */
+#define CM_POLVALID		0x00000020	/* inverse SPDIF/IN valid bit */
+#define CM_SPDLOCKED		0x00000010
 
-#define CM_CH1FMT_MASK		0x0000000C
+#define CM_CH1FMT_MASK		0x0000000C	/* bit 3: 16 bits, bit 2: stereo */
 #define CM_CH1FMT_SHIFT		2
-#define CM_CH0FMT_MASK		0x00000003
+#define CM_CH0FMT_MASK		0x00000003	/* bit 1: 16 bits, bit 0: stereo */
 #define CM_CH0FMT_SHIFT		0
 
 #define CM_REG_INT_HLDCLR	0x0C
 #define CM_CHIP_MASK2		0xff000000
+#define CM_CHIP_8768		0x20000000
+#define CM_CHIP_055		0x08000000
 #define CM_CHIP_039		0x04000000
 #define CM_CHIP_039_6CH		0x01000000
-#define CM_CHIP_055		0x08000000
-#define CM_CHIP_8768		0x20000000
+#define CM_UNKNOWN_INT_EN	0x00080000	/* ? */
 #define CM_TDMA_INT_EN		0x00040000
 #define CM_CH1_INT_EN		0x00020000
 #define CM_CH0_INT_EN		0x00010000
-#define CM_INT_HOLD		0x00000002
-#define CM_INT_CLEAR		0x00000001
 
 #define CM_REG_INT_STATUS	0x10
 #define CM_INTR			0x80000000
@@ -178,12 +189,13 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_CHINT0		0x00000001
 
 #define CM_REG_LEGACY_CTRL	0x14
-#define CM_NXCHG		0x80000000	/* h/w multi channels? */
+#define CM_NXCHG		0x80000000	/* don't map base reg dword->sample */
 #define CM_VMPU_MASK		0x60000000	/* MPU401 i/o port address */
 #define CM_VMPU_330		0x00000000
 #define CM_VMPU_320		0x20000000
 #define CM_VMPU_310		0x40000000
 #define CM_VMPU_300		0x60000000
+#define CM_ENWR8237		0x10000000	/* enable bus master to write 8237 base reg */
 #define CM_VSBSEL_MASK		0x0C000000	/* SB16 base address */
 #define CM_VSBSEL_220		0x00000000
 #define CM_VSBSEL_240		0x04000000
@@ -194,44 +206,74 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_FMSEL_3C8		0x01000000
 #define CM_FMSEL_3E0		0x02000000
 #define CM_FMSEL_3E8		0x03000000
-#define CM_ENSPDOUT		0x00800000	/* enable XPDIF/OUT to I/O interface */
-#define CM_SPDCOPYRHT		0x00400000	/* set copyright spdif in/out */
+#define CM_ENSPDOUT		0x00800000	/* enable XSPDIF/OUT to I/O interface */
+#define CM_SPDCOPYRHT		0x00400000	/* spdif in/out copyright bit */
 #define CM_DAC2SPDO		0x00200000	/* enable wave+fm_midi -> SPDIF/OUT */
-#define CM_SETRETRY		0x00010000	/* 0: legacy i/o wait (default), 1: legacy i/o bus retry */
+#define CM_INVIDWEN		0x00100000	/* internal vendor ID write enable, model 039? */
+#define CM_SETRETRY		0x00100000	/* 0: legacy i/o wait (default), 1: legacy i/o bus retry */
+#define CM_C_EEACCESS		0x00080000	/* direct programming eeprom regs */
+#define CM_C_EECS		0x00040000
+#define CM_C_EEDI46		0x00020000
+#define CM_C_EECK46		0x00010000
 #define CM_CHB3D6C		0x00008000	/* 5.1 channels support */
-#define CM_LINE_AS_BASS		0x00006000	/* use line-in as bass */
+#define CM_CENTR2LIN		0x00004000	/* line-in as center out */
+#define CM_BASE2LIN		0x00002000	/* line-in as bass out */
+#define CM_EXBASEN		0x00001000	/* external bass input enable */
 
 #define CM_REG_MISC_CTRL	0x18
-#define CM_PWD			0x80000000
+#define CM_PWD			0x80000000	/* power down */
 #define CM_RESET		0x40000000
-#define CM_SFIL_MASK		0x30000000
-#define CM_TXVX			0x08000000
-#define CM_N4SPK3D		0x04000000	/* 4ch output */
+#define CM_SFIL_MASK		0x30000000	/* filter control at front end DAC, model 037? */
+#define CM_VMGAIN		0x10000000	/* analog master amp +6dB, model 039? */
+#define CM_TXVX			0x08000000	/* model 037? */
+#define CM_N4SPK3D		0x04000000	/* copy front to rear */
 #define CM_SPDO5V		0x02000000	/* 5V spdif output (1 = 0.5v (coax)) */
 #define CM_SPDIF48K		0x01000000	/* write */
 #define CM_SPATUS48K		0x01000000	/* read */
-#define CM_ENDBDAC		0x00800000	/* enable dual dac */
+#define CM_ENDBDAC		0x00800000	/* enable double dac */
 #define CM_XCHGDAC		0x00400000	/* 0: front=ch0, 1: front=ch1 */
 #define CM_SPD32SEL		0x00200000	/* 0: 16bit SPDIF, 1: 32bit */
-#define CM_SPDFLOOPI		0x00100000	/* int. SPDIF-IN -> int. OUT */
-#define CM_FM_EN		0x00080000	/* enalbe FM */
+#define CM_SPDFLOOPI		0x00100000	/* int. SPDIF-OUT -> int. IN */
+#define CM_FM_EN		0x00080000	/* enable legacy FM */
 #define CM_AC3EN2		0x00040000	/* enable AC3: model 039 */
-#define CM_VIDWPDSB		0x00010000 
+#define CM_ENWRASID		0x00010000	/* choose writable internal SUBID (audio) */
+#define CM_VIDWPDSB		0x00010000	/* model 037? */
 #define CM_SPDF_AC97		0x00008000	/* 0: SPDIF/OUT 44.1K, 1: 48K */
-#define CM_MASK_EN		0x00004000
-#define CM_VIDWPPRT		0x00002000
-#define CM_SFILENB		0x00001000
-#define CM_MMODE_MASK		0x00000E00
+#define CM_MASK_EN		0x00004000	/* activate channel mask on legacy DMA */
+#define CM_ENWRMSID		0x00002000	/* choose writable internal SUBID (modem) */
+#define CM_VIDWPPRT		0x00002000	/* model 037? */
+#define CM_SFILENB		0x00001000	/* filter stepping at front end DAC, model 037? */
+#define CM_MMODE_MASK		0x00000E00	/* model DAA interface mode */
 #define CM_SPDIF_SELECT2	0x00000100	/* for model > 039 ? */
 #define CM_ENCENTER		0x00000080
-#define CM_FLINKON		0x00000040
-#define CM_FLINKOFF		0x00000020
-#define CM_MIDSMP		0x00000010
-#define CM_UPDDMA_MASK		0x0000000C
-#define CM_TWAIT_MASK		0x00000003
+#define CM_FLINKON		0x00000080	/* force modem link detection on, model 037 */
+#define CM_MUTECH1		0x00000040	/* mute PCI ch1 to DAC */
+#define CM_FLINKOFF		0x00000040	/* force modem link detection off, model 037 */
+#define CM_UNKNOWN_18_5		0x00000020	/* ? */
+#define CM_MIDSMP		0x00000010	/* 1/2 interpolation at front end DAC */
+#define CM_UPDDMA_MASK		0x0000000C	/* TDMA position update notification */
+#define CM_UPDDMA_2048		0x00000000
+#define CM_UPDDMA_1024		0x00000004
+#define CM_UPDDMA_512		0x00000008
+#define CM_UPDDMA_256		0x0000000C		
+#define CM_TWAIT_MASK		0x00000003	/* model 037 */
+#define CM_TWAIT1		0x00000002	/* FM i/o cycle, 0: 48, 1: 64 PCICLKs */
+#define CM_TWAIT0		0x00000001	/* i/o cycle, 0: 4, 1: 6 PCICLKs */
+
+#define CM_REG_TDMA_POSITION	0x1C
+#define CM_TDMA_CNT_MASK	0xFFFF0000	/* current byte/word count */
+#define CM_TDMA_ADR_MASK	0x0000FFFF	/* current address */
 
 	/* byte */
 #define CM_REG_MIXER0		0x20
+#define CM_REG_SBVR		0x20		/* write: sb16 version */
+#define CM_REG_DEV		0x20		/* read: hardware device version */
+
+#define CM_REG_MIXER21		0x21
+#define CM_UNKNOWN_21_MASK	0x78		/* ? */
+#define CM_X_ADPCM		0x04		/* SB16 ADPCM enable */
+#define CM_PROINV		0x02		/* SBPro left/right channel switching */
+#define CM_X_SB16		0x01		/* SB16 compatible */
 
 #define CM_REG_SB16_DATA	0x22
 #define CM_REG_SB16_ADDR	0x23
@@ -246,8 +288,8 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_FMMUTE_SHIFT		7
 #define CM_WSMUTE		0x40	/* mute PCM */
 #define CM_WSMUTE_SHIFT		6
-#define CM_SPK4			0x20	/* lin-in -> rear line out */
-#define CM_SPK4_SHIFT		5
+#define CM_REAR2LIN		0x20	/* lin-in -> rear line out */
+#define CM_REAR2LIN_SHIFT	5
 #define CM_REAR2FRONT		0x10	/* exchange rear/front */
 #define CM_REAR2FRONT_SHIFT	4
 #define CM_WAVEINL		0x08	/* digital wave rec. left chan */
@@ -279,12 +321,13 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_VAUXR_MASK		0x0f
 
 #define CM_REG_MISC		0x27
+#define CM_UNKNOWN_27_MASK	0xd8	/* ? */
 #define CM_XGPO1		0x20
 // #define CM_XGPBIO		0x04
 #define CM_MIC_CENTER_LFE	0x04	/* mic as center/lfe out? (model 039 or later?) */
 #define CM_SPDIF_INVERSE	0x04	/* spdif input phase inverse (model 037) */
 #define CM_SPDVALID		0x02	/* spdif input valid check */
-#define CM_DMAUTO		0x01
+#define CM_DMAUTO		0x01	/* SB16 DMA auto detect */
 
 #define CM_REG_AC97		0x28	/* hmmm.. do we have ac97 link? */
 /*
@@ -325,18 +368,20 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 /*
  * extended registers
  */
-#define CM_REG_CH0_FRAME1	0x80	/* base address */
-#define CM_REG_CH0_FRAME2	0x84
+#define CM_REG_CH0_FRAME1	0x80	/* write: base address */
+#define CM_REG_CH0_FRAME2	0x84	/* read: current address */
 #define CM_REG_CH1_FRAME1	0x88	/* 0-15: count of samples at bus master; buffer size */
 #define CM_REG_CH1_FRAME2	0x8C	/* 16-31: count of samples at codec; fragment size */
+
 #define CM_REG_EXT_MISC		0x90
-#define CM_REG_MISC_CTRL_8768	0x92	/* reg. name the same as 0x18 */
-#define CM_CHB3D8C		0x20	/* 7.1 channels support */
-#define CM_SPD32FMT		0x10	/* SPDIF/IN 32k */
-#define CM_ADC2SPDIF		0x08	/* ADC output to SPDIF/OUT */
-#define CM_SHAREADC		0x04	/* DAC in ADC as Center/LFE */
-#define CM_REALTCMP		0x02	/* monitor the CMPL/CMPR of ADC */
-#define CM_INVLRCK		0x01	/* invert ZVPORT's LRCK */
+#define CM_ADC48K44K		0x10000000	/* ADC parameters group, 0: 44k, 1: 48k */
+#define CM_CHB3D8C		0x00200000	/* 7.1 channels support */
+#define CM_SPD32FMT		0x00100000	/* SPDIF/IN 32k sample rate */
+#define CM_ADC2SPDIF		0x00080000	/* ADC output to SPDIF/OUT */
+#define CM_SHAREADC		0x00040000	/* DAC in ADC as Center/LFE */
+#define CM_REALTCMP		0x00020000	/* monitor the CMPL/CMPR of ADC */
+#define CM_INVLRCK		0x00010000	/* invert ZVPORT's LRCK */
+#define CM_UNKNOWN_90_MASK	0x0000FFFF	/* ? */
 
 /*
  * size of i/o region
@@ -717,9 +762,9 @@ static int set_dac_channels(struct cmipci *cm, struct cmipci_pcm *rec, int chann
 		}
 		if (cm->chip_version == 68) {
 			if (channels == 8) {
-				snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL_8768, CM_CHB3D8C);
+				snd_cmipci_set_bit(cm, CM_REG_EXT_MISC, CM_CHB3D8C);
 			} else {
-				snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL_8768, CM_CHB3D8C);
+				snd_cmipci_clear_bit(cm, CM_REG_EXT_MISC, CM_CHB3D8C);
 			}
 		}
 		spin_unlock_irq(&cm->reg_lock);
@@ -797,11 +842,11 @@ static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
 	freq = snd_cmipci_rate_freq(runtime->rate);
 	val = snd_cmipci_read(cm, CM_REG_FUNCTRL1);
 	if (rec->ch) {
-		val &= ~CM_ASFC_MASK;
-		val |= (freq << CM_ASFC_SHIFT) & CM_ASFC_MASK;
-	} else {
 		val &= ~CM_DSFC_MASK;
 		val |= (freq << CM_DSFC_SHIFT) & CM_DSFC_MASK;
+	} else {
+		val &= ~CM_ASFC_MASK;
+		val |= (freq << CM_ASFC_SHIFT) & CM_ASFC_MASK;
 	}
 	snd_cmipci_write(cm, CM_REG_FUNCTRL1, val);
 	//snd_printd("cmipci: functrl1 = %08x\n", val);
@@ -2284,8 +2329,8 @@ DEFINE_SWITCH_ARG(exchange_dac, CM_REG_MISC_CTRL, CM_XCHGDAC, 0, 0, 0); /* rever
 DEFINE_SWITCH_ARG(exchange_dac, CM_REG_MISC_CTRL, CM_XCHGDAC, CM_XCHGDAC, 0, 0);
 #endif
 DEFINE_BIT_SWITCH_ARG(fourch, CM_REG_MISC_CTRL, CM_N4SPK3D, 0, 0);
-// DEFINE_BIT_SWITCH_ARG(line_rear, CM_REG_MIXER1, CM_SPK4, 1, 0);
-// DEFINE_BIT_SWITCH_ARG(line_bass, CM_REG_LEGACY_CTRL, CM_LINE_AS_BASS, 0, 0);
+// DEFINE_BIT_SWITCH_ARG(line_rear, CM_REG_MIXER1, CM_REAR2LIN, 1, 0);
+// DEFINE_BIT_SWITCH_ARG(line_bass, CM_REG_LEGACY_CTRL, CM_CENTR2LIN|CM_BASE2LIN, 0, 0);
 // DEFINE_BIT_SWITCH_ARG(joystick, CM_REG_FUNCTRL1, CM_JYSTK_EN, 0, 0); /* now module option */
 DEFINE_SWITCH_ARG(modem, CM_REG_MISC_CTRL, CM_FLINKON|CM_FLINKOFF, CM_FLINKON, 0, 0);
 
@@ -2355,11 +2400,11 @@ static inline unsigned int get_line_in_mode(struct cmipci *cm)
 	unsigned int val;
 	if (cm->chip_version >= 39) {
 		val = snd_cmipci_read(cm, CM_REG_LEGACY_CTRL);
-		if (val & CM_LINE_AS_BASS)
+		if (val & (CM_CENTR2LIN | CM_BASE2LIN))
 			return 2;
 	}
 	val = snd_cmipci_read_b(cm, CM_REG_MIXER1);
-	if (val & CM_SPK4)
+	if (val & CM_REAR2LIN)
 		return 1;
 	return 0;
 }
@@ -2383,13 +2428,13 @@ static int snd_cmipci_line_in_mode_put(struct snd_kcontrol *kcontrol,
 
 	spin_lock_irq(&cm->reg_lock);
 	if (ucontrol->value.enumerated.item[0] == 2)
-		change = snd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_LINE_AS_BASS);
+		change = snd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_CENTR2LIN | CM_BASE2LIN);
 	else
-		change = snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_LINE_AS_BASS);
+		change = snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_CENTR2LIN | CM_BASE2LIN);
 	if (ucontrol->value.enumerated.item[0] == 1)
-		change |= snd_cmipci_set_bit_b(cm, CM_REG_MIXER1, CM_SPK4);
+		change |= snd_cmipci_set_bit_b(cm, CM_REG_MIXER1, CM_REAR2LIN);
 	else
-		change |= snd_cmipci_clear_bit_b(cm, CM_REG_MIXER1, CM_SPK4);
+		change |= snd_cmipci_clear_bit_b(cm, CM_REG_MIXER1, CM_REAR2LIN);
 	spin_unlock_irq(&cm->reg_lock);
 	return change;
 }

commit 6935e68877a875137ea3fe7b690b0bec6504b7ff
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 17 09:34:59 2007 +0200

    [ALSA] cmipci: fix version 37 detection
    
    Use the proper value for the bit that identifies chip version 37.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 78a23984eac7..751ff00bfeca 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2665,7 +2665,7 @@ static void __devinit query_chip(struct cmipci *cm)
 			else
 				cm->can_ac3_hw = 1;
 			break;
-		case 1:
+		case CM_CHIP_037:
 			cm->chip_version = 37;
 			cm->can_ac3_hw = 1;
 			break;

commit 57bd68b8b18608cf2729f97fcb984b8521d19551
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Sep 7 10:44:13 2007 +0200

    [ALSA] cmipci: add msbits constraint for 24-bit format
    
    Add a msbits constraint to the SPDIF output device to indicate that
    S32_LE samples use only 24 bits for data.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index a8d6b54143fa..78a23984eac7 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1599,8 +1599,10 @@ static int snd_cmipci_playback_spdif_open(struct snd_pcm_substream *substream)
 		return err;
 	if (cm->can_ac3_hw) {
 		runtime->hw = snd_cmipci_playback_spdif;
-		if (cm->chip_version >= 37)
+		if (cm->chip_version >= 37) {
 			runtime->hw.formats |= SNDRV_PCM_FMTBIT_S32_LE;
+			snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
+		}
 		if (cm->chip_version == 68) {
 			runtime->hw.rates |= SNDRV_PCM_RATE_88200 |
 					     SNDRV_PCM_RATE_96000;

commit b7e054a76fdc42b442c003f8d19ee5dce6b55f02
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 3 09:56:45 2007 +0200

    [ALSA] cmipci: show real chip name in card name
    
    The '-MCx' suffix that is expected by alsa-lib is only needed in the
    card driver string, so we can show the actual chip name in the
    shortname.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 9149d00d1ad5..a8d6b54143fa 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2852,6 +2852,7 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 	unsigned int val;
 	long iomidi;
 	int integrated_midi = 0;
+	char modelstr[16];
 	int pcm_index, pcm_spdif_index;
 	static struct pci_device_id intel_82437vx[] = {
 		{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82437VX) },
@@ -2951,12 +2952,8 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 		break;
 	}
 
-	sprintf(card->shortname, "C-Media %s", card->driver);
 	if (cm->chip_version < 68) {
 		val = pci->device < 0x110 ? 8338 : 8738;
-		sprintf(card->longname,
-			"C-Media CMI%d (model %d) at 0x%lx, irq %i",
-			val, cm->chip_version, cm->iobase, cm->irq);
 	} else {
 		switch (snd_cmipci_read_b(cm, CM_REG_INT_HLDCLR + 3) & 0x03) {
 		case 0:
@@ -2981,9 +2978,14 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 				break;
 			}
 		}
-		sprintf(card->longname, "C-Media CMI%d at 0x%lx, irq %i",
-			val, cm->iobase, cm->irq);
 	}
+	sprintf(card->shortname, "C-Media CMI%d", val);
+	if (cm->chip_version < 68)
+		sprintf(modelstr, " (model %d)", cm->chip_version);
+	else
+		modelstr[0] = '\0';
+	sprintf(card->longname, "%s%s at %#lx, irq %i",
+		card->shortname, modelstr, cm->iobase, cm->irq);
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, cm, &ops)) < 0) {
 		snd_cmipci_free(cm);

commit 88039815d8868fb507eb69448f5a3a65c90b0bf2
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 3 09:56:23 2007 +0200

    [ALSA] cmipci: check that the legacy MIDI port works
    
    Check that the UART_EN bit actually enabled the MPU-401 port.
    Apparently, C-Media thinks that it is a good idea to be paranoid here.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index fdc4615ea0e7..9149d00d1ad5 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3012,6 +3012,13 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 			snd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val);
 			/* enable UART */
 			snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_UART_EN);
+			if (inb(iomidi + 1) == 0xff) {
+				snd_printk(KERN_ERR "cannot enable MPU-401 port"
+					   " at %#lx\n", iomidi);
+				snd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1,
+						     CM_UART_EN);
+				iomidi = 0;
+			}
 		}
 	}
 

commit c78c950d28df984e39ad028a90bcdadcd3eda3b6
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 3 09:55:49 2007 +0200

    [ALSA] cmipci: do not check for integrated FM/MIDI ports with chip version 37
    
    Integrated MPU-401/OPL3 ports are available with chip version 39 and
    later, so we do not test for the port with version 37.
    Now that the test is known to work, we can again enable the MIDI port by
    default.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index af266eb83059..fdc4615ea0e7 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2798,7 +2798,7 @@ static int __devinit snd_cmipci_create_fm(struct cmipci *cm, long fm_port)
 	if (!fm_port)
 		goto disable_fm;
 
-	if (cm->chip_version > 33) {
+	if (cm->chip_version >= 39) {
 		/* first try FM regs in PCI port range */
 		iosynth = cm->iobase + CM_REG_FM_PCI;
 		err = snd_opl3_create(cm->card, iosynth, iosynth + 2,
@@ -2990,8 +2990,7 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 		return err;
 	}
 
-	val = 0;
-	if (cm->chip_version > 33 && mpu_port[dev] == 1) {
+	if (cm->chip_version >= 39) {
 		val = snd_cmipci_read_b(cm, CM_REG_MPU_PCI + 1);
 		if (val != 0x00 && val != 0xff) {
 			iomidi = cm->iobase + CM_REG_MPU_PCI;
@@ -2999,6 +2998,7 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 		}
 	}
 	if (!integrated_midi) {
+		val = 0;
 		iomidi = mpu_port[dev];
 		switch (iomidi) {
 		case 0x320: val = CM_VMPU_320; break;

commit 8992e18db32f5df55fd4b458def7dccd2a5c3266
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 3 09:54:55 2007 +0200

    [ALSA] cmipci: add 96 kHz support
    
    Add support for 88.2 kHz and 96 kHz analog and digital playback on
    CMI8768/CMI8770 chips.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 6d3a0abadd75..af266eb83059 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -135,11 +135,14 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_ADCDACLEN_280	0x00003000
 
 #define CM_CH1_SRATE_176K	0x00000800
+#define CM_CH1_SRATE_96K	0x00000800	/* model 055? */
 #define CM_CH1_SRATE_88K	0x00000400
 #define CM_CH0_SRATE_176K	0x00000200
+#define CM_CH0_SRATE_96K	0x00000200	/* model 055? */
 #define CM_CH0_SRATE_88K	0x00000100
 
 #define CM_SPDIF_INVERSE2	0x00000080	/* model 055? */
+#define CM_DBLSPDS		0x00000040
 
 #define CM_CH1FMT_MASK		0x0000000C
 #define CM_CH1FMT_SHIFT		2
@@ -812,6 +815,16 @@ static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
 		val &= ~CM_CH0FMT_MASK;
 		val |= rec->fmt << CM_CH0FMT_SHIFT;
 	}
+	if (cm->chip_version == 68) {
+		if (runtime->rate == 88200)
+			val |= CM_CH0_SRATE_88K << (rec->ch * 2);
+		else
+			val &= ~(CM_CH0_SRATE_88K << (rec->ch * 2));
+		if (runtime->rate == 96000)
+			val |= CM_CH0_SRATE_96K << (rec->ch * 2);
+		else
+			val &= ~(CM_CH0_SRATE_96K << (rec->ch * 2));
+	}
 	snd_cmipci_write(cm, CM_REG_CHFORMAT, val);
 	//snd_printd("cmipci: chformat = %08x\n", val);
 
@@ -1198,15 +1211,19 @@ static int setup_spdif_playback(struct cmipci *cm, struct snd_pcm_substream *sub
 			snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_PLAYBACK_SPDF);
 		setup_ac3(cm, subs, do_ac3, rate);
 
-		if (rate == 48000)
+		if (rate == 48000 || rate == 96000)
 			snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPDIF48K | CM_SPDF_AC97);
 		else
 			snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPDIF48K | CM_SPDF_AC97);
-
+		if (rate > 48000)
+			snd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);
+		else
+			snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);
 	} else {
 		/* they are controlled via "IEC958 Output Switch" */
 		/* snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_ENSPDOUT); */
 		/* snd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_SPDO2DAC); */
+		snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);
 		snd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_PLAYBACK_SPDF);
 		setup_ac3(cm, subs, 0, 0);
 	}
@@ -1226,7 +1243,7 @@ static int snd_cmipci_playback_prepare(struct snd_pcm_substream *substream)
 	int rate = substream->runtime->rate;
 	int err, do_spdif, do_ac3 = 0;
 
-	do_spdif = ((rate == 44100 || rate == 48000) &&
+	do_spdif = (rate >= 44100 &&
 		    substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE &&
 		    substream->runtime->channels == 2);
 	if (do_spdif && cm->can_ac3_hw) 
@@ -1514,6 +1531,11 @@ static int snd_cmipci_playback_open(struct snd_pcm_substream *substream)
 	if ((err = open_device_check(cm, CM_OPEN_PLAYBACK, substream)) < 0)
 		return err;
 	runtime->hw = snd_cmipci_playback;
+	if (cm->chip_version == 68) {
+		runtime->hw.rates |= SNDRV_PCM_RATE_88200 |
+				     SNDRV_PCM_RATE_96000;
+		runtime->hw.rate_max = 96000;
+	}
 	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);
 	cm->dig_pcm_status = cm->dig_status;
 	return 0;
@@ -1556,6 +1578,11 @@ static int snd_cmipci_playback2_open(struct snd_pcm_substream *substream)
 			else if (cm->max_channels == 8)
 				snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels_8);
 		}
+		if (cm->chip_version == 68) {
+			runtime->hw.rates |= SNDRV_PCM_RATE_88200 |
+					     SNDRV_PCM_RATE_96000;
+			runtime->hw.rate_max = 96000;
+		}
 		snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);
 	}
 	mutex_unlock(&cm->open_mutex);
@@ -1574,6 +1601,11 @@ static int snd_cmipci_playback_spdif_open(struct snd_pcm_substream *substream)
 		runtime->hw = snd_cmipci_playback_spdif;
 		if (cm->chip_version >= 37)
 			runtime->hw.formats |= SNDRV_PCM_FMTBIT_S32_LE;
+		if (cm->chip_version == 68) {
+			runtime->hw.rates |= SNDRV_PCM_RATE_88200 |
+					     SNDRV_PCM_RATE_96000;
+			runtime->hw.rate_max = 96000;
+		}
 	} else {
 		runtime->hw = snd_cmipci_playback_iec958_subframe;
 	}

commit f19a82a119b41d4607b63e6fd0412498a87d30bc
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 3 09:54:27 2007 +0200

    [ALSA] cmipci: remove invalid channels constraint
    
    Remove the constraint that sets the channel limit for the first playback
    device to that of the second one; the first device supports only stereo.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 315ba26bbd88..6d3a0abadd75 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1514,7 +1514,6 @@ static int snd_cmipci_playback_open(struct snd_pcm_substream *substream)
 	if ((err = open_device_check(cm, CM_OPEN_PLAYBACK, substream)) < 0)
 		return err;
 	runtime->hw = snd_cmipci_playback;
-	runtime->hw.channels_max = cm->max_channels;
 	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);
 	cm->dig_pcm_status = cm->dig_status;
 	return 0;

commit d6426257d2c960399ff675b7807cde54b769e543
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 27 09:22:31 2007 +0200

    [ALSA] cmipci: show actual chip name in card longname
    
    Show the actual name of CMI8762/CMI8768/CMI8769/CMI8770 chips in the
    card longname instead of just using 'CMI8738' for all of them.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 42227012c0bd..315ba26bbd88 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2818,7 +2818,7 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 	static struct snd_device_ops ops = {
 		.dev_free =	snd_cmipci_dev_free,
 	};
-	unsigned int val = 0;
+	unsigned int val;
 	long iomidi;
 	int integrated_midi = 0;
 	int pcm_index, pcm_spdif_index;
@@ -2920,18 +2920,46 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 		break;
 	}
 
-	sprintf(card->shortname, "C-Media PCI %s", card->driver);
-	sprintf(card->longname, "%s (model %d) at 0x%lx, irq %i",
-		card->shortname,
-		cm->chip_version,
-		cm->iobase,
-		cm->irq);
+	sprintf(card->shortname, "C-Media %s", card->driver);
+	if (cm->chip_version < 68) {
+		val = pci->device < 0x110 ? 8338 : 8738;
+		sprintf(card->longname,
+			"C-Media CMI%d (model %d) at 0x%lx, irq %i",
+			val, cm->chip_version, cm->iobase, cm->irq);
+	} else {
+		switch (snd_cmipci_read_b(cm, CM_REG_INT_HLDCLR + 3) & 0x03) {
+		case 0:
+			val = 8769;
+			break;
+		case 2:
+			val = 8762;
+			break;
+		default:
+			switch ((pci->subsystem_vendor << 16) |
+				pci->subsystem_device) {
+			case 0x13f69761:
+			case 0x584d3741:
+			case 0x584d3751:
+			case 0x584d3761:
+			case 0x584d3771:
+			case 0x72848384:
+				val = 8770;
+				break;
+			default:
+				val = 8768;
+				break;
+			}
+		}
+		sprintf(card->longname, "C-Media CMI%d at 0x%lx, irq %i",
+			val, cm->iobase, cm->irq);
+	}
 
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, cm, &ops)) < 0) {
 		snd_cmipci_free(cm);
 		return err;
 	}
 
+	val = 0;
 	if (cm->chip_version > 33 && mpu_port[dev] == 1) {
 		val = snd_cmipci_read_b(cm, CM_REG_MPU_PCI + 1);
 		if (val != 0x00 && val != 0xff) {

commit b080ebbf92f8d98a048b100e0b0c4aa7e6354ab9
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 27 09:21:02 2007 +0200

    [ALSA] cmipci: remove has_dual_dac
    
    Remove the has_dual_dac variable because it was always set.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index cc0977a8a3d6..42227012c0bd 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -424,7 +424,6 @@ struct cmipci {
 
 	int chip_version;
 	int max_channels;
-	unsigned int has_dual_dac: 1;
 	unsigned int can_ac3_sw: 1;
 	unsigned int can_ac3_hw: 1;
 	unsigned int can_multi_ch: 1;
@@ -2643,7 +2642,6 @@ static void __devinit query_chip(struct cmipci *cm)
 			break;
 		}
 		cm->max_channels = 2;
-		cm->has_dual_dac = 1;
 	} else {
 		if (detect & CM_CHIP_039) {
 			cm->chip_version = 39;
@@ -2659,7 +2657,6 @@ static void __devinit query_chip(struct cmipci *cm)
 			cm->max_channels = 6;
 		}
 		cm->can_ac3_hw = 1;
-		cm->has_dual_dac = 1;
 		cm->can_multi_ch = 1;
 	}
 }
@@ -2975,11 +2972,9 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 	if ((err = snd_cmipci_pcm_new(cm, pcm_index)) < 0)
 		return err;
 	pcm_index++;
-	if (cm->has_dual_dac) {
-		if ((err = snd_cmipci_pcm2_new(cm, pcm_index)) < 0)
-			return err;
-		pcm_index++;
-	}
+	if ((err = snd_cmipci_pcm2_new(cm, pcm_index)) < 0)
+		return err;
+	pcm_index++;
 	if (cm->can_ac3_hw || cm->can_ac3_sw) {
 		pcm_spdif_index = pcm_index;
 		if ((err = snd_cmipci_pcm_spdif_new(cm, pcm_index)) < 0)

commit 133271fef52c06de52ea9a8ee27899f18dae9af2
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 27 09:20:31 2007 +0200

    [ALSA] cmipci: reorganize chip version detection
    
    Add a case for chip version 39 where no bit is set in register 0Ch, and
    move the detection of version 39 before that of 8768.  This makes the
    logic more compatible with the driver on that other OS.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 6021e5c402ea..cc0977a8a3d6 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2625,46 +2625,42 @@ static void __devinit query_chip(struct cmipci *cm)
 	if (! detect) {
 		/* check reg 08h, bit 24-28 */
 		detect = snd_cmipci_read(cm, CM_REG_CHFORMAT) & CM_CHIP_MASK1;
-		if (! detect) {
+		switch (detect) {
+		case 0:
 			cm->chip_version = 33;
-			cm->max_channels = 2;
 			if (cm->do_soft_ac3)
 				cm->can_ac3_sw = 1;
 			else
 				cm->can_ac3_hw = 1;
-			cm->has_dual_dac = 1;
-		} else {
+			break;
+		case 1:
 			cm->chip_version = 37;
-			cm->max_channels = 2;
 			cm->can_ac3_hw = 1;
-			cm->has_dual_dac = 1;
+			break;
+		default:
+			cm->chip_version = 39;
+			cm->can_ac3_hw = 1;
+			break;
 		}
+		cm->max_channels = 2;
+		cm->has_dual_dac = 1;
 	} else {
-		/* check reg 0Ch, bit 26 */
-		if (detect & CM_CHIP_8768) {
-			cm->chip_version = 68;
-			cm->max_channels = 8;
-			cm->can_ac3_hw = 1;
-			cm->has_dual_dac = 1;
-			cm->can_multi_ch = 1;
-		} else if (detect & CM_CHIP_055) {
-			cm->chip_version = 55;
-			cm->max_channels = 6;
-			cm->can_ac3_hw = 1;
-			cm->has_dual_dac = 1;
-			cm->can_multi_ch = 1;
-		} else if (detect & CM_CHIP_039) {
+		if (detect & CM_CHIP_039) {
 			cm->chip_version = 39;
 			if (detect & CM_CHIP_039_6CH) /* 4 or 6 channels */
 				cm->max_channels = 6;
 			else
 				cm->max_channels = 4;
-			cm->can_ac3_hw = 1;
-			cm->has_dual_dac = 1;
-			cm->can_multi_ch = 1;
+		} else if (detect & CM_CHIP_8768) {
+			cm->chip_version = 68;
+			cm->max_channels = 8;
 		} else {
-			printk(KERN_ERR "chip %x version not supported\n", detect);
+			cm->chip_version = 55;
+			cm->max_channels = 6;
 		}
+		cm->can_ac3_hw = 1;
+		cm->has_dual_dac = 1;
+		cm->can_multi_ch = 1;
 	}
 }
 

commit c9116ae45bd10eabe1e5cf88798092e184d8dbc2
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Aug 24 09:18:04 2007 +0200

    [ALSA] cmipci: make the test for integrated MIDI port address more robust
    
    Unused bytes in the I/O register range are likely to have the value 0x00
    instead of 0xff, so test against both values when checking for the
    presence of the integrated MIDI port.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 9d394c7c221d..6021e5c402ea 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2827,7 +2827,7 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 	};
 	unsigned int val = 0;
 	long iomidi;
-	int integrated_midi;
+	int integrated_midi = 0;
 	int pcm_index, pcm_spdif_index;
 	static struct pci_device_id intel_82437vx[] = {
 		{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82437VX) },
@@ -2939,11 +2939,14 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 		return err;
 	}
 
-	integrated_midi = cm->chip_version > 33 &&
-		snd_cmipci_read_b(cm, CM_REG_MPU_PCI + 1) != 0xff;
-	if (integrated_midi && mpu_port[dev] == 1)
-		iomidi = cm->iobase + CM_REG_MPU_PCI;
-	else {
+	if (cm->chip_version > 33 && mpu_port[dev] == 1) {
+		val = snd_cmipci_read_b(cm, CM_REG_MPU_PCI + 1);
+		if (val != 0x00 && val != 0xff) {
+			iomidi = cm->iobase + CM_REG_MPU_PCI;
+			integrated_midi = 1;
+		}
+	}
+	if (!integrated_midi) {
 		iomidi = mpu_port[dev];
 		switch (iomidi) {
 		case 0x320: val = CM_VMPU_320; break;

commit 45c41b4868c9dbec5d43a4023e77994afa94470f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Aug 22 09:45:03 2007 +0200

    [ALSA] cmipci: fix handling of FM/MIDI port addresses
    
    Make sure that the MPU-401 MIDI and OPL-3 FM devices are used only on
    those chips where they are supported, and that the correct port
    addresses are used.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index c42c51647df7..9d394c7c221d 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2774,10 +2774,14 @@ static int __devinit snd_cmipci_create_fm(struct cmipci *cm, long fm_port)
 	if (!fm_port)
 		goto disable_fm;
 
-	/* first try FM regs in PCI port range */
-	iosynth = cm->iobase + CM_REG_FM_PCI;
-	err = snd_opl3_create(cm->card, iosynth, iosynth + 2,
-			      OPL3_HW_OPL3, 1, &opl3);
+	if (cm->chip_version > 33) {
+		/* first try FM regs in PCI port range */
+		iosynth = cm->iobase + CM_REG_FM_PCI;
+		err = snd_opl3_create(cm->card, iosynth, iosynth + 2,
+				      OPL3_HW_OPL3, 1, &opl3);
+	} else {
+		err = -EIO;
+	}
 	if (err < 0) {
 		/* then try legacy ports */
 		val = snd_cmipci_read(cm, CM_REG_LEGACY_CTRL) & ~CM_FMSEL_MASK;
@@ -2935,7 +2939,8 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 		return err;
 	}
 
-	integrated_midi = snd_cmipci_read_b(cm, CM_REG_MPU_PCI) != 0xff;
+	integrated_midi = cm->chip_version > 33 &&
+		snd_cmipci_read_b(cm, CM_REG_MPU_PCI + 1) != 0xff;
 	if (integrated_midi && mpu_port[dev] == 1)
 		iomidi = cm->iobase + CM_REG_MPU_PCI;
 	else {
@@ -2955,8 +2960,11 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 		}
 	}
 
-	if ((err = snd_cmipci_create_fm(cm, fm_port[dev])) < 0)
-		return err;
+	if (cm->chip_version < 68) {
+		err = snd_cmipci_create_fm(cm, fm_port[dev]);
+		if (err < 0)
+			return err;
+	}
 
 	/* reset mixer */
 	snd_cmipci_mixer_write(cm, 0, 0);

commit 1e02d6ea85e5ca3a8c49a7e2ef1656bfba902fc9
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Aug 21 08:58:35 2007 +0200

    [ALSA] cmipci: fix MIDI device name
    
    Initialize card->shortname early enough so that the MIDI device can pick
    it up and does not need to have a generic name.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index f38054ead176..c42c51647df7 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2923,6 +2923,13 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 		break;
 	}
 
+	sprintf(card->shortname, "C-Media PCI %s", card->driver);
+	sprintf(card->longname, "%s (model %d) at 0x%lx, irq %i",
+		card->shortname,
+		cm->chip_version,
+		cm->iobase,
+		cm->irq);
+
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, cm, &ops)) < 0) {
 		snd_cmipci_free(cm);
 		return err;
@@ -3049,15 +3056,6 @@ static int __devinit snd_cmipci_probe(struct pci_dev *pci,
 	}
 	card->private_data = cm;
 
-	sprintf(card->shortname, "C-Media PCI %s", card->driver);
-	sprintf(card->longname, "%s (model %d) at 0x%lx, irq %i",
-		card->shortname,
-		cm->chip_version,
-		cm->iobase,
-		cm->irq);
-
-	//snd_printd("%s is detected\n", card->longname);
-
 	if ((err = snd_card_register(card)) < 0) {
 		snd_card_free(card);
 		return err;

commit a5ce88909d3007caa7b65996a8f6784350beb2a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 23 15:42:26 2007 +0200

    [ALSA] Clean up with common snd_ctl_boolean_*_info callbacks
    
    Clean up codes using the new common snd_ctl_boolean_*_info() callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 7d3c5ee0005c..f38054ead176 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2139,15 +2139,7 @@ struct cmipci_switch_args {
 					 */
 };
 
-static int snd_cmipci_uswitch_info(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_cmipci_uswitch_info		snd_ctl_boolean_mono_info
 
 static int _snd_cmipci_uswitch_get(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_value *ucontrol,

commit 2f24d159d5ac418c946e0d38ada46345753688b1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 15 18:56:43 2007 +0100

    [ALSA] cmipci - Allow to disable integrated FM port
    
    The driver didn't allow to disable the integrated FM port (if available),
    and this annoyed people who don't want FM port.  Now fm_port=0 disables
    the FM port unconditionally.  fm_port=1 is used for enabling the integrated
    FM port (as default).
    Also fixed the documentation about this option.
    Fix ALSA bug#2491.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 70face7e1048..7d3c5ee0005c 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -57,7 +57,7 @@ static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
 static long mpu_port[SNDRV_CARDS];
-static long fm_port[SNDRV_CARDS];
+static long fm_port[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)]=1};
 static int soft_ac3[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)]=1};
 #ifdef SUPPORT_JOYSTICK
 static int joystick_port[SNDRV_CARDS];
@@ -2779,6 +2779,9 @@ static int __devinit snd_cmipci_create_fm(struct cmipci *cm, long fm_port)
 	struct snd_opl3 *opl3;
 	int err;
 
+	if (!fm_port)
+		goto disable_fm;
+
 	/* first try FM regs in PCI port range */
 	iosynth = cm->iobase + CM_REG_FM_PCI;
 	err = snd_opl3_create(cm->card, iosynth, iosynth + 2,
@@ -2793,7 +2796,7 @@ static int __devinit snd_cmipci_create_fm(struct cmipci *cm, long fm_port)
 		case 0x3C8: val |= CM_FMSEL_3C8; break;
 		case 0x388: val |= CM_FMSEL_388; break;
 		default:
-			    return 0;
+			goto disable_fm;
 		}
 		snd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val);
 		/* enable FM */
@@ -2803,11 +2806,7 @@ static int __devinit snd_cmipci_create_fm(struct cmipci *cm, long fm_port)
 				    OPL3_HW_OPL3, 0, &opl3) < 0) {
 			printk(KERN_ERR "cmipci: no OPL device at %#lx, "
 			       "skipping...\n", iosynth);
-			/* disable FM */
-			snd_cmipci_write(cm, CM_REG_LEGACY_CTRL,
-					 val & ~CM_FMSEL_MASK);
-			snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);
-			return 0;
+			goto disable_fm;
 		}
 	}
 	if ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {
@@ -2815,6 +2814,11 @@ static int __devinit snd_cmipci_create_fm(struct cmipci *cm, long fm_port)
 		return err;
 	}
 	return 0;
+
+ disable_fm:
+	snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_FMSEL_MASK);
+	snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);
+	return 0;
 }
 
 static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,

commit 8c670714223d58086695d007b76b3e3ead54e4f5
Author: Timofei V. Bondarenko <tim@ipi.ac.ru>
Date:   Wed Dec 20 19:20:07 2006 +0100

    [ALSA] _snd_cmipci_uswitch_put doesn't set zero flags
    
    Playing with spdif output on cmipci i've noticed the SPDO5V option does
    not change appropriate bits the register.
    The _snd_cmipci_uswitch_put checks the change in flags in wrong way.
    If 'active' state of an option corresponds to a _zero_ bits in a hw
    register then function fails. The SPDO5V is the sample.
    In the most cases 'active' state of option is set through an non-zerio
    bits in a register. This case works fine.
    The fix attached.
    Unfortunately i was unable to change spdif output voltage anyway.
    Although the register changes right at least.
    From: Timofei V. Bondarenko <tim@ipi.ac.ru>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 71c58df4af28..70face7e1048 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2198,7 +2198,8 @@ static int _snd_cmipci_uswitch_put(struct snd_kcontrol *kcontrol,
 		val = inb(cm->iobase + args->reg);
 	else
 		val = snd_cmipci_read(cm, args->reg);
-	change = (val & args->mask) != (ucontrol->value.integer.value[0] ? args->mask : 0);
+	change = (val & args->mask) != (ucontrol->value.integer.value[0] ? 
+			args->mask_on : (args->mask & ~args->mask_on));
 	if (change) {
 		val &= ~args->mask;
 		if (ucontrol->value.integer.value[0])

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 0093cd1f92db..71c58df4af28 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2862,7 +2862,7 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 	cm->iobase = pci_resource_start(pci, 0);
 
 	if (request_irq(pci->irq, snd_cmipci_interrupt,
-			IRQF_DISABLED|IRQF_SHARED, card->driver, cm)) {
+			IRQF_SHARED, card->driver, cm)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_cmipci_free(cm);
 		return -EBUSY;

commit 30b35399ceb2398d05837863476dcb12f12f3a82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 11 18:52:53 2006 +0200

    [ALSA] Various fixes for suspend/resume of ALSA PCI drivers
    
    - Check the return value of pci_enable_device() and request_irq()
      in the suspend.  If any error occurs there, disable the device
      using snd_card_disconnect().
    - Call pci_set_power_state() properly with pci_choose_state().
    - Fix the order to call pci_set_power_state().
    - Removed obsolete house-made PM codes in some drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 1f7e71083069..0093cd1f92db 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3122,9 +3122,9 @@ static int snd_cmipci_suspend(struct pci_dev *pci, pm_message_t state)
 	/* disable ints */
 	snd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);
 
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -3134,9 +3134,14 @@ static int snd_cmipci_resume(struct pci_dev *pci)
 	struct cmipci *cm = card->private_data;
 	int i;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "cmipci: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	/* reset / initialize to a sane state */

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 876b64464b6f..1f7e71083069 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1294,7 +1294,7 @@ static int snd_cmipci_capture_spdif_hw_free(struct snd_pcm_substream *subs)
 /*
  * interrupt handler
  */
-static irqreturn_t snd_cmipci_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_cmipci_interrupt(int irq, void *dev_id)
 {
 	struct cmipci *cm = dev_id;
 	unsigned int status, mask = 0;
@@ -1315,7 +1315,7 @@ static irqreturn_t snd_cmipci_interrupt(int irq, void *dev_id, struct pt_regs *r
 	spin_unlock(&cm->reg_lock);
 
 	if (cm->rmidi && (status & CM_UARTINT))
-		snd_mpu401_uart_interrupt(irq, cm->rmidi->private_data, regs);
+		snd_mpu401_uart_interrupt(irq, cm->rmidi->private_data);
 
 	if (cm->pcm) {
 		if ((status & CM_CHINT0) && cm->channel[0].running)

commit f40b68903ccd511ea9d658b4bce319dd032a265a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 16:51:05 2006 +0200

    [ALSA] Fix section mismatch errors in ALSA PCI drivers
    
    Fixed 'section mismatch' errors in ALSA PCI drivers:
    - removed invalid __devinitdata from pci id tables
    - fix/remove __devinit of functions called in suspend/resume
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 03766ad74998..876b64464b6f 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2609,7 +2609,7 @@ static inline void snd_cmipci_proc_init(struct cmipci *cm) {}
 #endif
 
 
-static struct pci_device_id snd_cmipci_ids[] __devinitdata = {
+static struct pci_device_id snd_cmipci_ids[] = {
 	{PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 0938c158b5c9..03766ad74998 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2862,7 +2862,7 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 	cm->iobase = pci_resource_start(pci, 0);
 
 	if (request_irq(pci->irq, snd_cmipci_interrupt,
-			SA_INTERRUPT|SA_SHIRQ, card->driver, cm)) {
+			IRQF_DISABLED|IRQF_SHARED, card->driver, cm)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_cmipci_free(cm);
 		return -EBUSY;

commit f26eb78fcfb5b76fbe6d3e740b6fedda611f8395
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon May 29 19:05:28 2006 +0200

    [ALSA] cmipci - Fix a typo in 'PC Speaker Playback Switch' control
    
    Fixed a typo in  'PC Speaker Playback Switch' control name.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 79bc60a5204e..0938c158b5c9 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2121,7 +2121,7 @@ static struct snd_kcontrol_new snd_cmipci_mixers[] __devinitdata = {
 	CMIPCI_MIXER_VOL_MONO("Mic Capture Volume", CM_REG_MIXER2, CM_VADMIC_SHIFT, 7),
 	CMIPCI_SB_VOL_MONO("Phone Playback Volume", CM_REG_EXTENT_IND, 5, 7),
 	CMIPCI_DOUBLE("Phone Playback Switch", CM_REG_EXTENT_IND, CM_REG_EXTENT_IND, 4, 4, 1, 0, 0),
-	CMIPCI_DOUBLE("PC Speaker Playnack Switch", CM_REG_EXTENT_IND, CM_REG_EXTENT_IND, 3, 3, 1, 0, 0),
+	CMIPCI_DOUBLE("PC Speaker Playback Switch", CM_REG_EXTENT_IND, CM_REG_EXTENT_IND, 3, 3, 1, 0, 0),
 	CMIPCI_DOUBLE("Mic Boost Capture Switch", CM_REG_EXTENT_IND, CM_REG_EXTENT_IND, 0, 0, 1, 0, 0),
 };
 

commit 302e4c2f9e2b9f07c69649782330a61c60001ac4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 23 13:24:30 2006 +0200

    [ALSA] Change an arugment of snd_mpu401_uart_new() to bit flags
    
    Change the 5th argument of snd_mpu401_uart_new() to bit flags
    instead of a boolean.  The argument takes bits that consist of
    MPU401_INFO_XXX flags.
    The callers that used the value 1 there are replaced with
    MPU401_INFO_INTEGRATED.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index cb475ada2ef1..79bc60a5204e 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2981,7 +2981,9 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 
 	if (iomidi > 0) {
 		if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_CMIPCI,
-					       iomidi, integrated_midi,
+					       iomidi,
+					       (integrated_midi ?
+						MPU401_INFO_INTEGRATED : 0),
 					       cm->irq, 0, &cm->rmidi)) < 0) {
 			printk(KERN_ERR "cmipci: no UART401 device at 0x%lx\n", iomidi);
 		}

commit cab5c4c97a98e46359faa52e86787c1f0ccd773c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu May 4 14:36:08 2006 +0200

    [ALSA] cmipci - Disable integrated mpu401 as default
    
    Enable the support of mpu401 PCI port only when mpu_port=1 module
    option is given, i.e. disabled as default.
    It turned out that the check of integrated midi port isn't perfect
    and caused hang-ups on some boards.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 42ca92be18f9..cb475ada2ef1 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2932,7 +2932,7 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 	}
 
 	integrated_midi = snd_cmipci_read_b(cm, CM_REG_MPU_PCI) != 0xff;
-	if (integrated_midi)
+	if (integrated_midi && mpu_port[dev] == 1)
 		iomidi = cm->iobase + CM_REG_MPU_PCI;
 	else {
 		iomidi = mpu_port[dev];

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index e5ce2dabd081..42ca92be18f9 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2602,7 +2602,7 @@ static void __devinit snd_cmipci_proc_init(struct cmipci *cm)
 	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(cm->card, "cmipci", &entry))
-		snd_info_set_text_ops(entry, cm, 1024, snd_cmipci_proc_read);
+		snd_info_set_text_ops(entry, cm, snd_cmipci_proc_read);
 }
 #else /* !CONFIG_PROC_FS */
 static inline void snd_cmipci_proc_init(struct cmipci *cm) {}

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 2ecbddbbdcf0..e5ce2dabd081 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2609,7 +2609,7 @@ static inline void snd_cmipci_proc_init(struct cmipci *cm) {}
 #endif
 
 
-static struct pci_device_id snd_cmipci_ids[] = {
+static struct pci_device_id snd_cmipci_ids[] __devinitdata = {
 	{PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},

commit 62932df8fb20ba2fb53a95fa52445eba22e821fe
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:34:20 2006 +0100

    [ALSA] semaphore -> mutex (PCI part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index c03b0a0a3b27..2ecbddbbdcf0 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -29,6 +29,7 @@
 #include <linux/slab.h>
 #include <linux/gameport.h>
 #include <linux/moduleparam.h>
+#include <linux/mutex.h>
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
@@ -439,7 +440,7 @@ struct cmipci {
 	struct snd_pcm_hardware *hw_info[3]; /* for playbacks */
 
 	int opened[2];	/* open mode */
-	struct semaphore open_mutex;
+	struct mutex open_mutex;
 
 	unsigned int mixer_insensitive: 1;
 	struct snd_kcontrol *mixer_res_ctl[CM_SAVED_MIXERS];
@@ -641,14 +642,14 @@ static int snd_cmipci_playback2_hw_params(struct snd_pcm_substream *substream,
 {
 	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	if (params_channels(hw_params) > 2) {
-		down(&cm->open_mutex);
+		mutex_lock(&cm->open_mutex);
 		if (cm->opened[CM_CH_PLAY]) {
-			up(&cm->open_mutex);
+			mutex_unlock(&cm->open_mutex);
 			return -EBUSY;
 		}
 		/* reserve the channel A */
 		cm->opened[CM_CH_PLAY] = CM_OPEN_PLAYBACK_MULTI;
-		up(&cm->open_mutex);
+		mutex_unlock(&cm->open_mutex);
 	}
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 }
@@ -1461,9 +1462,9 @@ static int open_device_check(struct cmipci *cm, int mode, struct snd_pcm_substre
 	 * pcm framework doesn't pass file pointer before actually opened,
 	 * we can't know whether blocking mode or not in open callback..
 	 */
-	down(&cm->open_mutex);
+	mutex_lock(&cm->open_mutex);
 	if (cm->opened[ch]) {
-		up(&cm->open_mutex);
+		mutex_unlock(&cm->open_mutex);
 		return -EBUSY;
 	}
 	cm->opened[ch] = mode;
@@ -1475,7 +1476,7 @@ static int open_device_check(struct cmipci *cm, int mode, struct snd_pcm_substre
 		snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_ENDBDAC);
 		spin_unlock_irq(&cm->reg_lock);
 	}
-	up(&cm->open_mutex);
+	mutex_unlock(&cm->open_mutex);
 	return 0;
 }
 
@@ -1483,7 +1484,7 @@ static void close_device_check(struct cmipci *cm, int mode)
 {
 	int ch = mode & CM_OPEN_CH_MASK;
 
-	down(&cm->open_mutex);
+	mutex_lock(&cm->open_mutex);
 	if (cm->opened[ch] == mode) {
 		if (cm->channel[ch].substream) {
 			snd_cmipci_ch_reset(cm, ch);
@@ -1499,7 +1500,7 @@ static void close_device_check(struct cmipci *cm, int mode)
 			spin_unlock_irq(&cm->reg_lock);
 		}
 	}
-	up(&cm->open_mutex);
+	mutex_unlock(&cm->open_mutex);
 }
 
 /*
@@ -1546,7 +1547,7 @@ static int snd_cmipci_playback2_open(struct snd_pcm_substream *substream)
 	if ((err = open_device_check(cm, CM_OPEN_PLAYBACK2, substream)) < 0) /* use channel B */
 		return err;
 	runtime->hw = snd_cmipci_playback2;
-	down(&cm->open_mutex);
+	mutex_lock(&cm->open_mutex);
 	if (! cm->opened[CM_CH_PLAY]) {
 		if (cm->can_multi_ch) {
 			runtime->hw.channels_max = cm->max_channels;
@@ -1559,7 +1560,7 @@ static int snd_cmipci_playback2_open(struct snd_pcm_substream *substream)
 		}
 		snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);
 	}
-	up(&cm->open_mutex);
+	mutex_unlock(&cm->open_mutex);
 	return 0;
 }
 
@@ -2844,7 +2845,7 @@ static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pc
 	}
 
 	spin_lock_init(&cm->reg_lock);
-	init_MUTEX(&cm->open_mutex);
+	mutex_init(&cm->open_mutex);
 	cm->device = pci->device;
 	cm->card = card;
 	cm->pci = pci;

commit cb60e5f5b2b19284479825cdaa6dd6b7078cf5d2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 16:14:49 2005 +0100

    [ALSA] cmipci - Add PM support
    
    Modules: CMIPCI driver
    
    Add PM support to CMIPCI driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index ce156ca5bc6f..c03b0a0a3b27 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -269,6 +269,7 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_MICGAINZ		0x01	/* mic boost */
 #define CM_MICGAINZ_SHIFT	0
 
+#define CM_REG_MIXER3		0x24
 #define CM_REG_AUX_VOL		0x26
 #define CM_VAUXL_MASK		0xf0
 #define CM_VAUXR_MASK		0x0f
@@ -324,6 +325,7 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_REG_CH0_FRAME2	0x84
 #define CM_REG_CH1_FRAME1	0x88	/* 0-15: count of samples at bus master; buffer size */
 #define CM_REG_CH1_FRAME2	0x8C	/* 16-31: count of samples at codec; fragment size */
+#define CM_REG_EXT_MISC		0x90
 #define CM_REG_MISC_CTRL_8768	0x92	/* reg. name the same as 0x18 */
 #define CM_CHB3D8C		0x20	/* 7.1 channels support */
 #define CM_SPD32FMT		0x10	/* SPDIF/IN 32k */
@@ -453,6 +455,11 @@ struct cmipci {
 #endif
 
 	spinlock_t reg_lock;
+
+#ifdef CONFIG_PM
+	unsigned int saved_regs[0x20];
+	unsigned char saved_mixers[0x20];
+#endif
 };
 
 
@@ -849,10 +856,12 @@ static int snd_cmipci_pcm_trigger(struct cmipci *cm, struct cmipci_pcm *rec,
 		snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl & ~reset);
 		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
 		cm->ctrl |= pause;
 		snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);
 		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_RESUME:
 		cm->ctrl &= ~pause;
 		snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);
 		break;
@@ -1325,7 +1334,7 @@ static struct snd_pcm_hardware snd_cmipci_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
-				 SNDRV_PCM_INFO_MMAP_VALID),
+				 SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),
 	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
 	.rates =		SNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000_48000,
 	.rate_min =		5512,
@@ -1345,7 +1354,7 @@ static struct snd_pcm_hardware snd_cmipci_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
-				 SNDRV_PCM_INFO_MMAP_VALID),
+				 SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),
 	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
 	.rates =		SNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000_48000,
 	.rate_min =		5512,
@@ -1365,7 +1374,7 @@ static struct snd_pcm_hardware snd_cmipci_playback2 =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
-				 SNDRV_PCM_INFO_MMAP_VALID),
+				 SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),
 	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
 	.rates =		SNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000_48000,
 	.rate_min =		5512,
@@ -1385,7 +1394,7 @@ static struct snd_pcm_hardware snd_cmipci_playback_spdif =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
-				 SNDRV_PCM_INFO_MMAP_VALID),
+				 SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),
 	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
 	.rates =		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
 	.rate_min =		44100,
@@ -1405,7 +1414,7 @@ static struct snd_pcm_hardware snd_cmipci_playback_iec958_subframe =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
-				 SNDRV_PCM_INFO_MMAP_VALID),
+				 SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),
 	.formats =		SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE,
 	.rates =		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
 	.rate_min =		44100,
@@ -1425,7 +1434,7 @@ static struct snd_pcm_hardware snd_cmipci_capture_spdif =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
-				 SNDRV_PCM_INFO_MMAP_VALID),
+				 SNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_MMAP_VALID),
 	.formats =	        SNDRV_PCM_FMTBIT_S16_LE,
 	.rates =		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
 	.rate_min =		44100,
@@ -3038,6 +3047,7 @@ static int __devinit snd_cmipci_probe(struct pci_dev *pci,
 		snd_card_free(card);
 		return err;
 	}
+	card->private_data = cm;
 
 	sprintf(card->shortname, "C-Media PCI %s", card->driver);
 	sprintf(card->longname, "%s (model %d) at 0x%lx, irq %i",
@@ -3065,11 +3075,93 @@ static void __devexit snd_cmipci_remove(struct pci_dev *pci)
 }
 
 
+#ifdef CONFIG_PM
+/*
+ * power management
+ */
+static unsigned char saved_regs[] = {
+	CM_REG_FUNCTRL1, CM_REG_CHFORMAT, CM_REG_LEGACY_CTRL, CM_REG_MISC_CTRL,
+	CM_REG_MIXER0, CM_REG_MIXER1, CM_REG_MIXER2, CM_REG_MIXER3, CM_REG_PLL,
+	CM_REG_CH0_FRAME1, CM_REG_CH0_FRAME2,
+	CM_REG_CH1_FRAME1, CM_REG_CH1_FRAME2, CM_REG_EXT_MISC,
+	CM_REG_INT_STATUS, CM_REG_INT_HLDCLR, CM_REG_FUNCTRL0,
+};
+
+static unsigned char saved_mixers[] = {
+	SB_DSP4_MASTER_DEV, SB_DSP4_MASTER_DEV + 1,
+	SB_DSP4_PCM_DEV, SB_DSP4_PCM_DEV + 1,
+	SB_DSP4_SYNTH_DEV, SB_DSP4_SYNTH_DEV + 1,
+	SB_DSP4_CD_DEV, SB_DSP4_CD_DEV + 1,
+	SB_DSP4_LINE_DEV, SB_DSP4_LINE_DEV + 1,
+	SB_DSP4_MIC_DEV, SB_DSP4_SPEAKER_DEV,
+	CM_REG_EXTENT_IND, SB_DSP4_OUTPUT_SW,
+	SB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT,
+};
+
+static int snd_cmipci_suspend(struct pci_dev *pci, pm_message_t state)
+{
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct cmipci *cm = card->private_data;
+	int i;
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	
+	snd_pcm_suspend_all(cm->pcm);
+	snd_pcm_suspend_all(cm->pcm2);
+	snd_pcm_suspend_all(cm->pcm_spdif);
+
+	/* save registers */
+	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
+		cm->saved_regs[i] = snd_cmipci_read(cm, saved_regs[i]);
+	for (i = 0; i < ARRAY_SIZE(saved_mixers); i++)
+		cm->saved_mixers[i] = snd_cmipci_mixer_read(cm, saved_mixers[i]);
+
+	/* disable ints */
+	snd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);
+
+	pci_set_power_state(pci, PCI_D3hot);
+	pci_disable_device(pci);
+	pci_save_state(pci);
+	return 0;
+}
+
+static int snd_cmipci_resume(struct pci_dev *pci)
+{
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct cmipci *cm = card->private_data;
+	int i;
+
+	pci_restore_state(pci);
+	pci_enable_device(pci);
+	pci_set_power_state(pci, PCI_D0);
+	pci_set_master(pci);
+
+	/* reset / initialize to a sane state */
+	snd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);
+	snd_cmipci_ch_reset(cm, CM_CH_PLAY);
+	snd_cmipci_ch_reset(cm, CM_CH_CAPT);
+	snd_cmipci_mixer_write(cm, 0, 0);
+
+	/* restore registers */
+	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
+		snd_cmipci_write(cm, saved_regs[i], cm->saved_regs[i]);
+	for (i = 0; i < ARRAY_SIZE(saved_mixers); i++)
+		snd_cmipci_mixer_write(cm, saved_mixers[i], cm->saved_mixers[i]);
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	return 0;
+}
+#endif /* CONFIG_PM */
+
 static struct pci_driver driver = {
 	.name = "C-Media PCI",
 	.id_table = snd_cmipci_ids,
 	.probe = snd_cmipci_probe,
 	.remove = __devexit_p(snd_cmipci_remove),
+#ifdef CONFIG_PM
+	.suspend = snd_cmipci_suspend,
+	.resume = snd_cmipci_resume,
+#endif
 };
 	
 static int __init alsa_card_cmipci_init(void)

commit 2cbdb686dd8df8d80742738ab50acfcfe9a95939
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:03:13 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI CMIPCI
    
    Modules: CMIPCI driver
    
    Remove xxx_t typedefs from the PCI CMIPCI driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 0309689f37f5..ce156ca5bc6f 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -378,11 +378,8 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
  * driver data
  */
 
-typedef struct snd_stru_cmipci cmipci_t;
-typedef struct snd_stru_cmipci_pcm cmipci_pcm_t;
-
-struct snd_stru_cmipci_pcm {
-	snd_pcm_substream_t *substream;
+struct cmipci_pcm {
+	struct snd_pcm_substream *substream;
 	int running;		/* dac/adc running? */
 	unsigned int dma_size;	/* in frames */
 	unsigned int period_size;	/* in frames */
@@ -408,8 +405,8 @@ static const struct cmipci_mixer_auto_switches cm_saved_mixer[] = {
 };
 #define CM_SAVED_MIXERS		ARRAY_SIZE(cm_saved_mixer)
 
-struct snd_stru_cmipci {
-	snd_card_t *card;
+struct cmipci {
+	struct snd_card *card;
 
 	struct pci_dev *pci;
 	unsigned int device;	/* device ID */
@@ -418,9 +415,9 @@ struct snd_stru_cmipci {
 	unsigned long iobase;
 	unsigned int ctrl;	/* FUNCTRL0 current value */
 
-	snd_pcm_t *pcm;		/* DAC/ADC PCM */
-	snd_pcm_t *pcm2;	/* 2nd DAC */
-	snd_pcm_t *pcm_spdif;	/* SPDIF */
+	struct snd_pcm *pcm;		/* DAC/ADC PCM */
+	struct snd_pcm *pcm2;	/* 2nd DAC */
+	struct snd_pcm *pcm_spdif;	/* SPDIF */
 
 	int chip_version;
 	int max_channels;
@@ -437,19 +434,19 @@ struct snd_stru_cmipci {
 	unsigned int dig_status;
 	unsigned int dig_pcm_status;
 
-	snd_pcm_hardware_t *hw_info[3]; /* for playbacks */
+	struct snd_pcm_hardware *hw_info[3]; /* for playbacks */
 
 	int opened[2];	/* open mode */
 	struct semaphore open_mutex;
 
 	unsigned int mixer_insensitive: 1;
-	snd_kcontrol_t *mixer_res_ctl[CM_SAVED_MIXERS];
+	struct snd_kcontrol *mixer_res_ctl[CM_SAVED_MIXERS];
 	int mixer_res_status[CM_SAVED_MIXERS];
 
-	cmipci_pcm_t channel[2];	/* ch0 - DAC, ch1 - ADC or 2nd DAC */
+	struct cmipci_pcm channel[2];	/* ch0 - DAC, ch1 - ADC or 2nd DAC */
 
 	/* external MIDI */
-	snd_rawmidi_t *rmidi;
+	struct snd_rawmidi *rmidi;
 
 #ifdef SUPPORT_JOYSTICK
 	struct gameport *gameport;
@@ -460,40 +457,40 @@ struct snd_stru_cmipci {
 
 
 /* read/write operations for dword register */
-static inline void snd_cmipci_write(cmipci_t *cm, unsigned int cmd, unsigned int data)
+static inline void snd_cmipci_write(struct cmipci *cm, unsigned int cmd, unsigned int data)
 {
 	outl(data, cm->iobase + cmd);
 }
 
-static inline unsigned int snd_cmipci_read(cmipci_t *cm, unsigned int cmd)
+static inline unsigned int snd_cmipci_read(struct cmipci *cm, unsigned int cmd)
 {
 	return inl(cm->iobase + cmd);
 }
 
 /* read/write operations for word register */
-static inline void snd_cmipci_write_w(cmipci_t *cm, unsigned int cmd, unsigned short data)
+static inline void snd_cmipci_write_w(struct cmipci *cm, unsigned int cmd, unsigned short data)
 {
 	outw(data, cm->iobase + cmd);
 }
 
-static inline unsigned short snd_cmipci_read_w(cmipci_t *cm, unsigned int cmd)
+static inline unsigned short snd_cmipci_read_w(struct cmipci *cm, unsigned int cmd)
 {
 	return inw(cm->iobase + cmd);
 }
 
 /* read/write operations for byte register */
-static inline void snd_cmipci_write_b(cmipci_t *cm, unsigned int cmd, unsigned char data)
+static inline void snd_cmipci_write_b(struct cmipci *cm, unsigned int cmd, unsigned char data)
 {
 	outb(data, cm->iobase + cmd);
 }
 
-static inline unsigned char snd_cmipci_read_b(cmipci_t *cm, unsigned int cmd)
+static inline unsigned char snd_cmipci_read_b(struct cmipci *cm, unsigned int cmd)
 {
 	return inb(cm->iobase + cmd);
 }
 
 /* bit operations for dword register */
-static int snd_cmipci_set_bit(cmipci_t *cm, unsigned int cmd, unsigned int flag)
+static int snd_cmipci_set_bit(struct cmipci *cm, unsigned int cmd, unsigned int flag)
 {
 	unsigned int val, oval;
 	val = oval = inl(cm->iobase + cmd);
@@ -504,7 +501,7 @@ static int snd_cmipci_set_bit(cmipci_t *cm, unsigned int cmd, unsigned int flag)
 	return 1;
 }
 
-static int snd_cmipci_clear_bit(cmipci_t *cm, unsigned int cmd, unsigned int flag)
+static int snd_cmipci_clear_bit(struct cmipci *cm, unsigned int cmd, unsigned int flag)
 {
 	unsigned int val, oval;
 	val = oval = inl(cm->iobase + cmd);
@@ -516,7 +513,7 @@ static int snd_cmipci_clear_bit(cmipci_t *cm, unsigned int cmd, unsigned int fla
 }
 
 /* bit operations for byte register */
-static int snd_cmipci_set_bit_b(cmipci_t *cm, unsigned int cmd, unsigned char flag)
+static int snd_cmipci_set_bit_b(struct cmipci *cm, unsigned int cmd, unsigned char flag)
 {
 	unsigned char val, oval;
 	val = oval = inb(cm->iobase + cmd);
@@ -527,7 +524,7 @@ static int snd_cmipci_set_bit_b(cmipci_t *cm, unsigned int cmd, unsigned char fl
 	return 1;
 }
 
-static int snd_cmipci_clear_bit_b(cmipci_t *cm, unsigned int cmd, unsigned char flag)
+static int snd_cmipci_clear_bit_b(struct cmipci *cm, unsigned int cmd, unsigned char flag)
 {
 	unsigned char val, oval;
 	val = oval = inb(cm->iobase + cmd);
@@ -608,7 +605,7 @@ static int snd_cmipci_pll_rmn(unsigned int rate, unsigned int adcmult, int *r, i
  * at the register CM_REG_FUNCTRL1 (0x04).
  * Problem: other ways are also possible (any information about that?)
  */
-static void snd_cmipci_set_pll(cmipci_t *cm, unsigned int rate, unsigned int slot)
+static void snd_cmipci_set_pll(struct cmipci *cm, unsigned int rate, unsigned int slot)
 {
 	unsigned int reg = CM_REG_PLL + slot;
 	/*
@@ -626,16 +623,16 @@ static void snd_cmipci_set_pll(cmipci_t *cm, unsigned int rate, unsigned int slo
 }
 #endif /* USE_VAR48KRATE */
 
-static int snd_cmipci_hw_params(snd_pcm_substream_t * substream,
-				snd_pcm_hw_params_t * hw_params)
+static int snd_cmipci_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *hw_params)
 {
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 }
 
-static int snd_cmipci_playback2_hw_params(snd_pcm_substream_t * substream,
-					  snd_pcm_hw_params_t * hw_params)
+static int snd_cmipci_playback2_hw_params(struct snd_pcm_substream *substream,
+					  struct snd_pcm_hw_params *hw_params)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	if (params_channels(hw_params) > 2) {
 		down(&cm->open_mutex);
 		if (cm->opened[CM_CH_PLAY]) {
@@ -649,7 +646,7 @@ static int snd_cmipci_playback2_hw_params(snd_pcm_substream_t * substream,
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 }
 
-static void snd_cmipci_ch_reset(cmipci_t *cm, int ch)
+static void snd_cmipci_ch_reset(struct cmipci *cm, int ch)
 {
 	int reset = CM_RST_CH0 << (cm->channel[ch].ch);
 	snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl | reset);
@@ -657,7 +654,7 @@ static void snd_cmipci_ch_reset(cmipci_t *cm, int ch)
 	udelay(10);
 }
 
-static int snd_cmipci_hw_free(snd_pcm_substream_t * substream)
+static int snd_cmipci_hw_free(struct snd_pcm_substream *substream)
 {
 	return snd_pcm_lib_free_pages(substream);
 }
@@ -667,23 +664,23 @@ static int snd_cmipci_hw_free(snd_pcm_substream_t * substream)
  */
 
 static unsigned int hw_channels[] = {1, 2, 4, 5, 6, 8};
-static snd_pcm_hw_constraint_list_t hw_constraints_channels_4 = {
+static struct snd_pcm_hw_constraint_list hw_constraints_channels_4 = {
 	.count = 3,
 	.list = hw_channels,
 	.mask = 0,
 };
-static snd_pcm_hw_constraint_list_t hw_constraints_channels_6 = {
+static struct snd_pcm_hw_constraint_list hw_constraints_channels_6 = {
 	.count = 5,
 	.list = hw_channels,
 	.mask = 0,
 };
-static snd_pcm_hw_constraint_list_t hw_constraints_channels_8 = {
+static struct snd_pcm_hw_constraint_list hw_constraints_channels_8 = {
 	.count = 6,
 	.list = hw_channels,
 	.mask = 0,
 };
 
-static int set_dac_channels(cmipci_t *cm, cmipci_pcm_t *rec, int channels)
+static int set_dac_channels(struct cmipci *cm, struct cmipci_pcm *rec, int channels)
 {
 	if (channels > 2) {
 		if (! cm->can_multi_ch)
@@ -737,11 +734,11 @@ static int set_dac_channels(cmipci_t *cm, cmipci_pcm_t *rec, int channels)
  * prepare playback/capture channel
  * channel to be used must have been set in rec->ch.
  */
-static int snd_cmipci_pcm_prepare(cmipci_t *cm, cmipci_pcm_t *rec,
-				 snd_pcm_substream_t *substream)
+static int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,
+				 struct snd_pcm_substream *substream)
 {
 	unsigned int reg, freq, val;
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	rec->fmt = 0;
 	rec->shift = 0;
@@ -820,8 +817,8 @@ static int snd_cmipci_pcm_prepare(cmipci_t *cm, cmipci_pcm_t *rec,
 /*
  * PCM trigger/stop
  */
-static int snd_cmipci_pcm_trigger(cmipci_t *cm, cmipci_pcm_t *rec,
-				 snd_pcm_substream_t *substream, int cmd)
+static int snd_cmipci_pcm_trigger(struct cmipci *cm, struct cmipci_pcm *rec,
+				  struct snd_pcm_substream *substream, int cmd)
 {
 	unsigned int inthld, chen, reset, pause;
 	int result = 0;
@@ -870,8 +867,8 @@ static int snd_cmipci_pcm_trigger(cmipci_t *cm, cmipci_pcm_t *rec,
 /*
  * return the current pointer
  */
-static snd_pcm_uframes_t snd_cmipci_pcm_pointer(cmipci_t *cm, cmipci_pcm_t *rec,
-					  snd_pcm_substream_t *substream)
+static snd_pcm_uframes_t snd_cmipci_pcm_pointer(struct cmipci *cm, struct cmipci_pcm *rec,
+						struct snd_pcm_substream *substream)
 {
 	size_t ptr;
 	unsigned int reg;
@@ -895,16 +892,16 @@ static snd_pcm_uframes_t snd_cmipci_pcm_pointer(cmipci_t *cm, cmipci_pcm_t *rec,
  * playback
  */
 
-static int snd_cmipci_playback_trigger(snd_pcm_substream_t *substream,
+static int snd_cmipci_playback_trigger(struct snd_pcm_substream *substream,
 				       int cmd)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	return snd_cmipci_pcm_trigger(cm, &cm->channel[CM_CH_PLAY], substream, cmd);
 }
 
-static snd_pcm_uframes_t snd_cmipci_playback_pointer(snd_pcm_substream_t *substream)
+static snd_pcm_uframes_t snd_cmipci_playback_pointer(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	return snd_cmipci_pcm_pointer(cm, &cm->channel[CM_CH_PLAY], substream);
 }
 
@@ -914,16 +911,16 @@ static snd_pcm_uframes_t snd_cmipci_playback_pointer(snd_pcm_substream_t *substr
  * capture
  */
 
-static int snd_cmipci_capture_trigger(snd_pcm_substream_t *substream,
+static int snd_cmipci_capture_trigger(struct snd_pcm_substream *substream,
 				     int cmd)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	return snd_cmipci_pcm_trigger(cm, &cm->channel[CM_CH_CAPT], substream, cmd);
 }
 
-static snd_pcm_uframes_t snd_cmipci_capture_pointer(snd_pcm_substream_t *substream)
+static snd_pcm_uframes_t snd_cmipci_capture_pointer(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	return snd_cmipci_pcm_pointer(cm, &cm->channel[CM_CH_CAPT], substream);
 }
 
@@ -932,18 +929,18 @@ static snd_pcm_uframes_t snd_cmipci_capture_pointer(snd_pcm_substream_t *substre
  * hw preparation for spdif
  */
 
-static int snd_cmipci_spdif_default_info(snd_kcontrol_t *kcontrol,
-					 snd_ctl_elem_info_t *uinfo)
+static int snd_cmipci_spdif_default_info(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_cmipci_spdif_default_get(snd_kcontrol_t *kcontrol,
-					snd_ctl_elem_value_t *ucontrol)
+static int snd_cmipci_spdif_default_get(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *chip = snd_kcontrol_chip(kcontrol);
+	struct cmipci *chip = snd_kcontrol_chip(kcontrol);
 	int i;
 
 	spin_lock_irq(&chip->reg_lock);
@@ -953,10 +950,10 @@ static int snd_cmipci_spdif_default_get(snd_kcontrol_t *kcontrol,
 	return 0;
 }
 
-static int snd_cmipci_spdif_default_put(snd_kcontrol_t * kcontrol,
-					 snd_ctl_elem_value_t * ucontrol)
+static int snd_cmipci_spdif_default_put(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *chip = snd_kcontrol_chip(kcontrol);
+	struct cmipci *chip = snd_kcontrol_chip(kcontrol);
 	int i, change;
 	unsigned int val;
 
@@ -970,7 +967,7 @@ static int snd_cmipci_spdif_default_put(snd_kcontrol_t * kcontrol,
 	return change;
 }
 
-static snd_kcontrol_new_t snd_cmipci_spdif_default __devinitdata =
+static struct snd_kcontrol_new snd_cmipci_spdif_default __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
@@ -979,16 +976,16 @@ static snd_kcontrol_new_t snd_cmipci_spdif_default __devinitdata =
 	.put =		snd_cmipci_spdif_default_put
 };
 
-static int snd_cmipci_spdif_mask_info(snd_kcontrol_t *kcontrol,
-				      snd_ctl_elem_info_t *uinfo)
+static int snd_cmipci_spdif_mask_info(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_cmipci_spdif_mask_get(snd_kcontrol_t * kcontrol,
-				     snd_ctl_elem_value_t *ucontrol)
+static int snd_cmipci_spdif_mask_get(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
 {
 	ucontrol->value.iec958.status[0] = 0xff;
 	ucontrol->value.iec958.status[1] = 0xff;
@@ -997,7 +994,7 @@ static int snd_cmipci_spdif_mask_get(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static snd_kcontrol_new_t snd_cmipci_spdif_mask __devinitdata =
+static struct snd_kcontrol_new snd_cmipci_spdif_mask __devinitdata =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -1006,18 +1003,18 @@ static snd_kcontrol_new_t snd_cmipci_spdif_mask __devinitdata =
 	.get =		snd_cmipci_spdif_mask_get,
 };
 
-static int snd_cmipci_spdif_stream_info(snd_kcontrol_t *kcontrol,
-					snd_ctl_elem_info_t *uinfo)
+static int snd_cmipci_spdif_stream_info(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_cmipci_spdif_stream_get(snd_kcontrol_t *kcontrol,
-				       snd_ctl_elem_value_t *ucontrol)
+static int snd_cmipci_spdif_stream_get(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *chip = snd_kcontrol_chip(kcontrol);
+	struct cmipci *chip = snd_kcontrol_chip(kcontrol);
 	int i;
 
 	spin_lock_irq(&chip->reg_lock);
@@ -1027,10 +1024,10 @@ static int snd_cmipci_spdif_stream_get(snd_kcontrol_t *kcontrol,
 	return 0;
 }
 
-static int snd_cmipci_spdif_stream_put(snd_kcontrol_t *kcontrol,
-				       snd_ctl_elem_value_t *ucontrol)
+static int snd_cmipci_spdif_stream_put(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *chip = snd_kcontrol_chip(kcontrol);
+	struct cmipci *chip = snd_kcontrol_chip(kcontrol);
 	int i, change;
 	unsigned int val;
 
@@ -1044,7 +1041,7 @@ static int snd_cmipci_spdif_stream_put(snd_kcontrol_t *kcontrol,
 	return change;
 }
 
-static snd_kcontrol_new_t snd_cmipci_spdif_stream __devinitdata =
+static struct snd_kcontrol_new snd_cmipci_spdif_stream __devinitdata =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -1058,17 +1055,17 @@ static snd_kcontrol_new_t snd_cmipci_spdif_stream __devinitdata =
  */
 
 /* save mixer setting and mute for AC3 playback */
-static int save_mixer_state(cmipci_t *cm)
+static int save_mixer_state(struct cmipci *cm)
 {
 	if (! cm->mixer_insensitive) {
-		snd_ctl_elem_value_t *val;
+		struct snd_ctl_elem_value *val;
 		unsigned int i;
 
 		val = kmalloc(sizeof(*val), GFP_ATOMIC);
 		if (!val)
 			return -ENOMEM;
 		for (i = 0; i < CM_SAVED_MIXERS; i++) {
-			snd_kcontrol_t *ctl = cm->mixer_res_ctl[i];
+			struct snd_kcontrol *ctl = cm->mixer_res_ctl[i];
 			if (ctl) {
 				int event;
 				memset(val, 0, sizeof(*val));
@@ -1092,10 +1089,10 @@ static int save_mixer_state(cmipci_t *cm)
 
 
 /* restore the previously saved mixer status */
-static void restore_mixer_state(cmipci_t *cm)
+static void restore_mixer_state(struct cmipci *cm)
 {
 	if (cm->mixer_insensitive) {
-		snd_ctl_elem_value_t *val;
+		struct snd_ctl_elem_value *val;
 		unsigned int i;
 
 		val = kmalloc(sizeof(*val), GFP_KERNEL);
@@ -1104,7 +1101,7 @@ static void restore_mixer_state(cmipci_t *cm)
 		cm->mixer_insensitive = 0; /* at first clear this;
 					      otherwise the changes will be ignored */
 		for (i = 0; i < CM_SAVED_MIXERS; i++) {
-			snd_kcontrol_t *ctl = cm->mixer_res_ctl[i];
+			struct snd_kcontrol *ctl = cm->mixer_res_ctl[i];
 			if (ctl) {
 				int event;
 
@@ -1125,7 +1122,7 @@ static void restore_mixer_state(cmipci_t *cm)
 }
 
 /* spinlock held! */
-static void setup_ac3(cmipci_t *cm, snd_pcm_substream_t *subs, int do_ac3, int rate)
+static void setup_ac3(struct cmipci *cm, struct snd_pcm_substream *subs, int do_ac3, int rate)
 {
 	if (do_ac3) {
 		/* AC3EN for 037 */
@@ -1172,7 +1169,7 @@ static void setup_ac3(cmipci_t *cm, snd_pcm_substream_t *subs, int do_ac3, int r
 	}
 }
 
-static int setup_spdif_playback(cmipci_t *cm, snd_pcm_substream_t *subs, int up, int do_ac3)
+static int setup_spdif_playback(struct cmipci *cm, struct snd_pcm_substream *subs, int up, int do_ac3)
 {
 	int rate, err;
 
@@ -1214,9 +1211,9 @@ static int setup_spdif_playback(cmipci_t *cm, snd_pcm_substream_t *subs, int up,
  */
 
 /* playback - enable spdif only on the certain condition */
-static int snd_cmipci_playback_prepare(snd_pcm_substream_t *substream)
+static int snd_cmipci_playback_prepare(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	int rate = substream->runtime->rate;
 	int err, do_spdif, do_ac3 = 0;
 
@@ -1231,9 +1228,9 @@ static int snd_cmipci_playback_prepare(snd_pcm_substream_t *substream)
 }
 
 /* playback  (via device #2) - enable spdif always */
-static int snd_cmipci_playback_spdif_prepare(snd_pcm_substream_t *substream)
+static int snd_cmipci_playback_spdif_prepare(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	int err, do_ac3;
 
 	if (cm->can_ac3_hw) 
@@ -1245,25 +1242,25 @@ static int snd_cmipci_playback_spdif_prepare(snd_pcm_substream_t *substream)
 	return snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_PLAY], substream);
 }
 
-static int snd_cmipci_playback_hw_free(snd_pcm_substream_t *substream)
+static int snd_cmipci_playback_hw_free(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	setup_spdif_playback(cm, substream, 0, 0);
 	restore_mixer_state(cm);
 	return snd_cmipci_hw_free(substream);
 }
 
 /* capture */
-static int snd_cmipci_capture_prepare(snd_pcm_substream_t *substream)
+static int snd_cmipci_capture_prepare(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	return snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_CAPT], substream);
 }
 
 /* capture with spdif (via device #2) */
-static int snd_cmipci_capture_spdif_prepare(snd_pcm_substream_t *substream)
+static int snd_cmipci_capture_spdif_prepare(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 
 	spin_lock_irq(&cm->reg_lock);
 	snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_CAPTURE_SPDF);
@@ -1272,9 +1269,9 @@ static int snd_cmipci_capture_spdif_prepare(snd_pcm_substream_t *substream)
 	return snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_CAPT], substream);
 }
 
-static int snd_cmipci_capture_spdif_hw_free(snd_pcm_substream_t *subs)
+static int snd_cmipci_capture_spdif_hw_free(struct snd_pcm_substream *subs)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(subs);
+	struct cmipci *cm = snd_pcm_substream_chip(subs);
 
 	spin_lock_irq(&cm->reg_lock);
 	snd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_CAPTURE_SPDF);
@@ -1289,7 +1286,7 @@ static int snd_cmipci_capture_spdif_hw_free(snd_pcm_substream_t *subs)
  */
 static irqreturn_t snd_cmipci_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	cmipci_t *cm = dev_id;
+	struct cmipci *cm = dev_id;
 	unsigned int status, mask = 0;
 	
 	/* fastpath out, to ease interrupt sharing */
@@ -1324,7 +1321,7 @@ static irqreturn_t snd_cmipci_interrupt(int irq, void *dev_id, struct pt_regs *r
  */
 
 /* playback on channel A */
-static snd_pcm_hardware_t snd_cmipci_playback =
+static struct snd_pcm_hardware snd_cmipci_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
@@ -1344,7 +1341,7 @@ static snd_pcm_hardware_t snd_cmipci_playback =
 };
 
 /* capture on channel B */
-static snd_pcm_hardware_t snd_cmipci_capture =
+static struct snd_pcm_hardware snd_cmipci_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
@@ -1364,7 +1361,7 @@ static snd_pcm_hardware_t snd_cmipci_capture =
 };
 
 /* playback on channel B - stereo 16bit only? */
-static snd_pcm_hardware_t snd_cmipci_playback2 =
+static struct snd_pcm_hardware snd_cmipci_playback2 =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
@@ -1384,7 +1381,7 @@ static snd_pcm_hardware_t snd_cmipci_playback2 =
 };
 
 /* spdif playback on channel A */
-static snd_pcm_hardware_t snd_cmipci_playback_spdif =
+static struct snd_pcm_hardware snd_cmipci_playback_spdif =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
@@ -1404,7 +1401,7 @@ static snd_pcm_hardware_t snd_cmipci_playback_spdif =
 };
 
 /* spdif playback on channel A (32bit, IEC958 subframes) */
-static snd_pcm_hardware_t snd_cmipci_playback_iec958_subframe =
+static struct snd_pcm_hardware snd_cmipci_playback_iec958_subframe =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
@@ -1424,7 +1421,7 @@ static snd_pcm_hardware_t snd_cmipci_playback_iec958_subframe =
 };
 
 /* spdif capture on channel B */
-static snd_pcm_hardware_t snd_cmipci_capture_spdif =
+static struct snd_pcm_hardware snd_cmipci_capture_spdif =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
@@ -1446,7 +1443,7 @@ static snd_pcm_hardware_t snd_cmipci_capture_spdif =
 /*
  * check device open/close
  */
-static int open_device_check(cmipci_t *cm, int mode, snd_pcm_substream_t *subs)
+static int open_device_check(struct cmipci *cm, int mode, struct snd_pcm_substream *subs)
 {
 	int ch = mode & CM_OPEN_CH_MASK;
 
@@ -1473,7 +1470,7 @@ static int open_device_check(cmipci_t *cm, int mode, snd_pcm_substream_t *subs)
 	return 0;
 }
 
-static void close_device_check(cmipci_t *cm, int mode)
+static void close_device_check(struct cmipci *cm, int mode)
 {
 	int ch = mode & CM_OPEN_CH_MASK;
 
@@ -1499,10 +1496,10 @@ static void close_device_check(cmipci_t *cm, int mode)
 /*
  */
 
-static int snd_cmipci_playback_open(snd_pcm_substream_t *substream)
+static int snd_cmipci_playback_open(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err;
 
 	if ((err = open_device_check(cm, CM_OPEN_PLAYBACK, substream)) < 0)
@@ -1514,10 +1511,10 @@ static int snd_cmipci_playback_open(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static int snd_cmipci_capture_open(snd_pcm_substream_t *substream)
+static int snd_cmipci_capture_open(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err;
 
 	if ((err = open_device_check(cm, CM_OPEN_CAPTURE, substream)) < 0)
@@ -1531,10 +1528,10 @@ static int snd_cmipci_capture_open(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static int snd_cmipci_playback2_open(snd_pcm_substream_t *substream)
+static int snd_cmipci_playback2_open(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err;
 
 	if ((err = open_device_check(cm, CM_OPEN_PLAYBACK2, substream)) < 0) /* use channel B */
@@ -1557,10 +1554,10 @@ static int snd_cmipci_playback2_open(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static int snd_cmipci_playback_spdif_open(snd_pcm_substream_t *substream)
+static int snd_cmipci_playback_spdif_open(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err;
 
 	if ((err = open_device_check(cm, CM_OPEN_SPDIF_PLAYBACK, substream)) < 0) /* use channel A */
@@ -1577,10 +1574,10 @@ static int snd_cmipci_playback_spdif_open(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static int snd_cmipci_capture_spdif_open(snd_pcm_substream_t * substream)
+static int snd_cmipci_capture_spdif_open(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err;
 
 	if ((err = open_device_check(cm, CM_OPEN_SPDIF_CAPTURE, substream)) < 0) /* use channel B */
@@ -1594,38 +1591,38 @@ static int snd_cmipci_capture_spdif_open(snd_pcm_substream_t * substream)
 /*
  */
 
-static int snd_cmipci_playback_close(snd_pcm_substream_t * substream)
+static int snd_cmipci_playback_close(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	close_device_check(cm, CM_OPEN_PLAYBACK);
 	return 0;
 }
 
-static int snd_cmipci_capture_close(snd_pcm_substream_t * substream)
+static int snd_cmipci_capture_close(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	close_device_check(cm, CM_OPEN_CAPTURE);
 	return 0;
 }
 
-static int snd_cmipci_playback2_close(snd_pcm_substream_t * substream)
+static int snd_cmipci_playback2_close(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	close_device_check(cm, CM_OPEN_PLAYBACK2);
 	close_device_check(cm, CM_OPEN_PLAYBACK_MULTI);
 	return 0;
 }
 
-static int snd_cmipci_playback_spdif_close(snd_pcm_substream_t * substream)
+static int snd_cmipci_playback_spdif_close(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	close_device_check(cm, CM_OPEN_SPDIF_PLAYBACK);
 	return 0;
 }
 
-static int snd_cmipci_capture_spdif_close(snd_pcm_substream_t * substream)
+static int snd_cmipci_capture_spdif_close(struct snd_pcm_substream *substream)
 {
-	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	struct cmipci *cm = snd_pcm_substream_chip(substream);
 	close_device_check(cm, CM_OPEN_SPDIF_CAPTURE);
 	return 0;
 }
@@ -1634,7 +1631,7 @@ static int snd_cmipci_capture_spdif_close(snd_pcm_substream_t * substream)
 /*
  */
 
-static snd_pcm_ops_t snd_cmipci_playback_ops = {
+static struct snd_pcm_ops snd_cmipci_playback_ops = {
 	.open =		snd_cmipci_playback_open,
 	.close =	snd_cmipci_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1645,7 +1642,7 @@ static snd_pcm_ops_t snd_cmipci_playback_ops = {
 	.pointer =	snd_cmipci_playback_pointer,
 };
 
-static snd_pcm_ops_t snd_cmipci_capture_ops = {
+static struct snd_pcm_ops snd_cmipci_capture_ops = {
 	.open =		snd_cmipci_capture_open,
 	.close =	snd_cmipci_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1656,7 +1653,7 @@ static snd_pcm_ops_t snd_cmipci_capture_ops = {
 	.pointer =	snd_cmipci_capture_pointer,
 };
 
-static snd_pcm_ops_t snd_cmipci_playback2_ops = {
+static struct snd_pcm_ops snd_cmipci_playback2_ops = {
 	.open =		snd_cmipci_playback2_open,
 	.close =	snd_cmipci_playback2_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1667,7 +1664,7 @@ static snd_pcm_ops_t snd_cmipci_playback2_ops = {
 	.pointer =	snd_cmipci_capture_pointer,	/* channel B */
 };
 
-static snd_pcm_ops_t snd_cmipci_playback_spdif_ops = {
+static struct snd_pcm_ops snd_cmipci_playback_spdif_ops = {
 	.open =		snd_cmipci_playback_spdif_open,
 	.close =	snd_cmipci_playback_spdif_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1678,7 +1675,7 @@ static snd_pcm_ops_t snd_cmipci_playback_spdif_ops = {
 	.pointer =	snd_cmipci_playback_pointer,
 };
 
-static snd_pcm_ops_t snd_cmipci_capture_spdif_ops = {
+static struct snd_pcm_ops snd_cmipci_capture_spdif_ops = {
 	.open =		snd_cmipci_capture_spdif_open,
 	.close =	snd_cmipci_capture_spdif_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1693,9 +1690,9 @@ static snd_pcm_ops_t snd_cmipci_capture_spdif_ops = {
 /*
  */
 
-static int __devinit snd_cmipci_pcm_new(cmipci_t *cm, int device)
+static int __devinit snd_cmipci_pcm_new(struct cmipci *cm, int device)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	err = snd_pcm_new(cm->card, cm->card->driver, device, 1, 1, &pcm);
@@ -1716,9 +1713,9 @@ static int __devinit snd_cmipci_pcm_new(cmipci_t *cm, int device)
 	return 0;
 }
 
-static int __devinit snd_cmipci_pcm2_new(cmipci_t *cm, int device)
+static int __devinit snd_cmipci_pcm2_new(struct cmipci *cm, int device)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	err = snd_pcm_new(cm->card, cm->card->driver, device, 1, 0, &pcm);
@@ -1738,9 +1735,9 @@ static int __devinit snd_cmipci_pcm2_new(cmipci_t *cm, int device)
 	return 0;
 }
 
-static int __devinit snd_cmipci_pcm_spdif_new(cmipci_t *cm, int device)
+static int __devinit snd_cmipci_pcm_spdif_new(struct cmipci *cm, int device)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	err = snd_pcm_new(cm->card, cm->card->driver, device, 1, 1, &pcm);
@@ -1770,13 +1767,13 @@ static int __devinit snd_cmipci_pcm_spdif_new(cmipci_t *cm, int device)
  *   - Output mute switches
  */
 
-static void snd_cmipci_mixer_write(cmipci_t *s, unsigned char idx, unsigned char data)
+static void snd_cmipci_mixer_write(struct cmipci *s, unsigned char idx, unsigned char data)
 {
 	outb(idx, s->iobase + CM_REG_SB16_ADDR);
 	outb(data, s->iobase + CM_REG_SB16_DATA);
 }
 
-static unsigned char snd_cmipci_mixer_read(cmipci_t *s, unsigned char idx)
+static unsigned char snd_cmipci_mixer_read(struct cmipci *s, unsigned char idx)
 {
 	unsigned char v;
 
@@ -1788,13 +1785,13 @@ static unsigned char snd_cmipci_mixer_read(cmipci_t *s, unsigned char idx)
 /*
  * general mixer element
  */
-typedef struct cmipci_sb_reg {
+struct cmipci_sb_reg {
 	unsigned int left_reg, right_reg;
 	unsigned int left_shift, right_shift;
 	unsigned int mask;
 	unsigned int invert: 1;
 	unsigned int stereo: 1;
-} cmipci_sb_reg_t;
+};
 
 #define COMPOSE_SB_REG(lreg,rreg,lshift,rshift,mask,invert,stereo) \
  ((lreg) | ((rreg) << 8) | (lshift << 16) | (rshift << 19) | (mask << 24) | (invert << 22) | (stereo << 23))
@@ -1811,7 +1808,7 @@ typedef struct cmipci_sb_reg {
 #define CMIPCI_SB_SW_STEREO(xname,lshift,rshift) CMIPCI_DOUBLE(xname, SB_DSP4_OUTPUT_SW, SB_DSP4_OUTPUT_SW, lshift, rshift, 1, 0, 1)
 #define CMIPCI_SB_SW_MONO(xname,shift) CMIPCI_DOUBLE(xname, SB_DSP4_OUTPUT_SW, SB_DSP4_OUTPUT_SW, shift, shift, 1, 0, 0)
 
-static void cmipci_sb_reg_decode(cmipci_sb_reg_t *r, unsigned long val)
+static void cmipci_sb_reg_decode(struct cmipci_sb_reg *r, unsigned long val)
 {
 	r->left_reg = val & 0xff;
 	r->right_reg = (val >> 8) & 0xff;
@@ -1822,9 +1819,10 @@ static void cmipci_sb_reg_decode(cmipci_sb_reg_t *r, unsigned long val)
 	r->mask = (val >> 24) & 0xff;
 }
 
-static int snd_cmipci_info_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_cmipci_info_volume(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_info *uinfo)
 {
-	cmipci_sb_reg_t reg;
+	struct cmipci_sb_reg reg;
 
 	cmipci_sb_reg_decode(&reg, kcontrol->private_value);
 	uinfo->type = reg.mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
@@ -1834,10 +1832,11 @@ static int snd_cmipci_info_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t
 	return 0;
 }
  
-static int snd_cmipci_get_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_cmipci_get_volume(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
-	cmipci_sb_reg_t reg;
+	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
+	struct cmipci_sb_reg reg;
 	int val;
 
 	cmipci_sb_reg_decode(&reg, kcontrol->private_value);
@@ -1856,10 +1855,11 @@ static int snd_cmipci_get_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	return 0;
 }
 
-static int snd_cmipci_put_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_cmipci_put_volume(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
-	cmipci_sb_reg_t reg;
+	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
+	struct cmipci_sb_reg reg;
 	int change;
 	int left, right, oleft, oright;
 
@@ -1904,7 +1904,8 @@ static int snd_cmipci_put_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
   .private_value = COMPOSE_SB_REG(SB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT, left_shift, right_shift, 1, 0, 1), \
 }
 
-static int snd_cmipci_info_input_sw(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_cmipci_info_input_sw(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 4;
@@ -1913,10 +1914,11 @@ static int snd_cmipci_info_input_sw(snd_kcontrol_t * kcontrol, snd_ctl_elem_info
 	return 0;
 }
  
-static int snd_cmipci_get_input_sw(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_cmipci_get_input_sw(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
-	cmipci_sb_reg_t reg;
+	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
+	struct cmipci_sb_reg reg;
 	int val1, val2;
 
 	cmipci_sb_reg_decode(&reg, kcontrol->private_value);
@@ -1931,10 +1933,11 @@ static int snd_cmipci_get_input_sw(snd_kcontrol_t * kcontrol, snd_ctl_elem_value
 	return 0;
 }
 
-static int snd_cmipci_put_input_sw(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_cmipci_put_input_sw(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
-	cmipci_sb_reg_t reg;
+	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
+	struct cmipci_sb_reg reg;
 	int change;
 	int val1, val2, oval1, oval2;
 
@@ -1987,9 +1990,10 @@ static int snd_cmipci_put_input_sw(snd_kcontrol_t * kcontrol, snd_ctl_elem_value
   .private_value = COMPOSE_SB_REG(reg, reg, shift, shift, mask, 0, 0), \
 }
 
-static int snd_cmipci_info_native_mixer(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int snd_cmipci_info_native_mixer(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_info *uinfo)
 {
-	cmipci_sb_reg_t reg;
+	struct cmipci_sb_reg reg;
 
 	cmipci_sb_reg_decode(&reg, kcontrol->private_value);
 	uinfo->type = reg.mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
@@ -2000,10 +2004,11 @@ static int snd_cmipci_info_native_mixer(snd_kcontrol_t *kcontrol, snd_ctl_elem_i
 
 }
 
-static int snd_cmipci_get_native_mixer(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_cmipci_get_native_mixer(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
-	cmipci_sb_reg_t reg;
+	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
+	struct cmipci_sb_reg reg;
 	unsigned char oreg, val;
 
 	cmipci_sb_reg_decode(&reg, kcontrol->private_value);
@@ -2023,10 +2028,11 @@ static int snd_cmipci_get_native_mixer(snd_kcontrol_t * kcontrol, snd_ctl_elem_v
 	return 0;
 }
 
-static int snd_cmipci_put_native_mixer(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_cmipci_put_native_mixer(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
-	cmipci_sb_reg_t reg;
+	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
+	struct cmipci_sb_reg reg;
 	unsigned char oreg, nreg, val;
 
 	cmipci_sb_reg_decode(&reg, kcontrol->private_value);
@@ -2052,15 +2058,17 @@ static int snd_cmipci_put_native_mixer(snd_kcontrol_t * kcontrol, snd_ctl_elem_v
 /*
  * special case - check mixer sensitivity
  */
-static int snd_cmipci_get_native_mixer_sensitive(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_cmipci_get_native_mixer_sensitive(struct snd_kcontrol *kcontrol,
+						 struct snd_ctl_elem_value *ucontrol)
 {
-	//cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	//struct cmipci *cm = snd_kcontrol_chip(kcontrol);
 	return snd_cmipci_get_native_mixer(kcontrol, ucontrol);
 }
 
-static int snd_cmipci_put_native_mixer_sensitive(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_cmipci_put_native_mixer_sensitive(struct snd_kcontrol *kcontrol,
+						 struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
 	if (cm->mixer_insensitive) {
 		/* ignored */
 		return 0;
@@ -2069,7 +2077,7 @@ static int snd_cmipci_put_native_mixer_sensitive(snd_kcontrol_t *kcontrol, snd_c
 }
 
 
-static snd_kcontrol_new_t snd_cmipci_mixers[] __devinitdata = {
+static struct snd_kcontrol_new snd_cmipci_mixers[] __devinitdata = {
 	CMIPCI_SB_VOL_STEREO("Master Playback Volume", SB_DSP4_MASTER_DEV, 3, 31),
 	CMIPCI_MIXER_SW_MONO("3D Control - Switch", CM_REG_MIXER1, CM_X3DEN_SHIFT, 0),
 	CMIPCI_SB_VOL_STEREO("PCM Playback Volume", SB_DSP4_PCM_DEV, 3, 31),
@@ -2111,15 +2119,18 @@ static snd_kcontrol_new_t snd_cmipci_mixers[] __devinitdata = {
  * other switches
  */
 
-typedef struct snd_cmipci_switch_args {
+struct cmipci_switch_args {
 	int reg;		/* register index */
 	unsigned int mask;	/* mask bits */
 	unsigned int mask_on;	/* mask bits to turn on */
 	unsigned int is_byte: 1;		/* byte access? */
-	unsigned int ac3_sensitive: 1;	/* access forbidden during non-audio operation? */
-} snd_cmipci_switch_args_t;
+	unsigned int ac3_sensitive: 1;	/* access forbidden during
+					 * non-audio operation?
+					 */
+};
 
-static int snd_cmipci_uswitch_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+static int snd_cmipci_uswitch_info(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
@@ -2128,10 +2139,12 @@ static int snd_cmipci_uswitch_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t
 	return 0;
 }
 
-static int _snd_cmipci_uswitch_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol, snd_cmipci_switch_args_t *args)
+static int _snd_cmipci_uswitch_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol,
+				   struct cmipci_switch_args *args)
 {
 	unsigned int val;
-	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&cm->reg_lock);
 	if (args->ac3_sensitive && cm->mixer_insensitive) {
@@ -2148,18 +2161,22 @@ static int _snd_cmipci_uswitch_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_
 	return 0;
 }
 
-static int snd_cmipci_uswitch_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_cmipci_uswitch_get(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
 {
-	snd_cmipci_switch_args_t *args = (snd_cmipci_switch_args_t*)kcontrol->private_value;
+	struct cmipci_switch_args *args;
+	args = (struct cmipci_switch_args *)kcontrol->private_value;
 	snd_assert(args != NULL, return -EINVAL);
 	return _snd_cmipci_uswitch_get(kcontrol, ucontrol, args);
 }
 
-static int _snd_cmipci_uswitch_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol, snd_cmipci_switch_args_t *args)
+static int _snd_cmipci_uswitch_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol,
+				   struct cmipci_switch_args *args)
 {
 	unsigned int val;
 	int change;
-	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&cm->reg_lock);
 	if (args->ac3_sensitive && cm->mixer_insensitive) {
@@ -2187,15 +2204,17 @@ static int _snd_cmipci_uswitch_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_
 	return change;
 }
 
-static int snd_cmipci_uswitch_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_cmipci_uswitch_put(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
 {
-	snd_cmipci_switch_args_t *args = (snd_cmipci_switch_args_t*)kcontrol->private_value;
+	struct cmipci_switch_args *args;
+	args = (struct cmipci_switch_args *)kcontrol->private_value;
 	snd_assert(args != NULL, return -EINVAL);
 	return _snd_cmipci_uswitch_put(kcontrol, ucontrol, args);
 }
 
 #define DEFINE_SWITCH_ARG(sname, xreg, xmask, xmask_on, xis_byte, xac3) \
-static snd_cmipci_switch_args_t cmipci_switch_arg_##sname = { \
+static struct cmipci_switch_args cmipci_switch_arg_##sname = { \
   .reg = xreg, \
   .mask = xmask, \
   .mask_on = xmask_on, \
@@ -2252,7 +2271,8 @@ DEFINE_SWITCH_ARG(modem, CM_REG_MISC_CTRL, CM_FLINKON|CM_FLINKOFF, CM_FLINKON, 0
  * callbacks for spdif output switch
  * needs toggle two registers..
  */
-static int snd_cmipci_spdout_enable_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_cmipci_spdout_enable_get(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
 {
 	int changed;
 	changed = _snd_cmipci_uswitch_get(kcontrol, ucontrol, &cmipci_switch_arg_spdif_enable);
@@ -2260,9 +2280,10 @@ static int snd_cmipci_spdout_enable_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_v
 	return changed;
 }
 
-static int snd_cmipci_spdout_enable_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+static int snd_cmipci_spdout_enable_put(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *chip = snd_kcontrol_chip(kcontrol);
+	struct cmipci *chip = snd_kcontrol_chip(kcontrol);
 	int changed;
 	changed = _snd_cmipci_uswitch_put(kcontrol, ucontrol, &cmipci_switch_arg_spdif_enable);
 	changed |= _snd_cmipci_uswitch_put(kcontrol, ucontrol, &cmipci_switch_arg_spdo2dac);
@@ -2280,10 +2301,10 @@ static int snd_cmipci_spdout_enable_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_v
 }
 
 
-static int snd_cmipci_line_in_mode_info(snd_kcontrol_t *kcontrol,
-					snd_ctl_elem_info_t *uinfo)
+static int snd_cmipci_line_in_mode_info(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_info *uinfo)
 {
-	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
 	static char *texts[3] = { "Line-In", "Rear Output", "Bass Output" };
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
@@ -2294,7 +2315,7 @@ static int snd_cmipci_line_in_mode_info(snd_kcontrol_t *kcontrol,
 	return 0;
 }
 
-static inline unsigned int get_line_in_mode(cmipci_t *cm)
+static inline unsigned int get_line_in_mode(struct cmipci *cm)
 {
 	unsigned int val;
 	if (cm->chip_version >= 39) {
@@ -2308,10 +2329,10 @@ static inline unsigned int get_line_in_mode(cmipci_t *cm)
 	return 0;
 }
 
-static int snd_cmipci_line_in_mode_get(snd_kcontrol_t *kcontrol,
-				       snd_ctl_elem_value_t *ucontrol)
+static int snd_cmipci_line_in_mode_get(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&cm->reg_lock);
 	ucontrol->value.enumerated.item[0] = get_line_in_mode(cm);
@@ -2319,10 +2340,10 @@ static int snd_cmipci_line_in_mode_get(snd_kcontrol_t *kcontrol,
 	return 0;
 }
 
-static int snd_cmipci_line_in_mode_put(snd_kcontrol_t *kcontrol,
-				       snd_ctl_elem_value_t *ucontrol)
+static int snd_cmipci_line_in_mode_put(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
 	int change;
 
 	spin_lock_irq(&cm->reg_lock);
@@ -2338,8 +2359,8 @@ static int snd_cmipci_line_in_mode_put(snd_kcontrol_t *kcontrol,
 	return change;
 }
 
-static int snd_cmipci_mic_in_mode_info(snd_kcontrol_t *kcontrol,
-				       snd_ctl_elem_info_t *uinfo)
+static int snd_cmipci_mic_in_mode_info(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[2] = { "Mic-In", "Center/LFE Output" };
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
@@ -2351,10 +2372,10 @@ static int snd_cmipci_mic_in_mode_info(snd_kcontrol_t *kcontrol,
 	return 0;
 }
 
-static int snd_cmipci_mic_in_mode_get(snd_kcontrol_t *kcontrol,
-				      snd_ctl_elem_value_t *ucontrol)
+static int snd_cmipci_mic_in_mode_get(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
 	/* same bit as spdi_phase */
 	spin_lock_irq(&cm->reg_lock);
 	ucontrol->value.enumerated.item[0] = 
@@ -2363,10 +2384,10 @@ static int snd_cmipci_mic_in_mode_get(snd_kcontrol_t *kcontrol,
 	return 0;
 }
 
-static int snd_cmipci_mic_in_mode_put(snd_kcontrol_t *kcontrol,
-				      snd_ctl_elem_value_t *ucontrol)
+static int snd_cmipci_mic_in_mode_put(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
 {
-	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	struct cmipci *cm = snd_kcontrol_chip(kcontrol);
 	int change;
 
 	spin_lock_irq(&cm->reg_lock);
@@ -2379,7 +2400,7 @@ static int snd_cmipci_mic_in_mode_put(snd_kcontrol_t *kcontrol,
 }
 
 /* both for CM8338/8738 */
-static snd_kcontrol_new_t snd_cmipci_mixer_switches[] __devinitdata = {
+static struct snd_kcontrol_new snd_cmipci_mixer_switches[] __devinitdata = {
 	DEFINE_MIXER_SWITCH("Four Channel Mode", fourch),
 	{
 		.name = "Line-In Mode",
@@ -2391,11 +2412,11 @@ static snd_kcontrol_new_t snd_cmipci_mixer_switches[] __devinitdata = {
 };
 
 /* for non-multichannel chips */
-static snd_kcontrol_new_t snd_cmipci_nomulti_switch __devinitdata =
+static struct snd_kcontrol_new snd_cmipci_nomulti_switch __devinitdata =
 DEFINE_MIXER_SWITCH("Exchange DAC", exchange_dac);
 
 /* only for CM8738 */
-static snd_kcontrol_new_t snd_cmipci_8738_mixer_switches[] __devinitdata = {
+static struct snd_kcontrol_new snd_cmipci_8738_mixer_switches[] __devinitdata = {
 #if 0 /* controlled in pcm device */
 	DEFINE_MIXER_SWITCH("IEC958 In Record", spdif_in),
 	DEFINE_MIXER_SWITCH("IEC958 Out", spdif_out),
@@ -2417,14 +2438,14 @@ static snd_kcontrol_new_t snd_cmipci_8738_mixer_switches[] __devinitdata = {
 };
 
 /* only for model 033/037 */
-static snd_kcontrol_new_t snd_cmipci_old_mixer_switches[] __devinitdata = {
+static struct snd_kcontrol_new snd_cmipci_old_mixer_switches[] __devinitdata = {
 	DEFINE_MIXER_SWITCH("IEC958 Mix Analog", spdif_dac_out),
 	DEFINE_MIXER_SWITCH("IEC958 In Phase Inverse", spdi_phase),
 	DEFINE_MIXER_SWITCH("IEC958 In Select", spdif_in_sel1),
 };
 
 /* only for model 039 or later */
-static snd_kcontrol_new_t snd_cmipci_extra_mixer_switches[] __devinitdata = {
+static struct snd_kcontrol_new snd_cmipci_extra_mixer_switches[] __devinitdata = {
 	DEFINE_MIXER_SWITCH("IEC958 In Select", spdif_in_sel2),
 	DEFINE_MIXER_SWITCH("IEC958 In Phase Inverse", spdi_phase2),
 	{
@@ -2437,17 +2458,17 @@ static snd_kcontrol_new_t snd_cmipci_extra_mixer_switches[] __devinitdata = {
 };
 
 /* card control switches */
-static snd_kcontrol_new_t snd_cmipci_control_switches[] __devinitdata = {
+static struct snd_kcontrol_new snd_cmipci_control_switches[] __devinitdata = {
 	// DEFINE_CARD_SWITCH("Joystick", joystick), /* now module option */
 	DEFINE_CARD_SWITCH("Modem", modem),
 };
 
 
-static int __devinit snd_cmipci_mixer_new(cmipci_t *cm, int pcm_spdif_device)
+static int __devinit snd_cmipci_mixer_new(struct cmipci *cm, int pcm_spdif_device)
 {
-	snd_card_t *card;
-	snd_kcontrol_new_t *sw;
-	snd_kcontrol_t *kctl;
+	struct snd_card *card;
+	struct snd_kcontrol_new *sw;
+	struct snd_kcontrol *kctl;
 	unsigned int idx;
 	int err;
 
@@ -2529,8 +2550,8 @@ static int __devinit snd_cmipci_mixer_new(cmipci_t *cm, int pcm_spdif_device)
 	}
 
 	for (idx = 0; idx < CM_SAVED_MIXERS; idx++) {
-		snd_ctl_elem_id_t id;
-		snd_kcontrol_t *ctl;
+		struct snd_ctl_elem_id id;
+		struct snd_kcontrol *ctl;
 		memset(&id, 0, sizeof(id));
 		id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 		strcpy(id.name, cm_saved_mixer[idx].name);
@@ -2547,10 +2568,10 @@ static int __devinit snd_cmipci_mixer_new(cmipci_t *cm, int pcm_spdif_device)
  */
 
 #ifdef CONFIG_PROC_FS
-static void snd_cmipci_proc_read(snd_info_entry_t *entry, 
-				 snd_info_buffer_t *buffer)
+static void snd_cmipci_proc_read(struct snd_info_entry *entry, 
+				 struct snd_info_buffer *buffer)
 {
-	cmipci_t *cm = entry->private_data;
+	struct cmipci *cm = entry->private_data;
 	int i;
 	
 	snd_iprintf(buffer, "%s\n\n", cm->card->longname);
@@ -2566,15 +2587,15 @@ static void snd_cmipci_proc_read(snd_info_entry_t *entry,
 	}
 }
 
-static void __devinit snd_cmipci_proc_init(cmipci_t *cm)
+static void __devinit snd_cmipci_proc_init(struct cmipci *cm)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(cm->card, "cmipci", &entry))
 		snd_info_set_text_ops(entry, cm, 1024, snd_cmipci_proc_read);
 }
 #else /* !CONFIG_PROC_FS */
-static inline void snd_cmipci_proc_init(cmipci_t *cm) {}
+static inline void snd_cmipci_proc_init(struct cmipci *cm) {}
 #endif
 
 
@@ -2592,7 +2613,7 @@ static struct pci_device_id snd_cmipci_ids[] = {
  * check chip version and capabilities
  * driver name is modified according to the chip model
  */
-static void __devinit query_chip(cmipci_t *cm)
+static void __devinit query_chip(struct cmipci *cm)
 {
 	unsigned int detect;
 
@@ -2645,7 +2666,7 @@ static void __devinit query_chip(cmipci_t *cm)
 }
 
 #ifdef SUPPORT_JOYSTICK
-static int __devinit snd_cmipci_create_gameport(cmipci_t *cm, int dev)
+static int __devinit snd_cmipci_create_gameport(struct cmipci *cm, int dev)
 {
 	static int ports[] = { 0x201, 0x200, 0 }; /* FIXME: majority is 0x201? */
 	struct gameport *gp;
@@ -2691,7 +2712,7 @@ static int __devinit snd_cmipci_create_gameport(cmipci_t *cm, int dev)
 	return 0;
 }
 
-static void snd_cmipci_free_gameport(cmipci_t *cm)
+static void snd_cmipci_free_gameport(struct cmipci *cm)
 {
 	if (cm->gameport) {
 		struct resource *r = gameport_get_port_data(cm->gameport);
@@ -2704,11 +2725,11 @@ static void snd_cmipci_free_gameport(cmipci_t *cm)
 	}
 }
 #else
-static inline int snd_cmipci_create_gameport(cmipci_t *cm, int dev) { return -ENOSYS; }
-static inline void snd_cmipci_free_gameport(cmipci_t *cm) { }
+static inline int snd_cmipci_create_gameport(struct cmipci *cm, int dev) { return -ENOSYS; }
+static inline void snd_cmipci_free_gameport(struct cmipci *cm) { }
 #endif
 
-static int snd_cmipci_free(cmipci_t *cm)
+static int snd_cmipci_free(struct cmipci *cm)
 {
 	if (cm->irq >= 0) {
 		snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);
@@ -2724,7 +2745,7 @@ static int snd_cmipci_free(cmipci_t *cm)
 
 		synchronize_irq(cm->irq);
 
-		free_irq(cm->irq, (void *)cm);
+		free_irq(cm->irq, cm);
 	}
 
 	snd_cmipci_free_gameport(cm);
@@ -2734,17 +2755,17 @@ static int snd_cmipci_free(cmipci_t *cm)
 	return 0;
 }
 
-static int snd_cmipci_dev_free(snd_device_t *device)
+static int snd_cmipci_dev_free(struct snd_device *device)
 {
-	cmipci_t *cm = device->device_data;
+	struct cmipci *cm = device->device_data;
 	return snd_cmipci_free(cm);
 }
 
-static int __devinit snd_cmipci_create_fm(cmipci_t *cm, long fm_port)
+static int __devinit snd_cmipci_create_fm(struct cmipci *cm, long fm_port)
 {
 	long iosynth;
 	unsigned int val;
-	opl3_t *opl3;
+	struct snd_opl3 *opl3;
 	int err;
 
 	/* first try FM regs in PCI port range */
@@ -2785,12 +2806,12 @@ static int __devinit snd_cmipci_create_fm(cmipci_t *cm, long fm_port)
 	return 0;
 }
 
-static int __devinit snd_cmipci_create(snd_card_t *card, struct pci_dev *pci,
-				       int dev, cmipci_t **rcmipci)
+static int __devinit snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,
+				       int dev, struct cmipci **rcmipci)
 {
-	cmipci_t *cm;
+	struct cmipci *cm;
 	int err;
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free =	snd_cmipci_dev_free,
 	};
 	unsigned int val = 0;
@@ -2830,7 +2851,8 @@ static int __devinit snd_cmipci_create(snd_card_t *card, struct pci_dev *pci,
 	}
 	cm->iobase = pci_resource_start(pci, 0);
 
-	if (request_irq(pci->irq, snd_cmipci_interrupt, SA_INTERRUPT|SA_SHIRQ, card->driver, (void *)cm)) {
+	if (request_irq(pci->irq, snd_cmipci_interrupt,
+			SA_INTERRUPT|SA_SHIRQ, card->driver, cm)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_cmipci_free(cm);
 		return -EBUSY;
@@ -2983,8 +3005,8 @@ static int __devinit snd_cmipci_probe(struct pci_dev *pci,
 				      const struct pci_device_id *pci_id)
 {
 	static int dev;
-	snd_card_t *card;
-	cmipci_t *cm;
+	struct snd_card *card;
+	struct cmipci *cm;
 	int err;
 
 	if (dev >= SNDRV_CARDS)

commit c3e6f7d8763fa0400d28c57633eb323515ba05fc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 16 18:43:35 2005 +0100

    [ALSA] Remove superfluous pcm_free callbacks
    
    Remove superflous pcm_free callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index db605373b3bc..0309689f37f5 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1693,11 +1693,6 @@ static snd_pcm_ops_t snd_cmipci_capture_spdif_ops = {
 /*
  */
 
-static void snd_cmipci_pcm_free(snd_pcm_t *pcm)
-{
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
 static int __devinit snd_cmipci_pcm_new(cmipci_t *cm, int device)
 {
 	snd_pcm_t *pcm;
@@ -1711,7 +1706,6 @@ static int __devinit snd_cmipci_pcm_new(cmipci_t *cm, int device)
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cmipci_capture_ops);
 
 	pcm->private_data = cm;
-	pcm->private_free = snd_cmipci_pcm_free;
 	pcm->info_flags = 0;
 	strcpy(pcm->name, "C-Media PCI DAC/ADC");
 	cm->pcm = pcm;
@@ -1734,7 +1728,6 @@ static int __devinit snd_cmipci_pcm2_new(cmipci_t *cm, int device)
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cmipci_playback2_ops);
 
 	pcm->private_data = cm;
-	pcm->private_free = snd_cmipci_pcm_free;
 	pcm->info_flags = 0;
 	strcpy(pcm->name, "C-Media PCI 2nd DAC");
 	cm->pcm2 = pcm;
@@ -1758,7 +1751,6 @@ static int __devinit snd_cmipci_pcm_spdif_new(cmipci_t *cm, int device)
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cmipci_capture_spdif_ops);
 
 	pcm->private_data = cm;
-	pcm->private_free = snd_cmipci_pcm_free;
 	pcm->info_flags = 0;
 	strcpy(pcm->name, "C-Media PCI IEC958");
 	cm->pcm_spdif = pcm;

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 57e8e433d56f..db605373b3bc 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3053,7 +3053,6 @@ static void __devexit snd_cmipci_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "C-Media PCI",
-	.owner = THIS_MODULE,
 	.id_table = snd_cmipci_ids,
 	.probe = snd_cmipci_probe,
 	.remove = __devexit_p(snd_cmipci_remove),

commit 99b359ba10a582148c6725f428a33ba5356dd993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 20 18:26:44 2005 +0200

    [ALSA] Add missing KERN_* suffix to printk
    
    Add missing KERN_* suffix to printk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index db093bca2cd0..57e8e433d56f 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2839,7 +2839,7 @@ static int __devinit snd_cmipci_create(snd_card_t *card, struct pci_dev *pci,
 	cm->iobase = pci_resource_start(pci, 0);
 
 	if (request_irq(pci->irq, snd_cmipci_interrupt, SA_INTERRUPT|SA_SHIRQ, card->driver, (void *)cm)) {
-		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_cmipci_free(cm);
 		return -EBUSY;
 	}

commit b1d5776d865951c213a1caaab5d8bf5de7615dbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:56:31 2005 +0200

    [ALSA] Remove vmalloc wrapper, kfree_nocheck()
    
    - Remove vmalloc wrapper
    - Add release_and_free_resource() to remove kfree_nocheck() from each driver
      and simplify the code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 316afb78488d..db093bca2cd0 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2683,8 +2683,7 @@ static int __devinit snd_cmipci_create_gameport(cmipci_t *cm, int dev)
 	cm->gameport = gp = gameport_allocate_port();
 	if (!gp) {
 		printk(KERN_ERR "cmipci: cannot allocate memory for gameport\n");
-		release_resource(r);
-		kfree_nocheck(r);
+		release_and_free_resource(r);
 		return -ENOMEM;
 	}
 	gameport_set_name(gp, "C-Media Gameport");
@@ -2709,8 +2708,7 @@ static void snd_cmipci_free_gameport(cmipci_t *cm)
 		cm->gameport = NULL;
 
 		snd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_JYSTK_EN);
-		release_resource(r);
-		kfree_nocheck(r);
+		release_and_free_resource(r);
 	}
 }
 #else

commit 5747e54042c710272cefed74cc457531a01768c9
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Sep 14 08:33:46 2005 +0200

    [ALSA] cmipci: use FM/MIDI ports in PCI port space
    
    Modules: CMIPCI driver
    
    If possible, use ports in the card's PCI port address range instead of
    the legacy ports.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 1eb3315d136d..316afb78488d 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -446,9 +446,6 @@ struct snd_stru_cmipci {
 	snd_kcontrol_t *mixer_res_ctl[CM_SAVED_MIXERS];
 	int mixer_res_status[CM_SAVED_MIXERS];
 
-	opl3_t *opl3;
-	snd_hwdep_t *opl3hwdep;
-
 	cmipci_pcm_t channel[2];	/* ch0 - DAC, ch1 - ADC or 2nd DAC */
 
 	/* external MIDI */
@@ -2753,6 +2750,51 @@ static int snd_cmipci_dev_free(snd_device_t *device)
 	return snd_cmipci_free(cm);
 }
 
+static int __devinit snd_cmipci_create_fm(cmipci_t *cm, long fm_port)
+{
+	long iosynth;
+	unsigned int val;
+	opl3_t *opl3;
+	int err;
+
+	/* first try FM regs in PCI port range */
+	iosynth = cm->iobase + CM_REG_FM_PCI;
+	err = snd_opl3_create(cm->card, iosynth, iosynth + 2,
+			      OPL3_HW_OPL3, 1, &opl3);
+	if (err < 0) {
+		/* then try legacy ports */
+		val = snd_cmipci_read(cm, CM_REG_LEGACY_CTRL) & ~CM_FMSEL_MASK;
+		iosynth = fm_port;
+		switch (iosynth) {
+		case 0x3E8: val |= CM_FMSEL_3E8; break;
+		case 0x3E0: val |= CM_FMSEL_3E0; break;
+		case 0x3C8: val |= CM_FMSEL_3C8; break;
+		case 0x388: val |= CM_FMSEL_388; break;
+		default:
+			    return 0;
+		}
+		snd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val);
+		/* enable FM */
+		snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);
+
+		if (snd_opl3_create(cm->card, iosynth, iosynth + 2,
+				    OPL3_HW_OPL3, 0, &opl3) < 0) {
+			printk(KERN_ERR "cmipci: no OPL device at %#lx, "
+			       "skipping...\n", iosynth);
+			/* disable FM */
+			snd_cmipci_write(cm, CM_REG_LEGACY_CTRL,
+					 val & ~CM_FMSEL_MASK);
+			snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);
+			return 0;
+		}
+	}
+	if ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {
+		printk(KERN_ERR "cmipci: cannot create OPL3 hwdep\n");
+		return err;
+	}
+	return 0;
+}
+
 static int __devinit snd_cmipci_create(snd_card_t *card, struct pci_dev *pci,
 				       int dev, cmipci_t **rcmipci)
 {
@@ -2762,8 +2804,8 @@ static int __devinit snd_cmipci_create(snd_card_t *card, struct pci_dev *pci,
 		.dev_free =	snd_cmipci_dev_free,
 	};
 	unsigned int val = 0;
-	long iomidi = mpu_port[dev];
-	long iosynth = fm_port[dev];
+	long iomidi;
+	int integrated_midi;
 	int pcm_index, pcm_spdif_index;
 	static struct pci_device_id intel_82437vx[] = {
 		{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82437VX) },
@@ -2867,52 +2909,28 @@ static int __devinit snd_cmipci_create(snd_card_t *card, struct pci_dev *pci,
 		return err;
 	}
 
-	/* set MPU address */
-	switch (iomidi) {
-	case 0x320: val = CM_VMPU_320; break;
-	case 0x310: val = CM_VMPU_310; break;
-	case 0x300: val = CM_VMPU_300; break;
-	case 0x330: val = CM_VMPU_330; break;
-	default:
-		iomidi = 0; break;
-	}
-	if (iomidi > 0) {
-		snd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val);
-		/* enable UART */
-		snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_UART_EN);
-	}
-
-	/* set FM address */
-	val = snd_cmipci_read(cm, CM_REG_LEGACY_CTRL) & ~CM_FMSEL_MASK;
-	switch (iosynth) {
-	case 0x3E8: val |= CM_FMSEL_3E8; break;
-	case 0x3E0: val |= CM_FMSEL_3E0; break;
-	case 0x3C8: val |= CM_FMSEL_3C8; break;
-	case 0x388: val |= CM_FMSEL_388; break;
-	default:
-		iosynth = 0; break;
-	}
-	if (iosynth > 0) {
-		snd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val);
-		/* enable FM */
-		snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);
-
-		if (snd_opl3_create(card, iosynth, iosynth + 2,
-				    OPL3_HW_OPL3, 0, &cm->opl3) < 0) {
-			printk(KERN_ERR "cmipci: no OPL device at 0x%lx, skipping...\n", iosynth);
-			iosynth = 0;
-		} else {
-			if ((err = snd_opl3_hwdep_new(cm->opl3, 0, 1, &cm->opl3hwdep)) < 0) {
-				printk(KERN_ERR "cmipci: cannot create OPL3 hwdep\n");
-				return err;
-			}
+	integrated_midi = snd_cmipci_read_b(cm, CM_REG_MPU_PCI) != 0xff;
+	if (integrated_midi)
+		iomidi = cm->iobase + CM_REG_MPU_PCI;
+	else {
+		iomidi = mpu_port[dev];
+		switch (iomidi) {
+		case 0x320: val = CM_VMPU_320; break;
+		case 0x310: val = CM_VMPU_310; break;
+		case 0x300: val = CM_VMPU_300; break;
+		case 0x330: val = CM_VMPU_330; break;
+		default:
+			    iomidi = 0; break;
+		}
+		if (iomidi > 0) {
+			snd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val);
+			/* enable UART */
+			snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_UART_EN);
 		}
 	}
-	if (! iosynth) {
-		/* disable FM */
-		snd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val & ~CM_FMSEL_MASK);
-		snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);
-	}
+
+	if ((err = snd_cmipci_create_fm(cm, fm_port[dev])) < 0)
+		return err;
 
 	/* reset mixer */
 	snd_cmipci_mixer_write(cm, 0, 0);
@@ -2941,7 +2959,7 @@ static int __devinit snd_cmipci_create(snd_card_t *card, struct pci_dev *pci,
 
 	if (iomidi > 0) {
 		if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_CMIPCI,
-					       iomidi, 0,
+					       iomidi, integrated_midi,
 					       cm->irq, 0, &cm->rmidi)) < 0) {
 			printk(KERN_ERR "cmipci: no UART401 device at 0x%lx\n", iomidi);
 		}

commit 3bcd4649bca99ee9242f20d7da35e3f8741c6549
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 12 08:20:54 2005 +0200

    [ALSA] set owner field in struct pci_driver
    
    AD1889 driver,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CS46xx driver,EMU10K1/EMU10K2 driver
    HDA Intel driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    MIXART driver,NM256 driver,RME HDSP driver,RME9652 driver
    Trident driver,Digigram VX222 driver,YMFPCI driver
    Set the module owner field in each driver's struct pci_driver to get
    the driver symlink in the sysfs device directory.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 583b2713d862..1eb3315d136d 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -3037,6 +3037,7 @@ static void __devexit snd_cmipci_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "C-Media PCI",
+	.owner = THIS_MODULE,
 	.id_table = snd_cmipci_ids,
 	.probe = snd_cmipci_probe,
 	.remove = __devexit_p(snd_cmipci_remove),

commit e560d8d8368ad8b6161839984b253de622863265
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:21:46 2005 +0200

    [ALSA] Replace with kzalloc() - pci stuff
    
    AD1889 driver,ATIIXP driver,ATIIXP-modem driver,AZT3328 driver
    BT87x driver,CMIPCI driver,CS4281 driver,ENS1370/1+ driver
    ES1938 driver,ES1968 driver,FM801 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,SonicVibes driver,VIA82xx driver
    VIA82xx-modem driver,AC97 Codec,AK4531 codec,au88x0 driver
    CA0106 driver,CS46xx driver,EMU10K1/EMU10K2 driver,HDA Codec driver
    HDA generic driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,Trident driver,YMFPCI driver
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 97ad90d47bc2..583b2713d862 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -2775,7 +2775,7 @@ static int __devinit snd_cmipci_create(snd_card_t *card, struct pci_dev *pci,
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 
-	cm = kcalloc(1, sizeof(*cm), GFP_KERNEL);
+	cm = kzalloc(sizeof(*cm), GFP_KERNEL);
 	if (cm == NULL) {
 		pci_disable_device(pci);
 		return -ENOMEM;

commit 8cdfd2519c6c9a1e6057dc5970b2542b35895738
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 7 14:08:11 2005 +0200

    [ALSA] Remove superfluous PCI ID definitions
    
    CS46xx driver,EMU10K1/EMU10K2 driver,PCM Midlevel,Trident driver
    YMFPCI driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,RME32 driver,RME96 driver
    SonicVibes driver,VIA82xx driver,ALI5451 driver,ICE1712 driver
    ICE1724 driver,NM256 driver,RME HDSP driver,RME9652 driver
    Remove superfluous PCI ID definitions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index b098b51099c2..97ad90d47bc2 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -79,13 +79,6 @@ module_param_array(joystick_port, int, NULL, 0444);
 MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #endif
 
-#ifndef PCI_DEVICE_ID_CMEDIA_CM8738
-#define PCI_DEVICE_ID_CMEDIA_CM8738	0x0111
-#endif
-#ifndef PCI_DEVICE_ID_CMEDIA_CM8738B
-#define PCI_DEVICE_ID_CMEDIA_CM8738B	0x0112
-#endif
-
 /*
  * CM8x38 registers definition
  */
@@ -347,25 +340,6 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_EXTENT_SYNTH	  0x4
 
 
-/*
- * pci ids
- */
-#ifndef PCI_VENDOR_ID_CMEDIA
-#define PCI_VENDOR_ID_CMEDIA         0x13F6
-#endif
-#ifndef PCI_DEVICE_ID_CMEDIA_CM8338A
-#define PCI_DEVICE_ID_CMEDIA_CM8338A 0x0100
-#endif
-#ifndef PCI_DEVICE_ID_CMEDIA_CM8338B
-#define PCI_DEVICE_ID_CMEDIA_CM8338B 0x0101
-#endif
-#ifndef PCI_DEVICE_ID_CMEDIA_CM8738
-#define PCI_DEVICE_ID_CMEDIA_CM8738  0x0111
-#endif
-#ifndef PCI_DEVICE_ID_CMEDIA_CM8738B
-#define PCI_DEVICE_ID_CMEDIA_CM8738B 0x0112
-#endif
-
 /*
  * channels for playback / capture
  */

commit 67ed4161f60d76b3b27efc085b36357a6a90768c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Jul 29 15:32:58 2005 +0200

    [ALSA] sound - fix .iface field of mixer control elements
    
    Documentation,CS46xx driver,EMU10K1/EMU10K2 driver,AD1848 driver
    SB16/AWE driver,CMIPCI driver,ENS1370/1+ driver,RME32 driver
    RME96 driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    RME HDSP driver,RME9652 driver
    This patch changes .iface to SNDRV_CTL_ELEM_IFACE_MIXER whre _PCM or
    _HWDEP was used in controls that are not associated with a specific PCM
    (sub)stream or hwdep device, and changes some controls that got
    inconsitent .iface values due to copy+paste errors.  Furthermore, it
    makes sure that all control that do use _PCM or _HWDEP use the correct
    number in the .device field.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index f5a4ac1ceef9..b098b51099c2 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -1029,7 +1029,7 @@ static int snd_cmipci_spdif_mask_get(snd_kcontrol_t * kcontrol,
 static snd_kcontrol_new_t snd_cmipci_spdif_mask __devinitdata =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
-	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,CON_MASK),
 	.info =		snd_cmipci_spdif_mask_info,
 	.get =		snd_cmipci_spdif_mask_get,

commit 2eff7ec81eb586076974cb0918dffc5f4ad763d5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jun 30 13:45:20 2005 +0200

    [ALSA] cmipci - Add Mic Boost capture switch
    
    CMIPCI driver
    Added 'Mic Boost Capture Switch' and 'Phone' switches.
    The existing playback switch is renamed as 'Mic Boost Playback Switch'.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 4725b4a010be..f5a4ac1ceef9 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -306,7 +306,7 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_REG_FM_PCI		0x50
 
 /*
- * for CMI-8338 .. this is not valid for CMI-8738.
+ * access from SB-mixer port
  */
 #define CM_REG_EXTENT_IND	0xf0
 #define CM_VPHONE_MASK		0xe0	/* Phone volume control (0-3) << 5 */
@@ -315,6 +315,7 @@ MODULE_PARM_DESC(joystick_port, "Joystick port address.");
 #define CM_VSPKM		0x08	/* Speaker mute control, default high */
 #define CM_RLOOPREN		0x04    /* Rec. R-channel enable */
 #define CM_RLOOPLEN		0x02	/* Rec. L-channel enable */
+#define CM_VADMIC3		0x01	/* Mic record boost */
 
 /*
  * CMI-8338 spec ver 0.5 (this is not valid for CMI-8738):
@@ -2135,8 +2136,12 @@ static snd_kcontrol_new_t snd_cmipci_mixers[] __devinitdata = {
 	CMIPCI_MIXER_VOL_STEREO("Aux Playback Volume", CM_REG_AUX_VOL, 4, 0, 15),
 	CMIPCI_MIXER_SW_STEREO("Aux Playback Switch", CM_REG_MIXER2, CM_VAUXLM_SHIFT, CM_VAUXRM_SHIFT, 0),
 	CMIPCI_MIXER_SW_STEREO("Aux Capture Switch", CM_REG_MIXER2, CM_RAUXLEN_SHIFT, CM_RAUXREN_SHIFT, 0),
-	CMIPCI_MIXER_SW_MONO("Mic Boost", CM_REG_MIXER2, CM_MICGAINZ_SHIFT, 1),
+	CMIPCI_MIXER_SW_MONO("Mic Boost Playback Switch", CM_REG_MIXER2, CM_MICGAINZ_SHIFT, 1),
 	CMIPCI_MIXER_VOL_MONO("Mic Capture Volume", CM_REG_MIXER2, CM_VADMIC_SHIFT, 7),
+	CMIPCI_SB_VOL_MONO("Phone Playback Volume", CM_REG_EXTENT_IND, 5, 7),
+	CMIPCI_DOUBLE("Phone Playback Switch", CM_REG_EXTENT_IND, CM_REG_EXTENT_IND, 4, 4, 1, 0, 0),
+	CMIPCI_DOUBLE("PC Speaker Playnack Switch", CM_REG_EXTENT_IND, CM_REG_EXTENT_IND, 3, 3, 1, 0, 0),
+	CMIPCI_DOUBLE("Mic Boost Capture Switch", CM_REG_EXTENT_IND, CM_REG_EXTENT_IND, 0, 0, 1, 0, 0),
 };
 
 /*

commit 77933d7276ee8fa0e2947641941a6f7a100a327b
Author: Jesper Juhl <juhl@dif.dk>
Date:   Wed Jul 27 11:46:09 2005 -0700

    [PATCH] clean up inline static vs static inline
    
    `gcc -W' likes to complain if the static keyword is not at the beginning of
    the declaration.  This patch fixes all remaining occurrences of "inline
    static" up with "static inline" in the entire kernel tree (140 occurrences in
    47 files).
    
    While making this change I came across a few lines with trailing whitespace
    that I also fixed up, I have also added or removed a blank line or two here
    and there, but there are no functional changes in the patch.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index b4503385ea69..4725b4a010be 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -488,32 +488,34 @@ struct snd_stru_cmipci {
 
 
 /* read/write operations for dword register */
-inline static void snd_cmipci_write(cmipci_t *cm, unsigned int cmd, unsigned int data)
+static inline void snd_cmipci_write(cmipci_t *cm, unsigned int cmd, unsigned int data)
 {
 	outl(data, cm->iobase + cmd);
 }
-inline static unsigned int snd_cmipci_read(cmipci_t *cm, unsigned int cmd)
+
+static inline unsigned int snd_cmipci_read(cmipci_t *cm, unsigned int cmd)
 {
 	return inl(cm->iobase + cmd);
 }
 
 /* read/write operations for word register */
-inline static void snd_cmipci_write_w(cmipci_t *cm, unsigned int cmd, unsigned short data)
+static inline void snd_cmipci_write_w(cmipci_t *cm, unsigned int cmd, unsigned short data)
 {
 	outw(data, cm->iobase + cmd);
 }
-inline static unsigned short snd_cmipci_read_w(cmipci_t *cm, unsigned int cmd)
+
+static inline unsigned short snd_cmipci_read_w(cmipci_t *cm, unsigned int cmd)
 {
 	return inw(cm->iobase + cmd);
 }
 
 /* read/write operations for byte register */
-inline static void snd_cmipci_write_b(cmipci_t *cm, unsigned int cmd, unsigned char data)
+static inline void snd_cmipci_write_b(cmipci_t *cm, unsigned int cmd, unsigned char data)
 {
 	outb(data, cm->iobase + cmd);
 }
 
-inline static unsigned char snd_cmipci_read_b(cmipci_t *cm, unsigned int cmd)
+static inline unsigned char snd_cmipci_read_b(cmipci_t *cm, unsigned int cmd)
 {
 	return inb(cm->iobase + cmd);
 }

commit 01d25d460a3b28aab537fab9a0038d1b5832ce28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 11 16:58:24 2005 +0200

    [ALSA] Replace pci_module_init() with pci_register_driver()
    
    Documentation,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CA0106 driver,CS46xx driver
    EMU10K1/EMU10K2 driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,RME HDSP driver
    RME9652 driver,Trident driver,Digigram VX222 driver,YMFPCI driver
    Replace the obsolete pci_module_init() with pci_register_driver().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
index 113208fbde1b..b4503385ea69 100644
--- a/sound/pci/cmipci.c
+++ b/sound/pci/cmipci.c
@@ -519,40 +519,50 @@ inline static unsigned char snd_cmipci_read_b(cmipci_t *cm, unsigned int cmd)
 }
 
 /* bit operations for dword register */
-static void snd_cmipci_set_bit(cmipci_t *cm, unsigned int cmd, unsigned int flag)
+static int snd_cmipci_set_bit(cmipci_t *cm, unsigned int cmd, unsigned int flag)
 {
-	unsigned int val;
-	val = inl(cm->iobase + cmd);
+	unsigned int val, oval;
+	val = oval = inl(cm->iobase + cmd);
 	val |= flag;
+	if (val == oval)
+		return 0;
 	outl(val, cm->iobase + cmd);
+	return 1;
 }
 
-static void snd_cmipci_clear_bit(cmipci_t *cm, unsigned int cmd, unsigned int flag)
+static int snd_cmipci_clear_bit(cmipci_t *cm, unsigned int cmd, unsigned int flag)
 {
-	unsigned int val;
-	val = inl(cm->iobase + cmd);
+	unsigned int val, oval;
+	val = oval = inl(cm->iobase + cmd);
 	val &= ~flag;
+	if (val == oval)
+		return 0;
 	outl(val, cm->iobase + cmd);
+	return 1;
 }
 
-#if 0 // not used
 /* bit operations for byte register */
-static void snd_cmipci_set_bit_b(cmipci_t *cm, unsigned int cmd, unsigned char flag)
+static int snd_cmipci_set_bit_b(cmipci_t *cm, unsigned int cmd, unsigned char flag)
 {
-	unsigned char val;
-	val = inb(cm->iobase + cmd);
+	unsigned char val, oval;
+	val = oval = inb(cm->iobase + cmd);
 	val |= flag;
+	if (val == oval)
+		return 0;
 	outb(val, cm->iobase + cmd);
+	return 1;
 }
 
-static void snd_cmipci_clear_bit_b(cmipci_t *cm, unsigned int cmd, unsigned char flag)
+static int snd_cmipci_clear_bit_b(cmipci_t *cm, unsigned int cmd, unsigned char flag)
 {
-	unsigned char val;
-	val = inb(cm->iobase + cmd);
+	unsigned char val, oval;
+	val = oval = inb(cm->iobase + cmd);
 	val &= ~flag;
+	if (val == oval)
+		return 0;
 	outb(val, cm->iobase + cmd);
+	return 1;
 }
-#endif
 
 
 /*
@@ -2250,8 +2260,8 @@ DEFINE_SWITCH_ARG(exchange_dac, CM_REG_MISC_CTRL, CM_XCHGDAC, 0, 0, 0); /* rever
 DEFINE_SWITCH_ARG(exchange_dac, CM_REG_MISC_CTRL, CM_XCHGDAC, CM_XCHGDAC, 0, 0);
 #endif
 DEFINE_BIT_SWITCH_ARG(fourch, CM_REG_MISC_CTRL, CM_N4SPK3D, 0, 0);
-DEFINE_BIT_SWITCH_ARG(line_rear, CM_REG_MIXER1, CM_SPK4, 1, 0);
-DEFINE_BIT_SWITCH_ARG(line_bass, CM_REG_LEGACY_CTRL, CM_LINE_AS_BASS, 0, 0);
+// DEFINE_BIT_SWITCH_ARG(line_rear, CM_REG_MIXER1, CM_SPK4, 1, 0);
+// DEFINE_BIT_SWITCH_ARG(line_bass, CM_REG_LEGACY_CTRL, CM_LINE_AS_BASS, 0, 0);
 // DEFINE_BIT_SWITCH_ARG(joystick, CM_REG_FUNCTRL1, CM_JYSTK_EN, 0, 0); /* now module option */
 DEFINE_SWITCH_ARG(modem, CM_REG_MISC_CTRL, CM_FLINKON|CM_FLINKOFF, CM_FLINKON, 0, 0);
 
@@ -2300,10 +2310,114 @@ static int snd_cmipci_spdout_enable_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_v
 }
 
 
+static int snd_cmipci_line_in_mode_info(snd_kcontrol_t *kcontrol,
+					snd_ctl_elem_info_t *uinfo)
+{
+	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	static char *texts[3] = { "Line-In", "Rear Output", "Bass Output" };
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = cm->chip_version >= 39 ? 3 : 2;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static inline unsigned int get_line_in_mode(cmipci_t *cm)
+{
+	unsigned int val;
+	if (cm->chip_version >= 39) {
+		val = snd_cmipci_read(cm, CM_REG_LEGACY_CTRL);
+		if (val & CM_LINE_AS_BASS)
+			return 2;
+	}
+	val = snd_cmipci_read_b(cm, CM_REG_MIXER1);
+	if (val & CM_SPK4)
+		return 1;
+	return 0;
+}
+
+static int snd_cmipci_line_in_mode_get(snd_kcontrol_t *kcontrol,
+				       snd_ctl_elem_value_t *ucontrol)
+{
+	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&cm->reg_lock);
+	ucontrol->value.enumerated.item[0] = get_line_in_mode(cm);
+	spin_unlock_irq(&cm->reg_lock);
+	return 0;
+}
+
+static int snd_cmipci_line_in_mode_put(snd_kcontrol_t *kcontrol,
+				       snd_ctl_elem_value_t *ucontrol)
+{
+	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	int change;
+
+	spin_lock_irq(&cm->reg_lock);
+	if (ucontrol->value.enumerated.item[0] == 2)
+		change = snd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_LINE_AS_BASS);
+	else
+		change = snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_LINE_AS_BASS);
+	if (ucontrol->value.enumerated.item[0] == 1)
+		change |= snd_cmipci_set_bit_b(cm, CM_REG_MIXER1, CM_SPK4);
+	else
+		change |= snd_cmipci_clear_bit_b(cm, CM_REG_MIXER1, CM_SPK4);
+	spin_unlock_irq(&cm->reg_lock);
+	return change;
+}
+
+static int snd_cmipci_mic_in_mode_info(snd_kcontrol_t *kcontrol,
+				       snd_ctl_elem_info_t *uinfo)
+{
+	static char *texts[2] = { "Mic-In", "Center/LFE Output" };
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_cmipci_mic_in_mode_get(snd_kcontrol_t *kcontrol,
+				      snd_ctl_elem_value_t *ucontrol)
+{
+	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	/* same bit as spdi_phase */
+	spin_lock_irq(&cm->reg_lock);
+	ucontrol->value.enumerated.item[0] = 
+		(snd_cmipci_read_b(cm, CM_REG_MISC) & CM_SPDIF_INVERSE) ? 1 : 0;
+	spin_unlock_irq(&cm->reg_lock);
+	return 0;
+}
+
+static int snd_cmipci_mic_in_mode_put(snd_kcontrol_t *kcontrol,
+				      snd_ctl_elem_value_t *ucontrol)
+{
+	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	int change;
+
+	spin_lock_irq(&cm->reg_lock);
+	if (ucontrol->value.enumerated.item[0])
+		change = snd_cmipci_set_bit_b(cm, CM_REG_MISC, CM_SPDIF_INVERSE);
+	else
+		change = snd_cmipci_clear_bit_b(cm, CM_REG_MISC, CM_SPDIF_INVERSE);
+	spin_unlock_irq(&cm->reg_lock);
+	return change;
+}
+
 /* both for CM8338/8738 */
 static snd_kcontrol_new_t snd_cmipci_mixer_switches[] __devinitdata = {
 	DEFINE_MIXER_SWITCH("Four Channel Mode", fourch),
-	DEFINE_MIXER_SWITCH("Line-In As Rear", line_rear),
+	{
+		.name = "Line-In Mode",
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.info = snd_cmipci_line_in_mode_info,
+		.get = snd_cmipci_line_in_mode_get,
+		.put = snd_cmipci_line_in_mode_put,
+	},
 };
 
 /* for non-multichannel chips */
@@ -2341,10 +2455,15 @@ static snd_kcontrol_new_t snd_cmipci_old_mixer_switches[] __devinitdata = {
 
 /* only for model 039 or later */
 static snd_kcontrol_new_t snd_cmipci_extra_mixer_switches[] __devinitdata = {
-	DEFINE_MIXER_SWITCH("Line-In As Bass", line_bass),
 	DEFINE_MIXER_SWITCH("IEC958 In Select", spdif_in_sel2),
 	DEFINE_MIXER_SWITCH("IEC958 In Phase Inverse", spdi_phase2),
-	DEFINE_MIXER_SWITCH("Mic As Center/LFE", spdi_phase), /* same bit as spdi_phase */
+	{
+		.name = "Mic-In Mode",
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.info = snd_cmipci_mic_in_mode_info,
+		.get = snd_cmipci_mic_in_mode_get,
+		.put = snd_cmipci_mic_in_mode_put,
+	}
 };
 
 /* card control switches */
@@ -2944,7 +3063,7 @@ static struct pci_driver driver = {
 	
 static int __init alsa_card_cmipci_init(void)
 {
-	return pci_module_init(&driver);
+	return pci_register_driver(&driver);
 }
 
 static void __exit alsa_card_cmipci_exit(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/cmipci.c b/sound/pci/cmipci.c
new file mode 100644
index 000000000000..113208fbde1b
--- /dev/null
+++ b/sound/pci/cmipci.c
@@ -0,0 +1,2956 @@
+/*
+ * Driver for C-Media CMI8338 and 8738 PCI soundcards.
+ * Copyright (c) 2000 by Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+ 
+/* Does not work. Warning may block system in capture mode */
+/* #define USE_VAR48KRATE */
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/gameport.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/rawmidi.h>
+#include <sound/mpu401.h>
+#include <sound/opl3.h>
+#include <sound/sb.h>
+#include <sound/asoundef.h>
+#include <sound/initval.h>
+
+MODULE_AUTHOR("Takashi Iwai <tiwai@suse.de>");
+MODULE_DESCRIPTION("C-Media CMI8x38 PCI");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{C-Media,CMI8738},"
+		"{C-Media,CMI8738B},"
+		"{C-Media,CMI8338A},"
+		"{C-Media,CMI8338B}}");
+
+#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+#define SUPPORT_JOYSTICK 1
+#endif
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
+static long mpu_port[SNDRV_CARDS];
+static long fm_port[SNDRV_CARDS];
+static int soft_ac3[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS-1)]=1};
+#ifdef SUPPORT_JOYSTICK
+static int joystick_port[SNDRV_CARDS];
+#endif
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for C-Media PCI soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for C-Media PCI soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable C-Media PCI soundcard.");
+module_param_array(mpu_port, long, NULL, 0444);
+MODULE_PARM_DESC(mpu_port, "MPU-401 port.");
+module_param_array(fm_port, long, NULL, 0444);
+MODULE_PARM_DESC(fm_port, "FM port.");
+module_param_array(soft_ac3, bool, NULL, 0444);
+MODULE_PARM_DESC(soft_ac3, "Sofware-conversion of raw SPDIF packets (model 033 only).");
+#ifdef SUPPORT_JOYSTICK
+module_param_array(joystick_port, int, NULL, 0444);
+MODULE_PARM_DESC(joystick_port, "Joystick port address.");
+#endif
+
+#ifndef PCI_DEVICE_ID_CMEDIA_CM8738
+#define PCI_DEVICE_ID_CMEDIA_CM8738	0x0111
+#endif
+#ifndef PCI_DEVICE_ID_CMEDIA_CM8738B
+#define PCI_DEVICE_ID_CMEDIA_CM8738B	0x0112
+#endif
+
+/*
+ * CM8x38 registers definition
+ */
+
+#define CM_REG_FUNCTRL0		0x00
+#define CM_RST_CH1		0x00080000
+#define CM_RST_CH0		0x00040000
+#define CM_CHEN1		0x00020000	/* ch1: enable */
+#define CM_CHEN0		0x00010000	/* ch0: enable */
+#define CM_PAUSE1		0x00000008	/* ch1: pause */
+#define CM_PAUSE0		0x00000004	/* ch0: pause */
+#define CM_CHADC1		0x00000002	/* ch1, 0:playback, 1:record */
+#define CM_CHADC0		0x00000001	/* ch0, 0:playback, 1:record */
+
+#define CM_REG_FUNCTRL1		0x04
+#define CM_ASFC_MASK		0x0000E000	/* ADC sampling frequency */
+#define CM_ASFC_SHIFT		13
+#define CM_DSFC_MASK		0x00001C00	/* DAC sampling frequency */
+#define CM_DSFC_SHIFT		10
+#define CM_SPDF_1		0x00000200	/* SPDIF IN/OUT at channel B */
+#define CM_SPDF_0		0x00000100	/* SPDIF OUT only channel A */
+#define CM_SPDFLOOP		0x00000080	/* ext. SPDIIF/OUT -> IN loopback */
+#define CM_SPDO2DAC		0x00000040	/* SPDIF/OUT can be heard from internal DAC */
+#define CM_INTRM		0x00000020	/* master control block (MCB) interrupt enabled */
+#define CM_BREQ			0x00000010	/* bus master enabled */
+#define CM_VOICE_EN		0x00000008	/* legacy voice (SB16,FM) */
+#define CM_UART_EN		0x00000004	/* UART */
+#define CM_JYSTK_EN		0x00000002	/* joy stick */
+
+#define CM_REG_CHFORMAT		0x08
+
+#define CM_CHB3D5C		0x80000000	/* 5,6 channels */
+#define CM_CHB3D		0x20000000	/* 4 channels */
+
+#define CM_CHIP_MASK1		0x1f000000
+#define CM_CHIP_037		0x01000000
+
+#define CM_SPDIF_SELECT1	0x00080000	/* for model <= 037 ? */
+#define CM_AC3EN1		0x00100000	/* enable AC3: model 037 */
+#define CM_SPD24SEL		0x00020000	/* 24bit spdif: model 037 */
+/* #define CM_SPDIF_INVERSE	0x00010000 */ /* ??? */
+
+#define CM_ADCBITLEN_MASK	0x0000C000	
+#define CM_ADCBITLEN_16		0x00000000
+#define CM_ADCBITLEN_15		0x00004000
+#define CM_ADCBITLEN_14		0x00008000
+#define CM_ADCBITLEN_13		0x0000C000
+
+#define CM_ADCDACLEN_MASK	0x00003000
+#define CM_ADCDACLEN_060	0x00000000
+#define CM_ADCDACLEN_066	0x00001000
+#define CM_ADCDACLEN_130	0x00002000
+#define CM_ADCDACLEN_280	0x00003000
+
+#define CM_CH1_SRATE_176K	0x00000800
+#define CM_CH1_SRATE_88K	0x00000400
+#define CM_CH0_SRATE_176K	0x00000200
+#define CM_CH0_SRATE_88K	0x00000100
+
+#define CM_SPDIF_INVERSE2	0x00000080	/* model 055? */
+
+#define CM_CH1FMT_MASK		0x0000000C
+#define CM_CH1FMT_SHIFT		2
+#define CM_CH0FMT_MASK		0x00000003
+#define CM_CH0FMT_SHIFT		0
+
+#define CM_REG_INT_HLDCLR	0x0C
+#define CM_CHIP_MASK2		0xff000000
+#define CM_CHIP_039		0x04000000
+#define CM_CHIP_039_6CH		0x01000000
+#define CM_CHIP_055		0x08000000
+#define CM_CHIP_8768		0x20000000
+#define CM_TDMA_INT_EN		0x00040000
+#define CM_CH1_INT_EN		0x00020000
+#define CM_CH0_INT_EN		0x00010000
+#define CM_INT_HOLD		0x00000002
+#define CM_INT_CLEAR		0x00000001
+
+#define CM_REG_INT_STATUS	0x10
+#define CM_INTR			0x80000000
+#define CM_VCO			0x08000000	/* Voice Control? CMI8738 */
+#define CM_MCBINT		0x04000000	/* Master Control Block abort cond.? */
+#define CM_UARTINT		0x00010000
+#define CM_LTDMAINT		0x00008000
+#define CM_HTDMAINT		0x00004000
+#define CM_XDO46		0x00000080	/* Modell 033? Direct programming EEPROM (read data register) */
+#define CM_LHBTOG		0x00000040	/* High/Low status from DMA ctrl register */
+#define CM_LEG_HDMA		0x00000020	/* Legacy is in High DMA channel */
+#define CM_LEG_STEREO		0x00000010	/* Legacy is in Stereo mode */
+#define CM_CH1BUSY		0x00000008
+#define CM_CH0BUSY		0x00000004
+#define CM_CHINT1		0x00000002
+#define CM_CHINT0		0x00000001
+
+#define CM_REG_LEGACY_CTRL	0x14
+#define CM_NXCHG		0x80000000	/* h/w multi channels? */
+#define CM_VMPU_MASK		0x60000000	/* MPU401 i/o port address */
+#define CM_VMPU_330		0x00000000
+#define CM_VMPU_320		0x20000000
+#define CM_VMPU_310		0x40000000
+#define CM_VMPU_300		0x60000000
+#define CM_VSBSEL_MASK		0x0C000000	/* SB16 base address */
+#define CM_VSBSEL_220		0x00000000
+#define CM_VSBSEL_240		0x04000000
+#define CM_VSBSEL_260		0x08000000
+#define CM_VSBSEL_280		0x0C000000
+#define CM_FMSEL_MASK		0x03000000	/* FM OPL3 base address */
+#define CM_FMSEL_388		0x00000000
+#define CM_FMSEL_3C8		0x01000000
+#define CM_FMSEL_3E0		0x02000000
+#define CM_FMSEL_3E8		0x03000000
+#define CM_ENSPDOUT		0x00800000	/* enable XPDIF/OUT to I/O interface */
+#define CM_SPDCOPYRHT		0x00400000	/* set copyright spdif in/out */
+#define CM_DAC2SPDO		0x00200000	/* enable wave+fm_midi -> SPDIF/OUT */
+#define CM_SETRETRY		0x00010000	/* 0: legacy i/o wait (default), 1: legacy i/o bus retry */
+#define CM_CHB3D6C		0x00008000	/* 5.1 channels support */
+#define CM_LINE_AS_BASS		0x00006000	/* use line-in as bass */
+
+#define CM_REG_MISC_CTRL	0x18
+#define CM_PWD			0x80000000
+#define CM_RESET		0x40000000
+#define CM_SFIL_MASK		0x30000000
+#define CM_TXVX			0x08000000
+#define CM_N4SPK3D		0x04000000	/* 4ch output */
+#define CM_SPDO5V		0x02000000	/* 5V spdif output (1 = 0.5v (coax)) */
+#define CM_SPDIF48K		0x01000000	/* write */
+#define CM_SPATUS48K		0x01000000	/* read */
+#define CM_ENDBDAC		0x00800000	/* enable dual dac */
+#define CM_XCHGDAC		0x00400000	/* 0: front=ch0, 1: front=ch1 */
+#define CM_SPD32SEL		0x00200000	/* 0: 16bit SPDIF, 1: 32bit */
+#define CM_SPDFLOOPI		0x00100000	/* int. SPDIF-IN -> int. OUT */
+#define CM_FM_EN		0x00080000	/* enalbe FM */
+#define CM_AC3EN2		0x00040000	/* enable AC3: model 039 */
+#define CM_VIDWPDSB		0x00010000 
+#define CM_SPDF_AC97		0x00008000	/* 0: SPDIF/OUT 44.1K, 1: 48K */
+#define CM_MASK_EN		0x00004000
+#define CM_VIDWPPRT		0x00002000
+#define CM_SFILENB		0x00001000
+#define CM_MMODE_MASK		0x00000E00
+#define CM_SPDIF_SELECT2	0x00000100	/* for model > 039 ? */
+#define CM_ENCENTER		0x00000080
+#define CM_FLINKON		0x00000040
+#define CM_FLINKOFF		0x00000020
+#define CM_MIDSMP		0x00000010
+#define CM_UPDDMA_MASK		0x0000000C
+#define CM_TWAIT_MASK		0x00000003
+
+	/* byte */
+#define CM_REG_MIXER0		0x20
+
+#define CM_REG_SB16_DATA	0x22
+#define CM_REG_SB16_ADDR	0x23
+
+#define CM_REFFREQ_XIN		(315*1000*1000)/22	/* 14.31818 Mhz reference clock frequency pin XIN */
+#define CM_ADCMULT_XIN		512			/* Guessed (487 best for 44.1kHz, not for 88/176kHz) */
+#define CM_TOLERANCE_RATE	0.001			/* Tolerance sample rate pitch (1000ppm) */
+#define CM_MAXIMUM_RATE		80000000		/* Note more than 80MHz */
+
+#define CM_REG_MIXER1		0x24
+#define CM_FMMUTE		0x80	/* mute FM */
+#define CM_FMMUTE_SHIFT		7
+#define CM_WSMUTE		0x40	/* mute PCM */
+#define CM_WSMUTE_SHIFT		6
+#define CM_SPK4			0x20	/* lin-in -> rear line out */
+#define CM_SPK4_SHIFT		5
+#define CM_REAR2FRONT		0x10	/* exchange rear/front */
+#define CM_REAR2FRONT_SHIFT	4
+#define CM_WAVEINL		0x08	/* digital wave rec. left chan */
+#define CM_WAVEINL_SHIFT	3
+#define CM_WAVEINR		0x04	/* digical wave rec. right */
+#define CM_WAVEINR_SHIFT	2
+#define CM_X3DEN		0x02	/* 3D surround enable */
+#define CM_X3DEN_SHIFT		1
+#define CM_CDPLAY		0x01	/* enable SPDIF/IN PCM -> DAC */
+#define CM_CDPLAY_SHIFT		0
+
+#define CM_REG_MIXER2		0x25
+#define CM_RAUXREN		0x80	/* AUX right capture */
+#define CM_RAUXREN_SHIFT	7
+#define CM_RAUXLEN		0x40	/* AUX left capture */
+#define CM_RAUXLEN_SHIFT	6
+#define CM_VAUXRM		0x20	/* AUX right mute */
+#define CM_VAUXRM_SHIFT		5
+#define CM_VAUXLM		0x10	/* AUX left mute */
+#define CM_VAUXLM_SHIFT		4
+#define CM_VADMIC_MASK		0x0e	/* mic gain level (0-3) << 1 */
+#define CM_VADMIC_SHIFT		1
+#define CM_MICGAINZ		0x01	/* mic boost */
+#define CM_MICGAINZ_SHIFT	0
+
+#define CM_REG_AUX_VOL		0x26
+#define CM_VAUXL_MASK		0xf0
+#define CM_VAUXR_MASK		0x0f
+
+#define CM_REG_MISC		0x27
+#define CM_XGPO1		0x20
+// #define CM_XGPBIO		0x04
+#define CM_MIC_CENTER_LFE	0x04	/* mic as center/lfe out? (model 039 or later?) */
+#define CM_SPDIF_INVERSE	0x04	/* spdif input phase inverse (model 037) */
+#define CM_SPDVALID		0x02	/* spdif input valid check */
+#define CM_DMAUTO		0x01
+
+#define CM_REG_AC97		0x28	/* hmmm.. do we have ac97 link? */
+/*
+ * For CMI-8338 (0x28 - 0x2b) .. is this valid for CMI-8738
+ * or identical with AC97 codec?
+ */
+#define CM_REG_EXTERN_CODEC	CM_REG_AC97
+
+/*
+ * MPU401 pci port index address 0x40 - 0x4f (CMI-8738 spec ver. 0.6)
+ */
+#define CM_REG_MPU_PCI		0x40
+
+/*
+ * FM pci port index address 0x50 - 0x5f (CMI-8738 spec ver. 0.6)
+ */
+#define CM_REG_FM_PCI		0x50
+
+/*
+ * for CMI-8338 .. this is not valid for CMI-8738.
+ */
+#define CM_REG_EXTENT_IND	0xf0
+#define CM_VPHONE_MASK		0xe0	/* Phone volume control (0-3) << 5 */
+#define CM_VPHONE_SHIFT		5
+#define CM_VPHOM		0x10	/* Phone mute control */
+#define CM_VSPKM		0x08	/* Speaker mute control, default high */
+#define CM_RLOOPREN		0x04    /* Rec. R-channel enable */
+#define CM_RLOOPLEN		0x02	/* Rec. L-channel enable */
+
+/*
+ * CMI-8338 spec ver 0.5 (this is not valid for CMI-8738):
+ * the 8 registers 0xf8 - 0xff are used for programming m/n counter by the PLL
+ * unit (readonly?).
+ */
+#define CM_REG_PLL		0xf8
+
+/*
+ * extended registers
+ */
+#define CM_REG_CH0_FRAME1	0x80	/* base address */
+#define CM_REG_CH0_FRAME2	0x84
+#define CM_REG_CH1_FRAME1	0x88	/* 0-15: count of samples at bus master; buffer size */
+#define CM_REG_CH1_FRAME2	0x8C	/* 16-31: count of samples at codec; fragment size */
+#define CM_REG_MISC_CTRL_8768	0x92	/* reg. name the same as 0x18 */
+#define CM_CHB3D8C		0x20	/* 7.1 channels support */
+#define CM_SPD32FMT		0x10	/* SPDIF/IN 32k */
+#define CM_ADC2SPDIF		0x08	/* ADC output to SPDIF/OUT */
+#define CM_SHAREADC		0x04	/* DAC in ADC as Center/LFE */
+#define CM_REALTCMP		0x02	/* monitor the CMPL/CMPR of ADC */
+#define CM_INVLRCK		0x01	/* invert ZVPORT's LRCK */
+
+/*
+ * size of i/o region
+ */
+#define CM_EXTENT_CODEC	  0x100
+#define CM_EXTENT_MIDI	  0x2
+#define CM_EXTENT_SYNTH	  0x4
+
+
+/*
+ * pci ids
+ */
+#ifndef PCI_VENDOR_ID_CMEDIA
+#define PCI_VENDOR_ID_CMEDIA         0x13F6
+#endif
+#ifndef PCI_DEVICE_ID_CMEDIA_CM8338A
+#define PCI_DEVICE_ID_CMEDIA_CM8338A 0x0100
+#endif
+#ifndef PCI_DEVICE_ID_CMEDIA_CM8338B
+#define PCI_DEVICE_ID_CMEDIA_CM8338B 0x0101
+#endif
+#ifndef PCI_DEVICE_ID_CMEDIA_CM8738
+#define PCI_DEVICE_ID_CMEDIA_CM8738  0x0111
+#endif
+#ifndef PCI_DEVICE_ID_CMEDIA_CM8738B
+#define PCI_DEVICE_ID_CMEDIA_CM8738B 0x0112
+#endif
+
+/*
+ * channels for playback / capture
+ */
+#define CM_CH_PLAY	0
+#define CM_CH_CAPT	1
+
+/*
+ * flags to check device open/close
+ */
+#define CM_OPEN_NONE	0
+#define CM_OPEN_CH_MASK	0x01
+#define CM_OPEN_DAC	0x10
+#define CM_OPEN_ADC	0x20
+#define CM_OPEN_SPDIF	0x40
+#define CM_OPEN_MCHAN	0x80
+#define CM_OPEN_PLAYBACK	(CM_CH_PLAY | CM_OPEN_DAC)
+#define CM_OPEN_PLAYBACK2	(CM_CH_CAPT | CM_OPEN_DAC)
+#define CM_OPEN_PLAYBACK_MULTI	(CM_CH_PLAY | CM_OPEN_DAC | CM_OPEN_MCHAN)
+#define CM_OPEN_CAPTURE		(CM_CH_CAPT | CM_OPEN_ADC)
+#define CM_OPEN_SPDIF_PLAYBACK	(CM_CH_PLAY | CM_OPEN_DAC | CM_OPEN_SPDIF)
+#define CM_OPEN_SPDIF_CAPTURE	(CM_CH_CAPT | CM_OPEN_ADC | CM_OPEN_SPDIF)
+
+
+#if CM_CH_PLAY == 1
+#define CM_PLAYBACK_SRATE_176K	CM_CH1_SRATE_176K
+#define CM_PLAYBACK_SPDF	CM_SPDF_1
+#define CM_CAPTURE_SPDF		CM_SPDF_0
+#else
+#define CM_PLAYBACK_SRATE_176K CM_CH0_SRATE_176K
+#define CM_PLAYBACK_SPDF	CM_SPDF_0
+#define CM_CAPTURE_SPDF		CM_SPDF_1
+#endif
+
+
+/*
+ * driver data
+ */
+
+typedef struct snd_stru_cmipci cmipci_t;
+typedef struct snd_stru_cmipci_pcm cmipci_pcm_t;
+
+struct snd_stru_cmipci_pcm {
+	snd_pcm_substream_t *substream;
+	int running;		/* dac/adc running? */
+	unsigned int dma_size;	/* in frames */
+	unsigned int period_size;	/* in frames */
+	unsigned int offset;	/* physical address of the buffer */
+	unsigned int fmt;	/* format bits */
+	int ch;			/* channel (0/1) */
+	unsigned int is_dac;		/* is dac? */
+	int bytes_per_frame;
+	int shift;
+};
+
+/* mixer elements toggled/resumed during ac3 playback */
+struct cmipci_mixer_auto_switches {
+	const char *name;	/* switch to toggle */
+	int toggle_on;		/* value to change when ac3 mode */
+};
+static const struct cmipci_mixer_auto_switches cm_saved_mixer[] = {
+	{"PCM Playback Switch", 0},
+	{"IEC958 Output Switch", 1},
+	{"IEC958 Mix Analog", 0},
+	// {"IEC958 Out To DAC", 1}, // no longer used
+	{"IEC958 Loop", 0},
+};
+#define CM_SAVED_MIXERS		ARRAY_SIZE(cm_saved_mixer)
+
+struct snd_stru_cmipci {
+	snd_card_t *card;
+
+	struct pci_dev *pci;
+	unsigned int device;	/* device ID */
+	int irq;
+
+	unsigned long iobase;
+	unsigned int ctrl;	/* FUNCTRL0 current value */
+
+	snd_pcm_t *pcm;		/* DAC/ADC PCM */
+	snd_pcm_t *pcm2;	/* 2nd DAC */
+	snd_pcm_t *pcm_spdif;	/* SPDIF */
+
+	int chip_version;
+	int max_channels;
+	unsigned int has_dual_dac: 1;
+	unsigned int can_ac3_sw: 1;
+	unsigned int can_ac3_hw: 1;
+	unsigned int can_multi_ch: 1;
+	unsigned int do_soft_ac3: 1;
+
+	unsigned int spdif_playback_avail: 1;	/* spdif ready? */
+	unsigned int spdif_playback_enabled: 1;	/* spdif switch enabled? */
+	int spdif_counter;	/* for software AC3 */
+
+	unsigned int dig_status;
+	unsigned int dig_pcm_status;
+
+	snd_pcm_hardware_t *hw_info[3]; /* for playbacks */
+
+	int opened[2];	/* open mode */
+	struct semaphore open_mutex;
+
+	unsigned int mixer_insensitive: 1;
+	snd_kcontrol_t *mixer_res_ctl[CM_SAVED_MIXERS];
+	int mixer_res_status[CM_SAVED_MIXERS];
+
+	opl3_t *opl3;
+	snd_hwdep_t *opl3hwdep;
+
+	cmipci_pcm_t channel[2];	/* ch0 - DAC, ch1 - ADC or 2nd DAC */
+
+	/* external MIDI */
+	snd_rawmidi_t *rmidi;
+
+#ifdef SUPPORT_JOYSTICK
+	struct gameport *gameport;
+#endif
+
+	spinlock_t reg_lock;
+};
+
+
+/* read/write operations for dword register */
+inline static void snd_cmipci_write(cmipci_t *cm, unsigned int cmd, unsigned int data)
+{
+	outl(data, cm->iobase + cmd);
+}
+inline static unsigned int snd_cmipci_read(cmipci_t *cm, unsigned int cmd)
+{
+	return inl(cm->iobase + cmd);
+}
+
+/* read/write operations for word register */
+inline static void snd_cmipci_write_w(cmipci_t *cm, unsigned int cmd, unsigned short data)
+{
+	outw(data, cm->iobase + cmd);
+}
+inline static unsigned short snd_cmipci_read_w(cmipci_t *cm, unsigned int cmd)
+{
+	return inw(cm->iobase + cmd);
+}
+
+/* read/write operations for byte register */
+inline static void snd_cmipci_write_b(cmipci_t *cm, unsigned int cmd, unsigned char data)
+{
+	outb(data, cm->iobase + cmd);
+}
+
+inline static unsigned char snd_cmipci_read_b(cmipci_t *cm, unsigned int cmd)
+{
+	return inb(cm->iobase + cmd);
+}
+
+/* bit operations for dword register */
+static void snd_cmipci_set_bit(cmipci_t *cm, unsigned int cmd, unsigned int flag)
+{
+	unsigned int val;
+	val = inl(cm->iobase + cmd);
+	val |= flag;
+	outl(val, cm->iobase + cmd);
+}
+
+static void snd_cmipci_clear_bit(cmipci_t *cm, unsigned int cmd, unsigned int flag)
+{
+	unsigned int val;
+	val = inl(cm->iobase + cmd);
+	val &= ~flag;
+	outl(val, cm->iobase + cmd);
+}
+
+#if 0 // not used
+/* bit operations for byte register */
+static void snd_cmipci_set_bit_b(cmipci_t *cm, unsigned int cmd, unsigned char flag)
+{
+	unsigned char val;
+	val = inb(cm->iobase + cmd);
+	val |= flag;
+	outb(val, cm->iobase + cmd);
+}
+
+static void snd_cmipci_clear_bit_b(cmipci_t *cm, unsigned int cmd, unsigned char flag)
+{
+	unsigned char val;
+	val = inb(cm->iobase + cmd);
+	val &= ~flag;
+	outb(val, cm->iobase + cmd);
+}
+#endif
+
+
+/*
+ * PCM interface
+ */
+
+/*
+ * calculate frequency
+ */
+
+static unsigned int rates[] = { 5512, 11025, 22050, 44100, 8000, 16000, 32000, 48000 };
+
+static unsigned int snd_cmipci_rate_freq(unsigned int rate)
+{
+	unsigned int i;
+	for (i = 0; i < ARRAY_SIZE(rates); i++) {
+		if (rates[i] == rate)
+			return i;
+	}
+	snd_BUG();
+	return 0;
+}
+
+#ifdef USE_VAR48KRATE
+/*
+ * Determine PLL values for frequency setup, maybe the CMI8338 (CMI8738???)
+ * does it this way .. maybe not.  Never get any information from C-Media about
+ * that <werner@suse.de>.
+ */
+static int snd_cmipci_pll_rmn(unsigned int rate, unsigned int adcmult, int *r, int *m, int *n)
+{
+	unsigned int delta, tolerance;
+	int xm, xn, xr;
+
+	for (*r = 0; rate < CM_MAXIMUM_RATE/adcmult; *r += (1<<5))
+		rate <<= 1;
+	*n = -1;
+	if (*r > 0xff)
+		goto out;
+	tolerance = rate*CM_TOLERANCE_RATE;
+
+	for (xn = (1+2); xn < (0x1f+2); xn++) {
+		for (xm = (1+2); xm < (0xff+2); xm++) {
+			xr = ((CM_REFFREQ_XIN/adcmult) * xm) / xn;
+
+			if (xr < rate)
+				delta = rate - xr;
+			else
+				delta = xr - rate;
+
+			/*
+			 * If we found one, remember this,
+			 * and try to find a closer one
+			 */
+			if (delta < tolerance) {
+				tolerance = delta;
+				*m = xm - 2;
+				*n = xn - 2;
+			}
+		}
+	}
+out:
+	return (*n > -1);
+}
+
+/*
+ * Program pll register bits, I assume that the 8 registers 0xf8 upto 0xff
+ * are mapped onto the 8 ADC/DAC sampling frequency which can be choosen
+ * at the register CM_REG_FUNCTRL1 (0x04).
+ * Problem: other ways are also possible (any information about that?)
+ */
+static void snd_cmipci_set_pll(cmipci_t *cm, unsigned int rate, unsigned int slot)
+{
+	unsigned int reg = CM_REG_PLL + slot;
+	/*
+	 * Guess that this programs at reg. 0x04 the pos 15:13/12:10
+	 * for DSFC/ASFC (000 upto 111).
+	 */
+
+	/* FIXME: Init (Do we've to set an other register first before programming?) */
+
+	/* FIXME: Is this correct? Or shouldn't the m/n/r values be used for that? */
+	snd_cmipci_write_b(cm, reg, rate>>8);
+	snd_cmipci_write_b(cm, reg, rate&0xff);
+
+	/* FIXME: Setup (Do we've to set an other register first to enable this?) */
+}
+#endif /* USE_VAR48KRATE */
+
+static int snd_cmipci_hw_params(snd_pcm_substream_t * substream,
+				snd_pcm_hw_params_t * hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+}
+
+static int snd_cmipci_playback2_hw_params(snd_pcm_substream_t * substream,
+					  snd_pcm_hw_params_t * hw_params)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	if (params_channels(hw_params) > 2) {
+		down(&cm->open_mutex);
+		if (cm->opened[CM_CH_PLAY]) {
+			up(&cm->open_mutex);
+			return -EBUSY;
+		}
+		/* reserve the channel A */
+		cm->opened[CM_CH_PLAY] = CM_OPEN_PLAYBACK_MULTI;
+		up(&cm->open_mutex);
+	}
+	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+}
+
+static void snd_cmipci_ch_reset(cmipci_t *cm, int ch)
+{
+	int reset = CM_RST_CH0 << (cm->channel[ch].ch);
+	snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl | reset);
+	snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl & ~reset);
+	udelay(10);
+}
+
+static int snd_cmipci_hw_free(snd_pcm_substream_t * substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+
+/*
+ */
+
+static unsigned int hw_channels[] = {1, 2, 4, 5, 6, 8};
+static snd_pcm_hw_constraint_list_t hw_constraints_channels_4 = {
+	.count = 3,
+	.list = hw_channels,
+	.mask = 0,
+};
+static snd_pcm_hw_constraint_list_t hw_constraints_channels_6 = {
+	.count = 5,
+	.list = hw_channels,
+	.mask = 0,
+};
+static snd_pcm_hw_constraint_list_t hw_constraints_channels_8 = {
+	.count = 6,
+	.list = hw_channels,
+	.mask = 0,
+};
+
+static int set_dac_channels(cmipci_t *cm, cmipci_pcm_t *rec, int channels)
+{
+	if (channels > 2) {
+		if (! cm->can_multi_ch)
+			return -EINVAL;
+		if (rec->fmt != 0x03) /* stereo 16bit only */
+			return -EINVAL;
+
+		spin_lock_irq(&cm->reg_lock);
+		snd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_NXCHG);
+		snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);
+		if (channels > 4) {
+			snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_CHB3D);
+			snd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_CHB3D5C);
+		} else {
+			snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_CHB3D5C);
+			snd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_CHB3D);
+		}
+		if (channels >= 6) {
+			snd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_CHB3D6C);
+			snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_ENCENTER);
+		} else {
+			snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_CHB3D6C);
+			snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_ENCENTER);
+		}
+		if (cm->chip_version == 68) {
+			if (channels == 8) {
+				snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL_8768, CM_CHB3D8C);
+			} else {
+				snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL_8768, CM_CHB3D8C);
+			}
+		}
+		spin_unlock_irq(&cm->reg_lock);
+
+	} else {
+		if (cm->can_multi_ch) {
+			spin_lock_irq(&cm->reg_lock);
+			snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_NXCHG);
+			snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_CHB3D);
+			snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_CHB3D5C);
+			snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_CHB3D6C);
+			snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_ENCENTER);
+			snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);
+			spin_unlock_irq(&cm->reg_lock);
+		}
+	}
+	return 0;
+}
+
+
+/*
+ * prepare playback/capture channel
+ * channel to be used must have been set in rec->ch.
+ */
+static int snd_cmipci_pcm_prepare(cmipci_t *cm, cmipci_pcm_t *rec,
+				 snd_pcm_substream_t *substream)
+{
+	unsigned int reg, freq, val;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	rec->fmt = 0;
+	rec->shift = 0;
+	if (snd_pcm_format_width(runtime->format) >= 16) {
+		rec->fmt |= 0x02;
+		if (snd_pcm_format_width(runtime->format) > 16)
+			rec->shift++; /* 24/32bit */
+	}
+	if (runtime->channels > 1)
+		rec->fmt |= 0x01;
+	if (rec->is_dac && set_dac_channels(cm, rec, runtime->channels) < 0) {
+		snd_printd("cannot set dac channels\n");
+		return -EINVAL;
+	}
+
+	rec->offset = runtime->dma_addr;
+	/* buffer and period sizes in frame */
+	rec->dma_size = runtime->buffer_size << rec->shift;
+	rec->period_size = runtime->period_size << rec->shift;
+	if (runtime->channels > 2) {
+		/* multi-channels */
+		rec->dma_size = (rec->dma_size * runtime->channels) / 2;
+		rec->period_size = (rec->period_size * runtime->channels) / 2;
+	}
+
+	spin_lock_irq(&cm->reg_lock);
+
+	/* set buffer address */
+	reg = rec->ch ? CM_REG_CH1_FRAME1 : CM_REG_CH0_FRAME1;
+	snd_cmipci_write(cm, reg, rec->offset);
+	/* program sample counts */
+	reg = rec->ch ? CM_REG_CH1_FRAME2 : CM_REG_CH0_FRAME2;
+	snd_cmipci_write_w(cm, reg, rec->dma_size - 1);
+	snd_cmipci_write_w(cm, reg + 2, rec->period_size - 1);
+
+	/* set adc/dac flag */
+	val = rec->ch ? CM_CHADC1 : CM_CHADC0;
+	if (rec->is_dac)
+		cm->ctrl &= ~val;
+	else
+		cm->ctrl |= val;
+	snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);
+	//snd_printd("cmipci: functrl0 = %08x\n", cm->ctrl);
+
+	/* set sample rate */
+	freq = snd_cmipci_rate_freq(runtime->rate);
+	val = snd_cmipci_read(cm, CM_REG_FUNCTRL1);
+	if (rec->ch) {
+		val &= ~CM_ASFC_MASK;
+		val |= (freq << CM_ASFC_SHIFT) & CM_ASFC_MASK;
+	} else {
+		val &= ~CM_DSFC_MASK;
+		val |= (freq << CM_DSFC_SHIFT) & CM_DSFC_MASK;
+	}
+	snd_cmipci_write(cm, CM_REG_FUNCTRL1, val);
+	//snd_printd("cmipci: functrl1 = %08x\n", val);
+
+	/* set format */
+	val = snd_cmipci_read(cm, CM_REG_CHFORMAT);
+	if (rec->ch) {
+		val &= ~CM_CH1FMT_MASK;
+		val |= rec->fmt << CM_CH1FMT_SHIFT;
+	} else {
+		val &= ~CM_CH0FMT_MASK;
+		val |= rec->fmt << CM_CH0FMT_SHIFT;
+	}
+	snd_cmipci_write(cm, CM_REG_CHFORMAT, val);
+	//snd_printd("cmipci: chformat = %08x\n", val);
+
+	rec->running = 0;
+	spin_unlock_irq(&cm->reg_lock);
+
+	return 0;
+}
+
+/*
+ * PCM trigger/stop
+ */
+static int snd_cmipci_pcm_trigger(cmipci_t *cm, cmipci_pcm_t *rec,
+				 snd_pcm_substream_t *substream, int cmd)
+{
+	unsigned int inthld, chen, reset, pause;
+	int result = 0;
+
+	inthld = CM_CH0_INT_EN << rec->ch;
+	chen = CM_CHEN0 << rec->ch;
+	reset = CM_RST_CH0 << rec->ch;
+	pause = CM_PAUSE0 << rec->ch;
+
+	spin_lock(&cm->reg_lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		rec->running = 1;
+		/* set interrupt */
+		snd_cmipci_set_bit(cm, CM_REG_INT_HLDCLR, inthld);
+		cm->ctrl |= chen;
+		/* enable channel */
+		snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);
+		//snd_printd("cmipci: functrl0 = %08x\n", cm->ctrl);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		rec->running = 0;
+		/* disable interrupt */
+		snd_cmipci_clear_bit(cm, CM_REG_INT_HLDCLR, inthld);
+		/* reset */
+		cm->ctrl &= ~chen;
+		snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl | reset);
+		snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl & ~reset);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		cm->ctrl |= pause;
+		snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		cm->ctrl &= ~pause;
+		snd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);
+		break;
+	default:
+		result = -EINVAL;
+		break;
+	}
+	spin_unlock(&cm->reg_lock);
+	return result;
+}
+
+/*
+ * return the current pointer
+ */
+static snd_pcm_uframes_t snd_cmipci_pcm_pointer(cmipci_t *cm, cmipci_pcm_t *rec,
+					  snd_pcm_substream_t *substream)
+{
+	size_t ptr;
+	unsigned int reg;
+	if (!rec->running)
+		return 0;
+#if 1 // this seems better..
+	reg = rec->ch ? CM_REG_CH1_FRAME2 : CM_REG_CH0_FRAME2;
+	ptr = rec->dma_size - (snd_cmipci_read_w(cm, reg) + 1);
+	ptr >>= rec->shift;
+#else
+	reg = rec->ch ? CM_REG_CH1_FRAME1 : CM_REG_CH0_FRAME1;
+	ptr = snd_cmipci_read(cm, reg) - rec->offset;
+	ptr = bytes_to_frames(substream->runtime, ptr);
+#endif
+	if (substream->runtime->channels > 2)
+		ptr = (ptr * 2) / substream->runtime->channels;
+	return ptr;
+}
+
+/*
+ * playback
+ */
+
+static int snd_cmipci_playback_trigger(snd_pcm_substream_t *substream,
+				       int cmd)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	return snd_cmipci_pcm_trigger(cm, &cm->channel[CM_CH_PLAY], substream, cmd);
+}
+
+static snd_pcm_uframes_t snd_cmipci_playback_pointer(snd_pcm_substream_t *substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	return snd_cmipci_pcm_pointer(cm, &cm->channel[CM_CH_PLAY], substream);
+}
+
+
+
+/*
+ * capture
+ */
+
+static int snd_cmipci_capture_trigger(snd_pcm_substream_t *substream,
+				     int cmd)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	return snd_cmipci_pcm_trigger(cm, &cm->channel[CM_CH_CAPT], substream, cmd);
+}
+
+static snd_pcm_uframes_t snd_cmipci_capture_pointer(snd_pcm_substream_t *substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	return snd_cmipci_pcm_pointer(cm, &cm->channel[CM_CH_CAPT], substream);
+}
+
+
+/*
+ * hw preparation for spdif
+ */
+
+static int snd_cmipci_spdif_default_info(snd_kcontrol_t *kcontrol,
+					 snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_cmipci_spdif_default_get(snd_kcontrol_t *kcontrol,
+					snd_ctl_elem_value_t *ucontrol)
+{
+	cmipci_t *chip = snd_kcontrol_chip(kcontrol);
+	int i;
+
+	spin_lock_irq(&chip->reg_lock);
+	for (i = 0; i < 4; i++)
+		ucontrol->value.iec958.status[i] = (chip->dig_status >> (i * 8)) & 0xff;
+	spin_unlock_irq(&chip->reg_lock);
+	return 0;
+}
+
+static int snd_cmipci_spdif_default_put(snd_kcontrol_t * kcontrol,
+					 snd_ctl_elem_value_t * ucontrol)
+{
+	cmipci_t *chip = snd_kcontrol_chip(kcontrol);
+	int i, change;
+	unsigned int val;
+
+	val = 0;
+	spin_lock_irq(&chip->reg_lock);
+	for (i = 0; i < 4; i++)
+		val |= (unsigned int)ucontrol->value.iec958.status[i] << (i * 8);
+	change = val != chip->dig_status;
+	chip->dig_status = val;
+	spin_unlock_irq(&chip->reg_lock);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_cmipci_spdif_default __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
+	.info =		snd_cmipci_spdif_default_info,
+	.get =		snd_cmipci_spdif_default_get,
+	.put =		snd_cmipci_spdif_default_put
+};
+
+static int snd_cmipci_spdif_mask_info(snd_kcontrol_t *kcontrol,
+				      snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_cmipci_spdif_mask_get(snd_kcontrol_t * kcontrol,
+				     snd_ctl_elem_value_t *ucontrol)
+{
+	ucontrol->value.iec958.status[0] = 0xff;
+	ucontrol->value.iec958.status[1] = 0xff;
+	ucontrol->value.iec958.status[2] = 0xff;
+	ucontrol->value.iec958.status[3] = 0xff;
+	return 0;
+}
+
+static snd_kcontrol_new_t snd_cmipci_spdif_mask __devinitdata =
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,CON_MASK),
+	.info =		snd_cmipci_spdif_mask_info,
+	.get =		snd_cmipci_spdif_mask_get,
+};
+
+static int snd_cmipci_spdif_stream_info(snd_kcontrol_t *kcontrol,
+					snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_cmipci_spdif_stream_get(snd_kcontrol_t *kcontrol,
+				       snd_ctl_elem_value_t *ucontrol)
+{
+	cmipci_t *chip = snd_kcontrol_chip(kcontrol);
+	int i;
+
+	spin_lock_irq(&chip->reg_lock);
+	for (i = 0; i < 4; i++)
+		ucontrol->value.iec958.status[i] = (chip->dig_pcm_status >> (i * 8)) & 0xff;
+	spin_unlock_irq(&chip->reg_lock);
+	return 0;
+}
+
+static int snd_cmipci_spdif_stream_put(snd_kcontrol_t *kcontrol,
+				       snd_ctl_elem_value_t *ucontrol)
+{
+	cmipci_t *chip = snd_kcontrol_chip(kcontrol);
+	int i, change;
+	unsigned int val;
+
+	val = 0;
+	spin_lock_irq(&chip->reg_lock);
+	for (i = 0; i < 4; i++)
+		val |= (unsigned int)ucontrol->value.iec958.status[i] << (i * 8);
+	change = val != chip->dig_pcm_status;
+	chip->dig_pcm_status = val;
+	spin_unlock_irq(&chip->reg_lock);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_cmipci_spdif_stream __devinitdata =
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM),
+	.info =		snd_cmipci_spdif_stream_info,
+	.get =		snd_cmipci_spdif_stream_get,
+	.put =		snd_cmipci_spdif_stream_put
+};
+
+/*
+ */
+
+/* save mixer setting and mute for AC3 playback */
+static int save_mixer_state(cmipci_t *cm)
+{
+	if (! cm->mixer_insensitive) {
+		snd_ctl_elem_value_t *val;
+		unsigned int i;
+
+		val = kmalloc(sizeof(*val), GFP_ATOMIC);
+		if (!val)
+			return -ENOMEM;
+		for (i = 0; i < CM_SAVED_MIXERS; i++) {
+			snd_kcontrol_t *ctl = cm->mixer_res_ctl[i];
+			if (ctl) {
+				int event;
+				memset(val, 0, sizeof(*val));
+				ctl->get(ctl, val);
+				cm->mixer_res_status[i] = val->value.integer.value[0];
+				val->value.integer.value[0] = cm_saved_mixer[i].toggle_on;
+				event = SNDRV_CTL_EVENT_MASK_INFO;
+				if (cm->mixer_res_status[i] != val->value.integer.value[0]) {
+					ctl->put(ctl, val); /* toggle */
+					event |= SNDRV_CTL_EVENT_MASK_VALUE;
+				}
+				ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+				snd_ctl_notify(cm->card, event, &ctl->id);
+			}
+		}
+		kfree(val);
+		cm->mixer_insensitive = 1;
+	}
+	return 0;
+}
+
+
+/* restore the previously saved mixer status */
+static void restore_mixer_state(cmipci_t *cm)
+{
+	if (cm->mixer_insensitive) {
+		snd_ctl_elem_value_t *val;
+		unsigned int i;
+
+		val = kmalloc(sizeof(*val), GFP_KERNEL);
+		if (!val)
+			return;
+		cm->mixer_insensitive = 0; /* at first clear this;
+					      otherwise the changes will be ignored */
+		for (i = 0; i < CM_SAVED_MIXERS; i++) {
+			snd_kcontrol_t *ctl = cm->mixer_res_ctl[i];
+			if (ctl) {
+				int event;
+
+				memset(val, 0, sizeof(*val));
+				ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+				ctl->get(ctl, val);
+				event = SNDRV_CTL_EVENT_MASK_INFO;
+				if (val->value.integer.value[0] != cm->mixer_res_status[i]) {
+					val->value.integer.value[0] = cm->mixer_res_status[i];
+					ctl->put(ctl, val);
+					event |= SNDRV_CTL_EVENT_MASK_VALUE;
+				}
+				snd_ctl_notify(cm->card, event, &ctl->id);
+			}
+		}
+		kfree(val);
+	}
+}
+
+/* spinlock held! */
+static void setup_ac3(cmipci_t *cm, snd_pcm_substream_t *subs, int do_ac3, int rate)
+{
+	if (do_ac3) {
+		/* AC3EN for 037 */
+		snd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_AC3EN1);
+		/* AC3EN for 039 */
+		snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_AC3EN2);
+	
+		if (cm->can_ac3_hw) {
+			/* SPD24SEL for 037, 0x02 */
+			/* SPD24SEL for 039, 0x20, but cannot be set */
+			snd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_SPD24SEL);
+			snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);
+		} else { /* can_ac3_sw */
+			/* SPD32SEL for 037 & 039, 0x20 */
+			snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);
+			/* set 176K sample rate to fix 033 HW bug */
+			if (cm->chip_version == 33) {
+				if (rate >= 48000) {
+					snd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_PLAYBACK_SRATE_176K);
+				} else {
+					snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_PLAYBACK_SRATE_176K);
+				}
+			}
+		}
+
+	} else {
+		snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_AC3EN1);
+		snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_AC3EN2);
+
+		if (cm->can_ac3_hw) {
+			/* chip model >= 37 */
+			if (snd_pcm_format_width(subs->runtime->format) > 16) {
+				snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);
+				snd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_SPD24SEL);
+			} else {
+				snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);
+				snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_SPD24SEL);
+			}
+		} else {
+			snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);
+			snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_SPD24SEL);
+			snd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_PLAYBACK_SRATE_176K);
+		}
+	}
+}
+
+static int setup_spdif_playback(cmipci_t *cm, snd_pcm_substream_t *subs, int up, int do_ac3)
+{
+	int rate, err;
+
+	rate = subs->runtime->rate;
+
+	if (up && do_ac3)
+		if ((err = save_mixer_state(cm)) < 0)
+			return err;
+
+	spin_lock_irq(&cm->reg_lock);
+	cm->spdif_playback_avail = up;
+	if (up) {
+		/* they are controlled via "IEC958 Output Switch" */
+		/* snd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_ENSPDOUT); */
+		/* snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_SPDO2DAC); */
+		if (cm->spdif_playback_enabled)
+			snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_PLAYBACK_SPDF);
+		setup_ac3(cm, subs, do_ac3, rate);
+
+		if (rate == 48000)
+			snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPDIF48K | CM_SPDF_AC97);
+		else
+			snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPDIF48K | CM_SPDF_AC97);
+
+	} else {
+		/* they are controlled via "IEC958 Output Switch" */
+		/* snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_ENSPDOUT); */
+		/* snd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_SPDO2DAC); */
+		snd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_PLAYBACK_SPDF);
+		setup_ac3(cm, subs, 0, 0);
+	}
+	spin_unlock_irq(&cm->reg_lock);
+	return 0;
+}
+
+
+/*
+ * preparation
+ */
+
+/* playback - enable spdif only on the certain condition */
+static int snd_cmipci_playback_prepare(snd_pcm_substream_t *substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	int rate = substream->runtime->rate;
+	int err, do_spdif, do_ac3 = 0;
+
+	do_spdif = ((rate == 44100 || rate == 48000) &&
+		    substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE &&
+		    substream->runtime->channels == 2);
+	if (do_spdif && cm->can_ac3_hw) 
+		do_ac3 = cm->dig_pcm_status & IEC958_AES0_NONAUDIO;
+	if ((err = setup_spdif_playback(cm, substream, do_spdif, do_ac3)) < 0)
+		return err;
+	return snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_PLAY], substream);
+}
+
+/* playback  (via device #2) - enable spdif always */
+static int snd_cmipci_playback_spdif_prepare(snd_pcm_substream_t *substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	int err, do_ac3;
+
+	if (cm->can_ac3_hw) 
+		do_ac3 = cm->dig_pcm_status & IEC958_AES0_NONAUDIO;
+	else
+		do_ac3 = 1; /* doesn't matter */
+	if ((err = setup_spdif_playback(cm, substream, 1, do_ac3)) < 0)
+		return err;
+	return snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_PLAY], substream);
+}
+
+static int snd_cmipci_playback_hw_free(snd_pcm_substream_t *substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	setup_spdif_playback(cm, substream, 0, 0);
+	restore_mixer_state(cm);
+	return snd_cmipci_hw_free(substream);
+}
+
+/* capture */
+static int snd_cmipci_capture_prepare(snd_pcm_substream_t *substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	return snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_CAPT], substream);
+}
+
+/* capture with spdif (via device #2) */
+static int snd_cmipci_capture_spdif_prepare(snd_pcm_substream_t *substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+
+	spin_lock_irq(&cm->reg_lock);
+	snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_CAPTURE_SPDF);
+	spin_unlock_irq(&cm->reg_lock);
+
+	return snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_CAPT], substream);
+}
+
+static int snd_cmipci_capture_spdif_hw_free(snd_pcm_substream_t *subs)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(subs);
+
+	spin_lock_irq(&cm->reg_lock);
+	snd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_CAPTURE_SPDF);
+	spin_unlock_irq(&cm->reg_lock);
+
+	return snd_cmipci_hw_free(subs);
+}
+
+
+/*
+ * interrupt handler
+ */
+static irqreturn_t snd_cmipci_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	cmipci_t *cm = dev_id;
+	unsigned int status, mask = 0;
+	
+	/* fastpath out, to ease interrupt sharing */
+	status = snd_cmipci_read(cm, CM_REG_INT_STATUS);
+	if (!(status & CM_INTR))
+		return IRQ_NONE;
+
+	/* acknowledge interrupt */
+	spin_lock(&cm->reg_lock);
+	if (status & CM_CHINT0)
+		mask |= CM_CH0_INT_EN;
+	if (status & CM_CHINT1)
+		mask |= CM_CH1_INT_EN;
+	snd_cmipci_clear_bit(cm, CM_REG_INT_HLDCLR, mask);
+	snd_cmipci_set_bit(cm, CM_REG_INT_HLDCLR, mask);
+	spin_unlock(&cm->reg_lock);
+
+	if (cm->rmidi && (status & CM_UARTINT))
+		snd_mpu401_uart_interrupt(irq, cm->rmidi->private_data, regs);
+
+	if (cm->pcm) {
+		if ((status & CM_CHINT0) && cm->channel[0].running)
+			snd_pcm_period_elapsed(cm->channel[0].substream);
+		if ((status & CM_CHINT1) && cm->channel[1].running)
+			snd_pcm_period_elapsed(cm->channel[1].substream);
+	}
+	return IRQ_HANDLED;
+}
+
+/*
+ * h/w infos
+ */
+
+/* playback on channel A */
+static snd_pcm_hardware_t snd_cmipci_playback =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		5512,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		2,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+/* capture on channel B */
+static snd_pcm_hardware_t snd_cmipci_capture =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		5512,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		2,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+/* playback on channel B - stereo 16bit only? */
+static snd_pcm_hardware_t snd_cmipci_playback2 =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		5512,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		2,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+/* spdif playback on channel A */
+static snd_pcm_hardware_t snd_cmipci_playback_spdif =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+	.rate_min =		44100,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		2,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+/* spdif playback on channel A (32bit, IEC958 subframes) */
+static snd_pcm_hardware_t snd_cmipci_playback_iec958_subframe =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE,
+	.rates =		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+	.rate_min =		44100,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		2,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+/* spdif capture on channel B */
+static snd_pcm_hardware_t snd_cmipci_capture_spdif =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =	        SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+	.rate_min =		44100,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		2,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+/*
+ * check device open/close
+ */
+static int open_device_check(cmipci_t *cm, int mode, snd_pcm_substream_t *subs)
+{
+	int ch = mode & CM_OPEN_CH_MASK;
+
+	/* FIXME: a file should wait until the device becomes free
+	 * when it's opened on blocking mode.  however, since the current
+	 * pcm framework doesn't pass file pointer before actually opened,
+	 * we can't know whether blocking mode or not in open callback..
+	 */
+	down(&cm->open_mutex);
+	if (cm->opened[ch]) {
+		up(&cm->open_mutex);
+		return -EBUSY;
+	}
+	cm->opened[ch] = mode;
+	cm->channel[ch].substream = subs;
+	if (! (mode & CM_OPEN_DAC)) {
+		/* disable dual DAC mode */
+		cm->channel[ch].is_dac = 0;
+		spin_lock_irq(&cm->reg_lock);
+		snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_ENDBDAC);
+		spin_unlock_irq(&cm->reg_lock);
+	}
+	up(&cm->open_mutex);
+	return 0;
+}
+
+static void close_device_check(cmipci_t *cm, int mode)
+{
+	int ch = mode & CM_OPEN_CH_MASK;
+
+	down(&cm->open_mutex);
+	if (cm->opened[ch] == mode) {
+		if (cm->channel[ch].substream) {
+			snd_cmipci_ch_reset(cm, ch);
+			cm->channel[ch].running = 0;
+			cm->channel[ch].substream = NULL;
+		}
+		cm->opened[ch] = 0;
+		if (! cm->channel[ch].is_dac) {
+			/* enable dual DAC mode again */
+			cm->channel[ch].is_dac = 1;
+			spin_lock_irq(&cm->reg_lock);
+			snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_ENDBDAC);
+			spin_unlock_irq(&cm->reg_lock);
+		}
+	}
+	up(&cm->open_mutex);
+}
+
+/*
+ */
+
+static int snd_cmipci_playback_open(snd_pcm_substream_t *substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+
+	if ((err = open_device_check(cm, CM_OPEN_PLAYBACK, substream)) < 0)
+		return err;
+	runtime->hw = snd_cmipci_playback;
+	runtime->hw.channels_max = cm->max_channels;
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);
+	cm->dig_pcm_status = cm->dig_status;
+	return 0;
+}
+
+static int snd_cmipci_capture_open(snd_pcm_substream_t *substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+
+	if ((err = open_device_check(cm, CM_OPEN_CAPTURE, substream)) < 0)
+		return err;
+	runtime->hw = snd_cmipci_capture;
+	if (cm->chip_version == 68) {	// 8768 only supports 44k/48k recording
+		runtime->hw.rate_min = 41000;
+		runtime->hw.rates = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000;
+	}
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);
+	return 0;
+}
+
+static int snd_cmipci_playback2_open(snd_pcm_substream_t *substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+
+	if ((err = open_device_check(cm, CM_OPEN_PLAYBACK2, substream)) < 0) /* use channel B */
+		return err;
+	runtime->hw = snd_cmipci_playback2;
+	down(&cm->open_mutex);
+	if (! cm->opened[CM_CH_PLAY]) {
+		if (cm->can_multi_ch) {
+			runtime->hw.channels_max = cm->max_channels;
+			if (cm->max_channels == 4)
+				snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels_4);
+			else if (cm->max_channels == 6)
+				snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels_6);
+			else if (cm->max_channels == 8)
+				snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels_8);
+		}
+		snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);
+	}
+	up(&cm->open_mutex);
+	return 0;
+}
+
+static int snd_cmipci_playback_spdif_open(snd_pcm_substream_t *substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+
+	if ((err = open_device_check(cm, CM_OPEN_SPDIF_PLAYBACK, substream)) < 0) /* use channel A */
+		return err;
+	if (cm->can_ac3_hw) {
+		runtime->hw = snd_cmipci_playback_spdif;
+		if (cm->chip_version >= 37)
+			runtime->hw.formats |= SNDRV_PCM_FMTBIT_S32_LE;
+	} else {
+		runtime->hw = snd_cmipci_playback_iec958_subframe;
+	}
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x40000);
+	cm->dig_pcm_status = cm->dig_status;
+	return 0;
+}
+
+static int snd_cmipci_capture_spdif_open(snd_pcm_substream_t * substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err;
+
+	if ((err = open_device_check(cm, CM_OPEN_SPDIF_CAPTURE, substream)) < 0) /* use channel B */
+		return err;
+	runtime->hw = snd_cmipci_capture_spdif;
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x40000);
+	return 0;
+}
+
+
+/*
+ */
+
+static int snd_cmipci_playback_close(snd_pcm_substream_t * substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	close_device_check(cm, CM_OPEN_PLAYBACK);
+	return 0;
+}
+
+static int snd_cmipci_capture_close(snd_pcm_substream_t * substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	close_device_check(cm, CM_OPEN_CAPTURE);
+	return 0;
+}
+
+static int snd_cmipci_playback2_close(snd_pcm_substream_t * substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	close_device_check(cm, CM_OPEN_PLAYBACK2);
+	close_device_check(cm, CM_OPEN_PLAYBACK_MULTI);
+	return 0;
+}
+
+static int snd_cmipci_playback_spdif_close(snd_pcm_substream_t * substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	close_device_check(cm, CM_OPEN_SPDIF_PLAYBACK);
+	return 0;
+}
+
+static int snd_cmipci_capture_spdif_close(snd_pcm_substream_t * substream)
+{
+	cmipci_t *cm = snd_pcm_substream_chip(substream);
+	close_device_check(cm, CM_OPEN_SPDIF_CAPTURE);
+	return 0;
+}
+
+
+/*
+ */
+
+static snd_pcm_ops_t snd_cmipci_playback_ops = {
+	.open =		snd_cmipci_playback_open,
+	.close =	snd_cmipci_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_cmipci_hw_params,
+	.hw_free =	snd_cmipci_playback_hw_free,
+	.prepare =	snd_cmipci_playback_prepare,
+	.trigger =	snd_cmipci_playback_trigger,
+	.pointer =	snd_cmipci_playback_pointer,
+};
+
+static snd_pcm_ops_t snd_cmipci_capture_ops = {
+	.open =		snd_cmipci_capture_open,
+	.close =	snd_cmipci_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_cmipci_hw_params,
+	.hw_free =	snd_cmipci_hw_free,
+	.prepare =	snd_cmipci_capture_prepare,
+	.trigger =	snd_cmipci_capture_trigger,
+	.pointer =	snd_cmipci_capture_pointer,
+};
+
+static snd_pcm_ops_t snd_cmipci_playback2_ops = {
+	.open =		snd_cmipci_playback2_open,
+	.close =	snd_cmipci_playback2_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_cmipci_playback2_hw_params,
+	.hw_free =	snd_cmipci_hw_free,
+	.prepare =	snd_cmipci_capture_prepare,	/* channel B */
+	.trigger =	snd_cmipci_capture_trigger,	/* channel B */
+	.pointer =	snd_cmipci_capture_pointer,	/* channel B */
+};
+
+static snd_pcm_ops_t snd_cmipci_playback_spdif_ops = {
+	.open =		snd_cmipci_playback_spdif_open,
+	.close =	snd_cmipci_playback_spdif_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_cmipci_hw_params,
+	.hw_free =	snd_cmipci_playback_hw_free,
+	.prepare =	snd_cmipci_playback_spdif_prepare,	/* set up rate */
+	.trigger =	snd_cmipci_playback_trigger,
+	.pointer =	snd_cmipci_playback_pointer,
+};
+
+static snd_pcm_ops_t snd_cmipci_capture_spdif_ops = {
+	.open =		snd_cmipci_capture_spdif_open,
+	.close =	snd_cmipci_capture_spdif_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_cmipci_hw_params,
+	.hw_free =	snd_cmipci_capture_spdif_hw_free,
+	.prepare =	snd_cmipci_capture_spdif_prepare,
+	.trigger =	snd_cmipci_capture_trigger,
+	.pointer =	snd_cmipci_capture_pointer,
+};
+
+
+/*
+ */
+
+static void snd_cmipci_pcm_free(snd_pcm_t *pcm)
+{
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static int __devinit snd_cmipci_pcm_new(cmipci_t *cm, int device)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	err = snd_pcm_new(cm->card, cm->card->driver, device, 1, 1, &pcm);
+	if (err < 0)
+		return err;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cmipci_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cmipci_capture_ops);
+
+	pcm->private_data = cm;
+	pcm->private_free = snd_cmipci_pcm_free;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "C-Media PCI DAC/ADC");
+	cm->pcm = pcm;
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      snd_dma_pci_data(cm->pci), 64*1024, 128*1024);
+
+	return 0;
+}
+
+static int __devinit snd_cmipci_pcm2_new(cmipci_t *cm, int device)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	err = snd_pcm_new(cm->card, cm->card->driver, device, 1, 0, &pcm);
+	if (err < 0)
+		return err;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cmipci_playback2_ops);
+
+	pcm->private_data = cm;
+	pcm->private_free = snd_cmipci_pcm_free;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "C-Media PCI 2nd DAC");
+	cm->pcm2 = pcm;
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      snd_dma_pci_data(cm->pci), 64*1024, 128*1024);
+
+	return 0;
+}
+
+static int __devinit snd_cmipci_pcm_spdif_new(cmipci_t *cm, int device)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	err = snd_pcm_new(cm->card, cm->card->driver, device, 1, 1, &pcm);
+	if (err < 0)
+		return err;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cmipci_playback_spdif_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cmipci_capture_spdif_ops);
+
+	pcm->private_data = cm;
+	pcm->private_free = snd_cmipci_pcm_free;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "C-Media PCI IEC958");
+	cm->pcm_spdif = pcm;
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      snd_dma_pci_data(cm->pci), 64*1024, 128*1024);
+
+	return 0;
+}
+
+/*
+ * mixer interface:
+ * - CM8338/8738 has a compatible mixer interface with SB16, but
+ *   lack of some elements like tone control, i/o gain and AGC.
+ * - Access to native registers:
+ *   - A 3D switch
+ *   - Output mute switches
+ */
+
+static void snd_cmipci_mixer_write(cmipci_t *s, unsigned char idx, unsigned char data)
+{
+	outb(idx, s->iobase + CM_REG_SB16_ADDR);
+	outb(data, s->iobase + CM_REG_SB16_DATA);
+}
+
+static unsigned char snd_cmipci_mixer_read(cmipci_t *s, unsigned char idx)
+{
+	unsigned char v;
+
+	outb(idx, s->iobase + CM_REG_SB16_ADDR);
+	v = inb(s->iobase + CM_REG_SB16_DATA);
+	return v;
+}
+
+/*
+ * general mixer element
+ */
+typedef struct cmipci_sb_reg {
+	unsigned int left_reg, right_reg;
+	unsigned int left_shift, right_shift;
+	unsigned int mask;
+	unsigned int invert: 1;
+	unsigned int stereo: 1;
+} cmipci_sb_reg_t;
+
+#define COMPOSE_SB_REG(lreg,rreg,lshift,rshift,mask,invert,stereo) \
+ ((lreg) | ((rreg) << 8) | (lshift << 16) | (rshift << 19) | (mask << 24) | (invert << 22) | (stereo << 23))
+
+#define CMIPCI_DOUBLE(xname, left_reg, right_reg, left_shift, right_shift, mask, invert, stereo) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+  .info = snd_cmipci_info_volume, \
+  .get = snd_cmipci_get_volume, .put = snd_cmipci_put_volume, \
+  .private_value = COMPOSE_SB_REG(left_reg, right_reg, left_shift, right_shift, mask, invert, stereo), \
+}
+
+#define CMIPCI_SB_VOL_STEREO(xname,reg,shift,mask) CMIPCI_DOUBLE(xname, reg, reg+1, shift, shift, mask, 0, 1)
+#define CMIPCI_SB_VOL_MONO(xname,reg,shift,mask) CMIPCI_DOUBLE(xname, reg, reg, shift, shift, mask, 0, 0)
+#define CMIPCI_SB_SW_STEREO(xname,lshift,rshift) CMIPCI_DOUBLE(xname, SB_DSP4_OUTPUT_SW, SB_DSP4_OUTPUT_SW, lshift, rshift, 1, 0, 1)
+#define CMIPCI_SB_SW_MONO(xname,shift) CMIPCI_DOUBLE(xname, SB_DSP4_OUTPUT_SW, SB_DSP4_OUTPUT_SW, shift, shift, 1, 0, 0)
+
+static void cmipci_sb_reg_decode(cmipci_sb_reg_t *r, unsigned long val)
+{
+	r->left_reg = val & 0xff;
+	r->right_reg = (val >> 8) & 0xff;
+	r->left_shift = (val >> 16) & 0x07;
+	r->right_shift = (val >> 19) & 0x07;
+	r->invert = (val >> 22) & 1;
+	r->stereo = (val >> 23) & 1;
+	r->mask = (val >> 24) & 0xff;
+}
+
+static int snd_cmipci_info_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	cmipci_sb_reg_t reg;
+
+	cmipci_sb_reg_decode(&reg, kcontrol->private_value);
+	uinfo->type = reg.mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = reg.stereo + 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = reg.mask;
+	return 0;
+}
+ 
+static int snd_cmipci_get_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	cmipci_sb_reg_t reg;
+	int val;
+
+	cmipci_sb_reg_decode(&reg, kcontrol->private_value);
+	spin_lock_irq(&cm->reg_lock);
+	val = (snd_cmipci_mixer_read(cm, reg.left_reg) >> reg.left_shift) & reg.mask;
+	if (reg.invert)
+		val = reg.mask - val;
+	ucontrol->value.integer.value[0] = val;
+	if (reg.stereo) {
+		val = (snd_cmipci_mixer_read(cm, reg.right_reg) >> reg.right_shift) & reg.mask;
+		if (reg.invert)
+			val = reg.mask - val;
+		 ucontrol->value.integer.value[1] = val;
+	}
+	spin_unlock_irq(&cm->reg_lock);
+	return 0;
+}
+
+static int snd_cmipci_put_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	cmipci_sb_reg_t reg;
+	int change;
+	int left, right, oleft, oright;
+
+	cmipci_sb_reg_decode(&reg, kcontrol->private_value);
+	left = ucontrol->value.integer.value[0] & reg.mask;
+	if (reg.invert)
+		left = reg.mask - left;
+	left <<= reg.left_shift;
+	if (reg.stereo) {
+		right = ucontrol->value.integer.value[1] & reg.mask;
+		if (reg.invert)
+			right = reg.mask - right;
+		right <<= reg.right_shift;
+	} else
+		right = 0;
+	spin_lock_irq(&cm->reg_lock);
+	oleft = snd_cmipci_mixer_read(cm, reg.left_reg);
+	left |= oleft & ~(reg.mask << reg.left_shift);
+	change = left != oleft;
+	if (reg.stereo) {
+		if (reg.left_reg != reg.right_reg) {
+			snd_cmipci_mixer_write(cm, reg.left_reg, left);
+			oright = snd_cmipci_mixer_read(cm, reg.right_reg);
+		} else
+			oright = left;
+		right |= oright & ~(reg.mask << reg.right_shift);
+		change |= right != oright;
+		snd_cmipci_mixer_write(cm, reg.right_reg, right);
+	} else
+		snd_cmipci_mixer_write(cm, reg.left_reg, left);
+	spin_unlock_irq(&cm->reg_lock);
+	return change;
+}
+
+/*
+ * input route (left,right) -> (left,right)
+ */
+#define CMIPCI_SB_INPUT_SW(xname, left_shift, right_shift) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+  .info = snd_cmipci_info_input_sw, \
+  .get = snd_cmipci_get_input_sw, .put = snd_cmipci_put_input_sw, \
+  .private_value = COMPOSE_SB_REG(SB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT, left_shift, right_shift, 1, 0, 1), \
+}
+
+static int snd_cmipci_info_input_sw(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 4;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+ 
+static int snd_cmipci_get_input_sw(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	cmipci_sb_reg_t reg;
+	int val1, val2;
+
+	cmipci_sb_reg_decode(&reg, kcontrol->private_value);
+	spin_lock_irq(&cm->reg_lock);
+	val1 = snd_cmipci_mixer_read(cm, reg.left_reg);
+	val2 = snd_cmipci_mixer_read(cm, reg.right_reg);
+	spin_unlock_irq(&cm->reg_lock);
+	ucontrol->value.integer.value[0] = (val1 >> reg.left_shift) & 1;
+	ucontrol->value.integer.value[1] = (val2 >> reg.left_shift) & 1;
+	ucontrol->value.integer.value[2] = (val1 >> reg.right_shift) & 1;
+	ucontrol->value.integer.value[3] = (val2 >> reg.right_shift) & 1;
+	return 0;
+}
+
+static int snd_cmipci_put_input_sw(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	cmipci_sb_reg_t reg;
+	int change;
+	int val1, val2, oval1, oval2;
+
+	cmipci_sb_reg_decode(&reg, kcontrol->private_value);
+	spin_lock_irq(&cm->reg_lock);
+	oval1 = snd_cmipci_mixer_read(cm, reg.left_reg);
+	oval2 = snd_cmipci_mixer_read(cm, reg.right_reg);
+	val1 = oval1 & ~((1 << reg.left_shift) | (1 << reg.right_shift));
+	val2 = oval2 & ~((1 << reg.left_shift) | (1 << reg.right_shift));
+	val1 |= (ucontrol->value.integer.value[0] & 1) << reg.left_shift;
+	val2 |= (ucontrol->value.integer.value[1] & 1) << reg.left_shift;
+	val1 |= (ucontrol->value.integer.value[2] & 1) << reg.right_shift;
+	val2 |= (ucontrol->value.integer.value[3] & 1) << reg.right_shift;
+	change = val1 != oval1 || val2 != oval2;
+	snd_cmipci_mixer_write(cm, reg.left_reg, val1);
+	snd_cmipci_mixer_write(cm, reg.right_reg, val2);
+	spin_unlock_irq(&cm->reg_lock);
+	return change;
+}
+
+/*
+ * native mixer switches/volumes
+ */
+
+#define CMIPCI_MIXER_SW_STEREO(xname, reg, lshift, rshift, invert) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+  .info = snd_cmipci_info_native_mixer, \
+  .get = snd_cmipci_get_native_mixer, .put = snd_cmipci_put_native_mixer, \
+  .private_value = COMPOSE_SB_REG(reg, reg, lshift, rshift, 1, invert, 1), \
+}
+
+#define CMIPCI_MIXER_SW_MONO(xname, reg, shift, invert) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+  .info = snd_cmipci_info_native_mixer, \
+  .get = snd_cmipci_get_native_mixer, .put = snd_cmipci_put_native_mixer, \
+  .private_value = COMPOSE_SB_REG(reg, reg, shift, shift, 1, invert, 0), \
+}
+
+#define CMIPCI_MIXER_VOL_STEREO(xname, reg, lshift, rshift, mask) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+  .info = snd_cmipci_info_native_mixer, \
+  .get = snd_cmipci_get_native_mixer, .put = snd_cmipci_put_native_mixer, \
+  .private_value = COMPOSE_SB_REG(reg, reg, lshift, rshift, mask, 0, 1), \
+}
+
+#define CMIPCI_MIXER_VOL_MONO(xname, reg, shift, mask) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+  .info = snd_cmipci_info_native_mixer, \
+  .get = snd_cmipci_get_native_mixer, .put = snd_cmipci_put_native_mixer, \
+  .private_value = COMPOSE_SB_REG(reg, reg, shift, shift, mask, 0, 0), \
+}
+
+static int snd_cmipci_info_native_mixer(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	cmipci_sb_reg_t reg;
+
+	cmipci_sb_reg_decode(&reg, kcontrol->private_value);
+	uinfo->type = reg.mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = reg.stereo + 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = reg.mask;
+	return 0;
+
+}
+
+static int snd_cmipci_get_native_mixer(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	cmipci_sb_reg_t reg;
+	unsigned char oreg, val;
+
+	cmipci_sb_reg_decode(&reg, kcontrol->private_value);
+	spin_lock_irq(&cm->reg_lock);
+	oreg = inb(cm->iobase + reg.left_reg);
+	val = (oreg >> reg.left_shift) & reg.mask;
+	if (reg.invert)
+		val = reg.mask - val;
+	ucontrol->value.integer.value[0] = val;
+	if (reg.stereo) {
+		val = (oreg >> reg.right_shift) & reg.mask;
+		if (reg.invert)
+			val = reg.mask - val;
+		ucontrol->value.integer.value[1] = val;
+	}
+	spin_unlock_irq(&cm->reg_lock);
+	return 0;
+}
+
+static int snd_cmipci_put_native_mixer(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	cmipci_sb_reg_t reg;
+	unsigned char oreg, nreg, val;
+
+	cmipci_sb_reg_decode(&reg, kcontrol->private_value);
+	spin_lock_irq(&cm->reg_lock);
+	oreg = inb(cm->iobase + reg.left_reg);
+	val = ucontrol->value.integer.value[0] & reg.mask;
+	if (reg.invert)
+		val = reg.mask - val;
+	nreg = oreg & ~(reg.mask << reg.left_shift);
+	nreg |= (val << reg.left_shift);
+	if (reg.stereo) {
+		val = ucontrol->value.integer.value[1] & reg.mask;
+		if (reg.invert)
+			val = reg.mask - val;
+		nreg &= ~(reg.mask << reg.right_shift);
+		nreg |= (val << reg.right_shift);
+	}
+	outb(nreg, cm->iobase + reg.left_reg);
+	spin_unlock_irq(&cm->reg_lock);
+	return (nreg != oreg);
+}
+
+/*
+ * special case - check mixer sensitivity
+ */
+static int snd_cmipci_get_native_mixer_sensitive(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	//cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	return snd_cmipci_get_native_mixer(kcontrol, ucontrol);
+}
+
+static int snd_cmipci_put_native_mixer_sensitive(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+	if (cm->mixer_insensitive) {
+		/* ignored */
+		return 0;
+	}
+	return snd_cmipci_put_native_mixer(kcontrol, ucontrol);
+}
+
+
+static snd_kcontrol_new_t snd_cmipci_mixers[] __devinitdata = {
+	CMIPCI_SB_VOL_STEREO("Master Playback Volume", SB_DSP4_MASTER_DEV, 3, 31),
+	CMIPCI_MIXER_SW_MONO("3D Control - Switch", CM_REG_MIXER1, CM_X3DEN_SHIFT, 0),
+	CMIPCI_SB_VOL_STEREO("PCM Playback Volume", SB_DSP4_PCM_DEV, 3, 31),
+	//CMIPCI_MIXER_SW_MONO("PCM Playback Switch", CM_REG_MIXER1, CM_WSMUTE_SHIFT, 1),
+	{ /* switch with sensitivity */
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "PCM Playback Switch",
+		.info = snd_cmipci_info_native_mixer,
+		.get = snd_cmipci_get_native_mixer_sensitive,
+		.put = snd_cmipci_put_native_mixer_sensitive,
+		.private_value = COMPOSE_SB_REG(CM_REG_MIXER1, CM_REG_MIXER1, CM_WSMUTE_SHIFT, CM_WSMUTE_SHIFT, 1, 1, 0),
+	},
+	CMIPCI_MIXER_SW_STEREO("PCM Capture Switch", CM_REG_MIXER1, CM_WAVEINL_SHIFT, CM_WAVEINR_SHIFT, 0),
+	CMIPCI_SB_VOL_STEREO("Synth Playback Volume", SB_DSP4_SYNTH_DEV, 3, 31),
+	CMIPCI_MIXER_SW_MONO("Synth Playback Switch", CM_REG_MIXER1, CM_FMMUTE_SHIFT, 1),
+	CMIPCI_SB_INPUT_SW("Synth Capture Route", 6, 5),
+	CMIPCI_SB_VOL_STEREO("CD Playback Volume", SB_DSP4_CD_DEV, 3, 31),
+	CMIPCI_SB_SW_STEREO("CD Playback Switch", 2, 1),
+	CMIPCI_SB_INPUT_SW("CD Capture Route", 2, 1),
+	CMIPCI_SB_VOL_STEREO("Line Playback Volume", SB_DSP4_LINE_DEV, 3, 31),
+	CMIPCI_SB_SW_STEREO("Line Playback Switch", 4, 3),
+	CMIPCI_SB_INPUT_SW("Line Capture Route", 4, 3),
+	CMIPCI_SB_VOL_MONO("Mic Playback Volume", SB_DSP4_MIC_DEV, 3, 31),
+	CMIPCI_SB_SW_MONO("Mic Playback Switch", 0),
+	CMIPCI_DOUBLE("Mic Capture Switch", SB_DSP4_INPUT_LEFT, SB_DSP4_INPUT_RIGHT, 0, 0, 1, 0, 0),
+	CMIPCI_SB_VOL_MONO("PC Speaker Playback Volume", SB_DSP4_SPEAKER_DEV, 6, 3),
+	CMIPCI_MIXER_VOL_STEREO("Aux Playback Volume", CM_REG_AUX_VOL, 4, 0, 15),
+	CMIPCI_MIXER_SW_STEREO("Aux Playback Switch", CM_REG_MIXER2, CM_VAUXLM_SHIFT, CM_VAUXRM_SHIFT, 0),
+	CMIPCI_MIXER_SW_STEREO("Aux Capture Switch", CM_REG_MIXER2, CM_RAUXLEN_SHIFT, CM_RAUXREN_SHIFT, 0),
+	CMIPCI_MIXER_SW_MONO("Mic Boost", CM_REG_MIXER2, CM_MICGAINZ_SHIFT, 1),
+	CMIPCI_MIXER_VOL_MONO("Mic Capture Volume", CM_REG_MIXER2, CM_VADMIC_SHIFT, 7),
+};
+
+/*
+ * other switches
+ */
+
+typedef struct snd_cmipci_switch_args {
+	int reg;		/* register index */
+	unsigned int mask;	/* mask bits */
+	unsigned int mask_on;	/* mask bits to turn on */
+	unsigned int is_byte: 1;		/* byte access? */
+	unsigned int ac3_sensitive: 1;	/* access forbidden during non-audio operation? */
+} snd_cmipci_switch_args_t;
+
+static int snd_cmipci_uswitch_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int _snd_cmipci_uswitch_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol, snd_cmipci_switch_args_t *args)
+{
+	unsigned int val;
+	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&cm->reg_lock);
+	if (args->ac3_sensitive && cm->mixer_insensitive) {
+		ucontrol->value.integer.value[0] = 0;
+		spin_unlock_irq(&cm->reg_lock);
+		return 0;
+	}
+	if (args->is_byte)
+		val = inb(cm->iobase + args->reg);
+	else
+		val = snd_cmipci_read(cm, args->reg);
+	ucontrol->value.integer.value[0] = ((val & args->mask) == args->mask_on) ? 1 : 0;
+	spin_unlock_irq(&cm->reg_lock);
+	return 0;
+}
+
+static int snd_cmipci_uswitch_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	snd_cmipci_switch_args_t *args = (snd_cmipci_switch_args_t*)kcontrol->private_value;
+	snd_assert(args != NULL, return -EINVAL);
+	return _snd_cmipci_uswitch_get(kcontrol, ucontrol, args);
+}
+
+static int _snd_cmipci_uswitch_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol, snd_cmipci_switch_args_t *args)
+{
+	unsigned int val;
+	int change;
+	cmipci_t *cm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&cm->reg_lock);
+	if (args->ac3_sensitive && cm->mixer_insensitive) {
+		/* ignored */
+		spin_unlock_irq(&cm->reg_lock);
+		return 0;
+	}
+	if (args->is_byte)
+		val = inb(cm->iobase + args->reg);
+	else
+		val = snd_cmipci_read(cm, args->reg);
+	change = (val & args->mask) != (ucontrol->value.integer.value[0] ? args->mask : 0);
+	if (change) {
+		val &= ~args->mask;
+		if (ucontrol->value.integer.value[0])
+			val |= args->mask_on;
+		else
+			val |= (args->mask & ~args->mask_on);
+		if (args->is_byte)
+			outb((unsigned char)val, cm->iobase + args->reg);
+		else
+			snd_cmipci_write(cm, args->reg, val);
+	}
+	spin_unlock_irq(&cm->reg_lock);
+	return change;
+}
+
+static int snd_cmipci_uswitch_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	snd_cmipci_switch_args_t *args = (snd_cmipci_switch_args_t*)kcontrol->private_value;
+	snd_assert(args != NULL, return -EINVAL);
+	return _snd_cmipci_uswitch_put(kcontrol, ucontrol, args);
+}
+
+#define DEFINE_SWITCH_ARG(sname, xreg, xmask, xmask_on, xis_byte, xac3) \
+static snd_cmipci_switch_args_t cmipci_switch_arg_##sname = { \
+  .reg = xreg, \
+  .mask = xmask, \
+  .mask_on = xmask_on, \
+  .is_byte = xis_byte, \
+  .ac3_sensitive = xac3, \
+}
+	
+#define DEFINE_BIT_SWITCH_ARG(sname, xreg, xmask, xis_byte, xac3) \
+	DEFINE_SWITCH_ARG(sname, xreg, xmask, xmask, xis_byte, xac3)
+
+#if 0 /* these will be controlled in pcm device */
+DEFINE_BIT_SWITCH_ARG(spdif_in, CM_REG_FUNCTRL1, CM_SPDF_1, 0, 0);
+DEFINE_BIT_SWITCH_ARG(spdif_out, CM_REG_FUNCTRL1, CM_SPDF_0, 0, 0);
+#endif
+DEFINE_BIT_SWITCH_ARG(spdif_in_sel1, CM_REG_CHFORMAT, CM_SPDIF_SELECT1, 0, 0);
+DEFINE_BIT_SWITCH_ARG(spdif_in_sel2, CM_REG_MISC_CTRL, CM_SPDIF_SELECT2, 0, 0);
+DEFINE_BIT_SWITCH_ARG(spdif_enable, CM_REG_LEGACY_CTRL, CM_ENSPDOUT, 0, 0);
+DEFINE_BIT_SWITCH_ARG(spdo2dac, CM_REG_FUNCTRL1, CM_SPDO2DAC, 0, 1);
+DEFINE_BIT_SWITCH_ARG(spdi_valid, CM_REG_MISC, CM_SPDVALID, 1, 0);
+DEFINE_BIT_SWITCH_ARG(spdif_copyright, CM_REG_LEGACY_CTRL, CM_SPDCOPYRHT, 0, 0);
+DEFINE_BIT_SWITCH_ARG(spdif_dac_out, CM_REG_LEGACY_CTRL, CM_DAC2SPDO, 0, 1);
+DEFINE_SWITCH_ARG(spdo_5v, CM_REG_MISC_CTRL, CM_SPDO5V, 0, 0, 0); /* inverse: 0 = 5V */
+// DEFINE_BIT_SWITCH_ARG(spdo_48k, CM_REG_MISC_CTRL, CM_SPDF_AC97|CM_SPDIF48K, 0, 1);
+DEFINE_BIT_SWITCH_ARG(spdif_loop, CM_REG_FUNCTRL1, CM_SPDFLOOP, 0, 1);
+DEFINE_BIT_SWITCH_ARG(spdi_monitor, CM_REG_MIXER1, CM_CDPLAY, 1, 0);
+/* DEFINE_BIT_SWITCH_ARG(spdi_phase, CM_REG_CHFORMAT, CM_SPDIF_INVERSE, 0, 0); */
+DEFINE_BIT_SWITCH_ARG(spdi_phase, CM_REG_MISC, CM_SPDIF_INVERSE, 1, 0);
+DEFINE_BIT_SWITCH_ARG(spdi_phase2, CM_REG_CHFORMAT, CM_SPDIF_INVERSE2, 0, 0);
+#if CM_CH_PLAY == 1
+DEFINE_SWITCH_ARG(exchange_dac, CM_REG_MISC_CTRL, CM_XCHGDAC, 0, 0, 0); /* reversed */
+#else
+DEFINE_SWITCH_ARG(exchange_dac, CM_REG_MISC_CTRL, CM_XCHGDAC, CM_XCHGDAC, 0, 0);
+#endif
+DEFINE_BIT_SWITCH_ARG(fourch, CM_REG_MISC_CTRL, CM_N4SPK3D, 0, 0);
+DEFINE_BIT_SWITCH_ARG(line_rear, CM_REG_MIXER1, CM_SPK4, 1, 0);
+DEFINE_BIT_SWITCH_ARG(line_bass, CM_REG_LEGACY_CTRL, CM_LINE_AS_BASS, 0, 0);
+// DEFINE_BIT_SWITCH_ARG(joystick, CM_REG_FUNCTRL1, CM_JYSTK_EN, 0, 0); /* now module option */
+DEFINE_SWITCH_ARG(modem, CM_REG_MISC_CTRL, CM_FLINKON|CM_FLINKOFF, CM_FLINKON, 0, 0);
+
+#define DEFINE_SWITCH(sname, stype, sarg) \
+{ .name = sname, \
+  .iface = stype, \
+  .info = snd_cmipci_uswitch_info, \
+  .get = snd_cmipci_uswitch_get, \
+  .put = snd_cmipci_uswitch_put, \
+  .private_value = (unsigned long)&cmipci_switch_arg_##sarg,\
+}
+
+#define DEFINE_CARD_SWITCH(sname, sarg) DEFINE_SWITCH(sname, SNDRV_CTL_ELEM_IFACE_CARD, sarg)
+#define DEFINE_MIXER_SWITCH(sname, sarg) DEFINE_SWITCH(sname, SNDRV_CTL_ELEM_IFACE_MIXER, sarg)
+
+
+/*
+ * callbacks for spdif output switch
+ * needs toggle two registers..
+ */
+static int snd_cmipci_spdout_enable_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	int changed;
+	changed = _snd_cmipci_uswitch_get(kcontrol, ucontrol, &cmipci_switch_arg_spdif_enable);
+	changed |= _snd_cmipci_uswitch_get(kcontrol, ucontrol, &cmipci_switch_arg_spdo2dac);
+	return changed;
+}
+
+static int snd_cmipci_spdout_enable_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *ucontrol)
+{
+	cmipci_t *chip = snd_kcontrol_chip(kcontrol);
+	int changed;
+	changed = _snd_cmipci_uswitch_put(kcontrol, ucontrol, &cmipci_switch_arg_spdif_enable);
+	changed |= _snd_cmipci_uswitch_put(kcontrol, ucontrol, &cmipci_switch_arg_spdo2dac);
+	if (changed) {
+		if (ucontrol->value.integer.value[0]) {
+			if (chip->spdif_playback_avail)
+				snd_cmipci_set_bit(chip, CM_REG_FUNCTRL1, CM_PLAYBACK_SPDF);
+		} else {
+			if (chip->spdif_playback_avail)
+				snd_cmipci_clear_bit(chip, CM_REG_FUNCTRL1, CM_PLAYBACK_SPDF);
+		}
+	}
+	chip->spdif_playback_enabled = ucontrol->value.integer.value[0];
+	return changed;
+}
+
+
+/* both for CM8338/8738 */
+static snd_kcontrol_new_t snd_cmipci_mixer_switches[] __devinitdata = {
+	DEFINE_MIXER_SWITCH("Four Channel Mode", fourch),
+	DEFINE_MIXER_SWITCH("Line-In As Rear", line_rear),
+};
+
+/* for non-multichannel chips */
+static snd_kcontrol_new_t snd_cmipci_nomulti_switch __devinitdata =
+DEFINE_MIXER_SWITCH("Exchange DAC", exchange_dac);
+
+/* only for CM8738 */
+static snd_kcontrol_new_t snd_cmipci_8738_mixer_switches[] __devinitdata = {
+#if 0 /* controlled in pcm device */
+	DEFINE_MIXER_SWITCH("IEC958 In Record", spdif_in),
+	DEFINE_MIXER_SWITCH("IEC958 Out", spdif_out),
+	DEFINE_MIXER_SWITCH("IEC958 Out To DAC", spdo2dac),
+#endif
+	// DEFINE_MIXER_SWITCH("IEC958 Output Switch", spdif_enable),
+	{ .name = "IEC958 Output Switch",
+	  .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	  .info = snd_cmipci_uswitch_info,
+	  .get = snd_cmipci_spdout_enable_get,
+	  .put = snd_cmipci_spdout_enable_put,
+	},
+	DEFINE_MIXER_SWITCH("IEC958 In Valid", spdi_valid),
+	DEFINE_MIXER_SWITCH("IEC958 Copyright", spdif_copyright),
+	DEFINE_MIXER_SWITCH("IEC958 5V", spdo_5v),
+//	DEFINE_MIXER_SWITCH("IEC958 In/Out 48KHz", spdo_48k),
+	DEFINE_MIXER_SWITCH("IEC958 Loop", spdif_loop),
+	DEFINE_MIXER_SWITCH("IEC958 In Monitor", spdi_monitor),
+};
+
+/* only for model 033/037 */
+static snd_kcontrol_new_t snd_cmipci_old_mixer_switches[] __devinitdata = {
+	DEFINE_MIXER_SWITCH("IEC958 Mix Analog", spdif_dac_out),
+	DEFINE_MIXER_SWITCH("IEC958 In Phase Inverse", spdi_phase),
+	DEFINE_MIXER_SWITCH("IEC958 In Select", spdif_in_sel1),
+};
+
+/* only for model 039 or later */
+static snd_kcontrol_new_t snd_cmipci_extra_mixer_switches[] __devinitdata = {
+	DEFINE_MIXER_SWITCH("Line-In As Bass", line_bass),
+	DEFINE_MIXER_SWITCH("IEC958 In Select", spdif_in_sel2),
+	DEFINE_MIXER_SWITCH("IEC958 In Phase Inverse", spdi_phase2),
+	DEFINE_MIXER_SWITCH("Mic As Center/LFE", spdi_phase), /* same bit as spdi_phase */
+};
+
+/* card control switches */
+static snd_kcontrol_new_t snd_cmipci_control_switches[] __devinitdata = {
+	// DEFINE_CARD_SWITCH("Joystick", joystick), /* now module option */
+	DEFINE_CARD_SWITCH("Modem", modem),
+};
+
+
+static int __devinit snd_cmipci_mixer_new(cmipci_t *cm, int pcm_spdif_device)
+{
+	snd_card_t *card;
+	snd_kcontrol_new_t *sw;
+	snd_kcontrol_t *kctl;
+	unsigned int idx;
+	int err;
+
+	snd_assert(cm != NULL && cm->card != NULL, return -EINVAL);
+
+	card = cm->card;
+
+	strcpy(card->mixername, "CMedia PCI");
+
+	spin_lock_irq(&cm->reg_lock);
+	snd_cmipci_mixer_write(cm, 0x00, 0x00);		/* mixer reset */
+	spin_unlock_irq(&cm->reg_lock);
+
+	for (idx = 0; idx < ARRAY_SIZE(snd_cmipci_mixers); idx++) {
+		if (cm->chip_version == 68) {	// 8768 has no PCM volume
+			if (!strcmp(snd_cmipci_mixers[idx].name,
+				"PCM Playback Volume"))
+				continue;
+		}
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_cmipci_mixers[idx], cm))) < 0)
+			return err;
+	}
+
+	/* mixer switches */
+	sw = snd_cmipci_mixer_switches;
+	for (idx = 0; idx < ARRAY_SIZE(snd_cmipci_mixer_switches); idx++, sw++) {
+		err = snd_ctl_add(cm->card, snd_ctl_new1(sw, cm));
+		if (err < 0)
+			return err;
+	}
+	if (! cm->can_multi_ch) {
+		err = snd_ctl_add(cm->card, snd_ctl_new1(&snd_cmipci_nomulti_switch, cm));
+		if (err < 0)
+			return err;
+	}
+	if (cm->device == PCI_DEVICE_ID_CMEDIA_CM8738 ||
+	    cm->device == PCI_DEVICE_ID_CMEDIA_CM8738B) {
+		sw = snd_cmipci_8738_mixer_switches;
+		for (idx = 0; idx < ARRAY_SIZE(snd_cmipci_8738_mixer_switches); idx++, sw++) {
+			err = snd_ctl_add(cm->card, snd_ctl_new1(sw, cm));
+			if (err < 0)
+				return err;
+		}
+		if (cm->can_ac3_hw) {
+			if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_cmipci_spdif_default, cm))) < 0)
+				return err;
+			kctl->id.device = pcm_spdif_device;
+			if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_cmipci_spdif_mask, cm))) < 0)
+				return err;
+			kctl->id.device = pcm_spdif_device;
+			if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_cmipci_spdif_stream, cm))) < 0)
+				return err;
+			kctl->id.device = pcm_spdif_device;
+		}
+		if (cm->chip_version <= 37) {
+			sw = snd_cmipci_old_mixer_switches;
+			for (idx = 0; idx < ARRAY_SIZE(snd_cmipci_old_mixer_switches); idx++, sw++) {
+				err = snd_ctl_add(cm->card, snd_ctl_new1(sw, cm));
+				if (err < 0)
+					return err;
+			}
+		}
+	}
+	if (cm->chip_version >= 39) {
+		sw = snd_cmipci_extra_mixer_switches;
+		for (idx = 0; idx < ARRAY_SIZE(snd_cmipci_extra_mixer_switches); idx++, sw++) {
+			err = snd_ctl_add(cm->card, snd_ctl_new1(sw, cm));
+			if (err < 0)
+				return err;
+		}
+	}
+
+	/* card switches */
+	sw = snd_cmipci_control_switches;
+	for (idx = 0; idx < ARRAY_SIZE(snd_cmipci_control_switches); idx++, sw++) {
+		err = snd_ctl_add(cm->card, snd_ctl_new1(sw, cm));
+		if (err < 0)
+			return err;
+	}
+
+	for (idx = 0; idx < CM_SAVED_MIXERS; idx++) {
+		snd_ctl_elem_id_t id;
+		snd_kcontrol_t *ctl;
+		memset(&id, 0, sizeof(id));
+		id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+		strcpy(id.name, cm_saved_mixer[idx].name);
+		if ((ctl = snd_ctl_find_id(cm->card, &id)) != NULL)
+			cm->mixer_res_ctl[idx] = ctl;
+	}
+
+	return 0;
+}
+
+
+/*
+ * proc interface
+ */
+
+#ifdef CONFIG_PROC_FS
+static void snd_cmipci_proc_read(snd_info_entry_t *entry, 
+				 snd_info_buffer_t *buffer)
+{
+	cmipci_t *cm = entry->private_data;
+	int i;
+	
+	snd_iprintf(buffer, "%s\n\n", cm->card->longname);
+	for (i = 0; i < 0x40; i++) {
+		int v = inb(cm->iobase + i);
+		if (i % 4 == 0)
+			snd_iprintf(buffer, "%02x: ", i);
+		snd_iprintf(buffer, "%02x", v);
+		if (i % 4 == 3)
+			snd_iprintf(buffer, "\n");
+		else
+			snd_iprintf(buffer, " ");
+	}
+}
+
+static void __devinit snd_cmipci_proc_init(cmipci_t *cm)
+{
+	snd_info_entry_t *entry;
+
+	if (! snd_card_proc_new(cm->card, "cmipci", &entry))
+		snd_info_set_text_ops(entry, cm, 1024, snd_cmipci_proc_read);
+}
+#else /* !CONFIG_PROC_FS */
+static inline void snd_cmipci_proc_init(cmipci_t *cm) {}
+#endif
+
+
+static struct pci_device_id snd_cmipci_ids[] = {
+	{PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8338B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_CMEDIA, PCI_DEVICE_ID_CMEDIA_CM8738B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_AL, PCI_DEVICE_ID_CMEDIA_CM8738, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0,},
+};
+
+
+/*
+ * check chip version and capabilities
+ * driver name is modified according to the chip model
+ */
+static void __devinit query_chip(cmipci_t *cm)
+{
+	unsigned int detect;
+
+	/* check reg 0Ch, bit 24-31 */
+	detect = snd_cmipci_read(cm, CM_REG_INT_HLDCLR) & CM_CHIP_MASK2;
+	if (! detect) {
+		/* check reg 08h, bit 24-28 */
+		detect = snd_cmipci_read(cm, CM_REG_CHFORMAT) & CM_CHIP_MASK1;
+		if (! detect) {
+			cm->chip_version = 33;
+			cm->max_channels = 2;
+			if (cm->do_soft_ac3)
+				cm->can_ac3_sw = 1;
+			else
+				cm->can_ac3_hw = 1;
+			cm->has_dual_dac = 1;
+		} else {
+			cm->chip_version = 37;
+			cm->max_channels = 2;
+			cm->can_ac3_hw = 1;
+			cm->has_dual_dac = 1;
+		}
+	} else {
+		/* check reg 0Ch, bit 26 */
+		if (detect & CM_CHIP_8768) {
+			cm->chip_version = 68;
+			cm->max_channels = 8;
+			cm->can_ac3_hw = 1;
+			cm->has_dual_dac = 1;
+			cm->can_multi_ch = 1;
+		} else if (detect & CM_CHIP_055) {
+			cm->chip_version = 55;
+			cm->max_channels = 6;
+			cm->can_ac3_hw = 1;
+			cm->has_dual_dac = 1;
+			cm->can_multi_ch = 1;
+		} else if (detect & CM_CHIP_039) {
+			cm->chip_version = 39;
+			if (detect & CM_CHIP_039_6CH) /* 4 or 6 channels */
+				cm->max_channels = 6;
+			else
+				cm->max_channels = 4;
+			cm->can_ac3_hw = 1;
+			cm->has_dual_dac = 1;
+			cm->can_multi_ch = 1;
+		} else {
+			printk(KERN_ERR "chip %x version not supported\n", detect);
+		}
+	}
+}
+
+#ifdef SUPPORT_JOYSTICK
+static int __devinit snd_cmipci_create_gameport(cmipci_t *cm, int dev)
+{
+	static int ports[] = { 0x201, 0x200, 0 }; /* FIXME: majority is 0x201? */
+	struct gameport *gp;
+	struct resource *r = NULL;
+	int i, io_port = 0;
+
+	if (joystick_port[dev] == 0)
+		return -ENODEV;
+
+	if (joystick_port[dev] == 1) { /* auto-detect */
+		for (i = 0; ports[i]; i++) {
+			io_port = ports[i];
+			r = request_region(io_port, 1, "CMIPCI gameport");
+			if (r)
+				break;
+		}
+	} else {
+		io_port = joystick_port[dev];
+		r = request_region(io_port, 1, "CMIPCI gameport");
+	}
+
+	if (!r) {
+		printk(KERN_WARNING "cmipci: cannot reserve joystick ports\n");
+		return -EBUSY;
+	}
+
+	cm->gameport = gp = gameport_allocate_port();
+	if (!gp) {
+		printk(KERN_ERR "cmipci: cannot allocate memory for gameport\n");
+		release_resource(r);
+		kfree_nocheck(r);
+		return -ENOMEM;
+	}
+	gameport_set_name(gp, "C-Media Gameport");
+	gameport_set_phys(gp, "pci%s/gameport0", pci_name(cm->pci));
+	gameport_set_dev_parent(gp, &cm->pci->dev);
+	gp->io = io_port;
+	gameport_set_port_data(gp, r);
+
+	snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_JYSTK_EN);
+
+	gameport_register_port(cm->gameport);
+
+	return 0;
+}
+
+static void snd_cmipci_free_gameport(cmipci_t *cm)
+{
+	if (cm->gameport) {
+		struct resource *r = gameport_get_port_data(cm->gameport);
+
+		gameport_unregister_port(cm->gameport);
+		cm->gameport = NULL;
+
+		snd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_JYSTK_EN);
+		release_resource(r);
+		kfree_nocheck(r);
+	}
+}
+#else
+static inline int snd_cmipci_create_gameport(cmipci_t *cm, int dev) { return -ENOSYS; }
+static inline void snd_cmipci_free_gameport(cmipci_t *cm) { }
+#endif
+
+static int snd_cmipci_free(cmipci_t *cm)
+{
+	if (cm->irq >= 0) {
+		snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);
+		snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_ENSPDOUT);
+		snd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);  /* disable ints */
+		snd_cmipci_ch_reset(cm, CM_CH_PLAY);
+		snd_cmipci_ch_reset(cm, CM_CH_CAPT);
+		snd_cmipci_write(cm, CM_REG_FUNCTRL0, 0); /* disable channels */
+		snd_cmipci_write(cm, CM_REG_FUNCTRL1, 0);
+
+		/* reset mixer */
+		snd_cmipci_mixer_write(cm, 0, 0);
+
+		synchronize_irq(cm->irq);
+
+		free_irq(cm->irq, (void *)cm);
+	}
+
+	snd_cmipci_free_gameport(cm);
+	pci_release_regions(cm->pci);
+	pci_disable_device(cm->pci);
+	kfree(cm);
+	return 0;
+}
+
+static int snd_cmipci_dev_free(snd_device_t *device)
+{
+	cmipci_t *cm = device->device_data;
+	return snd_cmipci_free(cm);
+}
+
+static int __devinit snd_cmipci_create(snd_card_t *card, struct pci_dev *pci,
+				       int dev, cmipci_t **rcmipci)
+{
+	cmipci_t *cm;
+	int err;
+	static snd_device_ops_t ops = {
+		.dev_free =	snd_cmipci_dev_free,
+	};
+	unsigned int val = 0;
+	long iomidi = mpu_port[dev];
+	long iosynth = fm_port[dev];
+	int pcm_index, pcm_spdif_index;
+	static struct pci_device_id intel_82437vx[] = {
+		{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82437VX) },
+		{ },
+	};
+
+	*rcmipci = NULL;
+
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+
+	cm = kcalloc(1, sizeof(*cm), GFP_KERNEL);
+	if (cm == NULL) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&cm->reg_lock);
+	init_MUTEX(&cm->open_mutex);
+	cm->device = pci->device;
+	cm->card = card;
+	cm->pci = pci;
+	cm->irq = -1;
+	cm->channel[0].ch = 0;
+	cm->channel[1].ch = 1;
+	cm->channel[0].is_dac = cm->channel[1].is_dac = 1; /* dual DAC mode */
+
+	if ((err = pci_request_regions(pci, card->driver)) < 0) {
+		kfree(cm);
+		pci_disable_device(pci);
+		return err;
+	}
+	cm->iobase = pci_resource_start(pci, 0);
+
+	if (request_irq(pci->irq, snd_cmipci_interrupt, SA_INTERRUPT|SA_SHIRQ, card->driver, (void *)cm)) {
+		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_cmipci_free(cm);
+		return -EBUSY;
+	}
+	cm->irq = pci->irq;
+
+	pci_set_master(cm->pci);
+
+	/*
+	 * check chip version, max channels and capabilities
+	 */
+
+	cm->chip_version = 0;
+	cm->max_channels = 2;
+	cm->do_soft_ac3 = soft_ac3[dev];
+
+	if (pci->device != PCI_DEVICE_ID_CMEDIA_CM8338A &&
+	    pci->device != PCI_DEVICE_ID_CMEDIA_CM8338B)
+		query_chip(cm);
+	/* added -MCx suffix for chip supporting multi-channels */
+	if (cm->can_multi_ch)
+		sprintf(cm->card->driver + strlen(cm->card->driver),
+			"-MC%d", cm->max_channels);
+	else if (cm->can_ac3_sw)
+		strcpy(cm->card->driver + strlen(cm->card->driver), "-SWIEC");
+
+	cm->dig_status = SNDRV_PCM_DEFAULT_CON_SPDIF;
+	cm->dig_pcm_status = SNDRV_PCM_DEFAULT_CON_SPDIF;
+
+#if CM_CH_PLAY == 1
+	cm->ctrl = CM_CHADC0;	/* default FUNCNTRL0 */
+#else
+	cm->ctrl = CM_CHADC1;	/* default FUNCNTRL0 */
+#endif
+
+	/* initialize codec registers */
+	snd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);	/* disable ints */
+	snd_cmipci_ch_reset(cm, CM_CH_PLAY);
+	snd_cmipci_ch_reset(cm, CM_CH_CAPT);
+	snd_cmipci_write(cm, CM_REG_FUNCTRL0, 0);	/* disable channels */
+	snd_cmipci_write(cm, CM_REG_FUNCTRL1, 0);
+
+	snd_cmipci_write(cm, CM_REG_CHFORMAT, 0);
+	snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_ENDBDAC|CM_N4SPK3D);
+#if CM_CH_PLAY == 1
+	snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);
+#else
+	snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);
+#endif
+	/* Set Bus Master Request */
+	snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_BREQ);
+
+	/* Assume TX and compatible chip set (Autodetection required for VX chip sets) */
+	switch (pci->device) {
+	case PCI_DEVICE_ID_CMEDIA_CM8738:
+	case PCI_DEVICE_ID_CMEDIA_CM8738B:
+		if (!pci_dev_present(intel_82437vx)) 
+			snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_TXVX);
+		break;
+	default:
+		break;
+	}
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, cm, &ops)) < 0) {
+		snd_cmipci_free(cm);
+		return err;
+	}
+
+	/* set MPU address */
+	switch (iomidi) {
+	case 0x320: val = CM_VMPU_320; break;
+	case 0x310: val = CM_VMPU_310; break;
+	case 0x300: val = CM_VMPU_300; break;
+	case 0x330: val = CM_VMPU_330; break;
+	default:
+		iomidi = 0; break;
+	}
+	if (iomidi > 0) {
+		snd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val);
+		/* enable UART */
+		snd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_UART_EN);
+	}
+
+	/* set FM address */
+	val = snd_cmipci_read(cm, CM_REG_LEGACY_CTRL) & ~CM_FMSEL_MASK;
+	switch (iosynth) {
+	case 0x3E8: val |= CM_FMSEL_3E8; break;
+	case 0x3E0: val |= CM_FMSEL_3E0; break;
+	case 0x3C8: val |= CM_FMSEL_3C8; break;
+	case 0x388: val |= CM_FMSEL_388; break;
+	default:
+		iosynth = 0; break;
+	}
+	if (iosynth > 0) {
+		snd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val);
+		/* enable FM */
+		snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);
+
+		if (snd_opl3_create(card, iosynth, iosynth + 2,
+				    OPL3_HW_OPL3, 0, &cm->opl3) < 0) {
+			printk(KERN_ERR "cmipci: no OPL device at 0x%lx, skipping...\n", iosynth);
+			iosynth = 0;
+		} else {
+			if ((err = snd_opl3_hwdep_new(cm->opl3, 0, 1, &cm->opl3hwdep)) < 0) {
+				printk(KERN_ERR "cmipci: cannot create OPL3 hwdep\n");
+				return err;
+			}
+		}
+	}
+	if (! iosynth) {
+		/* disable FM */
+		snd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val & ~CM_FMSEL_MASK);
+		snd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);
+	}
+
+	/* reset mixer */
+	snd_cmipci_mixer_write(cm, 0, 0);
+
+	snd_cmipci_proc_init(cm);
+
+	/* create pcm devices */
+	pcm_index = pcm_spdif_index = 0;
+	if ((err = snd_cmipci_pcm_new(cm, pcm_index)) < 0)
+		return err;
+	pcm_index++;
+	if (cm->has_dual_dac) {
+		if ((err = snd_cmipci_pcm2_new(cm, pcm_index)) < 0)
+			return err;
+		pcm_index++;
+	}
+	if (cm->can_ac3_hw || cm->can_ac3_sw) {
+		pcm_spdif_index = pcm_index;
+		if ((err = snd_cmipci_pcm_spdif_new(cm, pcm_index)) < 0)
+			return err;
+	}
+
+	/* create mixer interface & switches */
+	if ((err = snd_cmipci_mixer_new(cm, pcm_spdif_index)) < 0)
+		return err;
+
+	if (iomidi > 0) {
+		if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_CMIPCI,
+					       iomidi, 0,
+					       cm->irq, 0, &cm->rmidi)) < 0) {
+			printk(KERN_ERR "cmipci: no UART401 device at 0x%lx\n", iomidi);
+		}
+	}
+
+#ifdef USE_VAR48KRATE
+	for (val = 0; val < ARRAY_SIZE(rates); val++)
+		snd_cmipci_set_pll(cm, rates[val], val);
+
+	/*
+	 * (Re-)Enable external switch spdo_48k
+	 */
+	snd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPDIF48K|CM_SPDF_AC97);
+#endif /* USE_VAR48KRATE */
+
+	if (snd_cmipci_create_gameport(cm, dev) < 0)
+		snd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_JYSTK_EN);
+
+	snd_card_set_dev(card, &pci->dev);
+
+	*rcmipci = cm;
+	return 0;
+}
+
+/*
+ */
+
+MODULE_DEVICE_TABLE(pci, snd_cmipci_ids);
+
+static int __devinit snd_cmipci_probe(struct pci_dev *pci,
+				      const struct pci_device_id *pci_id)
+{
+	static int dev;
+	snd_card_t *card;
+	cmipci_t *cm;
+	int err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (! enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+	
+	switch (pci->device) {
+	case PCI_DEVICE_ID_CMEDIA_CM8738:
+	case PCI_DEVICE_ID_CMEDIA_CM8738B:
+		strcpy(card->driver, "CMI8738");
+		break;
+	case PCI_DEVICE_ID_CMEDIA_CM8338A:
+	case PCI_DEVICE_ID_CMEDIA_CM8338B:
+		strcpy(card->driver, "CMI8338");
+		break;
+	default:
+		strcpy(card->driver, "CMIPCI");
+		break;
+	}
+
+	if ((err = snd_cmipci_create(card, pci, dev, &cm)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	sprintf(card->shortname, "C-Media PCI %s", card->driver);
+	sprintf(card->longname, "%s (model %d) at 0x%lx, irq %i",
+		card->shortname,
+		cm->chip_version,
+		cm->iobase,
+		cm->irq);
+
+	//snd_printd("%s is detected\n", card->longname);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+
+}
+
+static void __devexit snd_cmipci_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+
+static struct pci_driver driver = {
+	.name = "C-Media PCI",
+	.id_table = snd_cmipci_ids,
+	.probe = snd_cmipci_probe,
+	.remove = __devexit_p(snd_cmipci_remove),
+};
+	
+static int __init alsa_card_cmipci_init(void)
+{
+	return pci_module_init(&driver);
+}
+
+static void __exit alsa_card_cmipci_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_cmipci_init)
+module_exit(alsa_card_cmipci_exit)
