commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index 2e80b17a7104..bde28aa9e139 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -183,7 +183,7 @@ int ct_vm_create(struct ct_vm **rvm, struct pci_dev *pci)
 	/* Allocate page table pages */
 	for (i = 0; i < CT_PTP_NUM; i++) {
 		err = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
-					  snd_dma_pci_data(pci),
+					  &pci->dev,
 					  PAGE_SIZE, &vm->ptp[i]);
 		if (err < 0)
 			break;

commit 5765e78e84023ced0c719aaea2ef59b9b34f626a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 31 01:09:25 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 364
    
    Based on 1 normalized pattern(s):
    
      this source file is released under gpl v2 license no other versions
      see the copying file included in the main directory of this source
      distribution for the license terms and conditions
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 28 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531081035.780831265@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index 520e19bc649f..2e80b17a7104 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -1,10 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /**
  * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
  *
- * This source file is released under GPL v2 license (no other versions).
- * See the COPYING file included in the main directory of this source
- * distribution for the license terms and conditions.
- *
  * @File    ctvmem.c
  *
  * @Brief

commit 44cc4a017e2df87f25765ac270f3f64efc6b06ef
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Sep 6 20:41:19 2016 +0900

    ALSA: squash lines for simple wrapper functions
    
    Remove unneeded variables and assignments.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index 419306ef825f..520e19bc649f 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -166,11 +166,7 @@ static void ct_vm_unmap(struct ct_vm *vm, struct ct_vm_block *block)
 static dma_addr_t
 ct_get_ptp_phys(struct ct_vm *vm, int index)
 {
-	dma_addr_t addr;
-
-	addr = (index >= CT_PTP_NUM) ? ~0UL : vm->ptp[index].addr;
-
-	return addr;
+	return (index >= CT_PTP_NUM) ? ~0UL : vm->ptp[index].addr;
 }
 
 int ct_vm_create(struct ct_vm **rvm, struct pci_dev *pci)

commit 0cae90a96c15f2fd3bd139ba5505755c9c9ef2eb
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Mon Sep 29 14:33:26 2014 +0530

    ALSA: ctxfi: pr_* replaced with dev_*
    
    pr_* macros replaced with dev_* as they are more preffered over pr_*.
    each file which had pr_* was reviewed manually and replaced with dev_*.
    here we have actually used the various snd_card which was added to some
    structures of ctxfi via a previous patch of this series.
    
    in the ctvmem.c file we have passed a reference of ct_atc as an
    argument to get_vm_block function so that it can be used from
    dev_*.
    
    since dev_* will print the device information , so the prefix of
    "ctxfi" from the various pr_* were also removed.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index 38163f52dd5f..419306ef825f 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -16,6 +16,7 @@
  */
 
 #include "ctvmem.h"
+#include "ctatc.h"
 #include <linux/slab.h>
 #include <linux/mm.h>
 #include <linux/io.h>
@@ -29,14 +30,15 @@
  * @size must be page aligned.
  * */
 static struct ct_vm_block *
-get_vm_block(struct ct_vm *vm, unsigned int size)
+get_vm_block(struct ct_vm *vm, unsigned int size, struct ct_atc *atc)
 {
 	struct ct_vm_block *block = NULL, *entry;
 	struct list_head *pos;
 
 	size = CT_PAGE_ALIGN(size);
 	if (size > vm->size) {
-		pr_err("ctxfi: Fail! No sufficient device virtual memory space available!\n");
+		dev_err(atc->card->dev,
+			"Fail! No sufficient device virtual memory space available!\n");
 		return NULL;
 	}
 
@@ -128,10 +130,12 @@ ct_vm_map(struct ct_vm *vm, struct snd_pcm_substream *substream, int size)
 	unsigned int pte_start;
 	unsigned i, pages;
 	unsigned long *ptp;
+	struct ct_atc *atc = snd_pcm_substream_chip(substream);
 
-	block = get_vm_block(vm, size);
+	block = get_vm_block(vm, size, atc);
 	if (block == NULL) {
-		pr_err("ctxfi: No virtual memory block that is big enough to allocate!\n");
+		dev_err(atc->card->dev,
+			"No virtual memory block that is big enough to allocate!\n");
 		return NULL;
 	}
 

commit 62afa853cb91288e85a8da6351bd29d798402308
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Tue Aug 26 19:01:43 2014 +0530

    ALSA: ctxfi: fix broken user-visible string
    
    as broken user-visible strings breaks the ability to grep for them , so this patch fixes the broken user-visible strings
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index 5ea015bec793..38163f52dd5f 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -36,8 +36,7 @@ get_vm_block(struct ct_vm *vm, unsigned int size)
 
 	size = CT_PAGE_ALIGN(size);
 	if (size > vm->size) {
-		pr_err("ctxfi: Fail! No sufficient device virtual "
-				  "memory space available!\n");
+		pr_err("ctxfi: Fail! No sufficient device virtual memory space available!\n");
 		return NULL;
 	}
 
@@ -132,8 +131,7 @@ ct_vm_map(struct ct_vm *vm, struct snd_pcm_substream *substream, int size)
 
 	block = get_vm_block(vm, size);
 	if (block == NULL) {
-		pr_err("ctxfi: No virtual memory block that is big "
-				  "enough to allocate!\n");
+		pr_err("ctxfi: No virtual memory block that is big enough to allocate!\n");
 		return NULL;
 	}
 

commit e720b82027b99482ea5d1001a69bdf2200e86b79
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Tue Aug 26 19:01:42 2014 +0530

    ALSA: ctxfi: prink replacement
    
    as pr_* macros are more preffered over printk, so printk replaced with corresponding pr_err and pr_alert
    this patch will generate a warning from checkpatch for an unnecessary space before new line and has not been fixed as this patch is only for printk replacement.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index 6109490b83e8..5ea015bec793 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -36,7 +36,7 @@ get_vm_block(struct ct_vm *vm, unsigned int size)
 
 	size = CT_PAGE_ALIGN(size);
 	if (size > vm->size) {
-		printk(KERN_ERR "ctxfi: Fail! No sufficient device virtual "
+		pr_err("ctxfi: Fail! No sufficient device virtual "
 				  "memory space available!\n");
 		return NULL;
 	}
@@ -132,7 +132,7 @@ ct_vm_map(struct ct_vm *vm, struct snd_pcm_substream *substream, int size)
 
 	block = get_vm_block(vm, size);
 	if (block == NULL) {
-		printk(KERN_ERR "ctxfi: No virtual memory block that is big "
+		pr_err("ctxfi: No virtual memory block that is big "
 				  "enough to allocate!\n");
 		return NULL;
 	}

commit 8a236f3f1a0e65de526c5e169eb8d7a758ffde9e
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Thu Feb 23 23:23:06 2012 +0900

    ALSA: ctxfi: Fix typo in ctvmem.c
    
    Correct spelling "virtural" to "virtual" in
    sound/pci/ctxfi/ctvmem.c
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index b78f3fc3c33c..6109490b83e8 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -36,7 +36,7 @@ get_vm_block(struct ct_vm *vm, unsigned int size)
 
 	size = CT_PAGE_ALIGN(size);
 	if (size > vm->size) {
-		printk(KERN_ERR "ctxfi: Fail! No sufficient device virtural "
+		printk(KERN_ERR "ctxfi: Fail! No sufficient device virtual "
 				  "memory space available!\n");
 		return NULL;
 	}

commit 9d4ed9e0771767a110dafffdeb0963e852fd6ae4
Author: Kirill A. Shutemov <kirill@shutemov.name>
Date:   Wed Mar 16 00:53:24 2011 +0200

    ALSA: ctxfi - use list_move() instead of list_del()/list_add() combination
    
    Signed-off-by: Kirill A. Shutemov <kirill@shutemov.name>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index 65da6e466f80..b78f3fc3c33c 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -52,8 +52,7 @@ get_vm_block(struct ct_vm *vm, unsigned int size)
 
 	if (entry->size == size) {
 		/* Move the vm node from unused list to used list directly */
-		list_del(&entry->list);
-		list_add(&entry->list, &vm->used);
+		list_move(&entry->list, &vm->used);
 		vm->size -= size;
 		block = entry;
 		goto out;

commit 21956b61f594f7924d98240da74bc81c28601fa9
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Tue Feb 2 19:58:25 2010 +0100

    ALSA: ctxfi - fix PTP address initialization
    
    After hours of debugging, I finally found the reason why some source
    and runtime combination does not work. The PTP (page table pages)
    address must be aligned. I am not sure how much, but alignment to
    PAGE_SIZE is sufficient. Also, use ALSA's page allocation routines
    to ensure proper virtual -> physical address translation.
    
    Cc: <stable@kernel.org>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index 6b78752e9503..65da6e466f80 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -138,7 +138,7 @@ ct_vm_map(struct ct_vm *vm, struct snd_pcm_substream *substream, int size)
 		return NULL;
 	}
 
-	ptp = vm->ptp[0];
+	ptp = (unsigned long *)vm->ptp[0].area;
 	pte_start = (block->addr >> CT_PAGE_SHIFT);
 	pages = block->size >> CT_PAGE_SHIFT;
 	for (i = 0; i < pages; i++) {
@@ -158,25 +158,25 @@ static void ct_vm_unmap(struct ct_vm *vm, struct ct_vm_block *block)
 }
 
 /* *
- * return the host (kmalloced) addr of the @index-th device
- * page talbe page on success, or NULL on failure.
- * The first returned NULL indicates the termination.
+ * return the host physical addr of the @index-th device
+ * page table page on success, or ~0UL on failure.
+ * The first returned ~0UL indicates the termination.
  * */
-static void *
-ct_get_ptp_virt(struct ct_vm *vm, int index)
+static dma_addr_t
+ct_get_ptp_phys(struct ct_vm *vm, int index)
 {
-	void *addr;
+	dma_addr_t addr;
 
-	addr = (index >= CT_PTP_NUM) ? NULL : vm->ptp[index];
+	addr = (index >= CT_PTP_NUM) ? ~0UL : vm->ptp[index].addr;
 
 	return addr;
 }
 
-int ct_vm_create(struct ct_vm **rvm)
+int ct_vm_create(struct ct_vm **rvm, struct pci_dev *pci)
 {
 	struct ct_vm *vm;
 	struct ct_vm_block *block;
-	int i;
+	int i, err = 0;
 
 	*rvm = NULL;
 
@@ -188,23 +188,21 @@ int ct_vm_create(struct ct_vm **rvm)
 
 	/* Allocate page table pages */
 	for (i = 0; i < CT_PTP_NUM; i++) {
-		vm->ptp[i] = kmalloc(PAGE_SIZE, GFP_KERNEL);
-		if (!vm->ptp[i])
+		err = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
+					  snd_dma_pci_data(pci),
+					  PAGE_SIZE, &vm->ptp[i]);
+		if (err < 0)
 			break;
 	}
-	if (!i) {
+	if (err < 0) {
 		/* no page table pages are allocated */
-		kfree(vm);
+		ct_vm_destroy(vm);
 		return -ENOMEM;
 	}
 	vm->size = CT_ADDRS_PER_PAGE * i;
-	/* Initialise remaining ptps */
-	for (; i < CT_PTP_NUM; i++)
-		vm->ptp[i] = NULL;
-
 	vm->map = ct_vm_map;
 	vm->unmap = ct_vm_unmap;
-	vm->get_ptp_virt = ct_get_ptp_virt;
+	vm->get_ptp_phys = ct_get_ptp_phys;
 	INIT_LIST_HEAD(&vm->unused);
 	INIT_LIST_HEAD(&vm->used);
 	block = kzalloc(sizeof(*block), GFP_KERNEL);
@@ -242,7 +240,7 @@ void ct_vm_destroy(struct ct_vm *vm)
 
 	/* free allocated page table pages */
 	for (i = 0; i < CT_PTP_NUM; i++)
-		kfree(vm->ptp[i]);
+		snd_dma_free_pages(&vm->ptp[i]);
 
 	vm->size = 0;
 

commit 35ebf6e7210dc0f7c612856513a8489a1da9de7e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 22 17:12:34 2009 +0200

    ALSA: ctxfi - Simple code clean up
    
    - replace NULL == xxx with !xxx
    - replace NULL != xxx with xxx
    - similar trivial cleanups
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index 67665a7e43c6..6b78752e9503 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -60,7 +60,7 @@ get_vm_block(struct ct_vm *vm, unsigned int size)
 	}
 
 	block = kzalloc(sizeof(*block), GFP_KERNEL);
-	if (NULL == block)
+	if (!block)
 		goto out;
 
 	block->addr = entry->addr;
@@ -181,7 +181,7 @@ int ct_vm_create(struct ct_vm **rvm)
 	*rvm = NULL;
 
 	vm = kzalloc(sizeof(*vm), GFP_KERNEL);
-	if (NULL == vm)
+	if (!vm)
 		return -ENOMEM;
 
 	mutex_init(&vm->lock);
@@ -189,7 +189,7 @@ int ct_vm_create(struct ct_vm **rvm)
 	/* Allocate page table pages */
 	for (i = 0; i < CT_PTP_NUM; i++) {
 		vm->ptp[i] = kmalloc(PAGE_SIZE, GFP_KERNEL);
-		if (NULL == vm->ptp[i])
+		if (!vm->ptp[i])
 			break;
 	}
 	if (!i) {

commit 514eef9c2a711b4c24b97bb456d39695a6fe1775
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jun 8 14:57:57 2009 +0200

    ALSA: ctxfi - Remove useless initializations and cast
    
    Remove useless variable initializations and cast at the beginning of
    functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index b7f8e58ae07d..67665a7e43c6 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -31,8 +31,8 @@
 static struct ct_vm_block *
 get_vm_block(struct ct_vm *vm, unsigned int size)
 {
-	struct ct_vm_block *block = NULL, *entry = NULL;
-	struct list_head *pos = NULL;
+	struct ct_vm_block *block = NULL, *entry;
+	struct list_head *pos;
 
 	size = CT_PAGE_ALIGN(size);
 	if (size > vm->size) {
@@ -77,8 +77,8 @@ get_vm_block(struct ct_vm *vm, unsigned int size)
 
 static void put_vm_block(struct ct_vm *vm, struct ct_vm_block *block)
 {
-	struct ct_vm_block *entry = NULL, *pre_ent = NULL;
-	struct list_head *pos = NULL, *pre = NULL;
+	struct ct_vm_block *entry, *pre_ent;
+	struct list_head *pos, *pre;
 
 	block->size = CT_PAGE_ALIGN(block->size);
 
@@ -223,8 +223,8 @@ int ct_vm_create(struct ct_vm **rvm)
 void ct_vm_destroy(struct ct_vm *vm)
 {
 	int i;
-	struct list_head *pos = NULL;
-	struct ct_vm_block *entry = NULL;
+	struct list_head *pos;
+	struct ct_vm_block *entry;
 
 	/* free used and unused list nodes */
 	while (!list_empty(&vm->used)) {

commit c76157d9286ed598c241c212aa5a3c6e5107bd82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 2 15:26:19 2009 +0200

    ALSA: ctxfi - Support SG-buffers
    
    Use SG-buffers instead of contiguous pages.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index 74a03623d047..b7f8e58ae07d 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -19,7 +19,7 @@
 #include <linux/slab.h>
 #include <linux/mm.h>
 #include <linux/io.h>
-#include <asm/pgtable.h>
+#include <sound/pcm.h>
 
 #define CT_PTES_PER_PAGE (CT_PAGE_SIZE / sizeof(void *))
 #define CT_ADDRS_PER_PAGE (CT_PTES_PER_PAGE * CT_PAGE_SIZE)
@@ -34,6 +34,13 @@ get_vm_block(struct ct_vm *vm, unsigned int size)
 	struct ct_vm_block *block = NULL, *entry = NULL;
 	struct list_head *pos = NULL;
 
+	size = CT_PAGE_ALIGN(size);
+	if (size > vm->size) {
+		printk(KERN_ERR "ctxfi: Fail! No sufficient device virtural "
+				  "memory space available!\n");
+		return NULL;
+	}
+
 	mutex_lock(&vm->lock);
 	list_for_each(pos, &vm->unused) {
 		entry = list_entry(pos, struct ct_vm_block, list);
@@ -73,6 +80,8 @@ static void put_vm_block(struct ct_vm *vm, struct ct_vm_block *block)
 	struct ct_vm_block *entry = NULL, *pre_ent = NULL;
 	struct list_head *pos = NULL, *pre = NULL;
 
+	block->size = CT_PAGE_ALIGN(block->size);
+
 	mutex_lock(&vm->lock);
 	list_del(&block->list);
 	vm->size += block->size;
@@ -115,57 +124,36 @@ static void put_vm_block(struct ct_vm *vm, struct ct_vm_block *block)
 
 /* Map host addr (kmalloced/vmalloced) to device logical addr. */
 static struct ct_vm_block *
-ct_vm_map(struct ct_vm *vm, void *host_addr, int size)
+ct_vm_map(struct ct_vm *vm, struct snd_pcm_substream *substream, int size)
 {
-	struct ct_vm_block *block = NULL;
-	unsigned long pte_start;
-	unsigned long i;
-	unsigned long pages;
-	unsigned long start_phys;
+	struct ct_vm_block *block;
+	unsigned int pte_start;
+	unsigned i, pages;
 	unsigned long *ptp;
 
-	/* do mapping */
-	if ((unsigned long)host_addr >= VMALLOC_START) {
-		printk(KERN_ERR "ctxfi: "
-		       "Fail! Not support vmalloced addr now!\n");
-		return NULL;
-	}
-
-	if (size > vm->size) {
-		printk(KERN_ERR "ctxfi: Fail! No sufficient device virtural "
-				  "memory space available!\n");
-		return NULL;
-	}
-
-	start_phys = (virt_to_phys(host_addr) & CT_PAGE_MASK);
-	pages = (CT_PAGE_ALIGN(virt_to_phys(host_addr) + size)
-			- start_phys) >> CT_PAGE_SHIFT;
-
-	ptp = vm->ptp[0];
-
-	block = get_vm_block(vm, (pages << CT_PAGE_SHIFT));
+	block = get_vm_block(vm, size);
 	if (block == NULL) {
 		printk(KERN_ERR "ctxfi: No virtual memory block that is big "
 				  "enough to allocate!\n");
 		return NULL;
 	}
 
+	ptp = vm->ptp[0];
 	pte_start = (block->addr >> CT_PAGE_SHIFT);
-	for (i = 0; i < pages; i++)
-		ptp[pte_start+i] = start_phys + (i << CT_PAGE_SHIFT);
+	pages = block->size >> CT_PAGE_SHIFT;
+	for (i = 0; i < pages; i++) {
+		unsigned long addr;
+		addr = snd_pcm_sgbuf_get_addr(substream, i << CT_PAGE_SHIFT);
+		ptp[pte_start + i] = addr;
+	}
 
-	block->addr += (virt_to_phys(host_addr) & (~CT_PAGE_MASK));
 	block->size = size;
-
 	return block;
 }
 
 static void ct_vm_unmap(struct ct_vm *vm, struct ct_vm_block *block)
 {
 	/* do unmapping */
-	block->size = ((block->addr + block->size + CT_PAGE_SIZE - 1)
-			& CT_PAGE_MASK) - (block->addr & CT_PAGE_MASK);
-	block->addr &= CT_PAGE_MASK;
 	put_vm_block(vm, block);
 }
 

commit cd391e206f486955e216a61bd9ebcb0e142122e9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 2 15:04:29 2009 +0200

    ALSA: ctxfi - Remove PAGE_SIZE limitation
    
    Remove the limitation of PAGE_SIZE to be 4k by defining the own
    page size and macros for 4k.  8kb page size could be natively supported,
    but it's disabled right now for simplicity.
    
    Also, clean up using upper_32_bits() macro.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index 363b67e3a9e7..74a03623d047 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -18,12 +18,11 @@
 #include "ctvmem.h"
 #include <linux/slab.h>
 #include <linux/mm.h>
-#include <asm/page.h>	/* for PAGE_SIZE macro definition */
 #include <linux/io.h>
 #include <asm/pgtable.h>
 
-#define CT_PTES_PER_PAGE (PAGE_SIZE / sizeof(void *))
-#define CT_ADDRS_PER_PAGE (CT_PTES_PER_PAGE * PAGE_SIZE)
+#define CT_PTES_PER_PAGE (CT_PAGE_SIZE / sizeof(void *))
+#define CT_ADDRS_PER_PAGE (CT_PTES_PER_PAGE * CT_PAGE_SIZE)
 
 /* *
  * Find or create vm block based on requested @size.
@@ -138,24 +137,24 @@ ct_vm_map(struct ct_vm *vm, void *host_addr, int size)
 		return NULL;
 	}
 
-	start_phys = (virt_to_phys(host_addr) & PAGE_MASK);
-	pages = (PAGE_ALIGN(virt_to_phys(host_addr) + size)
-			- start_phys) >> PAGE_SHIFT;
+	start_phys = (virt_to_phys(host_addr) & CT_PAGE_MASK);
+	pages = (CT_PAGE_ALIGN(virt_to_phys(host_addr) + size)
+			- start_phys) >> CT_PAGE_SHIFT;
 
 	ptp = vm->ptp[0];
 
-	block = get_vm_block(vm, (pages << PAGE_SHIFT));
+	block = get_vm_block(vm, (pages << CT_PAGE_SHIFT));
 	if (block == NULL) {
 		printk(KERN_ERR "ctxfi: No virtual memory block that is big "
 				  "enough to allocate!\n");
 		return NULL;
 	}
 
-	pte_start = (block->addr >> PAGE_SHIFT);
+	pte_start = (block->addr >> CT_PAGE_SHIFT);
 	for (i = 0; i < pages; i++)
-		ptp[pte_start+i] = start_phys + (i << PAGE_SHIFT);
+		ptp[pte_start+i] = start_phys + (i << CT_PAGE_SHIFT);
 
-	block->addr += (virt_to_phys(host_addr) & (~PAGE_MASK));
+	block->addr += (virt_to_phys(host_addr) & (~CT_PAGE_MASK));
 	block->size = size;
 
 	return block;
@@ -164,9 +163,9 @@ ct_vm_map(struct ct_vm *vm, void *host_addr, int size)
 static void ct_vm_unmap(struct ct_vm *vm, struct ct_vm_block *block)
 {
 	/* do unmapping */
-	block->size = ((block->addr + block->size + PAGE_SIZE - 1)
-			& PAGE_MASK) - (block->addr & PAGE_MASK);
-	block->addr &= PAGE_MASK;
+	block->size = ((block->addr + block->size + CT_PAGE_SIZE - 1)
+			& CT_PAGE_MASK) - (block->addr & CT_PAGE_MASK);
+	block->addr &= CT_PAGE_MASK;
 	put_vm_block(vm, block);
 }
 

commit 8a4259bf89d23bfd58d87e275ef6da29cea6b3c5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 2 08:40:51 2009 +0200

    ALSA: ctxfi - Fix Oops at mmapping
    
    Replace a spinlock with a mutex protecting the vm block list at
    mmap / munmap calls, which caused Oops like below:
    
    BUG: sleeping function called from invalid context at mm/slub.c:1599
    in_atomic(): 0, irqs_disabled(): 1, pid: 32065, name: xine
    Pid: 32065, comm: xine Tainted: P           2.6.29.4-75.fc10.x86_64 #1
    Call Trace:
      [<ffffffff81040685>] __might_sleep+0x105/0x10a
      [<ffffffff810c9fae>] kmem_cache_alloc+0x32/0xe2
      [<ffffffffa08e3110>] ct_vm_map+0xfa/0x19e [snd_ctxfi]
      [<ffffffffa08e1a07>] ct_map_audio_buffer+0x4c/0x76 [snd_ctxfi]
      [<ffffffffa08e2aa5>] atc_pcm_playback_prepare+0x1d7/0x2a8 [snd_ctxfi]
      [<ffffffff8105ef3f>] ? up_read+0x9/0xb
      [<ffffffff81186b61>] ? __up_read+0x7c/0x87
      [<ffffffffa08e36a6>] ct_pcm_playback_prepare+0x39/0x60 [snd_ctxfi]
      [<ffffffffa0886bcb>] snd_pcm_do_prepare+0x16/0x28 [snd_pcm]
      [<ffffffffa08867c7>] snd_pcm_action_single+0x2d/0x5b [snd_pcm]
      [<ffffffffa08881f3>] snd_pcm_action_nonatomic+0x52/0x6a [snd_pcm]
      [<ffffffffa088a723>] snd_pcm_common_ioctl1+0x404/0xc79 [snd_pcm]
      [<ffffffff810c52c8>] ? alloc_pages_current+0xb9/0xc2
      [<ffffffff810c9402>] ? new_slab+0x1a5/0x1cb
      [<ffffffff810ab9ea>] ? vma_prio_tree_insert+0x23/0xc1
      [<ffffffffa088b411>] snd_pcm_playback_ioctl1+0x213/0x230 [snd_pcm]
      [<ffffffff810b6c20>] ? mmap_region+0x397/0x4c9
      [<ffffffffa088bd9b>] snd_pcm_playback_ioctl+0x2e/0x36 [snd_pcm]
      [<ffffffff810ddc64>] vfs_ioctl+0x2a/0x78
      [<ffffffff810de130>] do_vfs_ioctl+0x462/0x4a2
      [<ffffffff81029cef>] ? default_spin_lock_flags+0x9/0xe
      [<ffffffff81374647>] ? trace_hardirqs_off_thunk+0x3a/0x6c
      [<ffffffff810de1c5>] sys_ioctl+0x55/0x77
      [<ffffffff8101133a>] system_call_fastpath+0x16/0x1b
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index cecf77e3ee86..363b67e3a9e7 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -35,25 +35,27 @@ get_vm_block(struct ct_vm *vm, unsigned int size)
 	struct ct_vm_block *block = NULL, *entry = NULL;
 	struct list_head *pos = NULL;
 
+	mutex_lock(&vm->lock);
 	list_for_each(pos, &vm->unused) {
 		entry = list_entry(pos, struct ct_vm_block, list);
 		if (entry->size >= size)
 			break; /* found a block that is big enough */
 	}
 	if (pos == &vm->unused)
-		return NULL;
+		goto out;
 
 	if (entry->size == size) {
 		/* Move the vm node from unused list to used list directly */
 		list_del(&entry->list);
 		list_add(&entry->list, &vm->used);
 		vm->size -= size;
-		return entry;
+		block = entry;
+		goto out;
 	}
 
 	block = kzalloc(sizeof(*block), GFP_KERNEL);
 	if (NULL == block)
-		return NULL;
+		goto out;
 
 	block->addr = entry->addr;
 	block->size = size;
@@ -62,6 +64,8 @@ get_vm_block(struct ct_vm *vm, unsigned int size)
 	entry->size -= size;
 	vm->size -= size;
 
+ out:
+	mutex_unlock(&vm->lock);
 	return block;
 }
 
@@ -70,6 +74,7 @@ static void put_vm_block(struct ct_vm *vm, struct ct_vm_block *block)
 	struct ct_vm_block *entry = NULL, *pre_ent = NULL;
 	struct list_head *pos = NULL, *pre = NULL;
 
+	mutex_lock(&vm->lock);
 	list_del(&block->list);
 	vm->size += block->size;
 
@@ -106,6 +111,7 @@ static void put_vm_block(struct ct_vm *vm, struct ct_vm_block *block)
 		pos = pre;
 		pre = pos->prev;
 	}
+	mutex_unlock(&vm->lock);
 }
 
 /* Map host addr (kmalloced/vmalloced) to device logical addr. */
@@ -191,6 +197,8 @@ int ct_vm_create(struct ct_vm **rvm)
 	if (NULL == vm)
 		return -ENOMEM;
 
+	mutex_init(&vm->lock);
+
 	/* Allocate page table pages */
 	for (i = 0; i < CT_PTP_NUM; i++) {
 		vm->ptp[i] = kmalloc(PAGE_SIZE, GFP_KERNEL);

commit b3e0afe61e8271a8d082478752a67e5c279c8f23
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu May 14 15:19:30 2009 +0200

    ALSA: ctxfi - Add prefix to debug prints
    
    Added ctxfi: prefix to each debug print.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
index 46ca04ce9210..cecf77e3ee86 100644
--- a/sound/pci/ctxfi/ctvmem.c
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -121,12 +121,13 @@ ct_vm_map(struct ct_vm *vm, void *host_addr, int size)
 
 	/* do mapping */
 	if ((unsigned long)host_addr >= VMALLOC_START) {
-		printk(KERN_ERR "Fail! Not support vmalloced addr now!\n");
+		printk(KERN_ERR "ctxfi: "
+		       "Fail! Not support vmalloced addr now!\n");
 		return NULL;
 	}
 
 	if (size > vm->size) {
-		printk(KERN_ERR "Fail! No sufficient device virtural "
+		printk(KERN_ERR "ctxfi: Fail! No sufficient device virtural "
 				  "memory space available!\n");
 		return NULL;
 	}
@@ -139,7 +140,7 @@ ct_vm_map(struct ct_vm *vm, void *host_addr, int size)
 
 	block = get_vm_block(vm, (pages << PAGE_SHIFT));
 	if (block == NULL) {
-		printk(KERN_ERR "No virtual memory block that is big "
+		printk(KERN_ERR "ctxfi: No virtual memory block that is big "
 				  "enough to allocate!\n");
 		return NULL;
 	}

commit 8cc72361481f00253f1e468ade5795427386d593
Author: Wai Yew CHAY <wychay@ctl.creative.com>
Date:   Thu May 14 08:05:58 2009 +0200

    ALSA: SB X-Fi driver merge
    
    The Sound Blaster X-Fi driver supports Creative solutions based on
    20K1 and 20K2 chipsets.
    
    Supported hardware :
    
    Creative Sound Blaster X-Fi Titanium Fatal1tyÂ® Champion Series
    Creative Sound Blaster X-Fi Titanium Fatal1ty Professional Series
    Creative Sound Blaster X-Fi Titanium Professional Audio
    Creative Sound Blaster X-Fi Titanium
    Creative Sound Blaster X-Fi Elite Pro
    Creative Sound Blaster X-Fi Platinum
    Creative Sound Blaster X-Fi Fatal1ty
    Creative Sound Blaster X-Fi XtremeGamer
    Creative Sound Blaster X-Fi XtremeMusic
    
    Current release features:
    
    * ALSA PCM Playback
    * ALSA Record
    * ALSA Mixer
    
    Note:
    
    * External I/O modules detection not included.
    
    Signed-off-by: Wai Yew CHAY <wychay@ctl.creative.com>
    Singed-off-by: Ryan RICHARDS <ryan_richards@creativelabs.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ctxfi/ctvmem.c b/sound/pci/ctxfi/ctvmem.c
new file mode 100644
index 000000000000..46ca04ce9210
--- /dev/null
+++ b/sound/pci/ctxfi/ctvmem.c
@@ -0,0 +1,254 @@
+/**
+ * Copyright (C) 2008, Creative Technology Ltd. All Rights Reserved.
+ *
+ * This source file is released under GPL v2 license (no other versions).
+ * See the COPYING file included in the main directory of this source
+ * distribution for the license terms and conditions.
+ *
+ * @File    ctvmem.c
+ *
+ * @Brief
+ * This file contains the implementation of virtual memory management object
+ * for card device.
+ *
+ * @Author Liu Chun
+ * @Date Apr 1 2008
+ */
+
+#include "ctvmem.h"
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <asm/page.h>	/* for PAGE_SIZE macro definition */
+#include <linux/io.h>
+#include <asm/pgtable.h>
+
+#define CT_PTES_PER_PAGE (PAGE_SIZE / sizeof(void *))
+#define CT_ADDRS_PER_PAGE (CT_PTES_PER_PAGE * PAGE_SIZE)
+
+/* *
+ * Find or create vm block based on requested @size.
+ * @size must be page aligned.
+ * */
+static struct ct_vm_block *
+get_vm_block(struct ct_vm *vm, unsigned int size)
+{
+	struct ct_vm_block *block = NULL, *entry = NULL;
+	struct list_head *pos = NULL;
+
+	list_for_each(pos, &vm->unused) {
+		entry = list_entry(pos, struct ct_vm_block, list);
+		if (entry->size >= size)
+			break; /* found a block that is big enough */
+	}
+	if (pos == &vm->unused)
+		return NULL;
+
+	if (entry->size == size) {
+		/* Move the vm node from unused list to used list directly */
+		list_del(&entry->list);
+		list_add(&entry->list, &vm->used);
+		vm->size -= size;
+		return entry;
+	}
+
+	block = kzalloc(sizeof(*block), GFP_KERNEL);
+	if (NULL == block)
+		return NULL;
+
+	block->addr = entry->addr;
+	block->size = size;
+	list_add(&block->list, &vm->used);
+	entry->addr += size;
+	entry->size -= size;
+	vm->size -= size;
+
+	return block;
+}
+
+static void put_vm_block(struct ct_vm *vm, struct ct_vm_block *block)
+{
+	struct ct_vm_block *entry = NULL, *pre_ent = NULL;
+	struct list_head *pos = NULL, *pre = NULL;
+
+	list_del(&block->list);
+	vm->size += block->size;
+
+	list_for_each(pos, &vm->unused) {
+		entry = list_entry(pos, struct ct_vm_block, list);
+		if (entry->addr >= (block->addr + block->size))
+			break; /* found a position */
+	}
+	if (pos == &vm->unused) {
+		list_add_tail(&block->list, &vm->unused);
+		entry = block;
+	} else {
+		if ((block->addr + block->size) == entry->addr) {
+			entry->addr = block->addr;
+			entry->size += block->size;
+			kfree(block);
+		} else {
+			__list_add(&block->list, pos->prev, pos);
+			entry = block;
+		}
+	}
+
+	pos = &entry->list;
+	pre = pos->prev;
+	while (pre != &vm->unused) {
+		entry = list_entry(pos, struct ct_vm_block, list);
+		pre_ent = list_entry(pre, struct ct_vm_block, list);
+		if ((pre_ent->addr + pre_ent->size) > entry->addr)
+			break;
+
+		pre_ent->size += entry->size;
+		list_del(pos);
+		kfree(entry);
+		pos = pre;
+		pre = pos->prev;
+	}
+}
+
+/* Map host addr (kmalloced/vmalloced) to device logical addr. */
+static struct ct_vm_block *
+ct_vm_map(struct ct_vm *vm, void *host_addr, int size)
+{
+	struct ct_vm_block *block = NULL;
+	unsigned long pte_start;
+	unsigned long i;
+	unsigned long pages;
+	unsigned long start_phys;
+	unsigned long *ptp;
+
+	/* do mapping */
+	if ((unsigned long)host_addr >= VMALLOC_START) {
+		printk(KERN_ERR "Fail! Not support vmalloced addr now!\n");
+		return NULL;
+	}
+
+	if (size > vm->size) {
+		printk(KERN_ERR "Fail! No sufficient device virtural "
+				  "memory space available!\n");
+		return NULL;
+	}
+
+	start_phys = (virt_to_phys(host_addr) & PAGE_MASK);
+	pages = (PAGE_ALIGN(virt_to_phys(host_addr) + size)
+			- start_phys) >> PAGE_SHIFT;
+
+	ptp = vm->ptp[0];
+
+	block = get_vm_block(vm, (pages << PAGE_SHIFT));
+	if (block == NULL) {
+		printk(KERN_ERR "No virtual memory block that is big "
+				  "enough to allocate!\n");
+		return NULL;
+	}
+
+	pte_start = (block->addr >> PAGE_SHIFT);
+	for (i = 0; i < pages; i++)
+		ptp[pte_start+i] = start_phys + (i << PAGE_SHIFT);
+
+	block->addr += (virt_to_phys(host_addr) & (~PAGE_MASK));
+	block->size = size;
+
+	return block;
+}
+
+static void ct_vm_unmap(struct ct_vm *vm, struct ct_vm_block *block)
+{
+	/* do unmapping */
+	block->size = ((block->addr + block->size + PAGE_SIZE - 1)
+			& PAGE_MASK) - (block->addr & PAGE_MASK);
+	block->addr &= PAGE_MASK;
+	put_vm_block(vm, block);
+}
+
+/* *
+ * return the host (kmalloced) addr of the @index-th device
+ * page talbe page on success, or NULL on failure.
+ * The first returned NULL indicates the termination.
+ * */
+static void *
+ct_get_ptp_virt(struct ct_vm *vm, int index)
+{
+	void *addr;
+
+	addr = (index >= CT_PTP_NUM) ? NULL : vm->ptp[index];
+
+	return addr;
+}
+
+int ct_vm_create(struct ct_vm **rvm)
+{
+	struct ct_vm *vm;
+	struct ct_vm_block *block;
+	int i;
+
+	*rvm = NULL;
+
+	vm = kzalloc(sizeof(*vm), GFP_KERNEL);
+	if (NULL == vm)
+		return -ENOMEM;
+
+	/* Allocate page table pages */
+	for (i = 0; i < CT_PTP_NUM; i++) {
+		vm->ptp[i] = kmalloc(PAGE_SIZE, GFP_KERNEL);
+		if (NULL == vm->ptp[i])
+			break;
+	}
+	if (!i) {
+		/* no page table pages are allocated */
+		kfree(vm);
+		return -ENOMEM;
+	}
+	vm->size = CT_ADDRS_PER_PAGE * i;
+	/* Initialise remaining ptps */
+	for (; i < CT_PTP_NUM; i++)
+		vm->ptp[i] = NULL;
+
+	vm->map = ct_vm_map;
+	vm->unmap = ct_vm_unmap;
+	vm->get_ptp_virt = ct_get_ptp_virt;
+	INIT_LIST_HEAD(&vm->unused);
+	INIT_LIST_HEAD(&vm->used);
+	block = kzalloc(sizeof(*block), GFP_KERNEL);
+	if (NULL != block) {
+		block->addr = 0;
+		block->size = vm->size;
+		list_add(&block->list, &vm->unused);
+	}
+
+	*rvm = vm;
+	return 0;
+}
+
+/* The caller must ensure no mapping pages are being used
+ * by hardware before calling this function */
+void ct_vm_destroy(struct ct_vm *vm)
+{
+	int i;
+	struct list_head *pos = NULL;
+	struct ct_vm_block *entry = NULL;
+
+	/* free used and unused list nodes */
+	while (!list_empty(&vm->used)) {
+		pos = vm->used.next;
+		list_del(pos);
+		entry = list_entry(pos, struct ct_vm_block, list);
+		kfree(entry);
+	}
+	while (!list_empty(&vm->unused)) {
+		pos = vm->unused.next;
+		list_del(pos);
+		entry = list_entry(pos, struct ct_vm_block, list);
+		kfree(entry);
+	}
+
+	/* free allocated page table pages */
+	for (i = 0; i < CT_PTP_NUM; i++)
+		kfree(vm->ptp[i]);
+
+	vm->size = 0;
+
+	kfree(vm);
+}
