commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 0b2a23c6d277..4032b89b1fc1 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -366,7 +366,6 @@ static int snd_cs5535audio_capture_prepare(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_cs5535audio_playback_ops = {
 	.open =		snd_cs5535audio_playback_open,
 	.close =	snd_cs5535audio_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_cs5535audio_hw_params,
 	.hw_free =	snd_cs5535audio_hw_free,
 	.prepare =	snd_cs5535audio_playback_prepare,
@@ -377,7 +376,6 @@ static const struct snd_pcm_ops snd_cs5535audio_playback_ops = {
 static const struct snd_pcm_ops snd_cs5535audio_capture_ops = {
 	.open =		snd_cs5535audio_capture_open,
 	.close =	snd_cs5535audio_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_cs5535audio_hw_params,
 	.hw_free =	snd_cs5535audio_hw_free,
 	.prepare =	snd_cs5535audio_capture_prepare,

commit c6071300ac85b0db5cce715fa5bc3727251fb65a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:04 2019 +0100

    ALSA: cs5535: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The superfluous snd_pcm_lib_malloc_pages() and
    snd_pcm_lib_free_pages() calls are dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-33-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 4642e5384e83..0b2a23c6d277 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -236,10 +236,6 @@ static int snd_cs5535audio_hw_params(struct snd_pcm_substream *substream,
 	struct cs5535audio_dma *dma = substream->runtime->private_data;
 	int err;
 
-	err = snd_pcm_lib_malloc_pages(substream,
-					params_buffer_bytes(hw_params));
-	if (err < 0)
-		return err;
 	dma->buf_addr = substream->runtime->dma_addr;
 	dma->buf_bytes = params_buffer_bytes(hw_params);
 
@@ -267,7 +263,7 @@ static int snd_cs5535audio_hw_free(struct snd_pcm_substream *substream)
 		dma->pcm_open_flag = 0;
 	}
 	cs5535audio_clear_dma_packets(cs5535au, dma, substream);
-	return snd_pcm_lib_free_pages(substream);
+	return 0;
 }
 
 static int snd_cs5535audio_playback_prepare(struct snd_pcm_substream *substream)
@@ -431,9 +427,9 @@ int snd_cs5535audio_pcm(struct cs5535audio *cs5535au)
 	pcm->info_flags = 0;
 	strcpy(pcm->name, "CS5535 Audio");
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &cs5535au->pci->dev,
-					      64*1024, 128*1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
+				       &cs5535au->pci->dev,
+				       64*1024, 128*1024);
 	cs5535au->pcm = pcm;
 
 	return 0;

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 04822bf2f987..4642e5384e83 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -117,7 +117,7 @@ static int cs5535audio_build_dma_packets(struct cs5535audio *cs5535au,
 
 	if (dma->desc_buf.area == NULL) {
 		if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
-					snd_dma_pci_data(cs5535au->pci),
+					&cs5535au->pci->dev,
 					CS5535AUDIO_DESC_LIST_SIZE+1,
 					&dma->desc_buf) < 0)
 			return -ENOMEM;
@@ -432,8 +432,8 @@ int snd_cs5535audio_pcm(struct cs5535audio *cs5535au)
 	strcpy(pcm->name, "CS5535 Audio");
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					snd_dma_pci_data(cs5535au->pci),
-					64*1024, 128*1024);
+					      &cs5535au->pci->dev,
+					      64*1024, 128*1024);
 	cs5535au->pcm = pcm;
 
 	return 0;

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 326caec854e1..04822bf2f987 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Driver for audio on multifunction CS5535 companion device
  * Copyright (C) Jaya Kumar
@@ -5,20 +6,6 @@
  * Based on Jaroslav Kysela and Takashi Iwai's examples.
  * This work was sponsored by CIS(M) Sdn Bhd.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  * todo: add be fmt support, spdif, pm
  */
 

commit 69756930f2de0457d51db7d505a1e4f40e9fd116
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 17:59:26 2018 +0200

    ALSA: cs5535audio: Fix invalid endian conversion
    
    One place in cs5535audio_build_dma_packets() does an extra conversion
    via cpu_to_le32(); namely jmpprd_addr is passed to setup_prd() ops,
    which writes the value via cs_writel().  That is, the callback does
    the conversion by itself, and we don't need to convert beforehand.
    
    This patch fixes that bogus conversion.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index ee7065f6e162..326caec854e1 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -158,8 +158,8 @@ static int cs5535audio_build_dma_packets(struct cs5535audio *cs5535au,
 	lastdesc->addr = cpu_to_le32((u32) dma->desc_buf.addr);
 	lastdesc->size = 0;
 	lastdesc->ctlreserved = cpu_to_le16(PRD_JMP);
-	jmpprd_addr = cpu_to_le32(lastdesc->addr +
-				  (sizeof(struct cs5535audio_dma_desc)*periods));
+	jmpprd_addr = (u32)dma->desc_buf.addr +
+		sizeof(struct cs5535audio_dma_desc) * periods;
 
 	dma->substream = substream;
 	dma->period_bytes = period_bytes;

commit d670315c4f08cf3f380d249c64b88171bd33a348
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:17 2017 +0530

    ALSA: cs5535audio: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index c208c1d8dbb2..ee7065f6e162 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -33,7 +33,7 @@
 #include <sound/ac97_codec.h>
 #include "cs5535audio.h"
 
-static struct snd_pcm_hardware snd_cs5535audio_playback =
+static const struct snd_pcm_hardware snd_cs5535audio_playback =
 {
 	.info =			(
 				SNDRV_PCM_INFO_MMAP |
@@ -62,7 +62,7 @@ static struct snd_pcm_hardware snd_cs5535audio_playback =
 	.fifo_size =		0,
 };
 
-static struct snd_pcm_hardware snd_cs5535audio_capture =
+static const struct snd_pcm_hardware snd_cs5535audio_capture =
 {
 	.info =			(
 				SNDRV_PCM_INFO_MMAP |

commit 9d5262ae9b52d5dd96a4c5bd1b683570b84a011e
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:09 2016 +0200

    ALSA: cs5535audio: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 27fa57da8dc4..c208c1d8dbb2 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -380,7 +380,7 @@ static int snd_cs5535audio_capture_prepare(struct snd_pcm_substream *substream)
 				 substream->runtime->rate);
 }
 
-static struct snd_pcm_ops snd_cs5535audio_playback_ops = {
+static const struct snd_pcm_ops snd_cs5535audio_playback_ops = {
 	.open =		snd_cs5535audio_playback_open,
 	.close =	snd_cs5535audio_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -391,7 +391,7 @@ static struct snd_pcm_ops snd_cs5535audio_playback_ops = {
 	.pointer =	snd_cs5535audio_pcm_pointer,
 };
 
-static struct snd_pcm_ops snd_cs5535audio_capture_ops = {
+static const struct snd_pcm_ops snd_cs5535audio_capture_ops = {
 	.open =		snd_cs5535audio_capture_open,
 	.close =	snd_cs5535audio_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,

commit 55a8aeef6dbdb90f5ee97801b86c73ffd93e8afd
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Wed Dec 30 11:44:53 2015 +0100

    ALSA: cs5535audio: constify cs5535audio_dma_ops structures
    
    The cs5535audio_dma_ops structures are never modified, so declare them as
    const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 9c2dc911d8d7..27fa57da8dc4 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -402,7 +402,7 @@ static struct snd_pcm_ops snd_cs5535audio_capture_ops = {
 	.pointer =	snd_cs5535audio_pcm_pointer,
 };
 
-static struct cs5535audio_dma_ops snd_cs5535audio_playback_dma_ops = {
+static const struct cs5535audio_dma_ops snd_cs5535audio_playback_dma_ops = {
         .type = CS5535AUDIO_DMA_PLAYBACK,
         .enable_dma = cs5535audio_playback_enable_dma,
         .disable_dma = cs5535audio_playback_disable_dma,
@@ -412,7 +412,7 @@ static struct cs5535audio_dma_ops snd_cs5535audio_playback_dma_ops = {
         .read_dma_pntr = cs5535audio_playback_read_dma_pntr,
 };
 
-static struct cs5535audio_dma_ops snd_cs5535audio_capture_dma_ops = {
+static const struct cs5535audio_dma_ops snd_cs5535audio_capture_dma_ops = {
         .type = CS5535AUDIO_DMA_CAPTURE,
         .enable_dma = cs5535audio_capture_enable_dma,
         .disable_dma = cs5535audio_capture_disable_dma,

commit 00980aa9c7ce2b5b54a5a7e7cf259f36fabdb249
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 16:10:25 2014 +0100

    ALSA: cs5535audio: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 9ab01a7047cf..9c2dc911d8d7 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -317,7 +317,7 @@ static int snd_cs5535audio_trigger(struct snd_pcm_substream *substream, int cmd)
 		dma->ops->disable_dma(cs5535au);
 		break;
 	default:
-		snd_printk(KERN_ERR "unhandled trigger\n");
+		dev_err(cs5535au->card->dev, "unhandled trigger\n");
 		err = -EINVAL;
 		break;
 	}
@@ -335,13 +335,13 @@ static snd_pcm_uframes_t snd_cs5535audio_pcm_pointer(struct snd_pcm_substream
 	dma = substream->runtime->private_data;
 	curdma = dma->ops->read_dma_pntr(cs5535au);
 	if (curdma < dma->buf_addr) {
-		snd_printk(KERN_ERR "curdma=%x < %x bufaddr.\n",
+		dev_err(cs5535au->card->dev, "curdma=%x < %x bufaddr.\n",
 					curdma, dma->buf_addr);
 		return 0;
 	}
 	curdma -= dma->buf_addr;
 	if (curdma >= dma->buf_bytes) {
-		snd_printk(KERN_ERR "diff=%x >= %x buf_bytes.\n",
+		dev_err(cs5535au->card->dev, "diff=%x >= %x buf_bytes.\n",
 					curdma, dma->buf_bytes);
 		return 0;
 	}

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index dbf94b189e75..9ab01a7047cf 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -422,7 +422,7 @@ static struct cs5535audio_dma_ops snd_cs5535audio_capture_dma_ops = {
         .read_dma_pntr = cs5535audio_capture_read_dma_pntr,
 };
 
-int __devinit snd_cs5535audio_pcm(struct cs5535audio *cs5535au)
+int snd_cs5535audio_pcm(struct cs5535audio *cs5535au)
 {
 	struct snd_pcm *pcm;
 	int err;

commit 27533df80e93dc164e39d47281bbbd608f9014a6
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Sun Nov 20 23:57:49 2011 +0300

    ALSA: cs5535 - Fix an endianness conversion
    
    desc->size is supposed to be a le16 type.  On a big endian system the
    current code will set ->size to zero.  We fixed a similar bug
    on the next line but missed this one.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index e083122ca55a..dbf94b189e75 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -148,7 +148,7 @@ static int cs5535audio_build_dma_packets(struct cs5535audio *cs5535au,
 		struct cs5535audio_dma_desc *desc =
 			&((struct cs5535audio_dma_desc *) dma->desc_buf.area)[i];
 		desc->addr = cpu_to_le32(addr);
-		desc->size = cpu_to_le32(period_bytes);
+		desc->size = cpu_to_le16(period_bytes);
 		desc->ctlreserved = cpu_to_le16(PRD_EOP);
 		desc_addr += sizeof(struct cs5535audio_dma_desc);
 		addr += period_bytes;

commit 71276410e17653cfacfa238a363475cde9e18fb3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jun 30 12:31:23 2011 +0200

    ALSA: cs5535 - Fix invalid big-endian conversions
    
    Fix the wrongly converted short values:
      sound/pci/cs5535audio/cs5535audio_pcm.c:152: warning: large integer implicitly truncated to unsigned type
      sound/pci/cs5535audio/cs5535audio_pcm.c:160: warning: large integer implicitly truncated to unsigned type
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index f16bc8aad6ed..e083122ca55a 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -149,7 +149,7 @@ static int cs5535audio_build_dma_packets(struct cs5535audio *cs5535au,
 			&((struct cs5535audio_dma_desc *) dma->desc_buf.area)[i];
 		desc->addr = cpu_to_le32(addr);
 		desc->size = cpu_to_le32(period_bytes);
-		desc->ctlreserved = cpu_to_le32(PRD_EOP);
+		desc->ctlreserved = cpu_to_le16(PRD_EOP);
 		desc_addr += sizeof(struct cs5535audio_dma_desc);
 		addr += period_bytes;
 	}
@@ -157,7 +157,7 @@ static int cs5535audio_build_dma_packets(struct cs5535audio *cs5535au,
 	lastdesc = &((struct cs5535audio_dma_desc *) dma->desc_buf.area)[periods];
 	lastdesc->addr = cpu_to_le32((u32) dma->desc_buf.addr);
 	lastdesc->size = 0;
-	lastdesc->ctlreserved = cpu_to_le32(PRD_JMP);
+	lastdesc->ctlreserved = cpu_to_le16(PRD_JMP);
 	jmpprd_addr = cpu_to_le32(lastdesc->addr +
 				  (sizeof(struct cs5535audio_dma_desc)*periods));
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 0f48a871f17b..f16bc8aad6ed 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -23,7 +23,6 @@
  */
 
 #include <linux/init.h>
-#include <linux/slab.h>
 #include <linux/pci.h>
 #include <sound/core.h>
 #include <sound/control.h>

commit bf1e5278354856ac0260d338961560e720147681
Author: Andres Salomon <dilinger@queued.net>
Date:   Thu Nov 6 16:53:03 2008 -0500

    ALSA: cs5535audio: rename V_REFOUT control to MIC Bias
    
    This drops the AD1888 V_REFOUT control, and replaces it with a MIC Bias
    Enable control.  It also moves the MIC bias enabling into a separate
    function.
    
    Signed-off-by: Andres Salomon <dilinger@debian.org>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index fa2a6b1b81a6..0f48a871f17b 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -363,27 +363,14 @@ static int snd_cs5535audio_capture_open(struct snd_pcm_substream *substream)
 	if ((err = snd_pcm_hw_constraint_integer(runtime,
 					 SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
 		return err;
-
-#ifdef CONFIG_OLPC
-	/* Enable the V_ref bias only while recording. */
-	err = snd_ac97_update_bits(cs5535au->ac97, AC97_AD_MISC,
-			1 << AC97_AD_VREFD_SHIFT, 0);
-	if (err < 0)
-		snd_printk(KERN_ERR "Error updating AD_MISC %d\n", err);
-#endif
+	olpc_capture_open(cs5535au->ac97);
 	return 0;
 }
 
 static int snd_cs5535audio_capture_close(struct snd_pcm_substream *substream)
 {
-	int err;
 	struct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);
-
-#ifdef CONFIG_OLPC
-	/* Disable V_ref bias. */
-	err = snd_ac97_update_bits(cs5535au->ac97, AC97_AD_MISC,
-			1 << AC97_AD_VREFD_SHIFT, 1 << AC97_AD_VREFD_SHIFT);
-#endif
+	olpc_capture_close(cs5535au->ac97);
 	return 0;
 }
 

commit e463ae1d13ffe4943bb31f47cc6f24415e55a59a
Author: Chris Ball <cjb@laptop.org>
Date:   Thu Nov 6 16:50:09 2008 -0500

    ALSA: cs5535audio: enable OLPC's V_REFOUT bias when recording
    
    The OLPC has a privacy light hooked up in series with the microphone's
    V_Ref bias.  We want to activate the bias while we are capturing audio.
    
    Signed-off-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Andres Salomon <dilinger@debian.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 6aa0c19390d7..fa2a6b1b81a6 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -363,11 +363,27 @@ static int snd_cs5535audio_capture_open(struct snd_pcm_substream *substream)
 	if ((err = snd_pcm_hw_constraint_integer(runtime,
 					 SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
 		return err;
+
+#ifdef CONFIG_OLPC
+	/* Enable the V_ref bias only while recording. */
+	err = snd_ac97_update_bits(cs5535au->ac97, AC97_AD_MISC,
+			1 << AC97_AD_VREFD_SHIFT, 0);
+	if (err < 0)
+		snd_printk(KERN_ERR "Error updating AD_MISC %d\n", err);
+#endif
 	return 0;
 }
 
 static int snd_cs5535audio_capture_close(struct snd_pcm_substream *substream)
 {
+	int err;
+	struct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);
+
+#ifdef CONFIG_OLPC
+	/* Disable V_ref bias. */
+	err = snd_ac97_update_bits(cs5535au->ac97, AC97_AD_MISC,
+			1 << AC97_AD_VREFD_SHIFT, 1 << AC97_AD_VREFD_SHIFT);
+#endif
 	return 0;
 }
 

commit b035ce0f26812292d067fbe2fc9e9d88d5dfcdb4
Author: Jaya Kumar <jayakumar.lkml@gmail.com>
Date:   Wed Nov 5 17:30:08 2008 -0500

    ALSA: cs5535audio: turn off PCM properly if closing the audio device
    
    As per <http://dev.laptop.org/ticket/1420>, we need to properly turn off
    the PCM if we're closing the device in order to save power.  This also
    causes the MIC led to turn off properly.
    
    Signed-off-by: Jaya Kumar <jayakumar.lkml@gmail.com>
    Signed-off-by: Andres Salomon <dilinger@debian.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index cdcda87116c3..6aa0c19390d7 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -260,6 +260,9 @@ static int snd_cs5535audio_hw_params(struct snd_pcm_substream *substream,
 	err = cs5535audio_build_dma_packets(cs5535au, dma, substream,
 					    params_periods(hw_params),
 					    params_period_bytes(hw_params));
+	if (!err)
+		dma->pcm_open_flag = 1;
+
 	return err;
 }
 
@@ -268,6 +271,15 @@ static int snd_cs5535audio_hw_free(struct snd_pcm_substream *substream)
 	struct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);
 	struct cs5535audio_dma *dma = substream->runtime->private_data;
 
+	if (dma->pcm_open_flag) {
+		if (substream == cs5535au->playback_substream)
+			snd_ac97_update_power(cs5535au->ac97,
+					AC97_PCM_FRONT_DAC_RATE, 0);
+		else
+			snd_ac97_update_power(cs5535au->ac97,
+					AC97_PCM_LR_ADC_RATE, 0);
+		dma->pcm_open_flag = 0;
+	}
 	cs5535audio_clear_dma_packets(cs5535au, dma, substream);
 	return snd_pcm_lib_free_pages(substream);
 }

commit 0de27c10d3524eba9e81f56ff315e97d95b3faa0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 21 11:49:03 2008 +0100

    [ALSA] cs5535audio - Fix available sample rates
    
    The available sample rates on CS5535 depend on AC97 codec chip.
    Set the additional hw params limit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 499e27961a30..cdcda87116c3 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -97,6 +97,8 @@ static int snd_cs5535audio_playback_open(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	runtime->hw = snd_cs5535audio_playback;
+	runtime->hw.rates = cs5535au->ac97->rates[AC97_RATES_FRONT_DAC];
+	snd_pcm_limit_hw_rates(runtime);
 	cs5535au->playback_substream = substream;
 	runtime->private_data = &(cs5535au->dmas[CS5535AUDIO_DMA_PLAYBACK]);
 	if ((err = snd_pcm_hw_constraint_integer(runtime,
@@ -342,6 +344,8 @@ static int snd_cs5535audio_capture_open(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	runtime->hw = snd_cs5535audio_capture;
+	runtime->hw.rates = cs5535au->ac97->rates[AC97_RATES_ADC];
+	snd_pcm_limit_hw_rates(runtime);
 	cs5535au->capture_substream = substream;
 	runtime->private_data = &(cs5535au->dmas[CS5535AUDIO_DMA_CAPTURE]);
 	if ((err = snd_pcm_hw_constraint_integer(runtime,

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 21df0634af32..499e27961a30 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -25,7 +25,6 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/pci.h>
-#include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/initval.h>

commit 222fa0b0d2fdb2373a71d532c2cabd2ec920b3b3
Author: Andres Salomon <dilinger@debian.org>
Date:   Mon Sep 3 15:42:16 2007 +0200

    [ALSA] cs5535audio: fix PRD register save/restore power management race
    
    In the suspend path, we currently save the PRD registers and then disable DMA.
    This is racy; the sound hardware might update the PRD register as it finishes
    processing some DMA pages between when we've saved the PRD registers and
    when DMA actually gets disabled.  Furthermore, we actively check whether or
    not DMA is enabled before saving PRD registers; there's no reason to do that,
    as the PRD registers should not update when we twiddle the ACC_BM[x]_CMD
    register(s).  Worst case, we save the PRD registers twice; even powering
    down the ACC shouldn't mess with the PRD registers (according to the 5536
    data sheet, section 5.3.7.4, power-down procedure).  This patch reworks
    all that to first disable DMA, and then save PRD registers.
    
    Signed-off-by: Andres Salomon <dilinger@debian.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 9a1e87fd4815..21df0634af32 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -297,14 +297,12 @@ static int snd_cs5535audio_trigger(struct snd_pcm_substream *substream, int cmd)
 		break;
 	case SNDRV_PCM_TRIGGER_RESUME:
 		dma->ops->enable_dma(cs5535au);
-		dma->suspended = 0;
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 		dma->ops->disable_dma(cs5535au);
 		break;
 	case SNDRV_PCM_TRIGGER_SUSPEND:
 		dma->ops->disable_dma(cs5535au);
-		dma->suspended = 1;
 		break;
 	default:
 		snd_printk(KERN_ERR "unhandled trigger\n");

commit 7abcacb09ac0f9c6848f1e7d86b284427fa83cee
Author: Andres Salomon <dilinger@debian.org>
Date:   Mon Sep 3 15:41:47 2007 +0200

    [ALSA] cs5535audio: correctly set dma->substream
    
    We're never actually setting dma->substream to the current substream; that
    means the dma->substream checks that we do in the suspend/resume path
    are never satisfied, and the PRD registers are never correctly managed.  This
    changes it so that we set the substream when constructing the specific
    bus master DMA, and unsetting it when we tear down the BM's DMA.
    
    Signed-off-by: Andres Salomon <dilinger@debian.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index ec920cbb2a71..9a1e87fd4815 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -161,6 +161,7 @@ static int cs5535audio_build_dma_packets(struct cs5535audio *cs5535au,
 	jmpprd_addr = cpu_to_le32(lastdesc->addr +
 				  (sizeof(struct cs5535audio_dma_desc)*periods));
 
+	dma->substream = substream;
 	dma->period_bytes = period_bytes;
 	dma->periods = periods;
 	spin_lock_irq(&cs5535au->reg_lock);
@@ -238,6 +239,7 @@ static void cs5535audio_clear_dma_packets(struct cs5535audio *cs5535au,
 {
 	snd_dma_free_pages(&dma->desc_buf);
 	dma->desc_buf.area = NULL;
+	dma->substream = NULL;
 }
 
 static int snd_cs5535audio_hw_params(struct snd_pcm_substream *substream,

commit b83f346bc4d6ab358fd0da85b7eab08bf0234c0b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 13 17:37:55 2007 +0200

    [ALSA] remove incorrect usage of SNDRV_PCM_INFO_SYNC_START and snd_pcm_set_sync()
    
    Set the SNDRV_PCM_INFO_SYNC_START flag and the substream's sync ID
    (only) if the substream actually can be linked to another one.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 5450a9e8f133..ec920cbb2a71 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -43,7 +43,6 @@ static struct snd_pcm_hardware snd_cs5535audio_playback =
 		 		SNDRV_PCM_INFO_BLOCK_TRANSFER |
 		 		SNDRV_PCM_INFO_MMAP_VALID |
 		 		SNDRV_PCM_INFO_PAUSE |
-				SNDRV_PCM_INFO_SYNC_START |
 				SNDRV_PCM_INFO_RESUME
 				),
 	.formats =		(
@@ -71,8 +70,7 @@ static struct snd_pcm_hardware snd_cs5535audio_capture =
 				SNDRV_PCM_INFO_MMAP |
 				SNDRV_PCM_INFO_INTERLEAVED |
 		 		SNDRV_PCM_INFO_BLOCK_TRANSFER |
-		 		SNDRV_PCM_INFO_MMAP_VALID |
-				SNDRV_PCM_INFO_SYNC_START
+		 		SNDRV_PCM_INFO_MMAP_VALID
 				),
 	.formats =		(
 				SNDRV_PCM_FMTBIT_S16_LE
@@ -102,7 +100,6 @@ static int snd_cs5535audio_playback_open(struct snd_pcm_substream *substream)
 	runtime->hw = snd_cs5535audio_playback;
 	cs5535au->playback_substream = substream;
 	runtime->private_data = &(cs5535au->dmas[CS5535AUDIO_DMA_PLAYBACK]);
-	snd_pcm_set_sync(substream);
 	if ((err = snd_pcm_hw_constraint_integer(runtime,
 				SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
 		return err;
@@ -348,7 +345,6 @@ static int snd_cs5535audio_capture_open(struct snd_pcm_substream *substream)
 	runtime->hw = snd_cs5535audio_capture;
 	cs5535au->capture_substream = substream;
 	runtime->private_data = &(cs5535au->dmas[CS5535AUDIO_DMA_CAPTURE]);
-	snd_pcm_set_sync(substream);
 	if ((err = snd_pcm_hw_constraint_integer(runtime,
 					 SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
 		return err;

commit d6e05edc59ecd79e8badf440c0d295a979bdfa3e
Author: Andreas Mohr <andi@lisas.de>
Date:   Mon Jun 26 18:35:02 2006 +0200

    spelling fixes
    
    acquired (aquired)
    contiguous (contigious)
    successful (succesful, succesfull)
    surprise (suprise)
    whether (weather)
    some other misspellings
    
    Signed-off-by: Andreas Mohr <andi@lisas.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index f0a48693d687..5450a9e8f133 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -143,7 +143,7 @@ static int cs5535audio_build_dma_packets(struct cs5535audio *cs5535au,
 	if (dma->periods == periods && dma->period_bytes == period_bytes)
 		return 0;
 
-	/* the u32 cast is okay because in snd*create we succesfully told
+	/* the u32 cast is okay because in snd*create we successfully told
    	   pci alloc that we're only 32 bit capable so the uppper will be 0 */
 	addr = (u32) substream->runtime->dma_addr;
 	desc_addr = (u32) dma->desc_buf.addr;

commit 9ac25594e68a4b61516e7c1140d8c0f7ef449e20
Author: Jaya Kumar <jayakumar.alsa@gmail.com>
Date:   Fri Apr 28 14:34:49 2006 +0200

    [ALSA] PM support for cs5535audio
    
    Appended is my patch adding PM support to the cs5535audio driver.
    I also added the ac97 quirk but it's not yet confirmed which
    boards need to be in the quirk list. The patch also includes some
    Kconfig and misc cleanup.
    
    Signed-off-by: Jaya Kumar <jayakumar.alsa@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 60bb82b2ff47..f0a48693d687 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -43,7 +43,8 @@ static struct snd_pcm_hardware snd_cs5535audio_playback =
 		 		SNDRV_PCM_INFO_BLOCK_TRANSFER |
 		 		SNDRV_PCM_INFO_MMAP_VALID |
 		 		SNDRV_PCM_INFO_PAUSE |
-				SNDRV_PCM_INFO_SYNC_START
+				SNDRV_PCM_INFO_SYNC_START |
+				SNDRV_PCM_INFO_RESUME
 				),
 	.formats =		(
 				SNDRV_PCM_FMTBIT_S16_LE
@@ -193,6 +194,11 @@ static void cs5535audio_playback_setup_prd(struct cs5535audio *cs5535au,
 	cs_writel(cs5535au, ACC_BM0_PRD, prd_addr);
 }
 
+static u32 cs5535audio_playback_read_prd(struct cs5535audio *cs5535au)
+{
+	return cs_readl(cs5535au, ACC_BM0_PRD);
+}
+
 static u32 cs5535audio_playback_read_dma_pntr(struct cs5535audio *cs5535au)
 {
 	return cs_readl(cs5535au, ACC_BM0_PNTR);
@@ -219,6 +225,11 @@ static void cs5535audio_capture_setup_prd(struct cs5535audio *cs5535au,
 	cs_writel(cs5535au, ACC_BM1_PRD, prd_addr);
 }
 
+static u32 cs5535audio_capture_read_prd(struct cs5535audio *cs5535au)
+{
+	return cs_readl(cs5535au, ACC_BM1_PRD);
+}
+
 static u32 cs5535audio_capture_read_dma_pntr(struct cs5535audio *cs5535au)
 {
 	return cs_readl(cs5535au, ACC_BM1_PNTR);
@@ -285,9 +296,17 @@ static int snd_cs5535audio_trigger(struct snd_pcm_substream *substream, int cmd)
 	case SNDRV_PCM_TRIGGER_START:
 		dma->ops->enable_dma(cs5535au);
 		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+		dma->ops->enable_dma(cs5535au);
+		dma->suspended = 0;
+		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 		dma->ops->disable_dma(cs5535au);
 		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		dma->ops->disable_dma(cs5535au);
+		dma->suspended = 1;
+		break;
 	default:
 		snd_printk(KERN_ERR "unhandled trigger\n");
 		err = -EINVAL;
@@ -375,6 +394,7 @@ static struct cs5535audio_dma_ops snd_cs5535audio_playback_dma_ops = {
         .enable_dma = cs5535audio_playback_enable_dma,
         .disable_dma = cs5535audio_playback_disable_dma,
         .setup_prd = cs5535audio_playback_setup_prd,
+        .read_prd = cs5535audio_playback_read_prd,
         .pause_dma = cs5535audio_playback_pause_dma,
         .read_dma_pntr = cs5535audio_playback_read_dma_pntr,
 };
@@ -384,6 +404,7 @@ static struct cs5535audio_dma_ops snd_cs5535audio_capture_dma_ops = {
         .enable_dma = cs5535audio_capture_enable_dma,
         .disable_dma = cs5535audio_capture_disable_dma,
         .setup_prd = cs5535audio_capture_setup_prd,
+        .read_prd = cs5535audio_capture_read_prd,
         .pause_dma = cs5535audio_capture_pause_dma,
         .read_dma_pntr = cs5535audio_capture_read_dma_pntr,
 };
@@ -413,6 +434,7 @@ int __devinit snd_cs5535audio_pcm(struct cs5535audio *cs5535au)
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
 					snd_dma_pci_data(cs5535au->pci),
 					64*1024, 128*1024);
+	cs5535au->pcm = pcm;
 
 	return 0;
 }

commit 66f8df6bdd388d209c38197785148c994c8a738d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:56:21 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI CS5535
    
    Modules: CS5535 driver
    
    Remove xxx_t typedefs from the PCI CS5535 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index d32b23f202cd..60bb82b2ff47 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -35,7 +35,7 @@
 #include <sound/ac97_codec.h>
 #include "cs5535audio.h"
 
-static snd_pcm_hardware_t snd_cs5535audio_playback =
+static struct snd_pcm_hardware snd_cs5535audio_playback =
 {
 	.info =			(
 				SNDRV_PCM_INFO_MMAP |
@@ -64,7 +64,7 @@ static snd_pcm_hardware_t snd_cs5535audio_playback =
 	.fifo_size =		0,
 };
 
-static snd_pcm_hardware_t snd_cs5535audio_capture =
+static struct snd_pcm_hardware snd_cs5535audio_capture =
 {
 	.info =			(
 				SNDRV_PCM_INFO_MMAP |
@@ -92,11 +92,11 @@ static snd_pcm_hardware_t snd_cs5535audio_capture =
 	.fifo_size =		0,
 };
 
-static int snd_cs5535audio_playback_open(snd_pcm_substream_t *substream)
+static int snd_cs5535audio_playback_open(struct snd_pcm_substream *substream)
 {
 	int err;
-	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	runtime->hw = snd_cs5535audio_playback;
 	cs5535au->playback_substream = substream;
@@ -109,23 +109,23 @@ static int snd_cs5535audio_playback_open(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static int snd_cs5535audio_playback_close(snd_pcm_substream_t *substream)
+static int snd_cs5535audio_playback_close(struct snd_pcm_substream *substream)
 {
 	return 0;
 }
 
 #define CS5535AUDIO_DESC_LIST_SIZE \
-	PAGE_ALIGN(CS5535AUDIO_MAX_DESCRIPTORS * sizeof(cs5535audio_dma_desc_t))
+	PAGE_ALIGN(CS5535AUDIO_MAX_DESCRIPTORS * sizeof(struct cs5535audio_dma_desc))
 
-static int cs5535audio_build_dma_packets(cs5535audio_t *cs5535au,
-					cs5535audio_dma_t *dma,
-					snd_pcm_substream_t *substream,
-					unsigned int periods,
-					unsigned int period_bytes)
+static int cs5535audio_build_dma_packets(struct cs5535audio *cs5535au,
+					 struct cs5535audio_dma *dma,
+					 struct snd_pcm_substream *substream,
+					 unsigned int periods,
+					 unsigned int period_bytes)
 {
 	unsigned int i;
 	u32 addr, desc_addr, jmpprd_addr;
-	cs5535audio_dma_desc_t *lastdesc;
+	struct cs5535audio_dma_desc *lastdesc;
 
 	if (periods > CS5535AUDIO_MAX_DESCRIPTORS)
 		return -ENOMEM;
@@ -147,21 +147,21 @@ static int cs5535audio_build_dma_packets(cs5535audio_t *cs5535au,
 	addr = (u32) substream->runtime->dma_addr;
 	desc_addr = (u32) dma->desc_buf.addr;
 	for (i = 0; i < periods; i++) {
-		cs5535audio_dma_desc_t *desc =
-			&((cs5535audio_dma_desc_t *) dma->desc_buf.area)[i];
+		struct cs5535audio_dma_desc *desc =
+			&((struct cs5535audio_dma_desc *) dma->desc_buf.area)[i];
 		desc->addr = cpu_to_le32(addr);
 		desc->size = cpu_to_le32(period_bytes);
 		desc->ctlreserved = cpu_to_le32(PRD_EOP);
-		desc_addr += sizeof(cs5535audio_dma_desc_t);
+		desc_addr += sizeof(struct cs5535audio_dma_desc);
 		addr += period_bytes;
 	}
 	/* we reserved one dummy descriptor at the end to do the PRD jump */
-	lastdesc = &((cs5535audio_dma_desc_t *) dma->desc_buf.area)[periods];
+	lastdesc = &((struct cs5535audio_dma_desc *) dma->desc_buf.area)[periods];
 	lastdesc->addr = cpu_to_le32((u32) dma->desc_buf.addr);
 	lastdesc->size = 0;
 	lastdesc->ctlreserved = cpu_to_le32(PRD_JMP);
 	jmpprd_addr = cpu_to_le32(lastdesc->addr +
-				(sizeof(cs5535audio_dma_desc_t)*periods));
+				  (sizeof(struct cs5535audio_dma_desc)*periods));
 
 	dma->period_bytes = period_bytes;
 	dma->periods = periods;
@@ -172,71 +172,71 @@ static int cs5535audio_build_dma_packets(cs5535audio_t *cs5535au,
 	return 0;
 }
 
-static void cs5535audio_playback_enable_dma(cs5535audio_t *cs5535au)
+static void cs5535audio_playback_enable_dma(struct cs5535audio *cs5535au)
 {
 	cs_writeb(cs5535au, ACC_BM0_CMD, BM_CTL_EN);
 }
 
-static void cs5535audio_playback_disable_dma(cs5535audio_t *cs5535au)
+static void cs5535audio_playback_disable_dma(struct cs5535audio *cs5535au)
 {
 	cs_writeb(cs5535au, ACC_BM0_CMD, 0);
 }
 
-static void cs5535audio_playback_pause_dma(cs5535audio_t *cs5535au)
+static void cs5535audio_playback_pause_dma(struct cs5535audio *cs5535au)
 {
 	cs_writeb(cs5535au, ACC_BM0_CMD, BM_CTL_PAUSE);
 }
 
-static void cs5535audio_playback_setup_prd(cs5535audio_t *cs5535au,
-						u32 prd_addr)
+static void cs5535audio_playback_setup_prd(struct cs5535audio *cs5535au,
+					   u32 prd_addr)
 {
 	cs_writel(cs5535au, ACC_BM0_PRD, prd_addr);
 }
 
-static u32 cs5535audio_playback_read_dma_pntr(cs5535audio_t *cs5535au)
+static u32 cs5535audio_playback_read_dma_pntr(struct cs5535audio *cs5535au)
 {
 	return cs_readl(cs5535au, ACC_BM0_PNTR);
 }
 
-static void cs5535audio_capture_enable_dma(cs5535audio_t *cs5535au)
+static void cs5535audio_capture_enable_dma(struct cs5535audio *cs5535au)
 {
 	cs_writeb(cs5535au, ACC_BM1_CMD, BM_CTL_EN);
 }
 
-static void cs5535audio_capture_disable_dma(cs5535audio_t *cs5535au)
+static void cs5535audio_capture_disable_dma(struct cs5535audio *cs5535au)
 {
 	cs_writeb(cs5535au, ACC_BM1_CMD, 0);
 }
 
-static void cs5535audio_capture_pause_dma(cs5535audio_t *cs5535au)
+static void cs5535audio_capture_pause_dma(struct cs5535audio *cs5535au)
 {
 	cs_writeb(cs5535au, ACC_BM1_CMD, BM_CTL_PAUSE);
 }
 
-static void cs5535audio_capture_setup_prd(cs5535audio_t *cs5535au,
-						u32 prd_addr)
+static void cs5535audio_capture_setup_prd(struct cs5535audio *cs5535au,
+					  u32 prd_addr)
 {
 	cs_writel(cs5535au, ACC_BM1_PRD, prd_addr);
 }
 
-static u32 cs5535audio_capture_read_dma_pntr(cs5535audio_t *cs5535au)
+static u32 cs5535audio_capture_read_dma_pntr(struct cs5535audio *cs5535au)
 {
 	return cs_readl(cs5535au, ACC_BM1_PNTR);
 }
 
-static void cs5535audio_clear_dma_packets(cs5535audio_t *cs5535au,
-					cs5535audio_dma_t *dma,
-					snd_pcm_substream_t *substream)
+static void cs5535audio_clear_dma_packets(struct cs5535audio *cs5535au,
+					  struct cs5535audio_dma *dma,
+					  struct snd_pcm_substream *substream)
 {
 	snd_dma_free_pages(&dma->desc_buf);
 	dma->desc_buf.area = NULL;
 }
 
-static int snd_cs5535audio_hw_params(snd_pcm_substream_t *substream,
-				 snd_pcm_hw_params_t *hw_params)
+static int snd_cs5535audio_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *hw_params)
 {
-	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
-	cs5535audio_dma_t *dma = substream->runtime->private_data;
+	struct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);
+	struct cs5535audio_dma *dma = substream->runtime->private_data;
 	int err;
 
 	err = snd_pcm_lib_malloc_pages(substream,
@@ -247,31 +247,31 @@ static int snd_cs5535audio_hw_params(snd_pcm_substream_t *substream,
 	dma->buf_bytes = params_buffer_bytes(hw_params);
 
 	err = cs5535audio_build_dma_packets(cs5535au, dma, substream,
-				       params_periods(hw_params),
-				       params_period_bytes(hw_params));
+					    params_periods(hw_params),
+					    params_period_bytes(hw_params));
 	return err;
 }
 
-static int snd_cs5535audio_hw_free(snd_pcm_substream_t *substream)
+static int snd_cs5535audio_hw_free(struct snd_pcm_substream *substream)
 {
-	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
-	cs5535audio_dma_t *dma = substream->runtime->private_data;
+	struct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);
+	struct cs5535audio_dma *dma = substream->runtime->private_data;
 
 	cs5535audio_clear_dma_packets(cs5535au, dma, substream);
 	return snd_pcm_lib_free_pages(substream);
 }
 
-static int snd_cs5535audio_playback_prepare(snd_pcm_substream_t *substream)
+static int snd_cs5535audio_playback_prepare(struct snd_pcm_substream *substream)
 {
-	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
+	struct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);
 	return snd_ac97_set_rate(cs5535au->ac97, AC97_PCM_FRONT_DAC_RATE,
-					substream->runtime->rate);
+				 substream->runtime->rate);
 }
 
-static int snd_cs5535audio_trigger(snd_pcm_substream_t *substream, int cmd)
+static int snd_cs5535audio_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
-	cs5535audio_dma_t *dma = substream->runtime->private_data;
+	struct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);
+	struct cs5535audio_dma *dma = substream->runtime->private_data;
 	int err = 0;
 
 	spin_lock(&cs5535au->reg_lock);
@@ -297,12 +297,12 @@ static int snd_cs5535audio_trigger(snd_pcm_substream_t *substream, int cmd)
 	return err;
 }
 
-static snd_pcm_uframes_t snd_cs5535audio_pcm_pointer(snd_pcm_substream_t
+static snd_pcm_uframes_t snd_cs5535audio_pcm_pointer(struct snd_pcm_substream
 							*substream)
 {
-	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
+	struct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);
 	u32 curdma;
-	cs5535audio_dma_t *dma;
+	struct cs5535audio_dma *dma;
 
 	dma = substream->runtime->private_data;
 	curdma = dma->ops->read_dma_pntr(cs5535au);
@@ -320,11 +320,11 @@ static snd_pcm_uframes_t snd_cs5535audio_pcm_pointer(snd_pcm_substream_t
 	return bytes_to_frames(substream->runtime, curdma);
 }
 
-static int snd_cs5535audio_capture_open(snd_pcm_substream_t *substream)
+static int snd_cs5535audio_capture_open(struct snd_pcm_substream *substream)
 {
 	int err;
-	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	runtime->hw = snd_cs5535audio_capture;
 	cs5535au->capture_substream = substream;
@@ -336,19 +336,19 @@ static int snd_cs5535audio_capture_open(snd_pcm_substream_t *substream)
 	return 0;
 }
 
-static int snd_cs5535audio_capture_close(snd_pcm_substream_t *substream)
+static int snd_cs5535audio_capture_close(struct snd_pcm_substream *substream)
 {
 	return 0;
 }
 
-static int snd_cs5535audio_capture_prepare(snd_pcm_substream_t *substream)
+static int snd_cs5535audio_capture_prepare(struct snd_pcm_substream *substream)
 {
-	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
+	struct cs5535audio *cs5535au = snd_pcm_substream_chip(substream);
 	return snd_ac97_set_rate(cs5535au->ac97, AC97_PCM_LR_ADC_RATE,
-					substream->runtime->rate);
+				 substream->runtime->rate);
 }
 
-static snd_pcm_ops_t snd_cs5535audio_playback_ops = {
+static struct snd_pcm_ops snd_cs5535audio_playback_ops = {
 	.open =		snd_cs5535audio_playback_open,
 	.close =	snd_cs5535audio_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -359,7 +359,7 @@ static snd_pcm_ops_t snd_cs5535audio_playback_ops = {
 	.pointer =	snd_cs5535audio_pcm_pointer,
 };
 
-static snd_pcm_ops_t snd_cs5535audio_capture_ops = {
+static struct snd_pcm_ops snd_cs5535audio_capture_ops = {
 	.open =		snd_cs5535audio_capture_open,
 	.close =	snd_cs5535audio_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -370,7 +370,7 @@ static snd_pcm_ops_t snd_cs5535audio_capture_ops = {
 	.pointer =	snd_cs5535audio_pcm_pointer,
 };
 
-static cs5535audio_dma_ops_t snd_cs5535audio_playback_dma_ops = {
+static struct cs5535audio_dma_ops snd_cs5535audio_playback_dma_ops = {
         .type = CS5535AUDIO_DMA_PLAYBACK,
         .enable_dma = cs5535audio_playback_enable_dma,
         .disable_dma = cs5535audio_playback_disable_dma,
@@ -379,7 +379,7 @@ static cs5535audio_dma_ops_t snd_cs5535audio_playback_dma_ops = {
         .read_dma_pntr = cs5535audio_playback_read_dma_pntr,
 };
 
-static cs5535audio_dma_ops_t snd_cs5535audio_capture_dma_ops = {
+static struct cs5535audio_dma_ops snd_cs5535audio_capture_dma_ops = {
         .type = CS5535AUDIO_DMA_CAPTURE,
         .enable_dma = cs5535audio_capture_enable_dma,
         .disable_dma = cs5535audio_capture_disable_dma,
@@ -388,9 +388,9 @@ static cs5535audio_dma_ops_t snd_cs5535audio_capture_dma_ops = {
         .read_dma_pntr = cs5535audio_capture_read_dma_pntr,
 };
 
-int __devinit snd_cs5535audio_pcm(cs5535audio_t *cs5535au)
+int __devinit snd_cs5535audio_pcm(struct cs5535audio *cs5535au)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	err = snd_pcm_new(cs5535au->card, "CS5535 Audio", 0, 1, 1, &pcm);

commit 3e8731740e17f01ec1ecce556ccdc4c42279ce1b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 10:15:37 2005 +0100

    [ALSA] Minor clean up and fixes for CS5535 audio driver
    
    Modules: Documentation,CS5535 driver
    
    Minor clean up and fixes for CS5535 audio driver.
    Added an entry in ALSA-Configuration.txt, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
index 5802ed9d57be..d32b23f202cd 100644
--- a/sound/pci/cs5535audio/cs5535audio_pcm.c
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -150,8 +150,8 @@ static int cs5535audio_build_dma_packets(cs5535audio_t *cs5535au,
 		cs5535audio_dma_desc_t *desc =
 			&((cs5535audio_dma_desc_t *) dma->desc_buf.area)[i];
 		desc->addr = cpu_to_le32(addr);
-		desc->size = period_bytes;
-		desc->ctlreserved = PRD_EOP;
+		desc->size = cpu_to_le32(period_bytes);
+		desc->ctlreserved = cpu_to_le32(PRD_EOP);
 		desc_addr += sizeof(cs5535audio_dma_desc_t);
 		addr += period_bytes;
 	}
@@ -159,7 +159,7 @@ static int cs5535audio_build_dma_packets(cs5535audio_t *cs5535au,
 	lastdesc = &((cs5535audio_dma_desc_t *) dma->desc_buf.area)[periods];
 	lastdesc->addr = cpu_to_le32((u32) dma->desc_buf.addr);
 	lastdesc->size = 0;
-	lastdesc->ctlreserved = PRD_JMP;
+	lastdesc->ctlreserved = cpu_to_le32(PRD_JMP);
 	jmpprd_addr = cpu_to_le32(lastdesc->addr +
 				(sizeof(cs5535audio_dma_desc_t)*periods));
 
@@ -272,34 +272,29 @@ static int snd_cs5535audio_trigger(snd_pcm_substream_t *substream, int cmd)
 {
 	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
 	cs5535audio_dma_t *dma = substream->runtime->private_data;
+	int err = 0;
 
+	spin_lock(&cs5535au->reg_lock);
 	switch (cmd) {
-		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-			spin_lock_irq(&cs5535au->reg_lock);
-			dma->ops->pause_dma(cs5535au);
-			spin_unlock_irq(&cs5535au->reg_lock);
-			break;
-		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-			spin_lock_irq(&cs5535au->reg_lock);
-			dma->ops->enable_dma(cs5535au);
-			spin_unlock_irq(&cs5535au->reg_lock);
-			break;
-		case SNDRV_PCM_TRIGGER_START:
-			spin_lock_irq(&cs5535au->reg_lock);
-			dma->ops->enable_dma(cs5535au);
-			spin_unlock_irq(&cs5535au->reg_lock);
-			break;
-		case SNDRV_PCM_TRIGGER_STOP:
-			spin_lock_irq(&cs5535au->reg_lock);
-			dma->ops->disable_dma(cs5535au);
-			spin_unlock_irq(&cs5535au->reg_lock);
-			break;
-		default:
-			snd_printk(KERN_ERR "unhandled trigger\n");
-			return -EINVAL;
-			break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dma->ops->pause_dma(cs5535au);
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		dma->ops->enable_dma(cs5535au);
+		break;
+	case SNDRV_PCM_TRIGGER_START:
+		dma->ops->enable_dma(cs5535au);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		dma->ops->disable_dma(cs5535au);
+		break;
+	default:
+		snd_printk(KERN_ERR "unhandled trigger\n");
+		err = -EINVAL;
+		break;
 	}
-	return 0;
+	spin_unlock(&cs5535au->reg_lock);
+	return err;
 }
 
 static snd_pcm_uframes_t snd_cs5535audio_pcm_pointer(snd_pcm_substream_t
@@ -375,11 +370,6 @@ static snd_pcm_ops_t snd_cs5535audio_capture_ops = {
 	.pointer =	snd_cs5535audio_pcm_pointer,
 };
 
-static void snd_cs5535audio_pcm_free(snd_pcm_t *pcm)
-{
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
 static cs5535audio_dma_ops_t snd_cs5535audio_playback_dma_ops = {
         .type = CS5535AUDIO_DMA_PLAYBACK,
         .enable_dma = cs5535audio_playback_enable_dma,
@@ -417,7 +407,6 @@ int __devinit snd_cs5535audio_pcm(cs5535audio_t *cs5535au)
 					&snd_cs5535audio_capture_ops);
 
 	pcm->private_data = cs5535au;
-	pcm->private_free = snd_cs5535audio_pcm_free;
 	pcm->info_flags = 0;
 	strcpy(pcm->name, "CS5535 Audio");
 

commit 9b4ffa48ae855c8657a36014c5b0243ff69f4722
Author: Jaya Kumar <jayakumar.alsa@gmail.com>
Date:   Thu Nov 17 10:12:23 2005 +0100

    [ALSA] Add support for the CS5535 Audio device
    
    Add support for the CS5535 Audio device.  I've fixed up some errors as per
    Takashi's advice from the thread:
    
    http://lkml.org/lkml/2005/9/15/119
    
     From: Alan Cox <alan@lxorguk.ukuu.org.uk>
    
            cs5535 is a 32bit x86 only device using weird CPU features
    
    Signed-off-by: Jaya Kumar <jayakumar.alsa@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs5535audio/cs5535audio_pcm.c b/sound/pci/cs5535audio/cs5535audio_pcm.c
new file mode 100644
index 000000000000..5802ed9d57be
--- /dev/null
+++ b/sound/pci/cs5535audio/cs5535audio_pcm.c
@@ -0,0 +1,430 @@
+/*
+ * Driver for audio on multifunction CS5535 companion device
+ * Copyright (C) Jaya Kumar
+ *
+ * Based on Jaroslav Kysela and Takashi Iwai's examples.
+ * This work was sponsored by CIS(M) Sdn Bhd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * todo: add be fmt support, spdif, pm
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include <sound/asoundef.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/ac97_codec.h>
+#include "cs5535audio.h"
+
+static snd_pcm_hardware_t snd_cs5535audio_playback =
+{
+	.info =			(
+				SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_INTERLEAVED |
+		 		SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		 		SNDRV_PCM_INFO_MMAP_VALID |
+		 		SNDRV_PCM_INFO_PAUSE |
+				SNDRV_PCM_INFO_SYNC_START
+				),
+	.formats =		(
+				SNDRV_PCM_FMTBIT_S16_LE
+				),
+	.rates =		(
+				SNDRV_PCM_RATE_CONTINUOUS |
+				SNDRV_PCM_RATE_8000_48000
+				),
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(64*1024 - 16),
+	.periods_min =		1,
+	.periods_max =		CS5535AUDIO_MAX_DESCRIPTORS,
+	.fifo_size =		0,
+};
+
+static snd_pcm_hardware_t snd_cs5535audio_capture =
+{
+	.info =			(
+				SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_INTERLEAVED |
+		 		SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		 		SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_SYNC_START
+				),
+	.formats =		(
+				SNDRV_PCM_FMTBIT_S16_LE
+				),
+	.rates =		(
+				SNDRV_PCM_RATE_CONTINUOUS |
+				SNDRV_PCM_RATE_8000_48000
+				),
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(64*1024 - 16),
+	.periods_min =		1,
+	.periods_max =		CS5535AUDIO_MAX_DESCRIPTORS,
+	.fifo_size =		0,
+};
+
+static int snd_cs5535audio_playback_open(snd_pcm_substream_t *substream)
+{
+	int err;
+	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	runtime->hw = snd_cs5535audio_playback;
+	cs5535au->playback_substream = substream;
+	runtime->private_data = &(cs5535au->dmas[CS5535AUDIO_DMA_PLAYBACK]);
+	snd_pcm_set_sync(substream);
+	if ((err = snd_pcm_hw_constraint_integer(runtime,
+				SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+
+	return 0;
+}
+
+static int snd_cs5535audio_playback_close(snd_pcm_substream_t *substream)
+{
+	return 0;
+}
+
+#define CS5535AUDIO_DESC_LIST_SIZE \
+	PAGE_ALIGN(CS5535AUDIO_MAX_DESCRIPTORS * sizeof(cs5535audio_dma_desc_t))
+
+static int cs5535audio_build_dma_packets(cs5535audio_t *cs5535au,
+					cs5535audio_dma_t *dma,
+					snd_pcm_substream_t *substream,
+					unsigned int periods,
+					unsigned int period_bytes)
+{
+	unsigned int i;
+	u32 addr, desc_addr, jmpprd_addr;
+	cs5535audio_dma_desc_t *lastdesc;
+
+	if (periods > CS5535AUDIO_MAX_DESCRIPTORS)
+		return -ENOMEM;
+
+	if (dma->desc_buf.area == NULL) {
+		if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,
+					snd_dma_pci_data(cs5535au->pci),
+					CS5535AUDIO_DESC_LIST_SIZE+1,
+					&dma->desc_buf) < 0)
+			return -ENOMEM;
+		dma->period_bytes = dma->periods = 0;
+	}
+
+	if (dma->periods == periods && dma->period_bytes == period_bytes)
+		return 0;
+
+	/* the u32 cast is okay because in snd*create we succesfully told
+   	   pci alloc that we're only 32 bit capable so the uppper will be 0 */
+	addr = (u32) substream->runtime->dma_addr;
+	desc_addr = (u32) dma->desc_buf.addr;
+	for (i = 0; i < periods; i++) {
+		cs5535audio_dma_desc_t *desc =
+			&((cs5535audio_dma_desc_t *) dma->desc_buf.area)[i];
+		desc->addr = cpu_to_le32(addr);
+		desc->size = period_bytes;
+		desc->ctlreserved = PRD_EOP;
+		desc_addr += sizeof(cs5535audio_dma_desc_t);
+		addr += period_bytes;
+	}
+	/* we reserved one dummy descriptor at the end to do the PRD jump */
+	lastdesc = &((cs5535audio_dma_desc_t *) dma->desc_buf.area)[periods];
+	lastdesc->addr = cpu_to_le32((u32) dma->desc_buf.addr);
+	lastdesc->size = 0;
+	lastdesc->ctlreserved = PRD_JMP;
+	jmpprd_addr = cpu_to_le32(lastdesc->addr +
+				(sizeof(cs5535audio_dma_desc_t)*periods));
+
+	dma->period_bytes = period_bytes;
+	dma->periods = periods;
+	spin_lock_irq(&cs5535au->reg_lock);
+	dma->ops->disable_dma(cs5535au);
+	dma->ops->setup_prd(cs5535au, jmpprd_addr);
+	spin_unlock_irq(&cs5535au->reg_lock);
+	return 0;
+}
+
+static void cs5535audio_playback_enable_dma(cs5535audio_t *cs5535au)
+{
+	cs_writeb(cs5535au, ACC_BM0_CMD, BM_CTL_EN);
+}
+
+static void cs5535audio_playback_disable_dma(cs5535audio_t *cs5535au)
+{
+	cs_writeb(cs5535au, ACC_BM0_CMD, 0);
+}
+
+static void cs5535audio_playback_pause_dma(cs5535audio_t *cs5535au)
+{
+	cs_writeb(cs5535au, ACC_BM0_CMD, BM_CTL_PAUSE);
+}
+
+static void cs5535audio_playback_setup_prd(cs5535audio_t *cs5535au,
+						u32 prd_addr)
+{
+	cs_writel(cs5535au, ACC_BM0_PRD, prd_addr);
+}
+
+static u32 cs5535audio_playback_read_dma_pntr(cs5535audio_t *cs5535au)
+{
+	return cs_readl(cs5535au, ACC_BM0_PNTR);
+}
+
+static void cs5535audio_capture_enable_dma(cs5535audio_t *cs5535au)
+{
+	cs_writeb(cs5535au, ACC_BM1_CMD, BM_CTL_EN);
+}
+
+static void cs5535audio_capture_disable_dma(cs5535audio_t *cs5535au)
+{
+	cs_writeb(cs5535au, ACC_BM1_CMD, 0);
+}
+
+static void cs5535audio_capture_pause_dma(cs5535audio_t *cs5535au)
+{
+	cs_writeb(cs5535au, ACC_BM1_CMD, BM_CTL_PAUSE);
+}
+
+static void cs5535audio_capture_setup_prd(cs5535audio_t *cs5535au,
+						u32 prd_addr)
+{
+	cs_writel(cs5535au, ACC_BM1_PRD, prd_addr);
+}
+
+static u32 cs5535audio_capture_read_dma_pntr(cs5535audio_t *cs5535au)
+{
+	return cs_readl(cs5535au, ACC_BM1_PNTR);
+}
+
+static void cs5535audio_clear_dma_packets(cs5535audio_t *cs5535au,
+					cs5535audio_dma_t *dma,
+					snd_pcm_substream_t *substream)
+{
+	snd_dma_free_pages(&dma->desc_buf);
+	dma->desc_buf.area = NULL;
+}
+
+static int snd_cs5535audio_hw_params(snd_pcm_substream_t *substream,
+				 snd_pcm_hw_params_t *hw_params)
+{
+	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
+	cs5535audio_dma_t *dma = substream->runtime->private_data;
+	int err;
+
+	err = snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+	if (err < 0)
+		return err;
+	dma->buf_addr = substream->runtime->dma_addr;
+	dma->buf_bytes = params_buffer_bytes(hw_params);
+
+	err = cs5535audio_build_dma_packets(cs5535au, dma, substream,
+				       params_periods(hw_params),
+				       params_period_bytes(hw_params));
+	return err;
+}
+
+static int snd_cs5535audio_hw_free(snd_pcm_substream_t *substream)
+{
+	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
+	cs5535audio_dma_t *dma = substream->runtime->private_data;
+
+	cs5535audio_clear_dma_packets(cs5535au, dma, substream);
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int snd_cs5535audio_playback_prepare(snd_pcm_substream_t *substream)
+{
+	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
+	return snd_ac97_set_rate(cs5535au->ac97, AC97_PCM_FRONT_DAC_RATE,
+					substream->runtime->rate);
+}
+
+static int snd_cs5535audio_trigger(snd_pcm_substream_t *substream, int cmd)
+{
+	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
+	cs5535audio_dma_t *dma = substream->runtime->private_data;
+
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			spin_lock_irq(&cs5535au->reg_lock);
+			dma->ops->pause_dma(cs5535au);
+			spin_unlock_irq(&cs5535au->reg_lock);
+			break;
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			spin_lock_irq(&cs5535au->reg_lock);
+			dma->ops->enable_dma(cs5535au);
+			spin_unlock_irq(&cs5535au->reg_lock);
+			break;
+		case SNDRV_PCM_TRIGGER_START:
+			spin_lock_irq(&cs5535au->reg_lock);
+			dma->ops->enable_dma(cs5535au);
+			spin_unlock_irq(&cs5535au->reg_lock);
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+			spin_lock_irq(&cs5535au->reg_lock);
+			dma->ops->disable_dma(cs5535au);
+			spin_unlock_irq(&cs5535au->reg_lock);
+			break;
+		default:
+			snd_printk(KERN_ERR "unhandled trigger\n");
+			return -EINVAL;
+			break;
+	}
+	return 0;
+}
+
+static snd_pcm_uframes_t snd_cs5535audio_pcm_pointer(snd_pcm_substream_t
+							*substream)
+{
+	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
+	u32 curdma;
+	cs5535audio_dma_t *dma;
+
+	dma = substream->runtime->private_data;
+	curdma = dma->ops->read_dma_pntr(cs5535au);
+	if (curdma < dma->buf_addr) {
+		snd_printk(KERN_ERR "curdma=%x < %x bufaddr.\n",
+					curdma, dma->buf_addr);
+		return 0;
+	}
+	curdma -= dma->buf_addr;
+	if (curdma >= dma->buf_bytes) {
+		snd_printk(KERN_ERR "diff=%x >= %x buf_bytes.\n",
+					curdma, dma->buf_bytes);
+		return 0;
+	}
+	return bytes_to_frames(substream->runtime, curdma);
+}
+
+static int snd_cs5535audio_capture_open(snd_pcm_substream_t *substream)
+{
+	int err;
+	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	runtime->hw = snd_cs5535audio_capture;
+	cs5535au->capture_substream = substream;
+	runtime->private_data = &(cs5535au->dmas[CS5535AUDIO_DMA_CAPTURE]);
+	snd_pcm_set_sync(substream);
+	if ((err = snd_pcm_hw_constraint_integer(runtime,
+					 SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+	return 0;
+}
+
+static int snd_cs5535audio_capture_close(snd_pcm_substream_t *substream)
+{
+	return 0;
+}
+
+static int snd_cs5535audio_capture_prepare(snd_pcm_substream_t *substream)
+{
+	cs5535audio_t *cs5535au = snd_pcm_substream_chip(substream);
+	return snd_ac97_set_rate(cs5535au->ac97, AC97_PCM_LR_ADC_RATE,
+					substream->runtime->rate);
+}
+
+static snd_pcm_ops_t snd_cs5535audio_playback_ops = {
+	.open =		snd_cs5535audio_playback_open,
+	.close =	snd_cs5535audio_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_cs5535audio_hw_params,
+	.hw_free =	snd_cs5535audio_hw_free,
+	.prepare =	snd_cs5535audio_playback_prepare,
+	.trigger =	snd_cs5535audio_trigger,
+	.pointer =	snd_cs5535audio_pcm_pointer,
+};
+
+static snd_pcm_ops_t snd_cs5535audio_capture_ops = {
+	.open =		snd_cs5535audio_capture_open,
+	.close =	snd_cs5535audio_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_cs5535audio_hw_params,
+	.hw_free =	snd_cs5535audio_hw_free,
+	.prepare =	snd_cs5535audio_capture_prepare,
+	.trigger =	snd_cs5535audio_trigger,
+	.pointer =	snd_cs5535audio_pcm_pointer,
+};
+
+static void snd_cs5535audio_pcm_free(snd_pcm_t *pcm)
+{
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static cs5535audio_dma_ops_t snd_cs5535audio_playback_dma_ops = {
+        .type = CS5535AUDIO_DMA_PLAYBACK,
+        .enable_dma = cs5535audio_playback_enable_dma,
+        .disable_dma = cs5535audio_playback_disable_dma,
+        .setup_prd = cs5535audio_playback_setup_prd,
+        .pause_dma = cs5535audio_playback_pause_dma,
+        .read_dma_pntr = cs5535audio_playback_read_dma_pntr,
+};
+
+static cs5535audio_dma_ops_t snd_cs5535audio_capture_dma_ops = {
+        .type = CS5535AUDIO_DMA_CAPTURE,
+        .enable_dma = cs5535audio_capture_enable_dma,
+        .disable_dma = cs5535audio_capture_disable_dma,
+        .setup_prd = cs5535audio_capture_setup_prd,
+        .pause_dma = cs5535audio_capture_pause_dma,
+        .read_dma_pntr = cs5535audio_capture_read_dma_pntr,
+};
+
+int __devinit snd_cs5535audio_pcm(cs5535audio_t *cs5535au)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	err = snd_pcm_new(cs5535au->card, "CS5535 Audio", 0, 1, 1, &pcm);
+	if (err < 0)
+		return err;
+
+	cs5535au->dmas[CS5535AUDIO_DMA_PLAYBACK].ops =
+					&snd_cs5535audio_playback_dma_ops;
+	cs5535au->dmas[CS5535AUDIO_DMA_CAPTURE].ops =
+					&snd_cs5535audio_capture_dma_ops;
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+					&snd_cs5535audio_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+					&snd_cs5535audio_capture_ops);
+
+	pcm->private_data = cs5535au;
+	pcm->private_free = snd_cs5535audio_pcm_free;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "CS5535 Audio");
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					snd_dma_pci_data(cs5535au->pci),
+					64*1024, 128*1024);
+
+	return 0;
+}
+
