commit fb95aae6e67c4e319a24b3eea32032d4246a5335
Merge: bd2463ac7d7e 90fb04f890bc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 28 16:26:57 2020 -0800

    Merge tag 'sound-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "As the diffstat shows we've had again a lot of works done for this
      cycle: the majority of changes are the continued componentization and
      code refactoring in ASoC, the tree-wide PCM API updates and cleanups
      and SOF updates while a few ASoC driver updates are seen, too.
    
      Here we go, some highlights:
    
      Core:
       - Finally y2038 support landed to ALSA ABI; some ioctls have been
         extended and lots of tricks were applied
       - Applying the new managed PCM buffer API to all drivers; the API
         itself was already merged in 5.5
       - The already deprecated dimension support in ALSA control API is
         dropped completely now
       - Verification of ALSA control elements to catch API misuses
    
      ASoC:
       - Further code refactorings and moving things to the component level
       - Lots of updates and improvements on SOF / Intel drivers; now
         including common HDMI driver and SoundWire support
       - New driver support for Ingenic JZ4770, Mediatek MT6660, Qualcomm
         WCD934x and WSA881x, and Realtek RT700, RT711, RT715, RT1011,
         RT1015 and RT1308
    
      HD-audio:
       - Improved ring-buffer communications using waitqueue
       - Drop the superfluous buffer preallocation on x86
    
      Others:
       - Many code cleanups, mostly constifications over the whole tree
       - USB-audio: quirks for MOTU, Corsair Virtuoso, Line6 Helix
       - FireWire: code refactoring for oxfw and dice drivers"
    
    * tag 'sound-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (638 commits)
      ALSA: usb-audio: add quirks for Line6 Helix devices fw>=2.82
      ALSA: hda: Add Clevo W65_67SB the power_save blacklist
      ASoC: soc-core: remove null_snd_soc_ops
      ASoC: soc-pcm: add soc_rtd_trigger()
      ASoC: soc-pcm: add soc_rtd_hw_free()
      ASoC: soc-pcm: add soc_rtd_hw_params()
      ASoC: soc-pcm: add soc_rtd_prepare()
      ASoC: soc-pcm: add soc_rtd_shutdown()
      ASoC: soc-pcm: add soc_rtd_startup()
      ASoC: rt1015: add rt1015 amplifier driver
      ASoC: madera: Correct some kernel doc
      ASoC: topology: fix soc_tplg_fe_link_create() - link->dobj initialization order
      ASoC: Intel: skl_hda_dsp_common: Fix global-out-of-bounds bug
      ASoC: madera: Correct DMIC only input hook ups
      ALSA: cs46xx: fix spelling mistake "to" -> "too"
      ALSA: hda - Add docking station support for Lenovo Thinkpad T420s
      ASoC: Add MediaTek MT6660 Speaker Amp Driver
      ASoC: dt-bindings: rt5645: add suppliers
      ASoC: max98090: fix deadlock in max98090_dapm_put_enum_double()
      ASoC: dapm: add snd_soc_dapm_put_enum_double_locked
      ...

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 64ab55772eae..db6033074ace 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1619,7 +1619,7 @@ snd_rme96_create(struct rme96 *rme96)
 		return err;
 	rme96->port = pci_resource_start(rme96->pci, 0);
 
-	rme96->iobase = ioremap_nocache(rme96->port, RME96_IO_SIZE);
+	rme96->iobase = ioremap(rme96->port, RME96_IO_SIZE);
 	if (!rme96->iobase) {
 		dev_err(rme96->card->dev,
 			"unable to remap memory region 0x%lx-0x%lx\n",

commit b4e5e70775546480035e156b40040e5d0d4264d1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:53 2020 +0100

    ALSA: pci: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-38-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 537381632be7..db576b7e5d5b 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2253,7 +2253,7 @@ snd_rme96_dac_volume_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_valu
         return change;
 }
 
-static struct snd_kcontrol_new snd_rme96_controls[] = {
+static const struct snd_kcontrol_new snd_rme96_controls[] = {
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),

commit 5fcf46bc8333409018f29966d736034c587d7aa6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:31 2019 +0100

    ALSA: rme96: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-33-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index f52195791a8b..537381632be7 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1629,6 +1629,7 @@ snd_rme96_create(struct rme96 *rme96)
 		return -EBUSY;
 	}
 	rme96->irq = pci->irq;
+	rme96->card->sync_irq = rme96->irq;
 
 	/* read the card's revision number */
 	pci_read_config_byte(pci, 8, &rme96->rev);	

commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 64ab55772eae..f52195791a8b 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1508,7 +1508,6 @@ snd_rme96_capture_pointer(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_rme96_playback_spdif_ops = {
 	.open =		snd_rme96_playback_spdif_open,
 	.close =	snd_rme96_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme96_playback_hw_params,
 	.prepare =	snd_rme96_playback_prepare,
 	.trigger =	snd_rme96_playback_trigger,
@@ -1522,7 +1521,6 @@ static const struct snd_pcm_ops snd_rme96_playback_spdif_ops = {
 static const struct snd_pcm_ops snd_rme96_capture_spdif_ops = {
 	.open =		snd_rme96_capture_spdif_open,
 	.close =	snd_rme96_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme96_capture_hw_params,
 	.prepare =	snd_rme96_capture_prepare,
 	.trigger =	snd_rme96_capture_trigger,
@@ -1535,7 +1533,6 @@ static const struct snd_pcm_ops snd_rme96_capture_spdif_ops = {
 static const struct snd_pcm_ops snd_rme96_playback_adat_ops = {
 	.open =		snd_rme96_playback_adat_open,
 	.close =	snd_rme96_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme96_playback_hw_params,
 	.prepare =	snd_rme96_playback_prepare,
 	.trigger =	snd_rme96_playback_trigger,
@@ -1549,7 +1546,6 @@ static const struct snd_pcm_ops snd_rme96_playback_adat_ops = {
 static const struct snd_pcm_ops snd_rme96_capture_adat_ops = {
 	.open =		snd_rme96_capture_adat_open,
 	.close =	snd_rme96_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.hw_params =	snd_rme96_capture_hw_params,
 	.prepare =	snd_rme96_capture_prepare,
 	.trigger =	snd_rme96_capture_trigger,

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 42c6b5e09072..64ab55772eae 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *   ALSA driver for RME Digi96, Digi96/8 and Digi96/8 PRO/PAD/PST audio
  *   interfaces 
@@ -6,21 +7,6 @@
  *    
  *      Thanks to Henk Hesselink <henk@anda.nl> for the analog volume control
  *      code.
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */      
 
 #include <linux/delay.h>

commit 47f2769b4b2e267cba135fc19c89c32d202b1415
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:01:39 2019 +0100

    ALSA: pci: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index c56702e6cb60..42c6b5e09072 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1868,10 +1868,7 @@ snd_rme96_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer
 
 static void snd_rme96_proc_init(struct rme96 *rme96)
 {
-	struct snd_info_entry *entry;
-
-	if (! snd_card_proc_new(rme96->card, "rme96", &entry))
-		snd_info_set_text_ops(entry, rme96, snd_rme96_proc_read);
+	snd_card_ro_proc_new(rme96->card, "rme96", rme96, snd_rme96_proc_read);
 }
 
 /*

commit 17bc4815de586d001c82d0ddf75247283c3f002a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:02:51 2019 +0100

    ALSA: pci: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index dcfa4d7a73e2..c56702e6cb60 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2388,8 +2388,6 @@ static int rme96_suspend(struct device *dev)
 	struct rme96 *rme96 = card->private_data;
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
-	snd_pcm_suspend(rme96->playback_substream);
-	snd_pcm_suspend(rme96->capture_substream);
 
 	/* save capture & playback pointers */
 	rme96->playback_pointer = readl(rme96->iobase + RME96_IO_GET_PLAY_POS)

commit dee49895b197936c02d27d651e58c90bac18f452
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:28 2017 +0530

    ALSA: pci: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index b488d74c3b99..dcfa4d7a73e2 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -384,7 +384,7 @@ snd_rme96_capture_copy_kernel(struct snd_pcm_substream *substream,
 /*
  * Digital output capabilities (S/PDIF)
  */
-static struct snd_pcm_hardware snd_rme96_playback_spdif_info =
+static const struct snd_pcm_hardware snd_rme96_playback_spdif_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
@@ -415,7 +415,7 @@ static struct snd_pcm_hardware snd_rme96_playback_spdif_info =
 /*
  * Digital input capabilities (S/PDIF)
  */
-static struct snd_pcm_hardware snd_rme96_capture_spdif_info =
+static const struct snd_pcm_hardware snd_rme96_capture_spdif_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
@@ -446,7 +446,7 @@ static struct snd_pcm_hardware snd_rme96_capture_spdif_info =
 /*
  * Digital output capabilities (ADAT)
  */
-static struct snd_pcm_hardware snd_rme96_playback_adat_info =
+static const struct snd_pcm_hardware snd_rme96_playback_adat_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
@@ -473,7 +473,7 @@ static struct snd_pcm_hardware snd_rme96_playback_adat_info =
 /*
  * Digital input capabilities (ADAT)
  */
-static struct snd_pcm_hardware snd_rme96_capture_adat_info =
+static const struct snd_pcm_hardware snd_rme96_capture_adat_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |

commit 2cb98d010fdc7a545856baf32bce096fa431d250
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Aug 12 15:18:56 2017 +0200

    ALSA: rme96: Adjust five checks for null pointers
    
    The script “checkpatch.pl” pointed information out like the following.
    
    Comparison to NULL could be written …
    
    Thus fix the affected source code places.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 0cdfd53b7796..b488d74c3b99 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1199,7 +1199,7 @@ snd_rme96_playback_spdif_open(struct snd_pcm_substream *substream)
 
 	snd_pcm_set_sync(substream);
 	spin_lock_irq(&rme96->lock);	
-        if (rme96->playback_substream != NULL) {
+	if (rme96->playback_substream) {
 		spin_unlock_irq(&rme96->lock);
                 return -EBUSY;
         }
@@ -1248,7 +1248,7 @@ snd_rme96_capture_spdif_open(struct snd_pcm_substream *substream)
         }
         
 	spin_lock_irq(&rme96->lock);
-        if (rme96->capture_substream != NULL) {
+	if (rme96->capture_substream) {
 		spin_unlock_irq(&rme96->lock);
                 return -EBUSY;
         }
@@ -1268,7 +1268,7 @@ snd_rme96_playback_adat_open(struct snd_pcm_substream *substream)
 	
 	snd_pcm_set_sync(substream);
 	spin_lock_irq(&rme96->lock);	
-        if (rme96->playback_substream != NULL) {
+	if (rme96->playback_substream) {
 		spin_unlock_irq(&rme96->lock);
                 return -EBUSY;
         }
@@ -1315,7 +1315,7 @@ snd_rme96_capture_adat_open(struct snd_pcm_substream *substream)
         }
         
 	spin_lock_irq(&rme96->lock);	
-        if (rme96->capture_substream != NULL) {
+	if (rme96->capture_substream) {
 		spin_unlock_irq(&rme96->lock);
                 return -EBUSY;
         }
@@ -1578,9 +1578,9 @@ snd_rme96_free(void *private_data)
 {
 	struct rme96 *rme96 = (struct rme96 *)private_data;
 
-	if (rme96 == NULL) {
+	if (!rme96)
 	        return;
-	}
+
 	if (rme96->irq >= 0) {
 		snd_rme96_trigger(rme96, RME96_STOP_BOTH);
 		rme96->areg &= ~RME96_AR_DAC_EN;

commit d72a8010ae60551ad14f1385e637be101cf741b5
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Aug 12 14:50:33 2017 +0200

    ALSA: rme96: Use common error handling code in snd_rme96_probe()
    
    Add a jump target so that a bit of exception handling can be better reused
    at the end of this function.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 82e8c78e48ca..0cdfd53b7796 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2481,21 +2481,20 @@ snd_rme96_probe(struct pci_dev *pci,
 	rme96 = card->private_data;
 	rme96->card = card;
 	rme96->pci = pci;
-	if ((err = snd_rme96_create(rme96)) < 0) {
-		snd_card_free(card);
-		return err;
-	}
+	err = snd_rme96_create(rme96);
+	if (err)
+		goto free_card;
 	
 #ifdef CONFIG_PM_SLEEP
 	rme96->playback_suspend_buffer = vmalloc(RME96_BUFFER_SIZE);
 	if (!rme96->playback_suspend_buffer) {
-		snd_card_free(card);
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto free_card;
 	}
 	rme96->capture_suspend_buffer = vmalloc(RME96_BUFFER_SIZE);
 	if (!rme96->capture_suspend_buffer) {
-		snd_card_free(card);
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto free_card;
 	}
 #endif
 
@@ -2521,14 +2520,16 @@ snd_rme96_probe(struct pci_dev *pci,
 	}
 	sprintf(card->longname, "%s at 0x%lx, irq %d", card->shortname,
 		rme96->port, rme96->irq);
-	
-	if ((err = snd_card_register(card)) < 0) {
-		snd_card_free(card);
-		return err;	
-	}
+	err = snd_card_register(card);
+	if (err)
+		goto free_card;
+
 	pci_set_drvdata(pci, card);
 	dev++;
 	return 0;
+free_card:
+	snd_card_free(card);
+	return err;
 }
 
 static void snd_rme96_remove(struct pci_dev *pci)

commit 1b2ff0c0c4803faa530cc1744cb0760f0703b416
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Aug 12 14:24:41 2017 +0200

    ALSA: rme96: Delete two error messages for a failed memory allocation in snd_rme96_probe()
    
    Omit extra messages for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 2e19ba55e754..82e8c78e48ca 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2489,15 +2489,11 @@ snd_rme96_probe(struct pci_dev *pci,
 #ifdef CONFIG_PM_SLEEP
 	rme96->playback_suspend_buffer = vmalloc(RME96_BUFFER_SIZE);
 	if (!rme96->playback_suspend_buffer) {
-		dev_err(card->dev,
-			   "Failed to allocate playback suspend buffer!\n");
 		snd_card_free(card);
 		return -ENOMEM;
 	}
 	rme96->capture_suspend_buffer = vmalloc(RME96_BUFFER_SIZE);
 	if (!rme96->capture_suspend_buffer) {
-		dev_err(card->dev,
-			   "Failed to allocate capture suspend buffer!\n");
 		snd_card_free(card);
 		return -ENOMEM;
 	}

commit 84e7b99865329394177db0d2a506c22b1c02dea1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 7 14:22:10 2017 +0200

    ALSA: rme96: Constify hw_constraints
    
    snd_pcm_hw_constraint_list(), *_ratnums() and *_ratdens() receive the
    const pointers.  Constify the corresponding static objects for better
    hardening.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 24f1349a8e1b..2e19ba55e754 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1163,9 +1163,9 @@ snd_rme96_interrupt(int irq,
 	return IRQ_HANDLED;
 }
 
-static unsigned int period_bytes[] = { RME96_SMALL_BLOCK_SIZE, RME96_LARGE_BLOCK_SIZE };
+static const unsigned int period_bytes[] = { RME96_SMALL_BLOCK_SIZE, RME96_LARGE_BLOCK_SIZE };
 
-static struct snd_pcm_hw_constraint_list hw_constraints_period_bytes = {
+static const struct snd_pcm_hw_constraint_list hw_constraints_period_bytes = {
 	.count = ARRAY_SIZE(period_bytes),
 	.list = period_bytes,
 	.mask = 0

commit 53945f5b8ae550d8c6f7ac8ed9b1e496778fad45
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 10 20:30:34 2017 +0200

    ALSA: rme96: Convert to the new PCM ops
    
    Replace the copy and the silence ops with the new PCM ops.
    The conversion is straightforward with standard helper functions, and
    now we can drop the bytes <-> frames conversions in callbacks.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 05b9da30990d..24f1349a8e1b 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -327,13 +327,10 @@ snd_rme96_capture_ptr(struct rme96 *rme96)
 
 static int
 snd_rme96_playback_silence(struct snd_pcm_substream *substream,
-			   int channel, /* not used (interleaved data) */
-			   snd_pcm_uframes_t pos,
-			   snd_pcm_uframes_t count)
+			   int channel, unsigned long pos, unsigned long count)
 {
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
-	count <<= rme96->playback_frlog;
-	pos <<= rme96->playback_frlog;
+
 	memset_io(rme96->iobase + RME96_IO_PLAY_BUFFER + pos,
 		  0, count);
 	return 0;
@@ -341,32 +338,49 @@ snd_rme96_playback_silence(struct snd_pcm_substream *substream,
 
 static int
 snd_rme96_playback_copy(struct snd_pcm_substream *substream,
-			int channel, /* not used (interleaved data) */
-			snd_pcm_uframes_t pos,
-			void __user *src,
-			snd_pcm_uframes_t count)
+			int channel, unsigned long pos,
+			void __user *src, unsigned long count)
 {
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
-	count <<= rme96->playback_frlog;
-	pos <<= rme96->playback_frlog;
-	return copy_from_user_toio(rme96->iobase + RME96_IO_PLAY_BUFFER + pos, src,
-				   count);
+
+	return copy_from_user_toio(rme96->iobase + RME96_IO_PLAY_BUFFER + pos,
+				   src, count);
+}
+
+static int
+snd_rme96_playback_copy_kernel(struct snd_pcm_substream *substream,
+			       int channel, unsigned long pos,
+			       void *src, unsigned long count)
+{
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
+
+	memcpy_toio(rme96->iobase + RME96_IO_PLAY_BUFFER + pos, src, count);
+	return 0;
 }
 
 static int
 snd_rme96_capture_copy(struct snd_pcm_substream *substream,
-		       int channel, /* not used (interleaved data) */
-		       snd_pcm_uframes_t pos,
-		       void __user *dst,
-		       snd_pcm_uframes_t count)
+		       int channel, unsigned long pos,
+		       void __user *dst, unsigned long count)
 {
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
-	count <<= rme96->capture_frlog;
-	pos <<= rme96->capture_frlog;
-	return copy_to_user_fromio(dst, rme96->iobase + RME96_IO_REC_BUFFER + pos,
+
+	return copy_to_user_fromio(dst,
+				   rme96->iobase + RME96_IO_REC_BUFFER + pos,
 				   count);
 }
 
+static int
+snd_rme96_capture_copy_kernel(struct snd_pcm_substream *substream,
+			      int channel, unsigned long pos,
+			      void *dst, unsigned long count)
+{
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
+
+	memcpy_fromio(dst, rme96->iobase + RME96_IO_REC_BUFFER + pos, count);
+	return 0;
+}
+
 /*
  * Digital output capabilities (S/PDIF)
  */
@@ -1513,8 +1527,9 @@ static const struct snd_pcm_ops snd_rme96_playback_spdif_ops = {
 	.prepare =	snd_rme96_playback_prepare,
 	.trigger =	snd_rme96_playback_trigger,
 	.pointer =	snd_rme96_playback_pointer,
-	.copy =		snd_rme96_playback_copy,
-	.silence =	snd_rme96_playback_silence,
+	.copy_user =	snd_rme96_playback_copy,
+	.copy_kernel =	snd_rme96_playback_copy_kernel,
+	.fill_silence =	snd_rme96_playback_silence,
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
@@ -1526,7 +1541,8 @@ static const struct snd_pcm_ops snd_rme96_capture_spdif_ops = {
 	.prepare =	snd_rme96_capture_prepare,
 	.trigger =	snd_rme96_capture_trigger,
 	.pointer =	snd_rme96_capture_pointer,
-	.copy =		snd_rme96_capture_copy,
+	.copy_user =	snd_rme96_capture_copy,
+	.copy_kernel =	snd_rme96_capture_copy_kernel,
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
@@ -1538,8 +1554,9 @@ static const struct snd_pcm_ops snd_rme96_playback_adat_ops = {
 	.prepare =	snd_rme96_playback_prepare,
 	.trigger =	snd_rme96_playback_trigger,
 	.pointer =	snd_rme96_playback_pointer,
-	.copy =		snd_rme96_playback_copy,
-	.silence =	snd_rme96_playback_silence,
+	.copy_user =	snd_rme96_playback_copy,
+	.copy_kernel =	snd_rme96_playback_copy_kernel,
+	.fill_silence =	snd_rme96_playback_silence,
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
@@ -1551,7 +1568,8 @@ static const struct snd_pcm_ops snd_rme96_capture_adat_ops = {
 	.prepare =	snd_rme96_capture_prepare,
 	.trigger =	snd_rme96_capture_trigger,
 	.pointer =	snd_rme96_capture_pointer,
-	.copy =		snd_rme96_capture_copy,
+	.copy_user =	snd_rme96_capture_copy,
+	.copy_kernel =	snd_rme96_capture_copy_kernel,
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 41c31db65039..05b9da30990d 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1505,7 +1505,7 @@ snd_rme96_capture_pointer(struct snd_pcm_substream *substream)
 	return snd_rme96_capture_ptr(rme96);
 }
 
-static struct snd_pcm_ops snd_rme96_playback_spdif_ops = {
+static const struct snd_pcm_ops snd_rme96_playback_spdif_ops = {
 	.open =		snd_rme96_playback_spdif_open,
 	.close =	snd_rme96_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1518,7 +1518,7 @@ static struct snd_pcm_ops snd_rme96_playback_spdif_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static struct snd_pcm_ops snd_rme96_capture_spdif_ops = {
+static const struct snd_pcm_ops snd_rme96_capture_spdif_ops = {
 	.open =		snd_rme96_capture_spdif_open,
 	.close =	snd_rme96_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1530,7 +1530,7 @@ static struct snd_pcm_ops snd_rme96_capture_spdif_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static struct snd_pcm_ops snd_rme96_playback_adat_ops = {
+static const struct snd_pcm_ops snd_rme96_playback_adat_ops = {
 	.open =		snd_rme96_playback_adat_open,
 	.close =	snd_rme96_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1543,7 +1543,7 @@ static struct snd_pcm_ops snd_rme96_playback_adat_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static struct snd_pcm_ops snd_rme96_capture_adat_ops = {
+static const struct snd_pcm_ops snd_rme96_capture_adat_ops = {
 	.open =		snd_rme96_capture_adat_open,
 	.close =	snd_rme96_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,

commit a74a821624c0c75388a193337babd17a8c02c740
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Dec 4 16:44:24 2015 +0100

    ALSA: rme96: Fix unexpected volume reset after rate changes
    
    rme96 driver needs to reset DAC depending on the sample rate, and this
    results in resetting to the max volume suddenly.  It's because of the
    missing call of snd_rme96_apply_dac_volume().
    
    However, calling this function right after the DAC reset still may not
    work, and we need some delay before this call.  Since the DAC reset
    and the procedure after that are performed in the spinlock, we delay
    the DAC volume restore at the end after the spinlock.
    
    Reported-and-tested-by: Sylvain LABOISNE <maeda1@free.fr>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 714df906249e..41c31db65039 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -741,10 +741,11 @@ snd_rme96_playback_setrate(struct rme96 *rme96,
 	{
 		/* change to/from double-speed: reset the DAC (if available) */
 		snd_rme96_reset_dac(rme96);
+		return 1; /* need to restore volume */
 	} else {
 		writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+		return 0;
 	}
-	return 0;
 }
 
 static int
@@ -980,6 +981,7 @@ snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err, rate, dummy;
+	bool apply_dac_volume = false;
 
 	runtime->dma_area = (void __force *)(rme96->iobase +
 					     RME96_IO_PLAY_BUFFER);
@@ -993,24 +995,26 @@ snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,
 	{
                 /* slave clock */
                 if ((int)params_rate(params) != rate) {
-			spin_unlock_irq(&rme96->lock);
-			return -EIO;                    
-                }
-	} else if ((err = snd_rme96_playback_setrate(rme96, params_rate(params))) < 0) {
-		spin_unlock_irq(&rme96->lock);
-		return err;
-	}
-	if ((err = snd_rme96_playback_setformat(rme96, params_format(params))) < 0) {
-		spin_unlock_irq(&rme96->lock);
-		return err;
+			err = -EIO;
+			goto error;
+		}
+	} else {
+		err = snd_rme96_playback_setrate(rme96, params_rate(params));
+		if (err < 0)
+			goto error;
+		apply_dac_volume = err > 0; /* need to restore volume later? */
 	}
+
+	err = snd_rme96_playback_setformat(rme96, params_format(params));
+	if (err < 0)
+		goto error;
 	snd_rme96_setframelog(rme96, params_channels(params), 1);
 	if (rme96->capture_periodsize != 0) {
 		if (params_period_size(params) << rme96->playback_frlog !=
 		    rme96->capture_periodsize)
 		{
-			spin_unlock_irq(&rme96->lock);
-			return -EBUSY;
+			err = -EBUSY;
+			goto error;
 		}
 	}
 	rme96->playback_periodsize =
@@ -1021,9 +1025,16 @@ snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,
 		rme96->wcreg &= ~(RME96_WCR_PRO | RME96_WCR_DOLBY | RME96_WCR_EMP);
 		writel(rme96->wcreg |= rme96->wcreg_spdif_stream, rme96->iobase + RME96_IO_CONTROL_REGISTER);
 	}
+
+	err = 0;
+ error:
 	spin_unlock_irq(&rme96->lock);
-		
-	return 0;
+	if (apply_dac_volume) {
+		usleep_range(3000, 10000);
+		snd_rme96_apply_dac_volume(rme96);
+	}
+
+	return err;
 }
 
 static int

commit 1a8e41efe3f403678cd6099fea8a05af7391de4c
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Oct 18 15:39:20 2015 +0200

    ALSA: rme96: Use snd_pcm_hw_constraint_single()
    
    Use the new snd_pcm_hw_constraint_single() helper function instead of
    calling snd_pcm_hw_constraint_minmax() with the same value for min and max
    to install a constraint that limits the possible configuration values to a
    single value. Using snd_pcm_hw_constraint_single() makes the indented
    result clearer.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 2306ccf7281e..714df906249e 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1152,13 +1152,13 @@ rme96_set_buffer_size_constraint(struct rme96 *rme96,
 {
 	unsigned int size;
 
-	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
-				     RME96_BUFFER_SIZE, RME96_BUFFER_SIZE);
+	snd_pcm_hw_constraint_single(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
+				     RME96_BUFFER_SIZE);
 	if ((size = rme96->playback_periodsize) != 0 ||
 	    (size = rme96->capture_periodsize) != 0)
-		snd_pcm_hw_constraint_minmax(runtime,
+		snd_pcm_hw_constraint_single(runtime,
 					     SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
-					     size, size);
+					     size);
 	else
 		snd_pcm_hw_constraint_list(runtime, 0,
 					   SNDRV_PCM_HW_PARAM_PERIOD_BYTES,

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 236ac1d48184..2306ccf7281e 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -29,6 +29,7 @@
 #include <linux/pci.h>
 #include <linux/module.h>
 #include <linux/vmalloc.h>
+#include <linux/io.h>
 
 #include <sound/core.h>
 #include <sound/info.h>
@@ -38,8 +39,6 @@
 #include <sound/asoundef.h>
 #include <sound/initval.h>
 
-#include <asm/io.h>
-
 /* note, two last pcis should be equal, it is not a bug */
 
 MODULE_AUTHOR("Anders Torger <torger@ludd.luth.se>");

commit 6c869d301bda3f672f001e2c9fcb01685000fc83
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 12 16:56:51 2015 +0100

    ALSA: rme*: Use snd_pcm_format_t
    
    Fix sparse warnings below by using snd_pcm_format_t properly:
       sound/pci/rme32.c:682:60: sparse: incorrect type in argument 2 (different base types)
      sound/pci/rme96.c:1006:69: sparse: incorrect type in argument 2 (different base types)
       .....
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index e33e79eadf83..236ac1d48184 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -922,8 +922,7 @@ snd_rme96_setframelog(struct rme96 *rme96,
 }
 
 static int
-snd_rme96_playback_setformat(struct rme96 *rme96,
-			     int format)
+snd_rme96_playback_setformat(struct rme96 *rme96, snd_pcm_format_t format)
 {
 	switch (format) {
 	case SNDRV_PCM_FORMAT_S16_LE:
@@ -940,8 +939,7 @@ snd_rme96_playback_setformat(struct rme96 *rme96,
 }
 
 static int
-snd_rme96_capture_setformat(struct rme96 *rme96,
-			    int format)
+snd_rme96_capture_setformat(struct rme96 *rme96, snd_pcm_format_t format)
 {
 	switch (format) {
 	case SNDRV_PCM_FORMAT_S16_LE:

commit a0044463da8a20052b23eb2cd38edbe3e611942e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 8 12:49:59 2015 +0100

    ALSA: rme96: Simplify PM callbacks
    
    This is a similar cleanup like the commit [3db084fd0af5: ALSA: fm801:
    PCI core handles power state for us].
    
    Since pci_set_power_state(), pci_save_state() and pci_restore_state()
    are already done in the PCI core side, so we don't need to it doubly.
    
    Also, pci_enable_device(), pci_disable_device() and pci_set_master()
    calls in PM callbacks are superfluous nowadays, too, so get rid of
    them as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 2f1a85185a16..e33e79eadf83 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2358,7 +2358,6 @@ snd_rme96_create_switches(struct snd_card *card,
 
 static int rme96_suspend(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct rme96 *rme96 = card->private_data;
 
@@ -2381,26 +2380,14 @@ static int rme96_suspend(struct device *dev)
 	/* disable the DAC  */
 	rme96->areg &= ~RME96_AR_DAC_EN;
 	writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
-
-	pci_disable_device(pci);
-	pci_save_state(pci);
-
 	return 0;
 }
 
 static int rme96_resume(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct rme96 *rme96 = card->private_data;
 
-	pci_restore_state(pci);
-	if (pci_enable_device(pci) < 0) {
-		dev_err(dev, "pci_enable_device failed, disabling device\n");
-		snd_card_disconnect(card);
-		return -EIO;
-	}
-
 	/* reset playback and record buffer pointers */
 	writel(0, rme96->iobase + RME96_IO_SET_PLAY_POS
 		  + rme96->playback_pointer);

commit 9c30d46a0fb3b294faf1226025071d6e802a8c36
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 20 18:19:23 2014 +0200

    ALSA: rme96: Use snd_ctl_enum_info()
    
    ... and reduce the open codes.  Also add missing const to text arrays.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 5a395c87c6fc..2f1a85185a16 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1884,39 +1884,38 @@ snd_rme96_put_loopback_control(struct snd_kcontrol *kcontrol, struct snd_ctl_ele
 static int
 snd_rme96_info_inputtype_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	static char *_texts[5] = { "Optical", "Coaxial", "Internal", "XLR", "Analog" };
+	static const char * const _texts[5] = {
+		"Optical", "Coaxial", "Internal", "XLR", "Analog"
+	};
 	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
-	char *texts[5] = { _texts[0], _texts[1], _texts[2], _texts[3], _texts[4] };
+	const char *texts[5] = {
+		_texts[0], _texts[1], _texts[2], _texts[3], _texts[4]
+	};
+	int num_items;
 	
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
 	switch (rme96->pci->device) {
 	case PCI_DEVICE_ID_RME_DIGI96:
 	case PCI_DEVICE_ID_RME_DIGI96_8:
-		uinfo->value.enumerated.items = 3;
+		num_items = 3;
 		break;
 	case PCI_DEVICE_ID_RME_DIGI96_8_PRO:
-		uinfo->value.enumerated.items = 4;
+		num_items = 4;
 		break;
 	case PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST:
 		if (rme96->rev > 4) {
 			/* PST */
-			uinfo->value.enumerated.items = 4;
+			num_items = 4;
 			texts[3] = _texts[4]; /* Analog instead of XLR */
 		} else {
 			/* PAD */
-			uinfo->value.enumerated.items = 5;
+			num_items = 5;
 		}
 		break;
 	default:
 		snd_BUG();
-		break;
-	}
-	if (uinfo->value.enumerated.item > uinfo->value.enumerated.items - 1) {
-		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
+		return -EINVAL;
 	}
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1, num_items, texts);
 }
 static int
 snd_rme96_get_inputtype_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
@@ -2002,16 +2001,9 @@ snd_rme96_put_inputtype_control(struct snd_kcontrol *kcontrol, struct snd_ctl_el
 static int
 snd_rme96_info_clockmode_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[3] = { "AutoSync", "Internal", "Word" };
+	static const char * const texts[3] = { "AutoSync", "Internal", "Word" };
 	
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 3;
-	if (uinfo->value.enumerated.item > 2) {
-		uinfo->value.enumerated.item = 2;
-	}
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1, 3, texts);
 }
 static int
 snd_rme96_get_clockmode_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
@@ -2041,16 +2033,11 @@ snd_rme96_put_clockmode_control(struct snd_kcontrol *kcontrol, struct snd_ctl_el
 static int
 snd_rme96_info_attenuation_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[4] = { "0 dB", "-6 dB", "-12 dB", "-18 dB" };
+	static const char * const texts[4] = {
+		"0 dB", "-6 dB", "-12 dB", "-18 dB"
+	};
 	
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 4;
-	if (uinfo->value.enumerated.item > 3) {
-		uinfo->value.enumerated.item = 3;
-	}
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1, 4, texts);
 }
 static int
 snd_rme96_get_attenuation_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
@@ -2081,16 +2068,9 @@ snd_rme96_put_attenuation_control(struct snd_kcontrol *kcontrol, struct snd_ctl_
 static int
 snd_rme96_info_montracks_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[4] = { "1+2", "3+4", "5+6", "7+8" };
+	static const char * const texts[4] = { "1+2", "3+4", "5+6", "7+8" };
 	
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 4;
-	if (uinfo->value.enumerated.item > 3) {
-		uinfo->value.enumerated.item = 3;
-	}
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1, 4, texts);
 }
 static int
 snd_rme96_get_montracks_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 76169929770d..5a395c87c6fc 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -263,7 +263,7 @@ struct rme96 {
 	struct snd_kcontrol   *spdif_ctl;
 };
 
-static DEFINE_PCI_DEVICE_TABLE(snd_rme96_ids) = {
+static const struct pci_device_id snd_rme96_ids[] = {
 	{ PCI_VDEVICE(XILINX, PCI_DEVICE_ID_RME_DIGI96), 0, },
 	{ PCI_VDEVICE(XILINX, PCI_DEVICE_ID_RME_DIGI96_8), 0, },
 	{ PCI_VDEVICE(XILINX, PCI_DEVICE_ID_RME_DIGI96_8_PRO), 0, },

commit 342cd93439501f8b8f7e150ad23fb9f24d6b8920
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 15:03:18 2014 +0100

    ALSA: rme96: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index f5014a8e69ad..76169929770d 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1609,13 +1609,15 @@ snd_rme96_create(struct rme96 *rme96)
 
 	rme96->iobase = ioremap_nocache(rme96->port, RME96_IO_SIZE);
 	if (!rme96->iobase) {
-		snd_printk(KERN_ERR "unable to remap memory region 0x%lx-0x%lx\n", rme96->port, rme96->port + RME96_IO_SIZE - 1);
+		dev_err(rme96->card->dev,
+			"unable to remap memory region 0x%lx-0x%lx\n",
+			rme96->port, rme96->port + RME96_IO_SIZE - 1);
 		return -ENOMEM;
 	}
 
 	if (request_irq(pci->irq, snd_rme96_interrupt, IRQF_SHARED,
 			KBUILD_MODNAME, rme96)) {
-		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		dev_err(rme96->card->dev, "unable to grab IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}
 	rme96->irq = pci->irq;
@@ -2414,7 +2416,7 @@ static int rme96_resume(struct device *dev)
 
 	pci_restore_state(pci);
 	if (pci_enable_device(pci) < 0) {
-		printk(KERN_ERR "rme96: pci_enable_device failed, disabling device\n");
+		dev_err(dev, "pci_enable_device failed, disabling device\n");
 		snd_card_disconnect(card);
 		return -EIO;
 	}
@@ -2494,14 +2496,14 @@ snd_rme96_probe(struct pci_dev *pci,
 #ifdef CONFIG_PM_SLEEP
 	rme96->playback_suspend_buffer = vmalloc(RME96_BUFFER_SIZE);
 	if (!rme96->playback_suspend_buffer) {
-		snd_printk(KERN_ERR
+		dev_err(card->dev,
 			   "Failed to allocate playback suspend buffer!\n");
 		snd_card_free(card);
 		return -ENOMEM;
 	}
 	rme96->capture_suspend_buffer = vmalloc(RME96_BUFFER_SIZE);
 	if (!rme96->capture_suspend_buffer) {
-		snd_printk(KERN_ERR
+		dev_err(card->dev,
 			   "Failed to allocate capture suspend buffer!\n");
 		snd_card_free(card);
 		return -ENOMEM;

commit a932be91f2200cfea8bbea2d71039c715eedca2a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 15:01:15 2014 +0100

    ALSA: rme96: Convert to the new pm_ops
    
    This driver slipped from the last rewrite.  Just convert to the new
    standard pm ops.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 00d46116e04a..f5014a8e69ad 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -240,7 +240,7 @@ struct rme96 {
 
 	u8 rev; /* card revision number */
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	u32 playback_pointer;
 	u32 capture_pointer;
 	void *playback_suspend_buffer;
@@ -1570,7 +1570,7 @@ snd_rme96_free(void *private_data)
 		pci_release_regions(rme96->pci);
 		rme96->port = 0;
 	}
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	vfree(rme96->playback_suspend_buffer);
 	vfree(rme96->capture_suspend_buffer);
 #endif
@@ -2372,13 +2372,12 @@ snd_rme96_create_switches(struct snd_card *card,
  * Card initialisation
  */
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 
-static int
-snd_rme96_suspend(struct pci_dev *pci,
-		  pm_message_t state)
+static int rme96_suspend(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct rme96 *rme96 = card->private_data;
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
@@ -2407,10 +2406,10 @@ snd_rme96_suspend(struct pci_dev *pci,
 	return 0;
 }
 
-static int
-snd_rme96_resume(struct pci_dev *pci)
+static int rme96_resume(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct rme96 *rme96 = card->private_data;
 
 	pci_restore_state(pci);
@@ -2451,7 +2450,11 @@ snd_rme96_resume(struct pci_dev *pci)
 	return 0;
 }
 
-#endif
+static SIMPLE_DEV_PM_OPS(rme96_pm, rme96_suspend, rme96_resume);
+#define RME96_PM_OPS	&rme96_pm
+#else
+#define RME96_PM_OPS	NULL
+#endif /* CONFIG_PM_SLEEP */
 
 static void snd_rme96_card_free(struct snd_card *card)
 {
@@ -2488,7 +2491,7 @@ snd_rme96_probe(struct pci_dev *pci,
 		return err;
 	}
 	
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	rme96->playback_suspend_buffer = vmalloc(RME96_BUFFER_SIZE);
 	if (!rme96->playback_suspend_buffer) {
 		snd_printk(KERN_ERR
@@ -2547,10 +2550,9 @@ static struct pci_driver rme96_driver = {
 	.id_table = snd_rme96_ids,
 	.probe = snd_rme96_probe,
 	.remove = snd_rme96_remove,
-#ifdef CONFIG_PM
-	.suspend = snd_rme96_suspend,
-	.resume = snd_rme96_resume,
-#endif
+	.driver = {
+		.pm = RME96_PM_OPS,
+	},
 };
 
 module_pci_driver(rme96_driver);

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 0236363c301f..00d46116e04a 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2475,15 +2475,14 @@ snd_rme96_probe(struct pci_dev *pci,
 		dev++;
 		return -ENOENT;
 	}
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE,
-			      sizeof(struct rme96), &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
+			   sizeof(struct rme96), &card);
 	if (err < 0)
 		return err;
 	card->private_free = snd_rme96_card_free;
 	rme96 = card->private_data;
 	rme96->card = card;
 	rme96->pci = pci;
-	snd_card_set_dev(card, &pci->dev);
 	if ((err = snd_rme96_create(rme96)) < 0) {
 		snd_card_free(card);
 		return err;

commit 2026d24ef2ea8caad5e87662a58075e930ccab63
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 29 16:04:37 2013 +0100

    ALSA: rme96: Return error code in PCM copy ops
    
    Just pass the error code returned from copy_from_user_toio() and
    copy_to_user_fromio() helpers.
    
    Spotted by coverity CID 114119.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index bb9ebc5543d7..0236363c301f 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -350,9 +350,8 @@ snd_rme96_playback_copy(struct snd_pcm_substream *substream,
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	count <<= rme96->playback_frlog;
 	pos <<= rme96->playback_frlog;
-	copy_from_user_toio(rme96->iobase + RME96_IO_PLAY_BUFFER + pos, src,
-			    count);
-	return 0;
+	return copy_from_user_toio(rme96->iobase + RME96_IO_PLAY_BUFFER + pos, src,
+				   count);
 }
 
 static int
@@ -365,9 +364,8 @@ snd_rme96_capture_copy(struct snd_pcm_substream *substream,
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	count <<= rme96->capture_frlog;
 	pos <<= rme96->capture_frlog;
-	copy_to_user_fromio(dst, rme96->iobase + RME96_IO_REC_BUFFER + pos,
-			    count);
-        return 0;
+	return copy_to_user_fromio(dst, rme96->iobase + RME96_IO_REC_BUFFER + pos,
+				   count);
 }
 
 /*

commit a8cc20999799a94929a56393ff39b32245e33d64
Author: Knut Petersen <Knut_Petersen@t-online.de>
Date:   Thu Aug 22 14:36:16 2013 +0200

    alsa/rme96: Add missing inclusion of linux/vmalloc.h
    
    Signed-off-by: Knut Petersen <Knut_Petersen@t-online.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 9d2a81fcbdad..bb9ebc5543d7 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -28,6 +28,7 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/module.h>
+#include <linux/vmalloc.h>
 
 #include <sound/core.h>
 #include <sound/info.h>

commit e58a244ff9ae264df1bf0fc8f09ecc135dbe3d0f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 22 12:02:31 2013 +0200

    ALSA: rme96: Check the return value of pci_enable_device() in resume callback
    
    Fixing warning message:
      sound/pci/rme96.c: In function ‘snd_rme96_resume’:
      sound/pci/rme96.c:2418:19: warning: ignoring return value of ‘pci_enable_device’, declared with attribute warn_unused_result [-Wunused-result]
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 0506530de5a5..9d2a81fcbdad 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2415,7 +2415,11 @@ snd_rme96_resume(struct pci_dev *pci)
 	struct rme96 *rme96 = card->private_data;
 
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "rme96: pci_enable_device failed, disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 
 	/* reset playback and record buffer pointers */
 	writel(0, rme96->iobase + RME96_IO_SET_PLAY_POS

commit 528ba522e18b95d25adc62367f04290776c390e5
Author: Knut Petersen <Knut_Petersen@t-online.de>
Date:   Wed Aug 21 09:18:54 2013 +0200

    ALSA: rme96: Add PM support v3
    
    Without proper power management handling, the first use
    of a Digi96/8 anytime after a suspend / resume cycle will
    start playback with distortions.
    
    v3: Abort if vmalloc() of suspend buffers fail, but do not
    leak memory in that case.
    
    [fixed wrong memory leak fix again -- tiwai]
    
    Signed-off-by: Knut Petersen <Knut_Petersen@t-online.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 4e9a5563eeca..0506530de5a5 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -239,6 +239,13 @@ struct rme96 {
 
 	u8 rev; /* card revision number */
 
+#ifdef CONFIG_PM
+	u32 playback_pointer;
+	u32 capture_pointer;
+	void *playback_suspend_buffer;
+	void *capture_suspend_buffer;
+#endif
+
 	struct snd_pcm_substream *playback_substream;
 	struct snd_pcm_substream *capture_substream;
 
@@ -370,6 +377,7 @@ static struct snd_pcm_hardware snd_rme96_playback_spdif_info =
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
 			      SNDRV_PCM_INFO_SYNC_START |
+			      SNDRV_PCM_INFO_RESUME |
 			      SNDRV_PCM_INFO_INTERLEAVED |
 			      SNDRV_PCM_INFO_PAUSE),
 	.formats =	     (SNDRV_PCM_FMTBIT_S16_LE |
@@ -400,6 +408,7 @@ static struct snd_pcm_hardware snd_rme96_capture_spdif_info =
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
 			      SNDRV_PCM_INFO_SYNC_START |
+			      SNDRV_PCM_INFO_RESUME |
 			      SNDRV_PCM_INFO_INTERLEAVED |
 			      SNDRV_PCM_INFO_PAUSE),
 	.formats =	     (SNDRV_PCM_FMTBIT_S16_LE |
@@ -430,6 +439,7 @@ static struct snd_pcm_hardware snd_rme96_playback_adat_info =
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
 			      SNDRV_PCM_INFO_SYNC_START |
+			      SNDRV_PCM_INFO_RESUME |
 			      SNDRV_PCM_INFO_INTERLEAVED |
 			      SNDRV_PCM_INFO_PAUSE),
 	.formats =	     (SNDRV_PCM_FMTBIT_S16_LE |
@@ -456,6 +466,7 @@ static struct snd_pcm_hardware snd_rme96_capture_adat_info =
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
 			      SNDRV_PCM_INFO_SYNC_START |
+			      SNDRV_PCM_INFO_RESUME |
 			      SNDRV_PCM_INFO_INTERLEAVED |
 			      SNDRV_PCM_INFO_PAUSE),
 	.formats =	     (SNDRV_PCM_FMTBIT_S16_LE |
@@ -1386,6 +1397,7 @@ snd_rme96_playback_trigger(struct snd_pcm_substream *substream,
 		}
 		break;
 
+	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_STOP:
 		if (RME96_ISPLAYING(rme96)) {
 			if (substream != rme96->playback_substream)
@@ -1401,6 +1413,7 @@ snd_rme96_playback_trigger(struct snd_pcm_substream *substream,
 						 : RME96_STOP_PLAYBACK);
 		break;
 
+	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		if (!RME96_ISPLAYING(rme96))
 			snd_rme96_trigger(rme96, sync ? RME96_RESUME_BOTH
@@ -1441,6 +1454,7 @@ snd_rme96_capture_trigger(struct snd_pcm_substream *substream,
 		}
 		break;
 
+	case SNDRV_PCM_TRIGGER_SUSPEND:
 	case SNDRV_PCM_TRIGGER_STOP:
 		if (RME96_ISRECORDING(rme96)) {
 			if (substream != rme96->capture_substream)
@@ -1456,6 +1470,7 @@ snd_rme96_capture_trigger(struct snd_pcm_substream *substream,
 						 : RME96_STOP_CAPTURE);
 		break;
 
+	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		if (!RME96_ISRECORDING(rme96))
 			snd_rme96_trigger(rme96, sync ? RME96_RESUME_BOTH
@@ -1556,6 +1571,10 @@ snd_rme96_free(void *private_data)
 		pci_release_regions(rme96->pci);
 		rme96->port = 0;
 	}
+#ifdef CONFIG_PM
+	vfree(rme96->playback_suspend_buffer);
+	vfree(rme96->capture_suspend_buffer);
+#endif
 	pci_disable_device(rme96->pci);
 }
 
@@ -2354,6 +2373,83 @@ snd_rme96_create_switches(struct snd_card *card,
  * Card initialisation
  */
 
+#ifdef CONFIG_PM
+
+static int
+snd_rme96_suspend(struct pci_dev *pci,
+		  pm_message_t state)
+{
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct rme96 *rme96 = card->private_data;
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	snd_pcm_suspend(rme96->playback_substream);
+	snd_pcm_suspend(rme96->capture_substream);
+
+	/* save capture & playback pointers */
+	rme96->playback_pointer = readl(rme96->iobase + RME96_IO_GET_PLAY_POS)
+				  & RME96_RCR_AUDIO_ADDR_MASK;
+	rme96->capture_pointer = readl(rme96->iobase + RME96_IO_GET_REC_POS)
+				 & RME96_RCR_AUDIO_ADDR_MASK;
+
+	/* save playback and capture buffers */
+	memcpy_fromio(rme96->playback_suspend_buffer,
+		      rme96->iobase + RME96_IO_PLAY_BUFFER, RME96_BUFFER_SIZE);
+	memcpy_fromio(rme96->capture_suspend_buffer,
+		      rme96->iobase + RME96_IO_REC_BUFFER, RME96_BUFFER_SIZE);
+
+	/* disable the DAC  */
+	rme96->areg &= ~RME96_AR_DAC_EN;
+	writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
+
+	pci_disable_device(pci);
+	pci_save_state(pci);
+
+	return 0;
+}
+
+static int
+snd_rme96_resume(struct pci_dev *pci)
+{
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct rme96 *rme96 = card->private_data;
+
+	pci_restore_state(pci);
+	pci_enable_device(pci);
+
+	/* reset playback and record buffer pointers */
+	writel(0, rme96->iobase + RME96_IO_SET_PLAY_POS
+		  + rme96->playback_pointer);
+	writel(0, rme96->iobase + RME96_IO_SET_REC_POS
+		  + rme96->capture_pointer);
+
+	/* restore playback and capture buffers */
+	memcpy_toio(rme96->iobase + RME96_IO_PLAY_BUFFER,
+		    rme96->playback_suspend_buffer, RME96_BUFFER_SIZE);
+	memcpy_toio(rme96->iobase + RME96_IO_REC_BUFFER,
+		    rme96->capture_suspend_buffer, RME96_BUFFER_SIZE);
+
+	/* reset the ADC */
+	writel(rme96->areg | RME96_AR_PD2,
+	       rme96->iobase + RME96_IO_ADDITIONAL_REG);
+	writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
+
+	/* reset and enable DAC, restore analog volume */
+	snd_rme96_reset_dac(rme96);
+	rme96->areg |= RME96_AR_DAC_EN;
+	writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
+	if (RME96_HAS_ANALOG_OUT(rme96)) {
+		usleep_range(3000, 10000);
+		snd_rme96_apply_dac_volume(rme96);
+	}
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+
+	return 0;
+}
+
+#endif
+
 static void snd_rme96_card_free(struct snd_card *card)
 {
 	snd_rme96_free(card->private_data);
@@ -2390,6 +2486,23 @@ snd_rme96_probe(struct pci_dev *pci,
 		return err;
 	}
 	
+#ifdef CONFIG_PM
+	rme96->playback_suspend_buffer = vmalloc(RME96_BUFFER_SIZE);
+	if (!rme96->playback_suspend_buffer) {
+		snd_printk(KERN_ERR
+			   "Failed to allocate playback suspend buffer!\n");
+		snd_card_free(card);
+		return -ENOMEM;
+	}
+	rme96->capture_suspend_buffer = vmalloc(RME96_BUFFER_SIZE);
+	if (!rme96->capture_suspend_buffer) {
+		snd_printk(KERN_ERR
+			   "Failed to allocate capture suspend buffer!\n");
+		snd_card_free(card);
+		return -ENOMEM;
+	}
+#endif
+
 	strcpy(card->driver, "Digi96");
 	switch (rme96->pci->device) {
 	case PCI_DEVICE_ID_RME_DIGI96:
@@ -2432,6 +2545,10 @@ static struct pci_driver rme96_driver = {
 	.id_table = snd_rme96_ids,
 	.probe = snd_rme96_probe,
 	.remove = snd_rme96_remove,
+#ifdef CONFIG_PM
+	.suspend = snd_rme96_suspend,
+	.resume = snd_rme96_resume,
+#endif
 };
 
 module_pci_driver(rme96_driver);

commit b892ca1c9fe71e829e7b9ed79b8398649de259d7
Author: Knut Petersen <Knut_Petersen@t-online.de>
Date:   Tue Aug 13 21:18:12 2013 +0200

    ALSA: rme96: Add pcm stream synchronization
    
    The hardware does support synchronized start/pause/stop of pcm streams,
    so there is no reason not to add that feature after more than ten years.
    
    Some minor coding style / white space fixes in the surroundings of the
    changes.
    
    Signed-off-by: Knut Petersen <Knut_Petersen@t-online.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 2a8ad9d1a2ae..4e9a5563eeca 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -198,6 +198,31 @@ MODULE_PARM_DESC(enable, "Enable RME Digi96 soundcard.");
 #define RME96_AD1852_VOL_BITS 14
 #define RME96_AD1855_VOL_BITS 10
 
+/* Defines for snd_rme96_trigger */
+#define RME96_TB_START_PLAYBACK 1
+#define RME96_TB_START_CAPTURE 2
+#define RME96_TB_STOP_PLAYBACK 4
+#define RME96_TB_STOP_CAPTURE 8
+#define RME96_TB_RESET_PLAYPOS 16
+#define RME96_TB_RESET_CAPTUREPOS 32
+#define RME96_TB_CLEAR_PLAYBACK_IRQ 64
+#define RME96_TB_CLEAR_CAPTURE_IRQ 128
+#define RME96_RESUME_PLAYBACK	(RME96_TB_START_PLAYBACK)
+#define RME96_RESUME_CAPTURE	(RME96_TB_START_CAPTURE)
+#define RME96_RESUME_BOTH	(RME96_RESUME_PLAYBACK \
+				| RME96_RESUME_CAPTURE)
+#define RME96_START_PLAYBACK	(RME96_TB_START_PLAYBACK \
+				| RME96_TB_RESET_PLAYPOS)
+#define RME96_START_CAPTURE	(RME96_TB_START_CAPTURE \
+				| RME96_TB_RESET_CAPTUREPOS)
+#define RME96_START_BOTH	(RME96_START_PLAYBACK \
+				| RME96_START_CAPTURE)
+#define RME96_STOP_PLAYBACK	(RME96_TB_STOP_PLAYBACK \
+				| RME96_TB_CLEAR_PLAYBACK_IRQ)
+#define RME96_STOP_CAPTURE	(RME96_TB_STOP_CAPTURE \
+				| RME96_TB_CLEAR_CAPTURE_IRQ)
+#define RME96_STOP_BOTH		(RME96_STOP_PLAYBACK \
+				| RME96_STOP_CAPTURE)
 
 struct rme96 {
 	spinlock_t    lock;
@@ -344,6 +369,7 @@ static struct snd_pcm_hardware snd_rme96_playback_spdif_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
+			      SNDRV_PCM_INFO_SYNC_START |
 			      SNDRV_PCM_INFO_INTERLEAVED |
 			      SNDRV_PCM_INFO_PAUSE),
 	.formats =	     (SNDRV_PCM_FMTBIT_S16_LE |
@@ -373,6 +399,7 @@ static struct snd_pcm_hardware snd_rme96_capture_spdif_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
+			      SNDRV_PCM_INFO_SYNC_START |
 			      SNDRV_PCM_INFO_INTERLEAVED |
 			      SNDRV_PCM_INFO_PAUSE),
 	.formats =	     (SNDRV_PCM_FMTBIT_S16_LE |
@@ -402,6 +429,7 @@ static struct snd_pcm_hardware snd_rme96_playback_adat_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
+			      SNDRV_PCM_INFO_SYNC_START |
 			      SNDRV_PCM_INFO_INTERLEAVED |
 			      SNDRV_PCM_INFO_PAUSE),
 	.formats =	     (SNDRV_PCM_FMTBIT_S16_LE |
@@ -427,6 +455,7 @@ static struct snd_pcm_hardware snd_rme96_capture_adat_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
+			      SNDRV_PCM_INFO_SYNC_START |
 			      SNDRV_PCM_INFO_INTERLEAVED |
 			      SNDRV_PCM_INFO_PAUSE),
 	.formats =	     (SNDRV_PCM_FMTBIT_S16_LE |
@@ -1045,54 +1074,35 @@ snd_rme96_capture_hw_params(struct snd_pcm_substream *substream,
 }
 
 static void
-snd_rme96_playback_start(struct rme96 *rme96,
-			 int from_pause)
+snd_rme96_trigger(struct rme96 *rme96,
+		  int op)
 {
-	if (!from_pause) {
+	if (op & RME96_TB_RESET_PLAYPOS)
 		writel(0, rme96->iobase + RME96_IO_RESET_PLAY_POS);
-	}
-
-	rme96->wcreg |= RME96_WCR_START;
-	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
-}
-
-static void
-snd_rme96_capture_start(struct rme96 *rme96,
-			int from_pause)
-{
-	if (!from_pause) {
+	if (op & RME96_TB_RESET_CAPTUREPOS)
 		writel(0, rme96->iobase + RME96_IO_RESET_REC_POS);
-	}
-
-	rme96->wcreg |= RME96_WCR_START_2;
+	if (op & RME96_TB_CLEAR_PLAYBACK_IRQ) {
+		rme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);
+		if (rme96->rcreg & RME96_RCR_IRQ)
+			writel(0, rme96->iobase + RME96_IO_CONFIRM_PLAY_IRQ);
+	}
+	if (op & RME96_TB_CLEAR_CAPTURE_IRQ) {
+		rme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);
+		if (rme96->rcreg & RME96_RCR_IRQ_2)
+			writel(0, rme96->iobase + RME96_IO_CONFIRM_REC_IRQ);
+	}
+	if (op & RME96_TB_START_PLAYBACK)
+		rme96->wcreg |= RME96_WCR_START;
+	if (op & RME96_TB_STOP_PLAYBACK)
+		rme96->wcreg &= ~RME96_WCR_START;
+	if (op & RME96_TB_START_CAPTURE)
+		rme96->wcreg |= RME96_WCR_START_2;
+	if (op & RME96_TB_STOP_CAPTURE)
+		rme96->wcreg &= ~RME96_WCR_START_2;
 	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
 }
 
-static void
-snd_rme96_playback_stop(struct rme96 *rme96)
-{
-	/*
-	 * Check if there is an unconfirmed IRQ, if so confirm it, or else
-	 * the hardware will not stop generating interrupts
-	 */
-	rme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);
-	if (rme96->rcreg & RME96_RCR_IRQ) {
-		writel(0, rme96->iobase + RME96_IO_CONFIRM_PLAY_IRQ);
-	}	
-	rme96->wcreg &= ~RME96_WCR_START;
-	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
-}
 
-static void
-snd_rme96_capture_stop(struct rme96 *rme96)
-{
-	rme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);
-	if (rme96->rcreg & RME96_RCR_IRQ_2) {
-		writel(0, rme96->iobase + RME96_IO_CONFIRM_REC_IRQ);
-	}	
-	rme96->wcreg &= ~RME96_WCR_START_2;
-	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
-}
 
 static irqreturn_t
 snd_rme96_interrupt(int irq,
@@ -1155,6 +1165,7 @@ snd_rme96_playback_spdif_open(struct snd_pcm_substream *substream)
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
+	snd_pcm_set_sync(substream);
 	spin_lock_irq(&rme96->lock);	
         if (rme96->playback_substream != NULL) {
 		spin_unlock_irq(&rme96->lock);
@@ -1191,6 +1202,7 @@ snd_rme96_capture_spdif_open(struct snd_pcm_substream *substream)
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
+	snd_pcm_set_sync(substream);
 	runtime->hw = snd_rme96_capture_spdif_info;
         if (snd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG &&
             (rate = snd_rme96_capture_getrate(rme96, &isadat)) > 0)
@@ -1222,6 +1234,7 @@ snd_rme96_playback_adat_open(struct snd_pcm_substream *substream)
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;        
 	
+	snd_pcm_set_sync(substream);
 	spin_lock_irq(&rme96->lock);	
         if (rme96->playback_substream != NULL) {
 		spin_unlock_irq(&rme96->lock);
@@ -1253,6 +1266,7 @@ snd_rme96_capture_adat_open(struct snd_pcm_substream *substream)
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
+	snd_pcm_set_sync(substream);
 	runtime->hw = snd_rme96_capture_adat_info;
         if (snd_rme96_getinputtype(rme96) == RME96_INPUT_ANALOG) {
                 /* makes no sense to use analog input. Note that analog
@@ -1288,7 +1302,7 @@ snd_rme96_playback_close(struct snd_pcm_substream *substream)
 
 	spin_lock_irq(&rme96->lock);	
 	if (RME96_ISPLAYING(rme96)) {
-		snd_rme96_playback_stop(rme96);
+		snd_rme96_trigger(rme96, RME96_STOP_PLAYBACK);
 	}
 	rme96->playback_substream = NULL;
 	rme96->playback_periodsize = 0;
@@ -1309,7 +1323,7 @@ snd_rme96_capture_close(struct snd_pcm_substream *substream)
 	
 	spin_lock_irq(&rme96->lock);	
 	if (RME96_ISRECORDING(rme96)) {
-		snd_rme96_capture_stop(rme96);
+		snd_rme96_trigger(rme96, RME96_STOP_CAPTURE);
 	}
 	rme96->capture_substream = NULL;
 	rme96->capture_periodsize = 0;
@@ -1324,7 +1338,7 @@ snd_rme96_playback_prepare(struct snd_pcm_substream *substream)
 	
 	spin_lock_irq(&rme96->lock);	
 	if (RME96_ISPLAYING(rme96)) {
-		snd_rme96_playback_stop(rme96);
+		snd_rme96_trigger(rme96, RME96_STOP_PLAYBACK);
 	}
 	writel(0, rme96->iobase + RME96_IO_RESET_PLAY_POS);
 	spin_unlock_irq(&rme96->lock);
@@ -1338,7 +1352,7 @@ snd_rme96_capture_prepare(struct snd_pcm_substream *substream)
 	
 	spin_lock_irq(&rme96->lock);	
 	if (RME96_ISRECORDING(rme96)) {
-		snd_rme96_capture_stop(rme96);
+		snd_rme96_trigger(rme96, RME96_STOP_CAPTURE);
 	}
 	writel(0, rme96->iobase + RME96_IO_RESET_REC_POS);
 	spin_unlock_irq(&rme96->lock);
@@ -1350,41 +1364,53 @@ snd_rme96_playback_trigger(struct snd_pcm_substream *substream,
 			   int cmd)
 {
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_substream *s;
+	bool sync;
+
+	snd_pcm_group_for_each_entry(s, substream) {
+		if (snd_pcm_substream_chip(s) == rme96)
+			snd_pcm_trigger_done(s, substream);
+	}
+
+	sync = (rme96->playback_substream && rme96->capture_substream) &&
+	       (rme96->playback_substream->group ==
+		rme96->capture_substream->group);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 		if (!RME96_ISPLAYING(rme96)) {
-			if (substream != rme96->playback_substream) {
+			if (substream != rme96->playback_substream)
 				return -EBUSY;
-			}
-			snd_rme96_playback_start(rme96, 0);
+			snd_rme96_trigger(rme96, sync ? RME96_START_BOTH
+						 : RME96_START_PLAYBACK);
 		}
 		break;
 
 	case SNDRV_PCM_TRIGGER_STOP:
 		if (RME96_ISPLAYING(rme96)) {
-			if (substream != rme96->playback_substream) {
+			if (substream != rme96->playback_substream)
 				return -EBUSY;
-			}
-			snd_rme96_playback_stop(rme96);
+			snd_rme96_trigger(rme96, sync ? RME96_STOP_BOTH
+						 :  RME96_STOP_PLAYBACK);
 		}
 		break;
 
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		if (RME96_ISPLAYING(rme96)) {
-			snd_rme96_playback_stop(rme96);
-		}
+		if (RME96_ISPLAYING(rme96))
+			snd_rme96_trigger(rme96, sync ? RME96_STOP_BOTH
+						 : RME96_STOP_PLAYBACK);
 		break;
 
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		if (!RME96_ISPLAYING(rme96)) {
-			snd_rme96_playback_start(rme96, 1);
-		}
+		if (!RME96_ISPLAYING(rme96))
+			snd_rme96_trigger(rme96, sync ? RME96_RESUME_BOTH
+						 : RME96_RESUME_PLAYBACK);
 		break;
-		
+
 	default:
 		return -EINVAL;
 	}
+
 	return 0;
 }
 
@@ -1393,38 +1419,49 @@ snd_rme96_capture_trigger(struct snd_pcm_substream *substream,
 			  int cmd)
 {
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_substream *s;
+	bool sync;
+
+	snd_pcm_group_for_each_entry(s, substream) {
+		if (snd_pcm_substream_chip(s) == rme96)
+			snd_pcm_trigger_done(s, substream);
+	}
+
+	sync = (rme96->playback_substream && rme96->capture_substream) &&
+	       (rme96->playback_substream->group ==
+		rme96->capture_substream->group);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 		if (!RME96_ISRECORDING(rme96)) {
-			if (substream != rme96->capture_substream) {
+			if (substream != rme96->capture_substream)
 				return -EBUSY;
-			}
-			snd_rme96_capture_start(rme96, 0);
+			snd_rme96_trigger(rme96, sync ? RME96_START_BOTH
+						 : RME96_START_CAPTURE);
 		}
 		break;
 
 	case SNDRV_PCM_TRIGGER_STOP:
 		if (RME96_ISRECORDING(rme96)) {
-			if (substream != rme96->capture_substream) {
+			if (substream != rme96->capture_substream)
 				return -EBUSY;
-			}
-			snd_rme96_capture_stop(rme96);
+			snd_rme96_trigger(rme96, sync ? RME96_STOP_BOTH
+						 : RME96_STOP_CAPTURE);
 		}
 		break;
 
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		if (RME96_ISRECORDING(rme96)) {
-			snd_rme96_capture_stop(rme96);
-		}
+		if (RME96_ISRECORDING(rme96))
+			snd_rme96_trigger(rme96, sync ? RME96_STOP_BOTH
+						 : RME96_STOP_CAPTURE);
 		break;
 
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		if (!RME96_ISRECORDING(rme96)) {
-			snd_rme96_capture_start(rme96, 1);
-		}
+		if (!RME96_ISRECORDING(rme96))
+			snd_rme96_trigger(rme96, sync ? RME96_RESUME_BOTH
+						 : RME96_RESUME_CAPTURE);
 		break;
-		
+
 	default:
 		return -EINVAL;
 	}
@@ -1505,8 +1542,7 @@ snd_rme96_free(void *private_data)
 	        return;
 	}
 	if (rme96->irq >= 0) {
-		snd_rme96_playback_stop(rme96);
-		snd_rme96_capture_stop(rme96);
+		snd_rme96_trigger(rme96, RME96_STOP_BOTH);
 		rme96->areg &= ~RME96_AR_DAC_EN;
 		writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
 		free_irq(rme96->irq, (void *)rme96);
@@ -1606,8 +1642,7 @@ snd_rme96_create(struct rme96 *rme96)
 	rme96->capture_periodsize = 0;
 	
 	/* make sure playback/capture is stopped, if by some reason active */
-	snd_rme96_playback_stop(rme96);
-	snd_rme96_capture_stop(rme96);
+	snd_rme96_trigger(rme96, RME96_STOP_BOTH);
 	
 	/* set default values in registers */
 	rme96->wcreg =

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 5fb88ac82aa9..2a8ad9d1a2ae 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2390,7 +2390,6 @@ snd_rme96_probe(struct pci_dev *pci,
 static void snd_rme96_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 static struct pci_driver rme96_driver = {

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 9b98dc406988..5fb88ac82aa9 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -270,8 +270,7 @@ snd_rme96_playback_pointer(struct snd_pcm_substream *substream);
 static snd_pcm_uframes_t
 snd_rme96_capture_pointer(struct snd_pcm_substream *substream);
 
-static void __devinit 
-snd_rme96_proc_init(struct rme96 *rme96);
+static void snd_rme96_proc_init(struct rme96 *rme96);
 
 static int
 snd_rme96_create_switches(struct snd_card *card,
@@ -1538,7 +1537,7 @@ snd_rme96_free_adat_pcm(struct snd_pcm *pcm)
 	rme96->adat_pcm = NULL;
 }
 
-static int __devinit
+static int
 snd_rme96_create(struct rme96 *rme96)
 {
 	struct pci_dev *pci = rme96->pci;
@@ -1786,8 +1785,7 @@ snd_rme96_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer
 	}
 }
 
-static void __devinit 
-snd_rme96_proc_init(struct rme96 *rme96)
+static void snd_rme96_proc_init(struct rme96 *rme96)
 {
 	struct snd_info_entry *entry;
 
@@ -2326,7 +2324,7 @@ static void snd_rme96_card_free(struct snd_card *card)
 	snd_rme96_free(card->private_data);
 }
 
-static int __devinit
+static int
 snd_rme96_probe(struct pci_dev *pci,
 		const struct pci_device_id *pci_id)
 {
@@ -2389,7 +2387,7 @@ snd_rme96_probe(struct pci_dev *pci,
 	return 0;
 }
 
-static void __devexit snd_rme96_remove(struct pci_dev *pci)
+static void snd_rme96_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -2399,7 +2397,7 @@ static struct pci_driver rme96_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_rme96_ids,
 	.probe = snd_rme96_probe,
-	.remove = __devexit_p(snd_rme96_remove),
+	.remove = snd_rme96_remove,
 };
 
 module_pci_driver(rme96_driver);

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index ba894158e76c..9b98dc406988 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2395,22 +2395,11 @@ static void __devexit snd_rme96_remove(struct pci_dev *pci)
 	pci_set_drvdata(pci, NULL);
 }
 
-static struct pci_driver driver = {
+static struct pci_driver rme96_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_rme96_ids,
 	.probe = snd_rme96_probe,
 	.remove = __devexit_p(snd_rme96_remove),
 };
 
-static int __init alsa_card_rme96_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit alsa_card_rme96_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(alsa_card_rme96_init)
-module_exit(alsa_card_rme96_exit)
+module_pci_driver(rme96_driver);

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 4585c9729fea..ba894158e76c 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -53,7 +53,7 @@ MODULE_SUPPORTED_DEVICE("{{RME,Digi96},"
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for RME Digi96 soundcard.");

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 409e5b89519d..4585c9729fea 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -27,7 +27,7 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 
 #include <sound/core.h>
 #include <sound/info.h>

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index a3646118abb0..409e5b89519d 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1561,7 +1561,7 @@ snd_rme96_create(struct rme96 *rme96)
 	}
 
 	if (request_irq(pci->irq, snd_rme96_interrupt, IRQF_SHARED,
-			"RME96", rme96)) {
+			KBUILD_MODNAME, rme96)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 9ff247fc8871..a3646118abb0 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2396,7 +2396,7 @@ static void __devexit snd_rme96_remove(struct pci_dev *pci)
 }
 
 static struct pci_driver driver = {
-	.name = "RME Digi96",
+	.name = KBUILD_MODNAME,
 	.id_table = snd_rme96_ids,
 	.probe = snd_rme96_probe,
 	.remove = __devexit_p(snd_rme96_remove),

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index d5f5b440fc40..9ff247fc8871 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -150,7 +150,7 @@ MODULE_PARM_DESC(enable, "Enable RME Digi96 soundcard.");
 #define RME96_RCR_BITPOS_F1 28
 #define RME96_RCR_BITPOS_F2 29
 
-/* Additonal register bits */
+/* Additional register bits */
 #define RME96_AR_WSEL       (1 << 0)
 #define RME96_AR_ANALOG     (1 << 1)
 #define RME96_AR_FREQPAD_0  (1 << 2)

commit 9fe856e47e1751204faf3d604c6d20ab24bd3b93
Author: Joe Perches <joe@perches.com>
Date:   Sat Sep 4 18:52:54 2010 -0700

    sound: Remove unnecessary casts of private_data
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index d19dc052c391..d5f5b440fc40 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1527,14 +1527,14 @@ snd_rme96_free(void *private_data)
 static void
 snd_rme96_free_spdif_pcm(struct snd_pcm *pcm)
 {
-	struct rme96 *rme96 = (struct rme96 *) pcm->private_data;
+	struct rme96 *rme96 = pcm->private_data;
 	rme96->spdif_pcm = NULL;
 }
 
 static void
 snd_rme96_free_adat_pcm(struct snd_pcm *pcm)
 {
-	struct rme96 *rme96 = (struct rme96 *) pcm->private_data;
+	struct rme96 *rme96 = pcm->private_data;
 	rme96->adat_pcm = NULL;
 }
 
@@ -1661,7 +1661,7 @@ static void
 snd_rme96_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
 	int n;
-	struct rme96 *rme96 = (struct rme96 *)entry->private_data;
+	struct rme96 *rme96 = entry->private_data;
 	
 	rme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);
 
@@ -2348,7 +2348,7 @@ snd_rme96_probe(struct pci_dev *pci,
 	if (err < 0)
 		return err;
 	card->private_free = snd_rme96_card_free;
-	rme96 = (struct rme96 *)card->private_data;	
+	rme96 = card->private_data;
 	rme96->card = card;
 	rme96->pci = pci;
 	snd_card_set_dev(card, &pci->dev);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 9d5252bc870c..d19dc052c391 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -27,7 +27,6 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
-#include <linux/slab.h>
 #include <linux/moduleparam.h>
 
 #include <sound/core.h>

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 2ba5c0fd55db..9d5252bc870c 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -231,7 +231,7 @@ struct rme96 {
 	struct snd_kcontrol   *spdif_ctl;
 };
 
-static struct pci_device_id snd_rme96_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_rme96_ids) = {
 	{ PCI_VDEVICE(XILINX, PCI_DEVICE_ID_RME_DIGI96), 0, },
 	{ PCI_VDEVICE(XILINX, PCI_DEVICE_ID_RME_DIGI96_8), 0, },
 	{ PCI_VDEVICE(XILINX, PCI_DEVICE_ID_RME_DIGI96_8_PRO), 0, },

commit 28d27aae9432c300857722a917be4065c6d7abff
Author: Joe Perches <joe@perches.com>
Date:   Wed Jun 24 22:13:35 2009 -0700

    sound: Use PCI_VDEVICE
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 55fb1c131f58..2ba5c0fd55db 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -232,14 +232,10 @@ struct rme96 {
 };
 
 static struct pci_device_id snd_rme96_ids[] = {
-	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_RME_DIGI96,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
-	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_RME_DIGI96_8,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
-	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_RME_DIGI96_8_PRO,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
-	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, }, 
+	{ PCI_VDEVICE(XILINX, PCI_DEVICE_ID_RME_DIGI96), 0, },
+	{ PCI_VDEVICE(XILINX, PCI_DEVICE_ID_RME_DIGI96_8), 0, },
+	{ PCI_VDEVICE(XILINX, PCI_DEVICE_ID_RME_DIGI96_8_PRO), 0, },
+	{ PCI_VDEVICE(XILINX, PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST), 0, },
 	{ 0, }
 };
 

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 3fdd488d0975..55fb1c131f58 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2348,9 +2348,10 @@ snd_rme96_probe(struct pci_dev *pci,
 		dev++;
 		return -ENOENT;
 	}
-	if ((card = snd_card_new(index[dev], id[dev], THIS_MODULE,
-				 sizeof(struct rme96))) == NULL)
-		return -ENOMEM;
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE,
+			      sizeof(struct rme96), &card);
+	if (err < 0)
+		return err;
 	card->private_free = snd_rme96_card_free;
 	rme96 = (struct rme96 *)card->private_data;	
 	rme96->card = card;

commit 44977b719f7425ddb1cb67d647a4f588a9718163
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Feb 28 11:57:47 2008 +0100

    [ALSA] sound: rme96.c fix integer as NULL pointer warning
    
    kernel style does assignment outside of if() block
    sound/pci/rme96.c:1562:71: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index fb0a4ee8bc02..3fdd488d0975 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1559,7 +1559,8 @@ snd_rme96_create(struct rme96 *rme96)
 		return err;
 	rme96->port = pci_resource_start(rme96->pci, 0);
 
-	if ((rme96->iobase = ioremap_nocache(rme96->port, RME96_IO_SIZE)) == 0) {
+	rme96->iobase = ioremap_nocache(rme96->port, RME96_IO_SIZE);
+	if (!rme96->iobase) {
 		snd_printk(KERN_ERR "unable to remap memory region 0x%lx-0x%lx\n", rme96->port, rme96->port + RME96_IO_SIZE - 1);
 		return -ENOMEM;
 	}

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index aff05bd15b77..fb0a4ee8bc02 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -23,7 +23,6 @@
  *
  */      
 
-#include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>

commit 4e98d6a7ce934b19bffb309f2522b22384355fef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 15 15:58:13 2007 +0100

    [ALSA] pci - check value range in ctl callbacks
    
    Check the value ranges in ctl put callbacks properly in the rest of
    PCI drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 0b3c532c4014..aff05bd15b77 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2195,22 +2195,25 @@ snd_rme96_dac_volume_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_valu
 {
 	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
         int change = 0;
+	unsigned int vol, maxvol;
 
-	if (!RME96_HAS_ANALOG_OUT(rme96)) {
+
+	if (!RME96_HAS_ANALOG_OUT(rme96))
 		return -EINVAL;
-	}
+	maxvol = RME96_185X_MAX_OUT(rme96);
 	spin_lock_irq(&rme96->lock);
-        if (u->value.integer.value[0] != rme96->vol[0]) {
-		rme96->vol[0] = u->value.integer.value[0];
-                change = 1;
-        }
-        if (u->value.integer.value[1] != rme96->vol[1]) {
-		rme96->vol[1] = u->value.integer.value[1];
-                change = 1;
-        }
-	if (change) {
-		snd_rme96_apply_dac_volume(rme96);
+	vol = u->value.integer.value[0];
+	if (vol != rme96->vol[0] && vol <= maxvol) {
+		rme96->vol[0] = vol;
+		change = 1;
+	}
+	vol = u->value.integer.value[1];
+	if (vol != rme96->vol[1] && vol <= maxvol) {
+		rme96->vol[1] = vol;
+		change = 1;
 	}
+	if (change)
+		snd_rme96_apply_dac_volume(rme96);
 	spin_unlock_irq(&rme96->lock);
 
         return change;

commit 918f3a0e8cf67b5db966516f255eaf24d814fac0
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 13 17:40:54 2007 +0200

    [ALSA] pcm: add snd_pcm_rate_to_rate_bit() helper
    
    Add a snd_pcm_rate_to_rate_bit() function to factor out common code used
    by several drivers.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index ba4a34bae48f..0b3c532c4014 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -300,20 +300,6 @@ snd_rme96_capture_ptr(struct rme96 *rme96)
 		& RME96_RCR_AUDIO_ADDR_MASK) >> rme96->capture_frlog;
 }
 
-static int
-snd_rme96_ratecode(int rate)
-{
-    switch (rate) {
-    case 32000: return SNDRV_PCM_RATE_32000;
-    case 44100: return SNDRV_PCM_RATE_44100;
-    case 48000: return SNDRV_PCM_RATE_48000;
-    case 64000: return SNDRV_PCM_RATE_64000;
-    case 88200: return SNDRV_PCM_RATE_88200;
-    case 96000: return SNDRV_PCM_RATE_96000;
-    }
-    return 0;
-}
-
 static int
 snd_rme96_playback_silence(struct snd_pcm_substream *substream,
 			   int channel, /* not used (interleaved data) */
@@ -1192,7 +1178,7 @@ snd_rme96_playback_spdif_open(struct snd_pcm_substream *substream)
 	    (rate = snd_rme96_capture_getrate(rme96, &dummy)) > 0)
 	{
                 /* slave clock */
-                runtime->hw.rates = snd_rme96_ratecode(rate);
+                runtime->hw.rates = snd_pcm_rate_to_rate_bit(rate);
                 runtime->hw.rate_min = rate;
                 runtime->hw.rate_max = rate;
 	}        
@@ -1219,7 +1205,7 @@ snd_rme96_capture_spdif_open(struct snd_pcm_substream *substream)
                 if (isadat) {
                         return -EIO;
                 }
-                runtime->hw.rates = snd_rme96_ratecode(rate);
+                runtime->hw.rates = snd_pcm_rate_to_rate_bit(rate);
                 runtime->hw.rate_min = rate;
                 runtime->hw.rate_max = rate;
         }
@@ -1259,7 +1245,7 @@ snd_rme96_playback_adat_open(struct snd_pcm_substream *substream)
 	    (rate = snd_rme96_capture_getrate(rme96, &dummy)) > 0)
 	{
                 /* slave clock */
-                runtime->hw.rates = snd_rme96_ratecode(rate);
+                runtime->hw.rates = snd_pcm_rate_to_rate_bit(rate);
                 runtime->hw.rate_min = rate;
                 runtime->hw.rate_max = rate;
 	}        
@@ -1284,7 +1270,7 @@ snd_rme96_capture_adat_open(struct snd_pcm_substream *substream)
                 if (!isadat) {
                         return -EIO;
                 }
-                runtime->hw.rates = snd_rme96_ratecode(rate);
+                runtime->hw.rates = snd_pcm_rate_to_rate_bit(rate);
                 runtime->hw.rate_min = rate;
                 runtime->hw.rate_max = rate;
         }

commit b83f346bc4d6ab358fd0da85b7eab08bf0234c0b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 13 17:37:55 2007 +0200

    [ALSA] remove incorrect usage of SNDRV_PCM_INFO_SYNC_START and snd_pcm_set_sync()
    
    Set the SNDRV_PCM_INFO_SYNC_START flag and the substream's sync ID
    (only) if the substream actually can be linked to another one.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 9a4596f879e8..ba4a34bae48f 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1176,8 +1176,6 @@ snd_rme96_playback_spdif_open(struct snd_pcm_substream *substream)
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	snd_pcm_set_sync(substream);
-
 	spin_lock_irq(&rme96->lock);	
         if (rme96->playback_substream != NULL) {
 		spin_unlock_irq(&rme96->lock);
@@ -1214,8 +1212,6 @@ snd_rme96_capture_spdif_open(struct snd_pcm_substream *substream)
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	snd_pcm_set_sync(substream);
-
 	runtime->hw = snd_rme96_capture_spdif_info;
         if (snd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG &&
             (rate = snd_rme96_capture_getrate(rme96, &isadat)) > 0)
@@ -1247,8 +1243,6 @@ snd_rme96_playback_adat_open(struct snd_pcm_substream *substream)
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;        
 	
-	snd_pcm_set_sync(substream);
-
 	spin_lock_irq(&rme96->lock);	
         if (rme96->playback_substream != NULL) {
 		spin_unlock_irq(&rme96->lock);
@@ -1280,8 +1274,6 @@ snd_rme96_capture_adat_open(struct snd_pcm_substream *substream)
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	snd_pcm_set_sync(substream);
-
 	runtime->hw = snd_rme96_capture_adat_info;
         if (snd_rme96_getinputtype(rme96) == RME96_INPUT_ANALOG) {
                 /* makes no sense to use analog input. Note that analog

commit a5ce88909d3007caa7b65996a8f6784350beb2a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 23 15:42:26 2007 +0200

    [ALSA] Clean up with common snd_ctl_boolean_*_info callbacks
    
    Clean up codes using the new common snd_ctl_boolean_*_info() callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index e3304b7ccbcb..9a4596f879e8 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1826,15 +1826,8 @@ snd_rme96_proc_init(struct rme96 *rme96)
  * control interface
  */
 
-static int
-snd_rme96_info_loopback_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_rme96_info_loopback_control		snd_ctl_boolean_mono_info
+
 static int
 snd_rme96_get_loopback_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 106110a89a4c..e3304b7ccbcb 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1587,7 +1587,8 @@ snd_rme96_create(struct rme96 *rme96)
 		return -ENOMEM;
 	}
 
-	if (request_irq(pci->irq, snd_rme96_interrupt, IRQF_DISABLED|IRQF_SHARED, "RME96", (void *)rme96)) {
+	if (request_irq(pci->irq, snd_rme96_interrupt, IRQF_SHARED,
+			"RME96", rme96)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index f8de7c997017..106110a89a4c 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1117,8 +1117,7 @@ snd_rme96_capture_stop(struct rme96 *rme96)
 
 static irqreturn_t
 snd_rme96_interrupt(int irq,
-		    void *dev_id,
-		    struct pt_regs *regs)
+		    void *dev_id)
 {
 	struct rme96 *rme96 = (struct rme96 *)dev_id;
 

commit f40b68903ccd511ea9d658b4bce319dd032a265a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 16:51:05 2006 +0200

    [ALSA] Fix section mismatch errors in ALSA PCI drivers
    
    Fixed 'section mismatch' errors in ALSA PCI drivers:
    - removed invalid __devinitdata from pci id tables
    - fix/remove __devinit of functions called in suspend/resume
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index fde0f3e20530..f8de7c997017 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -232,7 +232,7 @@ struct rme96 {
 	struct snd_kcontrol   *spdif_ctl;
 };
 
-static struct pci_device_id snd_rme96_ids[] __devinitdata = {
+static struct pci_device_id snd_rme96_ids[] = {
 	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_RME_DIGI96,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
 	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_RME_DIGI96_8,

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 991cb18c14f3..fde0f3e20530 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1588,7 +1588,7 @@ snd_rme96_create(struct rme96 *rme96)
 		return -ENOMEM;
 	}
 
-	if (request_irq(pci->irq, snd_rme96_interrupt, SA_INTERRUPT|SA_SHIRQ, "RME96", (void *)rme96)) {
+	if (request_irq(pci->irq, snd_rme96_interrupt, IRQF_DISABLED|IRQF_SHARED, "RME96", (void *)rme96)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}

commit 688956f23bdbfb1c3551bfafc819f989b36bb8ae
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 6 15:44:34 2006 +0200

    [ALSA] Fix races in irq handler and ioremap
    
    Call ioremap before request_irq for avoiding possible races
    in the irq handler.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 65611a7d366d..991cb18c14f3 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1583,17 +1583,17 @@ snd_rme96_create(struct rme96 *rme96)
 		return err;
 	rme96->port = pci_resource_start(rme96->pci, 0);
 
+	if ((rme96->iobase = ioremap_nocache(rme96->port, RME96_IO_SIZE)) == 0) {
+		snd_printk(KERN_ERR "unable to remap memory region 0x%lx-0x%lx\n", rme96->port, rme96->port + RME96_IO_SIZE - 1);
+		return -ENOMEM;
+	}
+
 	if (request_irq(pci->irq, snd_rme96_interrupt, SA_INTERRUPT|SA_SHIRQ, "RME96", (void *)rme96)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}
 	rme96->irq = pci->irq;
 
-	if ((rme96->iobase = ioremap_nocache(rme96->port, RME96_IO_SIZE)) == 0) {
-		snd_printk(KERN_ERR "unable to remap memory region 0x%lx-0x%lx\n", rme96->port, rme96->port + RME96_IO_SIZE - 1);
-		return -ENOMEM;
-	}
-
 	/* read the card's revision number */
 	pci_read_config_byte(pci, 8, &rme96->rev);	
 	

commit 2ce7fb579f842f76a0216618c105bffd334d9233
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 10 16:24:42 2006 +0200

    [ALSA] rme96 - Fix OSS full-duplex
    
    Fixed a bug in rme96 driver that the full-duplex on OSS emulation
    doesn't work due to the invalid period size parameter.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 75a8b754ef28..65611a7d366d 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1151,6 +1151,25 @@ static struct snd_pcm_hw_constraint_list hw_constraints_period_bytes = {
 	.mask = 0
 };
 
+static void
+rme96_set_buffer_size_constraint(struct rme96 *rme96,
+				 struct snd_pcm_runtime *runtime)
+{
+	unsigned int size;
+
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
+				     RME96_BUFFER_SIZE, RME96_BUFFER_SIZE);
+	if ((size = rme96->playback_periodsize) != 0 ||
+	    (size = rme96->capture_periodsize) != 0)
+		snd_pcm_hw_constraint_minmax(runtime,
+					     SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+					     size, size);
+	else
+		snd_pcm_hw_constraint_list(runtime, 0,
+					   SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+					   &hw_constraints_period_bytes);
+}
+
 static int
 snd_rme96_playback_spdif_open(struct snd_pcm_substream *substream)
 {
@@ -1180,8 +1199,7 @@ snd_rme96_playback_spdif_open(struct snd_pcm_substream *substream)
                 runtime->hw.rate_min = rate;
                 runtime->hw.rate_max = rate;
 	}        
-	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, RME96_BUFFER_SIZE, RME96_BUFFER_SIZE);
-	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_bytes);
+	rme96_set_buffer_size_constraint(rme96, runtime);
 
 	rme96->wcreg_spdif_stream = rme96->wcreg_spdif;
 	rme96->spdif_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
@@ -1219,9 +1237,7 @@ snd_rme96_capture_spdif_open(struct snd_pcm_substream *substream)
 	rme96->capture_substream = substream;
 	spin_unlock_irq(&rme96->lock);
 	
-	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, RME96_BUFFER_SIZE, RME96_BUFFER_SIZE);
-	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_bytes);
-
+	rme96_set_buffer_size_constraint(rme96, runtime);
 	return 0;
 }
 
@@ -1254,8 +1270,7 @@ snd_rme96_playback_adat_open(struct snd_pcm_substream *substream)
                 runtime->hw.rate_min = rate;
                 runtime->hw.rate_max = rate;
 	}        
-	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, RME96_BUFFER_SIZE, RME96_BUFFER_SIZE);
-	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_bytes);
+	rme96_set_buffer_size_constraint(rme96, runtime);
 	return 0;
 }
 
@@ -1291,8 +1306,7 @@ snd_rme96_capture_adat_open(struct snd_pcm_substream *substream)
 	rme96->capture_substream = substream;
 	spin_unlock_irq(&rme96->lock);
 
-	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, RME96_BUFFER_SIZE, RME96_BUFFER_SIZE);
-	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_bytes);
+	rme96_set_buffer_size_constraint(rme96, runtime);
 	return 0;
 }
 

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 3c1bc533d511..75a8b754ef28 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1805,7 +1805,7 @@ snd_rme96_proc_init(struct rme96 *rme96)
 	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(rme96->card, "rme96", &entry))
-		snd_info_set_text_ops(entry, rme96, 1024, snd_rme96_proc_read);
+		snd_info_set_text_ops(entry, rme96, snd_rme96_proc_read);
 }
 
 /*

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 6c2a9f4a7659..3c1bc533d511 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -232,7 +232,7 @@ struct rme96 {
 	struct snd_kcontrol   *spdif_ctl;
 };
 
-static struct pci_device_id snd_rme96_ids[] = {
+static struct pci_device_id snd_rme96_ids[] __devinitdata = {
 	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_RME_DIGI96,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
 	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_RME_DIGI96_8,

commit 7f927fcc2fd1575d01efb4b76665975007945690
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Mar 28 01:56:53 2006 -0800

    [PATCH] Typo fixes
    
    Fix a lot of typos.  Eyeballed by jmc@ in OpenBSD.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 0e694b011dcc..6c2a9f4a7659 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -359,7 +359,7 @@ snd_rme96_capture_copy(struct snd_pcm_substream *substream,
 }
 
 /*
- * Digital output capabilites (S/PDIF)
+ * Digital output capabilities (S/PDIF)
  */
 static struct snd_pcm_hardware snd_rme96_playback_spdif_info =
 {
@@ -388,7 +388,7 @@ static struct snd_pcm_hardware snd_rme96_playback_spdif_info =
 };
 
 /*
- * Digital input capabilites (S/PDIF)
+ * Digital input capabilities (S/PDIF)
  */
 static struct snd_pcm_hardware snd_rme96_capture_spdif_info =
 {
@@ -417,7 +417,7 @@ static struct snd_pcm_hardware snd_rme96_capture_spdif_info =
 };
 
 /*
- * Digital output capabilites (ADAT)
+ * Digital output capabilities (ADAT)
  */
 static struct snd_pcm_hardware snd_rme96_playback_adat_info =
 {
@@ -442,7 +442,7 @@ static struct snd_pcm_hardware snd_rme96_playback_adat_info =
 };
 
 /*
- * Digital input capabilites (ADAT)
+ * Digital input capabilities (ADAT)
  */
 static struct snd_pcm_hardware snd_rme96_capture_adat_info =
 {

commit a3aefd883dc8c17c2231d763630ffe5cd118d7e8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:05:37 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI RME96
    
    Modules: RME96 driver
    
    Remove xxx_t typedefs from the PCI RME96 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 6d422ef64999..0e694b011dcc 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -201,7 +201,7 @@ MODULE_PARM_DESC(enable, "Enable RME Digi96 soundcard.");
 #define RME96_AD1855_VOL_BITS 10
 
 
-typedef struct snd_rme96 {
+struct rme96 {
 	spinlock_t    lock;
 	int irq;
 	unsigned long port;
@@ -216,8 +216,8 @@ typedef struct snd_rme96 {
 
 	u8 rev; /* card revision number */
 
-	snd_pcm_substream_t *playback_substream;
-	snd_pcm_substream_t *capture_substream;
+	struct snd_pcm_substream *playback_substream;
+	struct snd_pcm_substream *capture_substream;
 
 	int playback_frlog; /* log2 of framesize */
 	int capture_frlog;
@@ -225,12 +225,12 @@ typedef struct snd_rme96 {
         size_t playback_periodsize; /* in bytes, zero if not used */
 	size_t capture_periodsize; /* in bytes, zero if not used */
 
-	snd_card_t         *card;
-	snd_pcm_t          *spdif_pcm;
-	snd_pcm_t          *adat_pcm; 
+	struct snd_card *card;
+	struct snd_pcm *spdif_pcm;
+	struct snd_pcm *adat_pcm; 
 	struct pci_dev     *pci;
-	snd_kcontrol_t	   *spdif_ctl;
-} rme96_t;
+	struct snd_kcontrol   *spdif_ctl;
+};
 
 static struct pci_device_id snd_rme96_ids[] = {
 	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_RME_DIGI96,
@@ -257,44 +257,44 @@ MODULE_DEVICE_TABLE(pci, snd_rme96_ids);
 #define	RME96_185X_MAX_OUT(rme96) ((1 << (RME96_DAC_IS_1852(rme96) ? RME96_AD1852_VOL_BITS : RME96_AD1855_VOL_BITS)) - 1)
 
 static int
-snd_rme96_playback_prepare(snd_pcm_substream_t *substream);
+snd_rme96_playback_prepare(struct snd_pcm_substream *substream);
 
 static int
-snd_rme96_capture_prepare(snd_pcm_substream_t *substream);
+snd_rme96_capture_prepare(struct snd_pcm_substream *substream);
 
 static int
-snd_rme96_playback_trigger(snd_pcm_substream_t *substream, 
+snd_rme96_playback_trigger(struct snd_pcm_substream *substream, 
 			   int cmd);
 
 static int
-snd_rme96_capture_trigger(snd_pcm_substream_t *substream, 
+snd_rme96_capture_trigger(struct snd_pcm_substream *substream, 
 			  int cmd);
 
 static snd_pcm_uframes_t
-snd_rme96_playback_pointer(snd_pcm_substream_t *substream);
+snd_rme96_playback_pointer(struct snd_pcm_substream *substream);
 
 static snd_pcm_uframes_t
-snd_rme96_capture_pointer(snd_pcm_substream_t *substream);
+snd_rme96_capture_pointer(struct snd_pcm_substream *substream);
 
 static void __devinit 
-snd_rme96_proc_init(rme96_t *rme96);
+snd_rme96_proc_init(struct rme96 *rme96);
 
 static int
-snd_rme96_create_switches(snd_card_t *card,
-			  rme96_t *rme96);
+snd_rme96_create_switches(struct snd_card *card,
+			  struct rme96 *rme96);
 
 static int
-snd_rme96_getinputtype(rme96_t *rme96);
+snd_rme96_getinputtype(struct rme96 *rme96);
 
 static inline unsigned int
-snd_rme96_playback_ptr(rme96_t *rme96)
+snd_rme96_playback_ptr(struct rme96 *rme96)
 {
 	return (readl(rme96->iobase + RME96_IO_GET_PLAY_POS)
 		& RME96_RCR_AUDIO_ADDR_MASK) >> rme96->playback_frlog;
 }
 
 static inline unsigned int
-snd_rme96_capture_ptr(rme96_t *rme96)
+snd_rme96_capture_ptr(struct rme96 *rme96)
 {
 	return (readl(rme96->iobase + RME96_IO_GET_REC_POS)
 		& RME96_RCR_AUDIO_ADDR_MASK) >> rme96->capture_frlog;
@@ -315,12 +315,12 @@ snd_rme96_ratecode(int rate)
 }
 
 static int
-snd_rme96_playback_silence(snd_pcm_substream_t *substream,
+snd_rme96_playback_silence(struct snd_pcm_substream *substream,
 			   int channel, /* not used (interleaved data) */
 			   snd_pcm_uframes_t pos,
 			   snd_pcm_uframes_t count)
 {
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	count <<= rme96->playback_frlog;
 	pos <<= rme96->playback_frlog;
 	memset_io(rme96->iobase + RME96_IO_PLAY_BUFFER + pos,
@@ -329,13 +329,13 @@ snd_rme96_playback_silence(snd_pcm_substream_t *substream,
 }
 
 static int
-snd_rme96_playback_copy(snd_pcm_substream_t *substream,
+snd_rme96_playback_copy(struct snd_pcm_substream *substream,
 			int channel, /* not used (interleaved data) */
 			snd_pcm_uframes_t pos,
 			void __user *src,
 			snd_pcm_uframes_t count)
 {
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	count <<= rme96->playback_frlog;
 	pos <<= rme96->playback_frlog;
 	copy_from_user_toio(rme96->iobase + RME96_IO_PLAY_BUFFER + pos, src,
@@ -344,13 +344,13 @@ snd_rme96_playback_copy(snd_pcm_substream_t *substream,
 }
 
 static int
-snd_rme96_capture_copy(snd_pcm_substream_t *substream,
+snd_rme96_capture_copy(struct snd_pcm_substream *substream,
 		       int channel, /* not used (interleaved data) */
 		       snd_pcm_uframes_t pos,
 		       void __user *dst,
 		       snd_pcm_uframes_t count)
 {
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	count <<= rme96->capture_frlog;
 	pos <<= rme96->capture_frlog;
 	copy_to_user_fromio(dst, rme96->iobase + RME96_IO_REC_BUFFER + pos,
@@ -361,7 +361,7 @@ snd_rme96_capture_copy(snd_pcm_substream_t *substream,
 /*
  * Digital output capabilites (S/PDIF)
  */
-static snd_pcm_hardware_t snd_rme96_playback_spdif_info =
+static struct snd_pcm_hardware snd_rme96_playback_spdif_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
@@ -390,7 +390,7 @@ static snd_pcm_hardware_t snd_rme96_playback_spdif_info =
 /*
  * Digital input capabilites (S/PDIF)
  */
-static snd_pcm_hardware_t snd_rme96_capture_spdif_info =
+static struct snd_pcm_hardware snd_rme96_capture_spdif_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
@@ -419,7 +419,7 @@ static snd_pcm_hardware_t snd_rme96_capture_spdif_info =
 /*
  * Digital output capabilites (ADAT)
  */
-static snd_pcm_hardware_t snd_rme96_playback_adat_info =
+static struct snd_pcm_hardware snd_rme96_playback_adat_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
@@ -444,7 +444,7 @@ static snd_pcm_hardware_t snd_rme96_playback_adat_info =
 /*
  * Digital input capabilites (ADAT)
  */
-static snd_pcm_hardware_t snd_rme96_capture_adat_info =
+static struct snd_pcm_hardware snd_rme96_capture_adat_info =
 {
 	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
 			      SNDRV_PCM_INFO_MMAP_VALID |
@@ -479,7 +479,7 @@ static snd_pcm_hardware_t snd_rme96_capture_adat_info =
  * the volume.
  */
 static void
-snd_rme96_write_SPI(rme96_t *rme96, u16 val)
+snd_rme96_write_SPI(struct rme96 *rme96, u16 val)
 {
 	int i;
 
@@ -506,7 +506,7 @@ snd_rme96_write_SPI(rme96_t *rme96, u16 val)
 }
 
 static void
-snd_rme96_apply_dac_volume(rme96_t *rme96)
+snd_rme96_apply_dac_volume(struct rme96 *rme96)
 {
 	if (RME96_DAC_IS_1852(rme96)) {
 		snd_rme96_write_SPI(rme96, (rme96->vol[0] << 2) | 0x0);
@@ -518,7 +518,7 @@ snd_rme96_apply_dac_volume(rme96_t *rme96)
 }
 
 static void
-snd_rme96_reset_dac(rme96_t *rme96)
+snd_rme96_reset_dac(struct rme96 *rme96)
 {
 	writel(rme96->wcreg | RME96_WCR_PD,
 	       rme96->iobase + RME96_IO_CONTROL_REGISTER);
@@ -526,14 +526,14 @@ snd_rme96_reset_dac(rme96_t *rme96)
 }
 
 static int
-snd_rme96_getmontracks(rme96_t *rme96)
+snd_rme96_getmontracks(struct rme96 *rme96)
 {
 	return ((rme96->wcreg >> RME96_WCR_BITPOS_MONITOR_0) & 1) +
 		(((rme96->wcreg >> RME96_WCR_BITPOS_MONITOR_1) & 1) << 1);
 }
 
 static int
-snd_rme96_setmontracks(rme96_t *rme96,
+snd_rme96_setmontracks(struct rme96 *rme96,
 		       int montracks)
 {
 	if (montracks & 1) {
@@ -551,14 +551,14 @@ snd_rme96_setmontracks(rme96_t *rme96,
 }
 
 static int
-snd_rme96_getattenuation(rme96_t *rme96)
+snd_rme96_getattenuation(struct rme96 *rme96)
 {
 	return ((rme96->wcreg >> RME96_WCR_BITPOS_GAIN_0) & 1) +
 		(((rme96->wcreg >> RME96_WCR_BITPOS_GAIN_1) & 1) << 1);
 }
 
 static int
-snd_rme96_setattenuation(rme96_t *rme96,
+snd_rme96_setattenuation(struct rme96 *rme96,
 			 int attenuation)
 {
 	switch (attenuation) {
@@ -586,7 +586,7 @@ snd_rme96_setattenuation(rme96_t *rme96,
 }
 
 static int
-snd_rme96_capture_getrate(rme96_t *rme96,
+snd_rme96_capture_getrate(struct rme96 *rme96,
 			  int *is_adat)
 {	
 	int n, rate;
@@ -649,7 +649,7 @@ snd_rme96_capture_getrate(rme96_t *rme96,
 }
 
 static int
-snd_rme96_playback_getrate(rme96_t *rme96)
+snd_rme96_playback_getrate(struct rme96 *rme96)
 {
 	int rate, dummy;
 
@@ -679,7 +679,7 @@ snd_rme96_playback_getrate(rme96_t *rme96)
 }
 
 static int
-snd_rme96_playback_setrate(rme96_t *rme96,
+snd_rme96_playback_setrate(struct rme96 *rme96,
 			   int rate)
 {
 	int ds;
@@ -731,7 +731,7 @@ snd_rme96_playback_setrate(rme96_t *rme96,
 }
 
 static int
-snd_rme96_capture_analog_setrate(rme96_t *rme96,
+snd_rme96_capture_analog_setrate(struct rme96 *rme96,
 				 int rate)
 {
 	switch (rate) {
@@ -773,7 +773,7 @@ snd_rme96_capture_analog_setrate(rme96_t *rme96,
 }
 
 static int
-snd_rme96_setclockmode(rme96_t *rme96,
+snd_rme96_setclockmode(struct rme96 *rme96,
 		       int mode)
 {
 	switch (mode) {
@@ -801,7 +801,7 @@ snd_rme96_setclockmode(rme96_t *rme96,
 }
 
 static int
-snd_rme96_getclockmode(rme96_t *rme96)
+snd_rme96_getclockmode(struct rme96 *rme96)
 {
 	if (rme96->areg & RME96_AR_WSEL) {
 		return RME96_CLOCKMODE_WORDCLOCK;
@@ -811,7 +811,7 @@ snd_rme96_getclockmode(rme96_t *rme96)
 }
 
 static int
-snd_rme96_setinputtype(rme96_t *rme96,
+snd_rme96_setinputtype(struct rme96 *rme96,
 		       int type)
 {
 	int n;
@@ -872,7 +872,7 @@ snd_rme96_setinputtype(rme96_t *rme96,
 }
 
 static int
-snd_rme96_getinputtype(rme96_t *rme96)
+snd_rme96_getinputtype(struct rme96 *rme96)
 {
 	if (rme96->areg & RME96_AR_ANALOG) {
 		return RME96_INPUT_ANALOG;
@@ -882,7 +882,7 @@ snd_rme96_getinputtype(rme96_t *rme96)
 }
 
 static void
-snd_rme96_setframelog(rme96_t *rme96,
+snd_rme96_setframelog(struct rme96 *rme96,
 		      int n_channels,
 		      int is_playback)
 {
@@ -904,7 +904,7 @@ snd_rme96_setframelog(rme96_t *rme96,
 }
 
 static int
-snd_rme96_playback_setformat(rme96_t *rme96,
+snd_rme96_playback_setformat(struct rme96 *rme96,
 			     int format)
 {
 	switch (format) {
@@ -922,7 +922,7 @@ snd_rme96_playback_setformat(rme96_t *rme96,
 }
 
 static int
-snd_rme96_capture_setformat(rme96_t *rme96,
+snd_rme96_capture_setformat(struct rme96 *rme96,
 			    int format)
 {
 	switch (format) {
@@ -940,7 +940,7 @@ snd_rme96_capture_setformat(rme96_t *rme96,
 }
 
 static void
-snd_rme96_set_period_properties(rme96_t *rme96,
+snd_rme96_set_period_properties(struct rme96 *rme96,
 				size_t period_bytes)
 {
 	switch (period_bytes) {
@@ -959,11 +959,11 @@ snd_rme96_set_period_properties(rme96_t *rme96,
 }
 
 static int
-snd_rme96_playback_hw_params(snd_pcm_substream_t *substream,
-			     snd_pcm_hw_params_t *params)
+snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params)
 {
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err, rate, dummy;
 
 	runtime->dma_area = (void __force *)(rme96->iobase +
@@ -1012,11 +1012,11 @@ snd_rme96_playback_hw_params(snd_pcm_substream_t *substream,
 }
 
 static int
-snd_rme96_capture_hw_params(snd_pcm_substream_t *substream,
-			    snd_pcm_hw_params_t *params)
+snd_rme96_capture_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params)
 {
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err, isadat, rate;
 	
 	runtime->dma_area = (void __force *)(rme96->iobase +
@@ -1066,7 +1066,7 @@ snd_rme96_capture_hw_params(snd_pcm_substream_t *substream,
 }
 
 static void
-snd_rme96_playback_start(rme96_t *rme96,
+snd_rme96_playback_start(struct rme96 *rme96,
 			 int from_pause)
 {
 	if (!from_pause) {
@@ -1078,7 +1078,7 @@ snd_rme96_playback_start(rme96_t *rme96,
 }
 
 static void
-snd_rme96_capture_start(rme96_t *rme96,
+snd_rme96_capture_start(struct rme96 *rme96,
 			int from_pause)
 {
 	if (!from_pause) {
@@ -1090,7 +1090,7 @@ snd_rme96_capture_start(rme96_t *rme96,
 }
 
 static void
-snd_rme96_playback_stop(rme96_t *rme96)
+snd_rme96_playback_stop(struct rme96 *rme96)
 {
 	/*
 	 * Check if there is an unconfirmed IRQ, if so confirm it, or else
@@ -1105,7 +1105,7 @@ snd_rme96_playback_stop(rme96_t *rme96)
 }
 
 static void
-snd_rme96_capture_stop(rme96_t *rme96)
+snd_rme96_capture_stop(struct rme96 *rme96)
 {
 	rme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);
 	if (rme96->rcreg & RME96_RCR_IRQ_2) {
@@ -1120,7 +1120,7 @@ snd_rme96_interrupt(int irq,
 		    void *dev_id,
 		    struct pt_regs *regs)
 {
-	rme96_t *rme96 = (rme96_t *)dev_id;
+	struct rme96 *rme96 = (struct rme96 *)dev_id;
 
 	rme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);
 	/* fastpath out, to ease interrupt sharing */
@@ -1145,18 +1145,18 @@ snd_rme96_interrupt(int irq,
 
 static unsigned int period_bytes[] = { RME96_SMALL_BLOCK_SIZE, RME96_LARGE_BLOCK_SIZE };
 
-static snd_pcm_hw_constraint_list_t hw_constraints_period_bytes = {
+static struct snd_pcm_hw_constraint_list hw_constraints_period_bytes = {
 	.count = ARRAY_SIZE(period_bytes),
 	.list = period_bytes,
 	.mask = 0
 };
 
 static int
-snd_rme96_playback_spdif_open(snd_pcm_substream_t *substream)
+snd_rme96_playback_spdif_open(struct snd_pcm_substream *substream)
 {
         int rate, dummy;
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	snd_pcm_set_sync(substream);
 
@@ -1191,11 +1191,11 @@ snd_rme96_playback_spdif_open(snd_pcm_substream_t *substream)
 }
 
 static int
-snd_rme96_capture_spdif_open(snd_pcm_substream_t *substream)
+snd_rme96_capture_spdif_open(struct snd_pcm_substream *substream)
 {
         int isadat, rate;
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	snd_pcm_set_sync(substream);
 
@@ -1226,11 +1226,11 @@ snd_rme96_capture_spdif_open(snd_pcm_substream_t *substream)
 }
 
 static int
-snd_rme96_playback_adat_open(snd_pcm_substream_t *substream)
+snd_rme96_playback_adat_open(struct snd_pcm_substream *substream)
 {
         int rate, dummy;
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;        
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;        
 	
 	snd_pcm_set_sync(substream);
 
@@ -1260,11 +1260,11 @@ snd_rme96_playback_adat_open(snd_pcm_substream_t *substream)
 }
 
 static int
-snd_rme96_capture_adat_open(snd_pcm_substream_t *substream)
+snd_rme96_capture_adat_open(struct snd_pcm_substream *substream)
 {
         int isadat, rate;
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	snd_pcm_set_sync(substream);
 
@@ -1297,9 +1297,9 @@ snd_rme96_capture_adat_open(snd_pcm_substream_t *substream)
 }
 
 static int
-snd_rme96_playback_close(snd_pcm_substream_t *substream)
+snd_rme96_playback_close(struct snd_pcm_substream *substream)
 {
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	int spdif = 0;
 
 	spin_lock_irq(&rme96->lock);	
@@ -1319,9 +1319,9 @@ snd_rme96_playback_close(snd_pcm_substream_t *substream)
 }
 
 static int
-snd_rme96_capture_close(snd_pcm_substream_t *substream)
+snd_rme96_capture_close(struct snd_pcm_substream *substream)
 {
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	
 	spin_lock_irq(&rme96->lock);	
 	if (RME96_ISRECORDING(rme96)) {
@@ -1334,9 +1334,9 @@ snd_rme96_capture_close(snd_pcm_substream_t *substream)
 }
 
 static int
-snd_rme96_playback_prepare(snd_pcm_substream_t *substream)
+snd_rme96_playback_prepare(struct snd_pcm_substream *substream)
 {
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	
 	spin_lock_irq(&rme96->lock);	
 	if (RME96_ISPLAYING(rme96)) {
@@ -1348,9 +1348,9 @@ snd_rme96_playback_prepare(snd_pcm_substream_t *substream)
 }
 
 static int
-snd_rme96_capture_prepare(snd_pcm_substream_t *substream)
+snd_rme96_capture_prepare(struct snd_pcm_substream *substream)
 {
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	
 	spin_lock_irq(&rme96->lock);	
 	if (RME96_ISRECORDING(rme96)) {
@@ -1362,10 +1362,10 @@ snd_rme96_capture_prepare(snd_pcm_substream_t *substream)
 }
 
 static int
-snd_rme96_playback_trigger(snd_pcm_substream_t *substream, 
+snd_rme96_playback_trigger(struct snd_pcm_substream *substream, 
 			   int cmd)
 {
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -1405,10 +1405,10 @@ snd_rme96_playback_trigger(snd_pcm_substream_t *substream,
 }
 
 static int
-snd_rme96_capture_trigger(snd_pcm_substream_t *substream, 
+snd_rme96_capture_trigger(struct snd_pcm_substream *substream, 
 			  int cmd)
 {
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -1449,20 +1449,20 @@ snd_rme96_capture_trigger(snd_pcm_substream_t *substream,
 }
 
 static snd_pcm_uframes_t
-snd_rme96_playback_pointer(snd_pcm_substream_t *substream)
+snd_rme96_playback_pointer(struct snd_pcm_substream *substream)
 {
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	return snd_rme96_playback_ptr(rme96);
 }
 
 static snd_pcm_uframes_t
-snd_rme96_capture_pointer(snd_pcm_substream_t *substream)
+snd_rme96_capture_pointer(struct snd_pcm_substream *substream)
 {
-	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	return snd_rme96_capture_ptr(rme96);
 }
 
-static snd_pcm_ops_t snd_rme96_playback_spdif_ops = {
+static struct snd_pcm_ops snd_rme96_playback_spdif_ops = {
 	.open =		snd_rme96_playback_spdif_open,
 	.close =	snd_rme96_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1475,7 +1475,7 @@ static snd_pcm_ops_t snd_rme96_playback_spdif_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static snd_pcm_ops_t snd_rme96_capture_spdif_ops = {
+static struct snd_pcm_ops snd_rme96_capture_spdif_ops = {
 	.open =		snd_rme96_capture_spdif_open,
 	.close =	snd_rme96_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1487,7 +1487,7 @@ static snd_pcm_ops_t snd_rme96_capture_spdif_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static snd_pcm_ops_t snd_rme96_playback_adat_ops = {
+static struct snd_pcm_ops snd_rme96_playback_adat_ops = {
 	.open =		snd_rme96_playback_adat_open,
 	.close =	snd_rme96_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1500,7 +1500,7 @@ static snd_pcm_ops_t snd_rme96_playback_adat_ops = {
 	.mmap =		snd_pcm_lib_mmap_iomem,
 };
 
-static snd_pcm_ops_t snd_rme96_capture_adat_ops = {
+static struct snd_pcm_ops snd_rme96_capture_adat_ops = {
 	.open =		snd_rme96_capture_adat_open,
 	.close =	snd_rme96_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -1515,7 +1515,7 @@ static snd_pcm_ops_t snd_rme96_capture_adat_ops = {
 static void
 snd_rme96_free(void *private_data)
 {
-	rme96_t *rme96 = (rme96_t *)private_data;
+	struct rme96 *rme96 = (struct rme96 *)private_data;
 
 	if (rme96 == NULL) {
 	        return;
@@ -1540,21 +1540,21 @@ snd_rme96_free(void *private_data)
 }
 
 static void
-snd_rme96_free_spdif_pcm(snd_pcm_t *pcm)
+snd_rme96_free_spdif_pcm(struct snd_pcm *pcm)
 {
-	rme96_t *rme96 = (rme96_t *) pcm->private_data;
+	struct rme96 *rme96 = (struct rme96 *) pcm->private_data;
 	rme96->spdif_pcm = NULL;
 }
 
 static void
-snd_rme96_free_adat_pcm(snd_pcm_t *pcm)
+snd_rme96_free_adat_pcm(struct snd_pcm *pcm)
 {
-	rme96_t *rme96 = (rme96_t *) pcm->private_data;
+	struct rme96 *rme96 = (struct rme96 *) pcm->private_data;
 	rme96->adat_pcm = NULL;
 }
 
 static int __devinit
-snd_rme96_create(rme96_t *rme96)
+snd_rme96_create(struct rme96 *rme96)
 {
 	struct pci_dev *pci = rme96->pci;
 	int err;
@@ -1671,10 +1671,10 @@ snd_rme96_create(rme96_t *rme96)
  */
 
 static void 
-snd_rme96_proc_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+snd_rme96_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
 {
 	int n;
-	rme96_t *rme96 = (rme96_t *)entry->private_data;
+	struct rme96 *rme96 = (struct rme96 *)entry->private_data;
 	
 	rme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);
 
@@ -1800,9 +1800,9 @@ snd_rme96_proc_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
 }
 
 static void __devinit 
-snd_rme96_proc_init(rme96_t *rme96)
+snd_rme96_proc_init(struct rme96 *rme96)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(rme96->card, "rme96", &entry))
 		snd_info_set_text_ops(entry, rme96, 1024, snd_rme96_proc_read);
@@ -1813,7 +1813,7 @@ snd_rme96_proc_init(rme96_t *rme96)
  */
 
 static int
-snd_rme96_info_loopback_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+snd_rme96_info_loopback_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
@@ -1822,9 +1822,9 @@ snd_rme96_info_loopback_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *
 	return 0;
 }
 static int
-snd_rme96_get_loopback_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+snd_rme96_get_loopback_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	
 	spin_lock_irq(&rme96->lock);
 	ucontrol->value.integer.value[0] = rme96->wcreg & RME96_WCR_SEL ? 0 : 1;
@@ -1832,9 +1832,9 @@ snd_rme96_get_loopback_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t *
 	return 0;
 }
 static int
-snd_rme96_put_loopback_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+snd_rme96_put_loopback_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 	int change;
 	
@@ -1849,10 +1849,10 @@ snd_rme96_put_loopback_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t *
 }
 
 static int
-snd_rme96_info_inputtype_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+snd_rme96_info_inputtype_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	static char *_texts[5] = { "Optical", "Coaxial", "Internal", "XLR", "Analog" };
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	char *texts[5] = { _texts[0], _texts[1], _texts[2], _texts[3], _texts[4] };
 	
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
@@ -1886,9 +1886,9 @@ snd_rme96_info_inputtype_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *
 	return 0;
 }
 static int
-snd_rme96_get_inputtype_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+snd_rme96_get_inputtype_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	unsigned int items = 3;
 	
 	spin_lock_irq(&rme96->lock);
@@ -1925,9 +1925,9 @@ snd_rme96_get_inputtype_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	return 0;
 }
 static int
-snd_rme96_put_inputtype_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+snd_rme96_put_inputtype_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 	int change, items = 3;
 	
@@ -1967,7 +1967,7 @@ snd_rme96_put_inputtype_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 }
 
 static int
-snd_rme96_info_clockmode_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+snd_rme96_info_clockmode_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[3] = { "AutoSync", "Internal", "Word" };
 	
@@ -1981,9 +1981,9 @@ snd_rme96_info_clockmode_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *
 	return 0;
 }
 static int
-snd_rme96_get_clockmode_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+snd_rme96_get_clockmode_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	
 	spin_lock_irq(&rme96->lock);
 	ucontrol->value.enumerated.item[0] = snd_rme96_getclockmode(rme96);
@@ -1991,9 +1991,9 @@ snd_rme96_get_clockmode_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	return 0;
 }
 static int
-snd_rme96_put_clockmode_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+snd_rme96_put_clockmode_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 	int change;
 	
@@ -2006,7 +2006,7 @@ snd_rme96_put_clockmode_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 }
 
 static int
-snd_rme96_info_attenuation_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+snd_rme96_info_attenuation_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[4] = { "0 dB", "-6 dB", "-12 dB", "-18 dB" };
 	
@@ -2020,9 +2020,9 @@ snd_rme96_info_attenuation_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t
 	return 0;
 }
 static int
-snd_rme96_get_attenuation_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+snd_rme96_get_attenuation_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	
 	spin_lock_irq(&rme96->lock);
 	ucontrol->value.enumerated.item[0] = snd_rme96_getattenuation(rme96);
@@ -2030,9 +2030,9 @@ snd_rme96_get_attenuation_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_
 	return 0;
 }
 static int
-snd_rme96_put_attenuation_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+snd_rme96_put_attenuation_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 	int change;
 	
@@ -2046,7 +2046,7 @@ snd_rme96_put_attenuation_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_
 }
 
 static int
-snd_rme96_info_montracks_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+snd_rme96_info_montracks_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[4] = { "1+2", "3+4", "5+6", "7+8" };
 	
@@ -2060,9 +2060,9 @@ snd_rme96_info_montracks_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *
 	return 0;
 }
 static int
-snd_rme96_get_montracks_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+snd_rme96_get_montracks_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	
 	spin_lock_irq(&rme96->lock);
 	ucontrol->value.enumerated.item[0] = snd_rme96_getmontracks(rme96);
@@ -2070,9 +2070,9 @@ snd_rme96_get_montracks_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	return 0;
 }
 static int
-snd_rme96_put_montracks_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+snd_rme96_put_montracks_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 	int change;
 	
@@ -2084,7 +2084,7 @@ snd_rme96_put_montracks_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	return change;
 }
 
-static u32 snd_rme96_convert_from_aes(snd_aes_iec958_t *aes)
+static u32 snd_rme96_convert_from_aes(struct snd_aes_iec958 *aes)
 {
 	u32 val = 0;
 	val |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? RME96_WCR_PRO : 0;
@@ -2096,7 +2096,7 @@ static u32 snd_rme96_convert_from_aes(snd_aes_iec958_t *aes)
 	return val;
 }
 
-static void snd_rme96_convert_to_aes(snd_aes_iec958_t *aes, u32 val)
+static void snd_rme96_convert_to_aes(struct snd_aes_iec958 *aes, u32 val)
 {
 	aes->status[0] = ((val & RME96_WCR_PRO) ? IEC958_AES0_PROFESSIONAL : 0) |
 			 ((val & RME96_WCR_DOLBY) ? IEC958_AES0_NONAUDIO : 0);
@@ -2106,24 +2106,24 @@ static void snd_rme96_convert_to_aes(snd_aes_iec958_t *aes, u32 val)
 		aes->status[0] |= (val & RME96_WCR_EMP) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;
 }
 
-static int snd_rme96_control_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme96_control_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_rme96_control_spdif_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme96_control_spdif_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	
 	snd_rme96_convert_to_aes(&ucontrol->value.iec958, rme96->wcreg_spdif);
 	return 0;
 }
 
-static int snd_rme96_control_spdif_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme96_control_spdif_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	int change;
 	u32 val;
 	
@@ -2135,24 +2135,24 @@ static int snd_rme96_control_spdif_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_v
 	return change;
 }
 
-static int snd_rme96_control_spdif_stream_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme96_control_spdif_stream_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_rme96_control_spdif_stream_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme96_control_spdif_stream_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	
 	snd_rme96_convert_to_aes(&ucontrol->value.iec958, rme96->wcreg_spdif_stream);
 	return 0;
 }
 
-static int snd_rme96_control_spdif_stream_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme96_control_spdif_stream_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	int change;
 	u32 val;
 	
@@ -2167,23 +2167,23 @@ static int snd_rme96_control_spdif_stream_put(snd_kcontrol_t * kcontrol, snd_ctl
 	return change;
 }
 
-static int snd_rme96_control_spdif_mask_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_rme96_control_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_rme96_control_spdif_mask_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_rme96_control_spdif_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
 	ucontrol->value.iec958.status[0] = kcontrol->private_value;
 	return 0;
 }
 
 static int
-snd_rme96_dac_volume_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+snd_rme96_dac_volume_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 	
         uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
         uinfo->count = 2;
@@ -2193,9 +2193,9 @@ snd_rme96_dac_volume_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
 }
 
 static int
-snd_rme96_dac_volume_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *u)
+snd_rme96_dac_volume_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *u)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&rme96->lock);
         u->value.integer.value[0] = rme96->vol[0];
@@ -2206,9 +2206,9 @@ snd_rme96_dac_volume_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *u)
 }
 
 static int
-snd_rme96_dac_volume_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *u)
+snd_rme96_dac_volume_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *u)
 {
-	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	struct rme96 *rme96 = snd_kcontrol_chip(kcontrol);
         int change = 0;
 
 	if (!RME96_HAS_ANALOG_OUT(rme96)) {
@@ -2231,7 +2231,7 @@ snd_rme96_dac_volume_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *u)
         return change;
 }
 
-static snd_kcontrol_new_t snd_rme96_controls[] = {
+static struct snd_kcontrol_new snd_rme96_controls[] = {
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
@@ -2312,11 +2312,11 @@ static snd_kcontrol_new_t snd_rme96_controls[] = {
 };
 
 static int
-snd_rme96_create_switches(snd_card_t *card,
-			  rme96_t *rme96)
+snd_rme96_create_switches(struct snd_card *card,
+			  struct rme96 *rme96)
 {
 	int idx, err;
-	snd_kcontrol_t *kctl;
+	struct snd_kcontrol *kctl;
 
 	for (idx = 0; idx < 7; idx++) {
 		if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_rme96_controls[idx], rme96))) < 0)
@@ -2338,7 +2338,7 @@ snd_rme96_create_switches(snd_card_t *card,
  * Card initialisation
  */
 
-static void snd_rme96_card_free(snd_card_t *card)
+static void snd_rme96_card_free(struct snd_card *card)
 {
 	snd_rme96_free(card->private_data);
 }
@@ -2348,8 +2348,8 @@ snd_rme96_probe(struct pci_dev *pci,
 		const struct pci_device_id *pci_id)
 {
 	static int dev;
-	rme96_t *rme96;
-	snd_card_t *card;
+	struct rme96 *rme96;
+	struct snd_card *card;
 	int err;
 	u8 val;
 
@@ -2361,10 +2361,10 @@ snd_rme96_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 	if ((card = snd_card_new(index[dev], id[dev], THIS_MODULE,
-				 sizeof(rme96_t))) == NULL)
+				 sizeof(struct rme96))) == NULL)
 		return -ENOMEM;
 	card->private_free = snd_rme96_card_free;
-	rme96 = (rme96_t *)card->private_data;	
+	rme96 = (struct rme96 *)card->private_data;	
 	rme96->card = card;
 	rme96->pci = pci;
 	snd_card_set_dev(card, &pci->dev);

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 0eddeb16a10f..6d422ef64999 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2413,7 +2413,6 @@ static void __devexit snd_rme96_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "RME Digi96",
-	.owner = THIS_MODULE,
 	.id_table = snd_rme96_ids,
 	.probe = snd_rme96_probe,
 	.remove = __devexit_p(snd_rme96_remove),

commit 99b359ba10a582148c6725f428a33ba5356dd993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 20 18:26:44 2005 +0200

    [ALSA] Add missing KERN_* suffix to printk
    
    Add missing KERN_* suffix to printk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index c495cae78dbf..0eddeb16a10f 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -1570,13 +1570,13 @@ snd_rme96_create(rme96_t *rme96)
 	rme96->port = pci_resource_start(rme96->pci, 0);
 
 	if (request_irq(pci->irq, snd_rme96_interrupt, SA_INTERRUPT|SA_SHIRQ, "RME96", (void *)rme96)) {
-		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}
 	rme96->irq = pci->irq;
 
 	if ((rme96->iobase = ioremap_nocache(rme96->port, RME96_IO_SIZE)) == 0) {
-		snd_printk("unable to remap memory region 0x%lx-0x%lx\n", rme96->port, rme96->port + RME96_IO_SIZE - 1);
+		snd_printk(KERN_ERR "unable to remap memory region 0x%lx-0x%lx\n", rme96->port, rme96->port + RME96_IO_SIZE - 1);
 		return -ENOMEM;
 	}
 

commit 8b7fc4214b550fafe595330e28d7c2c72b8b62f6
Author: Roland Dreier <rolandd@cisco.com>
Date:   Wed Sep 14 14:19:17 2005 -0700

    [PATCH] add PCI IDs so RME32 and RME96 drivers build
    
    While doing an allyesconfig build, I noticed that the commit
    
        commit 8cdfd2519c6c9a1e6057dc5970b2542b35895738
        Author: Takashi Iwai <tiwai@suse.de>
        Date:   Wed Sep 7 14:08:11 2005 +0200
    
            [ALSA] Remove superfluous PCI ID definitions
    
    broke the RME32 and RME96 drivers, since the PCI IDs they use seem to have
    changed names.  Here's a patch to fix this -- compile tested only, since I
    have no idea what the hardware even is.
    
    Fix the build of the RME32 and RME96 drivers by having them use the
    PCI_DEVICE_ID_RME_xxx names defined in <linux/pci_ids.h> instead of the
    PCI_DEVICE_ID_xxx names that they used to define themselves.
    
    Also fix the typo in the id PCI_DEVICE_IDRME__DIGI96_8_PAD_OR_PST so the
    name is PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST.
    
    Signed-off-by: Roland Dreier <rolandd@cisco.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 9983b66dc564..c495cae78dbf 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -233,13 +233,13 @@ typedef struct snd_rme96 {
 } rme96_t;
 
 static struct pci_device_id snd_rme96_ids[] = {
-	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_DIGI96,
+	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_RME_DIGI96,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
-	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_DIGI96_8,
+	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_RME_DIGI96_8,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
-	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_DIGI96_8_PRO,
+	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_RME_DIGI96_8_PRO,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
-	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST,
+	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, }, 
 	{ 0, }
 };
@@ -248,12 +248,12 @@ MODULE_DEVICE_TABLE(pci, snd_rme96_ids);
 
 #define RME96_ISPLAYING(rme96) ((rme96)->wcreg & RME96_WCR_START)
 #define RME96_ISRECORDING(rme96) ((rme96)->wcreg & RME96_WCR_START_2)
-#define	RME96_HAS_ANALOG_IN(rme96) ((rme96)->pci->device == PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST)
-#define	RME96_HAS_ANALOG_OUT(rme96) ((rme96)->pci->device == PCI_DEVICE_ID_DIGI96_8_PRO || \
-				     (rme96)->pci->device == PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST)
+#define	RME96_HAS_ANALOG_IN(rme96) ((rme96)->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST)
+#define	RME96_HAS_ANALOG_OUT(rme96) ((rme96)->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PRO || \
+				     (rme96)->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST)
 #define	RME96_DAC_IS_1852(rme96) (RME96_HAS_ANALOG_OUT(rme96) && (rme96)->rev >= 4)
-#define	RME96_DAC_IS_1855(rme96) (((rme96)->pci->device == PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST && (rme96)->rev < 4) || \
-			          ((rme96)->pci->device == PCI_DEVICE_ID_DIGI96_8_PRO && (rme96)->rev == 2))
+#define	RME96_DAC_IS_1855(rme96) (((rme96)->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST && (rme96)->rev < 4) || \
+			          ((rme96)->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PRO && (rme96)->rev == 2))
 #define	RME96_185X_MAX_OUT(rme96) ((1 << (RME96_DAC_IS_1852(rme96) ? RME96_AD1852_VOL_BITS : RME96_AD1855_VOL_BITS)) - 1)
 
 static int
@@ -830,9 +830,9 @@ snd_rme96_setinputtype(rme96_t *rme96,
 			RME96_WCR_INP_1;
 		break;
 	case RME96_INPUT_XLR:
-		if ((rme96->pci->device != PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST &&
-		     rme96->pci->device != PCI_DEVICE_ID_DIGI96_8_PRO) ||
-		    (rme96->pci->device == PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST &&
+		if ((rme96->pci->device != PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST &&
+		     rme96->pci->device != PCI_DEVICE_ID_RME_DIGI96_8_PRO) ||
+		    (rme96->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST &&
 		     rme96->rev > 4))
 		{
 			/* Only Digi96/8 PRO and Digi96/8 PAD supports XLR */
@@ -1598,7 +1598,7 @@ snd_rme96_create(rme96_t *rme96)
 	rme96->spdif_pcm->info_flags = 0;
 
 	/* set up ALSA pcm device for ADAT */
-	if (pci->device == PCI_DEVICE_ID_DIGI96) {
+	if (pci->device == PCI_DEVICE_ID_RME_DIGI96) {
 		/* ADAT is not available on the base model */
 		rme96->adat_pcm = NULL;
 	} else {
@@ -1858,14 +1858,14 @@ snd_rme96_info_inputtype_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t *
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
 	switch (rme96->pci->device) {
-	case PCI_DEVICE_ID_DIGI96:
-	case PCI_DEVICE_ID_DIGI96_8:
+	case PCI_DEVICE_ID_RME_DIGI96:
+	case PCI_DEVICE_ID_RME_DIGI96_8:
 		uinfo->value.enumerated.items = 3;
 		break;
-	case PCI_DEVICE_ID_DIGI96_8_PRO:
+	case PCI_DEVICE_ID_RME_DIGI96_8_PRO:
 		uinfo->value.enumerated.items = 4;
 		break;
-	case PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST:
+	case PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST:
 		if (rme96->rev > 4) {
 			/* PST */
 			uinfo->value.enumerated.items = 4;
@@ -1895,14 +1895,14 @@ snd_rme96_get_inputtype_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	ucontrol->value.enumerated.item[0] = snd_rme96_getinputtype(rme96);
 	
 	switch (rme96->pci->device) {
-	case PCI_DEVICE_ID_DIGI96:
-	case PCI_DEVICE_ID_DIGI96_8:
+	case PCI_DEVICE_ID_RME_DIGI96:
+	case PCI_DEVICE_ID_RME_DIGI96_8:
 		items = 3;
 		break;
-	case PCI_DEVICE_ID_DIGI96_8_PRO:
+	case PCI_DEVICE_ID_RME_DIGI96_8_PRO:
 		items = 4;
 		break;
-	case PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST:
+	case PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST:
 		if (rme96->rev > 4) {
 			/* for handling PST case, (INPUT_ANALOG is moved to INPUT_XLR */
 			if (ucontrol->value.enumerated.item[0] == RME96_INPUT_ANALOG) {
@@ -1932,14 +1932,14 @@ snd_rme96_put_inputtype_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	int change, items = 3;
 	
 	switch (rme96->pci->device) {
-	case PCI_DEVICE_ID_DIGI96:
-	case PCI_DEVICE_ID_DIGI96_8:
+	case PCI_DEVICE_ID_RME_DIGI96:
+	case PCI_DEVICE_ID_RME_DIGI96_8:
 		items = 3;
 		break;
-	case PCI_DEVICE_ID_DIGI96_8_PRO:
+	case PCI_DEVICE_ID_RME_DIGI96_8_PRO:
 		items = 4;
 		break;
-	case PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST:
+	case PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST:
 		if (rme96->rev > 4) {
 			items = 4;
 		} else {
@@ -1953,7 +1953,7 @@ snd_rme96_put_inputtype_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	val = ucontrol->value.enumerated.item[0] % items;
 	
 	/* special case for PST */
-	if (rme96->pci->device == PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST && rme96->rev > 4) {
+	if (rme96->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST && rme96->rev > 4) {
 		if (val == RME96_INPUT_XLR) {
 			val = RME96_INPUT_ANALOG;
 		}
@@ -2375,16 +2375,16 @@ snd_rme96_probe(struct pci_dev *pci,
 	
 	strcpy(card->driver, "Digi96");
 	switch (rme96->pci->device) {
-	case PCI_DEVICE_ID_DIGI96:
+	case PCI_DEVICE_ID_RME_DIGI96:
 		strcpy(card->shortname, "RME Digi96");
 		break;
-	case PCI_DEVICE_ID_DIGI96_8:
+	case PCI_DEVICE_ID_RME_DIGI96_8:
 		strcpy(card->shortname, "RME Digi96/8");
 		break;
-	case PCI_DEVICE_ID_DIGI96_8_PRO:
+	case PCI_DEVICE_ID_RME_DIGI96_8_PRO:
 		strcpy(card->shortname, "RME Digi96/8 PRO");
 		break;
-	case PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST:
+	case PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST:
 		pci_read_config_byte(rme96->pci, 8, &val);
 		if (val < 5) {
 			strcpy(card->shortname, "RME Digi96/8 PAD");

commit 3bcd4649bca99ee9242f20d7da35e3f8741c6549
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 12 08:20:54 2005 +0200

    [ALSA] set owner field in struct pci_driver
    
    AD1889 driver,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CS46xx driver,EMU10K1/EMU10K2 driver
    HDA Intel driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    MIXART driver,NM256 driver,RME HDSP driver,RME9652 driver
    Trident driver,Digigram VX222 driver,YMFPCI driver
    Set the module owner field in each driver's struct pci_driver to get
    the driver symlink in the sysfs device directory.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 6653c21bfa09..9983b66dc564 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2413,6 +2413,7 @@ static void __devexit snd_rme96_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "RME Digi96",
+	.owner = THIS_MODULE,
 	.id_table = snd_rme96_ids,
 	.probe = snd_rme96_probe,
 	.remove = __devexit_p(snd_rme96_remove),

commit 8cdfd2519c6c9a1e6057dc5970b2542b35895738
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 7 14:08:11 2005 +0200

    [ALSA] Remove superfluous PCI ID definitions
    
    CS46xx driver,EMU10K1/EMU10K2 driver,PCM Midlevel,Trident driver
    YMFPCI driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,RME32 driver,RME96 driver
    SonicVibes driver,VIA82xx driver,ALI5451 driver,ICE1712 driver
    ICE1724 driver,NM256 driver,RME HDSP driver,RME9652 driver
    Remove superfluous PCI ID definitions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 2da33138fa4b..6653c21bfa09 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -200,25 +200,6 @@ MODULE_PARM_DESC(enable, "Enable RME Digi96 soundcard.");
 #define RME96_AD1852_VOL_BITS 14
 #define RME96_AD1855_VOL_BITS 10
 
-/*
- * PCI vendor/device ids, could in the future be defined in <linux/pci.h>,
- * therefore #ifndef is used.
- */
-#ifndef PCI_VENDOR_ID_XILINX
-#define PCI_VENDOR_ID_XILINX 0x10ee
-#endif
-#ifndef PCI_DEVICE_ID_DIGI96
-#define PCI_DEVICE_ID_DIGI96 0x3fc0
-#endif
-#ifndef PCI_DEVICE_ID_DIGI96_8
-#define PCI_DEVICE_ID_DIGI96_8 0x3fc1
-#endif
-#ifndef PCI_DEVICE_ID_DIGI96_8_PRO
-#define PCI_DEVICE_ID_DIGI96_8_PRO 0x3fc2
-#endif
-#ifndef PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST
-#define PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST 0x3fc3
-#endif
 
 typedef struct snd_rme96 {
 	spinlock_t    lock;

commit 4d23359b7ec8b03da2154df935af7d625075f6cf
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 5 10:35:20 2005 +0200

    [ALSA] sparse address space annotations
    
    ALSA Core,RawMidi Midlevel,ALSA<-OSS emulation,ALSA sequencer
    RME32 driver,RME96 driver,EMU10K1/EMU10K2 driver,NM256 driver
    Add sparse annotations where we do strange this with __iomem/__user
    pointers.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 9645e9004a48..2da33138fa4b 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -985,7 +985,8 @@ snd_rme96_playback_hw_params(snd_pcm_substream_t *substream,
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	int err, rate, dummy;
 
-	runtime->dma_area = (void *)(rme96->iobase + RME96_IO_PLAY_BUFFER);
+	runtime->dma_area = (void __force *)(rme96->iobase +
+					     RME96_IO_PLAY_BUFFER);
 	runtime->dma_addr = rme96->port + RME96_IO_PLAY_BUFFER;
 	runtime->dma_bytes = RME96_BUFFER_SIZE;
 
@@ -1037,7 +1038,8 @@ snd_rme96_capture_hw_params(snd_pcm_substream_t *substream,
 	snd_pcm_runtime_t *runtime = substream->runtime;
 	int err, isadat, rate;
 	
-	runtime->dma_area = (void *)(rme96->iobase + RME96_IO_REC_BUFFER);
+	runtime->dma_area = (void __force *)(rme96->iobase +
+					     RME96_IO_REC_BUFFER);
 	runtime->dma_addr = rme96->port + RME96_IO_REC_BUFFER;
 	runtime->dma_bytes = RME96_BUFFER_SIZE;
 

commit 67ed4161f60d76b3b27efc085b36357a6a90768c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Jul 29 15:32:58 2005 +0200

    [ALSA] sound - fix .iface field of mixer control elements
    
    Documentation,CS46xx driver,EMU10K1/EMU10K2 driver,AD1848 driver
    SB16/AWE driver,CMIPCI driver,ENS1370/1+ driver,RME32 driver
    RME96 driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    RME HDSP driver,RME9652 driver
    This patch changes .iface to SNDRV_CTL_ELEM_IFACE_MIXER whre _PCM or
    _HWDEP was used in controls that are not associated with a specific PCM
    (sub)stream or hwdep device, and changes some controls that got
    inconsitent .iface values due to copy+paste errors.  Furthermore, it
    makes sure that all control that do use _PCM or _HWDEP use the correct
    number in the .device field.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 10c4f45a913c..9645e9004a48 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2266,7 +2266,7 @@ static snd_kcontrol_new_t snd_rme96_controls[] = {
 },
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
-	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,CON_MASK),
 	.info =		snd_rme96_control_spdif_mask_info,
 	.get =		snd_rme96_control_spdif_mask_get,
@@ -2276,7 +2276,7 @@ static snd_kcontrol_new_t snd_rme96_controls[] = {
 },
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
-	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PRO_MASK),
 	.info =		snd_rme96_control_spdif_mask_info,
 	.get =		snd_rme96_control_spdif_mask_get,

commit 01d25d460a3b28aab537fab9a0038d1b5832ce28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 11 16:58:24 2005 +0200

    [ALSA] Replace pci_module_init() with pci_register_driver()
    
    Documentation,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CA0106 driver,CS46xx driver
    EMU10K1/EMU10K2 driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,RME HDSP driver
    RME9652 driver,Trident driver,Digigram VX222 driver,YMFPCI driver
    Replace the obsolete pci_module_init() with pci_register_driver().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 8e2666841d21..10c4f45a913c 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -2437,7 +2437,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_rme96_init(void)
 {
-	return pci_module_init(&driver);
+	return pci_register_driver(&driver);
 }
 
 static void __exit alsa_card_rme96_exit(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
new file mode 100644
index 000000000000..8e2666841d21
--- /dev/null
+++ b/sound/pci/rme96.c
@@ -0,0 +1,2449 @@
+/*
+ *   ALSA driver for RME Digi96, Digi96/8 and Digi96/8 PRO/PAD/PST audio
+ *   interfaces 
+ *
+ *	Copyright (c) 2000, 2001 Anders Torger <torger@ludd.luth.se>
+ *    
+ *      Thanks to Henk Hesselink <henk@anda.nl> for the analog volume control
+ *      code.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */      
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/asoundef.h>
+#include <sound/initval.h>
+
+#include <asm/io.h>
+
+/* note, two last pcis should be equal, it is not a bug */
+
+MODULE_AUTHOR("Anders Torger <torger@ludd.luth.se>");
+MODULE_DESCRIPTION("RME Digi96, Digi96/8, Digi96/8 PRO, Digi96/8 PST, "
+		   "Digi96/8 PAD");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{RME,Digi96},"
+		"{RME,Digi96/8},"
+		"{RME,Digi96/8 PRO},"
+		"{RME,Digi96/8 PST},"
+		"{RME,Digi96/8 PAD}}");
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for RME Digi96 soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for RME Digi96 soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable RME Digi96 soundcard.");
+
+/*
+ * Defines for RME Digi96 series, from internal RME reference documents
+ * dated 12.01.00
+ */
+
+#define RME96_SPDIF_NCHANNELS 2
+
+/* Playback and capture buffer size */
+#define RME96_BUFFER_SIZE 0x10000
+
+/* IO area size */
+#define RME96_IO_SIZE 0x60000
+
+/* IO area offsets */
+#define RME96_IO_PLAY_BUFFER      0x0
+#define RME96_IO_REC_BUFFER       0x10000
+#define RME96_IO_CONTROL_REGISTER 0x20000
+#define RME96_IO_ADDITIONAL_REG   0x20004
+#define RME96_IO_CONFIRM_PLAY_IRQ 0x20008
+#define RME96_IO_CONFIRM_REC_IRQ  0x2000C
+#define RME96_IO_SET_PLAY_POS     0x40000
+#define RME96_IO_RESET_PLAY_POS   0x4FFFC
+#define RME96_IO_SET_REC_POS      0x50000
+#define RME96_IO_RESET_REC_POS    0x5FFFC
+#define RME96_IO_GET_PLAY_POS     0x20000
+#define RME96_IO_GET_REC_POS      0x30000
+
+/* Write control register bits */
+#define RME96_WCR_START     (1 << 0)
+#define RME96_WCR_START_2   (1 << 1)
+#define RME96_WCR_GAIN_0    (1 << 2)
+#define RME96_WCR_GAIN_1    (1 << 3)
+#define RME96_WCR_MODE24    (1 << 4)
+#define RME96_WCR_MODE24_2  (1 << 5)
+#define RME96_WCR_BM        (1 << 6)
+#define RME96_WCR_BM_2      (1 << 7)
+#define RME96_WCR_ADAT      (1 << 8)
+#define RME96_WCR_FREQ_0    (1 << 9)
+#define RME96_WCR_FREQ_1    (1 << 10)
+#define RME96_WCR_DS        (1 << 11)
+#define RME96_WCR_PRO       (1 << 12)
+#define RME96_WCR_EMP       (1 << 13)
+#define RME96_WCR_SEL       (1 << 14)
+#define RME96_WCR_MASTER    (1 << 15)
+#define RME96_WCR_PD        (1 << 16)
+#define RME96_WCR_INP_0     (1 << 17)
+#define RME96_WCR_INP_1     (1 << 18)
+#define RME96_WCR_THRU_0    (1 << 19)
+#define RME96_WCR_THRU_1    (1 << 20)
+#define RME96_WCR_THRU_2    (1 << 21)
+#define RME96_WCR_THRU_3    (1 << 22)
+#define RME96_WCR_THRU_4    (1 << 23)
+#define RME96_WCR_THRU_5    (1 << 24)
+#define RME96_WCR_THRU_6    (1 << 25)
+#define RME96_WCR_THRU_7    (1 << 26)
+#define RME96_WCR_DOLBY     (1 << 27)
+#define RME96_WCR_MONITOR_0 (1 << 28)
+#define RME96_WCR_MONITOR_1 (1 << 29)
+#define RME96_WCR_ISEL      (1 << 30)
+#define RME96_WCR_IDIS      (1 << 31)
+
+#define RME96_WCR_BITPOS_GAIN_0 2
+#define RME96_WCR_BITPOS_GAIN_1 3
+#define RME96_WCR_BITPOS_FREQ_0 9
+#define RME96_WCR_BITPOS_FREQ_1 10
+#define RME96_WCR_BITPOS_INP_0 17
+#define RME96_WCR_BITPOS_INP_1 18
+#define RME96_WCR_BITPOS_MONITOR_0 28
+#define RME96_WCR_BITPOS_MONITOR_1 29
+
+/* Read control register bits */
+#define RME96_RCR_AUDIO_ADDR_MASK 0xFFFF
+#define RME96_RCR_IRQ_2     (1 << 16)
+#define RME96_RCR_T_OUT     (1 << 17)
+#define RME96_RCR_DEV_ID_0  (1 << 21)
+#define RME96_RCR_DEV_ID_1  (1 << 22)
+#define RME96_RCR_LOCK      (1 << 23)
+#define RME96_RCR_VERF      (1 << 26)
+#define RME96_RCR_F0        (1 << 27)
+#define RME96_RCR_F1        (1 << 28)
+#define RME96_RCR_F2        (1 << 29)
+#define RME96_RCR_AUTOSYNC  (1 << 30)
+#define RME96_RCR_IRQ       (1 << 31)
+
+#define RME96_RCR_BITPOS_F0 27
+#define RME96_RCR_BITPOS_F1 28
+#define RME96_RCR_BITPOS_F2 29
+
+/* Additonal register bits */
+#define RME96_AR_WSEL       (1 << 0)
+#define RME96_AR_ANALOG     (1 << 1)
+#define RME96_AR_FREQPAD_0  (1 << 2)
+#define RME96_AR_FREQPAD_1  (1 << 3)
+#define RME96_AR_FREQPAD_2  (1 << 4)
+#define RME96_AR_PD2        (1 << 5)
+#define RME96_AR_DAC_EN     (1 << 6)
+#define RME96_AR_CLATCH     (1 << 7)
+#define RME96_AR_CCLK       (1 << 8)
+#define RME96_AR_CDATA      (1 << 9)
+
+#define RME96_AR_BITPOS_F0 2
+#define RME96_AR_BITPOS_F1 3
+#define RME96_AR_BITPOS_F2 4
+
+/* Monitor tracks */
+#define RME96_MONITOR_TRACKS_1_2 0
+#define RME96_MONITOR_TRACKS_3_4 1
+#define RME96_MONITOR_TRACKS_5_6 2
+#define RME96_MONITOR_TRACKS_7_8 3
+
+/* Attenuation */
+#define RME96_ATTENUATION_0 0
+#define RME96_ATTENUATION_6 1
+#define RME96_ATTENUATION_12 2
+#define RME96_ATTENUATION_18 3
+
+/* Input types */
+#define RME96_INPUT_OPTICAL 0
+#define RME96_INPUT_COAXIAL 1
+#define RME96_INPUT_INTERNAL 2
+#define RME96_INPUT_XLR 3
+#define RME96_INPUT_ANALOG 4
+
+/* Clock modes */
+#define RME96_CLOCKMODE_SLAVE 0
+#define RME96_CLOCKMODE_MASTER 1
+#define RME96_CLOCKMODE_WORDCLOCK 2
+
+/* Block sizes in bytes */
+#define RME96_SMALL_BLOCK_SIZE 2048
+#define RME96_LARGE_BLOCK_SIZE 8192
+
+/* Volume control */
+#define RME96_AD1852_VOL_BITS 14
+#define RME96_AD1855_VOL_BITS 10
+
+/*
+ * PCI vendor/device ids, could in the future be defined in <linux/pci.h>,
+ * therefore #ifndef is used.
+ */
+#ifndef PCI_VENDOR_ID_XILINX
+#define PCI_VENDOR_ID_XILINX 0x10ee
+#endif
+#ifndef PCI_DEVICE_ID_DIGI96
+#define PCI_DEVICE_ID_DIGI96 0x3fc0
+#endif
+#ifndef PCI_DEVICE_ID_DIGI96_8
+#define PCI_DEVICE_ID_DIGI96_8 0x3fc1
+#endif
+#ifndef PCI_DEVICE_ID_DIGI96_8_PRO
+#define PCI_DEVICE_ID_DIGI96_8_PRO 0x3fc2
+#endif
+#ifndef PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST
+#define PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST 0x3fc3
+#endif
+
+typedef struct snd_rme96 {
+	spinlock_t    lock;
+	int irq;
+	unsigned long port;
+	void __iomem *iobase;
+	
+	u32 wcreg;    /* cached write control register value */
+	u32 wcreg_spdif;		/* S/PDIF setup */
+	u32 wcreg_spdif_stream;		/* S/PDIF setup (temporary) */
+	u32 rcreg;    /* cached read control register value */
+	u32 areg;     /* cached additional register value */
+	u16 vol[2]; /* cached volume of analog output */
+
+	u8 rev; /* card revision number */
+
+	snd_pcm_substream_t *playback_substream;
+	snd_pcm_substream_t *capture_substream;
+
+	int playback_frlog; /* log2 of framesize */
+	int capture_frlog;
+	
+        size_t playback_periodsize; /* in bytes, zero if not used */
+	size_t capture_periodsize; /* in bytes, zero if not used */
+
+	snd_card_t         *card;
+	snd_pcm_t          *spdif_pcm;
+	snd_pcm_t          *adat_pcm; 
+	struct pci_dev     *pci;
+	snd_kcontrol_t	   *spdif_ctl;
+} rme96_t;
+
+static struct pci_device_id snd_rme96_ids[] = {
+	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_DIGI96,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
+	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_DIGI96_8,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
+	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_DIGI96_8_PRO,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
+	{ PCI_VENDOR_ID_XILINX, PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, }, 
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, snd_rme96_ids);
+
+#define RME96_ISPLAYING(rme96) ((rme96)->wcreg & RME96_WCR_START)
+#define RME96_ISRECORDING(rme96) ((rme96)->wcreg & RME96_WCR_START_2)
+#define	RME96_HAS_ANALOG_IN(rme96) ((rme96)->pci->device == PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST)
+#define	RME96_HAS_ANALOG_OUT(rme96) ((rme96)->pci->device == PCI_DEVICE_ID_DIGI96_8_PRO || \
+				     (rme96)->pci->device == PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST)
+#define	RME96_DAC_IS_1852(rme96) (RME96_HAS_ANALOG_OUT(rme96) && (rme96)->rev >= 4)
+#define	RME96_DAC_IS_1855(rme96) (((rme96)->pci->device == PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST && (rme96)->rev < 4) || \
+			          ((rme96)->pci->device == PCI_DEVICE_ID_DIGI96_8_PRO && (rme96)->rev == 2))
+#define	RME96_185X_MAX_OUT(rme96) ((1 << (RME96_DAC_IS_1852(rme96) ? RME96_AD1852_VOL_BITS : RME96_AD1855_VOL_BITS)) - 1)
+
+static int
+snd_rme96_playback_prepare(snd_pcm_substream_t *substream);
+
+static int
+snd_rme96_capture_prepare(snd_pcm_substream_t *substream);
+
+static int
+snd_rme96_playback_trigger(snd_pcm_substream_t *substream, 
+			   int cmd);
+
+static int
+snd_rme96_capture_trigger(snd_pcm_substream_t *substream, 
+			  int cmd);
+
+static snd_pcm_uframes_t
+snd_rme96_playback_pointer(snd_pcm_substream_t *substream);
+
+static snd_pcm_uframes_t
+snd_rme96_capture_pointer(snd_pcm_substream_t *substream);
+
+static void __devinit 
+snd_rme96_proc_init(rme96_t *rme96);
+
+static int
+snd_rme96_create_switches(snd_card_t *card,
+			  rme96_t *rme96);
+
+static int
+snd_rme96_getinputtype(rme96_t *rme96);
+
+static inline unsigned int
+snd_rme96_playback_ptr(rme96_t *rme96)
+{
+	return (readl(rme96->iobase + RME96_IO_GET_PLAY_POS)
+		& RME96_RCR_AUDIO_ADDR_MASK) >> rme96->playback_frlog;
+}
+
+static inline unsigned int
+snd_rme96_capture_ptr(rme96_t *rme96)
+{
+	return (readl(rme96->iobase + RME96_IO_GET_REC_POS)
+		& RME96_RCR_AUDIO_ADDR_MASK) >> rme96->capture_frlog;
+}
+
+static int
+snd_rme96_ratecode(int rate)
+{
+    switch (rate) {
+    case 32000: return SNDRV_PCM_RATE_32000;
+    case 44100: return SNDRV_PCM_RATE_44100;
+    case 48000: return SNDRV_PCM_RATE_48000;
+    case 64000: return SNDRV_PCM_RATE_64000;
+    case 88200: return SNDRV_PCM_RATE_88200;
+    case 96000: return SNDRV_PCM_RATE_96000;
+    }
+    return 0;
+}
+
+static int
+snd_rme96_playback_silence(snd_pcm_substream_t *substream,
+			   int channel, /* not used (interleaved data) */
+			   snd_pcm_uframes_t pos,
+			   snd_pcm_uframes_t count)
+{
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	count <<= rme96->playback_frlog;
+	pos <<= rme96->playback_frlog;
+	memset_io(rme96->iobase + RME96_IO_PLAY_BUFFER + pos,
+		  0, count);
+	return 0;
+}
+
+static int
+snd_rme96_playback_copy(snd_pcm_substream_t *substream,
+			int channel, /* not used (interleaved data) */
+			snd_pcm_uframes_t pos,
+			void __user *src,
+			snd_pcm_uframes_t count)
+{
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	count <<= rme96->playback_frlog;
+	pos <<= rme96->playback_frlog;
+	copy_from_user_toio(rme96->iobase + RME96_IO_PLAY_BUFFER + pos, src,
+			    count);
+	return 0;
+}
+
+static int
+snd_rme96_capture_copy(snd_pcm_substream_t *substream,
+		       int channel, /* not used (interleaved data) */
+		       snd_pcm_uframes_t pos,
+		       void __user *dst,
+		       snd_pcm_uframes_t count)
+{
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	count <<= rme96->capture_frlog;
+	pos <<= rme96->capture_frlog;
+	copy_to_user_fromio(dst, rme96->iobase + RME96_IO_REC_BUFFER + pos,
+			    count);
+        return 0;
+}
+
+/*
+ * Digital output capabilites (S/PDIF)
+ */
+static snd_pcm_hardware_t snd_rme96_playback_spdif_info =
+{
+	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
+			      SNDRV_PCM_INFO_MMAP_VALID |
+			      SNDRV_PCM_INFO_INTERLEAVED |
+			      SNDRV_PCM_INFO_PAUSE),
+	.formats =	     (SNDRV_PCM_FMTBIT_S16_LE |
+			      SNDRV_PCM_FMTBIT_S32_LE),
+	.rates =	     (SNDRV_PCM_RATE_32000 |
+			      SNDRV_PCM_RATE_44100 | 
+			      SNDRV_PCM_RATE_48000 | 
+			      SNDRV_PCM_RATE_64000 |
+			      SNDRV_PCM_RATE_88200 | 
+			      SNDRV_PCM_RATE_96000),
+	.rate_min =	     32000,
+	.rate_max =	     96000,
+	.channels_min =	     2,
+	.channels_max =	     2,
+	.buffer_bytes_max =  RME96_BUFFER_SIZE,
+	.period_bytes_min =  RME96_SMALL_BLOCK_SIZE,
+	.period_bytes_max =  RME96_LARGE_BLOCK_SIZE,
+	.periods_min =	     RME96_BUFFER_SIZE / RME96_LARGE_BLOCK_SIZE,
+	.periods_max =	     RME96_BUFFER_SIZE / RME96_SMALL_BLOCK_SIZE,
+	.fifo_size =	     0,
+};
+
+/*
+ * Digital input capabilites (S/PDIF)
+ */
+static snd_pcm_hardware_t snd_rme96_capture_spdif_info =
+{
+	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
+			      SNDRV_PCM_INFO_MMAP_VALID |
+			      SNDRV_PCM_INFO_INTERLEAVED |
+			      SNDRV_PCM_INFO_PAUSE),
+	.formats =	     (SNDRV_PCM_FMTBIT_S16_LE |
+			      SNDRV_PCM_FMTBIT_S32_LE),
+	.rates =	     (SNDRV_PCM_RATE_32000 |
+			      SNDRV_PCM_RATE_44100 | 
+			      SNDRV_PCM_RATE_48000 | 
+			      SNDRV_PCM_RATE_64000 |
+			      SNDRV_PCM_RATE_88200 | 
+			      SNDRV_PCM_RATE_96000),
+	.rate_min =	     32000,
+	.rate_max =	     96000,
+	.channels_min =	     2,
+	.channels_max =	     2,
+	.buffer_bytes_max =  RME96_BUFFER_SIZE,
+	.period_bytes_min =  RME96_SMALL_BLOCK_SIZE,
+	.period_bytes_max =  RME96_LARGE_BLOCK_SIZE,
+	.periods_min =	     RME96_BUFFER_SIZE / RME96_LARGE_BLOCK_SIZE,
+	.periods_max =	     RME96_BUFFER_SIZE / RME96_SMALL_BLOCK_SIZE,
+	.fifo_size =	     0,
+};
+
+/*
+ * Digital output capabilites (ADAT)
+ */
+static snd_pcm_hardware_t snd_rme96_playback_adat_info =
+{
+	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
+			      SNDRV_PCM_INFO_MMAP_VALID |
+			      SNDRV_PCM_INFO_INTERLEAVED |
+			      SNDRV_PCM_INFO_PAUSE),
+	.formats =	     (SNDRV_PCM_FMTBIT_S16_LE |
+			      SNDRV_PCM_FMTBIT_S32_LE),
+	.rates =             (SNDRV_PCM_RATE_44100 | 
+			      SNDRV_PCM_RATE_48000),
+	.rate_min =          44100,
+	.rate_max =          48000,
+	.channels_min =      8,
+	.channels_max =	     8,
+	.buffer_bytes_max =  RME96_BUFFER_SIZE,
+	.period_bytes_min =  RME96_SMALL_BLOCK_SIZE,
+	.period_bytes_max =  RME96_LARGE_BLOCK_SIZE,
+	.periods_min =	     RME96_BUFFER_SIZE / RME96_LARGE_BLOCK_SIZE,
+	.periods_max =	     RME96_BUFFER_SIZE / RME96_SMALL_BLOCK_SIZE,
+	.fifo_size =	     0,
+};
+
+/*
+ * Digital input capabilites (ADAT)
+ */
+static snd_pcm_hardware_t snd_rme96_capture_adat_info =
+{
+	.info =		     (SNDRV_PCM_INFO_MMAP_IOMEM |
+			      SNDRV_PCM_INFO_MMAP_VALID |
+			      SNDRV_PCM_INFO_INTERLEAVED |
+			      SNDRV_PCM_INFO_PAUSE),
+	.formats =	     (SNDRV_PCM_FMTBIT_S16_LE |
+			      SNDRV_PCM_FMTBIT_S32_LE),
+	.rates =	     (SNDRV_PCM_RATE_44100 | 
+			      SNDRV_PCM_RATE_48000),
+	.rate_min =          44100,
+	.rate_max =          48000,
+	.channels_min =      8,
+	.channels_max =	     8,
+	.buffer_bytes_max =  RME96_BUFFER_SIZE,
+	.period_bytes_min =  RME96_SMALL_BLOCK_SIZE,
+	.period_bytes_max =  RME96_LARGE_BLOCK_SIZE,
+	.periods_min =	     RME96_BUFFER_SIZE / RME96_LARGE_BLOCK_SIZE,
+	.periods_max =	     RME96_BUFFER_SIZE / RME96_SMALL_BLOCK_SIZE,
+	.fifo_size =         0,
+};
+
+/*
+ * The CDATA, CCLK and CLATCH bits can be used to write to the SPI interface
+ * of the AD1852 or AD1852 D/A converter on the board.  CDATA must be set up
+ * on the falling edge of CCLK and be stable on the rising edge.  The rising
+ * edge of CLATCH after the last data bit clocks in the whole data word.
+ * A fast processor could probably drive the SPI interface faster than the
+ * DAC can handle (3MHz for the 1855, unknown for the 1852).  The udelay(1)
+ * limits the data rate to 500KHz and only causes a delay of 33 microsecs.
+ *
+ * NOTE: increased delay from 1 to 10, since there where problems setting
+ * the volume.
+ */
+static void
+snd_rme96_write_SPI(rme96_t *rme96, u16 val)
+{
+	int i;
+
+	for (i = 0; i < 16; i++) {
+		if (val & 0x8000) {
+			rme96->areg |= RME96_AR_CDATA;
+		} else {
+			rme96->areg &= ~RME96_AR_CDATA;
+		}
+		rme96->areg &= ~(RME96_AR_CCLK | RME96_AR_CLATCH);
+		writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
+		udelay(10);
+		rme96->areg |= RME96_AR_CCLK;
+		writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
+		udelay(10);
+		val <<= 1;
+	}
+	rme96->areg &= ~(RME96_AR_CCLK | RME96_AR_CDATA);
+	rme96->areg |= RME96_AR_CLATCH;
+	writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
+	udelay(10);
+	rme96->areg &= ~RME96_AR_CLATCH;
+	writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
+}
+
+static void
+snd_rme96_apply_dac_volume(rme96_t *rme96)
+{
+	if (RME96_DAC_IS_1852(rme96)) {
+		snd_rme96_write_SPI(rme96, (rme96->vol[0] << 2) | 0x0);
+		snd_rme96_write_SPI(rme96, (rme96->vol[1] << 2) | 0x2);
+	} else if (RME96_DAC_IS_1855(rme96)) {
+		snd_rme96_write_SPI(rme96, (rme96->vol[0] & 0x3FF) | 0x000);
+		snd_rme96_write_SPI(rme96, (rme96->vol[1] & 0x3FF) | 0x400);
+	}
+}
+
+static void
+snd_rme96_reset_dac(rme96_t *rme96)
+{
+	writel(rme96->wcreg | RME96_WCR_PD,
+	       rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+}
+
+static int
+snd_rme96_getmontracks(rme96_t *rme96)
+{
+	return ((rme96->wcreg >> RME96_WCR_BITPOS_MONITOR_0) & 1) +
+		(((rme96->wcreg >> RME96_WCR_BITPOS_MONITOR_1) & 1) << 1);
+}
+
+static int
+snd_rme96_setmontracks(rme96_t *rme96,
+		       int montracks)
+{
+	if (montracks & 1) {
+		rme96->wcreg |= RME96_WCR_MONITOR_0;
+	} else {
+		rme96->wcreg &= ~RME96_WCR_MONITOR_0;
+	}
+	if (montracks & 2) {
+		rme96->wcreg |= RME96_WCR_MONITOR_1;
+	} else {
+		rme96->wcreg &= ~RME96_WCR_MONITOR_1;
+	}
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	return 0;
+}
+
+static int
+snd_rme96_getattenuation(rme96_t *rme96)
+{
+	return ((rme96->wcreg >> RME96_WCR_BITPOS_GAIN_0) & 1) +
+		(((rme96->wcreg >> RME96_WCR_BITPOS_GAIN_1) & 1) << 1);
+}
+
+static int
+snd_rme96_setattenuation(rme96_t *rme96,
+			 int attenuation)
+{
+	switch (attenuation) {
+	case 0:
+		rme96->wcreg = (rme96->wcreg & ~RME96_WCR_GAIN_0) &
+			~RME96_WCR_GAIN_1;
+		break;
+	case 1:
+		rme96->wcreg = (rme96->wcreg | RME96_WCR_GAIN_0) &
+			~RME96_WCR_GAIN_1;
+		break;
+	case 2:
+		rme96->wcreg = (rme96->wcreg & ~RME96_WCR_GAIN_0) |
+			RME96_WCR_GAIN_1;
+		break;
+	case 3:
+		rme96->wcreg = (rme96->wcreg | RME96_WCR_GAIN_0) |
+			RME96_WCR_GAIN_1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	return 0;
+}
+
+static int
+snd_rme96_capture_getrate(rme96_t *rme96,
+			  int *is_adat)
+{	
+	int n, rate;
+
+	*is_adat = 0;
+	if (rme96->areg & RME96_AR_ANALOG) {
+		/* Analog input, overrides S/PDIF setting */
+		n = ((rme96->areg >> RME96_AR_BITPOS_F0) & 1) +
+			(((rme96->areg >> RME96_AR_BITPOS_F1) & 1) << 1);
+		switch (n) {
+		case 1:
+			rate = 32000;
+			break;
+		case 2:
+			rate = 44100;
+			break;
+		case 3:
+			rate = 48000;
+			break;
+		default:
+			return -1;
+		}
+		return (rme96->areg & RME96_AR_BITPOS_F2) ? rate << 1 : rate;
+	}
+
+	rme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	if (rme96->rcreg & RME96_RCR_LOCK) {
+		/* ADAT rate */
+		*is_adat = 1;
+		if (rme96->rcreg & RME96_RCR_T_OUT) {
+			return 48000;
+		}
+		return 44100;
+	}
+
+	if (rme96->rcreg & RME96_RCR_VERF) {
+		return -1;
+	}
+	
+	/* S/PDIF rate */
+	n = ((rme96->rcreg >> RME96_RCR_BITPOS_F0) & 1) +
+		(((rme96->rcreg >> RME96_RCR_BITPOS_F1) & 1) << 1) +
+		(((rme96->rcreg >> RME96_RCR_BITPOS_F2) & 1) << 2);
+	
+	switch (n) {
+	case 0:		
+		if (rme96->rcreg & RME96_RCR_T_OUT) {
+			return 64000;
+		}
+		return -1;
+	case 3: return 96000;
+	case 4: return 88200;
+	case 5: return 48000;
+	case 6: return 44100;
+	case 7: return 32000;
+	default:
+		break;
+	}
+	return -1;
+}
+
+static int
+snd_rme96_playback_getrate(rme96_t *rme96)
+{
+	int rate, dummy;
+
+	if (!(rme96->wcreg & RME96_WCR_MASTER) &&
+            snd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG &&
+	    (rate = snd_rme96_capture_getrate(rme96, &dummy)) > 0)
+	{
+	        /* slave clock */
+	        return rate;
+	}
+	rate = ((rme96->wcreg >> RME96_WCR_BITPOS_FREQ_0) & 1) +
+		(((rme96->wcreg >> RME96_WCR_BITPOS_FREQ_1) & 1) << 1);
+	switch (rate) {
+	case 1:
+		rate = 32000;
+		break;
+	case 2:
+		rate = 44100;
+		break;
+	case 3:
+		rate = 48000;
+		break;
+	default:
+		return -1;
+	}
+	return (rme96->wcreg & RME96_WCR_DS) ? rate << 1 : rate;
+}
+
+static int
+snd_rme96_playback_setrate(rme96_t *rme96,
+			   int rate)
+{
+	int ds;
+
+	ds = rme96->wcreg & RME96_WCR_DS;
+	switch (rate) {
+	case 32000:
+		rme96->wcreg &= ~RME96_WCR_DS;
+		rme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_0) &
+			~RME96_WCR_FREQ_1;
+		break;
+	case 44100:
+		rme96->wcreg &= ~RME96_WCR_DS;
+		rme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_1) &
+			~RME96_WCR_FREQ_0;
+		break;
+	case 48000:
+		rme96->wcreg &= ~RME96_WCR_DS;
+		rme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_0) |
+			RME96_WCR_FREQ_1;
+		break;
+	case 64000:
+		rme96->wcreg |= RME96_WCR_DS;
+		rme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_0) &
+			~RME96_WCR_FREQ_1;
+		break;
+	case 88200:
+		rme96->wcreg |= RME96_WCR_DS;
+		rme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_1) &
+			~RME96_WCR_FREQ_0;
+		break;
+	case 96000:
+		rme96->wcreg |= RME96_WCR_DS;
+		rme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_0) |
+			RME96_WCR_FREQ_1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	if ((!ds && rme96->wcreg & RME96_WCR_DS) ||
+	    (ds && !(rme96->wcreg & RME96_WCR_DS)))
+	{
+		/* change to/from double-speed: reset the DAC (if available) */
+		snd_rme96_reset_dac(rme96);
+	} else {
+		writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	}
+	return 0;
+}
+
+static int
+snd_rme96_capture_analog_setrate(rme96_t *rme96,
+				 int rate)
+{
+	switch (rate) {
+	case 32000:
+		rme96->areg = ((rme96->areg | RME96_AR_FREQPAD_0) &
+			       ~RME96_AR_FREQPAD_1) & ~RME96_AR_FREQPAD_2;
+		break;
+	case 44100:
+		rme96->areg = ((rme96->areg & ~RME96_AR_FREQPAD_0) |
+			       RME96_AR_FREQPAD_1) & ~RME96_AR_FREQPAD_2;
+		break;
+	case 48000:
+		rme96->areg = ((rme96->areg | RME96_AR_FREQPAD_0) |
+			       RME96_AR_FREQPAD_1) & ~RME96_AR_FREQPAD_2;
+		break;
+	case 64000:
+		if (rme96->rev < 4) {
+			return -EINVAL;
+		}
+		rme96->areg = ((rme96->areg | RME96_AR_FREQPAD_0) &
+			       ~RME96_AR_FREQPAD_1) | RME96_AR_FREQPAD_2;
+		break;
+	case 88200:
+		if (rme96->rev < 4) {
+			return -EINVAL;
+		}
+		rme96->areg = ((rme96->areg & ~RME96_AR_FREQPAD_0) |
+			       RME96_AR_FREQPAD_1) | RME96_AR_FREQPAD_2;
+		break;
+	case 96000:
+		rme96->areg = ((rme96->areg | RME96_AR_FREQPAD_0) |
+			       RME96_AR_FREQPAD_1) | RME96_AR_FREQPAD_2;
+		break;
+	default:
+		return -EINVAL;
+	}
+	writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
+	return 0;
+}
+
+static int
+snd_rme96_setclockmode(rme96_t *rme96,
+		       int mode)
+{
+	switch (mode) {
+	case RME96_CLOCKMODE_SLAVE:
+	        /* AutoSync */ 
+		rme96->wcreg &= ~RME96_WCR_MASTER;
+		rme96->areg &= ~RME96_AR_WSEL;
+		break;
+	case RME96_CLOCKMODE_MASTER:
+	        /* Internal */
+		rme96->wcreg |= RME96_WCR_MASTER;
+		rme96->areg &= ~RME96_AR_WSEL;
+		break;
+	case RME96_CLOCKMODE_WORDCLOCK:
+		/* Word clock is a master mode */
+		rme96->wcreg |= RME96_WCR_MASTER; 
+		rme96->areg |= RME96_AR_WSEL;
+		break;
+	default:
+		return -EINVAL;
+	}
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
+	return 0;
+}
+
+static int
+snd_rme96_getclockmode(rme96_t *rme96)
+{
+	if (rme96->areg & RME96_AR_WSEL) {
+		return RME96_CLOCKMODE_WORDCLOCK;
+	}
+	return (rme96->wcreg & RME96_WCR_MASTER) ? RME96_CLOCKMODE_MASTER :
+		RME96_CLOCKMODE_SLAVE;
+}
+
+static int
+snd_rme96_setinputtype(rme96_t *rme96,
+		       int type)
+{
+	int n;
+
+	switch (type) {
+	case RME96_INPUT_OPTICAL:
+		rme96->wcreg = (rme96->wcreg & ~RME96_WCR_INP_0) &
+			~RME96_WCR_INP_1;
+		break;
+	case RME96_INPUT_COAXIAL:
+		rme96->wcreg = (rme96->wcreg | RME96_WCR_INP_0) &
+			~RME96_WCR_INP_1;
+		break;
+	case RME96_INPUT_INTERNAL:
+		rme96->wcreg = (rme96->wcreg & ~RME96_WCR_INP_0) |
+			RME96_WCR_INP_1;
+		break;
+	case RME96_INPUT_XLR:
+		if ((rme96->pci->device != PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST &&
+		     rme96->pci->device != PCI_DEVICE_ID_DIGI96_8_PRO) ||
+		    (rme96->pci->device == PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST &&
+		     rme96->rev > 4))
+		{
+			/* Only Digi96/8 PRO and Digi96/8 PAD supports XLR */
+			return -EINVAL;
+		}
+		rme96->wcreg = (rme96->wcreg | RME96_WCR_INP_0) |
+			RME96_WCR_INP_1;
+		break;
+	case RME96_INPUT_ANALOG:
+		if (!RME96_HAS_ANALOG_IN(rme96)) {
+			return -EINVAL;
+		}
+		rme96->areg |= RME96_AR_ANALOG;
+		writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
+		if (rme96->rev < 4) {
+			/*
+			 * Revision less than 004 does not support 64 and
+			 * 88.2 kHz
+			 */
+			if (snd_rme96_capture_getrate(rme96, &n) == 88200) {
+				snd_rme96_capture_analog_setrate(rme96, 44100);
+			}
+			if (snd_rme96_capture_getrate(rme96, &n) == 64000) {
+				snd_rme96_capture_analog_setrate(rme96, 32000);
+			}
+		}
+		return 0;
+	default:
+		return -EINVAL;
+	}
+	if (type != RME96_INPUT_ANALOG && RME96_HAS_ANALOG_IN(rme96)) {
+		rme96->areg &= ~RME96_AR_ANALOG;
+		writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
+	}
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	return 0;
+}
+
+static int
+snd_rme96_getinputtype(rme96_t *rme96)
+{
+	if (rme96->areg & RME96_AR_ANALOG) {
+		return RME96_INPUT_ANALOG;
+	}
+	return ((rme96->wcreg >> RME96_WCR_BITPOS_INP_0) & 1) +
+		(((rme96->wcreg >> RME96_WCR_BITPOS_INP_1) & 1) << 1);
+}
+
+static void
+snd_rme96_setframelog(rme96_t *rme96,
+		      int n_channels,
+		      int is_playback)
+{
+	int frlog;
+	
+	if (n_channels == 2) {
+		frlog = 1;
+	} else {
+		/* assume 8 channels */
+		frlog = 3;
+	}
+	if (is_playback) {
+		frlog += (rme96->wcreg & RME96_WCR_MODE24) ? 2 : 1;
+		rme96->playback_frlog = frlog;
+	} else {
+		frlog += (rme96->wcreg & RME96_WCR_MODE24_2) ? 2 : 1;
+		rme96->capture_frlog = frlog;
+	}
+}
+
+static int
+snd_rme96_playback_setformat(rme96_t *rme96,
+			     int format)
+{
+	switch (format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		rme96->wcreg &= ~RME96_WCR_MODE24;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		rme96->wcreg |= RME96_WCR_MODE24;
+		break;
+	default:
+		return -EINVAL;
+	}
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	return 0;
+}
+
+static int
+snd_rme96_capture_setformat(rme96_t *rme96,
+			    int format)
+{
+	switch (format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		rme96->wcreg &= ~RME96_WCR_MODE24_2;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		rme96->wcreg |= RME96_WCR_MODE24_2;
+		break;
+	default:
+		return -EINVAL;
+	}
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	return 0;
+}
+
+static void
+snd_rme96_set_period_properties(rme96_t *rme96,
+				size_t period_bytes)
+{
+	switch (period_bytes) {
+	case RME96_LARGE_BLOCK_SIZE:
+		rme96->wcreg &= ~RME96_WCR_ISEL;
+		break;
+	case RME96_SMALL_BLOCK_SIZE:
+		rme96->wcreg |= RME96_WCR_ISEL;
+		break;
+	default:
+		snd_BUG();
+		break;
+	}
+	rme96->wcreg &= ~RME96_WCR_IDIS;
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+}
+
+static int
+snd_rme96_playback_hw_params(snd_pcm_substream_t *substream,
+			     snd_pcm_hw_params_t *params)
+{
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err, rate, dummy;
+
+	runtime->dma_area = (void *)(rme96->iobase + RME96_IO_PLAY_BUFFER);
+	runtime->dma_addr = rme96->port + RME96_IO_PLAY_BUFFER;
+	runtime->dma_bytes = RME96_BUFFER_SIZE;
+
+	spin_lock_irq(&rme96->lock);
+	if (!(rme96->wcreg & RME96_WCR_MASTER) &&
+            snd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG &&
+	    (rate = snd_rme96_capture_getrate(rme96, &dummy)) > 0)
+	{
+                /* slave clock */
+                if ((int)params_rate(params) != rate) {
+			spin_unlock_irq(&rme96->lock);
+			return -EIO;                    
+                }
+	} else if ((err = snd_rme96_playback_setrate(rme96, params_rate(params))) < 0) {
+		spin_unlock_irq(&rme96->lock);
+		return err;
+	}
+	if ((err = snd_rme96_playback_setformat(rme96, params_format(params))) < 0) {
+		spin_unlock_irq(&rme96->lock);
+		return err;
+	}
+	snd_rme96_setframelog(rme96, params_channels(params), 1);
+	if (rme96->capture_periodsize != 0) {
+		if (params_period_size(params) << rme96->playback_frlog !=
+		    rme96->capture_periodsize)
+		{
+			spin_unlock_irq(&rme96->lock);
+			return -EBUSY;
+		}
+	}
+	rme96->playback_periodsize =
+		params_period_size(params) << rme96->playback_frlog;
+	snd_rme96_set_period_properties(rme96, rme96->playback_periodsize);
+	/* S/PDIF setup */
+	if ((rme96->wcreg & RME96_WCR_ADAT) == 0) {
+		rme96->wcreg &= ~(RME96_WCR_PRO | RME96_WCR_DOLBY | RME96_WCR_EMP);
+		writel(rme96->wcreg |= rme96->wcreg_spdif_stream, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	}
+	spin_unlock_irq(&rme96->lock);
+		
+	return 0;
+}
+
+static int
+snd_rme96_capture_hw_params(snd_pcm_substream_t *substream,
+			    snd_pcm_hw_params_t *params)
+{
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int err, isadat, rate;
+	
+	runtime->dma_area = (void *)(rme96->iobase + RME96_IO_REC_BUFFER);
+	runtime->dma_addr = rme96->port + RME96_IO_REC_BUFFER;
+	runtime->dma_bytes = RME96_BUFFER_SIZE;
+
+	spin_lock_irq(&rme96->lock);
+	if ((err = snd_rme96_capture_setformat(rme96, params_format(params))) < 0) {
+		spin_unlock_irq(&rme96->lock);
+		return err;
+	}
+	if (snd_rme96_getinputtype(rme96) == RME96_INPUT_ANALOG) {
+		if ((err = snd_rme96_capture_analog_setrate(rme96,
+							    params_rate(params))) < 0)
+		{
+			spin_unlock_irq(&rme96->lock);
+			return err;
+		}
+	} else if ((rate = snd_rme96_capture_getrate(rme96, &isadat)) > 0) {
+                if ((int)params_rate(params) != rate) {
+			spin_unlock_irq(&rme96->lock);
+			return -EIO;                    
+                }
+                if ((isadat && runtime->hw.channels_min == 2) ||
+                    (!isadat && runtime->hw.channels_min == 8))
+                {
+			spin_unlock_irq(&rme96->lock);
+			return -EIO;
+                }
+        }
+	snd_rme96_setframelog(rme96, params_channels(params), 0);
+	if (rme96->playback_periodsize != 0) {
+		if (params_period_size(params) << rme96->capture_frlog !=
+		    rme96->playback_periodsize)
+		{
+			spin_unlock_irq(&rme96->lock);
+			return -EBUSY;
+		}
+	}
+	rme96->capture_periodsize =
+		params_period_size(params) << rme96->capture_frlog;
+	snd_rme96_set_period_properties(rme96, rme96->capture_periodsize);
+	spin_unlock_irq(&rme96->lock);
+
+	return 0;
+}
+
+static void
+snd_rme96_playback_start(rme96_t *rme96,
+			 int from_pause)
+{
+	if (!from_pause) {
+		writel(0, rme96->iobase + RME96_IO_RESET_PLAY_POS);
+	}
+
+	rme96->wcreg |= RME96_WCR_START;
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+}
+
+static void
+snd_rme96_capture_start(rme96_t *rme96,
+			int from_pause)
+{
+	if (!from_pause) {
+		writel(0, rme96->iobase + RME96_IO_RESET_REC_POS);
+	}
+
+	rme96->wcreg |= RME96_WCR_START_2;
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+}
+
+static void
+snd_rme96_playback_stop(rme96_t *rme96)
+{
+	/*
+	 * Check if there is an unconfirmed IRQ, if so confirm it, or else
+	 * the hardware will not stop generating interrupts
+	 */
+	rme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	if (rme96->rcreg & RME96_RCR_IRQ) {
+		writel(0, rme96->iobase + RME96_IO_CONFIRM_PLAY_IRQ);
+	}	
+	rme96->wcreg &= ~RME96_WCR_START;
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+}
+
+static void
+snd_rme96_capture_stop(rme96_t *rme96)
+{
+	rme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	if (rme96->rcreg & RME96_RCR_IRQ_2) {
+		writel(0, rme96->iobase + RME96_IO_CONFIRM_REC_IRQ);
+	}	
+	rme96->wcreg &= ~RME96_WCR_START_2;
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+}
+
+static irqreturn_t
+snd_rme96_interrupt(int irq,
+		    void *dev_id,
+		    struct pt_regs *regs)
+{
+	rme96_t *rme96 = (rme96_t *)dev_id;
+
+	rme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	/* fastpath out, to ease interrupt sharing */
+	if (!((rme96->rcreg & RME96_RCR_IRQ) ||
+	      (rme96->rcreg & RME96_RCR_IRQ_2)))
+	{
+		return IRQ_NONE;
+	}
+	
+	if (rme96->rcreg & RME96_RCR_IRQ) {
+		/* playback */
+                snd_pcm_period_elapsed(rme96->playback_substream);
+		writel(0, rme96->iobase + RME96_IO_CONFIRM_PLAY_IRQ);
+	}
+	if (rme96->rcreg & RME96_RCR_IRQ_2) {
+		/* capture */
+		snd_pcm_period_elapsed(rme96->capture_substream);		
+		writel(0, rme96->iobase + RME96_IO_CONFIRM_REC_IRQ);
+	}
+	return IRQ_HANDLED;
+}
+
+static unsigned int period_bytes[] = { RME96_SMALL_BLOCK_SIZE, RME96_LARGE_BLOCK_SIZE };
+
+static snd_pcm_hw_constraint_list_t hw_constraints_period_bytes = {
+	.count = ARRAY_SIZE(period_bytes),
+	.list = period_bytes,
+	.mask = 0
+};
+
+static int
+snd_rme96_playback_spdif_open(snd_pcm_substream_t *substream)
+{
+        int rate, dummy;
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	snd_pcm_set_sync(substream);
+
+	spin_lock_irq(&rme96->lock);	
+        if (rme96->playback_substream != NULL) {
+		spin_unlock_irq(&rme96->lock);
+                return -EBUSY;
+        }
+	rme96->wcreg &= ~RME96_WCR_ADAT;
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	rme96->playback_substream = substream;
+	spin_unlock_irq(&rme96->lock);
+
+	runtime->hw = snd_rme96_playback_spdif_info;
+	if (!(rme96->wcreg & RME96_WCR_MASTER) &&
+            snd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG &&
+	    (rate = snd_rme96_capture_getrate(rme96, &dummy)) > 0)
+	{
+                /* slave clock */
+                runtime->hw.rates = snd_rme96_ratecode(rate);
+                runtime->hw.rate_min = rate;
+                runtime->hw.rate_max = rate;
+	}        
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, RME96_BUFFER_SIZE, RME96_BUFFER_SIZE);
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_bytes);
+
+	rme96->wcreg_spdif_stream = rme96->wcreg_spdif;
+	rme96->spdif_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+	snd_ctl_notify(rme96->card, SNDRV_CTL_EVENT_MASK_VALUE |
+		       SNDRV_CTL_EVENT_MASK_INFO, &rme96->spdif_ctl->id);
+	return 0;
+}
+
+static int
+snd_rme96_capture_spdif_open(snd_pcm_substream_t *substream)
+{
+        int isadat, rate;
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	snd_pcm_set_sync(substream);
+
+	runtime->hw = snd_rme96_capture_spdif_info;
+        if (snd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG &&
+            (rate = snd_rme96_capture_getrate(rme96, &isadat)) > 0)
+        {
+                if (isadat) {
+                        return -EIO;
+                }
+                runtime->hw.rates = snd_rme96_ratecode(rate);
+                runtime->hw.rate_min = rate;
+                runtime->hw.rate_max = rate;
+        }
+        
+	spin_lock_irq(&rme96->lock);
+        if (rme96->capture_substream != NULL) {
+		spin_unlock_irq(&rme96->lock);
+                return -EBUSY;
+        }
+	rme96->capture_substream = substream;
+	spin_unlock_irq(&rme96->lock);
+	
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, RME96_BUFFER_SIZE, RME96_BUFFER_SIZE);
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_bytes);
+
+	return 0;
+}
+
+static int
+snd_rme96_playback_adat_open(snd_pcm_substream_t *substream)
+{
+        int rate, dummy;
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;        
+	
+	snd_pcm_set_sync(substream);
+
+	spin_lock_irq(&rme96->lock);	
+        if (rme96->playback_substream != NULL) {
+		spin_unlock_irq(&rme96->lock);
+                return -EBUSY;
+        }
+	rme96->wcreg |= RME96_WCR_ADAT;
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	rme96->playback_substream = substream;
+	spin_unlock_irq(&rme96->lock);
+	
+	runtime->hw = snd_rme96_playback_adat_info;
+	if (!(rme96->wcreg & RME96_WCR_MASTER) &&
+            snd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG &&
+	    (rate = snd_rme96_capture_getrate(rme96, &dummy)) > 0)
+	{
+                /* slave clock */
+                runtime->hw.rates = snd_rme96_ratecode(rate);
+                runtime->hw.rate_min = rate;
+                runtime->hw.rate_max = rate;
+	}        
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, RME96_BUFFER_SIZE, RME96_BUFFER_SIZE);
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_bytes);
+	return 0;
+}
+
+static int
+snd_rme96_capture_adat_open(snd_pcm_substream_t *substream)
+{
+        int isadat, rate;
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	snd_pcm_set_sync(substream);
+
+	runtime->hw = snd_rme96_capture_adat_info;
+        if (snd_rme96_getinputtype(rme96) == RME96_INPUT_ANALOG) {
+                /* makes no sense to use analog input. Note that analog
+                   expension cards AEB4/8-I are RME96_INPUT_INTERNAL */
+                return -EIO;
+        }
+        if ((rate = snd_rme96_capture_getrate(rme96, &isadat)) > 0) {
+                if (!isadat) {
+                        return -EIO;
+                }
+                runtime->hw.rates = snd_rme96_ratecode(rate);
+                runtime->hw.rate_min = rate;
+                runtime->hw.rate_max = rate;
+        }
+        
+	spin_lock_irq(&rme96->lock);	
+        if (rme96->capture_substream != NULL) {
+		spin_unlock_irq(&rme96->lock);
+                return -EBUSY;
+        }
+	rme96->capture_substream = substream;
+	spin_unlock_irq(&rme96->lock);
+
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, RME96_BUFFER_SIZE, RME96_BUFFER_SIZE);
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, &hw_constraints_period_bytes);
+	return 0;
+}
+
+static int
+snd_rme96_playback_close(snd_pcm_substream_t *substream)
+{
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	int spdif = 0;
+
+	spin_lock_irq(&rme96->lock);	
+	if (RME96_ISPLAYING(rme96)) {
+		snd_rme96_playback_stop(rme96);
+	}
+	rme96->playback_substream = NULL;
+	rme96->playback_periodsize = 0;
+	spdif = (rme96->wcreg & RME96_WCR_ADAT) == 0;
+	spin_unlock_irq(&rme96->lock);
+	if (spdif) {
+		rme96->spdif_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+		snd_ctl_notify(rme96->card, SNDRV_CTL_EVENT_MASK_VALUE |
+			       SNDRV_CTL_EVENT_MASK_INFO, &rme96->spdif_ctl->id);
+	}
+	return 0;
+}
+
+static int
+snd_rme96_capture_close(snd_pcm_substream_t *substream)
+{
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	
+	spin_lock_irq(&rme96->lock);	
+	if (RME96_ISRECORDING(rme96)) {
+		snd_rme96_capture_stop(rme96);
+	}
+	rme96->capture_substream = NULL;
+	rme96->capture_periodsize = 0;
+	spin_unlock_irq(&rme96->lock);
+	return 0;
+}
+
+static int
+snd_rme96_playback_prepare(snd_pcm_substream_t *substream)
+{
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	
+	spin_lock_irq(&rme96->lock);	
+	if (RME96_ISPLAYING(rme96)) {
+		snd_rme96_playback_stop(rme96);
+	}
+	writel(0, rme96->iobase + RME96_IO_RESET_PLAY_POS);
+	spin_unlock_irq(&rme96->lock);
+	return 0;
+}
+
+static int
+snd_rme96_capture_prepare(snd_pcm_substream_t *substream)
+{
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	
+	spin_lock_irq(&rme96->lock);	
+	if (RME96_ISRECORDING(rme96)) {
+		snd_rme96_capture_stop(rme96);
+	}
+	writel(0, rme96->iobase + RME96_IO_RESET_REC_POS);
+	spin_unlock_irq(&rme96->lock);
+	return 0;
+}
+
+static int
+snd_rme96_playback_trigger(snd_pcm_substream_t *substream, 
+			   int cmd)
+{
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		if (!RME96_ISPLAYING(rme96)) {
+			if (substream != rme96->playback_substream) {
+				return -EBUSY;
+			}
+			snd_rme96_playback_start(rme96, 0);
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+		if (RME96_ISPLAYING(rme96)) {
+			if (substream != rme96->playback_substream) {
+				return -EBUSY;
+			}
+			snd_rme96_playback_stop(rme96);
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (RME96_ISPLAYING(rme96)) {
+			snd_rme96_playback_stop(rme96);
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (!RME96_ISPLAYING(rme96)) {
+			snd_rme96_playback_start(rme96, 1);
+		}
+		break;
+		
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int
+snd_rme96_capture_trigger(snd_pcm_substream_t *substream, 
+			  int cmd)
+{
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		if (!RME96_ISRECORDING(rme96)) {
+			if (substream != rme96->capture_substream) {
+				return -EBUSY;
+			}
+			snd_rme96_capture_start(rme96, 0);
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+		if (RME96_ISRECORDING(rme96)) {
+			if (substream != rme96->capture_substream) {
+				return -EBUSY;
+			}
+			snd_rme96_capture_stop(rme96);
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (RME96_ISRECORDING(rme96)) {
+			snd_rme96_capture_stop(rme96);
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (!RME96_ISRECORDING(rme96)) {
+			snd_rme96_capture_start(rme96, 1);
+		}
+		break;
+		
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static snd_pcm_uframes_t
+snd_rme96_playback_pointer(snd_pcm_substream_t *substream)
+{
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	return snd_rme96_playback_ptr(rme96);
+}
+
+static snd_pcm_uframes_t
+snd_rme96_capture_pointer(snd_pcm_substream_t *substream)
+{
+	rme96_t *rme96 = snd_pcm_substream_chip(substream);
+	return snd_rme96_capture_ptr(rme96);
+}
+
+static snd_pcm_ops_t snd_rme96_playback_spdif_ops = {
+	.open =		snd_rme96_playback_spdif_open,
+	.close =	snd_rme96_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_rme96_playback_hw_params,
+	.prepare =	snd_rme96_playback_prepare,
+	.trigger =	snd_rme96_playback_trigger,
+	.pointer =	snd_rme96_playback_pointer,
+	.copy =		snd_rme96_playback_copy,
+	.silence =	snd_rme96_playback_silence,
+	.mmap =		snd_pcm_lib_mmap_iomem,
+};
+
+static snd_pcm_ops_t snd_rme96_capture_spdif_ops = {
+	.open =		snd_rme96_capture_spdif_open,
+	.close =	snd_rme96_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_rme96_capture_hw_params,
+	.prepare =	snd_rme96_capture_prepare,
+	.trigger =	snd_rme96_capture_trigger,
+	.pointer =	snd_rme96_capture_pointer,
+	.copy =		snd_rme96_capture_copy,
+	.mmap =		snd_pcm_lib_mmap_iomem,
+};
+
+static snd_pcm_ops_t snd_rme96_playback_adat_ops = {
+	.open =		snd_rme96_playback_adat_open,
+	.close =	snd_rme96_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_rme96_playback_hw_params,
+	.prepare =	snd_rme96_playback_prepare,
+	.trigger =	snd_rme96_playback_trigger,
+	.pointer =	snd_rme96_playback_pointer,
+	.copy =		snd_rme96_playback_copy,
+	.silence =	snd_rme96_playback_silence,
+	.mmap =		snd_pcm_lib_mmap_iomem,
+};
+
+static snd_pcm_ops_t snd_rme96_capture_adat_ops = {
+	.open =		snd_rme96_capture_adat_open,
+	.close =	snd_rme96_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_rme96_capture_hw_params,
+	.prepare =	snd_rme96_capture_prepare,
+	.trigger =	snd_rme96_capture_trigger,
+	.pointer =	snd_rme96_capture_pointer,
+	.copy =		snd_rme96_capture_copy,
+	.mmap =		snd_pcm_lib_mmap_iomem,
+};
+
+static void
+snd_rme96_free(void *private_data)
+{
+	rme96_t *rme96 = (rme96_t *)private_data;
+
+	if (rme96 == NULL) {
+	        return;
+	}
+	if (rme96->irq >= 0) {
+		snd_rme96_playback_stop(rme96);
+		snd_rme96_capture_stop(rme96);
+		rme96->areg &= ~RME96_AR_DAC_EN;
+		writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
+		free_irq(rme96->irq, (void *)rme96);
+		rme96->irq = -1;
+	}
+	if (rme96->iobase) {
+		iounmap(rme96->iobase);
+		rme96->iobase = NULL;
+	}
+	if (rme96->port) {
+		pci_release_regions(rme96->pci);
+		rme96->port = 0;
+	}
+	pci_disable_device(rme96->pci);
+}
+
+static void
+snd_rme96_free_spdif_pcm(snd_pcm_t *pcm)
+{
+	rme96_t *rme96 = (rme96_t *) pcm->private_data;
+	rme96->spdif_pcm = NULL;
+}
+
+static void
+snd_rme96_free_adat_pcm(snd_pcm_t *pcm)
+{
+	rme96_t *rme96 = (rme96_t *) pcm->private_data;
+	rme96->adat_pcm = NULL;
+}
+
+static int __devinit
+snd_rme96_create(rme96_t *rme96)
+{
+	struct pci_dev *pci = rme96->pci;
+	int err;
+
+	rme96->irq = -1;
+	spin_lock_init(&rme96->lock);
+
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+
+	if ((err = pci_request_regions(pci, "RME96")) < 0)
+		return err;
+	rme96->port = pci_resource_start(rme96->pci, 0);
+
+	if (request_irq(pci->irq, snd_rme96_interrupt, SA_INTERRUPT|SA_SHIRQ, "RME96", (void *)rme96)) {
+		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		return -EBUSY;
+	}
+	rme96->irq = pci->irq;
+
+	if ((rme96->iobase = ioremap_nocache(rme96->port, RME96_IO_SIZE)) == 0) {
+		snd_printk("unable to remap memory region 0x%lx-0x%lx\n", rme96->port, rme96->port + RME96_IO_SIZE - 1);
+		return -ENOMEM;
+	}
+
+	/* read the card's revision number */
+	pci_read_config_byte(pci, 8, &rme96->rev);	
+	
+	/* set up ALSA pcm device for S/PDIF */
+	if ((err = snd_pcm_new(rme96->card, "Digi96 IEC958", 0,
+			       1, 1, &rme96->spdif_pcm)) < 0)
+	{
+		return err;
+	}
+	rme96->spdif_pcm->private_data = rme96;
+	rme96->spdif_pcm->private_free = snd_rme96_free_spdif_pcm;
+	strcpy(rme96->spdif_pcm->name, "Digi96 IEC958");
+	snd_pcm_set_ops(rme96->spdif_pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_rme96_playback_spdif_ops);
+	snd_pcm_set_ops(rme96->spdif_pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_rme96_capture_spdif_ops);
+
+	rme96->spdif_pcm->info_flags = 0;
+
+	/* set up ALSA pcm device for ADAT */
+	if (pci->device == PCI_DEVICE_ID_DIGI96) {
+		/* ADAT is not available on the base model */
+		rme96->adat_pcm = NULL;
+	} else {
+		if ((err = snd_pcm_new(rme96->card, "Digi96 ADAT", 1,
+				       1, 1, &rme96->adat_pcm)) < 0)
+		{
+			return err;
+		}		
+		rme96->adat_pcm->private_data = rme96;
+		rme96->adat_pcm->private_free = snd_rme96_free_adat_pcm;
+		strcpy(rme96->adat_pcm->name, "Digi96 ADAT");
+		snd_pcm_set_ops(rme96->adat_pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_rme96_playback_adat_ops);
+		snd_pcm_set_ops(rme96->adat_pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_rme96_capture_adat_ops);
+		
+		rme96->adat_pcm->info_flags = 0;
+	}
+
+	rme96->playback_periodsize = 0;
+	rme96->capture_periodsize = 0;
+	
+	/* make sure playback/capture is stopped, if by some reason active */
+	snd_rme96_playback_stop(rme96);
+	snd_rme96_capture_stop(rme96);
+	
+	/* set default values in registers */
+	rme96->wcreg =
+		RME96_WCR_FREQ_1 | /* set 44.1 kHz playback */
+		RME96_WCR_SEL |    /* normal playback */
+		RME96_WCR_MASTER | /* set to master clock mode */
+		RME96_WCR_INP_0;   /* set coaxial input */
+
+	rme96->areg = RME96_AR_FREQPAD_1; /* set 44.1 kHz analog capture */
+
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
+	
+	/* reset the ADC */
+	writel(rme96->areg | RME96_AR_PD2,
+	       rme96->iobase + RME96_IO_ADDITIONAL_REG);
+	writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);	
+
+	/* reset and enable the DAC (order is important). */
+	snd_rme96_reset_dac(rme96);
+	rme96->areg |= RME96_AR_DAC_EN;
+	writel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);
+
+	/* reset playback and record buffer pointers */
+	writel(0, rme96->iobase + RME96_IO_RESET_PLAY_POS);
+	writel(0, rme96->iobase + RME96_IO_RESET_REC_POS);
+
+	/* reset volume */
+	rme96->vol[0] = rme96->vol[1] = 0;
+	if (RME96_HAS_ANALOG_OUT(rme96)) {
+		snd_rme96_apply_dac_volume(rme96);
+	}
+	
+	/* init switch interface */
+	if ((err = snd_rme96_create_switches(rme96->card, rme96)) < 0) {
+		return err;
+	}
+
+        /* init proc interface */
+	snd_rme96_proc_init(rme96);
+	
+	return 0;
+}
+
+/*
+ * proc interface
+ */
+
+static void 
+snd_rme96_proc_read(snd_info_entry_t *entry, snd_info_buffer_t *buffer)
+{
+	int n;
+	rme96_t *rme96 = (rme96_t *)entry->private_data;
+	
+	rme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);
+
+	snd_iprintf(buffer, rme96->card->longname);
+	snd_iprintf(buffer, " (index #%d)\n", rme96->card->number + 1);
+
+	snd_iprintf(buffer, "\nGeneral settings\n");
+	if (rme96->wcreg & RME96_WCR_IDIS) {
+		snd_iprintf(buffer, "  period size: N/A (interrupts "
+			    "disabled)\n");
+	} else if (rme96->wcreg & RME96_WCR_ISEL) {
+		snd_iprintf(buffer, "  period size: 2048 bytes\n");
+	} else {
+		snd_iprintf(buffer, "  period size: 8192 bytes\n");
+	}	
+	snd_iprintf(buffer, "\nInput settings\n");
+	switch (snd_rme96_getinputtype(rme96)) {
+	case RME96_INPUT_OPTICAL:
+		snd_iprintf(buffer, "  input: optical");
+		break;
+	case RME96_INPUT_COAXIAL:
+		snd_iprintf(buffer, "  input: coaxial");
+		break;
+	case RME96_INPUT_INTERNAL:
+		snd_iprintf(buffer, "  input: internal");
+		break;
+	case RME96_INPUT_XLR:
+		snd_iprintf(buffer, "  input: XLR");
+		break;
+	case RME96_INPUT_ANALOG:
+		snd_iprintf(buffer, "  input: analog");
+		break;
+	}
+	if (snd_rme96_capture_getrate(rme96, &n) < 0) {
+		snd_iprintf(buffer, "\n  sample rate: no valid signal\n");
+	} else {
+		if (n) {
+			snd_iprintf(buffer, " (8 channels)\n");
+		} else {
+			snd_iprintf(buffer, " (2 channels)\n");
+		}
+		snd_iprintf(buffer, "  sample rate: %d Hz\n",
+			    snd_rme96_capture_getrate(rme96, &n));
+	}
+	if (rme96->wcreg & RME96_WCR_MODE24_2) {
+		snd_iprintf(buffer, "  sample format: 24 bit\n");
+	} else {
+		snd_iprintf(buffer, "  sample format: 16 bit\n");
+	}
+	
+	snd_iprintf(buffer, "\nOutput settings\n");
+	if (rme96->wcreg & RME96_WCR_SEL) {
+		snd_iprintf(buffer, "  output signal: normal playback\n");
+	} else {
+		snd_iprintf(buffer, "  output signal: same as input\n");
+	}
+	snd_iprintf(buffer, "  sample rate: %d Hz\n",
+		    snd_rme96_playback_getrate(rme96));
+	if (rme96->wcreg & RME96_WCR_MODE24) {
+		snd_iprintf(buffer, "  sample format: 24 bit\n");
+	} else {
+		snd_iprintf(buffer, "  sample format: 16 bit\n");
+	}
+	if (rme96->areg & RME96_AR_WSEL) {
+		snd_iprintf(buffer, "  sample clock source: word clock\n");
+	} else if (rme96->wcreg & RME96_WCR_MASTER) {
+		snd_iprintf(buffer, "  sample clock source: internal\n");
+	} else if (snd_rme96_getinputtype(rme96) == RME96_INPUT_ANALOG) {
+		snd_iprintf(buffer, "  sample clock source: autosync (internal anyway due to analog input setting)\n");
+	} else if (snd_rme96_capture_getrate(rme96, &n) < 0) {
+		snd_iprintf(buffer, "  sample clock source: autosync (internal anyway due to no valid signal)\n");
+	} else {
+		snd_iprintf(buffer, "  sample clock source: autosync\n");
+	}
+	if (rme96->wcreg & RME96_WCR_PRO) {
+		snd_iprintf(buffer, "  format: AES/EBU (professional)\n");
+	} else {
+		snd_iprintf(buffer, "  format: IEC958 (consumer)\n");
+	}
+	if (rme96->wcreg & RME96_WCR_EMP) {
+		snd_iprintf(buffer, "  emphasis: on\n");
+	} else {
+		snd_iprintf(buffer, "  emphasis: off\n");
+	}
+	if (rme96->wcreg & RME96_WCR_DOLBY) {
+		snd_iprintf(buffer, "  non-audio (dolby): on\n");
+	} else {
+		snd_iprintf(buffer, "  non-audio (dolby): off\n");
+	}
+	if (RME96_HAS_ANALOG_IN(rme96)) {
+		snd_iprintf(buffer, "\nAnalog output settings\n");
+		switch (snd_rme96_getmontracks(rme96)) {
+		case RME96_MONITOR_TRACKS_1_2:
+			snd_iprintf(buffer, "  monitored ADAT tracks: 1+2\n");
+			break;
+		case RME96_MONITOR_TRACKS_3_4:
+			snd_iprintf(buffer, "  monitored ADAT tracks: 3+4\n");
+			break;
+		case RME96_MONITOR_TRACKS_5_6:
+			snd_iprintf(buffer, "  monitored ADAT tracks: 5+6\n");
+			break;
+		case RME96_MONITOR_TRACKS_7_8:
+			snd_iprintf(buffer, "  monitored ADAT tracks: 7+8\n");
+			break;
+		}
+		switch (snd_rme96_getattenuation(rme96)) {
+		case RME96_ATTENUATION_0:
+			snd_iprintf(buffer, "  attenuation: 0 dB\n");
+			break;
+		case RME96_ATTENUATION_6:
+			snd_iprintf(buffer, "  attenuation: -6 dB\n");
+			break;
+		case RME96_ATTENUATION_12:
+			snd_iprintf(buffer, "  attenuation: -12 dB\n");
+			break;
+		case RME96_ATTENUATION_18:
+			snd_iprintf(buffer, "  attenuation: -18 dB\n");
+			break;
+		}
+		snd_iprintf(buffer, "  volume left: %u\n", rme96->vol[0]);
+		snd_iprintf(buffer, "  volume right: %u\n", rme96->vol[1]);
+	}
+}
+
+static void __devinit 
+snd_rme96_proc_init(rme96_t *rme96)
+{
+	snd_info_entry_t *entry;
+
+	if (! snd_card_proc_new(rme96->card, "rme96", &entry))
+		snd_info_set_text_ops(entry, rme96, 1024, snd_rme96_proc_read);
+}
+
+/*
+ * control interface
+ */
+
+static int
+snd_rme96_info_loopback_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+static int
+snd_rme96_get_loopback_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	
+	spin_lock_irq(&rme96->lock);
+	ucontrol->value.integer.value[0] = rme96->wcreg & RME96_WCR_SEL ? 0 : 1;
+	spin_unlock_irq(&rme96->lock);
+	return 0;
+}
+static int
+snd_rme96_put_loopback_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change;
+	
+	val = ucontrol->value.integer.value[0] ? 0 : RME96_WCR_SEL;
+	spin_lock_irq(&rme96->lock);
+	val = (rme96->wcreg & ~RME96_WCR_SEL) | val;
+	change = val != rme96->wcreg;
+	rme96->wcreg = val;
+	writel(val, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	spin_unlock_irq(&rme96->lock);
+	return change;
+}
+
+static int
+snd_rme96_info_inputtype_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *_texts[5] = { "Optical", "Coaxial", "Internal", "XLR", "Analog" };
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	char *texts[5] = { _texts[0], _texts[1], _texts[2], _texts[3], _texts[4] };
+	
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	switch (rme96->pci->device) {
+	case PCI_DEVICE_ID_DIGI96:
+	case PCI_DEVICE_ID_DIGI96_8:
+		uinfo->value.enumerated.items = 3;
+		break;
+	case PCI_DEVICE_ID_DIGI96_8_PRO:
+		uinfo->value.enumerated.items = 4;
+		break;
+	case PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST:
+		if (rme96->rev > 4) {
+			/* PST */
+			uinfo->value.enumerated.items = 4;
+			texts[3] = _texts[4]; /* Analog instead of XLR */
+		} else {
+			/* PAD */
+			uinfo->value.enumerated.items = 5;
+		}
+		break;
+	default:
+		snd_BUG();
+		break;
+	}
+	if (uinfo->value.enumerated.item > uinfo->value.enumerated.items - 1) {
+		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
+	}
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+static int
+snd_rme96_get_inputtype_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	unsigned int items = 3;
+	
+	spin_lock_irq(&rme96->lock);
+	ucontrol->value.enumerated.item[0] = snd_rme96_getinputtype(rme96);
+	
+	switch (rme96->pci->device) {
+	case PCI_DEVICE_ID_DIGI96:
+	case PCI_DEVICE_ID_DIGI96_8:
+		items = 3;
+		break;
+	case PCI_DEVICE_ID_DIGI96_8_PRO:
+		items = 4;
+		break;
+	case PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST:
+		if (rme96->rev > 4) {
+			/* for handling PST case, (INPUT_ANALOG is moved to INPUT_XLR */
+			if (ucontrol->value.enumerated.item[0] == RME96_INPUT_ANALOG) {
+				ucontrol->value.enumerated.item[0] = RME96_INPUT_XLR;
+			}
+			items = 4;
+		} else {
+			items = 5;
+		}
+		break;
+	default:
+		snd_BUG();
+		break;
+	}
+	if (ucontrol->value.enumerated.item[0] >= items) {
+		ucontrol->value.enumerated.item[0] = items - 1;
+	}
+	
+	spin_unlock_irq(&rme96->lock);
+	return 0;
+}
+static int
+snd_rme96_put_inputtype_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change, items = 3;
+	
+	switch (rme96->pci->device) {
+	case PCI_DEVICE_ID_DIGI96:
+	case PCI_DEVICE_ID_DIGI96_8:
+		items = 3;
+		break;
+	case PCI_DEVICE_ID_DIGI96_8_PRO:
+		items = 4;
+		break;
+	case PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST:
+		if (rme96->rev > 4) {
+			items = 4;
+		} else {
+			items = 5;
+		}
+		break;
+	default:
+		snd_BUG();
+		break;
+	}
+	val = ucontrol->value.enumerated.item[0] % items;
+	
+	/* special case for PST */
+	if (rme96->pci->device == PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST && rme96->rev > 4) {
+		if (val == RME96_INPUT_XLR) {
+			val = RME96_INPUT_ANALOG;
+		}
+	}
+	
+	spin_lock_irq(&rme96->lock);
+	change = (int)val != snd_rme96_getinputtype(rme96);
+	snd_rme96_setinputtype(rme96, val);
+	spin_unlock_irq(&rme96->lock);
+	return change;
+}
+
+static int
+snd_rme96_info_clockmode_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[3] = { "AutoSync", "Internal", "Word" };
+	
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 3;
+	if (uinfo->value.enumerated.item > 2) {
+		uinfo->value.enumerated.item = 2;
+	}
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+static int
+snd_rme96_get_clockmode_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	
+	spin_lock_irq(&rme96->lock);
+	ucontrol->value.enumerated.item[0] = snd_rme96_getclockmode(rme96);
+	spin_unlock_irq(&rme96->lock);
+	return 0;
+}
+static int
+snd_rme96_put_clockmode_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change;
+	
+	val = ucontrol->value.enumerated.item[0] % 3;
+	spin_lock_irq(&rme96->lock);
+	change = (int)val != snd_rme96_getclockmode(rme96);
+	snd_rme96_setclockmode(rme96, val);
+	spin_unlock_irq(&rme96->lock);
+	return change;
+}
+
+static int
+snd_rme96_info_attenuation_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[4] = { "0 dB", "-6 dB", "-12 dB", "-18 dB" };
+	
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 4;
+	if (uinfo->value.enumerated.item > 3) {
+		uinfo->value.enumerated.item = 3;
+	}
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+static int
+snd_rme96_get_attenuation_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	
+	spin_lock_irq(&rme96->lock);
+	ucontrol->value.enumerated.item[0] = snd_rme96_getattenuation(rme96);
+	spin_unlock_irq(&rme96->lock);
+	return 0;
+}
+static int
+snd_rme96_put_attenuation_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change;
+	
+	val = ucontrol->value.enumerated.item[0] % 4;
+	spin_lock_irq(&rme96->lock);
+
+	change = (int)val != snd_rme96_getattenuation(rme96);
+	snd_rme96_setattenuation(rme96, val);
+	spin_unlock_irq(&rme96->lock);
+	return change;
+}
+
+static int
+snd_rme96_info_montracks_control(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[4] = { "1+2", "3+4", "5+6", "7+8" };
+	
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 4;
+	if (uinfo->value.enumerated.item > 3) {
+		uinfo->value.enumerated.item = 3;
+	}
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+static int
+snd_rme96_get_montracks_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	
+	spin_lock_irq(&rme96->lock);
+	ucontrol->value.enumerated.item[0] = snd_rme96_getmontracks(rme96);
+	spin_unlock_irq(&rme96->lock);
+	return 0;
+}
+static int
+snd_rme96_put_montracks_control(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change;
+	
+	val = ucontrol->value.enumerated.item[0] % 4;
+	spin_lock_irq(&rme96->lock);
+	change = (int)val != snd_rme96_getmontracks(rme96);
+	snd_rme96_setmontracks(rme96, val);
+	spin_unlock_irq(&rme96->lock);
+	return change;
+}
+
+static u32 snd_rme96_convert_from_aes(snd_aes_iec958_t *aes)
+{
+	u32 val = 0;
+	val |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? RME96_WCR_PRO : 0;
+	val |= (aes->status[0] & IEC958_AES0_NONAUDIO) ? RME96_WCR_DOLBY : 0;
+	if (val & RME96_WCR_PRO)
+		val |= (aes->status[0] & IEC958_AES0_PRO_EMPHASIS_5015) ? RME96_WCR_EMP : 0;
+	else
+		val |= (aes->status[0] & IEC958_AES0_CON_EMPHASIS_5015) ? RME96_WCR_EMP : 0;
+	return val;
+}
+
+static void snd_rme96_convert_to_aes(snd_aes_iec958_t *aes, u32 val)
+{
+	aes->status[0] = ((val & RME96_WCR_PRO) ? IEC958_AES0_PROFESSIONAL : 0) |
+			 ((val & RME96_WCR_DOLBY) ? IEC958_AES0_NONAUDIO : 0);
+	if (val & RME96_WCR_PRO)
+		aes->status[0] |= (val & RME96_WCR_EMP) ? IEC958_AES0_PRO_EMPHASIS_5015 : 0;
+	else
+		aes->status[0] |= (val & RME96_WCR_EMP) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;
+}
+
+static int snd_rme96_control_spdif_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_rme96_control_spdif_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	
+	snd_rme96_convert_to_aes(&ucontrol->value.iec958, rme96->wcreg_spdif);
+	return 0;
+}
+
+static int snd_rme96_control_spdif_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	int change;
+	u32 val;
+	
+	val = snd_rme96_convert_from_aes(&ucontrol->value.iec958);
+	spin_lock_irq(&rme96->lock);
+	change = val != rme96->wcreg_spdif;
+	rme96->wcreg_spdif = val;
+	spin_unlock_irq(&rme96->lock);
+	return change;
+}
+
+static int snd_rme96_control_spdif_stream_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_rme96_control_spdif_stream_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	
+	snd_rme96_convert_to_aes(&ucontrol->value.iec958, rme96->wcreg_spdif_stream);
+	return 0;
+}
+
+static int snd_rme96_control_spdif_stream_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	int change;
+	u32 val;
+	
+	val = snd_rme96_convert_from_aes(&ucontrol->value.iec958);
+	spin_lock_irq(&rme96->lock);
+	change = val != rme96->wcreg_spdif_stream;
+	rme96->wcreg_spdif_stream = val;
+	rme96->wcreg &= ~(RME96_WCR_PRO | RME96_WCR_DOLBY | RME96_WCR_EMP);
+	rme96->wcreg |= val;
+	writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+	spin_unlock_irq(&rme96->lock);
+	return change;
+}
+
+static int snd_rme96_control_spdif_mask_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_rme96_control_spdif_mask_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	ucontrol->value.iec958.status[0] = kcontrol->private_value;
+	return 0;
+}
+
+static int
+snd_rme96_dac_volume_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+	
+        uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+        uinfo->count = 2;
+        uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = RME96_185X_MAX_OUT(rme96);
+        return 0;
+}
+
+static int
+snd_rme96_dac_volume_get(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *u)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&rme96->lock);
+        u->value.integer.value[0] = rme96->vol[0];
+        u->value.integer.value[1] = rme96->vol[1];
+	spin_unlock_irq(&rme96->lock);
+
+        return 0;
+}
+
+static int
+snd_rme96_dac_volume_put(snd_kcontrol_t *kcontrol, snd_ctl_elem_value_t *u)
+{
+	rme96_t *rme96 = snd_kcontrol_chip(kcontrol);
+        int change = 0;
+
+	if (!RME96_HAS_ANALOG_OUT(rme96)) {
+		return -EINVAL;
+	}
+	spin_lock_irq(&rme96->lock);
+        if (u->value.integer.value[0] != rme96->vol[0]) {
+		rme96->vol[0] = u->value.integer.value[0];
+                change = 1;
+        }
+        if (u->value.integer.value[1] != rme96->vol[1]) {
+		rme96->vol[1] = u->value.integer.value[1];
+                change = 1;
+        }
+	if (change) {
+		snd_rme96_apply_dac_volume(rme96);
+	}
+	spin_unlock_irq(&rme96->lock);
+
+        return change;
+}
+
+static snd_kcontrol_new_t snd_rme96_controls[] = {
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
+	.info =		snd_rme96_control_spdif_info,
+	.get =		snd_rme96_control_spdif_get,
+	.put =		snd_rme96_control_spdif_put
+},
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM),
+	.info =		snd_rme96_control_spdif_stream_info,
+	.get =		snd_rme96_control_spdif_stream_get,
+	.put =		snd_rme96_control_spdif_stream_put
+},
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,CON_MASK),
+	.info =		snd_rme96_control_spdif_mask_info,
+	.get =		snd_rme96_control_spdif_mask_get,
+	.private_value = IEC958_AES0_NONAUDIO |
+			IEC958_AES0_PROFESSIONAL |
+			IEC958_AES0_CON_EMPHASIS
+},
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =		SNDRV_CTL_NAME_IEC958("",PLAYBACK,PRO_MASK),
+	.info =		snd_rme96_control_spdif_mask_info,
+	.get =		snd_rme96_control_spdif_mask_get,
+	.private_value = IEC958_AES0_NONAUDIO |
+			IEC958_AES0_PROFESSIONAL |
+			IEC958_AES0_PRO_EMPHASIS
+},
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "Input Connector",
+	.info =         snd_rme96_info_inputtype_control, 
+	.get =          snd_rme96_get_inputtype_control,
+	.put =          snd_rme96_put_inputtype_control 
+},
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "Loopback Input",
+	.info =         snd_rme96_info_loopback_control,
+	.get =          snd_rme96_get_loopback_control,
+	.put =          snd_rme96_put_loopback_control
+},
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "Sample Clock Source",
+	.info =         snd_rme96_info_clockmode_control, 
+	.get =          snd_rme96_get_clockmode_control,
+	.put =          snd_rme96_put_clockmode_control
+},
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "Monitor Tracks",
+	.info =         snd_rme96_info_montracks_control, 
+	.get =          snd_rme96_get_montracks_control,
+	.put =          snd_rme96_put_montracks_control
+},
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "Attenuation",
+	.info =         snd_rme96_info_attenuation_control, 
+	.get =          snd_rme96_get_attenuation_control,
+	.put =          snd_rme96_put_attenuation_control
+},
+{
+        .iface =        SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "DAC Playback Volume",
+	.info =         snd_rme96_dac_volume_info,
+	.get =          snd_rme96_dac_volume_get,
+	.put =          snd_rme96_dac_volume_put
+}
+};
+
+static int
+snd_rme96_create_switches(snd_card_t *card,
+			  rme96_t *rme96)
+{
+	int idx, err;
+	snd_kcontrol_t *kctl;
+
+	for (idx = 0; idx < 7; idx++) {
+		if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_rme96_controls[idx], rme96))) < 0)
+			return err;
+		if (idx == 1)	/* IEC958 (S/PDIF) Stream */
+			rme96->spdif_ctl = kctl;
+	}
+
+	if (RME96_HAS_ANALOG_OUT(rme96)) {
+		for (idx = 7; idx < 10; idx++)
+			if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_rme96_controls[idx], rme96))) < 0)
+				return err;
+	}
+	
+	return 0;
+}
+
+/*
+ * Card initialisation
+ */
+
+static void snd_rme96_card_free(snd_card_t *card)
+{
+	snd_rme96_free(card->private_data);
+}
+
+static int __devinit
+snd_rme96_probe(struct pci_dev *pci,
+		const struct pci_device_id *pci_id)
+{
+	static int dev;
+	rme96_t *rme96;
+	snd_card_t *card;
+	int err;
+	u8 val;
+
+	if (dev >= SNDRV_CARDS) {
+		return -ENODEV;
+	}
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+	if ((card = snd_card_new(index[dev], id[dev], THIS_MODULE,
+				 sizeof(rme96_t))) == NULL)
+		return -ENOMEM;
+	card->private_free = snd_rme96_card_free;
+	rme96 = (rme96_t *)card->private_data;	
+	rme96->card = card;
+	rme96->pci = pci;
+	snd_card_set_dev(card, &pci->dev);
+	if ((err = snd_rme96_create(rme96)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	
+	strcpy(card->driver, "Digi96");
+	switch (rme96->pci->device) {
+	case PCI_DEVICE_ID_DIGI96:
+		strcpy(card->shortname, "RME Digi96");
+		break;
+	case PCI_DEVICE_ID_DIGI96_8:
+		strcpy(card->shortname, "RME Digi96/8");
+		break;
+	case PCI_DEVICE_ID_DIGI96_8_PRO:
+		strcpy(card->shortname, "RME Digi96/8 PRO");
+		break;
+	case PCI_DEVICE_ID_DIGI96_8_PAD_OR_PST:
+		pci_read_config_byte(rme96->pci, 8, &val);
+		if (val < 5) {
+			strcpy(card->shortname, "RME Digi96/8 PAD");
+		} else {
+			strcpy(card->shortname, "RME Digi96/8 PST");
+		}
+		break;
+	}
+	sprintf(card->longname, "%s at 0x%lx, irq %d", card->shortname,
+		rme96->port, rme96->irq);
+	
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;	
+	}
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_rme96_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name = "RME Digi96",
+	.id_table = snd_rme96_ids,
+	.probe = snd_rme96_probe,
+	.remove = __devexit_p(snd_rme96_remove),
+};
+
+static int __init alsa_card_rme96_init(void)
+{
+	return pci_module_init(&driver);
+}
+
+static void __exit alsa_card_rme96_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_rme96_init)
+module_exit(alsa_card_rme96_exit)
