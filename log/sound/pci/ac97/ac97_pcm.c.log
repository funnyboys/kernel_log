commit 1675bfc0fb040e421d15d1944dc578b76543c19f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:25 2020 +0100

    ALSA: ac97: More constifications
    
    Apply const prefix to each possible place: the static tables for
    registers and bits, the quirk tables, etc.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-11-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index 1c23a0f90559..491de1a623cb 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -26,7 +26,7 @@
  *  PCM support
  */
 
-static unsigned char rate_reg_tables[2][4][9] = {
+static const unsigned char rate_reg_tables[2][4][9] = {
 {
   /* standard rates */
   {
@@ -129,7 +129,7 @@ static unsigned char rate_reg_tables[2][4][9] = {
 }};
 
 /* FIXME: more various mappings for ADC? */
-static unsigned char rate_cregs[9] = {
+static const unsigned char rate_cregs[9] = {
 	AC97_PCM_LR_ADC_RATE,	/* 3 */
 	AC97_PCM_LR_ADC_RATE,	/* 4 */
 	0xff,			/* 5 */

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index d15297a68801..1c23a0f90559 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *  Universal interface for Audio Codec '97
@@ -5,22 +6,6 @@
  *  For more details look to AC '97 component specification revision 2.2
  *  by Intel Corporation (http://developer.intel.com) and to datasheets
  *  for specific codecs.
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/delay.h>

commit 38c16e34fe2f72c131e4dfd95c191783936c6bf8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 15:37:50 2014 +0100

    ALSA: ac97: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index eab0fc9ff2e0..d15297a68801 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -604,7 +604,9 @@ int snd_ac97_pcm_open(struct ac97_pcm *pcm, unsigned int rate,
 		}
 		if (!ok_flag) {
 			spin_unlock_irq(&pcm->bus->bus_lock);
-			snd_printk(KERN_ERR "cannot find configuration for AC97 slot %i\n", i);
+			dev_err(bus->card->dev,
+				"cannot find configuration for AC97 slot %i\n",
+				i);
 			err = -EAGAIN;
 			goto error;
 		}
@@ -618,15 +620,20 @@ int snd_ac97_pcm_open(struct ac97_pcm *pcm, unsigned int rate,
 			if (pcm->r[r].rslots[cidx] & (1 << i)) {
 				reg = get_slot_reg(pcm, cidx, i, r);
 				if (reg == 0xff) {
-					snd_printk(KERN_ERR "invalid AC97 slot %i?\n", i);
+					dev_err(bus->card->dev,
+						"invalid AC97 slot %i?\n", i);
 					continue;
 				}
 				if (reg_ok[cidx] & (1 << (reg - AC97_PCM_FRONT_DAC_RATE)))
 					continue;
-				//printk(KERN_DEBUG "setting ac97 reg 0x%x to rate %d\n", reg, rate);
+				dev_dbg(bus->card->dev,
+					"setting ac97 reg 0x%x to rate %d\n",
+					reg, rate);
 				err = snd_ac97_set_rate(pcm->r[r].codec[cidx], reg, rate);
 				if (err < 0)
-					snd_printk(KERN_ERR "error in snd_ac97_set_rate: cidx=%d, reg=0x%x, rate=%d, err=%d\n", cidx, reg, rate, err);
+					dev_err(bus->card->dev,
+						"error in snd_ac97_set_rate: cidx=%d, reg=0x%x, rate=%d, err=%d\n",
+						cidx, reg, rate, err);
 				else
 					reg_ok[cidx] |= (1 << (reg - AC97_PCM_FRONT_DAC_RATE));
 			}

commit eb7c06e8e9c93b495e355421cffd3c43c266d7d2
Author: Yacine Belkadi <yacine.belkadi.1@gmail.com>
Date:   Mon Mar 11 22:05:14 2013 +0100

    ALSA: add/change some comments describing function return values
    
    script/kernel-doc reports the following type of warnings (when run in verbose
    mode):
    
    Warning(sound/core/init.c:152): No description found for return value of
    'snd_card_create'
    
    To fix that:
    - add missing descriptions of function return values
    - use "Return:" sections to describe those return values
    
    Along the way:
    - complete some descriptions
    - fix some typos
    
    Signed-off-by: Yacine Belkadi <yacine.belkadi.1@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index f1488fc176d5..eab0fc9ff2e0 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -253,7 +253,7 @@ static int set_spdif_rate(struct snd_ac97 *ac97, unsigned short rate)
  * AC97_SPDIF is accepted as a pseudo register to modify the SPDIF
  * status bits.
  *
- * Returns zero if successful, or a negative error code on failure.
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_ac97_set_rate(struct snd_ac97 *ac97, int reg, unsigned int rate)
 {
@@ -440,6 +440,8 @@ static unsigned int get_rates(struct ac97_pcm *pcm, unsigned int cidx, unsigned
  * It assigns available AC97 slots for given PCMs. If none or only
  * some slots are available, pcm->xxx.slots and pcm->xxx.rslots[] members
  * are reduced and might be zero.
+ *
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_ac97_pcm_assign(struct snd_ac97_bus *bus,
 			unsigned short pcms_count,
@@ -562,6 +564,8 @@ EXPORT_SYMBOL(snd_ac97_pcm_assign);
  * @slots: a subset of allocated slots (snd_ac97_pcm_assign) for this pcm
  *
  * It locks the specified slots and sets the given rate to AC97 registers.
+ *
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_ac97_pcm_open(struct ac97_pcm *pcm, unsigned int rate,
 		      enum ac97_pcm_cfg cfg, unsigned short slots)
@@ -644,6 +648,8 @@ EXPORT_SYMBOL(snd_ac97_pcm_open);
  * @pcm: the ac97 pcm instance
  *
  * It frees the locked AC97 slots.
+ *
+ * Return: Zero.
  */
 int snd_ac97_pcm_close(struct ac97_pcm *pcm)
 {
@@ -718,6 +724,8 @@ static int double_rate_hw_constraint_channels(struct snd_pcm_hw_params *params,
  *
  * Installs the hardware constraint rules to prevent using double rates and
  * more than two channels at the same time.
+ *
+ * Return: Zero if successful, or a negative error code on failure.
  */
 int snd_ac97_pcm_double_rate_rules(struct snd_pcm_runtime *runtime)
 {

commit d81a6d71760c4d8323f1f9a506c64084caa09063
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Sep 22 09:34:58 2011 -0400

    sound: Add export.h for THIS_MODULE/EXPORT_SYMBOL where needed
    
    These aren't modules, but they do make use of these macros, so
    they will need export.h to get that definition.  Previously,
    they got it via the implicit module.h inclusion.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index 48cbda9378c5..f1488fc176d5 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -27,6 +27,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/mutex.h>
+#include <linux/export.h>
 
 #include <sound/core.h>
 #include <sound/pcm.h>

commit 608b10bad3563e2349393136ce421d9f67329170
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Feb 28 11:58:18 2008 +0100

    [ALSA] sound: ac97_pcm.c fix shadowed variable warning
    
    err is always assigned before it is used, no need to declare another
    inside the if statement.
    sound/pci/ac97/ac97_pcm.c:577:7: warning: symbol 'err' shadows an earlier one
    sound/pci/ac97/ac97_pcm.c:572:6: originally declared here
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index 3674f35c4a79..48cbda9378c5 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -574,7 +574,6 @@ int snd_ac97_pcm_open(struct ac97_pcm *pcm, unsigned int rate,
 	r = rate > 48000;
 	bus = pcm->bus;
 	if (cfg == AC97_PCM_CFG_SPDIF) {
-		int err;
 		for (cidx = 0; cidx < 4; cidx++)
 			if (bus->codec[cidx] && (bus->codec[cidx]->ext_id & AC97_EI_SPDIF)) {
 				err = set_spdif_rate(bus->codec[cidx], rate);

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index 8cbc03332b01..3674f35c4a79 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -23,7 +23,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/slab.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index 4281e6d0c5b6..8cbc03332b01 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *  Universal interface for Audio Codec '97
  *
  *  For more details look to AC '97 component specification revision 2.2

commit ac519028a4e7b919eaff65a1535824259df326c6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 22 12:58:27 2007 +0100

    [ALSA] ac97 - Make patch functions static
    
    Include ac97_patch.c from the main ac97_codec.c in order to make
    bunch of patch_*() functions static.  This helps optimization.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index 3758d07182f8..4281e6d0c5b6 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -34,7 +34,6 @@
 #include <sound/control.h>
 #include <sound/ac97_codec.h>
 #include <sound/asoundef.h>
-#include "ac97_patch.h"
 #include "ac97_id.h"
 #include "ac97_local.h"
 

commit 6dbe662874ba08585eaf732d126762c25ac8e3f7
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 27 18:28:53 2006 +0200

    [ALSA] Add experimental support of aggressive AC97 power-saving mode
    
    Added CONFIG_SND_AC97_POWER_SAVE kernel config to enable the support
    of aggressive AC97 power-saving mode.  In this mode, the AC97
    powerdown register bits are dynamically controlled at each open/close
    of PCM streams.
    The mode is activated via power_save option for snd-ac97-codec
    driver.  As default it's off.  It can be turned on/off on the fly
    via sysfs, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index f684aa2c0067..3758d07182f8 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -269,6 +269,7 @@ int snd_ac97_set_rate(struct snd_ac97 *ac97, int reg, unsigned int rate)
 			return -EINVAL;
 	}
 
+	snd_ac97_update_power(ac97, reg, 1);
 	switch (reg) {
 	case AC97_PCM_MIC_ADC_RATE:
 		if ((ac97->regs[AC97_EXTENDED_STATUS] & AC97_EA_VRM) == 0)	/* MIC VRA */
@@ -606,6 +607,7 @@ int snd_ac97_pcm_open(struct ac97_pcm *pcm, unsigned int rate,
 			goto error;
 		}
 	}
+	pcm->cur_dbl = r;
 	spin_unlock_irq(&pcm->bus->bus_lock);
 	for (i = 3; i < 12; i++) {
 		if (!(slots & (1 << i)))
@@ -651,6 +653,21 @@ int snd_ac97_pcm_close(struct ac97_pcm *pcm)
 	unsigned short slots = pcm->aslots;
 	int i, cidx;
 
+#ifdef CONFIG_SND_AC97_POWER_SAVE
+	int r = pcm->cur_dbl;
+	for (i = 3; i < 12; i++) {
+		if (!(slots & (1 << i)))
+			continue;
+		for (cidx = 0; cidx < 4; cidx++) {
+			if (pcm->r[r].rslots[cidx] & (1 << i)) {
+				int reg = get_slot_reg(pcm, cidx, i, r);
+				snd_ac97_update_power(pcm->r[r].codec[cidx],
+						      reg, 0);
+			}
+		}
+	}
+#endif
+
 	bus = pcm->bus;
 	spin_lock_irq(&pcm->bus->bus_lock);
 	for (i = 3; i < 12; i++) {
@@ -660,6 +677,7 @@ int snd_ac97_pcm_close(struct ac97_pcm *pcm)
 			bus->used_slots[pcm->stream][cidx] &= ~(1 << i);
 	}
 	pcm->aslots = 0;
+	pcm->cur_dbl = 0;
 	spin_unlock_irq(&pcm->bus->bus_lock);
 	return 0;
 }

commit 7b09679c431ba91551a90203f7e7dadbb4c26d1b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:39 2006 +0200

    [ALSA] ac97 - Move EXPORT_SYMBOL() to adjacent to each function
    
    Move EXPORT_SYMBOL() to adjacent to each exported function/variable.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index 512a3583b0ce..f684aa2c0067 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -317,6 +317,8 @@ int snd_ac97_set_rate(struct snd_ac97 *ac97, int reg, unsigned int rate)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_ac97_set_rate);
+
 static unsigned short get_pslots(struct snd_ac97 *ac97, unsigned char *rate_table, unsigned short *spdif_slots)
 {
 	if (!ac97_is_audio(ac97))
@@ -550,6 +552,8 @@ int snd_ac97_pcm_assign(struct snd_ac97_bus *bus,
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_ac97_pcm_assign);
+
 /**
  * snd_ac97_pcm_open - opens the given AC97 pcm
  * @pcm: the ac97 pcm instance
@@ -633,6 +637,8 @@ int snd_ac97_pcm_open(struct ac97_pcm *pcm, unsigned int rate,
 	return err;
 }
 
+EXPORT_SYMBOL(snd_ac97_pcm_open);
+
 /**
  * snd_ac97_pcm_close - closes the given AC97 pcm
  * @pcm: the ac97 pcm instance
@@ -658,6 +664,8 @@ int snd_ac97_pcm_close(struct ac97_pcm *pcm)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_ac97_pcm_close);
+
 static int double_rate_hw_constraint_rate(struct snd_pcm_hw_params *params,
 					  struct snd_pcm_hw_rule *rule)
 {
@@ -709,3 +717,5 @@ int snd_ac97_pcm_double_rate_rules(struct snd_pcm_runtime *runtime)
 				  SNDRV_PCM_HW_PARAM_RATE, -1);
 	return err;
 }
+
+EXPORT_SYMBOL(snd_ac97_pcm_double_rate_rules);

commit 62932df8fb20ba2fb53a95fa52445eba22e821fe
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:34:20 2006 +0100

    [ALSA] semaphore -> mutex (PCI part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index c3e590bf7a02..512a3583b0ce 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -27,6 +27,8 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/slab.h>
+#include <linux/mutex.h>
+
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/control.h>
@@ -206,7 +208,7 @@ static int set_spdif_rate(struct snd_ac97 *ac97, unsigned short rate)
 		mask = AC97_SC_SPSR_MASK;
 	}
 
-	down(&ac97->reg_mutex);
+	mutex_lock(&ac97->reg_mutex);
 	old = snd_ac97_read(ac97, reg) & mask;
 	if (old != bits) {
 		snd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);
@@ -231,7 +233,7 @@ static int set_spdif_rate(struct snd_ac97 *ac97, unsigned short rate)
 		ac97->spdif_status = sbits;
 	}
 	snd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF);
-	up(&ac97->reg_mutex);
+	mutex_unlock(&ac97->reg_mutex);
 	return 0;
 }
 

commit ee42381e71c56328db9e9d64d19a4de7a2f09a93
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:21:36 2005 +0100

    [ALSA] Remove xxx_t typedefs: AC97
    
    Modules: AC97 Codec
    
    Remove xxx_t typedefs from the AC97 codec support.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index ded13165d635..c3e590bf7a02 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -170,7 +170,7 @@ static unsigned char get_slot_reg(struct ac97_pcm *pcm, unsigned short cidx,
 		return rate_cregs[slot - 3];
 }
 
-static int set_spdif_rate(ac97_t *ac97, unsigned short rate)
+static int set_spdif_rate(struct snd_ac97 *ac97, unsigned short rate)
 {
 	unsigned short old, bits, reg, mask;
 	unsigned int sbits;
@@ -254,7 +254,7 @@ static int set_spdif_rate(ac97_t *ac97, unsigned short rate)
  *
  * Returns zero if successful, or a negative error code on failure.
  */
-int snd_ac97_set_rate(ac97_t *ac97, int reg, unsigned int rate)
+int snd_ac97_set_rate(struct snd_ac97 *ac97, int reg, unsigned int rate)
 {
 	int dbl;
 	unsigned int tmp;
@@ -315,7 +315,7 @@ int snd_ac97_set_rate(ac97_t *ac97, int reg, unsigned int rate)
 	return 0;
 }
 
-static unsigned short get_pslots(ac97_t *ac97, unsigned char *rate_table, unsigned short *spdif_slots)
+static unsigned short get_pslots(struct snd_ac97 *ac97, unsigned char *rate_table, unsigned short *spdif_slots)
 {
 	if (!ac97_is_audio(ac97))
 		return 0;
@@ -390,7 +390,7 @@ static unsigned short get_pslots(ac97_t *ac97, unsigned char *rate_table, unsign
 	}
 }
 
-static unsigned short get_cslots(ac97_t *ac97)
+static unsigned short get_cslots(struct snd_ac97 *ac97)
 {
 	unsigned short slots;
 
@@ -437,7 +437,7 @@ static unsigned int get_rates(struct ac97_pcm *pcm, unsigned int cidx, unsigned
  * some slots are available, pcm->xxx.slots and pcm->xxx.rslots[] members
  * are reduced and might be zero.
  */
-int snd_ac97_pcm_assign(ac97_bus_t *bus,
+int snd_ac97_pcm_assign(struct snd_ac97_bus *bus,
 			unsigned short pcms_count,
 			const struct ac97_pcm *pcms)
 {
@@ -449,7 +449,7 @@ int snd_ac97_pcm_assign(ac97_bus_t *bus,
 	unsigned short tmp, slots;
 	unsigned short spdif_slots[4];
 	unsigned int rates;
-	ac97_t *codec;
+	struct snd_ac97 *codec;
 
 	rpcms = kcalloc(pcms_count, sizeof(struct ac97_pcm), GFP_KERNEL);
 	if (rpcms == NULL)
@@ -560,7 +560,7 @@ int snd_ac97_pcm_assign(ac97_bus_t *bus,
 int snd_ac97_pcm_open(struct ac97_pcm *pcm, unsigned int rate,
 		      enum ac97_pcm_cfg cfg, unsigned short slots)
 {
-	ac97_bus_t *bus;
+	struct snd_ac97_bus *bus;
 	int i, cidx, r, ok_flag;
 	unsigned int reg_ok[4] = {0,0,0,0};
 	unsigned char reg;
@@ -639,7 +639,7 @@ int snd_ac97_pcm_open(struct ac97_pcm *pcm, unsigned int rate,
  */
 int snd_ac97_pcm_close(struct ac97_pcm *pcm)
 {
-	ac97_bus_t *bus;
+	struct snd_ac97_bus *bus;
 	unsigned short slots = pcm->aslots;
 	int i, cidx;
 
@@ -656,31 +656,31 @@ int snd_ac97_pcm_close(struct ac97_pcm *pcm)
 	return 0;
 }
 
-static int double_rate_hw_constraint_rate(snd_pcm_hw_params_t *params,
-					  snd_pcm_hw_rule_t *rule)
+static int double_rate_hw_constraint_rate(struct snd_pcm_hw_params *params,
+					  struct snd_pcm_hw_rule *rule)
 {
-	snd_interval_t *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_interval *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
 	if (channels->min > 2) {
-		static const snd_interval_t single_rates = {
+		static const struct snd_interval single_rates = {
 			.min = 1,
 			.max = 48000,
 		};
-		snd_interval_t *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+		struct snd_interval *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 		return snd_interval_refine(rate, &single_rates);
 	}
 	return 0;
 }
 
-static int double_rate_hw_constraint_channels(snd_pcm_hw_params_t *params,
-					      snd_pcm_hw_rule_t *rule)
+static int double_rate_hw_constraint_channels(struct snd_pcm_hw_params *params,
+					      struct snd_pcm_hw_rule *rule)
 {
-	snd_interval_t *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 	if (rate->min > 48000) {
-		static const snd_interval_t double_rate_channels = {
+		static const struct snd_interval double_rate_channels = {
 			.min = 2,
 			.max = 2,
 		};
-		snd_interval_t *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+		struct snd_interval *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
 		return snd_interval_refine(channels, &double_rate_channels);
 	}
 	return 0;
@@ -693,7 +693,7 @@ static int double_rate_hw_constraint_channels(snd_pcm_hw_params_t *params,
  * Installs the hardware constraint rules to prevent using double rates and
  * more than two channels at the same time.
  */
-int snd_ac97_pcm_double_rate_rules(snd_pcm_runtime_t *runtime)
+int snd_ac97_pcm_double_rate_rules(struct snd_pcm_runtime *runtime)
 {
 	int err;
 

commit 091e95ee7febf894603475c44d51f8ec4fab4328
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 27 20:56:35 2005 +0200

    [ALSA] ac97 - Fix confliction of DRA and surround slots
    
    Modules: AC97 Codec
    
    Fixed the confliction of DRA and surround slots 7/8.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
index dd289b9512e1..ded13165d635 100644
--- a/sound/pci/ac97/ac97_pcm.c
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -303,6 +303,15 @@ int snd_ac97_set_rate(ac97_t *ac97, int reg, unsigned int rate)
 				     AC97_EA_DRA, dbl ? AC97_EA_DRA : 0);
 	snd_ac97_update(ac97, reg, tmp & 0xffff);
 	snd_ac97_read(ac97, reg);
+	if ((ac97->ext_id & AC97_EI_DRA) && reg == AC97_PCM_FRONT_DAC_RATE) {
+		/* Intel controllers require double rate data to be put in
+		 * slots 7+8
+		 */
+		snd_ac97_update_bits(ac97, AC97_GENERAL_PURPOSE,
+				     AC97_GP_DRSS_MASK,
+				     dbl ? AC97_GP_DRSS_78 : 0);
+		snd_ac97_read(ac97, AC97_GENERAL_PURPOSE);
+	}
 	return 0;
 }
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/ac97/ac97_pcm.c b/sound/pci/ac97/ac97_pcm.c
new file mode 100644
index 000000000000..dd289b9512e1
--- /dev/null
+++ b/sound/pci/ac97/ac97_pcm.c
@@ -0,0 +1,700 @@
+/*
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Universal interface for Audio Codec '97
+ *
+ *  For more details look to AC '97 component specification revision 2.2
+ *  by Intel Corporation (http://developer.intel.com) and to datasheets
+ *  for specific codecs.
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/control.h>
+#include <sound/ac97_codec.h>
+#include <sound/asoundef.h>
+#include "ac97_patch.h"
+#include "ac97_id.h"
+#include "ac97_local.h"
+
+/*
+ *  PCM support
+ */
+
+static unsigned char rate_reg_tables[2][4][9] = {
+{
+  /* standard rates */
+  {
+  	/* 3&4 front, 7&8 rear, 6&9 center/lfe */
+	AC97_PCM_FRONT_DAC_RATE,	/* slot 3 */
+	AC97_PCM_FRONT_DAC_RATE,	/* slot 4 */
+	0xff,				/* slot 5 */
+	AC97_PCM_LFE_DAC_RATE,		/* slot 6 */
+	AC97_PCM_SURR_DAC_RATE,		/* slot 7 */
+	AC97_PCM_SURR_DAC_RATE,		/* slot 8 */
+	AC97_PCM_LFE_DAC_RATE,		/* slot 9 */
+	0xff,				/* slot 10 */
+	0xff,				/* slot 11 */
+  },
+  {
+  	/* 7&8 front, 6&9 rear, 10&11 center/lfe */
+	0xff,				/* slot 3 */
+	0xff,				/* slot 4 */
+	0xff,				/* slot 5 */
+	AC97_PCM_SURR_DAC_RATE,		/* slot 6 */
+	AC97_PCM_FRONT_DAC_RATE,	/* slot 7 */
+	AC97_PCM_FRONT_DAC_RATE,	/* slot 8 */
+	AC97_PCM_SURR_DAC_RATE,		/* slot 9 */
+	AC97_PCM_LFE_DAC_RATE,		/* slot 10 */
+	AC97_PCM_LFE_DAC_RATE,		/* slot 11 */
+  },
+  {
+  	/* 6&9 front, 10&11 rear, 3&4 center/lfe */
+	AC97_PCM_LFE_DAC_RATE,		/* slot 3 */
+	AC97_PCM_LFE_DAC_RATE,		/* slot 4 */
+	0xff,				/* slot 5 */
+	AC97_PCM_FRONT_DAC_RATE,	/* slot 6 */
+	0xff,				/* slot 7 */
+	0xff,				/* slot 8 */
+	AC97_PCM_FRONT_DAC_RATE,	/* slot 9 */
+	AC97_PCM_SURR_DAC_RATE,		/* slot 10 */
+	AC97_PCM_SURR_DAC_RATE,		/* slot 11 */
+  },
+  {
+  	/* 10&11 front, 3&4 rear, 7&8 center/lfe */
+	AC97_PCM_SURR_DAC_RATE,		/* slot 3 */
+	AC97_PCM_SURR_DAC_RATE,		/* slot 4 */
+	0xff,				/* slot 5 */
+	0xff,				/* slot 6 */
+	AC97_PCM_LFE_DAC_RATE,		/* slot 7 */
+	AC97_PCM_LFE_DAC_RATE,		/* slot 8 */
+	0xff,				/* slot 9 */
+	AC97_PCM_FRONT_DAC_RATE,	/* slot 10 */
+	AC97_PCM_FRONT_DAC_RATE,	/* slot 11 */
+  },
+},
+{
+  /* double rates */
+  {
+  	/* 3&4 front, 7&8 front (t+1) */
+	AC97_PCM_FRONT_DAC_RATE,	/* slot 3 */
+	AC97_PCM_FRONT_DAC_RATE,	/* slot 4 */
+	0xff,				/* slot 5 */
+	0xff,				/* slot 6 */
+	AC97_PCM_FRONT_DAC_RATE,	/* slot 7 */
+	AC97_PCM_FRONT_DAC_RATE,	/* slot 8 */
+	0xff,				/* slot 9 */
+	0xff,				/* slot 10 */
+	0xff,				/* slot 11 */
+  },
+  {
+	/* not specified in the specification */
+	0xff,				/* slot 3 */
+	0xff,				/* slot 4 */
+	0xff,				/* slot 5 */
+	0xff,				/* slot 6 */
+	0xff,				/* slot 7 */
+	0xff,				/* slot 8 */
+	0xff,				/* slot 9 */
+	0xff,				/* slot 10 */
+	0xff,				/* slot 11 */
+  },
+  {
+	0xff,				/* slot 3 */
+	0xff,				/* slot 4 */
+	0xff,				/* slot 5 */
+	0xff,				/* slot 6 */
+	0xff,				/* slot 7 */
+	0xff,				/* slot 8 */
+	0xff,				/* slot 9 */
+	0xff,				/* slot 10 */
+	0xff,				/* slot 11 */
+  },
+  {
+	0xff,				/* slot 3 */
+	0xff,				/* slot 4 */
+	0xff,				/* slot 5 */
+	0xff,				/* slot 6 */
+	0xff,				/* slot 7 */
+	0xff,				/* slot 8 */
+	0xff,				/* slot 9 */
+	0xff,				/* slot 10 */
+	0xff,				/* slot 11 */
+  }
+}};
+
+/* FIXME: more various mappings for ADC? */
+static unsigned char rate_cregs[9] = {
+	AC97_PCM_LR_ADC_RATE,	/* 3 */
+	AC97_PCM_LR_ADC_RATE,	/* 4 */
+	0xff,			/* 5 */
+	AC97_PCM_MIC_ADC_RATE,	/* 6 */
+	0xff,			/* 7 */
+	0xff,			/* 8 */
+	0xff,			/* 9 */
+	0xff,			/* 10 */
+	0xff,			/* 11 */
+};
+
+static unsigned char get_slot_reg(struct ac97_pcm *pcm, unsigned short cidx,
+				  unsigned short slot, int dbl)
+{
+	if (slot < 3)
+		return 0xff;
+	if (slot > 11)
+		return 0xff;
+	if (pcm->spdif)
+		return AC97_SPDIF; /* pseudo register */
+	if (pcm->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		return rate_reg_tables[dbl][pcm->r[dbl].rate_table[cidx]][slot - 3];
+	else
+		return rate_cregs[slot - 3];
+}
+
+static int set_spdif_rate(ac97_t *ac97, unsigned short rate)
+{
+	unsigned short old, bits, reg, mask;
+	unsigned int sbits;
+
+	if (! (ac97->ext_id & AC97_EI_SPDIF))
+		return -ENODEV;
+
+	/* TODO: double rate support */
+	if (ac97->flags & AC97_CS_SPDIF) {
+		switch (rate) {
+		case 48000: bits = 0; break;
+		case 44100: bits = 1 << AC97_SC_SPSR_SHIFT; break;
+		default: /* invalid - disable output */
+			snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);
+			return -EINVAL;
+		}
+		reg = AC97_CSR_SPDIF;
+		mask = 1 << AC97_SC_SPSR_SHIFT;
+	} else {
+		if (ac97->id == AC97_ID_CM9739 && rate != 48000) {
+			snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);
+			return -EINVAL;
+		}
+		switch (rate) {
+		case 44100: bits = AC97_SC_SPSR_44K; break;
+		case 48000: bits = AC97_SC_SPSR_48K; break;
+		case 32000: bits = AC97_SC_SPSR_32K; break;
+		default: /* invalid - disable output */
+			snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);
+			return -EINVAL;
+		}
+		reg = AC97_SPDIF;
+		mask = AC97_SC_SPSR_MASK;
+	}
+
+	down(&ac97->reg_mutex);
+	old = snd_ac97_read(ac97, reg) & mask;
+	if (old != bits) {
+		snd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, 0);
+		snd_ac97_update_bits_nolock(ac97, reg, mask, bits);
+		/* update the internal spdif bits */
+		sbits = ac97->spdif_status;
+		if (sbits & IEC958_AES0_PROFESSIONAL) {
+			sbits &= ~IEC958_AES0_PRO_FS;
+			switch (rate) {
+			case 44100: sbits |= IEC958_AES0_PRO_FS_44100; break;
+			case 48000: sbits |= IEC958_AES0_PRO_FS_48000; break;
+			case 32000: sbits |= IEC958_AES0_PRO_FS_32000; break;
+			}
+		} else {
+			sbits &= ~(IEC958_AES3_CON_FS << 24);
+			switch (rate) {
+			case 44100: sbits |= IEC958_AES3_CON_FS_44100<<24; break;
+			case 48000: sbits |= IEC958_AES3_CON_FS_48000<<24; break;
+			case 32000: sbits |= IEC958_AES3_CON_FS_32000<<24; break;
+			}
+		}
+		ac97->spdif_status = sbits;
+	}
+	snd_ac97_update_bits_nolock(ac97, AC97_EXTENDED_STATUS, AC97_EA_SPDIF, AC97_EA_SPDIF);
+	up(&ac97->reg_mutex);
+	return 0;
+}
+
+/**
+ * snd_ac97_set_rate - change the rate of the given input/output.
+ * @ac97: the ac97 instance
+ * @reg: the register to change
+ * @rate: the sample rate to set
+ *
+ * Changes the rate of the given input/output on the codec.
+ * If the codec doesn't support VAR, the rate must be 48000 (except
+ * for SPDIF).
+ *
+ * The valid registers are AC97_PMC_MIC_ADC_RATE,
+ * AC97_PCM_FRONT_DAC_RATE, AC97_PCM_LR_ADC_RATE.
+ * AC97_PCM_SURR_DAC_RATE and AC97_PCM_LFE_DAC_RATE are accepted
+ * if the codec supports them.
+ * AC97_SPDIF is accepted as a pseudo register to modify the SPDIF
+ * status bits.
+ *
+ * Returns zero if successful, or a negative error code on failure.
+ */
+int snd_ac97_set_rate(ac97_t *ac97, int reg, unsigned int rate)
+{
+	int dbl;
+	unsigned int tmp;
+	
+	dbl = rate > 48000;
+	if (dbl) {
+		if (!(ac97->flags & AC97_DOUBLE_RATE))
+			return -EINVAL;
+		if (reg != AC97_PCM_FRONT_DAC_RATE)
+			return -EINVAL;
+	}
+
+	switch (reg) {
+	case AC97_PCM_MIC_ADC_RATE:
+		if ((ac97->regs[AC97_EXTENDED_STATUS] & AC97_EA_VRM) == 0)	/* MIC VRA */
+			if (rate != 48000)
+				return -EINVAL;
+		break;
+	case AC97_PCM_FRONT_DAC_RATE:
+	case AC97_PCM_LR_ADC_RATE:
+		if ((ac97->regs[AC97_EXTENDED_STATUS] & AC97_EA_VRA) == 0)	/* VRA */
+			if (rate != 48000 && rate != 96000)
+				return -EINVAL;
+		break;
+	case AC97_PCM_SURR_DAC_RATE:
+		if (! (ac97->scaps & AC97_SCAP_SURROUND_DAC))
+			return -EINVAL;
+		break;
+	case AC97_PCM_LFE_DAC_RATE:
+		if (! (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC))
+			return -EINVAL;
+		break;
+	case AC97_SPDIF:
+		/* special case */
+		return set_spdif_rate(ac97, rate);
+	default:
+		return -EINVAL;
+	}
+	if (dbl)
+		rate /= 2;
+	tmp = (rate * ac97->bus->clock) / 48000;
+	if (tmp > 65535)
+		return -EINVAL;
+	if ((ac97->ext_id & AC97_EI_DRA) && reg == AC97_PCM_FRONT_DAC_RATE)
+		snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,
+				     AC97_EA_DRA, dbl ? AC97_EA_DRA : 0);
+	snd_ac97_update(ac97, reg, tmp & 0xffff);
+	snd_ac97_read(ac97, reg);
+	return 0;
+}
+
+static unsigned short get_pslots(ac97_t *ac97, unsigned char *rate_table, unsigned short *spdif_slots)
+{
+	if (!ac97_is_audio(ac97))
+		return 0;
+	if (ac97_is_rev22(ac97) || ac97_can_amap(ac97)) {
+		unsigned short slots = 0;
+		if (ac97_is_rev22(ac97)) {
+			/* Note: it's simply emulation of AMAP behaviour */
+			u16 es;
+			es = ac97->regs[AC97_EXTENDED_ID] &= ~AC97_EI_DACS_SLOT_MASK;
+			switch (ac97->addr) {
+			case 1:
+			case 2: es |= (1<<AC97_EI_DACS_SLOT_SHIFT); break;
+			case 3: es |= (2<<AC97_EI_DACS_SLOT_SHIFT); break;
+			}
+			snd_ac97_write_cache(ac97, AC97_EXTENDED_ID, es);
+		}
+		switch (ac97->addr) {
+		case 0:
+			slots |= (1<<AC97_SLOT_PCM_LEFT)|(1<<AC97_SLOT_PCM_RIGHT);
+			if (ac97->scaps & AC97_SCAP_SURROUND_DAC)
+				slots |= (1<<AC97_SLOT_PCM_SLEFT)|(1<<AC97_SLOT_PCM_SRIGHT);
+			if (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC)
+				slots |= (1<<AC97_SLOT_PCM_CENTER)|(1<<AC97_SLOT_LFE);
+			if (ac97->ext_id & AC97_EI_SPDIF) {
+				if (!(ac97->scaps & AC97_SCAP_SURROUND_DAC))
+					*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT)|(1<<AC97_SLOT_SPDIF_RIGHT);
+				else if (!(ac97->scaps & AC97_SCAP_CENTER_LFE_DAC))
+					*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT1)|(1<<AC97_SLOT_SPDIF_RIGHT1);
+				else
+					*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT2)|(1<<AC97_SLOT_SPDIF_RIGHT2);
+			}
+			*rate_table = 0;
+			break;
+		case 1:
+		case 2:
+			slots |= (1<<AC97_SLOT_PCM_SLEFT)|(1<<AC97_SLOT_PCM_SRIGHT);
+			if (ac97->scaps & AC97_SCAP_SURROUND_DAC)
+				slots |= (1<<AC97_SLOT_PCM_CENTER)|(1<<AC97_SLOT_LFE);
+			if (ac97->ext_id & AC97_EI_SPDIF) {
+				if (!(ac97->scaps & AC97_SCAP_SURROUND_DAC))
+					*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT1)|(1<<AC97_SLOT_SPDIF_RIGHT1);
+				else
+					*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT2)|(1<<AC97_SLOT_SPDIF_RIGHT2);
+			}
+			*rate_table = 1;
+			break;
+		case 3:
+			slots |= (1<<AC97_SLOT_PCM_CENTER)|(1<<AC97_SLOT_LFE);
+			if (ac97->ext_id & AC97_EI_SPDIF)
+				*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT2)|(1<<AC97_SLOT_SPDIF_RIGHT2);
+			*rate_table = 2;
+			break;
+		}
+		return slots;
+	} else {
+		unsigned short slots;
+		slots = (1<<AC97_SLOT_PCM_LEFT)|(1<<AC97_SLOT_PCM_RIGHT);
+		if (ac97->scaps & AC97_SCAP_SURROUND_DAC)
+			slots |= (1<<AC97_SLOT_PCM_SLEFT)|(1<<AC97_SLOT_PCM_SRIGHT);
+		if (ac97->scaps & AC97_SCAP_CENTER_LFE_DAC)
+			slots |= (1<<AC97_SLOT_PCM_CENTER)|(1<<AC97_SLOT_LFE);
+		if (ac97->ext_id & AC97_EI_SPDIF) {
+			if (!(ac97->scaps & AC97_SCAP_SURROUND_DAC))
+				*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT)|(1<<AC97_SLOT_SPDIF_RIGHT);
+			else if (!(ac97->scaps & AC97_SCAP_CENTER_LFE_DAC))
+				*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT1)|(1<<AC97_SLOT_SPDIF_RIGHT1);
+			else
+				*spdif_slots = (1<<AC97_SLOT_SPDIF_LEFT2)|(1<<AC97_SLOT_SPDIF_RIGHT2);
+		}
+		*rate_table = 0;
+		return slots;
+	}
+}
+
+static unsigned short get_cslots(ac97_t *ac97)
+{
+	unsigned short slots;
+
+	if (!ac97_is_audio(ac97))
+		return 0;
+	slots = (1<<AC97_SLOT_PCM_LEFT)|(1<<AC97_SLOT_PCM_RIGHT);
+	slots |= (1<<AC97_SLOT_MIC);
+	return slots;
+}
+
+static unsigned int get_rates(struct ac97_pcm *pcm, unsigned int cidx, unsigned short slots, int dbl)
+{
+	int i, idx;
+	unsigned int rates = ~0;
+	unsigned char reg;
+
+	for (i = 3; i < 12; i++) {
+		if (!(slots & (1 << i)))
+			continue;
+		reg = get_slot_reg(pcm, cidx, i, dbl);
+		switch (reg) {
+		case AC97_PCM_FRONT_DAC_RATE:	idx = AC97_RATES_FRONT_DAC; break;
+		case AC97_PCM_SURR_DAC_RATE:	idx = AC97_RATES_SURR_DAC; break;
+		case AC97_PCM_LFE_DAC_RATE:	idx = AC97_RATES_LFE_DAC; break;
+		case AC97_PCM_LR_ADC_RATE:	idx = AC97_RATES_ADC; break;
+		case AC97_PCM_MIC_ADC_RATE:	idx = AC97_RATES_MIC_ADC; break;
+		default:			idx = AC97_RATES_SPDIF; break;
+		}
+		rates &= pcm->r[dbl].codec[cidx]->rates[idx];
+	}
+	if (!dbl)
+		rates &= ~(SNDRV_PCM_RATE_64000 | SNDRV_PCM_RATE_88200 |
+			   SNDRV_PCM_RATE_96000);
+	return rates;
+}
+
+/**
+ * snd_ac97_pcm_assign - assign AC97 slots to given PCM streams
+ * @bus: the ac97 bus instance
+ * @pcms_count: count of PCMs to be assigned
+ * @pcms: PCMs to be assigned
+ *
+ * It assigns available AC97 slots for given PCMs. If none or only
+ * some slots are available, pcm->xxx.slots and pcm->xxx.rslots[] members
+ * are reduced and might be zero.
+ */
+int snd_ac97_pcm_assign(ac97_bus_t *bus,
+			unsigned short pcms_count,
+			const struct ac97_pcm *pcms)
+{
+	int i, j, k;
+	const struct ac97_pcm *pcm;
+	struct ac97_pcm *rpcms, *rpcm;
+	unsigned short avail_slots[2][4];
+	unsigned char rate_table[2][4];
+	unsigned short tmp, slots;
+	unsigned short spdif_slots[4];
+	unsigned int rates;
+	ac97_t *codec;
+
+	rpcms = kcalloc(pcms_count, sizeof(struct ac97_pcm), GFP_KERNEL);
+	if (rpcms == NULL)
+		return -ENOMEM;
+	memset(avail_slots, 0, sizeof(avail_slots));
+	memset(rate_table, 0, sizeof(rate_table));
+	memset(spdif_slots, 0, sizeof(spdif_slots));
+	for (i = 0; i < 4; i++) {
+		codec = bus->codec[i];
+		if (!codec)
+			continue;
+		avail_slots[0][i] = get_pslots(codec, &rate_table[0][i], &spdif_slots[i]);
+		avail_slots[1][i] = get_cslots(codec);
+		if (!(codec->scaps & AC97_SCAP_INDEP_SDIN)) {
+			for (j = 0; j < i; j++) {
+				if (bus->codec[j])
+					avail_slots[1][i] &= ~avail_slots[1][j];
+			}
+		}
+	}
+	/* first step - exclusive devices */
+	for (i = 0; i < pcms_count; i++) {
+		pcm = &pcms[i];
+		rpcm = &rpcms[i];
+		/* low-level driver thinks that it's more clever */
+		if (pcm->copy_flag) {
+			*rpcm = *pcm;
+			continue;
+		}
+		rpcm->stream = pcm->stream;
+		rpcm->exclusive = pcm->exclusive;
+		rpcm->spdif = pcm->spdif;
+		rpcm->private_value = pcm->private_value;
+		rpcm->bus = bus;
+		rpcm->rates = ~0;
+		slots = pcm->r[0].slots;
+		for (j = 0; j < 4 && slots; j++) {
+			if (!bus->codec[j])
+				continue;
+			rates = ~0;
+			if (pcm->spdif && pcm->stream == 0)
+				tmp = spdif_slots[j];
+			else
+				tmp = avail_slots[pcm->stream][j];
+			if (pcm->exclusive) {
+				/* exclusive access */
+				tmp &= slots;
+				for (k = 0; k < i; k++) {
+					if (rpcm->stream == rpcms[k].stream)
+						tmp &= ~rpcms[k].r[0].rslots[j];
+				}
+			} else {
+				/* non-exclusive access */
+				tmp &= pcm->r[0].slots;
+			}
+			if (tmp) {
+				rpcm->r[0].rslots[j] = tmp;
+				rpcm->r[0].codec[j] = bus->codec[j];
+				rpcm->r[0].rate_table[j] = rate_table[pcm->stream][j];
+				if (bus->no_vra)
+					rates = SNDRV_PCM_RATE_48000;
+				else
+					rates = get_rates(rpcm, j, tmp, 0);
+				if (pcm->exclusive)
+					avail_slots[pcm->stream][j] &= ~tmp;
+			}
+			slots &= ~tmp;
+			rpcm->r[0].slots |= tmp;
+			rpcm->rates &= rates;
+		}
+		/* for double rate, we check the first codec only */
+		if (pcm->stream == SNDRV_PCM_STREAM_PLAYBACK &&
+		    bus->codec[0] && (bus->codec[0]->flags & AC97_DOUBLE_RATE) &&
+		    rate_table[pcm->stream][0] == 0) {
+			tmp = (1<<AC97_SLOT_PCM_LEFT) | (1<<AC97_SLOT_PCM_RIGHT) |
+			      (1<<AC97_SLOT_PCM_LEFT_0) | (1<<AC97_SLOT_PCM_RIGHT_0);
+			if ((tmp & pcm->r[1].slots) == tmp) {
+				rpcm->r[1].slots = tmp;
+				rpcm->r[1].rslots[0] = tmp;
+				rpcm->r[1].rate_table[0] = 0;
+				rpcm->r[1].codec[0] = bus->codec[0];
+				if (pcm->exclusive)
+					avail_slots[pcm->stream][0] &= ~tmp;
+				if (bus->no_vra)
+					rates = SNDRV_PCM_RATE_96000;
+				else
+					rates = get_rates(rpcm, 0, tmp, 1);
+				rpcm->rates |= rates;
+			}
+		}
+		if (rpcm->rates == ~0)
+			rpcm->rates = 0; /* not used */
+	}
+	bus->pcms_count = pcms_count;
+	bus->pcms = rpcms;
+	return 0;
+}
+
+/**
+ * snd_ac97_pcm_open - opens the given AC97 pcm
+ * @pcm: the ac97 pcm instance
+ * @rate: rate in Hz, if codec does not support VRA, this value must be 48000Hz
+ * @cfg: output stream characteristics
+ * @slots: a subset of allocated slots (snd_ac97_pcm_assign) for this pcm
+ *
+ * It locks the specified slots and sets the given rate to AC97 registers.
+ */
+int snd_ac97_pcm_open(struct ac97_pcm *pcm, unsigned int rate,
+		      enum ac97_pcm_cfg cfg, unsigned short slots)
+{
+	ac97_bus_t *bus;
+	int i, cidx, r, ok_flag;
+	unsigned int reg_ok[4] = {0,0,0,0};
+	unsigned char reg;
+	int err = 0;
+
+	r = rate > 48000;
+	bus = pcm->bus;
+	if (cfg == AC97_PCM_CFG_SPDIF) {
+		int err;
+		for (cidx = 0; cidx < 4; cidx++)
+			if (bus->codec[cidx] && (bus->codec[cidx]->ext_id & AC97_EI_SPDIF)) {
+				err = set_spdif_rate(bus->codec[cidx], rate);
+				if (err < 0)
+					return err;
+			}
+	}
+	spin_lock_irq(&pcm->bus->bus_lock);
+	for (i = 3; i < 12; i++) {
+		if (!(slots & (1 << i)))
+			continue;
+		ok_flag = 0;
+		for (cidx = 0; cidx < 4; cidx++) {
+			if (bus->used_slots[pcm->stream][cidx] & (1 << i)) {
+				spin_unlock_irq(&pcm->bus->bus_lock);
+				err = -EBUSY;
+				goto error;
+			}
+			if (pcm->r[r].rslots[cidx] & (1 << i)) {
+				bus->used_slots[pcm->stream][cidx] |= (1 << i);
+				ok_flag++;
+			}
+		}
+		if (!ok_flag) {
+			spin_unlock_irq(&pcm->bus->bus_lock);
+			snd_printk(KERN_ERR "cannot find configuration for AC97 slot %i\n", i);
+			err = -EAGAIN;
+			goto error;
+		}
+	}
+	spin_unlock_irq(&pcm->bus->bus_lock);
+	for (i = 3; i < 12; i++) {
+		if (!(slots & (1 << i)))
+			continue;
+		for (cidx = 0; cidx < 4; cidx++) {
+			if (pcm->r[r].rslots[cidx] & (1 << i)) {
+				reg = get_slot_reg(pcm, cidx, i, r);
+				if (reg == 0xff) {
+					snd_printk(KERN_ERR "invalid AC97 slot %i?\n", i);
+					continue;
+				}
+				if (reg_ok[cidx] & (1 << (reg - AC97_PCM_FRONT_DAC_RATE)))
+					continue;
+				//printk(KERN_DEBUG "setting ac97 reg 0x%x to rate %d\n", reg, rate);
+				err = snd_ac97_set_rate(pcm->r[r].codec[cidx], reg, rate);
+				if (err < 0)
+					snd_printk(KERN_ERR "error in snd_ac97_set_rate: cidx=%d, reg=0x%x, rate=%d, err=%d\n", cidx, reg, rate, err);
+				else
+					reg_ok[cidx] |= (1 << (reg - AC97_PCM_FRONT_DAC_RATE));
+			}
+		}
+	}
+	pcm->aslots = slots;
+	return 0;
+
+ error:
+	pcm->aslots = slots;
+	snd_ac97_pcm_close(pcm);
+	return err;
+}
+
+/**
+ * snd_ac97_pcm_close - closes the given AC97 pcm
+ * @pcm: the ac97 pcm instance
+ *
+ * It frees the locked AC97 slots.
+ */
+int snd_ac97_pcm_close(struct ac97_pcm *pcm)
+{
+	ac97_bus_t *bus;
+	unsigned short slots = pcm->aslots;
+	int i, cidx;
+
+	bus = pcm->bus;
+	spin_lock_irq(&pcm->bus->bus_lock);
+	for (i = 3; i < 12; i++) {
+		if (!(slots & (1 << i)))
+			continue;
+		for (cidx = 0; cidx < 4; cidx++)
+			bus->used_slots[pcm->stream][cidx] &= ~(1 << i);
+	}
+	pcm->aslots = 0;
+	spin_unlock_irq(&pcm->bus->bus_lock);
+	return 0;
+}
+
+static int double_rate_hw_constraint_rate(snd_pcm_hw_params_t *params,
+					  snd_pcm_hw_rule_t *rule)
+{
+	snd_interval_t *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	if (channels->min > 2) {
+		static const snd_interval_t single_rates = {
+			.min = 1,
+			.max = 48000,
+		};
+		snd_interval_t *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+		return snd_interval_refine(rate, &single_rates);
+	}
+	return 0;
+}
+
+static int double_rate_hw_constraint_channels(snd_pcm_hw_params_t *params,
+					      snd_pcm_hw_rule_t *rule)
+{
+	snd_interval_t *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	if (rate->min > 48000) {
+		static const snd_interval_t double_rate_channels = {
+			.min = 2,
+			.max = 2,
+		};
+		snd_interval_t *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+		return snd_interval_refine(channels, &double_rate_channels);
+	}
+	return 0;
+}
+
+/**
+ * snd_ac97_pcm_double_rate_rules - set double rate constraints
+ * @runtime: the runtime of the ac97 front playback pcm
+ *
+ * Installs the hardware constraint rules to prevent using double rates and
+ * more than two channels at the same time.
+ */
+int snd_ac97_pcm_double_rate_rules(snd_pcm_runtime_t *runtime)
+{
+	int err;
+
+	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				  double_rate_hw_constraint_rate, NULL,
+				  SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	if (err < 0)
+		return err;
+	err = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+				  double_rate_hw_constraint_channels, NULL,
+				  SNDRV_PCM_HW_PARAM_RATE, -1);
+	return err;
+}
