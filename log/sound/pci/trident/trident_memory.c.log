commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
index b9ebb51893c5..bb24dbf0530d 100644
--- a/sound/pci/trident/trident_memory.c
+++ b/sound/pci/trident/trident_memory.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *  Copyright (c) by Takashi Iwai <tiwai@suse.de>
@@ -5,22 +6,6 @@
  *
  *  Trident 4DWave-NX memory page allocation (TLB area)
  *  Trident chip can handle only 16MByte of the memory at the same time.
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/io.h>

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
index 04c474658e3c..b9ebb51893c5 100644
--- a/sound/pci/trident/trident_memory.c
+++ b/sound/pci/trident/trident_memory.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/pci.h>
 #include <linux/time.h>
 #include <linux/mutex.h>

commit e2ff8406ade81f5f431a3cac6ef96720c37906cd
Author: Sachin Kamat <sachin.kamat@samsung.com>
Date:   Tue Jul 1 10:10:30 2014 +0530

    ALSA: trident: Remove unused variable in trident_memory.c
    
    'prev' is not used in the function. Remove it.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@samsung.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
index 3102a579660b..04c474658e3c 100644
--- a/sound/pci/trident/trident_memory.c
+++ b/sound/pci/trident/trident_memory.c
@@ -139,12 +139,11 @@ static inline void *offset_ptr(struct snd_trident *trident, int offset)
 static struct snd_util_memblk *
 search_empty(struct snd_util_memhdr *hdr, int size)
 {
-	struct snd_util_memblk *blk, *prev;
+	struct snd_util_memblk *blk;
 	int page, psize;
 	struct list_head *p;
 
 	psize = get_aligned_page(size + ALIGN_PAGE_SIZE -1);
-	prev = NULL;
 	page = 0;
 	list_for_each(p, &hdr->block) {
 		blk = list_entry(p, struct snd_util_memblk, list);

commit 81fcb170852d58d7ebd8101a8ef970c82056426e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 16:37:05 2012 +0200

    ALSA: Move some headers to local directories from include/sound
    
    This is a bit clean up of public sound header directory.
    Some header files in include/sound aren't really necessary to be
    located there but can be moved to their local directories gracefully.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
index f9779e23fe57..3102a579660b 100644
--- a/sound/pci/trident/trident_memory.c
+++ b/sound/pci/trident/trident_memory.c
@@ -29,7 +29,7 @@
 #include <linux/mutex.h>
 
 #include <sound/core.h>
-#include <sound/trident.h>
+#include "trident.h"
 
 /* page arguments of these two macros are Trident page (4096 bytes), not like
  * aligned pages in others

commit 77a23f2695bb2de0cd74599400dc55109c531b72
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 21 13:00:13 2008 +0200

    ALSA: Clean up SG-buffer helper functions and macros
    
    Clean up SG-buffer helper functions and macros.  Helpers take substream
    as arguments now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
index 2fe3b1fab53a..f9779e23fe57 100644
--- a/sound/pci/trident/trident_memory.c
+++ b/sound/pci/trident/trident_memory.c
@@ -194,7 +194,6 @@ snd_trident_alloc_sg_pages(struct snd_trident *trident,
 	struct snd_util_memblk *blk;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int idx, page;
-	struct snd_sg_buf *sgbuf = snd_pcm_substream_sgbuf(substream);
 
 	if (snd_BUG_ON(runtime->dma_bytes <= 0 ||
 		       runtime->dma_bytes > SNDRV_TRIDENT_MAX_PAGES *
@@ -212,18 +211,14 @@ snd_trident_alloc_sg_pages(struct snd_trident *trident,
 		mutex_unlock(&hdr->block_mutex);
 		return NULL;
 	}
-	if (lastpg(blk) - firstpg(blk) >= sgbuf->pages) {
-		snd_printk(KERN_ERR "page calculation doesn't match: allocated pages = %d, trident = %d/%d\n", sgbuf->pages, firstpg(blk), lastpg(blk));
-		__snd_util_mem_free(hdr, blk);
-		mutex_unlock(&hdr->block_mutex);
-		return NULL;
-	}
 			   
 	/* set TLB entries */
 	idx = 0;
 	for (page = firstpg(blk); page <= lastpg(blk); page++, idx++) {
-		dma_addr_t addr = sgbuf->table[idx].addr;
-		unsigned long ptr = (unsigned long)sgbuf->table[idx].buf;
+		unsigned long ofs = idx << PAGE_SHIFT;
+		dma_addr_t addr = snd_pcm_sgbuf_get_addr(substream, ofs);
+		unsigned long ptr = (unsigned long)
+			snd_pcm_sgbuf_get_ptr(substream, ofs);
 		if (! is_valid_page(addr)) {
 			__snd_util_mem_free(hdr, blk);
 			mutex_unlock(&hdr->block_mutex);

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
index 3fd7f1b29b0f..2fe3b1fab53a 100644
--- a/sound/pci/trident/trident_memory.c
+++ b/sound/pci/trident/trident_memory.c
@@ -196,9 +196,13 @@ snd_trident_alloc_sg_pages(struct snd_trident *trident,
 	int idx, page;
 	struct snd_sg_buf *sgbuf = snd_pcm_substream_sgbuf(substream);
 
-	snd_assert(runtime->dma_bytes > 0 && runtime->dma_bytes <= SNDRV_TRIDENT_MAX_PAGES * SNDRV_TRIDENT_PAGE_SIZE, return NULL);
+	if (snd_BUG_ON(runtime->dma_bytes <= 0 ||
+		       runtime->dma_bytes > SNDRV_TRIDENT_MAX_PAGES *
+					SNDRV_TRIDENT_PAGE_SIZE))
+		return NULL;
 	hdr = trident->tlb.memhdr;
-	snd_assert(hdr != NULL, return NULL);
+	if (snd_BUG_ON(!hdr))
+		return NULL;
 
 	
 
@@ -245,9 +249,13 @@ snd_trident_alloc_cont_pages(struct snd_trident *trident,
 	dma_addr_t addr;
 	unsigned long ptr;
 
-	snd_assert(runtime->dma_bytes> 0 && runtime->dma_bytes <= SNDRV_TRIDENT_MAX_PAGES * SNDRV_TRIDENT_PAGE_SIZE, return NULL);
+	if (snd_BUG_ON(runtime->dma_bytes <= 0 ||
+		       runtime->dma_bytes > SNDRV_TRIDENT_MAX_PAGES *
+					SNDRV_TRIDENT_PAGE_SIZE))
+		return NULL;
 	hdr = trident->tlb.memhdr;
-	snd_assert(hdr != NULL, return NULL);
+	if (snd_BUG_ON(!hdr))
+		return NULL;
 
 	mutex_lock(&hdr->block_mutex);
 	blk = search_empty(hdr, runtime->dma_bytes);
@@ -279,8 +287,8 @@ struct snd_util_memblk *
 snd_trident_alloc_pages(struct snd_trident *trident,
 			struct snd_pcm_substream *substream)
 {
-	snd_assert(trident != NULL, return NULL);
-	snd_assert(substream != NULL, return NULL);
+	if (snd_BUG_ON(!trident || !substream))
+		return NULL;
 	if (substream->dma_buffer.dev.type == SNDRV_DMA_TYPE_DEV_SG)
 		return snd_trident_alloc_sg_pages(trident, substream);
 	else
@@ -297,8 +305,8 @@ int snd_trident_free_pages(struct snd_trident *trident,
 	struct snd_util_memhdr *hdr;
 	int page;
 
-	snd_assert(trident != NULL, return -EINVAL);
-	snd_assert(blk != NULL, return -EINVAL);
+	if (snd_BUG_ON(!trident || !blk))
+		return -EINVAL;
 
 	hdr = trident->tlb.memhdr;
 	mutex_lock(&hdr->block_mutex);

commit 8bb8b453cb458d8f62411e78a4cfd6d860b503b6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 30 09:47:45 2008 +0200

    [ALSA] trident - clean up obsolete synth codes
    
    Clean up the unused synth codes in the memory handling of trident driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
index df9b487fa17e..3fd7f1b29b0f 100644
--- a/sound/pci/trident/trident_memory.c
+++ b/sound/pci/trident/trident_memory.c
@@ -310,181 +310,3 @@ int snd_trident_free_pages(struct snd_trident *trident,
 	mutex_unlock(&hdr->block_mutex);
 	return 0;
 }
-
-
-/*----------------------------------------------------------------
- * memory allocation using multiple pages (for synth)
- *----------------------------------------------------------------
- * Unlike the DMA allocation above, non-contiguous pages are
- * assigned to TLB.
- *----------------------------------------------------------------*/
-
-/*
- */
-static int synth_alloc_pages(struct snd_trident *hw, struct snd_util_memblk *blk);
-static int synth_free_pages(struct snd_trident *hw, struct snd_util_memblk *blk);
-
-/*
- * allocate a synth sample area
- */
-struct snd_util_memblk *
-snd_trident_synth_alloc(struct snd_trident *hw, unsigned int size)
-{
-	struct snd_util_memblk *blk;
-	struct snd_util_memhdr *hdr = hw->tlb.memhdr; 
-
-	mutex_lock(&hdr->block_mutex);
-	blk = __snd_util_mem_alloc(hdr, size);
-	if (blk == NULL) {
-		mutex_unlock(&hdr->block_mutex);
-		return NULL;
-	}
-	if (synth_alloc_pages(hw, blk)) {
-		__snd_util_mem_free(hdr, blk);
-		mutex_unlock(&hdr->block_mutex);
-		return NULL;
-	}
-	mutex_unlock(&hdr->block_mutex);
-	return blk;
-}
-
-EXPORT_SYMBOL(snd_trident_synth_alloc);
-
-/*
- * free a synth sample area
- */
-int
-snd_trident_synth_free(struct snd_trident *hw, struct snd_util_memblk *blk)
-{
-	struct snd_util_memhdr *hdr = hw->tlb.memhdr; 
-
-	mutex_lock(&hdr->block_mutex);
-	synth_free_pages(hw, blk);
-	 __snd_util_mem_free(hdr, blk);
-	mutex_unlock(&hdr->block_mutex);
-	return 0;
-}
-
-EXPORT_SYMBOL(snd_trident_synth_free);
-
-/*
- * reset TLB entry and free kernel page
- */
-static void clear_tlb(struct snd_trident *trident, int page)
-{
-	void *ptr = page_to_ptr(trident, page);
-	dma_addr_t addr = page_to_addr(trident, page);
-	set_silent_tlb(trident, page);
-	if (ptr) {
-		struct snd_dma_buffer dmab;
-		dmab.dev.type = SNDRV_DMA_TYPE_DEV;
-		dmab.dev.dev = snd_dma_pci_data(trident->pci);
-		dmab.area = ptr;
-		dmab.addr = addr;
-		dmab.bytes = ALIGN_PAGE_SIZE;
-		snd_dma_free_pages(&dmab);
-	}
-}
-
-/* check new allocation range */
-static void get_single_page_range(struct snd_util_memhdr *hdr,
-				  struct snd_util_memblk *blk,
-				  int *first_page_ret, int *last_page_ret)
-{
-	struct list_head *p;
-	struct snd_util_memblk *q;
-	int first_page, last_page;
-	first_page = firstpg(blk);
-	if ((p = blk->list.prev) != &hdr->block) {
-		q = list_entry(p, struct snd_util_memblk, list);
-		if (lastpg(q) == first_page)
-			first_page++;  /* first page was already allocated */
-	}
-	last_page = lastpg(blk);
-	if ((p = blk->list.next) != &hdr->block) {
-		q = list_entry(p, struct snd_util_memblk, list);
-		if (firstpg(q) == last_page)
-			last_page--; /* last page was already allocated */
-	}
-	*first_page_ret = first_page;
-	*last_page_ret = last_page;
-}
-
-/*
- * allocate kernel pages and assign them to TLB
- */
-static int synth_alloc_pages(struct snd_trident *hw, struct snd_util_memblk *blk)
-{
-	int page, first_page, last_page;
-	struct snd_dma_buffer dmab;
-
-	firstpg(blk) = get_aligned_page(blk->offset);
-	lastpg(blk) = get_aligned_page(blk->offset + blk->size - 1);
-	get_single_page_range(hw->tlb.memhdr, blk, &first_page, &last_page);
-
-	/* allocate a kernel page for each Trident page -
-	 * fortunately Trident page size and kernel PAGE_SIZE is identical!
-	 */
-	for (page = first_page; page <= last_page; page++) {
-		if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(hw->pci),
-					ALIGN_PAGE_SIZE, &dmab) < 0)
-			goto __fail;
-		if (! is_valid_page(dmab.addr)) {
-			snd_dma_free_pages(&dmab);
-			goto __fail;
-		}
-		set_tlb_bus(hw, page, (unsigned long)dmab.area, dmab.addr);
-	}
-	return 0;
-
-__fail:
-	/* release allocated pages */
-	last_page = page - 1;
-	for (page = first_page; page <= last_page; page++)
-		clear_tlb(hw, page);
-
-	return -ENOMEM;
-}
-
-/*
- * free pages
- */
-static int synth_free_pages(struct snd_trident *trident, struct snd_util_memblk *blk)
-{
-	int page, first_page, last_page;
-
-	get_single_page_range(trident->tlb.memhdr, blk, &first_page, &last_page);
-	for (page = first_page; page <= last_page; page++)
-		clear_tlb(trident, page);
-
-	return 0;
-}
-
-/*
- * copy_from_user(blk + offset, data, size)
- */
-int snd_trident_synth_copy_from_user(struct snd_trident *trident,
-				     struct snd_util_memblk *blk,
-				     int offset, const char __user *data, int size)
-{
-	int page, nextofs, end_offset, temp, temp1;
-
-	offset += blk->offset;
-	end_offset = offset + size;
-	page = get_aligned_page(offset) + 1;
-	do {
-		nextofs = aligned_page_offset(page);
-		temp = nextofs - offset;
-		temp1 = end_offset - offset;
-		if (temp1 < temp)
-			temp = temp1;
-		if (copy_from_user(offset_ptr(trident, offset), data, temp))
-			return -EFAULT;
-		offset = nextofs;
-		data += temp;
-		page++;
-	} while (offset < end_offset);
-	return 0;
-}
-
-EXPORT_SYMBOL(snd_trident_synth_copy_from_user);

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
index 847b8c6d5c0a..df9b487fa17e 100644
--- a/sound/pci/trident/trident_memory.c
+++ b/sound/pci/trident/trident_memory.c
@@ -23,7 +23,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <asm/io.h>
 #include <linux/pci.h>
 #include <linux/time.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
index aff3f874131c..847b8c6d5c0a 100644
--- a/sound/pci/trident/trident_memory.c
+++ b/sound/pci/trident/trident_memory.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *  Copyright (c) by Takashi Iwai <tiwai@suse.de>
  *  Copyright (c) by Scott McNab <sdm@fractalgraphics.com.au>
  *

commit cbef55f3d8e4e7efef4703c82302a0021d781483
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:40 2006 +0200

    [ALSA] trident - Move EXPORT_SYMBOL() to adjacent to each function
    
    Move EXPORT_SYMBOL() to adjacent to each exported function/variable.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
index 46c6982c9e88..aff3f874131c 100644
--- a/sound/pci/trident/trident_memory.c
+++ b/sound/pci/trident/trident_memory.c
@@ -349,6 +349,7 @@ snd_trident_synth_alloc(struct snd_trident *hw, unsigned int size)
 	return blk;
 }
 
+EXPORT_SYMBOL(snd_trident_synth_alloc);
 
 /*
  * free a synth sample area
@@ -365,6 +366,7 @@ snd_trident_synth_free(struct snd_trident *hw, struct snd_util_memblk *blk)
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_trident_synth_free);
 
 /*
  * reset TLB entry and free kernel page
@@ -486,3 +488,4 @@ int snd_trident_synth_copy_from_user(struct snd_trident *trident,
 	return 0;
 }
 
+EXPORT_SYMBOL(snd_trident_synth_copy_from_user);

commit 62932df8fb20ba2fb53a95fa52445eba22e821fe
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 16 16:34:20 2006 +0100

    [ALSA] semaphore -> mutex (PCI part)
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
index cf09ea99755c..46c6982c9e88 100644
--- a/sound/pci/trident/trident_memory.c
+++ b/sound/pci/trident/trident_memory.c
@@ -27,6 +27,8 @@
 #include <asm/io.h>
 #include <linux/pci.h>
 #include <linux/time.h>
+#include <linux/mutex.h>
+
 #include <sound/core.h>
 #include <sound/trident.h>
 
@@ -201,16 +203,16 @@ snd_trident_alloc_sg_pages(struct snd_trident *trident,
 
 	
 
-	down(&hdr->block_mutex);
+	mutex_lock(&hdr->block_mutex);
 	blk = search_empty(hdr, runtime->dma_bytes);
 	if (blk == NULL) {
-		up(&hdr->block_mutex);
+		mutex_unlock(&hdr->block_mutex);
 		return NULL;
 	}
 	if (lastpg(blk) - firstpg(blk) >= sgbuf->pages) {
 		snd_printk(KERN_ERR "page calculation doesn't match: allocated pages = %d, trident = %d/%d\n", sgbuf->pages, firstpg(blk), lastpg(blk));
 		__snd_util_mem_free(hdr, blk);
-		up(&hdr->block_mutex);
+		mutex_unlock(&hdr->block_mutex);
 		return NULL;
 	}
 			   
@@ -221,12 +223,12 @@ snd_trident_alloc_sg_pages(struct snd_trident *trident,
 		unsigned long ptr = (unsigned long)sgbuf->table[idx].buf;
 		if (! is_valid_page(addr)) {
 			__snd_util_mem_free(hdr, blk);
-			up(&hdr->block_mutex);
+			mutex_unlock(&hdr->block_mutex);
 			return NULL;
 		}
 		set_tlb_bus(trident, page, ptr, addr);
 	}
-	up(&hdr->block_mutex);
+	mutex_unlock(&hdr->block_mutex);
 	return blk;
 }
 
@@ -248,10 +250,10 @@ snd_trident_alloc_cont_pages(struct snd_trident *trident,
 	hdr = trident->tlb.memhdr;
 	snd_assert(hdr != NULL, return NULL);
 
-	down(&hdr->block_mutex);
+	mutex_lock(&hdr->block_mutex);
 	blk = search_empty(hdr, runtime->dma_bytes);
 	if (blk == NULL) {
-		up(&hdr->block_mutex);
+		mutex_unlock(&hdr->block_mutex);
 		return NULL;
 	}
 			   
@@ -262,12 +264,12 @@ snd_trident_alloc_cont_pages(struct snd_trident *trident,
 	     ptr += SNDRV_TRIDENT_PAGE_SIZE, addr += SNDRV_TRIDENT_PAGE_SIZE) {
 		if (! is_valid_page(addr)) {
 			__snd_util_mem_free(hdr, blk);
-			up(&hdr->block_mutex);
+			mutex_unlock(&hdr->block_mutex);
 			return NULL;
 		}
 		set_tlb_bus(trident, page, ptr, addr);
 	}
-	up(&hdr->block_mutex);
+	mutex_unlock(&hdr->block_mutex);
 	return blk;
 }
 
@@ -300,13 +302,13 @@ int snd_trident_free_pages(struct snd_trident *trident,
 	snd_assert(blk != NULL, return -EINVAL);
 
 	hdr = trident->tlb.memhdr;
-	down(&hdr->block_mutex);
+	mutex_lock(&hdr->block_mutex);
 	/* reset TLB entries */
 	for (page = firstpg(blk); page <= lastpg(blk); page++)
 		set_silent_tlb(trident, page);
 	/* free memory block */
 	__snd_util_mem_free(hdr, blk);
-	up(&hdr->block_mutex);
+	mutex_unlock(&hdr->block_mutex);
 	return 0;
 }
 
@@ -332,18 +334,18 @@ snd_trident_synth_alloc(struct snd_trident *hw, unsigned int size)
 	struct snd_util_memblk *blk;
 	struct snd_util_memhdr *hdr = hw->tlb.memhdr; 
 
-	down(&hdr->block_mutex);
+	mutex_lock(&hdr->block_mutex);
 	blk = __snd_util_mem_alloc(hdr, size);
 	if (blk == NULL) {
-		up(&hdr->block_mutex);
+		mutex_unlock(&hdr->block_mutex);
 		return NULL;
 	}
 	if (synth_alloc_pages(hw, blk)) {
 		__snd_util_mem_free(hdr, blk);
-		up(&hdr->block_mutex);
+		mutex_unlock(&hdr->block_mutex);
 		return NULL;
 	}
-	up(&hdr->block_mutex);
+	mutex_unlock(&hdr->block_mutex);
 	return blk;
 }
 
@@ -356,10 +358,10 @@ snd_trident_synth_free(struct snd_trident *hw, struct snd_util_memblk *blk)
 {
 	struct snd_util_memhdr *hdr = hw->tlb.memhdr; 
 
-	down(&hdr->block_mutex);
+	mutex_lock(&hdr->block_mutex);
 	synth_free_pages(hw, blk);
 	 __snd_util_mem_free(hdr, blk);
-	up(&hdr->block_mutex);
+	mutex_unlock(&hdr->block_mutex);
 	return 0;
 }
 

commit bee1a5be8b6210a0a4e27e38d0f76847b0a014ae
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:53:15 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI Trident
    
    Modules: Trident driver
    
    Remove xxx_t typedefs from the PCI Trident driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
index f3e6c546af74..cf09ea99755c 100644
--- a/sound/pci/trident/trident_memory.c
+++ b/sound/pci/trident/trident_memory.c
@@ -68,13 +68,14 @@
 #define page_to_addr(trident,page)	__tlb_to_addr(trident, (page) << 1)
 
 /* fill TLB entries -- we need to fill two entries */
-static inline void set_tlb_bus(trident_t *trident, int page, unsigned long ptr, dma_addr_t addr)
+static inline void set_tlb_bus(struct snd_trident *trident, int page,
+			       unsigned long ptr, dma_addr_t addr)
 {
 	page <<= 1;
 	__set_tlb_bus(trident, page, ptr, addr);
 	__set_tlb_bus(trident, page+1, ptr + SNDRV_TRIDENT_PAGE_SIZE, addr + SNDRV_TRIDENT_PAGE_SIZE);
 }
-static inline void set_silent_tlb(trident_t *trident, int page)
+static inline void set_silent_tlb(struct snd_trident *trident, int page)
 {
 	page <<= 1;
 	__set_tlb_bus(trident, page, (unsigned long)trident->tlb.silent_page.area, trident->tlb.silent_page.addr);
@@ -97,7 +98,8 @@ static inline void set_silent_tlb(trident_t *trident, int page)
 #define page_to_addr(trident,page)	__tlb_to_addr(trident, (page) * UNIT_PAGES)
 
 /* fill TLB entries -- UNIT_PAGES entries must be filled */
-static inline void set_tlb_bus(trident_t *trident, int page, unsigned long ptr, dma_addr_t addr)
+static inline void set_tlb_bus(struct snd_trident *trident, int page,
+			       unsigned long ptr, dma_addr_t addr)
 {
 	int i;
 	page *= UNIT_PAGES;
@@ -107,7 +109,7 @@ static inline void set_tlb_bus(trident_t *trident, int page, unsigned long ptr,
 		addr += SNDRV_TRIDENT_PAGE_SIZE;
 	}
 }
-static inline void set_silent_tlb(trident_t *trident, int page)
+static inline void set_silent_tlb(struct snd_trident *trident, int page)
 {
 	int i;
 	page *= UNIT_PAGES;
@@ -118,7 +120,7 @@ static inline void set_silent_tlb(trident_t *trident, int page)
 #endif /* PAGE_SIZE */
 
 /* calculate buffer pointer from offset address */
-static inline void *offset_ptr(trident_t *trident, int offset)
+static inline void *offset_ptr(struct snd_trident *trident, int offset)
 {
 	char *ptr;
 	ptr = page_to_ptr(trident, get_aligned_page(offset));
@@ -127,16 +129,16 @@ static inline void *offset_ptr(trident_t *trident, int offset)
 }
 
 /* first and last (aligned) pages of memory block */
-#define firstpg(blk)	(((snd_trident_memblk_arg_t*)snd_util_memblk_argptr(blk))->first_page)
-#define lastpg(blk)	(((snd_trident_memblk_arg_t*)snd_util_memblk_argptr(blk))->last_page)
+#define firstpg(blk)	(((struct snd_trident_memblk_arg *)snd_util_memblk_argptr(blk))->first_page)
+#define lastpg(blk)	(((struct snd_trident_memblk_arg *)snd_util_memblk_argptr(blk))->last_page)
 
 /*
  * search empty pages which may contain given size
  */
-static snd_util_memblk_t *
-search_empty(snd_util_memhdr_t *hdr, int size)
+static struct snd_util_memblk *
+search_empty(struct snd_util_memhdr *hdr, int size)
 {
-	snd_util_memblk_t *blk, *prev;
+	struct snd_util_memblk *blk, *prev;
 	int page, psize;
 	struct list_head *p;
 
@@ -144,7 +146,7 @@ search_empty(snd_util_memhdr_t *hdr, int size)
 	prev = NULL;
 	page = 0;
 	list_for_each(p, &hdr->block) {
-		blk = list_entry(p, snd_util_memblk_t, list);
+		blk = list_entry(p, struct snd_util_memblk, list);
 		if (page + psize <= firstpg(blk))
 			goto __found_pages;
 		page = lastpg(blk) + 1;
@@ -183,12 +185,13 @@ static int is_valid_page(unsigned long ptr)
 /*
  * page allocation for DMA (Scatter-Gather version)
  */
-static snd_util_memblk_t *
-snd_trident_alloc_sg_pages(trident_t *trident, snd_pcm_substream_t *substream)
+static struct snd_util_memblk *
+snd_trident_alloc_sg_pages(struct snd_trident *trident,
+			   struct snd_pcm_substream *substream)
 {
-	snd_util_memhdr_t *hdr;
-	snd_util_memblk_t *blk;
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_util_memhdr *hdr;
+	struct snd_util_memblk *blk;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	int idx, page;
 	struct snd_sg_buf *sgbuf = snd_pcm_substream_sgbuf(substream);
 
@@ -230,13 +233,14 @@ snd_trident_alloc_sg_pages(trident_t *trident, snd_pcm_substream_t *substream)
 /*
  * page allocation for DMA (contiguous version)
  */
-static snd_util_memblk_t *
-snd_trident_alloc_cont_pages(trident_t *trident, snd_pcm_substream_t *substream)
+static struct snd_util_memblk *
+snd_trident_alloc_cont_pages(struct snd_trident *trident,
+			     struct snd_pcm_substream *substream)
 {
-	snd_util_memhdr_t *hdr;
-	snd_util_memblk_t *blk;
+	struct snd_util_memhdr *hdr;
+	struct snd_util_memblk *blk;
 	int page;
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	dma_addr_t addr;
 	unsigned long ptr;
 
@@ -270,8 +274,9 @@ snd_trident_alloc_cont_pages(trident_t *trident, snd_pcm_substream_t *substream)
 /*
  * page allocation for DMA
  */
-snd_util_memblk_t *
-snd_trident_alloc_pages(trident_t *trident, snd_pcm_substream_t *substream)
+struct snd_util_memblk *
+snd_trident_alloc_pages(struct snd_trident *trident,
+			struct snd_pcm_substream *substream)
 {
 	snd_assert(trident != NULL, return NULL);
 	snd_assert(substream != NULL, return NULL);
@@ -285,9 +290,10 @@ snd_trident_alloc_pages(trident_t *trident, snd_pcm_substream_t *substream)
 /*
  * release DMA buffer from page table
  */
-int snd_trident_free_pages(trident_t *trident, snd_util_memblk_t *blk)
+int snd_trident_free_pages(struct snd_trident *trident,
+			   struct snd_util_memblk *blk)
 {
-	snd_util_memhdr_t *hdr;
+	struct snd_util_memhdr *hdr;
 	int page;
 
 	snd_assert(trident != NULL, return -EINVAL);
@@ -314,17 +320,17 @@ int snd_trident_free_pages(trident_t *trident, snd_util_memblk_t *blk)
 
 /*
  */
-static int synth_alloc_pages(trident_t *hw, snd_util_memblk_t *blk);
-static int synth_free_pages(trident_t *hw, snd_util_memblk_t *blk);
+static int synth_alloc_pages(struct snd_trident *hw, struct snd_util_memblk *blk);
+static int synth_free_pages(struct snd_trident *hw, struct snd_util_memblk *blk);
 
 /*
  * allocate a synth sample area
  */
-snd_util_memblk_t *
-snd_trident_synth_alloc(trident_t *hw, unsigned int size)
+struct snd_util_memblk *
+snd_trident_synth_alloc(struct snd_trident *hw, unsigned int size)
 {
-	snd_util_memblk_t *blk;
-	snd_util_memhdr_t *hdr = hw->tlb.memhdr; 
+	struct snd_util_memblk *blk;
+	struct snd_util_memhdr *hdr = hw->tlb.memhdr; 
 
 	down(&hdr->block_mutex);
 	blk = __snd_util_mem_alloc(hdr, size);
@@ -346,9 +352,9 @@ snd_trident_synth_alloc(trident_t *hw, unsigned int size)
  * free a synth sample area
  */
 int
-snd_trident_synth_free(trident_t *hw, snd_util_memblk_t *blk)
+snd_trident_synth_free(struct snd_trident *hw, struct snd_util_memblk *blk)
 {
-	snd_util_memhdr_t *hdr = hw->tlb.memhdr; 
+	struct snd_util_memhdr *hdr = hw->tlb.memhdr; 
 
 	down(&hdr->block_mutex);
 	synth_free_pages(hw, blk);
@@ -361,7 +367,7 @@ snd_trident_synth_free(trident_t *hw, snd_util_memblk_t *blk)
 /*
  * reset TLB entry and free kernel page
  */
-static void clear_tlb(trident_t *trident, int page)
+static void clear_tlb(struct snd_trident *trident, int page)
 {
 	void *ptr = page_to_ptr(trident, page);
 	dma_addr_t addr = page_to_addr(trident, page);
@@ -378,20 +384,22 @@ static void clear_tlb(trident_t *trident, int page)
 }
 
 /* check new allocation range */
-static void get_single_page_range(snd_util_memhdr_t *hdr, snd_util_memblk_t *blk, int *first_page_ret, int *last_page_ret)
+static void get_single_page_range(struct snd_util_memhdr *hdr,
+				  struct snd_util_memblk *blk,
+				  int *first_page_ret, int *last_page_ret)
 {
 	struct list_head *p;
-	snd_util_memblk_t *q;
+	struct snd_util_memblk *q;
 	int first_page, last_page;
 	first_page = firstpg(blk);
 	if ((p = blk->list.prev) != &hdr->block) {
-		q = list_entry(p, snd_util_memblk_t, list);
+		q = list_entry(p, struct snd_util_memblk, list);
 		if (lastpg(q) == first_page)
 			first_page++;  /* first page was already allocated */
 	}
 	last_page = lastpg(blk);
 	if ((p = blk->list.next) != &hdr->block) {
-		q = list_entry(p, snd_util_memblk_t, list);
+		q = list_entry(p, struct snd_util_memblk, list);
 		if (firstpg(q) == last_page)
 			last_page--; /* last page was already allocated */
 	}
@@ -402,7 +410,7 @@ static void get_single_page_range(snd_util_memhdr_t *hdr, snd_util_memblk_t *blk
 /*
  * allocate kernel pages and assign them to TLB
  */
-static int synth_alloc_pages(trident_t *hw, snd_util_memblk_t *blk)
+static int synth_alloc_pages(struct snd_trident *hw, struct snd_util_memblk *blk)
 {
 	int page, first_page, last_page;
 	struct snd_dma_buffer dmab;
@@ -438,7 +446,7 @@ static int synth_alloc_pages(trident_t *hw, snd_util_memblk_t *blk)
 /*
  * free pages
  */
-static int synth_free_pages(trident_t *trident, snd_util_memblk_t *blk)
+static int synth_free_pages(struct snd_trident *trident, struct snd_util_memblk *blk)
 {
 	int page, first_page, last_page;
 
@@ -452,7 +460,9 @@ static int synth_free_pages(trident_t *trident, snd_util_memblk_t *blk)
 /*
  * copy_from_user(blk + offset, data, size)
  */
-int snd_trident_synth_copy_from_user(trident_t *trident, snd_util_memblk_t *blk, int offset, const char __user *data, int size)
+int snd_trident_synth_copy_from_user(struct snd_trident *trident,
+				     struct snd_util_memblk *blk,
+				     int offset, const char __user *data, int size)
 {
 	int page, nextofs, end_offset, temp, temp1;
 

commit 99b359ba10a582148c6725f428a33ba5356dd993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 20 18:26:44 2005 +0200

    [ALSA] Add missing KERN_* suffix to printk
    
    Add missing KERN_* suffix to printk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
index 333d3790692a..f3e6c546af74 100644
--- a/sound/pci/trident/trident_memory.c
+++ b/sound/pci/trident/trident_memory.c
@@ -170,11 +170,11 @@ search_empty(snd_util_memhdr_t *hdr, int size)
 static int is_valid_page(unsigned long ptr)
 {
 	if (ptr & ~0x3fffffffUL) {
-		snd_printk("max memory size is 1GB!!\n");
+		snd_printk(KERN_ERR "max memory size is 1GB!!\n");
 		return 0;
 	}
 	if (ptr & (SNDRV_TRIDENT_PAGE_SIZE-1)) {
-		snd_printk("page is not aligned\n");
+		snd_printk(KERN_ERR "page is not aligned\n");
 		return 0;
 	}
 	return 1;

commit 77933d7276ee8fa0e2947641941a6f7a100a327b
Author: Jesper Juhl <juhl@dif.dk>
Date:   Wed Jul 27 11:46:09 2005 -0700

    [PATCH] clean up inline static vs static inline
    
    `gcc -W' likes to complain if the static keyword is not at the beginning of
    the declaration.  This patch fixes all remaining occurrences of "inline
    static" up with "static inline" in the entire kernel tree (140 occurrences in
    47 files).
    
    While making this change I came across a few lines with trailing whitespace
    that I also fixed up, I have also added or removed a blank line or two here
    and there, but there are no functional changes in the patch.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
index 6cc282681e09..333d3790692a 100644
--- a/sound/pci/trident/trident_memory.c
+++ b/sound/pci/trident/trident_memory.c
@@ -118,7 +118,7 @@ static inline void set_silent_tlb(trident_t *trident, int page)
 #endif /* PAGE_SIZE */
 
 /* calculate buffer pointer from offset address */
-inline static void *offset_ptr(trident_t *trident, int offset)
+static inline void *offset_ptr(trident_t *trident, int offset)
 {
 	char *ptr;
 	ptr = page_to_ptr(trident, get_aligned_page(offset));

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/trident/trident_memory.c b/sound/pci/trident/trident_memory.c
new file mode 100644
index 000000000000..6cc282681e09
--- /dev/null
+++ b/sound/pci/trident/trident_memory.c
@@ -0,0 +1,476 @@
+/*
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Takashi Iwai <tiwai@suse.de>
+ *  Copyright (c) by Scott McNab <sdm@fractalgraphics.com.au>
+ *
+ *  Trident 4DWave-NX memory page allocation (TLB area)
+ *  Trident chip can handle only 16MByte of the memory at the same time.
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/pci.h>
+#include <linux/time.h>
+#include <sound/core.h>
+#include <sound/trident.h>
+
+/* page arguments of these two macros are Trident page (4096 bytes), not like
+ * aligned pages in others
+ */
+#define __set_tlb_bus(trident,page,ptr,addr) \
+	do { (trident)->tlb.entries[page] = cpu_to_le32((addr) & ~(SNDRV_TRIDENT_PAGE_SIZE-1)); \
+	     (trident)->tlb.shadow_entries[page] = (ptr); } while (0)
+#define __tlb_to_ptr(trident,page) \
+	(void*)((trident)->tlb.shadow_entries[page])
+#define __tlb_to_addr(trident,page) \
+	(dma_addr_t)le32_to_cpu((trident->tlb.entries[page]) & ~(SNDRV_TRIDENT_PAGE_SIZE - 1))
+
+#if PAGE_SIZE == 4096
+/* page size == SNDRV_TRIDENT_PAGE_SIZE */
+#define ALIGN_PAGE_SIZE		PAGE_SIZE	/* minimum page size for allocation */
+#define MAX_ALIGN_PAGES		SNDRV_TRIDENT_MAX_PAGES	/* maxmium aligned pages */
+/* fill TLB entrie(s) corresponding to page with ptr */
+#define set_tlb_bus(trident,page,ptr,addr) __set_tlb_bus(trident,page,ptr,addr)
+/* fill TLB entrie(s) corresponding to page with silence pointer */
+#define set_silent_tlb(trident,page)	__set_tlb_bus(trident, page, (unsigned long)trident->tlb.silent_page.area, trident->tlb.silent_page.addr)
+/* get aligned page from offset address */
+#define get_aligned_page(offset)	((offset) >> 12)
+/* get offset address from aligned page */
+#define aligned_page_offset(page)	((page) << 12)
+/* get buffer address from aligned page */
+#define page_to_ptr(trident,page)	__tlb_to_ptr(trident, page)
+/* get PCI physical address from aligned page */
+#define page_to_addr(trident,page)	__tlb_to_addr(trident, page)
+
+#elif PAGE_SIZE == 8192
+/* page size == SNDRV_TRIDENT_PAGE_SIZE x 2*/
+#define ALIGN_PAGE_SIZE		PAGE_SIZE
+#define MAX_ALIGN_PAGES		(SNDRV_TRIDENT_MAX_PAGES / 2)
+#define get_aligned_page(offset)	((offset) >> 13)
+#define aligned_page_offset(page)	((page) << 13)
+#define page_to_ptr(trident,page)	__tlb_to_ptr(trident, (page) << 1)
+#define page_to_addr(trident,page)	__tlb_to_addr(trident, (page) << 1)
+
+/* fill TLB entries -- we need to fill two entries */
+static inline void set_tlb_bus(trident_t *trident, int page, unsigned long ptr, dma_addr_t addr)
+{
+	page <<= 1;
+	__set_tlb_bus(trident, page, ptr, addr);
+	__set_tlb_bus(trident, page+1, ptr + SNDRV_TRIDENT_PAGE_SIZE, addr + SNDRV_TRIDENT_PAGE_SIZE);
+}
+static inline void set_silent_tlb(trident_t *trident, int page)
+{
+	page <<= 1;
+	__set_tlb_bus(trident, page, (unsigned long)trident->tlb.silent_page.area, trident->tlb.silent_page.addr);
+	__set_tlb_bus(trident, page+1, (unsigned long)trident->tlb.silent_page.area, trident->tlb.silent_page.addr);
+}
+
+#else
+/* arbitrary size */
+#define UNIT_PAGES		(PAGE_SIZE / SNDRV_TRIDENT_PAGE_SIZE)
+#define ALIGN_PAGE_SIZE		(SNDRV_TRIDENT_PAGE_SIZE * UNIT_PAGES)
+#define MAX_ALIGN_PAGES		(SNDRV_TRIDENT_MAX_PAGES / UNIT_PAGES)
+/* Note: if alignment doesn't match to the maximum size, the last few blocks
+ * become unusable.  To use such blocks, you'll need to check the validity
+ * of accessing page in set_tlb_bus and set_silent_tlb.  search_empty()
+ * should also check it, too.
+ */
+#define get_aligned_page(offset)	((offset) / ALIGN_PAGE_SIZE)
+#define aligned_page_offset(page)	((page) * ALIGN_PAGE_SIZE)
+#define page_to_ptr(trident,page)	__tlb_to_ptr(trident, (page) * UNIT_PAGES)
+#define page_to_addr(trident,page)	__tlb_to_addr(trident, (page) * UNIT_PAGES)
+
+/* fill TLB entries -- UNIT_PAGES entries must be filled */
+static inline void set_tlb_bus(trident_t *trident, int page, unsigned long ptr, dma_addr_t addr)
+{
+	int i;
+	page *= UNIT_PAGES;
+	for (i = 0; i < UNIT_PAGES; i++, page++) {
+		__set_tlb_bus(trident, page, ptr, addr);
+		ptr += SNDRV_TRIDENT_PAGE_SIZE;
+		addr += SNDRV_TRIDENT_PAGE_SIZE;
+	}
+}
+static inline void set_silent_tlb(trident_t *trident, int page)
+{
+	int i;
+	page *= UNIT_PAGES;
+	for (i = 0; i < UNIT_PAGES; i++, page++)
+		__set_tlb_bus(trident, page, (unsigned long)trident->tlb.silent_page.area, trident->tlb.silent_page.addr);
+}
+
+#endif /* PAGE_SIZE */
+
+/* calculate buffer pointer from offset address */
+inline static void *offset_ptr(trident_t *trident, int offset)
+{
+	char *ptr;
+	ptr = page_to_ptr(trident, get_aligned_page(offset));
+	ptr += offset % ALIGN_PAGE_SIZE;
+	return (void*)ptr;
+}
+
+/* first and last (aligned) pages of memory block */
+#define firstpg(blk)	(((snd_trident_memblk_arg_t*)snd_util_memblk_argptr(blk))->first_page)
+#define lastpg(blk)	(((snd_trident_memblk_arg_t*)snd_util_memblk_argptr(blk))->last_page)
+
+/*
+ * search empty pages which may contain given size
+ */
+static snd_util_memblk_t *
+search_empty(snd_util_memhdr_t *hdr, int size)
+{
+	snd_util_memblk_t *blk, *prev;
+	int page, psize;
+	struct list_head *p;
+
+	psize = get_aligned_page(size + ALIGN_PAGE_SIZE -1);
+	prev = NULL;
+	page = 0;
+	list_for_each(p, &hdr->block) {
+		blk = list_entry(p, snd_util_memblk_t, list);
+		if (page + psize <= firstpg(blk))
+			goto __found_pages;
+		page = lastpg(blk) + 1;
+	}
+	if (page + psize > MAX_ALIGN_PAGES)
+		return NULL;
+
+__found_pages:
+	/* create a new memory block */
+	blk = __snd_util_memblk_new(hdr, psize * ALIGN_PAGE_SIZE, p->prev);
+	if (blk == NULL)
+		return NULL;
+	blk->offset = aligned_page_offset(page); /* set aligned offset */
+	firstpg(blk) = page;
+	lastpg(blk) = page + psize - 1;
+	return blk;
+}
+
+
+/*
+ * check if the given pointer is valid for pages
+ */
+static int is_valid_page(unsigned long ptr)
+{
+	if (ptr & ~0x3fffffffUL) {
+		snd_printk("max memory size is 1GB!!\n");
+		return 0;
+	}
+	if (ptr & (SNDRV_TRIDENT_PAGE_SIZE-1)) {
+		snd_printk("page is not aligned\n");
+		return 0;
+	}
+	return 1;
+}
+
+/*
+ * page allocation for DMA (Scatter-Gather version)
+ */
+static snd_util_memblk_t *
+snd_trident_alloc_sg_pages(trident_t *trident, snd_pcm_substream_t *substream)
+{
+	snd_util_memhdr_t *hdr;
+	snd_util_memblk_t *blk;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	int idx, page;
+	struct snd_sg_buf *sgbuf = snd_pcm_substream_sgbuf(substream);
+
+	snd_assert(runtime->dma_bytes > 0 && runtime->dma_bytes <= SNDRV_TRIDENT_MAX_PAGES * SNDRV_TRIDENT_PAGE_SIZE, return NULL);
+	hdr = trident->tlb.memhdr;
+	snd_assert(hdr != NULL, return NULL);
+
+	
+
+	down(&hdr->block_mutex);
+	blk = search_empty(hdr, runtime->dma_bytes);
+	if (blk == NULL) {
+		up(&hdr->block_mutex);
+		return NULL;
+	}
+	if (lastpg(blk) - firstpg(blk) >= sgbuf->pages) {
+		snd_printk(KERN_ERR "page calculation doesn't match: allocated pages = %d, trident = %d/%d\n", sgbuf->pages, firstpg(blk), lastpg(blk));
+		__snd_util_mem_free(hdr, blk);
+		up(&hdr->block_mutex);
+		return NULL;
+	}
+			   
+	/* set TLB entries */
+	idx = 0;
+	for (page = firstpg(blk); page <= lastpg(blk); page++, idx++) {
+		dma_addr_t addr = sgbuf->table[idx].addr;
+		unsigned long ptr = (unsigned long)sgbuf->table[idx].buf;
+		if (! is_valid_page(addr)) {
+			__snd_util_mem_free(hdr, blk);
+			up(&hdr->block_mutex);
+			return NULL;
+		}
+		set_tlb_bus(trident, page, ptr, addr);
+	}
+	up(&hdr->block_mutex);
+	return blk;
+}
+
+/*
+ * page allocation for DMA (contiguous version)
+ */
+static snd_util_memblk_t *
+snd_trident_alloc_cont_pages(trident_t *trident, snd_pcm_substream_t *substream)
+{
+	snd_util_memhdr_t *hdr;
+	snd_util_memblk_t *blk;
+	int page;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	dma_addr_t addr;
+	unsigned long ptr;
+
+	snd_assert(runtime->dma_bytes> 0 && runtime->dma_bytes <= SNDRV_TRIDENT_MAX_PAGES * SNDRV_TRIDENT_PAGE_SIZE, return NULL);
+	hdr = trident->tlb.memhdr;
+	snd_assert(hdr != NULL, return NULL);
+
+	down(&hdr->block_mutex);
+	blk = search_empty(hdr, runtime->dma_bytes);
+	if (blk == NULL) {
+		up(&hdr->block_mutex);
+		return NULL;
+	}
+			   
+	/* set TLB entries */
+	addr = runtime->dma_addr;
+	ptr = (unsigned long)runtime->dma_area;
+	for (page = firstpg(blk); page <= lastpg(blk); page++,
+	     ptr += SNDRV_TRIDENT_PAGE_SIZE, addr += SNDRV_TRIDENT_PAGE_SIZE) {
+		if (! is_valid_page(addr)) {
+			__snd_util_mem_free(hdr, blk);
+			up(&hdr->block_mutex);
+			return NULL;
+		}
+		set_tlb_bus(trident, page, ptr, addr);
+	}
+	up(&hdr->block_mutex);
+	return blk;
+}
+
+/*
+ * page allocation for DMA
+ */
+snd_util_memblk_t *
+snd_trident_alloc_pages(trident_t *trident, snd_pcm_substream_t *substream)
+{
+	snd_assert(trident != NULL, return NULL);
+	snd_assert(substream != NULL, return NULL);
+	if (substream->dma_buffer.dev.type == SNDRV_DMA_TYPE_DEV_SG)
+		return snd_trident_alloc_sg_pages(trident, substream);
+	else
+		return snd_trident_alloc_cont_pages(trident, substream);
+}
+
+
+/*
+ * release DMA buffer from page table
+ */
+int snd_trident_free_pages(trident_t *trident, snd_util_memblk_t *blk)
+{
+	snd_util_memhdr_t *hdr;
+	int page;
+
+	snd_assert(trident != NULL, return -EINVAL);
+	snd_assert(blk != NULL, return -EINVAL);
+
+	hdr = trident->tlb.memhdr;
+	down(&hdr->block_mutex);
+	/* reset TLB entries */
+	for (page = firstpg(blk); page <= lastpg(blk); page++)
+		set_silent_tlb(trident, page);
+	/* free memory block */
+	__snd_util_mem_free(hdr, blk);
+	up(&hdr->block_mutex);
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+ * memory allocation using multiple pages (for synth)
+ *----------------------------------------------------------------
+ * Unlike the DMA allocation above, non-contiguous pages are
+ * assigned to TLB.
+ *----------------------------------------------------------------*/
+
+/*
+ */
+static int synth_alloc_pages(trident_t *hw, snd_util_memblk_t *blk);
+static int synth_free_pages(trident_t *hw, snd_util_memblk_t *blk);
+
+/*
+ * allocate a synth sample area
+ */
+snd_util_memblk_t *
+snd_trident_synth_alloc(trident_t *hw, unsigned int size)
+{
+	snd_util_memblk_t *blk;
+	snd_util_memhdr_t *hdr = hw->tlb.memhdr; 
+
+	down(&hdr->block_mutex);
+	blk = __snd_util_mem_alloc(hdr, size);
+	if (blk == NULL) {
+		up(&hdr->block_mutex);
+		return NULL;
+	}
+	if (synth_alloc_pages(hw, blk)) {
+		__snd_util_mem_free(hdr, blk);
+		up(&hdr->block_mutex);
+		return NULL;
+	}
+	up(&hdr->block_mutex);
+	return blk;
+}
+
+
+/*
+ * free a synth sample area
+ */
+int
+snd_trident_synth_free(trident_t *hw, snd_util_memblk_t *blk)
+{
+	snd_util_memhdr_t *hdr = hw->tlb.memhdr; 
+
+	down(&hdr->block_mutex);
+	synth_free_pages(hw, blk);
+	 __snd_util_mem_free(hdr, blk);
+	up(&hdr->block_mutex);
+	return 0;
+}
+
+
+/*
+ * reset TLB entry and free kernel page
+ */
+static void clear_tlb(trident_t *trident, int page)
+{
+	void *ptr = page_to_ptr(trident, page);
+	dma_addr_t addr = page_to_addr(trident, page);
+	set_silent_tlb(trident, page);
+	if (ptr) {
+		struct snd_dma_buffer dmab;
+		dmab.dev.type = SNDRV_DMA_TYPE_DEV;
+		dmab.dev.dev = snd_dma_pci_data(trident->pci);
+		dmab.area = ptr;
+		dmab.addr = addr;
+		dmab.bytes = ALIGN_PAGE_SIZE;
+		snd_dma_free_pages(&dmab);
+	}
+}
+
+/* check new allocation range */
+static void get_single_page_range(snd_util_memhdr_t *hdr, snd_util_memblk_t *blk, int *first_page_ret, int *last_page_ret)
+{
+	struct list_head *p;
+	snd_util_memblk_t *q;
+	int first_page, last_page;
+	first_page = firstpg(blk);
+	if ((p = blk->list.prev) != &hdr->block) {
+		q = list_entry(p, snd_util_memblk_t, list);
+		if (lastpg(q) == first_page)
+			first_page++;  /* first page was already allocated */
+	}
+	last_page = lastpg(blk);
+	if ((p = blk->list.next) != &hdr->block) {
+		q = list_entry(p, snd_util_memblk_t, list);
+		if (firstpg(q) == last_page)
+			last_page--; /* last page was already allocated */
+	}
+	*first_page_ret = first_page;
+	*last_page_ret = last_page;
+}
+
+/*
+ * allocate kernel pages and assign them to TLB
+ */
+static int synth_alloc_pages(trident_t *hw, snd_util_memblk_t *blk)
+{
+	int page, first_page, last_page;
+	struct snd_dma_buffer dmab;
+
+	firstpg(blk) = get_aligned_page(blk->offset);
+	lastpg(blk) = get_aligned_page(blk->offset + blk->size - 1);
+	get_single_page_range(hw->tlb.memhdr, blk, &first_page, &last_page);
+
+	/* allocate a kernel page for each Trident page -
+	 * fortunately Trident page size and kernel PAGE_SIZE is identical!
+	 */
+	for (page = first_page; page <= last_page; page++) {
+		if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(hw->pci),
+					ALIGN_PAGE_SIZE, &dmab) < 0)
+			goto __fail;
+		if (! is_valid_page(dmab.addr)) {
+			snd_dma_free_pages(&dmab);
+			goto __fail;
+		}
+		set_tlb_bus(hw, page, (unsigned long)dmab.area, dmab.addr);
+	}
+	return 0;
+
+__fail:
+	/* release allocated pages */
+	last_page = page - 1;
+	for (page = first_page; page <= last_page; page++)
+		clear_tlb(hw, page);
+
+	return -ENOMEM;
+}
+
+/*
+ * free pages
+ */
+static int synth_free_pages(trident_t *trident, snd_util_memblk_t *blk)
+{
+	int page, first_page, last_page;
+
+	get_single_page_range(trident->tlb.memhdr, blk, &first_page, &last_page);
+	for (page = first_page; page <= last_page; page++)
+		clear_tlb(trident, page);
+
+	return 0;
+}
+
+/*
+ * copy_from_user(blk + offset, data, size)
+ */
+int snd_trident_synth_copy_from_user(trident_t *trident, snd_util_memblk_t *blk, int offset, const char __user *data, int size)
+{
+	int page, nextofs, end_offset, temp, temp1;
+
+	offset += blk->offset;
+	end_offset = offset + size;
+	page = get_aligned_page(offset) + 1;
+	do {
+		nextofs = aligned_page_offset(page);
+		temp = nextofs - offset;
+		temp1 = end_offset - offset;
+		if (temp1 < temp)
+			temp = temp1;
+		if (copy_from_user(offset_ptr(trident, offset), data, temp))
+			return -EFAULT;
+		offset = nextofs;
+		data += temp;
+		page++;
+	} while (offset < end_offset);
+	return 0;
+}
+
