commit 51055da51d1e92bb089c9b9e0ecb1be69396f808
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:43 2020 +0100

    ALSA: pci: Constify snd_ac97_bus_ops definitions
    
    Now snd_ac97_bus() takes the const ops pointer, so we can define the
    snd_ac97_bus_ops locally as const as well for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-28-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index ba4a9fcd5eba..6e50376163a2 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -2912,7 +2912,7 @@ static int snd_trident_mixer(struct snd_trident *trident, int pcm_spdif_device)
 	struct snd_kcontrol *kctl;
 	struct snd_ctl_elem_value *uctl;
 	int idx, err, retries = 2;
-	static struct snd_ac97_bus_ops ops = {
+	static const struct snd_ac97_bus_ops ops = {
 		.write = snd_trident_codec_write,
 		.read = snd_trident_codec_read,
 	};

commit efb0ad25d370344e61bb4fca8c3b9c3c6047922e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:25 2020 +0100

    ALSA: pci: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 0d039eacbf0a..ba4a9fcd5eba 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3487,7 +3487,7 @@ int snd_trident_create(struct snd_card *card,
 	int i, err;
 	struct snd_trident_voice *voice;
 	struct snd_trident_pcm_mixer *tmix;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free =	snd_trident_dev_free,
 	};
 

commit 4a9ff148bd348f7489fcc9d1a1ef3723b6f329be
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:35 2019 +0100

    ALSA: trident: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-37-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 0e02578c2b3d..0d039eacbf0a 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3543,6 +3543,7 @@ int snd_trident_create(struct snd_card *card,
 		return -EBUSY;
 	}
 	trident->irq = pci->irq;
+	card->sync_irq = trident->irq;
 
 	/* allocate 16k-aligned TLB for NX cards */
 	trident->tlb.entries = NULL;

commit 6b07ea052a5a4c56225c65e5d2c07b1af20a09bb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:36 2019 +0100

    ALSA: trident: Drop superfluous ioctl PCM ops
    
    snd_trident_ioctl() does nothing but calling the default handler.
    Now PCM core accepts NULL as the default ioctl ops(*), so let's drop
    altogether.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-15-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 93789069e78f..0e02578c2b3d 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -767,29 +767,6 @@ static unsigned int snd_trident_control_mode(struct snd_pcm_substream *substream
  *  PCM part
  */
 
-/*---------------------------------------------------------------------------
-   snd_trident_ioctl
-  
-   Description: Device I/O control handler for playback/capture parameters.
-  
-   Parameters:   substream  - PCM substream class
-                cmd     - what ioctl message to process
-                arg     - additional message infoarg     
-  
-   Returns:     Error status
-  
-  ---------------------------------------------------------------------------*/
-
-static int snd_trident_ioctl(struct snd_pcm_substream *substream,
-			     unsigned int cmd,
-			     void *arg)
-{
-	/* FIXME: it seems that with small periods the behaviour of
-	          trident hardware is unpredictable and interrupt generator
-	          is broken */
-	return snd_pcm_lib_ioctl(substream, cmd, arg);
-}
-
 /*---------------------------------------------------------------------------
    snd_trident_allocate_pcm_mem
   
@@ -2049,7 +2026,6 @@ static int snd_trident_foldback_close(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_trident_playback_ops = {
 	.open =		snd_trident_playback_open,
 	.close =	snd_trident_playback_close,
-	.ioctl =	snd_trident_ioctl,
 	.hw_params =	snd_trident_hw_params,
 	.hw_free =	snd_trident_hw_free,
 	.prepare =	snd_trident_playback_prepare,
@@ -2060,7 +2036,6 @@ static const struct snd_pcm_ops snd_trident_playback_ops = {
 static const struct snd_pcm_ops snd_trident_nx_playback_ops = {
 	.open =		snd_trident_playback_open,
 	.close =	snd_trident_playback_close,
-	.ioctl =	snd_trident_ioctl,
 	.hw_params =	snd_trident_hw_params,
 	.hw_free =	snd_trident_hw_free,
 	.prepare =	snd_trident_playback_prepare,
@@ -2071,7 +2046,6 @@ static const struct snd_pcm_ops snd_trident_nx_playback_ops = {
 static const struct snd_pcm_ops snd_trident_capture_ops = {
 	.open =		snd_trident_capture_open,
 	.close =	snd_trident_capture_close,
-	.ioctl =	snd_trident_ioctl,
 	.hw_params =	snd_trident_capture_hw_params,
 	.hw_free =	snd_trident_hw_free,
 	.prepare =	snd_trident_capture_prepare,
@@ -2082,7 +2056,6 @@ static const struct snd_pcm_ops snd_trident_capture_ops = {
 static const struct snd_pcm_ops snd_trident_si7018_capture_ops = {
 	.open =		snd_trident_capture_open,
 	.close =	snd_trident_capture_close,
-	.ioctl =	snd_trident_ioctl,
 	.hw_params =	snd_trident_si7018_capture_hw_params,
 	.hw_free =	snd_trident_si7018_capture_hw_free,
 	.prepare =	snd_trident_si7018_capture_prepare,
@@ -2093,7 +2066,6 @@ static const struct snd_pcm_ops snd_trident_si7018_capture_ops = {
 static const struct snd_pcm_ops snd_trident_foldback_ops = {
 	.open =		snd_trident_foldback_open,
 	.close =	snd_trident_foldback_close,
-	.ioctl =	snd_trident_ioctl,
 	.hw_params =	snd_trident_hw_params,
 	.hw_free =	snd_trident_hw_free,
 	.prepare =	snd_trident_foldback_prepare,
@@ -2104,7 +2076,6 @@ static const struct snd_pcm_ops snd_trident_foldback_ops = {
 static const struct snd_pcm_ops snd_trident_nx_foldback_ops = {
 	.open =		snd_trident_foldback_open,
 	.close =	snd_trident_foldback_close,
-	.ioctl =	snd_trident_ioctl,
 	.hw_params =	snd_trident_hw_params,
 	.hw_free =	snd_trident_hw_free,
 	.prepare =	snd_trident_foldback_prepare,
@@ -2115,7 +2086,6 @@ static const struct snd_pcm_ops snd_trident_nx_foldback_ops = {
 static const struct snd_pcm_ops snd_trident_spdif_ops = {
 	.open =		snd_trident_spdif_open,
 	.close =	snd_trident_spdif_close,
-	.ioctl =	snd_trident_ioctl,
 	.hw_params =	snd_trident_spdif_hw_params,
 	.hw_free =	snd_trident_hw_free,
 	.prepare =	snd_trident_spdif_prepare,
@@ -2126,7 +2096,6 @@ static const struct snd_pcm_ops snd_trident_spdif_ops = {
 static const struct snd_pcm_ops snd_trident_spdif_7018_ops = {
 	.open =		snd_trident_spdif_open,
 	.close =	snd_trident_spdif_close,
-	.ioctl =	snd_trident_ioctl,
 	.hw_params =	snd_trident_spdif_hw_params,
 	.hw_free =	snd_trident_hw_free,
 	.prepare =	snd_trident_spdif_prepare,

commit c79eafa095b192e251ece9e8016c8012e47fe303
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:26 2019 +0100

    ALSA: trident: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The superfluous snd_pcm_lib_malloc_pages() and
    snd_pcm_lib_free_pages() calls are dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-55-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 07022c0dad40..93789069e78f 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -808,12 +808,9 @@ static int snd_trident_allocate_pcm_mem(struct snd_pcm_substream *substream,
 	struct snd_trident *trident = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_trident_voice *voice = runtime->private_data;
-	int err;
 
-	if ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)
-		return err;
 	if (trident->tlb.entries) {
-		if (err > 0) { /* change */
+		if (runtime->buffer_changed) {
 			if (voice->memblk)
 				snd_trident_free_pages(trident, voice->memblk);
 			voice->memblk = snd_trident_alloc_pages(trident, substream);
@@ -911,7 +908,6 @@ static int snd_trident_hw_free(struct snd_pcm_substream *substream)
 			voice->memblk = NULL;
 		}
 	}
-	snd_pcm_lib_free_pages(substream);
 	if (evoice != NULL) {
 		snd_trident_free_voice(trident, evoice);
 		voice->extra = NULL;
@@ -1128,11 +1124,6 @@ static int snd_trident_capture_prepare(struct snd_pcm_substream *substream)
 static int snd_trident_si7018_capture_hw_params(struct snd_pcm_substream *substream,
 						struct snd_pcm_hw_params *hw_params)
 {
-	int err;
-
-	if ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)
-		return err;
-
 	return snd_trident_allocate_evoice(substream, hw_params);
 }
 
@@ -1154,7 +1145,6 @@ static int snd_trident_si7018_capture_hw_free(struct snd_pcm_substream *substrea
 	struct snd_trident_voice *voice = runtime->private_data;
 	struct snd_trident_voice *evoice = voice ? voice->extra : NULL;
 
-	snd_pcm_lib_free_pages(substream);
 	if (evoice != NULL) {
 		snd_trident_free_voice(trident, evoice);
 		voice->extra = NULL;
@@ -2183,17 +2173,17 @@ int snd_trident_pcm(struct snd_trident *trident, int device)
 	if (trident->tlb.entries) {
 		struct snd_pcm_substream *substream;
 		for (substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; substream; substream = substream->next)
-			snd_pcm_lib_preallocate_pages(substream, SNDRV_DMA_TYPE_DEV_SG,
-						      &trident->pci->dev,
-						      64*1024, 128*1024);
-		snd_pcm_lib_preallocate_pages(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,
-					      SNDRV_DMA_TYPE_DEV,
-					      &trident->pci->dev,
-					      64*1024, 128*1024);
+			snd_pcm_set_managed_buffer(substream, SNDRV_DMA_TYPE_DEV_SG,
+						   &trident->pci->dev,
+						   64*1024, 128*1024);
+		snd_pcm_set_managed_buffer(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,
+					   SNDRV_DMA_TYPE_DEV,
+					   &trident->pci->dev,
+					   64*1024, 128*1024);
 	} else {
-		snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-						      &trident->pci->dev,
-						      64*1024, 128*1024);
+		snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
+					       &trident->pci->dev,
+					       64*1024, 128*1024);
 	}
 
 	return 0;
@@ -2242,13 +2232,13 @@ int snd_trident_foldback_pcm(struct snd_trident *trident, int device)
 	trident->foldback = foldback;
 
 	if (trident->tlb.entries)
-		snd_pcm_lib_preallocate_pages_for_all(foldback, SNDRV_DMA_TYPE_DEV_SG,
-						      &trident->pci->dev,
-						      0, 128*1024);
+		snd_pcm_set_managed_buffer_all(foldback, SNDRV_DMA_TYPE_DEV_SG,
+					       &trident->pci->dev,
+					       0, 128*1024);
 	else
-		snd_pcm_lib_preallocate_pages_for_all(foldback, SNDRV_DMA_TYPE_DEV,
-						      &trident->pci->dev,
-						      64*1024, 128*1024);
+		snd_pcm_set_managed_buffer_all(foldback, SNDRV_DMA_TYPE_DEV,
+					       &trident->pci->dev,
+					       64*1024, 128*1024);
 
 	return 0;
 }
@@ -2282,9 +2272,8 @@ int snd_trident_spdif_pcm(struct snd_trident *trident, int device)
 	strcpy(spdif->name, "Trident 4DWave IEC958");
 	trident->spdif = spdif;
 
-	snd_pcm_lib_preallocate_pages_for_all(spdif, SNDRV_DMA_TYPE_DEV,
-					      &trident->pci->dev,
-					      64*1024, 128*1024);
+	snd_pcm_set_managed_buffer_all(spdif, SNDRV_DMA_TYPE_DEV,
+				       &trident->pci->dev, 64*1024, 128*1024);
 
 	return 0;
 }

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 8ac6f541b008..07022c0dad40 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -2184,14 +2184,16 @@ int snd_trident_pcm(struct snd_trident *trident, int device)
 		struct snd_pcm_substream *substream;
 		for (substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; substream; substream = substream->next)
 			snd_pcm_lib_preallocate_pages(substream, SNDRV_DMA_TYPE_DEV_SG,
-						      snd_dma_pci_data(trident->pci),
+						      &trident->pci->dev,
 						      64*1024, 128*1024);
 		snd_pcm_lib_preallocate_pages(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,
-					      SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci),
+					      SNDRV_DMA_TYPE_DEV,
+					      &trident->pci->dev,
 					      64*1024, 128*1024);
 	} else {
 		snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-						      snd_dma_pci_data(trident->pci), 64*1024, 128*1024);
+						      &trident->pci->dev,
+						      64*1024, 128*1024);
 	}
 
 	return 0;
@@ -2241,10 +2243,12 @@ int snd_trident_foldback_pcm(struct snd_trident *trident, int device)
 
 	if (trident->tlb.entries)
 		snd_pcm_lib_preallocate_pages_for_all(foldback, SNDRV_DMA_TYPE_DEV_SG,
-						      snd_dma_pci_data(trident->pci), 0, 128*1024);
+						      &trident->pci->dev,
+						      0, 128*1024);
 	else
 		snd_pcm_lib_preallocate_pages_for_all(foldback, SNDRV_DMA_TYPE_DEV,
-						      snd_dma_pci_data(trident->pci), 64*1024, 128*1024);
+						      &trident->pci->dev,
+						      64*1024, 128*1024);
 
 	return 0;
 }
@@ -2278,7 +2282,9 @@ int snd_trident_spdif_pcm(struct snd_trident *trident, int device)
 	strcpy(spdif->name, "Trident 4DWave IEC958");
 	trident->spdif = spdif;
 
-	snd_pcm_lib_preallocate_pages_for_all(spdif, SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci), 64*1024, 128*1024);
+	snd_pcm_lib_preallocate_pages_for_all(spdif, SNDRV_DMA_TYPE_DEV,
+					      &trident->pci->dev,
+					      64*1024, 128*1024);
 
 	return 0;
 }
@@ -3336,7 +3342,7 @@ static int snd_trident_tlb_alloc(struct snd_trident *trident)
 	/* TLB array must be aligned to 16kB !!! so we allocate
 	   32kB region and correct offset when necessary */
 
-	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci),
+	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &trident->pci->dev,
 				2 * SNDRV_TRIDENT_MAX_PAGES * 4, &trident->tlb.buffer) < 0) {
 		dev_err(trident->card->dev, "unable to allocate TLB buffer\n");
 		return -ENOMEM;
@@ -3351,7 +3357,7 @@ static int snd_trident_tlb_alloc(struct snd_trident *trident)
 		return -ENOMEM;
 
 	/* allocate and setup silent page and initialise TLB entries */
-	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci),
+	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &trident->pci->dev,
 				SNDRV_TRIDENT_PAGE_SIZE, &trident->tlb.silent_page) < 0) {
 		dev_err(trident->card->dev, "unable to allocate silent page\n");
 		return -ENOMEM;

commit 16ccca11088c1bdd9311a2c630b453541305c48a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:50 2019 +0100

    ALSA: pci: Drop superfluous snd_pcm_sgbuf_ops_page
    
    snd_pcm_sgbuf_ops_page is no longer needed to be set explicitly to PCM
    page ops since the recent change in the PCM core (*).  Leaving it NULL
    should work as long as the preallocation has been done properly.
    
    This patch drops the redundant lines.
    
    (*) 7e8edae39fd1: ALSA: pcm: Handle special page mapping in the
                      default mmap handler
    
    Link: https://lore.kernel.org/r/20191105151856.10785-19-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 1a6f6202fd16..8ac6f541b008 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -2076,7 +2076,6 @@ static const struct snd_pcm_ops snd_trident_nx_playback_ops = {
 	.prepare =	snd_trident_playback_prepare,
 	.trigger =	snd_trident_trigger,
 	.pointer =	snd_trident_playback_pointer,
-	.page =		snd_pcm_sgbuf_ops_page,
 };
 
 static const struct snd_pcm_ops snd_trident_capture_ops = {
@@ -2121,7 +2120,6 @@ static const struct snd_pcm_ops snd_trident_nx_foldback_ops = {
 	.prepare =	snd_trident_foldback_prepare,
 	.trigger =	snd_trident_trigger,
 	.pointer =	snd_trident_playback_pointer,
-	.page =		snd_pcm_sgbuf_ops_page,
 };
 
 static const struct snd_pcm_ops snd_trident_spdif_ops = {

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 0ff32d3f5d3b..1a6f6202fd16 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Maintained by Jaroslav Kysela <perex@perex.cz>
  *  Originated by audio@tridentmicro.com
@@ -9,21 +10,6 @@
  *  TODO:
  *    ---
  *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- *
  *  SiS7018 S/PDIF support by Thomas Winischhofer <thomas@winischhofer.net>
  */
 

commit 47f2769b4b2e267cba135fc19c89c32d202b1415
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:01:39 2019 +0100

    ALSA: pci: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index f271ea436cff..0ff32d3f5d3b 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3320,13 +3320,11 @@ static void snd_trident_proc_read(struct snd_info_entry *entry,
 
 static void snd_trident_proc_init(struct snd_trident *trident)
 {
-	struct snd_info_entry *entry;
 	const char *s = "trident";
 	
 	if (trident->device == TRIDENT_DEVICE_ID_SI7018)
 		s = "sis7018";
-	if (! snd_card_proc_new(trident->card, s, &entry))
-		snd_info_set_text_ops(entry, trident, snd_trident_proc_read);
+	snd_card_ro_proc_new(trident->card, s, trident, snd_trident_proc_read);
 }
 
 static int snd_trident_dev_free(struct snd_device *device)

commit 17bc4815de586d001c82d0ddf75247283c3f002a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:02:51 2019 +0100

    ALSA: pci: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 5523e193d556..f271ea436cff 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3915,10 +3915,6 @@ static int snd_trident_suspend(struct device *dev)
 
 	trident->in_suspend = 1;
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
-	snd_pcm_suspend_all(trident->pcm);
-	snd_pcm_suspend_all(trident->foldback);
-	snd_pcm_suspend_all(trident->spdif);
-
 	snd_ac97_suspend(trident->ac97);
 	snd_ac97_suspend(trident->ac97_sec);
 	return 0;

commit 752089fea357b36ba9dd477db594bdc677110579
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 25 23:24:02 2018 +0200

    ALSA: trident: Proper endian notations
    
    The TLB entries in Trident driver are represented in little-endian,
    hence they should be declared as __le32.
    
    This patch fixes the sparse warnings like:
      sound/pci/trident/trident_memory.c:226:17: warning: incorrect type in assignment (different base types)
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 49c64fae3466..5523e193d556 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3359,7 +3359,7 @@ static int snd_trident_tlb_alloc(struct snd_trident *trident)
 		dev_err(trident->card->dev, "unable to allocate TLB buffer\n");
 		return -ENOMEM;
 	}
-	trident->tlb.entries = (unsigned int*)ALIGN((unsigned long)trident->tlb.buffer.area, SNDRV_TRIDENT_MAX_PAGES * 4);
+	trident->tlb.entries = (__le32 *)ALIGN((unsigned long)trident->tlb.buffer.area, SNDRV_TRIDENT_MAX_PAGES * 4);
 	trident->tlb.entries_dmaaddr = ALIGN(trident->tlb.buffer.addr, SNDRV_TRIDENT_MAX_PAGES * 4);
 	/* allocate shadow TLB page table (virtual addresses) */
 	trident->tlb.shadow_entries =

commit 42bc47b35320e0e587a88e437e18f80f9c5bcbb2
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:27:11 2018 -0700

    treewide: Use array_size() in vmalloc()
    
    The vmalloc() function has no 2-factor argument form, so multiplication
    factors need to be wrapped in array_size(). This patch replaces cases of:
    
            vmalloc(a * b)
    
    with:
            vmalloc(array_size(a, b))
    
    as well as handling cases of:
    
            vmalloc(a * b * c)
    
    with:
    
            vmalloc(array3_size(a, b, c))
    
    This does, however, attempt to ignore constant size factors like:
    
            vmalloc(4 * 1024)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      vmalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      vmalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      vmalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
      vmalloc(
    -       sizeof(TYPE) * (COUNT_ID)
    +       array_size(COUNT_ID, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT_ID
    +       array_size(COUNT_ID, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * (COUNT_CONST)
    +       array_size(COUNT_CONST, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT_CONST
    +       array_size(COUNT_CONST, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT_ID)
    +       array_size(COUNT_ID, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT_ID
    +       array_size(COUNT_ID, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT_CONST)
    +       array_size(COUNT_CONST, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT_CONST
    +       array_size(COUNT_CONST, sizeof(THING))
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
      vmalloc(
    -       SIZE * COUNT
    +       array_size(COUNT, SIZE)
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      vmalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      vmalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      vmalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      vmalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      vmalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      vmalloc(C1 * C2 * C3, ...)
    |
      vmalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants.
    @@
    expression E1, E2;
    constant C1, C2;
    @@
    
    (
      vmalloc(C1 * C2, ...)
    |
      vmalloc(
    -       E1 * E2
    +       array_size(E1, E2)
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index eabd84d9ffee..49c64fae3466 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3362,7 +3362,9 @@ static int snd_trident_tlb_alloc(struct snd_trident *trident)
 	trident->tlb.entries = (unsigned int*)ALIGN((unsigned long)trident->tlb.buffer.area, SNDRV_TRIDENT_MAX_PAGES * 4);
 	trident->tlb.entries_dmaaddr = ALIGN(trident->tlb.buffer.addr, SNDRV_TRIDENT_MAX_PAGES * 4);
 	/* allocate shadow TLB page table (virtual addresses) */
-	trident->tlb.shadow_entries = vmalloc(SNDRV_TRIDENT_MAX_PAGES*sizeof(unsigned long));
+	trident->tlb.shadow_entries =
+		vmalloc(array_size(SNDRV_TRIDENT_MAX_PAGES,
+				   sizeof(unsigned long)));
 	if (!trident->tlb.shadow_entries)
 		return -ENOMEM;
 

commit b57cac281589654cef6120f694cb09c267e85d24
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:26 2017 +0530

    ALSA: trident: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index d9bb6dd9f227..eabd84d9ffee 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -1727,7 +1727,7 @@ static snd_pcm_uframes_t snd_trident_spdif_pointer(struct snd_pcm_substream *sub
  *  Playback support device description
  */
 
-static struct snd_pcm_hardware snd_trident_playback =
+static const struct snd_pcm_hardware snd_trident_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1752,7 +1752,7 @@ static struct snd_pcm_hardware snd_trident_playback =
  *  Capture support device description
  */
 
-static struct snd_pcm_hardware snd_trident_capture =
+static const struct snd_pcm_hardware snd_trident_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1777,7 +1777,7 @@ static struct snd_pcm_hardware snd_trident_capture =
  *  Foldback capture support device description
  */
 
-static struct snd_pcm_hardware snd_trident_foldback =
+static const struct snd_pcm_hardware snd_trident_foldback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1801,7 +1801,7 @@ static struct snd_pcm_hardware snd_trident_foldback =
  *  SPDIF playback support device description
  */
 
-static struct snd_pcm_hardware snd_trident_spdif =
+static const struct snd_pcm_hardware snd_trident_spdif =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1822,7 +1822,7 @@ static struct snd_pcm_hardware snd_trident_spdif =
 	.fifo_size =		0,
 };
 
-static struct snd_pcm_hardware snd_trident_spdif_7018 =
+static const struct snd_pcm_hardware snd_trident_spdif_7018 =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |

commit aef7758ff4ffcf9d7a03779f877228871efae4c0
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Aug 12 13:20:16 2017 +0200

    ALSA: trident: Delete an error message for a failed memory allocation in snd_trident_tlb_alloc()
    
    Omit an extra message for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 4561040520c2..d9bb6dd9f227 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3363,11 +3363,9 @@ static int snd_trident_tlb_alloc(struct snd_trident *trident)
 	trident->tlb.entries_dmaaddr = ALIGN(trident->tlb.buffer.addr, SNDRV_TRIDENT_MAX_PAGES * 4);
 	/* allocate shadow TLB page table (virtual addresses) */
 	trident->tlb.shadow_entries = vmalloc(SNDRV_TRIDENT_MAX_PAGES*sizeof(unsigned long));
-	if (trident->tlb.shadow_entries == NULL) {
-		dev_err(trident->card->dev,
-			"unable to allocate shadow TLB entries\n");
+	if (!trident->tlb.shadow_entries)
 		return -ENOMEM;
-	}
+
 	/* allocate and setup silent page and initialise TLB entries */
 	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci),
 				SNDRV_TRIDENT_PAGE_SIZE, &trident->tlb.silent_page) < 0) {

commit 841c1ea0d8f813029c821044d3e899d5eb93400a
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Thu Aug 10 17:17:38 2017 +0530

    ALSA: trident: constify snd_pcm_ops structures
    
    snd_pcm_ops are not supposed to change at runtime. All functions
    working with snd_pcm_ops provided by <sound/pcm.h> work with
    const snd_pcm_ops. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 64d3b8eba4bb..4561040520c2 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -2093,7 +2093,7 @@ static const struct snd_pcm_ops snd_trident_nx_playback_ops = {
 	.page =		snd_pcm_sgbuf_ops_page,
 };
 
-static struct snd_pcm_ops snd_trident_capture_ops = {
+static const struct snd_pcm_ops snd_trident_capture_ops = {
 	.open =		snd_trident_capture_open,
 	.close =	snd_trident_capture_close,
 	.ioctl =	snd_trident_ioctl,
@@ -2104,7 +2104,7 @@ static struct snd_pcm_ops snd_trident_capture_ops = {
 	.pointer =	snd_trident_capture_pointer,
 };
 
-static struct snd_pcm_ops snd_trident_si7018_capture_ops = {
+static const struct snd_pcm_ops snd_trident_si7018_capture_ops = {
 	.open =		snd_trident_capture_open,
 	.close =	snd_trident_capture_close,
 	.ioctl =	snd_trident_ioctl,

commit f3b827e0b1841f4cfc18436e09f4f269f3be908e
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Mon Feb 20 00:18:09 2017 +0530

    ALSA: pci: constify snd_kcontrol_new structures
    
    Declare snd_kcontrol_new structures as const as they are only passed as
    an argument to the function snd_ctl_new1. This argument is of type
    const, so snd_kcontrol_new structures having the same property can be
    made const too.
    Done using Coccinelle:
    
    @r1 disable optional_qualifier @
    identifier i;
    position p;
    @@
    static struct snd_kcontrol_new i@p = {...};
    
    @ok1@
    identifier r1.i;
    position p;
    expression e1;
    @@
    snd_ctl_new1(&i@p,e1)
    
    @bad@
    position p!={r1.p,ok1.p};
    identifier r1.i;
    @@
    i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r1.i;
    @@
    +const
    struct snd_kcontrol_new i;
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 92ad2d7a6bf8..64d3b8eba4bb 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -2356,7 +2356,7 @@ static int snd_trident_spdif_control_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_spdif_control =
+static const struct snd_kcontrol_new snd_trident_spdif_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,SWITCH),
@@ -2419,7 +2419,7 @@ static int snd_trident_spdif_default_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_spdif_default =
+static const struct snd_kcontrol_new snd_trident_spdif_default =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
@@ -2452,7 +2452,7 @@ static int snd_trident_spdif_mask_get(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_trident_spdif_mask =
+static const struct snd_kcontrol_new snd_trident_spdif_mask =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -2514,7 +2514,7 @@ static int snd_trident_spdif_stream_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_spdif_stream =
+static const struct snd_kcontrol_new snd_trident_spdif_stream =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -2564,7 +2564,7 @@ static int snd_trident_ac97_control_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_ac97_rear_control =
+static const struct snd_kcontrol_new snd_trident_ac97_rear_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Rear Path",
@@ -2622,7 +2622,7 @@ static int snd_trident_vol_control_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_vol_music_control =
+static const struct snd_kcontrol_new snd_trident_vol_music_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Music Playback Volume",
@@ -2633,7 +2633,7 @@ static struct snd_kcontrol_new snd_trident_vol_music_control =
 	.tlv = { .p = db_scale_gvol },
 };
 
-static struct snd_kcontrol_new snd_trident_vol_wave_control =
+static const struct snd_kcontrol_new snd_trident_vol_wave_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Wave Playback Volume",
@@ -2700,7 +2700,7 @@ static int snd_trident_pcm_vol_control_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_pcm_vol_control =
+static const struct snd_kcontrol_new snd_trident_pcm_vol_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "PCM Front Playback Volume",
@@ -2764,7 +2764,7 @@ static int snd_trident_pcm_pan_control_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_pcm_pan_control =
+static const struct snd_kcontrol_new snd_trident_pcm_pan_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "PCM Pan Playback Control",
@@ -2821,7 +2821,7 @@ static int snd_trident_pcm_rvol_control_put(struct snd_kcontrol *kcontrol,
 
 static const DECLARE_TLV_DB_SCALE(db_scale_crvol, -3175, 25, 1);
 
-static struct snd_kcontrol_new snd_trident_pcm_rvol_control =
+static const struct snd_kcontrol_new snd_trident_pcm_rvol_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "PCM Reverb Playback Volume",
@@ -2877,7 +2877,7 @@ static int snd_trident_pcm_cvol_control_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_pcm_cvol_control =
+static const struct snd_kcontrol_new snd_trident_pcm_cvol_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "PCM Chorus Playback Volume",

commit b2fac0730347d591b528d8f0e4a9438c1bb6f558
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sat Nov 12 23:26:41 2016 +0100

    ALSA: pci: don't opencode IS_REACHABLE()
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 27f0ed840979..92ad2d7a6bf8 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3120,7 +3120,7 @@ static int snd_trident_mixer(struct snd_trident *trident, int pcm_spdif_device)
  * gameport interface
  */
 
-#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+#if IS_REACHABLE(CONFIG_GAMEPORT)
 
 static unsigned char snd_trident_gameport_read(struct gameport *gameport)
 {

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 599d2b7eb5b8..27f0ed840979 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -2070,7 +2070,7 @@ static int snd_trident_foldback_close(struct snd_pcm_substream *substream)
    PCM operations
   ---------------------------------------------------------------------------*/
 
-static struct snd_pcm_ops snd_trident_playback_ops = {
+static const struct snd_pcm_ops snd_trident_playback_ops = {
 	.open =		snd_trident_playback_open,
 	.close =	snd_trident_playback_close,
 	.ioctl =	snd_trident_ioctl,
@@ -2081,7 +2081,7 @@ static struct snd_pcm_ops snd_trident_playback_ops = {
 	.pointer =	snd_trident_playback_pointer,
 };
 
-static struct snd_pcm_ops snd_trident_nx_playback_ops = {
+static const struct snd_pcm_ops snd_trident_nx_playback_ops = {
 	.open =		snd_trident_playback_open,
 	.close =	snd_trident_playback_close,
 	.ioctl =	snd_trident_ioctl,
@@ -2115,7 +2115,7 @@ static struct snd_pcm_ops snd_trident_si7018_capture_ops = {
 	.pointer =	snd_trident_playback_pointer,
 };
 
-static struct snd_pcm_ops snd_trident_foldback_ops = {
+static const struct snd_pcm_ops snd_trident_foldback_ops = {
 	.open =		snd_trident_foldback_open,
 	.close =	snd_trident_foldback_close,
 	.ioctl =	snd_trident_ioctl,
@@ -2126,7 +2126,7 @@ static struct snd_pcm_ops snd_trident_foldback_ops = {
 	.pointer =	snd_trident_playback_pointer,
 };
 
-static struct snd_pcm_ops snd_trident_nx_foldback_ops = {
+static const struct snd_pcm_ops snd_trident_nx_foldback_ops = {
 	.open =		snd_trident_foldback_open,
 	.close =	snd_trident_foldback_close,
 	.ioctl =	snd_trident_ioctl,
@@ -2138,7 +2138,7 @@ static struct snd_pcm_ops snd_trident_nx_foldback_ops = {
 	.page =		snd_pcm_sgbuf_ops_page,
 };
 
-static struct snd_pcm_ops snd_trident_spdif_ops = {
+static const struct snd_pcm_ops snd_trident_spdif_ops = {
 	.open =		snd_trident_spdif_open,
 	.close =	snd_trident_spdif_close,
 	.ioctl =	snd_trident_ioctl,
@@ -2149,7 +2149,7 @@ static struct snd_pcm_ops snd_trident_spdif_ops = {
 	.pointer =	snd_trident_spdif_pointer,
 };
 
-static struct snd_pcm_ops snd_trident_spdif_7018_ops = {
+static const struct snd_pcm_ops snd_trident_spdif_7018_ops = {
 	.open =		snd_trident_spdif_open,
 	.close =	snd_trident_spdif_close,
 	.ioctl =	snd_trident_ioctl,

commit 412b979ccceff448dccea54bdb616c85781bc0ba
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Wed Apr 15 16:10:17 2015 +0200

    ALSA: remove deprecated use of pci api
    
    Replace occurences of the pci api by appropriate call to the dma api.
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr)
    
    @deprecated@
    idexpression id;
    position p;
    @@
    
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @bad1@
    idexpression id;
    position deprecated.p;
    @@
    ...when != &id->dev
       when != pci_get_drvdata ( id )
       when != pci_enable_device ( id )
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @depends on !bad1@
    idexpression id;
    expression direction;
    position deprecated.p;
    @@
    
    (
    - pci_dma_supported@p ( id,
    + dma_supported ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    |
    - pci_alloc_consistent@p ( id,
    + dma_alloc_coherent ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    )
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index b72be035f785..599d2b7eb5b8 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3551,8 +3551,8 @@ int snd_trident_create(struct snd_card *card,
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 	/* check, if we can restrict PCI DMA transfers to 30 bits */
-	if (pci_set_dma_mask(pci, DMA_BIT_MASK(30)) < 0 ||
-	    pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(30)) < 0) {
+	if (dma_set_mask(&pci->dev, DMA_BIT_MASK(30)) < 0 ||
+	    dma_set_coherent_mask(&pci->dev, DMA_BIT_MASK(30)) < 0) {
 		dev_err(card->dev,
 			"architecture does not support 30bit PCI busmaster DMA\n");
 		pci_disable_device(pci);

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 2870cbf8cee0..b72be035f785 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -36,6 +36,7 @@
 #include <linux/gameport.h>
 #include <linux/dma-mapping.h>
 #include <linux/export.h>
+#include <linux/io.h>
 
 #include <sound/core.h>
 #include <sound/info.h>
@@ -44,8 +45,6 @@
 #include "trident.h"
 #include <sound/asoundef.h>
 
-#include <asm/io.h>
-
 static int snd_trident_pcm_mixer_build(struct snd_trident *trident,
 				       struct snd_trident_voice * voice,
 				       struct snd_pcm_substream *substream);

commit 9e5947465d72ef1b3a88104474ab2adf78837220
Merge: 624afe4dc9a0 3e41c9b5a1ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 11 11:26:48 2015 +0100

    Merge branch 'topic/pci-cleanup' into for-next

commit 6f9eb021f776e7765a054090932cc9834d99c242
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 8 12:50:18 2015 +0100

    ALSA: trident: Simplify PM callbacks
    
    This is a similar cleanup like the commit [3db084fd0af5: ALSA: fm801:
    PCI core handles power state for us].
    
    Since pci_set_power_state(), pci_save_state() and pci_restore_state()
    are already done in the PCI core side, so we don't need to it doubly.
    
    Also, pci_enable_device(), pci_disable_device() and pci_set_master()
    calls in PM callbacks are superfluous nowadays, too, so get rid of
    them as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 57cd757acfe7..072824982ff8 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3926,7 +3926,6 @@ static void snd_trident_clear_voices(struct snd_trident * trident, unsigned shor
 #ifdef CONFIG_PM_SLEEP
 static int snd_trident_suspend(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_trident *trident = card->private_data;
 
@@ -3938,28 +3937,14 @@ static int snd_trident_suspend(struct device *dev)
 
 	snd_ac97_suspend(trident->ac97);
 	snd_ac97_suspend(trident->ac97_sec);
-
-	pci_disable_device(pci);
-	pci_save_state(pci);
-	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
 static int snd_trident_resume(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_trident *trident = card->private_data;
 
-	pci_set_power_state(pci, PCI_D0);
-	pci_restore_state(pci);
-	if (pci_enable_device(pci) < 0) {
-		dev_err(dev, "pci_enable_device failed, disabling device\n");
-		snd_card_disconnect(card);
-		return -EIO;
-	}
-	pci_set_master(pci);
-
 	switch (trident->device) {
 	case TRIDENT_DEVICE_ID_DX:
 		snd_trident_4d_dx_init(trident);

commit 1b16416fda21a8c5704bce809e0d7387bbfb097d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Jan 2 12:24:54 2015 +0100

    ALSA: trident: Remove always NULL parameters
    
    The various PCM allocation functions in this driver take a pointer to a
    pointer of a PCM where if this parameter is provided the newly allocated PCM
    is stored. All callers pass NULL though, so remove the parameter.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 57cd757acfe7..c380c99407c0 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -2172,14 +2172,11 @@ static struct snd_pcm_ops snd_trident_spdif_7018_ops = {
   
   ---------------------------------------------------------------------------*/
 
-int snd_trident_pcm(struct snd_trident *trident,
-		    int device, struct snd_pcm **rpcm)
+int snd_trident_pcm(struct snd_trident *trident, int device)
 {
 	struct snd_pcm *pcm;
 	int err;
 
-	if (rpcm)
-		*rpcm = NULL;
 	if ((err = snd_pcm_new(trident->card, "trident_dx_nx", device, trident->ChanPCM, 1, &pcm)) < 0)
 		return err;
 
@@ -2214,8 +2211,6 @@ int snd_trident_pcm(struct snd_trident *trident,
 						      snd_dma_pci_data(trident->pci), 64*1024, 128*1024);
 	}
 
-	if (rpcm)
-		*rpcm = pcm;
 	return 0;
 }
 
@@ -2230,16 +2225,13 @@ int snd_trident_pcm(struct snd_trident *trident,
   
   ---------------------------------------------------------------------------*/
 
-int snd_trident_foldback_pcm(struct snd_trident *trident,
-			     int device, struct snd_pcm **rpcm)
+int snd_trident_foldback_pcm(struct snd_trident *trident, int device)
 {
 	struct snd_pcm *foldback;
 	int err;
 	int num_chan = 3;
 	struct snd_pcm_substream *substream;
 
-	if (rpcm)
-		*rpcm = NULL;
 	if (trident->device == TRIDENT_DEVICE_ID_NX)
 		num_chan = 4;
 	if ((err = snd_pcm_new(trident->card, "trident_dx_nx", device, 0, num_chan, &foldback)) < 0)
@@ -2271,8 +2263,6 @@ int snd_trident_foldback_pcm(struct snd_trident *trident,
 		snd_pcm_lib_preallocate_pages_for_all(foldback, SNDRV_DMA_TYPE_DEV,
 						      snd_dma_pci_data(trident->pci), 64*1024, 128*1024);
 
-	if (rpcm)
-		*rpcm = foldback;
 	return 0;
 }
 
@@ -2287,14 +2277,11 @@ int snd_trident_foldback_pcm(struct snd_trident *trident,
   
   ---------------------------------------------------------------------------*/
 
-int snd_trident_spdif_pcm(struct snd_trident *trident,
-			  int device, struct snd_pcm **rpcm)
+int snd_trident_spdif_pcm(struct snd_trident *trident, int device)
 {
 	struct snd_pcm *spdif;
 	int err;
 
-	if (rpcm)
-		*rpcm = NULL;
 	if ((err = snd_pcm_new(trident->card, "trident_dx_nx IEC958", device, 1, 0, &spdif)) < 0)
 		return err;
 
@@ -2310,8 +2297,6 @@ int snd_trident_spdif_pcm(struct snd_trident *trident,
 
 	snd_pcm_lib_preallocate_pages_for_all(spdif, SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci), 64*1024, 128*1024);
 
-	if (rpcm)
-		*rpcm = spdif;
 	return 0;
 }
 

commit 5c34fdf48b9522ca87372b1fae19de8f93ffd130
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Tue Dec 2 18:52:21 2014 +0100

    ALSA: trident: Deletion of a check before snd_util_memhdr_free()
    
    The snd_util_memhdr_free() function tests whether its argument is NULL
    and then returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index da875dced2ef..57cd757acfe7 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3702,8 +3702,7 @@ static int snd_trident_free(struct snd_trident *trident)
 		free_irq(trident->irq, trident);
 	if (trident->tlb.buffer.area) {
 		outl(0, TRID_REG(trident, NX_TLBC));
-		if (trident->tlb.memhdr)
-			snd_util_memhdr_free(trident->tlb.memhdr);
+		snd_util_memhdr_free(trident->tlb.memhdr);
 		if (trident->tlb.silent_page.area)
 			snd_dma_free_pages(&trident->tlb.silent_page);
 		vfree(trident->tlb.shadow_entries);

commit 8d9048643f32d795fd6dbf71d9dd5469611151cd
Author: Sachin Kamat <sachin.kamat@samsung.com>
Date:   Tue Jul 1 10:10:29 2014 +0530

    ALSA: trident: Remove unused variable in trident_main.c
    
    'private_data' is not used in the function. Remove it.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@samsung.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 1272c18a2544..da875dced2ef 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3880,14 +3880,12 @@ void snd_trident_free_voice(struct snd_trident * trident, struct snd_trident_voi
 {
 	unsigned long flags;
 	void (*private_free)(struct snd_trident_voice *);
-	void *private_data;
 
 	if (voice == NULL || !voice->use)
 		return;
 	snd_trident_clear_voices(trident, voice->number, voice->number);
 	spin_lock_irqsave(&trident->voice_alloc, flags);
 	private_free = voice->private_free;
-	private_data = voice->private_data;
 	voice->private_free = NULL;
 	voice->private_data = NULL;
 	if (voice->pcm)

commit 80c19b7513029a5da6542b4f8f22d415d659916d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 26 12:11:29 2014 +0100

    ALSA: trident: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 4f3c4be30a48..1272c18a2544 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -69,40 +69,40 @@ static void snd_trident_print_voice_regs(struct snd_trident *trident, int voice)
 {
 	unsigned int val, tmp;
 
-	printk(KERN_DEBUG "Trident voice %i:\n", voice);
+	dev_dbg(trident->card->dev, "Trident voice %i:\n", voice);
 	outb(voice, TRID_REG(trident, T4D_LFO_GC_CIR));
 	val = inl(TRID_REG(trident, CH_LBA));
-	printk(KERN_DEBUG "LBA: 0x%x\n", val);
+	dev_dbg(trident->card->dev, "LBA: 0x%x\n", val);
 	val = inl(TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC));
-	printk(KERN_DEBUG "GVSel: %i\n", val >> 31);
-	printk(KERN_DEBUG "Pan: 0x%x\n", (val >> 24) & 0x7f);
-	printk(KERN_DEBUG "Vol: 0x%x\n", (val >> 16) & 0xff);
-	printk(KERN_DEBUG "CTRL: 0x%x\n", (val >> 12) & 0x0f);
-	printk(KERN_DEBUG "EC: 0x%x\n", val & 0x0fff);
+	dev_dbg(trident->card->dev, "GVSel: %i\n", val >> 31);
+	dev_dbg(trident->card->dev, "Pan: 0x%x\n", (val >> 24) & 0x7f);
+	dev_dbg(trident->card->dev, "Vol: 0x%x\n", (val >> 16) & 0xff);
+	dev_dbg(trident->card->dev, "CTRL: 0x%x\n", (val >> 12) & 0x0f);
+	dev_dbg(trident->card->dev, "EC: 0x%x\n", val & 0x0fff);
 	if (trident->device != TRIDENT_DEVICE_ID_NX) {
 		val = inl(TRID_REG(trident, CH_DX_CSO_ALPHA_FMS));
-		printk(KERN_DEBUG "CSO: 0x%x\n", val >> 16);
-		printk("Alpha: 0x%x\n", (val >> 4) & 0x0fff);
-		printk(KERN_DEBUG "FMS: 0x%x\n", val & 0x0f);
+		dev_dbg(trident->card->dev, "CSO: 0x%x\n", val >> 16);
+		dev_dbg(trident->card->dev, "Alpha: 0x%x\n", (val >> 4) & 0x0fff);
+		dev_dbg(trident->card->dev, "FMS: 0x%x\n", val & 0x0f);
 		val = inl(TRID_REG(trident, CH_DX_ESO_DELTA));
-		printk(KERN_DEBUG "ESO: 0x%x\n", val >> 16);
-		printk(KERN_DEBUG "Delta: 0x%x\n", val & 0xffff);
+		dev_dbg(trident->card->dev, "ESO: 0x%x\n", val >> 16);
+		dev_dbg(trident->card->dev, "Delta: 0x%x\n", val & 0xffff);
 		val = inl(TRID_REG(trident, CH_DX_FMC_RVOL_CVOL));
 	} else {		// TRIDENT_DEVICE_ID_NX
 		val = inl(TRID_REG(trident, CH_NX_DELTA_CSO));
 		tmp = (val >> 24) & 0xff;
-		printk(KERN_DEBUG "CSO: 0x%x\n", val & 0x00ffffff);
+		dev_dbg(trident->card->dev, "CSO: 0x%x\n", val & 0x00ffffff);
 		val = inl(TRID_REG(trident, CH_NX_DELTA_ESO));
 		tmp |= (val >> 16) & 0xff00;
-		printk(KERN_DEBUG "Delta: 0x%x\n", tmp);
-		printk(KERN_DEBUG "ESO: 0x%x\n", val & 0x00ffffff);
+		dev_dbg(trident->card->dev, "Delta: 0x%x\n", tmp);
+		dev_dbg(trident->card->dev, "ESO: 0x%x\n", val & 0x00ffffff);
 		val = inl(TRID_REG(trident, CH_NX_ALPHA_FMS_FMC_RVOL_CVOL));
-		printk(KERN_DEBUG "Alpha: 0x%x\n", val >> 20);
-		printk(KERN_DEBUG "FMS: 0x%x\n", (val >> 16) & 0x0f);
+		dev_dbg(trident->card->dev, "Alpha: 0x%x\n", val >> 20);
+		dev_dbg(trident->card->dev, "FMS: 0x%x\n", (val >> 16) & 0x0f);
 	}
-	printk(KERN_DEBUG "FMC: 0x%x\n", (val >> 14) & 3);
-	printk(KERN_DEBUG "RVol: 0x%x\n", (val >> 7) & 0x7f);
-	printk(KERN_DEBUG "CVol: 0x%x\n", val & 0x7f);
+	dev_dbg(trident->card->dev, "FMC: 0x%x\n", (val >> 14) & 3);
+	dev_dbg(trident->card->dev, "RVol: 0x%x\n", (val >> 7) & 0x7f);
+	dev_dbg(trident->card->dev, "CVol: 0x%x\n", val & 0x7f);
 }
 #endif
 
@@ -156,7 +156,8 @@ static unsigned short snd_trident_codec_read(struct snd_ac97 *ac97, unsigned sho
 	}
 
 	if (count == 0 && !trident->ac97_detect) {
-		snd_printk(KERN_ERR "ac97 codec read TIMEOUT [0x%x/0x%x]!!!\n",
+		dev_err(trident->card->dev,
+			"ac97 codec read TIMEOUT [0x%x/0x%x]!!!\n",
 			   reg, data);
 		data = 0;
 	}
@@ -497,16 +498,16 @@ void snd_trident_write_voice_regs(struct snd_trident * trident,
 	outl(regs[4], TRID_REG(trident, CH_START + 16));
 
 #if 0
-	printk(KERN_DEBUG "written %i channel:\n", voice->number);
-	printk(KERN_DEBUG "  regs[0] = 0x%x/0x%x\n",
+	dev_dbg(trident->card->dev, "written %i channel:\n", voice->number);
+	dev_dbg(trident->card->dev, "  regs[0] = 0x%x/0x%x\n",
 	       regs[0], inl(TRID_REG(trident, CH_START + 0)));
-	printk(KERN_DEBUG "  regs[1] = 0x%x/0x%x\n",
+	dev_dbg(trident->card->dev, "  regs[1] = 0x%x/0x%x\n",
 	       regs[1], inl(TRID_REG(trident, CH_START + 4)));
-	printk(KERN_DEBUG "  regs[2] = 0x%x/0x%x\n",
+	dev_dbg(trident->card->dev, "  regs[2] = 0x%x/0x%x\n",
 	       regs[2], inl(TRID_REG(trident, CH_START + 8)));
-	printk(KERN_DEBUG "  regs[3] = 0x%x/0x%x\n",
+	dev_dbg(trident->card->dev, "  regs[3] = 0x%x/0x%x\n",
 	       regs[3], inl(TRID_REG(trident, CH_START + 12)));
-	printk(KERN_DEBUG "  regs[4] = 0x%x/0x%x\n",
+	dev_dbg(trident->card->dev, "  regs[4] = 0x%x/0x%x\n",
 	       regs[4], inl(TRID_REG(trident, CH_START + 16)));
 #endif
 }
@@ -589,7 +590,7 @@ static void snd_trident_write_vol_reg(struct snd_trident * trident,
 		outb(voice->Vol >> 2, TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC + 2));
 		break;
 	case TRIDENT_DEVICE_ID_SI7018:
-		/* printk(KERN_DEBUG "voice->Vol = 0x%x\n", voice->Vol); */
+		/* dev_dbg(trident->card->dev, "voice->Vol = 0x%x\n", voice->Vol); */
 		outw((voice->CTRL << 12) | voice->Vol,
 		     TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC));
 		break;
@@ -3013,13 +3014,15 @@ static int snd_trident_mixer(struct snd_trident *trident, int pcm_spdif_device)
 		_ac97.num = 1;
 		err = snd_ac97_mixer(trident->ac97_bus, &_ac97, &trident->ac97_sec);
 		if (err < 0)
-			snd_printk(KERN_ERR "SI7018: the secondary codec - invalid access\n");
+			dev_err(trident->card->dev,
+				"SI7018: the secondary codec - invalid access\n");
 #if 0	// only for my testing purpose --jk
 		{
 			struct snd_ac97 *mc97;
 			err = snd_ac97_modem(trident->card, &_ac97, &mc97);
 			if (err < 0)
-				snd_printk(KERN_ERR "snd_ac97_modem returned error %i\n", err);
+				dev_err(trident->card->dev,
+					"snd_ac97_modem returned error %i\n", err);
 		}
 #endif
 	}
@@ -3197,7 +3200,8 @@ int snd_trident_create_gameport(struct snd_trident *chip)
 
 	chip->gameport = gp = gameport_allocate_port();
 	if (!gp) {
-		printk(KERN_ERR "trident: cannot allocate memory for gameport\n");
+		dev_err(chip->card->dev,
+			"cannot allocate memory for gameport\n");
 		return -ENOMEM;
 	}
 
@@ -3270,7 +3274,8 @@ static int snd_trident_sis_reset(struct snd_trident *trident)
 			goto __si7018_ok;
 		do_delay(trident);
 	} while (time_after_eq(end_time, jiffies));
-	snd_printk(KERN_ERR "AC'97 codec ready error [0x%x]\n", inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)));
+	dev_err(trident->card->dev, "AC'97 codec ready error [0x%x]\n",
+		inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)));
 	if (r-- > 0) {
 		end_time = jiffies + HZ;
 		do {
@@ -3367,7 +3372,7 @@ static int snd_trident_tlb_alloc(struct snd_trident *trident)
 
 	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci),
 				2 * SNDRV_TRIDENT_MAX_PAGES * 4, &trident->tlb.buffer) < 0) {
-		snd_printk(KERN_ERR "trident: unable to allocate TLB buffer\n");
+		dev_err(trident->card->dev, "unable to allocate TLB buffer\n");
 		return -ENOMEM;
 	}
 	trident->tlb.entries = (unsigned int*)ALIGN((unsigned long)trident->tlb.buffer.area, SNDRV_TRIDENT_MAX_PAGES * 4);
@@ -3375,13 +3380,14 @@ static int snd_trident_tlb_alloc(struct snd_trident *trident)
 	/* allocate shadow TLB page table (virtual addresses) */
 	trident->tlb.shadow_entries = vmalloc(SNDRV_TRIDENT_MAX_PAGES*sizeof(unsigned long));
 	if (trident->tlb.shadow_entries == NULL) {
-		snd_printk(KERN_ERR "trident: unable to allocate shadow TLB entries\n");
+		dev_err(trident->card->dev,
+			"unable to allocate shadow TLB entries\n");
 		return -ENOMEM;
 	}
 	/* allocate and setup silent page and initialise TLB entries */
 	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci),
 				SNDRV_TRIDENT_PAGE_SIZE, &trident->tlb.silent_page) < 0) {
-		snd_printk(KERN_ERR "trident: unable to allocate silent page\n");
+		dev_err(trident->card->dev, "unable to allocate silent page\n");
 		return -ENOMEM;
 	}
 	memset(trident->tlb.silent_page.area, 0, SNDRV_TRIDENT_PAGE_SIZE);
@@ -3439,7 +3445,7 @@ static int snd_trident_4d_dx_init(struct snd_trident *trident)
 			goto __dx_ok;
 		do_delay(trident);
 	} while (time_after_eq(end_time, jiffies));
-	snd_printk(KERN_ERR "AC'97 codec ready error\n");
+	dev_err(trident->card->dev, "AC'97 codec ready error\n");
 	return -EIO;
 
  __dx_ok:
@@ -3477,7 +3483,8 @@ static int snd_trident_4d_nx_init(struct snd_trident *trident)
 			goto __nx_ok;
 		do_delay(trident);
 	} while (time_after_eq(end_time, jiffies));
-	snd_printk(KERN_ERR "AC'97 codec ready error [0x%x]\n", inl(TRID_REG(trident, NX_ACR0_AC97_COM_STAT)));
+	dev_err(trident->card->dev, "AC'97 codec ready error [0x%x]\n",
+		inl(TRID_REG(trident, NX_ACR0_AC97_COM_STAT)));
 	return -EIO;
 
  __nx_ok:
@@ -3562,7 +3569,8 @@ int snd_trident_create(struct snd_card *card,
 	/* check, if we can restrict PCI DMA transfers to 30 bits */
 	if (pci_set_dma_mask(pci, DMA_BIT_MASK(30)) < 0 ||
 	    pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(30)) < 0) {
-		snd_printk(KERN_ERR "architecture does not support 30bit PCI busmaster DMA\n");
+		dev_err(card->dev,
+			"architecture does not support 30bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;
 	}
@@ -3600,7 +3608,7 @@ int snd_trident_create(struct snd_card *card,
 
 	if (request_irq(pci->irq, snd_trident_interrupt, IRQF_SHARED,
 			KBUILD_MODNAME, trident)) {
-		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		dev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);
 		snd_trident_free(trident);
 		return -EBUSY;
 	}
@@ -3949,8 +3957,7 @@ static int snd_trident_resume(struct device *dev)
 	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
 	if (pci_enable_device(pci) < 0) {
-		printk(KERN_ERR "trident: pci_enable_device failed, "
-		       "disabling device\n");
+		dev_err(dev, "pci_enable_device failed, disabling device\n");
 		snd_card_disconnect(card);
 		return -EIO;
 	}

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index fb0e1586a6f8..4f3c4be30a48 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3664,7 +3664,6 @@ int snd_trident_create(struct snd_card *card,
 	snd_trident_enable_eso(trident);
 
 	snd_trident_proc_init(trident);
-	snd_card_set_dev(card, &pci->dev);
 	*rtrident = trident;
 	return 0;
 }

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 06b10d1a76e5..fb0e1586a6f8 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -2171,8 +2171,8 @@ static struct snd_pcm_ops snd_trident_spdif_7018_ops = {
   
   ---------------------------------------------------------------------------*/
 
-int __devinit snd_trident_pcm(struct snd_trident * trident,
-			      int device, struct snd_pcm ** rpcm)
+int snd_trident_pcm(struct snd_trident *trident,
+		    int device, struct snd_pcm **rpcm)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -2229,8 +2229,8 @@ int __devinit snd_trident_pcm(struct snd_trident * trident,
   
   ---------------------------------------------------------------------------*/
 
-int __devinit snd_trident_foldback_pcm(struct snd_trident * trident,
-				       int device, struct snd_pcm ** rpcm)
+int snd_trident_foldback_pcm(struct snd_trident *trident,
+			     int device, struct snd_pcm **rpcm)
 {
 	struct snd_pcm *foldback;
 	int err;
@@ -2286,8 +2286,8 @@ int __devinit snd_trident_foldback_pcm(struct snd_trident * trident,
   
   ---------------------------------------------------------------------------*/
 
-int __devinit snd_trident_spdif_pcm(struct snd_trident * trident,
-				    int device, struct snd_pcm ** rpcm)
+int snd_trident_spdif_pcm(struct snd_trident *trident,
+			  int device, struct snd_pcm **rpcm)
 {
 	struct snd_pcm *spdif;
 	int err;
@@ -2371,7 +2371,7 @@ static int snd_trident_spdif_control_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_spdif_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_spdif_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,SWITCH),
@@ -2434,7 +2434,7 @@ static int snd_trident_spdif_default_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_spdif_default __devinitdata =
+static struct snd_kcontrol_new snd_trident_spdif_default =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
@@ -2467,7 +2467,7 @@ static int snd_trident_spdif_mask_get(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static struct snd_kcontrol_new snd_trident_spdif_mask __devinitdata =
+static struct snd_kcontrol_new snd_trident_spdif_mask =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -2529,7 +2529,7 @@ static int snd_trident_spdif_stream_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_spdif_stream __devinitdata =
+static struct snd_kcontrol_new snd_trident_spdif_stream =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -2579,7 +2579,7 @@ static int snd_trident_ac97_control_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_ac97_rear_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_ac97_rear_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Rear Path",
@@ -2637,7 +2637,7 @@ static int snd_trident_vol_control_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_vol_music_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_vol_music_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Music Playback Volume",
@@ -2648,7 +2648,7 @@ static struct snd_kcontrol_new snd_trident_vol_music_control __devinitdata =
 	.tlv = { .p = db_scale_gvol },
 };
 
-static struct snd_kcontrol_new snd_trident_vol_wave_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_vol_wave_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Wave Playback Volume",
@@ -2715,7 +2715,7 @@ static int snd_trident_pcm_vol_control_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_pcm_vol_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_pcm_vol_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "PCM Front Playback Volume",
@@ -2779,7 +2779,7 @@ static int snd_trident_pcm_pan_control_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_pcm_pan_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_pcm_pan_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "PCM Pan Playback Control",
@@ -2836,7 +2836,7 @@ static int snd_trident_pcm_rvol_control_put(struct snd_kcontrol *kcontrol,
 
 static const DECLARE_TLV_DB_SCALE(db_scale_crvol, -3175, 25, 1);
 
-static struct snd_kcontrol_new snd_trident_pcm_rvol_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_pcm_rvol_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "PCM Reverb Playback Volume",
@@ -2892,7 +2892,7 @@ static int snd_trident_pcm_cvol_control_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static struct snd_kcontrol_new snd_trident_pcm_cvol_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_pcm_cvol_control =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "PCM Chorus Playback Volume",
@@ -2972,7 +2972,7 @@ static int snd_trident_pcm_mixer_free(struct snd_trident *trident, struct snd_tr
   
   ---------------------------------------------------------------------------*/
 
-static int __devinit snd_trident_mixer(struct snd_trident * trident, int pcm_spdif_device)
+static int snd_trident_mixer(struct snd_trident *trident, int pcm_spdif_device)
 {
 	struct snd_ac97_template _ac97;
 	struct snd_card *card = trident->card;
@@ -3191,7 +3191,7 @@ static int snd_trident_gameport_open(struct gameport *gameport, int mode)
 	}
 }
 
-int __devinit snd_trident_create_gameport(struct snd_trident *chip)
+int snd_trident_create_gameport(struct snd_trident *chip)
 {
 	struct gameport *gp;
 
@@ -3225,7 +3225,7 @@ static inline void snd_trident_free_gameport(struct snd_trident *chip)
 	}
 }
 #else
-int __devinit snd_trident_create_gameport(struct snd_trident *chip) { return -ENOSYS; }
+int snd_trident_create_gameport(struct snd_trident *chip) { return -ENOSYS; }
 static inline void snd_trident_free_gameport(struct snd_trident *chip) { }
 #endif /* CONFIG_GAMEPORT */
 
@@ -3329,7 +3329,7 @@ static void snd_trident_proc_read(struct snd_info_entry *entry,
 	}
 }
 
-static void __devinit snd_trident_proc_init(struct snd_trident * trident)
+static void snd_trident_proc_init(struct snd_trident *trident)
 {
 	struct snd_info_entry *entry;
 	const char *s = "trident";
@@ -3358,7 +3358,7 @@ static int snd_trident_dev_free(struct snd_device *device)
   
   ---------------------------------------------------------------------------*/
 
-static int __devinit snd_trident_tlb_alloc(struct snd_trident *trident)
+static int snd_trident_tlb_alloc(struct snd_trident *trident)
 {
 	int i;
 
@@ -3539,7 +3539,7 @@ static int snd_trident_sis_init(struct snd_trident *trident)
   
   ---------------------------------------------------------------------------*/
 
-int __devinit snd_trident_create(struct snd_card *card,
+int snd_trident_create(struct snd_card *card,
 		       struct pci_dev *pci,
 		       int pcm_streams,
 		       int pcm_spdif_device,

commit c7561cd80469f2fe4a6be0984db57832ee7f2a3b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 14 18:12:04 2012 +0200

    ALSA: PCI: Replace CONFIG_PM with CONFIG_PM_SLEEP
    
    Otherwise we may get compile warnings due to unused functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 94011dcae731..06b10d1a76e5 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3919,7 +3919,7 @@ static void snd_trident_clear_voices(struct snd_trident * trident, unsigned shor
 	}
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int snd_trident_suspend(struct device *dev)
 {
 	struct pci_dev *pci = to_pci_dev(dev);
@@ -3983,4 +3983,4 @@ static int snd_trident_resume(struct device *dev)
 }
 
 SIMPLE_DEV_PM_OPS(snd_trident_pm, snd_trident_suspend, snd_trident_resume);
-#endif /* CONFIG_PM */
+#endif /* CONFIG_PM_SLEEP */

commit 81fcb170852d58d7ebd8101a8ef970c82056426e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 16:37:05 2012 +0200

    ALSA: Move some headers to local directories from include/sound
    
    This is a bit clean up of public sound header directory.
    Some header files in include/sound aren't really necessary to be
    located there but can be moved to their local directories gracefully.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index b4430c093bad..94011dcae731 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -41,7 +41,7 @@
 #include <sound/info.h>
 #include <sound/control.h>
 #include <sound/tlv.h>
-#include <sound/trident.h>
+#include "trident.h"
 #include <sound/asoundef.h>
 
 #include <asm/io.h>

commit 68cb2b559278858ef9f3a7722f95df88797c7840
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 15:20:37 2012 +0200

    ALSA: Convert to new pm_ops for PCI drivers
    
    Straightforward conversion to the new pm_ops from the legacy
    suspend/resume ops.
    
    Since we change vx222, vx_core and vxpocket have to be converted,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 61d3c0e8d4ce..b4430c093bad 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3920,9 +3920,10 @@ static void snd_trident_clear_voices(struct snd_trident * trident, unsigned shor
 }
 
 #ifdef CONFIG_PM
-int snd_trident_suspend(struct pci_dev *pci, pm_message_t state)
+static int snd_trident_suspend(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_trident *trident = card->private_data;
 
 	trident->in_suspend = 1;
@@ -3936,13 +3937,14 @@ int snd_trident_suspend(struct pci_dev *pci, pm_message_t state)
 
 	pci_disable_device(pci);
 	pci_save_state(pci);
-	pci_set_power_state(pci, pci_choose_state(pci, state));
+	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
-int snd_trident_resume(struct pci_dev *pci)
+static int snd_trident_resume(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_trident *trident = card->private_data;
 
 	pci_set_power_state(pci, PCI_D0);
@@ -3979,4 +3981,6 @@ int snd_trident_resume(struct pci_dev *pci)
 	trident->in_suspend = 0;
 	return 0;
 }
+
+SIMPLE_DEV_PM_OPS(snd_trident_pm, snd_trident_suspend, snd_trident_resume);
 #endif /* CONFIG_PM */

commit d81a6d71760c4d8323f1f9a506c64084caa09063
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Sep 22 09:34:58 2011 -0400

    sound: Add export.h for THIS_MODULE/EXPORT_SYMBOL where needed
    
    These aren't modules, but they do make use of these macros, so
    they will need export.h to get that definition.  Previously,
    they got it via the implicit module.h inclusion.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 5bd57a7c52d2..61d3c0e8d4ce 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -35,6 +35,7 @@
 #include <linux/vmalloc.h>
 #include <linux/gameport.h>
 #include <linux/dma-mapping.h>
+#include <linux/export.h>
 
 #include <sound/core.h>
 #include <sound/info.h>

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 2870a4fdc130..5bd57a7c52d2 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3598,7 +3598,7 @@ int __devinit snd_trident_create(struct snd_card *card,
 	trident->port = pci_resource_start(pci, 0);
 
 	if (request_irq(pci->irq, snd_trident_interrupt, IRQF_SHARED,
-			"Trident Audio", trident)) {
+			KBUILD_MODNAME, trident)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_trident_free(trident);
 		return -EBUSY;

commit 421f91d21ad6f799dc7b489bb33cc560ccc56f98
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Fri Jun 11 12:17:00 2010 +0200

    fix typos concerning "initiali[zs]e"
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 6d943f6f6b70..2870a4fdc130 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -1055,7 +1055,7 @@ static int snd_trident_capture_prepare(struct snd_pcm_substream *substream)
 
 	spin_lock_irq(&trident->reg_lock);
 
-	// Initilize the channel and set channel Mode
+	// Initialize the channel and set channel Mode
 	outb(0, TRID_REG(trident, LEGACY_DMAR15));
 
 	// Set DMA channel operation mode register

commit 28b767967763835d8526f6baedc25a8a86052640
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:17 2009 -0700

    dma-mapping: replace all DMA_30BIT_MASK macro with DMA_BIT_MASK(30)
    
    Replace all DMA_30BIT_MASK macro with DMA_BIT_MASK(30)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index a9da9c184660..6d943f6f6b70 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3559,8 +3559,8 @@ int __devinit snd_trident_create(struct snd_card *card,
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 	/* check, if we can restrict PCI DMA transfers to 30 bits */
-	if (pci_set_dma_mask(pci, DMA_30BIT_MASK) < 0 ||
-	    pci_set_consistent_dma_mask(pci, DMA_30BIT_MASK) < 0) {
+	if (pci_set_dma_mask(pci, DMA_BIT_MASK(30)) < 0 ||
+	    pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(30)) < 0) {
 		snd_printk(KERN_ERR "architecture does not support 30bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;

commit ee419653a38de93b75a577851d9e4003cf0bbe07
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 16:11:31 2009 +0100

    ALSA: Fix missing KERN_* prefix to printk in sound/pci
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index c612b435ca2b..a9da9c184660 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -68,40 +68,40 @@ static void snd_trident_print_voice_regs(struct snd_trident *trident, int voice)
 {
 	unsigned int val, tmp;
 
-	printk("Trident voice %i:\n", voice);
+	printk(KERN_DEBUG "Trident voice %i:\n", voice);
 	outb(voice, TRID_REG(trident, T4D_LFO_GC_CIR));
 	val = inl(TRID_REG(trident, CH_LBA));
-	printk("LBA: 0x%x\n", val);
+	printk(KERN_DEBUG "LBA: 0x%x\n", val);
 	val = inl(TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC));
-	printk("GVSel: %i\n", val >> 31);
-	printk("Pan: 0x%x\n", (val >> 24) & 0x7f);
-	printk("Vol: 0x%x\n", (val >> 16) & 0xff);
-	printk("CTRL: 0x%x\n", (val >> 12) & 0x0f);
-	printk("EC: 0x%x\n", val & 0x0fff);
+	printk(KERN_DEBUG "GVSel: %i\n", val >> 31);
+	printk(KERN_DEBUG "Pan: 0x%x\n", (val >> 24) & 0x7f);
+	printk(KERN_DEBUG "Vol: 0x%x\n", (val >> 16) & 0xff);
+	printk(KERN_DEBUG "CTRL: 0x%x\n", (val >> 12) & 0x0f);
+	printk(KERN_DEBUG "EC: 0x%x\n", val & 0x0fff);
 	if (trident->device != TRIDENT_DEVICE_ID_NX) {
 		val = inl(TRID_REG(trident, CH_DX_CSO_ALPHA_FMS));
-		printk("CSO: 0x%x\n", val >> 16);
+		printk(KERN_DEBUG "CSO: 0x%x\n", val >> 16);
 		printk("Alpha: 0x%x\n", (val >> 4) & 0x0fff);
-		printk("FMS: 0x%x\n", val & 0x0f);
+		printk(KERN_DEBUG "FMS: 0x%x\n", val & 0x0f);
 		val = inl(TRID_REG(trident, CH_DX_ESO_DELTA));
-		printk("ESO: 0x%x\n", val >> 16);
-		printk("Delta: 0x%x\n", val & 0xffff);
+		printk(KERN_DEBUG "ESO: 0x%x\n", val >> 16);
+		printk(KERN_DEBUG "Delta: 0x%x\n", val & 0xffff);
 		val = inl(TRID_REG(trident, CH_DX_FMC_RVOL_CVOL));
 	} else {		// TRIDENT_DEVICE_ID_NX
 		val = inl(TRID_REG(trident, CH_NX_DELTA_CSO));
 		tmp = (val >> 24) & 0xff;
-		printk("CSO: 0x%x\n", val & 0x00ffffff);
+		printk(KERN_DEBUG "CSO: 0x%x\n", val & 0x00ffffff);
 		val = inl(TRID_REG(trident, CH_NX_DELTA_ESO));
 		tmp |= (val >> 16) & 0xff00;
-		printk("Delta: 0x%x\n", tmp);
-		printk("ESO: 0x%x\n", val & 0x00ffffff);
+		printk(KERN_DEBUG "Delta: 0x%x\n", tmp);
+		printk(KERN_DEBUG "ESO: 0x%x\n", val & 0x00ffffff);
 		val = inl(TRID_REG(trident, CH_NX_ALPHA_FMS_FMC_RVOL_CVOL));
-		printk("Alpha: 0x%x\n", val >> 20);
-		printk("FMS: 0x%x\n", (val >> 16) & 0x0f);
+		printk(KERN_DEBUG "Alpha: 0x%x\n", val >> 20);
+		printk(KERN_DEBUG "FMS: 0x%x\n", (val >> 16) & 0x0f);
 	}
-	printk("FMC: 0x%x\n", (val >> 14) & 3);
-	printk("RVol: 0x%x\n", (val >> 7) & 0x7f);
-	printk("CVol: 0x%x\n", val & 0x7f);
+	printk(KERN_DEBUG "FMC: 0x%x\n", (val >> 14) & 3);
+	printk(KERN_DEBUG "RVol: 0x%x\n", (val >> 7) & 0x7f);
+	printk(KERN_DEBUG "CVol: 0x%x\n", val & 0x7f);
 }
 #endif
 
@@ -496,12 +496,17 @@ void snd_trident_write_voice_regs(struct snd_trident * trident,
 	outl(regs[4], TRID_REG(trident, CH_START + 16));
 
 #if 0
-	printk("written %i channel:\n", voice->number);
-	printk("  regs[0] = 0x%x/0x%x\n", regs[0], inl(TRID_REG(trident, CH_START + 0)));
-	printk("  regs[1] = 0x%x/0x%x\n", regs[1], inl(TRID_REG(trident, CH_START + 4)));
-	printk("  regs[2] = 0x%x/0x%x\n", regs[2], inl(TRID_REG(trident, CH_START + 8)));
-	printk("  regs[3] = 0x%x/0x%x\n", regs[3], inl(TRID_REG(trident, CH_START + 12)));
-	printk("  regs[4] = 0x%x/0x%x\n", regs[4], inl(TRID_REG(trident, CH_START + 16)));
+	printk(KERN_DEBUG "written %i channel:\n", voice->number);
+	printk(KERN_DEBUG "  regs[0] = 0x%x/0x%x\n",
+	       regs[0], inl(TRID_REG(trident, CH_START + 0)));
+	printk(KERN_DEBUG "  regs[1] = 0x%x/0x%x\n",
+	       regs[1], inl(TRID_REG(trident, CH_START + 4)));
+	printk(KERN_DEBUG "  regs[2] = 0x%x/0x%x\n",
+	       regs[2], inl(TRID_REG(trident, CH_START + 8)));
+	printk(KERN_DEBUG "  regs[3] = 0x%x/0x%x\n",
+	       regs[3], inl(TRID_REG(trident, CH_START + 12)));
+	printk(KERN_DEBUG "  regs[4] = 0x%x/0x%x\n",
+	       regs[4], inl(TRID_REG(trident, CH_START + 16)));
 #endif
 }
 
@@ -583,7 +588,7 @@ static void snd_trident_write_vol_reg(struct snd_trident * trident,
 		outb(voice->Vol >> 2, TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC + 2));
 		break;
 	case TRIDENT_DEVICE_ID_SI7018:
-		// printk("voice->Vol = 0x%x\n", voice->Vol);
+		/* printk(KERN_DEBUG "voice->Vol = 0x%x\n", voice->Vol); */
 		outw((voice->CTRL << 12) | voice->Vol,
 		     TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC));
 		break;

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index a69b4206c69e..c612b435ca2b 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -2931,7 +2931,8 @@ static int snd_trident_pcm_mixer_build(struct snd_trident *trident,
 {
 	struct snd_trident_pcm_mixer *tmix;
 
-	snd_assert(trident != NULL && voice != NULL && substream != NULL, return -EINVAL);
+	if (snd_BUG_ON(!trident || !voice || !substream))
+		return -EINVAL;
 	tmix = &trident->pcm_mixer[substream->number];
 	tmix->voice = voice;
 	tmix->vol = T4D_DEFAULT_PCM_VOL;
@@ -2946,7 +2947,8 @@ static int snd_trident_pcm_mixer_free(struct snd_trident *trident, struct snd_tr
 {
 	struct snd_trident_pcm_mixer *tmix;
 
-	snd_assert(trident != NULL && substream != NULL, return -EINVAL);
+	if (snd_BUG_ON(!trident || !substream))
+		return -EINVAL;
 	tmix = &trident->pcm_mixer[substream->number];
 	tmix->voice = NULL;
 	snd_trident_notify_pcm_change(trident, tmix, substream->number, 0);
@@ -3131,7 +3133,8 @@ static unsigned char snd_trident_gameport_read(struct gameport *gameport)
 {
 	struct snd_trident *chip = gameport_get_port_data(gameport);
 
-	snd_assert(chip, return 0);
+	if (snd_BUG_ON(!chip))
+		return 0;
 	return inb(TRID_REG(chip, GAMEPORT_LEGACY));
 }
 
@@ -3139,7 +3142,8 @@ static void snd_trident_gameport_trigger(struct gameport *gameport)
 {
 	struct snd_trident *chip = gameport_get_port_data(gameport);
 
-	snd_assert(chip, return);
+	if (snd_BUG_ON(!chip))
+		return;
 	outb(0xff, TRID_REG(chip, GAMEPORT_LEGACY));
 }
 
@@ -3148,7 +3152,8 @@ static int snd_trident_gameport_cooked_read(struct gameport *gameport, int *axes
 	struct snd_trident *chip = gameport_get_port_data(gameport);
 	int i;
 
-	snd_assert(chip, return 0);
+	if (snd_BUG_ON(!chip))
+		return 0;
 
 	*buttons = (~inb(TRID_REG(chip, GAMEPORT_LEGACY)) >> 4) & 0xf;
 
@@ -3164,7 +3169,8 @@ static int snd_trident_gameport_open(struct gameport *gameport, int mode)
 {
 	struct snd_trident *chip = gameport_get_port_data(gameport);
 
-	snd_assert(chip, return 0);
+	if (snd_BUG_ON(!chip))
+		return 0;
 
 	switch (mode) {
 		case GAMEPORT_MODE_COOKED:
@@ -3891,8 +3897,8 @@ static void snd_trident_clear_voices(struct snd_trident * trident, unsigned shor
 {
 	unsigned int i, val, mask[2] = { 0, 0 };
 
-	snd_assert(v_min <= 63, return);
-	snd_assert(v_max <= 63, return);
+	if (snd_BUG_ON(v_min > 63 || v_max > 63))
+		return;
 	for (i = v_min; i <= v_max; i++)
 		mask[i >> 5] |= 1 << (i & 0x1f);
 	if (mask[0]) {

commit 981bcead3f2279a1ec6fb5f2c57aff79ed61a700
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Jun 23 11:45:47 2008 +0200

    ALSA: trident - pause s/pdif output
    
    Stop the S/PDIF DMA engine and output when the device is told to pause.
    It will keep on looping the current buffer contents if this isn't done.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Tested-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index bbcee2c09ae4..a69b4206c69e 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -1590,7 +1590,10 @@ static int snd_trident_trigger(struct snd_pcm_substream *substream,
 	if (spdif_flag) {
 		if (trident->device != TRIDENT_DEVICE_ID_SI7018) {
 			outl(trident->spdif_pcm_bits, TRID_REG(trident, NX_SPCSTATUS));
-			outb(trident->spdif_pcm_ctrl, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));
+			val = trident->spdif_pcm_ctrl;
+			if (!go)
+				val &= ~(0x28);
+			outb(val, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));
 		} else {
 			outl(trident->spdif_pcm_bits, TRID_REG(trident, SI_SPDIF_CS));
 			val = inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) | SPDIF_EN;

commit ebf029da38829ede6b53ac8a5ad45b149064ea16
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 22 17:28:11 2008 +0200

    [ALSA] Fix possible races at free_irq in PCI drivers
    
    The irq handler of PCI drivers must be released before releasing other
    resources since the handler for a shared irq can be still called and
    may access the freed resource again.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 71138ff9b310..bbcee2c09ae4 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3676,6 +3676,8 @@ static int snd_trident_free(struct snd_trident *trident)
 	else if (trident->device == TRIDENT_DEVICE_ID_SI7018) {
 		outl(0, TRID_REG(trident, SI_SERIAL_INTF_CTRL));
 	}
+	if (trident->irq >= 0)
+		free_irq(trident->irq, trident);
 	if (trident->tlb.buffer.area) {
 		outl(0, TRID_REG(trident, NX_TLBC));
 		if (trident->tlb.memhdr)
@@ -3685,8 +3687,6 @@ static int snd_trident_free(struct snd_trident *trident)
 		vfree(trident->tlb.shadow_entries);
 		snd_dma_free_pages(&trident->tlb.buffer);
 	}
-	if (trident->irq >= 0)
-		free_irq(trident->irq, trident);
 	pci_release_regions(trident->pci);
 	pci_disable_device(trident->pci);
 	kfree(trident);

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index c8d5665b5782..71138ff9b310 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -27,7 +27,6 @@
  *  SiS7018 S/PDIF support by Thomas Winischhofer <thomas@winischhofer.net>
  */
 
-#include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>

commit 561de31a23a8a5d23baeb8b2ce7c6102cb649616
Author: Joe Perches <joe@perches.com>
Date:   Tue Dec 18 13:13:47 2007 +0100

    [ALSA] sound/: Spelling fixes
    
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 59a319568ae5..c8d5665b5782 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -436,7 +436,7 @@ static void snd_trident_free_synth_channel(struct snd_trident *trident, int chan
    Description: This routine will complete and write the 5 hardware channel
                 registers to hardware.
   
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
                 voice - synthesizer voice structure
                 Each register field.
   
@@ -514,7 +514,7 @@ EXPORT_SYMBOL(snd_trident_write_voice_regs);
    Description: This routine will write the new CSO offset
                 register to hardware.
   
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
                 voice - synthesizer voice structure
                 CSO - new CSO value
   
@@ -540,7 +540,7 @@ static void snd_trident_write_cso_reg(struct snd_trident * trident,
    Description: This routine will write the new ESO offset
                 register to hardware.
   
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
                 voice - synthesizer voice structure
                 ESO - new ESO value
   
@@ -566,7 +566,7 @@ static void snd_trident_write_eso_reg(struct snd_trident * trident,
    Description: This routine will write the new voice volume
                 register to hardware.
   
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
                 voice - synthesizer voice structure
                 Vol - new voice volume
   
@@ -597,7 +597,7 @@ static void snd_trident_write_vol_reg(struct snd_trident * trident,
    Description: This routine will write the new voice pan
                 register to hardware.
   
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
                 voice - synthesizer voice structure
                 Pan - new pan value
   
@@ -619,7 +619,7 @@ static void snd_trident_write_pan_reg(struct snd_trident * trident,
    Description: This routine will write the new reverb volume
                 register to hardware.
   
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
                 voice - synthesizer voice structure
                 RVol - new reverb volume
   
@@ -643,7 +643,7 @@ static void snd_trident_write_rvol_reg(struct snd_trident * trident,
    Description: This routine will write the new chorus volume
                 register to hardware.
   
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
                 voice - synthesizer voice structure
                 CVol - new chorus volume
   
@@ -666,7 +666,7 @@ static void snd_trident_write_cvol_reg(struct snd_trident * trident,
 
    Description: This routine converts rate in HZ to hardware delta value.
   
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
                 rate - Real or Virtual channel number.
   
    Returns:     Delta value.
@@ -696,7 +696,7 @@ static unsigned int snd_trident_convert_rate(unsigned int rate)
 
    Description: This routine converts rate in HZ to hardware delta value.
   
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
                 rate - Real or Virtual channel number.
   
    Returns:     Delta value.
@@ -726,7 +726,7 @@ static unsigned int snd_trident_convert_adc_rate(unsigned int rate)
 
    Description: This routine converts rate in HZ to spurious threshold.
   
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
                 rate - Real or Virtual channel number.
   
    Returns:     Delta value.
@@ -748,7 +748,7 @@ static unsigned int snd_trident_spurious_threshold(unsigned int rate,
 
    Description: This routine returns a control mode for a PCM channel.
   
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
                 substream  - PCM substream
   
    Returns:     Control value.
@@ -781,7 +781,7 @@ static unsigned int snd_trident_control_mode(struct snd_pcm_substream *substream
   
    Description: Device I/O control handler for playback/capture parameters.
   
-   Paramters:   substream  - PCM substream class
+   Parameters:   substream  - PCM substream class
                 cmd     - what ioctl message to process
                 arg     - additional message infoarg     
   
@@ -1664,7 +1664,7 @@ static snd_pcm_uframes_t snd_trident_playback_pointer(struct snd_pcm_substream *
   
    Description: This routine return the capture position
                 
-   Paramters:   pcm1    - PCM device class
+   Parameters:   pcm1    - PCM device class
 
    Returns:     position of buffer
   
@@ -2157,7 +2157,7 @@ static struct snd_pcm_ops snd_trident_spdif_7018_ops = {
   
    Description: This routine registers the 4DWave device for PCM support.
                 
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
 
    Returns:     None
   
@@ -2215,7 +2215,7 @@ int __devinit snd_trident_pcm(struct snd_trident * trident,
   
    Description: This routine registers the 4DWave device for foldback PCM support.
                 
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
 
    Returns:     None
   
@@ -2272,7 +2272,7 @@ int __devinit snd_trident_foldback_pcm(struct snd_trident * trident,
   
    Description: This routine registers the 4DWave-NX device for SPDIF support.
                 
-   Paramters:   trident - pointer to target device class for 4DWave-NX.
+   Parameters:  trident - pointer to target device class for 4DWave-NX.
 
    Returns:     None
   
@@ -2956,7 +2956,7 @@ static int snd_trident_pcm_mixer_free(struct snd_trident *trident, struct snd_tr
   
    Description: This routine registers the 4DWave device for mixer support.
                 
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
 
    Returns:     None
   
@@ -3338,7 +3338,7 @@ static int snd_trident_dev_free(struct snd_device *device)
    Description: Allocate and set up the TLB page table on 4D NX.
 		Each entry has 4 bytes (physical PCI address).
                 
-   Paramters:   trident - pointer to target device class for 4DWave.
+   Parameters:  trident - pointer to target device class for 4DWave.
 
    Returns:     0 or negative error code
   
@@ -3515,7 +3515,7 @@ static int snd_trident_sis_init(struct snd_trident *trident)
    Description: This routine will create the device specific class for
                 the 4DWave card. It will also perform basic initialization.
                 
-   Paramters:   card  - which card to create
+   Parameters:  card  - which card to create
                 pci   - interface to PCI bus resource info
                 dma1ptr - playback dma buffer
                 dma2ptr - capture dma buffer
@@ -3661,7 +3661,7 @@ int __devinit snd_trident_create(struct snd_card *card,
    Description: This routine will free the device specific class for
                 the 4DWave card. 
                 
-   Paramters:   trident  - device specific private data for 4DWave card
+   Parameters:  trident  - device specific private data for 4DWave card
 
    Returns:     None.
   
@@ -3699,7 +3699,7 @@ static int snd_trident_free(struct snd_trident *trident)
   
    Description: ISR for Trident 4DWave device
                 
-   Paramters:   trident  - device specific private data for 4DWave card
+   Parameters:  trident  - device specific private data for 4DWave card
 
    Problems:    It seems that Trident chips generates interrupts more than
                 one time in special cases. The spurious interrupts are

commit e5723b41abe559bafc52591dcf8ee19cc131d3a1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 30 12:17:17 2007 +0100

    [ALSA] Remove sequencer instrument layer
    
    Remove sequencer instrument layer from the tree.
    This mechanism hasn't been used much with the actual devices.  The only
    reasonable user was OPL3 loader, and now it was rewritten to use hwdep
    instead.  So, let's remove the rest of rotten codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index a235e034a690..59a319568ae5 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3313,12 +3313,6 @@ static void snd_trident_proc_read(struct snd_info_entry *entry,
 			snd_iprintf(buffer, "Memory Free    : %d\n", snd_util_mem_avail(trident->tlb.memhdr));
 		}
 	}
-#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
-	snd_iprintf(buffer,"\nWavetable Synth\n");
-	snd_iprintf(buffer, "Memory Maximum : %d\n", trident->synth.max_size);
-	snd_iprintf(buffer, "Memory Used    : %d\n", trident->synth.current_size);
-	snd_iprintf(buffer, "Memory Free    : %d\n", (trident->synth.max_size-trident->synth.current_size));
-#endif
 }
 
 static void __devinit snd_trident_proc_init(struct snd_trident * trident)
@@ -3815,28 +3809,6 @@ static irqreturn_t snd_trident_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-/*---------------------------------------------------------------------------
-   snd_trident_attach_synthesizer
-  
-   Description: Attach synthesizer hooks
-                
-   Paramters:   trident  - device specific private data for 4DWave card
-
-   Returns:     None.
-  
-  ---------------------------------------------------------------------------*/
-int snd_trident_attach_synthesizer(struct snd_trident *trident)
-{	
-#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
-	if (snd_seq_device_new(trident->card, 1, SNDRV_SEQ_DEV_ID_TRIDENT,
-			       sizeof(struct snd_trident *), &trident->seq_dev) >= 0) {
-		strcpy(trident->seq_dev->name, "4DWave");
-		*(struct snd_trident **)SNDRV_SEQ_DEVICE_ARGPTR(trident->seq_dev) = trident;
-	}
-#endif
-	return 0;
-}
-
 struct snd_trident_voice *snd_trident_alloc_voice(struct snd_trident * trident, int type, int client, int port)
 {
 	struct snd_trident_voice *pvoice;

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 00e4004d5638..a235e034a690 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -1,5 +1,5 @@
 /*
- *  Maintained by Jaroslav Kysela <perex@suse.cz>
+ *  Maintained by Jaroslav Kysela <perex@perex.cz>
  *  Originated by audio@tridentmicro.com
  *  Fri Feb 19 15:55:28 MST 1999
  *  Routines for control of Trident 4DWave (DX and NX) chip

commit a5ce88909d3007caa7b65996a8f6784350beb2a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 23 15:42:26 2007 +0200

    [ALSA] Clean up with common snd_ctl_boolean_*_info callbacks
    
    Clean up codes using the new common snd_ctl_boolean_*_info() callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 7ca606272460..00e4004d5638 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -2317,15 +2317,7 @@ int __devinit snd_trident_spdif_pcm(struct snd_trident * trident,
     Description: enable/disable S/PDIF out from ac97 mixer
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_spdif_control_info(struct snd_kcontrol *kcontrol,
-					  struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_trident_spdif_control_info	snd_ctl_boolean_mono_info
 
 static int snd_trident_spdif_control_get(struct snd_kcontrol *kcontrol,
 					 struct snd_ctl_elem_value *ucontrol)
@@ -2545,15 +2537,7 @@ static struct snd_kcontrol_new snd_trident_spdif_stream __devinitdata =
     Description: enable/disable rear path for ac97
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_ac97_control_info(struct snd_kcontrol *kcontrol,
-					 struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_trident_ac97_control_info	snd_ctl_boolean_mono_info
 
 static int snd_trident_ac97_control_get(struct snd_kcontrol *kcontrol,
 					struct snd_ctl_elem_value *ucontrol)

commit ef991b95aa1351a5782cfaccb9aefba76ca8b990
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 22 12:52:53 2007 +0100

    [ALSA] Add snd_pcm_group_for_each_entry() for code cleanup
    
    Added a new macro snd_pcm_group_for_each_entry() just for code cleanup.
    Old macros, snd_pcm_group_for_each() and snd_pcm_group_substream_entry(),
    are removed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 3bff32167f66..7ca606272460 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -1540,7 +1540,6 @@ static int snd_trident_trigger(struct snd_pcm_substream *substream,
 				    
 {
 	struct snd_trident *trident = snd_pcm_substream_chip(substream);
-	struct list_head *pos;
 	struct snd_pcm_substream *s;
 	unsigned int what, whati, capture_flag, spdif_flag;
 	struct snd_trident_voice *voice, *evoice;
@@ -1563,8 +1562,7 @@ static int snd_trident_trigger(struct snd_pcm_substream *substream,
 	what = whati = capture_flag = spdif_flag = 0;
 	spin_lock(&trident->reg_lock);
 	val = inl(TRID_REG(trident, T4D_STIMER)) & 0x00ffffff;
-	snd_pcm_group_for_each(pos, substream) {
-		s = snd_pcm_group_substream_entry(pos);
+	snd_pcm_group_for_each_entry(s, substream) {
 		if ((struct snd_trident *) snd_pcm_substream_chip(s) == trident) {
 			voice = s->runtime->private_data;
 			evoice = voice->extra;

commit 0cb29ea0d449d7c0ecc9649a08ab63476389701d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 29 15:33:49 2007 +0100

    [ALSA] Add even more 'const' to everything related to TLV
    
    Mark TLV data as 'const'
    Signed-of-by: Philipp Matthias Hahn <pmhahn@pmhahn.de>
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 474f2d451ae8..3bff32167f66 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -2627,7 +2627,7 @@ static int snd_trident_vol_control_get(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static DECLARE_TLV_DB_SCALE(db_scale_gvol, -6375, 25, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_gvol, -6375, 25, 0);
 
 static int snd_trident_vol_control_put(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_value *ucontrol)
@@ -2844,7 +2844,7 @@ static int snd_trident_pcm_rvol_control_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static DECLARE_TLV_DB_SCALE(db_scale_crvol, -3175, 25, 1);
+static const DECLARE_TLV_DB_SCALE(db_scale_crvol, -3175, 25, 1);
 
 static struct snd_kcontrol_new snd_trident_pcm_rvol_control __devinitdata =
 {

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 89fe5760df36..474f2d451ae8 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3608,7 +3608,7 @@ int __devinit snd_trident_create(struct snd_card *card,
 	}
 	trident->port = pci_resource_start(pci, 0);
 
-	if (request_irq(pci->irq, snd_trident_interrupt, IRQF_DISABLED|IRQF_SHARED,
+	if (request_irq(pci->irq, snd_trident_interrupt, IRQF_SHARED,
 			"Trident Audio", trident)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_trident_free(trident);

commit 7ab399262ee636d19db5163a35ac406d5b892a0a
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Oct 9 08:13:32 2006 +0200

    [ALSA] use the ALIGN macro
    
    Use the ALIGN macro instead of manual calculations.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 1fbc4321122f..89fe5760df36 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3380,8 +3380,8 @@ static int __devinit snd_trident_tlb_alloc(struct snd_trident *trident)
 		snd_printk(KERN_ERR "trident: unable to allocate TLB buffer\n");
 		return -ENOMEM;
 	}
-	trident->tlb.entries = (unsigned int*)(((unsigned long)trident->tlb.buffer.area + SNDRV_TRIDENT_MAX_PAGES * 4 - 1) & ~(SNDRV_TRIDENT_MAX_PAGES * 4 - 1));
-	trident->tlb.entries_dmaaddr = (trident->tlb.buffer.addr + SNDRV_TRIDENT_MAX_PAGES * 4 - 1) & ~(SNDRV_TRIDENT_MAX_PAGES * 4 - 1);
+	trident->tlb.entries = (unsigned int*)ALIGN((unsigned long)trident->tlb.buffer.area, SNDRV_TRIDENT_MAX_PAGES * 4);
+	trident->tlb.entries_dmaaddr = ALIGN(trident->tlb.buffer.addr, SNDRV_TRIDENT_MAX_PAGES * 4);
 	/* allocate shadow TLB page table (virtual addresses) */
 	trident->tlb.shadow_entries = vmalloc(SNDRV_TRIDENT_MAX_PAGES*sizeof(unsigned long));
 	if (trident->tlb.shadow_entries == NULL) {

commit 30b35399ceb2398d05837863476dcb12f12f3a82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 11 18:52:53 2006 +0200

    [ALSA] Various fixes for suspend/resume of ALSA PCI drivers
    
    - Check the return value of pci_enable_device() and request_irq()
      in the suspend.  If any error occurs there, disable the device
      using snd_card_disconnect().
    - Call pci_set_power_state() properly with pci_choose_state().
    - Fix the order to call pci_set_power_state().
    - Removed obsolete house-made PM codes in some drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 0d478871808d..1fbc4321122f 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3966,15 +3966,9 @@ int snd_trident_suspend(struct pci_dev *pci, pm_message_t state)
 	snd_ac97_suspend(trident->ac97);
 	snd_ac97_suspend(trident->ac97_sec);
 
-	switch (trident->device) {
-	case TRIDENT_DEVICE_ID_DX:
-	case TRIDENT_DEVICE_ID_NX:
-		break;			/* TODO */
-	case TRIDENT_DEVICE_ID_SI7018:
-		break;
-	}
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -3983,9 +3977,15 @@ int snd_trident_resume(struct pci_dev *pci)
 	struct snd_card *card = pci_get_drvdata(pci);
 	struct snd_trident *trident = card->private_data;
 
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
-	pci_set_master(pci); /* to be sure */
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "trident: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
+	pci_set_master(pci);
 
 	switch (trident->device) {
 	case TRIDENT_DEVICE_ID_DX:

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index ebbe12d78d8c..0d478871808d 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -52,8 +52,7 @@ static int snd_trident_pcm_mixer_build(struct snd_trident *trident,
 static int snd_trident_pcm_mixer_free(struct snd_trident *trident,
 				      struct snd_trident_voice * voice,
 				      struct snd_pcm_substream *substream);
-static irqreturn_t snd_trident_interrupt(int irq, void *dev_id,
-					 struct pt_regs *regs);
+static irqreturn_t snd_trident_interrupt(int irq, void *dev_id);
 static int snd_trident_sis_reset(struct snd_trident *trident);
 
 static void snd_trident_clear_voices(struct snd_trident * trident,
@@ -3737,7 +3736,7 @@ static int snd_trident_free(struct snd_trident *trident)
   
   ---------------------------------------------------------------------------*/
 
-static irqreturn_t snd_trident_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_trident_interrupt(int irq, void *dev_id)
 {
 	struct snd_trident *trident = dev_id;
 	unsigned int audio_int, chn_int, stimer, channel, mask, tmp;
@@ -3825,7 +3824,7 @@ static irqreturn_t snd_trident_interrupt(int irq, void *dev_id, struct pt_regs *
 	}
 	if (audio_int & MPU401_IRQ) {
 		if (trident->rmidi) {
-			snd_mpu401_uart_interrupt(irq, trident->rmidi->private_data, regs);
+			snd_mpu401_uart_interrupt(irq, trident->rmidi->private_data);
 		} else {
 			inb(TRID_REG(trident, T4D_MPUR0));
 		}

commit a0aef8edfc9d6d682dba557fe42599297cbc329a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 23 13:01:37 2006 +0200

    [ALSA] Add dB scale information to trident driver
    
    Added the dB scale information to trident driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 4930cc6b054d..ebbe12d78d8c 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -40,6 +40,7 @@
 #include <sound/core.h>
 #include <sound/info.h>
 #include <sound/control.h>
+#include <sound/tlv.h>
 #include <sound/trident.h>
 #include <sound/asoundef.h>
 
@@ -2627,6 +2628,8 @@ static int snd_trident_vol_control_get(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+static DECLARE_TLV_DB_SCALE(db_scale_gvol, -6375, 25, 0);
+
 static int snd_trident_vol_control_put(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_value *ucontrol)
 {
@@ -2653,6 +2656,7 @@ static struct snd_kcontrol_new snd_trident_vol_music_control __devinitdata =
 	.get =		snd_trident_vol_control_get,
 	.put =		snd_trident_vol_control_put,
 	.private_value = 16,
+	.tlv = { .p = db_scale_gvol },
 };
 
 static struct snd_kcontrol_new snd_trident_vol_wave_control __devinitdata =
@@ -2663,6 +2667,7 @@ static struct snd_kcontrol_new snd_trident_vol_wave_control __devinitdata =
 	.get =		snd_trident_vol_control_get,
 	.put =		snd_trident_vol_control_put,
 	.private_value = 0,
+	.tlv = { .p = db_scale_gvol },
 };
 
 /*---------------------------------------------------------------------------
@@ -2730,6 +2735,7 @@ static struct snd_kcontrol_new snd_trident_pcm_vol_control __devinitdata =
 	.info =		snd_trident_pcm_vol_control_info,
 	.get =		snd_trident_pcm_vol_control_get,
 	.put =		snd_trident_pcm_vol_control_put,
+	/* FIXME: no tlv yet */
 };
 
 /*---------------------------------------------------------------------------
@@ -2839,6 +2845,8 @@ static int snd_trident_pcm_rvol_control_put(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
+static DECLARE_TLV_DB_SCALE(db_scale_crvol, -3175, 25, 1);
+
 static struct snd_kcontrol_new snd_trident_pcm_rvol_control __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -2848,6 +2856,7 @@ static struct snd_kcontrol_new snd_trident_pcm_rvol_control __devinitdata =
 	.info =		snd_trident_pcm_rvol_control_info,
 	.get =		snd_trident_pcm_rvol_control_get,
 	.put =		snd_trident_pcm_rvol_control_put,
+	.tlv = { .p = db_scale_crvol },
 };
 
 /*---------------------------------------------------------------------------
@@ -2903,6 +2912,7 @@ static struct snd_kcontrol_new snd_trident_pcm_cvol_control __devinitdata =
 	.info =		snd_trident_pcm_cvol_control_info,
 	.get =		snd_trident_pcm_cvol_control_get,
 	.put =		snd_trident_pcm_cvol_control_put,
+	.tlv = { .p = db_scale_crvol },
 };
 
 static void snd_trident_notify_pcm_change1(struct snd_card *card,

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index d99ed7237750..4930cc6b054d 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3599,7 +3599,7 @@ int __devinit snd_trident_create(struct snd_card *card,
 	}
 	trident->port = pci_resource_start(pci, 0);
 
-	if (request_irq(pci->irq, snd_trident_interrupt, SA_INTERRUPT|SA_SHIRQ,
+	if (request_irq(pci->irq, snd_trident_interrupt, IRQF_DISABLED|IRQF_SHARED,
 			"Trident Audio", trident)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_trident_free(trident);

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 850579208e49..d99ed7237750 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3338,7 +3338,7 @@ static void __devinit snd_trident_proc_init(struct snd_trident * trident)
 	if (trident->device == TRIDENT_DEVICE_ID_SI7018)
 		s = "sis7018";
 	if (! snd_card_proc_new(trident->card, s, &entry))
-		snd_info_set_text_ops(entry, trident, 1024, snd_trident_proc_read);
+		snd_info_set_text_ops(entry, trident, snd_trident_proc_read);
 }
 
 static int snd_trident_dev_free(struct snd_device *device)

commit cbef55f3d8e4e7efef4703c82302a0021d781483
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:40 2006 +0200

    [ALSA] trident - Move EXPORT_SYMBOL() to adjacent to each function
    
    Move EXPORT_SYMBOL() to adjacent to each exported function/variable.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 52178b8ad49d..850579208e49 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -306,6 +306,8 @@ void snd_trident_start_voice(struct snd_trident * trident, unsigned int voice)
 	outl(mask, TRID_REG(trident, reg));
 }
 
+EXPORT_SYMBOL(snd_trident_start_voice);
+
 /*---------------------------------------------------------------------------
    void snd_trident_stop_voice(struct snd_trident * trident, unsigned int voice)
 
@@ -328,6 +330,8 @@ void snd_trident_stop_voice(struct snd_trident * trident, unsigned int voice)
 	outl(mask, TRID_REG(trident, reg));
 }
 
+EXPORT_SYMBOL(snd_trident_stop_voice);
+
 /*---------------------------------------------------------------------------
     int snd_trident_allocate_pcm_channel(struct snd_trident *trident)
   
@@ -502,6 +506,8 @@ void snd_trident_write_voice_regs(struct snd_trident * trident,
 #endif
 }
 
+EXPORT_SYMBOL(snd_trident_write_voice_regs);
+
 /*---------------------------------------------------------------------------
    snd_trident_write_cso_reg
   
@@ -3884,6 +3890,8 @@ struct snd_trident_voice *snd_trident_alloc_voice(struct snd_trident * trident,
 	return NULL;
 }
 
+EXPORT_SYMBOL(snd_trident_alloc_voice);
+
 void snd_trident_free_voice(struct snd_trident * trident, struct snd_trident_voice *voice)
 {
 	unsigned long flags;
@@ -3912,6 +3920,8 @@ void snd_trident_free_voice(struct snd_trident * trident, struct snd_trident_voi
 		private_free(voice);
 }
 
+EXPORT_SYMBOL(snd_trident_free_voice);
+
 static void snd_trident_clear_voices(struct snd_trident * trident, unsigned short v_min, unsigned short v_max)
 {
 	unsigned int i, val, mask[2] = { 0, 0 };
@@ -3993,13 +4003,3 @@ int snd_trident_resume(struct pci_dev *pci)
 	return 0;
 }
 #endif /* CONFIG_PM */
-
-EXPORT_SYMBOL(snd_trident_alloc_voice);
-EXPORT_SYMBOL(snd_trident_free_voice);
-EXPORT_SYMBOL(snd_trident_start_voice);
-EXPORT_SYMBOL(snd_trident_stop_voice);
-EXPORT_SYMBOL(snd_trident_write_voice_regs);
-/* trident_memory.c symbols */
-EXPORT_SYMBOL(snd_trident_synth_alloc);
-EXPORT_SYMBOL(snd_trident_synth_free);
-EXPORT_SYMBOL(snd_trident_synth_copy_from_user);

commit 910638ae7ed4be27d6af55f6c9b5bf54b838e78b
Author: Matthias Gehre <M.Gehre@gmx.de>
Date:   Tue Mar 28 01:56:48 2006 -0800

    [PATCH] Replace 0xff.. with correct DMA_xBIT_MASK
    
    Replace all occurences of 0xff..  in calls to function pci_set_dma_mask()
    and pci_set_consistant_dma_mask() with the corresponding DMA_xBIT_MASK from
    linux/dma-mapping.h.
    
    Signed-off-by: Matthias Gehre <M.Gehre@gmx.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 83b7d8aba9e6..52178b8ad49d 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -35,6 +35,7 @@
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/gameport.h>
+#include <linux/dma-mapping.h>
 
 #include <sound/core.h>
 #include <sound/info.h>
@@ -3554,8 +3555,8 @@ int __devinit snd_trident_create(struct snd_card *card,
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 	/* check, if we can restrict PCI DMA transfers to 30 bits */
-	if (pci_set_dma_mask(pci, 0x3fffffff) < 0 ||
-	    pci_set_consistent_dma_mask(pci, 0x3fffffff) < 0) {
+	if (pci_set_dma_mask(pci, DMA_30BIT_MASK) < 0 ||
+	    pci_set_consistent_dma_mask(pci, DMA_30BIT_MASK) < 0) {
 		snd_printk(KERN_ERR "architecture does not support 30bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;

commit fb0700b4debbf45fb0465b40188bdc5396947bda
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 16:09:25 2005 +0100

    [ALSA] trident - Fix PM support
    
    Modules: Trident driver
    
    Fix PM support on Trident driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 6277dccebf64..83b7d8aba9e6 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -52,10 +52,6 @@ static int snd_trident_pcm_mixer_free(struct snd_trident *trident,
 				      struct snd_pcm_substream *substream);
 static irqreturn_t snd_trident_interrupt(int irq, void *dev_id,
 					 struct pt_regs *regs);
-#ifdef CONFIG_PM
-static int snd_trident_suspend(struct snd_card *card, pm_message_t state);
-static int snd_trident_resume(struct snd_card *card);
-#endif
 static int snd_trident_sis_reset(struct snd_trident *trident);
 
 static void snd_trident_clear_voices(struct snd_trident * trident,
@@ -3661,8 +3657,6 @@ int __devinit snd_trident_create(struct snd_card *card,
 
 	snd_trident_enable_eso(trident);
 
-	
-	snd_card_set_pm_callback(card, snd_trident_suspend, snd_trident_resume, trident);
 	snd_trident_proc_init(trident);
 	snd_card_set_dev(card, &pci->dev);
 	*rtrident = trident;
@@ -3938,20 +3932,19 @@ static void snd_trident_clear_voices(struct snd_trident * trident, unsigned shor
 }
 
 #ifdef CONFIG_PM
-static int snd_trident_suspend(struct snd_card *card, pm_message_t state)
+int snd_trident_suspend(struct pci_dev *pci, pm_message_t state)
 {
-	struct snd_trident *trident = card->pm_private_data;
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct snd_trident *trident = card->private_data;
 
 	trident->in_suspend = 1;
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	snd_pcm_suspend_all(trident->pcm);
-	if (trident->foldback)
-		snd_pcm_suspend_all(trident->foldback);
-	if (trident->spdif)
-		snd_pcm_suspend_all(trident->spdif);
+	snd_pcm_suspend_all(trident->foldback);
+	snd_pcm_suspend_all(trident->spdif);
 
 	snd_ac97_suspend(trident->ac97);
-	if (trident->ac97_sec)
-		snd_ac97_suspend(trident->ac97_sec);
+	snd_ac97_suspend(trident->ac97_sec);
 
 	switch (trident->device) {
 	case TRIDENT_DEVICE_ID_DX:
@@ -3960,19 +3953,19 @@ static int snd_trident_suspend(struct snd_card *card, pm_message_t state)
 	case TRIDENT_DEVICE_ID_SI7018:
 		break;
 	}
-	pci_disable_device(trident->pci);
+	pci_disable_device(pci);
+	pci_save_state(pci);
 	return 0;
 }
 
-static int snd_trident_resume(struct snd_card *card)
+int snd_trident_resume(struct pci_dev *pci)
 {
-	struct snd_trident *trident = card->pm_private_data;
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct snd_trident *trident = card->private_data;
 
-	pci_enable_device(trident->pci);
-	if (pci_set_dma_mask(trident->pci, 0x3fffffff) < 0 ||
-	    pci_set_consistent_dma_mask(trident->pci, 0x3fffffff) < 0)
-		snd_printk(KERN_WARNING "trident: can't set the proper DMA mask\n");
-	pci_set_master(trident->pci); /* to be sure */
+	pci_restore_state(pci);
+	pci_enable_device(pci);
+	pci_set_master(pci); /* to be sure */
 
 	switch (trident->device) {
 	case TRIDENT_DEVICE_ID_DX:
@@ -3987,14 +3980,14 @@ static int snd_trident_resume(struct snd_card *card)
 	}
 
 	snd_ac97_resume(trident->ac97);
-	if (trident->ac97_sec)
-		snd_ac97_resume(trident->ac97_sec);
+	snd_ac97_resume(trident->ac97_sec);
 
 	/* restore some registers */
 	outl(trident->musicvol_wavevol, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));
 
 	snd_trident_enable_eso(trident);
 
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	trident->in_suspend = 0;
 	return 0;
 }

commit bee1a5be8b6210a0a4e27e38d0f76847b0a014ae
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:53:15 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI Trident
    
    Modules: Trident driver
    
    Remove xxx_t typedefs from the PCI Trident driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 62f109f020a5..6277dccebf64 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -44,17 +44,23 @@
 
 #include <asm/io.h>
 
-static int snd_trident_pcm_mixer_build(trident_t *trident, snd_trident_voice_t * voice, snd_pcm_substream_t *substream);
-static int snd_trident_pcm_mixer_free(trident_t *trident, snd_trident_voice_t * voice, snd_pcm_substream_t *substream);
-static irqreturn_t snd_trident_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+static int snd_trident_pcm_mixer_build(struct snd_trident *trident,
+				       struct snd_trident_voice * voice,
+				       struct snd_pcm_substream *substream);
+static int snd_trident_pcm_mixer_free(struct snd_trident *trident,
+				      struct snd_trident_voice * voice,
+				      struct snd_pcm_substream *substream);
+static irqreturn_t snd_trident_interrupt(int irq, void *dev_id,
+					 struct pt_regs *regs);
 #ifdef CONFIG_PM
-static int snd_trident_suspend(snd_card_t *card, pm_message_t state);
-static int snd_trident_resume(snd_card_t *card);
+static int snd_trident_suspend(struct snd_card *card, pm_message_t state);
+static int snd_trident_resume(struct snd_card *card);
 #endif
-static int snd_trident_sis_reset(trident_t *trident);
+static int snd_trident_sis_reset(struct snd_trident *trident);
 
-static void snd_trident_clear_voices(trident_t * trident, unsigned short v_min, unsigned short v_max);
-static int snd_trident_free(trident_t *trident);
+static void snd_trident_clear_voices(struct snd_trident * trident,
+				     unsigned short v_min, unsigned short v_max);
+static int snd_trident_free(struct snd_trident *trident);
 
 /*
  *  common I/O routines
@@ -62,7 +68,7 @@ static int snd_trident_free(trident_t *trident);
 
 
 #if 0
-static void snd_trident_print_voice_regs(trident_t *trident, int voice)
+static void snd_trident_print_voice_regs(struct snd_trident *trident, int voice)
 {
 	unsigned int val, tmp;
 
@@ -104,7 +110,7 @@ static void snd_trident_print_voice_regs(trident_t *trident, int voice)
 #endif
 
 /*---------------------------------------------------------------------------
-   unsigned short snd_trident_codec_read(ac97_t *ac97, unsigned short reg)
+   unsigned short snd_trident_codec_read(struct snd_ac97 *ac97, unsigned short reg)
   
    Description: This routine will do all of the reading from the external
                 CODEC (AC97).
@@ -115,12 +121,12 @@ static void snd_trident_print_voice_regs(trident_t *trident, int voice)
    returns:     16 bit value read from the AC97.
   
   ---------------------------------------------------------------------------*/
-static unsigned short snd_trident_codec_read(ac97_t *ac97, unsigned short reg)
+static unsigned short snd_trident_codec_read(struct snd_ac97 *ac97, unsigned short reg)
 {
 	unsigned int data = 0, treg;
 	unsigned short count = 0xffff;
 	unsigned long flags;
-	trident_t *trident = ac97->private_data;
+	struct snd_trident *trident = ac97->private_data;
 
 	spin_lock_irqsave(&trident->reg_lock, flags);
 	if (trident->device == TRIDENT_DEVICE_ID_DX) {
@@ -153,7 +159,8 @@ static unsigned short snd_trident_codec_read(ac97_t *ac97, unsigned short reg)
 	}
 
 	if (count == 0 && !trident->ac97_detect) {
-		snd_printk(KERN_ERR "ac97 codec read TIMEOUT [0x%x/0x%x]!!!\n", reg, data);
+		snd_printk(KERN_ERR "ac97 codec read TIMEOUT [0x%x/0x%x]!!!\n",
+			   reg, data);
 		data = 0;
 	}
 
@@ -162,7 +169,8 @@ static unsigned short snd_trident_codec_read(ac97_t *ac97, unsigned short reg)
 }
 
 /*---------------------------------------------------------------------------
-   void snd_trident_codec_write(ac97_t *ac97, unsigned short reg, unsigned short wdata)
+   void snd_trident_codec_write(struct snd_ac97 *ac97, unsigned short reg,
+   unsigned short wdata)
   
    Description: This routine will do all of the writing to the external
                 CODEC (AC97).
@@ -174,12 +182,13 @@ static unsigned short snd_trident_codec_read(ac97_t *ac97, unsigned short reg)
    returns:     TRUE if everything went ok, else FALSE.
   
   ---------------------------------------------------------------------------*/
-static void snd_trident_codec_write(ac97_t *ac97, unsigned short reg, unsigned short wdata)
+static void snd_trident_codec_write(struct snd_ac97 *ac97, unsigned short reg,
+				    unsigned short wdata)
 {
 	unsigned int address, data;
 	unsigned short count = 0xffff;
 	unsigned long flags;
-	trident_t *trident = ac97->private_data;
+	struct snd_trident *trident = ac97->private_data;
 
 	data = ((unsigned long) wdata) << 16;
 
@@ -230,7 +239,7 @@ static void snd_trident_codec_write(ac97_t *ac97, unsigned short reg, unsigned s
 }
 
 /*---------------------------------------------------------------------------
-   void snd_trident_enable_eso(trident_t *trident)
+   void snd_trident_enable_eso(struct snd_trident *trident)
   
    Description: This routine will enable end of loop interrupts.
                 End of loop interrupts will occur when a running
@@ -241,7 +250,7 @@ static void snd_trident_codec_write(ac97_t *ac97, unsigned short reg, unsigned s
   
   ---------------------------------------------------------------------------*/
 
-static void snd_trident_enable_eso(trident_t * trident)
+static void snd_trident_enable_eso(struct snd_trident * trident)
 {
 	unsigned int val;
 
@@ -254,7 +263,7 @@ static void snd_trident_enable_eso(trident_t * trident)
 }
 
 /*---------------------------------------------------------------------------
-   void snd_trident_disable_eso(trident_t *trident)
+   void snd_trident_disable_eso(struct snd_trident *trident)
   
    Description: This routine will disable end of loop interrupts.
                 End of loop interrupts will occur when a running
@@ -268,7 +277,7 @@ static void snd_trident_enable_eso(trident_t * trident)
   
   ---------------------------------------------------------------------------*/
 
-static void snd_trident_disable_eso(trident_t * trident)
+static void snd_trident_disable_eso(struct snd_trident * trident)
 {
 	unsigned int tmp;
 
@@ -279,7 +288,7 @@ static void snd_trident_disable_eso(trident_t * trident)
 }
 
 /*---------------------------------------------------------------------------
-   void snd_trident_start_voice(trident_t * trident, unsigned int voice)
+   void snd_trident_start_voice(struct snd_trident * trident, unsigned int voice)
 
     Description: Start a voice, any channel 0 thru 63.
                  This routine automatically handles the fact that there are
@@ -292,7 +301,7 @@ static void snd_trident_disable_eso(trident_t * trident)
 
   ---------------------------------------------------------------------------*/
 
-void snd_trident_start_voice(trident_t * trident, unsigned int voice)
+void snd_trident_start_voice(struct snd_trident * trident, unsigned int voice)
 {
 	unsigned int mask = 1 << (voice & 0x1f);
 	unsigned int reg = (voice & 0x20) ? T4D_START_B : T4D_START_A;
@@ -301,7 +310,7 @@ void snd_trident_start_voice(trident_t * trident, unsigned int voice)
 }
 
 /*---------------------------------------------------------------------------
-   void snd_trident_stop_voice(trident_t * trident, unsigned int voice)
+   void snd_trident_stop_voice(struct snd_trident * trident, unsigned int voice)
 
     Description: Stop a voice, any channel 0 thru 63.
                  This routine automatically handles the fact that there are
@@ -314,7 +323,7 @@ void snd_trident_start_voice(trident_t * trident, unsigned int voice)
 
   ---------------------------------------------------------------------------*/
 
-void snd_trident_stop_voice(trident_t * trident, unsigned int voice)
+void snd_trident_stop_voice(struct snd_trident * trident, unsigned int voice)
 {
 	unsigned int mask = 1 << (voice & 0x1f);
 	unsigned int reg = (voice & 0x20) ? T4D_STOP_B : T4D_STOP_A;
@@ -323,7 +332,7 @@ void snd_trident_stop_voice(trident_t * trident, unsigned int voice)
 }
 
 /*---------------------------------------------------------------------------
-    int snd_trident_allocate_pcm_channel(trident_t *trident)
+    int snd_trident_allocate_pcm_channel(struct snd_trident *trident)
   
     Description: Allocate hardware channel in Bank B (32-63).
   
@@ -333,7 +342,7 @@ void snd_trident_stop_voice(trident_t * trident, unsigned int voice)
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_allocate_pcm_channel(trident_t * trident)
+static int snd_trident_allocate_pcm_channel(struct snd_trident * trident)
 {
 	int idx;
 
@@ -361,7 +370,7 @@ static int snd_trident_allocate_pcm_channel(trident_t * trident)
   
   ---------------------------------------------------------------------------*/
 
-static void snd_trident_free_pcm_channel(trident_t *trident, int channel)
+static void snd_trident_free_pcm_channel(struct snd_trident *trident, int channel)
 {
 	if (channel < 32 || channel > 63)
 		return;
@@ -383,7 +392,7 @@ static void snd_trident_free_pcm_channel(trident_t *trident, int channel)
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_allocate_synth_channel(trident_t * trident)
+static int snd_trident_allocate_synth_channel(struct snd_trident * trident)
 {
 	int idx;
 
@@ -409,7 +418,7 @@ static int snd_trident_allocate_synth_channel(trident_t * trident)
   
   ---------------------------------------------------------------------------*/
 
-static void snd_trident_free_synth_channel(trident_t *trident, int channel)
+static void snd_trident_free_synth_channel(struct snd_trident *trident, int channel)
 {
 	if (channel < 0 || channel > 31)
 		return;
@@ -432,8 +441,8 @@ static void snd_trident_free_synth_channel(trident_t *trident, int channel)
   
   ---------------------------------------------------------------------------*/
 
-void snd_trident_write_voice_regs(trident_t * trident,
-				  snd_trident_voice_t * voice)
+void snd_trident_write_voice_regs(struct snd_trident * trident,
+				  struct snd_trident_voice * voice)
 {
 	unsigned int FmcRvolCvol;
 	unsigned int regs[5];
@@ -452,14 +461,16 @@ void snd_trident_write_voice_regs(trident_t * trident,
 				(voice->Vol & 0x000003ff) :
 				((voice->Vol & 0x00003fc) << (16-2)) |
 				(voice->EC & 0x00000fff);
-		regs[0] = (voice->CSO << 16) | ((voice->Alpha & 0x00000fff) << 4) | (voice->FMS & 0x0000000f);
+		regs[0] = (voice->CSO << 16) | ((voice->Alpha & 0x00000fff) << 4) |
+			(voice->FMS & 0x0000000f);
 		regs[2] = (voice->ESO << 16) | (voice->Delta & 0x0ffff);
 		regs[3] = (voice->Attribute << 16) | FmcRvolCvol;
 		break;
 	case TRIDENT_DEVICE_ID_DX:
 		regs[4] |= ((voice->Vol & 0x000003fc) << (16-2)) |
 			   (voice->EC & 0x00000fff);
-		regs[0] = (voice->CSO << 16) | ((voice->Alpha & 0x00000fff) << 4) | (voice->FMS & 0x0000000f);
+		regs[0] = (voice->CSO << 16) | ((voice->Alpha & 0x00000fff) << 4) |
+			(voice->FMS & 0x0000000f);
 		regs[2] = (voice->ESO << 16) | (voice->Delta & 0x0ffff);
 		regs[3] = FmcRvolCvol;
 		break;
@@ -467,8 +478,10 @@ void snd_trident_write_voice_regs(trident_t * trident,
 		regs[4] |= ((voice->Vol & 0x000003fc) << (16-2)) |
 			   (voice->EC & 0x00000fff);
 		regs[0] = (voice->Delta << 24) | (voice->CSO & 0x00ffffff);
-		regs[2] = ((voice->Delta << 16) & 0xff000000) | (voice->ESO & 0x00ffffff);
-		regs[3] = (voice->Alpha << 20) | ((voice->FMS & 0x0000000f) << 16) | FmcRvolCvol;
+		regs[2] = ((voice->Delta << 16) & 0xff000000) |
+			(voice->ESO & 0x00ffffff);
+		regs[3] = (voice->Alpha << 20) |
+			((voice->FMS & 0x0000000f) << 16) | FmcRvolCvol;
 		break;
 	default:
 		snd_BUG();
@@ -504,14 +517,17 @@ void snd_trident_write_voice_regs(trident_t * trident,
   
   ---------------------------------------------------------------------------*/
 
-static void snd_trident_write_cso_reg(trident_t * trident, snd_trident_voice_t * voice, unsigned int CSO)
+static void snd_trident_write_cso_reg(struct snd_trident * trident,
+				      struct snd_trident_voice * voice,
+				      unsigned int CSO)
 {
 	voice->CSO = CSO;
 	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));
 	if (trident->device != TRIDENT_DEVICE_ID_NX) {
 		outw(voice->CSO, TRID_REG(trident, CH_DX_CSO_ALPHA_FMS) + 2);
 	} else {
-		outl((voice->Delta << 24) | (voice->CSO & 0x00ffffff), TRID_REG(trident, CH_NX_DELTA_CSO));
+		outl((voice->Delta << 24) |
+		     (voice->CSO & 0x00ffffff), TRID_REG(trident, CH_NX_DELTA_CSO));
 	}
 }
 
@@ -527,14 +543,17 @@ static void snd_trident_write_cso_reg(trident_t * trident, snd_trident_voice_t *
   
   ---------------------------------------------------------------------------*/
 
-static void snd_trident_write_eso_reg(trident_t * trident, snd_trident_voice_t * voice, unsigned int ESO)
+static void snd_trident_write_eso_reg(struct snd_trident * trident,
+				      struct snd_trident_voice * voice,
+				      unsigned int ESO)
 {
 	voice->ESO = ESO;
 	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));
 	if (trident->device != TRIDENT_DEVICE_ID_NX) {
 		outw(voice->ESO, TRID_REG(trident, CH_DX_ESO_DELTA) + 2);
 	} else {
-		outl(((voice->Delta << 16) & 0xff000000) | (voice->ESO & 0x00ffffff), TRID_REG(trident, CH_NX_DELTA_ESO));
+		outl(((voice->Delta << 16) & 0xff000000) | (voice->ESO & 0x00ffffff),
+		     TRID_REG(trident, CH_NX_DELTA_ESO));
 	}
 }
 
@@ -550,7 +569,9 @@ static void snd_trident_write_eso_reg(trident_t * trident, snd_trident_voice_t *
   
   ---------------------------------------------------------------------------*/
 
-static void snd_trident_write_vol_reg(trident_t * trident, snd_trident_voice_t * voice, unsigned int Vol)
+static void snd_trident_write_vol_reg(struct snd_trident * trident,
+				      struct snd_trident_voice * voice,
+				      unsigned int Vol)
 {
 	voice->Vol = Vol;
 	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));
@@ -561,7 +582,8 @@ static void snd_trident_write_vol_reg(trident_t * trident, snd_trident_voice_t *
 		break;
 	case TRIDENT_DEVICE_ID_SI7018:
 		// printk("voice->Vol = 0x%x\n", voice->Vol);
-		outw((voice->CTRL << 12) | voice->Vol, TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC));
+		outw((voice->CTRL << 12) | voice->Vol,
+		     TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC));
 		break;
 	}
 }
@@ -578,11 +600,14 @@ static void snd_trident_write_vol_reg(trident_t * trident, snd_trident_voice_t *
   
   ---------------------------------------------------------------------------*/
 
-static void snd_trident_write_pan_reg(trident_t * trident, snd_trident_voice_t * voice, unsigned int Pan)
+static void snd_trident_write_pan_reg(struct snd_trident * trident,
+				      struct snd_trident_voice * voice,
+				      unsigned int Pan)
 {
 	voice->Pan = Pan;
 	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));
-	outb(((voice->GVSel & 0x01) << 7) | (voice->Pan & 0x7f), TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC + 3));
+	outb(((voice->GVSel & 0x01) << 7) | (voice->Pan & 0x7f),
+	     TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC + 3));
 }
 
 /*---------------------------------------------------------------------------
@@ -597,12 +622,16 @@ static void snd_trident_write_pan_reg(trident_t * trident, snd_trident_voice_t *
   
   ---------------------------------------------------------------------------*/
 
-static void snd_trident_write_rvol_reg(trident_t * trident, snd_trident_voice_t * voice, unsigned int RVol)
+static void snd_trident_write_rvol_reg(struct snd_trident * trident,
+				       struct snd_trident_voice * voice,
+				       unsigned int RVol)
 {
 	voice->RVol = RVol;
 	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));
-	outw(((voice->FMC & 0x0003) << 14) | ((voice->RVol & 0x007f) << 7) | (voice->CVol & 0x007f),
-	     TRID_REG(trident, trident->device == TRIDENT_DEVICE_ID_NX ? CH_NX_ALPHA_FMS_FMC_RVOL_CVOL : CH_DX_FMC_RVOL_CVOL));
+	outw(((voice->FMC & 0x0003) << 14) | ((voice->RVol & 0x007f) << 7) |
+	     (voice->CVol & 0x007f),
+	     TRID_REG(trident, trident->device == TRIDENT_DEVICE_ID_NX ?
+		      CH_NX_ALPHA_FMS_FMC_RVOL_CVOL : CH_DX_FMC_RVOL_CVOL));
 }
 
 /*---------------------------------------------------------------------------
@@ -617,12 +646,16 @@ static void snd_trident_write_rvol_reg(trident_t * trident, snd_trident_voice_t
   
   ---------------------------------------------------------------------------*/
 
-static void snd_trident_write_cvol_reg(trident_t * trident, snd_trident_voice_t * voice, unsigned int CVol)
+static void snd_trident_write_cvol_reg(struct snd_trident * trident,
+				       struct snd_trident_voice * voice,
+				       unsigned int CVol)
 {
 	voice->CVol = CVol;
 	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));
-	outw(((voice->FMC & 0x0003) << 14) | ((voice->RVol & 0x007f) << 7) | (voice->CVol & 0x007f),
-	     TRID_REG(trident, trident->device == TRIDENT_DEVICE_ID_NX ? CH_NX_ALPHA_FMS_FMC_RVOL_CVOL : CH_DX_FMC_RVOL_CVOL));
+	outw(((voice->FMC & 0x0003) << 14) | ((voice->RVol & 0x007f) << 7) |
+	     (voice->CVol & 0x007f),
+	     TRID_REG(trident, trident->device == TRIDENT_DEVICE_ID_NX ?
+		      CH_NX_ALPHA_FMS_FMC_RVOL_CVOL : CH_DX_FMC_RVOL_CVOL));
 }
 
 /*---------------------------------------------------------------------------
@@ -696,7 +729,8 @@ static unsigned int snd_trident_convert_adc_rate(unsigned int rate)
    Returns:     Delta value.
   
   ---------------------------------------------------------------------------*/
-static unsigned int snd_trident_spurious_threshold(unsigned int rate, unsigned int period_size)
+static unsigned int snd_trident_spurious_threshold(unsigned int rate,
+						   unsigned int period_size)
 {
 	unsigned int res = (rate * period_size) / 48000;
 	if (res < 64)
@@ -717,10 +751,10 @@ static unsigned int snd_trident_spurious_threshold(unsigned int rate, unsigned i
    Returns:     Control value.
   
   ---------------------------------------------------------------------------*/
-static unsigned int snd_trident_control_mode(snd_pcm_substream_t *substream)
+static unsigned int snd_trident_control_mode(struct snd_pcm_substream *substream)
 {
 	unsigned int CTRL;
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	/* set ctrl mode
 	   CTRL default: 8-bit (unsigned) mono, loop mode enabled
@@ -752,7 +786,7 @@ static unsigned int snd_trident_control_mode(snd_pcm_substream_t *substream)
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_ioctl(snd_pcm_substream_t * substream,
+static int snd_trident_ioctl(struct snd_pcm_substream *substream,
 			     unsigned int cmd,
 			     void *arg)
 {
@@ -774,12 +808,12 @@ static int snd_trident_ioctl(snd_pcm_substream_t * substream,
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_allocate_pcm_mem(snd_pcm_substream_t * substream,
-					snd_pcm_hw_params_t * hw_params)
+static int snd_trident_allocate_pcm_mem(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *hw_params)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_trident_voice *voice = runtime->private_data;
 	int err;
 
 	if ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)
@@ -808,13 +842,13 @@ static int snd_trident_allocate_pcm_mem(snd_pcm_substream_t * substream,
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_allocate_evoice(snd_pcm_substream_t * substream,
-				       snd_pcm_hw_params_t * hw_params)
+static int snd_trident_allocate_evoice(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *hw_params)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
-	snd_trident_voice_t *evoice = voice->extra;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_trident_voice *voice = runtime->private_data;
+	struct snd_trident_voice *evoice = voice->extra;
 
 	/* voice management */
 
@@ -848,8 +882,8 @@ static int snd_trident_allocate_evoice(snd_pcm_substream_t * substream,
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_hw_params(snd_pcm_substream_t * substream,
-				 snd_pcm_hw_params_t * hw_params)
+static int snd_trident_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *hw_params)
 {
 	int err;
 
@@ -870,12 +904,12 @@ static int snd_trident_hw_params(snd_pcm_substream_t * substream,
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_hw_free(snd_pcm_substream_t * substream)
+static int snd_trident_hw_free(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
-	snd_trident_voice_t *evoice = voice ? voice->extra : NULL;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_trident_voice *voice = runtime->private_data;
+	struct snd_trident_voice *evoice = voice ? voice->extra : NULL;
 
 	if (trident->tlb.entries) {
 		if (voice && voice->memblk) {
@@ -902,13 +936,13 @@ static int snd_trident_hw_free(snd_pcm_substream_t * substream)
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_playback_prepare(snd_pcm_substream_t * substream)
+static int snd_trident_playback_prepare(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
-	snd_trident_voice_t *evoice = voice->extra;
-	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[substream->number];
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_trident_voice *voice = runtime->private_data;
+	struct snd_trident_voice *evoice = voice->extra;
+	struct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[substream->number];
 
 	spin_lock_irq(&trident->reg_lock);	
 
@@ -988,8 +1022,8 @@ static int snd_trident_playback_prepare(snd_pcm_substream_t * substream)
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_capture_hw_params(snd_pcm_substream_t * substream,
-					 snd_pcm_hw_params_t * hw_params)
+static int snd_trident_capture_hw_params(struct snd_pcm_substream *substream,
+					 struct snd_pcm_hw_params *hw_params)
 {
 	return snd_trident_allocate_pcm_mem(substream, hw_params);
 }
@@ -1005,11 +1039,11 @@ static int snd_trident_capture_hw_params(snd_pcm_substream_t * substream,
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_capture_prepare(snd_pcm_substream_t * substream)
+static int snd_trident_capture_prepare(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_trident_voice *voice = runtime->private_data;
 	unsigned int val, ESO_bytes;
 
 	spin_lock_irq(&trident->reg_lock);
@@ -1097,8 +1131,8 @@ static int snd_trident_capture_prepare(snd_pcm_substream_t * substream)
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_si7018_capture_hw_params(snd_pcm_substream_t * substream,
-						snd_pcm_hw_params_t * hw_params)
+static int snd_trident_si7018_capture_hw_params(struct snd_pcm_substream *substream,
+						struct snd_pcm_hw_params *hw_params)
 {
 	int err;
 
@@ -1119,12 +1153,12 @@ static int snd_trident_si7018_capture_hw_params(snd_pcm_substream_t * substream,
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_si7018_capture_hw_free(snd_pcm_substream_t * substream)
+static int snd_trident_si7018_capture_hw_free(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
-	snd_trident_voice_t *evoice = voice ? voice->extra : NULL;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_trident_voice *voice = runtime->private_data;
+	struct snd_trident_voice *evoice = voice ? voice->extra : NULL;
 
 	snd_pcm_lib_free_pages(substream);
 	if (evoice != NULL) {
@@ -1145,12 +1179,12 @@ static int snd_trident_si7018_capture_hw_free(snd_pcm_substream_t * substream)
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_si7018_capture_prepare(snd_pcm_substream_t * substream)
+static int snd_trident_si7018_capture_prepare(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
-	snd_trident_voice_t *evoice = voice->extra;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_trident_voice *voice = runtime->private_data;
+	struct snd_trident_voice *evoice = voice->extra;
 
 	spin_lock_irq(&trident->reg_lock);
 
@@ -1216,12 +1250,12 @@ static int snd_trident_si7018_capture_prepare(snd_pcm_substream_t * substream)
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_foldback_prepare(snd_pcm_substream_t * substream)
+static int snd_trident_foldback_prepare(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
-	snd_trident_voice_t *evoice = voice->extra;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_trident_voice *voice = runtime->private_data;
+	struct snd_trident_voice *evoice = voice->extra;
 
 	spin_lock_irq(&trident->reg_lock);
 
@@ -1294,10 +1328,10 @@ static int snd_trident_foldback_prepare(snd_pcm_substream_t * substream)
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_spdif_hw_params(snd_pcm_substream_t * substream,
-				       snd_pcm_hw_params_t * hw_params)
+static int snd_trident_spdif_hw_params(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *hw_params)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
 	unsigned int old_bits = 0, change = 0;
 	int err;
 
@@ -1359,13 +1393,13 @@ static int snd_trident_spdif_hw_params(snd_pcm_substream_t * substream,
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_spdif_prepare(snd_pcm_substream_t * substream)
+static int snd_trident_spdif_prepare(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
-	snd_trident_voice_t *evoice = voice->extra;
-	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[substream->number];
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_trident_voice *voice = runtime->private_data;
+	struct snd_trident_voice *evoice = voice->extra;
+	struct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[substream->number];
 	unsigned int RESO, LBAO;
 	unsigned int temp;
 
@@ -1498,15 +1532,15 @@ static int snd_trident_spdif_prepare(snd_pcm_substream_t * substream)
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_trigger(snd_pcm_substream_t *substream,
+static int snd_trident_trigger(struct snd_pcm_substream *substream,
 			       int cmd)
 				    
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
 	struct list_head *pos;
-	snd_pcm_substream_t *s;
+	struct snd_pcm_substream *s;
 	unsigned int what, whati, capture_flag, spdif_flag;
-	snd_trident_voice_t *voice, *evoice;
+	struct snd_trident_voice *voice, *evoice;
 	unsigned int val, go;
 
 	switch (cmd) {
@@ -1528,8 +1562,8 @@ static int snd_trident_trigger(snd_pcm_substream_t *substream,
 	val = inl(TRID_REG(trident, T4D_STIMER)) & 0x00ffffff;
 	snd_pcm_group_for_each(pos, substream) {
 		s = snd_pcm_group_substream_entry(pos);
-		if ((trident_t *) snd_pcm_substream_chip(s) == trident) {
-			voice = (snd_trident_voice_t *) s->runtime->private_data;
+		if ((struct snd_trident *) snd_pcm_substream_chip(s) == trident) {
+			voice = s->runtime->private_data;
 			evoice = voice->extra;
 			what |= 1 << (voice->number & 0x1f);
 			if (evoice == NULL) {
@@ -1596,11 +1630,11 @@ static int snd_trident_trigger(snd_pcm_substream_t *substream,
   
   ---------------------------------------------------------------------------*/
 
-static snd_pcm_uframes_t snd_trident_playback_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_trident_playback_pointer(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_trident_voice *voice = runtime->private_data;
 	unsigned int cso;
 
 	if (!voice->running)
@@ -1635,11 +1669,11 @@ static snd_pcm_uframes_t snd_trident_playback_pointer(snd_pcm_substream_t * subs
   
   ---------------------------------------------------------------------------*/
 
-static snd_pcm_uframes_t snd_trident_capture_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_trident_capture_pointer(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_trident_voice *voice = runtime->private_data;
 	unsigned int result;
 
 	if (!voice->running)
@@ -1665,11 +1699,11 @@ static snd_pcm_uframes_t snd_trident_capture_pointer(snd_pcm_substream_t * subst
   
   ---------------------------------------------------------------------------*/
 
-static snd_pcm_uframes_t snd_trident_spdif_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_trident_spdif_pointer(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_trident_voice *voice = runtime->private_data;
 	unsigned int result;
 
 	if (!voice->running)
@@ -1684,7 +1718,7 @@ static snd_pcm_uframes_t snd_trident_spdif_pointer(snd_pcm_substream_t * substre
  *  Playback support device description
  */
 
-static snd_pcm_hardware_t snd_trident_playback =
+static struct snd_pcm_hardware snd_trident_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1709,7 +1743,7 @@ static snd_pcm_hardware_t snd_trident_playback =
  *  Capture support device description
  */
 
-static snd_pcm_hardware_t snd_trident_capture =
+static struct snd_pcm_hardware snd_trident_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1734,7 +1768,7 @@ static snd_pcm_hardware_t snd_trident_capture =
  *  Foldback capture support device description
  */
 
-static snd_pcm_hardware_t snd_trident_foldback =
+static struct snd_pcm_hardware snd_trident_foldback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1758,7 +1792,7 @@ static snd_pcm_hardware_t snd_trident_foldback =
  *  SPDIF playback support device description
  */
 
-static snd_pcm_hardware_t snd_trident_spdif =
+static struct snd_pcm_hardware snd_trident_spdif =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1779,7 +1813,7 @@ static snd_pcm_hardware_t snd_trident_spdif =
 	.fifo_size =		0,
 };
 
-static snd_pcm_hardware_t snd_trident_spdif_7018 =
+static struct snd_pcm_hardware snd_trident_spdif_7018 =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -1799,10 +1833,10 @@ static snd_pcm_hardware_t snd_trident_spdif_7018 =
 	.fifo_size =		0,
 };
 
-static void snd_trident_pcm_free_substream(snd_pcm_runtime_t *runtime)
+static void snd_trident_pcm_free_substream(struct snd_pcm_runtime *runtime)
 {
-	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
-	trident_t *trident;
+	struct snd_trident_voice *voice = runtime->private_data;
+	struct snd_trident *trident;
 
 	if (voice) {
 		trident = voice->trident;
@@ -1810,11 +1844,11 @@ static void snd_trident_pcm_free_substream(snd_pcm_runtime_t *runtime)
 	}
 }
 
-static int snd_trident_playback_open(snd_pcm_substream_t * substream)
+static int snd_trident_playback_open(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_trident_voice_t *voice;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_trident_voice *voice;
 
 	voice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);
 	if (voice == NULL)
@@ -1838,11 +1872,11 @@ static int snd_trident_playback_open(snd_pcm_substream_t * substream)
    Parameters:	substream  - PCM substream class
 
   ---------------------------------------------------------------------------*/
-static int snd_trident_playback_close(snd_pcm_substream_t * substream)
+static int snd_trident_playback_close(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_trident_voice *voice = runtime->private_data;
 
 	snd_trident_pcm_mixer_free(trident, voice, substream);
 	return 0;
@@ -1859,11 +1893,11 @@ static int snd_trident_playback_close(snd_pcm_substream_t * substream)
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_spdif_open(snd_pcm_substream_t * substream)
+static int snd_trident_spdif_open(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_trident_voice_t *voice;
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_trident_voice *voice;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	
 	voice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);
 	if (voice == NULL)
@@ -1900,9 +1934,9 @@ static int snd_trident_spdif_open(snd_pcm_substream_t * substream)
 
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_spdif_close(snd_pcm_substream_t * substream)
+static int snd_trident_spdif_close(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
 	unsigned int temp;
 
 	spin_lock_irq(&trident->reg_lock);
@@ -1938,11 +1972,11 @@ static int snd_trident_spdif_close(snd_pcm_substream_t * substream)
 
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_capture_open(snd_pcm_substream_t * substream)
+static int snd_trident_capture_open(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_trident_voice_t *voice;
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_trident_voice *voice;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	voice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);
 	if (voice == NULL)
@@ -1966,7 +2000,7 @@ static int snd_trident_capture_open(snd_pcm_substream_t * substream)
    Parameters:	substream  - PCM substream class
 
   ---------------------------------------------------------------------------*/
-static int snd_trident_capture_close(snd_pcm_substream_t * substream)
+static int snd_trident_capture_close(struct snd_pcm_substream *substream)
 {
 	return 0;
 }
@@ -1982,11 +2016,11 @@ static int snd_trident_capture_close(snd_pcm_substream_t * substream)
 
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_foldback_open(snd_pcm_substream_t * substream)
+static int snd_trident_foldback_open(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_trident_voice_t *voice;
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_trident_voice *voice;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	voice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);
 	if (voice == NULL)
@@ -2009,12 +2043,12 @@ static int snd_trident_foldback_open(snd_pcm_substream_t * substream)
    Parameters:	substream  - PCM substream class
 
   ---------------------------------------------------------------------------*/
-static int snd_trident_foldback_close(snd_pcm_substream_t * substream)
+static int snd_trident_foldback_close(struct snd_pcm_substream *substream)
 {
-	trident_t *trident = snd_pcm_substream_chip(substream);
-	snd_trident_voice_t *voice;
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	voice = (snd_trident_voice_t *) runtime->private_data;
+	struct snd_trident *trident = snd_pcm_substream_chip(substream);
+	struct snd_trident_voice *voice;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	voice = runtime->private_data;
 	
 	/* stop capture channel */
 	spin_lock_irq(&trident->reg_lock);
@@ -2027,7 +2061,7 @@ static int snd_trident_foldback_close(snd_pcm_substream_t * substream)
    PCM operations
   ---------------------------------------------------------------------------*/
 
-static snd_pcm_ops_t snd_trident_playback_ops = {
+static struct snd_pcm_ops snd_trident_playback_ops = {
 	.open =		snd_trident_playback_open,
 	.close =	snd_trident_playback_close,
 	.ioctl =	snd_trident_ioctl,
@@ -2038,7 +2072,7 @@ static snd_pcm_ops_t snd_trident_playback_ops = {
 	.pointer =	snd_trident_playback_pointer,
 };
 
-static snd_pcm_ops_t snd_trident_nx_playback_ops = {
+static struct snd_pcm_ops snd_trident_nx_playback_ops = {
 	.open =		snd_trident_playback_open,
 	.close =	snd_trident_playback_close,
 	.ioctl =	snd_trident_ioctl,
@@ -2050,7 +2084,7 @@ static snd_pcm_ops_t snd_trident_nx_playback_ops = {
 	.page =		snd_pcm_sgbuf_ops_page,
 };
 
-static snd_pcm_ops_t snd_trident_capture_ops = {
+static struct snd_pcm_ops snd_trident_capture_ops = {
 	.open =		snd_trident_capture_open,
 	.close =	snd_trident_capture_close,
 	.ioctl =	snd_trident_ioctl,
@@ -2061,7 +2095,7 @@ static snd_pcm_ops_t snd_trident_capture_ops = {
 	.pointer =	snd_trident_capture_pointer,
 };
 
-static snd_pcm_ops_t snd_trident_si7018_capture_ops = {
+static struct snd_pcm_ops snd_trident_si7018_capture_ops = {
 	.open =		snd_trident_capture_open,
 	.close =	snd_trident_capture_close,
 	.ioctl =	snd_trident_ioctl,
@@ -2072,7 +2106,7 @@ static snd_pcm_ops_t snd_trident_si7018_capture_ops = {
 	.pointer =	snd_trident_playback_pointer,
 };
 
-static snd_pcm_ops_t snd_trident_foldback_ops = {
+static struct snd_pcm_ops snd_trident_foldback_ops = {
 	.open =		snd_trident_foldback_open,
 	.close =	snd_trident_foldback_close,
 	.ioctl =	snd_trident_ioctl,
@@ -2083,7 +2117,7 @@ static snd_pcm_ops_t snd_trident_foldback_ops = {
 	.pointer =	snd_trident_playback_pointer,
 };
 
-static snd_pcm_ops_t snd_trident_nx_foldback_ops = {
+static struct snd_pcm_ops snd_trident_nx_foldback_ops = {
 	.open =		snd_trident_foldback_open,
 	.close =	snd_trident_foldback_close,
 	.ioctl =	snd_trident_ioctl,
@@ -2095,7 +2129,7 @@ static snd_pcm_ops_t snd_trident_nx_foldback_ops = {
 	.page =		snd_pcm_sgbuf_ops_page,
 };
 
-static snd_pcm_ops_t snd_trident_spdif_ops = {
+static struct snd_pcm_ops snd_trident_spdif_ops = {
 	.open =		snd_trident_spdif_open,
 	.close =	snd_trident_spdif_close,
 	.ioctl =	snd_trident_ioctl,
@@ -2106,7 +2140,7 @@ static snd_pcm_ops_t snd_trident_spdif_ops = {
 	.pointer =	snd_trident_spdif_pointer,
 };
 
-static snd_pcm_ops_t snd_trident_spdif_7018_ops = {
+static struct snd_pcm_ops snd_trident_spdif_7018_ops = {
 	.open =		snd_trident_spdif_open,
 	.close =	snd_trident_spdif_close,
 	.ioctl =	snd_trident_ioctl,
@@ -2128,9 +2162,10 @@ static snd_pcm_ops_t snd_trident_spdif_7018_ops = {
   
   ---------------------------------------------------------------------------*/
 
-int __devinit snd_trident_pcm(trident_t * trident, int device, snd_pcm_t ** rpcm)
+int __devinit snd_trident_pcm(struct snd_trident * trident,
+			      int device, struct snd_pcm ** rpcm)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	if (rpcm)
@@ -2156,7 +2191,7 @@ int __devinit snd_trident_pcm(trident_t * trident, int device, snd_pcm_t ** rpcm
 	trident->pcm = pcm;
 
 	if (trident->tlb.entries) {
-		snd_pcm_substream_t *substream;
+		struct snd_pcm_substream *substream;
 		for (substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; substream; substream = substream->next)
 			snd_pcm_lib_preallocate_pages(substream, SNDRV_DMA_TYPE_DEV_SG,
 						      snd_dma_pci_data(trident->pci),
@@ -2185,12 +2220,13 @@ int __devinit snd_trident_pcm(trident_t * trident, int device, snd_pcm_t ** rpcm
   
   ---------------------------------------------------------------------------*/
 
-int __devinit snd_trident_foldback_pcm(trident_t * trident, int device, snd_pcm_t ** rpcm)
+int __devinit snd_trident_foldback_pcm(struct snd_trident * trident,
+				       int device, struct snd_pcm ** rpcm)
 {
-	snd_pcm_t *foldback;
+	struct snd_pcm *foldback;
 	int err;
 	int num_chan = 3;
-	snd_pcm_substream_t *substream;
+	struct snd_pcm_substream *substream;
 
 	if (rpcm)
 		*rpcm = NULL;
@@ -2241,9 +2277,10 @@ int __devinit snd_trident_foldback_pcm(trident_t * trident, int device, snd_pcm_
   
   ---------------------------------------------------------------------------*/
 
-int __devinit snd_trident_spdif_pcm(trident_t * trident, int device, snd_pcm_t ** rpcm)
+int __devinit snd_trident_spdif_pcm(struct snd_trident * trident,
+				    int device, struct snd_pcm ** rpcm)
 {
-	snd_pcm_t *spdif;
+	struct snd_pcm *spdif;
 	int err;
 
 	if (rpcm)
@@ -2279,7 +2316,8 @@ int __devinit snd_trident_spdif_pcm(trident_t * trident, int device, snd_pcm_t *
     Description: enable/disable S/PDIF out from ac97 mixer
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_spdif_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_trident_spdif_control_info(struct snd_kcontrol *kcontrol,
+					  struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
@@ -2288,10 +2326,10 @@ static int snd_trident_spdif_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem
 	return 0;
 }
 
-static int snd_trident_spdif_control_get(snd_kcontrol_t * kcontrol,
-					 snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_spdif_control_get(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
 	unsigned char val;
 
 	spin_lock_irq(&trident->reg_lock);
@@ -2301,10 +2339,10 @@ static int snd_trident_spdif_control_get(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_trident_spdif_control_put(snd_kcontrol_t * kcontrol,
-					 snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_spdif_control_put(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
 	unsigned char val;
 	int change;
 
@@ -2332,7 +2370,7 @@ static int snd_trident_spdif_control_put(snd_kcontrol_t * kcontrol,
 	return change;
 }
 
-static snd_kcontrol_new_t snd_trident_spdif_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_spdif_control __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,SWITCH),
@@ -2348,17 +2386,18 @@ static snd_kcontrol_new_t snd_trident_spdif_control __devinitdata =
     Description: put/get the S/PDIF default settings
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_spdif_default_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_trident_spdif_default_info(struct snd_kcontrol *kcontrol,
+					  struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_trident_spdif_default_get(snd_kcontrol_t * kcontrol,
-					 snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_spdif_default_get(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&trident->reg_lock);
 	ucontrol->value.iec958.status[0] = (trident->spdif_bits >> 0) & 0xff;
@@ -2369,10 +2408,10 @@ static int snd_trident_spdif_default_get(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_trident_spdif_default_put(snd_kcontrol_t * kcontrol,
-					 snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_spdif_default_put(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 	int change;
 
@@ -2394,7 +2433,7 @@ static int snd_trident_spdif_default_put(snd_kcontrol_t * kcontrol,
 	return change;
 }
 
-static snd_kcontrol_new_t snd_trident_spdif_default __devinitdata =
+static struct snd_kcontrol_new snd_trident_spdif_default __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
 	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
@@ -2409,15 +2448,16 @@ static snd_kcontrol_new_t snd_trident_spdif_default __devinitdata =
     Description: put/get the S/PDIF mask
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_spdif_mask_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_trident_spdif_mask_info(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_trident_spdif_mask_get(snd_kcontrol_t * kcontrol,
-				      snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_spdif_mask_get(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
 {
 	ucontrol->value.iec958.status[0] = 0xff;
 	ucontrol->value.iec958.status[1] = 0xff;
@@ -2426,7 +2466,7 @@ static int snd_trident_spdif_mask_get(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static snd_kcontrol_new_t snd_trident_spdif_mask __devinitdata =
+static struct snd_kcontrol_new snd_trident_spdif_mask __devinitdata =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -2441,17 +2481,18 @@ static snd_kcontrol_new_t snd_trident_spdif_mask __devinitdata =
     Description: put/get the S/PDIF stream settings
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_spdif_stream_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_trident_spdif_stream_info(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_trident_spdif_stream_get(snd_kcontrol_t * kcontrol,
-					snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_spdif_stream_get(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&trident->reg_lock);
 	ucontrol->value.iec958.status[0] = (trident->spdif_pcm_bits >> 0) & 0xff;
@@ -2462,10 +2503,10 @@ static int snd_trident_spdif_stream_get(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_trident_spdif_stream_put(snd_kcontrol_t * kcontrol,
-					snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_spdif_stream_put(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 	int change;
 
@@ -2487,7 +2528,7 @@ static int snd_trident_spdif_stream_put(snd_kcontrol_t * kcontrol,
 	return change;
 }
 
-static snd_kcontrol_new_t snd_trident_spdif_stream __devinitdata =
+static struct snd_kcontrol_new snd_trident_spdif_stream __devinitdata =
 {
 	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
 	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
@@ -2503,7 +2544,8 @@ static snd_kcontrol_new_t snd_trident_spdif_stream __devinitdata =
     Description: enable/disable rear path for ac97
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_ac97_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_trident_ac97_control_info(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
@@ -2512,10 +2554,10 @@ static int snd_trident_ac97_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_
 	return 0;
 }
 
-static int snd_trident_ac97_control_get(snd_kcontrol_t * kcontrol,
-					snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_ac97_control_get(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
 	unsigned char val;
 
 	spin_lock_irq(&trident->reg_lock);
@@ -2525,10 +2567,10 @@ static int snd_trident_ac97_control_get(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_trident_ac97_control_put(snd_kcontrol_t * kcontrol,
-					snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_ac97_control_put(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
 	unsigned char val;
 	int change = 0;
 
@@ -2544,7 +2586,7 @@ static int snd_trident_ac97_control_put(snd_kcontrol_t * kcontrol,
 	return change;
 }
 
-static snd_kcontrol_new_t snd_trident_ac97_rear_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_ac97_rear_control __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Rear Path",
@@ -2560,7 +2602,8 @@ static snd_kcontrol_new_t snd_trident_ac97_rear_control __devinitdata =
     Description: wave & music volume control
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_vol_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_trident_vol_control_info(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
@@ -2569,10 +2612,10 @@ static int snd_trident_vol_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_i
 	return 0;
 }
 
-static int snd_trident_vol_control_get(snd_kcontrol_t * kcontrol,
-				       snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_vol_control_get(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 
 	val = trident->musicvol_wavevol;
@@ -2581,10 +2624,10 @@ static int snd_trident_vol_control_get(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_trident_vol_control_put(snd_kcontrol_t * kcontrol,
-				       snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_vol_control_put(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
 	unsigned int val;
 	int change = 0;
 
@@ -2599,7 +2642,7 @@ static int snd_trident_vol_control_put(snd_kcontrol_t * kcontrol,
 	return change;
 }
 
-static snd_kcontrol_new_t snd_trident_vol_music_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_vol_music_control __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Music Playback Volume",
@@ -2609,7 +2652,7 @@ static snd_kcontrol_new_t snd_trident_vol_music_control __devinitdata =
 	.private_value = 16,
 };
 
-static snd_kcontrol_new_t snd_trident_vol_wave_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_vol_wave_control __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "Wave Playback Volume",
@@ -2625,9 +2668,10 @@ static snd_kcontrol_new_t snd_trident_vol_wave_control __devinitdata =
     Description: PCM front volume control
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_pcm_vol_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_trident_pcm_vol_control_info(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_info *uinfo)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
@@ -2638,11 +2682,11 @@ static int snd_trident_pcm_vol_control_info(snd_kcontrol_t *kcontrol, snd_ctl_el
 	return 0;
 }
 
-static int snd_trident_pcm_vol_control_get(snd_kcontrol_t * kcontrol,
-					   snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_pcm_vol_control_get(struct snd_kcontrol *kcontrol,
+					   struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
-	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
 
 	if (trident->device == TRIDENT_DEVICE_ID_SI7018) {
 		ucontrol->value.integer.value[0] = 1023 - mix->vol;
@@ -2652,11 +2696,11 @@ static int snd_trident_pcm_vol_control_get(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_trident_pcm_vol_control_put(snd_kcontrol_t * kcontrol,
-					   snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_pcm_vol_control_put(struct snd_kcontrol *kcontrol,
+					   struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
-	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
 	unsigned int val;
 	int change = 0;
 
@@ -2674,7 +2718,7 @@ static int snd_trident_pcm_vol_control_put(snd_kcontrol_t * kcontrol,
 	return change;
 }
 
-static snd_kcontrol_new_t snd_trident_pcm_vol_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_pcm_vol_control __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "PCM Front Playback Volume",
@@ -2691,7 +2735,8 @@ static snd_kcontrol_new_t snd_trident_pcm_vol_control __devinitdata =
     Description: PCM front pan control
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_pcm_pan_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_trident_pcm_pan_control_info(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
@@ -2700,11 +2745,11 @@ static int snd_trident_pcm_pan_control_info(snd_kcontrol_t *kcontrol, snd_ctl_el
 	return 0;
 }
 
-static int snd_trident_pcm_pan_control_get(snd_kcontrol_t * kcontrol,
-					   snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_pcm_pan_control_get(struct snd_kcontrol *kcontrol,
+					   struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
-	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
 
 	ucontrol->value.integer.value[0] = mix->pan;
 	if (ucontrol->value.integer.value[0] & 0x40) {
@@ -2715,11 +2760,11 @@ static int snd_trident_pcm_pan_control_get(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_trident_pcm_pan_control_put(snd_kcontrol_t * kcontrol,
-					   snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_pcm_pan_control_put(struct snd_kcontrol *kcontrol,
+					   struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
-	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
 	unsigned char val;
 	int change = 0;
 
@@ -2736,7 +2781,7 @@ static int snd_trident_pcm_pan_control_put(snd_kcontrol_t * kcontrol,
 	return change;
 }
 
-static snd_kcontrol_new_t snd_trident_pcm_pan_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_pcm_pan_control __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "PCM Pan Playback Control",
@@ -2753,7 +2798,8 @@ static snd_kcontrol_new_t snd_trident_pcm_pan_control __devinitdata =
     Description: PCM reverb volume control
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_pcm_rvol_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_trident_pcm_rvol_control_info(struct snd_kcontrol *kcontrol,
+					     struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
@@ -2762,21 +2808,21 @@ static int snd_trident_pcm_rvol_control_info(snd_kcontrol_t *kcontrol, snd_ctl_e
 	return 0;
 }
 
-static int snd_trident_pcm_rvol_control_get(snd_kcontrol_t * kcontrol,
-					    snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_pcm_rvol_control_get(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
-	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
 
 	ucontrol->value.integer.value[0] = 127 - mix->rvol;
 	return 0;
 }
 
-static int snd_trident_pcm_rvol_control_put(snd_kcontrol_t * kcontrol,
-					    snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_pcm_rvol_control_put(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
-	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
 	unsigned short val;
 	int change = 0;
 
@@ -2790,7 +2836,7 @@ static int snd_trident_pcm_rvol_control_put(snd_kcontrol_t * kcontrol,
 	return change;
 }
 
-static snd_kcontrol_new_t snd_trident_pcm_rvol_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_pcm_rvol_control __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "PCM Reverb Playback Volume",
@@ -2807,7 +2853,8 @@ static snd_kcontrol_new_t snd_trident_pcm_rvol_control __devinitdata =
     Description: PCM chorus volume control
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_pcm_cvol_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_trident_pcm_cvol_control_info(struct snd_kcontrol *kcontrol,
+					     struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
@@ -2816,21 +2863,21 @@ static int snd_trident_pcm_cvol_control_info(snd_kcontrol_t *kcontrol, snd_ctl_e
 	return 0;
 }
 
-static int snd_trident_pcm_cvol_control_get(snd_kcontrol_t * kcontrol,
-					    snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_pcm_cvol_control_get(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
-	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
 
 	ucontrol->value.integer.value[0] = 127 - mix->cvol;
 	return 0;
 }
 
-static int snd_trident_pcm_cvol_control_put(snd_kcontrol_t * kcontrol,
-					    snd_ctl_elem_value_t * ucontrol)
+static int snd_trident_pcm_cvol_control_put(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_value *ucontrol)
 {
-	trident_t *trident = snd_kcontrol_chip(kcontrol);
-	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+	struct snd_trident *trident = snd_kcontrol_chip(kcontrol);
+	struct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
 	unsigned short val;
 	int change = 0;
 
@@ -2844,7 +2891,7 @@ static int snd_trident_pcm_cvol_control_put(snd_kcontrol_t * kcontrol,
 	return change;
 }
 
-static snd_kcontrol_new_t snd_trident_pcm_cvol_control __devinitdata =
+static struct snd_kcontrol_new snd_trident_pcm_cvol_control __devinitdata =
 {
 	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name =         "PCM Chorus Playback Volume",
@@ -2855,9 +2902,11 @@ static snd_kcontrol_new_t snd_trident_pcm_cvol_control __devinitdata =
 	.put =		snd_trident_pcm_cvol_control_put,
 };
 
-static void snd_trident_notify_pcm_change1(snd_card_t * card, snd_kcontrol_t *kctl, int num, int activate)
+static void snd_trident_notify_pcm_change1(struct snd_card *card,
+					   struct snd_kcontrol *kctl,
+					   int num, int activate)
 {
-	snd_ctl_elem_id_t id;
+	struct snd_ctl_elem_id id;
 
 	if (! kctl)
 		return;
@@ -2870,7 +2919,9 @@ static void snd_trident_notify_pcm_change1(snd_card_t * card, snd_kcontrol_t *kc
 		       snd_ctl_build_ioff(&id, kctl, num));
 }
 
-static void snd_trident_notify_pcm_change(trident_t *trident, snd_trident_pcm_mixer_t *tmix, int num, int activate)
+static void snd_trident_notify_pcm_change(struct snd_trident *trident,
+					  struct snd_trident_pcm_mixer *tmix,
+					  int num, int activate)
 {
 	snd_trident_notify_pcm_change1(trident->card, trident->ctl_vol, num, activate);
 	snd_trident_notify_pcm_change1(trident->card, trident->ctl_pan, num, activate);
@@ -2878,9 +2929,11 @@ static void snd_trident_notify_pcm_change(trident_t *trident, snd_trident_pcm_mi
 	snd_trident_notify_pcm_change1(trident->card, trident->ctl_cvol, num, activate);
 }
 
-static int snd_trident_pcm_mixer_build(trident_t *trident, snd_trident_voice_t *voice, snd_pcm_substream_t *substream)
+static int snd_trident_pcm_mixer_build(struct snd_trident *trident,
+				       struct snd_trident_voice *voice,
+				       struct snd_pcm_substream *substream)
 {
-	snd_trident_pcm_mixer_t *tmix;
+	struct snd_trident_pcm_mixer *tmix;
 
 	snd_assert(trident != NULL && voice != NULL && substream != NULL, return -EINVAL);
 	tmix = &trident->pcm_mixer[substream->number];
@@ -2893,9 +2946,9 @@ static int snd_trident_pcm_mixer_build(trident_t *trident, snd_trident_voice_t *
 	return 0;
 }
 
-static int snd_trident_pcm_mixer_free(trident_t *trident, snd_trident_voice_t *voice, snd_pcm_substream_t *substream)
+static int snd_trident_pcm_mixer_free(struct snd_trident *trident, struct snd_trident_voice *voice, struct snd_pcm_substream *substream)
 {
-	snd_trident_pcm_mixer_t *tmix;
+	struct snd_trident_pcm_mixer *tmix;
 
 	snd_assert(trident != NULL && substream != NULL, return -EINVAL);
 	tmix = &trident->pcm_mixer[substream->number];
@@ -2915,14 +2968,14 @@ static int snd_trident_pcm_mixer_free(trident_t *trident, snd_trident_voice_t *v
   
   ---------------------------------------------------------------------------*/
 
-static int __devinit snd_trident_mixer(trident_t * trident, int pcm_spdif_device)
+static int __devinit snd_trident_mixer(struct snd_trident * trident, int pcm_spdif_device)
 {
-	ac97_template_t _ac97;
-	snd_card_t * card = trident->card;
-	snd_kcontrol_t *kctl;
-	snd_ctl_elem_value_t *uctl;
+	struct snd_ac97_template _ac97;
+	struct snd_card *card = trident->card;
+	struct snd_kcontrol *kctl;
+	struct snd_ctl_elem_value *uctl;
 	int idx, err, retries = 2;
-	static ac97_bus_ops_t ops = {
+	static struct snd_ac97_bus_ops ops = {
 		.write = snd_trident_codec_write,
 		.read = snd_trident_codec_read,
 	};
@@ -2959,7 +3012,7 @@ static int __devinit snd_trident_mixer(trident_t * trident, int pcm_spdif_device
 			snd_printk(KERN_ERR "SI7018: the secondary codec - invalid access\n");
 #if 0	// only for my testing purpose --jk
 		{
-			ac97_t *mc97;
+			struct snd_ac97 *mc97;
 			err = snd_ac97_modem(trident->card, &_ac97, &mc97);
 			if (err < 0)
 				snd_printk(KERN_ERR "snd_ac97_modem returned error %i\n", err);
@@ -2982,7 +3035,7 @@ static int __devinit snd_trident_mixer(trident_t * trident, int pcm_spdif_device
 	}
 
 	for (idx = 0; idx < 32; idx++) {
-		snd_trident_pcm_mixer_t *tmix;
+		struct snd_trident_pcm_mixer *tmix;
 		
 		tmix = &trident->pcm_mixer[idx];
 		tmix->voice = NULL;
@@ -3080,7 +3133,7 @@ static int __devinit snd_trident_mixer(trident_t * trident, int pcm_spdif_device
 
 static unsigned char snd_trident_gameport_read(struct gameport *gameport)
 {
-	trident_t *chip = gameport_get_port_data(gameport);
+	struct snd_trident *chip = gameport_get_port_data(gameport);
 
 	snd_assert(chip, return 0);
 	return inb(TRID_REG(chip, GAMEPORT_LEGACY));
@@ -3088,7 +3141,7 @@ static unsigned char snd_trident_gameport_read(struct gameport *gameport)
 
 static void snd_trident_gameport_trigger(struct gameport *gameport)
 {
-	trident_t *chip = gameport_get_port_data(gameport);
+	struct snd_trident *chip = gameport_get_port_data(gameport);
 
 	snd_assert(chip, return);
 	outb(0xff, TRID_REG(chip, GAMEPORT_LEGACY));
@@ -3096,7 +3149,7 @@ static void snd_trident_gameport_trigger(struct gameport *gameport)
 
 static int snd_trident_gameport_cooked_read(struct gameport *gameport, int *axes, int *buttons)
 {
-	trident_t *chip = gameport_get_port_data(gameport);
+	struct snd_trident *chip = gameport_get_port_data(gameport);
 	int i;
 
 	snd_assert(chip, return 0);
@@ -3113,7 +3166,7 @@ static int snd_trident_gameport_cooked_read(struct gameport *gameport, int *axes
 
 static int snd_trident_gameport_open(struct gameport *gameport, int mode)
 {
-	trident_t *chip = gameport_get_port_data(gameport);
+	struct snd_trident *chip = gameport_get_port_data(gameport);
 
 	snd_assert(chip, return 0);
 
@@ -3130,7 +3183,7 @@ static int snd_trident_gameport_open(struct gameport *gameport, int mode)
 	}
 }
 
-int __devinit snd_trident_create_gameport(trident_t *chip)
+int __devinit snd_trident_create_gameport(struct snd_trident *chip)
 {
 	struct gameport *gp;
 
@@ -3156,7 +3209,7 @@ int __devinit snd_trident_create_gameport(trident_t *chip)
 	return 0;
 }
 
-static inline void snd_trident_free_gameport(trident_t *chip)
+static inline void snd_trident_free_gameport(struct snd_trident *chip)
 {
 	if (chip->gameport) {
 		gameport_unregister_port(chip->gameport);
@@ -3164,14 +3217,14 @@ static inline void snd_trident_free_gameport(trident_t *chip)
 	}
 }
 #else
-int __devinit snd_trident_create_gameport(trident_t *chip) { return -ENOSYS; }
-static inline void snd_trident_free_gameport(trident_t *chip) { }
+int __devinit snd_trident_create_gameport(struct snd_trident *chip) { return -ENOSYS; }
+static inline void snd_trident_free_gameport(struct snd_trident *chip) { }
 #endif /* CONFIG_GAMEPORT */
 
 /*
  * delay for 1 tick
  */
-static inline void do_delay(trident_t *chip)
+static inline void do_delay(struct snd_trident *chip)
 {
 	schedule_timeout_uninterruptible(1);
 }
@@ -3180,7 +3233,7 @@ static inline void do_delay(trident_t *chip)
  *  SiS reset routine
  */
 
-static int snd_trident_sis_reset(trident_t *trident)
+static int snd_trident_sis_reset(struct snd_trident *trident)
 {
 	unsigned long end_time;
 	unsigned int i;
@@ -3233,10 +3286,10 @@ static int snd_trident_sis_reset(trident_t *trident)
  *  /proc interface
  */
 
-static void snd_trident_proc_read(snd_info_entry_t *entry, 
-				  snd_info_buffer_t * buffer)
+static void snd_trident_proc_read(struct snd_info_entry *entry, 
+				  struct snd_info_buffer *buffer)
 {
-	trident_t *trident = entry->private_data;
+	struct snd_trident *trident = entry->private_data;
 	char *s;
 
 	switch (trident->device) {
@@ -3274,9 +3327,9 @@ static void snd_trident_proc_read(snd_info_entry_t *entry,
 #endif
 }
 
-static void __devinit snd_trident_proc_init(trident_t * trident)
+static void __devinit snd_trident_proc_init(struct snd_trident * trident)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 	const char *s = "trident";
 	
 	if (trident->device == TRIDENT_DEVICE_ID_SI7018)
@@ -3285,9 +3338,9 @@ static void __devinit snd_trident_proc_init(trident_t * trident)
 		snd_info_set_text_ops(entry, trident, 1024, snd_trident_proc_read);
 }
 
-static int snd_trident_dev_free(snd_device_t *device)
+static int snd_trident_dev_free(struct snd_device *device)
 {
-	trident_t *trident = device->device_data;
+	struct snd_trident *trident = device->device_data;
 	return snd_trident_free(trident);
 }
 
@@ -3303,7 +3356,7 @@ static int snd_trident_dev_free(snd_device_t *device)
   
   ---------------------------------------------------------------------------*/
 
-static int __devinit snd_trident_tlb_alloc(trident_t *trident)
+static int __devinit snd_trident_tlb_alloc(struct snd_trident *trident)
 {
 	int i;
 
@@ -3318,7 +3371,7 @@ static int __devinit snd_trident_tlb_alloc(trident_t *trident)
 	trident->tlb.entries = (unsigned int*)(((unsigned long)trident->tlb.buffer.area + SNDRV_TRIDENT_MAX_PAGES * 4 - 1) & ~(SNDRV_TRIDENT_MAX_PAGES * 4 - 1));
 	trident->tlb.entries_dmaaddr = (trident->tlb.buffer.addr + SNDRV_TRIDENT_MAX_PAGES * 4 - 1) & ~(SNDRV_TRIDENT_MAX_PAGES * 4 - 1);
 	/* allocate shadow TLB page table (virtual addresses) */
-	trident->tlb.shadow_entries = (unsigned long *)vmalloc(SNDRV_TRIDENT_MAX_PAGES*sizeof(unsigned long));
+	trident->tlb.shadow_entries = vmalloc(SNDRV_TRIDENT_MAX_PAGES*sizeof(unsigned long));
 	if (trident->tlb.shadow_entries == NULL) {
 		snd_printk(KERN_ERR "trident: unable to allocate shadow TLB entries\n");
 		return -ENOMEM;
@@ -3340,7 +3393,7 @@ static int __devinit snd_trident_tlb_alloc(trident_t *trident)
 	if (trident->tlb.memhdr == NULL)
 		return -ENOMEM;
 
-	trident->tlb.memhdr->block_extra_size = sizeof(snd_trident_memblk_arg_t);
+	trident->tlb.memhdr->block_extra_size = sizeof(struct snd_trident_memblk_arg);
 	return 0;
 }
 
@@ -3348,7 +3401,7 @@ static int __devinit snd_trident_tlb_alloc(trident_t *trident)
  * initialize 4D DX chip
  */
 
-static void snd_trident_stop_all_voices(trident_t *trident)
+static void snd_trident_stop_all_voices(struct snd_trident *trident)
 {
 	outl(0xffffffff, TRID_REG(trident, T4D_STOP_A));
 	outl(0xffffffff, TRID_REG(trident, T4D_STOP_B));
@@ -3356,7 +3409,7 @@ static void snd_trident_stop_all_voices(trident_t *trident)
 	outl(0, TRID_REG(trident, T4D_AINTEN_B));
 }
 
-static int snd_trident_4d_dx_init(trident_t *trident)
+static int snd_trident_4d_dx_init(struct snd_trident *trident)
 {
 	struct pci_dev *pci = trident->pci;
 	unsigned long end_time;
@@ -3396,7 +3449,7 @@ static int snd_trident_4d_dx_init(trident_t *trident)
 /*
  * initialize 4D NX chip
  */
-static int snd_trident_4d_nx_init(trident_t *trident)
+static int snd_trident_4d_nx_init(struct snd_trident *trident)
 {
 	struct pci_dev *pci = trident->pci;
 	unsigned long end_time;
@@ -3453,7 +3506,7 @@ static int snd_trident_4d_nx_init(trident_t *trident)
 /*
  * initialize sis7018 chip
  */
-static int snd_trident_sis_init(trident_t *trident)
+static int snd_trident_sis_init(struct snd_trident *trident)
 {
 	int err;
 
@@ -3484,18 +3537,18 @@ static int snd_trident_sis_init(trident_t *trident)
   
   ---------------------------------------------------------------------------*/
 
-int __devinit snd_trident_create(snd_card_t * card,
+int __devinit snd_trident_create(struct snd_card *card,
 		       struct pci_dev *pci,
 		       int pcm_streams,
 		       int pcm_spdif_device,
 		       int max_wavetable_size,
-		       trident_t ** rtrident)
+		       struct snd_trident ** rtrident)
 {
-	trident_t *trident;
+	struct snd_trident *trident;
 	int i, err;
-	snd_trident_voice_t *voice;
-	snd_trident_pcm_mixer_t *tmix;
-	static snd_device_ops_t ops = {
+	struct snd_trident_voice *voice;
+	struct snd_trident_pcm_mixer *tmix;
+	static struct snd_device_ops ops = {
 		.dev_free =	snd_trident_dev_free,
 	};
 
@@ -3543,7 +3596,8 @@ int __devinit snd_trident_create(snd_card_t * card,
 	}
 	trident->port = pci_resource_start(pci, 0);
 
-	if (request_irq(pci->irq, snd_trident_interrupt, SA_INTERRUPT|SA_SHIRQ, "Trident Audio", (void *) trident)) {
+	if (request_irq(pci->irq, snd_trident_interrupt, SA_INTERRUPT|SA_SHIRQ,
+			"Trident Audio", trident)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_trident_free(trident);
 		return -EBUSY;
@@ -3627,7 +3681,7 @@ int __devinit snd_trident_create(snd_card_t * card,
   
   ---------------------------------------------------------------------------*/
 
-static int snd_trident_free(trident_t *trident)
+static int snd_trident_free(struct snd_trident *trident)
 {
 	snd_trident_free_gameport(trident);
 	snd_trident_disable_eso(trident);
@@ -3647,7 +3701,7 @@ static int snd_trident_free(trident_t *trident)
 		snd_dma_free_pages(&trident->tlb.buffer);
 	}
 	if (trident->irq >= 0)
-		free_irq(trident->irq, (void *)trident);
+		free_irq(trident->irq, trident);
 	pci_release_regions(trident->pci);
 	pci_disable_device(trident->pci);
 	kfree(trident);
@@ -3674,10 +3728,10 @@ static int snd_trident_free(trident_t *trident)
 
 static irqreturn_t snd_trident_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	trident_t *trident = dev_id;
+	struct snd_trident *trident = dev_id;
 	unsigned int audio_int, chn_int, stimer, channel, mask, tmp;
 	int delta;
-	snd_trident_voice_t *voice;
+	struct snd_trident_voice *voice;
 
 	audio_int = inl(TRID_REG(trident, T4D_MISCINT));
 	if ((audio_int & (ADDRESS_IRQ|MPU401_IRQ)) == 0)
@@ -3779,21 +3833,21 @@ static irqreturn_t snd_trident_interrupt(int irq, void *dev_id, struct pt_regs *
    Returns:     None.
   
   ---------------------------------------------------------------------------*/
-int snd_trident_attach_synthesizer(trident_t *trident)
+int snd_trident_attach_synthesizer(struct snd_trident *trident)
 {	
 #if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
 	if (snd_seq_device_new(trident->card, 1, SNDRV_SEQ_DEV_ID_TRIDENT,
-			       sizeof(trident_t*), &trident->seq_dev) >= 0) {
+			       sizeof(struct snd_trident *), &trident->seq_dev) >= 0) {
 		strcpy(trident->seq_dev->name, "4DWave");
-		*(trident_t**)SNDRV_SEQ_DEVICE_ARGPTR(trident->seq_dev) = trident;
+		*(struct snd_trident **)SNDRV_SEQ_DEVICE_ARGPTR(trident->seq_dev) = trident;
 	}
 #endif
 	return 0;
 }
 
-snd_trident_voice_t *snd_trident_alloc_voice(trident_t * trident, int type, int client, int port)
+struct snd_trident_voice *snd_trident_alloc_voice(struct snd_trident * trident, int type, int client, int port)
 {
-	snd_trident_voice_t *pvoice;
+	struct snd_trident_voice *pvoice;
 	unsigned long flags;
 	int idx;
 
@@ -3835,10 +3889,10 @@ snd_trident_voice_t *snd_trident_alloc_voice(trident_t * trident, int type, int
 	return NULL;
 }
 
-void snd_trident_free_voice(trident_t * trident, snd_trident_voice_t *voice)
+void snd_trident_free_voice(struct snd_trident * trident, struct snd_trident_voice *voice)
 {
 	unsigned long flags;
-	void (*private_free)(snd_trident_voice_t *);
+	void (*private_free)(struct snd_trident_voice *);
 	void *private_data;
 
 	if (voice == NULL || !voice->use)
@@ -3863,7 +3917,7 @@ void snd_trident_free_voice(trident_t * trident, snd_trident_voice_t *voice)
 		private_free(voice);
 }
 
-static void snd_trident_clear_voices(trident_t * trident, unsigned short v_min, unsigned short v_max)
+static void snd_trident_clear_voices(struct snd_trident * trident, unsigned short v_min, unsigned short v_max)
 {
 	unsigned int i, val, mask[2] = { 0, 0 };
 
@@ -3884,9 +3938,9 @@ static void snd_trident_clear_voices(trident_t * trident, unsigned short v_min,
 }
 
 #ifdef CONFIG_PM
-static int snd_trident_suspend(snd_card_t *card, pm_message_t state)
+static int snd_trident_suspend(struct snd_card *card, pm_message_t state)
 {
-	trident_t *trident = card->pm_private_data;
+	struct snd_trident *trident = card->pm_private_data;
 
 	trident->in_suspend = 1;
 	snd_pcm_suspend_all(trident->pcm);
@@ -3910,9 +3964,9 @@ static int snd_trident_suspend(snd_card_t *card, pm_message_t state)
 	return 0;
 }
 
-static int snd_trident_resume(snd_card_t *card)
+static int snd_trident_resume(struct snd_card *card)
 {
-	trident_t *trident = card->pm_private_data;
+	struct snd_trident *trident = card->pm_private_data;
 
 	pci_enable_device(trident->pci);
 	if (pci_set_dma_mask(trident->pci, 0x3fffffff) < 0 ||

commit c3e6f7d8763fa0400d28c57633eb323515ba05fc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 16 18:43:35 2005 +0100

    [ALSA] Remove superfluous pcm_free callbacks
    
    Remove superflous pcm_free callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index b9b93c7faafd..62f109f020a5 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -2117,37 +2117,6 @@ static snd_pcm_ops_t snd_trident_spdif_7018_ops = {
 	.pointer =	snd_trident_playback_pointer,
 };
 
-/*---------------------------------------------------------------------------
-   snd_trident_pcm_free
-  
-   Description: This routine release the 4DWave private data.
-                
-   Paramters:   private_data - pointer to 4DWave device info.
-
-   Returns:     None
-  
-  ---------------------------------------------------------------------------*/
-static void snd_trident_pcm_free(snd_pcm_t *pcm)
-{
-	trident_t *trident = pcm->private_data;
-	trident->pcm = NULL;
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
-static void snd_trident_foldback_pcm_free(snd_pcm_t *pcm)
-{
-	trident_t *trident = pcm->private_data;
-	trident->foldback = NULL;
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
-static void snd_trident_spdif_pcm_free(snd_pcm_t *pcm)
-{
-	trident_t *trident = pcm->private_data;
-	trident->spdif = NULL;
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
 /*---------------------------------------------------------------------------
    snd_trident_pcm
   
@@ -2170,7 +2139,6 @@ int __devinit snd_trident_pcm(trident_t * trident, int device, snd_pcm_t ** rpcm
 		return err;
 
 	pcm->private_data = trident;
-	pcm->private_free = snd_trident_pcm_free;
 
 	if (trident->tlb.entries) {
 		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_nx_playback_ops);
@@ -2232,7 +2200,6 @@ int __devinit snd_trident_foldback_pcm(trident_t * trident, int device, snd_pcm_
 		return err;
 
 	foldback->private_data = trident;
-	foldback->private_free = snd_trident_foldback_pcm_free;
 	if (trident->tlb.entries)
 		snd_pcm_set_ops(foldback, SNDRV_PCM_STREAM_CAPTURE, &snd_trident_nx_foldback_ops);
 	else
@@ -2285,7 +2252,6 @@ int __devinit snd_trident_spdif_pcm(trident_t * trident, int device, snd_pcm_t *
 		return err;
 
 	spdif->private_data = trident;
-	spdif->private_free = snd_trident_spdif_pcm_free;
 	if (trident->device != TRIDENT_DEVICE_ID_SI7018) {
 		snd_pcm_set_ops(spdif, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_spdif_ops);
 	} else {

commit 8433a509c0eb6bb1f33ce39c82c580b8901619ee
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Mon Oct 24 15:02:37 2005 +0200

    [ALSA] Fix schedule_timeout usage
    
    Use schedule_timeout_{,un}interruptible() instead of
    set_current_state()/schedule_timeout() to reduce kernel size.  Also use
    human-time conversion functions instead of hard-coded division to avoid
    rounding issues.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 08226f523eb8..b9b93c7faafd 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3207,8 +3207,7 @@ static inline void snd_trident_free_gameport(trident_t *chip) { }
  */
 static inline void do_delay(trident_t *chip)
 {
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	schedule_timeout(1);
+	schedule_timeout_uninterruptible(1);
 }
 
 /*

commit 99b359ba10a582148c6725f428a33ba5356dd993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 20 18:26:44 2005 +0200

    [ALSA] Add missing KERN_* suffix to printk
    
    Add missing KERN_* suffix to printk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index dda62955b4fe..08226f523eb8 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -153,7 +153,7 @@ static unsigned short snd_trident_codec_read(ac97_t *ac97, unsigned short reg)
 	}
 
 	if (count == 0 && !trident->ac97_detect) {
-		snd_printk("ac97 codec read TIMEOUT [0x%x/0x%x]!!!\n", reg, data);
+		snd_printk(KERN_ERR "ac97 codec read TIMEOUT [0x%x/0x%x]!!!\n", reg, data);
 		data = 0;
 	}
 
@@ -2990,13 +2990,13 @@ static int __devinit snd_trident_mixer(trident_t * trident, int pcm_spdif_device
 		_ac97.num = 1;
 		err = snd_ac97_mixer(trident->ac97_bus, &_ac97, &trident->ac97_sec);
 		if (err < 0)
-			snd_printk("SI7018: the secondary codec - invalid access\n");
+			snd_printk(KERN_ERR "SI7018: the secondary codec - invalid access\n");
 #if 0	// only for my testing purpose --jk
 		{
 			ac97_t *mc97;
 			err = snd_ac97_modem(trident->card, &_ac97, &mc97);
 			if (err < 0)
-				snd_printk("snd_ac97_modem returned error %i\n", err);
+				snd_printk(KERN_ERR "snd_ac97_modem returned error %i\n", err);
 		}
 #endif
 	}
@@ -3244,7 +3244,7 @@ static int snd_trident_sis_reset(trident_t *trident)
 			goto __si7018_ok;
 		do_delay(trident);
 	} while (time_after_eq(end_time, jiffies));
-	snd_printk("AC'97 codec ready error [0x%x]\n", inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)));
+	snd_printk(KERN_ERR "AC'97 codec ready error [0x%x]\n", inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)));
 	if (r-- > 0) {
 		end_time = jiffies + HZ;
 		do {
@@ -3542,7 +3542,7 @@ int __devinit snd_trident_create(snd_card_t * card,
 	/* check, if we can restrict PCI DMA transfers to 30 bits */
 	if (pci_set_dma_mask(pci, 0x3fffffff) < 0 ||
 	    pci_set_consistent_dma_mask(pci, 0x3fffffff) < 0) {
-		snd_printk("architecture does not support 30bit PCI busmaster DMA\n");
+		snd_printk(KERN_ERR "architecture does not support 30bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
 		return -ENXIO;
 	}
@@ -3579,7 +3579,7 @@ int __devinit snd_trident_create(snd_card_t * card,
 	trident->port = pci_resource_start(pci, 0);
 
 	if (request_irq(pci->irq, snd_trident_interrupt, SA_INTERRUPT|SA_SHIRQ, "Trident Audio", (void *) trident)) {
-		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_trident_free(trident);
 		return -EBUSY;
 	}

commit 7c22f1aaa23370bf9ba2dd3abbccbed70dced216
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:46:31 2005 +0200

    [ALSA] Remove snd_runtime_check() macro
    
    Remove snd_runtime_check() macro.
    This macro worsens the readability of codes.  They should be either
    normal if() or removable asserts.
    
    Also, the assert displays stack-dump, instead of only the last caller
    pointer.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 777da9a7298b..dda62955b4fe 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -2893,7 +2893,8 @@ static void snd_trident_notify_pcm_change1(snd_card_t * card, snd_kcontrol_t *kc
 {
 	snd_ctl_elem_id_t id;
 
-	snd_runtime_check(kctl != NULL, return);
+	if (! kctl)
+		return;
 	if (activate)
 		kctl->vd[num].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
 	else

commit e560d8d8368ad8b6161839984b253de622863265
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:21:46 2005 +0200

    [ALSA] Replace with kzalloc() - pci stuff
    
    AD1889 driver,ATIIXP driver,ATIIXP-modem driver,AZT3328 driver
    BT87x driver,CMIPCI driver,CS4281 driver,ENS1370/1+ driver
    ES1938 driver,ES1968 driver,FM801 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,SonicVibes driver,VIA82xx driver
    VIA82xx-modem driver,AC97 Codec,AK4531 codec,au88x0 driver
    CA0106 driver,CS46xx driver,EMU10K1/EMU10K2 driver,HDA Codec driver
    HDA generic driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,Trident driver,YMFPCI driver
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index f30d9d947862..777da9a7298b 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -2960,7 +2960,7 @@ static int __devinit snd_trident_mixer(trident_t * trident, int pcm_spdif_device
 		.read = snd_trident_codec_read,
 	};
 
-	uctl = kcalloc(1, sizeof(*uctl), GFP_KERNEL);
+	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (!uctl)
 		return -ENOMEM;
 
@@ -3546,7 +3546,7 @@ int __devinit snd_trident_create(snd_card_t * card,
 		return -ENXIO;
 	}
 	
-	trident = kcalloc(1, sizeof(*trident), GFP_KERNEL);
+	trident = kzalloc(sizeof(*trident), GFP_KERNEL);
 	if (trident == NULL) {
 		pci_disable_device(pci);
 		return -ENOMEM;

commit 41e4845c426024ec41724326397a36b3aa2cb6a3
Author: Jaroslav Kysela <perex@suse.cz>
Date:   Thu Aug 18 13:43:12 2005 +0200

    [ALSA] PCM resume cleanups
    
    Digigram VX core,CS4231 driver,ATIIXP driver,VIA82xx driver
    VIA82xx-modem driver,au88x0 driver,CS46xx driver,Trident driver
    This patch disables SNDRV_PCM_INFO_RESUME flag for drivers which does not
    support the full resume.
    
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index 29d89bfba0a4..f30d9d947862 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -1689,7 +1689,7 @@ static snd_pcm_hardware_t snd_trident_playback =
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
 				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |
-				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+				 SNDRV_PCM_INFO_PAUSE /* | SNDRV_PCM_INFO_RESUME */),
 	.formats =		(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE |
 				 SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U16_LE),
 	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
@@ -1714,7 +1714,7 @@ static snd_pcm_hardware_t snd_trident_capture =
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
 				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |
-				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+				 SNDRV_PCM_INFO_PAUSE /* | SNDRV_PCM_INFO_RESUME */),
 	.formats =		(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE |
 				 SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U16_LE),
 	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
@@ -1739,7 +1739,7 @@ static snd_pcm_hardware_t snd_trident_foldback =
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
 				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |
-				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+				 SNDRV_PCM_INFO_PAUSE /* | SNDRV_PCM_INFO_RESUME */),
 	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
 	.rates =		SNDRV_PCM_RATE_48000,
 	.rate_min =		48000,
@@ -1763,7 +1763,7 @@ static snd_pcm_hardware_t snd_trident_spdif =
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
 				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |
-				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+				 SNDRV_PCM_INFO_PAUSE /* | SNDRV_PCM_INFO_RESUME */),
 	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
 	.rates =		(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
 				 SNDRV_PCM_RATE_48000),
@@ -1784,7 +1784,7 @@ static snd_pcm_hardware_t snd_trident_spdif_7018 =
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
 				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |
-				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+				 SNDRV_PCM_INFO_PAUSE /* | SNDRV_PCM_INFO_RESUME */),
 	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
 	.rates =		SNDRV_PCM_RATE_48000,
 	.rate_min =		48000,

commit ef21ca24faf28df6d06939e77d5032a313490289
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Sat Jul 9 10:13:22 2005 +0200

    [ALSA] sound/pci: fix-up sleeping paths
    
    ENS1370/1+ driver,ES1968 driver,Intel8x0 driver,VIA82xx driver
    VIA82xx-modem driver,AC97 Codec,ALI5451 driver,CS46xx driver
    MIXART driver,RME HDSP driver,Trident driver,YMFPCI driver
    Description: Fix-up sleeping in sound/pci. These changes fall under the
    following two categories:
    
            1) Replace schedule_timeout() with msleep() to guarantee the
            task delays as expected. This also involved replacing/removing
            custom sleep functions.
            2) Do not assume jiffies will only increment by one if you
            request a 1 jiffy sleep, i.e. use time_after/time_before in
            while loops.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index b01c91bb5f6a..29d89bfba0a4 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3153,8 +3153,7 @@ static int snd_trident_gameport_open(struct gameport *gameport, int mode)
 	switch (mode) {
 		case GAMEPORT_MODE_COOKED:
 			outb(GAMEPORT_MODE_ADC, TRID_REG(chip, GAMEPORT_GCR));
-			set_current_state(TASK_UNINTERRUPTIBLE);
-			schedule_timeout(1 + 20 * HZ / 1000); /* 20msec */
+			msleep(20);
 			return 0;
 		case GAMEPORT_MODE_RAW:
 			outb(0, TRID_REG(chip, GAMEPORT_GCR));

commit b95eed7cde4a44476fa12e776e090fc494059458
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jun 27 15:07:33 2005 +0200

    [ALSA] trident - Shut up compile warnings
    
    Trident driver
    Shut up compile warnings about uninitialized variables.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index a09b0fb49e81..b01c91bb5f6a 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -472,6 +472,7 @@ void snd_trident_write_voice_regs(trident_t * trident,
 		break;
 	default:
 		snd_BUG();
+		return;
 	}
 
 	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));

commit 77933d7276ee8fa0e2947641941a6f7a100a327b
Author: Jesper Juhl <juhl@dif.dk>
Date:   Wed Jul 27 11:46:09 2005 -0700

    [PATCH] clean up inline static vs static inline
    
    `gcc -W' likes to complain if the static keyword is not at the beginning of
    the declaration.  This patch fixes all remaining occurrences of "inline
    static" up with "static inline" in the entire kernel tree (140 occurrences in
    47 files).
    
    While making this change I came across a few lines with trailing whitespace
    that I also fixed up, I have also added or removed a blank line or two here
    and there, but there are no functional changes in the patch.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
index ccd5ca2ba16f..a09b0fb49e81 100644
--- a/sound/pci/trident/trident_main.c
+++ b/sound/pci/trident/trident_main.c
@@ -3204,7 +3204,7 @@ static inline void snd_trident_free_gameport(trident_t *chip) { }
 /*
  * delay for 1 tick
  */
-inline static void do_delay(trident_t *chip)
+static inline void do_delay(trident_t *chip)
 {
 	set_current_state(TASK_UNINTERRUPTIBLE);
 	schedule_timeout(1);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/trident/trident_main.c b/sound/pci/trident/trident_main.c
new file mode 100644
index 000000000000..ccd5ca2ba16f
--- /dev/null
+++ b/sound/pci/trident/trident_main.c
@@ -0,0 +1,3991 @@
+/*
+ *  Maintained by Jaroslav Kysela <perex@suse.cz>
+ *  Originated by audio@tridentmicro.com
+ *  Fri Feb 19 15:55:28 MST 1999
+ *  Routines for control of Trident 4DWave (DX and NX) chip
+ *
+ *  BUGS:
+ *
+ *  TODO:
+ *    ---
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *
+ *  SiS7018 S/PDIF support by Thomas Winischhofer <thomas@winischhofer.net>
+ */
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/gameport.h>
+
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/control.h>
+#include <sound/trident.h>
+#include <sound/asoundef.h>
+
+#include <asm/io.h>
+
+static int snd_trident_pcm_mixer_build(trident_t *trident, snd_trident_voice_t * voice, snd_pcm_substream_t *substream);
+static int snd_trident_pcm_mixer_free(trident_t *trident, snd_trident_voice_t * voice, snd_pcm_substream_t *substream);
+static irqreturn_t snd_trident_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+#ifdef CONFIG_PM
+static int snd_trident_suspend(snd_card_t *card, pm_message_t state);
+static int snd_trident_resume(snd_card_t *card);
+#endif
+static int snd_trident_sis_reset(trident_t *trident);
+
+static void snd_trident_clear_voices(trident_t * trident, unsigned short v_min, unsigned short v_max);
+static int snd_trident_free(trident_t *trident);
+
+/*
+ *  common I/O routines
+ */
+
+
+#if 0
+static void snd_trident_print_voice_regs(trident_t *trident, int voice)
+{
+	unsigned int val, tmp;
+
+	printk("Trident voice %i:\n", voice);
+	outb(voice, TRID_REG(trident, T4D_LFO_GC_CIR));
+	val = inl(TRID_REG(trident, CH_LBA));
+	printk("LBA: 0x%x\n", val);
+	val = inl(TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC));
+	printk("GVSel: %i\n", val >> 31);
+	printk("Pan: 0x%x\n", (val >> 24) & 0x7f);
+	printk("Vol: 0x%x\n", (val >> 16) & 0xff);
+	printk("CTRL: 0x%x\n", (val >> 12) & 0x0f);
+	printk("EC: 0x%x\n", val & 0x0fff);
+	if (trident->device != TRIDENT_DEVICE_ID_NX) {
+		val = inl(TRID_REG(trident, CH_DX_CSO_ALPHA_FMS));
+		printk("CSO: 0x%x\n", val >> 16);
+		printk("Alpha: 0x%x\n", (val >> 4) & 0x0fff);
+		printk("FMS: 0x%x\n", val & 0x0f);
+		val = inl(TRID_REG(trident, CH_DX_ESO_DELTA));
+		printk("ESO: 0x%x\n", val >> 16);
+		printk("Delta: 0x%x\n", val & 0xffff);
+		val = inl(TRID_REG(trident, CH_DX_FMC_RVOL_CVOL));
+	} else {		// TRIDENT_DEVICE_ID_NX
+		val = inl(TRID_REG(trident, CH_NX_DELTA_CSO));
+		tmp = (val >> 24) & 0xff;
+		printk("CSO: 0x%x\n", val & 0x00ffffff);
+		val = inl(TRID_REG(trident, CH_NX_DELTA_ESO));
+		tmp |= (val >> 16) & 0xff00;
+		printk("Delta: 0x%x\n", tmp);
+		printk("ESO: 0x%x\n", val & 0x00ffffff);
+		val = inl(TRID_REG(trident, CH_NX_ALPHA_FMS_FMC_RVOL_CVOL));
+		printk("Alpha: 0x%x\n", val >> 20);
+		printk("FMS: 0x%x\n", (val >> 16) & 0x0f);
+	}
+	printk("FMC: 0x%x\n", (val >> 14) & 3);
+	printk("RVol: 0x%x\n", (val >> 7) & 0x7f);
+	printk("CVol: 0x%x\n", val & 0x7f);
+}
+#endif
+
+/*---------------------------------------------------------------------------
+   unsigned short snd_trident_codec_read(ac97_t *ac97, unsigned short reg)
+  
+   Description: This routine will do all of the reading from the external
+                CODEC (AC97).
+  
+   Parameters:  ac97 - ac97 codec structure
+                reg - CODEC register index, from AC97 Hal.
+ 
+   returns:     16 bit value read from the AC97.
+  
+  ---------------------------------------------------------------------------*/
+static unsigned short snd_trident_codec_read(ac97_t *ac97, unsigned short reg)
+{
+	unsigned int data = 0, treg;
+	unsigned short count = 0xffff;
+	unsigned long flags;
+	trident_t *trident = ac97->private_data;
+
+	spin_lock_irqsave(&trident->reg_lock, flags);
+	if (trident->device == TRIDENT_DEVICE_ID_DX) {
+		data = (DX_AC97_BUSY_READ | (reg & 0x000000ff));
+		outl(data, TRID_REG(trident, DX_ACR1_AC97_R));
+		do {
+			data = inl(TRID_REG(trident, DX_ACR1_AC97_R));
+			if ((data & DX_AC97_BUSY_READ) == 0)
+				break;
+		} while (--count);
+	} else if (trident->device == TRIDENT_DEVICE_ID_NX) {
+		data = (NX_AC97_BUSY_READ | (reg & 0x000000ff));
+		treg = ac97->num == 0 ? NX_ACR2_AC97_R_PRIMARY : NX_ACR3_AC97_R_SECONDARY;
+		outl(data, TRID_REG(trident, treg));
+		do {
+			data = inl(TRID_REG(trident, treg));
+			if ((data & 0x00000C00) == 0)
+				break;
+		} while (--count);
+	} else if (trident->device == TRIDENT_DEVICE_ID_SI7018) {
+		data = SI_AC97_BUSY_READ | SI_AC97_AUDIO_BUSY | (reg & 0x000000ff);
+		if (ac97->num == 1)
+			data |= SI_AC97_SECONDARY;
+		outl(data, TRID_REG(trident, SI_AC97_READ));
+		do {
+			data = inl(TRID_REG(trident, SI_AC97_READ));
+			if ((data & (SI_AC97_BUSY_READ)) == 0)
+				break;
+		} while (--count);
+	}
+
+	if (count == 0 && !trident->ac97_detect) {
+		snd_printk("ac97 codec read TIMEOUT [0x%x/0x%x]!!!\n", reg, data);
+		data = 0;
+	}
+
+	spin_unlock_irqrestore(&trident->reg_lock, flags);
+	return ((unsigned short) (data >> 16));
+}
+
+/*---------------------------------------------------------------------------
+   void snd_trident_codec_write(ac97_t *ac97, unsigned short reg, unsigned short wdata)
+  
+   Description: This routine will do all of the writing to the external
+                CODEC (AC97).
+  
+   Parameters:	ac97 - ac97 codec structure
+   	        reg - CODEC register index, from AC97 Hal.
+                data  - Lower 16 bits are the data to write to CODEC.
+  
+   returns:     TRUE if everything went ok, else FALSE.
+  
+  ---------------------------------------------------------------------------*/
+static void snd_trident_codec_write(ac97_t *ac97, unsigned short reg, unsigned short wdata)
+{
+	unsigned int address, data;
+	unsigned short count = 0xffff;
+	unsigned long flags;
+	trident_t *trident = ac97->private_data;
+
+	data = ((unsigned long) wdata) << 16;
+
+	spin_lock_irqsave(&trident->reg_lock, flags);
+	if (trident->device == TRIDENT_DEVICE_ID_DX) {
+		address = DX_ACR0_AC97_W;
+
+		/* read AC-97 write register status */
+		do {
+			if ((inw(TRID_REG(trident, address)) & DX_AC97_BUSY_WRITE) == 0)
+				break;
+		} while (--count);
+
+		data |= (DX_AC97_BUSY_WRITE | (reg & 0x000000ff));
+	} else if (trident->device == TRIDENT_DEVICE_ID_NX) {
+		address = NX_ACR1_AC97_W;
+
+		/* read AC-97 write register status */
+		do {
+			if ((inw(TRID_REG(trident, address)) & NX_AC97_BUSY_WRITE) == 0)
+				break;
+		} while (--count);
+
+		data |= (NX_AC97_BUSY_WRITE | (ac97->num << 8) | (reg & 0x000000ff));
+	} else if (trident->device == TRIDENT_DEVICE_ID_SI7018) {
+		address = SI_AC97_WRITE;
+
+		/* read AC-97 write register status */
+		do {
+			if ((inw(TRID_REG(trident, address)) & (SI_AC97_BUSY_WRITE)) == 0)
+				break;
+		} while (--count);
+
+		data |= SI_AC97_BUSY_WRITE | SI_AC97_AUDIO_BUSY | (reg & 0x000000ff);
+		if (ac97->num == 1)
+			data |= SI_AC97_SECONDARY;
+	} else {
+		address = 0;	/* keep GCC happy */
+		count = 0;	/* return */
+	}
+
+	if (count == 0) {
+		spin_unlock_irqrestore(&trident->reg_lock, flags);
+		return;
+	}
+	outl(data, TRID_REG(trident, address));
+	spin_unlock_irqrestore(&trident->reg_lock, flags);
+}
+
+/*---------------------------------------------------------------------------
+   void snd_trident_enable_eso(trident_t *trident)
+  
+   Description: This routine will enable end of loop interrupts.
+                End of loop interrupts will occur when a running
+                channel reaches ESO.
+                Also enables middle of loop interrupts.
+  
+   Parameters:  trident - pointer to target device class for 4DWave.
+  
+  ---------------------------------------------------------------------------*/
+
+static void snd_trident_enable_eso(trident_t * trident)
+{
+	unsigned int val;
+
+	val = inl(TRID_REG(trident, T4D_LFO_GC_CIR));
+	val |= ENDLP_IE;
+	val |= MIDLP_IE;
+	if (trident->device == TRIDENT_DEVICE_ID_SI7018)
+		val |= BANK_B_EN;
+	outl(val, TRID_REG(trident, T4D_LFO_GC_CIR));
+}
+
+/*---------------------------------------------------------------------------
+   void snd_trident_disable_eso(trident_t *trident)
+  
+   Description: This routine will disable end of loop interrupts.
+                End of loop interrupts will occur when a running
+                channel reaches ESO.
+                Also disables middle of loop interrupts.
+  
+   Parameters:  
+                trident - pointer to target device class for 4DWave.
+  
+   returns:     TRUE if everything went ok, else FALSE.
+  
+  ---------------------------------------------------------------------------*/
+
+static void snd_trident_disable_eso(trident_t * trident)
+{
+	unsigned int tmp;
+
+	tmp = inl(TRID_REG(trident, T4D_LFO_GC_CIR));
+	tmp &= ~ENDLP_IE;
+	tmp &= ~MIDLP_IE;
+	outl(tmp, TRID_REG(trident, T4D_LFO_GC_CIR));
+}
+
+/*---------------------------------------------------------------------------
+   void snd_trident_start_voice(trident_t * trident, unsigned int voice)
+
+    Description: Start a voice, any channel 0 thru 63.
+                 This routine automatically handles the fact that there are
+                 more than 32 channels available.
+
+    Parameters : voice - Voice number 0 thru n.
+                 trident - pointer to target device class for 4DWave.
+
+    Return Value: None.
+
+  ---------------------------------------------------------------------------*/
+
+void snd_trident_start_voice(trident_t * trident, unsigned int voice)
+{
+	unsigned int mask = 1 << (voice & 0x1f);
+	unsigned int reg = (voice & 0x20) ? T4D_START_B : T4D_START_A;
+
+	outl(mask, TRID_REG(trident, reg));
+}
+
+/*---------------------------------------------------------------------------
+   void snd_trident_stop_voice(trident_t * trident, unsigned int voice)
+
+    Description: Stop a voice, any channel 0 thru 63.
+                 This routine automatically handles the fact that there are
+                 more than 32 channels available.
+
+    Parameters : voice - Voice number 0 thru n.
+                 trident - pointer to target device class for 4DWave.
+
+    Return Value: None.
+
+  ---------------------------------------------------------------------------*/
+
+void snd_trident_stop_voice(trident_t * trident, unsigned int voice)
+{
+	unsigned int mask = 1 << (voice & 0x1f);
+	unsigned int reg = (voice & 0x20) ? T4D_STOP_B : T4D_STOP_A;
+
+	outl(mask, TRID_REG(trident, reg));
+}
+
+/*---------------------------------------------------------------------------
+    int snd_trident_allocate_pcm_channel(trident_t *trident)
+  
+    Description: Allocate hardware channel in Bank B (32-63).
+  
+    Parameters :  trident - pointer to target device class for 4DWave.
+  
+    Return Value: hardware channel - 32-63 or -1 when no channel is available
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_allocate_pcm_channel(trident_t * trident)
+{
+	int idx;
+
+	if (trident->ChanPCMcnt >= trident->ChanPCM)
+		return -1;
+	for (idx = 31; idx >= 0; idx--) {
+		if (!(trident->ChanMap[T4D_BANK_B] & (1 << idx))) {
+			trident->ChanMap[T4D_BANK_B] |= 1 << idx;
+			trident->ChanPCMcnt++;
+			return idx + 32;
+		}
+	}
+	return -1;
+}
+
+/*---------------------------------------------------------------------------
+    void snd_trident_free_pcm_channel(int channel)
+  
+    Description: Free hardware channel in Bank B (32-63)
+  
+    Parameters :  trident - pointer to target device class for 4DWave.
+	          channel - hardware channel number 0-63
+  
+    Return Value: none
+  
+  ---------------------------------------------------------------------------*/
+
+static void snd_trident_free_pcm_channel(trident_t *trident, int channel)
+{
+	if (channel < 32 || channel > 63)
+		return;
+	channel &= 0x1f;
+	if (trident->ChanMap[T4D_BANK_B] & (1 << channel)) {
+		trident->ChanMap[T4D_BANK_B] &= ~(1 << channel);
+		trident->ChanPCMcnt--;
+	}
+}
+
+/*---------------------------------------------------------------------------
+    unsigned int snd_trident_allocate_synth_channel(void)
+  
+    Description: Allocate hardware channel in Bank A (0-31).
+  
+    Parameters :  trident - pointer to target device class for 4DWave.
+  
+    Return Value: hardware channel - 0-31 or -1 when no channel is available
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_allocate_synth_channel(trident_t * trident)
+{
+	int idx;
+
+	for (idx = 31; idx >= 0; idx--) {
+		if (!(trident->ChanMap[T4D_BANK_A] & (1 << idx))) {
+			trident->ChanMap[T4D_BANK_A] |= 1 << idx;
+			trident->synth.ChanSynthCount++;
+			return idx;
+		}
+	}
+	return -1;
+}
+
+/*---------------------------------------------------------------------------
+    void snd_trident_free_synth_channel( int channel )
+  
+    Description: Free hardware channel in Bank B (0-31).
+  
+    Parameters :  trident - pointer to target device class for 4DWave.
+	          channel - hardware channel number 0-63
+  
+    Return Value: none
+  
+  ---------------------------------------------------------------------------*/
+
+static void snd_trident_free_synth_channel(trident_t *trident, int channel)
+{
+	if (channel < 0 || channel > 31)
+		return;
+	channel &= 0x1f;
+	if (trident->ChanMap[T4D_BANK_A] & (1 << channel)) {
+		trident->ChanMap[T4D_BANK_A] &= ~(1 << channel);
+		trident->synth.ChanSynthCount--;
+	}
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_write_voice_regs
+  
+   Description: This routine will complete and write the 5 hardware channel
+                registers to hardware.
+  
+   Paramters:   trident - pointer to target device class for 4DWave.
+                voice - synthesizer voice structure
+                Each register field.
+  
+  ---------------------------------------------------------------------------*/
+
+void snd_trident_write_voice_regs(trident_t * trident,
+				  snd_trident_voice_t * voice)
+{
+	unsigned int FmcRvolCvol;
+	unsigned int regs[5];
+
+	regs[1] = voice->LBA;
+	regs[4] = (voice->GVSel << 31) |
+		  ((voice->Pan & 0x0000007f) << 24) |
+		  ((voice->CTRL & 0x0000000f) << 12);
+	FmcRvolCvol = ((voice->FMC & 3) << 14) |
+	              ((voice->RVol & 0x7f) << 7) |
+	              (voice->CVol & 0x7f);
+
+	switch (trident->device) {
+	case TRIDENT_DEVICE_ID_SI7018:
+		regs[4] |= voice->number > 31 ?
+				(voice->Vol & 0x000003ff) :
+				((voice->Vol & 0x00003fc) << (16-2)) |
+				(voice->EC & 0x00000fff);
+		regs[0] = (voice->CSO << 16) | ((voice->Alpha & 0x00000fff) << 4) | (voice->FMS & 0x0000000f);
+		regs[2] = (voice->ESO << 16) | (voice->Delta & 0x0ffff);
+		regs[3] = (voice->Attribute << 16) | FmcRvolCvol;
+		break;
+	case TRIDENT_DEVICE_ID_DX:
+		regs[4] |= ((voice->Vol & 0x000003fc) << (16-2)) |
+			   (voice->EC & 0x00000fff);
+		regs[0] = (voice->CSO << 16) | ((voice->Alpha & 0x00000fff) << 4) | (voice->FMS & 0x0000000f);
+		regs[2] = (voice->ESO << 16) | (voice->Delta & 0x0ffff);
+		regs[3] = FmcRvolCvol;
+		break;
+	case TRIDENT_DEVICE_ID_NX:
+		regs[4] |= ((voice->Vol & 0x000003fc) << (16-2)) |
+			   (voice->EC & 0x00000fff);
+		regs[0] = (voice->Delta << 24) | (voice->CSO & 0x00ffffff);
+		regs[2] = ((voice->Delta << 16) & 0xff000000) | (voice->ESO & 0x00ffffff);
+		regs[3] = (voice->Alpha << 20) | ((voice->FMS & 0x0000000f) << 16) | FmcRvolCvol;
+		break;
+	default:
+		snd_BUG();
+	}
+
+	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));
+	outl(regs[0], TRID_REG(trident, CH_START + 0));
+	outl(regs[1], TRID_REG(trident, CH_START + 4));
+	outl(regs[2], TRID_REG(trident, CH_START + 8));
+	outl(regs[3], TRID_REG(trident, CH_START + 12));
+	outl(regs[4], TRID_REG(trident, CH_START + 16));
+
+#if 0
+	printk("written %i channel:\n", voice->number);
+	printk("  regs[0] = 0x%x/0x%x\n", regs[0], inl(TRID_REG(trident, CH_START + 0)));
+	printk("  regs[1] = 0x%x/0x%x\n", regs[1], inl(TRID_REG(trident, CH_START + 4)));
+	printk("  regs[2] = 0x%x/0x%x\n", regs[2], inl(TRID_REG(trident, CH_START + 8)));
+	printk("  regs[3] = 0x%x/0x%x\n", regs[3], inl(TRID_REG(trident, CH_START + 12)));
+	printk("  regs[4] = 0x%x/0x%x\n", regs[4], inl(TRID_REG(trident, CH_START + 16)));
+#endif
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_write_cso_reg
+  
+   Description: This routine will write the new CSO offset
+                register to hardware.
+  
+   Paramters:   trident - pointer to target device class for 4DWave.
+                voice - synthesizer voice structure
+                CSO - new CSO value
+  
+  ---------------------------------------------------------------------------*/
+
+static void snd_trident_write_cso_reg(trident_t * trident, snd_trident_voice_t * voice, unsigned int CSO)
+{
+	voice->CSO = CSO;
+	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));
+	if (trident->device != TRIDENT_DEVICE_ID_NX) {
+		outw(voice->CSO, TRID_REG(trident, CH_DX_CSO_ALPHA_FMS) + 2);
+	} else {
+		outl((voice->Delta << 24) | (voice->CSO & 0x00ffffff), TRID_REG(trident, CH_NX_DELTA_CSO));
+	}
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_write_eso_reg
+  
+   Description: This routine will write the new ESO offset
+                register to hardware.
+  
+   Paramters:   trident - pointer to target device class for 4DWave.
+                voice - synthesizer voice structure
+                ESO - new ESO value
+  
+  ---------------------------------------------------------------------------*/
+
+static void snd_trident_write_eso_reg(trident_t * trident, snd_trident_voice_t * voice, unsigned int ESO)
+{
+	voice->ESO = ESO;
+	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));
+	if (trident->device != TRIDENT_DEVICE_ID_NX) {
+		outw(voice->ESO, TRID_REG(trident, CH_DX_ESO_DELTA) + 2);
+	} else {
+		outl(((voice->Delta << 16) & 0xff000000) | (voice->ESO & 0x00ffffff), TRID_REG(trident, CH_NX_DELTA_ESO));
+	}
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_write_vol_reg
+  
+   Description: This routine will write the new voice volume
+                register to hardware.
+  
+   Paramters:   trident - pointer to target device class for 4DWave.
+                voice - synthesizer voice structure
+                Vol - new voice volume
+  
+  ---------------------------------------------------------------------------*/
+
+static void snd_trident_write_vol_reg(trident_t * trident, snd_trident_voice_t * voice, unsigned int Vol)
+{
+	voice->Vol = Vol;
+	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));
+	switch (trident->device) {
+	case TRIDENT_DEVICE_ID_DX:
+	case TRIDENT_DEVICE_ID_NX:
+		outb(voice->Vol >> 2, TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC + 2));
+		break;
+	case TRIDENT_DEVICE_ID_SI7018:
+		// printk("voice->Vol = 0x%x\n", voice->Vol);
+		outw((voice->CTRL << 12) | voice->Vol, TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC));
+		break;
+	}
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_write_pan_reg
+  
+   Description: This routine will write the new voice pan
+                register to hardware.
+  
+   Paramters:   trident - pointer to target device class for 4DWave.
+                voice - synthesizer voice structure
+                Pan - new pan value
+  
+  ---------------------------------------------------------------------------*/
+
+static void snd_trident_write_pan_reg(trident_t * trident, snd_trident_voice_t * voice, unsigned int Pan)
+{
+	voice->Pan = Pan;
+	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));
+	outb(((voice->GVSel & 0x01) << 7) | (voice->Pan & 0x7f), TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC + 3));
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_write_rvol_reg
+  
+   Description: This routine will write the new reverb volume
+                register to hardware.
+  
+   Paramters:   trident - pointer to target device class for 4DWave.
+                voice - synthesizer voice structure
+                RVol - new reverb volume
+  
+  ---------------------------------------------------------------------------*/
+
+static void snd_trident_write_rvol_reg(trident_t * trident, snd_trident_voice_t * voice, unsigned int RVol)
+{
+	voice->RVol = RVol;
+	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));
+	outw(((voice->FMC & 0x0003) << 14) | ((voice->RVol & 0x007f) << 7) | (voice->CVol & 0x007f),
+	     TRID_REG(trident, trident->device == TRIDENT_DEVICE_ID_NX ? CH_NX_ALPHA_FMS_FMC_RVOL_CVOL : CH_DX_FMC_RVOL_CVOL));
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_write_cvol_reg
+  
+   Description: This routine will write the new chorus volume
+                register to hardware.
+  
+   Paramters:   trident - pointer to target device class for 4DWave.
+                voice - synthesizer voice structure
+                CVol - new chorus volume
+  
+  ---------------------------------------------------------------------------*/
+
+static void snd_trident_write_cvol_reg(trident_t * trident, snd_trident_voice_t * voice, unsigned int CVol)
+{
+	voice->CVol = CVol;
+	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));
+	outw(((voice->FMC & 0x0003) << 14) | ((voice->RVol & 0x007f) << 7) | (voice->CVol & 0x007f),
+	     TRID_REG(trident, trident->device == TRIDENT_DEVICE_ID_NX ? CH_NX_ALPHA_FMS_FMC_RVOL_CVOL : CH_DX_FMC_RVOL_CVOL));
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_convert_rate
+
+   Description: This routine converts rate in HZ to hardware delta value.
+  
+   Paramters:   trident - pointer to target device class for 4DWave.
+                rate - Real or Virtual channel number.
+  
+   Returns:     Delta value.
+  
+  ---------------------------------------------------------------------------*/
+static unsigned int snd_trident_convert_rate(unsigned int rate)
+{
+	unsigned int delta;
+
+	// We special case 44100 and 8000 since rounding with the equation
+	// does not give us an accurate enough value. For 11025 and 22050
+	// the equation gives us the best answer. All other frequencies will
+	// also use the equation. JDW
+	if (rate == 44100)
+		delta = 0xeb3;
+	else if (rate == 8000)
+		delta = 0x2ab;
+	else if (rate == 48000)
+		delta = 0x1000;
+	else
+		delta = (((rate << 12) + 24000) / 48000) & 0x0000ffff;
+	return delta;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_convert_adc_rate
+
+   Description: This routine converts rate in HZ to hardware delta value.
+  
+   Paramters:   trident - pointer to target device class for 4DWave.
+                rate - Real or Virtual channel number.
+  
+   Returns:     Delta value.
+  
+  ---------------------------------------------------------------------------*/
+static unsigned int snd_trident_convert_adc_rate(unsigned int rate)
+{
+	unsigned int delta;
+
+	// We special case 44100 and 8000 since rounding with the equation
+	// does not give us an accurate enough value. For 11025 and 22050
+	// the equation gives us the best answer. All other frequencies will
+	// also use the equation. JDW
+	if (rate == 44100)
+		delta = 0x116a;
+	else if (rate == 8000)
+		delta = 0x6000;
+	else if (rate == 48000)
+		delta = 0x1000;
+	else
+		delta = ((48000 << 12) / rate) & 0x0000ffff;
+	return delta;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_spurious_threshold
+
+   Description: This routine converts rate in HZ to spurious threshold.
+  
+   Paramters:   trident - pointer to target device class for 4DWave.
+                rate - Real or Virtual channel number.
+  
+   Returns:     Delta value.
+  
+  ---------------------------------------------------------------------------*/
+static unsigned int snd_trident_spurious_threshold(unsigned int rate, unsigned int period_size)
+{
+	unsigned int res = (rate * period_size) / 48000;
+	if (res < 64)
+		res = res / 2;
+	else
+		res -= 32;
+	return res;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_control_mode
+
+   Description: This routine returns a control mode for a PCM channel.
+  
+   Paramters:   trident - pointer to target device class for 4DWave.
+                substream  - PCM substream
+  
+   Returns:     Control value.
+  
+  ---------------------------------------------------------------------------*/
+static unsigned int snd_trident_control_mode(snd_pcm_substream_t *substream)
+{
+	unsigned int CTRL;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	/* set ctrl mode
+	   CTRL default: 8-bit (unsigned) mono, loop mode enabled
+	 */
+	CTRL = 0x00000001;
+	if (snd_pcm_format_width(runtime->format) == 16)
+		CTRL |= 0x00000008;	// 16-bit data
+	if (snd_pcm_format_signed(runtime->format))
+		CTRL |= 0x00000002;	// signed data
+	if (runtime->channels > 1)
+		CTRL |= 0x00000004;	// stereo data
+	return CTRL;
+}
+
+/*
+ *  PCM part
+ */
+
+/*---------------------------------------------------------------------------
+   snd_trident_ioctl
+  
+   Description: Device I/O control handler for playback/capture parameters.
+  
+   Paramters:   substream  - PCM substream class
+                cmd     - what ioctl message to process
+                arg     - additional message infoarg     
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_ioctl(snd_pcm_substream_t * substream,
+			     unsigned int cmd,
+			     void *arg)
+{
+	/* FIXME: it seems that with small periods the behaviour of
+	          trident hardware is unpredictable and interrupt generator
+	          is broken */
+	return snd_pcm_lib_ioctl(substream, cmd, arg);
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_allocate_pcm_mem
+  
+   Description: Allocate PCM ring buffer for given substream
+  
+   Parameters:  substream  - PCM substream class
+		hw_params  - hardware parameters
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_allocate_pcm_mem(snd_pcm_substream_t * substream,
+					snd_pcm_hw_params_t * hw_params)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	int err;
+
+	if ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)
+		return err;
+	if (trident->tlb.entries) {
+		if (err > 0) { /* change */
+			if (voice->memblk)
+				snd_trident_free_pages(trident, voice->memblk);
+			voice->memblk = snd_trident_alloc_pages(trident, substream);
+			if (voice->memblk == NULL)
+				return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_allocate_evoice
+  
+   Description: Allocate extra voice as interrupt generator
+  
+   Parameters:  substream  - PCM substream class
+		hw_params  - hardware parameters
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_allocate_evoice(snd_pcm_substream_t * substream,
+				       snd_pcm_hw_params_t * hw_params)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	snd_trident_voice_t *evoice = voice->extra;
+
+	/* voice management */
+
+	if (params_buffer_size(hw_params) / 2 != params_period_size(hw_params)) {
+		if (evoice == NULL) {
+			evoice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);
+			if (evoice == NULL)
+				return -ENOMEM;
+			voice->extra = evoice;
+			evoice->substream = substream;
+		}
+	} else {
+		if (evoice != NULL) {
+			snd_trident_free_voice(trident, evoice);
+			voice->extra = evoice = NULL;
+		}
+	}
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_hw_params
+  
+   Description: Set the hardware parameters for the playback device.
+  
+   Parameters:  substream  - PCM substream class
+		hw_params  - hardware parameters
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_hw_params(snd_pcm_substream_t * substream,
+				 snd_pcm_hw_params_t * hw_params)
+{
+	int err;
+
+	err = snd_trident_allocate_pcm_mem(substream, hw_params);
+	if (err >= 0)
+		err = snd_trident_allocate_evoice(substream, hw_params);
+	return err;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_playback_hw_free
+  
+   Description: Release the hardware resources for the playback device.
+  
+   Parameters:  substream  - PCM substream class
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_hw_free(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	snd_trident_voice_t *evoice = voice ? voice->extra : NULL;
+
+	if (trident->tlb.entries) {
+		if (voice && voice->memblk) {
+			snd_trident_free_pages(trident, voice->memblk);
+			voice->memblk = NULL;
+		}
+	}
+	snd_pcm_lib_free_pages(substream);
+	if (evoice != NULL) {
+		snd_trident_free_voice(trident, evoice);
+		voice->extra = NULL;
+	}
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_playback_prepare
+  
+   Description: Prepare playback device for playback.
+  
+   Parameters:  substream  - PCM substream class
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_playback_prepare(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	snd_trident_voice_t *evoice = voice->extra;
+	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[substream->number];
+
+	spin_lock_irq(&trident->reg_lock);	
+
+	/* set delta (rate) value */
+	voice->Delta = snd_trident_convert_rate(runtime->rate);
+	voice->spurious_threshold = snd_trident_spurious_threshold(runtime->rate, runtime->period_size);
+
+	/* set Loop Begin Address */
+	if (voice->memblk)
+		voice->LBA = voice->memblk->offset;
+	else
+		voice->LBA = runtime->dma_addr;
+ 
+	voice->CSO = 0;
+	voice->ESO = runtime->buffer_size - 1;	/* in samples */
+	voice->CTRL = snd_trident_control_mode(substream);
+	voice->FMC = 3;
+	voice->GVSel = 1;
+	voice->EC = 0;
+	voice->Alpha = 0;
+	voice->FMS = 0;
+	voice->Vol = mix->vol;
+	voice->RVol = mix->rvol;
+	voice->CVol = mix->cvol;
+	voice->Pan = mix->pan;
+	voice->Attribute = 0;
+#if 0
+	voice->Attribute = (1<<(30-16))|(2<<(26-16))|
+			   (0<<(24-16))|(0x1f<<(19-16));
+#else
+	voice->Attribute = 0;
+#endif
+
+	snd_trident_write_voice_regs(trident, voice);
+
+	if (evoice != NULL) {
+		evoice->Delta = voice->Delta;
+		evoice->spurious_threshold = voice->spurious_threshold;
+		evoice->LBA = voice->LBA;
+		evoice->CSO = 0;
+		evoice->ESO = (runtime->period_size * 2) + 4 - 1; /* in samples */
+		evoice->CTRL = voice->CTRL;
+		evoice->FMC = 3;
+		evoice->GVSel = trident->device == TRIDENT_DEVICE_ID_SI7018 ? 0 : 1;
+		evoice->EC = 0;
+		evoice->Alpha = 0;
+		evoice->FMS = 0;
+		evoice->Vol = 0x3ff;			/* mute */
+		evoice->RVol = evoice->CVol = 0x7f;	/* mute */
+		evoice->Pan = 0x7f;			/* mute */
+#if 0
+		evoice->Attribute = (1<<(30-16))|(2<<(26-16))|
+				    (0<<(24-16))|(0x1f<<(19-16));
+#else
+		evoice->Attribute = 0;
+#endif
+		snd_trident_write_voice_regs(trident, evoice);
+		evoice->isync2 = 1;
+		evoice->isync_mark = runtime->period_size;
+		evoice->ESO = (runtime->period_size * 2) - 1;
+	}
+
+	spin_unlock_irq(&trident->reg_lock);
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_capture_hw_params
+  
+   Description: Set the hardware parameters for the capture device.
+  
+   Parameters:  substream  - PCM substream class
+		hw_params  - hardware parameters
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_capture_hw_params(snd_pcm_substream_t * substream,
+					 snd_pcm_hw_params_t * hw_params)
+{
+	return snd_trident_allocate_pcm_mem(substream, hw_params);
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_capture_prepare
+  
+   Description: Prepare capture device for playback.
+  
+   Parameters:  substream  - PCM substream class
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_capture_prepare(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	unsigned int val, ESO_bytes;
+
+	spin_lock_irq(&trident->reg_lock);
+
+	// Initilize the channel and set channel Mode
+	outb(0, TRID_REG(trident, LEGACY_DMAR15));
+
+	// Set DMA channel operation mode register
+	outb(0x54, TRID_REG(trident, LEGACY_DMAR11));
+
+	// Set channel buffer Address, DMAR0 expects contiguous PCI memory area	
+	voice->LBA = runtime->dma_addr;
+	outl(voice->LBA, TRID_REG(trident, LEGACY_DMAR0));
+	if (voice->memblk)
+		voice->LBA = voice->memblk->offset;
+
+	// set ESO
+	ESO_bytes = snd_pcm_lib_buffer_bytes(substream) - 1;
+	outb((ESO_bytes & 0x00ff0000) >> 16, TRID_REG(trident, LEGACY_DMAR6));
+	outw((ESO_bytes & 0x0000ffff), TRID_REG(trident, LEGACY_DMAR4));
+	ESO_bytes++;
+
+	// Set channel sample rate, 4.12 format
+	val = (((unsigned int) 48000L << 12) + (runtime->rate/2)) / runtime->rate;
+	outw(val, TRID_REG(trident, T4D_SBDELTA_DELTA_R));
+
+	// Set channel interrupt blk length
+	if (snd_pcm_format_width(runtime->format) == 16) {
+		val = (unsigned short) ((ESO_bytes >> 1) - 1);
+	} else {
+		val = (unsigned short) (ESO_bytes - 1);
+	}
+
+	outl((val << 16) | val, TRID_REG(trident, T4D_SBBL_SBCL));
+
+	// Right now, set format and start to run captureing, 
+	// continuous run loop enable.
+	trident->bDMAStart = 0x19;	// 0001 1001b
+
+	if (snd_pcm_format_width(runtime->format) == 16)
+		trident->bDMAStart |= 0x80;
+	if (snd_pcm_format_signed(runtime->format))
+		trident->bDMAStart |= 0x20;
+	if (runtime->channels > 1)
+		trident->bDMAStart |= 0x40;
+
+	// Prepare capture intr channel
+
+	voice->Delta = snd_trident_convert_rate(runtime->rate);
+	voice->spurious_threshold = snd_trident_spurious_threshold(runtime->rate, runtime->period_size);
+	voice->isync = 1;
+	voice->isync_mark = runtime->period_size;
+	voice->isync_max = runtime->buffer_size;
+
+	// Set voice parameters
+	voice->CSO = 0;
+	voice->ESO = voice->isync_ESO = (runtime->period_size * 2) + 6 - 1;
+	voice->CTRL = snd_trident_control_mode(substream);
+	voice->FMC = 3;
+	voice->RVol = 0x7f;
+	voice->CVol = 0x7f;
+	voice->GVSel = 1;
+	voice->Pan = 0x7f;		/* mute */
+	voice->Vol = 0x3ff;		/* mute */
+	voice->EC = 0;
+	voice->Alpha = 0;
+	voice->FMS = 0;
+	voice->Attribute = 0;
+
+	snd_trident_write_voice_regs(trident, voice);
+
+	spin_unlock_irq(&trident->reg_lock);
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_si7018_capture_hw_params
+  
+   Description: Set the hardware parameters for the capture device.
+  
+   Parameters:  substream  - PCM substream class
+		hw_params  - hardware parameters
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_si7018_capture_hw_params(snd_pcm_substream_t * substream,
+						snd_pcm_hw_params_t * hw_params)
+{
+	int err;
+
+	if ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)
+		return err;
+
+	return snd_trident_allocate_evoice(substream, hw_params);
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_si7018_capture_hw_free
+  
+   Description: Release the hardware resources for the capture device.
+  
+   Parameters:  substream  - PCM substream class
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_si7018_capture_hw_free(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	snd_trident_voice_t *evoice = voice ? voice->extra : NULL;
+
+	snd_pcm_lib_free_pages(substream);
+	if (evoice != NULL) {
+		snd_trident_free_voice(trident, evoice);
+		voice->extra = NULL;
+	}
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_si7018_capture_prepare
+  
+   Description: Prepare capture device for playback.
+  
+   Parameters:  substream  - PCM substream class
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_si7018_capture_prepare(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	snd_trident_voice_t *evoice = voice->extra;
+
+	spin_lock_irq(&trident->reg_lock);
+
+	voice->LBA = runtime->dma_addr;
+	voice->Delta = snd_trident_convert_adc_rate(runtime->rate);
+	voice->spurious_threshold = snd_trident_spurious_threshold(runtime->rate, runtime->period_size);
+
+	// Set voice parameters
+	voice->CSO = 0;
+	voice->ESO = runtime->buffer_size - 1;		/* in samples */
+	voice->CTRL = snd_trident_control_mode(substream);
+	voice->FMC = 0;
+	voice->RVol = 0;
+	voice->CVol = 0;
+	voice->GVSel = 1;
+	voice->Pan = T4D_DEFAULT_PCM_PAN;
+	voice->Vol = 0;
+	voice->EC = 0;
+	voice->Alpha = 0;
+	voice->FMS = 0;
+
+	voice->Attribute = (2 << (30-16)) |
+			   (2 << (26-16)) |
+			   (2 << (24-16)) |
+			   (1 << (23-16));
+
+	snd_trident_write_voice_regs(trident, voice);
+
+	if (evoice != NULL) {
+		evoice->Delta = snd_trident_convert_rate(runtime->rate);
+		evoice->spurious_threshold = voice->spurious_threshold;
+		evoice->LBA = voice->LBA;
+		evoice->CSO = 0;
+		evoice->ESO = (runtime->period_size * 2) + 20 - 1; /* in samples, 20 means correction */
+		evoice->CTRL = voice->CTRL;
+		evoice->FMC = 3;
+		evoice->GVSel = 0;
+		evoice->EC = 0;
+		evoice->Alpha = 0;
+		evoice->FMS = 0;
+		evoice->Vol = 0x3ff;			/* mute */
+		evoice->RVol = evoice->CVol = 0x7f;	/* mute */
+		evoice->Pan = 0x7f;			/* mute */
+		evoice->Attribute = 0;
+		snd_trident_write_voice_regs(trident, evoice);
+		evoice->isync2 = 1;
+		evoice->isync_mark = runtime->period_size;
+		evoice->ESO = (runtime->period_size * 2) - 1;
+	}
+	
+	spin_unlock_irq(&trident->reg_lock);
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_foldback_prepare
+  
+   Description: Prepare foldback capture device for playback.
+  
+   Parameters:  substream  - PCM substream class
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_foldback_prepare(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	snd_trident_voice_t *evoice = voice->extra;
+
+	spin_lock_irq(&trident->reg_lock);
+
+	/* Set channel buffer Address */
+	if (voice->memblk)
+		voice->LBA = voice->memblk->offset;
+	else
+		voice->LBA = runtime->dma_addr;
+
+	/* set target ESO for channel */
+	voice->ESO = runtime->buffer_size - 1;	/* in samples */
+
+	/* set sample rate */
+	voice->Delta = 0x1000;
+	voice->spurious_threshold = snd_trident_spurious_threshold(48000, runtime->period_size);
+
+	voice->CSO = 0;
+	voice->CTRL = snd_trident_control_mode(substream);
+	voice->FMC = 3;
+	voice->RVol = 0x7f;
+	voice->CVol = 0x7f;
+	voice->GVSel = 1;
+	voice->Pan = 0x7f;	/* mute */
+	voice->Vol = 0x3ff;	/* mute */
+	voice->EC = 0;
+	voice->Alpha = 0;
+	voice->FMS = 0;
+	voice->Attribute = 0;
+
+	/* set up capture channel */
+	outb(((voice->number & 0x3f) | 0x80), TRID_REG(trident, T4D_RCI + voice->foldback_chan));
+
+	snd_trident_write_voice_regs(trident, voice);
+
+	if (evoice != NULL) {
+		evoice->Delta = voice->Delta;
+		evoice->spurious_threshold = voice->spurious_threshold;
+		evoice->LBA = voice->LBA;
+		evoice->CSO = 0;
+		evoice->ESO = (runtime->period_size * 2) + 4 - 1; /* in samples */
+		evoice->CTRL = voice->CTRL;
+		evoice->FMC = 3;
+		evoice->GVSel = trident->device == TRIDENT_DEVICE_ID_SI7018 ? 0 : 1;
+		evoice->EC = 0;
+		evoice->Alpha = 0;
+		evoice->FMS = 0;
+		evoice->Vol = 0x3ff;			/* mute */
+		evoice->RVol = evoice->CVol = 0x7f;	/* mute */
+		evoice->Pan = 0x7f;			/* mute */
+		evoice->Attribute = 0;
+		snd_trident_write_voice_regs(trident, evoice);
+		evoice->isync2 = 1;
+		evoice->isync_mark = runtime->period_size;
+		evoice->ESO = (runtime->period_size * 2) - 1;
+	}
+
+	spin_unlock_irq(&trident->reg_lock);
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_spdif_hw_params
+  
+   Description: Set the hardware parameters for the spdif device.
+  
+   Parameters:  substream  - PCM substream class
+		hw_params  - hardware parameters
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_spdif_hw_params(snd_pcm_substream_t * substream,
+				       snd_pcm_hw_params_t * hw_params)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	unsigned int old_bits = 0, change = 0;
+	int err;
+
+	err = snd_trident_allocate_pcm_mem(substream, hw_params);
+	if (err < 0)
+		return err;
+
+	if (trident->device == TRIDENT_DEVICE_ID_SI7018) {
+		err = snd_trident_allocate_evoice(substream, hw_params);
+		if (err < 0)
+			return err;
+	}
+
+	/* prepare SPDIF channel */
+	spin_lock_irq(&trident->reg_lock);
+	old_bits = trident->spdif_pcm_bits;
+	if (old_bits & IEC958_AES0_PROFESSIONAL)
+		trident->spdif_pcm_bits &= ~IEC958_AES0_PRO_FS;
+	else
+		trident->spdif_pcm_bits &= ~(IEC958_AES3_CON_FS << 24);
+	if (params_rate(hw_params) >= 48000) {
+		trident->spdif_pcm_ctrl = 0x3c;	// 48000 Hz
+		trident->spdif_pcm_bits |=
+			trident->spdif_bits & IEC958_AES0_PROFESSIONAL ?
+				IEC958_AES0_PRO_FS_48000 :
+				(IEC958_AES3_CON_FS_48000 << 24);
+	}
+	else if (params_rate(hw_params) >= 44100) {
+		trident->spdif_pcm_ctrl = 0x3e;	// 44100 Hz
+		trident->spdif_pcm_bits |=
+			trident->spdif_bits & IEC958_AES0_PROFESSIONAL ?
+				IEC958_AES0_PRO_FS_44100 :
+				(IEC958_AES3_CON_FS_44100 << 24);
+	}
+	else {
+		trident->spdif_pcm_ctrl = 0x3d;	// 32000 Hz
+		trident->spdif_pcm_bits |=
+			trident->spdif_bits & IEC958_AES0_PROFESSIONAL ?
+				IEC958_AES0_PRO_FS_32000 :
+				(IEC958_AES3_CON_FS_32000 << 24);
+	}
+	change = old_bits != trident->spdif_pcm_bits;
+	spin_unlock_irq(&trident->reg_lock);
+
+	if (change)
+		snd_ctl_notify(trident->card, SNDRV_CTL_EVENT_MASK_VALUE, &trident->spdif_pcm_ctl->id);
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_spdif_prepare
+  
+   Description: Prepare SPDIF device for playback.
+  
+   Parameters:  substream  - PCM substream class
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_spdif_prepare(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	snd_trident_voice_t *evoice = voice->extra;
+	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[substream->number];
+	unsigned int RESO, LBAO;
+	unsigned int temp;
+
+	spin_lock_irq(&trident->reg_lock);
+
+	if (trident->device != TRIDENT_DEVICE_ID_SI7018) {
+
+		/* set delta (rate) value */
+		voice->Delta = snd_trident_convert_rate(runtime->rate);
+		voice->spurious_threshold = snd_trident_spurious_threshold(runtime->rate, runtime->period_size);
+
+		/* set Loop Back Address */
+		LBAO = runtime->dma_addr;
+		if (voice->memblk)
+			voice->LBA = voice->memblk->offset;
+		else
+			voice->LBA = LBAO;
+
+		voice->isync = 1;
+		voice->isync3 = 1;
+		voice->isync_mark = runtime->period_size;
+		voice->isync_max = runtime->buffer_size;
+
+		/* set target ESO for channel */
+		RESO = runtime->buffer_size - 1;
+		voice->ESO = voice->isync_ESO = (runtime->period_size * 2) + 6 - 1;
+
+		/* set ctrl mode */
+		voice->CTRL = snd_trident_control_mode(substream);
+
+		voice->FMC = 3;
+		voice->RVol = 0x7f;
+		voice->CVol = 0x7f;
+		voice->GVSel = 1;
+		voice->Pan = 0x7f;
+		voice->Vol = 0x3ff;
+		voice->EC = 0;
+		voice->CSO = 0;
+		voice->Alpha = 0;
+		voice->FMS = 0;
+		voice->Attribute = 0;
+
+		/* prepare surrogate IRQ channel */
+		snd_trident_write_voice_regs(trident, voice);
+
+		outw((RESO & 0xffff), TRID_REG(trident, NX_SPESO));
+		outb((RESO >> 16), TRID_REG(trident, NX_SPESO + 2));
+		outl((LBAO & 0xfffffffc), TRID_REG(trident, NX_SPLBA));
+		outw((voice->CSO & 0xffff), TRID_REG(trident, NX_SPCTRL_SPCSO));
+		outb((voice->CSO >> 16), TRID_REG(trident, NX_SPCTRL_SPCSO + 2));
+
+		/* set SPDIF setting */
+		outb(trident->spdif_pcm_ctrl, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));
+		outl(trident->spdif_pcm_bits, TRID_REG(trident, NX_SPCSTATUS));
+
+	} else {	/* SiS */
+	
+		/* set delta (rate) value */
+		voice->Delta = 0x800;
+		voice->spurious_threshold = snd_trident_spurious_threshold(48000, runtime->period_size);
+
+		/* set Loop Begin Address */
+		if (voice->memblk)
+			voice->LBA = voice->memblk->offset;
+		else
+			voice->LBA = runtime->dma_addr;
+
+		voice->CSO = 0;
+		voice->ESO = runtime->buffer_size - 1;	/* in samples */
+		voice->CTRL = snd_trident_control_mode(substream);
+		voice->FMC = 3;
+		voice->GVSel = 1;
+		voice->EC = 0;
+		voice->Alpha = 0;
+		voice->FMS = 0;
+		voice->Vol = mix->vol;
+		voice->RVol = mix->rvol;
+		voice->CVol = mix->cvol;
+		voice->Pan = mix->pan;
+		voice->Attribute = (1<<(30-16))|(7<<(26-16))|
+				   (0<<(24-16))|(0<<(19-16));
+
+		snd_trident_write_voice_regs(trident, voice);
+
+		if (evoice != NULL) {
+			evoice->Delta = voice->Delta;
+			evoice->spurious_threshold = voice->spurious_threshold;
+			evoice->LBA = voice->LBA;
+			evoice->CSO = 0;
+			evoice->ESO = (runtime->period_size * 2) + 4 - 1; /* in samples */
+			evoice->CTRL = voice->CTRL;
+			evoice->FMC = 3;
+			evoice->GVSel = trident->device == TRIDENT_DEVICE_ID_SI7018 ? 0 : 1;
+			evoice->EC = 0;
+			evoice->Alpha = 0;
+			evoice->FMS = 0;
+			evoice->Vol = 0x3ff;			/* mute */
+			evoice->RVol = evoice->CVol = 0x7f;	/* mute */
+			evoice->Pan = 0x7f;			/* mute */
+			evoice->Attribute = 0;
+			snd_trident_write_voice_regs(trident, evoice);
+			evoice->isync2 = 1;
+			evoice->isync_mark = runtime->period_size;
+			evoice->ESO = (runtime->period_size * 2) - 1;
+		}
+
+		outl(trident->spdif_pcm_bits, TRID_REG(trident, SI_SPDIF_CS));
+		temp = inl(TRID_REG(trident, T4D_LFO_GC_CIR));
+		temp &= ~(1<<19);
+		outl(temp, TRID_REG(trident, T4D_LFO_GC_CIR));
+		temp = inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL));
+		temp |= SPDIF_EN;
+		outl(temp, TRID_REG(trident, SI_SERIAL_INTF_CTRL));
+	}
+
+	spin_unlock_irq(&trident->reg_lock);
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_trigger
+  
+   Description: Start/stop devices
+  
+   Parameters:  substream  - PCM substream class
+   		cmd	- trigger command (STOP, GO)
+  
+   Returns:     Error status
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_trigger(snd_pcm_substream_t *substream,
+			       int cmd)
+				    
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	struct list_head *pos;
+	snd_pcm_substream_t *s;
+	unsigned int what, whati, capture_flag, spdif_flag;
+	snd_trident_voice_t *voice, *evoice;
+	unsigned int val, go;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		go = 1;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		go = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+	what = whati = capture_flag = spdif_flag = 0;
+	spin_lock(&trident->reg_lock);
+	val = inl(TRID_REG(trident, T4D_STIMER)) & 0x00ffffff;
+	snd_pcm_group_for_each(pos, substream) {
+		s = snd_pcm_group_substream_entry(pos);
+		if ((trident_t *) snd_pcm_substream_chip(s) == trident) {
+			voice = (snd_trident_voice_t *) s->runtime->private_data;
+			evoice = voice->extra;
+			what |= 1 << (voice->number & 0x1f);
+			if (evoice == NULL) {
+				whati |= 1 << (voice->number & 0x1f);
+			} else {
+				what |= 1 << (evoice->number & 0x1f);
+				whati |= 1 << (evoice->number & 0x1f);
+				if (go)
+					evoice->stimer = val;
+			}
+			if (go) {
+				voice->running = 1;
+				voice->stimer = val;
+			} else {
+				voice->running = 0;
+			}
+			snd_pcm_trigger_done(s, substream);
+			if (voice->capture)
+				capture_flag = 1;
+			if (voice->spdif)
+				spdif_flag = 1;
+		}
+	}
+	if (spdif_flag) {
+		if (trident->device != TRIDENT_DEVICE_ID_SI7018) {
+			outl(trident->spdif_pcm_bits, TRID_REG(trident, NX_SPCSTATUS));
+			outb(trident->spdif_pcm_ctrl, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));
+		} else {
+			outl(trident->spdif_pcm_bits, TRID_REG(trident, SI_SPDIF_CS));
+			val = inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) | SPDIF_EN;
+			outl(val, TRID_REG(trident, SI_SERIAL_INTF_CTRL));
+		}
+	}
+	if (!go)
+		outl(what, TRID_REG(trident, T4D_STOP_B));
+	val = inl(TRID_REG(trident, T4D_AINTEN_B));
+	if (go) {
+		val |= whati;
+	} else {
+		val &= ~whati;
+	}
+	outl(val, TRID_REG(trident, T4D_AINTEN_B));
+	if (go) {
+		outl(what, TRID_REG(trident, T4D_START_B));
+
+		if (capture_flag && trident->device != TRIDENT_DEVICE_ID_SI7018)
+			outb(trident->bDMAStart, TRID_REG(trident, T4D_SBCTRL_SBE2R_SBDD));
+	} else {
+		if (capture_flag && trident->device != TRIDENT_DEVICE_ID_SI7018)
+			outb(0x00, TRID_REG(trident, T4D_SBCTRL_SBE2R_SBDD));
+	}
+	spin_unlock(&trident->reg_lock);
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_playback_pointer
+  
+   Description: This routine return the playback position
+                
+   Parameters:	substream  - PCM substream class
+
+   Returns:     position of buffer
+  
+  ---------------------------------------------------------------------------*/
+
+static snd_pcm_uframes_t snd_trident_playback_pointer(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	unsigned int cso;
+
+	if (!voice->running)
+		return 0;
+
+	spin_lock(&trident->reg_lock);
+
+	outb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));
+
+	if (trident->device != TRIDENT_DEVICE_ID_NX) {
+		cso = inw(TRID_REG(trident, CH_DX_CSO_ALPHA_FMS + 2));
+	} else {		// ID_4DWAVE_NX
+		cso = (unsigned int) inl(TRID_REG(trident, CH_NX_DELTA_CSO)) & 0x00ffffff;
+	}
+
+	spin_unlock(&trident->reg_lock);
+
+	if (cso >= runtime->buffer_size)
+		cso = 0;
+
+	return cso;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_capture_pointer
+  
+   Description: This routine return the capture position
+                
+   Paramters:   pcm1    - PCM device class
+
+   Returns:     position of buffer
+  
+  ---------------------------------------------------------------------------*/
+
+static snd_pcm_uframes_t snd_trident_capture_pointer(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	unsigned int result;
+
+	if (!voice->running)
+		return 0;
+
+	result = inw(TRID_REG(trident, T4D_SBBL_SBCL));
+	if (runtime->channels > 1)
+		result >>= 1;
+	if (result > 0)
+		result = runtime->buffer_size - result;
+
+	return result;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_spdif_pointer
+  
+   Description: This routine return the SPDIF playback position
+                
+   Parameters:	substream  - PCM substream class
+
+   Returns:     position of buffer
+  
+  ---------------------------------------------------------------------------*/
+
+static snd_pcm_uframes_t snd_trident_spdif_pointer(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	unsigned int result;
+
+	if (!voice->running)
+		return 0;
+
+	result = inl(TRID_REG(trident, NX_SPCTRL_SPCSO)) & 0x00ffffff;
+
+	return result;
+}
+
+/*
+ *  Playback support device description
+ */
+
+static snd_pcm_hardware_t snd_trident_playback =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |
+				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats =		(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE |
+				 SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U16_LE),
+	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(256*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(256*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+/*
+ *  Capture support device description
+ */
+
+static snd_pcm_hardware_t snd_trident_capture =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |
+				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats =		(SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE |
+				 SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U16_LE),
+	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+/*
+ *  Foldback capture support device description
+ */
+
+static snd_pcm_hardware_t snd_trident_foldback =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |
+				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_48000,
+	.rate_min =		48000,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+/*
+ *  SPDIF playback support device description
+ */
+
+static snd_pcm_hardware_t snd_trident_spdif =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |
+				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
+				 SNDRV_PCM_RATE_48000),
+	.rate_min =		32000,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+static snd_pcm_hardware_t snd_trident_spdif_7018 =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_SYNC_START |
+				 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_48000,
+	.rate_min =		48000,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+static void snd_trident_pcm_free_substream(snd_pcm_runtime_t *runtime)
+{
+	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+	trident_t *trident;
+
+	if (voice) {
+		trident = voice->trident;
+		snd_trident_free_voice(trident, voice);
+	}
+}
+
+static int snd_trident_playback_open(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_trident_voice_t *voice;
+
+	voice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);
+	if (voice == NULL)
+		return -EAGAIN;
+	snd_trident_pcm_mixer_build(trident, voice, substream);
+	voice->substream = substream;
+	runtime->private_data = voice;
+	runtime->private_free = snd_trident_pcm_free_substream;
+	runtime->hw = snd_trident_playback;
+	snd_pcm_set_sync(substream);
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 64*1024);
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_playback_close
+  
+   Description: This routine will close the 4DWave playback device. For now 
+                we will simply free the dma transfer buffer.
+                
+   Parameters:	substream  - PCM substream class
+
+  ---------------------------------------------------------------------------*/
+static int snd_trident_playback_close(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_trident_voice_t *voice = (snd_trident_voice_t *) runtime->private_data;
+
+	snd_trident_pcm_mixer_free(trident, voice, substream);
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_spdif_open
+  
+   Description: This routine will open the 4DWave SPDIF device.
+
+   Parameters:	substream  - PCM substream class
+
+   Returns:     status  - success or failure flag
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_spdif_open(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_trident_voice_t *voice;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	
+	voice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);
+	if (voice == NULL)
+		return -EAGAIN;
+	voice->spdif = 1;
+	voice->substream = substream;
+	spin_lock_irq(&trident->reg_lock);
+	trident->spdif_pcm_bits = trident->spdif_bits;
+	spin_unlock_irq(&trident->reg_lock);
+
+	runtime->private_data = voice;
+	runtime->private_free = snd_trident_pcm_free_substream;
+	if (trident->device == TRIDENT_DEVICE_ID_SI7018) {
+		runtime->hw = snd_trident_spdif;
+	} else {
+		runtime->hw = snd_trident_spdif_7018;
+	}
+
+	trident->spdif_pcm_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+	snd_ctl_notify(trident->card, SNDRV_CTL_EVENT_MASK_VALUE |
+		       SNDRV_CTL_EVENT_MASK_INFO, &trident->spdif_pcm_ctl->id);
+
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 64*1024);
+	return 0;
+}
+
+
+/*---------------------------------------------------------------------------
+   snd_trident_spdif_close
+  
+   Description: This routine will close the 4DWave SPDIF device.
+                
+   Parameters:	substream  - PCM substream class
+
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_spdif_close(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	unsigned int temp;
+
+	spin_lock_irq(&trident->reg_lock);
+	// restore default SPDIF setting
+	if (trident->device != TRIDENT_DEVICE_ID_SI7018) {
+		outb(trident->spdif_ctrl, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));
+		outl(trident->spdif_bits, TRID_REG(trident, NX_SPCSTATUS));
+	} else {
+		outl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));
+		temp = inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL));
+		if (trident->spdif_ctrl) {
+			temp |= SPDIF_EN;
+		} else {
+			temp &= ~SPDIF_EN;
+		}
+		outl(temp, TRID_REG(trident, SI_SERIAL_INTF_CTRL));
+	}
+	spin_unlock_irq(&trident->reg_lock);
+	trident->spdif_pcm_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+	snd_ctl_notify(trident->card, SNDRV_CTL_EVENT_MASK_VALUE |
+		       SNDRV_CTL_EVENT_MASK_INFO, &trident->spdif_pcm_ctl->id);
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_capture_open
+  
+   Description: This routine will open the 4DWave capture device.
+
+   Parameters:	substream  - PCM substream class
+
+   Returns:     status  - success or failure flag
+
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_capture_open(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_trident_voice_t *voice;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	voice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);
+	if (voice == NULL)
+		return -EAGAIN;
+	voice->capture = 1;
+	voice->substream = substream;
+	runtime->private_data = voice;
+	runtime->private_free = snd_trident_pcm_free_substream;
+	runtime->hw = snd_trident_capture;
+	snd_pcm_set_sync(substream);
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 64*1024);
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_capture_close
+  
+   Description: This routine will close the 4DWave capture device. For now 
+                we will simply free the dma transfer buffer.
+                
+   Parameters:	substream  - PCM substream class
+
+  ---------------------------------------------------------------------------*/
+static int snd_trident_capture_close(snd_pcm_substream_t * substream)
+{
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_foldback_open
+  
+   Description: This routine will open the 4DWave foldback capture device.
+
+   Parameters:	substream  - PCM substream class
+
+   Returns:     status  - success or failure flag
+
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_foldback_open(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_trident_voice_t *voice;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	voice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);
+	if (voice == NULL)
+		return -EAGAIN;
+	voice->foldback_chan = substream->number;
+	voice->substream = substream;
+	runtime->private_data = voice;
+	runtime->private_free = snd_trident_pcm_free_substream;
+	runtime->hw = snd_trident_foldback;
+	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 64*1024);
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_foldback_close
+  
+   Description: This routine will close the 4DWave foldback capture device. 
+		For now we will simply free the dma transfer buffer.
+                
+   Parameters:	substream  - PCM substream class
+
+  ---------------------------------------------------------------------------*/
+static int snd_trident_foldback_close(snd_pcm_substream_t * substream)
+{
+	trident_t *trident = snd_pcm_substream_chip(substream);
+	snd_trident_voice_t *voice;
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	voice = (snd_trident_voice_t *) runtime->private_data;
+	
+	/* stop capture channel */
+	spin_lock_irq(&trident->reg_lock);
+	outb(0x00, TRID_REG(trident, T4D_RCI + voice->foldback_chan));
+	spin_unlock_irq(&trident->reg_lock);
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   PCM operations
+  ---------------------------------------------------------------------------*/
+
+static snd_pcm_ops_t snd_trident_playback_ops = {
+	.open =		snd_trident_playback_open,
+	.close =	snd_trident_playback_close,
+	.ioctl =	snd_trident_ioctl,
+	.hw_params =	snd_trident_hw_params,
+	.hw_free =	snd_trident_hw_free,
+	.prepare =	snd_trident_playback_prepare,
+	.trigger =	snd_trident_trigger,
+	.pointer =	snd_trident_playback_pointer,
+};
+
+static snd_pcm_ops_t snd_trident_nx_playback_ops = {
+	.open =		snd_trident_playback_open,
+	.close =	snd_trident_playback_close,
+	.ioctl =	snd_trident_ioctl,
+	.hw_params =	snd_trident_hw_params,
+	.hw_free =	snd_trident_hw_free,
+	.prepare =	snd_trident_playback_prepare,
+	.trigger =	snd_trident_trigger,
+	.pointer =	snd_trident_playback_pointer,
+	.page =		snd_pcm_sgbuf_ops_page,
+};
+
+static snd_pcm_ops_t snd_trident_capture_ops = {
+	.open =		snd_trident_capture_open,
+	.close =	snd_trident_capture_close,
+	.ioctl =	snd_trident_ioctl,
+	.hw_params =	snd_trident_capture_hw_params,
+	.hw_free =	snd_trident_hw_free,
+	.prepare =	snd_trident_capture_prepare,
+	.trigger =	snd_trident_trigger,
+	.pointer =	snd_trident_capture_pointer,
+};
+
+static snd_pcm_ops_t snd_trident_si7018_capture_ops = {
+	.open =		snd_trident_capture_open,
+	.close =	snd_trident_capture_close,
+	.ioctl =	snd_trident_ioctl,
+	.hw_params =	snd_trident_si7018_capture_hw_params,
+	.hw_free =	snd_trident_si7018_capture_hw_free,
+	.prepare =	snd_trident_si7018_capture_prepare,
+	.trigger =	snd_trident_trigger,
+	.pointer =	snd_trident_playback_pointer,
+};
+
+static snd_pcm_ops_t snd_trident_foldback_ops = {
+	.open =		snd_trident_foldback_open,
+	.close =	snd_trident_foldback_close,
+	.ioctl =	snd_trident_ioctl,
+	.hw_params =	snd_trident_hw_params,
+	.hw_free =	snd_trident_hw_free,
+	.prepare =	snd_trident_foldback_prepare,
+	.trigger =	snd_trident_trigger,
+	.pointer =	snd_trident_playback_pointer,
+};
+
+static snd_pcm_ops_t snd_trident_nx_foldback_ops = {
+	.open =		snd_trident_foldback_open,
+	.close =	snd_trident_foldback_close,
+	.ioctl =	snd_trident_ioctl,
+	.hw_params =	snd_trident_hw_params,
+	.hw_free =	snd_trident_hw_free,
+	.prepare =	snd_trident_foldback_prepare,
+	.trigger =	snd_trident_trigger,
+	.pointer =	snd_trident_playback_pointer,
+	.page =		snd_pcm_sgbuf_ops_page,
+};
+
+static snd_pcm_ops_t snd_trident_spdif_ops = {
+	.open =		snd_trident_spdif_open,
+	.close =	snd_trident_spdif_close,
+	.ioctl =	snd_trident_ioctl,
+	.hw_params =	snd_trident_spdif_hw_params,
+	.hw_free =	snd_trident_hw_free,
+	.prepare =	snd_trident_spdif_prepare,
+	.trigger =	snd_trident_trigger,
+	.pointer =	snd_trident_spdif_pointer,
+};
+
+static snd_pcm_ops_t snd_trident_spdif_7018_ops = {
+	.open =		snd_trident_spdif_open,
+	.close =	snd_trident_spdif_close,
+	.ioctl =	snd_trident_ioctl,
+	.hw_params =	snd_trident_spdif_hw_params,
+	.hw_free =	snd_trident_hw_free,
+	.prepare =	snd_trident_spdif_prepare,
+	.trigger =	snd_trident_trigger,
+	.pointer =	snd_trident_playback_pointer,
+};
+
+/*---------------------------------------------------------------------------
+   snd_trident_pcm_free
+  
+   Description: This routine release the 4DWave private data.
+                
+   Paramters:   private_data - pointer to 4DWave device info.
+
+   Returns:     None
+  
+  ---------------------------------------------------------------------------*/
+static void snd_trident_pcm_free(snd_pcm_t *pcm)
+{
+	trident_t *trident = pcm->private_data;
+	trident->pcm = NULL;
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static void snd_trident_foldback_pcm_free(snd_pcm_t *pcm)
+{
+	trident_t *trident = pcm->private_data;
+	trident->foldback = NULL;
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static void snd_trident_spdif_pcm_free(snd_pcm_t *pcm)
+{
+	trident_t *trident = pcm->private_data;
+	trident->spdif = NULL;
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_pcm
+  
+   Description: This routine registers the 4DWave device for PCM support.
+                
+   Paramters:   trident - pointer to target device class for 4DWave.
+
+   Returns:     None
+  
+  ---------------------------------------------------------------------------*/
+
+int __devinit snd_trident_pcm(trident_t * trident, int device, snd_pcm_t ** rpcm)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	if (rpcm)
+		*rpcm = NULL;
+	if ((err = snd_pcm_new(trident->card, "trident_dx_nx", device, trident->ChanPCM, 1, &pcm)) < 0)
+		return err;
+
+	pcm->private_data = trident;
+	pcm->private_free = snd_trident_pcm_free;
+
+	if (trident->tlb.entries) {
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_nx_playback_ops);
+	} else {
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_playback_ops);
+	}
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+			trident->device != TRIDENT_DEVICE_ID_SI7018 ?
+			&snd_trident_capture_ops :
+			&snd_trident_si7018_capture_ops);
+
+	pcm->info_flags = 0;
+	pcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;
+	strcpy(pcm->name, "Trident 4DWave");
+	trident->pcm = pcm;
+
+	if (trident->tlb.entries) {
+		snd_pcm_substream_t *substream;
+		for (substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; substream; substream = substream->next)
+			snd_pcm_lib_preallocate_pages(substream, SNDRV_DMA_TYPE_DEV_SG,
+						      snd_dma_pci_data(trident->pci),
+						      64*1024, 128*1024);
+		snd_pcm_lib_preallocate_pages(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,
+					      SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci),
+					      64*1024, 128*1024);
+	} else {
+		snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+						      snd_dma_pci_data(trident->pci), 64*1024, 128*1024);
+	}
+
+	if (rpcm)
+		*rpcm = pcm;
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_foldback_pcm
+  
+   Description: This routine registers the 4DWave device for foldback PCM support.
+                
+   Paramters:   trident - pointer to target device class for 4DWave.
+
+   Returns:     None
+  
+  ---------------------------------------------------------------------------*/
+
+int __devinit snd_trident_foldback_pcm(trident_t * trident, int device, snd_pcm_t ** rpcm)
+{
+	snd_pcm_t *foldback;
+	int err;
+	int num_chan = 3;
+	snd_pcm_substream_t *substream;
+
+	if (rpcm)
+		*rpcm = NULL;
+	if (trident->device == TRIDENT_DEVICE_ID_NX)
+		num_chan = 4;
+	if ((err = snd_pcm_new(trident->card, "trident_dx_nx", device, 0, num_chan, &foldback)) < 0)
+		return err;
+
+	foldback->private_data = trident;
+	foldback->private_free = snd_trident_foldback_pcm_free;
+	if (trident->tlb.entries)
+		snd_pcm_set_ops(foldback, SNDRV_PCM_STREAM_CAPTURE, &snd_trident_nx_foldback_ops);
+	else
+		snd_pcm_set_ops(foldback, SNDRV_PCM_STREAM_CAPTURE, &snd_trident_foldback_ops);
+	foldback->info_flags = 0;
+	strcpy(foldback->name, "Trident 4DWave");
+	substream = foldback->streams[SNDRV_PCM_STREAM_CAPTURE].substream;
+	strcpy(substream->name, "Front Mixer");
+	substream = substream->next;
+	strcpy(substream->name, "Reverb Mixer");
+	substream = substream->next;
+	strcpy(substream->name, "Chorus Mixer");
+	if (num_chan == 4) {
+		substream = substream->next;
+		strcpy(substream->name, "Second AC'97 ADC");
+	}
+	trident->foldback = foldback;
+
+	if (trident->tlb.entries)
+		snd_pcm_lib_preallocate_pages_for_all(foldback, SNDRV_DMA_TYPE_DEV_SG,
+						      snd_dma_pci_data(trident->pci), 0, 128*1024);
+	else
+		snd_pcm_lib_preallocate_pages_for_all(foldback, SNDRV_DMA_TYPE_DEV,
+						      snd_dma_pci_data(trident->pci), 64*1024, 128*1024);
+
+	if (rpcm)
+		*rpcm = foldback;
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_spdif
+  
+   Description: This routine registers the 4DWave-NX device for SPDIF support.
+                
+   Paramters:   trident - pointer to target device class for 4DWave-NX.
+
+   Returns:     None
+  
+  ---------------------------------------------------------------------------*/
+
+int __devinit snd_trident_spdif_pcm(trident_t * trident, int device, snd_pcm_t ** rpcm)
+{
+	snd_pcm_t *spdif;
+	int err;
+
+	if (rpcm)
+		*rpcm = NULL;
+	if ((err = snd_pcm_new(trident->card, "trident_dx_nx IEC958", device, 1, 0, &spdif)) < 0)
+		return err;
+
+	spdif->private_data = trident;
+	spdif->private_free = snd_trident_spdif_pcm_free;
+	if (trident->device != TRIDENT_DEVICE_ID_SI7018) {
+		snd_pcm_set_ops(spdif, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_spdif_ops);
+	} else {
+		snd_pcm_set_ops(spdif, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_spdif_7018_ops);
+	}
+	spdif->info_flags = 0;
+	strcpy(spdif->name, "Trident 4DWave IEC958");
+	trident->spdif = spdif;
+
+	snd_pcm_lib_preallocate_pages_for_all(spdif, SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci), 64*1024, 128*1024);
+
+	if (rpcm)
+		*rpcm = spdif;
+	return 0;
+}
+
+/*
+ *  Mixer part
+ */
+
+
+/*---------------------------------------------------------------------------
+    snd_trident_spdif_control
+
+    Description: enable/disable S/PDIF out from ac97 mixer
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_spdif_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_trident_spdif_control_get(snd_kcontrol_t * kcontrol,
+					 snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	unsigned char val;
+
+	spin_lock_irq(&trident->reg_lock);
+	val = trident->spdif_ctrl;
+	ucontrol->value.integer.value[0] = val == kcontrol->private_value;
+	spin_unlock_irq(&trident->reg_lock);
+	return 0;
+}
+
+static int snd_trident_spdif_control_put(snd_kcontrol_t * kcontrol,
+					 snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	unsigned char val;
+	int change;
+
+	val = ucontrol->value.integer.value[0] ? (unsigned char) kcontrol->private_value : 0x00;
+	spin_lock_irq(&trident->reg_lock);
+	/* S/PDIF C Channel bits 0-31 : 48khz, SCMS disabled */
+	change = trident->spdif_ctrl != val;
+	trident->spdif_ctrl = val;
+	if (trident->device != TRIDENT_DEVICE_ID_SI7018) {
+		if ((inb(TRID_REG(trident, NX_SPCTRL_SPCSO + 3)) & 0x10) == 0) {
+			outl(trident->spdif_bits, TRID_REG(trident, NX_SPCSTATUS));
+			outb(trident->spdif_ctrl, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));
+		}
+	} else {
+		if (trident->spdif == NULL) {
+			unsigned int temp;
+			outl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));
+			temp = inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) & ~SPDIF_EN;
+			if (val)
+				temp |= SPDIF_EN;
+			outl(temp, TRID_REG(trident, SI_SERIAL_INTF_CTRL));
+		}
+	}
+	spin_unlock_irq(&trident->reg_lock);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_trident_spdif_control __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,SWITCH),
+	.info =		snd_trident_spdif_control_info,
+	.get =		snd_trident_spdif_control_get,
+	.put =		snd_trident_spdif_control_put,
+	.private_value = 0x28,
+};
+
+/*---------------------------------------------------------------------------
+    snd_trident_spdif_default
+
+    Description: put/get the S/PDIF default settings
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_spdif_default_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_trident_spdif_default_get(snd_kcontrol_t * kcontrol,
+					 snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&trident->reg_lock);
+	ucontrol->value.iec958.status[0] = (trident->spdif_bits >> 0) & 0xff;
+	ucontrol->value.iec958.status[1] = (trident->spdif_bits >> 8) & 0xff;
+	ucontrol->value.iec958.status[2] = (trident->spdif_bits >> 16) & 0xff;
+	ucontrol->value.iec958.status[3] = (trident->spdif_bits >> 24) & 0xff;
+	spin_unlock_irq(&trident->reg_lock);
+	return 0;
+}
+
+static int snd_trident_spdif_default_put(snd_kcontrol_t * kcontrol,
+					 snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change;
+
+	val = (ucontrol->value.iec958.status[0] << 0) |
+	      (ucontrol->value.iec958.status[1] << 8) |
+	      (ucontrol->value.iec958.status[2] << 16) |
+	      (ucontrol->value.iec958.status[3] << 24);
+	spin_lock_irq(&trident->reg_lock);
+	change = trident->spdif_bits != val;
+	trident->spdif_bits = val;
+	if (trident->device != TRIDENT_DEVICE_ID_SI7018) {
+		if ((inb(TRID_REG(trident, NX_SPCTRL_SPCSO + 3)) & 0x10) == 0)
+			outl(trident->spdif_bits, TRID_REG(trident, NX_SPCSTATUS));
+	} else {
+		if (trident->spdif == NULL)
+			outl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));
+	}
+	spin_unlock_irq(&trident->reg_lock);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_trident_spdif_default __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,DEFAULT),
+	.info =		snd_trident_spdif_default_info,
+	.get =		snd_trident_spdif_default_get,
+	.put =		snd_trident_spdif_default_put
+};
+
+/*---------------------------------------------------------------------------
+    snd_trident_spdif_mask
+
+    Description: put/get the S/PDIF mask
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_spdif_mask_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_trident_spdif_mask_get(snd_kcontrol_t * kcontrol,
+				      snd_ctl_elem_value_t * ucontrol)
+{
+	ucontrol->value.iec958.status[0] = 0xff;
+	ucontrol->value.iec958.status[1] = 0xff;
+	ucontrol->value.iec958.status[2] = 0xff;
+	ucontrol->value.iec958.status[3] = 0xff;
+	return 0;
+}
+
+static snd_kcontrol_new_t snd_trident_spdif_mask __devinitdata =
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READ,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,MASK),
+	.info =		snd_trident_spdif_mask_info,
+	.get =		snd_trident_spdif_mask_get,
+};
+
+/*---------------------------------------------------------------------------
+    snd_trident_spdif_stream
+
+    Description: put/get the S/PDIF stream settings
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_spdif_stream_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_trident_spdif_stream_get(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&trident->reg_lock);
+	ucontrol->value.iec958.status[0] = (trident->spdif_pcm_bits >> 0) & 0xff;
+	ucontrol->value.iec958.status[1] = (trident->spdif_pcm_bits >> 8) & 0xff;
+	ucontrol->value.iec958.status[2] = (trident->spdif_pcm_bits >> 16) & 0xff;
+	ucontrol->value.iec958.status[3] = (trident->spdif_pcm_bits >> 24) & 0xff;
+	spin_unlock_irq(&trident->reg_lock);
+	return 0;
+}
+
+static int snd_trident_spdif_stream_put(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change;
+
+	val = (ucontrol->value.iec958.status[0] << 0) |
+	      (ucontrol->value.iec958.status[1] << 8) |
+	      (ucontrol->value.iec958.status[2] << 16) |
+	      (ucontrol->value.iec958.status[3] << 24);
+	spin_lock_irq(&trident->reg_lock);
+	change = trident->spdif_pcm_bits != val;
+	trident->spdif_pcm_bits = val;
+	if (trident->spdif != NULL) {
+		if (trident->device != TRIDENT_DEVICE_ID_SI7018) {
+			outl(trident->spdif_pcm_bits, TRID_REG(trident, NX_SPCSTATUS));
+		} else {
+			outl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));
+		}
+	}
+	spin_unlock_irq(&trident->reg_lock);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_trident_spdif_stream __devinitdata =
+{
+	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
+	.iface =	SNDRV_CTL_ELEM_IFACE_PCM,
+	.name =         SNDRV_CTL_NAME_IEC958("",PLAYBACK,PCM_STREAM),
+	.info =		snd_trident_spdif_stream_info,
+	.get =		snd_trident_spdif_stream_get,
+	.put =		snd_trident_spdif_stream_put
+};
+
+/*---------------------------------------------------------------------------
+    snd_trident_ac97_control
+
+    Description: enable/disable rear path for ac97
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_ac97_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_trident_ac97_control_get(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	unsigned char val;
+
+	spin_lock_irq(&trident->reg_lock);
+	val = trident->ac97_ctrl = inl(TRID_REG(trident, NX_ACR0_AC97_COM_STAT));
+	ucontrol->value.integer.value[0] = (val & (1 << kcontrol->private_value)) ? 1 : 0;
+	spin_unlock_irq(&trident->reg_lock);
+	return 0;
+}
+
+static int snd_trident_ac97_control_put(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	unsigned char val;
+	int change = 0;
+
+	spin_lock_irq(&trident->reg_lock);
+	val = trident->ac97_ctrl = inl(TRID_REG(trident, NX_ACR0_AC97_COM_STAT));
+	val &= ~(1 << kcontrol->private_value);
+	if (ucontrol->value.integer.value[0])
+		val |= 1 << kcontrol->private_value;
+	change = val != trident->ac97_ctrl;
+	trident->ac97_ctrl = val;
+	outl(trident->ac97_ctrl = val, TRID_REG(trident, NX_ACR0_AC97_COM_STAT));
+	spin_unlock_irq(&trident->reg_lock);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_trident_ac97_rear_control __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "Rear Path",
+	.info =		snd_trident_ac97_control_info,
+	.get =		snd_trident_ac97_control_get,
+	.put =		snd_trident_ac97_control_put,
+	.private_value = 4,
+};
+
+/*---------------------------------------------------------------------------
+    snd_trident_vol_control
+
+    Description: wave & music volume control
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_vol_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 255;
+	return 0;
+}
+
+static int snd_trident_vol_control_get(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+
+	val = trident->musicvol_wavevol;
+	ucontrol->value.integer.value[0] = 255 - ((val >> kcontrol->private_value) & 0xff);
+	ucontrol->value.integer.value[1] = 255 - ((val >> (kcontrol->private_value + 8)) & 0xff);
+	return 0;
+}
+
+static int snd_trident_vol_control_put(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	unsigned int val;
+	int change = 0;
+
+	spin_lock_irq(&trident->reg_lock);
+	val = trident->musicvol_wavevol;
+	val &= ~(0xffff << kcontrol->private_value);
+	val |= ((255 - (ucontrol->value.integer.value[0] & 0xff)) |
+	        ((255 - (ucontrol->value.integer.value[1] & 0xff)) << 8)) << kcontrol->private_value;
+	change = val != trident->musicvol_wavevol;
+	outl(trident->musicvol_wavevol = val, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));
+	spin_unlock_irq(&trident->reg_lock);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_trident_vol_music_control __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "Music Playback Volume",
+	.info =		snd_trident_vol_control_info,
+	.get =		snd_trident_vol_control_get,
+	.put =		snd_trident_vol_control_put,
+	.private_value = 16,
+};
+
+static snd_kcontrol_new_t snd_trident_vol_wave_control __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "Wave Playback Volume",
+	.info =		snd_trident_vol_control_info,
+	.get =		snd_trident_vol_control_get,
+	.put =		snd_trident_vol_control_put,
+	.private_value = 0,
+};
+
+/*---------------------------------------------------------------------------
+    snd_trident_pcm_vol_control
+
+    Description: PCM front volume control
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_pcm_vol_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 255;
+	if (trident->device == TRIDENT_DEVICE_ID_SI7018)
+		uinfo->value.integer.max = 1023;
+	return 0;
+}
+
+static int snd_trident_pcm_vol_control_get(snd_kcontrol_t * kcontrol,
+					   snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+
+	if (trident->device == TRIDENT_DEVICE_ID_SI7018) {
+		ucontrol->value.integer.value[0] = 1023 - mix->vol;
+	} else {
+		ucontrol->value.integer.value[0] = 255 - (mix->vol>>2);
+	}
+	return 0;
+}
+
+static int snd_trident_pcm_vol_control_put(snd_kcontrol_t * kcontrol,
+					   snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+	unsigned int val;
+	int change = 0;
+
+	if (trident->device == TRIDENT_DEVICE_ID_SI7018) {
+		val = 1023 - (ucontrol->value.integer.value[0] & 1023);
+	} else {
+		val = (255 - (ucontrol->value.integer.value[0] & 255)) << 2;
+	}
+	spin_lock_irq(&trident->reg_lock);
+	change = val != mix->vol;
+	mix->vol = val;
+	if (mix->voice != NULL)
+		snd_trident_write_vol_reg(trident, mix->voice, val);
+	spin_unlock_irq(&trident->reg_lock);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_trident_pcm_vol_control __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "PCM Front Playback Volume",
+	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
+	.count =	32,
+	.info =		snd_trident_pcm_vol_control_info,
+	.get =		snd_trident_pcm_vol_control_get,
+	.put =		snd_trident_pcm_vol_control_put,
+};
+
+/*---------------------------------------------------------------------------
+    snd_trident_pcm_pan_control
+
+    Description: PCM front pan control
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_pcm_pan_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 127;
+	return 0;
+}
+
+static int snd_trident_pcm_pan_control_get(snd_kcontrol_t * kcontrol,
+					   snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+
+	ucontrol->value.integer.value[0] = mix->pan;
+	if (ucontrol->value.integer.value[0] & 0x40) {
+		ucontrol->value.integer.value[0] = (0x3f - (ucontrol->value.integer.value[0] & 0x3f));
+	} else {
+		ucontrol->value.integer.value[0] |= 0x40;
+	}
+	return 0;
+}
+
+static int snd_trident_pcm_pan_control_put(snd_kcontrol_t * kcontrol,
+					   snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+	unsigned char val;
+	int change = 0;
+
+	if (ucontrol->value.integer.value[0] & 0x40)
+		val = ucontrol->value.integer.value[0] & 0x3f;
+	else
+		val = (0x3f - (ucontrol->value.integer.value[0] & 0x3f)) | 0x40;
+	spin_lock_irq(&trident->reg_lock);
+	change = val != mix->pan;
+	mix->pan = val;
+	if (mix->voice != NULL)
+		snd_trident_write_pan_reg(trident, mix->voice, val);
+	spin_unlock_irq(&trident->reg_lock);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_trident_pcm_pan_control __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "PCM Pan Playback Control",
+	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
+	.count =	32,
+	.info =		snd_trident_pcm_pan_control_info,
+	.get =		snd_trident_pcm_pan_control_get,
+	.put =		snd_trident_pcm_pan_control_put,
+};
+
+/*---------------------------------------------------------------------------
+    snd_trident_pcm_rvol_control
+
+    Description: PCM reverb volume control
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_pcm_rvol_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 127;
+	return 0;
+}
+
+static int snd_trident_pcm_rvol_control_get(snd_kcontrol_t * kcontrol,
+					    snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+
+	ucontrol->value.integer.value[0] = 127 - mix->rvol;
+	return 0;
+}
+
+static int snd_trident_pcm_rvol_control_put(snd_kcontrol_t * kcontrol,
+					    snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+	unsigned short val;
+	int change = 0;
+
+	val = 0x7f - (ucontrol->value.integer.value[0] & 0x7f);
+	spin_lock_irq(&trident->reg_lock);
+	change = val != mix->rvol;
+	mix->rvol = val;
+	if (mix->voice != NULL)
+		snd_trident_write_rvol_reg(trident, mix->voice, val);
+	spin_unlock_irq(&trident->reg_lock);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_trident_pcm_rvol_control __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "PCM Reverb Playback Volume",
+	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
+	.count = 	32,
+	.info =		snd_trident_pcm_rvol_control_info,
+	.get =		snd_trident_pcm_rvol_control_get,
+	.put =		snd_trident_pcm_rvol_control_put,
+};
+
+/*---------------------------------------------------------------------------
+    snd_trident_pcm_cvol_control
+
+    Description: PCM chorus volume control
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_pcm_cvol_control_info(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 127;
+	return 0;
+}
+
+static int snd_trident_pcm_cvol_control_get(snd_kcontrol_t * kcontrol,
+					    snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+
+	ucontrol->value.integer.value[0] = 127 - mix->cvol;
+	return 0;
+}
+
+static int snd_trident_pcm_cvol_control_put(snd_kcontrol_t * kcontrol,
+					    snd_ctl_elem_value_t * ucontrol)
+{
+	trident_t *trident = snd_kcontrol_chip(kcontrol);
+	snd_trident_pcm_mixer_t *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];
+	unsigned short val;
+	int change = 0;
+
+	val = 0x7f - (ucontrol->value.integer.value[0] & 0x7f);
+	spin_lock_irq(&trident->reg_lock);
+	change = val != mix->cvol;
+	mix->cvol = val;
+	if (mix->voice != NULL)
+		snd_trident_write_cvol_reg(trident, mix->voice, val);
+	spin_unlock_irq(&trident->reg_lock);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_trident_pcm_cvol_control __devinitdata =
+{
+	.iface =	SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name =         "PCM Chorus Playback Volume",
+	.access =	SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE,
+	.count =	32,
+	.info =		snd_trident_pcm_cvol_control_info,
+	.get =		snd_trident_pcm_cvol_control_get,
+	.put =		snd_trident_pcm_cvol_control_put,
+};
+
+static void snd_trident_notify_pcm_change1(snd_card_t * card, snd_kcontrol_t *kctl, int num, int activate)
+{
+	snd_ctl_elem_id_t id;
+
+	snd_runtime_check(kctl != NULL, return);
+	if (activate)
+		kctl->vd[num].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+	else
+		kctl->vd[num].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+	snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE |
+		       SNDRV_CTL_EVENT_MASK_INFO,
+		       snd_ctl_build_ioff(&id, kctl, num));
+}
+
+static void snd_trident_notify_pcm_change(trident_t *trident, snd_trident_pcm_mixer_t *tmix, int num, int activate)
+{
+	snd_trident_notify_pcm_change1(trident->card, trident->ctl_vol, num, activate);
+	snd_trident_notify_pcm_change1(trident->card, trident->ctl_pan, num, activate);
+	snd_trident_notify_pcm_change1(trident->card, trident->ctl_rvol, num, activate);
+	snd_trident_notify_pcm_change1(trident->card, trident->ctl_cvol, num, activate);
+}
+
+static int snd_trident_pcm_mixer_build(trident_t *trident, snd_trident_voice_t *voice, snd_pcm_substream_t *substream)
+{
+	snd_trident_pcm_mixer_t *tmix;
+
+	snd_assert(trident != NULL && voice != NULL && substream != NULL, return -EINVAL);
+	tmix = &trident->pcm_mixer[substream->number];
+	tmix->voice = voice;
+	tmix->vol = T4D_DEFAULT_PCM_VOL;
+	tmix->pan = T4D_DEFAULT_PCM_PAN;
+	tmix->rvol = T4D_DEFAULT_PCM_RVOL;
+	tmix->cvol = T4D_DEFAULT_PCM_CVOL;
+	snd_trident_notify_pcm_change(trident, tmix, substream->number, 1);
+	return 0;
+}
+
+static int snd_trident_pcm_mixer_free(trident_t *trident, snd_trident_voice_t *voice, snd_pcm_substream_t *substream)
+{
+	snd_trident_pcm_mixer_t *tmix;
+
+	snd_assert(trident != NULL && substream != NULL, return -EINVAL);
+	tmix = &trident->pcm_mixer[substream->number];
+	tmix->voice = NULL;
+	snd_trident_notify_pcm_change(trident, tmix, substream->number, 0);
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_mixer
+  
+   Description: This routine registers the 4DWave device for mixer support.
+                
+   Paramters:   trident - pointer to target device class for 4DWave.
+
+   Returns:     None
+  
+  ---------------------------------------------------------------------------*/
+
+static int __devinit snd_trident_mixer(trident_t * trident, int pcm_spdif_device)
+{
+	ac97_template_t _ac97;
+	snd_card_t * card = trident->card;
+	snd_kcontrol_t *kctl;
+	snd_ctl_elem_value_t *uctl;
+	int idx, err, retries = 2;
+	static ac97_bus_ops_t ops = {
+		.write = snd_trident_codec_write,
+		.read = snd_trident_codec_read,
+	};
+
+	uctl = kcalloc(1, sizeof(*uctl), GFP_KERNEL);
+	if (!uctl)
+		return -ENOMEM;
+
+	if ((err = snd_ac97_bus(trident->card, 0, &ops, NULL, &trident->ac97_bus)) < 0)
+		goto __out;
+
+	memset(&_ac97, 0, sizeof(_ac97));
+	_ac97.private_data = trident;
+	trident->ac97_detect = 1;
+
+      __again:
+	if ((err = snd_ac97_mixer(trident->ac97_bus, &_ac97, &trident->ac97)) < 0) {
+		if (trident->device == TRIDENT_DEVICE_ID_SI7018) {
+			if ((err = snd_trident_sis_reset(trident)) < 0)
+				goto __out;
+			if (retries-- > 0)
+				goto __again;
+			err = -EIO;
+		}
+		goto __out;
+	}
+	
+	/* secondary codec? */
+	if (trident->device == TRIDENT_DEVICE_ID_SI7018 &&
+	    (inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) & SI_AC97_PRIMARY_READY) != 0) {
+		_ac97.num = 1;
+		err = snd_ac97_mixer(trident->ac97_bus, &_ac97, &trident->ac97_sec);
+		if (err < 0)
+			snd_printk("SI7018: the secondary codec - invalid access\n");
+#if 0	// only for my testing purpose --jk
+		{
+			ac97_t *mc97;
+			err = snd_ac97_modem(trident->card, &_ac97, &mc97);
+			if (err < 0)
+				snd_printk("snd_ac97_modem returned error %i\n", err);
+		}
+#endif
+	}
+	
+	trident->ac97_detect = 0;
+
+	if (trident->device != TRIDENT_DEVICE_ID_SI7018) {
+		if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_trident_vol_wave_control, trident))) < 0)
+			goto __out;
+		kctl->put(kctl, uctl);
+		if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_trident_vol_music_control, trident))) < 0)
+			goto __out;
+		kctl->put(kctl, uctl);
+		outl(trident->musicvol_wavevol = 0x00000000, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));
+	} else {
+		outl(trident->musicvol_wavevol = 0xffff0000, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));
+	}
+
+	for (idx = 0; idx < 32; idx++) {
+		snd_trident_pcm_mixer_t *tmix;
+		
+		tmix = &trident->pcm_mixer[idx];
+		tmix->voice = NULL;
+	}
+	if ((trident->ctl_vol = snd_ctl_new1(&snd_trident_pcm_vol_control, trident)) == NULL)
+		goto __nomem;
+	if ((err = snd_ctl_add(card, trident->ctl_vol)))
+		goto __out;
+		
+	if ((trident->ctl_pan = snd_ctl_new1(&snd_trident_pcm_pan_control, trident)) == NULL)
+		goto __nomem;
+	if ((err = snd_ctl_add(card, trident->ctl_pan)))
+		goto __out;
+
+	if ((trident->ctl_rvol = snd_ctl_new1(&snd_trident_pcm_rvol_control, trident)) == NULL)
+		goto __nomem;
+	if ((err = snd_ctl_add(card, trident->ctl_rvol)))
+		goto __out;
+
+	if ((trident->ctl_cvol = snd_ctl_new1(&snd_trident_pcm_cvol_control, trident)) == NULL)
+		goto __nomem;
+	if ((err = snd_ctl_add(card, trident->ctl_cvol)))
+		goto __out;
+
+	if (trident->device == TRIDENT_DEVICE_ID_NX) {
+		if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_trident_ac97_rear_control, trident))) < 0)
+			goto __out;
+		kctl->put(kctl, uctl);
+	}
+	if (trident->device == TRIDENT_DEVICE_ID_NX || trident->device == TRIDENT_DEVICE_ID_SI7018) {
+
+		kctl = snd_ctl_new1(&snd_trident_spdif_control, trident);
+		if (kctl == NULL) {
+			err = -ENOMEM;
+			goto __out;
+		}
+		if (trident->ac97->ext_id & AC97_EI_SPDIF)
+			kctl->id.index++;
+		if (trident->ac97_sec && (trident->ac97_sec->ext_id & AC97_EI_SPDIF))
+			kctl->id.index++;
+		idx = kctl->id.index;
+		if ((err = snd_ctl_add(card, kctl)) < 0)
+			goto __out;
+		kctl->put(kctl, uctl);
+
+		kctl = snd_ctl_new1(&snd_trident_spdif_default, trident);
+		if (kctl == NULL) {
+			err = -ENOMEM;
+			goto __out;
+		}
+		kctl->id.index = idx;
+		kctl->id.device = pcm_spdif_device;
+		if ((err = snd_ctl_add(card, kctl)) < 0)
+			goto __out;
+
+		kctl = snd_ctl_new1(&snd_trident_spdif_mask, trident);
+		if (kctl == NULL) {
+			err = -ENOMEM;
+			goto __out;
+		}
+		kctl->id.index = idx;
+		kctl->id.device = pcm_spdif_device;
+		if ((err = snd_ctl_add(card, kctl)) < 0)
+			goto __out;
+
+		kctl = snd_ctl_new1(&snd_trident_spdif_stream, trident);
+		if (kctl == NULL) {
+			err = -ENOMEM;
+			goto __out;
+		}
+		kctl->id.index = idx;
+		kctl->id.device = pcm_spdif_device;
+		if ((err = snd_ctl_add(card, kctl)) < 0)
+			goto __out;
+		trident->spdif_pcm_ctl = kctl;
+	}
+
+	err = 0;
+	goto __out;
+
+ __nomem:
+	err = -ENOMEM;
+
+ __out:
+	kfree(uctl);
+
+	return err;
+}
+
+/*
+ * gameport interface
+ */
+
+#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+
+static unsigned char snd_trident_gameport_read(struct gameport *gameport)
+{
+	trident_t *chip = gameport_get_port_data(gameport);
+
+	snd_assert(chip, return 0);
+	return inb(TRID_REG(chip, GAMEPORT_LEGACY));
+}
+
+static void snd_trident_gameport_trigger(struct gameport *gameport)
+{
+	trident_t *chip = gameport_get_port_data(gameport);
+
+	snd_assert(chip, return);
+	outb(0xff, TRID_REG(chip, GAMEPORT_LEGACY));
+}
+
+static int snd_trident_gameport_cooked_read(struct gameport *gameport, int *axes, int *buttons)
+{
+	trident_t *chip = gameport_get_port_data(gameport);
+	int i;
+
+	snd_assert(chip, return 0);
+
+	*buttons = (~inb(TRID_REG(chip, GAMEPORT_LEGACY)) >> 4) & 0xf;
+
+	for (i = 0; i < 4; i++) {
+		axes[i] = inw(TRID_REG(chip, GAMEPORT_AXES + i * 2));
+		if (axes[i] == 0xffff) axes[i] = -1;
+	}
+        
+        return 0;
+}
+
+static int snd_trident_gameport_open(struct gameport *gameport, int mode)
+{
+	trident_t *chip = gameport_get_port_data(gameport);
+
+	snd_assert(chip, return 0);
+
+	switch (mode) {
+		case GAMEPORT_MODE_COOKED:
+			outb(GAMEPORT_MODE_ADC, TRID_REG(chip, GAMEPORT_GCR));
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(1 + 20 * HZ / 1000); /* 20msec */
+			return 0;
+		case GAMEPORT_MODE_RAW:
+			outb(0, TRID_REG(chip, GAMEPORT_GCR));
+			return 0;
+		default:
+			return -1;
+	}
+}
+
+int __devinit snd_trident_create_gameport(trident_t *chip)
+{
+	struct gameport *gp;
+
+	chip->gameport = gp = gameport_allocate_port();
+	if (!gp) {
+		printk(KERN_ERR "trident: cannot allocate memory for gameport\n");
+		return -ENOMEM;
+	}
+
+	gameport_set_name(gp, "Trident 4DWave");
+	gameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));
+	gameport_set_dev_parent(gp, &chip->pci->dev);
+
+	gameport_set_port_data(gp, chip);
+	gp->fuzz = 64;
+	gp->read = snd_trident_gameport_read;
+	gp->trigger = snd_trident_gameport_trigger;
+	gp->cooked_read = snd_trident_gameport_cooked_read;
+	gp->open = snd_trident_gameport_open;
+
+	gameport_register_port(gp);
+
+	return 0;
+}
+
+static inline void snd_trident_free_gameport(trident_t *chip)
+{
+	if (chip->gameport) {
+		gameport_unregister_port(chip->gameport);
+		chip->gameport = NULL;
+	}
+}
+#else
+int __devinit snd_trident_create_gameport(trident_t *chip) { return -ENOSYS; }
+static inline void snd_trident_free_gameport(trident_t *chip) { }
+#endif /* CONFIG_GAMEPORT */
+
+/*
+ * delay for 1 tick
+ */
+inline static void do_delay(trident_t *chip)
+{
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(1);
+}
+
+/*
+ *  SiS reset routine
+ */
+
+static int snd_trident_sis_reset(trident_t *trident)
+{
+	unsigned long end_time;
+	unsigned int i;
+	int r;
+
+	r = trident->in_suspend ? 0 : 2;	/* count of retries */
+      __si7018_retry:
+	pci_write_config_byte(trident->pci, 0x46, 0x04);	/* SOFTWARE RESET */
+	udelay(100);
+	pci_write_config_byte(trident->pci, 0x46, 0x00);
+	udelay(100);
+	/* disable AC97 GPIO interrupt */
+	outb(0x00, TRID_REG(trident, SI_AC97_GPIO));
+	/* initialize serial interface, force cold reset */
+	i = PCMOUT|SURROUT|CENTEROUT|LFEOUT|SECONDARY_ID|COLD_RESET;
+	outl(i, TRID_REG(trident, SI_SERIAL_INTF_CTRL));
+	udelay(1000);
+	/* remove cold reset */
+	i &= ~COLD_RESET;
+	outl(i, TRID_REG(trident, SI_SERIAL_INTF_CTRL));
+	udelay(2000);
+	/* wait, until the codec is ready */
+	end_time = (jiffies + (HZ * 3) / 4) + 1;
+	do {
+		if ((inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) & SI_AC97_PRIMARY_READY) != 0)
+			goto __si7018_ok;
+		do_delay(trident);
+	} while (time_after_eq(end_time, jiffies));
+	snd_printk("AC'97 codec ready error [0x%x]\n", inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)));
+	if (r-- > 0) {
+		end_time = jiffies + HZ;
+		do {
+			do_delay(trident);
+		} while (time_after_eq(end_time, jiffies));
+		goto __si7018_retry;
+	}
+      __si7018_ok:
+	/* wait for the second codec */
+	do {
+		if ((inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) & SI_AC97_SECONDARY_READY) != 0)
+			break;
+		do_delay(trident);
+	} while (time_after_eq(end_time, jiffies));
+	/* enable 64 channel mode */
+	outl(BANK_B_EN, TRID_REG(trident, T4D_LFO_GC_CIR));
+	return 0;
+}
+
+/*  
+ *  /proc interface
+ */
+
+static void snd_trident_proc_read(snd_info_entry_t *entry, 
+				  snd_info_buffer_t * buffer)
+{
+	trident_t *trident = entry->private_data;
+	char *s;
+
+	switch (trident->device) {
+	case TRIDENT_DEVICE_ID_SI7018:
+		s = "SiS 7018 Audio";
+		break;
+	case TRIDENT_DEVICE_ID_DX:
+		s = "Trident 4DWave PCI DX";
+		break;
+	case TRIDENT_DEVICE_ID_NX:
+		s = "Trident 4DWave PCI NX";
+		break;
+	default:
+		s = "???";
+	}
+	snd_iprintf(buffer, "%s\n\n", s);
+	snd_iprintf(buffer, "Spurious IRQs    : %d\n", trident->spurious_irq_count);
+	snd_iprintf(buffer, "Spurious IRQ dlta: %d\n", trident->spurious_irq_max_delta);
+	if (trident->device == TRIDENT_DEVICE_ID_NX || trident->device == TRIDENT_DEVICE_ID_SI7018)
+		snd_iprintf(buffer, "IEC958 Mixer Out : %s\n", trident->spdif_ctrl == 0x28 ? "on" : "off");
+	if (trident->device == TRIDENT_DEVICE_ID_NX) {
+		snd_iprintf(buffer, "Rear Speakers    : %s\n", trident->ac97_ctrl & 0x00000010 ? "on" : "off");
+		if (trident->tlb.entries) {
+			snd_iprintf(buffer,"\nVirtual Memory\n");
+			snd_iprintf(buffer, "Memory Maximum : %d\n", trident->tlb.memhdr->size);
+			snd_iprintf(buffer, "Memory Used    : %d\n", trident->tlb.memhdr->used);
+			snd_iprintf(buffer, "Memory Free    : %d\n", snd_util_mem_avail(trident->tlb.memhdr));
+		}
+	}
+#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
+	snd_iprintf(buffer,"\nWavetable Synth\n");
+	snd_iprintf(buffer, "Memory Maximum : %d\n", trident->synth.max_size);
+	snd_iprintf(buffer, "Memory Used    : %d\n", trident->synth.current_size);
+	snd_iprintf(buffer, "Memory Free    : %d\n", (trident->synth.max_size-trident->synth.current_size));
+#endif
+}
+
+static void __devinit snd_trident_proc_init(trident_t * trident)
+{
+	snd_info_entry_t *entry;
+	const char *s = "trident";
+	
+	if (trident->device == TRIDENT_DEVICE_ID_SI7018)
+		s = "sis7018";
+	if (! snd_card_proc_new(trident->card, s, &entry))
+		snd_info_set_text_ops(entry, trident, 1024, snd_trident_proc_read);
+}
+
+static int snd_trident_dev_free(snd_device_t *device)
+{
+	trident_t *trident = device->device_data;
+	return snd_trident_free(trident);
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_tlb_alloc
+  
+   Description: Allocate and set up the TLB page table on 4D NX.
+		Each entry has 4 bytes (physical PCI address).
+                
+   Paramters:   trident - pointer to target device class for 4DWave.
+
+   Returns:     0 or negative error code
+  
+  ---------------------------------------------------------------------------*/
+
+static int __devinit snd_trident_tlb_alloc(trident_t *trident)
+{
+	int i;
+
+	/* TLB array must be aligned to 16kB !!! so we allocate
+	   32kB region and correct offset when necessary */
+
+	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci),
+				2 * SNDRV_TRIDENT_MAX_PAGES * 4, &trident->tlb.buffer) < 0) {
+		snd_printk(KERN_ERR "trident: unable to allocate TLB buffer\n");
+		return -ENOMEM;
+	}
+	trident->tlb.entries = (unsigned int*)(((unsigned long)trident->tlb.buffer.area + SNDRV_TRIDENT_MAX_PAGES * 4 - 1) & ~(SNDRV_TRIDENT_MAX_PAGES * 4 - 1));
+	trident->tlb.entries_dmaaddr = (trident->tlb.buffer.addr + SNDRV_TRIDENT_MAX_PAGES * 4 - 1) & ~(SNDRV_TRIDENT_MAX_PAGES * 4 - 1);
+	/* allocate shadow TLB page table (virtual addresses) */
+	trident->tlb.shadow_entries = (unsigned long *)vmalloc(SNDRV_TRIDENT_MAX_PAGES*sizeof(unsigned long));
+	if (trident->tlb.shadow_entries == NULL) {
+		snd_printk(KERN_ERR "trident: unable to allocate shadow TLB entries\n");
+		return -ENOMEM;
+	}
+	/* allocate and setup silent page and initialise TLB entries */
+	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci),
+				SNDRV_TRIDENT_PAGE_SIZE, &trident->tlb.silent_page) < 0) {
+		snd_printk(KERN_ERR "trident: unable to allocate silent page\n");
+		return -ENOMEM;
+	}
+	memset(trident->tlb.silent_page.area, 0, SNDRV_TRIDENT_PAGE_SIZE);
+	for (i = 0; i < SNDRV_TRIDENT_MAX_PAGES; i++) {
+		trident->tlb.entries[i] = cpu_to_le32(trident->tlb.silent_page.addr & ~(SNDRV_TRIDENT_PAGE_SIZE-1));
+		trident->tlb.shadow_entries[i] = (unsigned long)trident->tlb.silent_page.area;
+	}
+
+	/* use emu memory block manager code to manage tlb page allocation */
+	trident->tlb.memhdr = snd_util_memhdr_new(SNDRV_TRIDENT_PAGE_SIZE * SNDRV_TRIDENT_MAX_PAGES);
+	if (trident->tlb.memhdr == NULL)
+		return -ENOMEM;
+
+	trident->tlb.memhdr->block_extra_size = sizeof(snd_trident_memblk_arg_t);
+	return 0;
+}
+
+/*
+ * initialize 4D DX chip
+ */
+
+static void snd_trident_stop_all_voices(trident_t *trident)
+{
+	outl(0xffffffff, TRID_REG(trident, T4D_STOP_A));
+	outl(0xffffffff, TRID_REG(trident, T4D_STOP_B));
+	outl(0, TRID_REG(trident, T4D_AINTEN_A));
+	outl(0, TRID_REG(trident, T4D_AINTEN_B));
+}
+
+static int snd_trident_4d_dx_init(trident_t *trident)
+{
+	struct pci_dev *pci = trident->pci;
+	unsigned long end_time;
+
+	/* reset the legacy configuration and whole audio/wavetable block */
+	pci_write_config_dword(pci, 0x40, 0);	/* DDMA */
+	pci_write_config_byte(pci, 0x44, 0);	/* ports */
+	pci_write_config_byte(pci, 0x45, 0);	/* Legacy DMA */
+	pci_write_config_byte(pci, 0x46, 4); /* reset */
+	udelay(100);
+	pci_write_config_byte(pci, 0x46, 0); /* release reset */
+	udelay(100);
+	
+	/* warm reset of the AC'97 codec */
+	outl(0x00000001, TRID_REG(trident, DX_ACR2_AC97_COM_STAT));
+	udelay(100);
+	outl(0x00000000, TRID_REG(trident, DX_ACR2_AC97_COM_STAT));
+	/* DAC on, disable SB IRQ and try to force ADC valid signal */
+	trident->ac97_ctrl = 0x0000004a;
+	outl(trident->ac97_ctrl, TRID_REG(trident, DX_ACR2_AC97_COM_STAT));
+	/* wait, until the codec is ready */
+	end_time = (jiffies + (HZ * 3) / 4) + 1;
+	do {
+		if ((inl(TRID_REG(trident, DX_ACR2_AC97_COM_STAT)) & 0x0010) != 0)
+			goto __dx_ok;
+		do_delay(trident);
+	} while (time_after_eq(end_time, jiffies));
+	snd_printk(KERN_ERR "AC'97 codec ready error\n");
+	return -EIO;
+
+ __dx_ok:
+	snd_trident_stop_all_voices(trident);
+
+	return 0;
+}
+
+/*
+ * initialize 4D NX chip
+ */
+static int snd_trident_4d_nx_init(trident_t *trident)
+{
+	struct pci_dev *pci = trident->pci;
+	unsigned long end_time;
+
+	/* reset the legacy configuration and whole audio/wavetable block */
+	pci_write_config_dword(pci, 0x40, 0);	/* DDMA */
+	pci_write_config_byte(pci, 0x44, 0);	/* ports */
+	pci_write_config_byte(pci, 0x45, 0);	/* Legacy DMA */
+
+	pci_write_config_byte(pci, 0x46, 1); /* reset */
+	udelay(100);
+	pci_write_config_byte(pci, 0x46, 0); /* release reset */
+	udelay(100);
+
+	/* warm reset of the AC'97 codec */
+	outl(0x00000001, TRID_REG(trident, NX_ACR0_AC97_COM_STAT));
+	udelay(100);
+	outl(0x00000000, TRID_REG(trident, NX_ACR0_AC97_COM_STAT));
+	/* wait, until the codec is ready */
+	end_time = (jiffies + (HZ * 3) / 4) + 1;
+	do {
+		if ((inl(TRID_REG(trident, NX_ACR0_AC97_COM_STAT)) & 0x0008) != 0)
+			goto __nx_ok;
+		do_delay(trident);
+	} while (time_after_eq(end_time, jiffies));
+	snd_printk(KERN_ERR "AC'97 codec ready error [0x%x]\n", inl(TRID_REG(trident, NX_ACR0_AC97_COM_STAT)));
+	return -EIO;
+
+ __nx_ok:
+	/* DAC on */
+	trident->ac97_ctrl = 0x00000002;
+	outl(trident->ac97_ctrl, TRID_REG(trident, NX_ACR0_AC97_COM_STAT));
+	/* disable SB IRQ */
+	outl(NX_SB_IRQ_DISABLE, TRID_REG(trident, T4D_MISCINT));
+
+	snd_trident_stop_all_voices(trident);
+
+	if (trident->tlb.entries != NULL) {
+		unsigned int i;
+		/* enable virtual addressing via TLB */
+		i = trident->tlb.entries_dmaaddr;
+		i |= 0x00000001;
+		outl(i, TRID_REG(trident, NX_TLBC));
+	} else {
+		outl(0, TRID_REG(trident, NX_TLBC));
+	}
+	/* initialize S/PDIF */
+	outl(trident->spdif_bits, TRID_REG(trident, NX_SPCSTATUS));
+	outb(trident->spdif_ctrl, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));
+
+	return 0;
+}
+
+/*
+ * initialize sis7018 chip
+ */
+static int snd_trident_sis_init(trident_t *trident)
+{
+	int err;
+
+	if ((err = snd_trident_sis_reset(trident)) < 0)
+		return err;
+
+	snd_trident_stop_all_voices(trident);
+
+	/* initialize S/PDIF */
+	outl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_create
+  
+   Description: This routine will create the device specific class for
+                the 4DWave card. It will also perform basic initialization.
+                
+   Paramters:   card  - which card to create
+                pci   - interface to PCI bus resource info
+                dma1ptr - playback dma buffer
+                dma2ptr - capture dma buffer
+                irqptr  -  interrupt resource info
+
+   Returns:     4DWave device class private data
+  
+  ---------------------------------------------------------------------------*/
+
+int __devinit snd_trident_create(snd_card_t * card,
+		       struct pci_dev *pci,
+		       int pcm_streams,
+		       int pcm_spdif_device,
+		       int max_wavetable_size,
+		       trident_t ** rtrident)
+{
+	trident_t *trident;
+	int i, err;
+	snd_trident_voice_t *voice;
+	snd_trident_pcm_mixer_t *tmix;
+	static snd_device_ops_t ops = {
+		.dev_free =	snd_trident_dev_free,
+	};
+
+	*rtrident = NULL;
+
+	/* enable PCI device */
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+	/* check, if we can restrict PCI DMA transfers to 30 bits */
+	if (pci_set_dma_mask(pci, 0x3fffffff) < 0 ||
+	    pci_set_consistent_dma_mask(pci, 0x3fffffff) < 0) {
+		snd_printk("architecture does not support 30bit PCI busmaster DMA\n");
+		pci_disable_device(pci);
+		return -ENXIO;
+	}
+	
+	trident = kcalloc(1, sizeof(*trident), GFP_KERNEL);
+	if (trident == NULL) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+	trident->device = (pci->vendor << 16) | pci->device;
+	trident->card = card;
+	trident->pci = pci;
+	spin_lock_init(&trident->reg_lock);
+	spin_lock_init(&trident->event_lock);
+	spin_lock_init(&trident->voice_alloc);
+	if (pcm_streams < 1)
+		pcm_streams = 1;
+	if (pcm_streams > 32)
+		pcm_streams = 32;
+	trident->ChanPCM = pcm_streams;
+	if (max_wavetable_size < 0 )
+		max_wavetable_size = 0;
+	trident->synth.max_size = max_wavetable_size * 1024;
+	trident->irq = -1;
+
+	trident->midi_port = TRID_REG(trident, T4D_MPU401_BASE);
+	pci_set_master(pci);
+
+	if ((err = pci_request_regions(pci, "Trident Audio")) < 0) {
+		kfree(trident);
+		pci_disable_device(pci);
+		return err;
+	}
+	trident->port = pci_resource_start(pci, 0);
+
+	if (request_irq(pci->irq, snd_trident_interrupt, SA_INTERRUPT|SA_SHIRQ, "Trident Audio", (void *) trident)) {
+		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_trident_free(trident);
+		return -EBUSY;
+	}
+	trident->irq = pci->irq;
+
+	/* allocate 16k-aligned TLB for NX cards */
+	trident->tlb.entries = NULL;
+	trident->tlb.buffer.area = NULL;
+	if (trident->device == TRIDENT_DEVICE_ID_NX) {
+		if ((err = snd_trident_tlb_alloc(trident)) < 0) {
+			snd_trident_free(trident);
+			return err;
+		}
+	}
+
+	trident->spdif_bits = trident->spdif_pcm_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;
+
+	/* initialize chip */
+	switch (trident->device) {
+	case TRIDENT_DEVICE_ID_DX:
+		err = snd_trident_4d_dx_init(trident);
+		break;
+	case TRIDENT_DEVICE_ID_NX:
+		err = snd_trident_4d_nx_init(trident);
+		break;
+	case TRIDENT_DEVICE_ID_SI7018:
+		err = snd_trident_sis_init(trident);
+		break;
+	default:
+		snd_BUG();
+		break;
+	}
+	if (err < 0) {
+		snd_trident_free(trident);
+		return err;
+	}
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, trident, &ops)) < 0) {
+		snd_trident_free(trident);
+		return err;
+	}
+
+	if ((err = snd_trident_mixer(trident, pcm_spdif_device)) < 0)
+		return err;
+	
+	/* initialise synth voices */
+	for (i = 0; i < 64; i++) {
+		voice = &trident->synth.voices[i];
+		voice->number = i;
+		voice->trident = trident;
+	}
+	/* initialize pcm mixer entries */
+	for (i = 0; i < 32; i++) {
+		tmix = &trident->pcm_mixer[i];
+		tmix->vol = T4D_DEFAULT_PCM_VOL;
+		tmix->pan = T4D_DEFAULT_PCM_PAN;
+		tmix->rvol = T4D_DEFAULT_PCM_RVOL;
+		tmix->cvol = T4D_DEFAULT_PCM_CVOL;
+	}
+
+	snd_trident_enable_eso(trident);
+
+	
+	snd_card_set_pm_callback(card, snd_trident_suspend, snd_trident_resume, trident);
+	snd_trident_proc_init(trident);
+	snd_card_set_dev(card, &pci->dev);
+	*rtrident = trident;
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_free
+  
+   Description: This routine will free the device specific class for
+                the 4DWave card. 
+                
+   Paramters:   trident  - device specific private data for 4DWave card
+
+   Returns:     None.
+  
+  ---------------------------------------------------------------------------*/
+
+static int snd_trident_free(trident_t *trident)
+{
+	snd_trident_free_gameport(trident);
+	snd_trident_disable_eso(trident);
+	// Disable S/PDIF out
+	if (trident->device == TRIDENT_DEVICE_ID_NX)
+		outb(0x00, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));
+	else if (trident->device == TRIDENT_DEVICE_ID_SI7018) {
+		outl(0, TRID_REG(trident, SI_SERIAL_INTF_CTRL));
+	}
+	if (trident->tlb.buffer.area) {
+		outl(0, TRID_REG(trident, NX_TLBC));
+		if (trident->tlb.memhdr)
+			snd_util_memhdr_free(trident->tlb.memhdr);
+		if (trident->tlb.silent_page.area)
+			snd_dma_free_pages(&trident->tlb.silent_page);
+		vfree(trident->tlb.shadow_entries);
+		snd_dma_free_pages(&trident->tlb.buffer);
+	}
+	if (trident->irq >= 0)
+		free_irq(trident->irq, (void *)trident);
+	pci_release_regions(trident->pci);
+	pci_disable_device(trident->pci);
+	kfree(trident);
+	return 0;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_interrupt
+  
+   Description: ISR for Trident 4DWave device
+                
+   Paramters:   trident  - device specific private data for 4DWave card
+
+   Problems:    It seems that Trident chips generates interrupts more than
+                one time in special cases. The spurious interrupts are
+                detected via sample timer (T4D_STIMER) and computing
+                corresponding delta value. The limits are detected with
+                the method try & fail so it is possible that it won't
+                work on all computers. [jaroslav]
+
+   Returns:     None.
+  
+  ---------------------------------------------------------------------------*/
+
+static irqreturn_t snd_trident_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	trident_t *trident = dev_id;
+	unsigned int audio_int, chn_int, stimer, channel, mask, tmp;
+	int delta;
+	snd_trident_voice_t *voice;
+
+	audio_int = inl(TRID_REG(trident, T4D_MISCINT));
+	if ((audio_int & (ADDRESS_IRQ|MPU401_IRQ)) == 0)
+		return IRQ_NONE;
+	if (audio_int & ADDRESS_IRQ) {
+		// get interrupt status for all channels
+		spin_lock(&trident->reg_lock);
+		stimer = inl(TRID_REG(trident, T4D_STIMER)) & 0x00ffffff;
+		chn_int = inl(TRID_REG(trident, T4D_AINT_A));
+		if (chn_int == 0)
+			goto __skip1;
+		outl(chn_int, TRID_REG(trident, T4D_AINT_A));	/* ack */
+	      __skip1:
+		chn_int = inl(TRID_REG(trident, T4D_AINT_B));
+		if (chn_int == 0)
+			goto __skip2;
+		for (channel = 63; channel >= 32; channel--) {
+			mask = 1 << (channel&0x1f);
+			if ((chn_int & mask) == 0)
+				continue;
+			voice = &trident->synth.voices[channel];
+			if (!voice->pcm || voice->substream == NULL) {
+				outl(mask, TRID_REG(trident, T4D_STOP_B));
+				continue;
+			}
+			delta = (int)stimer - (int)voice->stimer;
+			if (delta < 0)
+				delta = -delta;
+			if ((unsigned int)delta < voice->spurious_threshold) {
+				/* do some statistics here */
+				trident->spurious_irq_count++;
+				if (trident->spurious_irq_max_delta < (unsigned int)delta)
+					trident->spurious_irq_max_delta = delta;
+				continue;
+			}
+			voice->stimer = stimer;
+			if (voice->isync) {
+				if (!voice->isync3) {
+					tmp = inw(TRID_REG(trident, T4D_SBBL_SBCL));
+					if (trident->bDMAStart & 0x40)
+						tmp >>= 1;
+					if (tmp > 0)
+						tmp = voice->isync_max - tmp;
+				} else {
+					tmp = inl(TRID_REG(trident, NX_SPCTRL_SPCSO)) & 0x00ffffff;
+				}
+				if (tmp < voice->isync_mark) {
+					if (tmp > 0x10)
+						tmp = voice->isync_ESO - 7;
+					else
+						tmp = voice->isync_ESO + 2;
+					/* update ESO for IRQ voice to preserve sync */
+					snd_trident_stop_voice(trident, voice->number);
+					snd_trident_write_eso_reg(trident, voice, tmp);
+					snd_trident_start_voice(trident, voice->number);
+				}
+			} else if (voice->isync2) {
+				voice->isync2 = 0;
+				/* write original ESO and update CSO for IRQ voice to preserve sync */
+				snd_trident_stop_voice(trident, voice->number);
+				snd_trident_write_cso_reg(trident, voice, voice->isync_mark);
+				snd_trident_write_eso_reg(trident, voice, voice->ESO);
+				snd_trident_start_voice(trident, voice->number);
+			}
+#if 0
+			if (voice->extra) {
+				/* update CSO for extra voice to preserve sync */
+				snd_trident_stop_voice(trident, voice->extra->number);
+				snd_trident_write_cso_reg(trident, voice->extra, 0);
+				snd_trident_start_voice(trident, voice->extra->number);
+			}
+#endif
+			spin_unlock(&trident->reg_lock);
+			snd_pcm_period_elapsed(voice->substream);
+			spin_lock(&trident->reg_lock);
+		}
+		outl(chn_int, TRID_REG(trident, T4D_AINT_B));	/* ack */
+	      __skip2:
+		spin_unlock(&trident->reg_lock);
+	}
+	if (audio_int & MPU401_IRQ) {
+		if (trident->rmidi) {
+			snd_mpu401_uart_interrupt(irq, trident->rmidi->private_data, regs);
+		} else {
+			inb(TRID_REG(trident, T4D_MPUR0));
+		}
+	}
+	// outl((ST_TARGET_REACHED | MIXER_OVERFLOW | MIXER_UNDERFLOW), TRID_REG(trident, T4D_MISCINT));
+	return IRQ_HANDLED;
+}
+
+/*---------------------------------------------------------------------------
+   snd_trident_attach_synthesizer
+  
+   Description: Attach synthesizer hooks
+                
+   Paramters:   trident  - device specific private data for 4DWave card
+
+   Returns:     None.
+  
+  ---------------------------------------------------------------------------*/
+int snd_trident_attach_synthesizer(trident_t *trident)
+{	
+#if defined(CONFIG_SND_SEQUENCER) || (defined(MODULE) && defined(CONFIG_SND_SEQUENCER_MODULE))
+	if (snd_seq_device_new(trident->card, 1, SNDRV_SEQ_DEV_ID_TRIDENT,
+			       sizeof(trident_t*), &trident->seq_dev) >= 0) {
+		strcpy(trident->seq_dev->name, "4DWave");
+		*(trident_t**)SNDRV_SEQ_DEVICE_ARGPTR(trident->seq_dev) = trident;
+	}
+#endif
+	return 0;
+}
+
+snd_trident_voice_t *snd_trident_alloc_voice(trident_t * trident, int type, int client, int port)
+{
+	snd_trident_voice_t *pvoice;
+	unsigned long flags;
+	int idx;
+
+	spin_lock_irqsave(&trident->voice_alloc, flags);
+	if (type == SNDRV_TRIDENT_VOICE_TYPE_PCM) {
+		idx = snd_trident_allocate_pcm_channel(trident);
+		if(idx < 0) {
+			spin_unlock_irqrestore(&trident->voice_alloc, flags);
+			return NULL;
+		}
+		pvoice = &trident->synth.voices[idx];
+		pvoice->use = 1;
+		pvoice->pcm = 1;
+		pvoice->capture = 0;
+		pvoice->spdif = 0;
+		pvoice->memblk = NULL;
+		pvoice->substream = NULL;
+		spin_unlock_irqrestore(&trident->voice_alloc, flags);
+		return pvoice;
+	}
+	if (type == SNDRV_TRIDENT_VOICE_TYPE_SYNTH) {
+		idx = snd_trident_allocate_synth_channel(trident);
+		if(idx < 0) {
+			spin_unlock_irqrestore(&trident->voice_alloc, flags);
+			return NULL;
+		}
+		pvoice = &trident->synth.voices[idx];
+		pvoice->use = 1;
+		pvoice->synth = 1;
+		pvoice->client = client;
+		pvoice->port = port;
+		pvoice->memblk = NULL;
+		spin_unlock_irqrestore(&trident->voice_alloc, flags);
+		return pvoice;
+	}
+	if (type == SNDRV_TRIDENT_VOICE_TYPE_MIDI) {
+	}
+	spin_unlock_irqrestore(&trident->voice_alloc, flags);
+	return NULL;
+}
+
+void snd_trident_free_voice(trident_t * trident, snd_trident_voice_t *voice)
+{
+	unsigned long flags;
+	void (*private_free)(snd_trident_voice_t *);
+	void *private_data;
+
+	if (voice == NULL || !voice->use)
+		return;
+	snd_trident_clear_voices(trident, voice->number, voice->number);
+	spin_lock_irqsave(&trident->voice_alloc, flags);
+	private_free = voice->private_free;
+	private_data = voice->private_data;
+	voice->private_free = NULL;
+	voice->private_data = NULL;
+	if (voice->pcm)
+		snd_trident_free_pcm_channel(trident, voice->number);
+	if (voice->synth)
+		snd_trident_free_synth_channel(trident, voice->number);
+	voice->use = voice->pcm = voice->synth = voice->midi = 0;
+	voice->capture = voice->spdif = 0;
+	voice->sample_ops = NULL;
+	voice->substream = NULL;
+	voice->extra = NULL;
+	spin_unlock_irqrestore(&trident->voice_alloc, flags);
+	if (private_free)
+		private_free(voice);
+}
+
+static void snd_trident_clear_voices(trident_t * trident, unsigned short v_min, unsigned short v_max)
+{
+	unsigned int i, val, mask[2] = { 0, 0 };
+
+	snd_assert(v_min <= 63, return);
+	snd_assert(v_max <= 63, return);
+	for (i = v_min; i <= v_max; i++)
+		mask[i >> 5] |= 1 << (i & 0x1f);
+	if (mask[0]) {
+		outl(mask[0], TRID_REG(trident, T4D_STOP_A));
+		val = inl(TRID_REG(trident, T4D_AINTEN_A));
+		outl(val & ~mask[0], TRID_REG(trident, T4D_AINTEN_A));
+	}
+	if (mask[1]) {
+		outl(mask[1], TRID_REG(trident, T4D_STOP_B));
+		val = inl(TRID_REG(trident, T4D_AINTEN_B));
+		outl(val & ~mask[1], TRID_REG(trident, T4D_AINTEN_B));
+	}
+}
+
+#ifdef CONFIG_PM
+static int snd_trident_suspend(snd_card_t *card, pm_message_t state)
+{
+	trident_t *trident = card->pm_private_data;
+
+	trident->in_suspend = 1;
+	snd_pcm_suspend_all(trident->pcm);
+	if (trident->foldback)
+		snd_pcm_suspend_all(trident->foldback);
+	if (trident->spdif)
+		snd_pcm_suspend_all(trident->spdif);
+
+	snd_ac97_suspend(trident->ac97);
+	if (trident->ac97_sec)
+		snd_ac97_suspend(trident->ac97_sec);
+
+	switch (trident->device) {
+	case TRIDENT_DEVICE_ID_DX:
+	case TRIDENT_DEVICE_ID_NX:
+		break;			/* TODO */
+	case TRIDENT_DEVICE_ID_SI7018:
+		break;
+	}
+	pci_disable_device(trident->pci);
+	return 0;
+}
+
+static int snd_trident_resume(snd_card_t *card)
+{
+	trident_t *trident = card->pm_private_data;
+
+	pci_enable_device(trident->pci);
+	if (pci_set_dma_mask(trident->pci, 0x3fffffff) < 0 ||
+	    pci_set_consistent_dma_mask(trident->pci, 0x3fffffff) < 0)
+		snd_printk(KERN_WARNING "trident: can't set the proper DMA mask\n");
+	pci_set_master(trident->pci); /* to be sure */
+
+	switch (trident->device) {
+	case TRIDENT_DEVICE_ID_DX:
+		snd_trident_4d_dx_init(trident);
+		break;
+	case TRIDENT_DEVICE_ID_NX:
+		snd_trident_4d_nx_init(trident);
+		break;
+	case TRIDENT_DEVICE_ID_SI7018:
+		snd_trident_sis_init(trident);
+		break;
+	}
+
+	snd_ac97_resume(trident->ac97);
+	if (trident->ac97_sec)
+		snd_ac97_resume(trident->ac97_sec);
+
+	/* restore some registers */
+	outl(trident->musicvol_wavevol, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));
+
+	snd_trident_enable_eso(trident);
+
+	trident->in_suspend = 0;
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+EXPORT_SYMBOL(snd_trident_alloc_voice);
+EXPORT_SYMBOL(snd_trident_free_voice);
+EXPORT_SYMBOL(snd_trident_start_voice);
+EXPORT_SYMBOL(snd_trident_stop_voice);
+EXPORT_SYMBOL(snd_trident_write_voice_regs);
+/* trident_memory.c symbols */
+EXPORT_SYMBOL(snd_trident_synth_alloc);
+EXPORT_SYMBOL(snd_trident_synth_free);
+EXPORT_SYMBOL(snd_trident_synth_copy_from_user);
