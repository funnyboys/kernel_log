commit 51055da51d1e92bb089c9b9e0ecb1be69396f808
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:43 2020 +0100

    ALSA: pci: Constify snd_ac97_bus_ops definitions
    
    Now snd_ac97_bus() takes the const ops pointer, so we can define the
    snd_ac97_bus_ops locally as const as well for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-28-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 64d978307755..8d2471ea090b 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -294,7 +294,7 @@ static int snd_als300_ac97(struct snd_als300 *chip)
 	struct snd_ac97_bus *bus;
 	struct snd_ac97_template ac97;
 	int err;
-	static struct snd_ac97_bus_ops ops = {
+	static const struct snd_ac97_bus_ops ops = {
 		.write = snd_als300_ac97_write,
 		.read = snd_als300_ac97_read,
 	};

commit efb0ad25d370344e61bb4fca8c3b9c3c6047922e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:25 2020 +0100

    ALSA: pci: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 6573a2259cb6..64d978307755 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -617,7 +617,7 @@ static int snd_als300_create(struct snd_card *card,
 	void *irq_handler;
 	int err;
 
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free = snd_als300_dev_free,
 	};
 	*rchip = NULL;

commit ea2eab50a0e1a868a87b407f51a6b45b9062ee08
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:02 2019 +0100

    ALSA: als300: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-4-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 0fb84d1d1dbe..6573a2259cb6 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -664,7 +664,7 @@ static int snd_als300_create(struct snd_card *card,
 		return -EBUSY;
 	}
 	chip->irq = pci->irq;
-
+	card->sync_irq = chip->irq;
 
 	snd_als300_init(chip);
 

commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 0bb5a0fea23a..0fb84d1d1dbe 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -539,7 +539,6 @@ static snd_pcm_uframes_t snd_als300_pointer(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_als300_playback_ops = {
 	.open =		snd_als300_playback_open,
 	.close =	snd_als300_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_als300_playback_prepare,
 	.trigger =	snd_als300_trigger,
 	.pointer =	snd_als300_pointer,
@@ -548,7 +547,6 @@ static const struct snd_pcm_ops snd_als300_playback_ops = {
 static const struct snd_pcm_ops snd_als300_capture_ops = {
 	.open =		snd_als300_capture_open,
 	.close =	snd_als300_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_als300_capture_prepare,
 	.trigger =	snd_als300_trigger,
 	.pointer =	snd_als300_pointer,

commit 909c7d2cccc386f087cb4dcc4207b9931ddd6601
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:48:53 2019 +0100

    ALSA: als300: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The hw_params and hw_free callbacks became superfluous and got
    dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-22-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index cfbb8cacaaac..0bb5a0fea23a 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -378,7 +378,6 @@ static int snd_als300_playback_close(struct snd_pcm_substream *substream)
 	data = substream->runtime->private_data;
 	kfree(data);
 	chip->playback_substream = NULL;
-	snd_pcm_lib_free_pages(substream);
 	return 0;
 }
 
@@ -407,22 +406,9 @@ static int snd_als300_capture_close(struct snd_pcm_substream *substream)
 	data = substream->runtime->private_data;
 	kfree(data);
 	chip->capture_substream = NULL;
-	snd_pcm_lib_free_pages(substream);
 	return 0;
 }
 
-static int snd_als300_pcm_hw_params(struct snd_pcm_substream *substream,
-				    struct snd_pcm_hw_params *hw_params)
-{
-	return snd_pcm_lib_malloc_pages(substream,
-					params_buffer_bytes(hw_params));
-}
-
-static int snd_als300_pcm_hw_free(struct snd_pcm_substream *substream)
-{
-	return snd_pcm_lib_free_pages(substream);
-}
-
 static int snd_als300_playback_prepare(struct snd_pcm_substream *substream)
 {
 	u32 tmp;
@@ -554,8 +540,6 @@ static const struct snd_pcm_ops snd_als300_playback_ops = {
 	.open =		snd_als300_playback_open,
 	.close =	snd_als300_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_als300_pcm_hw_params,
-	.hw_free =	snd_als300_pcm_hw_free,
 	.prepare =	snd_als300_playback_prepare,
 	.trigger =	snd_als300_trigger,
 	.pointer =	snd_als300_pointer,
@@ -565,8 +549,6 @@ static const struct snd_pcm_ops snd_als300_capture_ops = {
 	.open =		snd_als300_capture_open,
 	.close =	snd_als300_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_als300_pcm_hw_params,
-	.hw_free =	snd_als300_pcm_hw_free,
 	.prepare =	snd_als300_capture_prepare,
 	.trigger =	snd_als300_trigger,
 	.pointer =	snd_als300_pointer,
@@ -591,9 +573,8 @@ static int snd_als300_new_pcm(struct snd_als300 *chip)
 				&snd_als300_capture_ops);
 
 	/* pre-allocation of buffers */
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &chip->pci->dev,
-					      64*1024, 64*1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, &chip->pci->dev,
+				       64*1024, 64*1024);
 	return 0;
 }
 

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 530799c8d3ce..cfbb8cacaaac 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -592,7 +592,8 @@ static int snd_als300_new_pcm(struct snd_als300 *chip)
 
 	/* pre-allocation of buffers */
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-	snd_dma_pci_data(chip->pci), 64*1024, 64*1024);
+					      &chip->pci->dev,
+					      64*1024, 64*1024);
 	return 0;
 }
 

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 516b3d9cbfdf..530799c8d3ce 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -1,21 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  als300.c - driver for Avance Logic ALS300/ALS300+ soundcards.
  *  Copyright (C) 2005 by Ash Willis <ashwillis@programmer.net>
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  *  TODO
  *  4 channel playback for ALS300+
  *  gameport

commit 17bc4815de586d001c82d0ddf75247283c3f002a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:02:51 2019 +0100

    ALSA: pci: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index eaa2d853d922..516b3d9cbfdf 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -731,7 +731,6 @@ static int snd_als300_suspend(struct device *dev)
 	struct snd_als300 *chip = card->private_data;
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
-	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
 	return 0;
 }

commit dee49895b197936c02d27d651e58c90bac18f452
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:28 2017 +0530

    ALSA: pci: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index ab75601d7c2c..eaa2d853d922 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -328,7 +328,7 @@ static int snd_als300_ac97(struct snd_als300 *chip)
  * the card when it is running outside of legacy
  * mode.
  */
-static struct snd_pcm_hardware snd_als300_playback_hw =
+static const struct snd_pcm_hardware snd_als300_playback_hw =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP |
 				SNDRV_PCM_INFO_INTERLEAVED |
@@ -347,7 +347,7 @@ static struct snd_pcm_hardware snd_als300_playback_hw =
 	.periods_max =		2,
 };
 
-static struct snd_pcm_hardware snd_als300_capture_hw =
+static const struct snd_pcm_hardware snd_als300_capture_hw =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP |
 				SNDRV_PCM_INFO_INTERLEAVED |

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index add3176398d3..ab75601d7c2c 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -563,7 +563,7 @@ static snd_pcm_uframes_t snd_als300_pointer(struct snd_pcm_substream *substream)
 	return bytes_to_frames(substream->runtime, current_ptr);
 }
 
-static struct snd_pcm_ops snd_als300_playback_ops = {
+static const struct snd_pcm_ops snd_als300_playback_ops = {
 	.open =		snd_als300_playback_open,
 	.close =	snd_als300_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -574,7 +574,7 @@ static struct snd_pcm_ops snd_als300_playback_ops = {
 	.pointer =	snd_als300_pointer,
 };
 
-static struct snd_pcm_ops snd_als300_capture_ops = {
+static const struct snd_pcm_ops snd_als300_capture_ops = {
 	.open =		snd_als300_capture_open,
 	.close =	snd_als300_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,

commit 412b979ccceff448dccea54bdb616c85781bc0ba
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Wed Apr 15 16:10:17 2015 +0200

    ALSA: remove deprecated use of pci api
    
    Replace occurences of the pci api by appropriate call to the dma api.
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr)
    
    @deprecated@
    idexpression id;
    position p;
    @@
    
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @bad1@
    idexpression id;
    position deprecated.p;
    @@
    ...when != &id->dev
       when != pci_get_drvdata ( id )
       when != pci_enable_device ( id )
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @depends on !bad1@
    idexpression id;
    expression direction;
    position deprecated.p;
    @@
    
    (
    - pci_dma_supported@p ( id,
    + dma_supported ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    |
    - pci_alloc_consistent@p ( id,
    + dma_alloc_coherent ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    )
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 57e034f208dc..add3176398d3 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -658,8 +658,8 @@ static int snd_als300_create(struct snd_card *card,
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 
-	if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) < 0 ||
-		pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) < 0) {
+	if (dma_set_mask(&pci->dev, DMA_BIT_MASK(28)) < 0 ||
+		dma_set_coherent_mask(&pci->dev, DMA_BIT_MASK(28)) < 0) {
 		dev_err(card->dev, "error setting 28bit DMA mask\n");
 		pci_disable_device(pci);
 		return -ENXIO;

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index bd01113de39a..57e034f208dc 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -37,8 +37,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
-
-#include <asm/io.h>
+#include <linux/io.h>
 
 #include <sound/core.h>
 #include <sound/control.h>

commit 08aa0e34305059a80f38e039f085fe91a7587cca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 8 12:43:46 2015 +0100

    ALSA: als300: Simplify PM callbacks
    
    This is a similar cleanup like the commit [3db084fd0af5: ALSA: fm801:
    PCI core handles power state for us].
    
    Since pci_set_power_state(), pci_save_state() and pci_restore_state()
    are already done in the PCI core side, so we don't need to it doubly.
    
    Also, pci_enable_device(), pci_disable_device() and pci_set_master()
    calls in PM callbacks are superfluous nowadays, too, so get rid of
    them as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 7bb6ac565107..bd01113de39a 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -728,35 +728,20 @@ static int snd_als300_create(struct snd_card *card,
 #ifdef CONFIG_PM_SLEEP
 static int snd_als300_suspend(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_als300 *chip = card->private_data;
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
-
-	pci_disable_device(pci);
-	pci_save_state(pci);
-	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
 static int snd_als300_resume(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_als300 *chip = card->private_data;
 
-	pci_set_power_state(pci, PCI_D0);
-	pci_restore_state(pci);
-	if (pci_enable_device(pci) < 0) {
-		dev_err(dev, "pci_enable_device failed, disabling device\n");
-		snd_card_disconnect(card);
-		return -EIO;
-	}
-	pci_set_master(pci);
-
 	snd_als300_init(chip);
 	snd_ac97_resume(chip->ac97);
 

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index cc9a15a1304b..7bb6ac565107 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -141,7 +141,7 @@ struct snd_als300_substream_data {
 	int block_counter_register;
 };
 
-static DEFINE_PCI_DEVICE_TABLE(snd_als300_ids) = {
+static const struct pci_device_id snd_als300_ids[] = {
 	{ 0x4005, 0x0300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_ALS300 },
 	{ 0x4005, 0x0308, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_ALS300_PLUS },
 	{ 0, }

commit c778f7ec74535196d225d1668cd3af57abcff89e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 12:48:27 2014 +0100

    ALSA: als300: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    Also, correct the printk level appropriately.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index fc1043a79007..cc9a15a1304b 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -661,7 +661,7 @@ static int snd_als300_create(struct snd_card *card,
 
 	if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) < 0 ||
 		pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) < 0) {
-		printk(KERN_ERR "error setting 28bit DMA mask\n");
+		dev_err(card->dev, "error setting 28bit DMA mask\n");
 		pci_disable_device(pci);
 		return -ENXIO;
 	}
@@ -693,7 +693,7 @@ static int snd_als300_create(struct snd_card *card,
 
 	if (request_irq(pci->irq, irq_handler, IRQF_SHARED,
 			KBUILD_MODNAME, chip)) {
-		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		dev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);
 		snd_als300_free(chip);
 		return -EBUSY;
 	}
@@ -704,13 +704,13 @@ static int snd_als300_create(struct snd_card *card,
 
 	err = snd_als300_ac97(chip);
 	if (err < 0) {
-		snd_printk(KERN_WARNING "Could not create ac97\n");
+		dev_err(card->dev, "Could not create ac97\n");
 		snd_als300_free(chip);
 		return err;
 	}
 
 	if ((err = snd_als300_new_pcm(chip)) < 0) {
-		snd_printk(KERN_WARNING "Could not create PCM\n");
+		dev_err(card->dev, "Could not create PCM\n");
 		snd_als300_free(chip);
 		return err;
 	}
@@ -751,8 +751,7 @@ static int snd_als300_resume(struct device *dev)
 	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
 	if (pci_enable_device(pci) < 0) {
-		printk(KERN_ERR "als300: pci_enable_device failed, "
-		       "disabling device\n");
+		dev_err(dev, "pci_enable_device failed, disabling device\n");
 		snd_card_disconnect(card);
 		return -EIO;
 	}

commit bc340c3350fe411796df345815570322dc9969be
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 12:46:10 2014 +0100

    ALSA: als300: Remove function debug prints
    
    We have a better infrastructure in general, so let's reduce the
    home-baked debug macros.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 9acd88ab93a4..fc1043a79007 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -87,19 +87,8 @@
 #define PLAYBACK_BLOCK_COUNTER	0x9A
 #define RECORD_BLOCK_COUNTER	0x9B
 
-#define DEBUG_CALLS	0
 #define DEBUG_PLAY_REC	0
 
-#if DEBUG_CALLS
-#define snd_als300_dbgcalls(format, args...) printk(KERN_DEBUG format, ##args)
-#define snd_als300_dbgcallenter() printk(KERN_ERR "--> %s\n", __func__)
-#define snd_als300_dbgcallleave() printk(KERN_ERR "<-- %s\n", __func__)
-#else
-#define snd_als300_dbgcalls(format, args...)
-#define snd_als300_dbgcallenter()
-#define snd_als300_dbgcallleave()
-#endif
-
 #if DEBUG_PLAY_REC
 #define snd_als300_dbgplay(format, args...) printk(KERN_ERR format, ##args)
 #else
@@ -177,7 +166,6 @@ static inline void snd_als300_gcr_write(unsigned long port,
 static void snd_als300_set_irq_flag(struct snd_als300 *chip, int cmd)
 {
 	u32 tmp = snd_als300_gcr_read(chip->port, MISC_CONTROL);
-	snd_als300_dbgcallenter();
 
 	/* boolean XOR check, since old vs. new hardware have
 	   directly reversed bit setting for ENABLE and DISABLE.
@@ -188,19 +176,16 @@ static void snd_als300_set_irq_flag(struct snd_als300 *chip, int cmd)
 	else
 		tmp &= ~IRQ_SET_BIT;
 	snd_als300_gcr_write(chip->port, MISC_CONTROL, tmp);
-	snd_als300_dbgcallleave();
 }
 
 static int snd_als300_free(struct snd_als300 *chip)
 {
-	snd_als300_dbgcallenter();
 	snd_als300_set_irq_flag(chip, IRQ_DISABLE);
 	if (chip->irq >= 0)
 		free_irq(chip->irq, chip);
 	pci_release_regions(chip->pci);
 	pci_disable_device(chip->pci);
 	kfree(chip);
-	snd_als300_dbgcallleave();
 	return 0;
 }
 
@@ -280,9 +265,7 @@ static irqreturn_t snd_als300plus_interrupt(int irq, void *dev_id)
 
 static void snd_als300_remove(struct pci_dev *pci)
 {
-	snd_als300_dbgcallenter();
 	snd_card_free(pci_get_drvdata(pci));
-	snd_als300_dbgcallleave();
 }
 
 static unsigned short snd_als300_ac97_read(struct snd_ac97 *ac97,
@@ -330,14 +313,12 @@ static int snd_als300_ac97(struct snd_als300 *chip)
 		.read = snd_als300_ac97_read,
 	};
 
-	snd_als300_dbgcallenter();
 	if ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &bus)) < 0)
 		return err;
 
 	memset(&ac97, 0, sizeof(ac97));
 	ac97.private_data = chip;
 
-	snd_als300_dbgcallleave();
 	return snd_ac97_mixer(bus, &ac97, &chip->ac97);
 }
 
@@ -395,13 +376,11 @@ static int snd_als300_playback_open(struct snd_pcm_substream *substream)
 
 	if (!data)
 		return -ENOMEM;
-	snd_als300_dbgcallenter();
 	chip->playback_substream = substream;
 	runtime->hw = snd_als300_playback_hw;
 	runtime->private_data = data;
 	data->control_register = PLAYBACK_CONTROL;
 	data->block_counter_register = PLAYBACK_BLOCK_COUNTER;
-	snd_als300_dbgcallleave();
 	return 0;
 }
 
@@ -411,11 +390,9 @@ static int snd_als300_playback_close(struct snd_pcm_substream *substream)
 	struct snd_als300_substream_data *data;
 
 	data = substream->runtime->private_data;
-	snd_als300_dbgcallenter();
 	kfree(data);
 	chip->playback_substream = NULL;
 	snd_pcm_lib_free_pages(substream);
-	snd_als300_dbgcallleave();
 	return 0;
 }
 
@@ -428,13 +405,11 @@ static int snd_als300_capture_open(struct snd_pcm_substream *substream)
 
 	if (!data)
 		return -ENOMEM;
-	snd_als300_dbgcallenter();
 	chip->capture_substream = substream;
 	runtime->hw = snd_als300_capture_hw;
 	runtime->private_data = data;
 	data->control_register = RECORD_CONTROL;
 	data->block_counter_register = RECORD_BLOCK_COUNTER;
-	snd_als300_dbgcallleave();
 	return 0;
 }
 
@@ -444,11 +419,9 @@ static int snd_als300_capture_close(struct snd_pcm_substream *substream)
 	struct snd_als300_substream_data *data;
 
 	data = substream->runtime->private_data;
-	snd_als300_dbgcallenter();
 	kfree(data);
 	chip->capture_substream = NULL;
 	snd_pcm_lib_free_pages(substream);
-	snd_als300_dbgcallleave();
 	return 0;
 }
 
@@ -472,7 +445,6 @@ static int snd_als300_playback_prepare(struct snd_pcm_substream *substream)
 	unsigned short period_bytes = snd_pcm_lib_period_bytes(substream);
 	unsigned short buffer_bytes = snd_pcm_lib_buffer_bytes(substream);
 	
-	snd_als300_dbgcallenter();
 	spin_lock_irq(&chip->reg_lock);
 	tmp = snd_als300_gcr_read(chip->port, PLAYBACK_CONTROL);
 	tmp &= ~TRANSFER_START;
@@ -491,7 +463,6 @@ static int snd_als300_playback_prepare(struct snd_pcm_substream *substream)
 	snd_als300_gcr_write(chip->port, PLAYBACK_END,
 					runtime->dma_addr + buffer_bytes - 1);
 	spin_unlock_irq(&chip->reg_lock);
-	snd_als300_dbgcallleave();
 	return 0;
 }
 
@@ -503,7 +474,6 @@ static int snd_als300_capture_prepare(struct snd_pcm_substream *substream)
 	unsigned short period_bytes = snd_pcm_lib_period_bytes(substream);
 	unsigned short buffer_bytes = snd_pcm_lib_buffer_bytes(substream);
 
-	snd_als300_dbgcallenter();
 	spin_lock_irq(&chip->reg_lock);
 	tmp = snd_als300_gcr_read(chip->port, RECORD_CONTROL);
 	tmp &= ~TRANSFER_START;
@@ -522,7 +492,6 @@ static int snd_als300_capture_prepare(struct snd_pcm_substream *substream)
 	snd_als300_gcr_write(chip->port, RECORD_END,
 					runtime->dma_addr + buffer_bytes - 1);
 	spin_unlock_irq(&chip->reg_lock);
-	snd_als300_dbgcallleave();
 	return 0;
 }
 
@@ -537,7 +506,6 @@ static int snd_als300_trigger(struct snd_pcm_substream *substream, int cmd)
 	data = substream->runtime->private_data;
 	reg = data->control_register;
 
-	snd_als300_dbgcallenter();
 	spin_lock(&chip->reg_lock);
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -568,7 +536,6 @@ static int snd_als300_trigger(struct snd_pcm_substream *substream, int cmd)
 		ret = -EINVAL;
 	}
 	spin_unlock(&chip->reg_lock);
-	snd_als300_dbgcallleave();
 	return ret;
 }
 
@@ -582,7 +549,6 @@ static snd_pcm_uframes_t snd_als300_pointer(struct snd_pcm_substream *substream)
 	data = substream->runtime->private_data;
 	period_bytes = snd_pcm_lib_period_bytes(substream);
 	
-	snd_als300_dbgcallenter();
 	spin_lock(&chip->reg_lock);
 	current_ptr = (u16) snd_als300_gcr_read(chip->port,
 					data->block_counter_register) + 4;
@@ -595,7 +561,6 @@ static snd_pcm_uframes_t snd_als300_pointer(struct snd_pcm_substream *substream)
 	if (data->period_flipflop == 0)
 		current_ptr += period_bytes;
 	snd_als300_dbgplay("Pointer (bytes): %d\n", current_ptr);
-	snd_als300_dbgcallleave();
 	return bytes_to_frames(substream->runtime, current_ptr);
 }
 
@@ -626,7 +591,6 @@ static int snd_als300_new_pcm(struct snd_als300 *chip)
 	struct snd_pcm *pcm;
 	int err;
 
-	snd_als300_dbgcallenter();
 	err = snd_pcm_new(chip->card, "ALS300", 0, 1, 1, &pcm);
 	if (err < 0)
 		return err;
@@ -643,7 +607,6 @@ static int snd_als300_new_pcm(struct snd_als300 *chip)
 	/* pre-allocation of buffers */
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
 	snd_dma_pci_data(chip->pci), 64*1024, 64*1024);
-	snd_als300_dbgcallleave();
 	return 0;
 }
 
@@ -652,7 +615,6 @@ static void snd_als300_init(struct snd_als300 *chip)
 	unsigned long flags;
 	u32 tmp;
 	
-	snd_als300_dbgcallenter();
 	spin_lock_irqsave(&chip->reg_lock, flags);
 	chip->revision = (snd_als300_gcr_read(chip->port, MISC_CONTROL) >> 16)
 								& 0x0000000F;
@@ -679,7 +641,6 @@ static void snd_als300_init(struct snd_als300 *chip)
 	snd_als300_gcr_write(chip->port, PLAYBACK_CONTROL,
 			tmp & ~TRANSFER_START);
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
-	snd_als300_dbgcallleave();
 }
 
 static int snd_als300_create(struct snd_card *card,
@@ -695,7 +656,6 @@ static int snd_als300_create(struct snd_card *card,
 	};
 	*rchip = NULL;
 
-	snd_als300_dbgcallenter();
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 
@@ -762,7 +722,6 @@ static int snd_als300_create(struct snd_card *card,
 	}
 
 	*rchip = chip;
-	snd_als300_dbgcallleave();
 	return 0;
 }
 

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 591efb6eef05..9acd88ab93a4 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -761,8 +761,6 @@ static int snd_als300_create(struct snd_card *card,
 		return err;
 	}
 
-	snd_card_set_dev(card, &pci->dev);
-
 	*rchip = chip;
 	snd_als300_dbgcallleave();
 	return 0;
@@ -829,7 +827,8 @@ static int snd_als300_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
+			   0, &card);
 
 	if (err < 0)
 		return err;

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 864c4310366b..591efb6eef05 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -282,7 +282,6 @@ static void snd_als300_remove(struct pci_dev *pci)
 {
 	snd_als300_dbgcallenter();
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 	snd_als300_dbgcallleave();
 }
 

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 5af3cb6b0c18..864c4310366b 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -278,7 +278,7 @@ static irqreturn_t snd_als300plus_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static void __devexit snd_als300_remove(struct pci_dev *pci)
+static void snd_als300_remove(struct pci_dev *pci)
 {
 	snd_als300_dbgcallenter();
 	snd_card_free(pci_get_drvdata(pci));
@@ -622,7 +622,7 @@ static struct snd_pcm_ops snd_als300_capture_ops = {
 	.pointer =	snd_als300_pointer,
 };
 
-static int __devinit snd_als300_new_pcm(struct snd_als300 *chip)
+static int snd_als300_new_pcm(struct snd_als300 *chip)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -683,9 +683,9 @@ static void snd_als300_init(struct snd_als300 *chip)
 	snd_als300_dbgcallleave();
 }
 
-static int __devinit snd_als300_create(struct snd_card *card,
-				       struct pci_dev *pci, int chip_type,
-				       struct snd_als300 **rchip)
+static int snd_als300_create(struct snd_card *card,
+			     struct pci_dev *pci, int chip_type,
+			     struct snd_als300 **rchip)
 {
 	struct snd_als300 *chip;
 	void *irq_handler;
@@ -815,7 +815,7 @@ static SIMPLE_DEV_PM_OPS(snd_als300_pm, snd_als300_suspend, snd_als300_resume);
 #define SND_ALS300_PM_OPS	NULL
 #endif
 
-static int __devinit snd_als300_probe(struct pci_dev *pci,
+static int snd_als300_probe(struct pci_dev *pci,
                              const struct pci_device_id *pci_id)
 {
 	static int dev;
@@ -867,7 +867,7 @@ static struct pci_driver als300_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_als300_ids,
 	.probe = snd_als300_probe,
-	.remove = __devexit_p(snd_als300_remove),
+	.remove = snd_als300_remove,
 	.driver = {
 		.pm = SND_ALS300_PM_OPS,
 	},

commit 21b3de881b38a84002c07b1b4bfb91892644e83f
Author: Denis Kirjanov <kirjanov@gmail.com>
Date:   Mon Oct 22 17:05:53 2012 +0400

    ALSA: als3000: check for the kzalloc return value
    
    Signed-off-by: Denis Kirjanov <kirjanov@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 00f157a2cf64..5af3cb6b0c18 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -394,6 +394,8 @@ static int snd_als300_playback_open(struct snd_pcm_substream *substream)
 	struct snd_als300_substream_data *data = kzalloc(sizeof(*data),
 								GFP_KERNEL);
 
+	if (!data)
+		return -ENOMEM;
 	snd_als300_dbgcallenter();
 	chip->playback_substream = substream;
 	runtime->hw = snd_als300_playback_hw;
@@ -425,6 +427,8 @@ static int snd_als300_capture_open(struct snd_pcm_substream *substream)
 	struct snd_als300_substream_data *data = kzalloc(sizeof(*data),
 								GFP_KERNEL);
 
+	if (!data)
+		return -ENOMEM;
 	snd_als300_dbgcallenter();
 	chip->capture_substream = substream;
 	runtime->hw = snd_als300_capture_hw;

commit c7561cd80469f2fe4a6be0984db57832ee7f2a3b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 14 18:12:04 2012 +0200

    ALSA: PCI: Replace CONFIG_PM with CONFIG_PM_SLEEP
    
    Otherwise we may get compile warnings due to unused functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 68c4469c6d19..00f157a2cf64 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -765,7 +765,7 @@ static int __devinit snd_als300_create(struct snd_card *card,
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int snd_als300_suspend(struct device *dev)
 {
 	struct pci_dev *pci = to_pci_dev(dev);

commit 68cb2b559278858ef9f3a7722f95df88797c7840
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 15:20:37 2012 +0200

    ALSA: Convert to new pm_ops for PCI drivers
    
    Straightforward conversion to the new pm_ops from the legacy
    suspend/resume ops.
    
    Since we change vx222, vx_core and vxpocket have to be converted,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 59d65388faf5..68c4469c6d19 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -766,9 +766,10 @@ static int __devinit snd_als300_create(struct snd_card *card,
 }
 
 #ifdef CONFIG_PM
-static int snd_als300_suspend(struct pci_dev *pci, pm_message_t state)
+static int snd_als300_suspend(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_als300 *chip = card->private_data;
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
@@ -777,13 +778,14 @@ static int snd_als300_suspend(struct pci_dev *pci, pm_message_t state)
 
 	pci_disable_device(pci);
 	pci_save_state(pci);
-	pci_set_power_state(pci, pci_choose_state(pci, state));
+	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
-static int snd_als300_resume(struct pci_dev *pci)
+static int snd_als300_resume(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct snd_als300 *chip = card->private_data;
 
 	pci_set_power_state(pci, PCI_D0);
@@ -802,6 +804,11 @@ static int snd_als300_resume(struct pci_dev *pci)
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
+
+static SIMPLE_DEV_PM_OPS(snd_als300_pm, snd_als300_suspend, snd_als300_resume);
+#define SND_ALS300_PM_OPS	&snd_als300_pm
+#else
+#define SND_ALS300_PM_OPS	NULL
 #endif
 
 static int __devinit snd_als300_probe(struct pci_dev *pci,
@@ -857,10 +864,9 @@ static struct pci_driver als300_driver = {
 	.id_table = snd_als300_ids,
 	.probe = snd_als300_probe,
 	.remove = __devexit_p(snd_als300_remove),
-#ifdef CONFIG_PM
-	.suspend = snd_als300_suspend,
-	.resume = snd_als300_resume,
-#endif
+	.driver = {
+		.pm = SND_ALS300_PM_OPS,
+	},
 };
 
 module_pci_driver(als300_driver);

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 8196e229b2df..59d65388faf5 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -852,7 +852,7 @@ static int __devinit snd_als300_probe(struct pci_dev *pci,
 	return 0;
 }
 
-static struct pci_driver driver = {
+static struct pci_driver als300_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_als300_ids,
 	.probe = snd_als300_probe,
@@ -863,15 +863,4 @@ static struct pci_driver driver = {
 #endif
 };
 
-static int __init alsa_card_als300_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit alsa_card_als300_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(alsa_card_als300_init)
-module_exit(alsa_card_als300_exit)
+module_pci_driver(als300_driver);

commit cde944803d12450f70f0adc4d418afcd8e42db2e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 19 10:32:48 2011 +0100

    ALSA: Add missing module parameters for als300 and cs5530 drivers
    
    These drviers defined only variables but didn't declare as module
    parameters.  Also fix the enable variable to bool type.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 8dc77a0a5d8b..8196e229b2df 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -115,7 +115,14 @@ MODULE_SUPPORTED_DEVICE("{{Avance Logic,ALS300},{Avance Logic,ALS300+}}");
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for ALS300 sound card.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for ALS300 sound card.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable ALS300 sound card.");
 
 struct snd_als300 {
 	unsigned long port;

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 736c8e93db1f..8dc77a0a5d8b 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -32,7 +32,7 @@
 
 #include <linux/delay.h>
 #include <linux/init.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/dma-mapping.h>
 #include <linux/interrupt.h>

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 0958daccd15e..736c8e93db1f 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -722,7 +722,7 @@ static int __devinit snd_als300_create(struct snd_card *card,
 		irq_handler = snd_als300_interrupt;
 
 	if (request_irq(pci->irq, irq_handler, IRQF_SHARED,
-			card->shortname, chip)) {
+			KBUILD_MODNAME, chip)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_als300_free(chip);
 		return -EBUSY;

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index d7653cb7ac60..0958daccd15e 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -846,7 +846,7 @@ static int __devinit snd_als300_probe(struct pci_dev *pci,
 }
 
 static struct pci_driver driver = {
-	.name = "ALS300",
+	.name = KBUILD_MODNAME,
 	.id_table = snd_als300_ids,
 	.probe = snd_als300_probe,
 	.remove = __devexit_p(snd_als300_remove),

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 3aa35af7ca91..d7653cb7ac60 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -145,7 +145,7 @@ struct snd_als300_substream_data {
 	int block_counter_register;
 };
 
-static struct pci_device_id snd_als300_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_als300_ids) = {
 	{ 0x4005, 0x0300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_ALS300 },
 	{ 0x4005, 0x0308, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_ALS300_PLUS },
 	{ 0, }

commit ce0b620160e6d15a7f5b4b00cd7b8bd956d427d1
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:17 2009 -0700

    dma-mapping: replace all DMA_28BIT_MASK macro with DMA_BIT_MASK(28)
    
    Replace all DMA_28BIT_MASK macro with DMA_BIT_MASK(28)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 009b4c8225a5..3aa35af7ca91 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -689,8 +689,8 @@ static int __devinit snd_als300_create(struct snd_card *card,
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 
-	if (pci_set_dma_mask(pci, DMA_28BIT_MASK) < 0 ||
-		pci_set_consistent_dma_mask(pci, DMA_28BIT_MASK) < 0) {
+	if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) < 0 ||
+		pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) < 0) {
 		printk(KERN_ERR "error setting 28bit DMA mask\n");
 		pci_disable_device(pci);
 		return -ENXIO;

commit e0d2054fd3cf167395390dc1758644486c782707
Merge: d807500a2472 c468ac29e63b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:35:50 2009 +0100

    Merge branch 'topic/misc' into for-linus

commit ee419653a38de93b75a577851d9e4003cf0bbe07
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 16:11:31 2009 +0100

    ALSA: Fix missing KERN_* prefix to printk in sound/pci
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 8df6824b51cd..a2c35c1081c3 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -91,7 +91,7 @@
 #define DEBUG_PLAY_REC	0
 
 #if DEBUG_CALLS
-#define snd_als300_dbgcalls(format, args...) printk(format, ##args)
+#define snd_als300_dbgcalls(format, args...) printk(KERN_DEBUG format, ##args)
 #define snd_als300_dbgcallenter() printk(KERN_ERR "--> %s\n", __func__)
 #define snd_als300_dbgcallleave() printk(KERN_ERR "<-- %s\n", __func__)
 #else

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 8df6824b51cd..f557c155db48 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -812,10 +812,10 @@ static int __devinit snd_als300_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
 
-	if (card == NULL)
-		return -ENOMEM;
+	if (err < 0)
+		return err;
 
 	chip_type = pci_id->driver_data;
 

commit 9bf8e7ddeaf57f1ec534014c447705ad31d5d721
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 15:32:18 2008 -0800

    [ALSA] sound: replace remaining __FUNCTION__ occurences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 0e990a735821..8df6824b51cd 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -92,8 +92,8 @@
 
 #if DEBUG_CALLS
 #define snd_als300_dbgcalls(format, args...) printk(format, ##args)
-#define snd_als300_dbgcallenter() printk(KERN_ERR "--> %s\n", __FUNCTION__)
-#define snd_als300_dbgcallleave() printk(KERN_ERR "<-- %s\n", __FUNCTION__)
+#define snd_als300_dbgcallenter() printk(KERN_ERR "--> %s\n", __func__)
+#define snd_als300_dbgcallleave() printk(KERN_ERR "<-- %s\n", __func__)
 #else
 #define snd_als300_dbgcalls(format, args...)
 #define snd_als300_dbgcallenter()

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 48cc39b771d9..0e990a735821 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -30,7 +30,6 @@
  *  to keep track of what period we are in.
  */
 
-#include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/moduleparam.h>

commit 65ff2357a7e40bf4b42858516861c3d0e19f512b
Author: Ash Willis <ashwillis@programmer.net>
Date:   Tue May 29 14:34:17 2007 +0200

    [ALSA] Disable debugging output for the ALS300 driver
    
    Disables debugging output in the ALS300 driver.
    Also contains a whitespace cleanup and a fix for a potential bug.
    
    Signed-off-by: Ash Willis <ashwillis@programmer.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 8afcb98ca7bb..48cc39b771d9 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -88,8 +88,8 @@
 #define PLAYBACK_BLOCK_COUNTER	0x9A
 #define RECORD_BLOCK_COUNTER	0x9B
 
-#define DEBUG_CALLS	1
-#define DEBUG_PLAY_REC	1
+#define DEBUG_CALLS	0
+#define DEBUG_PLAY_REC	0
 
 #if DEBUG_CALLS
 #define snd_als300_dbgcalls(format, args...) printk(format, ##args)
@@ -733,7 +733,8 @@ static int __devinit snd_als300_create(struct snd_card *card,
 
 	snd_als300_init(chip);
 
-	if (snd_als300_ac97(chip) < 0) {
+	err = snd_als300_ac97(chip);
+	if (err < 0) {
 		snd_printk(KERN_WARNING "Could not create ac97\n");
 		snd_als300_free(chip);
 		return err;

commit d1d985f019c3b290e09881b7b23abdc87aee2895
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 23 19:27:12 2006 +0100

    [ALSA] Fix obsolete *_t typedefs
    
    Fixed obsolete *_t typedefs.  Now completely removed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 9f406fbe0d95..8afcb98ca7bb 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -444,7 +444,7 @@ static int snd_als300_capture_close(struct snd_pcm_substream *substream)
 }
 
 static int snd_als300_pcm_hw_params(struct snd_pcm_substream *substream,
-					snd_pcm_hw_params_t * hw_params)
+				    struct snd_pcm_hw_params *hw_params)
 {
 	return snd_pcm_lib_malloc_pages(substream,
 					params_buffer_bytes(hw_params));
@@ -673,7 +673,7 @@ static void snd_als300_init(struct snd_als300 *chip)
 	snd_als300_dbgcallleave();
 }
 
-static int __devinit snd_als300_create(snd_card_t *card,
+static int __devinit snd_als300_create(struct snd_card *card,
 				       struct pci_dev *pci, int chip_type,
 				       struct snd_als300 **rchip)
 {
@@ -681,7 +681,7 @@ static int __devinit snd_als300_create(snd_card_t *card,
 	void *irq_handler;
 	int err;
 
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free = snd_als300_dev_free,
 	};
 	*rchip = NULL;

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 95f70f3cc37e..9f406fbe0d95 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -190,7 +190,7 @@ static int snd_als300_free(struct snd_als300 *chip)
 	snd_als300_dbgcallenter();
 	snd_als300_set_irq_flag(chip, IRQ_DISABLE);
 	if (chip->irq >= 0)
-		free_irq(chip->irq, (void *)chip);
+		free_irq(chip->irq, chip);
 	pci_release_regions(chip->pci);
 	pci_disable_device(chip->pci);
 	kfree(chip);
@@ -722,8 +722,8 @@ static int __devinit snd_als300_create(snd_card_t *card,
 	else
 		irq_handler = snd_als300_interrupt;
 
-	if (request_irq(pci->irq, irq_handler, IRQF_DISABLED|IRQF_SHARED,
-					card->shortname, (void *)chip)) {
+	if (request_irq(pci->irq, irq_handler, IRQF_SHARED,
+			card->shortname, chip)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_als300_free(chip);
 		return -EBUSY;

commit 30b35399ceb2398d05837863476dcb12f12f3a82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 11 18:52:53 2006 +0200

    [ALSA] Various fixes for suspend/resume of ALSA PCI drivers
    
    - Check the return value of pci_enable_device() and request_irq()
      in the suspend.  If any error occurs there, disable the device
      using snd_card_disconnect().
    - Call pci_set_power_state() properly with pci_choose_state().
    - Fix the order to call pci_set_power_state().
    - Removed obsolete house-made PM codes in some drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 9b16c299f0a9..95f70f3cc37e 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -768,9 +768,9 @@ static int snd_als300_suspend(struct pci_dev *pci, pm_message_t state)
 	snd_pcm_suspend_all(chip->pcm);
 	snd_ac97_suspend(chip->ac97);
 
-	pci_set_power_state(pci, PCI_D3hot);
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -779,9 +779,14 @@ static int snd_als300_resume(struct pci_dev *pci)
 	struct snd_card *card = pci_get_drvdata(pci);
 	struct snd_als300 *chip = card->private_data;
 
-	pci_restore_state(pci);
-	pci_enable_device(pci);
 	pci_set_power_state(pci, PCI_D0);
+	pci_restore_state(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "als300: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	snd_als300_init(chip);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 96cfb8ae5055..9b16c299f0a9 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -204,8 +204,7 @@ static int snd_als300_dev_free(struct snd_device *device)
 	return snd_als300_free(chip);
 }
 
-static irqreturn_t snd_als300_interrupt(int irq, void *dev_id,
-						struct pt_regs *regs)
+static irqreturn_t snd_als300_interrupt(int irq, void *dev_id)
 {
 	u8 status;
 	struct snd_als300 *chip = dev_id;
@@ -236,8 +235,7 @@ static irqreturn_t snd_als300_interrupt(int irq, void *dev_id,
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t snd_als300plus_interrupt(int irq, void *dev_id,
-						struct pt_regs *regs)
+static irqreturn_t snd_als300plus_interrupt(int irq, void *dev_id)
 {
 	u8 general, mpu, dram;
 	struct snd_als300 *chip = dev_id;

commit f40b68903ccd511ea9d658b4bce319dd032a265a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 16:51:05 2006 +0200

    [ALSA] Fix section mismatch errors in ALSA PCI drivers
    
    Fixed 'section mismatch' errors in ALSA PCI drivers:
    - removed invalid __devinitdata from pci id tables
    - fix/remove __devinit of functions called in suspend/resume
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index a9c38963188a..96cfb8ae5055 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -146,7 +146,7 @@ struct snd_als300_substream_data {
 	int block_counter_register;
 };
 
-static struct pci_device_id snd_als300_ids[] __devinitdata = {
+static struct pci_device_id snd_als300_ids[] = {
 	{ 0x4005, 0x0300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_ALS300 },
 	{ 0x4005, 0x0308, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_ALS300_PLUS },
 	{ 0, }

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 901b08ae9174..a9c38963188a 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -724,7 +724,7 @@ static int __devinit snd_als300_create(snd_card_t *card,
 	else
 		irq_handler = snd_als300_interrupt;
 
-	if (request_irq(pci->irq, irq_handler, SA_INTERRUPT|SA_SHIRQ,
+	if (request_irq(pci->irq, irq_handler, IRQF_DISABLED|IRQF_SHARED,
 					card->shortname, (void *)chip)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_als300_free(chip);

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 91899f87f037..901b08ae9174 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -146,7 +146,7 @@ struct snd_als300_substream_data {
 	int block_counter_register;
 };
 
-static struct pci_device_id snd_als300_ids[] = {
+static struct pci_device_id snd_als300_ids[] __devinitdata = {
 	{ 0x4005, 0x0300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_ALS300 },
 	{ 0x4005, 0x0308, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_ALS300_PLUS },
 	{ 0, }

commit 56b146d36db933844011d5026c6f55593037c7b8
Author: Tobias Klauser <tklauser@nuerscht.ch>
Date:   Mon Apr 10 22:54:21 2006 -0700

    [PATCH] Last DMA_xBIT_MASK cleanups
    
    These are the last conversions of pci_set_dma_mask(),
    pci_set_consistent_dma_mask() and pci_dma_supported() to use DMA_xBIT_MASK
    constants from linux/dma-mapping.h
    
    Signed-off-by: Tobias Klauser <tklauser@nuerscht.ch>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
index 37b80570a5c6..91899f87f037 100644
--- a/sound/pci/als300.c
+++ b/sound/pci/als300.c
@@ -35,6 +35,7 @@
 #include <linux/init.h>
 #include <linux/moduleparam.h>
 #include <linux/pci.h>
+#include <linux/dma-mapping.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 
@@ -691,8 +692,8 @@ static int __devinit snd_als300_create(snd_card_t *card,
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 
-	if (pci_set_dma_mask(pci, 0x0fffffff) < 0 ||
-		pci_set_consistent_dma_mask(pci, 0x0fffffff) < 0) {
+	if (pci_set_dma_mask(pci, DMA_28BIT_MASK) < 0 ||
+		pci_set_consistent_dma_mask(pci, DMA_28BIT_MASK) < 0) {
 		printk(KERN_ERR "error setting 28bit DMA mask\n");
 		pci_disable_device(pci);
 		return -ENXIO;

commit b3a70d5ece60684c00d7d94ccc42741efdf99336
Author: Ash Willis <ashwillis@programmer.net>
Date:   Mon Mar 27 13:20:40 2006 +0200

    [ALSA] Add snd-als300 driver for Avance Logic ALS300/ALS300+ soundcards
    
    Added snd-als300 driver for Avance Logic ALS300/ALS300+ soundcards
    by Ash Willis.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/als300.c b/sound/pci/als300.c
new file mode 100644
index 000000000000..37b80570a5c6
--- /dev/null
+++ b/sound/pci/als300.c
@@ -0,0 +1,866 @@
+/*
+ *  als300.c - driver for Avance Logic ALS300/ALS300+ soundcards.
+ *  Copyright (C) 2005 by Ash Willis <ashwillis@programmer.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *  TODO
+ *  4 channel playback for ALS300+
+ *  gameport
+ *  mpu401
+ *  opl3
+ *
+ *  NOTES
+ *  The BLOCK_COUNTER registers for the ALS300(+) return a figure related to
+ *  the position in the current period, NOT the whole buffer. It is important
+ *  to know which period we are in so we can calculate the correct pointer.
+ *  This is why we always use 2 periods. We can then use a flip-flop variable
+ *  to keep track of what period we are in.
+ */
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+
+#include <asm/io.h>
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/ac97_codec.h>
+#include <sound/opl3.h>
+
+/* snd_als300_set_irq_flag */
+#define IRQ_DISABLE		0
+#define IRQ_ENABLE		1
+
+/* I/O port layout */
+#define AC97_ACCESS		0x00
+#define AC97_READ		0x04
+#define AC97_STATUS		0x06
+#define   AC97_DATA_AVAIL		(1<<6)
+#define   AC97_BUSY			(1<<7)
+#define ALS300_IRQ_STATUS	0x07		/* ALS300 Only */
+#define   IRQ_PLAYBACK			(1<<3)
+#define   IRQ_CAPTURE			(1<<2)
+#define GCR_DATA		0x08
+#define GCR_INDEX		0x0C
+#define ALS300P_DRAM_IRQ_STATUS	0x0D		/* ALS300+ Only */
+#define MPU_IRQ_STATUS		0x0E		/* ALS300 Rev. E+, ALS300+ */
+#define ALS300P_IRQ_STATUS	0x0F		/* ALS300+ Only */
+
+/* General Control Registers */
+#define PLAYBACK_START		0x80
+#define PLAYBACK_END		0x81
+#define PLAYBACK_CONTROL	0x82
+#define   TRANSFER_START		(1<<16)
+#define   FIFO_PAUSE			(1<<17)
+#define RECORD_START		0x83
+#define RECORD_END		0x84
+#define RECORD_CONTROL		0x85
+#define DRAM_WRITE_CONTROL	0x8B
+#define   WRITE_TRANS_START		(1<<16)
+#define   DRAM_MODE_2			(1<<17)
+#define MISC_CONTROL		0x8C
+#define   IRQ_SET_BIT			(1<<15)
+#define   VMUTE_NORMAL			(1<<20)
+#define   MMUTE_NORMAL			(1<<21)
+#define MUS_VOC_VOL		0x8E
+#define PLAYBACK_BLOCK_COUNTER	0x9A
+#define RECORD_BLOCK_COUNTER	0x9B
+
+#define DEBUG_CALLS	1
+#define DEBUG_PLAY_REC	1
+
+#if DEBUG_CALLS
+#define snd_als300_dbgcalls(format, args...) printk(format, ##args)
+#define snd_als300_dbgcallenter() printk(KERN_ERR "--> %s\n", __FUNCTION__)
+#define snd_als300_dbgcallleave() printk(KERN_ERR "<-- %s\n", __FUNCTION__)
+#else
+#define snd_als300_dbgcalls(format, args...)
+#define snd_als300_dbgcallenter()
+#define snd_als300_dbgcallleave()
+#endif
+
+#if DEBUG_PLAY_REC
+#define snd_als300_dbgplay(format, args...) printk(KERN_ERR format, ##args)
+#else
+#define snd_als300_dbgplay(format, args...)
+#endif		
+
+enum {DEVICE_ALS300, DEVICE_ALS300_PLUS};
+
+MODULE_AUTHOR("Ash Willis <ashwillis@programmer.net>");
+MODULE_DESCRIPTION("Avance Logic ALS300");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{Avance Logic,ALS300},{Avance Logic,ALS300+}}");
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+
+struct snd_als300 {
+	unsigned long port;
+	spinlock_t reg_lock;
+	struct snd_card *card;
+	struct pci_dev *pci;
+
+	struct snd_pcm *pcm;
+	struct snd_pcm_substream *playback_substream;
+	struct snd_pcm_substream *capture_substream;
+
+	struct snd_ac97 *ac97;
+	struct snd_opl3 *opl3;
+
+	struct resource *res_port;
+
+	int irq;
+
+	int chip_type; /* ALS300 or ALS300+ */
+
+	char revision;	
+};
+
+struct snd_als300_substream_data {
+	int period_flipflop;
+	int control_register;
+	int block_counter_register;
+};
+
+static struct pci_device_id snd_als300_ids[] = {
+	{ 0x4005, 0x0300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_ALS300 },
+	{ 0x4005, 0x0308, PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEVICE_ALS300_PLUS },
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, snd_als300_ids);
+
+static inline u32 snd_als300_gcr_read(unsigned long port, unsigned short reg)
+{
+	outb(reg, port+GCR_INDEX);
+	return inl(port+GCR_DATA);
+}
+
+static inline void snd_als300_gcr_write(unsigned long port,
+						unsigned short reg, u32 val)
+{
+	outb(reg, port+GCR_INDEX);
+	outl(val, port+GCR_DATA);
+}
+
+/* Enable/Disable Interrupts */
+static void snd_als300_set_irq_flag(struct snd_als300 *chip, int cmd)
+{
+	u32 tmp = snd_als300_gcr_read(chip->port, MISC_CONTROL);
+	snd_als300_dbgcallenter();
+
+	/* boolean XOR check, since old vs. new hardware have
+	   directly reversed bit setting for ENABLE and DISABLE.
+	   ALS300+ acts like newer versions of ALS300 */
+	if (((chip->revision > 5 || chip->chip_type == DEVICE_ALS300_PLUS) ^
+						(cmd == IRQ_ENABLE)) == 0)
+		tmp |= IRQ_SET_BIT;
+	else
+		tmp &= ~IRQ_SET_BIT;
+	snd_als300_gcr_write(chip->port, MISC_CONTROL, tmp);
+	snd_als300_dbgcallleave();
+}
+
+static int snd_als300_free(struct snd_als300 *chip)
+{
+	snd_als300_dbgcallenter();
+	snd_als300_set_irq_flag(chip, IRQ_DISABLE);
+	if (chip->irq >= 0)
+		free_irq(chip->irq, (void *)chip);
+	pci_release_regions(chip->pci);
+	pci_disable_device(chip->pci);
+	kfree(chip);
+	snd_als300_dbgcallleave();
+	return 0;
+}
+
+static int snd_als300_dev_free(struct snd_device *device)
+{
+	struct snd_als300 *chip = device->device_data;
+	return snd_als300_free(chip);
+}
+
+static irqreturn_t snd_als300_interrupt(int irq, void *dev_id,
+						struct pt_regs *regs)
+{
+	u8 status;
+	struct snd_als300 *chip = dev_id;
+	struct snd_als300_substream_data *data;
+
+	status = inb(chip->port+ALS300_IRQ_STATUS);
+	if (!status) /* shared IRQ, for different device?? Exit ASAP! */
+		return IRQ_NONE;
+
+	/* ACK everything ASAP */
+	outb(status, chip->port+ALS300_IRQ_STATUS);
+	if (status & IRQ_PLAYBACK) {
+		if (chip->pcm && chip->playback_substream) {
+			data = chip->playback_substream->runtime->private_data;
+			data->period_flipflop ^= 1;
+			snd_pcm_period_elapsed(chip->playback_substream);
+			snd_als300_dbgplay("IRQ_PLAYBACK\n");
+		}
+	}
+	if (status & IRQ_CAPTURE) {
+		if (chip->pcm && chip->capture_substream) {
+			data = chip->capture_substream->runtime->private_data;
+			data->period_flipflop ^= 1;
+			snd_pcm_period_elapsed(chip->capture_substream);
+			snd_als300_dbgplay("IRQ_CAPTURE\n");
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t snd_als300plus_interrupt(int irq, void *dev_id,
+						struct pt_regs *regs)
+{
+	u8 general, mpu, dram;
+	struct snd_als300 *chip = dev_id;
+	struct snd_als300_substream_data *data;
+	
+	general = inb(chip->port+ALS300P_IRQ_STATUS);
+	mpu = inb(chip->port+MPU_IRQ_STATUS);
+	dram = inb(chip->port+ALS300P_DRAM_IRQ_STATUS);
+
+	/* shared IRQ, for different device?? Exit ASAP! */
+	if ((general == 0) && ((mpu & 0x80) == 0) && ((dram & 0x01) == 0))
+		return IRQ_NONE;
+
+	if (general & IRQ_PLAYBACK) {
+		if (chip->pcm && chip->playback_substream) {
+			outb(IRQ_PLAYBACK, chip->port+ALS300P_IRQ_STATUS);
+			data = chip->playback_substream->runtime->private_data;
+			data->period_flipflop ^= 1;
+			snd_pcm_period_elapsed(chip->playback_substream);
+			snd_als300_dbgplay("IRQ_PLAYBACK\n");
+		}
+	}
+	if (general & IRQ_CAPTURE) {
+		if (chip->pcm && chip->capture_substream) {
+			outb(IRQ_CAPTURE, chip->port+ALS300P_IRQ_STATUS);
+			data = chip->capture_substream->runtime->private_data;
+			data->period_flipflop ^= 1;
+			snd_pcm_period_elapsed(chip->capture_substream);
+			snd_als300_dbgplay("IRQ_CAPTURE\n");
+		}
+	}
+	/* FIXME: Ack other interrupt types. Not important right now as
+	 * those other devices aren't enabled. */
+	return IRQ_HANDLED;
+}
+
+static void __devexit snd_als300_remove(struct pci_dev *pci)
+{
+	snd_als300_dbgcallenter();
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+	snd_als300_dbgcallleave();
+}
+
+static unsigned short snd_als300_ac97_read(struct snd_ac97 *ac97,
+							unsigned short reg)
+{
+	int i;
+	struct snd_als300 *chip = ac97->private_data;
+
+	for (i = 0; i < 1000; i++) {
+		if ((inb(chip->port+AC97_STATUS) & (AC97_BUSY)) == 0)
+			break;
+		udelay(10);
+	}
+	outl((reg << 24) | (1 << 31), chip->port+AC97_ACCESS);
+
+	for (i = 0; i < 1000; i++) {
+		if ((inb(chip->port+AC97_STATUS) & (AC97_DATA_AVAIL)) != 0)
+			break;
+		udelay(10);
+	}
+	return inw(chip->port+AC97_READ);
+}
+
+static void snd_als300_ac97_write(struct snd_ac97 *ac97,
+				unsigned short reg, unsigned short val)
+{
+	int i;
+	struct snd_als300 *chip = ac97->private_data;
+
+	for (i = 0; i < 1000; i++) {
+		if ((inb(chip->port+AC97_STATUS) & (AC97_BUSY)) == 0)
+			break;
+		udelay(10);
+	}
+	outl((reg << 24) | val, chip->port+AC97_ACCESS);
+}
+
+static int snd_als300_ac97(struct snd_als300 *chip)
+{
+	struct snd_ac97_bus *bus;
+	struct snd_ac97_template ac97;
+	int err;
+	static struct snd_ac97_bus_ops ops = {
+		.write = snd_als300_ac97_write,
+		.read = snd_als300_ac97_read,
+	};
+
+	snd_als300_dbgcallenter();
+	if ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &bus)) < 0)
+		return err;
+
+	memset(&ac97, 0, sizeof(ac97));
+	ac97.private_data = chip;
+
+	snd_als300_dbgcallleave();
+	return snd_ac97_mixer(bus, &ac97, &chip->ac97);
+}
+
+/* hardware definition
+ *
+ * In AC97 mode, we always use 48k/16bit/stereo.
+ * Any request to change data type is ignored by
+ * the card when it is running outside of legacy
+ * mode.
+ */
+static struct snd_pcm_hardware snd_als300_playback_hw =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_PAUSE |
+				SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_S16,
+	.rates =		SNDRV_PCM_RATE_48000,
+	.rate_min =		48000,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	64 * 1024,
+	.period_bytes_min =	64,
+	.period_bytes_max =	32 * 1024,
+	.periods_min =		2,
+	.periods_max =		2,
+};
+
+static struct snd_pcm_hardware snd_als300_capture_hw =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_PAUSE |
+				SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_S16,
+	.rates =		SNDRV_PCM_RATE_48000,
+	.rate_min =		48000,
+	.rate_max =		48000,
+	.channels_min =		2,
+	.channels_max =		2,
+	.buffer_bytes_max =	64 * 1024,
+	.period_bytes_min =	64,
+	.period_bytes_max =	32 * 1024,
+	.periods_min =		2,
+	.periods_max =		2,
+};
+
+static int snd_als300_playback_open(struct snd_pcm_substream *substream)
+{
+	struct snd_als300 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_als300_substream_data *data = kzalloc(sizeof(*data),
+								GFP_KERNEL);
+
+	snd_als300_dbgcallenter();
+	chip->playback_substream = substream;
+	runtime->hw = snd_als300_playback_hw;
+	runtime->private_data = data;
+	data->control_register = PLAYBACK_CONTROL;
+	data->block_counter_register = PLAYBACK_BLOCK_COUNTER;
+	snd_als300_dbgcallleave();
+	return 0;
+}
+
+static int snd_als300_playback_close(struct snd_pcm_substream *substream)
+{
+	struct snd_als300 *chip = snd_pcm_substream_chip(substream);
+	struct snd_als300_substream_data *data;
+
+	data = substream->runtime->private_data;
+	snd_als300_dbgcallenter();
+	kfree(data);
+	chip->playback_substream = NULL;
+	snd_pcm_lib_free_pages(substream);
+	snd_als300_dbgcallleave();
+	return 0;
+}
+
+static int snd_als300_capture_open(struct snd_pcm_substream *substream)
+{
+	struct snd_als300 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_als300_substream_data *data = kzalloc(sizeof(*data),
+								GFP_KERNEL);
+
+	snd_als300_dbgcallenter();
+	chip->capture_substream = substream;
+	runtime->hw = snd_als300_capture_hw;
+	runtime->private_data = data;
+	data->control_register = RECORD_CONTROL;
+	data->block_counter_register = RECORD_BLOCK_COUNTER;
+	snd_als300_dbgcallleave();
+	return 0;
+}
+
+static int snd_als300_capture_close(struct snd_pcm_substream *substream)
+{
+	struct snd_als300 *chip = snd_pcm_substream_chip(substream);
+	struct snd_als300_substream_data *data;
+
+	data = substream->runtime->private_data;
+	snd_als300_dbgcallenter();
+	kfree(data);
+	chip->capture_substream = NULL;
+	snd_pcm_lib_free_pages(substream);
+	snd_als300_dbgcallleave();
+	return 0;
+}
+
+static int snd_als300_pcm_hw_params(struct snd_pcm_substream *substream,
+					snd_pcm_hw_params_t * hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream,
+					params_buffer_bytes(hw_params));
+}
+
+static int snd_als300_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int snd_als300_playback_prepare(struct snd_pcm_substream *substream)
+{
+	u32 tmp;
+	struct snd_als300 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned short period_bytes = snd_pcm_lib_period_bytes(substream);
+	unsigned short buffer_bytes = snd_pcm_lib_buffer_bytes(substream);
+	
+	snd_als300_dbgcallenter();
+	spin_lock_irq(&chip->reg_lock);
+	tmp = snd_als300_gcr_read(chip->port, PLAYBACK_CONTROL);
+	tmp &= ~TRANSFER_START;
+
+	snd_als300_dbgplay("Period bytes: %d Buffer bytes %d\n",
+						period_bytes, buffer_bytes);
+	
+	/* set block size */
+	tmp &= 0xffff0000;
+	tmp |= period_bytes - 1;
+	snd_als300_gcr_write(chip->port, PLAYBACK_CONTROL, tmp);
+
+	/* set dma area */
+	snd_als300_gcr_write(chip->port, PLAYBACK_START,
+					runtime->dma_addr);
+	snd_als300_gcr_write(chip->port, PLAYBACK_END,
+					runtime->dma_addr + buffer_bytes - 1);
+	spin_unlock_irq(&chip->reg_lock);
+	snd_als300_dbgcallleave();
+	return 0;
+}
+
+static int snd_als300_capture_prepare(struct snd_pcm_substream *substream)
+{
+	u32 tmp;
+	struct snd_als300 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned short period_bytes = snd_pcm_lib_period_bytes(substream);
+	unsigned short buffer_bytes = snd_pcm_lib_buffer_bytes(substream);
+
+	snd_als300_dbgcallenter();
+	spin_lock_irq(&chip->reg_lock);
+	tmp = snd_als300_gcr_read(chip->port, RECORD_CONTROL);
+	tmp &= ~TRANSFER_START;
+
+	snd_als300_dbgplay("Period bytes: %d Buffer bytes %d\n", period_bytes,
+							buffer_bytes);
+
+	/* set block size */
+	tmp &= 0xffff0000;
+	tmp |= period_bytes - 1;
+
+	/* set dma area */
+	snd_als300_gcr_write(chip->port, RECORD_CONTROL, tmp);
+	snd_als300_gcr_write(chip->port, RECORD_START,
+					runtime->dma_addr);
+	snd_als300_gcr_write(chip->port, RECORD_END,
+					runtime->dma_addr + buffer_bytes - 1);
+	spin_unlock_irq(&chip->reg_lock);
+	snd_als300_dbgcallleave();
+	return 0;
+}
+
+static int snd_als300_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_als300 *chip = snd_pcm_substream_chip(substream);
+	u32 tmp;
+	struct snd_als300_substream_data *data;
+	unsigned short reg;
+	int ret = 0;
+
+	data = substream->runtime->private_data;
+	reg = data->control_register;
+
+	snd_als300_dbgcallenter();
+	spin_lock(&chip->reg_lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		tmp = snd_als300_gcr_read(chip->port, reg);
+		data->period_flipflop = 1;
+		snd_als300_gcr_write(chip->port, reg, tmp | TRANSFER_START);
+		snd_als300_dbgplay("TRIGGER START\n");
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		tmp = snd_als300_gcr_read(chip->port, reg);
+		snd_als300_gcr_write(chip->port, reg, tmp & ~TRANSFER_START);
+		snd_als300_dbgplay("TRIGGER STOP\n");
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		tmp = snd_als300_gcr_read(chip->port, reg);
+		snd_als300_gcr_write(chip->port, reg, tmp | FIFO_PAUSE);
+		snd_als300_dbgplay("TRIGGER PAUSE\n");
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		tmp = snd_als300_gcr_read(chip->port, reg);
+		snd_als300_gcr_write(chip->port, reg, tmp & ~FIFO_PAUSE);
+		snd_als300_dbgplay("TRIGGER RELEASE\n");
+		break;
+	default:
+		snd_als300_dbgplay("TRIGGER INVALID\n");
+		ret = -EINVAL;
+	}
+	spin_unlock(&chip->reg_lock);
+	snd_als300_dbgcallleave();
+	return ret;
+}
+
+static snd_pcm_uframes_t snd_als300_pointer(struct snd_pcm_substream *substream)
+{
+	u16 current_ptr;
+	struct snd_als300 *chip = snd_pcm_substream_chip(substream);
+	struct snd_als300_substream_data *data;
+	unsigned short period_bytes;
+
+	data = substream->runtime->private_data;
+	period_bytes = snd_pcm_lib_period_bytes(substream);
+	
+	snd_als300_dbgcallenter();
+	spin_lock(&chip->reg_lock);
+	current_ptr = (u16) snd_als300_gcr_read(chip->port,
+					data->block_counter_register) + 4;
+	spin_unlock(&chip->reg_lock);
+	if (current_ptr > period_bytes)
+		current_ptr = 0;
+	else
+		current_ptr = period_bytes - current_ptr;
+
+	if (data->period_flipflop == 0)
+		current_ptr += period_bytes;
+	snd_als300_dbgplay("Pointer (bytes): %d\n", current_ptr);
+	snd_als300_dbgcallleave();
+	return bytes_to_frames(substream->runtime, current_ptr);
+}
+
+static struct snd_pcm_ops snd_als300_playback_ops = {
+	.open =		snd_als300_playback_open,
+	.close =	snd_als300_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_als300_pcm_hw_params,
+	.hw_free =	snd_als300_pcm_hw_free,
+	.prepare =	snd_als300_playback_prepare,
+	.trigger =	snd_als300_trigger,
+	.pointer =	snd_als300_pointer,
+};
+
+static struct snd_pcm_ops snd_als300_capture_ops = {
+	.open =		snd_als300_capture_open,
+	.close =	snd_als300_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_als300_pcm_hw_params,
+	.hw_free =	snd_als300_pcm_hw_free,
+	.prepare =	snd_als300_capture_prepare,
+	.trigger =	snd_als300_trigger,
+	.pointer =	snd_als300_pointer,
+};
+
+static int __devinit snd_als300_new_pcm(struct snd_als300 *chip)
+{
+	struct snd_pcm *pcm;
+	int err;
+
+	snd_als300_dbgcallenter();
+	err = snd_pcm_new(chip->card, "ALS300", 0, 1, 1, &pcm);
+	if (err < 0)
+		return err;
+	pcm->private_data = chip;
+	strcpy(pcm->name, "ALS300");
+	chip->pcm = pcm;
+
+	/* set operators */
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				&snd_als300_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+				&snd_als300_capture_ops);
+
+	/* pre-allocation of buffers */
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+	snd_dma_pci_data(chip->pci), 64*1024, 64*1024);
+	snd_als300_dbgcallleave();
+	return 0;
+}
+
+static void snd_als300_init(struct snd_als300 *chip)
+{
+	unsigned long flags;
+	u32 tmp;
+	
+	snd_als300_dbgcallenter();
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	chip->revision = (snd_als300_gcr_read(chip->port, MISC_CONTROL) >> 16)
+								& 0x0000000F;
+	/* Setup DRAM */
+	tmp = snd_als300_gcr_read(chip->port, DRAM_WRITE_CONTROL);
+	snd_als300_gcr_write(chip->port, DRAM_WRITE_CONTROL,
+						(tmp | DRAM_MODE_2)
+						& ~WRITE_TRANS_START);
+
+	/* Enable IRQ output */
+	snd_als300_set_irq_flag(chip, IRQ_ENABLE);
+
+	/* Unmute hardware devices so their outputs get routed to
+	 * the onboard mixer */
+	tmp = snd_als300_gcr_read(chip->port, MISC_CONTROL);
+	snd_als300_gcr_write(chip->port, MISC_CONTROL,
+			tmp | VMUTE_NORMAL | MMUTE_NORMAL);
+
+	/* Reset volumes */
+	snd_als300_gcr_write(chip->port, MUS_VOC_VOL, 0);
+
+	/* Make sure playback transfer is stopped */
+	tmp = snd_als300_gcr_read(chip->port, PLAYBACK_CONTROL);
+	snd_als300_gcr_write(chip->port, PLAYBACK_CONTROL,
+			tmp & ~TRANSFER_START);
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+	snd_als300_dbgcallleave();
+}
+
+static int __devinit snd_als300_create(snd_card_t *card,
+				       struct pci_dev *pci, int chip_type,
+				       struct snd_als300 **rchip)
+{
+	struct snd_als300 *chip;
+	void *irq_handler;
+	int err;
+
+	static snd_device_ops_t ops = {
+		.dev_free = snd_als300_dev_free,
+	};
+	*rchip = NULL;
+
+	snd_als300_dbgcallenter();
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+
+	if (pci_set_dma_mask(pci, 0x0fffffff) < 0 ||
+		pci_set_consistent_dma_mask(pci, 0x0fffffff) < 0) {
+		printk(KERN_ERR "error setting 28bit DMA mask\n");
+		pci_disable_device(pci);
+		return -ENXIO;
+	}
+	pci_set_master(pci);
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+
+	chip->card = card;
+	chip->pci = pci;
+	chip->irq = -1;
+	chip->chip_type = chip_type;
+	spin_lock_init(&chip->reg_lock);
+
+	if ((err = pci_request_regions(pci, "ALS300")) < 0) {
+		kfree(chip);
+		pci_disable_device(pci);
+		return err;
+	}
+	chip->port = pci_resource_start(pci, 0);
+
+	if (chip->chip_type == DEVICE_ALS300_PLUS)
+		irq_handler = snd_als300plus_interrupt;
+	else
+		irq_handler = snd_als300_interrupt;
+
+	if (request_irq(pci->irq, irq_handler, SA_INTERRUPT|SA_SHIRQ,
+					card->shortname, (void *)chip)) {
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		snd_als300_free(chip);
+		return -EBUSY;
+	}
+	chip->irq = pci->irq;
+
+
+	snd_als300_init(chip);
+
+	if (snd_als300_ac97(chip) < 0) {
+		snd_printk(KERN_WARNING "Could not create ac97\n");
+		snd_als300_free(chip);
+		return err;
+	}
+
+	if ((err = snd_als300_new_pcm(chip)) < 0) {
+		snd_printk(KERN_WARNING "Could not create PCM\n");
+		snd_als300_free(chip);
+		return err;
+	}
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,
+						chip, &ops)) < 0) {
+		snd_als300_free(chip);
+		return err;
+	}
+
+	snd_card_set_dev(card, &pci->dev);
+
+	*rchip = chip;
+	snd_als300_dbgcallleave();
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int snd_als300_suspend(struct pci_dev *pci, pm_message_t state)
+{
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct snd_als300 *chip = card->private_data;
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	snd_pcm_suspend_all(chip->pcm);
+	snd_ac97_suspend(chip->ac97);
+
+	pci_set_power_state(pci, PCI_D3hot);
+	pci_disable_device(pci);
+	pci_save_state(pci);
+	return 0;
+}
+
+static int snd_als300_resume(struct pci_dev *pci)
+{
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct snd_als300 *chip = card->private_data;
+
+	pci_restore_state(pci);
+	pci_enable_device(pci);
+	pci_set_power_state(pci, PCI_D0);
+	pci_set_master(pci);
+
+	snd_als300_init(chip);
+	snd_ac97_resume(chip->ac97);
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+	return 0;
+}
+#endif
+
+static int __devinit snd_als300_probe(struct pci_dev *pci,
+                             const struct pci_device_id *pci_id)
+{
+	static int dev;
+	struct snd_card *card;
+	struct snd_als300 *chip;
+	int err, chip_type;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+
+	if (card == NULL)
+		return -ENOMEM;
+
+	chip_type = pci_id->driver_data;
+
+	if ((err = snd_als300_create(card, pci, chip_type, &chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	card->private_data = chip;
+
+	strcpy(card->driver, "ALS300");
+	if (chip->chip_type == DEVICE_ALS300_PLUS)
+		/* don't know much about ALS300+ yet
+		 * print revision number for now */
+		sprintf(card->shortname, "ALS300+ (Rev. %d)", chip->revision);
+	else
+		sprintf(card->shortname, "ALS300 (Rev. %c)", 'A' +
+							chip->revision - 1);
+	sprintf(card->longname, "%s at 0x%lx irq %i",
+				card->shortname, chip->port, chip->irq);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static struct pci_driver driver = {
+	.name = "ALS300",
+	.id_table = snd_als300_ids,
+	.probe = snd_als300_probe,
+	.remove = __devexit_p(snd_als300_remove),
+#ifdef CONFIG_PM
+	.suspend = snd_als300_suspend,
+	.resume = snd_als300_resume,
+#endif
+};
+
+static int __init alsa_card_als300_init(void)
+{
+	return pci_register_driver(&driver);
+}
+
+static void __exit alsa_card_als300_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_als300_init)
+module_exit(alsa_card_als300_exit)
