commit 9ca7a0c97923a88d9bbb645ea6e3e1ffe2bd5661
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:47 2020 +0100

    ALSA: asihpi: More constifications
    
    Apply const prefix to each possible place: the static tables for
    formats, parameters, etc.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-33-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpimsgx.c b/sound/pci/asihpi/hpimsgx.c
index 5fb0b98bec30..f7427f8eb630 100644
--- a/sound/pci/asihpi/hpimsgx.c
+++ b/sound/pci/asihpi/hpimsgx.c
@@ -17,7 +17,7 @@ Extended Message Function With Response Caching
 #include "hpimsgx.h"
 #include "hpidebug.h"
 
-static struct pci_device_id asihpi_pci_tbl[] = {
+static const struct pci_device_id asihpi_pci_tbl[] = {
 #include "hpipcida.h"
 };
 

commit 07d7fe7bd6a56f20d57e708c508bf29bea16aa40
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:12:47 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 273
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of version 2 of the gnu general public license as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 24 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141334.606756275@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/asihpi/hpimsgx.c b/sound/pci/asihpi/hpimsgx.c
index 736f45337fc7..5fb0b98bec30 100644
--- a/sound/pci/asihpi/hpimsgx.c
+++ b/sound/pci/asihpi/hpimsgx.c
@@ -1,20 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /******************************************************************************
 
     AudioScience HPI driver
     Copyright (C) 1997-2014  AudioScience Inc. <support@audioscience.com>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of version 2 of the GNU General Public License as
-    published by the Free Software Foundation;
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
 Extended Message Function With Response Caching
 

commit 5bc91f5b3c732bdb3b9e7cc8bd27969d25015bcd
Author: Eliot Blennerhassett <eliot@blennerhassett.gen.nz>
Date:   Thu Nov 20 16:22:54 2014 +1300

    ALSA: asihpi: Turn off msg/resp logging after DSP has crashed.
    
    Prevents spewing of useless messages if app keeps trying to
    access the card.
    
    Signed-off-by: Eliot Blennerhassett <eliot@blennerhassett.gen.nz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpimsgx.c b/sound/pci/asihpi/hpimsgx.c
index d4790ddc225c..736f45337fc7 100644
--- a/sound/pci/asihpi/hpimsgx.c
+++ b/sound/pci/asihpi/hpimsgx.c
@@ -1,7 +1,7 @@
 /******************************************************************************
 
     AudioScience HPI driver
-    Copyright (C) 1997-2011  AudioScience Inc. <support@audioscience.com>
+    Copyright (C) 1997-2014  AudioScience Inc. <support@audioscience.com>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of version 2 of the GNU General Public License as
@@ -35,6 +35,7 @@ static struct pci_device_id asihpi_pci_tbl[] = {
 static struct hpios_spinlock msgx_lock;
 
 static hpi_handler_func *hpi_entry_points[HPI_MAX_ADAPTERS];
+static int logging_enabled = 1;
 
 static hpi_handler_func *hpi_lookup_entry_point_function(const struct hpi_pci
 	*pci_info)
@@ -312,7 +313,9 @@ static void instream_message(struct hpi_message *phm,
 void hpi_send_recv_ex(struct hpi_message *phm, struct hpi_response *phr,
 	void *h_owner)
 {
-	HPI_DEBUG_MESSAGE(DEBUG, phm);
+
+	if (logging_enabled)
+		HPI_DEBUG_MESSAGE(DEBUG, phm);
 
 	if (phm->type != HPI_TYPE_REQUEST) {
 		hpi_init_response(phr, phm->object, phm->function,
@@ -352,8 +355,14 @@ void hpi_send_recv_ex(struct hpi_message *phm, struct hpi_response *phr,
 		hw_entry_point(phm, phr);
 		break;
 	}
-	HPI_DEBUG_RESPONSE(phr);
 
+	if (logging_enabled)
+		HPI_DEBUG_RESPONSE(phr);
+
+	if (phr->error >= HPI_ERROR_DSP_COMMUNICATION) {
+		hpi_debug_level_set(HPI_DEBUG_LEVEL_ERROR);
+		logging_enabled = 0;
+	}
 }
 
 static void adapter_open(struct hpi_message *phm, struct hpi_response *phr)

commit f6baaec2af36494469aa37558db8c79186f2fa03
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Thu Dec 22 13:38:31 2011 +1300

    ALSA: asihpi - Split hpi version info into separate header file.
    
    and update HPI version to 4.10
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpimsgx.c b/sound/pci/asihpi/hpimsgx.c
index 2e779421a618..d4790ddc225c 100644
--- a/sound/pci/asihpi/hpimsgx.c
+++ b/sound/pci/asihpi/hpimsgx.c
@@ -1,7 +1,7 @@
 /******************************************************************************
 
     AudioScience HPI driver
-    Copyright (C) 1997-2010  AudioScience Inc. <support@audioscience.com>
+    Copyright (C) 1997-2011  AudioScience Inc. <support@audioscience.com>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of version 2 of the GNU General Public License as
@@ -22,6 +22,7 @@ Extended Message Function With Response Caching
 *****************************************************************************/
 #define SOURCEFILE_NAME "hpimsgx.c"
 #include "hpi_internal.h"
+#include "hpi_version.h"
 #include "hpimsginit.h"
 #include "hpicmn.h"
 #include "hpimsgx.h"

commit 938c565a821706177d810dc08f9e1506d7429760
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Fri Jul 22 15:52:50 2011 +1200

    ALSA: asihpi - Fix minor typos and spelling
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpimsgx.c b/sound/pci/asihpi/hpimsgx.c
index 83b7e7337933..2e779421a618 100644
--- a/sound/pci/asihpi/hpimsgx.c
+++ b/sound/pci/asihpi/hpimsgx.c
@@ -16,7 +16,7 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
-Extended Message Function With Response Cacheing
+Extended Message Function With Response Caching
 
 (C) Copyright AudioScience Inc. 2002
 *****************************************************************************/

commit 4bf8cff05a4461d24b36d9942a077504a3461732
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Fri Jul 22 15:52:48 2011 +1200

    ALSA: asihpi - Remove unused structures, macros and functions
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpimsgx.c b/sound/pci/asihpi/hpimsgx.c
index 111f774f5f20..83b7e7337933 100644
--- a/sound/pci/asihpi/hpimsgx.c
+++ b/sound/pci/asihpi/hpimsgx.c
@@ -186,7 +186,6 @@ static void subsys_message(struct hpi_message *phm, struct hpi_response *phr,
 		/* Initialize this module's internal state */
 		hpios_msgxlock_init(&msgx_lock);
 		memset(&hpi_entry_points, 0, sizeof(hpi_entry_points));
-		hpios_locked_mem_init();
 		/* Init subsys_findadapters response to no-adapters */
 		HPIMSGX__reset(HPIMSGX_ALLADAPTERS);
 		hpi_init_response(phr, HPI_OBJ_SUBSYSTEM,
@@ -197,7 +196,6 @@ static void subsys_message(struct hpi_message *phm, struct hpi_response *phr,
 	case HPI_SUBSYS_DRIVER_UNLOAD:
 		HPI_COMMON(phm, phr);
 		HPIMSGX__cleanup(HPIMSGX_ALLADAPTERS, h_owner);
-		hpios_locked_mem_free_all();
 		hpi_init_response(phr, HPI_OBJ_SUBSYSTEM,
 			HPI_SUBSYS_DRIVER_UNLOAD, 0);
 		return;

commit 82b5774fe02c61fc70aed6bc885f0d26b708e925
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Fri Jul 22 15:52:36 2011 +1200

    ALSA: asihpi - Give more meaningful name to hpi request message type
    
    Having a 'request message' makes more sense than a 'message message'
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpimsgx.c b/sound/pci/asihpi/hpimsgx.c
index 7352a5f7b4f7..111f774f5f20 100644
--- a/sound/pci/asihpi/hpimsgx.c
+++ b/sound/pci/asihpi/hpimsgx.c
@@ -315,7 +315,7 @@ void hpi_send_recv_ex(struct hpi_message *phm, struct hpi_response *phr,
 {
 	HPI_DEBUG_MESSAGE(DEBUG, phm);
 
-	if (phm->type != HPI_TYPE_MESSAGE) {
+	if (phm->type != HPI_TYPE_REQUEST) {
 		hpi_init_response(phr, phm->object, phm->function,
 			HPI_ERROR_INVALID_TYPE);
 		return;

commit 02e5fbf622aabf68bdc02282a17a3aeed054237a
Merge: b759b3ac9aee bfe9fc8aebc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun May 22 10:01:29 2011 +0200

    Merge branch 'topic/misc' into for-linus

commit 6d0b898e9c402d6b7d0d07adacdbee2ebedafdcd
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Tue Apr 5 20:55:47 2011 +1200

    ALSA: asihpi: Simplify driver unload cleanup
    
    Replacing subsys_delete_adapter with adapter_delete
    allows some special-case adapter lookup code to be removed.
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpimsgx.c b/sound/pci/asihpi/hpimsgx.c
index bcbdf30a6aa0..888e37966c3f 100644
--- a/sound/pci/asihpi/hpimsgx.c
+++ b/sound/pci/asihpi/hpimsgx.c
@@ -211,24 +211,6 @@ static void subsys_message(struct hpi_message *phm, struct hpi_response *phr,
 		HPIMSGX__init(phm, phr);
 		break;
 
-	case HPI_SUBSYS_DELETE_ADAPTER:
-		HPIMSGX__cleanup(phm->obj_index, h_owner);
-		{
-			struct hpi_message hm;
-			struct hpi_response hr;
-			hpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,
-				HPI_ADAPTER_CLOSE);
-			hm.adapter_index = phm->obj_index;
-			hw_entry_point(&hm, &hr);
-		}
-		if ((phm->obj_index < HPI_MAX_ADAPTERS)
-			&& hpi_entry_points[phm->obj_index]) {
-			hpi_entry_points[phm->obj_index] (phm, phr);
-			hpi_entry_points[phm->obj_index] = NULL;
-		} else
-			phr->error = HPI_ERROR_INVALID_OBJ_INDEX;
-
-		break;
 	default:
 		/* Must explicitly handle every subsys message in this switch */
 		hpi_init_response(phr, HPI_OBJ_SUBSYSTEM, phm->function,
@@ -247,6 +229,19 @@ static void adapter_message(struct hpi_message *phm, struct hpi_response *phr,
 	case HPI_ADAPTER_CLOSE:
 		adapter_close(phm, phr);
 		break;
+	case HPI_ADAPTER_DELETE:
+		HPIMSGX__cleanup(phm->adapter_index, h_owner);
+		{
+			struct hpi_message hm;
+			struct hpi_response hr;
+			hpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,
+				HPI_ADAPTER_CLOSE);
+			hm.adapter_index = phm->adapter_index;
+			hw_entry_point(&hm, &hr);
+		}
+		hw_entry_point(phm, phr);
+		break;
+
 	default:
 		hw_entry_point(phm, phr);
 		break;

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/sound/pci/asihpi/hpimsgx.c b/sound/pci/asihpi/hpimsgx.c
index bcbdf30a6aa0..360028b9abf5 100644
--- a/sound/pci/asihpi/hpimsgx.c
+++ b/sound/pci/asihpi/hpimsgx.c
@@ -722,7 +722,7 @@ static u16 HPIMSGX__init(struct hpi_message *phm,
 		return phr->error;
 	}
 	if (hr.error == 0) {
-		/* the adapter was created succesfully
+		/* the adapter was created successfully
 		   save the mapping for future use */
 		hpi_entry_points[hr.u.s.adapter_index] = entry_point_func;
 		/* prepare adapter (pre-open streams etc.) */

commit 1d595d2a2121b0db2b57656c685a164f38c0c8ae
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Thu Feb 10 17:26:08 2011 +1300

    ALSA: asihpi - Cosmetic + a minor comments.
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpimsgx.c b/sound/pci/asihpi/hpimsgx.c
index b4e7d9a19472..bcbdf30a6aa0 100644
--- a/sound/pci/asihpi/hpimsgx.c
+++ b/sound/pci/asihpi/hpimsgx.c
@@ -230,7 +230,7 @@ static void subsys_message(struct hpi_message *phm, struct hpi_response *phr,
 
 		break;
 	default:
-		/* Must explicitly send subsys messages to individual backends */
+		/* Must explicitly handle every subsys message in this switch */
 		hpi_init_response(phr, HPI_OBJ_SUBSYSTEM, phm->function,
 			HPI_ERROR_INVALID_FUNC);
 		break;

commit 3285ea10e9b09d68da18d2f805980246ec53523a
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Thu Feb 10 17:25:58 2011 +1300

    ALSA: asihpi - Interrelated HPI tidy up.
    
    Remove many unused functions.
    Update some message and cache structs.
    Use pci info directly from pci_dev.
    Allow control cache elements with variable size, and handle
    large message/response from dsp.
    hpi6000 and hpi6205: fix error path when adapter bootload fails.
    hpimsgx.c get rid of code duplicated in hpicmn.c
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpimsgx.c b/sound/pci/asihpi/hpimsgx.c
index f01ab964f602..b4e7d9a19472 100644
--- a/sound/pci/asihpi/hpimsgx.c
+++ b/sound/pci/asihpi/hpimsgx.c
@@ -23,6 +23,7 @@ Extended Message Function With Response Cacheing
 #define SOURCEFILE_NAME "hpimsgx.c"
 #include "hpi_internal.h"
 #include "hpimsginit.h"
+#include "hpicmn.h"
 #include "hpimsgx.h"
 #include "hpidebug.h"
 
@@ -42,22 +43,24 @@ static hpi_handler_func *hpi_lookup_entry_point_function(const struct hpi_pci
 
 	for (i = 0; asihpi_pci_tbl[i].vendor != 0; i++) {
 		if (asihpi_pci_tbl[i].vendor != PCI_ANY_ID
-			&& asihpi_pci_tbl[i].vendor != pci_info->vendor_id)
+			&& asihpi_pci_tbl[i].vendor !=
+			pci_info->pci_dev->vendor)
 			continue;
 		if (asihpi_pci_tbl[i].device != PCI_ANY_ID
-			&& asihpi_pci_tbl[i].device != pci_info->device_id)
+			&& asihpi_pci_tbl[i].device !=
+			pci_info->pci_dev->device)
 			continue;
 		if (asihpi_pci_tbl[i].subvendor != PCI_ANY_ID
 			&& asihpi_pci_tbl[i].subvendor !=
-			pci_info->subsys_vendor_id)
+			pci_info->pci_dev->subsystem_vendor)
 			continue;
 		if (asihpi_pci_tbl[i].subdevice != PCI_ANY_ID
 			&& asihpi_pci_tbl[i].subdevice !=
-			pci_info->subsys_device_id)
+			pci_info->pci_dev->subsystem_device)
 			continue;
 
-		HPI_DEBUG_LOG(DEBUG, " %x,%lu\n", i,
-			asihpi_pci_tbl[i].driver_data);
+		/* HPI_DEBUG_LOG(DEBUG, " %x,%lx\n", i,
+		   asihpi_pci_tbl[i].driver_data); */
 		return (hpi_handler_func *) asihpi_pci_tbl[i].driver_data;
 	}
 
@@ -67,21 +70,12 @@ static hpi_handler_func *hpi_lookup_entry_point_function(const struct hpi_pci
 static inline void hw_entry_point(struct hpi_message *phm,
 	struct hpi_response *phr)
 {
-
-	hpi_handler_func *ep;
-
-	if (phm->adapter_index < HPI_MAX_ADAPTERS) {
-		ep = (hpi_handler_func *) hpi_entry_points[phm->
-			adapter_index];
-		if (ep) {
-			HPI_DEBUG_MESSAGE(DEBUG, phm);
-			ep(phm, phr);
-			HPI_DEBUG_RESPONSE(phr);
-			return;
-		}
-	}
-	hpi_init_response(phr, phm->object, phm->function,
-		HPI_ERROR_PROCESSING_MESSAGE);
+	if ((phm->adapter_index < HPI_MAX_ADAPTERS)
+		&& hpi_entry_points[phm->adapter_index])
+		hpi_entry_points[phm->adapter_index] (phm, phr);
+	else
+		hpi_init_response(phr, phm->object, phm->function,
+			HPI_ERROR_PROCESSING_MESSAGE);
 }
 
 static void adapter_open(struct hpi_message *phm, struct hpi_response *phr);
@@ -100,6 +94,7 @@ static void instream_close(struct hpi_message *phm, struct hpi_response *phr,
 	void *h_owner);
 
 static void HPIMSGX__reset(u16 adapter_index);
+
 static u16 HPIMSGX__init(struct hpi_message *phm, struct hpi_response *phr);
 static void HPIMSGX__cleanup(u16 adapter_index, void *h_owner);
 
@@ -153,8 +148,6 @@ static struct hpi_stream_response
 
 static struct hpi_mixer_response rESP_HPI_MIXER_OPEN[HPI_MAX_ADAPTERS];
 
-static struct hpi_subsys_response gRESP_HPI_SUBSYS_FIND_ADAPTERS;
-
 static struct adapter_info aDAPTER_INFO[HPI_MAX_ADAPTERS];
 
 /* use these to keep track of opens from user mode apps/DLLs */
@@ -167,6 +160,11 @@ static struct asi_open_state
 static void subsys_message(struct hpi_message *phm, struct hpi_response *phr,
 	void *h_owner)
 {
+	if (phm->adapter_index != HPI_ADAPTER_INDEX_INVALID)
+		HPI_DEBUG_LOG(WARNING,
+			"suspicious adapter index %d in subsys message 0x%x.\n",
+			phm->adapter_index, phm->function);
+
 	switch (phm->function) {
 	case HPI_SUBSYS_GET_VERSION:
 		hpi_init_response(phr, HPI_OBJ_SUBSYSTEM,
@@ -204,85 +202,37 @@ static void subsys_message(struct hpi_message *phm, struct hpi_response *phr,
 			HPI_SUBSYS_DRIVER_UNLOAD, 0);
 		return;
 
-	case HPI_SUBSYS_GET_INFO:
-		HPI_COMMON(phm, phr);
-		break;
-
-	case HPI_SUBSYS_FIND_ADAPTERS:
-		memcpy(phr, &gRESP_HPI_SUBSYS_FIND_ADAPTERS,
-			sizeof(gRESP_HPI_SUBSYS_FIND_ADAPTERS));
-		break;
 	case HPI_SUBSYS_GET_NUM_ADAPTERS:
-		memcpy(phr, &gRESP_HPI_SUBSYS_FIND_ADAPTERS,
-			sizeof(gRESP_HPI_SUBSYS_FIND_ADAPTERS));
-		phr->function = HPI_SUBSYS_GET_NUM_ADAPTERS;
-		break;
 	case HPI_SUBSYS_GET_ADAPTER:
-		{
-			int count = phm->adapter_index;
-			int index = 0;
-			hpi_init_response(phr, HPI_OBJ_SUBSYSTEM,
-				HPI_SUBSYS_GET_ADAPTER, 0);
-
-			/* This is complicated by the fact that we want to
-			 * "skip" 0's in the adapter list.
-			 * First, make sure we are pointing to a
-			 * non-zero adapter type.
-			 */
-			while (gRESP_HPI_SUBSYS_FIND_ADAPTERS.
-				s.aw_adapter_list[index] == 0) {
-				index++;
-				if (index >= HPI_MAX_ADAPTERS)
-					break;
-			}
-			while (count) {
-				/* move on to the next adapter */
-				index++;
-				if (index >= HPI_MAX_ADAPTERS)
-					break;
-				while (gRESP_HPI_SUBSYS_FIND_ADAPTERS.
-					s.aw_adapter_list[index] == 0) {
-					index++;
-					if (index >= HPI_MAX_ADAPTERS)
-						break;
-				}
-				count--;
-			}
+		HPI_COMMON(phm, phr);
+		break;
 
-			if (index < HPI_MAX_ADAPTERS) {
-				phr->u.s.adapter_index = (u16)index;
-				phr->u.s.aw_adapter_list[0] =
-					gRESP_HPI_SUBSYS_FIND_ADAPTERS.
-					s.aw_adapter_list[index];
-			} else {
-				phr->u.s.adapter_index = 0;
-				phr->u.s.aw_adapter_list[0] = 0;
-				phr->error = HPI_ERROR_BAD_ADAPTER_NUMBER;
-			}
-			break;
-		}
 	case HPI_SUBSYS_CREATE_ADAPTER:
 		HPIMSGX__init(phm, phr);
 		break;
+
 	case HPI_SUBSYS_DELETE_ADAPTER:
-		HPIMSGX__cleanup(phm->adapter_index, h_owner);
+		HPIMSGX__cleanup(phm->obj_index, h_owner);
 		{
 			struct hpi_message hm;
 			struct hpi_response hr;
-			/* call to HPI_ADAPTER_CLOSE */
 			hpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,
 				HPI_ADAPTER_CLOSE);
-			hm.adapter_index = phm->adapter_index;
+			hm.adapter_index = phm->obj_index;
 			hw_entry_point(&hm, &hr);
 		}
-		hw_entry_point(phm, phr);
-		gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.
-			aw_adapter_list[phm->adapter_index]
-			= 0;
-		hpi_entry_points[phm->adapter_index] = NULL;
+		if ((phm->obj_index < HPI_MAX_ADAPTERS)
+			&& hpi_entry_points[phm->obj_index]) {
+			hpi_entry_points[phm->obj_index] (phm, phr);
+			hpi_entry_points[phm->obj_index] = NULL;
+		} else
+			phr->error = HPI_ERROR_INVALID_OBJ_INDEX;
+
 		break;
 	default:
-		hw_entry_point(phm, phr);
+		/* Must explicitly send subsys messages to individual backends */
+		hpi_init_response(phr, HPI_OBJ_SUBSYSTEM, phm->function,
+			HPI_ERROR_INVALID_FUNC);
 		break;
 	}
 }
@@ -409,33 +359,7 @@ void hpi_send_recv_ex(struct hpi_message *phm, struct hpi_response *phr,
 		break;
 	}
 	HPI_DEBUG_RESPONSE(phr);
-#if 1
-	if (phr->error >= HPI_ERROR_BACKEND_BASE) {
-		void *ep = NULL;
-		char *ep_name;
-
-		HPI_DEBUG_MESSAGE(ERROR, phm);
-
-		if (phm->adapter_index < HPI_MAX_ADAPTERS)
-			ep = hpi_entry_points[phm->adapter_index];
-
-		/* Don't need this? Have adapter index in debug info
-		   Know at driver load time index->backend mapping */
-		if (ep == HPI_6000)
-			ep_name = "HPI_6000";
-		else if (ep == HPI_6205)
-			ep_name = "HPI_6205";
-		else
-			ep_name = "unknown";
-
-		HPI_DEBUG_LOG(ERROR, "HPI %s response - error# %d\n", ep_name,
-			phr->error);
-
-		if (hpi_debug_level >= HPI_DEBUG_LEVEL_VERBOSE)
-			hpi_debug_data((u16 *)phm,
-				sizeof(*phm) / sizeof(u16));
-	}
-#endif
+
 }
 
 static void adapter_open(struct hpi_message *phm, struct hpi_response *phr)
@@ -484,7 +408,7 @@ static void instream_open(struct hpi_message *phm, struct hpi_response *phr,
 	else {
 		instream_user_open[phm->adapter_index][phm->
 			obj_index].open_flag = 1;
-		hpios_msgxlock_un_lock(&msgx_lock);
+		hpios_msgxlock_unlock(&msgx_lock);
 
 		/* issue a reset */
 		hpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,
@@ -509,7 +433,7 @@ static void instream_open(struct hpi_message *phm, struct hpi_response *phr,
 				sizeof(rESP_HPI_ISTREAM_OPEN[0][0]));
 		}
 	}
-	hpios_msgxlock_un_lock(&msgx_lock);
+	hpios_msgxlock_unlock(&msgx_lock);
 }
 
 static void instream_close(struct hpi_message *phm, struct hpi_response *phr,
@@ -530,7 +454,7 @@ static void instream_close(struct hpi_message *phm, struct hpi_response *phr,
 		   phm->wAdapterIndex, phm->wObjIndex, hOwner); */
 		instream_user_open[phm->adapter_index][phm->
 			obj_index].h_owner = NULL;
-		hpios_msgxlock_un_lock(&msgx_lock);
+		hpios_msgxlock_unlock(&msgx_lock);
 		/* issue a reset */
 		hpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,
 			HPI_ISTREAM_RESET);
@@ -556,7 +480,7 @@ static void instream_close(struct hpi_message *phm, struct hpi_response *phr,
 				obj_index].h_owner);
 		phr->error = HPI_ERROR_OBJ_NOT_OPEN;
 	}
-	hpios_msgxlock_un_lock(&msgx_lock);
+	hpios_msgxlock_unlock(&msgx_lock);
 }
 
 static void outstream_open(struct hpi_message *phm, struct hpi_response *phr,
@@ -581,7 +505,7 @@ static void outstream_open(struct hpi_message *phm, struct hpi_response *phr,
 	else {
 		outstream_user_open[phm->adapter_index][phm->
 			obj_index].open_flag = 1;
-		hpios_msgxlock_un_lock(&msgx_lock);
+		hpios_msgxlock_unlock(&msgx_lock);
 
 		/* issue a reset */
 		hpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,
@@ -606,7 +530,7 @@ static void outstream_open(struct hpi_message *phm, struct hpi_response *phr,
 				sizeof(rESP_HPI_OSTREAM_OPEN[0][0]));
 		}
 	}
-	hpios_msgxlock_un_lock(&msgx_lock);
+	hpios_msgxlock_unlock(&msgx_lock);
 }
 
 static void outstream_close(struct hpi_message *phm, struct hpi_response *phr,
@@ -628,7 +552,7 @@ static void outstream_close(struct hpi_message *phm, struct hpi_response *phr,
 		   phm->wAdapterIndex, phm->wObjIndex, hOwner); */
 		outstream_user_open[phm->adapter_index][phm->
 			obj_index].h_owner = NULL;
-		hpios_msgxlock_un_lock(&msgx_lock);
+		hpios_msgxlock_unlock(&msgx_lock);
 		/* issue a reset */
 		hpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,
 			HPI_OSTREAM_RESET);
@@ -654,7 +578,7 @@ static void outstream_close(struct hpi_message *phm, struct hpi_response *phr,
 				obj_index].h_owner);
 		phr->error = HPI_ERROR_OBJ_NOT_OPEN;
 	}
-	hpios_msgxlock_un_lock(&msgx_lock);
+	hpios_msgxlock_unlock(&msgx_lock);
 }
 
 static u16 adapter_prepare(u16 adapter)
@@ -683,16 +607,9 @@ static u16 adapter_prepare(u16 adapter)
 	if (hr.error)
 		return hr.error;
 
-	aDAPTER_INFO[adapter].num_outstreams = hr.u.a.num_outstreams;
-	aDAPTER_INFO[adapter].num_instreams = hr.u.a.num_instreams;
-	aDAPTER_INFO[adapter].type = hr.u.a.adapter_type;
-
-	gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.aw_adapter_list[adapter] =
-		hr.u.a.adapter_type;
-	gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.num_adapters++;
-	if (gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.num_adapters > HPI_MAX_ADAPTERS)
-		gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.num_adapters =
-			HPI_MAX_ADAPTERS;
+	aDAPTER_INFO[adapter].num_outstreams = hr.u.ax.info.num_outstreams;
+	aDAPTER_INFO[adapter].num_instreams = hr.u.ax.info.num_instreams;
+	aDAPTER_INFO[adapter].type = hr.u.ax.info.adapter_type;
 
 	/* call to HPI_OSTREAM_OPEN */
 	for (i = 0; i < aDAPTER_INFO[adapter].num_outstreams; i++) {
@@ -727,7 +644,7 @@ static u16 adapter_prepare(u16 adapter)
 	memcpy(&rESP_HPI_MIXER_OPEN[adapter], &hr,
 		sizeof(rESP_HPI_MIXER_OPEN[0]));
 
-	return gRESP_HPI_SUBSYS_FIND_ADAPTERS.h.error;
+	return 0;
 }
 
 static void HPIMSGX__reset(u16 adapter_index)
@@ -737,12 +654,6 @@ static void HPIMSGX__reset(u16 adapter_index)
 	struct hpi_response hr;
 
 	if (adapter_index == HPIMSGX_ALLADAPTERS) {
-		/* reset all responses to contain errors */
-		hpi_init_response(&hr, HPI_OBJ_SUBSYSTEM,
-			HPI_SUBSYS_FIND_ADAPTERS, 0);
-		memcpy(&gRESP_HPI_SUBSYS_FIND_ADAPTERS, &hr,
-			sizeof(gRESP_HPI_SUBSYS_FIND_ADAPTERS));
-
 		for (adapter = 0; adapter < HPI_MAX_ADAPTERS; adapter++) {
 
 			hpi_init_response(&hr, HPI_OBJ_ADAPTER,
@@ -783,12 +694,6 @@ static void HPIMSGX__reset(u16 adapter_index)
 			rESP_HPI_ISTREAM_OPEN[adapter_index][i].h.error =
 				HPI_ERROR_INVALID_OBJ;
 		}
-		if (gRESP_HPI_SUBSYS_FIND_ADAPTERS.
-			s.aw_adapter_list[adapter_index]) {
-			gRESP_HPI_SUBSYS_FIND_ADAPTERS.
-				s.aw_adapter_list[adapter_index] = 0;
-			gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.num_adapters--;
-		}
 	}
 }
 
@@ -802,15 +707,9 @@ static u16 HPIMSGX__init(struct hpi_message *phm,
 	hpi_handler_func *entry_point_func;
 	struct hpi_response hr;
 
-	if (gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.num_adapters >= HPI_MAX_ADAPTERS)
-		return HPI_ERROR_BAD_ADAPTER_NUMBER;
-
 	/* Init response here so we can pass in previous adapter list */
 	hpi_init_response(&hr, phm->object, phm->function,
 		HPI_ERROR_INVALID_OBJ);
-	memcpy(hr.u.s.aw_adapter_list,
-		gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.aw_adapter_list,
-		sizeof(gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.aw_adapter_list));
 
 	entry_point_func =
 		hpi_lookup_entry_point_function(phm->u.s.resource.r.pci);
@@ -860,7 +759,7 @@ static void HPIMSGX__cleanup(u16 adapter_index, void *h_owner)
 				struct hpi_response hr;
 
 				HPI_DEBUG_LOG(DEBUG,
-					"close adapter %d ostream %d\n",
+					"Close adapter %d ostream %d\n",
 					adapter, i);
 
 				hpi_init_message_response(&hm, &hr,
@@ -884,7 +783,7 @@ static void HPIMSGX__cleanup(u16 adapter_index, void *h_owner)
 				struct hpi_response hr;
 
 				HPI_DEBUG_LOG(DEBUG,
-					"close adapter %d istream %d\n",
+					"Close adapter %d istream %d\n",
 					adapter, i);
 
 				hpi_init_message_response(&hm, &hr,

commit 63818c448ac6f4dd75aa42997acaa746f86acb6b
Author: Axel Lin <axel.lin@gmail.com>
Date:   Wed Jul 28 16:58:42 2010 +0800

    ALSA: hpimsgx: fix wrong sizeof
    
    The correct size should be sizeof(gRESP_HPI_SUBSYS_FIND_ADAPTERS),
    sizeof(&gRESP_HPI_SUBSYS_FIND_ADAPTERS) is incorrect.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpimsgx.c b/sound/pci/asihpi/hpimsgx.c
index 2ee90dc3d897..f01ab964f602 100644
--- a/sound/pci/asihpi/hpimsgx.c
+++ b/sound/pci/asihpi/hpimsgx.c
@@ -741,7 +741,7 @@ static void HPIMSGX__reset(u16 adapter_index)
 		hpi_init_response(&hr, HPI_OBJ_SUBSYSTEM,
 			HPI_SUBSYS_FIND_ADAPTERS, 0);
 		memcpy(&gRESP_HPI_SUBSYS_FIND_ADAPTERS, &hr,
-			sizeof(&gRESP_HPI_SUBSYS_FIND_ADAPTERS));
+			sizeof(gRESP_HPI_SUBSYS_FIND_ADAPTERS));
 
 		for (adapter = 0; adapter < HPI_MAX_ADAPTERS; adapter++) {
 

commit 719f82d3987aad4cc9f46d19c35f362672545cad
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Wed Apr 21 18:17:39 2010 +0200

    ALSA: Add support of AudioScience ASI boards
    
    Added the support of AudioScience ASI boards.
    The driver has been tested for years on alsa-driver external tree,
    now finally got merged to the kernel.
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpimsgx.c b/sound/pci/asihpi/hpimsgx.c
new file mode 100644
index 000000000000..2ee90dc3d897
--- /dev/null
+++ b/sound/pci/asihpi/hpimsgx.c
@@ -0,0 +1,907 @@
+/******************************************************************************
+
+    AudioScience HPI driver
+    Copyright (C) 1997-2010  AudioScience Inc. <support@audioscience.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of version 2 of the GNU General Public License as
+    published by the Free Software Foundation;
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+Extended Message Function With Response Cacheing
+
+(C) Copyright AudioScience Inc. 2002
+*****************************************************************************/
+#define SOURCEFILE_NAME "hpimsgx.c"
+#include "hpi_internal.h"
+#include "hpimsginit.h"
+#include "hpimsgx.h"
+#include "hpidebug.h"
+
+static struct pci_device_id asihpi_pci_tbl[] = {
+#include "hpipcida.h"
+};
+
+static struct hpios_spinlock msgx_lock;
+
+static hpi_handler_func *hpi_entry_points[HPI_MAX_ADAPTERS];
+
+static hpi_handler_func *hpi_lookup_entry_point_function(const struct hpi_pci
+	*pci_info)
+{
+
+	int i;
+
+	for (i = 0; asihpi_pci_tbl[i].vendor != 0; i++) {
+		if (asihpi_pci_tbl[i].vendor != PCI_ANY_ID
+			&& asihpi_pci_tbl[i].vendor != pci_info->vendor_id)
+			continue;
+		if (asihpi_pci_tbl[i].device != PCI_ANY_ID
+			&& asihpi_pci_tbl[i].device != pci_info->device_id)
+			continue;
+		if (asihpi_pci_tbl[i].subvendor != PCI_ANY_ID
+			&& asihpi_pci_tbl[i].subvendor !=
+			pci_info->subsys_vendor_id)
+			continue;
+		if (asihpi_pci_tbl[i].subdevice != PCI_ANY_ID
+			&& asihpi_pci_tbl[i].subdevice !=
+			pci_info->subsys_device_id)
+			continue;
+
+		HPI_DEBUG_LOG(DEBUG, " %x,%lu\n", i,
+			asihpi_pci_tbl[i].driver_data);
+		return (hpi_handler_func *) asihpi_pci_tbl[i].driver_data;
+	}
+
+	return NULL;
+}
+
+static inline void hw_entry_point(struct hpi_message *phm,
+	struct hpi_response *phr)
+{
+
+	hpi_handler_func *ep;
+
+	if (phm->adapter_index < HPI_MAX_ADAPTERS) {
+		ep = (hpi_handler_func *) hpi_entry_points[phm->
+			adapter_index];
+		if (ep) {
+			HPI_DEBUG_MESSAGE(DEBUG, phm);
+			ep(phm, phr);
+			HPI_DEBUG_RESPONSE(phr);
+			return;
+		}
+	}
+	hpi_init_response(phr, phm->object, phm->function,
+		HPI_ERROR_PROCESSING_MESSAGE);
+}
+
+static void adapter_open(struct hpi_message *phm, struct hpi_response *phr);
+static void adapter_close(struct hpi_message *phm, struct hpi_response *phr);
+
+static void mixer_open(struct hpi_message *phm, struct hpi_response *phr);
+static void mixer_close(struct hpi_message *phm, struct hpi_response *phr);
+
+static void outstream_open(struct hpi_message *phm, struct hpi_response *phr,
+	void *h_owner);
+static void outstream_close(struct hpi_message *phm, struct hpi_response *phr,
+	void *h_owner);
+static void instream_open(struct hpi_message *phm, struct hpi_response *phr,
+	void *h_owner);
+static void instream_close(struct hpi_message *phm, struct hpi_response *phr,
+	void *h_owner);
+
+static void HPIMSGX__reset(u16 adapter_index);
+static u16 HPIMSGX__init(struct hpi_message *phm, struct hpi_response *phr);
+static void HPIMSGX__cleanup(u16 adapter_index, void *h_owner);
+
+#ifndef DISABLE_PRAGMA_PACK1
+#pragma pack(push, 1)
+#endif
+
+struct hpi_subsys_response {
+	struct hpi_response_header h;
+	struct hpi_subsys_res s;
+};
+
+struct hpi_adapter_response {
+	struct hpi_response_header h;
+	struct hpi_adapter_res a;
+};
+
+struct hpi_mixer_response {
+	struct hpi_response_header h;
+	struct hpi_mixer_res m;
+};
+
+struct hpi_stream_response {
+	struct hpi_response_header h;
+	struct hpi_stream_res d;
+};
+
+struct adapter_info {
+	u16 type;
+	u16 num_instreams;
+	u16 num_outstreams;
+};
+
+struct asi_open_state {
+	int open_flag;
+	void *h_owner;
+};
+
+#ifndef DISABLE_PRAGMA_PACK1
+#pragma pack(pop)
+#endif
+
+/* Globals */
+static struct hpi_adapter_response rESP_HPI_ADAPTER_OPEN[HPI_MAX_ADAPTERS];
+
+static struct hpi_stream_response
+	rESP_HPI_OSTREAM_OPEN[HPI_MAX_ADAPTERS][HPI_MAX_STREAMS];
+
+static struct hpi_stream_response
+	rESP_HPI_ISTREAM_OPEN[HPI_MAX_ADAPTERS][HPI_MAX_STREAMS];
+
+static struct hpi_mixer_response rESP_HPI_MIXER_OPEN[HPI_MAX_ADAPTERS];
+
+static struct hpi_subsys_response gRESP_HPI_SUBSYS_FIND_ADAPTERS;
+
+static struct adapter_info aDAPTER_INFO[HPI_MAX_ADAPTERS];
+
+/* use these to keep track of opens from user mode apps/DLLs */
+static struct asi_open_state
+	outstream_user_open[HPI_MAX_ADAPTERS][HPI_MAX_STREAMS];
+
+static struct asi_open_state
+	instream_user_open[HPI_MAX_ADAPTERS][HPI_MAX_STREAMS];
+
+static void subsys_message(struct hpi_message *phm, struct hpi_response *phr,
+	void *h_owner)
+{
+	switch (phm->function) {
+	case HPI_SUBSYS_GET_VERSION:
+		hpi_init_response(phr, HPI_OBJ_SUBSYSTEM,
+			HPI_SUBSYS_GET_VERSION, 0);
+		phr->u.s.version = HPI_VER >> 8;	/* return major.minor */
+		phr->u.s.data = HPI_VER;	/* return major.minor.release */
+		break;
+	case HPI_SUBSYS_OPEN:
+		/*do not propagate the message down the chain */
+		hpi_init_response(phr, HPI_OBJ_SUBSYSTEM, HPI_SUBSYS_OPEN, 0);
+		break;
+	case HPI_SUBSYS_CLOSE:
+		/*do not propagate the message down the chain */
+		hpi_init_response(phr, HPI_OBJ_SUBSYSTEM, HPI_SUBSYS_CLOSE,
+			0);
+		HPIMSGX__cleanup(HPIMSGX_ALLADAPTERS, h_owner);
+		break;
+	case HPI_SUBSYS_DRIVER_LOAD:
+		/* Initialize this module's internal state */
+		hpios_msgxlock_init(&msgx_lock);
+		memset(&hpi_entry_points, 0, sizeof(hpi_entry_points));
+		hpios_locked_mem_init();
+		/* Init subsys_findadapters response to no-adapters */
+		HPIMSGX__reset(HPIMSGX_ALLADAPTERS);
+		hpi_init_response(phr, HPI_OBJ_SUBSYSTEM,
+			HPI_SUBSYS_DRIVER_LOAD, 0);
+		/* individual HPIs dont implement driver load */
+		HPI_COMMON(phm, phr);
+		break;
+	case HPI_SUBSYS_DRIVER_UNLOAD:
+		HPI_COMMON(phm, phr);
+		HPIMSGX__cleanup(HPIMSGX_ALLADAPTERS, h_owner);
+		hpios_locked_mem_free_all();
+		hpi_init_response(phr, HPI_OBJ_SUBSYSTEM,
+			HPI_SUBSYS_DRIVER_UNLOAD, 0);
+		return;
+
+	case HPI_SUBSYS_GET_INFO:
+		HPI_COMMON(phm, phr);
+		break;
+
+	case HPI_SUBSYS_FIND_ADAPTERS:
+		memcpy(phr, &gRESP_HPI_SUBSYS_FIND_ADAPTERS,
+			sizeof(gRESP_HPI_SUBSYS_FIND_ADAPTERS));
+		break;
+	case HPI_SUBSYS_GET_NUM_ADAPTERS:
+		memcpy(phr, &gRESP_HPI_SUBSYS_FIND_ADAPTERS,
+			sizeof(gRESP_HPI_SUBSYS_FIND_ADAPTERS));
+		phr->function = HPI_SUBSYS_GET_NUM_ADAPTERS;
+		break;
+	case HPI_SUBSYS_GET_ADAPTER:
+		{
+			int count = phm->adapter_index;
+			int index = 0;
+			hpi_init_response(phr, HPI_OBJ_SUBSYSTEM,
+				HPI_SUBSYS_GET_ADAPTER, 0);
+
+			/* This is complicated by the fact that we want to
+			 * "skip" 0's in the adapter list.
+			 * First, make sure we are pointing to a
+			 * non-zero adapter type.
+			 */
+			while (gRESP_HPI_SUBSYS_FIND_ADAPTERS.
+				s.aw_adapter_list[index] == 0) {
+				index++;
+				if (index >= HPI_MAX_ADAPTERS)
+					break;
+			}
+			while (count) {
+				/* move on to the next adapter */
+				index++;
+				if (index >= HPI_MAX_ADAPTERS)
+					break;
+				while (gRESP_HPI_SUBSYS_FIND_ADAPTERS.
+					s.aw_adapter_list[index] == 0) {
+					index++;
+					if (index >= HPI_MAX_ADAPTERS)
+						break;
+				}
+				count--;
+			}
+
+			if (index < HPI_MAX_ADAPTERS) {
+				phr->u.s.adapter_index = (u16)index;
+				phr->u.s.aw_adapter_list[0] =
+					gRESP_HPI_SUBSYS_FIND_ADAPTERS.
+					s.aw_adapter_list[index];
+			} else {
+				phr->u.s.adapter_index = 0;
+				phr->u.s.aw_adapter_list[0] = 0;
+				phr->error = HPI_ERROR_BAD_ADAPTER_NUMBER;
+			}
+			break;
+		}
+	case HPI_SUBSYS_CREATE_ADAPTER:
+		HPIMSGX__init(phm, phr);
+		break;
+	case HPI_SUBSYS_DELETE_ADAPTER:
+		HPIMSGX__cleanup(phm->adapter_index, h_owner);
+		{
+			struct hpi_message hm;
+			struct hpi_response hr;
+			/* call to HPI_ADAPTER_CLOSE */
+			hpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,
+				HPI_ADAPTER_CLOSE);
+			hm.adapter_index = phm->adapter_index;
+			hw_entry_point(&hm, &hr);
+		}
+		hw_entry_point(phm, phr);
+		gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.
+			aw_adapter_list[phm->adapter_index]
+			= 0;
+		hpi_entry_points[phm->adapter_index] = NULL;
+		break;
+	default:
+		hw_entry_point(phm, phr);
+		break;
+	}
+}
+
+static void adapter_message(struct hpi_message *phm, struct hpi_response *phr,
+	void *h_owner)
+{
+	switch (phm->function) {
+	case HPI_ADAPTER_OPEN:
+		adapter_open(phm, phr);
+		break;
+	case HPI_ADAPTER_CLOSE:
+		adapter_close(phm, phr);
+		break;
+	default:
+		hw_entry_point(phm, phr);
+		break;
+	}
+}
+
+static void mixer_message(struct hpi_message *phm, struct hpi_response *phr)
+{
+	switch (phm->function) {
+	case HPI_MIXER_OPEN:
+		mixer_open(phm, phr);
+		break;
+	case HPI_MIXER_CLOSE:
+		mixer_close(phm, phr);
+		break;
+	default:
+		hw_entry_point(phm, phr);
+		break;
+	}
+}
+
+static void outstream_message(struct hpi_message *phm,
+	struct hpi_response *phr, void *h_owner)
+{
+	if (phm->obj_index >= aDAPTER_INFO[phm->adapter_index].num_outstreams) {
+		hpi_init_response(phr, HPI_OBJ_OSTREAM, phm->function,
+			HPI_ERROR_INVALID_OBJ_INDEX);
+		return;
+	}
+
+	switch (phm->function) {
+	case HPI_OSTREAM_OPEN:
+		outstream_open(phm, phr, h_owner);
+		break;
+	case HPI_OSTREAM_CLOSE:
+		outstream_close(phm, phr, h_owner);
+		break;
+	default:
+		hw_entry_point(phm, phr);
+		break;
+	}
+}
+
+static void instream_message(struct hpi_message *phm,
+	struct hpi_response *phr, void *h_owner)
+{
+	if (phm->obj_index >= aDAPTER_INFO[phm->adapter_index].num_instreams) {
+		hpi_init_response(phr, HPI_OBJ_ISTREAM, phm->function,
+			HPI_ERROR_INVALID_OBJ_INDEX);
+		return;
+	}
+
+	switch (phm->function) {
+	case HPI_ISTREAM_OPEN:
+		instream_open(phm, phr, h_owner);
+		break;
+	case HPI_ISTREAM_CLOSE:
+		instream_close(phm, phr, h_owner);
+		break;
+	default:
+		hw_entry_point(phm, phr);
+		break;
+	}
+}
+
+/* NOTE: HPI_Message() must be defined in the driver as a wrapper for
+ * HPI_MessageEx so that functions in hpifunc.c compile.
+ */
+void hpi_send_recv_ex(struct hpi_message *phm, struct hpi_response *phr,
+	void *h_owner)
+{
+	HPI_DEBUG_MESSAGE(DEBUG, phm);
+
+	if (phm->type != HPI_TYPE_MESSAGE) {
+		hpi_init_response(phr, phm->object, phm->function,
+			HPI_ERROR_INVALID_TYPE);
+		return;
+	}
+
+	if (phm->adapter_index >= HPI_MAX_ADAPTERS
+		&& phm->adapter_index != HPIMSGX_ALLADAPTERS) {
+		hpi_init_response(phr, phm->object, phm->function,
+			HPI_ERROR_BAD_ADAPTER_NUMBER);
+		return;
+	}
+
+	switch (phm->object) {
+	case HPI_OBJ_SUBSYSTEM:
+		subsys_message(phm, phr, h_owner);
+		break;
+
+	case HPI_OBJ_ADAPTER:
+		adapter_message(phm, phr, h_owner);
+		break;
+
+	case HPI_OBJ_MIXER:
+		mixer_message(phm, phr);
+		break;
+
+	case HPI_OBJ_OSTREAM:
+		outstream_message(phm, phr, h_owner);
+		break;
+
+	case HPI_OBJ_ISTREAM:
+		instream_message(phm, phr, h_owner);
+		break;
+
+	default:
+		hw_entry_point(phm, phr);
+		break;
+	}
+	HPI_DEBUG_RESPONSE(phr);
+#if 1
+	if (phr->error >= HPI_ERROR_BACKEND_BASE) {
+		void *ep = NULL;
+		char *ep_name;
+
+		HPI_DEBUG_MESSAGE(ERROR, phm);
+
+		if (phm->adapter_index < HPI_MAX_ADAPTERS)
+			ep = hpi_entry_points[phm->adapter_index];
+
+		/* Don't need this? Have adapter index in debug info
+		   Know at driver load time index->backend mapping */
+		if (ep == HPI_6000)
+			ep_name = "HPI_6000";
+		else if (ep == HPI_6205)
+			ep_name = "HPI_6205";
+		else
+			ep_name = "unknown";
+
+		HPI_DEBUG_LOG(ERROR, "HPI %s response - error# %d\n", ep_name,
+			phr->error);
+
+		if (hpi_debug_level >= HPI_DEBUG_LEVEL_VERBOSE)
+			hpi_debug_data((u16 *)phm,
+				sizeof(*phm) / sizeof(u16));
+	}
+#endif
+}
+
+static void adapter_open(struct hpi_message *phm, struct hpi_response *phr)
+{
+	HPI_DEBUG_LOG(VERBOSE, "adapter_open\n");
+	memcpy(phr, &rESP_HPI_ADAPTER_OPEN[phm->adapter_index],
+		sizeof(rESP_HPI_ADAPTER_OPEN[0]));
+}
+
+static void adapter_close(struct hpi_message *phm, struct hpi_response *phr)
+{
+	HPI_DEBUG_LOG(VERBOSE, "adapter_close\n");
+	hpi_init_response(phr, HPI_OBJ_ADAPTER, HPI_ADAPTER_CLOSE, 0);
+}
+
+static void mixer_open(struct hpi_message *phm, struct hpi_response *phr)
+{
+	memcpy(phr, &rESP_HPI_MIXER_OPEN[phm->adapter_index],
+		sizeof(rESP_HPI_MIXER_OPEN[0]));
+}
+
+static void mixer_close(struct hpi_message *phm, struct hpi_response *phr)
+{
+	hpi_init_response(phr, HPI_OBJ_MIXER, HPI_MIXER_CLOSE, 0);
+}
+
+static void instream_open(struct hpi_message *phm, struct hpi_response *phr,
+	void *h_owner)
+{
+
+	struct hpi_message hm;
+	struct hpi_response hr;
+
+	hpi_init_response(phr, HPI_OBJ_ISTREAM, HPI_ISTREAM_OPEN, 0);
+
+	hpios_msgxlock_lock(&msgx_lock);
+
+	if (instream_user_open[phm->adapter_index][phm->obj_index].open_flag)
+		phr->error = HPI_ERROR_OBJ_ALREADY_OPEN;
+	else if (rESP_HPI_ISTREAM_OPEN[phm->adapter_index]
+		[phm->obj_index].h.error)
+		memcpy(phr,
+			&rESP_HPI_ISTREAM_OPEN[phm->adapter_index][phm->
+				obj_index],
+			sizeof(rESP_HPI_ISTREAM_OPEN[0][0]));
+	else {
+		instream_user_open[phm->adapter_index][phm->
+			obj_index].open_flag = 1;
+		hpios_msgxlock_un_lock(&msgx_lock);
+
+		/* issue a reset */
+		hpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,
+			HPI_ISTREAM_RESET);
+		hm.adapter_index = phm->adapter_index;
+		hm.obj_index = phm->obj_index;
+		hw_entry_point(&hm, &hr);
+
+		hpios_msgxlock_lock(&msgx_lock);
+		if (hr.error) {
+			instream_user_open[phm->adapter_index][phm->
+				obj_index].open_flag = 0;
+			phr->error = hr.error;
+		} else {
+			instream_user_open[phm->adapter_index][phm->
+				obj_index].open_flag = 1;
+			instream_user_open[phm->adapter_index][phm->
+				obj_index].h_owner = h_owner;
+			memcpy(phr,
+				&rESP_HPI_ISTREAM_OPEN[phm->adapter_index]
+				[phm->obj_index],
+				sizeof(rESP_HPI_ISTREAM_OPEN[0][0]));
+		}
+	}
+	hpios_msgxlock_un_lock(&msgx_lock);
+}
+
+static void instream_close(struct hpi_message *phm, struct hpi_response *phr,
+	void *h_owner)
+{
+
+	struct hpi_message hm;
+	struct hpi_response hr;
+
+	hpi_init_response(phr, HPI_OBJ_ISTREAM, HPI_ISTREAM_CLOSE, 0);
+
+	hpios_msgxlock_lock(&msgx_lock);
+	if (h_owner ==
+		instream_user_open[phm->adapter_index][phm->
+			obj_index].h_owner) {
+		/* HPI_DEBUG_LOG(INFO,"closing adapter %d "
+		   "instream %d owned by %p\n",
+		   phm->wAdapterIndex, phm->wObjIndex, hOwner); */
+		instream_user_open[phm->adapter_index][phm->
+			obj_index].h_owner = NULL;
+		hpios_msgxlock_un_lock(&msgx_lock);
+		/* issue a reset */
+		hpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,
+			HPI_ISTREAM_RESET);
+		hm.adapter_index = phm->adapter_index;
+		hm.obj_index = phm->obj_index;
+		hw_entry_point(&hm, &hr);
+		hpios_msgxlock_lock(&msgx_lock);
+		if (hr.error) {
+			instream_user_open[phm->adapter_index][phm->
+				obj_index].h_owner = h_owner;
+			phr->error = hr.error;
+		} else {
+			instream_user_open[phm->adapter_index][phm->
+				obj_index].open_flag = 0;
+			instream_user_open[phm->adapter_index][phm->
+				obj_index].h_owner = NULL;
+		}
+	} else {
+		HPI_DEBUG_LOG(WARNING,
+			"%p trying to close %d instream %d owned by %p\n",
+			h_owner, phm->adapter_index, phm->obj_index,
+			instream_user_open[phm->adapter_index][phm->
+				obj_index].h_owner);
+		phr->error = HPI_ERROR_OBJ_NOT_OPEN;
+	}
+	hpios_msgxlock_un_lock(&msgx_lock);
+}
+
+static void outstream_open(struct hpi_message *phm, struct hpi_response *phr,
+	void *h_owner)
+{
+
+	struct hpi_message hm;
+	struct hpi_response hr;
+
+	hpi_init_response(phr, HPI_OBJ_OSTREAM, HPI_OSTREAM_OPEN, 0);
+
+	hpios_msgxlock_lock(&msgx_lock);
+
+	if (outstream_user_open[phm->adapter_index][phm->obj_index].open_flag)
+		phr->error = HPI_ERROR_OBJ_ALREADY_OPEN;
+	else if (rESP_HPI_OSTREAM_OPEN[phm->adapter_index]
+		[phm->obj_index].h.error)
+		memcpy(phr,
+			&rESP_HPI_OSTREAM_OPEN[phm->adapter_index][phm->
+				obj_index],
+			sizeof(rESP_HPI_OSTREAM_OPEN[0][0]));
+	else {
+		outstream_user_open[phm->adapter_index][phm->
+			obj_index].open_flag = 1;
+		hpios_msgxlock_un_lock(&msgx_lock);
+
+		/* issue a reset */
+		hpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,
+			HPI_OSTREAM_RESET);
+		hm.adapter_index = phm->adapter_index;
+		hm.obj_index = phm->obj_index;
+		hw_entry_point(&hm, &hr);
+
+		hpios_msgxlock_lock(&msgx_lock);
+		if (hr.error) {
+			outstream_user_open[phm->adapter_index][phm->
+				obj_index].open_flag = 0;
+			phr->error = hr.error;
+		} else {
+			outstream_user_open[phm->adapter_index][phm->
+				obj_index].open_flag = 1;
+			outstream_user_open[phm->adapter_index][phm->
+				obj_index].h_owner = h_owner;
+			memcpy(phr,
+				&rESP_HPI_OSTREAM_OPEN[phm->adapter_index]
+				[phm->obj_index],
+				sizeof(rESP_HPI_OSTREAM_OPEN[0][0]));
+		}
+	}
+	hpios_msgxlock_un_lock(&msgx_lock);
+}
+
+static void outstream_close(struct hpi_message *phm, struct hpi_response *phr,
+	void *h_owner)
+{
+
+	struct hpi_message hm;
+	struct hpi_response hr;
+
+	hpi_init_response(phr, HPI_OBJ_OSTREAM, HPI_OSTREAM_CLOSE, 0);
+
+	hpios_msgxlock_lock(&msgx_lock);
+
+	if (h_owner ==
+		outstream_user_open[phm->adapter_index][phm->
+			obj_index].h_owner) {
+		/* HPI_DEBUG_LOG(INFO,"closing adapter %d "
+		   "outstream %d owned by %p\n",
+		   phm->wAdapterIndex, phm->wObjIndex, hOwner); */
+		outstream_user_open[phm->adapter_index][phm->
+			obj_index].h_owner = NULL;
+		hpios_msgxlock_un_lock(&msgx_lock);
+		/* issue a reset */
+		hpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,
+			HPI_OSTREAM_RESET);
+		hm.adapter_index = phm->adapter_index;
+		hm.obj_index = phm->obj_index;
+		hw_entry_point(&hm, &hr);
+		hpios_msgxlock_lock(&msgx_lock);
+		if (hr.error) {
+			outstream_user_open[phm->adapter_index][phm->
+				obj_index].h_owner = h_owner;
+			phr->error = hr.error;
+		} else {
+			outstream_user_open[phm->adapter_index][phm->
+				obj_index].open_flag = 0;
+			outstream_user_open[phm->adapter_index][phm->
+				obj_index].h_owner = NULL;
+		}
+	} else {
+		HPI_DEBUG_LOG(WARNING,
+			"%p trying to close %d outstream %d owned by %p\n",
+			h_owner, phm->adapter_index, phm->obj_index,
+			outstream_user_open[phm->adapter_index][phm->
+				obj_index].h_owner);
+		phr->error = HPI_ERROR_OBJ_NOT_OPEN;
+	}
+	hpios_msgxlock_un_lock(&msgx_lock);
+}
+
+static u16 adapter_prepare(u16 adapter)
+{
+	struct hpi_message hm;
+	struct hpi_response hr;
+
+	/* Open the adapter and streams */
+	u16 i;
+
+	/* call to HPI_ADAPTER_OPEN */
+	hpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,
+		HPI_ADAPTER_OPEN);
+	hm.adapter_index = adapter;
+	hw_entry_point(&hm, &hr);
+	memcpy(&rESP_HPI_ADAPTER_OPEN[adapter], &hr,
+		sizeof(rESP_HPI_ADAPTER_OPEN[0]));
+	if (hr.error)
+		return hr.error;
+
+	/* call to HPI_ADAPTER_GET_INFO */
+	hpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,
+		HPI_ADAPTER_GET_INFO);
+	hm.adapter_index = adapter;
+	hw_entry_point(&hm, &hr);
+	if (hr.error)
+		return hr.error;
+
+	aDAPTER_INFO[adapter].num_outstreams = hr.u.a.num_outstreams;
+	aDAPTER_INFO[adapter].num_instreams = hr.u.a.num_instreams;
+	aDAPTER_INFO[adapter].type = hr.u.a.adapter_type;
+
+	gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.aw_adapter_list[adapter] =
+		hr.u.a.adapter_type;
+	gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.num_adapters++;
+	if (gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.num_adapters > HPI_MAX_ADAPTERS)
+		gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.num_adapters =
+			HPI_MAX_ADAPTERS;
+
+	/* call to HPI_OSTREAM_OPEN */
+	for (i = 0; i < aDAPTER_INFO[adapter].num_outstreams; i++) {
+		hpi_init_message_response(&hm, &hr, HPI_OBJ_OSTREAM,
+			HPI_OSTREAM_OPEN);
+		hm.adapter_index = adapter;
+		hm.obj_index = i;
+		hw_entry_point(&hm, &hr);
+		memcpy(&rESP_HPI_OSTREAM_OPEN[adapter][i], &hr,
+			sizeof(rESP_HPI_OSTREAM_OPEN[0][0]));
+		outstream_user_open[adapter][i].open_flag = 0;
+		outstream_user_open[adapter][i].h_owner = NULL;
+	}
+
+	/* call to HPI_ISTREAM_OPEN */
+	for (i = 0; i < aDAPTER_INFO[adapter].num_instreams; i++) {
+		hpi_init_message_response(&hm, &hr, HPI_OBJ_ISTREAM,
+			HPI_ISTREAM_OPEN);
+		hm.adapter_index = adapter;
+		hm.obj_index = i;
+		hw_entry_point(&hm, &hr);
+		memcpy(&rESP_HPI_ISTREAM_OPEN[adapter][i], &hr,
+			sizeof(rESP_HPI_ISTREAM_OPEN[0][0]));
+		instream_user_open[adapter][i].open_flag = 0;
+		instream_user_open[adapter][i].h_owner = NULL;
+	}
+
+	/* call to HPI_MIXER_OPEN */
+	hpi_init_message_response(&hm, &hr, HPI_OBJ_MIXER, HPI_MIXER_OPEN);
+	hm.adapter_index = adapter;
+	hw_entry_point(&hm, &hr);
+	memcpy(&rESP_HPI_MIXER_OPEN[adapter], &hr,
+		sizeof(rESP_HPI_MIXER_OPEN[0]));
+
+	return gRESP_HPI_SUBSYS_FIND_ADAPTERS.h.error;
+}
+
+static void HPIMSGX__reset(u16 adapter_index)
+{
+	int i;
+	u16 adapter;
+	struct hpi_response hr;
+
+	if (adapter_index == HPIMSGX_ALLADAPTERS) {
+		/* reset all responses to contain errors */
+		hpi_init_response(&hr, HPI_OBJ_SUBSYSTEM,
+			HPI_SUBSYS_FIND_ADAPTERS, 0);
+		memcpy(&gRESP_HPI_SUBSYS_FIND_ADAPTERS, &hr,
+			sizeof(&gRESP_HPI_SUBSYS_FIND_ADAPTERS));
+
+		for (adapter = 0; adapter < HPI_MAX_ADAPTERS; adapter++) {
+
+			hpi_init_response(&hr, HPI_OBJ_ADAPTER,
+				HPI_ADAPTER_OPEN, HPI_ERROR_BAD_ADAPTER);
+			memcpy(&rESP_HPI_ADAPTER_OPEN[adapter], &hr,
+				sizeof(rESP_HPI_ADAPTER_OPEN[adapter]));
+
+			hpi_init_response(&hr, HPI_OBJ_MIXER, HPI_MIXER_OPEN,
+				HPI_ERROR_INVALID_OBJ);
+			memcpy(&rESP_HPI_MIXER_OPEN[adapter], &hr,
+				sizeof(rESP_HPI_MIXER_OPEN[adapter]));
+
+			for (i = 0; i < HPI_MAX_STREAMS; i++) {
+				hpi_init_response(&hr, HPI_OBJ_OSTREAM,
+					HPI_OSTREAM_OPEN,
+					HPI_ERROR_INVALID_OBJ);
+				memcpy(&rESP_HPI_OSTREAM_OPEN[adapter][i],
+					&hr,
+					sizeof(rESP_HPI_OSTREAM_OPEN[adapter]
+						[i]));
+				hpi_init_response(&hr, HPI_OBJ_ISTREAM,
+					HPI_ISTREAM_OPEN,
+					HPI_ERROR_INVALID_OBJ);
+				memcpy(&rESP_HPI_ISTREAM_OPEN[adapter][i],
+					&hr,
+					sizeof(rESP_HPI_ISTREAM_OPEN[adapter]
+						[i]));
+			}
+		}
+	} else if (adapter_index < HPI_MAX_ADAPTERS) {
+		rESP_HPI_ADAPTER_OPEN[adapter_index].h.error =
+			HPI_ERROR_BAD_ADAPTER;
+		rESP_HPI_MIXER_OPEN[adapter_index].h.error =
+			HPI_ERROR_INVALID_OBJ;
+		for (i = 0; i < HPI_MAX_STREAMS; i++) {
+			rESP_HPI_OSTREAM_OPEN[adapter_index][i].h.error =
+				HPI_ERROR_INVALID_OBJ;
+			rESP_HPI_ISTREAM_OPEN[adapter_index][i].h.error =
+				HPI_ERROR_INVALID_OBJ;
+		}
+		if (gRESP_HPI_SUBSYS_FIND_ADAPTERS.
+			s.aw_adapter_list[adapter_index]) {
+			gRESP_HPI_SUBSYS_FIND_ADAPTERS.
+				s.aw_adapter_list[adapter_index] = 0;
+			gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.num_adapters--;
+		}
+	}
+}
+
+static u16 HPIMSGX__init(struct hpi_message *phm,
+	/* HPI_SUBSYS_CREATE_ADAPTER structure with */
+	/* resource list or NULL=find all */
+	struct hpi_response *phr
+	/* response from HPI_ADAPTER_GET_INFO */
+	)
+{
+	hpi_handler_func *entry_point_func;
+	struct hpi_response hr;
+
+	if (gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.num_adapters >= HPI_MAX_ADAPTERS)
+		return HPI_ERROR_BAD_ADAPTER_NUMBER;
+
+	/* Init response here so we can pass in previous adapter list */
+	hpi_init_response(&hr, phm->object, phm->function,
+		HPI_ERROR_INVALID_OBJ);
+	memcpy(hr.u.s.aw_adapter_list,
+		gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.aw_adapter_list,
+		sizeof(gRESP_HPI_SUBSYS_FIND_ADAPTERS.s.aw_adapter_list));
+
+	entry_point_func =
+		hpi_lookup_entry_point_function(phm->u.s.resource.r.pci);
+
+	if (entry_point_func) {
+		HPI_DEBUG_MESSAGE(DEBUG, phm);
+		entry_point_func(phm, &hr);
+	} else {
+		phr->error = HPI_ERROR_PROCESSING_MESSAGE;
+		return phr->error;
+	}
+	if (hr.error == 0) {
+		/* the adapter was created succesfully
+		   save the mapping for future use */
+		hpi_entry_points[hr.u.s.adapter_index] = entry_point_func;
+		/* prepare adapter (pre-open streams etc.) */
+		HPI_DEBUG_LOG(DEBUG,
+			"HPI_SUBSYS_CREATE_ADAPTER successful,"
+			" preparing adapter\n");
+		adapter_prepare(hr.u.s.adapter_index);
+	}
+	memcpy(phr, &hr, hr.size);
+	return phr->error;
+}
+
+static void HPIMSGX__cleanup(u16 adapter_index, void *h_owner)
+{
+	int i, adapter, adapter_limit;
+
+	if (!h_owner)
+		return;
+
+	if (adapter_index == HPIMSGX_ALLADAPTERS) {
+		adapter = 0;
+		adapter_limit = HPI_MAX_ADAPTERS;
+	} else {
+		adapter = adapter_index;
+		adapter_limit = adapter + 1;
+	}
+
+	for (; adapter < adapter_limit; adapter++) {
+		/*      printk(KERN_INFO "Cleanup adapter #%d\n",wAdapter); */
+		for (i = 0; i < HPI_MAX_STREAMS; i++) {
+			if (h_owner ==
+				outstream_user_open[adapter][i].h_owner) {
+				struct hpi_message hm;
+				struct hpi_response hr;
+
+				HPI_DEBUG_LOG(DEBUG,
+					"close adapter %d ostream %d\n",
+					adapter, i);
+
+				hpi_init_message_response(&hm, &hr,
+					HPI_OBJ_OSTREAM, HPI_OSTREAM_RESET);
+				hm.adapter_index = (u16)adapter;
+				hm.obj_index = (u16)i;
+				hw_entry_point(&hm, &hr);
+
+				hm.function = HPI_OSTREAM_HOSTBUFFER_FREE;
+				hw_entry_point(&hm, &hr);
+
+				hm.function = HPI_OSTREAM_GROUP_RESET;
+				hw_entry_point(&hm, &hr);
+
+				outstream_user_open[adapter][i].open_flag = 0;
+				outstream_user_open[adapter][i].h_owner =
+					NULL;
+			}
+			if (h_owner == instream_user_open[adapter][i].h_owner) {
+				struct hpi_message hm;
+				struct hpi_response hr;
+
+				HPI_DEBUG_LOG(DEBUG,
+					"close adapter %d istream %d\n",
+					adapter, i);
+
+				hpi_init_message_response(&hm, &hr,
+					HPI_OBJ_ISTREAM, HPI_ISTREAM_RESET);
+				hm.adapter_index = (u16)adapter;
+				hm.obj_index = (u16)i;
+				hw_entry_point(&hm, &hr);
+
+				hm.function = HPI_ISTREAM_HOSTBUFFER_FREE;
+				hw_entry_point(&hm, &hr);
+
+				hm.function = HPI_ISTREAM_GROUP_RESET;
+				hw_entry_point(&hm, &hr);
+
+				instream_user_open[adapter][i].open_flag = 0;
+				instream_user_open[adapter][i].h_owner = NULL;
+			}
+		}
+	}
+}
