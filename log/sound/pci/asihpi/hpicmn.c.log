commit 07d7fe7bd6a56f20d57e708c508bf29bea16aa40
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:12:47 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 273
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of version 2 of the gnu general public license as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 24 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141334.606756275@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index c7751243dc42..968510bc2552 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -1,20 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /******************************************************************************
 
     AudioScience HPI driver
     Copyright (C) 1997-2014  AudioScience Inc. <support@audioscience.com>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of version 2 of the GNU General Public License as
-    published by the Free Software Foundation;
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
 \file hpicmn.c
 

commit c1464a885444dd7e9c4491177ee102b64adc46c5
Author: Eliot Blennerhassett <eliot@blennerhassett.gen.nz>
Date:   Thu Nov 20 16:22:52 2014 +1300

    ALSA: asihpi: Refactor control cache code.
    
    Signed-off-by: Eliot Blennerhassett <eliot@blennerhassett.gen.nz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index 7ed5c26c3737..c7751243dc42 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -1,7 +1,7 @@
 /******************************************************************************
 
     AudioScience HPI driver
-    Copyright (C) 1997-2011  AudioScience Inc. <support@audioscience.com>
+    Copyright (C) 1997-2014  AudioScience Inc. <support@audioscience.com>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of version 2 of the GNU General Public License as
@@ -206,6 +206,14 @@ static unsigned int control_cache_alloc_check(struct hpi_control_cache *pC)
 			struct hpi_control_cache_info *info =
 				(struct hpi_control_cache_info *)
 				&p_master_cache[byte_count];
+			u16 control_index = info->control_index;
+
+			if (control_index >= pC->control_count) {
+				HPI_DEBUG_LOG(INFO,
+					"adap %d control index %d out of range, cache not ready?\n",
+					pC->adap_idx, control_index);
+				return 0;
+			}
 
 			if (!info->size_in32bit_words) {
 				if (!i) {
@@ -225,10 +233,10 @@ static unsigned int control_cache_alloc_check(struct hpi_control_cache *pC)
 			}
 
 			if (info->control_type) {
-				pC->p_info[info->control_index] = info;
+				pC->p_info[control_index] = info;
 				cached++;
 			} else {	/* dummy cache entry */
-				pC->p_info[info->control_index] = NULL;
+				pC->p_info[control_index] = NULL;
 			}
 
 			byte_count += info->size_in32bit_words * 4;
@@ -309,35 +317,18 @@ static const struct pad_ofs_size pad_desc[] = {
 /** CheckControlCache checks the cache and fills the struct hpi_response
  * accordingly. It returns one if a cache hit occurred, zero otherwise.
  */
-short hpi_check_control_cache(struct hpi_control_cache *p_cache,
+short hpi_check_control_cache_single(struct hpi_control_cache_single *pC,
 	struct hpi_message *phm, struct hpi_response *phr)
 {
-	short found = 1;
-	struct hpi_control_cache_info *pI;
-	struct hpi_control_cache_single *pC;
 	size_t response_size;
-	if (!find_control(phm->obj_index, p_cache, &pI)) {
-		HPI_DEBUG_LOG(VERBOSE,
-			"HPICMN find_control() failed for adap %d\n",
-			phm->adapter_index);
-		return 0;
-	}
-
-	phr->error = 0;
-	phr->specific_error = 0;
-	phr->version = 0;
+	short found = 1;
 
 	/* set the default response size */
 	response_size =
 		sizeof(struct hpi_response_header) +
 		sizeof(struct hpi_control_res);
 
-	/* pC is the default cached control strucure. May be cast to
-	   something else in the following switch statement.
-	 */
-	pC = (struct hpi_control_cache_single *)pI;
-
-	switch (pI->control_type) {
+	switch (pC->u.i.control_type) {
 
 	case HPI_CONTROL_METER:
 		if (phm->u.c.attribute == HPI_METER_PEAK) {
@@ -467,7 +458,7 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 		break;
 	case HPI_CONTROL_PAD:{
 			struct hpi_control_cache_pad *p_pad;
-			p_pad = (struct hpi_control_cache_pad *)pI;
+			p_pad = (struct hpi_control_cache_pad *)pC;
 
 			if (!(p_pad->field_valid_flags & (1 <<
 						HPI_CTL_ATTR_INDEX(phm->u.c.
@@ -531,7 +522,8 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 
 	HPI_DEBUG_LOG(VERBOSE, "%s Adap %d, Ctl %d, Type %d, Attr %d\n",
 		found ? "Cached" : "Uncached", phm->adapter_index,
-		pI->control_index, pI->control_type, phm->u.c.attribute);
+		pC->u.i.control_index, pC->u.i.control_type,
+		phm->u.c.attribute);
 
 	if (found) {
 		phr->size = (u16)response_size;
@@ -543,34 +535,36 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 	return found;
 }
 
-/** Updates the cache with Set values.
-
-Only update if no error.
-Volume and Level return the limited values in the response, so use these
-Multiplexer does so use sent values
-*/
-void hpi_cmn_control_cache_sync_to_msg(struct hpi_control_cache *p_cache,
+short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 	struct hpi_message *phm, struct hpi_response *phr)
 {
-	struct hpi_control_cache_single *pC;
 	struct hpi_control_cache_info *pI;
 
-	if (phr->error)
-		return;
-
 	if (!find_control(phm->obj_index, p_cache, &pI)) {
 		HPI_DEBUG_LOG(VERBOSE,
 			"HPICMN find_control() failed for adap %d\n",
 			phm->adapter_index);
-		return;
+		return 0;
 	}
 
-	/* pC is the default cached control strucure.
-	   May be cast to something else in the following switch statement.
-	 */
-	pC = (struct hpi_control_cache_single *)pI;
+	phr->error = 0;
+	phr->specific_error = 0;
+	phr->version = 0;
+
+	return hpi_check_control_cache_single((struct hpi_control_cache_single
+			*)pI, phm, phr);
+}
+
+/** Updates the cache with Set values.
 
-	switch (pI->control_type) {
+Only update if no error.
+Volume and Level return the limited values in the response, so use these
+Multiplexer does so use sent values
+*/
+void hpi_cmn_control_cache_sync_to_msg_single(struct hpi_control_cache_single
+	*pC, struct hpi_message *phm, struct hpi_response *phr)
+{
+	switch (pC->u.i.control_type) {
 	case HPI_CONTROL_VOLUME:
 		if (phm->u.c.attribute == HPI_VOLUME_GAIN) {
 			pC->u.vol.an_log[0] = phr->u.c.an_log_value[0];
@@ -625,6 +619,30 @@ void hpi_cmn_control_cache_sync_to_msg(struct hpi_control_cache *p_cache,
 	}
 }
 
+void hpi_cmn_control_cache_sync_to_msg(struct hpi_control_cache *p_cache,
+	struct hpi_message *phm, struct hpi_response *phr)
+{
+	struct hpi_control_cache_single *pC;
+	struct hpi_control_cache_info *pI;
+
+	if (phr->error)
+		return;
+
+	if (!find_control(phm->obj_index, p_cache, &pI)) {
+		HPI_DEBUG_LOG(VERBOSE,
+			"HPICMN find_control() failed for adap %d\n",
+			phm->adapter_index);
+		return;
+	}
+
+	/* pC is the default cached control strucure.
+	   May be cast to something else in the following switch statement.
+	 */
+	pC = (struct hpi_control_cache_single *)pI;
+
+	hpi_cmn_control_cache_sync_to_msg_single(pC, phm, phr);
+}
+
 /** Allocate control cache.
 
 \return Cache pointer, or NULL if allocation fails.
@@ -637,12 +655,13 @@ struct hpi_control_cache *hpi_alloc_control_cache(const u32 control_count,
 	if (!p_cache)
 		return NULL;
 
-	p_cache->p_info = kcalloc(control_count, sizeof(*p_cache->p_info),
-				  GFP_KERNEL);
+	p_cache->p_info =
+		kcalloc(control_count, sizeof(*p_cache->p_info), GFP_KERNEL);
 	if (!p_cache->p_info) {
 		kfree(p_cache);
 		return NULL;
 	}
+
 	p_cache->cache_size_in_bytes = size_in_bytes;
 	p_cache->control_count = control_count;
 	p_cache->p_cache = p_dsp_control_buffer;

commit 8637bc94f6a36c138229ac1ea09faca343f48bd7
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Thu Dec 22 13:38:49 2011 +1300

    ALSA: asihpi - Correct headers in cached control responses.
    
    Previously, only payload and size were correct, sufficient for reading,
    but other fields produced spurious debug output.
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index c54a49f0e6d1..7ed5c26c3737 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -324,6 +324,8 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 	}
 
 	phr->error = 0;
+	phr->specific_error = 0;
+	phr->version = 0;
 
 	/* set the default response size */
 	response_size =
@@ -531,8 +533,12 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 		found ? "Cached" : "Uncached", phm->adapter_index,
 		pI->control_index, pI->control_type, phm->u.c.attribute);
 
-	if (found)
+	if (found) {
 		phr->size = (u16)response_size;
+		phr->type = HPI_TYPE_RESPONSE;
+		phr->object = phm->object;
+		phr->function = phm->function;
+	}
 
 	return found;
 }

commit 7036b92d303a01477e27a5a9b2d582a5df3cc8ef
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Thu Dec 22 13:38:43 2011 +1300

    ALSA: asihpi - Remove redundant struct members.
    
    Structs hpi_adapter and snd_card_asihpi had members that
    duplicate those in underlying hpi_adapter_obj or whose info
    can be retrieved using hpi_adapter_get_info().
    
    Print less info in probe function, it can be retrieved from /proc.
    
    Avoid name redundancy: hpi_adapter_obj.adapter_type renamed to .type
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index 358853a047c2..c54a49f0e6d1 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -68,7 +68,7 @@ u16 hpi_validate_response(struct hpi_message *phm, struct hpi_response *phr)
 u16 hpi_add_adapter(struct hpi_adapter_obj *pao)
 {
 	u16 retval = 0;
-	/*HPI_ASSERT(pao->wAdapterType); */
+	/*HPI_ASSERT(pao->type); */
 
 	hpios_alistlock_lock(&adapters);
 
@@ -77,13 +77,13 @@ u16 hpi_add_adapter(struct hpi_adapter_obj *pao)
 		goto unlock;
 	}
 
-	if (adapters.adapter[pao->index].adapter_type) {
+	if (adapters.adapter[pao->index].type) {
 		int a;
 		for (a = HPI_MAX_ADAPTERS - 1; a >= 0; a--) {
-			if (!adapters.adapter[a].adapter_type) {
+			if (!adapters.adapter[a].type) {
 				HPI_DEBUG_LOG(WARNING,
 					"ASI%X duplicate index %d moved to %d\n",
-					pao->adapter_type, pao->index, a);
+					pao->type, pao->index, a);
 				pao->index = a;
 				break;
 			}
@@ -104,13 +104,13 @@ u16 hpi_add_adapter(struct hpi_adapter_obj *pao)
 
 void hpi_delete_adapter(struct hpi_adapter_obj *pao)
 {
-	if (!pao->adapter_type) {
+	if (!pao->type) {
 		HPI_DEBUG_LOG(ERROR, "removing null adapter?\n");
 		return;
 	}
 
 	hpios_alistlock_lock(&adapters);
-	if (adapters.adapter[pao->index].adapter_type)
+	if (adapters.adapter[pao->index].type)
 		adapters.gw_num_adapters--;
 	memset(&adapters.adapter[pao->index], 0, sizeof(adapters.adapter[0]));
 	hpios_alistlock_unlock(&adapters);
@@ -132,7 +132,7 @@ struct hpi_adapter_obj *hpi_find_adapter(u16 adapter_index)
 	}
 
 	pao = &adapters.adapter[adapter_index];
-	if (pao->adapter_type != 0) {
+	if (pao->type != 0) {
 		/*
 		   HPI_DEBUG_LOG(VERBOSE, "Found adapter index %d\n",
 		   wAdapterIndex);
@@ -165,7 +165,7 @@ static void subsys_get_adapter(struct hpi_message *phm,
 
 	/* find the nCount'th nonzero adapter in array */
 	for (index = 0; index < HPI_MAX_ADAPTERS; index++) {
-		if (adapters.adapter[index].adapter_type) {
+		if (adapters.adapter[index].type) {
 			if (!count)
 				break;
 			count--;
@@ -174,11 +174,11 @@ static void subsys_get_adapter(struct hpi_message *phm,
 
 	if (index < HPI_MAX_ADAPTERS) {
 		phr->u.s.adapter_index = adapters.adapter[index].index;
-		phr->u.s.adapter_type = adapters.adapter[index].adapter_type;
+		phr->u.s.adapter_type = adapters.adapter[index].type;
 	} else {
 		phr->u.s.adapter_index = 0;
 		phr->u.s.adapter_type = 0;
-		phr->error = HPI_ERROR_BAD_ADAPTER_NUMBER;
+		phr->error = HPI_ERROR_INVALID_OBJ_INDEX;
 	}
 }
 

commit 40818b6242513676c8adf30811fb7877b02005fb
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Thu Dec 22 13:38:32 2011 +1300

    ALSA: asihpi - Update copyright to 2011
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index 44c7eb4a3f1d..358853a047c2 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -1,7 +1,7 @@
 /******************************************************************************
 
     AudioScience HPI driver
-    Copyright (C) 1997-2010  AudioScience Inc. <support@audioscience.com>
+    Copyright (C) 1997-2011  AudioScience Inc. <support@audioscience.com>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of version 2 of the GNU General Public License as

commit 6d2d4313690f2f81a9a54c6a0c8ae645c4598063
Author: Thomas Meyer <thomas@m3y3r.de>
Date:   Tue Nov 29 22:08:00 2011 +0100

    ALSA: asihp: Use kcalloc instead of kzalloc to allocate array
    
    The advantage of kcalloc is, that will prevent integer overflows which could
    result from the multiplication of number of elements and size and it is also
    a bit nicer to read.
    
    The semantic patch that makes this change is available
    in https://lkml.org/lkml/2011/11/25/107
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index bd47521b24ec..44c7eb4a3f1d 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -631,7 +631,7 @@ struct hpi_control_cache *hpi_alloc_control_cache(const u32 control_count,
 	if (!p_cache)
 		return NULL;
 
-	p_cache->p_info = kzalloc(sizeof(*p_cache->p_info) * control_count,
+	p_cache->p_info = kcalloc(control_count, sizeof(*p_cache->p_info),
 				  GFP_KERNEL);
 	if (!p_cache->p_info) {
 		kfree(p_cache);

commit 67ada8367c323ce13d0268c87cf09bf8af956e92
Author: Thomas Meyer <thomas@m3y3r.de>
Date:   Sat Aug 6 13:26:20 2011 +0200

    ALSA: asihpi - use kzalloc()
    
     Use kzalloc rather than kmalloc followed by memset with 0
    
     This considers some simple cases that are common and easy to validate
     Note in particular that there are no ...s in the rule, so all of the
     matched code has to be contiguous
    
     The semantic patch that makes this output is available
     in scripts/coccinelle/api/alloc/kzalloc-simple.cocci.
    
     More information about semantic patching is available at
     http://coccinelle.lip6.fr/
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index 65b7ca13115b..bd47521b24ec 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -631,13 +631,12 @@ struct hpi_control_cache *hpi_alloc_control_cache(const u32 control_count,
 	if (!p_cache)
 		return NULL;
 
-	p_cache->p_info =
-		kmalloc(sizeof(*p_cache->p_info) * control_count, GFP_KERNEL);
+	p_cache->p_info = kzalloc(sizeof(*p_cache->p_info) * control_count,
+				  GFP_KERNEL);
 	if (!p_cache->p_info) {
 		kfree(p_cache);
 		return NULL;
 	}
-	memset(p_cache->p_info, 0, sizeof(*p_cache->p_info) * control_count);
 	p_cache->cache_size_in_bytes = size_in_bytes;
 	p_cache->control_count = control_count;
 	p_cache->p_cache = p_dsp_control_buffer;

commit 3d0591eee46f1c7cdfd502c8366e5552b8cea3db
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Fri Jul 22 15:52:58 2011 +1200

    ALSA: asihpi - Use size_t for sizeof result
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index 808f18447fa9..65b7ca13115b 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -315,7 +315,7 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 	short found = 1;
 	struct hpi_control_cache_info *pI;
 	struct hpi_control_cache_single *pC;
-	u16 response_size;
+	size_t response_size;
 	if (!find_control(phm->obj_index, p_cache, &pI)) {
 		HPI_DEBUG_LOG(VERBOSE,
 			"HPICMN find_control() failed for adap %d\n",
@@ -532,7 +532,7 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 		pI->control_index, pI->control_type, phm->u.c.attribute);
 
 	if (found)
-		phr->size = response_size;
+		phr->size = (u16)response_size;
 
 	return found;
 }

commit 938c565a821706177d810dc08f9e1506d7429760
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Fri Jul 22 15:52:50 2011 +1200

    ALSA: asihpi - Fix minor typos and spelling
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index fe2e1ae3853d..808f18447fa9 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -57,7 +57,7 @@ u16 hpi_validate_response(struct hpi_message *phm, struct hpi_response *phr)
 	}
 
 	if (phr->function != phm->function) {
-		HPI_DEBUG_LOG(ERROR, "header type %d invalid\n",
+		HPI_DEBUG_LOG(ERROR, "header function %d invalid\n",
 			phr->function);
 		return HPI_ERROR_INVALID_RESPONSE;
 	}

commit c6c2c9aba16c41a8f72bec0738880447d158bdf7
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Fri Jul 22 15:52:38 2011 +1200

    ALSA: asihpi - Increase request and response buffer sizes
    
    Allow for up to 256 bytes of extra data on top of standard hpi
    request and response sizes.
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index 801dcd89c86e..fe2e1ae3853d 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -315,8 +315,7 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 	short found = 1;
 	struct hpi_control_cache_info *pI;
 	struct hpi_control_cache_single *pC;
-	struct hpi_control_cache_pad *p_pad;
-
+	u16 response_size;
 	if (!find_control(phm->obj_index, p_cache, &pI)) {
 		HPI_DEBUG_LOG(VERBOSE,
 			"HPICMN find_control() failed for adap %d\n",
@@ -326,11 +325,15 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 
 	phr->error = 0;
 
+	/* set the default response size */
+	response_size =
+		sizeof(struct hpi_response_header) +
+		sizeof(struct hpi_control_res);
+
 	/* pC is the default cached control strucure. May be cast to
 	   something else in the following switch statement.
 	 */
 	pC = (struct hpi_control_cache_single *)pI;
-	p_pad = (struct hpi_control_cache_pad *)pI;
 
 	switch (pI->control_type) {
 
@@ -529,9 +532,7 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 		pI->control_index, pI->control_type, phm->u.c.attribute);
 
 	if (found)
-		phr->size =
-			sizeof(struct hpi_response_header) +
-			sizeof(struct hpi_control_res);
+		phr->size = response_size;
 
 	return found;
 }

commit 82b5774fe02c61fc70aed6bc885f0d26b708e925
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Fri Jul 22 15:52:36 2011 +1200

    ALSA: asihpi - Give more meaningful name to hpi request message type
    
    Having a 'request message' makes more sense than a 'message message'
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index b15a02e91f82..801dcd89c86e 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -682,7 +682,7 @@ static void subsys_message(struct hpi_message *phm, struct hpi_response *phr)
 void HPI_COMMON(struct hpi_message *phm, struct hpi_response *phr)
 {
 	switch (phm->type) {
-	case HPI_TYPE_MESSAGE:
+	case HPI_TYPE_REQUEST:
 		switch (phm->object) {
 		case HPI_OBJ_SUBSYSTEM:
 			subsys_message(phm, phr);

commit 42258daba22897f9859b0f3cb42700322b7c16bc
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Tue Apr 5 20:55:48 2011 +1200

    ALSA: asihpi: Minor cleanups
    
    Remove some unneeded defintions
    Use %pR to print resources
    Make some data const
    Consistent braces for else
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index 0428f285725d..b15a02e91f82 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -227,8 +227,9 @@ static unsigned int control_cache_alloc_check(struct hpi_control_cache *pC)
 			if (info->control_type) {
 				pC->p_info[info->control_index] = info;
 				cached++;
-			} else	/* dummy cache entry */
+			} else {	/* dummy cache entry */
 				pC->p_info[info->control_index] = NULL;
+			}
 
 			byte_count += info->size_in32bit_words * 4;
 
@@ -298,7 +299,7 @@ struct pad_ofs_size {
 	unsigned int field_size;
 };
 
-static struct pad_ofs_size pad_desc[] = {
+static const struct pad_ofs_size pad_desc[] = {
 	HPICMN_PAD_OFS_AND_SIZE(c_channel),	/* HPI_PAD_CHANNEL_NAME */
 	HPICMN_PAD_OFS_AND_SIZE(c_artist),	/* HPI_PAD_ARTIST */
 	HPICMN_PAD_OFS_AND_SIZE(c_title),	/* HPI_PAD_TITLE */
@@ -617,6 +618,10 @@ void hpi_cmn_control_cache_sync_to_msg(struct hpi_control_cache *p_cache,
 	}
 }
 
+/** Allocate control cache.
+
+\return Cache pointer, or NULL if allocation fails.
+*/
 struct hpi_control_cache *hpi_alloc_control_cache(const u32 control_count,
 	const u32 size_in_bytes, u8 *p_dsp_control_buffer)
 {

commit 6d0b898e9c402d6b7d0d07adacdbee2ebedafdcd
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Tue Apr 5 20:55:47 2011 +1200

    ALSA: asihpi: Simplify driver unload cleanup
    
    Replacing subsys_delete_adapter with adapter_delete
    allows some special-case adapter lookup code to be removed.
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index 3e9c5c289764..0428f285725d 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -667,7 +667,6 @@ static void subsys_message(struct hpi_message *phm, struct hpi_response *phr)
 		phr->u.s.num_adapters = adapters.gw_num_adapters;
 		break;
 	case HPI_SUBSYS_CREATE_ADAPTER:
-	case HPI_SUBSYS_DELETE_ADAPTER:
 		break;
 	default:
 		phr->error = HPI_ERROR_INVALID_FUNC;

commit d6f1c1c3646276c0784398d4ab31a9c307a6e15f
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Thu Feb 10 17:26:12 2011 +1300

    ALSA: asihpi - Allow adapters with duplicate index jumpers to be discovered.
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index 4b3f4761cba5..3e9c5c289764 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -78,8 +78,18 @@ u16 hpi_add_adapter(struct hpi_adapter_obj *pao)
 	}
 
 	if (adapters.adapter[pao->index].adapter_type) {
-		{
-			retval = HPI_DUPLICATE_ADAPTER_NUMBER;
+		int a;
+		for (a = HPI_MAX_ADAPTERS - 1; a >= 0; a--) {
+			if (!adapters.adapter[a].adapter_type) {
+				HPI_DEBUG_LOG(WARNING,
+					"ASI%X duplicate index %d moved to %d\n",
+					pao->adapter_type, pao->index, a);
+				pao->index = a;
+				break;
+			}
+		}
+		if (a < 0) {
+			retval = HPI_ERROR_DUPLICATE_ADAPTER_NUMBER;
 			goto unlock;
 		}
 	}

commit fc3a399019a5a54258095c9bb0e17d4be5d51e67
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Thu Feb 10 17:26:11 2011 +1300

    ALSA: asihpi - Add volume mute control.
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index e0a08f61a348..4b3f4761cba5 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -347,8 +347,21 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 		if (phm->u.c.attribute == HPI_VOLUME_GAIN) {
 			phr->u.c.an_log_value[0] = pC->u.vol.an_log[0];
 			phr->u.c.an_log_value[1] = pC->u.vol.an_log[1];
-		} else
+		} else if (phm->u.c.attribute == HPI_VOLUME_MUTE) {
+			if (pC->u.vol.flags & HPI_VOLUME_FLAG_HAS_MUTE) {
+				if (pC->u.vol.flags & HPI_VOLUME_FLAG_MUTED)
+					phr->u.c.param1 =
+						HPI_BITMASK_ALL_CHANNELS;
+				else
+					phr->u.c.param1 = 0;
+			} else {
+				phr->error =
+					HPI_ERROR_INVALID_CONTROL_ATTRIBUTE;
+				phr->u.c.param1 = 0;
+			}
+		} else {
 			found = 0;
+		}
 		break;
 	case HPI_CONTROL_MULTIPLEXER:
 		if (phm->u.c.attribute == HPI_MULTIPLEXER_SOURCE) {
@@ -544,6 +557,11 @@ void hpi_cmn_control_cache_sync_to_msg(struct hpi_control_cache *p_cache,
 		if (phm->u.c.attribute == HPI_VOLUME_GAIN) {
 			pC->u.vol.an_log[0] = phr->u.c.an_log_value[0];
 			pC->u.vol.an_log[1] = phr->u.c.an_log_value[1];
+		} else if (phm->u.c.attribute == HPI_VOLUME_MUTE) {
+			if (phm->u.c.param1)
+				pC->u.vol.flags |= HPI_VOLUME_FLAG_MUTED;
+			else
+				pC->u.vol.flags &= ~HPI_VOLUME_FLAG_MUTED;
 		}
 		break;
 	case HPI_CONTROL_MULTIPLEXER:

commit 2f918a6445218120a7b5e4ce6b6e76064ee8f846
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Thu Feb 10 17:26:09 2011 +1300

    ALSA: asihpi - Replace adapter list with single item in subsys response.
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index 4d696ab4b1f0..e0a08f61a348 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -164,11 +164,10 @@ static void subsys_get_adapter(struct hpi_message *phm,
 
 	if (index < HPI_MAX_ADAPTERS) {
 		phr->u.s.adapter_index = adapters.adapter[index].index;
-		phr->u.s.aw_adapter_list[0] =
-			adapters.adapter[index].adapter_type;
+		phr->u.s.adapter_type = adapters.adapter[index].adapter_type;
 	} else {
 		phr->u.s.adapter_index = 0;
-		phr->u.s.aw_adapter_list[0] = 0;
+		phr->u.s.adapter_type = 0;
 		phr->error = HPI_ERROR_BAD_ADAPTER_NUMBER;
 	}
 }

commit 4704998e84b03e2d93ef8d4d03eeb7a84c0cb493
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Thu Feb 10 17:26:06 2011 +1300

    ALSA: asihpi - Code cleanup.
    
    Remove unused function.
    Simplify hpi_alloc_control_cache.
    Remove useless assignment to struct subsequently freed.
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index 8346aeabee5d..4d696ab4b1f0 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -156,7 +156,7 @@ static void subsys_get_adapter(struct hpi_message *phm,
 	/* find the nCount'th nonzero adapter in array */
 	for (index = 0; index < HPI_MAX_ADAPTERS; index++) {
 		if (adapters.adapter[index].adapter_type) {
-			if (count == 0)
+			if (!count)
 				break;
 			count--;
 		}
@@ -199,7 +199,7 @@ static unsigned int control_cache_alloc_check(struct hpi_control_cache *pC)
 				&p_master_cache[byte_count];
 
 			if (!info->size_in32bit_words) {
-				if (i == 0) {
+				if (!i) {
 					HPI_DEBUG_LOG(INFO,
 						"adap %d cache not ready?\n",
 						pC->adap_idx);
@@ -279,28 +279,6 @@ static short find_control(u16 control_index,
 	return 1;
 }
 
-/** Used by the kernel driver to figure out if a buffer needs mapping.
- */
-short hpi_check_buffer_mapping(struct hpi_control_cache *p_cache,
-	struct hpi_message *phm, void **p, unsigned int *pN)
-{
-	*pN = 0;
-	*p = NULL;
-	if ((phm->function == HPI_CONTROL_GET_STATE)
-		&& (phm->object == HPI_OBJ_CONTROLEX)
-		) {
-		struct hpi_control_cache_info *pI;
-
-		if (!find_control(phm->obj_index, p_cache, &pI)) {
-			HPI_DEBUG_LOG(VERBOSE,
-				"HPICMN find_control() failed for adap %d\n",
-				phm->adapter_index);
-			return 0;
-		}
-	}
-	return 0;
-}
-
 /* allow unified treatment of several string fields within struct */
 #define HPICMN_PAD_OFS_AND_SIZE(m)  {\
 	offsetof(struct hpi_control_cache_pad, m), \
@@ -612,24 +590,24 @@ void hpi_cmn_control_cache_sync_to_msg(struct hpi_control_cache *p_cache,
 	}
 }
 
-struct hpi_control_cache *hpi_alloc_control_cache(const u32
-	number_of_controls, const u32 size_in_bytes, u8 *pDSP_control_buffer)
+struct hpi_control_cache *hpi_alloc_control_cache(const u32 control_count,
+	const u32 size_in_bytes, u8 *p_dsp_control_buffer)
 {
 	struct hpi_control_cache *p_cache =
 		kmalloc(sizeof(*p_cache), GFP_KERNEL);
 	if (!p_cache)
 		return NULL;
+
 	p_cache->p_info =
-		kmalloc(sizeof(*p_cache->p_info) * number_of_controls,
-			GFP_KERNEL);
+		kmalloc(sizeof(*p_cache->p_info) * control_count, GFP_KERNEL);
 	if (!p_cache->p_info) {
 		kfree(p_cache);
 		return NULL;
 	}
+	memset(p_cache->p_info, 0, sizeof(*p_cache->p_info) * control_count);
 	p_cache->cache_size_in_bytes = size_in_bytes;
-	p_cache->control_count = number_of_controls;
-	p_cache->p_cache =
-		(struct hpi_control_cache_single *)pDSP_control_buffer;
+	p_cache->control_count = control_count;
+	p_cache->p_cache = p_dsp_control_buffer;
 	p_cache->init = 0;
 	return p_cache;
 }
@@ -638,8 +616,6 @@ void hpi_free_control_cache(struct hpi_control_cache *p_cache)
 {
 	if (p_cache) {
 		kfree(p_cache->p_info);
-		p_cache->p_info = NULL;
-		p_cache->init = 0;
 		kfree(p_cache);
 	}
 }

commit 1528fbb5dcb5089652147bc6b76aa1f15e50c078
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Thu Feb 10 17:26:02 2011 +1300

    ALSA: asihpi - Checkpatch line lengths etc.
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index 85c297279792..8346aeabee5d 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -46,17 +46,19 @@ static struct hpi_adapters_list adapters;
 u16 hpi_validate_response(struct hpi_message *phm, struct hpi_response *phr)
 {
 	if (phr->type != HPI_TYPE_RESPONSE) {
-		HPI_DEBUG_LOG(ERROR, "header type %d invalid", phr->type);
+		HPI_DEBUG_LOG(ERROR, "header type %d invalid\n", phr->type);
 		return HPI_ERROR_INVALID_RESPONSE;
 	}
 
 	if (phr->object != phm->object) {
-		HPI_DEBUG_LOG(ERROR, "header object %d invalid", phr->object);
+		HPI_DEBUG_LOG(ERROR, "header object %d invalid\n",
+			phr->object);
 		return HPI_ERROR_INVALID_RESPONSE;
 	}
 
 	if (phr->function != phm->function) {
-		HPI_DEBUG_LOG(ERROR, "header type %d invalid", phr->function);
+		HPI_DEBUG_LOG(ERROR, "header type %d invalid\n",
+			phr->function);
 		return HPI_ERROR_INVALID_RESPONSE;
 	}
 
@@ -114,7 +116,7 @@ struct hpi_adapter_obj *hpi_find_adapter(u16 adapter_index)
 	struct hpi_adapter_obj *pao = NULL;
 
 	if (adapter_index >= HPI_MAX_ADAPTERS) {
-		HPI_DEBUG_LOG(VERBOSE, "find_adapter invalid index %d ",
+		HPI_DEBUG_LOG(VERBOSE, "find_adapter invalid index %d\n",
 			adapter_index);
 		return NULL;
 	}
@@ -203,9 +205,10 @@ static unsigned int control_cache_alloc_check(struct hpi_control_cache *pC)
 						pC->adap_idx);
 					return 0;
 				}
-				/* ? This is a severe error, the cache is probably
-				   corrupted.  Minimum valid entry size is
-				   sizeof(struct hpi_control_cache_info) */
+				/* The cache is invalid.
+				 * Minimum valid entry size is
+				 * sizeof(struct hpi_control_cache_info)
+				 */
 				HPI_DEBUG_LOG(ERROR,
 					"adap %d zero size cache entry %d\n",
 					pC->adap_idx, i);
@@ -226,9 +229,10 @@ static unsigned int control_cache_alloc_check(struct hpi_control_cache *pC)
 				info->control_index, info->control_type,
 				info->size_in32bit_words);
 
-			/* quit loop early if whole cache has been scanned. */
-			/* pC->dwControlCount is the maximum possible entries, */
-			/* but some may not be in the cache at all */
+			/* quit loop early if whole cache has been scanned.
+			 * dwControlCount is the maximum possible entries
+			 * but some may be absent from the cache
+			 */
 			if (byte_count >= pC->cache_size_in_bytes)
 				break;
 			/* have seen last control index */
@@ -238,15 +242,15 @@ static unsigned int control_cache_alloc_check(struct hpi_control_cache *pC)
 
 		if (byte_count != pC->cache_size_in_bytes)
 			HPI_DEBUG_LOG(WARNING,
-				"adap %d bytecount %d != cache size %d",
+				"adap %d bytecount %d != cache size %d\n",
 				pC->adap_idx, byte_count,
 				pC->cache_size_in_bytes);
 		else
 			HPI_DEBUG_LOG(DEBUG,
-				"adap %d cache good, bytecount == cache size = %d",
+				"adap %d cache good, bytecount == cache size = %d\n",
 				pC->adap_idx, byte_count);
 
-		pC->init = cached;
+		pC->init = (u16)cached;
 	}
 	return pC->init;
 }
@@ -430,7 +434,6 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 	case HPI_CONTROL_SILENCEDETECTOR:
 		if (phm->u.c.attribute == HPI_SILENCEDETECTOR_STATE) {
 			phr->u.c.param1 = pC->u.silence.state;
-			/*? phr->u.c.dwParam2 = pC->u.silence.dwCount; */
 		} else
 			found = 0;
 		break;

commit ffdb57874643a8ad65a46a02dceb2211283816c2
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Thu Feb 10 17:26:00 2011 +1300

    ALSA: asihpi - Add adapter index to cache info for debug.
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index 793236ef0a54..85c297279792 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -197,11 +197,18 @@ static unsigned int control_cache_alloc_check(struct hpi_control_cache *pC)
 				&p_master_cache[byte_count];
 
 			if (!info->size_in32bit_words) {
+				if (i == 0) {
+					HPI_DEBUG_LOG(INFO,
+						"adap %d cache not ready?\n",
+						pC->adap_idx);
+					return 0;
+				}
 				/* ? This is a severe error, the cache is probably
 				   corrupted.  Minimum valid entry size is
 				   sizeof(struct hpi_control_cache_info) */
 				HPI_DEBUG_LOG(ERROR,
-					"zero size cache entry %d\n", i);
+					"adap %d zero size cache entry %d\n",
+					pC->adap_idx, i);
 				break;
 			}
 
@@ -231,12 +238,13 @@ static unsigned int control_cache_alloc_check(struct hpi_control_cache *pC)
 
 		if (byte_count != pC->cache_size_in_bytes)
 			HPI_DEBUG_LOG(WARNING,
-				"bytecount %d != cache size %d", byte_count,
+				"adap %d bytecount %d != cache size %d",
+				pC->adap_idx, byte_count,
 				pC->cache_size_in_bytes);
 		else
 			HPI_DEBUG_LOG(DEBUG,
-				"cache good. bytecount == cache size = %d",
-				byte_count);
+				"adap %d cache good, bytecount == cache size = %d",
+				pC->adap_idx, byte_count);
 
 		pC->init = cached;
 	}

commit 3285ea10e9b09d68da18d2f805980246ec53523a
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Thu Feb 10 17:25:58 2011 +1300

    ALSA: asihpi - Interrelated HPI tidy up.
    
    Remove many unused functions.
    Update some message and cache structs.
    Use pci info directly from pci_dev.
    Allow control cache elements with variable size, and handle
    large message/response from dsp.
    hpi6000 and hpi6205: fix error path when adapter bootload fails.
    hpimsgx.c get rid of code duplicated in hpicmn.c
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index d67f4d3db911..793236ef0a54 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -26,6 +26,8 @@
 
 #include "hpi_internal.h"
 #include "hpidebug.h"
+#include "hpimsginit.h"
+
 #include "hpicmn.h"
 
 struct hpi_adapters_list {
@@ -43,14 +45,22 @@ static struct hpi_adapters_list adapters;
 **/
 u16 hpi_validate_response(struct hpi_message *phm, struct hpi_response *phr)
 {
-	u16 error = 0;
+	if (phr->type != HPI_TYPE_RESPONSE) {
+		HPI_DEBUG_LOG(ERROR, "header type %d invalid", phr->type);
+		return HPI_ERROR_INVALID_RESPONSE;
+	}
+
+	if (phr->object != phm->object) {
+		HPI_DEBUG_LOG(ERROR, "header object %d invalid", phr->object);
+		return HPI_ERROR_INVALID_RESPONSE;
+	}
 
-	if ((phr->type != HPI_TYPE_RESPONSE)
-		|| (phr->object != phm->object)
-		|| (phr->function != phm->function))
-		error = HPI_ERROR_INVALID_RESPONSE;
+	if (phr->function != phm->function) {
+		HPI_DEBUG_LOG(ERROR, "header type %d invalid", phr->function);
+		return HPI_ERROR_INVALID_RESPONSE;
+	}
 
-	return error;
+	return 0;
 }
 
 u16 hpi_add_adapter(struct hpi_adapter_obj *pao)
@@ -76,17 +86,22 @@ u16 hpi_add_adapter(struct hpi_adapter_obj *pao)
 	adapters.gw_num_adapters++;
 
 unlock:
-	hpios_alistlock_un_lock(&adapters);
+	hpios_alistlock_unlock(&adapters);
 	return retval;
 }
 
 void hpi_delete_adapter(struct hpi_adapter_obj *pao)
 {
-	memset(pao, 0, sizeof(struct hpi_adapter_obj));
+	if (!pao->adapter_type) {
+		HPI_DEBUG_LOG(ERROR, "removing null adapter?\n");
+		return;
+	}
 
 	hpios_alistlock_lock(&adapters);
-	adapters.gw_num_adapters--;	/* dec the number of adapters */
-	hpios_alistlock_un_lock(&adapters);
+	if (adapters.adapter[pao->index].adapter_type)
+		adapters.gw_num_adapters--;
+	memset(&adapters.adapter[pao->index], 0, sizeof(adapters.adapter[0]));
+	hpios_alistlock_unlock(&adapters);
 }
 
 /**
@@ -125,51 +140,35 @@ struct hpi_adapter_obj *hpi_find_adapter(u16 adapter_index)
 * wipe an HPI_ADAPTERS_LIST structure.
 *
 **/
-static void wipe_adapter_list(void
-	)
+static void wipe_adapter_list(void)
 {
 	memset(&adapters, 0, sizeof(adapters));
 }
 
-/**
-* SubSysGetAdapters fills awAdapterList in an struct hpi_response structure
-* with all adapters in the given HPI_ADAPTERS_LIST.
-*
-*/
-static void subsys_get_adapters(struct hpi_response *phr)
+static void subsys_get_adapter(struct hpi_message *phm,
+	struct hpi_response *phr)
 {
-	/* fill in the response adapter array with the position */
-	/* identified by the adapter number/index of the adapters in */
-	/* this HPI */
-	/* i.e. if we have an A120 with it's jumper set to */
-	/* Adapter Number 2 then put an Adapter type A120 in the */
-	/* array in position 1 */
-	/* NOTE: AdapterNumber is 1..N, Index is 0..N-1 */
-
-	/* input:  NONE */
-	/* output: wNumAdapters */
-	/*                 awAdapter[] */
-	/* */
-
-	short i;
-	struct hpi_adapter_obj *pao = NULL;
+	int count = phm->obj_index;
+	u16 index = 0;
 
-	HPI_DEBUG_LOG(VERBOSE, "subsys_get_adapters\n");
-
-	/* for each adapter, place it's type in the position of the array */
-	/* corresponding to it's adapter number */
-	for (i = 0; i < adapters.gw_num_adapters; i++) {
-		pao = &adapters.adapter[i];
-		if (phr->u.s.aw_adapter_list[pao->index] != 0) {
-			phr->error = HPI_DUPLICATE_ADAPTER_NUMBER;
-			phr->specific_error = pao->index;
-			return;
+	/* find the nCount'th nonzero adapter in array */
+	for (index = 0; index < HPI_MAX_ADAPTERS; index++) {
+		if (adapters.adapter[index].adapter_type) {
+			if (count == 0)
+				break;
+			count--;
 		}
-		phr->u.s.aw_adapter_list[pao->index] = pao->adapter_type;
 	}
 
-	phr->u.s.num_adapters = adapters.gw_num_adapters;
-	phr->error = 0;	/* the function completed OK; */
+	if (index < HPI_MAX_ADAPTERS) {
+		phr->u.s.adapter_index = adapters.adapter[index].index;
+		phr->u.s.aw_adapter_list[0] =
+			adapters.adapter[index].adapter_type;
+	} else {
+		phr->u.s.adapter_index = 0;
+		phr->u.s.aw_adapter_list[0] = 0;
+		phr->error = HPI_ERROR_BAD_ADAPTER_NUMBER;
+	}
 }
 
 static unsigned int control_cache_alloc_check(struct hpi_control_cache *pC)
@@ -178,67 +177,88 @@ static unsigned int control_cache_alloc_check(struct hpi_control_cache *pC)
 	int cached = 0;
 	if (!pC)
 		return 0;
-	if ((!pC->init) && (pC->p_cache != NULL) && (pC->control_count)
-		&& (pC->cache_size_in_bytes)
-		) {
-		u32 *p_master_cache;
-		pC->init = 1;
 
-		p_master_cache = (u32 *)pC->p_cache;
-		HPI_DEBUG_LOG(VERBOSE, "check %d controls\n",
+	if (pC->init)
+		return pC->init;
+
+	if (!pC->p_cache)
+		return 0;
+
+	if (pC->control_count && pC->cache_size_in_bytes) {
+		char *p_master_cache;
+		unsigned int byte_count = 0;
+
+		p_master_cache = (char *)pC->p_cache;
+		HPI_DEBUG_LOG(DEBUG, "check %d controls\n",
 			pC->control_count);
 		for (i = 0; i < pC->control_count; i++) {
 			struct hpi_control_cache_info *info =
 				(struct hpi_control_cache_info *)
-				p_master_cache;
+				&p_master_cache[byte_count];
+
+			if (!info->size_in32bit_words) {
+				/* ? This is a severe error, the cache is probably
+				   corrupted.  Minimum valid entry size is
+				   sizeof(struct hpi_control_cache_info) */
+				HPI_DEBUG_LOG(ERROR,
+					"zero size cache entry %d\n", i);
+				break;
+			}
 
 			if (info->control_type) {
-				pC->p_info[i] = info;
+				pC->p_info[info->control_index] = info;
 				cached++;
-			} else
-				pC->p_info[i] = NULL;
+			} else	/* dummy cache entry */
+				pC->p_info[info->control_index] = NULL;
 
-			if (info->size_in32bit_words)
-				p_master_cache += info->size_in32bit_words;
-			else
-				p_master_cache +=
-					sizeof(struct
-					hpi_control_cache_single) /
-					sizeof(u32);
+			byte_count += info->size_in32bit_words * 4;
 
 			HPI_DEBUG_LOG(VERBOSE,
-				"cached %d, pinfo %p index %d type %d\n",
-				cached, pC->p_info[i], info->control_index,
-				info->control_type);
+				"cached %d, pinfo %p index %d type %d size %d\n",
+				cached, pC->p_info[info->control_index],
+				info->control_index, info->control_type,
+				info->size_in32bit_words);
+
+			/* quit loop early if whole cache has been scanned. */
+			/* pC->dwControlCount is the maximum possible entries, */
+			/* but some may not be in the cache at all */
+			if (byte_count >= pC->cache_size_in_bytes)
+				break;
+			/* have seen last control index */
+			if (info->control_index == pC->control_count - 1)
+				break;
 		}
-		/*
-		   We didn't find anything to cache, so try again later !
-		 */
-		if (!cached)
-			pC->init = 0;
+
+		if (byte_count != pC->cache_size_in_bytes)
+			HPI_DEBUG_LOG(WARNING,
+				"bytecount %d != cache size %d", byte_count,
+				pC->cache_size_in_bytes);
+		else
+			HPI_DEBUG_LOG(DEBUG,
+				"cache good. bytecount == cache size = %d",
+				byte_count);
+
+		pC->init = cached;
 	}
 	return pC->init;
 }
 
 /** Find a control.
 */
-static short find_control(struct hpi_message *phm,
-	struct hpi_control_cache *p_cache, struct hpi_control_cache_info **pI,
-	u16 *pw_control_index)
+static short find_control(u16 control_index,
+	struct hpi_control_cache *p_cache, struct hpi_control_cache_info **pI)
 {
-	*pw_control_index = phm->obj_index;
-
 	if (!control_cache_alloc_check(p_cache)) {
 		HPI_DEBUG_LOG(VERBOSE,
-			"control_cache_alloc_check() failed. adap%d ci%d\n",
-			phm->adapter_index, *pw_control_index);
+			"control_cache_alloc_check() failed %d\n",
+			control_index);
 		return 0;
 	}
 
-	*pI = p_cache->p_info[*pw_control_index];
+	*pI = p_cache->p_info[control_index];
 	if (!*pI) {
-		HPI_DEBUG_LOG(VERBOSE, "uncached adap %d, control %d\n",
-			phm->adapter_index, *pw_control_index);
+		HPI_DEBUG_LOG(VERBOSE, "Uncached Control %d\n",
+			control_index);
 		return 0;
 	} else {
 		HPI_DEBUG_LOG(VERBOSE, "find_control() type %d\n",
@@ -257,11 +277,14 @@ short hpi_check_buffer_mapping(struct hpi_control_cache *p_cache,
 	if ((phm->function == HPI_CONTROL_GET_STATE)
 		&& (phm->object == HPI_OBJ_CONTROLEX)
 		) {
-		u16 control_index;
 		struct hpi_control_cache_info *pI;
 
-		if (!find_control(phm, p_cache, &pI, &control_index))
+		if (!find_control(phm->obj_index, p_cache, &pI)) {
+			HPI_DEBUG_LOG(VERBOSE,
+				"HPICMN find_control() failed for adap %d\n",
+				phm->adapter_index);
 			return 0;
+		}
 	}
 	return 0;
 }
@@ -290,13 +313,16 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 	struct hpi_message *phm, struct hpi_response *phr)
 {
 	short found = 1;
-	u16 control_index;
 	struct hpi_control_cache_info *pI;
 	struct hpi_control_cache_single *pC;
 	struct hpi_control_cache_pad *p_pad;
 
-	if (!find_control(phm, p_cache, &pI, &control_index))
+	if (!find_control(phm->obj_index, p_cache, &pI)) {
+		HPI_DEBUG_LOG(VERBOSE,
+			"HPICMN find_control() failed for adap %d\n",
+			phm->adapter_index);
 		return 0;
+	}
 
 	phr->error = 0;
 
@@ -310,55 +336,66 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 
 	case HPI_CONTROL_METER:
 		if (phm->u.c.attribute == HPI_METER_PEAK) {
-			phr->u.c.an_log_value[0] = pC->u.p.an_log_peak[0];
-			phr->u.c.an_log_value[1] = pC->u.p.an_log_peak[1];
+			phr->u.c.an_log_value[0] = pC->u.meter.an_log_peak[0];
+			phr->u.c.an_log_value[1] = pC->u.meter.an_log_peak[1];
 		} else if (phm->u.c.attribute == HPI_METER_RMS) {
-			phr->u.c.an_log_value[0] = pC->u.p.an_logRMS[0];
-			phr->u.c.an_log_value[1] = pC->u.p.an_logRMS[1];
+			if (pC->u.meter.an_logRMS[0] ==
+				HPI_CACHE_INVALID_SHORT) {
+				phr->error =
+					HPI_ERROR_INVALID_CONTROL_ATTRIBUTE;
+				phr->u.c.an_log_value[0] = HPI_METER_MINIMUM;
+				phr->u.c.an_log_value[1] = HPI_METER_MINIMUM;
+			} else {
+				phr->u.c.an_log_value[0] =
+					pC->u.meter.an_logRMS[0];
+				phr->u.c.an_log_value[1] =
+					pC->u.meter.an_logRMS[1];
+			}
 		} else
 			found = 0;
 		break;
 	case HPI_CONTROL_VOLUME:
 		if (phm->u.c.attribute == HPI_VOLUME_GAIN) {
-			phr->u.c.an_log_value[0] = pC->u.v.an_log[0];
-			phr->u.c.an_log_value[1] = pC->u.v.an_log[1];
+			phr->u.c.an_log_value[0] = pC->u.vol.an_log[0];
+			phr->u.c.an_log_value[1] = pC->u.vol.an_log[1];
 		} else
 			found = 0;
 		break;
 	case HPI_CONTROL_MULTIPLEXER:
 		if (phm->u.c.attribute == HPI_MULTIPLEXER_SOURCE) {
-			phr->u.c.param1 = pC->u.x.source_node_type;
-			phr->u.c.param2 = pC->u.x.source_node_index;
+			phr->u.c.param1 = pC->u.mux.source_node_type;
+			phr->u.c.param2 = pC->u.mux.source_node_index;
 		} else {
 			found = 0;
 		}
 		break;
 	case HPI_CONTROL_CHANNEL_MODE:
 		if (phm->u.c.attribute == HPI_CHANNEL_MODE_MODE)
-			phr->u.c.param1 = pC->u.m.mode;
+			phr->u.c.param1 = pC->u.mode.mode;
 		else
 			found = 0;
 		break;
 	case HPI_CONTROL_LEVEL:
 		if (phm->u.c.attribute == HPI_LEVEL_GAIN) {
-			phr->u.c.an_log_value[0] = pC->u.l.an_log[0];
-			phr->u.c.an_log_value[1] = pC->u.l.an_log[1];
+			phr->u.c.an_log_value[0] = pC->u.level.an_log[0];
+			phr->u.c.an_log_value[1] = pC->u.level.an_log[1];
 		} else
 			found = 0;
 		break;
 	case HPI_CONTROL_TUNER:
 		if (phm->u.c.attribute == HPI_TUNER_FREQ)
-			phr->u.c.param1 = pC->u.t.freq_ink_hz;
+			phr->u.c.param1 = pC->u.tuner.freq_ink_hz;
 		else if (phm->u.c.attribute == HPI_TUNER_BAND)
-			phr->u.c.param1 = pC->u.t.band;
-		else if ((phm->u.c.attribute == HPI_TUNER_LEVEL)
-			&& (phm->u.c.param1 == HPI_TUNER_LEVEL_AVERAGE))
-			if (pC->u.t.level == HPI_ERROR_ILLEGAL_CACHE_VALUE) {
-				phr->u.c.param1 = 0;
+			phr->u.c.param1 = pC->u.tuner.band;
+		else if (phm->u.c.attribute == HPI_TUNER_LEVEL_AVG)
+			if (pC->u.tuner.s_level_avg ==
+				HPI_CACHE_INVALID_SHORT) {
+				phr->u.cu.tuner.s_level = 0;
 				phr->error =
 					HPI_ERROR_INVALID_CONTROL_ATTRIBUTE;
 			} else
-				phr->u.c.param1 = pC->u.t.level;
+				phr->u.cu.tuner.s_level =
+					pC->u.tuner.s_level_avg;
 		else
 			found = 0;
 		break;
@@ -366,7 +403,7 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 		if (phm->u.c.attribute == HPI_AESEBURX_ERRORSTATUS)
 			phr->u.c.param1 = pC->u.aes3rx.error_status;
 		else if (phm->u.c.attribute == HPI_AESEBURX_FORMAT)
-			phr->u.c.param1 = pC->u.aes3rx.source;
+			phr->u.c.param1 = pC->u.aes3rx.format;
 		else
 			found = 0;
 		break;
@@ -385,13 +422,13 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 	case HPI_CONTROL_SILENCEDETECTOR:
 		if (phm->u.c.attribute == HPI_SILENCEDETECTOR_STATE) {
 			phr->u.c.param1 = pC->u.silence.state;
-			phr->u.c.param2 = pC->u.silence.count;
+			/*? phr->u.c.dwParam2 = pC->u.silence.dwCount; */
 		} else
 			found = 0;
 		break;
 	case HPI_CONTROL_MICROPHONE:
 		if (phm->u.c.attribute == HPI_MICROPHONE_PHANTOM_POWER)
-			phr->u.c.param1 = pC->u.phantom_power.state;
+			phr->u.c.param1 = pC->u.microphone.phantom_state;
 		else
 			found = 0;
 		break;
@@ -400,7 +437,7 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 			phr->u.c.param1 = pC->u.clk.source;
 		else if (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE_INDEX) {
 			if (pC->u.clk.source_index ==
-				HPI_ERROR_ILLEGAL_CACHE_VALUE) {
+				HPI_CACHE_INVALID_UINT16) {
 				phr->u.c.param1 = 0;
 				phr->error =
 					HPI_ERROR_INVALID_CONTROL_ATTRIBUTE;
@@ -411,60 +448,63 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 		else
 			found = 0;
 		break;
-	case HPI_CONTROL_PAD:
-
-		if (!(p_pad->field_valid_flags & (1 <<
-					HPI_CTL_ATTR_INDEX(phm->u.c.
-						attribute)))) {
-			phr->error = HPI_ERROR_INVALID_CONTROL_ATTRIBUTE;
-			break;
-		}
+	case HPI_CONTROL_PAD:{
+			struct hpi_control_cache_pad *p_pad;
+			p_pad = (struct hpi_control_cache_pad *)pI;
 
-		if (phm->u.c.attribute == HPI_PAD_PROGRAM_ID)
-			phr->u.c.param1 = p_pad->pI;
-		else if (phm->u.c.attribute == HPI_PAD_PROGRAM_TYPE)
-			phr->u.c.param1 = p_pad->pTY;
-		else {
-			unsigned int index =
-				HPI_CTL_ATTR_INDEX(phm->u.c.attribute) - 1;
-			unsigned int offset = phm->u.c.param1;
-			unsigned int pad_string_len, field_size;
-			char *pad_string;
-			unsigned int tocopy;
-
-			HPI_DEBUG_LOG(VERBOSE, "PADS HPI_PADS_ %d\n",
-				phm->u.c.attribute);
-
-			if (index > ARRAY_SIZE(pad_desc) - 1) {
+			if (!(p_pad->field_valid_flags & (1 <<
+						HPI_CTL_ATTR_INDEX(phm->u.c.
+							attribute)))) {
 				phr->error =
 					HPI_ERROR_INVALID_CONTROL_ATTRIBUTE;
 				break;
 			}
 
-			pad_string = ((char *)p_pad) + pad_desc[index].offset;
-			field_size = pad_desc[index].field_size;
-			/* Ensure null terminator */
-			pad_string[field_size - 1] = 0;
-
-			pad_string_len = strlen(pad_string) + 1;
-
-			if (offset > pad_string_len) {
-				phr->error = HPI_ERROR_INVALID_CONTROL_VALUE;
-				break;
+			if (phm->u.c.attribute == HPI_PAD_PROGRAM_ID)
+				phr->u.c.param1 = p_pad->pI;
+			else if (phm->u.c.attribute == HPI_PAD_PROGRAM_TYPE)
+				phr->u.c.param1 = p_pad->pTY;
+			else {
+				unsigned int index =
+					HPI_CTL_ATTR_INDEX(phm->u.c.
+					attribute) - 1;
+				unsigned int offset = phm->u.c.param1;
+				unsigned int pad_string_len, field_size;
+				char *pad_string;
+				unsigned int tocopy;
+
+				if (index > ARRAY_SIZE(pad_desc) - 1) {
+					phr->error =
+						HPI_ERROR_INVALID_CONTROL_ATTRIBUTE;
+					break;
+				}
+
+				pad_string =
+					((char *)p_pad) +
+					pad_desc[index].offset;
+				field_size = pad_desc[index].field_size;
+				/* Ensure null terminator */
+				pad_string[field_size - 1] = 0;
+
+				pad_string_len = strlen(pad_string) + 1;
+
+				if (offset > pad_string_len) {
+					phr->error =
+						HPI_ERROR_INVALID_CONTROL_VALUE;
+					break;
+				}
+
+				tocopy = pad_string_len - offset;
+				if (tocopy > sizeof(phr->u.cu.chars8.sz_data))
+					tocopy = sizeof(phr->u.cu.chars8.
+						sz_data);
+
+				memcpy(phr->u.cu.chars8.sz_data,
+					&pad_string[offset], tocopy);
+
+				phr->u.cu.chars8.remaining_chars =
+					pad_string_len - offset - tocopy;
 			}
-
-			tocopy = pad_string_len - offset;
-			if (tocopy > sizeof(phr->u.cu.chars8.sz_data))
-				tocopy = sizeof(phr->u.cu.chars8.sz_data);
-
-			HPI_DEBUG_LOG(VERBOSE,
-				"PADS memcpy(%d), offset %d \n", tocopy,
-				offset);
-			memcpy(phr->u.cu.chars8.sz_data, &pad_string[offset],
-				tocopy);
-
-			phr->u.cu.chars8.remaining_chars =
-				pad_string_len - offset - tocopy;
 		}
 		break;
 	default:
@@ -472,16 +512,9 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 		break;
 	}
 
-	if (found)
-		HPI_DEBUG_LOG(VERBOSE,
-			"cached adap %d, ctl %d, type %d, attr %d\n",
-			phm->adapter_index, pI->control_index,
-			pI->control_type, phm->u.c.attribute);
-	else
-		HPI_DEBUG_LOG(VERBOSE,
-			"uncached adap %d, ctl %d, ctl type %d\n",
-			phm->adapter_index, pI->control_index,
-			pI->control_type);
+	HPI_DEBUG_LOG(VERBOSE, "%s Adap %d, Ctl %d, Type %d, Attr %d\n",
+		found ? "Cached" : "Uncached", phm->adapter_index,
+		pI->control_index, pI->control_type, phm->u.c.attribute);
 
 	if (found)
 		phr->size =
@@ -497,18 +530,21 @@ Only update if no error.
 Volume and Level return the limited values in the response, so use these
 Multiplexer does so use sent values
 */
-void hpi_sync_control_cache(struct hpi_control_cache *p_cache,
+void hpi_cmn_control_cache_sync_to_msg(struct hpi_control_cache *p_cache,
 	struct hpi_message *phm, struct hpi_response *phr)
 {
-	u16 control_index;
 	struct hpi_control_cache_single *pC;
 	struct hpi_control_cache_info *pI;
 
 	if (phr->error)
 		return;
 
-	if (!find_control(phm, p_cache, &pI, &control_index))
+	if (!find_control(phm->obj_index, p_cache, &pI)) {
+		HPI_DEBUG_LOG(VERBOSE,
+			"HPICMN find_control() failed for adap %d\n",
+			phm->adapter_index);
 		return;
+	}
 
 	/* pC is the default cached control strucure.
 	   May be cast to something else in the following switch statement.
@@ -518,31 +554,31 @@ void hpi_sync_control_cache(struct hpi_control_cache *p_cache,
 	switch (pI->control_type) {
 	case HPI_CONTROL_VOLUME:
 		if (phm->u.c.attribute == HPI_VOLUME_GAIN) {
-			pC->u.v.an_log[0] = phr->u.c.an_log_value[0];
-			pC->u.v.an_log[1] = phr->u.c.an_log_value[1];
+			pC->u.vol.an_log[0] = phr->u.c.an_log_value[0];
+			pC->u.vol.an_log[1] = phr->u.c.an_log_value[1];
 		}
 		break;
 	case HPI_CONTROL_MULTIPLEXER:
 		/* mux does not return its setting on Set command. */
 		if (phm->u.c.attribute == HPI_MULTIPLEXER_SOURCE) {
-			pC->u.x.source_node_type = (u16)phm->u.c.param1;
-			pC->u.x.source_node_index = (u16)phm->u.c.param2;
+			pC->u.mux.source_node_type = (u16)phm->u.c.param1;
+			pC->u.mux.source_node_index = (u16)phm->u.c.param2;
 		}
 		break;
 	case HPI_CONTROL_CHANNEL_MODE:
 		/* mode does not return its setting on Set command. */
 		if (phm->u.c.attribute == HPI_CHANNEL_MODE_MODE)
-			pC->u.m.mode = (u16)phm->u.c.param1;
+			pC->u.mode.mode = (u16)phm->u.c.param1;
 		break;
 	case HPI_CONTROL_LEVEL:
 		if (phm->u.c.attribute == HPI_LEVEL_GAIN) {
-			pC->u.v.an_log[0] = phr->u.c.an_log_value[0];
-			pC->u.v.an_log[1] = phr->u.c.an_log_value[1];
+			pC->u.vol.an_log[0] = phr->u.c.an_log_value[0];
+			pC->u.vol.an_log[1] = phr->u.c.an_log_value[1];
 		}
 		break;
 	case HPI_CONTROL_MICROPHONE:
 		if (phm->u.c.attribute == HPI_MICROPHONE_PHANTOM_POWER)
-			pC->u.phantom_power.state = (u16)phm->u.c.param1;
+			pC->u.microphone.phantom_state = (u16)phm->u.c.param1;
 		break;
 	case HPI_CONTROL_AESEBU_TRANSMITTER:
 		if (phm->u.c.attribute == HPI_AESEBUTX_FORMAT)
@@ -550,7 +586,7 @@ void hpi_sync_control_cache(struct hpi_control_cache *p_cache,
 		break;
 	case HPI_CONTROL_AESEBU_RECEIVER:
 		if (phm->u.c.attribute == HPI_AESEBURX_FORMAT)
-			pC->u.aes3rx.source = phm->u.c.param1;
+			pC->u.aes3rx.format = phm->u.c.param1;
 		break;
 	case HPI_CONTROL_SAMPLECLOCK:
 		if (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE)
@@ -566,8 +602,7 @@ void hpi_sync_control_cache(struct hpi_control_cache *p_cache,
 }
 
 struct hpi_control_cache *hpi_alloc_control_cache(const u32
-	number_of_controls, const u32 size_in_bytes,
-	struct hpi_control_cache_info *pDSP_control_buffer)
+	number_of_controls, const u32 size_in_bytes, u8 *pDSP_control_buffer)
 {
 	struct hpi_control_cache *p_cache =
 		kmalloc(sizeof(*p_cache), GFP_KERNEL);
@@ -590,7 +625,7 @@ struct hpi_control_cache *hpi_alloc_control_cache(const u32
 
 void hpi_free_control_cache(struct hpi_control_cache *p_cache)
 {
-	if (p_cache->init) {
+	if (p_cache) {
 		kfree(p_cache->p_info);
 		p_cache->p_info = NULL;
 		p_cache->init = 0;
@@ -600,24 +635,25 @@ void hpi_free_control_cache(struct hpi_control_cache *p_cache)
 
 static void subsys_message(struct hpi_message *phm, struct hpi_response *phr)
 {
+	hpi_init_response(phr, HPI_OBJ_SUBSYSTEM, phm->function, 0);
 
 	switch (phm->function) {
 	case HPI_SUBSYS_OPEN:
 	case HPI_SUBSYS_CLOSE:
 	case HPI_SUBSYS_DRIVER_UNLOAD:
-		phr->error = 0;
 		break;
 	case HPI_SUBSYS_DRIVER_LOAD:
 		wipe_adapter_list();
 		hpios_alistlock_init(&adapters);
-		phr->error = 0;
 		break;
-	case HPI_SUBSYS_GET_INFO:
-		subsys_get_adapters(phr);
+	case HPI_SUBSYS_GET_ADAPTER:
+		subsys_get_adapter(phm, phr);
+		break;
+	case HPI_SUBSYS_GET_NUM_ADAPTERS:
+		phr->u.s.num_adapters = adapters.gw_num_adapters;
 		break;
 	case HPI_SUBSYS_CREATE_ADAPTER:
 	case HPI_SUBSYS_DELETE_ADAPTER:
-		phr->error = 0;
 		break;
 	default:
 		phr->error = HPI_ERROR_INVALID_FUNC;

commit fd0977d0f42d3e73121b88f57c7d48ca9b861a58
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Fri Oct 29 21:35:25 2010 +0200

    ALSA: asihpi - Unsafe memory management when allocating control cache
    
    I noticed that sound/pci/asihpi/hpicmn.c::hpi_alloc_control_cache() does
    not check the return value from kmalloc(), which may fail.
    If kmalloc() fails we'll dereference a null pointer and things will go bad
    fast.
    There are two memory allocations in that function and there's also the
    problem that the first may succeed and the second may fail and nothing is
    done about that either which will also go wrong down the line.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Acked-by: Eliot Blennerhassett <linux@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index dda4f1c6f658..d67f4d3db911 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -571,14 +571,20 @@ struct hpi_control_cache *hpi_alloc_control_cache(const u32
 {
 	struct hpi_control_cache *p_cache =
 		kmalloc(sizeof(*p_cache), GFP_KERNEL);
+	if (!p_cache)
+		return NULL;
+	p_cache->p_info =
+		kmalloc(sizeof(*p_cache->p_info) * number_of_controls,
+			GFP_KERNEL);
+	if (!p_cache->p_info) {
+		kfree(p_cache);
+		return NULL;
+	}
 	p_cache->cache_size_in_bytes = size_in_bytes;
 	p_cache->control_count = number_of_controls;
 	p_cache->p_cache =
 		(struct hpi_control_cache_single *)pDSP_control_buffer;
 	p_cache->init = 0;
-	p_cache->p_info =
-		kmalloc(sizeof(*p_cache->p_info) * p_cache->control_count,
-		GFP_KERNEL);
 	return p_cache;
 }
 

commit 36ed8bdd867314660b8dca2d1b6d9e92352b319b
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Tue Jul 6 08:37:10 2010 +1200

    ALSA: asihpi - Minor HPI error handling fixes
    
    Handle errors in tuner level caching,
    Ccorrect error code for aesebu rx status.
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index fcd64539d9ef..dda4f1c6f658 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -353,7 +353,12 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 			phr->u.c.param1 = pC->u.t.band;
 		else if ((phm->u.c.attribute == HPI_TUNER_LEVEL)
 			&& (phm->u.c.param1 == HPI_TUNER_LEVEL_AVERAGE))
-			phr->u.c.param1 = pC->u.t.level;
+			if (pC->u.t.level == HPI_ERROR_ILLEGAL_CACHE_VALUE) {
+				phr->u.c.param1 = 0;
+				phr->error =
+					HPI_ERROR_INVALID_CONTROL_ATTRIBUTE;
+			} else
+				phr->u.c.param1 = pC->u.t.level;
 		else
 			found = 0;
 		break;
@@ -397,7 +402,8 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 			if (pC->u.clk.source_index ==
 				HPI_ERROR_ILLEGAL_CACHE_VALUE) {
 				phr->u.c.param1 = 0;
-				phr->error = HPI_ERROR_INVALID_OPERATION;
+				phr->error =
+					HPI_ERROR_INVALID_CONTROL_ATTRIBUTE;
 			} else
 				phr->u.c.param1 = pC->u.clk.source_index;
 		} else if (phm->u.c.attribute == HPI_SAMPLECLOCK_SAMPLERATE)

commit 3ee317fe9cf08d81501b142bf0054c25e3ed5e7d
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Thu May 27 17:53:55 2010 +1200

    ALSA: asihpi - Minor code cleanup
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
index 565102cae4f8..fcd64539d9ef 100644
--- a/sound/pci/asihpi/hpicmn.c
+++ b/sound/pci/asihpi/hpicmn.c
@@ -347,20 +347,15 @@ short hpi_check_control_cache(struct hpi_control_cache *p_cache,
 			found = 0;
 		break;
 	case HPI_CONTROL_TUNER:
-		{
-			struct hpi_control_cache_single *pCT =
-				(struct hpi_control_cache_single *)pI;
-			if (phm->u.c.attribute == HPI_TUNER_FREQ)
-				phr->u.c.param1 = pCT->u.t.freq_ink_hz;
-			else if (phm->u.c.attribute == HPI_TUNER_BAND)
-				phr->u.c.param1 = pCT->u.t.band;
-			else if ((phm->u.c.attribute == HPI_TUNER_LEVEL)
-				&& (phm->u.c.param1 ==
-					HPI_TUNER_LEVEL_AVERAGE))
-				phr->u.c.param1 = pCT->u.t.level;
-			else
-				found = 0;
-		}
+		if (phm->u.c.attribute == HPI_TUNER_FREQ)
+			phr->u.c.param1 = pC->u.t.freq_ink_hz;
+		else if (phm->u.c.attribute == HPI_TUNER_BAND)
+			phr->u.c.param1 = pC->u.t.band;
+		else if ((phm->u.c.attribute == HPI_TUNER_LEVEL)
+			&& (phm->u.c.param1 == HPI_TUNER_LEVEL_AVERAGE))
+			phr->u.c.param1 = pC->u.t.level;
+		else
+			found = 0;
 		break;
 	case HPI_CONTROL_AESEBU_RECEIVER:
 		if (phm->u.c.attribute == HPI_AESEBURX_ERRORSTATUS)
@@ -503,6 +498,9 @@ void hpi_sync_control_cache(struct hpi_control_cache *p_cache,
 	struct hpi_control_cache_single *pC;
 	struct hpi_control_cache_info *pI;
 
+	if (phr->error)
+		return;
+
 	if (!find_control(phm, p_cache, &pI, &control_index))
 		return;
 
@@ -520,8 +518,6 @@ void hpi_sync_control_cache(struct hpi_control_cache *p_cache,
 		break;
 	case HPI_CONTROL_MULTIPLEXER:
 		/* mux does not return its setting on Set command. */
-		if (phr->error)
-			return;
 		if (phm->u.c.attribute == HPI_MULTIPLEXER_SOURCE) {
 			pC->u.x.source_node_type = (u16)phm->u.c.param1;
 			pC->u.x.source_node_index = (u16)phm->u.c.param2;
@@ -529,8 +525,6 @@ void hpi_sync_control_cache(struct hpi_control_cache *p_cache,
 		break;
 	case HPI_CONTROL_CHANNEL_MODE:
 		/* mode does not return its setting on Set command. */
-		if (phr->error)
-			return;
 		if (phm->u.c.attribute == HPI_CHANNEL_MODE_MODE)
 			pC->u.m.mode = (u16)phm->u.c.param1;
 		break;
@@ -545,20 +539,14 @@ void hpi_sync_control_cache(struct hpi_control_cache *p_cache,
 			pC->u.phantom_power.state = (u16)phm->u.c.param1;
 		break;
 	case HPI_CONTROL_AESEBU_TRANSMITTER:
-		if (phr->error)
-			return;
 		if (phm->u.c.attribute == HPI_AESEBUTX_FORMAT)
 			pC->u.aes3tx.format = phm->u.c.param1;
 		break;
 	case HPI_CONTROL_AESEBU_RECEIVER:
-		if (phr->error)
-			return;
 		if (phm->u.c.attribute == HPI_AESEBURX_FORMAT)
 			pC->u.aes3rx.source = phm->u.c.param1;
 		break;
 	case HPI_CONTROL_SAMPLECLOCK:
-		if (phr->error)
-			return;
 		if (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE)
 			pC->u.clk.source = (u16)phm->u.c.param1;
 		else if (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE_INDEX)
@@ -590,7 +578,7 @@ struct hpi_control_cache *hpi_alloc_control_cache(const u32
 
 void hpi_free_control_cache(struct hpi_control_cache *p_cache)
 {
-	if ((p_cache->init) && (p_cache->p_info)) {
+	if (p_cache->init) {
 		kfree(p_cache->p_info);
 		p_cache->p_info = NULL;
 		p_cache->init = 0;

commit 719f82d3987aad4cc9f46d19c35f362672545cad
Author: Eliot Blennerhassett <eblennerhassett@audioscience.com>
Date:   Wed Apr 21 18:17:39 2010 +0200

    ALSA: Add support of AudioScience ASI boards
    
    Added the support of AudioScience ASI boards.
    The driver has been tested for years on alsa-driver external tree,
    now finally got merged to the kernel.
    
    Signed-off-by: Eliot Blennerhassett <eblennerhassett@audioscience.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/asihpi/hpicmn.c b/sound/pci/asihpi/hpicmn.c
new file mode 100644
index 000000000000..565102cae4f8
--- /dev/null
+++ b/sound/pci/asihpi/hpicmn.c
@@ -0,0 +1,643 @@
+/******************************************************************************
+
+    AudioScience HPI driver
+    Copyright (C) 1997-2010  AudioScience Inc. <support@audioscience.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of version 2 of the GNU General Public License as
+    published by the Free Software Foundation;
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+\file hpicmn.c
+
+ Common functions used by hpixxxx.c modules
+
+(C) Copyright AudioScience Inc. 1998-2003
+*******************************************************************************/
+#define SOURCEFILE_NAME "hpicmn.c"
+
+#include "hpi_internal.h"
+#include "hpidebug.h"
+#include "hpicmn.h"
+
+struct hpi_adapters_list {
+	struct hpios_spinlock list_lock;
+	struct hpi_adapter_obj adapter[HPI_MAX_ADAPTERS];
+	u16 gw_num_adapters;
+};
+
+static struct hpi_adapters_list adapters;
+
+/**
+* Given an HPI Message that was sent out and a response that was received,
+* validate that the response has the correct fields filled in,
+* i.e ObjectType, Function etc
+**/
+u16 hpi_validate_response(struct hpi_message *phm, struct hpi_response *phr)
+{
+	u16 error = 0;
+
+	if ((phr->type != HPI_TYPE_RESPONSE)
+		|| (phr->object != phm->object)
+		|| (phr->function != phm->function))
+		error = HPI_ERROR_INVALID_RESPONSE;
+
+	return error;
+}
+
+u16 hpi_add_adapter(struct hpi_adapter_obj *pao)
+{
+	u16 retval = 0;
+	/*HPI_ASSERT(pao->wAdapterType); */
+
+	hpios_alistlock_lock(&adapters);
+
+	if (pao->index >= HPI_MAX_ADAPTERS) {
+		retval = HPI_ERROR_BAD_ADAPTER_NUMBER;
+		goto unlock;
+	}
+
+	if (adapters.adapter[pao->index].adapter_type) {
+		{
+			retval = HPI_DUPLICATE_ADAPTER_NUMBER;
+			goto unlock;
+		}
+	}
+	adapters.adapter[pao->index] = *pao;
+	hpios_dsplock_init(&adapters.adapter[pao->index]);
+	adapters.gw_num_adapters++;
+
+unlock:
+	hpios_alistlock_un_lock(&adapters);
+	return retval;
+}
+
+void hpi_delete_adapter(struct hpi_adapter_obj *pao)
+{
+	memset(pao, 0, sizeof(struct hpi_adapter_obj));
+
+	hpios_alistlock_lock(&adapters);
+	adapters.gw_num_adapters--;	/* dec the number of adapters */
+	hpios_alistlock_un_lock(&adapters);
+}
+
+/**
+* FindAdapter returns a pointer to the struct hpi_adapter_obj with
+* index wAdapterIndex in an HPI_ADAPTERS_LIST structure.
+*
+*/
+struct hpi_adapter_obj *hpi_find_adapter(u16 adapter_index)
+{
+	struct hpi_adapter_obj *pao = NULL;
+
+	if (adapter_index >= HPI_MAX_ADAPTERS) {
+		HPI_DEBUG_LOG(VERBOSE, "find_adapter invalid index %d ",
+			adapter_index);
+		return NULL;
+	}
+
+	pao = &adapters.adapter[adapter_index];
+	if (pao->adapter_type != 0) {
+		/*
+		   HPI_DEBUG_LOG(VERBOSE, "Found adapter index %d\n",
+		   wAdapterIndex);
+		 */
+		return pao;
+	} else {
+		/*
+		   HPI_DEBUG_LOG(VERBOSE, "No adapter index %d\n",
+		   wAdapterIndex);
+		 */
+		return NULL;
+	}
+}
+
+/**
+*
+* wipe an HPI_ADAPTERS_LIST structure.
+*
+**/
+static void wipe_adapter_list(void
+	)
+{
+	memset(&adapters, 0, sizeof(adapters));
+}
+
+/**
+* SubSysGetAdapters fills awAdapterList in an struct hpi_response structure
+* with all adapters in the given HPI_ADAPTERS_LIST.
+*
+*/
+static void subsys_get_adapters(struct hpi_response *phr)
+{
+	/* fill in the response adapter array with the position */
+	/* identified by the adapter number/index of the adapters in */
+	/* this HPI */
+	/* i.e. if we have an A120 with it's jumper set to */
+	/* Adapter Number 2 then put an Adapter type A120 in the */
+	/* array in position 1 */
+	/* NOTE: AdapterNumber is 1..N, Index is 0..N-1 */
+
+	/* input:  NONE */
+	/* output: wNumAdapters */
+	/*                 awAdapter[] */
+	/* */
+
+	short i;
+	struct hpi_adapter_obj *pao = NULL;
+
+	HPI_DEBUG_LOG(VERBOSE, "subsys_get_adapters\n");
+
+	/* for each adapter, place it's type in the position of the array */
+	/* corresponding to it's adapter number */
+	for (i = 0; i < adapters.gw_num_adapters; i++) {
+		pao = &adapters.adapter[i];
+		if (phr->u.s.aw_adapter_list[pao->index] != 0) {
+			phr->error = HPI_DUPLICATE_ADAPTER_NUMBER;
+			phr->specific_error = pao->index;
+			return;
+		}
+		phr->u.s.aw_adapter_list[pao->index] = pao->adapter_type;
+	}
+
+	phr->u.s.num_adapters = adapters.gw_num_adapters;
+	phr->error = 0;	/* the function completed OK; */
+}
+
+static unsigned int control_cache_alloc_check(struct hpi_control_cache *pC)
+{
+	unsigned int i;
+	int cached = 0;
+	if (!pC)
+		return 0;
+	if ((!pC->init) && (pC->p_cache != NULL) && (pC->control_count)
+		&& (pC->cache_size_in_bytes)
+		) {
+		u32 *p_master_cache;
+		pC->init = 1;
+
+		p_master_cache = (u32 *)pC->p_cache;
+		HPI_DEBUG_LOG(VERBOSE, "check %d controls\n",
+			pC->control_count);
+		for (i = 0; i < pC->control_count; i++) {
+			struct hpi_control_cache_info *info =
+				(struct hpi_control_cache_info *)
+				p_master_cache;
+
+			if (info->control_type) {
+				pC->p_info[i] = info;
+				cached++;
+			} else
+				pC->p_info[i] = NULL;
+
+			if (info->size_in32bit_words)
+				p_master_cache += info->size_in32bit_words;
+			else
+				p_master_cache +=
+					sizeof(struct
+					hpi_control_cache_single) /
+					sizeof(u32);
+
+			HPI_DEBUG_LOG(VERBOSE,
+				"cached %d, pinfo %p index %d type %d\n",
+				cached, pC->p_info[i], info->control_index,
+				info->control_type);
+		}
+		/*
+		   We didn't find anything to cache, so try again later !
+		 */
+		if (!cached)
+			pC->init = 0;
+	}
+	return pC->init;
+}
+
+/** Find a control.
+*/
+static short find_control(struct hpi_message *phm,
+	struct hpi_control_cache *p_cache, struct hpi_control_cache_info **pI,
+	u16 *pw_control_index)
+{
+	*pw_control_index = phm->obj_index;
+
+	if (!control_cache_alloc_check(p_cache)) {
+		HPI_DEBUG_LOG(VERBOSE,
+			"control_cache_alloc_check() failed. adap%d ci%d\n",
+			phm->adapter_index, *pw_control_index);
+		return 0;
+	}
+
+	*pI = p_cache->p_info[*pw_control_index];
+	if (!*pI) {
+		HPI_DEBUG_LOG(VERBOSE, "uncached adap %d, control %d\n",
+			phm->adapter_index, *pw_control_index);
+		return 0;
+	} else {
+		HPI_DEBUG_LOG(VERBOSE, "find_control() type %d\n",
+			(*pI)->control_type);
+	}
+	return 1;
+}
+
+/** Used by the kernel driver to figure out if a buffer needs mapping.
+ */
+short hpi_check_buffer_mapping(struct hpi_control_cache *p_cache,
+	struct hpi_message *phm, void **p, unsigned int *pN)
+{
+	*pN = 0;
+	*p = NULL;
+	if ((phm->function == HPI_CONTROL_GET_STATE)
+		&& (phm->object == HPI_OBJ_CONTROLEX)
+		) {
+		u16 control_index;
+		struct hpi_control_cache_info *pI;
+
+		if (!find_control(phm, p_cache, &pI, &control_index))
+			return 0;
+	}
+	return 0;
+}
+
+/* allow unified treatment of several string fields within struct */
+#define HPICMN_PAD_OFS_AND_SIZE(m)  {\
+	offsetof(struct hpi_control_cache_pad, m), \
+	sizeof(((struct hpi_control_cache_pad *)(NULL))->m) }
+
+struct pad_ofs_size {
+	unsigned int offset;
+	unsigned int field_size;
+};
+
+static struct pad_ofs_size pad_desc[] = {
+	HPICMN_PAD_OFS_AND_SIZE(c_channel),	/* HPI_PAD_CHANNEL_NAME */
+	HPICMN_PAD_OFS_AND_SIZE(c_artist),	/* HPI_PAD_ARTIST */
+	HPICMN_PAD_OFS_AND_SIZE(c_title),	/* HPI_PAD_TITLE */
+	HPICMN_PAD_OFS_AND_SIZE(c_comment),	/* HPI_PAD_COMMENT */
+};
+
+/** CheckControlCache checks the cache and fills the struct hpi_response
+ * accordingly. It returns one if a cache hit occurred, zero otherwise.
+ */
+short hpi_check_control_cache(struct hpi_control_cache *p_cache,
+	struct hpi_message *phm, struct hpi_response *phr)
+{
+	short found = 1;
+	u16 control_index;
+	struct hpi_control_cache_info *pI;
+	struct hpi_control_cache_single *pC;
+	struct hpi_control_cache_pad *p_pad;
+
+	if (!find_control(phm, p_cache, &pI, &control_index))
+		return 0;
+
+	phr->error = 0;
+
+	/* pC is the default cached control strucure. May be cast to
+	   something else in the following switch statement.
+	 */
+	pC = (struct hpi_control_cache_single *)pI;
+	p_pad = (struct hpi_control_cache_pad *)pI;
+
+	switch (pI->control_type) {
+
+	case HPI_CONTROL_METER:
+		if (phm->u.c.attribute == HPI_METER_PEAK) {
+			phr->u.c.an_log_value[0] = pC->u.p.an_log_peak[0];
+			phr->u.c.an_log_value[1] = pC->u.p.an_log_peak[1];
+		} else if (phm->u.c.attribute == HPI_METER_RMS) {
+			phr->u.c.an_log_value[0] = pC->u.p.an_logRMS[0];
+			phr->u.c.an_log_value[1] = pC->u.p.an_logRMS[1];
+		} else
+			found = 0;
+		break;
+	case HPI_CONTROL_VOLUME:
+		if (phm->u.c.attribute == HPI_VOLUME_GAIN) {
+			phr->u.c.an_log_value[0] = pC->u.v.an_log[0];
+			phr->u.c.an_log_value[1] = pC->u.v.an_log[1];
+		} else
+			found = 0;
+		break;
+	case HPI_CONTROL_MULTIPLEXER:
+		if (phm->u.c.attribute == HPI_MULTIPLEXER_SOURCE) {
+			phr->u.c.param1 = pC->u.x.source_node_type;
+			phr->u.c.param2 = pC->u.x.source_node_index;
+		} else {
+			found = 0;
+		}
+		break;
+	case HPI_CONTROL_CHANNEL_MODE:
+		if (phm->u.c.attribute == HPI_CHANNEL_MODE_MODE)
+			phr->u.c.param1 = pC->u.m.mode;
+		else
+			found = 0;
+		break;
+	case HPI_CONTROL_LEVEL:
+		if (phm->u.c.attribute == HPI_LEVEL_GAIN) {
+			phr->u.c.an_log_value[0] = pC->u.l.an_log[0];
+			phr->u.c.an_log_value[1] = pC->u.l.an_log[1];
+		} else
+			found = 0;
+		break;
+	case HPI_CONTROL_TUNER:
+		{
+			struct hpi_control_cache_single *pCT =
+				(struct hpi_control_cache_single *)pI;
+			if (phm->u.c.attribute == HPI_TUNER_FREQ)
+				phr->u.c.param1 = pCT->u.t.freq_ink_hz;
+			else if (phm->u.c.attribute == HPI_TUNER_BAND)
+				phr->u.c.param1 = pCT->u.t.band;
+			else if ((phm->u.c.attribute == HPI_TUNER_LEVEL)
+				&& (phm->u.c.param1 ==
+					HPI_TUNER_LEVEL_AVERAGE))
+				phr->u.c.param1 = pCT->u.t.level;
+			else
+				found = 0;
+		}
+		break;
+	case HPI_CONTROL_AESEBU_RECEIVER:
+		if (phm->u.c.attribute == HPI_AESEBURX_ERRORSTATUS)
+			phr->u.c.param1 = pC->u.aes3rx.error_status;
+		else if (phm->u.c.attribute == HPI_AESEBURX_FORMAT)
+			phr->u.c.param1 = pC->u.aes3rx.source;
+		else
+			found = 0;
+		break;
+	case HPI_CONTROL_AESEBU_TRANSMITTER:
+		if (phm->u.c.attribute == HPI_AESEBUTX_FORMAT)
+			phr->u.c.param1 = pC->u.aes3tx.format;
+		else
+			found = 0;
+		break;
+	case HPI_CONTROL_TONEDETECTOR:
+		if (phm->u.c.attribute == HPI_TONEDETECTOR_STATE)
+			phr->u.c.param1 = pC->u.tone.state;
+		else
+			found = 0;
+		break;
+	case HPI_CONTROL_SILENCEDETECTOR:
+		if (phm->u.c.attribute == HPI_SILENCEDETECTOR_STATE) {
+			phr->u.c.param1 = pC->u.silence.state;
+			phr->u.c.param2 = pC->u.silence.count;
+		} else
+			found = 0;
+		break;
+	case HPI_CONTROL_MICROPHONE:
+		if (phm->u.c.attribute == HPI_MICROPHONE_PHANTOM_POWER)
+			phr->u.c.param1 = pC->u.phantom_power.state;
+		else
+			found = 0;
+		break;
+	case HPI_CONTROL_SAMPLECLOCK:
+		if (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE)
+			phr->u.c.param1 = pC->u.clk.source;
+		else if (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE_INDEX) {
+			if (pC->u.clk.source_index ==
+				HPI_ERROR_ILLEGAL_CACHE_VALUE) {
+				phr->u.c.param1 = 0;
+				phr->error = HPI_ERROR_INVALID_OPERATION;
+			} else
+				phr->u.c.param1 = pC->u.clk.source_index;
+		} else if (phm->u.c.attribute == HPI_SAMPLECLOCK_SAMPLERATE)
+			phr->u.c.param1 = pC->u.clk.sample_rate;
+		else
+			found = 0;
+		break;
+	case HPI_CONTROL_PAD:
+
+		if (!(p_pad->field_valid_flags & (1 <<
+					HPI_CTL_ATTR_INDEX(phm->u.c.
+						attribute)))) {
+			phr->error = HPI_ERROR_INVALID_CONTROL_ATTRIBUTE;
+			break;
+		}
+
+		if (phm->u.c.attribute == HPI_PAD_PROGRAM_ID)
+			phr->u.c.param1 = p_pad->pI;
+		else if (phm->u.c.attribute == HPI_PAD_PROGRAM_TYPE)
+			phr->u.c.param1 = p_pad->pTY;
+		else {
+			unsigned int index =
+				HPI_CTL_ATTR_INDEX(phm->u.c.attribute) - 1;
+			unsigned int offset = phm->u.c.param1;
+			unsigned int pad_string_len, field_size;
+			char *pad_string;
+			unsigned int tocopy;
+
+			HPI_DEBUG_LOG(VERBOSE, "PADS HPI_PADS_ %d\n",
+				phm->u.c.attribute);
+
+			if (index > ARRAY_SIZE(pad_desc) - 1) {
+				phr->error =
+					HPI_ERROR_INVALID_CONTROL_ATTRIBUTE;
+				break;
+			}
+
+			pad_string = ((char *)p_pad) + pad_desc[index].offset;
+			field_size = pad_desc[index].field_size;
+			/* Ensure null terminator */
+			pad_string[field_size - 1] = 0;
+
+			pad_string_len = strlen(pad_string) + 1;
+
+			if (offset > pad_string_len) {
+				phr->error = HPI_ERROR_INVALID_CONTROL_VALUE;
+				break;
+			}
+
+			tocopy = pad_string_len - offset;
+			if (tocopy > sizeof(phr->u.cu.chars8.sz_data))
+				tocopy = sizeof(phr->u.cu.chars8.sz_data);
+
+			HPI_DEBUG_LOG(VERBOSE,
+				"PADS memcpy(%d), offset %d \n", tocopy,
+				offset);
+			memcpy(phr->u.cu.chars8.sz_data, &pad_string[offset],
+				tocopy);
+
+			phr->u.cu.chars8.remaining_chars =
+				pad_string_len - offset - tocopy;
+		}
+		break;
+	default:
+		found = 0;
+		break;
+	}
+
+	if (found)
+		HPI_DEBUG_LOG(VERBOSE,
+			"cached adap %d, ctl %d, type %d, attr %d\n",
+			phm->adapter_index, pI->control_index,
+			pI->control_type, phm->u.c.attribute);
+	else
+		HPI_DEBUG_LOG(VERBOSE,
+			"uncached adap %d, ctl %d, ctl type %d\n",
+			phm->adapter_index, pI->control_index,
+			pI->control_type);
+
+	if (found)
+		phr->size =
+			sizeof(struct hpi_response_header) +
+			sizeof(struct hpi_control_res);
+
+	return found;
+}
+
+/** Updates the cache with Set values.
+
+Only update if no error.
+Volume and Level return the limited values in the response, so use these
+Multiplexer does so use sent values
+*/
+void hpi_sync_control_cache(struct hpi_control_cache *p_cache,
+	struct hpi_message *phm, struct hpi_response *phr)
+{
+	u16 control_index;
+	struct hpi_control_cache_single *pC;
+	struct hpi_control_cache_info *pI;
+
+	if (!find_control(phm, p_cache, &pI, &control_index))
+		return;
+
+	/* pC is the default cached control strucure.
+	   May be cast to something else in the following switch statement.
+	 */
+	pC = (struct hpi_control_cache_single *)pI;
+
+	switch (pI->control_type) {
+	case HPI_CONTROL_VOLUME:
+		if (phm->u.c.attribute == HPI_VOLUME_GAIN) {
+			pC->u.v.an_log[0] = phr->u.c.an_log_value[0];
+			pC->u.v.an_log[1] = phr->u.c.an_log_value[1];
+		}
+		break;
+	case HPI_CONTROL_MULTIPLEXER:
+		/* mux does not return its setting on Set command. */
+		if (phr->error)
+			return;
+		if (phm->u.c.attribute == HPI_MULTIPLEXER_SOURCE) {
+			pC->u.x.source_node_type = (u16)phm->u.c.param1;
+			pC->u.x.source_node_index = (u16)phm->u.c.param2;
+		}
+		break;
+	case HPI_CONTROL_CHANNEL_MODE:
+		/* mode does not return its setting on Set command. */
+		if (phr->error)
+			return;
+		if (phm->u.c.attribute == HPI_CHANNEL_MODE_MODE)
+			pC->u.m.mode = (u16)phm->u.c.param1;
+		break;
+	case HPI_CONTROL_LEVEL:
+		if (phm->u.c.attribute == HPI_LEVEL_GAIN) {
+			pC->u.v.an_log[0] = phr->u.c.an_log_value[0];
+			pC->u.v.an_log[1] = phr->u.c.an_log_value[1];
+		}
+		break;
+	case HPI_CONTROL_MICROPHONE:
+		if (phm->u.c.attribute == HPI_MICROPHONE_PHANTOM_POWER)
+			pC->u.phantom_power.state = (u16)phm->u.c.param1;
+		break;
+	case HPI_CONTROL_AESEBU_TRANSMITTER:
+		if (phr->error)
+			return;
+		if (phm->u.c.attribute == HPI_AESEBUTX_FORMAT)
+			pC->u.aes3tx.format = phm->u.c.param1;
+		break;
+	case HPI_CONTROL_AESEBU_RECEIVER:
+		if (phr->error)
+			return;
+		if (phm->u.c.attribute == HPI_AESEBURX_FORMAT)
+			pC->u.aes3rx.source = phm->u.c.param1;
+		break;
+	case HPI_CONTROL_SAMPLECLOCK:
+		if (phr->error)
+			return;
+		if (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE)
+			pC->u.clk.source = (u16)phm->u.c.param1;
+		else if (phm->u.c.attribute == HPI_SAMPLECLOCK_SOURCE_INDEX)
+			pC->u.clk.source_index = (u16)phm->u.c.param1;
+		else if (phm->u.c.attribute == HPI_SAMPLECLOCK_SAMPLERATE)
+			pC->u.clk.sample_rate = phm->u.c.param1;
+		break;
+	default:
+		break;
+	}
+}
+
+struct hpi_control_cache *hpi_alloc_control_cache(const u32
+	number_of_controls, const u32 size_in_bytes,
+	struct hpi_control_cache_info *pDSP_control_buffer)
+{
+	struct hpi_control_cache *p_cache =
+		kmalloc(sizeof(*p_cache), GFP_KERNEL);
+	p_cache->cache_size_in_bytes = size_in_bytes;
+	p_cache->control_count = number_of_controls;
+	p_cache->p_cache =
+		(struct hpi_control_cache_single *)pDSP_control_buffer;
+	p_cache->init = 0;
+	p_cache->p_info =
+		kmalloc(sizeof(*p_cache->p_info) * p_cache->control_count,
+		GFP_KERNEL);
+	return p_cache;
+}
+
+void hpi_free_control_cache(struct hpi_control_cache *p_cache)
+{
+	if ((p_cache->init) && (p_cache->p_info)) {
+		kfree(p_cache->p_info);
+		p_cache->p_info = NULL;
+		p_cache->init = 0;
+		kfree(p_cache);
+	}
+}
+
+static void subsys_message(struct hpi_message *phm, struct hpi_response *phr)
+{
+
+	switch (phm->function) {
+	case HPI_SUBSYS_OPEN:
+	case HPI_SUBSYS_CLOSE:
+	case HPI_SUBSYS_DRIVER_UNLOAD:
+		phr->error = 0;
+		break;
+	case HPI_SUBSYS_DRIVER_LOAD:
+		wipe_adapter_list();
+		hpios_alistlock_init(&adapters);
+		phr->error = 0;
+		break;
+	case HPI_SUBSYS_GET_INFO:
+		subsys_get_adapters(phr);
+		break;
+	case HPI_SUBSYS_CREATE_ADAPTER:
+	case HPI_SUBSYS_DELETE_ADAPTER:
+		phr->error = 0;
+		break;
+	default:
+		phr->error = HPI_ERROR_INVALID_FUNC;
+		break;
+	}
+}
+
+void HPI_COMMON(struct hpi_message *phm, struct hpi_response *phr)
+{
+	switch (phm->type) {
+	case HPI_TYPE_MESSAGE:
+		switch (phm->object) {
+		case HPI_OBJ_SUBSYSTEM:
+			subsys_message(phm, phr);
+			break;
+		}
+		break;
+
+	default:
+		phr->error = HPI_ERROR_INVALID_TYPE;
+		break;
+	}
+}
