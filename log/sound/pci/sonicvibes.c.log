commit b4e5e70775546480035e156b40040e5d0d4264d1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:53 2020 +0100

    ALSA: pci: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-38-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index dcdf5a534c4e..ecdd54d7a4e1 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1050,7 +1050,7 @@ static int snd_sonicvibes_put_double(struct snd_kcontrol *kcontrol, struct snd_c
 	return change;
 }
 
-static struct snd_kcontrol_new snd_sonicvibes_controls[] = {
+static const struct snd_kcontrol_new snd_sonicvibes_controls[] = {
 SONICVIBES_DOUBLE("Capture Volume", 0, SV_IREG_LEFT_ADC, SV_IREG_RIGHT_ADC, 0, 0, 15, 0),
 SONICVIBES_DOUBLE("Aux Playback Switch", 0, SV_IREG_LEFT_AUX1, SV_IREG_RIGHT_AUX1, 7, 7, 1, 1),
 SONICVIBES_DOUBLE("Aux Playback Volume", 0, SV_IREG_LEFT_AUX1, SV_IREG_RIGHT_AUX1, 0, 0, 31, 1),
@@ -1149,7 +1149,7 @@ static void snd_sonicvibes_proc_init(struct sonicvibes *sonic)
  */
 
 #ifdef SUPPORT_JOYSTICK
-static struct snd_kcontrol_new snd_sonicvibes_game_control =
+static const struct snd_kcontrol_new snd_sonicvibes_game_control =
 SONICVIBES_SINGLE("Joystick Speed", 0, SV_IREG_GAME_PORT, 1, 15, 0);
 
 static int snd_sonicvibes_create_gameport(struct sonicvibes *sonic)
@@ -1375,7 +1375,7 @@ static int snd_sonicvibes_create(struct snd_card *card,
  *  MIDI section
  */
 
-static struct snd_kcontrol_new snd_sonicvibes_midi_controls[] = {
+static const struct snd_kcontrol_new snd_sonicvibes_midi_controls[] = {
 SONICVIBES_SINGLE("SonicVibes Wave Source RAM", 0, SV_IREG_WAVE_SOURCE, 0, 1, 0),
 SONICVIBES_SINGLE("SonicVibes Wave Source RAM+ROM", 0, SV_IREG_WAVE_SOURCE, 1, 1, 0),
 SONICVIBES_SINGLE("SonicVibes Onboard Synth", 0, SV_IREG_MPU401, 0, 1, 0),

commit efb0ad25d370344e61bb4fca8c3b9c3c6047922e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:25 2020 +0100

    ALSA: pci: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index a2bff9431512..dcdf5a534c4e 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1221,7 +1221,7 @@ static int snd_sonicvibes_create(struct snd_card *card,
 	struct sonicvibes *sonic;
 	unsigned int dmaa, dmac;
 	int err;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free =	snd_sonicvibes_dev_free,
 	};
 

commit 93042ac2bc40658e8e2cd809644e37bda05cf4fc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:34 2019 +0100

    ALSA: sonicvibes: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-36-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index bc650c8e85b0..a2bff9431512 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1267,6 +1267,7 @@ static int snd_sonicvibes_create(struct snd_card *card,
 		return -EBUSY;
 	}
 	sonic->irq = pci->irq;
+	card->sync_irq = sonic->irq;
 
 	pci_read_config_dword(pci, 0x40, &dmaa);
 	pci_read_config_dword(pci, 0x48, &dmac);

commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index e117d8450b2d..bc650c8e85b0 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -835,7 +835,6 @@ static int snd_sonicvibes_capture_close(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_sonicvibes_playback_ops = {
 	.open =		snd_sonicvibes_playback_open,
 	.close =	snd_sonicvibes_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_sonicvibes_playback_prepare,
 	.trigger =	snd_sonicvibes_playback_trigger,
 	.pointer =	snd_sonicvibes_playback_pointer,
@@ -844,7 +843,6 @@ static const struct snd_pcm_ops snd_sonicvibes_playback_ops = {
 static const struct snd_pcm_ops snd_sonicvibes_capture_ops = {
 	.open =		snd_sonicvibes_capture_open,
 	.close =	snd_sonicvibes_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_sonicvibes_capture_prepare,
 	.trigger =	snd_sonicvibes_capture_trigger,
 	.pointer =	snd_sonicvibes_capture_pointer,

commit 3e1ee04ba9ea9129c8d5bb8809866ea38e7794c2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:25 2019 +0100

    ALSA: sonicvibes: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The hw_params and hw_free callbacks became superfluous and got
    dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-54-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 31cbc811ad37..e117d8450b2d 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -681,17 +681,6 @@ static int snd_sonicvibes_capture_trigger(struct snd_pcm_substream *substream,
 	return snd_sonicvibes_trigger(sonic, 2, cmd);
 }
 
-static int snd_sonicvibes_hw_params(struct snd_pcm_substream *substream,
-				    struct snd_pcm_hw_params *hw_params)
-{
-	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
-}
-
-static int snd_sonicvibes_hw_free(struct snd_pcm_substream *substream)
-{
-	return snd_pcm_lib_free_pages(substream);
-}
-
 static int snd_sonicvibes_playback_prepare(struct snd_pcm_substream *substream)
 {
 	struct sonicvibes *sonic = snd_pcm_substream_chip(substream);
@@ -847,8 +836,6 @@ static const struct snd_pcm_ops snd_sonicvibes_playback_ops = {
 	.open =		snd_sonicvibes_playback_open,
 	.close =	snd_sonicvibes_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_sonicvibes_hw_params,
-	.hw_free =	snd_sonicvibes_hw_free,
 	.prepare =	snd_sonicvibes_playback_prepare,
 	.trigger =	snd_sonicvibes_playback_trigger,
 	.pointer =	snd_sonicvibes_playback_pointer,
@@ -858,8 +845,6 @@ static const struct snd_pcm_ops snd_sonicvibes_capture_ops = {
 	.open =		snd_sonicvibes_capture_open,
 	.close =	snd_sonicvibes_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_sonicvibes_hw_params,
-	.hw_free =	snd_sonicvibes_hw_free,
 	.prepare =	snd_sonicvibes_capture_prepare,
 	.trigger =	snd_sonicvibes_capture_trigger,
 	.pointer =	snd_sonicvibes_capture_pointer,
@@ -883,9 +868,8 @@ static int snd_sonicvibes_pcm(struct sonicvibes *sonic, int device)
 	strcpy(pcm->name, "S3 SonicVibes");
 	sonic->pcm = pcm;
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &sonic->pci->dev,
-					      64*1024, 128*1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
+				       &sonic->pci->dev, 64*1024, 128*1024);
 
 	return 0;
 }

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 13103f5c309b..31cbc811ad37 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -884,7 +884,8 @@ static int snd_sonicvibes_pcm(struct sonicvibes *sonic, int device)
 	sonic->pcm = pcm;
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      snd_dma_pci_data(sonic->pci), 64*1024, 128*1024);
+					      &sonic->pci->dev,
+					      64*1024, 128*1024);
 
 	return 0;
 }

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 71d5ad3cffd6..13103f5c309b 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Driver for S3 SonicVibes soundcard
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
@@ -5,21 +6,6 @@
  *  BUGS:
  *    It looks like 86c617 rev 3 doesn't supports DDMA buffers above 16MB?
  *    Driver sometimes hangs... Nobody knows why at this moment...
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/delay.h>

commit 47f2769b4b2e267cba135fc19c89c32d202b1415
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:01:39 2019 +0100

    ALSA: pci: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 7218f38b59db..71d5ad3cffd6 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1171,10 +1171,8 @@ static void snd_sonicvibes_proc_read(struct snd_info_entry *entry,
 
 static void snd_sonicvibes_proc_init(struct sonicvibes *sonic)
 {
-	struct snd_info_entry *entry;
-
-	if (! snd_card_proc_new(sonic->card, "sonicvibes", &entry))
-		snd_info_set_text_ops(entry, sonic, snd_sonicvibes_proc_read);
+	snd_card_ro_proc_new(sonic->card, "sonicvibes", sonic,
+			     snd_sonicvibes_proc_read);
 }
 
 /*

commit 0d00085b905c904d6de4296aa6a1e3613d0a4d67
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Aug 1 11:47:38 2018 +0100

    ALSA: sonicvibes: remove redundant pointer 'dir'
    
    Pointer 'dir' is being assigned but is never used hence it is
    redundant and can be removed.
    
    Cleans up clang warning:
    warning: variable 'dir' set but not used [-Wunused-but-set-variable]
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 7fbdb703bfcd..7218f38b59db 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1433,14 +1433,12 @@ static int snd_sonicvibes_midi(struct sonicvibes *sonic,
 {
 	struct snd_mpu401 * mpu = rmidi->private_data;
 	struct snd_card *card = sonic->card;
-	struct snd_rawmidi_str *dir;
 	unsigned int idx;
 	int err;
 
 	mpu->private_data = sonic;
 	mpu->open_input = snd_sonicvibes_midi_input_open;
 	mpu->close_input = snd_sonicvibes_midi_input_close;
-	dir = &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT];
 	for (idx = 0; idx < ARRAY_SIZE(snd_sonicvibes_midi_controls); idx++)
 		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_sonicvibes_midi_controls[idx], sonic))) < 0)
 			return err;

commit 41538f2db1eaa8613ffb3cd0c92a57ace6c0a5f2
Author: Zhouyang Jia <jiazhouyang09@gmail.com>
Date:   Thu Jun 14 19:41:37 2018 +0800

    ALSA: sonicvibes: add error handling for snd_ctl_add
    
    When snd_ctl_add fails, the lack of error-handling code may
    cause unexpected results.
    
    This patch adds error-handling code after calling snd_ctl_add.
    
    Signed-off-by: Zhouyang Jia <jiazhouyang09@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index a8abb15e3c3a..7fbdb703bfcd 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1188,6 +1188,7 @@ SONICVIBES_SINGLE("Joystick Speed", 0, SV_IREG_GAME_PORT, 1, 15, 0);
 static int snd_sonicvibes_create_gameport(struct sonicvibes *sonic)
 {
 	struct gameport *gp;
+	int err;
 
 	sonic->gameport = gp = gameport_allocate_port();
 	if (!gp) {
@@ -1203,7 +1204,10 @@ static int snd_sonicvibes_create_gameport(struct sonicvibes *sonic)
 
 	gameport_register_port(gp);
 
-	snd_ctl_add(sonic->card, snd_ctl_new1(&snd_sonicvibes_game_control, sonic));
+	err = snd_ctl_add(sonic->card,
+		snd_ctl_new1(&snd_sonicvibes_game_control, sonic));
+	if (err < 0)
+		return err;
 
 	return 0;
 }
@@ -1515,7 +1519,11 @@ static int snd_sonic_probe(struct pci_dev *pci,
 		return err;
 	}
 
-	snd_sonicvibes_create_gameport(sonic);
+	err = snd_sonicvibes_create_gameport(sonic);
+	if (err < 0) {
+		snd_card_free(card);
+		return err;
+	}
 
 	if ((err = snd_card_register(card)) < 0) {
 		snd_card_free(card);

commit dee49895b197936c02d27d651e58c90bac18f452
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:28 2017 +0530

    ALSA: pci: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 784d762f18a7..a8abb15e3c3a 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -776,7 +776,7 @@ static snd_pcm_uframes_t snd_sonicvibes_capture_pointer(struct snd_pcm_substream
 	return bytes_to_frames(substream->runtime, ptr);
 }
 
-static struct snd_pcm_hardware snd_sonicvibes_playback =
+static const struct snd_pcm_hardware snd_sonicvibes_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -795,7 +795,7 @@ static struct snd_pcm_hardware snd_sonicvibes_playback =
 	.fifo_size =		0,
 };
 
-static struct snd_pcm_hardware snd_sonicvibes_capture =
+static const struct snd_pcm_hardware snd_sonicvibes_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |

commit de900b182ef1826e887c4458d7af0696f08fcc4b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 7 14:22:55 2017 +0200

    ALSA: sonicvibes: Constify hw_constraints
    
    snd_pcm_hw_constraint_list(), *_ratnums() and *_ratdens() receive the
    const pointers.  Constify the corresponding static objects for better
    hardening.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 8e3d4ec39c35..784d762f18a7 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -248,13 +248,13 @@ static const struct pci_device_id snd_sonic_ids[] = {
 
 MODULE_DEVICE_TABLE(pci, snd_sonic_ids);
 
-static struct snd_ratden sonicvibes_adc_clock = {
+static const struct snd_ratden sonicvibes_adc_clock = {
 	.num_min = 4000 * 65536,
 	.num_max = 48000UL * 65536,
 	.num_step = 1,
 	.den = 65536,
 };
-static struct snd_pcm_hw_constraint_ratdens snd_sonicvibes_hw_constraints_adc_clock = {
+static const struct snd_pcm_hw_constraint_ratdens snd_sonicvibes_hw_constraints_adc_clock = {
 	.nrats = 1,
 	.rats = &sonicvibes_adc_clock,
 };

commit 6192c41fc608b0a58d5540b015aa1672c266f3c5
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:30 2017 +0100

    Annotate hardware config module parameters in sound/pci/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in sound/pci/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jaroslav Kysela <perex@perex.cz>
    cc: Takashi Iwai <tiwai@suse.com>
    cc: alsa-devel@alsa-project.org

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index a6aa48c5b969..8e3d4ec39c35 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -66,7 +66,7 @@ module_param_array(reverb, bool, NULL, 0444);
 MODULE_PARM_DESC(reverb, "Enable reverb (SRAM is present) for S3 SonicVibes soundcard.");
 module_param_array(mge, bool, NULL, 0444);
 MODULE_PARM_DESC(mge, "MIC Gain Enable for S3 SonicVibes soundcard.");
-module_param(dmaio, uint, 0444);
+module_param_hw(dmaio, uint, ioport, 0444);
 MODULE_PARM_DESC(dmaio, "DDMA i/o base address for S3 SonicVibes soundcard.");
 
 /*

commit b2fac0730347d591b528d8f0e4a9438c1bb6f558
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sat Nov 12 23:26:41 2016 +0100

    ALSA: pci: don't opencode IS_REACHABLE()
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index e1a13870bb80..a6aa48c5b969 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -45,7 +45,7 @@ MODULE_DESCRIPTION("S3 SonicVibes PCI");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{S3,SonicVibes PCI}}");
 
-#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+#if IS_REACHABLE(CONFIG_GAMEPORT)
 #define SUPPORT_JOYSTICK 1
 #endif
 

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 1b6fad7d4d56..e1a13870bb80 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -857,7 +857,7 @@ static int snd_sonicvibes_capture_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static struct snd_pcm_ops snd_sonicvibes_playback_ops = {
+static const struct snd_pcm_ops snd_sonicvibes_playback_ops = {
 	.open =		snd_sonicvibes_playback_open,
 	.close =	snd_sonicvibes_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -868,7 +868,7 @@ static struct snd_pcm_ops snd_sonicvibes_playback_ops = {
 	.pointer =	snd_sonicvibes_playback_pointer,
 };
 
-static struct snd_pcm_ops snd_sonicvibes_capture_ops = {
+static const struct snd_pcm_ops snd_sonicvibes_capture_ops = {
 	.open =		snd_sonicvibes_capture_open,
 	.close =	snd_sonicvibes_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,

commit 412b979ccceff448dccea54bdb616c85781bc0ba
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Wed Apr 15 16:10:17 2015 +0200

    ALSA: remove deprecated use of pci api
    
    Replace occurences of the pci api by appropriate call to the dma api.
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr)
    
    @deprecated@
    idexpression id;
    position p;
    @@
    
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @bad1@
    idexpression id;
    position deprecated.p;
    @@
    ...when != &id->dev
       when != pci_get_drvdata ( id )
       when != pci_enable_device ( id )
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @depends on !bad1@
    idexpression id;
    expression direction;
    position deprecated.p;
    @@
    
    (
    - pci_dma_supported@p ( id,
    + dma_supported ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    |
    - pci_alloc_consistent@p ( id,
    + dma_alloc_coherent ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    )
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 0f40624a4275..1b6fad7d4d56 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1259,8 +1259,8 @@ static int snd_sonicvibes_create(struct snd_card *card,
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 	/* check, if we can restrict PCI DMA transfers to 24 bits */
-        if (pci_set_dma_mask(pci, DMA_BIT_MASK(24)) < 0 ||
-	    pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(24)) < 0) {
+	if (dma_set_mask(&pci->dev, DMA_BIT_MASK(24)) < 0 ||
+	    dma_set_coherent_mask(&pci->dev, DMA_BIT_MASK(24)) < 0) {
 		dev_err(card->dev,
 			"architecture does not support 24bit PCI busmaster DMA\n");
 		pci_disable_device(pci);

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 34cee5c1abd8..0f40624a4275 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -30,6 +30,7 @@
 #include <linux/gameport.h>
 #include <linux/module.h>
 #include <linux/dma-mapping.h>
+#include <linux/io.h>
 
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -39,8 +40,6 @@
 #include <sound/opl3.h>
 #include <sound/initval.h>
 
-#include <asm/io.h>
-
 MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");
 MODULE_DESCRIPTION("S3 SonicVibes PCI");
 MODULE_LICENSE("GPL");

commit 0f33991dd2811cb5458b1a2bc19c6aa6ff64c00b
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Jan 2 12:24:53 2015 +0100

    ALSA: sonicvibes: Remove always NULL parameter
    
    snd_sonicvibes_pcm() take a pointer to a pointer of a PCM where if this
    parameter is provided the newly allocated PCM is stored. All callers pass
    NULL though, so remove the parameter. This makes the code a bit cleaner and
    shorter.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 313a7328bf9c..34cee5c1abd8 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -880,8 +880,7 @@ static struct snd_pcm_ops snd_sonicvibes_capture_ops = {
 	.pointer =	snd_sonicvibes_capture_pointer,
 };
 
-static int snd_sonicvibes_pcm(struct sonicvibes *sonic, int device,
-			      struct snd_pcm **rpcm)
+static int snd_sonicvibes_pcm(struct sonicvibes *sonic, int device)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -902,8 +901,6 @@ static int snd_sonicvibes_pcm(struct sonicvibes *sonic, int device,
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
 					      snd_dma_pci_data(sonic->pci), 64*1024, 128*1024);
 
-	if (rpcm)
-		*rpcm = pcm;
 	return 0;
 }
 
@@ -1491,7 +1488,7 @@ static int snd_sonic_probe(struct pci_dev *pci,
 		(unsigned long long)pci_resource_start(pci, 1),
 		sonic->irq);
 
-	if ((err = snd_sonicvibes_pcm(sonic, 0, NULL)) < 0) {
+	if ((err = snd_sonicvibes_pcm(sonic, 0)) < 0) {
 		snd_card_free(card);
 		return err;
 	}

commit 3e4bc5b78e5516585941c7888287ed50a5090bf4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 20 18:20:07 2014 +0200

    ALSA: sonicvibes: Use snd_ctl_enum_info()
    
    ... and reduce the open codes.  Also add missing const to the text array.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 5b0d317cc9a6..313a7328bf9c 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -918,17 +918,11 @@ static int snd_sonicvibes_pcm(struct sonicvibes *sonic, int device,
 
 static int snd_sonicvibes_info_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[7] = {
+	static const char * const texts[7] = {
 		"CD", "PCM", "Aux1", "Line", "Aux0", "Mic", "Mix"
 	};
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 2;
-	uinfo->value.enumerated.items = 7;
-	if (uinfo->value.enumerated.item >= 7)
-		uinfo->value.enumerated.item = 6;
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(uinfo, 2, 7, texts);
 }
 
 static int snd_sonicvibes_get_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 2044dc742071..5b0d317cc9a6 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -242,7 +242,7 @@ struct sonicvibes {
 #endif
 };
 
-static DEFINE_PCI_DEVICE_TABLE(snd_sonic_ids) = {
+static const struct pci_device_id snd_sonic_ids[] = {
 	{ PCI_VDEVICE(S3, 0xca00), 0, },
         { 0, }
 };

commit ffa74cc78125325a507b2aab7570f842a2f0aab0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 15:16:04 2014 +0100

    ALSA: sonicvibes: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    The debug prints are also reformatted to suit with dev_dbg().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 9ff408fff7b0..2044dc742071 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -273,7 +273,7 @@ static inline void snd_sonicvibes_setdmaa(struct sonicvibes * sonic,
 	outl(count, sonic->dmaa_port + SV_DMA_COUNT0);
 	outb(0x18, sonic->dmaa_port + SV_DMA_MODE);
 #if 0
-	printk(KERN_DEBUG "program dmaa: addr = 0x%x, paddr = 0x%x\n",
+	dev_dbg(sonic->card->dev, "program dmaa: addr = 0x%x, paddr = 0x%x\n",
 	       addr, inl(sonic->dmaa_port + SV_DMA_ADDR0));
 #endif
 }
@@ -289,7 +289,7 @@ static inline void snd_sonicvibes_setdmac(struct sonicvibes * sonic,
 	outl(count, sonic->dmac_port + SV_DMA_COUNT0);
 	outb(0x14, sonic->dmac_port + SV_DMA_MODE);
 #if 0
-	printk(KERN_DEBUG "program dmac: addr = 0x%x, paddr = 0x%x\n",
+	dev_dbg(sonic->card->dev, "program dmac: addr = 0x%x, paddr = 0x%x\n",
 	       addr, inl(sonic->dmac_port + SV_DMA_ADDR0));
 #endif
 }
@@ -357,105 +357,105 @@ static unsigned char snd_sonicvibes_in(struct sonicvibes * sonic, unsigned char
 #if 0
 static void snd_sonicvibes_debug(struct sonicvibes * sonic)
 {
-	printk(KERN_DEBUG
-	       "SV REGS:          INDEX = 0x%02x  ", inb(SV_REG(sonic, INDEX)));
-	printk("                 STATUS = 0x%02x\n", inb(SV_REG(sonic, STATUS)));
-	printk(KERN_DEBUG
-	       "  0x00: left input      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x00));
-	printk("  0x20: synth rate low  = 0x%02x\n", snd_sonicvibes_in(sonic, 0x20));
-	printk(KERN_DEBUG
-	       "  0x01: right input     = 0x%02x  ", snd_sonicvibes_in(sonic, 0x01));
-	printk("  0x21: synth rate high = 0x%02x\n", snd_sonicvibes_in(sonic, 0x21));
-	printk(KERN_DEBUG
-	       "  0x02: left AUX1       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x02));
-	printk("  0x22: ADC clock       = 0x%02x\n", snd_sonicvibes_in(sonic, 0x22));
-	printk(KERN_DEBUG
-	       "  0x03: right AUX1      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x03));
-	printk("  0x23: ADC alt rate    = 0x%02x\n", snd_sonicvibes_in(sonic, 0x23));
-	printk(KERN_DEBUG
-	       "  0x04: left CD         = 0x%02x  ", snd_sonicvibes_in(sonic, 0x04));
-	printk("  0x24: ADC pll M       = 0x%02x\n", snd_sonicvibes_in(sonic, 0x24));
-	printk(KERN_DEBUG
-	       "  0x05: right CD        = 0x%02x  ", snd_sonicvibes_in(sonic, 0x05));
-	printk("  0x25: ADC pll N       = 0x%02x\n", snd_sonicvibes_in(sonic, 0x25));
-	printk(KERN_DEBUG
-	       "  0x06: left line       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x06));
-	printk("  0x26: Synth pll M     = 0x%02x\n", snd_sonicvibes_in(sonic, 0x26));
-	printk(KERN_DEBUG
-	       "  0x07: right line      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x07));
-	printk("  0x27: Synth pll N     = 0x%02x\n", snd_sonicvibes_in(sonic, 0x27));
-	printk(KERN_DEBUG
-	       "  0x08: MIC             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x08));
-	printk("  0x28: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x28));
-	printk(KERN_DEBUG
-	       "  0x09: Game port       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x09));
-	printk("  0x29: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x29));
-	printk(KERN_DEBUG
-	       "  0x0a: left synth      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0a));
-	printk("  0x2a: MPU401          = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2a));
-	printk(KERN_DEBUG
-	       "  0x0b: right synth     = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0b));
-	printk("  0x2b: drive ctrl      = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2b));
-	printk(KERN_DEBUG
-	       "  0x0c: left AUX2       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0c));
-	printk("  0x2c: SRS space       = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2c));
-	printk(KERN_DEBUG
-	       "  0x0d: right AUX2      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0d));
-	printk("  0x2d: SRS center      = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2d));
-	printk(KERN_DEBUG
-	       "  0x0e: left analog     = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0e));
-	printk("  0x2e: wave source     = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2e));
-	printk(KERN_DEBUG
-	       "  0x0f: right analog    = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0f));
-	printk("  0x2f: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2f));
-	printk(KERN_DEBUG
-	       "  0x10: left PCM        = 0x%02x  ", snd_sonicvibes_in(sonic, 0x10));
-	printk("  0x30: analog power    = 0x%02x\n", snd_sonicvibes_in(sonic, 0x30));
-	printk(KERN_DEBUG
-	       "  0x11: right PCM       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x11));
-	printk("  0x31: analog power    = 0x%02x\n", snd_sonicvibes_in(sonic, 0x31));
-	printk(KERN_DEBUG
-	       "  0x12: DMA data format = 0x%02x  ", snd_sonicvibes_in(sonic, 0x12));
-	printk("  0x32: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x32));
-	printk(KERN_DEBUG
-	       "  0x13: P/C enable      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x13));
-	printk("  0x33: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x33));
-	printk(KERN_DEBUG
-	       "  0x14: U/D button      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x14));
-	printk("  0x34: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x34));
-	printk(KERN_DEBUG
-	       "  0x15: revision        = 0x%02x  ", snd_sonicvibes_in(sonic, 0x15));
-	printk("  0x35: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x35));
-	printk(KERN_DEBUG
-	       "  0x16: ADC output ctrl = 0x%02x  ", snd_sonicvibes_in(sonic, 0x16));
-	printk("  0x36: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x36));
-	printk(KERN_DEBUG
-	       "  0x17: ---             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x17));
-	printk("  0x37: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x37));
-	printk(KERN_DEBUG
-	       "  0x18: DMA A upper cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x18));
-	printk("  0x38: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x38));
-	printk(KERN_DEBUG
-	       "  0x19: DMA A lower cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x19));
-	printk("  0x39: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x39));
-	printk(KERN_DEBUG
-	       "  0x1a: ---             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1a));
-	printk("  0x3a: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3a));
-	printk(KERN_DEBUG
-	       "  0x1b: ---             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1b));
-	printk("  0x3b: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3b));
-	printk(KERN_DEBUG
-	       "  0x1c: DMA C upper cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1c));
-	printk("  0x3c: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3c));
-	printk(KERN_DEBUG
-	       "  0x1d: DMA C upper cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1d));
-	printk("  0x3d: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3d));
-	printk(KERN_DEBUG
-	       "  0x1e: PCM rate low    = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1e));
-	printk("  0x3e: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3e));
-	printk(KERN_DEBUG
-	       "  0x1f: PCM rate high   = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1f));
-	printk("  0x3f: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3f));
+	dev_dbg(sonic->card->dev,
+		"SV REGS:          INDEX = 0x%02x                   STATUS = 0x%02x\n",
+		inb(SV_REG(sonic, INDEX)), inb(SV_REG(sonic, STATUS)));
+	dev_dbg(sonic->card->dev,
+		"  0x00: left input      = 0x%02x    0x20: synth rate low  = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x00), snd_sonicvibes_in(sonic, 0x20));
+	dev_dbg(sonic->card->dev,
+		"  0x01: right input     = 0x%02x    0x21: synth rate high = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x01), snd_sonicvibes_in(sonic, 0x21));
+	dev_dbg(sonic->card->dev,
+		"  0x02: left AUX1       = 0x%02x    0x22: ADC clock       = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x02), snd_sonicvibes_in(sonic, 0x22));
+	dev_dbg(sonic->card->dev,
+		"  0x03: right AUX1      = 0x%02x    0x23: ADC alt rate    = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x03), snd_sonicvibes_in(sonic, 0x23));
+	dev_dbg(sonic->card->dev,
+		"  0x04: left CD         = 0x%02x    0x24: ADC pll M       = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x04), snd_sonicvibes_in(sonic, 0x24));
+	dev_dbg(sonic->card->dev,
+		"  0x05: right CD        = 0x%02x    0x25: ADC pll N       = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x05), snd_sonicvibes_in(sonic, 0x25));
+	dev_dbg(sonic->card->dev,
+		"  0x06: left line       = 0x%02x    0x26: Synth pll M     = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x06), snd_sonicvibes_in(sonic, 0x26));
+	dev_dbg(sonic->card->dev,
+		"  0x07: right line      = 0x%02x    0x27: Synth pll N     = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x07), snd_sonicvibes_in(sonic, 0x27));
+	dev_dbg(sonic->card->dev,
+		"  0x08: MIC             = 0x%02x    0x28: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x08), snd_sonicvibes_in(sonic, 0x28));
+	dev_dbg(sonic->card->dev,
+		"  0x09: Game port       = 0x%02x    0x29: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x09), snd_sonicvibes_in(sonic, 0x29));
+	dev_dbg(sonic->card->dev,
+		"  0x0a: left synth      = 0x%02x    0x2a: MPU401          = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x0a), snd_sonicvibes_in(sonic, 0x2a));
+	dev_dbg(sonic->card->dev,
+		"  0x0b: right synth     = 0x%02x    0x2b: drive ctrl      = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x0b), snd_sonicvibes_in(sonic, 0x2b));
+	dev_dbg(sonic->card->dev,
+		"  0x0c: left AUX2       = 0x%02x    0x2c: SRS space       = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x0c), snd_sonicvibes_in(sonic, 0x2c));
+	dev_dbg(sonic->card->dev,
+		"  0x0d: right AUX2      = 0x%02x    0x2d: SRS center      = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x0d), snd_sonicvibes_in(sonic, 0x2d));
+	dev_dbg(sonic->card->dev,
+		"  0x0e: left analog     = 0x%02x    0x2e: wave source     = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x0e), snd_sonicvibes_in(sonic, 0x2e));
+	dev_dbg(sonic->card->dev,
+		"  0x0f: right analog    = 0x%02x    0x2f: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x0f), snd_sonicvibes_in(sonic, 0x2f));
+	dev_dbg(sonic->card->dev,
+		"  0x10: left PCM        = 0x%02x    0x30: analog power    = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x10), snd_sonicvibes_in(sonic, 0x30));
+	dev_dbg(sonic->card->dev,
+		"  0x11: right PCM       = 0x%02x    0x31: analog power    = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x11), snd_sonicvibes_in(sonic, 0x31));
+	dev_dbg(sonic->card->dev,
+		"  0x12: DMA data format = 0x%02x    0x32: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x12), snd_sonicvibes_in(sonic, 0x32));
+	dev_dbg(sonic->card->dev,
+		"  0x13: P/C enable      = 0x%02x    0x33: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x13), snd_sonicvibes_in(sonic, 0x33));
+	dev_dbg(sonic->card->dev,
+		"  0x14: U/D button      = 0x%02x    0x34: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x14), snd_sonicvibes_in(sonic, 0x34));
+	dev_dbg(sonic->card->dev,
+		"  0x15: revision        = 0x%02x    0x35: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x15), snd_sonicvibes_in(sonic, 0x35));
+	dev_dbg(sonic->card->dev,
+		"  0x16: ADC output ctrl = 0x%02x    0x36: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x16), snd_sonicvibes_in(sonic, 0x36));
+	dev_dbg(sonic->card->dev,
+		"  0x17: ---             = 0x%02x    0x37: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x17), snd_sonicvibes_in(sonic, 0x37));
+	dev_dbg(sonic->card->dev,
+		"  0x18: DMA A upper cnt = 0x%02x    0x38: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x18), snd_sonicvibes_in(sonic, 0x38));
+	dev_dbg(sonic->card->dev,
+		"  0x19: DMA A lower cnt = 0x%02x    0x39: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x19), snd_sonicvibes_in(sonic, 0x39));
+	dev_dbg(sonic->card->dev,
+		"  0x1a: ---             = 0x%02x    0x3a: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x1a), snd_sonicvibes_in(sonic, 0x3a));
+	dev_dbg(sonic->card->dev,
+		"  0x1b: ---             = 0x%02x    0x3b: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x1b), snd_sonicvibes_in(sonic, 0x3b));
+	dev_dbg(sonic->card->dev,
+		"  0x1c: DMA C upper cnt = 0x%02x    0x3c: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x1c), snd_sonicvibes_in(sonic, 0x3c));
+	dev_dbg(sonic->card->dev,
+		"  0x1d: DMA C upper cnt = 0x%02x    0x3d: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x1d), snd_sonicvibes_in(sonic, 0x3d));
+	dev_dbg(sonic->card->dev,
+		"  0x1e: PCM rate low    = 0x%02x    0x3e: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x1e), snd_sonicvibes_in(sonic, 0x3e));
+	dev_dbg(sonic->card->dev,
+		"  0x1f: PCM rate high   = 0x%02x    0x3f: ---             = 0x%02x\n",
+		snd_sonicvibes_in(sonic, 0x1f), snd_sonicvibes_in(sonic, 0x3f));
 }
 
 #endif
@@ -511,8 +511,10 @@ static void snd_sonicvibes_pll(unsigned int rate,
 	*res_m = m;
 	*res_n = n;
 #if 0
-	printk(KERN_DEBUG "metric = %i, xm = %i, xn = %i\n", metric, xm, xn);
-	printk(KERN_DEBUG "pll: m = 0x%x, r = 0x%x, n = 0x%x\n", reg, m, r, n);
+	dev_dbg(sonic->card->dev,
+		"metric = %i, xm = %i, xn = %i\n", metric, xm, xn);
+	dev_dbg(sonic->card->dev,
+		"pll: m = 0x%x, r = 0x%x, n = 0x%x\n", reg, m, r, n);
 #endif
 }
 
@@ -624,7 +626,8 @@ static irqreturn_t snd_sonicvibes_interrupt(int irq, void *dev_id)
 		return IRQ_NONE;
 	if (status == 0xff) {	/* failure */
 		outb(sonic->irqmask = ~0, SV_REG(sonic, IRQMASK));
-		snd_printk(KERN_ERR "IRQ failure - interrupts disabled!!\n");
+		dev_err(sonic->card->dev,
+			"IRQ failure - interrupts disabled!!\n");
 		return IRQ_HANDLED;
 	}
 	if (sonic->pcm) {
@@ -1198,7 +1201,8 @@ static int snd_sonicvibes_create_gameport(struct sonicvibes *sonic)
 
 	sonic->gameport = gp = gameport_allocate_port();
 	if (!gp) {
-		printk(KERN_ERR "sonicvibes: cannot allocate memory for gameport\n");
+		dev_err(sonic->card->dev,
+			"sonicvibes: cannot allocate memory for gameport\n");
 		return -ENOMEM;
 	}
 
@@ -1267,7 +1271,8 @@ static int snd_sonicvibes_create(struct snd_card *card,
 	/* check, if we can restrict PCI DMA transfers to 24 bits */
         if (pci_set_dma_mask(pci, DMA_BIT_MASK(24)) < 0 ||
 	    pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(24)) < 0) {
-		snd_printk(KERN_ERR "architecture does not support 24bit PCI busmaster DMA\n");
+		dev_err(card->dev,
+			"architecture does not support 24bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
                 return -ENXIO;
         }
@@ -1296,7 +1301,7 @@ static int snd_sonicvibes_create(struct snd_card *card,
 
 	if (request_irq(pci->irq, snd_sonicvibes_interrupt, IRQF_SHARED,
 			KBUILD_MODNAME, sonic)) {
-		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		dev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);
 		snd_sonicvibes_free(sonic);
 		return -EBUSY;
 	}
@@ -1310,24 +1315,32 @@ static int snd_sonicvibes_create(struct snd_card *card,
 	if (!dmaa) {
 		dmaa = dmaio;
 		dmaio += 0x10;
-		snd_printk(KERN_INFO "BIOS did not allocate DDMA channel A i/o, allocated at 0x%x\n", dmaa);
+		dev_info(card->dev,
+			 "BIOS did not allocate DDMA channel A i/o, allocated at 0x%x\n",
+			 dmaa);
 	}
 	if (!dmac) {
 		dmac = dmaio;
 		dmaio += 0x10;
-		snd_printk(KERN_INFO "BIOS did not allocate DDMA channel C i/o, allocated at 0x%x\n", dmac);
+		dev_info(card->dev,
+			 "BIOS did not allocate DDMA channel C i/o, allocated at 0x%x\n",
+			 dmac);
 	}
 	pci_write_config_dword(pci, 0x40, dmaa);
 	pci_write_config_dword(pci, 0x48, dmac);
 
 	if ((sonic->res_dmaa = request_region(dmaa, 0x10, "S3 SonicVibes DDMA-A")) == NULL) {
 		snd_sonicvibes_free(sonic);
-		snd_printk(KERN_ERR "unable to grab DDMA-A port at 0x%x-0x%x\n", dmaa, dmaa + 0x10 - 1);
+		dev_err(card->dev,
+			"unable to grab DDMA-A port at 0x%x-0x%x\n",
+			dmaa, dmaa + 0x10 - 1);
 		return -EBUSY;
 	}
 	if ((sonic->res_dmac = request_region(dmac, 0x10, "S3 SonicVibes DDMA-C")) == NULL) {
 		snd_sonicvibes_free(sonic);
-		snd_printk(KERN_ERR "unable to grab DDMA-C port at 0x%x-0x%x\n", dmac, dmac + 0x10 - 1);
+		dev_err(card->dev,
+			"unable to grab DDMA-C port at 0x%x-0x%x\n",
+			dmac, dmac + 0x10 - 1);
 		return -EBUSY;
 	}
 

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 2a46bf98af30..9ff408fff7b0 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1392,8 +1392,6 @@ static int snd_sonicvibes_create(struct snd_card *card,
 
 	snd_sonicvibes_proc_init(sonic);
 
-	snd_card_set_dev(card, &pci->dev);
-
 	*rsonic = sonic;
 	return 0;
 }
@@ -1459,7 +1457,8 @@ static int snd_sonic_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
  
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
+			   0, &card);
 	if (err < 0)
 		return err;
 	for (idx = 0; idx < 5; idx++) {

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index a2e7686e7ae3..2a46bf98af30 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1528,7 +1528,6 @@ static int snd_sonic_probe(struct pci_dev *pci,
 static void snd_sonic_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 static struct pci_driver sonicvibes_driver = {

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index baa9946bedf0..a2e7686e7ae3 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -877,7 +877,8 @@ static struct snd_pcm_ops snd_sonicvibes_capture_ops = {
 	.pointer =	snd_sonicvibes_capture_pointer,
 };
 
-static int __devinit snd_sonicvibes_pcm(struct sonicvibes * sonic, int device, struct snd_pcm ** rpcm)
+static int snd_sonicvibes_pcm(struct sonicvibes *sonic, int device,
+			      struct snd_pcm **rpcm)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -1087,7 +1088,7 @@ static int snd_sonicvibes_put_double(struct snd_kcontrol *kcontrol, struct snd_c
 	return change;
 }
 
-static struct snd_kcontrol_new snd_sonicvibes_controls[] __devinitdata = {
+static struct snd_kcontrol_new snd_sonicvibes_controls[] = {
 SONICVIBES_DOUBLE("Capture Volume", 0, SV_IREG_LEFT_ADC, SV_IREG_RIGHT_ADC, 0, 0, 15, 0),
 SONICVIBES_DOUBLE("Aux Playback Switch", 0, SV_IREG_LEFT_AUX1, SV_IREG_RIGHT_AUX1, 7, 7, 1, 1),
 SONICVIBES_DOUBLE("Aux Playback Volume", 0, SV_IREG_LEFT_AUX1, SV_IREG_RIGHT_AUX1, 0, 0, 31, 1),
@@ -1118,7 +1119,7 @@ static void snd_sonicvibes_master_free(struct snd_kcontrol *kcontrol)
 	sonic->master_volume = NULL;
 }
 
-static int __devinit snd_sonicvibes_mixer(struct sonicvibes * sonic)
+static int snd_sonicvibes_mixer(struct sonicvibes *sonic)
 {
 	struct snd_card *card;
 	struct snd_kcontrol *kctl;
@@ -1175,7 +1176,7 @@ static void snd_sonicvibes_proc_read(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "MIDI to ext. Tx  : %s\n", tmp & 0x04 ? "on" : "off");
 }
 
-static void __devinit snd_sonicvibes_proc_init(struct sonicvibes * sonic)
+static void snd_sonicvibes_proc_init(struct sonicvibes *sonic)
 {
 	struct snd_info_entry *entry;
 
@@ -1188,10 +1189,10 @@ static void __devinit snd_sonicvibes_proc_init(struct sonicvibes * sonic)
  */
 
 #ifdef SUPPORT_JOYSTICK
-static struct snd_kcontrol_new snd_sonicvibes_game_control __devinitdata =
+static struct snd_kcontrol_new snd_sonicvibes_game_control =
 SONICVIBES_SINGLE("Joystick Speed", 0, SV_IREG_GAME_PORT, 1, 15, 0);
 
-static int __devinit snd_sonicvibes_create_gameport(struct sonicvibes *sonic)
+static int snd_sonicvibes_create_gameport(struct sonicvibes *sonic)
 {
 	struct gameport *gp;
 
@@ -1246,11 +1247,11 @@ static int snd_sonicvibes_dev_free(struct snd_device *device)
 	return snd_sonicvibes_free(sonic);
 }
 
-static int __devinit snd_sonicvibes_create(struct snd_card *card,
-					struct pci_dev *pci,
-					int reverb,
-					int mge,
-					struct sonicvibes ** rsonic)
+static int snd_sonicvibes_create(struct snd_card *card,
+				 struct pci_dev *pci,
+				 int reverb,
+				 int mge,
+				 struct sonicvibes **rsonic)
 {
 	struct sonicvibes *sonic;
 	unsigned int dmaa, dmac;
@@ -1401,7 +1402,7 @@ static int __devinit snd_sonicvibes_create(struct snd_card *card,
  *  MIDI section
  */
 
-static struct snd_kcontrol_new snd_sonicvibes_midi_controls[] __devinitdata = {
+static struct snd_kcontrol_new snd_sonicvibes_midi_controls[] = {
 SONICVIBES_SINGLE("SonicVibes Wave Source RAM", 0, SV_IREG_WAVE_SOURCE, 0, 1, 0),
 SONICVIBES_SINGLE("SonicVibes Wave Source RAM+ROM", 0, SV_IREG_WAVE_SOURCE, 1, 1, 0),
 SONICVIBES_SINGLE("SonicVibes Onboard Synth", 0, SV_IREG_MPU401, 0, 1, 0),
@@ -1422,8 +1423,8 @@ static void snd_sonicvibes_midi_input_close(struct snd_mpu401 * mpu)
 	outb(sonic->irqmask |= SV_MIDI_MASK, SV_REG(sonic, IRQMASK));
 }
 
-static int __devinit snd_sonicvibes_midi(struct sonicvibes * sonic,
-					 struct snd_rawmidi *rmidi)
+static int snd_sonicvibes_midi(struct sonicvibes *sonic,
+			       struct snd_rawmidi *rmidi)
 {
 	struct snd_mpu401 * mpu = rmidi->private_data;
 	struct snd_card *card = sonic->card;
@@ -1441,8 +1442,8 @@ static int __devinit snd_sonicvibes_midi(struct sonicvibes * sonic,
 	return 0;
 }
 
-static int __devinit snd_sonic_probe(struct pci_dev *pci,
-				     const struct pci_device_id *pci_id)
+static int snd_sonic_probe(struct pci_dev *pci,
+			   const struct pci_device_id *pci_id)
 {
 	static int dev;
 	struct snd_card *card;
@@ -1524,7 +1525,7 @@ static int __devinit snd_sonic_probe(struct pci_dev *pci,
 	return 0;
 }
 
-static void __devexit snd_sonic_remove(struct pci_dev *pci)
+static void snd_sonic_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -1534,7 +1535,7 @@ static struct pci_driver sonicvibes_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_sonic_ids,
 	.probe = snd_sonic_probe,
-	.remove = __devexit_p(snd_sonic_remove),
+	.remove = snd_sonic_remove,
 };
 
 module_pci_driver(sonicvibes_driver);

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 54cc802050f7..baa9946bedf0 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1530,22 +1530,11 @@ static void __devexit snd_sonic_remove(struct pci_dev *pci)
 	pci_set_drvdata(pci, NULL);
 }
 
-static struct pci_driver driver = {
+static struct pci_driver sonicvibes_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_sonic_ids,
 	.probe = snd_sonic_probe,
 	.remove = __devexit_p(snd_sonic_remove),
 };
 
-static int __init alsa_card_sonicvibes_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit alsa_card_sonicvibes_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(alsa_card_sonicvibes_init)
-module_exit(alsa_card_sonicvibes_exit)
+module_pci_driver(sonicvibes_driver);

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 31b6ad3ab1dc..54cc802050f7 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -52,9 +52,9 @@ MODULE_SUPPORTED_DEVICE("{{S3,SonicVibes PCI}}");
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
-static int reverb[SNDRV_CARDS];
-static int mge[SNDRV_CARDS];
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static bool reverb[SNDRV_CARDS];
+static bool mge[SNDRV_CARDS];
 static unsigned int dmaio = 0x7a00;	/* DDMA i/o address */
 
 module_param_array(index, int, NULL, 0444);

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index c5008166cf1f..31b6ad3ab1dc 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -28,7 +28,7 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <linux/dma-mapping.h>
 
 #include <sound/core.h>

commit dba8b46992c55946d3b092934f581a343403118f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Sep 13 11:24:41 2011 +0200

    ALSA: mpu401: clean up interrupt specification
    
    The semantics of snd_mpu401_uart_new()'s interrupt parameters are
    somewhat counterintuitive:  To prevent the function from allocating its
    own interrupt, either the irq number must be invalid, or the irq_flags
    parameter must be zero.  At the same time, the irq parameter being
    invalid specifies that the mpu401 code has to work without an interrupt
    allocated by the caller.  This implies that, if there is an interrupt
    and it is allocated by the caller, the irq parameter must be set to
    a valid-looking number which then isn't actually used.
    
    With the removal of IRQF_DISABLED, zero becomes a valid irq_flags value,
    which forces us to handle the parameters differently.
    
    This patch introduces a new flag MPU401_INFO_IRQ_HOOK for when the
    device interrupt is handled by the caller, and makes the allocation of
    the interrupt to depend only on the irq parameter.  As suggested by
    Takashi, the irq_flags parameter was dropped because, when used, it had
    the constant value IRQF_DISABLED.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 2571a67b389a..c5008166cf1f 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1493,9 +1493,10 @@ static int __devinit snd_sonic_probe(struct pci_dev *pci,
 		return err;
 	}
 	if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_SONICVIBES,
-				       sonic->midi_port, MPU401_INFO_INTEGRATED,
-				       sonic->irq, 0,
-				       &midi_uart)) < 0) {
+				       sonic->midi_port,
+				       MPU401_INFO_INTEGRATED |
+				       MPU401_INFO_IRQ_HOOK,
+				       -1, &midi_uart)) < 0) {
 		snd_card_free(card);
 		return err;
 	}

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 860903e10f0f..2571a67b389a 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1294,7 +1294,7 @@ static int __devinit snd_sonicvibes_create(struct snd_card *card,
 	sonic->game_port = pci_resource_start(pci, 4);
 
 	if (request_irq(pci->irq, snd_sonicvibes_interrupt, IRQF_SHARED,
-			"S3 SonicVibes", sonic)) {
+			KBUILD_MODNAME, sonic)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_sonicvibes_free(sonic);
 		return -EBUSY;

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 337b9facadfd..860903e10f0f 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1530,7 +1530,7 @@ static void __devexit snd_sonic_remove(struct pci_dev *pci)
 }
 
 static struct pci_driver driver = {
-	.name = "S3 SonicVibes",
+	.name = KBUILD_MODNAME,
 	.id_table = snd_sonic_ids,
 	.probe = snd_sonic_probe,
 	.remove = __devexit_p(snd_sonic_remove),

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 1f6406c4534d..337b9facadfd 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -242,7 +242,7 @@ struct sonicvibes {
 #endif
 };
 
-static struct pci_device_id snd_sonic_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_sonic_ids) = {
 	{ PCI_VDEVICE(S3, 0xca00), 0, },
         { 0, }
 };

commit 28d27aae9432c300857722a917be4065c6d7abff
Author: Joe Perches <joe@perches.com>
Date:   Wed Jun 24 22:13:35 2009 -0700

    sound: Use PCI_VDEVICE
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 7dc60ad4772e..1f6406c4534d 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -243,7 +243,7 @@ struct sonicvibes {
 };
 
 static struct pci_device_id snd_sonic_ids[] = {
-	{ 0x5333, 0xca00, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
+	{ PCI_VDEVICE(S3, 0xca00), 0, },
         { 0, }
 };
 

commit 2f4f27d42a301ed147e50c2edbcd27bb8990bc8e
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:18 2009 -0700

    dma-mapping: replace all DMA_24BIT_MASK macro with DMA_BIT_MASK(24)
    
    Replace all DMA_24BIT_MASK macro with DMA_BIT_MASK(24)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index d989215f3556..7dc60ad4772e 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1264,8 +1264,8 @@ static int __devinit snd_sonicvibes_create(struct snd_card *card,
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 	/* check, if we can restrict PCI DMA transfers to 24 bits */
-        if (pci_set_dma_mask(pci, DMA_24BIT_MASK) < 0 ||
-	    pci_set_consistent_dma_mask(pci, DMA_24BIT_MASK) < 0) {
+        if (pci_set_dma_mask(pci, DMA_BIT_MASK(24)) < 0 ||
+	    pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(24)) < 0) {
 		snd_printk(KERN_ERR "architecture does not support 24bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
                 return -ENXIO;

commit e0d2054fd3cf167395390dc1758644486c782707
Merge: d807500a2472 c468ac29e63b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:35:50 2009 +0100

    Merge branch 'topic/misc' into for-linus

commit ee419653a38de93b75a577851d9e4003cf0bbe07
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 16:11:31 2009 +0100

    ALSA: Fix missing KERN_* prefix to printk in sound/pci
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index cd408b86c839..e922b1887b1d 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -273,7 +273,8 @@ static inline void snd_sonicvibes_setdmaa(struct sonicvibes * sonic,
 	outl(count, sonic->dmaa_port + SV_DMA_COUNT0);
 	outb(0x18, sonic->dmaa_port + SV_DMA_MODE);
 #if 0
-	printk("program dmaa: addr = 0x%x, paddr = 0x%x\n", addr, inl(sonic->dmaa_port + SV_DMA_ADDR0));
+	printk(KERN_DEBUG "program dmaa: addr = 0x%x, paddr = 0x%x\n",
+	       addr, inl(sonic->dmaa_port + SV_DMA_ADDR0));
 #endif
 }
 
@@ -288,7 +289,8 @@ static inline void snd_sonicvibes_setdmac(struct sonicvibes * sonic,
 	outl(count, sonic->dmac_port + SV_DMA_COUNT0);
 	outb(0x14, sonic->dmac_port + SV_DMA_MODE);
 #if 0
-	printk("program dmac: addr = 0x%x, paddr = 0x%x\n", addr, inl(sonic->dmac_port + SV_DMA_ADDR0));
+	printk(KERN_DEBUG "program dmac: addr = 0x%x, paddr = 0x%x\n",
+	       addr, inl(sonic->dmac_port + SV_DMA_ADDR0));
 #endif
 }
 
@@ -355,71 +357,104 @@ static unsigned char snd_sonicvibes_in(struct sonicvibes * sonic, unsigned char
 #if 0
 static void snd_sonicvibes_debug(struct sonicvibes * sonic)
 {
-	printk("SV REGS:          INDEX = 0x%02x  ", inb(SV_REG(sonic, INDEX)));
+	printk(KERN_DEBUG
+	       "SV REGS:          INDEX = 0x%02x  ", inb(SV_REG(sonic, INDEX)));
 	printk("                 STATUS = 0x%02x\n", inb(SV_REG(sonic, STATUS)));
-	printk("  0x00: left input      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x00));
+	printk(KERN_DEBUG
+	       "  0x00: left input      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x00));
 	printk("  0x20: synth rate low  = 0x%02x\n", snd_sonicvibes_in(sonic, 0x20));
-	printk("  0x01: right input     = 0x%02x  ", snd_sonicvibes_in(sonic, 0x01));
+	printk(KERN_DEBUG
+	       "  0x01: right input     = 0x%02x  ", snd_sonicvibes_in(sonic, 0x01));
 	printk("  0x21: synth rate high = 0x%02x\n", snd_sonicvibes_in(sonic, 0x21));
-	printk("  0x02: left AUX1       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x02));
+	printk(KERN_DEBUG
+	       "  0x02: left AUX1       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x02));
 	printk("  0x22: ADC clock       = 0x%02x\n", snd_sonicvibes_in(sonic, 0x22));
-	printk("  0x03: right AUX1      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x03));
+	printk(KERN_DEBUG
+	       "  0x03: right AUX1      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x03));
 	printk("  0x23: ADC alt rate    = 0x%02x\n", snd_sonicvibes_in(sonic, 0x23));
-	printk("  0x04: left CD         = 0x%02x  ", snd_sonicvibes_in(sonic, 0x04));
+	printk(KERN_DEBUG
+	       "  0x04: left CD         = 0x%02x  ", snd_sonicvibes_in(sonic, 0x04));
 	printk("  0x24: ADC pll M       = 0x%02x\n", snd_sonicvibes_in(sonic, 0x24));
-	printk("  0x05: right CD        = 0x%02x  ", snd_sonicvibes_in(sonic, 0x05));
+	printk(KERN_DEBUG
+	       "  0x05: right CD        = 0x%02x  ", snd_sonicvibes_in(sonic, 0x05));
 	printk("  0x25: ADC pll N       = 0x%02x\n", snd_sonicvibes_in(sonic, 0x25));
-	printk("  0x06: left line       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x06));
+	printk(KERN_DEBUG
+	       "  0x06: left line       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x06));
 	printk("  0x26: Synth pll M     = 0x%02x\n", snd_sonicvibes_in(sonic, 0x26));
-	printk("  0x07: right line      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x07));
+	printk(KERN_DEBUG
+	       "  0x07: right line      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x07));
 	printk("  0x27: Synth pll N     = 0x%02x\n", snd_sonicvibes_in(sonic, 0x27));
-	printk("  0x08: MIC             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x08));
+	printk(KERN_DEBUG
+	       "  0x08: MIC             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x08));
 	printk("  0x28: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x28));
-	printk("  0x09: Game port       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x09));
+	printk(KERN_DEBUG
+	       "  0x09: Game port       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x09));
 	printk("  0x29: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x29));
-	printk("  0x0a: left synth      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0a));
+	printk(KERN_DEBUG
+	       "  0x0a: left synth      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0a));
 	printk("  0x2a: MPU401          = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2a));
-	printk("  0x0b: right synth     = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0b));
+	printk(KERN_DEBUG
+	       "  0x0b: right synth     = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0b));
 	printk("  0x2b: drive ctrl      = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2b));
-	printk("  0x0c: left AUX2       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0c));
+	printk(KERN_DEBUG
+	       "  0x0c: left AUX2       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0c));
 	printk("  0x2c: SRS space       = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2c));
-	printk("  0x0d: right AUX2      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0d));
+	printk(KERN_DEBUG
+	       "  0x0d: right AUX2      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0d));
 	printk("  0x2d: SRS center      = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2d));
-	printk("  0x0e: left analog     = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0e));
+	printk(KERN_DEBUG
+	       "  0x0e: left analog     = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0e));
 	printk("  0x2e: wave source     = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2e));
-	printk("  0x0f: right analog    = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0f));
+	printk(KERN_DEBUG
+	       "  0x0f: right analog    = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0f));
 	printk("  0x2f: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2f));
-	printk("  0x10: left PCM        = 0x%02x  ", snd_sonicvibes_in(sonic, 0x10));
+	printk(KERN_DEBUG
+	       "  0x10: left PCM        = 0x%02x  ", snd_sonicvibes_in(sonic, 0x10));
 	printk("  0x30: analog power    = 0x%02x\n", snd_sonicvibes_in(sonic, 0x30));
-	printk("  0x11: right PCM       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x11));
+	printk(KERN_DEBUG
+	       "  0x11: right PCM       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x11));
 	printk("  0x31: analog power    = 0x%02x\n", snd_sonicvibes_in(sonic, 0x31));
-	printk("  0x12: DMA data format = 0x%02x  ", snd_sonicvibes_in(sonic, 0x12));
+	printk(KERN_DEBUG
+	       "  0x12: DMA data format = 0x%02x  ", snd_sonicvibes_in(sonic, 0x12));
 	printk("  0x32: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x32));
-	printk("  0x13: P/C enable      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x13));
+	printk(KERN_DEBUG
+	       "  0x13: P/C enable      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x13));
 	printk("  0x33: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x33));
-	printk("  0x14: U/D button      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x14));
+	printk(KERN_DEBUG
+	       "  0x14: U/D button      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x14));
 	printk("  0x34: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x34));
-	printk("  0x15: revision        = 0x%02x  ", snd_sonicvibes_in(sonic, 0x15));
+	printk(KERN_DEBUG
+	       "  0x15: revision        = 0x%02x  ", snd_sonicvibes_in(sonic, 0x15));
 	printk("  0x35: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x35));
-	printk("  0x16: ADC output ctrl = 0x%02x  ", snd_sonicvibes_in(sonic, 0x16));
+	printk(KERN_DEBUG
+	       "  0x16: ADC output ctrl = 0x%02x  ", snd_sonicvibes_in(sonic, 0x16));
 	printk("  0x36: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x36));
-	printk("  0x17: ---             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x17));
+	printk(KERN_DEBUG
+	       "  0x17: ---             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x17));
 	printk("  0x37: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x37));
-	printk("  0x18: DMA A upper cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x18));
+	printk(KERN_DEBUG
+	       "  0x18: DMA A upper cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x18));
 	printk("  0x38: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x38));
-	printk("  0x19: DMA A lower cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x19));
+	printk(KERN_DEBUG
+	       "  0x19: DMA A lower cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x19));
 	printk("  0x39: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x39));
-	printk("  0x1a: ---             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1a));
+	printk(KERN_DEBUG
+	       "  0x1a: ---             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1a));
 	printk("  0x3a: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3a));
-	printk("  0x1b: ---             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1b));
+	printk(KERN_DEBUG
+	       "  0x1b: ---             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1b));
 	printk("  0x3b: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3b));
-	printk("  0x1c: DMA C upper cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1c));
+	printk(KERN_DEBUG
+	       "  0x1c: DMA C upper cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1c));
 	printk("  0x3c: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3c));
-	printk("  0x1d: DMA C upper cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1d));
+	printk(KERN_DEBUG
+	       "  0x1d: DMA C upper cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1d));
 	printk("  0x3d: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3d));
-	printk("  0x1e: PCM rate low    = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1e));
+	printk(KERN_DEBUG
+	       "  0x1e: PCM rate low    = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1e));
 	printk("  0x3e: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3e));
-	printk("  0x1f: PCM rate high   = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1f));
+	printk(KERN_DEBUG
+	       "  0x1f: PCM rate high   = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1f));
 	printk("  0x3f: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3f));
 }
 
@@ -476,8 +511,8 @@ static void snd_sonicvibes_pll(unsigned int rate,
 	*res_m = m;
 	*res_n = n;
 #if 0
-	printk("metric = %i, xm = %i, xn = %i\n", metric, xm, xn);
-	printk("pll: m = 0x%x, r = 0x%x, n = 0x%x\n", reg, m, r, n);
+	printk(KERN_DEBUG "metric = %i, xm = %i, xn = %i\n", metric, xm, xn);
+	printk(KERN_DEBUG "pll: m = 0x%x, r = 0x%x, n = 0x%x\n", reg, m, r, n);
 #endif
 }
 

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index cd408b86c839..c5601b0ad7cc 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1423,9 +1423,9 @@ static int __devinit snd_sonic_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
  
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
-	if (card == NULL)
-		return -ENOMEM;
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	if (err < 0)
+		return err;
 	for (idx = 0; idx < 5; idx++) {
 		if (pci_resource_start(pci, idx) == 0 ||
 		    !(pci_resource_flags(pci, idx) & IORESOURCE_IO)) {

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 0d3d305b0a0b..cd408b86c839 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -534,8 +534,8 @@ static int snd_sonicvibes_hw_constraint_dac_rate(struct snd_pcm_hw_params *param
 			params->rate_den = 1;
 		} else {
 			snd_sonicvibes_pll(rate, &r, &m, &n);
-			snd_assert((SV_REFFREQUENCY % 16) == 0, return -EINVAL);
-			snd_assert((SV_ADCMULT % 512) == 0, return -EINVAL);
+			snd_BUG_ON(SV_REFFREQUENCY % 16);
+			snd_BUG_ON(SV_ADCMULT % 512);
 			params->rate_num = (SV_REFFREQUENCY/16) * (n+2) * r;
 			params->rate_den = (SV_ADCMULT/512) * (m+2);
 		}
@@ -849,7 +849,8 @@ static int __devinit snd_sonicvibes_pcm(struct sonicvibes * sonic, int device, s
 
 	if ((err = snd_pcm_new(sonic->card, "s3_86c617", device, 1, 1, &pcm)) < 0)
 		return err;
-	snd_assert(pcm != NULL, return -EINVAL);
+	if (snd_BUG_ON(!pcm))
+		return -EINVAL;
 
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_sonicvibes_playback_ops);
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_sonicvibes_capture_ops);
@@ -1089,7 +1090,8 @@ static int __devinit snd_sonicvibes_mixer(struct sonicvibes * sonic)
 	unsigned int idx;
 	int err;
 
-	snd_assert(sonic != NULL && sonic->card != NULL, return -EINVAL);
+	if (snd_BUG_ON(!sonic || !sonic->card))
+		return -EINVAL;
 	card = sonic->card;
 	strcpy(card->mixername, "S3 SonicVibes");
 

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 44a7f5fad573..0d3d305b0a0b 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -22,7 +22,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 9f25d93cbec2..44a7f5fad573 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1,6 +1,6 @@
 /*
  *  Driver for S3 SonicVibes soundcard
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
  *
  *  BUGS:
  *    It looks like 86c617 rev 3 doesn't supports DDMA buffers above 16MB?
@@ -42,7 +42,7 @@
 
 #include <asm/io.h>
 
-MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");
 MODULE_DESCRIPTION("S3 SonicVibes PCI");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{S3,SonicVibes PCI}}");

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index f9b8afabda9c..9f25d93cbec2 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1195,7 +1195,7 @@ static int snd_sonicvibes_free(struct sonicvibes *sonic)
 	pci_write_config_dword(sonic->pci, 0x40, sonic->dmaa_port);
 	pci_write_config_dword(sonic->pci, 0x48, sonic->dmac_port);
 	if (sonic->irq >= 0)
-		free_irq(sonic->irq, (void *)sonic);
+		free_irq(sonic->irq, sonic);
 	release_and_free_resource(sonic->res_dmaa);
 	release_and_free_resource(sonic->res_dmac);
 	pci_release_regions(sonic->pci);
@@ -1257,7 +1257,8 @@ static int __devinit snd_sonicvibes_create(struct snd_card *card,
 	sonic->midi_port = pci_resource_start(pci, 3);
 	sonic->game_port = pci_resource_start(pci, 4);
 
-	if (request_irq(pci->irq, snd_sonicvibes_interrupt, IRQF_DISABLED|IRQF_SHARED, "S3 SonicVibes", (void *)sonic)) {
+	if (request_irq(pci->irq, snd_sonicvibes_interrupt, IRQF_SHARED,
+			"S3 SonicVibes", sonic)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_sonicvibes_free(sonic);
 		return -EBUSY;

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index e5d4def1aa6f..f9b8afabda9c 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -580,7 +580,7 @@ static int snd_sonicvibes_trigger(struct sonicvibes * sonic, int what, int cmd)
 	return result;
 }
 
-static irqreturn_t snd_sonicvibes_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_sonicvibes_interrupt(int irq, void *dev_id)
 {
 	struct sonicvibes *sonic = dev_id;
 	unsigned char status;
@@ -601,7 +601,7 @@ static irqreturn_t snd_sonicvibes_interrupt(int irq, void *dev_id, struct pt_reg
 	}
 	if (sonic->rmidi) {
 		if (status & SV_MIDI_IRQ)
-			snd_mpu401_uart_interrupt(irq, sonic->rmidi->private_data, regs);
+			snd_mpu401_uart_interrupt(irq, sonic->rmidi->private_data);
 	}
 	if (status & SV_UD_IRQ) {
 		unsigned char udreg;

commit f40b68903ccd511ea9d658b4bce319dd032a265a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 16:51:05 2006 +0200

    [ALSA] Fix section mismatch errors in ALSA PCI drivers
    
    Fixed 'section mismatch' errors in ALSA PCI drivers:
    - removed invalid __devinitdata from pci id tables
    - fix/remove __devinit of functions called in suspend/resume
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index c4303418668b..e5d4def1aa6f 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -243,7 +243,7 @@ struct sonicvibes {
 #endif
 };
 
-static struct pci_device_id snd_sonic_ids[] __devinitdata = {
+static struct pci_device_id snd_sonic_ids[] = {
 	{ 0x5333, 0xca00, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
         { 0, }
 };

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index e5511606af04..c4303418668b 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1257,7 +1257,7 @@ static int __devinit snd_sonicvibes_create(struct snd_card *card,
 	sonic->midi_port = pci_resource_start(pci, 3);
 	sonic->game_port = pci_resource_start(pci, 4);
 
-	if (request_irq(pci->irq, snd_sonicvibes_interrupt, SA_INTERRUPT|SA_SHIRQ, "S3 SonicVibes", (void *)sonic)) {
+	if (request_irq(pci->irq, snd_sonicvibes_interrupt, IRQF_DISABLED|IRQF_SHARED, "S3 SonicVibes", (void *)sonic)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_sonicvibes_free(sonic);
 		return -EBUSY;

commit aa0a2ddc54fa8a22060d17a9ca7bbc4bcc51f260
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 14:50:27 2006 -0700

    [PATCH] 64bit resource: fix up printks for resources in sound drivers
    
    This is needed if we wish to change the size of the resource structures.
    
    Based on an original patch from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index dcf402948347..e5511606af04 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1441,10 +1441,10 @@ static int __devinit snd_sonic_probe(struct pci_dev *pci,
 
 	strcpy(card->driver, "SonicVibes");
 	strcpy(card->shortname, "S3 SonicVibes");
-	sprintf(card->longname, "%s rev %i at 0x%lx, irq %i",
+	sprintf(card->longname, "%s rev %i at 0x%llx, irq %i",
 		card->shortname,
 		sonic->revision,
-		pci_resource_start(pci, 1),
+		(unsigned long long)pci_resource_start(pci, 1),
 		sonic->irq);
 
 	if ((err = snd_sonicvibes_pcm(sonic, 0, NULL)) < 0) {

commit 302e4c2f9e2b9f07c69649782330a61c60001ac4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue May 23 13:24:30 2006 +0200

    [ALSA] Change an arugment of snd_mpu401_uart_new() to bit flags
    
    Change the 5th argument of snd_mpu401_uart_new() to bit flags
    instead of a boolean.  The argument takes bits that consist of
    MPU401_INFO_XXX flags.
    The callers that used the value 1 there are replaced with
    MPU401_INFO_INTEGRATED.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 51775706c843..dcf402948347 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1456,7 +1456,7 @@ static int __devinit snd_sonic_probe(struct pci_dev *pci,
 		return err;
 	}
 	if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_SONICVIBES,
-				       sonic->midi_port, 1,
+				       sonic->midi_port, MPU401_INFO_INTEGRATED,
 				       sonic->irq, 0,
 				       &midi_uart)) < 0) {
 		snd_card_free(card);

commit 6581f4e74d8541dd7d579f64e94822622cbb1654
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 17 17:14:51 2006 +0200

    [ALSA] Remove zero-initialization of static variables
    
    Removed zero-initializations of static variables.
    A tiny optimization.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index a78304172921..51775706c843 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -54,8 +54,8 @@ MODULE_SUPPORTED_DEVICE("{{S3,SonicVibes PCI}}");
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
-static int reverb[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
-static int mge[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
+static int reverb[SNDRV_CARDS];
+static int mge[SNDRV_CARDS];
 static unsigned int dmaio = 0x7a00;	/* DDMA i/o address */
 
 module_param_array(index, int, NULL, 0444);

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 91f8bf3ae9fa..a78304172921 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1144,7 +1144,7 @@ static void __devinit snd_sonicvibes_proc_init(struct sonicvibes * sonic)
 	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(sonic->card, "sonicvibes", &entry))
-		snd_info_set_text_ops(entry, sonic, 1024, snd_sonicvibes_proc_read);
+		snd_info_set_text_ops(entry, sonic, snd_sonicvibes_proc_read);
 }
 
 /*

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 2d66a09fe5ee..91f8bf3ae9fa 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -243,7 +243,7 @@ struct sonicvibes {
 #endif
 };
 
-static struct pci_device_id snd_sonic_ids[] = {
+static struct pci_device_id snd_sonic_ids[] __devinitdata = {
 	{ 0x5333, 0xca00, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
         { 0, }
 };

commit 910638ae7ed4be27d6af55f6c9b5bf54b838e78b
Author: Matthias Gehre <M.Gehre@gmx.de>
Date:   Tue Mar 28 01:56:48 2006 -0800

    [PATCH] Replace 0xff.. with correct DMA_xBIT_MASK
    
    Replace all occurences of 0xff..  in calls to function pci_set_dma_mask()
    and pci_set_consistant_dma_mask() with the corresponding DMA_xBIT_MASK from
    linux/dma-mapping.h.
    
    Signed-off-by: Matthias Gehre <M.Gehre@gmx.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 7bbea3738b8a..2d66a09fe5ee 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -30,6 +30,7 @@
 #include <linux/slab.h>
 #include <linux/gameport.h>
 #include <linux/moduleparam.h>
+#include <linux/dma-mapping.h>
 
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -1227,8 +1228,8 @@ static int __devinit snd_sonicvibes_create(struct snd_card *card,
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
 	/* check, if we can restrict PCI DMA transfers to 24 bits */
-        if (pci_set_dma_mask(pci, 0x00ffffff) < 0 ||
-	    pci_set_consistent_dma_mask(pci, 0x00ffffff) < 0) {
+        if (pci_set_dma_mask(pci, DMA_24BIT_MASK) < 0 ||
+	    pci_set_consistent_dma_mask(pci, DMA_24BIT_MASK) < 0) {
 		snd_printk(KERN_ERR "architecture does not support 24bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
                 return -ENXIO;

commit 016e401c2e64ce5c440b1f68eae4a53273aa0bc2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:05:57 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI Sonicvibes
    
    Modules: SonicVibes driver
    
    Remove xxx_t typedefs from the PCI Sonicvibes driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index b66459f69c0b..7bbea3738b8a 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -195,9 +195,7 @@ MODULE_PARM_DESC(dmaio, "DDMA i/o base address for S3 SonicVibes soundcard.");
 
  */
 
-typedef struct _snd_sonicvibes sonicvibes_t;
-
-struct _snd_sonicvibes {
+struct sonicvibes {
 	unsigned long dma1size;
 	unsigned long dma2size;
 	int irq;
@@ -224,20 +222,20 @@ struct _snd_sonicvibes {
 	unsigned int mode;
 
 	struct pci_dev *pci;
-	snd_card_t *card;
-	snd_pcm_t *pcm;
-	snd_pcm_substream_t *playback_substream;
-	snd_pcm_substream_t *capture_substream;
-	snd_rawmidi_t *rmidi;
-	snd_hwdep_t *fmsynth;	/* S3FM */
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	struct snd_pcm_substream *playback_substream;
+	struct snd_pcm_substream *capture_substream;
+	struct snd_rawmidi *rmidi;
+	struct snd_hwdep *fmsynth;	/* S3FM */
 
 	spinlock_t reg_lock;
 
 	unsigned int p_dma_size;
 	unsigned int c_dma_size;
 
-	snd_kcontrol_t *master_mute;
-	snd_kcontrol_t *master_volume;
+	struct snd_kcontrol *master_mute;
+	struct snd_kcontrol *master_volume;
 
 #ifdef SUPPORT_JOYSTICK
 	struct gameport *gameport;
@@ -251,13 +249,13 @@ static struct pci_device_id snd_sonic_ids[] = {
 
 MODULE_DEVICE_TABLE(pci, snd_sonic_ids);
 
-static ratden_t sonicvibes_adc_clock = {
+static struct snd_ratden sonicvibes_adc_clock = {
 	.num_min = 4000 * 65536,
 	.num_max = 48000UL * 65536,
 	.num_step = 1,
 	.den = 65536,
 };
-static snd_pcm_hw_constraint_ratdens_t snd_sonicvibes_hw_constraints_adc_clock = {
+static struct snd_pcm_hw_constraint_ratdens snd_sonicvibes_hw_constraints_adc_clock = {
 	.nrats = 1,
 	.rats = &sonicvibes_adc_clock,
 };
@@ -266,7 +264,7 @@ static snd_pcm_hw_constraint_ratdens_t snd_sonicvibes_hw_constraints_adc_clock =
  *  common I/O routines
  */
 
-static inline void snd_sonicvibes_setdmaa(sonicvibes_t * sonic,
+static inline void snd_sonicvibes_setdmaa(struct sonicvibes * sonic,
 					  unsigned int addr,
 					  unsigned int count)
 {
@@ -279,7 +277,7 @@ static inline void snd_sonicvibes_setdmaa(sonicvibes_t * sonic,
 #endif
 }
 
-static inline void snd_sonicvibes_setdmac(sonicvibes_t * sonic,
+static inline void snd_sonicvibes_setdmac(struct sonicvibes * sonic,
 					  unsigned int addr,
 					  unsigned int count)
 {
@@ -294,18 +292,18 @@ static inline void snd_sonicvibes_setdmac(sonicvibes_t * sonic,
 #endif
 }
 
-static inline unsigned int snd_sonicvibes_getdmaa(sonicvibes_t * sonic)
+static inline unsigned int snd_sonicvibes_getdmaa(struct sonicvibes * sonic)
 {
 	return (inl(sonic->dmaa_port + SV_DMA_COUNT0) & 0xffffff) + 1;
 }
 
-static inline unsigned int snd_sonicvibes_getdmac(sonicvibes_t * sonic)
+static inline unsigned int snd_sonicvibes_getdmac(struct sonicvibes * sonic)
 {
 	/* note: dmac is working in word mode!!! */
 	return ((inl(sonic->dmac_port + SV_DMA_COUNT0) & 0xffffff) + 1) << 1;
 }
 
-static void snd_sonicvibes_out1(sonicvibes_t * sonic,
+static void snd_sonicvibes_out1(struct sonicvibes * sonic,
 				unsigned char reg,
 				unsigned char value)
 {
@@ -315,7 +313,7 @@ static void snd_sonicvibes_out1(sonicvibes_t * sonic,
 	udelay(10);
 }
 
-static void snd_sonicvibes_out(sonicvibes_t * sonic,
+static void snd_sonicvibes_out(struct sonicvibes * sonic,
 			       unsigned char reg,
 			       unsigned char value)
 {
@@ -329,7 +327,7 @@ static void snd_sonicvibes_out(sonicvibes_t * sonic,
 	spin_unlock_irqrestore(&sonic->reg_lock, flags);
 }
 
-static unsigned char snd_sonicvibes_in1(sonicvibes_t * sonic, unsigned char reg)
+static unsigned char snd_sonicvibes_in1(struct sonicvibes * sonic, unsigned char reg)
 {
 	unsigned char value;
 
@@ -340,7 +338,7 @@ static unsigned char snd_sonicvibes_in1(sonicvibes_t * sonic, unsigned char reg)
 	return value;
 }
 
-static unsigned char snd_sonicvibes_in(sonicvibes_t * sonic, unsigned char reg)
+static unsigned char snd_sonicvibes_in(struct sonicvibes * sonic, unsigned char reg)
 {
 	unsigned long flags;
 	unsigned char value;
@@ -355,7 +353,7 @@ static unsigned char snd_sonicvibes_in(sonicvibes_t * sonic, unsigned char reg)
 }
 
 #if 0
-static void snd_sonicvibes_debug(sonicvibes_t * sonic)
+static void snd_sonicvibes_debug(struct sonicvibes * sonic)
 {
 	printk("SV REGS:          INDEX = 0x%02x  ", inb(SV_REG(sonic, INDEX)));
 	printk("                 STATUS = 0x%02x\n", inb(SV_REG(sonic, STATUS)));
@@ -427,7 +425,7 @@ static void snd_sonicvibes_debug(sonicvibes_t * sonic)
 
 #endif
 
-static void snd_sonicvibes_setfmt(sonicvibes_t * sonic,
+static void snd_sonicvibes_setfmt(struct sonicvibes * sonic,
                                   unsigned char mask,
                                   unsigned char value)
 {
@@ -483,7 +481,7 @@ static void snd_sonicvibes_pll(unsigned int rate,
 #endif
 }
 
-static void snd_sonicvibes_setpll(sonicvibes_t * sonic,
+static void snd_sonicvibes_setpll(struct sonicvibes * sonic,
                                   unsigned char reg,
                                   unsigned int rate)
 {
@@ -499,7 +497,7 @@ static void snd_sonicvibes_setpll(sonicvibes_t * sonic,
 	}
 }
 
-static void snd_sonicvibes_set_adc_rate(sonicvibes_t * sonic, unsigned int rate)
+static void snd_sonicvibes_set_adc_rate(struct sonicvibes * sonic, unsigned int rate)
 {
 	unsigned long flags;
 	unsigned int div;
@@ -520,8 +518,8 @@ static void snd_sonicvibes_set_adc_rate(sonicvibes_t * sonic, unsigned int rate)
 	spin_unlock_irqrestore(&sonic->reg_lock, flags);
 }
 
-static int snd_sonicvibes_hw_constraint_dac_rate(snd_pcm_hw_params_t *params,
-						 snd_pcm_hw_rule_t *rule)
+static int snd_sonicvibes_hw_constraint_dac_rate(struct snd_pcm_hw_params *params,
+						 struct snd_pcm_hw_rule *rule)
 {
 	unsigned int rate, div, r, m, n;
 
@@ -545,7 +543,7 @@ static int snd_sonicvibes_hw_constraint_dac_rate(snd_pcm_hw_params_t *params,
 	return 0;
 }
 
-static void snd_sonicvibes_set_dac_rate(sonicvibes_t * sonic, unsigned int rate)
+static void snd_sonicvibes_set_dac_rate(struct sonicvibes * sonic, unsigned int rate)
 {
 	unsigned int div;
 	unsigned long flags;
@@ -559,7 +557,7 @@ static void snd_sonicvibes_set_dac_rate(sonicvibes_t * sonic, unsigned int rate)
 	spin_unlock_irqrestore(&sonic->reg_lock, flags);
 }
 
-static int snd_sonicvibes_trigger(sonicvibes_t * sonic, int what, int cmd)
+static int snd_sonicvibes_trigger(struct sonicvibes * sonic, int what, int cmd)
 {
 	int result = 0;
 
@@ -583,7 +581,7 @@ static int snd_sonicvibes_trigger(sonicvibes_t * sonic, int what, int cmd)
 
 static irqreturn_t snd_sonicvibes_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	sonicvibes_t *sonic = dev_id;
+	struct sonicvibes *sonic = dev_id;
 	unsigned char status;
 
 	status = inb(SV_REG(sonic, STATUS));
@@ -646,35 +644,35 @@ static irqreturn_t snd_sonicvibes_interrupt(int irq, void *dev_id, struct pt_reg
  *  PCM part
  */
 
-static int snd_sonicvibes_playback_trigger(snd_pcm_substream_t * substream,
+static int snd_sonicvibes_playback_trigger(struct snd_pcm_substream *substream,
 					   int cmd)
 {
-	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+	struct sonicvibes *sonic = snd_pcm_substream_chip(substream);
 	return snd_sonicvibes_trigger(sonic, 1, cmd);
 }
 
-static int snd_sonicvibes_capture_trigger(snd_pcm_substream_t * substream,
+static int snd_sonicvibes_capture_trigger(struct snd_pcm_substream *substream,
 					  int cmd)
 {
-	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+	struct sonicvibes *sonic = snd_pcm_substream_chip(substream);
 	return snd_sonicvibes_trigger(sonic, 2, cmd);
 }
 
-static int snd_sonicvibes_hw_params(snd_pcm_substream_t * substream,
-				    snd_pcm_hw_params_t * hw_params)
+static int snd_sonicvibes_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *hw_params)
 {
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 }
 
-static int snd_sonicvibes_hw_free(snd_pcm_substream_t * substream)
+static int snd_sonicvibes_hw_free(struct snd_pcm_substream *substream)
 {
 	return snd_pcm_lib_free_pages(substream);
 }
 
-static int snd_sonicvibes_playback_prepare(snd_pcm_substream_t * substream)
+static int snd_sonicvibes_playback_prepare(struct snd_pcm_substream *substream)
 {
-	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct sonicvibes *sonic = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned char fmt = 0;
 	unsigned int size = snd_pcm_lib_buffer_bytes(substream);
 	unsigned int count = snd_pcm_lib_period_bytes(substream);
@@ -695,10 +693,10 @@ static int snd_sonicvibes_playback_prepare(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_sonicvibes_capture_prepare(snd_pcm_substream_t * substream)
+static int snd_sonicvibes_capture_prepare(struct snd_pcm_substream *substream)
 {
-	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct sonicvibes *sonic = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned char fmt = 0;
 	unsigned int size = snd_pcm_lib_buffer_bytes(substream);
 	unsigned int count = snd_pcm_lib_period_bytes(substream);
@@ -720,9 +718,9 @@ static int snd_sonicvibes_capture_prepare(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static snd_pcm_uframes_t snd_sonicvibes_playback_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_sonicvibes_playback_pointer(struct snd_pcm_substream *substream)
 {
-	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+	struct sonicvibes *sonic = snd_pcm_substream_chip(substream);
 	size_t ptr;
 
 	if (!(sonic->enable & 1))
@@ -731,9 +729,9 @@ static snd_pcm_uframes_t snd_sonicvibes_playback_pointer(snd_pcm_substream_t * s
 	return bytes_to_frames(substream->runtime, ptr);
 }
 
-static snd_pcm_uframes_t snd_sonicvibes_capture_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_sonicvibes_capture_pointer(struct snd_pcm_substream *substream)
 {
-	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+	struct sonicvibes *sonic = snd_pcm_substream_chip(substream);
 	size_t ptr;
 	if (!(sonic->enable & 2))
 		return 0;
@@ -741,7 +739,7 @@ static snd_pcm_uframes_t snd_sonicvibes_capture_pointer(snd_pcm_substream_t * su
 	return bytes_to_frames(substream->runtime, ptr);
 }
 
-static snd_pcm_hardware_t snd_sonicvibes_playback =
+static struct snd_pcm_hardware snd_sonicvibes_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -760,7 +758,7 @@ static snd_pcm_hardware_t snd_sonicvibes_playback =
 	.fifo_size =		0,
 };
 
-static snd_pcm_hardware_t snd_sonicvibes_capture =
+static struct snd_pcm_hardware snd_sonicvibes_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
 				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
@@ -779,10 +777,10 @@ static snd_pcm_hardware_t snd_sonicvibes_capture =
 	.fifo_size =		0,
 };
 
-static int snd_sonicvibes_playback_open(snd_pcm_substream_t * substream)
+static int snd_sonicvibes_playback_open(struct snd_pcm_substream *substream)
 {
-	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct sonicvibes *sonic = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	sonic->mode |= SV_MODE_PLAY;
 	sonic->playback_substream = substream;
@@ -791,10 +789,10 @@ static int snd_sonicvibes_playback_open(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_sonicvibes_capture_open(snd_pcm_substream_t * substream)
+static int snd_sonicvibes_capture_open(struct snd_pcm_substream *substream)
 {
-	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct sonicvibes *sonic = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	sonic->mode |= SV_MODE_CAPTURE;
 	sonic->capture_substream = substream;
@@ -804,25 +802,25 @@ static int snd_sonicvibes_capture_open(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_sonicvibes_playback_close(snd_pcm_substream_t * substream)
+static int snd_sonicvibes_playback_close(struct snd_pcm_substream *substream)
 {
-	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+	struct sonicvibes *sonic = snd_pcm_substream_chip(substream);
 
 	sonic->playback_substream = NULL;
 	sonic->mode &= ~SV_MODE_PLAY;
 	return 0;
 }
 
-static int snd_sonicvibes_capture_close(snd_pcm_substream_t * substream)
+static int snd_sonicvibes_capture_close(struct snd_pcm_substream *substream)
 {
-	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+	struct sonicvibes *sonic = snd_pcm_substream_chip(substream);
 
 	sonic->capture_substream = NULL;
 	sonic->mode &= ~SV_MODE_CAPTURE;
 	return 0;
 }
 
-static snd_pcm_ops_t snd_sonicvibes_playback_ops = {
+static struct snd_pcm_ops snd_sonicvibes_playback_ops = {
 	.open =		snd_sonicvibes_playback_open,
 	.close =	snd_sonicvibes_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -833,7 +831,7 @@ static snd_pcm_ops_t snd_sonicvibes_playback_ops = {
 	.pointer =	snd_sonicvibes_playback_pointer,
 };
 
-static snd_pcm_ops_t snd_sonicvibes_capture_ops = {
+static struct snd_pcm_ops snd_sonicvibes_capture_ops = {
 	.open =		snd_sonicvibes_capture_open,
 	.close =	snd_sonicvibes_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -844,9 +842,9 @@ static snd_pcm_ops_t snd_sonicvibes_capture_ops = {
 	.pointer =	snd_sonicvibes_capture_pointer,
 };
 
-static int __devinit snd_sonicvibes_pcm(sonicvibes_t * sonic, int device, snd_pcm_t ** rpcm)
+static int __devinit snd_sonicvibes_pcm(struct sonicvibes * sonic, int device, struct snd_pcm ** rpcm)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	if ((err = snd_pcm_new(sonic->card, "s3_86c617", device, 1, 1, &pcm)) < 0)
@@ -878,7 +876,7 @@ static int __devinit snd_sonicvibes_pcm(sonicvibes_t * sonic, int device, snd_pc
   .info = snd_sonicvibes_info_mux, \
   .get = snd_sonicvibes_get_mux, .put = snd_sonicvibes_put_mux }
 
-static int snd_sonicvibes_info_mux(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_sonicvibes_info_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[7] = {
 		"CD", "PCM", "Aux1", "Line", "Aux0", "Mic", "Mix"
@@ -893,9 +891,9 @@ static int snd_sonicvibes_info_mux(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t
 	return 0;
 }
 
-static int snd_sonicvibes_get_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_sonicvibes_get_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	sonicvibes_t *sonic = snd_kcontrol_chip(kcontrol);
+	struct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);
 	
 	spin_lock_irq(&sonic->reg_lock);
 	ucontrol->value.enumerated.item[0] = ((snd_sonicvibes_in1(sonic, SV_IREG_LEFT_ADC) & SV_RECSRC_OUT) >> 5) - 1;
@@ -904,9 +902,9 @@ static int snd_sonicvibes_get_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_
 	return 0;
 }
 
-static int snd_sonicvibes_put_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_sonicvibes_put_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	sonicvibes_t *sonic = snd_kcontrol_chip(kcontrol);
+	struct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);
 	unsigned short left, right, oval1, oval2;
 	int change;
 	
@@ -933,7 +931,7 @@ static int snd_sonicvibes_put_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_
   .get = snd_sonicvibes_get_single, .put = snd_sonicvibes_put_single, \
   .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }
 
-static int snd_sonicvibes_info_single(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_sonicvibes_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	int mask = (kcontrol->private_value >> 16) & 0xff;
 
@@ -944,9 +942,9 @@ static int snd_sonicvibes_info_single(snd_kcontrol_t *kcontrol, snd_ctl_elem_inf
 	return 0;
 }
 
-static int snd_sonicvibes_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_sonicvibes_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	sonicvibes_t *sonic = snd_kcontrol_chip(kcontrol);
+	struct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);
 	int reg = kcontrol->private_value & 0xff;
 	int shift = (kcontrol->private_value >> 8) & 0xff;
 	int mask = (kcontrol->private_value >> 16) & 0xff;
@@ -960,9 +958,9 @@ static int snd_sonicvibes_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_val
 	return 0;
 }
 
-static int snd_sonicvibes_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_sonicvibes_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	sonicvibes_t *sonic = snd_kcontrol_chip(kcontrol);
+	struct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);
 	int reg = kcontrol->private_value & 0xff;
 	int shift = (kcontrol->private_value >> 8) & 0xff;
 	int mask = (kcontrol->private_value >> 16) & 0xff;
@@ -989,7 +987,7 @@ static int snd_sonicvibes_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_val
   .get = snd_sonicvibes_get_double, .put = snd_sonicvibes_put_double, \
   .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22) }
 
-static int snd_sonicvibes_info_double(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_sonicvibes_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
 {
 	int mask = (kcontrol->private_value >> 24) & 0xff;
 
@@ -1000,9 +998,9 @@ static int snd_sonicvibes_info_double(snd_kcontrol_t *kcontrol, snd_ctl_elem_inf
 	return 0;
 }
 
-static int snd_sonicvibes_get_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_sonicvibes_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	sonicvibes_t *sonic = snd_kcontrol_chip(kcontrol);
+	struct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);
 	int left_reg = kcontrol->private_value & 0xff;
 	int right_reg = (kcontrol->private_value >> 8) & 0xff;
 	int shift_left = (kcontrol->private_value >> 16) & 0x07;
@@ -1021,9 +1019,9 @@ static int snd_sonicvibes_get_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_val
 	return 0;
 }
 
-static int snd_sonicvibes_put_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_sonicvibes_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	sonicvibes_t *sonic = snd_kcontrol_chip(kcontrol);
+	struct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);
 	int left_reg = kcontrol->private_value & 0xff;
 	int right_reg = (kcontrol->private_value >> 8) & 0xff;
 	int shift_left = (kcontrol->private_value >> 16) & 0x07;
@@ -1053,7 +1051,7 @@ static int snd_sonicvibes_put_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_val
 	return change;
 }
 
-static snd_kcontrol_new_t snd_sonicvibes_controls[] __devinitdata = {
+static struct snd_kcontrol_new snd_sonicvibes_controls[] __devinitdata = {
 SONICVIBES_DOUBLE("Capture Volume", 0, SV_IREG_LEFT_ADC, SV_IREG_RIGHT_ADC, 0, 0, 15, 0),
 SONICVIBES_DOUBLE("Aux Playback Switch", 0, SV_IREG_LEFT_AUX1, SV_IREG_RIGHT_AUX1, 7, 7, 1, 1),
 SONICVIBES_DOUBLE("Aux Playback Volume", 0, SV_IREG_LEFT_AUX1, SV_IREG_RIGHT_AUX1, 0, 0, 31, 1),
@@ -1077,17 +1075,17 @@ SONICVIBES_SINGLE("Loopback Capture Volume", 0, SV_IREG_ADC_OUTPUT_CTRL, 2, 63,
 SONICVIBES_MUX("Capture Source", 0)
 };
 
-static void snd_sonicvibes_master_free(snd_kcontrol_t *kcontrol)
+static void snd_sonicvibes_master_free(struct snd_kcontrol *kcontrol)
 {
-	sonicvibes_t *sonic = snd_kcontrol_chip(kcontrol);
+	struct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);
 	sonic->master_mute = NULL;
 	sonic->master_volume = NULL;
 }
 
-static int __devinit snd_sonicvibes_mixer(sonicvibes_t * sonic)
+static int __devinit snd_sonicvibes_mixer(struct sonicvibes * sonic)
 {
-	snd_card_t *card;
-	snd_kcontrol_t *kctl;
+	struct snd_card *card;
+	struct snd_kcontrol *kctl;
 	unsigned int idx;
 	int err;
 
@@ -1110,10 +1108,10 @@ static int __devinit snd_sonicvibes_mixer(sonicvibes_t * sonic)
 
  */
 
-static void snd_sonicvibes_proc_read(snd_info_entry_t *entry, 
-				     snd_info_buffer_t * buffer)
+static void snd_sonicvibes_proc_read(struct snd_info_entry *entry, 
+				     struct snd_info_buffer *buffer)
 {
-	sonicvibes_t *sonic = entry->private_data;
+	struct sonicvibes *sonic = entry->private_data;
 	unsigned char tmp;
 
 	tmp = sonic->srs_space & 0x0f;
@@ -1140,9 +1138,9 @@ static void snd_sonicvibes_proc_read(snd_info_entry_t *entry,
 	snd_iprintf(buffer, "MIDI to ext. Tx  : %s\n", tmp & 0x04 ? "on" : "off");
 }
 
-static void __devinit snd_sonicvibes_proc_init(sonicvibes_t * sonic)
+static void __devinit snd_sonicvibes_proc_init(struct sonicvibes * sonic)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(sonic->card, "sonicvibes", &entry))
 		snd_info_set_text_ops(entry, sonic, 1024, snd_sonicvibes_proc_read);
@@ -1153,10 +1151,10 @@ static void __devinit snd_sonicvibes_proc_init(sonicvibes_t * sonic)
  */
 
 #ifdef SUPPORT_JOYSTICK
-static snd_kcontrol_new_t snd_sonicvibes_game_control __devinitdata =
+static struct snd_kcontrol_new snd_sonicvibes_game_control __devinitdata =
 SONICVIBES_SINGLE("Joystick Speed", 0, SV_IREG_GAME_PORT, 1, 15, 0);
 
-static int __devinit snd_sonicvibes_create_gameport(sonicvibes_t *sonic)
+static int __devinit snd_sonicvibes_create_gameport(struct sonicvibes *sonic)
 {
 	struct gameport *gp;
 
@@ -1178,7 +1176,7 @@ static int __devinit snd_sonicvibes_create_gameport(sonicvibes_t *sonic)
 	return 0;
 }
 
-static void snd_sonicvibes_free_gameport(sonicvibes_t *sonic)
+static void snd_sonicvibes_free_gameport(struct sonicvibes *sonic)
 {
 	if (sonic->gameport) {
 		gameport_unregister_port(sonic->gameport);
@@ -1186,11 +1184,11 @@ static void snd_sonicvibes_free_gameport(sonicvibes_t *sonic)
 	}
 }
 #else
-static inline int snd_sonicvibes_create_gameport(sonicvibes_t *sonic) { return -ENOSYS; }
-static inline void snd_sonicvibes_free_gameport(sonicvibes_t *sonic) { }
+static inline int snd_sonicvibes_create_gameport(struct sonicvibes *sonic) { return -ENOSYS; }
+static inline void snd_sonicvibes_free_gameport(struct sonicvibes *sonic) { }
 #endif
 
-static int snd_sonicvibes_free(sonicvibes_t *sonic)
+static int snd_sonicvibes_free(struct sonicvibes *sonic)
 {
 	snd_sonicvibes_free_gameport(sonic);
 	pci_write_config_dword(sonic->pci, 0x40, sonic->dmaa_port);
@@ -1205,22 +1203,22 @@ static int snd_sonicvibes_free(sonicvibes_t *sonic)
 	return 0;
 }
 
-static int snd_sonicvibes_dev_free(snd_device_t *device)
+static int snd_sonicvibes_dev_free(struct snd_device *device)
 {
-	sonicvibes_t *sonic = device->device_data;
+	struct sonicvibes *sonic = device->device_data;
 	return snd_sonicvibes_free(sonic);
 }
 
-static int __devinit snd_sonicvibes_create(snd_card_t * card,
+static int __devinit snd_sonicvibes_create(struct snd_card *card,
 					struct pci_dev *pci,
 					int reverb,
 					int mge,
-					sonicvibes_t ** rsonic)
+					struct sonicvibes ** rsonic)
 {
-	sonicvibes_t *sonic;
+	struct sonicvibes *sonic;
 	unsigned int dmaa, dmac;
 	int err;
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free =	snd_sonicvibes_dev_free,
 	};
 
@@ -1365,7 +1363,7 @@ static int __devinit snd_sonicvibes_create(snd_card_t * card,
  *  MIDI section
  */
 
-static snd_kcontrol_new_t snd_sonicvibes_midi_controls[] __devinitdata = {
+static struct snd_kcontrol_new snd_sonicvibes_midi_controls[] __devinitdata = {
 SONICVIBES_SINGLE("SonicVibes Wave Source RAM", 0, SV_IREG_WAVE_SOURCE, 0, 1, 0),
 SONICVIBES_SINGLE("SonicVibes Wave Source RAM+ROM", 0, SV_IREG_WAVE_SOURCE, 1, 1, 0),
 SONICVIBES_SINGLE("SonicVibes Onboard Synth", 0, SV_IREG_MPU401, 0, 1, 0),
@@ -1373,24 +1371,25 @@ SONICVIBES_SINGLE("SonicVibes External Rx to Synth", 0, SV_IREG_MPU401, 1, 1, 0)
 SONICVIBES_SINGLE("SonicVibes External Tx", 0, SV_IREG_MPU401, 2, 1, 0)
 };
 
-static int snd_sonicvibes_midi_input_open(mpu401_t * mpu)
+static int snd_sonicvibes_midi_input_open(struct snd_mpu401 * mpu)
 {
-	sonicvibes_t *sonic = mpu->private_data;
+	struct sonicvibes *sonic = mpu->private_data;
 	outb(sonic->irqmask &= ~SV_MIDI_MASK, SV_REG(sonic, IRQMASK));
 	return 0;
 }
 
-static void snd_sonicvibes_midi_input_close(mpu401_t * mpu)
+static void snd_sonicvibes_midi_input_close(struct snd_mpu401 * mpu)
 {
-	sonicvibes_t *sonic = mpu->private_data;
+	struct sonicvibes *sonic = mpu->private_data;
 	outb(sonic->irqmask |= SV_MIDI_MASK, SV_REG(sonic, IRQMASK));
 }
 
-static int __devinit snd_sonicvibes_midi(sonicvibes_t * sonic, snd_rawmidi_t * rmidi)
+static int __devinit snd_sonicvibes_midi(struct sonicvibes * sonic,
+					 struct snd_rawmidi *rmidi)
 {
-	mpu401_t * mpu = rmidi->private_data;
-	snd_card_t *card = sonic->card;
-	snd_rawmidi_str_t *dir;
+	struct snd_mpu401 * mpu = rmidi->private_data;
+	struct snd_card *card = sonic->card;
+	struct snd_rawmidi_str *dir;
 	unsigned int idx;
 	int err;
 
@@ -1408,10 +1407,10 @@ static int __devinit snd_sonic_probe(struct pci_dev *pci,
 				     const struct pci_device_id *pci_id)
 {
 	static int dev;
-	snd_card_t *card;
-	sonicvibes_t *sonic;
-	snd_rawmidi_t *midi_uart;
-	opl3_t *opl3;
+	struct snd_card *card;
+	struct sonicvibes *sonic;
+	struct snd_rawmidi *midi_uart;
+	struct snd_opl3 *opl3;
 	int idx, err;
 
 	if (dev >= SNDRV_CARDS)

commit c3e6f7d8763fa0400d28c57633eb323515ba05fc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 16 18:43:35 2005 +0100

    [ALSA] Remove superfluous pcm_free callbacks
    
    Remove superflous pcm_free callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index e92ef3ae2ca1..b66459f69c0b 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -844,13 +844,6 @@ static snd_pcm_ops_t snd_sonicvibes_capture_ops = {
 	.pointer =	snd_sonicvibes_capture_pointer,
 };
 
-static void snd_sonicvibes_pcm_free(snd_pcm_t *pcm)
-{
-	sonicvibes_t *sonic = pcm->private_data;
-	sonic->pcm = NULL;
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
 static int __devinit snd_sonicvibes_pcm(sonicvibes_t * sonic, int device, snd_pcm_t ** rpcm)
 {
 	snd_pcm_t *pcm;
@@ -864,7 +857,6 @@ static int __devinit snd_sonicvibes_pcm(sonicvibes_t * sonic, int device, snd_pc
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_sonicvibes_capture_ops);
 
 	pcm->private_data = sonic;
-	pcm->private_free = snd_sonicvibes_pcm_free;
 	pcm->info_flags = 0;
 	strcpy(pcm->name, "S3 SonicVibes");
 	sonic->pcm = pcm;

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 9a35474aad05..e92ef3ae2ca1 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1502,7 +1502,6 @@ static void __devexit snd_sonic_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "S3 SonicVibes",
-	.owner = THIS_MODULE,
 	.id_table = snd_sonic_ids,
 	.probe = snd_sonic_probe,
 	.remove = __devexit_p(snd_sonic_remove),

commit 99b359ba10a582148c6725f428a33ba5356dd993
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Oct 20 18:26:44 2005 +0200

    [ALSA] Add missing KERN_* suffix to printk
    
    Add missing KERN_* suffix to printk.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 4f64814dfef0..9a35474aad05 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -591,7 +591,7 @@ static irqreturn_t snd_sonicvibes_interrupt(int irq, void *dev_id, struct pt_reg
 		return IRQ_NONE;
 	if (status == 0xff) {	/* failure */
 		outb(sonic->irqmask = ~0, SV_REG(sonic, IRQMASK));
-		snd_printk("IRQ failure - interrupts disabled!!\n");
+		snd_printk(KERN_ERR "IRQ failure - interrupts disabled!!\n");
 		return IRQ_HANDLED;
 	}
 	if (sonic->pcm) {
@@ -1239,7 +1239,7 @@ static int __devinit snd_sonicvibes_create(snd_card_t * card,
 	/* check, if we can restrict PCI DMA transfers to 24 bits */
         if (pci_set_dma_mask(pci, 0x00ffffff) < 0 ||
 	    pci_set_consistent_dma_mask(pci, 0x00ffffff) < 0) {
-                snd_printk("architecture does not support 24bit PCI busmaster DMA\n");
+		snd_printk(KERN_ERR "architecture does not support 24bit PCI busmaster DMA\n");
 		pci_disable_device(pci);
                 return -ENXIO;
         }
@@ -1267,7 +1267,7 @@ static int __devinit snd_sonicvibes_create(snd_card_t * card,
 	sonic->game_port = pci_resource_start(pci, 4);
 
 	if (request_irq(pci->irq, snd_sonicvibes_interrupt, SA_INTERRUPT|SA_SHIRQ, "S3 SonicVibes", (void *)sonic)) {
-		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_sonicvibes_free(sonic);
 		return -EBUSY;
 	}
@@ -1281,24 +1281,24 @@ static int __devinit snd_sonicvibes_create(snd_card_t * card,
 	if (!dmaa) {
 		dmaa = dmaio;
 		dmaio += 0x10;
-		snd_printk("BIOS did not allocate DDMA channel A i/o, allocated at 0x%x\n", dmaa);
+		snd_printk(KERN_INFO "BIOS did not allocate DDMA channel A i/o, allocated at 0x%x\n", dmaa);
 	}
 	if (!dmac) {
 		dmac = dmaio;
 		dmaio += 0x10;
-		snd_printk("BIOS did not allocate DDMA channel C i/o, allocated at 0x%x\n", dmac);
+		snd_printk(KERN_INFO "BIOS did not allocate DDMA channel C i/o, allocated at 0x%x\n", dmac);
 	}
 	pci_write_config_dword(pci, 0x40, dmaa);
 	pci_write_config_dword(pci, 0x48, dmac);
 
 	if ((sonic->res_dmaa = request_region(dmaa, 0x10, "S3 SonicVibes DDMA-A")) == NULL) {
 		snd_sonicvibes_free(sonic);
-		snd_printk("unable to grab DDMA-A port at 0x%x-0x%x\n", dmaa, dmaa + 0x10 - 1);
+		snd_printk(KERN_ERR "unable to grab DDMA-A port at 0x%x-0x%x\n", dmaa, dmaa + 0x10 - 1);
 		return -EBUSY;
 	}
 	if ((sonic->res_dmac = request_region(dmac, 0x10, "S3 SonicVibes DDMA-C")) == NULL) {
 		snd_sonicvibes_free(sonic);
-		snd_printk("unable to grab DDMA-C port at 0x%x-0x%x\n", dmac, dmac + 0x10 - 1);
+		snd_printk(KERN_ERR "unable to grab DDMA-C port at 0x%x-0x%x\n", dmac, dmac + 0x10 - 1);
 		return -EBUSY;
 	}
 

commit b1d5776d865951c213a1caaab5d8bf5de7615dbd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 10 11:56:31 2005 +0200

    [ALSA] Remove vmalloc wrapper, kfree_nocheck()
    
    - Remove vmalloc wrapper
    - Add release_and_free_resource() to remove kfree_nocheck() from each driver
      and simplify the code
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 1f6c2bfd43fd..4f64814dfef0 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1205,14 +1205,8 @@ static int snd_sonicvibes_free(sonicvibes_t *sonic)
 	pci_write_config_dword(sonic->pci, 0x48, sonic->dmac_port);
 	if (sonic->irq >= 0)
 		free_irq(sonic->irq, (void *)sonic);
-	if (sonic->res_dmaa) {
-		release_resource(sonic->res_dmaa);
-		kfree_nocheck(sonic->res_dmaa);
-	}
-	if (sonic->res_dmac) {
-		release_resource(sonic->res_dmac);
-		kfree_nocheck(sonic->res_dmac);
-	}
+	release_and_free_resource(sonic->res_dmaa);
+	release_and_free_resource(sonic->res_dmac);
 	pci_release_regions(sonic->pci);
 	pci_disable_device(sonic->pci);
 	kfree(sonic);

commit 3bcd4649bca99ee9242f20d7da35e3f8741c6549
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 12 08:20:54 2005 +0200

    [ALSA] set owner field in struct pci_driver
    
    AD1889 driver,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CS46xx driver,EMU10K1/EMU10K2 driver
    HDA Intel driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    MIXART driver,NM256 driver,RME HDSP driver,RME9652 driver
    Trident driver,Digigram VX222 driver,YMFPCI driver
    Set the module owner field in each driver's struct pci_driver to get
    the driver symlink in the sysfs device directory.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 57c8ff5f5260..1f6c2bfd43fd 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1508,6 +1508,7 @@ static void __devexit snd_sonic_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "S3 SonicVibes",
+	.owner = THIS_MODULE,
 	.id_table = snd_sonic_ids,
 	.probe = snd_sonic_probe,
 	.remove = __devexit_p(snd_sonic_remove),

commit e560d8d8368ad8b6161839984b253de622863265
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:21:46 2005 +0200

    [ALSA] Replace with kzalloc() - pci stuff
    
    AD1889 driver,ATIIXP driver,ATIIXP-modem driver,AZT3328 driver
    BT87x driver,CMIPCI driver,CS4281 driver,ENS1370/1+ driver
    ES1938 driver,ES1968 driver,FM801 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,SonicVibes driver,VIA82xx driver
    VIA82xx-modem driver,AC97 Codec,AK4531 codec,au88x0 driver
    CA0106 driver,CS46xx driver,EMU10K1/EMU10K2 driver,HDA Codec driver
    HDA generic driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,Trident driver,YMFPCI driver
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 3d431390c1c0..57c8ff5f5260 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1250,7 +1250,7 @@ static int __devinit snd_sonicvibes_create(snd_card_t * card,
                 return -ENXIO;
         }
 
-	sonic = kcalloc(1, sizeof(*sonic), GFP_KERNEL);
+	sonic = kzalloc(sizeof(*sonic), GFP_KERNEL);
 	if (sonic == NULL) {
 		pci_disable_device(pci);
 		return -ENOMEM;

commit 8cdfd2519c6c9a1e6057dc5970b2542b35895738
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 7 14:08:11 2005 +0200

    [ALSA] Remove superfluous PCI ID definitions
    
    CS46xx driver,EMU10K1/EMU10K2 driver,PCM Midlevel,Trident driver
    YMFPCI driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,RME32 driver,RME96 driver
    SonicVibes driver,VIA82xx driver,ALI5451 driver,ICE1712 driver
    ICE1724 driver,NM256 driver,RME HDSP driver,RME9652 driver
    Remove superfluous PCI ID definitions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index 60ecb2bdb65e..3d431390c1c0 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -50,13 +50,6 @@ MODULE_SUPPORTED_DEVICE("{{S3,SonicVibes PCI}}");
 #define SUPPORT_JOYSTICK 1
 #endif
 
-#ifndef PCI_VENDOR_ID_S3
-#define PCI_VENDOR_ID_S3             0x5333
-#endif
-#ifndef PCI_DEVICE_ID_S3_SONICVIBES
-#define PCI_DEVICE_ID_S3_SONICVIBES  0xca00
-#endif
-
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */

commit 01d25d460a3b28aab537fab9a0038d1b5832ce28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 11 16:58:24 2005 +0200

    [ALSA] Replace pci_module_init() with pci_register_driver()
    
    Documentation,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CA0106 driver,CS46xx driver
    EMU10K1/EMU10K2 driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,RME HDSP driver
    RME9652 driver,Trident driver,Digigram VX222 driver,YMFPCI driver
    Replace the obsolete pci_module_init() with pci_register_driver().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
index cfd2c5fd6ddf..60ecb2bdb65e 100644
--- a/sound/pci/sonicvibes.c
+++ b/sound/pci/sonicvibes.c
@@ -1522,7 +1522,7 @@ static struct pci_driver driver = {
 
 static int __init alsa_card_sonicvibes_init(void)
 {
-	return pci_module_init(&driver);
+	return pci_register_driver(&driver);
 }
 
 static void __exit alsa_card_sonicvibes_exit(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/sonicvibes.c b/sound/pci/sonicvibes.c
new file mode 100644
index 000000000000..cfd2c5fd6ddf
--- /dev/null
+++ b/sound/pci/sonicvibes.c
@@ -0,0 +1,1534 @@
+/*
+ *  Driver for S3 SonicVibes soundcard
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *
+ *  BUGS:
+ *    It looks like 86c617 rev 3 doesn't supports DDMA buffers above 16MB?
+ *    Driver sometimes hangs... Nobody knows why at this moment...
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/gameport.h>
+#include <linux/moduleparam.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/info.h>
+#include <sound/control.h>
+#include <sound/mpu401.h>
+#include <sound/opl3.h>
+#include <sound/initval.h>
+
+#include <asm/io.h>
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_DESCRIPTION("S3 SonicVibes PCI");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{S3,SonicVibes PCI}}");
+
+#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+#define SUPPORT_JOYSTICK 1
+#endif
+
+#ifndef PCI_VENDOR_ID_S3
+#define PCI_VENDOR_ID_S3             0x5333
+#endif
+#ifndef PCI_DEVICE_ID_S3_SONICVIBES
+#define PCI_DEVICE_ID_S3_SONICVIBES  0xca00
+#endif
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable this card */
+static int reverb[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
+static int mge[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 0};
+static unsigned int dmaio = 0x7a00;	/* DDMA i/o address */
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for S3 SonicVibes soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for S3 SonicVibes soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable S3 SonicVibes soundcard.");
+module_param_array(reverb, bool, NULL, 0444);
+MODULE_PARM_DESC(reverb, "Enable reverb (SRAM is present) for S3 SonicVibes soundcard.");
+module_param_array(mge, bool, NULL, 0444);
+MODULE_PARM_DESC(mge, "MIC Gain Enable for S3 SonicVibes soundcard.");
+module_param(dmaio, uint, 0444);
+MODULE_PARM_DESC(dmaio, "DDMA i/o base address for S3 SonicVibes soundcard.");
+
+/*
+ * Enhanced port direct registers
+ */
+
+#define SV_REG(sonic, x) ((sonic)->enh_port + SV_REG_##x)
+
+#define SV_REG_CONTROL	0x00	/* R/W: CODEC/Mixer control register */
+#define   SV_ENHANCED	  0x01	/* audio mode select - enhanced mode */
+#define   SV_TEST	  0x02	/* test bit */
+#define   SV_REVERB	  0x04	/* reverb enable */
+#define   SV_WAVETABLE	  0x08	/* wavetable active / FM active if not set */
+#define   SV_INTA	  0x20	/* INTA driving - should be always 1 */
+#define   SV_RESET	  0x80	/* reset chip */
+#define SV_REG_IRQMASK	0x01	/* R/W: CODEC/Mixer interrupt mask register */
+#define   SV_DMAA_MASK	  0x01	/* mask DMA-A interrupt */
+#define   SV_DMAC_MASK	  0x04	/* mask DMA-C interrupt */
+#define   SV_SPEC_MASK	  0x08	/* special interrupt mask - should be always masked */
+#define   SV_UD_MASK	  0x40	/* Up/Down button interrupt mask */
+#define   SV_MIDI_MASK	  0x80	/* mask MIDI interrupt */
+#define SV_REG_STATUS	0x02	/* R/O: CODEC/Mixer status register */
+#define   SV_DMAA_IRQ	  0x01	/* DMA-A interrupt */
+#define   SV_DMAC_IRQ	  0x04	/* DMA-C interrupt */
+#define   SV_SPEC_IRQ	  0x08	/* special interrupt */
+#define   SV_UD_IRQ	  0x40	/* Up/Down interrupt */
+#define   SV_MIDI_IRQ	  0x80	/* MIDI interrupt */
+#define SV_REG_INDEX	0x04	/* R/W: CODEC/Mixer index address register */
+#define   SV_MCE          0x40	/* mode change enable */
+#define   SV_TRD	  0x80	/* DMA transfer request disabled */
+#define SV_REG_DATA	0x05	/* R/W: CODEC/Mixer index data register */
+
+/*
+ * Enhanced port indirect registers
+ */
+
+#define SV_IREG_LEFT_ADC	0x00	/* Left ADC Input Control */
+#define SV_IREG_RIGHT_ADC	0x01	/* Right ADC Input Control */
+#define SV_IREG_LEFT_AUX1	0x02	/* Left AUX1 Input Control */
+#define SV_IREG_RIGHT_AUX1	0x03	/* Right AUX1 Input Control */
+#define SV_IREG_LEFT_CD		0x04	/* Left CD Input Control */
+#define SV_IREG_RIGHT_CD	0x05	/* Right CD Input Control */
+#define SV_IREG_LEFT_LINE	0x06	/* Left Line Input Control */
+#define SV_IREG_RIGHT_LINE	0x07	/* Right Line Input Control */
+#define SV_IREG_MIC		0x08	/* MIC Input Control */
+#define SV_IREG_GAME_PORT	0x09	/* Game Port Control */
+#define SV_IREG_LEFT_SYNTH	0x0a	/* Left Synth Input Control */
+#define SV_IREG_RIGHT_SYNTH	0x0b	/* Right Synth Input Control */
+#define SV_IREG_LEFT_AUX2	0x0c	/* Left AUX2 Input Control */
+#define SV_IREG_RIGHT_AUX2	0x0d	/* Right AUX2 Input Control */
+#define SV_IREG_LEFT_ANALOG	0x0e	/* Left Analog Mixer Output Control */
+#define SV_IREG_RIGHT_ANALOG	0x0f	/* Right Analog Mixer Output Control */
+#define SV_IREG_LEFT_PCM	0x10	/* Left PCM Input Control */
+#define SV_IREG_RIGHT_PCM	0x11	/* Right PCM Input Control */
+#define SV_IREG_DMA_DATA_FMT	0x12	/* DMA Data Format */
+#define SV_IREG_PC_ENABLE	0x13	/* Playback/Capture Enable Register */
+#define SV_IREG_UD_BUTTON	0x14	/* Up/Down Button Register */
+#define SV_IREG_REVISION	0x15	/* Revision */
+#define SV_IREG_ADC_OUTPUT_CTRL	0x16	/* ADC Output Control */
+#define SV_IREG_DMA_A_UPPER	0x18	/* DMA A Upper Base Count */
+#define SV_IREG_DMA_A_LOWER	0x19	/* DMA A Lower Base Count */
+#define SV_IREG_DMA_C_UPPER	0x1c	/* DMA C Upper Base Count */
+#define SV_IREG_DMA_C_LOWER	0x1d	/* DMA C Lower Base Count */
+#define SV_IREG_PCM_RATE_LOW	0x1e	/* PCM Sampling Rate Low Byte */
+#define SV_IREG_PCM_RATE_HIGH	0x1f	/* PCM Sampling Rate High Byte */
+#define SV_IREG_SYNTH_RATE_LOW	0x20	/* Synthesizer Sampling Rate Low Byte */
+#define SV_IREG_SYNTH_RATE_HIGH 0x21	/* Synthesizer Sampling Rate High Byte */
+#define SV_IREG_ADC_CLOCK	0x22	/* ADC Clock Source Selection */
+#define SV_IREG_ADC_ALT_RATE	0x23	/* ADC Alternative Sampling Rate Selection */
+#define SV_IREG_ADC_PLL_M	0x24	/* ADC PLL M Register */
+#define SV_IREG_ADC_PLL_N	0x25	/* ADC PLL N Register */
+#define SV_IREG_SYNTH_PLL_M	0x26	/* Synthesizer PLL M Register */
+#define SV_IREG_SYNTH_PLL_N	0x27	/* Synthesizer PLL N Register */
+#define SV_IREG_MPU401		0x2a	/* MPU-401 UART Operation */
+#define SV_IREG_DRIVE_CTRL	0x2b	/* Drive Control */
+#define SV_IREG_SRS_SPACE	0x2c	/* SRS Space Control */
+#define SV_IREG_SRS_CENTER	0x2d	/* SRS Center Control */
+#define SV_IREG_WAVE_SOURCE	0x2e	/* Wavetable Sample Source Select */
+#define SV_IREG_ANALOG_POWER	0x30	/* Analog Power Down Control */
+#define SV_IREG_DIGITAL_POWER	0x31	/* Digital Power Down Control */
+
+#define SV_IREG_ADC_PLL		SV_IREG_ADC_PLL_M
+#define SV_IREG_SYNTH_PLL	SV_IREG_SYNTH_PLL_M
+
+/*
+ *  DMA registers
+ */
+
+#define SV_DMA_ADDR0		0x00
+#define SV_DMA_ADDR1		0x01
+#define SV_DMA_ADDR2		0x02
+#define SV_DMA_ADDR3		0x03
+#define SV_DMA_COUNT0		0x04
+#define SV_DMA_COUNT1		0x05
+#define SV_DMA_COUNT2		0x06
+#define SV_DMA_MODE		0x0b
+#define SV_DMA_RESET		0x0d
+#define SV_DMA_MASK		0x0f
+
+/*
+ *  Record sources
+ */
+
+#define SV_RECSRC_RESERVED	(0x00<<5)
+#define SV_RECSRC_CD		(0x01<<5)
+#define SV_RECSRC_DAC		(0x02<<5)
+#define SV_RECSRC_AUX2		(0x03<<5)
+#define SV_RECSRC_LINE		(0x04<<5)
+#define SV_RECSRC_AUX1		(0x05<<5)
+#define SV_RECSRC_MIC		(0x06<<5)
+#define SV_RECSRC_OUT		(0x07<<5)
+
+/*
+ *  constants
+ */
+
+#define SV_FULLRATE		48000
+#define SV_REFFREQUENCY		24576000
+#define SV_ADCMULT		512
+
+#define SV_MODE_PLAY		1
+#define SV_MODE_CAPTURE		2
+
+/*
+
+ */
+
+typedef struct _snd_sonicvibes sonicvibes_t;
+
+struct _snd_sonicvibes {
+	unsigned long dma1size;
+	unsigned long dma2size;
+	int irq;
+
+	unsigned long sb_port;
+	unsigned long enh_port;
+	unsigned long synth_port;
+	unsigned long midi_port;
+	unsigned long game_port;
+	unsigned int dmaa_port;
+	struct resource *res_dmaa;
+	unsigned int dmac_port;
+	struct resource *res_dmac;
+
+	unsigned char enable;
+	unsigned char irqmask;
+	unsigned char revision;
+	unsigned char format;
+	unsigned char srs_space;
+	unsigned char srs_center;
+	unsigned char mpu_switch;
+	unsigned char wave_source;
+
+	unsigned int mode;
+
+	struct pci_dev *pci;
+	snd_card_t *card;
+	snd_pcm_t *pcm;
+	snd_pcm_substream_t *playback_substream;
+	snd_pcm_substream_t *capture_substream;
+	snd_rawmidi_t *rmidi;
+	snd_hwdep_t *fmsynth;	/* S3FM */
+
+	spinlock_t reg_lock;
+
+	unsigned int p_dma_size;
+	unsigned int c_dma_size;
+
+	snd_kcontrol_t *master_mute;
+	snd_kcontrol_t *master_volume;
+
+#ifdef SUPPORT_JOYSTICK
+	struct gameport *gameport;
+#endif
+};
+
+static struct pci_device_id snd_sonic_ids[] = {
+	{ 0x5333, 0xca00, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
+        { 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, snd_sonic_ids);
+
+static ratden_t sonicvibes_adc_clock = {
+	.num_min = 4000 * 65536,
+	.num_max = 48000UL * 65536,
+	.num_step = 1,
+	.den = 65536,
+};
+static snd_pcm_hw_constraint_ratdens_t snd_sonicvibes_hw_constraints_adc_clock = {
+	.nrats = 1,
+	.rats = &sonicvibes_adc_clock,
+};
+
+/*
+ *  common I/O routines
+ */
+
+static inline void snd_sonicvibes_setdmaa(sonicvibes_t * sonic,
+					  unsigned int addr,
+					  unsigned int count)
+{
+	count--;
+	outl(addr, sonic->dmaa_port + SV_DMA_ADDR0);
+	outl(count, sonic->dmaa_port + SV_DMA_COUNT0);
+	outb(0x18, sonic->dmaa_port + SV_DMA_MODE);
+#if 0
+	printk("program dmaa: addr = 0x%x, paddr = 0x%x\n", addr, inl(sonic->dmaa_port + SV_DMA_ADDR0));
+#endif
+}
+
+static inline void snd_sonicvibes_setdmac(sonicvibes_t * sonic,
+					  unsigned int addr,
+					  unsigned int count)
+{
+	/* note: dmac is working in word mode!!! */
+	count >>= 1;
+	count--;
+	outl(addr, sonic->dmac_port + SV_DMA_ADDR0);
+	outl(count, sonic->dmac_port + SV_DMA_COUNT0);
+	outb(0x14, sonic->dmac_port + SV_DMA_MODE);
+#if 0
+	printk("program dmac: addr = 0x%x, paddr = 0x%x\n", addr, inl(sonic->dmac_port + SV_DMA_ADDR0));
+#endif
+}
+
+static inline unsigned int snd_sonicvibes_getdmaa(sonicvibes_t * sonic)
+{
+	return (inl(sonic->dmaa_port + SV_DMA_COUNT0) & 0xffffff) + 1;
+}
+
+static inline unsigned int snd_sonicvibes_getdmac(sonicvibes_t * sonic)
+{
+	/* note: dmac is working in word mode!!! */
+	return ((inl(sonic->dmac_port + SV_DMA_COUNT0) & 0xffffff) + 1) << 1;
+}
+
+static void snd_sonicvibes_out1(sonicvibes_t * sonic,
+				unsigned char reg,
+				unsigned char value)
+{
+	outb(reg, SV_REG(sonic, INDEX));
+	udelay(10);
+	outb(value, SV_REG(sonic, DATA));
+	udelay(10);
+}
+
+static void snd_sonicvibes_out(sonicvibes_t * sonic,
+			       unsigned char reg,
+			       unsigned char value)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&sonic->reg_lock, flags);
+	outb(reg, SV_REG(sonic, INDEX));
+	udelay(10);
+	outb(value, SV_REG(sonic, DATA));
+	udelay(10);
+	spin_unlock_irqrestore(&sonic->reg_lock, flags);
+}
+
+static unsigned char snd_sonicvibes_in1(sonicvibes_t * sonic, unsigned char reg)
+{
+	unsigned char value;
+
+	outb(reg, SV_REG(sonic, INDEX));
+	udelay(10);
+	value = inb(SV_REG(sonic, DATA));
+	udelay(10);
+	return value;
+}
+
+static unsigned char snd_sonicvibes_in(sonicvibes_t * sonic, unsigned char reg)
+{
+	unsigned long flags;
+	unsigned char value;
+
+	spin_lock_irqsave(&sonic->reg_lock, flags);
+	outb(reg, SV_REG(sonic, INDEX));
+	udelay(10);
+	value = inb(SV_REG(sonic, DATA));
+	udelay(10);
+	spin_unlock_irqrestore(&sonic->reg_lock, flags);
+	return value;
+}
+
+#if 0
+static void snd_sonicvibes_debug(sonicvibes_t * sonic)
+{
+	printk("SV REGS:          INDEX = 0x%02x  ", inb(SV_REG(sonic, INDEX)));
+	printk("                 STATUS = 0x%02x\n", inb(SV_REG(sonic, STATUS)));
+	printk("  0x00: left input      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x00));
+	printk("  0x20: synth rate low  = 0x%02x\n", snd_sonicvibes_in(sonic, 0x20));
+	printk("  0x01: right input     = 0x%02x  ", snd_sonicvibes_in(sonic, 0x01));
+	printk("  0x21: synth rate high = 0x%02x\n", snd_sonicvibes_in(sonic, 0x21));
+	printk("  0x02: left AUX1       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x02));
+	printk("  0x22: ADC clock       = 0x%02x\n", snd_sonicvibes_in(sonic, 0x22));
+	printk("  0x03: right AUX1      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x03));
+	printk("  0x23: ADC alt rate    = 0x%02x\n", snd_sonicvibes_in(sonic, 0x23));
+	printk("  0x04: left CD         = 0x%02x  ", snd_sonicvibes_in(sonic, 0x04));
+	printk("  0x24: ADC pll M       = 0x%02x\n", snd_sonicvibes_in(sonic, 0x24));
+	printk("  0x05: right CD        = 0x%02x  ", snd_sonicvibes_in(sonic, 0x05));
+	printk("  0x25: ADC pll N       = 0x%02x\n", snd_sonicvibes_in(sonic, 0x25));
+	printk("  0x06: left line       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x06));
+	printk("  0x26: Synth pll M     = 0x%02x\n", snd_sonicvibes_in(sonic, 0x26));
+	printk("  0x07: right line      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x07));
+	printk("  0x27: Synth pll N     = 0x%02x\n", snd_sonicvibes_in(sonic, 0x27));
+	printk("  0x08: MIC             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x08));
+	printk("  0x28: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x28));
+	printk("  0x09: Game port       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x09));
+	printk("  0x29: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x29));
+	printk("  0x0a: left synth      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0a));
+	printk("  0x2a: MPU401          = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2a));
+	printk("  0x0b: right synth     = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0b));
+	printk("  0x2b: drive ctrl      = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2b));
+	printk("  0x0c: left AUX2       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0c));
+	printk("  0x2c: SRS space       = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2c));
+	printk("  0x0d: right AUX2      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0d));
+	printk("  0x2d: SRS center      = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2d));
+	printk("  0x0e: left analog     = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0e));
+	printk("  0x2e: wave source     = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2e));
+	printk("  0x0f: right analog    = 0x%02x  ", snd_sonicvibes_in(sonic, 0x0f));
+	printk("  0x2f: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2f));
+	printk("  0x10: left PCM        = 0x%02x  ", snd_sonicvibes_in(sonic, 0x10));
+	printk("  0x30: analog power    = 0x%02x\n", snd_sonicvibes_in(sonic, 0x30));
+	printk("  0x11: right PCM       = 0x%02x  ", snd_sonicvibes_in(sonic, 0x11));
+	printk("  0x31: analog power    = 0x%02x\n", snd_sonicvibes_in(sonic, 0x31));
+	printk("  0x12: DMA data format = 0x%02x  ", snd_sonicvibes_in(sonic, 0x12));
+	printk("  0x32: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x32));
+	printk("  0x13: P/C enable      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x13));
+	printk("  0x33: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x33));
+	printk("  0x14: U/D button      = 0x%02x  ", snd_sonicvibes_in(sonic, 0x14));
+	printk("  0x34: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x34));
+	printk("  0x15: revision        = 0x%02x  ", snd_sonicvibes_in(sonic, 0x15));
+	printk("  0x35: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x35));
+	printk("  0x16: ADC output ctrl = 0x%02x  ", snd_sonicvibes_in(sonic, 0x16));
+	printk("  0x36: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x36));
+	printk("  0x17: ---             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x17));
+	printk("  0x37: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x37));
+	printk("  0x18: DMA A upper cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x18));
+	printk("  0x38: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x38));
+	printk("  0x19: DMA A lower cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x19));
+	printk("  0x39: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x39));
+	printk("  0x1a: ---             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1a));
+	printk("  0x3a: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3a));
+	printk("  0x1b: ---             = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1b));
+	printk("  0x3b: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3b));
+	printk("  0x1c: DMA C upper cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1c));
+	printk("  0x3c: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3c));
+	printk("  0x1d: DMA C upper cnt = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1d));
+	printk("  0x3d: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3d));
+	printk("  0x1e: PCM rate low    = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1e));
+	printk("  0x3e: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3e));
+	printk("  0x1f: PCM rate high   = 0x%02x  ", snd_sonicvibes_in(sonic, 0x1f));
+	printk("  0x3f: ---             = 0x%02x\n", snd_sonicvibes_in(sonic, 0x3f));
+}
+
+#endif
+
+static void snd_sonicvibes_setfmt(sonicvibes_t * sonic,
+                                  unsigned char mask,
+                                  unsigned char value)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&sonic->reg_lock, flags);
+	outb(SV_MCE | SV_IREG_DMA_DATA_FMT, SV_REG(sonic, INDEX));
+	if (mask) {
+		sonic->format = inb(SV_REG(sonic, DATA));
+		udelay(10);
+	}
+	sonic->format = (sonic->format & mask) | value;
+	outb(sonic->format, SV_REG(sonic, DATA));
+	udelay(10);
+	outb(0, SV_REG(sonic, INDEX));
+	udelay(10);
+	spin_unlock_irqrestore(&sonic->reg_lock, flags);
+}
+
+static void snd_sonicvibes_pll(unsigned int rate,
+			       unsigned int *res_r,
+			       unsigned int *res_m,
+			       unsigned int *res_n)
+{
+	unsigned int r, m = 0, n = 0;
+	unsigned int xm, xn, xr, xd, metric = ~0U;
+
+	if (rate < 625000 / SV_ADCMULT)
+		rate = 625000 / SV_ADCMULT;
+	if (rate > 150000000 / SV_ADCMULT)
+		rate = 150000000 / SV_ADCMULT;
+	/* slight violation of specs, needed for continuous sampling rates */
+	for (r = 0; rate < 75000000 / SV_ADCMULT; r += 0x20, rate <<= 1);
+	for (xn = 3; xn < 33; xn++)	/* 35 */
+		for (xm = 3; xm < 257; xm++) {
+			xr = ((SV_REFFREQUENCY / SV_ADCMULT) * xm) / xn;
+			if (xr >= rate)
+				xd = xr - rate;
+			else
+				xd = rate - xr;
+			if (xd < metric) {
+				metric = xd;
+				m = xm - 2;
+				n = xn - 2;
+			}
+		}
+	*res_r = r;
+	*res_m = m;
+	*res_n = n;
+#if 0
+	printk("metric = %i, xm = %i, xn = %i\n", metric, xm, xn);
+	printk("pll: m = 0x%x, r = 0x%x, n = 0x%x\n", reg, m, r, n);
+#endif
+}
+
+static void snd_sonicvibes_setpll(sonicvibes_t * sonic,
+                                  unsigned char reg,
+                                  unsigned int rate)
+{
+	unsigned long flags;
+	unsigned int r, m, n;
+
+	snd_sonicvibes_pll(rate, &r, &m, &n);
+	if (sonic != NULL) {
+		spin_lock_irqsave(&sonic->reg_lock, flags);
+		snd_sonicvibes_out1(sonic, reg, m);
+		snd_sonicvibes_out1(sonic, reg + 1, r | n);
+		spin_unlock_irqrestore(&sonic->reg_lock, flags);
+	}
+}
+
+static void snd_sonicvibes_set_adc_rate(sonicvibes_t * sonic, unsigned int rate)
+{
+	unsigned long flags;
+	unsigned int div;
+	unsigned char clock;
+
+	div = 48000 / rate;
+	if (div > 8)
+		div = 8;
+	if ((48000 / div) == rate) {	/* use the alternate clock */
+		clock = 0x10;
+	} else {			/* use the PLL source */
+		clock = 0x00;
+		snd_sonicvibes_setpll(sonic, SV_IREG_ADC_PLL, rate);
+	}
+	spin_lock_irqsave(&sonic->reg_lock, flags);
+	snd_sonicvibes_out1(sonic, SV_IREG_ADC_ALT_RATE, (div - 1) << 4);
+	snd_sonicvibes_out1(sonic, SV_IREG_ADC_CLOCK, clock);
+	spin_unlock_irqrestore(&sonic->reg_lock, flags);
+}
+
+static int snd_sonicvibes_hw_constraint_dac_rate(snd_pcm_hw_params_t *params,
+						 snd_pcm_hw_rule_t *rule)
+{
+	unsigned int rate, div, r, m, n;
+
+	if (hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->min == 
+	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->max) {
+		rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->min;
+		div = 48000 / rate;
+		if (div > 8)
+			div = 8;
+		if ((48000 / div) == rate) {
+			params->rate_num = rate;
+			params->rate_den = 1;
+		} else {
+			snd_sonicvibes_pll(rate, &r, &m, &n);
+			snd_assert((SV_REFFREQUENCY % 16) == 0, return -EINVAL);
+			snd_assert((SV_ADCMULT % 512) == 0, return -EINVAL);
+			params->rate_num = (SV_REFFREQUENCY/16) * (n+2) * r;
+			params->rate_den = (SV_ADCMULT/512) * (m+2);
+		}
+	}
+	return 0;
+}
+
+static void snd_sonicvibes_set_dac_rate(sonicvibes_t * sonic, unsigned int rate)
+{
+	unsigned int div;
+	unsigned long flags;
+
+	div = (rate * 65536 + SV_FULLRATE / 2) / SV_FULLRATE;
+	if (div > 65535)
+		div = 65535;
+	spin_lock_irqsave(&sonic->reg_lock, flags);
+	snd_sonicvibes_out1(sonic, SV_IREG_PCM_RATE_HIGH, div >> 8);
+	snd_sonicvibes_out1(sonic, SV_IREG_PCM_RATE_LOW, div);
+	spin_unlock_irqrestore(&sonic->reg_lock, flags);
+}
+
+static int snd_sonicvibes_trigger(sonicvibes_t * sonic, int what, int cmd)
+{
+	int result = 0;
+
+	spin_lock(&sonic->reg_lock);
+	if (cmd == SNDRV_PCM_TRIGGER_START) {
+		if (!(sonic->enable & what)) {
+			sonic->enable |= what;
+			snd_sonicvibes_out1(sonic, SV_IREG_PC_ENABLE, sonic->enable);
+		}
+	} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {
+		if (sonic->enable & what) {
+			sonic->enable &= ~what;
+			snd_sonicvibes_out1(sonic, SV_IREG_PC_ENABLE, sonic->enable);
+		}
+	} else {
+		result = -EINVAL;
+	}
+	spin_unlock(&sonic->reg_lock);
+	return result;
+}
+
+static irqreturn_t snd_sonicvibes_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	sonicvibes_t *sonic = dev_id;
+	unsigned char status;
+
+	status = inb(SV_REG(sonic, STATUS));
+	if (!(status & (SV_DMAA_IRQ | SV_DMAC_IRQ | SV_MIDI_IRQ)))
+		return IRQ_NONE;
+	if (status == 0xff) {	/* failure */
+		outb(sonic->irqmask = ~0, SV_REG(sonic, IRQMASK));
+		snd_printk("IRQ failure - interrupts disabled!!\n");
+		return IRQ_HANDLED;
+	}
+	if (sonic->pcm) {
+		if (status & SV_DMAA_IRQ)
+			snd_pcm_period_elapsed(sonic->playback_substream);
+		if (status & SV_DMAC_IRQ)
+			snd_pcm_period_elapsed(sonic->capture_substream);
+	}
+	if (sonic->rmidi) {
+		if (status & SV_MIDI_IRQ)
+			snd_mpu401_uart_interrupt(irq, sonic->rmidi->private_data, regs);
+	}
+	if (status & SV_UD_IRQ) {
+		unsigned char udreg;
+		int vol, oleft, oright, mleft, mright;
+
+		spin_lock(&sonic->reg_lock);
+		udreg = snd_sonicvibes_in1(sonic, SV_IREG_UD_BUTTON);
+		vol = udreg & 0x3f;
+		if (!(udreg & 0x40))
+			vol = -vol;
+		oleft = mleft = snd_sonicvibes_in1(sonic, SV_IREG_LEFT_ANALOG);
+		oright = mright = snd_sonicvibes_in1(sonic, SV_IREG_RIGHT_ANALOG);
+		oleft &= 0x1f;
+		oright &= 0x1f;
+		oleft += vol;
+		if (oleft < 0)
+			oleft = 0;
+		if (oleft > 0x1f)
+			oleft = 0x1f;
+		oright += vol;
+		if (oright < 0)
+			oright = 0;
+		if (oright > 0x1f)
+			oright = 0x1f;
+		if (udreg & 0x80) {
+			mleft ^= 0x80;
+			mright ^= 0x80;
+		}
+		oleft |= mleft & 0x80;
+		oright |= mright & 0x80;
+		snd_sonicvibes_out1(sonic, SV_IREG_LEFT_ANALOG, oleft);
+		snd_sonicvibes_out1(sonic, SV_IREG_RIGHT_ANALOG, oright);
+		spin_unlock(&sonic->reg_lock);
+		snd_ctl_notify(sonic->card, SNDRV_CTL_EVENT_MASK_VALUE, &sonic->master_mute->id);
+		snd_ctl_notify(sonic->card, SNDRV_CTL_EVENT_MASK_VALUE, &sonic->master_volume->id);
+	}
+	return IRQ_HANDLED;
+}
+
+/*
+ *  PCM part
+ */
+
+static int snd_sonicvibes_playback_trigger(snd_pcm_substream_t * substream,
+					   int cmd)
+{
+	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+	return snd_sonicvibes_trigger(sonic, 1, cmd);
+}
+
+static int snd_sonicvibes_capture_trigger(snd_pcm_substream_t * substream,
+					  int cmd)
+{
+	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+	return snd_sonicvibes_trigger(sonic, 2, cmd);
+}
+
+static int snd_sonicvibes_hw_params(snd_pcm_substream_t * substream,
+				    snd_pcm_hw_params_t * hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+}
+
+static int snd_sonicvibes_hw_free(snd_pcm_substream_t * substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int snd_sonicvibes_playback_prepare(snd_pcm_substream_t * substream)
+{
+	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned char fmt = 0;
+	unsigned int size = snd_pcm_lib_buffer_bytes(substream);
+	unsigned int count = snd_pcm_lib_period_bytes(substream);
+
+	sonic->p_dma_size = size;
+	count--;
+	if (runtime->channels > 1)
+		fmt |= 1;
+	if (snd_pcm_format_width(runtime->format) == 16)
+		fmt |= 2;
+	snd_sonicvibes_setfmt(sonic, ~3, fmt);
+	snd_sonicvibes_set_dac_rate(sonic, runtime->rate);
+	spin_lock_irq(&sonic->reg_lock);
+	snd_sonicvibes_setdmaa(sonic, runtime->dma_addr, size);
+	snd_sonicvibes_out1(sonic, SV_IREG_DMA_A_UPPER, count >> 8);
+	snd_sonicvibes_out1(sonic, SV_IREG_DMA_A_LOWER, count);
+	spin_unlock_irq(&sonic->reg_lock);
+	return 0;
+}
+
+static int snd_sonicvibes_capture_prepare(snd_pcm_substream_t * substream)
+{
+	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	unsigned char fmt = 0;
+	unsigned int size = snd_pcm_lib_buffer_bytes(substream);
+	unsigned int count = snd_pcm_lib_period_bytes(substream);
+
+	sonic->c_dma_size = size;
+	count >>= 1;
+	count--;
+	if (runtime->channels > 1)
+		fmt |= 0x10;
+	if (snd_pcm_format_width(runtime->format) == 16)
+		fmt |= 0x20;
+	snd_sonicvibes_setfmt(sonic, ~0x30, fmt);
+	snd_sonicvibes_set_adc_rate(sonic, runtime->rate);
+	spin_lock_irq(&sonic->reg_lock);
+	snd_sonicvibes_setdmac(sonic, runtime->dma_addr, size);
+	snd_sonicvibes_out1(sonic, SV_IREG_DMA_C_UPPER, count >> 8);
+	snd_sonicvibes_out1(sonic, SV_IREG_DMA_C_LOWER, count);
+	spin_unlock_irq(&sonic->reg_lock);
+	return 0;
+}
+
+static snd_pcm_uframes_t snd_sonicvibes_playback_pointer(snd_pcm_substream_t * substream)
+{
+	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+	size_t ptr;
+
+	if (!(sonic->enable & 1))
+		return 0;
+	ptr = sonic->p_dma_size - snd_sonicvibes_getdmaa(sonic);
+	return bytes_to_frames(substream->runtime, ptr);
+}
+
+static snd_pcm_uframes_t snd_sonicvibes_capture_pointer(snd_pcm_substream_t * substream)
+{
+	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+	size_t ptr;
+	if (!(sonic->enable & 2))
+		return 0;
+	ptr = sonic->c_dma_size - snd_sonicvibes_getdmac(sonic);
+	return bytes_to_frames(substream->runtime, ptr);
+}
+
+static snd_pcm_hardware_t snd_sonicvibes_playback =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	32,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+static snd_pcm_hardware_t snd_sonicvibes_capture =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(128*1024),
+	.period_bytes_min =	32,
+	.period_bytes_max =	(128*1024),
+	.periods_min =		1,
+	.periods_max =		1024,
+	.fifo_size =		0,
+};
+
+static int snd_sonicvibes_playback_open(snd_pcm_substream_t * substream)
+{
+	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	sonic->mode |= SV_MODE_PLAY;
+	sonic->playback_substream = substream;
+	runtime->hw = snd_sonicvibes_playback;
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, snd_sonicvibes_hw_constraint_dac_rate, NULL, SNDRV_PCM_HW_PARAM_RATE, -1);
+	return 0;
+}
+
+static int snd_sonicvibes_capture_open(snd_pcm_substream_t * substream)
+{
+	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	sonic->mode |= SV_MODE_CAPTURE;
+	sonic->capture_substream = substream;
+	runtime->hw = snd_sonicvibes_capture;
+	snd_pcm_hw_constraint_ratdens(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				      &snd_sonicvibes_hw_constraints_adc_clock);
+	return 0;
+}
+
+static int snd_sonicvibes_playback_close(snd_pcm_substream_t * substream)
+{
+	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+
+	sonic->playback_substream = NULL;
+	sonic->mode &= ~SV_MODE_PLAY;
+	return 0;
+}
+
+static int snd_sonicvibes_capture_close(snd_pcm_substream_t * substream)
+{
+	sonicvibes_t *sonic = snd_pcm_substream_chip(substream);
+
+	sonic->capture_substream = NULL;
+	sonic->mode &= ~SV_MODE_CAPTURE;
+	return 0;
+}
+
+static snd_pcm_ops_t snd_sonicvibes_playback_ops = {
+	.open =		snd_sonicvibes_playback_open,
+	.close =	snd_sonicvibes_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_sonicvibes_hw_params,
+	.hw_free =	snd_sonicvibes_hw_free,
+	.prepare =	snd_sonicvibes_playback_prepare,
+	.trigger =	snd_sonicvibes_playback_trigger,
+	.pointer =	snd_sonicvibes_playback_pointer,
+};
+
+static snd_pcm_ops_t snd_sonicvibes_capture_ops = {
+	.open =		snd_sonicvibes_capture_open,
+	.close =	snd_sonicvibes_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_sonicvibes_hw_params,
+	.hw_free =	snd_sonicvibes_hw_free,
+	.prepare =	snd_sonicvibes_capture_prepare,
+	.trigger =	snd_sonicvibes_capture_trigger,
+	.pointer =	snd_sonicvibes_capture_pointer,
+};
+
+static void snd_sonicvibes_pcm_free(snd_pcm_t *pcm)
+{
+	sonicvibes_t *sonic = pcm->private_data;
+	sonic->pcm = NULL;
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static int __devinit snd_sonicvibes_pcm(sonicvibes_t * sonic, int device, snd_pcm_t ** rpcm)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	if ((err = snd_pcm_new(sonic->card, "s3_86c617", device, 1, 1, &pcm)) < 0)
+		return err;
+	snd_assert(pcm != NULL, return -EINVAL);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_sonicvibes_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_sonicvibes_capture_ops);
+
+	pcm->private_data = sonic;
+	pcm->private_free = snd_sonicvibes_pcm_free;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "S3 SonicVibes");
+	sonic->pcm = pcm;
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      snd_dma_pci_data(sonic->pci), 64*1024, 128*1024);
+
+	if (rpcm)
+		*rpcm = pcm;
+	return 0;
+}
+
+/*
+ *  Mixer part
+ */
+
+#define SONICVIBES_MUX(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+  .info = snd_sonicvibes_info_mux, \
+  .get = snd_sonicvibes_get_mux, .put = snd_sonicvibes_put_mux }
+
+static int snd_sonicvibes_info_mux(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[7] = {
+		"CD", "PCM", "Aux1", "Line", "Aux0", "Mic", "Mix"
+	};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 2;
+	uinfo->value.enumerated.items = 7;
+	if (uinfo->value.enumerated.item >= 7)
+		uinfo->value.enumerated.item = 6;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_sonicvibes_get_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	sonicvibes_t *sonic = snd_kcontrol_chip(kcontrol);
+	
+	spin_lock_irq(&sonic->reg_lock);
+	ucontrol->value.enumerated.item[0] = ((snd_sonicvibes_in1(sonic, SV_IREG_LEFT_ADC) & SV_RECSRC_OUT) >> 5) - 1;
+	ucontrol->value.enumerated.item[1] = ((snd_sonicvibes_in1(sonic, SV_IREG_RIGHT_ADC) & SV_RECSRC_OUT) >> 5) - 1;
+	spin_unlock_irq(&sonic->reg_lock);
+	return 0;
+}
+
+static int snd_sonicvibes_put_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	sonicvibes_t *sonic = snd_kcontrol_chip(kcontrol);
+	unsigned short left, right, oval1, oval2;
+	int change;
+	
+	if (ucontrol->value.enumerated.item[0] >= 7 ||
+	    ucontrol->value.enumerated.item[1] >= 7)
+		return -EINVAL;
+	left = (ucontrol->value.enumerated.item[0] + 1) << 5;
+	right = (ucontrol->value.enumerated.item[1] + 1) << 5;
+	spin_lock_irq(&sonic->reg_lock);
+	oval1 = snd_sonicvibes_in1(sonic, SV_IREG_LEFT_ADC);
+	oval2 = snd_sonicvibes_in1(sonic, SV_IREG_RIGHT_ADC);
+	left = (oval1 & ~SV_RECSRC_OUT) | left;
+	right = (oval2 & ~SV_RECSRC_OUT) | right;
+	change = left != oval1 || right != oval2;
+	snd_sonicvibes_out1(sonic, SV_IREG_LEFT_ADC, left);
+	snd_sonicvibes_out1(sonic, SV_IREG_RIGHT_ADC, right);
+	spin_unlock_irq(&sonic->reg_lock);
+	return change;
+}
+
+#define SONICVIBES_SINGLE(xname, xindex, reg, shift, mask, invert) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+  .info = snd_sonicvibes_info_single, \
+  .get = snd_sonicvibes_get_single, .put = snd_sonicvibes_put_single, \
+  .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }
+
+static int snd_sonicvibes_info_single(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+
+	uinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+
+static int snd_sonicvibes_get_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	sonicvibes_t *sonic = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0xff;
+	
+	spin_lock_irq(&sonic->reg_lock);
+	ucontrol->value.integer.value[0] = (snd_sonicvibes_in1(sonic, reg)>> shift) & mask;
+	spin_unlock_irq(&sonic->reg_lock);
+	if (invert)
+		ucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static int snd_sonicvibes_put_single(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	sonicvibes_t *sonic = snd_kcontrol_chip(kcontrol);
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0xff;
+	int mask = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0xff;
+	int change;
+	unsigned short val, oval;
+	
+	val = (ucontrol->value.integer.value[0] & mask);
+	if (invert)
+		val = mask - val;
+	val <<= shift;
+	spin_lock_irq(&sonic->reg_lock);
+	oval = snd_sonicvibes_in1(sonic, reg);
+	val = (oval & ~(mask << shift)) | val;
+	change = val != oval;
+	snd_sonicvibes_out1(sonic, reg, val);
+	spin_unlock_irq(&sonic->reg_lock);
+	return change;
+}
+
+#define SONICVIBES_DOUBLE(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, .index = xindex, \
+  .info = snd_sonicvibes_info_double, \
+  .get = snd_sonicvibes_get_double, .put = snd_sonicvibes_put_double, \
+  .private_value = left_reg | (right_reg << 8) | (shift_left << 16) | (shift_right << 19) | (mask << 24) | (invert << 22) }
+
+static int snd_sonicvibes_info_double(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	int mask = (kcontrol->private_value >> 24) & 0xff;
+
+	uinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+	return 0;
+}
+
+static int snd_sonicvibes_get_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	sonicvibes_t *sonic = snd_kcontrol_chip(kcontrol);
+	int left_reg = kcontrol->private_value & 0xff;
+	int right_reg = (kcontrol->private_value >> 8) & 0xff;
+	int shift_left = (kcontrol->private_value >> 16) & 0x07;
+	int shift_right = (kcontrol->private_value >> 19) & 0x07;
+	int mask = (kcontrol->private_value >> 24) & 0xff;
+	int invert = (kcontrol->private_value >> 22) & 1;
+	
+	spin_lock_irq(&sonic->reg_lock);
+	ucontrol->value.integer.value[0] = (snd_sonicvibes_in1(sonic, left_reg) >> shift_left) & mask;
+	ucontrol->value.integer.value[1] = (snd_sonicvibes_in1(sonic, right_reg) >> shift_right) & mask;
+	spin_unlock_irq(&sonic->reg_lock);
+	if (invert) {
+		ucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];
+		ucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];
+	}
+	return 0;
+}
+
+static int snd_sonicvibes_put_double(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	sonicvibes_t *sonic = snd_kcontrol_chip(kcontrol);
+	int left_reg = kcontrol->private_value & 0xff;
+	int right_reg = (kcontrol->private_value >> 8) & 0xff;
+	int shift_left = (kcontrol->private_value >> 16) & 0x07;
+	int shift_right = (kcontrol->private_value >> 19) & 0x07;
+	int mask = (kcontrol->private_value >> 24) & 0xff;
+	int invert = (kcontrol->private_value >> 22) & 1;
+	int change;
+	unsigned short val1, val2, oval1, oval2;
+	
+	val1 = ucontrol->value.integer.value[0] & mask;
+	val2 = ucontrol->value.integer.value[1] & mask;
+	if (invert) {
+		val1 = mask - val1;
+		val2 = mask - val2;
+	}
+	val1 <<= shift_left;
+	val2 <<= shift_right;
+	spin_lock_irq(&sonic->reg_lock);
+	oval1 = snd_sonicvibes_in1(sonic, left_reg);
+	oval2 = snd_sonicvibes_in1(sonic, right_reg);
+	val1 = (oval1 & ~(mask << shift_left)) | val1;
+	val2 = (oval2 & ~(mask << shift_right)) | val2;
+	change = val1 != oval1 || val2 != oval2;
+	snd_sonicvibes_out1(sonic, left_reg, val1);
+	snd_sonicvibes_out1(sonic, right_reg, val2);
+	spin_unlock_irq(&sonic->reg_lock);
+	return change;
+}
+
+static snd_kcontrol_new_t snd_sonicvibes_controls[] __devinitdata = {
+SONICVIBES_DOUBLE("Capture Volume", 0, SV_IREG_LEFT_ADC, SV_IREG_RIGHT_ADC, 0, 0, 15, 0),
+SONICVIBES_DOUBLE("Aux Playback Switch", 0, SV_IREG_LEFT_AUX1, SV_IREG_RIGHT_AUX1, 7, 7, 1, 1),
+SONICVIBES_DOUBLE("Aux Playback Volume", 0, SV_IREG_LEFT_AUX1, SV_IREG_RIGHT_AUX1, 0, 0, 31, 1),
+SONICVIBES_DOUBLE("CD Playback Switch", 0, SV_IREG_LEFT_CD, SV_IREG_RIGHT_CD, 7, 7, 1, 1),
+SONICVIBES_DOUBLE("CD Playback Volume", 0, SV_IREG_LEFT_CD, SV_IREG_RIGHT_CD, 0, 0, 31, 1),
+SONICVIBES_DOUBLE("Line Playback Switch", 0, SV_IREG_LEFT_LINE, SV_IREG_RIGHT_LINE, 7, 7, 1, 1),
+SONICVIBES_DOUBLE("Line Playback Volume", 0, SV_IREG_LEFT_LINE, SV_IREG_RIGHT_LINE, 0, 0, 31, 1),
+SONICVIBES_SINGLE("Mic Playback Switch", 0, SV_IREG_MIC, 7, 1, 1),
+SONICVIBES_SINGLE("Mic Playback Volume", 0, SV_IREG_MIC, 0, 15, 1),
+SONICVIBES_SINGLE("Mic Boost", 0, SV_IREG_LEFT_ADC, 4, 1, 0),
+SONICVIBES_DOUBLE("Synth Playback Switch", 0, SV_IREG_LEFT_SYNTH, SV_IREG_RIGHT_SYNTH, 7, 7, 1, 1),
+SONICVIBES_DOUBLE("Synth Playback Volume", 0, SV_IREG_LEFT_SYNTH, SV_IREG_RIGHT_SYNTH, 0, 0, 31, 1),
+SONICVIBES_DOUBLE("Aux Playback Switch", 1, SV_IREG_LEFT_AUX2, SV_IREG_RIGHT_AUX2, 7, 7, 1, 1),
+SONICVIBES_DOUBLE("Aux Playback Volume", 1, SV_IREG_LEFT_AUX2, SV_IREG_RIGHT_AUX2, 0, 0, 31, 1),
+SONICVIBES_DOUBLE("Master Playback Switch", 0, SV_IREG_LEFT_ANALOG, SV_IREG_RIGHT_ANALOG, 7, 7, 1, 1),
+SONICVIBES_DOUBLE("Master Playback Volume", 0, SV_IREG_LEFT_ANALOG, SV_IREG_RIGHT_ANALOG, 0, 0, 31, 1),
+SONICVIBES_DOUBLE("PCM Playback Switch", 0, SV_IREG_LEFT_PCM, SV_IREG_RIGHT_PCM, 7, 7, 1, 1),
+SONICVIBES_DOUBLE("PCM Playback Volume", 0, SV_IREG_LEFT_PCM, SV_IREG_RIGHT_PCM, 0, 0, 63, 1),
+SONICVIBES_SINGLE("Loopback Capture Switch", 0, SV_IREG_ADC_OUTPUT_CTRL, 0, 1, 0),
+SONICVIBES_SINGLE("Loopback Capture Volume", 0, SV_IREG_ADC_OUTPUT_CTRL, 2, 63, 1),
+SONICVIBES_MUX("Capture Source", 0)
+};
+
+static void snd_sonicvibes_master_free(snd_kcontrol_t *kcontrol)
+{
+	sonicvibes_t *sonic = snd_kcontrol_chip(kcontrol);
+	sonic->master_mute = NULL;
+	sonic->master_volume = NULL;
+}
+
+static int __devinit snd_sonicvibes_mixer(sonicvibes_t * sonic)
+{
+	snd_card_t *card;
+	snd_kcontrol_t *kctl;
+	unsigned int idx;
+	int err;
+
+	snd_assert(sonic != NULL && sonic->card != NULL, return -EINVAL);
+	card = sonic->card;
+	strcpy(card->mixername, "S3 SonicVibes");
+
+	for (idx = 0; idx < ARRAY_SIZE(snd_sonicvibes_controls); idx++) {
+		if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_sonicvibes_controls[idx], sonic))) < 0)
+			return err;
+		switch (idx) {
+		case 0:
+		case 1: kctl->private_free = snd_sonicvibes_master_free; break;
+		}
+	}
+	return 0;
+}
+
+/*
+
+ */
+
+static void snd_sonicvibes_proc_read(snd_info_entry_t *entry, 
+				     snd_info_buffer_t * buffer)
+{
+	sonicvibes_t *sonic = entry->private_data;
+	unsigned char tmp;
+
+	tmp = sonic->srs_space & 0x0f;
+	snd_iprintf(buffer, "SRS 3D           : %s\n",
+		    sonic->srs_space & 0x80 ? "off" : "on");
+	snd_iprintf(buffer, "SRS Space        : %s\n",
+		    tmp == 0x00 ? "100%" :
+		    tmp == 0x01 ? "75%" :
+		    tmp == 0x02 ? "50%" :
+		    tmp == 0x03 ? "25%" : "0%");
+	tmp = sonic->srs_center & 0x0f;
+	snd_iprintf(buffer, "SRS Center       : %s\n",
+		    tmp == 0x00 ? "100%" :
+		    tmp == 0x01 ? "75%" :
+		    tmp == 0x02 ? "50%" :
+		    tmp == 0x03 ? "25%" : "0%");
+	tmp = sonic->wave_source & 0x03;
+	snd_iprintf(buffer, "WaveTable Source : %s\n",
+		    tmp == 0x00 ? "on-board ROM" :
+		    tmp == 0x01 ? "PCI bus" : "on-board ROM + PCI bus");
+	tmp = sonic->mpu_switch;
+	snd_iprintf(buffer, "Onboard synth    : %s\n", tmp & 0x01 ? "on" : "off");
+	snd_iprintf(buffer, "Ext. Rx to synth : %s\n", tmp & 0x02 ? "on" : "off");
+	snd_iprintf(buffer, "MIDI to ext. Tx  : %s\n", tmp & 0x04 ? "on" : "off");
+}
+
+static void __devinit snd_sonicvibes_proc_init(sonicvibes_t * sonic)
+{
+	snd_info_entry_t *entry;
+
+	if (! snd_card_proc_new(sonic->card, "sonicvibes", &entry))
+		snd_info_set_text_ops(entry, sonic, 1024, snd_sonicvibes_proc_read);
+}
+
+/*
+
+ */
+
+#ifdef SUPPORT_JOYSTICK
+static snd_kcontrol_new_t snd_sonicvibes_game_control __devinitdata =
+SONICVIBES_SINGLE("Joystick Speed", 0, SV_IREG_GAME_PORT, 1, 15, 0);
+
+static int __devinit snd_sonicvibes_create_gameport(sonicvibes_t *sonic)
+{
+	struct gameport *gp;
+
+	sonic->gameport = gp = gameport_allocate_port();
+	if (!gp) {
+		printk(KERN_ERR "sonicvibes: cannot allocate memory for gameport\n");
+		return -ENOMEM;
+	}
+
+	gameport_set_name(gp, "SonicVibes Gameport");
+	gameport_set_phys(gp, "pci%s/gameport0", pci_name(sonic->pci));
+	gameport_set_dev_parent(gp, &sonic->pci->dev);
+	gp->io = sonic->game_port;
+
+	gameport_register_port(gp);
+
+	snd_ctl_add(sonic->card, snd_ctl_new1(&snd_sonicvibes_game_control, sonic));
+
+	return 0;
+}
+
+static void snd_sonicvibes_free_gameport(sonicvibes_t *sonic)
+{
+	if (sonic->gameport) {
+		gameport_unregister_port(sonic->gameport);
+		sonic->gameport = NULL;
+	}
+}
+#else
+static inline int snd_sonicvibes_create_gameport(sonicvibes_t *sonic) { return -ENOSYS; }
+static inline void snd_sonicvibes_free_gameport(sonicvibes_t *sonic) { }
+#endif
+
+static int snd_sonicvibes_free(sonicvibes_t *sonic)
+{
+	snd_sonicvibes_free_gameport(sonic);
+	pci_write_config_dword(sonic->pci, 0x40, sonic->dmaa_port);
+	pci_write_config_dword(sonic->pci, 0x48, sonic->dmac_port);
+	if (sonic->irq >= 0)
+		free_irq(sonic->irq, (void *)sonic);
+	if (sonic->res_dmaa) {
+		release_resource(sonic->res_dmaa);
+		kfree_nocheck(sonic->res_dmaa);
+	}
+	if (sonic->res_dmac) {
+		release_resource(sonic->res_dmac);
+		kfree_nocheck(sonic->res_dmac);
+	}
+	pci_release_regions(sonic->pci);
+	pci_disable_device(sonic->pci);
+	kfree(sonic);
+	return 0;
+}
+
+static int snd_sonicvibes_dev_free(snd_device_t *device)
+{
+	sonicvibes_t *sonic = device->device_data;
+	return snd_sonicvibes_free(sonic);
+}
+
+static int __devinit snd_sonicvibes_create(snd_card_t * card,
+					struct pci_dev *pci,
+					int reverb,
+					int mge,
+					sonicvibes_t ** rsonic)
+{
+	sonicvibes_t *sonic;
+	unsigned int dmaa, dmac;
+	int err;
+	static snd_device_ops_t ops = {
+		.dev_free =	snd_sonicvibes_dev_free,
+	};
+
+	*rsonic = NULL;
+	/* enable PCI device */
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+	/* check, if we can restrict PCI DMA transfers to 24 bits */
+        if (pci_set_dma_mask(pci, 0x00ffffff) < 0 ||
+	    pci_set_consistent_dma_mask(pci, 0x00ffffff) < 0) {
+                snd_printk("architecture does not support 24bit PCI busmaster DMA\n");
+		pci_disable_device(pci);
+                return -ENXIO;
+        }
+
+	sonic = kcalloc(1, sizeof(*sonic), GFP_KERNEL);
+	if (sonic == NULL) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+	spin_lock_init(&sonic->reg_lock);
+	sonic->card = card;
+	sonic->pci = pci;
+	sonic->irq = -1;
+
+	if ((err = pci_request_regions(pci, "S3 SonicVibes")) < 0) {
+		kfree(sonic);
+		pci_disable_device(pci);
+		return err;
+	}
+
+	sonic->sb_port = pci_resource_start(pci, 0);
+	sonic->enh_port = pci_resource_start(pci, 1);
+	sonic->synth_port = pci_resource_start(pci, 2);
+	sonic->midi_port = pci_resource_start(pci, 3);
+	sonic->game_port = pci_resource_start(pci, 4);
+
+	if (request_irq(pci->irq, snd_sonicvibes_interrupt, SA_INTERRUPT|SA_SHIRQ, "S3 SonicVibes", (void *)sonic)) {
+		snd_printk("unable to grab IRQ %d\n", pci->irq);
+		snd_sonicvibes_free(sonic);
+		return -EBUSY;
+	}
+	sonic->irq = pci->irq;
+
+	pci_read_config_dword(pci, 0x40, &dmaa);
+	pci_read_config_dword(pci, 0x48, &dmac);
+	dmaio &= ~0x0f;
+	dmaa &= ~0x0f;
+	dmac &= ~0x0f;
+	if (!dmaa) {
+		dmaa = dmaio;
+		dmaio += 0x10;
+		snd_printk("BIOS did not allocate DDMA channel A i/o, allocated at 0x%x\n", dmaa);
+	}
+	if (!dmac) {
+		dmac = dmaio;
+		dmaio += 0x10;
+		snd_printk("BIOS did not allocate DDMA channel C i/o, allocated at 0x%x\n", dmac);
+	}
+	pci_write_config_dword(pci, 0x40, dmaa);
+	pci_write_config_dword(pci, 0x48, dmac);
+
+	if ((sonic->res_dmaa = request_region(dmaa, 0x10, "S3 SonicVibes DDMA-A")) == NULL) {
+		snd_sonicvibes_free(sonic);
+		snd_printk("unable to grab DDMA-A port at 0x%x-0x%x\n", dmaa, dmaa + 0x10 - 1);
+		return -EBUSY;
+	}
+	if ((sonic->res_dmac = request_region(dmac, 0x10, "S3 SonicVibes DDMA-C")) == NULL) {
+		snd_sonicvibes_free(sonic);
+		snd_printk("unable to grab DDMA-C port at 0x%x-0x%x\n", dmac, dmac + 0x10 - 1);
+		return -EBUSY;
+	}
+
+	pci_read_config_dword(pci, 0x40, &sonic->dmaa_port);
+	pci_read_config_dword(pci, 0x48, &sonic->dmac_port);
+	sonic->dmaa_port &= ~0x0f;
+	sonic->dmac_port &= ~0x0f;
+	pci_write_config_dword(pci, 0x40, sonic->dmaa_port | 9);	/* enable + enhanced */
+	pci_write_config_dword(pci, 0x48, sonic->dmac_port | 9);	/* enable */
+	/* ok.. initialize S3 SonicVibes chip */
+	outb(SV_RESET, SV_REG(sonic, CONTROL));		/* reset chip */
+	udelay(100);
+	outb(0, SV_REG(sonic, CONTROL));	/* release reset */
+	udelay(100);
+	outb(SV_ENHANCED | SV_INTA | (reverb ? SV_REVERB : 0), SV_REG(sonic, CONTROL));
+	inb(SV_REG(sonic, STATUS));	/* clear IRQs */
+#if 1
+	snd_sonicvibes_out(sonic, SV_IREG_DRIVE_CTRL, 0);	/* drive current 16mA */
+#else
+	snd_sonicvibes_out(sonic, SV_IREG_DRIVE_CTRL, 0x40);	/* drive current 8mA */
+#endif
+	snd_sonicvibes_out(sonic, SV_IREG_PC_ENABLE, sonic->enable = 0);	/* disable playback & capture */
+	outb(sonic->irqmask = ~(SV_DMAA_MASK | SV_DMAC_MASK | SV_UD_MASK), SV_REG(sonic, IRQMASK));
+	inb(SV_REG(sonic, STATUS));	/* clear IRQs */
+	snd_sonicvibes_out(sonic, SV_IREG_ADC_CLOCK, 0);	/* use PLL as clock source */
+	snd_sonicvibes_out(sonic, SV_IREG_ANALOG_POWER, 0);	/* power up analog parts */
+	snd_sonicvibes_out(sonic, SV_IREG_DIGITAL_POWER, 0);	/* power up digital parts */
+	snd_sonicvibes_setpll(sonic, SV_IREG_ADC_PLL, 8000);
+	snd_sonicvibes_out(sonic, SV_IREG_SRS_SPACE, sonic->srs_space = 0x80);	/* SRS space off */
+	snd_sonicvibes_out(sonic, SV_IREG_SRS_CENTER, sonic->srs_center = 0x00);/* SRS center off */
+	snd_sonicvibes_out(sonic, SV_IREG_MPU401, sonic->mpu_switch = 0x05);	/* MPU-401 switch */
+	snd_sonicvibes_out(sonic, SV_IREG_WAVE_SOURCE, sonic->wave_source = 0x00);	/* onboard ROM */
+	snd_sonicvibes_out(sonic, SV_IREG_PCM_RATE_LOW, (8000 * 65536 / SV_FULLRATE) & 0xff);
+	snd_sonicvibes_out(sonic, SV_IREG_PCM_RATE_HIGH, ((8000 * 65536 / SV_FULLRATE) >> 8) & 0xff);
+	snd_sonicvibes_out(sonic, SV_IREG_LEFT_ADC, mge ? 0xd0 : 0xc0);
+	snd_sonicvibes_out(sonic, SV_IREG_RIGHT_ADC, 0xc0);
+	snd_sonicvibes_out(sonic, SV_IREG_LEFT_AUX1, 0x9f);
+	snd_sonicvibes_out(sonic, SV_IREG_RIGHT_AUX1, 0x9f);
+	snd_sonicvibes_out(sonic, SV_IREG_LEFT_CD, 0x9f);
+	snd_sonicvibes_out(sonic, SV_IREG_RIGHT_CD, 0x9f);
+	snd_sonicvibes_out(sonic, SV_IREG_LEFT_LINE, 0x9f);
+	snd_sonicvibes_out(sonic, SV_IREG_RIGHT_LINE, 0x9f);
+	snd_sonicvibes_out(sonic, SV_IREG_MIC, 0x8f);
+	snd_sonicvibes_out(sonic, SV_IREG_LEFT_SYNTH, 0x9f);
+	snd_sonicvibes_out(sonic, SV_IREG_RIGHT_SYNTH, 0x9f);
+	snd_sonicvibes_out(sonic, SV_IREG_LEFT_AUX2, 0x9f);
+	snd_sonicvibes_out(sonic, SV_IREG_RIGHT_AUX2, 0x9f);
+	snd_sonicvibes_out(sonic, SV_IREG_LEFT_ANALOG, 0x9f);
+	snd_sonicvibes_out(sonic, SV_IREG_RIGHT_ANALOG, 0x9f);
+	snd_sonicvibes_out(sonic, SV_IREG_LEFT_PCM, 0xbf);
+	snd_sonicvibes_out(sonic, SV_IREG_RIGHT_PCM, 0xbf);
+	snd_sonicvibes_out(sonic, SV_IREG_ADC_OUTPUT_CTRL, 0xfc);
+#if 0
+	snd_sonicvibes_debug(sonic);
+#endif
+	sonic->revision = snd_sonicvibes_in(sonic, SV_IREG_REVISION);
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, sonic, &ops)) < 0) {
+		snd_sonicvibes_free(sonic);
+		return err;
+	}
+
+	snd_sonicvibes_proc_init(sonic);
+
+	snd_card_set_dev(card, &pci->dev);
+
+	*rsonic = sonic;
+	return 0;
+}
+
+/*
+ *  MIDI section
+ */
+
+static snd_kcontrol_new_t snd_sonicvibes_midi_controls[] __devinitdata = {
+SONICVIBES_SINGLE("SonicVibes Wave Source RAM", 0, SV_IREG_WAVE_SOURCE, 0, 1, 0),
+SONICVIBES_SINGLE("SonicVibes Wave Source RAM+ROM", 0, SV_IREG_WAVE_SOURCE, 1, 1, 0),
+SONICVIBES_SINGLE("SonicVibes Onboard Synth", 0, SV_IREG_MPU401, 0, 1, 0),
+SONICVIBES_SINGLE("SonicVibes External Rx to Synth", 0, SV_IREG_MPU401, 1, 1, 0),
+SONICVIBES_SINGLE("SonicVibes External Tx", 0, SV_IREG_MPU401, 2, 1, 0)
+};
+
+static int snd_sonicvibes_midi_input_open(mpu401_t * mpu)
+{
+	sonicvibes_t *sonic = mpu->private_data;
+	outb(sonic->irqmask &= ~SV_MIDI_MASK, SV_REG(sonic, IRQMASK));
+	return 0;
+}
+
+static void snd_sonicvibes_midi_input_close(mpu401_t * mpu)
+{
+	sonicvibes_t *sonic = mpu->private_data;
+	outb(sonic->irqmask |= SV_MIDI_MASK, SV_REG(sonic, IRQMASK));
+}
+
+static int __devinit snd_sonicvibes_midi(sonicvibes_t * sonic, snd_rawmidi_t * rmidi)
+{
+	mpu401_t * mpu = rmidi->private_data;
+	snd_card_t *card = sonic->card;
+	snd_rawmidi_str_t *dir;
+	unsigned int idx;
+	int err;
+
+	mpu->private_data = sonic;
+	mpu->open_input = snd_sonicvibes_midi_input_open;
+	mpu->close_input = snd_sonicvibes_midi_input_close;
+	dir = &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT];
+	for (idx = 0; idx < ARRAY_SIZE(snd_sonicvibes_midi_controls); idx++)
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_sonicvibes_midi_controls[idx], sonic))) < 0)
+			return err;
+	return 0;
+}
+
+static int __devinit snd_sonic_probe(struct pci_dev *pci,
+				     const struct pci_device_id *pci_id)
+{
+	static int dev;
+	snd_card_t *card;
+	sonicvibes_t *sonic;
+	snd_rawmidi_t *midi_uart;
+	opl3_t *opl3;
+	int idx, err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+ 
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+	for (idx = 0; idx < 5; idx++) {
+		if (pci_resource_start(pci, idx) == 0 ||
+		    !(pci_resource_flags(pci, idx) & IORESOURCE_IO)) {
+			snd_card_free(card);
+			return -ENODEV;
+		}
+	}
+	if ((err = snd_sonicvibes_create(card, pci,
+					 reverb[dev] ? 1 : 0,
+					 mge[dev] ? 1 : 0,
+					 &sonic)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	strcpy(card->driver, "SonicVibes");
+	strcpy(card->shortname, "S3 SonicVibes");
+	sprintf(card->longname, "%s rev %i at 0x%lx, irq %i",
+		card->shortname,
+		sonic->revision,
+		pci_resource_start(pci, 1),
+		sonic->irq);
+
+	if ((err = snd_sonicvibes_pcm(sonic, 0, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_sonicvibes_mixer(sonic)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_SONICVIBES,
+				       sonic->midi_port, 1,
+				       sonic->irq, 0,
+				       &midi_uart)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	snd_sonicvibes_midi(sonic, midi_uart);
+	if ((err = snd_opl3_create(card, sonic->synth_port,
+				   sonic->synth_port + 2,
+				   OPL3_HW_OPL3_SV, 1, &opl3)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	snd_sonicvibes_create_gameport(sonic);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_sonic_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name = "S3 SonicVibes",
+	.id_table = snd_sonic_ids,
+	.probe = snd_sonic_probe,
+	.remove = __devexit_p(snd_sonic_remove),
+};
+
+static int __init alsa_card_sonicvibes_init(void)
+{
+	return pci_module_init(&driver);
+}
+
+static void __exit alsa_card_sonicvibes_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_sonicvibes_init)
+module_exit(alsa_card_sonicvibes_exit)
