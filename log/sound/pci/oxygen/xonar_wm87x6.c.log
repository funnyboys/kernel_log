commit b67eb1520b39f7b56c17d452040f5371fb1104dc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:12:38 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 264
    
    Based on 1 normalized pattern(s):
    
      this driver is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 this
      driver is distributed in the hope that it will be useful but without
      any warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this driver if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 9 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141333.769845457@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index 90ac479f389f..0767276582ca 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -1,19 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * card driver for models with WM8776/WM8766 DACs (Xonar DS/HDAV1.3 Slim)
  *
  * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
- *
- *
- *  This driver is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License, version 2.
- *
- *  This driver is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this driver; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*

commit 4e3f0dc65883cac95807549b2f7a3ac183686bcb
Author: Jie Yang <yang.jie@intel.com>
Date:   Mon Apr 27 21:20:58 2015 +0800

    ALSA: jack: extend snd_jack_new to support phantom jack
    
    Dont create input devices for phantom jacks.
    
    Here, we extend snd_jack_new() to support phantom jack creating:
    pass in a bool param for [non-]phantom flag, and a bool param
    initial_jack to indicate whether we need to create a kctl at
    this stage.
    
    We can also add a kctl to the jack after its created meaning we
    can now integrate the HDA and ASoC jacks.
    
    Signed-off-by: Jie Yang <yang.jie@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index 6ce68604c25e..90ac479f389f 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -286,7 +286,7 @@ static void xonar_ds_init(struct oxygen *chip)
 	xonar_enable_output(chip);
 
 	snd_jack_new(chip->card, "Headphone",
-		     SND_JACK_HEADPHONE, &data->hp_jack);
+		     SND_JACK_HEADPHONE, &data->hp_jack, false, false);
 	xonar_ds_handle_hp_jack(chip);
 
 	snd_component_add(chip->card, "WM8776");

commit f120a6fb486c2500c9ae11fd2da11fbde29bc186
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:20 2012 -0500

    ALSA: oxygen: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index b555b620babb..6ce68604c25e 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -1320,8 +1320,8 @@ static const struct oxygen_model model_xonar_hdav_slim = {
 	.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,
 };
 
-int __devinit get_xonar_wm87x6_model(struct oxygen *chip,
-				     const struct pci_device_id *id)
+int get_xonar_wm87x6_model(struct oxygen *chip,
+			   const struct pci_device_id *id)
 {
 	switch (id->subdevice) {
 	case 0x838e:

commit 4492363251235c4499a2d073c5f09121ea23d39d
Author: Sergiu Giurgiu <sgiurgiu11@gmail.com>
Date:   Sun Sep 9 05:14:15 2012 -0400

    ALSA: virtuoso: Xonar DSX support
    
    This patch adds support for ASUS - Xonar DSX sound cards. Tested on
    openSUSE 12.2 with kernel:
    Linux 3.4.6-2.10-desktop #1 SMP PREEMPT Thu Jul 26 09:36:26 UTC 2012 (641c197) x86_64 x86_64 x86_64 GNU/Linux
    Works:
     - play sounds
     - adjust volume on master channel.
     - mute .
    
    Since Xonar DS uses the same chip, everything that works for DS should
    work for DSX as well.
    
    Signed-off-by: Sergiu Giurgiu <sgiurgiu11@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index 63cff90706bf..b555b620babb 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -1255,7 +1255,6 @@ static void dump_wm87x6_registers(struct oxygen *chip,
 }
 
 static const struct oxygen_model model_xonar_ds = {
-	.shortname = "Xonar DS",
 	.longname = "Asus Virtuoso 66",
 	.chip = "AV200",
 	.init = xonar_ds_init,
@@ -1327,6 +1326,11 @@ int __devinit get_xonar_wm87x6_model(struct oxygen *chip,
 	switch (id->subdevice) {
 	case 0x838e:
 		chip->model = model_xonar_ds;
+		chip->model.shortname = "Xonar DS";
+		break;
+	case 0x8522:
+		chip->model = model_xonar_ds;
+		chip->model.shortname = "Xonar DSX";
 		break;
 	case 0x835e:
 		chip->model = model_xonar_hdav_slim;

commit f0e48b6bd4e407459715240cd241ddb6b89bdf81
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sat Jan 14 16:42:24 2012 +0100

    ALSA: virtuoso: Xonar DS: fix polarity of front output
    
    The two DACs for the front output and the surround/center/LFE/back
    outputs are wired up out of phase, so when channels are duplicated,
    their sound can cancel out each other and result in a weaker bass
    response.  To fix this, reverse the polarity of the neutron flow to
    the front output.
    
    Reported-any-tested-by: Daniel Hill <daniel@enemyplanet.geek.nz>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: 2.6.34+ <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index 478303e6c2b0..63cff90706bf 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -177,6 +177,7 @@ static void wm8776_registers_init(struct oxygen *chip)
 	struct xonar_wm87x6 *data = chip->model_data;
 
 	wm8776_write(chip, WM8776_RESET, 0);
+	wm8776_write(chip, WM8776_PHASESWAP, WM8776_PH_MASK);
 	wm8776_write(chip, WM8776_DACCTRL1, WM8776_DZCEN |
 		     WM8776_PL_LEFT_LEFT | WM8776_PL_RIGHT_RIGHT);
 	wm8776_write(chip, WM8776_DACMUTE, chip->dac_mute ? WM8776_DMUTE : 0);

commit 56225e4cc88a24d3e1632bdfb901a3c38615fc42
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Dec 6 10:07:43 2011 +0100

    ALSA: virtuoso: add S/PDIF input support for all Xonars
    
    All Xonar cards support S/PDIF input, but the cards without optical or
    coaxial plugs have only undocumented pin connectors.  Support for the
    ST/STX was already added in a previous patch; this adds support for the
    D1/DX (JP2), DG (J5), DS (J5), and HDAV Slim (J12).
    
    Many thanks to Zoltan Miklos for testing the DS and DX.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index 42d1ab136217..478303e6c2b0 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -1274,7 +1274,8 @@ static const struct oxygen_model model_xonar_ds = {
 	.model_data_size = sizeof(struct xonar_wm87x6),
 	.device_config = PLAYBACK_0_TO_I2S |
 			 PLAYBACK_1_TO_SPDIF |
-			 CAPTURE_0_FROM_I2S_1,
+			 CAPTURE_0_FROM_I2S_1 |
+			 CAPTURE_1_FROM_SPDIF,
 	.dac_channels_pcm = 8,
 	.dac_channels_mixer = 8,
 	.dac_volume_min = 255 - 2*60,
@@ -1306,7 +1307,8 @@ static const struct oxygen_model model_xonar_hdav_slim = {
 	.model_data_size = sizeof(struct xonar_wm87x6),
 	.device_config = PLAYBACK_0_TO_I2S |
 			 PLAYBACK_1_TO_SPDIF |
-			 CAPTURE_0_FROM_I2S_1,
+			 CAPTURE_0_FROM_I2S_1 |
+			 CAPTURE_1_FROM_SPDIF,
 	.dac_channels_pcm = 8,
 	.dac_channels_mixer = 2,
 	.dac_volume_min = 255 - 2*60,

commit 9600732b6caba595f34acf2abd930098ec9a0b2b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jan 10 16:25:44 2011 +0100

    ALSA: core, oxygen, virtuoso: add an enum control info helper
    
    Introduce the helper function snd_ctl_enum_info() to fill out the
    elem_info fields for an enumerated control.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index ad48356c54e4..42d1ab136217 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -577,11 +577,6 @@ static int wm8776_field_enum_info(struct snd_kcontrol *ctl,
 	const char *const *names;
 
 	max = (ctl->private_value >> 12) & 0xf;
-	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	info->count = 1;
-	info->value.enumerated.items = max + 1;
-	if (info->value.enumerated.item > max)
-		info->value.enumerated.item = max;
 	switch ((ctl->private_value >> 24) & 0x1f) {
 	case WM8776_ALCCTRL2:
 		names = hld;
@@ -605,8 +600,7 @@ static int wm8776_field_enum_info(struct snd_kcontrol *ctl,
 	default:
 		return -ENXIO;
 	}
-	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(info, 1, max + 1, names);
 }
 
 static int wm8776_field_volume_info(struct snd_kcontrol *ctl,
@@ -863,13 +857,8 @@ static int wm8776_level_control_info(struct snd_kcontrol *ctl,
 	static const char *const names[3] = {
 		"None", "Peak Limiter", "Automatic Level Control"
 	};
-	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	info->count = 1;
-	info->value.enumerated.items = 3;
-	if (info->value.enumerated.item >= 3)
-		info->value.enumerated.item = 2;
-	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
-	return 0;
+
+	return snd_ctl_enum_info(info, 1, 3, names);
 }
 
 static int wm8776_level_control_get(struct snd_kcontrol *ctl,
@@ -955,13 +944,7 @@ static int hpf_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)
 		"None", "High-pass Filter"
 	};
 
-	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	info->count = 1;
-	info->value.enumerated.items = 2;
-	if (info->value.enumerated.item >= 2)
-		info->value.enumerated.item = 1;
-	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(info, 1, 2, names);
 }
 
 static int hpf_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)

commit b532d6b8d3aa163e1dc143bc729e9ee92f75baf5
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jan 10 16:23:57 2011 +0100

    ALSA: virtuoso: add Xonar HDAV1.3 Slim support
    
    Add experimental support for the Asus Xonar HDAV1.3 Slim sound card.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index 4f9657084603..ad48356c54e4 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -1,5 +1,5 @@
 /*
- * card driver for models with WM8776/WM8766 DACs (Xonar DS)
+ * card driver for models with WM8776/WM8766 DACs (Xonar DS/HDAV1.3 Slim)
  *
  * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
  *
@@ -77,6 +77,13 @@
 #define GPIO_DS_OUTPUT_FRONTLR	0x0080
 #define GPIO_DS_OUTPUT_ENABLE	0x0100
 
+#define GPIO_SLIM_HDMI_DISABLE	0x0001
+#define GPIO_SLIM_OUTPUT_ENABLE	0x0002
+#define GPIO_SLIM_FIRMWARE_CLK	0x0040
+#define GPIO_SLIM_FIRMWARE_DATA	0x0080
+
+#define I2C_DEVICE_WM8776	0x34	/* 001101, 0, /W=0 */
+
 #define LC_CONTROL_LIMITER	0x40000000
 #define LC_CONTROL_ALC		0x20000000
 
@@ -88,19 +95,37 @@ struct xonar_wm87x6 {
 	struct snd_kcontrol *mic_adcmux_control;
 	struct snd_kcontrol *lc_controls[13];
 	struct snd_jack *hp_jack;
+	struct xonar_hdmi hdmi;
 };
 
-static void wm8776_write(struct oxygen *chip,
-			 unsigned int reg, unsigned int value)
+static void wm8776_write_spi(struct oxygen *chip,
+			     unsigned int reg, unsigned int value)
 {
-	struct xonar_wm87x6 *data = chip->model_data;
-
 	oxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |
 			 OXYGEN_SPI_DATA_LENGTH_2 |
 			 OXYGEN_SPI_CLOCK_160 |
 			 (1 << OXYGEN_SPI_CODEC_SHIFT) |
 			 OXYGEN_SPI_CEN_LATCH_CLOCK_LO,
 			 (reg << 9) | value);
+}
+
+static void wm8776_write_i2c(struct oxygen *chip,
+			     unsigned int reg, unsigned int value)
+{
+	oxygen_write_i2c(chip, I2C_DEVICE_WM8776,
+			 (reg << 1) | (value >> 8), value);
+}
+
+static void wm8776_write(struct oxygen *chip,
+			 unsigned int reg, unsigned int value)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	if ((chip->model.function_flags & OXYGEN_FUNCTION_2WIRE_SPI_MASK) ==
+	    OXYGEN_FUNCTION_SPI)
+		wm8776_write_spi(chip, reg, value);
+	else
+		wm8776_write_i2c(chip, reg, value);
 	if (reg < ARRAY_SIZE(data->wm8776_regs)) {
 		if (reg >= WM8776_HPLVOL && reg <= WM8776_DACMASTER)
 			value &= ~WM8776_UPDATE;
@@ -267,17 +292,50 @@ static void xonar_ds_init(struct oxygen *chip)
 	snd_component_add(chip->card, "WM8766");
 }
 
+static void xonar_hdav_slim_init(struct oxygen *chip)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	data->generic.anti_pop_delay = 300;
+	data->generic.output_enable_bit = GPIO_SLIM_OUTPUT_ENABLE;
+
+	wm8776_init(chip);
+
+	oxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,
+			  GPIO_SLIM_HDMI_DISABLE |
+			  GPIO_SLIM_FIRMWARE_CLK |
+			  GPIO_SLIM_FIRMWARE_DATA);
+
+	xonar_hdmi_init(chip, &data->hdmi);
+	xonar_enable_output(chip);
+
+	snd_component_add(chip->card, "WM8776");
+}
+
 static void xonar_ds_cleanup(struct oxygen *chip)
 {
 	xonar_disable_output(chip);
 	wm8776_write(chip, WM8776_RESET, 0);
 }
 
+static void xonar_hdav_slim_cleanup(struct oxygen *chip)
+{
+	xonar_hdmi_cleanup(chip);
+	xonar_disable_output(chip);
+	wm8776_write(chip, WM8776_RESET, 0);
+	msleep(2);
+}
+
 static void xonar_ds_suspend(struct oxygen *chip)
 {
 	xonar_ds_cleanup(chip);
 }
 
+static void xonar_hdav_slim_suspend(struct oxygen *chip)
+{
+	xonar_hdav_slim_cleanup(chip);
+}
+
 static void xonar_ds_resume(struct oxygen *chip)
 {
 	wm8776_registers_init(chip);
@@ -286,6 +344,15 @@ static void xonar_ds_resume(struct oxygen *chip)
 	xonar_ds_handle_hp_jack(chip);
 }
 
+static void xonar_hdav_slim_resume(struct oxygen *chip)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	wm8776_registers_init(chip);
+	xonar_hdmi_resume(chip, &data->hdmi);
+	xonar_enable_output(chip);
+}
+
 static void wm8776_adc_hardware_filter(unsigned int channel,
 				       struct snd_pcm_hardware *hardware)
 {
@@ -300,6 +367,13 @@ static void wm8776_adc_hardware_filter(unsigned int channel,
 	}
 }
 
+static void xonar_hdav_slim_hardware_filter(unsigned int channel,
+					    struct snd_pcm_hardware *hardware)
+{
+	wm8776_adc_hardware_filter(channel, hardware);
+	xonar_hdmi_pcm_hardware_filter(channel, hardware);
+}
+
 static void set_wm87x6_dac_params(struct oxygen *chip,
 				  struct snd_pcm_hw_params *params)
 {
@@ -316,6 +390,14 @@ static void set_wm8776_adc_params(struct oxygen *chip,
 	wm8776_write_cached(chip, WM8776_MSTRCTRL, reg);
 }
 
+static void set_hdav_slim_dac_params(struct oxygen *chip,
+				     struct snd_pcm_hw_params *params)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	xonar_set_hdmi_params(chip, &data->hdmi, params);
+}
+
 static void update_wm8776_volume(struct oxygen *chip)
 {
 	struct xonar_wm87x6 *data = chip->model_data;
@@ -1007,6 +1089,53 @@ static const struct snd_kcontrol_new ds_controls[] = {
 		.private_value = 0,
 	},
 };
+static const struct snd_kcontrol_new hdav_slim_controls[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "HDMI Playback Switch",
+		.info = snd_ctl_boolean_mono_info,
+		.get = xonar_gpio_bit_switch_get,
+		.put = xonar_gpio_bit_switch_put,
+		.private_value = GPIO_SLIM_HDMI_DISABLE | XONAR_GPIO_BIT_INVERT,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Headphone Playback Volume",
+		.info = wm8776_hp_vol_info,
+		.get = wm8776_hp_vol_get,
+		.put = wm8776_hp_vol_put,
+		.tlv = { .p = wm8776_hp_db_scale },
+	},
+	WM8776_BIT_SWITCH("Headphone Playback Switch",
+			  WM8776_PWRDOWN, WM8776_HPPD, 1, 0),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Input Capture Volume",
+		.info = wm8776_input_vol_info,
+		.get = wm8776_input_vol_get,
+		.put = wm8776_input_vol_put,
+		.tlv = { .p = wm8776_adc_db_scale },
+	},
+	WM8776_BIT_SWITCH("Mic Capture Switch",
+			  WM8776_ADCMUX, 1 << 0, 0, 0),
+	WM8776_BIT_SWITCH("Aux Capture Switch",
+			  WM8776_ADCMUX, 1 << 1, 0, 0),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "ADC Filter Capture Enum",
+		.info = hpf_info,
+		.get = hpf_get,
+		.put = hpf_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Level Control Capture Enum",
+		.info = wm8776_level_control_info,
+		.get = wm8776_level_control_get,
+		.put = wm8776_level_control_put,
+		.private_value = 0,
+	},
+};
 static const struct snd_kcontrol_new lc_controls[] = {
 	WM8776_FIELD_CTL_VOLUME("Limiter Threshold",
 				WM8776_ALCCTRL1, 0, 11, 0, 15, 0xf,
@@ -1050,6 +1179,26 @@ static const struct snd_kcontrol_new lc_controls[] = {
 				LC_CONTROL_ALC, wm8776_ngth_db_scale),
 };
 
+static int add_lc_controls(struct oxygen *chip)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+	unsigned int i;
+	struct snd_kcontrol *ctl;
+	int err;
+
+	BUILD_BUG_ON(ARRAY_SIZE(lc_controls) != ARRAY_SIZE(data->lc_controls));
+	for (i = 0; i < ARRAY_SIZE(lc_controls); ++i) {
+		ctl = snd_ctl_new1(&lc_controls[i], chip);
+		if (!ctl)
+			return -ENOMEM;
+		err = snd_ctl_add(chip->card, ctl);
+		if (err < 0)
+			return err;
+		data->lc_controls[i] = ctl;
+	}
+	return 0;
+}
+
 static int xonar_ds_mixer_init(struct oxygen *chip)
 {
 	struct xonar_wm87x6 *data = chip->model_data;
@@ -1071,17 +1220,26 @@ static int xonar_ds_mixer_init(struct oxygen *chip)
 	}
 	if (!data->line_adcmux_control || !data->mic_adcmux_control)
 		return -ENXIO;
-	BUILD_BUG_ON(ARRAY_SIZE(lc_controls) != ARRAY_SIZE(data->lc_controls));
-	for (i = 0; i < ARRAY_SIZE(lc_controls); ++i) {
-		ctl = snd_ctl_new1(&lc_controls[i], chip);
+
+	return add_lc_controls(chip);
+}
+
+static int xonar_hdav_slim_mixer_init(struct oxygen *chip)
+{
+	unsigned int i;
+	struct snd_kcontrol *ctl;
+	int err;
+
+	for (i = 0; i < ARRAY_SIZE(hdav_slim_controls); ++i) {
+		ctl = snd_ctl_new1(&hdav_slim_controls[i], chip);
 		if (!ctl)
 			return -ENOMEM;
 		err = snd_ctl_add(chip->card, ctl);
 		if (err < 0)
 			return err;
-		data->lc_controls[i] = ctl;
 	}
-	return 0;
+
+	return add_lc_controls(chip);
 }
 
 static void dump_wm8776_registers(struct oxygen *chip,
@@ -1145,6 +1303,38 @@ static const struct oxygen_model model_xonar_ds = {
 	.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,
 };
 
+static const struct oxygen_model model_xonar_hdav_slim = {
+	.shortname = "Xonar HDAV1.3 Slim",
+	.longname = "Asus Virtuoso 200",
+	.chip = "AV200",
+	.init = xonar_hdav_slim_init,
+	.mixer_init = xonar_hdav_slim_mixer_init,
+	.cleanup = xonar_hdav_slim_cleanup,
+	.suspend = xonar_hdav_slim_suspend,
+	.resume = xonar_hdav_slim_resume,
+	.pcm_hardware_filter = xonar_hdav_slim_hardware_filter,
+	.set_dac_params = set_hdav_slim_dac_params,
+	.set_adc_params = set_wm8776_adc_params,
+	.update_dac_volume = update_wm8776_volume,
+	.update_dac_mute = update_wm8776_mute,
+	.uart_input = xonar_hdmi_uart_input,
+	.dump_registers = dump_wm8776_registers,
+	.dac_tlv = wm87x6_dac_db_scale,
+	.model_data_size = sizeof(struct xonar_wm87x6),
+	.device_config = PLAYBACK_0_TO_I2S |
+			 PLAYBACK_1_TO_SPDIF |
+			 CAPTURE_0_FROM_I2S_1,
+	.dac_channels_pcm = 8,
+	.dac_channels_mixer = 2,
+	.dac_volume_min = 255 - 2*60,
+	.dac_volume_max = 255,
+	.function_flags = OXYGEN_FUNCTION_2WIRE,
+	.dac_mclks = OXYGEN_MCLKS(256, 256, 128),
+	.adc_mclks = OXYGEN_MCLKS(256, 256, 128),
+	.dac_i2s_format = OXYGEN_I2S_FORMAT_LJUST,
+	.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,
+};
+
 int __devinit get_xonar_wm87x6_model(struct oxygen *chip,
 				     const struct pci_device_id *id)
 {
@@ -1152,6 +1342,9 @@ int __devinit get_xonar_wm87x6_model(struct oxygen *chip,
 	case 0x838e:
 		chip->model = model_xonar_ds;
 		break;
+	case 0x835e:
+		chip->model = model_xonar_hdav_slim;
+		break;
 	default:
 		return -EINVAL;
 	}

commit 5b8bf2a54fb13e40519ee846ce27bc8a2d7a7878
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jan 10 16:14:52 2011 +0100

    ALSA: oxygen: simplify model-specific MCLK handling
    
    Replace the get_i2s_mclk callback with tables of MCLK values.  This
    simplifies the MCLK-handling code in both the framework and the model-
    specific drivers.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index da92cc24eed2..4f9657084603 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -1122,7 +1122,6 @@ static const struct oxygen_model model_xonar_ds = {
 	.suspend = xonar_ds_suspend,
 	.resume = xonar_ds_resume,
 	.pcm_hardware_filter = wm8776_adc_hardware_filter,
-	.get_i2s_mclk = oxygen_default_i2s_mclk,
 	.set_dac_params = set_wm87x6_dac_params,
 	.set_adc_params = set_wm8776_adc_params,
 	.update_dac_volume = update_wm87x6_volume,
@@ -1140,6 +1139,8 @@ static const struct oxygen_model model_xonar_ds = {
 	.dac_volume_min = 255 - 2*60,
 	.dac_volume_max = 255,
 	.function_flags = OXYGEN_FUNCTION_SPI,
+	.dac_mclks = OXYGEN_MCLKS(256, 256, 128),
+	.adc_mclks = OXYGEN_MCLKS(256, 256, 128),
 	.dac_i2s_format = OXYGEN_I2S_FORMAT_LJUST,
 	.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,
 };

commit 1f4d7be7293aecd5f8469a46f606f62f0f05d84c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jan 10 15:59:38 2011 +0100

    ALSA: oxygen: allow different number of PCM and mixer channels
    
    For cards like the Xonar HDAV1.3, differentiate between the number of
    PCM channels that can be played and the number of channels whose volume
    can be adjusted.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index 1705d1e93115..da92cc24eed2 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -1135,7 +1135,8 @@ static const struct oxygen_model model_xonar_ds = {
 	.device_config = PLAYBACK_0_TO_I2S |
 			 PLAYBACK_1_TO_SPDIF |
 			 CAPTURE_0_FROM_I2S_1,
-	.dac_channels = 8,
+	.dac_channels_pcm = 8,
+	.dac_channels_mixer = 8,
 	.dac_volume_min = 255 - 2*60,
 	.dac_volume_max = 255,
 	.function_flags = OXYGEN_FUNCTION_SPI,

commit de664936930dae5469170f7eed24bcff7e91ef82
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Dec 2 11:42:48 2010 +0100

    ALSA: oxygen: update hardware comments
    
    Reformat and update the comments that describe the hardware connections
    on the various models.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index 2b5e69b64708..1705d1e93115 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -22,20 +22,41 @@
  *
  * CMI8788:
  *
- * SPI 0 -> WM8766 (surround, center/LFE, back)
- * SPI 1 -> WM8776 (front, input)
+ *   SPI 0 -> WM8766 (surround, center/LFE, back)
+ *   SPI 1 -> WM8776 (front, input)
  *
- * GPIO 4 <- headphone detect, 0 = plugged
- * GPIO 6 -> route input jack to mic-in (0) or line-in (1)
- * GPIO 7 -> enable output to front L/R speaker channels
- * GPIO 8 -> enable output to other speaker channels and front panel headphone
+ *   GPIO 4 <- headphone detect, 0 = plugged
+ *   GPIO 6 -> route input jack to mic-in (0) or line-in (1)
+ *   GPIO 7 -> enable output to front L/R speaker channels
+ *   GPIO 8 -> enable output to other speaker channels and front panel headphone
  *
- * WM8766:
+ * WM8776:
  *
- * input 1 <- line
- * input 2 <- mic
- * input 3 <- front mic
- * input 4 <- aux
+ *   input 1 <- line
+ *   input 2 <- mic
+ *   input 3 <- front mic
+ *   input 4 <- aux
+ */
+
+/*
+ * Xonar HDAV1.3 Slim
+ * ------------------
+ *
+ * CMI8788:
+ *
+ *   I²C <-> WM8776 (addr 0011010)
+ *
+ *   GPIO 0  -> disable HDMI output
+ *   GPIO 1  -> enable HP output
+ *   GPIO 6  -> firmware EEPROM I²C clock
+ *   GPIO 7 <-> firmware EEPROM I²C data
+ *
+ *   UART <-> HDMI controller
+ *
+ * WM8776:
+ *
+ *   input 1 <- mic
+ *   input 2 <- aux
  */
 
 #include <linux/pci.h>

commit 9719fcaa6a82be59a2d7767725e5cd8233c6a387
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Dec 2 11:41:10 2010 +0100

    ALSA: oxygen: allow to dump codec registers
    
    To help with debugging, add the registers of the model-specific
    codecs to the controller and AC97 register dump in the proc file.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index 200f7601276f..2b5e69b64708 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -42,6 +42,7 @@
 #include <linux/delay.h>
 #include <sound/control.h>
 #include <sound/core.h>
+#include <sound/info.h>
 #include <sound/jack.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -1062,6 +1063,34 @@ static int xonar_ds_mixer_init(struct oxygen *chip)
 	return 0;
 }
 
+static void dump_wm8776_registers(struct oxygen *chip,
+				  struct snd_info_buffer *buffer)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+	unsigned int i;
+
+	snd_iprintf(buffer, "\nWM8776:\n00:");
+	for (i = 0; i < 0x10; ++i)
+		snd_iprintf(buffer, " %03x", data->wm8776_regs[i]);
+	snd_iprintf(buffer, "\n10:");
+	for (i = 0x10; i < 0x17; ++i)
+		snd_iprintf(buffer, " %03x", data->wm8776_regs[i]);
+	snd_iprintf(buffer, "\n");
+}
+
+static void dump_wm87x6_registers(struct oxygen *chip,
+				  struct snd_info_buffer *buffer)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+	unsigned int i;
+
+	dump_wm8776_registers(chip, buffer);
+	snd_iprintf(buffer, "\nWM8766:\n00:");
+	for (i = 0; i < 0x10; ++i)
+		snd_iprintf(buffer, " %03x", data->wm8766_regs[i]);
+	snd_iprintf(buffer, "\n");
+}
+
 static const struct oxygen_model model_xonar_ds = {
 	.shortname = "Xonar DS",
 	.longname = "Asus Virtuoso 66",
@@ -1079,6 +1108,7 @@ static const struct oxygen_model model_xonar_ds = {
 	.update_dac_mute = update_wm87x6_mute,
 	.update_center_lfe_mix = update_wm8766_center_lfe_mix,
 	.gpio_changed = xonar_ds_gpio_changed,
+	.dump_registers = dump_wm87x6_registers,
 	.dac_tlv = wm87x6_dac_db_scale,
 	.model_data_size = sizeof(struct xonar_wm87x6),
 	.device_config = PLAYBACK_0_TO_I2S |

commit b6ca8ab399d913eed0d89d65d6b768337a3d20d7
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Oct 4 13:21:52 2010 +0200

    ALSA: oxygen: handle CD input configuration with a flag
    
    There are more models without a CD input than with one, so handle this
    explicitly with a device_config flag to avoid having to define a control
    filter callback to filter it out.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index 5f9f59c10198..200f7601276f 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -1028,13 +1028,6 @@ static const struct snd_kcontrol_new lc_controls[] = {
 				LC_CONTROL_ALC, wm8776_ngth_db_scale),
 };
 
-static int xonar_ds_control_filter(struct snd_kcontrol_new *template)
-{
-	if (!strncmp(template->name, "CD Capture ", 11))
-		return 1; /* no CD input */
-	return 0;
-}
-
 static int xonar_ds_mixer_init(struct oxygen *chip)
 {
 	struct xonar_wm87x6 *data = chip->model_data;
@@ -1074,7 +1067,6 @@ static const struct oxygen_model model_xonar_ds = {
 	.longname = "Asus Virtuoso 66",
 	.chip = "AV200",
 	.init = xonar_ds_init,
-	.control_filter = xonar_ds_control_filter,
 	.mixer_init = xonar_ds_mixer_init,
 	.cleanup = xonar_ds_cleanup,
 	.suspend = xonar_ds_suspend,

commit 45bc307f328c044e69cad2a18a9ae972bb15f254
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Oct 4 13:17:26 2010 +0200

    ALSA: virtuoso: fix Xonar DS chip name
    
    The controller on the Xonar DS is labeled "AV66", not "AV200".
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index aceaaa036da6..5f9f59c10198 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -1071,7 +1071,7 @@ static int xonar_ds_mixer_init(struct oxygen *chip)
 
 static const struct oxygen_model model_xonar_ds = {
 	.shortname = "Xonar DS",
-	.longname = "Asus Virtuoso 200",
+	.longname = "Asus Virtuoso 66",
 	.chip = "AV200",
 	.init = xonar_ds_init,
 	.control_filter = xonar_ds_control_filter,

commit 2dbf0ea29c1e4dff4ee5f0c59b367168fa2e5a40
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Sep 9 12:24:35 2010 +0200

    ALSA: virtuoso: Xonar DS: add stereo upmixing to center/LFE channels
    
    Add the possibility to route a mix of the two channels of stereo data to
    the center and LFE outputs.  Due to a WM8766 restriction, all surround
    and back channels also get the mixed L/R signal in this case.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index cee07fe3aa36..aceaaa036da6 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -377,6 +377,24 @@ static void update_wm87x6_mute(struct oxygen *chip)
 			    (chip->dac_mute ? WM8766_DMUTE_MASK : 0));
 }
 
+static void update_wm8766_center_lfe_mix(struct oxygen *chip, bool mixed)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+	unsigned int reg;
+
+	/*
+	 * The WM8766 can mix left and right channels, but this setting
+	 * applies to all three stereo pairs.
+	 */
+	reg = data->wm8766_regs[WM8766_DAC_CTRL] &
+		~(WM8766_PL_LEFT_MASK | WM8766_PL_RIGHT_MASK);
+	if (mixed)
+		reg |= WM8766_PL_LEFT_LRMIX | WM8766_PL_RIGHT_LRMIX;
+	else
+		reg |= WM8766_PL_LEFT_LEFT | WM8766_PL_RIGHT_RIGHT;
+	wm8766_write_cached(chip, WM8766_DAC_CTRL, reg);
+}
+
 static void xonar_ds_gpio_changed(struct oxygen *chip)
 {
 	xonar_ds_handle_hp_jack(chip);
@@ -1067,6 +1085,7 @@ static const struct oxygen_model model_xonar_ds = {
 	.set_adc_params = set_wm8776_adc_params,
 	.update_dac_volume = update_wm87x6_volume,
 	.update_dac_mute = update_wm87x6_mute,
+	.update_center_lfe_mix = update_wm8766_center_lfe_mix,
 	.gpio_changed = xonar_ds_gpio_changed,
 	.dac_tlv = wm87x6_dac_db_scale,
 	.model_data_size = sizeof(struct xonar_wm87x6),

commit 84cf83a28d4a3cd1fac1384cbaa4ed0ba650d309
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Sep 9 12:23:06 2010 +0200

    ALSA: virtuoso: automatically handle Xonar DS headphone routing
    
    Automatically mute the speaker outputs as long as a headphone is plugged.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index 9d57b5eee3f5..cee07fe3aa36 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -27,8 +27,8 @@
  *
  * GPIO 4 <- headphone detect, 0 = plugged
  * GPIO 6 -> route input jack to mic-in (0) or line-in (1)
- * GPIO 7 -> enable output to speakers
- * GPIO 8 -> enable output to speakers
+ * GPIO 7 -> enable output to front L/R speaker channels
+ * GPIO 8 -> enable output to other speaker channels and front panel headphone
  *
  * WM8766:
  *
@@ -52,7 +52,8 @@
 
 #define GPIO_DS_HP_DETECT	0x0010
 #define GPIO_DS_INPUT_ROUTE	0x0040
-#define GPIO_DS_OUTPUT_ENABLE	0x0180
+#define GPIO_DS_OUTPUT_FRONTLR	0x0080
+#define GPIO_DS_OUTPUT_ENABLE	0x0100
 
 #define LC_CONTROL_LIMITER	0x40000000
 #define LC_CONTROL_ALC		0x20000000
@@ -150,7 +151,10 @@ static void wm8776_registers_init(struct oxygen *chip)
 
 static void wm8766_registers_init(struct oxygen *chip)
 {
+	struct xonar_wm87x6 *data = chip->model_data;
+
 	wm8766_write(chip, WM8766_RESET, 0);
+	wm8766_write(chip, WM8766_DAC_CTRL, data->wm8766_regs[WM8766_DAC_CTRL]);
 	wm8766_write(chip, WM8766_INT_CTRL, WM8766_FMT_LJUST | WM8766_IWL_24);
 	wm8766_write(chip, WM8766_DAC_CTRL2,
 		     WM8766_ZCD | (chip->dac_mute ? WM8766_DMUTE_MASK : 0));
@@ -179,14 +183,38 @@ static void wm8776_init(struct oxygen *chip)
 	wm8776_registers_init(chip);
 }
 
-static void xonar_ds_report_hp_jack(struct oxygen *chip)
+static void wm8766_init(struct oxygen *chip)
 {
 	struct xonar_wm87x6 *data = chip->model_data;
-	u16 bits;
 
-	bits = oxygen_read16(chip, OXYGEN_GPIO_DATA);
-	snd_jack_report(data->hp_jack,
-			bits & GPIO_DS_HP_DETECT ? 0 : SND_JACK_HEADPHONE);
+	data->wm8766_regs[WM8766_DAC_CTRL] =
+		WM8766_PL_LEFT_LEFT | WM8766_PL_RIGHT_RIGHT;
+	wm8766_registers_init(chip);
+}
+
+static void xonar_ds_handle_hp_jack(struct oxygen *chip)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+	bool hp_plugged;
+	unsigned int reg;
+
+	mutex_lock(&chip->mutex);
+
+	hp_plugged = !(oxygen_read16(chip, OXYGEN_GPIO_DATA) &
+		       GPIO_DS_HP_DETECT);
+
+	oxygen_write16_masked(chip, OXYGEN_GPIO_DATA,
+			      hp_plugged ? 0 : GPIO_DS_OUTPUT_FRONTLR,
+			      GPIO_DS_OUTPUT_FRONTLR);
+
+	reg = data->wm8766_regs[WM8766_DAC_CTRL] & ~WM8766_MUTEALL;
+	if (hp_plugged)
+		reg |= WM8766_MUTEALL;
+	wm8766_write_cached(chip, WM8766_DAC_CTRL, reg);
+
+	snd_jack_report(data->hp_jack, hp_plugged ? SND_JACK_HEADPHONE : 0);
+
+	mutex_unlock(&chip->mutex);
 }
 
 static void xonar_ds_init(struct oxygen *chip)
@@ -197,10 +225,12 @@ static void xonar_ds_init(struct oxygen *chip)
 	data->generic.output_enable_bit = GPIO_DS_OUTPUT_ENABLE;
 
 	wm8776_init(chip);
-	wm8766_registers_init(chip);
+	wm8766_init(chip);
 
-	oxygen_write16_masked(chip, OXYGEN_GPIO_CONTROL, GPIO_DS_INPUT_ROUTE,
-			      GPIO_DS_HP_DETECT | GPIO_DS_INPUT_ROUTE);
+	oxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,
+			  GPIO_DS_INPUT_ROUTE | GPIO_DS_OUTPUT_FRONTLR);
+	oxygen_clear_bits16(chip, OXYGEN_GPIO_CONTROL,
+			    GPIO_DS_HP_DETECT);
 	oxygen_set_bits16(chip, OXYGEN_GPIO_DATA, GPIO_DS_INPUT_ROUTE);
 	oxygen_set_bits16(chip, OXYGEN_GPIO_INTERRUPT_MASK, GPIO_DS_HP_DETECT);
 	chip->interrupt_mask |= OXYGEN_INT_GPIO;
@@ -209,7 +239,7 @@ static void xonar_ds_init(struct oxygen *chip)
 
 	snd_jack_new(chip->card, "Headphone",
 		     SND_JACK_HEADPHONE, &data->hp_jack);
-	xonar_ds_report_hp_jack(chip);
+	xonar_ds_handle_hp_jack(chip);
 
 	snd_component_add(chip->card, "WM8776");
 	snd_component_add(chip->card, "WM8766");
@@ -231,6 +261,7 @@ static void xonar_ds_resume(struct oxygen *chip)
 	wm8776_registers_init(chip);
 	wm8766_registers_init(chip);
 	xonar_enable_output(chip);
+	xonar_ds_handle_hp_jack(chip);
 }
 
 static void wm8776_adc_hardware_filter(unsigned int channel,
@@ -348,7 +379,7 @@ static void update_wm87x6_mute(struct oxygen *chip)
 
 static void xonar_ds_gpio_changed(struct oxygen *chip)
 {
-	xonar_ds_report_hp_jack(chip);
+	xonar_ds_handle_hp_jack(chip);
 }
 
 static int wm8776_bit_switch_get(struct snd_kcontrol *ctl,

commit 435feac648cab190990aa0bf9355f77d1f082db3
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Sep 9 12:20:29 2010 +0200

    ALSA: virtuoso: add Xonar DS headphone jack detection
    
    Now that the polarity of the headphone detection pin is known, replace
    the debugging message with a proper jack plug input device.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index fb3f95ccafa1..9d57b5eee3f5 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -25,8 +25,8 @@
  * SPI 0 -> WM8766 (surround, center/LFE, back)
  * SPI 1 -> WM8776 (front, input)
  *
- * GPIO 4 <- headphone detect
- * GPIO 6 -> route input jack to input 1/2 (1/0)
+ * GPIO 4 <- headphone detect, 0 = plugged
+ * GPIO 6 -> route input jack to mic-in (0) or line-in (1)
  * GPIO 7 -> enable output to speakers
  * GPIO 8 -> enable output to speakers
  *
@@ -42,6 +42,7 @@
 #include <linux/delay.h>
 #include <sound/control.h>
 #include <sound/core.h>
+#include <sound/jack.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/tlv.h>
@@ -63,6 +64,7 @@ struct xonar_wm87x6 {
 	struct snd_kcontrol *line_adcmux_control;
 	struct snd_kcontrol *mic_adcmux_control;
 	struct snd_kcontrol *lc_controls[13];
+	struct snd_jack *hp_jack;
 };
 
 static void wm8776_write(struct oxygen *chip,
@@ -177,6 +179,16 @@ static void wm8776_init(struct oxygen *chip)
 	wm8776_registers_init(chip);
 }
 
+static void xonar_ds_report_hp_jack(struct oxygen *chip)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+	u16 bits;
+
+	bits = oxygen_read16(chip, OXYGEN_GPIO_DATA);
+	snd_jack_report(data->hp_jack,
+			bits & GPIO_DS_HP_DETECT ? 0 : SND_JACK_HEADPHONE);
+}
+
 static void xonar_ds_init(struct oxygen *chip)
 {
 	struct xonar_wm87x6 *data = chip->model_data;
@@ -195,6 +207,10 @@ static void xonar_ds_init(struct oxygen *chip)
 
 	xonar_enable_output(chip);
 
+	snd_jack_new(chip->card, "Headphone",
+		     SND_JACK_HEADPHONE, &data->hp_jack);
+	xonar_ds_report_hp_jack(chip);
+
 	snd_component_add(chip->card, "WM8776");
 	snd_component_add(chip->card, "WM8766");
 }
@@ -332,10 +348,7 @@ static void update_wm87x6_mute(struct oxygen *chip)
 
 static void xonar_ds_gpio_changed(struct oxygen *chip)
 {
-	u16 bits;
-
-	bits = oxygen_read16(chip, OXYGEN_GPIO_DATA);
-	snd_printk(KERN_INFO "HP detect: %d\n", !!(bits & GPIO_DS_HP_DETECT));
+	xonar_ds_report_hp_jack(chip);
 }
 
 static int wm8776_bit_switch_get(struct snd_kcontrol *ctl,

commit 9bac84edf0360ac94a27308778ef98dc9068777c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Sep 9 12:19:21 2010 +0200

    ALSA: virtuoso: fix Xonar DS input switches
    
    Use the correct number, register bits, and names for the input switches.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index 4346006df3ec..fb3f95ccafa1 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -29,6 +29,13 @@
  * GPIO 6 -> route input jack to input 1/2 (1/0)
  * GPIO 7 -> enable output to speakers
  * GPIO 8 -> enable output to speakers
+ *
+ * WM8766:
+ *
+ * input 1 <- line
+ * input 2 <- mic
+ * input 3 <- front mic
+ * input 4 <- aux
  */
 
 #include <linux/pci.h>
@@ -896,7 +903,10 @@ static const struct snd_kcontrol_new ds_controls[] = {
 		.put = wm8776_input_mux_put,
 		.private_value = 1 << 1,
 	},
-	WM8776_BIT_SWITCH("Aux", WM8776_ADCMUX, 1 << 2, 0, 0),
+	WM8776_BIT_SWITCH("Front Mic Capture Switch",
+			  WM8776_ADCMUX, 1 << 2, 0, 0),
+	WM8776_BIT_SWITCH("Aux Capture Switch",
+			  WM8776_ADCMUX, 1 << 3, 0, 0),
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "ADC Filter Capture Enum",

commit da0dab5ecb5001f76e739e71ee199db4c61e7af2
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Sep 9 12:18:35 2010 +0200

    ALSA: virtuoso: fix WM8766 register writes with MSB
    
    The check for the volume update latch bit was accidentally in the wrong
    function, where it would prevent the MSB from being written, instead of
    correctly ignoring it for cached values.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index b82c1cfa96f5..4346006df3ec 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -97,8 +97,12 @@ static void wm8766_write(struct oxygen *chip,
 			 (0 << OXYGEN_SPI_CODEC_SHIFT) |
 			 OXYGEN_SPI_CEN_LATCH_CLOCK_LO,
 			 (reg << 9) | value);
-	if (reg < ARRAY_SIZE(data->wm8766_regs))
+	if (reg < ARRAY_SIZE(data->wm8766_regs)) {
+		if ((reg >= WM8766_LDA1 && reg <= WM8766_RDA1) ||
+		    (reg >= WM8766_LDA2 && reg <= WM8766_MASTDA))
+			value &= ~WM8766_UPDATE;
 		data->wm8766_regs[reg] = value;
+	}
 }
 
 static void wm8766_write_cached(struct oxygen *chip,
@@ -107,12 +111,8 @@ static void wm8766_write_cached(struct oxygen *chip,
 	struct xonar_wm87x6 *data = chip->model_data;
 
 	if (reg >= ARRAY_SIZE(data->wm8766_regs) ||
-	    value != data->wm8766_regs[reg]) {
-		if ((reg >= WM8766_LDA1 && reg <= WM8766_RDA1) ||
-		    (reg >= WM8766_LDA2 && reg <= WM8766_MASTDA))
-			value &= ~WM8766_UPDATE;
+	    value != data->wm8766_regs[reg])
 		wm8766_write(chip, reg, value);
-	}
 }
 
 static void wm8776_registers_init(struct oxygen *chip)

commit fe6ce80ae25953d95ebaf9bce27b585218cda25c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Sep 7 13:38:49 2010 +0200

    ALSA: virtuoso: fix setting of Xonar DS line-in/mic-in controls
    
    The Line and Mic inputs cannot be used at the same time, so the driver
    has to automatically disable one of them if both are set.  However, it
    forgot to notify userspace about this change, so the mixer state would
    be inconsistent.  To fix this, check if the other control gets muted,
    and send a notification event in this case.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Reported-and-tested-by: Nathan Schagen
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index 0b89932fb8c4..b82c1cfa96f5 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -53,6 +53,8 @@ struct xonar_wm87x6 {
 	struct xonar_generic generic;
 	u16 wm8776_regs[0x17];
 	u16 wm8766_regs[0x10];
+	struct snd_kcontrol *line_adcmux_control;
+	struct snd_kcontrol *mic_adcmux_control;
 	struct snd_kcontrol *lc_controls[13];
 };
 
@@ -604,6 +606,7 @@ static int wm8776_input_mux_put(struct snd_kcontrol *ctl,
 {
 	struct oxygen *chip = ctl->private_data;
 	struct xonar_wm87x6 *data = chip->model_data;
+	struct snd_kcontrol *other_ctl;
 	unsigned int mux_bit = ctl->private_value;
 	u16 reg;
 	int changed;
@@ -611,8 +614,18 @@ static int wm8776_input_mux_put(struct snd_kcontrol *ctl,
 	mutex_lock(&chip->mutex);
 	reg = data->wm8776_regs[WM8776_ADCMUX];
 	if (value->value.integer.value[0]) {
-		reg &= ~0x003;
 		reg |= mux_bit;
+		/* line-in and mic-in are exclusive */
+		mux_bit ^= 3;
+		if (reg & mux_bit) {
+			reg &= ~mux_bit;
+			if (mux_bit == 1)
+				other_ctl = data->line_adcmux_control;
+			else
+				other_ctl = data->mic_adcmux_control;
+			snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,
+				       &other_ctl->id);
+		}
 	} else
 		reg &= ~mux_bit;
 	changed = reg != data->wm8776_regs[WM8776_ADCMUX];
@@ -964,7 +977,13 @@ static int xonar_ds_mixer_init(struct oxygen *chip)
 		err = snd_ctl_add(chip->card, ctl);
 		if (err < 0)
 			return err;
+		if (!strcmp(ctl->id.name, "Line Capture Switch"))
+			data->line_adcmux_control = ctl;
+		else if (!strcmp(ctl->id.name, "Mic Capture Switch"))
+			data->mic_adcmux_control = ctl;
 	}
+	if (!data->line_adcmux_control || !data->mic_adcmux_control)
+		return -ENXIO;
 	BUILD_BUG_ON(ARRAY_SIZE(lc_controls) != ARRAY_SIZE(data->lc_controls));
 	for (i = 0; i < ARRAY_SIZE(lc_controls); ++i) {
 		ctl = snd_ctl_new1(&lc_controls[i], chip);

commit 4c25b93223340deff73381cc47f9244fb379a74d
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Sep 7 13:37:10 2010 +0200

    ALSA: virtuoso: work around missing reset in the Xonar DS Windows driver
    
    For the WM8776 chip, this driver uses a different sample format and
    more features than the Windows driver.  When rebooting from Linux into
    Windows, the latter driver does not reset the chip but assumes all its
    registers have their default settings, so we get garbled sound or, if
    the output happened to be muted before rebooting, no sound.
    
    To make that driver happy, hook our driver's cleanup function into the
    shutdown notifier and ensure that the chip gets reset.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Reported-and-tested-by: Nathan Schagen
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index dbc4b89d74e4..0b89932fb8c4 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -193,6 +193,7 @@ static void xonar_ds_init(struct oxygen *chip)
 static void xonar_ds_cleanup(struct oxygen *chip)
 {
 	xonar_disable_output(chip);
+	wm8776_write(chip, WM8776_RESET, 0);
 }
 
 static void xonar_ds_suspend(struct oxygen *chip)

commit faf4eb23d5fcb9a4728766a1e7bce9c6f2b43bd8
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Mar 3 09:16:18 2010 +0100

    ALSA: oxygen: change || to &&
    
    In the original code the condition was always true (hopefully) because
    WM8776_HPLVOL is zero.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
index 7754db166d9e..dbc4b89d74e4 100644
--- a/sound/pci/oxygen/xonar_wm87x6.c
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -68,7 +68,7 @@ static void wm8776_write(struct oxygen *chip,
 			 OXYGEN_SPI_CEN_LATCH_CLOCK_LO,
 			 (reg << 9) | value);
 	if (reg < ARRAY_SIZE(data->wm8776_regs)) {
-		if (reg >= WM8776_HPLVOL || reg <= WM8776_DACMASTER)
+		if (reg >= WM8776_HPLVOL && reg <= WM8776_DACMASTER)
 			value &= ~WM8776_UPDATE;
 		data->wm8776_regs[reg] = value;
 	}

commit d1db38c015a392b0ea8c15ab95abb3ee768b8d47
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jan 18 15:44:04 2010 +0100

    sound: virtuoso: add Xonar DS support
    
    Add experimental support for the Asus Xonar DS.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/oxygen/xonar_wm87x6.c b/sound/pci/oxygen/xonar_wm87x6.c
new file mode 100644
index 000000000000..7754db166d9e
--- /dev/null
+++ b/sound/pci/oxygen/xonar_wm87x6.c
@@ -0,0 +1,1021 @@
+/*
+ * card driver for models with WM8776/WM8766 DACs (Xonar DS)
+ *
+ * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
+ *
+ *
+ *  This driver is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, version 2.
+ *
+ *  This driver is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this driver; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Xonar DS
+ * --------
+ *
+ * CMI8788:
+ *
+ * SPI 0 -> WM8766 (surround, center/LFE, back)
+ * SPI 1 -> WM8776 (front, input)
+ *
+ * GPIO 4 <- headphone detect
+ * GPIO 6 -> route input jack to input 1/2 (1/0)
+ * GPIO 7 -> enable output to speakers
+ * GPIO 8 -> enable output to speakers
+ */
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <sound/control.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/tlv.h>
+#include "xonar.h"
+#include "wm8776.h"
+#include "wm8766.h"
+
+#define GPIO_DS_HP_DETECT	0x0010
+#define GPIO_DS_INPUT_ROUTE	0x0040
+#define GPIO_DS_OUTPUT_ENABLE	0x0180
+
+#define LC_CONTROL_LIMITER	0x40000000
+#define LC_CONTROL_ALC		0x20000000
+
+struct xonar_wm87x6 {
+	struct xonar_generic generic;
+	u16 wm8776_regs[0x17];
+	u16 wm8766_regs[0x10];
+	struct snd_kcontrol *lc_controls[13];
+};
+
+static void wm8776_write(struct oxygen *chip,
+			 unsigned int reg, unsigned int value)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	oxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |
+			 OXYGEN_SPI_DATA_LENGTH_2 |
+			 OXYGEN_SPI_CLOCK_160 |
+			 (1 << OXYGEN_SPI_CODEC_SHIFT) |
+			 OXYGEN_SPI_CEN_LATCH_CLOCK_LO,
+			 (reg << 9) | value);
+	if (reg < ARRAY_SIZE(data->wm8776_regs)) {
+		if (reg >= WM8776_HPLVOL || reg <= WM8776_DACMASTER)
+			value &= ~WM8776_UPDATE;
+		data->wm8776_regs[reg] = value;
+	}
+}
+
+static void wm8776_write_cached(struct oxygen *chip,
+				unsigned int reg, unsigned int value)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	if (reg >= ARRAY_SIZE(data->wm8776_regs) ||
+	    value != data->wm8776_regs[reg])
+		wm8776_write(chip, reg, value);
+}
+
+static void wm8766_write(struct oxygen *chip,
+			 unsigned int reg, unsigned int value)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	oxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |
+			 OXYGEN_SPI_DATA_LENGTH_2 |
+			 OXYGEN_SPI_CLOCK_160 |
+			 (0 << OXYGEN_SPI_CODEC_SHIFT) |
+			 OXYGEN_SPI_CEN_LATCH_CLOCK_LO,
+			 (reg << 9) | value);
+	if (reg < ARRAY_SIZE(data->wm8766_regs))
+		data->wm8766_regs[reg] = value;
+}
+
+static void wm8766_write_cached(struct oxygen *chip,
+				unsigned int reg, unsigned int value)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	if (reg >= ARRAY_SIZE(data->wm8766_regs) ||
+	    value != data->wm8766_regs[reg]) {
+		if ((reg >= WM8766_LDA1 && reg <= WM8766_RDA1) ||
+		    (reg >= WM8766_LDA2 && reg <= WM8766_MASTDA))
+			value &= ~WM8766_UPDATE;
+		wm8766_write(chip, reg, value);
+	}
+}
+
+static void wm8776_registers_init(struct oxygen *chip)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	wm8776_write(chip, WM8776_RESET, 0);
+	wm8776_write(chip, WM8776_DACCTRL1, WM8776_DZCEN |
+		     WM8776_PL_LEFT_LEFT | WM8776_PL_RIGHT_RIGHT);
+	wm8776_write(chip, WM8776_DACMUTE, chip->dac_mute ? WM8776_DMUTE : 0);
+	wm8776_write(chip, WM8776_DACIFCTRL,
+		     WM8776_DACFMT_LJUST | WM8776_DACWL_24);
+	wm8776_write(chip, WM8776_ADCIFCTRL,
+		     data->wm8776_regs[WM8776_ADCIFCTRL]);
+	wm8776_write(chip, WM8776_MSTRCTRL, data->wm8776_regs[WM8776_MSTRCTRL]);
+	wm8776_write(chip, WM8776_PWRDOWN, data->wm8776_regs[WM8776_PWRDOWN]);
+	wm8776_write(chip, WM8776_HPLVOL, data->wm8776_regs[WM8776_HPLVOL]);
+	wm8776_write(chip, WM8776_HPRVOL, data->wm8776_regs[WM8776_HPRVOL] |
+		     WM8776_UPDATE);
+	wm8776_write(chip, WM8776_ADCLVOL, data->wm8776_regs[WM8776_ADCLVOL]);
+	wm8776_write(chip, WM8776_ADCRVOL, data->wm8776_regs[WM8776_ADCRVOL]);
+	wm8776_write(chip, WM8776_ADCMUX, data->wm8776_regs[WM8776_ADCMUX]);
+	wm8776_write(chip, WM8776_DACLVOL, chip->dac_volume[0]);
+	wm8776_write(chip, WM8776_DACRVOL, chip->dac_volume[1] | WM8776_UPDATE);
+}
+
+static void wm8766_registers_init(struct oxygen *chip)
+{
+	wm8766_write(chip, WM8766_RESET, 0);
+	wm8766_write(chip, WM8766_INT_CTRL, WM8766_FMT_LJUST | WM8766_IWL_24);
+	wm8766_write(chip, WM8766_DAC_CTRL2,
+		     WM8766_ZCD | (chip->dac_mute ? WM8766_DMUTE_MASK : 0));
+	wm8766_write(chip, WM8766_LDA1, chip->dac_volume[2]);
+	wm8766_write(chip, WM8766_RDA1, chip->dac_volume[3]);
+	wm8766_write(chip, WM8766_LDA2, chip->dac_volume[4]);
+	wm8766_write(chip, WM8766_RDA2, chip->dac_volume[5]);
+	wm8766_write(chip, WM8766_LDA3, chip->dac_volume[6]);
+	wm8766_write(chip, WM8766_RDA3, chip->dac_volume[7] | WM8766_UPDATE);
+}
+
+static void wm8776_init(struct oxygen *chip)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	data->wm8776_regs[WM8776_HPLVOL] = (0x79 - 60) | WM8776_HPZCEN;
+	data->wm8776_regs[WM8776_HPRVOL] = (0x79 - 60) | WM8776_HPZCEN;
+	data->wm8776_regs[WM8776_ADCIFCTRL] =
+		WM8776_ADCFMT_LJUST | WM8776_ADCWL_24 | WM8776_ADCMCLK;
+	data->wm8776_regs[WM8776_MSTRCTRL] =
+		WM8776_ADCRATE_256 | WM8776_DACRATE_256;
+	data->wm8776_regs[WM8776_PWRDOWN] = WM8776_HPPD;
+	data->wm8776_regs[WM8776_ADCLVOL] = 0xa5 | WM8776_ZCA;
+	data->wm8776_regs[WM8776_ADCRVOL] = 0xa5 | WM8776_ZCA;
+	data->wm8776_regs[WM8776_ADCMUX] = 0x001;
+	wm8776_registers_init(chip);
+}
+
+static void xonar_ds_init(struct oxygen *chip)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	data->generic.anti_pop_delay = 300;
+	data->generic.output_enable_bit = GPIO_DS_OUTPUT_ENABLE;
+
+	wm8776_init(chip);
+	wm8766_registers_init(chip);
+
+	oxygen_write16_masked(chip, OXYGEN_GPIO_CONTROL, GPIO_DS_INPUT_ROUTE,
+			      GPIO_DS_HP_DETECT | GPIO_DS_INPUT_ROUTE);
+	oxygen_set_bits16(chip, OXYGEN_GPIO_DATA, GPIO_DS_INPUT_ROUTE);
+	oxygen_set_bits16(chip, OXYGEN_GPIO_INTERRUPT_MASK, GPIO_DS_HP_DETECT);
+	chip->interrupt_mask |= OXYGEN_INT_GPIO;
+
+	xonar_enable_output(chip);
+
+	snd_component_add(chip->card, "WM8776");
+	snd_component_add(chip->card, "WM8766");
+}
+
+static void xonar_ds_cleanup(struct oxygen *chip)
+{
+	xonar_disable_output(chip);
+}
+
+static void xonar_ds_suspend(struct oxygen *chip)
+{
+	xonar_ds_cleanup(chip);
+}
+
+static void xonar_ds_resume(struct oxygen *chip)
+{
+	wm8776_registers_init(chip);
+	wm8766_registers_init(chip);
+	xonar_enable_output(chip);
+}
+
+static void wm8776_adc_hardware_filter(unsigned int channel,
+				       struct snd_pcm_hardware *hardware)
+{
+	if (channel == PCM_A) {
+		hardware->rates = SNDRV_PCM_RATE_32000 |
+				  SNDRV_PCM_RATE_44100 |
+				  SNDRV_PCM_RATE_48000 |
+				  SNDRV_PCM_RATE_64000 |
+				  SNDRV_PCM_RATE_88200 |
+				  SNDRV_PCM_RATE_96000;
+		hardware->rate_max = 96000;
+	}
+}
+
+static void set_wm87x6_dac_params(struct oxygen *chip,
+				  struct snd_pcm_hw_params *params)
+{
+}
+
+static void set_wm8776_adc_params(struct oxygen *chip,
+				  struct snd_pcm_hw_params *params)
+{
+	u16 reg;
+
+	reg = WM8776_ADCRATE_256 | WM8776_DACRATE_256;
+	if (params_rate(params) > 48000)
+		reg |= WM8776_ADCOSR;
+	wm8776_write_cached(chip, WM8776_MSTRCTRL, reg);
+}
+
+static void update_wm8776_volume(struct oxygen *chip)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+	u8 to_change;
+
+	if (chip->dac_volume[0] == chip->dac_volume[1]) {
+		if (chip->dac_volume[0] != data->wm8776_regs[WM8776_DACLVOL] ||
+		    chip->dac_volume[1] != data->wm8776_regs[WM8776_DACRVOL]) {
+			wm8776_write(chip, WM8776_DACMASTER,
+				     chip->dac_volume[0] | WM8776_UPDATE);
+			data->wm8776_regs[WM8776_DACLVOL] = chip->dac_volume[0];
+			data->wm8776_regs[WM8776_DACRVOL] = chip->dac_volume[0];
+		}
+	} else {
+		to_change = (chip->dac_volume[0] !=
+			     data->wm8776_regs[WM8776_DACLVOL]) << 0;
+		to_change |= (chip->dac_volume[1] !=
+			      data->wm8776_regs[WM8776_DACLVOL]) << 1;
+		if (to_change & 1)
+			wm8776_write(chip, WM8776_DACLVOL, chip->dac_volume[0] |
+				     ((to_change & 2) ? 0 : WM8776_UPDATE));
+		if (to_change & 2)
+			wm8776_write(chip, WM8776_DACRVOL,
+				     chip->dac_volume[1] | WM8776_UPDATE);
+	}
+}
+
+static void update_wm87x6_volume(struct oxygen *chip)
+{
+	static const u8 wm8766_regs[6] = {
+		WM8766_LDA1, WM8766_RDA1,
+		WM8766_LDA2, WM8766_RDA2,
+		WM8766_LDA3, WM8766_RDA3,
+	};
+	struct xonar_wm87x6 *data = chip->model_data;
+	unsigned int i;
+	u8 to_change;
+
+	update_wm8776_volume(chip);
+	if (chip->dac_volume[2] == chip->dac_volume[3] &&
+	    chip->dac_volume[2] == chip->dac_volume[4] &&
+	    chip->dac_volume[2] == chip->dac_volume[5] &&
+	    chip->dac_volume[2] == chip->dac_volume[6] &&
+	    chip->dac_volume[2] == chip->dac_volume[7]) {
+		to_change = 0;
+		for (i = 0; i < 6; ++i)
+			if (chip->dac_volume[2] !=
+			    data->wm8766_regs[wm8766_regs[i]])
+				to_change = 1;
+		if (to_change) {
+			wm8766_write(chip, WM8766_MASTDA,
+				     chip->dac_volume[2] | WM8766_UPDATE);
+			for (i = 0; i < 6; ++i)
+				data->wm8766_regs[wm8766_regs[i]] =
+					chip->dac_volume[2];
+		}
+	} else {
+		to_change = 0;
+		for (i = 0; i < 6; ++i)
+			to_change |= (chip->dac_volume[2 + i] !=
+				      data->wm8766_regs[wm8766_regs[i]]) << i;
+		for (i = 0; i < 6; ++i)
+			if (to_change & (1 << i))
+				wm8766_write(chip, wm8766_regs[i],
+					     chip->dac_volume[2 + i] |
+					     ((to_change & (0x3e << i))
+					      ? 0 : WM8766_UPDATE));
+	}
+}
+
+static void update_wm8776_mute(struct oxygen *chip)
+{
+	wm8776_write_cached(chip, WM8776_DACMUTE,
+			    chip->dac_mute ? WM8776_DMUTE : 0);
+}
+
+static void update_wm87x6_mute(struct oxygen *chip)
+{
+	update_wm8776_mute(chip);
+	wm8766_write_cached(chip, WM8766_DAC_CTRL2, WM8766_ZCD |
+			    (chip->dac_mute ? WM8766_DMUTE_MASK : 0));
+}
+
+static void xonar_ds_gpio_changed(struct oxygen *chip)
+{
+	u16 bits;
+
+	bits = oxygen_read16(chip, OXYGEN_GPIO_DATA);
+	snd_printk(KERN_INFO "HP detect: %d\n", !!(bits & GPIO_DS_HP_DETECT));
+}
+
+static int wm8776_bit_switch_get(struct snd_kcontrol *ctl,
+				 struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct xonar_wm87x6 *data = chip->model_data;
+	u16 bit = ctl->private_value & 0xffff;
+	unsigned int reg_index = (ctl->private_value >> 16) & 0xff;
+	bool invert = (ctl->private_value >> 24) & 1;
+
+	value->value.integer.value[0] =
+		((data->wm8776_regs[reg_index] & bit) != 0) ^ invert;
+	return 0;
+}
+
+static int wm8776_bit_switch_put(struct snd_kcontrol *ctl,
+				 struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct xonar_wm87x6 *data = chip->model_data;
+	u16 bit = ctl->private_value & 0xffff;
+	u16 reg_value;
+	unsigned int reg_index = (ctl->private_value >> 16) & 0xff;
+	bool invert = (ctl->private_value >> 24) & 1;
+	int changed;
+
+	mutex_lock(&chip->mutex);
+	reg_value = data->wm8776_regs[reg_index] & ~bit;
+	if (value->value.integer.value[0] ^ invert)
+		reg_value |= bit;
+	changed = reg_value != data->wm8776_regs[reg_index];
+	if (changed)
+		wm8776_write(chip, reg_index, reg_value);
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+static int wm8776_field_enum_info(struct snd_kcontrol *ctl,
+				  struct snd_ctl_elem_info *info)
+{
+	static const char *const hld[16] = {
+		"0 ms", "2.67 ms", "5.33 ms", "10.6 ms",
+		"21.3 ms", "42.7 ms", "85.3 ms", "171 ms",
+		"341 ms", "683 ms", "1.37 s", "2.73 s",
+		"5.46 s", "10.9 s", "21.8 s", "43.7 s",
+	};
+	static const char *const atk_lim[11] = {
+		"0.25 ms", "0.5 ms", "1 ms", "2 ms",
+		"4 ms", "8 ms", "16 ms", "32 ms",
+		"64 ms", "128 ms", "256 ms",
+	};
+	static const char *const atk_alc[11] = {
+		"8.40 ms", "16.8 ms", "33.6 ms", "67.2 ms",
+		"134 ms", "269 ms", "538 ms", "1.08 s",
+		"2.15 s", "4.3 s", "8.6 s",
+	};
+	static const char *const dcy_lim[11] = {
+		"1.2 ms", "2.4 ms", "4.8 ms", "9.6 ms",
+		"19.2 ms", "38.4 ms", "76.8 ms", "154 ms",
+		"307 ms", "614 ms", "1.23 s",
+	};
+	static const char *const dcy_alc[11] = {
+		"33.5 ms", "67.0 ms", "134 ms", "268 ms",
+		"536 ms", "1.07 s", "2.14 s", "4.29 s",
+		"8.58 s", "17.2 s", "34.3 s",
+	};
+	static const char *const tranwin[8] = {
+		"0 us", "62.5 us", "125 us", "250 us",
+		"500 us", "1 ms", "2 ms", "4 ms",
+	};
+	u8 max;
+	const char *const *names;
+
+	max = (ctl->private_value >> 12) & 0xf;
+	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	info->count = 1;
+	info->value.enumerated.items = max + 1;
+	if (info->value.enumerated.item > max)
+		info->value.enumerated.item = max;
+	switch ((ctl->private_value >> 24) & 0x1f) {
+	case WM8776_ALCCTRL2:
+		names = hld;
+		break;
+	case WM8776_ALCCTRL3:
+		if (((ctl->private_value >> 20) & 0xf) == 0) {
+			if (ctl->private_value & LC_CONTROL_LIMITER)
+				names = atk_lim;
+			else
+				names = atk_alc;
+		} else {
+			if (ctl->private_value & LC_CONTROL_LIMITER)
+				names = dcy_lim;
+			else
+				names = dcy_alc;
+		}
+		break;
+	case WM8776_LIMITER:
+		names = tranwin;
+		break;
+	default:
+		return -ENXIO;
+	}
+	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
+	return 0;
+}
+
+static int wm8776_field_volume_info(struct snd_kcontrol *ctl,
+				    struct snd_ctl_elem_info *info)
+{
+	info->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	info->count = 1;
+	info->value.integer.min = (ctl->private_value >> 8) & 0xf;
+	info->value.integer.max = (ctl->private_value >> 12) & 0xf;
+	return 0;
+}
+
+static void wm8776_field_set_from_ctl(struct snd_kcontrol *ctl)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct xonar_wm87x6 *data = chip->model_data;
+	unsigned int value, reg_index, mode;
+	u8 min, max, shift;
+	u16 mask, reg_value;
+	bool invert;
+
+	if ((data->wm8776_regs[WM8776_ALCCTRL1] & WM8776_LCSEL_MASK) ==
+	    WM8776_LCSEL_LIMITER)
+		mode = LC_CONTROL_LIMITER;
+	else
+		mode = LC_CONTROL_ALC;
+	if (!(ctl->private_value & mode))
+		return;
+
+	value = ctl->private_value & 0xf;
+	min = (ctl->private_value >> 8) & 0xf;
+	max = (ctl->private_value >> 12) & 0xf;
+	mask = (ctl->private_value >> 16) & 0xf;
+	shift = (ctl->private_value >> 20) & 0xf;
+	reg_index = (ctl->private_value >> 24) & 0x1f;
+	invert = (ctl->private_value >> 29) & 0x1;
+
+	if (invert)
+		value = max - (value - min);
+	reg_value = data->wm8776_regs[reg_index];
+	reg_value &= ~(mask << shift);
+	reg_value |= value << shift;
+	wm8776_write_cached(chip, reg_index, reg_value);
+}
+
+static int wm8776_field_set(struct snd_kcontrol *ctl, unsigned int value)
+{
+	struct oxygen *chip = ctl->private_data;
+	u8 min, max;
+	int changed;
+
+	min = (ctl->private_value >> 8) & 0xf;
+	max = (ctl->private_value >> 12) & 0xf;
+	if (value < min || value > max)
+		return -EINVAL;
+	mutex_lock(&chip->mutex);
+	changed = value != (ctl->private_value & 0xf);
+	if (changed) {
+		ctl->private_value = (ctl->private_value & ~0xf) | value;
+		wm8776_field_set_from_ctl(ctl);
+	}
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+static int wm8776_field_enum_get(struct snd_kcontrol *ctl,
+				 struct snd_ctl_elem_value *value)
+{
+	value->value.enumerated.item[0] = ctl->private_value & 0xf;
+	return 0;
+}
+
+static int wm8776_field_volume_get(struct snd_kcontrol *ctl,
+				   struct snd_ctl_elem_value *value)
+{
+	value->value.integer.value[0] = ctl->private_value & 0xf;
+	return 0;
+}
+
+static int wm8776_field_enum_put(struct snd_kcontrol *ctl,
+				 struct snd_ctl_elem_value *value)
+{
+	return wm8776_field_set(ctl, value->value.enumerated.item[0]);
+}
+
+static int wm8776_field_volume_put(struct snd_kcontrol *ctl,
+				   struct snd_ctl_elem_value *value)
+{
+	return wm8776_field_set(ctl, value->value.integer.value[0]);
+}
+
+static int wm8776_hp_vol_info(struct snd_kcontrol *ctl,
+			      struct snd_ctl_elem_info *info)
+{
+	info->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	info->count = 2;
+	info->value.integer.min = 0x79 - 60;
+	info->value.integer.max = 0x7f;
+	return 0;
+}
+
+static int wm8776_hp_vol_get(struct snd_kcontrol *ctl,
+			     struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	mutex_lock(&chip->mutex);
+	value->value.integer.value[0] =
+		data->wm8776_regs[WM8776_HPLVOL] & WM8776_HPATT_MASK;
+	value->value.integer.value[1] =
+		data->wm8776_regs[WM8776_HPRVOL] & WM8776_HPATT_MASK;
+	mutex_unlock(&chip->mutex);
+	return 0;
+}
+
+static int wm8776_hp_vol_put(struct snd_kcontrol *ctl,
+			     struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct xonar_wm87x6 *data = chip->model_data;
+	u8 to_update;
+
+	mutex_lock(&chip->mutex);
+	to_update = (value->value.integer.value[0] !=
+		     (data->wm8776_regs[WM8776_HPLVOL] & WM8776_HPATT_MASK))
+		<< 0;
+	to_update |= (value->value.integer.value[1] !=
+		      (data->wm8776_regs[WM8776_HPRVOL] & WM8776_HPATT_MASK))
+		<< 1;
+	if (value->value.integer.value[0] == value->value.integer.value[1]) {
+		if (to_update) {
+			wm8776_write(chip, WM8776_HPMASTER,
+				     value->value.integer.value[0] |
+				     WM8776_HPZCEN | WM8776_UPDATE);
+			data->wm8776_regs[WM8776_HPLVOL] =
+				value->value.integer.value[0] | WM8776_HPZCEN;
+			data->wm8776_regs[WM8776_HPRVOL] =
+				value->value.integer.value[0] | WM8776_HPZCEN;
+		}
+	} else {
+		if (to_update & 1)
+			wm8776_write(chip, WM8776_HPLVOL,
+				     value->value.integer.value[0] |
+				     WM8776_HPZCEN |
+				     ((to_update & 2) ? 0 : WM8776_UPDATE));
+		if (to_update & 2)
+			wm8776_write(chip, WM8776_HPRVOL,
+				     value->value.integer.value[1] |
+				     WM8776_HPZCEN | WM8776_UPDATE);
+	}
+	mutex_unlock(&chip->mutex);
+	return to_update != 0;
+}
+
+static int wm8776_input_mux_get(struct snd_kcontrol *ctl,
+				struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct xonar_wm87x6 *data = chip->model_data;
+	unsigned int mux_bit = ctl->private_value;
+
+	value->value.integer.value[0] =
+		!!(data->wm8776_regs[WM8776_ADCMUX] & mux_bit);
+	return 0;
+}
+
+static int wm8776_input_mux_put(struct snd_kcontrol *ctl,
+				struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct xonar_wm87x6 *data = chip->model_data;
+	unsigned int mux_bit = ctl->private_value;
+	u16 reg;
+	int changed;
+
+	mutex_lock(&chip->mutex);
+	reg = data->wm8776_regs[WM8776_ADCMUX];
+	if (value->value.integer.value[0]) {
+		reg &= ~0x003;
+		reg |= mux_bit;
+	} else
+		reg &= ~mux_bit;
+	changed = reg != data->wm8776_regs[WM8776_ADCMUX];
+	if (changed) {
+		oxygen_write16_masked(chip, OXYGEN_GPIO_DATA,
+				      reg & 1 ? GPIO_DS_INPUT_ROUTE : 0,
+				      GPIO_DS_INPUT_ROUTE);
+		wm8776_write(chip, WM8776_ADCMUX, reg);
+	}
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+static int wm8776_input_vol_info(struct snd_kcontrol *ctl,
+				 struct snd_ctl_elem_info *info)
+{
+	info->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	info->count = 2;
+	info->value.integer.min = 0xa5;
+	info->value.integer.max = 0xff;
+	return 0;
+}
+
+static int wm8776_input_vol_get(struct snd_kcontrol *ctl,
+				struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	mutex_lock(&chip->mutex);
+	value->value.integer.value[0] =
+		data->wm8776_regs[WM8776_ADCLVOL] & WM8776_AGMASK;
+	value->value.integer.value[1] =
+		data->wm8776_regs[WM8776_ADCRVOL] & WM8776_AGMASK;
+	mutex_unlock(&chip->mutex);
+	return 0;
+}
+
+static int wm8776_input_vol_put(struct snd_kcontrol *ctl,
+				struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct xonar_wm87x6 *data = chip->model_data;
+	int changed = 0;
+
+	mutex_lock(&chip->mutex);
+	changed = (value->value.integer.value[0] !=
+		   (data->wm8776_regs[WM8776_ADCLVOL] & WM8776_AGMASK)) ||
+		  (value->value.integer.value[1] !=
+		   (data->wm8776_regs[WM8776_ADCRVOL] & WM8776_AGMASK));
+	wm8776_write_cached(chip, WM8776_ADCLVOL,
+			    value->value.integer.value[0] | WM8776_ZCA);
+	wm8776_write_cached(chip, WM8776_ADCRVOL,
+			    value->value.integer.value[1] | WM8776_ZCA);
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+static int wm8776_level_control_info(struct snd_kcontrol *ctl,
+				     struct snd_ctl_elem_info *info)
+{
+	static const char *const names[3] = {
+		"None", "Peak Limiter", "Automatic Level Control"
+	};
+	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	info->count = 1;
+	info->value.enumerated.items = 3;
+	if (info->value.enumerated.item >= 3)
+		info->value.enumerated.item = 2;
+	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
+	return 0;
+}
+
+static int wm8776_level_control_get(struct snd_kcontrol *ctl,
+				    struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	if (!(data->wm8776_regs[WM8776_ALCCTRL2] & WM8776_LCEN))
+		value->value.enumerated.item[0] = 0;
+	else if ((data->wm8776_regs[WM8776_ALCCTRL1] & WM8776_LCSEL_MASK) ==
+		 WM8776_LCSEL_LIMITER)
+		value->value.enumerated.item[0] = 1;
+	else
+		value->value.enumerated.item[0] = 2;
+	return 0;
+}
+
+static void activate_control(struct oxygen *chip,
+			     struct snd_kcontrol *ctl, unsigned int mode)
+{
+	unsigned int access;
+
+	if (ctl->private_value & mode)
+		access = 0;
+	else
+		access = SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+	if ((ctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_INACTIVE) != access) {
+		ctl->vd[0].access ^= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
+		snd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);
+	}
+}
+
+static int wm8776_level_control_put(struct snd_kcontrol *ctl,
+				    struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct xonar_wm87x6 *data = chip->model_data;
+	unsigned int mode = 0, i;
+	u16 ctrl1, ctrl2;
+	int changed;
+
+	if (value->value.enumerated.item[0] >= 3)
+		return -EINVAL;
+	mutex_lock(&chip->mutex);
+	changed = value->value.enumerated.item[0] != ctl->private_value;
+	if (changed) {
+		ctl->private_value = value->value.enumerated.item[0];
+		ctrl1 = data->wm8776_regs[WM8776_ALCCTRL1];
+		ctrl2 = data->wm8776_regs[WM8776_ALCCTRL2];
+		switch (value->value.enumerated.item[0]) {
+		default:
+			wm8776_write_cached(chip, WM8776_ALCCTRL2,
+					    ctrl2 & ~WM8776_LCEN);
+			break;
+		case 1:
+			wm8776_write_cached(chip, WM8776_ALCCTRL1,
+					    (ctrl1 & ~WM8776_LCSEL_MASK) |
+					    WM8776_LCSEL_LIMITER);
+			wm8776_write_cached(chip, WM8776_ALCCTRL2,
+					    ctrl2 | WM8776_LCEN);
+			mode = LC_CONTROL_LIMITER;
+			break;
+		case 2:
+			wm8776_write_cached(chip, WM8776_ALCCTRL1,
+					    (ctrl1 & ~WM8776_LCSEL_MASK) |
+					    WM8776_LCSEL_ALC_STEREO);
+			wm8776_write_cached(chip, WM8776_ALCCTRL2,
+					    ctrl2 | WM8776_LCEN);
+			mode = LC_CONTROL_ALC;
+			break;
+		}
+		for (i = 0; i < ARRAY_SIZE(data->lc_controls); ++i)
+			activate_control(chip, data->lc_controls[i], mode);
+	}
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+static int hpf_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)
+{
+	static const char *const names[2] = {
+		"None", "High-pass Filter"
+	};
+
+	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	info->count = 1;
+	info->value.enumerated.items = 2;
+	if (info->value.enumerated.item >= 2)
+		info->value.enumerated.item = 1;
+	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
+	return 0;
+}
+
+static int hpf_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct xonar_wm87x6 *data = chip->model_data;
+
+	value->value.enumerated.item[0] =
+		!(data->wm8776_regs[WM8776_ADCIFCTRL] & WM8776_ADCHPD);
+	return 0;
+}
+
+static int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct xonar_wm87x6 *data = chip->model_data;
+	unsigned int reg;
+	int changed;
+
+	mutex_lock(&chip->mutex);
+	reg = data->wm8776_regs[WM8776_ADCIFCTRL] & ~WM8776_ADCHPD;
+	if (!value->value.enumerated.item[0])
+		reg |= WM8776_ADCHPD;
+	changed = reg != data->wm8776_regs[WM8776_ADCIFCTRL];
+	if (changed)
+		wm8776_write(chip, WM8776_ADCIFCTRL, reg);
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+#define WM8776_BIT_SWITCH(xname, reg, bit, invert, flags) { \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.info = snd_ctl_boolean_mono_info, \
+	.get = wm8776_bit_switch_get, \
+	.put = wm8776_bit_switch_put, \
+	.private_value = ((reg) << 16) | (bit) | ((invert) << 24) | (flags), \
+}
+#define _WM8776_FIELD_CTL(xname, reg, shift, initval, min, max, mask, flags) \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.private_value = (initval) | ((min) << 8) | ((max) << 12) | \
+	((mask) << 16) | ((shift) << 20) | ((reg) << 24) | (flags)
+#define WM8776_FIELD_CTL_ENUM(xname, reg, shift, init, min, max, mask, flags) {\
+	_WM8776_FIELD_CTL(xname " Capture Enum", \
+			  reg, shift, init, min, max, mask, flags), \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \
+		  SNDRV_CTL_ELEM_ACCESS_INACTIVE, \
+	.info = wm8776_field_enum_info, \
+	.get = wm8776_field_enum_get, \
+	.put = wm8776_field_enum_put, \
+}
+#define WM8776_FIELD_CTL_VOLUME(a, b, c, d, e, f, g, h, tlv_p) { \
+	_WM8776_FIELD_CTL(a " Capture Volume", b, c, d, e, f, g, h), \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \
+		  SNDRV_CTL_ELEM_ACCESS_INACTIVE | \
+		  SNDRV_CTL_ELEM_ACCESS_TLV_READ, \
+	.info = wm8776_field_volume_info, \
+	.get = wm8776_field_volume_get, \
+	.put = wm8776_field_volume_put, \
+	.tlv = { .p = tlv_p }, \
+}
+
+static const DECLARE_TLV_DB_SCALE(wm87x6_dac_db_scale, -6000, 50, 0);
+static const DECLARE_TLV_DB_SCALE(wm8776_adc_db_scale, -2100, 50, 0);
+static const DECLARE_TLV_DB_SCALE(wm8776_hp_db_scale, -6000, 100, 0);
+static const DECLARE_TLV_DB_SCALE(wm8776_lct_db_scale, -1600, 100, 0);
+static const DECLARE_TLV_DB_SCALE(wm8776_maxgain_db_scale, 0, 400, 0);
+static const DECLARE_TLV_DB_SCALE(wm8776_ngth_db_scale, -7800, 600, 0);
+static const DECLARE_TLV_DB_SCALE(wm8776_maxatten_lim_db_scale, -1200, 100, 0);
+static const DECLARE_TLV_DB_SCALE(wm8776_maxatten_alc_db_scale, -2100, 400, 0);
+
+static const struct snd_kcontrol_new ds_controls[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Headphone Playback Volume",
+		.info = wm8776_hp_vol_info,
+		.get = wm8776_hp_vol_get,
+		.put = wm8776_hp_vol_put,
+		.tlv = { .p = wm8776_hp_db_scale },
+	},
+	WM8776_BIT_SWITCH("Headphone Playback Switch",
+			  WM8776_PWRDOWN, WM8776_HPPD, 1, 0),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Input Capture Volume",
+		.info = wm8776_input_vol_info,
+		.get = wm8776_input_vol_get,
+		.put = wm8776_input_vol_put,
+		.tlv = { .p = wm8776_adc_db_scale },
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Line Capture Switch",
+		.info = snd_ctl_boolean_mono_info,
+		.get = wm8776_input_mux_get,
+		.put = wm8776_input_mux_put,
+		.private_value = 1 << 0,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Mic Capture Switch",
+		.info = snd_ctl_boolean_mono_info,
+		.get = wm8776_input_mux_get,
+		.put = wm8776_input_mux_put,
+		.private_value = 1 << 1,
+	},
+	WM8776_BIT_SWITCH("Aux", WM8776_ADCMUX, 1 << 2, 0, 0),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "ADC Filter Capture Enum",
+		.info = hpf_info,
+		.get = hpf_get,
+		.put = hpf_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Level Control Capture Enum",
+		.info = wm8776_level_control_info,
+		.get = wm8776_level_control_get,
+		.put = wm8776_level_control_put,
+		.private_value = 0,
+	},
+};
+static const struct snd_kcontrol_new lc_controls[] = {
+	WM8776_FIELD_CTL_VOLUME("Limiter Threshold",
+				WM8776_ALCCTRL1, 0, 11, 0, 15, 0xf,
+				LC_CONTROL_LIMITER, wm8776_lct_db_scale),
+	WM8776_FIELD_CTL_ENUM("Limiter Attack Time",
+			      WM8776_ALCCTRL3, 0, 2, 0, 10, 0xf,
+			      LC_CONTROL_LIMITER),
+	WM8776_FIELD_CTL_ENUM("Limiter Decay Time",
+			      WM8776_ALCCTRL3, 4, 3, 0, 10, 0xf,
+			      LC_CONTROL_LIMITER),
+	WM8776_FIELD_CTL_ENUM("Limiter Transient Window",
+			      WM8776_LIMITER, 4, 2, 0, 7, 0x7,
+			      LC_CONTROL_LIMITER),
+	WM8776_FIELD_CTL_VOLUME("Limiter Maximum Attenuation",
+				WM8776_LIMITER, 0, 6, 3, 12, 0xf,
+				LC_CONTROL_LIMITER,
+				wm8776_maxatten_lim_db_scale),
+	WM8776_FIELD_CTL_VOLUME("ALC Target Level",
+				WM8776_ALCCTRL1, 0, 11, 0, 15, 0xf,
+				LC_CONTROL_ALC, wm8776_lct_db_scale),
+	WM8776_FIELD_CTL_ENUM("ALC Attack Time",
+			      WM8776_ALCCTRL3, 0, 2, 0, 10, 0xf,
+			      LC_CONTROL_ALC),
+	WM8776_FIELD_CTL_ENUM("ALC Decay Time",
+			      WM8776_ALCCTRL3, 4, 3, 0, 10, 0xf,
+			      LC_CONTROL_ALC),
+	WM8776_FIELD_CTL_VOLUME("ALC Maximum Gain",
+				WM8776_ALCCTRL1, 4, 7, 1, 7, 0x7,
+				LC_CONTROL_ALC, wm8776_maxgain_db_scale),
+	WM8776_FIELD_CTL_VOLUME("ALC Maximum Attenuation",
+				WM8776_LIMITER, 0, 10, 10, 15, 0xf,
+				LC_CONTROL_ALC, wm8776_maxatten_alc_db_scale),
+	WM8776_FIELD_CTL_ENUM("ALC Hold Time",
+			      WM8776_ALCCTRL2, 0, 0, 0, 15, 0xf,
+			      LC_CONTROL_ALC),
+	WM8776_BIT_SWITCH("Noise Gate Capture Switch",
+			  WM8776_NOISEGATE, WM8776_NGAT, 0,
+			  LC_CONTROL_ALC),
+	WM8776_FIELD_CTL_VOLUME("Noise Gate Threshold",
+				WM8776_NOISEGATE, 2, 0, 0, 7, 0x7,
+				LC_CONTROL_ALC, wm8776_ngth_db_scale),
+};
+
+static int xonar_ds_control_filter(struct snd_kcontrol_new *template)
+{
+	if (!strncmp(template->name, "CD Capture ", 11))
+		return 1; /* no CD input */
+	return 0;
+}
+
+static int xonar_ds_mixer_init(struct oxygen *chip)
+{
+	struct xonar_wm87x6 *data = chip->model_data;
+	unsigned int i;
+	struct snd_kcontrol *ctl;
+	int err;
+
+	for (i = 0; i < ARRAY_SIZE(ds_controls); ++i) {
+		ctl = snd_ctl_new1(&ds_controls[i], chip);
+		if (!ctl)
+			return -ENOMEM;
+		err = snd_ctl_add(chip->card, ctl);
+		if (err < 0)
+			return err;
+	}
+	BUILD_BUG_ON(ARRAY_SIZE(lc_controls) != ARRAY_SIZE(data->lc_controls));
+	for (i = 0; i < ARRAY_SIZE(lc_controls); ++i) {
+		ctl = snd_ctl_new1(&lc_controls[i], chip);
+		if (!ctl)
+			return -ENOMEM;
+		err = snd_ctl_add(chip->card, ctl);
+		if (err < 0)
+			return err;
+		data->lc_controls[i] = ctl;
+	}
+	return 0;
+}
+
+static const struct oxygen_model model_xonar_ds = {
+	.shortname = "Xonar DS",
+	.longname = "Asus Virtuoso 200",
+	.chip = "AV200",
+	.init = xonar_ds_init,
+	.control_filter = xonar_ds_control_filter,
+	.mixer_init = xonar_ds_mixer_init,
+	.cleanup = xonar_ds_cleanup,
+	.suspend = xonar_ds_suspend,
+	.resume = xonar_ds_resume,
+	.pcm_hardware_filter = wm8776_adc_hardware_filter,
+	.get_i2s_mclk = oxygen_default_i2s_mclk,
+	.set_dac_params = set_wm87x6_dac_params,
+	.set_adc_params = set_wm8776_adc_params,
+	.update_dac_volume = update_wm87x6_volume,
+	.update_dac_mute = update_wm87x6_mute,
+	.gpio_changed = xonar_ds_gpio_changed,
+	.dac_tlv = wm87x6_dac_db_scale,
+	.model_data_size = sizeof(struct xonar_wm87x6),
+	.device_config = PLAYBACK_0_TO_I2S |
+			 PLAYBACK_1_TO_SPDIF |
+			 CAPTURE_0_FROM_I2S_1,
+	.dac_channels = 8,
+	.dac_volume_min = 255 - 2*60,
+	.dac_volume_max = 255,
+	.function_flags = OXYGEN_FUNCTION_SPI,
+	.dac_i2s_format = OXYGEN_I2S_FORMAT_LJUST,
+	.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,
+};
+
+int __devinit get_xonar_wm87x6_model(struct oxygen *chip,
+				     const struct pci_device_id *id)
+{
+	switch (id->subdevice) {
+	case 0x838e:
+		chip->model = model_xonar_ds;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
