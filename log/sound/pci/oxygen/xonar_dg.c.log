commit b67eb1520b39f7b56c17d452040f5371fb1104dc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:12:38 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 264
    
    Based on 1 normalized pattern(s):
    
      this driver is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 this
      driver is distributed in the hope that it will be useful but without
      any warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this driver if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 9 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141333.769845457@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index 4cf3200e988b..c3f8721624cd 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -1,19 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * card driver for the Xonar DG/DGX
  *
  * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
  * Copyright (c) Roman Volkov <v1ron@mail.ru>
- *
- *  This driver is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License, version 2.
- *
- *  This driver is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this driver; if not, see <http://www.gnu.org/licenses/>.
  */
 
 /*

commit 305564413c99514a14a49215790d96b8d71a6295
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Mar 18 09:31:18 2014 +0100

    ALSA: oxygen: Xonar DG(X): fix Stereo Upmixing regression
    
    The code introduced in commit 1f91ecc14dee ("ALSA: oxygen: modify
    adjust_dg_dac_routing function") accidentally disregarded the old value
    of the playback routing register, so it broke the "Stereo Upmixing"
    mixer control.
    
    The unmuted parts of the channel routing are the same for all settings
    of the output destination, so it suffices to revert that part of the
    patch.
    
    Fixes: 1f91ecc14dee ('ALSA: oxygen: modify adjust_dg_dac_routing function')
    Tested-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index ed6f199f8a38..4cf3200e988b 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -238,11 +238,21 @@ void set_cs4245_adc_params(struct oxygen *chip,
 	cs4245_write_spi(chip, CS4245_MCLK_FREQ);
 }
 
+static inline unsigned int shift_bits(unsigned int value,
+				      unsigned int shift_from,
+				      unsigned int shift_to,
+				      unsigned int mask)
+{
+	if (shift_from < shift_to)
+		return (value << (shift_to - shift_from)) & mask;
+	else
+		return (value >> (shift_from - shift_to)) & mask;
+}
+
 unsigned int adjust_dg_dac_routing(struct oxygen *chip,
 					  unsigned int play_routing)
 {
 	struct dg *data = chip->model_data;
-	unsigned int routing = 0;
 
 	switch (data->output_sel) {
 	case PLAYBACK_DST_HP:
@@ -252,15 +262,23 @@ unsigned int adjust_dg_dac_routing(struct oxygen *chip,
 			OXYGEN_PLAY_MUTE67, OXYGEN_PLAY_MUTE_MASK);
 		break;
 	case PLAYBACK_DST_MULTICH:
-		routing = (0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |
-			  (2 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |
-			  (1 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |
-			  (0 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT);
 		oxygen_write8_masked(chip, OXYGEN_PLAY_ROUTING,
 			OXYGEN_PLAY_MUTE01, OXYGEN_PLAY_MUTE_MASK);
 		break;
 	}
-	return routing;
+	return (play_routing & OXYGEN_PLAY_DAC0_SOURCE_MASK) |
+	       shift_bits(play_routing,
+			  OXYGEN_PLAY_DAC2_SOURCE_SHIFT,
+			  OXYGEN_PLAY_DAC1_SOURCE_SHIFT,
+			  OXYGEN_PLAY_DAC1_SOURCE_MASK) |
+	       shift_bits(play_routing,
+			  OXYGEN_PLAY_DAC1_SOURCE_SHIFT,
+			  OXYGEN_PLAY_DAC2_SOURCE_SHIFT,
+			  OXYGEN_PLAY_DAC2_SOURCE_MASK) |
+	       shift_bits(play_routing,
+			  OXYGEN_PLAY_DAC0_SOURCE_SHIFT,
+			  OXYGEN_PLAY_DAC3_SOURCE_SHIFT,
+			  OXYGEN_PLAY_DAC3_SOURCE_MASK);
 }
 
 void dump_cs4245_registers(struct oxygen *chip,

commit 3f49a66f6ceff1c87b49858644771c17763902ab
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:20 2014 +0400

    ALSA: oxygen: Xonar DG(X): cleanup and minor changes
    
    Remove old SPI control functions, change anti-pop init
    sequence, remove some garbage from structures. The 'Apply' functions
    must be called at the mixer initialization, otherwise
    mixer settings sometimes will not be applied at startup.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index 6cec934e6628..ed6f199f8a38 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -123,29 +123,6 @@ int cs4245_shadow_control(struct oxygen *chip, enum cs4245_shadow_operation op)
 	return 0;
 }
 
-void cs4245_write(struct oxygen *chip, unsigned int reg, u8 value)
-{
-	struct dg *data = chip->model_data;
-
-	oxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |
-			 OXYGEN_SPI_DATA_LENGTH_3 |
-			 OXYGEN_SPI_CLOCK_1280 |
-			 (0 << OXYGEN_SPI_CODEC_SHIFT) |
-			 OXYGEN_SPI_CEN_LATCH_CLOCK_HI,
-			 CS4245_SPI_ADDRESS_S |
-			 CS4245_SPI_WRITE_S |
-			 (reg << 8) | value);
-	data->cs4245_shadow[reg] = value;
-}
-
-void cs4245_write_cached(struct oxygen *chip, unsigned int reg, u8 value)
-{
-	struct dg *data = chip->model_data;
-
-	if (value != data->cs4245_shadow[reg])
-		cs4245_write(chip, reg, value);
-}
-
 static void cs4245_init(struct oxygen *chip)
 {
 	struct dg *data = chip->model_data;
@@ -171,8 +148,8 @@ static void cs4245_init(struct oxygen *chip)
 		CS4245_PGA_SOFT | CS4245_PGA_ZERO;
 	data->cs4245_shadow[CS4245_PGA_B_CTRL] = 0;
 	data->cs4245_shadow[CS4245_PGA_A_CTRL] = 0;
-	data->cs4245_shadow[CS4245_DAC_A_CTRL] = 4;
-	data->cs4245_shadow[CS4245_DAC_B_CTRL] = 4;
+	data->cs4245_shadow[CS4245_DAC_A_CTRL] = 8;
+	data->cs4245_shadow[CS4245_DAC_B_CTRL] = 8;
 
 	cs4245_shadow_control(chip, CS4245_LOAD_FROM_SHADOW);
 	snd_component_add(chip->card, "CS4245");
@@ -182,15 +159,14 @@ void dg_init(struct oxygen *chip)
 {
 	struct dg *data = chip->model_data;
 
-	data->output_sel = 0;
-	data->input_sel = 3;
-	data->hp_vol_att = 2 * 16;
+	data->output_sel = PLAYBACK_DST_HP_FP;
+	data->input_sel = CAPTURE_SRC_MIC;
 
 	cs4245_init(chip);
 	oxygen_write16(chip, OXYGEN_GPIO_CONTROL,
 		       GPIO_OUTPUT_ENABLE | GPIO_HP_REAR | GPIO_INPUT_ROUTE);
-	oxygen_write16(chip, OXYGEN_GPIO_DATA, GPIO_INPUT_ROUTE);
-	msleep(2500); /* anti-pop delay */
+	/* anti-pop delay, wait some time before enabling the output */
+	msleep(2500);
 	oxygen_write16(chip, OXYGEN_GPIO_DATA,
 		       GPIO_OUTPUT_ENABLE | GPIO_INPUT_ROUTE);
 }

commit 2809cb84d1672b639a4a41a0fa077fb554699072
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:15 2014 +0400

    ALSA: oxygen: Xonar DG(X): modify playback output select
    
    Change the order of elements in the output select control. This will
    reduce the number of relay switches. Change 'put' function to call the
    oxygen_update_dac_routing() function. Otherwise multichannel playback
    does not work. Also there is a new function to apply settings, this
    prevents from duplicating the code.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index d12d83554abb..6cec934e6628 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -268,7 +268,7 @@ unsigned int adjust_dg_dac_routing(struct oxygen *chip,
 	struct dg *data = chip->model_data;
 	unsigned int routing = 0;
 
-	switch (data->pcm_output) {
+	switch (data->output_sel) {
 	case PLAYBACK_DST_HP:
 	case PLAYBACK_DST_HP_FP:
 		oxygen_write8_masked(chip, OXYGEN_PLAY_ROUTING,

commit 041f26b6257d15449e1634ba8dea426dd06514c7
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:13 2014 +0400

    ALSA: oxygen: Xonar DG(X): move the mixer code into another file
    
    Moving the mixer code away makes things easier. The mixer
    will control the driver, so the functions of the
    driver need to be non-static.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index 4a4266519934..d12d83554abb 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -123,7 +123,7 @@ int cs4245_shadow_control(struct oxygen *chip, enum cs4245_shadow_operation op)
 	return 0;
 }
 
-static void cs4245_write(struct oxygen *chip, unsigned int reg, u8 value)
+void cs4245_write(struct oxygen *chip, unsigned int reg, u8 value)
 {
 	struct dg *data = chip->model_data;
 
@@ -138,7 +138,7 @@ static void cs4245_write(struct oxygen *chip, unsigned int reg, u8 value)
 	data->cs4245_shadow[reg] = value;
 }
 
-static void cs4245_write_cached(struct oxygen *chip, unsigned int reg, u8 value)
+void cs4245_write_cached(struct oxygen *chip, unsigned int reg, u8 value)
 {
 	struct dg *data = chip->model_data;
 
@@ -178,7 +178,7 @@ static void cs4245_init(struct oxygen *chip)
 	snd_component_add(chip->card, "CS4245");
 }
 
-static void dg_init(struct oxygen *chip)
+void dg_init(struct oxygen *chip)
 {
 	struct dg *data = chip->model_data;
 
@@ -195,24 +195,24 @@ static void dg_init(struct oxygen *chip)
 		       GPIO_OUTPUT_ENABLE | GPIO_INPUT_ROUTE);
 }
 
-static void dg_cleanup(struct oxygen *chip)
+void dg_cleanup(struct oxygen *chip)
 {
 	oxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_OUTPUT_ENABLE);
 }
 
-static void dg_suspend(struct oxygen *chip)
+void dg_suspend(struct oxygen *chip)
 {
 	dg_cleanup(chip);
 }
 
-static void dg_resume(struct oxygen *chip)
+void dg_resume(struct oxygen *chip)
 {
 	cs4245_shadow_control(chip, CS4245_LOAD_FROM_SHADOW);
 	msleep(2500);
 	oxygen_set_bits16(chip, OXYGEN_GPIO_DATA, GPIO_OUTPUT_ENABLE);
 }
 
-static void set_cs4245_dac_params(struct oxygen *chip,
+void set_cs4245_dac_params(struct oxygen *chip,
 				  struct snd_pcm_hw_params *params)
 {
 	struct dg *data = chip->model_data;
@@ -237,7 +237,7 @@ static void set_cs4245_dac_params(struct oxygen *chip,
 	cs4245_write_spi(chip, CS4245_MCLK_FREQ);
 }
 
-static void set_cs4245_adc_params(struct oxygen *chip,
+void set_cs4245_adc_params(struct oxygen *chip,
 				  struct snd_pcm_hw_params *params)
 {
 	struct dg *data = chip->model_data;
@@ -262,7 +262,7 @@ static void set_cs4245_adc_params(struct oxygen *chip,
 	cs4245_write_spi(chip, CS4245_MCLK_FREQ);
 }
 
-static unsigned int adjust_dg_dac_routing(struct oxygen *chip,
+unsigned int adjust_dg_dac_routing(struct oxygen *chip,
 					  unsigned int play_routing)
 {
 	struct dg *data = chip->model_data;
@@ -287,333 +287,7 @@ static unsigned int adjust_dg_dac_routing(struct oxygen *chip,
 	return routing;
 }
 
-static int output_switch_info(struct snd_kcontrol *ctl,
-			      struct snd_ctl_elem_info *info)
-{
-	static const char *const names[3] = {
-		"Speakers", "Headphones", "FP Headphones"
-	};
-
-	return snd_ctl_enum_info(info, 1, 3, names);
-}
-
-static int output_switch_get(struct snd_kcontrol *ctl,
-			     struct snd_ctl_elem_value *value)
-{
-	struct oxygen *chip = ctl->private_data;
-	struct dg *data = chip->model_data;
-
-	mutex_lock(&chip->mutex);
-	value->value.enumerated.item[0] = data->output_sel;
-	mutex_unlock(&chip->mutex);
-	return 0;
-}
-
-static int output_switch_put(struct snd_kcontrol *ctl,
-			     struct snd_ctl_elem_value *value)
-{
-	struct oxygen *chip = ctl->private_data;
-	struct dg *data = chip->model_data;
-	u8 reg;
-	int changed;
-
-	if (value->value.enumerated.item[0] > 2)
-		return -EINVAL;
-
-	mutex_lock(&chip->mutex);
-	changed = value->value.enumerated.item[0] != data->output_sel;
-	if (changed) {
-		data->output_sel = value->value.enumerated.item[0];
-
-		reg = data->cs4245_shadow[CS4245_SIGNAL_SEL] &
-						~CS4245_A_OUT_SEL_MASK;
-		reg |= data->output_sel == 2 ?
-				CS4245_A_OUT_SEL_DAC : CS4245_A_OUT_SEL_HIZ;
-		cs4245_write_cached(chip, CS4245_SIGNAL_SEL, reg);
-
-		cs4245_write_cached(chip, CS4245_DAC_A_CTRL,
-				    data->output_sel ? data->hp_vol_att : 0);
-		cs4245_write_cached(chip, CS4245_DAC_B_CTRL,
-				    data->output_sel ? data->hp_vol_att : 0);
-
-		oxygen_write16_masked(chip, OXYGEN_GPIO_DATA,
-				      data->output_sel == 1 ? GPIO_HP_REAR : 0,
-				      GPIO_HP_REAR);
-	}
-	mutex_unlock(&chip->mutex);
-	return changed;
-}
-
-static int hp_volume_offset_info(struct snd_kcontrol *ctl,
-				 struct snd_ctl_elem_info *info)
-{
-	static const char *const names[3] = {
-		"< 64 ohms", "64-150 ohms", "150-300 ohms"
-	};
-
-	return snd_ctl_enum_info(info, 1, 3, names);
-}
-
-static int hp_volume_offset_get(struct snd_kcontrol *ctl,
-				struct snd_ctl_elem_value *value)
-{
-	struct oxygen *chip = ctl->private_data;
-	struct dg *data = chip->model_data;
-
-	mutex_lock(&chip->mutex);
-	if (data->hp_vol_att > 2 * 7)
-		value->value.enumerated.item[0] = 0;
-	else if (data->hp_vol_att > 0)
-		value->value.enumerated.item[0] = 1;
-	else
-		value->value.enumerated.item[0] = 2;
-	mutex_unlock(&chip->mutex);
-	return 0;
-}
-
-static int hp_volume_offset_put(struct snd_kcontrol *ctl,
-				struct snd_ctl_elem_value *value)
-{
-	static const s8 atts[3] = { 2 * 16, 2 * 7, 0 };
-	struct oxygen *chip = ctl->private_data;
-	struct dg *data = chip->model_data;
-	s8 att;
-	int changed;
-
-	if (value->value.enumerated.item[0] > 2)
-		return -EINVAL;
-	att = atts[value->value.enumerated.item[0]];
-	mutex_lock(&chip->mutex);
-	changed = att != data->hp_vol_att;
-	if (changed) {
-		data->hp_vol_att = att;
-		if (data->output_sel) {
-			cs4245_write_cached(chip, CS4245_DAC_A_CTRL, att);
-			cs4245_write_cached(chip, CS4245_DAC_B_CTRL, att);
-		}
-	}
-	mutex_unlock(&chip->mutex);
-	return changed;
-}
-
-static int input_vol_info(struct snd_kcontrol *ctl,
-			  struct snd_ctl_elem_info *info)
-{
-	info->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	info->count = 2;
-	info->value.integer.min = 2 * -12;
-	info->value.integer.max = 2 * 12;
-	return 0;
-}
-
-static int input_vol_get(struct snd_kcontrol *ctl,
-			 struct snd_ctl_elem_value *value)
-{
-	struct oxygen *chip = ctl->private_data;
-	struct dg *data = chip->model_data;
-	unsigned int idx = ctl->private_value;
-
-	mutex_lock(&chip->mutex);
-	value->value.integer.value[0] = data->input_vol[idx][0];
-	value->value.integer.value[1] = data->input_vol[idx][1];
-	mutex_unlock(&chip->mutex);
-	return 0;
-}
-
-static int input_vol_put(struct snd_kcontrol *ctl,
-			 struct snd_ctl_elem_value *value)
-{
-	struct oxygen *chip = ctl->private_data;
-	struct dg *data = chip->model_data;
-	unsigned int idx = ctl->private_value;
-	int changed = 0;
-
-	if (value->value.integer.value[0] < 2 * -12 ||
-	    value->value.integer.value[0] > 2 * 12 ||
-	    value->value.integer.value[1] < 2 * -12 ||
-	    value->value.integer.value[1] > 2 * 12)
-		return -EINVAL;
-	mutex_lock(&chip->mutex);
-	changed = data->input_vol[idx][0] != value->value.integer.value[0] ||
-		  data->input_vol[idx][1] != value->value.integer.value[1];
-	if (changed) {
-		data->input_vol[idx][0] = value->value.integer.value[0];
-		data->input_vol[idx][1] = value->value.integer.value[1];
-		if (idx == data->input_sel) {
-			cs4245_write_cached(chip, CS4245_PGA_A_CTRL,
-					    data->input_vol[idx][0]);
-			cs4245_write_cached(chip, CS4245_PGA_B_CTRL,
-					    data->input_vol[idx][1]);
-		}
-	}
-	mutex_unlock(&chip->mutex);
-	return changed;
-}
-
-static DECLARE_TLV_DB_SCALE(cs4245_pga_db_scale, -1200, 50, 0);
-
-static int input_sel_info(struct snd_kcontrol *ctl,
-			  struct snd_ctl_elem_info *info)
-{
-	static const char *const names[4] = {
-		"Mic", "Aux", "Front Mic", "Line"
-	};
-
-	return snd_ctl_enum_info(info, 1, 4, names);
-}
-
-static int input_sel_get(struct snd_kcontrol *ctl,
-			 struct snd_ctl_elem_value *value)
-{
-	struct oxygen *chip = ctl->private_data;
-	struct dg *data = chip->model_data;
-
-	mutex_lock(&chip->mutex);
-	value->value.enumerated.item[0] = data->input_sel;
-	mutex_unlock(&chip->mutex);
-	return 0;
-}
-
-static int input_sel_put(struct snd_kcontrol *ctl,
-			 struct snd_ctl_elem_value *value)
-{
-	static const u8 sel_values[4] = {
-		CS4245_SEL_MIC,
-		CS4245_SEL_INPUT_1,
-		CS4245_SEL_INPUT_2,
-		CS4245_SEL_INPUT_4
-	};
-	struct oxygen *chip = ctl->private_data;
-	struct dg *data = chip->model_data;
-	int changed;
-
-	if (value->value.enumerated.item[0] > 3)
-		return -EINVAL;
-
-	mutex_lock(&chip->mutex);
-	changed = value->value.enumerated.item[0] != data->input_sel;
-	if (changed) {
-		data->input_sel = value->value.enumerated.item[0];
-
-		cs4245_write(chip, CS4245_ANALOG_IN,
-			     (data->cs4245_shadow[CS4245_ANALOG_IN] &
-							~CS4245_SEL_MASK) |
-			     sel_values[data->input_sel]);
-
-		cs4245_write_cached(chip, CS4245_PGA_A_CTRL,
-				    data->input_vol[data->input_sel][0]);
-		cs4245_write_cached(chip, CS4245_PGA_B_CTRL,
-				    data->input_vol[data->input_sel][1]);
-
-		oxygen_write16_masked(chip, OXYGEN_GPIO_DATA,
-				      data->input_sel ? 0 : GPIO_INPUT_ROUTE,
-				      GPIO_INPUT_ROUTE);
-	}
-	mutex_unlock(&chip->mutex);
-	return changed;
-}
-
-static int hpf_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)
-{
-	static const char *const names[2] = { "Active", "Frozen" };
-
-	return snd_ctl_enum_info(info, 1, 2, names);
-}
-
-static int hpf_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)
-{
-	struct oxygen *chip = ctl->private_data;
-	struct dg *data = chip->model_data;
-
-	value->value.enumerated.item[0] =
-		!!(data->cs4245_shadow[CS4245_ADC_CTRL] & CS4245_HPF_FREEZE);
-	return 0;
-}
-
-static int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)
-{
-	struct oxygen *chip = ctl->private_data;
-	struct dg *data = chip->model_data;
-	u8 reg;
-	int changed;
-
-	mutex_lock(&chip->mutex);
-	reg = data->cs4245_shadow[CS4245_ADC_CTRL] & ~CS4245_HPF_FREEZE;
-	if (value->value.enumerated.item[0])
-		reg |= CS4245_HPF_FREEZE;
-	changed = reg != data->cs4245_shadow[CS4245_ADC_CTRL];
-	if (changed)
-		cs4245_write(chip, CS4245_ADC_CTRL, reg);
-	mutex_unlock(&chip->mutex);
-	return changed;
-}
-
-#define INPUT_VOLUME(xname, index) { \
-	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-	.name = xname, \
-	.info = input_vol_info, \
-	.get = input_vol_get, \
-	.put = input_vol_put, \
-	.tlv = { .p = cs4245_pga_db_scale }, \
-	.private_value = index, \
-}
-static const struct snd_kcontrol_new dg_controls[] = {
-	{
-		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name = "Analog Output Playback Enum",
-		.info = output_switch_info,
-		.get = output_switch_get,
-		.put = output_switch_put,
-	},
-	{
-		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name = "Headphones Impedance Playback Enum",
-		.info = hp_volume_offset_info,
-		.get = hp_volume_offset_get,
-		.put = hp_volume_offset_put,
-	},
-	INPUT_VOLUME("Mic Capture Volume", 0),
-	INPUT_VOLUME("Aux Capture Volume", 1),
-	INPUT_VOLUME("Front Mic Capture Volume", 2),
-	INPUT_VOLUME("Line Capture Volume", 3),
-	{
-		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name = "Capture Source",
-		.info = input_sel_info,
-		.get = input_sel_get,
-		.put = input_sel_put,
-	},
-	{
-		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name = "ADC High-pass Filter Capture Enum",
-		.info = hpf_info,
-		.get = hpf_get,
-		.put = hpf_put,
-	},
-};
-
-static int dg_control_filter(struct snd_kcontrol_new *template)
-{
-	if (!strncmp(template->name, "Master Playback ", 16))
-		return 1;
-	return 0;
-}
-
-static int dg_mixer_init(struct oxygen *chip)
-{
-	unsigned int i;
-	int err;
-
-	for (i = 0; i < ARRAY_SIZE(dg_controls); ++i) {
-		err = snd_ctl_add(chip->card,
-				  snd_ctl_new1(&dg_controls[i], chip));
-		if (err < 0)
-			return err;
-	}
-	return 0;
-}
-
-static void dump_cs4245_registers(struct oxygen *chip,
+void dump_cs4245_registers(struct oxygen *chip,
 				  struct snd_info_buffer *buffer)
 {
 	struct dg *data = chip->model_data;
@@ -625,30 +299,3 @@ static void dump_cs4245_registers(struct oxygen *chip,
 		snd_iprintf(buffer, " %02x", data->cs4245_shadow[addr]);
 	snd_iprintf(buffer, "\n");
 }
-
-struct oxygen_model model_xonar_dg = {
-	.longname = "C-Media Oxygen HD Audio",
-	.chip = "CMI8786",
-	.init = dg_init,
-	.control_filter = dg_control_filter,
-	.mixer_init = dg_mixer_init,
-	.cleanup = dg_cleanup,
-	.suspend = dg_suspend,
-	.resume = dg_resume,
-	.set_dac_params = set_cs4245_dac_params,
-	.set_adc_params = set_cs4245_adc_params,
-	.adjust_dac_routing = adjust_dg_dac_routing,
-	.dump_registers = dump_cs4245_registers,
-	.model_data_size = sizeof(struct dg),
-	.device_config = PLAYBACK_0_TO_I2S |
-			 PLAYBACK_1_TO_SPDIF |
-			 CAPTURE_0_FROM_I2S_2 |
-			 CAPTURE_1_FROM_SPDIF,
-	.dac_channels_pcm = 6,
-	.dac_channels_mixer = 0,
-	.function_flags = OXYGEN_FUNCTION_SPI,
-	.dac_mclks = OXYGEN_MCLKS(256, 128, 128),
-	.adc_mclks = OXYGEN_MCLKS(256, 128, 128),
-	.dac_i2s_format = OXYGEN_I2S_FORMAT_LJUST,
-	.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,
-};

commit 06f70d0da029a0ae9dbb7e383f853db483575f87
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:12 2014 +0400

    ALSA: oxygen: modify CS4245 register dumping function
    
    Change the function to read the data from the new shadow buffer.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index 329da5434556..4a4266519934 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -617,11 +617,12 @@ static void dump_cs4245_registers(struct oxygen *chip,
 				  struct snd_info_buffer *buffer)
 {
 	struct dg *data = chip->model_data;
-	unsigned int i;
+	unsigned int addr;
 
 	snd_iprintf(buffer, "\nCS4245:");
-	for (i = 1; i <= 0x10; ++i)
-		snd_iprintf(buffer, " %02x", data->cs4245_shadow[i]);
+	cs4245_read_spi(chip, CS4245_INT_STATUS);
+	for (addr = 1; addr < ARRAY_SIZE(data->cs4245_shadow); addr++)
+		snd_iprintf(buffer, " %02x", data->cs4245_shadow[addr]);
 	snd_iprintf(buffer, "\n");
 }
 

commit 1f91ecc14deea9461aca93273d78871ec4d98fcd
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:11 2014 +0400

    ALSA: oxygen: modify adjust_dg_dac_routing function
    
    When selecting the audio output destinations (headphones,
    FP headphones, multichannel output), the channel routing
    should be changed depending on what destination selected.
    Also unnecessary I2S channels are digitally muted. This
    function called when the user selects the destination
    in the ALSA mixer.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index 81c004c78766..329da5434556 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -262,33 +262,29 @@ static void set_cs4245_adc_params(struct oxygen *chip,
 	cs4245_write_spi(chip, CS4245_MCLK_FREQ);
 }
 
-static inline unsigned int shift_bits(unsigned int value,
-				      unsigned int shift_from,
-				      unsigned int shift_to,
-				      unsigned int mask)
-{
-	if (shift_from < shift_to)
-		return (value << (shift_to - shift_from)) & mask;
-	else
-		return (value >> (shift_from - shift_to)) & mask;
-}
-
 static unsigned int adjust_dg_dac_routing(struct oxygen *chip,
 					  unsigned int play_routing)
 {
-	return (play_routing & OXYGEN_PLAY_DAC0_SOURCE_MASK) |
-	       shift_bits(play_routing,
-			  OXYGEN_PLAY_DAC2_SOURCE_SHIFT,
-			  OXYGEN_PLAY_DAC1_SOURCE_SHIFT,
-			  OXYGEN_PLAY_DAC1_SOURCE_MASK) |
-	       shift_bits(play_routing,
-			  OXYGEN_PLAY_DAC1_SOURCE_SHIFT,
-			  OXYGEN_PLAY_DAC2_SOURCE_SHIFT,
-			  OXYGEN_PLAY_DAC2_SOURCE_MASK) |
-	       shift_bits(play_routing,
-			  OXYGEN_PLAY_DAC0_SOURCE_SHIFT,
-			  OXYGEN_PLAY_DAC3_SOURCE_SHIFT,
-			  OXYGEN_PLAY_DAC3_SOURCE_MASK);
+	struct dg *data = chip->model_data;
+	unsigned int routing = 0;
+
+	switch (data->pcm_output) {
+	case PLAYBACK_DST_HP:
+	case PLAYBACK_DST_HP_FP:
+		oxygen_write8_masked(chip, OXYGEN_PLAY_ROUTING,
+			OXYGEN_PLAY_MUTE23 | OXYGEN_PLAY_MUTE45 |
+			OXYGEN_PLAY_MUTE67, OXYGEN_PLAY_MUTE_MASK);
+		break;
+	case PLAYBACK_DST_MULTICH:
+		routing = (0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |
+			  (2 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |
+			  (1 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |
+			  (0 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT);
+		oxygen_write8_masked(chip, OXYGEN_PLAY_ROUTING,
+			OXYGEN_PLAY_MUTE01, OXYGEN_PLAY_MUTE_MASK);
+		break;
+	}
+	return routing;
 }
 
 static int output_switch_info(struct snd_kcontrol *ctl,

commit fddc106bc35ac2663f42c99bdf404c155a34b9a7
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:10 2014 +0400

    ALSA: oxygen: Xonar DG(X): modify DAC/ADC parameters function
    
    When selecting the audio sample rate for CS4245,
    the MCLK divider should also be changed.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index 4177fb131086..81c004c78766 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -216,32 +216,50 @@ static void set_cs4245_dac_params(struct oxygen *chip,
 				  struct snd_pcm_hw_params *params)
 {
 	struct dg *data = chip->model_data;
-	u8 value;
-
-	value = data->cs4245_shadow[CS4245_DAC_CTRL_1] & ~CS4245_DAC_FM_MASK;
-	if (params_rate(params) <= 50000)
-		value |= CS4245_DAC_FM_SINGLE;
-	else if (params_rate(params) <= 100000)
-		value |= CS4245_DAC_FM_DOUBLE;
-	else
-		value |= CS4245_DAC_FM_QUAD;
-	cs4245_write_cached(chip, CS4245_DAC_CTRL_1, value);
+	unsigned char dac_ctrl;
+	unsigned char mclk_freq;
+
+	dac_ctrl = data->cs4245_shadow[CS4245_DAC_CTRL_1] & ~CS4245_DAC_FM_MASK;
+	mclk_freq = data->cs4245_shadow[CS4245_MCLK_FREQ] & ~CS4245_MCLK1_MASK;
+	if (params_rate(params) <= 50000) {
+		dac_ctrl |= CS4245_DAC_FM_SINGLE;
+		mclk_freq |= CS4245_MCLK_1 << CS4245_MCLK1_SHIFT;
+	} else if (params_rate(params) <= 100000) {
+		dac_ctrl |= CS4245_DAC_FM_DOUBLE;
+		mclk_freq |= CS4245_MCLK_1 << CS4245_MCLK1_SHIFT;
+	} else {
+		dac_ctrl |= CS4245_DAC_FM_QUAD;
+		mclk_freq |= CS4245_MCLK_2 << CS4245_MCLK1_SHIFT;
+	}
+	data->cs4245_shadow[CS4245_DAC_CTRL_1] = dac_ctrl;
+	data->cs4245_shadow[CS4245_MCLK_FREQ] = mclk_freq;
+	cs4245_write_spi(chip, CS4245_DAC_CTRL_1);
+	cs4245_write_spi(chip, CS4245_MCLK_FREQ);
 }
 
 static void set_cs4245_adc_params(struct oxygen *chip,
 				  struct snd_pcm_hw_params *params)
 {
 	struct dg *data = chip->model_data;
-	u8 value;
-
-	value = data->cs4245_shadow[CS4245_ADC_CTRL] & ~CS4245_ADC_FM_MASK;
-	if (params_rate(params) <= 50000)
-		value |= CS4245_ADC_FM_SINGLE;
-	else if (params_rate(params) <= 100000)
-		value |= CS4245_ADC_FM_DOUBLE;
-	else
-		value |= CS4245_ADC_FM_QUAD;
-	cs4245_write_cached(chip, CS4245_ADC_CTRL, value);
+	unsigned char adc_ctrl;
+	unsigned char mclk_freq;
+
+	adc_ctrl = data->cs4245_shadow[CS4245_ADC_CTRL] & ~CS4245_ADC_FM_MASK;
+	mclk_freq = data->cs4245_shadow[CS4245_MCLK_FREQ] & ~CS4245_MCLK2_MASK;
+	if (params_rate(params) <= 50000) {
+		adc_ctrl |= CS4245_ADC_FM_SINGLE;
+		mclk_freq |= CS4245_MCLK_1 << CS4245_MCLK2_SHIFT;
+	} else if (params_rate(params) <= 100000) {
+		adc_ctrl |= CS4245_ADC_FM_DOUBLE;
+		mclk_freq |= CS4245_MCLK_1 << CS4245_MCLK2_SHIFT;
+	} else {
+		adc_ctrl |= CS4245_ADC_FM_QUAD;
+		mclk_freq |= CS4245_MCLK_2 << CS4245_MCLK2_SHIFT;
+	}
+	data->cs4245_shadow[CS4245_ADC_CTRL] = adc_ctrl;
+	data->cs4245_shadow[CS4245_MCLK_FREQ] = mclk_freq;
+	cs4245_write_spi(chip, CS4245_ADC_CTRL);
+	cs4245_write_spi(chip, CS4245_MCLK_FREQ);
 }
 
 static inline unsigned int shift_bits(unsigned int value,

commit 3c1611ddd1b67628bd946111edae8f5366a14edf
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:09 2014 +0400

    ALSA: oxygen: Xonar DG(X): modify initialization functions
    
    Change CS4245 initialization: different sequence and GPIO values,
    according to datasheets and reverse-engineering information.
    Change cleanup/resume/suspend functions, since they use
    initialization.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index 2518c611d5c5..4177fb131086 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -135,70 +135,49 @@ static void cs4245_write(struct oxygen *chip, unsigned int reg, u8 value)
 			 CS4245_SPI_ADDRESS_S |
 			 CS4245_SPI_WRITE_S |
 			 (reg << 8) | value);
-	data->cs4245_regs[reg] = value;
+	data->cs4245_shadow[reg] = value;
 }
 
 static void cs4245_write_cached(struct oxygen *chip, unsigned int reg, u8 value)
 {
 	struct dg *data = chip->model_data;
 
-	if (value != data->cs4245_regs[reg])
+	if (value != data->cs4245_shadow[reg])
 		cs4245_write(chip, reg, value);
 }
 
-static void cs4245_registers_init(struct oxygen *chip)
-{
-	struct dg *data = chip->model_data;
-
-	cs4245_write(chip, CS4245_POWER_CTRL, CS4245_PDN);
-	cs4245_write(chip, CS4245_DAC_CTRL_1,
-		     data->cs4245_regs[CS4245_DAC_CTRL_1]);
-	cs4245_write(chip, CS4245_ADC_CTRL,
-		     data->cs4245_regs[CS4245_ADC_CTRL]);
-	cs4245_write(chip, CS4245_SIGNAL_SEL,
-		     data->cs4245_regs[CS4245_SIGNAL_SEL]);
-	cs4245_write(chip, CS4245_PGA_B_CTRL,
-		     data->cs4245_regs[CS4245_PGA_B_CTRL]);
-	cs4245_write(chip, CS4245_PGA_A_CTRL,
-		     data->cs4245_regs[CS4245_PGA_A_CTRL]);
-	cs4245_write(chip, CS4245_ANALOG_IN,
-		     data->cs4245_regs[CS4245_ANALOG_IN]);
-	cs4245_write(chip, CS4245_DAC_A_CTRL,
-		     data->cs4245_regs[CS4245_DAC_A_CTRL]);
-	cs4245_write(chip, CS4245_DAC_B_CTRL,
-		     data->cs4245_regs[CS4245_DAC_B_CTRL]);
-	cs4245_write(chip, CS4245_DAC_CTRL_2,
-		     CS4245_DAC_SOFT | CS4245_DAC_ZERO | CS4245_INVERT_DAC);
-	cs4245_write(chip, CS4245_INT_MASK, 0);
-	cs4245_write(chip, CS4245_POWER_CTRL, 0);
-}
-
 static void cs4245_init(struct oxygen *chip)
 {
 	struct dg *data = chip->model_data;
 
-	data->cs4245_regs[CS4245_DAC_CTRL_1] =
+	/* save the initial state: codec version, registers */
+	cs4245_shadow_control(chip, CS4245_SAVE_TO_SHADOW);
+
+	/*
+	 * Power up the CODEC internals, enable soft ramp & zero cross, work in
+	 * async. mode, enable aux output from DAC. Invert DAC output as in the
+	 * Windows driver.
+	 */
+	data->cs4245_shadow[CS4245_POWER_CTRL] = 0;
+	data->cs4245_shadow[CS4245_SIGNAL_SEL] =
+		CS4245_A_OUT_SEL_DAC | CS4245_ASYNCH;
+	data->cs4245_shadow[CS4245_DAC_CTRL_1] =
 		CS4245_DAC_FM_SINGLE | CS4245_DAC_DIF_LJUST;
-	data->cs4245_regs[CS4245_ADC_CTRL] =
+	data->cs4245_shadow[CS4245_DAC_CTRL_2] =
+		CS4245_DAC_SOFT | CS4245_DAC_ZERO | CS4245_INVERT_DAC;
+	data->cs4245_shadow[CS4245_ADC_CTRL] =
 		CS4245_ADC_FM_SINGLE | CS4245_ADC_DIF_LJUST;
-	data->cs4245_regs[CS4245_SIGNAL_SEL] =
-		CS4245_A_OUT_SEL_HIZ | CS4245_ASYNCH;
-	data->cs4245_regs[CS4245_PGA_B_CTRL] = 0;
-	data->cs4245_regs[CS4245_PGA_A_CTRL] = 0;
-	data->cs4245_regs[CS4245_ANALOG_IN] =
-		CS4245_PGA_SOFT | CS4245_PGA_ZERO | CS4245_SEL_INPUT_4;
-	data->cs4245_regs[CS4245_DAC_A_CTRL] = 0;
-	data->cs4245_regs[CS4245_DAC_B_CTRL] = 0;
-	cs4245_registers_init(chip);
+	data->cs4245_shadow[CS4245_ANALOG_IN] =
+		CS4245_PGA_SOFT | CS4245_PGA_ZERO;
+	data->cs4245_shadow[CS4245_PGA_B_CTRL] = 0;
+	data->cs4245_shadow[CS4245_PGA_A_CTRL] = 0;
+	data->cs4245_shadow[CS4245_DAC_A_CTRL] = 4;
+	data->cs4245_shadow[CS4245_DAC_B_CTRL] = 4;
+
+	cs4245_shadow_control(chip, CS4245_LOAD_FROM_SHADOW);
 	snd_component_add(chip->card, "CS4245");
 }
 
-static void dg_output_enable(struct oxygen *chip)
-{
-	msleep(2500);
-	oxygen_set_bits16(chip, OXYGEN_GPIO_DATA, GPIO_OUTPUT_ENABLE);
-}
-
 static void dg_init(struct oxygen *chip)
 {
 	struct dg *data = chip->model_data;
@@ -208,14 +187,12 @@ static void dg_init(struct oxygen *chip)
 	data->hp_vol_att = 2 * 16;
 
 	cs4245_init(chip);
-
-	oxygen_clear_bits16(chip, OXYGEN_GPIO_CONTROL,
-			    GPIO_MAGIC | GPIO_HP_DETECT);
-	oxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,
-			  GPIO_INPUT_ROUTE | GPIO_HP_REAR | GPIO_OUTPUT_ENABLE);
-	oxygen_clear_bits16(chip, OXYGEN_GPIO_DATA,
-			    GPIO_INPUT_ROUTE | GPIO_HP_REAR);
-	dg_output_enable(chip);
+	oxygen_write16(chip, OXYGEN_GPIO_CONTROL,
+		       GPIO_OUTPUT_ENABLE | GPIO_HP_REAR | GPIO_INPUT_ROUTE);
+	oxygen_write16(chip, OXYGEN_GPIO_DATA, GPIO_INPUT_ROUTE);
+	msleep(2500); /* anti-pop delay */
+	oxygen_write16(chip, OXYGEN_GPIO_DATA,
+		       GPIO_OUTPUT_ENABLE | GPIO_INPUT_ROUTE);
 }
 
 static void dg_cleanup(struct oxygen *chip)
@@ -230,8 +207,9 @@ static void dg_suspend(struct oxygen *chip)
 
 static void dg_resume(struct oxygen *chip)
 {
-	cs4245_registers_init(chip);
-	dg_output_enable(chip);
+	cs4245_shadow_control(chip, CS4245_LOAD_FROM_SHADOW);
+	msleep(2500);
+	oxygen_set_bits16(chip, OXYGEN_GPIO_DATA, GPIO_OUTPUT_ENABLE);
 }
 
 static void set_cs4245_dac_params(struct oxygen *chip,
@@ -240,7 +218,7 @@ static void set_cs4245_dac_params(struct oxygen *chip,
 	struct dg *data = chip->model_data;
 	u8 value;
 
-	value = data->cs4245_regs[CS4245_DAC_CTRL_1] & ~CS4245_DAC_FM_MASK;
+	value = data->cs4245_shadow[CS4245_DAC_CTRL_1] & ~CS4245_DAC_FM_MASK;
 	if (params_rate(params) <= 50000)
 		value |= CS4245_DAC_FM_SINGLE;
 	else if (params_rate(params) <= 100000)
@@ -256,7 +234,7 @@ static void set_cs4245_adc_params(struct oxygen *chip,
 	struct dg *data = chip->model_data;
 	u8 value;
 
-	value = data->cs4245_regs[CS4245_ADC_CTRL] & ~CS4245_ADC_FM_MASK;
+	value = data->cs4245_shadow[CS4245_ADC_CTRL] & ~CS4245_ADC_FM_MASK;
 	if (params_rate(params) <= 50000)
 		value |= CS4245_ADC_FM_SINGLE;
 	else if (params_rate(params) <= 100000)
@@ -333,7 +311,7 @@ static int output_switch_put(struct snd_kcontrol *ctl,
 	if (changed) {
 		data->output_sel = value->value.enumerated.item[0];
 
-		reg = data->cs4245_regs[CS4245_SIGNAL_SEL] &
+		reg = data->cs4245_shadow[CS4245_SIGNAL_SEL] &
 						~CS4245_A_OUT_SEL_MASK;
 		reg |= data->output_sel == 2 ?
 				CS4245_A_OUT_SEL_DAC : CS4245_A_OUT_SEL_HIZ;
@@ -504,7 +482,7 @@ static int input_sel_put(struct snd_kcontrol *ctl,
 		data->input_sel = value->value.enumerated.item[0];
 
 		cs4245_write(chip, CS4245_ANALOG_IN,
-			     (data->cs4245_regs[CS4245_ANALOG_IN] &
+			     (data->cs4245_shadow[CS4245_ANALOG_IN] &
 							~CS4245_SEL_MASK) |
 			     sel_values[data->input_sel]);
 
@@ -534,7 +512,7 @@ static int hpf_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)
 	struct dg *data = chip->model_data;
 
 	value->value.enumerated.item[0] =
-		!!(data->cs4245_regs[CS4245_ADC_CTRL] & CS4245_HPF_FREEZE);
+		!!(data->cs4245_shadow[CS4245_ADC_CTRL] & CS4245_HPF_FREEZE);
 	return 0;
 }
 
@@ -546,10 +524,10 @@ static int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)
 	int changed;
 
 	mutex_lock(&chip->mutex);
-	reg = data->cs4245_regs[CS4245_ADC_CTRL] & ~CS4245_HPF_FREEZE;
+	reg = data->cs4245_shadow[CS4245_ADC_CTRL] & ~CS4245_HPF_FREEZE;
 	if (value->value.enumerated.item[0])
 		reg |= CS4245_HPF_FREEZE;
-	changed = reg != data->cs4245_regs[CS4245_ADC_CTRL];
+	changed = reg != data->cs4245_shadow[CS4245_ADC_CTRL];
 	if (changed)
 		cs4245_write(chip, CS4245_ADC_CTRL, reg);
 	mutex_unlock(&chip->mutex);
@@ -629,7 +607,7 @@ static void dump_cs4245_registers(struct oxygen *chip,
 
 	snd_iprintf(buffer, "\nCS4245:");
 	for (i = 1; i <= 0x10; ++i)
-		snd_iprintf(buffer, " %02x", data->cs4245_regs[i]);
+		snd_iprintf(buffer, " %02x", data->cs4245_shadow[i]);
 	snd_iprintf(buffer, "\n");
 }
 

commit bed61935cc5b70f84480dfd465c0e15a060c1f2c
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:08 2014 +0400

    ALSA: oxygen: Xonar DG(X): add new CS4245 SPI functions
    
    Add the new SPI write and read functions. The SPI read function
    is used for creating initial registers dump and may be used for
    debugging purposes. SPI operations are cached, so there is a new
    function to manage the cache (shadow). I have to remove
    the shift from the CS4245_SPI_* constants, since when
    we are performing the reading, we need to shift by 8 instead
    of 16.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index c175720f1c7a..2518c611d5c5 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -64,6 +64,65 @@
 #include "xonar_dg.h"
 #include "cs4245.h"
 
+int cs4245_write_spi(struct oxygen *chip, u8 reg)
+{
+	struct dg *data = chip->model_data;
+	unsigned int packet;
+
+	packet = reg << 8;
+	packet |= (CS4245_SPI_ADDRESS | CS4245_SPI_WRITE) << 16;
+	packet |= data->cs4245_shadow[reg];
+
+	return oxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |
+				OXYGEN_SPI_DATA_LENGTH_3 |
+				OXYGEN_SPI_CLOCK_1280 |
+				(0 << OXYGEN_SPI_CODEC_SHIFT) |
+				OXYGEN_SPI_CEN_LATCH_CLOCK_HI,
+				packet);
+}
+
+int cs4245_read_spi(struct oxygen *chip, u8 addr)
+{
+	struct dg *data = chip->model_data;
+	int ret;
+
+	ret = oxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |
+		OXYGEN_SPI_DATA_LENGTH_2 |
+		OXYGEN_SPI_CEN_LATCH_CLOCK_HI |
+		OXYGEN_SPI_CLOCK_1280 | (0 << OXYGEN_SPI_CODEC_SHIFT),
+		((CS4245_SPI_ADDRESS | CS4245_SPI_WRITE) << 8) | addr);
+	if (ret < 0)
+		return ret;
+
+	ret = oxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |
+		OXYGEN_SPI_DATA_LENGTH_2 |
+		OXYGEN_SPI_CEN_LATCH_CLOCK_HI |
+		OXYGEN_SPI_CLOCK_1280 | (0 << OXYGEN_SPI_CODEC_SHIFT),
+		(CS4245_SPI_ADDRESS | CS4245_SPI_READ) << 8);
+	if (ret < 0)
+		return ret;
+
+	data->cs4245_shadow[addr] = oxygen_read8(chip, OXYGEN_SPI_DATA1);
+
+	return 0;
+}
+
+int cs4245_shadow_control(struct oxygen *chip, enum cs4245_shadow_operation op)
+{
+	struct dg *data = chip->model_data;
+	unsigned char addr;
+	int ret;
+
+	for (addr = 1; addr < ARRAY_SIZE(data->cs4245_shadow); addr++) {
+		ret = (op == CS4245_SAVE_TO_SHADOW ?
+			cs4245_read_spi(chip, addr) :
+			cs4245_write_spi(chip, addr));
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
 static void cs4245_write(struct oxygen *chip, unsigned int reg, u8 value)
 {
 	struct dg *data = chip->model_data;
@@ -73,8 +132,8 @@ static void cs4245_write(struct oxygen *chip, unsigned int reg, u8 value)
 			 OXYGEN_SPI_CLOCK_1280 |
 			 (0 << OXYGEN_SPI_CODEC_SHIFT) |
 			 OXYGEN_SPI_CEN_LATCH_CLOCK_HI,
-			 CS4245_SPI_ADDRESS |
-			 CS4245_SPI_WRITE |
+			 CS4245_SPI_ADDRESS_S |
+			 CS4245_SPI_WRITE_S |
 			 (reg << 8) | value);
 	data->cs4245_regs[reg] = value;
 }

commit ddd624c332698eb3ee5293bca6b5b3a97d05c0b6
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:07 2014 +0400

    ALSA: oxygen: additional definitions for the Xonar DG/DGX card
    
    Add additional constants to the xonar_dg.h file:
    capture and playback sources. Move GPIO_* constants and the
    dg struct to the header file from the xonar_dg.c file.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index 7f5259e70a71..c175720f1c7a 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -64,20 +64,6 @@
 #include "xonar_dg.h"
 #include "cs4245.h"
 
-#define GPIO_MAGIC		0x0008
-#define GPIO_HP_DETECT		0x0010
-#define GPIO_INPUT_ROUTE	0x0060
-#define GPIO_HP_REAR		0x0080
-#define GPIO_OUTPUT_ENABLE	0x0100
-
-struct dg {
-	unsigned int output_sel;
-	s8 input_vol[4][2];
-	unsigned int input_sel;
-	u8 hp_vol_att;
-	u8 cs4245_regs[0x11];
-};
-
 static void cs4245_write(struct oxygen *chip, unsigned int reg, u8 value)
 {
 	struct dg *data = chip->model_data;

commit c4d4390c581603ec449c648df3be6b50281db8a3
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:06 2014 +0400

    ALSA: oxygen: change description of the xonar_dg.c file
    
    Add some additional information in comments and my copyright.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index 77acd790ea47..7f5259e70a71 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -2,7 +2,7 @@
  * card driver for the Xonar DG/DGX
  *
  * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
- *
+ * Copyright (c) Roman Volkov <v1ron@mail.ru>
  *
  *  This driver is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License, version 2.
@@ -20,27 +20,35 @@
  * Xonar DG/DGX
  * ------------
  *
+ * CS4245 and CS4361 both will mute all outputs if any clock ratio
+ * is invalid.
+ *
  * CMI8788:
  *
  *   SPI 0 -> CS4245
  *
+ *   Playback:
  *   I²S 1 -> CS4245
  *   I²S 2 -> CS4361 (center/LFE)
  *   I²S 3 -> CS4361 (surround)
  *   I²S 4 -> CS4361 (front)
+ *   Capture:
+ *   I²S ADC 1 <- CS4245
  *
  *   GPIO 3 <- ?
  *   GPIO 4 <- headphone detect
- *   GPIO 5 -> route input jack to line-in (0) or mic-in (1)
- *   GPIO 6 -> route input jack to line-in (0) or mic-in (1)
- *   GPIO 7 -> enable rear headphone amp
+ *   GPIO 5 -> enable ADC analog circuit for the left channel
+ *   GPIO 6 -> enable ADC analog circuit for the right channel
+ *   GPIO 7 -> switch green rear output jack between CS4245 and and the first
+ *             channel of CS4361 (mechanical relay)
  *   GPIO 8 -> enable output to speakers
  *
  * CS4245:
  *
+ *   input 0 <- mic
  *   input 1 <- aux
  *   input 2 <- front mic
- *   input 4 <- line/mic
+ *   input 4 <- line
  *   DAC out -> headphones
  *   aux out -> front panel headphones
  */

commit 76bc7a0d0a2a833d09fbf9d4e19a7985ef6e276b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue May 1 17:40:30 2012 +0200

    ALSA: oxygen: add Xonar DGX support
    
    Add the PCI ID of the Asus Xonar DGX card; it's otherwise
    identical with the DG.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index 793bdf03d7e0..77acd790ea47 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -1,5 +1,5 @@
 /*
- * card driver for the Xonar DG
+ * card driver for the Xonar DG/DGX
  *
  * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
  *
@@ -17,8 +17,8 @@
  */
 
 /*
- * Xonar DG
- * --------
+ * Xonar DG/DGX
+ * ------------
  *
  * CMI8788:
  *
@@ -581,7 +581,6 @@ static void dump_cs4245_registers(struct oxygen *chip,
 }
 
 struct oxygen_model model_xonar_dg = {
-	.shortname = "Xonar DG",
 	.longname = "C-Media Oxygen HD Audio",
 	.chip = "CMI8786",
 	.init = dg_init,

commit 56225e4cc88a24d3e1632bdfb901a3c38615fc42
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Dec 6 10:07:43 2011 +0100

    ALSA: virtuoso: add S/PDIF input support for all Xonars
    
    All Xonar cards support S/PDIF input, but the cards without optical or
    coaxial plugs have only undocumented pin connectors.  Support for the
    ST/STX was already added in a previous patch; this adds support for the
    D1/DX (JP2), DG (J5), DS (J5), and HDAV Slim (J12).
    
    Many thanks to Zoltan Miklos for testing the DS and DX.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index bc6eb58be380..793bdf03d7e0 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -597,7 +597,8 @@ struct oxygen_model model_xonar_dg = {
 	.model_data_size = sizeof(struct dg),
 	.device_config = PLAYBACK_0_TO_I2S |
 			 PLAYBACK_1_TO_SPDIF |
-			 CAPTURE_0_FROM_I2S_2,
+			 CAPTURE_0_FROM_I2S_2 |
+			 CAPTURE_1_FROM_SPDIF,
 	.dac_channels_pcm = 6,
 	.dac_channels_mixer = 0,
 	.function_flags = OXYGEN_FUNCTION_SPI,

commit efbeb0718126d277c9d7e902eec8da956acf4bd6
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jan 31 11:47:52 2011 +0100

    ALSA: oxygen: fix output routing on Xonar DG
    
    This card uses separate I2S outputs for the front speakers and
    headphones, and reverses the order of the three speaker outputs.
    To work around this, add a model-specific callback to adjust the
    controller's playback routing.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index e1fa602eba79..bc6eb58be380 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -24,6 +24,11 @@
  *
  *   SPI 0 -> CS4245
  *
+ *   I²S 1 -> CS4245
+ *   I²S 2 -> CS4361 (center/LFE)
+ *   I²S 3 -> CS4361 (surround)
+ *   I²S 4 -> CS4361 (front)
+ *
  *   GPIO 3 <- ?
  *   GPIO 4 <- headphone detect
  *   GPIO 5 -> route input jack to line-in (0) or mic-in (1)
@@ -36,6 +41,7 @@
  *   input 1 <- aux
  *   input 2 <- front mic
  *   input 4 <- line/mic
+ *   DAC out -> headphones
  *   aux out -> front panel headphones
  */
 
@@ -207,6 +213,35 @@ static void set_cs4245_adc_params(struct oxygen *chip,
 	cs4245_write_cached(chip, CS4245_ADC_CTRL, value);
 }
 
+static inline unsigned int shift_bits(unsigned int value,
+				      unsigned int shift_from,
+				      unsigned int shift_to,
+				      unsigned int mask)
+{
+	if (shift_from < shift_to)
+		return (value << (shift_to - shift_from)) & mask;
+	else
+		return (value >> (shift_from - shift_to)) & mask;
+}
+
+static unsigned int adjust_dg_dac_routing(struct oxygen *chip,
+					  unsigned int play_routing)
+{
+	return (play_routing & OXYGEN_PLAY_DAC0_SOURCE_MASK) |
+	       shift_bits(play_routing,
+			  OXYGEN_PLAY_DAC2_SOURCE_SHIFT,
+			  OXYGEN_PLAY_DAC1_SOURCE_SHIFT,
+			  OXYGEN_PLAY_DAC1_SOURCE_MASK) |
+	       shift_bits(play_routing,
+			  OXYGEN_PLAY_DAC1_SOURCE_SHIFT,
+			  OXYGEN_PLAY_DAC2_SOURCE_SHIFT,
+			  OXYGEN_PLAY_DAC2_SOURCE_MASK) |
+	       shift_bits(play_routing,
+			  OXYGEN_PLAY_DAC0_SOURCE_SHIFT,
+			  OXYGEN_PLAY_DAC3_SOURCE_SHIFT,
+			  OXYGEN_PLAY_DAC3_SOURCE_MASK);
+}
+
 static int output_switch_info(struct snd_kcontrol *ctl,
 			      struct snd_ctl_elem_info *info)
 {
@@ -557,6 +592,7 @@ struct oxygen_model model_xonar_dg = {
 	.resume = dg_resume,
 	.set_dac_params = set_cs4245_dac_params,
 	.set_adc_params = set_cs4245_adc_params,
+	.adjust_dac_routing = adjust_dg_dac_routing,
 	.dump_registers = dump_cs4245_registers,
 	.model_data_size = sizeof(struct dg),
 	.device_config = PLAYBACK_0_TO_I2S |

commit f8fe80e4383bf5f542beb80bf2abe9fc1505c366
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Jan 14 08:07:50 2011 +0100

    ALSA: oxygen: Xonar DG: fix CS4245 register writes
    
    Accidentally exchanging register addresses and register values leads to
    many strange errors ...
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index e4de0b8d087a..e1fa602eba79 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -75,7 +75,7 @@ static void cs4245_write(struct oxygen *chip, unsigned int reg, u8 value)
 			 OXYGEN_SPI_CEN_LATCH_CLOCK_HI,
 			 CS4245_SPI_ADDRESS |
 			 CS4245_SPI_WRITE |
-			 (value << 8) | reg);
+			 (reg << 8) | value);
 	data->cs4245_regs[reg] = value;
 }
 

commit c386735264da97e6b6d15aa56361e9ef188b26ab
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Jan 12 08:30:12 2011 +0100

    ALSA: oxygen: fix Xonar DG input
    
    Apparently, this card uses the other I2S input.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index dd45cf4d9eb9..e4de0b8d087a 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -561,7 +561,7 @@ struct oxygen_model model_xonar_dg = {
 	.model_data_size = sizeof(struct dg),
 	.device_config = PLAYBACK_0_TO_I2S |
 			 PLAYBACK_1_TO_SPDIF |
-			 CAPTURE_0_FROM_I2S_1,
+			 CAPTURE_0_FROM_I2S_2,
 	.dac_channels_pcm = 6,
 	.dac_channels_mixer = 0,
 	.function_flags = OXYGEN_FUNCTION_SPI,

commit e92d457514c957f293c4706a06a25833061d9b88
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Jan 11 13:20:30 2011 +1100

    ALSA: include delay.h for msleep in Xonar DG support
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index cc610ac1fc19..dd45cf4d9eb9 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -40,6 +40,7 @@
  */
 
 #include <linux/pci.h>
+#include <linux/delay.h>
 #include <sound/control.h>
 #include <sound/core.h>
 #include <sound/info.h>

commit 9600732b6caba595f34acf2abd930098ec9a0b2b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jan 10 16:25:44 2011 +0100

    ALSA: core, oxygen, virtuoso: add an enum control info helper
    
    Introduce the helper function snd_ctl_enum_info() to fill out the
    elem_info fields for an enumerated control.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
index 7ed3284d7d5b..cc610ac1fc19 100644
--- a/sound/pci/oxygen/xonar_dg.c
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -213,13 +213,7 @@ static int output_switch_info(struct snd_kcontrol *ctl,
 		"Speakers", "Headphones", "FP Headphones"
 	};
 
-	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	info->count = 1;
-	info->value.enumerated.items = 3;
-	if (info->value.enumerated.item >= 3)
-		info->value.enumerated.item = 2;
-	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(info, 1, 3, names);
 }
 
 static int output_switch_get(struct snd_kcontrol *ctl,
@@ -276,13 +270,7 @@ static int hp_volume_offset_info(struct snd_kcontrol *ctl,
 		"< 64 ohms", "64-150 ohms", "150-300 ohms"
 	};
 
-	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	info->count = 1;
-	info->value.enumerated.items = 3;
-	if (info->value.enumerated.item >= 3)
-		info->value.enumerated.item = 2;
-	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(info, 1, 3, names);
 }
 
 static int hp_volume_offset_get(struct snd_kcontrol *ctl,
@@ -390,12 +378,7 @@ static int input_sel_info(struct snd_kcontrol *ctl,
 		"Mic", "Aux", "Front Mic", "Line"
 	};
 
-	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	info->count = 1;
-	info->value.enumerated.items = 4;
-	info->value.enumerated.item &= 3;
-	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(info, 1, 4, names);
 }
 
 static int input_sel_get(struct snd_kcontrol *ctl,
@@ -453,12 +436,7 @@ static int hpf_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)
 {
 	static const char *const names[2] = { "Active", "Frozen" };
 
-	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	info->count = 1;
-	info->value.enumerated.items = 2;
-	info->value.enumerated.item &= 1;
-	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
-	return 0;
+	return snd_ctl_enum_info(info, 1, 2, names);
 }
 
 static int hpf_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)

commit 66410bfdf14f7c2ad3b2d4a8adeab41d368b6f05
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jan 10 16:20:29 2011 +0100

    ALSA: oxygen: add Xonar DG support
    
    Add experimental support for the Asus Xonar DG sound card.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_dg.c b/sound/pci/oxygen/xonar_dg.c
new file mode 100644
index 000000000000..7ed3284d7d5b
--- /dev/null
+++ b/sound/pci/oxygen/xonar_dg.c
@@ -0,0 +1,593 @@
+/*
+ * card driver for the Xonar DG
+ *
+ * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
+ *
+ *
+ *  This driver is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, version 2.
+ *
+ *  This driver is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this driver; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Xonar DG
+ * --------
+ *
+ * CMI8788:
+ *
+ *   SPI 0 -> CS4245
+ *
+ *   GPIO 3 <- ?
+ *   GPIO 4 <- headphone detect
+ *   GPIO 5 -> route input jack to line-in (0) or mic-in (1)
+ *   GPIO 6 -> route input jack to line-in (0) or mic-in (1)
+ *   GPIO 7 -> enable rear headphone amp
+ *   GPIO 8 -> enable output to speakers
+ *
+ * CS4245:
+ *
+ *   input 1 <- aux
+ *   input 2 <- front mic
+ *   input 4 <- line/mic
+ *   aux out -> front panel headphones
+ */
+
+#include <linux/pci.h>
+#include <sound/control.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/pcm.h>
+#include <sound/tlv.h>
+#include "oxygen.h"
+#include "xonar_dg.h"
+#include "cs4245.h"
+
+#define GPIO_MAGIC		0x0008
+#define GPIO_HP_DETECT		0x0010
+#define GPIO_INPUT_ROUTE	0x0060
+#define GPIO_HP_REAR		0x0080
+#define GPIO_OUTPUT_ENABLE	0x0100
+
+struct dg {
+	unsigned int output_sel;
+	s8 input_vol[4][2];
+	unsigned int input_sel;
+	u8 hp_vol_att;
+	u8 cs4245_regs[0x11];
+};
+
+static void cs4245_write(struct oxygen *chip, unsigned int reg, u8 value)
+{
+	struct dg *data = chip->model_data;
+
+	oxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |
+			 OXYGEN_SPI_DATA_LENGTH_3 |
+			 OXYGEN_SPI_CLOCK_1280 |
+			 (0 << OXYGEN_SPI_CODEC_SHIFT) |
+			 OXYGEN_SPI_CEN_LATCH_CLOCK_HI,
+			 CS4245_SPI_ADDRESS |
+			 CS4245_SPI_WRITE |
+			 (value << 8) | reg);
+	data->cs4245_regs[reg] = value;
+}
+
+static void cs4245_write_cached(struct oxygen *chip, unsigned int reg, u8 value)
+{
+	struct dg *data = chip->model_data;
+
+	if (value != data->cs4245_regs[reg])
+		cs4245_write(chip, reg, value);
+}
+
+static void cs4245_registers_init(struct oxygen *chip)
+{
+	struct dg *data = chip->model_data;
+
+	cs4245_write(chip, CS4245_POWER_CTRL, CS4245_PDN);
+	cs4245_write(chip, CS4245_DAC_CTRL_1,
+		     data->cs4245_regs[CS4245_DAC_CTRL_1]);
+	cs4245_write(chip, CS4245_ADC_CTRL,
+		     data->cs4245_regs[CS4245_ADC_CTRL]);
+	cs4245_write(chip, CS4245_SIGNAL_SEL,
+		     data->cs4245_regs[CS4245_SIGNAL_SEL]);
+	cs4245_write(chip, CS4245_PGA_B_CTRL,
+		     data->cs4245_regs[CS4245_PGA_B_CTRL]);
+	cs4245_write(chip, CS4245_PGA_A_CTRL,
+		     data->cs4245_regs[CS4245_PGA_A_CTRL]);
+	cs4245_write(chip, CS4245_ANALOG_IN,
+		     data->cs4245_regs[CS4245_ANALOG_IN]);
+	cs4245_write(chip, CS4245_DAC_A_CTRL,
+		     data->cs4245_regs[CS4245_DAC_A_CTRL]);
+	cs4245_write(chip, CS4245_DAC_B_CTRL,
+		     data->cs4245_regs[CS4245_DAC_B_CTRL]);
+	cs4245_write(chip, CS4245_DAC_CTRL_2,
+		     CS4245_DAC_SOFT | CS4245_DAC_ZERO | CS4245_INVERT_DAC);
+	cs4245_write(chip, CS4245_INT_MASK, 0);
+	cs4245_write(chip, CS4245_POWER_CTRL, 0);
+}
+
+static void cs4245_init(struct oxygen *chip)
+{
+	struct dg *data = chip->model_data;
+
+	data->cs4245_regs[CS4245_DAC_CTRL_1] =
+		CS4245_DAC_FM_SINGLE | CS4245_DAC_DIF_LJUST;
+	data->cs4245_regs[CS4245_ADC_CTRL] =
+		CS4245_ADC_FM_SINGLE | CS4245_ADC_DIF_LJUST;
+	data->cs4245_regs[CS4245_SIGNAL_SEL] =
+		CS4245_A_OUT_SEL_HIZ | CS4245_ASYNCH;
+	data->cs4245_regs[CS4245_PGA_B_CTRL] = 0;
+	data->cs4245_regs[CS4245_PGA_A_CTRL] = 0;
+	data->cs4245_regs[CS4245_ANALOG_IN] =
+		CS4245_PGA_SOFT | CS4245_PGA_ZERO | CS4245_SEL_INPUT_4;
+	data->cs4245_regs[CS4245_DAC_A_CTRL] = 0;
+	data->cs4245_regs[CS4245_DAC_B_CTRL] = 0;
+	cs4245_registers_init(chip);
+	snd_component_add(chip->card, "CS4245");
+}
+
+static void dg_output_enable(struct oxygen *chip)
+{
+	msleep(2500);
+	oxygen_set_bits16(chip, OXYGEN_GPIO_DATA, GPIO_OUTPUT_ENABLE);
+}
+
+static void dg_init(struct oxygen *chip)
+{
+	struct dg *data = chip->model_data;
+
+	data->output_sel = 0;
+	data->input_sel = 3;
+	data->hp_vol_att = 2 * 16;
+
+	cs4245_init(chip);
+
+	oxygen_clear_bits16(chip, OXYGEN_GPIO_CONTROL,
+			    GPIO_MAGIC | GPIO_HP_DETECT);
+	oxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,
+			  GPIO_INPUT_ROUTE | GPIO_HP_REAR | GPIO_OUTPUT_ENABLE);
+	oxygen_clear_bits16(chip, OXYGEN_GPIO_DATA,
+			    GPIO_INPUT_ROUTE | GPIO_HP_REAR);
+	dg_output_enable(chip);
+}
+
+static void dg_cleanup(struct oxygen *chip)
+{
+	oxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_OUTPUT_ENABLE);
+}
+
+static void dg_suspend(struct oxygen *chip)
+{
+	dg_cleanup(chip);
+}
+
+static void dg_resume(struct oxygen *chip)
+{
+	cs4245_registers_init(chip);
+	dg_output_enable(chip);
+}
+
+static void set_cs4245_dac_params(struct oxygen *chip,
+				  struct snd_pcm_hw_params *params)
+{
+	struct dg *data = chip->model_data;
+	u8 value;
+
+	value = data->cs4245_regs[CS4245_DAC_CTRL_1] & ~CS4245_DAC_FM_MASK;
+	if (params_rate(params) <= 50000)
+		value |= CS4245_DAC_FM_SINGLE;
+	else if (params_rate(params) <= 100000)
+		value |= CS4245_DAC_FM_DOUBLE;
+	else
+		value |= CS4245_DAC_FM_QUAD;
+	cs4245_write_cached(chip, CS4245_DAC_CTRL_1, value);
+}
+
+static void set_cs4245_adc_params(struct oxygen *chip,
+				  struct snd_pcm_hw_params *params)
+{
+	struct dg *data = chip->model_data;
+	u8 value;
+
+	value = data->cs4245_regs[CS4245_ADC_CTRL] & ~CS4245_ADC_FM_MASK;
+	if (params_rate(params) <= 50000)
+		value |= CS4245_ADC_FM_SINGLE;
+	else if (params_rate(params) <= 100000)
+		value |= CS4245_ADC_FM_DOUBLE;
+	else
+		value |= CS4245_ADC_FM_QUAD;
+	cs4245_write_cached(chip, CS4245_ADC_CTRL, value);
+}
+
+static int output_switch_info(struct snd_kcontrol *ctl,
+			      struct snd_ctl_elem_info *info)
+{
+	static const char *const names[3] = {
+		"Speakers", "Headphones", "FP Headphones"
+	};
+
+	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	info->count = 1;
+	info->value.enumerated.items = 3;
+	if (info->value.enumerated.item >= 3)
+		info->value.enumerated.item = 2;
+	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
+	return 0;
+}
+
+static int output_switch_get(struct snd_kcontrol *ctl,
+			     struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+
+	mutex_lock(&chip->mutex);
+	value->value.enumerated.item[0] = data->output_sel;
+	mutex_unlock(&chip->mutex);
+	return 0;
+}
+
+static int output_switch_put(struct snd_kcontrol *ctl,
+			     struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+	u8 reg;
+	int changed;
+
+	if (value->value.enumerated.item[0] > 2)
+		return -EINVAL;
+
+	mutex_lock(&chip->mutex);
+	changed = value->value.enumerated.item[0] != data->output_sel;
+	if (changed) {
+		data->output_sel = value->value.enumerated.item[0];
+
+		reg = data->cs4245_regs[CS4245_SIGNAL_SEL] &
+						~CS4245_A_OUT_SEL_MASK;
+		reg |= data->output_sel == 2 ?
+				CS4245_A_OUT_SEL_DAC : CS4245_A_OUT_SEL_HIZ;
+		cs4245_write_cached(chip, CS4245_SIGNAL_SEL, reg);
+
+		cs4245_write_cached(chip, CS4245_DAC_A_CTRL,
+				    data->output_sel ? data->hp_vol_att : 0);
+		cs4245_write_cached(chip, CS4245_DAC_B_CTRL,
+				    data->output_sel ? data->hp_vol_att : 0);
+
+		oxygen_write16_masked(chip, OXYGEN_GPIO_DATA,
+				      data->output_sel == 1 ? GPIO_HP_REAR : 0,
+				      GPIO_HP_REAR);
+	}
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+static int hp_volume_offset_info(struct snd_kcontrol *ctl,
+				 struct snd_ctl_elem_info *info)
+{
+	static const char *const names[3] = {
+		"< 64 ohms", "64-150 ohms", "150-300 ohms"
+	};
+
+	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	info->count = 1;
+	info->value.enumerated.items = 3;
+	if (info->value.enumerated.item >= 3)
+		info->value.enumerated.item = 2;
+	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
+	return 0;
+}
+
+static int hp_volume_offset_get(struct snd_kcontrol *ctl,
+				struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+
+	mutex_lock(&chip->mutex);
+	if (data->hp_vol_att > 2 * 7)
+		value->value.enumerated.item[0] = 0;
+	else if (data->hp_vol_att > 0)
+		value->value.enumerated.item[0] = 1;
+	else
+		value->value.enumerated.item[0] = 2;
+	mutex_unlock(&chip->mutex);
+	return 0;
+}
+
+static int hp_volume_offset_put(struct snd_kcontrol *ctl,
+				struct snd_ctl_elem_value *value)
+{
+	static const s8 atts[3] = { 2 * 16, 2 * 7, 0 };
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+	s8 att;
+	int changed;
+
+	if (value->value.enumerated.item[0] > 2)
+		return -EINVAL;
+	att = atts[value->value.enumerated.item[0]];
+	mutex_lock(&chip->mutex);
+	changed = att != data->hp_vol_att;
+	if (changed) {
+		data->hp_vol_att = att;
+		if (data->output_sel) {
+			cs4245_write_cached(chip, CS4245_DAC_A_CTRL, att);
+			cs4245_write_cached(chip, CS4245_DAC_B_CTRL, att);
+		}
+	}
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+static int input_vol_info(struct snd_kcontrol *ctl,
+			  struct snd_ctl_elem_info *info)
+{
+	info->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	info->count = 2;
+	info->value.integer.min = 2 * -12;
+	info->value.integer.max = 2 * 12;
+	return 0;
+}
+
+static int input_vol_get(struct snd_kcontrol *ctl,
+			 struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+	unsigned int idx = ctl->private_value;
+
+	mutex_lock(&chip->mutex);
+	value->value.integer.value[0] = data->input_vol[idx][0];
+	value->value.integer.value[1] = data->input_vol[idx][1];
+	mutex_unlock(&chip->mutex);
+	return 0;
+}
+
+static int input_vol_put(struct snd_kcontrol *ctl,
+			 struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+	unsigned int idx = ctl->private_value;
+	int changed = 0;
+
+	if (value->value.integer.value[0] < 2 * -12 ||
+	    value->value.integer.value[0] > 2 * 12 ||
+	    value->value.integer.value[1] < 2 * -12 ||
+	    value->value.integer.value[1] > 2 * 12)
+		return -EINVAL;
+	mutex_lock(&chip->mutex);
+	changed = data->input_vol[idx][0] != value->value.integer.value[0] ||
+		  data->input_vol[idx][1] != value->value.integer.value[1];
+	if (changed) {
+		data->input_vol[idx][0] = value->value.integer.value[0];
+		data->input_vol[idx][1] = value->value.integer.value[1];
+		if (idx == data->input_sel) {
+			cs4245_write_cached(chip, CS4245_PGA_A_CTRL,
+					    data->input_vol[idx][0]);
+			cs4245_write_cached(chip, CS4245_PGA_B_CTRL,
+					    data->input_vol[idx][1]);
+		}
+	}
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+static DECLARE_TLV_DB_SCALE(cs4245_pga_db_scale, -1200, 50, 0);
+
+static int input_sel_info(struct snd_kcontrol *ctl,
+			  struct snd_ctl_elem_info *info)
+{
+	static const char *const names[4] = {
+		"Mic", "Aux", "Front Mic", "Line"
+	};
+
+	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	info->count = 1;
+	info->value.enumerated.items = 4;
+	info->value.enumerated.item &= 3;
+	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
+	return 0;
+}
+
+static int input_sel_get(struct snd_kcontrol *ctl,
+			 struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+
+	mutex_lock(&chip->mutex);
+	value->value.enumerated.item[0] = data->input_sel;
+	mutex_unlock(&chip->mutex);
+	return 0;
+}
+
+static int input_sel_put(struct snd_kcontrol *ctl,
+			 struct snd_ctl_elem_value *value)
+{
+	static const u8 sel_values[4] = {
+		CS4245_SEL_MIC,
+		CS4245_SEL_INPUT_1,
+		CS4245_SEL_INPUT_2,
+		CS4245_SEL_INPUT_4
+	};
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+	int changed;
+
+	if (value->value.enumerated.item[0] > 3)
+		return -EINVAL;
+
+	mutex_lock(&chip->mutex);
+	changed = value->value.enumerated.item[0] != data->input_sel;
+	if (changed) {
+		data->input_sel = value->value.enumerated.item[0];
+
+		cs4245_write(chip, CS4245_ANALOG_IN,
+			     (data->cs4245_regs[CS4245_ANALOG_IN] &
+							~CS4245_SEL_MASK) |
+			     sel_values[data->input_sel]);
+
+		cs4245_write_cached(chip, CS4245_PGA_A_CTRL,
+				    data->input_vol[data->input_sel][0]);
+		cs4245_write_cached(chip, CS4245_PGA_B_CTRL,
+				    data->input_vol[data->input_sel][1]);
+
+		oxygen_write16_masked(chip, OXYGEN_GPIO_DATA,
+				      data->input_sel ? 0 : GPIO_INPUT_ROUTE,
+				      GPIO_INPUT_ROUTE);
+	}
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+static int hpf_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)
+{
+	static const char *const names[2] = { "Active", "Frozen" };
+
+	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	info->count = 1;
+	info->value.enumerated.items = 2;
+	info->value.enumerated.item &= 1;
+	strcpy(info->value.enumerated.name, names[info->value.enumerated.item]);
+	return 0;
+}
+
+static int hpf_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+
+	value->value.enumerated.item[0] =
+		!!(data->cs4245_regs[CS4245_ADC_CTRL] & CS4245_HPF_FREEZE);
+	return 0;
+}
+
+static int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+	u8 reg;
+	int changed;
+
+	mutex_lock(&chip->mutex);
+	reg = data->cs4245_regs[CS4245_ADC_CTRL] & ~CS4245_HPF_FREEZE;
+	if (value->value.enumerated.item[0])
+		reg |= CS4245_HPF_FREEZE;
+	changed = reg != data->cs4245_regs[CS4245_ADC_CTRL];
+	if (changed)
+		cs4245_write(chip, CS4245_ADC_CTRL, reg);
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+#define INPUT_VOLUME(xname, index) { \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.info = input_vol_info, \
+	.get = input_vol_get, \
+	.put = input_vol_put, \
+	.tlv = { .p = cs4245_pga_db_scale }, \
+	.private_value = index, \
+}
+static const struct snd_kcontrol_new dg_controls[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Analog Output Playback Enum",
+		.info = output_switch_info,
+		.get = output_switch_get,
+		.put = output_switch_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Headphones Impedance Playback Enum",
+		.info = hp_volume_offset_info,
+		.get = hp_volume_offset_get,
+		.put = hp_volume_offset_put,
+	},
+	INPUT_VOLUME("Mic Capture Volume", 0),
+	INPUT_VOLUME("Aux Capture Volume", 1),
+	INPUT_VOLUME("Front Mic Capture Volume", 2),
+	INPUT_VOLUME("Line Capture Volume", 3),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Capture Source",
+		.info = input_sel_info,
+		.get = input_sel_get,
+		.put = input_sel_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "ADC High-pass Filter Capture Enum",
+		.info = hpf_info,
+		.get = hpf_get,
+		.put = hpf_put,
+	},
+};
+
+static int dg_control_filter(struct snd_kcontrol_new *template)
+{
+	if (!strncmp(template->name, "Master Playback ", 16))
+		return 1;
+	return 0;
+}
+
+static int dg_mixer_init(struct oxygen *chip)
+{
+	unsigned int i;
+	int err;
+
+	for (i = 0; i < ARRAY_SIZE(dg_controls); ++i) {
+		err = snd_ctl_add(chip->card,
+				  snd_ctl_new1(&dg_controls[i], chip));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+static void dump_cs4245_registers(struct oxygen *chip,
+				  struct snd_info_buffer *buffer)
+{
+	struct dg *data = chip->model_data;
+	unsigned int i;
+
+	snd_iprintf(buffer, "\nCS4245:");
+	for (i = 1; i <= 0x10; ++i)
+		snd_iprintf(buffer, " %02x", data->cs4245_regs[i]);
+	snd_iprintf(buffer, "\n");
+}
+
+struct oxygen_model model_xonar_dg = {
+	.shortname = "Xonar DG",
+	.longname = "C-Media Oxygen HD Audio",
+	.chip = "CMI8786",
+	.init = dg_init,
+	.control_filter = dg_control_filter,
+	.mixer_init = dg_mixer_init,
+	.cleanup = dg_cleanup,
+	.suspend = dg_suspend,
+	.resume = dg_resume,
+	.set_dac_params = set_cs4245_dac_params,
+	.set_adc_params = set_cs4245_adc_params,
+	.dump_registers = dump_cs4245_registers,
+	.model_data_size = sizeof(struct dg),
+	.device_config = PLAYBACK_0_TO_I2S |
+			 PLAYBACK_1_TO_SPDIF |
+			 CAPTURE_0_FROM_I2S_1,
+	.dac_channels_pcm = 6,
+	.dac_channels_mixer = 0,
+	.function_flags = OXYGEN_FUNCTION_SPI,
+	.dac_mclks = OXYGEN_MCLKS(256, 128, 128),
+	.adc_mclks = OXYGEN_MCLKS(256, 128, 128),
+	.dac_i2s_format = OXYGEN_I2S_FORMAT_LJUST,
+	.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,
+};
