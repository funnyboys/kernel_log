commit b67eb1520b39f7b56c17d452040f5371fb1104dc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:12:38 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 264
    
    Based on 1 normalized pattern(s):
    
      this driver is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 this
      driver is distributed in the hope that it will be useful but without
      any warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this driver if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 9 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141333.769845457@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/oxygen/xonar_dg_mixer.c b/sound/pci/oxygen/xonar_dg_mixer.c
index d22fbe8aebd0..198588562880 100644
--- a/sound/pci/oxygen/xonar_dg_mixer.c
+++ b/sound/pci/oxygen/xonar_dg_mixer.c
@@ -1,19 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Mixer controls for the Xonar DG/DGX
  *
  * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
  * Copyright (c) Roman Volkov <v1ron@mail.ru>
- *
- *  This driver is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License, version 2.
- *
- *  This driver is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this driver; if not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/pci.h>

commit 621c51be8ed17b2d56847a09aa651087ca1d218a
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Thu Sep 14 19:34:15 2017 +0530

    ALSA: oxygen: Xonar DG(X): make model_xonar_dg const
    
    Make this const as it not modified anywhere. It is only used during a
    copy operation. Also, add const to the declaration in header.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/oxygen/xonar_dg_mixer.c b/sound/pci/oxygen/xonar_dg_mixer.c
index b885dac28a09..d22fbe8aebd0 100644
--- a/sound/pci/oxygen/xonar_dg_mixer.c
+++ b/sound/pci/oxygen/xonar_dg_mixer.c
@@ -449,7 +449,7 @@ static int dg_mixer_init(struct oxygen *chip)
 	return 0;
 }
 
-struct oxygen_model model_xonar_dg = {
+const struct oxygen_model model_xonar_dg = {
 	.longname = "C-Media Oxygen HD Audio",
 	.chip = "CMI8786",
 	.init = dg_init,

commit 3f49a66f6ceff1c87b49858644771c17763902ab
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:20 2014 +0400

    ALSA: oxygen: Xonar DG(X): cleanup and minor changes
    
    Remove old SPI control functions, change anti-pop init
    sequence, remove some garbage from structures. The 'Apply' functions
    must be called at the mixer initialization, otherwise
    mixer settings sometimes will not be applied at startup.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg_mixer.c b/sound/pci/oxygen/xonar_dg_mixer.c
index dfdfc991f8e6..b885dac28a09 100644
--- a/sound/pci/oxygen/xonar_dg_mixer.c
+++ b/sound/pci/oxygen/xonar_dg_mixer.c
@@ -435,12 +435,17 @@ static int dg_mixer_init(struct oxygen *chip)
 	unsigned int i;
 	int err;
 
+	output_select_apply(chip);
+	input_source_apply(chip);
+	oxygen_update_dac_routing(chip);
+
 	for (i = 0; i < ARRAY_SIZE(dg_controls); ++i) {
 		err = snd_ctl_add(chip->card,
 				  snd_ctl_new1(&dg_controls[i], chip));
 		if (err < 0)
 			return err;
 	}
+
 	return 0;
 }
 

commit fc114e9fbaf555e2d7fbfe144dac716142e22331
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:19 2014 +0400

    ALSA: oxygen: Xonar DG(X): modify high-pass filter control
    
    Change the 'put' function of the high-pass filter control to use the new
    SPI functions.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg_mixer.c b/sound/pci/oxygen/xonar_dg_mixer.c
index 41ee39359bd6..dfdfc991f8e6 100644
--- a/sound/pci/oxygen/xonar_dg_mixer.c
+++ b/sound/pci/oxygen/xonar_dg_mixer.c
@@ -325,6 +325,8 @@ static int input_sel_put(struct snd_kcontrol *ctl,
 	return changed;
 }
 
+/* ADC high-pass filter */
+
 static int hpf_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)
 {
 	static const char *const names[2] = { "Active", "Frozen" };
@@ -354,8 +356,10 @@ static int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)
 	if (value->value.enumerated.item[0])
 		reg |= CS4245_HPF_FREEZE;
 	changed = reg != data->cs4245_shadow[CS4245_ADC_CTRL];
-	if (changed)
-		cs4245_write(chip, CS4245_ADC_CTRL, reg);
+	if (changed) {
+		data->cs4245_shadow[CS4245_ADC_CTRL] = reg;
+		cs4245_write_spi(chip, CS4245_ADC_CTRL);
+	}
 	mutex_unlock(&chip->mutex);
 	return changed;
 }

commit 70e0d82d5e5d65e96f56ced3de97221fdf62cf38
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:18 2014 +0400

    ALSA: oxygen: Xonar DG(X): modify input select functions
    
    First of all, we should not touch the GPIOs. They are not
    for selecting the capture source, but they seems just enable
    the whole audio input curcuit. The 'put' function calls the
    'apply' functions to change register values. Change the order
    of capture sources.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg_mixer.c b/sound/pci/oxygen/xonar_dg_mixer.c
index 2417a1efd719..41ee39359bd6 100644
--- a/sound/pci/oxygen/xonar_dg_mixer.c
+++ b/sound/pci/oxygen/xonar_dg_mixer.c
@@ -260,11 +260,27 @@ static int input_vol_put(struct snd_kcontrol *ctl,
 	return changed;
 }
 
+/* Capture Source */
+
+static int input_source_apply(struct oxygen *chip)
+{
+	struct dg *data = chip->model_data;
+
+	data->cs4245_shadow[CS4245_ANALOG_IN] &= ~CS4245_SEL_MASK;
+	if (data->input_sel == CAPTURE_SRC_FP_MIC)
+		data->cs4245_shadow[CS4245_ANALOG_IN] |= CS4245_SEL_INPUT_2;
+	else if (data->input_sel == CAPTURE_SRC_LINE)
+		data->cs4245_shadow[CS4245_ANALOG_IN] |= CS4245_SEL_INPUT_4;
+	else if (data->input_sel != CAPTURE_SRC_MIC)
+		data->cs4245_shadow[CS4245_ANALOG_IN] |= CS4245_SEL_INPUT_1;
+	return cs4245_write_spi(chip, CS4245_ANALOG_IN);
+}
+
 static int input_sel_info(struct snd_kcontrol *ctl,
 			  struct snd_ctl_elem_info *info)
 {
 	static const char *const names[4] = {
-		"Mic", "Aux", "Front Mic", "Line"
+		"Mic", "Front Mic", "Line", "Aux"
 	};
 
 	return snd_ctl_enum_info(info, 1, 4, names);
@@ -285,15 +301,10 @@ static int input_sel_get(struct snd_kcontrol *ctl,
 static int input_sel_put(struct snd_kcontrol *ctl,
 			 struct snd_ctl_elem_value *value)
 {
-	static const u8 sel_values[4] = {
-		CS4245_SEL_MIC,
-		CS4245_SEL_INPUT_1,
-		CS4245_SEL_INPUT_2,
-		CS4245_SEL_INPUT_4
-	};
 	struct oxygen *chip = ctl->private_data;
 	struct dg *data = chip->model_data;
 	int changed;
+	int ret;
 
 	if (value->value.enumerated.item[0] > 3)
 		return -EINVAL;
@@ -303,19 +314,12 @@ static int input_sel_put(struct snd_kcontrol *ctl,
 	if (changed) {
 		data->input_sel = value->value.enumerated.item[0];
 
-		cs4245_write(chip, CS4245_ANALOG_IN,
-			     (data->cs4245_shadow[CS4245_ANALOG_IN] &
-							~CS4245_SEL_MASK) |
-			     sel_values[data->input_sel]);
-
-		cs4245_write_cached(chip, CS4245_PGA_A_CTRL,
-				    data->input_vol[data->input_sel][0]);
-		cs4245_write_cached(chip, CS4245_PGA_B_CTRL,
-				    data->input_vol[data->input_sel][1]);
-
-		oxygen_write16_masked(chip, OXYGEN_GPIO_DATA,
-				      data->input_sel ? 0 : GPIO_INPUT_ROUTE,
-				      GPIO_INPUT_ROUTE);
+		ret = input_source_apply(chip);
+		if (ret >= 0)
+			ret = input_volume_apply(chip,
+				data->input_vol[data->input_sel][0],
+				data->input_vol[data->input_sel][1]);
+		changed = ret >= 0 ? 1 : ret;
 	}
 	mutex_unlock(&chip->mutex);
 	return changed;
@@ -395,10 +399,10 @@ static const struct snd_kcontrol_new dg_controls[] = {
 		.get = hp_mute_get,
 		.put = hp_mute_put,
 	},
-	INPUT_VOLUME("Mic Capture Volume", 0),
-	INPUT_VOLUME("Aux Capture Volume", 1),
-	INPUT_VOLUME("Front Mic Capture Volume", 2),
-	INPUT_VOLUME("Line Capture Volume", 3),
+	INPUT_VOLUME("Mic Capture Volume", CAPTURE_SRC_MIC),
+	INPUT_VOLUME("Front Mic Capture Volume", CAPTURE_SRC_FP_MIC),
+	INPUT_VOLUME("Line Capture Volume", CAPTURE_SRC_LINE),
+	INPUT_VOLUME("Aux Capture Volume", CAPTURE_SRC_AUX),
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Capture Source",

commit cf218b2ef345a26f4ae242907150035950f90cb8
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:17 2014 +0400

    ALSA: oxygen: Xonar DG(X): modify capture volume functions
    
    Modify the input_vol_* functions to use the new SPI routines,
    There is a new applying function that will be called when
    the capture source changed.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg_mixer.c b/sound/pci/oxygen/xonar_dg_mixer.c
index 0c310e7c3a04..2417a1efd719 100644
--- a/sound/pci/oxygen/xonar_dg_mixer.c
+++ b/sound/pci/oxygen/xonar_dg_mixer.c
@@ -190,6 +190,21 @@ static int hp_mute_put(struct snd_kcontrol *ctl,
 	return changed;
 }
 
+/* capture volume for all sources */
+
+static int input_volume_apply(struct oxygen *chip, char left, char right)
+{
+	struct dg *data = chip->model_data;
+	int ret;
+
+	data->cs4245_shadow[CS4245_PGA_A_CTRL] = left;
+	data->cs4245_shadow[CS4245_PGA_B_CTRL] = right;
+	ret = cs4245_write_spi(chip, CS4245_PGA_A_CTRL);
+	if (ret < 0)
+		return ret;
+	return cs4245_write_spi(chip, CS4245_PGA_B_CTRL);
+}
+
 static int input_vol_info(struct snd_kcontrol *ctl,
 			  struct snd_ctl_elem_info *info)
 {
@@ -221,6 +236,7 @@ static int input_vol_put(struct snd_kcontrol *ctl,
 	struct dg *data = chip->model_data;
 	unsigned int idx = ctl->private_value;
 	int changed = 0;
+	int ret = 0;
 
 	if (value->value.integer.value[0] < 2 * -12 ||
 	    value->value.integer.value[0] > 2 * 12 ||
@@ -234,18 +250,16 @@ static int input_vol_put(struct snd_kcontrol *ctl,
 		data->input_vol[idx][0] = value->value.integer.value[0];
 		data->input_vol[idx][1] = value->value.integer.value[1];
 		if (idx == data->input_sel) {
-			cs4245_write_cached(chip, CS4245_PGA_A_CTRL,
-					    data->input_vol[idx][0]);
-			cs4245_write_cached(chip, CS4245_PGA_B_CTRL,
-					    data->input_vol[idx][1]);
+			ret = input_volume_apply(chip,
+				data->input_vol[idx][0],
+				data->input_vol[idx][1]);
 		}
+		changed = ret >= 0 ? 1 : ret;
 	}
 	mutex_unlock(&chip->mutex);
 	return changed;
 }
 
-static DECLARE_TLV_DB_SCALE(cs4245_pga_db_scale, -1200, 50, 0);
-
 static int input_sel_info(struct snd_kcontrol *ctl,
 			  struct snd_ctl_elem_info *info)
 {
@@ -345,13 +359,16 @@ static int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)
 #define INPUT_VOLUME(xname, index) { \
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
 	.name = xname, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \
+		  SNDRV_CTL_ELEM_ACCESS_TLV_READ, \
 	.info = input_vol_info, \
 	.get = input_vol_get, \
 	.put = input_vol_put, \
-	.tlv = { .p = cs4245_pga_db_scale }, \
+	.tlv = { .p = pga_db_scale }, \
 	.private_value = index, \
 }
 static const DECLARE_TLV_DB_MINMAX(hp_db_scale, -12550, 0);
+static const DECLARE_TLV_DB_MINMAX(pga_db_scale, -1200, 1200);
 static const struct snd_kcontrol_new dg_controls[] = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,

commit c754639a29e8d00933ccd2d7ec41505d0074de8b
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:16 2014 +0400

    ALSA: oxygen: Xonar DG(X): use headphone volume control
    
    I tried both variants: volume control and impedance selector.
    In the first case one minus is that we can't change the
    volume of multichannel output without additional software
    volume control. However, I am using this variant for the
    last three months and this seems good. All multichannel
    speaker systems have internal amplifier with the
    volume control included, but not all headphones have
    this regulator. In the second case, my software volume
    control does not save the value after reboot.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg_mixer.c b/sound/pci/oxygen/xonar_dg_mixer.c
index 6dfe63554742..0c310e7c3a04 100644
--- a/sound/pci/oxygen/xonar_dg_mixer.c
+++ b/sound/pci/oxygen/xonar_dg_mixer.c
@@ -99,54 +99,93 @@ static int output_select_put(struct snd_kcontrol *ctl,
 	return changed;
 }
 
-static int hp_volume_offset_info(struct snd_kcontrol *ctl,
-				 struct snd_ctl_elem_info *info)
+/* CS4245 Headphone Channels A&B Volume Control */
+
+static int hp_stereo_volume_info(struct snd_kcontrol *ctl,
+				struct snd_ctl_elem_info *info)
 {
-	static const char *const names[3] = {
-		"< 64 ohms", "64-150 ohms", "150-300 ohms"
-	};
+	info->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	info->count = 2;
+	info->value.integer.min = 0;
+	info->value.integer.max = 255;
+	return 0;
+}
 
-	return snd_ctl_enum_info(info, 1, 3, names);
+static int hp_stereo_volume_get(struct snd_kcontrol *ctl,
+				struct snd_ctl_elem_value *val)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+	unsigned int tmp;
+
+	mutex_lock(&chip->mutex);
+	tmp = (~data->cs4245_shadow[CS4245_DAC_A_CTRL]) & 255;
+	val->value.integer.value[0] = tmp;
+	tmp = (~data->cs4245_shadow[CS4245_DAC_B_CTRL]) & 255;
+	val->value.integer.value[1] = tmp;
+	mutex_unlock(&chip->mutex);
+	return 0;
 }
 
-static int hp_volume_offset_get(struct snd_kcontrol *ctl,
-				struct snd_ctl_elem_value *value)
+static int hp_stereo_volume_put(struct snd_kcontrol *ctl,
+				struct snd_ctl_elem_value *val)
 {
 	struct oxygen *chip = ctl->private_data;
 	struct dg *data = chip->model_data;
+	int ret;
+	int changed = 0;
+	long new1 = val->value.integer.value[0];
+	long new2 = val->value.integer.value[1];
+
+	if ((new1 > 255) || (new1 < 0) || (new2 > 255) || (new2 < 0))
+		return -EINVAL;
 
 	mutex_lock(&chip->mutex);
-	if (data->hp_vol_att > 2 * 7)
-		value->value.enumerated.item[0] = 0;
-	else if (data->hp_vol_att > 0)
-		value->value.enumerated.item[0] = 1;
-	else
-		value->value.enumerated.item[0] = 2;
+	if ((data->cs4245_shadow[CS4245_DAC_A_CTRL] != ~new1) ||
+	    (data->cs4245_shadow[CS4245_DAC_B_CTRL] != ~new2)) {
+		data->cs4245_shadow[CS4245_DAC_A_CTRL] = ~new1;
+		data->cs4245_shadow[CS4245_DAC_B_CTRL] = ~new2;
+		ret = cs4245_write_spi(chip, CS4245_DAC_A_CTRL);
+		if (ret >= 0)
+			ret = cs4245_write_spi(chip, CS4245_DAC_B_CTRL);
+		changed = ret >= 0 ? 1 : ret;
+	}
+	mutex_unlock(&chip->mutex);
+
+	return changed;
+}
+
+/* Headphone Mute */
+
+static int hp_mute_get(struct snd_kcontrol *ctl,
+			struct snd_ctl_elem_value *val)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+
+	mutex_lock(&chip->mutex);
+	val->value.integer.value[0] =
+		!(data->cs4245_shadow[CS4245_DAC_CTRL_1] & CS4245_MUTE_DAC);
 	mutex_unlock(&chip->mutex);
 	return 0;
 }
 
-static int hp_volume_offset_put(struct snd_kcontrol *ctl,
-				struct snd_ctl_elem_value *value)
+static int hp_mute_put(struct snd_kcontrol *ctl,
+			struct snd_ctl_elem_value *val)
 {
-	static const s8 atts[3] = { 2 * 16, 2 * 7, 0 };
 	struct oxygen *chip = ctl->private_data;
 	struct dg *data = chip->model_data;
-	s8 att;
+	int ret;
 	int changed;
 
-	if (value->value.enumerated.item[0] > 2)
+	if (val->value.integer.value[0] > 1)
 		return -EINVAL;
-	att = atts[value->value.enumerated.item[0]];
 	mutex_lock(&chip->mutex);
-	changed = att != data->hp_vol_att;
-	if (changed) {
-		data->hp_vol_att = att;
-		if (data->output_sel) {
-			cs4245_write_cached(chip, CS4245_DAC_A_CTRL, att);
-			cs4245_write_cached(chip, CS4245_DAC_B_CTRL, att);
-		}
-	}
+	data->cs4245_shadow[CS4245_DAC_CTRL_1] &= ~CS4245_MUTE_DAC;
+	data->cs4245_shadow[CS4245_DAC_CTRL_1] |=
+		(~val->value.integer.value[0] << 2) & CS4245_MUTE_DAC;
+	ret = cs4245_write_spi(chip, CS4245_DAC_CTRL_1);
+	changed = ret >= 0 ? 1 : ret;
 	mutex_unlock(&chip->mutex);
 	return changed;
 }
@@ -312,6 +351,7 @@ static int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)
 	.tlv = { .p = cs4245_pga_db_scale }, \
 	.private_value = index, \
 }
+static const DECLARE_TLV_DB_MINMAX(hp_db_scale, -12550, 0);
 static const struct snd_kcontrol_new dg_controls[] = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -322,10 +362,21 @@ static const struct snd_kcontrol_new dg_controls[] = {
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
-		.name = "Headphones Impedance Playback Enum",
-		.info = hp_volume_offset_info,
-		.get = hp_volume_offset_get,
-		.put = hp_volume_offset_put,
+		.name = "Headphone Playback Volume",
+		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			  SNDRV_CTL_ELEM_ACCESS_TLV_READ,
+		.info = hp_stereo_volume_info,
+		.get = hp_stereo_volume_get,
+		.put = hp_stereo_volume_put,
+		.tlv = { .p = hp_db_scale, },
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Headphone Playback Switch",
+		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.info = snd_ctl_boolean_mono_info,
+		.get = hp_mute_get,
+		.put = hp_mute_put,
 	},
 	INPUT_VOLUME("Mic Capture Volume", 0),
 	INPUT_VOLUME("Aux Capture Volume", 1),

commit 2809cb84d1672b639a4a41a0fa077fb554699072
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:15 2014 +0400

    ALSA: oxygen: Xonar DG(X): modify playback output select
    
    Change the order of elements in the output select control. This will
    reduce the number of relay switches. Change 'put' function to call the
    oxygen_update_dac_routing() function. Otherwise multichannel playback
    does not work. Also there is a new function to apply settings, this
    prevents from duplicating the code.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg_mixer.c b/sound/pci/oxygen/xonar_dg_mixer.c
index 7e9fc4af81bd..6dfe63554742 100644
--- a/sound/pci/oxygen/xonar_dg_mixer.c
+++ b/sound/pci/oxygen/xonar_dg_mixer.c
@@ -27,17 +27,46 @@
 #include "xonar_dg.h"
 #include "cs4245.h"
 
-static int output_switch_info(struct snd_kcontrol *ctl,
+/* analog output select */
+
+static int output_select_apply(struct oxygen *chip)
+{
+	struct dg *data = chip->model_data;
+
+	data->cs4245_shadow[CS4245_SIGNAL_SEL] &= ~CS4245_A_OUT_SEL_MASK;
+	if (data->output_sel == PLAYBACK_DST_HP) {
+		/* mute FP (aux output) amplifier, switch rear jack to CS4245 */
+		oxygen_set_bits8(chip, OXYGEN_GPIO_DATA, GPIO_HP_REAR);
+	} else if (data->output_sel == PLAYBACK_DST_HP_FP) {
+		/*
+		 * Unmute FP amplifier, switch rear jack to CS4361;
+		 * I2S channels 2,3,4 should be inactive.
+		 */
+		oxygen_clear_bits8(chip, OXYGEN_GPIO_DATA, GPIO_HP_REAR);
+		data->cs4245_shadow[CS4245_SIGNAL_SEL] |= CS4245_A_OUT_SEL_DAC;
+	} else {
+		/*
+		 * 2.0, 4.0, 5.1: switch to CS4361, mute FP amp.,
+		 * and change playback routing.
+		 */
+		oxygen_clear_bits8(chip, OXYGEN_GPIO_DATA, GPIO_HP_REAR);
+	}
+	return cs4245_write_spi(chip, CS4245_SIGNAL_SEL);
+}
+
+static int output_select_info(struct snd_kcontrol *ctl,
 			      struct snd_ctl_elem_info *info)
 {
 	static const char *const names[3] = {
-		"Speakers", "Headphones", "FP Headphones"
+		"Stereo Headphones",
+		"Stereo Headphones FP",
+		"Multichannel",
 	};
 
 	return snd_ctl_enum_info(info, 1, 3, names);
 }
 
-static int output_switch_get(struct snd_kcontrol *ctl,
+static int output_select_get(struct snd_kcontrol *ctl,
 			     struct snd_ctl_elem_value *value)
 {
 	struct oxygen *chip = ctl->private_data;
@@ -49,38 +78,24 @@ static int output_switch_get(struct snd_kcontrol *ctl,
 	return 0;
 }
 
-static int output_switch_put(struct snd_kcontrol *ctl,
+static int output_select_put(struct snd_kcontrol *ctl,
 			     struct snd_ctl_elem_value *value)
 {
 	struct oxygen *chip = ctl->private_data;
 	struct dg *data = chip->model_data;
-	u8 reg;
-	int changed;
-
-	if (value->value.enumerated.item[0] > 2)
-		return -EINVAL;
+	unsigned int new = value->value.enumerated.item[0];
+	int changed = 0;
+	int ret;
 
 	mutex_lock(&chip->mutex);
-	changed = value->value.enumerated.item[0] != data->output_sel;
-	if (changed) {
-		data->output_sel = value->value.enumerated.item[0];
-
-		reg = data->cs4245_shadow[CS4245_SIGNAL_SEL] &
-						~CS4245_A_OUT_SEL_MASK;
-		reg |= data->output_sel == 2 ?
-				CS4245_A_OUT_SEL_DAC : CS4245_A_OUT_SEL_HIZ;
-		cs4245_write_cached(chip, CS4245_SIGNAL_SEL, reg);
-
-		cs4245_write_cached(chip, CS4245_DAC_A_CTRL,
-				    data->output_sel ? data->hp_vol_att : 0);
-		cs4245_write_cached(chip, CS4245_DAC_B_CTRL,
-				    data->output_sel ? data->hp_vol_att : 0);
-
-		oxygen_write16_masked(chip, OXYGEN_GPIO_DATA,
-				      data->output_sel == 1 ? GPIO_HP_REAR : 0,
-				      GPIO_HP_REAR);
+	if (data->output_sel != new) {
+		data->output_sel = new;
+		ret = output_select_apply(chip);
+		changed = ret >= 0 ? 1 : ret;
+		oxygen_update_dac_routing(chip);
 	}
 	mutex_unlock(&chip->mutex);
+
 	return changed;
 }
 
@@ -301,9 +316,9 @@ static const struct snd_kcontrol_new dg_controls[] = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 		.name = "Analog Output Playback Enum",
-		.info = output_switch_info,
-		.get = output_switch_get,
-		.put = output_switch_put,
+		.info = output_select_info,
+		.get = output_select_get,
+		.put = output_select_put,
 	},
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,

commit 3dd77654fb1d7f68b9739f3039bad8dbbc0739f8
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:14 2014 +0400

    ALSA: oxygen: Xonar DG(X): capture from I2S channel 1, not 2
    
    Actually CS4245 connected to the I2S channel 1 for
    capture, not channel 2. Otherwise capturing and
    playback does not work for CS4245.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg_mixer.c b/sound/pci/oxygen/xonar_dg_mixer.c
index a2cd0d31ac77..7e9fc4af81bd 100644
--- a/sound/pci/oxygen/xonar_dg_mixer.c
+++ b/sound/pci/oxygen/xonar_dg_mixer.c
@@ -369,7 +369,7 @@ struct oxygen_model model_xonar_dg = {
 	.model_data_size = sizeof(struct dg),
 	.device_config = PLAYBACK_0_TO_I2S |
 			 PLAYBACK_1_TO_SPDIF |
-			 CAPTURE_0_FROM_I2S_2 |
+			 CAPTURE_0_FROM_I2S_1 |
 			 CAPTURE_1_FROM_SPDIF,
 	.dac_channels_pcm = 6,
 	.dac_channels_mixer = 0,

commit 041f26b6257d15449e1634ba8dea426dd06514c7
Author: Roman Volkov <v1ron@mail.ru>
Date:   Fri Jan 24 16:18:13 2014 +0400

    ALSA: oxygen: Xonar DG(X): move the mixer code into another file
    
    Moving the mixer code away makes things easier. The mixer
    will control the driver, so the functions of the
    driver need to be non-static.
    
    Signed-off-by: Roman Volkov <v1ron@mail.ru>
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/oxygen/xonar_dg_mixer.c b/sound/pci/oxygen/xonar_dg_mixer.c
new file mode 100644
index 000000000000..a2cd0d31ac77
--- /dev/null
+++ b/sound/pci/oxygen/xonar_dg_mixer.c
@@ -0,0 +1,381 @@
+/*
+ * Mixer controls for the Xonar DG/DGX
+ *
+ * Copyright (c) Clemens Ladisch <clemens@ladisch.de>
+ * Copyright (c) Roman Volkov <v1ron@mail.ru>
+ *
+ *  This driver is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License, version 2.
+ *
+ *  This driver is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this driver; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <sound/control.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/pcm.h>
+#include <sound/tlv.h>
+#include "oxygen.h"
+#include "xonar_dg.h"
+#include "cs4245.h"
+
+static int output_switch_info(struct snd_kcontrol *ctl,
+			      struct snd_ctl_elem_info *info)
+{
+	static const char *const names[3] = {
+		"Speakers", "Headphones", "FP Headphones"
+	};
+
+	return snd_ctl_enum_info(info, 1, 3, names);
+}
+
+static int output_switch_get(struct snd_kcontrol *ctl,
+			     struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+
+	mutex_lock(&chip->mutex);
+	value->value.enumerated.item[0] = data->output_sel;
+	mutex_unlock(&chip->mutex);
+	return 0;
+}
+
+static int output_switch_put(struct snd_kcontrol *ctl,
+			     struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+	u8 reg;
+	int changed;
+
+	if (value->value.enumerated.item[0] > 2)
+		return -EINVAL;
+
+	mutex_lock(&chip->mutex);
+	changed = value->value.enumerated.item[0] != data->output_sel;
+	if (changed) {
+		data->output_sel = value->value.enumerated.item[0];
+
+		reg = data->cs4245_shadow[CS4245_SIGNAL_SEL] &
+						~CS4245_A_OUT_SEL_MASK;
+		reg |= data->output_sel == 2 ?
+				CS4245_A_OUT_SEL_DAC : CS4245_A_OUT_SEL_HIZ;
+		cs4245_write_cached(chip, CS4245_SIGNAL_SEL, reg);
+
+		cs4245_write_cached(chip, CS4245_DAC_A_CTRL,
+				    data->output_sel ? data->hp_vol_att : 0);
+		cs4245_write_cached(chip, CS4245_DAC_B_CTRL,
+				    data->output_sel ? data->hp_vol_att : 0);
+
+		oxygen_write16_masked(chip, OXYGEN_GPIO_DATA,
+				      data->output_sel == 1 ? GPIO_HP_REAR : 0,
+				      GPIO_HP_REAR);
+	}
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+static int hp_volume_offset_info(struct snd_kcontrol *ctl,
+				 struct snd_ctl_elem_info *info)
+{
+	static const char *const names[3] = {
+		"< 64 ohms", "64-150 ohms", "150-300 ohms"
+	};
+
+	return snd_ctl_enum_info(info, 1, 3, names);
+}
+
+static int hp_volume_offset_get(struct snd_kcontrol *ctl,
+				struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+
+	mutex_lock(&chip->mutex);
+	if (data->hp_vol_att > 2 * 7)
+		value->value.enumerated.item[0] = 0;
+	else if (data->hp_vol_att > 0)
+		value->value.enumerated.item[0] = 1;
+	else
+		value->value.enumerated.item[0] = 2;
+	mutex_unlock(&chip->mutex);
+	return 0;
+}
+
+static int hp_volume_offset_put(struct snd_kcontrol *ctl,
+				struct snd_ctl_elem_value *value)
+{
+	static const s8 atts[3] = { 2 * 16, 2 * 7, 0 };
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+	s8 att;
+	int changed;
+
+	if (value->value.enumerated.item[0] > 2)
+		return -EINVAL;
+	att = atts[value->value.enumerated.item[0]];
+	mutex_lock(&chip->mutex);
+	changed = att != data->hp_vol_att;
+	if (changed) {
+		data->hp_vol_att = att;
+		if (data->output_sel) {
+			cs4245_write_cached(chip, CS4245_DAC_A_CTRL, att);
+			cs4245_write_cached(chip, CS4245_DAC_B_CTRL, att);
+		}
+	}
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+static int input_vol_info(struct snd_kcontrol *ctl,
+			  struct snd_ctl_elem_info *info)
+{
+	info->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	info->count = 2;
+	info->value.integer.min = 2 * -12;
+	info->value.integer.max = 2 * 12;
+	return 0;
+}
+
+static int input_vol_get(struct snd_kcontrol *ctl,
+			 struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+	unsigned int idx = ctl->private_value;
+
+	mutex_lock(&chip->mutex);
+	value->value.integer.value[0] = data->input_vol[idx][0];
+	value->value.integer.value[1] = data->input_vol[idx][1];
+	mutex_unlock(&chip->mutex);
+	return 0;
+}
+
+static int input_vol_put(struct snd_kcontrol *ctl,
+			 struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+	unsigned int idx = ctl->private_value;
+	int changed = 0;
+
+	if (value->value.integer.value[0] < 2 * -12 ||
+	    value->value.integer.value[0] > 2 * 12 ||
+	    value->value.integer.value[1] < 2 * -12 ||
+	    value->value.integer.value[1] > 2 * 12)
+		return -EINVAL;
+	mutex_lock(&chip->mutex);
+	changed = data->input_vol[idx][0] != value->value.integer.value[0] ||
+		  data->input_vol[idx][1] != value->value.integer.value[1];
+	if (changed) {
+		data->input_vol[idx][0] = value->value.integer.value[0];
+		data->input_vol[idx][1] = value->value.integer.value[1];
+		if (idx == data->input_sel) {
+			cs4245_write_cached(chip, CS4245_PGA_A_CTRL,
+					    data->input_vol[idx][0]);
+			cs4245_write_cached(chip, CS4245_PGA_B_CTRL,
+					    data->input_vol[idx][1]);
+		}
+	}
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+static DECLARE_TLV_DB_SCALE(cs4245_pga_db_scale, -1200, 50, 0);
+
+static int input_sel_info(struct snd_kcontrol *ctl,
+			  struct snd_ctl_elem_info *info)
+{
+	static const char *const names[4] = {
+		"Mic", "Aux", "Front Mic", "Line"
+	};
+
+	return snd_ctl_enum_info(info, 1, 4, names);
+}
+
+static int input_sel_get(struct snd_kcontrol *ctl,
+			 struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+
+	mutex_lock(&chip->mutex);
+	value->value.enumerated.item[0] = data->input_sel;
+	mutex_unlock(&chip->mutex);
+	return 0;
+}
+
+static int input_sel_put(struct snd_kcontrol *ctl,
+			 struct snd_ctl_elem_value *value)
+{
+	static const u8 sel_values[4] = {
+		CS4245_SEL_MIC,
+		CS4245_SEL_INPUT_1,
+		CS4245_SEL_INPUT_2,
+		CS4245_SEL_INPUT_4
+	};
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+	int changed;
+
+	if (value->value.enumerated.item[0] > 3)
+		return -EINVAL;
+
+	mutex_lock(&chip->mutex);
+	changed = value->value.enumerated.item[0] != data->input_sel;
+	if (changed) {
+		data->input_sel = value->value.enumerated.item[0];
+
+		cs4245_write(chip, CS4245_ANALOG_IN,
+			     (data->cs4245_shadow[CS4245_ANALOG_IN] &
+							~CS4245_SEL_MASK) |
+			     sel_values[data->input_sel]);
+
+		cs4245_write_cached(chip, CS4245_PGA_A_CTRL,
+				    data->input_vol[data->input_sel][0]);
+		cs4245_write_cached(chip, CS4245_PGA_B_CTRL,
+				    data->input_vol[data->input_sel][1]);
+
+		oxygen_write16_masked(chip, OXYGEN_GPIO_DATA,
+				      data->input_sel ? 0 : GPIO_INPUT_ROUTE,
+				      GPIO_INPUT_ROUTE);
+	}
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+static int hpf_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)
+{
+	static const char *const names[2] = { "Active", "Frozen" };
+
+	return snd_ctl_enum_info(info, 1, 2, names);
+}
+
+static int hpf_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+
+	value->value.enumerated.item[0] =
+		!!(data->cs4245_shadow[CS4245_ADC_CTRL] & CS4245_HPF_FREEZE);
+	return 0;
+}
+
+static int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)
+{
+	struct oxygen *chip = ctl->private_data;
+	struct dg *data = chip->model_data;
+	u8 reg;
+	int changed;
+
+	mutex_lock(&chip->mutex);
+	reg = data->cs4245_shadow[CS4245_ADC_CTRL] & ~CS4245_HPF_FREEZE;
+	if (value->value.enumerated.item[0])
+		reg |= CS4245_HPF_FREEZE;
+	changed = reg != data->cs4245_shadow[CS4245_ADC_CTRL];
+	if (changed)
+		cs4245_write(chip, CS4245_ADC_CTRL, reg);
+	mutex_unlock(&chip->mutex);
+	return changed;
+}
+
+#define INPUT_VOLUME(xname, index) { \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.info = input_vol_info, \
+	.get = input_vol_get, \
+	.put = input_vol_put, \
+	.tlv = { .p = cs4245_pga_db_scale }, \
+	.private_value = index, \
+}
+static const struct snd_kcontrol_new dg_controls[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Analog Output Playback Enum",
+		.info = output_switch_info,
+		.get = output_switch_get,
+		.put = output_switch_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Headphones Impedance Playback Enum",
+		.info = hp_volume_offset_info,
+		.get = hp_volume_offset_get,
+		.put = hp_volume_offset_put,
+	},
+	INPUT_VOLUME("Mic Capture Volume", 0),
+	INPUT_VOLUME("Aux Capture Volume", 1),
+	INPUT_VOLUME("Front Mic Capture Volume", 2),
+	INPUT_VOLUME("Line Capture Volume", 3),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Capture Source",
+		.info = input_sel_info,
+		.get = input_sel_get,
+		.put = input_sel_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "ADC High-pass Filter Capture Enum",
+		.info = hpf_info,
+		.get = hpf_get,
+		.put = hpf_put,
+	},
+};
+
+static int dg_control_filter(struct snd_kcontrol_new *template)
+{
+	if (!strncmp(template->name, "Master Playback ", 16))
+		return 1;
+	return 0;
+}
+
+static int dg_mixer_init(struct oxygen *chip)
+{
+	unsigned int i;
+	int err;
+
+	for (i = 0; i < ARRAY_SIZE(dg_controls); ++i) {
+		err = snd_ctl_add(chip->card,
+				  snd_ctl_new1(&dg_controls[i], chip));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+struct oxygen_model model_xonar_dg = {
+	.longname = "C-Media Oxygen HD Audio",
+	.chip = "CMI8786",
+	.init = dg_init,
+	.control_filter = dg_control_filter,
+	.mixer_init = dg_mixer_init,
+	.cleanup = dg_cleanup,
+	.suspend = dg_suspend,
+	.resume = dg_resume,
+	.set_dac_params = set_cs4245_dac_params,
+	.set_adc_params = set_cs4245_adc_params,
+	.adjust_dac_routing = adjust_dg_dac_routing,
+	.dump_registers = dump_cs4245_registers,
+	.model_data_size = sizeof(struct dg),
+	.device_config = PLAYBACK_0_TO_I2S |
+			 PLAYBACK_1_TO_SPDIF |
+			 CAPTURE_0_FROM_I2S_2 |
+			 CAPTURE_1_FROM_SPDIF,
+	.dac_channels_pcm = 6,
+	.dac_channels_mixer = 0,
+	.function_flags = OXYGEN_FUNCTION_SPI,
+	.dac_mclks = OXYGEN_MCLKS(256, 128, 128),
+	.adc_mclks = OXYGEN_MCLKS(256, 128, 128),
+	.dac_i2s_format = OXYGEN_I2S_FORMAT_LJUST,
+	.adc_i2s_format = OXYGEN_I2S_FORMAT_LJUST,
+};
