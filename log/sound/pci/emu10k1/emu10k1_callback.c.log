commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c
index aa2cc27b8491..07471c3dcbed 100644
--- a/sound/pci/emu10k1/emu10k1_callback.c
+++ b/sound/pci/emu10k1/emu10k1_callback.c
@@ -1,21 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  synth callback routines for Emu10k1
  *
  *  Copyright (C) 2000 Takashi Iwai <tiwai@suse.de>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 #include <linux/export.h>

commit 3bb9eca913025ed05c0510de831c67b7bef652c5
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sun Feb 19 15:51:30 2017 +0530

    ALSA: emu10k1: constify snd_emux_operators structure
    
    Declare snd_emux_operators structure as const as it is only copied into
    another structure. So, snd_emux_operators structures having this property
    can be made const.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c
index d2c7ea3a7610..aa2cc27b8491 100644
--- a/sound/pci/emu10k1/emu10k1_callback.c
+++ b/sound/pci/emu10k1/emu10k1_callback.c
@@ -61,7 +61,7 @@ static void set_filterQ(struct snd_emu10k1 *hw, struct snd_emux_voice *vp);
 /*
  * set up operators
  */
-static struct snd_emux_operators emu10k1_ops = {
+static const struct snd_emux_operators emu10k1_ops = {
 	.owner =	THIS_MODULE,
 	.get_voice =	get_voice,
 	.prepare =	start_voice,

commit 7241ea558c6715501e777396b5fc312c372e11d9
Author: Peter Zubaj <pzubaj@marticonet.sk>
Date:   Tue Apr 28 21:57:29 2015 +0200

    ALSA: emu10k1: Emu10k2 32 bit DMA mode
    
    Looks like audigy emu10k2 (probably emu10k1 - sb live too) support two
    modes for DMA. Second mode is useful for 64 bit os with more then 2 GB
    of ram (fixes problems with big soundfont loading)
    
    1) 32MB from 2 GB address space using 8192 pages (used now as default)
    2) 16MB from 4 GB address space using 4096 pages
    
    Mode is set using HCFG_EXPANDED_MEM flag in HCFG register.
    Also format of emu10k2 page table is then different.
    
    Signed-off-by: Peter Zubaj <pzubaj@marticonet.sk>
    Tested-by: Takashi Iwai <tiwai@suse.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c
index 874cd76c7b7f..d2c7ea3a7610 100644
--- a/sound/pci/emu10k1/emu10k1_callback.c
+++ b/sound/pci/emu10k1/emu10k1_callback.c
@@ -415,7 +415,7 @@ start_voice(struct snd_emux_voice *vp)
 	snd_emu10k1_ptr_write(hw, Z2, ch, 0);
 
 	/* invalidate maps */
-	temp = (hw->silent_page.addr << 1) | MAP_PTI_MASK;
+	temp = (hw->silent_page.addr << hw->address_mode) | (hw->address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);
 	snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 	snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 #if 0
@@ -436,7 +436,7 @@ start_voice(struct snd_emux_voice *vp)
 		snd_emu10k1_ptr_write(hw, CDF, ch, sample);
 
 		/* invalidate maps */
-		temp = ((unsigned int)hw->silent_page.addr << 1) | MAP_PTI_MASK;
+		temp = ((unsigned int)hw->silent_page.addr << hw_address_mode) | (hw->address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);
 		snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 		snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 		

commit 95926035b187cc9fee6fb61385b7da9c28123f74
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 13 23:18:02 2014 +0200

    ALSA: emu10k1: Fix deadlock in synth voice lookup
    
    The emu10k1 voice allocator takes voice_lock spinlock.  When there is
    no empty stream available, it tries to release a voice used by synth,
    and calls get_synth_voice.  The callback function,
    snd_emu10k1_synth_get_voice(), however, also takes the voice_lock,
    thus it deadlocks.
    
    The fix is simply removing the voice_lock holds in
    snd_emu10k1_synth_get_voice(), as this is always called in the
    spinlock context.
    
    Reported-and-tested-by: Arthur Marsh <arthur.marsh@internode.on.net>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c
index 3f3ef38d9b6e..874cd76c7b7f 100644
--- a/sound/pci/emu10k1/emu10k1_callback.c
+++ b/sound/pci/emu10k1/emu10k1_callback.c
@@ -85,6 +85,8 @@ snd_emu10k1_ops_setup(struct snd_emux *emux)
  * get more voice for pcm
  *
  * terminate most inactive voice and give it as a pcm voice.
+ *
+ * voice_lock is already held.
  */
 int
 snd_emu10k1_synth_get_voice(struct snd_emu10k1 *hw)
@@ -92,12 +94,10 @@ snd_emu10k1_synth_get_voice(struct snd_emu10k1 *hw)
 	struct snd_emux *emu;
 	struct snd_emux_voice *vp;
 	struct best_voice best[V_END];
-	unsigned long flags;
 	int i;
 
 	emu = hw->synth;
 
-	spin_lock_irqsave(&emu->voice_lock, flags);
 	lookup_voices(emu, hw, best, 1); /* no OFF voices */
 	for (i = 0; i < V_END; i++) {
 		if (best[i].voice >= 0) {
@@ -113,11 +113,9 @@ snd_emu10k1_synth_get_voice(struct snd_emu10k1 *hw)
 			vp->emu->num_voices--;
 			vp->ch = -1;
 			vp->state = SNDRV_EMUX_ST_OFF;
-			spin_unlock_irqrestore(&emu->voice_lock, flags);
 			return ch;
 		}
 	}
-	spin_unlock_irqrestore(&emu->voice_lock, flags);
 
 	/* not found */
 	return -ENOMEM;

commit 6f002b02166cc037025c0d1600a0e638a82145ac
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 17:02:09 2014 +0100

    ALSA: emu10k1: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c
index cae36597aa71..3f3ef38d9b6e 100644
--- a/sound/pci/emu10k1/emu10k1_callback.c
+++ b/sound/pci/emu10k1/emu10k1_callback.c
@@ -105,7 +105,7 @@ snd_emu10k1_synth_get_voice(struct snd_emu10k1 *hw)
 			vp = &emu->voices[best[i].voice];
 			if ((ch = vp->ch) < 0) {
 				/*
-				printk(KERN_WARNING
+				dev_warn(emu->card->dev,
 				       "synth_get_voice: ch < 0 (%d) ??", i);
 				*/
 				continue;
@@ -339,7 +339,7 @@ start_voice(struct snd_emux_voice *vp)
 		return -EINVAL;
 	emem->map_locked++;
 	if (snd_emu10k1_memblk_map(hw, emem) < 0) {
-		/* printk(KERN_ERR "emu: cannot map!\n"); */
+		/* dev_err(hw->card->devK, "emu: cannot map!\n"); */
 		return -ENOMEM;
 	}
 	mapped_offset = snd_emu10k1_memblk_offset(emem) >> 1;

commit 395d9dd5dd13c6aa3c8c61a31126af98cd1e747d
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Fri Sep 28 11:24:57 2012 +0200

    sound: Remove unnecessary semicolon
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r1@
    statement S;
    position p,p1;
    @@
    S@p1;@p
    
    @script:python r2@
    p << r1.p;
    p1 << r1.p1;
    @@
    if p[0].line != p1[0].line_end:
            cocci.include_match(False)
    @@
    position r1.p;
    @@
    -;@p
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c
index a0afa5057488..cae36597aa71 100644
--- a/sound/pci/emu10k1/emu10k1_callback.c
+++ b/sound/pci/emu10k1/emu10k1_callback.c
@@ -228,7 +228,7 @@ lookup_voices(struct snd_emux *emu, struct snd_emu10k1 *hw,
 	int  i;
 
 	for (i = 0; i < V_END; i++) {
-		best[i].time = (unsigned int)-1; /* XXX MAX_?INT really */;
+		best[i].time = (unsigned int)-1; /* XXX MAX_?INT really */
 		best[i].voice = -1;
 	}
 

commit d81a6d71760c4d8323f1f9a506c64084caa09063
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Sep 22 09:34:58 2011 -0400

    sound: Add export.h for THIS_MODULE/EXPORT_SYMBOL where needed
    
    These aren't modules, but they do make use of these macros, so
    they will need export.h to get that definition.  Previously,
    they got it via the implicit module.h inclusion.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c
index 7ef949d99a50..a0afa5057488 100644
--- a/sound/pci/emu10k1/emu10k1_callback.c
+++ b/sound/pci/emu10k1/emu10k1_callback.c
@@ -18,6 +18,7 @@
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
+#include <linux/export.h>
 #include "emu10k1_synth_local.h"
 #include <sound/asoundef.h>
 

commit 28a97c194cec477073ae341f15b836437d8ef8e5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 16:08:14 2009 +0100

    ALSA: emu10k1 - Add missing KERN_* prefix to printk
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c
index 0e649dcdbf64..7ef949d99a50 100644
--- a/sound/pci/emu10k1/emu10k1_callback.c
+++ b/sound/pci/emu10k1/emu10k1_callback.c
@@ -103,7 +103,10 @@ snd_emu10k1_synth_get_voice(struct snd_emu10k1 *hw)
 			int ch;
 			vp = &emu->voices[best[i].voice];
 			if ((ch = vp->ch) < 0) {
-				//printk("synth_get_voice: ch < 0 (%d) ??", i);
+				/*
+				printk(KERN_WARNING
+				       "synth_get_voice: ch < 0 (%d) ??", i);
+				*/
 				continue;
 			}
 			vp->emu->num_voices--;
@@ -335,7 +338,7 @@ start_voice(struct snd_emux_voice *vp)
 		return -EINVAL;
 	emem->map_locked++;
 	if (snd_emu10k1_memblk_map(hw, emem) < 0) {
-		// printk("emu: cannot map!\n");
+		/* printk(KERN_ERR "emu: cannot map!\n"); */
 		return -ENOMEM;
 	}
 	mapped_offset = snd_emu10k1_memblk_offset(emem) >> 1;

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c
index 45088ebcce50..0e649dcdbf64 100644
--- a/sound/pci/emu10k1/emu10k1_callback.c
+++ b/sound/pci/emu10k1/emu10k1_callback.c
@@ -145,7 +145,8 @@ terminate_voice(struct snd_emux_voice *vp)
 {
 	struct snd_emu10k1 *hw;
 	
-	snd_assert(vp, return);
+	if (snd_BUG_ON(!vp))
+		return;
 	hw = vp->hw;
 	snd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, 0x807f | DCYSUSV_CHANNELENABLE_MASK);
 	if (vp->block) {
@@ -325,7 +326,8 @@ start_voice(struct snd_emux_voice *vp)
 	
 	hw = vp->hw;
 	ch = vp->ch;
-	snd_assert(ch >= 0, return -EINVAL);
+	if (snd_BUG_ON(ch < 0))
+		return -EINVAL;
 	chan = vp->chan;
 
 	emem = (struct snd_emu10k1_memblk *)vp->block;

commit c94fa4c9168e51a8dab8e72cb9f0d89673fc8d8c
Author: James Courtier-Dutton <James@superbug.co.uk>
Date:   Sat Nov 10 17:55:14 2007 +0000

    [ALSA] emu10k1: General cleanup, add new locks, fix alsa bug#3501, kernel bug#9304.
    
    
    Signed-off-by: James Courtier-Dutton <James@superbug.co.uk>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c
index 01965bd99966..45088ebcce50 100644
--- a/sound/pci/emu10k1/emu10k1_callback.c
+++ b/sound/pci/emu10k1/emu10k1_callback.c
@@ -35,9 +35,9 @@ struct best_voice {
 /*
  * prototypes
  */
-static void lookup_voices(struct snd_emux *emu, struct snd_emu10k1 *hw,
+static void lookup_voices(struct snd_emux *emux, struct snd_emu10k1 *hw,
 			  struct best_voice *best, int active_only);
-static struct snd_emux_voice *get_voice(struct snd_emux *emu,
+static struct snd_emux_voice *get_voice(struct snd_emux *emux,
 					struct snd_emux_port *port);
 static int start_voice(struct snd_emux_voice *vp);
 static void trigger_voice(struct snd_emux_voice *vp);
@@ -45,7 +45,6 @@ static void release_voice(struct snd_emux_voice *vp);
 static void update_voice(struct snd_emux_voice *vp, int update);
 static void terminate_voice(struct snd_emux_voice *vp);
 static void free_voice(struct snd_emux_voice *vp);
-
 static void set_fmmod(struct snd_emu10k1 *hw, struct snd_emux_voice *vp);
 static void set_fm2frq2(struct snd_emu10k1 *hw, struct snd_emux_voice *vp);
 static void set_filterQ(struct snd_emu10k1 *hw, struct snd_emux_voice *vp);
@@ -75,9 +74,9 @@ static struct snd_emux_operators emu10k1_ops = {
 };
 
 void
-snd_emu10k1_ops_setup(struct snd_emux *emu)
+snd_emu10k1_ops_setup(struct snd_emux *emux)
 {
-	emu->ops = emu10k1_ops;
+	emux->ops = emu10k1_ops;
 }
 
 
@@ -166,7 +165,11 @@ free_voice(struct snd_emux_voice *vp)
 	struct snd_emu10k1 *hw;
 	
 	hw = vp->hw;
-	if (vp->ch >= 0) {
+	/* FIXME: emu10k1_synth is broken. */
+	/* This can get called with hw == 0 */
+	/* Problem apparent on plug, unplug then plug */
+	/* on the Audigy 2 ZS Notebook. */
+	if (hw && (vp->ch >= 0)) {
 		snd_emu10k1_ptr_write(hw, IFATN, vp->ch, 0xff00);
 		snd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, 0x807f | DCYSUSV_CHANNELENABLE_MASK);
 		// snd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, 0);

commit eb4698f347ec908c365504c4edddadd1acd406ea
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:50:13 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI emu10k1
    
    Modules: EMU10K1/EMU10K2 driver
    
    Remove xxx_t typedefs from the PCI emu10k1 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c
index 6589bf24abcd..01965bd99966 100644
--- a/sound/pci/emu10k1/emu10k1_callback.c
+++ b/sound/pci/emu10k1/emu10k1_callback.c
@@ -27,26 +27,28 @@ enum {
 };
 
 /* Keeps track of what we are finding */
-typedef struct best_voice {
+struct best_voice {
 	unsigned int time;
 	int voice;
-} best_voice_t;
+};
 
 /*
  * prototypes
  */
-static void lookup_voices(snd_emux_t *emu, emu10k1_t *hw, best_voice_t *best, int active_only);
-static snd_emux_voice_t *get_voice(snd_emux_t *emu, snd_emux_port_t *port);
-static int start_voice(snd_emux_voice_t *vp);
-static void trigger_voice(snd_emux_voice_t *vp);
-static void release_voice(snd_emux_voice_t *vp);
-static void update_voice(snd_emux_voice_t *vp, int update);
-static void terminate_voice(snd_emux_voice_t *vp);
-static void free_voice(snd_emux_voice_t *vp);
-
-static void set_fmmod(emu10k1_t *hw, snd_emux_voice_t *vp);
-static void set_fm2frq2(emu10k1_t *hw, snd_emux_voice_t *vp);
-static void set_filterQ(emu10k1_t *hw, snd_emux_voice_t *vp);
+static void lookup_voices(struct snd_emux *emu, struct snd_emu10k1 *hw,
+			  struct best_voice *best, int active_only);
+static struct snd_emux_voice *get_voice(struct snd_emux *emu,
+					struct snd_emux_port *port);
+static int start_voice(struct snd_emux_voice *vp);
+static void trigger_voice(struct snd_emux_voice *vp);
+static void release_voice(struct snd_emux_voice *vp);
+static void update_voice(struct snd_emux_voice *vp, int update);
+static void terminate_voice(struct snd_emux_voice *vp);
+static void free_voice(struct snd_emux_voice *vp);
+
+static void set_fmmod(struct snd_emu10k1 *hw, struct snd_emux_voice *vp);
+static void set_fm2frq2(struct snd_emu10k1 *hw, struct snd_emux_voice *vp);
+static void set_filterQ(struct snd_emu10k1 *hw, struct snd_emux_voice *vp);
 
 /*
  * Ensure a value is between two points
@@ -59,7 +61,7 @@ static void set_filterQ(emu10k1_t *hw, snd_emux_voice_t *vp);
 /*
  * set up operators
  */
-static snd_emux_operators_t emu10k1_ops = {
+static struct snd_emux_operators emu10k1_ops = {
 	.owner =	THIS_MODULE,
 	.get_voice =	get_voice,
 	.prepare =	start_voice,
@@ -73,7 +75,7 @@ static snd_emux_operators_t emu10k1_ops = {
 };
 
 void
-snd_emu10k1_ops_setup(snd_emux_t *emu)
+snd_emu10k1_ops_setup(struct snd_emux *emu)
 {
 	emu->ops = emu10k1_ops;
 }
@@ -85,11 +87,11 @@ snd_emu10k1_ops_setup(snd_emux_t *emu)
  * terminate most inactive voice and give it as a pcm voice.
  */
 int
-snd_emu10k1_synth_get_voice(emu10k1_t *hw)
+snd_emu10k1_synth_get_voice(struct snd_emu10k1 *hw)
 {
-	snd_emux_t *emu;
-	snd_emux_voice_t *vp;
-	best_voice_t best[V_END];
+	struct snd_emux *emu;
+	struct snd_emux_voice *vp;
+	struct best_voice best[V_END];
 	unsigned long flags;
 	int i;
 
@@ -123,10 +125,10 @@ snd_emu10k1_synth_get_voice(emu10k1_t *hw)
  * turn off the voice (not terminated)
  */
 static void
-release_voice(snd_emux_voice_t *vp)
+release_voice(struct snd_emux_voice *vp)
 {
 	int dcysusv;
-	emu10k1_t *hw;
+	struct snd_emu10k1 *hw;
 	
 	hw = vp->hw;
 	dcysusv = 0x8000 | (unsigned char)vp->reg.parm.modrelease;
@@ -140,16 +142,16 @@ release_voice(snd_emux_voice_t *vp)
  * terminate the voice
  */
 static void
-terminate_voice(snd_emux_voice_t *vp)
+terminate_voice(struct snd_emux_voice *vp)
 {
-	emu10k1_t *hw;
+	struct snd_emu10k1 *hw;
 	
 	snd_assert(vp, return);
 	hw = vp->hw;
 	snd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, 0x807f | DCYSUSV_CHANNELENABLE_MASK);
 	if (vp->block) {
-		emu10k1_memblk_t *emem;
-		emem = (emu10k1_memblk_t *)vp->block;
+		struct snd_emu10k1_memblk *emem;
+		emem = (struct snd_emu10k1_memblk *)vp->block;
 		if (emem->map_locked > 0)
 			emem->map_locked--;
 	}
@@ -159,9 +161,9 @@ terminate_voice(snd_emux_voice_t *vp)
  * release the voice to system
  */
 static void
-free_voice(snd_emux_voice_t *vp)
+free_voice(struct snd_emux_voice *vp)
 {
-	emu10k1_t *hw;
+	struct snd_emu10k1 *hw;
 	
 	hw = vp->hw;
 	if (vp->ch >= 0) {
@@ -181,9 +183,9 @@ free_voice(snd_emux_voice_t *vp)
  * update registers
  */
 static void
-update_voice(snd_emux_voice_t *vp, int update)
+update_voice(struct snd_emux_voice *vp, int update)
 {
-	emu10k1_t *hw;
+	struct snd_emu10k1 *hw;
 	
 	hw = vp->hw;
 	if (update & SNDRV_EMUX_UPDATE_VOLUME)
@@ -210,10 +212,11 @@ update_voice(snd_emux_voice_t *vp, int update)
  */
 /* spinlock held! */
 static void
-lookup_voices(snd_emux_t *emu, emu10k1_t *hw, best_voice_t *best, int active_only)
+lookup_voices(struct snd_emux *emu, struct snd_emu10k1 *hw,
+	      struct best_voice *best, int active_only)
 {
-	snd_emux_voice_t *vp;
-	best_voice_t *bp;
+	struct snd_emux_voice *vp;
+	struct best_voice *bp;
 	int  i;
 
 	for (i = 0; i < V_END; i++) {
@@ -274,12 +277,12 @@ lookup_voices(snd_emux_t *emu, emu10k1_t *hw, best_voice_t *best, int active_onl
  *
  * emu->voice_lock is already held.
  */
-static snd_emux_voice_t *
-get_voice(snd_emux_t *emu, snd_emux_port_t *port)
+static struct snd_emux_voice *
+get_voice(struct snd_emux *emu, struct snd_emux_port *port)
 {
-	emu10k1_t *hw;
-	snd_emux_voice_t *vp;
-	best_voice_t best[V_END];
+	struct snd_emu10k1 *hw;
+	struct snd_emux_voice *vp;
+	struct best_voice best[V_END];
 	int i;
 
 	hw = emu->hw;
@@ -290,7 +293,7 @@ get_voice(snd_emux_t *emu, snd_emux_port_t *port)
 			vp = &emu->voices[best[i].voice];
 			if (vp->ch < 0) {
 				/* allocate a voice */
-				emu10k1_voice_t *hwvoice;
+				struct snd_emu10k1_voice *hwvoice;
 				if (snd_emu10k1_voice_alloc(hw, EMU10K1_SYNTH, 1, &hwvoice) < 0 || hwvoice == NULL)
 					continue;
 				vp->ch = hwvoice->number;
@@ -308,21 +311,21 @@ get_voice(snd_emux_t *emu, snd_emux_port_t *port)
  * prepare envelopes and LFOs
  */
 static int
-start_voice(snd_emux_voice_t *vp)
+start_voice(struct snd_emux_voice *vp)
 {
 	unsigned int temp;
 	int ch;
 	unsigned int addr, mapped_offset;
-	snd_midi_channel_t *chan;
-	emu10k1_t *hw;
-	emu10k1_memblk_t *emem;
+	struct snd_midi_channel *chan;
+	struct snd_emu10k1 *hw;
+	struct snd_emu10k1_memblk *emem;
 	
 	hw = vp->hw;
 	ch = vp->ch;
 	snd_assert(ch >= 0, return -EINVAL);
 	chan = vp->chan;
 
-	emem = (emu10k1_memblk_t *)vp->block;
+	emem = (struct snd_emu10k1_memblk *)vp->block;
 	if (emem == NULL)
 		return -EINVAL;
 	emem->map_locked++;
@@ -463,15 +466,15 @@ start_voice(snd_emux_voice_t *vp)
  * Start envelope
  */
 static void
-trigger_voice(snd_emux_voice_t *vp)
+trigger_voice(struct snd_emux_voice *vp)
 {
 	unsigned int temp, ptarget;
-	emu10k1_t *hw;
-	emu10k1_memblk_t *emem;
+	struct snd_emu10k1 *hw;
+	struct snd_emu10k1_memblk *emem;
 	
 	hw = vp->hw;
 
-	emem = (emu10k1_memblk_t *)vp->block;
+	emem = (struct snd_emu10k1_memblk *)vp->block;
 	if (! emem || emem->mapped_page < 0)
 		return; /* not mapped */
 
@@ -495,7 +498,7 @@ trigger_voice(snd_emux_voice_t *vp)
 
 /* set lfo1 modulation height and cutoff */
 static void
-set_fmmod(emu10k1_t *hw, snd_emux_voice_t *vp)
+set_fmmod(struct snd_emu10k1 *hw, struct snd_emux_voice *vp)
 {
 	unsigned short fmmod;
 	short pitch;
@@ -513,7 +516,7 @@ set_fmmod(emu10k1_t *hw, snd_emux_voice_t *vp)
 
 /* set lfo2 pitch & frequency */
 static void
-set_fm2frq2(emu10k1_t *hw, snd_emux_voice_t *vp)
+set_fm2frq2(struct snd_emu10k1 *hw, struct snd_emux_voice *vp)
 {
 	unsigned short fm2frq2;
 	short pitch;
@@ -531,7 +534,7 @@ set_fm2frq2(emu10k1_t *hw, snd_emux_voice_t *vp)
 
 /* set filterQ */
 static void
-set_filterQ(emu10k1_t *hw, snd_emux_voice_t *vp)
+set_filterQ(struct snd_emu10k1 *hw, struct snd_emux_voice *vp)
 {
 	unsigned int val;
 	val = snd_emu10k1_ptr_read(hw, CCCA, vp->ch) & ~CCCA_RESONANCE;

commit fc20773329c993ec7d1b2c65618351f057d9d679
Author: Tim <tedon@rogers.com>
Date:   Tue Oct 25 11:10:55 2005 +0200

    [ALSA] Fix emu10k1 synth problems.
    
    Modules: EMU10K1/EMU10K2 driver,Common EMU synth
    
    This patch fixes problems with voices cutting off or not
    sounding at all.
    
    Signed-off-by: Tim <tedon@rogers.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c
index 7cf2f908eed9..6589bf24abcd 100644
--- a/sound/pci/emu10k1/emu10k1_callback.c
+++ b/sound/pci/emu10k1/emu10k1_callback.c
@@ -241,7 +241,7 @@ lookup_voices(snd_emux_t *emu, emu10k1_t *hw, best_voice_t *best, int active_onl
 		else if (state == SNDRV_EMUX_ST_RELEASED ||
 			 state == SNDRV_EMUX_ST_PENDING) {
 			bp = best + V_RELEASED;
-#if 0
+#if 1
 			val = snd_emu10k1_ptr_read(hw, CVCF_CURRENTVOL, vp->ch);
 			if (! val)
 				bp = best + V_OFF;
@@ -349,7 +349,7 @@ start_voice(snd_emux_voice_t *vp)
 	}
 
 	/* channel to be silent and idle */
-	snd_emu10k1_ptr_write(hw, DCYSUSV, ch, 0x0080);
+	snd_emu10k1_ptr_write(hw, DCYSUSV, ch, 0x0000);
 	snd_emu10k1_ptr_write(hw, VTFT, ch, 0x0000FFFF);
 	snd_emu10k1_ptr_write(hw, CVCF, ch, 0x0000FFFF);
 	snd_emu10k1_ptr_write(hw, PTRX, ch, 0);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c
new file mode 100644
index 000000000000..7cf2f908eed9
--- /dev/null
+++ b/sound/pci/emu10k1/emu10k1_callback.c
@@ -0,0 +1,540 @@
+/*
+ *  synth callback routines for Emu10k1
+ *
+ *  Copyright (C) 2000 Takashi Iwai <tiwai@suse.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include "emu10k1_synth_local.h"
+#include <sound/asoundef.h>
+
+/* voice status */
+enum {
+	V_FREE=0, V_OFF, V_RELEASED, V_PLAYING, V_END
+};
+
+/* Keeps track of what we are finding */
+typedef struct best_voice {
+	unsigned int time;
+	int voice;
+} best_voice_t;
+
+/*
+ * prototypes
+ */
+static void lookup_voices(snd_emux_t *emu, emu10k1_t *hw, best_voice_t *best, int active_only);
+static snd_emux_voice_t *get_voice(snd_emux_t *emu, snd_emux_port_t *port);
+static int start_voice(snd_emux_voice_t *vp);
+static void trigger_voice(snd_emux_voice_t *vp);
+static void release_voice(snd_emux_voice_t *vp);
+static void update_voice(snd_emux_voice_t *vp, int update);
+static void terminate_voice(snd_emux_voice_t *vp);
+static void free_voice(snd_emux_voice_t *vp);
+
+static void set_fmmod(emu10k1_t *hw, snd_emux_voice_t *vp);
+static void set_fm2frq2(emu10k1_t *hw, snd_emux_voice_t *vp);
+static void set_filterQ(emu10k1_t *hw, snd_emux_voice_t *vp);
+
+/*
+ * Ensure a value is between two points
+ * macro evaluates its args more than once, so changed to upper-case.
+ */
+#define LIMITVALUE(x, a, b) do { if ((x) < (a)) (x) = (a); else if ((x) > (b)) (x) = (b); } while (0)
+#define LIMITMAX(x, a) do {if ((x) > (a)) (x) = (a); } while (0)
+
+
+/*
+ * set up operators
+ */
+static snd_emux_operators_t emu10k1_ops = {
+	.owner =	THIS_MODULE,
+	.get_voice =	get_voice,
+	.prepare =	start_voice,
+	.trigger =	trigger_voice,
+	.release =	release_voice,
+	.update =	update_voice,
+	.terminate =	terminate_voice,
+	.free_voice =	free_voice,
+	.sample_new =	snd_emu10k1_sample_new,
+	.sample_free =	snd_emu10k1_sample_free,
+};
+
+void
+snd_emu10k1_ops_setup(snd_emux_t *emu)
+{
+	emu->ops = emu10k1_ops;
+}
+
+
+/*
+ * get more voice for pcm
+ *
+ * terminate most inactive voice and give it as a pcm voice.
+ */
+int
+snd_emu10k1_synth_get_voice(emu10k1_t *hw)
+{
+	snd_emux_t *emu;
+	snd_emux_voice_t *vp;
+	best_voice_t best[V_END];
+	unsigned long flags;
+	int i;
+
+	emu = hw->synth;
+
+	spin_lock_irqsave(&emu->voice_lock, flags);
+	lookup_voices(emu, hw, best, 1); /* no OFF voices */
+	for (i = 0; i < V_END; i++) {
+		if (best[i].voice >= 0) {
+			int ch;
+			vp = &emu->voices[best[i].voice];
+			if ((ch = vp->ch) < 0) {
+				//printk("synth_get_voice: ch < 0 (%d) ??", i);
+				continue;
+			}
+			vp->emu->num_voices--;
+			vp->ch = -1;
+			vp->state = SNDRV_EMUX_ST_OFF;
+			spin_unlock_irqrestore(&emu->voice_lock, flags);
+			return ch;
+		}
+	}
+	spin_unlock_irqrestore(&emu->voice_lock, flags);
+
+	/* not found */
+	return -ENOMEM;
+}
+
+
+/*
+ * turn off the voice (not terminated)
+ */
+static void
+release_voice(snd_emux_voice_t *vp)
+{
+	int dcysusv;
+	emu10k1_t *hw;
+	
+	hw = vp->hw;
+	dcysusv = 0x8000 | (unsigned char)vp->reg.parm.modrelease;
+	snd_emu10k1_ptr_write(hw, DCYSUSM, vp->ch, dcysusv);
+	dcysusv = 0x8000 | (unsigned char)vp->reg.parm.volrelease | DCYSUSV_CHANNELENABLE_MASK;
+	snd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, dcysusv);
+}
+
+
+/*
+ * terminate the voice
+ */
+static void
+terminate_voice(snd_emux_voice_t *vp)
+{
+	emu10k1_t *hw;
+	
+	snd_assert(vp, return);
+	hw = vp->hw;
+	snd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, 0x807f | DCYSUSV_CHANNELENABLE_MASK);
+	if (vp->block) {
+		emu10k1_memblk_t *emem;
+		emem = (emu10k1_memblk_t *)vp->block;
+		if (emem->map_locked > 0)
+			emem->map_locked--;
+	}
+}
+
+/*
+ * release the voice to system
+ */
+static void
+free_voice(snd_emux_voice_t *vp)
+{
+	emu10k1_t *hw;
+	
+	hw = vp->hw;
+	if (vp->ch >= 0) {
+		snd_emu10k1_ptr_write(hw, IFATN, vp->ch, 0xff00);
+		snd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, 0x807f | DCYSUSV_CHANNELENABLE_MASK);
+		// snd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, 0);
+		snd_emu10k1_ptr_write(hw, VTFT, vp->ch, 0xffff);
+		snd_emu10k1_ptr_write(hw, CVCF, vp->ch, 0xffff);
+		snd_emu10k1_voice_free(hw, &hw->voices[vp->ch]);
+		vp->emu->num_voices--;
+		vp->ch = -1;
+	}
+}
+
+
+/*
+ * update registers
+ */
+static void
+update_voice(snd_emux_voice_t *vp, int update)
+{
+	emu10k1_t *hw;
+	
+	hw = vp->hw;
+	if (update & SNDRV_EMUX_UPDATE_VOLUME)
+		snd_emu10k1_ptr_write(hw, IFATN_ATTENUATION, vp->ch, vp->avol);
+	if (update & SNDRV_EMUX_UPDATE_PITCH)
+		snd_emu10k1_ptr_write(hw, IP, vp->ch, vp->apitch);
+	if (update & SNDRV_EMUX_UPDATE_PAN) {
+		snd_emu10k1_ptr_write(hw, PTRX_FXSENDAMOUNT_A, vp->ch, vp->apan);
+		snd_emu10k1_ptr_write(hw, PTRX_FXSENDAMOUNT_B, vp->ch, vp->aaux);
+	}
+	if (update & SNDRV_EMUX_UPDATE_FMMOD)
+		set_fmmod(hw, vp);
+	if (update & SNDRV_EMUX_UPDATE_TREMFREQ)
+		snd_emu10k1_ptr_write(hw, TREMFRQ, vp->ch, vp->reg.parm.tremfrq);
+	if (update & SNDRV_EMUX_UPDATE_FM2FRQ2)
+		set_fm2frq2(hw, vp);
+	if (update & SNDRV_EMUX_UPDATE_Q)
+		set_filterQ(hw, vp);
+}
+
+
+/*
+ * look up voice table - get the best voice in order of preference
+ */
+/* spinlock held! */
+static void
+lookup_voices(snd_emux_t *emu, emu10k1_t *hw, best_voice_t *best, int active_only)
+{
+	snd_emux_voice_t *vp;
+	best_voice_t *bp;
+	int  i;
+
+	for (i = 0; i < V_END; i++) {
+		best[i].time = (unsigned int)-1; /* XXX MAX_?INT really */;
+		best[i].voice = -1;
+	}
+
+	/*
+	 * Go through them all and get a best one to use.
+	 * NOTE: could also look at volume and pick the quietest one.
+	 */
+	for (i = 0; i < emu->max_voices; i++) {
+		int state, val;
+
+		vp = &emu->voices[i];
+		state = vp->state;
+		if (state == SNDRV_EMUX_ST_OFF) {
+			if (vp->ch < 0) {
+				if (active_only)
+					continue;
+				bp = best + V_FREE;
+			} else
+				bp = best + V_OFF;
+		}
+		else if (state == SNDRV_EMUX_ST_RELEASED ||
+			 state == SNDRV_EMUX_ST_PENDING) {
+			bp = best + V_RELEASED;
+#if 0
+			val = snd_emu10k1_ptr_read(hw, CVCF_CURRENTVOL, vp->ch);
+			if (! val)
+				bp = best + V_OFF;
+#endif
+		}
+		else if (state == SNDRV_EMUX_ST_STANDBY)
+			continue;
+		else if (state & SNDRV_EMUX_ST_ON)
+			bp = best + V_PLAYING;
+		else
+			continue;
+
+		/* check if sample is finished playing (non-looping only) */
+		if (bp != best + V_OFF && bp != best + V_FREE &&
+		    (vp->reg.sample_mode & SNDRV_SFNT_SAMPLE_SINGLESHOT)) {
+			val = snd_emu10k1_ptr_read(hw, CCCA_CURRADDR, vp->ch);
+			if (val >= vp->reg.loopstart)
+				bp = best + V_OFF;
+		}
+
+		if (vp->time < bp->time) {
+			bp->time = vp->time;
+			bp->voice = i;
+		}
+	}
+}
+
+/*
+ * get an empty voice
+ *
+ * emu->voice_lock is already held.
+ */
+static snd_emux_voice_t *
+get_voice(snd_emux_t *emu, snd_emux_port_t *port)
+{
+	emu10k1_t *hw;
+	snd_emux_voice_t *vp;
+	best_voice_t best[V_END];
+	int i;
+
+	hw = emu->hw;
+
+	lookup_voices(emu, hw, best, 0);
+	for (i = 0; i < V_END; i++) {
+		if (best[i].voice >= 0) {
+			vp = &emu->voices[best[i].voice];
+			if (vp->ch < 0) {
+				/* allocate a voice */
+				emu10k1_voice_t *hwvoice;
+				if (snd_emu10k1_voice_alloc(hw, EMU10K1_SYNTH, 1, &hwvoice) < 0 || hwvoice == NULL)
+					continue;
+				vp->ch = hwvoice->number;
+				emu->num_voices++;
+			}
+			return vp;
+		}
+	}
+
+	/* not found */
+	return NULL;
+}
+
+/*
+ * prepare envelopes and LFOs
+ */
+static int
+start_voice(snd_emux_voice_t *vp)
+{
+	unsigned int temp;
+	int ch;
+	unsigned int addr, mapped_offset;
+	snd_midi_channel_t *chan;
+	emu10k1_t *hw;
+	emu10k1_memblk_t *emem;
+	
+	hw = vp->hw;
+	ch = vp->ch;
+	snd_assert(ch >= 0, return -EINVAL);
+	chan = vp->chan;
+
+	emem = (emu10k1_memblk_t *)vp->block;
+	if (emem == NULL)
+		return -EINVAL;
+	emem->map_locked++;
+	if (snd_emu10k1_memblk_map(hw, emem) < 0) {
+		// printk("emu: cannot map!\n");
+		return -ENOMEM;
+	}
+	mapped_offset = snd_emu10k1_memblk_offset(emem) >> 1;
+	vp->reg.start += mapped_offset;
+	vp->reg.end += mapped_offset;
+	vp->reg.loopstart += mapped_offset;
+	vp->reg.loopend += mapped_offset;
+
+	/* set channel routing */
+	/* A = left(0), B = right(1), C = reverb(c), D = chorus(d) */
+	if (hw->audigy) {
+		temp = FXBUS_MIDI_LEFT | (FXBUS_MIDI_RIGHT << 8) | 
+			(FXBUS_MIDI_REVERB << 16) | (FXBUS_MIDI_CHORUS << 24);
+		snd_emu10k1_ptr_write(hw, A_FXRT1, ch, temp);
+	} else {
+		temp = (FXBUS_MIDI_LEFT << 16) | (FXBUS_MIDI_RIGHT << 20) | 
+			(FXBUS_MIDI_REVERB << 24) | (FXBUS_MIDI_CHORUS << 28);
+		snd_emu10k1_ptr_write(hw, FXRT, ch, temp);
+	}
+
+	/* channel to be silent and idle */
+	snd_emu10k1_ptr_write(hw, DCYSUSV, ch, 0x0080);
+	snd_emu10k1_ptr_write(hw, VTFT, ch, 0x0000FFFF);
+	snd_emu10k1_ptr_write(hw, CVCF, ch, 0x0000FFFF);
+	snd_emu10k1_ptr_write(hw, PTRX, ch, 0);
+	snd_emu10k1_ptr_write(hw, CPF, ch, 0);
+
+	/* set pitch offset */
+	snd_emu10k1_ptr_write(hw, IP, vp->ch, vp->apitch);
+
+	/* set envelope parameters */
+	snd_emu10k1_ptr_write(hw, ENVVAL, ch, vp->reg.parm.moddelay);
+	snd_emu10k1_ptr_write(hw, ATKHLDM, ch, vp->reg.parm.modatkhld);
+	snd_emu10k1_ptr_write(hw, DCYSUSM, ch, vp->reg.parm.moddcysus);
+	snd_emu10k1_ptr_write(hw, ENVVOL, ch, vp->reg.parm.voldelay);
+	snd_emu10k1_ptr_write(hw, ATKHLDV, ch, vp->reg.parm.volatkhld);
+	/* decay/sustain parameter for volume envelope is used
+	   for triggerg the voice */
+
+	/* cutoff and volume */
+	temp = (unsigned int)vp->acutoff << 8 | (unsigned char)vp->avol;
+	snd_emu10k1_ptr_write(hw, IFATN, vp->ch, temp);
+
+	/* modulation envelope heights */
+	snd_emu10k1_ptr_write(hw, PEFE, ch, vp->reg.parm.pefe);
+
+	/* lfo1/2 delay */
+	snd_emu10k1_ptr_write(hw, LFOVAL1, ch, vp->reg.parm.lfo1delay);
+	snd_emu10k1_ptr_write(hw, LFOVAL2, ch, vp->reg.parm.lfo2delay);
+
+	/* lfo1 pitch & cutoff shift */
+	set_fmmod(hw, vp);
+	/* lfo1 volume & freq */
+	snd_emu10k1_ptr_write(hw, TREMFRQ, vp->ch, vp->reg.parm.tremfrq);
+	/* lfo2 pitch & freq */
+	set_fm2frq2(hw, vp);
+
+	/* reverb and loop start (reverb 8bit, MSB) */
+	temp = vp->reg.parm.reverb;
+	temp += (int)vp->chan->control[MIDI_CTL_E1_REVERB_DEPTH] * 9 / 10;
+	LIMITMAX(temp, 255);
+	addr = vp->reg.loopstart;
+	snd_emu10k1_ptr_write(hw, PSST, vp->ch, (temp << 24) | addr);
+
+	/* chorus & loop end (chorus 8bit, MSB) */
+	addr = vp->reg.loopend;
+	temp = vp->reg.parm.chorus;
+	temp += (int)chan->control[MIDI_CTL_E3_CHORUS_DEPTH] * 9 / 10;
+	LIMITMAX(temp, 255);
+	temp = (temp <<24) | addr;
+	snd_emu10k1_ptr_write(hw, DSL, ch, temp);
+
+	/* clear filter delay memory */
+	snd_emu10k1_ptr_write(hw, Z1, ch, 0);
+	snd_emu10k1_ptr_write(hw, Z2, ch, 0);
+
+	/* invalidate maps */
+	temp = (hw->silent_page.addr << 1) | MAP_PTI_MASK;
+	snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
+	snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
+#if 0
+	/* cache */
+	{
+		unsigned int val, sample;
+		val = 32;
+		if (vp->reg.sample_mode & SNDRV_SFNT_SAMPLE_8BITS)
+			sample = 0x80808080;
+		else {
+			sample = 0;
+			val *= 2;
+		}
+
+		/* cache */
+		snd_emu10k1_ptr_write(hw, CCR, ch, 0x1c << 16);
+		snd_emu10k1_ptr_write(hw, CDE, ch, sample);
+		snd_emu10k1_ptr_write(hw, CDF, ch, sample);
+
+		/* invalidate maps */
+		temp = ((unsigned int)hw->silent_page.addr << 1) | MAP_PTI_MASK;
+		snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
+		snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
+		
+		/* fill cache */
+		val -= 4;
+		val <<= 25;
+		val |= 0x1c << 16;
+		snd_emu10k1_ptr_write(hw, CCR, ch, val);
+	}
+#endif
+
+	/* Q & current address (Q 4bit value, MSB) */
+	addr = vp->reg.start;
+	temp = vp->reg.parm.filterQ;
+	temp = (temp<<28) | addr;
+	if (vp->apitch < 0xe400)
+		temp |= CCCA_INTERPROM_0;
+	else {
+		unsigned int shift = (vp->apitch - 0xe000) >> 10;
+		temp |= shift << 25;
+	}
+	if (vp->reg.sample_mode & SNDRV_SFNT_SAMPLE_8BITS)
+		temp |= CCCA_8BITSELECT;
+	snd_emu10k1_ptr_write(hw, CCCA, ch, temp);
+
+	/* reset volume */
+	temp = (unsigned int)vp->vtarget << 16;
+	snd_emu10k1_ptr_write(hw, VTFT, ch, temp | vp->ftarget);
+	snd_emu10k1_ptr_write(hw, CVCF, ch, temp | 0xff00);
+	return 0;
+}
+
+/*
+ * Start envelope
+ */
+static void
+trigger_voice(snd_emux_voice_t *vp)
+{
+	unsigned int temp, ptarget;
+	emu10k1_t *hw;
+	emu10k1_memblk_t *emem;
+	
+	hw = vp->hw;
+
+	emem = (emu10k1_memblk_t *)vp->block;
+	if (! emem || emem->mapped_page < 0)
+		return; /* not mapped */
+
+#if 0
+	ptarget = (unsigned int)vp->ptarget << 16;
+#else
+	ptarget = IP_TO_CP(vp->apitch);
+#endif
+	/* set pitch target and pan (volume) */
+	temp = ptarget | (vp->apan << 8) | vp->aaux;
+	snd_emu10k1_ptr_write(hw, PTRX, vp->ch, temp);
+
+	/* pitch target */
+	snd_emu10k1_ptr_write(hw, CPF, vp->ch, ptarget);
+
+	/* trigger voice */
+	snd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, vp->reg.parm.voldcysus|DCYSUSV_CHANNELENABLE_MASK);
+}
+
+#define MOD_SENSE 18
+
+/* set lfo1 modulation height and cutoff */
+static void
+set_fmmod(emu10k1_t *hw, snd_emux_voice_t *vp)
+{
+	unsigned short fmmod;
+	short pitch;
+	unsigned char cutoff;
+	int modulation;
+
+	pitch = (char)(vp->reg.parm.fmmod>>8);
+	cutoff = (vp->reg.parm.fmmod & 0xff);
+	modulation = vp->chan->gm_modulation + vp->chan->midi_pressure;
+	pitch += (MOD_SENSE * modulation) / 1200;
+	LIMITVALUE(pitch, -128, 127);
+	fmmod = ((unsigned char)pitch<<8) | cutoff;
+	snd_emu10k1_ptr_write(hw, FMMOD, vp->ch, fmmod);
+}
+
+/* set lfo2 pitch & frequency */
+static void
+set_fm2frq2(emu10k1_t *hw, snd_emux_voice_t *vp)
+{
+	unsigned short fm2frq2;
+	short pitch;
+	unsigned char freq;
+	int modulation;
+
+	pitch = (char)(vp->reg.parm.fm2frq2>>8);
+	freq = vp->reg.parm.fm2frq2 & 0xff;
+	modulation = vp->chan->gm_modulation + vp->chan->midi_pressure;
+	pitch += (MOD_SENSE * modulation) / 1200;
+	LIMITVALUE(pitch, -128, 127);
+	fm2frq2 = ((unsigned char)pitch<<8) | freq;
+	snd_emu10k1_ptr_write(hw, FM2FRQ2, vp->ch, fm2frq2);
+}
+
+/* set filterQ */
+static void
+set_filterQ(emu10k1_t *hw, snd_emux_voice_t *vp)
+{
+	unsigned int val;
+	val = snd_emu10k1_ptr_read(hw, CCCA, vp->ch) & ~CCCA_RESONANCE;
+	val |= (vp->reg.parm.filterQ << 28);
+	snd_emu10k1_ptr_write(hw, CCCA, vp->ch, val);
+}
