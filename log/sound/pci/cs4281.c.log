commit e157f0cd056af9f2715dd91d55688a7c0fea4608
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:48:16 2020 +0100

    ALSA: cs4281: More constification
    
    Apply const prefix to the static register table.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-62-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index dc89ef906c9b..94d2a6a466a8 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1939,7 +1939,7 @@ static void snd_cs4281_remove(struct pci_dev *pci)
  */
 #ifdef CONFIG_PM_SLEEP
 
-static int saved_regs[SUSPEND_REGISTERS] = {
+static const int saved_regs[SUSPEND_REGISTERS] = {
 	BA0_JSCTL,
 	BA0_GPIOR,
 	BA0_SSCR,

commit d25ff26840bd0af3283d8e478669abc104bb873a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:44 2020 +0100

    ALSA: info: Make snd_info_entry_ops as const
    
    The reference to snd_info_entry_ops is rather read-only, so declare it
    as a const pointer.  This allows a bit more optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-29-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 8fd64dab372d..dc89ef906c9b 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1129,11 +1129,11 @@ static ssize_t snd_cs4281_BA1_read(struct snd_info_entry *entry,
 	return count;
 }
 
-static struct snd_info_entry_ops snd_cs4281_proc_ops_BA0 = {
+static const struct snd_info_entry_ops snd_cs4281_proc_ops_BA0 = {
 	.read = snd_cs4281_BA0_read,
 };
 
-static struct snd_info_entry_ops snd_cs4281_proc_ops_BA1 = {
+static const struct snd_info_entry_ops snd_cs4281_proc_ops_BA1 = {
 	.read = snd_cs4281_BA1_read,
 };
 

commit 51055da51d1e92bb089c9b9e0ecb1be69396f808
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:43 2020 +0100

    ALSA: pci: Constify snd_ac97_bus_ops definitions
    
    Now snd_ac97_bus() takes the const ops pointer, so we can define the
    snd_ac97_bus_ops locally as const as well for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-28-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 75450e329cee..8fd64dab372d 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1064,7 +1064,7 @@ static int snd_cs4281_mixer(struct cs4281 *chip)
 	struct snd_card *card = chip->card;
 	struct snd_ac97_template ac97;
 	int err;
-	static struct snd_ac97_bus_ops ops = {
+	static const struct snd_ac97_bus_ops ops = {
 		.write = snd_cs4281_ac97_write,
 		.read = snd_cs4281_ac97_read,
 	};

commit efb0ad25d370344e61bb4fca8c3b9c3c6047922e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:25 2020 +0100

    ALSA: pci: Constify snd_device_ops definitions
    
    Now we may declare const for snd_device_ops definitions, so let's do
    it for optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-10-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index e7294b9d2cb6..75450e329cee 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1304,7 +1304,7 @@ static int snd_cs4281_create(struct snd_card *card,
 	struct cs4281 *chip;
 	unsigned int tmp;
 	int err;
-	static struct snd_device_ops ops = {
+	static const struct snd_device_ops ops = {
 		.dev_free =	snd_cs4281_dev_free,
 	};
 

commit 5afff8c1bbc7c5d9a092b217dd27040ccd5b347a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:10 2019 +0100

    ALSA: cs4281: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation, as well as removing the superfluous synchronize_irq()
    call.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-12-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 0dcb2d15b560..e7294b9d2cb6 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1268,9 +1268,6 @@ static int snd_cs4281_free(struct cs4281 *chip)
 {
 	snd_cs4281_free_gameport(chip);
 
-	if (chip->irq >= 0)
-		synchronize_irq(chip->irq);
-
 	/* Mask interrupts */
 	snd_cs4281_pokeBA0(chip, BA0_HIMR, 0x7fffffff);
 	/* Stop the DLL Clock logic. */
@@ -1352,6 +1349,7 @@ static int snd_cs4281_create(struct snd_card *card,
 		return -ENOMEM;
 	}
 	chip->irq = pci->irq;
+	card->sync_irq = chip->irq;
 
 	tmp = snd_cs4281_chip_init(chip);
 	if (tmp) {
@@ -1600,7 +1598,6 @@ static int snd_cs4281_chip_init(struct cs4281 *chip)
 					BA0_HISR_DMA(1) |
 					BA0_HISR_DMA(2) |
 					BA0_HISR_DMA(3)));
-	synchronize_irq(chip->irq);
 
 	return 0;
 }

commit d34e1b7b9a7fa87fc5309447e4a14bd511de4bc9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:11:37 2019 +0100

    ALSA: pci: Drop superfluous ioctl PCM ops
    
    PCM core deals the empty ioctl field now as default(*).
    Let's kill the redundant lines.
    
    (*) commit fc033cbf6fb7 ("ALSA: pcm: Allow NULL ioctl ops")
    
    Link: https://lore.kernel.org/r/20191210061145.24641-16-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index ea665d42107e..0dcb2d15b560 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -927,7 +927,6 @@ static int snd_cs4281_capture_close(struct snd_pcm_substream *substream)
 static const struct snd_pcm_ops snd_cs4281_playback_ops = {
 	.open =		snd_cs4281_playback_open,
 	.close =	snd_cs4281_playback_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_cs4281_playback_prepare,
 	.trigger =	snd_cs4281_trigger,
 	.pointer =	snd_cs4281_pointer,
@@ -936,7 +935,6 @@ static const struct snd_pcm_ops snd_cs4281_playback_ops = {
 static const struct snd_pcm_ops snd_cs4281_capture_ops = {
 	.open =		snd_cs4281_capture_open,
 	.close =	snd_cs4281_capture_close,
-	.ioctl =	snd_pcm_lib_ioctl,
 	.prepare =	snd_cs4281_capture_prepare,
 	.trigger =	snd_cs4281_trigger,
 	.pointer =	snd_cs4281_pointer,

commit 44e78a1a85ad5b893dda6cbf866e9e14acf71e0d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Dec 9 10:49:03 2019 +0100

    ALSA: cs4281: Use managed buffer allocation
    
    Clean up the driver with the new managed buffer allocation API.
    The hw_params and hw_free callbacks became superfluous and got
    dropped.
    
    Link: https://lore.kernel.org/r/20191209094943.14984-32-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 058c1414b777..ea665d42107e 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -780,17 +780,6 @@ static void snd_cs4281_mode(struct cs4281 *chip, struct cs4281_dma *dma,
 	snd_cs4281_pokeBA0(chip, dma->regFSIC, 0);
 }
 
-static int snd_cs4281_hw_params(struct snd_pcm_substream *substream,
-				struct snd_pcm_hw_params *hw_params)
-{
-	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
-}
-
-static int snd_cs4281_hw_free(struct snd_pcm_substream *substream)
-{
-	return snd_pcm_lib_free_pages(substream);
-}
-
 static int snd_cs4281_playback_prepare(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -939,8 +928,6 @@ static const struct snd_pcm_ops snd_cs4281_playback_ops = {
 	.open =		snd_cs4281_playback_open,
 	.close =	snd_cs4281_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_cs4281_hw_params,
-	.hw_free =	snd_cs4281_hw_free,
 	.prepare =	snd_cs4281_playback_prepare,
 	.trigger =	snd_cs4281_trigger,
 	.pointer =	snd_cs4281_pointer,
@@ -950,8 +937,6 @@ static const struct snd_pcm_ops snd_cs4281_capture_ops = {
 	.open =		snd_cs4281_capture_open,
 	.close =	snd_cs4281_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
-	.hw_params =	snd_cs4281_hw_params,
-	.hw_free =	snd_cs4281_hw_free,
 	.prepare =	snd_cs4281_capture_prepare,
 	.trigger =	snd_cs4281_trigger,
 	.pointer =	snd_cs4281_pointer,
@@ -974,9 +959,8 @@ static int snd_cs4281_pcm(struct cs4281 *chip, int device)
 	strcpy(pcm->name, "CS4281");
 	chip->pcm = pcm;
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      &chip->pci->dev,
-					      64*1024, 512*1024);
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, &chip->pci->dev,
+				       64*1024, 512*1024);
 
 	return 0;
 }

commit 6974f8ad44946701779209cb03cd8c6b598c3342
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:55 2019 +0100

    ALSA: pci: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-24-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 04c712647853..058c1414b777 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -975,7 +975,8 @@ static int snd_cs4281_pcm(struct cs4281 *chip, int device)
 	chip->pcm = pcm;
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
-					      snd_dma_pci_data(chip->pci), 64*1024, 512*1024);
+					      &chip->pci->dev,
+					      64*1024, 512*1024);
 
 	return 0;
 }

commit 3c53c6255d598db7084c5c3d7553d7200e857818
Merge: b89b889a326a a98429acadef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 8 14:45:20 2019 +0200

    Merge tag 'asoc-v5.3' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.3
    
    This is a very big update, mainly thanks to Morimoto-san's refactoring
    work and some fairly large new drivers.
    
     - Lots more work on moving towards a component based framework from
       Morimoto-san.
     - Support for force disconnecting muxes from Jerome Brunet.
     - New drivers for Cirrus Logic CS47L35, CS47L85 and CS47L90, Conexant
       CX2072X, Realtek RT1011 and RT1308.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 388b00f045180179fedff4b108d40a0192684cda
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Jul 5 10:57:04 2019 +0100

    ALSA: cs4281: remove redundant assignment to variable val and remove a goto
    
    The variable val is being assigned with a value that is never
    read and it is being updated later with a new value. The
    assignment is redundant and can be removed.  Also remove a
    goto statement and a label and replace with a break statement.
    
    Addresses-Coverity: ("Unused value")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 15bbf9564c82..d271cb881948 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -709,7 +709,7 @@ static int snd_cs4281_trigger(struct snd_pcm_substream *substream, int cmd)
 
 static unsigned int snd_cs4281_rate(unsigned int rate, unsigned int *real_rate)
 {
-	unsigned int val = ~0;
+	unsigned int val;
 	
 	if (real_rate)
 		*real_rate = rate;
@@ -722,9 +722,8 @@ static unsigned int snd_cs4281_rate(unsigned int rate, unsigned int *real_rate)
 	case 44100:	return 1;
 	case 48000:	return 0;
 	default:
-		goto __variable;
+		break;
 	}
-      __variable:
 	val = 1536000 / rate;
 	if (real_rate)
 		*real_rate = 1536000 / val;

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 15bbf9564c82..a2cce3ecda6f 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1,22 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Driver for Cirrus Logic CS4281 based PCI soundcard
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>,
- *
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 #include <linux/io.h>

commit 47f2769b4b2e267cba135fc19c89c32d202b1415
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:01:39 2019 +0100

    ALSA: pci: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index a9fb819cad1d..15bbf9564c82 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1174,8 +1174,7 @@ static void snd_cs4281_proc_init(struct cs4281 *chip)
 {
 	struct snd_info_entry *entry;
 
-	if (! snd_card_proc_new(chip->card, "cs4281", &entry))
-		snd_info_set_text_ops(entry, chip, snd_cs4281_proc_read);
+	snd_card_ro_proc_new(chip->card, "cs4281", chip, snd_cs4281_proc_read);
 	if (! snd_card_proc_new(chip->card, "cs4281_BA0", &entry)) {
 		entry->content = SNDRV_INFO_CONTENT_DATA;
 		entry->private_data = chip;

commit 17bc4815de586d001c82d0ddf75247283c3f002a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 11 18:02:51 2019 +0100

    ALSA: pci: Remove superfluous snd_pcm_suspend*() calls
    
    The call of snd_pcm_suspend_all() & co became superfluous since we
    call it in the PCM PM ops.  Let's remove them.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index ec4247638fa1..a9fb819cad1d 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -2002,8 +2002,6 @@ static int cs4281_suspend(struct device *dev)
 	unsigned int i;
 
 	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
-	snd_pcm_suspend_all(chip->pcm);
-
 	snd_ac97_suspend(chip->ac97);
 	snd_ac97_suspend(chip->ac97_secondary);
 

commit dee49895b197936c02d27d651e58c90bac18f452
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 12 21:01:28 2017 +0530

    ALSA: pci: make snd_pcm_hardware const
    
    Make these const as they are only used during a copy operation.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index ee7ba4b0b47b..ec4247638fa1 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -847,7 +847,7 @@ static snd_pcm_uframes_t snd_cs4281_pointer(struct snd_pcm_substream *substream)
 	       snd_cs4281_peekBA0(chip, dma->regDCC) - 1;
 }
 
-static struct snd_pcm_hardware snd_cs4281_playback =
+static const struct snd_pcm_hardware snd_cs4281_playback =
 {
 	.info =			SNDRV_PCM_INFO_MMAP |
 				SNDRV_PCM_INFO_INTERLEAVED |
@@ -872,7 +872,7 @@ static struct snd_pcm_hardware snd_cs4281_playback =
 	.fifo_size =		CS4281_FIFO_SIZE,
 };
 
-static struct snd_pcm_hardware snd_cs4281_capture =
+static const struct snd_pcm_hardware snd_cs4281_capture =
 {
 	.info =			SNDRV_PCM_INFO_MMAP |
 				SNDRV_PCM_INFO_INTERLEAVED |

commit 667011706707f91f53122259f62d260cfc01a96d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri May 12 11:55:17 2017 +0200

    ALSA: cs4281: Fix the leftover comment
    
    The comment at endif line was forgotten to be corrected when the
    condition was converted to IS_REACHABLE().  Fix it, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index f870697aca67..ee7ba4b0b47b 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1296,7 +1296,7 @@ static void snd_cs4281_free_gameport(struct cs4281 *chip)
 #else
 static inline int snd_cs4281_create_gameport(struct cs4281 *chip) { return -ENOSYS; }
 static inline void snd_cs4281_free_gameport(struct cs4281 *chip) { }
-#endif /* CONFIG_GAMEPORT || (MODULE && CONFIG_GAMEPORT_MODULE) */
+#endif /* IS_REACHABLE(CONFIG_GAMEPORT) */
 
 static int snd_cs4281_free(struct cs4281 *chip)
 {

commit f3b827e0b1841f4cfc18436e09f4f269f3be908e
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Mon Feb 20 00:18:09 2017 +0530

    ALSA: pci: constify snd_kcontrol_new structures
    
    Declare snd_kcontrol_new structures as const as they are only passed as
    an argument to the function snd_ctl_new1. This argument is of type
    const, so snd_kcontrol_new structures having the same property can be
    made const too.
    Done using Coccinelle:
    
    @r1 disable optional_qualifier @
    identifier i;
    position p;
    @@
    static struct snd_kcontrol_new i@p = {...};
    
    @ok1@
    identifier r1.i;
    position p;
    expression e1;
    @@
    snd_ctl_new1(&i@p,e1)
    
    @bad@
    position p!={r1.p,ok1.p};
    identifier r1.i;
    @@
    i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r1.i;
    @@
    +const
    struct snd_kcontrol_new i;
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index fa7c51684dd2..f870697aca67 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1055,7 +1055,7 @@ static int snd_cs4281_put_volume(struct snd_kcontrol *kcontrol,
 
 static const DECLARE_TLV_DB_SCALE(db_scale_dsp, -4650, 150, 0);
 
-static struct snd_kcontrol_new snd_cs4281_fm_vol = 
+static const struct snd_kcontrol_new snd_cs4281_fm_vol =
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Synth Playback Volume",
@@ -1066,7 +1066,7 @@ static struct snd_kcontrol_new snd_cs4281_fm_vol =
 	.tlv = { .p = db_scale_dsp },
 };
 
-static struct snd_kcontrol_new snd_cs4281_pcm_vol = 
+static const struct snd_kcontrol_new snd_cs4281_pcm_vol =
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "PCM Stream Playback Volume",

commit 485885b9d0474ac374297e637f479c22930bb593
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 5 17:29:31 2017 +0100

    ALSA: pci: Constify snd_rawmidi_ops
    
    Now snd_rawmidi_ops is maintained as a const pointer in snd_rawmidi,
    we can constify the definitions.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 8f0f5f24e40e..fa7c51684dd2 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1767,14 +1767,14 @@ static void snd_cs4281_midi_output_trigger(struct snd_rawmidi_substream *substre
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 }
 
-static struct snd_rawmidi_ops snd_cs4281_midi_output =
+static const struct snd_rawmidi_ops snd_cs4281_midi_output =
 {
 	.open =		snd_cs4281_midi_output_open,
 	.close =	snd_cs4281_midi_output_close,
 	.trigger =	snd_cs4281_midi_output_trigger,
 };
 
-static struct snd_rawmidi_ops snd_cs4281_midi_input =
+static const struct snd_rawmidi_ops snd_cs4281_midi_input =
 {
 	.open = 	snd_cs4281_midi_input_open,
 	.close =	snd_cs4281_midi_input_close,

commit b2fac0730347d591b528d8f0e4a9438c1bb6f558
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sat Nov 12 23:26:41 2016 +0100

    ALSA: pci: don't opencode IS_REACHABLE()
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 615d8a99d8c8..8f0f5f24e40e 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1194,7 +1194,7 @@ static void snd_cs4281_proc_init(struct cs4281 *chip)
  * joystick support
  */
 
-#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+#if IS_REACHABLE(CONFIG_GAMEPORT)
 
 static void snd_cs4281_gameport_trigger(struct gameport *gameport)
 {

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index c296fd0dbc9c..615d8a99d8c8 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -951,7 +951,7 @@ static int snd_cs4281_capture_close(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static struct snd_pcm_ops snd_cs4281_playback_ops = {
+static const struct snd_pcm_ops snd_cs4281_playback_ops = {
 	.open =		snd_cs4281_playback_open,
 	.close =	snd_cs4281_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -962,7 +962,7 @@ static struct snd_pcm_ops snd_cs4281_playback_ops = {
 	.pointer =	snd_cs4281_pointer,
 };
 
-static struct snd_pcm_ops snd_cs4281_capture_ops = {
+static const struct snd_pcm_ops snd_cs4281_capture_ops = {
 	.open =		snd_cs4281_capture_open,
 	.close =	snd_cs4281_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 754613b772ab..c296fd0dbc9c 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -19,7 +19,7 @@
  *
  */
 
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>

commit 9e5947465d72ef1b3a88104474ab2adf78837220
Merge: 624afe4dc9a0 3e41c9b5a1ca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 11 11:26:48 2015 +0100

    Merge branch 'topic/pci-cleanup' into for-next

commit faab5223930114b0a33f8c712c14799967342e8c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 8 12:45:22 2015 +0100

    ALSA: cs4281: Simplify PM callbacks
    
    This is a similar cleanup like the commit [3db084fd0af5: ALSA: fm801:
    PCI core handles power state for us].
    
    Since pci_set_power_state(), pci_save_state() and pci_restore_state()
    are already done in the PCI core side, so we don't need to it doubly.
    
    Also, pci_enable_device(), pci_disable_device() and pci_set_master()
    calls in PM callbacks are superfluous nowadays, too, so get rid of
    them as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 4c49b5c8a7b3..80bb1d11da12 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -2008,7 +2008,6 @@ static int saved_regs[SUSPEND_REGISTERS] = {
 
 static int cs4281_suspend(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct cs4281 *chip = card->private_data;
 	u32 ulCLK;
@@ -2047,30 +2046,16 @@ static int cs4281_suspend(struct device *dev)
 	ulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);
 	ulCLK &= ~CLKCR1_CKRA;
 	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);
-
-	pci_disable_device(pci);
-	pci_save_state(pci);
-	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
 static int cs4281_resume(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct cs4281 *chip = card->private_data;
 	unsigned int i;
 	u32 ulCLK;
 
-	pci_set_power_state(pci, PCI_D0);
-	pci_restore_state(pci);
-	if (pci_enable_device(pci) < 0) {
-		dev_err(dev, "pci_enable_device failed, disabling device\n");
-		snd_card_disconnect(card);
-		return -EIO;
-	}
-	pci_set_master(pci);
-
 	ulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);
 	ulCLK |= CLKCR1_CKRA;
 	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);

commit ff6defa6a8fae12205d64f55db395b1fcf35af8e
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jan 3 22:55:54 2015 +0100

    ALSA: Deletion of checks before the function call "iounmap"
    
    The iounmap() function performs also input parameter validation.
    Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 05a4337f8116..ea339111c59f 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1316,10 +1316,8 @@ static int snd_cs4281_free(struct cs4281 *chip)
 
 	if (chip->irq >= 0)
 		free_irq(chip->irq, chip);
-	if (chip->ba0)
-		iounmap(chip->ba0);
-	if (chip->ba1)
-		iounmap(chip->ba1);
+	iounmap(chip->ba0);
+	iounmap(chip->ba1);
 	pci_release_regions(chip->pci);
 	pci_disable_device(chip->pci);
 

commit 3e4f4776f427ddeeba6972f34cca04df478a67b4
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Jan 2 12:24:46 2015 +0100

    ALSA: cs4281: Remove always NULL parameters
    
    snd_cs4281_pcm() and snd_cs4281_midi() take a pointer to a pointer of a
    PCM/MIDI object where if this parameter is provided the newly allocated
    object is stored. All callers pass NULL though, so remove the parameter.
    This makes the code a bit shorter and cleaner.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 4c49b5c8a7b3..05a4337f8116 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -973,14 +973,11 @@ static struct snd_pcm_ops snd_cs4281_capture_ops = {
 	.pointer =	snd_cs4281_pointer,
 };
 
-static int snd_cs4281_pcm(struct cs4281 *chip, int device,
-			  struct snd_pcm **rpcm)
+static int snd_cs4281_pcm(struct cs4281 *chip, int device)
 {
 	struct snd_pcm *pcm;
 	int err;
 
-	if (rpcm)
-		*rpcm = NULL;
 	err = snd_pcm_new(chip->card, "CS4281", device, 1, 1, &pcm);
 	if (err < 0)
 		return err;
@@ -996,8 +993,6 @@ static int snd_cs4281_pcm(struct cs4281 *chip, int device,
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
 					      snd_dma_pci_data(chip->pci), 64*1024, 512*1024);
 
-	if (rpcm)
-		*rpcm = pcm;
 	return 0;
 }
 
@@ -1788,14 +1783,11 @@ static struct snd_rawmidi_ops snd_cs4281_midi_input =
 	.trigger =	snd_cs4281_midi_input_trigger,
 };
 
-static int snd_cs4281_midi(struct cs4281 *chip, int device,
-			   struct snd_rawmidi **rrawmidi)
+static int snd_cs4281_midi(struct cs4281 *chip, int device)
 {
 	struct snd_rawmidi *rmidi;
 	int err;
 
-	if (rrawmidi)
-		*rrawmidi = NULL;
 	if ((err = snd_rawmidi_new(chip->card, "CS4281", device, 1, 1, &rmidi)) < 0)
 		return err;
 	strcpy(rmidi->name, "CS4281");
@@ -1804,8 +1796,6 @@ static int snd_cs4281_midi(struct cs4281 *chip, int device,
 	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT | SNDRV_RAWMIDI_INFO_DUPLEX;
 	rmidi->private_data = chip;
 	chip->rmidi = rmidi;
-	if (rrawmidi)
-		*rrawmidi = rmidi;
 	return 0;
 }
 
@@ -1941,11 +1931,11 @@ static int snd_cs4281_probe(struct pci_dev *pci,
 		snd_card_free(card);
 		return err;
 	}
-	if ((err = snd_cs4281_pcm(chip, 0, NULL)) < 0) {
+	if ((err = snd_cs4281_pcm(chip, 0)) < 0) {
 		snd_card_free(card);
 		return err;
 	}
-	if ((err = snd_cs4281_midi(chip, 0, NULL)) < 0) {
+	if ((err = snd_cs4281_midi(chip, 0)) < 0) {
 		snd_card_free(card);
 		return err;
 	}

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 43d1f912c641..4c49b5c8a7b3 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -494,7 +494,7 @@ struct cs4281 {
 
 static irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id);
 
-static DEFINE_PCI_DEVICE_TABLE(snd_cs4281_ids) = {
+static const struct pci_device_id snd_cs4281_ids[] = {
 	{ PCI_VDEVICE(CIRRUS, 0x6005), 0, },	/* CS4281 */
 	{ 0, }
 };

commit b055e7b483b92bec1c9fbc27cc5436d80c749f65
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Feb 25 14:11:14 2014 +0100

    ALSA: cs4281: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 2bd55177b1ae..43d1f912c641 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -564,7 +564,8 @@ static void snd_cs4281_ac97_write(struct snd_ac97 *ac97,
 			return;
 		}
 	}
-	snd_printk(KERN_ERR "AC'97 write problem, reg = 0x%x, val = 0x%x\n", reg, val);
+	dev_err(chip->card->dev,
+		"AC'97 write problem, reg = 0x%x, val = 0x%x\n", reg, val);
 }
 
 static unsigned short snd_cs4281_ac97_read(struct snd_ac97 *ac97,
@@ -624,7 +625,8 @@ static unsigned short snd_cs4281_ac97_read(struct snd_ac97 *ac97,
 			goto __ok1;
 	}
 
-	snd_printk(KERN_ERR "AC'97 read problem (ACCTL_DCV), reg = 0x%x\n", reg);
+	dev_err(chip->card->dev,
+		"AC'97 read problem (ACCTL_DCV), reg = 0x%x\n", reg);
 	result = 0xffff;
 	goto __end;
 	
@@ -643,7 +645,8 @@ static unsigned short snd_cs4281_ac97_read(struct snd_ac97 *ac97,
 		udelay(10);
 	}
 	
-	snd_printk(KERN_ERR "AC'97 read problem (ACSTS_VSTS), reg = 0x%x\n", reg);
+	dev_err(chip->card->dev,
+		"AC'97 read problem (ACSTS_VSTS), reg = 0x%x\n", reg);
 	result = 0xffff;
 	goto __end;
 
@@ -835,8 +838,9 @@ static snd_pcm_uframes_t snd_cs4281_pointer(struct snd_pcm_substream *substream)
 	struct cs4281 *chip = snd_pcm_substream_chip(substream);
 
 	/*
-	printk(KERN_DEBUG "DCC = 0x%x, buffer_size = 0x%x, jiffies = %li\n",
-	       snd_cs4281_peekBA0(chip, dma->regDCC), runtime->buffer_size,
+	dev_dbg(chip->card->dev,
+		"DCC = 0x%x, buffer_size = 0x%x, jiffies = %li\n",
+		snd_cs4281_peekBA0(chip, dma->regDCC), runtime->buffer_size,
 	       jiffies);
 	*/
 	return runtime->buffer_size -
@@ -1265,7 +1269,8 @@ static int snd_cs4281_create_gameport(struct cs4281 *chip)
 
 	chip->gameport = gp = gameport_allocate_port();
 	if (!gp) {
-		printk(KERN_ERR "cs4281: cannot allocate memory for gameport\n");
+		dev_err(chip->card->dev,
+			"cannot allocate memory for gameport\n");
 		return -ENOMEM;
 	}
 
@@ -1361,7 +1366,7 @@ static int snd_cs4281_create(struct snd_card *card,
 	chip->irq = -1;
 	pci_set_master(pci);
 	if (dual_codec < 0 || dual_codec > 3) {
-		snd_printk(KERN_ERR "invalid dual_codec option %d\n", dual_codec);
+		dev_err(card->dev, "invalid dual_codec option %d\n", dual_codec);
 		dual_codec = 0;
 	}
 	chip->dual_codec = dual_codec;
@@ -1383,7 +1388,7 @@ static int snd_cs4281_create(struct snd_card *card,
 	
 	if (request_irq(pci->irq, snd_cs4281_interrupt, IRQF_SHARED,
 			KBUILD_MODNAME, chip)) {
-		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		dev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);
 		snd_cs4281_free(chip);
 		return -ENOMEM;
 	}
@@ -1423,7 +1428,8 @@ static int snd_cs4281_chip_init(struct cs4281 *chip)
 		snd_cs4281_pokeBA0(chip, BA0_CFLR, BA0_CFLR_DEFAULT);
 		tmp = snd_cs4281_peekBA0(chip, BA0_CFLR);
 		if (tmp != BA0_CFLR_DEFAULT) {
-			snd_printk(KERN_ERR "CFLR setup failed (0x%x)\n", tmp);
+			dev_err(chip->card->dev,
+				"CFLR setup failed (0x%x)\n", tmp);
 			return -EIO;
 		}
 	}
@@ -1434,11 +1440,13 @@ static int snd_cs4281_chip_init(struct cs4281 *chip)
 	snd_cs4281_pokeBA0(chip, BA0_CWPR, 0x4281);
 	
 	if ((tmp = snd_cs4281_peekBA0(chip, BA0_SERC1)) != (BA0_SERC1_SO1EN | BA0_SERC1_AC97)) {
-		snd_printk(KERN_ERR "SERC1 AC'97 check failed (0x%x)\n", tmp);
+		dev_err(chip->card->dev,
+			"SERC1 AC'97 check failed (0x%x)\n", tmp);
 		return -EIO;
 	}
 	if ((tmp = snd_cs4281_peekBA0(chip, BA0_SERC2)) != (BA0_SERC2_SI1EN | BA0_SERC2_AC97)) {
-		snd_printk(KERN_ERR "SERC2 AC'97 check failed (0x%x)\n", tmp);
+		dev_err(chip->card->dev,
+			"SERC2 AC'97 check failed (0x%x)\n", tmp);
 		return -EIO;
 	}
 
@@ -1500,7 +1508,7 @@ static int snd_cs4281_chip_init(struct cs4281 *chip)
 		schedule_timeout_uninterruptible(1);
 	} while (time_after_eq(end_time, jiffies));
 
-	snd_printk(KERN_ERR "DLLRDY not seen\n");
+	dev_err(chip->card->dev, "DLLRDY not seen\n");
 	return -EIO;
 
       __ok0:
@@ -1526,7 +1534,9 @@ static int snd_cs4281_chip_init(struct cs4281 *chip)
 		schedule_timeout_uninterruptible(1);
 	} while (time_after_eq(end_time, jiffies));
 
-	snd_printk(KERN_ERR "never read codec ready from AC'97 (0x%x)\n", snd_cs4281_peekBA0(chip, BA0_ACSTS));
+	dev_err(chip->card->dev,
+		"never read codec ready from AC'97 (0x%x)\n",
+		snd_cs4281_peekBA0(chip, BA0_ACSTS));
 	return -EIO;
 
       __ok1:
@@ -1537,7 +1547,8 @@ static int snd_cs4281_chip_init(struct cs4281 *chip)
 				goto __codec2_ok;
 			schedule_timeout_uninterruptible(1);
 		} while (time_after_eq(end_time, jiffies));
-		snd_printk(KERN_INFO "secondary codec doesn't respond. disable it...\n");
+		dev_info(chip->card->dev,
+			 "secondary codec doesn't respond. disable it...\n");
 		chip->dual_codec = 0;
 	__codec2_ok: ;
 	}
@@ -1567,7 +1578,7 @@ static int snd_cs4281_chip_init(struct cs4281 *chip)
 
 	if (--retry_count > 0)
 		goto __retry;
-	snd_printk(KERN_ERR "never read ISV3 and ISV4 from AC'97\n");
+	dev_err(chip->card->dev, "never read ISV3 and ISV4 from AC'97\n");
 	return -EIO;
 
       __ok2:
@@ -2054,8 +2065,7 @@ static int cs4281_resume(struct device *dev)
 	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
 	if (pci_enable_device(pci) < 0) {
-		printk(KERN_ERR "cs4281: pci_enable_device failed, "
-		       "disabling device\n");
+		dev_err(dev, "pci_enable_device failed, disabling device\n");
 		snd_card_disconnect(card);
 		return -EIO;
 	}

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 1dc793e742d7..2bd55177b1ae 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1402,8 +1402,6 @@ static int snd_cs4281_create(struct snd_card *card,
 
 	snd_cs4281_proc_init(chip);
 
-	snd_card_set_dev(card, &pci->dev);
-
 	*rchip = chip;
 	return 0;
 }
@@ -1917,7 +1915,8 @@ static int snd_cs4281_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,
+			   0, &card);
 	if (err < 0)
 		return err;
 

commit db10e7fbbc836fb66d4500c64c1960940cfad2b0
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Thu Jun 27 20:55:11 2013 +0800

    ALSA: pci: trivial: replace numeric with standard PM state macros
    
    Use standard PM state macros PCI_Dx instead of numeric 0/1/2..
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 64659facd155..1dc793e742d7 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1312,7 +1312,7 @@ static int snd_cs4281_free(struct cs4281 *chip)
 	/* Sound System Power Management - Turn Everything OFF */
 	snd_cs4281_pokeBA0(chip, BA0_SSPM, 0);
 	/* PCI interface - D3 state */
-	pci_set_power_state(chip->pci, 3);
+	pci_set_power_state(chip->pci, PCI_D3hot);
 
 	if (chip->irq >= 0)
 		free_irq(chip->irq, chip);

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 6a8695069941..64659facd155 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1971,7 +1971,6 @@ static int snd_cs4281_probe(struct pci_dev *pci,
 static void snd_cs4281_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 /*

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 8e86ec0031fc..6a8695069941 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -969,8 +969,8 @@ static struct snd_pcm_ops snd_cs4281_capture_ops = {
 	.pointer =	snd_cs4281_pointer,
 };
 
-static int __devinit snd_cs4281_pcm(struct cs4281 * chip, int device,
-				    struct snd_pcm ** rpcm)
+static int snd_cs4281_pcm(struct cs4281 *chip, int device,
+			  struct snd_pcm **rpcm)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -1093,7 +1093,7 @@ static void snd_cs4281_mixer_free_ac97(struct snd_ac97 *ac97)
 		chip->ac97 = NULL;
 }
 
-static int __devinit snd_cs4281_mixer(struct cs4281 * chip)
+static int snd_cs4281_mixer(struct cs4281 *chip)
 {
 	struct snd_card *card = chip->card;
 	struct snd_ac97_template ac97;
@@ -1171,7 +1171,7 @@ static struct snd_info_entry_ops snd_cs4281_proc_ops_BA1 = {
 	.read = snd_cs4281_BA1_read,
 };
 
-static void __devinit snd_cs4281_proc_init(struct cs4281 * chip)
+static void snd_cs4281_proc_init(struct cs4281 *chip)
 {
 	struct snd_info_entry *entry;
 
@@ -1259,7 +1259,7 @@ static int snd_cs4281_gameport_open(struct gameport *gameport, int mode)
 	return 0;
 }
 
-static int __devinit snd_cs4281_create_gameport(struct cs4281 *chip)
+static int snd_cs4281_create_gameport(struct cs4281 *chip)
 {
 	struct gameport *gp;
 
@@ -1335,10 +1335,10 @@ static int snd_cs4281_dev_free(struct snd_device *device)
 
 static int snd_cs4281_chip_init(struct cs4281 *chip); /* defined below */
 
-static int __devinit snd_cs4281_create(struct snd_card *card,
-				       struct pci_dev *pci,
-				       struct cs4281 ** rchip,
-				       int dual_codec)
+static int snd_cs4281_create(struct snd_card *card,
+			     struct pci_dev *pci,
+			     struct cs4281 **rchip,
+			     int dual_codec)
 {
 	struct cs4281 *chip;
 	unsigned int tmp;
@@ -1779,8 +1779,8 @@ static struct snd_rawmidi_ops snd_cs4281_midi_input =
 	.trigger =	snd_cs4281_midi_input_trigger,
 };
 
-static int __devinit snd_cs4281_midi(struct cs4281 * chip, int device,
-				     struct snd_rawmidi **rrawmidi)
+static int snd_cs4281_midi(struct cs4281 *chip, int device,
+			   struct snd_rawmidi **rrawmidi)
 {
 	struct snd_rawmidi *rmidi;
 	int err;
@@ -1901,8 +1901,8 @@ static void snd_cs4281_opl3_command(struct snd_opl3 *opl3, unsigned short cmd,
 	spin_unlock_irqrestore(&opl3->reg_lock, flags);
 }
 
-static int __devinit snd_cs4281_probe(struct pci_dev *pci,
-				      const struct pci_device_id *pci_id)
+static int snd_cs4281_probe(struct pci_dev *pci,
+			    const struct pci_device_id *pci_id)
 {
 	static int dev;
 	struct snd_card *card;
@@ -1968,7 +1968,7 @@ static int __devinit snd_cs4281_probe(struct pci_dev *pci,
 	return 0;
 }
 
-static void __devexit snd_cs4281_remove(struct pci_dev *pci)
+static void snd_cs4281_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -2095,7 +2095,7 @@ static struct pci_driver cs4281_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_cs4281_ids,
 	.probe = snd_cs4281_probe,
-	.remove = __devexit_p(snd_cs4281_remove),
+	.remove = snd_cs4281_remove,
 	.driver = {
 		.pm = CS4281_PM_OPS,
 	},

commit c7561cd80469f2fe4a6be0984db57832ee7f2a3b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 14 18:12:04 2012 +0200

    ALSA: PCI: Replace CONFIG_PM with CONFIG_PM_SLEEP
    
    Otherwise we may get compile warnings due to unused functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 45a8317085f4..8e86ec0031fc 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -486,7 +486,7 @@ struct cs4281 {
 
 	struct gameport *gameport;
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	u32 suspend_regs[SUSPEND_REGISTERS];
 #endif
 
@@ -1977,7 +1977,7 @@ static void __devexit snd_cs4281_remove(struct pci_dev *pci)
 /*
  * Power Management
  */
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 
 static int saved_regs[SUSPEND_REGISTERS] = {
 	BA0_JSCTL,
@@ -2089,7 +2089,7 @@ static SIMPLE_DEV_PM_OPS(cs4281_pm, cs4281_suspend, cs4281_resume);
 #define CS4281_PM_OPS	&cs4281_pm
 #else
 #define CS4281_PM_OPS	NULL
-#endif /* CONFIG_PM */
+#endif /* CONFIG_PM_SLEEP */
 
 static struct pci_driver cs4281_driver = {
 	.name = KBUILD_MODNAME,

commit 68cb2b559278858ef9f3a7722f95df88797c7840
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 2 15:20:37 2012 +0200

    ALSA: Convert to new pm_ops for PCI drivers
    
    Straightforward conversion to the new pm_ops from the legacy
    suspend/resume ops.
    
    Since we change vx222, vx_core and vxpocket have to be converted,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 33506ee569bd..45a8317085f4 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1997,9 +1997,10 @@ static int saved_regs[SUSPEND_REGISTERS] = {
 
 #define CLKCR1_CKRA                             0x00010000L
 
-static int cs4281_suspend(struct pci_dev *pci, pm_message_t state)
+static int cs4281_suspend(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct cs4281 *chip = card->private_data;
 	u32 ulCLK;
 	unsigned int i;
@@ -2040,13 +2041,14 @@ static int cs4281_suspend(struct pci_dev *pci, pm_message_t state)
 
 	pci_disable_device(pci);
 	pci_save_state(pci);
-	pci_set_power_state(pci, pci_choose_state(pci, state));
+	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
 
-static int cs4281_resume(struct pci_dev *pci)
+static int cs4281_resume(struct device *dev)
 {
-	struct snd_card *card = pci_get_drvdata(pci);
+	struct pci_dev *pci = to_pci_dev(dev);
+	struct snd_card *card = dev_get_drvdata(dev);
 	struct cs4281 *chip = card->private_data;
 	unsigned int i;
 	u32 ulCLK;
@@ -2082,6 +2084,11 @@ static int cs4281_resume(struct pci_dev *pci)
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
+
+static SIMPLE_DEV_PM_OPS(cs4281_pm, cs4281_suspend, cs4281_resume);
+#define CS4281_PM_OPS	&cs4281_pm
+#else
+#define CS4281_PM_OPS	NULL
 #endif /* CONFIG_PM */
 
 static struct pci_driver cs4281_driver = {
@@ -2089,10 +2096,9 @@ static struct pci_driver cs4281_driver = {
 	.id_table = snd_cs4281_ids,
 	.probe = snd_cs4281_probe,
 	.remove = __devexit_p(snd_cs4281_remove),
-#ifdef CONFIG_PM
-	.suspend = cs4281_suspend,
-	.resume = cs4281_resume,
-#endif
+	.driver = {
+		.pm = CS4281_PM_OPS,
+	},
 };
 	
 module_pci_driver(cs4281_driver);

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index a9f368f60df6..33506ee569bd 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -2084,7 +2084,7 @@ static int cs4281_resume(struct pci_dev *pci)
 }
 #endif /* CONFIG_PM */
 
-static struct pci_driver driver = {
+static struct pci_driver cs4281_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_cs4281_ids,
 	.probe = snd_cs4281_probe,
@@ -2095,15 +2095,4 @@ static struct pci_driver driver = {
 #endif
 };
 	
-static int __init alsa_card_cs4281_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit alsa_card_cs4281_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(alsa_card_cs4281_init)
-module_exit(alsa_card_cs4281_exit)
+module_pci_driver(cs4281_driver);

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index a6c6c5c53af9..a9f368f60df6 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -44,8 +44,8 @@ MODULE_SUPPORTED_DEVICE("{{Cirrus Logic,CS4281}}");
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
-static int dual_codec[SNDRV_CARDS];	/* dual codec */
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
+static bool dual_codec[SNDRV_CARDS];	/* dual codec */
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for CS4281 soundcard.");

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 07f04e390aa1..a6c6c5c53af9 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -26,7 +26,7 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/gameport.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/pcm.h>

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 67052d9069cf..07f04e390aa1 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1382,7 +1382,7 @@ static int __devinit snd_cs4281_create(struct snd_card *card,
 	}
 	
 	if (request_irq(pci->irq, snd_cs4281_interrupt, IRQF_SHARED,
-			"CS4281", chip)) {
+			KBUILD_MODNAME, chip)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_cs4281_free(chip);
 		return -ENOMEM;

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 6772070ed492..67052d9069cf 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -2085,7 +2085,7 @@ static int cs4281_resume(struct pci_dev *pci)
 #endif /* CONFIG_PM */
 
 static struct pci_driver driver = {
-	.name = "CS4281",
+	.name = KBUILD_MODNAME,
 	.id_table = snd_cs4281_ids,
 	.probe = snd_cs4281_probe,
 	.remove = __devexit_p(snd_cs4281_remove),

commit d97e1b78239c7e7e441088e0b644bd3b076002e6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 13 11:33:54 2010 +0200

    ALSA: info - Check file position validity in common layer
    
    Check the validity of the file position in the common info layer before
    calling read or write callbacks in assumption that entry->size is set up
    properly to indicate the max file size.
    
    Removed the redundant checks from the callbacks as well.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index b0bba2e86b12..6772070ed492 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1144,17 +1144,11 @@ static ssize_t snd_cs4281_BA0_read(struct snd_info_entry *entry,
 				   struct file *file, char __user *buf,
 				   size_t count, loff_t pos)
 {
-	long size;
 	struct cs4281 *chip = entry->private_data;
 	
-	size = count;
-	if (pos + size > CS4281_BA0_SIZE)
-		size = (long)CS4281_BA0_SIZE - pos;
-	if (size > 0) {
-		if (copy_to_user_fromio(buf, chip->ba0 + pos, size))
-			return -EFAULT;
-	}
-	return size;
+	if (copy_to_user_fromio(buf, chip->ba0 + pos, count))
+		return -EFAULT;
+	return count;
 }
 
 static ssize_t snd_cs4281_BA1_read(struct snd_info_entry *entry,
@@ -1162,17 +1156,11 @@ static ssize_t snd_cs4281_BA1_read(struct snd_info_entry *entry,
 				   struct file *file, char __user *buf,
 				   size_t count, loff_t pos)
 {
-	long size;
 	struct cs4281 *chip = entry->private_data;
 	
-	size = count;
-	if (pos + size > CS4281_BA1_SIZE)
-		size = (long)CS4281_BA1_SIZE - pos;
-	if (size > 0) {
-		if (copy_to_user_fromio(buf, chip->ba1 + pos, size))
-			return -EFAULT;
-	}
-	return size;
+	if (copy_to_user_fromio(buf, chip->ba1 + pos, count))
+		return -EFAULT;
+	return count;
 }
 
 static struct snd_info_entry_ops snd_cs4281_proc_ops_BA0 = {

commit 24e4a1211f691fc671de44685430dbad757d8487
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 13 11:22:01 2010 +0200

    ALSA: info - Use standard types for info callbacks
    
    Use loff_t, size_t and ssize_t for arguments of info callbacks
    to follow the standard procfs.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 9edc65059e3e..b0bba2e86b12 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1139,10 +1139,10 @@ static void snd_cs4281_proc_read(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "Spurious end IRQs    : %u\n", chip->spurious_dtc_irq);
 }
 
-static long snd_cs4281_BA0_read(struct snd_info_entry *entry,
-				void *file_private_data,
-				struct file *file, char __user *buf,
-				unsigned long count, unsigned long pos)
+static ssize_t snd_cs4281_BA0_read(struct snd_info_entry *entry,
+				   void *file_private_data,
+				   struct file *file, char __user *buf,
+				   size_t count, loff_t pos)
 {
 	long size;
 	struct cs4281 *chip = entry->private_data;
@@ -1157,10 +1157,10 @@ static long snd_cs4281_BA0_read(struct snd_info_entry *entry,
 	return size;
 }
 
-static long snd_cs4281_BA1_read(struct snd_info_entry *entry,
-				void *file_private_data,
-				struct file *file, char __user *buf,
-				unsigned long count, unsigned long pos)
+static ssize_t snd_cs4281_BA1_read(struct snd_info_entry *entry,
+				   void *file_private_data,
+				   struct file *file, char __user *buf,
+				   size_t count, loff_t pos)
 {
 	long size;
 	struct cs4281 *chip = entry->private_data;

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index e2e0359bb056..9edc65059e3e 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -494,7 +494,7 @@ struct cs4281 {
 
 static irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id);
 
-static struct pci_device_id snd_cs4281_ids[] = {
+static DEFINE_PCI_DEVICE_TABLE(snd_cs4281_ids) = {
 	{ PCI_VDEVICE(CIRRUS, 0x6005), 0, },	/* CS4281 */
 	{ 0, }
 };

commit 28d27aae9432c300857722a917be4065c6d7abff
Author: Joe Perches <joe@perches.com>
Date:   Wed Jun 24 22:13:35 2009 -0700

    sound: Use PCI_VDEVICE
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index f6286f84a221..e2e0359bb056 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -495,7 +495,7 @@ struct cs4281 {
 static irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id);
 
 static struct pci_device_id snd_cs4281_ids[] = {
-	{ 0x1013, 0x6005, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* CS4281 */
+	{ PCI_VDEVICE(CIRRUS, 0x6005), 0, },	/* CS4281 */
 	{ 0, }
 };
 

commit e0d2054fd3cf167395390dc1758644486c782707
Merge: d807500a2472 c468ac29e63b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:35:50 2009 +0100

    Merge branch 'topic/misc' into for-linus

commit ee419653a38de93b75a577851d9e4003cf0bbe07
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 16:11:31 2009 +0100

    ALSA: Fix missing KERN_* prefix to printk in sound/pci
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 192e7842e181..415e88f2c62f 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -834,7 +834,11 @@ static snd_pcm_uframes_t snd_cs4281_pointer(struct snd_pcm_substream *substream)
 	struct cs4281_dma *dma = runtime->private_data;
 	struct cs4281 *chip = snd_pcm_substream_chip(substream);
 
-	// printk("DCC = 0x%x, buffer_size = 0x%x, jiffies = %li\n", snd_cs4281_peekBA0(chip, dma->regDCC), runtime->buffer_size, jiffies);
+	/*
+	printk(KERN_DEBUG "DCC = 0x%x, buffer_size = 0x%x, jiffies = %li\n",
+	       snd_cs4281_peekBA0(chip, dma->regDCC), runtime->buffer_size,
+	       jiffies);
+	*/
 	return runtime->buffer_size -
 	       snd_cs4281_peekBA0(chip, dma->regDCC) - 1;
 }

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 192e7842e181..b9b07f464631 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1925,9 +1925,9 @@ static int __devinit snd_cs4281_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
-	if (card == NULL)
-		return -ENOMEM;
+	err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
+	if (err < 0)
+		return err;
 
 	if ((err = snd_cs4281_create(card, pci, &chip, dual_codec[dev])) < 0) {
 		snd_card_free(card);

commit 2f5ad54ea6e2e38156bfb889964deee991f3087a
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Sun Sep 28 16:20:09 2008 -0700

    pci: use pci_ioremap_bar() in sound/
    
    Use the newly introduced pci_ioremap_bar() function in sound/.
    pci_ioremap_bar() just takes a pci device and a bar number, with the goal
    of making it really hard to get wrong, while also having a central place
    to stick sanity checks.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index ef9308f7c45b..192e7842e181 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1382,8 +1382,8 @@ static int __devinit snd_cs4281_create(struct snd_card *card,
 	chip->ba0_addr = pci_resource_start(pci, 0);
 	chip->ba1_addr = pci_resource_start(pci, 1);
 
-	chip->ba0 = ioremap_nocache(chip->ba0_addr, pci_resource_len(pci, 0));
-	chip->ba1 = ioremap_nocache(chip->ba1_addr, pci_resource_len(pci, 1));
+	chip->ba0 = pci_ioremap_bar(pci, 0);
+	chip->ba1 = pci_ioremap_bar(pci, 1);
 	if (!chip->ba0 || !chip->ba1) {
 		snd_cs4281_free(chip);
 		return -ENOMEM;

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 7556fd90d0eb..ef9308f7c45b 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -766,13 +766,13 @@ static void snd_cs4281_mode(struct cs4281 *chip, struct cs4281_dma *dma,
 	if (!capture) {
 		if (dma->left_slot == chip->src_left_play_slot) {
 			unsigned int val = snd_cs4281_rate(runtime->rate, NULL);
-			snd_assert(dma->right_slot == chip->src_right_play_slot, );
+			snd_BUG_ON(dma->right_slot != chip->src_right_play_slot);
 			snd_cs4281_pokeBA0(chip, BA0_DACSR, val);
 		}
 	} else {
 		if (dma->left_slot == chip->src_left_rec_slot) {
 			unsigned int val = snd_cs4281_rate(runtime->rate, NULL);
-			snd_assert(dma->right_slot == chip->src_right_rec_slot, );
+			snd_BUG_ON(dma->right_slot != chip->src_right_rec_slot);
 			snd_cs4281_pokeBA0(chip, BA0_ADCSR, val);
 		}
 	}
@@ -1209,7 +1209,8 @@ static void snd_cs4281_gameport_trigger(struct gameport *gameport)
 {
 	struct cs4281 *chip = gameport_get_port_data(gameport);
 
-	snd_assert(chip, return);
+	if (snd_BUG_ON(!chip))
+		return;
 	snd_cs4281_pokeBA0(chip, BA0_JSPT, 0xff);
 }
 
@@ -1217,7 +1218,8 @@ static unsigned char snd_cs4281_gameport_read(struct gameport *gameport)
 {
 	struct cs4281 *chip = gameport_get_port_data(gameport);
 
-	snd_assert(chip, return 0);
+	if (snd_BUG_ON(!chip))
+		return 0;
 	return snd_cs4281_peekBA0(chip, BA0_JSPT);
 }
 
@@ -1228,7 +1230,8 @@ static int snd_cs4281_gameport_cooked_read(struct gameport *gameport,
 	struct cs4281 *chip = gameport_get_port_data(gameport);
 	unsigned js1, js2, jst;
 	
-	snd_assert(chip, return 0);
+	if (snd_BUG_ON(!chip))
+		return 0;
 
 	js1 = snd_cs4281_peekBA0(chip, BA0_JSC1);
 	js2 = snd_cs4281_peekBA0(chip, BA0_JSC2);

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 9a55f4a9739b..7556fd90d0eb 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -19,7 +19,6 @@
  *
  */
 
-#include <sound/driver.h>
 #include <asm/io.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>

commit c1017a4cdb68ae5368fbc9ee42c77f1f5dca8916
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Mon Oct 15 09:50:19 2007 +0200

    [ALSA] Changed Jaroslav Kysela's e-mail from perex@suse.cz to perex@perex.cz
    
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 1fca49a1641a..9a55f4a9739b 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1,6 +1,6 @@
 /*
  *  Driver for Cirrus Logic CS4281 based PCI soundcard
- *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>,
+ *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>,
  *
  *
  *   This program is free software; you can redistribute it and/or modify
@@ -38,7 +38,7 @@
 #include <sound/initval.h>
 
 
-MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_AUTHOR("Jaroslav Kysela <perex@perex.cz>");
 MODULE_DESCRIPTION("Cirrus Logic CS4281");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{Cirrus Logic,CS4281}}");

commit b83f346bc4d6ab358fd0da85b7eab08bf0234c0b
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Aug 13 17:37:55 2007 +0200

    [ALSA] remove incorrect usage of SNDRV_PCM_INFO_SYNC_START and snd_pcm_set_sync()
    
    Set the SNDRV_PCM_INFO_SYNC_START flag and the substream's sync ID
    (only) if the substream actually can be linked to another one.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 44cf54607647..1fca49a1641a 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -842,12 +842,11 @@ static snd_pcm_uframes_t snd_cs4281_pointer(struct snd_pcm_substream *substream)
 
 static struct snd_pcm_hardware snd_cs4281_playback =
 {
-	.info =			(SNDRV_PCM_INFO_MMAP |
-				 SNDRV_PCM_INFO_INTERLEAVED |
-				 SNDRV_PCM_INFO_MMAP_VALID |
-				 SNDRV_PCM_INFO_PAUSE |
-				 SNDRV_PCM_INFO_RESUME |
-				 SNDRV_PCM_INFO_SYNC_START),
+	.info =			SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_PAUSE |
+				SNDRV_PCM_INFO_RESUME,
 	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 |
 				SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_S16_LE |
 				SNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |
@@ -868,12 +867,11 @@ static struct snd_pcm_hardware snd_cs4281_playback =
 
 static struct snd_pcm_hardware snd_cs4281_capture =
 {
-	.info =			(SNDRV_PCM_INFO_MMAP |
-				 SNDRV_PCM_INFO_INTERLEAVED |
-				 SNDRV_PCM_INFO_MMAP_VALID |
-				 SNDRV_PCM_INFO_PAUSE |
-				 SNDRV_PCM_INFO_RESUME |
-				 SNDRV_PCM_INFO_SYNC_START),
+	.info =			SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_PAUSE |
+				SNDRV_PCM_INFO_RESUME,
 	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 |
 				SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_S16_LE |
 				SNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |
@@ -904,7 +902,6 @@ static int snd_cs4281_playback_open(struct snd_pcm_substream *substream)
 	dma->right_slot = 1;
 	runtime->private_data = dma;
 	runtime->hw = snd_cs4281_playback;
-	snd_pcm_set_sync(substream);
 	/* should be detected from the AC'97 layer, but it seems
 	   that although CS4297A rev B reports 18-bit ADC resolution,
 	   samples are 20-bit */
@@ -924,7 +921,6 @@ static int snd_cs4281_capture_open(struct snd_pcm_substream *substream)
 	dma->right_slot = 11;
 	runtime->private_data = dma;
 	runtime->hw = snd_cs4281_capture;
-	snd_pcm_set_sync(substream);
 	/* should be detected from the AC'97 layer, but it seems
 	   that although CS4297A rev B reports 18-bit ADC resolution,
 	   samples are 20-bit */

commit 0cb29ea0d449d7c0ecc9649a08ab63476389701d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 29 15:33:49 2007 +0100

    [ALSA] Add even more 'const' to everything related to TLV
    
    Mark TLV data as 'const'
    Signed-of-by: Philipp Matthias Hahn <pmhahn@pmhahn.de>
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 8e5519de7115..44cf54607647 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1055,7 +1055,7 @@ static int snd_cs4281_put_volume(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-static DECLARE_TLV_DB_SCALE(db_scale_dsp, -4650, 150, 0);
+static const DECLARE_TLV_DB_SCALE(db_scale_dsp, -4650, 150, 0);
 
 static struct snd_kcontrol_new snd_cs4281_fm_vol = 
 {

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 0905fa88129d..8e5519de7115 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1391,7 +1391,7 @@ static int __devinit snd_cs4281_create(struct snd_card *card,
 		return -ENOMEM;
 	}
 	
-	if (request_irq(pci->irq, snd_cs4281_interrupt, IRQF_DISABLED|IRQF_SHARED,
+	if (request_irq(pci->irq, snd_cs4281_interrupt, IRQF_SHARED,
 			"CS4281", chip)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_cs4281_free(chip);

commit 30b35399ceb2398d05837863476dcb12f12f3a82
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 11 18:52:53 2006 +0200

    [ALSA] Various fixes for suspend/resume of ALSA PCI drivers
    
    - Check the return value of pci_enable_device() and request_irq()
      in the suspend.  If any error occurs there, disable the device
      using snd_card_disconnect().
    - Call pci_set_power_state() properly with pci_choose_state().
    - Fix the order to call pci_set_power_state().
    - Removed obsolete house-made PM codes in some drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index d54924e60bb1..0905fa88129d 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -2050,6 +2050,7 @@ static int cs4281_suspend(struct pci_dev *pci, pm_message_t state)
 
 	pci_disable_device(pci);
 	pci_save_state(pci);
+	pci_set_power_state(pci, pci_choose_state(pci, state));
 	return 0;
 }
 
@@ -2060,8 +2061,14 @@ static int cs4281_resume(struct pci_dev *pci)
 	unsigned int i;
 	u32 ulCLK;
 
+	pci_set_power_state(pci, PCI_D0);
 	pci_restore_state(pci);
-	pci_enable_device(pci);
+	if (pci_enable_device(pci) < 0) {
+		printk(KERN_ERR "cs4281: pci_enable_device failed, "
+		       "disabling device\n");
+		snd_card_disconnect(card);
+		return -EIO;
+	}
 	pci_set_master(pci);
 
 	ulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 1990430a21c1..d54924e60bb1 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -493,7 +493,7 @@ struct cs4281 {
 
 };
 
-static irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+static irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id);
 
 static struct pci_device_id snd_cs4281_ids[] = {
 	{ 0x1013, 0x6005, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* CS4281 */
@@ -1814,7 +1814,7 @@ static int __devinit snd_cs4281_midi(struct cs4281 * chip, int device,
  *  Interrupt handler
  */
 
-static irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id)
 {
 	struct cs4281 *chip = dev_id;
 	unsigned int status, dma, val;

commit 9f6ab25063f04597e02968ae8393e8f4703c1563
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Aug 23 12:14:25 2006 +0200

    [ALSA] Add dB scale information to cs4281 driver
    
    Added the dB scale information to cs4281 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 9631456ec3de..1990430a21c1 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -33,6 +33,7 @@
 #include <sound/pcm.h>
 #include <sound/rawmidi.h>
 #include <sound/ac97_codec.h>
+#include <sound/tlv.h>
 #include <sound/opl3.h>
 #include <sound/initval.h>
 
@@ -1054,6 +1055,8 @@ static int snd_cs4281_put_volume(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
+static DECLARE_TLV_DB_SCALE(db_scale_dsp, -4650, 150, 0);
+
 static struct snd_kcontrol_new snd_cs4281_fm_vol = 
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
@@ -1062,6 +1065,7 @@ static struct snd_kcontrol_new snd_cs4281_fm_vol =
 	.get = snd_cs4281_get_volume,
 	.put = snd_cs4281_put_volume, 
 	.private_value = ((BA0_FMLVC << 16) | BA0_FMRVC),
+	.tlv = { .p = db_scale_dsp },
 };
 
 static struct snd_kcontrol_new snd_cs4281_pcm_vol = 
@@ -1072,6 +1076,7 @@ static struct snd_kcontrol_new snd_cs4281_pcm_vol =
 	.get = snd_cs4281_get_volume,
 	.put = snd_cs4281_put_volume, 
 	.private_value = ((BA0_PPLVC << 16) | BA0_PPRVC),
+	.tlv = { .p = db_scale_dsp },
 };
 
 static void snd_cs4281_mixer_free_ac97_bus(struct snd_ac97_bus *bus)

commit f40b68903ccd511ea9d658b4bce319dd032a265a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jul 5 16:51:05 2006 +0200

    [ALSA] Fix section mismatch errors in ALSA PCI drivers
    
    Fixed 'section mismatch' errors in ALSA PCI drivers:
    - removed invalid __devinitdata from pci id tables
    - fix/remove __devinit of functions called in suspend/resume
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index d1802487f5be..9631456ec3de 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -494,7 +494,7 @@ struct cs4281 {
 
 static irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 
-static struct pci_device_id snd_cs4281_ids[] __devinitdata = {
+static struct pci_device_id snd_cs4281_ids[] = {
 	{ 0x1013, 0x6005, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* CS4281 */
 	{ 0, }
 };

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index e77a4ce314b7..d1802487f5be 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1386,7 +1386,7 @@ static int __devinit snd_cs4281_create(struct snd_card *card,
 		return -ENOMEM;
 	}
 	
-	if (request_irq(pci->irq, snd_cs4281_interrupt, SA_INTERRUPT|SA_SHIRQ,
+	if (request_irq(pci->irq, snd_cs4281_interrupt, IRQF_DISABLED|IRQF_SHARED,
 			"CS4281", chip)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_cs4281_free(chip);

commit 688956f23bdbfb1c3551bfafc819f989b36bb8ae
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 6 15:44:34 2006 +0200

    [ALSA] Fix races in irq handler and ioremap
    
    Call ioremap before request_irq for avoiding possible races
    in the irq handler.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 8c150eab45b6..e77a4ce314b7 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1379,6 +1379,13 @@ static int __devinit snd_cs4281_create(struct snd_card *card,
 	chip->ba0_addr = pci_resource_start(pci, 0);
 	chip->ba1_addr = pci_resource_start(pci, 1);
 
+	chip->ba0 = ioremap_nocache(chip->ba0_addr, pci_resource_len(pci, 0));
+	chip->ba1 = ioremap_nocache(chip->ba1_addr, pci_resource_len(pci, 1));
+	if (!chip->ba0 || !chip->ba1) {
+		snd_cs4281_free(chip);
+		return -ENOMEM;
+	}
+	
 	if (request_irq(pci->irq, snd_cs4281_interrupt, SA_INTERRUPT|SA_SHIRQ,
 			"CS4281", chip)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
@@ -1387,13 +1394,6 @@ static int __devinit snd_cs4281_create(struct snd_card *card,
 	}
 	chip->irq = pci->irq;
 
-	chip->ba0 = ioremap_nocache(chip->ba0_addr, pci_resource_len(pci, 0));
-	chip->ba1 = ioremap_nocache(chip->ba1_addr, pci_resource_len(pci, 1));
-	if (!chip->ba0 || !chip->ba1) {
-		snd_cs4281_free(chip);
-		return -ENOMEM;
-	}
-	
 	tmp = snd_cs4281_chip_init(chip);
 	if (tmp) {
 		snd_cs4281_free(chip);

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index b3c94d83450a..8c150eab45b6 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1184,7 +1184,7 @@ static void __devinit snd_cs4281_proc_init(struct cs4281 * chip)
 	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(chip->card, "cs4281", &entry))
-		snd_info_set_text_ops(entry, chip, 1024, snd_cs4281_proc_read);
+		snd_info_set_text_ops(entry, chip, snd_cs4281_proc_read);
 	if (! snd_card_proc_new(chip->card, "cs4281_BA0", &entry)) {
 		entry->content = SNDRV_INFO_CONTENT_DATA;
 		entry->private_data = chip;

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index ac4e73f69c1d..b3c94d83450a 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -494,7 +494,7 @@ struct cs4281 {
 
 static irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 
-static struct pci_device_id snd_cs4281_ids[] = {
+static struct pci_device_id snd_cs4281_ids[] __devinitdata = {
 	{ 0x1013, 0x6005, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* CS4281 */
 	{ 0, }
 };

commit 38223daa1aa98d0a6f35ba7addcfefc756a04f5e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 29 12:33:38 2006 +0200

    [ALSA] cs4281 - Fix the check of timeout in probe
    
    Fix the check of timeout in probe routines to work properly
    reagrdless of HZ (ALSA bug#1976).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 4221dfe8bd7e..ac4e73f69c1d 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1416,7 +1416,7 @@ static int __devinit snd_cs4281_create(struct snd_card *card,
 static int snd_cs4281_chip_init(struct cs4281 *chip)
 {
 	unsigned int tmp;
-	int timeout;
+	unsigned long end_time;
 	int retry_count = 2;
 
 	/* Having EPPMC.FPDN=1 prevent proper chip initialisation */
@@ -1496,7 +1496,7 @@ static int snd_cs4281_chip_init(struct cs4281 *chip)
 	/*
 	 * Wait for the DLL ready signal from the clock logic.
 	 */
-	timeout = 100;
+	end_time = jiffies + HZ;
 	do {
 		/*
 		 *  Read the AC97 status register to see if we've seen a CODEC
@@ -1504,8 +1504,8 @@ static int snd_cs4281_chip_init(struct cs4281 *chip)
 		 */
 		if (snd_cs4281_peekBA0(chip, BA0_CLKCR1) & BA0_CLKCR1_DLLRDY)
 			goto __ok0;
-		msleep(1);
-	} while (timeout-- > 0);
+		schedule_timeout_uninterruptible(1);
+	} while (time_after_eq(end_time, jiffies));
 
 	snd_printk(KERN_ERR "DLLRDY not seen\n");
 	return -EIO;
@@ -1522,7 +1522,7 @@ static int snd_cs4281_chip_init(struct cs4281 *chip)
 	/*
 	 * Wait for the codec ready signal from the AC97 codec.
 	 */
-	timeout = 100;
+	end_time = jiffies + HZ;
 	do {
 		/*
 		 *  Read the AC97 status register to see if we've seen a CODEC
@@ -1530,20 +1530,20 @@ static int snd_cs4281_chip_init(struct cs4281 *chip)
 		 */
 		if (snd_cs4281_peekBA0(chip, BA0_ACSTS) & BA0_ACSTS_CRDY)
 			goto __ok1;
-		msleep(1);
-	} while (timeout-- > 0);
+		schedule_timeout_uninterruptible(1);
+	} while (time_after_eq(end_time, jiffies));
 
 	snd_printk(KERN_ERR "never read codec ready from AC'97 (0x%x)\n", snd_cs4281_peekBA0(chip, BA0_ACSTS));
 	return -EIO;
 
       __ok1:
 	if (chip->dual_codec) {
-		timeout = 100;
+		end_time = jiffies + HZ;
 		do {
 			if (snd_cs4281_peekBA0(chip, BA0_ACSTS2) & BA0_ACSTS_CRDY)
 				goto __codec2_ok;
-			msleep(1);
-		} while (timeout-- > 0);
+			schedule_timeout_uninterruptible(1);
+		} while (time_after_eq(end_time, jiffies));
 		snd_printk(KERN_INFO "secondary codec doesn't respond. disable it...\n");
 		chip->dual_codec = 0;
 	__codec2_ok: ;
@@ -1561,7 +1561,7 @@ static int snd_cs4281_chip_init(struct cs4281 *chip)
 	 *  the codec is pumping ADC data across the AC-link.
 	 */
 
-	timeout = 100;
+	end_time = jiffies + HZ;
 	do {
 		/*
 		 *  Read the input slot valid register and see if input slots 3
@@ -1569,8 +1569,8 @@ static int snd_cs4281_chip_init(struct cs4281 *chip)
 		 */
                 if ((snd_cs4281_peekBA0(chip, BA0_ACISV) & (BA0_ACISV_SLV(3) | BA0_ACISV_SLV(4))) == (BA0_ACISV_SLV(3) | BA0_ACISV_SLV(4)))
                         goto __ok2;
-		msleep(1);
-	} while (timeout-- > 0);
+		schedule_timeout_uninterruptible(1);
+	} while (time_after_eq(end_time, jiffies));
 
 	if (--retry_count > 0)
 		goto __retry;

commit e860f00047108ec97ac58c0d1bf59ae23e35f81c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 29 11:38:01 2006 +0200

    [ALSA] cs4281 - Fix the check of right channel
    
    Fix the check of right channel in mixer volume put callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 4f65ec56bf35..4221dfe8bd7e 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1046,7 +1046,7 @@ static int snd_cs4281_put_volume(struct snd_kcontrol *kcontrol,
 		snd_cs4281_pokeBA0(chip, regL, volL);
 		change = 1;
 	}
-	if (ucontrol->value.integer.value[0] != volL) {
+	if (ucontrol->value.integer.value[1] != volR) {
 		volR = CS_VOL_MASK - (ucontrol->value.integer.value[1] & CS_VOL_MASK);
 		snd_cs4281_pokeBA0(chip, regR, volR);
 		change = 1;

commit 38c0a158ee23027e6a4fe47311e05d9c34c94da4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 16:08:11 2005 +0100

    [ALSA] cs4281 - Fix PM support
    
    Modules: CS4281 driver
    
    Fix PM support on CS4281 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 116cdc1c5528..4f65ec56bf35 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1339,10 +1339,6 @@ static int snd_cs4281_dev_free(struct snd_device *device)
 }
 
 static int snd_cs4281_chip_init(struct cs4281 *chip); /* defined below */
-#ifdef CONFIG_PM
-static int cs4281_suspend(struct snd_card *card, pm_message_t state);
-static int cs4281_resume(struct snd_card *card);
-#endif
 
 static int __devinit snd_cs4281_create(struct snd_card *card,
 				       struct pci_dev *pci,
@@ -1411,8 +1407,6 @@ static int __devinit snd_cs4281_create(struct snd_card *card,
 
 	snd_cs4281_proc_init(chip);
 
-	snd_card_set_pm_callback(card, cs4281_suspend, cs4281_resume, chip);
-
 	snd_card_set_dev(card, &pci->dev);
 
 	*rchip = chip;
@@ -1936,6 +1930,7 @@ static int __devinit snd_cs4281_probe(struct pci_dev *pci,
 		snd_card_free(card);
 		return err;
 	}
+	card->private_data = chip;
 
 	if ((err = snd_cs4281_mixer(chip)) < 0) {
 		snd_card_free(card);
@@ -2007,18 +2002,18 @@ static int saved_regs[SUSPEND_REGISTERS] = {
 
 #define CLKCR1_CKRA                             0x00010000L
 
-static int cs4281_suspend(struct snd_card *card, pm_message_t state)
+static int cs4281_suspend(struct pci_dev *pci, pm_message_t state)
 {
-	struct cs4281 *chip = card->pm_private_data;
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct cs4281 *chip = card->private_data;
 	u32 ulCLK;
 	unsigned int i;
 
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
 	snd_pcm_suspend_all(chip->pcm);
 
-	if (chip->ac97)
-		snd_ac97_suspend(chip->ac97);
-	if (chip->ac97_secondary)
-		snd_ac97_suspend(chip->ac97_secondary);
+	snd_ac97_suspend(chip->ac97);
+	snd_ac97_suspend(chip->ac97_secondary);
 
 	ulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);
 	ulCLK |= CLKCR1_CKRA;
@@ -2048,18 +2043,21 @@ static int cs4281_suspend(struct snd_card *card, pm_message_t state)
 	ulCLK &= ~CLKCR1_CKRA;
 	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);
 
-	pci_disable_device(chip->pci);
+	pci_disable_device(pci);
+	pci_save_state(pci);
 	return 0;
 }
 
-static int cs4281_resume(struct snd_card *card)
+static int cs4281_resume(struct pci_dev *pci)
 {
-	struct cs4281 *chip = card->pm_private_data;
+	struct snd_card *card = pci_get_drvdata(pci);
+	struct cs4281 *chip = card->private_data;
 	unsigned int i;
 	u32 ulCLK;
 
-	pci_enable_device(chip->pci);
-	pci_set_master(chip->pci);
+	pci_restore_state(pci);
+	pci_enable_device(pci);
+	pci_set_master(pci);
 
 	ulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);
 	ulCLK |= CLKCR1_CKRA;
@@ -2072,15 +2070,14 @@ static int cs4281_resume(struct snd_card *card)
 		if (saved_regs[i])
 			snd_cs4281_pokeBA0(chip, saved_regs[i], chip->suspend_regs[i]);
 
-	if (chip->ac97)
-		snd_ac97_resume(chip->ac97);
-	if (chip->ac97_secondary)
-		snd_ac97_resume(chip->ac97_secondary);
+	snd_ac97_resume(chip->ac97);
+	snd_ac97_resume(chip->ac97_secondary);
 
 	ulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);
 	ulCLK &= ~CLKCR1_CKRA;
 	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);
 
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 	return 0;
 }
 #endif /* CONFIG_PM */
@@ -2090,7 +2087,10 @@ static struct pci_driver driver = {
 	.id_table = snd_cs4281_ids,
 	.probe = snd_cs4281_probe,
 	.remove = __devexit_p(snd_cs4281_remove),
-	SND_PCI_PM_CALLBACKS
+#ifdef CONFIG_PM
+	.suspend = cs4281_suspend,
+	.resume = cs4281_resume,
+#endif
 };
 	
 static int __init alsa_card_cs4281_init(void)

commit 93e35f956a1720eedcf95b8337dde25bde22d624
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 15:03:28 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI CS4281
    
    Modules: CS4281 driver
    
    Remove xxx_t typedefs from the PCI CS4281 driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index c99bb1f2bfa8..116cdc1c5528 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -427,11 +427,8 @@ MODULE_PARM_DESC(dual_codec, "Secondary Codec ID (0 = disabled).");
  *
  */
 
-typedef struct snd_cs4281 cs4281_t;
-typedef struct snd_cs4281_dma cs4281_dma_t;
-
-struct snd_cs4281_dma {
-	snd_pcm_substream_t *substream;
+struct cs4281_dma {
+	struct snd_pcm_substream *substream;
 	unsigned int regDBA;		/* offset to DBA register */
 	unsigned int regDCA;		/* offset to DCA register */
 	unsigned int regDBC;		/* offset to DBC register */
@@ -452,7 +449,7 @@ struct snd_cs4281_dma {
 
 #define SUSPEND_REGISTERS	20
 
-struct snd_cs4281 {
+struct cs4281 {
 	int irq;
 
 	void __iomem *ba0;		/* virtual (accessible) address */
@@ -462,18 +459,18 @@ struct snd_cs4281 {
 
 	int dual_codec;
 
-	ac97_bus_t *ac97_bus;
-	ac97_t *ac97;
-	ac97_t *ac97_secondary;
+	struct snd_ac97_bus *ac97_bus;
+	struct snd_ac97 *ac97;
+	struct snd_ac97 *ac97_secondary;
 
 	struct pci_dev *pci;
-	snd_card_t *card;
-	snd_pcm_t *pcm;
-	snd_rawmidi_t *rmidi;
-	snd_rawmidi_substream_t *midi_input;
-	snd_rawmidi_substream_t *midi_output;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	struct snd_rawmidi *rmidi;
+	struct snd_rawmidi_substream *midi_input;
+	struct snd_rawmidi_substream *midi_output;
 
-	cs4281_dma_t dma[4];
+	struct cs4281_dma dma[4];
 
 	unsigned char src_left_play_slot;
 	unsigned char src_right_play_slot;
@@ -514,17 +511,18 @@ MODULE_DEVICE_TABLE(pci, snd_cs4281_ids);
  *  common I/O routines
  */
 
-static inline void snd_cs4281_pokeBA0(cs4281_t *chip, unsigned long offset, unsigned int val)
+static inline void snd_cs4281_pokeBA0(struct cs4281 *chip, unsigned long offset,
+				      unsigned int val)
 {
         writel(val, chip->ba0 + offset);
 }
 
-static inline unsigned int snd_cs4281_peekBA0(cs4281_t *chip, unsigned long offset)
+static inline unsigned int snd_cs4281_peekBA0(struct cs4281 *chip, unsigned long offset)
 {
         return readl(chip->ba0 + offset);
 }
 
-static void snd_cs4281_ac97_write(ac97_t *ac97,
+static void snd_cs4281_ac97_write(struct snd_ac97 *ac97,
 				  unsigned short reg, unsigned short val)
 {
 	/*
@@ -534,7 +532,7 @@ static void snd_cs4281_ac97_write(ac97_t *ac97,
 	 *  4. Read ACCTL = 460h, DCV should be reset by now and 460h = 07h
 	 *  5. if DCV not cleared, break and return error
 	 */
-	cs4281_t *chip = ac97->private_data;
+	struct cs4281 *chip = ac97->private_data;
 	int count;
 
 	/*
@@ -569,15 +567,15 @@ static void snd_cs4281_ac97_write(ac97_t *ac97,
 	snd_printk(KERN_ERR "AC'97 write problem, reg = 0x%x, val = 0x%x\n", reg, val);
 }
 
-static unsigned short snd_cs4281_ac97_read(ac97_t *ac97,
+static unsigned short snd_cs4281_ac97_read(struct snd_ac97 *ac97,
 					   unsigned short reg)
 {
-	cs4281_t *chip = ac97->private_data;
+	struct cs4281 *chip = ac97->private_data;
 	int count;
 	unsigned short result;
 	// FIXME: volatile is necessary in the following due to a bug of
 	// some gcc versions
-	volatile int ac97_num = ((volatile ac97_t *)ac97)->num;
+	volatile int ac97_num = ((volatile struct snd_ac97 *)ac97)->num;
 
 	/*
 	 *  1. Write ACCAD = Command Address Register = 46Ch for AC97 register address
@@ -664,10 +662,10 @@ static unsigned short snd_cs4281_ac97_read(ac97_t *ac97,
  *  PCM part
  */
 
-static int snd_cs4281_trigger(snd_pcm_substream_t *substream, int cmd)
+static int snd_cs4281_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	cs4281_dma_t *dma = (cs4281_dma_t *)substream->runtime->private_data;
-	cs4281_t *chip = snd_pcm_substream_chip(substream);
+	struct cs4281_dma *dma = substream->runtime->private_data;
+	struct cs4281 *chip = snd_pcm_substream_chip(substream);
 
 	spin_lock(&chip->reg_lock);
 	switch (cmd) {
@@ -730,7 +728,9 @@ static unsigned int snd_cs4281_rate(unsigned int rate, unsigned int *real_rate)
 	return val;
 }
 
-static void snd_cs4281_mode(cs4281_t *chip, cs4281_dma_t *dma, snd_pcm_runtime_t *runtime, int capture, int src)
+static void snd_cs4281_mode(struct cs4281 *chip, struct cs4281_dma *dma,
+			    struct snd_pcm_runtime *runtime,
+			    int capture, int src)
 {
 	int rec_mono;
 
@@ -793,22 +793,22 @@ static void snd_cs4281_mode(cs4281_t *chip, cs4281_dma_t *dma, snd_pcm_runtime_t
 	snd_cs4281_pokeBA0(chip, dma->regFSIC, 0);
 }
 
-static int snd_cs4281_hw_params(snd_pcm_substream_t * substream,
-				snd_pcm_hw_params_t * hw_params)
+static int snd_cs4281_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *hw_params)
 {
 	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
 }
 
-static int snd_cs4281_hw_free(snd_pcm_substream_t * substream)
+static int snd_cs4281_hw_free(struct snd_pcm_substream *substream)
 {
 	return snd_pcm_lib_free_pages(substream);
 }
 
-static int snd_cs4281_playback_prepare(snd_pcm_substream_t * substream)
+static int snd_cs4281_playback_prepare(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	cs4281_dma_t *dma = (cs4281_dma_t *)runtime->private_data;
-	cs4281_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct cs4281_dma *dma = runtime->private_data;
+	struct cs4281 *chip = snd_pcm_substream_chip(substream);
 
 	spin_lock_irq(&chip->reg_lock);
 	snd_cs4281_mode(chip, dma, runtime, 0, 1);
@@ -816,11 +816,11 @@ static int snd_cs4281_playback_prepare(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_cs4281_capture_prepare(snd_pcm_substream_t * substream)
+static int snd_cs4281_capture_prepare(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	cs4281_dma_t *dma = (cs4281_dma_t *)runtime->private_data;
-	cs4281_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct cs4281_dma *dma = runtime->private_data;
+	struct cs4281 *chip = snd_pcm_substream_chip(substream);
 
 	spin_lock_irq(&chip->reg_lock);
 	snd_cs4281_mode(chip, dma, runtime, 1, 1);
@@ -828,18 +828,18 @@ static int snd_cs4281_capture_prepare(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static snd_pcm_uframes_t snd_cs4281_pointer(snd_pcm_substream_t * substream)
+static snd_pcm_uframes_t snd_cs4281_pointer(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	cs4281_dma_t *dma = (cs4281_dma_t *)runtime->private_data;
-	cs4281_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct cs4281_dma *dma = runtime->private_data;
+	struct cs4281 *chip = snd_pcm_substream_chip(substream);
 
 	// printk("DCC = 0x%x, buffer_size = 0x%x, jiffies = %li\n", snd_cs4281_peekBA0(chip, dma->regDCC), runtime->buffer_size, jiffies);
 	return runtime->buffer_size -
 	       snd_cs4281_peekBA0(chip, dma->regDCC) - 1;
 }
 
-static snd_pcm_hardware_t snd_cs4281_playback =
+static struct snd_pcm_hardware snd_cs4281_playback =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP |
 				 SNDRV_PCM_INFO_INTERLEAVED |
@@ -865,7 +865,7 @@ static snd_pcm_hardware_t snd_cs4281_playback =
 	.fifo_size =		CS4281_FIFO_SIZE,
 };
 
-static snd_pcm_hardware_t snd_cs4281_capture =
+static struct snd_pcm_hardware snd_cs4281_capture =
 {
 	.info =			(SNDRV_PCM_INFO_MMAP |
 				 SNDRV_PCM_INFO_INTERLEAVED |
@@ -891,11 +891,11 @@ static snd_pcm_hardware_t snd_cs4281_capture =
 	.fifo_size =		CS4281_FIFO_SIZE,
 };
 
-static int snd_cs4281_playback_open(snd_pcm_substream_t * substream)
+static int snd_cs4281_playback_open(struct snd_pcm_substream *substream)
 {
-	cs4281_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	cs4281_dma_t *dma;
+	struct cs4281 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct cs4281_dma *dma;
 
 	dma = &chip->dma[0];
 	dma->substream = substream;
@@ -911,11 +911,11 @@ static int snd_cs4281_playback_open(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_cs4281_capture_open(snd_pcm_substream_t * substream)
+static int snd_cs4281_capture_open(struct snd_pcm_substream *substream)
 {
-	cs4281_t *chip = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	cs4281_dma_t *dma;
+	struct cs4281 *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct cs4281_dma *dma;
 
 	dma = &chip->dma[1];
 	dma->substream = substream;
@@ -931,23 +931,23 @@ static int snd_cs4281_capture_open(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_cs4281_playback_close(snd_pcm_substream_t * substream)
+static int snd_cs4281_playback_close(struct snd_pcm_substream *substream)
 {
-	cs4281_dma_t *dma = (cs4281_dma_t *)substream->runtime->private_data;
+	struct cs4281_dma *dma = substream->runtime->private_data;
 
 	dma->substream = NULL;
 	return 0;
 }
 
-static int snd_cs4281_capture_close(snd_pcm_substream_t * substream)
+static int snd_cs4281_capture_close(struct snd_pcm_substream *substream)
 {
-	cs4281_dma_t *dma = (cs4281_dma_t *)substream->runtime->private_data;
+	struct cs4281_dma *dma = substream->runtime->private_data;
 
 	dma->substream = NULL;
 	return 0;
 }
 
-static snd_pcm_ops_t snd_cs4281_playback_ops = {
+static struct snd_pcm_ops snd_cs4281_playback_ops = {
 	.open =		snd_cs4281_playback_open,
 	.close =	snd_cs4281_playback_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -958,7 +958,7 @@ static snd_pcm_ops_t snd_cs4281_playback_ops = {
 	.pointer =	snd_cs4281_pointer,
 };
 
-static snd_pcm_ops_t snd_cs4281_capture_ops = {
+static struct snd_pcm_ops snd_cs4281_capture_ops = {
 	.open =		snd_cs4281_capture_open,
 	.close =	snd_cs4281_capture_close,
 	.ioctl =	snd_pcm_lib_ioctl,
@@ -969,9 +969,10 @@ static snd_pcm_ops_t snd_cs4281_capture_ops = {
 	.pointer =	snd_cs4281_pointer,
 };
 
-static int __devinit snd_cs4281_pcm(cs4281_t * chip, int device, snd_pcm_t ** rpcm)
+static int __devinit snd_cs4281_pcm(struct cs4281 * chip, int device,
+				    struct snd_pcm ** rpcm)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	if (rpcm)
@@ -1002,7 +1003,8 @@ static int __devinit snd_cs4281_pcm(cs4281_t * chip, int device, snd_pcm_t ** rp
 
 #define CS_VOL_MASK	0x1f
 
-static int snd_cs4281_info_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t * uinfo)
+static int snd_cs4281_info_volume(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type              = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count             = 2;
@@ -1011,9 +1013,10 @@ static int snd_cs4281_info_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t
 	return 0;
 }
  
-static int snd_cs4281_get_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_cs4281_get_volume(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
 {
-	cs4281_t *chip = snd_kcontrol_chip(kcontrol);
+	struct cs4281 *chip = snd_kcontrol_chip(kcontrol);
 	int regL = (kcontrol->private_value >> 16) & 0xffff;
 	int regR = kcontrol->private_value & 0xffff;
 	int volL, volR;
@@ -1026,9 +1029,10 @@ static int snd_cs4281_get_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	return 0;
 }
 
-static int snd_cs4281_put_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+static int snd_cs4281_put_volume(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
 {
-	cs4281_t *chip = snd_kcontrol_chip(kcontrol);
+	struct cs4281 *chip = snd_kcontrol_chip(kcontrol);
 	int change = 0;
 	int regL = (kcontrol->private_value >> 16) & 0xffff;
 	int regR = kcontrol->private_value & 0xffff;
@@ -1050,7 +1054,7 @@ static int snd_cs4281_put_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t
 	return change;
 }
 
-static snd_kcontrol_new_t snd_cs4281_fm_vol = 
+static struct snd_kcontrol_new snd_cs4281_fm_vol = 
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "Synth Playback Volume",
@@ -1060,7 +1064,7 @@ static snd_kcontrol_new_t snd_cs4281_fm_vol =
 	.private_value = ((BA0_FMLVC << 16) | BA0_FMRVC),
 };
 
-static snd_kcontrol_new_t snd_cs4281_pcm_vol = 
+static struct snd_kcontrol_new snd_cs4281_pcm_vol = 
 {
 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
 	.name = "PCM Stream Playback Volume",
@@ -1070,27 +1074,27 @@ static snd_kcontrol_new_t snd_cs4281_pcm_vol =
 	.private_value = ((BA0_PPLVC << 16) | BA0_PPRVC),
 };
 
-static void snd_cs4281_mixer_free_ac97_bus(ac97_bus_t *bus)
+static void snd_cs4281_mixer_free_ac97_bus(struct snd_ac97_bus *bus)
 {
-	cs4281_t *chip = bus->private_data;
+	struct cs4281 *chip = bus->private_data;
 	chip->ac97_bus = NULL;
 }
 
-static void snd_cs4281_mixer_free_ac97(ac97_t *ac97)
+static void snd_cs4281_mixer_free_ac97(struct snd_ac97 *ac97)
 {
-	cs4281_t *chip = ac97->private_data;
+	struct cs4281 *chip = ac97->private_data;
 	if (ac97->num)
 		chip->ac97_secondary = NULL;
 	else
 		chip->ac97 = NULL;
 }
 
-static int __devinit snd_cs4281_mixer(cs4281_t * chip)
+static int __devinit snd_cs4281_mixer(struct cs4281 * chip)
 {
-	snd_card_t *card = chip->card;
-	ac97_template_t ac97;
+	struct snd_card *card = chip->card;
+	struct snd_ac97_template ac97;
 	int err;
-	static ac97_bus_ops_t ops = {
+	static struct snd_ac97_bus_ops ops = {
 		.write = snd_cs4281_ac97_write,
 		.read = snd_cs4281_ac97_read,
 	};
@@ -1121,22 +1125,23 @@ static int __devinit snd_cs4281_mixer(cs4281_t * chip)
  * proc interface
  */
 
-static void snd_cs4281_proc_read(snd_info_entry_t *entry, 
-				  snd_info_buffer_t * buffer)
+static void snd_cs4281_proc_read(struct snd_info_entry *entry, 
+				  struct snd_info_buffer *buffer)
 {
-	cs4281_t *chip = entry->private_data;
+	struct cs4281 *chip = entry->private_data;
 
 	snd_iprintf(buffer, "Cirrus Logic CS4281\n\n");
 	snd_iprintf(buffer, "Spurious half IRQs   : %u\n", chip->spurious_dhtc_irq);
 	snd_iprintf(buffer, "Spurious end IRQs    : %u\n", chip->spurious_dtc_irq);
 }
 
-static long snd_cs4281_BA0_read(snd_info_entry_t *entry, void *file_private_data,
+static long snd_cs4281_BA0_read(struct snd_info_entry *entry,
+				void *file_private_data,
 				struct file *file, char __user *buf,
 				unsigned long count, unsigned long pos)
 {
 	long size;
-	cs4281_t *chip = entry->private_data;
+	struct cs4281 *chip = entry->private_data;
 	
 	size = count;
 	if (pos + size > CS4281_BA0_SIZE)
@@ -1148,12 +1153,13 @@ static long snd_cs4281_BA0_read(snd_info_entry_t *entry, void *file_private_data
 	return size;
 }
 
-static long snd_cs4281_BA1_read(snd_info_entry_t *entry, void *file_private_data,
+static long snd_cs4281_BA1_read(struct snd_info_entry *entry,
+				void *file_private_data,
 				struct file *file, char __user *buf,
 				unsigned long count, unsigned long pos)
 {
 	long size;
-	cs4281_t *chip = entry->private_data;
+	struct cs4281 *chip = entry->private_data;
 	
 	size = count;
 	if (pos + size > CS4281_BA1_SIZE)
@@ -1173,9 +1179,9 @@ static struct snd_info_entry_ops snd_cs4281_proc_ops_BA1 = {
 	.read = snd_cs4281_BA1_read,
 };
 
-static void __devinit snd_cs4281_proc_init(cs4281_t * chip)
+static void __devinit snd_cs4281_proc_init(struct cs4281 * chip)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	if (! snd_card_proc_new(chip->card, "cs4281", &entry))
 		snd_info_set_text_ops(entry, chip, 1024, snd_cs4281_proc_read);
@@ -1201,7 +1207,7 @@ static void __devinit snd_cs4281_proc_init(cs4281_t * chip)
 
 static void snd_cs4281_gameport_trigger(struct gameport *gameport)
 {
-	cs4281_t *chip = gameport_get_port_data(gameport);
+	struct cs4281 *chip = gameport_get_port_data(gameport);
 
 	snd_assert(chip, return);
 	snd_cs4281_pokeBA0(chip, BA0_JSPT, 0xff);
@@ -1209,16 +1215,17 @@ static void snd_cs4281_gameport_trigger(struct gameport *gameport)
 
 static unsigned char snd_cs4281_gameport_read(struct gameport *gameport)
 {
-	cs4281_t *chip = gameport_get_port_data(gameport);
+	struct cs4281 *chip = gameport_get_port_data(gameport);
 
 	snd_assert(chip, return 0);
 	return snd_cs4281_peekBA0(chip, BA0_JSPT);
 }
 
 #ifdef COOKED_MODE
-static int snd_cs4281_gameport_cooked_read(struct gameport *gameport, int *axes, int *buttons)
+static int snd_cs4281_gameport_cooked_read(struct gameport *gameport,
+					   int *axes, int *buttons)
 {
-	cs4281_t *chip = gameport_get_port_data(gameport);
+	struct cs4281 *chip = gameport_get_port_data(gameport);
 	unsigned js1, js2, jst;
 	
 	snd_assert(chip, return 0);
@@ -1257,7 +1264,7 @@ static int snd_cs4281_gameport_open(struct gameport *gameport, int mode)
 	return 0;
 }
 
-static int __devinit snd_cs4281_create_gameport(cs4281_t *chip)
+static int __devinit snd_cs4281_create_gameport(struct cs4281 *chip)
 {
 	struct gameport *gp;
 
@@ -1284,7 +1291,7 @@ static int __devinit snd_cs4281_create_gameport(cs4281_t *chip)
 	return 0;
 }
 
-static void snd_cs4281_free_gameport(cs4281_t *chip)
+static void snd_cs4281_free_gameport(struct cs4281 *chip)
 {
 	if (chip->gameport) {
 		gameport_unregister_port(chip->gameport);
@@ -1292,11 +1299,11 @@ static void snd_cs4281_free_gameport(cs4281_t *chip)
 	}
 }
 #else
-static inline int snd_cs4281_create_gameport(cs4281_t *chip) { return -ENOSYS; }
-static inline void snd_cs4281_free_gameport(cs4281_t *chip) { }
+static inline int snd_cs4281_create_gameport(struct cs4281 *chip) { return -ENOSYS; }
+static inline void snd_cs4281_free_gameport(struct cs4281 *chip) { }
 #endif /* CONFIG_GAMEPORT || (MODULE && CONFIG_GAMEPORT_MODULE) */
 
-static int snd_cs4281_free(cs4281_t *chip)
+static int snd_cs4281_free(struct cs4281 *chip)
 {
 	snd_cs4281_free_gameport(chip);
 
@@ -1313,7 +1320,7 @@ static int snd_cs4281_free(cs4281_t *chip)
 	pci_set_power_state(chip->pci, 3);
 
 	if (chip->irq >= 0)
-		free_irq(chip->irq, (void *)chip);
+		free_irq(chip->irq, chip);
 	if (chip->ba0)
 		iounmap(chip->ba0);
 	if (chip->ba1)
@@ -1325,27 +1332,27 @@ static int snd_cs4281_free(cs4281_t *chip)
 	return 0;
 }
 
-static int snd_cs4281_dev_free(snd_device_t *device)
+static int snd_cs4281_dev_free(struct snd_device *device)
 {
-	cs4281_t *chip = device->device_data;
+	struct cs4281 *chip = device->device_data;
 	return snd_cs4281_free(chip);
 }
 
-static int snd_cs4281_chip_init(cs4281_t *chip); /* defined below */
+static int snd_cs4281_chip_init(struct cs4281 *chip); /* defined below */
 #ifdef CONFIG_PM
-static int cs4281_suspend(snd_card_t *card, pm_message_t state);
-static int cs4281_resume(snd_card_t *card);
+static int cs4281_suspend(struct snd_card *card, pm_message_t state);
+static int cs4281_resume(struct snd_card *card);
 #endif
 
-static int __devinit snd_cs4281_create(snd_card_t * card,
+static int __devinit snd_cs4281_create(struct snd_card *card,
 				       struct pci_dev *pci,
-				       cs4281_t ** rchip,
+				       struct cs4281 ** rchip,
 				       int dual_codec)
 {
-	cs4281_t *chip;
+	struct cs4281 *chip;
 	unsigned int tmp;
 	int err;
-	static snd_device_ops_t ops = {
+	static struct snd_device_ops ops = {
 		.dev_free =	snd_cs4281_dev_free,
 	};
 
@@ -1376,7 +1383,8 @@ static int __devinit snd_cs4281_create(snd_card_t * card,
 	chip->ba0_addr = pci_resource_start(pci, 0);
 	chip->ba1_addr = pci_resource_start(pci, 1);
 
-	if (request_irq(pci->irq, snd_cs4281_interrupt, SA_INTERRUPT|SA_SHIRQ, "CS4281", (void *)chip)) {
+	if (request_irq(pci->irq, snd_cs4281_interrupt, SA_INTERRUPT|SA_SHIRQ,
+			"CS4281", chip)) {
 		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
 		snd_cs4281_free(chip);
 		return -ENOMEM;
@@ -1411,7 +1419,7 @@ static int __devinit snd_cs4281_create(snd_card_t * card,
 	return 0;
 }
 
-static int snd_cs4281_chip_init(cs4281_t *chip)
+static int snd_cs4281_chip_init(struct cs4281 *chip)
 {
 	unsigned int tmp;
 	int timeout;
@@ -1587,7 +1595,7 @@ static int snd_cs4281_chip_init(cs4281_t *chip)
 	 *  Initialize DMA structures
 	 */
 	for (tmp = 0; tmp < 4; tmp++) {
-		cs4281_dma_t *dma = &chip->dma[tmp];
+		struct cs4281_dma *dma = &chip->dma[tmp];
 		dma->regDBA = BA0_DBA0 + (tmp * 0x10);
 		dma->regDCA = BA0_DCA0 + (tmp * 0x10);
 		dma->regDBC = BA0_DBC0 + (tmp * 0x10);
@@ -1644,16 +1652,16 @@ static int snd_cs4281_chip_init(cs4281_t *chip)
  *  MIDI section
  */
 
-static void snd_cs4281_midi_reset(cs4281_t *chip)
+static void snd_cs4281_midi_reset(struct cs4281 *chip)
 {
 	snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr | BA0_MIDCR_MRST);
 	udelay(100);
 	snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
 }
 
-static int snd_cs4281_midi_input_open(snd_rawmidi_substream_t * substream)
+static int snd_cs4281_midi_input_open(struct snd_rawmidi_substream *substream)
 {
-	cs4281_t *chip = substream->rmidi->private_data;
+	struct cs4281 *chip = substream->rmidi->private_data;
 
 	spin_lock_irq(&chip->reg_lock);
  	chip->midcr |= BA0_MIDCR_RXE;
@@ -1667,9 +1675,9 @@ static int snd_cs4281_midi_input_open(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static int snd_cs4281_midi_input_close(snd_rawmidi_substream_t * substream)
+static int snd_cs4281_midi_input_close(struct snd_rawmidi_substream *substream)
 {
-	cs4281_t *chip = substream->rmidi->private_data;
+	struct cs4281 *chip = substream->rmidi->private_data;
 
 	spin_lock_irq(&chip->reg_lock);
 	chip->midcr &= ~(BA0_MIDCR_RXE | BA0_MIDCR_RIE);
@@ -1684,9 +1692,9 @@ static int snd_cs4281_midi_input_close(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static int snd_cs4281_midi_output_open(snd_rawmidi_substream_t * substream)
+static int snd_cs4281_midi_output_open(struct snd_rawmidi_substream *substream)
 {
-	cs4281_t *chip = substream->rmidi->private_data;
+	struct cs4281 *chip = substream->rmidi->private_data;
 
 	spin_lock_irq(&chip->reg_lock);
 	chip->uartm |= CS4281_MODE_OUTPUT;
@@ -1701,9 +1709,9 @@ static int snd_cs4281_midi_output_open(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static int snd_cs4281_midi_output_close(snd_rawmidi_substream_t * substream)
+static int snd_cs4281_midi_output_close(struct snd_rawmidi_substream *substream)
 {
-	cs4281_t *chip = substream->rmidi->private_data;
+	struct cs4281 *chip = substream->rmidi->private_data;
 
 	spin_lock_irq(&chip->reg_lock);
 	chip->midcr &= ~(BA0_MIDCR_TXE | BA0_MIDCR_TIE);
@@ -1718,10 +1726,10 @@ static int snd_cs4281_midi_output_close(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static void snd_cs4281_midi_input_trigger(snd_rawmidi_substream_t * substream, int up)
+static void snd_cs4281_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)
 {
 	unsigned long flags;
-	cs4281_t *chip = substream->rmidi->private_data;
+	struct cs4281 *chip = substream->rmidi->private_data;
 
 	spin_lock_irqsave(&chip->reg_lock, flags);
 	if (up) {
@@ -1738,10 +1746,10 @@ static void snd_cs4281_midi_input_trigger(snd_rawmidi_substream_t * substream, i
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 }
 
-static void snd_cs4281_midi_output_trigger(snd_rawmidi_substream_t * substream, int up)
+static void snd_cs4281_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)
 {
 	unsigned long flags;
-	cs4281_t *chip = substream->rmidi->private_data;
+	struct cs4281 *chip = substream->rmidi->private_data;
 	unsigned char byte;
 
 	spin_lock_irqsave(&chip->reg_lock, flags);
@@ -1768,23 +1776,24 @@ static void snd_cs4281_midi_output_trigger(snd_rawmidi_substream_t * substream,
 	spin_unlock_irqrestore(&chip->reg_lock, flags);
 }
 
-static snd_rawmidi_ops_t snd_cs4281_midi_output =
+static struct snd_rawmidi_ops snd_cs4281_midi_output =
 {
 	.open =		snd_cs4281_midi_output_open,
 	.close =	snd_cs4281_midi_output_close,
 	.trigger =	snd_cs4281_midi_output_trigger,
 };
 
-static snd_rawmidi_ops_t snd_cs4281_midi_input =
+static struct snd_rawmidi_ops snd_cs4281_midi_input =
 {
 	.open = 	snd_cs4281_midi_input_open,
 	.close =	snd_cs4281_midi_input_close,
 	.trigger =	snd_cs4281_midi_input_trigger,
 };
 
-static int __devinit snd_cs4281_midi(cs4281_t * chip, int device, snd_rawmidi_t **rrawmidi)
+static int __devinit snd_cs4281_midi(struct cs4281 * chip, int device,
+				     struct snd_rawmidi **rrawmidi)
 {
-	snd_rawmidi_t *rmidi;
+	struct snd_rawmidi *rmidi;
 	int err;
 
 	if (rrawmidi)
@@ -1808,9 +1817,9 @@ static int __devinit snd_cs4281_midi(cs4281_t * chip, int device, snd_rawmidi_t
 
 static irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	cs4281_t *chip = dev_id;
+	struct cs4281 *chip = dev_id;
 	unsigned int status, dma, val;
-	cs4281_dma_t *cdma;
+	struct cs4281_dma *cdma;
 
 	if (chip == NULL)
 		return IRQ_NONE;
@@ -1880,10 +1889,11 @@ static irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id, struct pt_regs *r
 /*
  * OPL3 command
  */
-static void snd_cs4281_opl3_command(opl3_t * opl3, unsigned short cmd, unsigned char val)
+static void snd_cs4281_opl3_command(struct snd_opl3 *opl3, unsigned short cmd,
+				    unsigned char val)
 {
 	unsigned long flags;
-	cs4281_t *chip = opl3->private_data;
+	struct cs4281 *chip = opl3->private_data;
 	void __iomem *port;
 
 	if (cmd & OPL3_RIGHT)
@@ -1906,9 +1916,9 @@ static int __devinit snd_cs4281_probe(struct pci_dev *pci,
 				      const struct pci_device_id *pci_id)
 {
 	static int dev;
-	snd_card_t *card;
-	cs4281_t *chip;
-	opl3_t *opl3;
+	struct snd_card *card;
+	struct cs4281 *chip;
+	struct snd_opl3 *opl3;
 	int err;
 
         if (dev >= SNDRV_CARDS)
@@ -1997,9 +2007,9 @@ static int saved_regs[SUSPEND_REGISTERS] = {
 
 #define CLKCR1_CKRA                             0x00010000L
 
-static int cs4281_suspend(snd_card_t *card, pm_message_t state)
+static int cs4281_suspend(struct snd_card *card, pm_message_t state)
 {
-	cs4281_t *chip = card->pm_private_data;
+	struct cs4281 *chip = card->pm_private_data;
 	u32 ulCLK;
 	unsigned int i;
 
@@ -2042,9 +2052,9 @@ static int cs4281_suspend(snd_card_t *card, pm_message_t state)
 	return 0;
 }
 
-static int cs4281_resume(snd_card_t *card)
+static int cs4281_resume(struct snd_card *card)
 {
-	cs4281_t *chip = card->pm_private_data;
+	struct cs4281 *chip = card->pm_private_data;
 	unsigned int i;
 	u32 ulCLK;
 

commit c9a49bb1957f45e0146c17a865f1444fd06c0f97
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 10:36:57 2005 +0100

    [ALSA] cs4281 - Clean up delay function
    
    Modules: CS4281 driver
    
    Remove the own delay function.
    Call appropriate functions directly.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index a4b4608034b6..c99bb1f2bfa8 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -514,27 +514,6 @@ MODULE_DEVICE_TABLE(pci, snd_cs4281_ids);
  *  common I/O routines
  */
 
-static void snd_cs4281_delay(unsigned int delay)
-{
-	if (delay > 999) {
-		unsigned long end_time;
-		delay = (delay * HZ) / 1000000;
-		if (delay < 1)
-			delay = 1;
-		end_time = jiffies + delay;
-		do {
-			schedule_timeout_uninterruptible(1);
-		} while (time_after_eq(end_time, jiffies));
-	} else {
-		udelay(delay);
-	}
-}
-
-static inline void snd_cs4281_delay_long(void)
-{
-	schedule_timeout_uninterruptible(1);
-}
-
 static inline void snd_cs4281_pokeBA0(cs4281_t *chip, unsigned long offset, unsigned int val)
 {
         writel(val, chip->ba0 + offset);
@@ -1493,7 +1472,7 @@ static int snd_cs4281_chip_init(cs4281_t *chip)
 	snd_cs4281_pokeBA0(chip, BA0_SPMC, 0);
 	udelay(50);
 	snd_cs4281_pokeBA0(chip, BA0_SPMC, BA0_SPMC_RSTN);
-	snd_cs4281_delay(50000);
+	msleep(50);
 
 	if (chip->dual_codec)
 		snd_cs4281_pokeBA0(chip, BA0_SPMC, BA0_SPMC_RSTN | BA0_SPMC_ASDI2E);
@@ -1509,13 +1488,13 @@ static int snd_cs4281_chip_init(cs4281_t *chip)
 	 *  Start the DLL Clock logic.
 	 */
 	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, BA0_CLKCR1_DLLP);
-	snd_cs4281_delay(50000);
+	msleep(50);
 	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, BA0_CLKCR1_SWCE | BA0_CLKCR1_DLLP);
 
 	/*
 	 * Wait for the DLL ready signal from the clock logic.
 	 */
-	timeout = HZ;
+	timeout = 100;
 	do {
 		/*
 		 *  Read the AC97 status register to see if we've seen a CODEC
@@ -1523,7 +1502,7 @@ static int snd_cs4281_chip_init(cs4281_t *chip)
 		 */
 		if (snd_cs4281_peekBA0(chip, BA0_CLKCR1) & BA0_CLKCR1_DLLRDY)
 			goto __ok0;
-		snd_cs4281_delay_long();
+		msleep(1);
 	} while (timeout-- > 0);
 
 	snd_printk(KERN_ERR "DLLRDY not seen\n");
@@ -1541,7 +1520,7 @@ static int snd_cs4281_chip_init(cs4281_t *chip)
 	/*
 	 * Wait for the codec ready signal from the AC97 codec.
 	 */
-	timeout = HZ;
+	timeout = 100;
 	do {
 		/*
 		 *  Read the AC97 status register to see if we've seen a CODEC
@@ -1549,7 +1528,7 @@ static int snd_cs4281_chip_init(cs4281_t *chip)
 		 */
 		if (snd_cs4281_peekBA0(chip, BA0_ACSTS) & BA0_ACSTS_CRDY)
 			goto __ok1;
-		snd_cs4281_delay_long();
+		msleep(1);
 	} while (timeout-- > 0);
 
 	snd_printk(KERN_ERR "never read codec ready from AC'97 (0x%x)\n", snd_cs4281_peekBA0(chip, BA0_ACSTS));
@@ -1557,11 +1536,11 @@ static int snd_cs4281_chip_init(cs4281_t *chip)
 
       __ok1:
 	if (chip->dual_codec) {
-		timeout = HZ;
+		timeout = 100;
 		do {
 			if (snd_cs4281_peekBA0(chip, BA0_ACSTS2) & BA0_ACSTS_CRDY)
 				goto __codec2_ok;
-			snd_cs4281_delay_long();
+			msleep(1);
 		} while (timeout-- > 0);
 		snd_printk(KERN_INFO "secondary codec doesn't respond. disable it...\n");
 		chip->dual_codec = 0;
@@ -1580,7 +1559,7 @@ static int snd_cs4281_chip_init(cs4281_t *chip)
 	 *  the codec is pumping ADC data across the AC-link.
 	 */
 
-	timeout = HZ;
+	timeout = 100;
 	do {
 		/*
 		 *  Read the input slot valid register and see if input slots 3
@@ -1588,7 +1567,7 @@ static int snd_cs4281_chip_init(cs4281_t *chip)
 		 */
                 if ((snd_cs4281_peekBA0(chip, BA0_ACISV) & (BA0_ACISV_SLV(3) | BA0_ACISV_SLV(4))) == (BA0_ACISV_SLV(3) | BA0_ACISV_SLV(4)))
                         goto __ok2;
-		snd_cs4281_delay_long();
+		msleep(1);
 	} while (timeout-- > 0);
 
 	if (--retry_count > 0)

commit c3e6f7d8763fa0400d28c57633eb323515ba05fc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 16 18:43:35 2005 +0100

    [ALSA] Remove superfluous pcm_free callbacks
    
    Remove superflous pcm_free callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 034ff3755a3b..a4b4608034b6 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -990,13 +990,6 @@ static snd_pcm_ops_t snd_cs4281_capture_ops = {
 	.pointer =	snd_cs4281_pointer,
 };
 
-static void snd_cs4281_pcm_free(snd_pcm_t *pcm)
-{
-	cs4281_t *chip = pcm->private_data;
-	chip->pcm = NULL;
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
 static int __devinit snd_cs4281_pcm(cs4281_t * chip, int device, snd_pcm_t ** rpcm)
 {
 	snd_pcm_t *pcm;
@@ -1012,7 +1005,6 @@ static int __devinit snd_cs4281_pcm(cs4281_t * chip, int device, snd_pcm_t ** rp
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cs4281_capture_ops);
 
 	pcm->private_data = chip;
-	pcm->private_free = snd_cs4281_pcm_free;
 	pcm->info_flags = 0;
 	strcpy(pcm->name, "CS4281");
 	chip->pcm = pcm;

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index aea2c47712f9..034ff3755a3b 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -2106,7 +2106,6 @@ static int cs4281_resume(snd_card_t *card)
 
 static struct pci_driver driver = {
 	.name = "CS4281",
-	.owner = THIS_MODULE,
 	.id_table = snd_cs4281_ids,
 	.probe = snd_cs4281_probe,
 	.remove = __devexit_p(snd_cs4281_remove),

commit 8433a509c0eb6bb1f33ce39c82c580b8901619ee
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Mon Oct 24 15:02:37 2005 +0200

    [ALSA] Fix schedule_timeout usage
    
    Use schedule_timeout_{,un}interruptible() instead of
    set_current_state()/schedule_timeout() to reduce kernel size.  Also use
    human-time conversion functions instead of hard-coded division to avoid
    rounding issues.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index dc87e0144b5a..aea2c47712f9 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -523,8 +523,7 @@ static void snd_cs4281_delay(unsigned int delay)
 			delay = 1;
 		end_time = jiffies + delay;
 		do {
-			set_current_state(TASK_UNINTERRUPTIBLE);
-			schedule_timeout(1);
+			schedule_timeout_uninterruptible(1);
 		} while (time_after_eq(end_time, jiffies));
 	} else {
 		udelay(delay);
@@ -533,8 +532,7 @@ static void snd_cs4281_delay(unsigned int delay)
 
 static inline void snd_cs4281_delay_long(void)
 {
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	schedule_timeout(1);
+	schedule_timeout_uninterruptible(1);
 }
 
 static inline void snd_cs4281_pokeBA0(cs4281_t *chip, unsigned long offset, unsigned int val)

commit 3bcd4649bca99ee9242f20d7da35e3f8741c6549
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 12 08:20:54 2005 +0200

    [ALSA] set owner field in struct pci_driver
    
    AD1889 driver,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CS46xx driver,EMU10K1/EMU10K2 driver
    HDA Intel driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    MIXART driver,NM256 driver,RME HDSP driver,RME9652 driver
    Trident driver,Digigram VX222 driver,YMFPCI driver
    Set the module owner field in each driver's struct pci_driver to get
    the driver symlink in the sysfs device directory.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 421430bad989..dc87e0144b5a 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -2108,6 +2108,7 @@ static int cs4281_resume(snd_card_t *card)
 
 static struct pci_driver driver = {
 	.name = "CS4281",
+	.owner = THIS_MODULE,
 	.id_table = snd_cs4281_ids,
 	.probe = snd_cs4281_probe,
 	.remove = __devexit_p(snd_cs4281_remove),

commit e560d8d8368ad8b6161839984b253de622863265
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Sep 9 14:21:46 2005 +0200

    [ALSA] Replace with kzalloc() - pci stuff
    
    AD1889 driver,ATIIXP driver,ATIIXP-modem driver,AZT3328 driver
    BT87x driver,CMIPCI driver,CS4281 driver,ENS1370/1+ driver
    ES1938 driver,ES1968 driver,FM801 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,SonicVibes driver,VIA82xx driver
    VIA82xx-modem driver,AC97 Codec,AK4531 codec,au88x0 driver
    CA0106 driver,CS46xx driver,EMU10K1/EMU10K2 driver,HDA Codec driver
    HDA generic driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,Trident driver,YMFPCI driver
    Replace kcalloc(1,..) with kzalloc().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index e3e03028c721..421430bad989 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1383,7 +1383,7 @@ static int __devinit snd_cs4281_create(snd_card_t * card,
 	*rchip = NULL;
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;
-	chip = kcalloc(1, sizeof(*chip), GFP_KERNEL);
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
 	if (chip == NULL) {
 		pci_disable_device(pci);
 		return -ENOMEM;

commit 8cdfd2519c6c9a1e6057dc5970b2542b35895738
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 7 14:08:11 2005 +0200

    [ALSA] Remove superfluous PCI ID definitions
    
    CS46xx driver,EMU10K1/EMU10K2 driver,PCM Midlevel,Trident driver
    YMFPCI driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,RME32 driver,RME96 driver
    SonicVibes driver,VIA82xx driver,ALI5451 driver,ICE1712 driver
    ICE1724 driver,NM256 driver,RME HDSP driver,RME9652 driver
    Remove superfluous PCI ID definitions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index c7a370d4f923..e3e03028c721 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -56,17 +56,6 @@ MODULE_PARM_DESC(enable, "Enable CS4281 soundcard.");
 module_param_array(dual_codec, bool, NULL, 0444);
 MODULE_PARM_DESC(dual_codec, "Secondary Codec ID (0 = disabled).");
 
-/*
- *
- */
-
-#ifndef PCI_VENDOR_ID_CIRRUS
-#define PCI_VENDOR_ID_CIRRUS            0x1013
-#endif
-#ifndef PCI_DEVICE_ID_CIRRUS_4281
-#define PCI_DEVICE_ID_CIRRUS_4281	0x6005
-#endif
-
 /*
  *  Direct registers
  */

commit 77933d7276ee8fa0e2947641941a6f7a100a327b
Author: Jesper Juhl <juhl@dif.dk>
Date:   Wed Jul 27 11:46:09 2005 -0700

    [PATCH] clean up inline static vs static inline
    
    `gcc -W' likes to complain if the static keyword is not at the beginning of
    the declaration.  This patch fixes all remaining occurrences of "inline
    static" up with "static inline" in the entire kernel tree (140 occurrences in
    47 files).
    
    While making this change I came across a few lines with trailing whitespace
    that I also fixed up, I have also added or removed a blank line or two here
    and there, but there are no functional changes in the patch.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index eb3c52b03af3..c7a370d4f923 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -542,7 +542,7 @@ static void snd_cs4281_delay(unsigned int delay)
 	}
 }
 
-inline static void snd_cs4281_delay_long(void)
+static inline void snd_cs4281_delay_long(void)
 {
 	set_current_state(TASK_UNINTERRUPTIBLE);
 	schedule_timeout(1);

commit 3e0777b8fa96f7073ed5d13d3bc1d573b766bef9
Merge: a94130e00038 e5119885f008
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Mon Jun 27 14:47:31 2005 -0700

    Merge rsync://rsync.kernel.org/pub/scm/linux/kernel/git/dtor/input.git manually
    
    Some manual fixups required due to clashes with the PF_FREEZE cleanups.

commit cc2d7eeacaff6ccdf407a3555cc3373890f79e01
Author: Adrian Bunk <bunk@stusta.de>
Date:   Wed Jun 1 02:39:11 2005 -0500

    Input: kill empty comment in gameport support section of
           cs4281 ALSA driver.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Vojtech Pavlik <vojtech@suse.cz>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index d7e06b3caf97..0b53f7c61f86 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -1335,11 +1335,6 @@ static inline int snd_cs4281_create_gameport(cs4281_t *chip) { return -ENOSYS; }
 static inline void snd_cs4281_free_gameport(cs4281_t *chip) { }
 #endif /* CONFIG_GAMEPORT || (MODULE && CONFIG_GAMEPORT_MODULE) */
 
-
-/*
-
- */
-
 static int snd_cs4281_free(cs4281_t *chip)
 {
 	snd_cs4281_free_gameport(chip);

commit a488e033861363f64ed90d01622e0c30b382b753
Author: Arnaud Patard <arnaud.patard@rtp-net.org>
Date:   Sat May 7 18:51:51 2005 +0200

    [ALSA] cs4281 - fix DLLRDY not seen problem
    
    CS4281 driver
    Reset the FPDN bit of the EPPMC register if needed.
    
    Signed-off-by: Arnaud Patard <arnaud.patard@rtp-net.org>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index 8b42e8631f2a..b6e1854e9389 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -206,7 +206,10 @@ MODULE_PARM_DESC(dual_codec, "Secondary Codec ID (0 = disabled).");
 
 #define BA0_PMCS		0x0344	/* Power Management Control/Status */
 #define BA0_CWPR		0x03e0	/* Configuration Write Protect */
+
 #define BA0_EPPMC		0x03e4	/* Extended PCI Power Management Control */
+#define BA0_EPPMC_FPDN		(1<<14) /* Full Power DowN */
+
 #define BA0_GPIOR		0x03e8	/* GPIO Pin Interface Register */
 
 #define BA0_SPMC		0x03ec	/* Serial Port Power Management Control (& ASDIN2 enable) */
@@ -1461,6 +1464,11 @@ static int snd_cs4281_chip_init(cs4281_t *chip)
 	int timeout;
 	int retry_count = 2;
 
+	/* Having EPPMC.FPDN=1 prevent proper chip initialisation */
+	tmp = snd_cs4281_peekBA0(chip, BA0_EPPMC);
+	if (tmp & BA0_EPPMC_FPDN)
+		snd_cs4281_pokeBA0(chip, BA0_EPPMC, tmp & ~BA0_EPPMC_FPDN);
+
       __retry:
 	tmp = snd_cs4281_peekBA0(chip, BA0_CFLR);
 	if (tmp != BA0_CFLR_DEFAULT) {

commit 01d25d460a3b28aab537fab9a0038d1b5832ce28
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Apr 11 16:58:24 2005 +0200

    [ALSA] Replace pci_module_init() with pci_register_driver()
    
    Documentation,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CA0106 driver,CS46xx driver
    EMU10K1/EMU10K2 driver,HDA Intel driver,ICE1712 driver,ICE1724 driver
    KORG1212 driver,MIXART driver,NM256 driver,RME HDSP driver
    RME9652 driver,Trident driver,Digigram VX222 driver,YMFPCI driver
    Replace the obsolete pci_module_init() with pci_register_driver().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
index d7e06b3caf97..8b42e8631f2a 100644
--- a/sound/pci/cs4281.c
+++ b/sound/pci/cs4281.c
@@ -2124,7 +2124,7 @@ static struct pci_driver driver = {
 	
 static int __init alsa_card_cs4281_init(void)
 {
-	return pci_module_init(&driver);
+	return pci_register_driver(&driver);
 }
 
 static void __exit alsa_card_cs4281_exit(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/sound/pci/cs4281.c b/sound/pci/cs4281.c
new file mode 100644
index 000000000000..d7e06b3caf97
--- /dev/null
+++ b/sound/pci/cs4281.c
@@ -0,0 +1,2136 @@
+/*
+ *  Driver for Cirrus Logic CS4281 based PCI soundcard
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>,
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/gameport.h>
+#include <linux/moduleparam.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/rawmidi.h>
+#include <sound/ac97_codec.h>
+#include <sound/opl3.h>
+#include <sound/initval.h>
+
+
+MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
+MODULE_DESCRIPTION("Cirrus Logic CS4281");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{Cirrus Logic,CS4281}}");
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;	/* Enable switches */
+static int dual_codec[SNDRV_CARDS];	/* dual codec */
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for CS4281 soundcard.");
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for CS4281 soundcard.");
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable CS4281 soundcard.");
+module_param_array(dual_codec, bool, NULL, 0444);
+MODULE_PARM_DESC(dual_codec, "Secondary Codec ID (0 = disabled).");
+
+/*
+ *
+ */
+
+#ifndef PCI_VENDOR_ID_CIRRUS
+#define PCI_VENDOR_ID_CIRRUS            0x1013
+#endif
+#ifndef PCI_DEVICE_ID_CIRRUS_4281
+#define PCI_DEVICE_ID_CIRRUS_4281	0x6005
+#endif
+
+/*
+ *  Direct registers
+ */
+
+#define CS4281_BA0_SIZE		0x1000
+#define CS4281_BA1_SIZE		0x10000
+
+/*
+ *  BA0 registers
+ */
+#define BA0_HISR		0x0000	/* Host Interrupt Status Register */
+#define BA0_HISR_INTENA		(1<<31)	/* Internal Interrupt Enable Bit */
+#define BA0_HISR_MIDI		(1<<22)	/* MIDI port interrupt */
+#define BA0_HISR_FIFOI		(1<<20)	/* FIFO polled interrupt */
+#define BA0_HISR_DMAI		(1<<18)	/* DMA interrupt (half or end) */
+#define BA0_HISR_FIFO(c)	(1<<(12+(c))) /* FIFO channel interrupt */
+#define BA0_HISR_DMA(c)		(1<<(8+(c)))  /* DMA channel interrupt */
+#define BA0_HISR_GPPI		(1<<5)	/* General Purpose Input (Primary chip) */
+#define BA0_HISR_GPSI		(1<<4)	/* General Purpose Input (Secondary chip) */
+#define BA0_HISR_GP3I		(1<<3)	/* GPIO3 pin Interrupt */
+#define BA0_HISR_GP1I		(1<<2)	/* GPIO1 pin Interrupt */
+#define BA0_HISR_VUPI		(1<<1)	/* VOLUP pin Interrupt */
+#define BA0_HISR_VDNI		(1<<0)	/* VOLDN pin Interrupt */
+
+#define BA0_HICR		0x0008	/* Host Interrupt Control Register */
+#define BA0_HICR_CHGM		(1<<1)	/* INTENA Change Mask */
+#define BA0_HICR_IEV		(1<<0)	/* INTENA Value */
+#define BA0_HICR_EOI		(3<<0)	/* End of Interrupt command */
+
+#define BA0_HIMR		0x000c	/* Host Interrupt Mask Register */
+					/* Use same contants as for BA0_HISR */
+
+#define BA0_IIER		0x0010	/* ISA Interrupt Enable Register */
+
+#define BA0_HDSR0		0x00f0	/* Host DMA Engine 0 Status Register */
+#define BA0_HDSR1		0x00f4	/* Host DMA Engine 1 Status Register */
+#define BA0_HDSR2		0x00f8	/* Host DMA Engine 2 Status Register */
+#define BA0_HDSR3		0x00fc	/* Host DMA Engine 3 Status Register */
+
+#define BA0_HDSR_CH1P		(1<<25)	/* Channel 1 Pending */
+#define BA0_HDSR_CH2P		(1<<24)	/* Channel 2 Pending */
+#define BA0_HDSR_DHTC		(1<<17)	/* DMA Half Terminal Count */
+#define BA0_HDSR_DTC		(1<<16)	/* DMA Terminal Count */
+#define BA0_HDSR_DRUN		(1<<15)	/* DMA Running */
+#define BA0_HDSR_RQ		(1<<7)	/* Pending Request */
+
+#define BA0_DCA0		0x0110	/* Host DMA Engine 0 Current Address */
+#define BA0_DCC0		0x0114	/* Host DMA Engine 0 Current Count */
+#define BA0_DBA0		0x0118	/* Host DMA Engine 0 Base Address */
+#define BA0_DBC0		0x011c	/* Host DMA Engine 0 Base Count */
+#define BA0_DCA1		0x0120	/* Host DMA Engine 1 Current Address */
+#define BA0_DCC1		0x0124	/* Host DMA Engine 1 Current Count */
+#define BA0_DBA1		0x0128	/* Host DMA Engine 1 Base Address */
+#define BA0_DBC1		0x012c	/* Host DMA Engine 1 Base Count */
+#define BA0_DCA2		0x0130	/* Host DMA Engine 2 Current Address */
+#define BA0_DCC2		0x0134	/* Host DMA Engine 2 Current Count */
+#define BA0_DBA2		0x0138	/* Host DMA Engine 2 Base Address */
+#define BA0_DBC2		0x013c	/* Host DMA Engine 2 Base Count */
+#define BA0_DCA3		0x0140	/* Host DMA Engine 3 Current Address */
+#define BA0_DCC3		0x0144	/* Host DMA Engine 3 Current Count */
+#define BA0_DBA3		0x0148	/* Host DMA Engine 3 Base Address */
+#define BA0_DBC3		0x014c	/* Host DMA Engine 3 Base Count */
+#define BA0_DMR0		0x0150	/* Host DMA Engine 0 Mode */
+#define BA0_DCR0		0x0154	/* Host DMA Engine 0 Command */
+#define BA0_DMR1		0x0158	/* Host DMA Engine 1 Mode */
+#define BA0_DCR1		0x015c	/* Host DMA Engine 1 Command */
+#define BA0_DMR2		0x0160	/* Host DMA Engine 2 Mode */
+#define BA0_DCR2		0x0164	/* Host DMA Engine 2 Command */
+#define BA0_DMR3		0x0168	/* Host DMA Engine 3 Mode */
+#define BA0_DCR3		0x016c	/* Host DMA Engine 3 Command */
+
+#define BA0_DMR_DMA		(1<<29)	/* Enable DMA mode */
+#define BA0_DMR_POLL		(1<<28)	/* Enable poll mode */
+#define BA0_DMR_TBC		(1<<25)	/* Transfer By Channel */
+#define BA0_DMR_CBC		(1<<24)	/* Count By Channel (0 = frame resolution) */
+#define BA0_DMR_SWAPC		(1<<22)	/* Swap Left/Right Channels */
+#define BA0_DMR_SIZE20		(1<<20)	/* Sample is 20-bit */
+#define BA0_DMR_USIGN		(1<<19)	/* Unsigned */
+#define BA0_DMR_BEND		(1<<18)	/* Big Endian */
+#define BA0_DMR_MONO		(1<<17)	/* Mono */
+#define BA0_DMR_SIZE8		(1<<16)	/* Sample is 8-bit */
+#define BA0_DMR_TYPE_DEMAND	(0<<6)
+#define BA0_DMR_TYPE_SINGLE	(1<<6)
+#define BA0_DMR_TYPE_BLOCK	(2<<6)
+#define BA0_DMR_TYPE_CASCADE	(3<<6)	/* Not supported */
+#define BA0_DMR_DEC		(1<<5)	/* Access Increment (0) or Decrement (1) */
+#define BA0_DMR_AUTO		(1<<4)	/* Auto-Initialize */
+#define BA0_DMR_TR_VERIFY	(0<<2)	/* Verify Transfer */
+#define BA0_DMR_TR_WRITE	(1<<2)	/* Write Transfer */
+#define BA0_DMR_TR_READ		(2<<2)	/* Read Transfer */
+
+#define BA0_DCR_HTCIE		(1<<17)	/* Half Terminal Count Interrupt */
+#define BA0_DCR_TCIE		(1<<16)	/* Terminal Count Interrupt */
+#define BA0_DCR_MSK		(1<<0)	/* DMA Mask bit */
+
+#define BA0_FCR0		0x0180	/* FIFO Control 0 */
+#define BA0_FCR1		0x0184	/* FIFO Control 1 */
+#define BA0_FCR2		0x0188	/* FIFO Control 2 */
+#define BA0_FCR3		0x018c	/* FIFO Control 3 */
+
+#define BA0_FCR_FEN		(1<<31)	/* FIFO Enable bit */
+#define BA0_FCR_DACZ		(1<<30)	/* DAC Zero */
+#define BA0_FCR_PSH		(1<<29)	/* Previous Sample Hold */
+#define BA0_FCR_RS(x)		(((x)&0x1f)<<24) /* Right Slot Mapping */
+#define BA0_FCR_LS(x)		(((x)&0x1f)<<16) /* Left Slot Mapping */
+#define BA0_FCR_SZ(x)		(((x)&0x7f)<<8)	/* FIFO buffer size (in samples) */
+#define BA0_FCR_OF(x)		(((x)&0x7f)<<0)	/* FIFO starting offset (in samples) */
+
+#define BA0_FPDR0		0x0190	/* FIFO Polled Data 0 */
+#define BA0_FPDR1		0x0194	/* FIFO Polled Data 1 */
+#define BA0_FPDR2		0x0198	/* FIFO Polled Data 2 */
+#define BA0_FPDR3		0x019c	/* FIFO Polled Data 3 */
+
+#define BA0_FCHS		0x020c	/* FIFO Channel Status */
+#define BA0_FCHS_RCO(x)		(1<<(7+(((x)&3)<<3))) /* Right Channel Out */
+#define BA0_FCHS_LCO(x)		(1<<(6+(((x)&3)<<3))) /* Left Channel Out */
+#define BA0_FCHS_MRP(x)		(1<<(5+(((x)&3)<<3))) /* Move Read Pointer */
+#define BA0_FCHS_FE(x)		(1<<(4+(((x)&3)<<3))) /* FIFO Empty */
+#define BA0_FCHS_FF(x)		(1<<(3+(((x)&3)<<3))) /* FIFO Full */
+#define BA0_FCHS_IOR(x)		(1<<(2+(((x)&3)<<3))) /* Internal Overrun Flag */
+#define BA0_FCHS_RCI(x)		(1<<(1+(((x)&3)<<3))) /* Right Channel In */
+#define BA0_FCHS_LCI(x)		(1<<(0+(((x)&3)<<3))) /* Left Channel In */
+
+#define BA0_FSIC0		0x0210	/* FIFO Status and Interrupt Control 0 */
+#define BA0_FSIC1		0x0214	/* FIFO Status and Interrupt Control 1 */
+#define BA0_FSIC2		0x0218	/* FIFO Status and Interrupt Control 2 */
+#define BA0_FSIC3		0x021c	/* FIFO Status and Interrupt Control 3 */
+
+#define BA0_FSIC_FIC(x)		(((x)&0x7f)<<24) /* FIFO Interrupt Count */
+#define BA0_FSIC_FORIE		(1<<23) /* FIFO OverRun Interrupt Enable */
+#define BA0_FSIC_FURIE		(1<<22) /* FIFO UnderRun Interrupt Enable */
+#define BA0_FSIC_FSCIE		(1<<16)	/* FIFO Sample Count Interrupt Enable */
+#define BA0_FSIC_FSC(x)		(((x)&0x7f)<<8) /* FIFO Sample Count */
+#define BA0_FSIC_FOR		(1<<7)	/* FIFO OverRun */
+#define BA0_FSIC_FUR		(1<<6)	/* FIFO UnderRun */
+#define BA0_FSIC_FSCR		(1<<0)	/* FIFO Sample Count Reached */
+
+#define BA0_PMCS		0x0344	/* Power Management Control/Status */
+#define BA0_CWPR		0x03e0	/* Configuration Write Protect */
+#define BA0_EPPMC		0x03e4	/* Extended PCI Power Management Control */
+#define BA0_GPIOR		0x03e8	/* GPIO Pin Interface Register */
+
+#define BA0_SPMC		0x03ec	/* Serial Port Power Management Control (& ASDIN2 enable) */
+#define BA0_SPMC_GIPPEN		(1<<15)	/* GP INT Primary PME# Enable */
+#define BA0_SPMC_GISPEN		(1<<14)	/* GP INT Secondary PME# Enable */
+#define BA0_SPMC_EESPD		(1<<9)	/* EEPROM Serial Port Disable */
+#define BA0_SPMC_ASDI2E		(1<<8)	/* ASDIN2 Enable */
+#define BA0_SPMC_ASDO		(1<<7)	/* Asynchronous ASDOUT Assertion */
+#define BA0_SPMC_WUP2		(1<<3)	/* Wakeup for Secondary Input */
+#define BA0_SPMC_WUP1		(1<<2)	/* Wakeup for Primary Input */
+#define BA0_SPMC_ASYNC		(1<<1)	/* Asynchronous ASYNC Assertion */
+#define BA0_SPMC_RSTN		(1<<0)	/* Reset Not! */
+
+#define BA0_CFLR		0x03f0	/* Configuration Load Register (EEPROM or BIOS) */
+#define BA0_CFLR_DEFAULT	0x00000001 /* CFLR must be in AC97 link mode */
+#define BA0_IISR		0x03f4	/* ISA Interrupt Select */
+#define BA0_TMS			0x03f8	/* Test Register */
+#define BA0_SSVID		0x03fc	/* Subsystem ID register */
+
+#define BA0_CLKCR1		0x0400	/* Clock Control Register 1 */
+#define BA0_CLKCR1_CLKON	(1<<25)	/* Read Only */
+#define BA0_CLKCR1_DLLRDY	(1<<24)	/* DLL Ready */
+#define BA0_CLKCR1_DLLOS	(1<<6)	/* DLL Output Select */
+#define BA0_CLKCR1_SWCE		(1<<5)	/* Clock Enable */
+#define BA0_CLKCR1_DLLP		(1<<4)	/* DLL PowerUp */
+#define BA0_CLKCR1_DLLSS	(((x)&3)<<3) /* DLL Source Select */
+
+#define BA0_FRR			0x0410	/* Feature Reporting Register */
+#define BA0_SLT12O		0x041c	/* Slot 12 GPIO Output Register for AC-Link */
+
+#define BA0_SERMC		0x0420	/* Serial Port Master Control */
+#define BA0_SERMC_FCRN		(1<<27)	/* Force Codec Ready Not */
+#define BA0_SERMC_ODSEN2	(1<<25)	/* On-Demand Support Enable ASDIN2 */
+#define BA0_SERMC_ODSEN1	(1<<24)	/* On-Demand Support Enable ASDIN1 */
+#define BA0_SERMC_SXLB		(1<<21)	/* ASDIN2 to ASDOUT Loopback */
+#define BA0_SERMC_SLB		(1<<20)	/* ASDOUT to ASDIN2 Loopback */
+#define BA0_SERMC_LOVF		(1<<19)	/* Loopback Output Valid Frame bit */
+#define BA0_SERMC_TCID(x)	(((x)&3)<<16) /* Target Secondary Codec ID */
+#define BA0_SERMC_PXLB		(5<<1)	/* Primary Port External Loopback */
+#define BA0_SERMC_PLB		(4<<1)	/* Primary Port Internal Loopback */
+#define BA0_SERMC_PTC		(7<<1)	/* Port Timing Configuration */
+#define BA0_SERMC_PTC_AC97	(1<<1)	/* AC97 mode */
+#define BA0_SERMC_MSPE		(1<<0)	/* Master Serial Port Enable */
+
+#define BA0_SERC1		0x0428	/* Serial Port Configuration 1 */
+#define BA0_SERC1_SO1F(x)	(((x)&7)>>1) /* Primary Output Port Format */
+#define BA0_SERC1_AC97		(1<<1)
+#define BA0_SERC1_SO1EN		(1<<0)	/* Primary Output Port Enable */
+
+#define BA0_SERC2		0x042c	/* Serial Port Configuration 2 */
+#define BA0_SERC2_SI1F(x)	(((x)&7)>>1) /* Primary Input Port Format */
+#define BA0_SERC2_AC97		(1<<1)
+#define BA0_SERC2_SI1EN		(1<<0)	/* Primary Input Port Enable */
+
+#define BA0_SLT12M		0x045c	/* Slot 12 Monitor Register for Primary AC-Link */
+
+#define BA0_ACCTL		0x0460	/* AC'97 Control */
+#define BA0_ACCTL_TC		(1<<6)	/* Target Codec */
+#define BA0_ACCTL_CRW		(1<<4)	/* 0=Write, 1=Read Command */
+#define BA0_ACCTL_DCV		(1<<3)	/* Dynamic Command Valid */
+#define BA0_ACCTL_VFRM		(1<<2)	/* Valid Frame */
+#define BA0_ACCTL_ESYN		(1<<1)	/* Enable Sync */
+
+#define BA0_ACSTS		0x0464	/* AC'97 Status */
+#define BA0_ACSTS_VSTS		(1<<1)	/* Valid Status */
+#define BA0_ACSTS_CRDY		(1<<0)	/* Codec Ready */
+
+#define BA0_ACOSV		0x0468	/* AC'97 Output Slot Valid */
+#define BA0_ACOSV_SLV(x)	(1<<((x)-3))
+
+#define BA0_ACCAD		0x046c	/* AC'97 Command Address */
+#define BA0_ACCDA		0x0470	/* AC'97 Command Data */
+
+#define BA0_ACISV		0x0474	/* AC'97 Input Slot Valid */
+#define BA0_ACISV_SLV(x)	(1<<((x)-3))
+
+#define BA0_ACSAD		0x0478	/* AC'97 Status Address */
+#define BA0_ACSDA		0x047c	/* AC'97 Status Data */
+#define BA0_JSPT		0x0480	/* Joystick poll/trigger */
+#define BA0_JSCTL		0x0484	/* Joystick control */
+#define BA0_JSC1		0x0488	/* Joystick control */
+#define BA0_JSC2		0x048c	/* Joystick control */
+#define BA0_JSIO		0x04a0
+
+#define BA0_MIDCR		0x0490	/* MIDI Control */
+#define BA0_MIDCR_MRST		(1<<5)	/* Reset MIDI Interface */
+#define BA0_MIDCR_MLB		(1<<4)	/* MIDI Loop Back Enable */
+#define BA0_MIDCR_TIE		(1<<3)	/* MIDI Transmuit Interrupt Enable */
+#define BA0_MIDCR_RIE		(1<<2)	/* MIDI Receive Interrupt Enable */
+#define BA0_MIDCR_RXE		(1<<1)	/* MIDI Receive Enable */
+#define BA0_MIDCR_TXE		(1<<0)	/* MIDI Transmit Enable */
+
+#define BA0_MIDCMD		0x0494	/* MIDI Command (wo) */
+
+#define BA0_MIDSR		0x0494	/* MIDI Status (ro) */
+#define BA0_MIDSR_RDA		(1<<15)	/* Sticky bit (RBE 1->0) */
+#define BA0_MIDSR_TBE		(1<<14) /* Sticky bit (TBF 0->1) */
+#define BA0_MIDSR_RBE		(1<<7)	/* Receive Buffer Empty */
+#define BA0_MIDSR_TBF		(1<<6)	/* Transmit Buffer Full */
+
+#define BA0_MIDWP		0x0498	/* MIDI Write */
+#define BA0_MIDRP		0x049c	/* MIDI Read (ro) */
+
+#define BA0_AODSD1		0x04a8	/* AC'97 On-Demand Slot Disable for primary link (ro) */
+#define BA0_AODSD1_NDS(x)	(1<<((x)-3))
+
+#define BA0_AODSD2		0x04ac	/* AC'97 On-Demand Slot Disable for secondary link (ro) */
+#define BA0_AODSD2_NDS(x)	(1<<((x)-3))
+
+#define BA0_CFGI		0x04b0	/* Configure Interface (EEPROM interface) */
+#define BA0_SLT12M2		0x04dc	/* Slot 12 Monitor Register 2 for secondary AC-link */
+#define BA0_ACSTS2		0x04e4	/* AC'97 Status Register 2 */
+#define BA0_ACISV2		0x04f4	/* AC'97 Input Slot Valid Register 2 */
+#define BA0_ACSAD2		0x04f8	/* AC'97 Status Address Register 2 */
+#define BA0_ACSDA2		0x04fc	/* AC'97 Status Data Register 2 */
+#define BA0_FMSR		0x0730	/* FM Synthesis Status (ro) */
+#define BA0_B0AP		0x0730	/* FM Bank 0 Address Port (wo) */
+#define BA0_FMDP		0x0734	/* FM Data Port */
+#define BA0_B1AP		0x0738	/* FM Bank 1 Address Port */
+#define BA0_B1DP		0x073c	/* FM Bank 1 Data Port */
+
+#define BA0_SSPM		0x0740	/* Sound System Power Management */
+#define BA0_SSPM_MIXEN		(1<<6)	/* Playback SRC + FM/Wavetable MIX */
+#define BA0_SSPM_CSRCEN		(1<<5)	/* Capture Sample Rate Converter Enable */
+#define BA0_SSPM_PSRCEN		(1<<4)	/* Playback Sample Rate Converter Enable */
+#define BA0_SSPM_JSEN		(1<<3)	/* Joystick Enable */
+#define BA0_SSPM_ACLEN		(1<<2)	/* Serial Port Engine and AC-Link Enable */
+#define BA0_SSPM_FMEN		(1<<1)	/* FM Synthesis Block Enable */
+
+#define BA0_DACSR		0x0744	/* DAC Sample Rate - Playback SRC */
+#define BA0_ADCSR		0x0748	/* ADC Sample Rate - Capture SRC */
+
+#define BA0_SSCR		0x074c	/* Sound System Control Register */
+#define BA0_SSCR_HVS1		(1<<23)	/* Hardwave Volume Step (0=1,1=2) */
+#define BA0_SSCR_MVCS		(1<<19)	/* Master Volume Codec Select */
+#define BA0_SSCR_MVLD		(1<<18)	/* Master Volume Line Out Disable */
+#define BA0_SSCR_MVAD		(1<<17)	/* Master Volume Alternate Out Disable */
+#define BA0_SSCR_MVMD		(1<<16)	/* Master Volume Mono Out Disable */
+#define BA0_SSCR_XLPSRC		(1<<8)	/* External SRC Loopback Mode */
+#define BA0_SSCR_LPSRC		(1<<7)	/* SRC Loopback Mode */
+#define BA0_SSCR_CDTX		(1<<5)	/* CD Transfer Data */
+#define BA0_SSCR_HVC		(1<<3)	/* Harware Volume Control Enable */
+
+#define BA0_FMLVC		0x0754	/* FM Synthesis Left Volume Control */
+#define BA0_FMRVC		0x0758	/* FM Synthesis Right Volume Control */
+#define BA0_SRCSA		0x075c	/* SRC Slot Assignments */
+#define BA0_PPLVC		0x0760	/* PCM Playback Left Volume Control */
+#define BA0_PPRVC		0x0764	/* PCM Playback Right Volume Control */
+#define BA0_PASR		0x0768	/* playback sample rate */
+#define BA0_CASR		0x076C	/* capture sample rate */
+
+/* Source Slot Numbers - Playback */
+#define SRCSLOT_LEFT_PCM_PLAYBACK		0
+#define SRCSLOT_RIGHT_PCM_PLAYBACK		1
+#define SRCSLOT_PHONE_LINE_1_DAC		2
+#define SRCSLOT_CENTER_PCM_PLAYBACK		3
+#define SRCSLOT_LEFT_SURROUND_PCM_PLAYBACK	4
+#define SRCSLOT_RIGHT_SURROUND_PCM_PLAYBACK	5
+#define SRCSLOT_LFE_PCM_PLAYBACK		6
+#define SRCSLOT_PHONE_LINE_2_DAC		7
+#define SRCSLOT_HEADSET_DAC			8
+#define SRCSLOT_LEFT_WT				29  /* invalid for BA0_SRCSA */
+#define SRCSLOT_RIGHT_WT			30  /* invalid for BA0_SRCSA */
+
+/* Source Slot Numbers - Capture */
+#define SRCSLOT_LEFT_PCM_RECORD			10
+#define SRCSLOT_RIGHT_PCM_RECORD		11
+#define SRCSLOT_PHONE_LINE_1_ADC		12
+#define SRCSLOT_MIC_ADC				13
+#define SRCSLOT_PHONE_LINE_2_ADC		17
+#define SRCSLOT_HEADSET_ADC			18
+#define SRCSLOT_SECONDARY_LEFT_PCM_RECORD	20
+#define SRCSLOT_SECONDARY_RIGHT_PCM_RECORD	21
+#define SRCSLOT_SECONDARY_PHONE_LINE_1_ADC	22
+#define SRCSLOT_SECONDARY_MIC_ADC		23
+#define SRCSLOT_SECONDARY_PHONE_LINE_2_ADC	27
+#define SRCSLOT_SECONDARY_HEADSET_ADC		28
+
+/* Source Slot Numbers - Others */
+#define SRCSLOT_POWER_DOWN			31
+
+/* MIDI modes */
+#define CS4281_MODE_OUTPUT		(1<<0)
+#define CS4281_MODE_INPUT		(1<<1)
+
+/* joystick bits */
+/* Bits for JSPT */
+#define JSPT_CAX                                0x00000001
+#define JSPT_CAY                                0x00000002
+#define JSPT_CBX                                0x00000004
+#define JSPT_CBY                                0x00000008
+#define JSPT_BA1                                0x00000010
+#define JSPT_BA2                                0x00000020
+#define JSPT_BB1                                0x00000040
+#define JSPT_BB2                                0x00000080
+
+/* Bits for JSCTL */
+#define JSCTL_SP_MASK                           0x00000003
+#define JSCTL_SP_SLOW                           0x00000000
+#define JSCTL_SP_MEDIUM_SLOW                    0x00000001
+#define JSCTL_SP_MEDIUM_FAST                    0x00000002
+#define JSCTL_SP_FAST                           0x00000003
+#define JSCTL_ARE                               0x00000004
+
+/* Data register pairs masks */
+#define JSC1_Y1V_MASK                           0x0000FFFF
+#define JSC1_X1V_MASK                           0xFFFF0000
+#define JSC1_Y1V_SHIFT                          0
+#define JSC1_X1V_SHIFT                          16
+#define JSC2_Y2V_MASK                           0x0000FFFF
+#define JSC2_X2V_MASK                           0xFFFF0000
+#define JSC2_Y2V_SHIFT                          0
+#define JSC2_X2V_SHIFT                          16
+
+/* JS GPIO */
+#define JSIO_DAX                                0x00000001
+#define JSIO_DAY                                0x00000002
+#define JSIO_DBX                                0x00000004
+#define JSIO_DBY                                0x00000008
+#define JSIO_AXOE                               0x00000010
+#define JSIO_AYOE                               0x00000020
+#define JSIO_BXOE                               0x00000040
+#define JSIO_BYOE                               0x00000080
+
+/*
+ *
+ */
+
+typedef struct snd_cs4281 cs4281_t;
+typedef struct snd_cs4281_dma cs4281_dma_t;
+
+struct snd_cs4281_dma {
+	snd_pcm_substream_t *substream;
+	unsigned int regDBA;		/* offset to DBA register */
+	unsigned int regDCA;		/* offset to DCA register */
+	unsigned int regDBC;		/* offset to DBC register */
+	unsigned int regDCC;		/* offset to DCC register */
+	unsigned int regDMR;		/* offset to DMR register */
+	unsigned int regDCR;		/* offset to DCR register */
+	unsigned int regHDSR;		/* offset to HDSR register */
+	unsigned int regFCR;		/* offset to FCR register */
+	unsigned int regFSIC;		/* offset to FSIC register */
+	unsigned int valDMR;		/* DMA mode */
+	unsigned int valDCR;		/* DMA command */
+	unsigned int valFCR;		/* FIFO control */
+	unsigned int fifo_offset;	/* FIFO offset within BA1 */
+	unsigned char left_slot;	/* FIFO left slot */
+	unsigned char right_slot;	/* FIFO right slot */
+	int frag;			/* period number */
+};
+
+#define SUSPEND_REGISTERS	20
+
+struct snd_cs4281 {
+	int irq;
+
+	void __iomem *ba0;		/* virtual (accessible) address */
+	void __iomem *ba1;		/* virtual (accessible) address */
+	unsigned long ba0_addr;
+	unsigned long ba1_addr;
+
+	int dual_codec;
+
+	ac97_bus_t *ac97_bus;
+	ac97_t *ac97;
+	ac97_t *ac97_secondary;
+
+	struct pci_dev *pci;
+	snd_card_t *card;
+	snd_pcm_t *pcm;
+	snd_rawmidi_t *rmidi;
+	snd_rawmidi_substream_t *midi_input;
+	snd_rawmidi_substream_t *midi_output;
+
+	cs4281_dma_t dma[4];
+
+	unsigned char src_left_play_slot;
+	unsigned char src_right_play_slot;
+	unsigned char src_left_rec_slot;
+	unsigned char src_right_rec_slot;
+
+	unsigned int spurious_dhtc_irq;
+	unsigned int spurious_dtc_irq;
+
+	spinlock_t reg_lock;
+	unsigned int midcr;
+	unsigned int uartm;
+
+	struct gameport *gameport;
+
+#ifdef CONFIG_PM
+	u32 suspend_regs[SUSPEND_REGISTERS];
+#endif
+
+};
+
+static irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+
+static struct pci_device_id snd_cs4281_ids[] = {
+	{ 0x1013, 0x6005, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },	/* CS4281 */
+	{ 0, }
+};
+
+MODULE_DEVICE_TABLE(pci, snd_cs4281_ids);
+
+/*
+ *  constants
+ */
+
+#define CS4281_FIFO_SIZE	32
+
+/*
+ *  common I/O routines
+ */
+
+static void snd_cs4281_delay(unsigned int delay)
+{
+	if (delay > 999) {
+		unsigned long end_time;
+		delay = (delay * HZ) / 1000000;
+		if (delay < 1)
+			delay = 1;
+		end_time = jiffies + delay;
+		do {
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(1);
+		} while (time_after_eq(end_time, jiffies));
+	} else {
+		udelay(delay);
+	}
+}
+
+inline static void snd_cs4281_delay_long(void)
+{
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(1);
+}
+
+static inline void snd_cs4281_pokeBA0(cs4281_t *chip, unsigned long offset, unsigned int val)
+{
+        writel(val, chip->ba0 + offset);
+}
+
+static inline unsigned int snd_cs4281_peekBA0(cs4281_t *chip, unsigned long offset)
+{
+        return readl(chip->ba0 + offset);
+}
+
+static void snd_cs4281_ac97_write(ac97_t *ac97,
+				  unsigned short reg, unsigned short val)
+{
+	/*
+	 *  1. Write ACCAD = Command Address Register = 46Ch for AC97 register address
+	 *  2. Write ACCDA = Command Data Register = 470h    for data to write to AC97
+	 *  3. Write ACCTL = Control Register = 460h for initiating the write
+	 *  4. Read ACCTL = 460h, DCV should be reset by now and 460h = 07h
+	 *  5. if DCV not cleared, break and return error
+	 */
+	cs4281_t *chip = ac97->private_data;
+	int count;
+
+	/*
+	 *  Setup the AC97 control registers on the CS461x to send the
+	 *  appropriate command to the AC97 to perform the read.
+	 *  ACCAD = Command Address Register = 46Ch
+	 *  ACCDA = Command Data Register = 470h
+	 *  ACCTL = Control Register = 460h
+	 *  set DCV - will clear when process completed
+	 *  reset CRW - Write command
+	 *  set VFRM - valid frame enabled
+	 *  set ESYN - ASYNC generation enabled
+	 *  set RSTN - ARST# inactive, AC97 codec not reset
+         */
+	snd_cs4281_pokeBA0(chip, BA0_ACCAD, reg);
+	snd_cs4281_pokeBA0(chip, BA0_ACCDA, val);
+	snd_cs4281_pokeBA0(chip, BA0_ACCTL, BA0_ACCTL_DCV | BA0_ACCTL_VFRM |
+				            BA0_ACCTL_ESYN | (ac97->num ? BA0_ACCTL_TC : 0));
+	for (count = 0; count < 2000; count++) {
+		/*
+		 *  First, we want to wait for a short time.
+		 */
+		udelay(10);
+		/*
+		 *  Now, check to see if the write has completed.
+		 *  ACCTL = 460h, DCV should be reset by now and 460h = 07h
+		 */
+		if (!(snd_cs4281_peekBA0(chip, BA0_ACCTL) & BA0_ACCTL_DCV)) {
+			return;
+		}
+	}
+	snd_printk(KERN_ERR "AC'97 write problem, reg = 0x%x, val = 0x%x\n", reg, val);
+}
+
+static unsigned short snd_cs4281_ac97_read(ac97_t *ac97,
+					   unsigned short reg)
+{
+	cs4281_t *chip = ac97->private_data;
+	int count;
+	unsigned short result;
+	// FIXME: volatile is necessary in the following due to a bug of
+	// some gcc versions
+	volatile int ac97_num = ((volatile ac97_t *)ac97)->num;
+
+	/*
+	 *  1. Write ACCAD = Command Address Register = 46Ch for AC97 register address
+	 *  2. Write ACCDA = Command Data Register = 470h    for data to write to AC97 
+	 *  3. Write ACCTL = Control Register = 460h for initiating the write
+	 *  4. Read ACCTL = 460h, DCV should be reset by now and 460h = 17h
+	 *  5. if DCV not cleared, break and return error
+	 *  6. Read ACSTS = Status Register = 464h, check VSTS bit
+	 */
+
+	snd_cs4281_peekBA0(chip, ac97_num ? BA0_ACSDA2 : BA0_ACSDA);
+
+	/*
+	 *  Setup the AC97 control registers on the CS461x to send the
+	 *  appropriate command to the AC97 to perform the read.
+	 *  ACCAD = Command Address Register = 46Ch
+	 *  ACCDA = Command Data Register = 470h
+	 *  ACCTL = Control Register = 460h
+	 *  set DCV - will clear when process completed
+	 *  set CRW - Read command
+	 *  set VFRM - valid frame enabled
+	 *  set ESYN - ASYNC generation enabled
+	 *  set RSTN - ARST# inactive, AC97 codec not reset
+	 */
+
+	snd_cs4281_pokeBA0(chip, BA0_ACCAD, reg);
+	snd_cs4281_pokeBA0(chip, BA0_ACCDA, 0);
+	snd_cs4281_pokeBA0(chip, BA0_ACCTL, BA0_ACCTL_DCV | BA0_ACCTL_CRW |
+					    BA0_ACCTL_VFRM | BA0_ACCTL_ESYN |
+			   (ac97_num ? BA0_ACCTL_TC : 0));
+
+
+	/*
+	 *  Wait for the read to occur.
+	 */
+	for (count = 0; count < 500; count++) {
+		/*
+		 *  First, we want to wait for a short time.
+	 	 */
+		udelay(10);
+		/*
+		 *  Now, check to see if the read has completed.
+		 *  ACCTL = 460h, DCV should be reset by now and 460h = 17h
+		 */
+		if (!(snd_cs4281_peekBA0(chip, BA0_ACCTL) & BA0_ACCTL_DCV))
+			goto __ok1;
+	}
+
+	snd_printk(KERN_ERR "AC'97 read problem (ACCTL_DCV), reg = 0x%x\n", reg);
+	result = 0xffff;
+	goto __end;
+	
+      __ok1:
+	/*
+	 *  Wait for the valid status bit to go active.
+	 */
+	for (count = 0; count < 100; count++) {
+		/*
+		 *  Read the AC97 status register.
+		 *  ACSTS = Status Register = 464h
+		 *  VSTS - Valid Status
+		 */
+		if (snd_cs4281_peekBA0(chip, ac97_num ? BA0_ACSTS2 : BA0_ACSTS) & BA0_ACSTS_VSTS)
+			goto __ok2;
+		udelay(10);
+	}
+	
+	snd_printk(KERN_ERR "AC'97 read problem (ACSTS_VSTS), reg = 0x%x\n", reg);
+	result = 0xffff;
+	goto __end;
+
+      __ok2:
+	/*
+	 *  Read the data returned from the AC97 register.
+	 *  ACSDA = Status Data Register = 474h
+	 */
+	result = snd_cs4281_peekBA0(chip, ac97_num ? BA0_ACSDA2 : BA0_ACSDA);
+
+      __end:
+	return result;
+}
+
+/*
+ *  PCM part
+ */
+
+static int snd_cs4281_trigger(snd_pcm_substream_t *substream, int cmd)
+{
+	cs4281_dma_t *dma = (cs4281_dma_t *)substream->runtime->private_data;
+	cs4281_t *chip = snd_pcm_substream_chip(substream);
+
+	spin_lock(&chip->reg_lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dma->valDCR |= BA0_DCR_MSK;
+		dma->valFCR |= BA0_FCR_FEN;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		dma->valDCR &= ~BA0_DCR_MSK;
+		dma->valFCR &= ~BA0_FCR_FEN;
+		break;
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		snd_cs4281_pokeBA0(chip, dma->regDMR, dma->valDMR & ~BA0_DMR_DMA);
+		dma->valDMR |= BA0_DMR_DMA;
+		dma->valDCR &= ~BA0_DCR_MSK;
+		dma->valFCR |= BA0_FCR_FEN;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		dma->valDMR &= ~(BA0_DMR_DMA|BA0_DMR_POLL);
+		dma->valDCR |= BA0_DCR_MSK;
+		dma->valFCR &= ~BA0_FCR_FEN;
+		/* Leave wave playback FIFO enabled for FM */
+		if (dma->regFCR != BA0_FCR0)
+			dma->valFCR &= ~BA0_FCR_FEN;
+		break;
+	default:
+		spin_unlock(&chip->reg_lock);
+		return -EINVAL;
+	}
+	snd_cs4281_pokeBA0(chip, dma->regDMR, dma->valDMR);
+	snd_cs4281_pokeBA0(chip, dma->regFCR, dma->valFCR);
+	snd_cs4281_pokeBA0(chip, dma->regDCR, dma->valDCR);
+	spin_unlock(&chip->reg_lock);
+	return 0;
+}
+
+static unsigned int snd_cs4281_rate(unsigned int rate, unsigned int *real_rate)
+{
+	unsigned int val = ~0;
+	
+	if (real_rate)
+		*real_rate = rate;
+	/* special "hardcoded" rates */
+	switch (rate) {
+	case 8000:	return 5;
+	case 11025:	return 4;
+	case 16000:	return 3;
+	case 22050:	return 2;
+	case 44100:	return 1;
+	case 48000:	return 0;
+	default:
+		goto __variable;
+	}
+      __variable:
+	val = 1536000 / rate;
+	if (real_rate)
+		*real_rate = 1536000 / val;
+	return val;
+}
+
+static void snd_cs4281_mode(cs4281_t *chip, cs4281_dma_t *dma, snd_pcm_runtime_t *runtime, int capture, int src)
+{
+	int rec_mono;
+
+	dma->valDMR = BA0_DMR_TYPE_SINGLE | BA0_DMR_AUTO |
+		      (capture ? BA0_DMR_TR_WRITE : BA0_DMR_TR_READ);
+	if (runtime->channels == 1)
+		dma->valDMR |= BA0_DMR_MONO;
+	if (snd_pcm_format_unsigned(runtime->format) > 0)
+		dma->valDMR |= BA0_DMR_USIGN;
+	if (snd_pcm_format_big_endian(runtime->format) > 0)
+		dma->valDMR |= BA0_DMR_BEND;
+	switch (snd_pcm_format_width(runtime->format)) {
+	case 8: dma->valDMR |= BA0_DMR_SIZE8;
+		if (runtime->channels == 1)
+			dma->valDMR |= BA0_DMR_SWAPC;
+		break;
+	case 32: dma->valDMR |= BA0_DMR_SIZE20; break;
+	}
+	dma->frag = 0;	/* for workaround */
+	dma->valDCR = BA0_DCR_TCIE | BA0_DCR_MSK;
+	if (runtime->buffer_size != runtime->period_size)
+		dma->valDCR |= BA0_DCR_HTCIE;
+	/* Initialize DMA */
+	snd_cs4281_pokeBA0(chip, dma->regDBA, runtime->dma_addr);
+	snd_cs4281_pokeBA0(chip, dma->regDBC, runtime->buffer_size - 1);
+	rec_mono = (chip->dma[1].valDMR & BA0_DMR_MONO) == BA0_DMR_MONO;
+	snd_cs4281_pokeBA0(chip, BA0_SRCSA, (chip->src_left_play_slot << 0) |
+					    (chip->src_right_play_slot << 8) |
+					    (chip->src_left_rec_slot << 16) |
+					    ((rec_mono ? 31 : chip->src_right_rec_slot) << 24));
+	if (!src)
+		goto __skip_src;
+	if (!capture) {
+		if (dma->left_slot == chip->src_left_play_slot) {
+			unsigned int val = snd_cs4281_rate(runtime->rate, NULL);
+			snd_assert(dma->right_slot == chip->src_right_play_slot, );
+			snd_cs4281_pokeBA0(chip, BA0_DACSR, val);
+		}
+	} else {
+		if (dma->left_slot == chip->src_left_rec_slot) {
+			unsigned int val = snd_cs4281_rate(runtime->rate, NULL);
+			snd_assert(dma->right_slot == chip->src_right_rec_slot, );
+			snd_cs4281_pokeBA0(chip, BA0_ADCSR, val);
+		}
+	}
+      __skip_src:
+	/* Deactivate wave playback FIFO before changing slot assignments */
+	if (dma->regFCR == BA0_FCR0)
+		snd_cs4281_pokeBA0(chip, dma->regFCR, snd_cs4281_peekBA0(chip, dma->regFCR) & ~BA0_FCR_FEN);
+	/* Initialize FIFO */
+	dma->valFCR = BA0_FCR_LS(dma->left_slot) |
+		      BA0_FCR_RS(capture && (dma->valDMR & BA0_DMR_MONO) ? 31 : dma->right_slot) |
+		      BA0_FCR_SZ(CS4281_FIFO_SIZE) |
+		      BA0_FCR_OF(dma->fifo_offset);
+	snd_cs4281_pokeBA0(chip, dma->regFCR, dma->valFCR | (capture ? BA0_FCR_PSH : 0));
+	/* Activate FIFO again for FM playback */
+	if (dma->regFCR == BA0_FCR0)
+		snd_cs4281_pokeBA0(chip, dma->regFCR, dma->valFCR | BA0_FCR_FEN);
+	/* Clear FIFO Status and Interrupt Control Register */
+	snd_cs4281_pokeBA0(chip, dma->regFSIC, 0);
+}
+
+static int snd_cs4281_hw_params(snd_pcm_substream_t * substream,
+				snd_pcm_hw_params_t * hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+}
+
+static int snd_cs4281_hw_free(snd_pcm_substream_t * substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int snd_cs4281_playback_prepare(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	cs4281_dma_t *dma = (cs4281_dma_t *)runtime->private_data;
+	cs4281_t *chip = snd_pcm_substream_chip(substream);
+
+	spin_lock_irq(&chip->reg_lock);
+	snd_cs4281_mode(chip, dma, runtime, 0, 1);
+	spin_unlock_irq(&chip->reg_lock);
+	return 0;
+}
+
+static int snd_cs4281_capture_prepare(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	cs4281_dma_t *dma = (cs4281_dma_t *)runtime->private_data;
+	cs4281_t *chip = snd_pcm_substream_chip(substream);
+
+	spin_lock_irq(&chip->reg_lock);
+	snd_cs4281_mode(chip, dma, runtime, 1, 1);
+	spin_unlock_irq(&chip->reg_lock);
+	return 0;
+}
+
+static snd_pcm_uframes_t snd_cs4281_pointer(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	cs4281_dma_t *dma = (cs4281_dma_t *)runtime->private_data;
+	cs4281_t *chip = snd_pcm_substream_chip(substream);
+
+	// printk("DCC = 0x%x, buffer_size = 0x%x, jiffies = %li\n", snd_cs4281_peekBA0(chip, dma->regDCC), runtime->buffer_size, jiffies);
+	return runtime->buffer_size -
+	       snd_cs4281_peekBA0(chip, dma->regDCC) - 1;
+}
+
+static snd_pcm_hardware_t snd_cs4281_playback =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP |
+				 SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_PAUSE |
+				 SNDRV_PCM_INFO_RESUME |
+				 SNDRV_PCM_INFO_SYNC_START),
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 |
+				SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_S16_LE |
+				SNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |
+				SNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_S32_LE |
+				SNDRV_PCM_FMTBIT_U32_BE | SNDRV_PCM_FMTBIT_S32_BE,
+	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(512*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(512*1024),
+	.periods_min =		1,
+	.periods_max =		2,
+	.fifo_size =		CS4281_FIFO_SIZE,
+};
+
+static snd_pcm_hardware_t snd_cs4281_capture =
+{
+	.info =			(SNDRV_PCM_INFO_MMAP |
+				 SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_MMAP_VALID |
+				 SNDRV_PCM_INFO_PAUSE |
+				 SNDRV_PCM_INFO_RESUME |
+				 SNDRV_PCM_INFO_SYNC_START),
+	.formats =		SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8 |
+				SNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_S16_LE |
+				SNDRV_PCM_FMTBIT_U16_BE | SNDRV_PCM_FMTBIT_S16_BE |
+				SNDRV_PCM_FMTBIT_U32_LE | SNDRV_PCM_FMTBIT_S32_LE |
+				SNDRV_PCM_FMTBIT_U32_BE | SNDRV_PCM_FMTBIT_S32_BE,
+	.rates =		SNDRV_PCM_RATE_CONTINUOUS | SNDRV_PCM_RATE_8000_48000,
+	.rate_min =		4000,
+	.rate_max =		48000,
+	.channels_min =		1,
+	.channels_max =		2,
+	.buffer_bytes_max =	(512*1024),
+	.period_bytes_min =	64,
+	.period_bytes_max =	(512*1024),
+	.periods_min =		1,
+	.periods_max =		2,
+	.fifo_size =		CS4281_FIFO_SIZE,
+};
+
+static int snd_cs4281_playback_open(snd_pcm_substream_t * substream)
+{
+	cs4281_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	cs4281_dma_t *dma;
+
+	dma = &chip->dma[0];
+	dma->substream = substream;
+	dma->left_slot = 0;
+	dma->right_slot = 1;
+	runtime->private_data = dma;
+	runtime->hw = snd_cs4281_playback;
+	snd_pcm_set_sync(substream);
+	/* should be detected from the AC'97 layer, but it seems
+	   that although CS4297A rev B reports 18-bit ADC resolution,
+	   samples are 20-bit */
+	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 20);
+	return 0;
+}
+
+static int snd_cs4281_capture_open(snd_pcm_substream_t * substream)
+{
+	cs4281_t *chip = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	cs4281_dma_t *dma;
+
+	dma = &chip->dma[1];
+	dma->substream = substream;
+	dma->left_slot = 10;
+	dma->right_slot = 11;
+	runtime->private_data = dma;
+	runtime->hw = snd_cs4281_capture;
+	snd_pcm_set_sync(substream);
+	/* should be detected from the AC'97 layer, but it seems
+	   that although CS4297A rev B reports 18-bit ADC resolution,
+	   samples are 20-bit */
+	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 20);
+	return 0;
+}
+
+static int snd_cs4281_playback_close(snd_pcm_substream_t * substream)
+{
+	cs4281_dma_t *dma = (cs4281_dma_t *)substream->runtime->private_data;
+
+	dma->substream = NULL;
+	return 0;
+}
+
+static int snd_cs4281_capture_close(snd_pcm_substream_t * substream)
+{
+	cs4281_dma_t *dma = (cs4281_dma_t *)substream->runtime->private_data;
+
+	dma->substream = NULL;
+	return 0;
+}
+
+static snd_pcm_ops_t snd_cs4281_playback_ops = {
+	.open =		snd_cs4281_playback_open,
+	.close =	snd_cs4281_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_cs4281_hw_params,
+	.hw_free =	snd_cs4281_hw_free,
+	.prepare =	snd_cs4281_playback_prepare,
+	.trigger =	snd_cs4281_trigger,
+	.pointer =	snd_cs4281_pointer,
+};
+
+static snd_pcm_ops_t snd_cs4281_capture_ops = {
+	.open =		snd_cs4281_capture_open,
+	.close =	snd_cs4281_capture_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	snd_cs4281_hw_params,
+	.hw_free =	snd_cs4281_hw_free,
+	.prepare =	snd_cs4281_capture_prepare,
+	.trigger =	snd_cs4281_trigger,
+	.pointer =	snd_cs4281_pointer,
+};
+
+static void snd_cs4281_pcm_free(snd_pcm_t *pcm)
+{
+	cs4281_t *chip = pcm->private_data;
+	chip->pcm = NULL;
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static int __devinit snd_cs4281_pcm(cs4281_t * chip, int device, snd_pcm_t ** rpcm)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	if (rpcm)
+		*rpcm = NULL;
+	err = snd_pcm_new(chip->card, "CS4281", device, 1, 1, &pcm);
+	if (err < 0)
+		return err;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cs4281_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cs4281_capture_ops);
+
+	pcm->private_data = chip;
+	pcm->private_free = snd_cs4281_pcm_free;
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "CS4281");
+	chip->pcm = pcm;
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      snd_dma_pci_data(chip->pci), 64*1024, 512*1024);
+
+	if (rpcm)
+		*rpcm = pcm;
+	return 0;
+}
+
+/*
+ *  Mixer section
+ */
+
+#define CS_VOL_MASK	0x1f
+
+static int snd_cs4281_info_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type              = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count             = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = CS_VOL_MASK;
+	return 0;
+}
+ 
+static int snd_cs4281_get_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	cs4281_t *chip = snd_kcontrol_chip(kcontrol);
+	int regL = (kcontrol->private_value >> 16) & 0xffff;
+	int regR = kcontrol->private_value & 0xffff;
+	int volL, volR;
+
+	volL = CS_VOL_MASK - (snd_cs4281_peekBA0(chip, regL) & CS_VOL_MASK);
+	volR = CS_VOL_MASK - (snd_cs4281_peekBA0(chip, regR) & CS_VOL_MASK);
+
+	ucontrol->value.integer.value[0] = volL;
+	ucontrol->value.integer.value[1] = volR;
+	return 0;
+}
+
+static int snd_cs4281_put_volume(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	cs4281_t *chip = snd_kcontrol_chip(kcontrol);
+	int change = 0;
+	int regL = (kcontrol->private_value >> 16) & 0xffff;
+	int regR = kcontrol->private_value & 0xffff;
+	int volL, volR;
+
+	volL = CS_VOL_MASK - (snd_cs4281_peekBA0(chip, regL) & CS_VOL_MASK);
+	volR = CS_VOL_MASK - (snd_cs4281_peekBA0(chip, regR) & CS_VOL_MASK);
+
+	if (ucontrol->value.integer.value[0] != volL) {
+		volL = CS_VOL_MASK - (ucontrol->value.integer.value[0] & CS_VOL_MASK);
+		snd_cs4281_pokeBA0(chip, regL, volL);
+		change = 1;
+	}
+	if (ucontrol->value.integer.value[0] != volL) {
+		volR = CS_VOL_MASK - (ucontrol->value.integer.value[1] & CS_VOL_MASK);
+		snd_cs4281_pokeBA0(chip, regR, volR);
+		change = 1;
+	}
+	return change;
+}
+
+static snd_kcontrol_new_t snd_cs4281_fm_vol = 
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "Synth Playback Volume",
+	.info = snd_cs4281_info_volume, 
+	.get = snd_cs4281_get_volume,
+	.put = snd_cs4281_put_volume, 
+	.private_value = ((BA0_FMLVC << 16) | BA0_FMRVC),
+};
+
+static snd_kcontrol_new_t snd_cs4281_pcm_vol = 
+{
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "PCM Stream Playback Volume",
+	.info = snd_cs4281_info_volume, 
+	.get = snd_cs4281_get_volume,
+	.put = snd_cs4281_put_volume, 
+	.private_value = ((BA0_PPLVC << 16) | BA0_PPRVC),
+};
+
+static void snd_cs4281_mixer_free_ac97_bus(ac97_bus_t *bus)
+{
+	cs4281_t *chip = bus->private_data;
+	chip->ac97_bus = NULL;
+}
+
+static void snd_cs4281_mixer_free_ac97(ac97_t *ac97)
+{
+	cs4281_t *chip = ac97->private_data;
+	if (ac97->num)
+		chip->ac97_secondary = NULL;
+	else
+		chip->ac97 = NULL;
+}
+
+static int __devinit snd_cs4281_mixer(cs4281_t * chip)
+{
+	snd_card_t *card = chip->card;
+	ac97_template_t ac97;
+	int err;
+	static ac97_bus_ops_t ops = {
+		.write = snd_cs4281_ac97_write,
+		.read = snd_cs4281_ac97_read,
+	};
+
+	if ((err = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus)) < 0)
+		return err;
+	chip->ac97_bus->private_free = snd_cs4281_mixer_free_ac97_bus;
+
+	memset(&ac97, 0, sizeof(ac97));
+	ac97.private_data = chip;
+	ac97.private_free = snd_cs4281_mixer_free_ac97;
+	if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)
+		return err;
+	if (chip->dual_codec) {
+		ac97.num = 1;
+		if ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97_secondary)) < 0)
+			return err;
+	}
+	if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_cs4281_fm_vol, chip))) < 0)
+		return err;
+	if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_cs4281_pcm_vol, chip))) < 0)
+		return err;
+	return 0;
+}
+
+
+/*
+ * proc interface
+ */
+
+static void snd_cs4281_proc_read(snd_info_entry_t *entry, 
+				  snd_info_buffer_t * buffer)
+{
+	cs4281_t *chip = entry->private_data;
+
+	snd_iprintf(buffer, "Cirrus Logic CS4281\n\n");
+	snd_iprintf(buffer, "Spurious half IRQs   : %u\n", chip->spurious_dhtc_irq);
+	snd_iprintf(buffer, "Spurious end IRQs    : %u\n", chip->spurious_dtc_irq);
+}
+
+static long snd_cs4281_BA0_read(snd_info_entry_t *entry, void *file_private_data,
+				struct file *file, char __user *buf,
+				unsigned long count, unsigned long pos)
+{
+	long size;
+	cs4281_t *chip = entry->private_data;
+	
+	size = count;
+	if (pos + size > CS4281_BA0_SIZE)
+		size = (long)CS4281_BA0_SIZE - pos;
+	if (size > 0) {
+		if (copy_to_user_fromio(buf, chip->ba0 + pos, size))
+			return -EFAULT;
+	}
+	return size;
+}
+
+static long snd_cs4281_BA1_read(snd_info_entry_t *entry, void *file_private_data,
+				struct file *file, char __user *buf,
+				unsigned long count, unsigned long pos)
+{
+	long size;
+	cs4281_t *chip = entry->private_data;
+	
+	size = count;
+	if (pos + size > CS4281_BA1_SIZE)
+		size = (long)CS4281_BA1_SIZE - pos;
+	if (size > 0) {
+		if (copy_to_user_fromio(buf, chip->ba1 + pos, size))
+			return -EFAULT;
+	}
+	return size;
+}
+
+static struct snd_info_entry_ops snd_cs4281_proc_ops_BA0 = {
+	.read = snd_cs4281_BA0_read,
+};
+
+static struct snd_info_entry_ops snd_cs4281_proc_ops_BA1 = {
+	.read = snd_cs4281_BA1_read,
+};
+
+static void __devinit snd_cs4281_proc_init(cs4281_t * chip)
+{
+	snd_info_entry_t *entry;
+
+	if (! snd_card_proc_new(chip->card, "cs4281", &entry))
+		snd_info_set_text_ops(entry, chip, 1024, snd_cs4281_proc_read);
+	if (! snd_card_proc_new(chip->card, "cs4281_BA0", &entry)) {
+		entry->content = SNDRV_INFO_CONTENT_DATA;
+		entry->private_data = chip;
+		entry->c.ops = &snd_cs4281_proc_ops_BA0;
+		entry->size = CS4281_BA0_SIZE;
+	}
+	if (! snd_card_proc_new(chip->card, "cs4281_BA1", &entry)) {
+		entry->content = SNDRV_INFO_CONTENT_DATA;
+		entry->private_data = chip;
+		entry->c.ops = &snd_cs4281_proc_ops_BA1;
+		entry->size = CS4281_BA1_SIZE;
+	}
+}
+
+/*
+ * joystick support
+ */
+
+#if defined(CONFIG_GAMEPORT) || (defined(MODULE) && defined(CONFIG_GAMEPORT_MODULE))
+
+static void snd_cs4281_gameport_trigger(struct gameport *gameport)
+{
+	cs4281_t *chip = gameport_get_port_data(gameport);
+
+	snd_assert(chip, return);
+	snd_cs4281_pokeBA0(chip, BA0_JSPT, 0xff);
+}
+
+static unsigned char snd_cs4281_gameport_read(struct gameport *gameport)
+{
+	cs4281_t *chip = gameport_get_port_data(gameport);
+
+	snd_assert(chip, return 0);
+	return snd_cs4281_peekBA0(chip, BA0_JSPT);
+}
+
+#ifdef COOKED_MODE
+static int snd_cs4281_gameport_cooked_read(struct gameport *gameport, int *axes, int *buttons)
+{
+	cs4281_t *chip = gameport_get_port_data(gameport);
+	unsigned js1, js2, jst;
+	
+	snd_assert(chip, return 0);
+
+	js1 = snd_cs4281_peekBA0(chip, BA0_JSC1);
+	js2 = snd_cs4281_peekBA0(chip, BA0_JSC2);
+	jst = snd_cs4281_peekBA0(chip, BA0_JSPT);
+	
+	*buttons = (~jst >> 4) & 0x0F; 
+	
+	axes[0] = ((js1 & JSC1_Y1V_MASK) >> JSC1_Y1V_SHIFT) & 0xFFFF;
+	axes[1] = ((js1 & JSC1_X1V_MASK) >> JSC1_X1V_SHIFT) & 0xFFFF;
+	axes[2] = ((js2 & JSC2_Y2V_MASK) >> JSC2_Y2V_SHIFT) & 0xFFFF;
+	axes[3] = ((js2 & JSC2_X2V_MASK) >> JSC2_X2V_SHIFT) & 0xFFFF;
+
+	for (jst = 0; jst < 4; ++jst)
+		if (axes[jst] == 0xFFFF) axes[jst] = -1;
+	return 0;
+}
+#else
+#define snd_cs4281_gameport_cooked_read	NULL
+#endif
+
+static int snd_cs4281_gameport_open(struct gameport *gameport, int mode)
+{
+	switch (mode) {
+#ifdef COOKED_MODE
+	case GAMEPORT_MODE_COOKED:
+		return 0;
+#endif
+	case GAMEPORT_MODE_RAW:
+		return 0;
+	default:
+		return -1;
+	}
+	return 0;
+}
+
+static int __devinit snd_cs4281_create_gameport(cs4281_t *chip)
+{
+	struct gameport *gp;
+
+	chip->gameport = gp = gameport_allocate_port();
+	if (!gp) {
+		printk(KERN_ERR "cs4281: cannot allocate memory for gameport\n");
+		return -ENOMEM;
+	}
+
+	gameport_set_name(gp, "CS4281 Gameport");
+	gameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));
+	gameport_set_dev_parent(gp, &chip->pci->dev);
+	gp->open = snd_cs4281_gameport_open;
+	gp->read = snd_cs4281_gameport_read;
+	gp->trigger = snd_cs4281_gameport_trigger;
+	gp->cooked_read = snd_cs4281_gameport_cooked_read;
+	gameport_set_port_data(gp, chip);
+
+	snd_cs4281_pokeBA0(chip, BA0_JSIO, 0xFF); // ?
+	snd_cs4281_pokeBA0(chip, BA0_JSCTL, JSCTL_SP_MEDIUM_SLOW);
+
+	gameport_register_port(gp);
+
+	return 0;
+}
+
+static void snd_cs4281_free_gameport(cs4281_t *chip)
+{
+	if (chip->gameport) {
+		gameport_unregister_port(chip->gameport);
+		chip->gameport = NULL;
+	}
+}
+#else
+static inline int snd_cs4281_create_gameport(cs4281_t *chip) { return -ENOSYS; }
+static inline void snd_cs4281_free_gameport(cs4281_t *chip) { }
+#endif /* CONFIG_GAMEPORT || (MODULE && CONFIG_GAMEPORT_MODULE) */
+
+
+/*
+
+ */
+
+static int snd_cs4281_free(cs4281_t *chip)
+{
+	snd_cs4281_free_gameport(chip);
+
+	if (chip->irq >= 0)
+		synchronize_irq(chip->irq);
+
+	/* Mask interrupts */
+	snd_cs4281_pokeBA0(chip, BA0_HIMR, 0x7fffffff);
+	/* Stop the DLL Clock logic. */
+	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, 0);
+	/* Sound System Power Management - Turn Everything OFF */
+	snd_cs4281_pokeBA0(chip, BA0_SSPM, 0);
+	/* PCI interface - D3 state */
+	pci_set_power_state(chip->pci, 3);
+
+	if (chip->irq >= 0)
+		free_irq(chip->irq, (void *)chip);
+	if (chip->ba0)
+		iounmap(chip->ba0);
+	if (chip->ba1)
+		iounmap(chip->ba1);
+	pci_release_regions(chip->pci);
+	pci_disable_device(chip->pci);
+
+	kfree(chip);
+	return 0;
+}
+
+static int snd_cs4281_dev_free(snd_device_t *device)
+{
+	cs4281_t *chip = device->device_data;
+	return snd_cs4281_free(chip);
+}
+
+static int snd_cs4281_chip_init(cs4281_t *chip); /* defined below */
+#ifdef CONFIG_PM
+static int cs4281_suspend(snd_card_t *card, pm_message_t state);
+static int cs4281_resume(snd_card_t *card);
+#endif
+
+static int __devinit snd_cs4281_create(snd_card_t * card,
+				       struct pci_dev *pci,
+				       cs4281_t ** rchip,
+				       int dual_codec)
+{
+	cs4281_t *chip;
+	unsigned int tmp;
+	int err;
+	static snd_device_ops_t ops = {
+		.dev_free =	snd_cs4281_dev_free,
+	};
+
+	*rchip = NULL;
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+	chip = kcalloc(1, sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL) {
+		pci_disable_device(pci);
+		return -ENOMEM;
+	}
+	spin_lock_init(&chip->reg_lock);
+	chip->card = card;
+	chip->pci = pci;
+	chip->irq = -1;
+	pci_set_master(pci);
+	if (dual_codec < 0 || dual_codec > 3) {
+		snd_printk(KERN_ERR "invalid dual_codec option %d\n", dual_codec);
+		dual_codec = 0;
+	}
+	chip->dual_codec = dual_codec;
+
+	if ((err = pci_request_regions(pci, "CS4281")) < 0) {
+		kfree(chip);
+		pci_disable_device(pci);
+		return err;
+	}
+	chip->ba0_addr = pci_resource_start(pci, 0);
+	chip->ba1_addr = pci_resource_start(pci, 1);
+
+	if (request_irq(pci->irq, snd_cs4281_interrupt, SA_INTERRUPT|SA_SHIRQ, "CS4281", (void *)chip)) {
+		snd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);
+		snd_cs4281_free(chip);
+		return -ENOMEM;
+	}
+	chip->irq = pci->irq;
+
+	chip->ba0 = ioremap_nocache(chip->ba0_addr, pci_resource_len(pci, 0));
+	chip->ba1 = ioremap_nocache(chip->ba1_addr, pci_resource_len(pci, 1));
+	if (!chip->ba0 || !chip->ba1) {
+		snd_cs4281_free(chip);
+		return -ENOMEM;
+	}
+	
+	tmp = snd_cs4281_chip_init(chip);
+	if (tmp) {
+		snd_cs4281_free(chip);
+		return tmp;
+	}
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {
+		snd_cs4281_free(chip);
+		return err;
+	}
+
+	snd_cs4281_proc_init(chip);
+
+	snd_card_set_pm_callback(card, cs4281_suspend, cs4281_resume, chip);
+
+	snd_card_set_dev(card, &pci->dev);
+
+	*rchip = chip;
+	return 0;
+}
+
+static int snd_cs4281_chip_init(cs4281_t *chip)
+{
+	unsigned int tmp;
+	int timeout;
+	int retry_count = 2;
+
+      __retry:
+	tmp = snd_cs4281_peekBA0(chip, BA0_CFLR);
+	if (tmp != BA0_CFLR_DEFAULT) {
+		snd_cs4281_pokeBA0(chip, BA0_CFLR, BA0_CFLR_DEFAULT);
+		tmp = snd_cs4281_peekBA0(chip, BA0_CFLR);
+		if (tmp != BA0_CFLR_DEFAULT) {
+			snd_printk(KERN_ERR "CFLR setup failed (0x%x)\n", tmp);
+			return -EIO;
+		}
+	}
+
+	/* Set the 'Configuration Write Protect' register
+	 * to 4281h.  Allows vendor-defined configuration
+         * space between 0e4h and 0ffh to be written. */	
+	snd_cs4281_pokeBA0(chip, BA0_CWPR, 0x4281);
+	
+	if ((tmp = snd_cs4281_peekBA0(chip, BA0_SERC1)) != (BA0_SERC1_SO1EN | BA0_SERC1_AC97)) {
+		snd_printk(KERN_ERR "SERC1 AC'97 check failed (0x%x)\n", tmp);
+		return -EIO;
+	}
+	if ((tmp = snd_cs4281_peekBA0(chip, BA0_SERC2)) != (BA0_SERC2_SI1EN | BA0_SERC2_AC97)) {
+		snd_printk(KERN_ERR "SERC2 AC'97 check failed (0x%x)\n", tmp);
+		return -EIO;
+	}
+
+	/* Sound System Power Management */
+	snd_cs4281_pokeBA0(chip, BA0_SSPM, BA0_SSPM_MIXEN | BA0_SSPM_CSRCEN |
+				           BA0_SSPM_PSRCEN | BA0_SSPM_JSEN |
+				           BA0_SSPM_ACLEN | BA0_SSPM_FMEN);
+
+	/* Serial Port Power Management */
+ 	/* Blast the clock control register to zero so that the
+         * PLL starts out in a known state, and blast the master serial
+         * port control register to zero so that the serial ports also
+         * start out in a known state. */
+	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, 0);
+	snd_cs4281_pokeBA0(chip, BA0_SERMC, 0);
+
+        /* Make ESYN go to zero to turn off
+         * the Sync pulse on the AC97 link. */
+	snd_cs4281_pokeBA0(chip, BA0_ACCTL, 0);
+	udelay(50);
+                
+	/*  Drive the ARST# pin low for a minimum of 1uS (as defined in the AC97
+	 *  spec) and then drive it high.  This is done for non AC97 modes since
+	 *  there might be logic external to the CS4281 that uses the ARST# line
+	 *  for a reset. */
+	snd_cs4281_pokeBA0(chip, BA0_SPMC, 0);
+	udelay(50);
+	snd_cs4281_pokeBA0(chip, BA0_SPMC, BA0_SPMC_RSTN);
+	snd_cs4281_delay(50000);
+
+	if (chip->dual_codec)
+		snd_cs4281_pokeBA0(chip, BA0_SPMC, BA0_SPMC_RSTN | BA0_SPMC_ASDI2E);
+
+	/*
+	 *  Set the serial port timing configuration.
+	 */
+	snd_cs4281_pokeBA0(chip, BA0_SERMC,
+			   (chip->dual_codec ? BA0_SERMC_TCID(chip->dual_codec) : BA0_SERMC_TCID(1)) |
+			   BA0_SERMC_PTC_AC97 | BA0_SERMC_MSPE);
+
+	/*
+	 *  Start the DLL Clock logic.
+	 */
+	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, BA0_CLKCR1_DLLP);
+	snd_cs4281_delay(50000);
+	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, BA0_CLKCR1_SWCE | BA0_CLKCR1_DLLP);
+
+	/*
+	 * Wait for the DLL ready signal from the clock logic.
+	 */
+	timeout = HZ;
+	do {
+		/*
+		 *  Read the AC97 status register to see if we've seen a CODEC
+		 *  signal from the AC97 codec.
+		 */
+		if (snd_cs4281_peekBA0(chip, BA0_CLKCR1) & BA0_CLKCR1_DLLRDY)
+			goto __ok0;
+		snd_cs4281_delay_long();
+	} while (timeout-- > 0);
+
+	snd_printk(KERN_ERR "DLLRDY not seen\n");
+	return -EIO;
+
+      __ok0:
+
+	/*
+	 *  The first thing we do here is to enable sync generation.  As soon
+	 *  as we start receiving bit clock, we'll start producing the SYNC
+	 *  signal.
+	 */
+	snd_cs4281_pokeBA0(chip, BA0_ACCTL, BA0_ACCTL_ESYN);
+
+	/*
+	 * Wait for the codec ready signal from the AC97 codec.
+	 */
+	timeout = HZ;
+	do {
+		/*
+		 *  Read the AC97 status register to see if we've seen a CODEC
+		 *  signal from the AC97 codec.
+		 */
+		if (snd_cs4281_peekBA0(chip, BA0_ACSTS) & BA0_ACSTS_CRDY)
+			goto __ok1;
+		snd_cs4281_delay_long();
+	} while (timeout-- > 0);
+
+	snd_printk(KERN_ERR "never read codec ready from AC'97 (0x%x)\n", snd_cs4281_peekBA0(chip, BA0_ACSTS));
+	return -EIO;
+
+      __ok1:
+	if (chip->dual_codec) {
+		timeout = HZ;
+		do {
+			if (snd_cs4281_peekBA0(chip, BA0_ACSTS2) & BA0_ACSTS_CRDY)
+				goto __codec2_ok;
+			snd_cs4281_delay_long();
+		} while (timeout-- > 0);
+		snd_printk(KERN_INFO "secondary codec doesn't respond. disable it...\n");
+		chip->dual_codec = 0;
+	__codec2_ok: ;
+	}
+
+	/*
+	 *  Assert the valid frame signal so that we can start sending commands
+	 *  to the AC97 codec.
+	 */
+
+	snd_cs4281_pokeBA0(chip, BA0_ACCTL, BA0_ACCTL_VFRM | BA0_ACCTL_ESYN);
+
+	/*
+	 *  Wait until we've sampled input slots 3 and 4 as valid, meaning that
+	 *  the codec is pumping ADC data across the AC-link.
+	 */
+
+	timeout = HZ;
+	do {
+		/*
+		 *  Read the input slot valid register and see if input slots 3
+		 *  4 are valid yet.
+		 */
+                if ((snd_cs4281_peekBA0(chip, BA0_ACISV) & (BA0_ACISV_SLV(3) | BA0_ACISV_SLV(4))) == (BA0_ACISV_SLV(3) | BA0_ACISV_SLV(4)))
+                        goto __ok2;
+		snd_cs4281_delay_long();
+	} while (timeout-- > 0);
+
+	if (--retry_count > 0)
+		goto __retry;
+	snd_printk(KERN_ERR "never read ISV3 and ISV4 from AC'97\n");
+	return -EIO;
+
+      __ok2:
+
+	/*
+	 *  Now, assert valid frame and the slot 3 and 4 valid bits.  This will
+	 *  commense the transfer of digital audio data to the AC97 codec.
+	 */
+	snd_cs4281_pokeBA0(chip, BA0_ACOSV, BA0_ACOSV_SLV(3) | BA0_ACOSV_SLV(4));
+
+	/*
+	 *  Initialize DMA structures
+	 */
+	for (tmp = 0; tmp < 4; tmp++) {
+		cs4281_dma_t *dma = &chip->dma[tmp];
+		dma->regDBA = BA0_DBA0 + (tmp * 0x10);
+		dma->regDCA = BA0_DCA0 + (tmp * 0x10);
+		dma->regDBC = BA0_DBC0 + (tmp * 0x10);
+		dma->regDCC = BA0_DCC0 + (tmp * 0x10);
+		dma->regDMR = BA0_DMR0 + (tmp * 8);
+		dma->regDCR = BA0_DCR0 + (tmp * 8);
+		dma->regHDSR = BA0_HDSR0 + (tmp * 4);
+		dma->regFCR = BA0_FCR0 + (tmp * 4);
+		dma->regFSIC = BA0_FSIC0 + (tmp * 4);
+		dma->fifo_offset = tmp * CS4281_FIFO_SIZE;
+		snd_cs4281_pokeBA0(chip, dma->regFCR,
+				   BA0_FCR_LS(31) |
+				   BA0_FCR_RS(31) |
+				   BA0_FCR_SZ(CS4281_FIFO_SIZE) |
+				   BA0_FCR_OF(dma->fifo_offset));
+	}
+
+	chip->src_left_play_slot = 0;	/* AC'97 left PCM playback (3) */
+	chip->src_right_play_slot = 1;	/* AC'97 right PCM playback (4) */
+	chip->src_left_rec_slot = 10;	/* AC'97 left PCM record (3) */
+	chip->src_right_rec_slot = 11;	/* AC'97 right PCM record (4) */
+
+	/* Activate wave playback FIFO for FM playback */
+	chip->dma[0].valFCR = BA0_FCR_FEN | BA0_FCR_LS(0) |
+		              BA0_FCR_RS(1) |
+ 	  	              BA0_FCR_SZ(CS4281_FIFO_SIZE) |
+		              BA0_FCR_OF(chip->dma[0].fifo_offset);
+	snd_cs4281_pokeBA0(chip, chip->dma[0].regFCR, chip->dma[0].valFCR);
+	snd_cs4281_pokeBA0(chip, BA0_SRCSA, (chip->src_left_play_slot << 0) |
+					    (chip->src_right_play_slot << 8) |
+					    (chip->src_left_rec_slot << 16) |
+					    (chip->src_right_rec_slot << 24));
+
+	/* Initialize digital volume */
+	snd_cs4281_pokeBA0(chip, BA0_PPLVC, 0);
+	snd_cs4281_pokeBA0(chip, BA0_PPRVC, 0);
+
+	/* Enable IRQs */
+	snd_cs4281_pokeBA0(chip, BA0_HICR, BA0_HICR_EOI);
+	/* Unmask interrupts */
+	snd_cs4281_pokeBA0(chip, BA0_HIMR, 0x7fffffff & ~(
+					BA0_HISR_MIDI |
+					BA0_HISR_DMAI |
+					BA0_HISR_DMA(0) |
+					BA0_HISR_DMA(1) |
+					BA0_HISR_DMA(2) |
+					BA0_HISR_DMA(3)));
+	synchronize_irq(chip->irq);
+
+	return 0;
+}
+
+/*
+ *  MIDI section
+ */
+
+static void snd_cs4281_midi_reset(cs4281_t *chip)
+{
+	snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr | BA0_MIDCR_MRST);
+	udelay(100);
+	snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
+}
+
+static int snd_cs4281_midi_input_open(snd_rawmidi_substream_t * substream)
+{
+	cs4281_t *chip = substream->rmidi->private_data;
+
+	spin_lock_irq(&chip->reg_lock);
+ 	chip->midcr |= BA0_MIDCR_RXE;
+	chip->midi_input = substream;
+	if (!(chip->uartm & CS4281_MODE_OUTPUT)) {
+		snd_cs4281_midi_reset(chip);
+	} else {
+		snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
+	}
+	spin_unlock_irq(&chip->reg_lock);
+	return 0;
+}
+
+static int snd_cs4281_midi_input_close(snd_rawmidi_substream_t * substream)
+{
+	cs4281_t *chip = substream->rmidi->private_data;
+
+	spin_lock_irq(&chip->reg_lock);
+	chip->midcr &= ~(BA0_MIDCR_RXE | BA0_MIDCR_RIE);
+	chip->midi_input = NULL;
+	if (!(chip->uartm & CS4281_MODE_OUTPUT)) {
+		snd_cs4281_midi_reset(chip);
+	} else {
+		snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
+	}
+	chip->uartm &= ~CS4281_MODE_INPUT;
+	spin_unlock_irq(&chip->reg_lock);
+	return 0;
+}
+
+static int snd_cs4281_midi_output_open(snd_rawmidi_substream_t * substream)
+{
+	cs4281_t *chip = substream->rmidi->private_data;
+
+	spin_lock_irq(&chip->reg_lock);
+	chip->uartm |= CS4281_MODE_OUTPUT;
+	chip->midcr |= BA0_MIDCR_TXE;
+	chip->midi_output = substream;
+	if (!(chip->uartm & CS4281_MODE_INPUT)) {
+		snd_cs4281_midi_reset(chip);
+	} else {
+		snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
+	}
+	spin_unlock_irq(&chip->reg_lock);
+	return 0;
+}
+
+static int snd_cs4281_midi_output_close(snd_rawmidi_substream_t * substream)
+{
+	cs4281_t *chip = substream->rmidi->private_data;
+
+	spin_lock_irq(&chip->reg_lock);
+	chip->midcr &= ~(BA0_MIDCR_TXE | BA0_MIDCR_TIE);
+	chip->midi_output = NULL;
+	if (!(chip->uartm & CS4281_MODE_INPUT)) {
+		snd_cs4281_midi_reset(chip);
+	} else {
+		snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
+	}
+	chip->uartm &= ~CS4281_MODE_OUTPUT;
+	spin_unlock_irq(&chip->reg_lock);
+	return 0;
+}
+
+static void snd_cs4281_midi_input_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	unsigned long flags;
+	cs4281_t *chip = substream->rmidi->private_data;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	if (up) {
+		if ((chip->midcr & BA0_MIDCR_RIE) == 0) {
+			chip->midcr |= BA0_MIDCR_RIE;
+			snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
+		}
+	} else {
+		if (chip->midcr & BA0_MIDCR_RIE) {
+			chip->midcr &= ~BA0_MIDCR_RIE;
+			snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
+		}
+	}
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+}
+
+static void snd_cs4281_midi_output_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	unsigned long flags;
+	cs4281_t *chip = substream->rmidi->private_data;
+	unsigned char byte;
+
+	spin_lock_irqsave(&chip->reg_lock, flags);
+	if (up) {
+		if ((chip->midcr & BA0_MIDCR_TIE) == 0) {
+			chip->midcr |= BA0_MIDCR_TIE;
+			/* fill UART FIFO buffer at first, and turn Tx interrupts only if necessary */
+			while ((chip->midcr & BA0_MIDCR_TIE) &&
+			       (snd_cs4281_peekBA0(chip, BA0_MIDSR) & BA0_MIDSR_TBF) == 0) {
+				if (snd_rawmidi_transmit(substream, &byte, 1) != 1) {
+					chip->midcr &= ~BA0_MIDCR_TIE;
+				} else {
+					snd_cs4281_pokeBA0(chip, BA0_MIDWP, byte);
+				}
+			}
+			snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
+		}
+	} else {
+		if (chip->midcr & BA0_MIDCR_TIE) {
+			chip->midcr &= ~BA0_MIDCR_TIE;
+			snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
+		}
+	}
+	spin_unlock_irqrestore(&chip->reg_lock, flags);
+}
+
+static snd_rawmidi_ops_t snd_cs4281_midi_output =
+{
+	.open =		snd_cs4281_midi_output_open,
+	.close =	snd_cs4281_midi_output_close,
+	.trigger =	snd_cs4281_midi_output_trigger,
+};
+
+static snd_rawmidi_ops_t snd_cs4281_midi_input =
+{
+	.open = 	snd_cs4281_midi_input_open,
+	.close =	snd_cs4281_midi_input_close,
+	.trigger =	snd_cs4281_midi_input_trigger,
+};
+
+static int __devinit snd_cs4281_midi(cs4281_t * chip, int device, snd_rawmidi_t **rrawmidi)
+{
+	snd_rawmidi_t *rmidi;
+	int err;
+
+	if (rrawmidi)
+		*rrawmidi = NULL;
+	if ((err = snd_rawmidi_new(chip->card, "CS4281", device, 1, 1, &rmidi)) < 0)
+		return err;
+	strcpy(rmidi->name, "CS4281");
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_cs4281_midi_output);
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_cs4281_midi_input);
+	rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT | SNDRV_RAWMIDI_INFO_DUPLEX;
+	rmidi->private_data = chip;
+	chip->rmidi = rmidi;
+	if (rrawmidi)
+		*rrawmidi = rmidi;
+	return 0;
+}
+
+/*
+ *  Interrupt handler
+ */
+
+static irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	cs4281_t *chip = dev_id;
+	unsigned int status, dma, val;
+	cs4281_dma_t *cdma;
+
+	if (chip == NULL)
+		return IRQ_NONE;
+	status = snd_cs4281_peekBA0(chip, BA0_HISR);
+	if ((status & 0x7fffffff) == 0) {
+		snd_cs4281_pokeBA0(chip, BA0_HICR, BA0_HICR_EOI);
+		return IRQ_NONE;
+	}
+
+	if (status & (BA0_HISR_DMA(0)|BA0_HISR_DMA(1)|BA0_HISR_DMA(2)|BA0_HISR_DMA(3))) {
+		for (dma = 0; dma < 4; dma++)
+			if (status & BA0_HISR_DMA(dma)) {
+				cdma = &chip->dma[dma];
+				spin_lock(&chip->reg_lock);
+				/* ack DMA IRQ */
+				val = snd_cs4281_peekBA0(chip, cdma->regHDSR);
+				/* workaround, sometimes CS4281 acknowledges */
+				/* end or middle transfer position twice */
+				cdma->frag++;
+				if ((val & BA0_HDSR_DHTC) && !(cdma->frag & 1)) {
+					cdma->frag--;
+					chip->spurious_dhtc_irq++;
+					spin_unlock(&chip->reg_lock);
+					continue;
+				}
+				if ((val & BA0_HDSR_DTC) && (cdma->frag & 1)) {
+					cdma->frag--;
+					chip->spurious_dtc_irq++;
+					spin_unlock(&chip->reg_lock);
+					continue;
+				}
+				spin_unlock(&chip->reg_lock);
+				snd_pcm_period_elapsed(cdma->substream);
+			}
+	}
+
+	if ((status & BA0_HISR_MIDI) && chip->rmidi) {
+		unsigned char c;
+		
+		spin_lock(&chip->reg_lock);
+		while ((snd_cs4281_peekBA0(chip, BA0_MIDSR) & BA0_MIDSR_RBE) == 0) {
+			c = snd_cs4281_peekBA0(chip, BA0_MIDRP);
+			if ((chip->midcr & BA0_MIDCR_RIE) == 0)
+				continue;
+			snd_rawmidi_receive(chip->midi_input, &c, 1);
+		}
+		while ((snd_cs4281_peekBA0(chip, BA0_MIDSR) & BA0_MIDSR_TBF) == 0) {
+			if ((chip->midcr & BA0_MIDCR_TIE) == 0)
+				break;
+			if (snd_rawmidi_transmit(chip->midi_output, &c, 1) != 1) {
+				chip->midcr &= ~BA0_MIDCR_TIE;
+				snd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);
+				break;
+			}
+			snd_cs4281_pokeBA0(chip, BA0_MIDWP, c);
+		}
+		spin_unlock(&chip->reg_lock);
+	}
+
+	/* EOI to the PCI part... reenables interrupts */
+	snd_cs4281_pokeBA0(chip, BA0_HICR, BA0_HICR_EOI);
+
+	return IRQ_HANDLED;
+}
+
+
+/*
+ * OPL3 command
+ */
+static void snd_cs4281_opl3_command(opl3_t * opl3, unsigned short cmd, unsigned char val)
+{
+	unsigned long flags;
+	cs4281_t *chip = opl3->private_data;
+	void __iomem *port;
+
+	if (cmd & OPL3_RIGHT)
+		port = chip->ba0 + BA0_B1AP; /* right port */
+	else
+		port = chip->ba0 + BA0_B0AP; /* left port */
+
+	spin_lock_irqsave(&opl3->reg_lock, flags);
+
+	writel((unsigned int)cmd, port);
+	udelay(10);
+
+	writel((unsigned int)val, port + 4);
+	udelay(30);
+
+	spin_unlock_irqrestore(&opl3->reg_lock, flags);
+}
+
+static int __devinit snd_cs4281_probe(struct pci_dev *pci,
+				      const struct pci_device_id *pci_id)
+{
+	static int dev;
+	snd_card_t *card;
+	cs4281_t *chip;
+	opl3_t *opl3;
+	int err;
+
+        if (dev >= SNDRV_CARDS)
+                return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	card = snd_card_new(index[dev], id[dev], THIS_MODULE, 0);
+	if (card == NULL)
+		return -ENOMEM;
+
+	if ((err = snd_cs4281_create(card, pci, &chip, dual_codec[dev])) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	if ((err = snd_cs4281_mixer(chip)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_cs4281_pcm(chip, 0, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_cs4281_midi(chip, 0, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	if ((err = snd_opl3_new(card, OPL3_HW_OPL3_CS4281, &opl3)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	opl3->private_data = chip;
+	opl3->command = snd_cs4281_opl3_command;
+	snd_opl3_init(opl3);
+	if ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	snd_cs4281_create_gameport(chip);
+	strcpy(card->driver, "CS4281");
+	strcpy(card->shortname, "Cirrus Logic CS4281");
+	sprintf(card->longname, "%s at 0x%lx, irq %d",
+		card->shortname,
+		chip->ba0_addr,
+		chip->irq);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	pci_set_drvdata(pci, card);
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_cs4281_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+/*
+ * Power Management
+ */
+#ifdef CONFIG_PM
+
+static int saved_regs[SUSPEND_REGISTERS] = {
+	BA0_JSCTL,
+	BA0_GPIOR,
+	BA0_SSCR,
+	BA0_MIDCR,
+	BA0_SRCSA,
+	BA0_PASR,
+	BA0_CASR,
+	BA0_DACSR,
+	BA0_ADCSR,
+	BA0_FMLVC,
+	BA0_FMRVC,
+	BA0_PPLVC,
+	BA0_PPRVC,
+};
+
+#define CLKCR1_CKRA                             0x00010000L
+
+static int cs4281_suspend(snd_card_t *card, pm_message_t state)
+{
+	cs4281_t *chip = card->pm_private_data;
+	u32 ulCLK;
+	unsigned int i;
+
+	snd_pcm_suspend_all(chip->pcm);
+
+	if (chip->ac97)
+		snd_ac97_suspend(chip->ac97);
+	if (chip->ac97_secondary)
+		snd_ac97_suspend(chip->ac97_secondary);
+
+	ulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);
+	ulCLK |= CLKCR1_CKRA;
+	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);
+
+	/* Disable interrupts. */
+	snd_cs4281_pokeBA0(chip, BA0_HICR, BA0_HICR_CHGM);
+
+	/* remember the status registers */
+	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
+		if (saved_regs[i])
+			chip->suspend_regs[i] = snd_cs4281_peekBA0(chip, saved_regs[i]);
+
+	/* Turn off the serial ports. */
+	snd_cs4281_pokeBA0(chip, BA0_SERMC, 0);
+
+	/* Power off FM, Joystick, AC link, */
+	snd_cs4281_pokeBA0(chip, BA0_SSPM, 0);
+
+	/* DLL off. */
+	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, 0);
+
+	/* AC link off. */
+	snd_cs4281_pokeBA0(chip, BA0_SPMC, 0);
+
+	ulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);
+	ulCLK &= ~CLKCR1_CKRA;
+	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);
+
+	pci_disable_device(chip->pci);
+	return 0;
+}
+
+static int cs4281_resume(snd_card_t *card)
+{
+	cs4281_t *chip = card->pm_private_data;
+	unsigned int i;
+	u32 ulCLK;
+
+	pci_enable_device(chip->pci);
+	pci_set_master(chip->pci);
+
+	ulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);
+	ulCLK |= CLKCR1_CKRA;
+	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);
+
+	snd_cs4281_chip_init(chip);
+
+	/* restore the status registers */
+	for (i = 0; i < ARRAY_SIZE(saved_regs); i++)
+		if (saved_regs[i])
+			snd_cs4281_pokeBA0(chip, saved_regs[i], chip->suspend_regs[i]);
+
+	if (chip->ac97)
+		snd_ac97_resume(chip->ac97);
+	if (chip->ac97_secondary)
+		snd_ac97_resume(chip->ac97_secondary);
+
+	ulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);
+	ulCLK &= ~CLKCR1_CKRA;
+	snd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);
+
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+static struct pci_driver driver = {
+	.name = "CS4281",
+	.id_table = snd_cs4281_ids,
+	.probe = snd_cs4281_probe,
+	.remove = __devexit_p(snd_cs4281_remove),
+	SND_PCI_PM_CALLBACKS
+};
+	
+static int __init alsa_card_cs4281_init(void)
+{
+	return pci_module_init(&driver);
+}
+
+static void __exit alsa_card_cs4281_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_cs4281_init)
+module_exit(alsa_card_cs4281_exit)
