commit fb95aae6e67c4e319a24b3eea32032d4246a5335
Merge: bd2463ac7d7e 90fb04f890bc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 28 16:26:57 2020 -0800

    Merge tag 'sound-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "As the diffstat shows we've had again a lot of works done for this
      cycle: the majority of changes are the continued componentization and
      code refactoring in ASoC, the tree-wide PCM API updates and cleanups
      and SOF updates while a few ASoC driver updates are seen, too.
    
      Here we go, some highlights:
    
      Core:
       - Finally y2038 support landed to ALSA ABI; some ioctls have been
         extended and lots of tricks were applied
       - Applying the new managed PCM buffer API to all drivers; the API
         itself was already merged in 5.5
       - The already deprecated dimension support in ALSA control API is
         dropped completely now
       - Verification of ALSA control elements to catch API misuses
    
      ASoC:
       - Further code refactorings and moving things to the component level
       - Lots of updates and improvements on SOF / Intel drivers; now
         including common HDMI driver and SoundWire support
       - New driver support for Ingenic JZ4770, Mediatek MT6660, Qualcomm
         WCD934x and WSA881x, and Realtek RT700, RT711, RT715, RT1011,
         RT1015 and RT1308
    
      HD-audio:
       - Improved ring-buffer communications using waitqueue
       - Drop the superfluous buffer preallocation on x86
    
      Others:
       - Many code cleanups, mostly constifications over the whole tree
       - USB-audio: quirks for MOTU, Corsair Virtuoso, Line6 Helix
       - FireWire: code refactoring for oxfw and dice drivers"
    
    * tag 'sound-5.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (638 commits)
      ALSA: usb-audio: add quirks for Line6 Helix devices fw>=2.82
      ALSA: hda: Add Clevo W65_67SB the power_save blacklist
      ASoC: soc-core: remove null_snd_soc_ops
      ASoC: soc-pcm: add soc_rtd_trigger()
      ASoC: soc-pcm: add soc_rtd_hw_free()
      ASoC: soc-pcm: add soc_rtd_hw_params()
      ASoC: soc-pcm: add soc_rtd_prepare()
      ASoC: soc-pcm: add soc_rtd_shutdown()
      ASoC: soc-pcm: add soc_rtd_startup()
      ASoC: rt1015: add rt1015 amplifier driver
      ASoC: madera: Correct some kernel doc
      ASoC: topology: fix soc_tplg_fe_link_create() - link->dobj initialization order
      ASoC: Intel: skl_hda_dsp_common: Fix global-out-of-bounds bug
      ASoC: madera: Correct DMIC only input hook ups
      ALSA: cs46xx: fix spelling mistake "to" -> "too"
      ALSA: hda - Add docking station support for Lenovo Thinkpad T420s
      ASoC: Add MediaTek MT6660 Speaker Amp Driver
      ASoC: dt-bindings: rt5645: add suppliers
      ASoC: max98090: fix deadlock in max98090_dapm_put_enum_double()
      ASoC: dapm: add snd_soc_dapm_put_enum_double_locked
      ...

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 75c06a7cc779..e2214ba4a38d 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6594,7 +6594,7 @@ static int snd_hdspm_create(struct snd_card *card,
 	dev_dbg(card->dev, "grabbed memory region 0x%lx-0x%lx\n",
 			hdspm->port, hdspm->port + io_extent - 1);
 
-	hdspm->iobase = ioremap_nocache(hdspm->port, io_extent);
+	hdspm->iobase = ioremap(hdspm->port, io_extent);
 	if (!hdspm->iobase) {
 		dev_err(card->dev, "unable to remap region 0x%lx-0x%lx\n",
 				hdspm->port, hdspm->port + io_extent - 1);

commit e315cc3f93c93e4969d28145b9e30761ad4e58a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sun Jan 5 15:47:34 2020 +0100

    ALSA: hdspm: More constifications
    
    Apply const prefix to each possible place: the string arrays, the
    channel map tables and callers.
    
    Just for minor optimization and no functional changes.
    
    Link: https://lore.kernel.org/r/20200105144823.29547-20-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index f926899e4755..2212d5799151 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -637,7 +637,7 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_SPEED_QUAD   2
 
 /* names for speed modes */
-static char *hdspm_speed_names[] = { "single", "double", "quad" };
+static const char * const hdspm_speed_names[] = { "single", "double", "quad" };
 
 static const char *const texts_autosync_aes_tco[] = { "Word Clock",
 					  "AES1", "AES2", "AES3", "AES4",
@@ -684,7 +684,7 @@ static const char *const texts_freq[] = {
 	"192 kHz"
 };
 
-static char *texts_ports_madi[] = {
+static const char * const texts_ports_madi[] = {
 	"MADI.1", "MADI.2", "MADI.3", "MADI.4", "MADI.5", "MADI.6",
 	"MADI.7", "MADI.8", "MADI.9", "MADI.10", "MADI.11", "MADI.12",
 	"MADI.13", "MADI.14", "MADI.15", "MADI.16", "MADI.17", "MADI.18",
@@ -699,7 +699,7 @@ static char *texts_ports_madi[] = {
 };
 
 
-static char *texts_ports_raydat_ss[] = {
+static const char * const texts_ports_raydat_ss[] = {
 	"ADAT1.1", "ADAT1.2", "ADAT1.3", "ADAT1.4", "ADAT1.5", "ADAT1.6",
 	"ADAT1.7", "ADAT1.8", "ADAT2.1", "ADAT2.2", "ADAT2.3", "ADAT2.4",
 	"ADAT2.5", "ADAT2.6", "ADAT2.7", "ADAT2.8", "ADAT3.1", "ADAT3.2",
@@ -710,7 +710,7 @@ static char *texts_ports_raydat_ss[] = {
 	"SPDIF.L", "SPDIF.R"
 };
 
-static char *texts_ports_raydat_ds[] = {
+static const char * const texts_ports_raydat_ds[] = {
 	"ADAT1.1", "ADAT1.2", "ADAT1.3", "ADAT1.4",
 	"ADAT2.1", "ADAT2.2", "ADAT2.3", "ADAT2.4",
 	"ADAT3.1", "ADAT3.2", "ADAT3.3", "ADAT3.4",
@@ -719,7 +719,7 @@ static char *texts_ports_raydat_ds[] = {
 	"SPDIF.L", "SPDIF.R"
 };
 
-static char *texts_ports_raydat_qs[] = {
+static const char * const texts_ports_raydat_qs[] = {
 	"ADAT1.1", "ADAT1.2",
 	"ADAT2.1", "ADAT2.2",
 	"ADAT3.1", "ADAT3.2",
@@ -729,7 +729,7 @@ static char *texts_ports_raydat_qs[] = {
 };
 
 
-static char *texts_ports_aio_in_ss[] = {
+static const char * const texts_ports_aio_in_ss[] = {
 	"Analogue.L", "Analogue.R",
 	"AES.L", "AES.R",
 	"SPDIF.L", "SPDIF.R",
@@ -738,7 +738,7 @@ static char *texts_ports_aio_in_ss[] = {
 	"AEB.1", "AEB.2", "AEB.3", "AEB.4"
 };
 
-static char *texts_ports_aio_out_ss[] = {
+static const char * const texts_ports_aio_out_ss[] = {
 	"Analogue.L", "Analogue.R",
 	"AES.L", "AES.R",
 	"SPDIF.L", "SPDIF.R",
@@ -748,7 +748,7 @@ static char *texts_ports_aio_out_ss[] = {
 	"AEB.1", "AEB.2", "AEB.3", "AEB.4"
 };
 
-static char *texts_ports_aio_in_ds[] = {
+static const char * const texts_ports_aio_in_ds[] = {
 	"Analogue.L", "Analogue.R",
 	"AES.L", "AES.R",
 	"SPDIF.L", "SPDIF.R",
@@ -756,7 +756,7 @@ static char *texts_ports_aio_in_ds[] = {
 	"AEB.1", "AEB.2", "AEB.3", "AEB.4"
 };
 
-static char *texts_ports_aio_out_ds[] = {
+static const char * const texts_ports_aio_out_ds[] = {
 	"Analogue.L", "Analogue.R",
 	"AES.L", "AES.R",
 	"SPDIF.L", "SPDIF.R",
@@ -765,7 +765,7 @@ static char *texts_ports_aio_out_ds[] = {
 	"AEB.1", "AEB.2", "AEB.3", "AEB.4"
 };
 
-static char *texts_ports_aio_in_qs[] = {
+static const char * const texts_ports_aio_in_qs[] = {
 	"Analogue.L", "Analogue.R",
 	"AES.L", "AES.R",
 	"SPDIF.L", "SPDIF.R",
@@ -773,7 +773,7 @@ static char *texts_ports_aio_in_qs[] = {
 	"AEB.1", "AEB.2", "AEB.3", "AEB.4"
 };
 
-static char *texts_ports_aio_out_qs[] = {
+static const char * const texts_ports_aio_out_qs[] = {
 	"Analogue.L", "Analogue.R",
 	"AES.L", "AES.R",
 	"SPDIF.L", "SPDIF.R",
@@ -782,7 +782,7 @@ static char *texts_ports_aio_out_qs[] = {
 	"AEB.1", "AEB.2", "AEB.3", "AEB.4"
 };
 
-static char *texts_ports_aes32[] = {
+static const char * const texts_ports_aes32[] = {
 	"AES.1", "AES.2", "AES.3", "AES.4", "AES.5", "AES.6", "AES.7",
 	"AES.8", "AES.9.", "AES.10", "AES.11", "AES.12", "AES.13", "AES.14",
 	"AES.15", "AES.16"
@@ -796,7 +796,7 @@ static char *texts_ports_aes32[] = {
    where the data for that channel can be read/written from/to.
 */
 
-static char channel_map_unity_ss[HDSPM_MAX_CHANNELS] = {
+static const char channel_map_unity_ss[HDSPM_MAX_CHANNELS] = {
 	0, 1, 2, 3, 4, 5, 6, 7,
 	8, 9, 10, 11, 12, 13, 14, 15,
 	16, 17, 18, 19, 20, 21, 22, 23,
@@ -807,7 +807,7 @@ static char channel_map_unity_ss[HDSPM_MAX_CHANNELS] = {
 	56, 57, 58, 59, 60, 61, 62, 63
 };
 
-static char channel_map_raydat_ss[HDSPM_MAX_CHANNELS] = {
+static const char channel_map_raydat_ss[HDSPM_MAX_CHANNELS] = {
 	4, 5, 6, 7, 8, 9, 10, 11,	/* ADAT 1 */
 	12, 13, 14, 15, 16, 17, 18, 19,	/* ADAT 2 */
 	20, 21, 22, 23, 24, 25, 26, 27,	/* ADAT 3 */
@@ -820,7 +820,7 @@ static char channel_map_raydat_ss[HDSPM_MAX_CHANNELS] = {
 	-1, -1, -1, -1, -1, -1, -1, -1,
 };
 
-static char channel_map_raydat_ds[HDSPM_MAX_CHANNELS] = {
+static const char channel_map_raydat_ds[HDSPM_MAX_CHANNELS] = {
 	4, 5, 6, 7,		/* ADAT 1 */
 	8, 9, 10, 11,		/* ADAT 2 */
 	12, 13, 14, 15,		/* ADAT 3 */
@@ -835,7 +835,7 @@ static char channel_map_raydat_ds[HDSPM_MAX_CHANNELS] = {
 	-1, -1, -1, -1, -1, -1, -1, -1,
 };
 
-static char channel_map_raydat_qs[HDSPM_MAX_CHANNELS] = {
+static const char channel_map_raydat_qs[HDSPM_MAX_CHANNELS] = {
 	4, 5,			/* ADAT 1 */
 	6, 7,			/* ADAT 2 */
 	8, 9,			/* ADAT 3 */
@@ -851,7 +851,7 @@ static char channel_map_raydat_qs[HDSPM_MAX_CHANNELS] = {
 	-1, -1, -1, -1, -1, -1, -1, -1,
 };
 
-static char channel_map_aio_in_ss[HDSPM_MAX_CHANNELS] = {
+static const char channel_map_aio_in_ss[HDSPM_MAX_CHANNELS] = {
 	0, 1,			/* line in */
 	8, 9,			/* aes in, */
 	10, 11,			/* spdif in */
@@ -865,7 +865,7 @@ static char channel_map_aio_in_ss[HDSPM_MAX_CHANNELS] = {
 	-1, -1, -1, -1, -1, -1, -1, -1,
 };
 
-static char channel_map_aio_out_ss[HDSPM_MAX_CHANNELS] = {
+static const char channel_map_aio_out_ss[HDSPM_MAX_CHANNELS] = {
 	0, 1,			/* line out */
 	8, 9,			/* aes out */
 	10, 11,			/* spdif out */
@@ -880,7 +880,7 @@ static char channel_map_aio_out_ss[HDSPM_MAX_CHANNELS] = {
 	-1, -1, -1, -1, -1, -1, -1, -1,
 };
 
-static char channel_map_aio_in_ds[HDSPM_MAX_CHANNELS] = {
+static const char channel_map_aio_in_ds[HDSPM_MAX_CHANNELS] = {
 	0, 1,			/* line in */
 	8, 9,			/* aes in */
 	10, 11,			/* spdif in */
@@ -895,7 +895,7 @@ static char channel_map_aio_in_ds[HDSPM_MAX_CHANNELS] = {
 	-1, -1, -1, -1, -1, -1, -1, -1
 };
 
-static char channel_map_aio_out_ds[HDSPM_MAX_CHANNELS] = {
+static const char channel_map_aio_out_ds[HDSPM_MAX_CHANNELS] = {
 	0, 1,			/* line out */
 	8, 9,			/* aes out */
 	10, 11,			/* spdif out */
@@ -910,7 +910,7 @@ static char channel_map_aio_out_ds[HDSPM_MAX_CHANNELS] = {
 	-1, -1, -1, -1, -1, -1, -1, -1
 };
 
-static char channel_map_aio_in_qs[HDSPM_MAX_CHANNELS] = {
+static const char channel_map_aio_in_qs[HDSPM_MAX_CHANNELS] = {
 	0, 1,			/* line in */
 	8, 9,			/* aes in */
 	10, 11,			/* spdif in */
@@ -925,7 +925,7 @@ static char channel_map_aio_in_qs[HDSPM_MAX_CHANNELS] = {
 	-1, -1, -1, -1, -1, -1, -1, -1
 };
 
-static char channel_map_aio_out_qs[HDSPM_MAX_CHANNELS] = {
+static const char channel_map_aio_out_qs[HDSPM_MAX_CHANNELS] = {
 	0, 1,			/* line out */
 	8, 9,			/* aes out */
 	10, 11,			/* spdif out */
@@ -941,7 +941,7 @@ static char channel_map_aio_out_qs[HDSPM_MAX_CHANNELS] = {
 	-1, -1, -1, -1, -1, -1, -1, -1
 };
 
-static char channel_map_aes32[HDSPM_MAX_CHANNELS] = {
+static const char channel_map_aes32[HDSPM_MAX_CHANNELS] = {
 	0, 1, 2, 3, 4, 5, 6, 7,
 	8, 9, 10, 11, 12, 13, 14, 15,
 	-1, -1, -1, -1, -1, -1, -1, -1,
@@ -1010,17 +1010,21 @@ struct hdspm {
 	unsigned char max_channels_in;
 	unsigned char max_channels_out;
 
-	signed char *channel_map_in;
-	signed char *channel_map_out;
+	const signed char *channel_map_in;
+	const signed char *channel_map_out;
 
-	signed char *channel_map_in_ss, *channel_map_in_ds, *channel_map_in_qs;
-	signed char *channel_map_out_ss, *channel_map_out_ds, *channel_map_out_qs;
+	const signed char *channel_map_in_ss, *channel_map_in_ds, *channel_map_in_qs;
+	const signed char *channel_map_out_ss, *channel_map_out_ds, *channel_map_out_qs;
 
-	char **port_names_in;
-	char **port_names_out;
+	const char * const *port_names_in;
+	const char * const *port_names_out;
 
-	char **port_names_in_ss, **port_names_in_ds, **port_names_in_qs;
-	char **port_names_out_ss, **port_names_out_ds, **port_names_out_qs;
+	const char * const *port_names_in_ss;
+	const char * const *port_names_in_ds;
+	const char * const *port_names_in_qs;
+	const char * const *port_names_out_ss;
+	const char * const *port_names_out_ds;
+	const char * const *port_names_out_qs;
 
 	unsigned char *playback_buffer;	/* suitably aligned address */
 	unsigned char *capture_buffer;	/* suitably aligned address */

commit b4e5e70775546480035e156b40040e5d0d4264d1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:53 2020 +0100

    ALSA: pci: Constify snd_kcontrol_new items
    
    Most of snd_kcontrol_new definitions are read-only and passed as-is.
    Let's declare them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-38-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 9e3263395f98..f926899e4755 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4478,7 +4478,7 @@ static int snd_hdspm_put_tco_word_term(struct snd_kcontrol *kcontrol,
 
 
 
-static struct snd_kcontrol_new snd_hdspm_controls_madi[] = {
+static const struct snd_kcontrol_new snd_hdspm_controls_madi[] = {
 	HDSPM_MIXER("Mixer", 0),
 	HDSPM_INTERNAL_CLOCK("Internal Clock", 0),
 	HDSPM_SYSTEM_CLOCK_MODE("System Clock Mode", 0),
@@ -4500,7 +4500,7 @@ static struct snd_kcontrol_new snd_hdspm_controls_madi[] = {
 };
 
 
-static struct snd_kcontrol_new snd_hdspm_controls_madiface[] = {
+static const struct snd_kcontrol_new snd_hdspm_controls_madiface[] = {
 	HDSPM_MIXER("Mixer", 0),
 	HDSPM_INTERNAL_CLOCK("Internal Clock", 0),
 	HDSPM_SYSTEM_CLOCK_MODE("System Clock Mode", 0),
@@ -4513,7 +4513,7 @@ static struct snd_kcontrol_new snd_hdspm_controls_madiface[] = {
 	HDSPM_MADI_SPEEDMODE("MADI Speed Mode", 0)
 };
 
-static struct snd_kcontrol_new snd_hdspm_controls_aio[] = {
+static const struct snd_kcontrol_new snd_hdspm_controls_aio[] = {
 	HDSPM_MIXER("Mixer", 0),
 	HDSPM_INTERNAL_CLOCK("Internal Clock", 0),
 	HDSPM_SYSTEM_CLOCK_MODE("System Clock Mode", 0),
@@ -4554,7 +4554,7 @@ static struct snd_kcontrol_new snd_hdspm_controls_aio[] = {
 		   */
 };
 
-static struct snd_kcontrol_new snd_hdspm_controls_raydat[] = {
+static const struct snd_kcontrol_new snd_hdspm_controls_raydat[] = {
 	HDSPM_MIXER("Mixer", 0),
 	HDSPM_INTERNAL_CLOCK("Internal Clock", 0),
 	HDSPM_SYSTEM_CLOCK_MODE("Clock Mode", 0),
@@ -4582,7 +4582,7 @@ static struct snd_kcontrol_new snd_hdspm_controls_raydat[] = {
 	HDSPM_TOGGLE_SETTING("Single Speed WordClock Out", HDSPM_c0_Wck48)
 };
 
-static struct snd_kcontrol_new snd_hdspm_controls_aes32[] = {
+static const struct snd_kcontrol_new snd_hdspm_controls_aes32[] = {
 	HDSPM_MIXER("Mixer", 0),
 	HDSPM_INTERNAL_CLOCK("Internal Clock", 0),
 	HDSPM_SYSTEM_CLOCK_MODE("System Clock Mode", 0),
@@ -4624,7 +4624,7 @@ static struct snd_kcontrol_new snd_hdspm_controls_aes32[] = {
 
 
 /* Control elements for the optional TCO module */
-static struct snd_kcontrol_new snd_hdspm_controls_tco[] = {
+static const struct snd_kcontrol_new snd_hdspm_controls_tco[] = {
 	HDSPM_TCO_SAMPLE_RATE("TCO Sample Rate", 0),
 	HDSPM_TCO_PULL("TCO Pull", 0),
 	HDSPM_TCO_WCK_CONVERSION("TCO WCK Conversion", 0),
@@ -4671,7 +4671,7 @@ static int snd_hdspm_create_controls(struct snd_card *card,
 	unsigned int idx, limit;
 	int err;
 	struct snd_kcontrol *kctl;
-	struct snd_kcontrol_new *list = NULL;
+	const struct snd_kcontrol_new *list = NULL;
 
 	switch (hdspm->io_type) {
 	case MADI:

commit c1c3981fa16688e02f629a4805c9188679b132e9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 3 09:16:17 2020 +0100

    ALSA: pci: Constify snd_pcm_hardware definitions
    
    Most of snd_pcm_hardware definitions are just copied to another object
    as-is, hence we can define them as const for further optimization.
    
    There should be no functional changes by this patch.
    
    Link: https://lore.kernel.org/r/20200103081714.9560-2-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 56ae14c90a2c..9e3263395f98 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -5820,7 +5820,7 @@ static int snd_hdspm_prepare(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static struct snd_pcm_hardware snd_hdspm_playback_subinfo = {
+static const struct snd_pcm_hardware snd_hdspm_playback_subinfo = {
 	.info = (SNDRV_PCM_INFO_MMAP |
 		 SNDRV_PCM_INFO_MMAP_VALID |
 		 SNDRV_PCM_INFO_NONINTERLEAVED |
@@ -5845,7 +5845,7 @@ static struct snd_pcm_hardware snd_hdspm_playback_subinfo = {
 	.fifo_size = 0
 };
 
-static struct snd_pcm_hardware snd_hdspm_capture_subinfo = {
+static const struct snd_pcm_hardware snd_hdspm_capture_subinfo = {
 	.info = (SNDRV_PCM_INFO_MMAP |
 		 SNDRV_PCM_INFO_MMAP_VALID |
 		 SNDRV_PCM_INFO_NONINTERLEAVED |

commit 39cccf4511fd00c591c989edb47c8ed51aba0282
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Dec 10 07:34:32 2019 +0100

    ALSA: rme9652: Support PCM sync_stop
    
    The driver invokes snd_pcm_period_elapsed() simply from the interrupt
    handler.  Set card->sync_irq for enabling the missing sync_stop PCM
    operation.
    
    Link: https://lore.kernel.org/r/20191210063454.31603-34-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 75c06a7cc779..56ae14c90a2c 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6613,6 +6613,7 @@ static int snd_hdspm_create(struct snd_card *card,
 	dev_dbg(card->dev, "use IRQ %d\n", pci->irq);
 
 	hdspm->irq = pci->irq;
+	card->sync_irq = hdspm->irq;
 
 	dev_dbg(card->dev, "kmalloc Mixer memory of %zd Bytes\n",
 		sizeof(*hdspm->mixer));

commit 1a810436a2eff372aa1a934fe4d1bef50bd9dac8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:54 2019 +0100

    ALSA: rme: Avoid non-standard macro usage
    
    Pass the device pointer from the PCI pointer directly, instead of a
    non-standard macro.  The macro didn't give any better readability.
    
    Along with it, drop the unnecessary assignment before the
    snd_dma_alloc_pages() call and simplify by returning the error code
    directly.
    
    Link: https://lore.kernel.org/r/20191105151856.10785-23-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index b571d9d017bb..75c06a7cc779 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6406,7 +6406,7 @@ static int snd_hdspm_preallocate_memory(struct hdspm *hdspm)
 	wanted = HDSPM_DMA_AREA_BYTES;
 
 	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
-					      snd_dma_pci_data(hdspm->pci),
+					      &hdspm->pci->dev,
 					      wanted, wanted);
 	dev_dbg(hdspm->card->dev, " Preallocated %zd Bytes\n", wanted);
 	return 0;

commit 16ccca11088c1bdd9311a2c630b453541305c48a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 5 16:18:50 2019 +0100

    ALSA: pci: Drop superfluous snd_pcm_sgbuf_ops_page
    
    snd_pcm_sgbuf_ops_page is no longer needed to be set explicitly to PCM
    page ops since the recent change in the PCM core (*).  Leaving it NULL
    should work as long as the preallocation has been done properly.
    
    This patch drops the redundant lines.
    
    (*) 7e8edae39fd1: ALSA: pcm: Handle special page mapping in the
                      default mmap handler
    
    Link: https://lore.kernel.org/r/20191105151856.10785-19-tiwai@suse.de
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 81a6f4b2bd3c..b571d9d017bb 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6368,7 +6368,6 @@ static const struct snd_pcm_ops snd_hdspm_ops = {
 	.prepare = snd_hdspm_prepare,
 	.trigger = snd_hdspm_trigger,
 	.pointer = snd_hdspm_hw_pointer,
-	.page = snd_pcm_sgbuf_ops_page,
 };
 
 static int snd_hdspm_create_hwdep(struct snd_card *card,

commit 3c53c6255d598db7084c5c3d7553d7200e857818
Merge: b89b889a326a a98429acadef
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 8 14:45:20 2019 +0200

    Merge tag 'asoc-v5.3' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v5.3
    
    This is a very big update, mainly thanks to Morimoto-san's refactoring
    work and some fairly large new drivers.
    
     - Lots more work on moving towards a component based framework from
       Morimoto-san.
     - Support for force disconnecting muxes from Jerome Brunet.
     - New drivers for Cirrus Logic CS47L35, CS47L85 and CS47L90, Conexant
       CX2072X, Realtek RT1011 and RT1308.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 1209cf0b05e0..6f5eaa510bbc 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *   ALSA driver for RME Hammerfall DSP MADI audio interface(s)
  *
@@ -22,21 +23,6 @@
  *      Modified 2011-01-14 added S/PDIF input on RayDATs by Adrian Knoth
  *
  *	Modified 2011-01-25 variable period sizes on RayDAT/AIO by Adrian Knoth
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
  */
 
 /* *************    Register Documentation   *******************************************************

commit e4e07c6cdca8a837ab40363fc8002cf62965a628
Author: Philippe Bekaert <Philippe.Bekaert@panokkel.be>
Date:   Thu May 23 23:56:49 2019 +0200

    ALSA: hdspm: Fix single speed ADAT capture and playback with RME HDSPe AIO
    
    By taking into account the mapping from logical to DMA channels when
    enabling or disabling audio channels, ADAT channels 3 to 8 on the RME
    HDSPe AIO card are now correctly captured and played back in single speed
    mode.
    
    Since the mapping is an identity mapping for all cards except AIO and
    RayDAT, only those cards should be affected by this patch. It was tested on
    an AIO card. The patch needs testing on other cards, in particular RayDAT.
    
    Note: this patch does not solve ADAT capture and playback issues in double
    or triple speed mode. That seems to be another problem.
    
    Signed-off-by: Philippe Bekaert <Philippe.Bekaert@panokkel.be>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 1209cf0b05e0..982b297b3d0a 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -23,6 +23,9 @@
  *
  *	Modified 2011-01-25 variable period sizes on RayDAT/AIO by Adrian Knoth
  *
+ *      Modified 2019-05-23 fix AIO single speed ADAT capture and playback
+ *      by Philippe.Bekaert@uhasselt.be
+ *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
  *   the Free Software Foundation; either version 2 of the License, or
@@ -1105,9 +1108,9 @@ static int hdspm_autosync_ref(struct hdspm *hdspm);
 static int hdspm_set_toggle_setting(struct hdspm *hdspm, u32 regmask, int out);
 static int snd_hdspm_set_defaults(struct hdspm *hdspm);
 static int hdspm_system_clock_mode(struct hdspm *hdspm);
-static void hdspm_set_sgbuf(struct hdspm *hdspm,
-			    struct snd_pcm_substream *substream,
-			     unsigned int reg, int channels);
+static void hdspm_set_channel_dma_addr(struct hdspm *hdspm,
+				       struct snd_pcm_substream *substream,
+				       unsigned int reg, int channels);
 
 static int hdspm_aes_sync_check(struct hdspm *hdspm, int idx);
 static int hdspm_wc_sync_check(struct hdspm *hdspm);
@@ -5588,11 +5591,16 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 
-		hdspm_set_sgbuf(hdspm, substream, HDSPM_pageAddressBufferOut,
-				params_channels(params));
+		for (i = 0; i < params_channels(params); ++i) {
+			int c = hdspm->channel_map_out[i];
 
-		for (i = 0; i < params_channels(params); ++i)
-			snd_hdspm_enable_out(hdspm, i, 1);
+			if (c < 0)
+				continue;      /* just make sure */
+			hdspm_set_channel_dma_addr(hdspm, substream,
+						   HDSPM_pageAddressBufferOut,
+						   c);
+			snd_hdspm_enable_out(hdspm, c, 1);
+		}
 
 		hdspm->playback_buffer =
 			(unsigned char *) substream->runtime->dma_area;
@@ -5600,11 +5608,16 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 			"Allocated sample buffer for playback at %p\n",
 				hdspm->playback_buffer);
 	} else {
-		hdspm_set_sgbuf(hdspm, substream, HDSPM_pageAddressBufferIn,
-				params_channels(params));
-
-		for (i = 0; i < params_channels(params); ++i)
-			snd_hdspm_enable_in(hdspm, i, 1);
+		for (i = 0; i < params_channels(params); ++i) {
+			int c = hdspm->channel_map_in[i];
+
+			if (c < 0)
+				continue;
+			hdspm_set_channel_dma_addr(hdspm, substream,
+						   HDSPM_pageAddressBufferIn,
+						   c);
+			snd_hdspm_enable_in(hdspm, c, 1);
+		}
 
 		hdspm->capture_buffer =
 			(unsigned char *) substream->runtime->dma_area;
@@ -5665,19 +5678,17 @@ static int snd_hdspm_hw_free(struct snd_pcm_substream *substream)
 	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-
-		/* params_channels(params) should be enough,
-		   but to get sure in case of error */
-		for (i = 0; i < hdspm->max_channels_out; ++i)
+		/* Just disable all channels. The saving when disabling a */
+		/* smaller set is not worth the trouble. */
+		for (i = 0; i < HDSPM_MAX_CHANNELS; ++i)
 			snd_hdspm_enable_out(hdspm, i, 0);
 
 		hdspm->playback_buffer = NULL;
 	} else {
-		for (i = 0; i < hdspm->max_channels_in; ++i)
+		for (i = 0; i < HDSPM_MAX_CHANNELS; ++i)
 			snd_hdspm_enable_in(hdspm, i, 0);
 
 		hdspm->capture_buffer = NULL;
-
 	}
 
 	snd_pcm_lib_free_pages(substream);
@@ -6416,17 +6427,17 @@ static int snd_hdspm_preallocate_memory(struct hdspm *hdspm)
 	return 0;
 }
 
-
-static void hdspm_set_sgbuf(struct hdspm *hdspm,
-			    struct snd_pcm_substream *substream,
-			     unsigned int reg, int channels)
+/* Inform the card what DMA addresses to use for the indicated channel. */
+/* Each channel got 16 4K pages allocated for DMA transfers. */
+static void hdspm_set_channel_dma_addr(struct hdspm *hdspm,
+				       struct snd_pcm_substream *substream,
+				       unsigned int reg, int channel)
 {
 	int i;
 
-	/* continuous memory segment */
-	for (i = 0; i < (channels * 16); i++)
+	for (i = channel * 16; i < channel * 16 + 16; i++)
 		hdspm_write(hdspm, reg + 4 * i,
-				snd_pcm_sgbuf_get_addr(substream, 4096 * i));
+			    snd_pcm_sgbuf_get_addr(substream, 4096 * i));
 }
 
 

commit 36e4617c01153757cde9e5fcd375a75a8f8425c3
Merge: 0b2338a9bf36 62e94da3e9d8
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Feb 8 14:12:15 2019 +0100

    Merge branch 'topic/memory-device-fixes-2' into for-next
    
    Pull further device memory allocation cleanups (but no API change yet).
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit 47f2769b4b2e267cba135fc19c89c32d202b1415
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:01:39 2019 +0100

    ALSA: pci: Clean up with new procfs helpers
    
    Simplify the proc fs creation code with new helper functions,
    snd_card_ro_proc_new() and snd_card_rw_proc_new().
    Just a code refactoring and no functional changes.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 679ad0415e3b..d485dd8a7b72 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -5287,44 +5287,35 @@ static void snd_hdspm_proc_ports_out(struct snd_info_entry *entry,
 
 static void snd_hdspm_proc_init(struct hdspm *hdspm)
 {
-	struct snd_info_entry *entry;
+	void (*read)(struct snd_info_entry *, struct snd_info_buffer *) = NULL;
 
-	if (!snd_card_proc_new(hdspm->card, "hdspm", &entry)) {
-		switch (hdspm->io_type) {
-		case AES32:
-			snd_info_set_text_ops(entry, hdspm,
-					snd_hdspm_proc_read_aes32);
-			break;
-		case MADI:
-			snd_info_set_text_ops(entry, hdspm,
-					snd_hdspm_proc_read_madi);
-			break;
-		case MADIface:
-			/* snd_info_set_text_ops(entry, hdspm,
-			 snd_hdspm_proc_read_madiface); */
-			break;
-		case RayDAT:
-			snd_info_set_text_ops(entry, hdspm,
-					snd_hdspm_proc_read_raydat);
-			break;
-		case AIO:
-			break;
-		}
-	}
-
-	if (!snd_card_proc_new(hdspm->card, "ports.in", &entry)) {
-		snd_info_set_text_ops(entry, hdspm, snd_hdspm_proc_ports_in);
+	switch (hdspm->io_type) {
+	case AES32:
+		read = snd_hdspm_proc_read_aes32;
+		break;
+	case MADI:
+		read = snd_hdspm_proc_read_madi;
+		break;
+	case MADIface:
+		/* read = snd_hdspm_proc_read_madiface; */
+		break;
+	case RayDAT:
+		read = snd_hdspm_proc_read_raydat;
+		break;
+	case AIO:
+		break;
 	}
 
-	if (!snd_card_proc_new(hdspm->card, "ports.out", &entry)) {
-		snd_info_set_text_ops(entry, hdspm, snd_hdspm_proc_ports_out);
-	}
+	snd_card_ro_proc_new(hdspm->card, "hdspm", hdspm, read);
+	snd_card_ro_proc_new(hdspm->card, "ports.in", hdspm,
+			     snd_hdspm_proc_ports_in);
+	snd_card_ro_proc_new(hdspm->card, "ports.out", hdspm,
+			     snd_hdspm_proc_ports_out);
 
 #ifdef CONFIG_SND_DEBUG
 	/* debug file to read all hdspm registers */
-	if (!snd_card_proc_new(hdspm->card, "debug", &entry))
-		snd_info_set_text_ops(entry, hdspm,
-				snd_hdspm_proc_read_debug);
+	snd_card_ro_proc_new(hdspm->card, "debug", hdspm,
+			     snd_hdspm_proc_read_debug);
 #endif
 }
 

commit 5116b94af07a9775ed694562f354e931b2cc04d4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 4 16:32:09 2019 +0100

    ALSA: pci: Drop superfluous PCM preallocation error checks
    
    snd_pcm_lib_preallocate_pages() and co always succeed, so the error
    check is simply redundant.  Drop it.
    
    Reviewed-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 679ad0415e3b..3e66df7b5d1f 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6411,7 +6411,6 @@ static int snd_hdspm_create_hwdep(struct snd_card *card,
  ------------------------------------------------------------*/
 static int snd_hdspm_preallocate_memory(struct hdspm *hdspm)
 {
-	int err;
 	struct snd_pcm *pcm;
 	size_t wanted;
 
@@ -6419,21 +6418,10 @@ static int snd_hdspm_preallocate_memory(struct hdspm *hdspm)
 
 	wanted = HDSPM_DMA_AREA_BYTES;
 
-	err =
-	     snd_pcm_lib_preallocate_pages_for_all(pcm,
-						   SNDRV_DMA_TYPE_DEV_SG,
-						   snd_dma_pci_data(hdspm->pci),
-						   wanted,
-						   wanted);
-	if (err < 0) {
-		dev_dbg(hdspm->card->dev,
-			"Could not preallocate %zd Bytes\n", wanted);
-
-		return err;
-	} else
-		dev_dbg(hdspm->card->dev,
-			" Preallocated %zd Bytes\n", wanted);
-
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,
+					      snd_dma_pci_data(hdspm->pci),
+					      wanted, wanted);
+	dev_dbg(hdspm->card->dev, " Preallocated %zd Bytes\n", wanted);
 	return 0;
 }
 

commit 1bb6d9e2f682a401417f925d602de992c559b057
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sun Aug 26 23:09:52 2018 +0100

    ALSA: hdspm: fix spelling mistake "Initializeing" -> "Initializing"
    
    Trivial fix to spelling mistake in dev_dbg message and also remove
    extraneous white space and repeated question marks.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 11b5b5e0e058..679ad0415e3b 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6534,7 +6534,7 @@ static int snd_hdspm_create_alsa_devices(struct snd_card *card,
 	dev_dbg(card->dev, "Update mixer controls...\n");
 	hdspm_update_simple_mixer_controls(hdspm);
 
-	dev_dbg(card->dev, "Initializeing complete ???\n");
+	dev_dbg(card->dev, "Initializing complete?\n");
 
 	err = snd_card_register(card);
 	if (err < 0) {

commit 10513142a7114d251670361ad40cba2c61403406
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 08:03:14 2018 +0200

    ALSA: hdspm: Hardening for potential Spectre v1
    
    As recently Smatch suggested, a couple of places in HDSP MADI driver
    may expand the array directly from the user-space value with
    speculation:
      sound/pci/rme9652/hdspm.c:5717 snd_hdspm_channel_info() warn: potential spectre issue 'hdspm->channel_map_out' (local cap)
      sound/pci/rme9652/hdspm.c:5734 snd_hdspm_channel_info() warn: potential spectre issue 'hdspm->channel_map_in' (local cap)
    
    This patch puts array_index_nospec() for hardening against them.
    
    BugLink: https://marc.info/?l=linux-kernel&m=152411496503418&w=2
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 4c59983158e0..11b5b5e0e058 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -137,6 +137,7 @@
 #include <linux/pci.h>
 #include <linux/math64.h>
 #include <linux/io.h>
+#include <linux/nospec.h>
 
 #include <sound/core.h>
 #include <sound/control.h>
@@ -5698,40 +5699,43 @@ static int snd_hdspm_channel_info(struct snd_pcm_substream *substream,
 		struct snd_pcm_channel_info *info)
 {
 	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
+	unsigned int channel = info->channel;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		if (snd_BUG_ON(info->channel >= hdspm->max_channels_out)) {
+		if (snd_BUG_ON(channel >= hdspm->max_channels_out)) {
 			dev_info(hdspm->card->dev,
 				 "snd_hdspm_channel_info: output channel out of range (%d)\n",
-				 info->channel);
+				 channel);
 			return -EINVAL;
 		}
 
-		if (hdspm->channel_map_out[info->channel] < 0) {
+		channel = array_index_nospec(channel, hdspm->max_channels_out);
+		if (hdspm->channel_map_out[channel] < 0) {
 			dev_info(hdspm->card->dev,
 				 "snd_hdspm_channel_info: output channel %d mapped out\n",
-				 info->channel);
+				 channel);
 			return -EINVAL;
 		}
 
-		info->offset = hdspm->channel_map_out[info->channel] *
+		info->offset = hdspm->channel_map_out[channel] *
 			HDSPM_CHANNEL_BUFFER_BYTES;
 	} else {
-		if (snd_BUG_ON(info->channel >= hdspm->max_channels_in)) {
+		if (snd_BUG_ON(channel >= hdspm->max_channels_in)) {
 			dev_info(hdspm->card->dev,
 				 "snd_hdspm_channel_info: input channel out of range (%d)\n",
-				 info->channel);
+				 channel);
 			return -EINVAL;
 		}
 
-		if (hdspm->channel_map_in[info->channel] < 0) {
+		channel = array_index_nospec(channel, hdspm->max_channels_in);
+		if (hdspm->channel_map_in[channel] < 0) {
 			dev_info(hdspm->card->dev,
 				 "snd_hdspm_channel_info: input channel %d mapped out\n",
-				 info->channel);
+				 channel);
 			return -EINVAL;
 		}
 
-		info->offset = hdspm->channel_map_in[info->channel] *
+		info->offset = hdspm->channel_map_in[channel] *
 			HDSPM_CHANNEL_BUFFER_BYTES;
 	}
 

commit 7211ec6392c8650ebc804023178c245464417ed2
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 25 08:09:27 2017 -0700

    ALSA: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list
    pointer to all timer callbacks, switch to using the new timer_setup()
    and from_timer() to pass the timer pointer explicitly. These are all the
    "mechanical" changes remaining in the sound subsystem.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index f20d42714e4d..4c59983158e0 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1946,9 +1946,9 @@ snd_hdspm_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)
 	spin_unlock_irqrestore (&hdspm->lock, flags);
 }
 
-static void snd_hdspm_midi_output_timer(unsigned long data)
+static void snd_hdspm_midi_output_timer(struct timer_list *t)
 {
-	struct hdspm_midi *hmidi = (struct hdspm_midi *) data;
+	struct hdspm_midi *hmidi = from_timer(hmidi, t, timer);
 	unsigned long flags;
 
 	snd_hdspm_midi_output_write(hmidi);
@@ -1976,8 +1976,8 @@ snd_hdspm_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)
 	spin_lock_irqsave (&hmidi->lock, flags);
 	if (up) {
 		if (!hmidi->istimer) {
-			setup_timer(&hmidi->timer, snd_hdspm_midi_output_timer,
-				    (unsigned long) hmidi);
+			timer_setup(&hmidi->timer,
+				    snd_hdspm_midi_output_timer, 0);
 			mod_timer(&hmidi->timer, 1 + jiffies);
 			hmidi->istimer++;
 		}

commit e35e9ddfab7e6017b38b8b75cd13756530b3b2b6
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Tue Sep 5 22:22:21 2017 +0200

    ALSA: hdspm: Use common error handling code in snd_hdspm_probe()
    
    Add a jump target so that a bit of exception handling can be better reused
    at the end of this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 25284d8d9758..f20d42714e4d 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6949,10 +6949,8 @@ static int snd_hdspm_probe(struct pci_dev *pci,
 	hdspm->pci = pci;
 
 	err = snd_hdspm_create(card, hdspm);
-	if (err < 0) {
-		snd_card_free(card);
-		return err;
-	}
+	if (err < 0)
+		goto free_card;
 
 	if (hdspm->io_type != MADIface) {
 		snprintf(card->shortname, sizeof(card->shortname), "%s_%x",
@@ -6970,15 +6968,17 @@ static int snd_hdspm_probe(struct pci_dev *pci,
 	}
 
 	err = snd_card_register(card);
-	if (err < 0) {
-		snd_card_free(card);
-		return err;
-	}
+	if (err < 0)
+		goto free_card;
 
 	pci_set_drvdata(pci, card);
 
 	dev++;
 	return 0;
+
+free_card:
+	snd_card_free(card);
+	return err;
 }
 
 static void snd_hdspm_remove(struct pci_dev *pci)

commit da2ea374b28aa6e6e5621396e0ae58580fe94af8
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Aug 12 17:07:09 2017 +0200

    ALSA: rme9652: Adjust seven checks for null pointers
    
    The script “checkpatch.pl” pointed information out like the following.
    
    Comparison to NULL could be written …
    
    Thus fix the affected source code places.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 8d339fb7c24b..25284d8d9758 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1521,7 +1521,7 @@ static void hdspm_silence_playback(struct hdspm *hdspm)
 	int n = hdspm->period_bytes;
 	void *buf = hdspm->playback_buffer;
 
-	if (buf == NULL)
+	if (!buf)
 		return;
 
 	for (i = 0; i < HDSPM_MAX_CHANNELS; i++) {
@@ -4706,7 +4706,7 @@ static int snd_hdspm_create_controls(struct snd_card *card,
 		break;
 	}
 
-	if (NULL != list) {
+	if (list) {
 		for (idx = 0; idx < limit; idx++) {
 			err = snd_ctl_add(card,
 					snd_ctl_new1(&list[idx], hdspm));
@@ -6069,13 +6069,13 @@ static int snd_hdspm_open(struct snd_pcm_substream *substream)
 		snd_hdspm_capture_subinfo;
 
 	if (playback) {
-		if (hdspm->capture_substream == NULL)
+		if (!hdspm->capture_substream)
 			hdspm_stop_audio(hdspm);
 
 		hdspm->playback_pid = current->pid;
 		hdspm->playback_substream = substream;
 	} else {
-		if (hdspm->playback_substream == NULL)
+		if (!hdspm->playback_substream)
 			hdspm_stop_audio(hdspm);
 
 		hdspm->capture_pid = current->pid;
@@ -6775,9 +6775,9 @@ static int snd_hdspm_create(struct snd_card *card,
 				HDSPM_s2_tco_detect) {
 			hdspm->midiPorts++;
 			hdspm->tco = kzalloc(sizeof(*hdspm->tco), GFP_KERNEL);
-			if (NULL != hdspm->tco) {
+			if (hdspm->tco)
 				hdspm_tco_write(hdspm);
-			}
+
 			dev_info(card->dev, "AIO/RayDAT TCO module found\n");
 		} else {
 			hdspm->tco = NULL;
@@ -6789,9 +6789,9 @@ static int snd_hdspm_create(struct snd_card *card,
 		if (hdspm_read(hdspm, HDSPM_statusRegister) & HDSPM_tco_detect) {
 			hdspm->midiPorts++;
 			hdspm->tco = kzalloc(sizeof(*hdspm->tco), GFP_KERNEL);
-			if (NULL != hdspm->tco) {
+			if (hdspm->tco)
 				hdspm_tco_write(hdspm);
-			}
+
 			dev_info(card->dev, "MADI/AES TCO module found\n");
 		} else {
 			hdspm->tco = NULL;
@@ -6868,7 +6868,7 @@ static int snd_hdspm_create(struct snd_card *card,
 		 * this case, we don't set card->id to avoid collisions
 		 * when running with multiple cards.
 		 */
-		if (NULL == id[hdspm->dev] && hdspm->serial != 0xFFFFFF) {
+		if (!id[hdspm->dev] && hdspm->serial != 0xFFFFFF) {
 			snprintf(card->id, sizeof(card->id),
 				 "HDSPMx%06x", hdspm->serial);
 			snd_card_set_id(card, card->id);

commit 7dfec5075f23cdf114f530979bdf3c8dc232ea22
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Aug 12 16:50:06 2017 +0200

    ALSA: rme9652: Improve eight size determinations
    
    Replace the specification of data structures by variable references
    as the parameter for the operator "sizeof" to make the corresponding size
    determination a bit safer according to the Linux coding style convention.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index d448cf474c1b..8d339fb7c24b 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6221,7 +6221,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 		}
 		levels->status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
 
-		s = copy_to_user(argp, levels, sizeof(struct hdspm_peak_rms));
+		s = copy_to_user(argp, levels, sizeof(*levels));
 		if (0 != s) {
 			/* dev_err(hdspm->card->dev, "copy_to_user(.., .., %lu): %lu
 			 [Levels]\n", sizeof(struct hdspm_peak_rms), s);
@@ -6266,7 +6266,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 			ltc.input_format = no_video;
 		}
 
-		s = copy_to_user(argp, &ltc, sizeof(struct hdspm_ltc));
+		s = copy_to_user(argp, &ltc, sizeof(ltc));
 		if (0 != s) {
 			/*
 			  dev_err(hdspm->card->dev, "copy_to_user(.., .., %lu): %lu [LTC]\n", sizeof(struct hdspm_ltc), s); */
@@ -6357,7 +6357,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 		if (copy_from_user(&mixer, argp, sizeof(mixer)))
 			return -EFAULT;
 		if (copy_to_user((void __user *)mixer.mixer, hdspm->mixer,
-					sizeof(struct hdspm_mixer)))
+				 sizeof(*mixer.mixer)))
 			return -EFAULT;
 		break;
 
@@ -6636,8 +6636,8 @@ static int snd_hdspm_create(struct snd_card *card,
 	hdspm->irq = pci->irq;
 
 	dev_dbg(card->dev, "kmalloc Mixer memory of %zd Bytes\n",
-			sizeof(struct hdspm_mixer));
-	hdspm->mixer = kzalloc(sizeof(struct hdspm_mixer), GFP_KERNEL);
+		sizeof(*hdspm->mixer));
+	hdspm->mixer = kzalloc(sizeof(*hdspm->mixer), GFP_KERNEL);
 	if (!hdspm->mixer)
 		return -ENOMEM;
 
@@ -6774,8 +6774,7 @@ static int snd_hdspm_create(struct snd_card *card,
 		if (hdspm_read(hdspm, HDSPM_statusRegister2) &
 				HDSPM_s2_tco_detect) {
 			hdspm->midiPorts++;
-			hdspm->tco = kzalloc(sizeof(struct hdspm_tco),
-					GFP_KERNEL);
+			hdspm->tco = kzalloc(sizeof(*hdspm->tco), GFP_KERNEL);
 			if (NULL != hdspm->tco) {
 				hdspm_tco_write(hdspm);
 			}
@@ -6789,8 +6788,7 @@ static int snd_hdspm_create(struct snd_card *card,
 	case AES32:
 		if (hdspm_read(hdspm, HDSPM_statusRegister) & HDSPM_tco_detect) {
 			hdspm->midiPorts++;
-			hdspm->tco = kzalloc(sizeof(struct hdspm_tco),
-					GFP_KERNEL);
+			hdspm->tco = kzalloc(sizeof(*hdspm->tco), GFP_KERNEL);
 			if (NULL != hdspm->tco) {
 				hdspm_tco_write(hdspm);
 			}
@@ -6941,7 +6939,7 @@ static int snd_hdspm_probe(struct pci_dev *pci,
 	}
 
 	err = snd_card_new(&pci->dev, index[dev], id[dev],
-			   THIS_MODULE, sizeof(struct hdspm), &card);
+			   THIS_MODULE, sizeof(*hdspm), &card);
 	if (err < 0)
 		return err;
 

commit 9dba54296b8b4ae14053bfea82b171aeb9e16710
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Aug 12 16:10:32 2017 +0200

    ALSA: rme9652: Delete an error message for a failed memory allocation in snd_hdspm_create()
    
    Omit an extra message for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 2a3a916e5d15..d448cf474c1b 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6638,12 +6638,8 @@ static int snd_hdspm_create(struct snd_card *card,
 	dev_dbg(card->dev, "kmalloc Mixer memory of %zd Bytes\n",
 			sizeof(struct hdspm_mixer));
 	hdspm->mixer = kzalloc(sizeof(struct hdspm_mixer), GFP_KERNEL);
-	if (!hdspm->mixer) {
-		dev_err(card->dev,
-			"unable to kmalloc Mixer memory of %d Bytes\n",
-				(int)sizeof(struct hdspm_mixer));
+	if (!hdspm->mixer)
 		return -ENOMEM;
-	}
 
 	hdspm->port_names_in = NULL;
 	hdspm->port_names_out = NULL;

commit 7ad210ace5c1701421a4defa9d9e830a6f2ee56b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jul 18 13:48:09 2017 +0200

    ALSA: rme9652: fix format overflow warnings
    
    gcc-7 warns about a possible sprintf format string overflow with a
    temporary buffer that is used to print from another buffer of the same
    size:
    
    sound/pci/rme9652/hdspm.c: In function 'snd_hdspm_create_alsa_devices':
    sound/pci/rme9652/hdspm.c:2123:17: error: ' MIDIoverMADI' directive writing 13 bytes into a region of size between 1 and 32 [-Werror=format-overflow=]
    
    This extends the temporary buffer to twice the size, and changes
    the code to use the safer snprintf() across the entire file.
    The longer buffer is still necessary to avoid a format-truncation
    warning.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 254c3d040118..2a3a916e5d15 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2061,7 +2061,7 @@ static int snd_hdspm_create_midi(struct snd_card *card,
 				 struct hdspm *hdspm, int id)
 {
 	int err;
-	char buf[32];
+	char buf[64];
 
 	hdspm->midi[id].id = id;
 	hdspm->midi[id].hdspm = hdspm;
@@ -2120,19 +2120,23 @@ static int snd_hdspm_create_midi(struct snd_card *card,
 	if ((id < 2) || ((2 == id) && ((MADI == hdspm->io_type) ||
 					(MADIface == hdspm->io_type)))) {
 		if ((id == 0) && (MADIface == hdspm->io_type)) {
-			sprintf(buf, "%s MIDIoverMADI", card->shortname);
+			snprintf(buf, sizeof(buf), "%s MIDIoverMADI",
+				 card->shortname);
 		} else if ((id == 2) && (MADI == hdspm->io_type)) {
-			sprintf(buf, "%s MIDIoverMADI", card->shortname);
+			snprintf(buf, sizeof(buf), "%s MIDIoverMADI",
+				 card->shortname);
 		} else {
-			sprintf(buf, "%s MIDI %d", card->shortname, id+1);
+			snprintf(buf, sizeof(buf), "%s MIDI %d",
+				 card->shortname, id+1);
 		}
 		err = snd_rawmidi_new(card, buf, id, 1, 1,
 				&hdspm->midi[id].rmidi);
 		if (err < 0)
 			return err;
 
-		sprintf(hdspm->midi[id].rmidi->name, "%s MIDI %d",
-				card->id, id+1);
+		snprintf(hdspm->midi[id].rmidi->name,
+			 sizeof(hdspm->midi[id].rmidi->name),
+			 "%s MIDI %d", card->id, id+1);
 		hdspm->midi[id].rmidi->private_data = &hdspm->midi[id];
 
 		snd_rawmidi_set_ops(hdspm->midi[id].rmidi,
@@ -2148,14 +2152,16 @@ static int snd_hdspm_create_midi(struct snd_card *card,
 			SNDRV_RAWMIDI_INFO_DUPLEX;
 	} else {
 		/* TCO MTC, read only */
-		sprintf(buf, "%s MTC %d", card->shortname, id+1);
+		snprintf(buf, sizeof(buf), "%s MTC %d",
+			 card->shortname, id+1);
 		err = snd_rawmidi_new(card, buf, id, 1, 1,
 				&hdspm->midi[id].rmidi);
 		if (err < 0)
 			return err;
 
-		sprintf(hdspm->midi[id].rmidi->name,
-				"%s MTC %d", card->id, id+1);
+		snprintf(hdspm->midi[id].rmidi->name,
+			 sizeof(hdspm->midi[id].rmidi->name),
+			 "%s MTC %d", card->id, id+1);
 		hdspm->midi[id].rmidi->private_data = &hdspm->midi[id];
 
 		snd_rawmidi_set_ops(hdspm->midi[id].rmidi,
@@ -6869,7 +6875,8 @@ static int snd_hdspm_create(struct snd_card *card,
 		 * when running with multiple cards.
 		 */
 		if (NULL == id[hdspm->dev] && hdspm->serial != 0xFFFFFF) {
-			sprintf(card->id, "HDSPMx%06x", hdspm->serial);
+			snprintf(card->id, sizeof(card->id),
+				 "HDSPMx%06x", hdspm->serial);
 			snd_card_set_id(card, card->id);
 		}
 	}
@@ -6954,17 +6961,18 @@ static int snd_hdspm_probe(struct pci_dev *pci,
 	}
 
 	if (hdspm->io_type != MADIface) {
-		sprintf(card->shortname, "%s_%x",
-			hdspm->card_name,
-			hdspm->serial);
-		sprintf(card->longname, "%s S/N 0x%x at 0x%lx, irq %d",
-			hdspm->card_name,
-			hdspm->serial,
-			hdspm->port, hdspm->irq);
+		snprintf(card->shortname, sizeof(card->shortname), "%s_%x",
+			hdspm->card_name, hdspm->serial);
+		snprintf(card->longname, sizeof(card->longname),
+			 "%s S/N 0x%x at 0x%lx, irq %d",
+			 hdspm->card_name, hdspm->serial,
+			 hdspm->port, hdspm->irq);
 	} else {
-		sprintf(card->shortname, "%s", hdspm->card_name);
-		sprintf(card->longname, "%s at 0x%lx, irq %d",
-				hdspm->card_name, hdspm->port, hdspm->irq);
+		snprintf(card->shortname, sizeof(card->shortname), "%s",
+			 hdspm->card_name);
+		snprintf(card->longname, sizeof(card->longname),
+			 "%s at 0x%lx, irq %d",
+			 hdspm->card_name, hdspm->port, hdspm->irq);
 	}
 
 	err = snd_card_register(card);

commit bdf84db72fe78a411aacd1a93375978c2941945f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jun 7 14:22:35 2017 +0200

    ALSA: hdspm: Constify hw_constraints
    
    snd_pcm_hw_constraint_list(), *_ratnums() and *_ratdens() receive the
    const pointers.  Constify the corresponding static objects for better
    hardening.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index c48acdb0e186..254c3d040118 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6040,11 +6040,11 @@ static int snd_hdspm_hw_rule_out_channels(struct snd_pcm_hw_params *params,
 }
 
 
-static unsigned int hdspm_aes32_sample_rates[] = {
+static const unsigned int hdspm_aes32_sample_rates[] = {
 	32000, 44100, 48000, 64000, 88200, 96000, 128000, 176400, 192000
 };
 
-static struct snd_pcm_hw_constraint_list
+static const struct snd_pcm_hw_constraint_list
 hdspm_hw_constraints_aes32_sample_rates = {
 	.count = ARRAY_SIZE(hdspm_aes32_sample_rates),
 	.list = hdspm_aes32_sample_rates,

commit 485885b9d0474ac374297e637f479c22930bb593
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 5 17:29:31 2017 +0100

    ALSA: pci: Constify snd_rawmidi_ops
    
    Now snd_rawmidi_ops is maintained as a const pointer in snd_rawmidi,
    we can constify the definitions.
    
    Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 14bbf55c1ef9..c48acdb0e186 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2043,14 +2043,14 @@ static int snd_hdspm_midi_output_close(struct snd_rawmidi_substream *substream)
 	return 0;
 }
 
-static struct snd_rawmidi_ops snd_hdspm_midi_output =
+static const struct snd_rawmidi_ops snd_hdspm_midi_output =
 {
 	.open =		snd_hdspm_midi_output_open,
 	.close =	snd_hdspm_midi_output_close,
 	.trigger =	snd_hdspm_midi_output_trigger,
 };
 
-static struct snd_rawmidi_ops snd_hdspm_midi_input =
+static const struct snd_rawmidi_ops snd_hdspm_midi_input =
 {
 	.open =		snd_hdspm_midi_input_open,
 	.close =	snd_hdspm_midi_input_close,

commit 6769e988b0062bf8d63d35b0fdbb47b385dd3252
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Sep 2 00:13:10 2016 +0200

    ALSA: constify snd_pcm_ops structures
    
    Check for snd_pcm_ops structures that are only stored in the ops field of a
    snd_soc_platform_driver structure or passed as the third argument to
    snd_pcm_set_ops.  The corresponding field or parameter is declared const,
    so snd_pcm_ops structures that have this property can be declared as const
    also.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable optional_qualifier@
    identifier i;
    position p;
    @@
    static struct snd_pcm_ops i@p = { ... };
    
    @ok1@
    identifier r.i;
    struct snd_soc_platform_driver e;
    position p;
    @@
    e.ops = &i@p;
    
    @ok2@
    identifier r.i;
    expression e1, e2;
    position p;
    @@
    snd_pcm_set_ops(e1, e2, &i@p)
    
    @bad@
    position p != {r.p,ok1.p,ok2.p};
    identifier r.i;
    struct snd_pcm_ops e;
    @@
    e@i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r.i;
    @@
    static
    +const
     struct snd_pcm_ops i = { ... };
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 0e51a00ada23..14bbf55c1ef9 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6361,7 +6361,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 	return 0;
 }
 
-static struct snd_pcm_ops snd_hdspm_ops = {
+static const struct snd_pcm_ops snd_hdspm_ops = {
 	.open = snd_hdspm_open,
 	.close = snd_hdspm_release,
 	.ioctl = snd_hdspm_ioctl,

commit 07cb3272af7935babe8b421f4070a6e3f26ef59b
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Aug 22 12:50:02 2016 +0100

    ALSA: hdspm: fix spelling mistake "Externel" -> "External"
    
    Trivial fix to spelling mistake in dev_warn message.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index a4a999a0317e..0e51a00ada23 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1666,7 +1666,7 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 			    HDSPM_AUTOSYNC_FROM_NONE) {
 
 				dev_warn(hdspm->card->dev,
-					 "Detected no Externel Sync\n");
+					 "Detected no External Sync\n");
 				not_set = 1;
 
 			} else if (rate != external_freq) {

commit c1099c3294c2344110085a38c50e478a5992b368
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 29 14:32:42 2016 +0100

    ALSA: hdspm: Fix zero-division
    
    HDSPM driver contains a code issuing zero-division potentially in
    system sample rate ctl code.  This patch fixes it by not processing
    a zero or invalid rate value as a divisor, as well as excluding the
    invalid value to be passed via the given ctl element.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index b047b1ba48fd..a4a999a0317e 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1601,6 +1601,9 @@ static void hdspm_set_dds_value(struct hdspm *hdspm, int rate)
 {
 	u64 n;
 
+	if (snd_BUG_ON(rate <= 0))
+		return;
+
 	if (rate >= 112000)
 		rate /= 4;
 	else if (rate >= 56000)
@@ -2215,6 +2218,8 @@ static int hdspm_get_system_sample_rate(struct hdspm *hdspm)
 		} else {
 			/* slave mode, return external sample rate */
 			rate = hdspm_external_sample_rate(hdspm);
+			if (!rate)
+				rate = hdspm->system_sample_rate;
 		}
 	}
 
@@ -2260,7 +2265,10 @@ static int snd_hdspm_put_system_sample_rate(struct snd_kcontrol *kcontrol,
 					    ucontrol)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int rate = ucontrol->value.integer.value[0];
 
+	if (rate < 27000 || rate > 207000)
+		return -EINVAL;
 	hdspm_set_dds_value(hdspm, ucontrol->value.integer.value[0]);
 	return 0;
 }

commit 537e48136295c5860a92138c5ea3959b9542868b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 29 14:25:16 2016 +0100

    ALSA: hdspm: Fix wrong boolean ctl value accesses
    
    snd-hdspm driver accesses enum item values (int) instead of boolean
    values (long) wrongly for some ctl elements.  This patch fixes them.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 8bc8016c173d..b047b1ba48fd 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2261,7 +2261,7 @@ static int snd_hdspm_put_system_sample_rate(struct snd_kcontrol *kcontrol,
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	hdspm_set_dds_value(hdspm, ucontrol->value.enumerated.item[0]);
+	hdspm_set_dds_value(hdspm, ucontrol->value.integer.value[0]);
 	return 0;
 }
 
@@ -4449,7 +4449,7 @@ static int snd_hdspm_get_tco_word_term(struct snd_kcontrol *kcontrol,
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	ucontrol->value.enumerated.item[0] = hdspm->tco->term;
+	ucontrol->value.integer.value[0] = hdspm->tco->term;
 
 	return 0;
 }
@@ -4460,8 +4460,8 @@ static int snd_hdspm_put_tco_word_term(struct snd_kcontrol *kcontrol,
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	if (hdspm->tco->term != ucontrol->value.enumerated.item[0]) {
-		hdspm->tco->term = ucontrol->value.enumerated.item[0];
+	if (hdspm->tco->term != ucontrol->value.integer.value[0]) {
+		hdspm->tco->term = ucontrol->value.integer.value[0];
 
 		hdspm_tco_write(hdspm);
 

commit b4ffc1be9fde347f0407b96a7074a8dc2bf61a8a
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Oct 18 15:39:21 2015 +0200

    ALSA: rme9652: Use snd_pcm_hw_constraint_single()
    
    Use the new snd_pcm_hw_constraint_single() helper function instead of
    calling snd_pcm_hw_constraint_minmax() with the same value for min and max
    to install a constraint that limits the possible configuration values to a
    single value. Using snd_pcm_hw_constraint_single() makes the indented
    result clearer.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index cb666c73712d..8bc8016c173d 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6080,18 +6080,17 @@ static int snd_hdspm_open(struct snd_pcm_substream *substream)
 					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
 					     32, 4096);
 		/* RayDAT & AIO have a fixed buffer of 16384 samples per channel */
-		snd_pcm_hw_constraint_minmax(runtime,
+		snd_pcm_hw_constraint_single(runtime,
 					     SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
-					     16384, 16384);
+					     16384);
 		break;
 
 	default:
 		snd_pcm_hw_constraint_minmax(runtime,
 					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
 					     64, 8192);
-		snd_pcm_hw_constraint_minmax(runtime,
-					     SNDRV_PCM_HW_PARAM_PERIODS,
-					     2, 2);
+		snd_pcm_hw_constraint_single(runtime,
+					     SNDRV_PCM_HW_PARAM_PERIODS, 2);
 		break;
 	}
 

commit 0c8d948565490d2a2db9d9a5aec388342c7d38ce
Author: Adrian Knoth <aknoth@google.com>
Date:   Tue Feb 17 00:05:06 2015 +0100

    ALSA: hdspm - DRY cleanup of snd_pcm_ops
    
    This commit removes code duplication between
    snd_hdspm_{capture,playback}_ops. No semantic changes intended, this is
    purely cosmetic.
    
    Signed-off-by: Adrian Knoth <aknoth@google.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 4e1cfb91a8d8..cb666c73712d 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6354,19 +6354,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 	return 0;
 }
 
-static struct snd_pcm_ops snd_hdspm_playback_ops = {
-	.open = snd_hdspm_open,
-	.close = snd_hdspm_release,
-	.ioctl = snd_hdspm_ioctl,
-	.hw_params = snd_hdspm_hw_params,
-	.hw_free = snd_hdspm_hw_free,
-	.prepare = snd_hdspm_prepare,
-	.trigger = snd_hdspm_trigger,
-	.pointer = snd_hdspm_hw_pointer,
-	.page = snd_pcm_sgbuf_ops_page,
-};
-
-static struct snd_pcm_ops snd_hdspm_capture_ops = {
+static struct snd_pcm_ops snd_hdspm_ops = {
 	.open = snd_hdspm_open,
 	.close = snd_hdspm_release,
 	.ioctl = snd_hdspm_ioctl,
@@ -6462,9 +6450,9 @@ static int snd_hdspm_create_pcm(struct snd_card *card,
 	strcpy(pcm->name, hdspm->card_name);
 
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
-			&snd_hdspm_playback_ops);
+			&snd_hdspm_ops);
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
-			&snd_hdspm_capture_ops);
+			&snd_hdspm_ops);
 
 	pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
 

commit 8b73b867294364ae3007affdf8cfd28f022b158c
Author: Adrian Knoth <aknoth@google.com>
Date:   Tue Feb 17 00:05:05 2015 +0100

    ALSA: hdspm - DRY cleanup in .release callback
    
    This commit removes code duplication between
    snd_hdspm_{capture,playback}_release. No semantic changes intended, this
    is purely cosmetic.
    
    Signed-off-by: Adrian Knoth <aknoth@google.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 51e984170b3d..4e1cfb91a8d8 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6120,33 +6120,26 @@ static int snd_hdspm_open(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static int snd_hdspm_playback_release(struct snd_pcm_substream *substream)
+static int snd_hdspm_release(struct snd_pcm_substream *substream)
 {
 	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
+	bool playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
 
 	spin_lock_irq(&hdspm->lock);
 
-	hdspm->playback_pid = -1;
-	hdspm->playback_substream = NULL;
+	if (playback) {
+		hdspm->playback_pid = -1;
+		hdspm->playback_substream = NULL;
+	} else {
+		hdspm->capture_pid = -1;
+		hdspm->capture_substream = NULL;
+	}
 
 	spin_unlock_irq(&hdspm->lock);
 
 	return 0;
 }
 
-static int snd_hdspm_capture_release(struct snd_pcm_substream *substream)
-{
-	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
-
-	spin_lock_irq(&hdspm->lock);
-
-	hdspm->capture_pid = -1;
-	hdspm->capture_substream = NULL;
-
-	spin_unlock_irq(&hdspm->lock);
-	return 0;
-}
-
 static int snd_hdspm_hwdep_dummy_op(struct snd_hwdep *hw, struct file *file)
 {
 	/* we have nothing to initialize but the call is required */
@@ -6363,7 +6356,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 
 static struct snd_pcm_ops snd_hdspm_playback_ops = {
 	.open = snd_hdspm_open,
-	.close = snd_hdspm_playback_release,
+	.close = snd_hdspm_release,
 	.ioctl = snd_hdspm_ioctl,
 	.hw_params = snd_hdspm_hw_params,
 	.hw_free = snd_hdspm_hw_free,
@@ -6375,7 +6368,7 @@ static struct snd_pcm_ops snd_hdspm_playback_ops = {
 
 static struct snd_pcm_ops snd_hdspm_capture_ops = {
 	.open = snd_hdspm_open,
-	.close = snd_hdspm_capture_release,
+	.close = snd_hdspm_release,
 	.ioctl = snd_hdspm_ioctl,
 	.hw_params = snd_hdspm_hw_params,
 	.hw_free = snd_hdspm_hw_free,

commit 5ecc5dc720307d3fb0167e2b14f50e97dd9a2233
Author: Adrian Knoth <aknoth@google.com>
Date:   Tue Feb 17 00:05:04 2015 +0100

    ALSA: hdspm - DRY cleanup in .open callbacks
    
    This commit removes code duplication between
    snd_hdspm_{capture,playback}_open. No semantic changes intended, this is
    purely cosmetic.
    
    Signed-off-by: Adrian Knoth <aknoth@google.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index ca67f896d117..51e984170b3d 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6043,23 +6043,30 @@ hdspm_hw_constraints_aes32_sample_rates = {
 	.mask = 0
 };
 
-static int snd_hdspm_playback_open(struct snd_pcm_substream *substream)
+static int snd_hdspm_open(struct snd_pcm_substream *substream)
 {
 	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
+	bool playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
 
 	spin_lock_irq(&hdspm->lock);
-
 	snd_pcm_set_sync(substream);
+	runtime->hw = (playback) ? snd_hdspm_playback_subinfo :
+		snd_hdspm_capture_subinfo;
 
+	if (playback) {
+		if (hdspm->capture_substream == NULL)
+			hdspm_stop_audio(hdspm);
 
-	runtime->hw = snd_hdspm_playback_subinfo;
-
-	if (hdspm->capture_substream == NULL)
-		hdspm_stop_audio(hdspm);
+		hdspm->playback_pid = current->pid;
+		hdspm->playback_substream = substream;
+	} else {
+		if (hdspm->playback_substream == NULL)
+			hdspm_stop_audio(hdspm);
 
-	hdspm->playback_pid = current->pid;
-	hdspm->playback_substream = substream;
+		hdspm->capture_pid = current->pid;
+		hdspm->capture_substream = substream;
+	}
 
 	spin_unlock_irq(&hdspm->lock);
 
@@ -6094,16 +6101,20 @@ static int snd_hdspm_playback_open(struct snd_pcm_substream *substream)
 				&hdspm_hw_constraints_aes32_sample_rates);
 	} else {
 		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
-				snd_hdspm_hw_rule_rate_out_channels, hdspm,
+				(playback ?
+				 snd_hdspm_hw_rule_rate_out_channels :
+				 snd_hdspm_hw_rule_rate_in_channels), hdspm,
 				SNDRV_PCM_HW_PARAM_CHANNELS, -1);
 	}
 
 	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-			snd_hdspm_hw_rule_out_channels, hdspm,
+			(playback ? snd_hdspm_hw_rule_out_channels :
+			 snd_hdspm_hw_rule_in_channels), hdspm,
 			SNDRV_PCM_HW_PARAM_CHANNELS, -1);
 
 	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-			snd_hdspm_hw_rule_out_channels_rate, hdspm,
+			(playback ? snd_hdspm_hw_rule_out_channels_rate :
+			 snd_hdspm_hw_rule_in_channels_rate), hdspm,
 			SNDRV_PCM_HW_PARAM_RATE, -1);
 
 	return 0;
@@ -6123,69 +6134,6 @@ static int snd_hdspm_playback_release(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-
-static int snd_hdspm_capture_open(struct snd_pcm_substream *substream)
-{
-	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
-	struct snd_pcm_runtime *runtime = substream->runtime;
-
-	spin_lock_irq(&hdspm->lock);
-	snd_pcm_set_sync(substream);
-	runtime->hw = snd_hdspm_capture_subinfo;
-
-	if (hdspm->playback_substream == NULL)
-		hdspm_stop_audio(hdspm);
-
-	hdspm->capture_pid = current->pid;
-	hdspm->capture_substream = substream;
-
-	spin_unlock_irq(&hdspm->lock);
-
-	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
-	snd_pcm_hw_constraint_pow2(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
-
-	switch (hdspm->io_type) {
-	case AIO:
-	case RayDAT:
-		snd_pcm_hw_constraint_minmax(runtime,
-					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
-					     32, 4096);
-		snd_pcm_hw_constraint_minmax(runtime,
-					     SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
-					     16384, 16384);
-		break;
-
-	default:
-		snd_pcm_hw_constraint_minmax(runtime,
-					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
-					     64, 8192);
-		snd_pcm_hw_constraint_minmax(runtime,
-					     SNDRV_PCM_HW_PARAM_PERIODS,
-					     2, 2);
-		break;
-	}
-
-	if (AES32 == hdspm->io_type) {
-		runtime->hw.rates |= SNDRV_PCM_RATE_KNOT;
-		snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
-				&hdspm_hw_constraints_aes32_sample_rates);
-	} else {
-		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
-				snd_hdspm_hw_rule_rate_in_channels, hdspm,
-				SNDRV_PCM_HW_PARAM_CHANNELS, -1);
-	}
-
-	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-			snd_hdspm_hw_rule_in_channels, hdspm,
-			SNDRV_PCM_HW_PARAM_CHANNELS, -1);
-
-	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-			snd_hdspm_hw_rule_in_channels_rate, hdspm,
-			SNDRV_PCM_HW_PARAM_RATE, -1);
-
-	return 0;
-}
-
 static int snd_hdspm_capture_release(struct snd_pcm_substream *substream)
 {
 	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
@@ -6414,7 +6362,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 }
 
 static struct snd_pcm_ops snd_hdspm_playback_ops = {
-	.open = snd_hdspm_playback_open,
+	.open = snd_hdspm_open,
 	.close = snd_hdspm_playback_release,
 	.ioctl = snd_hdspm_ioctl,
 	.hw_params = snd_hdspm_hw_params,
@@ -6426,7 +6374,7 @@ static struct snd_pcm_ops snd_hdspm_playback_ops = {
 };
 
 static struct snd_pcm_ops snd_hdspm_capture_ops = {
-	.open = snd_hdspm_capture_open,
+	.open = snd_hdspm_open,
 	.close = snd_hdspm_capture_release,
 	.ioctl = snd_hdspm_ioctl,
 	.hw_params = snd_hdspm_hw_params,

commit f0153c3d948c1764f6c920a0675d86fc1d75813e
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Tue Feb 10 11:33:50 2015 +0100

    ALSA: hdspm - Constrain periods to 2 on older cards
    
    RME RayDAT and AIO use a fixed buffer size of 16384 samples. With period
    sizes of 32-4096, this translates to 4-512 periods.
    
    The older RME cards have a variable buffer size but require exactly two
    periods.
    
    This patch enforces nperiods=2 on those cards.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Cc: <stable@vger.kernel.org> # 2.6.39+
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 2c363fdca9fd..ca67f896d117 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6082,6 +6082,9 @@ static int snd_hdspm_playback_open(struct snd_pcm_substream *substream)
 		snd_pcm_hw_constraint_minmax(runtime,
 					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
 					     64, 8192);
+		snd_pcm_hw_constraint_minmax(runtime,
+					     SNDRV_PCM_HW_PARAM_PERIODS,
+					     2, 2);
 		break;
 	}
 
@@ -6156,6 +6159,9 @@ static int snd_hdspm_capture_open(struct snd_pcm_substream *substream)
 		snd_pcm_hw_constraint_minmax(runtime,
 					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
 					     64, 8192);
+		snd_pcm_hw_constraint_minmax(runtime,
+					     SNDRV_PCM_HW_PARAM_PERIODS,
+					     2, 2);
 		break;
 	}
 

commit 6cbbfe1c8ddb6ac1322a87795dff9d8712c3e359
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 28 16:49:33 2015 +0100

    ALSA: Include linux/io.h instead of asm/io.h
    
    Nowadays it's recommended.  Replace all in a shot.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 1716323fed9c..2c363fdca9fd 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -136,7 +136,7 @@
 #include <linux/slab.h>
 #include <linux/pci.h>
 #include <linux/math64.h>
-#include <asm/io.h>
+#include <linux/io.h>
 
 #include <sound/core.h>
 #include <sound/control.h>

commit 04018e137c298f199fbf0f0c431d975f584f4702
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 19 11:34:45 2015 +0100

    ALSA: hdspm: Use setup_timer() and mod_timer()
    
    No functional change, refactoring with the standard helpers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 8109b8e5f6ef..1716323fed9c 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1957,10 +1957,8 @@ static void snd_hdspm_midi_output_timer(unsigned long data)
 	   leaving istimer wherever it was set before.
 	*/
 
-	if (hmidi->istimer) {
-		hmidi->timer.expires = 1 + jiffies;
-		add_timer(&hmidi->timer);
-	}
+	if (hmidi->istimer)
+		mod_timer(&hmidi->timer, 1 + jiffies);
 
 	spin_unlock_irqrestore (&hmidi->lock, flags);
 }
@@ -1975,11 +1973,9 @@ snd_hdspm_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)
 	spin_lock_irqsave (&hmidi->lock, flags);
 	if (up) {
 		if (!hmidi->istimer) {
-			init_timer(&hmidi->timer);
-			hmidi->timer.function = snd_hdspm_midi_output_timer;
-			hmidi->timer.data = (unsigned long) hmidi;
-			hmidi->timer.expires = 1 + jiffies;
-			add_timer(&hmidi->timer);
+			setup_timer(&hmidi->timer, snd_hdspm_midi_output_timer,
+				    (unsigned long) hmidi);
+			mod_timer(&hmidi->timer, 1 + jiffies);
 			hmidi->istimer++;
 		}
 	} else {

commit ff6defa6a8fae12205d64f55db395b1fcf35af8e
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jan 3 22:55:54 2015 +0100

    ALSA: Deletion of checks before the function call "iounmap"
    
    The iounmap() function performs also input parameter validation.
    Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 3342705a5715..8109b8e5f6ef 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6965,9 +6965,7 @@ static int snd_hdspm_free(struct hdspm * hdspm)
 		free_irq(hdspm->irq, (void *) hdspm);
 
 	kfree(hdspm->mixer);
-
-	if (hdspm->iobase)
-		iounmap(hdspm->iobase);
+	iounmap(hdspm->iobase);
 
 	if (hdspm->port)
 		pci_release_regions(hdspm->pci);

commit ddcecf6b6ae7b91c8735e52f50cd403ee9cbe298
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 10 17:24:26 2014 +0100

    ALSA: Fix invalid kerneldoc markers
    
    They are no real kerneldoc comments, so drop such markers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index e09348c156d8..3342705a5715 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2201,10 +2201,10 @@ static inline int hdspm_get_pll_freq(struct hdspm *hdspm)
 	return rate;
 }
 
-/**
+/*
  * Calculate the real sample rate from the
  * current DDS value.
- **/
+ */
 static int hdspm_get_system_sample_rate(struct hdspm *hdspm)
 {
 	unsigned int rate;
@@ -2270,9 +2270,9 @@ static int snd_hdspm_put_system_sample_rate(struct snd_kcontrol *kcontrol,
 }
 
 
-/**
+/*
  * Returns the WordClock sample rate class for the given card.
- **/
+ */
 static int hdspm_get_wc_sample_rate(struct hdspm *hdspm)
 {
 	int status;
@@ -2295,9 +2295,9 @@ static int hdspm_get_wc_sample_rate(struct hdspm *hdspm)
 }
 
 
-/**
+/*
  * Returns the TCO sample rate class for the given card.
- **/
+ */
 static int hdspm_get_tco_sample_rate(struct hdspm *hdspm)
 {
 	int status;
@@ -2321,9 +2321,9 @@ static int hdspm_get_tco_sample_rate(struct hdspm *hdspm)
 }
 
 
-/**
+/*
  * Returns the SYNC_IN sample rate class for the given card.
- **/
+ */
 static int hdspm_get_sync_in_sample_rate(struct hdspm *hdspm)
 {
 	int status;
@@ -2343,9 +2343,9 @@ static int hdspm_get_sync_in_sample_rate(struct hdspm *hdspm)
 	return 0;
 }
 
-/**
+/*
  * Returns the AES sample rate class for the given card.
- **/
+ */
 static int hdspm_get_aes_sample_rate(struct hdspm *hdspm, int index)
 {
 	int timecode;
@@ -2361,10 +2361,10 @@ static int hdspm_get_aes_sample_rate(struct hdspm *hdspm, int index)
 	return 0;
 }
 
-/**
+/*
  * Returns the sample rate class for input source <idx> for
  * 'new style' cards like the AIO and RayDAT.
- **/
+ */
 static int hdspm_get_s1_sample_rate(struct hdspm *hdspm, unsigned int idx)
 {
 	int status = hdspm_read(hdspm, HDSPM_RD_STATUS_2);
@@ -2512,10 +2512,10 @@ static int snd_hdspm_get_autosync_sample_rate(struct snd_kcontrol *kcontrol,
 }
 
 
-/**
+/*
  * Returns the system clock mode for the given card.
  * @returns 0 - master, 1 - slave
- **/
+ */
 static int hdspm_system_clock_mode(struct hdspm *hdspm)
 {
 	switch (hdspm->io_type) {
@@ -2534,10 +2534,10 @@ static int hdspm_system_clock_mode(struct hdspm *hdspm)
 }
 
 
-/**
+/*
  * Sets the system clock mode.
  * @param mode 0 - master, 1 - slave
- **/
+ */
 static void hdspm_set_system_clock_mode(struct hdspm *hdspm, int mode)
 {
 	hdspm_set_toggle_setting(hdspm,
@@ -2692,11 +2692,11 @@ static int snd_hdspm_put_clock_source(struct snd_kcontrol *kcontrol,
 }
 
 
-/**
+/*
  * Returns the current preferred sync reference setting.
  * The semantics of the return value are depending on the
  * card, please see the comments for clarification.
- **/
+ */
 static int hdspm_pref_sync_ref(struct hdspm * hdspm)
 {
 	switch (hdspm->io_type) {
@@ -2795,11 +2795,11 @@ static int hdspm_pref_sync_ref(struct hdspm * hdspm)
 }
 
 
-/**
+/*
  * Set the preferred sync reference to <pref>. The semantics
  * of <pref> are depending on the card type, see the comments
  * for clarification.
- **/
+ */
 static int hdspm_set_pref_sync_ref(struct hdspm * hdspm, int pref)
 {
 	int p = 0;
@@ -4101,9 +4101,9 @@ static int snd_hdspm_get_sync_check(struct snd_kcontrol *kcontrol,
 
 
 
-/**
+/*
  * TCO controls
- **/
+ */
 static void hdspm_tco_write(struct hdspm *hdspm)
 {
 	unsigned int tc[4] = { 0, 0, 0, 0};
@@ -5403,7 +5403,7 @@ static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id)
 			HDSPM_midi2IRQPending | HDSPM_midi3IRQPending);
 
 	/* now = get_cycles(); */
-	/**
+	/*
 	 *   LAT_2..LAT_0 period  counter (win)  counter (mac)
 	 *          6       4096   ~256053425     ~514672358
 	 *          5       2048   ~128024983     ~257373821
@@ -5412,7 +5412,7 @@ static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id)
 	 *          2        256    ~16003039      ~32260176
 	 *          1        128     ~7998738      ~16194507
 	 *          0         64     ~3998231       ~8191558
-	 **/
+	 */
 	/*
 	  dev_info(hdspm->card->dev, "snd_hdspm_interrupt %llu @ %llx\n",
 	   now-hdspm->last_interrupt, status & 0xFFC0);

commit df57de172a47f16548ee4bb69d1110e32686d6a9
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 29 20:09:45 2014 +0530

    ALSA: hdspm: remove unused variable
    
    removed the unused variables. These variables were only being
    assigned some value, but the values were never being used.
    
    it has been build tested after removing the variables.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 7f7277bfb66a..e09348c156d8 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1257,14 +1257,13 @@ static int hdspm_rate_multiplier(struct hdspm *hdspm, int rate)
 /* check for external sample rate, returns the sample rate in Hz*/
 static int hdspm_external_sample_rate(struct hdspm *hdspm)
 {
-	unsigned int status, status2, timecode;
+	unsigned int status, status2;
 	int syncref, rate = 0, rate_bits;
 
 	switch (hdspm->io_type) {
 	case AES32:
 		status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
 		status = hdspm_read(hdspm, HDSPM_statusRegister);
-		timecode = hdspm_read(hdspm, HDSPM_timecodeRegister);
 
 		syncref = hdspm_autosync_ref(hdspm);
 		switch (syncref) {
@@ -4862,18 +4861,15 @@ snd_hdspm_proc_read_madi(struct snd_info_entry *entry,
 			 struct snd_info_buffer *buffer)
 {
 	struct hdspm *hdspm = entry->private_data;
-	unsigned int status, status2, control, freq;
+	unsigned int status, status2;
 
 	char *pref_sync_ref;
 	char *autosync_ref;
 	char *system_clock_mode;
-	char *insel;
 	int x, x2;
 
 	status = hdspm_read(hdspm, HDSPM_statusRegister);
 	status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
-	control = hdspm->control_register;
-	freq = hdspm_read(hdspm, HDSPM_timecodeRegister);
 
 	snd_iprintf(buffer, "%s (Card #%d) Rev.%x Status2first3bits: %x\n",
 			hdspm->card_name, hdspm->card->number + 1,
@@ -4936,17 +4932,6 @@ snd_hdspm_proc_read_madi(struct snd_info_entry *entry,
 	snd_iprintf(buffer, "Line out: %s\n",
 		(hdspm->control_register & HDSPM_LineOut) ? "on " : "off");
 
-	switch (hdspm->control_register & HDSPM_InputMask) {
-	case HDSPM_InputOptical:
-		insel = "Optical";
-		break;
-	case HDSPM_InputCoaxial:
-		insel = "Coaxial";
-		break;
-	default:
-		insel = "Unknown";
-	}
-
 	snd_iprintf(buffer,
 		"ClearTrackMarker = %s, Transmit in %s Channel Mode, "
 		"Auto Input %s\n",
@@ -5191,15 +5176,13 @@ snd_hdspm_proc_read_raydat(struct snd_info_entry *entry,
 			 struct snd_info_buffer *buffer)
 {
 	struct hdspm *hdspm = entry->private_data;
-	unsigned int status1, status2, status3, control, i;
+	unsigned int status1, status2, status3, i;
 	unsigned int lock, sync;
 
 	status1 = hdspm_read(hdspm, HDSPM_RD_STATUS_1); /* s1 */
 	status2 = hdspm_read(hdspm, HDSPM_RD_STATUS_2); /* freq */
 	status3 = hdspm_read(hdspm, HDSPM_RD_STATUS_3); /* s2 */
 
-	control = hdspm->control_register;
-
 	snd_iprintf(buffer, "STATUS1: 0x%08x\n", status1);
 	snd_iprintf(buffer, "STATUS2: 0x%08x\n", status2);
 	snd_iprintf(buffer, "STATUS3: 0x%08x\n", status3);

commit c69a637b4df37fc5a011a89e422636ea393af5b0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Oct 20 18:19:41 2014 +0200

    ALSA: hdspm: Use snd_ctl_enum_info()
    
    ... and reduce the open codes.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 52d86af3ef2d..7f7277bfb66a 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2645,18 +2645,7 @@ static int hdspm_set_clock_source(struct hdspm * hdspm, int mode)
 static int snd_hdspm_info_clock_source(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 9;
-
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-		    uinfo->value.enumerated.items - 1;
-
-	strcpy(uinfo->value.enumerated.name,
-	       texts_freq[uinfo->value.enumerated.item+1]);
-
-	return 0;
+	return snd_ctl_enum_info(uinfo, 1, 9, texts_freq + 1);
 }
 
 static int snd_hdspm_get_clock_source(struct snd_kcontrol *kcontrol,

commit 9baa3c34ac4e27f7e062f266f50cc5dbea26a6c1
Author: Benoit Taine <benoit.taine@lip6.fr>
Date:   Fri Aug 8 15:56:03 2014 +0200

    PCI: Remove DEFINE_PCI_DEVICE_TABLE macro use
    
    We should prefer `struct pci_device_id` over `DEFINE_PCI_DEVICE_TABLE` to
    meet kernel coding style guidelines.  This issue was reported by checkpatch.
    
    A simplified version of the semantic patch that makes this change is as
    follows (http://coccinelle.lip6.fr/):
    
    // <smpl>
    
    @@
    identifier i;
    declarer name DEFINE_PCI_DEVICE_TABLE;
    initializer z;
    @@
    
    - DEFINE_PCI_DEVICE_TABLE(i)
    + const struct pci_device_id i[]
    = z;
    
    // </smpl>
    
    [bhelgaas: add semantic patch]
    Signed-off-by: Benoit Taine <benoit.taine@lip6.fr>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index cb82b593473a..52d86af3ef2d 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1077,7 +1077,7 @@ struct hdspm {
 };
 
 
-static DEFINE_PCI_DEVICE_TABLE(snd_hdspm_ids) = {
+static const struct pci_device_id snd_hdspm_ids[] = {
 	{
 	 .vendor = PCI_VENDOR_ID_XILINX,
 	 .device = PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP_MADI,

commit e3a471d6680487c693ab82b197e37688174cefc6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 26 12:05:40 2014 +0100

    ALSA: hdspm: Use standard printk helpers
    
    Convert with dev_err() and co from snd_printk(), etc.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 76016287e46f..cb82b593473a 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1651,9 +1651,8 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 			   just make a warning an remember setting
 			   for future master mode switching */
 
-			snd_printk(KERN_WARNING "HDSPM: "
-				   "Warning: device is not running "
-				   "as a clock master.\n");
+			dev_warn(hdspm->card->dev,
+				 "Warning: device is not running as a clock master.\n");
 			not_set = 1;
 		} else {
 
@@ -1664,15 +1663,14 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 			if (hdspm_autosync_ref(hdspm) ==
 			    HDSPM_AUTOSYNC_FROM_NONE) {
 
-				snd_printk(KERN_WARNING "HDSPM: "
-					   "Detected no Externel Sync \n");
+				dev_warn(hdspm->card->dev,
+					 "Detected no Externel Sync\n");
 				not_set = 1;
 
 			} else if (rate != external_freq) {
 
-				snd_printk(KERN_WARNING "HDSPM: "
-					   "Warning: No AutoSync source for "
-					   "requested rate\n");
+				dev_warn(hdspm->card->dev,
+					 "Warning: No AutoSync source for requested rate\n");
 				not_set = 1;
 			}
 		}
@@ -1738,13 +1736,11 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 
 	if (current_speed != target_speed
 	    && (hdspm->capture_pid >= 0 || hdspm->playback_pid >= 0)) {
-		snd_printk
-		    (KERN_ERR "HDSPM: "
-		     "cannot change from %s speed to %s speed mode "
-		     "(capture PID = %d, playback PID = %d)\n",
-		     hdspm_speed_names[current_speed],
-		     hdspm_speed_names[target_speed],
-		     hdspm->capture_pid, hdspm->playback_pid);
+		dev_err(hdspm->card->dev,
+			"cannot change from %s speed to %s speed mode (capture PID = %d, playback PID = %d)\n",
+			hdspm_speed_names[current_speed],
+			hdspm_speed_names[target_speed],
+			hdspm->capture_pid, hdspm->playback_pid);
 		return -EBUSY;
 	}
 
@@ -5446,7 +5442,7 @@ static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id)
 	 *          0         64     ~3998231       ~8191558
 	 **/
 	/*
-	   snd_printk(KERN_INFO "snd_hdspm_interrupt %llu @ %llx\n",
+	  dev_info(hdspm->card->dev, "snd_hdspm_interrupt %llu @ %llx\n",
 	   now-hdspm->last_interrupt, status & 0xFFC0);
 	   hdspm->last_interrupt = now;
 	*/
@@ -5583,7 +5579,7 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 	spin_lock_irq(&hdspm->lock);
 	err = hdspm_set_rate(hdspm, params_rate(params), 0);
 	if (err < 0) {
-		snd_printk(KERN_INFO "err on hdspm_set_rate: %d\n", err);
+		dev_info(hdspm->card->dev, "err on hdspm_set_rate: %d\n", err);
 		spin_unlock_irq(&hdspm->lock);
 		_snd_pcm_hw_param_setempty(params,
 				SNDRV_PCM_HW_PARAM_RATE);
@@ -5594,7 +5590,8 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 	err = hdspm_set_interrupt_interval(hdspm,
 			params_period_size(params));
 	if (err < 0) {
-		snd_printk(KERN_INFO "err on hdspm_set_interrupt_interval: %d\n", err);
+		dev_info(hdspm->card->dev,
+			 "err on hdspm_set_interrupt_interval: %d\n", err);
 		_snd_pcm_hw_param_setempty(params,
 				SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
 		return err;
@@ -5610,7 +5607,8 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 	err =
 		snd_pcm_lib_malloc_pages(substream, HDSPM_DMA_AREA_BYTES);
 	if (err < 0) {
-		snd_printk(KERN_INFO "err on snd_pcm_lib_malloc_pages: %d\n", err);
+		dev_info(hdspm->card->dev,
+			 "err on snd_pcm_lib_malloc_pages: %d\n", err);
 		return err;
 	}
 
@@ -5624,7 +5622,8 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 
 		hdspm->playback_buffer =
 			(unsigned char *) substream->runtime->dma_area;
-		snd_printdd("Allocated sample buffer for playback at %p\n",
+		dev_dbg(hdspm->card->dev,
+			"Allocated sample buffer for playback at %p\n",
 				hdspm->playback_buffer);
 	} else {
 		hdspm_set_sgbuf(hdspm, substream, HDSPM_pageAddressBufferIn,
@@ -5635,18 +5634,21 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 
 		hdspm->capture_buffer =
 			(unsigned char *) substream->runtime->dma_area;
-		snd_printdd("Allocated sample buffer for capture at %p\n",
+		dev_dbg(hdspm->card->dev,
+			"Allocated sample buffer for capture at %p\n",
 				hdspm->capture_buffer);
 	}
 
 	/*
-	   snd_printdd("Allocated sample buffer for %s at 0x%08X\n",
+	   dev_dbg(hdspm->card->dev,
+	   "Allocated sample buffer for %s at 0x%08X\n",
 	   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
 	   "playback" : "capture",
 	   snd_pcm_sgbuf_get_addr(substream, 0));
 	   */
 	/*
-	   snd_printdd("set_hwparams: %s %d Hz, %d channels, bs = %d\n",
+	   dev_dbg(hdspm->card->dev,
+	   "set_hwparams: %s %d Hz, %d channels, bs = %d\n",
 	   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
 	   "playback" : "capture",
 	   params_rate(params), params_channels(params),
@@ -5667,12 +5669,14 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 	/* Switch to native float format if requested */
 	if (SNDRV_PCM_FORMAT_FLOAT_LE == params_format(params)) {
 		if (!(hdspm->control_register & HDSPe_FLOAT_FORMAT))
-			snd_printk(KERN_INFO "hdspm: Switching to native 32bit LE float format.\n");
+			dev_info(hdspm->card->dev,
+				 "Switching to native 32bit LE float format.\n");
 
 		hdspm->control_register |= HDSPe_FLOAT_FORMAT;
 	} else if (SNDRV_PCM_FORMAT_S32_LE == params_format(params)) {
 		if (hdspm->control_register & HDSPe_FLOAT_FORMAT)
-			snd_printk(KERN_INFO "hdspm: Switching to native 32bit LE integer format.\n");
+			dev_info(hdspm->card->dev,
+				 "Switching to native 32bit LE integer format.\n");
 
 		hdspm->control_register &= ~HDSPe_FLOAT_FORMAT;
 	}
@@ -5715,12 +5719,16 @@ static int snd_hdspm_channel_info(struct snd_pcm_substream *substream,
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		if (snd_BUG_ON(info->channel >= hdspm->max_channels_out)) {
-			snd_printk(KERN_INFO "snd_hdspm_channel_info: output channel out of range (%d)\n", info->channel);
+			dev_info(hdspm->card->dev,
+				 "snd_hdspm_channel_info: output channel out of range (%d)\n",
+				 info->channel);
 			return -EINVAL;
 		}
 
 		if (hdspm->channel_map_out[info->channel] < 0) {
-			snd_printk(KERN_INFO "snd_hdspm_channel_info: output channel %d mapped out\n", info->channel);
+			dev_info(hdspm->card->dev,
+				 "snd_hdspm_channel_info: output channel %d mapped out\n",
+				 info->channel);
 			return -EINVAL;
 		}
 
@@ -5728,12 +5736,16 @@ static int snd_hdspm_channel_info(struct snd_pcm_substream *substream,
 			HDSPM_CHANNEL_BUFFER_BYTES;
 	} else {
 		if (snd_BUG_ON(info->channel >= hdspm->max_channels_in)) {
-			snd_printk(KERN_INFO "snd_hdspm_channel_info: input channel out of range (%d)\n", info->channel);
+			dev_info(hdspm->card->dev,
+				 "snd_hdspm_channel_info: input channel out of range (%d)\n",
+				 info->channel);
 			return -EINVAL;
 		}
 
 		if (hdspm->channel_map_in[info->channel] < 0) {
-			snd_printk(KERN_INFO "snd_hdspm_channel_info: input channel %d mapped out\n", info->channel);
+			dev_info(hdspm->card->dev,
+				 "snd_hdspm_channel_info: input channel %d mapped out\n",
+				 info->channel);
 			return -EINVAL;
 		}
 
@@ -6283,7 +6295,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 
 		s = copy_to_user(argp, levels, sizeof(struct hdspm_peak_rms));
 		if (0 != s) {
-			/* snd_printk(KERN_ERR "copy_to_user(.., .., %lu): %lu
+			/* dev_err(hdspm->card->dev, "copy_to_user(.., .., %lu): %lu
 			 [Levels]\n", sizeof(struct hdspm_peak_rms), s);
 			 */
 			return -EFAULT;
@@ -6329,7 +6341,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 		s = copy_to_user(argp, &ltc, sizeof(struct hdspm_ltc));
 		if (0 != s) {
 			/*
-			 snd_printk(KERN_ERR "copy_to_user(.., .., %lu): %lu [LTC]\n", sizeof(struct hdspm_ltc), s); */
+			  dev_err(hdspm->card->dev, "copy_to_user(.., .., %lu): %lu [LTC]\n", sizeof(struct hdspm_ltc), s); */
 			return -EFAULT;
 		}
 
@@ -6494,11 +6506,13 @@ static int snd_hdspm_preallocate_memory(struct hdspm *hdspm)
 						   wanted,
 						   wanted);
 	if (err < 0) {
-		snd_printdd("Could not preallocate %zd Bytes\n", wanted);
+		dev_dbg(hdspm->card->dev,
+			"Could not preallocate %zd Bytes\n", wanted);
 
 		return err;
 	} else
-		snd_printdd(" Preallocated %zd Bytes\n", wanted);
+		dev_dbg(hdspm->card->dev,
+			" Preallocated %zd Bytes\n", wanted);
 
 	return 0;
 }
@@ -6559,7 +6573,7 @@ static int snd_hdspm_create_alsa_devices(struct snd_card *card,
 {
 	int err, i;
 
-	snd_printdd("Create card...\n");
+	dev_dbg(card->dev, "Create card...\n");
 	err = snd_hdspm_create_pcm(card, hdspm);
 	if (err < 0)
 		return err;
@@ -6581,7 +6595,7 @@ static int snd_hdspm_create_alsa_devices(struct snd_card *card,
 	if (err < 0)
 		return err;
 
-	snd_printdd("proc init...\n");
+	dev_dbg(card->dev, "proc init...\n");
 	snd_hdspm_proc_init(hdspm);
 
 	hdspm->system_sample_rate = -1;
@@ -6592,23 +6606,23 @@ static int snd_hdspm_create_alsa_devices(struct snd_card *card,
 	hdspm->capture_substream = NULL;
 	hdspm->playback_substream = NULL;
 
-	snd_printdd("Set defaults...\n");
+	dev_dbg(card->dev, "Set defaults...\n");
 	err = snd_hdspm_set_defaults(hdspm);
 	if (err < 0)
 		return err;
 
-	snd_printdd("Update mixer controls...\n");
+	dev_dbg(card->dev, "Update mixer controls...\n");
 	hdspm_update_simple_mixer_controls(hdspm);
 
-	snd_printdd("Initializeing complete ???\n");
+	dev_dbg(card->dev, "Initializeing complete ???\n");
 
 	err = snd_card_register(card);
 	if (err < 0) {
-		snd_printk(KERN_ERR "HDSPM: error registering card\n");
+		dev_err(card->dev, "error registering card\n");
 		return err;
 	}
 
-	snd_printdd("... yes now\n");
+	dev_dbg(card->dev, "... yes now\n");
 
 	return 0;
 }
@@ -6662,8 +6676,8 @@ static int snd_hdspm_create(struct snd_card *card,
 			hdspm->card_name = "RME MADI";
 			hdspm->midiPorts = 3;
 		} else {
-			snd_printk(KERN_ERR
-				"HDSPM: unknown firmware revision %x\n",
+			dev_err(card->dev,
+				"unknown firmware revision %x\n",
 				hdspm->firmware_rev);
 			return -ENODEV;
 		}
@@ -6682,36 +6696,35 @@ static int snd_hdspm_create(struct snd_card *card,
 	hdspm->port = pci_resource_start(pci, 0);
 	io_extent = pci_resource_len(pci, 0);
 
-	snd_printdd("grabbed memory region 0x%lx-0x%lx\n",
+	dev_dbg(card->dev, "grabbed memory region 0x%lx-0x%lx\n",
 			hdspm->port, hdspm->port + io_extent - 1);
 
 	hdspm->iobase = ioremap_nocache(hdspm->port, io_extent);
 	if (!hdspm->iobase) {
-		snd_printk(KERN_ERR "HDSPM: "
-				"unable to remap region 0x%lx-0x%lx\n",
+		dev_err(card->dev, "unable to remap region 0x%lx-0x%lx\n",
 				hdspm->port, hdspm->port + io_extent - 1);
 		return -EBUSY;
 	}
-	snd_printdd("remapped region (0x%lx) 0x%lx-0x%lx\n",
+	dev_dbg(card->dev, "remapped region (0x%lx) 0x%lx-0x%lx\n",
 			(unsigned long)hdspm->iobase, hdspm->port,
 			hdspm->port + io_extent - 1);
 
 	if (request_irq(pci->irq, snd_hdspm_interrupt,
 			IRQF_SHARED, KBUILD_MODNAME, hdspm)) {
-		snd_printk(KERN_ERR "HDSPM: unable to use IRQ %d\n", pci->irq);
+		dev_err(card->dev, "unable to use IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}
 
-	snd_printdd("use IRQ %d\n", pci->irq);
+	dev_dbg(card->dev, "use IRQ %d\n", pci->irq);
 
 	hdspm->irq = pci->irq;
 
-	snd_printdd("kmalloc Mixer memory of %zd Bytes\n",
+	dev_dbg(card->dev, "kmalloc Mixer memory of %zd Bytes\n",
 			sizeof(struct hdspm_mixer));
 	hdspm->mixer = kzalloc(sizeof(struct hdspm_mixer), GFP_KERNEL);
 	if (!hdspm->mixer) {
-		snd_printk(KERN_ERR "HDSPM: "
-				"unable to kmalloc Mixer memory of %d Bytes\n",
+		dev_err(card->dev,
+			"unable to kmalloc Mixer memory of %d Bytes\n",
 				(int)sizeof(struct hdspm_mixer));
 		return -ENOMEM;
 	}
@@ -6780,14 +6793,14 @@ static int snd_hdspm_create(struct snd_card *card,
 		hdspm->qs_out_channels = AIO_OUT_QS_CHANNELS;
 
 		if (0 == (hdspm_read(hdspm, HDSPM_statusRegister2) & HDSPM_s2_AEBI_D)) {
-			snd_printk(KERN_INFO "HDSPM: AEB input board found\n");
+			dev_info(card->dev, "AEB input board found\n");
 			hdspm->ss_in_channels += 4;
 			hdspm->ds_in_channels += 4;
 			hdspm->qs_in_channels += 4;
 		}
 
 		if (0 == (hdspm_read(hdspm, HDSPM_statusRegister2) & HDSPM_s2_AEBO_D)) {
-			snd_printk(KERN_INFO "HDSPM: AEB output board found\n");
+			dev_info(card->dev, "AEB output board found\n");
 			hdspm->ss_out_channels += 4;
 			hdspm->ds_out_channels += 4;
 			hdspm->qs_out_channels += 4;
@@ -6854,7 +6867,7 @@ static int snd_hdspm_create(struct snd_card *card,
 			if (NULL != hdspm->tco) {
 				hdspm_tco_write(hdspm);
 			}
-			snd_printk(KERN_INFO "HDSPM: AIO/RayDAT TCO module found\n");
+			dev_info(card->dev, "AIO/RayDAT TCO module found\n");
 		} else {
 			hdspm->tco = NULL;
 		}
@@ -6869,7 +6882,7 @@ static int snd_hdspm_create(struct snd_card *card,
 			if (NULL != hdspm->tco) {
 				hdspm_tco_write(hdspm);
 			}
-			snd_printk(KERN_INFO "HDSPM: MADI/AES TCO module found\n");
+			dev_info(card->dev, "MADI/AES TCO module found\n");
 		} else {
 			hdspm->tco = NULL;
 		}
@@ -6951,7 +6964,7 @@ static int snd_hdspm_create(struct snd_card *card,
 		}
 	}
 
-	snd_printdd("create alsa devices.\n");
+	dev_dbg(card->dev, "create alsa devices.\n");
 	err = snd_hdspm_create_alsa_devices(card, hdspm);
 	if (err < 0)
 		return err;

commit 60c5772b50fe8ce947685cfe3a80b9bf6ea92831
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 29 14:20:19 2014 +0100

    ALSA: pci: Convert to snd_card_new() with a device pointer
    
    Also remove superfluous snd_card_set_dev() calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index e98dc008de0b..76016287e46f 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -7016,8 +7016,8 @@ static int snd_hdspm_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	err = snd_card_create(index[dev], id[dev],
-			THIS_MODULE, sizeof(struct hdspm), &card);
+	err = snd_card_new(&pci->dev, index[dev], id[dev],
+			   THIS_MODULE, sizeof(struct hdspm), &card);
 	if (err < 0)
 		return err;
 
@@ -7026,8 +7026,6 @@ static int snd_hdspm_probe(struct pci_dev *pci,
 	hdspm->dev = dev;
 	hdspm->pci = pci;
 
-	snd_card_set_dev(card, &pci->dev);
-
 	err = snd_hdspm_create(card, hdspm);
 	if (err < 0) {
 		snd_card_free(card);

commit 57a4451d26eef4ccbf3b32fd116295f001c18cb4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Oct 29 15:26:12 2013 +0100

    ALSA: Use strlcpy() instead of strncpy()
    
    We tend to make stupid mistakes with strncpy().  Let's take a safer
    one, strlcpy().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 2907e68150cb..e98dc008de0b 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6400,7 +6400,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 		memset(&hdspm_version, 0, sizeof(hdspm_version));
 
 		hdspm_version.card_type = hdspm->io_type;
-		strncpy(hdspm_version.cardname, hdspm->card_name,
+		strlcpy(hdspm_version.cardname, hdspm->card_name,
 				sizeof(hdspm_version.cardname));
 		hdspm_version.serial = hdspm->serial;
 		hdspm_version.firmware_rev = hdspm->firmware_rev;

commit bf69aa906ccddacc9e966794869431374953738a
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Fri Sep 13 16:18:59 2013 +0530

    ALSA: rme9652: Remove redundant break
    
    'break' after return statement is not necessary.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 3cde55b753e2..2907e68150cb 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3996,7 +3996,6 @@ static int hdspm_tco_sync_check(struct hdspm *hdspm)
 					return 1;
 			}
 			return 0;
-			break;
 		case AES32:
 			status = hdspm_read(hdspm, HDSPM_statusRegister);
 			if (status & HDSPM_tcoLockAes) {
@@ -4006,9 +4005,6 @@ static int hdspm_tco_sync_check(struct hdspm *hdspm)
 					return 1;
 			}
 			return 0;
-
-			break;
-
 		case RayDAT:
 		case AIO:
 			status = hdspm_read(hdspm, HDSPM_RD_STATUS_1);
@@ -4018,7 +4014,6 @@ static int hdspm_tco_sync_check(struct hdspm *hdspm)
 			if (status & 0x4000000)
 				return 1; /* Lock */
 			return 0; /* No signal */
-			break;
 
 		default:
 			break;

commit 1568b8802227f4e7b0ad79a49cd35d4e285570f2
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Aug 19 17:20:31 2013 +0200

    ALSA: hdspm - Use enums in hdspm_tco_ltc_frames()
    
    This patch doesn't change functionality, it only improves readability
    and fixes a copy&paste error in a comment.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index e4d76a6a7960..3cde55b753e2 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3173,19 +3173,19 @@ static int hdspm_tco_ltc_frames(struct hdspm *hdspm)
 					HDSPM_TCO1_LTC_Format_MSB)) {
 		case 0:
 			/* 24 fps */
-			ret = 1;
+			ret = fps_24;
 			break;
 		case HDSPM_TCO1_LTC_Format_LSB:
 			/* 25 fps */
-			ret = 2;
+			ret = fps_25;
 			break;
 		case HDSPM_TCO1_LTC_Format_MSB:
-			/* 25 fps */
-			ret = 3;
+			/* 29.97 fps */
+			ret = fps_2997;
 			break;
 		default:
 			/* 30 fps */
-			ret = 4;
+			ret = fps_30;
 			break;
 		}
 	}

commit 17d2f00836cce9b1a24e65670ad78dbab275777b
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Aug 19 17:20:30 2013 +0200

    ALSA: hdspm - Fix default value in SNDRV_HDSPM_IOCTL_GET_LTC
    
    Use enum hdspm_ltc_format's fps_30 (corresponds to 4) instead of 30,
    Other case branches return 1, 2 or 3 respectively, so 30 obviously is
    wrong.
    
    Since SNDRV_HDSPM_IOCTL_GET_LTC had never been working due to a
    copy&paste error in hdspm.h, this change doesn't break userspace.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index ec6335e2fda0..e4d76a6a7960 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6311,7 +6311,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 				ltc.format = fps_2997;
 				break;
 			default:
-				ltc.format = 30;
+				ltc.format = fps_30;
 				break;
 			}
 			if (i & HDSPM_TCO1_set_drop_frame_flag) {

commit 68593c9340847662ac1d337b3c5621a1f4ca05db
Author: Fengguang Wu <fengguang.wu@intel.com>
Date:   Mon Jul 15 21:41:32 2013 +0800

    ALSA: hdspm - remove unneeded semicolon
    
    sound/pci/rme9652/hdspm.c:1110:2-3: Unneeded semicolon
    
    Generated by: coccinelle/misc/semicolon.cocci
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index a3a71ac513f1..ec6335e2fda0 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1250,7 +1250,7 @@ static int hdspm_rate_multiplier(struct hdspm *hdspm, int rate)
 		else if (hdspm->control_register &
 				HDSPM_DoubleSpeed)
 			return rate * 2;
-	};
+	}
 	return rate;
 }
 

commit 69358fca4203eda93e008f234fabf603d9dba15e
Author: Martin Dausel <martin.dausel@iosono-sound.com>
Date:   Fri Jul 5 11:28:23 2013 +0200

    ALSA: hdspm - Added some comments and control register documentation
    
    Signed-off-by: Martin Dausel <martin.dausel@iosono-sound.com>
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 7a09b2de907b..a3a71ac513f1 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -38,6 +38,97 @@
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  *
  */
+
+/* *************    Register Documentation   *******************************************************
+ *
+ * Work in progress! Documentation is based on the code in this file.
+ *
+ * --------- HDSPM_controlRegister ---------
+ * :7654.3210:7654.3210:7654.3210:7654.3210: bit number per byte
+ * :||||.||||:||||.||||:||||.||||:||||.||||:
+ * :3322.2222:2222.1111:1111.1100:0000.0000: bit number
+ * :1098.7654:3210.9876:5432.1098:7654.3210: 0..31
+ * :||||.||||:||||.||||:||||.||||:||||.||||:
+ * :8421.8421:8421.8421:8421.8421:8421.8421: hex digit
+ * :    .    :    .    :    .    :  x .    :  HDSPM_AudioInterruptEnable \_ setting both bits
+ * :    .    :    .    :    .    :    .   x:  HDSPM_Start                /  enables audio IO
+ * :    .    :    .    :    .    :   x.    :  HDSPM_ClockModeMaster - 1: Master, 0: Slave
+ * :    .    :    .    :    .    :    .210 :  HDSPM_LatencyMask - 3 Bit value for latency
+ * :    .    :    .    :    .    :    .    :      0:64, 1:128, 2:256, 3:512,
+ * :    .    :    .    :    .    :    .    :      4:1024, 5:2048, 6:4096, 7:8192
+ * :x   .    :    .    :    .   x:xx  .    :  HDSPM_FrequencyMask
+ * :    .    :    .    :    .    :10  .    :  HDSPM_Frequency1|HDSPM_Frequency0: 1=32K,2=44.1K,3=48K,0=??
+ * :    .    :    .    :    .   x:    .    :  <MADI> HDSPM_DoubleSpeed
+ * :x   .    :    .    :    .    :    .    :  <MADI> HDSPM_QuadSpeed
+ * :    .  3 :    .  10:  2 .    :    .    :  HDSPM_SyncRefMask :
+ * :    .    :    .   x:    .    :    .    :  HDSPM_SyncRef0
+ * :    .    :    .  x :    .    :    .    :  HDSPM_SyncRef1
+ * :    .    :    .    :  x .    :    .    :  <AES32> HDSPM_SyncRef2
+ * :    .  x :    .    :    .    :    .    :  <AES32> HDSPM_SyncRef3
+ * :    .    :    .  10:    .    :    .    :  <MADI> sync ref: 0:WC, 1:Madi, 2:TCO, 3:SyncIn
+ * :    .  3 :    .  10:  2 .    :    .    :  <AES32>  0:WC, 1:AES1 ... 8:AES8, 9: TCO, 10:SyncIn?
+ * :    .  x :    .    :    .    :    .    :  <MADIe> HDSPe_FLOAT_FORMAT
+ * :    .    :    .    : x  .    :    .    :  <MADI> HDSPM_InputSelect0 : 0=optical,1=coax
+ * :    .    :    .    :x   .    :    .    :  <MADI> HDSPM_InputSelect1
+ * :    .    :    .x   :    .    :    .    :  <MADI> HDSPM_clr_tms
+ * :    .    :    .    :    . x  :    .    :  <MADI> HDSPM_TX_64ch
+ * :    .    :    .    :    . x  :    .    :  <AES32> HDSPM_Emphasis
+ * :    .    :    .    :    .x   :    .    :  <MADI> HDSPM_AutoInp
+ * :    .    :    . x  :    .    :    .    :  <MADI> HDSPM_SMUX
+ * :    .    :    .x   :    .    :    .    :  <MADI> HDSPM_clr_tms
+ * :    .    :   x.    :    .    :    .    :  <MADI> HDSPM_taxi_reset
+ * :    .   x:    .    :    .    :    .    :  <MADI> HDSPM_LineOut
+ * :    .   x:    .    :    .    :    .    :  <AES32> ??????????????????
+ * :    .    :   x.    :    .    :    .    :  <AES32> HDSPM_WCK48
+ * :    .    :    .    :    .x   :    .    :  <AES32> HDSPM_Dolby
+ * :    .    : x  .    :    .    :    .    :  HDSPM_Midi0InterruptEnable
+ * :    .    :x   .    :    .    :    .    :  HDSPM_Midi1InterruptEnable
+ * :    .    :  x .    :    .    :    .    :  HDSPM_Midi2InterruptEnable
+ * :    . x  :    .    :    .    :    .    :  <MADI> HDSPM_Midi3InterruptEnable
+ * :    . x  :    .    :    .    :    .    :  <AES32> HDSPM_DS_DoubleWire
+ * :    .x   :    .    :    .    :    .    :  <AES32> HDSPM_QS_DoubleWire
+ * :   x.    :    .    :    .    :    .    :  <AES32> HDSPM_QS_QuadWire
+ * :    .    :    .    :    .  x :    .    :  <AES32> HDSPM_Professional
+ * : x  .    :    .    :    .    :    .    :  HDSPM_wclk_sel
+ * :    .    :    .    :    .    :    .    :
+ * :7654.3210:7654.3210:7654.3210:7654.3210: bit number per byte
+ * :||||.||||:||||.||||:||||.||||:||||.||||:
+ * :3322.2222:2222.1111:1111.1100:0000.0000: bit number
+ * :1098.7654:3210.9876:5432.1098:7654.3210: 0..31
+ * :||||.||||:||||.||||:||||.||||:||||.||||:
+ * :8421.8421:8421.8421:8421.8421:8421.8421:hex digit
+ *
+ *
+ *
+ * AIO / RayDAT only
+ *
+ * ------------ HDSPM_WR_SETTINGS ----------
+ * :3322.2222:2222.1111:1111.1100:0000.0000: bit number per byte
+ * :1098.7654:3210.9876:5432.1098:7654.3210:
+ * :||||.||||:||||.||||:||||.||||:||||.||||: bit number
+ * :7654.3210:7654.3210:7654.3210:7654.3210: 0..31
+ * :||||.||||:||||.||||:||||.||||:||||.||||:
+ * :8421.8421:8421.8421:8421.8421:8421.8421: hex digit
+ * :    .    :    .    :    .    :    .   x: HDSPM_c0Master 1: Master, 0: Slave
+ * :    .    :    .    :    .    :    .  x : HDSPM_c0_SyncRef0
+ * :    .    :    .    :    .    :    . x  : HDSPM_c0_SyncRef1
+ * :    .    :    .    :    .    :    .x   : HDSPM_c0_SyncRef2
+ * :    .    :    .    :    .    :   x.    : HDSPM_c0_SyncRef3
+ * :    .    :    .    :    .    :   3.210 : HDSPM_c0_SyncRefMask:
+ * :    .    :    .    :    .    :    .    :  RayDat: 0:WC, 1:AES, 2:SPDIF, 3..6: ADAT1..4,
+ * :    .    :    .    :    .    :    .    :          9:TCO, 10:SyncIn
+ * :    .    :    .    :    .    :    .    :  AIO: 0:WC, 1:AES, 2: SPDIF, 3: ATAT,
+ * :    .    :    .    :    .    :    .    :          9:TCO, 10:SyncIn
+ * :    .    :    .    :    .    :    .    :
+ * :    .    :    .    :    .    :    .    :
+ * :3322.2222:2222.1111:1111.1100:0000.0000: bit number per byte
+ * :1098.7654:3210.9876:5432.1098:7654.3210:
+ * :||||.||||:||||.||||:||||.||||:||||.||||: bit number
+ * :7654.3210:7654.3210:7654.3210:7654.3210: 0..31
+ * :||||.||||:||||.||||:||||.||||:||||.||||:
+ * :8421.8421:8421.8421:8421.8421:8421.8421: hex digit
+ *
+ */
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
@@ -95,7 +186,7 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_controlRegister	     64
 #define HDSPM_interruptConfirmation  96
 #define HDSPM_control2Reg	     256  /* not in specs ???????? */
-#define HDSPM_freqReg                256  /* for AES32 */
+#define HDSPM_freqReg                256  /* for setting arbitrary clock values (DDS feature) */
 #define HDSPM_midiDataOut0	     352  /* just believe in old code */
 #define HDSPM_midiDataOut1	     356
 #define HDSPM_eeprom_wr		     384  /* for AES32 */
@@ -890,11 +981,11 @@ struct hdspm_midi {
 };
 
 struct hdspm_tco {
-	int input;
-	int framerate;
-	int wordclock;
-	int samplerate;
-	int pull;
+	int input; /* 0: LTC, 1:Video, 2: WC*/
+	int framerate; /* 0=24, 1=25, 2=29.97, 3=29.97d, 4=30, 5=30d */
+	int wordclock; /* 0=1:1, 1=44.1->48, 2=48->44.1 */
+	int samplerate; /* 0=44.1, 1=48, 2= freq from app */
+	int pull; /*   0=0, 1=+0.1%, 2=-0.1%, 3=+4%, 4=-4%*/
 	int term; /* 0 = off, 1 = on */
 };
 
@@ -913,7 +1004,7 @@ struct hdspm {
 
 	u32 control_register;	/* cached value */
 	u32 control2_register;	/* cached value */
-	u32 settings_register;
+	u32 settings_register;  /* cached value for AIO / RayDat (sync reference, master/slave) */
 
 	struct hdspm_midi midi[4];
 	struct tasklet_struct midi_tasklet;
@@ -4137,6 +4228,7 @@ static void hdspm_tco_write(struct hdspm *hdspm)
 static int snd_hdspm_info_tco_sample_rate(struct snd_kcontrol *kcontrol,
 					  struct snd_ctl_elem_info *uinfo)
 {
+	/* TODO freq from app could be supported here, see tco->samplerate */
 	static const char *const texts[] = { "44.1 kHz", "48 kHz" };
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;

commit 04659f9e9e6f2493d0e2dc52c72c4f20c22d9c61
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:22 2013 +0200

    ALSA: hdspm - Use snd_ctl_enum_info() in snd_hdspm_info_autosync_ref
    
    Also use snd_ctl_enum_info() to fill the autosync text fields on AES32
    and MADI cards (only users of snd_hdspm_info_autosync_ref).
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index ffd5d7c08a4b..7a09b2de907b 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2983,31 +2983,15 @@ static int snd_hdspm_info_autosync_ref(struct snd_kcontrol *kcontrol,
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	if (AES32 == hdspm->io_type) {
-		static char *texts[] = { "WordClock", "AES1", "AES2", "AES3",
+		static const char *const texts[] = { "WordClock", "AES1", "AES2", "AES3",
 			"AES4",	"AES5", "AES6", "AES7", "AES8", "TCO", "Sync In", "None"};
 
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-		uinfo->count = 1;
-		uinfo->value.enumerated.items = ARRAY_SIZE(texts);
-		if (uinfo->value.enumerated.item >=
-		    uinfo->value.enumerated.items)
-			uinfo->value.enumerated.item =
-				uinfo->value.enumerated.items - 1;
-		strcpy(uinfo->value.enumerated.name,
-				texts[uinfo->value.enumerated.item]);
+		ENUMERATED_CTL_INFO(uinfo, texts);
 	} else if (MADI == hdspm->io_type) {
-		static char *texts[] = {"Word Clock", "MADI", "TCO",
+		static const char *const texts[] = {"Word Clock", "MADI", "TCO",
 			"Sync In", "None" };
 
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-		uinfo->count = 1;
-		uinfo->value.enumerated.items = 5;
-		if (uinfo->value.enumerated.item >=
-				uinfo->value.enumerated.items)
-			uinfo->value.enumerated.item =
-				uinfo->value.enumerated.items - 1;
-		strcpy(uinfo->value.enumerated.name,
-				texts[uinfo->value.enumerated.item]);
+		ENUMERATED_CTL_INFO(uinfo, texts);
 	}
 	return 0;
 }

commit eb0d4dbf3d7f503f435022da46ef1495ca570d85
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:21 2013 +0200

    ALSA: hdspm - Use snd_ctl_enum_info() for texts_autosync
    
    Also use snd_ctl_enum_info() to fill the autosync enumerated controls.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 5a2eb644458e..ffd5d7c08a4b 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -558,36 +558,36 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 /* names for speed modes */
 static char *hdspm_speed_names[] = { "single", "double", "quad" };
 
-static char *texts_autosync_aes_tco[] = { "Word Clock",
+static const char *const texts_autosync_aes_tco[] = { "Word Clock",
 					  "AES1", "AES2", "AES3", "AES4",
 					  "AES5", "AES6", "AES7", "AES8",
 					  "TCO", "Sync In"
 };
-static char *texts_autosync_aes[] = { "Word Clock",
+static const char *const texts_autosync_aes[] = { "Word Clock",
 				      "AES1", "AES2", "AES3", "AES4",
 				      "AES5", "AES6", "AES7", "AES8",
 				      "Sync In"
 };
-static char *texts_autosync_madi_tco[] = { "Word Clock",
+static const char *const texts_autosync_madi_tco[] = { "Word Clock",
 					   "MADI", "TCO", "Sync In" };
-static char *texts_autosync_madi[] = { "Word Clock",
+static const char *const texts_autosync_madi[] = { "Word Clock",
 				       "MADI", "Sync In" };
 
-static char *texts_autosync_raydat_tco[] = {
+static const char *const texts_autosync_raydat_tco[] = {
 	"Word Clock",
 	"ADAT 1", "ADAT 2", "ADAT 3", "ADAT 4",
 	"AES", "SPDIF", "TCO", "Sync In"
 };
-static char *texts_autosync_raydat[] = {
+static const char *const texts_autosync_raydat[] = {
 	"Word Clock",
 	"ADAT 1", "ADAT 2", "ADAT 3", "ADAT 4",
 	"AES", "SPDIF", "Sync In"
 };
-static char *texts_autosync_aio_tco[] = {
+static const char *const texts_autosync_aio_tco[] = {
 	"Word Clock",
 	"ADAT", "AES", "SPDIF", "TCO", "Sync In"
 };
-static char *texts_autosync_aio[] = { "Word Clock",
+static const char *const texts_autosync_aio[] = { "Word Clock",
 				      "ADAT", "AES", "SPDIF", "Sync In" };
 
 static const char *const texts_freq[] = {
@@ -975,7 +975,7 @@ struct hdspm {
 
 	struct hdspm_tco *tco;  /* NULL if no TCO detected */
 
-	char **texts_autosync;
+	const char *const *texts_autosync;
 	int texts_autosync_items;
 
 	cycles_t last_interrupt;
@@ -2888,16 +2888,7 @@ static int snd_hdspm_info_pref_sync_ref(struct snd_kcontrol *kcontrol,
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = hdspm->texts_autosync_items;
-
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-			uinfo->value.enumerated.items - 1;
-
-	strcpy(uinfo->value.enumerated.name,
-			hdspm->texts_autosync[uinfo->value.enumerated.item]);
+	snd_ctl_enum_info(uinfo, 1, hdspm->texts_autosync_items, hdspm->texts_autosync);
 
 	return 0;
 }

commit 38816545a2cc6f436e5f9b26ebcb4cc2813eeb5c
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:20 2013 +0200

    ALSA: hdspm - Use snd_ctl_enum_info for most text arrays
    
    Use snd_ctl_enum_info() to fill most of the enumerated controls. More
    non-trivial occurrences will follow in separate commits.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 630316c108c0..5a2eb644458e 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -590,7 +590,7 @@ static char *texts_autosync_aio_tco[] = {
 static char *texts_autosync_aio[] = { "Word Clock",
 				      "ADAT", "AES", "SPDIF", "Sync In" };
 
-static char *texts_freq[] = {
+static const char *const texts_freq[] = {
 	"No Lock",
 	"32 kHz",
 	"44.1 kHz",
@@ -2286,21 +2286,8 @@ static int hdspm_get_s1_sample_rate(struct hdspm *hdspm, unsigned int idx)
 	return (status >> (idx*4)) & 0xF;
 }
 
-static void snd_hdspm_set_infotext(struct snd_ctl_elem_info *uinfo,
-		char **texts, const int count)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = count;
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-			uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name,
-			texts[uinfo->value.enumerated.item]);
-}
-
 #define ENUMERATED_CTL_INFO(info, texts) \
-	snd_hdspm_set_infotext(info, texts, ARRAY_SIZE(texts))
+	snd_ctl_enum_info(info, 1, ARRAY_SIZE(texts), texts)
 
 
 /* Helper function to query the external sample rate and return the
@@ -2477,7 +2464,7 @@ static void hdspm_set_system_clock_mode(struct hdspm *hdspm, int mode)
 static int snd_hdspm_info_system_clock_mode(struct snd_kcontrol *kcontrol,
 					    struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "Master", "AutoSync" };
+	static const char *const texts[] = { "Master", "AutoSync" };
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
@@ -3057,7 +3044,7 @@ static int snd_hdspm_get_autosync_ref(struct snd_kcontrol *kcontrol,
 static int snd_hdspm_info_tco_video_input_format(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = {"No video", "NTSC", "PAL"};
+	static const char *const texts[] = {"No video", "NTSC", "PAL"};
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
@@ -3103,7 +3090,7 @@ static int snd_hdspm_get_tco_video_input_format(struct snd_kcontrol *kcontrol,
 static int snd_hdspm_info_tco_ltc_frames(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = {"No lock", "24 fps", "25 fps", "29.97 fps",
+	static const char *const texts[] = {"No lock", "24 fps", "25 fps", "29.97 fps",
 				"30 fps"};
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
@@ -3253,7 +3240,7 @@ static int hdspm_set_input_select(struct hdspm * hdspm, int out)
 static int snd_hdspm_info_input_select(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "optical", "coaxial" };
+	static const char *const texts[] = { "optical", "coaxial" };
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
@@ -3315,7 +3302,7 @@ static int hdspm_set_ds_wire(struct hdspm * hdspm, int ds)
 static int snd_hdspm_info_ds_wire(struct snd_kcontrol *kcontrol,
 				  struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "Single", "Double" };
+	static const char *const texts[] = { "Single", "Double" };
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
@@ -3388,7 +3375,7 @@ static int hdspm_set_qs_wire(struct hdspm * hdspm, int mode)
 static int snd_hdspm_info_qs_wire(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "Single", "Double", "Quad" };
+	static const char *const texts[] = { "Single", "Double", "Quad" };
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
@@ -3454,8 +3441,8 @@ static int snd_hdspm_info_tristate(struct snd_kcontrol *kcontrol,
 {
 	u32 regmask = kcontrol->private_value;
 
-	static char *texts_spdif[] = { "Optical", "Coaxial", "Internal" };
-	static char *texts_levels[] = { "Hi Gain", "+4 dBu", "-10 dBV" };
+	static const char *const texts_spdif[] = { "Optical", "Coaxial", "Internal" };
+	static const char *const texts_levels[] = { "Hi Gain", "+4 dBu", "-10 dBV" };
 
 	switch (regmask) {
 	case HDSPM_c0_Input0:
@@ -3542,7 +3529,7 @@ static int hdspm_set_madi_speedmode(struct hdspm *hdspm, int mode)
 static int snd_hdspm_info_madi_speedmode(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "Single", "Double", "Quad" };
+	static const char *const texts[] = { "Single", "Double", "Quad" };
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
@@ -3777,7 +3764,7 @@ static int snd_hdspm_put_playback_mixer(struct snd_kcontrol *kcontrol,
 static int snd_hdspm_info_sync_check(struct snd_kcontrol *kcontrol,
 				     struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "No Lock", "Lock", "Sync", "N/A" };
+	static const char *const texts[] = { "No Lock", "Lock", "Sync", "N/A" };
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
@@ -3785,7 +3772,7 @@ static int snd_hdspm_info_sync_check(struct snd_kcontrol *kcontrol,
 static int snd_hdspm_tco_info_lock_check(struct snd_kcontrol *kcontrol,
 				     struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "No Lock", "Lock" };
+	static const char *const texts[] = { "No Lock", "Lock" };
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
@@ -4175,7 +4162,7 @@ static void hdspm_tco_write(struct hdspm *hdspm)
 static int snd_hdspm_info_tco_sample_rate(struct snd_kcontrol *kcontrol,
 					  struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "44.1 kHz", "48 kHz" };
+	static const char *const texts[] = { "44.1 kHz", "48 kHz" };
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
@@ -4221,7 +4208,8 @@ static int snd_hdspm_put_tco_sample_rate(struct snd_kcontrol *kcontrol,
 static int snd_hdspm_info_tco_pull(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "0", "+ 0.1 %", "- 0.1 %", "+ 4 %", "- 4 %" };
+	static const char *const texts[] = { "0", "+ 0.1 %", "- 0.1 %",
+		"+ 4 %", "- 4 %" };
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
@@ -4266,7 +4254,7 @@ static int snd_hdspm_put_tco_pull(struct snd_kcontrol *kcontrol,
 static int snd_hdspm_info_tco_wck_conversion(struct snd_kcontrol *kcontrol,
 					     struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "1:1", "44.1 -> 48", "48 -> 44.1" };
+	static const char *const texts[] = { "1:1", "44.1 -> 48", "48 -> 44.1" };
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
@@ -4312,7 +4300,7 @@ static int snd_hdspm_put_tco_wck_conversion(struct snd_kcontrol *kcontrol,
 static int snd_hdspm_info_tco_frame_rate(struct snd_kcontrol *kcontrol,
 					  struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "24 fps", "25 fps", "29.97fps",
+	static const char *const texts[] = { "24 fps", "25 fps", "29.97fps",
 		"29.97 dfps", "30 fps", "30 dfps" };
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
@@ -4359,7 +4347,7 @@ static int snd_hdspm_put_tco_frame_rate(struct snd_kcontrol *kcontrol,
 static int snd_hdspm_info_tco_sync_source(struct snd_kcontrol *kcontrol,
 					  struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "LTC", "Video", "WCK" };
+	static const char *const texts[] = { "LTC", "Video", "WCK" };
 	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }

commit 0dc831b9bca98a0d8dafb00fa7f20b3aef6cab67
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:19 2013 +0200

    ALSA: hdspm - AES32: Enable TCO support
    
    This patch finally enables TCO support on RME AES(32) cards.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 2f58e0721ea3..630316c108c0 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6811,6 +6811,7 @@ static int snd_hdspm_create(struct snd_card *card,
 		break;
 
 	case MADI:
+	case AES32:
 		if (hdspm_read(hdspm, HDSPM_statusRegister) & HDSPM_tco_detect) {
 			hdspm->midiPorts++;
 			hdspm->tco = kzalloc(sizeof(struct hdspm_tco),

commit 2d63ec38f5bb1f598baa003a964805c852a80b33
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:18 2013 +0200

    ALSA: hdspm - AES32: Report external sample rate to userspace
    
    This patch adds a new ALSA control to read the external sample rate from
    userspace on RME AES(32) cards.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 26f10fdbfcd6..2f58e0721ea3 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2401,10 +2401,15 @@ static int snd_hdspm_get_autosync_sample_rate(struct snd_kcontrol *kcontrol,
 			ucontrol->value.enumerated.item[0] =
 				hdspm_get_sync_in_sample_rate(hdspm);
 			break;
+		case 11: /* External Rate */
+			ucontrol->value.enumerated.item[0] =
+				hdspm_external_rate_to_enum(hdspm);
+			break;
 		default: /* AES1 to AES8 */
 			ucontrol->value.enumerated.item[0] =
-				hdspm_get_s1_sample_rate(hdspm,
-						kcontrol->private_value-1);
+				hdspm_get_aes_sample_rate(hdspm,
+						kcontrol->private_value -
+						HDSPM_AES32_AUTOSYNC_FROM_AES1);
 			break;
 		}
 		break;
@@ -4550,7 +4555,7 @@ static struct snd_kcontrol_new snd_hdspm_controls_aes32[] = {
 	HDSPM_PREF_SYNC_REF("Preferred Sync Reference", 0),
 	HDSPM_AUTOSYNC_REF("AutoSync Reference", 0),
 	HDSPM_SYSTEM_SAMPLE_RATE("System Sample Rate", 0),
-	HDSPM_AUTOSYNC_SAMPLE_RATE("External Rate", 0),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("External Rate", 11),
 	HDSPM_SYNC_CHECK("WC Sync Check", 0),
 	HDSPM_SYNC_CHECK("AES1 Sync Check", 1),
 	HDSPM_SYNC_CHECK("AES2 Sync Check", 2),

commit 2336142fc0470db2ac831225936b8e37b3ecb2bd
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:17 2013 +0200

    ALSA: hdspm - Introduce hdspm_external_rate_to_enum() helper function
    
    This patch refactors the code to query the external sample rate and its
    translation into the corresponding enum into a helper function to
    prevent future code duplication.
    
    A later commit will make use of this new helper function.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index f6e922cf3fd3..26f10fdbfcd6 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2303,6 +2303,21 @@ static void snd_hdspm_set_infotext(struct snd_ctl_elem_info *uinfo,
 	snd_hdspm_set_infotext(info, texts, ARRAY_SIZE(texts))
 
 
+/* Helper function to query the external sample rate and return the
+ * corresponding enum to be returned to userspace.
+ */
+static int hdspm_external_rate_to_enum(struct hdspm *hdspm)
+{
+	int rate = hdspm_external_sample_rate(hdspm);
+	int i, selected_rate = 0;
+	for (i = 1; i < 10; i++)
+		if (HDSPM_bit2freq(i) == rate) {
+			selected_rate = i;
+			break;
+		}
+	return selected_rate;
+}
+
 
 #define HDSPM_AUTOSYNC_SAMPLE_RATE(xname, xindex) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
@@ -2396,18 +2411,9 @@ static int snd_hdspm_get_autosync_sample_rate(struct snd_kcontrol *kcontrol,
 
 	case MADI:
 	case MADIface:
-		{
-			int rate = hdspm_external_sample_rate(hdspm);
-			int i, selected_rate = 0;
-			for (i = 1; i < 10; i++)
-				if (HDSPM_bit2freq(i) == rate) {
-					selected_rate = i;
-					break;
-				}
-			ucontrol->value.enumerated.item[0] = selected_rate;
-		}
+		ucontrol->value.enumerated.item[0] =
+			hdspm_external_rate_to_enum(hdspm);
 		break;
-
 	default:
 		break;
 	}

commit 194062daba00688dfd47caaf01f3131700cd726f
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:16 2013 +0200

    ALSA: hdspm - AES32: Include TCO and Sync-In in proc output
    
    Also report TCO status and Sync-In via /proc/ on AES(32) cards.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 73d96269c9b2..f6e922cf3fd3 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -5125,11 +5125,18 @@ snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
 		autosync_ref = "AES7"; break;
 	case HDSPM_AES32_AUTOSYNC_FROM_AES8:
 		autosync_ref = "AES8"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_TCO:
+		autosync_ref = "TCO"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_SYNC_IN:
+		autosync_ref = "Sync In"; break;
 	default:
 		autosync_ref = "---"; break;
 	}
 	snd_iprintf(buffer, "AutoSync ref = %s\n", autosync_ref);
 
+	/* call readout function for TCO specific status */
+	snd_hdspm_proc_read_tco(entry, buffer);
+
 	snd_iprintf(buffer, "\n");
 }
 

commit 2d60fc7f7d3d79e5646646bb34811961f19d111a
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:15 2013 +0200

    ALSA: hdspm - AES32: Enable TCO/Sync-In in snd_hdspm_put_sync_ref()
    
    This patch enables the user to select "TCO" and "Sync In" as a preferred
    sync reference on RME AES(32) cards.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 80b2247dc8f9..73d96269c9b2 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2954,19 +2954,20 @@ static int snd_hdspm_put_pref_sync_ref(struct snd_kcontrol *kcontrol,
 
 static int hdspm_autosync_ref(struct hdspm *hdspm)
 {
+	/* This looks at the autosync selected sync reference */
 	if (AES32 == hdspm->io_type) {
+
 		unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
-		unsigned int syncref =
-			(status >> HDSPM_AES32_syncref_bit) & 0xF;
-		if (syncref == 0)
-			return HDSPM_AES32_AUTOSYNC_FROM_WORD;
-		if (syncref <= 8)
+		unsigned int syncref = (status >> HDSPM_AES32_syncref_bit) & 0xF;
+		if ((syncref >= HDSPM_AES32_AUTOSYNC_FROM_WORD) &&
+				(syncref <= HDSPM_AES32_AUTOSYNC_FROM_SYNC_IN)) {
 			return syncref;
+		}
 		return HDSPM_AES32_AUTOSYNC_FROM_NONE;
+
 	} else if (MADI == hdspm->io_type) {
-		/* This looks at the autosync selected sync reference */
-		unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
 
+		unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
 		switch (status2 & HDSPM_SelSyncRefMask) {
 		case HDSPM_SelSyncRef_WORD:
 			return HDSPM_AUTOSYNC_FROM_WORD;

commit dbae4a0c8d8794df1a6bd7e644ed94b915f46f7e
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:14 2013 +0200

    ALSA: hdspm - AES32: Enable TCO input in hdspm_external_sample_rate()
    
    This patch adds support to read the TCO sample rate in
    hdspm_external_sample_rate() on RME AES(32) cards.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index a9f4c7c4b6f4..80b2247dc8f9 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1176,17 +1176,36 @@ static int hdspm_external_sample_rate(struct hdspm *hdspm)
 		timecode = hdspm_read(hdspm, HDSPM_timecodeRegister);
 
 		syncref = hdspm_autosync_ref(hdspm);
+		switch (syncref) {
+		case HDSPM_AES32_AUTOSYNC_FROM_WORD:
+		/* Check WC sync and get sample rate */
+			if (hdspm_wc_sync_check(hdspm))
+				return HDSPM_bit2freq(hdspm_get_wc_sample_rate(hdspm));
+			break;
+
+		case HDSPM_AES32_AUTOSYNC_FROM_AES1:
+		case HDSPM_AES32_AUTOSYNC_FROM_AES2:
+		case HDSPM_AES32_AUTOSYNC_FROM_AES3:
+		case HDSPM_AES32_AUTOSYNC_FROM_AES4:
+		case HDSPM_AES32_AUTOSYNC_FROM_AES5:
+		case HDSPM_AES32_AUTOSYNC_FROM_AES6:
+		case HDSPM_AES32_AUTOSYNC_FROM_AES7:
+		case HDSPM_AES32_AUTOSYNC_FROM_AES8:
+		/* Check AES sync and get sample rate */
+			if (hdspm_aes_sync_check(hdspm, syncref - HDSPM_AES32_AUTOSYNC_FROM_AES1))
+				return HDSPM_bit2freq(hdspm_get_aes_sample_rate(hdspm,
+							syncref - HDSPM_AES32_AUTOSYNC_FROM_AES1));
+			break;
 
-		if (syncref == HDSPM_AES32_AUTOSYNC_FROM_WORD &&
-				status & HDSPM_AES32_wcLock)
-			return HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit) & 0xF);
 
-		if (syncref >= HDSPM_AES32_AUTOSYNC_FROM_AES1 &&
-				syncref <= HDSPM_AES32_AUTOSYNC_FROM_AES8 &&
-				status2 & (HDSPM_LockAES >>
-				(syncref - HDSPM_AES32_AUTOSYNC_FROM_AES1)))
-			return HDSPM_bit2freq((timecode >> (4*(syncref-HDSPM_AES32_AUTOSYNC_FROM_AES1))) & 0xF);
-		return 0;
+		case HDSPM_AES32_AUTOSYNC_FROM_TCO:
+		/* Check TCO sync and get sample rate */
+			if (hdspm_tco_sync_check(hdspm))
+				return HDSPM_bit2freq(hdspm_get_tco_sample_rate(hdspm));
+			break;
+		default:
+			return 0;
+		} /* end switch(syncref) */
 		break;
 
 	case MADIface:

commit 3ac9b0acc34fbe56e2d31b8f2f7e59d45c53cb3b
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:13 2013 +0200

    ALSA: hdspm - AES32: Ignore float/int format bit
    
    As mentioned in the comment, the AES32 cards must not set the format
    bit, since it is used to indicate the preferred sync setting instead.
    
    We hence simply skip the corresponding part in the hw_params function.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index c0143cf83cf3..a9f4c7c4b6f4 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -5566,6 +5566,16 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 	   */
 
 
+	/*  For AES cards, the float format bit is the same as the
+	 *  preferred sync reference. Since we don't want to break
+	 *  sync settings, we have to skip the remaining part of this
+	 *  function.
+	 */
+	if (hdspm->io_type == AES32) {
+		return 0;
+	}
+
+
 	/* Switch to native float format if requested */
 	if (SNDRV_PCM_FORMAT_FLOAT_LE == params_format(params)) {
 		if (!(hdspm->control_register & HDSPe_FLOAT_FORMAT))

commit 051c44fec7e250a93d8f3b6704a3ce880a11bb0f
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:12 2013 +0200

    ALSA: hdspm - Enable AES32 in hdspm_get_tco_sample_rate
    
    This patch adds AES32 specific code to hdspm_get_tco_sample_rate to
    query the TCO sample rate.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index a69957cba0f4..c0143cf83cf3 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2204,6 +2204,9 @@ static int hdspm_get_tco_sample_rate(struct hdspm *hdspm)
 			status = hdspm_read(hdspm, HDSPM_RD_STATUS_1);
 			return (status >> 20) & 0xF;
 			break;
+		case AES32:
+			status = hdspm_read(hdspm, HDSPM_statusRegister);
+			return (status >> 1) & 0xF;
 		default:
 			break;
 		}

commit a57fea8ed44a2d32f8cbdd5455262aca88e72aa6
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:11 2013 +0200

    ALSA: hdspm - Enable AES32 in hdspm_get_wc_sample_rate
    
    This patch adds AES32 specific code to hdspm_get_wc_sample_rate() to
    query the wordclock frequency.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 367dd411247d..a69957cba0f4 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2178,6 +2178,9 @@ static int hdspm_get_wc_sample_rate(struct hdspm *hdspm)
 		status = hdspm_read(hdspm, HDSPM_RD_STATUS_1);
 		return (status >> 16) & 0xF;
 		break;
+	case AES32:
+		status = hdspm_read(hdspm, HDSPM_statusRegister);
+		return (status >> HDSPM_AES32_wcFreq_bit) & 0xF;
 	default:
 		break;
 	}

commit 5b266354b91087d8f1b1d1b6853a2c012f3e1518
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:10 2013 +0200

    ALSA: hdspm - Add prototype declarations
    
    This patch only introduces prototype declarations, no real change. The
    functions themselves are already present.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index b7702b225c3e..367dd411247d 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1017,6 +1017,17 @@ static void hdspm_set_sgbuf(struct hdspm *hdspm,
 			    struct snd_pcm_substream *substream,
 			     unsigned int reg, int channels);
 
+static int hdspm_aes_sync_check(struct hdspm *hdspm, int idx);
+static int hdspm_wc_sync_check(struct hdspm *hdspm);
+static int hdspm_tco_sync_check(struct hdspm *hdspm);
+static int hdspm_sync_in_sync_check(struct hdspm *hdspm);
+
+static int hdspm_get_aes_sample_rate(struct hdspm *hdspm, int index);
+static int hdspm_get_tco_sample_rate(struct hdspm *hdspm);
+static int hdspm_get_wc_sample_rate(struct hdspm *hdspm);
+
+
+
 static inline int HDSPM_bit2freq(int n)
 {
 	static const int bit2freq_tab[] = {
@@ -1152,10 +1163,7 @@ static int hdspm_rate_multiplier(struct hdspm *hdspm, int rate)
 	return rate;
 }
 
-static int hdspm_tco_sync_check(struct hdspm *hdspm);
-static int hdspm_sync_in_sync_check(struct hdspm *hdspm);
-
-/* check for external sample rate */
+/* check for external sample rate, returns the sample rate in Hz*/
 static int hdspm_external_sample_rate(struct hdspm *hdspm)
 {
 	unsigned int status, status2, timecode;

commit d3c36ed8e578185b752dac4277819965fa5f6879
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:09 2013 +0200

    ALSA: hdspm - Introduce hdspm_get_aes_sample_rate()
    
    Helper function to return the AES sample rate class. This class needs to
    be translated via HDSPM_bit2freq() to get the more common
    representation.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 8e6ce1473333..b7702b225c3e 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2224,6 +2224,23 @@ static int hdspm_get_sync_in_sample_rate(struct hdspm *hdspm)
 	return 0;
 }
 
+/**
+ * Returns the AES sample rate class for the given card.
+ **/
+static int hdspm_get_aes_sample_rate(struct hdspm *hdspm, int index)
+{
+	int timecode;
+
+	switch (hdspm->io_type) {
+	case AES32:
+		timecode = hdspm_read(hdspm, HDSPM_timecodeRegister);
+		return (timecode >> (4*index)) & 0xF;
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
 
 /**
  * Returns the sample rate class for input source <idx> for

commit db2d1a913d838ecfab5b903508bcdd4e4ad42419
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:08 2013 +0200

    ALSA: hdspm - AES32: Add TCO and Sync-In text entries
    
    Provide the text for the two new clock options "TCO" and "Sync In" on
    AES32 cards.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index d1e05828cee6..8e6ce1473333 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -561,10 +561,13 @@ static char *hdspm_speed_names[] = { "single", "double", "quad" };
 static char *texts_autosync_aes_tco[] = { "Word Clock",
 					  "AES1", "AES2", "AES3", "AES4",
 					  "AES5", "AES6", "AES7", "AES8",
-					  "TCO" };
+					  "TCO", "Sync In"
+};
 static char *texts_autosync_aes[] = { "Word Clock",
 				      "AES1", "AES2", "AES3", "AES4",
-				      "AES5", "AES6", "AES7", "AES8" };
+				      "AES5", "AES6", "AES7", "AES8",
+				      "Sync In"
+};
 static char *texts_autosync_madi_tco[] = { "Word Clock",
 					   "MADI", "TCO", "Sync In" };
 static char *texts_autosync_madi[] = { "Word Clock",
@@ -2941,11 +2944,11 @@ static int snd_hdspm_info_autosync_ref(struct snd_kcontrol *kcontrol,
 
 	if (AES32 == hdspm->io_type) {
 		static char *texts[] = { "WordClock", "AES1", "AES2", "AES3",
-			"AES4",	"AES5", "AES6", "AES7", "AES8", "None"};
+			"AES4",	"AES5", "AES6", "AES7", "AES8", "TCO", "Sync In", "None"};
 
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 		uinfo->count = 1;
-		uinfo->value.enumerated.items = 10;
+		uinfo->value.enumerated.items = ARRAY_SIZE(texts);
 		if (uinfo->value.enumerated.item >=
 		    uinfo->value.enumerated.items)
 			uinfo->value.enumerated.item =

commit 3c32de58ae9a3d534ba1a66274bf43631e36eb5c
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:07 2013 +0200

    ALSA: hdspm - AIO: Drop superfluous HDSPM_AUTOSYNC_REF
    
    The HDSPM_AUTOSYNC_REF macro is only implemented for MADI and AES32
    cards, so it doesn't make sense to call it on AIO boards.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index d95100e7bd22..d1e05828cee6 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4419,7 +4419,6 @@ static struct snd_kcontrol_new snd_hdspm_controls_aio[] = {
 	HDSPM_INTERNAL_CLOCK("Internal Clock", 0),
 	HDSPM_SYSTEM_CLOCK_MODE("System Clock Mode", 0),
 	HDSPM_PREF_SYNC_REF("Preferred Sync Reference", 0),
-	HDSPM_AUTOSYNC_REF("AutoSync Reference", 0),
 	HDSPM_SYSTEM_SAMPLE_RATE("System Sample Rate", 0),
 	HDSPM_AUTOSYNC_SAMPLE_RATE("External Rate", 0),
 	HDSPM_SYNC_CHECK("WC SyncCheck", 0),

commit e71b95ad71e3ee44ec634e242b186e3ff03bd459
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:06 2013 +0200

    ALSA: hdspm - Cosmetics, no real change
    
    This patch does nothing, it's sole intent is to clean up the code.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index bdd8c7742a1f..d95100e7bd22 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2926,7 +2926,7 @@ static int hdspm_autosync_ref(struct hdspm *hdspm)
 		case HDSPM_SelSyncRef_NVALID:
 			return HDSPM_AUTOSYNC_FROM_NONE;
 		default:
-			return 0;
+			return HDSPM_AUTOSYNC_FROM_NONE;
 		}
 
 	}
@@ -5260,7 +5260,7 @@ static int snd_hdspm_set_defaults(struct hdspm * hdspm)
 
 	case AES32:
 		hdspm->control_register =
-			HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
+			HDSPM_ClockModeMaster |	/* Master Clock Mode on */
 			hdspm_encode_latency(7) | /* latency max=8192samples */
 			HDSPM_SyncRef0 |	/* AES1 is syncclock */
 			HDSPM_LineOut |	/* Analog output in */
@@ -6737,7 +6737,7 @@ static int snd_hdspm_create(struct snd_card *card,
 			if (NULL != hdspm->tco) {
 				hdspm_tco_write(hdspm);
 			}
-			snd_printk(KERN_INFO "HDSPM: MADI TCO module found\n");
+			snd_printk(KERN_INFO "HDSPM: MADI/AES TCO module found\n");
 		} else {
 			hdspm->tco = NULL;
 		}
@@ -6752,10 +6752,12 @@ static int snd_hdspm_create(struct snd_card *card,
 	case AES32:
 		if (hdspm->tco) {
 			hdspm->texts_autosync = texts_autosync_aes_tco;
-			hdspm->texts_autosync_items = 10;
+			hdspm->texts_autosync_items =
+				ARRAY_SIZE(texts_autosync_aes_tco);
 		} else {
 			hdspm->texts_autosync = texts_autosync_aes;
-			hdspm->texts_autosync_items = 9;
+			hdspm->texts_autosync_items =
+				ARRAY_SIZE(texts_autosync_aes);
 		}
 		break;
 

commit b0bf550476a5a6238baf1309ba913ca9f7a379ba
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:05 2013 +0200

    ALSA: hdspm - AES32: Fix TCO sync check reporting
    
    HDSPM_tco_lock and HDSPM_tcoLock were too close, so the previous code
    didn't honour the difference between the two.
    
    Let's be more verbose and use HDSPM_tcoLockMadi for MADI cards,
    HDSPM_tcoLockAes for AES(32) and fix the code that makes use of both.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 58b21048c2e8..bdd8c7742a1f 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -360,11 +360,11 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_madiLock           (1<<3)	/* MADI Locked =1, no=0 */
 #define HDSPM_madiSync          (1<<18) /* MADI is in sync */
 
-#define HDSPM_tcoLock    0x00000020 /* Optional TCO locked status FOR HDSPe MADI! */
-#define HDSPM_tcoSync    0x10000000 /* Optional TCO sync status */
+#define HDSPM_tcoLockMadi    0x00000020 /* Optional TCO locked status for HDSPe MADI*/
+#define HDSPM_tcoSync    0x10000000 /* Optional TCO sync status for HDSPe MADI and AES32!*/
 
-#define HDSPM_syncInLock 0x00010000 /* Sync In lock status FOR HDSPe MADI! */
-#define HDSPM_syncInSync 0x00020000 /* Sync In sync status FOR HDSPe MADI! */
+#define HDSPM_syncInLock 0x00010000 /* Sync In lock status for HDSPe MADI! */
+#define HDSPM_syncInSync 0x00020000 /* Sync In sync status for HDSPe MADI! */
 
 #define HDSPM_BufferPositionMask 0x000FFC0 /* Bit 6..15 : h/w buffer pointer */
 			/* since 64byte accurate, last 6 bits are not used */
@@ -382,7 +382,7 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 					 * Interrupt
 					 */
 #define HDSPM_tco_detect         0x08000000
-#define HDSPM_tco_lock	         0x20000000
+#define HDSPM_tcoLockAes         0x20000000 /* Optional TCO locked status for HDSPe AES */
 
 #define HDSPM_s2_tco_detect      0x00000040
 #define HDSPM_s2_AEBO_D          0x00000080
@@ -480,7 +480,9 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_AES32_AUTOSYNC_FROM_AES6 6
 #define HDSPM_AES32_AUTOSYNC_FROM_AES7 7
 #define HDSPM_AES32_AUTOSYNC_FROM_AES8 8
-#define HDSPM_AES32_AUTOSYNC_FROM_NONE 9
+#define HDSPM_AES32_AUTOSYNC_FROM_TCO 9
+#define HDSPM_AES32_AUTOSYNC_FROM_SYNC_IN 10
+#define HDSPM_AES32_AUTOSYNC_FROM_NONE 11
 
 /*  status2 */
 /* HDSPM_LockAES_bit is given by HDSPM_LockAES >> (AES# - 1) */
@@ -3868,9 +3870,18 @@ static int hdspm_tco_sync_check(struct hdspm *hdspm)
 	if (hdspm->tco) {
 		switch (hdspm->io_type) {
 		case MADI:
+			status = hdspm_read(hdspm, HDSPM_statusRegister);
+			if (status & HDSPM_tcoLockMadi) {
+				if (status & HDSPM_tcoSync)
+					return 2;
+				else
+					return 1;
+			}
+			return 0;
+			break;
 		case AES32:
 			status = hdspm_read(hdspm, HDSPM_statusRegister);
-			if (status & HDSPM_tcoLock) {
+			if (status & HDSPM_tcoLockAes) {
 				if (status & HDSPM_tcoSync)
 					return 2;
 				else

commit 5760107c8263cf518968ece65453b7d9b8ca3d0a
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:04 2013 +0200

    ALSA: hdspm - Create TCO readout function
    
    This patch separates the TCO bits from snd_hdspm_proc_read_madi(), so
    the new function can later be shared between MADI and AES32 cards.
    
    It's essentially only moving code around, no new functionality.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 06e69de0801e..58b21048c2e8 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4636,77 +4636,22 @@ static int snd_hdspm_create_controls(struct snd_card *card,
  ------------------------------------------------------------*/
 
 static void
-snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
-			 struct snd_info_buffer *buffer)
+snd_hdspm_proc_read_tco(struct snd_info_entry *entry,
+					struct snd_info_buffer *buffer)
 {
 	struct hdspm *hdspm = entry->private_data;
-	unsigned int status, status2, control, freq;
-
-	char *pref_sync_ref;
-	char *autosync_ref;
-	char *system_clock_mode;
-	char *insel;
-	int x, x2;
-
-	/* TCO stuff */
+	unsigned int status, control;
 	int a, ltc, frames, seconds, minutes, hours;
 	unsigned int period;
 	u64 freq_const = 0;
 	u32 rate;
 
+	snd_iprintf(buffer, "--- TCO ---\n");
+
 	status = hdspm_read(hdspm, HDSPM_statusRegister);
-	status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
 	control = hdspm->control_register;
-	freq = hdspm_read(hdspm, HDSPM_timecodeRegister);
-
-	snd_iprintf(buffer, "%s (Card #%d) Rev.%x Status2first3bits: %x\n",
-			hdspm->card_name, hdspm->card->number + 1,
-			hdspm->firmware_rev,
-			(status2 & HDSPM_version0) |
-			(status2 & HDSPM_version1) | (status2 &
-				HDSPM_version2));
-
-	snd_iprintf(buffer, "HW Serial: 0x%06x%06x\n",
-			(hdspm_read(hdspm, HDSPM_midiStatusIn1)>>8) & 0xFFFFFF,
-			hdspm->serial);
-
-	snd_iprintf(buffer, "IRQ: %d Registers bus: 0x%lx VM: 0x%lx\n",
-			hdspm->irq, hdspm->port, (unsigned long)hdspm->iobase);
-
-	snd_iprintf(buffer, "--- System ---\n");
 
-	snd_iprintf(buffer,
-		"IRQ Pending: Audio=%d, MIDI0=%d, MIDI1=%d, IRQcount=%d\n",
-		status & HDSPM_audioIRQPending,
-		(status & HDSPM_midi0IRQPending) ? 1 : 0,
-		(status & HDSPM_midi1IRQPending) ? 1 : 0,
-		hdspm->irq_count);
-	snd_iprintf(buffer,
-		"HW pointer: id = %d, rawptr = %d (%d->%d) "
-		"estimated= %ld (bytes)\n",
-		((status & HDSPM_BufferID) ? 1 : 0),
-		(status & HDSPM_BufferPositionMask),
-		(status & HDSPM_BufferPositionMask) %
-		(2 * (int)hdspm->period_bytes),
-		((status & HDSPM_BufferPositionMask) - 64) %
-		(2 * (int)hdspm->period_bytes),
-		(long) hdspm_hw_pointer(hdspm) * 4);
 
-	snd_iprintf(buffer,
-		"MIDI FIFO: Out1=0x%x, Out2=0x%x, In1=0x%x, In2=0x%x \n",
-		hdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xFF,
-		hdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xFF,
-		hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,
-		hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);
-	snd_iprintf(buffer,
-		"MIDIoverMADI FIFO: In=0x%x, Out=0x%x \n",
-		hdspm_read(hdspm, HDSPM_midiStatusIn2) & 0xFF,
-		hdspm_read(hdspm, HDSPM_midiStatusOut2) & 0xFF);
-	snd_iprintf(buffer,
-		"Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, "
-		"status2=0x%x\n",
-		hdspm->control_register, hdspm->control2_register,
-		status, status2);
 	if (status & HDSPM_tco_detect) {
 		snd_iprintf(buffer, "TCO module detected.\n");
 		a = hdspm_read(hdspm, HDSPM_RD_TCO+4);
@@ -4800,6 +4745,75 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 	} else {
 		snd_iprintf(buffer, "No TCO module detected.\n");
 	}
+}
+
+static void
+snd_hdspm_proc_read_madi(struct snd_info_entry *entry,
+			 struct snd_info_buffer *buffer)
+{
+	struct hdspm *hdspm = entry->private_data;
+	unsigned int status, status2, control, freq;
+
+	char *pref_sync_ref;
+	char *autosync_ref;
+	char *system_clock_mode;
+	char *insel;
+	int x, x2;
+
+	status = hdspm_read(hdspm, HDSPM_statusRegister);
+	status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+	control = hdspm->control_register;
+	freq = hdspm_read(hdspm, HDSPM_timecodeRegister);
+
+	snd_iprintf(buffer, "%s (Card #%d) Rev.%x Status2first3bits: %x\n",
+			hdspm->card_name, hdspm->card->number + 1,
+			hdspm->firmware_rev,
+			(status2 & HDSPM_version0) |
+			(status2 & HDSPM_version1) | (status2 &
+				HDSPM_version2));
+
+	snd_iprintf(buffer, "HW Serial: 0x%06x%06x\n",
+			(hdspm_read(hdspm, HDSPM_midiStatusIn1)>>8) & 0xFFFFFF,
+			hdspm->serial);
+
+	snd_iprintf(buffer, "IRQ: %d Registers bus: 0x%lx VM: 0x%lx\n",
+			hdspm->irq, hdspm->port, (unsigned long)hdspm->iobase);
+
+	snd_iprintf(buffer, "--- System ---\n");
+
+	snd_iprintf(buffer,
+		"IRQ Pending: Audio=%d, MIDI0=%d, MIDI1=%d, IRQcount=%d\n",
+		status & HDSPM_audioIRQPending,
+		(status & HDSPM_midi0IRQPending) ? 1 : 0,
+		(status & HDSPM_midi1IRQPending) ? 1 : 0,
+		hdspm->irq_count);
+	snd_iprintf(buffer,
+		"HW pointer: id = %d, rawptr = %d (%d->%d) "
+		"estimated= %ld (bytes)\n",
+		((status & HDSPM_BufferID) ? 1 : 0),
+		(status & HDSPM_BufferPositionMask),
+		(status & HDSPM_BufferPositionMask) %
+		(2 * (int)hdspm->period_bytes),
+		((status & HDSPM_BufferPositionMask) - 64) %
+		(2 * (int)hdspm->period_bytes),
+		(long) hdspm_hw_pointer(hdspm) * 4);
+
+	snd_iprintf(buffer,
+		"MIDI FIFO: Out1=0x%x, Out2=0x%x, In1=0x%x, In2=0x%x \n",
+		hdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xFF,
+		hdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xFF,
+		hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,
+		hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);
+	snd_iprintf(buffer,
+		"MIDIoverMADI FIFO: In=0x%x, Out=0x%x \n",
+		hdspm_read(hdspm, HDSPM_midiStatusIn2) & 0xFF,
+		hdspm_read(hdspm, HDSPM_midiStatusOut2) & 0xFF);
+	snd_iprintf(buffer,
+		"Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, "
+		"status2=0x%x\n",
+		hdspm->control_register, hdspm->control2_register,
+		status, status2);
+
 
 	snd_iprintf(buffer, "--- Settings ---\n");
 
@@ -4903,6 +4917,9 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 		(status & HDSPM_RX_64ch) ? "64 channels" :
 		"56 channels");
 
+	/* call readout function for TCO specific status */
+	snd_hdspm_proc_read_tco(entry, buffer);
+
 	snd_iprintf(buffer, "\n");
 }
 

commit 1cb7dbf489f9985b7a117e34d00f20799adb138a
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:03 2013 +0200

    ALSA: hdspm - Fix S/PDIF Sync status and frequency on RME AIO
    
    This is a left-over mistake from old code, the correct register offset is
    provided in kcontrol->private_value, not in the index.
    Cf. RayDAT case, where it has already been corrected.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index ad416365dc68..06e69de0801e 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2312,7 +2312,7 @@ static int snd_hdspm_get_autosync_sample_rate(struct snd_kcontrol *kcontrol,
 		default:
 			ucontrol->value.enumerated.item[0] =
 				hdspm_get_s1_sample_rate(hdspm,
-						ucontrol->id.index-1);
+						kcontrol->private_value-1);
 		}
 		break;
 
@@ -3930,7 +3930,8 @@ static int snd_hdspm_get_sync_check(struct snd_kcontrol *kcontrol,
 		case 5: /* SYNC IN */
 			val = hdspm_sync_in_sync_check(hdspm); break;
 		default:
-			val = hdspm_s1_sync_check(hdspm, ucontrol->id.index-1);
+			val = hdspm_s1_sync_check(hdspm,
+					kcontrol->private_value-1);
 		}
 		break;
 

commit 3de9db264cef4bc984f928e08cccf36304f30d0a
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:02 2013 +0200

    ALSA: hdspm - Add support for AEBs on RME AIO
    
    AIO cards allow to use AEB (Analogue Expansion Boards) to add four
    input and/or output channels.
    
    This patch adds the necessary code to detect and enable the additional
    I/O channels.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 778fc23105fa..ad416365dc68 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -648,7 +648,8 @@ static char *texts_ports_aio_in_ss[] = {
 	"AES.L", "AES.R",
 	"SPDIF.L", "SPDIF.R",
 	"ADAT.1", "ADAT.2", "ADAT.3", "ADAT.4", "ADAT.5", "ADAT.6",
-	"ADAT.7", "ADAT.8"
+	"ADAT.7", "ADAT.8",
+	"AEB.1", "AEB.2", "AEB.3", "AEB.4"
 };
 
 static char *texts_ports_aio_out_ss[] = {
@@ -657,14 +658,16 @@ static char *texts_ports_aio_out_ss[] = {
 	"SPDIF.L", "SPDIF.R",
 	"ADAT.1", "ADAT.2", "ADAT.3", "ADAT.4", "ADAT.5", "ADAT.6",
 	"ADAT.7", "ADAT.8",
-	"Phone.L", "Phone.R"
+	"Phone.L", "Phone.R",
+	"AEB.1", "AEB.2", "AEB.3", "AEB.4"
 };
 
 static char *texts_ports_aio_in_ds[] = {
 	"Analogue.L", "Analogue.R",
 	"AES.L", "AES.R",
 	"SPDIF.L", "SPDIF.R",
-	"ADAT.1", "ADAT.2", "ADAT.3", "ADAT.4"
+	"ADAT.1", "ADAT.2", "ADAT.3", "ADAT.4",
+	"AEB.1", "AEB.2", "AEB.3", "AEB.4"
 };
 
 static char *texts_ports_aio_out_ds[] = {
@@ -672,14 +675,16 @@ static char *texts_ports_aio_out_ds[] = {
 	"AES.L", "AES.R",
 	"SPDIF.L", "SPDIF.R",
 	"ADAT.1", "ADAT.2", "ADAT.3", "ADAT.4",
-	"Phone.L", "Phone.R"
+	"Phone.L", "Phone.R",
+	"AEB.1", "AEB.2", "AEB.3", "AEB.4"
 };
 
 static char *texts_ports_aio_in_qs[] = {
 	"Analogue.L", "Analogue.R",
 	"AES.L", "AES.R",
 	"SPDIF.L", "SPDIF.R",
-	"ADAT.1", "ADAT.2", "ADAT.3", "ADAT.4"
+	"ADAT.1", "ADAT.2", "ADAT.3", "ADAT.4",
+	"AEB.1", "AEB.2", "AEB.3", "AEB.4"
 };
 
 static char *texts_ports_aio_out_qs[] = {
@@ -687,7 +692,8 @@ static char *texts_ports_aio_out_qs[] = {
 	"AES.L", "AES.R",
 	"SPDIF.L", "SPDIF.R",
 	"ADAT.1", "ADAT.2", "ADAT.3", "ADAT.4",
-	"Phone.L", "Phone.R"
+	"Phone.L", "Phone.R",
+	"AEB.1", "AEB.2", "AEB.3", "AEB.4"
 };
 
 static char *texts_ports_aes32[] = {
@@ -764,8 +770,8 @@ static char channel_map_aio_in_ss[HDSPM_MAX_CHANNELS] = {
 	8, 9,			/* aes in, */
 	10, 11,			/* spdif in */
 	12, 13, 14, 15, 16, 17, 18, 19,	/* ADAT in */
-	-1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1,
+	2, 3, 4, 5,		/* AEB */
+	-1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
@@ -779,7 +785,8 @@ static char channel_map_aio_out_ss[HDSPM_MAX_CHANNELS] = {
 	10, 11,			/* spdif out */
 	12, 13, 14, 15, 16, 17, 18, 19,	/* ADAT out */
 	6, 7,			/* phone out */
-	-1, -1, -1, -1, -1, -1, -1, -1,
+	2, 3, 4, 5,		/* AEB */
+	-1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
@@ -792,7 +799,8 @@ static char channel_map_aio_in_ds[HDSPM_MAX_CHANNELS] = {
 	8, 9,			/* aes in */
 	10, 11,			/* spdif in */
 	12, 14, 16, 18,		/* adat in */
-	-1, -1, -1, -1, -1, -1,
+	2, 3, 4, 5,		/* AEB */
+	-1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
@@ -807,7 +815,7 @@ static char channel_map_aio_out_ds[HDSPM_MAX_CHANNELS] = {
 	10, 11,			/* spdif out */
 	12, 14, 16, 18,		/* adat out */
 	6, 7,			/* phone out */
-	-1, -1, -1, -1,
+	2, 3, 4, 5,		/* AEB */
 	-1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
@@ -821,7 +829,8 @@ static char channel_map_aio_in_qs[HDSPM_MAX_CHANNELS] = {
 	8, 9,			/* aes in */
 	10, 11,			/* spdif in */
 	12, 16,			/* adat in */
-	-1, -1, -1, -1, -1, -1, -1, -1,
+	2, 3, 4, 5,		/* AEB */
+	-1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
@@ -836,7 +845,8 @@ static char channel_map_aio_out_qs[HDSPM_MAX_CHANNELS] = {
 	10, 11,			/* spdif out */
 	12, 16,			/* adat out */
 	6, 7,			/* phone out */
-	-1, -1, -1, -1, -1, -1,
+	2, 3, 4, 5,		/* AEB */
+	-1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
@@ -6602,10 +6612,6 @@ static int snd_hdspm_create(struct snd_card *card,
 		break;
 
 	case AIO:
-		if (0 == (hdspm_read(hdspm, HDSPM_statusRegister2) & HDSPM_s2_AEBI_D)) {
-			snd_printk(KERN_INFO "HDSPM: AEB input board found, but not supported\n");
-		}
-
 		hdspm->ss_in_channels = AIO_IN_SS_CHANNELS;
 		hdspm->ds_in_channels = AIO_IN_DS_CHANNELS;
 		hdspm->qs_in_channels = AIO_IN_QS_CHANNELS;
@@ -6613,6 +6619,20 @@ static int snd_hdspm_create(struct snd_card *card,
 		hdspm->ds_out_channels = AIO_OUT_DS_CHANNELS;
 		hdspm->qs_out_channels = AIO_OUT_QS_CHANNELS;
 
+		if (0 == (hdspm_read(hdspm, HDSPM_statusRegister2) & HDSPM_s2_AEBI_D)) {
+			snd_printk(KERN_INFO "HDSPM: AEB input board found\n");
+			hdspm->ss_in_channels += 4;
+			hdspm->ds_in_channels += 4;
+			hdspm->qs_in_channels += 4;
+		}
+
+		if (0 == (hdspm_read(hdspm, HDSPM_statusRegister2) & HDSPM_s2_AEBO_D)) {
+			snd_printk(KERN_INFO "HDSPM: AEB output board found\n");
+			hdspm->ss_out_channels += 4;
+			hdspm->ds_out_channels += 4;
+			hdspm->qs_out_channels += 4;
+		}
+
 		hdspm->channel_map_out_ss = channel_map_aio_out_ss;
 		hdspm->channel_map_out_ds = channel_map_aio_out_ds;
 		hdspm->channel_map_out_qs = channel_map_aio_out_qs;

commit 42f4c12dcf46cbca8b7bb17610c0cb7ffbd7ab2e
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:01 2013 +0200

    ALSA: hdspm - Enable AD/DA/PH gains and S/PDIF-Input select on AIO
    
    This patch uses the newly introduced HDSPM_CONTROL_TRISTATE functions to
    create and expose the following ALSA controls:
    
       - Gain selection for Input, Output and Phones (HiGain, +4dBu, -10dbV)
       - S/PDIF Input select (Coaxial, Optical, Internal)
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index d9532c42e2ce..778fc23105fa 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4412,11 +4412,15 @@ static struct snd_kcontrol_new snd_hdspm_controls_aio[] = {
 	HDSPM_AUTOSYNC_SAMPLE_RATE("ADAT Frequency", 3),
 	HDSPM_AUTOSYNC_SAMPLE_RATE("TCO Frequency", 4),
 	HDSPM_AUTOSYNC_SAMPLE_RATE("SYNC IN Frequency", 5),
+	HDSPM_CONTROL_TRISTATE("S/PDIF Input", HDSPM_c0_Input0),
 	HDSPM_TOGGLE_SETTING("S/PDIF Out Optical", HDSPM_c0_Spdif_Opt),
 	HDSPM_TOGGLE_SETTING("S/PDIF Out Professional", HDSPM_c0_Pro),
 	HDSPM_TOGGLE_SETTING("ADAT internal (AEB/TEB)", HDSPM_c0_AEB1),
 	HDSPM_TOGGLE_SETTING("XLR Breakout Cable", HDSPM_c0_Sym6db),
-	HDSPM_TOGGLE_SETTING("Single Speed WordClock Out", HDSPM_c0_Wck48)
+	HDSPM_TOGGLE_SETTING("Single Speed WordClock Out", HDSPM_c0_Wck48),
+	HDSPM_CONTROL_TRISTATE("Input Level", HDSPM_c0_AD_GAIN0),
+	HDSPM_CONTROL_TRISTATE("Output Level", HDSPM_c0_DA_GAIN0),
+	HDSPM_CONTROL_TRISTATE("Phones Level", HDSPM_c0_PH_GAIN0)
 
 		/*
 		   HDSPM_INPUT_SELECT("Input Select", 0),

commit acf14767e17ab7ee8b6213f9e56d07d9ffa033da
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:28:00 2013 +0200

    ALSA: hdspm - Introduce generic AIO tristate control
    
    AIO cards offer at least four individual settings options with three
    states each. Those settings are represented as two bits in the settings
    register with the following meaning:
    
       0*some_base_bit --> Option value 0
       1*some_base_bit --> Option value 1
       2*some_base_bit --> Option value 2
       3*some_base_bit --> mask to select the two involved bits
    
    This patch adds a generic ALSA control macro for such a value-to-bit
    pattern mapping. It will be used in a later commit to expose four new
    controls.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index b271853e2e52..d9532c42e2ce 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3348,6 +3348,84 @@ static int snd_hdspm_put_qs_wire(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
+#define HDSPM_CONTROL_TRISTATE(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.private_value = xindex, \
+	.info = snd_hdspm_info_tristate, \
+	.get = snd_hdspm_get_tristate, \
+	.put = snd_hdspm_put_tristate \
+}
+
+static int hdspm_tristate(struct hdspm *hdspm, u32 regmask)
+{
+	u32 reg = hdspm->settings_register & (regmask * 3);
+	return reg / regmask;
+}
+
+static int hdspm_set_tristate(struct hdspm *hdspm, int mode, u32 regmask)
+{
+	hdspm->settings_register &= ~(regmask * 3);
+	hdspm->settings_register |= (regmask * mode);
+	hdspm_write(hdspm, HDSPM_WR_SETTINGS, hdspm->settings_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_tristate(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_info *uinfo)
+{
+	u32 regmask = kcontrol->private_value;
+
+	static char *texts_spdif[] = { "Optical", "Coaxial", "Internal" };
+	static char *texts_levels[] = { "Hi Gain", "+4 dBu", "-10 dBV" };
+
+	switch (regmask) {
+	case HDSPM_c0_Input0:
+		ENUMERATED_CTL_INFO(uinfo, texts_spdif);
+		break;
+	default:
+		ENUMERATED_CTL_INFO(uinfo, texts_levels);
+		break;
+	}
+	return 0;
+}
+
+static int snd_hdspm_get_tristate(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	u32 regmask = kcontrol->private_value;
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.enumerated.item[0] = hdspm_tristate(hdspm, regmask);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_tristate(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	u32 regmask = kcontrol->private_value;
+	int change;
+	int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0];
+	if (val < 0)
+		val = 0;
+	if (val > 2)
+		val = 2;
+
+	spin_lock_irq(&hdspm->lock);
+	change = val != hdspm_tristate(hdspm, regmask);
+	hdspm_set_tristate(hdspm, val, regmask);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
 #define HDSPM_MADI_SPEEDMODE(xname, xindex) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
 	.name = xname, \

commit 8cea57104273909ab0825df48149840aad9d2b14
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:27:59 2013 +0200

    ALSA: hdspm - Refactor ENUMERATED_CTL_INFO into function
    
    ENUMERATED_CTL_INFO is a macro, so the binary code is generated multiple
    times. To avoid code duplication, refactor the involved functionality
    into a function and make ENUMERATED_CTL_INFO a call to this function.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 15f1e7b37c9f..b271853e2e52 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2221,16 +2221,22 @@ static int hdspm_get_s1_sample_rate(struct hdspm *hdspm, unsigned int idx)
 	return (status >> (idx*4)) & 0xF;
 }
 
-#define ENUMERATED_CTL_INFO(info, texts) \
-{ \
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED; \
-	uinfo->count = 1; \
-	uinfo->value.enumerated.items = ARRAY_SIZE(texts); \
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items) \
-		uinfo->value.enumerated.item =	uinfo->value.enumerated.items - 1; \
-	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]); \
+static void snd_hdspm_set_infotext(struct snd_ctl_elem_info *uinfo,
+		char **texts, const int count)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = count;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+			uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+			texts[uinfo->value.enumerated.item]);
 }
 
+#define ENUMERATED_CTL_INFO(info, texts) \
+	snd_hdspm_set_infotext(info, texts, ARRAY_SIZE(texts))
+
 
 
 #define HDSPM_AUTOSYNC_SAMPLE_RATE(xname, xindex) \

commit fb0f121e0f346bec45810a9439e936ae62fd2441
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:27:58 2013 +0200

    ALSA: hdspm - Add S/PDIF, XLR, WCK48 and ADAT-in controls for RME AIO cards
    
    This commit adds the following ALSA controls:
    
       - S/PDIF Out Optical to switch S/PDIF Out from coaxial to optical
       - S/PDIF Out Professional to send the Pro bit in the output stream
       - ADAT-Internal to enable ADAT/TDIF Expansion Board (AEB/TEB)
       - XLR Breakout Cable if analogue I/O uses the XLR breakout cable
       - WCK48 to force WordClock to the 32-48kHz range (single speed) if
         the card is operating at higher frequencies
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 4a3a82249153..15f1e7b37c9f 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4327,7 +4327,12 @@ static struct snd_kcontrol_new snd_hdspm_controls_aio[] = {
 	HDSPM_AUTOSYNC_SAMPLE_RATE("SPDIF Frequency", 2),
 	HDSPM_AUTOSYNC_SAMPLE_RATE("ADAT Frequency", 3),
 	HDSPM_AUTOSYNC_SAMPLE_RATE("TCO Frequency", 4),
-	HDSPM_AUTOSYNC_SAMPLE_RATE("SYNC IN Frequency", 5)
+	HDSPM_AUTOSYNC_SAMPLE_RATE("SYNC IN Frequency", 5),
+	HDSPM_TOGGLE_SETTING("S/PDIF Out Optical", HDSPM_c0_Spdif_Opt),
+	HDSPM_TOGGLE_SETTING("S/PDIF Out Professional", HDSPM_c0_Pro),
+	HDSPM_TOGGLE_SETTING("ADAT internal (AEB/TEB)", HDSPM_c0_AEB1),
+	HDSPM_TOGGLE_SETTING("XLR Breakout Cable", HDSPM_c0_Sym6db),
+	HDSPM_TOGGLE_SETTING("Single Speed WordClock Out", HDSPM_c0_Wck48)
 
 		/*
 		   HDSPM_INPUT_SELECT("Input Select", 0),

commit 11a5cd3c950ee27b165b5c170e588dff22cadeca
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:27:57 2013 +0200

    ALSA: hdspm - Add S/PDIF and WCK48 controls for RME RayDAT
    
    This commit adds new ALSA controls to send single-speed WordClock and
    S/PDIF-Professional on RME RayDAT cards.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 631c54601013..4a3a82249153 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4364,7 +4364,9 @@ static struct snd_kcontrol_new snd_hdspm_controls_raydat[] = {
 	HDSPM_AUTOSYNC_SAMPLE_RATE("ADAT3 Frequency", 5),
 	HDSPM_AUTOSYNC_SAMPLE_RATE("ADAT4 Frequency", 6),
 	HDSPM_AUTOSYNC_SAMPLE_RATE("TCO Frequency", 7),
-	HDSPM_AUTOSYNC_SAMPLE_RATE("SYNC IN Frequency", 8)
+	HDSPM_AUTOSYNC_SAMPLE_RATE("SYNC IN Frequency", 8),
+	HDSPM_TOGGLE_SETTING("S/PDIF Out Professional", HDSPM_c0_Pro),
+	HDSPM_TOGGLE_SETTING("Single Speed WordClock Out", HDSPM_c0_Wck48)
 };
 
 static struct snd_kcontrol_new snd_hdspm_controls_aes32[] = {

commit 34be7ebbb4488818a2c413290b7b5835173fe44d
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:27:56 2013 +0200

    ALSA: hdspm - Drop duplicate code in hdspm_set_system_clock_mode()
    
    hdspm_set_system_clock_mode() is almost a one-by-one copy of
    hdspm_set_toggle_setting(). To improve code quality, remove the
    duplication.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 118d727150e7..631c54601013 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -995,6 +995,7 @@ static inline void snd_hdspm_initialize_midi_flush(struct hdspm *hdspm);
 static inline int hdspm_get_pll_freq(struct hdspm *hdspm);
 static int hdspm_update_simple_mixer_controls(struct hdspm *hdspm);
 static int hdspm_autosync_ref(struct hdspm *hdspm);
+static int hdspm_set_toggle_setting(struct hdspm *hdspm, u32 regmask, int out);
 static int snd_hdspm_set_defaults(struct hdspm *hdspm);
 static int hdspm_system_clock_mode(struct hdspm *hdspm);
 static void hdspm_set_sgbuf(struct hdspm *hdspm,
@@ -2384,26 +2385,10 @@ static int hdspm_system_clock_mode(struct hdspm *hdspm)
  **/
 static void hdspm_set_system_clock_mode(struct hdspm *hdspm, int mode)
 {
-	switch (hdspm->io_type) {
-	case AIO:
-	case RayDAT:
-		if (0 == mode)
-			hdspm->settings_register |= HDSPM_c0Master;
-		else
-			hdspm->settings_register &= ~HDSPM_c0Master;
-
-		hdspm_write(hdspm, HDSPM_WR_SETTINGS, hdspm->settings_register);
-		break;
-
-	default:
-		if (0 == mode)
-			hdspm->control_register |= HDSPM_ClockModeMaster;
-		else
-			hdspm->control_register &= ~HDSPM_ClockModeMaster;
-
-		hdspm_write(hdspm, HDSPM_controlRegister,
-				hdspm->control_register);
-	}
+	hdspm_set_toggle_setting(hdspm,
+			(hdspm_is_raydat_or_aio(hdspm)) ?
+			HDSPM_c0Master : HDSPM_ClockModeMaster,
+			(0 == mode));
 }
 
 

commit ce13f3f33a32895da9304a9f9cb865f337dd0933
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:27:55 2013 +0200

    ALSA: hdspm - Augment HDSPM_TOGGLE_SETTING for AIO/RayDAT
    
    The HDSPM_TOGGLE_SETTING functions alter the control_register on older
    cards. On newer cards (AIO/RayDAT), they have to operate on the
    settings_register instead.
    
    This patch augments the existing functions to work with AIO/RayDAT, too.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 32a87dcecfa3..118d727150e7 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3092,16 +3092,35 @@ static int snd_hdspm_get_tco_ltc_frames(struct snd_kcontrol *kcontrol,
 
 static int hdspm_toggle_setting(struct hdspm *hdspm, u32 regmask)
 {
-	return (hdspm->control_register & regmask) ? 1 : 0;
+	u32 reg;
+
+	if (hdspm_is_raydat_or_aio(hdspm))
+		reg = hdspm->settings_register;
+	else
+		reg = hdspm->control_register;
+
+	return (reg & regmask) ? 1 : 0;
 }
 
 static int hdspm_set_toggle_setting(struct hdspm *hdspm, u32 regmask, int out)
 {
+	u32 *reg;
+	u32 target_reg;
+
+	if (hdspm_is_raydat_or_aio(hdspm)) {
+		reg = &(hdspm->settings_register);
+		target_reg = HDSPM_WR_SETTINGS;
+	} else {
+		reg = &(hdspm->control_register);
+		target_reg = HDSPM_controlRegister;
+	}
+
 	if (out)
-		hdspm->control_register |= regmask;
+		*reg |= regmask;
 	else
-		hdspm->control_register &= ~regmask;
-	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+		*reg &= ~regmask;
+
+	hdspm_write(hdspm, target_reg, *reg);
 
 	return 0;
 }

commit b2ed6326874b1bf5410871d83df4086a395ab13b
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:27:54 2013 +0200

    ALSA: hdspm - Introduce hdspm_is_raydat_or_aio()
    
    RME RayDAT and AIO cards are new designs with different register
    settings. Since we need to distinguish them from older cards multiple
    times in the driver, refactor the code into a separate helper function.
    
    No functional change intended.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index a0fc961bc347..32a87dcecfa3 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1011,6 +1011,12 @@ static inline int HDSPM_bit2freq(int n)
 	return bit2freq_tab[n];
 }
 
+static bool hdspm_is_raydat_or_aio(struct hdspm *hdspm)
+{
+	return ((AIO == hdspm->io_type) || (RayDAT == hdspm->io_type));
+}
+
+
 /* Write/read to/from HDSPM with Adresses in Bytes
    not words but only 32Bit writes are allowed */
 
@@ -5142,9 +5148,8 @@ static int snd_hdspm_set_defaults(struct hdspm * hdspm)
 
 	all_in_all_mixer(hdspm, 0 * UNITY_GAIN);
 
-	if (hdspm->io_type == AIO || hdspm->io_type == RayDAT) {
+	if (hdspm_is_raydat_or_aio(hdspm))
 		hdspm_write(hdspm, HDSPM_WR_SETTINGS, hdspm->settings_register);
-	}
 
 	/* set a default rate so that the channel map is set up. */
 	hdspm_set_rate(hdspm, 48000, 1);

commit 384f778fd924cc843acf93c23f52cb168cb3f02a
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 5 11:27:53 2013 +0200

    ALSA: hdspm - Add missing defines for RME AIO and RayDAT
    
    The driver did not support all possible configurations. These defines
    will be used by later commits to add the missing functionality.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index bd501931ee23..a0fc961bc347 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -258,6 +258,25 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 
 #define HDSPM_wclk_sel (1<<30)
 
+/* additional control register bits for AIO*/
+#define HDSPM_c0_Wck48				0x20 /* also RayDAT */
+#define HDSPM_c0_Input0				0x1000
+#define HDSPM_c0_Input1				0x2000
+#define HDSPM_c0_Spdif_Opt			0x4000
+#define HDSPM_c0_Pro				0x8000
+#define HDSPM_c0_clr_tms			0x10000
+#define HDSPM_c0_AEB1				0x20000
+#define HDSPM_c0_AEB2				0x40000
+#define HDSPM_c0_LineOut			0x80000
+#define HDSPM_c0_AD_GAIN0			0x100000
+#define HDSPM_c0_AD_GAIN1			0x200000
+#define HDSPM_c0_DA_GAIN0			0x400000
+#define HDSPM_c0_DA_GAIN1			0x800000
+#define HDSPM_c0_PH_GAIN0			0x1000000
+#define HDSPM_c0_PH_GAIN1			0x2000000
+#define HDSPM_c0_Sym6db				0x4000000
+
+
 /* --- bit helper defines */
 #define HDSPM_LatencyMask    (HDSPM_Latency0|HDSPM_Latency1|HDSPM_Latency2)
 #define HDSPM_FrequencyMask  (HDSPM_Frequency0|HDSPM_Frequency1|\

commit 7b5593976c2cae886afb920885580e300ebb01ca
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri May 31 12:57:11 2013 +0200

    ALSA: hdspm - Allow SingleSpeed WordClock when in DS/QS mode
    
    Similarly to MADI, WordClock can also be at SingleSpeed while the card
    is actually working at twice or four times this rate. If so, multiply
    the base rate accordingly.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 8eb2070fd258..bd501931ee23 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1225,7 +1225,7 @@ static int hdspm_external_sample_rate(struct hdspm *hdspm)
 		 */
 		if (rate != 0 &&
 		(status2 & HDSPM_SelSyncRefMask) == HDSPM_SelSyncRef_WORD)
-			return rate;
+			return hdspm_rate_multiplier(hdspm, rate);
 
 		/* maybe a madi input (which is taken if sel sync is madi) */
 		if (status & HDSPM_madiLock) {

commit a8a729fa06164889da4cacaecebe48370329716b
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri May 31 12:57:10 2013 +0200

    ALSA: hdspm - Refactor SS/DS/QS clock multiplier into function
    
    When the DoubleSpeed or QuadSpeed bit is set, the SingleSpeed frequency
    has to be multiplied accordingly. Since this functionality will be
    required at least twice, refactor it into a separate function.
    
    The second reference to the newly introduced hdspm_rate_multiplier()
    will be in a separate commit.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index e070ea85c30a..8eb2070fd258 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1091,6 +1091,26 @@ static int hdspm_round_frequency(int rate)
 		return 48000;
 }
 
+/* QS and DS rates normally can not be detected
+ * automatically by the card. Only exception is MADI
+ * in 96k frame mode.
+ *
+ * So if we read SS values (32 .. 48k), check for
+ * user-provided DS/QS bits in the control register
+ * and multiply the base frequency accordingly.
+ */
+static int hdspm_rate_multiplier(struct hdspm *hdspm, int rate)
+{
+	if (rate <= 48000) {
+		if (hdspm->control_register & HDSPM_QuadSpeed)
+			return rate * 4;
+		else if (hdspm->control_register &
+				HDSPM_DoubleSpeed)
+			return rate * 2;
+	};
+	return rate;
+}
+
 static int hdspm_tco_sync_check(struct hdspm *hdspm);
 static int hdspm_sync_in_sync_check(struct hdspm *hdspm);
 
@@ -1268,21 +1288,8 @@ static int hdspm_external_sample_rate(struct hdspm *hdspm)
 			}
 		}
 
-		/* QS and DS rates normally can not be detected
-		 * automatically by the card. Only exception is MADI
-		 * in 96k frame mode.
-		 *
-		 * So if we read SS values (32 .. 48k), check for
-		 * user-provided DS/QS bits in the control register
-		 * and multiply the base frequency accordingly.
-		 */
-		if (rate <= 48000) {
-			if (hdspm->control_register & HDSPM_QuadSpeed)
-				rate *= 4;
-			else if (hdspm->control_register &
-					HDSPM_DoubleSpeed)
-				rate *= 2;
-		}
+		rate = hdspm_rate_multiplier(hdspm, rate);
+
 		break;
 	}
 

commit a8cd7148045bd6a14adb15985dda806d17e9cab2
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri May 31 12:57:09 2013 +0200

    ALSA: hdspm - Add support for 128-192kHz WordClock input
    
    Allow WordClock input rates of 128, 176.4 and 192kHz.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index ef3cbc044f0c..e070ea85c30a 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -400,8 +400,8 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 
 #define HDSPM_wc_freq0 (1<<5)	/* input freq detected via autosync  */
 #define HDSPM_wc_freq1 (1<<6)	/* 001=32, 010==44.1, 011=48, */
-#define HDSPM_wc_freq2 (1<<7)	/* 100=64, 101=88.2, 110=96, */
-/* missing Bit   for               111=128, 1000=176.4, 1001=192 */
+#define HDSPM_wc_freq2 (1<<7)	/* 100=64, 101=88.2, 110=96, 111=128 */
+#define HDSPM_wc_freq3 0x800	/* 1000=176.4, 1001=192 */
 
 #define HDSPM_SyncRef0 0x10000  /* Sync Reference */
 #define HDSPM_SyncRef1 0x20000
@@ -412,13 +412,17 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 
 #define HDSPM_wc_valid (HDSPM_wcLock|HDSPM_wcSync)
 
-#define HDSPM_wcFreqMask  (HDSPM_wc_freq0|HDSPM_wc_freq1|HDSPM_wc_freq2)
+#define HDSPM_wcFreqMask  (HDSPM_wc_freq0|HDSPM_wc_freq1|HDSPM_wc_freq2|\
+			    HDSPM_wc_freq3)
 #define HDSPM_wcFreq32    (HDSPM_wc_freq0)
 #define HDSPM_wcFreq44_1  (HDSPM_wc_freq1)
 #define HDSPM_wcFreq48    (HDSPM_wc_freq0|HDSPM_wc_freq1)
 #define HDSPM_wcFreq64    (HDSPM_wc_freq2)
 #define HDSPM_wcFreq88_2  (HDSPM_wc_freq0|HDSPM_wc_freq2)
 #define HDSPM_wcFreq96    (HDSPM_wc_freq1|HDSPM_wc_freq2)
+#define HDSPM_wcFreq128   (HDSPM_wc_freq0|HDSPM_wc_freq1|HDSPM_wc_freq2)
+#define HDSPM_wcFreq176_4 (HDSPM_wc_freq3)
+#define HDSPM_wcFreq192   (HDSPM_wc_freq0|HDSPM_wc_freq3)
 
 #define HDSPM_status1_F_0 0x0400000
 #define HDSPM_status1_F_1 0x0800000
@@ -1181,6 +1185,15 @@ static int hdspm_external_sample_rate(struct hdspm *hdspm)
 			case HDSPM_wcFreq96:
 				rate = 96000;
 				break;
+			case HDSPM_wcFreq128:
+				rate = 128000;
+				break;
+			case HDSPM_wcFreq176_4:
+				rate = 176400;
+				break;
+			case HDSPM_wcFreq192:
+				rate = 192000;
+				break;
 			default:
 				rate = 0;
 				break;

commit 20a24225d8f94fc56f74a9068684869d6deebea5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed May 29 12:37:32 2013 +0200

    ALSA: PCI: Remove superfluous pci_set_drvdata(pci, NULL) at remove
    
    As drvdata is cleared to NULL at probe failure or at removal by the
    driver core, we don't have to call pci_set_drvdata(pci, NULL) any
    longer in each driver.
    
    The only remaining pci_set_drvdata(NULL) is in azx_firmware_cb() in
    hda_intel.c.  Since this function itself releases the card instance,
    we need to clear drvdata here as well, so that it won't be released
    doubly in the remove callback.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 9ea05e956474..ef3cbc044f0c 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6737,7 +6737,6 @@ static int snd_hdspm_probe(struct pci_dev *pci,
 static void snd_hdspm_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
-	pci_set_drvdata(pci, NULL);
 }
 
 static struct pci_driver hdspm_driver = {

commit a817650ebb451ef27db2baa7e10d0c28609bed13
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Sun Mar 10 00:37:27 2013 +0100

    ALSA: hdspm - Enable new TCO ALSA controls
    
    Expose the newly added TCO LTC and sync check functions to userspace.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index e23572dd0e46..9ea05e956474 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4366,7 +4366,11 @@ static struct snd_kcontrol_new snd_hdspm_controls_tco[] = {
 	HDSPM_TCO_WCK_CONVERSION("TCO WCK Conversion", 0),
 	HDSPM_TCO_FRAME_RATE("TCO Frame Rate", 0),
 	HDSPM_TCO_SYNC_SOURCE("TCO Sync Source", 0),
-	HDSPM_TCO_WORD_TERM("TCO Word Term", 0)
+	HDSPM_TCO_WORD_TERM("TCO Word Term", 0),
+	HDSPM_TCO_LOCK_CHECK("TCO Input Check", 11),
+	HDSPM_TCO_LOCK_CHECK("TCO LTC Valid", 12),
+	HDSPM_TCO_LTC_FRAMES("TCO Detected Frame Rate", 0),
+	HDSPM_TCO_VIDEO_INPUT_FORMAT("Video Input Format", 0)
 };
 
 

commit f99c78812fcc38a32f9f1694cf75dd7f7e329ae7
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Sun Mar 10 00:37:26 2013 +0100

    ALSA: hdspm - Add ALSA controls to read the TCO LTC state
    
    This patch adds new ALSA controls to query the LTC state from userspace.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 8b7c9fb901c7..e23572dd0e46 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2930,6 +2930,112 @@ static int snd_hdspm_get_autosync_ref(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+
+
+#define HDSPM_TCO_VIDEO_INPUT_FORMAT(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READ |\
+		SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_info_tco_video_input_format, \
+	.get = snd_hdspm_get_tco_video_input_format, \
+}
+
+static int snd_hdspm_info_tco_video_input_format(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_info *uinfo)
+{
+	static char *texts[] = {"No video", "NTSC", "PAL"};
+	ENUMERATED_CTL_INFO(uinfo, texts);
+	return 0;
+}
+
+static int snd_hdspm_get_tco_video_input_format(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	u32 status;
+	int ret = 0;
+
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	status = hdspm_read(hdspm, HDSPM_RD_TCO + 4);
+	switch (status & (HDSPM_TCO1_Video_Input_Format_NTSC |
+			HDSPM_TCO1_Video_Input_Format_PAL)) {
+	case HDSPM_TCO1_Video_Input_Format_NTSC:
+		/* ntsc */
+		ret = 1;
+		break;
+	case HDSPM_TCO1_Video_Input_Format_PAL:
+		/* pal */
+		ret = 2;
+		break;
+	default:
+		/* no video */
+		ret = 0;
+		break;
+	}
+	ucontrol->value.enumerated.item[0] = ret;
+	return 0;
+}
+
+
+
+#define HDSPM_TCO_LTC_FRAMES(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READ |\
+		SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_info_tco_ltc_frames, \
+	.get = snd_hdspm_get_tco_ltc_frames, \
+}
+
+static int snd_hdspm_info_tco_ltc_frames(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_info *uinfo)
+{
+	static char *texts[] = {"No lock", "24 fps", "25 fps", "29.97 fps",
+				"30 fps"};
+	ENUMERATED_CTL_INFO(uinfo, texts);
+	return 0;
+}
+
+static int hdspm_tco_ltc_frames(struct hdspm *hdspm)
+{
+	u32 status;
+	int ret = 0;
+
+	status = hdspm_read(hdspm, HDSPM_RD_TCO + 4);
+	if (status & HDSPM_TCO1_LTC_Input_valid) {
+		switch (status & (HDSPM_TCO1_LTC_Format_LSB |
+					HDSPM_TCO1_LTC_Format_MSB)) {
+		case 0:
+			/* 24 fps */
+			ret = 1;
+			break;
+		case HDSPM_TCO1_LTC_Format_LSB:
+			/* 25 fps */
+			ret = 2;
+			break;
+		case HDSPM_TCO1_LTC_Format_MSB:
+			/* 25 fps */
+			ret = 3;
+			break;
+		default:
+			/* 30 fps */
+			ret = 4;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int snd_hdspm_get_tco_ltc_frames(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm_tco_ltc_frames(hdspm);
+	return 0;
+}
+
 #define HDSPM_TOGGLE_SETTING(xname, xindex) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
 	.name = xname, \

commit 345422133ae07147aa695a469bfec8f97d77a81c
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Sun Mar 10 00:37:25 2013 +0100

    ALSA: hdspm - Also check for TCO sync states
    
    This patch prepares snd_hdspm_get_sync_check() to also check the TCO
    sync state. The added feature will be exposed to the user in a later
    commit.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 82f209f283aa..8b7c9fb901c7 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3447,6 +3447,16 @@ static int snd_hdspm_put_playback_mixer(struct snd_kcontrol *kcontrol,
 	.get = snd_hdspm_get_sync_check \
 }
 
+#define HDSPM_TCO_LOCK_CHECK(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.private_value = xindex, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_tco_info_lock_check, \
+	.get = snd_hdspm_get_sync_check \
+}
+
+
 
 static int snd_hdspm_info_sync_check(struct snd_kcontrol *kcontrol,
 				     struct snd_ctl_elem_info *uinfo)
@@ -3456,6 +3466,14 @@ static int snd_hdspm_info_sync_check(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+static int snd_hdspm_tco_info_lock_check(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_info *uinfo)
+{
+	static char *texts[] = { "No Lock", "Lock" };
+	ENUMERATED_CTL_INFO(uinfo, texts);
+	return 0;
+}
+
 static int hdspm_wc_sync_check(struct hdspm *hdspm)
 {
 	int status, status2;
@@ -3585,6 +3603,14 @@ static int hdspm_aes_sync_check(struct hdspm *hdspm, int idx)
 	return 0;
 }
 
+static int hdspm_tco_input_check(struct hdspm *hdspm, u32 mask)
+{
+	u32 status;
+	status = hdspm_read(hdspm, HDSPM_RD_TCO + 4);
+
+	return (status & mask) ? 1 : 0;
+}
+
 
 static int hdspm_tco_sync_check(struct hdspm *hdspm)
 {
@@ -3692,6 +3718,22 @@ static int snd_hdspm_get_sync_check(struct snd_kcontrol *kcontrol,
 
 	}
 
+	if (hdspm->tco) {
+		switch (kcontrol->private_value) {
+		case 11:
+			/* Check TCO for lock state of its current input */
+			val = hdspm_tco_input_check(hdspm, HDSPM_TCO1_TCO_lock);
+			break;
+		case 12:
+			/* Check TCO for valid time code on LTC input. */
+			val = hdspm_tco_input_check(hdspm,
+				HDSPM_TCO1_LTC_Input_valid);
+			break;
+		default:
+			break;
+		}
+	}
+
 	if (-1 == val)
 		val = 3;
 

commit e5b7b1fe3b263441a1fc89bc6a4cca5e80f348b0
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Sun Mar 10 00:37:24 2013 +0100

    ALSA: hdspm - Remove duplicate code from ALSA controls
    
    Considerably shorten the code by using a macro. Though this won't lower
    the binary size, it makes the source more readable.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index c03ee011bfb6..82f209f283aa 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2175,6 +2175,16 @@ static int hdspm_get_s1_sample_rate(struct hdspm *hdspm, unsigned int idx)
 	return (status >> (idx*4)) & 0xF;
 }
 
+#define ENUMERATED_CTL_INFO(info, texts) \
+{ \
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED; \
+	uinfo->count = 1; \
+	uinfo->value.enumerated.items = ARRAY_SIZE(texts); \
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items) \
+		uinfo->value.enumerated.item =	uinfo->value.enumerated.items - 1; \
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]); \
+}
+
 
 
 #define HDSPM_AUTOSYNC_SAMPLE_RATE(xname, xindex) \
@@ -2190,14 +2200,7 @@ static int hdspm_get_s1_sample_rate(struct hdspm *hdspm, unsigned int idx)
 static int snd_hdspm_info_autosync_sample_rate(struct snd_kcontrol *kcontrol,
 					       struct snd_ctl_elem_info *uinfo)
 {
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 10;
-
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name,
-			texts_freq[uinfo->value.enumerated.item]);
+	ENUMERATED_CTL_INFO(uinfo, texts_freq);
 	return 0;
 }
 
@@ -2363,15 +2366,7 @@ static int snd_hdspm_info_system_clock_mode(struct snd_kcontrol *kcontrol,
 					    struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "Master", "AutoSync" };
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 2;
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-		    uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
+	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
 
@@ -3021,17 +3016,7 @@ static int snd_hdspm_info_input_select(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "optical", "coaxial" };
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 2;
-
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-		    uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
-
+	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
 
@@ -3093,17 +3078,7 @@ static int snd_hdspm_info_ds_wire(struct snd_kcontrol *kcontrol,
 				  struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "Single", "Double" };
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 2;
-
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-		    uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
-
+	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
 
@@ -3176,17 +3151,7 @@ static int snd_hdspm_info_qs_wire(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "Single", "Double", "Quad" };
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 3;
-
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-		    uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
-
+	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
 
@@ -3262,17 +3227,7 @@ static int snd_hdspm_info_madi_speedmode(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "Single", "Double", "Quad" };
-
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 3;
-
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-		    uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
-
+	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
 
@@ -3497,14 +3452,7 @@ static int snd_hdspm_info_sync_check(struct snd_kcontrol *kcontrol,
 				     struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "No Lock", "Lock", "Sync", "N/A" };
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 4;
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-			uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name,
-			texts[uinfo->value.enumerated.item]);
+	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
 
@@ -3860,17 +3808,7 @@ static int snd_hdspm_info_tco_sample_rate(struct snd_kcontrol *kcontrol,
 					  struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "44.1 kHz", "48 kHz" };
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 2;
-
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-			uinfo->value.enumerated.items - 1;
-
-	strcpy(uinfo->value.enumerated.name,
-			texts[uinfo->value.enumerated.item]);
-
+	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
 
@@ -3916,17 +3854,7 @@ static int snd_hdspm_info_tco_pull(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "0", "+ 0.1 %", "- 0.1 %", "+ 4 %", "- 4 %" };
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 5;
-
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-			uinfo->value.enumerated.items - 1;
-
-	strcpy(uinfo->value.enumerated.name,
-			texts[uinfo->value.enumerated.item]);
-
+	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
 
@@ -3971,17 +3899,7 @@ static int snd_hdspm_info_tco_wck_conversion(struct snd_kcontrol *kcontrol,
 					     struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "1:1", "44.1 -> 48", "48 -> 44.1" };
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 3;
-
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-			uinfo->value.enumerated.items - 1;
-
-	strcpy(uinfo->value.enumerated.name,
-			texts[uinfo->value.enumerated.item]);
-
+	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
 
@@ -4028,17 +3946,7 @@ static int snd_hdspm_info_tco_frame_rate(struct snd_kcontrol *kcontrol,
 {
 	static char *texts[] = { "24 fps", "25 fps", "29.97fps",
 		"29.97 dfps", "30 fps", "30 dfps" };
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 6;
-
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-			uinfo->value.enumerated.items - 1;
-
-	strcpy(uinfo->value.enumerated.name,
-			texts[uinfo->value.enumerated.item]);
-
+	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
 
@@ -4084,17 +3992,7 @@ static int snd_hdspm_info_tco_sync_source(struct snd_kcontrol *kcontrol,
 					  struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "LTC", "Video", "WCK" };
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 3;
-
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-			uinfo->value.enumerated.items - 1;
-
-	strcpy(uinfo->value.enumerated.name,
-			texts[uinfo->value.enumerated.item]);
-
+	ENUMERATED_CTL_INFO(uinfo, texts);
 	return 0;
 }
 

commit 696be0fbe244ca6d267fb1ce67a4a5f6c8fe37bc
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Sun Mar 10 00:37:23 2013 +0100

    ALSA: hdspm - Provide ALSA control to disable 96K frames
    
    For 96kHz, MADI allows to multiplex the samples (SMUX) or to use a
    dedicated 96K mode. The RME cards default to 96K mode, but since not all
    external MADI equipment supports this, provide a switch to users that
    changes the on-wire protocol to SMUX.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index c56bfe402234..c03ee011bfb6 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4192,6 +4192,7 @@ static struct snd_kcontrol_new snd_hdspm_controls_madi[] = {
 	HDSPM_SYNC_CHECK("SYNC IN SyncCheck", 3),
 	HDSPM_TOGGLE_SETTING("Line Out", HDSPM_LineOut),
 	HDSPM_TOGGLE_SETTING("TX 64 channels mode", HDSPM_TX_64ch),
+	HDSPM_TOGGLE_SETTING("Disable 96K frames", HDSPM_SMUX),
 	HDSPM_TOGGLE_SETTING("Clear Track Marker", HDSPM_clr_tms),
 	HDSPM_TOGGLE_SETTING("Safe Mode", HDSPM_AutoInp),
 	HDSPM_INPUT_SELECT("Input Select", 0),

commit fcdc4ba1d8c69847540cb3152f0ca44e238111ee
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Sun Mar 10 00:37:22 2013 +0100

    ALSA: hdspm - Allow the TCO and SYNC-IN to be used in slave mode
    
    When using the additional Time Code Option module in slave mode or the
    SYNC-In wordclock connector, the sample rate needs to be returned by
    hdspm_external_sample_rate().
    
    Since this sample rate may contain any value with 1Hz granularity, we
    need to round it to a common rate as done by the OSX driver.
    
    [Fixed missing function declarations by tiwai]
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 50cba5ce54fe..c56bfe402234 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1076,6 +1076,20 @@ static int snd_hdspm_use_is_exclusive(struct hdspm *hdspm)
 	return ret;
 }
 
+/* round arbitary sample rates to commonly known rates */
+static int hdspm_round_frequency(int rate)
+{
+	if (rate < 38050)
+		return 32000;
+	if (rate < 46008)
+		return 44100;
+	else
+		return 48000;
+}
+
+static int hdspm_tco_sync_check(struct hdspm *hdspm);
+static int hdspm_sync_in_sync_check(struct hdspm *hdspm);
+
 /* check for external sample rate */
 static int hdspm_external_sample_rate(struct hdspm *hdspm)
 {
@@ -1217,22 +1231,45 @@ static int hdspm_external_sample_rate(struct hdspm *hdspm)
 				break;
 			}
 
-			/* QS and DS rates normally can not be detected
-			 * automatically by the card. Only exception is MADI
-			 * in 96k frame mode.
-			 *
-			 * So if we read SS values (32 .. 48k), check for
-			 * user-provided DS/QS bits in the control register
-			 * and multiply the base frequency accordingly.
-			 */
-			if (rate <= 48000) {
-				if (hdspm->control_register & HDSPM_QuadSpeed)
-					rate *= 4;
-				else if (hdspm->control_register &
-						HDSPM_DoubleSpeed)
-					rate *= 2;
+		} /* endif HDSPM_madiLock */
+
+		/* check sample rate from TCO or SYNC_IN */
+		{
+			bool is_valid_input = 0;
+			bool has_sync = 0;
+
+			syncref = hdspm_autosync_ref(hdspm);
+			if (HDSPM_AUTOSYNC_FROM_TCO == syncref) {
+				is_valid_input = 1;
+				has_sync = (HDSPM_SYNC_CHECK_SYNC ==
+					hdspm_tco_sync_check(hdspm));
+			} else if (HDSPM_AUTOSYNC_FROM_SYNC_IN == syncref) {
+				is_valid_input = 1;
+				has_sync = (HDSPM_SYNC_CHECK_SYNC ==
+					hdspm_sync_in_sync_check(hdspm));
+			}
+
+			if (is_valid_input && has_sync) {
+				rate = hdspm_round_frequency(
+					hdspm_get_pll_freq(hdspm));
 			}
 		}
+
+		/* QS and DS rates normally can not be detected
+		 * automatically by the card. Only exception is MADI
+		 * in 96k frame mode.
+		 *
+		 * So if we read SS values (32 .. 48k), check for
+		 * user-provided DS/QS bits in the control register
+		 * and multiply the base frequency accordingly.
+		 */
+		if (rate <= 48000) {
+			if (hdspm->control_register & HDSPM_QuadSpeed)
+				rate *= 4;
+			else if (hdspm->control_register &
+					HDSPM_DoubleSpeed)
+				rate *= 2;
+		}
 		break;
 	}
 

commit 3f7bf918bfa2f4b8aa461ae82249e3c187bbff81
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Sun Mar 10 00:37:21 2013 +0100

    ALSA: hdspm - Refactor sample rate acquisition
    
    This commit introduces hdspm_get_pll_freq() to avoid code duplication.
    Reading the sample rate from the DDS register will be required by
    upcoming code.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 223c3d9cc69e..50cba5ce54fe 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -969,6 +969,7 @@ static int snd_hdspm_create_pcm(struct snd_card *card,
 				struct hdspm *hdspm);
 
 static inline void snd_hdspm_initialize_midi_flush(struct hdspm *hdspm);
+static inline int hdspm_get_pll_freq(struct hdspm *hdspm);
 static int hdspm_update_simple_mixer_controls(struct hdspm *hdspm);
 static int hdspm_autosync_ref(struct hdspm *hdspm);
 static int snd_hdspm_set_defaults(struct hdspm *hdspm);
@@ -1979,16 +1980,25 @@ static void hdspm_midi_tasklet(unsigned long arg)
 /* get the system sample rate which is set */
 
 
+static inline int hdspm_get_pll_freq(struct hdspm *hdspm)
+{
+	unsigned int period, rate;
+
+	period = hdspm_read(hdspm, HDSPM_RD_PLL_FREQ);
+	rate = hdspm_calc_dds_value(hdspm, period);
+
+	return rate;
+}
+
 /**
  * Calculate the real sample rate from the
  * current DDS value.
  **/
 static int hdspm_get_system_sample_rate(struct hdspm *hdspm)
 {
-	unsigned int period, rate;
+	unsigned int rate;
 
-	period = hdspm_read(hdspm, HDSPM_RD_PLL_FREQ);
-	rate = hdspm_calc_dds_value(hdspm, period);
+	rate = hdspm_get_pll_freq(hdspm);
 
 	if (rate > 207000) {
 		/* Unreasonable high sample rate as seen on PCI MADI cards. */

commit 56bde0f328428f2fc6e416510d8b42de6a0cfad5
Author: Andre Schramm <andre.schramm@iosono-sound.com>
Date:   Wed Jan 9 14:40:18 2013 +0100

    ALSA: hdspm - Fix wordclock status on AES32
    
    Use correct bitmask for AES32 cards to determine wordclock lock state,
    add missing bitmask for sync check and make output of the corresponding
    control and /proc coherent.
    
    Signed-off-by: Andre Schramm <andre.schramm@iosono-sound.com>
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 6e02e064d7b4..223c3d9cc69e 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -441,6 +441,7 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 */
 /* status */
 #define HDSPM_AES32_wcLock	0x0200000
+#define HDSPM_AES32_wcSync	0x0100000
 #define HDSPM_AES32_wcFreq_bit  22
 /* (status >> HDSPM_AES32_wcFreq_bit) & 0xF gives WC frequency (cf function
   HDSPM_bit2freq */
@@ -3467,10 +3468,12 @@ static int hdspm_wc_sync_check(struct hdspm *hdspm)
 	switch (hdspm->io_type) {
 	case AES32:
 		status = hdspm_read(hdspm, HDSPM_statusRegister);
-		if (status & HDSPM_wcSync)
-			return 2;
-		else if (status & HDSPM_wcLock)
-			return 1;
+		if (status & HDSPM_AES32_wcLock) {
+			if (status & HDSPM_AES32_wcSync)
+				return 2;
+			else
+				return 1;
+		}
 		return 0;
 		break;
 
@@ -4658,6 +4661,7 @@ snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
 	unsigned int status;
 	unsigned int status2;
 	unsigned int timecode;
+	unsigned int wcLock, wcSync;
 	int pref_syncref;
 	char *autosync_ref;
 	int x;
@@ -4751,8 +4755,11 @@ snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
 
 	snd_iprintf(buffer, "--- Status:\n");
 
+	wcLock = status & HDSPM_AES32_wcLock;
+	wcSync = wcLock && (status & HDSPM_AES32_wcSync);
+
 	snd_iprintf(buffer, "Word: %s  Frequency: %d\n",
-		    (status & HDSPM_AES32_wcLock) ? "Sync   " : "No Lock",
+		    (wcLock) ? (wcSync ? "Sync   " : "Lock   ") : "No Lock",
 		    HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit) & 0xF));
 
 	for (x = 0; x < 8; x++) {

commit e23e7a1436207217000c2854214bc908936af3cb
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Dec 6 12:35:10 2012 -0500

    ALSA: pci: remove __dev* attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index a7e0de1a1b4b..6e02e064d7b4 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -962,10 +962,10 @@ static DEFINE_PCI_DEVICE_TABLE(snd_hdspm_ids) = {
 MODULE_DEVICE_TABLE(pci, snd_hdspm_ids);
 
 /* prototypes */
-static int __devinit snd_hdspm_create_alsa_devices(struct snd_card *card,
-						   struct hdspm * hdspm);
-static int __devinit snd_hdspm_create_pcm(struct snd_card *card,
-					  struct hdspm * hdspm);
+static int snd_hdspm_create_alsa_devices(struct snd_card *card,
+					 struct hdspm *hdspm);
+static int snd_hdspm_create_pcm(struct snd_card *card,
+				struct hdspm *hdspm);
 
 static inline void snd_hdspm_initialize_midi_flush(struct hdspm *hdspm);
 static int hdspm_update_simple_mixer_controls(struct hdspm *hdspm);
@@ -1845,8 +1845,8 @@ static struct snd_rawmidi_ops snd_hdspm_midi_input =
 	.trigger =	snd_hdspm_midi_input_trigger,
 };
 
-static int __devinit snd_hdspm_create_midi (struct snd_card *card,
-					    struct hdspm *hdspm, int id)
+static int snd_hdspm_create_midi(struct snd_card *card,
+				 struct hdspm *hdspm, int id)
 {
 	int err;
 	char buf[32];
@@ -4897,7 +4897,7 @@ static void snd_hdspm_proc_ports_out(struct snd_info_entry *entry,
 }
 
 
-static void __devinit snd_hdspm_proc_init(struct hdspm *hdspm)
+static void snd_hdspm_proc_init(struct hdspm *hdspm)
 {
 	struct snd_info_entry *entry;
 
@@ -6033,8 +6033,8 @@ static struct snd_pcm_ops snd_hdspm_capture_ops = {
 	.page = snd_pcm_sgbuf_ops_page,
 };
 
-static int __devinit snd_hdspm_create_hwdep(struct snd_card *card,
-					    struct hdspm * hdspm)
+static int snd_hdspm_create_hwdep(struct snd_card *card,
+				  struct hdspm *hdspm)
 {
 	struct snd_hwdep *hw;
 	int err;
@@ -6059,7 +6059,7 @@ static int __devinit snd_hdspm_create_hwdep(struct snd_card *card,
 /*------------------------------------------------------------
    memory interface
  ------------------------------------------------------------*/
-static int __devinit snd_hdspm_preallocate_memory(struct hdspm *hdspm)
+static int snd_hdspm_preallocate_memory(struct hdspm *hdspm)
 {
 	int err;
 	struct snd_pcm *pcm;
@@ -6100,8 +6100,8 @@ static void hdspm_set_sgbuf(struct hdspm *hdspm,
 
 
 /* ------------- ALSA Devices ---------------------------- */
-static int __devinit snd_hdspm_create_pcm(struct snd_card *card,
-					  struct hdspm *hdspm)
+static int snd_hdspm_create_pcm(struct snd_card *card,
+				struct hdspm *hdspm)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -6136,8 +6136,8 @@ static inline void snd_hdspm_initialize_midi_flush(struct hdspm * hdspm)
 		snd_hdspm_flush_midi_input(hdspm, i);
 }
 
-static int __devinit snd_hdspm_create_alsa_devices(struct snd_card *card,
-						   struct hdspm * hdspm)
+static int snd_hdspm_create_alsa_devices(struct snd_card *card,
+					 struct hdspm *hdspm)
 {
 	int err, i;
 
@@ -6195,8 +6195,9 @@ static int __devinit snd_hdspm_create_alsa_devices(struct snd_card *card,
 	return 0;
 }
 
-static int __devinit snd_hdspm_create(struct snd_card *card,
-		struct hdspm *hdspm) {
+static int snd_hdspm_create(struct snd_card *card,
+			    struct hdspm *hdspm)
+{
 
 	struct pci_dev *pci = hdspm->pci;
 	int err;
@@ -6569,8 +6570,8 @@ static void snd_hdspm_card_free(struct snd_card *card)
 }
 
 
-static int __devinit snd_hdspm_probe(struct pci_dev *pci,
-				     const struct pci_device_id *pci_id)
+static int snd_hdspm_probe(struct pci_dev *pci,
+			   const struct pci_device_id *pci_id)
 {
 	static int dev;
 	struct hdspm *hdspm;
@@ -6628,7 +6629,7 @@ static int __devinit snd_hdspm_probe(struct pci_dev *pci,
 	return 0;
 }
 
-static void __devexit snd_hdspm_remove(struct pci_dev *pci)
+static void snd_hdspm_remove(struct pci_dev *pci)
 {
 	snd_card_free(pci_get_drvdata(pci));
 	pci_set_drvdata(pci, NULL);
@@ -6638,7 +6639,7 @@ static struct pci_driver hdspm_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_hdspm_ids,
 	.probe = snd_hdspm_probe,
-	.remove = __devexit_p(snd_hdspm_remove),
+	.remove = snd_hdspm_remove,
 };
 
 module_pci_driver(hdspm_driver);

commit 467b10350525e53ddeea0b8de5b8b386a830d2a9
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Dec 3 14:55:51 2012 +0100

    ALSA: hdspm - Remove obsolete settings functions
    
    With HDSPM_TOGGLE_SETTING in place, these functions are no longer
    required. Removing them makes the code DRY and considerably shorter.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index f958e204eb4b..a7e0de1a1b4b 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2944,399 +2944,6 @@ static int snd_hdspm_put_toggle_setting(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-
-#define HDSPM_LINE_OUT(xname, xindex) \
-{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-	.name = xname, \
-	.index = xindex, \
-	.info = snd_hdspm_info_line_out, \
-	.get = snd_hdspm_get_line_out, \
-	.put = snd_hdspm_put_line_out \
-}
-
-static int hdspm_line_out(struct hdspm * hdspm)
-{
-	return (hdspm->control_register & HDSPM_LineOut) ? 1 : 0;
-}
-
-
-static int hdspm_set_line_output(struct hdspm * hdspm, int out)
-{
-	if (out)
-		hdspm->control_register |= HDSPM_LineOut;
-	else
-		hdspm->control_register &= ~HDSPM_LineOut;
-	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
-
-	return 0;
-}
-
-#define snd_hdspm_info_line_out		snd_ctl_boolean_mono_info
-
-static int snd_hdspm_get_line_out(struct snd_kcontrol *kcontrol,
-				  struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-
-	spin_lock_irq(&hdspm->lock);
-	ucontrol->value.integer.value[0] = hdspm_line_out(hdspm);
-	spin_unlock_irq(&hdspm->lock);
-	return 0;
-}
-
-static int snd_hdspm_put_line_out(struct snd_kcontrol *kcontrol,
-				  struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-	int change;
-	unsigned int val;
-
-	if (!snd_hdspm_use_is_exclusive(hdspm))
-		return -EBUSY;
-	val = ucontrol->value.integer.value[0] & 1;
-	spin_lock_irq(&hdspm->lock);
-	change = (int) val != hdspm_line_out(hdspm);
-	hdspm_set_line_output(hdspm, val);
-	spin_unlock_irq(&hdspm->lock);
-	return change;
-}
-
-
-#define HDSPM_TX_64(xname, xindex) \
-{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-	.name = xname, \
-	.index = xindex, \
-	.info = snd_hdspm_info_tx_64, \
-	.get = snd_hdspm_get_tx_64, \
-	.put = snd_hdspm_put_tx_64 \
-}
-
-static int hdspm_tx_64(struct hdspm * hdspm)
-{
-	return (hdspm->control_register & HDSPM_TX_64ch) ? 1 : 0;
-}
-
-static int hdspm_set_tx_64(struct hdspm * hdspm, int out)
-{
-	if (out)
-		hdspm->control_register |= HDSPM_TX_64ch;
-	else
-		hdspm->control_register &= ~HDSPM_TX_64ch;
-	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
-
-	return 0;
-}
-
-#define snd_hdspm_info_tx_64		snd_ctl_boolean_mono_info
-
-static int snd_hdspm_get_tx_64(struct snd_kcontrol *kcontrol,
-			       struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-
-	spin_lock_irq(&hdspm->lock);
-	ucontrol->value.integer.value[0] = hdspm_tx_64(hdspm);
-	spin_unlock_irq(&hdspm->lock);
-	return 0;
-}
-
-static int snd_hdspm_put_tx_64(struct snd_kcontrol *kcontrol,
-			       struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-	int change;
-	unsigned int val;
-
-	if (!snd_hdspm_use_is_exclusive(hdspm))
-		return -EBUSY;
-	val = ucontrol->value.integer.value[0] & 1;
-	spin_lock_irq(&hdspm->lock);
-	change = (int) val != hdspm_tx_64(hdspm);
-	hdspm_set_tx_64(hdspm, val);
-	spin_unlock_irq(&hdspm->lock);
-	return change;
-}
-
-
-#define HDSPM_C_TMS(xname, xindex) \
-{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-	.name = xname, \
-	.index = xindex, \
-	.info = snd_hdspm_info_c_tms, \
-	.get = snd_hdspm_get_c_tms, \
-	.put = snd_hdspm_put_c_tms \
-}
-
-static int hdspm_c_tms(struct hdspm * hdspm)
-{
-	return (hdspm->control_register & HDSPM_clr_tms) ? 1 : 0;
-}
-
-static int hdspm_set_c_tms(struct hdspm * hdspm, int out)
-{
-	if (out)
-		hdspm->control_register |= HDSPM_clr_tms;
-	else
-		hdspm->control_register &= ~HDSPM_clr_tms;
-	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
-
-	return 0;
-}
-
-#define snd_hdspm_info_c_tms		snd_ctl_boolean_mono_info
-
-static int snd_hdspm_get_c_tms(struct snd_kcontrol *kcontrol,
-			       struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-
-	spin_lock_irq(&hdspm->lock);
-	ucontrol->value.integer.value[0] = hdspm_c_tms(hdspm);
-	spin_unlock_irq(&hdspm->lock);
-	return 0;
-}
-
-static int snd_hdspm_put_c_tms(struct snd_kcontrol *kcontrol,
-			       struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-	int change;
-	unsigned int val;
-
-	if (!snd_hdspm_use_is_exclusive(hdspm))
-		return -EBUSY;
-	val = ucontrol->value.integer.value[0] & 1;
-	spin_lock_irq(&hdspm->lock);
-	change = (int) val != hdspm_c_tms(hdspm);
-	hdspm_set_c_tms(hdspm, val);
-	spin_unlock_irq(&hdspm->lock);
-	return change;
-}
-
-
-#define HDSPM_SAFE_MODE(xname, xindex) \
-{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-	.name = xname, \
-	.index = xindex, \
-	.info = snd_hdspm_info_safe_mode, \
-	.get = snd_hdspm_get_safe_mode, \
-	.put = snd_hdspm_put_safe_mode \
-}
-
-static int hdspm_safe_mode(struct hdspm * hdspm)
-{
-	return (hdspm->control_register & HDSPM_AutoInp) ? 1 : 0;
-}
-
-static int hdspm_set_safe_mode(struct hdspm * hdspm, int out)
-{
-	if (out)
-		hdspm->control_register |= HDSPM_AutoInp;
-	else
-		hdspm->control_register &= ~HDSPM_AutoInp;
-	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
-
-	return 0;
-}
-
-#define snd_hdspm_info_safe_mode	snd_ctl_boolean_mono_info
-
-static int snd_hdspm_get_safe_mode(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-
-	spin_lock_irq(&hdspm->lock);
-	ucontrol->value.integer.value[0] = hdspm_safe_mode(hdspm);
-	spin_unlock_irq(&hdspm->lock);
-	return 0;
-}
-
-static int snd_hdspm_put_safe_mode(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-	int change;
-	unsigned int val;
-
-	if (!snd_hdspm_use_is_exclusive(hdspm))
-		return -EBUSY;
-	val = ucontrol->value.integer.value[0] & 1;
-	spin_lock_irq(&hdspm->lock);
-	change = (int) val != hdspm_safe_mode(hdspm);
-	hdspm_set_safe_mode(hdspm, val);
-	spin_unlock_irq(&hdspm->lock);
-	return change;
-}
-
-
-#define HDSPM_EMPHASIS(xname, xindex) \
-{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-	.name = xname, \
-	.index = xindex, \
-	.info = snd_hdspm_info_emphasis, \
-	.get = snd_hdspm_get_emphasis, \
-	.put = snd_hdspm_put_emphasis \
-}
-
-static int hdspm_emphasis(struct hdspm * hdspm)
-{
-	return (hdspm->control_register & HDSPM_Emphasis) ? 1 : 0;
-}
-
-static int hdspm_set_emphasis(struct hdspm * hdspm, int emp)
-{
-	if (emp)
-		hdspm->control_register |= HDSPM_Emphasis;
-	else
-		hdspm->control_register &= ~HDSPM_Emphasis;
-	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
-
-	return 0;
-}
-
-#define snd_hdspm_info_emphasis		snd_ctl_boolean_mono_info
-
-static int snd_hdspm_get_emphasis(struct snd_kcontrol *kcontrol,
-				  struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-
-	spin_lock_irq(&hdspm->lock);
-	ucontrol->value.enumerated.item[0] = hdspm_emphasis(hdspm);
-	spin_unlock_irq(&hdspm->lock);
-	return 0;
-}
-
-static int snd_hdspm_put_emphasis(struct snd_kcontrol *kcontrol,
-				  struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-	int change;
-	unsigned int val;
-
-	if (!snd_hdspm_use_is_exclusive(hdspm))
-		return -EBUSY;
-	val = ucontrol->value.integer.value[0] & 1;
-	spin_lock_irq(&hdspm->lock);
-	change = (int) val != hdspm_emphasis(hdspm);
-	hdspm_set_emphasis(hdspm, val);
-	spin_unlock_irq(&hdspm->lock);
-	return change;
-}
-
-
-#define HDSPM_DOLBY(xname, xindex) \
-{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-	.name = xname, \
-	.index = xindex, \
-	.info = snd_hdspm_info_dolby, \
-	.get = snd_hdspm_get_dolby, \
-	.put = snd_hdspm_put_dolby \
-}
-
-static int hdspm_dolby(struct hdspm * hdspm)
-{
-	return (hdspm->control_register & HDSPM_Dolby) ? 1 : 0;
-}
-
-static int hdspm_set_dolby(struct hdspm * hdspm, int dol)
-{
-	if (dol)
-		hdspm->control_register |= HDSPM_Dolby;
-	else
-		hdspm->control_register &= ~HDSPM_Dolby;
-	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
-
-	return 0;
-}
-
-#define snd_hdspm_info_dolby		snd_ctl_boolean_mono_info
-
-static int snd_hdspm_get_dolby(struct snd_kcontrol *kcontrol,
-			       struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-
-	spin_lock_irq(&hdspm->lock);
-	ucontrol->value.enumerated.item[0] = hdspm_dolby(hdspm);
-	spin_unlock_irq(&hdspm->lock);
-	return 0;
-}
-
-static int snd_hdspm_put_dolby(struct snd_kcontrol *kcontrol,
-			       struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-	int change;
-	unsigned int val;
-
-	if (!snd_hdspm_use_is_exclusive(hdspm))
-		return -EBUSY;
-	val = ucontrol->value.integer.value[0] & 1;
-	spin_lock_irq(&hdspm->lock);
-	change = (int) val != hdspm_dolby(hdspm);
-	hdspm_set_dolby(hdspm, val);
-	spin_unlock_irq(&hdspm->lock);
-	return change;
-}
-
-
-#define HDSPM_PROFESSIONAL(xname, xindex) \
-{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-	.name = xname, \
-	.index = xindex, \
-	.info = snd_hdspm_info_professional, \
-	.get = snd_hdspm_get_professional, \
-	.put = snd_hdspm_put_professional \
-}
-
-static int hdspm_professional(struct hdspm * hdspm)
-{
-	return (hdspm->control_register & HDSPM_Professional) ? 1 : 0;
-}
-
-static int hdspm_set_professional(struct hdspm * hdspm, int dol)
-{
-	if (dol)
-		hdspm->control_register |= HDSPM_Professional;
-	else
-		hdspm->control_register &= ~HDSPM_Professional;
-	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
-
-	return 0;
-}
-
-#define snd_hdspm_info_professional	snd_ctl_boolean_mono_info
-
-static int snd_hdspm_get_professional(struct snd_kcontrol *kcontrol,
-				      struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-
-	spin_lock_irq(&hdspm->lock);
-	ucontrol->value.enumerated.item[0] = hdspm_professional(hdspm);
-	spin_unlock_irq(&hdspm->lock);
-	return 0;
-}
-
-static int snd_hdspm_put_professional(struct snd_kcontrol *kcontrol,
-				      struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-	int change;
-	unsigned int val;
-
-	if (!snd_hdspm_use_is_exclusive(hdspm))
-		return -EBUSY;
-	val = ucontrol->value.integer.value[0] & 1;
-	spin_lock_irq(&hdspm->lock);
-	change = (int) val != hdspm_professional(hdspm);
-	hdspm_set_professional(hdspm, val);
-	spin_unlock_irq(&hdspm->lock);
-	return change;
-}
-
 #define HDSPM_INPUT_SELECT(xname, xindex) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
 	.name = xname, \

commit c9e1668c68c623296f4aca35ffca5763665e58de
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Dec 3 14:55:50 2012 +0100

    ALSA: hdspm - Use HDSPM_TOGGLE_SETTING to alter settings
    
    HDSPM_TOGGLE_SETTING and its corresponding functions allow to change
    settings in the control register. Instead of using the specialised
    functions, use the generic code to make the code DRY.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 002e692bd346..f958e204eb4b 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4533,10 +4533,10 @@ static struct snd_kcontrol_new snd_hdspm_controls_madi[] = {
 	HDSPM_SYNC_CHECK("MADI SyncCheck", 1),
 	HDSPM_SYNC_CHECK("TCO SyncCheck", 2),
 	HDSPM_SYNC_CHECK("SYNC IN SyncCheck", 3),
-	HDSPM_LINE_OUT("Line Out", 0),
-	HDSPM_TX_64("TX 64 channels mode", 0),
-	HDSPM_C_TMS("Clear Track Marker", 0),
-	HDSPM_SAFE_MODE("Safe Mode", 0),
+	HDSPM_TOGGLE_SETTING("Line Out", HDSPM_LineOut),
+	HDSPM_TOGGLE_SETTING("TX 64 channels mode", HDSPM_TX_64ch),
+	HDSPM_TOGGLE_SETTING("Clear Track Marker", HDSPM_clr_tms),
+	HDSPM_TOGGLE_SETTING("Safe Mode", HDSPM_AutoInp),
 	HDSPM_INPUT_SELECT("Input Select", 0),
 	HDSPM_MADI_SPEEDMODE("MADI Speed Mode", 0)
 };
@@ -4549,9 +4549,9 @@ static struct snd_kcontrol_new snd_hdspm_controls_madiface[] = {
 	HDSPM_SYSTEM_SAMPLE_RATE("System Sample Rate", 0),
 	HDSPM_AUTOSYNC_SAMPLE_RATE("External Rate", 0),
 	HDSPM_SYNC_CHECK("MADI SyncCheck", 0),
-	HDSPM_TX_64("TX 64 channels mode", 0),
-	HDSPM_C_TMS("Clear Track Marker", 0),
-	HDSPM_SAFE_MODE("Safe Mode", 0),
+	HDSPM_TOGGLE_SETTING("TX 64 channels mode", HDSPM_TX_64ch),
+	HDSPM_TOGGLE_SETTING("Clear Track Marker", HDSPM_clr_tms),
+	HDSPM_TOGGLE_SETTING("Safe Mode", HDSPM_AutoInp),
 	HDSPM_MADI_SPEEDMODE("MADI Speed Mode", 0)
 };
 
@@ -4644,11 +4644,11 @@ static struct snd_kcontrol_new snd_hdspm_controls_aes32[] = {
 	HDSPM_AUTOSYNC_SAMPLE_RATE("AES8 Frequency", 8),
 	HDSPM_AUTOSYNC_SAMPLE_RATE("TCO Frequency", 9),
 	HDSPM_AUTOSYNC_SAMPLE_RATE("SYNC IN Frequency", 10),
-	HDSPM_LINE_OUT("Line Out", 0),
-	HDSPM_EMPHASIS("Emphasis", 0),
-	HDSPM_DOLBY("Non Audio", 0),
-	HDSPM_PROFESSIONAL("Professional", 0),
-	HDSPM_C_TMS("Clear Track Marker", 0),
+	HDSPM_TOGGLE_SETTING("Line Out", HDSPM_LineOut),
+	HDSPM_TOGGLE_SETTING("Emphasis", HDSPM_Emphasis),
+	HDSPM_TOGGLE_SETTING("Non Audio", HDSPM_Dolby),
+	HDSPM_TOGGLE_SETTING("Professional", HDSPM_Professional),
+	HDSPM_TOGGLE_SETTING("Clear Track Marker", HDSPM_clr_tms),
 	HDSPM_DS_WIRE("Double Speed Wire Mode", 0),
 	HDSPM_QS_WIRE("Quad Speed Wire Mode", 0),
 };
@@ -6323,7 +6323,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 		info.system_clock_mode = hdspm_system_clock_mode(hdspm);
 		info.clock_source = hdspm_clock_source(hdspm);
 		info.autosync_ref = hdspm_autosync_ref(hdspm);
-		info.line_out = hdspm_line_out(hdspm);
+		info.line_out = hdspm_toggle_setting(hdspm, HDSPM_LineOut);
 		info.passthru = 0;
 		spin_unlock_irq(&hdspm->lock);
 		if (copy_to_user(argp, &info, sizeof(info)))

commit bf0ff87bef59fbc60b259b8843ae7fbed2cc44bd
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Dec 3 14:55:49 2012 +0100

    ALSA: hdspm - Implement generic function to toggle settings
    
    The driver contains at least six similar functions that change only a
    single bit in the control register, only the bit position varies.
    
    This patch implements a generic function to toggle a certain bit
    position that will be used to replace the old code.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 748e36c66603..002e692bd346 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2887,6 +2887,63 @@ static int snd_hdspm_get_autosync_ref(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+#define HDSPM_TOGGLE_SETTING(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.private_value = xindex, \
+	.info = snd_hdspm_info_toggle_setting, \
+	.get = snd_hdspm_get_toggle_setting, \
+	.put = snd_hdspm_put_toggle_setting \
+}
+
+static int hdspm_toggle_setting(struct hdspm *hdspm, u32 regmask)
+{
+	return (hdspm->control_register & regmask) ? 1 : 0;
+}
+
+static int hdspm_set_toggle_setting(struct hdspm *hdspm, u32 regmask, int out)
+{
+	if (out)
+		hdspm->control_register |= regmask;
+	else
+		hdspm->control_register &= ~regmask;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+#define snd_hdspm_info_toggle_setting		snd_ctl_boolean_mono_info
+
+static int snd_hdspm_get_toggle_setting(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	u32 regmask = kcontrol->private_value;
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.integer.value[0] = hdspm_toggle_setting(hdspm, regmask);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_toggle_setting(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	u32 regmask = kcontrol->private_value;
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_toggle_setting(hdspm, regmask);
+	hdspm_set_toggle_setting(hdspm, regmask, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
 
 #define HDSPM_LINE_OUT(xname, xindex) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \

commit d1a3c98d50731c627909029bb653a0557946f0f5
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Wed Nov 7 18:00:09 2012 +0100

    ALSA: hdspm - Fix sync check reporting on RME RayDAT
    
    The RayDAT reports the sync status of its inputs in consecutive bit
    positions, so all we do in hdspm_s1_sync_check is to iterate over idx:
    
        status = hdspm_read(hdspm, HDSPM_RD_STATUS_1);
    
        lock = (status & (0x1<<idx)) ? 1 : 0;
        sync = (status & (0x100<<idx)) ? 1 : 0;
    
    The index is given in kcontrol->private_value:
    
        HDSPM_SYNC_CHECK("WC SyncCheck", 0),
        HDSPM_SYNC_CHECK("AES SyncCheck", 1),
        HDSPM_SYNC_CHECK("SPDIF SyncCheck", 2),
        HDSPM_SYNC_CHECK("ADAT1 SyncCheck", 3),
        HDSPM_SYNC_CHECK("ADAT2 SyncCheck", 4),
        HDSPM_SYNC_CHECK("ADAT3 SyncCheck", 5),
        HDSPM_SYNC_CHECK("ADAT4 SyncCheck", 6),
        HDSPM_SYNC_CHECK("TCO SyncCheck", 7),
        HDSPM_SYNC_CHECK("SYNC IN SyncCheck", 8),
    
    The patch corrects the indicated sync flags by passing the proper index
    value to hdspm_s1_sync_check().
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 9a8d5cef32c7..748e36c66603 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3979,7 +3979,8 @@ static int snd_hdspm_get_sync_check(struct snd_kcontrol *kcontrol,
 		case 8: /* SYNC IN */
 			val = hdspm_sync_in_sync_check(hdspm); break;
 		default:
-			val = hdspm_s1_sync_check(hdspm, ucontrol->id.index-1);
+			val = hdspm_s1_sync_check(hdspm,
+					kcontrol->private_value-1);
 		}
 		break;
 

commit ec8f53fb693dda095ad3342b927a074e7c4dddfa
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Fri Nov 2 00:28:50 2012 +0900

    ALSA: Fix typo in drivers sound
    
    Correct spelling typo in debug messages within drivers/sound
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index f1cd1e387801..9a8d5cef32c7 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4899,7 +4899,7 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 		insel = "Coaxial";
 		break;
 	default:
-		insel = "Unkown";
+		insel = "Unknown";
 	}
 
 	snd_iprintf(buffer,

commit f27a64f9973ff932ece576793c195de60c1c6c9b
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Oct 19 17:42:30 2012 +0200

    ALSA: hdspm - Fix coding style in CTL_ELEM macros
    
    checkpatch.pl discourages the use of spaces at the beginning of lines.
    Some of the CTL_ELEM defines were not properly indented.
    
    This patch replaces the leading spaces by tabs. No functionality is
    changed, the commit is purely cosmetic.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 096580473529..f1cd1e387801 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2005,14 +2005,14 @@ static int hdspm_get_system_sample_rate(struct hdspm *hdspm)
 
 
 #define HDSPM_SYSTEM_SAMPLE_RATE(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\
-	SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
-  .info = snd_hdspm_info_system_sample_rate, \
-  .put = snd_hdspm_put_system_sample_rate, \
-  .get = snd_hdspm_get_system_sample_rate \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\
+		SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_info_system_sample_rate, \
+	.put = snd_hdspm_put_system_sample_rate, \
+	.get = snd_hdspm_get_system_sample_rate \
 }
 
 static int snd_hdspm_info_system_sample_rate(struct snd_kcontrol *kcontrol,
@@ -2464,7 +2464,7 @@ static int snd_hdspm_put_clock_source(struct snd_kcontrol *kcontrol,
 
 
 #define HDSPM_PREF_SYNC_REF(xname, xindex) \
-{.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
 	.name = xname, \
 	.index = xindex, \
 	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\
@@ -2800,12 +2800,12 @@ static int snd_hdspm_put_pref_sync_ref(struct snd_kcontrol *kcontrol,
 
 
 #define HDSPM_AUTOSYNC_REF(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .access = SNDRV_CTL_ELEM_ACCESS_READ, \
-  .info = snd_hdspm_info_autosync_ref, \
-  .get = snd_hdspm_get_autosync_ref, \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READ, \
+	.info = snd_hdspm_info_autosync_ref, \
+	.get = snd_hdspm_get_autosync_ref, \
 }
 
 static int hdspm_autosync_ref(struct hdspm *hdspm)
@@ -2889,12 +2889,12 @@ static int snd_hdspm_get_autosync_ref(struct snd_kcontrol *kcontrol,
 
 
 #define HDSPM_LINE_OUT(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .info = snd_hdspm_info_line_out, \
-  .get = snd_hdspm_get_line_out, \
-  .put = snd_hdspm_put_line_out \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.info = snd_hdspm_info_line_out, \
+	.get = snd_hdspm_get_line_out, \
+	.put = snd_hdspm_put_line_out \
 }
 
 static int hdspm_line_out(struct hdspm * hdspm)
@@ -2946,12 +2946,12 @@ static int snd_hdspm_put_line_out(struct snd_kcontrol *kcontrol,
 
 
 #define HDSPM_TX_64(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .info = snd_hdspm_info_tx_64, \
-  .get = snd_hdspm_get_tx_64, \
-  .put = snd_hdspm_put_tx_64 \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.info = snd_hdspm_info_tx_64, \
+	.get = snd_hdspm_get_tx_64, \
+	.put = snd_hdspm_put_tx_64 \
 }
 
 static int hdspm_tx_64(struct hdspm * hdspm)
@@ -3002,12 +3002,12 @@ static int snd_hdspm_put_tx_64(struct snd_kcontrol *kcontrol,
 
 
 #define HDSPM_C_TMS(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .info = snd_hdspm_info_c_tms, \
-  .get = snd_hdspm_get_c_tms, \
-  .put = snd_hdspm_put_c_tms \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.info = snd_hdspm_info_c_tms, \
+	.get = snd_hdspm_get_c_tms, \
+	.put = snd_hdspm_put_c_tms \
 }
 
 static int hdspm_c_tms(struct hdspm * hdspm)
@@ -3058,12 +3058,12 @@ static int snd_hdspm_put_c_tms(struct snd_kcontrol *kcontrol,
 
 
 #define HDSPM_SAFE_MODE(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .info = snd_hdspm_info_safe_mode, \
-  .get = snd_hdspm_get_safe_mode, \
-  .put = snd_hdspm_put_safe_mode \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.info = snd_hdspm_info_safe_mode, \
+	.get = snd_hdspm_get_safe_mode, \
+	.put = snd_hdspm_put_safe_mode \
 }
 
 static int hdspm_safe_mode(struct hdspm * hdspm)
@@ -3114,12 +3114,12 @@ static int snd_hdspm_put_safe_mode(struct snd_kcontrol *kcontrol,
 
 
 #define HDSPM_EMPHASIS(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .info = snd_hdspm_info_emphasis, \
-  .get = snd_hdspm_get_emphasis, \
-  .put = snd_hdspm_put_emphasis \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.info = snd_hdspm_info_emphasis, \
+	.get = snd_hdspm_get_emphasis, \
+	.put = snd_hdspm_put_emphasis \
 }
 
 static int hdspm_emphasis(struct hdspm * hdspm)
@@ -3170,12 +3170,12 @@ static int snd_hdspm_put_emphasis(struct snd_kcontrol *kcontrol,
 
 
 #define HDSPM_DOLBY(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .info = snd_hdspm_info_dolby, \
-  .get = snd_hdspm_get_dolby, \
-  .put = snd_hdspm_put_dolby \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.info = snd_hdspm_info_dolby, \
+	.get = snd_hdspm_get_dolby, \
+	.put = snd_hdspm_put_dolby \
 }
 
 static int hdspm_dolby(struct hdspm * hdspm)
@@ -3226,12 +3226,12 @@ static int snd_hdspm_put_dolby(struct snd_kcontrol *kcontrol,
 
 
 #define HDSPM_PROFESSIONAL(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .info = snd_hdspm_info_professional, \
-  .get = snd_hdspm_get_professional, \
-  .put = snd_hdspm_put_professional \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.info = snd_hdspm_info_professional, \
+	.get = snd_hdspm_get_professional, \
+	.put = snd_hdspm_put_professional \
 }
 
 static int hdspm_professional(struct hdspm * hdspm)
@@ -3281,12 +3281,12 @@ static int snd_hdspm_put_professional(struct snd_kcontrol *kcontrol,
 }
 
 #define HDSPM_INPUT_SELECT(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .info = snd_hdspm_info_input_select, \
-  .get = snd_hdspm_get_input_select, \
-  .put = snd_hdspm_put_input_select \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.info = snd_hdspm_info_input_select, \
+	.get = snd_hdspm_get_input_select, \
+	.put = snd_hdspm_put_input_select \
 }
 
 static int hdspm_input_select(struct hdspm * hdspm)
@@ -3353,12 +3353,12 @@ static int snd_hdspm_put_input_select(struct snd_kcontrol *kcontrol,
 
 
 #define HDSPM_DS_WIRE(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .info = snd_hdspm_info_ds_wire, \
-  .get = snd_hdspm_get_ds_wire, \
-  .put = snd_hdspm_put_ds_wire \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.info = snd_hdspm_info_ds_wire, \
+	.get = snd_hdspm_get_ds_wire, \
+	.put = snd_hdspm_put_ds_wire \
 }
 
 static int hdspm_ds_wire(struct hdspm * hdspm)
@@ -3425,12 +3425,12 @@ static int snd_hdspm_put_ds_wire(struct snd_kcontrol *kcontrol,
 
 
 #define HDSPM_QS_WIRE(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .info = snd_hdspm_info_qs_wire, \
-  .get = snd_hdspm_get_qs_wire, \
-  .put = snd_hdspm_put_qs_wire \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.info = snd_hdspm_info_qs_wire, \
+	.get = snd_hdspm_get_qs_wire, \
+	.put = snd_hdspm_put_qs_wire \
 }
 
 static int hdspm_qs_wire(struct hdspm * hdspm)
@@ -3597,15 +3597,15 @@ static int snd_hdspm_put_madi_speedmode(struct snd_kcontrol *kcontrol,
 }
 
 #define HDSPM_MIXER(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
-  .name = xname, \
-  .index = xindex, \
-  .device = 0, \
-  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \
-		 SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
-  .info = snd_hdspm_info_mixer, \
-  .get = snd_hdspm_get_mixer, \
-  .put = snd_hdspm_put_mixer \
+{	.iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+	.name = xname, \
+	.index = xindex, \
+	.device = 0, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \
+		SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_info_mixer, \
+	.get = snd_hdspm_get_mixer, \
+	.put = snd_hdspm_put_mixer \
 }
 
 static int snd_hdspm_info_mixer(struct snd_kcontrol *kcontrol,
@@ -3704,12 +3704,12 @@ static int snd_hdspm_put_mixer(struct snd_kcontrol *kcontrol,
 */
 
 #define HDSPM_PLAYBACK_MIXER \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE | \
-		 SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
-  .info = snd_hdspm_info_playback_mixer, \
-  .get = snd_hdspm_get_playback_mixer, \
-  .put = snd_hdspm_put_playback_mixer \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE | \
+		SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_info_playback_mixer, \
+	.get = snd_hdspm_get_playback_mixer, \
+	.put = snd_hdspm_put_playback_mixer \
 }
 
 static int snd_hdspm_info_playback_mixer(struct snd_kcontrol *kcontrol,

commit 930f4ff078b9c4484b0e9383fc17a04d4f9253bf
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Oct 19 17:42:29 2012 +0200

    ALSA: hdspm - Fix typo in kcontrol element on RME MADI cards
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index b8b15ee5eebb..096580473529 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4473,7 +4473,7 @@ static struct snd_kcontrol_new snd_hdspm_controls_madi[] = {
 	HDSPM_AUTOSYNC_SAMPLE_RATE("External Rate", 0),
 	HDSPM_SYNC_CHECK("WC SyncCheck", 0),
 	HDSPM_SYNC_CHECK("MADI SyncCheck", 1),
-	HDSPM_SYNC_CHECK("TCO SyncCHeck", 2),
+	HDSPM_SYNC_CHECK("TCO SyncCheck", 2),
 	HDSPM_SYNC_CHECK("SYNC IN SyncCheck", 3),
 	HDSPM_LINE_OUT("Line Out", 0),
 	HDSPM_TX_64("TX 64 channels mode", 0),

commit 9a215f47da029b04bf92f1f68abf978211155ceb
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Oct 19 17:42:28 2012 +0200

    ALSA: hdspm - Fix sync_in detection on AES/AES32
    
    According to the documentation, AES32 cards use a different bit position
    for reporting the sync_in status.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 5d70efec26c0..b8b15ee5eebb 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3892,8 +3892,8 @@ static int hdspm_sync_in_sync_check(struct hdspm *hdspm)
 
 	case AES32:
 		status = hdspm_read(hdspm, HDSPM_statusRegister2);
-		lock = (status & HDSPM_syncInLock) ? 1 : 0;
-		sync = (status & HDSPM_syncInSync) ? 1 : 0;
+		lock = (status & 0x100000) ? 1 : 0;
+		sync = (status & 0x200000) ? 1 : 0;
 		break;
 
 	case MADIface:

commit 2e0452f544758d798ba76016c00783f654b43fe3
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Oct 19 17:42:27 2012 +0200

    ALSA: hdspm - Fix sync_in reporting on RME MADI cards
    
    In contrast to AES32, MADI uses the first status register to report the
    sync_in status.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 5f243aedeef7..5d70efec26c0 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3885,6 +3885,11 @@ static int hdspm_sync_in_sync_check(struct hdspm *hdspm)
 		break;
 
 	case MADI:
+		status = hdspm_read(hdspm, HDSPM_statusRegister);
+		lock = (status & HDSPM_syncInLock) ? 1 : 0;
+		sync = (status & HDSPM_syncInSync) ? 1 : 0;
+		break;
+
 	case AES32:
 		status = hdspm_read(hdspm, HDSPM_statusRegister2);
 		lock = (status & HDSPM_syncInLock) ? 1 : 0;

commit b8812c55c5e59596bbf4b1d3e5b4b3ef50a89cad
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Oct 19 17:42:26 2012 +0200

    ALSA: hdspm - Also report autosync_sample_rate on MADI and MADIface
    
    MADI and MADIface used to report the autosync_sample_rate. This
    functionality was lost in commit
    0dca1793063c28dde8f6c49c9c72203fe5cb6efc, this commit now adds it back.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 976e3a6b0508..5f243aedeef7 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2225,6 +2225,21 @@ static int snd_hdspm_get_autosync_sample_rate(struct snd_kcontrol *kcontrol,
 			break;
 		}
 		break;
+
+	case MADI:
+	case MADIface:
+		{
+			int rate = hdspm_external_sample_rate(hdspm);
+			int i, selected_rate = 0;
+			for (i = 1; i < 10; i++)
+				if (HDSPM_bit2freq(i) == rate) {
+					selected_rate = i;
+					break;
+				}
+			ucontrol->value.enumerated.item[0] = selected_rate;
+		}
+		break;
+
 	default:
 		break;
 	}
@@ -4450,6 +4465,7 @@ static struct snd_kcontrol_new snd_hdspm_controls_madi[] = {
 	HDSPM_PREF_SYNC_REF("Preferred Sync Reference", 0),
 	HDSPM_AUTOSYNC_REF("AutoSync Reference", 0),
 	HDSPM_SYSTEM_SAMPLE_RATE("System Sample Rate", 0),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("External Rate", 0),
 	HDSPM_SYNC_CHECK("WC SyncCheck", 0),
 	HDSPM_SYNC_CHECK("MADI SyncCheck", 1),
 	HDSPM_SYNC_CHECK("TCO SyncCHeck", 2),

commit d681deaa74748ce1d4b1a862438c955b70f46690
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Oct 19 17:42:25 2012 +0200

    ALSA: hdspm - Fix reported autosync_sample_rate
    
    Missing breaks lead to a fall-through, thus causing the wrong
    autosync_sample_rate to be reported.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 81d83faab510..976e3a6b0508 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2180,6 +2180,7 @@ static int snd_hdspm_get_autosync_sample_rate(struct snd_kcontrol *kcontrol,
 				hdspm_get_s1_sample_rate(hdspm,
 						kcontrol->private_value-1);
 		}
+		break;
 
 	case AIO:
 		switch (kcontrol->private_value) {
@@ -2200,6 +2201,7 @@ static int snd_hdspm_get_autosync_sample_rate(struct snd_kcontrol *kcontrol,
 				hdspm_get_s1_sample_rate(hdspm,
 						ucontrol->id.index-1);
 		}
+		break;
 
 	case AES32:
 
@@ -2221,8 +2223,8 @@ static int snd_hdspm_get_autosync_sample_rate(struct snd_kcontrol *kcontrol,
 				hdspm_get_s1_sample_rate(hdspm,
 						kcontrol->private_value-1);
 			break;
-
 		}
+		break;
 	default:
 		break;
 	}

commit fba30fd342beda8e7908f214d9e7f8a62dcdc57d
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Oct 19 17:42:24 2012 +0200

    ALSA: hdspm - Fix sync check reporting on all RME HDSPM cards
    
    Due to missing breaks and the resulting fall-through, card subtype
    selection was effectively missing, thus causing the wrong sync check
    functions to be called.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 1131a8ab3f73..81d83faab510 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3959,6 +3959,7 @@ static int snd_hdspm_get_sync_check(struct snd_kcontrol *kcontrol,
 		default:
 			val = hdspm_s1_sync_check(hdspm, ucontrol->id.index-1);
 		}
+		break;
 
 	case AIO:
 		switch (kcontrol->private_value) {
@@ -3971,6 +3972,7 @@ static int snd_hdspm_get_sync_check(struct snd_kcontrol *kcontrol,
 		default:
 			val = hdspm_s1_sync_check(hdspm, ucontrol->id.index-1);
 		}
+		break;
 
 	case MADI:
 		switch (kcontrol->private_value) {
@@ -3983,6 +3985,7 @@ static int snd_hdspm_get_sync_check(struct snd_kcontrol *kcontrol,
 		case 3: /* SYNC_IN */
 			val = hdspm_sync_in_sync_check(hdspm); break;
 		}
+		break;
 
 	case MADIface:
 		val = hdspm_madi_sync_check(hdspm); /* MADI */
@@ -4000,6 +4003,7 @@ static int snd_hdspm_get_sync_check(struct snd_kcontrol *kcontrol,
 			 val = hdspm_aes_sync_check(hdspm,
 					 kcontrol->private_value-1);
 		}
+		break;
 
 	}
 

commit 21a164df0c1c2e72d4bb78b2f67dc75a1c9d14fb
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Oct 19 17:42:23 2012 +0200

    ALSA: hdspm - Report external rate in slave mode on PCI MADI
    
    As a follow-up to a97bda7d29d02a2e9c6609d0947b15e55f5200e5, report the
    external sample rate as system_sample_rate when in slave mode.
    
    For PCIe MADI cards, the DDS value automatically contains the external
    sample rate, but the PCI version needs this manual workaround.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 742bd5e430ab..1131a8ab3f73 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -971,6 +971,7 @@ static inline void snd_hdspm_initialize_midi_flush(struct hdspm *hdspm);
 static int hdspm_update_simple_mixer_controls(struct hdspm *hdspm);
 static int hdspm_autosync_ref(struct hdspm *hdspm);
 static int snd_hdspm_set_defaults(struct hdspm *hdspm);
+static int hdspm_system_clock_mode(struct hdspm *hdspm);
 static void hdspm_set_sgbuf(struct hdspm *hdspm,
 			    struct snd_pcm_substream *substream,
 			     unsigned int reg, int channels);
@@ -1989,10 +1990,14 @@ static int hdspm_get_system_sample_rate(struct hdspm *hdspm)
 	rate = hdspm_calc_dds_value(hdspm, period);
 
 	if (rate > 207000) {
-		/* Unreasonable high sample rate as seen on PCI MADI cards.
-		 * Use the cached value instead.
-		 */
-		rate = hdspm->system_sample_rate;
+		/* Unreasonable high sample rate as seen on PCI MADI cards. */
+		if (0 == hdspm_system_clock_mode(hdspm)) {
+			/* master mode, return internal sample rate */
+			rate = hdspm->system_sample_rate;
+		} else {
+			/* slave mode, return external sample rate */
+			rate = hdspm_external_sample_rate(hdspm);
+		}
 	}
 
 	return rate;

commit 41285a98f8f052b59f01bbbcb0064e5e41b0ca2d
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Oct 19 17:42:22 2012 +0200

    ALSA: hdspm - Allow DDS/Varispeed to be set from userspace
    
    The DDS value is the actual physical sample rate. We set it indirectly
    when selecting 44100, 48000 and so on via snd_hdspm_hw_params or
    hdspm_set_clock_source.
    
    This commit now allows the DDS value to be altered at runtime, thus
    speeding up or slowing down the physical sample rate. This is required
    for MADI's varispeed that allows for ±12.5% speed adjustment from the
    "selected" rate (32kHz, 44100kHz, 48kHz and so on).
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index b12308b5ba2a..742bd5e430ab 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2003,8 +2003,10 @@ static int hdspm_get_system_sample_rate(struct hdspm *hdspm)
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
-  .access = SNDRV_CTL_ELEM_ACCESS_READ, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\
+	SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
   .info = snd_hdspm_info_system_sample_rate, \
+  .put = snd_hdspm_put_system_sample_rate, \
   .get = snd_hdspm_get_system_sample_rate \
 }
 
@@ -2030,6 +2032,16 @@ static int snd_hdspm_get_system_sample_rate(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+static int snd_hdspm_put_system_sample_rate(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_value *
+					    ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	hdspm_set_dds_value(hdspm, ucontrol->value.enumerated.item[0]);
+	return 0;
+}
+
 
 /**
  * Returns the WordClock sample rate class for the given card.

commit b17cbdd85f84c8323189416da6e9701d2793b0e5
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Aug 19 09:02:54 2012 +0200

    ALSA: sound/pci/rme9652/hdspm.c: fix error return code
    
    Convert a nonnegative error return code to a negative one, as returned
    elsewhere in the function.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    (
    if@p1 (\(ret < 0\|ret != 0\))
     { ... return ret; }
    |
    ret@p1 = 0
    )
    ... when != ret = e1
        when != &ret
    *if(...)
    {
      ... when != ret = e2
          when forall
     return ret;
    }
    
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index b8ac8710f47f..b12308b5ba2a 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6585,7 +6585,7 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 		snd_printk(KERN_ERR "HDSPM: "
 				"unable to kmalloc Mixer memory of %d Bytes\n",
 				(int)sizeof(struct hdspm_mixer));
-		return err;
+		return -ENOMEM;
 	}
 
 	hdspm->port_names_in = NULL;

commit a97bda7d29d02a2e9c6609d0947b15e55f5200e5
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Wed May 30 14:23:18 2012 +0200

    ALSA: hdspm - Work around broken DDS value on PCI RME MADI
    
    On PCI RME MADI cards, the PLL register does not contain the proper
    value, so the calculated system_sample_rate is wrong. In this case, we
    simply return the cached rate from struct hdspm.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 0a5027b94714..b8ac8710f47f 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1988,6 +1988,13 @@ static int hdspm_get_system_sample_rate(struct hdspm *hdspm)
 	period = hdspm_read(hdspm, HDSPM_RD_PLL_FREQ);
 	rate = hdspm_calc_dds_value(hdspm, period);
 
+	if (rate > 207000) {
+		/* Unreasonable high sample rate as seen on PCI MADI cards.
+		 * Use the cached value instead.
+		 */
+		rate = hdspm->system_sample_rate;
+	}
+
 	return rate;
 }
 

commit e9f66d9b9ce03f74a52894cebedf12b67f65dd24
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Apr 24 12:25:00 2012 +0200

    ALSA: pci: clean up using module_pci_driver()
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index bc030a2088da..0a5027b94714 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6918,23 +6918,11 @@ static void __devexit snd_hdspm_remove(struct pci_dev *pci)
 	pci_set_drvdata(pci, NULL);
 }
 
-static struct pci_driver driver = {
+static struct pci_driver hdspm_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = snd_hdspm_ids,
 	.probe = snd_hdspm_probe,
 	.remove = __devexit_p(snd_hdspm_remove),
 };
 
-
-static int __init alsa_card_hdspm_init(void)
-{
-	return pci_register_driver(&driver);
-}
-
-static void __exit alsa_card_hdspm_exit(void)
-{
-	pci_unregister_driver(&driver);
-}
-
-module_init(alsa_card_hdspm_init)
-module_exit(alsa_card_hdspm_exit)
+module_pci_driver(hdspm_driver);

commit 8de5d6f19bbe7c77676a62ab52be901aa10d6b54
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Thu Mar 8 15:38:04 2012 +0100

    ALSA: hdspm - Provide ioctl_compat
    
    snd_hdspm uses its own ioctls to acquire config- and status information.
    Expose the corresponding ioctl handler via ioctl_compat, so that 32bit
    applications can use it on 64bit kernels.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index cc9f6c83d661..bc030a2088da 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6333,6 +6333,7 @@ static int __devinit snd_hdspm_create_hwdep(struct snd_card *card,
 
 	hw->ops.open = snd_hdspm_hwdep_dummy_op;
 	hw->ops.ioctl = snd_hdspm_hwdep_ioctl;
+	hw->ops.ioctl_compat = snd_hdspm_hwdep_ioctl;
 	hw->ops.release = snd_hdspm_hwdep_dummy_op;
 
 	return 0;

commit f7de8ba3fcf19487d2f0af9aee0c510fc79efa15
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Tue Jan 10 20:58:40 2012 +0100

    ALSA: hdspm - Provide unique driver id based on card serial
    
    Before, /proc/asound looked like this:
    
     2 [Default        ]: HDSPM - RME RayDAT_f1cd85
                          RME RayDAT S/N 0xf1cd85 at 0xf7300000, irq 18
    
    In case of a second HDSPM card, its name would be Default_1. This is
    cumbersome, because the order of the cards isn't stable across reboots.
    
    To help userspace tools referring to the correct card, this commit
    provides a unique id for each card:
    
     2 [HDSPMxf1cd85   ]: HDSPM - RME RayDAT_f1cd85
                          RME RayDAT S/N 0xf1cd85 at 0xf7300000, irq 18
    
    In this example, userspace (configuration files) would then use
    hw:HDSPMxf1cd85 to choose the right card.
    
    The serial is masked to 24bits, so this string is always shorter than
    sixteen chars.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 16092538e0bb..cc9f6c83d661 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6783,6 +6783,25 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 	tasklet_init(&hdspm->midi_tasklet,
 			hdspm_midi_tasklet, (unsigned long) hdspm);
 
+
+	if (hdspm->io_type != MADIface) {
+		hdspm->serial = (hdspm_read(hdspm,
+				HDSPM_midiStatusIn0)>>8) & 0xFFFFFF;
+		/* id contains either a user-provided value or the default
+		 * NULL. If it's the default, we're safe to
+		 * fill card->id with the serial number.
+		 *
+		 * If the serial number is 0xFFFFFF, then we're dealing with
+		 * an old PCI revision that comes without a sane number. In
+		 * this case, we don't set card->id to avoid collisions
+		 * when running with multiple cards.
+		 */
+		if (NULL == id[hdspm->dev] && hdspm->serial != 0xFFFFFF) {
+			sprintf(card->id, "HDSPMx%06x", hdspm->serial);
+			snd_card_set_id(card, card->id);
+		}
+	}
+
 	snd_printdd("create alsa devices.\n");
 	err = snd_hdspm_create_alsa_devices(card, hdspm);
 	if (err < 0)
@@ -6867,8 +6886,6 @@ static int __devinit snd_hdspm_probe(struct pci_dev *pci,
 	}
 
 	if (hdspm->io_type != MADIface) {
-		hdspm->serial = (hdspm_read(hdspm,
-				HDSPM_midiStatusIn0)>>8) & 0xFFFFFF;
 		sprintf(card->shortname, "%s_%x",
 			hdspm->card_name,
 			hdspm->serial);

commit 7d53a631ed92abd19d3c948a5daa535e53bd2bff
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Wed Jan 4 14:31:16 2012 +0100

    ALSA: hdspm - Refactor serial number to avoid code duplication
    
    The serial number is used multiple times in hdspm.c. Since it belongs
    to the card, let's store it in struct hdspm and refer to it whenever
    necessary.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index d623451cbf46..16092538e0bb 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -941,6 +941,8 @@ struct hdspm {
 
 	cycles_t last_interrupt;
 
+	unsigned int serial;
+
 	struct hdspm_peak_rms peak_rms;
 };
 
@@ -4694,7 +4696,7 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 
 	snd_iprintf(buffer, "HW Serial: 0x%06x%06x\n",
 			(hdspm_read(hdspm, HDSPM_midiStatusIn1)>>8) & 0xFFFFFF,
-			(hdspm_read(hdspm, HDSPM_midiStatusIn0)>>8) & 0xFFFFFF);
+			hdspm->serial);
 
 	snd_iprintf(buffer, "IRQ: %d Registers bus: 0x%lx VM: 0x%lx\n",
 			hdspm->irq, hdspm->port, (unsigned long)hdspm->iobase);
@@ -6266,8 +6268,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 		hdspm_version.card_type = hdspm->io_type;
 		strncpy(hdspm_version.cardname, hdspm->card_name,
 				sizeof(hdspm_version.cardname));
-		hdspm_version.serial = (hdspm_read(hdspm,
-					HDSPM_midiStatusIn0)>>8) & 0xFFFFFF;
+		hdspm_version.serial = hdspm->serial;
 		hdspm_version.firmware_rev = hdspm->firmware_rev;
 		hdspm_version.addons = 0;
 		if (hdspm->tco)
@@ -6866,12 +6867,14 @@ static int __devinit snd_hdspm_probe(struct pci_dev *pci,
 	}
 
 	if (hdspm->io_type != MADIface) {
+		hdspm->serial = (hdspm_read(hdspm,
+				HDSPM_midiStatusIn0)>>8) & 0xFFFFFF;
 		sprintf(card->shortname, "%s_%x",
 			hdspm->card_name,
-			(hdspm_read(hdspm, HDSPM_midiStatusIn0)>>8) & 0xFFFFFF);
+			hdspm->serial);
 		sprintf(card->longname, "%s S/N 0x%x at 0x%lx, irq %d",
 			hdspm->card_name,
-			(hdspm_read(hdspm, HDSPM_midiStatusIn0)>>8) & 0xFFFFFF,
+			hdspm->serial,
 			hdspm->port, hdspm->irq);
 	} else {
 		sprintf(card->shortname, "%s", hdspm->card_name);

commit a67ff6a54095e27093ea501fb143fefe51a536c2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 15 13:49:36 2011 +1030

    ALSA: module_param: make bool parameters really bool
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 19ee2203cbb5..d623451cbf46 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -61,7 +61,7 @@
 
 static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	  /* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	  /* ID for this card */
-static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */
+static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for RME HDSPM interface.");

commit 05c7cc9ccab7d9229fdae68d7d6231edd2c93741
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Nov 21 16:15:36 2011 +0100

    ALSA: hdspm - Fix PCI ID for PCIe RME MADI cards
    
    Commit c09403dcc5698abf214329fbbf3cf8dbb5558bea has introduced a
    regression: PCIe versions of RME MADI were no longer detected, because
    the MADIface ID (0xd5) was used instead of the correct 0xd2.
    
    This commit fixes the problem.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index e760adad9523..19ee2203cbb5 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6518,7 +6518,7 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 			hdspm->io_type = AES32;
 			hdspm->card_name = "RME AES32";
 			hdspm->midiPorts = 2;
-		} else if ((hdspm->firmware_rev == 0xd5) ||
+		} else if ((hdspm->firmware_rev == 0xd2) ||
 			((hdspm->firmware_rev >= 0xc8)  &&
 				(hdspm->firmware_rev <= 0xcf))) {
 			hdspm->io_type = MADI;

commit 32aaeffbd4a7457bf2f7448b33b5946ff2a960eb
Merge: 208bca086040 67b84999b1a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 6 19:44:47 2011 -0800

    Merge branch 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    * 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux: (230 commits)
      Revert "tracing: Include module.h in define_trace.h"
      irq: don't put module.h into irq.h for tracking irqgen modules.
      bluetooth: macroize two small inlines to avoid module.h
      ip_vs.h: fix implicit use of module_get/module_put from module.h
      nf_conntrack.h: fix up fallout from implicit moduleparam.h presence
      include: replace linux/module.h with "struct module" wherever possible
      include: convert various register fcns to macros to avoid include chaining
      crypto.h: remove unused crypto_tfm_alg_modname() inline
      uwb.h: fix implicit use of asm/page.h for PAGE_SIZE
      pm_runtime.h: explicitly requires notifier.h
      linux/dmaengine.h: fix implicit use of bitmap.h and asm/page.h
      miscdevice.h: fix up implicit use of lists and types
      stop_machine.h: fix implicit use of smp.h for smp_processor_id
      of: fix implicit use of errno.h in include/linux/of.h
      of_platform.h: delete needless include <linux/module.h>
      acpi: remove module.h include from platform/aclinux.h
      miscdevice.h: delete unnecessary inclusion of module.h
      device_cgroup.h: delete needless include <linux/module.h>
      net: sch_generic remove redundant use of <linux/module.h>
      net: inet_timewait_sock doesnt need <linux/module.h>
      ...
    
    Fix up trivial conflicts (other header files, and  removal of the ab3550 mfd driver) in
     - drivers/media/dvb/frontends/dibx000_common.c
     - drivers/media/video/{mt9m111.c,ov6650.c}
     - drivers/mfd/ab3550-core.c
     - include/linux/dmaengine.h

commit 65a772172b06e6e9b43e5ad77dccbcc767ff9831
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 15 13:13:37 2011 -0400

    sound: fix drivers needing module.h not moduleparam.h
    
    The implicit presence of module.h lured several users into
    incorrectly thinking that they only needed/used modparam.h
    but once we clean up the module.h presence, these will show
    up as build failures, so fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 6e2f7ef7ddb1..a4e1cccd4473 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -41,7 +41,7 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
-#include <linux/moduleparam.h>
+#include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/pci.h>
 #include <linux/math64.h>

commit c09403dcc5698abf214329fbbf3cf8dbb5558bea
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Thu Oct 27 21:57:54 2011 +0200

    ALSA: hdspm - Enable all firmware ranges for PCI MADI/AES cards
    
    From the Windows INF file, we know the firmware ranges for all RME
    cards. For PCIe, a single revision ID per device (RayDAT, MADI, AIO,
    AES) is used. Contrary, the older PCI versions use ranges, that is,
    one revision ID per firmware version.
    
    Instead of listing all possible revisions individually, match the range.
    
    This commit enables all MADI and AES PCI versions ever shipped.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 60a0b7de8e57..15a6c3b9bc9a 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -520,16 +520,9 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_DMA_AREA_BYTES (HDSPM_MAX_CHANNELS * HDSPM_CHANNEL_BUFFER_BYTES)
 #define HDSPM_DMA_AREA_KILOBYTES (HDSPM_DMA_AREA_BYTES/1024)
 
-/* revisions >= 230 indicate AES32 card */
-#define HDSPM_MADI_ANCIENT_REV	204
-#define HDSPM_MADI_OLD_REV	207
-#define HDSPM_MADI_REV		210
 #define HDSPM_RAYDAT_REV	211
 #define HDSPM_AIO_REV		212
 #define HDSPM_MADIFACE_REV	213
-#define HDSPM_AES_REV		240
-#define HDSPM_AES32_REV		234
-#define HDSPM_AES32_OLD_REV	233
 
 /* speed factor modes */
 #define HDSPM_SPEED_SINGLE 0
@@ -6503,13 +6496,6 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 	strcpy(card->driver, "HDSPM");
 
 	switch (hdspm->firmware_rev) {
-	case HDSPM_MADI_REV:
-	case HDSPM_MADI_OLD_REV:
-	case HDSPM_MADI_ANCIENT_REV:
-		hdspm->io_type = MADI;
-		hdspm->card_name = "RME MADI";
-		hdspm->midiPorts = 3;
-		break;
 	case HDSPM_RAYDAT_REV:
 		hdspm->io_type = RayDAT;
 		hdspm->card_name = "RME RayDAT";
@@ -6525,17 +6511,25 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 		hdspm->card_name = "RME MADIface";
 		hdspm->midiPorts = 1;
 		break;
-	case HDSPM_AES_REV:
-	case HDSPM_AES32_REV:
-	case HDSPM_AES32_OLD_REV:
-		hdspm->io_type = AES32;
-		hdspm->card_name = "RME AES32";
-		hdspm->midiPorts = 2;
-		break;
 	default:
-		snd_printk(KERN_ERR "HDSPM: unknown firmware revision %x\n",
+		if ((hdspm->firmware_rev == 0xf0) ||
+			((hdspm->firmware_rev >= 0xe6) &&
+					(hdspm->firmware_rev <= 0xea))) {
+			hdspm->io_type = AES32;
+			hdspm->card_name = "RME AES32";
+			hdspm->midiPorts = 2;
+		} else if ((hdspm->firmware_rev == 0xd5) ||
+			((hdspm->firmware_rev >= 0xc8)  &&
+				(hdspm->firmware_rev <= 0xcf))) {
+			hdspm->io_type = MADI;
+			hdspm->card_name = "RME MADI";
+			hdspm->midiPorts = 3;
+		} else {
+			snd_printk(KERN_ERR
+				"HDSPM: unknown firmware revision %x\n",
 				hdspm->firmware_rev);
-		return -ENODEV;
+			return -ENODEV;
+		}
 	}
 
 	err = pci_enable_device(pci);

commit 9e6ff52088433e02426f860b0d40a5a0d4c8eb92
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Thu Oct 27 21:57:52 2011 +0200

    ALSA: hdspm - Fix MADI channel format in the status ioctl
    
    SNDRV_HDSPM_IOCTL_GET_STATUS is supposed to query the current card
    status, so we have to return what we receive on the MADI wire (RX), not
    what we transmit (TX) to others. The latter is a config item to be
    queried via SNDRV_HDSPM_IOCTL_GET_CONFIG.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 6e2f7ef7ddb1..60a0b7de8e57 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6253,7 +6253,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 			status.card_specific.madi.madi_input =
 				(statusregister & HDSPM_AB_int) ? 1 : 0;
 			status.card_specific.madi.channel_format =
-				(statusregister & HDSPM_TX_64ch) ? 1 : 0;
+				(statusregister & HDSPM_RX_64ch) ? 1 : 0;
 			/* TODO: Mac driver sets it when f_s>48kHz */
 			status.card_specific.madi.frame_format = 0;
 

commit 2ca595ab7a557f6cee21bf073fe2a242004cd19e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Sep 23 09:25:05 2011 +0300

    ALSA: hdspm - cleanup __user tags in ioctl()
    
    This makes the code cleaner and silences a Sparse complaint:
    sound/pci/rme9652/hdspm.c:6341:23: warning: incorrect type in assignment (incompatible argument 4 (different address spaces))
    sound/pci/rme9652/hdspm.c:6341:23:    expected int ( *ioctl )( ... )
    sound/pci/rme9652/hdspm.c:6341:23:    got int ( static [toplevel] *<noident> )( ... )
    sound/pci/rme9652/hdspm.c:6102:44: warning: dereference of noderef expression
    sound/pci/rme9652/hdspm.c:6225:50: warning: dereference of noderef expression
    sound/pci/rme9652/hdspm.c:6264:50: warning: dereference of noderef expression
    sound/pci/rme9652/hdspm.c:6283:50: warning: dereference of noderef expression
    sound/pci/rme9652/hdspm.c:6289:59: warning: dereference of noderef expression
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index bf438d121afe..6e2f7ef7ddb1 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6097,7 +6097,7 @@ static inline int copy_u32_le(void __user *dest, void __iomem *src)
 }
 
 static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
-		unsigned int cmd, unsigned long __user arg)
+		unsigned int cmd, unsigned long arg)
 {
 	void __user *argp = (void __user *)arg;
 	struct hdspm *hdspm = hw->private_data;
@@ -6222,7 +6222,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 		info.line_out = hdspm_line_out(hdspm);
 		info.passthru = 0;
 		spin_unlock_irq(&hdspm->lock);
-		if (copy_to_user((void __user *) arg, &info, sizeof(info)))
+		if (copy_to_user(argp, &info, sizeof(info)))
 			return -EFAULT;
 		break;
 
@@ -6261,7 +6261,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 			break;
 		}
 
-		if (copy_to_user((void __user *) arg, &status, sizeof(status)))
+		if (copy_to_user(argp, &status, sizeof(status)))
 			return -EFAULT;
 
 
@@ -6280,13 +6280,13 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 		if (hdspm->tco)
 			hdspm_version.addons |= HDSPM_ADDON_TCO;
 
-		if (copy_to_user((void __user *) arg, &hdspm_version,
+		if (copy_to_user(argp, &hdspm_version,
 					sizeof(hdspm_version)))
 			return -EFAULT;
 		break;
 
 	case SNDRV_HDSPM_IOCTL_GET_MIXER:
-		if (copy_from_user(&mixer, (void __user *)arg, sizeof(mixer)))
+		if (copy_from_user(&mixer, argp, sizeof(mixer)))
 			return -EFAULT;
 		if (copy_to_user((void __user *)mixer.mixer, hdspm->mixer,
 					sizeof(struct hdspm_mixer)))

commit 643d6bbb9637a9b4bb47ec1a1ae3adf3ff9d75a1
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Sep 23 09:24:21 2011 +0300

    ALSA: hdspm - potential info leak in snd_hdspm_hwdep_ioctl()
    
    Smatch has a new check for Rosenberg type information leaks where
    structs are copied to the user with uninitialized stack data in them.
    
    The status struct has a hole in it, and on some paths not all the
    members were initialized.
    
    struct hdspm_status {
            unsigned char              card_type;            /*     0     1 */
            /* XXX 3 bytes hole, try to pack */
            enum hdspm_syncsource      autosync_source;      /*     4     4 */
            long long unsigned int     card_clock;           /*     8     8 */
    
    The hdspm_version struct had holes in it as well.
    
    struct hdspm_version {
            unsigned char              card_type;            /*     0     1 */
            char                       cardname[20];         /*     1    20 */
            /* XXX 3 bytes hole, try to pack */
            unsigned int               serial;               /*    24     4 */
            short unsigned int         firmware_rev;         /*    28     2 */
            /* XXX 2 bytes hole, try to pack */
            int                        addons;               /*    32     4 */
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 214110d6a2bf..bf438d121afe 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6227,6 +6227,8 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 		break;
 
 	case SNDRV_HDSPM_IOCTL_GET_STATUS:
+		memset(&status, 0, sizeof(status));
+
 		status.card_type = hdspm->io_type;
 
 		status.autosync_source = hdspm_autosync_ref(hdspm);
@@ -6266,6 +6268,8 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 		break;
 
 	case SNDRV_HDSPM_IOCTL_GET_VERSION:
+		memset(&hdspm_version, 0, sizeof(hdspm_version));
+
 		hdspm_version.card_type = hdspm->io_type;
 		strncpy(hdspm_version.cardname, hdspm->card_name,
 				sizeof(hdspm_version.cardname));

commit d877681d2eab28ae2a7ff08bec9a6fe3b65973fb
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Aug 15 10:45:42 2011 +0200

    ALSA: hdspm - Simplify with snd_pcm_hw_constraint_pow2()
    
    Refactoring the code using snd_pcm_hw_constraint_pow2() helper function.
    
    Tested-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 4add485e6b16..214110d6a2bf 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -5705,19 +5705,6 @@ static int snd_hdspm_prepare(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static unsigned int period_sizes_old[] = {
-	64, 128, 256, 512, 1024, 2048, 4096, 8192
-};
-
-static unsigned int period_sizes_new[] = {
-	64, 128, 256, 512, 1024, 2048, 4096, 32
-};
-
-/* RayDAT and AIO always have a buffer of 16384 samples per channel */
-static unsigned int raydat_aio_buffer_sizes[] = {
-	16384
-};
-
 static struct snd_pcm_hardware snd_hdspm_playback_subinfo = {
 	.info = (SNDRV_PCM_INFO_MMAP |
 		 SNDRV_PCM_INFO_MMAP_VALID |
@@ -5768,24 +5755,6 @@ static struct snd_pcm_hardware snd_hdspm_capture_subinfo = {
 	.fifo_size = 0
 };
 
-static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes_old = {
-	.count = ARRAY_SIZE(period_sizes_old),
-	.list = period_sizes_old,
-	.mask = 0
-};
-
-static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes_new = {
-	.count = ARRAY_SIZE(period_sizes_new),
-	.list = period_sizes_new,
-	.mask = 0
-};
-
-static struct snd_pcm_hw_constraint_list hw_constraints_raydat_io_buffer = {
-	.count = ARRAY_SIZE(raydat_aio_buffer_sizes),
-	.list = raydat_aio_buffer_sizes,
-	.mask = 0
-};
-
 static int snd_hdspm_hw_rule_in_channels_rate(struct snd_pcm_hw_params *params,
 					   struct snd_pcm_hw_rule *rule)
 {
@@ -5986,23 +5955,25 @@ static int snd_hdspm_playback_open(struct snd_pcm_substream *substream)
 	spin_unlock_irq(&hdspm->lock);
 
 	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
+	snd_pcm_hw_constraint_pow2(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
 
 	switch (hdspm->io_type) {
 	case AIO:
 	case RayDAT:
-		snd_pcm_hw_constraint_list(runtime, 0,
-				SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
-				&hw_constraints_period_sizes_new);
-		snd_pcm_hw_constraint_list(runtime, 0,
-				SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
-				&hw_constraints_raydat_io_buffer);
-
+		snd_pcm_hw_constraint_minmax(runtime,
+					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+					     32, 4096);
+		/* RayDAT & AIO have a fixed buffer of 16384 samples per channel */
+		snd_pcm_hw_constraint_minmax(runtime,
+					     SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+					     16384, 16384);
 		break;
 
 	default:
-		snd_pcm_hw_constraint_list(runtime, 0,
-				SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
-				&hw_constraints_period_sizes_old);
+		snd_pcm_hw_constraint_minmax(runtime,
+					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+					     64, 8192);
+		break;
 	}
 
 	if (AES32 == hdspm->io_type) {
@@ -6059,21 +6030,24 @@ static int snd_hdspm_capture_open(struct snd_pcm_substream *substream)
 	spin_unlock_irq(&hdspm->lock);
 
 	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
+	snd_pcm_hw_constraint_pow2(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+
 	switch (hdspm->io_type) {
 	case AIO:
 	case RayDAT:
-	  snd_pcm_hw_constraint_list(runtime, 0,
-				     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
-				     &hw_constraints_period_sizes_new);
-	  snd_pcm_hw_constraint_list(runtime, 0,
-				     SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
-				     &hw_constraints_raydat_io_buffer);
-	  break;
+		snd_pcm_hw_constraint_minmax(runtime,
+					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+					     32, 4096);
+		snd_pcm_hw_constraint_minmax(runtime,
+					     SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+					     16384, 16384);
+		break;
 
 	default:
-	  snd_pcm_hw_constraint_list(runtime, 0,
-				     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
-				     &hw_constraints_period_sizes_old);
+		snd_pcm_hw_constraint_minmax(runtime,
+					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+					     64, 8192);
+		break;
 	}
 
 	if (AES32 == hdspm->io_type) {

commit 3fa9e3d230911272eaf1c3856f5483b0af3903f3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Aug 15 10:42:23 2011 +0200

    ALSA: hdspm - Add missing KNOT flag for AES32 rate restriction
    
    AES32 supports the non-standard 128kHZ, and this is enabled only when
    SNDRV_PCM_RATE_KNOT is set in hw.rates field.
    
    Tested-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index c33f4a5c5241..4add485e6b16 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6006,6 +6006,7 @@ static int snd_hdspm_playback_open(struct snd_pcm_substream *substream)
 	}
 
 	if (AES32 == hdspm->io_type) {
+		runtime->hw.rates |= SNDRV_PCM_RATE_KNOT;
 		snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
 				&hdspm_hw_constraints_aes32_sample_rates);
 	} else {
@@ -6076,6 +6077,7 @@ static int snd_hdspm_capture_open(struct snd_pcm_substream *substream)
 	}
 
 	if (AES32 == hdspm->io_type) {
+		runtime->hw.rates |= SNDRV_PCM_RATE_KNOT;
 		snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
 				&hdspm_hw_constraints_aes32_sample_rates);
 	} else {

commit 52e6fb48121a552d11ea0eb05540178fb3ac4e15
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Aug 15 10:40:59 2011 +0200

    ALSA: hdspm - Correct max buffer size limit
    
    Some modesl can support up to 8192 frames per period.
    
    Tested-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 92ac64ced29a..c33f4a5c5241 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -5737,7 +5737,7 @@ static struct snd_pcm_hardware snd_hdspm_playback_subinfo = {
 	.buffer_bytes_max =
 	    HDSPM_CHANNEL_BUFFER_BYTES * HDSPM_MAX_CHANNELS,
 	.period_bytes_min = (32 * 4),
-	.period_bytes_max = (4096 * 4) * HDSPM_MAX_CHANNELS,
+	.period_bytes_max = (8192 * 4) * HDSPM_MAX_CHANNELS,
 	.periods_min = 2,
 	.periods_max = 512,
 	.fifo_size = 0
@@ -5762,7 +5762,7 @@ static struct snd_pcm_hardware snd_hdspm_capture_subinfo = {
 	.buffer_bytes_max =
 	    HDSPM_CHANNEL_BUFFER_BYTES * HDSPM_MAX_CHANNELS,
 	.period_bytes_min = (32 * 4),
-	.period_bytes_max = (4096 * 4) * HDSPM_MAX_CHANNELS,
+	.period_bytes_max = (8192 * 4) * HDSPM_MAX_CHANNELS,
 	.periods_min = 2,
 	.periods_max = 512,
 	.fifo_size = 0

commit 2e61027079ed70f54fec41ddb8fa8af37d79d8d8
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Aug 15 00:22:54 2011 +0200

    ALSA: hdspm - Enable 32 samples/period on RME RayDAT/AIO
    
    Newer RME cards like RayDAT and AIO support 32 samples per period. This
    value is encoded as {1,1,1} in the HDSP_LatencyMask bits in the control
    register.
    
    Since {1,1,1} is also the representation for 8192 samples/period on
    older RME cards, we have to special case 32 samples and 32768 bytes
    according to the actual card.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 1a52a1ae1f4c..92ac64ced29a 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1323,12 +1323,27 @@ static int hdspm_set_interrupt_interval(struct hdspm *s, unsigned int frames)
 
 	spin_lock_irq(&s->lock);
 
-	frames >>= 7;
-	n = 0;
-	while (frames) {
-		n++;
-		frames >>= 1;
+	if (32 == frames) {
+		/* Special case for new RME cards like RayDAT/AIO which
+		 * support period sizes of 32 samples. Since latency is
+		 * encoded in the three bits of HDSP_LatencyMask, we can only
+		 * have values from 0 .. 7. While 0 still means 64 samples and
+		 * 6 represents 4096 samples on all cards, 7 represents 8192
+		 * on older cards and 32 samples on new cards.
+		 *
+		 * In other words, period size in samples is calculated by
+		 * 2^(n+6) with n ranging from 0 .. 7.
+		 */
+		n = 7;
+	} else {
+		frames >>= 7;
+		n = 0;
+		while (frames) {
+			n++;
+			frames >>= 1;
+		}
 	}
+
 	s->control_register &= ~HDSPM_LatencyMask;
 	s->control_register |= hdspm_encode_latency(n);
 

commit 7cb155ff3e4645188c42d707300e36cfce44e28a
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Aug 15 00:22:53 2011 +0200

    ALSA: hdspm - Introduce hdspm_get_latency() to harmonize latency calculation
    
    Currently, hdspm_decode_latency is called several times, violating the
    DRY principle. Given that we need to distinguish between old and new
    cards when decoding the latency bits in the control register, introduce
    hdspm_get_latency() to provide the required functionality.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 159133a14464..1a52a1ae1f4c 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1241,10 +1241,30 @@ static int hdspm_external_sample_rate(struct hdspm *hdspm)
 	return rate;
 }
 
+/* return latency in samples per period */
+static int hdspm_get_latency(struct hdspm *hdspm)
+{
+	int n;
+
+	n = hdspm_decode_latency(hdspm->control_register);
+
+	/* Special case for new RME cards with 32 samples period size.
+	 * The three latency bits in the control register
+	 * (HDSP_LatencyMask) encode latency values of 64 samples as
+	 * 0, 128 samples as 1 ... 4096 samples as 6. For old cards, 7
+	 * denotes 8192 samples, but on new cards like RayDAT or AIO,
+	 * it corresponds to 32 samples.
+	 */
+	if ((7 == n) && (RayDAT == hdspm->io_type || AIO == hdspm->io_type))
+		n = -1;
+
+	return 1 << (n + 6);
+}
+
 /* Latency function */
 static inline void hdspm_compute_period_size(struct hdspm *hdspm)
 {
-	hdspm->period_bytes = 1 << ((hdspm_decode_latency(hdspm->control_register) + 8));
+	hdspm->period_bytes = 4 * hdspm_get_latency(hdspm);
 }
 
 
@@ -4801,8 +4821,7 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 
 	snd_iprintf(buffer, "--- Settings ---\n");
 
-	x = 1 << (6 + hdspm_decode_latency(hdspm->control_register &
-							HDSPM_LatencyMask));
+	x = hdspm_get_latency(hdspm);
 
 	snd_iprintf(buffer,
 		"Size (Latency): %d samples (2 periods of %lu bytes)\n",
@@ -4965,8 +4984,7 @@ snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
 
 	snd_iprintf(buffer, "--- Settings ---\n");
 
-	x = 1 << (6 + hdspm_decode_latency(hdspm->control_register &
-				HDSPM_LatencyMask));
+	x = hdspm_get_latency(hdspm);
 
 	snd_iprintf(buffer,
 		    "Size (Latency): %d samples (2 periods of %lu bytes)\n",

commit 1ad5972f71f94d8a8b5b683dd5f81a52a4ddf54c
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Aug 15 00:22:52 2011 +0200

    ALSA: hdspm - Reorder period sizes according to their bit representation
    
    On newer RME cards like RayDAT and AIO, the 8192 samples per period size
    are no longer supported. Instead, setting all three bits of
    HDSP_LatencyMask to one ({1,1,1}) now corresponds to 32 samples per
    period.
    
    To make this more obvious to future developers, let's reorder the array
    according to their bit representation, starting at 64 ({0,0,0}) up to
    4096 ({1,1,0}) and finally 32 ({1,1,1}).
    
    Note that this patch doesn't change semantics.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 8dc2a894f6f7..159133a14464 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -5677,7 +5677,7 @@ static unsigned int period_sizes_old[] = {
 };
 
 static unsigned int period_sizes_new[] = {
-	32, 64, 128, 256, 512, 1024, 2048, 4096
+	64, 128, 256, 512, 1024, 2048, 4096, 32
 };
 
 /* RayDAT and AIO always have a buffer of 16384 samples per channel */

commit 1b6fa108b33f4a3e3999563e830daff39d332f70
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Aug 15 00:22:51 2011 +0200

    ALSA: hdspm - Set period_bytes_min to 32 * 4 for new RME cards
    
    On newer RME cards like RayDAT and AIO, the lower bound is 32 samples
    per period in contrast to 64 samples as seen on older cards.
    
    We hence lower period_bytes_min to 32 * 4. Four bytes per sample.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 204e1ced16a7..8dc2a894f6f7 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -5703,7 +5703,7 @@ static struct snd_pcm_hardware snd_hdspm_playback_subinfo = {
 	.channels_max = HDSPM_MAX_CHANNELS,
 	.buffer_bytes_max =
 	    HDSPM_CHANNEL_BUFFER_BYTES * HDSPM_MAX_CHANNELS,
-	.period_bytes_min = (64 * 4),
+	.period_bytes_min = (32 * 4),
 	.period_bytes_max = (4096 * 4) * HDSPM_MAX_CHANNELS,
 	.periods_min = 2,
 	.periods_max = 512,
@@ -5728,7 +5728,7 @@ static struct snd_pcm_hardware snd_hdspm_capture_subinfo = {
 	.channels_max = HDSPM_MAX_CHANNELS,
 	.buffer_bytes_max =
 	    HDSPM_CHANNEL_BUFFER_BYTES * HDSPM_MAX_CHANNELS,
-	.period_bytes_min = (64 * 4),
+	.period_bytes_min = (32 * 4),
 	.period_bytes_max = (4096 * 4) * HDSPM_MAX_CHANNELS,
 	.periods_min = 2,
 	.periods_max = 512,

commit 135d1535f4619ce74e46b9268c4a7899bc531cb1
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Aug 15 00:22:50 2011 +0200

    ALSA: hdspm - Allow for 8192 period size on RME MADI and AES cards
    
    Older RME cards like MADI and AES support period sizes of 8192 samples.
    The original hdspm driver already featured this value, apparently, it
    was lost during the rewrite.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 493e3946756f..204e1ced16a7 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -5673,7 +5673,7 @@ static int snd_hdspm_prepare(struct snd_pcm_substream *substream)
 }
 
 static unsigned int period_sizes_old[] = {
-	64, 128, 256, 512, 1024, 2048, 4096
+	64, 128, 256, 512, 1024, 2048, 4096, 8192
 };
 
 static unsigned int period_sizes_new[] = {

commit 3d56c8e6b039f2bc1d7c62d3b19e696c3129c8c0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 5 12:30:12 2011 +0200

    ALSA: hdspm - Fix uninitialized compile warnings
    
    Put the exception checks for io_type switch() for possible mistakes in
    future.  Also this shuts up annoying compile warnings.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 6edc67ced905..493e3946756f 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1339,6 +1339,10 @@ static u64 hdspm_calc_dds_value(struct hdspm *hdspm, u64 period)
 		break;
 	case MADIface:
 		freq_const = 131072000000000ULL;
+		break;
+	default:
+		snd_BUG();
+		return 0;
 	}
 
 	return div_u64(freq_const, period);
@@ -1356,16 +1360,19 @@ static void hdspm_set_dds_value(struct hdspm *hdspm, int rate)
 
 	switch (hdspm->io_type) {
 	case MADIface:
-	  n = 131072000000000ULL;  /* 125 MHz */
-	  break;
+		n = 131072000000000ULL;  /* 125 MHz */
+		break;
 	case MADI:
 	case AES32:
-	  n = 110069313433624ULL;  /* 105 MHz */
-	  break;
+		n = 110069313433624ULL;  /* 105 MHz */
+		break;
 	case RayDAT:
 	case AIO:
-	  n = 104857600000000ULL;  /* 100 MHz */
-	  break;
+		n = 104857600000000ULL;  /* 100 MHz */
+		break;
+	default:
+		snd_BUG();
+		return;
 	}
 
 	n = div_u64(n, rate);

commit 5f8b4d53d7efe00ecb7d96c8cc0b4a44e130f174
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 29 03:11:04 2011 +0200

    ALSA: hdspm - Add firmware revision 0xcc for RME MADI
    
    Apparently, there are multiple old firmware revisions in the wild for
    the PCI RME MADI cards. Just add them to the list of supported devices
    and treat them like their modern counterparts.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 88ae27431cb2..6edc67ced905 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -521,6 +521,7 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_DMA_AREA_KILOBYTES (HDSPM_DMA_AREA_BYTES/1024)
 
 /* revisions >= 230 indicate AES32 card */
+#define HDSPM_MADI_ANCIENT_REV	204
 #define HDSPM_MADI_OLD_REV	207
 #define HDSPM_MADI_REV		210
 #define HDSPM_RAYDAT_REV	211
@@ -6484,6 +6485,7 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 	switch (hdspm->firmware_rev) {
 	case HDSPM_MADI_REV:
 	case HDSPM_MADI_OLD_REV:
+	case HDSPM_MADI_ANCIENT_REV:
 		hdspm->io_type = MADI;
 		hdspm->card_name = "RME MADI";
 		hdspm->midiPorts = 3;

commit d12c51d8299667464e31d545acc4ebb7031d024c
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 29 03:11:03 2011 +0200

    ALSA: hdspm - Fix reported external sample rate on RME MADI and MADIface
    
    In slave mode, the card can only detect the base frequency (32..48kHz)
    on the MADI link (exception: 96k frames), so the real external sample
    rate is this base frequency multiplied by 1, 2 or 4 depending on the
    speed mode.
    
    This patch enables 64..192kHz sample rates in clock slave mode, which
    failed before due to an alleged sample rate mismatch between the MADI
    link (e.g., 48kHz) and the application in DS/QS mode (e.g., 96kHz,
    192kHz).
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index d21964994168..88ae27431cb2 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1217,6 +1217,22 @@ static int hdspm_external_sample_rate(struct hdspm *hdspm)
 				rate = 0;
 				break;
 			}
+
+			/* QS and DS rates normally can not be detected
+			 * automatically by the card. Only exception is MADI
+			 * in 96k frame mode.
+			 *
+			 * So if we read SS values (32 .. 48k), check for
+			 * user-provided DS/QS bits in the control register
+			 * and multiply the base frequency accordingly.
+			 */
+			if (rate <= 48000) {
+				if (hdspm->control_register & HDSPM_QuadSpeed)
+					rate *= 4;
+				else if (hdspm->control_register &
+						HDSPM_DoubleSpeed)
+					rate *= 2;
+			}
 		}
 		break;
 	}

commit 700d1ef33ff1d9a582b4a1dc23a130049f239942
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Fri Jul 29 03:11:02 2011 +0200

    ALSA: hdspm - Provide MADI speed mode selector on RME MADI and MADIface
    
    When running in slave mode (no clock master), there is no way to
    determine the real wirespeed on the MADI link (single/double/quad
    speed). Like physical gear, simply provide the user with a tristate
    switch to select the appropriate format.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index af130ee0c45d..d21964994168 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3415,6 +3415,91 @@ static int snd_hdspm_put_qs_wire(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
+#define HDSPM_MADI_SPEEDMODE(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.info = snd_hdspm_info_madi_speedmode, \
+	.get = snd_hdspm_get_madi_speedmode, \
+	.put = snd_hdspm_put_madi_speedmode \
+}
+
+static int hdspm_madi_speedmode(struct hdspm *hdspm)
+{
+	if (hdspm->control_register & HDSPM_QuadSpeed)
+		return 2;
+	if (hdspm->control_register & HDSPM_DoubleSpeed)
+		return 1;
+	return 0;
+}
+
+static int hdspm_set_madi_speedmode(struct hdspm *hdspm, int mode)
+{
+	hdspm->control_register &= ~(HDSPM_DoubleSpeed | HDSPM_QuadSpeed);
+	switch (mode) {
+	case 0:
+		break;
+	case 1:
+		hdspm->control_register |= HDSPM_DoubleSpeed;
+		break;
+	case 2:
+		hdspm->control_register |= HDSPM_QuadSpeed;
+		break;
+	}
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_madi_speedmode(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_info *uinfo)
+{
+	static char *texts[] = { "Single", "Double", "Quad" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 3;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+
+	return 0;
+}
+
+static int snd_hdspm_get_madi_speedmode(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.enumerated.item[0] = hdspm_madi_speedmode(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_madi_speedmode(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0];
+	if (val < 0)
+		val = 0;
+	if (val > 2)
+		val = 2;
+	spin_lock_irq(&hdspm->lock);
+	change = val != hdspm_madi_speedmode(hdspm);
+	hdspm_set_madi_speedmode(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
 
 #define HDSPM_MIXER(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
@@ -4289,7 +4374,8 @@ static struct snd_kcontrol_new snd_hdspm_controls_madi[] = {
 	HDSPM_TX_64("TX 64 channels mode", 0),
 	HDSPM_C_TMS("Clear Track Marker", 0),
 	HDSPM_SAFE_MODE("Safe Mode", 0),
-	HDSPM_INPUT_SELECT("Input Select", 0)
+	HDSPM_INPUT_SELECT("Input Select", 0),
+	HDSPM_MADI_SPEEDMODE("MADI Speed Mode", 0)
 };
 
 
@@ -4302,7 +4388,8 @@ static struct snd_kcontrol_new snd_hdspm_controls_madiface[] = {
 	HDSPM_SYNC_CHECK("MADI SyncCheck", 0),
 	HDSPM_TX_64("TX 64 channels mode", 0),
 	HDSPM_C_TMS("Clear Track Marker", 0),
-	HDSPM_SAFE_MODE("Safe Mode", 0)
+	HDSPM_SAFE_MODE("Safe Mode", 0),
+	HDSPM_MADI_SPEEDMODE("MADI Speed Mode", 0)
 };
 
 static struct snd_kcontrol_new snd_hdspm_controls_aio[] = {

commit 7d339ae99758bc21033d4a19bcd4f7b55f96e24e
Merge: 13b137ef0367 000477a0fe1a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jul 22 08:43:24 2011 +0200

    Merge branch 'topic/misc' into for-linus

commit 286bed0f0c447b6660e72093d7e778784fdd9ee6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jun 30 12:45:36 2011 +0200

    ALSA: hdspm - Fix compile warnings with PPC
    
    The char can be unsigned on some architectures.  Since the code checks
    the negative values, they should be declared as signed char explicitly.
    
      sound/pci/rme9652/hdspm.c:5449: warning: comparison is always false due to limited range of data type
      sound/pci/rme9652/hdspm.c:5462: warning: comparison is always false due to limited range of data type
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 3f08afc0f0d3..c8e402fc3782 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -896,11 +896,11 @@ struct hdspm {
 	unsigned char max_channels_in;
 	unsigned char max_channels_out;
 
-	char *channel_map_in;
-	char *channel_map_out;
+	signed char *channel_map_in;
+	signed char *channel_map_out;
 
-	char *channel_map_in_ss, *channel_map_in_ds, *channel_map_in_qs;
-	char *channel_map_out_ss, *channel_map_out_ds, *channel_map_out_qs;
+	signed char *channel_map_in_ss, *channel_map_in_ds, *channel_map_in_qs;
+	signed char *channel_map_out_ss, *channel_map_out_ds, *channel_map_out_qs;
 
 	char **port_names_in;
 	char **port_names_out;

commit 85e4d95da091e35209338962eca232e70819a485
Merge: b028b81835d7 ce1fd36932f2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jun 14 08:56:42 2011 +0200

    Merge branch 'test/pci-rename' into topic/misc

commit efef054e8c4bc4fd48a0b4deb5491116d9f557c7
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Sun Jun 12 17:26:19 2011 +0200

    ALSA: hdspm - Add firmware revision ID for RME MADI PCI version
    
    The PCI version of the RME HDSP MADI card uses 0xcf as revision ID. Just
    add this to the list of supported cards.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index d03ef94d570e..3f08afc0f0d3 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -521,6 +521,7 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_DMA_AREA_KILOBYTES (HDSPM_DMA_AREA_BYTES/1024)
 
 /* revisions >= 230 indicate AES32 card */
+#define HDSPM_MADI_OLD_REV	207
 #define HDSPM_MADI_REV		210
 #define HDSPM_RAYDAT_REV	211
 #define HDSPM_AIO_REV		212
@@ -6379,6 +6380,7 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 
 	switch (hdspm->firmware_rev) {
 	case HDSPM_MADI_REV:
+	case HDSPM_MADI_OLD_REV:
 		hdspm->io_type = MADI;
 		hdspm->card_name = "RME MADI";
 		hdspm->midiPorts = 3;

commit fedf1535ab5ee02acbbc235c2272d84bb9334758
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Sun Jun 12 17:26:18 2011 +0200

    ALSA: hdspm - Fix jumping external wordclock frequency in AutoSync mode
    
    When using Word Clock on RME MADI cards, AutoSync mode was alternating
    betweeen MADI and WC due to a typo: AutoSync is indicated in the second
    status register (status2), not the first one (status).
    
    While the proc output was always correct, the reported WC frequency to
    ALSA was unstable as mentioned in
    
    http://mailman.alsa-project.org/pipermail/alsa-devel/2008-March/006723.html
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 32d80af012cc..d03ef94d570e 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1143,7 +1143,7 @@ static int hdspm_external_sample_rate(struct hdspm *hdspm)
 
 		/* if wordclock has synced freq and wordclock is valid */
 		if ((status2 & HDSPM_wcLock) != 0 &&
-				(status & HDSPM_SelSyncRef0) == 0) {
+				(status2 & HDSPM_SelSyncRef0) == 0) {
 
 			rate_bits = status2 & HDSPM_wcFreqMask;
 

commit c0da00145f9a32ef33b14508e6fd90fc130afbdc
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Sun Jun 12 17:26:17 2011 +0200

    ALSA: hdspm - Fix locking in snd_hdspm_midi_input_read
    
    For the MIDI part, we need to acquire (and release) the hmidi->lock,
    access to the global hdspm structure is serialized through
    hmidi->hdspm->lock instead.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 949691a876d3..32d80af012cc 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1639,12 +1639,14 @@ static int snd_hdspm_midi_input_read (struct hdspm_midi *hmidi)
 		}
 	}
 	hmidi->pending = 0;
+	spin_unlock_irqrestore(&hmidi->lock, flags);
 
+	spin_lock_irqsave(&hmidi->hdspm->lock, flags);
 	hmidi->hdspm->control_register |= hmidi->ie;
 	hdspm_write(hmidi->hdspm, HDSPM_controlRegister,
 		    hmidi->hdspm->control_register);
+	spin_unlock_irqrestore(&hmidi->hdspm->lock, flags);
 
-	spin_unlock_irqrestore (&hmidi->lock, flags);
 	return snd_hdspm_midi_output_write (hmidi);
 }
 

commit 934c2b6d0cb50f9014ba0f10241e062a3bfc462d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:36:37 2011 +0200

    ALSA: use KBUILD_MODNAME for request_irq argument in sound/pci/*
    
    The name argument of request_irq() appears in /proc/interrupts, and
    it's quite ugly when the name entry contains a space or special letters.
    In general, it's simpler and more readable when the module name appears
    there, so let's replace all entries with KBUILD_MODNAME.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 2785f4cef349..32d0c9c35007 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6437,7 +6437,7 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 			hdspm->port + io_extent - 1);
 
 	if (request_irq(pci->irq, snd_hdspm_interrupt,
-				IRQF_SHARED, "hdspm", hdspm)) {
+			IRQF_SHARED, KBUILD_MODNAME, hdspm)) {
 		snd_printk(KERN_ERR "HDSPM: unable to use IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}

commit 3733e424c4fcd8edff2090f0628f4fd245daddb5
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 10 16:20:20 2011 +0200

    ALSA: Use KBUILD_MODNAME for pci_driver.name entries
    
    The convention for pci_driver.name entry in kernel drivers seem to be
    the module name or equivalent ones.  But, so far, almost all PCI sound
    drivers use more verbose name like "ABC Xyz (12)", and these are fairly
    confusing when appearing as a file name.
    
    This patch converts the all pci_driver.name entries in sound/pci/* to
    use KBUILD_MODNAME for more unified appearance.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 949691a876d3..2785f4cef349 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6775,7 +6775,7 @@ static void __devexit snd_hdspm_remove(struct pci_dev *pci)
 }
 
 static struct pci_driver driver = {
-	.name = "RME Hammerfall DSP MADI",
+	.name = KBUILD_MODNAME,
 	.id_table = snd_hdspm_ids,
 	.probe = snd_hdspm_probe,
 	.remove = __devexit_p(snd_hdspm_remove),

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index a323eafb9e03..949691a876d3 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -391,7 +391,7 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 
 /* Status2 Register bits */ /* MADI ONLY */
 
-#define HDSPM_version0 (1<<0)	/* not realy defined but I guess */
+#define HDSPM_version0 (1<<0)	/* not really defined but I guess */
 #define HDSPM_version1 (1<<1)	/* in former cards it was ??? */
 #define HDSPM_version2 (1<<2)
 
@@ -936,7 +936,7 @@ struct hdspm {
 	struct snd_kcontrol *playback_mixer_ctls[HDSPM_MAX_CHANNELS];
 	/* but input to much, so not used */
 	struct snd_kcontrol *input_mixer_ctls[HDSPM_MAX_CHANNELS];
-	/* full mixer accessable over mixer ioctl or hwdep-device */
+	/* full mixer accessible over mixer ioctl or hwdep-device */
 	struct hdspm_mixer *mixer;
 
 	struct hdspm_tco *tco;  /* NULL if no TCO detected */

commit bdd3255d3adcb9f4fd70c09ec71eb1c5b36d833e
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Mar 7 19:10:11 2011 +0100

    ALSA: hdspm - Add firmware ID for older AES32 cards.
    
    The current AES32 firmware revision ID is 234, however, a user confirmed
    that everything works fine with the previous revision, too.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 0ed4b4e981d8..a323eafb9e03 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -527,6 +527,7 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_MADIFACE_REV	213
 #define HDSPM_AES_REV		240
 #define HDSPM_AES32_REV		234
+#define HDSPM_AES32_OLD_REV	233
 
 /* speed factor modes */
 #define HDSPM_SPEED_SINGLE 0
@@ -6397,6 +6398,7 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 		break;
 	case HDSPM_AES_REV:
 	case HDSPM_AES32_REV:
+	case HDSPM_AES32_OLD_REV:
 		hdspm->io_type = AES32;
 		hdspm->card_name = "RME AES32";
 		hdspm->midiPorts = 2;

commit 7c7102b7af1e5043ddb455f7fae307ed3b194074
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Feb 28 15:14:50 2011 +0100

    ALSA: hdspm - Fix midi port initialization
    
    Depending on the model and the presence of a TCO module, the number of
    midi ports varies. Some have 1 port (MADIface), some have 2 (default),
    with TCO, there are 3.
    
    Don't hardcode the number of midi ports to initialize.
    
    This patch also fixes a boot lockup on MADIface.
    
    [Coding-style fixes by tiwai]
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 78f6ab5dbdd8..0ed4b4e981d8 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6291,8 +6291,10 @@ static int __devinit snd_hdspm_create_pcm(struct snd_card *card,
 
 static inline void snd_hdspm_initialize_midi_flush(struct hdspm * hdspm)
 {
-	snd_hdspm_flush_midi_input(hdspm, 0);
-	snd_hdspm_flush_midi_input(hdspm, 1);
+	int i;
+
+	for (i = 0; i < hdspm->midiPorts; i++)
+		snd_hdspm_flush_midi_input(hdspm, i);
 }
 
 static int __devinit snd_hdspm_create_alsa_devices(struct snd_card *card,

commit 5027f347ffe6f719365ab13127106b52721676ff
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Feb 28 15:14:49 2011 +0100

    ALSA: hdspm - Abort on unknown firmware revision
    
    Don't continue if we cannot detect the real card type, otherwise, all
    subsequent functions, especially strcpy(), would fail, leaving the whole
    driver in an unusable state.
    
    Without such a protection, dmesg would look like this:
    
    Pid: 1525, comm: modprobe Not tainted 2.6.38-rc6 #1 MSI MS-7250/MS-7250
    EIP: 0060:[<c114e700>] EFLAGS: 00010296 CPU: 1
    EIP is at strcpy+0x10/0x30
    EAX: f4d33e58 EBX: f5990800 ECX: f4d33e58 EDX: 00000000
    ESI: 00000000 EDI: f4d33e58 EBP: f5990930 ESP: f3dd3e0c
    DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068
    f53d4204 00000000 f90bfc03 00000001 00000001 f3dd3e64 c10fedff f3dd3e7c
    f3d854e4 f53d4000 c10307b8 00000001 c10307b8 f5990860 c10307b8 00000001
    c10332e5 f59908bc c12f4339 f59908bc f5990860 c11ef207 f4d33e00 f53d4000
    [<f90bfc03>] ? snd_hdspm_probe+0x7e7/0x1166 [snd_hdspm]
    [<c10fedff>] ? __sysfs_add_one+0x1f/0xf0
    [<c10307b8>] ? get_parent_ip+0x8/0x20
    [<c10307b8>] ? get_parent_ip+0x8/0x20
    [<c10307b8>] ? get_parent_ip+0x8/0x20
    [<c10332e5>] ? add_preempt_count+0xa5/0xd0
    [<c12f4339>] ? _raw_spin_lock_irqsave+0x19/0x40
    [<c11ef207>] ? pm_runtime_enable+0x17/0x80
    [<c1160172>] ? local_pci_probe+0x42/0xb0
    [<c1161091>] ? pci_device_probe+0x61/0x80
    [<c11e9587>] ? driver_probe_device+0x77/0x180
    [<c11600f0>] ? pci_match_device+0xa0/0xc0
    [<c11e9709>] ? __driver_attach+0x79/0x80
    [<c11e9690>] ? __driver_attach+0x0/0x80
    [<c11e8e32>] ? bus_for_each_dev+0x52/0x80
    [<c11e9416>] ? driver_attach+0x16/0x20
    [<c11e9690>] ? __driver_attach+0x0/0x80
    [<c11e8771>] ? bus_add_driver+0xa1/0x220
    [<c1160f20>] ? pci_device_remove+0x0/0xf0
    [<c11e99a3>] ? driver_register+0x63/0x120
    [<c11612bd>] ? __pci_register_driver+0x3d/0xb0
    [<c1001132>] ? do_one_initcall+0x32/0x160
    [<f90d6000>] ? alsa_card_hdspm_init+0x0/0x14 [snd_hdspm]
    [<c10676a9>] ? sys_init_module+0x99/0x1e0
    [<c10ade3d>] ? sys_close+0x6d/0xc0
    [<c1002c90>] ? sysenter_do_call+0x12/0x26
    ---[ end trace 239f0661c558378b ]---
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 20c54f7531a9..78f6ab5dbdd8 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6399,6 +6399,10 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 		hdspm->card_name = "RME AES32";
 		hdspm->midiPorts = 2;
 		break;
+	default:
+		snd_printk(KERN_ERR "HDSPM: unknown firmware revision %x\n",
+				hdspm->firmware_rev);
+		return -ENODEV;
 	}
 
 	err = pci_enable_device(pci);

commit 526ea867781ca26f8d7996aa769aa062e1159fd3
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Feb 28 15:14:48 2011 +0100

    ALSA: hdspm - Add updated firmware revision for AES32
    
    In contrast to the PCIe version (RME AES), the PCI version (RME AES32)
    has a different firmware revision.
    
    This patch adds the missing PCI revision.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 7ce492947583..20c54f7531a9 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -526,6 +526,7 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_AIO_REV		212
 #define HDSPM_MADIFACE_REV	213
 #define HDSPM_AES_REV		240
+#define HDSPM_AES32_REV		234
 
 /* speed factor modes */
 #define HDSPM_SPEED_SINGLE 0
@@ -6393,6 +6394,7 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 		hdspm->midiPorts = 1;
 		break;
 	case HDSPM_AES_REV:
+	case HDSPM_AES32_REV:
 		hdspm->io_type = AES32;
 		hdspm->card_name = "RME AES32";
 		hdspm->midiPorts = 2;

commit d2d10a213294d6719d41aab5a111bce1168914a6
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Mon Feb 28 15:14:47 2011 +0100

    ALSA: hdspm - AES32: Use define instead of hardcoded channel count
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 5dbf620a32c2..7ce492947583 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -506,6 +506,8 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define AIO_OUT_DS_CHANNELS        12
 #define AIO_OUT_QS_CHANNELS        10
 
+#define AES32_CHANNELS		16
+
 /* the size of a substream (1 mono data stream) */
 #define HDSPM_CHANNEL_BUFFER_SAMPLES  (16*1024)
 #define HDSPM_CHANNEL_BUFFER_BYTES    (4*HDSPM_CHANNEL_BUFFER_SAMPLES)
@@ -6449,9 +6451,9 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 
 	switch (hdspm->io_type) {
 	case AES32:
-		hdspm->ss_in_channels = hdspm->ss_out_channels = 16;
-		hdspm->ds_in_channels = hdspm->ds_out_channels = 16;
-		hdspm->qs_in_channels = hdspm->qs_out_channels = 16;
+		hdspm->ss_in_channels = hdspm->ss_out_channels = AES32_CHANNELS;
+		hdspm->ds_in_channels = hdspm->ds_out_channels = AES32_CHANNELS;
+		hdspm->qs_in_channels = hdspm->qs_out_channels = AES32_CHANNELS;
 
 		hdspm->channel_map_in_ss = hdspm->channel_map_out_ss =
 			channel_map_aes32;
@@ -6466,7 +6468,8 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 		hdspm->port_names_in_qs = hdspm->port_names_out_qs =
 			texts_ports_aes32;
 
-		hdspm->max_channels_out = hdspm->max_channels_in = 16;
+		hdspm->max_channels_out = hdspm->max_channels_in =
+			AES32_CHANNELS;
 		hdspm->port_names_in = hdspm->port_names_out =
 			texts_ports_aes32;
 		hdspm->channel_map_in = hdspm->channel_map_out =

commit a7edbd5bf944c50d3d2db18b7c5b4e7b22c1a643
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Wed Feb 23 11:43:15 2011 +0100

    ALSA: hdspm - Fix lock/sync reporting on MADI and AES32
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index ced1406d777f..5dbf620a32c2 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3700,8 +3700,8 @@ static int hdspm_sync_in_sync_check(struct hdspm *hdspm)
 	case MADI:
 	case AES32:
 		status = hdspm_read(hdspm, HDSPM_statusRegister2);
-		lock = (status & 0x400000) ? 1 : 0;
-		sync = (status & 0x800000) ? 1 : 0;
+		lock = (status & HDSPM_syncInLock) ? 1 : 0;
+		sync = (status & HDSPM_syncInSync) ? 1 : 0;
 		break;
 
 	case MADIface:

commit 4ab69a2b3b84415085d261bcf848b7a95c010c9d
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Wed Feb 23 11:43:14 2011 +0100

    ALSA: hdspm - prevent reading unitialized stack memory
    
    Original patch by Dan Rosenberg <drosenberg@vsecurity.com> under commit
    e68d3b316ab7b02a074edc4f770e6a746390cb7d. I'm copying his text here:
    
    The SNDRV_HDSPM_IOCTL_GET_CONFIG_INFO ioctl in hdspm.c allow unprivileged
    users to read uninitialized kernel stack memory, because several fields
    of the hdspm_config struct declared on the stack are not altered
    or zeroed before being copied back to the user.  This patch takes care
    of it.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 0b0293fb8f09..ced1406d777f 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6081,6 +6081,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 
 	case SNDRV_HDSPM_IOCTL_GET_CONFIG:
 
+		memset(&info, 0, sizeof(info));
 		spin_lock_irq(&hdspm->lock);
 		info.pref_sync_ref = hdspm_pref_sync_ref(hdspm);
 		info.wordclock_sync_check = hdspm_wc_sync_check(hdspm);

commit 7c4a95b5ec484244fc615be7b9f56c267c51ade6
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Wed Feb 23 11:43:13 2011 +0100

    ALSA: hdspm - fix sync check on AES32
    
    Fredrik Lingvall <fredrik.lingvall@gmail.com> has discovered wrong
    frequency and sync detection on AES32. According to him, the provided
    patch fixes these issues.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index ea49ffe4d9ab..0b0293fb8f09 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1082,7 +1082,7 @@ static int hdspm_external_sample_rate(struct hdspm *hdspm)
 	case AES32:
 		status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
 		status = hdspm_read(hdspm, HDSPM_statusRegister);
-		timecode =	hdspm_read(hdspm, HDSPM_timecodeRegister);
+		timecode = hdspm_read(hdspm, HDSPM_timecodeRegister);
 
 		syncref = hdspm_autosync_ref(hdspm);
 
@@ -2115,6 +2115,29 @@ static int snd_hdspm_get_autosync_sample_rate(struct snd_kcontrol *kcontrol,
 				hdspm_get_s1_sample_rate(hdspm,
 						ucontrol->id.index-1);
 		}
+
+	case AES32:
+
+		switch (kcontrol->private_value) {
+		case 0: /* WC */
+			ucontrol->value.enumerated.item[0] =
+				hdspm_get_wc_sample_rate(hdspm);
+			break;
+		case 9: /* TCO */
+			ucontrol->value.enumerated.item[0] =
+				hdspm_get_tco_sample_rate(hdspm);
+			break;
+		case 10: /* SYNC_IN */
+			ucontrol->value.enumerated.item[0] =
+				hdspm_get_sync_in_sample_rate(hdspm);
+			break;
+		default: /* AES1 to AES8 */
+			ucontrol->value.enumerated.item[0] =
+				hdspm_get_s1_sample_rate(hdspm,
+						kcontrol->private_value-1);
+			break;
+
+		}
 	default:
 		break;
 	}
@@ -3803,9 +3826,9 @@ static int snd_hdspm_get_sync_check(struct snd_kcontrol *kcontrol,
 			val = hdspm_tco_sync_check(hdspm); break;
 		case 10 /* SYNC IN */:
 			val = hdspm_sync_in_sync_check(hdspm); break;
-		default:
+		default: /* AES1 to AES8 */
 			 val = hdspm_aes_sync_check(hdspm,
-					 ucontrol->id.index-1);
+					 kcontrol->private_value-1);
 		}
 
 	}

commit f6ea805f524207f125f1d245152a16e3a8094243
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Wed Feb 23 11:43:12 2011 +0100

    ALSA: hdspm - Remove input selector on MADIface
    
    In contrast to the RME MADI card, coax/optical selection on the MADIface
    is done via a physical switch located at the breakout box. Obviously,
    the driver cannot switch ports in software.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 7246302f6900..ea49ffe4d9ab 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4272,8 +4272,7 @@ static struct snd_kcontrol_new snd_hdspm_controls_madiface[] = {
 	HDSPM_SYNC_CHECK("MADI SyncCheck", 0),
 	HDSPM_TX_64("TX 64 channels mode", 0),
 	HDSPM_C_TMS("Clear Track Marker", 0),
-	HDSPM_SAFE_MODE("Safe Mode", 0),
-	HDSPM_INPUT_SELECT("Input Select", 0),
+	HDSPM_SAFE_MODE("Safe Mode", 0)
 };
 
 static struct snd_kcontrol_new snd_hdspm_controls_aio[] = {

commit 01e9607815755f748eb8722c3c3d8f308b7b4470
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Wed Feb 23 11:43:11 2011 +0100

    ALSA: hdspm - Fix DS/QS output channel mappings on RME MADI/MADIface
    
    Caused by two typos, no output channel mappings were assigned for
    MADI/MADIface at double/quad speed.
    
    The channel mapping is indeed identical to the single speed mapping, the
    cards will simply use the first N channels.
    
    Signed-off-by: Florian Faber <faber@faberman.de>
    Signed-off-by: Fredrik Lingvall <fredrik.lingvall@gmail.com>
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 17939b9713ea..7246302f6900 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6462,9 +6462,9 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 
 		hdspm->channel_map_in_ss = hdspm->channel_map_out_ss =
 			channel_map_unity_ss;
-		hdspm->channel_map_in_ds = hdspm->channel_map_out_ss =
+		hdspm->channel_map_in_ds = hdspm->channel_map_out_ds =
 			channel_map_unity_ss;
-		hdspm->channel_map_in_qs = hdspm->channel_map_out_ss =
+		hdspm->channel_map_in_qs = hdspm->channel_map_out_qs =
 			channel_map_unity_ss;
 
 		hdspm->port_names_in_ss = hdspm->port_names_out_ss =

commit 88fabbfcc6d347555f9be04e3fe89e7a9c9a2a2d
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Wed Feb 23 11:43:10 2011 +0100

    ALSA: hdspm - Restrict channel count on RME AES/AES32
    
    Without calling an appropriate rule, AES/AES32 cards would announce a
    theoretical channel count of 64 (HDSPM_MAX_CHANNELS), leading to the
    already known bug:
    
    [37422.640481] ------------[ cut here ]------------
    [37422.640487] WARNING: at sound/pci/rme9652/hdspm.c:5449
    snd_hdspm_ioctl+0x18f/0x202 [snd_hdspm]()
    [37422.640489] Hardware name: PRIMERGY RX100 S6
    [37422.640490] BUG? (info->channel >= hdspm->max_channels_in)
    [37422.640492] Modules linked in: snd_hdspm snd_seq_midi ipmi_watchdog
    ipmi_poweroff ipmi_si ipmi_devintf ipmi_msghandler i2c_i801 e1000e
    snd_rawmidi power_meter [last unloaded: snd_hdspm]
    [37422.640501] Pid: 22231, comm: jackd Tainted: G      D W
    2.6.36-gentoo-r5 #5
    [37422.640502] Call Trace:
    [37422.640508]  [<ffffffff8103db3a>] warn_slowpath_common+0x80/0x98
    [37422.640511]  [<ffffffff8103dbe6>] warn_slowpath_fmt+0x41/0x43
    [37422.640514]  [<ffffffff81034306>] ? get_parent_ip+0x11/0x42
    [37422.640518]  [<ffffffffa0055763>] snd_hdspm_ioctl+0x18f/0x202
    [snd_hdspm]
    [37422.640522]  [<ffffffff813fd626>] snd_pcm_channel_info+0x73/0x7c
    [37422.640525]  [<ffffffff814001e9>] snd_pcm_common_ioctl1+0x326/0xb01
    [37422.640527]  [<ffffffff81034306>] ? get_parent_ip+0x11/0x42
    [37422.640531]  [<ffffffff8105be6c>] ? __srcu_read_unlock+0x3b/0x59
    [37422.640533]  [<ffffffff81400bce>] snd_pcm_capture_ioctl1+0x20a/0x227
    [37422.640537]  [<ffffffff811e599c>] ? file_has_perm+0x90/0x9e
    [37422.640540]  [<ffffffff81400c15>] snd_pcm_capture_ioctl+0x2a/0x2e
    [37422.640543]  [<ffffffff810f2c69>] do_vfs_ioctl+0x404/0x453
    [37422.640546]  [<ffffffff810f2d09>] sys_ioctl+0x51/0x74
    [37422.640549]  [<ffffffff81002aab>] system_call_fastpath+0x16/0x1b
    [37422.640552] ---[ end trace 0cd919cd68118082 ]---
    
    We already have all the right values in place, we simply have to inform
    the upper layers about this restriction.
    
    Note that snd_hdspm_hw_rule_rate_out_channels and
    snd_hdspm_hw_rule_rate_in_channels must not be called on AES32, because
    the channel count is always 16, no matter of the samplerate in use.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 509a35a881f5..17939b9713ea 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -5836,17 +5836,19 @@ static int snd_hdspm_playback_open(struct snd_pcm_substream *substream)
 		snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
 				&hdspm_hw_constraints_aes32_sample_rates);
 	} else {
-		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-				snd_hdspm_hw_rule_out_channels, hdspm,
-				SNDRV_PCM_HW_PARAM_CHANNELS, -1);
-		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-				snd_hdspm_hw_rule_out_channels_rate, hdspm,
-				SNDRV_PCM_HW_PARAM_RATE, -1);
-
 		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
 				snd_hdspm_hw_rule_rate_out_channels, hdspm,
 				SNDRV_PCM_HW_PARAM_CHANNELS, -1);
 	}
+
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			snd_hdspm_hw_rule_out_channels, hdspm,
+			SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			snd_hdspm_hw_rule_out_channels_rate, hdspm,
+			SNDRV_PCM_HW_PARAM_RATE, -1);
+
 	return 0;
 }
 
@@ -5904,17 +5906,19 @@ static int snd_hdspm_capture_open(struct snd_pcm_substream *substream)
 		snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
 				&hdspm_hw_constraints_aes32_sample_rates);
 	} else {
-		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-				     snd_hdspm_hw_rule_in_channels, hdspm,
-				     SNDRV_PCM_HW_PARAM_CHANNELS, -1);
-		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-				    snd_hdspm_hw_rule_in_channels_rate, hdspm,
-				    SNDRV_PCM_HW_PARAM_RATE, -1);
-
 		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
-				    snd_hdspm_hw_rule_rate_in_channels, hdspm,
-				    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+				snd_hdspm_hw_rule_rate_in_channels, hdspm,
+				SNDRV_PCM_HW_PARAM_CHANNELS, -1);
 	}
+
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			snd_hdspm_hw_rule_in_channels, hdspm,
+			SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			snd_hdspm_hw_rule_in_channels_rate, hdspm,
+			SNDRV_PCM_HW_PARAM_RATE, -1);
+
 	return 0;
 }
 

commit 483cee77d2be6c22ef67ac8c6711e757d138a538
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Wed Feb 23 11:43:09 2011 +0100

    ALSA: hdspm - Fix buffer handling on RME MADI/MADIface/AES(32)
    
    Only RayDAT and AIO provide sane buffer pointers that can be used with
    HDSPM_BufferPositionMask, on all other cards, this would result in a
    wrong HW pointer leading to xruns and these messages:
    
    [260808.916788] BUG: pcmC0D0p:0, pos = 2976, buffer size = 1024, period size = 512
    [260808.961124] BUG: pcmC0D0c:0, pos = 4944, buffer size = 1024, period size = 512
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 92588975f580..509a35a881f5 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1231,8 +1231,17 @@ static snd_pcm_uframes_t hdspm_hw_pointer(struct hdspm *hdspm)
 	int position;
 
 	position = hdspm_read(hdspm, HDSPM_statusRegister);
-	position &= HDSPM_BufferPositionMask;
-	position /= 4; /* Bytes per sample */
+
+	switch (hdspm->io_type) {
+	case RayDAT:
+	case AIO:
+		position &= HDSPM_BufferPositionMask;
+		position /= 4; /* Bytes per sample */
+		break;
+	default:
+		position = (position & HDSPM_BufferID) ?
+			(hdspm->period_bytes / 4) : 0;
+	}
 
 	return position;
 }

commit 432d2500ac11ca88532e08716813b189a27f74a9
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Wed Feb 23 11:43:08 2011 +0100

    ALSA: hpdsm - RME AES(32): Fix missing channel mappings
    
    On RME AES and AES(32), none of the required information
    (max_channels_in, max_channels_out, channel mappings, port names) was
    set, leading to the BUG below.
    
    This patch adds the missing bits, thus fixing the bug.
    
    125.058768] ------------[ cut here ]------------
    [  125.058773] WARNING: at sound/pci/rme9652/hdspm.c:5389
    snd_hdspm_ioctl+0x10c/0x1d8 [snd_hdspm]()
    [  125.058775] Hardware name: PRIMERGY RX100 S6
    [  125.058777] BUG? (info->channel >= hdspm->max_channels_out)
    [  125.058778] Modules linked in: ipmi_watchdog ipmi_poweroff ipmi_si
    ipmi_devintf ipmi_msghandler snd_hdspm power_meter e1000e snd_rawmidi
    i2c_i801
    [  125.058787] Pid: 3652, comm: audacity Tainted: G        W
    2.6.36-gentoo-r5 #5
    [  125.058788] Call Trace:
    [  125.058792]  [<ffffffff8103db3a>] warn_slowpath_common+0x80/0x98
    [  125.058796]  [<ffffffff8103dbe6>] warn_slowpath_fmt+0x41/0x43
    [  125.058800]  [<ffffffffa006761a>] snd_hdspm_ioctl+0x10c/0x1d8
    [snd_hdspm]
    [  125.058803]  [<ffffffff813fd626>] snd_pcm_channel_info+0x73/0x7c
    [  125.058806]  [<ffffffff814001e9>] snd_pcm_common_ioctl1+0x326/0xb01
    [  125.058809]  [<ffffffff810c604c>] ? __do_fault+0x361/0x3a6
    [  125.058812]  [<ffffffff81400e23>] snd_pcm_playback_ioctl1+0x20a/0x227
    [  125.058815]  [<ffffffff811e599c>] ? file_has_perm+0x90/0x9e
    [  125.058818]  [<ffffffff81400e6a>] snd_pcm_playback_ioctl+0x2a/0x2e
    [  125.058821]  [<ffffffff810f2c69>] do_vfs_ioctl+0x404/0x453
    [  125.058824]  [<ffffffff810f2d09>] sys_ioctl+0x51/0x74
    [  125.058827]  [<ffffffff81002aab>] system_call_fastpath+0x16/0x1b
    [  125.058830] ---[ end trace 5bddb08e5d4cbeb1 ]---
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Florian Faber <faber@faberman.de>
    Signed-off-by: Fredrik Lingvall <fredrik.lingvall@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 6de88b0ce9f4..92588975f580 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -667,6 +667,12 @@ static char *texts_ports_aio_out_qs[] = {
 	"Phone.L", "Phone.R"
 };
 
+static char *texts_ports_aes32[] = {
+	"AES.1", "AES.2", "AES.3", "AES.4", "AES.5", "AES.6", "AES.7",
+	"AES.8", "AES.9.", "AES.10", "AES.11", "AES.12", "AES.13", "AES.14",
+	"AES.15", "AES.16"
+};
+
 /* These tables map the ALSA channels 1..N to the channels that we
    need to use in order to find the relevant channel buffer. RME
    refers to this kind of mapping as between "the ADAT channel and
@@ -816,6 +822,17 @@ static char channel_map_aio_out_qs[HDSPM_MAX_CHANNELS] = {
 	-1, -1, -1, -1, -1, -1, -1, -1
 };
 
+static char channel_map_aes32[HDSPM_MAX_CHANNELS] = {
+	0, 1, 2, 3, 4, 5, 6, 7,
+	8, 9, 10, 11, 12, 13, 14, 15,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1
+};
+
 struct hdspm_midi {
 	struct hdspm *hdspm;
 	int id;
@@ -6396,6 +6413,29 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 
 	switch (hdspm->io_type) {
 	case AES32:
+		hdspm->ss_in_channels = hdspm->ss_out_channels = 16;
+		hdspm->ds_in_channels = hdspm->ds_out_channels = 16;
+		hdspm->qs_in_channels = hdspm->qs_out_channels = 16;
+
+		hdspm->channel_map_in_ss = hdspm->channel_map_out_ss =
+			channel_map_aes32;
+		hdspm->channel_map_in_ds = hdspm->channel_map_out_ds =
+			channel_map_aes32;
+		hdspm->channel_map_in_qs = hdspm->channel_map_out_qs =
+			channel_map_aes32;
+		hdspm->port_names_in_ss = hdspm->port_names_out_ss =
+			texts_ports_aes32;
+		hdspm->port_names_in_ds = hdspm->port_names_out_ds =
+			texts_ports_aes32;
+		hdspm->port_names_in_qs = hdspm->port_names_out_qs =
+			texts_ports_aes32;
+
+		hdspm->max_channels_out = hdspm->max_channels_in = 16;
+		hdspm->port_names_in = hdspm->port_names_out =
+			texts_ports_aes32;
+		hdspm->channel_map_in = hdspm->channel_map_out =
+			channel_map_aes32;
+
 		break;
 
 	case MADI:

commit 730a5865152be843eea5fe87e2b309623c730435
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Thu Jan 27 13:03:15 2011 +0100

    ALSA: hdspm - remove unused arrays, reduce stack usage in hwdep_ioctl
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 28a1eb3f4d02..6de88b0ce9f4 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -575,12 +575,6 @@ static char *texts_freq[] = {
 	"192 kHz"
 };
 
-static char *texts_sync_status[] = {
-	"no lock",
-	"lock",
-	"sync"
-};
-
 static char *texts_ports_madi[] = {
 	"MADI.1", "MADI.2", "MADI.3", "MADI.4", "MADI.5", "MADI.6",
 	"MADI.7", "MADI.8", "MADI.9", "MADI.10", "MADI.11", "MADI.12",
@@ -692,28 +686,6 @@ static char channel_map_unity_ss[HDSPM_MAX_CHANNELS] = {
 	56, 57, 58, 59, 60, 61, 62, 63
 };
 
-static char channel_map_unity_ds[HDSPM_MAX_CHANNELS] = {
-	0, 2, 4, 6, 8, 10, 12, 14,
-	16, 18, 20, 22, 24, 26, 28, 30,
-	32, 34, 36, 38, 40, 42, 44, 46,
-	48, 50, 52, 54, 56, 58, 60, 62,
-	-1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1,
-};
-
-static char channel_map_unity_qs[HDSPM_MAX_CHANNELS] = {
-	0, 4, 8, 12, 16, 20, 24, 28,
-	32, 36, 40, 44, 48, 52, 56, 60,
-	-1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1,
-};
-
 static char channel_map_raydat_ss[HDSPM_MAX_CHANNELS] = {
 	4, 5, 6, 7, 8, 9, 10, 11,	/* ADAT 1 */
 	12, 13, 14, 15, 16, 17, 18, 19,	/* ADAT 2 */
@@ -952,6 +924,8 @@ struct hdspm {
 	int texts_autosync_items;
 
 	cycles_t last_interrupt;
+
+	struct hdspm_peak_rms peak_rms;
 };
 
 
@@ -5952,7 +5926,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 	struct hdspm_config info;
 	struct hdspm_status status;
 	struct hdspm_version hdspm_version;
-	struct hdspm_peak_rms levels;
+	struct hdspm_peak_rms *levels;
 	struct hdspm_ltc ltc;
 	unsigned int statusregister;
 	long unsigned int s;
@@ -5961,28 +5935,29 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 	switch (cmd) {
 
 	case SNDRV_HDSPM_IOCTL_GET_PEAK_RMS:
+		levels = &hdspm->peak_rms;
 		for (i = 0; i < HDSPM_MAX_CHANNELS; i++) {
-			levels.input_peaks[i] =
+			levels->input_peaks[i] =
 				readl(hdspm->iobase +
 						HDSPM_MADI_INPUT_PEAK + i*4);
-			levels.playback_peaks[i] =
+			levels->playback_peaks[i] =
 				readl(hdspm->iobase +
 						HDSPM_MADI_PLAYBACK_PEAK + i*4);
-			levels.output_peaks[i] =
+			levels->output_peaks[i] =
 				readl(hdspm->iobase +
 						HDSPM_MADI_OUTPUT_PEAK + i*4);
 
-			levels.input_rms[i] =
+			levels->input_rms[i] =
 				((uint64_t) readl(hdspm->iobase +
 					HDSPM_MADI_INPUT_RMS_H + i*4) << 32) |
 				(uint64_t) readl(hdspm->iobase +
 						HDSPM_MADI_INPUT_RMS_L + i*4);
-			levels.playback_rms[i] =
+			levels->playback_rms[i] =
 				((uint64_t)readl(hdspm->iobase +
 					HDSPM_MADI_PLAYBACK_RMS_H+i*4) << 32) |
 				(uint64_t)readl(hdspm->iobase +
 					HDSPM_MADI_PLAYBACK_RMS_L + i*4);
-			levels.output_rms[i] =
+			levels->output_rms[i] =
 				((uint64_t)readl(hdspm->iobase +
 					HDSPM_MADI_OUTPUT_RMS_H + i*4) << 32) |
 				(uint64_t)readl(hdspm->iobase +
@@ -5990,15 +5965,15 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
 		}
 
 		if (hdspm->system_sample_rate > 96000) {
-			levels.speed = qs;
+			levels->speed = qs;
 		} else if (hdspm->system_sample_rate > 48000) {
-			levels.speed = ds;
+			levels->speed = ds;
 		} else {
-			levels.speed = ss;
+			levels->speed = ss;
 		}
-		levels.status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+		levels->status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
 
-		s = copy_to_user(argp, &levels, sizeof(struct hdspm_peak_rms));
+		s = copy_to_user(argp, levels, sizeof(struct hdspm_peak_rms));
 		if (0 != s) {
 			/* snd_printk(KERN_ERR "copy_to_user(.., .., %lu): %lu
 			 [Levels]\n", sizeof(struct hdspm_peak_rms), s);

commit 55a57606b26665870f2993dc53a43daad157dbcd
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Thu Jan 27 11:23:15 2011 +0100

    ALSA: [hdspm] Move static mapping arrays to .c
    
    As requested by Takashi and Jaroslav, these arrays should not be in the
    header file.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 2db871d9a007..28a1eb3f4d02 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -673,6 +673,177 @@ static char *texts_ports_aio_out_qs[] = {
 	"Phone.L", "Phone.R"
 };
 
+/* These tables map the ALSA channels 1..N to the channels that we
+   need to use in order to find the relevant channel buffer. RME
+   refers to this kind of mapping as between "the ADAT channel and
+   the DMA channel." We index it using the logical audio channel,
+   and the value is the DMA channel (i.e. channel buffer number)
+   where the data for that channel can be read/written from/to.
+*/
+
+static char channel_map_unity_ss[HDSPM_MAX_CHANNELS] = {
+	0, 1, 2, 3, 4, 5, 6, 7,
+	8, 9, 10, 11, 12, 13, 14, 15,
+	16, 17, 18, 19, 20, 21, 22, 23,
+	24, 25, 26, 27, 28, 29, 30, 31,
+	32, 33, 34, 35, 36, 37, 38, 39,
+	40, 41, 42, 43, 44, 45, 46, 47,
+	48, 49, 50, 51, 52, 53, 54, 55,
+	56, 57, 58, 59, 60, 61, 62, 63
+};
+
+static char channel_map_unity_ds[HDSPM_MAX_CHANNELS] = {
+	0, 2, 4, 6, 8, 10, 12, 14,
+	16, 18, 20, 22, 24, 26, 28, 30,
+	32, 34, 36, 38, 40, 42, 44, 46,
+	48, 50, 52, 54, 56, 58, 60, 62,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+};
+
+static char channel_map_unity_qs[HDSPM_MAX_CHANNELS] = {
+	0, 4, 8, 12, 16, 20, 24, 28,
+	32, 36, 40, 44, 48, 52, 56, 60,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+};
+
+static char channel_map_raydat_ss[HDSPM_MAX_CHANNELS] = {
+	4, 5, 6, 7, 8, 9, 10, 11,	/* ADAT 1 */
+	12, 13, 14, 15, 16, 17, 18, 19,	/* ADAT 2 */
+	20, 21, 22, 23, 24, 25, 26, 27,	/* ADAT 3 */
+	28, 29, 30, 31, 32, 33, 34, 35,	/* ADAT 4 */
+	0, 1,			/* AES */
+	2, 3,			/* SPDIF */
+	-1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+};
+
+static char channel_map_raydat_ds[HDSPM_MAX_CHANNELS] = {
+	4, 5, 6, 7,		/* ADAT 1 */
+	8, 9, 10, 11,		/* ADAT 2 */
+	12, 13, 14, 15,		/* ADAT 3 */
+	16, 17, 18, 19,		/* ADAT 4 */
+	0, 1,			/* AES */
+	2, 3,			/* SPDIF */
+	-1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+};
+
+static char channel_map_raydat_qs[HDSPM_MAX_CHANNELS] = {
+	4, 5,			/* ADAT 1 */
+	6, 7,			/* ADAT 2 */
+	8, 9,			/* ADAT 3 */
+	10, 11,			/* ADAT 4 */
+	0, 1,			/* AES */
+	2, 3,			/* SPDIF */
+	-1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+};
+
+static char channel_map_aio_in_ss[HDSPM_MAX_CHANNELS] = {
+	0, 1,			/* line in */
+	8, 9,			/* aes in, */
+	10, 11,			/* spdif in */
+	12, 13, 14, 15, 16, 17, 18, 19,	/* ADAT in */
+	-1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+};
+
+static char channel_map_aio_out_ss[HDSPM_MAX_CHANNELS] = {
+	0, 1,			/* line out */
+	8, 9,			/* aes out */
+	10, 11,			/* spdif out */
+	12, 13, 14, 15, 16, 17, 18, 19,	/* ADAT out */
+	6, 7,			/* phone out */
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+};
+
+static char channel_map_aio_in_ds[HDSPM_MAX_CHANNELS] = {
+	0, 1,			/* line in */
+	8, 9,			/* aes in */
+	10, 11,			/* spdif in */
+	12, 14, 16, 18,		/* adat in */
+	-1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1
+};
+
+static char channel_map_aio_out_ds[HDSPM_MAX_CHANNELS] = {
+	0, 1,			/* line out */
+	8, 9,			/* aes out */
+	10, 11,			/* spdif out */
+	12, 14, 16, 18,		/* adat out */
+	6, 7,			/* phone out */
+	-1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1
+};
+
+static char channel_map_aio_in_qs[HDSPM_MAX_CHANNELS] = {
+	0, 1,			/* line in */
+	8, 9,			/* aes in */
+	10, 11,			/* spdif in */
+	12, 16,			/* adat in */
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1
+};
+
+static char channel_map_aio_out_qs[HDSPM_MAX_CHANNELS] = {
+	0, 1,			/* line out */
+	8, 9,			/* aes out */
+	10, 11,			/* spdif out */
+	12, 16,			/* adat out */
+	6, 7,			/* phone out */
+	-1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1
+};
+
 struct hdspm_midi {
 	struct hdspm *hdspm;
 	int id;

commit 0dca1793063c28dde8f6c49c9c72203fe5cb6efc
Author: Adrian Knoth <adi@drcomp.erfurt.thur.de>
Date:   Wed Jan 26 19:32:14 2011 +0100

    ALSA: hdspm - Add support for RME RayDAT and AIO
    
    Incorporate changes by Florian Faber into hdspm.c. Code taken from
    
       http://wiki.linuxproaudio.org/index.php/Driver:hdspe
    
    Heavily reworked to mostly comply with the coding standard (whitespace
    fixes, line width, C++ style comments)
    
    The code was tested and confirmed to be working on RME RayDAT.
    
    Signed-off-by: Adrian Knoth <adi@drcomp.erfurt.thur.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index f5eadfc0672a..2db871d9a007 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -8,6 +8,21 @@
  *      Modified 2006-06-01 for AES32 support by Remy Bruno
  *                                               <remy.bruno@trinnov.com>
  *
+ *      Modified 2009-04-13 for proper metering by Florian Faber
+ *                                               <faber@faberman.de>
+ *
+ *      Modified 2009-04-14 for native float support by Florian Faber
+ *                                               <faber@faberman.de>
+ *
+ *      Modified 2009-04-26 fixed bug in rms metering by Florian Faber
+ *                                               <faber@faberman.de>
+ *
+ *      Modified 2009-04-30 added hw serial number support by Florian Faber
+ *
+ *      Modified 2011-01-14 added S/PDIF input on RayDATs by Adrian Knoth
+ *
+ *	Modified 2011-01-25 variable period sizes on RayDAT/AIO by Adrian Knoth
+ *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
  *   the Free Software Foundation; either version 2 of the License, or
@@ -35,6 +50,7 @@
 #include <sound/core.h>
 #include <sound/control.h>
 #include <sound/pcm.h>
+#include <sound/pcm_params.h>
 #include <sound/info.h>
 #include <sound/asoundef.h>
 #include <sound/rawmidi.h>
@@ -47,15 +63,6 @@ static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	  /* Index 0-MAX */
 static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	  /* ID for this card */
 static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */
 
-/* Disable precise pointer at start */
-static int precise_ptr[SNDRV_CARDS];
-
-/* Send all playback to line outs */
-static int line_outs_monitor[SNDRV_CARDS];
-
-/* Enable Analog Outs on Channel 63/64 by default */
-static int enable_monitor[SNDRV_CARDS];
-
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for RME HDSPM interface.");
 
@@ -65,42 +72,39 @@ MODULE_PARM_DESC(id, "ID string for RME HDSPM interface.");
 module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable/disable specific HDSPM soundcards.");
 
-module_param_array(precise_ptr, bool, NULL, 0444);
-MODULE_PARM_DESC(precise_ptr, "Enable or disable precise pointer.");
-
-module_param_array(line_outs_monitor, bool, NULL, 0444);
-MODULE_PARM_DESC(line_outs_monitor,
-		 "Send playback streams to analog outs by default.");
-
-module_param_array(enable_monitor, bool, NULL, 0444);
-MODULE_PARM_DESC(enable_monitor,
-		 "Enable Analog Out on Channel 63/64 by default.");
 
 MODULE_AUTHOR
-      ("Winfried Ritsch <ritsch_AT_iem.at>, "
-       "Paul Davis <paul@linuxaudiosystems.com>, "
-       "Marcus Andersson, Thomas Charbonnel <thomas@undata.org>, "
-       "Remy Bruno <remy.bruno@trinnov.com>");
+(
+	"Winfried Ritsch <ritsch_AT_iem.at>, "
+	"Paul Davis <paul@linuxaudiosystems.com>, "
+	"Marcus Andersson, Thomas Charbonnel <thomas@undata.org>, "
+	"Remy Bruno <remy.bruno@trinnov.com>, "
+	"Florian Faber <faberman@linuxproaudio.org>, "
+	"Adrian Knoth <adi@drcomp.erfurt.thur.de>"
+);
 MODULE_DESCRIPTION("RME HDSPM");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 
-/* --- Write registers. --- 
+/* --- Write registers. ---
   These are defined as byte-offsets from the iobase value.  */
 
+#define HDSPM_WR_SETTINGS             0
+#define HDSPM_outputBufferAddress    32
+#define HDSPM_inputBufferAddress     36
 #define HDSPM_controlRegister	     64
 #define HDSPM_interruptConfirmation  96
 #define HDSPM_control2Reg	     256  /* not in specs ???????? */
 #define HDSPM_freqReg                256  /* for AES32 */
-#define HDSPM_midiDataOut0  	     352  /* just believe in old code */
-#define HDSPM_midiDataOut1  	     356
+#define HDSPM_midiDataOut0	     352  /* just believe in old code */
+#define HDSPM_midiDataOut1	     356
 #define HDSPM_eeprom_wr		     384  /* for AES32 */
 
 /* DMA enable for 64 channels, only Bit 0 is relevant */
-#define HDSPM_outputEnableBase       512  /* 512-767  input  DMA */ 
+#define HDSPM_outputEnableBase       512  /* 512-767  input  DMA */
 #define HDSPM_inputEnableBase        768  /* 768-1023 output DMA */
 
-/* 16 page addresses for each of the 64 channels DMA buffer in and out 
+/* 16 page addresses for each of the 64 channels DMA buffer in and out
    (each 64k=16*4k) Buffer must be 4k aligned (which is default i386 ????) */
 #define HDSPM_pageAddressBufferOut       8192
 #define HDSPM_pageAddressBufferIn        (HDSPM_pageAddressBufferOut+64*16*4)
@@ -119,22 +123,84 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_statusRegister2  192
 #define HDSPM_timecodeRegister 128
 
+/* AIO, RayDAT */
+#define HDSPM_RD_STATUS_0 0
+#define HDSPM_RD_STATUS_1 64
+#define HDSPM_RD_STATUS_2 128
+#define HDSPM_RD_STATUS_3 192
+
+#define HDSPM_RD_TCO           256
+#define HDSPM_RD_PLL_FREQ      512
+#define HDSPM_WR_TCO           128
+
+#define HDSPM_TCO1_TCO_lock			0x00000001
+#define HDSPM_TCO1_WCK_Input_Range_LSB		0x00000002
+#define HDSPM_TCO1_WCK_Input_Range_MSB		0x00000004
+#define HDSPM_TCO1_LTC_Input_valid		0x00000008
+#define HDSPM_TCO1_WCK_Input_valid		0x00000010
+#define HDSPM_TCO1_Video_Input_Format_NTSC	0x00000020
+#define HDSPM_TCO1_Video_Input_Format_PAL	0x00000040
+
+#define HDSPM_TCO1_set_TC			0x00000100
+#define HDSPM_TCO1_set_drop_frame_flag		0x00000200
+#define HDSPM_TCO1_LTC_Format_LSB		0x00000400
+#define HDSPM_TCO1_LTC_Format_MSB		0x00000800
+
+#define HDSPM_TCO2_TC_run			0x00010000
+#define HDSPM_TCO2_WCK_IO_ratio_LSB		0x00020000
+#define HDSPM_TCO2_WCK_IO_ratio_MSB		0x00040000
+#define HDSPM_TCO2_set_num_drop_frames_LSB	0x00080000
+#define HDSPM_TCO2_set_num_drop_frames_MSB	0x00100000
+#define HDSPM_TCO2_set_jam_sync			0x00200000
+#define HDSPM_TCO2_set_flywheel			0x00400000
+
+#define HDSPM_TCO2_set_01_4			0x01000000
+#define HDSPM_TCO2_set_pull_down		0x02000000
+#define HDSPM_TCO2_set_pull_up			0x04000000
+#define HDSPM_TCO2_set_freq			0x08000000
+#define HDSPM_TCO2_set_term_75R			0x10000000
+#define HDSPM_TCO2_set_input_LSB		0x20000000
+#define HDSPM_TCO2_set_input_MSB		0x40000000
+#define HDSPM_TCO2_set_freq_from_app		0x80000000
+
+
+#define HDSPM_midiDataOut0    352
+#define HDSPM_midiDataOut1    356
+#define HDSPM_midiDataOut2    368
+
 #define HDSPM_midiDataIn0     360
 #define HDSPM_midiDataIn1     364
+#define HDSPM_midiDataIn2     372
+#define HDSPM_midiDataIn3     376
 
 /* status is data bytes in MIDI-FIFO (0-128) */
-#define HDSPM_midiStatusOut0  384	
-#define HDSPM_midiStatusOut1  388	
-#define HDSPM_midiStatusIn0   392	
-#define HDSPM_midiStatusIn1   396	
+#define HDSPM_midiStatusOut0  384
+#define HDSPM_midiStatusOut1  388
+#define HDSPM_midiStatusOut2  400
+
+#define HDSPM_midiStatusIn0   392
+#define HDSPM_midiStatusIn1   396
+#define HDSPM_midiStatusIn2   404
+#define HDSPM_midiStatusIn3   408
 
 
 /* the meters are regular i/o-mapped registers, but offset
    considerably from the rest. the peak registers are reset
-   when read; the least-significant 4 bits are full-scale counters; 
+   when read; the least-significant 4 bits are full-scale counters;
    the actual peak value is in the most-significant 24 bits.
 */
-#define HDSPM_MADI_peakrmsbase 	4096	/* 4096-8191 2x64x32Bit Meters */
+
+#define HDSPM_MADI_INPUT_PEAK		4096
+#define HDSPM_MADI_PLAYBACK_PEAK	4352
+#define HDSPM_MADI_OUTPUT_PEAK		4608
+
+#define HDSPM_MADI_INPUT_RMS_L		6144
+#define HDSPM_MADI_PLAYBACK_RMS_L	6400
+#define HDSPM_MADI_OUTPUT_RMS_L		6656
+
+#define HDSPM_MADI_INPUT_RMS_H		7168
+#define HDSPM_MADI_PLAYBACK_RMS_H	7424
+#define HDSPM_MADI_OUTPUT_RMS_H		7680
 
 /* --- Control Register bits --------- */
 #define HDSPM_Start                (1<<0) /* start engine */
@@ -143,7 +209,9 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_Latency1             (1<<2) /* where n is defined */
 #define HDSPM_Latency2             (1<<3) /* by Latency{2,1,0} */
 
-#define HDSPM_ClockModeMaster      (1<<4) /* 1=Master, 0=Slave/Autosync */
+#define HDSPM_ClockModeMaster      (1<<4) /* 1=Master, 0=Autosync */
+#define HDSPM_c0Master		0x1    /* Master clock bit in settings
+					  register [RayDAT, AIO] */
 
 #define HDSPM_AudioInterruptEnable (1<<5) /* what do you think ? */
 
@@ -157,7 +225,7 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 				     56channelMODE=0 */ /* MADI ONLY*/
 #define HDSPM_Emphasis    (1<<10) /* Emphasis */ /* AES32 ONLY */
 
-#define HDSPM_AutoInp     (1<<11) /* Auto Input (takeover) == Safe Mode, 
+#define HDSPM_AutoInp     (1<<11) /* Auto Input (takeover) == Safe Mode,
                                      0=off, 1=on  */ /* MADI ONLY */
 #define HDSPM_Dolby       (1<<11) /* Dolby = "NonAudio" ?? */ /* AES32 ONLY */
 
@@ -166,22 +234,23 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 				    */
 #define HDSPM_InputSelect1 (1<<15) /* should be 0 */
 
-#define HDSPM_SyncRef0     (1<<16) /* 0=WOrd, 1=MADI */
-#define HDSPM_SyncRef1     (1<<17) /* for AES32: SyncRefN codes the AES # */
 #define HDSPM_SyncRef2     (1<<13)
 #define HDSPM_SyncRef3     (1<<25)
 
 #define HDSPM_SMUX         (1<<18) /* Frame ??? */ /* MADI ONY */
-#define HDSPM_clr_tms      (1<<19) /* clear track marker, do not use 
+#define HDSPM_clr_tms      (1<<19) /* clear track marker, do not use
                                       AES additional bits in
 				      lower 5 Audiodatabits ??? */
 #define HDSPM_taxi_reset   (1<<20) /* ??? */ /* MADI ONLY ? */
 #define HDSPM_WCK48        (1<<20) /* Frame ??? = HDSPM_SMUX */ /* AES32 ONLY */
 
-#define HDSPM_Midi0InterruptEnable (1<<22)
-#define HDSPM_Midi1InterruptEnable (1<<23)
+#define HDSPM_Midi0InterruptEnable 0x0400000
+#define HDSPM_Midi1InterruptEnable 0x0800000
+#define HDSPM_Midi2InterruptEnable 0x0200000
+#define HDSPM_Midi3InterruptEnable 0x4000000
 
 #define HDSPM_LineOut (1<<24) /* Analog Out on channel 63/64 on=1, mute=0 */
+#define HDSPe_FLOAT_FORMAT         0x2000000
 
 #define HDSPM_DS_DoubleWire (1<<26) /* AES32 ONLY */
 #define HDSPM_QS_DoubleWire (1<<27) /* AES32 ONLY */
@@ -198,11 +267,18 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_InputCoaxial   (HDSPM_InputSelect0)
 #define HDSPM_SyncRefMask    (HDSPM_SyncRef0|HDSPM_SyncRef1|\
 			      HDSPM_SyncRef2|HDSPM_SyncRef3)
-#define HDSPM_SyncRef_Word   0
-#define HDSPM_SyncRef_MADI   (HDSPM_SyncRef0)
 
-#define HDSPM_SYNC_FROM_WORD 0	/* Preferred sync reference */
-#define HDSPM_SYNC_FROM_MADI 1	/* choices - used by "pref_sync_ref" */
+#define HDSPM_c0_SyncRef0      0x2
+#define HDSPM_c0_SyncRef1      0x4
+#define HDSPM_c0_SyncRef2      0x8
+#define HDSPM_c0_SyncRef3      0x10
+#define HDSPM_c0_SyncRefMask   (HDSPM_c0_SyncRef0 | HDSPM_c0_SyncRef1 |\
+				HDSPM_c0_SyncRef2 | HDSPM_c0_SyncRef3)
+
+#define HDSPM_SYNC_FROM_WORD    0	/* Preferred sync reference */
+#define HDSPM_SYNC_FROM_MADI    1	/* choices - used by "pref_sync_ref" */
+#define HDSPM_SYNC_FROM_TCO     2
+#define HDSPM_SYNC_FROM_SYNC_IN 3
 
 #define HDSPM_Frequency32KHz    HDSPM_Frequency0
 #define HDSPM_Frequency44_1KHz  HDSPM_Frequency1
@@ -216,17 +292,6 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_Frequency192KHz   (HDSPM_QuadSpeed|HDSPM_Frequency1|\
 				 HDSPM_Frequency0)
 
-/* --- for internal discrimination */
-#define HDSPM_CLOCK_SOURCE_AUTOSYNC          0	/* Sample Clock Sources */
-#define HDSPM_CLOCK_SOURCE_INTERNAL_32KHZ    1
-#define HDSPM_CLOCK_SOURCE_INTERNAL_44_1KHZ  2
-#define HDSPM_CLOCK_SOURCE_INTERNAL_48KHZ    3
-#define HDSPM_CLOCK_SOURCE_INTERNAL_64KHZ    4
-#define HDSPM_CLOCK_SOURCE_INTERNAL_88_2KHZ  5
-#define HDSPM_CLOCK_SOURCE_INTERNAL_96KHZ    6
-#define HDSPM_CLOCK_SOURCE_INTERNAL_128KHZ   7
-#define HDSPM_CLOCK_SOURCE_INTERNAL_176_4KHZ 8
-#define HDSPM_CLOCK_SOURCE_INTERNAL_192KHZ   9
 
 /* Synccheck Status */
 #define HDSPM_SYNC_CHECK_NO_LOCK 0
@@ -236,14 +301,16 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 /* AutoSync References - used by "autosync_ref" control switch */
 #define HDSPM_AUTOSYNC_FROM_WORD      0
 #define HDSPM_AUTOSYNC_FROM_MADI      1
-#define HDSPM_AUTOSYNC_FROM_NONE      2
+#define HDSPM_AUTOSYNC_FROM_TCO       2
+#define HDSPM_AUTOSYNC_FROM_SYNC_IN   3
+#define HDSPM_AUTOSYNC_FROM_NONE      4
 
 /* Possible sources of MADI input */
 #define HDSPM_OPTICAL 0		/* optical   */
 #define HDSPM_COAXIAL 1		/* BNC */
 
 #define hdspm_encode_latency(x)       (((x)<<1) & HDSPM_LatencyMask)
-#define hdspm_decode_latency(x)       (((x) & HDSPM_LatencyMask)>>1)
+#define hdspm_decode_latency(x)       ((((x) & HDSPM_LatencyMask)>>1))
 
 #define hdspm_encode_in(x) (((x)&0x3)<<14)
 #define hdspm_decode_in(x) (((x)>>14)&0x3)
@@ -270,13 +337,21 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_AB_int             (1<<2)	/* InputChannel Opt=0, Coax=1
 					 * (like inp0)
 					 */
+
 #define HDSPM_madiLock           (1<<3)	/* MADI Locked =1, no=0 */
+#define HDSPM_madiSync          (1<<18) /* MADI is in sync */
+
+#define HDSPM_tcoLock    0x00000020 /* Optional TCO locked status FOR HDSPe MADI! */
+#define HDSPM_tcoSync    0x10000000 /* Optional TCO sync status */
+
+#define HDSPM_syncInLock 0x00010000 /* Sync In lock status FOR HDSPe MADI! */
+#define HDSPM_syncInSync 0x00020000 /* Sync In sync status FOR HDSPe MADI! */
 
 #define HDSPM_BufferPositionMask 0x000FFC0 /* Bit 6..15 : h/w buffer pointer */
-                                           /* since 64byte accurate last 6 bits 
-                                              are not used */
+			/* since 64byte accurate, last 6 bits are not used */
+
+
 
-#define HDSPM_madiSync          (1<<18) /* MADI is in sync */
 #define HDSPM_DoubleSpeedStatus (1<<19) /* (input) card in double speed */
 
 #define HDSPM_madiFreq0         (1<<22)	/* system freq 0=error */
@@ -287,8 +362,19 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_BufferID          (1<<26)	/* (Double)Buffer ID toggles with
 					 * Interrupt
 					 */
-#define HDSPM_midi0IRQPending   (1<<30)	/* MIDI IRQ is pending  */
-#define HDSPM_midi1IRQPending   (1<<31)	/* and aktiv */
+#define HDSPM_tco_detect         0x08000000
+#define HDSPM_tco_lock	         0x20000000
+
+#define HDSPM_s2_tco_detect      0x00000040
+#define HDSPM_s2_AEBO_D          0x00000080
+#define HDSPM_s2_AEBI_D          0x00000100
+
+
+#define HDSPM_midi0IRQPending    0x40000000
+#define HDSPM_midi1IRQPending    0x80000000
+#define HDSPM_midi2IRQPending    0x20000000
+#define HDSPM_midi2IRQPendingAES 0x00000020
+#define HDSPM_midi3IRQPending    0x00200000
 
 /* --- status bit helpers */
 #define HDSPM_madiFreqMask  (HDSPM_madiFreq0|HDSPM_madiFreq1|\
@@ -317,7 +403,10 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_wc_freq2 (1<<7)	/* 100=64, 101=88.2, 110=96, */
 /* missing Bit   for               111=128, 1000=176.4, 1001=192 */
 
-#define HDSPM_SelSyncRef0 (1<<8)	/* Sync Source in slave mode */
+#define HDSPM_SyncRef0 0x10000  /* Sync Reference */
+#define HDSPM_SyncRef1 0x20000
+
+#define HDSPM_SelSyncRef0 (1<<8)	/* AutoSync Source */
 #define HDSPM_SelSyncRef1 (1<<9)	/* 000=word, 001=MADI, */
 #define HDSPM_SelSyncRef2 (1<<10)	/* 111=no valid signal */
 
@@ -331,11 +420,19 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_wcFreq88_2  (HDSPM_wc_freq0|HDSPM_wc_freq2)
 #define HDSPM_wcFreq96    (HDSPM_wc_freq1|HDSPM_wc_freq2)
 
+#define HDSPM_status1_F_0 0x0400000
+#define HDSPM_status1_F_1 0x0800000
+#define HDSPM_status1_F_2 0x1000000
+#define HDSPM_status1_F_3 0x2000000
+#define HDSPM_status1_freqMask (HDSPM_status1_F_0|HDSPM_status1_F_1|HDSPM_status1_F_2|HDSPM_status1_F_3)
+
 
 #define HDSPM_SelSyncRefMask       (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1|\
 				    HDSPM_SelSyncRef2)
 #define HDSPM_SelSyncRef_WORD      0
 #define HDSPM_SelSyncRef_MADI      (HDSPM_SelSyncRef0)
+#define HDSPM_SelSyncRef_TCO       (HDSPM_SelSyncRef1)
+#define HDSPM_SelSyncRef_SyncIn    (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1)
 #define HDSPM_SelSyncRef_NVALID    (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1|\
 				    HDSPM_SelSyncRef2)
 
@@ -345,7 +442,7 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 /* status */
 #define HDSPM_AES32_wcLock	0x0200000
 #define HDSPM_AES32_wcFreq_bit  22
-/* (status >> HDSPM_AES32_wcFreq_bit) & 0xF gives WC frequency (cf function 
+/* (status >> HDSPM_AES32_wcFreq_bit) & 0xF gives WC frequency (cf function
   HDSPM_bit2freq */
 #define HDSPM_AES32_syncref_bit  16
 /* (status >> HDSPM_AES32_syncref_bit) & 0xF gives sync source */
@@ -398,28 +495,184 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define MADI_DS_CHANNELS       32
 #define MADI_QS_CHANNELS       16
 
+#define RAYDAT_SS_CHANNELS     36
+#define RAYDAT_DS_CHANNELS     20
+#define RAYDAT_QS_CHANNELS     12
+
+#define AIO_IN_SS_CHANNELS        14
+#define AIO_IN_DS_CHANNELS        10
+#define AIO_IN_QS_CHANNELS        8
+#define AIO_OUT_SS_CHANNELS        16
+#define AIO_OUT_DS_CHANNELS        12
+#define AIO_OUT_QS_CHANNELS        10
+
 /* the size of a substream (1 mono data stream) */
 #define HDSPM_CHANNEL_BUFFER_SAMPLES  (16*1024)
 #define HDSPM_CHANNEL_BUFFER_BYTES    (4*HDSPM_CHANNEL_BUFFER_SAMPLES)
 
 /* the size of the area we need to allocate for DMA transfers. the
    size is the same regardless of the number of channels, and
-   also the latency to use. 
+   also the latency to use.
    for one direction !!!
 */
 #define HDSPM_DMA_AREA_BYTES (HDSPM_MAX_CHANNELS * HDSPM_CHANNEL_BUFFER_BYTES)
 #define HDSPM_DMA_AREA_KILOBYTES (HDSPM_DMA_AREA_BYTES/1024)
 
 /* revisions >= 230 indicate AES32 card */
-#define HDSPM_AESREVISION 230
+#define HDSPM_MADI_REV		210
+#define HDSPM_RAYDAT_REV	211
+#define HDSPM_AIO_REV		212
+#define HDSPM_MADIFACE_REV	213
+#define HDSPM_AES_REV		240
 
 /* speed factor modes */
 #define HDSPM_SPEED_SINGLE 0
 #define HDSPM_SPEED_DOUBLE 1
 #define HDSPM_SPEED_QUAD   2
+
 /* names for speed modes */
 static char *hdspm_speed_names[] = { "single", "double", "quad" };
 
+static char *texts_autosync_aes_tco[] = { "Word Clock",
+					  "AES1", "AES2", "AES3", "AES4",
+					  "AES5", "AES6", "AES7", "AES8",
+					  "TCO" };
+static char *texts_autosync_aes[] = { "Word Clock",
+				      "AES1", "AES2", "AES3", "AES4",
+				      "AES5", "AES6", "AES7", "AES8" };
+static char *texts_autosync_madi_tco[] = { "Word Clock",
+					   "MADI", "TCO", "Sync In" };
+static char *texts_autosync_madi[] = { "Word Clock",
+				       "MADI", "Sync In" };
+
+static char *texts_autosync_raydat_tco[] = {
+	"Word Clock",
+	"ADAT 1", "ADAT 2", "ADAT 3", "ADAT 4",
+	"AES", "SPDIF", "TCO", "Sync In"
+};
+static char *texts_autosync_raydat[] = {
+	"Word Clock",
+	"ADAT 1", "ADAT 2", "ADAT 3", "ADAT 4",
+	"AES", "SPDIF", "Sync In"
+};
+static char *texts_autosync_aio_tco[] = {
+	"Word Clock",
+	"ADAT", "AES", "SPDIF", "TCO", "Sync In"
+};
+static char *texts_autosync_aio[] = { "Word Clock",
+				      "ADAT", "AES", "SPDIF", "Sync In" };
+
+static char *texts_freq[] = {
+	"No Lock",
+	"32 kHz",
+	"44.1 kHz",
+	"48 kHz",
+	"64 kHz",
+	"88.2 kHz",
+	"96 kHz",
+	"128 kHz",
+	"176.4 kHz",
+	"192 kHz"
+};
+
+static char *texts_sync_status[] = {
+	"no lock",
+	"lock",
+	"sync"
+};
+
+static char *texts_ports_madi[] = {
+	"MADI.1", "MADI.2", "MADI.3", "MADI.4", "MADI.5", "MADI.6",
+	"MADI.7", "MADI.8", "MADI.9", "MADI.10", "MADI.11", "MADI.12",
+	"MADI.13", "MADI.14", "MADI.15", "MADI.16", "MADI.17", "MADI.18",
+	"MADI.19", "MADI.20", "MADI.21", "MADI.22", "MADI.23", "MADI.24",
+	"MADI.25", "MADI.26", "MADI.27", "MADI.28", "MADI.29", "MADI.30",
+	"MADI.31", "MADI.32", "MADI.33", "MADI.34", "MADI.35", "MADI.36",
+	"MADI.37", "MADI.38", "MADI.39", "MADI.40", "MADI.41", "MADI.42",
+	"MADI.43", "MADI.44", "MADI.45", "MADI.46", "MADI.47", "MADI.48",
+	"MADI.49", "MADI.50", "MADI.51", "MADI.52", "MADI.53", "MADI.54",
+	"MADI.55", "MADI.56", "MADI.57", "MADI.58", "MADI.59", "MADI.60",
+	"MADI.61", "MADI.62", "MADI.63", "MADI.64",
+};
+
+
+static char *texts_ports_raydat_ss[] = {
+	"ADAT1.1", "ADAT1.2", "ADAT1.3", "ADAT1.4", "ADAT1.5", "ADAT1.6",
+	"ADAT1.7", "ADAT1.8", "ADAT2.1", "ADAT2.2", "ADAT2.3", "ADAT2.4",
+	"ADAT2.5", "ADAT2.6", "ADAT2.7", "ADAT2.8", "ADAT3.1", "ADAT3.2",
+	"ADAT3.3", "ADAT3.4", "ADAT3.5", "ADAT3.6", "ADAT3.7", "ADAT3.8",
+	"ADAT4.1", "ADAT4.2", "ADAT4.3", "ADAT4.4", "ADAT4.5", "ADAT4.6",
+	"ADAT4.7", "ADAT4.8",
+	"AES.L", "AES.R",
+	"SPDIF.L", "SPDIF.R"
+};
+
+static char *texts_ports_raydat_ds[] = {
+	"ADAT1.1", "ADAT1.2", "ADAT1.3", "ADAT1.4",
+	"ADAT2.1", "ADAT2.2", "ADAT2.3", "ADAT2.4",
+	"ADAT3.1", "ADAT3.2", "ADAT3.3", "ADAT3.4",
+	"ADAT4.1", "ADAT4.2", "ADAT4.3", "ADAT4.4",
+	"AES.L", "AES.R",
+	"SPDIF.L", "SPDIF.R"
+};
+
+static char *texts_ports_raydat_qs[] = {
+	"ADAT1.1", "ADAT1.2",
+	"ADAT2.1", "ADAT2.2",
+	"ADAT3.1", "ADAT3.2",
+	"ADAT4.1", "ADAT4.2",
+	"AES.L", "AES.R",
+	"SPDIF.L", "SPDIF.R"
+};
+
+
+static char *texts_ports_aio_in_ss[] = {
+	"Analogue.L", "Analogue.R",
+	"AES.L", "AES.R",
+	"SPDIF.L", "SPDIF.R",
+	"ADAT.1", "ADAT.2", "ADAT.3", "ADAT.4", "ADAT.5", "ADAT.6",
+	"ADAT.7", "ADAT.8"
+};
+
+static char *texts_ports_aio_out_ss[] = {
+	"Analogue.L", "Analogue.R",
+	"AES.L", "AES.R",
+	"SPDIF.L", "SPDIF.R",
+	"ADAT.1", "ADAT.2", "ADAT.3", "ADAT.4", "ADAT.5", "ADAT.6",
+	"ADAT.7", "ADAT.8",
+	"Phone.L", "Phone.R"
+};
+
+static char *texts_ports_aio_in_ds[] = {
+	"Analogue.L", "Analogue.R",
+	"AES.L", "AES.R",
+	"SPDIF.L", "SPDIF.R",
+	"ADAT.1", "ADAT.2", "ADAT.3", "ADAT.4"
+};
+
+static char *texts_ports_aio_out_ds[] = {
+	"Analogue.L", "Analogue.R",
+	"AES.L", "AES.R",
+	"SPDIF.L", "SPDIF.R",
+	"ADAT.1", "ADAT.2", "ADAT.3", "ADAT.4",
+	"Phone.L", "Phone.R"
+};
+
+static char *texts_ports_aio_in_qs[] = {
+	"Analogue.L", "Analogue.R",
+	"AES.L", "AES.R",
+	"SPDIF.L", "SPDIF.R",
+	"ADAT.1", "ADAT.2", "ADAT.3", "ADAT.4"
+};
+
+static char *texts_ports_aio_out_qs[] = {
+	"Analogue.L", "Analogue.R",
+	"AES.L", "AES.R",
+	"SPDIF.L", "SPDIF.R",
+	"ADAT.1", "ADAT.2", "ADAT.3", "ADAT.4",
+	"Phone.L", "Phone.R"
+};
+
 struct hdspm_midi {
 	struct hdspm *hdspm;
 	int id;
@@ -430,6 +683,21 @@ struct hdspm_midi {
 	struct timer_list timer;
 	spinlock_t lock;
 	int pending;
+	int dataIn;
+	int statusIn;
+	int dataOut;
+	int statusOut;
+	int ie;
+	int irq;
+};
+
+struct hdspm_tco {
+	int input;
+	int framerate;
+	int wordclock;
+	int samplerate;
+	int pull;
+	int term; /* 0 = off, 1 = on */
 };
 
 struct hdspm {
@@ -441,21 +709,39 @@ struct hdspm {
 	char *card_name;	     /* for procinfo */
 	unsigned short firmware_rev; /* dont know if relevant (yes if AES32)*/
 
-	unsigned char is_aes32;    /* indicates if card is AES32 */
+	uint8_t io_type;
 
-	int precise_ptr;	/* use precise pointers, to be tested */
 	int monitor_outs;	/* set up monitoring outs init flag */
 
 	u32 control_register;	/* cached value */
 	u32 control2_register;	/* cached value */
+	u32 settings_register;
 
-	struct hdspm_midi midi[2];
+	struct hdspm_midi midi[4];
 	struct tasklet_struct midi_tasklet;
 
 	size_t period_bytes;
-	unsigned char ss_channels;	/* channels of card in single speed */
-	unsigned char ds_channels;	/* Double Speed */
-	unsigned char qs_channels;	/* Quad Speed */
+	unsigned char ss_in_channels;
+	unsigned char ds_in_channels;
+	unsigned char qs_in_channels;
+	unsigned char ss_out_channels;
+	unsigned char ds_out_channels;
+	unsigned char qs_out_channels;
+
+	unsigned char max_channels_in;
+	unsigned char max_channels_out;
+
+	char *channel_map_in;
+	char *channel_map_out;
+
+	char *channel_map_in_ss, *channel_map_in_ds, *channel_map_in_qs;
+	char *channel_map_out_ss, *channel_map_out_ds, *channel_map_out_qs;
+
+	char **port_names_in;
+	char **port_names_out;
+
+	char **port_names_in_ss, **port_names_in_ds, **port_names_in_qs;
+	char **port_names_out_ss, **port_names_out_ds, **port_names_out_qs;
 
 	unsigned char *playback_buffer;	/* suitably aligned address */
 	unsigned char *capture_buffer;	/* suitably aligned address */
@@ -468,14 +754,13 @@ struct hdspm {
 	int last_internal_sample_rate;
 	int system_sample_rate;
 
-	char *channel_map;	/* channel map for DS and Quadspeed */
-
 	int dev;		/* Hardware vars... */
 	int irq;
 	unsigned long port;
 	void __iomem *iobase;
 
 	int irq_count;		/* for debug */
+	int midiPorts;
 
 	struct snd_card *card;	/* one card */
 	struct snd_pcm *pcm;		/* has one pcm */
@@ -487,28 +772,15 @@ struct hdspm {
 	struct snd_kcontrol *playback_mixer_ctls[HDSPM_MAX_CHANNELS];
 	/* but input to much, so not used */
 	struct snd_kcontrol *input_mixer_ctls[HDSPM_MAX_CHANNELS];
-	/* full mixer accessible over mixer ioctl or hwdep-device */
+	/* full mixer accessable over mixer ioctl or hwdep-device */
 	struct hdspm_mixer *mixer;
 
-};
+	struct hdspm_tco *tco;  /* NULL if no TCO detected */
 
-/* These tables map the ALSA channels 1..N to the channels that we
-   need to use in order to find the relevant channel buffer. RME
-   refer to this kind of mapping as between "the ADAT channel and
-   the DMA channel." We index it using the logical audio channel,
-   and the value is the DMA channel (i.e. channel buffer number)
-   where the data for that channel can be read/written from/to.
-*/
+	char **texts_autosync;
+	int texts_autosync_items;
 
-static char channel_map_madi_ss[HDSPM_MAX_CHANNELS] = {
-   0, 1, 2, 3, 4, 5, 6, 7,
-   8, 9, 10, 11, 12, 13, 14, 15,
-   16, 17, 18, 19, 20, 21, 22, 23,
-   24, 25, 26, 27, 28, 29, 30, 31,
-   32, 33, 34, 35, 36, 37, 38, 39,
-   40, 41, 42, 43, 44, 45, 46, 47,
-   48, 49, 50, 51, 52, 53, 54, 55,
-   56, 57, 58, 59, 60, 61, 62, 63
+	cycles_t last_interrupt;
 };
 
 
@@ -532,11 +804,11 @@ static int __devinit snd_hdspm_create_alsa_devices(struct snd_card *card,
 static int __devinit snd_hdspm_create_pcm(struct snd_card *card,
 					  struct hdspm * hdspm);
 
-static inline void snd_hdspm_initialize_midi_flush(struct hdspm * hdspm);
-static int hdspm_update_simple_mixer_controls(struct hdspm * hdspm);
-static int hdspm_autosync_ref(struct hdspm * hdspm);
-static int snd_hdspm_set_defaults(struct hdspm * hdspm);
-static void hdspm_set_sgbuf(struct hdspm * hdspm,
+static inline void snd_hdspm_initialize_midi_flush(struct hdspm *hdspm);
+static int hdspm_update_simple_mixer_controls(struct hdspm *hdspm);
+static int hdspm_autosync_ref(struct hdspm *hdspm);
+static int snd_hdspm_set_defaults(struct hdspm *hdspm);
+static void hdspm_set_sgbuf(struct hdspm *hdspm,
 			    struct snd_pcm_substream *substream,
 			     unsigned int reg, int channels);
 
@@ -550,7 +822,7 @@ static inline int HDSPM_bit2freq(int n)
 	return bit2freq_tab[n];
 }
 
-/* Write/read to/from HDSPM with Addresses in Bytes
+/* Write/read to/from HDSPM with Adresses in Bytes
    not words but only 32Bit writes are allowed */
 
 static inline void hdspm_write(struct hdspm * hdspm, unsigned int reg,
@@ -564,8 +836,8 @@ static inline unsigned int hdspm_read(struct hdspm * hdspm, unsigned int reg)
 	return readl(hdspm->iobase + reg);
 }
 
-/* for each output channel (chan) I have an Input (in) and Playback (pb) Fader 
-   mixer is write only on hardware so we have to cache him for read 
+/* for each output channel (chan) I have an Input (in) and Playback (pb) Fader
+   mixer is write only on hardware so we have to cache him for read
    each fader is a u32, but uses only the first 16 bit */
 
 static inline int hdspm_read_in_gain(struct hdspm * hdspm, unsigned int chan,
@@ -641,30 +913,67 @@ static int snd_hdspm_use_is_exclusive(struct hdspm *hdspm)
 /* check for external sample rate */
 static int hdspm_external_sample_rate(struct hdspm *hdspm)
 {
-	if (hdspm->is_aes32) {
-		unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
-		unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
-		unsigned int timecode =
-			hdspm_read(hdspm, HDSPM_timecodeRegister);
+	unsigned int status, status2, timecode;
+	int syncref, rate = 0, rate_bits;
 
-		int syncref = hdspm_autosync_ref(hdspm);
+	switch (hdspm->io_type) {
+	case AES32:
+		status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+		status = hdspm_read(hdspm, HDSPM_statusRegister);
+		timecode =	hdspm_read(hdspm, HDSPM_timecodeRegister);
+
+		syncref = hdspm_autosync_ref(hdspm);
 
 		if (syncref == HDSPM_AES32_AUTOSYNC_FROM_WORD &&
 				status & HDSPM_AES32_wcLock)
-			return HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit)
-					      & 0xF);
+			return HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit) & 0xF);
+
 		if (syncref >= HDSPM_AES32_AUTOSYNC_FROM_AES1 &&
-			syncref <= HDSPM_AES32_AUTOSYNC_FROM_AES8 &&
-			status2 & (HDSPM_LockAES >>
-			          (syncref - HDSPM_AES32_AUTOSYNC_FROM_AES1)))
-			return HDSPM_bit2freq((timecode >>
-			  (4*(syncref-HDSPM_AES32_AUTOSYNC_FROM_AES1))) & 0xF);
+				syncref <= HDSPM_AES32_AUTOSYNC_FROM_AES8 &&
+				status2 & (HDSPM_LockAES >>
+				(syncref - HDSPM_AES32_AUTOSYNC_FROM_AES1)))
+			return HDSPM_bit2freq((timecode >> (4*(syncref-HDSPM_AES32_AUTOSYNC_FROM_AES1))) & 0xF);
 		return 0;
-	} else {
-		unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
-		unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
-		unsigned int rate_bits;
-		int rate = 0;
+		break;
+
+	case MADIface:
+		status = hdspm_read(hdspm, HDSPM_statusRegister);
+
+		if (!(status & HDSPM_madiLock)) {
+			rate = 0;  /* no lock */
+		} else {
+			switch (status & (HDSPM_status1_freqMask)) {
+			case HDSPM_status1_F_0*1:
+				rate = 32000; break;
+			case HDSPM_status1_F_0*2:
+				rate = 44100; break;
+			case HDSPM_status1_F_0*3:
+				rate = 48000; break;
+			case HDSPM_status1_F_0*4:
+				rate = 64000; break;
+			case HDSPM_status1_F_0*5:
+				rate = 88200; break;
+			case HDSPM_status1_F_0*6:
+				rate = 96000; break;
+			case HDSPM_status1_F_0*7:
+				rate = 128000; break;
+			case HDSPM_status1_F_0*8:
+				rate = 176400; break;
+			case HDSPM_status1_F_0*9:
+				rate = 192000; break;
+			default:
+				rate = 0; break;
+			}
+		}
+
+		break;
+
+	case MADI:
+	case AIO:
+	case RayDAT:
+		status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+		status = hdspm_read(hdspm, HDSPM_statusRegister);
+		rate = 0;
 
 		/* if wordclock has synced freq and wordclock is valid */
 		if ((status2 & HDSPM_wcLock) != 0 &&
@@ -672,6 +981,7 @@ static int hdspm_external_sample_rate(struct hdspm *hdspm)
 
 			rate_bits = status2 & HDSPM_wcFreqMask;
 
+
 			switch (rate_bits) {
 			case HDSPM_wcFreq32:
 				rate = 32000;
@@ -691,7 +1001,6 @@ static int hdspm_external_sample_rate(struct hdspm *hdspm)
 			case HDSPM_wcFreq96:
 				rate = 96000;
 				break;
-				/* Quadspeed Bit missing ???? */
 			default:
 				rate = 0;
 				break;
@@ -702,10 +1011,10 @@ static int hdspm_external_sample_rate(struct hdspm *hdspm)
 		 * word has priority to MADI
 		 */
 		if (rate != 0 &&
-	            (status2 & HDSPM_SelSyncRefMask) == HDSPM_SelSyncRef_WORD)
+		(status2 & HDSPM_SelSyncRefMask) == HDSPM_SelSyncRef_WORD)
 			return rate;
 
-		/* maby a madi input (which is taken if sel sync is madi) */
+		/* maybe a madi input (which is taken if sel sync is madi) */
 		if (status & HDSPM_madiLock) {
 			rate_bits = status & HDSPM_madiFreqMask;
 
@@ -742,36 +1051,26 @@ static int hdspm_external_sample_rate(struct hdspm *hdspm)
 				break;
 			}
 		}
-		return rate;
+		break;
 	}
+
+	return rate;
 }
 
 /* Latency function */
-static inline void hdspm_compute_period_size(struct hdspm * hdspm)
+static inline void hdspm_compute_period_size(struct hdspm *hdspm)
 {
-	hdspm->period_bytes =
-	    1 << ((hdspm_decode_latency(hdspm->control_register) + 8));
+	hdspm->period_bytes = 1 << ((hdspm_decode_latency(hdspm->control_register) + 8));
 }
 
-static snd_pcm_uframes_t hdspm_hw_pointer(struct hdspm * hdspm)
+
+static snd_pcm_uframes_t hdspm_hw_pointer(struct hdspm *hdspm)
 {
 	int position;
 
 	position = hdspm_read(hdspm, HDSPM_statusRegister);
-
-	if (!hdspm->precise_ptr)
-		return (position & HDSPM_BufferID) ?
-			(hdspm->period_bytes / 4) : 0;
-
-	/* hwpointer comes in bytes and is 64Bytes accurate (by docu since
-	   PCI Burst)
-	   i have experimented that it is at most 64 Byte to much for playing 
-	   so substraction of 64 byte should be ok for ALSA, but use it only
-	   for application where you know what you do since if you come to
-	   near with record pointer it can be a disaster */
-
 	position &= HDSPM_BufferPositionMask;
-	position = ((position - 64) % (2 * hdspm->period_bytes)) / 4;
+	position /= 4; /* Bytes per sample */
 
 	return position;
 }
@@ -805,7 +1104,7 @@ static void hdspm_silence_playback(struct hdspm *hdspm)
 	}
 }
 
-static int hdspm_set_interrupt_interval(struct hdspm * s, unsigned int frames)
+static int hdspm_set_interrupt_interval(struct hdspm *s, unsigned int frames)
 {
 	int n;
 
@@ -829,21 +1128,53 @@ static int hdspm_set_interrupt_interval(struct hdspm * s, unsigned int frames)
 	return 0;
 }
 
+static u64 hdspm_calc_dds_value(struct hdspm *hdspm, u64 period)
+{
+	u64 freq_const;
+
+	if (period == 0)
+		return 0;
+
+	switch (hdspm->io_type) {
+	case MADI:
+	case AES32:
+		freq_const = 110069313433624ULL;
+		break;
+	case RayDAT:
+	case AIO:
+		freq_const = 104857600000000ULL;
+		break;
+	case MADIface:
+		freq_const = 131072000000000ULL;
+	}
+
+	return div_u64(freq_const, period);
+}
+
+
 static void hdspm_set_dds_value(struct hdspm *hdspm, int rate)
 {
 	u64 n;
-	
+
 	if (rate >= 112000)
 		rate /= 4;
 	else if (rate >= 56000)
 		rate /= 2;
 
-	/* RME says n = 104857600000000, but in the windows MADI driver, I see:
-//	return 104857600000000 / rate; // 100 MHz
-	return 110100480000000 / rate; // 105 MHz
-        */	   
-	/* n = 104857600000000ULL; */ /*  =  2^20 * 10^8 */
-	n = 110100480000000ULL;    /* Value checked for AES32 and MADI */
+	switch (hdspm->io_type) {
+	case MADIface:
+	  n = 131072000000000ULL;  /* 125 MHz */
+	  break;
+	case MADI:
+	case AES32:
+	  n = 110069313433624ULL;  /* 105 MHz */
+	  break;
+	case RayDAT:
+	case AIO:
+	  n = 104857600000000ULL;  /* 100 MHz */
+	  break;
+	}
+
 	n = div_u64(n, rate);
 	/* n should be less than 2^32 for being written to FREQ register */
 	snd_BUG_ON(n >> 32);
@@ -864,13 +1195,13 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 
 	if (!(hdspm->control_register & HDSPM_ClockModeMaster)) {
 
-	        /* SLAVE --- */ 
+		/* SLAVE --- */
 		if (called_internally) {
 
-        	  /* request from ctl or card initialization 
-	             just make a warning an remember setting 
-		     for future master mode switching */
-    
+			/* request from ctl or card initialization
+			   just make a warning an remember setting
+			   for future master mode switching */
+
 			snd_printk(KERN_WARNING "HDSPM: "
 				   "Warning: device is not running "
 				   "as a clock master.\n");
@@ -907,7 +1238,7 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 
 	   Note that a similar but essentially insoluble problem exists for
 	   externally-driven rate changes. All we can do is to flag rate
-	   changes in the read/write routines.  
+	   changes in the read/write routines.
 	 */
 
 	if (current_rate <= 48000)
@@ -975,16 +1306,35 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 	/* For AES32, need to set DDS value in FREQ register
 	   For MADI, also apparently */
 	hdspm_set_dds_value(hdspm, rate);
-	
-	if (hdspm->is_aes32 && rate != current_rate)
+
+	if (AES32 == hdspm->io_type && rate != current_rate)
 		hdspm_write(hdspm, HDSPM_eeprom_wr, 0);
-	
-	/* For AES32 and for MADI (at least rev 204), channel_map needs to
-	 * always be channel_map_madi_ss, whatever the sample rate */
-	hdspm->channel_map = channel_map_madi_ss;
 
 	hdspm->system_sample_rate = rate;
 
+	if (rate <= 48000) {
+		hdspm->channel_map_in = hdspm->channel_map_in_ss;
+		hdspm->channel_map_out = hdspm->channel_map_out_ss;
+		hdspm->max_channels_in = hdspm->ss_in_channels;
+		hdspm->max_channels_out = hdspm->ss_out_channels;
+		hdspm->port_names_in = hdspm->port_names_in_ss;
+		hdspm->port_names_out = hdspm->port_names_out_ss;
+	} else if (rate <= 96000) {
+		hdspm->channel_map_in = hdspm->channel_map_in_ds;
+		hdspm->channel_map_out = hdspm->channel_map_out_ds;
+		hdspm->max_channels_in = hdspm->ds_in_channels;
+		hdspm->max_channels_out = hdspm->ds_out_channels;
+		hdspm->port_names_in = hdspm->port_names_in_ds;
+		hdspm->port_names_out = hdspm->port_names_out_ds;
+	} else {
+		hdspm->channel_map_in = hdspm->channel_map_in_qs;
+		hdspm->channel_map_out = hdspm->channel_map_out_qs;
+		hdspm->max_channels_in = hdspm->qs_in_channels;
+		hdspm->max_channels_out = hdspm->qs_out_channels;
+		hdspm->port_names_in = hdspm->port_names_in_qs;
+		hdspm->port_names_out = hdspm->port_names_out_qs;
+	}
+
 	if (not_set != 0)
 		return -1;
 
@@ -1019,39 +1369,26 @@ static inline unsigned char snd_hdspm_midi_read_byte (struct hdspm *hdspm,
 						      int id)
 {
 	/* the hardware already does the relevant bit-mask with 0xff */
-	if (id)
-		return hdspm_read(hdspm, HDSPM_midiDataIn1);
-	else
-		return hdspm_read(hdspm, HDSPM_midiDataIn0);
+	return hdspm_read(hdspm, hdspm->midi[id].dataIn);
 }
 
 static inline void snd_hdspm_midi_write_byte (struct hdspm *hdspm, int id,
 					      int val)
 {
 	/* the hardware already does the relevant bit-mask with 0xff */
-	if (id)
-		hdspm_write(hdspm, HDSPM_midiDataOut1, val);
-	else
-		hdspm_write(hdspm, HDSPM_midiDataOut0, val);
+	return hdspm_write(hdspm, hdspm->midi[id].dataOut, val);
 }
 
 static inline int snd_hdspm_midi_input_available (struct hdspm *hdspm, int id)
 {
-	if (id)
-		return (hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xff);
-	else
-		return (hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xff);
+	return hdspm_read(hdspm, hdspm->midi[id].statusIn) & 0xFF;
 }
 
 static inline int snd_hdspm_midi_output_possible (struct hdspm *hdspm, int id)
 {
 	int fifo_bytes_used;
 
-	if (id)
-		fifo_bytes_used = hdspm_read(hdspm, HDSPM_midiStatusOut1);
-	else
-		fifo_bytes_used = hdspm_read(hdspm, HDSPM_midiStatusOut0);
-	fifo_bytes_used &= 0xff;
+	fifo_bytes_used = hdspm_read(hdspm, hdspm->midi[id].statusOut) & 0xFF;
 
 	if (fifo_bytes_used < 128)
 		return  128 - fifo_bytes_used;
@@ -1074,7 +1411,7 @@ static int snd_hdspm_midi_output_write (struct hdspm_midi *hmidi)
 	unsigned char buf[128];
 
 	/* Output is not interrupt driven */
-		
+
 	spin_lock_irqsave (&hmidi->lock, flags);
 	if (hmidi->output &&
 	    !snd_rawmidi_transmit_empty (hmidi->output)) {
@@ -1083,11 +1420,11 @@ static int snd_hdspm_midi_output_write (struct hdspm_midi *hmidi)
 		if (n_pending > 0) {
 			if (n_pending > (int)sizeof (buf))
 				n_pending = sizeof (buf);
-		
+
 			to_write = snd_rawmidi_transmit (hmidi->output, buf,
 							 n_pending);
 			if (to_write > 0) {
-				for (i = 0; i < to_write; ++i) 
+				for (i = 0; i < to_write; ++i)
 					snd_hdspm_midi_write_byte (hmidi->hdspm,
 								   hmidi->id,
 								   buf[i]);
@@ -1127,12 +1464,11 @@ static int snd_hdspm_midi_input_read (struct hdspm_midi *hmidi)
 		}
 	}
 	hmidi->pending = 0;
-	if (hmidi->id)
-		hmidi->hdspm->control_register |= HDSPM_Midi1InterruptEnable;
-	else
-		hmidi->hdspm->control_register |= HDSPM_Midi0InterruptEnable;
+
+	hmidi->hdspm->control_register |= hmidi->ie;
 	hdspm_write(hmidi->hdspm, HDSPM_controlRegister,
 		    hmidi->hdspm->control_register);
+
 	spin_unlock_irqrestore (&hmidi->lock, flags);
 	return snd_hdspm_midi_output_write (hmidi);
 }
@@ -1143,20 +1479,18 @@ snd_hdspm_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)
 	struct hdspm *hdspm;
 	struct hdspm_midi *hmidi;
 	unsigned long flags;
-	u32 ie;
 
 	hmidi = substream->rmidi->private_data;
 	hdspm = hmidi->hdspm;
-	ie = hmidi->id ?
-		HDSPM_Midi1InterruptEnable : HDSPM_Midi0InterruptEnable;
+
 	spin_lock_irqsave (&hdspm->lock, flags);
 	if (up) {
-		if (!(hdspm->control_register & ie)) {
+		if (!(hdspm->control_register & hmidi->ie)) {
 			snd_hdspm_flush_midi_input (hdspm, hmidi->id);
-			hdspm->control_register |= ie;
+			hdspm->control_register |= hmidi->ie;
 		}
 	} else {
-		hdspm->control_register &= ~ie;
+		hdspm->control_register &= ~hmidi->ie;
 	}
 
 	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
@@ -1167,14 +1501,14 @@ static void snd_hdspm_midi_output_timer(unsigned long data)
 {
 	struct hdspm_midi *hmidi = (struct hdspm_midi *) data;
 	unsigned long flags;
-	
+
 	snd_hdspm_midi_output_write(hmidi);
 	spin_lock_irqsave (&hmidi->lock, flags);
 
 	/* this does not bump hmidi->istimer, because the
 	   kernel automatically removed the timer when it
 	   expired, and we are now adding it back, thus
-	   leaving istimer wherever it was set before.  
+	   leaving istimer wherever it was set before.
 	*/
 
 	if (hmidi->istimer) {
@@ -1288,22 +1622,103 @@ static int __devinit snd_hdspm_create_midi (struct snd_card *card,
 	hdspm->midi[id].hdspm = hdspm;
 	spin_lock_init (&hdspm->midi[id].lock);
 
-	sprintf (buf, "%s MIDI %d", card->shortname, id+1);
-	err = snd_rawmidi_new (card, buf, id, 1, 1, &hdspm->midi[id].rmidi);
-	if (err < 0)
-		return err;
+	if (0 == id) {
+		if (MADIface == hdspm->io_type) {
+			/* MIDI-over-MADI on HDSPe MADIface */
+			hdspm->midi[0].dataIn = HDSPM_midiDataIn2;
+			hdspm->midi[0].statusIn = HDSPM_midiStatusIn2;
+			hdspm->midi[0].dataOut = HDSPM_midiDataOut2;
+			hdspm->midi[0].statusOut = HDSPM_midiStatusOut2;
+			hdspm->midi[0].ie = HDSPM_Midi2InterruptEnable;
+			hdspm->midi[0].irq = HDSPM_midi2IRQPending;
+		} else {
+			hdspm->midi[0].dataIn = HDSPM_midiDataIn0;
+			hdspm->midi[0].statusIn = HDSPM_midiStatusIn0;
+			hdspm->midi[0].dataOut = HDSPM_midiDataOut0;
+			hdspm->midi[0].statusOut = HDSPM_midiStatusOut0;
+			hdspm->midi[0].ie = HDSPM_Midi0InterruptEnable;
+			hdspm->midi[0].irq = HDSPM_midi0IRQPending;
+		}
+	} else if (1 == id) {
+		hdspm->midi[1].dataIn = HDSPM_midiDataIn1;
+		hdspm->midi[1].statusIn = HDSPM_midiStatusIn1;
+		hdspm->midi[1].dataOut = HDSPM_midiDataOut1;
+		hdspm->midi[1].statusOut = HDSPM_midiStatusOut1;
+		hdspm->midi[1].ie = HDSPM_Midi1InterruptEnable;
+		hdspm->midi[1].irq = HDSPM_midi1IRQPending;
+	} else if ((2 == id) && (MADI == hdspm->io_type)) {
+		/* MIDI-over-MADI on HDSPe MADI */
+		hdspm->midi[2].dataIn = HDSPM_midiDataIn2;
+		hdspm->midi[2].statusIn = HDSPM_midiStatusIn2;
+		hdspm->midi[2].dataOut = HDSPM_midiDataOut2;
+		hdspm->midi[2].statusOut = HDSPM_midiStatusOut2;
+		hdspm->midi[2].ie = HDSPM_Midi2InterruptEnable;
+		hdspm->midi[2].irq = HDSPM_midi2IRQPending;
+	} else if (2 == id) {
+		/* TCO MTC, read only */
+		hdspm->midi[2].dataIn = HDSPM_midiDataIn2;
+		hdspm->midi[2].statusIn = HDSPM_midiStatusIn2;
+		hdspm->midi[2].dataOut = -1;
+		hdspm->midi[2].statusOut = -1;
+		hdspm->midi[2].ie = HDSPM_Midi2InterruptEnable;
+		hdspm->midi[2].irq = HDSPM_midi2IRQPendingAES;
+	} else if (3 == id) {
+		/* TCO MTC on HDSPe MADI */
+		hdspm->midi[3].dataIn = HDSPM_midiDataIn3;
+		hdspm->midi[3].statusIn = HDSPM_midiStatusIn3;
+		hdspm->midi[3].dataOut = -1;
+		hdspm->midi[3].statusOut = -1;
+		hdspm->midi[3].ie = HDSPM_Midi3InterruptEnable;
+		hdspm->midi[3].irq = HDSPM_midi3IRQPending;
+	}
+
+	if ((id < 2) || ((2 == id) && ((MADI == hdspm->io_type) ||
+					(MADIface == hdspm->io_type)))) {
+		if ((id == 0) && (MADIface == hdspm->io_type)) {
+			sprintf(buf, "%s MIDIoverMADI", card->shortname);
+		} else if ((id == 2) && (MADI == hdspm->io_type)) {
+			sprintf(buf, "%s MIDIoverMADI", card->shortname);
+		} else {
+			sprintf(buf, "%s MIDI %d", card->shortname, id+1);
+		}
+		err = snd_rawmidi_new(card, buf, id, 1, 1,
+				&hdspm->midi[id].rmidi);
+		if (err < 0)
+			return err;
 
-	sprintf(hdspm->midi[id].rmidi->name, "HDSPM MIDI %d", id+1);
-	hdspm->midi[id].rmidi->private_data = &hdspm->midi[id];
+		sprintf(hdspm->midi[id].rmidi->name, "%s MIDI %d",
+				card->id, id+1);
+		hdspm->midi[id].rmidi->private_data = &hdspm->midi[id];
+
+		snd_rawmidi_set_ops(hdspm->midi[id].rmidi,
+				SNDRV_RAWMIDI_STREAM_OUTPUT,
+				&snd_hdspm_midi_output);
+		snd_rawmidi_set_ops(hdspm->midi[id].rmidi,
+				SNDRV_RAWMIDI_STREAM_INPUT,
+				&snd_hdspm_midi_input);
+
+		hdspm->midi[id].rmidi->info_flags |=
+			SNDRV_RAWMIDI_INFO_OUTPUT |
+			SNDRV_RAWMIDI_INFO_INPUT |
+			SNDRV_RAWMIDI_INFO_DUPLEX;
+	} else {
+		/* TCO MTC, read only */
+		sprintf(buf, "%s MTC %d", card->shortname, id+1);
+		err = snd_rawmidi_new(card, buf, id, 1, 1,
+				&hdspm->midi[id].rmidi);
+		if (err < 0)
+			return err;
+
+		sprintf(hdspm->midi[id].rmidi->name,
+				"%s MTC %d", card->id, id+1);
+		hdspm->midi[id].rmidi->private_data = &hdspm->midi[id];
 
-	snd_rawmidi_set_ops(hdspm->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,
-			    &snd_hdspm_midi_output);
-	snd_rawmidi_set_ops(hdspm->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_INPUT,
-			    &snd_hdspm_midi_input);
+		snd_rawmidi_set_ops(hdspm->midi[id].rmidi,
+				SNDRV_RAWMIDI_STREAM_INPUT,
+				&snd_hdspm_midi_input);
 
-	hdspm->midi[id].rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |
-		SNDRV_RAWMIDI_INFO_INPUT |
-		SNDRV_RAWMIDI_INFO_DUPLEX;
+		hdspm->midi[id].rmidi->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;
+	}
 
 	return 0;
 }
@@ -1312,12 +1727,15 @@ static int __devinit snd_hdspm_create_midi (struct snd_card *card,
 static void hdspm_midi_tasklet(unsigned long arg)
 {
 	struct hdspm *hdspm = (struct hdspm *)arg;
-	
-	if (hdspm->midi[0].pending)
-		snd_hdspm_midi_input_read (&hdspm->midi[0]);
-	if (hdspm->midi[1].pending)
-		snd_hdspm_midi_input_read (&hdspm->midi[1]);
-} 
+	int i = 0;
+
+	while (i < hdspm->midiPorts) {
+		if (hdspm->midi[i].pending)
+			snd_hdspm_midi_input_read(&hdspm->midi[i]);
+
+		i++;
+	}
+}
 
 
 /*-----------------------------------------------------------------------------
@@ -1326,6 +1744,22 @@ static void hdspm_midi_tasklet(unsigned long arg)
 
 /* get the system sample rate which is set */
 
+
+/**
+ * Calculate the real sample rate from the
+ * current DDS value.
+ **/
+static int hdspm_get_system_sample_rate(struct hdspm *hdspm)
+{
+	unsigned int period, rate;
+
+	period = hdspm_read(hdspm, HDSPM_RD_PLL_FREQ);
+	rate = hdspm_calc_dds_value(hdspm, period);
+
+	return rate;
+}
+
+
 #define HDSPM_SYSTEM_SAMPLE_RATE(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
@@ -1340,112 +1774,251 @@ static int snd_hdspm_info_system_sample_rate(struct snd_kcontrol *kcontrol,
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
+	uinfo->value.integer.min = 27000;
+	uinfo->value.integer.max = 207000;
+	uinfo->value.integer.step = 1;
 	return 0;
 }
 
+
 static int snd_hdspm_get_system_sample_rate(struct snd_kcontrol *kcontrol,
 					    struct snd_ctl_elem_value *
 					    ucontrol)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	ucontrol->value.enumerated.item[0] = hdspm->system_sample_rate;
+	ucontrol->value.integer.value[0] = hdspm_get_system_sample_rate(hdspm);
+	return 0;
+}
+
+
+/**
+ * Returns the WordClock sample rate class for the given card.
+ **/
+static int hdspm_get_wc_sample_rate(struct hdspm *hdspm)
+{
+	int status;
+
+	switch (hdspm->io_type) {
+	case RayDAT:
+	case AIO:
+		status = hdspm_read(hdspm, HDSPM_RD_STATUS_1);
+		return (status >> 16) & 0xF;
+		break;
+	default:
+		break;
+	}
+
+
+	return 0;
+}
+
+
+/**
+ * Returns the TCO sample rate class for the given card.
+ **/
+static int hdspm_get_tco_sample_rate(struct hdspm *hdspm)
+{
+	int status;
+
+	if (hdspm->tco) {
+		switch (hdspm->io_type) {
+		case RayDAT:
+		case AIO:
+			status = hdspm_read(hdspm, HDSPM_RD_STATUS_1);
+			return (status >> 20) & 0xF;
+			break;
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
+
+
+/**
+ * Returns the SYNC_IN sample rate class for the given card.
+ **/
+static int hdspm_get_sync_in_sample_rate(struct hdspm *hdspm)
+{
+	int status;
+
+	if (hdspm->tco) {
+		switch (hdspm->io_type) {
+		case RayDAT:
+		case AIO:
+			status = hdspm_read(hdspm, HDSPM_RD_STATUS_2);
+			return (status >> 12) & 0xF;
+			break;
+		default:
+			break;
+		}
+	}
+
 	return 0;
 }
 
+
+/**
+ * Returns the sample rate class for input source <idx> for
+ * 'new style' cards like the AIO and RayDAT.
+ **/
+static int hdspm_get_s1_sample_rate(struct hdspm *hdspm, unsigned int idx)
+{
+	int status = hdspm_read(hdspm, HDSPM_RD_STATUS_2);
+
+	return (status >> (idx*4)) & 0xF;
+}
+
+
+
 #define HDSPM_AUTOSYNC_SAMPLE_RATE(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .access = SNDRV_CTL_ELEM_ACCESS_READ, \
-  .info = snd_hdspm_info_autosync_sample_rate, \
-  .get = snd_hdspm_get_autosync_sample_rate \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.private_value = xindex, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READ, \
+	.info = snd_hdspm_info_autosync_sample_rate, \
+	.get = snd_hdspm_get_autosync_sample_rate \
 }
 
+
 static int snd_hdspm_info_autosync_sample_rate(struct snd_kcontrol *kcontrol,
 					       struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "32000", "44100", "48000",
-		"64000", "88200", "96000",
-		"128000", "176400", "192000",
-		"None"
-	};
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
 	uinfo->value.enumerated.items = 10;
+
 	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-		    uinfo->value.enumerated.items - 1;
+		uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;
 	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
+			texts_freq[uinfo->value.enumerated.item]);
 	return 0;
 }
 
+
 static int snd_hdspm_get_autosync_sample_rate(struct snd_kcontrol *kcontrol,
 					      struct snd_ctl_elem_value *
 					      ucontrol)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	switch (hdspm_external_sample_rate(hdspm)) {
-	case 32000:
-		ucontrol->value.enumerated.item[0] = 0;
-		break;
-	case 44100:
-		ucontrol->value.enumerated.item[0] = 1;
-		break;
-	case 48000:
-		ucontrol->value.enumerated.item[0] = 2;
-		break;
-	case 64000:
-		ucontrol->value.enumerated.item[0] = 3;
-		break;
-	case 88200:
-		ucontrol->value.enumerated.item[0] = 4;
-		break;
-	case 96000:
-		ucontrol->value.enumerated.item[0] = 5;
-		break;
-	case 128000:
-		ucontrol->value.enumerated.item[0] = 6;
-		break;
-	case 176400:
-		ucontrol->value.enumerated.item[0] = 7;
-		break;
-	case 192000:
-		ucontrol->value.enumerated.item[0] = 8;
-		break;
+	switch (hdspm->io_type) {
+	case RayDAT:
+		switch (kcontrol->private_value) {
+		case 0:
+			ucontrol->value.enumerated.item[0] =
+				hdspm_get_wc_sample_rate(hdspm);
+			break;
+		case 7:
+			ucontrol->value.enumerated.item[0] =
+				hdspm_get_tco_sample_rate(hdspm);
+			break;
+		case 8:
+			ucontrol->value.enumerated.item[0] =
+				hdspm_get_sync_in_sample_rate(hdspm);
+			break;
+		default:
+			ucontrol->value.enumerated.item[0] =
+				hdspm_get_s1_sample_rate(hdspm,
+						kcontrol->private_value-1);
+		}
 
+	case AIO:
+		switch (kcontrol->private_value) {
+		case 0: /* WC */
+			ucontrol->value.enumerated.item[0] =
+				hdspm_get_wc_sample_rate(hdspm);
+			break;
+		case 4: /* TCO */
+			ucontrol->value.enumerated.item[0] =
+				hdspm_get_tco_sample_rate(hdspm);
+			break;
+		case 5: /* SYNC_IN */
+			ucontrol->value.enumerated.item[0] =
+				hdspm_get_sync_in_sample_rate(hdspm);
+			break;
+		default:
+			ucontrol->value.enumerated.item[0] =
+				hdspm_get_s1_sample_rate(hdspm,
+						ucontrol->id.index-1);
+		}
 	default:
-		ucontrol->value.enumerated.item[0] = 9;
+		break;
 	}
-	return 0;
-}
 
-#define HDSPM_SYSTEM_CLOCK_MODE(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .access = SNDRV_CTL_ELEM_ACCESS_READ, \
-  .info = snd_hdspm_info_system_clock_mode, \
-  .get = snd_hdspm_get_system_clock_mode, \
+	return 0;
 }
 
 
+#define HDSPM_SYSTEM_CLOCK_MODE(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\
+		SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_info_system_clock_mode, \
+	.get = snd_hdspm_get_system_clock_mode, \
+	.put = snd_hdspm_put_system_clock_mode, \
+}
+
+
+/**
+ * Returns the system clock mode for the given card.
+ * @returns 0 - master, 1 - slave
+ **/
+static int hdspm_system_clock_mode(struct hdspm *hdspm)
+{
+	switch (hdspm->io_type) {
+	case AIO:
+	case RayDAT:
+		if (hdspm->settings_register & HDSPM_c0Master)
+			return 0;
+		break;
 
-static int hdspm_system_clock_mode(struct hdspm * hdspm)
-{
-        /* Always reflect the hardware info, rme is never wrong !!!! */
+	default:
+		if (hdspm->control_register & HDSPM_ClockModeMaster)
+			return 0;
+	}
 
-	if (hdspm->control_register & HDSPM_ClockModeMaster)
-		return 0;
 	return 1;
 }
 
-static int snd_hdspm_info_system_clock_mode(struct snd_kcontrol *kcontrol,
+
+/**
+ * Sets the system clock mode.
+ * @param mode 0 - master, 1 - slave
+ **/
+static void hdspm_set_system_clock_mode(struct hdspm *hdspm, int mode)
+{
+	switch (hdspm->io_type) {
+	case AIO:
+	case RayDAT:
+		if (0 == mode)
+			hdspm->settings_register |= HDSPM_c0Master;
+		else
+			hdspm->settings_register &= ~HDSPM_c0Master;
+
+		hdspm_write(hdspm, HDSPM_WR_SETTINGS, hdspm->settings_register);
+		break;
+
+	default:
+		if (0 == mode)
+			hdspm->control_register |= HDSPM_ClockModeMaster;
+		else
+			hdspm->control_register &= ~HDSPM_ClockModeMaster;
+
+		hdspm_write(hdspm, HDSPM_controlRegister,
+				hdspm->control_register);
+	}
+}
+
+
+static int snd_hdspm_info_system_clock_mode(struct snd_kcontrol *kcontrol,
 					    struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "Master", "Slave" };
+	static char *texts[] = { "Master", "AutoSync" };
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
@@ -1463,96 +2036,83 @@ static int snd_hdspm_get_system_clock_mode(struct snd_kcontrol *kcontrol,
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	ucontrol->value.enumerated.item[0] =
-	    hdspm_system_clock_mode(hdspm);
+	ucontrol->value.enumerated.item[0] = hdspm_system_clock_mode(hdspm);
 	return 0;
 }
 
-#define HDSPM_CLOCK_SOURCE(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .info = snd_hdspm_info_clock_source, \
-  .get = snd_hdspm_get_clock_source, \
-  .put = snd_hdspm_put_clock_source \
+static int snd_hdspm_put_system_clock_mode(struct snd_kcontrol *kcontrol,
+					   struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+
+	val = ucontrol->value.enumerated.item[0];
+	if (val < 0)
+		val = 0;
+	else if (val > 1)
+		val = 1;
+
+	hdspm_set_system_clock_mode(hdspm, val);
+
+	return 0;
+}
+
+
+#define HDSPM_INTERNAL_CLOCK(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.info = snd_hdspm_info_clock_source, \
+	.get = snd_hdspm_get_clock_source, \
+	.put = snd_hdspm_put_clock_source \
 }
 
+
 static int hdspm_clock_source(struct hdspm * hdspm)
 {
-	if (hdspm->control_register & HDSPM_ClockModeMaster) {
-		switch (hdspm->system_sample_rate) {
-		case 32000:
-			return 1;
-		case 44100:
-			return 2;
-		case 48000:
-			return 3;
-		case 64000:
-			return 4;
-		case 88200:
-			return 5;
-		case 96000:
-			return 6;
-		case 128000:
-			return 7;
-		case 176400:
-			return 8;
-		case 192000:
-			return 9;
-		default:
-			return 3;
-		}
-	} else {
-		return 0;
+	switch (hdspm->system_sample_rate) {
+	case 32000: return 0;
+	case 44100: return 1;
+	case 48000: return 2;
+	case 64000: return 3;
+	case 88200: return 4;
+	case 96000: return 5;
+	case 128000: return 6;
+	case 176400: return 7;
+	case 192000: return 8;
 	}
+
+	return -1;
 }
 
 static int hdspm_set_clock_source(struct hdspm * hdspm, int mode)
 {
 	int rate;
 	switch (mode) {
-
-	case HDSPM_CLOCK_SOURCE_AUTOSYNC:
-		if (hdspm_external_sample_rate(hdspm) != 0) {
-			hdspm->control_register &= ~HDSPM_ClockModeMaster;
-			hdspm_write(hdspm, HDSPM_controlRegister,
-				    hdspm->control_register);
-			return 0;
-		}
-		return -1;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_32KHZ:
-		rate = 32000;
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_44_1KHZ:
-		rate = 44100;
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_48KHZ:
-		rate = 48000;
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_64KHZ:
-		rate = 64000;
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_88_2KHZ:
-		rate = 88200;
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_96KHZ:
-		rate = 96000;
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_128KHZ:
-		rate = 128000;
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_176_4KHZ:
-		rate = 176400;
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_192KHZ:
-		rate = 192000;
-		break;
-
+	case 0:
+		rate = 32000; break;
+	case 1:
+		rate = 44100; break;
+	case 2:
+		rate = 48000; break;
+	case 3:
+		rate = 64000; break;
+	case 4:
+		rate = 88200; break;
+	case 5:
+		rate = 96000; break;
+	case 6:
+		rate = 128000; break;
+	case 7:
+		rate = 176400; break;
+	case 8:
+		rate = 192000; break;
 	default:
-		rate = 44100;
+		rate = 48000;
 	}
-	hdspm->control_register |= HDSPM_ClockModeMaster;
-	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
 	hdspm_set_rate(hdspm, rate, 1);
 	return 0;
 }
@@ -1560,25 +2120,16 @@ static int hdspm_set_clock_source(struct hdspm * hdspm, int mode)
 static int snd_hdspm_info_clock_source(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "AutoSync",
-		"Internal 32.0 kHz", "Internal 44.1 kHz",
-		    "Internal 48.0 kHz",
-		"Internal 64.0 kHz", "Internal 88.2 kHz",
-		    "Internal 96.0 kHz",
-		"Internal 128.0 kHz", "Internal 176.4 kHz",
-		    "Internal 192.0 kHz"
-	};
-
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
-	uinfo->value.enumerated.items = 10;
+	uinfo->value.enumerated.items = 9;
 
 	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
 		uinfo->value.enumerated.item =
 		    uinfo->value.enumerated.items - 1;
 
 	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
+	       texts_freq[uinfo->value.enumerated.item+1]);
 
 	return 0;
 }
@@ -1615,134 +2166,301 @@ static int snd_hdspm_put_clock_source(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-#define HDSPM_PREF_SYNC_REF(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .info = snd_hdspm_info_pref_sync_ref, \
-  .get = snd_hdspm_get_pref_sync_ref, \
-  .put = snd_hdspm_put_pref_sync_ref \
-}
 
+#define HDSPM_PREF_SYNC_REF(xname, xindex) \
+{.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_info_pref_sync_ref, \
+	.get = snd_hdspm_get_pref_sync_ref, \
+	.put = snd_hdspm_put_pref_sync_ref \
+}
+
+
+/**
+ * Returns the current preferred sync reference setting.
+ * The semantics of the return value are depending on the
+ * card, please see the comments for clarification.
+ **/
 static int hdspm_pref_sync_ref(struct hdspm * hdspm)
 {
-	/* Notice that this looks at the requested sync source,
-	   not the one actually in use.
-	 */
-	if (hdspm->is_aes32) {
+	switch (hdspm->io_type) {
+	case AES32:
 		switch (hdspm->control_register & HDSPM_SyncRefMask) {
-		/* number gives AES index, except for 0 which
-		   corresponds to WordClock */
-		case 0: return 0;
-		case HDSPM_SyncRef0: return 1;
-		case HDSPM_SyncRef1: return 2;
-		case HDSPM_SyncRef1+HDSPM_SyncRef0: return 3;
-		case HDSPM_SyncRef2: return 4;
-		case HDSPM_SyncRef2+HDSPM_SyncRef0: return 5;
-		case HDSPM_SyncRef2+HDSPM_SyncRef1: return 6;
-		case HDSPM_SyncRef2+HDSPM_SyncRef1+HDSPM_SyncRef0: return 7;
-		case HDSPM_SyncRef3: return 8;
+		case 0: return 0;  /* WC */
+		case HDSPM_SyncRef0: return 1; /* AES 1 */
+		case HDSPM_SyncRef1: return 2; /* AES 2 */
+		case HDSPM_SyncRef1+HDSPM_SyncRef0: return 3; /* AES 3 */
+		case HDSPM_SyncRef2: return 4; /* AES 4 */
+		case HDSPM_SyncRef2+HDSPM_SyncRef0: return 5; /* AES 5 */
+		case HDSPM_SyncRef2+HDSPM_SyncRef1: return 6; /* AES 6 */
+		case HDSPM_SyncRef2+HDSPM_SyncRef1+HDSPM_SyncRef0:
+						    return 7; /* AES 7 */
+		case HDSPM_SyncRef3: return 8; /* AES 8 */
+		case HDSPM_SyncRef3+HDSPM_SyncRef0: return 9; /* TCO */
 		}
-	} else {
-		switch (hdspm->control_register & HDSPM_SyncRefMask) {
-		case HDSPM_SyncRef_Word:
-			return HDSPM_SYNC_FROM_WORD;
-		case HDSPM_SyncRef_MADI:
-			return HDSPM_SYNC_FROM_MADI;
+		break;
+
+	case MADI:
+	case MADIface:
+		if (hdspm->tco) {
+			switch (hdspm->control_register & HDSPM_SyncRefMask) {
+			case 0: return 0;  /* WC */
+			case HDSPM_SyncRef0: return 1;  /* MADI */
+			case HDSPM_SyncRef1: return 2;  /* TCO */
+			case HDSPM_SyncRef1+HDSPM_SyncRef0:
+					     return 3;  /* SYNC_IN */
+			}
+		} else {
+			switch (hdspm->control_register & HDSPM_SyncRefMask) {
+			case 0: return 0;  /* WC */
+			case HDSPM_SyncRef0: return 1;  /* MADI */
+			case HDSPM_SyncRef1+HDSPM_SyncRef0:
+					     return 2;  /* SYNC_IN */
+			}
+		}
+		break;
+
+	case RayDAT:
+		if (hdspm->tco) {
+			switch ((hdspm->settings_register &
+				HDSPM_c0_SyncRefMask) / HDSPM_c0_SyncRef0) {
+			case 0: return 0;  /* WC */
+			case 3: return 1;  /* ADAT 1 */
+			case 4: return 2;  /* ADAT 2 */
+			case 5: return 3;  /* ADAT 3 */
+			case 6: return 4;  /* ADAT 4 */
+			case 1: return 5;  /* AES */
+			case 2: return 6;  /* SPDIF */
+			case 9: return 7;  /* TCO */
+			case 10: return 8; /* SYNC_IN */
+			}
+		} else {
+			switch ((hdspm->settings_register &
+				HDSPM_c0_SyncRefMask) / HDSPM_c0_SyncRef0) {
+			case 0: return 0;  /* WC */
+			case 3: return 1;  /* ADAT 1 */
+			case 4: return 2;  /* ADAT 2 */
+			case 5: return 3;  /* ADAT 3 */
+			case 6: return 4;  /* ADAT 4 */
+			case 1: return 5;  /* AES */
+			case 2: return 6;  /* SPDIF */
+			case 10: return 7; /* SYNC_IN */
+			}
 		}
+
+		break;
+
+	case AIO:
+		if (hdspm->tco) {
+			switch ((hdspm->settings_register &
+				HDSPM_c0_SyncRefMask) / HDSPM_c0_SyncRef0) {
+			case 0: return 0;  /* WC */
+			case 3: return 1;  /* ADAT */
+			case 1: return 2;  /* AES */
+			case 2: return 3;  /* SPDIF */
+			case 9: return 4;  /* TCO */
+			case 10: return 5; /* SYNC_IN */
+			}
+		} else {
+			switch ((hdspm->settings_register &
+				HDSPM_c0_SyncRefMask) / HDSPM_c0_SyncRef0) {
+			case 0: return 0;  /* WC */
+			case 3: return 1;  /* ADAT */
+			case 1: return 2;  /* AES */
+			case 2: return 3;  /* SPDIF */
+			case 10: return 4; /* SYNC_IN */
+			}
+		}
+
+		break;
 	}
 
-	return HDSPM_SYNC_FROM_WORD;
+	return -1;
 }
 
+
+/**
+ * Set the preferred sync reference to <pref>. The semantics
+ * of <pref> are depending on the card type, see the comments
+ * for clarification.
+ **/
 static int hdspm_set_pref_sync_ref(struct hdspm * hdspm, int pref)
 {
-	hdspm->control_register &= ~HDSPM_SyncRefMask;
+	int p = 0;
 
-	if (hdspm->is_aes32) {
-		switch (pref) {
-		case 0:
-		       hdspm->control_register |= 0;
-		       break;
-		case 1:
-		       hdspm->control_register |= HDSPM_SyncRef0;
-		       break;
-		case 2:
-		       hdspm->control_register |= HDSPM_SyncRef1;
-		       break;
-		case 3:
-		       hdspm->control_register |= HDSPM_SyncRef1+HDSPM_SyncRef0;
-		       break;
-		case 4:
-		       hdspm->control_register |= HDSPM_SyncRef2;
-		       break;
-		case 5:
-		       hdspm->control_register |= HDSPM_SyncRef2+HDSPM_SyncRef0;
-		       break;
-		case 6:
-		       hdspm->control_register |= HDSPM_SyncRef2+HDSPM_SyncRef1;
-		       break;
-		case 7:
-		       hdspm->control_register |=
-			       HDSPM_SyncRef2+HDSPM_SyncRef1+HDSPM_SyncRef0;
-		       break;
-		case 8:
-		       hdspm->control_register |= HDSPM_SyncRef3;
-		       break;
-		default:
-		       return -1;
-		}
-	} else {
+	switch (hdspm->io_type) {
+	case AES32:
+		hdspm->control_register &= ~HDSPM_SyncRefMask;
 		switch (pref) {
-		case HDSPM_SYNC_FROM_MADI:
-			hdspm->control_register |= HDSPM_SyncRef_MADI;
+		case 0: /* WC  */
+			break;
+		case 1: /* AES 1 */
+			hdspm->control_register |= HDSPM_SyncRef0;
+			break;
+		case 2: /* AES 2 */
+			hdspm->control_register |= HDSPM_SyncRef1;
+			break;
+		case 3: /* AES 3 */
+			hdspm->control_register |=
+				HDSPM_SyncRef1+HDSPM_SyncRef0;
+			break;
+		case 4: /* AES 4 */
+			hdspm->control_register |= HDSPM_SyncRef2;
+			break;
+		case 5: /* AES 5 */
+			hdspm->control_register |=
+				HDSPM_SyncRef2+HDSPM_SyncRef0;
+			break;
+		case 6: /* AES 6 */
+			hdspm->control_register |=
+				HDSPM_SyncRef2+HDSPM_SyncRef1;
+			break;
+		case 7: /* AES 7 */
+			hdspm->control_register |=
+				HDSPM_SyncRef2+HDSPM_SyncRef1+HDSPM_SyncRef0;
 			break;
-		case HDSPM_SYNC_FROM_WORD:
-			hdspm->control_register |= HDSPM_SyncRef_Word;
+		case 8: /* AES 8 */
+			hdspm->control_register |= HDSPM_SyncRef3;
+			break;
+		case 9: /* TCO */
+			hdspm->control_register |=
+				HDSPM_SyncRef3+HDSPM_SyncRef0;
 			break;
 		default:
 			return -1;
 		}
+
+		break;
+
+	case MADI:
+	case MADIface:
+		hdspm->control_register &= ~HDSPM_SyncRefMask;
+		if (hdspm->tco) {
+			switch (pref) {
+			case 0: /* WC */
+				break;
+			case 1: /* MADI */
+				hdspm->control_register |= HDSPM_SyncRef0;
+				break;
+			case 2: /* TCO */
+				hdspm->control_register |= HDSPM_SyncRef1;
+				break;
+			case 3: /* SYNC_IN */
+				hdspm->control_register |=
+					HDSPM_SyncRef0+HDSPM_SyncRef1;
+				break;
+			default:
+				return -1;
+			}
+		} else {
+			switch (pref) {
+			case 0: /* WC */
+				break;
+			case 1: /* MADI */
+				hdspm->control_register |= HDSPM_SyncRef0;
+				break;
+			case 2: /* SYNC_IN */
+				hdspm->control_register |=
+					HDSPM_SyncRef0+HDSPM_SyncRef1;
+				break;
+			default:
+				return -1;
+			}
+		}
+
+		break;
+
+	case RayDAT:
+		if (hdspm->tco) {
+			switch (pref) {
+			case 0: p = 0; break;  /* WC */
+			case 1: p = 3; break;  /* ADAT 1 */
+			case 2: p = 4; break;  /* ADAT 2 */
+			case 3: p = 5; break;  /* ADAT 3 */
+			case 4: p = 6; break;  /* ADAT 4 */
+			case 5: p = 1; break;  /* AES */
+			case 6: p = 2; break;  /* SPDIF */
+			case 7: p = 9; break;  /* TCO */
+			case 8: p = 10; break; /* SYNC_IN */
+			default: return -1;
+			}
+		} else {
+			switch (pref) {
+			case 0: p = 0; break;  /* WC */
+			case 1: p = 3; break;  /* ADAT 1 */
+			case 2: p = 4; break;  /* ADAT 2 */
+			case 3: p = 5; break;  /* ADAT 3 */
+			case 4: p = 6; break;  /* ADAT 4 */
+			case 5: p = 1; break;  /* AES */
+			case 6: p = 2; break;  /* SPDIF */
+			case 7: p = 10; break; /* SYNC_IN */
+			default: return -1;
+			}
+		}
+		break;
+
+	case AIO:
+		if (hdspm->tco) {
+			switch (pref) {
+			case 0: p = 0; break;  /* WC */
+			case 1: p = 3; break;  /* ADAT */
+			case 2: p = 1; break;  /* AES */
+			case 3: p = 2; break;  /* SPDIF */
+			case 4: p = 9; break;  /* TCO */
+			case 5: p = 10; break; /* SYNC_IN */
+			default: return -1;
+			}
+		} else {
+			switch (pref) {
+			case 0: p = 0; break;  /* WC */
+			case 1: p = 3; break;  /* ADAT */
+			case 2: p = 1; break;  /* AES */
+			case 3: p = 2; break;  /* SPDIF */
+			case 4: p = 10; break; /* SYNC_IN */
+			default: return -1;
+			}
+		}
+		break;
 	}
-	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	switch (hdspm->io_type) {
+	case RayDAT:
+	case AIO:
+		hdspm->settings_register &= ~HDSPM_c0_SyncRefMask;
+		hdspm->settings_register |= HDSPM_c0_SyncRef0 * p;
+		hdspm_write(hdspm, HDSPM_WR_SETTINGS, hdspm->settings_register);
+		break;
+
+	case MADI:
+	case MADIface:
+	case AES32:
+		hdspm_write(hdspm, HDSPM_controlRegister,
+				hdspm->control_register);
+	}
+
 	return 0;
 }
 
+
 static int snd_hdspm_info_pref_sync_ref(struct snd_kcontrol *kcontrol,
 					struct snd_ctl_elem_info *uinfo)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	if (hdspm->is_aes32) {
-		static char *texts[] = { "Word", "AES1", "AES2", "AES3",
-			"AES4", "AES5",	"AES6", "AES7", "AES8" };
-
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-		uinfo->count = 1;
-
-		uinfo->value.enumerated.items = 9;
-
-		if (uinfo->value.enumerated.item >=
-		    uinfo->value.enumerated.items)
-			uinfo->value.enumerated.item =
-				uinfo->value.enumerated.items - 1;
-		strcpy(uinfo->value.enumerated.name,
-				texts[uinfo->value.enumerated.item]);
-	} else {
-		static char *texts[] = { "Word", "MADI" };
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = hdspm->texts_autosync_items;
 
-		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-		uinfo->count = 1;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+			uinfo->value.enumerated.items - 1;
 
-		uinfo->value.enumerated.items = 2;
+	strcpy(uinfo->value.enumerated.name,
+			hdspm->texts_autosync[uinfo->value.enumerated.item]);
 
-		if (uinfo->value.enumerated.item >=
-		    uinfo->value.enumerated.items)
-			uinfo->value.enumerated.item =
-				uinfo->value.enumerated.items - 1;
-		strcpy(uinfo->value.enumerated.name,
-				texts[uinfo->value.enumerated.item]);
-	}
 	return 0;
 }
 
@@ -1750,32 +2468,41 @@ static int snd_hdspm_get_pref_sync_ref(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_value *ucontrol)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int psf = hdspm_pref_sync_ref(hdspm);
 
-	ucontrol->value.enumerated.item[0] = hdspm_pref_sync_ref(hdspm);
-	return 0;
+	if (psf >= 0) {
+		ucontrol->value.enumerated.item[0] = psf;
+		return 0;
+	}
+
+	return -1;
 }
 
 static int snd_hdspm_put_pref_sync_ref(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_value *ucontrol)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
-	int change, max;
-	unsigned int val;
-
-	max = hdspm->is_aes32 ? 9 : 2;
+	int val, change = 0;
 
 	if (!snd_hdspm_use_is_exclusive(hdspm))
 		return -EBUSY;
 
-	val = ucontrol->value.enumerated.item[0] % max;
+	val = ucontrol->value.enumerated.item[0];
+
+	if (val < 0)
+		val = 0;
+	else if (val >= hdspm->texts_autosync_items)
+		val = hdspm->texts_autosync_items-1;
 
 	spin_lock_irq(&hdspm->lock);
-	change = (int) val != hdspm_pref_sync_ref(hdspm);
-	hdspm_set_pref_sync_ref(hdspm, val);
+	if (val != hdspm_pref_sync_ref(hdspm))
+		change = (0 == hdspm_set_pref_sync_ref(hdspm, val)) ? 1 : 0;
+
 	spin_unlock_irq(&hdspm->lock);
 	return change;
 }
 
+
 #define HDSPM_AUTOSYNC_REF(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
@@ -1785,18 +2512,18 @@ static int snd_hdspm_put_pref_sync_ref(struct snd_kcontrol *kcontrol,
   .get = snd_hdspm_get_autosync_ref, \
 }
 
-static int hdspm_autosync_ref(struct hdspm * hdspm)
+static int hdspm_autosync_ref(struct hdspm *hdspm)
 {
-	if (hdspm->is_aes32) {
+	if (AES32 == hdspm->io_type) {
 		unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
-		unsigned int syncref = (status >> HDSPM_AES32_syncref_bit) &
-			0xF;
+		unsigned int syncref =
+			(status >> HDSPM_AES32_syncref_bit) & 0xF;
 		if (syncref == 0)
 			return HDSPM_AES32_AUTOSYNC_FROM_WORD;
 		if (syncref <= 8)
 			return syncref;
 		return HDSPM_AES32_AUTOSYNC_FROM_NONE;
-	} else {
+	} else if (MADI == hdspm->io_type) {
 		/* This looks at the autosync selected sync reference */
 		unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
 
@@ -1805,22 +2532,27 @@ static int hdspm_autosync_ref(struct hdspm * hdspm)
 			return HDSPM_AUTOSYNC_FROM_WORD;
 		case HDSPM_SelSyncRef_MADI:
 			return HDSPM_AUTOSYNC_FROM_MADI;
+		case HDSPM_SelSyncRef_TCO:
+			return HDSPM_AUTOSYNC_FROM_TCO;
+		case HDSPM_SelSyncRef_SyncIn:
+			return HDSPM_AUTOSYNC_FROM_SYNC_IN;
 		case HDSPM_SelSyncRef_NVALID:
 			return HDSPM_AUTOSYNC_FROM_NONE;
 		default:
 			return 0;
 		}
 
-		return 0;
 	}
+	return 0;
 }
 
+
 static int snd_hdspm_info_autosync_ref(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	if (hdspm->is_aes32) {
+	if (AES32 == hdspm->io_type) {
 		static char *texts[] = { "WordClock", "AES1", "AES2", "AES3",
 			"AES4",	"AES5", "AES6", "AES7", "AES8", "None"};
 
@@ -1833,14 +2565,15 @@ static int snd_hdspm_info_autosync_ref(struct snd_kcontrol *kcontrol,
 				uinfo->value.enumerated.items - 1;
 		strcpy(uinfo->value.enumerated.name,
 				texts[uinfo->value.enumerated.item]);
-	} else {
-		static char *texts[] = { "WordClock", "MADI", "None" };
+	} else if (MADI == hdspm->io_type) {
+		static char *texts[] = {"Word Clock", "MADI", "TCO",
+			"Sync In", "None" };
 
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 		uinfo->count = 1;
-		uinfo->value.enumerated.items = 3;
+		uinfo->value.enumerated.items = 5;
 		if (uinfo->value.enumerated.item >=
-		    uinfo->value.enumerated.items)
+				uinfo->value.enumerated.items)
 			uinfo->value.enumerated.item =
 				uinfo->value.enumerated.items - 1;
 		strcpy(uinfo->value.enumerated.name,
@@ -1858,6 +2591,7 @@ static int snd_hdspm_get_autosync_ref(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
+
 #define HDSPM_LINE_OUT(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
@@ -1914,6 +2648,7 @@ static int snd_hdspm_put_line_out(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
+
 #define HDSPM_TX_64(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
@@ -1969,6 +2704,7 @@ static int snd_hdspm_put_tx_64(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
+
 #define HDSPM_C_TMS(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
@@ -2024,6 +2760,7 @@ static int snd_hdspm_put_c_tms(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
+
 #define HDSPM_SAFE_MODE(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
@@ -2079,6 +2816,7 @@ static int snd_hdspm_put_safe_mode(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
+
 #define HDSPM_EMPHASIS(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
@@ -2134,6 +2872,7 @@ static int snd_hdspm_put_emphasis(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
+
 #define HDSPM_DOLBY(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
@@ -2189,6 +2928,7 @@ static int snd_hdspm_put_dolby(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
+
 #define HDSPM_PROFESSIONAL(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
@@ -2315,6 +3055,7 @@ static int snd_hdspm_put_input_select(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
+
 #define HDSPM_DS_WIRE(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
@@ -2386,6 +3127,7 @@ static int snd_hdspm_put_ds_wire(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
+
 #define HDSPM_QS_WIRE(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
@@ -2472,15 +3214,6 @@ static int snd_hdspm_put_qs_wire(struct snd_kcontrol *kcontrol,
 	return change;
 }
 
-/*           Simple Mixer
-  deprecated since to much faders ???
-  MIXER interface says output (source, destination, value)
-   where source > MAX_channels are playback channels 
-   on MADICARD 
-  - playback mixer matrix: [channelout+64] [output] [value]
-  - input(thru) mixer matrix: [channelin] [output] [value]
-  (better do 2 kontrols for separation ?)
-*/
 
 #define HDSPM_MIXER(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
@@ -2586,7 +3319,7 @@ static int snd_hdspm_put_mixer(struct snd_kcontrol *kcontrol,
 
 /* The simple mixer control(s) provide gain control for the
    basic 1:1 mappings of playback streams to output
-   streams. 
+   streams.
 */
 
 #define HDSPM_PLAYBACK_MIXER \
@@ -2604,7 +3337,7 @@ static int snd_hdspm_info_playback_mixer(struct snd_kcontrol *kcontrol,
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
 	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 65536;
+	uinfo->value.integer.max = 64;
 	uinfo->value.integer.step = 1;
 	return 0;
 }
@@ -2614,28 +3347,17 @@ static int snd_hdspm_get_playback_mixer(struct snd_kcontrol *kcontrol,
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int channel;
-	int mapped_channel;
 
 	channel = ucontrol->id.index - 1;
 
 	if (snd_BUG_ON(channel < 0 || channel >= HDSPM_MAX_CHANNELS))
 		return -EINVAL;
 
-	mapped_channel = hdspm->channel_map[channel];
-	if (mapped_channel < 0)
-		return -EINVAL;
-
 	spin_lock_irq(&hdspm->lock);
 	ucontrol->value.integer.value[0] =
-	    hdspm_read_pb_gain(hdspm, mapped_channel, mapped_channel);
+	  (hdspm_read_pb_gain(hdspm, channel, channel)*64)/UNITY_GAIN;
 	spin_unlock_irq(&hdspm->lock);
 
-	/*
-	snd_printdd("get pb mixer index %d, channel %d, mapped_channel %d, "
-		    "value %d\n",
-		    ucontrol->id.index, channel, mapped_channel,
-		    ucontrol->value.integer.value[0]); 
-	*/
 	return 0;
 }
 
@@ -2645,7 +3367,6 @@ static int snd_hdspm_put_playback_mixer(struct snd_kcontrol *kcontrol,
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int change;
 	int channel;
-	int mapped_channel;
 	int gain;
 
 	if (!snd_hdspm_use_is_exclusive(hdspm))
@@ -2656,59 +3377,60 @@ static int snd_hdspm_put_playback_mixer(struct snd_kcontrol *kcontrol,
 	if (snd_BUG_ON(channel < 0 || channel >= HDSPM_MAX_CHANNELS))
 		return -EINVAL;
 
-	mapped_channel = hdspm->channel_map[channel];
-	if (mapped_channel < 0)
-		return -EINVAL;
-
-	gain = ucontrol->value.integer.value[0];
+	gain = ucontrol->value.integer.value[0]*UNITY_GAIN/64;
 
 	spin_lock_irq(&hdspm->lock);
 	change =
-	    gain != hdspm_read_pb_gain(hdspm, mapped_channel,
-				       mapped_channel);
+	    gain != hdspm_read_pb_gain(hdspm, channel,
+				       channel);
 	if (change)
-		hdspm_write_pb_gain(hdspm, mapped_channel, mapped_channel,
+		hdspm_write_pb_gain(hdspm, channel, channel,
 				    gain);
 	spin_unlock_irq(&hdspm->lock);
 	return change;
 }
 
-#define HDSPM_WC_SYNC_CHECK(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
-  .info = snd_hdspm_info_sync_check, \
-  .get = snd_hdspm_get_wc_sync_check \
+#define HDSPM_SYNC_CHECK(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.private_value = xindex, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_info_sync_check, \
+	.get = snd_hdspm_get_sync_check \
 }
 
+
 static int snd_hdspm_info_sync_check(struct snd_kcontrol *kcontrol,
 				     struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "No Lock", "Lock", "Sync" };
+	static char *texts[] = { "No Lock", "Lock", "Sync", "N/A" };
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
-	uinfo->value.enumerated.items = 3;
+	uinfo->value.enumerated.items = 4;
 	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
 		uinfo->value.enumerated.item =
-		    uinfo->value.enumerated.items - 1;
+			uinfo->value.enumerated.items - 1;
 	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
+			texts[uinfo->value.enumerated.item]);
 	return 0;
 }
 
-static int hdspm_wc_sync_check(struct hdspm * hdspm)
+static int hdspm_wc_sync_check(struct hdspm *hdspm)
 {
-	if (hdspm->is_aes32) {
-		int status = hdspm_read(hdspm, HDSPM_statusRegister);
-		if (status & HDSPM_AES32_wcLock) {
-			/* I don't know how to differenciate sync from lock.
-			   Doing as if sync for now */
+	int status, status2;
+
+	switch (hdspm->io_type) {
+	case AES32:
+		status = hdspm_read(hdspm, HDSPM_statusRegister);
+		if (status & HDSPM_wcSync)
 			return 2;
-		}
+		else if (status & HDSPM_wcLock)
+			return 1;
 		return 0;
-	} else {
-		int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+		break;
+
+	case MADI:
+		status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
 		if (status2 & HDSPM_wcLock) {
 			if (status2 & HDSPM_wcSync)
 				return 2;
@@ -2716,29 +3438,30 @@ static int hdspm_wc_sync_check(struct hdspm * hdspm)
 				return 1;
 		}
 		return 0;
-	}
-}
+		break;
 
-static int snd_hdspm_get_wc_sync_check(struct snd_kcontrol *kcontrol,
-				       struct snd_ctl_elem_value *ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	case RayDAT:
+	case AIO:
+		status = hdspm_read(hdspm, HDSPM_statusRegister);
 
-	ucontrol->value.enumerated.item[0] = hdspm_wc_sync_check(hdspm);
-	return 0;
-}
+		if (status & 0x2000000)
+			return 2;
+		else if (status & 0x1000000)
+			return 1;
+		return 0;
 
+		break;
 
-#define HDSPM_MADI_SYNC_CHECK(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
-  .info = snd_hdspm_info_sync_check, \
-  .get = snd_hdspm_get_madisync_sync_check \
+	case MADIface:
+		break;
+	}
+
+
+	return 3;
 }
 
-static int hdspm_madisync_sync_check(struct hdspm * hdspm)
+
+static int hdspm_madi_sync_check(struct hdspm *hdspm)
 {
 	int status = hdspm_read(hdspm, HDSPM_statusRegister);
 	if (status & HDSPM_madiLock) {
@@ -2750,89 +3473,727 @@ static int hdspm_madisync_sync_check(struct hdspm * hdspm)
 	return 0;
 }
 
-static int snd_hdspm_get_madisync_sync_check(struct snd_kcontrol *kcontrol,
-					     struct snd_ctl_elem_value *
-					     ucontrol)
-{
-	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	ucontrol->value.enumerated.item[0] =
-	    hdspm_madisync_sync_check(hdspm);
-	return 0;
-}
+static int hdspm_s1_sync_check(struct hdspm *hdspm, int idx)
+{
+	int status, lock, sync;
 
+	status = hdspm_read(hdspm, HDSPM_RD_STATUS_1);
 
-#define HDSPM_AES_SYNC_CHECK(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
-  .name = xname, \
-  .index = xindex, \
-  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
-  .info = snd_hdspm_info_sync_check, \
-  .get = snd_hdspm_get_aes_sync_check \
-}
+	lock = (status & (0x1<<idx)) ? 1 : 0;
+	sync = (status & (0x100<<idx)) ? 1 : 0;
 
-static int hdspm_aes_sync_check(struct hdspm * hdspm, int idx)
-{
-	int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
-	if (status2 & (HDSPM_LockAES >> idx)) {
-		/* I don't know how to differenciate sync from lock.
-		   Doing as if sync for now */
+	if (lock && sync)
 		return 2;
-	}
+	else if (lock)
+		return 1;
 	return 0;
 }
 
-static int snd_hdspm_get_aes_sync_check(struct snd_kcontrol *kcontrol,
+
+static int hdspm_sync_in_sync_check(struct hdspm *hdspm)
+{
+	int status, lock = 0, sync = 0;
+
+	switch (hdspm->io_type) {
+	case RayDAT:
+	case AIO:
+		status = hdspm_read(hdspm, HDSPM_RD_STATUS_3);
+		lock = (status & 0x400) ? 1 : 0;
+		sync = (status & 0x800) ? 1 : 0;
+		break;
+
+	case MADI:
+	case AES32:
+		status = hdspm_read(hdspm, HDSPM_statusRegister2);
+		lock = (status & 0x400000) ? 1 : 0;
+		sync = (status & 0x800000) ? 1 : 0;
+		break;
+
+	case MADIface:
+		break;
+	}
+
+	if (lock && sync)
+		return 2;
+	else if (lock)
+		return 1;
+
+	return 0;
+}
+
+static int hdspm_aes_sync_check(struct hdspm *hdspm, int idx)
+{
+	int status2, lock, sync;
+	status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+
+	lock = (status2 & (0x0080 >> idx)) ? 1 : 0;
+	sync = (status2 & (0x8000 >> idx)) ? 1 : 0;
+
+	if (sync)
+		return 2;
+	else if (lock)
+		return 1;
+	return 0;
+}
+
+
+static int hdspm_tco_sync_check(struct hdspm *hdspm)
+{
+	int status;
+
+	if (hdspm->tco) {
+		switch (hdspm->io_type) {
+		case MADI:
+		case AES32:
+			status = hdspm_read(hdspm, HDSPM_statusRegister);
+			if (status & HDSPM_tcoLock) {
+				if (status & HDSPM_tcoSync)
+					return 2;
+				else
+					return 1;
+			}
+			return 0;
+
+			break;
+
+		case RayDAT:
+		case AIO:
+			status = hdspm_read(hdspm, HDSPM_RD_STATUS_1);
+
+			if (status & 0x8000000)
+				return 2; /* Sync */
+			if (status & 0x4000000)
+				return 1; /* Lock */
+			return 0; /* No signal */
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	return 3; /* N/A */
+}
+
+
+static int snd_hdspm_get_sync_check(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int val = -1;
+
+	switch (hdspm->io_type) {
+	case RayDAT:
+		switch (kcontrol->private_value) {
+		case 0: /* WC */
+			val = hdspm_wc_sync_check(hdspm); break;
+		case 7: /* TCO */
+			val = hdspm_tco_sync_check(hdspm); break;
+		case 8: /* SYNC IN */
+			val = hdspm_sync_in_sync_check(hdspm); break;
+		default:
+			val = hdspm_s1_sync_check(hdspm, ucontrol->id.index-1);
+		}
+
+	case AIO:
+		switch (kcontrol->private_value) {
+		case 0: /* WC */
+			val = hdspm_wc_sync_check(hdspm); break;
+		case 4: /* TCO */
+			val = hdspm_tco_sync_check(hdspm); break;
+		case 5: /* SYNC IN */
+			val = hdspm_sync_in_sync_check(hdspm); break;
+		default:
+			val = hdspm_s1_sync_check(hdspm, ucontrol->id.index-1);
+		}
+
+	case MADI:
+		switch (kcontrol->private_value) {
+		case 0: /* WC */
+			val = hdspm_wc_sync_check(hdspm); break;
+		case 1: /* MADI */
+			val = hdspm_madi_sync_check(hdspm); break;
+		case 2: /* TCO */
+			val = hdspm_tco_sync_check(hdspm); break;
+		case 3: /* SYNC_IN */
+			val = hdspm_sync_in_sync_check(hdspm); break;
+		}
+
+	case MADIface:
+		val = hdspm_madi_sync_check(hdspm); /* MADI */
+		break;
+
+	case AES32:
+		switch (kcontrol->private_value) {
+		case 0: /* WC */
+			val = hdspm_wc_sync_check(hdspm); break;
+		case 9: /* TCO */
+			val = hdspm_tco_sync_check(hdspm); break;
+		case 10 /* SYNC IN */:
+			val = hdspm_sync_in_sync_check(hdspm); break;
+		default:
+			 val = hdspm_aes_sync_check(hdspm,
+					 ucontrol->id.index-1);
+		}
+
+	}
+
+	if (-1 == val)
+		val = 3;
+
+	ucontrol->value.enumerated.item[0] = val;
+	return 0;
+}
+
+
+
+/**
+ * TCO controls
+ **/
+static void hdspm_tco_write(struct hdspm *hdspm)
+{
+	unsigned int tc[4] = { 0, 0, 0, 0};
+
+	switch (hdspm->tco->input) {
+	case 0:
+		tc[2] |= HDSPM_TCO2_set_input_MSB;
+		break;
+	case 1:
+		tc[2] |= HDSPM_TCO2_set_input_LSB;
+		break;
+	default:
+		break;
+	}
+
+	switch (hdspm->tco->framerate) {
+	case 1:
+		tc[1] |= HDSPM_TCO1_LTC_Format_LSB;
+		break;
+	case 2:
+		tc[1] |= HDSPM_TCO1_LTC_Format_MSB;
+		break;
+	case 3:
+		tc[1] |= HDSPM_TCO1_LTC_Format_MSB +
+			HDSPM_TCO1_set_drop_frame_flag;
+		break;
+	case 4:
+		tc[1] |= HDSPM_TCO1_LTC_Format_LSB +
+			HDSPM_TCO1_LTC_Format_MSB;
+		break;
+	case 5:
+		tc[1] |= HDSPM_TCO1_LTC_Format_LSB +
+			HDSPM_TCO1_LTC_Format_MSB +
+			HDSPM_TCO1_set_drop_frame_flag;
+		break;
+	default:
+		break;
+	}
+
+	switch (hdspm->tco->wordclock) {
+	case 1:
+		tc[2] |= HDSPM_TCO2_WCK_IO_ratio_LSB;
+		break;
+	case 2:
+		tc[2] |= HDSPM_TCO2_WCK_IO_ratio_MSB;
+		break;
+	default:
+		break;
+	}
+
+	switch (hdspm->tco->samplerate) {
+	case 1:
+		tc[2] |= HDSPM_TCO2_set_freq;
+		break;
+	case 2:
+		tc[2] |= HDSPM_TCO2_set_freq_from_app;
+		break;
+	default:
+		break;
+	}
+
+	switch (hdspm->tco->pull) {
+	case 1:
+		tc[2] |= HDSPM_TCO2_set_pull_up;
+		break;
+	case 2:
+		tc[2] |= HDSPM_TCO2_set_pull_down;
+		break;
+	case 3:
+		tc[2] |= HDSPM_TCO2_set_pull_up + HDSPM_TCO2_set_01_4;
+		break;
+	case 4:
+		tc[2] |= HDSPM_TCO2_set_pull_down + HDSPM_TCO2_set_01_4;
+		break;
+	default:
+		break;
+	}
+
+	if (1 == hdspm->tco->term) {
+		tc[2] |= HDSPM_TCO2_set_term_75R;
+	}
+
+	hdspm_write(hdspm, HDSPM_WR_TCO, tc[0]);
+	hdspm_write(hdspm, HDSPM_WR_TCO+4, tc[1]);
+	hdspm_write(hdspm, HDSPM_WR_TCO+8, tc[2]);
+	hdspm_write(hdspm, HDSPM_WR_TCO+12, tc[3]);
+}
+
+
+#define HDSPM_TCO_SAMPLE_RATE(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\
+		SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_info_tco_sample_rate, \
+	.get = snd_hdspm_get_tco_sample_rate, \
+	.put = snd_hdspm_put_tco_sample_rate \
+}
+
+static int snd_hdspm_info_tco_sample_rate(struct snd_kcontrol *kcontrol,
+					  struct snd_ctl_elem_info *uinfo)
+{
+	static char *texts[] = { "44.1 kHz", "48 kHz" };
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+			uinfo->value.enumerated.items - 1;
+
+	strcpy(uinfo->value.enumerated.name,
+			texts[uinfo->value.enumerated.item]);
+
+	return 0;
+}
+
+static int snd_hdspm_get_tco_sample_rate(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm->tco->samplerate;
+
+	return 0;
+}
+
+static int snd_hdspm_put_tco_sample_rate(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	if (hdspm->tco->samplerate != ucontrol->value.enumerated.item[0]) {
+		hdspm->tco->samplerate = ucontrol->value.enumerated.item[0];
+
+		hdspm_tco_write(hdspm);
+
+		return 1;
+	}
+
+	return 0;
+}
+
+
+#define HDSPM_TCO_PULL(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\
+		SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_info_tco_pull, \
+	.get = snd_hdspm_get_tco_pull, \
+	.put = snd_hdspm_put_tco_pull \
+}
+
+static int snd_hdspm_info_tco_pull(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+	static char *texts[] = { "0", "+ 0.1 %", "- 0.1 %", "+ 4 %", "- 4 %" };
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 5;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+			uinfo->value.enumerated.items - 1;
+
+	strcpy(uinfo->value.enumerated.name,
+			texts[uinfo->value.enumerated.item]);
+
+	return 0;
+}
+
+static int snd_hdspm_get_tco_pull(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm->tco->pull;
+
+	return 0;
+}
+
+static int snd_hdspm_put_tco_pull(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	if (hdspm->tco->pull != ucontrol->value.enumerated.item[0]) {
+		hdspm->tco->pull = ucontrol->value.enumerated.item[0];
+
+		hdspm_tco_write(hdspm);
+
+		return 1;
+	}
+
+	return 0;
+}
+
+#define HDSPM_TCO_WCK_CONVERSION(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_info_tco_wck_conversion, \
+	.get = snd_hdspm_get_tco_wck_conversion, \
+	.put = snd_hdspm_put_tco_wck_conversion \
+}
+
+static int snd_hdspm_info_tco_wck_conversion(struct snd_kcontrol *kcontrol,
+					     struct snd_ctl_elem_info *uinfo)
+{
+	static char *texts[] = { "1:1", "44.1 -> 48", "48 -> 44.1" };
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 3;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+			uinfo->value.enumerated.items - 1;
+
+	strcpy(uinfo->value.enumerated.name,
+			texts[uinfo->value.enumerated.item]);
+
+	return 0;
+}
+
+static int snd_hdspm_get_tco_wck_conversion(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm->tco->wordclock;
+
+	return 0;
+}
+
+static int snd_hdspm_put_tco_wck_conversion(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	if (hdspm->tco->wordclock != ucontrol->value.enumerated.item[0]) {
+		hdspm->tco->wordclock = ucontrol->value.enumerated.item[0];
+
+		hdspm_tco_write(hdspm);
+
+		return 1;
+	}
+
+	return 0;
+}
+
+
+#define HDSPM_TCO_FRAME_RATE(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_info_tco_frame_rate, \
+	.get = snd_hdspm_get_tco_frame_rate, \
+	.put = snd_hdspm_put_tco_frame_rate \
+}
+
+static int snd_hdspm_info_tco_frame_rate(struct snd_kcontrol *kcontrol,
+					  struct snd_ctl_elem_info *uinfo)
+{
+	static char *texts[] = { "24 fps", "25 fps", "29.97fps",
+		"29.97 dfps", "30 fps", "30 dfps" };
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 6;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+			uinfo->value.enumerated.items - 1;
+
+	strcpy(uinfo->value.enumerated.name,
+			texts[uinfo->value.enumerated.item]);
+
+	return 0;
+}
+
+static int snd_hdspm_get_tco_frame_rate(struct snd_kcontrol *kcontrol,
 					struct snd_ctl_elem_value *ucontrol)
 {
-	int offset;
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	offset = ucontrol->id.index - 1;
-	if (offset < 0 || offset >= 8)
-		return -EINVAL;
+	ucontrol->value.enumerated.item[0] = hdspm->tco->framerate;
 
-	ucontrol->value.enumerated.item[0] =
-		hdspm_aes_sync_check(hdspm, offset);
 	return 0;
 }
 
+static int snd_hdspm_put_tco_frame_rate(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-static struct snd_kcontrol_new snd_hdspm_controls_madi[] = {
+	if (hdspm->tco->framerate != ucontrol->value.enumerated.item[0]) {
+		hdspm->tco->framerate = ucontrol->value.enumerated.item[0];
 
-	HDSPM_MIXER("Mixer", 0),
-/* 'Sample Clock Source' complies with the alsa control naming scheme */
-	HDSPM_CLOCK_SOURCE("Sample Clock Source", 0),
+		hdspm_tco_write(hdspm);
+
+		return 1;
+	}
+
+	return 0;
+}
 
+
+#define HDSPM_TCO_SYNC_SOURCE(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_info_tco_sync_source, \
+	.get = snd_hdspm_get_tco_sync_source, \
+	.put = snd_hdspm_put_tco_sync_source \
+}
+
+static int snd_hdspm_info_tco_sync_source(struct snd_kcontrol *kcontrol,
+					  struct snd_ctl_elem_info *uinfo)
+{
+	static char *texts[] = { "LTC", "Video", "WCK" };
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 3;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+			uinfo->value.enumerated.items - 1;
+
+	strcpy(uinfo->value.enumerated.name,
+			texts[uinfo->value.enumerated.item]);
+
+	return 0;
+}
+
+static int snd_hdspm_get_tco_sync_source(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm->tco->input;
+
+	return 0;
+}
+
+static int snd_hdspm_put_tco_sync_source(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	if (hdspm->tco->input != ucontrol->value.enumerated.item[0]) {
+		hdspm->tco->input = ucontrol->value.enumerated.item[0];
+
+		hdspm_tco_write(hdspm);
+
+		return 1;
+	}
+
+	return 0;
+}
+
+
+#define HDSPM_TCO_WORD_TERM(xname, xindex) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = xindex, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+	.info = snd_hdspm_info_tco_word_term, \
+	.get = snd_hdspm_get_tco_word_term, \
+	.put = snd_hdspm_put_tco_word_term \
+}
+
+static int snd_hdspm_info_tco_word_term(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+
+
+static int snd_hdspm_get_tco_word_term(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm->tco->term;
+
+	return 0;
+}
+
+
+static int snd_hdspm_put_tco_word_term(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	if (hdspm->tco->term != ucontrol->value.enumerated.item[0]) {
+		hdspm->tco->term = ucontrol->value.enumerated.item[0];
+
+		hdspm_tco_write(hdspm);
+
+		return 1;
+	}
+
+	return 0;
+}
+
+
+
+
+static struct snd_kcontrol_new snd_hdspm_controls_madi[] = {
+	HDSPM_MIXER("Mixer", 0),
+	HDSPM_INTERNAL_CLOCK("Internal Clock", 0),
 	HDSPM_SYSTEM_CLOCK_MODE("System Clock Mode", 0),
 	HDSPM_PREF_SYNC_REF("Preferred Sync Reference", 0),
 	HDSPM_AUTOSYNC_REF("AutoSync Reference", 0),
 	HDSPM_SYSTEM_SAMPLE_RATE("System Sample Rate", 0),
-/* 'External Rate' complies with the alsa control naming scheme */
-	HDSPM_AUTOSYNC_SAMPLE_RATE("External Rate", 0),
-	HDSPM_WC_SYNC_CHECK("Word Clock Lock Status", 0),
-	HDSPM_MADI_SYNC_CHECK("MADI Sync Lock Status", 0),
+	HDSPM_SYNC_CHECK("WC SyncCheck", 0),
+	HDSPM_SYNC_CHECK("MADI SyncCheck", 1),
+	HDSPM_SYNC_CHECK("TCO SyncCHeck", 2),
+	HDSPM_SYNC_CHECK("SYNC IN SyncCheck", 3),
 	HDSPM_LINE_OUT("Line Out", 0),
 	HDSPM_TX_64("TX 64 channels mode", 0),
 	HDSPM_C_TMS("Clear Track Marker", 0),
 	HDSPM_SAFE_MODE("Safe Mode", 0),
+	HDSPM_INPUT_SELECT("Input Select", 0)
+};
+
+
+static struct snd_kcontrol_new snd_hdspm_controls_madiface[] = {
+	HDSPM_MIXER("Mixer", 0),
+	HDSPM_INTERNAL_CLOCK("Internal Clock", 0),
+	HDSPM_SYSTEM_CLOCK_MODE("System Clock Mode", 0),
+	HDSPM_SYSTEM_SAMPLE_RATE("System Sample Rate", 0),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("External Rate", 0),
+	HDSPM_SYNC_CHECK("MADI SyncCheck", 0),
+	HDSPM_TX_64("TX 64 channels mode", 0),
+	HDSPM_C_TMS("Clear Track Marker", 0),
+	HDSPM_SAFE_MODE("Safe Mode", 0),
 	HDSPM_INPUT_SELECT("Input Select", 0),
 };
 
-static struct snd_kcontrol_new snd_hdspm_controls_aes32[] = {
+static struct snd_kcontrol_new snd_hdspm_controls_aio[] = {
+	HDSPM_MIXER("Mixer", 0),
+	HDSPM_INTERNAL_CLOCK("Internal Clock", 0),
+	HDSPM_SYSTEM_CLOCK_MODE("System Clock Mode", 0),
+	HDSPM_PREF_SYNC_REF("Preferred Sync Reference", 0),
+	HDSPM_AUTOSYNC_REF("AutoSync Reference", 0),
+	HDSPM_SYSTEM_SAMPLE_RATE("System Sample Rate", 0),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("External Rate", 0),
+	HDSPM_SYNC_CHECK("WC SyncCheck", 0),
+	HDSPM_SYNC_CHECK("AES SyncCheck", 1),
+	HDSPM_SYNC_CHECK("SPDIF SyncCheck", 2),
+	HDSPM_SYNC_CHECK("ADAT SyncCheck", 3),
+	HDSPM_SYNC_CHECK("TCO SyncCheck", 4),
+	HDSPM_SYNC_CHECK("SYNC IN SyncCheck", 5),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("WC Frequency", 0),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("AES Frequency", 1),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("SPDIF Frequency", 2),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("ADAT Frequency", 3),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("TCO Frequency", 4),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("SYNC IN Frequency", 5)
+
+		/*
+		   HDSPM_INPUT_SELECT("Input Select", 0),
+		   HDSPM_SPDIF_OPTICAL("SPDIF Out Optical", 0),
+		   HDSPM_PROFESSIONAL("SPDIF Out Professional", 0);
+		   HDSPM_SPDIF_IN("SPDIF In", 0);
+		   HDSPM_BREAKOUT_CABLE("Breakout Cable", 0);
+		   HDSPM_INPUT_LEVEL("Input Level", 0);
+		   HDSPM_OUTPUT_LEVEL("Output Level", 0);
+		   HDSPM_PHONES("Phones", 0);
+		   */
+};
 
+static struct snd_kcontrol_new snd_hdspm_controls_raydat[] = {
+	HDSPM_MIXER("Mixer", 0),
+	HDSPM_INTERNAL_CLOCK("Internal Clock", 0),
+	HDSPM_SYSTEM_CLOCK_MODE("Clock Mode", 0),
+	HDSPM_PREF_SYNC_REF("Pref Sync Ref", 0),
+	HDSPM_SYSTEM_SAMPLE_RATE("System Sample Rate", 0),
+	HDSPM_SYNC_CHECK("WC SyncCheck", 0),
+	HDSPM_SYNC_CHECK("AES SyncCheck", 1),
+	HDSPM_SYNC_CHECK("SPDIF SyncCheck", 2),
+	HDSPM_SYNC_CHECK("ADAT1 SyncCheck", 3),
+	HDSPM_SYNC_CHECK("ADAT2 SyncCheck", 4),
+	HDSPM_SYNC_CHECK("ADAT3 SyncCheck", 5),
+	HDSPM_SYNC_CHECK("ADAT4 SyncCheck", 6),
+	HDSPM_SYNC_CHECK("TCO SyncCheck", 7),
+	HDSPM_SYNC_CHECK("SYNC IN SyncCheck", 8),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("WC Frequency", 0),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("AES Frequency", 1),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("SPDIF Frequency", 2),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("ADAT1 Frequency", 3),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("ADAT2 Frequency", 4),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("ADAT3 Frequency", 5),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("ADAT4 Frequency", 6),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("TCO Frequency", 7),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("SYNC IN Frequency", 8)
+};
+
+static struct snd_kcontrol_new snd_hdspm_controls_aes32[] = {
 	HDSPM_MIXER("Mixer", 0),
-/* 'Sample Clock Source' complies with the alsa control naming scheme */
-	HDSPM_CLOCK_SOURCE("Sample Clock Source", 0),
-
+	HDSPM_INTERNAL_CLOCK("Internal Clock", 0),
 	HDSPM_SYSTEM_CLOCK_MODE("System Clock Mode", 0),
 	HDSPM_PREF_SYNC_REF("Preferred Sync Reference", 0),
 	HDSPM_AUTOSYNC_REF("AutoSync Reference", 0),
 	HDSPM_SYSTEM_SAMPLE_RATE("System Sample Rate", 0),
-/* 'External Rate' complies with the alsa control naming scheme */
 	HDSPM_AUTOSYNC_SAMPLE_RATE("External Rate", 0),
-	HDSPM_WC_SYNC_CHECK("Word Clock Lock Status", 0),
-/*	HDSPM_AES_SYNC_CHECK("AES Lock Status", 0),*/ /* created in snd_hdspm_create_controls() */
+	HDSPM_SYNC_CHECK("WC Sync Check", 0),
+	HDSPM_SYNC_CHECK("AES1 Sync Check", 1),
+	HDSPM_SYNC_CHECK("AES2 Sync Check", 2),
+	HDSPM_SYNC_CHECK("AES3 Sync Check", 3),
+	HDSPM_SYNC_CHECK("AES4 Sync Check", 4),
+	HDSPM_SYNC_CHECK("AES5 Sync Check", 5),
+	HDSPM_SYNC_CHECK("AES6 Sync Check", 6),
+	HDSPM_SYNC_CHECK("AES7 Sync Check", 7),
+	HDSPM_SYNC_CHECK("AES8 Sync Check", 8),
+	HDSPM_SYNC_CHECK("TCO Sync Check", 9),
+	HDSPM_SYNC_CHECK("SYNC IN Sync Check", 10),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("WC Frequency", 0),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("AES1 Frequency", 1),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("AES2 Frequency", 2),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("AES3 Frequency", 3),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("AES4 Frequency", 4),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("AES5 Frequency", 5),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("AES6 Frequency", 6),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("AES7 Frequency", 7),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("AES8 Frequency", 8),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("TCO Frequency", 9),
+	HDSPM_AUTOSYNC_SAMPLE_RATE("SYNC IN Frequency", 10),
 	HDSPM_LINE_OUT("Line Out", 0),
 	HDSPM_EMPHASIS("Emphasis", 0),
 	HDSPM_DOLBY("Non Audio", 0),
@@ -2842,6 +4203,19 @@ static struct snd_kcontrol_new snd_hdspm_controls_aes32[] = {
 	HDSPM_QS_WIRE("Quad Speed Wire Mode", 0),
 };
 
+
+
+/* Control elements for the optional TCO module */
+static struct snd_kcontrol_new snd_hdspm_controls_tco[] = {
+	HDSPM_TCO_SAMPLE_RATE("TCO Sample Rate", 0),
+	HDSPM_TCO_PULL("TCO Pull", 0),
+	HDSPM_TCO_WCK_CONVERSION("TCO WCK Conversion", 0),
+	HDSPM_TCO_FRAME_RATE("TCO Frame Rate", 0),
+	HDSPM_TCO_SYNC_SOURCE("TCO Sync Source", 0),
+	HDSPM_TCO_WORD_TERM("TCO Word Term", 0)
+};
+
+
 static struct snd_kcontrol_new snd_hdspm_playback_mixer = HDSPM_PLAYBACK_MIXER;
 
 
@@ -2849,78 +4223,76 @@ static int hdspm_update_simple_mixer_controls(struct hdspm * hdspm)
 {
 	int i;
 
-	for (i = hdspm->ds_channels; i < hdspm->ss_channels; ++i) {
+	for (i = hdspm->ds_out_channels; i < hdspm->ss_out_channels; ++i) {
 		if (hdspm->system_sample_rate > 48000) {
 			hdspm->playback_mixer_ctls[i]->vd[0].access =
-			    SNDRV_CTL_ELEM_ACCESS_INACTIVE |
-			    SNDRV_CTL_ELEM_ACCESS_READ |
-			    SNDRV_CTL_ELEM_ACCESS_VOLATILE;
+				SNDRV_CTL_ELEM_ACCESS_INACTIVE |
+				SNDRV_CTL_ELEM_ACCESS_READ |
+				SNDRV_CTL_ELEM_ACCESS_VOLATILE;
 		} else {
 			hdspm->playback_mixer_ctls[i]->vd[0].access =
-			    SNDRV_CTL_ELEM_ACCESS_READWRITE |
-			    SNDRV_CTL_ELEM_ACCESS_VOLATILE;
+				SNDRV_CTL_ELEM_ACCESS_READWRITE |
+				SNDRV_CTL_ELEM_ACCESS_VOLATILE;
 		}
 		snd_ctl_notify(hdspm->card, SNDRV_CTL_EVENT_MASK_VALUE |
-			       SNDRV_CTL_EVENT_MASK_INFO,
-			       &hdspm->playback_mixer_ctls[i]->id);
+				SNDRV_CTL_EVENT_MASK_INFO,
+				&hdspm->playback_mixer_ctls[i]->id);
 	}
 
 	return 0;
 }
 
 
-static int snd_hdspm_create_controls(struct snd_card *card, struct hdspm * hdspm)
+static int snd_hdspm_create_controls(struct snd_card *card,
+					struct hdspm *hdspm)
 {
 	unsigned int idx, limit;
 	int err;
 	struct snd_kcontrol *kctl;
+	struct snd_kcontrol_new *list = NULL;
 
-	/* add control list first */
-	if (hdspm->is_aes32) {
-		struct snd_kcontrol_new aes_sync_ctl =
-			HDSPM_AES_SYNC_CHECK("AES Lock Status", 0);
+	switch (hdspm->io_type) {
+	case MADI:
+		list = snd_hdspm_controls_madi;
+		limit = ARRAY_SIZE(snd_hdspm_controls_madi);
+		break;
+	case MADIface:
+		list = snd_hdspm_controls_madiface;
+		limit = ARRAY_SIZE(snd_hdspm_controls_madiface);
+		break;
+	case AIO:
+		list = snd_hdspm_controls_aio;
+		limit = ARRAY_SIZE(snd_hdspm_controls_aio);
+		break;
+	case RayDAT:
+		list = snd_hdspm_controls_raydat;
+		limit = ARRAY_SIZE(snd_hdspm_controls_raydat);
+		break;
+	case AES32:
+		list = snd_hdspm_controls_aes32;
+		limit = ARRAY_SIZE(snd_hdspm_controls_aes32);
+		break;
+	}
 
-		for (idx = 0; idx < ARRAY_SIZE(snd_hdspm_controls_aes32);
-		     idx++) {
-			err = snd_ctl_add(card,
-					  snd_ctl_new1(&snd_hdspm_controls_aes32[idx],
-						       hdspm));
-			if (err < 0)
-				return err;
-		}
-		for (idx = 1; idx <= 8; idx++) {
-			aes_sync_ctl.index = idx;
+	if (NULL != list) {
+		for (idx = 0; idx < limit; idx++) {
 			err = snd_ctl_add(card,
-					  snd_ctl_new1(&aes_sync_ctl, hdspm));
-			if (err < 0)
-				return err;
-		}
-	} else {
-		for (idx = 0; idx < ARRAY_SIZE(snd_hdspm_controls_madi);
-		     idx++) {
-			err = snd_ctl_add(card,
-					  snd_ctl_new1(&snd_hdspm_controls_madi[idx],
-						       hdspm));
+					snd_ctl_new1(&list[idx], hdspm));
 			if (err < 0)
 				return err;
 		}
 	}
 
-	/* Channel playback mixer as default control 
-	   Note: the whole matrix would be 128*HDSPM_MIXER_CHANNELS Faders,
-	   thats too * big for any alsamixer they are accessible via special
-	   IOCTL on hwdep and the mixer 2dimensional mixer control
-	*/
 
+	/* create simple 1:1 playback mixer controls */
 	snd_hdspm_playback_mixer.name = "Chn";
-	limit = HDSPM_MAX_CHANNELS;
-
-	/* The index values are one greater than the channel ID so that
-	 * alsamixer will display them correctly. We want to use the index
-	 * for fast lookup of the relevant channel, but if we use it at all,
-	 * most ALSA software does the wrong thing with it ...
-	 */
-
+	if (hdspm->system_sample_rate >= 128000) {
+		limit = hdspm->qs_out_channels;
+	} else if (hdspm->system_sample_rate >= 64000) {
+		limit = hdspm->ds_out_channels;
+	} else {
+		limit = hdspm->ss_out_channels;
+	}
 	for (idx = 0; idx < limit; ++idx) {
 		snd_hdspm_playback_mixer.index = idx + 1;
 		kctl = snd_ctl_new1(&snd_hdspm_playback_mixer, hdspm);
@@ -2930,11 +4302,24 @@ static int snd_hdspm_create_controls(struct snd_card *card, struct hdspm * hdspm
 		hdspm->playback_mixer_ctls[idx] = kctl;
 	}
 
+
+	if (hdspm->tco) {
+		/* add tco control elements */
+		list = snd_hdspm_controls_tco;
+		limit = ARRAY_SIZE(snd_hdspm_controls_tco);
+		for (idx = 0; idx < limit; idx++) {
+			err = snd_ctl_add(card,
+					snd_ctl_new1(&list[idx], hdspm));
+			if (err < 0)
+				return err;
+		}
+	}
+
 	return 0;
 }
 
 /*------------------------------------------------------------
-   /proc interface 
+   /proc interface
  ------------------------------------------------------------*/
 
 static void
@@ -2942,72 +4327,178 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 			 struct snd_info_buffer *buffer)
 {
 	struct hdspm *hdspm = entry->private_data;
-	unsigned int status;
-	unsigned int status2;
+	unsigned int status, status2, control, freq;
+
 	char *pref_sync_ref;
 	char *autosync_ref;
 	char *system_clock_mode;
-	char *clock_source;
 	char *insel;
-	char *syncref;
 	int x, x2;
 
+	/* TCO stuff */
+	int a, ltc, frames, seconds, minutes, hours;
+	unsigned int period;
+	u64 freq_const = 0;
+	u32 rate;
+
 	status = hdspm_read(hdspm, HDSPM_statusRegister);
 	status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+	control = hdspm->control_register;
+	freq = hdspm_read(hdspm, HDSPM_timecodeRegister);
 
 	snd_iprintf(buffer, "%s (Card #%d) Rev.%x Status2first3bits: %x\n",
-		    hdspm->card_name, hdspm->card->number + 1,
-		    hdspm->firmware_rev,
-		    (status2 & HDSPM_version0) |
-		    (status2 & HDSPM_version1) | (status2 &
-						  HDSPM_version2));
+			hdspm->card_name, hdspm->card->number + 1,
+			hdspm->firmware_rev,
+			(status2 & HDSPM_version0) |
+			(status2 & HDSPM_version1) | (status2 &
+				HDSPM_version2));
+
+	snd_iprintf(buffer, "HW Serial: 0x%06x%06x\n",
+			(hdspm_read(hdspm, HDSPM_midiStatusIn1)>>8) & 0xFFFFFF,
+			(hdspm_read(hdspm, HDSPM_midiStatusIn0)>>8) & 0xFFFFFF);
 
 	snd_iprintf(buffer, "IRQ: %d Registers bus: 0x%lx VM: 0x%lx\n",
-		    hdspm->irq, hdspm->port, (unsigned long)hdspm->iobase);
+			hdspm->irq, hdspm->port, (unsigned long)hdspm->iobase);
 
 	snd_iprintf(buffer, "--- System ---\n");
 
 	snd_iprintf(buffer,
-		    "IRQ Pending: Audio=%d, MIDI0=%d, MIDI1=%d, IRQcount=%d\n",
-		    status & HDSPM_audioIRQPending,
-		    (status & HDSPM_midi0IRQPending) ? 1 : 0,
-		    (status & HDSPM_midi1IRQPending) ? 1 : 0,
-		    hdspm->irq_count);
+		"IRQ Pending: Audio=%d, MIDI0=%d, MIDI1=%d, IRQcount=%d\n",
+		status & HDSPM_audioIRQPending,
+		(status & HDSPM_midi0IRQPending) ? 1 : 0,
+		(status & HDSPM_midi1IRQPending) ? 1 : 0,
+		hdspm->irq_count);
 	snd_iprintf(buffer,
-		    "HW pointer: id = %d, rawptr = %d (%d->%d) "
-		    "estimated= %ld (bytes)\n",
-		    ((status & HDSPM_BufferID) ? 1 : 0),
-		    (status & HDSPM_BufferPositionMask),
-		    (status & HDSPM_BufferPositionMask) %
-		    (2 * (int)hdspm->period_bytes),
-		    ((status & HDSPM_BufferPositionMask) - 64) %
-		    (2 * (int)hdspm->period_bytes),
-		    (long) hdspm_hw_pointer(hdspm) * 4);
+		"HW pointer: id = %d, rawptr = %d (%d->%d) "
+		"estimated= %ld (bytes)\n",
+		((status & HDSPM_BufferID) ? 1 : 0),
+		(status & HDSPM_BufferPositionMask),
+		(status & HDSPM_BufferPositionMask) %
+		(2 * (int)hdspm->period_bytes),
+		((status & HDSPM_BufferPositionMask) - 64) %
+		(2 * (int)hdspm->period_bytes),
+		(long) hdspm_hw_pointer(hdspm) * 4);
 
 	snd_iprintf(buffer,
-		    "MIDI FIFO: Out1=0x%x, Out2=0x%x, In1=0x%x, In2=0x%x \n",
-		    hdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xFF,
-		    hdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xFF,
-		    hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,
-		    hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);
+		"MIDI FIFO: Out1=0x%x, Out2=0x%x, In1=0x%x, In2=0x%x \n",
+		hdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xFF,
+		hdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xFF,
+		hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,
+		hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);
 	snd_iprintf(buffer,
-		    "Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, "
-		    "status2=0x%x\n",
-		    hdspm->control_register, hdspm->control2_register,
-		    status, status2);
+		"MIDIoverMADI FIFO: In=0x%x, Out=0x%x \n",
+		hdspm_read(hdspm, HDSPM_midiStatusIn2) & 0xFF,
+		hdspm_read(hdspm, HDSPM_midiStatusOut2) & 0xFF);
+	snd_iprintf(buffer,
+		"Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, "
+		"status2=0x%x\n",
+		hdspm->control_register, hdspm->control2_register,
+		status, status2);
+	if (status & HDSPM_tco_detect) {
+		snd_iprintf(buffer, "TCO module detected.\n");
+		a = hdspm_read(hdspm, HDSPM_RD_TCO+4);
+		if (a & HDSPM_TCO1_LTC_Input_valid) {
+			snd_iprintf(buffer, "  LTC valid, ");
+			switch (a & (HDSPM_TCO1_LTC_Format_LSB |
+						HDSPM_TCO1_LTC_Format_MSB)) {
+			case 0:
+				snd_iprintf(buffer, "24 fps, ");
+				break;
+			case HDSPM_TCO1_LTC_Format_LSB:
+				snd_iprintf(buffer, "25 fps, ");
+				break;
+			case HDSPM_TCO1_LTC_Format_MSB:
+				snd_iprintf(buffer, "29.97 fps, ");
+				break;
+			default:
+				snd_iprintf(buffer, "30 fps, ");
+				break;
+			}
+			if (a & HDSPM_TCO1_set_drop_frame_flag) {
+				snd_iprintf(buffer, "drop frame\n");
+			} else {
+				snd_iprintf(buffer, "full frame\n");
+			}
+		} else {
+			snd_iprintf(buffer, "  no LTC\n");
+		}
+		if (a & HDSPM_TCO1_Video_Input_Format_NTSC) {
+			snd_iprintf(buffer, "  Video: NTSC\n");
+		} else if (a & HDSPM_TCO1_Video_Input_Format_PAL) {
+			snd_iprintf(buffer, "  Video: PAL\n");
+		} else {
+			snd_iprintf(buffer, "  No video\n");
+		}
+		if (a & HDSPM_TCO1_TCO_lock) {
+			snd_iprintf(buffer, "  Sync: lock\n");
+		} else {
+			snd_iprintf(buffer, "  Sync: no lock\n");
+		}
+
+		switch (hdspm->io_type) {
+		case MADI:
+		case AES32:
+			freq_const = 110069313433624ULL;
+			break;
+		case RayDAT:
+		case AIO:
+			freq_const = 104857600000000ULL;
+			break;
+		case MADIface:
+			break; /* no TCO possible */
+		}
+
+		period = hdspm_read(hdspm, HDSPM_RD_PLL_FREQ);
+		snd_iprintf(buffer, "    period: %u\n", period);
+
+
+		/* rate = freq_const/period; */
+		rate = div_u64(freq_const, period);
+
+		if (control & HDSPM_QuadSpeed) {
+			rate *= 4;
+		} else if (control & HDSPM_DoubleSpeed) {
+			rate *= 2;
+		}
+
+		snd_iprintf(buffer, "  Frequency: %u Hz\n",
+				(unsigned int) rate);
+
+		ltc = hdspm_read(hdspm, HDSPM_RD_TCO);
+		frames = ltc & 0xF;
+		ltc >>= 4;
+		frames += (ltc & 0x3) * 10;
+		ltc >>= 4;
+		seconds = ltc & 0xF;
+		ltc >>= 4;
+		seconds += (ltc & 0x7) * 10;
+		ltc >>= 4;
+		minutes = ltc & 0xF;
+		ltc >>= 4;
+		minutes += (ltc & 0x7) * 10;
+		ltc >>= 4;
+		hours = ltc & 0xF;
+		ltc >>= 4;
+		hours += (ltc & 0x3) * 10;
+		snd_iprintf(buffer,
+			"  LTC In: %02d:%02d:%02d:%02d\n",
+			hours, minutes, seconds, frames);
+
+	} else {
+		snd_iprintf(buffer, "No TCO module detected.\n");
+	}
 
 	snd_iprintf(buffer, "--- Settings ---\n");
 
 	x = 1 << (6 + hdspm_decode_latency(hdspm->control_register &
-					   HDSPM_LatencyMask));
+							HDSPM_LatencyMask));
 
 	snd_iprintf(buffer,
-		    "Size (Latency): %d samples (2 periods of %lu bytes)\n",
-		    x, (unsigned long) hdspm->period_bytes);
+		"Size (Latency): %d samples (2 periods of %lu bytes)\n",
+		x, (unsigned long) hdspm->period_bytes);
 
-	snd_iprintf(buffer, "Line out: %s,   Precise Pointer: %s\n",
-		    (hdspm->control_register & HDSPM_LineOut) ? "on " : "off",
-		    (hdspm->precise_ptr) ? "on" : "off");
+	snd_iprintf(buffer, "Line out: %s\n",
+		(hdspm->control_register & HDSPM_LineOut) ? "on " : "off");
 
 	switch (hdspm->control_register & HDSPM_InputMask) {
 	case HDSPM_InputOptical:
@@ -3017,63 +4508,22 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 		insel = "Coaxial";
 		break;
 	default:
-		insel = "Unknown";
-	}
-
-	switch (hdspm->control_register & HDSPM_SyncRefMask) {
-	case HDSPM_SyncRef_Word:
-		syncref = "WordClock";
-		break;
-	case HDSPM_SyncRef_MADI:
-		syncref = "MADI";
-		break;
-	default:
-		syncref = "Unknown";
+		insel = "Unkown";
 	}
-	snd_iprintf(buffer, "Inputsel = %s, SyncRef = %s\n", insel,
-		    syncref);
 
 	snd_iprintf(buffer,
-		    "ClearTrackMarker = %s, Transmit in %s Channel Mode, "
-		    "Auto Input %s\n",
-		    (hdspm->
-		     control_register & HDSPM_clr_tms) ? "on" : "off",
-		    (hdspm->
-		     control_register & HDSPM_TX_64ch) ? "64" : "56",
-		    (hdspm->
-		     control_register & HDSPM_AutoInp) ? "on" : "off");
+		"ClearTrackMarker = %s, Transmit in %s Channel Mode, "
+		"Auto Input %s\n",
+		(hdspm->control_register & HDSPM_clr_tms) ? "on" : "off",
+		(hdspm->control_register & HDSPM_TX_64ch) ? "64" : "56",
+		(hdspm->control_register & HDSPM_AutoInp) ? "on" : "off");
+
 
-	switch (hdspm_clock_source(hdspm)) {
-	case HDSPM_CLOCK_SOURCE_AUTOSYNC:
-		clock_source = "AutoSync";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_32KHZ:
-		clock_source = "Internal 32 kHz";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_44_1KHZ:
-		clock_source = "Internal 44.1 kHz";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_48KHZ:
-		clock_source = "Internal 48 kHz";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_64KHZ:
-		clock_source = "Internal 64 kHz";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_88_2KHZ:
-		clock_source = "Internal 88.2 kHz";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_96KHZ:
-		clock_source = "Internal 96 kHz";
-		break;
-	default:
-		clock_source = "Error";
-	}
-	snd_iprintf(buffer, "Sample Clock Source: %s\n", clock_source);
 	if (!(hdspm->control_register & HDSPM_ClockModeMaster))
-		system_clock_mode = "Slave";
+		system_clock_mode = "AutoSync";
 	else
 		system_clock_mode = "Master";
-	snd_iprintf(buffer, "System Clock Mode: %s\n", system_clock_mode);
+	snd_iprintf(buffer, "AutoSync Reference: %s\n", system_clock_mode);
 
 	switch (hdspm_pref_sync_ref(hdspm)) {
 	case HDSPM_SYNC_FROM_WORD:
@@ -3082,15 +4532,21 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 	case HDSPM_SYNC_FROM_MADI:
 		pref_sync_ref = "MADI Sync";
 		break;
+	case HDSPM_SYNC_FROM_TCO:
+		pref_sync_ref = "TCO";
+		break;
+	case HDSPM_SYNC_FROM_SYNC_IN:
+		pref_sync_ref = "Sync In";
+		break;
 	default:
 		pref_sync_ref = "XXXX Clock";
 		break;
 	}
 	snd_iprintf(buffer, "Preferred Sync Reference: %s\n",
-		    pref_sync_ref);
+			pref_sync_ref);
 
 	snd_iprintf(buffer, "System Clock Frequency: %d\n",
-		    hdspm->system_sample_rate);
+			hdspm->system_sample_rate);
 
 
 	snd_iprintf(buffer, "--- Status:\n");
@@ -3099,12 +4555,18 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 	x2 = status2 & HDSPM_wcSync;
 
 	snd_iprintf(buffer, "Inputs MADI=%s, WordClock=%s\n",
-		    (status & HDSPM_madiLock) ? (x ? "Sync" : "Lock") :
-		    "NoLock",
-		    (status2 & HDSPM_wcLock) ? (x2 ? "Sync" : "Lock") :
-		    "NoLock");
+			(status & HDSPM_madiLock) ? (x ? "Sync" : "Lock") :
+			"NoLock",
+			(status2 & HDSPM_wcLock) ? (x2 ? "Sync" : "Lock") :
+			"NoLock");
 
 	switch (hdspm_autosync_ref(hdspm)) {
+	case HDSPM_AUTOSYNC_FROM_SYNC_IN:
+		autosync_ref = "Sync In";
+		break;
+	case HDSPM_AUTOSYNC_FROM_TCO:
+		autosync_ref = "TCO";
+		break;
 	case HDSPM_AUTOSYNC_FROM_WORD:
 		autosync_ref = "Word Clock";
 		break;
@@ -3119,15 +4581,15 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 		break;
 	}
 	snd_iprintf(buffer,
-		    "AutoSync: Reference= %s, Freq=%d (MADI = %d, Word = %d)\n",
-		    autosync_ref, hdspm_external_sample_rate(hdspm),
-		    (status & HDSPM_madiFreqMask) >> 22,
-		    (status2 & HDSPM_wcFreqMask) >> 5);
+		"AutoSync: Reference= %s, Freq=%d (MADI = %d, Word = %d)\n",
+		autosync_ref, hdspm_external_sample_rate(hdspm),
+		(status & HDSPM_madiFreqMask) >> 22,
+		(status2 & HDSPM_wcFreqMask) >> 5);
 
 	snd_iprintf(buffer, "Input: %s, Mode=%s\n",
-		    (status & HDSPM_AB_int) ? "Coax" : "Optical",
-		    (status & HDSPM_RX_64ch) ? "64 channels" :
-		    "56 channels");
+		(status & HDSPM_AB_int) ? "Coax" : "Optical",
+		(status & HDSPM_RX_64ch) ? "64 channels" :
+		"56 channels");
 
 	snd_iprintf(buffer, "\n");
 }
@@ -3142,8 +4604,6 @@ snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
 	unsigned int timecode;
 	int pref_syncref;
 	char *autosync_ref;
-	char *system_clock_mode;
-	char *clock_source;
 	int x;
 
 	status = hdspm_read(hdspm, HDSPM_statusRegister);
@@ -3183,24 +4643,27 @@ snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
 		    hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,
 		    hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);
 	snd_iprintf(buffer,
-		    "Register: ctrl1=0x%x, status1=0x%x, status2=0x%x, "
-		    "timecode=0x%x\n",
-		    hdspm->control_register,
-		    status, status2, timecode);
+		    "MIDIoverMADI FIFO: In=0x%x, Out=0x%x \n",
+		    hdspm_read(hdspm, HDSPM_midiStatusIn2) & 0xFF,
+		    hdspm_read(hdspm, HDSPM_midiStatusOut2) & 0xFF);
+	snd_iprintf(buffer,
+		    "Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, "
+		    "status2=0x%x\n",
+		    hdspm->control_register, hdspm->control2_register,
+		    status, status2);
 
 	snd_iprintf(buffer, "--- Settings ---\n");
 
 	x = 1 << (6 + hdspm_decode_latency(hdspm->control_register &
-					   HDSPM_LatencyMask));
+				HDSPM_LatencyMask));
 
 	snd_iprintf(buffer,
 		    "Size (Latency): %d samples (2 periods of %lu bytes)\n",
 		    x, (unsigned long) hdspm->period_bytes);
 
-	snd_iprintf(buffer, "Line out: %s,   Precise Pointer: %s\n",
+	snd_iprintf(buffer, "Line out: %s\n",
 		    (hdspm->
-		     control_register & HDSPM_LineOut) ? "on " : "off",
-		    (hdspm->precise_ptr) ? "on" : "off");
+		     control_register & HDSPM_LineOut) ? "on " : "off");
 
 	snd_iprintf(buffer,
 		    "ClearTrackMarker %s, Emphasis %s, Dolby %s\n",
@@ -3211,46 +4674,6 @@ snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
 		    (hdspm->
 		     control_register & HDSPM_Dolby) ? "on" : "off");
 
-	switch (hdspm_clock_source(hdspm)) {
-	case HDSPM_CLOCK_SOURCE_AUTOSYNC:
-		clock_source = "AutoSync";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_32KHZ:
-		clock_source = "Internal 32 kHz";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_44_1KHZ:
-		clock_source = "Internal 44.1 kHz";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_48KHZ:
-		clock_source = "Internal 48 kHz";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_64KHZ:
-		clock_source = "Internal 64 kHz";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_88_2KHZ:
-		clock_source = "Internal 88.2 kHz";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_96KHZ:
-		clock_source = "Internal 96 kHz";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_128KHZ:
-		clock_source = "Internal 128 kHz";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_176_4KHZ:
-		clock_source = "Internal 176.4 kHz";
-		break;
-	case HDSPM_CLOCK_SOURCE_INTERNAL_192KHZ:
-		clock_source = "Internal 192 kHz";
-		break;
-	default:
-		clock_source = "Error";
-	}
-	snd_iprintf(buffer, "Sample Clock Source: %s\n", clock_source);
-	if (!(hdspm->control_register & HDSPM_ClockModeMaster))
-		system_clock_mode = "Slave";
-	else
-		system_clock_mode = "Master";
-	snd_iprintf(buffer, "System Clock Mode: %s\n", system_clock_mode);
 
 	pref_syncref = hdspm_pref_sync_ref(hdspm);
 	if (pref_syncref == 0)
@@ -3274,38 +4697,108 @@ snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
 	snd_iprintf(buffer, "--- Status:\n");
 
 	snd_iprintf(buffer, "Word: %s  Frequency: %d\n",
-		    (status & HDSPM_AES32_wcLock)? "Sync   " : "No Lock",
+		    (status & HDSPM_AES32_wcLock) ? "Sync   " : "No Lock",
 		    HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit) & 0xF));
 
 	for (x = 0; x < 8; x++) {
 		snd_iprintf(buffer, "AES%d: %s  Frequency: %d\n",
 			    x+1,
 			    (status2 & (HDSPM_LockAES >> x)) ?
-			    "Sync   ": "No Lock",
+			    "Sync   " : "No Lock",
 			    HDSPM_bit2freq((timecode >> (4*x)) & 0xF));
 	}
 
 	switch (hdspm_autosync_ref(hdspm)) {
-	case HDSPM_AES32_AUTOSYNC_FROM_NONE: autosync_ref="None"; break;
-	case HDSPM_AES32_AUTOSYNC_FROM_WORD: autosync_ref="Word Clock"; break;
-	case HDSPM_AES32_AUTOSYNC_FROM_AES1: autosync_ref="AES1"; break;
-	case HDSPM_AES32_AUTOSYNC_FROM_AES2: autosync_ref="AES2"; break;
-	case HDSPM_AES32_AUTOSYNC_FROM_AES3: autosync_ref="AES3"; break;
-	case HDSPM_AES32_AUTOSYNC_FROM_AES4: autosync_ref="AES4"; break;
-	case HDSPM_AES32_AUTOSYNC_FROM_AES5: autosync_ref="AES5"; break;
-	case HDSPM_AES32_AUTOSYNC_FROM_AES6: autosync_ref="AES6"; break;
-	case HDSPM_AES32_AUTOSYNC_FROM_AES7: autosync_ref="AES7"; break;
-	case HDSPM_AES32_AUTOSYNC_FROM_AES8: autosync_ref="AES8"; break;
-	default: autosync_ref = "---"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_NONE:
+		autosync_ref = "None"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_WORD:
+		autosync_ref = "Word Clock"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES1:
+		autosync_ref = "AES1"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES2:
+		autosync_ref = "AES2"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES3:
+		autosync_ref = "AES3"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES4:
+		autosync_ref = "AES4"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES5:
+		autosync_ref = "AES5"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES6:
+		autosync_ref = "AES6"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES7:
+		autosync_ref = "AES7"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES8:
+		autosync_ref = "AES8"; break;
+	default:
+		autosync_ref = "---"; break;
 	}
 	snd_iprintf(buffer, "AutoSync ref = %s\n", autosync_ref);
 
 	snd_iprintf(buffer, "\n");
 }
 
+static void
+snd_hdspm_proc_read_raydat(struct snd_info_entry *entry,
+			 struct snd_info_buffer *buffer)
+{
+	struct hdspm *hdspm = entry->private_data;
+	unsigned int status1, status2, status3, control, i;
+	unsigned int lock, sync;
+
+	status1 = hdspm_read(hdspm, HDSPM_RD_STATUS_1); /* s1 */
+	status2 = hdspm_read(hdspm, HDSPM_RD_STATUS_2); /* freq */
+	status3 = hdspm_read(hdspm, HDSPM_RD_STATUS_3); /* s2 */
+
+	control = hdspm->control_register;
+
+	snd_iprintf(buffer, "STATUS1: 0x%08x\n", status1);
+	snd_iprintf(buffer, "STATUS2: 0x%08x\n", status2);
+	snd_iprintf(buffer, "STATUS3: 0x%08x\n", status3);
+
+
+	snd_iprintf(buffer, "\n*** CLOCK MODE\n\n");
+
+	snd_iprintf(buffer, "Clock mode      : %s\n",
+		(hdspm_system_clock_mode(hdspm) == 0) ? "master" : "slave");
+	snd_iprintf(buffer, "System frequency: %d Hz\n",
+		hdspm_get_system_sample_rate(hdspm));
+
+	snd_iprintf(buffer, "\n*** INPUT STATUS\n\n");
+
+	lock = 0x1;
+	sync = 0x100;
+
+	for (i = 0; i < 8; i++) {
+		snd_iprintf(buffer, "s1_input %d: Lock %d, Sync %d, Freq %s\n",
+				i,
+				(status1 & lock) ? 1 : 0,
+				(status1 & sync) ? 1 : 0,
+				texts_freq[(status2 >> (i * 4)) & 0xF]);
+
+		lock = lock<<1;
+		sync = sync<<1;
+	}
+
+	snd_iprintf(buffer, "WC input: Lock %d, Sync %d, Freq %s\n",
+			(status1 & 0x1000000) ? 1 : 0,
+			(status1 & 0x2000000) ? 1 : 0,
+			texts_freq[(status1 >> 16) & 0xF]);
+
+	snd_iprintf(buffer, "TCO input: Lock %d, Sync %d, Freq %s\n",
+			(status1 & 0x4000000) ? 1 : 0,
+			(status1 & 0x8000000) ? 1 : 0,
+			texts_freq[(status1 >> 20) & 0xF]);
+
+	snd_iprintf(buffer, "SYNC IN: Lock %d, Sync %d, Freq %s\n",
+			(status3 & 0x400) ? 1 : 0,
+			(status3 & 0x800) ? 1 : 0,
+			texts_freq[(status2 >> 12) & 0xF]);
+
+}
+
 #ifdef CONFIG_SND_DEBUG
 static void
-snd_hdspm_proc_read_debug(struct snd_info_entry * entry,
+snd_hdspm_proc_read_debug(struct snd_info_entry *entry,
 			  struct snd_info_buffer *buffer)
 {
 	struct hdspm *hdspm = entry->private_data;
@@ -3322,16 +4815,68 @@ snd_hdspm_proc_read_debug(struct snd_info_entry * entry,
 #endif
 
 
+static void snd_hdspm_proc_ports_in(struct snd_info_entry *entry,
+			  struct snd_info_buffer *buffer)
+{
+	struct hdspm *hdspm = entry->private_data;
+	int i;
+
+	snd_iprintf(buffer, "# generated by hdspm\n");
+
+	for (i = 0; i < hdspm->max_channels_in; i++) {
+		snd_iprintf(buffer, "%d=%s\n", i+1, hdspm->port_names_in[i]);
+	}
+}
+
+static void snd_hdspm_proc_ports_out(struct snd_info_entry *entry,
+			  struct snd_info_buffer *buffer)
+{
+	struct hdspm *hdspm = entry->private_data;
+	int i;
+
+	snd_iprintf(buffer, "# generated by hdspm\n");
+
+	for (i = 0; i < hdspm->max_channels_out; i++) {
+		snd_iprintf(buffer, "%d=%s\n", i+1, hdspm->port_names_out[i]);
+	}
+}
+
 
-static void __devinit snd_hdspm_proc_init(struct hdspm * hdspm)
+static void __devinit snd_hdspm_proc_init(struct hdspm *hdspm)
 {
 	struct snd_info_entry *entry;
 
-	if (!snd_card_proc_new(hdspm->card, "hdspm", &entry))
-		snd_info_set_text_ops(entry, hdspm,
-				      hdspm->is_aes32 ?
-				      snd_hdspm_proc_read_aes32 :
-				      snd_hdspm_proc_read_madi);
+	if (!snd_card_proc_new(hdspm->card, "hdspm", &entry)) {
+		switch (hdspm->io_type) {
+		case AES32:
+			snd_info_set_text_ops(entry, hdspm,
+					snd_hdspm_proc_read_aes32);
+			break;
+		case MADI:
+			snd_info_set_text_ops(entry, hdspm,
+					snd_hdspm_proc_read_madi);
+			break;
+		case MADIface:
+			/* snd_info_set_text_ops(entry, hdspm,
+			 snd_hdspm_proc_read_madiface); */
+			break;
+		case RayDAT:
+			snd_info_set_text_ops(entry, hdspm,
+					snd_hdspm_proc_read_raydat);
+			break;
+		case AIO:
+			break;
+		}
+	}
+
+	if (!snd_card_proc_new(hdspm->card, "ports.in", &entry)) {
+		snd_info_set_text_ops(entry, hdspm, snd_hdspm_proc_ports_in);
+	}
+
+	if (!snd_card_proc_new(hdspm->card, "ports.out", &entry)) {
+		snd_info_set_text_ops(entry, hdspm, snd_hdspm_proc_ports_out);
+	}
+
 #ifdef CONFIG_SND_DEBUG
 	/* debug file to read all hdspm registers */
 	if (!snd_card_proc_new(hdspm->card, "debug", &entry))
@@ -3341,47 +4886,48 @@ static void __devinit snd_hdspm_proc_init(struct hdspm * hdspm)
 }
 
 /*------------------------------------------------------------
-   hdspm intitialize 
+   hdspm intitialize
  ------------------------------------------------------------*/
 
 static int snd_hdspm_set_defaults(struct hdspm * hdspm)
 {
-	unsigned int i;
-
 	/* ASSUMPTION: hdspm->lock is either held, or there is no need to
 	   hold it (e.g. during module initialization).
-	 */
+	   */
 
 	/* set defaults:       */
 
-	if (hdspm->is_aes32)
+	hdspm->settings_register = 0;
+
+	switch (hdspm->io_type) {
+	case MADI:
+	case MADIface:
+		hdspm->control_register =
+			0x2 + 0x8 + 0x10 + 0x80 + 0x400 + 0x4000 + 0x1000000;
+		break;
+
+	case RayDAT:
+	case AIO:
+		hdspm->settings_register = 0x1 + 0x1000;
+		/* Magic values are: LAT_0, LAT_2, Master, freq1, tx64ch, inp_0,
+		 * line_out */
+		hdspm->control_register =
+			0x2 + 0x8 + 0x10 + 0x80 + 0x400 + 0x4000 + 0x1000000;
+		break;
+
+	case AES32:
 		hdspm->control_register =
 			HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
-			hdspm_encode_latency(7) | /* latency maximum =
-						   * 8192 samples
-						   */
+			hdspm_encode_latency(7) | /* latency max=8192samples */
 			HDSPM_SyncRef0 |	/* AES1 is syncclock */
 			HDSPM_LineOut |	/* Analog output in */
 			HDSPM_Professional;  /* Professional mode */
-	else
-		hdspm->control_register =
-			HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
-			hdspm_encode_latency(7) | /* latency maximum =
-						   * 8192 samples
-						   */
-			HDSPM_InputCoaxial |	/* Input Coax not Optical */
-			HDSPM_SyncRef_MADI |	/* Madi is syncclock */
-			HDSPM_LineOut |	/* Analog output in */
-			HDSPM_TX_64ch |	/* transmit in 64ch mode */
-			HDSPM_AutoInp;	/* AutoInput chossing (takeover) */
-
-	/* ! HDSPM_Frequency0|HDSPM_Frequency1 = 44.1khz */
-	/* !  HDSPM_DoubleSpeed HDSPM_QuadSpeed = normal speed */
-	/* ! HDSPM_clr_tms = do not clear bits in track marks */
+		break;
+	}
 
 	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
 
-        if (!hdspm->is_aes32) {
+	if (AES32 == hdspm->io_type) {
 		/* No control2 register for AES32 */
 #ifdef SNDRV_BIG_ENDIAN
 		hdspm->control2_register = HDSPM_BIGENDIAN_MODE;
@@ -3397,57 +4943,59 @@ static int snd_hdspm_set_defaults(struct hdspm * hdspm)
 
 	all_in_all_mixer(hdspm, 0 * UNITY_GAIN);
 
-	if (line_outs_monitor[hdspm->dev]) {
-
-		snd_printk(KERN_INFO "HDSPM: "
-			   "sending all playback streams to line outs.\n");
-
-		for (i = 0; i < HDSPM_MIXER_CHANNELS; i++) {
-			if (hdspm_write_pb_gain(hdspm, i, i, UNITY_GAIN))
-				return -EIO;
-		}
+	if (hdspm->io_type == AIO || hdspm->io_type == RayDAT) {
+		hdspm_write(hdspm, HDSPM_WR_SETTINGS, hdspm->settings_register);
 	}
 
 	/* set a default rate so that the channel map is set up. */
-	hdspm->channel_map = channel_map_madi_ss;
-	hdspm_set_rate(hdspm, 44100, 1);
+	hdspm_set_rate(hdspm, 48000, 1);
 
 	return 0;
 }
 
 
 /*------------------------------------------------------------
-   interrupt 
+   interrupt
  ------------------------------------------------------------*/
 
 static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id)
 {
 	struct hdspm *hdspm = (struct hdspm *) dev_id;
 	unsigned int status;
-	int audio;
-	int midi0;
-	int midi1;
-	unsigned int midi0status;
-	unsigned int midi1status;
-	int schedule = 0;
+	int i, audio, midi, schedule = 0;
+	/* cycles_t now; */
 
 	status = hdspm_read(hdspm, HDSPM_statusRegister);
 
 	audio = status & HDSPM_audioIRQPending;
-	midi0 = status & HDSPM_midi0IRQPending;
-	midi1 = status & HDSPM_midi1IRQPending;
+	midi = status & (HDSPM_midi0IRQPending | HDSPM_midi1IRQPending |
+			HDSPM_midi2IRQPending | HDSPM_midi3IRQPending);
+
+	/* now = get_cycles(); */
+	/**
+	 *   LAT_2..LAT_0 period  counter (win)  counter (mac)
+	 *          6       4096   ~256053425     ~514672358
+	 *          5       2048   ~128024983     ~257373821
+	 *          4       1024    ~64023706     ~128718089
+	 *          3        512    ~32005945      ~64385999
+	 *          2        256    ~16003039      ~32260176
+	 *          1        128     ~7998738      ~16194507
+	 *          0         64     ~3998231       ~8191558
+	 **/
+	/*
+	   snd_printk(KERN_INFO "snd_hdspm_interrupt %llu @ %llx\n",
+	   now-hdspm->last_interrupt, status & 0xFFC0);
+	   hdspm->last_interrupt = now;
+	*/
 
-	if (!audio && !midi0 && !midi1)
+	if (!audio && !midi)
 		return IRQ_NONE;
 
 	hdspm_write(hdspm, HDSPM_interruptConfirmation, 0);
 	hdspm->irq_count++;
 
-	midi0status = hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xff;
-	midi1status = hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xff;
 
 	if (audio) {
-
 		if (hdspm->capture_substream)
 			snd_pcm_period_elapsed(hdspm->capture_substream);
 
@@ -3455,118 +5003,44 @@ static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id)
 			snd_pcm_period_elapsed(hdspm->playback_substream);
 	}
 
-	if (midi0 && midi0status) {
-		/* we disable interrupts for this input until processing
-		 * is done
-		 */
-		hdspm->control_register &= ~HDSPM_Midi0InterruptEnable;
-		hdspm_write(hdspm, HDSPM_controlRegister,
-			    hdspm->control_register);
-		hdspm->midi[0].pending = 1;
-		schedule = 1;
-	}
-	if (midi1 && midi1status) {
-		/* we disable interrupts for this input until processing
-		 * is done
-		 */
-		hdspm->control_register &= ~HDSPM_Midi1InterruptEnable;
-		hdspm_write(hdspm, HDSPM_controlRegister,
-			    hdspm->control_register);
-		hdspm->midi[1].pending = 1;
-		schedule = 1;
+	if (midi) {
+		i = 0;
+		while (i < hdspm->midiPorts) {
+			if ((hdspm_read(hdspm,
+				hdspm->midi[i].statusIn) & 0xff) &&
+					(status & hdspm->midi[i].irq)) {
+				/* we disable interrupts for this input until
+				 * processing is done
+				 */
+				hdspm->control_register &= ~hdspm->midi[i].ie;
+				hdspm_write(hdspm, HDSPM_controlRegister,
+						hdspm->control_register);
+				hdspm->midi[i].pending = 1;
+				schedule = 1;
+			}
+
+			i++;
+		}
+
+		if (schedule)
+			tasklet_hi_schedule(&hdspm->midi_tasklet);
 	}
-	if (schedule)
-		tasklet_schedule(&hdspm->midi_tasklet);
+
 	return IRQ_HANDLED;
 }
 
 /*------------------------------------------------------------
-   pcm interface 
+   pcm interface
   ------------------------------------------------------------*/
 
 
-static snd_pcm_uframes_t snd_hdspm_hw_pointer(struct snd_pcm_substream *
-					      substream)
+static snd_pcm_uframes_t snd_hdspm_hw_pointer(struct snd_pcm_substream
+					      *substream)
 {
 	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 	return hdspm_hw_pointer(hdspm);
 }
 
-static char *hdspm_channel_buffer_location(struct hdspm * hdspm,
-					   int stream, int channel)
-{
-	int mapped_channel;
-
-	if (snd_BUG_ON(channel < 0 || channel >= HDSPM_MAX_CHANNELS))
-		return NULL;
-
-	mapped_channel = hdspm->channel_map[channel];
-	if (mapped_channel < 0)
-		return NULL;
-
-	if (stream == SNDRV_PCM_STREAM_CAPTURE)
-		return hdspm->capture_buffer +
-		    mapped_channel * HDSPM_CHANNEL_BUFFER_BYTES;
-	else
-		return hdspm->playback_buffer +
-		    mapped_channel * HDSPM_CHANNEL_BUFFER_BYTES;
-}
-
-
-/* dont know why need it ??? */
-static int snd_hdspm_playback_copy(struct snd_pcm_substream *substream,
-				   int channel, snd_pcm_uframes_t pos,
-				   void __user *src, snd_pcm_uframes_t count)
-{
-	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
-	char *channel_buf;
-
-	if (snd_BUG_ON(pos + count > HDSPM_CHANNEL_BUFFER_BYTES / 4))
-		return -EINVAL;
-
-	channel_buf =
-		hdspm_channel_buffer_location(hdspm, substream->pstr->stream,
-					      channel);
-
-	if (snd_BUG_ON(!channel_buf))
-		return -EIO;
-
-	return copy_from_user(channel_buf + pos * 4, src, count * 4);
-}
-
-static int snd_hdspm_capture_copy(struct snd_pcm_substream *substream,
-				  int channel, snd_pcm_uframes_t pos,
-				  void __user *dst, snd_pcm_uframes_t count)
-{
-	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
-	char *channel_buf;
-
-	if (snd_BUG_ON(pos + count > HDSPM_CHANNEL_BUFFER_BYTES / 4))
-		return -EINVAL;
-
-	channel_buf =
-		hdspm_channel_buffer_location(hdspm, substream->pstr->stream,
-					      channel);
-	if (snd_BUG_ON(!channel_buf))
-		return -EIO;
-	return copy_to_user(dst, channel_buf + pos * 4, count * 4);
-}
-
-static int snd_hdspm_hw_silence(struct snd_pcm_substream *substream,
-				int channel, snd_pcm_uframes_t pos,
-				snd_pcm_uframes_t count)
-{
-	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
-	char *channel_buf;
-
-	channel_buf =
-		hdspm_channel_buffer_location(hdspm, substream->pstr->stream,
-					      channel);
-	if (snd_BUG_ON(!channel_buf))
-		return -EIO;
-	memset(channel_buf + pos * 4, 0, count * 4);
-	return 0;
-}
 
 static int snd_hdspm_reset(struct snd_pcm_substream *substream)
 {
@@ -3589,7 +5063,7 @@ static int snd_hdspm_reset(struct snd_pcm_substream *substream)
 		snd_pcm_group_for_each_entry(s, substream) {
 			if (s == other) {
 				oruntime->status->hw_ptr =
-				    runtime->status->hw_ptr;
+					runtime->status->hw_ptr;
 				break;
 			}
 		}
@@ -3621,19 +5095,19 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 		/* The other stream is open, and not by the same
 		   task as this one. Make sure that the parameters
 		   that matter are the same.
-		 */
+		   */
 
 		if (params_rate(params) != hdspm->system_sample_rate) {
 			spin_unlock_irq(&hdspm->lock);
 			_snd_pcm_hw_param_setempty(params,
-						   SNDRV_PCM_HW_PARAM_RATE);
+					SNDRV_PCM_HW_PARAM_RATE);
 			return -EBUSY;
 		}
 
 		if (params_period_size(params) != hdspm->period_bytes / 4) {
 			spin_unlock_irq(&hdspm->lock);
 			_snd_pcm_hw_param_setempty(params,
-					   SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+					SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
 			return -EBUSY;
 		}
 
@@ -3646,18 +5120,20 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 	spin_lock_irq(&hdspm->lock);
 	err = hdspm_set_rate(hdspm, params_rate(params), 0);
 	if (err < 0) {
+		snd_printk(KERN_INFO "err on hdspm_set_rate: %d\n", err);
 		spin_unlock_irq(&hdspm->lock);
 		_snd_pcm_hw_param_setempty(params,
-					   SNDRV_PCM_HW_PARAM_RATE);
+				SNDRV_PCM_HW_PARAM_RATE);
 		return err;
 	}
 	spin_unlock_irq(&hdspm->lock);
 
 	err = hdspm_set_interrupt_interval(hdspm,
-					   params_period_size(params));
+			params_period_size(params));
 	if (err < 0) {
+		snd_printk(KERN_INFO "err on hdspm_set_interrupt_interval: %d\n", err);
 		_snd_pcm_hw_param_setempty(params,
-					   SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+				SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
 		return err;
 	}
 
@@ -3667,10 +5143,13 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 	/* malloc all buffer even if not enabled to get sure */
 	/* Update for MADI rev 204: we need to allocate for all channels,
 	 * otherwise it doesn't work at 96kHz */
+
 	err =
-	    snd_pcm_lib_malloc_pages(substream, HDSPM_DMA_AREA_BYTES);
-	if (err < 0)
+		snd_pcm_lib_malloc_pages(substream, HDSPM_DMA_AREA_BYTES);
+	if (err < 0) {
+		snd_printk(KERN_INFO "err on snd_pcm_lib_malloc_pages: %d\n", err);
 		return err;
+	}
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 
@@ -3681,7 +5160,7 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 			snd_hdspm_enable_out(hdspm, i, 1);
 
 		hdspm->playback_buffer =
-		    (unsigned char *) substream->runtime->dma_area;
+			(unsigned char *) substream->runtime->dma_area;
 		snd_printdd("Allocated sample buffer for playback at %p\n",
 				hdspm->playback_buffer);
 	} else {
@@ -3692,23 +5171,40 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 			snd_hdspm_enable_in(hdspm, i, 1);
 
 		hdspm->capture_buffer =
-		    (unsigned char *) substream->runtime->dma_area;
+			(unsigned char *) substream->runtime->dma_area;
 		snd_printdd("Allocated sample buffer for capture at %p\n",
 				hdspm->capture_buffer);
 	}
+
 	/*
 	   snd_printdd("Allocated sample buffer for %s at 0x%08X\n",
 	   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
 	   "playback" : "capture",
 	   snd_pcm_sgbuf_get_addr(substream, 0));
-	 */
+	   */
 	/*
-	snd_printdd("set_hwparams: %s %d Hz, %d channels, bs = %d\n",
-			substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
-			  "playback" : "capture",
-			params_rate(params), params_channels(params),
-			params_buffer_size(params));
-	*/
+	   snd_printdd("set_hwparams: %s %d Hz, %d channels, bs = %d\n",
+	   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+	   "playback" : "capture",
+	   params_rate(params), params_channels(params),
+	   params_buffer_size(params));
+	   */
+
+
+	/* Switch to native float format if requested */
+	if (SNDRV_PCM_FORMAT_FLOAT_LE == params_format(params)) {
+		if (!(hdspm->control_register & HDSPe_FLOAT_FORMAT))
+			snd_printk(KERN_INFO "hdspm: Switching to native 32bit LE float format.\n");
+
+		hdspm->control_register |= HDSPe_FLOAT_FORMAT;
+	} else if (SNDRV_PCM_FORMAT_S32_LE == params_format(params)) {
+		if (hdspm->control_register & HDSPe_FLOAT_FORMAT)
+			snd_printk(KERN_INFO "hdspm: Switching to native 32bit LE integer format.\n");
+
+		hdspm->control_register &= ~HDSPe_FLOAT_FORMAT;
+	}
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
 	return 0;
 }
 
@@ -3719,14 +5215,14 @@ static int snd_hdspm_hw_free(struct snd_pcm_substream *substream)
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 
-		/* params_channels(params) should be enough, 
+		/* params_channels(params) should be enough,
 		   but to get sure in case of error */
-		for (i = 0; i < HDSPM_MAX_CHANNELS; ++i)
+		for (i = 0; i < hdspm->max_channels_out; ++i)
 			snd_hdspm_enable_out(hdspm, i, 0);
 
 		hdspm->playback_buffer = NULL;
 	} else {
-		for (i = 0; i < HDSPM_MAX_CHANNELS; ++i)
+		for (i = 0; i < hdspm->max_channels_in; ++i)
 			snd_hdspm_enable_in(hdspm, i, 0);
 
 		hdspm->capture_buffer = NULL;
@@ -3738,37 +5234,58 @@ static int snd_hdspm_hw_free(struct snd_pcm_substream *substream)
 	return 0;
 }
 
+
 static int snd_hdspm_channel_info(struct snd_pcm_substream *substream,
-				  struct snd_pcm_channel_info * info)
+		struct snd_pcm_channel_info *info)
 {
 	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
-	int mapped_channel;
 
-	if (snd_BUG_ON(info->channel >= HDSPM_MAX_CHANNELS))
-		return -EINVAL;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (snd_BUG_ON(info->channel >= hdspm->max_channels_out)) {
+			snd_printk(KERN_INFO "snd_hdspm_channel_info: output channel out of range (%d)\n", info->channel);
+			return -EINVAL;
+		}
 
-	mapped_channel = hdspm->channel_map[info->channel];
-	if (mapped_channel < 0)
-		return -EINVAL;
+		if (hdspm->channel_map_out[info->channel] < 0) {
+			snd_printk(KERN_INFO "snd_hdspm_channel_info: output channel %d mapped out\n", info->channel);
+			return -EINVAL;
+		}
+
+		info->offset = hdspm->channel_map_out[info->channel] *
+			HDSPM_CHANNEL_BUFFER_BYTES;
+	} else {
+		if (snd_BUG_ON(info->channel >= hdspm->max_channels_in)) {
+			snd_printk(KERN_INFO "snd_hdspm_channel_info: input channel out of range (%d)\n", info->channel);
+			return -EINVAL;
+		}
+
+		if (hdspm->channel_map_in[info->channel] < 0) {
+			snd_printk(KERN_INFO "snd_hdspm_channel_info: input channel %d mapped out\n", info->channel);
+			return -EINVAL;
+		}
+
+		info->offset = hdspm->channel_map_in[info->channel] *
+			HDSPM_CHANNEL_BUFFER_BYTES;
+	}
 
-	info->offset = mapped_channel * HDSPM_CHANNEL_BUFFER_BYTES;
 	info->first = 0;
 	info->step = 32;
 	return 0;
 }
 
+
 static int snd_hdspm_ioctl(struct snd_pcm_substream *substream,
-			   unsigned int cmd, void *arg)
+		unsigned int cmd, void *arg)
 {
 	switch (cmd) {
 	case SNDRV_PCM_IOCTL1_RESET:
 		return snd_hdspm_reset(substream);
 
 	case SNDRV_PCM_IOCTL1_CHANNEL_INFO:
-	{
-		struct snd_pcm_channel_info *info = arg;
-		return snd_hdspm_channel_info(substream, info);
-	}
+		{
+			struct snd_pcm_channel_info *info = arg;
+			return snd_hdspm_channel_info(substream, info);
+		}
 	default:
 		break;
 	}
@@ -3815,19 +5332,19 @@ static int snd_hdspm_trigger(struct snd_pcm_substream *substream, int cmd)
 		}
 		if (cmd == SNDRV_PCM_TRIGGER_START) {
 			if (!(running & (1 << SNDRV_PCM_STREAM_PLAYBACK))
-			    && substream->stream ==
-			    SNDRV_PCM_STREAM_CAPTURE)
+					&& substream->stream ==
+					SNDRV_PCM_STREAM_CAPTURE)
 				hdspm_silence_playback(hdspm);
 		} else {
 			if (running &&
-			    substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 				hdspm_silence_playback(hdspm);
 		}
 	} else {
 		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
 			hdspm_silence_playback(hdspm);
 	}
-      _ok:
+_ok:
 	snd_pcm_trigger_done(substream, substream);
 	if (!hdspm->running && running)
 		hdspm_start_audio(hdspm);
@@ -3844,8 +5361,18 @@ static int snd_hdspm_prepare(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static unsigned int period_sizes[] =
-    { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
+static unsigned int period_sizes_old[] = {
+	64, 128, 256, 512, 1024, 2048, 4096
+};
+
+static unsigned int period_sizes_new[] = {
+	32, 64, 128, 256, 512, 1024, 2048, 4096
+};
+
+/* RayDAT and AIO always have a buffer of 16384 samples per channel */
+static unsigned int raydat_aio_buffer_sizes[] = {
+	16384
+};
 
 static struct snd_pcm_hardware snd_hdspm_playback_subinfo = {
 	.info = (SNDRV_PCM_INFO_MMAP |
@@ -3866,9 +5393,9 @@ static struct snd_pcm_hardware snd_hdspm_playback_subinfo = {
 	.buffer_bytes_max =
 	    HDSPM_CHANNEL_BUFFER_BYTES * HDSPM_MAX_CHANNELS,
 	.period_bytes_min = (64 * 4),
-	.period_bytes_max = (8192 * 4) * HDSPM_MAX_CHANNELS,
+	.period_bytes_max = (4096 * 4) * HDSPM_MAX_CHANNELS,
 	.periods_min = 2,
-	.periods_max = 2,
+	.periods_max = 512,
 	.fifo_size = 0
 };
 
@@ -3891,20 +5418,66 @@ static struct snd_pcm_hardware snd_hdspm_capture_subinfo = {
 	.buffer_bytes_max =
 	    HDSPM_CHANNEL_BUFFER_BYTES * HDSPM_MAX_CHANNELS,
 	.period_bytes_min = (64 * 4),
-	.period_bytes_max = (8192 * 4) * HDSPM_MAX_CHANNELS,
+	.period_bytes_max = (4096 * 4) * HDSPM_MAX_CHANNELS,
 	.periods_min = 2,
-	.periods_max = 2,
+	.periods_max = 512,
 	.fifo_size = 0
 };
 
-static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
-	.count = ARRAY_SIZE(period_sizes),
-	.list = period_sizes,
+static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes_old = {
+	.count = ARRAY_SIZE(period_sizes_old),
+	.list = period_sizes_old,
+	.mask = 0
+};
+
+static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes_new = {
+	.count = ARRAY_SIZE(period_sizes_new),
+	.list = period_sizes_new,
+	.mask = 0
+};
+
+static struct snd_pcm_hw_constraint_list hw_constraints_raydat_io_buffer = {
+	.count = ARRAY_SIZE(raydat_aio_buffer_sizes),
+	.list = raydat_aio_buffer_sizes,
 	.mask = 0
 };
 
+static int snd_hdspm_hw_rule_in_channels_rate(struct snd_pcm_hw_params *params,
+					   struct snd_pcm_hw_rule *rule)
+{
+	struct hdspm *hdspm = rule->private;
+	struct snd_interval *c =
+	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_interval *r =
+	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+
+	if (r->min > 96000 && r->max <= 192000) {
+		struct snd_interval t = {
+			.min = hdspm->qs_in_channels,
+			.max = hdspm->qs_in_channels,
+			.integer = 1,
+		};
+		return snd_interval_refine(c, &t);
+	} else if (r->min > 48000 && r->max <= 96000) {
+		struct snd_interval t = {
+			.min = hdspm->ds_in_channels,
+			.max = hdspm->ds_in_channels,
+			.integer = 1,
+		};
+		return snd_interval_refine(c, &t);
+	} else if (r->max < 64000) {
+		struct snd_interval t = {
+			.min = hdspm->ss_in_channels,
+			.max = hdspm->ss_in_channels,
+			.integer = 1,
+		};
+		return snd_interval_refine(c, &t);
+	}
+
+	return 0;
+}
 
-static int snd_hdspm_hw_rule_channels_rate(struct snd_pcm_hw_params *params,
+static int snd_hdspm_hw_rule_out_channels_rate(struct snd_pcm_hw_params *params,
 					   struct snd_pcm_hw_rule * rule)
 {
 	struct hdspm *hdspm = rule->private;
@@ -3913,25 +5486,33 @@ static int snd_hdspm_hw_rule_channels_rate(struct snd_pcm_hw_params *params,
 	struct snd_interval *r =
 	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 
-	if (r->min > 48000 && r->max <= 96000) {
+	if (r->min > 96000 && r->max <= 192000) {
+		struct snd_interval t = {
+			.min = hdspm->qs_out_channels,
+			.max = hdspm->qs_out_channels,
+			.integer = 1,
+		};
+		return snd_interval_refine(c, &t);
+	} else if (r->min > 48000 && r->max <= 96000) {
 		struct snd_interval t = {
-			.min = hdspm->ds_channels,
-			.max = hdspm->ds_channels,
+			.min = hdspm->ds_out_channels,
+			.max = hdspm->ds_out_channels,
 			.integer = 1,
 		};
 		return snd_interval_refine(c, &t);
 	} else if (r->max < 64000) {
 		struct snd_interval t = {
-			.min = hdspm->ss_channels,
-			.max = hdspm->ss_channels,
+			.min = hdspm->ss_out_channels,
+			.max = hdspm->ss_out_channels,
 			.integer = 1,
 		};
 		return snd_interval_refine(c, &t);
+	} else {
 	}
 	return 0;
 }
 
-static int snd_hdspm_hw_rule_rate_channels(struct snd_pcm_hw_params *params,
+static int snd_hdspm_hw_rule_rate_in_channels(struct snd_pcm_hw_params *params,
 					   struct snd_pcm_hw_rule * rule)
 {
 	struct hdspm *hdspm = rule->private;
@@ -3940,42 +5521,92 @@ static int snd_hdspm_hw_rule_rate_channels(struct snd_pcm_hw_params *params,
 	struct snd_interval *r =
 	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 
-	if (c->min >= hdspm->ss_channels) {
+	if (c->min >= hdspm->ss_in_channels) {
 		struct snd_interval t = {
 			.min = 32000,
 			.max = 48000,
 			.integer = 1,
 		};
 		return snd_interval_refine(r, &t);
-	} else if (c->max <= hdspm->ds_channels) {
+	} else if (c->max <= hdspm->qs_in_channels) {
+		struct snd_interval t = {
+			.min = 128000,
+			.max = 192000,
+			.integer = 1,
+		};
+		return snd_interval_refine(r, &t);
+	} else if (c->max <= hdspm->ds_in_channels) {
 		struct snd_interval t = {
 			.min = 64000,
 			.max = 96000,
 			.integer = 1,
 		};
+		return snd_interval_refine(r, &t);
+	}
+
+	return 0;
+}
+static int snd_hdspm_hw_rule_rate_out_channels(struct snd_pcm_hw_params *params,
+					   struct snd_pcm_hw_rule *rule)
+{
+	struct hdspm *hdspm = rule->private;
+	struct snd_interval *c =
+	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_interval *r =
+	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 
+	if (c->min >= hdspm->ss_out_channels) {
+		struct snd_interval t = {
+			.min = 32000,
+			.max = 48000,
+			.integer = 1,
+		};
+		return snd_interval_refine(r, &t);
+	} else if (c->max <= hdspm->qs_out_channels) {
+		struct snd_interval t = {
+			.min = 128000,
+			.max = 192000,
+			.integer = 1,
+		};
+		return snd_interval_refine(r, &t);
+	} else if (c->max <= hdspm->ds_out_channels) {
+		struct snd_interval t = {
+			.min = 64000,
+			.max = 96000,
+			.integer = 1,
+		};
 		return snd_interval_refine(r, &t);
 	}
+
 	return 0;
 }
 
-static int snd_hdspm_hw_rule_channels(struct snd_pcm_hw_params *params,
+static int snd_hdspm_hw_rule_in_channels(struct snd_pcm_hw_params *params,
 				      struct snd_pcm_hw_rule *rule)
 {
 	unsigned int list[3];
 	struct hdspm *hdspm = rule->private;
 	struct snd_interval *c = hw_param_interval(params,
 			SNDRV_PCM_HW_PARAM_CHANNELS);
-	if (hdspm->is_aes32) {
-		list[0] = hdspm->qs_channels;
-		list[1] = hdspm->ds_channels;
-		list[2] = hdspm->ss_channels;
-		return snd_interval_list(c, 3, list, 0);
-	} else {
-		list[0] = hdspm->ds_channels;
-		list[1] = hdspm->ss_channels;
-		return snd_interval_list(c, 2, list, 0);
-	}
+
+	list[0] = hdspm->qs_in_channels;
+	list[1] = hdspm->ds_in_channels;
+	list[2] = hdspm->ss_in_channels;
+	return snd_interval_list(c, 3, list, 0);
+}
+
+static int snd_hdspm_hw_rule_out_channels(struct snd_pcm_hw_params *params,
+				      struct snd_pcm_hw_rule *rule)
+{
+	unsigned int list[3];
+	struct hdspm *hdspm = rule->private;
+	struct snd_interval *c = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	list[0] = hdspm->qs_out_channels;
+	list[1] = hdspm->ds_out_channels;
+	list[2] = hdspm->ss_out_channels;
+	return snd_interval_list(c, 3, list, 0);
 }
 
 
@@ -3999,6 +5630,7 @@ static int snd_hdspm_playback_open(struct snd_pcm_substream *substream)
 
 	snd_pcm_set_sync(substream);
 
+
 	runtime->hw = snd_hdspm_playback_subinfo;
 
 	if (hdspm->capture_substream == NULL)
@@ -4011,24 +5643,38 @@ static int snd_hdspm_playback_open(struct snd_pcm_substream *substream)
 
 	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
 
-	snd_pcm_hw_constraint_list(runtime, 0,
-				   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
-				   &hw_constraints_period_sizes);
+	switch (hdspm->io_type) {
+	case AIO:
+	case RayDAT:
+		snd_pcm_hw_constraint_list(runtime, 0,
+				SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+				&hw_constraints_period_sizes_new);
+		snd_pcm_hw_constraint_list(runtime, 0,
+				SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+				&hw_constraints_raydat_io_buffer);
+
+		break;
+
+	default:
+		snd_pcm_hw_constraint_list(runtime, 0,
+				SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+				&hw_constraints_period_sizes_old);
+	}
 
-	if (hdspm->is_aes32) {
+	if (AES32 == hdspm->io_type) {
 		snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
 				&hdspm_hw_constraints_aes32_sample_rates);
 	} else {
 		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-				     snd_hdspm_hw_rule_channels, hdspm,
-				     SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+				snd_hdspm_hw_rule_out_channels, hdspm,
+				SNDRV_PCM_HW_PARAM_CHANNELS, -1);
 		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-				    snd_hdspm_hw_rule_channels_rate, hdspm,
-				    SNDRV_PCM_HW_PARAM_RATE, -1);
+				snd_hdspm_hw_rule_out_channels_rate, hdspm,
+				SNDRV_PCM_HW_PARAM_RATE, -1);
 
 		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
-				    snd_hdspm_hw_rule_rate_channels, hdspm,
-				    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+				snd_hdspm_hw_rule_rate_out_channels, hdspm,
+				SNDRV_PCM_HW_PARAM_CHANNELS, -1);
 	}
 	return 0;
 }
@@ -4066,22 +5712,36 @@ static int snd_hdspm_capture_open(struct snd_pcm_substream *substream)
 	spin_unlock_irq(&hdspm->lock);
 
 	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
-	snd_pcm_hw_constraint_list(runtime, 0,
-				   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
-				   &hw_constraints_period_sizes);
-	if (hdspm->is_aes32) {
+	switch (hdspm->io_type) {
+	case AIO:
+	case RayDAT:
+	  snd_pcm_hw_constraint_list(runtime, 0,
+				     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+				     &hw_constraints_period_sizes_new);
+	  snd_pcm_hw_constraint_list(runtime, 0,
+				     SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+				     &hw_constraints_raydat_io_buffer);
+	  break;
+
+	default:
+	  snd_pcm_hw_constraint_list(runtime, 0,
+				     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+				     &hw_constraints_period_sizes_old);
+	}
+
+	if (AES32 == hdspm->io_type) {
 		snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
 				&hdspm_hw_constraints_aes32_sample_rates);
 	} else {
 		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-				     snd_hdspm_hw_rule_channels, hdspm,
+				     snd_hdspm_hw_rule_in_channels, hdspm,
 				     SNDRV_PCM_HW_PARAM_CHANNELS, -1);
 		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-				    snd_hdspm_hw_rule_channels_rate, hdspm,
+				    snd_hdspm_hw_rule_in_channels_rate, hdspm,
 				    SNDRV_PCM_HW_PARAM_RATE, -1);
 
 		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
-				    snd_hdspm_hw_rule_rate_channels, hdspm,
+				    snd_hdspm_hw_rule_rate_in_channels, hdspm,
 				    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
 	}
 	return 0;
@@ -4100,41 +5760,136 @@ static int snd_hdspm_capture_release(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static int snd_hdspm_hwdep_ioctl(struct snd_hwdep * hw, struct file *file,
-				 unsigned int cmd, unsigned long arg)
+static int snd_hdspm_hwdep_dummy_op(struct snd_hwdep *hw, struct file *file)
+{
+	/* we have nothing to initialize but the call is required */
+	return 0;
+}
+
+static inline int copy_u32_le(void __user *dest, void __iomem *src)
+{
+	u32 val = readl(src);
+	return copy_to_user(dest, &val, 4);
+}
+
+static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
+		unsigned int cmd, unsigned long __user arg)
 {
+	void __user *argp = (void __user *)arg;
 	struct hdspm *hdspm = hw->private_data;
 	struct hdspm_mixer_ioctl mixer;
-	struct hdspm_config_info info;
+	struct hdspm_config info;
+	struct hdspm_status status;
 	struct hdspm_version hdspm_version;
-	struct hdspm_peak_rms_ioctl rms;
+	struct hdspm_peak_rms levels;
+	struct hdspm_ltc ltc;
+	unsigned int statusregister;
+	long unsigned int s;
+	int i = 0;
 
 	switch (cmd) {
 
 	case SNDRV_HDSPM_IOCTL_GET_PEAK_RMS:
-		if (copy_from_user(&rms, (void __user *)arg, sizeof(rms)))
+		for (i = 0; i < HDSPM_MAX_CHANNELS; i++) {
+			levels.input_peaks[i] =
+				readl(hdspm->iobase +
+						HDSPM_MADI_INPUT_PEAK + i*4);
+			levels.playback_peaks[i] =
+				readl(hdspm->iobase +
+						HDSPM_MADI_PLAYBACK_PEAK + i*4);
+			levels.output_peaks[i] =
+				readl(hdspm->iobase +
+						HDSPM_MADI_OUTPUT_PEAK + i*4);
+
+			levels.input_rms[i] =
+				((uint64_t) readl(hdspm->iobase +
+					HDSPM_MADI_INPUT_RMS_H + i*4) << 32) |
+				(uint64_t) readl(hdspm->iobase +
+						HDSPM_MADI_INPUT_RMS_L + i*4);
+			levels.playback_rms[i] =
+				((uint64_t)readl(hdspm->iobase +
+					HDSPM_MADI_PLAYBACK_RMS_H+i*4) << 32) |
+				(uint64_t)readl(hdspm->iobase +
+					HDSPM_MADI_PLAYBACK_RMS_L + i*4);
+			levels.output_rms[i] =
+				((uint64_t)readl(hdspm->iobase +
+					HDSPM_MADI_OUTPUT_RMS_H + i*4) << 32) |
+				(uint64_t)readl(hdspm->iobase +
+						HDSPM_MADI_OUTPUT_RMS_L + i*4);
+		}
+
+		if (hdspm->system_sample_rate > 96000) {
+			levels.speed = qs;
+		} else if (hdspm->system_sample_rate > 48000) {
+			levels.speed = ds;
+		} else {
+			levels.speed = ss;
+		}
+		levels.status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+
+		s = copy_to_user(argp, &levels, sizeof(struct hdspm_peak_rms));
+		if (0 != s) {
+			/* snd_printk(KERN_ERR "copy_to_user(.., .., %lu): %lu
+			 [Levels]\n", sizeof(struct hdspm_peak_rms), s);
+			 */
 			return -EFAULT;
-		/* maybe there is a chance to memorymap in future
-		 * so dont touch just copy
-		 */
-		if(copy_to_user_fromio((void __user *)rms.peak,
-				       hdspm->iobase+HDSPM_MADI_peakrmsbase,
-				       sizeof(struct hdspm_peak_rms)) != 0 )
+		}
+		break;
+
+	case SNDRV_HDSPM_IOCTL_GET_LTC:
+		ltc.ltc = hdspm_read(hdspm, HDSPM_RD_TCO);
+		i = hdspm_read(hdspm, HDSPM_RD_TCO + 4);
+		if (i & HDSPM_TCO1_LTC_Input_valid) {
+			switch (i & (HDSPM_TCO1_LTC_Format_LSB |
+				HDSPM_TCO1_LTC_Format_MSB)) {
+			case 0:
+				ltc.format = fps_24;
+				break;
+			case HDSPM_TCO1_LTC_Format_LSB:
+				ltc.format = fps_25;
+				break;
+			case HDSPM_TCO1_LTC_Format_MSB:
+				ltc.format = fps_2997;
+				break;
+			default:
+				ltc.format = 30;
+				break;
+			}
+			if (i & HDSPM_TCO1_set_drop_frame_flag) {
+				ltc.frame = drop_frame;
+			} else {
+				ltc.frame = full_frame;
+			}
+		} else {
+			ltc.format = format_invalid;
+			ltc.frame = frame_invalid;
+		}
+		if (i & HDSPM_TCO1_Video_Input_Format_NTSC) {
+			ltc.input_format = ntsc;
+		} else if (i & HDSPM_TCO1_Video_Input_Format_PAL) {
+			ltc.input_format = pal;
+		} else {
+			ltc.input_format = no_video;
+		}
+
+		s = copy_to_user(argp, &ltc, sizeof(struct hdspm_ltc));
+		if (0 != s) {
+			/*
+			 snd_printk(KERN_ERR "copy_to_user(.., .., %lu): %lu [LTC]\n", sizeof(struct hdspm_ltc), s); */
 			return -EFAULT;
+		}
 
 		break;
-		
 
-	case SNDRV_HDSPM_IOCTL_GET_CONFIG_INFO:
+	case SNDRV_HDSPM_IOCTL_GET_CONFIG:
 
-		memset(&info, 0, sizeof(info));
 		spin_lock_irq(&hdspm->lock);
 		info.pref_sync_ref = hdspm_pref_sync_ref(hdspm);
 		info.wordclock_sync_check = hdspm_wc_sync_check(hdspm);
 
 		info.system_sample_rate = hdspm->system_sample_rate;
 		info.autosync_sample_rate =
-		    hdspm_external_sample_rate(hdspm);
+			hdspm_external_sample_rate(hdspm);
 		info.system_clock_mode = hdspm_system_clock_mode(hdspm);
 		info.clock_source = hdspm_clock_source(hdspm);
 		info.autosync_ref = hdspm_autosync_ref(hdspm);
@@ -4145,10 +5900,58 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep * hw, struct file *file,
 			return -EFAULT;
 		break;
 
+	case SNDRV_HDSPM_IOCTL_GET_STATUS:
+		status.card_type = hdspm->io_type;
+
+		status.autosync_source = hdspm_autosync_ref(hdspm);
+
+		status.card_clock = 110069313433624ULL;
+		status.master_period = hdspm_read(hdspm, HDSPM_RD_PLL_FREQ);
+
+		switch (hdspm->io_type) {
+		case MADI:
+		case MADIface:
+			status.card_specific.madi.sync_wc =
+				hdspm_wc_sync_check(hdspm);
+			status.card_specific.madi.sync_madi =
+				hdspm_madi_sync_check(hdspm);
+			status.card_specific.madi.sync_tco =
+				hdspm_tco_sync_check(hdspm);
+			status.card_specific.madi.sync_in =
+				hdspm_sync_in_sync_check(hdspm);
+
+			statusregister =
+				hdspm_read(hdspm, HDSPM_statusRegister);
+			status.card_specific.madi.madi_input =
+				(statusregister & HDSPM_AB_int) ? 1 : 0;
+			status.card_specific.madi.channel_format =
+				(statusregister & HDSPM_TX_64ch) ? 1 : 0;
+			/* TODO: Mac driver sets it when f_s>48kHz */
+			status.card_specific.madi.frame_format = 0;
+
+		default:
+			break;
+		}
+
+		if (copy_to_user((void __user *) arg, &status, sizeof(status)))
+			return -EFAULT;
+
+
+		break;
+
 	case SNDRV_HDSPM_IOCTL_GET_VERSION:
+		hdspm_version.card_type = hdspm->io_type;
+		strncpy(hdspm_version.cardname, hdspm->card_name,
+				sizeof(hdspm_version.cardname));
+		hdspm_version.serial = (hdspm_read(hdspm,
+					HDSPM_midiStatusIn0)>>8) & 0xFFFFFF;
 		hdspm_version.firmware_rev = hdspm->firmware_rev;
+		hdspm_version.addons = 0;
+		if (hdspm->tco)
+			hdspm_version.addons |= HDSPM_ADDON_TCO;
+
 		if (copy_to_user((void __user *) arg, &hdspm_version,
-				 sizeof(hdspm_version)))
+					sizeof(hdspm_version)))
 			return -EFAULT;
 		break;
 
@@ -4156,7 +5959,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep * hw, struct file *file,
 		if (copy_from_user(&mixer, (void __user *)arg, sizeof(mixer)))
 			return -EFAULT;
 		if (copy_to_user((void __user *)mixer.mixer, hdspm->mixer,
-				 sizeof(struct hdspm_mixer)))
+					sizeof(struct hdspm_mixer)))
 			return -EFAULT;
 		break;
 
@@ -4175,8 +5978,6 @@ static struct snd_pcm_ops snd_hdspm_playback_ops = {
 	.prepare = snd_hdspm_prepare,
 	.trigger = snd_hdspm_trigger,
 	.pointer = snd_hdspm_hw_pointer,
-	.copy = snd_hdspm_playback_copy,
-	.silence = snd_hdspm_hw_silence,
 	.page = snd_pcm_sgbuf_ops_page,
 };
 
@@ -4189,7 +5990,6 @@ static struct snd_pcm_ops snd_hdspm_capture_ops = {
 	.prepare = snd_hdspm_prepare,
 	.trigger = snd_hdspm_trigger,
 	.pointer = snd_hdspm_hw_pointer,
-	.copy = snd_hdspm_capture_copy,
 	.page = snd_pcm_sgbuf_ops_page,
 };
 
@@ -4207,16 +6007,18 @@ static int __devinit snd_hdspm_create_hwdep(struct snd_card *card,
 	hw->private_data = hdspm;
 	strcpy(hw->name, "HDSPM hwdep interface");
 
+	hw->ops.open = snd_hdspm_hwdep_dummy_op;
 	hw->ops.ioctl = snd_hdspm_hwdep_ioctl;
+	hw->ops.release = snd_hdspm_hwdep_dummy_op;
 
 	return 0;
 }
 
 
 /*------------------------------------------------------------
-   memory interface 
+   memory interface
  ------------------------------------------------------------*/
-static int __devinit snd_hdspm_preallocate_memory(struct hdspm * hdspm)
+static int __devinit snd_hdspm_preallocate_memory(struct hdspm *hdspm)
 {
 	int err;
 	struct snd_pcm *pcm;
@@ -4228,7 +6030,7 @@ static int __devinit snd_hdspm_preallocate_memory(struct hdspm * hdspm)
 
 	err =
 	     snd_pcm_lib_preallocate_pages_for_all(pcm,
-	     					   SNDRV_DMA_TYPE_DEV_SG,
+						   SNDRV_DMA_TYPE_DEV_SG,
 						   snd_dma_pci_data(hdspm->pci),
 						   wanted,
 						   wanted);
@@ -4242,19 +6044,23 @@ static int __devinit snd_hdspm_preallocate_memory(struct hdspm * hdspm)
 	return 0;
 }
 
-static void hdspm_set_sgbuf(struct hdspm * hdspm,
+
+static void hdspm_set_sgbuf(struct hdspm *hdspm,
 			    struct snd_pcm_substream *substream,
 			     unsigned int reg, int channels)
 {
 	int i;
+
+	/* continuous memory segment */
 	for (i = 0; i < (channels * 16); i++)
 		hdspm_write(hdspm, reg + 4 * i,
-			    snd_pcm_sgbuf_get_addr(substream, 4096 * i));
+				snd_pcm_sgbuf_get_addr(substream, 4096 * i));
 }
 
+
 /* ------------- ALSA Devices ---------------------------- */
 static int __devinit snd_hdspm_create_pcm(struct snd_card *card,
-					  struct hdspm * hdspm)
+					  struct hdspm *hdspm)
 {
 	struct snd_pcm *pcm;
 	int err;
@@ -4290,20 +6096,21 @@ static inline void snd_hdspm_initialize_midi_flush(struct hdspm * hdspm)
 static int __devinit snd_hdspm_create_alsa_devices(struct snd_card *card,
 						   struct hdspm * hdspm)
 {
-	int err;
+	int err, i;
 
 	snd_printdd("Create card...\n");
 	err = snd_hdspm_create_pcm(card, hdspm);
 	if (err < 0)
 		return err;
 
-	err = snd_hdspm_create_midi(card, hdspm, 0);
-	if (err < 0)
-		return err;
-
-	err = snd_hdspm_create_midi(card, hdspm, 1);
-	if (err < 0)
-		return err;
+	i = 0;
+	while (i < hdspm->midiPorts) {
+		err = snd_hdspm_create_midi(card, hdspm, i);
+		if (err < 0) {
+			return err;
+		}
+		i++;
+	}
 
 	err = snd_hdspm_create_controls(card, hdspm);
 	if (err < 0)
@@ -4346,37 +6153,49 @@ static int __devinit snd_hdspm_create_alsa_devices(struct snd_card *card,
 }
 
 static int __devinit snd_hdspm_create(struct snd_card *card,
-				      struct hdspm *hdspm,
-				      int precise_ptr, int enable_monitor)
-{
+		struct hdspm *hdspm) {
+
 	struct pci_dev *pci = hdspm->pci;
 	int err;
 	unsigned long io_extent;
 
 	hdspm->irq = -1;
-
-	spin_lock_init(&hdspm->midi[0].lock);
-	spin_lock_init(&hdspm->midi[1].lock);
-
 	hdspm->card = card;
 
 	spin_lock_init(&hdspm->lock);
 
-	tasklet_init(&hdspm->midi_tasklet,
-		     hdspm_midi_tasklet, (unsigned long) hdspm);
-
 	pci_read_config_word(hdspm->pci,
-			     PCI_CLASS_REVISION, &hdspm->firmware_rev);
-
-	hdspm->is_aes32 = (hdspm->firmware_rev >= HDSPM_AESREVISION);
+			PCI_CLASS_REVISION, &hdspm->firmware_rev);
 
 	strcpy(card->mixername, "Xilinx FPGA");
-	if (hdspm->is_aes32) {
-		strcpy(card->driver, "HDSPAES32");
-		hdspm->card_name = "RME HDSPM AES32";
-	} else {
-		strcpy(card->driver, "HDSPM");
-		hdspm->card_name = "RME HDSPM MADI";
+	strcpy(card->driver, "HDSPM");
+
+	switch (hdspm->firmware_rev) {
+	case HDSPM_MADI_REV:
+		hdspm->io_type = MADI;
+		hdspm->card_name = "RME MADI";
+		hdspm->midiPorts = 3;
+		break;
+	case HDSPM_RAYDAT_REV:
+		hdspm->io_type = RayDAT;
+		hdspm->card_name = "RME RayDAT";
+		hdspm->midiPorts = 2;
+		break;
+	case HDSPM_AIO_REV:
+		hdspm->io_type = AIO;
+		hdspm->card_name = "RME AIO";
+		hdspm->midiPorts = 1;
+		break;
+	case HDSPM_MADIFACE_REV:
+		hdspm->io_type = MADIface;
+		hdspm->card_name = "RME MADIface";
+		hdspm->midiPorts = 1;
+		break;
+	case HDSPM_AES_REV:
+		hdspm->io_type = AES32;
+		hdspm->card_name = "RME AES32";
+		hdspm->midiPorts = 2;
+		break;
 	}
 
 	err = pci_enable_device(pci);
@@ -4393,22 +6212,21 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 	io_extent = pci_resource_len(pci, 0);
 
 	snd_printdd("grabbed memory region 0x%lx-0x%lx\n",
-		   hdspm->port, hdspm->port + io_extent - 1);
-
+			hdspm->port, hdspm->port + io_extent - 1);
 
 	hdspm->iobase = ioremap_nocache(hdspm->port, io_extent);
 	if (!hdspm->iobase) {
 		snd_printk(KERN_ERR "HDSPM: "
-			   "unable to remap region 0x%lx-0x%lx\n",
-			   hdspm->port, hdspm->port + io_extent - 1);
+				"unable to remap region 0x%lx-0x%lx\n",
+				hdspm->port, hdspm->port + io_extent - 1);
 		return -EBUSY;
 	}
 	snd_printdd("remapped region (0x%lx) 0x%lx-0x%lx\n",
-		   (unsigned long)hdspm->iobase, hdspm->port,
-		   hdspm->port + io_extent - 1);
+			(unsigned long)hdspm->iobase, hdspm->port,
+			hdspm->port + io_extent - 1);
 
 	if (request_irq(pci->irq, snd_hdspm_interrupt,
-			IRQF_SHARED, "hdspm", hdspm)) {
+				IRQF_SHARED, "hdspm", hdspm)) {
 		snd_printk(KERN_ERR "HDSPM: unable to use IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}
@@ -4416,23 +6234,195 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 	snd_printdd("use IRQ %d\n", pci->irq);
 
 	hdspm->irq = pci->irq;
-	hdspm->precise_ptr = precise_ptr;
-
-	hdspm->monitor_outs = enable_monitor;
 
 	snd_printdd("kmalloc Mixer memory of %zd Bytes\n",
-		   sizeof(struct hdspm_mixer));
+			sizeof(struct hdspm_mixer));
 	hdspm->mixer = kzalloc(sizeof(struct hdspm_mixer), GFP_KERNEL);
 	if (!hdspm->mixer) {
 		snd_printk(KERN_ERR "HDSPM: "
-			   "unable to kmalloc Mixer memory of %d Bytes\n",
-			   (int)sizeof(struct hdspm_mixer));
+				"unable to kmalloc Mixer memory of %d Bytes\n",
+				(int)sizeof(struct hdspm_mixer));
 		return err;
 	}
 
-	hdspm->ss_channels = MADI_SS_CHANNELS;
-	hdspm->ds_channels = MADI_DS_CHANNELS;
-	hdspm->qs_channels = MADI_QS_CHANNELS;
+	hdspm->port_names_in = NULL;
+	hdspm->port_names_out = NULL;
+
+	switch (hdspm->io_type) {
+	case AES32:
+		break;
+
+	case MADI:
+	case MADIface:
+		hdspm->ss_in_channels = hdspm->ss_out_channels =
+			MADI_SS_CHANNELS;
+		hdspm->ds_in_channels = hdspm->ds_out_channels =
+			MADI_DS_CHANNELS;
+		hdspm->qs_in_channels = hdspm->qs_out_channels =
+			MADI_QS_CHANNELS;
+
+		hdspm->channel_map_in_ss = hdspm->channel_map_out_ss =
+			channel_map_unity_ss;
+		hdspm->channel_map_in_ds = hdspm->channel_map_out_ss =
+			channel_map_unity_ss;
+		hdspm->channel_map_in_qs = hdspm->channel_map_out_ss =
+			channel_map_unity_ss;
+
+		hdspm->port_names_in_ss = hdspm->port_names_out_ss =
+			texts_ports_madi;
+		hdspm->port_names_in_ds = hdspm->port_names_out_ds =
+			texts_ports_madi;
+		hdspm->port_names_in_qs = hdspm->port_names_out_qs =
+			texts_ports_madi;
+		break;
+
+	case AIO:
+		if (0 == (hdspm_read(hdspm, HDSPM_statusRegister2) & HDSPM_s2_AEBI_D)) {
+			snd_printk(KERN_INFO "HDSPM: AEB input board found, but not supported\n");
+		}
+
+		hdspm->ss_in_channels = AIO_IN_SS_CHANNELS;
+		hdspm->ds_in_channels = AIO_IN_DS_CHANNELS;
+		hdspm->qs_in_channels = AIO_IN_QS_CHANNELS;
+		hdspm->ss_out_channels = AIO_OUT_SS_CHANNELS;
+		hdspm->ds_out_channels = AIO_OUT_DS_CHANNELS;
+		hdspm->qs_out_channels = AIO_OUT_QS_CHANNELS;
+
+		hdspm->channel_map_out_ss = channel_map_aio_out_ss;
+		hdspm->channel_map_out_ds = channel_map_aio_out_ds;
+		hdspm->channel_map_out_qs = channel_map_aio_out_qs;
+
+		hdspm->channel_map_in_ss = channel_map_aio_in_ss;
+		hdspm->channel_map_in_ds = channel_map_aio_in_ds;
+		hdspm->channel_map_in_qs = channel_map_aio_in_qs;
+
+		hdspm->port_names_in_ss = texts_ports_aio_in_ss;
+		hdspm->port_names_out_ss = texts_ports_aio_out_ss;
+		hdspm->port_names_in_ds = texts_ports_aio_in_ds;
+		hdspm->port_names_out_ds = texts_ports_aio_out_ds;
+		hdspm->port_names_in_qs = texts_ports_aio_in_qs;
+		hdspm->port_names_out_qs = texts_ports_aio_out_qs;
+
+		break;
+
+	case RayDAT:
+		hdspm->ss_in_channels = hdspm->ss_out_channels =
+			RAYDAT_SS_CHANNELS;
+		hdspm->ds_in_channels = hdspm->ds_out_channels =
+			RAYDAT_DS_CHANNELS;
+		hdspm->qs_in_channels = hdspm->qs_out_channels =
+			RAYDAT_QS_CHANNELS;
+
+		hdspm->max_channels_in = RAYDAT_SS_CHANNELS;
+		hdspm->max_channels_out = RAYDAT_SS_CHANNELS;
+
+		hdspm->channel_map_in_ss = hdspm->channel_map_out_ss =
+			channel_map_raydat_ss;
+		hdspm->channel_map_in_ds = hdspm->channel_map_out_ds =
+			channel_map_raydat_ds;
+		hdspm->channel_map_in_qs = hdspm->channel_map_out_qs =
+			channel_map_raydat_qs;
+		hdspm->channel_map_in = hdspm->channel_map_out =
+			channel_map_raydat_ss;
+
+		hdspm->port_names_in_ss = hdspm->port_names_out_ss =
+			texts_ports_raydat_ss;
+		hdspm->port_names_in_ds = hdspm->port_names_out_ds =
+			texts_ports_raydat_ds;
+		hdspm->port_names_in_qs = hdspm->port_names_out_qs =
+			texts_ports_raydat_qs;
+
+
+		break;
+
+	}
+
+	/* TCO detection */
+	switch (hdspm->io_type) {
+	case AIO:
+	case RayDAT:
+		if (hdspm_read(hdspm, HDSPM_statusRegister2) &
+				HDSPM_s2_tco_detect) {
+			hdspm->midiPorts++;
+			hdspm->tco = kzalloc(sizeof(struct hdspm_tco),
+					GFP_KERNEL);
+			if (NULL != hdspm->tco) {
+				hdspm_tco_write(hdspm);
+			}
+			snd_printk(KERN_INFO "HDSPM: AIO/RayDAT TCO module found\n");
+		} else {
+			hdspm->tco = NULL;
+		}
+		break;
+
+	case MADI:
+		if (hdspm_read(hdspm, HDSPM_statusRegister) & HDSPM_tco_detect) {
+			hdspm->midiPorts++;
+			hdspm->tco = kzalloc(sizeof(struct hdspm_tco),
+					GFP_KERNEL);
+			if (NULL != hdspm->tco) {
+				hdspm_tco_write(hdspm);
+			}
+			snd_printk(KERN_INFO "HDSPM: MADI TCO module found\n");
+		} else {
+			hdspm->tco = NULL;
+		}
+		break;
+
+	default:
+		hdspm->tco = NULL;
+	}
+
+	/* texts */
+	switch (hdspm->io_type) {
+	case AES32:
+		if (hdspm->tco) {
+			hdspm->texts_autosync = texts_autosync_aes_tco;
+			hdspm->texts_autosync_items = 10;
+		} else {
+			hdspm->texts_autosync = texts_autosync_aes;
+			hdspm->texts_autosync_items = 9;
+		}
+		break;
+
+	case MADI:
+		if (hdspm->tco) {
+			hdspm->texts_autosync = texts_autosync_madi_tco;
+			hdspm->texts_autosync_items = 4;
+		} else {
+			hdspm->texts_autosync = texts_autosync_madi;
+			hdspm->texts_autosync_items = 3;
+		}
+		break;
+
+	case MADIface:
+
+		break;
+
+	case RayDAT:
+		if (hdspm->tco) {
+			hdspm->texts_autosync = texts_autosync_raydat_tco;
+			hdspm->texts_autosync_items = 9;
+		} else {
+			hdspm->texts_autosync = texts_autosync_raydat;
+			hdspm->texts_autosync_items = 8;
+		}
+		break;
+
+	case AIO:
+		if (hdspm->tco) {
+			hdspm->texts_autosync = texts_autosync_aio_tco;
+			hdspm->texts_autosync_items = 6;
+		} else {
+			hdspm->texts_autosync = texts_autosync_aio;
+			hdspm->texts_autosync_items = 5;
+		}
+		break;
+
+	}
+
+	tasklet_init(&hdspm->midi_tasklet,
+			hdspm_midi_tasklet, (unsigned long) hdspm);
 
 	snd_printdd("create alsa devices.\n");
 	err = snd_hdspm_create_alsa_devices(card, hdspm);
@@ -4444,6 +6434,7 @@ static int __devinit snd_hdspm_create(struct snd_card *card,
 	return 0;
 }
 
+
 static int snd_hdspm_free(struct hdspm * hdspm)
 {
 
@@ -4452,7 +6443,8 @@ static int snd_hdspm_free(struct hdspm * hdspm)
 		/* stop th audio, and cancel all interrupts */
 		hdspm->control_register &=
 		    ~(HDSPM_Start | HDSPM_AudioInterruptEnable |
-		      HDSPM_Midi0InterruptEnable | HDSPM_Midi1InterruptEnable);
+		      HDSPM_Midi0InterruptEnable | HDSPM_Midi1InterruptEnable |
+		      HDSPM_Midi2InterruptEnable | HDSPM_Midi3InterruptEnable);
 		hdspm_write(hdspm, HDSPM_controlRegister,
 			    hdspm->control_register);
 	}
@@ -4472,6 +6464,7 @@ static int snd_hdspm_free(struct hdspm * hdspm)
 	return 0;
 }
 
+
 static void snd_hdspm_card_free(struct snd_card *card)
 {
 	struct hdspm *hdspm = card->private_data;
@@ -4480,6 +6473,7 @@ static void snd_hdspm_card_free(struct snd_card *card)
 		snd_hdspm_free(hdspm);
 }
 
+
 static int __devinit snd_hdspm_probe(struct pci_dev *pci,
 				     const struct pci_device_id *pci_id)
 {
@@ -4496,7 +6490,7 @@ static int __devinit snd_hdspm_probe(struct pci_dev *pci,
 	}
 
 	err = snd_card_create(index[dev], id[dev],
-			      THIS_MODULE, sizeof(struct hdspm), &card);
+			THIS_MODULE, sizeof(struct hdspm), &card);
 	if (err < 0)
 		return err;
 
@@ -4507,16 +6501,25 @@ static int __devinit snd_hdspm_probe(struct pci_dev *pci,
 
 	snd_card_set_dev(card, &pci->dev);
 
-	err = snd_hdspm_create(card, hdspm, precise_ptr[dev],
-			       enable_monitor[dev]);
+	err = snd_hdspm_create(card, hdspm);
 	if (err < 0) {
 		snd_card_free(card);
 		return err;
 	}
 
-	strcpy(card->shortname, "HDSPM MADI");
-	sprintf(card->longname, "%s at 0x%lx, irq %d", hdspm->card_name,
-		hdspm->port, hdspm->irq);
+	if (hdspm->io_type != MADIface) {
+		sprintf(card->shortname, "%s_%x",
+			hdspm->card_name,
+			(hdspm_read(hdspm, HDSPM_midiStatusIn0)>>8) & 0xFFFFFF);
+		sprintf(card->longname, "%s S/N 0x%x at 0x%lx, irq %d",
+			hdspm->card_name,
+			(hdspm_read(hdspm, HDSPM_midiStatusIn0)>>8) & 0xFFFFFF,
+			hdspm->port, hdspm->irq);
+	} else {
+		sprintf(card->shortname, "%s", hdspm->card_name);
+		sprintf(card->longname, "%s at 0x%lx, irq %d",
+				hdspm->card_name, hdspm->port, hdspm->irq);
+	}
 
 	err = snd_card_register(card);
 	if (err < 0) {

commit b595076a180a56d1bb170e6eceda6eb9d76f4cd3
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Nov 1 15:38:34 2010 -0400

    tree-wide: fix comment/printk typos
    
    "gadget", "through", "command", "maintain", "maintain", "controller", "address",
    "between", "initiali[zs]e", "instead", "function", "select", "already",
    "equal", "access", "management", "hierarchy", "registration", "interest",
    "relative", "memory", "offset", "already",
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 0c98ef9156d8..f5eadfc0672a 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -487,7 +487,7 @@ struct hdspm {
 	struct snd_kcontrol *playback_mixer_ctls[HDSPM_MAX_CHANNELS];
 	/* but input to much, so not used */
 	struct snd_kcontrol *input_mixer_ctls[HDSPM_MAX_CHANNELS];
-	/* full mixer accessable over mixer ioctl or hwdep-device */
+	/* full mixer accessible over mixer ioctl or hwdep-device */
 	struct hdspm_mixer *mixer;
 
 };
@@ -550,7 +550,7 @@ static inline int HDSPM_bit2freq(int n)
 	return bit2freq_tab[n];
 }
 
-/* Write/read to/from HDSPM with Adresses in Bytes
+/* Write/read to/from HDSPM with Addresses in Bytes
    not words but only 32Bit writes are allowed */
 
 static inline void hdspm_write(struct hdspm * hdspm, unsigned int reg,
@@ -2908,7 +2908,7 @@ static int snd_hdspm_create_controls(struct snd_card *card, struct hdspm * hdspm
 
 	/* Channel playback mixer as default control 
 	   Note: the whole matrix would be 128*HDSPM_MIXER_CHANNELS Faders,
-	   thats too * big for any alsamixer they are accesible via special
+	   thats too * big for any alsamixer they are accessible via special
 	   IOCTL on hwdep and the mixer 2dimensional mixer control
 	*/
 

commit e68d3b316ab7b02a074edc4f770e6a746390cb7d
Author: Dan Rosenberg <drosenberg@vsecurity.com>
Date:   Sat Sep 25 11:07:27 2010 -0400

    ALSA: sound/pci/rme9652: prevent reading uninitialized stack memory
    
    The SNDRV_HDSP_IOCTL_GET_CONFIG_INFO and
    SNDRV_HDSP_IOCTL_GET_CONFIG_INFO ioctls in hdspm.c and hdsp.c allow
    unprivileged users to read uninitialized kernel stack memory, because
    several fields of the hdsp{m}_config_info structs declared on the stack
    are not altered or zeroed before being copied back to the user.  This
    patch takes care of it.
    
    Signed-off-by: Dan Rosenberg <dan.j.rosenberg@gmail.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 547b713d7204..0c98ef9156d8 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4127,6 +4127,7 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep * hw, struct file *file,
 
 	case SNDRV_HDSPM_IOCTL_GET_CONFIG_INFO:
 
+		memset(&info, 0, sizeof(info));
 		spin_lock_irq(&hdspm->lock);
 		info.pref_sync_ref = hdspm_pref_sync_ref(hdspm);
 		info.wordclock_sync_check = hdspm_wc_sync_check(hdspm);

commit 318ae2edc3b29216abd8a2510f3f80b764f06858
Merge: 25cf84cf377c 3e58974027b0
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon Mar 8 16:55:37 2010 +0100

    Merge branch 'for-next' into for-linus
    
    Conflicts:
            Documentation/filesystems/proc.txt
            arch/arm/mach-u300/include/mach/debug-macro.S
            drivers/net/qlge/qlge_ethtool.c
            drivers/net/qlge/qlge_main.c
            drivers/net/typhoon.c

commit 3ad2f3fbb961429d2aa627465ae4829758bc7e07
Author: Daniel Mack <daniel@caiaq.de>
Date:   Wed Feb 3 08:01:28 2010 +0800

    tree-wide: Assorted spelling fixes
    
    In particular, several occurances of funny versions of 'success',
    'unknown', 'therefore', 'acknowledge', 'argument', 'achieve', 'address',
    'beginning', 'desirable', 'separate' and 'necessary' are fixed.
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Joe Perches <joe@perches.com>
    Cc: Junio C Hamano <gitster@pobox.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index a1b10d1a384d..db0ed1cbd982 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2479,7 +2479,7 @@ static int snd_hdspm_put_qs_wire(struct snd_kcontrol *kcontrol,
    on MADICARD 
   - playback mixer matrix: [channelout+64] [output] [value]
   - input(thru) mixer matrix: [channelin] [output] [value]
-  (better do 2 kontrols for seperation ?)
+  (better do 2 kontrols for separation ?)
 */
 
 #define HDSPM_MIXER(xname, xindex) \

commit cebe41d4b8f8092359de31e241815fcb4b4dc0be
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Feb 6 00:21:03 2010 +0200

    sound: use DEFINE_PCI_DEVICE_TABLE
    
    Use DEFINE_PCI_DEVICE_TABLE() to make PCI device ids go to
    .devinit.rodata section, so they can be discarded in some cases,
    and make them const.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index a1b10d1a384d..3d72c1effeef 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -512,7 +512,7 @@ static char channel_map_madi_ss[HDSPM_MAX_CHANNELS] = {
 };
 
 
-static struct pci_device_id snd_hdspm_ids[] __devinitdata = {
+static DEFINE_PCI_DEVICE_TABLE(snd_hdspm_ids) = {
 	{
 	 .vendor = PCI_VENDOR_ID_XILINX,
 	 .device = PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP_MADI,

commit af901ca181d92aac3a7dc265144a9081a86d8f39
Author: André Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:05 2009 -0200

    tree-wide: fix assorted typos all over the place
    
    That is "success", "unknown", "through", "performance", "[re|un]mapping"
    , "access", "default", "reasonable", "[con]currently", "temperature"
    , "channel", "[un]used", "application", "example","hierarchy", "therefore"
    , "[over|under]flow", "contiguous", "threshold", "enough" and others.
    
    Signed-off-by: André Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 0dce331a2a3b..a1b10d1a384d 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3017,7 +3017,7 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 		insel = "Coaxial";
 		break;
 	default:
-		insel = "Unkown";
+		insel = "Unknown";
 	}
 
 	switch (hdspm->control_register & HDSPM_SyncRefMask) {
@@ -3028,7 +3028,7 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 		syncref = "MADI";
 		break;
 	default:
-		syncref = "Unkown";
+		syncref = "Unknown";
 	}
 	snd_iprintf(buffer, "Inputsel = %s, SyncRef = %s\n", insel,
 		    syncref);

commit 3f7440a6b771169e1f11fa582e53a4259b682809
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 5 17:40:04 2009 +0200

    ALSA: Clean up 64bit division functions
    
    Replace the house-made div64_32() with the standard div_u64*() functions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index bac2dc0c5d85..0dce331a2a3b 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -29,6 +29,7 @@
 #include <linux/moduleparam.h>
 #include <linux/slab.h>
 #include <linux/pci.h>
+#include <linux/math64.h>
 #include <asm/io.h>
 
 #include <sound/core.h>
@@ -831,7 +832,6 @@ static int hdspm_set_interrupt_interval(struct hdspm * s, unsigned int frames)
 static void hdspm_set_dds_value(struct hdspm *hdspm, int rate)
 {
 	u64 n;
-	u32 r;
 	
 	if (rate >= 112000)
 		rate /= 4;
@@ -844,7 +844,7 @@ static void hdspm_set_dds_value(struct hdspm *hdspm, int rate)
         */	   
 	/* n = 104857600000000ULL; */ /*  =  2^20 * 10^8 */
 	n = 110100480000000ULL;    /* Value checked for AES32 and MADI */
-	div64_32(&n, rate, &r);
+	n = div_u64(n, rate);
 	/* n should be less than 2^32 for being written to FREQ register */
 	snd_BUG_ON(n >> 32);
 	hdspm_write(hdspm, HDSPM_freqReg, (u32)n);

commit c2f43981e5dbc92884149aa2234064cc2c340acd
Merge: dec14f8c0eff 28b7e343ee63
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 24 00:35:41 2009 +0100

    Merge branch 'topic/hwdep-cleanup' into for-linus

commit 28b7e343ee63454d563a71d2d5f769fc297fd5ad
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 5 09:28:08 2009 +0100

    ALSA: Remove superfluous hwdep ops
    
    Remove NOP hwdep ops in sound drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 71231cf1b2b0..df2034eb235d 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4100,13 +4100,6 @@ static int snd_hdspm_capture_release(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-static int snd_hdspm_hwdep_dummy_op(struct snd_hwdep * hw, struct file *file)
-{
-	/* we have nothing to initialize but the call is required */
-	return 0;
-}
-
-
 static int snd_hdspm_hwdep_ioctl(struct snd_hwdep * hw, struct file *file,
 				 unsigned int cmd, unsigned long arg)
 {
@@ -4213,9 +4206,7 @@ static int __devinit snd_hdspm_create_hwdep(struct snd_card *card,
 	hw->private_data = hdspm;
 	strcpy(hw->name, "HDSPM hwdep interface");
 
-	hw->ops.open = snd_hdspm_hwdep_dummy_op;
 	hw->ops.ioctl = snd_hdspm_hwdep_ioctl;
-	hw->ops.release = snd_hdspm_hwdep_dummy_op;
 
 	return 0;
 }

commit e58de7baf7de11f01a675cbbf6ecc8a2758b9ca5
Author: Takashi Iwai <tiwai@alsa3.local>
Date:   Sun Dec 28 16:44:30 2008 +0100

    ALSA: Convert to snd_card_create() in sound/pci/*
    
    Convert from snd_card_new() to the new snd_card_create() function
    in sound/pci/*.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 71231cf1b2b0..d4b4e0d0fee8 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4503,10 +4503,10 @@ static int __devinit snd_hdspm_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	card = snd_card_new(index[dev], id[dev],
-			    THIS_MODULE, sizeof(struct hdspm));
-	if (!card)
-		return -ENOMEM;
+	err = snd_card_create(index[dev], id[dev],
+			      THIS_MODULE, sizeof(struct hdspm), &card);
+	if (err < 0)
+		return err;
 
 	hdspm = card->private_data;
 	card->private_free = snd_hdspm_card_free;

commit 5ce442fe2c9423ec5451222aee6f9b2127bb8311
Merge: 60cda2b53a78 2af752936b31
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 25 11:40:34 2008 +0100

    Merge branch 'topic/udev-id-rename' into to-push

commit 1f04128a3db7c0f0e8b5d25323eba70ac342f47f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Dec 18 12:17:55 2008 +0100

    ALSA: hda - Convert from takslet_hi_schedule() to tasklet_schedule()
    
    Replace all tasklet_hi_schedule() callers with the normal
    tasklet_schedule().  The former often causes troubles with
    RT-kernels, and has actually no merit.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 98762f909d64..d7dd53675ccd 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3476,7 +3476,7 @@ static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id)
 		schedule = 1;
 	}
 	if (schedule)
-		tasklet_hi_schedule(&hdspm->midi_tasklet);
+		tasklet_schedule(&hdspm->midi_tasklet);
 	return IRQ_HANDLED;
 }
 

commit 972d4c50fbbb1b9c10293ff90e4e1d45e7fb21ac
Author: Jaroslav Kysela <perex@perex.cz>
Date:   Wed Nov 12 16:37:48 2008 +0100

    ALSA: hdsp/hdspm: remove card->id from rawmidi device name
    
    The card->id (card text identification) can be changed at runtime.
    It might be confusing to have old text identification in device name.
    
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 98762f909d64..dc5c4baa1e64 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1293,7 +1293,7 @@ static int __devinit snd_hdspm_create_midi (struct snd_card *card,
 	if (err < 0)
 		return err;
 
-	sprintf (hdspm->midi[id].rmidi->name, "%s MIDI %d", card->id, id+1);
+	sprintf(hdspm->midi[id].rmidi->name, "HDSPM MIDI %d", id+1);
 	hdspm->midi[id].rmidi->private_data = &hdspm->midi[id];
 
 	snd_rawmidi_set_ops(hdspm->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,

commit 77a23f2695bb2de0cd74599400dc55109c531b72
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Aug 21 13:00:13 2008 +0200

    ALSA: Clean up SG-buffer helper functions and macros
    
    Clean up SG-buffer helper functions and macros.  Helpers take substream
    as arguments now.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 83c92e6082a2..98762f909d64 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -535,7 +535,8 @@ static inline void snd_hdspm_initialize_midi_flush(struct hdspm * hdspm);
 static int hdspm_update_simple_mixer_controls(struct hdspm * hdspm);
 static int hdspm_autosync_ref(struct hdspm * hdspm);
 static int snd_hdspm_set_defaults(struct hdspm * hdspm);
-static void hdspm_set_sgbuf(struct hdspm * hdspm, struct snd_sg_buf *sgbuf,
+static void hdspm_set_sgbuf(struct hdspm * hdspm,
+			    struct snd_pcm_substream *substream,
 			     unsigned int reg, int channels);
 
 static inline int HDSPM_bit2freq(int n)
@@ -3604,8 +3605,6 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 	int i;
 	pid_t this_pid;
 	pid_t other_pid;
-	struct snd_sg_buf *sgbuf;
-
 
 	spin_lock_irq(&hdspm->lock);
 
@@ -3673,11 +3672,9 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 	if (err < 0)
 		return err;
 
-	sgbuf = snd_pcm_substream_sgbuf(substream);
-
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 
-		hdspm_set_sgbuf(hdspm, sgbuf, HDSPM_pageAddressBufferOut,
+		hdspm_set_sgbuf(hdspm, substream, HDSPM_pageAddressBufferOut,
 				params_channels(params));
 
 		for (i = 0; i < params_channels(params); ++i)
@@ -3688,7 +3685,7 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 		snd_printdd("Allocated sample buffer for playback at %p\n",
 				hdspm->playback_buffer);
 	} else {
-		hdspm_set_sgbuf(hdspm, sgbuf, HDSPM_pageAddressBufferIn,
+		hdspm_set_sgbuf(hdspm, substream, HDSPM_pageAddressBufferIn,
 				params_channels(params));
 
 		for (i = 0; i < params_channels(params); ++i)
@@ -3703,7 +3700,7 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 	   snd_printdd("Allocated sample buffer for %s at 0x%08X\n",
 	   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
 	   "playback" : "capture",
-	   snd_pcm_sgbuf_get_addr(sgbuf, 0));
+	   snd_pcm_sgbuf_get_addr(substream, 0));
 	 */
 	/*
 	snd_printdd("set_hwparams: %s %d Hz, %d channels, bs = %d\n",
@@ -4253,13 +4250,14 @@ static int __devinit snd_hdspm_preallocate_memory(struct hdspm * hdspm)
 	return 0;
 }
 
-static void hdspm_set_sgbuf(struct hdspm * hdspm, struct snd_sg_buf *sgbuf,
+static void hdspm_set_sgbuf(struct hdspm * hdspm,
+			    struct snd_pcm_substream *substream,
 			     unsigned int reg, int channels)
 {
 	int i;
 	for (i = 0; i < (channels * 16); i++)
 		hdspm_write(hdspm, reg + 4 * i,
-			    snd_pcm_sgbuf_get_addr(sgbuf, (size_t) 4096 * i));
+			    snd_pcm_sgbuf_get_addr(substream, 4096 * i));
 }
 
 /* ------------- ALSA Devices ---------------------------- */

commit da3cec35dd3c31d8706db4bf379372ce70d92118
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Aug 8 17:12:14 2008 +0200

    ALSA: Kill snd_assert() in sound/pci/*
    
    Kill snd_assert() in sound/pci/*, either removed or replaced with
    if () with snd_BUG_ON().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index ab423bc82342..83c92e6082a2 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -845,7 +845,7 @@ static void hdspm_set_dds_value(struct hdspm *hdspm, int rate)
 	n = 110100480000000ULL;    /* Value checked for AES32 and MADI */
 	div64_32(&n, rate, &r);
 	/* n should be less than 2^32 for being written to FREQ register */
-	snd_assert((n >> 32) == 0);
+	snd_BUG_ON(n >> 32);
 	hdspm_write(hdspm, HDSPM_freqReg, (u32)n);
 }
 
@@ -2617,8 +2617,8 @@ static int snd_hdspm_get_playback_mixer(struct snd_kcontrol *kcontrol,
 
 	channel = ucontrol->id.index - 1;
 
-	snd_assert(channel >= 0
-		   || channel < HDSPM_MAX_CHANNELS, return -EINVAL);
+	if (snd_BUG_ON(channel < 0 || channel >= HDSPM_MAX_CHANNELS))
+		return -EINVAL;
 
 	mapped_channel = hdspm->channel_map[channel];
 	if (mapped_channel < 0)
@@ -2652,8 +2652,8 @@ static int snd_hdspm_put_playback_mixer(struct snd_kcontrol *kcontrol,
 
 	channel = ucontrol->id.index - 1;
 
-	snd_assert(channel >= 0
-		   || channel < HDSPM_MAX_CHANNELS, return -EINVAL);
+	if (snd_BUG_ON(channel < 0 || channel >= HDSPM_MAX_CHANNELS))
+		return -EINVAL;
 
 	mapped_channel = hdspm->channel_map[channel];
 	if (mapped_channel < 0)
@@ -3496,8 +3496,8 @@ static char *hdspm_channel_buffer_location(struct hdspm * hdspm,
 {
 	int mapped_channel;
 
-	snd_assert(channel >= 0
-		   || channel < HDSPM_MAX_CHANNELS, return NULL);
+	if (snd_BUG_ON(channel < 0 || channel >= HDSPM_MAX_CHANNELS))
+		return NULL;
 
 	mapped_channel = hdspm->channel_map[channel];
 	if (mapped_channel < 0)
@@ -3520,14 +3520,15 @@ static int snd_hdspm_playback_copy(struct snd_pcm_substream *substream,
 	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 	char *channel_buf;
 
-	snd_assert(pos + count <= HDSPM_CHANNEL_BUFFER_BYTES / 4,
-		   return -EINVAL);
+	if (snd_BUG_ON(pos + count > HDSPM_CHANNEL_BUFFER_BYTES / 4))
+		return -EINVAL;
 
 	channel_buf =
 		hdspm_channel_buffer_location(hdspm, substream->pstr->stream,
 					      channel);
 
-	snd_assert(channel_buf != NULL, return -EIO);
+	if (snd_BUG_ON(!channel_buf))
+		return -EIO;
 
 	return copy_from_user(channel_buf + pos * 4, src, count * 4);
 }
@@ -3539,13 +3540,14 @@ static int snd_hdspm_capture_copy(struct snd_pcm_substream *substream,
 	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 	char *channel_buf;
 
-	snd_assert(pos + count <= HDSPM_CHANNEL_BUFFER_BYTES / 4,
-		   return -EINVAL);
+	if (snd_BUG_ON(pos + count > HDSPM_CHANNEL_BUFFER_BYTES / 4))
+		return -EINVAL;
 
 	channel_buf =
 		hdspm_channel_buffer_location(hdspm, substream->pstr->stream,
 					      channel);
-	snd_assert(channel_buf != NULL, return -EIO);
+	if (snd_BUG_ON(!channel_buf))
+		return -EIO;
 	return copy_to_user(dst, channel_buf + pos * 4, count * 4);
 }
 
@@ -3559,7 +3561,8 @@ static int snd_hdspm_hw_silence(struct snd_pcm_substream *substream,
 	channel_buf =
 		hdspm_channel_buffer_location(hdspm, substream->pstr->stream,
 					      channel);
-	snd_assert(channel_buf != NULL, return -EIO);
+	if (snd_BUG_ON(!channel_buf))
+		return -EIO;
 	memset(channel_buf + pos * 4, 0, count * 4);
 	return 0;
 }
@@ -3744,7 +3747,8 @@ static int snd_hdspm_channel_info(struct snd_pcm_substream *substream,
 	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 	int mapped_channel;
 
-	snd_assert(info->channel < HDSPM_MAX_CHANNELS, return -EINVAL);
+	if (snd_BUG_ON(info->channel >= HDSPM_MAX_CHANNELS))
+		return -EINVAL;
 
 	mapped_channel = hdspm->channel_map[info->channel];
 	if (mapped_channel < 0)

commit 62cef8212ffa9df3e6c5b358ea2382d90489d590
Author: Denys Vlasenko <vda.linux@googlemail.com>
Date:   Mon Apr 14 13:04:18 2008 +0200

    [ALSA] sound/pci/rme9652/hdspm.c: stop inlining largish static functions
    
    sound/pci/rme9652/hdspm.c has unusually large number of static inline
    functions - 22.
    
    I looked through them and some of them seem to be too big to warrant inlining.
    
    This patch removes "inline" from these static functions (regardless of number
    of callsites - gcc nowadays auto-inlines statics with one callsite).
    
    Size difference on 32bit x86:
       text    data     bss     dec     hex filename
      20437    2160     516   23113    5a49 linux-2.6-ALLYES/sound/pci/rme9652/hdspm.o
      18036    2160     516   20712    50e8 linux-2.6.inline-ALLYES/sound/pci/rme9652/hdspm.o
    
    [coding fix by Takashi Iwai <tiwai@suse.de>]
    
    Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 38c931c480d9..ab423bc82342 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -540,7 +540,8 @@ static void hdspm_set_sgbuf(struct hdspm * hdspm, struct snd_sg_buf *sgbuf,
 
 static inline int HDSPM_bit2freq(int n)
 {
-	static int bit2freq_tab[] = { 0, 32000, 44100, 48000, 64000, 88200,
+	static const int bit2freq_tab[] = {
+		0, 32000, 44100, 48000, 64000, 88200,
 		96000, 128000, 176400, 192000 };
 	if (n < 1 || n > 9)
 		return 0;
@@ -582,7 +583,7 @@ static inline int hdspm_read_pb_gain(struct hdspm * hdspm, unsigned int chan,
 	return hdspm->mixer->ch[chan].pb[pb];
 }
 
-static inline int hdspm_write_in_gain(struct hdspm * hdspm, unsigned int chan,
+static int hdspm_write_in_gain(struct hdspm *hdspm, unsigned int chan,
 				      unsigned int in, unsigned short data)
 {
 	if (chan >= HDSPM_MIXER_CHANNELS || in >= HDSPM_MIXER_CHANNELS)
@@ -595,7 +596,7 @@ static inline int hdspm_write_in_gain(struct hdspm * hdspm, unsigned int chan,
 	return 0;
 }
 
-static inline int hdspm_write_pb_gain(struct hdspm * hdspm, unsigned int chan,
+static int hdspm_write_pb_gain(struct hdspm *hdspm, unsigned int chan,
 				      unsigned int pb, unsigned short data)
 {
 	if (chan >= HDSPM_MIXER_CHANNELS || pb >= HDSPM_MIXER_CHANNELS)
@@ -621,7 +622,7 @@ static inline void snd_hdspm_enable_out(struct hdspm * hdspm, int i, int v)
 }
 
 /* check if same process is writing and reading */
-static inline int snd_hdspm_use_is_exclusive(struct hdspm * hdspm)
+static int snd_hdspm_use_is_exclusive(struct hdspm *hdspm)
 {
 	unsigned long flags;
 	int ret = 1;
@@ -636,7 +637,7 @@ static inline int snd_hdspm_use_is_exclusive(struct hdspm * hdspm)
 }
 
 /* check for external sample rate */
-static inline int hdspm_external_sample_rate(struct hdspm * hdspm)
+static int hdspm_external_sample_rate(struct hdspm *hdspm)
 {
 	if (hdspm->is_aes32) {
 		unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
@@ -787,7 +788,7 @@ static inline void hdspm_stop_audio(struct hdspm * s)
 }
 
 /* should I silence all or only opened ones ? doit all for first even is 4MB*/
-static inline void hdspm_silence_playback(struct hdspm * hdspm)
+static void hdspm_silence_playback(struct hdspm *hdspm)
 {
 	int i;
 	int n = hdspm->period_bytes;
@@ -1057,7 +1058,7 @@ static inline int snd_hdspm_midi_output_possible (struct hdspm *hdspm, int id)
 		return 0;
 }
 
-static inline void snd_hdspm_flush_midi_input (struct hdspm *hdspm, int id)
+static void snd_hdspm_flush_midi_input(struct hdspm *hdspm, int id)
 {
 	while (snd_hdspm_midi_input_available (hdspm, id))
 		snd_hdspm_midi_read_byte (hdspm, id);

commit 0b76b51e5807951995a39ea791b39971a7ae945f
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Fri Feb 29 11:54:49 2008 +0100

    [ALSA] sound: hdspm.c fix returning void expression warnings
    
    Just drop the returns.
    sound/pci/rme9652/hdspm.c:1031:3: warning: returning void-valued expression
    sound/pci/rme9652/hdspm.c:1033:3: warning: returning void-valued expression
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 9a19ae6a64d9..38c931c480d9 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1028,9 +1028,9 @@ static inline void snd_hdspm_midi_write_byte (struct hdspm *hdspm, int id,
 {
 	/* the hardware already does the relevant bit-mask with 0xff */
 	if (id)
-		return hdspm_write(hdspm, HDSPM_midiDataOut1, val);
+		hdspm_write(hdspm, HDSPM_midiDataOut1, val);
 	else
-		return hdspm_write(hdspm, HDSPM_midiDataOut0, val);
+		hdspm_write(hdspm, HDSPM_midiDataOut0, val);
 }
 
 static inline int snd_hdspm_midi_input_available (struct hdspm *hdspm, int id)

commit 9004acc70e8c49c50c4c7b652f906f1e0ed5709d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 8 18:13:27 2008 +0100

    [ALSA] Remove sound/driver.h
    
    This header file exists only for some hacks to adapt alsa-driver
    tree.  It's useless for building in the kernel.  Let's move a few
    lines in it to sound/core.h and remove it.
    With this patch, sound/driver.h isn't removed but has just a single
    compile warning to include it.  This should be really killed in
    future.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 6b1d5292fc20..9a19ae6a64d9 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -23,7 +23,6 @@
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  *
  */
-#include <sound/driver.h>
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>

commit 561de31a23a8a5d23baeb8b2ce7c6102cb649616
Author: Joe Perches <joe@perches.com>
Date:   Tue Dec 18 13:13:47 2007 +0100

    [ALSA] sound/: Spelling fixes
    
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@perex.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index f1bdda6cbcff..6b1d5292fc20 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3348,7 +3348,7 @@ static int snd_hdspm_set_defaults(struct hdspm * hdspm)
 	unsigned int i;
 
 	/* ASSUMPTION: hdspm->lock is either held, or there is no need to
-	   hold it (e.g. during module initalization).
+	   hold it (e.g. during module initialization).
 	 */
 
 	/* set defaults:       */
@@ -3416,7 +3416,7 @@ static int snd_hdspm_set_defaults(struct hdspm * hdspm)
 
 
 /*------------------------------------------------------------
-   interupt 
+   interrupt 
  ------------------------------------------------------------*/
 
 static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id)

commit 6534599d14892c5b0838b7170f071c850f5ea8e9
Author: Remy Bruno <remy.bruno@trinnov.com>
Date:   Fri Aug 31 12:21:08 2007 +0200

    [ALSA] hdspm - Fix autosync bug
    
    * better report of speed mode change failures
    * autosync_ref control bugfix (was reporting pref_sync_ref instead)
      (changed HDSPM_AES32_AUTOSYNC_FROM_NONE value to comply with array
      indexing in snd_hdspm_info_autosync_ref())
    * added support for master modes up to 192kHz (clock source control
      value was restricted up to 96kHz)
    
    Signed-off-by: Remy Bruno <remy.bruno@trinnov.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 30e0c4dc9484..f1bdda6cbcff 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -359,7 +359,7 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_AES32_AUTOSYNC_FROM_AES6 6
 #define HDSPM_AES32_AUTOSYNC_FROM_AES7 7
 #define HDSPM_AES32_AUTOSYNC_FROM_AES8 8
-#define HDSPM_AES32_AUTOSYNC_FROM_NONE -1
+#define HDSPM_AES32_AUTOSYNC_FROM_NONE 9
 
 /*  status2 */
 /* HDSPM_LockAES_bit is given by HDSPM_LockAES >> (AES# - 1) */
@@ -413,6 +413,13 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 /* revisions >= 230 indicate AES32 card */
 #define HDSPM_AESREVISION 230
 
+/* speed factor modes */
+#define HDSPM_SPEED_SINGLE 0
+#define HDSPM_SPEED_DOUBLE 1
+#define HDSPM_SPEED_QUAD   2
+/* names for speed modes */
+static char *hdspm_speed_names[] = { "single", "double", "quad" };
+
 struct hdspm_midi {
 	struct hdspm *hdspm;
 	int id;
@@ -831,7 +838,7 @@ static void hdspm_set_dds_value(struct hdspm *hdspm, int rate)
 		rate /= 2;
 
 	/* RME says n = 104857600000000, but in the windows MADI driver, I see:
-	   return 104857600000000 / rate; // 100 MHz
+//	return 104857600000000 / rate; // 100 MHz
 	return 110100480000000 / rate; // 105 MHz
         */	   
 	/* n = 104857600000000ULL; */ /*  =  2^20 * 10^8 */
@@ -845,11 +852,10 @@ static void hdspm_set_dds_value(struct hdspm *hdspm, int rate)
 /* dummy set rate lets see what happens */
 static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 {
-	int reject_if_open = 0;
 	int current_rate;
 	int rate_bits;
 	int not_set = 0;
-	int is_single, is_double, is_quad;
+	int current_speed, target_speed;
 
 	/* ASSUMPTION: hdspm->lock is either set, or there is no need for
 	   it (e.g. during module initialization).
@@ -903,66 +909,60 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 	   changes in the read/write routines.  
 	 */
 
-	is_single = (current_rate <= 48000);
-	is_double = (current_rate > 48000 && current_rate <= 96000);
-	is_quad = (current_rate > 96000);
+	if (current_rate <= 48000)
+		current_speed = HDSPM_SPEED_SINGLE;
+	else if (current_rate <= 96000)
+		current_speed = HDSPM_SPEED_DOUBLE;
+	else
+		current_speed = HDSPM_SPEED_QUAD;
+
+	if (rate <= 48000)
+		target_speed = HDSPM_SPEED_SINGLE;
+	else if (rate <= 96000)
+		target_speed = HDSPM_SPEED_DOUBLE;
+	else
+		target_speed = HDSPM_SPEED_QUAD;
 
 	switch (rate) {
 	case 32000:
-		if (!is_single)
-			reject_if_open = 1;
 		rate_bits = HDSPM_Frequency32KHz;
 		break;
 	case 44100:
-		if (!is_single)
-			reject_if_open = 1;
 		rate_bits = HDSPM_Frequency44_1KHz;
 		break;
 	case 48000:
-		if (!is_single)
-			reject_if_open = 1;
 		rate_bits = HDSPM_Frequency48KHz;
 		break;
 	case 64000:
-		if (!is_double)
-			reject_if_open = 1;
 		rate_bits = HDSPM_Frequency64KHz;
 		break;
 	case 88200:
-		if (!is_double)
-			reject_if_open = 1;
 		rate_bits = HDSPM_Frequency88_2KHz;
 		break;
 	case 96000:
-		if (!is_double)
-			reject_if_open = 1;
 		rate_bits = HDSPM_Frequency96KHz;
 		break;
 	case 128000:
-		if (!is_quad)
-			reject_if_open = 1;
 		rate_bits = HDSPM_Frequency128KHz;
 		break;
 	case 176400:
-		if (!is_quad)
-			reject_if_open = 1;
 		rate_bits = HDSPM_Frequency176_4KHz;
 		break;
 	case 192000:
-		if (!is_quad)
-			reject_if_open = 1;
 		rate_bits = HDSPM_Frequency192KHz;
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	if (reject_if_open
+	if (current_speed != target_speed
 	    && (hdspm->capture_pid >= 0 || hdspm->playback_pid >= 0)) {
 		snd_printk
 		    (KERN_ERR "HDSPM: "
-		     "cannot change between single- and double-speed mode "
+		     "cannot change from %s speed to %s speed mode "
 		     "(capture PID = %d, playback PID = %d)\n",
+		     hdspm_speed_names[current_speed],
+		     hdspm_speed_names[target_speed],
 		     hdspm->capture_pid, hdspm->playback_pid);
 		return -EBUSY;
 	}
@@ -1603,8 +1603,8 @@ static int snd_hdspm_put_clock_source(struct snd_kcontrol *kcontrol,
 	val = ucontrol->value.enumerated.item[0];
 	if (val < 0)
 		val = 0;
-	if (val > 6)
-		val = 6;
+	if (val > 9)
+		val = 9;
 	spin_lock_irq(&hdspm->lock);
 	if (val != hdspm_clock_source(hdspm))
 		change = (hdspm_set_clock_source(hdspm, val) == 0) ? 1 : 0;
@@ -1853,7 +1853,7 @@ static int snd_hdspm_get_autosync_ref(struct snd_kcontrol *kcontrol,
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	ucontrol->value.enumerated.item[0] = hdspm_pref_sync_ref(hdspm);
+	ucontrol->value.enumerated.item[0] = hdspm_autosync_ref(hdspm);
 	return 0;
 }
 

commit ef5fa1a49fc3b5fe8e734f25fa61bc73ccba344e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jul 27 16:52:46 2007 +0200

    [ALSA] hdspm - Coding style fixes
    
    Fix codes to follow more to the standard kernel coding style.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 83ea4623e77c..30e0c4dc9484 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1,5 +1,4 @@
-/*   -*- linux-c -*-
- *
+/*
  *   ALSA driver for RME Hammerfall DSP MADI audio interface(s)
  *
  *      Copyright (c) 2003 Winfried Ritsch (IEM)
@@ -78,7 +77,8 @@ MODULE_PARM_DESC(enable_monitor,
 		 "Enable Analog Out on Channel 63/64 by default.");
 
 MODULE_AUTHOR
-      ("Winfried Ritsch <ritsch_AT_iem.at>, Paul Davis <paul@linuxaudiosystems.com>, "
+      ("Winfried Ritsch <ritsch_AT_iem.at>, "
+       "Paul Davis <paul@linuxaudiosystems.com>, "
        "Marcus Andersson, Thomas Charbonnel <thomas@undata.org>, "
        "Remy Bruno <remy.bruno@trinnov.com>");
 MODULE_DESCRIPTION("RME HDSPM");
@@ -161,7 +161,9 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
                                      0=off, 1=on  */ /* MADI ONLY */
 #define HDSPM_Dolby       (1<<11) /* Dolby = "NonAudio" ?? */ /* AES32 ONLY */
 
-#define HDSPM_InputSelect0 (1<<14) /* Input select 0= optical, 1=coax */ /* MADI ONLY*/
+#define HDSPM_InputSelect0 (1<<14) /* Input select 0= optical, 1=coax
+				    * -- MADI ONLY
+				    */
 #define HDSPM_InputSelect1 (1<<15) /* should be 0 */
 
 #define HDSPM_SyncRef0     (1<<16) /* 0=WOrd, 1=MADI */
@@ -189,11 +191,13 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 
 /* --- bit helper defines */
 #define HDSPM_LatencyMask    (HDSPM_Latency0|HDSPM_Latency1|HDSPM_Latency2)
-#define HDSPM_FrequencyMask  (HDSPM_Frequency0|HDSPM_Frequency1|HDSPM_DoubleSpeed|HDSPM_QuadSpeed)
+#define HDSPM_FrequencyMask  (HDSPM_Frequency0|HDSPM_Frequency1|\
+			      HDSPM_DoubleSpeed|HDSPM_QuadSpeed)
 #define HDSPM_InputMask      (HDSPM_InputSelect0|HDSPM_InputSelect1)
 #define HDSPM_InputOptical   0
 #define HDSPM_InputCoaxial   (HDSPM_InputSelect0)
-#define HDSPM_SyncRefMask    (HDSPM_SyncRef0|HDSPM_SyncRef1|HDSPM_SyncRef2|HDSPM_SyncRef3)
+#define HDSPM_SyncRefMask    (HDSPM_SyncRef0|HDSPM_SyncRef1|\
+			      HDSPM_SyncRef2|HDSPM_SyncRef3)
 #define HDSPM_SyncRef_Word   0
 #define HDSPM_SyncRef_MADI   (HDSPM_SyncRef0)
 
@@ -205,10 +209,12 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_Frequency48KHz   (HDSPM_Frequency1|HDSPM_Frequency0)
 #define HDSPM_Frequency64KHz   (HDSPM_DoubleSpeed|HDSPM_Frequency0)
 #define HDSPM_Frequency88_2KHz (HDSPM_DoubleSpeed|HDSPM_Frequency1)
-#define HDSPM_Frequency96KHz   (HDSPM_DoubleSpeed|HDSPM_Frequency1|HDSPM_Frequency0)
+#define HDSPM_Frequency96KHz   (HDSPM_DoubleSpeed|HDSPM_Frequency1|\
+				HDSPM_Frequency0)
 #define HDSPM_Frequency128KHz   (HDSPM_QuadSpeed|HDSPM_Frequency0)
 #define HDSPM_Frequency176_4KHz   (HDSPM_QuadSpeed|HDSPM_Frequency1)
-#define HDSPM_Frequency192KHz   (HDSPM_QuadSpeed|HDSPM_Frequency1|HDSPM_Frequency0)
+#define HDSPM_Frequency192KHz   (HDSPM_QuadSpeed|HDSPM_Frequency1|\
+				 HDSPM_Frequency0)
 
 /* --- for internal discrimination */
 #define HDSPM_CLOCK_SOURCE_AUTOSYNC          0	/* Sample Clock Sources */
@@ -256,10 +262,14 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_RD_MULTIPLE     (1<<10)
 
 /* --- Status Register bits --- */ /* MADI ONLY */ /* Bits defined here and
-     that do not conflict with specific bits for AES32 seem to be valid also for the AES32 */
+     that do not conflict with specific bits for AES32 seem to be valid also
+     for the AES32
+ */
 #define HDSPM_audioIRQPending    (1<<0)	/* IRQ is high and pending */
-#define HDSPM_RX_64ch            (1<<1)	/* Input 64chan. MODE=1, 56chn. MODE=0 */
-#define HDSPM_AB_int             (1<<2)	/* InputChannel Opt=0, Coax=1 (like inp0) */
+#define HDSPM_RX_64ch            (1<<1)	/* Input 64chan. MODE=1, 56chn MODE=0 */
+#define HDSPM_AB_int             (1<<2)	/* InputChannel Opt=0, Coax=1
+					 * (like inp0)
+					 */
 #define HDSPM_madiLock           (1<<3)	/* MADI Locked =1, no=0 */
 
 #define HDSPM_BufferPositionMask 0x000FFC0 /* Bit 6..15 : h/w buffer pointer */
@@ -274,12 +284,15 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_madiFreq2         (1<<24)	/* 4=64, 5=88.2 6=96 */
 #define HDSPM_madiFreq3         (1<<25)	/* 7=128, 8=176.4 9=192 */
 
-#define HDSPM_BufferID          (1<<26)	/* (Double)Buffer ID toggles with Interrupt */
+#define HDSPM_BufferID          (1<<26)	/* (Double)Buffer ID toggles with
+					 * Interrupt
+					 */
 #define HDSPM_midi0IRQPending   (1<<30)	/* MIDI IRQ is pending  */
 #define HDSPM_midi1IRQPending   (1<<31)	/* and aktiv */
 
 /* --- status bit helpers */
-#define HDSPM_madiFreqMask  (HDSPM_madiFreq0|HDSPM_madiFreq1|HDSPM_madiFreq2|HDSPM_madiFreq3)
+#define HDSPM_madiFreqMask  (HDSPM_madiFreq0|HDSPM_madiFreq1|\
+			     HDSPM_madiFreq2|HDSPM_madiFreq3)
 #define HDSPM_madiFreq32    (HDSPM_madiFreq0)
 #define HDSPM_madiFreq44_1  (HDSPM_madiFreq1)
 #define HDSPM_madiFreq48    (HDSPM_madiFreq0|HDSPM_madiFreq1)
@@ -319,10 +332,12 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_wcFreq96    (HDSPM_wc_freq1|HDSPM_wc_freq2)
 
 
-#define HDSPM_SelSyncRefMask       (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1|HDSPM_SelSyncRef2)
+#define HDSPM_SelSyncRefMask       (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1|\
+				    HDSPM_SelSyncRef2)
 #define HDSPM_SelSyncRef_WORD      0
 #define HDSPM_SelSyncRef_MADI      (HDSPM_SelSyncRef0)
-#define HDSPM_SelSyncRef_NVALID    (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1|HDSPM_SelSyncRef2)
+#define HDSPM_SelSyncRef_NVALID    (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1|\
+				    HDSPM_SelSyncRef2)
 
 /*
    For AES32, bits for status, status2 and timecode are different
@@ -412,8 +427,9 @@ struct hdspm_midi {
 
 struct hdspm {
         spinlock_t lock;
-        struct snd_pcm_substream *capture_substream;	 /* only one playback */
-        struct snd_pcm_substream *playback_substream; /* and/or capture stream */
+	/* only one playback and/or capture stream */
+        struct snd_pcm_substream *capture_substream;
+        struct snd_pcm_substream *playback_substream;
 
 	char *card_name;	     /* for procinfo */
 	unsigned short firmware_rev; /* dont know if relevant (yes if AES32)*/
@@ -460,9 +476,12 @@ struct hdspm {
 	struct pci_dev *pci;	/* and an pci info */
 
 	/* Mixer vars */
-	struct snd_kcontrol *playback_mixer_ctls[HDSPM_MAX_CHANNELS];	/* fast alsa mixer */
-	struct snd_kcontrol *input_mixer_ctls[HDSPM_MAX_CHANNELS];	/* but input to much, so not used */
-	struct hdspm_mixer *mixer;	/* full mixer accessable over mixer ioctl or hwdep-device */
+	/* fast alsa mixer */
+	struct snd_kcontrol *playback_mixer_ctls[HDSPM_MAX_CHANNELS];
+	/* but input to much, so not used */
+	struct snd_kcontrol *input_mixer_ctls[HDSPM_MAX_CHANNELS];
+	/* full mixer accessable over mixer ioctl or hwdep-device */
+	struct hdspm_mixer *mixer;
 
 };
 
@@ -616,13 +635,15 @@ static inline int hdspm_external_sample_rate(struct hdspm * hdspm)
 	if (hdspm->is_aes32) {
 		unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
 		unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
-		unsigned int timecode = hdspm_read(hdspm, HDSPM_timecodeRegister);
+		unsigned int timecode =
+			hdspm_read(hdspm, HDSPM_timecodeRegister);
 
 		int syncref = hdspm_autosync_ref(hdspm);
 
 		if (syncref == HDSPM_AES32_AUTOSYNC_FROM_WORD &&
 				status & HDSPM_AES32_wcLock)
-			return HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit) & 0xF);
+			return HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit)
+					      & 0xF);
 		if (syncref >= HDSPM_AES32_AUTOSYNC_FROM_AES1 &&
 			syncref <= HDSPM_AES32_AUTOSYNC_FROM_AES8 &&
 			status2 & (HDSPM_LockAES >>
@@ -668,7 +689,9 @@ static inline int hdspm_external_sample_rate(struct hdspm * hdspm)
 			}
 		}
 
-		/* if rate detected and Syncref is Word than have it, word has priority to MADI */
+		/* if rate detected and Syncref is Word than have it,
+		 * word has priority to MADI
+		 */
 		if (rate != 0 &&
 	            (status2 & HDSPM_SelSyncRefMask) == HDSPM_SelSyncRef_WORD)
 			return rate;
@@ -727,12 +750,12 @@ static snd_pcm_uframes_t hdspm_hw_pointer(struct hdspm * hdspm)
 
 	position = hdspm_read(hdspm, HDSPM_statusRegister);
 
-	if (!hdspm->precise_ptr) {
-		return (position & HDSPM_BufferID) ? (hdspm->period_bytes /
-						      4) : 0;
-	}
+	if (!hdspm->precise_ptr)
+		return (position & HDSPM_BufferID) ?
+			(hdspm->period_bytes / 4) : 0;
 
-	/* hwpointer comes in bytes and is 64Bytes accurate (by docu since PCI Burst)
+	/* hwpointer comes in bytes and is 64Bytes accurate (by docu since
+	   PCI Burst)
 	   i have experimented that it is at most 64 Byte to much for playing 
 	   so substraction of 64 byte should be ok for ALSA, but use it only
 	   for application where you know what you do since if you come to
@@ -808,10 +831,10 @@ static void hdspm_set_dds_value(struct hdspm *hdspm, int rate)
 		rate /= 2;
 
 	/* RME says n = 104857600000000, but in the windows MADI driver, I see:
-//	return 104857600000000 / rate; // 100 MHz
+	   return 104857600000000 / rate; // 100 MHz
 	return 110100480000000 / rate; // 105 MHz
         */	   
-	//n = 104857600000000ULL;  /*  =  2^20 * 10^8 */
+	/* n = 104857600000000ULL; */ /*  =  2^20 * 10^8 */
 	n = 110100480000000ULL;    /* Value checked for AES32 and MADI */
 	div64_32(&n, rate, &r);
 	/* n should be less than 2^32 for being written to FREQ register */
@@ -841,8 +864,9 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 	             just make a warning an remember setting 
 		     for future master mode switching */
     
-			snd_printk
-			    (KERN_WARNING "HDSPM: Warning: device is not running as a clock master.\n");
+			snd_printk(KERN_WARNING "HDSPM: "
+				   "Warning: device is not running "
+				   "as a clock master.\n");
 			not_set = 1;
 		} else {
 
@@ -850,16 +874,18 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 			int external_freq =
 			    hdspm_external_sample_rate(hdspm);
 
-			if ((hdspm_autosync_ref(hdspm) ==
-			     HDSPM_AUTOSYNC_FROM_NONE)) {
+			if (hdspm_autosync_ref(hdspm) ==
+			    HDSPM_AUTOSYNC_FROM_NONE) {
 
-				snd_printk(KERN_WARNING "HDSPM: Detected no Externel Sync \n");
+				snd_printk(KERN_WARNING "HDSPM: "
+					   "Detected no Externel Sync \n");
 				not_set = 1;
 
 			} else if (rate != external_freq) {
 
-				snd_printk
-				    (KERN_WARNING "HDSPM: Warning: No AutoSync source for requested rate\n");
+				snd_printk(KERN_WARNING "HDSPM: "
+					   "Warning: No AutoSync source for "
+					   "requested rate\n");
 				not_set = 1;
 			}
 		}
@@ -934,7 +960,9 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 	if (reject_if_open
 	    && (hdspm->capture_pid >= 0 || hdspm->playback_pid >= 0)) {
 		snd_printk
-		    (KERN_ERR "HDSPM: cannot change between single- and double-speed mode (capture PID = %d, playback PID = %d)\n",
+		    (KERN_ERR "HDSPM: "
+		     "cannot change between single- and double-speed mode "
+		     "(capture PID = %d, playback PID = %d)\n",
 		     hdspm->capture_pid, hdspm->playback_pid);
 		return -EBUSY;
 	}
@@ -966,8 +994,14 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 static void all_in_all_mixer(struct hdspm * hdspm, int sgain)
 {
 	int i, j;
-	unsigned int gain =
-	    (sgain > UNITY_GAIN) ? UNITY_GAIN : (sgain < 0) ? 0 : sgain;
+	unsigned int gain;
+
+	if (sgain > UNITY_GAIN)
+		gain = UNITY_GAIN;
+	else if (sgain < 0)
+		gain = 0;
+	else
+		gain = sgain;
 
 	for (i = 0; i < HDSPM_MIXER_CHANNELS; i++)
 		for (j = 0; j < HDSPM_MIXER_CHANNELS; j++) {
@@ -980,7 +1014,8 @@ static void all_in_all_mixer(struct hdspm * hdspm, int sgain)
    MIDI
   ----------------------------------------------------------------------------*/
 
-static inline unsigned char snd_hdspm_midi_read_byte (struct hdspm *hdspm, int id)
+static inline unsigned char snd_hdspm_midi_read_byte (struct hdspm *hdspm,
+						      int id)
 {
 	/* the hardware already does the relevant bit-mask with 0xff */
 	if (id)
@@ -989,7 +1024,8 @@ static inline unsigned char snd_hdspm_midi_read_byte (struct hdspm *hdspm, int i
 		return hdspm_read(hdspm, HDSPM_midiDataIn0);
 }
 
-static inline void snd_hdspm_midi_write_byte (struct hdspm *hdspm, int id, int val)
+static inline void snd_hdspm_midi_write_byte (struct hdspm *hdspm, int id,
+					      int val)
 {
 	/* the hardware already does the relevant bit-mask with 0xff */
 	if (id)
@@ -1011,9 +1047,10 @@ static inline int snd_hdspm_midi_output_possible (struct hdspm *hdspm, int id)
 	int fifo_bytes_used;
 
 	if (id)
-		fifo_bytes_used = hdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xff;
+		fifo_bytes_used = hdspm_read(hdspm, HDSPM_midiStatusOut1);
 	else
-		fifo_bytes_used = hdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xff;
+		fifo_bytes_used = hdspm_read(hdspm, HDSPM_midiStatusOut0);
+	fifo_bytes_used &= 0xff;
 
 	if (fifo_bytes_used < 128)
 		return  128 - fifo_bytes_used;
@@ -1038,16 +1075,21 @@ static int snd_hdspm_midi_output_write (struct hdspm_midi *hmidi)
 	/* Output is not interrupt driven */
 		
 	spin_lock_irqsave (&hmidi->lock, flags);
-	if (hmidi->output) {
-		if (!snd_rawmidi_transmit_empty (hmidi->output)) {
-			if ((n_pending = snd_hdspm_midi_output_possible (hmidi->hdspm, hmidi->id)) > 0) {
-				if (n_pending > (int)sizeof (buf))
-					n_pending = sizeof (buf);
-				
-				if ((to_write = snd_rawmidi_transmit (hmidi->output, buf, n_pending)) > 0) {
-					for (i = 0; i < to_write; ++i) 
-						snd_hdspm_midi_write_byte (hmidi->hdspm, hmidi->id, buf[i]);
-				}
+	if (hmidi->output &&
+	    !snd_rawmidi_transmit_empty (hmidi->output)) {
+		n_pending = snd_hdspm_midi_output_possible (hmidi->hdspm,
+							    hmidi->id);
+		if (n_pending > 0) {
+			if (n_pending > (int)sizeof (buf))
+				n_pending = sizeof (buf);
+		
+			to_write = snd_rawmidi_transmit (hmidi->output, buf,
+							 n_pending);
+			if (to_write > 0) {
+				for (i = 0; i < to_write; ++i) 
+					snd_hdspm_midi_write_byte (hmidi->hdspm,
+								   hmidi->id,
+								   buf[i]);
 			}
 		}
 	}
@@ -1057,51 +1099,55 @@ static int snd_hdspm_midi_output_write (struct hdspm_midi *hmidi)
 
 static int snd_hdspm_midi_input_read (struct hdspm_midi *hmidi)
 {
-	unsigned char buf[128]; /* this buffer is designed to match the MIDI input FIFO size */
+	unsigned char buf[128]; /* this buffer is designed to match the MIDI
+				 * input FIFO size
+				 */
 	unsigned long flags;
 	int n_pending;
 	int i;
 
 	spin_lock_irqsave (&hmidi->lock, flags);
-	if ((n_pending = snd_hdspm_midi_input_available (hmidi->hdspm, hmidi->id)) > 0) {
+	n_pending = snd_hdspm_midi_input_available (hmidi->hdspm, hmidi->id);
+	if (n_pending > 0) {
 		if (hmidi->input) {
-			if (n_pending > (int)sizeof (buf)) {
+			if (n_pending > (int)sizeof (buf))
 				n_pending = sizeof (buf);
-			}
-			for (i = 0; i < n_pending; ++i) {
-				buf[i] = snd_hdspm_midi_read_byte (hmidi->hdspm, hmidi->id);
-			}
-			if (n_pending) {
-				snd_rawmidi_receive (hmidi->input, buf, n_pending);
-			}
+			for (i = 0; i < n_pending; ++i)
+				buf[i] = snd_hdspm_midi_read_byte (hmidi->hdspm,
+								   hmidi->id);
+			if (n_pending)
+				snd_rawmidi_receive (hmidi->input, buf,
+						     n_pending);
 		} else {
 			/* flush the MIDI input FIFO */
-			while (n_pending--) {
-				snd_hdspm_midi_read_byte (hmidi->hdspm, hmidi->id);
-			}
+			while (n_pending--)
+				snd_hdspm_midi_read_byte (hmidi->hdspm,
+							  hmidi->id);
 		}
 	}
 	hmidi->pending = 0;
-	if (hmidi->id) {
+	if (hmidi->id)
 		hmidi->hdspm->control_register |= HDSPM_Midi1InterruptEnable;
-	} else {
+	else
 		hmidi->hdspm->control_register |= HDSPM_Midi0InterruptEnable;
-	}
-	hdspm_write(hmidi->hdspm, HDSPM_controlRegister, hmidi->hdspm->control_register);
+	hdspm_write(hmidi->hdspm, HDSPM_controlRegister,
+		    hmidi->hdspm->control_register);
 	spin_unlock_irqrestore (&hmidi->lock, flags);
 	return snd_hdspm_midi_output_write (hmidi);
 }
 
-static void snd_hdspm_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)
+static void
+snd_hdspm_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)
 {
 	struct hdspm *hdspm;
 	struct hdspm_midi *hmidi;
 	unsigned long flags;
 	u32 ie;
 
-	hmidi = (struct hdspm_midi *) substream->rmidi->private_data;
+	hmidi = substream->rmidi->private_data;
 	hdspm = hmidi->hdspm;
-	ie = hmidi->id ? HDSPM_Midi1InterruptEnable : HDSPM_Midi0InterruptEnable;
+	ie = hmidi->id ?
+		HDSPM_Midi1InterruptEnable : HDSPM_Midi0InterruptEnable;
 	spin_lock_irqsave (&hdspm->lock, flags);
 	if (up) {
 		if (!(hdspm->control_register & ie)) {
@@ -1138,12 +1184,13 @@ static void snd_hdspm_midi_output_timer(unsigned long data)
 	spin_unlock_irqrestore (&hmidi->lock, flags);
 }
 
-static void snd_hdspm_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)
+static void
+snd_hdspm_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)
 {
 	struct hdspm_midi *hmidi;
 	unsigned long flags;
 
-	hmidi = (struct hdspm_midi *) substream->rmidi->private_data;
+	hmidi = substream->rmidi->private_data;
 	spin_lock_irqsave (&hmidi->lock, flags);
 	if (up) {
 		if (!hmidi->istimer) {
@@ -1155,9 +1202,8 @@ static void snd_hdspm_midi_output_trigger(struct snd_rawmidi_substream *substrea
 			hmidi->istimer++;
 		}
 	} else {
-		if (hmidi->istimer && --hmidi->istimer <= 0) {
+		if (hmidi->istimer && --hmidi->istimer <= 0)
 			del_timer (&hmidi->timer);
-		}
 	}
 	spin_unlock_irqrestore (&hmidi->lock, flags);
 	if (up)
@@ -1168,7 +1214,7 @@ static int snd_hdspm_midi_input_open(struct snd_rawmidi_substream *substream)
 {
 	struct hdspm_midi *hmidi;
 
-	hmidi = (struct hdspm_midi *) substream->rmidi->private_data;
+	hmidi = substream->rmidi->private_data;
 	spin_lock_irq (&hmidi->lock);
 	snd_hdspm_flush_midi_input (hmidi->hdspm, hmidi->id);
 	hmidi->input = substream;
@@ -1181,7 +1227,7 @@ static int snd_hdspm_midi_output_open(struct snd_rawmidi_substream *substream)
 {
 	struct hdspm_midi *hmidi;
 
-	hmidi = (struct hdspm_midi *) substream->rmidi->private_data;
+	hmidi = substream->rmidi->private_data;
 	spin_lock_irq (&hmidi->lock);
 	hmidi->output = substream;
 	spin_unlock_irq (&hmidi->lock);
@@ -1195,7 +1241,7 @@ static int snd_hdspm_midi_input_close(struct snd_rawmidi_substream *substream)
 
 	snd_hdspm_midi_input_trigger (substream, 0);
 
-	hmidi = (struct hdspm_midi *) substream->rmidi->private_data;
+	hmidi = substream->rmidi->private_data;
 	spin_lock_irq (&hmidi->lock);
 	hmidi->input = NULL;
 	spin_unlock_irq (&hmidi->lock);
@@ -1209,7 +1255,7 @@ static int snd_hdspm_midi_output_close(struct snd_rawmidi_substream *substream)
 
 	snd_hdspm_midi_output_trigger (substream, 0);
 
-	hmidi = (struct hdspm_midi *) substream->rmidi->private_data;
+	hmidi = substream->rmidi->private_data;
 	spin_lock_irq (&hmidi->lock);
 	hmidi->output = NULL;
 	spin_unlock_irq (&hmidi->lock);
@@ -1231,29 +1277,28 @@ static struct snd_rawmidi_ops snd_hdspm_midi_input =
 	.trigger =	snd_hdspm_midi_input_trigger,
 };
 
-static int __devinit snd_hdspm_create_midi (struct snd_card *card, struct hdspm *hdspm, int id)
+static int __devinit snd_hdspm_create_midi (struct snd_card *card,
+					    struct hdspm *hdspm, int id)
 {
 	int err;
 	char buf[32];
 
 	hdspm->midi[id].id = id;
-	hdspm->midi[id].rmidi = NULL;
-	hdspm->midi[id].input = NULL;
-	hdspm->midi[id].output = NULL;
 	hdspm->midi[id].hdspm = hdspm;
-	hdspm->midi[id].istimer = 0;
-	hdspm->midi[id].pending = 0;
 	spin_lock_init (&hdspm->midi[id].lock);
 
 	sprintf (buf, "%s MIDI %d", card->shortname, id+1);
-	if ((err = snd_rawmidi_new (card, buf, id, 1, 1, &hdspm->midi[id].rmidi)) < 0)
+	err = snd_rawmidi_new (card, buf, id, 1, 1, &hdspm->midi[id].rmidi);
+	if (err < 0)
 		return err;
 
 	sprintf (hdspm->midi[id].rmidi->name, "%s MIDI %d", card->id, id+1);
 	hdspm->midi[id].rmidi->private_data = &hdspm->midi[id];
 
-	snd_rawmidi_set_ops (hdspm->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_hdspm_midi_output);
-	snd_rawmidi_set_ops (hdspm->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_hdspm_midi_input);
+	snd_rawmidi_set_ops(hdspm->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,
+			    &snd_hdspm_midi_output);
+	snd_rawmidi_set_ops(hdspm->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_INPUT,
+			    &snd_hdspm_midi_input);
 
 	hdspm->midi[id].rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |
 		SNDRV_RAWMIDI_INFO_INPUT |
@@ -1637,7 +1682,8 @@ static int hdspm_set_pref_sync_ref(struct hdspm * hdspm, int pref)
 		       hdspm->control_register |= HDSPM_SyncRef2+HDSPM_SyncRef1;
 		       break;
 		case 7:
-		       hdspm->control_register |= HDSPM_SyncRef2+HDSPM_SyncRef1+HDSPM_SyncRef0;
+		       hdspm->control_register |=
+			       HDSPM_SyncRef2+HDSPM_SyncRef1+HDSPM_SyncRef0;
 		       break;
 		case 8:
 		       hdspm->control_register |= HDSPM_SyncRef3;
@@ -1675,7 +1721,8 @@ static int snd_hdspm_info_pref_sync_ref(struct snd_kcontrol *kcontrol,
 
 		uinfo->value.enumerated.items = 9;
 
-		if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		if (uinfo->value.enumerated.item >=
+		    uinfo->value.enumerated.items)
 			uinfo->value.enumerated.item =
 				uinfo->value.enumerated.items - 1;
 		strcpy(uinfo->value.enumerated.name,
@@ -1688,7 +1735,8 @@ static int snd_hdspm_info_pref_sync_ref(struct snd_kcontrol *kcontrol,
 
 		uinfo->value.enumerated.items = 2;
 
-		if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		if (uinfo->value.enumerated.item >=
+		    uinfo->value.enumerated.items)
 			uinfo->value.enumerated.item =
 				uinfo->value.enumerated.items - 1;
 		strcpy(uinfo->value.enumerated.name,
@@ -1740,7 +1788,8 @@ static int hdspm_autosync_ref(struct hdspm * hdspm)
 {
 	if (hdspm->is_aes32) {
 		unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
-		unsigned int syncref = (status >> HDSPM_AES32_syncref_bit) & 0xF;
+		unsigned int syncref = (status >> HDSPM_AES32_syncref_bit) &
+			0xF;
 		if (syncref == 0)
 			return HDSPM_AES32_AUTOSYNC_FROM_WORD;
 		if (syncref <= 8)
@@ -1777,20 +1826,20 @@ static int snd_hdspm_info_autosync_ref(struct snd_kcontrol *kcontrol,
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 		uinfo->count = 1;
 		uinfo->value.enumerated.items = 10;
-		if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		if (uinfo->value.enumerated.item >=
+		    uinfo->value.enumerated.items)
 			uinfo->value.enumerated.item =
 				uinfo->value.enumerated.items - 1;
 		strcpy(uinfo->value.enumerated.name,
 				texts[uinfo->value.enumerated.item]);
-	}
-	else
-	{
+	} else {
 		static char *texts[] = { "WordClock", "MADI", "None" };
 
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 		uinfo->count = 1;
 		uinfo->value.enumerated.items = 3;
-		if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		if (uinfo->value.enumerated.item >=
+		    uinfo->value.enumerated.items)
 			uinfo->value.enumerated.item =
 				uinfo->value.enumerated.items - 1;
 		strcpy(uinfo->value.enumerated.name,
@@ -2416,7 +2465,7 @@ static int snd_hdspm_put_qs_wire(struct snd_kcontrol *kcontrol,
 	if (val > 2)
 		val = 2;
 	spin_lock_irq(&hdspm->lock);
-	change = (int) val != hdspm_qs_wire(hdspm);
+	change = val != hdspm_qs_wire(hdspm);
 	hdspm_set_qs_wire(hdspm, val);
 	spin_unlock_irq(&hdspm->lock);
 	return change;
@@ -2517,8 +2566,8 @@ static int snd_hdspm_put_mixer(struct snd_kcontrol *kcontrol,
 						    source -
 						    HDSPM_MAX_CHANNELS);
 	else
-		change =
-		    gain != hdspm_read_in_gain(hdspm, destination, source);
+		change = gain != hdspm_read_in_gain(hdspm, destination,
+						    source);
 
 	if (change) {
 		if (source >= HDSPM_MAX_CHANNELS)
@@ -2571,7 +2620,8 @@ static int snd_hdspm_get_playback_mixer(struct snd_kcontrol *kcontrol,
 	snd_assert(channel >= 0
 		   || channel < HDSPM_MAX_CHANNELS, return -EINVAL);
 
-	if ((mapped_channel = hdspm->channel_map[channel]) < 0)
+	mapped_channel = hdspm->channel_map[channel];
+	if (mapped_channel < 0)
 		return -EINVAL;
 
 	spin_lock_irq(&hdspm->lock);
@@ -2579,10 +2629,12 @@ static int snd_hdspm_get_playback_mixer(struct snd_kcontrol *kcontrol,
 	    hdspm_read_pb_gain(hdspm, mapped_channel, mapped_channel);
 	spin_unlock_irq(&hdspm->lock);
 
-	/*    snd_printdd("get pb mixer index %d, channel %d, mapped_channel %d, value %d\n",
-	   ucontrol->id.index,        channel, mapped_channel,  ucontrol->value.integer.value[0]); 
-	 */
-
+	/*
+	snd_printdd("get pb mixer index %d, channel %d, mapped_channel %d, "
+		    "value %d\n",
+		    ucontrol->id.index, channel, mapped_channel,
+		    ucontrol->value.integer.value[0]); 
+	*/
 	return 0;
 }
 
@@ -2603,7 +2655,8 @@ static int snd_hdspm_put_playback_mixer(struct snd_kcontrol *kcontrol,
 	snd_assert(channel >= 0
 		   || channel < HDSPM_MAX_CHANNELS, return -EINVAL);
 
-	if ((mapped_channel = hdspm->channel_map[channel]) < 0)
+	mapped_channel = hdspm->channel_map[channel];
+	if (mapped_channel < 0)
 		return -EINVAL;
 
 	gain = ucontrol->value.integer.value[0];
@@ -2853,28 +2906,26 @@ static int snd_hdspm_create_controls(struct snd_card *card, struct hdspm * hdspm
 	}
 
 	/* Channel playback mixer as default control 
-Note: the whole matrix would be 128*HDSPM_MIXER_CHANNELS Faders, thats too big for any alsamixer
-they are accesible via special IOCTL on hwdep
-and the mixer 2dimensional mixer control */
+	   Note: the whole matrix would be 128*HDSPM_MIXER_CHANNELS Faders,
+	   thats too * big for any alsamixer they are accesible via special
+	   IOCTL on hwdep and the mixer 2dimensional mixer control
+	*/
 
 	snd_hdspm_playback_mixer.name = "Chn";
 	limit = HDSPM_MAX_CHANNELS;
 
-	/* The index values are one greater than the channel ID so that alsamixer
-	   will display them correctly. We want to use the index for fast lookup
-	   of the relevant channel, but if we use it at all, most ALSA software
-	   does the wrong thing with it ...
+	/* The index values are one greater than the channel ID so that
+	 * alsamixer will display them correctly. We want to use the index
+	 * for fast lookup of the relevant channel, but if we use it at all,
+	 * most ALSA software does the wrong thing with it ...
 	 */
 
 	for (idx = 0; idx < limit; ++idx) {
 		snd_hdspm_playback_mixer.index = idx + 1;
-		if ((err = snd_ctl_add(card,
-				       kctl =
-				       snd_ctl_new1
-				       (&snd_hdspm_playback_mixer,
-					hdspm)))) {
+		kctl = snd_ctl_new1(&snd_hdspm_playback_mixer, hdspm);
+		err = snd_ctl_add(card, kctl);
+		if (err < 0)
 			return err;
-		}
 		hdspm->playback_mixer_ctls[idx] = kctl;
 	}
 
@@ -2889,7 +2940,7 @@ static void
 snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 			 struct snd_info_buffer *buffer)
 {
-	struct hdspm *hdspm = (struct hdspm *) entry->private_data;
+	struct hdspm *hdspm = entry->private_data;
 	unsigned int status;
 	unsigned int status2;
 	char *pref_sync_ref;
@@ -2922,14 +2973,14 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 		    (status & HDSPM_midi1IRQPending) ? 1 : 0,
 		    hdspm->irq_count);
 	snd_iprintf(buffer,
-		    "HW pointer: id = %d, rawptr = %d (%d->%d) estimated= %ld (bytes)\n",
+		    "HW pointer: id = %d, rawptr = %d (%d->%d) "
+		    "estimated= %ld (bytes)\n",
 		    ((status & HDSPM_BufferID) ? 1 : 0),
 		    (status & HDSPM_BufferPositionMask),
-		    (status & HDSPM_BufferPositionMask) % (2 *
-							   (int)hdspm->
-							   period_bytes),
-		    ((status & HDSPM_BufferPositionMask) -
-		     64) % (2 * (int)hdspm->period_bytes),
+		    (status & HDSPM_BufferPositionMask) %
+		    (2 * (int)hdspm->period_bytes),
+		    ((status & HDSPM_BufferPositionMask) - 64) %
+		    (2 * (int)hdspm->period_bytes),
 		    (long) hdspm_hw_pointer(hdspm) * 4);
 
 	snd_iprintf(buffer,
@@ -2939,24 +2990,22 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 		    hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,
 		    hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);
 	snd_iprintf(buffer,
-		    "Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, status2=0x%x\n",
+		    "Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, "
+		    "status2=0x%x\n",
 		    hdspm->control_register, hdspm->control2_register,
 		    status, status2);
 
 	snd_iprintf(buffer, "--- Settings ---\n");
 
-	x = 1 << (6 +
-		  hdspm_decode_latency(hdspm->
-				       control_register &
-				       HDSPM_LatencyMask));
+	x = 1 << (6 + hdspm_decode_latency(hdspm->control_register &
+					   HDSPM_LatencyMask));
 
 	snd_iprintf(buffer,
 		    "Size (Latency): %d samples (2 periods of %lu bytes)\n",
 		    x, (unsigned long) hdspm->period_bytes);
 
 	snd_iprintf(buffer, "Line out: %s,   Precise Pointer: %s\n",
-		    (hdspm->
-		     control_register & HDSPM_LineOut) ? "on " : "off",
+		    (hdspm->control_register & HDSPM_LineOut) ? "on " : "off",
 		    (hdspm->precise_ptr) ? "on" : "off");
 
 	switch (hdspm->control_register & HDSPM_InputMask) {
@@ -2984,7 +3033,8 @@ snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
 		    syncref);
 
 	snd_iprintf(buffer,
-		    "ClearTrackMarker = %s, Transmit in %s Channel Mode, Auto Input %s\n",
+		    "ClearTrackMarker = %s, Transmit in %s Channel Mode, "
+		    "Auto Input %s\n",
 		    (hdspm->
 		     control_register & HDSPM_clr_tms) ? "on" : "off",
 		    (hdspm->
@@ -3085,7 +3135,7 @@ static void
 snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
 			  struct snd_info_buffer *buffer)
 {
-	struct hdspm *hdspm = (struct hdspm *) entry->private_data;
+	struct hdspm *hdspm = entry->private_data;
 	unsigned int status;
 	unsigned int status2;
 	unsigned int timecode;
@@ -3115,14 +3165,14 @@ snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
 		    (status & HDSPM_midi1IRQPending) ? 1 : 0,
 		    hdspm->irq_count);
 	snd_iprintf(buffer,
-		    "HW pointer: id = %d, rawptr = %d (%d->%d) estimated= %ld (bytes)\n",
+		    "HW pointer: id = %d, rawptr = %d (%d->%d) "
+		    "estimated= %ld (bytes)\n",
 		    ((status & HDSPM_BufferID) ? 1 : 0),
 		    (status & HDSPM_BufferPositionMask),
-		    (status & HDSPM_BufferPositionMask) % (2 *
-							   (int)hdspm->
-							   period_bytes),
-		    ((status & HDSPM_BufferPositionMask) -
-		     64) % (2 * (int)hdspm->period_bytes),
+		    (status & HDSPM_BufferPositionMask) %
+		    (2 * (int)hdspm->period_bytes),
+		    ((status & HDSPM_BufferPositionMask) - 64) %
+		    (2 * (int)hdspm->period_bytes),
 		    (long) hdspm_hw_pointer(hdspm) * 4);
 
 	snd_iprintf(buffer,
@@ -3132,16 +3182,15 @@ snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
 		    hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,
 		    hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);
 	snd_iprintf(buffer,
-		    "Register: ctrl1=0x%x, status1=0x%x, status2=0x%x, timecode=0x%x\n",
+		    "Register: ctrl1=0x%x, status1=0x%x, status2=0x%x, "
+		    "timecode=0x%x\n",
 		    hdspm->control_register,
 		    status, status2, timecode);
 
 	snd_iprintf(buffer, "--- Settings ---\n");
 
-	x = 1 << (6 +
-		  hdspm_decode_latency(hdspm->
-				       control_register &
-				       HDSPM_LatencyMask));
+	x = 1 << (6 + hdspm_decode_latency(hdspm->control_register &
+					   HDSPM_LatencyMask));
 
 	snd_iprintf(buffer,
 		    "Size (Latency): %d samples (2 periods of %lu bytes)\n",
@@ -3224,14 +3273,15 @@ snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
 	snd_iprintf(buffer, "--- Status:\n");
 
 	snd_iprintf(buffer, "Word: %s  Frequency: %d\n",
-			(status & HDSPM_AES32_wcLock)? "Sync   " : "No Lock",
-			HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit) & 0xF));
+		    (status & HDSPM_AES32_wcLock)? "Sync   " : "No Lock",
+		    HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit) & 0xF));
 
 	for (x = 0; x < 8; x++) {
 		snd_iprintf(buffer, "AES%d: %s  Frequency: %d\n",
-				x+1,
-				(status2 & (HDSPM_LockAES >> x))? "Sync   ": "No Lock",
-				HDSPM_bit2freq((timecode >> (4*x)) & 0xF));
+			    x+1,
+			    (status2 & (HDSPM_LockAES >> x)) ?
+			    "Sync   ": "No Lock",
+			    HDSPM_bit2freq((timecode >> (4*x)) & 0xF));
 	}
 
 	switch (hdspm_autosync_ref(hdspm)) {
@@ -3257,12 +3307,11 @@ static void
 snd_hdspm_proc_read_debug(struct snd_info_entry * entry,
 			  struct snd_info_buffer *buffer)
 {
-	struct hdspm *hdspm = (struct hdspm *)entry->private_data;
+	struct hdspm *hdspm = entry->private_data;
 
 	int j,i;
 
-	for (i = 0; i < 256 /* 1024*64 */; i += j)
-	{
+	for (i = 0; i < 256 /* 1024*64 */; i += j) {
 		snd_iprintf(buffer, "0x%08X: ", i);
 		for (j = 0; j < 16; j += 4)
 			snd_iprintf(buffer, "%08X ", hdspm_read(hdspm, i + j));
@@ -3305,14 +3354,20 @@ static int snd_hdspm_set_defaults(struct hdspm * hdspm)
 	/* set defaults:       */
 
 	if (hdspm->is_aes32)
-		hdspm->control_register = HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
-			hdspm_encode_latency(7) |	/* latency maximum = 8192 samples */
+		hdspm->control_register =
+			HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
+			hdspm_encode_latency(7) | /* latency maximum =
+						   * 8192 samples
+						   */
 			HDSPM_SyncRef0 |	/* AES1 is syncclock */
 			HDSPM_LineOut |	/* Analog output in */
 			HDSPM_Professional;  /* Professional mode */
 	else
-		hdspm->control_register = HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
-			hdspm_encode_latency(7) |	/* latency maximum = 8192 samples */
+		hdspm->control_register =
+			HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
+			hdspm_encode_latency(7) | /* latency maximum =
+						   * 8192 samples
+						   */
 			HDSPM_InputCoaxial |	/* Input Coax not Optical */
 			HDSPM_SyncRef_MADI |	/* Madi is syncclock */
 			HDSPM_LineOut |	/* Analog output in */
@@ -3343,7 +3398,8 @@ static int snd_hdspm_set_defaults(struct hdspm * hdspm)
 
 	if (line_outs_monitor[hdspm->dev]) {
 
-		snd_printk(KERN_INFO "HDSPM: sending all playback streams to line outs.\n");
+		snd_printk(KERN_INFO "HDSPM: "
+			   "sending all playback streams to line outs.\n");
 
 		for (i = 0; i < HDSPM_MIXER_CHANNELS; i++) {
 			if (hdspm_write_pb_gain(hdspm, i, i, UNITY_GAIN))
@@ -3392,20 +3448,16 @@ static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id)
 	if (audio) {
 
 		if (hdspm->capture_substream)
-			snd_pcm_period_elapsed(hdspm->pcm->
-					       streams
-					       [SNDRV_PCM_STREAM_CAPTURE].
-					       substream);
+			snd_pcm_period_elapsed(hdspm->capture_substream);
 
 		if (hdspm->playback_substream)
-			snd_pcm_period_elapsed(hdspm->pcm->
-					       streams
-					       [SNDRV_PCM_STREAM_PLAYBACK].
-					       substream);
+			snd_pcm_period_elapsed(hdspm->playback_substream);
 	}
 
 	if (midi0 && midi0status) {
-		/* we disable interrupts for this input until processing is done */
+		/* we disable interrupts for this input until processing
+		 * is done
+		 */
 		hdspm->control_register &= ~HDSPM_Midi0InterruptEnable;
 		hdspm_write(hdspm, HDSPM_controlRegister,
 			    hdspm->control_register);
@@ -3413,7 +3465,9 @@ static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id)
 		schedule = 1;
 	}
 	if (midi1 && midi1status) {
-		/* we disable interrupts for this input until processing is done */
+		/* we disable interrupts for this input until processing
+		 * is done
+		 */
 		hdspm->control_register &= ~HDSPM_Midi1InterruptEnable;
 		hdspm_write(hdspm, HDSPM_controlRegister,
 			    hdspm->control_register);
@@ -3445,16 +3499,16 @@ static char *hdspm_channel_buffer_location(struct hdspm * hdspm,
 	snd_assert(channel >= 0
 		   || channel < HDSPM_MAX_CHANNELS, return NULL);
 
-	if ((mapped_channel = hdspm->channel_map[channel]) < 0)
+	mapped_channel = hdspm->channel_map[channel];
+	if (mapped_channel < 0)
 		return NULL;
 
-	if (stream == SNDRV_PCM_STREAM_CAPTURE) {
+	if (stream == SNDRV_PCM_STREAM_CAPTURE)
 		return hdspm->capture_buffer +
 		    mapped_channel * HDSPM_CHANNEL_BUFFER_BYTES;
-	} else {
+	else
 		return hdspm->playback_buffer +
 		    mapped_channel * HDSPM_CHANNEL_BUFFER_BYTES;
-	}
 }
 
 
@@ -3469,9 +3523,9 @@ static int snd_hdspm_playback_copy(struct snd_pcm_substream *substream,
 	snd_assert(pos + count <= HDSPM_CHANNEL_BUFFER_BYTES / 4,
 		   return -EINVAL);
 
-	channel_buf = hdspm_channel_buffer_location(hdspm,
-						    substream->pstr->
-						    stream, channel);
+	channel_buf =
+		hdspm_channel_buffer_location(hdspm, substream->pstr->stream,
+					      channel);
 
 	snd_assert(channel_buf != NULL, return -EIO);
 
@@ -3488,9 +3542,9 @@ static int snd_hdspm_capture_copy(struct snd_pcm_substream *substream,
 	snd_assert(pos + count <= HDSPM_CHANNEL_BUFFER_BYTES / 4,
 		   return -EINVAL);
 
-	channel_buf = hdspm_channel_buffer_location(hdspm,
-						    substream->pstr->
-						    stream, channel);
+	channel_buf =
+		hdspm_channel_buffer_location(hdspm, substream->pstr->stream,
+					      channel);
 	snd_assert(channel_buf != NULL, return -EIO);
 	return copy_to_user(dst, channel_buf + pos * 4, count * 4);
 }
@@ -3503,8 +3557,8 @@ static int snd_hdspm_hw_silence(struct snd_pcm_substream *substream,
 	char *channel_buf;
 
 	channel_buf =
-	    hdspm_channel_buffer_location(hdspm, substream->pstr->stream,
-					  channel);
+		hdspm_channel_buffer_location(hdspm, substream->pstr->stream,
+					      channel);
 	snd_assert(channel_buf != NULL, return -EIO);
 	memset(channel_buf + pos * 4, 0, count * 4);
 	return 0;
@@ -3560,7 +3614,7 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 		other_pid = hdspm->playback_pid;
 	}
 
-	if ((other_pid > 0) && (this_pid != other_pid)) {
+	if (other_pid > 0 && this_pid != other_pid) {
 
 		/* The other stream is open, and not by the same
 		   task as this one. Make sure that the parameters
@@ -3577,7 +3631,7 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 		if (params_period_size(params) != hdspm->period_bytes / 4) {
 			spin_unlock_irq(&hdspm->lock);
 			_snd_pcm_hw_param_setempty(params,
-						   SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+					   SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
 			return -EBUSY;
 		}
 
@@ -3588,7 +3642,8 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 	/* how to make sure that the rate matches an externally-set one ?   */
 
 	spin_lock_irq(&hdspm->lock);
-	if ((err = hdspm_set_rate(hdspm, params_rate(params), 0)) < 0) {
+	err = hdspm_set_rate(hdspm, params_rate(params), 0);
+	if (err < 0) {
 		spin_unlock_irq(&hdspm->lock);
 		_snd_pcm_hw_param_setempty(params,
 					   SNDRV_PCM_HW_PARAM_RATE);
@@ -3596,16 +3651,17 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 	}
 	spin_unlock_irq(&hdspm->lock);
 
-	if ((err =
-	     hdspm_set_interrupt_interval(hdspm,
-					  params_period_size(params))) <
-	    0) {
+	err = hdspm_set_interrupt_interval(hdspm,
+					   params_period_size(params));
+	if (err < 0) {
 		_snd_pcm_hw_param_setempty(params,
 					   SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
 		return err;
 	}
 
-	/* Memory allocation, takashi's method, dont know if we should spinlock  */
+	/* Memory allocation, takashi's method, dont know if we should
+	 * spinlock
+	 */
 	/* malloc all buffer even if not enabled to get sure */
 	/* Update for MADI rev 204: we need to allocate for all channels,
 	 * otherwise it doesn't work at 96kHz */
@@ -3690,7 +3746,8 @@ static int snd_hdspm_channel_info(struct snd_pcm_substream *substream,
 
 	snd_assert(info->channel < HDSPM_MAX_CHANNELS, return -EINVAL);
 
-	if ((mapped_channel = hdspm->channel_map[info->channel]) < 0)
+	mapped_channel = hdspm->channel_map[info->channel];
+	if (mapped_channel < 0)
 		return -EINVAL;
 
 	info->offset = mapped_channel * HDSPM_CHANNEL_BUFFER_BYTES;
@@ -3704,15 +3761,13 @@ static int snd_hdspm_ioctl(struct snd_pcm_substream *substream,
 {
 	switch (cmd) {
 	case SNDRV_PCM_IOCTL1_RESET:
-		{
-			return snd_hdspm_reset(substream);
-		}
+		return snd_hdspm_reset(substream);
 
 	case SNDRV_PCM_IOCTL1_CHANNEL_INFO:
-		{
-			struct snd_pcm_channel_info *info = arg;
-			return snd_hdspm_channel_info(substream, info);
-		}
+	{
+		struct snd_pcm_channel_info *info = arg;
+		return snd_hdspm_channel_info(substream, info);
+	}
 	default:
 		break;
 	}
@@ -3923,9 +3978,12 @@ static int snd_hdspm_hw_rule_channels(struct snd_pcm_hw_params *params,
 }
 
 
-static unsigned int hdspm_aes32_sample_rates[] = { 32000, 44100, 48000, 64000, 88200, 96000, 128000, 176400, 192000 };
+static unsigned int hdspm_aes32_sample_rates[] = {
+	32000, 44100, 48000, 64000, 88200, 96000, 128000, 176400, 192000
+};
 
-static struct snd_pcm_hw_constraint_list hdspm_hw_constraints_aes32_sample_rates = {
+static struct snd_pcm_hw_constraint_list
+hdspm_hw_constraints_aes32_sample_rates = {
 	.count = ARRAY_SIZE(hdspm_aes32_sample_rates),
 	.list = hdspm_aes32_sample_rates,
 	.mask = 0
@@ -4051,7 +4109,7 @@ static int snd_hdspm_hwdep_dummy_op(struct snd_hwdep * hw, struct file *file)
 static int snd_hdspm_hwdep_ioctl(struct snd_hwdep * hw, struct file *file,
 				 unsigned int cmd, unsigned long arg)
 {
-	struct hdspm *hdspm = (struct hdspm *) hw->private_data;
+	struct hdspm *hdspm = hw->private_data;
 	struct hdspm_mixer_ioctl mixer;
 	struct hdspm_config_info info;
 	struct hdspm_version hdspm_version;
@@ -4059,11 +4117,12 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep * hw, struct file *file,
 
 	switch (cmd) {
 
-		
 	case SNDRV_HDSPM_IOCTL_GET_PEAK_RMS:
 		if (copy_from_user(&rms, (void __user *)arg, sizeof(rms)))
 			return -EFAULT;
-		/* maybe there is a chance to memorymap in future so dont touch just copy */
+		/* maybe there is a chance to memorymap in future
+		 * so dont touch just copy
+		 */
 		if(copy_to_user_fromio((void __user *)rms.peak,
 				       hdspm->iobase+HDSPM_MADI_peakrmsbase,
 				       sizeof(struct hdspm_peak_rms)) != 0 )
@@ -4075,21 +4134,16 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep * hw, struct file *file,
 	case SNDRV_HDSPM_IOCTL_GET_CONFIG_INFO:
 
 		spin_lock_irq(&hdspm->lock);
-		info.pref_sync_ref =
-		    (unsigned char) hdspm_pref_sync_ref(hdspm);
-		info.wordclock_sync_check =
-		    (unsigned char) hdspm_wc_sync_check(hdspm);
+		info.pref_sync_ref = hdspm_pref_sync_ref(hdspm);
+		info.wordclock_sync_check = hdspm_wc_sync_check(hdspm);
 
 		info.system_sample_rate = hdspm->system_sample_rate;
 		info.autosync_sample_rate =
 		    hdspm_external_sample_rate(hdspm);
-		info.system_clock_mode =
-		    (unsigned char) hdspm_system_clock_mode(hdspm);
-		info.clock_source =
-		    (unsigned char) hdspm_clock_source(hdspm);
-		info.autosync_ref =
-		    (unsigned char) hdspm_autosync_ref(hdspm);
-		info.line_out = (unsigned char) hdspm_line_out(hdspm);
+		info.system_clock_mode = hdspm_system_clock_mode(hdspm);
+		info.clock_source = hdspm_clock_source(hdspm);
+		info.autosync_ref = hdspm_autosync_ref(hdspm);
+		info.line_out = hdspm_line_out(hdspm);
 		info.passthru = 0;
 		spin_unlock_irq(&hdspm->lock);
 		if (copy_to_user((void __user *) arg, &info, sizeof(info)))
@@ -4106,8 +4160,8 @@ static int snd_hdspm_hwdep_ioctl(struct snd_hwdep * hw, struct file *file,
 	case SNDRV_HDSPM_IOCTL_GET_MIXER:
 		if (copy_from_user(&mixer, (void __user *)arg, sizeof(mixer)))
 			return -EFAULT;
-		if (copy_to_user
-		    ((void __user *)mixer.mixer, hdspm->mixer, sizeof(struct hdspm_mixer)))
+		if (copy_to_user((void __user *)mixer.mixer, hdspm->mixer,
+				 sizeof(struct hdspm_mixer)))
 			return -EFAULT;
 		break;
 
@@ -4150,7 +4204,8 @@ static int __devinit snd_hdspm_create_hwdep(struct snd_card *card,
 	struct snd_hwdep *hw;
 	int err;
 
-	if ((err = snd_hwdep_new(card, "HDSPM hwdep", 0, &hw)) < 0)
+	err = snd_hwdep_new(card, "HDSPM hwdep", 0, &hw);
+	if (err < 0)
 		return err;
 
 	hdspm->hwdep = hw;
@@ -4176,15 +4231,15 @@ static int __devinit snd_hdspm_preallocate_memory(struct hdspm * hdspm)
 
 	pcm = hdspm->pcm;
 
-/*	wanted = HDSPM_DMA_AREA_BYTES + 4096;*/	/* dont know why, but it works */
 	wanted = HDSPM_DMA_AREA_BYTES;
 
-	if ((err =
+	err =
 	     snd_pcm_lib_preallocate_pages_for_all(pcm,
 	     					   SNDRV_DMA_TYPE_DEV_SG,
 						   snd_dma_pci_data(hdspm->pci),
 						   wanted,
-						   wanted)) < 0) {
+						   wanted);
+	if (err < 0) {
 		snd_printdd("Could not preallocate %zd Bytes\n", wanted);
 
 		return err;
@@ -4200,8 +4255,7 @@ static void hdspm_set_sgbuf(struct hdspm * hdspm, struct snd_sg_buf *sgbuf,
 	int i;
 	for (i = 0; i < (channels * 16); i++)
 		hdspm_write(hdspm, reg + 4 * i,
-			    snd_pcm_sgbuf_get_addr(sgbuf,
-						   (size_t) 4096 * i));
+			    snd_pcm_sgbuf_get_addr(sgbuf, (size_t) 4096 * i));
 }
 
 /* ------------- ALSA Devices ---------------------------- */
@@ -4211,7 +4265,8 @@ static int __devinit snd_hdspm_create_pcm(struct snd_card *card,
 	struct snd_pcm *pcm;
 	int err;
 
-	if ((err = snd_pcm_new(card, hdspm->card_name, 0, 1, 1, &pcm)) < 0)
+	err = snd_pcm_new(card, hdspm->card_name, 0, 1, 1, &pcm);
+	if (err < 0)
 		return err;
 
 	hdspm->pcm = pcm;
@@ -4225,7 +4280,8 @@ static int __devinit snd_hdspm_create_pcm(struct snd_card *card,
 
 	pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
 
-	if ((err = snd_hdspm_preallocate_memory(hdspm)) < 0)
+	err = snd_hdspm_preallocate_memory(hdspm);
+	if (err < 0)
 		return err;
 
 	return 0;
@@ -4243,19 +4299,24 @@ static int __devinit snd_hdspm_create_alsa_devices(struct snd_card *card,
 	int err;
 
 	snd_printdd("Create card...\n");
-	if ((err = snd_hdspm_create_pcm(card, hdspm)) < 0)
+	err = snd_hdspm_create_pcm(card, hdspm);
+	if (err < 0)
 		return err;
 
-	if ((err = snd_hdspm_create_midi(card, hdspm, 0)) < 0)
+	err = snd_hdspm_create_midi(card, hdspm, 0);
+	if (err < 0)
 		return err;
 
-	if ((err = snd_hdspm_create_midi(card, hdspm, 1)) < 0)
+	err = snd_hdspm_create_midi(card, hdspm, 1);
+	if (err < 0)
 		return err;
 
-	if ((err = snd_hdspm_create_controls(card, hdspm)) < 0)
+	err = snd_hdspm_create_controls(card, hdspm);
+	if (err < 0)
 		return err;
 
-	if ((err = snd_hdspm_create_hwdep(card, hdspm)) < 0)
+	err = snd_hdspm_create_hwdep(card, hdspm);
+	if (err < 0)
 		return err;
 
 	snd_printdd("proc init...\n");
@@ -4270,7 +4331,8 @@ static int __devinit snd_hdspm_create_alsa_devices(struct snd_card *card,
 	hdspm->playback_substream = NULL;
 
 	snd_printdd("Set defaults...\n");
-	if ((err = snd_hdspm_set_defaults(hdspm)) < 0)
+	err = snd_hdspm_set_defaults(hdspm);
+	if (err < 0)
 		return err;
 
 	snd_printdd("Update mixer controls...\n");
@@ -4278,7 +4340,8 @@ static int __devinit snd_hdspm_create_alsa_devices(struct snd_card *card,
 
 	snd_printdd("Initializeing complete ???\n");
 
-	if ((err = snd_card_register(card)) < 0) {
+	err = snd_card_register(card);
+	if (err < 0) {
 		snd_printk(KERN_ERR "HDSPM: error registering card\n");
 		return err;
 	}
@@ -4288,36 +4351,18 @@ static int __devinit snd_hdspm_create_alsa_devices(struct snd_card *card,
 	return 0;
 }
 
-static int __devinit snd_hdspm_create(struct snd_card *card, struct hdspm * hdspm,
+static int __devinit snd_hdspm_create(struct snd_card *card,
+				      struct hdspm *hdspm,
 				      int precise_ptr, int enable_monitor)
 {
 	struct pci_dev *pci = hdspm->pci;
 	int err;
-	int i;
-
 	unsigned long io_extent;
 
 	hdspm->irq = -1;
-	hdspm->irq_count = 0;
-
-	hdspm->midi[0].rmidi = NULL;
-	hdspm->midi[1].rmidi = NULL;
-	hdspm->midi[0].input = NULL;
-	hdspm->midi[1].input = NULL;
-	hdspm->midi[0].output = NULL;
-	hdspm->midi[1].output = NULL;
+
 	spin_lock_init(&hdspm->midi[0].lock);
 	spin_lock_init(&hdspm->midi[1].lock);
-	hdspm->iobase = NULL;
-	hdspm->control_register = 0;
-	hdspm->control2_register = 0;
-
-	hdspm->playback_buffer = NULL;
-	hdspm->capture_buffer = NULL;
-
-	for (i = 0; i < HDSPM_MAX_CHANNELS; ++i)
-		hdspm->playback_mixer_ctls[i] = NULL;
-	hdspm->mixer = NULL;
 
 	hdspm->card = card;
 
@@ -4340,12 +4385,14 @@ static int __devinit snd_hdspm_create(struct snd_card *card, struct hdspm * hdsp
 		hdspm->card_name = "RME HDSPM MADI";
 	}
 
-	if ((err = pci_enable_device(pci)) < 0)
+	err = pci_enable_device(pci);
+	if (err < 0)
 		return err;
 
 	pci_set_master(hdspm->pci);
 
-	if ((err = pci_request_regions(pci, "hdspm")) < 0)
+	err = pci_request_regions(pci, "hdspm");
+	if (err < 0)
 		return err;
 
 	hdspm->port = pci_resource_start(pci, 0);
@@ -4355,8 +4402,10 @@ static int __devinit snd_hdspm_create(struct snd_card *card, struct hdspm * hdsp
 		   hdspm->port, hdspm->port + io_extent - 1);
 
 
-	if ((hdspm->iobase = ioremap_nocache(hdspm->port, io_extent)) == NULL) {
-		snd_printk(KERN_ERR "HDSPM: unable to remap region 0x%lx-0x%lx\n",
+	hdspm->iobase = ioremap_nocache(hdspm->port, io_extent);
+	if (!hdspm->iobase) {
+		snd_printk(KERN_ERR "HDSPM: "
+			   "unable to remap region 0x%lx-0x%lx\n",
 			   hdspm->port, hdspm->port + io_extent - 1);
 		return -EBUSY;
 	}
@@ -4379,9 +4428,10 @@ static int __devinit snd_hdspm_create(struct snd_card *card, struct hdspm * hdsp
 
 	snd_printdd("kmalloc Mixer memory of %zd Bytes\n",
 		   sizeof(struct hdspm_mixer));
-	if ((hdspm->mixer = kmalloc(sizeof(struct hdspm_mixer), GFP_KERNEL))
-	    == NULL) {
-		snd_printk(KERN_ERR "HDSPM: unable to kmalloc Mixer memory of %d Bytes\n",
+	hdspm->mixer = kzalloc(sizeof(struct hdspm_mixer), GFP_KERNEL);
+	if (!hdspm->mixer) {
+		snd_printk(KERN_ERR "HDSPM: "
+			   "unable to kmalloc Mixer memory of %d Bytes\n",
 			   (int)sizeof(struct hdspm_mixer));
 		return err;
 	}
@@ -4391,7 +4441,8 @@ static int __devinit snd_hdspm_create(struct snd_card *card, struct hdspm * hdsp
 	hdspm->qs_channels = MADI_QS_CHANNELS;
 
 	snd_printdd("create alsa devices.\n");
-	if ((err = snd_hdspm_create_alsa_devices(card, hdspm)) < 0)
+	err = snd_hdspm_create_alsa_devices(card, hdspm);
+	if (err < 0)
 		return err;
 
 	snd_hdspm_initialize_midi_flush(hdspm);
@@ -4406,9 +4457,8 @@ static int snd_hdspm_free(struct hdspm * hdspm)
 
 		/* stop th audio, and cancel all interrupts */
 		hdspm->control_register &=
-		    ~(HDSPM_Start | HDSPM_AudioInterruptEnable
-		      | HDSPM_Midi0InterruptEnable |
-		      HDSPM_Midi1InterruptEnable);
+		    ~(HDSPM_Start | HDSPM_AudioInterruptEnable |
+		      HDSPM_Midi0InterruptEnable | HDSPM_Midi1InterruptEnable);
 		hdspm_write(hdspm, HDSPM_controlRegister,
 			    hdspm->control_register);
 	}
@@ -4416,7 +4466,6 @@ static int snd_hdspm_free(struct hdspm * hdspm)
 	if (hdspm->irq >= 0)
 		free_irq(hdspm->irq, (void *) hdspm);
 
-
 	kfree(hdspm->mixer);
 
 	if (hdspm->iobase)
@@ -4431,7 +4480,7 @@ static int snd_hdspm_free(struct hdspm * hdspm)
 
 static void snd_hdspm_card_free(struct snd_card *card)
 {
-	struct hdspm *hdspm = (struct hdspm *) card->private_data;
+	struct hdspm *hdspm = card->private_data;
 
 	if (hdspm)
 		snd_hdspm_free(hdspm);
@@ -4452,20 +4501,21 @@ static int __devinit snd_hdspm_probe(struct pci_dev *pci,
 		return -ENOENT;
 	}
 
-	if (!(card = snd_card_new(index[dev], id[dev],
-				  THIS_MODULE, sizeof(struct hdspm))))
+	card = snd_card_new(index[dev], id[dev],
+			    THIS_MODULE, sizeof(struct hdspm));
+	if (!card)
 		return -ENOMEM;
 
-	hdspm = (struct hdspm *) card->private_data;
+	hdspm = card->private_data;
 	card->private_free = snd_hdspm_card_free;
 	hdspm->dev = dev;
 	hdspm->pci = pci;
 
 	snd_card_set_dev(card, &pci->dev);
 
-	if ((err =
-	     snd_hdspm_create(card, hdspm, precise_ptr[dev],
-			      enable_monitor[dev])) < 0) {
+	err = snd_hdspm_create(card, hdspm, precise_ptr[dev],
+			       enable_monitor[dev]);
+	if (err < 0) {
 		snd_card_free(card);
 		return err;
 	}
@@ -4474,7 +4524,8 @@ static int __devinit snd_hdspm_probe(struct pci_dev *pci,
 	sprintf(card->longname, "%s at 0x%lx, irq %d", hdspm->card_name,
 		hdspm->port, hdspm->irq);
 
-	if ((err = snd_card_register(card)) < 0) {
+	err = snd_card_register(card);
+	if (err < 0) {
 		snd_card_free(card);
 		return err;
 	}

commit a5ce88909d3007caa7b65996a8f6784350beb2a6
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jul 23 15:42:26 2007 +0200

    [ALSA] Clean up with common snd_ctl_boolean_*_info callbacks
    
    Clean up codes using the new common snd_ctl_boolean_*_info() callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 143185e7e4dc..83ea4623e77c 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1834,15 +1834,7 @@ static int hdspm_set_line_output(struct hdspm * hdspm, int out)
 	return 0;
 }
 
-static int snd_hdspm_info_line_out(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_hdspm_info_line_out		snd_ctl_boolean_mono_info
 
 static int snd_hdspm_get_line_out(struct snd_kcontrol *kcontrol,
 				  struct snd_ctl_elem_value *ucontrol)
@@ -1897,15 +1889,7 @@ static int hdspm_set_tx_64(struct hdspm * hdspm, int out)
 	return 0;
 }
 
-static int snd_hdspm_info_tx_64(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_hdspm_info_tx_64		snd_ctl_boolean_mono_info
 
 static int snd_hdspm_get_tx_64(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
@@ -1960,15 +1944,7 @@ static int hdspm_set_c_tms(struct hdspm * hdspm, int out)
 	return 0;
 }
 
-static int snd_hdspm_info_c_tms(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_hdspm_info_c_tms		snd_ctl_boolean_mono_info
 
 static int snd_hdspm_get_c_tms(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
@@ -2023,15 +1999,7 @@ static int hdspm_set_safe_mode(struct hdspm * hdspm, int out)
 	return 0;
 }
 
-static int snd_hdspm_info_safe_mode(struct snd_kcontrol *kcontrol,
-				    struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_hdspm_info_safe_mode	snd_ctl_boolean_mono_info
 
 static int snd_hdspm_get_safe_mode(struct snd_kcontrol *kcontrol,
 				   struct snd_ctl_elem_value *ucontrol)
@@ -2086,15 +2054,7 @@ static int hdspm_set_emphasis(struct hdspm * hdspm, int emp)
 	return 0;
 }
 
-static int snd_hdspm_info_emphasis(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_hdspm_info_emphasis		snd_ctl_boolean_mono_info
 
 static int snd_hdspm_get_emphasis(struct snd_kcontrol *kcontrol,
 				  struct snd_ctl_elem_value *ucontrol)
@@ -2149,15 +2109,7 @@ static int hdspm_set_dolby(struct hdspm * hdspm, int dol)
 	return 0;
 }
 
-static int snd_hdspm_info_dolby(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_hdspm_info_dolby		snd_ctl_boolean_mono_info
 
 static int snd_hdspm_get_dolby(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
@@ -2212,15 +2164,7 @@ static int hdspm_set_professional(struct hdspm * hdspm, int dol)
 	return 0;
 }
 
-static int snd_hdspm_info_professional(struct snd_kcontrol *kcontrol,
-				       struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
-	return 0;
-}
+#define snd_hdspm_info_professional	snd_ctl_boolean_mono_info
 
 static int snd_hdspm_get_professional(struct snd_kcontrol *kcontrol,
 				      struct snd_ctl_elem_value *ucontrol)

commit ffb2c3c07f6ffd61923de736139248b31dc6f642
Author: Remy Bruno <remy.bruno@trinnov.com>
Date:   Wed Mar 7 19:08:46 2007 +0100

    [ALSA] hdspm - Support for Master mode of AES32 and recent MADI
    
    The current MADI driver was found not to completely work, at least on recent
    MADI cards (rev 204), in particular at 96kHz. This patch solves this:
      * Add support of DDS feature
      * Channel map fixed
      * Channel/rate rules fixed
      * DMA allocation fixed (need to alloc for all channels and not only for the
        used ones)
    Full support for AES32 master mode was added:
      * Add support of DDS feature
      * Channel map fixed
      * Channel/rate rules fixed
    
    Signed-off-by: Remy Bruno <remy.bruno@trinnov.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index d2ae6380943e..143185e7e4dc 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -91,8 +91,10 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_controlRegister	     64
 #define HDSPM_interruptConfirmation  96
 #define HDSPM_control2Reg	     256  /* not in specs ???????? */
+#define HDSPM_freqReg                256  /* for AES32 */
 #define HDSPM_midiDataOut0  	     352  /* just believe in old code */
 #define HDSPM_midiDataOut1  	     356
+#define HDSPM_eeprom_wr		     384  /* for AES32 */
 
 /* DMA enable for 64 channels, only Bit 0 is relevant */
 #define HDSPM_outputEnableBase       512  /* 512-767  input  DMA */ 
@@ -389,9 +391,8 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
    size is the same regardless of the number of channels, and
    also the latency to use. 
    for one direction !!!
-   => need to mupltiply by 2!!
 */
-#define HDSPM_DMA_AREA_BYTES (2 * HDSPM_MAX_CHANNELS * HDSPM_CHANNEL_BUFFER_BYTES)
+#define HDSPM_DMA_AREA_BYTES (HDSPM_MAX_CHANNELS * HDSPM_CHANNEL_BUFFER_BYTES)
 #define HDSPM_DMA_AREA_KILOBYTES (HDSPM_DMA_AREA_BYTES/1024)
 
 /* revisions >= 230 indicate AES32 card */
@@ -484,28 +485,6 @@ static char channel_map_madi_ss[HDSPM_MAX_CHANNELS] = {
    56, 57, 58, 59, 60, 61, 62, 63
 };
 
-static char channel_map_madi_ds[HDSPM_MAX_CHANNELS] = {
-  0, 2, 4, 6, 8, 10, 12, 14,
-  16, 18, 20, 22, 24, 26, 28, 30,
-  32, 34, 36, 38, 40, 42, 44, 46,
-  48, 50, 52, 54, 56, 58, 60, 62,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1
-};
-
-static char channel_map_madi_qs[HDSPM_MAX_CHANNELS] = {
-  0,   4,  8, 12, 16, 20, 24,  28,  
-  32, 36, 40, 44, 48, 52, 56,  60
-  -1, -1, -1, -1, -1, -1, -1, -1,  
-  -1, -1, -1, -1, -1, -1, -1, -1,  
-  -1, -1, -1, -1, -1, -1, -1, -1, 
-  -1, -1, -1, -1, -1, -1, -1, -1, 
-  -1, -1, -1, -1, -1, -1, -1, -1, 
-  -1, -1, -1, -1, -1, -1, -1, -1
-};
-
 
 static struct pci_device_id snd_hdspm_ids[] __devinitdata = {
 	{
@@ -818,6 +797,27 @@ static int hdspm_set_interrupt_interval(struct hdspm * s, unsigned int frames)
 	return 0;
 }
 
+static void hdspm_set_dds_value(struct hdspm *hdspm, int rate)
+{
+	u64 n;
+	u32 r;
+	
+	if (rate >= 112000)
+		rate /= 4;
+	else if (rate >= 56000)
+		rate /= 2;
+
+	/* RME says n = 104857600000000, but in the windows MADI driver, I see:
+//	return 104857600000000 / rate; // 100 MHz
+	return 110100480000000 / rate; // 105 MHz
+        */	   
+	//n = 104857600000000ULL;  /*  =  2^20 * 10^8 */
+	n = 110100480000000ULL;    /* Value checked for AES32 and MADI */
+	div64_32(&n, rate, &r);
+	/* n should be less than 2^32 for being written to FREQ register */
+	snd_assert((n >> 32) == 0);
+	hdspm_write(hdspm, HDSPM_freqReg, (u32)n);
+}
 
 /* dummy set rate lets see what happens */
 static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
@@ -943,12 +943,16 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 	hdspm->control_register |= rate_bits;
 	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
 
-	if (rate > 96000 /* 64000*/)
-		hdspm->channel_map = channel_map_madi_qs;
-	else if (rate > 48000)
-		hdspm->channel_map = channel_map_madi_ds;
-	else 
-		hdspm->channel_map = channel_map_madi_ss;
+	/* For AES32, need to set DDS value in FREQ register
+	   For MADI, also apparently */
+	hdspm_set_dds_value(hdspm, rate);
+	
+	if (hdspm->is_aes32 && rate != current_rate)
+		hdspm_write(hdspm, HDSPM_eeprom_wr, 0);
+	
+	/* For AES32 and for MADI (at least rev 204), channel_map needs to
+	 * always be channel_map_madi_ss, whatever the sample rate */
+	hdspm->channel_map = channel_map_madi_ss;
 
 	hdspm->system_sample_rate = rate;
 
@@ -3184,8 +3188,8 @@ snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
 		    hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,
 		    hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);
 	snd_iprintf(buffer,
-		    "Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, status2=0x%x, timecode=0x%x\n",
-		    hdspm->control_register, hdspm->control2_register,
+		    "Register: ctrl1=0x%x, status1=0x%x, status2=0x%x, timecode=0x%x\n",
+		    hdspm->control_register,
 		    status, status2, timecode);
 
 	snd_iprintf(buffer, "--- Settings ---\n");
@@ -3377,13 +3381,16 @@ static int snd_hdspm_set_defaults(struct hdspm * hdspm)
 
 	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
 
+        if (!hdspm->is_aes32) {
+		/* No control2 register for AES32 */
 #ifdef SNDRV_BIG_ENDIAN
-	hdspm->control2_register = HDSPM_BIGENDIAN_MODE;
+		hdspm->control2_register = HDSPM_BIGENDIAN_MODE;
 #else
-	hdspm->control2_register = 0;
+		hdspm->control2_register = 0;
 #endif
 
-	hdspm_write(hdspm, HDSPM_control2Reg, hdspm->control2_register);
+		hdspm_write(hdspm, HDSPM_control2Reg, hdspm->control2_register);
+	}
 	hdspm_compute_period_size(hdspm);
 
 	/* silence everything */
@@ -3656,11 +3663,10 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 
 	/* Memory allocation, takashi's method, dont know if we should spinlock  */
 	/* malloc all buffer even if not enabled to get sure */
-	/* malloc only needed bytes */
+	/* Update for MADI rev 204: we need to allocate for all channels,
+	 * otherwise it doesn't work at 96kHz */
 	err =
-	    snd_pcm_lib_malloc_pages(substream,
-				     HDSPM_CHANNEL_BUFFER_BYTES *
-				     params_channels(params));
+	    snd_pcm_lib_malloc_pages(substream, HDSPM_DMA_AREA_BYTES);
 	if (err < 0)
 		return err;
 
@@ -3696,6 +3702,13 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 	   "playback" : "capture",
 	   snd_pcm_sgbuf_get_addr(sgbuf, 0));
 	 */
+	/*
+	snd_printdd("set_hwparams: %s %d Hz, %d channels, bs = %d\n",
+			substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+			  "playback" : "capture",
+			params_rate(params), params_channels(params),
+			params_buffer_size(params));
+	*/
 	return 0;
 }
 
@@ -3900,16 +3913,16 @@ static int snd_hdspm_hw_rule_channels_rate(struct snd_pcm_hw_params *params,
 	struct snd_interval *r =
 	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 
-	if (r->min > 48000) {
+	if (r->min > 48000 && r->max <= 96000) {
 		struct snd_interval t = {
-			.min = 1,
+			.min = hdspm->ds_channels,
 			.max = hdspm->ds_channels,
 			.integer = 1,
 		};
 		return snd_interval_refine(c, &t);
 	} else if (r->max < 64000) {
 		struct snd_interval t = {
-			.min = 1,
+			.min = hdspm->ss_channels,
 			.max = hdspm->ss_channels,
 			.integer = 1,
 		};
@@ -3927,14 +3940,14 @@ static int snd_hdspm_hw_rule_rate_channels(struct snd_pcm_hw_params *params,
 	struct snd_interval *r =
 	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 
-	if (c->min <= hdspm->ss_channels) {
+	if (c->min >= hdspm->ss_channels) {
 		struct snd_interval t = {
 			.min = 32000,
 			.max = 48000,
 			.integer = 1,
 		};
 		return snd_interval_refine(r, &t);
-	} else if (c->max > hdspm->ss_channels) {
+	} else if (c->max <= hdspm->ds_channels) {
 		struct snd_interval t = {
 			.min = 64000,
 			.max = 96000,
@@ -3946,13 +3959,39 @@ static int snd_hdspm_hw_rule_rate_channels(struct snd_pcm_hw_params *params,
 	return 0;
 }
 
+static int snd_hdspm_hw_rule_channels(struct snd_pcm_hw_params *params,
+				      struct snd_pcm_hw_rule *rule)
+{
+	unsigned int list[3];
+	struct hdspm *hdspm = rule->private;
+	struct snd_interval *c = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_CHANNELS);
+	if (hdspm->is_aes32) {
+		list[0] = hdspm->qs_channels;
+		list[1] = hdspm->ds_channels;
+		list[2] = hdspm->ss_channels;
+		return snd_interval_list(c, 3, list, 0);
+	} else {
+		list[0] = hdspm->ds_channels;
+		list[1] = hdspm->ss_channels;
+		return snd_interval_list(c, 2, list, 0);
+	}
+}
+
+
+static unsigned int hdspm_aes32_sample_rates[] = { 32000, 44100, 48000, 64000, 88200, 96000, 128000, 176400, 192000 };
+
+static struct snd_pcm_hw_constraint_list hdspm_hw_constraints_aes32_sample_rates = {
+	.count = ARRAY_SIZE(hdspm_aes32_sample_rates),
+	.list = hdspm_aes32_sample_rates,
+	.mask = 0
+};
+
 static int snd_hdspm_playback_open(struct snd_pcm_substream *substream)
 {
 	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	snd_printdd("Open device substream %d\n", substream->stream);
-
 	spin_lock_irq(&hdspm->lock);
 
 	snd_pcm_set_sync(substream);
@@ -3973,14 +4012,21 @@ static int snd_hdspm_playback_open(struct snd_pcm_substream *substream)
 				   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
 				   &hw_constraints_period_sizes);
 
-	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-			    snd_hdspm_hw_rule_channels_rate, hdspm,
-			    SNDRV_PCM_HW_PARAM_RATE, -1);
-
-	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
-			    snd_hdspm_hw_rule_rate_channels, hdspm,
-			    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
-
+	if (hdspm->is_aes32) {
+		snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				&hdspm_hw_constraints_aes32_sample_rates);
+	} else {
+		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+				     snd_hdspm_hw_rule_channels, hdspm,
+				     SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+				    snd_hdspm_hw_rule_channels_rate, hdspm,
+				    SNDRV_PCM_HW_PARAM_RATE, -1);
+
+		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				    snd_hdspm_hw_rule_rate_channels, hdspm,
+				    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	}
 	return 0;
 }
 
@@ -4020,14 +4066,21 @@ static int snd_hdspm_capture_open(struct snd_pcm_substream *substream)
 	snd_pcm_hw_constraint_list(runtime, 0,
 				   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
 				   &hw_constraints_period_sizes);
-
-	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
-			    snd_hdspm_hw_rule_channels_rate, hdspm,
-			    SNDRV_PCM_HW_PARAM_RATE, -1);
-
-	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
-			    snd_hdspm_hw_rule_rate_channels, hdspm,
-			    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	if (hdspm->is_aes32) {
+		snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				&hdspm_hw_constraints_aes32_sample_rates);
+	} else {
+		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+				     snd_hdspm_hw_rule_channels, hdspm,
+				     SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+				    snd_hdspm_hw_rule_channels_rate, hdspm,
+				    SNDRV_PCM_HW_PARAM_RATE, -1);
+
+		snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+				    snd_hdspm_hw_rule_rate_channels, hdspm,
+				    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	}
 	return 0;
 }
 

commit ef991b95aa1351a5782cfaccb9aefba76ca8b990
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Feb 22 12:52:53 2007 +0100

    [ALSA] Add snd_pcm_group_for_each_entry() for code cleanup
    
    Added a new macro snd_pcm_group_for_each_entry() just for code cleanup.
    Old macros, snd_pcm_group_for_each() and snd_pcm_group_substream_entry(),
    are removed.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 6e95857e4e67..d2ae6380943e 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3575,11 +3575,9 @@ static int snd_hdspm_reset(struct snd_pcm_substream *substream)
 	else
 		runtime->status->hw_ptr = 0;
 	if (other) {
-		struct list_head *pos;
 		struct snd_pcm_substream *s;
 		struct snd_pcm_runtime *oruntime = other->runtime;
-		snd_pcm_group_for_each(pos, substream) {
-			s = snd_pcm_group_substream_entry(pos);
+		snd_pcm_group_for_each_entry(s, substream) {
 			if (s == other) {
 				oruntime->status->hw_ptr =
 				    runtime->status->hw_ptr;
@@ -3791,10 +3789,8 @@ static int snd_hdspm_trigger(struct snd_pcm_substream *substream, int cmd)
 		other = hdspm->playback_substream;
 
 	if (other) {
-		struct list_head *pos;
 		struct snd_pcm_substream *s;
-		snd_pcm_group_for_each(pos, substream) {
-			s = snd_pcm_group_substream_entry(pos);
+		snd_pcm_group_for_each_entry(s, substream) {
 			if (s == other) {
 				snd_pcm_trigger_done(s, substream);
 				if (cmd == SNDRV_PCM_TRIGGER_START)

commit c187c041c6552339e4d8883a1a00c3c489354eca
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 19 15:27:33 2007 +0100

    [ALSA] Add missing sysfs device assignment for ALSA PCI drivers
    
    Added the missing sysfs device assignment for ALSA PCI drivers.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index e0215aca1193..6e95857e4e67 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -4468,6 +4468,8 @@ static int __devinit snd_hdspm_probe(struct pci_dev *pci,
 	hdspm->dev = dev;
 	hdspm->pci = pci;
 
+	snd_card_set_dev(card, &pci->dev);
+
 	if ((err =
 	     snd_hdspm_create(card, hdspm, precise_ptr[dev],
 			      enable_monitor[dev])) < 0) {

commit 54bf5dd9ccd8c37830d7dae0737466e8fda018aa
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 6 15:38:55 2006 +0100

    [ALSA] hdspm - Fix printk warnings
    
    sound/pci/rme9652/hdspm.c: In function 'snd_hdspm_hw_params':
    sound/pci/rme9652/hdspm.c:3681: warning: format '%08X' expects type 'unsigned int', but argument 4 has type 'unsigned char *'
    sound/pci/rme9652/hdspm.c:3692: warning: format '%08X' expects type 'unsigned int', but argument 4 has type 'unsigned char *'
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 3d3a4ce3a35e..e0215aca1193 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3678,7 +3678,7 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 
 		hdspm->playback_buffer =
 		    (unsigned char *) substream->runtime->dma_area;
-		snd_printdd("Allocated sample buffer for playback at 0x%08X\n",
+		snd_printdd("Allocated sample buffer for playback at %p\n",
 				hdspm->playback_buffer);
 	} else {
 		hdspm_set_sgbuf(hdspm, sgbuf, HDSPM_pageAddressBufferIn,
@@ -3689,7 +3689,7 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 
 		hdspm->capture_buffer =
 		    (unsigned char *) substream->runtime->dma_area;
-		snd_printdd("Allocated sample buffer for capture at 0x%08X\n",
+		snd_printdd("Allocated sample buffer for capture at %p\n",
 				hdspm->capture_buffer);
 	}
 	/*

commit 3cee5a60ce18034a63f70ba2bdd54f85018ce960
Author: Remy Bruno <remy.bruno@trinnov.com>
Date:   Mon Oct 16 12:46:32 2006 +0200

    [ALSA] hdspm: Add support for AES32
    
    Add support for AES32. Difference between MADI and AES32 is done
    through revision. Master support is not finished for now (RME so-called DDS
    feature is not supported yet)
    
    Signed-off-by: Remy Bruno <remy.bruno@trinnov.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 0547f6f04bdc..3d3a4ce3a35e 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -6,6 +6,8 @@
  *      code based on hdsp.c   Paul Davis
  *                             Marcus Andersson
  *                             Thomas Charbonnel
+ *      Modified 2006-06-01 for AES32 support by Remy Bruno
+ *                                               <remy.bruno@trinnov.com>
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -77,7 +79,8 @@ MODULE_PARM_DESC(enable_monitor,
 
 MODULE_AUTHOR
       ("Winfried Ritsch <ritsch_AT_iem.at>, Paul Davis <paul@linuxaudiosystems.com>, "
-       "Marcus Andersson, Thomas Charbonnel <thomas@undata.org>");
+       "Marcus Andersson, Thomas Charbonnel <thomas@undata.org>, "
+       "Remy Bruno <remy.bruno@trinnov.com>");
 MODULE_DESCRIPTION("RME HDSPM");
 MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
@@ -107,7 +110,12 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 /* --- Read registers. ---
    These are defined as byte-offsets from the iobase value */
 #define HDSPM_statusRegister    0
-#define HDSPM_statusRegister2  96
+/*#define HDSPM_statusRegister2  96 */
+/* after RME Windows driver sources, status2 is 4-byte word # 48 = word at
+ * offset 192, for AES32 *and* MADI
+ * => need to check that offset 192 is working on MADI */
+#define HDSPM_statusRegister2  192
+#define HDSPM_timecodeRegister 128
 
 #define HDSPM_midiDataIn0     360
 #define HDSPM_midiDataIn1     364
@@ -140,37 +148,50 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_Frequency0  (1<<6)  /* 0=44.1kHz/88.2kHz 1=48kHz/96kHz */
 #define HDSPM_Frequency1  (1<<7)  /* 0=32kHz/64kHz */
 #define HDSPM_DoubleSpeed (1<<8)  /* 0=normal speed, 1=double speed */
-#define HDSPM_QuadSpeed   (1<<31) /* quad speed bit, not implemented now */
+#define HDSPM_QuadSpeed   (1<<31) /* quad speed bit */
 
+#define HDSPM_Professional (1<<9) /* Professional */ /* AES32 ONLY */
 #define HDSPM_TX_64ch     (1<<10) /* Output 64channel MODE=1,
-				     56channelMODE=0 */
+				     56channelMODE=0 */ /* MADI ONLY*/
+#define HDSPM_Emphasis    (1<<10) /* Emphasis */ /* AES32 ONLY */
 
 #define HDSPM_AutoInp     (1<<11) /* Auto Input (takeover) == Safe Mode, 
-                                     0=off, 1=on  */
+                                     0=off, 1=on  */ /* MADI ONLY */
+#define HDSPM_Dolby       (1<<11) /* Dolby = "NonAudio" ?? */ /* AES32 ONLY */
 
-#define HDSPM_InputSelect0 (1<<14) /* Input select 0= optical, 1=coax */
+#define HDSPM_InputSelect0 (1<<14) /* Input select 0= optical, 1=coax */ /* MADI ONLY*/
 #define HDSPM_InputSelect1 (1<<15) /* should be 0 */
 
 #define HDSPM_SyncRef0     (1<<16) /* 0=WOrd, 1=MADI */
-#define HDSPM_SyncRef1     (1<<17) /* should be 0 */
+#define HDSPM_SyncRef1     (1<<17) /* for AES32: SyncRefN codes the AES # */
+#define HDSPM_SyncRef2     (1<<13)
+#define HDSPM_SyncRef3     (1<<25)
 
+#define HDSPM_SMUX         (1<<18) /* Frame ??? */ /* MADI ONY */
 #define HDSPM_clr_tms      (1<<19) /* clear track marker, do not use 
                                       AES additional bits in
 				      lower 5 Audiodatabits ??? */
+#define HDSPM_taxi_reset   (1<<20) /* ??? */ /* MADI ONLY ? */
+#define HDSPM_WCK48        (1<<20) /* Frame ??? = HDSPM_SMUX */ /* AES32 ONLY */
 
 #define HDSPM_Midi0InterruptEnable (1<<22)
 #define HDSPM_Midi1InterruptEnable (1<<23)
 
 #define HDSPM_LineOut (1<<24) /* Analog Out on channel 63/64 on=1, mute=0 */
 
+#define HDSPM_DS_DoubleWire (1<<26) /* AES32 ONLY */
+#define HDSPM_QS_DoubleWire (1<<27) /* AES32 ONLY */
+#define HDSPM_QS_QuadWire   (1<<28) /* AES32 ONLY */
+
+#define HDSPM_wclk_sel (1<<30)
 
 /* --- bit helper defines */
 #define HDSPM_LatencyMask    (HDSPM_Latency0|HDSPM_Latency1|HDSPM_Latency2)
-#define HDSPM_FrequencyMask  (HDSPM_Frequency0|HDSPM_Frequency1)
+#define HDSPM_FrequencyMask  (HDSPM_Frequency0|HDSPM_Frequency1|HDSPM_DoubleSpeed|HDSPM_QuadSpeed)
 #define HDSPM_InputMask      (HDSPM_InputSelect0|HDSPM_InputSelect1)
 #define HDSPM_InputOptical   0
 #define HDSPM_InputCoaxial   (HDSPM_InputSelect0)
-#define HDSPM_SyncRefMask    (HDSPM_SyncRef0|HDSPM_SyncRef1)
+#define HDSPM_SyncRefMask    (HDSPM_SyncRef0|HDSPM_SyncRef1|HDSPM_SyncRef2|HDSPM_SyncRef3)
 #define HDSPM_SyncRef_Word   0
 #define HDSPM_SyncRef_MADI   (HDSPM_SyncRef0)
 
@@ -183,6 +204,9 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_Frequency64KHz   (HDSPM_DoubleSpeed|HDSPM_Frequency0)
 #define HDSPM_Frequency88_2KHz (HDSPM_DoubleSpeed|HDSPM_Frequency1)
 #define HDSPM_Frequency96KHz   (HDSPM_DoubleSpeed|HDSPM_Frequency1|HDSPM_Frequency0)
+#define HDSPM_Frequency128KHz   (HDSPM_QuadSpeed|HDSPM_Frequency0)
+#define HDSPM_Frequency176_4KHz   (HDSPM_QuadSpeed|HDSPM_Frequency1)
+#define HDSPM_Frequency192KHz   (HDSPM_QuadSpeed|HDSPM_Frequency1|HDSPM_Frequency0)
 
 /* --- for internal discrimination */
 #define HDSPM_CLOCK_SOURCE_AUTOSYNC          0	/* Sample Clock Sources */
@@ -229,7 +253,8 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_BIGENDIAN_MODE  (1<<9)
 #define HDSPM_RD_MULTIPLE     (1<<10)
 
-/* --- Status Register bits --- */
+/* --- Status Register bits --- */ /* MADI ONLY */ /* Bits defined here and
+     that do not conflict with specific bits for AES32 seem to be valid also for the AES32 */
 #define HDSPM_audioIRQPending    (1<<0)	/* IRQ is high and pending */
 #define HDSPM_RX_64ch            (1<<1)	/* Input 64chan. MODE=1, 56chn. MODE=0 */
 #define HDSPM_AB_int             (1<<2)	/* InputChannel Opt=0, Coax=1 (like inp0) */
@@ -263,7 +288,7 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_madiFreq176_4 (HDSPM_madiFreq3)
 #define HDSPM_madiFreq192   (HDSPM_madiFreq3|HDSPM_madiFreq0)
 
-/* Status2 Register bits */
+/* Status2 Register bits */ /* MADI ONLY */
 
 #define HDSPM_version0 (1<<0)	/* not realy defined but I guess */
 #define HDSPM_version1 (1<<1)	/* in former cards it was ??? */
@@ -297,6 +322,56 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_SelSyncRef_MADI      (HDSPM_SelSyncRef0)
 #define HDSPM_SelSyncRef_NVALID    (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1|HDSPM_SelSyncRef2)
 
+/*
+   For AES32, bits for status, status2 and timecode are different
+*/
+/* status */
+#define HDSPM_AES32_wcLock	0x0200000
+#define HDSPM_AES32_wcFreq_bit  22
+/* (status >> HDSPM_AES32_wcFreq_bit) & 0xF gives WC frequency (cf function 
+  HDSPM_bit2freq */
+#define HDSPM_AES32_syncref_bit  16
+/* (status >> HDSPM_AES32_syncref_bit) & 0xF gives sync source */
+
+#define HDSPM_AES32_AUTOSYNC_FROM_WORD 0
+#define HDSPM_AES32_AUTOSYNC_FROM_AES1 1
+#define HDSPM_AES32_AUTOSYNC_FROM_AES2 2
+#define HDSPM_AES32_AUTOSYNC_FROM_AES3 3
+#define HDSPM_AES32_AUTOSYNC_FROM_AES4 4
+#define HDSPM_AES32_AUTOSYNC_FROM_AES5 5
+#define HDSPM_AES32_AUTOSYNC_FROM_AES6 6
+#define HDSPM_AES32_AUTOSYNC_FROM_AES7 7
+#define HDSPM_AES32_AUTOSYNC_FROM_AES8 8
+#define HDSPM_AES32_AUTOSYNC_FROM_NONE -1
+
+/*  status2 */
+/* HDSPM_LockAES_bit is given by HDSPM_LockAES >> (AES# - 1) */
+#define HDSPM_LockAES   0x80
+#define HDSPM_LockAES1  0x80
+#define HDSPM_LockAES2  0x40
+#define HDSPM_LockAES3  0x20
+#define HDSPM_LockAES4  0x10
+#define HDSPM_LockAES5  0x8
+#define HDSPM_LockAES6  0x4
+#define HDSPM_LockAES7  0x2
+#define HDSPM_LockAES8  0x1
+/*
+   Timecode
+   After windows driver sources, bits 4*i to 4*i+3 give the input frequency on
+   AES i+1
+ bits 3210
+      0001  32kHz
+      0010  44.1kHz
+      0011  48kHz
+      0100  64kHz
+      0101  88.2kHz
+      0110  96kHz
+      0111  128kHz
+      1000  176.4kHz
+      1001  192kHz
+  NB: Timecode register doesn't seem to work on AES32 card revision 230
+*/
+
 /* Mixer Values */
 #define UNITY_GAIN          32768	/* = 65536/2 */
 #define MINUS_INFINITY_GAIN 0
@@ -314,10 +389,14 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
    size is the same regardless of the number of channels, and
    also the latency to use. 
    for one direction !!!
+   => need to mupltiply by 2!!
 */
-#define HDSPM_DMA_AREA_BYTES (HDSPM_MAX_CHANNELS * HDSPM_CHANNEL_BUFFER_BYTES)
+#define HDSPM_DMA_AREA_BYTES (2 * HDSPM_MAX_CHANNELS * HDSPM_CHANNEL_BUFFER_BYTES)
 #define HDSPM_DMA_AREA_KILOBYTES (HDSPM_DMA_AREA_BYTES/1024)
 
+/* revisions >= 230 indicate AES32 card */
+#define HDSPM_AESREVISION 230
+
 struct hdspm_midi {
 	struct hdspm *hdspm;
 	int id;
@@ -336,7 +415,9 @@ struct hdspm {
         struct snd_pcm_substream *playback_substream; /* and/or capture stream */
 
 	char *card_name;	     /* for procinfo */
-	unsigned short firmware_rev; /* dont know if relevant */
+	unsigned short firmware_rev; /* dont know if relevant (yes if AES32)*/
+
+	unsigned char is_aes32;    /* indicates if card is AES32 */
 
 	int precise_ptr;	/* use precise pointers, to be tested */
 	int monitor_outs;	/* set up monitoring outs init flag */
@@ -453,6 +534,15 @@ static int snd_hdspm_set_defaults(struct hdspm * hdspm);
 static void hdspm_set_sgbuf(struct hdspm * hdspm, struct snd_sg_buf *sgbuf,
 			     unsigned int reg, int channels);
 
+static inline int HDSPM_bit2freq(int n)
+{
+	static int bit2freq_tab[] = { 0, 32000, 44100, 48000, 64000, 88200,
+		96000, 128000, 176400, 192000 };
+	if (n < 1 || n > 9)
+		return 0;
+	return bit2freq_tab[n];
+}
+
 /* Write/read to/from HDSPM with Adresses in Bytes
    not words but only 32Bit writes are allowed */
 
@@ -544,86 +634,105 @@ static inline int snd_hdspm_use_is_exclusive(struct hdspm * hdspm)
 /* check for external sample rate */
 static inline int hdspm_external_sample_rate(struct hdspm * hdspm)
 {
-	unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
-	unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
-	unsigned int rate_bits;
-	int rate = 0;
+	if (hdspm->is_aes32) {
+		unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+		unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
+		unsigned int timecode = hdspm_read(hdspm, HDSPM_timecodeRegister);
+
+		int syncref = hdspm_autosync_ref(hdspm);
+
+		if (syncref == HDSPM_AES32_AUTOSYNC_FROM_WORD &&
+				status & HDSPM_AES32_wcLock)
+			return HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit) & 0xF);
+		if (syncref >= HDSPM_AES32_AUTOSYNC_FROM_AES1 &&
+			syncref <= HDSPM_AES32_AUTOSYNC_FROM_AES8 &&
+			status2 & (HDSPM_LockAES >>
+			          (syncref - HDSPM_AES32_AUTOSYNC_FROM_AES1)))
+			return HDSPM_bit2freq((timecode >>
+			  (4*(syncref-HDSPM_AES32_AUTOSYNC_FROM_AES1))) & 0xF);
+		return 0;
+	} else {
+		unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+		unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
+		unsigned int rate_bits;
+		int rate = 0;
 
-	/* if wordclock has synced freq and wordclock is valid */
-	if ((status2 & HDSPM_wcLock) != 0 &&
-	    (status & HDSPM_SelSyncRef0) == 0) {
+		/* if wordclock has synced freq and wordclock is valid */
+		if ((status2 & HDSPM_wcLock) != 0 &&
+				(status & HDSPM_SelSyncRef0) == 0) {
 
-		rate_bits = status2 & HDSPM_wcFreqMask;
+			rate_bits = status2 & HDSPM_wcFreqMask;
 
-		switch (rate_bits) {
-		case HDSPM_wcFreq32:
-			rate = 32000;
-			break;
-		case HDSPM_wcFreq44_1:
-			rate = 44100;
-			break;
-		case HDSPM_wcFreq48:
-			rate = 48000;
-			break;
-		case HDSPM_wcFreq64:
-			rate = 64000;
-			break;
-		case HDSPM_wcFreq88_2:
-			rate = 88200;
-			break;
-		case HDSPM_wcFreq96:
-			rate = 96000;
-			break;
-			/* Quadspeed Bit missing ???? */
-		default:
-			rate = 0;
-			break;
+			switch (rate_bits) {
+			case HDSPM_wcFreq32:
+				rate = 32000;
+				break;
+			case HDSPM_wcFreq44_1:
+				rate = 44100;
+				break;
+			case HDSPM_wcFreq48:
+				rate = 48000;
+				break;
+			case HDSPM_wcFreq64:
+				rate = 64000;
+				break;
+			case HDSPM_wcFreq88_2:
+				rate = 88200;
+				break;
+			case HDSPM_wcFreq96:
+				rate = 96000;
+				break;
+				/* Quadspeed Bit missing ???? */
+			default:
+				rate = 0;
+				break;
+			}
 		}
-	}
 
-	/* if rate detected and Syncref is Word than have it, word has priority to MADI */
-	if (rate != 0
-	    && (status2 & HDSPM_SelSyncRefMask) == HDSPM_SelSyncRef_WORD)
-		return rate;
+		/* if rate detected and Syncref is Word than have it, word has priority to MADI */
+		if (rate != 0 &&
+	            (status2 & HDSPM_SelSyncRefMask) == HDSPM_SelSyncRef_WORD)
+			return rate;
 
-	/* maby a madi input (which is taken if sel sync is madi) */
-	if (status & HDSPM_madiLock) {
-		rate_bits = status & HDSPM_madiFreqMask;
+		/* maby a madi input (which is taken if sel sync is madi) */
+		if (status & HDSPM_madiLock) {
+			rate_bits = status & HDSPM_madiFreqMask;
 
-		switch (rate_bits) {
-		case HDSPM_madiFreq32:
-			rate = 32000;
-			break;
-		case HDSPM_madiFreq44_1:
-			rate = 44100;
-			break;
-		case HDSPM_madiFreq48:
-			rate = 48000;
-			break;
-		case HDSPM_madiFreq64:
-			rate = 64000;
-			break;
-		case HDSPM_madiFreq88_2:
-			rate = 88200;
-			break;
-		case HDSPM_madiFreq96:
-			rate = 96000;
-			break;
-		case HDSPM_madiFreq128:
-			rate = 128000;
-			break;
-		case HDSPM_madiFreq176_4:
-			rate = 176400;
-			break;
-		case HDSPM_madiFreq192:
-			rate = 192000;
-			break;
-		default:
-			rate = 0;
-			break;
+			switch (rate_bits) {
+			case HDSPM_madiFreq32:
+				rate = 32000;
+				break;
+			case HDSPM_madiFreq44_1:
+				rate = 44100;
+				break;
+			case HDSPM_madiFreq48:
+				rate = 48000;
+				break;
+			case HDSPM_madiFreq64:
+				rate = 64000;
+				break;
+			case HDSPM_madiFreq88_2:
+				rate = 88200;
+				break;
+			case HDSPM_madiFreq96:
+				rate = 96000;
+				break;
+			case HDSPM_madiFreq128:
+				rate = 128000;
+				break;
+			case HDSPM_madiFreq176_4:
+				rate = 176400;
+				break;
+			case HDSPM_madiFreq192:
+				rate = 192000;
+				break;
+			default:
+				rate = 0;
+				break;
+			}
 		}
+		return rate;
 	}
-	return rate;
 }
 
 /* Latency function */
@@ -676,7 +785,8 @@ static inline void hdspm_silence_playback(struct hdspm * hdspm)
 	int n = hdspm->period_bytes;
 	void *buf = hdspm->playback_buffer;
 
-	snd_assert(buf != NULL, return);
+	if (buf == NULL)
+		return;
 
 	for (i = 0; i < HDSPM_MAX_CHANNELS; i++) {
 		memset(buf, 0, n);
@@ -716,6 +826,7 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 	int current_rate;
 	int rate_bits;
 	int not_set = 0;
+	int is_single, is_double, is_quad;
 
 	/* ASSUMPTION: hdspm->lock is either set, or there is no need for
 	   it (e.g. during module initialization).
@@ -766,43 +877,56 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 	   changes in the read/write routines.  
 	 */
 
+	is_single = (current_rate <= 48000);
+	is_double = (current_rate > 48000 && current_rate <= 96000);
+	is_quad = (current_rate > 96000);
+
 	switch (rate) {
 	case 32000:
-		if (current_rate > 48000) {
+		if (!is_single)
 			reject_if_open = 1;
-		}
 		rate_bits = HDSPM_Frequency32KHz;
 		break;
 	case 44100:
-		if (current_rate > 48000) {
+		if (!is_single)
 			reject_if_open = 1;
-		}
 		rate_bits = HDSPM_Frequency44_1KHz;
 		break;
 	case 48000:
-		if (current_rate > 48000) {
+		if (!is_single)
 			reject_if_open = 1;
-		}
 		rate_bits = HDSPM_Frequency48KHz;
 		break;
 	case 64000:
-		if (current_rate <= 48000) {
+		if (!is_double)
 			reject_if_open = 1;
-		}
 		rate_bits = HDSPM_Frequency64KHz;
 		break;
 	case 88200:
-		if (current_rate <= 48000) {
+		if (!is_double)
 			reject_if_open = 1;
-		}
 		rate_bits = HDSPM_Frequency88_2KHz;
 		break;
 	case 96000:
-		if (current_rate <= 48000) {
+		if (!is_double)
 			reject_if_open = 1;
-		}
 		rate_bits = HDSPM_Frequency96KHz;
 		break;
+	case 128000:
+		if (!is_quad)
+			reject_if_open = 1;
+		rate_bits = HDSPM_Frequency128KHz;
+		break;
+	case 176400:
+		if (!is_quad)
+			reject_if_open = 1;
+		rate_bits = HDSPM_Frequency176_4KHz;
+		break;
+	case 192000:
+		if (!is_quad)
+			reject_if_open = 1;
+		rate_bits = HDSPM_Frequency192KHz;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -819,7 +943,7 @@ static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 	hdspm->control_register |= rate_bits;
 	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
 
-	if (rate > 64000)
+	if (rate > 96000 /* 64000*/)
 		hdspm->channel_map = channel_map_madi_qs;
 	else if (rate > 48000)
 		hdspm->channel_map = channel_map_madi_ds;
@@ -1455,11 +1579,27 @@ static int hdspm_pref_sync_ref(struct hdspm * hdspm)
 	/* Notice that this looks at the requested sync source,
 	   not the one actually in use.
 	 */
-	switch (hdspm->control_register & HDSPM_SyncRefMask) {
-	case HDSPM_SyncRef_Word:
-		return HDSPM_SYNC_FROM_WORD;
-	case HDSPM_SyncRef_MADI:
-		return HDSPM_SYNC_FROM_MADI;
+	if (hdspm->is_aes32) {
+		switch (hdspm->control_register & HDSPM_SyncRefMask) {
+		/* number gives AES index, except for 0 which
+		   corresponds to WordClock */
+		case 0: return 0;
+		case HDSPM_SyncRef0: return 1;
+		case HDSPM_SyncRef1: return 2;
+		case HDSPM_SyncRef1+HDSPM_SyncRef0: return 3;
+		case HDSPM_SyncRef2: return 4;
+		case HDSPM_SyncRef2+HDSPM_SyncRef0: return 5;
+		case HDSPM_SyncRef2+HDSPM_SyncRef1: return 6;
+		case HDSPM_SyncRef2+HDSPM_SyncRef1+HDSPM_SyncRef0: return 7;
+		case HDSPM_SyncRef3: return 8;
+		}
+	} else {
+		switch (hdspm->control_register & HDSPM_SyncRefMask) {
+		case HDSPM_SyncRef_Word:
+			return HDSPM_SYNC_FROM_WORD;
+		case HDSPM_SyncRef_MADI:
+			return HDSPM_SYNC_FROM_MADI;
+		}
 	}
 
 	return HDSPM_SYNC_FROM_WORD;
@@ -1469,15 +1609,49 @@ static int hdspm_set_pref_sync_ref(struct hdspm * hdspm, int pref)
 {
 	hdspm->control_register &= ~HDSPM_SyncRefMask;
 
-	switch (pref) {
-	case HDSPM_SYNC_FROM_MADI:
-		hdspm->control_register |= HDSPM_SyncRef_MADI;
-		break;
-	case HDSPM_SYNC_FROM_WORD:
-		hdspm->control_register |= HDSPM_SyncRef_Word;
-		break;
-	default:
-		return -1;
+	if (hdspm->is_aes32) {
+		switch (pref) {
+		case 0:
+		       hdspm->control_register |= 0;
+		       break;
+		case 1:
+		       hdspm->control_register |= HDSPM_SyncRef0;
+		       break;
+		case 2:
+		       hdspm->control_register |= HDSPM_SyncRef1;
+		       break;
+		case 3:
+		       hdspm->control_register |= HDSPM_SyncRef1+HDSPM_SyncRef0;
+		       break;
+		case 4:
+		       hdspm->control_register |= HDSPM_SyncRef2;
+		       break;
+		case 5:
+		       hdspm->control_register |= HDSPM_SyncRef2+HDSPM_SyncRef0;
+		       break;
+		case 6:
+		       hdspm->control_register |= HDSPM_SyncRef2+HDSPM_SyncRef1;
+		       break;
+		case 7:
+		       hdspm->control_register |= HDSPM_SyncRef2+HDSPM_SyncRef1+HDSPM_SyncRef0;
+		       break;
+		case 8:
+		       hdspm->control_register |= HDSPM_SyncRef3;
+		       break;
+		default:
+		       return -1;
+		}
+	} else {
+		switch (pref) {
+		case HDSPM_SYNC_FROM_MADI:
+			hdspm->control_register |= HDSPM_SyncRef_MADI;
+			break;
+		case HDSPM_SYNC_FROM_WORD:
+			hdspm->control_register |= HDSPM_SyncRef_Word;
+			break;
+		default:
+			return -1;
+		}
 	}
 	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
 	return 0;
@@ -1486,18 +1660,36 @@ static int hdspm_set_pref_sync_ref(struct hdspm * hdspm, int pref)
 static int snd_hdspm_info_pref_sync_ref(struct snd_kcontrol *kcontrol,
 					struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "Word", "MADI" };
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
+	if (hdspm->is_aes32) {
+		static char *texts[] = { "Word", "AES1", "AES2", "AES3",
+			"AES4", "AES5",	"AES6", "AES7", "AES8" };
 
-	uinfo->value.enumerated.items = 2;
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+		uinfo->count = 1;
 
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-		    uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
+		uinfo->value.enumerated.items = 9;
+
+		if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+			uinfo->value.enumerated.item =
+				uinfo->value.enumerated.items - 1;
+		strcpy(uinfo->value.enumerated.name,
+				texts[uinfo->value.enumerated.item]);
+	} else {
+		static char *texts[] = { "Word", "MADI" };
+
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+		uinfo->count = 1;
+
+		uinfo->value.enumerated.items = 2;
+
+		if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+			uinfo->value.enumerated.item =
+				uinfo->value.enumerated.items - 1;
+		strcpy(uinfo->value.enumerated.name,
+				texts[uinfo->value.enumerated.item]);
+	}
 	return 0;
 }
 
@@ -1517,7 +1709,7 @@ static int snd_hdspm_put_pref_sync_ref(struct snd_kcontrol *kcontrol,
 	int change, max;
 	unsigned int val;
 
-	max = 2;
+	max = hdspm->is_aes32 ? 9 : 2;
 
 	if (!snd_hdspm_use_is_exclusive(hdspm))
 		return -EBUSY;
@@ -1542,40 +1734,64 @@ static int snd_hdspm_put_pref_sync_ref(struct snd_kcontrol *kcontrol,
 
 static int hdspm_autosync_ref(struct hdspm * hdspm)
 {
-	/* This looks at the autosync selected sync reference */
-	unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
-
-	switch (status2 & HDSPM_SelSyncRefMask) {
-
-	case HDSPM_SelSyncRef_WORD:
-		return HDSPM_AUTOSYNC_FROM_WORD;
-
-	case HDSPM_SelSyncRef_MADI:
-		return HDSPM_AUTOSYNC_FROM_MADI;
-
-	case HDSPM_SelSyncRef_NVALID:
-		return HDSPM_AUTOSYNC_FROM_NONE;
+	if (hdspm->is_aes32) {
+		unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
+		unsigned int syncref = (status >> HDSPM_AES32_syncref_bit) & 0xF;
+		if (syncref == 0)
+			return HDSPM_AES32_AUTOSYNC_FROM_WORD;
+		if (syncref <= 8)
+			return syncref;
+		return HDSPM_AES32_AUTOSYNC_FROM_NONE;
+	} else {
+		/* This looks at the autosync selected sync reference */
+		unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+
+		switch (status2 & HDSPM_SelSyncRefMask) {
+		case HDSPM_SelSyncRef_WORD:
+			return HDSPM_AUTOSYNC_FROM_WORD;
+		case HDSPM_SelSyncRef_MADI:
+			return HDSPM_AUTOSYNC_FROM_MADI;
+		case HDSPM_SelSyncRef_NVALID:
+			return HDSPM_AUTOSYNC_FROM_NONE;
+		default:
+			return 0;
+		}
 
-	default:
 		return 0;
 	}
-
-	return 0;
 }
 
 static int snd_hdspm_info_autosync_ref(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "WordClock", "MADI", "None" };
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
-	uinfo->count = 1;
-	uinfo->value.enumerated.items = 3;
-	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
-		uinfo->value.enumerated.item =
-		    uinfo->value.enumerated.items - 1;
-	strcpy(uinfo->value.enumerated.name,
-	       texts[uinfo->value.enumerated.item]);
+	if (hdspm->is_aes32) {
+		static char *texts[] = { "WordClock", "AES1", "AES2", "AES3",
+			"AES4",	"AES5", "AES6", "AES7", "AES8", "None"};
+
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+		uinfo->count = 1;
+		uinfo->value.enumerated.items = 10;
+		if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+			uinfo->value.enumerated.item =
+				uinfo->value.enumerated.items - 1;
+		strcpy(uinfo->value.enumerated.name,
+				texts[uinfo->value.enumerated.item]);
+	}
+	else
+	{
+		static char *texts[] = { "WordClock", "MADI", "None" };
+
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+		uinfo->count = 1;
+		uinfo->value.enumerated.items = 3;
+		if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+			uinfo->value.enumerated.item =
+				uinfo->value.enumerated.items - 1;
+		strcpy(uinfo->value.enumerated.name,
+				texts[uinfo->value.enumerated.item]);
+	}
 	return 0;
 }
 
@@ -1787,45 +2003,376 @@ static int snd_hdspm_put_c_tms(struct snd_kcontrol *kcontrol,
   .put = snd_hdspm_put_safe_mode \
 }
 
-static int hdspm_safe_mode(struct hdspm * hdspm)
+static int hdspm_safe_mode(struct hdspm * hdspm)
+{
+	return (hdspm->control_register & HDSPM_AutoInp) ? 1 : 0;
+}
+
+static int hdspm_set_safe_mode(struct hdspm * hdspm, int out)
+{
+	if (out)
+		hdspm->control_register |= HDSPM_AutoInp;
+	else
+		hdspm->control_register &= ~HDSPM_AutoInp;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_safe_mode(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_safe_mode(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.integer.value[0] = hdspm_safe_mode(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_safe_mode(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_safe_mode(hdspm);
+	hdspm_set_safe_mode(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_EMPHASIS(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_emphasis, \
+  .get = snd_hdspm_get_emphasis, \
+  .put = snd_hdspm_put_emphasis \
+}
+
+static int hdspm_emphasis(struct hdspm * hdspm)
+{
+	return (hdspm->control_register & HDSPM_Emphasis) ? 1 : 0;
+}
+
+static int hdspm_set_emphasis(struct hdspm * hdspm, int emp)
+{
+	if (emp)
+		hdspm->control_register |= HDSPM_Emphasis;
+	else
+		hdspm->control_register &= ~HDSPM_Emphasis;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_emphasis(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_emphasis(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.enumerated.item[0] = hdspm_emphasis(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_emphasis(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_emphasis(hdspm);
+	hdspm_set_emphasis(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_DOLBY(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_dolby, \
+  .get = snd_hdspm_get_dolby, \
+  .put = snd_hdspm_put_dolby \
+}
+
+static int hdspm_dolby(struct hdspm * hdspm)
+{
+	return (hdspm->control_register & HDSPM_Dolby) ? 1 : 0;
+}
+
+static int hdspm_set_dolby(struct hdspm * hdspm, int dol)
+{
+	if (dol)
+		hdspm->control_register |= HDSPM_Dolby;
+	else
+		hdspm->control_register &= ~HDSPM_Dolby;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_dolby(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_dolby(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.enumerated.item[0] = hdspm_dolby(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_dolby(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_dolby(hdspm);
+	hdspm_set_dolby(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_PROFESSIONAL(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_professional, \
+  .get = snd_hdspm_get_professional, \
+  .put = snd_hdspm_put_professional \
+}
+
+static int hdspm_professional(struct hdspm * hdspm)
+{
+	return (hdspm->control_register & HDSPM_Professional) ? 1 : 0;
+}
+
+static int hdspm_set_professional(struct hdspm * hdspm, int dol)
+{
+	if (dol)
+		hdspm->control_register |= HDSPM_Professional;
+	else
+		hdspm->control_register &= ~HDSPM_Professional;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_professional(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_professional(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.enumerated.item[0] = hdspm_professional(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_professional(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_professional(hdspm);
+	hdspm_set_professional(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_INPUT_SELECT(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_input_select, \
+  .get = snd_hdspm_get_input_select, \
+  .put = snd_hdspm_put_input_select \
+}
+
+static int hdspm_input_select(struct hdspm * hdspm)
+{
+	return (hdspm->control_register & HDSPM_InputSelect0) ? 1 : 0;
+}
+
+static int hdspm_set_input_select(struct hdspm * hdspm, int out)
+{
+	if (out)
+		hdspm->control_register |= HDSPM_InputSelect0;
+	else
+		hdspm->control_register &= ~HDSPM_InputSelect0;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_input_select(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_info *uinfo)
+{
+	static char *texts[] = { "optical", "coaxial" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+
+	return 0;
+}
+
+static int snd_hdspm_get_input_select(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.enumerated.item[0] = hdspm_input_select(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_input_select(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_input_select(hdspm);
+	hdspm_set_input_select(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_DS_WIRE(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_ds_wire, \
+  .get = snd_hdspm_get_ds_wire, \
+  .put = snd_hdspm_put_ds_wire \
+}
+
+static int hdspm_ds_wire(struct hdspm * hdspm)
 {
-	return (hdspm->control_register & HDSPM_AutoInp) ? 1 : 0;
+	return (hdspm->control_register & HDSPM_DS_DoubleWire) ? 1 : 0;
 }
 
-static int hdspm_set_safe_mode(struct hdspm * hdspm, int out)
+static int hdspm_set_ds_wire(struct hdspm * hdspm, int ds)
 {
-	if (out)
-		hdspm->control_register |= HDSPM_AutoInp;
+	if (ds)
+		hdspm->control_register |= HDSPM_DS_DoubleWire;
 	else
-		hdspm->control_register &= ~HDSPM_AutoInp;
+		hdspm->control_register &= ~HDSPM_DS_DoubleWire;
 	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
 
 	return 0;
 }
 
-static int snd_hdspm_info_safe_mode(struct snd_kcontrol *kcontrol,
-				    struct snd_ctl_elem_info *uinfo)
+static int snd_hdspm_info_ds_wire(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_info *uinfo)
 {
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	static char *texts[] = { "Single", "Double" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = 1;
+	uinfo->value.enumerated.items = 2;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+
 	return 0;
 }
 
-static int snd_hdspm_get_safe_mode(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *ucontrol)
+static int snd_hdspm_get_ds_wire(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&hdspm->lock);
-	ucontrol->value.integer.value[0] = hdspm_safe_mode(hdspm);
+	ucontrol->value.enumerated.item[0] = hdspm_ds_wire(hdspm);
 	spin_unlock_irq(&hdspm->lock);
 	return 0;
 }
 
-static int snd_hdspm_put_safe_mode(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *ucontrol)
+static int snd_hdspm_put_ds_wire(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int change;
@@ -1835,45 +2382,56 @@ static int snd_hdspm_put_safe_mode(struct snd_kcontrol *kcontrol,
 		return -EBUSY;
 	val = ucontrol->value.integer.value[0] & 1;
 	spin_lock_irq(&hdspm->lock);
-	change = (int) val != hdspm_safe_mode(hdspm);
-	hdspm_set_safe_mode(hdspm, val);
+	change = (int) val != hdspm_ds_wire(hdspm);
+	hdspm_set_ds_wire(hdspm, val);
 	spin_unlock_irq(&hdspm->lock);
 	return change;
 }
 
-#define HDSPM_INPUT_SELECT(xname, xindex) \
+#define HDSPM_QS_WIRE(xname, xindex) \
 { .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
-  .info = snd_hdspm_info_input_select, \
-  .get = snd_hdspm_get_input_select, \
-  .put = snd_hdspm_put_input_select \
+  .info = snd_hdspm_info_qs_wire, \
+  .get = snd_hdspm_get_qs_wire, \
+  .put = snd_hdspm_put_qs_wire \
 }
 
-static int hdspm_input_select(struct hdspm * hdspm)
+static int hdspm_qs_wire(struct hdspm * hdspm)
 {
-	return (hdspm->control_register & HDSPM_InputSelect0) ? 1 : 0;
+	if (hdspm->control_register & HDSPM_QS_DoubleWire)
+		return 1;
+	if (hdspm->control_register & HDSPM_QS_QuadWire)
+		return 2;
+	return 0;
 }
 
-static int hdspm_set_input_select(struct hdspm * hdspm, int out)
+static int hdspm_set_qs_wire(struct hdspm * hdspm, int mode)
 {
-	if (out)
-		hdspm->control_register |= HDSPM_InputSelect0;
-	else
-		hdspm->control_register &= ~HDSPM_InputSelect0;
+	hdspm->control_register &= ~(HDSPM_QS_DoubleWire | HDSPM_QS_QuadWire);
+	switch (mode) {
+	case 0:
+		break;
+	case 1:
+		hdspm->control_register |= HDSPM_QS_DoubleWire;
+		break;
+	case 2:
+		hdspm->control_register |= HDSPM_QS_QuadWire;
+		break;
+	}
 	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
 
 	return 0;
 }
 
-static int snd_hdspm_info_input_select(struct snd_kcontrol *kcontrol,
+static int snd_hdspm_info_qs_wire(struct snd_kcontrol *kcontrol,
 				       struct snd_ctl_elem_info *uinfo)
 {
-	static char *texts[] = { "optical", "coaxial" };
+	static char *texts[] = { "Single", "Double", "Quad" };
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
-	uinfo->value.enumerated.items = 2;
+	uinfo->value.enumerated.items = 3;
 
 	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
 		uinfo->value.enumerated.item =
@@ -1884,30 +2442,34 @@ static int snd_hdspm_info_input_select(struct snd_kcontrol *kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_get_input_select(struct snd_kcontrol *kcontrol,
+static int snd_hdspm_get_qs_wire(struct snd_kcontrol *kcontrol,
 				      struct snd_ctl_elem_value *ucontrol)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&hdspm->lock);
-	ucontrol->value.enumerated.item[0] = hdspm_input_select(hdspm);
+	ucontrol->value.enumerated.item[0] = hdspm_qs_wire(hdspm);
 	spin_unlock_irq(&hdspm->lock);
 	return 0;
 }
 
-static int snd_hdspm_put_input_select(struct snd_kcontrol *kcontrol,
+static int snd_hdspm_put_qs_wire(struct snd_kcontrol *kcontrol,
 				      struct snd_ctl_elem_value *ucontrol)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int change;
-	unsigned int val;
+	int val;
 
 	if (!snd_hdspm_use_is_exclusive(hdspm))
 		return -EBUSY;
-	val = ucontrol->value.integer.value[0] & 1;
+	val = ucontrol->value.integer.value[0];
+	if (val < 0)
+		val = 0;
+	if (val > 2)
+		val = 2;
 	spin_lock_irq(&hdspm->lock);
-	change = (int) val != hdspm_input_select(hdspm);
-	hdspm_set_input_select(hdspm, val);
+	change = (int) val != hdspm_qs_wire(hdspm);
+	hdspm_set_qs_wire(hdspm, val);
 	spin_unlock_irq(&hdspm->lock);
 	return change;
 }
@@ -2135,14 +2697,24 @@ static int snd_hdspm_info_sync_check(struct snd_kcontrol *kcontrol,
 
 static int hdspm_wc_sync_check(struct hdspm * hdspm)
 {
-	int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
-	if (status2 & HDSPM_wcLock) {
-		if (status2 & HDSPM_wcSync)
+	if (hdspm->is_aes32) {
+		int status = hdspm_read(hdspm, HDSPM_statusRegister);
+		if (status & HDSPM_AES32_wcLock) {
+			/* I don't know how to differenciate sync from lock.
+			   Doing as if sync for now */
 			return 2;
-		else
-			return 1;
+		}
+		return 0;
+	} else {
+		int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+		if (status2 & HDSPM_wcLock) {
+			if (status2 & HDSPM_wcSync)
+				return 2;
+			else
+				return 1;
+		}
+		return 0;
 	}
-	return 0;
 }
 
 static int snd_hdspm_get_wc_sync_check(struct snd_kcontrol *kcontrol,
@@ -2188,9 +2760,43 @@ static int snd_hdspm_get_madisync_sync_check(struct snd_kcontrol *kcontrol,
 }
 
 
+#define HDSPM_AES_SYNC_CHECK(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  .info = snd_hdspm_info_sync_check, \
+  .get = snd_hdspm_get_aes_sync_check \
+}
+
+static int hdspm_aes_sync_check(struct hdspm * hdspm, int idx)
+{
+	int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+	if (status2 & (HDSPM_LockAES >> idx)) {
+		/* I don't know how to differenciate sync from lock.
+		   Doing as if sync for now */
+		return 2;
+	}
+	return 0;
+}
+
+static int snd_hdspm_get_aes_sync_check(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	int offset;
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+
+	offset = ucontrol->id.index - 1;
+	if (offset < 0 || offset >= 8)
+		return -EINVAL;
+
+	ucontrol->value.enumerated.item[0] =
+		hdspm_aes_sync_check(hdspm, offset);
+	return 0;
+}
 
 
-static struct snd_kcontrol_new snd_hdspm_controls[] = {
+static struct snd_kcontrol_new snd_hdspm_controls_madi[] = {
 
 	HDSPM_MIXER("Mixer", 0),
 /* 'Sample Clock Source' complies with the alsa control naming scheme */
@@ -2211,6 +2817,29 @@ static struct snd_kcontrol_new snd_hdspm_controls[] = {
 	HDSPM_INPUT_SELECT("Input Select", 0),
 };
 
+static struct snd_kcontrol_new snd_hdspm_controls_aes32[] = {
+
+	HDSPM_MIXER("Mixer", 0),
+/* 'Sample Clock Source' complies with the alsa control naming scheme */
+	HDSPM_CLOCK_SOURCE("Sample Clock Source", 0),
+
+	HDSPM_SYSTEM_CLOCK_MODE("System Clock Mode", 0),
+	HDSPM_PREF_SYNC_REF("Preferred Sync Reference", 0),
+	HDSPM_AUTOSYNC_REF("AutoSync Reference", 0),
+	HDSPM_SYSTEM_SAMPLE_RATE("System Sample Rate", 0),
+/* 'External Rate' complies with the alsa control naming scheme */
+	HDSPM_AUTOSYNC_SAMPLE_RATE("External Rate", 0),
+	HDSPM_WC_SYNC_CHECK("Word Clock Lock Status", 0),
+/*	HDSPM_AES_SYNC_CHECK("AES Lock Status", 0),*/ /* created in snd_hdspm_create_controls() */
+	HDSPM_LINE_OUT("Line Out", 0),
+	HDSPM_EMPHASIS("Emphasis", 0),
+	HDSPM_DOLBY("Non Audio", 0),
+	HDSPM_PROFESSIONAL("Professional", 0),
+	HDSPM_C_TMS("Clear Track Marker", 0),
+	HDSPM_DS_WIRE("Double Speed Wire Mode", 0),
+	HDSPM_QS_WIRE("Quad Speed Wire Mode", 0),
+};
+
 static struct snd_kcontrol_new snd_hdspm_playback_mixer = HDSPM_PLAYBACK_MIXER;
 
 
@@ -2245,20 +2874,40 @@ static int snd_hdspm_create_controls(struct snd_card *card, struct hdspm * hdspm
 	struct snd_kcontrol *kctl;
 
 	/* add control list first */
-
-	for (idx = 0; idx < ARRAY_SIZE(snd_hdspm_controls); idx++) {
-		if ((err =
-		     snd_ctl_add(card, kctl =
-				 snd_ctl_new1(&snd_hdspm_controls[idx],
-					      hdspm))) < 0) {
-			return err;
+	if (hdspm->is_aes32) {
+		struct snd_kcontrol_new aes_sync_ctl =
+			HDSPM_AES_SYNC_CHECK("AES Lock Status", 0);
+
+		for (idx = 0; idx < ARRAY_SIZE(snd_hdspm_controls_aes32);
+		     idx++) {
+			err = snd_ctl_add(card,
+					  snd_ctl_new1(&snd_hdspm_controls_aes32[idx],
+						       hdspm));
+			if (err < 0)
+				return err;
+		}
+		for (idx = 1; idx <= 8; idx++) {
+			aes_sync_ctl.index = idx;
+			err = snd_ctl_add(card,
+					  snd_ctl_new1(&aes_sync_ctl, hdspm));
+			if (err < 0)
+				return err;
+		}
+	} else {
+		for (idx = 0; idx < ARRAY_SIZE(snd_hdspm_controls_madi);
+		     idx++) {
+			err = snd_ctl_add(card,
+					  snd_ctl_new1(&snd_hdspm_controls_madi[idx],
+						       hdspm));
+			if (err < 0)
+				return err;
 		}
 	}
 
 	/* Channel playback mixer as default control 
-	   Note: the whole matrix would be 128*HDSPM_MIXER_CHANNELS Faders, thats too big for any alsamixer
-	   they are accesible via special IOCTL on hwdep
-	   and the mixer 2dimensional mixer control */
+Note: the whole matrix would be 128*HDSPM_MIXER_CHANNELS Faders, thats too big for any alsamixer
+they are accesible via special IOCTL on hwdep
+and the mixer 2dimensional mixer control */
 
 	snd_hdspm_playback_mixer.name = "Chn";
 	limit = HDSPM_MAX_CHANNELS;
@@ -2289,7 +2938,8 @@ static int snd_hdspm_create_controls(struct snd_card *card, struct hdspm * hdspm
  ------------------------------------------------------------*/
 
 static void
-snd_hdspm_proc_read(struct snd_info_entry * entry, struct snd_info_buffer *buffer)
+snd_hdspm_proc_read_madi(struct snd_info_entry * entry,
+			 struct snd_info_buffer *buffer)
 {
 	struct hdspm *hdspm = (struct hdspm *) entry->private_data;
 	unsigned int status;
@@ -2420,11 +3070,10 @@ snd_hdspm_proc_read(struct snd_info_entry * entry, struct snd_info_buffer *buffe
 		clock_source = "Error";
 	}
 	snd_iprintf(buffer, "Sample Clock Source: %s\n", clock_source);
-	if (!(hdspm->control_register & HDSPM_ClockModeMaster)) {
+	if (!(hdspm->control_register & HDSPM_ClockModeMaster))
 		system_clock_mode = "Slave";
-	} else {
+	else
 		system_clock_mode = "Master";
-	}
 	snd_iprintf(buffer, "System Clock Mode: %s\n", system_clock_mode);
 
 	switch (hdspm_pref_sync_ref(hdspm)) {
@@ -2484,13 +3133,213 @@ snd_hdspm_proc_read(struct snd_info_entry * entry, struct snd_info_buffer *buffe
 	snd_iprintf(buffer, "\n");
 }
 
+static void
+snd_hdspm_proc_read_aes32(struct snd_info_entry * entry,
+			  struct snd_info_buffer *buffer)
+{
+	struct hdspm *hdspm = (struct hdspm *) entry->private_data;
+	unsigned int status;
+	unsigned int status2;
+	unsigned int timecode;
+	int pref_syncref;
+	char *autosync_ref;
+	char *system_clock_mode;
+	char *clock_source;
+	int x;
+
+	status = hdspm_read(hdspm, HDSPM_statusRegister);
+	status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+	timecode = hdspm_read(hdspm, HDSPM_timecodeRegister);
+
+	snd_iprintf(buffer, "%s (Card #%d) Rev.%x\n",
+		    hdspm->card_name, hdspm->card->number + 1,
+		    hdspm->firmware_rev);
+
+	snd_iprintf(buffer, "IRQ: %d Registers bus: 0x%lx VM: 0x%lx\n",
+		    hdspm->irq, hdspm->port, (unsigned long)hdspm->iobase);
+
+	snd_iprintf(buffer, "--- System ---\n");
+
+	snd_iprintf(buffer,
+		    "IRQ Pending: Audio=%d, MIDI0=%d, MIDI1=%d, IRQcount=%d\n",
+		    status & HDSPM_audioIRQPending,
+		    (status & HDSPM_midi0IRQPending) ? 1 : 0,
+		    (status & HDSPM_midi1IRQPending) ? 1 : 0,
+		    hdspm->irq_count);
+	snd_iprintf(buffer,
+		    "HW pointer: id = %d, rawptr = %d (%d->%d) estimated= %ld (bytes)\n",
+		    ((status & HDSPM_BufferID) ? 1 : 0),
+		    (status & HDSPM_BufferPositionMask),
+		    (status & HDSPM_BufferPositionMask) % (2 *
+							   (int)hdspm->
+							   period_bytes),
+		    ((status & HDSPM_BufferPositionMask) -
+		     64) % (2 * (int)hdspm->period_bytes),
+		    (long) hdspm_hw_pointer(hdspm) * 4);
+
+	snd_iprintf(buffer,
+		    "MIDI FIFO: Out1=0x%x, Out2=0x%x, In1=0x%x, In2=0x%x \n",
+		    hdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xFF,
+		    hdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xFF,
+		    hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,
+		    hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);
+	snd_iprintf(buffer,
+		    "Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, status2=0x%x, timecode=0x%x\n",
+		    hdspm->control_register, hdspm->control2_register,
+		    status, status2, timecode);
+
+	snd_iprintf(buffer, "--- Settings ---\n");
+
+	x = 1 << (6 +
+		  hdspm_decode_latency(hdspm->
+				       control_register &
+				       HDSPM_LatencyMask));
+
+	snd_iprintf(buffer,
+		    "Size (Latency): %d samples (2 periods of %lu bytes)\n",
+		    x, (unsigned long) hdspm->period_bytes);
+
+	snd_iprintf(buffer, "Line out: %s,   Precise Pointer: %s\n",
+		    (hdspm->
+		     control_register & HDSPM_LineOut) ? "on " : "off",
+		    (hdspm->precise_ptr) ? "on" : "off");
+
+	snd_iprintf(buffer,
+		    "ClearTrackMarker %s, Emphasis %s, Dolby %s\n",
+		    (hdspm->
+		     control_register & HDSPM_clr_tms) ? "on" : "off",
+		    (hdspm->
+		     control_register & HDSPM_Emphasis) ? "on" : "off",
+		    (hdspm->
+		     control_register & HDSPM_Dolby) ? "on" : "off");
+
+	switch (hdspm_clock_source(hdspm)) {
+	case HDSPM_CLOCK_SOURCE_AUTOSYNC:
+		clock_source = "AutoSync";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_32KHZ:
+		clock_source = "Internal 32 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_44_1KHZ:
+		clock_source = "Internal 44.1 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_48KHZ:
+		clock_source = "Internal 48 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_64KHZ:
+		clock_source = "Internal 64 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_88_2KHZ:
+		clock_source = "Internal 88.2 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_96KHZ:
+		clock_source = "Internal 96 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_128KHZ:
+		clock_source = "Internal 128 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_176_4KHZ:
+		clock_source = "Internal 176.4 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_192KHZ:
+		clock_source = "Internal 192 kHz";
+		break;
+	default:
+		clock_source = "Error";
+	}
+	snd_iprintf(buffer, "Sample Clock Source: %s\n", clock_source);
+	if (!(hdspm->control_register & HDSPM_ClockModeMaster))
+		system_clock_mode = "Slave";
+	else
+		system_clock_mode = "Master";
+	snd_iprintf(buffer, "System Clock Mode: %s\n", system_clock_mode);
+
+	pref_syncref = hdspm_pref_sync_ref(hdspm);
+	if (pref_syncref == 0)
+		snd_iprintf(buffer, "Preferred Sync Reference: Word Clock\n");
+	else
+		snd_iprintf(buffer, "Preferred Sync Reference: AES%d\n",
+				pref_syncref);
+
+	snd_iprintf(buffer, "System Clock Frequency: %d\n",
+		    hdspm->system_sample_rate);
+
+	snd_iprintf(buffer, "Double speed: %s\n",
+			hdspm->control_register & HDSPM_DS_DoubleWire?
+			"Double wire" : "Single wire");
+	snd_iprintf(buffer, "Quad speed: %s\n",
+			hdspm->control_register & HDSPM_QS_DoubleWire?
+			"Double wire" :
+			hdspm->control_register & HDSPM_QS_QuadWire?
+			"Quad wire" : "Single wire");
+
+	snd_iprintf(buffer, "--- Status:\n");
+
+	snd_iprintf(buffer, "Word: %s  Frequency: %d\n",
+			(status & HDSPM_AES32_wcLock)? "Sync   " : "No Lock",
+			HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit) & 0xF));
+
+	for (x = 0; x < 8; x++) {
+		snd_iprintf(buffer, "AES%d: %s  Frequency: %d\n",
+				x+1,
+				(status2 & (HDSPM_LockAES >> x))? "Sync   ": "No Lock",
+				HDSPM_bit2freq((timecode >> (4*x)) & 0xF));
+	}
+
+	switch (hdspm_autosync_ref(hdspm)) {
+	case HDSPM_AES32_AUTOSYNC_FROM_NONE: autosync_ref="None"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_WORD: autosync_ref="Word Clock"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES1: autosync_ref="AES1"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES2: autosync_ref="AES2"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES3: autosync_ref="AES3"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES4: autosync_ref="AES4"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES5: autosync_ref="AES5"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES6: autosync_ref="AES6"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES7: autosync_ref="AES7"; break;
+	case HDSPM_AES32_AUTOSYNC_FROM_AES8: autosync_ref="AES8"; break;
+	default: autosync_ref = "---"; break;
+	}
+	snd_iprintf(buffer, "AutoSync ref = %s\n", autosync_ref);
+
+	snd_iprintf(buffer, "\n");
+}
+
+#ifdef CONFIG_SND_DEBUG
+static void
+snd_hdspm_proc_read_debug(struct snd_info_entry * entry,
+			  struct snd_info_buffer *buffer)
+{
+	struct hdspm *hdspm = (struct hdspm *)entry->private_data;
+
+	int j,i;
+
+	for (i = 0; i < 256 /* 1024*64 */; i += j)
+	{
+		snd_iprintf(buffer, "0x%08X: ", i);
+		for (j = 0; j < 16; j += 4)
+			snd_iprintf(buffer, "%08X ", hdspm_read(hdspm, i + j));
+		snd_iprintf(buffer, "\n");
+	}
+}
+#endif
+
+
+
 static void __devinit snd_hdspm_proc_init(struct hdspm * hdspm)
 {
 	struct snd_info_entry *entry;
 
 	if (!snd_card_proc_new(hdspm->card, "hdspm", &entry))
 		snd_info_set_text_ops(entry, hdspm,
-				      snd_hdspm_proc_read);
+				      hdspm->is_aes32 ?
+				      snd_hdspm_proc_read_aes32 :
+				      snd_hdspm_proc_read_madi);
+#ifdef CONFIG_SND_DEBUG
+	/* debug file to read all hdspm registers */
+	if (!snd_card_proc_new(hdspm->card, "debug", &entry))
+		snd_info_set_text_ops(entry, hdspm,
+				snd_hdspm_proc_read_debug);
+#endif
 }
 
 /*------------------------------------------------------------
@@ -2507,13 +3356,20 @@ static int snd_hdspm_set_defaults(struct hdspm * hdspm)
 
 	/* set defaults:       */
 
-	hdspm->control_register = HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
-	    hdspm_encode_latency(7) |	/* latency maximum = 8192 samples */
-	    HDSPM_InputCoaxial |	/* Input Coax not Optical */
-	    HDSPM_SyncRef_MADI |	/* Madi is syncclock */
-	    HDSPM_LineOut |	/* Analog output in */
-	    HDSPM_TX_64ch |	/* transmit in 64ch mode */
-	    HDSPM_AutoInp;	/* AutoInput chossing (takeover) */
+	if (hdspm->is_aes32)
+		hdspm->control_register = HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
+			hdspm_encode_latency(7) |	/* latency maximum = 8192 samples */
+			HDSPM_SyncRef0 |	/* AES1 is syncclock */
+			HDSPM_LineOut |	/* Analog output in */
+			HDSPM_Professional;  /* Professional mode */
+	else
+		hdspm->control_register = HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
+			hdspm_encode_latency(7) |	/* latency maximum = 8192 samples */
+			HDSPM_InputCoaxial |	/* Input Coax not Optical */
+			HDSPM_SyncRef_MADI |	/* Madi is syncclock */
+			HDSPM_LineOut |	/* Analog output in */
+			HDSPM_TX_64ch |	/* transmit in 64ch mode */
+			HDSPM_AutoInp;	/* AutoInput chossing (takeover) */
 
 	/* ! HDSPM_Frequency0|HDSPM_Frequency1 = 44.1khz */
 	/* !  HDSPM_DoubleSpeed HDSPM_QuadSpeed = normal speed */
@@ -2822,6 +3678,8 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 
 		hdspm->playback_buffer =
 		    (unsigned char *) substream->runtime->dma_area;
+		snd_printdd("Allocated sample buffer for playback at 0x%08X\n",
+				hdspm->playback_buffer);
 	} else {
 		hdspm_set_sgbuf(hdspm, sgbuf, HDSPM_pageAddressBufferIn,
 				params_channels(params));
@@ -2831,7 +3689,15 @@ static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
 
 		hdspm->capture_buffer =
 		    (unsigned char *) substream->runtime->dma_area;
+		snd_printdd("Allocated sample buffer for capture at 0x%08X\n",
+				hdspm->capture_buffer);
 	}
+	/*
+	   snd_printdd("Allocated sample buffer for %s at 0x%08X\n",
+	   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+	   "playback" : "capture",
+	   snd_pcm_sgbuf_get_addr(sgbuf, 0));
+	 */
 	return 0;
 }
 
@@ -2982,9 +3848,10 @@ static struct snd_pcm_hardware snd_hdspm_playback_subinfo = {
 		  SNDRV_PCM_RATE_44100 |
 		  SNDRV_PCM_RATE_48000 |
 		  SNDRV_PCM_RATE_64000 |
-		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000),
+		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
+		  SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000 ),
 	.rate_min = 32000,
-	.rate_max = 96000,
+	.rate_max = 192000,
 	.channels_min = 1,
 	.channels_max = HDSPM_MAX_CHANNELS,
 	.buffer_bytes_max =
@@ -3006,9 +3873,10 @@ static struct snd_pcm_hardware snd_hdspm_capture_subinfo = {
 		  SNDRV_PCM_RATE_44100 |
 		  SNDRV_PCM_RATE_48000 |
 		  SNDRV_PCM_RATE_64000 |
-		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000),
+		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
+		  SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000),
 	.rate_min = 32000,
-	.rate_max = 96000,
+	.rate_max = 192000,
 	.channels_min = 1,
 	.channels_max = HDSPM_MAX_CHANNELS,
 	.buffer_bytes_max =
@@ -3315,7 +4183,8 @@ static int __devinit snd_hdspm_preallocate_memory(struct hdspm * hdspm)
 
 	pcm = hdspm->pcm;
 
-	wanted = HDSPM_DMA_AREA_BYTES + 4096;	/* dont know why, but it works */
+/*	wanted = HDSPM_DMA_AREA_BYTES + 4096;*/	/* dont know why, but it works */
+	wanted = HDSPM_DMA_AREA_BYTES;
 
 	if ((err =
 	     snd_pcm_lib_preallocate_pages_for_all(pcm,
@@ -3467,9 +4336,16 @@ static int __devinit snd_hdspm_create(struct snd_card *card, struct hdspm * hdsp
 	pci_read_config_word(hdspm->pci,
 			     PCI_CLASS_REVISION, &hdspm->firmware_rev);
 
-	strcpy(card->driver, "HDSPM");
+	hdspm->is_aes32 = (hdspm->firmware_rev >= HDSPM_AESREVISION);
+
 	strcpy(card->mixername, "Xilinx FPGA");
-	hdspm->card_name = "RME HDSPM MADI";
+	if (hdspm->is_aes32) {
+		strcpy(card->driver, "HDSPAES32");
+		hdspm->card_name = "RME HDSPM AES32";
+	} else {
+		strcpy(card->driver, "HDSPM");
+		hdspm->card_name = "RME HDSPM MADI";
+	}
 
 	if ((err = pci_enable_device(pci)) < 0)
 		return err;

commit 437a5a4606c12ab904793a7cad5b2062fc76c04e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 21 12:14:23 2006 +0100

    [ALSA] Remove IRQF_DISABLED for shared PCI irqs
    
    Fix IRQ flags for PCI devices.
    The shared IRQs for PCI devices shouldn't be allocated with
    IRQF_DISABLED.  Also, when MSI is enabled, IRQF_SHARED shouldn't
    be used.
    The patch removes unnecessary cast in request_irq and free_irq,
    too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Jaroslav Kysela <perex@suse.cz>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 7055d893855d..0547f6f04bdc 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3496,8 +3496,7 @@ static int __devinit snd_hdspm_create(struct snd_card *card, struct hdspm * hdsp
 		   hdspm->port + io_extent - 1);
 
 	if (request_irq(pci->irq, snd_hdspm_interrupt,
-			IRQF_DISABLED | IRQF_SHARED, "hdspm",
-			(void *) hdspm)) {
+			IRQF_SHARED, "hdspm", hdspm)) {
 		snd_printk(KERN_ERR "HDSPM: unable to use IRQ %d\n", pci->irq);
 		return -EBUSY;
 	}

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 7d03ae066d53..7055d893855d 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2556,8 +2556,7 @@ static int snd_hdspm_set_defaults(struct hdspm * hdspm)
    interupt 
  ------------------------------------------------------------*/
 
-static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id,
-				       struct pt_regs *regs)
+static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id)
 {
 	struct hdspm *hdspm = (struct hdspm *) dev_id;
 	unsigned int status;

commit 65ca68b30073473583f6ca2f463cbd94ade43ddb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:46 2006 -0700

    [PATCH] irq-flags: sound: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index bba1615504d3..7d03ae066d53 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3497,7 +3497,7 @@ static int __devinit snd_hdspm_create(struct snd_card *card, struct hdspm * hdsp
 		   hdspm->port + io_extent - 1);
 
 	if (request_irq(pci->irq, snd_hdspm_interrupt,
-			SA_INTERRUPT | SA_SHIRQ, "hdspm",
+			IRQF_DISABLED | IRQF_SHARED, "hdspm",
 			(void *) hdspm)) {
 		snd_printk(KERN_ERR "HDSPM: unable to use IRQ %d\n", pci->irq);
 		return -EBUSY;

commit bf850204a71a97eb5a6afaf27263bb667f9cab0a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Apr 28 15:13:41 2006 +0200

    [ALSA] Remove unneeded read/write_size fields in proc text ops
    
    Remove unneeded read/write_size fields in proc text ops.
    snd_info_set_text_ops() is fixed, too.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 722b9e6ce54a..bba1615504d3 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2489,7 +2489,7 @@ static void __devinit snd_hdspm_proc_init(struct hdspm * hdspm)
 	struct snd_info_entry *entry;
 
 	if (!snd_card_proc_new(hdspm->card, "hdspm", &entry))
-		snd_info_set_text_ops(entry, hdspm, 1024,
+		snd_info_set_text_ops(entry, hdspm,
 				      snd_hdspm_proc_read);
 }
 

commit 396c9b928d5c24775846a161a8191dcc1ea4971f
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Apr 24 15:59:04 2006 +0200

    [ALSA] add __devinitdata to all pci_device_id
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index b5538efd146b..722b9e6ce54a 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -426,7 +426,7 @@ static char channel_map_madi_qs[HDSPM_MAX_CHANNELS] = {
 };
 
 
-static struct pci_device_id snd_hdspm_ids[] = {
+static struct pci_device_id snd_hdspm_ids[] __devinitdata = {
 	{
 	 .vendor = PCI_VENDOR_ID_XILINX,
 	 .device = PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP_MADI,

commit 7f927fcc2fd1575d01efb4b76665975007945690
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Mar 28 01:56:53 2006 -0800

    [PATCH] Typo fixes
    
    Fix a lot of typos.  Eyeballed by jmc@ in OpenBSD.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 980b9cd689dd..b5538efd146b 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -2256,7 +2256,7 @@ static int snd_hdspm_create_controls(struct snd_card *card, struct hdspm * hdspm
 	}
 
 	/* Channel playback mixer as default control 
-	   Note: the whole matrix would be 128*HDSPM_MIXER_CHANNELS Faders, thats to big for any alsamixer 
+	   Note: the whole matrix would be 128*HDSPM_MIXER_CHANNELS Faders, thats too big for any alsamixer
 	   they are accesible via special IOCTL on hwdep
 	   and the mixer 2dimensional mixer control */
 

commit 5bab2482083077d1e14644db2546c54534156849
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Mar 13 14:15:04 2006 +0100

    [ALSA] sound/pci/rme9652/hdspm.c: fix off-by-one errors
    
    Modules: RME9652 driver
    
    This patch fixes off-by-one errors found by the Coverity checker.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 103b4d715ff4..980b9cd689dd 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -474,7 +474,7 @@ static inline unsigned int hdspm_read(struct hdspm * hdspm, unsigned int reg)
 static inline int hdspm_read_in_gain(struct hdspm * hdspm, unsigned int chan,
 				     unsigned int in)
 {
-	if (chan > HDSPM_MIXER_CHANNELS || in > HDSPM_MIXER_CHANNELS)
+	if (chan >= HDSPM_MIXER_CHANNELS || in >= HDSPM_MIXER_CHANNELS)
 		return 0;
 
 	return hdspm->mixer->ch[chan].in[in];
@@ -483,7 +483,7 @@ static inline int hdspm_read_in_gain(struct hdspm * hdspm, unsigned int chan,
 static inline int hdspm_read_pb_gain(struct hdspm * hdspm, unsigned int chan,
 				     unsigned int pb)
 {
-	if (chan > HDSPM_MIXER_CHANNELS || pb > HDSPM_MIXER_CHANNELS)
+	if (chan >= HDSPM_MIXER_CHANNELS || pb >= HDSPM_MIXER_CHANNELS)
 		return 0;
 	return hdspm->mixer->ch[chan].pb[pb];
 }

commit e2eba3e7d911b26525c17f0b7e2bc45aad8e2629
Author: Andrew Morton <akpm@osdl.org>
Date:   Fri Jan 20 14:07:13 2006 +0100

    [ALSA] hdsp - Fix printk warnings
    
    Modules: RME9652 driver
    
    sound/pci/rme9652/hdspm.c: In function 'snd_hdspm_preallocate_memory':
    sound/pci/rme9652/hdspm.c:3327: warning: int format, different type arg (arg 4)
    sound/pci/rme9652/hdspm.c:3331: warning: int format, different type arg (arg 4)
    sound/pci/rme9652/hdspm.c: In function 'snd_hdspm_create':
    sound/pci/rme9652/hdspm.c:3513: warning: int format, different type arg (arg 4)
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 3dec616bad6b..103b4d715ff4 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3324,11 +3324,11 @@ static int __devinit snd_hdspm_preallocate_memory(struct hdspm * hdspm)
 						   snd_dma_pci_data(hdspm->pci),
 						   wanted,
 						   wanted)) < 0) {
-		snd_printdd("Could not preallocate %d  Bytes\n", wanted);
+		snd_printdd("Could not preallocate %zd Bytes\n", wanted);
 
 		return err;
 	} else
-		snd_printdd(" Preallocated %d  Bytes\n", wanted);
+		snd_printdd(" Preallocated %zd Bytes\n", wanted);
 
 	return 0;
 }
@@ -3510,7 +3510,7 @@ static int __devinit snd_hdspm_create(struct snd_card *card, struct hdspm * hdsp
 
 	hdspm->monitor_outs = enable_monitor;
 
-	snd_printdd("kmalloc Mixer memory of %d Bytes\n",
+	snd_printdd("kmalloc Mixer memory of %zd Bytes\n",
 		   sizeof(struct hdspm_mixer));
 	if ((hdspm->mixer = kmalloc(sizeof(struct hdspm_mixer), GFP_KERNEL))
 	    == NULL) {

commit 98274f0701f9e6579ae493ac190227fe93d11e20
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Nov 17 14:52:34 2005 +0100

    [ALSA] Remove xxx_t typedefs: PCI HDSP-MADI
    
    Modules: HDSPM driver,RME9652 driver
    
    Remove xxx_t typedefs from the PCI HDSP-MADI driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index ae2013a8492d..3dec616bad6b 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -318,25 +318,22 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define HDSPM_DMA_AREA_BYTES (HDSPM_MAX_CHANNELS * HDSPM_CHANNEL_BUFFER_BYTES)
 #define HDSPM_DMA_AREA_KILOBYTES (HDSPM_DMA_AREA_BYTES/1024)
 
-typedef struct _hdspm hdspm_t;
-typedef struct _hdspm_midi hdspm_midi_t;
-
-struct _hdspm_midi {
-	hdspm_t *hdspm;
+struct hdspm_midi {
+	struct hdspm *hdspm;
 	int id;
-	snd_rawmidi_t *rmidi;
-	snd_rawmidi_substream_t *input;
-	snd_rawmidi_substream_t *output;
+	struct snd_rawmidi *rmidi;
+	struct snd_rawmidi_substream *input;
+	struct snd_rawmidi_substream *output;
 	char istimer;		/* timer in use */
 	struct timer_list timer;
 	spinlock_t lock;
 	int pending;
 };
 
-struct _hdspm {
+struct hdspm {
         spinlock_t lock;
-        snd_pcm_substream_t *capture_substream;	 /* only one playback */
-        snd_pcm_substream_t *playback_substream; /* and/or capture stream */
+        struct snd_pcm_substream *capture_substream;	 /* only one playback */
+        struct snd_pcm_substream *playback_substream; /* and/or capture stream */
 
 	char *card_name;	     /* for procinfo */
 	unsigned short firmware_rev; /* dont know if relevant */
@@ -347,7 +344,7 @@ struct _hdspm {
 	u32 control_register;	/* cached value */
 	u32 control2_register;	/* cached value */
 
-	hdspm_midi_t midi[2];
+	struct hdspm_midi midi[2];
 	struct tasklet_struct midi_tasklet;
 
 	size_t period_bytes;
@@ -375,15 +372,15 @@ struct _hdspm {
 
 	int irq_count;		/* for debug */
 
-	snd_card_t *card;	/* one card */
-	snd_pcm_t *pcm;		/* has one pcm */
-	snd_hwdep_t *hwdep;	/* and a hwdep for additional ioctl */
+	struct snd_card *card;	/* one card */
+	struct snd_pcm *pcm;		/* has one pcm */
+	struct snd_hwdep *hwdep;	/* and a hwdep for additional ioctl */
 	struct pci_dev *pci;	/* and an pci info */
 
 	/* Mixer vars */
-	snd_kcontrol_t *playback_mixer_ctls[HDSPM_MAX_CHANNELS];	/* fast alsa mixer */
-	snd_kcontrol_t *input_mixer_ctls[HDSPM_MAX_CHANNELS];	/* but input to much, so not used */
-	hdspm_mixer_t *mixer;	/* full mixer accessable over mixer ioctl or hwdep-device */
+	struct snd_kcontrol *playback_mixer_ctls[HDSPM_MAX_CHANNELS];	/* fast alsa mixer */
+	struct snd_kcontrol *input_mixer_ctls[HDSPM_MAX_CHANNELS];	/* but input to much, so not used */
+	struct hdspm_mixer *mixer;	/* full mixer accessable over mixer ioctl or hwdep-device */
 
 };
 
@@ -444,28 +441,28 @@ static struct pci_device_id snd_hdspm_ids[] = {
 MODULE_DEVICE_TABLE(pci, snd_hdspm_ids);
 
 /* prototypes */
-static int __devinit snd_hdspm_create_alsa_devices(snd_card_t * card,
-						   hdspm_t * hdspm);
-static int __devinit snd_hdspm_create_pcm(snd_card_t * card,
-					  hdspm_t * hdspm);
-
-static inline void snd_hdspm_initialize_midi_flush(hdspm_t * hdspm);
-static int hdspm_update_simple_mixer_controls(hdspm_t * hdspm);
-static int hdspm_autosync_ref(hdspm_t * hdspm);
-static int snd_hdspm_set_defaults(hdspm_t * hdspm);
-static void hdspm_set_sgbuf(hdspm_t * hdspm, struct snd_sg_buf *sgbuf,
+static int __devinit snd_hdspm_create_alsa_devices(struct snd_card *card,
+						   struct hdspm * hdspm);
+static int __devinit snd_hdspm_create_pcm(struct snd_card *card,
+					  struct hdspm * hdspm);
+
+static inline void snd_hdspm_initialize_midi_flush(struct hdspm * hdspm);
+static int hdspm_update_simple_mixer_controls(struct hdspm * hdspm);
+static int hdspm_autosync_ref(struct hdspm * hdspm);
+static int snd_hdspm_set_defaults(struct hdspm * hdspm);
+static void hdspm_set_sgbuf(struct hdspm * hdspm, struct snd_sg_buf *sgbuf,
 			     unsigned int reg, int channels);
 
 /* Write/read to/from HDSPM with Adresses in Bytes
    not words but only 32Bit writes are allowed */
 
-static inline void hdspm_write(hdspm_t * hdspm, unsigned int reg,
+static inline void hdspm_write(struct hdspm * hdspm, unsigned int reg,
 			       unsigned int val)
 {
 	writel(val, hdspm->iobase + reg);
 }
 
-static inline unsigned int hdspm_read(hdspm_t * hdspm, unsigned int reg)
+static inline unsigned int hdspm_read(struct hdspm * hdspm, unsigned int reg)
 {
 	return readl(hdspm->iobase + reg);
 }
@@ -474,7 +471,7 @@ static inline unsigned int hdspm_read(hdspm_t * hdspm, unsigned int reg)
    mixer is write only on hardware so we have to cache him for read 
    each fader is a u32, but uses only the first 16 bit */
 
-static inline int hdspm_read_in_gain(hdspm_t * hdspm, unsigned int chan,
+static inline int hdspm_read_in_gain(struct hdspm * hdspm, unsigned int chan,
 				     unsigned int in)
 {
 	if (chan > HDSPM_MIXER_CHANNELS || in > HDSPM_MIXER_CHANNELS)
@@ -483,7 +480,7 @@ static inline int hdspm_read_in_gain(hdspm_t * hdspm, unsigned int chan,
 	return hdspm->mixer->ch[chan].in[in];
 }
 
-static inline int hdspm_read_pb_gain(hdspm_t * hdspm, unsigned int chan,
+static inline int hdspm_read_pb_gain(struct hdspm * hdspm, unsigned int chan,
 				     unsigned int pb)
 {
 	if (chan > HDSPM_MIXER_CHANNELS || pb > HDSPM_MIXER_CHANNELS)
@@ -491,7 +488,7 @@ static inline int hdspm_read_pb_gain(hdspm_t * hdspm, unsigned int chan,
 	return hdspm->mixer->ch[chan].pb[pb];
 }
 
-static inline int hdspm_write_in_gain(hdspm_t * hdspm, unsigned int chan,
+static inline int hdspm_write_in_gain(struct hdspm * hdspm, unsigned int chan,
 				      unsigned int in, unsigned short data)
 {
 	if (chan >= HDSPM_MIXER_CHANNELS || in >= HDSPM_MIXER_CHANNELS)
@@ -504,7 +501,7 @@ static inline int hdspm_write_in_gain(hdspm_t * hdspm, unsigned int chan,
 	return 0;
 }
 
-static inline int hdspm_write_pb_gain(hdspm_t * hdspm, unsigned int chan,
+static inline int hdspm_write_pb_gain(struct hdspm * hdspm, unsigned int chan,
 				      unsigned int pb, unsigned short data)
 {
 	if (chan >= HDSPM_MIXER_CHANNELS || pb >= HDSPM_MIXER_CHANNELS)
@@ -519,18 +516,18 @@ static inline int hdspm_write_pb_gain(hdspm_t * hdspm, unsigned int chan,
 
 
 /* enable DMA for specific channels, now available for DSP-MADI */
-static inline void snd_hdspm_enable_in(hdspm_t * hdspm, int i, int v)
+static inline void snd_hdspm_enable_in(struct hdspm * hdspm, int i, int v)
 {
 	hdspm_write(hdspm, HDSPM_inputEnableBase + (4 * i), v);
 }
 
-static inline void snd_hdspm_enable_out(hdspm_t * hdspm, int i, int v)
+static inline void snd_hdspm_enable_out(struct hdspm * hdspm, int i, int v)
 {
 	hdspm_write(hdspm, HDSPM_outputEnableBase + (4 * i), v);
 }
 
 /* check if same process is writing and reading */
-static inline int snd_hdspm_use_is_exclusive(hdspm_t * hdspm)
+static inline int snd_hdspm_use_is_exclusive(struct hdspm * hdspm)
 {
 	unsigned long flags;
 	int ret = 1;
@@ -545,7 +542,7 @@ static inline int snd_hdspm_use_is_exclusive(hdspm_t * hdspm)
 }
 
 /* check for external sample rate */
-static inline int hdspm_external_sample_rate(hdspm_t * hdspm)
+static inline int hdspm_external_sample_rate(struct hdspm * hdspm)
 {
 	unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
 	unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
@@ -630,13 +627,13 @@ static inline int hdspm_external_sample_rate(hdspm_t * hdspm)
 }
 
 /* Latency function */
-static inline void hdspm_compute_period_size(hdspm_t * hdspm)
+static inline void hdspm_compute_period_size(struct hdspm * hdspm)
 {
 	hdspm->period_bytes =
 	    1 << ((hdspm_decode_latency(hdspm->control_register) + 8));
 }
 
-static snd_pcm_uframes_t hdspm_hw_pointer(hdspm_t * hdspm)
+static snd_pcm_uframes_t hdspm_hw_pointer(struct hdspm * hdspm)
 {
 	int position;
 
@@ -660,20 +657,20 @@ static snd_pcm_uframes_t hdspm_hw_pointer(hdspm_t * hdspm)
 }
 
 
-static inline void hdspm_start_audio(hdspm_t * s)
+static inline void hdspm_start_audio(struct hdspm * s)
 {
 	s->control_register |= (HDSPM_AudioInterruptEnable | HDSPM_Start);
 	hdspm_write(s, HDSPM_controlRegister, s->control_register);
 }
 
-static inline void hdspm_stop_audio(hdspm_t * s)
+static inline void hdspm_stop_audio(struct hdspm * s)
 {
 	s->control_register &= ~(HDSPM_Start | HDSPM_AudioInterruptEnable);
 	hdspm_write(s, HDSPM_controlRegister, s->control_register);
 }
 
 /* should I silence all or only opened ones ? doit all for first even is 4MB*/
-static inline void hdspm_silence_playback(hdspm_t * hdspm)
+static inline void hdspm_silence_playback(struct hdspm * hdspm)
 {
 	int i;
 	int n = hdspm->period_bytes;
@@ -687,7 +684,7 @@ static inline void hdspm_silence_playback(hdspm_t * hdspm)
 	}
 }
 
-static int hdspm_set_interrupt_interval(hdspm_t * s, unsigned int frames)
+static int hdspm_set_interrupt_interval(struct hdspm * s, unsigned int frames)
 {
 	int n;
 
@@ -713,7 +710,7 @@ static int hdspm_set_interrupt_interval(hdspm_t * s, unsigned int frames)
 
 
 /* dummy set rate lets see what happens */
-static int hdspm_set_rate(hdspm_t * hdspm, int rate, int called_internally)
+static int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)
 {
 	int reject_if_open = 0;
 	int current_rate;
@@ -838,7 +835,7 @@ static int hdspm_set_rate(hdspm_t * hdspm, int rate, int called_internally)
 }
 
 /* mainly for init to 0 on load */
-static void all_in_all_mixer(hdspm_t * hdspm, int sgain)
+static void all_in_all_mixer(struct hdspm * hdspm, int sgain)
 {
 	int i, j;
 	unsigned int gain =
@@ -855,7 +852,7 @@ static void all_in_all_mixer(hdspm_t * hdspm, int sgain)
    MIDI
   ----------------------------------------------------------------------------*/
 
-static inline unsigned char snd_hdspm_midi_read_byte (hdspm_t *hdspm, int id)
+static inline unsigned char snd_hdspm_midi_read_byte (struct hdspm *hdspm, int id)
 {
 	/* the hardware already does the relevant bit-mask with 0xff */
 	if (id)
@@ -864,7 +861,7 @@ static inline unsigned char snd_hdspm_midi_read_byte (hdspm_t *hdspm, int id)
 		return hdspm_read(hdspm, HDSPM_midiDataIn0);
 }
 
-static inline void snd_hdspm_midi_write_byte (hdspm_t *hdspm, int id, int val)
+static inline void snd_hdspm_midi_write_byte (struct hdspm *hdspm, int id, int val)
 {
 	/* the hardware already does the relevant bit-mask with 0xff */
 	if (id)
@@ -873,7 +870,7 @@ static inline void snd_hdspm_midi_write_byte (hdspm_t *hdspm, int id, int val)
 		return hdspm_write(hdspm, HDSPM_midiDataOut0, val);
 }
 
-static inline int snd_hdspm_midi_input_available (hdspm_t *hdspm, int id)
+static inline int snd_hdspm_midi_input_available (struct hdspm *hdspm, int id)
 {
 	if (id)
 		return (hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xff);
@@ -881,7 +878,7 @@ static inline int snd_hdspm_midi_input_available (hdspm_t *hdspm, int id)
 		return (hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xff);
 }
 
-static inline int snd_hdspm_midi_output_possible (hdspm_t *hdspm, int id)
+static inline int snd_hdspm_midi_output_possible (struct hdspm *hdspm, int id)
 {
 	int fifo_bytes_used;
 
@@ -896,13 +893,13 @@ static inline int snd_hdspm_midi_output_possible (hdspm_t *hdspm, int id)
 		return 0;
 }
 
-static inline void snd_hdspm_flush_midi_input (hdspm_t *hdspm, int id)
+static inline void snd_hdspm_flush_midi_input (struct hdspm *hdspm, int id)
 {
 	while (snd_hdspm_midi_input_available (hdspm, id))
 		snd_hdspm_midi_read_byte (hdspm, id);
 }
 
-static int snd_hdspm_midi_output_write (hdspm_midi_t *hmidi)
+static int snd_hdspm_midi_output_write (struct hdspm_midi *hmidi)
 {
 	unsigned long flags;
 	int n_pending;
@@ -930,7 +927,7 @@ static int snd_hdspm_midi_output_write (hdspm_midi_t *hmidi)
 	return 0;
 }
 
-static int snd_hdspm_midi_input_read (hdspm_midi_t *hmidi)
+static int snd_hdspm_midi_input_read (struct hdspm_midi *hmidi)
 {
 	unsigned char buf[128]; /* this buffer is designed to match the MIDI input FIFO size */
 	unsigned long flags;
@@ -967,14 +964,14 @@ static int snd_hdspm_midi_input_read (hdspm_midi_t *hmidi)
 	return snd_hdspm_midi_output_write (hmidi);
 }
 
-static void snd_hdspm_midi_input_trigger(snd_rawmidi_substream_t * substream, int up)
+static void snd_hdspm_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)
 {
-	hdspm_t *hdspm;
-	hdspm_midi_t *hmidi;
+	struct hdspm *hdspm;
+	struct hdspm_midi *hmidi;
 	unsigned long flags;
 	u32 ie;
 
-	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	hmidi = (struct hdspm_midi *) substream->rmidi->private_data;
 	hdspm = hmidi->hdspm;
 	ie = hmidi->id ? HDSPM_Midi1InterruptEnable : HDSPM_Midi0InterruptEnable;
 	spin_lock_irqsave (&hdspm->lock, flags);
@@ -993,7 +990,7 @@ static void snd_hdspm_midi_input_trigger(snd_rawmidi_substream_t * substream, in
 
 static void snd_hdspm_midi_output_timer(unsigned long data)
 {
-	hdspm_midi_t *hmidi = (hdspm_midi_t *) data;
+	struct hdspm_midi *hmidi = (struct hdspm_midi *) data;
 	unsigned long flags;
 	
 	snd_hdspm_midi_output_write(hmidi);
@@ -1013,12 +1010,12 @@ static void snd_hdspm_midi_output_timer(unsigned long data)
 	spin_unlock_irqrestore (&hmidi->lock, flags);
 }
 
-static void snd_hdspm_midi_output_trigger(snd_rawmidi_substream_t * substream, int up)
+static void snd_hdspm_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)
 {
-	hdspm_midi_t *hmidi;
+	struct hdspm_midi *hmidi;
 	unsigned long flags;
 
-	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	hmidi = (struct hdspm_midi *) substream->rmidi->private_data;
 	spin_lock_irqsave (&hmidi->lock, flags);
 	if (up) {
 		if (!hmidi->istimer) {
@@ -1039,11 +1036,11 @@ static void snd_hdspm_midi_output_trigger(snd_rawmidi_substream_t * substream, i
 		snd_hdspm_midi_output_write(hmidi);
 }
 
-static int snd_hdspm_midi_input_open(snd_rawmidi_substream_t * substream)
+static int snd_hdspm_midi_input_open(struct snd_rawmidi_substream *substream)
 {
-	hdspm_midi_t *hmidi;
+	struct hdspm_midi *hmidi;
 
-	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	hmidi = (struct hdspm_midi *) substream->rmidi->private_data;
 	spin_lock_irq (&hmidi->lock);
 	snd_hdspm_flush_midi_input (hmidi->hdspm, hmidi->id);
 	hmidi->input = substream;
@@ -1052,11 +1049,11 @@ static int snd_hdspm_midi_input_open(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static int snd_hdspm_midi_output_open(snd_rawmidi_substream_t * substream)
+static int snd_hdspm_midi_output_open(struct snd_rawmidi_substream *substream)
 {
-	hdspm_midi_t *hmidi;
+	struct hdspm_midi *hmidi;
 
-	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	hmidi = (struct hdspm_midi *) substream->rmidi->private_data;
 	spin_lock_irq (&hmidi->lock);
 	hmidi->output = substream;
 	spin_unlock_irq (&hmidi->lock);
@@ -1064,13 +1061,13 @@ static int snd_hdspm_midi_output_open(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static int snd_hdspm_midi_input_close(snd_rawmidi_substream_t * substream)
+static int snd_hdspm_midi_input_close(struct snd_rawmidi_substream *substream)
 {
-	hdspm_midi_t *hmidi;
+	struct hdspm_midi *hmidi;
 
 	snd_hdspm_midi_input_trigger (substream, 0);
 
-	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	hmidi = (struct hdspm_midi *) substream->rmidi->private_data;
 	spin_lock_irq (&hmidi->lock);
 	hmidi->input = NULL;
 	spin_unlock_irq (&hmidi->lock);
@@ -1078,13 +1075,13 @@ static int snd_hdspm_midi_input_close(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static int snd_hdspm_midi_output_close(snd_rawmidi_substream_t * substream)
+static int snd_hdspm_midi_output_close(struct snd_rawmidi_substream *substream)
 {
-	hdspm_midi_t *hmidi;
+	struct hdspm_midi *hmidi;
 
 	snd_hdspm_midi_output_trigger (substream, 0);
 
-	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	hmidi = (struct hdspm_midi *) substream->rmidi->private_data;
 	spin_lock_irq (&hmidi->lock);
 	hmidi->output = NULL;
 	spin_unlock_irq (&hmidi->lock);
@@ -1092,21 +1089,21 @@ static int snd_hdspm_midi_output_close(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-static snd_rawmidi_ops_t snd_hdspm_midi_output =
+static struct snd_rawmidi_ops snd_hdspm_midi_output =
 {
 	.open =		snd_hdspm_midi_output_open,
 	.close =	snd_hdspm_midi_output_close,
 	.trigger =	snd_hdspm_midi_output_trigger,
 };
 
-static snd_rawmidi_ops_t snd_hdspm_midi_input =
+static struct snd_rawmidi_ops snd_hdspm_midi_input =
 {
 	.open =		snd_hdspm_midi_input_open,
 	.close =	snd_hdspm_midi_input_close,
 	.trigger =	snd_hdspm_midi_input_trigger,
 };
 
-static int __devinit snd_hdspm_create_midi (snd_card_t *card, hdspm_t *hdspm, int id)
+static int __devinit snd_hdspm_create_midi (struct snd_card *card, struct hdspm *hdspm, int id)
 {
 	int err;
 	char buf[32];
@@ -1140,7 +1137,7 @@ static int __devinit snd_hdspm_create_midi (snd_card_t *card, hdspm_t *hdspm, in
 
 static void hdspm_midi_tasklet(unsigned long arg)
 {
-	hdspm_t *hdspm = (hdspm_t *)arg;
+	struct hdspm *hdspm = (struct hdspm *)arg;
 	
 	if (hdspm->midi[0].pending)
 		snd_hdspm_midi_input_read (&hdspm->midi[0]);
@@ -1164,19 +1161,19 @@ static void hdspm_midi_tasklet(unsigned long arg)
   .get = snd_hdspm_get_system_sample_rate \
 }
 
-static int snd_hdspm_info_system_sample_rate(snd_kcontrol_t * kcontrol,
-					     snd_ctl_elem_info_t * uinfo)
+static int snd_hdspm_info_system_sample_rate(struct snd_kcontrol *kcontrol,
+					     struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
 	return 0;
 }
 
-static int snd_hdspm_get_system_sample_rate(snd_kcontrol_t * kcontrol,
-					    snd_ctl_elem_value_t *
+static int snd_hdspm_get_system_sample_rate(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_value *
 					    ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	ucontrol->value.enumerated.item[0] = hdspm->system_sample_rate;
 	return 0;
@@ -1191,8 +1188,8 @@ static int snd_hdspm_get_system_sample_rate(snd_kcontrol_t * kcontrol,
   .get = snd_hdspm_get_autosync_sample_rate \
 }
 
-static int snd_hdspm_info_autosync_sample_rate(snd_kcontrol_t * kcontrol,
-					       snd_ctl_elem_info_t * uinfo)
+static int snd_hdspm_info_autosync_sample_rate(struct snd_kcontrol *kcontrol,
+					       struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "32000", "44100", "48000",
 		"64000", "88200", "96000",
@@ -1210,11 +1207,11 @@ static int snd_hdspm_info_autosync_sample_rate(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_get_autosync_sample_rate(snd_kcontrol_t * kcontrol,
-					      snd_ctl_elem_value_t *
+static int snd_hdspm_get_autosync_sample_rate(struct snd_kcontrol *kcontrol,
+					      struct snd_ctl_elem_value *
 					      ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	switch (hdspm_external_sample_rate(hdspm)) {
 	case 32000:
@@ -1262,7 +1259,7 @@ static int snd_hdspm_get_autosync_sample_rate(snd_kcontrol_t * kcontrol,
 
 
 
-static int hdspm_system_clock_mode(hdspm_t * hdspm)
+static int hdspm_system_clock_mode(struct hdspm * hdspm)
 {
         /* Always reflect the hardware info, rme is never wrong !!!! */
 
@@ -1271,8 +1268,8 @@ static int hdspm_system_clock_mode(hdspm_t * hdspm)
 	return 1;
 }
 
-static int snd_hdspm_info_system_clock_mode(snd_kcontrol_t * kcontrol,
-					    snd_ctl_elem_info_t * uinfo)
+static int snd_hdspm_info_system_clock_mode(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "Master", "Slave" };
 
@@ -1287,10 +1284,10 @@ static int snd_hdspm_info_system_clock_mode(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_get_system_clock_mode(snd_kcontrol_t * kcontrol,
-					   snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_get_system_clock_mode(struct snd_kcontrol *kcontrol,
+					   struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	ucontrol->value.enumerated.item[0] =
 	    hdspm_system_clock_mode(hdspm);
@@ -1306,7 +1303,7 @@ static int snd_hdspm_get_system_clock_mode(snd_kcontrol_t * kcontrol,
   .put = snd_hdspm_put_clock_source \
 }
 
-static int hdspm_clock_source(hdspm_t * hdspm)
+static int hdspm_clock_source(struct hdspm * hdspm)
 {
 	if (hdspm->control_register & HDSPM_ClockModeMaster) {
 		switch (hdspm->system_sample_rate) {
@@ -1336,7 +1333,7 @@ static int hdspm_clock_source(hdspm_t * hdspm)
 	}
 }
 
-static int hdspm_set_clock_source(hdspm_t * hdspm, int mode)
+static int hdspm_set_clock_source(struct hdspm * hdspm, int mode)
 {
 	int rate;
 	switch (mode) {
@@ -1386,8 +1383,8 @@ static int hdspm_set_clock_source(hdspm_t * hdspm, int mode)
 	return 0;
 }
 
-static int snd_hdspm_info_clock_source(snd_kcontrol_t * kcontrol,
-				       snd_ctl_elem_info_t * uinfo)
+static int snd_hdspm_info_clock_source(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "AutoSync",
 		"Internal 32.0 kHz", "Internal 44.1 kHz",
@@ -1412,19 +1409,19 @@ static int snd_hdspm_info_clock_source(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_get_clock_source(snd_kcontrol_t * kcontrol,
-				      snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_get_clock_source(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	ucontrol->value.enumerated.item[0] = hdspm_clock_source(hdspm);
 	return 0;
 }
 
-static int snd_hdspm_put_clock_source(snd_kcontrol_t * kcontrol,
-				      snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_put_clock_source(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int change;
 	int val;
 
@@ -1453,7 +1450,7 @@ static int snd_hdspm_put_clock_source(snd_kcontrol_t * kcontrol,
   .put = snd_hdspm_put_pref_sync_ref \
 }
 
-static int hdspm_pref_sync_ref(hdspm_t * hdspm)
+static int hdspm_pref_sync_ref(struct hdspm * hdspm)
 {
 	/* Notice that this looks at the requested sync source,
 	   not the one actually in use.
@@ -1468,7 +1465,7 @@ static int hdspm_pref_sync_ref(hdspm_t * hdspm)
 	return HDSPM_SYNC_FROM_WORD;
 }
 
-static int hdspm_set_pref_sync_ref(hdspm_t * hdspm, int pref)
+static int hdspm_set_pref_sync_ref(struct hdspm * hdspm, int pref)
 {
 	hdspm->control_register &= ~HDSPM_SyncRefMask;
 
@@ -1486,8 +1483,8 @@ static int hdspm_set_pref_sync_ref(hdspm_t * hdspm, int pref)
 	return 0;
 }
 
-static int snd_hdspm_info_pref_sync_ref(snd_kcontrol_t * kcontrol,
-					snd_ctl_elem_info_t * uinfo)
+static int snd_hdspm_info_pref_sync_ref(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "Word", "MADI" };
 
@@ -1504,19 +1501,19 @@ static int snd_hdspm_info_pref_sync_ref(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_get_pref_sync_ref(snd_kcontrol_t * kcontrol,
-				       snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_get_pref_sync_ref(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	ucontrol->value.enumerated.item[0] = hdspm_pref_sync_ref(hdspm);
 	return 0;
 }
 
-static int snd_hdspm_put_pref_sync_ref(snd_kcontrol_t * kcontrol,
-				       snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_put_pref_sync_ref(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int change, max;
 	unsigned int val;
 
@@ -1543,7 +1540,7 @@ static int snd_hdspm_put_pref_sync_ref(snd_kcontrol_t * kcontrol,
   .get = snd_hdspm_get_autosync_ref, \
 }
 
-static int hdspm_autosync_ref(hdspm_t * hdspm)
+static int hdspm_autosync_ref(struct hdspm * hdspm)
 {
 	/* This looks at the autosync selected sync reference */
 	unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
@@ -1566,8 +1563,8 @@ static int hdspm_autosync_ref(hdspm_t * hdspm)
 	return 0;
 }
 
-static int snd_hdspm_info_autosync_ref(snd_kcontrol_t * kcontrol,
-				       snd_ctl_elem_info_t * uinfo)
+static int snd_hdspm_info_autosync_ref(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "WordClock", "MADI", "None" };
 
@@ -1582,10 +1579,10 @@ static int snd_hdspm_info_autosync_ref(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_get_autosync_ref(snd_kcontrol_t * kcontrol,
-				      snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_get_autosync_ref(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	ucontrol->value.enumerated.item[0] = hdspm_pref_sync_ref(hdspm);
 	return 0;
@@ -1600,13 +1597,13 @@ static int snd_hdspm_get_autosync_ref(snd_kcontrol_t * kcontrol,
   .put = snd_hdspm_put_line_out \
 }
 
-static int hdspm_line_out(hdspm_t * hdspm)
+static int hdspm_line_out(struct hdspm * hdspm)
 {
 	return (hdspm->control_register & HDSPM_LineOut) ? 1 : 0;
 }
 
 
-static int hdspm_set_line_output(hdspm_t * hdspm, int out)
+static int hdspm_set_line_output(struct hdspm * hdspm, int out)
 {
 	if (out)
 		hdspm->control_register |= HDSPM_LineOut;
@@ -1617,8 +1614,8 @@ static int hdspm_set_line_output(hdspm_t * hdspm, int out)
 	return 0;
 }
 
-static int snd_hdspm_info_line_out(snd_kcontrol_t * kcontrol,
-				   snd_ctl_elem_info_t * uinfo)
+static int snd_hdspm_info_line_out(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
@@ -1627,10 +1624,10 @@ static int snd_hdspm_info_line_out(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_get_line_out(snd_kcontrol_t * kcontrol,
-				  snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_get_line_out(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&hdspm->lock);
 	ucontrol->value.integer.value[0] = hdspm_line_out(hdspm);
@@ -1638,10 +1635,10 @@ static int snd_hdspm_get_line_out(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_put_line_out(snd_kcontrol_t * kcontrol,
-				  snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_put_line_out(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int change;
 	unsigned int val;
 
@@ -1664,12 +1661,12 @@ static int snd_hdspm_put_line_out(snd_kcontrol_t * kcontrol,
   .put = snd_hdspm_put_tx_64 \
 }
 
-static int hdspm_tx_64(hdspm_t * hdspm)
+static int hdspm_tx_64(struct hdspm * hdspm)
 {
 	return (hdspm->control_register & HDSPM_TX_64ch) ? 1 : 0;
 }
 
-static int hdspm_set_tx_64(hdspm_t * hdspm, int out)
+static int hdspm_set_tx_64(struct hdspm * hdspm, int out)
 {
 	if (out)
 		hdspm->control_register |= HDSPM_TX_64ch;
@@ -1680,8 +1677,8 @@ static int hdspm_set_tx_64(hdspm_t * hdspm, int out)
 	return 0;
 }
 
-static int snd_hdspm_info_tx_64(snd_kcontrol_t * kcontrol,
-				snd_ctl_elem_info_t * uinfo)
+static int snd_hdspm_info_tx_64(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
@@ -1690,10 +1687,10 @@ static int snd_hdspm_info_tx_64(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_get_tx_64(snd_kcontrol_t * kcontrol,
-			       snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_get_tx_64(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&hdspm->lock);
 	ucontrol->value.integer.value[0] = hdspm_tx_64(hdspm);
@@ -1701,10 +1698,10 @@ static int snd_hdspm_get_tx_64(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_put_tx_64(snd_kcontrol_t * kcontrol,
-			       snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_put_tx_64(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int change;
 	unsigned int val;
 
@@ -1727,12 +1724,12 @@ static int snd_hdspm_put_tx_64(snd_kcontrol_t * kcontrol,
   .put = snd_hdspm_put_c_tms \
 }
 
-static int hdspm_c_tms(hdspm_t * hdspm)
+static int hdspm_c_tms(struct hdspm * hdspm)
 {
 	return (hdspm->control_register & HDSPM_clr_tms) ? 1 : 0;
 }
 
-static int hdspm_set_c_tms(hdspm_t * hdspm, int out)
+static int hdspm_set_c_tms(struct hdspm * hdspm, int out)
 {
 	if (out)
 		hdspm->control_register |= HDSPM_clr_tms;
@@ -1743,8 +1740,8 @@ static int hdspm_set_c_tms(hdspm_t * hdspm, int out)
 	return 0;
 }
 
-static int snd_hdspm_info_c_tms(snd_kcontrol_t * kcontrol,
-				snd_ctl_elem_info_t * uinfo)
+static int snd_hdspm_info_c_tms(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
@@ -1753,10 +1750,10 @@ static int snd_hdspm_info_c_tms(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_get_c_tms(snd_kcontrol_t * kcontrol,
-			       snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_get_c_tms(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&hdspm->lock);
 	ucontrol->value.integer.value[0] = hdspm_c_tms(hdspm);
@@ -1764,10 +1761,10 @@ static int snd_hdspm_get_c_tms(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_put_c_tms(snd_kcontrol_t * kcontrol,
-			       snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_put_c_tms(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int change;
 	unsigned int val;
 
@@ -1790,12 +1787,12 @@ static int snd_hdspm_put_c_tms(snd_kcontrol_t * kcontrol,
   .put = snd_hdspm_put_safe_mode \
 }
 
-static int hdspm_safe_mode(hdspm_t * hdspm)
+static int hdspm_safe_mode(struct hdspm * hdspm)
 {
 	return (hdspm->control_register & HDSPM_AutoInp) ? 1 : 0;
 }
 
-static int hdspm_set_safe_mode(hdspm_t * hdspm, int out)
+static int hdspm_set_safe_mode(struct hdspm * hdspm, int out)
 {
 	if (out)
 		hdspm->control_register |= HDSPM_AutoInp;
@@ -1806,8 +1803,8 @@ static int hdspm_set_safe_mode(hdspm_t * hdspm, int out)
 	return 0;
 }
 
-static int snd_hdspm_info_safe_mode(snd_kcontrol_t * kcontrol,
-				    snd_ctl_elem_info_t * uinfo)
+static int snd_hdspm_info_safe_mode(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
 	uinfo->count = 1;
@@ -1816,10 +1813,10 @@ static int snd_hdspm_info_safe_mode(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_get_safe_mode(snd_kcontrol_t * kcontrol,
-				   snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_get_safe_mode(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&hdspm->lock);
 	ucontrol->value.integer.value[0] = hdspm_safe_mode(hdspm);
@@ -1827,10 +1824,10 @@ static int snd_hdspm_get_safe_mode(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_put_safe_mode(snd_kcontrol_t * kcontrol,
-				   snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_put_safe_mode(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int change;
 	unsigned int val;
 
@@ -1853,12 +1850,12 @@ static int snd_hdspm_put_safe_mode(snd_kcontrol_t * kcontrol,
   .put = snd_hdspm_put_input_select \
 }
 
-static int hdspm_input_select(hdspm_t * hdspm)
+static int hdspm_input_select(struct hdspm * hdspm)
 {
 	return (hdspm->control_register & HDSPM_InputSelect0) ? 1 : 0;
 }
 
-static int hdspm_set_input_select(hdspm_t * hdspm, int out)
+static int hdspm_set_input_select(struct hdspm * hdspm, int out)
 {
 	if (out)
 		hdspm->control_register |= HDSPM_InputSelect0;
@@ -1869,8 +1866,8 @@ static int hdspm_set_input_select(hdspm_t * hdspm, int out)
 	return 0;
 }
 
-static int snd_hdspm_info_input_select(snd_kcontrol_t * kcontrol,
-				       snd_ctl_elem_info_t * uinfo)
+static int snd_hdspm_info_input_select(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "optical", "coaxial" };
 
@@ -1887,10 +1884,10 @@ static int snd_hdspm_info_input_select(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_get_input_select(snd_kcontrol_t * kcontrol,
-				      snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_get_input_select(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	spin_lock_irq(&hdspm->lock);
 	ucontrol->value.enumerated.item[0] = hdspm_input_select(hdspm);
@@ -1898,10 +1895,10 @@ static int snd_hdspm_get_input_select(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_put_input_select(snd_kcontrol_t * kcontrol,
-				      snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_put_input_select(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int change;
 	unsigned int val;
 
@@ -1937,8 +1934,8 @@ static int snd_hdspm_put_input_select(snd_kcontrol_t * kcontrol,
   .put = snd_hdspm_put_mixer \
 }
 
-static int snd_hdspm_info_mixer(snd_kcontrol_t * kcontrol,
-				snd_ctl_elem_info_t * uinfo)
+static int snd_hdspm_info_mixer(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 3;
@@ -1948,10 +1945,10 @@ static int snd_hdspm_info_mixer(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_get_mixer(snd_kcontrol_t * kcontrol,
-			       snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_get_mixer(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int source;
 	int destination;
 
@@ -1981,10 +1978,10 @@ static int snd_hdspm_get_mixer(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_put_mixer(snd_kcontrol_t * kcontrol,
-			       snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_put_mixer(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int change;
 	int source;
 	int destination;
@@ -2041,8 +2038,8 @@ static int snd_hdspm_put_mixer(snd_kcontrol_t * kcontrol,
   .put = snd_hdspm_put_playback_mixer \
 }
 
-static int snd_hdspm_info_playback_mixer(snd_kcontrol_t * kcontrol,
-					 snd_ctl_elem_info_t * uinfo)
+static int snd_hdspm_info_playback_mixer(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_info *uinfo)
 {
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 1;
@@ -2052,10 +2049,10 @@ static int snd_hdspm_info_playback_mixer(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_get_playback_mixer(snd_kcontrol_t * kcontrol,
-					snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_get_playback_mixer(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int channel;
 	int mapped_channel;
 
@@ -2079,10 +2076,10 @@ static int snd_hdspm_get_playback_mixer(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int snd_hdspm_put_playback_mixer(snd_kcontrol_t * kcontrol,
-					snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_put_playback_mixer(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 	int change;
 	int channel;
 	int mapped_channel;
@@ -2121,8 +2118,8 @@ static int snd_hdspm_put_playback_mixer(snd_kcontrol_t * kcontrol,
   .get = snd_hdspm_get_wc_sync_check \
 }
 
-static int snd_hdspm_info_sync_check(snd_kcontrol_t * kcontrol,
-				     snd_ctl_elem_info_t * uinfo)
+static int snd_hdspm_info_sync_check(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_info *uinfo)
 {
 	static char *texts[] = { "No Lock", "Lock", "Sync" };
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
@@ -2136,7 +2133,7 @@ static int snd_hdspm_info_sync_check(snd_kcontrol_t * kcontrol,
 	return 0;
 }
 
-static int hdspm_wc_sync_check(hdspm_t * hdspm)
+static int hdspm_wc_sync_check(struct hdspm * hdspm)
 {
 	int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
 	if (status2 & HDSPM_wcLock) {
@@ -2148,10 +2145,10 @@ static int hdspm_wc_sync_check(hdspm_t * hdspm)
 	return 0;
 }
 
-static int snd_hdspm_get_wc_sync_check(snd_kcontrol_t * kcontrol,
-				       snd_ctl_elem_value_t * ucontrol)
+static int snd_hdspm_get_wc_sync_check(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	ucontrol->value.enumerated.item[0] = hdspm_wc_sync_check(hdspm);
 	return 0;
@@ -2167,7 +2164,7 @@ static int snd_hdspm_get_wc_sync_check(snd_kcontrol_t * kcontrol,
   .get = snd_hdspm_get_madisync_sync_check \
 }
 
-static int hdspm_madisync_sync_check(hdspm_t * hdspm)
+static int hdspm_madisync_sync_check(struct hdspm * hdspm)
 {
 	int status = hdspm_read(hdspm, HDSPM_statusRegister);
 	if (status & HDSPM_madiLock) {
@@ -2179,11 +2176,11 @@ static int hdspm_madisync_sync_check(hdspm_t * hdspm)
 	return 0;
 }
 
-static int snd_hdspm_get_madisync_sync_check(snd_kcontrol_t * kcontrol,
-					     snd_ctl_elem_value_t *
+static int snd_hdspm_get_madisync_sync_check(struct snd_kcontrol *kcontrol,
+					     struct snd_ctl_elem_value *
 					     ucontrol)
 {
-	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
 	ucontrol->value.enumerated.item[0] =
 	    hdspm_madisync_sync_check(hdspm);
@@ -2193,7 +2190,7 @@ static int snd_hdspm_get_madisync_sync_check(snd_kcontrol_t * kcontrol,
 
 
 
-static snd_kcontrol_new_t snd_hdspm_controls[] = {
+static struct snd_kcontrol_new snd_hdspm_controls[] = {
 
 	HDSPM_MIXER("Mixer", 0),
 /* 'Sample Clock Source' complies with the alsa control naming scheme */
@@ -2214,10 +2211,10 @@ static snd_kcontrol_new_t snd_hdspm_controls[] = {
 	HDSPM_INPUT_SELECT("Input Select", 0),
 };
 
-static snd_kcontrol_new_t snd_hdspm_playback_mixer = HDSPM_PLAYBACK_MIXER;
+static struct snd_kcontrol_new snd_hdspm_playback_mixer = HDSPM_PLAYBACK_MIXER;
 
 
-static int hdspm_update_simple_mixer_controls(hdspm_t * hdspm)
+static int hdspm_update_simple_mixer_controls(struct hdspm * hdspm)
 {
 	int i;
 
@@ -2241,11 +2238,11 @@ static int hdspm_update_simple_mixer_controls(hdspm_t * hdspm)
 }
 
 
-static int snd_hdspm_create_controls(snd_card_t * card, hdspm_t * hdspm)
+static int snd_hdspm_create_controls(struct snd_card *card, struct hdspm * hdspm)
 {
 	unsigned int idx, limit;
 	int err;
-	snd_kcontrol_t *kctl;
+	struct snd_kcontrol *kctl;
 
 	/* add control list first */
 
@@ -2292,9 +2289,9 @@ static int snd_hdspm_create_controls(snd_card_t * card, hdspm_t * hdspm)
  ------------------------------------------------------------*/
 
 static void
-snd_hdspm_proc_read(snd_info_entry_t * entry, snd_info_buffer_t * buffer)
+snd_hdspm_proc_read(struct snd_info_entry * entry, struct snd_info_buffer *buffer)
 {
-	hdspm_t *hdspm = (hdspm_t *) entry->private_data;
+	struct hdspm *hdspm = (struct hdspm *) entry->private_data;
 	unsigned int status;
 	unsigned int status2;
 	char *pref_sync_ref;
@@ -2487,9 +2484,9 @@ snd_hdspm_proc_read(snd_info_entry_t * entry, snd_info_buffer_t * buffer)
 	snd_iprintf(buffer, "\n");
 }
 
-static void __devinit snd_hdspm_proc_init(hdspm_t * hdspm)
+static void __devinit snd_hdspm_proc_init(struct hdspm * hdspm)
 {
-	snd_info_entry_t *entry;
+	struct snd_info_entry *entry;
 
 	if (!snd_card_proc_new(hdspm->card, "hdspm", &entry))
 		snd_info_set_text_ops(entry, hdspm, 1024,
@@ -2500,7 +2497,7 @@ static void __devinit snd_hdspm_proc_init(hdspm_t * hdspm)
    hdspm intitialize 
  ------------------------------------------------------------*/
 
-static int snd_hdspm_set_defaults(hdspm_t * hdspm)
+static int snd_hdspm_set_defaults(struct hdspm * hdspm)
 {
 	unsigned int i;
 
@@ -2562,7 +2559,7 @@ static int snd_hdspm_set_defaults(hdspm_t * hdspm)
 static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id,
 				       struct pt_regs *regs)
 {
-	hdspm_t *hdspm = (hdspm_t *) dev_id;
+	struct hdspm *hdspm = (struct hdspm *) dev_id;
 	unsigned int status;
 	int audio;
 	int midi0;
@@ -2627,14 +2624,14 @@ static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id,
   ------------------------------------------------------------*/
 
 
-static snd_pcm_uframes_t snd_hdspm_hw_pointer(snd_pcm_substream_t *
+static snd_pcm_uframes_t snd_hdspm_hw_pointer(struct snd_pcm_substream *
 					      substream)
 {
-	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 	return hdspm_hw_pointer(hdspm);
 }
 
-static char *hdspm_channel_buffer_location(hdspm_t * hdspm,
+static char *hdspm_channel_buffer_location(struct hdspm * hdspm,
 					   int stream, int channel)
 {
 	int mapped_channel;
@@ -2656,11 +2653,11 @@ static char *hdspm_channel_buffer_location(hdspm_t * hdspm,
 
 
 /* dont know why need it ??? */
-static int snd_hdspm_playback_copy(snd_pcm_substream_t * substream,
+static int snd_hdspm_playback_copy(struct snd_pcm_substream *substream,
 				   int channel, snd_pcm_uframes_t pos,
 				   void __user *src, snd_pcm_uframes_t count)
 {
-	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 	char *channel_buf;
 
 	snd_assert(pos + count <= HDSPM_CHANNEL_BUFFER_BYTES / 4,
@@ -2675,11 +2672,11 @@ static int snd_hdspm_playback_copy(snd_pcm_substream_t * substream,
 	return copy_from_user(channel_buf + pos * 4, src, count * 4);
 }
 
-static int snd_hdspm_capture_copy(snd_pcm_substream_t * substream,
+static int snd_hdspm_capture_copy(struct snd_pcm_substream *substream,
 				  int channel, snd_pcm_uframes_t pos,
 				  void __user *dst, snd_pcm_uframes_t count)
 {
-	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 	char *channel_buf;
 
 	snd_assert(pos + count <= HDSPM_CHANNEL_BUFFER_BYTES / 4,
@@ -2692,11 +2689,11 @@ static int snd_hdspm_capture_copy(snd_pcm_substream_t * substream,
 	return copy_to_user(dst, channel_buf + pos * 4, count * 4);
 }
 
-static int snd_hdspm_hw_silence(snd_pcm_substream_t * substream,
+static int snd_hdspm_hw_silence(struct snd_pcm_substream *substream,
 				int channel, snd_pcm_uframes_t pos,
 				snd_pcm_uframes_t count)
 {
-	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 	char *channel_buf;
 
 	channel_buf =
@@ -2707,11 +2704,11 @@ static int snd_hdspm_hw_silence(snd_pcm_substream_t * substream,
 	return 0;
 }
 
-static int snd_hdspm_reset(snd_pcm_substream_t * substream)
+static int snd_hdspm_reset(struct snd_pcm_substream *substream)
 {
-	snd_pcm_runtime_t *runtime = substream->runtime;
-	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
-	snd_pcm_substream_t *other;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
+	struct snd_pcm_substream *other;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		other = hdspm->capture_substream;
@@ -2724,8 +2721,8 @@ static int snd_hdspm_reset(snd_pcm_substream_t * substream)
 		runtime->status->hw_ptr = 0;
 	if (other) {
 		struct list_head *pos;
-		snd_pcm_substream_t *s;
-		snd_pcm_runtime_t *oruntime = other->runtime;
+		struct snd_pcm_substream *s;
+		struct snd_pcm_runtime *oruntime = other->runtime;
 		snd_pcm_group_for_each(pos, substream) {
 			s = snd_pcm_group_substream_entry(pos);
 			if (s == other) {
@@ -2738,10 +2735,10 @@ static int snd_hdspm_reset(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_hdspm_hw_params(snd_pcm_substream_t * substream,
-			       snd_pcm_hw_params_t * params)
+static int snd_hdspm_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params)
 {
-	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 	int err;
 	int i;
 	pid_t this_pid;
@@ -2839,10 +2836,10 @@ static int snd_hdspm_hw_params(snd_pcm_substream_t * substream,
 	return 0;
 }
 
-static int snd_hdspm_hw_free(snd_pcm_substream_t * substream)
+static int snd_hdspm_hw_free(struct snd_pcm_substream *substream)
 {
 	int i;
-	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 
@@ -2865,10 +2862,10 @@ static int snd_hdspm_hw_free(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_hdspm_channel_info(snd_pcm_substream_t * substream,
-				  snd_pcm_channel_info_t * info)
+static int snd_hdspm_channel_info(struct snd_pcm_substream *substream,
+				  struct snd_pcm_channel_info * info)
 {
-	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 	int mapped_channel;
 
 	snd_assert(info->channel < HDSPM_MAX_CHANNELS, return -EINVAL);
@@ -2882,7 +2879,7 @@ static int snd_hdspm_channel_info(snd_pcm_substream_t * substream,
 	return 0;
 }
 
-static int snd_hdspm_ioctl(snd_pcm_substream_t * substream,
+static int snd_hdspm_ioctl(struct snd_pcm_substream *substream,
 			   unsigned int cmd, void *arg)
 {
 	switch (cmd) {
@@ -2893,7 +2890,7 @@ static int snd_hdspm_ioctl(snd_pcm_substream_t * substream,
 
 	case SNDRV_PCM_IOCTL1_CHANNEL_INFO:
 		{
-			snd_pcm_channel_info_t *info = arg;
+			struct snd_pcm_channel_info *info = arg;
 			return snd_hdspm_channel_info(substream, info);
 		}
 	default:
@@ -2903,10 +2900,10 @@ static int snd_hdspm_ioctl(snd_pcm_substream_t * substream,
 	return snd_pcm_lib_ioctl(substream, cmd, arg);
 }
 
-static int snd_hdspm_trigger(snd_pcm_substream_t * substream, int cmd)
+static int snd_hdspm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
-	snd_pcm_substream_t *other;
+	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
+	struct snd_pcm_substream *other;
 	int running;
 
 	spin_lock(&hdspm->lock);
@@ -2930,7 +2927,7 @@ static int snd_hdspm_trigger(snd_pcm_substream_t * substream, int cmd)
 
 	if (other) {
 		struct list_head *pos;
-		snd_pcm_substream_t *s;
+		struct snd_pcm_substream *s;
 		snd_pcm_group_for_each(pos, substream) {
 			s = snd_pcm_group_substream_entry(pos);
 			if (s == other) {
@@ -2968,7 +2965,7 @@ static int snd_hdspm_trigger(snd_pcm_substream_t * substream, int cmd)
 	return 0;
 }
 
-static int snd_hdspm_prepare(snd_pcm_substream_t * substream)
+static int snd_hdspm_prepare(struct snd_pcm_substream *substream)
 {
 	return 0;
 }
@@ -2976,7 +2973,7 @@ static int snd_hdspm_prepare(snd_pcm_substream_t * substream)
 static unsigned int period_sizes[] =
     { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
 
-static snd_pcm_hardware_t snd_hdspm_playback_subinfo = {
+static struct snd_pcm_hardware snd_hdspm_playback_subinfo = {
 	.info = (SNDRV_PCM_INFO_MMAP |
 		 SNDRV_PCM_INFO_MMAP_VALID |
 		 SNDRV_PCM_INFO_NONINTERLEAVED |
@@ -3000,7 +2997,7 @@ static snd_pcm_hardware_t snd_hdspm_playback_subinfo = {
 	.fifo_size = 0
 };
 
-static snd_pcm_hardware_t snd_hdspm_capture_subinfo = {
+static struct snd_pcm_hardware snd_hdspm_capture_subinfo = {
 	.info = (SNDRV_PCM_INFO_MMAP |
 		 SNDRV_PCM_INFO_MMAP_VALID |
 		 SNDRV_PCM_INFO_NONINTERLEAVED |
@@ -3024,31 +3021,31 @@ static snd_pcm_hardware_t snd_hdspm_capture_subinfo = {
 	.fifo_size = 0
 };
 
-static snd_pcm_hw_constraint_list_t hw_constraints_period_sizes = {
+static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
 	.count = ARRAY_SIZE(period_sizes),
 	.list = period_sizes,
 	.mask = 0
 };
 
 
-static int snd_hdspm_hw_rule_channels_rate(snd_pcm_hw_params_t * params,
-					   snd_pcm_hw_rule_t * rule)
+static int snd_hdspm_hw_rule_channels_rate(struct snd_pcm_hw_params *params,
+					   struct snd_pcm_hw_rule * rule)
 {
-	hdspm_t *hdspm = rule->private;
-	snd_interval_t *c =
+	struct hdspm *hdspm = rule->private;
+	struct snd_interval *c =
 	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
-	snd_interval_t *r =
+	struct snd_interval *r =
 	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 
 	if (r->min > 48000) {
-		snd_interval_t t = {
+		struct snd_interval t = {
 			.min = 1,
 			.max = hdspm->ds_channels,
 			.integer = 1,
 		};
 		return snd_interval_refine(c, &t);
 	} else if (r->max < 64000) {
-		snd_interval_t t = {
+		struct snd_interval t = {
 			.min = 1,
 			.max = hdspm->ss_channels,
 			.integer = 1,
@@ -3058,24 +3055,24 @@ static int snd_hdspm_hw_rule_channels_rate(snd_pcm_hw_params_t * params,
 	return 0;
 }
 
-static int snd_hdspm_hw_rule_rate_channels(snd_pcm_hw_params_t * params,
-					   snd_pcm_hw_rule_t * rule)
+static int snd_hdspm_hw_rule_rate_channels(struct snd_pcm_hw_params *params,
+					   struct snd_pcm_hw_rule * rule)
 {
-	hdspm_t *hdspm = rule->private;
-	snd_interval_t *c =
+	struct hdspm *hdspm = rule->private;
+	struct snd_interval *c =
 	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
-	snd_interval_t *r =
+	struct snd_interval *r =
 	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 
 	if (c->min <= hdspm->ss_channels) {
-		snd_interval_t t = {
+		struct snd_interval t = {
 			.min = 32000,
 			.max = 48000,
 			.integer = 1,
 		};
 		return snd_interval_refine(r, &t);
 	} else if (c->max > hdspm->ss_channels) {
-		snd_interval_t t = {
+		struct snd_interval t = {
 			.min = 64000,
 			.max = 96000,
 			.integer = 1,
@@ -3086,10 +3083,10 @@ static int snd_hdspm_hw_rule_rate_channels(snd_pcm_hw_params_t * params,
 	return 0;
 }
 
-static int snd_hdspm_playback_open(snd_pcm_substream_t * substream)
+static int snd_hdspm_playback_open(struct snd_pcm_substream *substream)
 {
-	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	snd_printdd("Open device substream %d\n", substream->stream);
 
@@ -3124,9 +3121,9 @@ static int snd_hdspm_playback_open(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_hdspm_playback_release(snd_pcm_substream_t * substream)
+static int snd_hdspm_playback_release(struct snd_pcm_substream *substream)
 {
-	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 
 	spin_lock_irq(&hdspm->lock);
 
@@ -3139,10 +3136,10 @@ static int snd_hdspm_playback_release(snd_pcm_substream_t * substream)
 }
 
 
-static int snd_hdspm_capture_open(snd_pcm_substream_t * substream)
+static int snd_hdspm_capture_open(struct snd_pcm_substream *substream)
 {
-	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	spin_lock_irq(&hdspm->lock);
 	snd_pcm_set_sync(substream);
@@ -3171,9 +3168,9 @@ static int snd_hdspm_capture_open(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_hdspm_capture_release(snd_pcm_substream_t * substream)
+static int snd_hdspm_capture_release(struct snd_pcm_substream *substream)
 {
-	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	struct hdspm *hdspm = snd_pcm_substream_chip(substream);
 
 	spin_lock_irq(&hdspm->lock);
 
@@ -3184,21 +3181,21 @@ static int snd_hdspm_capture_release(snd_pcm_substream_t * substream)
 	return 0;
 }
 
-static int snd_hdspm_hwdep_dummy_op(snd_hwdep_t * hw, struct file *file)
+static int snd_hdspm_hwdep_dummy_op(struct snd_hwdep * hw, struct file *file)
 {
 	/* we have nothing to initialize but the call is required */
 	return 0;
 }
 
 
-static int snd_hdspm_hwdep_ioctl(snd_hwdep_t * hw, struct file *file,
+static int snd_hdspm_hwdep_ioctl(struct snd_hwdep * hw, struct file *file,
 				 unsigned int cmd, unsigned long arg)
 {
-	hdspm_t *hdspm = (hdspm_t *) hw->private_data;
-	struct sndrv_hdspm_mixer_ioctl mixer;
-	hdspm_config_info_t info;
-	hdspm_version_t hdspm_version;
-	struct sndrv_hdspm_peak_rms_ioctl rms;
+	struct hdspm *hdspm = (struct hdspm *) hw->private_data;
+	struct hdspm_mixer_ioctl mixer;
+	struct hdspm_config_info info;
+	struct hdspm_version hdspm_version;
+	struct hdspm_peak_rms_ioctl rms;
 
 	switch (cmd) {
 
@@ -3209,7 +3206,7 @@ static int snd_hdspm_hwdep_ioctl(snd_hwdep_t * hw, struct file *file,
 		/* maybe there is a chance to memorymap in future so dont touch just copy */
 		if(copy_to_user_fromio((void __user *)rms.peak,
 				       hdspm->iobase+HDSPM_MADI_peakrmsbase,
-				       sizeof(hdspm_peak_rms_t)) != 0 )
+				       sizeof(struct hdspm_peak_rms)) != 0 )
 			return -EFAULT;
 
 		break;
@@ -3250,7 +3247,7 @@ static int snd_hdspm_hwdep_ioctl(snd_hwdep_t * hw, struct file *file,
 		if (copy_from_user(&mixer, (void __user *)arg, sizeof(mixer)))
 			return -EFAULT;
 		if (copy_to_user
-		    ((void __user *)mixer.mixer, hdspm->mixer, sizeof(hdspm_mixer_t)))
+		    ((void __user *)mixer.mixer, hdspm->mixer, sizeof(struct hdspm_mixer)))
 			return -EFAULT;
 		break;
 
@@ -3260,7 +3257,7 @@ static int snd_hdspm_hwdep_ioctl(snd_hwdep_t * hw, struct file *file,
 	return 0;
 }
 
-static snd_pcm_ops_t snd_hdspm_playback_ops = {
+static struct snd_pcm_ops snd_hdspm_playback_ops = {
 	.open = snd_hdspm_playback_open,
 	.close = snd_hdspm_playback_release,
 	.ioctl = snd_hdspm_ioctl,
@@ -3274,7 +3271,7 @@ static snd_pcm_ops_t snd_hdspm_playback_ops = {
 	.page = snd_pcm_sgbuf_ops_page,
 };
 
-static snd_pcm_ops_t snd_hdspm_capture_ops = {
+static struct snd_pcm_ops snd_hdspm_capture_ops = {
 	.open = snd_hdspm_capture_open,
 	.close = snd_hdspm_capture_release,
 	.ioctl = snd_hdspm_ioctl,
@@ -3287,10 +3284,10 @@ static snd_pcm_ops_t snd_hdspm_capture_ops = {
 	.page = snd_pcm_sgbuf_ops_page,
 };
 
-static int __devinit snd_hdspm_create_hwdep(snd_card_t * card,
-					    hdspm_t * hdspm)
+static int __devinit snd_hdspm_create_hwdep(struct snd_card *card,
+					    struct hdspm * hdspm)
 {
-	snd_hwdep_t *hw;
+	struct snd_hwdep *hw;
 	int err;
 
 	if ((err = snd_hwdep_new(card, "HDSPM hwdep", 0, &hw)) < 0)
@@ -3311,10 +3308,10 @@ static int __devinit snd_hdspm_create_hwdep(snd_card_t * card,
 /*------------------------------------------------------------
    memory interface 
  ------------------------------------------------------------*/
-static int __devinit snd_hdspm_preallocate_memory(hdspm_t * hdspm)
+static int __devinit snd_hdspm_preallocate_memory(struct hdspm * hdspm)
 {
 	int err;
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	size_t wanted;
 
 	pcm = hdspm->pcm;
@@ -3336,7 +3333,7 @@ static int __devinit snd_hdspm_preallocate_memory(hdspm_t * hdspm)
 	return 0;
 }
 
-static void hdspm_set_sgbuf(hdspm_t * hdspm, struct snd_sg_buf *sgbuf,
+static void hdspm_set_sgbuf(struct hdspm * hdspm, struct snd_sg_buf *sgbuf,
 			     unsigned int reg, int channels)
 {
 	int i;
@@ -3347,10 +3344,10 @@ static void hdspm_set_sgbuf(hdspm_t * hdspm, struct snd_sg_buf *sgbuf,
 }
 
 /* ------------- ALSA Devices ---------------------------- */
-static int __devinit snd_hdspm_create_pcm(snd_card_t * card,
-					  hdspm_t * hdspm)
+static int __devinit snd_hdspm_create_pcm(struct snd_card *card,
+					  struct hdspm * hdspm)
 {
-	snd_pcm_t *pcm;
+	struct snd_pcm *pcm;
 	int err;
 
 	if ((err = snd_pcm_new(card, hdspm->card_name, 0, 1, 1, &pcm)) < 0)
@@ -3373,14 +3370,14 @@ static int __devinit snd_hdspm_create_pcm(snd_card_t * card,
 	return 0;
 }
 
-static inline void snd_hdspm_initialize_midi_flush(hdspm_t * hdspm)
+static inline void snd_hdspm_initialize_midi_flush(struct hdspm * hdspm)
 {
 	snd_hdspm_flush_midi_input(hdspm, 0);
 	snd_hdspm_flush_midi_input(hdspm, 1);
 }
 
-static int __devinit snd_hdspm_create_alsa_devices(snd_card_t * card,
-						   hdspm_t * hdspm)
+static int __devinit snd_hdspm_create_alsa_devices(struct snd_card *card,
+						   struct hdspm * hdspm)
 {
 	int err;
 
@@ -3430,7 +3427,7 @@ static int __devinit snd_hdspm_create_alsa_devices(snd_card_t * card,
 	return 0;
 }
 
-static int __devinit snd_hdspm_create(snd_card_t * card, hdspm_t * hdspm,
+static int __devinit snd_hdspm_create(struct snd_card *card, struct hdspm * hdspm,
 				      int precise_ptr, int enable_monitor)
 {
 	struct pci_dev *pci = hdspm->pci;
@@ -3514,12 +3511,11 @@ static int __devinit snd_hdspm_create(snd_card_t * card, hdspm_t * hdspm,
 	hdspm->monitor_outs = enable_monitor;
 
 	snd_printdd("kmalloc Mixer memory of %d Bytes\n",
-		   sizeof(hdspm_mixer_t));
-	if ((hdspm->mixer =
-	     (hdspm_mixer_t *) kmalloc(sizeof(hdspm_mixer_t), GFP_KERNEL))
+		   sizeof(struct hdspm_mixer));
+	if ((hdspm->mixer = kmalloc(sizeof(struct hdspm_mixer), GFP_KERNEL))
 	    == NULL) {
 		snd_printk(KERN_ERR "HDSPM: unable to kmalloc Mixer memory of %d Bytes\n",
-			   (int)sizeof(hdspm_mixer_t));
+			   (int)sizeof(struct hdspm_mixer));
 		return err;
 	}
 
@@ -3536,7 +3532,7 @@ static int __devinit snd_hdspm_create(snd_card_t * card, hdspm_t * hdspm,
 	return 0;
 }
 
-static int snd_hdspm_free(hdspm_t * hdspm)
+static int snd_hdspm_free(struct hdspm * hdspm)
 {
 
 	if (hdspm->port) {
@@ -3566,9 +3562,9 @@ static int snd_hdspm_free(hdspm_t * hdspm)
 	return 0;
 }
 
-static void snd_hdspm_card_free(snd_card_t * card)
+static void snd_hdspm_card_free(struct snd_card *card)
 {
-	hdspm_t *hdspm = (hdspm_t *) card->private_data;
+	struct hdspm *hdspm = (struct hdspm *) card->private_data;
 
 	if (hdspm)
 		snd_hdspm_free(hdspm);
@@ -3578,8 +3574,8 @@ static int __devinit snd_hdspm_probe(struct pci_dev *pci,
 				     const struct pci_device_id *pci_id)
 {
 	static int dev;
-	hdspm_t *hdspm;
-	snd_card_t *card;
+	struct hdspm *hdspm;
+	struct snd_card *card;
 	int err;
 
 	if (dev >= SNDRV_CARDS)
@@ -3590,10 +3586,10 @@ static int __devinit snd_hdspm_probe(struct pci_dev *pci,
 	}
 
 	if (!(card = snd_card_new(index[dev], id[dev],
-				  THIS_MODULE, sizeof(hdspm_t))))
+				  THIS_MODULE, sizeof(struct hdspm))))
 		return -ENOMEM;
 
-	hdspm = (hdspm_t *) card->private_data;
+	hdspm = (struct hdspm *) card->private_data;
 	card->private_free = snd_hdspm_card_free;
 	hdspm->dev = dev;
 	hdspm->pci = pci;

commit c3e6f7d8763fa0400d28c57633eb323515ba05fc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Nov 16 18:43:35 2005 +0100

    [ALSA] Remove superfluous pcm_free callbacks
    
    Remove superflous pcm_free callbacks.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index a1aef6f6767e..ae2013a8492d 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3336,15 +3336,6 @@ static int __devinit snd_hdspm_preallocate_memory(hdspm_t * hdspm)
 	return 0;
 }
 
-static int snd_hdspm_memory_free(hdspm_t * hdspm)
-{
-	snd_printdd("memory_free_for_all %p\n", hdspm->pcm);
-
-	snd_pcm_lib_preallocate_free_for_all(hdspm->pcm);
-	return 0;
-}
-
-
 static void hdspm_set_sgbuf(hdspm_t * hdspm, struct snd_sg_buf *sgbuf,
 			     unsigned int reg, int channels)
 {
@@ -3568,8 +3559,6 @@ static int snd_hdspm_free(hdspm_t * hdspm)
 	if (hdspm->iobase)
 		iounmap(hdspm->iobase);
 
-	snd_hdspm_memory_free(hdspm);
-
 	if (hdspm->port)
 		pci_release_regions(hdspm->pci);
 

commit 249bb070f5e821503c1118e1e87c0ccb1432d191
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 4 18:56:13 2005 -0800

    [PATCH] PCI: removed unneeded .owner field from struct pci_driver
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 60a1141f1327..a1aef6f6767e 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3639,7 +3639,6 @@ static void __devexit snd_hdspm_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "RME Hammerfall DSP MADI",
-	.owner = THIS_MODULE,
 	.id_table = snd_hdspm_ids,
 	.probe = snd_hdspm_probe,
 	.remove = __devexit_p(snd_hdspm_remove),

commit fc58422ad95a0f4936ead538e0b946aee5a4f98c
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Mon Oct 24 15:11:28 2005 +0200

    [ALSA] Big kfree NULL check cleanup - sound
    
    Modules: AD1889 driver,RME9652 driver
    
    This is the sound/ part of the big kfree cleanup patch.
    
    Remove pointless checks for NULL prior to calling kfree() in sound/.
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index fc3f3283ff37..60a1141f1327 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3563,8 +3563,7 @@ static int snd_hdspm_free(hdspm_t * hdspm)
 		free_irq(hdspm->irq, (void *) hdspm);
 
 
-	if (hdspm->mixer)
-		kfree(hdspm->mixer);
+	kfree(hdspm->mixer);
 
 	if (hdspm->iobase)
 		iounmap(hdspm->iobase);

commit 3bcd4649bca99ee9242f20d7da35e3f8741c6549
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Sep 12 08:20:54 2005 +0200

    [ALSA] set owner field in struct pci_driver
    
    AD1889 driver,ALS4000 driver,ATIIXP driver,ATIIXP-modem driver
    AZT3328 driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,FM801 driver
    Intel8x0 driver,Intel8x0-modem driver,Maestro3 driver,RME32 driver
    RME96 driver,SonicVibes driver,VIA82xx driver,VIA82xx-modem driver
    ALI5451 driver,au88x0 driver,CS46xx driver,EMU10K1/EMU10K2 driver
    HDA Intel driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    MIXART driver,NM256 driver,RME HDSP driver,RME9652 driver
    Trident driver,Digigram VX222 driver,YMFPCI driver
    Set the module owner field in each driver's struct pci_driver to get
    the driver symlink in the sysfs device directory.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 7c67c0286911..fc3f3283ff37 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -3640,6 +3640,7 @@ static void __devexit snd_hdspm_remove(struct pci_dev *pci)
 
 static struct pci_driver driver = {
 	.name = "RME Hammerfall DSP MADI",
+	.owner = THIS_MODULE,
 	.id_table = snd_hdspm_ids,
 	.probe = snd_hdspm_probe,
 	.remove = __devexit_p(snd_hdspm_remove),

commit 8cdfd2519c6c9a1e6057dc5970b2542b35895738
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 7 14:08:11 2005 +0200

    [ALSA] Remove superfluous PCI ID definitions
    
    CS46xx driver,EMU10K1/EMU10K2 driver,PCM Midlevel,Trident driver
    YMFPCI driver,BT87x driver,CMIPCI driver,CS4281 driver
    ENS1370/1+ driver,ES1938 driver,ES1968 driver,Intel8x0 driver
    Intel8x0-modem driver,Maestro3 driver,RME32 driver,RME96 driver
    SonicVibes driver,VIA82xx driver,ALI5451 driver,ICE1712 driver
    ICE1724 driver,NM256 driver,RME HDSP driver,RME9652 driver
    Remove superfluous PCI ID definitions.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 5d786d113b25..7c67c0286911 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -301,18 +301,6 @@ MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
 #define UNITY_GAIN          32768	/* = 65536/2 */
 #define MINUS_INFINITY_GAIN 0
 
-/* PCI info */
-#ifndef PCI_VENDOR_ID_XILINX
-#define PCI_VENDOR_ID_XILINX		0x10ee
-#endif
-#ifndef PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP
-#define PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP 0x3fc5
-#endif
-#ifndef PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP_MADI
-#define PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP_MADI 0x3fc6
-#endif
-
-
 /* Number of channels for different Speed Modes */
 #define MADI_SS_CHANNELS       64
 #define MADI_DS_CHANNELS       32

commit e8da2fbc2dd1fb4d603442f7220d23a2192955fa
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Aug 16 16:55:13 2005 +0200

    [ALSA] hdspm - Fix module parameter description
    
    RME9652 driver
    Fix the module parameter description after proofreading.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index d4a0c2c56cdb..5d786d113b25 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -65,7 +65,7 @@ module_param_array(enable, bool, NULL, 0444);
 MODULE_PARM_DESC(enable, "Enable/disable specific HDSPM soundcards.");
 
 module_param_array(precise_ptr, bool, NULL, 0444);
-MODULE_PARM_DESC(precise_ptr, "Enable precise pointer, or disable.");
+MODULE_PARM_DESC(precise_ptr, "Enable or disable precise pointer.");
 
 module_param_array(line_outs_monitor, bool, NULL, 0444);
 MODULE_PARM_DESC(line_outs_monitor,

commit a53fc188ec6fc406276799da465fe789c40d96b2
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Aug 11 15:59:17 2005 +0200

    [ALSA] make local objects static
    
    Memalloc module,PCM Midlevel,Timer Midlevel,GUS Library,AC97 Codec
    ALI5451 driver,RME9652 driver
    Make some functions/variables that are used in only one file static.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index f6daec4e4d97..d4a0c2c56cdb 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1104,14 +1104,14 @@ static int snd_hdspm_midi_output_close(snd_rawmidi_substream_t * substream)
 	return 0;
 }
 
-snd_rawmidi_ops_t snd_hdspm_midi_output =
+static snd_rawmidi_ops_t snd_hdspm_midi_output =
 {
 	.open =		snd_hdspm_midi_output_open,
 	.close =	snd_hdspm_midi_output_close,
 	.trigger =	snd_hdspm_midi_output_trigger,
 };
 
-snd_rawmidi_ops_t snd_hdspm_midi_input =
+static snd_rawmidi_ops_t snd_hdspm_midi_input =
 {
 	.open =		snd_hdspm_midi_input_open,
 	.close =	snd_hdspm_midi_input_close,

commit 67ed4161f60d76b3b27efc085b36357a6a90768c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Fri Jul 29 15:32:58 2005 +0200

    [ALSA] sound - fix .iface field of mixer control elements
    
    Documentation,CS46xx driver,EMU10K1/EMU10K2 driver,AD1848 driver
    SB16/AWE driver,CMIPCI driver,ENS1370/1+ driver,RME32 driver
    RME96 driver,ICE1712 driver,ICE1724 driver,KORG1212 driver
    RME HDSP driver,RME9652 driver
    This patch changes .iface to SNDRV_CTL_ELEM_IFACE_MIXER whre _PCM or
    _HWDEP was used in controls that are not associated with a specific PCM
    (sub)stream or hwdep device, and changes some controls that got
    inconsitent .iface values due to copy+paste errors.  Furthermore, it
    makes sure that all control that do use _PCM or _HWDEP use the correct
    number in the .device field.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index 9e86d0eb41ce..f6daec4e4d97 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1168,7 +1168,7 @@ static void hdspm_midi_tasklet(unsigned long arg)
 /* get the system sample rate which is set */
 
 #define HDSPM_SYSTEM_SAMPLE_RATE(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
   .access = SNDRV_CTL_ELEM_ACCESS_READ, \
@@ -1195,7 +1195,7 @@ static int snd_hdspm_get_system_sample_rate(snd_kcontrol_t * kcontrol,
 }
 
 #define HDSPM_AUTOSYNC_SAMPLE_RATE(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
   .access = SNDRV_CTL_ELEM_ACCESS_READ, \
@@ -1264,7 +1264,7 @@ static int snd_hdspm_get_autosync_sample_rate(snd_kcontrol_t * kcontrol,
 }
 
 #define HDSPM_SYSTEM_CLOCK_MODE(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
   .access = SNDRV_CTL_ELEM_ACCESS_READ, \
@@ -1310,7 +1310,7 @@ static int snd_hdspm_get_system_clock_mode(snd_kcontrol_t * kcontrol,
 }
 
 #define HDSPM_CLOCK_SOURCE(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
   .info = snd_hdspm_info_clock_source, \
@@ -1457,7 +1457,7 @@ static int snd_hdspm_put_clock_source(snd_kcontrol_t * kcontrol,
 }
 
 #define HDSPM_PREF_SYNC_REF(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
   .info = snd_hdspm_info_pref_sync_ref, \
@@ -1547,7 +1547,7 @@ static int snd_hdspm_put_pref_sync_ref(snd_kcontrol_t * kcontrol,
 }
 
 #define HDSPM_AUTOSYNC_REF(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
   .access = SNDRV_CTL_ELEM_ACCESS_READ, \
@@ -1604,7 +1604,7 @@ static int snd_hdspm_get_autosync_ref(snd_kcontrol_t * kcontrol,
 }
 
 #define HDSPM_LINE_OUT(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
   .info = snd_hdspm_info_line_out, \
@@ -1668,7 +1668,7 @@ static int snd_hdspm_put_line_out(snd_kcontrol_t * kcontrol,
 }
 
 #define HDSPM_TX_64(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
   .info = snd_hdspm_info_tx_64, \
@@ -1731,7 +1731,7 @@ static int snd_hdspm_put_tx_64(snd_kcontrol_t * kcontrol,
 }
 
 #define HDSPM_C_TMS(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
   .info = snd_hdspm_info_c_tms, \
@@ -1794,7 +1794,7 @@ static int snd_hdspm_put_c_tms(snd_kcontrol_t * kcontrol,
 }
 
 #define HDSPM_SAFE_MODE(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
   .info = snd_hdspm_info_safe_mode, \
@@ -1857,7 +1857,7 @@ static int snd_hdspm_put_safe_mode(snd_kcontrol_t * kcontrol,
 }
 
 #define HDSPM_INPUT_SELECT(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
   .info = snd_hdspm_info_input_select, \
@@ -1941,6 +1941,7 @@ static int snd_hdspm_put_input_select(snd_kcontrol_t * kcontrol,
 { .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
   .name = xname, \
   .index = xindex, \
+  .device = 0, \
   .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \
 		 SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
   .info = snd_hdspm_info_mixer, \
@@ -2124,7 +2125,7 @@ static int snd_hdspm_put_playback_mixer(snd_kcontrol_t * kcontrol,
 }
 
 #define HDSPM_WC_SYNC_CHECK(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
   .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
@@ -2170,7 +2171,7 @@ static int snd_hdspm_get_wc_sync_check(snd_kcontrol_t * kcontrol,
 
 
 #define HDSPM_MADI_SYNC_CHECK(xname, xindex) \
-{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
   .name = xname, \
   .index = xindex, \
   .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \

commit 763f356cd8de9e158836d236b3fd9dd149d696f9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jun 3 11:25:34 2005 +0200

    [ALSA] Add HDSP MADI driver
    
    HDSPM driver,PCI drivers,RME9652 driver
    Added RME Hammerfall DSP MADI driver by Winfried Ritsch.
    (Moved from alsa-driver tree to mainline.)
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
new file mode 100644
index 000000000000..9e86d0eb41ce
--- /dev/null
+++ b/sound/pci/rme9652/hdspm.c
@@ -0,0 +1,3671 @@
+/*   -*- linux-c -*-
+ *
+ *   ALSA driver for RME Hammerfall DSP MADI audio interface(s)
+ *
+ *      Copyright (c) 2003 Winfried Ritsch (IEM)
+ *      code based on hdsp.c   Paul Davis
+ *                             Marcus Andersson
+ *                             Thomas Charbonnel
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#include <sound/driver.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/info.h>
+#include <sound/asoundef.h>
+#include <sound/rawmidi.h>
+#include <sound/hwdep.h>
+#include <sound/initval.h>
+
+#include <sound/hdspm.h>
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	  /* Index 0-MAX */
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	  /* ID for this card */
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */
+
+/* Disable precise pointer at start */
+static int precise_ptr[SNDRV_CARDS];
+
+/* Send all playback to line outs */
+static int line_outs_monitor[SNDRV_CARDS];
+
+/* Enable Analog Outs on Channel 63/64 by default */
+static int enable_monitor[SNDRV_CARDS];
+
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for RME HDSPM interface.");
+
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for RME HDSPM interface.");
+
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable/disable specific HDSPM soundcards.");
+
+module_param_array(precise_ptr, bool, NULL, 0444);
+MODULE_PARM_DESC(precise_ptr, "Enable precise pointer, or disable.");
+
+module_param_array(line_outs_monitor, bool, NULL, 0444);
+MODULE_PARM_DESC(line_outs_monitor,
+		 "Send playback streams to analog outs by default.");
+
+module_param_array(enable_monitor, bool, NULL, 0444);
+MODULE_PARM_DESC(enable_monitor,
+		 "Enable Analog Out on Channel 63/64 by default.");
+
+MODULE_AUTHOR
+      ("Winfried Ritsch <ritsch_AT_iem.at>, Paul Davis <paul@linuxaudiosystems.com>, "
+       "Marcus Andersson, Thomas Charbonnel <thomas@undata.org>");
+MODULE_DESCRIPTION("RME HDSPM");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("{{RME HDSPM-MADI}}");
+
+/* --- Write registers. --- 
+  These are defined as byte-offsets from the iobase value.  */
+
+#define HDSPM_controlRegister	     64
+#define HDSPM_interruptConfirmation  96
+#define HDSPM_control2Reg	     256  /* not in specs ???????? */
+#define HDSPM_midiDataOut0  	     352  /* just believe in old code */
+#define HDSPM_midiDataOut1  	     356
+
+/* DMA enable for 64 channels, only Bit 0 is relevant */
+#define HDSPM_outputEnableBase       512  /* 512-767  input  DMA */ 
+#define HDSPM_inputEnableBase        768  /* 768-1023 output DMA */
+
+/* 16 page addresses for each of the 64 channels DMA buffer in and out 
+   (each 64k=16*4k) Buffer must be 4k aligned (which is default i386 ????) */
+#define HDSPM_pageAddressBufferOut       8192
+#define HDSPM_pageAddressBufferIn        (HDSPM_pageAddressBufferOut+64*16*4)
+
+#define HDSPM_MADI_mixerBase    32768	/* 32768-65535 for 2x64x64 Fader */
+
+#define HDSPM_MATRIX_MIXER_SIZE  8192	/* = 2*64*64 * 4 Byte => 32kB */
+
+/* --- Read registers. ---
+   These are defined as byte-offsets from the iobase value */
+#define HDSPM_statusRegister    0
+#define HDSPM_statusRegister2  96
+
+#define HDSPM_midiDataIn0     360
+#define HDSPM_midiDataIn1     364
+
+/* status is data bytes in MIDI-FIFO (0-128) */
+#define HDSPM_midiStatusOut0  384	
+#define HDSPM_midiStatusOut1  388	
+#define HDSPM_midiStatusIn0   392	
+#define HDSPM_midiStatusIn1   396	
+
+
+/* the meters are regular i/o-mapped registers, but offset
+   considerably from the rest. the peak registers are reset
+   when read; the least-significant 4 bits are full-scale counters; 
+   the actual peak value is in the most-significant 24 bits.
+*/
+#define HDSPM_MADI_peakrmsbase 	4096	/* 4096-8191 2x64x32Bit Meters */
+
+/* --- Control Register bits --------- */
+#define HDSPM_Start                (1<<0) /* start engine */
+
+#define HDSPM_Latency0             (1<<1) /* buffer size = 2^n */
+#define HDSPM_Latency1             (1<<2) /* where n is defined */
+#define HDSPM_Latency2             (1<<3) /* by Latency{2,1,0} */
+
+#define HDSPM_ClockModeMaster      (1<<4) /* 1=Master, 0=Slave/Autosync */
+
+#define HDSPM_AudioInterruptEnable (1<<5) /* what do you think ? */
+
+#define HDSPM_Frequency0  (1<<6)  /* 0=44.1kHz/88.2kHz 1=48kHz/96kHz */
+#define HDSPM_Frequency1  (1<<7)  /* 0=32kHz/64kHz */
+#define HDSPM_DoubleSpeed (1<<8)  /* 0=normal speed, 1=double speed */
+#define HDSPM_QuadSpeed   (1<<31) /* quad speed bit, not implemented now */
+
+#define HDSPM_TX_64ch     (1<<10) /* Output 64channel MODE=1,
+				     56channelMODE=0 */
+
+#define HDSPM_AutoInp     (1<<11) /* Auto Input (takeover) == Safe Mode, 
+                                     0=off, 1=on  */
+
+#define HDSPM_InputSelect0 (1<<14) /* Input select 0= optical, 1=coax */
+#define HDSPM_InputSelect1 (1<<15) /* should be 0 */
+
+#define HDSPM_SyncRef0     (1<<16) /* 0=WOrd, 1=MADI */
+#define HDSPM_SyncRef1     (1<<17) /* should be 0 */
+
+#define HDSPM_clr_tms      (1<<19) /* clear track marker, do not use 
+                                      AES additional bits in
+				      lower 5 Audiodatabits ??? */
+
+#define HDSPM_Midi0InterruptEnable (1<<22)
+#define HDSPM_Midi1InterruptEnable (1<<23)
+
+#define HDSPM_LineOut (1<<24) /* Analog Out on channel 63/64 on=1, mute=0 */
+
+
+/* --- bit helper defines */
+#define HDSPM_LatencyMask    (HDSPM_Latency0|HDSPM_Latency1|HDSPM_Latency2)
+#define HDSPM_FrequencyMask  (HDSPM_Frequency0|HDSPM_Frequency1)
+#define HDSPM_InputMask      (HDSPM_InputSelect0|HDSPM_InputSelect1)
+#define HDSPM_InputOptical   0
+#define HDSPM_InputCoaxial   (HDSPM_InputSelect0)
+#define HDSPM_SyncRefMask    (HDSPM_SyncRef0|HDSPM_SyncRef1)
+#define HDSPM_SyncRef_Word   0
+#define HDSPM_SyncRef_MADI   (HDSPM_SyncRef0)
+
+#define HDSPM_SYNC_FROM_WORD 0	/* Preferred sync reference */
+#define HDSPM_SYNC_FROM_MADI 1	/* choices - used by "pref_sync_ref" */
+
+#define HDSPM_Frequency32KHz    HDSPM_Frequency0
+#define HDSPM_Frequency44_1KHz  HDSPM_Frequency1
+#define HDSPM_Frequency48KHz   (HDSPM_Frequency1|HDSPM_Frequency0)
+#define HDSPM_Frequency64KHz   (HDSPM_DoubleSpeed|HDSPM_Frequency0)
+#define HDSPM_Frequency88_2KHz (HDSPM_DoubleSpeed|HDSPM_Frequency1)
+#define HDSPM_Frequency96KHz   (HDSPM_DoubleSpeed|HDSPM_Frequency1|HDSPM_Frequency0)
+
+/* --- for internal discrimination */
+#define HDSPM_CLOCK_SOURCE_AUTOSYNC          0	/* Sample Clock Sources */
+#define HDSPM_CLOCK_SOURCE_INTERNAL_32KHZ    1
+#define HDSPM_CLOCK_SOURCE_INTERNAL_44_1KHZ  2
+#define HDSPM_CLOCK_SOURCE_INTERNAL_48KHZ    3
+#define HDSPM_CLOCK_SOURCE_INTERNAL_64KHZ    4
+#define HDSPM_CLOCK_SOURCE_INTERNAL_88_2KHZ  5
+#define HDSPM_CLOCK_SOURCE_INTERNAL_96KHZ    6
+#define HDSPM_CLOCK_SOURCE_INTERNAL_128KHZ   7
+#define HDSPM_CLOCK_SOURCE_INTERNAL_176_4KHZ 8
+#define HDSPM_CLOCK_SOURCE_INTERNAL_192KHZ   9
+
+/* Synccheck Status */
+#define HDSPM_SYNC_CHECK_NO_LOCK 0
+#define HDSPM_SYNC_CHECK_LOCK    1
+#define HDSPM_SYNC_CHECK_SYNC	 2
+
+/* AutoSync References - used by "autosync_ref" control switch */
+#define HDSPM_AUTOSYNC_FROM_WORD      0
+#define HDSPM_AUTOSYNC_FROM_MADI      1
+#define HDSPM_AUTOSYNC_FROM_NONE      2
+
+/* Possible sources of MADI input */
+#define HDSPM_OPTICAL 0		/* optical   */
+#define HDSPM_COAXIAL 1		/* BNC */
+
+#define hdspm_encode_latency(x)       (((x)<<1) & HDSPM_LatencyMask)
+#define hdspm_decode_latency(x)       (((x) & HDSPM_LatencyMask)>>1)
+
+#define hdspm_encode_in(x) (((x)&0x3)<<14)
+#define hdspm_decode_in(x) (((x)>>14)&0x3)
+
+/* --- control2 register bits --- */
+#define HDSPM_TMS             (1<<0)
+#define HDSPM_TCK             (1<<1)
+#define HDSPM_TDI             (1<<2)
+#define HDSPM_JTAG            (1<<3)
+#define HDSPM_PWDN            (1<<4)
+#define HDSPM_PROGRAM	      (1<<5)
+#define HDSPM_CONFIG_MODE_0   (1<<6)
+#define HDSPM_CONFIG_MODE_1   (1<<7)
+/*#define HDSPM_VERSION_BIT     (1<<8) not defined any more*/
+#define HDSPM_BIGENDIAN_MODE  (1<<9)
+#define HDSPM_RD_MULTIPLE     (1<<10)
+
+/* --- Status Register bits --- */
+#define HDSPM_audioIRQPending    (1<<0)	/* IRQ is high and pending */
+#define HDSPM_RX_64ch            (1<<1)	/* Input 64chan. MODE=1, 56chn. MODE=0 */
+#define HDSPM_AB_int             (1<<2)	/* InputChannel Opt=0, Coax=1 (like inp0) */
+#define HDSPM_madiLock           (1<<3)	/* MADI Locked =1, no=0 */
+
+#define HDSPM_BufferPositionMask 0x000FFC0 /* Bit 6..15 : h/w buffer pointer */
+                                           /* since 64byte accurate last 6 bits 
+                                              are not used */
+
+#define HDSPM_madiSync          (1<<18) /* MADI is in sync */
+#define HDSPM_DoubleSpeedStatus (1<<19) /* (input) card in double speed */
+
+#define HDSPM_madiFreq0         (1<<22)	/* system freq 0=error */
+#define HDSPM_madiFreq1         (1<<23)	/* 1=32, 2=44.1 3=48 */
+#define HDSPM_madiFreq2         (1<<24)	/* 4=64, 5=88.2 6=96 */
+#define HDSPM_madiFreq3         (1<<25)	/* 7=128, 8=176.4 9=192 */
+
+#define HDSPM_BufferID          (1<<26)	/* (Double)Buffer ID toggles with Interrupt */
+#define HDSPM_midi0IRQPending   (1<<30)	/* MIDI IRQ is pending  */
+#define HDSPM_midi1IRQPending   (1<<31)	/* and aktiv */
+
+/* --- status bit helpers */
+#define HDSPM_madiFreqMask  (HDSPM_madiFreq0|HDSPM_madiFreq1|HDSPM_madiFreq2|HDSPM_madiFreq3)
+#define HDSPM_madiFreq32    (HDSPM_madiFreq0)
+#define HDSPM_madiFreq44_1  (HDSPM_madiFreq1)
+#define HDSPM_madiFreq48    (HDSPM_madiFreq0|HDSPM_madiFreq1)
+#define HDSPM_madiFreq64    (HDSPM_madiFreq2)
+#define HDSPM_madiFreq88_2  (HDSPM_madiFreq0|HDSPM_madiFreq2)
+#define HDSPM_madiFreq96    (HDSPM_madiFreq1|HDSPM_madiFreq2)
+#define HDSPM_madiFreq128   (HDSPM_madiFreq0|HDSPM_madiFreq1|HDSPM_madiFreq2)
+#define HDSPM_madiFreq176_4 (HDSPM_madiFreq3)
+#define HDSPM_madiFreq192   (HDSPM_madiFreq3|HDSPM_madiFreq0)
+
+/* Status2 Register bits */
+
+#define HDSPM_version0 (1<<0)	/* not realy defined but I guess */
+#define HDSPM_version1 (1<<1)	/* in former cards it was ??? */
+#define HDSPM_version2 (1<<2)
+
+#define HDSPM_wcLock (1<<3)	/* Wordclock is detected and locked */
+#define HDSPM_wcSync (1<<4)	/* Wordclock is in sync with systemclock */
+
+#define HDSPM_wc_freq0 (1<<5)	/* input freq detected via autosync  */
+#define HDSPM_wc_freq1 (1<<6)	/* 001=32, 010==44.1, 011=48, */
+#define HDSPM_wc_freq2 (1<<7)	/* 100=64, 101=88.2, 110=96, */
+/* missing Bit   for               111=128, 1000=176.4, 1001=192 */
+
+#define HDSPM_SelSyncRef0 (1<<8)	/* Sync Source in slave mode */
+#define HDSPM_SelSyncRef1 (1<<9)	/* 000=word, 001=MADI, */
+#define HDSPM_SelSyncRef2 (1<<10)	/* 111=no valid signal */
+
+#define HDSPM_wc_valid (HDSPM_wcLock|HDSPM_wcSync)
+
+#define HDSPM_wcFreqMask  (HDSPM_wc_freq0|HDSPM_wc_freq1|HDSPM_wc_freq2)
+#define HDSPM_wcFreq32    (HDSPM_wc_freq0)
+#define HDSPM_wcFreq44_1  (HDSPM_wc_freq1)
+#define HDSPM_wcFreq48    (HDSPM_wc_freq0|HDSPM_wc_freq1)
+#define HDSPM_wcFreq64    (HDSPM_wc_freq2)
+#define HDSPM_wcFreq88_2  (HDSPM_wc_freq0|HDSPM_wc_freq2)
+#define HDSPM_wcFreq96    (HDSPM_wc_freq1|HDSPM_wc_freq2)
+
+
+#define HDSPM_SelSyncRefMask       (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1|HDSPM_SelSyncRef2)
+#define HDSPM_SelSyncRef_WORD      0
+#define HDSPM_SelSyncRef_MADI      (HDSPM_SelSyncRef0)
+#define HDSPM_SelSyncRef_NVALID    (HDSPM_SelSyncRef0|HDSPM_SelSyncRef1|HDSPM_SelSyncRef2)
+
+/* Mixer Values */
+#define UNITY_GAIN          32768	/* = 65536/2 */
+#define MINUS_INFINITY_GAIN 0
+
+/* PCI info */
+#ifndef PCI_VENDOR_ID_XILINX
+#define PCI_VENDOR_ID_XILINX		0x10ee
+#endif
+#ifndef PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP
+#define PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP 0x3fc5
+#endif
+#ifndef PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP_MADI
+#define PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP_MADI 0x3fc6
+#endif
+
+
+/* Number of channels for different Speed Modes */
+#define MADI_SS_CHANNELS       64
+#define MADI_DS_CHANNELS       32
+#define MADI_QS_CHANNELS       16
+
+/* the size of a substream (1 mono data stream) */
+#define HDSPM_CHANNEL_BUFFER_SAMPLES  (16*1024)
+#define HDSPM_CHANNEL_BUFFER_BYTES    (4*HDSPM_CHANNEL_BUFFER_SAMPLES)
+
+/* the size of the area we need to allocate for DMA transfers. the
+   size is the same regardless of the number of channels, and
+   also the latency to use. 
+   for one direction !!!
+*/
+#define HDSPM_DMA_AREA_BYTES (HDSPM_MAX_CHANNELS * HDSPM_CHANNEL_BUFFER_BYTES)
+#define HDSPM_DMA_AREA_KILOBYTES (HDSPM_DMA_AREA_BYTES/1024)
+
+typedef struct _hdspm hdspm_t;
+typedef struct _hdspm_midi hdspm_midi_t;
+
+struct _hdspm_midi {
+	hdspm_t *hdspm;
+	int id;
+	snd_rawmidi_t *rmidi;
+	snd_rawmidi_substream_t *input;
+	snd_rawmidi_substream_t *output;
+	char istimer;		/* timer in use */
+	struct timer_list timer;
+	spinlock_t lock;
+	int pending;
+};
+
+struct _hdspm {
+        spinlock_t lock;
+        snd_pcm_substream_t *capture_substream;	 /* only one playback */
+        snd_pcm_substream_t *playback_substream; /* and/or capture stream */
+
+	char *card_name;	     /* for procinfo */
+	unsigned short firmware_rev; /* dont know if relevant */
+
+	int precise_ptr;	/* use precise pointers, to be tested */
+	int monitor_outs;	/* set up monitoring outs init flag */
+
+	u32 control_register;	/* cached value */
+	u32 control2_register;	/* cached value */
+
+	hdspm_midi_t midi[2];
+	struct tasklet_struct midi_tasklet;
+
+	size_t period_bytes;
+	unsigned char ss_channels;	/* channels of card in single speed */
+	unsigned char ds_channels;	/* Double Speed */
+	unsigned char qs_channels;	/* Quad Speed */
+
+	unsigned char *playback_buffer;	/* suitably aligned address */
+	unsigned char *capture_buffer;	/* suitably aligned address */
+
+	pid_t capture_pid;	/* process id which uses capture */
+	pid_t playback_pid;	/* process id which uses capture */
+	int running;		/* running status */
+
+	int last_external_sample_rate;	/* samplerate mystic ... */
+	int last_internal_sample_rate;
+	int system_sample_rate;
+
+	char *channel_map;	/* channel map for DS and Quadspeed */
+
+	int dev;		/* Hardware vars... */
+	int irq;
+	unsigned long port;
+	void __iomem *iobase;
+
+	int irq_count;		/* for debug */
+
+	snd_card_t *card;	/* one card */
+	snd_pcm_t *pcm;		/* has one pcm */
+	snd_hwdep_t *hwdep;	/* and a hwdep for additional ioctl */
+	struct pci_dev *pci;	/* and an pci info */
+
+	/* Mixer vars */
+	snd_kcontrol_t *playback_mixer_ctls[HDSPM_MAX_CHANNELS];	/* fast alsa mixer */
+	snd_kcontrol_t *input_mixer_ctls[HDSPM_MAX_CHANNELS];	/* but input to much, so not used */
+	hdspm_mixer_t *mixer;	/* full mixer accessable over mixer ioctl or hwdep-device */
+
+};
+
+/* These tables map the ALSA channels 1..N to the channels that we
+   need to use in order to find the relevant channel buffer. RME
+   refer to this kind of mapping as between "the ADAT channel and
+   the DMA channel." We index it using the logical audio channel,
+   and the value is the DMA channel (i.e. channel buffer number)
+   where the data for that channel can be read/written from/to.
+*/
+
+static char channel_map_madi_ss[HDSPM_MAX_CHANNELS] = {
+   0, 1, 2, 3, 4, 5, 6, 7,
+   8, 9, 10, 11, 12, 13, 14, 15,
+   16, 17, 18, 19, 20, 21, 22, 23,
+   24, 25, 26, 27, 28, 29, 30, 31,
+   32, 33, 34, 35, 36, 37, 38, 39,
+   40, 41, 42, 43, 44, 45, 46, 47,
+   48, 49, 50, 51, 52, 53, 54, 55,
+   56, 57, 58, 59, 60, 61, 62, 63
+};
+
+static char channel_map_madi_ds[HDSPM_MAX_CHANNELS] = {
+  0, 2, 4, 6, 8, 10, 12, 14,
+  16, 18, 20, 22, 24, 26, 28, 30,
+  32, 34, 36, 38, 40, 42, 44, 46,
+  48, 50, 52, 54, 56, 58, 60, 62,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1,
+  -1, -1, -1, -1, -1, -1, -1, -1
+};
+
+static char channel_map_madi_qs[HDSPM_MAX_CHANNELS] = {
+  0,   4,  8, 12, 16, 20, 24,  28,  
+  32, 36, 40, 44, 48, 52, 56,  60
+  -1, -1, -1, -1, -1, -1, -1, -1,  
+  -1, -1, -1, -1, -1, -1, -1, -1,  
+  -1, -1, -1, -1, -1, -1, -1, -1, 
+  -1, -1, -1, -1, -1, -1, -1, -1, 
+  -1, -1, -1, -1, -1, -1, -1, -1, 
+  -1, -1, -1, -1, -1, -1, -1, -1
+};
+
+
+static struct pci_device_id snd_hdspm_ids[] = {
+	{
+	 .vendor = PCI_VENDOR_ID_XILINX,
+	 .device = PCI_DEVICE_ID_XILINX_HAMMERFALL_DSP_MADI,
+	 .subvendor = PCI_ANY_ID,
+	 .subdevice = PCI_ANY_ID,
+	 .class = 0,
+	 .class_mask = 0,
+	 .driver_data = 0},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, snd_hdspm_ids);
+
+/* prototypes */
+static int __devinit snd_hdspm_create_alsa_devices(snd_card_t * card,
+						   hdspm_t * hdspm);
+static int __devinit snd_hdspm_create_pcm(snd_card_t * card,
+					  hdspm_t * hdspm);
+
+static inline void snd_hdspm_initialize_midi_flush(hdspm_t * hdspm);
+static int hdspm_update_simple_mixer_controls(hdspm_t * hdspm);
+static int hdspm_autosync_ref(hdspm_t * hdspm);
+static int snd_hdspm_set_defaults(hdspm_t * hdspm);
+static void hdspm_set_sgbuf(hdspm_t * hdspm, struct snd_sg_buf *sgbuf,
+			     unsigned int reg, int channels);
+
+/* Write/read to/from HDSPM with Adresses in Bytes
+   not words but only 32Bit writes are allowed */
+
+static inline void hdspm_write(hdspm_t * hdspm, unsigned int reg,
+			       unsigned int val)
+{
+	writel(val, hdspm->iobase + reg);
+}
+
+static inline unsigned int hdspm_read(hdspm_t * hdspm, unsigned int reg)
+{
+	return readl(hdspm->iobase + reg);
+}
+
+/* for each output channel (chan) I have an Input (in) and Playback (pb) Fader 
+   mixer is write only on hardware so we have to cache him for read 
+   each fader is a u32, but uses only the first 16 bit */
+
+static inline int hdspm_read_in_gain(hdspm_t * hdspm, unsigned int chan,
+				     unsigned int in)
+{
+	if (chan > HDSPM_MIXER_CHANNELS || in > HDSPM_MIXER_CHANNELS)
+		return 0;
+
+	return hdspm->mixer->ch[chan].in[in];
+}
+
+static inline int hdspm_read_pb_gain(hdspm_t * hdspm, unsigned int chan,
+				     unsigned int pb)
+{
+	if (chan > HDSPM_MIXER_CHANNELS || pb > HDSPM_MIXER_CHANNELS)
+		return 0;
+	return hdspm->mixer->ch[chan].pb[pb];
+}
+
+static inline int hdspm_write_in_gain(hdspm_t * hdspm, unsigned int chan,
+				      unsigned int in, unsigned short data)
+{
+	if (chan >= HDSPM_MIXER_CHANNELS || in >= HDSPM_MIXER_CHANNELS)
+		return -1;
+
+	hdspm_write(hdspm,
+		    HDSPM_MADI_mixerBase +
+		    ((in + 128 * chan) * sizeof(u32)),
+		    (hdspm->mixer->ch[chan].in[in] = data & 0xFFFF));
+	return 0;
+}
+
+static inline int hdspm_write_pb_gain(hdspm_t * hdspm, unsigned int chan,
+				      unsigned int pb, unsigned short data)
+{
+	if (chan >= HDSPM_MIXER_CHANNELS || pb >= HDSPM_MIXER_CHANNELS)
+		return -1;
+
+	hdspm_write(hdspm,
+		    HDSPM_MADI_mixerBase +
+		    ((64 + pb + 128 * chan) * sizeof(u32)),
+		    (hdspm->mixer->ch[chan].pb[pb] = data & 0xFFFF));
+	return 0;
+}
+
+
+/* enable DMA for specific channels, now available for DSP-MADI */
+static inline void snd_hdspm_enable_in(hdspm_t * hdspm, int i, int v)
+{
+	hdspm_write(hdspm, HDSPM_inputEnableBase + (4 * i), v);
+}
+
+static inline void snd_hdspm_enable_out(hdspm_t * hdspm, int i, int v)
+{
+	hdspm_write(hdspm, HDSPM_outputEnableBase + (4 * i), v);
+}
+
+/* check if same process is writing and reading */
+static inline int snd_hdspm_use_is_exclusive(hdspm_t * hdspm)
+{
+	unsigned long flags;
+	int ret = 1;
+
+	spin_lock_irqsave(&hdspm->lock, flags);
+	if ((hdspm->playback_pid != hdspm->capture_pid) &&
+	    (hdspm->playback_pid >= 0) && (hdspm->capture_pid >= 0)) {
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&hdspm->lock, flags);
+	return ret;
+}
+
+/* check for external sample rate */
+static inline int hdspm_external_sample_rate(hdspm_t * hdspm)
+{
+	unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+	unsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);
+	unsigned int rate_bits;
+	int rate = 0;
+
+	/* if wordclock has synced freq and wordclock is valid */
+	if ((status2 & HDSPM_wcLock) != 0 &&
+	    (status & HDSPM_SelSyncRef0) == 0) {
+
+		rate_bits = status2 & HDSPM_wcFreqMask;
+
+		switch (rate_bits) {
+		case HDSPM_wcFreq32:
+			rate = 32000;
+			break;
+		case HDSPM_wcFreq44_1:
+			rate = 44100;
+			break;
+		case HDSPM_wcFreq48:
+			rate = 48000;
+			break;
+		case HDSPM_wcFreq64:
+			rate = 64000;
+			break;
+		case HDSPM_wcFreq88_2:
+			rate = 88200;
+			break;
+		case HDSPM_wcFreq96:
+			rate = 96000;
+			break;
+			/* Quadspeed Bit missing ???? */
+		default:
+			rate = 0;
+			break;
+		}
+	}
+
+	/* if rate detected and Syncref is Word than have it, word has priority to MADI */
+	if (rate != 0
+	    && (status2 & HDSPM_SelSyncRefMask) == HDSPM_SelSyncRef_WORD)
+		return rate;
+
+	/* maby a madi input (which is taken if sel sync is madi) */
+	if (status & HDSPM_madiLock) {
+		rate_bits = status & HDSPM_madiFreqMask;
+
+		switch (rate_bits) {
+		case HDSPM_madiFreq32:
+			rate = 32000;
+			break;
+		case HDSPM_madiFreq44_1:
+			rate = 44100;
+			break;
+		case HDSPM_madiFreq48:
+			rate = 48000;
+			break;
+		case HDSPM_madiFreq64:
+			rate = 64000;
+			break;
+		case HDSPM_madiFreq88_2:
+			rate = 88200;
+			break;
+		case HDSPM_madiFreq96:
+			rate = 96000;
+			break;
+		case HDSPM_madiFreq128:
+			rate = 128000;
+			break;
+		case HDSPM_madiFreq176_4:
+			rate = 176400;
+			break;
+		case HDSPM_madiFreq192:
+			rate = 192000;
+			break;
+		default:
+			rate = 0;
+			break;
+		}
+	}
+	return rate;
+}
+
+/* Latency function */
+static inline void hdspm_compute_period_size(hdspm_t * hdspm)
+{
+	hdspm->period_bytes =
+	    1 << ((hdspm_decode_latency(hdspm->control_register) + 8));
+}
+
+static snd_pcm_uframes_t hdspm_hw_pointer(hdspm_t * hdspm)
+{
+	int position;
+
+	position = hdspm_read(hdspm, HDSPM_statusRegister);
+
+	if (!hdspm->precise_ptr) {
+		return (position & HDSPM_BufferID) ? (hdspm->period_bytes /
+						      4) : 0;
+	}
+
+	/* hwpointer comes in bytes and is 64Bytes accurate (by docu since PCI Burst)
+	   i have experimented that it is at most 64 Byte to much for playing 
+	   so substraction of 64 byte should be ok for ALSA, but use it only
+	   for application where you know what you do since if you come to
+	   near with record pointer it can be a disaster */
+
+	position &= HDSPM_BufferPositionMask;
+	position = ((position - 64) % (2 * hdspm->period_bytes)) / 4;
+
+	return position;
+}
+
+
+static inline void hdspm_start_audio(hdspm_t * s)
+{
+	s->control_register |= (HDSPM_AudioInterruptEnable | HDSPM_Start);
+	hdspm_write(s, HDSPM_controlRegister, s->control_register);
+}
+
+static inline void hdspm_stop_audio(hdspm_t * s)
+{
+	s->control_register &= ~(HDSPM_Start | HDSPM_AudioInterruptEnable);
+	hdspm_write(s, HDSPM_controlRegister, s->control_register);
+}
+
+/* should I silence all or only opened ones ? doit all for first even is 4MB*/
+static inline void hdspm_silence_playback(hdspm_t * hdspm)
+{
+	int i;
+	int n = hdspm->period_bytes;
+	void *buf = hdspm->playback_buffer;
+
+	snd_assert(buf != NULL, return);
+
+	for (i = 0; i < HDSPM_MAX_CHANNELS; i++) {
+		memset(buf, 0, n);
+		buf += HDSPM_CHANNEL_BUFFER_BYTES;
+	}
+}
+
+static int hdspm_set_interrupt_interval(hdspm_t * s, unsigned int frames)
+{
+	int n;
+
+	spin_lock_irq(&s->lock);
+
+	frames >>= 7;
+	n = 0;
+	while (frames) {
+		n++;
+		frames >>= 1;
+	}
+	s->control_register &= ~HDSPM_LatencyMask;
+	s->control_register |= hdspm_encode_latency(n);
+
+	hdspm_write(s, HDSPM_controlRegister, s->control_register);
+
+	hdspm_compute_period_size(s);
+
+	spin_unlock_irq(&s->lock);
+
+	return 0;
+}
+
+
+/* dummy set rate lets see what happens */
+static int hdspm_set_rate(hdspm_t * hdspm, int rate, int called_internally)
+{
+	int reject_if_open = 0;
+	int current_rate;
+	int rate_bits;
+	int not_set = 0;
+
+	/* ASSUMPTION: hdspm->lock is either set, or there is no need for
+	   it (e.g. during module initialization).
+	 */
+
+	if (!(hdspm->control_register & HDSPM_ClockModeMaster)) {
+
+	        /* SLAVE --- */ 
+		if (called_internally) {
+
+        	  /* request from ctl or card initialization 
+	             just make a warning an remember setting 
+		     for future master mode switching */
+    
+			snd_printk
+			    (KERN_WARNING "HDSPM: Warning: device is not running as a clock master.\n");
+			not_set = 1;
+		} else {
+
+			/* hw_param request while in AutoSync mode */
+			int external_freq =
+			    hdspm_external_sample_rate(hdspm);
+
+			if ((hdspm_autosync_ref(hdspm) ==
+			     HDSPM_AUTOSYNC_FROM_NONE)) {
+
+				snd_printk(KERN_WARNING "HDSPM: Detected no Externel Sync \n");
+				not_set = 1;
+
+			} else if (rate != external_freq) {
+
+				snd_printk
+				    (KERN_WARNING "HDSPM: Warning: No AutoSync source for requested rate\n");
+				not_set = 1;
+			}
+		}
+	}
+
+	current_rate = hdspm->system_sample_rate;
+
+	/* Changing between Singe, Double and Quad speed is not
+	   allowed if any substreams are open. This is because such a change
+	   causes a shift in the location of the DMA buffers and a reduction
+	   in the number of available buffers.
+
+	   Note that a similar but essentially insoluble problem exists for
+	   externally-driven rate changes. All we can do is to flag rate
+	   changes in the read/write routines.  
+	 */
+
+	switch (rate) {
+	case 32000:
+		if (current_rate > 48000) {
+			reject_if_open = 1;
+		}
+		rate_bits = HDSPM_Frequency32KHz;
+		break;
+	case 44100:
+		if (current_rate > 48000) {
+			reject_if_open = 1;
+		}
+		rate_bits = HDSPM_Frequency44_1KHz;
+		break;
+	case 48000:
+		if (current_rate > 48000) {
+			reject_if_open = 1;
+		}
+		rate_bits = HDSPM_Frequency48KHz;
+		break;
+	case 64000:
+		if (current_rate <= 48000) {
+			reject_if_open = 1;
+		}
+		rate_bits = HDSPM_Frequency64KHz;
+		break;
+	case 88200:
+		if (current_rate <= 48000) {
+			reject_if_open = 1;
+		}
+		rate_bits = HDSPM_Frequency88_2KHz;
+		break;
+	case 96000:
+		if (current_rate <= 48000) {
+			reject_if_open = 1;
+		}
+		rate_bits = HDSPM_Frequency96KHz;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (reject_if_open
+	    && (hdspm->capture_pid >= 0 || hdspm->playback_pid >= 0)) {
+		snd_printk
+		    (KERN_ERR "HDSPM: cannot change between single- and double-speed mode (capture PID = %d, playback PID = %d)\n",
+		     hdspm->capture_pid, hdspm->playback_pid);
+		return -EBUSY;
+	}
+
+	hdspm->control_register &= ~HDSPM_FrequencyMask;
+	hdspm->control_register |= rate_bits;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	if (rate > 64000)
+		hdspm->channel_map = channel_map_madi_qs;
+	else if (rate > 48000)
+		hdspm->channel_map = channel_map_madi_ds;
+	else 
+		hdspm->channel_map = channel_map_madi_ss;
+
+	hdspm->system_sample_rate = rate;
+
+	if (not_set != 0)
+		return -1;
+
+	return 0;
+}
+
+/* mainly for init to 0 on load */
+static void all_in_all_mixer(hdspm_t * hdspm, int sgain)
+{
+	int i, j;
+	unsigned int gain =
+	    (sgain > UNITY_GAIN) ? UNITY_GAIN : (sgain < 0) ? 0 : sgain;
+
+	for (i = 0; i < HDSPM_MIXER_CHANNELS; i++)
+		for (j = 0; j < HDSPM_MIXER_CHANNELS; j++) {
+			hdspm_write_in_gain(hdspm, i, j, gain);
+			hdspm_write_pb_gain(hdspm, i, j, gain);
+		}
+}
+
+/*----------------------------------------------------------------------------
+   MIDI
+  ----------------------------------------------------------------------------*/
+
+static inline unsigned char snd_hdspm_midi_read_byte (hdspm_t *hdspm, int id)
+{
+	/* the hardware already does the relevant bit-mask with 0xff */
+	if (id)
+		return hdspm_read(hdspm, HDSPM_midiDataIn1);
+	else
+		return hdspm_read(hdspm, HDSPM_midiDataIn0);
+}
+
+static inline void snd_hdspm_midi_write_byte (hdspm_t *hdspm, int id, int val)
+{
+	/* the hardware already does the relevant bit-mask with 0xff */
+	if (id)
+		return hdspm_write(hdspm, HDSPM_midiDataOut1, val);
+	else
+		return hdspm_write(hdspm, HDSPM_midiDataOut0, val);
+}
+
+static inline int snd_hdspm_midi_input_available (hdspm_t *hdspm, int id)
+{
+	if (id)
+		return (hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xff);
+	else
+		return (hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xff);
+}
+
+static inline int snd_hdspm_midi_output_possible (hdspm_t *hdspm, int id)
+{
+	int fifo_bytes_used;
+
+	if (id)
+		fifo_bytes_used = hdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xff;
+	else
+		fifo_bytes_used = hdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xff;
+
+	if (fifo_bytes_used < 128)
+		return  128 - fifo_bytes_used;
+	else
+		return 0;
+}
+
+static inline void snd_hdspm_flush_midi_input (hdspm_t *hdspm, int id)
+{
+	while (snd_hdspm_midi_input_available (hdspm, id))
+		snd_hdspm_midi_read_byte (hdspm, id);
+}
+
+static int snd_hdspm_midi_output_write (hdspm_midi_t *hmidi)
+{
+	unsigned long flags;
+	int n_pending;
+	int to_write;
+	int i;
+	unsigned char buf[128];
+
+	/* Output is not interrupt driven */
+		
+	spin_lock_irqsave (&hmidi->lock, flags);
+	if (hmidi->output) {
+		if (!snd_rawmidi_transmit_empty (hmidi->output)) {
+			if ((n_pending = snd_hdspm_midi_output_possible (hmidi->hdspm, hmidi->id)) > 0) {
+				if (n_pending > (int)sizeof (buf))
+					n_pending = sizeof (buf);
+				
+				if ((to_write = snd_rawmidi_transmit (hmidi->output, buf, n_pending)) > 0) {
+					for (i = 0; i < to_write; ++i) 
+						snd_hdspm_midi_write_byte (hmidi->hdspm, hmidi->id, buf[i]);
+				}
+			}
+		}
+	}
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+	return 0;
+}
+
+static int snd_hdspm_midi_input_read (hdspm_midi_t *hmidi)
+{
+	unsigned char buf[128]; /* this buffer is designed to match the MIDI input FIFO size */
+	unsigned long flags;
+	int n_pending;
+	int i;
+
+	spin_lock_irqsave (&hmidi->lock, flags);
+	if ((n_pending = snd_hdspm_midi_input_available (hmidi->hdspm, hmidi->id)) > 0) {
+		if (hmidi->input) {
+			if (n_pending > (int)sizeof (buf)) {
+				n_pending = sizeof (buf);
+			}
+			for (i = 0; i < n_pending; ++i) {
+				buf[i] = snd_hdspm_midi_read_byte (hmidi->hdspm, hmidi->id);
+			}
+			if (n_pending) {
+				snd_rawmidi_receive (hmidi->input, buf, n_pending);
+			}
+		} else {
+			/* flush the MIDI input FIFO */
+			while (n_pending--) {
+				snd_hdspm_midi_read_byte (hmidi->hdspm, hmidi->id);
+			}
+		}
+	}
+	hmidi->pending = 0;
+	if (hmidi->id) {
+		hmidi->hdspm->control_register |= HDSPM_Midi1InterruptEnable;
+	} else {
+		hmidi->hdspm->control_register |= HDSPM_Midi0InterruptEnable;
+	}
+	hdspm_write(hmidi->hdspm, HDSPM_controlRegister, hmidi->hdspm->control_register);
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+	return snd_hdspm_midi_output_write (hmidi);
+}
+
+static void snd_hdspm_midi_input_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	hdspm_t *hdspm;
+	hdspm_midi_t *hmidi;
+	unsigned long flags;
+	u32 ie;
+
+	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	hdspm = hmidi->hdspm;
+	ie = hmidi->id ? HDSPM_Midi1InterruptEnable : HDSPM_Midi0InterruptEnable;
+	spin_lock_irqsave (&hdspm->lock, flags);
+	if (up) {
+		if (!(hdspm->control_register & ie)) {
+			snd_hdspm_flush_midi_input (hdspm, hmidi->id);
+			hdspm->control_register |= ie;
+		}
+	} else {
+		hdspm->control_register &= ~ie;
+	}
+
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+	spin_unlock_irqrestore (&hdspm->lock, flags);
+}
+
+static void snd_hdspm_midi_output_timer(unsigned long data)
+{
+	hdspm_midi_t *hmidi = (hdspm_midi_t *) data;
+	unsigned long flags;
+	
+	snd_hdspm_midi_output_write(hmidi);
+	spin_lock_irqsave (&hmidi->lock, flags);
+
+	/* this does not bump hmidi->istimer, because the
+	   kernel automatically removed the timer when it
+	   expired, and we are now adding it back, thus
+	   leaving istimer wherever it was set before.  
+	*/
+
+	if (hmidi->istimer) {
+		hmidi->timer.expires = 1 + jiffies;
+		add_timer(&hmidi->timer);
+	}
+
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+}
+
+static void snd_hdspm_midi_output_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	hdspm_midi_t *hmidi;
+	unsigned long flags;
+
+	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	spin_lock_irqsave (&hmidi->lock, flags);
+	if (up) {
+		if (!hmidi->istimer) {
+			init_timer(&hmidi->timer);
+			hmidi->timer.function = snd_hdspm_midi_output_timer;
+			hmidi->timer.data = (unsigned long) hmidi;
+			hmidi->timer.expires = 1 + jiffies;
+			add_timer(&hmidi->timer);
+			hmidi->istimer++;
+		}
+	} else {
+		if (hmidi->istimer && --hmidi->istimer <= 0) {
+			del_timer (&hmidi->timer);
+		}
+	}
+	spin_unlock_irqrestore (&hmidi->lock, flags);
+	if (up)
+		snd_hdspm_midi_output_write(hmidi);
+}
+
+static int snd_hdspm_midi_input_open(snd_rawmidi_substream_t * substream)
+{
+	hdspm_midi_t *hmidi;
+
+	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	spin_lock_irq (&hmidi->lock);
+	snd_hdspm_flush_midi_input (hmidi->hdspm, hmidi->id);
+	hmidi->input = substream;
+	spin_unlock_irq (&hmidi->lock);
+
+	return 0;
+}
+
+static int snd_hdspm_midi_output_open(snd_rawmidi_substream_t * substream)
+{
+	hdspm_midi_t *hmidi;
+
+	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	spin_lock_irq (&hmidi->lock);
+	hmidi->output = substream;
+	spin_unlock_irq (&hmidi->lock);
+
+	return 0;
+}
+
+static int snd_hdspm_midi_input_close(snd_rawmidi_substream_t * substream)
+{
+	hdspm_midi_t *hmidi;
+
+	snd_hdspm_midi_input_trigger (substream, 0);
+
+	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	spin_lock_irq (&hmidi->lock);
+	hmidi->input = NULL;
+	spin_unlock_irq (&hmidi->lock);
+
+	return 0;
+}
+
+static int snd_hdspm_midi_output_close(snd_rawmidi_substream_t * substream)
+{
+	hdspm_midi_t *hmidi;
+
+	snd_hdspm_midi_output_trigger (substream, 0);
+
+	hmidi = (hdspm_midi_t *) substream->rmidi->private_data;
+	spin_lock_irq (&hmidi->lock);
+	hmidi->output = NULL;
+	spin_unlock_irq (&hmidi->lock);
+
+	return 0;
+}
+
+snd_rawmidi_ops_t snd_hdspm_midi_output =
+{
+	.open =		snd_hdspm_midi_output_open,
+	.close =	snd_hdspm_midi_output_close,
+	.trigger =	snd_hdspm_midi_output_trigger,
+};
+
+snd_rawmidi_ops_t snd_hdspm_midi_input =
+{
+	.open =		snd_hdspm_midi_input_open,
+	.close =	snd_hdspm_midi_input_close,
+	.trigger =	snd_hdspm_midi_input_trigger,
+};
+
+static int __devinit snd_hdspm_create_midi (snd_card_t *card, hdspm_t *hdspm, int id)
+{
+	int err;
+	char buf[32];
+
+	hdspm->midi[id].id = id;
+	hdspm->midi[id].rmidi = NULL;
+	hdspm->midi[id].input = NULL;
+	hdspm->midi[id].output = NULL;
+	hdspm->midi[id].hdspm = hdspm;
+	hdspm->midi[id].istimer = 0;
+	hdspm->midi[id].pending = 0;
+	spin_lock_init (&hdspm->midi[id].lock);
+
+	sprintf (buf, "%s MIDI %d", card->shortname, id+1);
+	if ((err = snd_rawmidi_new (card, buf, id, 1, 1, &hdspm->midi[id].rmidi)) < 0)
+		return err;
+
+	sprintf (hdspm->midi[id].rmidi->name, "%s MIDI %d", card->id, id+1);
+	hdspm->midi[id].rmidi->private_data = &hdspm->midi[id];
+
+	snd_rawmidi_set_ops (hdspm->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_hdspm_midi_output);
+	snd_rawmidi_set_ops (hdspm->midi[id].rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_hdspm_midi_input);
+
+	hdspm->midi[id].rmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |
+		SNDRV_RAWMIDI_INFO_INPUT |
+		SNDRV_RAWMIDI_INFO_DUPLEX;
+
+	return 0;
+}
+
+
+static void hdspm_midi_tasklet(unsigned long arg)
+{
+	hdspm_t *hdspm = (hdspm_t *)arg;
+	
+	if (hdspm->midi[0].pending)
+		snd_hdspm_midi_input_read (&hdspm->midi[0]);
+	if (hdspm->midi[1].pending)
+		snd_hdspm_midi_input_read (&hdspm->midi[1]);
+} 
+
+
+/*-----------------------------------------------------------------------------
+  Status Interface
+  ----------------------------------------------------------------------------*/
+
+/* get the system sample rate which is set */
+
+#define HDSPM_SYSTEM_SAMPLE_RATE(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ, \
+  .info = snd_hdspm_info_system_sample_rate, \
+  .get = snd_hdspm_get_system_sample_rate \
+}
+
+static int snd_hdspm_info_system_sample_rate(snd_kcontrol_t * kcontrol,
+					     snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_system_sample_rate(snd_kcontrol_t * kcontrol,
+					    snd_ctl_elem_value_t *
+					    ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm->system_sample_rate;
+	return 0;
+}
+
+#define HDSPM_AUTOSYNC_SAMPLE_RATE(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ, \
+  .info = snd_hdspm_info_autosync_sample_rate, \
+  .get = snd_hdspm_get_autosync_sample_rate \
+}
+
+static int snd_hdspm_info_autosync_sample_rate(snd_kcontrol_t * kcontrol,
+					       snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = { "32000", "44100", "48000",
+		"64000", "88200", "96000",
+		"128000", "176400", "192000",
+		"None"
+	};
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 10;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_hdspm_get_autosync_sample_rate(snd_kcontrol_t * kcontrol,
+					      snd_ctl_elem_value_t *
+					      ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	switch (hdspm_external_sample_rate(hdspm)) {
+	case 32000:
+		ucontrol->value.enumerated.item[0] = 0;
+		break;
+	case 44100:
+		ucontrol->value.enumerated.item[0] = 1;
+		break;
+	case 48000:
+		ucontrol->value.enumerated.item[0] = 2;
+		break;
+	case 64000:
+		ucontrol->value.enumerated.item[0] = 3;
+		break;
+	case 88200:
+		ucontrol->value.enumerated.item[0] = 4;
+		break;
+	case 96000:
+		ucontrol->value.enumerated.item[0] = 5;
+		break;
+	case 128000:
+		ucontrol->value.enumerated.item[0] = 6;
+		break;
+	case 176400:
+		ucontrol->value.enumerated.item[0] = 7;
+		break;
+	case 192000:
+		ucontrol->value.enumerated.item[0] = 8;
+		break;
+
+	default:
+		ucontrol->value.enumerated.item[0] = 9;
+	}
+	return 0;
+}
+
+#define HDSPM_SYSTEM_CLOCK_MODE(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ, \
+  .info = snd_hdspm_info_system_clock_mode, \
+  .get = snd_hdspm_get_system_clock_mode, \
+}
+
+
+
+static int hdspm_system_clock_mode(hdspm_t * hdspm)
+{
+        /* Always reflect the hardware info, rme is never wrong !!!! */
+
+	if (hdspm->control_register & HDSPM_ClockModeMaster)
+		return 0;
+	return 1;
+}
+
+static int snd_hdspm_info_system_clock_mode(snd_kcontrol_t * kcontrol,
+					    snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = { "Master", "Slave" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_hdspm_get_system_clock_mode(snd_kcontrol_t * kcontrol,
+					   snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] =
+	    hdspm_system_clock_mode(hdspm);
+	return 0;
+}
+
+#define HDSPM_CLOCK_SOURCE(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_PCM, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_clock_source, \
+  .get = snd_hdspm_get_clock_source, \
+  .put = snd_hdspm_put_clock_source \
+}
+
+static int hdspm_clock_source(hdspm_t * hdspm)
+{
+	if (hdspm->control_register & HDSPM_ClockModeMaster) {
+		switch (hdspm->system_sample_rate) {
+		case 32000:
+			return 1;
+		case 44100:
+			return 2;
+		case 48000:
+			return 3;
+		case 64000:
+			return 4;
+		case 88200:
+			return 5;
+		case 96000:
+			return 6;
+		case 128000:
+			return 7;
+		case 176400:
+			return 8;
+		case 192000:
+			return 9;
+		default:
+			return 3;
+		}
+	} else {
+		return 0;
+	}
+}
+
+static int hdspm_set_clock_source(hdspm_t * hdspm, int mode)
+{
+	int rate;
+	switch (mode) {
+
+	case HDSPM_CLOCK_SOURCE_AUTOSYNC:
+		if (hdspm_external_sample_rate(hdspm) != 0) {
+			hdspm->control_register &= ~HDSPM_ClockModeMaster;
+			hdspm_write(hdspm, HDSPM_controlRegister,
+				    hdspm->control_register);
+			return 0;
+		}
+		return -1;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_32KHZ:
+		rate = 32000;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_44_1KHZ:
+		rate = 44100;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_48KHZ:
+		rate = 48000;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_64KHZ:
+		rate = 64000;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_88_2KHZ:
+		rate = 88200;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_96KHZ:
+		rate = 96000;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_128KHZ:
+		rate = 128000;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_176_4KHZ:
+		rate = 176400;
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_192KHZ:
+		rate = 192000;
+		break;
+
+	default:
+		rate = 44100;
+	}
+	hdspm->control_register |= HDSPM_ClockModeMaster;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+	hdspm_set_rate(hdspm, rate, 1);
+	return 0;
+}
+
+static int snd_hdspm_info_clock_source(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = { "AutoSync",
+		"Internal 32.0 kHz", "Internal 44.1 kHz",
+		    "Internal 48.0 kHz",
+		"Internal 64.0 kHz", "Internal 88.2 kHz",
+		    "Internal 96.0 kHz",
+		"Internal 128.0 kHz", "Internal 176.4 kHz",
+		    "Internal 192.0 kHz"
+	};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 10;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+
+	return 0;
+}
+
+static int snd_hdspm_get_clock_source(snd_kcontrol_t * kcontrol,
+				      snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm_clock_source(hdspm);
+	return 0;
+}
+
+static int snd_hdspm_put_clock_source(snd_kcontrol_t * kcontrol,
+				      snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.enumerated.item[0];
+	if (val < 0)
+		val = 0;
+	if (val > 6)
+		val = 6;
+	spin_lock_irq(&hdspm->lock);
+	if (val != hdspm_clock_source(hdspm))
+		change = (hdspm_set_clock_source(hdspm, val) == 0) ? 1 : 0;
+	else
+		change = 0;
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_PREF_SYNC_REF(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_pref_sync_ref, \
+  .get = snd_hdspm_get_pref_sync_ref, \
+  .put = snd_hdspm_put_pref_sync_ref \
+}
+
+static int hdspm_pref_sync_ref(hdspm_t * hdspm)
+{
+	/* Notice that this looks at the requested sync source,
+	   not the one actually in use.
+	 */
+	switch (hdspm->control_register & HDSPM_SyncRefMask) {
+	case HDSPM_SyncRef_Word:
+		return HDSPM_SYNC_FROM_WORD;
+	case HDSPM_SyncRef_MADI:
+		return HDSPM_SYNC_FROM_MADI;
+	}
+
+	return HDSPM_SYNC_FROM_WORD;
+}
+
+static int hdspm_set_pref_sync_ref(hdspm_t * hdspm, int pref)
+{
+	hdspm->control_register &= ~HDSPM_SyncRefMask;
+
+	switch (pref) {
+	case HDSPM_SYNC_FROM_MADI:
+		hdspm->control_register |= HDSPM_SyncRef_MADI;
+		break;
+	case HDSPM_SYNC_FROM_WORD:
+		hdspm->control_register |= HDSPM_SyncRef_Word;
+		break;
+	default:
+		return -1;
+	}
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+	return 0;
+}
+
+static int snd_hdspm_info_pref_sync_ref(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = { "Word", "MADI" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+
+	uinfo->value.enumerated.items = 2;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_hdspm_get_pref_sync_ref(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm_pref_sync_ref(hdspm);
+	return 0;
+}
+
+static int snd_hdspm_put_pref_sync_ref(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change, max;
+	unsigned int val;
+
+	max = 2;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+
+	val = ucontrol->value.enumerated.item[0] % max;
+
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_pref_sync_ref(hdspm);
+	hdspm_set_pref_sync_ref(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_AUTOSYNC_REF(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ, \
+  .info = snd_hdspm_info_autosync_ref, \
+  .get = snd_hdspm_get_autosync_ref, \
+}
+
+static int hdspm_autosync_ref(hdspm_t * hdspm)
+{
+	/* This looks at the autosync selected sync reference */
+	unsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+
+	switch (status2 & HDSPM_SelSyncRefMask) {
+
+	case HDSPM_SelSyncRef_WORD:
+		return HDSPM_AUTOSYNC_FROM_WORD;
+
+	case HDSPM_SelSyncRef_MADI:
+		return HDSPM_AUTOSYNC_FROM_MADI;
+
+	case HDSPM_SelSyncRef_NVALID:
+		return HDSPM_AUTOSYNC_FROM_NONE;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int snd_hdspm_info_autosync_ref(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = { "WordClock", "MADI", "None" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 3;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_hdspm_get_autosync_ref(snd_kcontrol_t * kcontrol,
+				      snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm_pref_sync_ref(hdspm);
+	return 0;
+}
+
+#define HDSPM_LINE_OUT(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_line_out, \
+  .get = snd_hdspm_get_line_out, \
+  .put = snd_hdspm_put_line_out \
+}
+
+static int hdspm_line_out(hdspm_t * hdspm)
+{
+	return (hdspm->control_register & HDSPM_LineOut) ? 1 : 0;
+}
+
+
+static int hdspm_set_line_output(hdspm_t * hdspm, int out)
+{
+	if (out)
+		hdspm->control_register |= HDSPM_LineOut;
+	else
+		hdspm->control_register &= ~HDSPM_LineOut;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_line_out(snd_kcontrol_t * kcontrol,
+				   snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_line_out(snd_kcontrol_t * kcontrol,
+				  snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.integer.value[0] = hdspm_line_out(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_line_out(snd_kcontrol_t * kcontrol,
+				  snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_line_out(hdspm);
+	hdspm_set_line_output(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_TX_64(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_tx_64, \
+  .get = snd_hdspm_get_tx_64, \
+  .put = snd_hdspm_put_tx_64 \
+}
+
+static int hdspm_tx_64(hdspm_t * hdspm)
+{
+	return (hdspm->control_register & HDSPM_TX_64ch) ? 1 : 0;
+}
+
+static int hdspm_set_tx_64(hdspm_t * hdspm, int out)
+{
+	if (out)
+		hdspm->control_register |= HDSPM_TX_64ch;
+	else
+		hdspm->control_register &= ~HDSPM_TX_64ch;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_tx_64(snd_kcontrol_t * kcontrol,
+				snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_tx_64(snd_kcontrol_t * kcontrol,
+			       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.integer.value[0] = hdspm_tx_64(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_tx_64(snd_kcontrol_t * kcontrol,
+			       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_tx_64(hdspm);
+	hdspm_set_tx_64(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_C_TMS(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_c_tms, \
+  .get = snd_hdspm_get_c_tms, \
+  .put = snd_hdspm_put_c_tms \
+}
+
+static int hdspm_c_tms(hdspm_t * hdspm)
+{
+	return (hdspm->control_register & HDSPM_clr_tms) ? 1 : 0;
+}
+
+static int hdspm_set_c_tms(hdspm_t * hdspm, int out)
+{
+	if (out)
+		hdspm->control_register |= HDSPM_clr_tms;
+	else
+		hdspm->control_register &= ~HDSPM_clr_tms;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_c_tms(snd_kcontrol_t * kcontrol,
+				snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_c_tms(snd_kcontrol_t * kcontrol,
+			       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.integer.value[0] = hdspm_c_tms(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_c_tms(snd_kcontrol_t * kcontrol,
+			       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_c_tms(hdspm);
+	hdspm_set_c_tms(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_SAFE_MODE(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_safe_mode, \
+  .get = snd_hdspm_get_safe_mode, \
+  .put = snd_hdspm_put_safe_mode \
+}
+
+static int hdspm_safe_mode(hdspm_t * hdspm)
+{
+	return (hdspm->control_register & HDSPM_AutoInp) ? 1 : 0;
+}
+
+static int hdspm_set_safe_mode(hdspm_t * hdspm, int out)
+{
+	if (out)
+		hdspm->control_register |= HDSPM_AutoInp;
+	else
+		hdspm->control_register &= ~HDSPM_AutoInp;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_safe_mode(snd_kcontrol_t * kcontrol,
+				    snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_safe_mode(snd_kcontrol_t * kcontrol,
+				   snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.integer.value[0] = hdspm_safe_mode(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_safe_mode(snd_kcontrol_t * kcontrol,
+				   snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_safe_mode(hdspm);
+	hdspm_set_safe_mode(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_INPUT_SELECT(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .info = snd_hdspm_info_input_select, \
+  .get = snd_hdspm_get_input_select, \
+  .put = snd_hdspm_put_input_select \
+}
+
+static int hdspm_input_select(hdspm_t * hdspm)
+{
+	return (hdspm->control_register & HDSPM_InputSelect0) ? 1 : 0;
+}
+
+static int hdspm_set_input_select(hdspm_t * hdspm, int out)
+{
+	if (out)
+		hdspm->control_register |= HDSPM_InputSelect0;
+	else
+		hdspm->control_register &= ~HDSPM_InputSelect0;
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+	return 0;
+}
+
+static int snd_hdspm_info_input_select(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = { "optical", "coaxial" };
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 2;
+
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+
+	return 0;
+}
+
+static int snd_hdspm_get_input_select(snd_kcontrol_t * kcontrol,
+				      snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.enumerated.item[0] = hdspm_input_select(hdspm);
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_put_input_select(snd_kcontrol_t * kcontrol,
+				      snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	unsigned int val;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+	val = ucontrol->value.integer.value[0] & 1;
+	spin_lock_irq(&hdspm->lock);
+	change = (int) val != hdspm_input_select(hdspm);
+	hdspm_set_input_select(hdspm, val);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+/*           Simple Mixer
+  deprecated since to much faders ???
+  MIXER interface says output (source, destination, value)
+   where source > MAX_channels are playback channels 
+   on MADICARD 
+  - playback mixer matrix: [channelout+64] [output] [value]
+  - input(thru) mixer matrix: [channelin] [output] [value]
+  (better do 2 kontrols for seperation ?)
+*/
+
+#define HDSPM_MIXER(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READWRITE | \
+		 SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  .info = snd_hdspm_info_mixer, \
+  .get = snd_hdspm_get_mixer, \
+  .put = snd_hdspm_put_mixer \
+}
+
+static int snd_hdspm_info_mixer(snd_kcontrol_t * kcontrol,
+				snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 3;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 65535;
+	uinfo->value.integer.step = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_mixer(snd_kcontrol_t * kcontrol,
+			       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int source;
+	int destination;
+
+	source = ucontrol->value.integer.value[0];
+	if (source < 0)
+		source = 0;
+	else if (source >= 2 * HDSPM_MAX_CHANNELS)
+		source = 2 * HDSPM_MAX_CHANNELS - 1;
+
+	destination = ucontrol->value.integer.value[1];
+	if (destination < 0)
+		destination = 0;
+	else if (destination >= HDSPM_MAX_CHANNELS)
+		destination = HDSPM_MAX_CHANNELS - 1;
+
+	spin_lock_irq(&hdspm->lock);
+	if (source >= HDSPM_MAX_CHANNELS)
+		ucontrol->value.integer.value[2] =
+		    hdspm_read_pb_gain(hdspm, destination,
+				       source - HDSPM_MAX_CHANNELS);
+	else
+		ucontrol->value.integer.value[2] =
+		    hdspm_read_in_gain(hdspm, destination, source);
+
+	spin_unlock_irq(&hdspm->lock);
+
+	return 0;
+}
+
+static int snd_hdspm_put_mixer(snd_kcontrol_t * kcontrol,
+			       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	int source;
+	int destination;
+	int gain;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+
+	source = ucontrol->value.integer.value[0];
+	destination = ucontrol->value.integer.value[1];
+
+	if (source < 0 || source >= 2 * HDSPM_MAX_CHANNELS)
+		return -1;
+	if (destination < 0 || destination >= HDSPM_MAX_CHANNELS)
+		return -1;
+
+	gain = ucontrol->value.integer.value[2];
+
+	spin_lock_irq(&hdspm->lock);
+
+	if (source >= HDSPM_MAX_CHANNELS)
+		change = gain != hdspm_read_pb_gain(hdspm, destination,
+						    source -
+						    HDSPM_MAX_CHANNELS);
+	else
+		change =
+		    gain != hdspm_read_in_gain(hdspm, destination, source);
+
+	if (change) {
+		if (source >= HDSPM_MAX_CHANNELS)
+			hdspm_write_pb_gain(hdspm, destination,
+					    source - HDSPM_MAX_CHANNELS,
+					    gain);
+		else
+			hdspm_write_in_gain(hdspm, destination, source,
+					    gain);
+	}
+	spin_unlock_irq(&hdspm->lock);
+
+	return change;
+}
+
+/* The simple mixer control(s) provide gain control for the
+   basic 1:1 mappings of playback streams to output
+   streams. 
+*/
+
+#define HDSPM_PLAYBACK_MIXER \
+{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE | \
+		 SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  .info = snd_hdspm_info_playback_mixer, \
+  .get = snd_hdspm_get_playback_mixer, \
+  .put = snd_hdspm_put_playback_mixer \
+}
+
+static int snd_hdspm_info_playback_mixer(snd_kcontrol_t * kcontrol,
+					 snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 65536;
+	uinfo->value.integer.step = 1;
+	return 0;
+}
+
+static int snd_hdspm_get_playback_mixer(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int channel;
+	int mapped_channel;
+
+	channel = ucontrol->id.index - 1;
+
+	snd_assert(channel >= 0
+		   || channel < HDSPM_MAX_CHANNELS, return -EINVAL);
+
+	if ((mapped_channel = hdspm->channel_map[channel]) < 0)
+		return -EINVAL;
+
+	spin_lock_irq(&hdspm->lock);
+	ucontrol->value.integer.value[0] =
+	    hdspm_read_pb_gain(hdspm, mapped_channel, mapped_channel);
+	spin_unlock_irq(&hdspm->lock);
+
+	/*    snd_printdd("get pb mixer index %d, channel %d, mapped_channel %d, value %d\n",
+	   ucontrol->id.index,        channel, mapped_channel,  ucontrol->value.integer.value[0]); 
+	 */
+
+	return 0;
+}
+
+static int snd_hdspm_put_playback_mixer(snd_kcontrol_t * kcontrol,
+					snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+	int change;
+	int channel;
+	int mapped_channel;
+	int gain;
+
+	if (!snd_hdspm_use_is_exclusive(hdspm))
+		return -EBUSY;
+
+	channel = ucontrol->id.index - 1;
+
+	snd_assert(channel >= 0
+		   || channel < HDSPM_MAX_CHANNELS, return -EINVAL);
+
+	if ((mapped_channel = hdspm->channel_map[channel]) < 0)
+		return -EINVAL;
+
+	gain = ucontrol->value.integer.value[0];
+
+	spin_lock_irq(&hdspm->lock);
+	change =
+	    gain != hdspm_read_pb_gain(hdspm, mapped_channel,
+				       mapped_channel);
+	if (change)
+		hdspm_write_pb_gain(hdspm, mapped_channel, mapped_channel,
+				    gain);
+	spin_unlock_irq(&hdspm->lock);
+	return change;
+}
+
+#define HDSPM_WC_SYNC_CHECK(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  .info = snd_hdspm_info_sync_check, \
+  .get = snd_hdspm_get_wc_sync_check \
+}
+
+static int snd_hdspm_info_sync_check(snd_kcontrol_t * kcontrol,
+				     snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[] = { "No Lock", "Lock", "Sync" };
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 3;
+	if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)
+		uinfo->value.enumerated.item =
+		    uinfo->value.enumerated.items - 1;
+	strcpy(uinfo->value.enumerated.name,
+	       texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int hdspm_wc_sync_check(hdspm_t * hdspm)
+{
+	int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+	if (status2 & HDSPM_wcLock) {
+		if (status2 & HDSPM_wcSync)
+			return 2;
+		else
+			return 1;
+	}
+	return 0;
+}
+
+static int snd_hdspm_get_wc_sync_check(snd_kcontrol_t * kcontrol,
+				       snd_ctl_elem_value_t * ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] = hdspm_wc_sync_check(hdspm);
+	return 0;
+}
+
+
+#define HDSPM_MADI_SYNC_CHECK(xname, xindex) \
+{ .iface = SNDRV_CTL_ELEM_IFACE_HWDEP, \
+  .name = xname, \
+  .index = xindex, \
+  .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE, \
+  .info = snd_hdspm_info_sync_check, \
+  .get = snd_hdspm_get_madisync_sync_check \
+}
+
+static int hdspm_madisync_sync_check(hdspm_t * hdspm)
+{
+	int status = hdspm_read(hdspm, HDSPM_statusRegister);
+	if (status & HDSPM_madiLock) {
+		if (status & HDSPM_madiSync)
+			return 2;
+		else
+			return 1;
+	}
+	return 0;
+}
+
+static int snd_hdspm_get_madisync_sync_check(snd_kcontrol_t * kcontrol,
+					     snd_ctl_elem_value_t *
+					     ucontrol)
+{
+	hdspm_t *hdspm = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.enumerated.item[0] =
+	    hdspm_madisync_sync_check(hdspm);
+	return 0;
+}
+
+
+
+
+static snd_kcontrol_new_t snd_hdspm_controls[] = {
+
+	HDSPM_MIXER("Mixer", 0),
+/* 'Sample Clock Source' complies with the alsa control naming scheme */
+	HDSPM_CLOCK_SOURCE("Sample Clock Source", 0),
+
+	HDSPM_SYSTEM_CLOCK_MODE("System Clock Mode", 0),
+	HDSPM_PREF_SYNC_REF("Preferred Sync Reference", 0),
+	HDSPM_AUTOSYNC_REF("AutoSync Reference", 0),
+	HDSPM_SYSTEM_SAMPLE_RATE("System Sample Rate", 0),
+/* 'External Rate' complies with the alsa control naming scheme */
+	HDSPM_AUTOSYNC_SAMPLE_RATE("External Rate", 0),
+	HDSPM_WC_SYNC_CHECK("Word Clock Lock Status", 0),
+	HDSPM_MADI_SYNC_CHECK("MADI Sync Lock Status", 0),
+	HDSPM_LINE_OUT("Line Out", 0),
+	HDSPM_TX_64("TX 64 channels mode", 0),
+	HDSPM_C_TMS("Clear Track Marker", 0),
+	HDSPM_SAFE_MODE("Safe Mode", 0),
+	HDSPM_INPUT_SELECT("Input Select", 0),
+};
+
+static snd_kcontrol_new_t snd_hdspm_playback_mixer = HDSPM_PLAYBACK_MIXER;
+
+
+static int hdspm_update_simple_mixer_controls(hdspm_t * hdspm)
+{
+	int i;
+
+	for (i = hdspm->ds_channels; i < hdspm->ss_channels; ++i) {
+		if (hdspm->system_sample_rate > 48000) {
+			hdspm->playback_mixer_ctls[i]->vd[0].access =
+			    SNDRV_CTL_ELEM_ACCESS_INACTIVE |
+			    SNDRV_CTL_ELEM_ACCESS_READ |
+			    SNDRV_CTL_ELEM_ACCESS_VOLATILE;
+		} else {
+			hdspm->playback_mixer_ctls[i]->vd[0].access =
+			    SNDRV_CTL_ELEM_ACCESS_READWRITE |
+			    SNDRV_CTL_ELEM_ACCESS_VOLATILE;
+		}
+		snd_ctl_notify(hdspm->card, SNDRV_CTL_EVENT_MASK_VALUE |
+			       SNDRV_CTL_EVENT_MASK_INFO,
+			       &hdspm->playback_mixer_ctls[i]->id);
+	}
+
+	return 0;
+}
+
+
+static int snd_hdspm_create_controls(snd_card_t * card, hdspm_t * hdspm)
+{
+	unsigned int idx, limit;
+	int err;
+	snd_kcontrol_t *kctl;
+
+	/* add control list first */
+
+	for (idx = 0; idx < ARRAY_SIZE(snd_hdspm_controls); idx++) {
+		if ((err =
+		     snd_ctl_add(card, kctl =
+				 snd_ctl_new1(&snd_hdspm_controls[idx],
+					      hdspm))) < 0) {
+			return err;
+		}
+	}
+
+	/* Channel playback mixer as default control 
+	   Note: the whole matrix would be 128*HDSPM_MIXER_CHANNELS Faders, thats to big for any alsamixer 
+	   they are accesible via special IOCTL on hwdep
+	   and the mixer 2dimensional mixer control */
+
+	snd_hdspm_playback_mixer.name = "Chn";
+	limit = HDSPM_MAX_CHANNELS;
+
+	/* The index values are one greater than the channel ID so that alsamixer
+	   will display them correctly. We want to use the index for fast lookup
+	   of the relevant channel, but if we use it at all, most ALSA software
+	   does the wrong thing with it ...
+	 */
+
+	for (idx = 0; idx < limit; ++idx) {
+		snd_hdspm_playback_mixer.index = idx + 1;
+		if ((err = snd_ctl_add(card,
+				       kctl =
+				       snd_ctl_new1
+				       (&snd_hdspm_playback_mixer,
+					hdspm)))) {
+			return err;
+		}
+		hdspm->playback_mixer_ctls[idx] = kctl;
+	}
+
+	return 0;
+}
+
+/*------------------------------------------------------------
+   /proc interface 
+ ------------------------------------------------------------*/
+
+static void
+snd_hdspm_proc_read(snd_info_entry_t * entry, snd_info_buffer_t * buffer)
+{
+	hdspm_t *hdspm = (hdspm_t *) entry->private_data;
+	unsigned int status;
+	unsigned int status2;
+	char *pref_sync_ref;
+	char *autosync_ref;
+	char *system_clock_mode;
+	char *clock_source;
+	char *insel;
+	char *syncref;
+	int x, x2;
+
+	status = hdspm_read(hdspm, HDSPM_statusRegister);
+	status2 = hdspm_read(hdspm, HDSPM_statusRegister2);
+
+	snd_iprintf(buffer, "%s (Card #%d) Rev.%x Status2first3bits: %x\n",
+		    hdspm->card_name, hdspm->card->number + 1,
+		    hdspm->firmware_rev,
+		    (status2 & HDSPM_version0) |
+		    (status2 & HDSPM_version1) | (status2 &
+						  HDSPM_version2));
+
+	snd_iprintf(buffer, "IRQ: %d Registers bus: 0x%lx VM: 0x%lx\n",
+		    hdspm->irq, hdspm->port, (unsigned long)hdspm->iobase);
+
+	snd_iprintf(buffer, "--- System ---\n");
+
+	snd_iprintf(buffer,
+		    "IRQ Pending: Audio=%d, MIDI0=%d, MIDI1=%d, IRQcount=%d\n",
+		    status & HDSPM_audioIRQPending,
+		    (status & HDSPM_midi0IRQPending) ? 1 : 0,
+		    (status & HDSPM_midi1IRQPending) ? 1 : 0,
+		    hdspm->irq_count);
+	snd_iprintf(buffer,
+		    "HW pointer: id = %d, rawptr = %d (%d->%d) estimated= %ld (bytes)\n",
+		    ((status & HDSPM_BufferID) ? 1 : 0),
+		    (status & HDSPM_BufferPositionMask),
+		    (status & HDSPM_BufferPositionMask) % (2 *
+							   (int)hdspm->
+							   period_bytes),
+		    ((status & HDSPM_BufferPositionMask) -
+		     64) % (2 * (int)hdspm->period_bytes),
+		    (long) hdspm_hw_pointer(hdspm) * 4);
+
+	snd_iprintf(buffer,
+		    "MIDI FIFO: Out1=0x%x, Out2=0x%x, In1=0x%x, In2=0x%x \n",
+		    hdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xFF,
+		    hdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xFF,
+		    hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,
+		    hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);
+	snd_iprintf(buffer,
+		    "Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, status2=0x%x\n",
+		    hdspm->control_register, hdspm->control2_register,
+		    status, status2);
+
+	snd_iprintf(buffer, "--- Settings ---\n");
+
+	x = 1 << (6 +
+		  hdspm_decode_latency(hdspm->
+				       control_register &
+				       HDSPM_LatencyMask));
+
+	snd_iprintf(buffer,
+		    "Size (Latency): %d samples (2 periods of %lu bytes)\n",
+		    x, (unsigned long) hdspm->period_bytes);
+
+	snd_iprintf(buffer, "Line out: %s,   Precise Pointer: %s\n",
+		    (hdspm->
+		     control_register & HDSPM_LineOut) ? "on " : "off",
+		    (hdspm->precise_ptr) ? "on" : "off");
+
+	switch (hdspm->control_register & HDSPM_InputMask) {
+	case HDSPM_InputOptical:
+		insel = "Optical";
+		break;
+	case HDSPM_InputCoaxial:
+		insel = "Coaxial";
+		break;
+	default:
+		insel = "Unkown";
+	}
+
+	switch (hdspm->control_register & HDSPM_SyncRefMask) {
+	case HDSPM_SyncRef_Word:
+		syncref = "WordClock";
+		break;
+	case HDSPM_SyncRef_MADI:
+		syncref = "MADI";
+		break;
+	default:
+		syncref = "Unkown";
+	}
+	snd_iprintf(buffer, "Inputsel = %s, SyncRef = %s\n", insel,
+		    syncref);
+
+	snd_iprintf(buffer,
+		    "ClearTrackMarker = %s, Transmit in %s Channel Mode, Auto Input %s\n",
+		    (hdspm->
+		     control_register & HDSPM_clr_tms) ? "on" : "off",
+		    (hdspm->
+		     control_register & HDSPM_TX_64ch) ? "64" : "56",
+		    (hdspm->
+		     control_register & HDSPM_AutoInp) ? "on" : "off");
+
+	switch (hdspm_clock_source(hdspm)) {
+	case HDSPM_CLOCK_SOURCE_AUTOSYNC:
+		clock_source = "AutoSync";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_32KHZ:
+		clock_source = "Internal 32 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_44_1KHZ:
+		clock_source = "Internal 44.1 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_48KHZ:
+		clock_source = "Internal 48 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_64KHZ:
+		clock_source = "Internal 64 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_88_2KHZ:
+		clock_source = "Internal 88.2 kHz";
+		break;
+	case HDSPM_CLOCK_SOURCE_INTERNAL_96KHZ:
+		clock_source = "Internal 96 kHz";
+		break;
+	default:
+		clock_source = "Error";
+	}
+	snd_iprintf(buffer, "Sample Clock Source: %s\n", clock_source);
+	if (!(hdspm->control_register & HDSPM_ClockModeMaster)) {
+		system_clock_mode = "Slave";
+	} else {
+		system_clock_mode = "Master";
+	}
+	snd_iprintf(buffer, "System Clock Mode: %s\n", system_clock_mode);
+
+	switch (hdspm_pref_sync_ref(hdspm)) {
+	case HDSPM_SYNC_FROM_WORD:
+		pref_sync_ref = "Word Clock";
+		break;
+	case HDSPM_SYNC_FROM_MADI:
+		pref_sync_ref = "MADI Sync";
+		break;
+	default:
+		pref_sync_ref = "XXXX Clock";
+		break;
+	}
+	snd_iprintf(buffer, "Preferred Sync Reference: %s\n",
+		    pref_sync_ref);
+
+	snd_iprintf(buffer, "System Clock Frequency: %d\n",
+		    hdspm->system_sample_rate);
+
+
+	snd_iprintf(buffer, "--- Status:\n");
+
+	x = status & HDSPM_madiSync;
+	x2 = status2 & HDSPM_wcSync;
+
+	snd_iprintf(buffer, "Inputs MADI=%s, WordClock=%s\n",
+		    (status & HDSPM_madiLock) ? (x ? "Sync" : "Lock") :
+		    "NoLock",
+		    (status2 & HDSPM_wcLock) ? (x2 ? "Sync" : "Lock") :
+		    "NoLock");
+
+	switch (hdspm_autosync_ref(hdspm)) {
+	case HDSPM_AUTOSYNC_FROM_WORD:
+		autosync_ref = "Word Clock";
+		break;
+	case HDSPM_AUTOSYNC_FROM_MADI:
+		autosync_ref = "MADI Sync";
+		break;
+	case HDSPM_AUTOSYNC_FROM_NONE:
+		autosync_ref = "Input not valid";
+		break;
+	default:
+		autosync_ref = "---";
+		break;
+	}
+	snd_iprintf(buffer,
+		    "AutoSync: Reference= %s, Freq=%d (MADI = %d, Word = %d)\n",
+		    autosync_ref, hdspm_external_sample_rate(hdspm),
+		    (status & HDSPM_madiFreqMask) >> 22,
+		    (status2 & HDSPM_wcFreqMask) >> 5);
+
+	snd_iprintf(buffer, "Input: %s, Mode=%s\n",
+		    (status & HDSPM_AB_int) ? "Coax" : "Optical",
+		    (status & HDSPM_RX_64ch) ? "64 channels" :
+		    "56 channels");
+
+	snd_iprintf(buffer, "\n");
+}
+
+static void __devinit snd_hdspm_proc_init(hdspm_t * hdspm)
+{
+	snd_info_entry_t *entry;
+
+	if (!snd_card_proc_new(hdspm->card, "hdspm", &entry))
+		snd_info_set_text_ops(entry, hdspm, 1024,
+				      snd_hdspm_proc_read);
+}
+
+/*------------------------------------------------------------
+   hdspm intitialize 
+ ------------------------------------------------------------*/
+
+static int snd_hdspm_set_defaults(hdspm_t * hdspm)
+{
+	unsigned int i;
+
+	/* ASSUMPTION: hdspm->lock is either held, or there is no need to
+	   hold it (e.g. during module initalization).
+	 */
+
+	/* set defaults:       */
+
+	hdspm->control_register = HDSPM_ClockModeMaster |	/* Master Cloack Mode on */
+	    hdspm_encode_latency(7) |	/* latency maximum = 8192 samples */
+	    HDSPM_InputCoaxial |	/* Input Coax not Optical */
+	    HDSPM_SyncRef_MADI |	/* Madi is syncclock */
+	    HDSPM_LineOut |	/* Analog output in */
+	    HDSPM_TX_64ch |	/* transmit in 64ch mode */
+	    HDSPM_AutoInp;	/* AutoInput chossing (takeover) */
+
+	/* ! HDSPM_Frequency0|HDSPM_Frequency1 = 44.1khz */
+	/* !  HDSPM_DoubleSpeed HDSPM_QuadSpeed = normal speed */
+	/* ! HDSPM_clr_tms = do not clear bits in track marks */
+
+	hdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);
+
+#ifdef SNDRV_BIG_ENDIAN
+	hdspm->control2_register = HDSPM_BIGENDIAN_MODE;
+#else
+	hdspm->control2_register = 0;
+#endif
+
+	hdspm_write(hdspm, HDSPM_control2Reg, hdspm->control2_register);
+	hdspm_compute_period_size(hdspm);
+
+	/* silence everything */
+
+	all_in_all_mixer(hdspm, 0 * UNITY_GAIN);
+
+	if (line_outs_monitor[hdspm->dev]) {
+
+		snd_printk(KERN_INFO "HDSPM: sending all playback streams to line outs.\n");
+
+		for (i = 0; i < HDSPM_MIXER_CHANNELS; i++) {
+			if (hdspm_write_pb_gain(hdspm, i, i, UNITY_GAIN))
+				return -EIO;
+		}
+	}
+
+	/* set a default rate so that the channel map is set up. */
+	hdspm->channel_map = channel_map_madi_ss;
+	hdspm_set_rate(hdspm, 44100, 1);
+
+	return 0;
+}
+
+
+/*------------------------------------------------------------
+   interupt 
+ ------------------------------------------------------------*/
+
+static irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id,
+				       struct pt_regs *regs)
+{
+	hdspm_t *hdspm = (hdspm_t *) dev_id;
+	unsigned int status;
+	int audio;
+	int midi0;
+	int midi1;
+	unsigned int midi0status;
+	unsigned int midi1status;
+	int schedule = 0;
+
+	status = hdspm_read(hdspm, HDSPM_statusRegister);
+
+	audio = status & HDSPM_audioIRQPending;
+	midi0 = status & HDSPM_midi0IRQPending;
+	midi1 = status & HDSPM_midi1IRQPending;
+
+	if (!audio && !midi0 && !midi1)
+		return IRQ_NONE;
+
+	hdspm_write(hdspm, HDSPM_interruptConfirmation, 0);
+	hdspm->irq_count++;
+
+	midi0status = hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xff;
+	midi1status = hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xff;
+
+	if (audio) {
+
+		if (hdspm->capture_substream)
+			snd_pcm_period_elapsed(hdspm->pcm->
+					       streams
+					       [SNDRV_PCM_STREAM_CAPTURE].
+					       substream);
+
+		if (hdspm->playback_substream)
+			snd_pcm_period_elapsed(hdspm->pcm->
+					       streams
+					       [SNDRV_PCM_STREAM_PLAYBACK].
+					       substream);
+	}
+
+	if (midi0 && midi0status) {
+		/* we disable interrupts for this input until processing is done */
+		hdspm->control_register &= ~HDSPM_Midi0InterruptEnable;
+		hdspm_write(hdspm, HDSPM_controlRegister,
+			    hdspm->control_register);
+		hdspm->midi[0].pending = 1;
+		schedule = 1;
+	}
+	if (midi1 && midi1status) {
+		/* we disable interrupts for this input until processing is done */
+		hdspm->control_register &= ~HDSPM_Midi1InterruptEnable;
+		hdspm_write(hdspm, HDSPM_controlRegister,
+			    hdspm->control_register);
+		hdspm->midi[1].pending = 1;
+		schedule = 1;
+	}
+	if (schedule)
+		tasklet_hi_schedule(&hdspm->midi_tasklet);
+	return IRQ_HANDLED;
+}
+
+/*------------------------------------------------------------
+   pcm interface 
+  ------------------------------------------------------------*/
+
+
+static snd_pcm_uframes_t snd_hdspm_hw_pointer(snd_pcm_substream_t *
+					      substream)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	return hdspm_hw_pointer(hdspm);
+}
+
+static char *hdspm_channel_buffer_location(hdspm_t * hdspm,
+					   int stream, int channel)
+{
+	int mapped_channel;
+
+	snd_assert(channel >= 0
+		   || channel < HDSPM_MAX_CHANNELS, return NULL);
+
+	if ((mapped_channel = hdspm->channel_map[channel]) < 0)
+		return NULL;
+
+	if (stream == SNDRV_PCM_STREAM_CAPTURE) {
+		return hdspm->capture_buffer +
+		    mapped_channel * HDSPM_CHANNEL_BUFFER_BYTES;
+	} else {
+		return hdspm->playback_buffer +
+		    mapped_channel * HDSPM_CHANNEL_BUFFER_BYTES;
+	}
+}
+
+
+/* dont know why need it ??? */
+static int snd_hdspm_playback_copy(snd_pcm_substream_t * substream,
+				   int channel, snd_pcm_uframes_t pos,
+				   void __user *src, snd_pcm_uframes_t count)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	char *channel_buf;
+
+	snd_assert(pos + count <= HDSPM_CHANNEL_BUFFER_BYTES / 4,
+		   return -EINVAL);
+
+	channel_buf = hdspm_channel_buffer_location(hdspm,
+						    substream->pstr->
+						    stream, channel);
+
+	snd_assert(channel_buf != NULL, return -EIO);
+
+	return copy_from_user(channel_buf + pos * 4, src, count * 4);
+}
+
+static int snd_hdspm_capture_copy(snd_pcm_substream_t * substream,
+				  int channel, snd_pcm_uframes_t pos,
+				  void __user *dst, snd_pcm_uframes_t count)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	char *channel_buf;
+
+	snd_assert(pos + count <= HDSPM_CHANNEL_BUFFER_BYTES / 4,
+		   return -EINVAL);
+
+	channel_buf = hdspm_channel_buffer_location(hdspm,
+						    substream->pstr->
+						    stream, channel);
+	snd_assert(channel_buf != NULL, return -EIO);
+	return copy_to_user(dst, channel_buf + pos * 4, count * 4);
+}
+
+static int snd_hdspm_hw_silence(snd_pcm_substream_t * substream,
+				int channel, snd_pcm_uframes_t pos,
+				snd_pcm_uframes_t count)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	char *channel_buf;
+
+	channel_buf =
+	    hdspm_channel_buffer_location(hdspm, substream->pstr->stream,
+					  channel);
+	snd_assert(channel_buf != NULL, return -EIO);
+	memset(channel_buf + pos * 4, 0, count * 4);
+	return 0;
+}
+
+static int snd_hdspm_reset(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	snd_pcm_substream_t *other;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		other = hdspm->capture_substream;
+	else
+		other = hdspm->playback_substream;
+
+	if (hdspm->running)
+		runtime->status->hw_ptr = hdspm_hw_pointer(hdspm);
+	else
+		runtime->status->hw_ptr = 0;
+	if (other) {
+		struct list_head *pos;
+		snd_pcm_substream_t *s;
+		snd_pcm_runtime_t *oruntime = other->runtime;
+		snd_pcm_group_for_each(pos, substream) {
+			s = snd_pcm_group_substream_entry(pos);
+			if (s == other) {
+				oruntime->status->hw_ptr =
+				    runtime->status->hw_ptr;
+				break;
+			}
+		}
+	}
+	return 0;
+}
+
+static int snd_hdspm_hw_params(snd_pcm_substream_t * substream,
+			       snd_pcm_hw_params_t * params)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	int err;
+	int i;
+	pid_t this_pid;
+	pid_t other_pid;
+	struct snd_sg_buf *sgbuf;
+
+
+	spin_lock_irq(&hdspm->lock);
+
+	if (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		this_pid = hdspm->playback_pid;
+		other_pid = hdspm->capture_pid;
+	} else {
+		this_pid = hdspm->capture_pid;
+		other_pid = hdspm->playback_pid;
+	}
+
+	if ((other_pid > 0) && (this_pid != other_pid)) {
+
+		/* The other stream is open, and not by the same
+		   task as this one. Make sure that the parameters
+		   that matter are the same.
+		 */
+
+		if (params_rate(params) != hdspm->system_sample_rate) {
+			spin_unlock_irq(&hdspm->lock);
+			_snd_pcm_hw_param_setempty(params,
+						   SNDRV_PCM_HW_PARAM_RATE);
+			return -EBUSY;
+		}
+
+		if (params_period_size(params) != hdspm->period_bytes / 4) {
+			spin_unlock_irq(&hdspm->lock);
+			_snd_pcm_hw_param_setempty(params,
+						   SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+			return -EBUSY;
+		}
+
+	}
+	/* We're fine. */
+	spin_unlock_irq(&hdspm->lock);
+
+	/* how to make sure that the rate matches an externally-set one ?   */
+
+	spin_lock_irq(&hdspm->lock);
+	if ((err = hdspm_set_rate(hdspm, params_rate(params), 0)) < 0) {
+		spin_unlock_irq(&hdspm->lock);
+		_snd_pcm_hw_param_setempty(params,
+					   SNDRV_PCM_HW_PARAM_RATE);
+		return err;
+	}
+	spin_unlock_irq(&hdspm->lock);
+
+	if ((err =
+	     hdspm_set_interrupt_interval(hdspm,
+					  params_period_size(params))) <
+	    0) {
+		_snd_pcm_hw_param_setempty(params,
+					   SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+		return err;
+	}
+
+	/* Memory allocation, takashi's method, dont know if we should spinlock  */
+	/* malloc all buffer even if not enabled to get sure */
+	/* malloc only needed bytes */
+	err =
+	    snd_pcm_lib_malloc_pages(substream,
+				     HDSPM_CHANNEL_BUFFER_BYTES *
+				     params_channels(params));
+	if (err < 0)
+		return err;
+
+	sgbuf = snd_pcm_substream_sgbuf(substream);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+
+		hdspm_set_sgbuf(hdspm, sgbuf, HDSPM_pageAddressBufferOut,
+				params_channels(params));
+
+		for (i = 0; i < params_channels(params); ++i)
+			snd_hdspm_enable_out(hdspm, i, 1);
+
+		hdspm->playback_buffer =
+		    (unsigned char *) substream->runtime->dma_area;
+	} else {
+		hdspm_set_sgbuf(hdspm, sgbuf, HDSPM_pageAddressBufferIn,
+				params_channels(params));
+
+		for (i = 0; i < params_channels(params); ++i)
+			snd_hdspm_enable_in(hdspm, i, 1);
+
+		hdspm->capture_buffer =
+		    (unsigned char *) substream->runtime->dma_area;
+	}
+	return 0;
+}
+
+static int snd_hdspm_hw_free(snd_pcm_substream_t * substream)
+{
+	int i;
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+
+		/* params_channels(params) should be enough, 
+		   but to get sure in case of error */
+		for (i = 0; i < HDSPM_MAX_CHANNELS; ++i)
+			snd_hdspm_enable_out(hdspm, i, 0);
+
+		hdspm->playback_buffer = NULL;
+	} else {
+		for (i = 0; i < HDSPM_MAX_CHANNELS; ++i)
+			snd_hdspm_enable_in(hdspm, i, 0);
+
+		hdspm->capture_buffer = NULL;
+
+	}
+
+	snd_pcm_lib_free_pages(substream);
+
+	return 0;
+}
+
+static int snd_hdspm_channel_info(snd_pcm_substream_t * substream,
+				  snd_pcm_channel_info_t * info)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	int mapped_channel;
+
+	snd_assert(info->channel < HDSPM_MAX_CHANNELS, return -EINVAL);
+
+	if ((mapped_channel = hdspm->channel_map[info->channel]) < 0)
+		return -EINVAL;
+
+	info->offset = mapped_channel * HDSPM_CHANNEL_BUFFER_BYTES;
+	info->first = 0;
+	info->step = 32;
+	return 0;
+}
+
+static int snd_hdspm_ioctl(snd_pcm_substream_t * substream,
+			   unsigned int cmd, void *arg)
+{
+	switch (cmd) {
+	case SNDRV_PCM_IOCTL1_RESET:
+		{
+			return snd_hdspm_reset(substream);
+		}
+
+	case SNDRV_PCM_IOCTL1_CHANNEL_INFO:
+		{
+			snd_pcm_channel_info_t *info = arg;
+			return snd_hdspm_channel_info(substream, info);
+		}
+	default:
+		break;
+	}
+
+	return snd_pcm_lib_ioctl(substream, cmd, arg);
+}
+
+static int snd_hdspm_trigger(snd_pcm_substream_t * substream, int cmd)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	snd_pcm_substream_t *other;
+	int running;
+
+	spin_lock(&hdspm->lock);
+	running = hdspm->running;
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		running |= 1 << substream->stream;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		running &= ~(1 << substream->stream);
+		break;
+	default:
+		snd_BUG();
+		spin_unlock(&hdspm->lock);
+		return -EINVAL;
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		other = hdspm->capture_substream;
+	else
+		other = hdspm->playback_substream;
+
+	if (other) {
+		struct list_head *pos;
+		snd_pcm_substream_t *s;
+		snd_pcm_group_for_each(pos, substream) {
+			s = snd_pcm_group_substream_entry(pos);
+			if (s == other) {
+				snd_pcm_trigger_done(s, substream);
+				if (cmd == SNDRV_PCM_TRIGGER_START)
+					running |= 1 << s->stream;
+				else
+					running &= ~(1 << s->stream);
+				goto _ok;
+			}
+		}
+		if (cmd == SNDRV_PCM_TRIGGER_START) {
+			if (!(running & (1 << SNDRV_PCM_STREAM_PLAYBACK))
+			    && substream->stream ==
+			    SNDRV_PCM_STREAM_CAPTURE)
+				hdspm_silence_playback(hdspm);
+		} else {
+			if (running &&
+			    substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				hdspm_silence_playback(hdspm);
+		}
+	} else {
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			hdspm_silence_playback(hdspm);
+	}
+      _ok:
+	snd_pcm_trigger_done(substream, substream);
+	if (!hdspm->running && running)
+		hdspm_start_audio(hdspm);
+	else if (hdspm->running && !running)
+		hdspm_stop_audio(hdspm);
+	hdspm->running = running;
+	spin_unlock(&hdspm->lock);
+
+	return 0;
+}
+
+static int snd_hdspm_prepare(snd_pcm_substream_t * substream)
+{
+	return 0;
+}
+
+static unsigned int period_sizes[] =
+    { 64, 128, 256, 512, 1024, 2048, 4096, 8192 };
+
+static snd_pcm_hardware_t snd_hdspm_playback_subinfo = {
+	.info = (SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_NONINTERLEAVED |
+		 SNDRV_PCM_INFO_SYNC_START | SNDRV_PCM_INFO_DOUBLE),
+	.formats = SNDRV_PCM_FMTBIT_S32_LE,
+	.rates = (SNDRV_PCM_RATE_32000 |
+		  SNDRV_PCM_RATE_44100 |
+		  SNDRV_PCM_RATE_48000 |
+		  SNDRV_PCM_RATE_64000 |
+		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000),
+	.rate_min = 32000,
+	.rate_max = 96000,
+	.channels_min = 1,
+	.channels_max = HDSPM_MAX_CHANNELS,
+	.buffer_bytes_max =
+	    HDSPM_CHANNEL_BUFFER_BYTES * HDSPM_MAX_CHANNELS,
+	.period_bytes_min = (64 * 4),
+	.period_bytes_max = (8192 * 4) * HDSPM_MAX_CHANNELS,
+	.periods_min = 2,
+	.periods_max = 2,
+	.fifo_size = 0
+};
+
+static snd_pcm_hardware_t snd_hdspm_capture_subinfo = {
+	.info = (SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_NONINTERLEAVED |
+		 SNDRV_PCM_INFO_SYNC_START),
+	.formats = SNDRV_PCM_FMTBIT_S32_LE,
+	.rates = (SNDRV_PCM_RATE_32000 |
+		  SNDRV_PCM_RATE_44100 |
+		  SNDRV_PCM_RATE_48000 |
+		  SNDRV_PCM_RATE_64000 |
+		  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000),
+	.rate_min = 32000,
+	.rate_max = 96000,
+	.channels_min = 1,
+	.channels_max = HDSPM_MAX_CHANNELS,
+	.buffer_bytes_max =
+	    HDSPM_CHANNEL_BUFFER_BYTES * HDSPM_MAX_CHANNELS,
+	.period_bytes_min = (64 * 4),
+	.period_bytes_max = (8192 * 4) * HDSPM_MAX_CHANNELS,
+	.periods_min = 2,
+	.periods_max = 2,
+	.fifo_size = 0
+};
+
+static snd_pcm_hw_constraint_list_t hw_constraints_period_sizes = {
+	.count = ARRAY_SIZE(period_sizes),
+	.list = period_sizes,
+	.mask = 0
+};
+
+
+static int snd_hdspm_hw_rule_channels_rate(snd_pcm_hw_params_t * params,
+					   snd_pcm_hw_rule_t * rule)
+{
+	hdspm_t *hdspm = rule->private;
+	snd_interval_t *c =
+	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	snd_interval_t *r =
+	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+
+	if (r->min > 48000) {
+		snd_interval_t t = {
+			.min = 1,
+			.max = hdspm->ds_channels,
+			.integer = 1,
+		};
+		return snd_interval_refine(c, &t);
+	} else if (r->max < 64000) {
+		snd_interval_t t = {
+			.min = 1,
+			.max = hdspm->ss_channels,
+			.integer = 1,
+		};
+		return snd_interval_refine(c, &t);
+	}
+	return 0;
+}
+
+static int snd_hdspm_hw_rule_rate_channels(snd_pcm_hw_params_t * params,
+					   snd_pcm_hw_rule_t * rule)
+{
+	hdspm_t *hdspm = rule->private;
+	snd_interval_t *c =
+	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+	snd_interval_t *r =
+	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+
+	if (c->min <= hdspm->ss_channels) {
+		snd_interval_t t = {
+			.min = 32000,
+			.max = 48000,
+			.integer = 1,
+		};
+		return snd_interval_refine(r, &t);
+	} else if (c->max > hdspm->ss_channels) {
+		snd_interval_t t = {
+			.min = 64000,
+			.max = 96000,
+			.integer = 1,
+		};
+
+		return snd_interval_refine(r, &t);
+	}
+	return 0;
+}
+
+static int snd_hdspm_playback_open(snd_pcm_substream_t * substream)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	snd_printdd("Open device substream %d\n", substream->stream);
+
+	spin_lock_irq(&hdspm->lock);
+
+	snd_pcm_set_sync(substream);
+
+	runtime->hw = snd_hdspm_playback_subinfo;
+
+	if (hdspm->capture_substream == NULL)
+		hdspm_stop_audio(hdspm);
+
+	hdspm->playback_pid = current->pid;
+	hdspm->playback_substream = substream;
+
+	spin_unlock_irq(&hdspm->lock);
+
+	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
+
+	snd_pcm_hw_constraint_list(runtime, 0,
+				   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+				   &hw_constraints_period_sizes);
+
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			    snd_hdspm_hw_rule_channels_rate, hdspm,
+			    SNDRV_PCM_HW_PARAM_RATE, -1);
+
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+			    snd_hdspm_hw_rule_rate_channels, hdspm,
+			    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+
+	return 0;
+}
+
+static int snd_hdspm_playback_release(snd_pcm_substream_t * substream)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+
+	spin_lock_irq(&hdspm->lock);
+
+	hdspm->playback_pid = -1;
+	hdspm->playback_substream = NULL;
+
+	spin_unlock_irq(&hdspm->lock);
+
+	return 0;
+}
+
+
+static int snd_hdspm_capture_open(snd_pcm_substream_t * substream)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+	snd_pcm_runtime_t *runtime = substream->runtime;
+
+	spin_lock_irq(&hdspm->lock);
+	snd_pcm_set_sync(substream);
+	runtime->hw = snd_hdspm_capture_subinfo;
+
+	if (hdspm->playback_substream == NULL)
+		hdspm_stop_audio(hdspm);
+
+	hdspm->capture_pid = current->pid;
+	hdspm->capture_substream = substream;
+
+	spin_unlock_irq(&hdspm->lock);
+
+	snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);
+	snd_pcm_hw_constraint_list(runtime, 0,
+				   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
+				   &hw_constraints_period_sizes);
+
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+			    snd_hdspm_hw_rule_channels_rate, hdspm,
+			    SNDRV_PCM_HW_PARAM_RATE, -1);
+
+	snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+			    snd_hdspm_hw_rule_rate_channels, hdspm,
+			    SNDRV_PCM_HW_PARAM_CHANNELS, -1);
+	return 0;
+}
+
+static int snd_hdspm_capture_release(snd_pcm_substream_t * substream)
+{
+	hdspm_t *hdspm = snd_pcm_substream_chip(substream);
+
+	spin_lock_irq(&hdspm->lock);
+
+	hdspm->capture_pid = -1;
+	hdspm->capture_substream = NULL;
+
+	spin_unlock_irq(&hdspm->lock);
+	return 0;
+}
+
+static int snd_hdspm_hwdep_dummy_op(snd_hwdep_t * hw, struct file *file)
+{
+	/* we have nothing to initialize but the call is required */
+	return 0;
+}
+
+
+static int snd_hdspm_hwdep_ioctl(snd_hwdep_t * hw, struct file *file,
+				 unsigned int cmd, unsigned long arg)
+{
+	hdspm_t *hdspm = (hdspm_t *) hw->private_data;
+	struct sndrv_hdspm_mixer_ioctl mixer;
+	hdspm_config_info_t info;
+	hdspm_version_t hdspm_version;
+	struct sndrv_hdspm_peak_rms_ioctl rms;
+
+	switch (cmd) {
+
+		
+	case SNDRV_HDSPM_IOCTL_GET_PEAK_RMS:
+		if (copy_from_user(&rms, (void __user *)arg, sizeof(rms)))
+			return -EFAULT;
+		/* maybe there is a chance to memorymap in future so dont touch just copy */
+		if(copy_to_user_fromio((void __user *)rms.peak,
+				       hdspm->iobase+HDSPM_MADI_peakrmsbase,
+				       sizeof(hdspm_peak_rms_t)) != 0 )
+			return -EFAULT;
+
+		break;
+		
+
+	case SNDRV_HDSPM_IOCTL_GET_CONFIG_INFO:
+
+		spin_lock_irq(&hdspm->lock);
+		info.pref_sync_ref =
+		    (unsigned char) hdspm_pref_sync_ref(hdspm);
+		info.wordclock_sync_check =
+		    (unsigned char) hdspm_wc_sync_check(hdspm);
+
+		info.system_sample_rate = hdspm->system_sample_rate;
+		info.autosync_sample_rate =
+		    hdspm_external_sample_rate(hdspm);
+		info.system_clock_mode =
+		    (unsigned char) hdspm_system_clock_mode(hdspm);
+		info.clock_source =
+		    (unsigned char) hdspm_clock_source(hdspm);
+		info.autosync_ref =
+		    (unsigned char) hdspm_autosync_ref(hdspm);
+		info.line_out = (unsigned char) hdspm_line_out(hdspm);
+		info.passthru = 0;
+		spin_unlock_irq(&hdspm->lock);
+		if (copy_to_user((void __user *) arg, &info, sizeof(info)))
+			return -EFAULT;
+		break;
+
+	case SNDRV_HDSPM_IOCTL_GET_VERSION:
+		hdspm_version.firmware_rev = hdspm->firmware_rev;
+		if (copy_to_user((void __user *) arg, &hdspm_version,
+				 sizeof(hdspm_version)))
+			return -EFAULT;
+		break;
+
+	case SNDRV_HDSPM_IOCTL_GET_MIXER:
+		if (copy_from_user(&mixer, (void __user *)arg, sizeof(mixer)))
+			return -EFAULT;
+		if (copy_to_user
+		    ((void __user *)mixer.mixer, hdspm->mixer, sizeof(hdspm_mixer_t)))
+			return -EFAULT;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static snd_pcm_ops_t snd_hdspm_playback_ops = {
+	.open = snd_hdspm_playback_open,
+	.close = snd_hdspm_playback_release,
+	.ioctl = snd_hdspm_ioctl,
+	.hw_params = snd_hdspm_hw_params,
+	.hw_free = snd_hdspm_hw_free,
+	.prepare = snd_hdspm_prepare,
+	.trigger = snd_hdspm_trigger,
+	.pointer = snd_hdspm_hw_pointer,
+	.copy = snd_hdspm_playback_copy,
+	.silence = snd_hdspm_hw_silence,
+	.page = snd_pcm_sgbuf_ops_page,
+};
+
+static snd_pcm_ops_t snd_hdspm_capture_ops = {
+	.open = snd_hdspm_capture_open,
+	.close = snd_hdspm_capture_release,
+	.ioctl = snd_hdspm_ioctl,
+	.hw_params = snd_hdspm_hw_params,
+	.hw_free = snd_hdspm_hw_free,
+	.prepare = snd_hdspm_prepare,
+	.trigger = snd_hdspm_trigger,
+	.pointer = snd_hdspm_hw_pointer,
+	.copy = snd_hdspm_capture_copy,
+	.page = snd_pcm_sgbuf_ops_page,
+};
+
+static int __devinit snd_hdspm_create_hwdep(snd_card_t * card,
+					    hdspm_t * hdspm)
+{
+	snd_hwdep_t *hw;
+	int err;
+
+	if ((err = snd_hwdep_new(card, "HDSPM hwdep", 0, &hw)) < 0)
+		return err;
+
+	hdspm->hwdep = hw;
+	hw->private_data = hdspm;
+	strcpy(hw->name, "HDSPM hwdep interface");
+
+	hw->ops.open = snd_hdspm_hwdep_dummy_op;
+	hw->ops.ioctl = snd_hdspm_hwdep_ioctl;
+	hw->ops.release = snd_hdspm_hwdep_dummy_op;
+
+	return 0;
+}
+
+
+/*------------------------------------------------------------
+   memory interface 
+ ------------------------------------------------------------*/
+static int __devinit snd_hdspm_preallocate_memory(hdspm_t * hdspm)
+{
+	int err;
+	snd_pcm_t *pcm;
+	size_t wanted;
+
+	pcm = hdspm->pcm;
+
+	wanted = HDSPM_DMA_AREA_BYTES + 4096;	/* dont know why, but it works */
+
+	if ((err =
+	     snd_pcm_lib_preallocate_pages_for_all(pcm,
+	     					   SNDRV_DMA_TYPE_DEV_SG,
+						   snd_dma_pci_data(hdspm->pci),
+						   wanted,
+						   wanted)) < 0) {
+		snd_printdd("Could not preallocate %d  Bytes\n", wanted);
+
+		return err;
+	} else
+		snd_printdd(" Preallocated %d  Bytes\n", wanted);
+
+	return 0;
+}
+
+static int snd_hdspm_memory_free(hdspm_t * hdspm)
+{
+	snd_printdd("memory_free_for_all %p\n", hdspm->pcm);
+
+	snd_pcm_lib_preallocate_free_for_all(hdspm->pcm);
+	return 0;
+}
+
+
+static void hdspm_set_sgbuf(hdspm_t * hdspm, struct snd_sg_buf *sgbuf,
+			     unsigned int reg, int channels)
+{
+	int i;
+	for (i = 0; i < (channels * 16); i++)
+		hdspm_write(hdspm, reg + 4 * i,
+			    snd_pcm_sgbuf_get_addr(sgbuf,
+						   (size_t) 4096 * i));
+}
+
+/* ------------- ALSA Devices ---------------------------- */
+static int __devinit snd_hdspm_create_pcm(snd_card_t * card,
+					  hdspm_t * hdspm)
+{
+	snd_pcm_t *pcm;
+	int err;
+
+	if ((err = snd_pcm_new(card, hdspm->card_name, 0, 1, 1, &pcm)) < 0)
+		return err;
+
+	hdspm->pcm = pcm;
+	pcm->private_data = hdspm;
+	strcpy(pcm->name, hdspm->card_name);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&snd_hdspm_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+			&snd_hdspm_capture_ops);
+
+	pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;
+
+	if ((err = snd_hdspm_preallocate_memory(hdspm)) < 0)
+		return err;
+
+	return 0;
+}
+
+static inline void snd_hdspm_initialize_midi_flush(hdspm_t * hdspm)
+{
+	snd_hdspm_flush_midi_input(hdspm, 0);
+	snd_hdspm_flush_midi_input(hdspm, 1);
+}
+
+static int __devinit snd_hdspm_create_alsa_devices(snd_card_t * card,
+						   hdspm_t * hdspm)
+{
+	int err;
+
+	snd_printdd("Create card...\n");
+	if ((err = snd_hdspm_create_pcm(card, hdspm)) < 0)
+		return err;
+
+	if ((err = snd_hdspm_create_midi(card, hdspm, 0)) < 0)
+		return err;
+
+	if ((err = snd_hdspm_create_midi(card, hdspm, 1)) < 0)
+		return err;
+
+	if ((err = snd_hdspm_create_controls(card, hdspm)) < 0)
+		return err;
+
+	if ((err = snd_hdspm_create_hwdep(card, hdspm)) < 0)
+		return err;
+
+	snd_printdd("proc init...\n");
+	snd_hdspm_proc_init(hdspm);
+
+	hdspm->system_sample_rate = -1;
+	hdspm->last_external_sample_rate = -1;
+	hdspm->last_internal_sample_rate = -1;
+	hdspm->playback_pid = -1;
+	hdspm->capture_pid = -1;
+	hdspm->capture_substream = NULL;
+	hdspm->playback_substream = NULL;
+
+	snd_printdd("Set defaults...\n");
+	if ((err = snd_hdspm_set_defaults(hdspm)) < 0)
+		return err;
+
+	snd_printdd("Update mixer controls...\n");
+	hdspm_update_simple_mixer_controls(hdspm);
+
+	snd_printdd("Initializeing complete ???\n");
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_printk(KERN_ERR "HDSPM: error registering card\n");
+		return err;
+	}
+
+	snd_printdd("... yes now\n");
+
+	return 0;
+}
+
+static int __devinit snd_hdspm_create(snd_card_t * card, hdspm_t * hdspm,
+				      int precise_ptr, int enable_monitor)
+{
+	struct pci_dev *pci = hdspm->pci;
+	int err;
+	int i;
+
+	unsigned long io_extent;
+
+	hdspm->irq = -1;
+	hdspm->irq_count = 0;
+
+	hdspm->midi[0].rmidi = NULL;
+	hdspm->midi[1].rmidi = NULL;
+	hdspm->midi[0].input = NULL;
+	hdspm->midi[1].input = NULL;
+	hdspm->midi[0].output = NULL;
+	hdspm->midi[1].output = NULL;
+	spin_lock_init(&hdspm->midi[0].lock);
+	spin_lock_init(&hdspm->midi[1].lock);
+	hdspm->iobase = NULL;
+	hdspm->control_register = 0;
+	hdspm->control2_register = 0;
+
+	hdspm->playback_buffer = NULL;
+	hdspm->capture_buffer = NULL;
+
+	for (i = 0; i < HDSPM_MAX_CHANNELS; ++i)
+		hdspm->playback_mixer_ctls[i] = NULL;
+	hdspm->mixer = NULL;
+
+	hdspm->card = card;
+
+	spin_lock_init(&hdspm->lock);
+
+	tasklet_init(&hdspm->midi_tasklet,
+		     hdspm_midi_tasklet, (unsigned long) hdspm);
+
+	pci_read_config_word(hdspm->pci,
+			     PCI_CLASS_REVISION, &hdspm->firmware_rev);
+
+	strcpy(card->driver, "HDSPM");
+	strcpy(card->mixername, "Xilinx FPGA");
+	hdspm->card_name = "RME HDSPM MADI";
+
+	if ((err = pci_enable_device(pci)) < 0)
+		return err;
+
+	pci_set_master(hdspm->pci);
+
+	if ((err = pci_request_regions(pci, "hdspm")) < 0)
+		return err;
+
+	hdspm->port = pci_resource_start(pci, 0);
+	io_extent = pci_resource_len(pci, 0);
+
+	snd_printdd("grabbed memory region 0x%lx-0x%lx\n",
+		   hdspm->port, hdspm->port + io_extent - 1);
+
+
+	if ((hdspm->iobase = ioremap_nocache(hdspm->port, io_extent)) == NULL) {
+		snd_printk(KERN_ERR "HDSPM: unable to remap region 0x%lx-0x%lx\n",
+			   hdspm->port, hdspm->port + io_extent - 1);
+		return -EBUSY;
+	}
+	snd_printdd("remapped region (0x%lx) 0x%lx-0x%lx\n",
+		   (unsigned long)hdspm->iobase, hdspm->port,
+		   hdspm->port + io_extent - 1);
+
+	if (request_irq(pci->irq, snd_hdspm_interrupt,
+			SA_INTERRUPT | SA_SHIRQ, "hdspm",
+			(void *) hdspm)) {
+		snd_printk(KERN_ERR "HDSPM: unable to use IRQ %d\n", pci->irq);
+		return -EBUSY;
+	}
+
+	snd_printdd("use IRQ %d\n", pci->irq);
+
+	hdspm->irq = pci->irq;
+	hdspm->precise_ptr = precise_ptr;
+
+	hdspm->monitor_outs = enable_monitor;
+
+	snd_printdd("kmalloc Mixer memory of %d Bytes\n",
+		   sizeof(hdspm_mixer_t));
+	if ((hdspm->mixer =
+	     (hdspm_mixer_t *) kmalloc(sizeof(hdspm_mixer_t), GFP_KERNEL))
+	    == NULL) {
+		snd_printk(KERN_ERR "HDSPM: unable to kmalloc Mixer memory of %d Bytes\n",
+			   (int)sizeof(hdspm_mixer_t));
+		return err;
+	}
+
+	hdspm->ss_channels = MADI_SS_CHANNELS;
+	hdspm->ds_channels = MADI_DS_CHANNELS;
+	hdspm->qs_channels = MADI_QS_CHANNELS;
+
+	snd_printdd("create alsa devices.\n");
+	if ((err = snd_hdspm_create_alsa_devices(card, hdspm)) < 0)
+		return err;
+
+	snd_hdspm_initialize_midi_flush(hdspm);
+
+	return 0;
+}
+
+static int snd_hdspm_free(hdspm_t * hdspm)
+{
+
+	if (hdspm->port) {
+
+		/* stop th audio, and cancel all interrupts */
+		hdspm->control_register &=
+		    ~(HDSPM_Start | HDSPM_AudioInterruptEnable
+		      | HDSPM_Midi0InterruptEnable |
+		      HDSPM_Midi1InterruptEnable);
+		hdspm_write(hdspm, HDSPM_controlRegister,
+			    hdspm->control_register);
+	}
+
+	if (hdspm->irq >= 0)
+		free_irq(hdspm->irq, (void *) hdspm);
+
+
+	if (hdspm->mixer)
+		kfree(hdspm->mixer);
+
+	if (hdspm->iobase)
+		iounmap(hdspm->iobase);
+
+	snd_hdspm_memory_free(hdspm);
+
+	if (hdspm->port)
+		pci_release_regions(hdspm->pci);
+
+	pci_disable_device(hdspm->pci);
+	return 0;
+}
+
+static void snd_hdspm_card_free(snd_card_t * card)
+{
+	hdspm_t *hdspm = (hdspm_t *) card->private_data;
+
+	if (hdspm)
+		snd_hdspm_free(hdspm);
+}
+
+static int __devinit snd_hdspm_probe(struct pci_dev *pci,
+				     const struct pci_device_id *pci_id)
+{
+	static int dev;
+	hdspm_t *hdspm;
+	snd_card_t *card;
+	int err;
+
+	if (dev >= SNDRV_CARDS)
+		return -ENODEV;
+	if (!enable[dev]) {
+		dev++;
+		return -ENOENT;
+	}
+
+	if (!(card = snd_card_new(index[dev], id[dev],
+				  THIS_MODULE, sizeof(hdspm_t))))
+		return -ENOMEM;
+
+	hdspm = (hdspm_t *) card->private_data;
+	card->private_free = snd_hdspm_card_free;
+	hdspm->dev = dev;
+	hdspm->pci = pci;
+
+	if ((err =
+	     snd_hdspm_create(card, hdspm, precise_ptr[dev],
+			      enable_monitor[dev])) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	strcpy(card->shortname, "HDSPM MADI");
+	sprintf(card->longname, "%s at 0x%lx, irq %d", hdspm->card_name,
+		hdspm->port, hdspm->irq);
+
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	pci_set_drvdata(pci, card);
+
+	dev++;
+	return 0;
+}
+
+static void __devexit snd_hdspm_remove(struct pci_dev *pci)
+{
+	snd_card_free(pci_get_drvdata(pci));
+	pci_set_drvdata(pci, NULL);
+}
+
+static struct pci_driver driver = {
+	.name = "RME Hammerfall DSP MADI",
+	.id_table = snd_hdspm_ids,
+	.probe = snd_hdspm_probe,
+	.remove = __devexit_p(snd_hdspm_remove),
+};
+
+
+static int __init alsa_card_hdspm_init(void)
+{
+	return pci_register_driver(&driver);
+}
+
+static void __exit alsa_card_hdspm_exit(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+module_init(alsa_card_hdspm_init)
+module_exit(alsa_card_hdspm_exit)
